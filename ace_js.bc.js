//# 1 "ace_js.bc.runtime.js"
// Generated by js_of_ocaml 3.9.1
(function(joo_global_object)
   {"use strict";
    function caml_int64_is_zero(x){return + x.isZero()}
    function caml_str_repeat(n,s)
     {if(n == 0)return "";
      if(s.repeat)return s.repeat(n);
      var r="",l=0;
      for(;;)
       {if(n & 1)r += s;
        n >>= 1;
        if(n == 0)return r;
        s += s;
        l++;
        if(l == 9)s.slice(0,1)}}
    var caml_int64_offset=Math.pow(2,- 24);
    function caml_raise_constant(tag){throw tag}
    var caml_global_data=[0];
    function caml_raise_zero_divide()
     {caml_raise_constant(caml_global_data.Division_by_zero)}
    function MlInt64(lo,mi,hi)
     {this.lo = lo & 0xffffff;this.mi = mi & 0xffffff;this.hi = hi & 0xffff}
    MlInt64.prototype.caml_custom = "_j";
    MlInt64.prototype.copy
    =
    function(){return new MlInt64(this.lo,this.mi,this.hi)};
    MlInt64.prototype.ucompare
    =
    function(x)
     {if(this.hi > x.hi)return 1;
      if(this.hi < x.hi)return - 1;
      if(this.mi > x.mi)return 1;
      if(this.mi < x.mi)return - 1;
      if(this.lo > x.lo)return 1;
      if(this.lo < x.lo)return - 1;
      return 0};
    MlInt64.prototype.compare
    =
    function(x)
     {var hi=this.hi << 16,xhi=x.hi << 16;
      if(hi > xhi)return 1;
      if(hi < xhi)return - 1;
      if(this.mi > x.mi)return 1;
      if(this.mi < x.mi)return - 1;
      if(this.lo > x.lo)return 1;
      if(this.lo < x.lo)return - 1;
      return 0};
    MlInt64.prototype.neg
    =
    function()
     {var lo=- this.lo,mi=- this.mi + (lo >> 24),hi=- this.hi + (mi >> 24);
      return new MlInt64(lo,mi,hi)};
    MlInt64.prototype.add
    =
    function(x)
     {var
       lo=this.lo + x.lo,
       mi=this.mi + x.mi + (lo >> 24),
       hi=this.hi + x.hi + (mi >> 24);
      return new MlInt64(lo,mi,hi)};
    MlInt64.prototype.sub
    =
    function(x)
     {var
       lo=this.lo - x.lo,
       mi=this.mi - x.mi + (lo >> 24),
       hi=this.hi - x.hi + (mi >> 24);
      return new MlInt64(lo,mi,hi)};
    MlInt64.prototype.mul
    =
    function(x)
     {var
       lo=this.lo * x.lo,
       mi=(lo * caml_int64_offset | 0) + this.mi * x.lo + this.lo * x.mi,
       hi=
        (mi * caml_int64_offset | 0)
        +
        this.hi
        *
        x.lo
        +
        this.mi
        *
        x.mi
        +
        this.lo
        *
        x.hi;
      return new MlInt64(lo,mi,hi)};
    MlInt64.prototype.isZero
    =
    function(){return (this.lo | this.mi | this.hi) == 0};
    MlInt64.prototype.isNeg = function(){return this.hi << 16 < 0};
    MlInt64.prototype.and
    =
    function(x)
     {return new MlInt64(this.lo & x.lo,this.mi & x.mi,this.hi & x.hi)};
    MlInt64.prototype.or
    =
    function(x)
     {return new MlInt64(this.lo | x.lo,this.mi | x.mi,this.hi | x.hi)};
    MlInt64.prototype.xor
    =
    function(x)
     {return new MlInt64(this.lo ^ x.lo,this.mi ^ x.mi,this.hi ^ x.hi)};
    MlInt64.prototype.shift_left
    =
    function(s)
     {s = s & 63;
      if(s == 0)return this;
      if(s < 24)
       return new
               MlInt64
               (this.lo << s,
                this.mi << s | this.lo >> 24 - s,
                this.hi << s | this.mi >> 24 - s);
      if(s < 48)
       return new
               MlInt64
               (0,this.lo << s - 24,this.mi << s - 24 | this.lo >> 48 - s);
      return new MlInt64(0,0,this.lo << s - 48)};
    MlInt64.prototype.shift_right_unsigned
    =
    function(s)
     {s = s & 63;
      if(s == 0)return this;
      if(s < 24)
       return new
               MlInt64
               (this.lo >> s | this.mi << 24 - s,
                this.mi >> s | this.hi << 24 - s,
                this.hi >> s);
      if(s < 48)
       return new
               MlInt64
               (this.mi >> s - 24 | this.hi << 48 - s,this.hi >> s - 24,0);
      return new MlInt64(this.hi >> s - 48,0,0)};
    MlInt64.prototype.shift_right
    =
    function(s)
     {s = s & 63;
      if(s == 0)return this;
      var h=this.hi << 16 >> 16;
      if(s < 24)
       return new
               MlInt64
               (this.lo >> s | this.mi << 24 - s,
                this.mi >> s | h << 24 - s,
                this.hi << 16 >> s >>> 16);
      var sign=this.hi << 16 >> 31;
      if(s < 48)
       return new
               MlInt64
               (this.mi >> s - 24 | this.hi << 48 - s,
                this.hi << 16 >> s - 24 >> 16,
                sign & 0xffff);
      return new MlInt64(this.hi << 16 >> s - 32,sign,sign)};
    MlInt64.prototype.lsl1
    =
    function()
     {this.hi = this.hi << 1 | this.mi >> 23;
      this.mi = (this.mi << 1 | this.lo >> 23) & 0xffffff;
      this.lo = this.lo << 1 & 0xffffff};
    MlInt64.prototype.lsr1
    =
    function()
     {this.lo = (this.lo >>> 1 | this.mi << 23) & 0xffffff;
      this.mi = (this.mi >>> 1 | this.hi << 23) & 0xffffff;
      this.hi = this.hi >>> 1};
    MlInt64.prototype.udivmod
    =
    function(x)
     {var
       offset=0,
       modulus=this.copy(),
       divisor=x.copy(),
       quotient=new MlInt64(0,0,0);
      while(modulus.ucompare(divisor) > 0){offset++;divisor.lsl1()}
      while(offset >= 0)
       {offset--;
        quotient.lsl1();
        if(modulus.ucompare(divisor) >= 0)
         {quotient.lo++;modulus = modulus.sub(divisor)}
        divisor.lsr1()}
      return {quotient:quotient,modulus:modulus}};
    MlInt64.prototype.div
    =
    function(y)
     {var x=this;
      if(y.isZero())caml_raise_zero_divide();
      var sign=x.hi ^ y.hi;
      if(x.hi & 0x8000)x = x.neg();
      if(y.hi & 0x8000)y = y.neg();
      var q=x.udivmod(y).quotient;
      if(sign & 0x8000)q = q.neg();
      return q};
    MlInt64.prototype.mod
    =
    function(y)
     {var x=this;
      if(y.isZero())caml_raise_zero_divide();
      var sign=x.hi;
      if(x.hi & 0x8000)x = x.neg();
      if(y.hi & 0x8000)y = y.neg();
      var r=x.udivmod(y).modulus;
      if(sign & 0x8000)r = r.neg();
      return r};
    MlInt64.prototype.toInt = function(){return this.lo | this.mi << 24};
    MlInt64.prototype.toFloat
    =
    function()
     {return (this.hi << 16)
             *
             Math.pow(2,32)
             +
             this.mi
             *
             Math.pow(2,24)
             +
             this.lo};
    MlInt64.prototype.toArray
    =
    function()
     {return [this.hi >> 8,
              this.hi & 0xff,
              this.mi >> 16,
              this.mi >> 8 & 0xff,
              this.mi & 0xff,
              this.lo >> 16,
              this.lo >> 8 & 0xff,
              this.lo & 0xff]};
    MlInt64.prototype.lo32
    =
    function(){return this.lo | (this.mi & 0xff) << 24};
    MlInt64.prototype.hi32
    =
    function(){return this.mi >>> 8 & 0xffff | this.hi << 16};
    function caml_int64_of_int32(x)
     {return new MlInt64(x & 0xffffff,x >> 24 & 0xffffff,x >> 31 & 0xffff)}
    function caml_int64_to_int32(x){return x.toInt()}
    function caml_int64_is_negative(x){return + x.isNeg()}
    function caml_int64_neg(x){return x.neg()}
    function caml_subarray_to_jsbytes(a,i,len)
     {var f=String.fromCharCode;
      if(i == 0 && len <= 4096 && len == a.length)return f.apply(null,a);
      var s="";
      for(;0 < len;i += 1024,len -= 1024)
       s += f.apply(null,a.slice(i,i + Math.min(len,1024)));
      return s}
    function caml_convert_string_to_bytes(s)
     {if(s.t == 2)
       s.c += caml_str_repeat(s.l - s.c.length,"\0");
      else
       s.c = caml_subarray_to_jsbytes(s.c,0,s.c.length);
      s.t = 0}
    function caml_jsbytes_of_string(s)
     {if((s.t & 6) != 0)caml_convert_string_to_bytes(s);return s.c}
    function caml_raise_with_arg(tag,arg){throw [0,tag,arg]}
    function jsoo_is_ascii(s)
     {if(s.length < 24)
       {for(var i=0;i < s.length;i++)if(s.charCodeAt(i) > 127)return false;
        return true}
      else
       return ! /[^\x00-\x7f]/.test(s)}
    function caml_utf16_of_utf8(s)
     {for(var b="",t="",c,c1,c2,v,i=0,l=s.length;i < l;i++)
       {c1 = s.charCodeAt(i);
        if(c1 < 0x80)
         {for(var j=i + 1;j < l && (c1 = s.charCodeAt(j)) < 0x80;j++);
          if(j - i > 512)
           {t.substr(0,1);b += t;t = "";b += s.slice(i,j)}
          else
           t += s.slice(i,j);
          if(j == l)break;
          i = j}
        v = 1;
        if(++i < l && ((c2 = s.charCodeAt(i)) & - 64) == 128)
         {c = c2 + (c1 << 6);
          if(c1 < 0xe0)
           {v = c - 0x3080;if(v < 0x80)v = 1}
          else
           {v = 2;
            if(++i < l && ((c2 = s.charCodeAt(i)) & - 64) == 128)
             {c = c2 + (c << 6);
              if(c1 < 0xf0)
               {v = c - 0xe2080;
                if(v < 0x800 || v >= 0xd7ff && v < 0xe000)v = 2}
              else
               {v = 3;
                if
                 (++i
                  <
                  l
                  &&
                  ((c2 = s.charCodeAt(i)) & - 64)
                  ==
                  128
                  &&
                  c1
                  <
                  0xf5)
                 {v = c2 - 0x3c82080 + (c << 6);
                  if(v < 0x10000 || v > 0x10ffff)v = 3}}}}}
        if(v < 4)
         {i -= v;t += "\ufffd"}
        else
         if(v > 0xffff)
          t += String.fromCharCode(0xd7c0 + (v >> 10),0xdc00 + (v & 0x3FF));
         else
          t += String.fromCharCode(v);
        if(t.length > 1024){t.substr(0,1);b += t;t = ""}}
      return b + t}
    function MlBytes(tag,contents,length)
     {this.t = tag;this.c = contents;this.l = length}
    MlBytes.prototype.toString
    =
    function()
     {switch(this.t)
       {case 9:return this.c;
        default:caml_convert_string_to_bytes(this);case 0:
         if(jsoo_is_ascii(this.c)){this.t = 9;return this.c}this.t = 8;
        case 8:return this.c
        }};
    MlBytes.prototype.toUtf16
    =
    function()
     {var r=this.toString();
      if(this.t == 9)return r;
      return caml_utf16_of_utf8(r)};
    MlBytes.prototype.slice
    =
    function()
     {var content=this.t == 4?this.c.slice():this.c;
      return new MlBytes(this.t,content,this.l)};
    function caml_bytes_of_jsbytes(s){return new MlBytes(0,s,s.length)}
    function caml_string_of_jsbytes(s){return caml_bytes_of_jsbytes(s)}
    function caml_raise_with_string(tag,msg)
     {caml_raise_with_arg(tag,caml_string_of_jsbytes(msg))}
    function caml_invalid_argument(msg)
     {caml_raise_with_string(caml_global_data.Invalid_argument,msg)}
    function caml_parse_format(fmt)
     {fmt = caml_jsbytes_of_string(fmt);
      var len=fmt.length;
      if(len > 31)caml_invalid_argument("format_int: format too long");
      var
       f=
        {justify:"+",
         signstyle:"-",
         filler:" ",
         alternate:false,
         base:0,
         signedconv:false,
         width:0,
         uppercase:false,
         sign:1,
         prec:- 1,
         conv:"f"};
      for(var i=0;i < len;i++)
       {var c=fmt.charAt(i);
        switch(c)
         {case "-":f.justify = "-";break;
          case "+":
          case " ":f.signstyle = c;break;
          case "0":f.filler = "0";break;
          case "#":f.alternate = true;break;
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9":
           f.width = 0;
           while(c = fmt.charCodeAt(i) - 48,c >= 0 && c <= 9)
            {f.width = f.width * 10 + c;i++}
           i--;
           break;
          case ".":
           f.prec = 0;
           i++;
           while(c = fmt.charCodeAt(i) - 48,c >= 0 && c <= 9)
            {f.prec = f.prec * 10 + c;i++}
           i--;
          case "d":
          case "i":f.signedconv = true;
          case "u":f.base = 10;break;
          case "x":f.base = 16;break;
          case "X":f.base = 16;f.uppercase = true;break;
          case "o":f.base = 8;break;
          case "e":
          case "f":
          case "g":f.signedconv = true;f.conv = c;break;
          case "E":
          case "F":
          case "G":
           f.signedconv = true;
           f.uppercase = true;
           f.conv = c.toLowerCase();
           break
          }}
      return f}
    function caml_finish_formatting(f,rawbuffer)
     {if(f.uppercase)rawbuffer = rawbuffer.toUpperCase();
      var len=rawbuffer.length;
      if(f.signedconv && (f.sign < 0 || f.signstyle != "-"))len++;
      if(f.alternate){if(f.base == 8)len += 1;if(f.base == 16)len += 2}
      var buffer="";
      if(f.justify == "+" && f.filler == " ")
       for(var i=len;i < f.width;i++)buffer += " ";
      if(f.signedconv)
       if(f.sign < 0)
        buffer += "-";
       else
        if(f.signstyle != "-")buffer += f.signstyle;
      if(f.alternate && f.base == 8)buffer += "0";
      if(f.alternate && f.base == 16)buffer += "0x";
      if(f.justify == "+" && f.filler == "0")
       for(var i=len;i < f.width;i++)buffer += "0";
      buffer += rawbuffer;
      if(f.justify == "-")for(var i=len;i < f.width;i++)buffer += " ";
      return caml_string_of_jsbytes(buffer)}
    function caml_int64_format(fmt,x)
     {var f=caml_parse_format(fmt);
      if(f.signedconv && caml_int64_is_negative(x))
       {f.sign = - 1;x = caml_int64_neg(x)}
      var
       buffer="",
       wbase=caml_int64_of_int32(f.base),
       cvtbl="0123456789abcdef";
      do
       {var p=x.udivmod(wbase);
        x = p.quotient;
        buffer = cvtbl.charAt(caml_int64_to_int32(p.modulus)) + buffer}
      while
       (! caml_int64_is_zero(x));
      if(f.prec >= 0)
       {f.filler = " ";
        var n=f.prec - buffer.length;
        if(n > 0)buffer = caml_str_repeat(n,"0") + buffer}
      return caml_finish_formatting(f,buffer)}
    function caml_expm1_float(x)
     {var y=Math.exp(x),z=y - 1;
      return Math.abs(x) > 1?z:z == 0?x:x * z / Math.log(y)}
    function caml_jsstring_of_string(s){return s.toUtf16()}
    if(joo_global_object.process && joo_global_object.process.cwd)
     var caml_current_dir=joo_global_object.process.cwd().replace(/\\/g,"/");
    else
     var caml_current_dir="/static";
    if(caml_current_dir.slice(- 1) !== "/")caml_current_dir += "/";
    function caml_make_path(name)
     {name = caml_jsstring_of_string(name);
      if(name.charCodeAt(0) != 47)name = caml_current_dir + name;
      var comp=name.split("/"),ncomp=[];
      for(var i=0;i < comp.length;i++)
       switch(comp[i])
        {case "..":if(ncomp.length > 1)ncomp.pop();break;
         case ".":break;
         case "":if(ncomp.length == 0)ncomp.push("");break;
         default:ncomp.push(comp[i]);break}
      ncomp.orig = name;
      return ncomp}
    function caml_is_ml_bytes(s){return s instanceof MlBytes}
    function caml_is_ml_string(s){return caml_is_ml_bytes(s)}
    function caml_bytes_of_array(a){return new MlBytes(4,a,a.length)}
    function caml_bytes_of_string(s){return s}
    function caml_utf8_of_utf16(s)
     {for(var b="",t=b,c,d,i=0,l=s.length;i < l;i++)
       {c = s.charCodeAt(i);
        if(c < 0x80)
         {for(var j=i + 1;j < l && (c = s.charCodeAt(j)) < 0x80;j++);
          if(j - i > 512)
           {t.substr(0,1);b += t;t = "";b += s.slice(i,j)}
          else
           t += s.slice(i,j);
          if(j == l)break;
          i = j}
        if(c < 0x800)
         {t += String.fromCharCode(0xc0 | c >> 6);
          t += String.fromCharCode(0x80 | c & 0x3f)}
        else
         if(c < 0xd800 || c >= 0xdfff)
          t
          +=
          String.fromCharCode
           (0xe0 | c >> 12,0x80 | c >> 6 & 0x3f,0x80 | c & 0x3f);
         else
          if
           (c
            >=
            0xdbff
            ||
            i
            +
            1
            ==
            l
            ||
            (d = s.charCodeAt(i + 1))
            <
            0xdc00
            ||
            d
            >
            0xdfff)
           t += "\xef\xbf\xbd";
          else
           {i++;
            c = (c << 10) + d - 0x35fdc00;
            t
            +=
            String.fromCharCode
             (0xf0 | c >> 18,
              0x80 | c >> 12 & 0x3f,
              0x80 | c >> 6 & 0x3f,
              0x80 | c & 0x3f)}
        if(t.length > 1024){t.substr(0,1);b += t;t = ""}}
      return b + t}
    function caml_bytes_of_utf16_jsstring(s)
     {var tag=9;
      if(! jsoo_is_ascii(s))tag = 8,s = caml_utf8_of_utf16(s);
      return new MlBytes(tag,s,s.length)}
    function caml_string_of_jsstring(s)
     {return caml_bytes_of_utf16_jsstring(s)}
    function caml_raise_sys_error(msg)
     {caml_raise_with_string(caml_global_data.Sys_error,msg)}
    function caml_raise_no_such_file(name)
     {name = caml_jsbytes_of_string(name);
      caml_raise_sys_error(name + ": No such file or directory")}
    function caml_bytes_bound_error()
     {caml_invalid_argument("index out of bounds")}
    function caml_bytes_unsafe_get(s,i)
     {switch(s.t & 6)
       {default:if(i >= s.c.length)return 0;case 0:return s.c.charCodeAt(i);
        case 4:return s.c[i]
        }}
    function caml_bytes_get(s,i)
     {if(i >>> 0 >= s.l)caml_bytes_bound_error();
      return caml_bytes_unsafe_get(s,i)}
    function caml_create_bytes(len)
     {if(len < 0)caml_invalid_argument("Bytes.create");
      return new MlBytes(len?2:9,"",len)}
    function caml_ml_bytes_length(s){return s.l}
    function caml_convert_bytes_to_array(s)
     {if(joo_global_object.Uint8Array)
       var a=new (joo_global_object.Uint8Array)(s.l);
      else
       var a=new Array(s.l);
      var b=s.c,l=b.length,i=0;
      for(;i < l;i++)a[i] = b.charCodeAt(i);
      for(l = s.l;i < l;i++)a[i] = 0;
      s.c = a;
      s.t = 4;
      return a}
    function caml_blit_bytes(s1,i1,s2,i2,len)
     {if(len == 0)return 0;
      if(i2 == 0 && (len >= s2.l || s2.t == 2 && len >= s2.c.length))
       {s2.c
        =
        s1.t == 4
         ?caml_subarray_to_jsbytes(s1.c,i1,len)
         :i1 == 0 && s1.c.length == len?s1.c:s1.c.substr(i1,len);
        s2.t = s2.c.length == s2.l?0:2}
      else
       if(s2.t == 2 && i2 == s2.c.length)
        {s2.c
         +=
         s1.t == 4
          ?caml_subarray_to_jsbytes(s1.c,i1,len)
          :i1 == 0 && s1.c.length == len?s1.c:s1.c.substr(i1,len);
         s2.t = s2.c.length == s2.l?0:2}
       else
        {if(s2.t != 4)caml_convert_bytes_to_array(s2);
         var c1=s1.c,c2=s2.c;
         if(s1.t == 4)
          if(i2 <= i1)
           for(var i=0;i < len;i++)c2[i2 + i] = c1[i1 + i];
          else
           for(var i=len - 1;i >= 0;i--)c2[i2 + i] = c1[i1 + i];
         else
          {var l=Math.min(len,c1.length - i1);
           for(var i=0;i < l;i++)c2[i2 + i] = c1.charCodeAt(i1 + i);
           for(;i < len;i++)c2[i2 + i] = 0}}
      return 0}
    function caml_blit_string(a,b,c,d,e)
     {caml_blit_bytes(caml_bytes_of_string(a),b,c,d,e);return 0}
    function MlFile(){}
    function MlFakeFile(content){this.data = content}
    MlFakeFile.prototype = new MlFile();
    MlFakeFile.prototype.truncate
    =
    function(len)
     {var old=this.data;
      this.data = caml_create_bytes(len | 0);
      caml_blit_bytes(old,0,this.data,0,len)};
    MlFakeFile.prototype.length
    =
    function(){return caml_ml_bytes_length(this.data)};
    MlFakeFile.prototype.write
    =
    function(offset,buf,pos,len)
     {var clen=this.length();
      if(offset + len >= clen)
       {var new_str=caml_create_bytes(offset + len),old_data=this.data;
        this.data = new_str;
        caml_blit_bytes(old_data,0,this.data,0,clen)}
      caml_blit_string(buf,pos,this.data,offset,len);
      return 0};
    MlFakeFile.prototype.read
    =
    function(offset,buf,pos,len)
     {var clen=this.length();
      caml_blit_bytes(this.data,offset,buf,pos,len);
      return 0};
    MlFakeFile.prototype.read_one
    =
    function(offset){return caml_bytes_get(this.data,offset)};
    MlFakeFile.prototype.close = function(){};
    MlFakeFile.prototype.constructor = MlFakeFile;
    function MlFakeDevice(root,f)
     {this.content = {};this.root = root;this.lookupFun = f}
    MlFakeDevice.prototype.nm = function(name){return this.root + name};
    MlFakeDevice.prototype.lookup
    =
    function(name)
     {if(! this.content[name] && this.lookupFun)
       {var
         res=
          this.lookupFun
           (caml_string_of_jsbytes(this.root),caml_string_of_jsbytes(name));
        if(res !== 0)
         this.content[name] = new MlFakeFile(caml_bytes_of_string(res[1]))}};
    MlFakeDevice.prototype.exists
    =
    function(name)
     {if(name == "")return 1;
      var name_slash=name + "/",r=new RegExp("^" + name_slash);
      for(var n in this.content)if(n.match(r))return 1;
      this.lookup(name);
      return this.content[name]?1:0};
    MlFakeDevice.prototype.readdir
    =
    function(name)
     {var
       name_slash=name == ""?"":name + "/",
       r=new RegExp("^" + name_slash + "([^/]*)"),
       seen={},
       a=[];
      for(var n in this.content)
       {var m=n.match(r);
        if(m && ! seen[m[1]]){seen[m[1]] = true;a.push(m[1])}}
      return a};
    MlFakeDevice.prototype.is_dir
    =
    function(name)
     {var
       name_slash=name == ""?"":name + "/",
       r=new RegExp("^" + name_slash + "([^/]*)"),
       a=[];
      for(var n in this.content){var m=n.match(r);if(m)return 1}
      return 0};
    MlFakeDevice.prototype.unlink
    =
    function(name)
     {var ok=this.content[name]?true:false;
      delete this.content[name];
      return ok};
    MlFakeDevice.prototype.open
    =
    function(name,f)
     {if(f.rdonly && f.wronly)
       caml_raise_sys_error
        (this.nm(name)
         +
         " : flags Open_rdonly and Open_wronly are not compatible");
      if(f.text && f.binary)
       caml_raise_sys_error
        (this.nm(name)
         +
         " : flags Open_text and Open_binary are not compatible");
      this.lookup(name);
      if(this.content[name])
       {if(this.is_dir(name))
         caml_raise_sys_error(this.nm(name) + " : is a directory");
        if(f.create && f.excl)
         caml_raise_sys_error(this.nm(name) + " : file already exists");
        var file=this.content[name];
        if(f.truncate)file.truncate();
        return file}
      else
       if(f.create)
        {this.content[name] = new MlFakeFile(caml_create_bytes(0));
         return this.content[name]}
       else
        caml_raise_no_such_file(this.nm(name))};
    MlFakeDevice.prototype.register
    =
    function(name,content)
     {if(this.content[name])
       caml_raise_sys_error(this.nm(name) + " : file already exists");
      if(caml_is_ml_bytes(content))
       this.content[name] = new MlFakeFile(content);
      if(caml_is_ml_string(content))
       this.content[name] = new MlFakeFile(caml_bytes_of_string(content));
      else
       if(content instanceof Array)
        this.content[name] = new MlFakeFile(caml_bytes_of_array(content));
       else
        if(typeof content === "string")
         this.content[name] = new MlFakeFile(caml_bytes_of_jsbytes(content));
        else
         if(content.toString)
          {var
            bytes=
             caml_bytes_of_string(caml_string_of_jsstring(content.toString()));
           this.content[name] = new MlFakeFile(bytes)}
         else
          caml_raise_sys_error
           (this.nm(name) + " : registering file with invalid content type")};
    MlFakeDevice.prototype.constructor = MlFakeDevice;
    function caml_ml_string_length(s){return caml_ml_bytes_length(s)}
    function caml_string_unsafe_get(s,i){return caml_bytes_unsafe_get(s,i)}
    function caml_array_of_string(s)
     {var l=caml_ml_string_length(s),a=new Array(l),i=0;
      for(;i < l;i++)a[i] = caml_string_unsafe_get(s,i);
      return a}
    function caml_array_of_bytes(s)
     {if(s.t != 4)caml_convert_bytes_to_array(s);return s.c}
    function caml_bytes_unsafe_set(s,i,c)
     {c &= 0xff;
      if(s.t != 4)
       {if(i == s.c.length)
         {s.c += String.fromCharCode(c);if(i + 1 == s.l)s.t = 0;return 0}
        caml_convert_bytes_to_array(s)}
      s.c[i] = c;
      return 0}
    function caml_bytes_set(s,i,c)
     {if(i >>> 0 >= s.l)caml_bytes_bound_error();
      return caml_bytes_unsafe_set(s,i,c)}
    function MlNodeFile(fd){this.fs = require("fs");this.fd = fd}
    MlNodeFile.prototype = new MlFile();
    MlNodeFile.prototype.truncate
    =
    function(len)
     {try
       {this.fs.ftruncateSync(this.fd,len | 0)}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeFile.prototype.length
    =
    function()
     {try
       {return this.fs.fstatSync(this.fd).size}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeFile.prototype.write
    =
    function(offset,buf,buf_offset,len)
     {var a=caml_array_of_string(buf);
      if(! (a instanceof joo_global_object.Uint8Array))
       a = new (joo_global_object.Uint8Array)(a);
      var buffer=joo_global_object.Buffer.from(a);
      try
       {this.fs.writeSync(this.fd,buffer,buf_offset,len,offset)}
      catch(err){caml_raise_sys_error(err.toString())}
      return 0};
    MlNodeFile.prototype.read
    =
    function(offset,buf,buf_offset,len)
     {var a=caml_array_of_bytes(buf);
      if(! (a instanceof joo_global_object.Uint8Array))
       a = new (joo_global_object.Uint8Array)(a);
      var buffer=joo_global_object.Buffer.from(a);
      try
       {this.fs.readSync(this.fd,buffer,buf_offset,len,offset)}
      catch(err){caml_raise_sys_error(err.toString())}
      for(var i=0;i < len;i++)
       caml_bytes_set(buf,buf_offset + i,buffer[buf_offset + i]);
      return 0};
    MlNodeFile.prototype.read_one
    =
    function(offset)
     {var
       a=new (joo_global_object.Uint8Array)(1),
       buffer=joo_global_object.Buffer.from(a);
      try
       {this.fs.readSync(this.fd,buffer,0,1,offset)}
      catch(err){caml_raise_sys_error(err.toString())}
      return buffer[0]};
    MlNodeFile.prototype.close
    =
    function()
     {try
       {this.fs.closeSync(this.fd)}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeFile.prototype.constructor = MlNodeFile;
    function MlNodeDevice(root){this.fs = require("fs");this.root = root}
    MlNodeDevice.prototype.nm = function(name){return this.root + name};
    MlNodeDevice.prototype.exists
    =
    function(name)
     {try
       {return this.fs.existsSync(this.nm(name))?1:0}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeDevice.prototype.readdir
    =
    function(name)
     {try
       {return this.fs.readdirSync(this.nm(name))}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeDevice.prototype.is_dir
    =
    function(name)
     {try
       {return this.fs.statSync(this.nm(name)).isDirectory()?1:0}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeDevice.prototype.unlink
    =
    function(name)
     {try
       {var b=this.fs.existsSync(this.nm(name))?1:0;
        this.fs.unlinkSync(this.nm(name))}
      catch(err){caml_raise_sys_error(err.toString())}
      return b};
    MlNodeDevice.prototype.open
    =
    function(name,f)
     {var consts=require("constants"),res=0;
      for(var key in f)
       switch(key)
        {case "rdonly":res |= consts.O_RDONLY;break;
         case "wronly":res |= consts.O_WRONLY;break;
         case "append":res |= consts.O_WRONLY | consts.O_APPEND;break;
         case "create":res |= consts.O_CREAT;break;
         case "truncate":res |= consts.O_TRUNC;break;
         case "excl":res |= consts.O_EXCL;break;
         case "binary":res |= consts.O_BINARY;break;
         case "text":res |= consts.O_TEXT;break;
         case "nonblock":res |= consts.O_NONBLOCK;break
         }
      try
       {var fd=this.fs.openSync(this.nm(name),res);return new MlNodeFile(fd)}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeDevice.prototype.rename
    =
    function(o,n)
     {try
       {this.fs.renameSync(this.nm(o),this.nm(n))}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeDevice.prototype.constructor = MlNodeDevice;
    var caml_root=caml_current_dir.match(/[^\/]*\//)[0];
    function fs_node_supported()
     {return typeof joo_global_object.process
             !==
             "undefined"
             &&
             typeof joo_global_object.process.versions
             !==
             "undefined"
             &&
             typeof joo_global_object.process.versions.node
             !==
             "undefined"
             &&
             joo_global_object.process.platform
             !==
             "browser"}
    var jsoo_mount_point=[];
    if(fs_node_supported())
     jsoo_mount_point.push
      ({path:caml_root,device:new MlNodeDevice(caml_root)});
    else
     jsoo_mount_point.push
      ({path:caml_root,device:new MlFakeDevice(caml_root)});
    jsoo_mount_point.push
     ({path:caml_root + "static/",
       device:new MlFakeDevice(caml_root + "static/")});
    function resolve_fs_device(name)
     {var
       path=caml_make_path(name),
       name=path.join("/"),
       name_slash=name + "/",
       res;
      for(var i=0;i < jsoo_mount_point.length;i++)
       {var m=jsoo_mount_point[i];
        if
         (name_slash.search(m.path)
          ==
          0
          &&
          (! res || res.path.length < m.path.length))
         res
         =
         {path:m.path,
          device:m.device,
          rest:name.substring(m.path.length,name.length)}}
      return res}
    function caml_sys_is_directory(name)
     {var root=resolve_fs_device(name),a=root.device.is_dir(root.rest);
      return a?1:0}
    function caml_raise_not_found()
     {caml_raise_constant(caml_global_data.Not_found)}
    function caml_sys_getenv(name)
     {var g=joo_global_object,n=caml_jsstring_of_string(name);
      if(g.process && g.process.env && g.process.env[n] != undefined)
       return caml_string_of_jsstring(g.process.env[n]);
      if
       (joo_global_object.jsoo_static_env
        &&
        joo_global_object.jsoo_static_env[n])
       return caml_string_of_jsstring(joo_global_object.jsoo_static_env[n]);
      caml_raise_not_found()}
    function shift_right_nat(nat1,ofs1,len1,nat2,ofs2,nbits)
     {if(nbits == 0){nat2.data[ofs2] = 0;return 0}
      var wrap=0;
      for(var i=len1 - 1;i >= 0;i--)
       {var a=nat1.data[ofs1 + i] >>> 0;
        nat1.data[ofs1 + i] = a >>> nbits | wrap;
        wrap = a << 32 - nbits}
      nat2.data[ofs2] = wrap;
      return 0}
    var caml_named_values={};
    function caml_named_value(nm){return caml_named_values[nm]}
    var caml_gr_state;
    function caml_gr_state_get()
     {if(caml_gr_state)return caml_gr_state;
      throw [0,
             caml_named_value("Graphics.Graphic_failure"),
             caml_string_of_jsbytes("Not initialized")]}
    function caml_gr_point_color(x,y)
     {var
       s=caml_gr_state_get(),
       im=s.context.getImageData(x,s.height - y,1,1),
       d=im.data;
      return (d[0] << 16) + (d[1] << 8) + d[2]}
    var MlObjectTable;
    if(typeof joo_global_object.WeakMap === "undefined")
     MlObjectTable
     =
     function()
       {function NaiveLookup(objs){this.objs = objs}
        NaiveLookup.prototype.get
        =
        function(v)
         {for(var i=0;i < this.objs.length;i++)if(this.objs[i] === v)return i};
        NaiveLookup.prototype.set = function(){};
        return function()
         {this.objs = [];this.lookup = new NaiveLookup(this.objs)}}
      ();
    else
     MlObjectTable
     =
     function()
      {this.objs = [];this.lookup = new (joo_global_object.WeakMap)()};
    MlObjectTable.prototype.store
    =
    function(v){this.lookup.set(v,this.objs.length);this.objs.push(v)};
    MlObjectTable.prototype.recall
    =
    function(v)
     {var i=this.lookup.get(v);
      return i === undefined?undefined:this.objs.length - i};
    function caml_failwith(msg)
     {caml_raise_with_string(caml_global_data.Failure,msg)}
    function caml_sys_rename(o,n)
     {var o_root=resolve_fs_device(o),n_root=resolve_fs_device(n);
      if(o_root.device != n_root.device)
       caml_failwith
        ("caml_sys_rename: cannot move file between two filesystem");
      if(! o_root.device.rename)
       caml_failwith("caml_sys_rename: no implemented");
      o_root.device.rename(o_root.rest,n_root.rest)}
    function caml_log10_float(x){return Math.LOG10E * Math.log(x)}
    var caml_runtime_warnings=0;
    function caml_ml_enable_runtime_warnings(bool)
     {caml_runtime_warnings = bool;return 0}
    function caml_classify_float(x)
     {if(isFinite(x))
       {if(Math.abs(x) >= 2.2250738585072014e-308)return 0;
        if(x != 0)return 1;
        return 2}
      return isNaN(x)?4:3}
    function caml_ml_refill_input(chan)
     {var str=chan.refill(),str_len=caml_ml_string_length(str);
      if(str_len == 0)chan.refill = null;
      chan.file.write(chan.file.length(),str,0,str_len);
      return str_len}
    var caml_ml_channels=new Array();
    function caml_ml_may_refill_input(chanid)
     {var chan=caml_ml_channels[chanid];
      if(chan.refill == null)return;
      if(chan.file.length() != chan.offset)return;
      caml_ml_refill_input(chan)}
    function caml_array_bound_error()
     {caml_invalid_argument("index out of bounds")}
    function caml_ml_input_scan_line(chanid)
     {var chan=caml_ml_channels[chanid];
      caml_ml_may_refill_input(chanid);
      var p=chan.offset,len=chan.file.length();
      if(p >= len)return 0;
      while(true)
       {if(p >= len)return - (p - chan.offset);
        if(chan.file.read_one(p) == 10)return p - chan.offset + 1;
        p++}}
    function caml_gc_minor(){return 0}
    function caml_int64_of_bytes(a)
     {return new
              MlInt64
              (a[7] << 0 | a[6] << 8 | a[5] << 16,
               a[4] << 0 | a[3] << 8 | a[2] << 16,
               a[1] << 0 | a[0] << 8)}
    function caml_ba_uint8_get64(ba,i0)
     {var ofs=ba.offset(i0);
      if(ofs + 7 >= ba.data.length)caml_array_bound_error();
      var
       b1=ba.get(ofs + 0),
       b2=ba.get(ofs + 1),
       b3=ba.get(ofs + 2),
       b4=ba.get(ofs + 3),
       b5=ba.get(ofs + 4),
       b6=ba.get(ofs + 5),
       b7=ba.get(ofs + 6),
       b8=ba.get(ofs + 7);
      return caml_int64_of_bytes([b8,b7,b6,b5,b4,b3,b2,b1])}
    function caml_int64_to_bytes(x){return x.toArray()}
    function caml_int64_marshal(writer,v,sizes)
     {var b=caml_int64_to_bytes(v);
      for(var i=0;i < 8;i++)writer.write(8,b[i]);
      sizes[0] = 8;
      sizes[1] = 8}
    function caml_ba_num_dims(ba){return ba.dims.length}
    function caml_return_exn_constant(tag){return tag}
    function caml_wrap_exception(e)
     {if(e instanceof Array)return e;
      if
       (joo_global_object.RangeError
        &&
        e instanceof joo_global_object.RangeError
        &&
        e.message
        &&
        e.message.match(/maximum call stack/i))
       return caml_return_exn_constant(caml_global_data.Stack_overflow);
      if
       (joo_global_object.InternalError
        &&
        e instanceof joo_global_object.InternalError
        &&
        e.message
        &&
        e.message.match(/too much recursion/i))
       return caml_return_exn_constant(caml_global_data.Stack_overflow);
      if(e instanceof joo_global_object.Error && caml_named_value("jsError"))
       return [0,caml_named_value("jsError"),e];
      return [0,caml_global_data.Failure,caml_string_of_jsstring(String(e))]}
    function caml_create_file(name,content)
     {var
       name=typeof name == "string"?caml_string_of_jsbytes(name):name,
       content=
        typeof content == "string"?caml_string_of_jsbytes(content):content,
       root=resolve_fs_device(name);
      if(! root.device.register)caml_failwith("cannot register file");
      root.device.register(root.rest,content);
      return 0}
    function caml_fs_init()
     {var tmp=joo_global_object.caml_fs_tmp;
      if(tmp)
       for(var i=0;i < tmp.length;i++)
        caml_create_file(tmp[i].name,tmp[i].content);
      joo_global_object.caml_create_file = caml_create_file;
      joo_global_object.caml_fs_tmp = [];
      return 0}
    function caml_set_parser_trace(){return 0}
    function caml_list_of_js_array(a)
     {var l=0;
      for(var i=a.length - 1;i >= 0;i--){var e=a[i];l = [0,e,l]}
      return l}
    function unix_gettimeofday(){return new Date().getTime() / 1000}
    function caml_mul(a,b){return Math.imul(a,b)}
    function caml_hash_mix_int(h,d)
     {d = caml_mul(d,0xcc9e2d51 | 0);
      d = d << 15 | d >>> 32 - 15;
      d = caml_mul(d,0x1b873593);
      h ^= d;
      h = h << 13 | h >>> 32 - 13;
      return (h + (h << 2) | 0) + (0xe6546b64 | 0) | 0}
    function num_digits_nat(nat,ofs,len)
     {for(var i=len - 1;i >= 0;i--)if(nat.data[ofs + i] != 0)return i + 1;
      return 1}
    function caml_hash_nat(x)
     {var len=num_digits_nat(x,0,x.data.length),h=0;
      for(var i=0;i < len;i++)h = caml_hash_mix_int(h,x.data[i]);
      return h}
    function caml_call_gen(f,args)
     {if(f.fun)return caml_call_gen(f.fun,args);
      if(typeof f !== "function")return f;
      var n=f.length | 0;
      if(n === 0)return f.apply(null,args);
      var argsLen=args.length | 0,d=n - argsLen | 0;
      if(d == 0)
       return f.apply(null,args);
      else
       if(d < 0)
        return caml_call_gen(f.apply(null,args.slice(0,n)),args.slice(n));
       else
        return function()
         {var
           extra_args=arguments.length == 0?1:arguments.length,
           nargs=new Array(args.length + extra_args);
          for(var i=0;i < args.length;i++)nargs[i] = args[i];
          for(var i=0;i < arguments.length;i++)
           nargs[args.length + i] = arguments[i];
          return caml_call_gen(f,nargs)}}
    function caml_js_wrap_callback_arguments(f)
     {return function()
       {var len=arguments.length,args=new Array(len);
        for(var i=0;i < len;i++)args[i] = arguments[i];
        return caml_call_gen(f,[args])}}
    function caml_sys_chdir(dir)
     {var root=resolve_fs_device(dir);
      if(root.device.exists(root.rest))
       {if(root.rest)
         caml_current_dir = root.path + root.rest + "/";
        else
         caml_current_dir = root.path;
        return 0}
      else
       caml_raise_no_such_file(dir)}
    function caml_gc_counters(){return [254,0,0,0]}
    function caml_gr_synchronize()
     {caml_failwith("caml_gr_synchronize not Implemented")}
    var log2_ok=Math.log2 && Math.log2(1.1235582092889474E+307) == 1020;
    function jsoo_floor_log2(x)
     {if(log2_ok)return Math.floor(Math.log2(x));
      var i=0;
      if(x == 0)return - Infinity;
      if(x >= 1)while(x >= 2){x /= 2;i++}else while(x < 1){x *= 2;i--}
      return i}
    function caml_int32_bits_of_float(x)
     {var float32a=new (joo_global_object.Float32Array)(1);
      float32a[0] = x;
      var int32a=new (joo_global_object.Int32Array)(float32a.buffer);
      return int32a[0] | 0}
    function caml_int64_create_lo_mi_hi(lo,mi,hi)
     {return new MlInt64(lo,mi,hi)}
    function caml_int64_bits_of_float(x)
     {if(! isFinite(x))
       {if(isNaN(x))return caml_int64_create_lo_mi_hi(1,0,0x7ff0);
        return x > 0
                ?caml_int64_create_lo_mi_hi(0,0,0x7ff0)
                :caml_int64_create_lo_mi_hi(0,0,0xfff0)}
      var sign=x == 0 && 1 / x == - Infinity?0x8000:x >= 0?0:0x8000;
      if(sign)x = - x;
      var exp=jsoo_floor_log2(x) + 1023;
      if(exp <= 0)
       {exp = 0;x /= Math.pow(2,- 1026)}
      else
       {x /= Math.pow(2,exp - 1027);
        if(x < 16){x *= 2;exp -= 1}
        if(exp == 0)x /= 2}
      var k=Math.pow(2,24),r3=x | 0;
      x = (x - r3) * k;
      var r2=x | 0;
      x = (x - r2) * k;
      var r1=x | 0;
      r3 = r3 & 0xf | sign | exp << 4;
      return caml_int64_create_lo_mi_hi(r1,r2,r3)}
    function caml_ba_serialize(writer,ba,sz)
     {writer.write(32,ba.dims.length);
      writer.write(32,ba.kind | ba.layout << 8);
      if(ba.caml_custom == "_bigarr02")
       for(var i=0;i < ba.dims.length;i++)
        if(ba.dims[i] < 0xffff)
         writer.write(16,ba.dims[i]);
        else
         {writer.write(16,0xffff);
          writer.write(32,0);
          writer.write(32,ba.dims[i])}
      else
       for(var i=0;i < ba.dims.length;i++)writer.write(32,ba.dims[i]);
      switch(ba.kind)
       {case 2:
        case 3:
        case 12:
         for(var i=0;i < ba.data.length;i++)writer.write(8,ba.data[i]);break;
        case 4:
        case 5:
         for(var i=0;i < ba.data.length;i++)writer.write(16,ba.data[i]);break;
        case 6:
         for(var i=0;i < ba.data.length;i++)writer.write(32,ba.data[i]);break;
        case 8:
        case 9:
         writer.write(8,0);
         for(var i=0;i < ba.data.length;i++)writer.write(32,ba.data[i]);
         break;
        case 7:
         for(var i=0;i < ba.data.length / 2;i++)
          {var b=caml_int64_to_bytes(ba.get(i));
           for(var j=0;j < 8;j++)writer.write(8,b[j])}
         break;
        case 1:
         for(var i=0;i < ba.data.length;i++)
          {var b=caml_int64_to_bytes(caml_int64_bits_of_float(ba.get(i)));
           for(var j=0;j < 8;j++)writer.write(8,b[j])}
         break;
        case 0:
         for(var i=0;i < ba.data.length;i++)
          {var b=caml_int32_bits_of_float(ba.get(i));writer.write(32,b)}
         break;
        case 10:
         for(var i=0;i < ba.data.length / 2;i++)
          {var j=ba.get(i);
           writer.write(32,caml_int32_bits_of_float(j[1]));
           writer.write(32,caml_int32_bits_of_float(j[2]))}
         break;
        case 11:
         for(var i=0;i < ba.data.length / 2;i++)
          {var
            complex=ba.get(i),
            b=caml_int64_to_bytes(caml_int64_bits_of_float(complex[1]));
           for(var j=0;j < 8;j++)writer.write(8,b[j]);
           var b=caml_int64_to_bytes(caml_int64_bits_of_float(complex[2]));
           for(var j=0;j < 8;j++)writer.write(8,b[j])}
         break
        }
      sz[0] = (4 + ba.dims.length) * 4;
      sz[1] = (4 + ba.dims.length) * 8}
    function caml_ba_get_size_per_element(kind)
     {switch(kind){case 7:case 10:case 11:return 2;default:return 1}}
    function caml_ba_create_buffer(kind,size)
     {var g=joo_global_object,view;
      switch(kind)
       {case 0:view = g.Float32Array;break;
        case 1:view = g.Float64Array;break;
        case 2:view = g.Int8Array;break;
        case 3:view = g.Uint8Array;break;
        case 4:view = g.Int16Array;break;
        case 5:view = g.Uint16Array;break;
        case 6:view = g.Int32Array;break;
        case 7:view = g.Int32Array;break;
        case 8:view = g.Int32Array;break;
        case 9:view = g.Int32Array;break;
        case 10:view = g.Float32Array;break;
        case 11:view = g.Float64Array;break;
        case 12:view = g.Uint8Array;break
        }
      if(! view)caml_invalid_argument("Bigarray.create: unsupported kind");
      var data=new view(size * caml_ba_get_size_per_element(kind));
      return data}
    function caml_int32_float_of_bits(x)
     {var int32a=new (joo_global_object.Int32Array)(1);
      int32a[0] = x;
      var float32a=new (joo_global_object.Float32Array)(int32a.buffer);
      return float32a[0]}
    function caml_int64_float_of_bits(x)
     {var lo=x.lo,mi=x.mi,hi=x.hi,exp=(hi & 0x7fff) >> 4;
      if(exp == 2047)
       return (lo | mi | hi & 0xf) == 0?hi & 0x8000?- Infinity:Infinity:NaN;
      var k=Math.pow(2,- 24),res=(lo * k + mi) * k + (hi & 0xf);
      if(exp > 0)
       {res += 16;res *= Math.pow(2,exp - 1027)}
      else
       res *= Math.pow(2,- 1026);
      if(hi & 0x8000)res = - res;
      return res}
    function caml_ba_get_size(dims)
     {var n_dims=dims.length,size=1;
      for(var i=0;i < n_dims;i++)
       {if(dims[i] < 0)
         caml_invalid_argument("Bigarray.create: negative dimension");
        size = size * dims[i]}
      return size}
    function caml_int64_create_lo_hi(lo,hi)
     {return new
              MlInt64
              (lo & 0xffffff,
               lo >>> 24 & 0xff | (hi & 0xffff) << 8,
               hi >>> 16 & 0xffff)}
    function caml_int64_hi32(v){return v.hi32()}
    function caml_int64_lo32(v){return v.lo32()}
    var caml_ba_custom_name="_bigarr02";
    function Ml_Bigarray(kind,layout,dims,buffer)
     {this.kind = kind;
      this.layout = layout;
      this.dims = dims;
      this.data = buffer}
    Ml_Bigarray.prototype.caml_custom = caml_ba_custom_name;
    Ml_Bigarray.prototype.offset
    =
    function(arg)
     {var ofs=0;
      if(typeof arg === "number")arg = [arg];
      if(! (arg instanceof Array))
       caml_invalid_argument("bigarray.js: invalid offset");
      if(this.dims.length != arg.length)
       caml_invalid_argument("Bigarray.get/set: bad number of dimensions");
      if(this.layout == 0)
       for(var i=0;i < this.dims.length;i++)
        {if(arg[i] < 0 || arg[i] >= this.dims[i])caml_array_bound_error();
         ofs = ofs * this.dims[i] + arg[i]}
      else
       for(var i=this.dims.length - 1;i >= 0;i--)
        {if(arg[i] < 1 || arg[i] > this.dims[i])caml_array_bound_error();
         ofs = ofs * this.dims[i] + (arg[i] - 1)}
      return ofs};
    Ml_Bigarray.prototype.get
    =
    function(ofs)
     {switch(this.kind)
       {case 7:
         var l=this.data[ofs * 2 + 0],h=this.data[ofs * 2 + 1];
         return caml_int64_create_lo_hi(l,h);
        case 10:
        case 11:
         var r=this.data[ofs * 2 + 0],i=this.data[ofs * 2 + 1];
         return [254,r,i];
        default:return this.data[ofs]}};
    Ml_Bigarray.prototype.set
    =
    function(ofs,v)
     {switch(this.kind)
       {case 7:
         this.data[ofs * 2 + 0] = caml_int64_lo32(v);
         this.data[ofs * 2 + 1] = caml_int64_hi32(v);
         break;
        case 10:
        case 11:
         this.data[ofs * 2 + 0] = v[1];this.data[ofs * 2 + 1] = v[2];break;
        default:this.data[ofs] = v;break}
      return 0};
    Ml_Bigarray.prototype.fill
    =
    function(v)
     {switch(this.kind)
       {case 7:
         var a=caml_int64_lo32(v),b=caml_int64_hi32(v);
         if(a == b)
          this.data.fill(a);
         else
          for(var i=0;i < this.data.length;i++)this.data[i] = i % 2 == 0?a:b;
         break;
        case 10:
        case 11:
         var im=v[1],re=v[2];
         if(im == re)
          this.data.fill(im);
         else
          for(var i=0;i < this.data.length;i++)
           this.data[i] = i % 2 == 0?im:re;
         break;
        default:this.data.fill(v);break}};
    Ml_Bigarray.prototype.compare
    =
    function(b,total)
     {if(this.layout != b.layout || this.kind != b.kind)
       {var k1=this.kind | this.layout << 8,k2=b.kind | b.layout << 8;
        return k2 - k1}
      if(this.dims.length != b.dims.length)
       return b.dims.length - this.dims.length;
      for(var i=0;i < this.dims.length;i++)
       if(this.dims[i] != b.dims[i])return this.dims[i] < b.dims[i]?- 1:1;
      switch(this.kind)
       {case 0:
        case 1:
        case 10:
        case 11:
         var x,y;
         for(var i=0;i < this.data.length;i++)
          {x = this.data[i];
           y = b.data[i];
           if(x < y)return - 1;
           if(x > y)return 1;
           if(x != y)
            {if(! total)return NaN;if(x == x)return 1;if(y == y)return - 1}}
         break;
        case 7:
         for(var i=0;i < this.data.length;i += 2)
          {if(this.data[i + 1] < b.data[i + 1])return - 1;
           if(this.data[i + 1] > b.data[i + 1])return 1;
           if(this.data[i] >>> 0 < b.data[i] >>> 0)return - 1;
           if(this.data[i] >>> 0 > b.data[i] >>> 0)return 1}
         break;
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 8:
        case 9:
        case 12:
         for(var i=0;i < this.data.length;i++)
          {if(this.data[i] < b.data[i])return - 1;
           if(this.data[i] > b.data[i])return 1}
         break
        }
      return 0};
    function Ml_Bigarray_c_1_1(kind,layout,dims,buffer)
     {this.kind = kind;
      this.layout = layout;
      this.dims = dims;
      this.data = buffer}
    Ml_Bigarray_c_1_1.prototype = new Ml_Bigarray();
    Ml_Bigarray_c_1_1.prototype.offset
    =
    function(arg)
     {if(typeof arg !== "number")
       if(arg instanceof Array && arg.length == 1)
        arg = arg[0];
       else
        caml_invalid_argument("Ml_Bigarray_c_1_1.offset");
      if(arg < 0 || arg >= this.dims[0])caml_array_bound_error();
      return arg};
    Ml_Bigarray_c_1_1.prototype.get = function(ofs){return this.data[ofs]};
    Ml_Bigarray_c_1_1.prototype.set
    =
    function(ofs,v){this.data[ofs] = v;return 0};
    Ml_Bigarray_c_1_1.prototype.fill
    =
    function(v){this.data.fill(v);return 0};
    function caml_ba_create_unsafe(kind,layout,dims,data)
     {var size_per_element=caml_ba_get_size_per_element(kind);
      if(caml_ba_get_size(dims) * size_per_element != data.length)
       caml_invalid_argument("length doesn't match dims");
      if(layout == 0 && dims.length == 1 && size_per_element == 1)
       return new Ml_Bigarray_c_1_1(kind,layout,dims,data);
      return new Ml_Bigarray(kind,layout,dims,data)}
    function caml_ba_deserialize(reader,sz,name)
     {var num_dims=reader.read32s();
      if(num_dims < 0 || num_dims > 16)
       caml_failwith("input_value: wrong number of bigarray dimensions");
      var tag=reader.read32s(),kind=tag & 0xff,layout=tag >> 8 & 1,dims=[];
      if(name == "_bigarr02")
       for(var i=0;i < num_dims;i++)
        {var size_dim=reader.read16u();
         if(size_dim == 0xffff)
          {var size_dim_hi=reader.read32u(),size_dim_lo=reader.read32u();
           if(size_dim_hi != 0)
            caml_failwith("input_value: bigarray dimension overflow in 32bit");
           size_dim = size_dim_lo}
         dims.push(size_dim)}
      else
       for(var i=0;i < num_dims;i++)dims.push(reader.read32u());
      var
       size=caml_ba_get_size(dims),
       data=caml_ba_create_buffer(kind,size),
       ba=caml_ba_create_unsafe(kind,layout,dims,data);
      switch(kind)
       {case 2:for(var i=0;i < size;i++)data[i] = reader.read8s();break;
        case 3:
        case 12:for(var i=0;i < size;i++)data[i] = reader.read8u();break;
        case 4:for(var i=0;i < size;i++)data[i] = reader.read16s();break;
        case 5:for(var i=0;i < size;i++)data[i] = reader.read16u();break;
        case 6:for(var i=0;i < size;i++)data[i] = reader.read32s();break;
        case 8:
        case 9:
         var sixty=reader.read8u();
         if(sixty)
          caml_failwith
           ("input_value: cannot read bigarray with 64-bit OCaml ints");
         for(var i=0;i < size;i++)data[i] = reader.read32s();
         break;
        case 7:
         var t=new Array(8);
         for(var i=0;i < size;i++)
          {for(var j=0;j < 8;j++)t[j] = reader.read8u();
           var int64=caml_int64_of_bytes(t);
           ba.set(i,int64)}
         break;
        case 1:
         var t=new Array(8);
         for(var i=0;i < size;i++)
          {for(var j=0;j < 8;j++)t[j] = reader.read8u();
           var f=caml_int64_float_of_bits(caml_int64_of_bytes(t));
           ba.set(i,f)}
         break;
        case 0:
         for(var i=0;i < size;i++)
          {var f=caml_int32_float_of_bits(reader.read32s());ba.set(i,f)}
         break;
        case 10:
         for(var i=0;i < size;i++)
          {var
            re=caml_int32_float_of_bits(reader.read32s()),
            im=caml_int32_float_of_bits(reader.read32s());
           ba.set(i,[254,re,im])}
         break;
        case 11:
         var t=new Array(8);
         for(var i=0;i < size;i++)
          {for(var j=0;j < 8;j++)t[j] = reader.read8u();
           var re=caml_int64_float_of_bits(caml_int64_of_bytes(t));
           for(var j=0;j < 8;j++)t[j] = reader.read8u();
           var im=caml_int64_float_of_bits(caml_int64_of_bytes(t));
           ba.set(i,[254,re,im])}
         break
        }
      sz[0] = (4 + num_dims) * 4;
      return caml_ba_create_unsafe(kind,layout,dims,data)}
    function caml_ba_compare(a,b,total){return a.compare(b,total)}
    function caml_hash_mix_int64(h,v)
     {h = caml_hash_mix_int(h,caml_int64_lo32(v));
      h = caml_hash_mix_int(h,caml_int64_hi32(v));
      return h}
    function caml_hash_mix_float(h,v0)
     {return caml_hash_mix_int64(h,caml_int64_bits_of_float(v0))}
    function caml_ba_hash(ba)
     {var num_elts=caml_ba_get_size(ba.dims),h=0;
      switch(ba.kind)
       {case 2:
        case 3:
        case 12:
         if(num_elts > 256)num_elts = 256;
         var w=0,i=0;
         for(i = 0;i + 4 <= ba.data.length;i += 4)
          {w
           =
           ba.data[i + 0]
           |
           ba.data[i + 1]
           <<
           8
           |
           ba.data[i + 2]
           <<
           16
           |
           ba.data[i + 3]
           <<
           24;
           h = caml_hash_mix_int(h,w)}
         w = 0;
         switch(num_elts & 3)
          {case 3:w = ba.data[i + 2] << 16;
           case 2:w |= ba.data[i + 1] << 8;
           case 1:w |= ba.data[i + 0];h = caml_hash_mix_int(h,w)
           }
         break;
        case 4:
        case 5:
         if(num_elts > 128)num_elts = 128;
         var w=0,i=0;
         for(i = 0;i + 2 <= ba.data.length;i += 2)
          {w = ba.data[i + 0] | ba.data[i + 1] << 16;
           h = caml_hash_mix_int(h,w)}
         if((num_elts & 1) != 0)h = caml_hash_mix_int(h,ba.data[i]);
         break;
        case 6:
         if(num_elts > 64)num_elts = 64;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_int(h,ba.data[i]);
         break;
        case 8:
        case 9:
         if(num_elts > 64)num_elts = 64;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_int(h,ba.data[i]);
         break;
        case 7:
         if(num_elts > 32)num_elts = 32;
         num_elts *= 2;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_int(h,ba.data[i]);
         break;
        case 10:num_elts *= 2;
        case 0:
         if(num_elts > 64)num_elts = 64;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_float(h,ba.data[i]);
         break;
        case 11:num_elts *= 2;
        case 1:
         if(num_elts > 32)num_elts = 32;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_float(h,ba.data[i]);
         break
        }
      return h}
    function caml_int32_unmarshal(reader,size)
     {size[0] = 4;return reader.read32s()}
    function caml_nativeint_unmarshal(reader,size)
     {switch(reader.read8u())
       {case 1:size[0] = 4;return reader.read32s();
        case 2:caml_failwith("input_value: native integer value too large");
        default:caml_failwith("input_value: ill-formed native integer")}}
    function caml_int64_unmarshal(reader,size)
     {var t=new Array(8);
      for(var j=0;j < 8;j++)t[j] = reader.read8u();
      size[0] = 8;
      return caml_int64_of_bytes(t)}
    function caml_int64_compare(x,y,total){return x.compare(y)}
    function caml_int64_hash(v){return v.lo32() ^ v.hi32()}
    var
     caml_custom_ops=
      {"_j":
       {deserialize:caml_int64_unmarshal,
        serialize:caml_int64_marshal,
        fixed_length:8,
        compare:caml_int64_compare,
        hash:caml_int64_hash},
       "_i":{deserialize:caml_int32_unmarshal,fixed_length:4},
       "_n":{deserialize:caml_nativeint_unmarshal,fixed_length:4},
       "_bigarray":
       {deserialize:
        function(reader,sz){return caml_ba_deserialize(reader,sz,"_bigarray")},
        serialize:caml_ba_serialize,
        compare:caml_ba_compare,
        hash:caml_ba_hash},
       "_bigarr02":
       {deserialize:
        function(reader,sz){return caml_ba_deserialize(reader,sz,"_bigarr02")},
        serialize:caml_ba_serialize,
        compare:caml_ba_compare,
        hash:caml_ba_hash}};
    function caml_compare_val_get_custom(a)
     {return caml_custom_ops[a.caml_custom]
             &&
             caml_custom_ops[a.caml_custom].compare}
    function caml_compare_val_number_custom(num,custom,swap,total)
     {var comp=caml_compare_val_get_custom(custom);
      if(comp)
       {var x=swap > 0?comp(custom,num,total):comp(num,custom,total);
        if(total && x != x)return swap;
        if(+ x != + x)return + x;
        if((x | 0) != 0)return x | 0}
      return swap}
    function caml_compare_val_tag(a)
     {if(typeof a === "number")
       return 1000;
      else
       if(caml_is_ml_bytes(a))
        return 252;
       else
        if(caml_is_ml_string(a))
         return 1252;
        else
         if(a instanceof Array && a[0] === a[0] >>> 0 && a[0] <= 255)
          {var tag=a[0] | 0;return tag == 254?0:tag}
         else
          if(a instanceof String)
           return 12520;
          else
           if(typeof a == "string")
            return 12520;
           else
            if(a instanceof Number)
             return 1000;
            else
             if(a && a.caml_custom)
              return 1255;
             else
              if(a && a.compare)
               return 1256;
              else
               if(typeof a == "function")
                return 1247;
               else
                if(typeof a == "symbol")return 1251;
      return 1001}
    function caml_int_compare(a,b)
     {if(a < b)return - 1;if(a == b)return 0;return 1}
    function caml_bytes_compare(s1,s2)
     {s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c < s2.c?- 1:s1.c > s2.c?1:0}
    function caml_string_compare(s1,s2){return caml_bytes_compare(s1,s2)}
    function caml_compare_val(a,b,total)
     {var stack=[];
      for(;;)
       {if(! (total && a === b))
         {var tag_a=caml_compare_val_tag(a);
          if(tag_a == 250){a = a[1];continue}
          var tag_b=caml_compare_val_tag(b);
          if(tag_b == 250){b = b[1];continue}
          if(tag_a !== tag_b)
           {if(tag_a == 1000)
             {if(tag_b == 1255)
               return caml_compare_val_number_custom(a,b,- 1,total);
              return - 1}
            if(tag_b == 1000)
             {if(tag_a == 1255)
               return caml_compare_val_number_custom(b,a,1,total);
              return 1}
            return tag_a < tag_b?- 1:1}
          switch(tag_a)
           {case 247:caml_invalid_argument("compare: functional value");break;
            case 248:
             var x=caml_int_compare(a[2],b[2]);if(x != 0)return x | 0;break;
            case 249:caml_invalid_argument("compare: functional value");break;
            case 250:
             caml_invalid_argument
              ("equal: got Forward_tag, should not happen");
             break;
            case 251:caml_invalid_argument("equal: abstract value");break;
            case 252:
             if(a !== b){var x=caml_bytes_compare(a,b);if(x != 0)return x | 0}
             break;
            case 253:
             caml_invalid_argument("equal: got Double_tag, should not happen");
             break;
            case 254:
             caml_invalid_argument
              ("equal: got Double_array_tag, should not happen");
             break;
            case 255:
             caml_invalid_argument("equal: got Custom_tag, should not happen");
             break;
            case 1247:
             caml_invalid_argument("compare: functional value");break;
            case 1255:
             var comp=caml_compare_val_get_custom(a);
             if(comp != caml_compare_val_get_custom(b))
              return a.caml_custom < b.caml_custom?- 1:1;
             if(! comp)caml_invalid_argument("compare: abstract value");
             var x=comp(a,b,total);
             if(x != x)return total?- 1:x;
             if(x !== (x | 0))return - 1;
             if(x != 0)return x | 0;
             break;
            case 1256:
             var x=a.compare(b,total);
             if(x != x)return total?- 1:x;
             if(x !== (x | 0))return - 1;
             if(x != 0)return x | 0;
             break;
            case 1000:
             a = + a;
             b = + b;
             if(a < b)return - 1;
             if(a > b)return 1;
             if(a != b)
              {if(! total)return NaN;if(a == a)return 1;if(b == b)return - 1}
             break;
            case 1001:
             if(a < b)return - 1;
             if(a > b)return 1;
             if(a != b)
              {if(! total)return NaN;if(a == a)return 1;if(b == b)return - 1}
             break;
            case 1251:if(a !== b){if(! total)return NaN;return 1}break;
            case 1252:
             var a=caml_jsbytes_of_string(a),b=caml_jsbytes_of_string(b);
             if(a !== b){if(a < b)return - 1;if(a > b)return 1}
             break;
            case 12520:
             var a=a.toString(),b=b.toString();
             if(a !== b){if(a < b)return - 1;if(a > b)return 1}
             break;
            case 246:
            case 254:
            default:
             if(a.length != b.length)return a.length < b.length?- 1:1;
             if(a.length > 1)stack.push(a,b,1);
             break}}
        if(stack.length == 0)return 0;
        var i=stack.pop();
        b = stack.pop();
        a = stack.pop();
        if(i + 1 < a.length)stack.push(a,b,i + 1);
        a = a[i];
        b = b[i]}}
    function caml_greaterthan(x,y){return + (caml_compare_val(x,y,false) > 0)}
    function div_helper(a,b,c)
     {var
       x=a * 65536 + (b >>> 16),
       y=Math.floor(x / c) * 65536,
       z=x % c * 65536,
       w=z + (b & 0x0000FFFF);
      return [y + Math.floor(w / c),w % c]}
    function div_digit_nat(natq,ofsq,natr,ofsr,nat1,ofs1,len,nat2,ofs2)
     {var rem=nat1.data[ofs1 + len - 1] >>> 0;
      for(var i=len - 2;i >= 0;i--)
       {var x=div_helper(rem,nat1.data[ofs1 + i] >>> 0,nat2.data[ofs2] >>> 0);
        natq.data[ofsq + i] = x[0];
        rem = x[1]}
      natr.data[ofsr] = rem;
      return 0}
    function num_leading_zero_bits_in_digit(nat,ofs)
     {var a=nat.data[ofs],b=0;
      if(a & 0xFFFF0000){b += 16;a >>>= 16}
      if(a & 0xFF00){b += 8;a >>>= 8}
      if(a & 0xF0){b += 4;a >>>= 4}
      if(a & 12){b += 2;a >>>= 2}
      if(a & 2){b += 1;a >>>= 1}
      if(a & 1)b += 1;
      return 32 - b}
    function shift_left_nat(nat1,ofs1,len1,nat2,ofs2,nbits)
     {if(nbits == 0){nat2.data[ofs2] = 0;return 0}
      var wrap=0;
      for(var i=0;i < len1;i++)
       {var a=nat1.data[ofs1 + i] >>> 0;
        nat1.data[ofs1 + i] = a << nbits | wrap;
        wrap = a >>> 32 - nbits}
      nat2.data[ofs2] = wrap;
      return 0}
    function MlNat(x)
     {this.data = new (joo_global_object.Int32Array)(x);
      this.length = this.data.length + 2}
    MlNat.prototype.caml_custom = "_nat";
    function create_nat(size)
     {var arr=new MlNat(size);
      for(var i=0;i < size;i++)arr.data[i] = - 1;
      return arr}
    function set_to_zero_nat(nat,ofs,len)
     {for(var i=0;i < len;i++)nat.data[ofs + i] = 0;return 0}
    function incr_nat(nat,ofs,len,carry_in)
     {var carry=carry_in;
      for(var i=0;i < len;i++)
       {var x=(nat.data[ofs + i] >>> 0) + carry;
        nat.data[ofs + i] = x | 0;
        if(x == x >>> 0){carry = 0;break}else carry = 1}
      return carry}
    function add_nat(nat1,ofs1,len1,nat2,ofs2,len2,carry_in)
     {var carry=carry_in;
      for(var i=0;i < len2;i++)
       {var
         x=
          (nat1.data[ofs1 + i] >>> 0) + (nat2.data[ofs2 + i] >>> 0) + carry;
        nat1.data[ofs1 + i] = x;
        if(x == x >>> 0)carry = 0;else carry = 1}
      return incr_nat(nat1,ofs1 + len2,len1 - len2,carry)}
    function nat_of_array(l){return new MlNat(l)}
    function mult_digit_nat(nat1,ofs1,len1,nat2,ofs2,len2,nat3,ofs3)
     {var carry=0,a=nat3.data[ofs3] >>> 0;
      for(var i=0;i < len2;i++)
       {var
         x1=
          (nat1.data[ofs1 + i] >>> 0)
          +
          (nat2.data[ofs2 + i] >>> 0)
          *
          (a & 0x0000FFFF)
          +
          carry,
         x2=(nat2.data[ofs2 + i] >>> 0) * (a >>> 16);
        carry = Math.floor(x2 / 65536);
        var x3=x1 + x2 % 65536 * 65536;
        nat1.data[ofs1 + i] = x3;
        carry += Math.floor(x3 / 4294967296)}
      return len2 < len1 && carry
              ?add_nat
                (nat1,ofs1 + len2,len1 - len2,nat_of_array([carry]),0,1,0)
              :carry}
    function decr_nat(nat,ofs,len,carry_in)
     {var borrow=carry_in == 1?0:1;
      for(var i=0;i < len;i++)
       {var x=(nat.data[ofs + i] >>> 0) - borrow;
        nat.data[ofs + i] = x;
        if(x >= 0){borrow = 0;break}else borrow = 1}
      return borrow == 1?0:1}
    function sub_nat(nat1,ofs1,len1,nat2,ofs2,len2,carry_in)
     {var borrow=carry_in == 1?0:1;
      for(var i=0;i < len2;i++)
       {var
         x=
          (nat1.data[ofs1 + i] >>> 0) - (nat2.data[ofs2 + i] >>> 0) - borrow;
        nat1.data[ofs1 + i] = x;
        if(x >= 0)borrow = 0;else borrow = 1}
      return decr_nat(nat1,ofs1 + len2,len1 - len2,borrow == 1?0:1)}
    function compare_nat(nat1,ofs1,len1,nat2,ofs2,len2)
     {var a=num_digits_nat(nat1,ofs1,len1),b=num_digits_nat(nat2,ofs2,len2);
      if(a > b)return 1;
      if(a < b)return - 1;
      for(var i=len1 - 1;i >= 0;i--)
       {if(nat1.data[ofs1 + i] >>> 0 > nat2.data[ofs2 + i] >>> 0)return 1;
        if(nat1.data[ofs1 + i] >>> 0 < nat2.data[ofs2 + i] >>> 0)return - 1}
      return 0}
    function div_nat(nat1,ofs1,len1,nat2,ofs2,len2)
     {if(len2 == 1)
       {div_digit_nat(nat1,ofs1 + 1,nat1,ofs1,nat1,ofs1,len1,nat2,ofs2);
        return 0}
      var s=num_leading_zero_bits_in_digit(nat2,ofs2 + len2 - 1);
      shift_left_nat(nat2,ofs2,len2,nat_of_array([0]),0,s);
      shift_left_nat(nat1,ofs1,len1,nat_of_array([0]),0,s);
      var d=(nat2.data[ofs2 + len2 - 1] >>> 0) + 1,a=create_nat(len2 + 1);
      for(var i=len1 - 1;i >= len2;i--)
       {var
         quo=
          d == 4294967296
           ?nat1.data[ofs1 + i] >>> 0
           :div_helper
              (nat1.data[ofs1 + i] >>> 0,nat1.data[ofs1 + i - 1] >>> 0,d)
             [0];
        set_to_zero_nat(a,0,len2 + 1);
        mult_digit_nat(a,0,len2 + 1,nat2,ofs2,len2,nat_of_array([quo]),0);
        sub_nat(nat1,ofs1 + i - len2,len2 + 1,a,0,len2 + 1,1);
        while
         (nat1.data[ofs1 + i]
          !=
          0
          ||
          compare_nat(nat1,ofs1 + i - len2,len2,nat2,ofs2,len2)
          >=
          0)
         {quo = quo + 1;
          sub_nat(nat1,ofs1 + i - len2,len2 + 1,nat2,ofs2,len2,1)}
        nat1.data[ofs1 + i] = quo}
      shift_right_nat(nat1,ofs1,len2,nat_of_array([0]),0,s);
      shift_right_nat(nat2,ofs2,len2,nat_of_array([0]),0,s);
      return 0}
    function caml_ba_blit(src,dst)
     {if(dst.dims.length != src.dims.length)
       caml_invalid_argument("Bigarray.blit: dimension mismatch");
      for(var i=0;i < dst.dims.length;i++)
       if(dst.dims[i] != src.dims[i])
        caml_invalid_argument("Bigarray.blit: dimension mismatch");
      dst.data.set(src.data);
      return 0}
    function is_digit_int(nat,ofs){if(nat.data[ofs] >= 0)return 1;return 0}
    function caml_int64_div(x,y){return x.div(y)}
    function caml_js_html_entities(s)
     {var entity=/^&#?[0-9a-zA-Z]+;$/;
      if(s.match(entity))
       {var str,temp=document.createElement("p");
        temp.innerHTML = s;
        str = temp.textContent || temp.innerText;
        temp = null;
        return str}
      else
       caml_failwith("Invalid entity " + s)}
    function caml_string_unsafe_set(s,i,c)
     {return caml_bytes_unsafe_set(s,i,c)}
    function caml_int64_of_float(x)
     {if(x < 0)x = Math.ceil(x);
      return new
              MlInt64
              (x & 0xffffff,
               Math.floor(x * caml_int64_offset) & 0xffffff,
               Math.floor(x * caml_int64_offset * caml_int64_offset) & 0xffff)}
    function caml_ml_channel_size_64(chanid)
     {var chan=caml_ml_channels[chanid];
      return caml_int64_of_float(chan.file.length())}
    function caml_ba_set_2(ba,i0,i1,v){ba.set(ba.offset([i0,i1]),v);return 0}
    var
     caml_argv=
      function()
        {var g=joo_global_object,main="a.out",args=[];
         if(g.process && g.process.argv && g.process.argv.length > 1)
          {var argv=g.process.argv;main = argv[1];args = argv.slice(2)}
         var p=caml_string_of_jsstring(main),args2=[0,p];
         for(var i=0;i < args.length;i++)
          args2.push(caml_string_of_jsstring(args[i]));
         return args2}
       (),
     caml_executable_name=caml_argv[1];
    function caml_js_eval_string(s){return eval(caml_jsstring_of_string(s))}
    function caml_CamlinternalMod_init_mod(loc,shape)
     {function undef_module(_x)
       {caml_raise_with_arg(caml_global_data.Undefined_recursive_module,loc)}
      function loop(shape,struct,idx)
       {if(typeof shape === "number")
         switch(shape)
          {case 0:struct[idx] = {fun:undef_module};break;
           case 1:struct[idx] = [246,undef_module];break;
           default:struct[idx] = []}
        else
         switch(shape[0])
          {case 0:
            struct[idx] = [0];
            for(var i=1;i < shape[1].length;i++)
             loop(shape[1][i],struct[idx],i);
            break;
           default:struct[idx] = shape[1]}}
      var res=[];
      loop(shape,res,0);
      return res[0]}
    function serialize_nat(writer,nat,sz)
     {var len=nat.data.length;
      writer.write(32,len);
      for(var i=0;i < len;i++)writer.write(32,nat.data[i]);
      sz[0] = len * 4;
      sz[1] = len * 8}
    function caml_memprof_set(_control){return 0}
    function caml_sys_exit(code)
     {var g=joo_global_object;
      if(g.quit)g.quit(code);
      if(g.process && g.process.exit)g.process.exit(code);
      caml_invalid_argument("Function 'exit' not implemented")}
    function caml_channel_descriptor(chanid)
     {var chan=caml_ml_channels[chanid];return chan.fd}
    function caml_js_from_array(a){return a.slice(1)}
    function caml_ba_reshape(ba,vind)
     {vind = caml_js_from_array(vind);
      var new_dim=[],num_dims=vind.length;
      if(num_dims < 0 || num_dims > 16)
       caml_invalid_argument("Bigarray.reshape: bad number of dimensions");
      var num_elts=1;
      for(var i=0;i < num_dims;i++)
       {new_dim[i] = vind[i];
        if(new_dim[i] < 0)
         caml_invalid_argument("Bigarray.reshape: negative dimension");
        num_elts = num_elts * new_dim[i]}
      var size=caml_ba_get_size(ba.dims);
      if(num_elts != size)
       caml_invalid_argument("Bigarray.reshape: size mismatch");
      return caml_ba_create_unsafe(ba.kind,ba.layout,new_dim,ba.data)}
    var caml_oo_last_id=0;
    function caml_set_oo_id(b){b[2] = caml_oo_last_id++;return b}
    function caml_gr_fill_rect(x,y,w,h)
     {var s=caml_gr_state_get();
      s.context.fillRect(x,s.height - y,w,- h);
      return 0}
    function caml_bigstring_blit_string_to_ba(str1,pos1,ba2,pos2,len)
     {if(12 != ba2.kind)
       caml_invalid_argument
        ("caml_bigstring_blit_string_to_ba: kind mismatch");
      if(len == 0)return 0;
      var ofs2=ba2.offset(pos2);
      if(pos1 + len > caml_ml_string_length(str1))caml_array_bound_error();
      if(ofs2 + len > ba2.data.length)caml_array_bound_error();
      var slice=caml_array_of_string(str1).slice(pos1,pos1 + len);
      ba2.data.set(slice,ofs2);
      return 0}
    function caml_gr_set_window_title(name)
     {var s=caml_gr_state_get();
      s.title = name;
      var jsname=caml_jsstring_of_string(name);
      if(s.set_title)s.set_title(jsname);
      return 0}
    function caml_get_global_data(){return caml_global_data}
    function caml_int64_shift_right_unsigned(x,s)
     {return x.shift_right_unsigned(s)}
    function caml_ba_uint8_get16(ba,i0)
     {var ofs=ba.offset(i0);
      if(ofs + 1 >= ba.data.length)caml_array_bound_error();
      var b1=ba.get(ofs),b2=ba.get(ofs + 1);
      return b1 | b2 << 8}
    function caml_compare(a,b){return caml_compare_val(a,b,true)}
    function caml_fresh_oo_id(){return caml_oo_last_id++}
    function caml_int64_to_float(x){return x.toFloat()}
    function caml_ba_get_1(ba,i0){return ba.get(ba.offset(i0))}
    function caml_bigstring_memcmp(s1,pos1,s2,pos2,len)
     {for(var i=0;i < len;i++)
       {var a=caml_ba_get_1(s1,pos1 + i),b=caml_ba_get_1(s2,pos2 + i);
        if(a < b)return - 1;
        if(a > b)return 1}
      return 0}
    function caml_new_string(s){return caml_string_of_jsbytes(s)}
    function caml_ba_uint8_get32(ba,i0)
     {var ofs=ba.offset(i0);
      if(ofs + 3 >= ba.data.length)caml_array_bound_error();
      var
       b1=ba.get(ofs + 0),
       b2=ba.get(ofs + 1),
       b3=ba.get(ofs + 2),
       b4=ba.get(ofs + 3);
      return b1 << 0 | b2 << 8 | b3 << 16 | b4 << 24}
    function caml_raw_backtrace_length(){return 0}
    function caml_obj_block(tag,size)
     {var o=new Array(size + 1);
      o[0] = tag;
      for(var i=1;i <= size;i++)o[i] = 0;
      return o}
    function caml_gr_clear_graph()
     {var s=caml_gr_state_get();
      s.canvas.width = s.width;
      s.canvas.height = s.height;
      return 0}
    function bigstring_to_array_buffer(bs){return bs.data.buffer}
    function caml_sys_const_naked_pointers_checked(_unit){return 0}
    function lxor_digit_nat(nat1,ofs1,nat2,ofs2)
     {nat1.data[ofs1] ^= nat2.data[ofs2];return 0}
    function caml_final_release(){return 0}
    function caml_js_to_array(a)
     {var len=a.length,b=new Array(len + 1);
      b[0] = 0;
      for(var i=0;i < len;i++)b[i + 1] = a[i];
      return b}
    function caml_gr_plot(x,y)
     {var
       s=caml_gr_state_get(),
       im=s.context.createImageData(1,1),
       d=im.data,
       color=s.color;
      d[0] = color >> 16 & 0xff;
      d[1] = color >> 8 & 0xff,d[2] = color >> 0 & 0xff;
      d[3] = 0xFF;
      s.x = x;
      s.y = y;
      s.context.putImageData(im,x,s.height - y);
      return 0}
    function caml_bytes_set64(s,i,i64)
     {if(i >>> 0 >= s.l - 7)caml_bytes_bound_error();
      var a=caml_int64_to_bytes(i64);
      for(var j=0;j < 8;j++)caml_bytes_unsafe_set(s,i + 7 - j,a[j]);
      return 0}
    function caml_bytes_set16(s,i,i16)
     {if(i >>> 0 >= s.l - 1)caml_bytes_bound_error();
      var b2=0xFF & i16 >> 8,b1=0xFF & i16;
      caml_bytes_unsafe_set(s,i + 0,b1);
      caml_bytes_unsafe_set(s,i + 1,b2);
      return 0}
    function caml_string_set16(s,i,i16){return caml_bytes_set16(s,i,i16)}
    function caml_int64_bswap(x)
     {var y=caml_int64_to_bytes(x);
      return caml_int64_of_bytes([y[7],y[6],y[5],y[4],y[3],y[2],y[1],y[0]])}
    function caml_fill_bytes(s,i,l,c)
     {if(l > 0)
       if(i == 0 && (l >= s.l || s.t == 2 && l >= s.c.length))
        if(c == 0)
         {s.c = "";s.t = 2}
        else
         {s.c = caml_str_repeat(l,String.fromCharCode(c));s.t = l == s.l?0:2}
       else
        {if(s.t != 4)caml_convert_bytes_to_array(s);
         for(l += i;i < l;i++)s.c[i] = c}
      return 0}
    var caml_fill_string=caml_fill_bytes;
    function caml_gc_major(){return 0}
    function caml_lex_array(s)
     {s = caml_jsbytes_of_string(s);
      var l=s.length / 2,a=new Array(l);
      for(var i=0;i < l;i++)
       a[i]
       =
       (s.charCodeAt(2 * i) | s.charCodeAt(2 * i + 1) << 8)
       <<
       16
       >>
       16;
      return a}
    function caml_lex_engine(tbl,start_state,lexbuf)
     {var
       lex_buffer=2,
       lex_buffer_len=3,
       lex_start_pos=5,
       lex_curr_pos=6,
       lex_last_pos=7,
       lex_last_action=8,
       lex_eof_reached=9,
       lex_base=1,
       lex_backtrk=2,
       lex_default=3,
       lex_trans=4,
       lex_check=5;
      if(! tbl.lex_default)
       {tbl.lex_base = caml_lex_array(tbl[lex_base]);
        tbl.lex_backtrk = caml_lex_array(tbl[lex_backtrk]);
        tbl.lex_check = caml_lex_array(tbl[lex_check]);
        tbl.lex_trans = caml_lex_array(tbl[lex_trans]);
        tbl.lex_default = caml_lex_array(tbl[lex_default])}
      var c,state=start_state,buffer=caml_array_of_bytes(lexbuf[lex_buffer]);
      if(state >= 0)
       {lexbuf[lex_last_pos] = lexbuf[lex_start_pos] = lexbuf[lex_curr_pos];
        lexbuf[lex_last_action] = - 1}
      else
       state = - state - 1;
      for(;;)
       {var base=tbl.lex_base[state];
        if(base < 0)return - base - 1;
        var backtrk=tbl.lex_backtrk[state];
        if(backtrk >= 0)
         {lexbuf[lex_last_pos] = lexbuf[lex_curr_pos];
          lexbuf[lex_last_action] = backtrk}
        if(lexbuf[lex_curr_pos] >= lexbuf[lex_buffer_len])
         if(lexbuf[lex_eof_reached] == 0)return - state - 1;else c = 256;
        else
         {c = buffer[lexbuf[lex_curr_pos]];lexbuf[lex_curr_pos]++}
        if(tbl.lex_check[base + c] == state)
         state = tbl.lex_trans[base + c];
        else
         state = tbl.lex_default[state];
        if(state < 0)
         {lexbuf[lex_curr_pos] = lexbuf[lex_last_pos];
          if(lexbuf[lex_last_action] == - 1)
           caml_failwith("lexing: empty token");
          else
           return lexbuf[lex_last_action]}
        else
         if(c == 256)lexbuf[lex_eof_reached] = 0}}
    function caml_sys_file_exists(name)
     {var root=resolve_fs_device(name);return root.device.exists(root.rest)}
    function caml_convert_raw_backtrace_slot()
     {caml_failwith("caml_convert_raw_backtrace_slot")}
    function caml_array_sub(a,i,len)
     {var a2=new Array(len + 1);
      a2[0] = 0;
      for(var i2=1,i1=i + 1;i2 <= len;i2++,i1++)a2[i2] = a[i1];
      return a2}
    function caml_bytes_equal(s1,s2)
     {if(s1 === s2)return 1;
      s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c == s2.c?1:0}
    function caml_gr_size_x(){var s=caml_gr_state_get();return s.width}
    function caml_ml_debug_info_status(){return 0}
    function caml_sys_const_ostype_cygwin(){return 0}
    function caml_cosh_float(x){return (Math.exp(x) + Math.exp(- x)) / 2}
    var caml_ephe_key_offset=3;
    function caml_weak_check(x,i)
     {return x[caml_ephe_key_offset + i]
              !==
              undefined
              &&
              x[caml_ephe_key_offset + i]
              !==
              0
              ?1
              :0}
    var caml_ephe_check_key=caml_weak_check;
    function caml_hash_mix_final(h)
     {h ^= h >>> 16;
      h = caml_mul(h,0x85ebca6b | 0);
      h ^= h >>> 13;
      h = caml_mul(h,0xc2b2ae35 | 0);
      h ^= h >>> 16;
      return h}
    function caml_gr_text_size(txt)
     {var
       s=caml_gr_state_get(),
       w=s.context.measureText(caml_jsstring_of_string(txt)).width;
      return [0,w,s.text_size]}
    function caml_lex_run_mem(s,i,mem,curr_pos)
     {for(;;)
       {var dst=s.charCodeAt(i);
        i++;
        if(dst == 0xff)return;
        var src=s.charCodeAt(i);
        i++;
        if(src == 0xff)
         mem[dst + 1] = curr_pos;
        else
         mem[dst + 1] = mem[src + 1]}}
    function caml_lex_run_tag(s,i,mem)
     {for(;;)
       {var dst=s.charCodeAt(i);
        i++;
        if(dst == 0xff)return;
        var src=s.charCodeAt(i);
        i++;
        if(src == 0xff)mem[dst + 1] = - 1;else mem[dst + 1] = mem[src + 1]}}
    function caml_new_lex_engine(tbl,start_state,lexbuf)
     {var
       lex_buffer=2,
       lex_buffer_len=3,
       lex_start_pos=5,
       lex_curr_pos=6,
       lex_last_pos=7,
       lex_last_action=8,
       lex_eof_reached=9,
       lex_mem=10,
       lex_base=1,
       lex_backtrk=2,
       lex_default=3,
       lex_trans=4,
       lex_check=5,
       lex_base_code=6,
       lex_backtrk_code=7,
       lex_default_code=8,
       lex_trans_code=9,
       lex_check_code=10,
       lex_code=11;
      if(! tbl.lex_default)
       {tbl.lex_base = caml_lex_array(tbl[lex_base]);
        tbl.lex_backtrk = caml_lex_array(tbl[lex_backtrk]);
        tbl.lex_check = caml_lex_array(tbl[lex_check]);
        tbl.lex_trans = caml_lex_array(tbl[lex_trans]);
        tbl.lex_default = caml_lex_array(tbl[lex_default])}
      if(! tbl.lex_default_code)
       {tbl.lex_base_code = caml_lex_array(tbl[lex_base_code]);
        tbl.lex_backtrk_code = caml_lex_array(tbl[lex_backtrk_code]);
        tbl.lex_check_code = caml_lex_array(tbl[lex_check_code]);
        tbl.lex_trans_code = caml_lex_array(tbl[lex_trans_code]);
        tbl.lex_default_code = caml_lex_array(tbl[lex_default_code])}
      if(tbl.lex_code == null)
       tbl.lex_code = caml_jsbytes_of_string(tbl[lex_code]);
      var c,state=start_state,buffer=caml_array_of_bytes(lexbuf[lex_buffer]);
      if(state >= 0)
       {lexbuf[lex_last_pos] = lexbuf[lex_start_pos] = lexbuf[lex_curr_pos];
        lexbuf[lex_last_action] = - 1}
      else
       state = - state - 1;
      for(;;)
       {var base=tbl.lex_base[state];
        if(base < 0)
         {var pc_off=tbl.lex_base_code[state];
          caml_lex_run_tag(tbl.lex_code,pc_off,lexbuf[lex_mem]);
          return - base - 1}
        var backtrk=tbl.lex_backtrk[state];
        if(backtrk >= 0)
         {var pc_off=tbl.lex_backtrk_code[state];
          caml_lex_run_tag(tbl.lex_code,pc_off,lexbuf[lex_mem]);
          lexbuf[lex_last_pos] = lexbuf[lex_curr_pos];
          lexbuf[lex_last_action] = backtrk}
        if(lexbuf[lex_curr_pos] >= lexbuf[lex_buffer_len])
         if(lexbuf[lex_eof_reached] == 0)return - state - 1;else c = 256;
        else
         {c = buffer[lexbuf[lex_curr_pos]];lexbuf[lex_curr_pos]++}
        var pstate=state;
        if(tbl.lex_check[base + c] == state)
         state = tbl.lex_trans[base + c];
        else
         state = tbl.lex_default[state];
        if(state < 0)
         {lexbuf[lex_curr_pos] = lexbuf[lex_last_pos];
          if(lexbuf[lex_last_action] == - 1)
           caml_failwith("lexing: empty token");
          else
           return lexbuf[lex_last_action]}
        else
         {var base_code=tbl.lex_base_code[pstate],pc_off;
          if(tbl.lex_check_code[base_code + c] == pstate)
           pc_off = tbl.lex_trans_code[base_code + c];
          else
           pc_off = tbl.lex_default_code[pstate];
          if(pc_off > 0)
           caml_lex_run_mem
            (tbl.lex_code,pc_off,lexbuf[lex_mem],lexbuf[lex_curr_pos]);
          if(c == 256)lexbuf[lex_eof_reached] = 0}}}
    function caml_ba_uint8_set64(ba,i0,v)
     {var ofs=ba.offset(i0);
      if(ofs + 7 >= ba.data.length)caml_array_bound_error();
      var v=caml_int64_to_bytes(v);
      for(var i=0;i < 8;i++)ba.set(ofs + i,v[7 - i]);
      return 0}
    function caml_sys_executable_name(a){return caml_executable_name}
    function caml_lessequal(x,y){return + (caml_compare_val(x,y,false) <= 0)}
    function caml_ml_flush(chanid)
     {var chan=caml_ml_channels[chanid];
      if(! chan.opened)caml_raise_sys_error("Cannot flush a closed channel");
      if(! chan.buffer || chan.buffer == "")return 0;
      if
       (chan.fd
        &&
        caml_global_data.fds[chan.fd]
        &&
        caml_global_data.fds[chan.fd].output)
       {var output=caml_global_data.fds[chan.fd].output;
        switch(output.length)
         {case 2:output(chanid,chan.buffer);break;default:output(chan.buffer)}}
      chan.buffer = "";
      return 0}
    function caml_ml_seek_out_64(chanid,pos)
     {caml_ml_flush(chanid);
      caml_ml_channels[chanid].offset = caml_int64_to_float(pos);
      return 0}
    function compare_nat_real(nat1,nat2)
     {return compare_nat(nat1,0,nat1.data.length,nat2,0,nat2.data.length)}
    function caml_gc_set(_control){return 0}
    function caml_js_get(o,f){return o[f]}
    function caml_gc_compaction(){return 0}
    function caml_weak_get(x,i)
     {if(i < 0 || caml_ephe_key_offset + i >= x.length)
       caml_invalid_argument("Weak.get_key");
      return x[caml_ephe_key_offset + i] === undefined
              ?0
              :x[caml_ephe_key_offset + i]}
    var caml_ephe_get_key=caml_weak_get;
    function caml_bigstring_blit_bytes_to_ba(str1,pos1,ba2,pos2,len)
     {if(12 != ba2.kind)
       caml_invalid_argument
        ("caml_bigstring_blit_string_to_ba: kind mismatch");
      if(len == 0)return 0;
      var ofs2=ba2.offset(pos2);
      if(pos1 + len > caml_ml_bytes_length(str1))caml_array_bound_error();
      if(ofs2 + len > ba2.data.length)caml_array_bound_error();
      var slice=caml_array_of_bytes(str1).slice(pos1,pos1 + len);
      ba2.data.set(slice,ofs2);
      return 0}
    function win_cleanup(){}
    function caml_sys_close(fd){delete caml_global_data.fds[fd];return 0}
    function caml_ml_close_channel(chanid)
     {var chan=caml_ml_channels[chanid];
      caml_ml_flush(chanid);
      chan.opened = false;
      chan.file.close();
      caml_sys_close(chan.fd);
      return 0}
    function caml_exn_with_js_backtrace(exn,force)
     {if(! exn.js_error || force || exn[0] == 248)
       exn.js_error
       =
       new (joo_global_object.Error)("Js exception containing backtrace");
      return exn}
    function caml_sys_isatty(_chan){return 0}
    function is_digit_zero(nat,ofs){if(nat.data[ofs] == 0)return 1;return 0}
    function unix_inet_addr_of_string(){return 0}
    function caml_js_set(o,f,v){o[f] = v;return 0}
    function caml_array_get(array,index)
     {if(index < 0 || index >= array.length - 1)caml_array_bound_error();
      return array[index + 1]}
    function caml_spacetime_only_works_for_native_code()
     {caml_failwith("Spacetime profiling only works for native code")}
    function caml_int64_sub(x,y){return x.sub(y)}
    function caml_ml_seek_in_64(chanid,pos)
     {var chan=caml_ml_channels[chanid];
      if(chan.refill != null)caml_raise_sys_error("Illegal seek");
      chan.offset = caml_int64_to_float(pos);
      return 0}
    function caml_int64_shift_left(x,s){return x.shift_left(s)}
    function caml_notequal(x,y){return + (caml_compare_val(x,y,false) != 0)}
    function caml_sys_const_int_size(){return 32}
    function caml_js_wrap_meth_callback(f)
     {return function()
       {var len=arguments.length,args=new Array(len + 1);
        args[0] = this;
        for(var i=0;i < len;i++)args[i + 1] = arguments[i];
        return caml_call_gen(f,args)}}
    function caml_is_js(){return 1}
    function caml_ba_dim(ba,i)
     {if(i < 0 || i >= ba.dims.length)caml_invalid_argument("Bigarray.dim");
      return ba.dims[i]}
    function caml_ba_dim_1(ba){return caml_ba_dim(ba,0)}
    function unix_localtime(t)
     {var
       d=new Date(t * 1000),
       d_num=d.getTime(),
       januaryfirst=new Date(d.getFullYear(),0,1).getTime(),
       doy=Math.floor((d_num - januaryfirst) / 86400000),
       jan=new Date(d.getFullYear(),0,1),
       jul=new Date(d.getFullYear(),6,1),
       stdTimezoneOffset=
        Math.max(jan.getTimezoneOffset(),jul.getTimezoneOffset());
      return [0,
              d.getSeconds(),
              d.getMinutes(),
              d.getHours(),
              d.getDate(),
              d.getMonth(),
              d.getFullYear() - 1900,
              d.getDay(),
              doy,
              d.getTimezoneOffset() < stdTimezoneOffset | 0]}
    function caml_js_meth_call(o,f,args)
     {return o[caml_jsstring_of_string(f)].apply(o,caml_js_from_array(args))}
    function caml_weak_create(n)
     {if(n < 0)caml_invalid_argument("Weak.create");
      var x=[251,"caml_ephe_list_head"];
      x.length = caml_ephe_key_offset + n;
      return x}
    var caml_ephe_create=caml_weak_create;
    function caml_js_to_byte_string(s){return caml_string_of_jsbytes(s)}
    function unix_mktime(tm)
     {var
       d=new Date(tm[6] + 1900,tm[5],tm[4],tm[3],tm[2],tm[1]).getTime(),
       t=Math.floor(d / 1000),
       tm2=unix_localtime(t);
      return [0,t,tm2]}
    function caml_trampoline(res)
     {var c=1;
      while(res && res.joo_tramp)
       {res = res.joo_tramp.apply(null,res.joo_args);c++}
      return res}
    function caml_bytes_get64(s,i)
     {if(i >>> 0 >= s.l - 7)caml_bytes_bound_error();
      var a=new Array(8);
      for(var j=0;j < 8;j++)a[7 - j] = caml_bytes_unsafe_get(s,i + j);
      return caml_int64_of_bytes(a)}
    function caml_weak_set(x,i,v)
     {if(i < 0 || caml_ephe_key_offset + i >= x.length)
       caml_invalid_argument("Weak.set");
      x[caml_ephe_key_offset + i] = v;
      return 0}
    function caml_sys_remove(name)
     {var root=resolve_fs_device(name),ok=root.device.unlink(root.rest);
      if(ok == 0)caml_raise_no_such_file(name);
      return 0}
    function caml_string_bound_error()
     {caml_invalid_argument("index out of bounds")}
    function caml_string_get32(s,i)
     {if(i >>> 0 >= caml_ml_string_length(s) - 3)caml_string_bound_error();
      var
       b1=caml_string_unsafe_get(s,i),
       b2=caml_string_unsafe_get(s,i + 1),
       b3=caml_string_unsafe_get(s,i + 2),
       b4=caml_string_unsafe_get(s,i + 3);
      return b4 << 24 | b3 << 16 | b2 << 8 | b1}
    function caml_hypot_float(x,y)
     {var
       x=Math.abs(x),
       y=Math.abs(y),
       a=Math.max(x,y),
       b=Math.min(x,y) / (a?a:1);
      return a * Math.sqrt(1 + b * b)}
    function caml_js_call(f,o,args)
     {return f.apply(o,caml_js_from_array(args))}
    function caml_sys_const_max_wosize(){return 0x7FFFFFFF / 4 | 0}
    function caml_ephe_unset_key(x,i){return caml_weak_set(x,i,0)}
    function caml_hash_mix_bytes_arr(h,s)
     {var len=s.length,i,w;
      for(i = 0;i + 4 <= len;i += 4)
       {w = s[i] | s[i + 1] << 8 | s[i + 2] << 16 | s[i + 3] << 24;
        h = caml_hash_mix_int(h,w)}
      w = 0;
      switch(len & 3)
       {case 3:w = s[i + 2] << 16;
        case 2:w |= s[i + 1] << 8;
        case 1:w |= s[i];h = caml_hash_mix_int(h,w)
        }
      h ^= len;
      return h}
    function caml_hash_mix_jsbytes(h,s)
     {var len=s.length,i,w;
      for(i = 0;i + 4 <= len;i += 4)
       {w
        =
        s.charCodeAt(i)
        |
        s.charCodeAt(i + 1)
        <<
        8
        |
        s.charCodeAt(i + 2)
        <<
        16
        |
        s.charCodeAt(i + 3)
        <<
        24;
        h = caml_hash_mix_int(h,w)}
      w = 0;
      switch(len & 3)
       {case 3:w = s.charCodeAt(i + 2) << 16;
        case 2:w |= s.charCodeAt(i + 1) << 8;
        case 1:w |= s.charCodeAt(i);h = caml_hash_mix_int(h,w)
        }
      h ^= len;
      return h}
    function caml_hash_mix_bytes(h,v)
     {switch(v.t & 6)
       {default:caml_convert_string_to_bytes(v);case 0:
         h = caml_hash_mix_jsbytes(h,v.c);break;
        case 2:h = caml_hash_mix_bytes_arr(h,v.c)
        }
      return h}
    function caml_bytes_lessthan(s1,s2)
     {s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c < s2.c?1:0}
    function caml_gr_fill_poly(ar)
     {var s=caml_gr_state_get();
      s.context.beginPath();
      s.context.moveTo(ar[1][1],s.height - ar[1][2]);
      for(var i=2;i < ar.length;i++)
       s.context.lineTo(ar[i][1],s.height - ar[i][2]);
      s.context.lineTo(ar[1][1],s.height - ar[1][2]);
      s.context.fill();
      return 0}
    function caml_gc_quick_stat(){return [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]}
    function caml_raise_end_of_file()
     {caml_raise_constant(caml_global_data.End_of_file)}
    function caml_ml_input_int(chanid)
     {var chan=caml_ml_channels[chanid],file=chan.file;
      while(chan.offset + 3 >= file.length())
       {var l=caml_ml_refill_input(chan);if(l == 0)caml_raise_end_of_file()}
      var
       o=chan.offset,
       r=
        file.read_one(o)
        <<
        24
        |
        file.read_one(o + 1)
        <<
        16
        |
        file.read_one(o + 2)
        <<
        8
        |
        file.read_one(o + 3);
      chan.offset += 4;
      return r}
    function caml_gr_display_mode()
     {caml_failwith("caml_gr_display_mode not Implemented")}
    function nth_digit_nat(nat,ofs){return nat.data[ofs]}
    function caml_array_blit(a1,i1,a2,i2,len)
     {if(i2 <= i1)
       for(var j=1;j <= len;j++)a2[i2 + j] = a1[i1 + j];
      else
       for(var j=len;j >= 1;j--)a2[i2 + j] = a1[i1 + j];
      return 0}
    function caml_float_of_string(s)
     {var res;
      s = caml_jsbytes_of_string(s);
      res = + s;
      if(s.length > 0 && res === res)return res;
      s = s.replace(/_/g,"");
      res = + s;
      if(s.length > 0 && res === res || /^[+-]?nan$/i.test(s))return res;
      var m=/^ *([+-]?)0x([0-9a-f]+)\.?([0-9a-f]*)p([+-]?[0-9]+)/i.exec(s);
      if(m)
       {var
         m3=m[3].replace(/0+$/,""),
         mantissa=parseInt(m[1] + m[2] + m3,16),
         exponent=(m[4] | 0) - 4 * m3.length;
        res = mantissa * Math.pow(2,exponent);
        return res}
      if(/^\+?inf(inity)?$/i.test(s))return Infinity;
      if(/^-inf(inity)?$/i.test(s))return - Infinity;
      caml_failwith("float_of_string")}
    function caml_sys_getcwd()
     {return caml_string_of_jsbytes(caml_current_dir)}
    function caml_sys_const_big_endian(){return 0}
    function caml_list_to_js_array(l)
     {var a=[];for(;l !== 0;l = l[2])a.push(l[1]);return a}
    var
     caml_legacy_custom_code=false,
     caml_output_val=
      function()
        {function Writer(){this.chunk = []}
         Writer.prototype
         =
         {chunk_idx:20,
          block_len:0,
          obj_counter:0,
          size_32:0,
          size_64:0,
          write:
          function(size,value)
           {for(var i=size - 8;i >= 0;i -= 8)
             this.chunk[this.chunk_idx++] = value >> i & 0xFF},
          write_at:
          function(pos,size,value)
           {var pos=pos;
            for(var i=size - 8;i >= 0;i -= 8)
             this.chunk[pos++] = value >> i & 0xFF},
          write_code:
          function(size,code,value)
           {this.chunk[this.chunk_idx++] = code;
            for(var i=size - 8;i >= 0;i -= 8)
             this.chunk[this.chunk_idx++] = value >> i & 0xFF},
          write_shared:
          function(offset)
           {if(offset < 1 << 8)
             this.write_code(8,0x04,offset);
            else
             if(offset < 1 << 16)
              this.write_code(16,0x05,offset);
             else
              this.write_code(32,0x06,offset)},
          pos:function(){return this.chunk_idx},
          finalize:
          function()
           {this.block_len = this.chunk_idx - 20;
            this.chunk_idx = 0;
            this.write(32,0x8495A6BE);
            this.write(32,this.block_len);
            this.write(32,this.obj_counter);
            this.write(32,this.size_32);
            this.write(32,this.size_64);
            return this.chunk}};
         return function(v,flags)
          {flags = caml_list_to_js_array(flags);
           var
            no_sharing=flags.indexOf(0) !== - 1,
            closures=flags.indexOf(1) !== - 1;
           if(closures)
            joo_global_object.console.warn
             ("in caml_output_val: flag Marshal.Closures is not supported.");
           var
            writer=new Writer(),
            stack=[],
            intern_obj_table=no_sharing?null:new MlObjectTable();
           function memo(v)
            {if(no_sharing)return false;
             var existing_offset=intern_obj_table.recall(v);
             if(existing_offset)
              {writer.write_shared(existing_offset);return true}
             else
              {intern_obj_table.store(v);return false}}
           function extern_rec(v)
            {if(v.caml_custom)
              {if(memo(v))return;
               var
                name=v.caml_custom,
                ops=caml_custom_ops[name],
                sz_32_64=[0,0];
               if(! ops.serialize)
                caml_invalid_argument("output_value: abstract value (Custom)");
               if(caml_legacy_custom_code)
                {writer.write(8,0x12);
                 for(var i=0;i < name.length;i++)
                  writer.write(8,name.charCodeAt(i));
                 writer.write(8,0);
                 ops.serialize(writer,v,sz_32_64)}
               else
                if(ops.fixed_length == undefined)
                 {writer.write(8,0x18);
                  for(var i=0;i < name.length;i++)
                   writer.write(8,name.charCodeAt(i));
                  writer.write(8,0);
                  var header_pos=writer.pos();
                  for(var i=0;i < 12;i++)writer.write(8,0);
                  ops.serialize(writer,v,sz_32_64);
                  writer.write_at(header_pos,32,sz_32_64[0]);
                  writer.write_at(header_pos + 4,32,0);
                  writer.write_at(header_pos + 8,32,sz_32_64[1])}
                else
                 {writer.write(8,0x19);
                  for(var i=0;i < name.length;i++)
                   writer.write(8,name.charCodeAt(i));
                  writer.write(8,0);
                  var old_pos=writer.pos();
                  ops.serialize(writer,v,sz_32_64);
                  if(ops.fixed_length != writer.pos() - old_pos)
                   caml_failwith
                    ("output_value: incorrect fixed sizes specified by " + name)}
               writer.size_32 += 2 + (sz_32_64[0] + 3 >> 2);
               writer.size_64 += 2 + (sz_32_64[1] + 7 >> 3)}
             else
              if(v instanceof Array && v[0] === (v[0] | 0))
               {if(v[0] == 251)
                 caml_failwith("output_value: abstract value (Abstract)");
                if(v.length > 1 && memo(v))return;
                if(v[0] < 16 && v.length - 1 < 8)
                 writer.write(8,0x80 + v[0] + (v.length - 1 << 4));
                else
                 writer.write_code(32,0x08,v.length - 1 << 10 | v[0]);
                writer.size_32 += v.length;
                writer.size_64 += v.length;
                if(v.length > 1)stack.push(v,1)}
              else
               if(caml_is_ml_bytes(v))
                {if(! caml_is_ml_bytes(caml_string_of_jsbytes("")))
                  caml_failwith
                   ("output_value: [Bytes.t] cannot safely be marshaled with [--enable use-js-string]");
                 if(memo(v))return;
                 var len=caml_ml_bytes_length(v);
                 if(len < 0x20)
                  writer.write(8,0x20 + len);
                 else
                  if(len < 0x100)
                   writer.write_code(8,0x09,len);
                  else
                   writer.write_code(32,0x0A,len);
                 for(var i=0;i < len;i++)
                  writer.write(8,caml_bytes_unsafe_get(v,i));
                 writer.size_32 += 1 + ((len + 4) / 4 | 0);
                 writer.size_64 += 1 + ((len + 8) / 8 | 0)}
               else
                if(caml_is_ml_string(v))
                 {var len=caml_ml_string_length(v);
                  if(len < 0x20)
                   writer.write(8,0x20 + len);
                  else
                   if(len < 0x100)
                    writer.write_code(8,0x09,len);
                   else
                    writer.write_code(32,0x0A,len);
                  for(var i=0;i < len;i++)
                   writer.write(8,caml_string_unsafe_get(v,i));
                  writer.size_32 += 1 + ((len + 4) / 4 | 0);
                  writer.size_64 += 1 + ((len + 8) / 8 | 0)}
                else
                 if(v != (v | 0))
                  {var type_of_v=typeof v;
                   caml_failwith
                    ("output_value: abstract value (" + type_of_v + ")")}
                 else
                  if(v >= 0 && v < 0x40)
                   writer.write(8,0X40 + v);
                  else
                   if(v >= - (1 << 7) && v < 1 << 7)
                    writer.write_code(8,0x00,v);
                   else
                    if(v >= - (1 << 15) && v < 1 << 15)
                     writer.write_code(16,0x01,v);
                    else
                     writer.write_code(32,0x02,v)}
           extern_rec(v);
           while(stack.length > 0)
            {var i=stack.pop(),v=stack.pop();
             if(i + 1 < v.length)stack.push(v,i + 1);
             extern_rec(v[i])}
           if(intern_obj_table)
            writer.obj_counter = intern_obj_table.objs.length;
           writer.finalize();
           return writer.chunk}}
       ();
    function caml_string_of_array(a)
     {return caml_string_of_jsbytes(caml_subarray_to_jsbytes(a,0,a.length))}
    function caml_output_value_to_string(v,flags)
     {return caml_string_of_array(caml_output_val(v,flags))}
    function caml_raise_not_a_dir(name)
     {name = caml_jsbytes_of_string(name);
      caml_raise_sys_error(name + ": Not a directory")}
    function caml_sys_system_command(cmd)
     {var cmd=caml_jsstring_of_string(cmd);
      if
       (typeof require
        !=
        "undefined"
        &&
        require("child_process")
        &&
        require("child_process").execSync)
       try
        {require("child_process").execSync(cmd,{stdio:"inherit"});return 0}
       catch(e){return 1}
      else
       return 127}
    function unix_isatty(fileDescriptor)
     {if(fs_node_supported())
       {var tty=require("tty");return tty.isatty(fileDescriptor)}
      else
       return false}
    function caml_js_error_of_exception(exn)
     {if(exn.js_error)return exn.js_error;return null}
    function deserialize_nat(reader,sz)
     {var len=reader.read32s(),nat=new MlNat(len);
      for(var i=0;i < len;i++)nat.data[i] = reader.read32s();
      sz[0] = len * 4;
      return nat}
    function initialize_nat()
     {caml_custom_ops["_nat"]
      =
      {deserialize:deserialize_nat,serialize:serialize_nat,hash:caml_hash_nat}}
    function caml_gr_open_subwindow(a,b,c,d)
     {caml_failwith("caml_gr_open_subwindow not Implemented")}
    function js_print_stdout(s)
     {var s=caml_utf16_of_utf8(s),g=joo_global_object;
      if(g.process && g.process.stdout && g.process.stdout.write)
       g.process.stdout.write(s);
      else
       {if(s.charCodeAt(s.length - 1) == 10)s = s.substr(0,s.length - 1);
        var v=g.console;
        v && v.log && v.log(s)}}
    function caml_copysign_float(x,y)
     {if(y == 0)y = 1 / y;x = Math.abs(x);return y < 0?- x:x}
    function caml_gr_set_text_size(size)
     {var s=caml_gr_state_get();
      s.text_size = size;
      s.context.font = s.text_size + "px " + caml_jsstring_of_string(s.font);
      return 0}
    var
     caml_md5_bytes=
      function()
        {function add(x,y){return x + y | 0}
         function xx(q,a,b,x,s,t)
          {a = add(add(a,q),add(x,t));return add(a << s | a >>> 32 - s,b)}
         function ff(a,b,c,d,x,s,t){return xx(b & c | ~ b & d,a,b,x,s,t)}
         function gg(a,b,c,d,x,s,t){return xx(b & d | c & ~ d,a,b,x,s,t)}
         function hh(a,b,c,d,x,s,t){return xx(b ^ c ^ d,a,b,x,s,t)}
         function ii(a,b,c,d,x,s,t){return xx(c ^ (b | ~ d),a,b,x,s,t)}
         function md5(buffer,length)
          {var i=length;
           buffer[i >> 2] |= 0x80 << 8 * (i & 3);
           for(i = (i & ~ 0x3) + 8;(i & 0x3F) < 60;i += 4)
            buffer[(i >> 2) - 1] = 0;
           buffer[(i >> 2) - 1] = length << 3;
           buffer[i >> 2] = length >> 29 & 0x1FFFFFFF;
           var w=[0x67452301,0xEFCDAB89,0x98BADCFE,0x10325476];
           for(i = 0;i < buffer.length;i += 16)
            {var a=w[0],b=w[1],c=w[2],d=w[3];
             a = ff(a,b,c,d,buffer[i + 0],7,0xD76AA478);
             d = ff(d,a,b,c,buffer[i + 1],12,0xE8C7B756);
             c = ff(c,d,a,b,buffer[i + 2],17,0x242070DB);
             b = ff(b,c,d,a,buffer[i + 3],22,0xC1BDCEEE);
             a = ff(a,b,c,d,buffer[i + 4],7,0xF57C0FAF);
             d = ff(d,a,b,c,buffer[i + 5],12,0x4787C62A);
             c = ff(c,d,a,b,buffer[i + 6],17,0xA8304613);
             b = ff(b,c,d,a,buffer[i + 7],22,0xFD469501);
             a = ff(a,b,c,d,buffer[i + 8],7,0x698098D8);
             d = ff(d,a,b,c,buffer[i + 9],12,0x8B44F7AF);
             c = ff(c,d,a,b,buffer[i + 10],17,0xFFFF5BB1);
             b = ff(b,c,d,a,buffer[i + 11],22,0x895CD7BE);
             a = ff(a,b,c,d,buffer[i + 12],7,0x6B901122);
             d = ff(d,a,b,c,buffer[i + 13],12,0xFD987193);
             c = ff(c,d,a,b,buffer[i + 14],17,0xA679438E);
             b = ff(b,c,d,a,buffer[i + 15],22,0x49B40821);
             a = gg(a,b,c,d,buffer[i + 1],5,0xF61E2562);
             d = gg(d,a,b,c,buffer[i + 6],9,0xC040B340);
             c = gg(c,d,a,b,buffer[i + 11],14,0x265E5A51);
             b = gg(b,c,d,a,buffer[i + 0],20,0xE9B6C7AA);
             a = gg(a,b,c,d,buffer[i + 5],5,0xD62F105D);
             d = gg(d,a,b,c,buffer[i + 10],9,0x02441453);
             c = gg(c,d,a,b,buffer[i + 15],14,0xD8A1E681);
             b = gg(b,c,d,a,buffer[i + 4],20,0xE7D3FBC8);
             a = gg(a,b,c,d,buffer[i + 9],5,0x21E1CDE6);
             d = gg(d,a,b,c,buffer[i + 14],9,0xC33707D6);
             c = gg(c,d,a,b,buffer[i + 3],14,0xF4D50D87);
             b = gg(b,c,d,a,buffer[i + 8],20,0x455A14ED);
             a = gg(a,b,c,d,buffer[i + 13],5,0xA9E3E905);
             d = gg(d,a,b,c,buffer[i + 2],9,0xFCEFA3F8);
             c = gg(c,d,a,b,buffer[i + 7],14,0x676F02D9);
             b = gg(b,c,d,a,buffer[i + 12],20,0x8D2A4C8A);
             a = hh(a,b,c,d,buffer[i + 5],4,0xFFFA3942);
             d = hh(d,a,b,c,buffer[i + 8],11,0x8771F681);
             c = hh(c,d,a,b,buffer[i + 11],16,0x6D9D6122);
             b = hh(b,c,d,a,buffer[i + 14],23,0xFDE5380C);
             a = hh(a,b,c,d,buffer[i + 1],4,0xA4BEEA44);
             d = hh(d,a,b,c,buffer[i + 4],11,0x4BDECFA9);
             c = hh(c,d,a,b,buffer[i + 7],16,0xF6BB4B60);
             b = hh(b,c,d,a,buffer[i + 10],23,0xBEBFBC70);
             a = hh(a,b,c,d,buffer[i + 13],4,0x289B7EC6);
             d = hh(d,a,b,c,buffer[i + 0],11,0xEAA127FA);
             c = hh(c,d,a,b,buffer[i + 3],16,0xD4EF3085);
             b = hh(b,c,d,a,buffer[i + 6],23,0x04881D05);
             a = hh(a,b,c,d,buffer[i + 9],4,0xD9D4D039);
             d = hh(d,a,b,c,buffer[i + 12],11,0xE6DB99E5);
             c = hh(c,d,a,b,buffer[i + 15],16,0x1FA27CF8);
             b = hh(b,c,d,a,buffer[i + 2],23,0xC4AC5665);
             a = ii(a,b,c,d,buffer[i + 0],6,0xF4292244);
             d = ii(d,a,b,c,buffer[i + 7],10,0x432AFF97);
             c = ii(c,d,a,b,buffer[i + 14],15,0xAB9423A7);
             b = ii(b,c,d,a,buffer[i + 5],21,0xFC93A039);
             a = ii(a,b,c,d,buffer[i + 12],6,0x655B59C3);
             d = ii(d,a,b,c,buffer[i + 3],10,0x8F0CCC92);
             c = ii(c,d,a,b,buffer[i + 10],15,0xFFEFF47D);
             b = ii(b,c,d,a,buffer[i + 1],21,0x85845DD1);
             a = ii(a,b,c,d,buffer[i + 8],6,0x6FA87E4F);
             d = ii(d,a,b,c,buffer[i + 15],10,0xFE2CE6E0);
             c = ii(c,d,a,b,buffer[i + 6],15,0xA3014314);
             b = ii(b,c,d,a,buffer[i + 13],21,0x4E0811A1);
             a = ii(a,b,c,d,buffer[i + 4],6,0xF7537E82);
             d = ii(d,a,b,c,buffer[i + 11],10,0xBD3AF235);
             c = ii(c,d,a,b,buffer[i + 2],15,0x2AD7D2BB);
             b = ii(b,c,d,a,buffer[i + 9],21,0xEB86D391);
             w[0] = add(a,w[0]);
             w[1] = add(b,w[1]);
             w[2] = add(c,w[2]);
             w[3] = add(d,w[3])}
           var t=new Array(16);
           for(var i=0;i < 4;i++)
            for(var j=0;j < 4;j++)t[i * 4 + j] = w[i] >> 8 * j & 0xFF;
           return t}
         return function(s,ofs,len)
          {var buf=[];
           switch(s.t & 6)
            {default:caml_convert_string_to_bytes(s);case 0:
              var b=s.c;
              for(var i=0;i < len;i += 4)
               {var j=i + ofs;
                buf[i >> 2]
                =
                b.charCodeAt(j)
                |
                b.charCodeAt(j + 1)
                <<
                8
                |
                b.charCodeAt(j + 2)
                <<
                16
                |
                b.charCodeAt(j + 3)
                <<
                24}
              for(;i < len;i++)
               buf[i >> 2] |= b.charCodeAt(i + ofs) << 8 * (i & 3);
              break;
             case 4:
              var a=s.c;
              for(var i=0;i < len;i += 4)
               {var j=i + ofs;
                buf[i >> 2]
                =
                a[j]
                |
                a[j + 1]
                <<
                8
                |
                a[j + 2]
                <<
                16
                |
                a[j + 3]
                <<
                24}
              for(;i < len;i++)buf[i >> 2] |= a[i + ofs] << 8 * (i & 3)
             }
           return caml_string_of_array(md5(buf,len))}}
       ();
    function caml_ba_set_generic(ba,i,v)
     {ba.set(ba.offset(caml_js_from_array(i)),v);return 0}
    function caml_ephe_set_key(x,i,v){return caml_weak_set(x,i,[0,v])}
    function caml_bytes_lessequal(s1,s2)
     {s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c <= s2.c?1:0}
    function caml_string_lessequal(s1,s2){return caml_bytes_lessequal(s1,s2)}
    function caml_string_greaterequal(s1,s2)
     {return caml_string_lessequal(s2,s1)}
    function caml_int64_add(x,y){return x.add(y)}
    function caml_nextafter_float(x,y)
     {if(isNaN(x) || isNaN(y))return NaN;
      if(x == y)return y;
      if(x == 0)return y < 0?- Math.pow(2,- 1074):Math.pow(2,- 1074);
      var bits=caml_int64_bits_of_float(x),one=caml_int64_of_int32(1);
      if(x < y == x > 0)
       bits = caml_int64_add(bits,one);
      else
       bits = caml_int64_sub(bits,one);
      return caml_int64_float_of_bits(bits)}
    function caml_gr_size_y(){var s=caml_gr_state_get();return s.height}
    function caml_ml_pos_in(chanid){return caml_ml_channels[chanid].offset}
    function caml_int64_and(x,y){return x.and(y)}
    function caml_sys_const_word_size(){return 32}
    function caml_std_output(chanid,s)
     {var
       chan=caml_ml_channels[chanid],
       str=caml_string_of_jsbytes(s),
       slen=caml_ml_string_length(str);
      chan.file.write(chan.offset,str,0,slen);
      chan.offset += slen;
      return 0}
    function js_print_stderr(s)
     {var s=caml_utf16_of_utf8(s),g=joo_global_object;
      if(g.process && g.process.stdout && g.process.stdout.write)
       g.process.stderr.write(s);
      else
       {if(s.charCodeAt(s.length - 1) == 10)s = s.substr(0,s.length - 1);
        var v=g.console;
        v && v.error && v.error(s)}}
    function caml_sys_open_internal(idx,output,file,flags)
     {if(caml_global_data.fds === undefined)
       caml_global_data.fds = new Array();
      flags = flags?flags:{};
      var info={};
      info.file = file;
      info.offset = flags.append?file.length():0;
      info.flags = flags;
      info.output = output;
      caml_global_data.fds[idx] = info;
      if(! caml_global_data.fd_last_idx || idx > caml_global_data.fd_last_idx)
       caml_global_data.fd_last_idx = idx;
      return idx}
    function caml_sys_open(name,flags,_perms)
     {var f={};
      while(flags)
       {switch(flags[1])
         {case 0:f.rdonly = 1;break;
          case 1:f.wronly = 1;break;
          case 2:f.append = 1;break;
          case 3:f.create = 1;break;
          case 4:f.truncate = 1;break;
          case 5:f.excl = 1;break;
          case 6:f.binary = 1;break;
          case 7:f.text = 1;break;
          case 8:f.nonblock = 1;break
          }
        flags = flags[2]}
      if(f.rdonly && f.wronly)
       caml_raise_sys_error
        (caml_jsbytes_of_string(name)
         +
         " : flags Open_rdonly and Open_wronly are not compatible");
      if(f.text && f.binary)
       caml_raise_sys_error
        (caml_jsbytes_of_string(name)
         +
         " : flags Open_text and Open_binary are not compatible");
      var
       root=resolve_fs_device(name),
       file=root.device.open(root.rest,f),
       idx=caml_global_data.fd_last_idx?caml_global_data.fd_last_idx:0;
      return caml_sys_open_internal(idx + 1,caml_std_output,file,f)}
    caml_sys_open_internal
     (0,caml_std_output,new MlFakeFile(caml_create_bytes(0)));
    caml_sys_open_internal
     (1,js_print_stdout,new MlFakeFile(caml_create_bytes(0)));
    caml_sys_open_internal
     (2,js_print_stderr,new MlFakeFile(caml_create_bytes(0)));
    function MlStringReader(s,i)
     {this.s = caml_jsbytes_of_string(s);this.i = i}
    MlStringReader.prototype
    =
    {read8u:function(){return this.s.charCodeAt(this.i++)},
     read8s:function(){return this.s.charCodeAt(this.i++) << 24 >> 24},
     read16u:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 2;
       return s.charCodeAt(i) << 8 | s.charCodeAt(i + 1)},
     read16s:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 2;
       return s.charCodeAt(i) << 24 >> 16 | s.charCodeAt(i + 1)},
     read32u:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 4;
       return (s.charCodeAt(i)
               <<
               24
               |
               s.charCodeAt(i + 1)
               <<
               16
               |
               s.charCodeAt(i + 2)
               <<
               8
               |
               s.charCodeAt(i + 3))
              >>>
              0},
     read32s:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 4;
       return s.charCodeAt(i)
              <<
              24
              |
              s.charCodeAt(i + 1)
              <<
              16
              |
              s.charCodeAt(i + 2)
              <<
              8
              |
              s.charCodeAt(i + 3)},
     readstr:
     function(len)
      {var i=this.i;
       this.i = i + len;
       return caml_string_of_jsbytes(this.s.substring(i,i + len))}};
    function caml_float_of_bytes(a)
     {return caml_int64_float_of_bits(caml_int64_of_bytes(a))}
    function caml_input_value_from_reader(reader,ofs)
     {var
       _magic=reader.read32u(),
       _block_len=reader.read32u(),
       num_objects=reader.read32u(),
       _size_32=reader.read32u(),
       _size_64=reader.read32u(),
       stack=[],
       intern_obj_table=num_objects > 0?[]:null,
       obj_counter=0;
      function intern_rec()
       {var code=reader.read8u();
        if(code >= 0x40)
         if(code >= 0x80)
          {var tag=code & 0xF,size=code >> 4 & 0x7,v=[tag];
           if(size == 0)return v;
           if(intern_obj_table)intern_obj_table[obj_counter++] = v;
           stack.push(v,size);
           return v}
         else
          return code & 0x3F;
        else
         if(code >= 0x20)
          {var len=code & 0x1F,v=reader.readstr(len);
           if(intern_obj_table)intern_obj_table[obj_counter++] = v;
           return v}
         else
          switch(code)
           {case 0x00:return reader.read8s();
            case 0x01:return reader.read16s();
            case 0x02:return reader.read32s();
            case 0x03:caml_failwith("input_value: integer too large");break;
            case 0x04:
             var offset=reader.read8u();
             return intern_obj_table[obj_counter - offset];
            case 0x05:
             var offset=reader.read16u();
             return intern_obj_table[obj_counter - offset];
            case 0x06:
             var offset=reader.read32u();
             return intern_obj_table[obj_counter - offset];
            case 0x08:
             var
              header=reader.read32u(),
              tag=header & 0xFF,
              size=header >> 10,
              v=[tag];
             if(size == 0)return v;
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             stack.push(v,size);
             return v;
            case 0x13:
             caml_failwith("input_value: data block too large");break;
            case 0x09:
             var len=reader.read8u(),v=reader.readstr(len);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            case 0x0A:
             var len=reader.read32u(),v=reader.readstr(len);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            case 0x0C:
             var t=new Array(8);
             for(var i=0;i < 8;i++)t[7 - i] = reader.read8u();
             var v=caml_float_of_bytes(t);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            case 0x0B:
             var t=new Array(8);
             for(var i=0;i < 8;i++)t[i] = reader.read8u();
             var v=caml_float_of_bytes(t);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            case 0x0E:
             var len=reader.read8u(),v=new Array(len + 1);
             v[0] = 254;
             var t=new Array(8);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             for(var i=1;i <= len;i++)
              {for(var j=0;j < 8;j++)t[7 - j] = reader.read8u();
               v[i] = caml_float_of_bytes(t)}
             return v;
            case 0x0D:
             var len=reader.read8u(),v=new Array(len + 1);
             v[0] = 254;
             var t=new Array(8);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             for(var i=1;i <= len;i++)
              {for(var j=0;j < 8;j++)t[j] = reader.read8u();
               v[i] = caml_float_of_bytes(t)}
             return v;
            case 0x07:
             var len=reader.read32u(),v=new Array(len + 1);
             v[0] = 254;
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             var t=new Array(8);
             for(var i=1;i <= len;i++)
              {for(var j=0;j < 8;j++)t[7 - j] = reader.read8u();
               v[i] = caml_float_of_bytes(t)}
             return v;
            case 0x0F:
             var len=reader.read32u(),v=new Array(len + 1);
             v[0] = 254;
             var t=new Array(8);
             for(var i=1;i <= len;i++)
              {for(var j=0;j < 8;j++)t[j] = reader.read8u();
               v[i] = caml_float_of_bytes(t)}
             return v;
            case 0x10:
            case 0x11:caml_failwith("input_value: code pointer");break;
            case 0x12:
            case 0x18:
            case 0x19:
             var c,s="";
             while((c = reader.read8u()) != 0)s += String.fromCharCode(c);
             var ops=caml_custom_ops[s],expected_size;
             if(! ops)
              caml_failwith("input_value: unknown custom block identifier");
             switch(code)
              {case 0x12:break;
               case 0x19:
                if(! ops.fixed_length)
                 caml_failwith
                  ("input_value: expected a fixed-size custom block");
                expected_size = ops.fixed_length;
                break;
               case 0x18:
                expected_size = reader.read32u();
                reader.read32s();
                reader.read32s();
                break
               }
             var old_pos=reader.i,size=[0],v=ops.deserialize(reader,size);
             if(expected_size != undefined)
              if(expected_size != size[0])
               caml_failwith
                ("input_value: incorrect length of serialized custom block");
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            default:caml_failwith("input_value: ill-formed message")}}
      var res=intern_rec();
      while(stack.length > 0)
       {var size=stack.pop(),v=stack.pop(),d=v.length;
        if(d < size)stack.push(v,size);
        v[d] = intern_rec()}
      if(typeof ofs != "number")ofs[0] = reader.i;
      return res}
    function caml_string_of_bytes(s){return s}
    function caml_input_value_from_bytes(s,ofs)
     {var
       reader=
        new
         MlStringReader
         (caml_string_of_bytes(s),typeof ofs == "number"?ofs:ofs[0]);
      return caml_input_value_from_reader(reader,ofs)}
    function caml_string_get(s,i)
     {if(i >>> 0 >= caml_ml_string_length(s))caml_string_bound_error();
      return caml_string_unsafe_get(s,i)}
    var
     re_match=
      function()
        {var
          re_word_letters=
           [0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0xFF,
            0x03,
            0xFE,
            0xFF,
            0xFF,
            0x87,
            0xFE,
            0xFF,
            0xFF,
            0x07,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0xFF,
            0xFF,
            0x7F,
            0xFF,
            0xFF,
            0xFF,
            0x7F,
            0xFF],
          opcodes=
           {CHAR:0,
            CHARNORM:1,
            STRING:2,
            STRINGNORM:3,
            CHARCLASS:4,
            BOL:5,
            EOL:6,
            WORDBOUNDARY:7,
            BEGGROUP:8,
            ENDGROUP:9,
            REFGROUP:10,
            ACCEPT:11,
            SIMPLEOPT:12,
            SIMPLESTAR:13,
            SIMPLEPLUS:14,
            GOTO:15,
            PUSHBACK:16,
            SETMARK:17,
            CHECKPROGRESS:18};
         function is_word_letter(c)
          {return re_word_letters[c >> 3] >> (c & 7) & 1}
         function in_bitset(s,i)
          {return caml_string_get(s,i >> 3) >> (i & 7) & 1}
         function re_match_impl(re,s,pos,partial)
          {var
            prog=caml_js_from_array(re[1]),
            cpool=caml_js_from_array(re[2]),
            normtable=caml_jsbytes_of_string(re[3]),
            numgroups=re[4] | 0,
            numregisters=re[5] | 0,
            startchars=re[6] | 0,
            s=caml_array_of_string(s),
            pc=0,
            quit=false,
            stack=[],
            groups=new Array(numgroups),
            re_register=new Array(numregisters);
           for(var i=0;i < groups.length;i++)groups[i] = {start:- 1,end:- 1};
           groups[0].start = pos;
           function backtrack()
            {while(stack.length)
              {var item=stack.pop();
               if(item.undo)
                item.undo.obj[item.undo.prop] = item.undo.value;
               else
                if(item.pos){pc = item.pos.pc;pos = item.pos.txt;return}}
             quit = true}
           function push(item){stack.push(item)}
           function accept()
            {groups[0].end = pos;
             var result=new Array(1 + groups.length * 2);
             result[0] = 0;
             for(var i=0;i < groups.length;i++)
              {var g=groups[i];
               if(g.start < 0 || g.end < 0)g.start = g.end = - 1;
               result[2 * i + 1] = g.start;
               result[2 * i + 1 + 1] = g.end}
             return result}
           function prefix_match()
            {if(partial)return accept();else backtrack()}
           while(! quit)
            {var
              op=prog[pc] & 0xff,
              sarg=prog[pc] >> 8,
              uarg=sarg & 0xff,
              c=s[pos],
              group;
             pc++;
             switch(op)
              {case opcodes.CHAR:
                if(pos === s.length){prefix_match();break}
                if(c === uarg)pos++;else backtrack();
                break;
               case opcodes.CHARNORM:
                if(pos === s.length){prefix_match();break}
                if(normtable.charCodeAt(c) === uarg)pos++;else backtrack();
                break;
               case opcodes.STRING:
                for
                 (var arg=caml_jsbytes_of_string(cpool[uarg]),i=0;
                  i
                  <
                  arg.length;
                  i++)
                 {if(pos === s.length){prefix_match();break}
                  if(c === arg.charCodeAt(i))
                   c = s[++pos];
                  else
                   {backtrack();break}}
                break;
               case opcodes.STRINGNORM:
                for
                 (var arg=caml_jsbytes_of_string(cpool[uarg]),i=0;
                  i
                  <
                  arg.length;
                  i++)
                 {if(pos === s.length){prefix_match();break}
                  if(normtable.charCodeAt(c) === arg.charCodeAt(i))
                   c = s[++pos];
                  else
                   {backtrack();break}}
                break;
               case opcodes.CHARCLASS:
                if(pos === s.length){prefix_match();break}
                if(in_bitset(cpool[uarg],c))pos++;else backtrack();
                break;
               case opcodes.BOL:
                if(pos > 0 && s[pos - 1] != 10)backtrack();break;
               case opcodes.EOL:
                if(pos < s.length && s[pos] != 10)backtrack();break;
               case opcodes.WORDBOUNDARY:
                if(pos == 0)
                 {if(pos === s.length){prefix_match();break}
                  if(is_word_letter(s[0]))break;
                  backtrack()}
                else
                 if(pos === s.length)
                  {if(is_word_letter(s[pos - 1]))break;backtrack()}
                 else
                  {if(is_word_letter(s[pos - 1]) != is_word_letter(s[pos]))
                    break;
                   backtrack()}
                break;
               case opcodes.BEGGROUP:
                group = groups[uarg];
                push({undo:{obj:group,prop:"start",value:group.start}});
                group.start = pos;
                break;
               case opcodes.ENDGROUP:
                group = groups[uarg];
                push({undo:{obj:group,prop:"end",value:group.end}});
                group.end = pos;
                break;
               case opcodes.REFGROUP:
                group = groups[uarg];
                if(group.start < 0 || group.end < 0){backtrack();break}
                for(var i=group.start;i < group.end;i++)
                 {if(pos === s.length){prefix_match();break}
                  if(s[i] != s[pos]){backtrack();break}
                  pos++}
                break;
               case opcodes.SIMPLEOPT:if(in_bitset(cpool[uarg],c))pos++;break;
               case opcodes.SIMPLESTAR:
                while(in_bitset(cpool[uarg],c))c = s[++pos];break;
               case opcodes.SIMPLEPLUS:
                if(pos === s.length){prefix_match();break}
                if(in_bitset(cpool[uarg],c))
                 do c = s[++pos];while(in_bitset(cpool[uarg],c));
                else
                 backtrack();
                break;
               case opcodes.ACCEPT:return accept();
               case opcodes.GOTO:pc = pc + sarg;break;
               case opcodes.PUSHBACK:push({pos:{pc:pc + sarg,txt:pos}});break;
               case opcodes.SETMARK:
                push
                 ({undo:{obj:re_register,prop:uarg,value:re_register[uarg]}});
                re_register[uarg] = pos;
                break;
               case opcodes.CHECKPROGRESS:
                if(re_register[uarg] === pos)backtrack();break;
               default:throw new Error("Invalid bytecode")}}
           return 0}
         return re_match_impl}
       ();
    function re_search_backward(re,s,pos)
     {if(pos < 0 || pos > caml_ml_string_length(s))
       caml_invalid_argument("Str.search_backward");
      while(pos >= 0){var res=re_match(re,s,pos,0);if(res)return res;pos--}
      return [0]}
    function caml_js_from_string(s){return caml_jsstring_of_string(s)}
    function caml_ba_sub(ba,ofs,len)
     {var changed_dim,mul=1;
      if(ba.layout == 0)
       {for(var i=1;i < ba.dims.length;i++)mul = mul * ba.dims[i];
        changed_dim = 0}
      else
       {for(var i=0;i < ba.dims.length - 1;i++)mul = mul * ba.dims[i];
        changed_dim = ba.dims.length - 1;
        ofs = ofs - 1}
      if(ofs < 0 || len < 0 || ofs + len > ba.dims[changed_dim])
       caml_invalid_argument("Bigarray.sub: bad sub-array");
      var new_dims=[];
      for(var i=0;i < ba.dims.length;i++)new_dims[i] = ba.dims[i];
      new_dims[changed_dim] = len;
      mul *= caml_ba_get_size_per_element(ba.kind);
      var new_data=ba.data.subarray(ofs * mul,(ofs + len) * mul);
      return caml_ba_create_unsafe(ba.kind,ba.layout,new_dims,new_data)}
    function caml_gc_full_major(){return 0}
    function caml_bytes_set32(s,i,i32)
     {if(i >>> 0 >= s.l - 3)caml_bytes_bound_error();
      var
       b4=0xFF & i32 >> 24,
       b3=0xFF & i32 >> 16,
       b2=0xFF & i32 >> 8,
       b1=0xFF & i32;
      caml_bytes_unsafe_set(s,i + 0,b1);
      caml_bytes_unsafe_set(s,i + 1,b2);
      caml_bytes_unsafe_set(s,i + 2,b3);
      caml_bytes_unsafe_set(s,i + 3,b4);
      return 0}
    function caml_gr_sigio_signal(){return 0}
    function caml_ba_uint8_set32(ba,i0,v)
     {var ofs=ba.offset(i0);
      if(ofs + 3 >= ba.data.length)caml_array_bound_error();
      ba.set(ofs + 0,v & 0xff);
      ba.set(ofs + 1,v >>> 8 & 0xff);
      ba.set(ofs + 2,v >>> 16 & 0xff);
      ba.set(ofs + 3,v >>> 24 & 0xff);
      return 0}
    function caml_sys_const_ostype_unix(){return 1}
    function caml_signbit_float(x){if(x == 0)x = 1 / x;return x < 0?1:0}
    function caml_gr_current_x(){var s=caml_gr_state_get();return s.x}
    function caml_gr_set_line_width(w)
     {var s=caml_gr_state_get();
      s.line_width = w;
      s.context.lineWidth = w;
      return 0}
    function caml_gr_set_font(f)
     {var s=caml_gr_state_get();
      s.font = f;
      s.context.font = s.text_size + "px " + caml_jsstring_of_string(s.font);
      return 0}
    function caml_gr_set_color(color)
     {var s=caml_gr_state_get();
      function convert(number)
       {var str="" + number.toString(16);
        while(str.length < 2)str = "0" + str;
        return str}
      var r=color >> 16 & 0xff,g=color >> 8 & 0xff,b=color >> 0 & 0xff;
      s.color = color;
      var c_str="#" + convert(r) + convert(g) + convert(b);
      s.context.fillStyle = c_str;
      s.context.strokeStyle = c_str;
      return 0}
    function caml_gr_moveto(x,y)
     {var s=caml_gr_state_get();s.x = x;s.y = y;return 0}
    function caml_gr_resize_window(w,h)
     {var s=caml_gr_state_get();
      s.width = w;
      s.height = h;
      s.canvas.width = w;
      s.canvas.height = h;
      return 0}
    function caml_gr_state_init()
     {caml_gr_moveto(caml_gr_state.x,caml_gr_state.y);
      caml_gr_resize_window(caml_gr_state.width,caml_gr_state.height);
      caml_gr_set_line_width(caml_gr_state.line_width);
      caml_gr_set_text_size(caml_gr_state.text_size);
      caml_gr_set_font(caml_gr_state.font);
      caml_gr_set_color(caml_gr_state.color);
      caml_gr_set_window_title(caml_gr_state.title);
      caml_gr_state.context.textBaseline = "bottom"}
    function caml_ba_kind_of_typed_array(ta)
     {var g=joo_global_object,kind;
      if(ta instanceof g.Float32Array)
       kind = 0;
      else
       if(ta instanceof g.Float64Array)
        kind = 1;
       else
        if(ta instanceof g.Int8Array)
         kind = 2;
        else
         if(ta instanceof g.Uint8Array)
          kind = 3;
         else
          if(ta instanceof g.Int16Array)
           kind = 4;
          else
           if(ta instanceof g.Uint16Array)
            kind = 5;
           else
            if(ta instanceof g.Int32Array)
             kind = 6;
            else
             if(ta instanceof g.Uint32Array)
              kind = 6;
             else
              caml_invalid_argument
               ("caml_ba_kind_of_typed_array: unsupported kind");
      return kind}
    function caml_ba_from_typed_array(ta)
     {var kind=caml_ba_kind_of_typed_array(ta);
      return caml_ba_create_unsafe(kind,0,[ta.length],ta)}
    function caml_ml_seek_out(chanid,pos)
     {caml_ml_flush(chanid);caml_ml_channels[chanid].offset = pos;return 0}
    function caml_js_typeof(o){return typeof o}
    function caml_restore_raw_backtrace(exn,bt){return 0}
    function caml_gr_lineto(x,y)
     {var s=caml_gr_state_get();
      s.context.beginPath();
      s.context.moveTo(s.x,s.height - s.y);
      s.context.lineTo(x,s.height - y);
      s.context.stroke();
      s.x = x;
      s.y = y;
      return 0}
    function caml_js_wrap_meth_callback_unsafe(f)
     {return function()
       {var len=arguments.length,args=new Array(len + 1);
        args[0] = this;
        for(var i=0;i < len;i++)args[i + 1] = arguments[i];
        return f.apply(null,args)}}
    function caml_ba_dim_3(ba){return caml_ba_dim(ba,2)}
    var caml_ephe_data_offset=2;
    function caml_ephe_check_data(x)
     {return x[caml_ephe_data_offset] === undefined?0:1}
    function caml_bytes_get16(s,i)
     {if(i >>> 0 >= s.l - 1)caml_bytes_bound_error();
      var b1=caml_bytes_unsafe_get(s,i),b2=caml_bytes_unsafe_get(s,i + 1);
      return b2 << 8 | b1}
    function caml_obj_make_forward(b,v){b[0] = 250;b[1] = v;return 0}
    function caml_js_from_bool(x){return ! ! x}
    function caml_ml_set_channel_name(){return 0}
    function caml_gr_close_graph()
     {var s=caml_gr_state_get();
      s.canvas.width = 0;
      s.canvas.height = 0;
      return 0}
    function caml_create_string(len)
     {if(len < 0)caml_invalid_argument("String.create");
      return new MlBytes(len?2:9,"",len)}
    function caml_md5_string(s,ofs,len)
     {return caml_md5_bytes(caml_bytes_of_string(s),ofs,len)}
    function caml_md5_chan(chanid,len)
     {var chan=caml_ml_channels[chanid],chan_len=chan.file.length();
      if(len < 0)len = chan_len - chan.offset;
      if(chan.offset + len > chan_len)caml_raise_end_of_file();
      var buf=caml_create_bytes(len);
      chan.file.read(chan.offset,buf,0,len);
      return caml_md5_string(caml_string_of_bytes(buf),0,len)}
    function caml_obj_dup(x)
     {var l=x.length,a=new Array(l);
      for(var i=0;i < l;i++)a[i] = x[i];
      return a}
    function caml_weak_get_copy(x,i)
     {if(i < 0 || caml_ephe_key_offset + i >= x.length)
       caml_invalid_argument("Weak.get_copy");
      var y=caml_weak_get(x,i);
      if(y === 0)return y;
      var z=y[1];
      if(z instanceof Array)return [0,caml_obj_dup(z)];
      return y}
    function caml_ml_output_bytes(chanid,buffer,offset,len)
     {var chan=caml_ml_channels[chanid];
      if(! chan.opened)
       caml_raise_sys_error("Cannot output to a closed channel");
      var bytes;
      if(offset == 0 && caml_ml_bytes_length(buffer) == len)
       bytes = buffer;
      else
       {bytes = caml_create_bytes(len);
        caml_blit_bytes(buffer,offset,bytes,0,len)}
      var
       string=caml_string_of_bytes(bytes),
       jsstring=caml_jsbytes_of_string(string),
       id=jsstring.lastIndexOf("\n");
      if(id < 0)
       chan.buffer += jsstring;
      else
       {chan.buffer += jsstring.substr(0,id + 1);
        caml_ml_flush(chanid);
        chan.buffer += jsstring.substr(id + 1)}
      return 0}
    function caml_ml_output(chanid,buffer,offset,len)
     {return caml_ml_output_bytes
              (chanid,caml_bytes_of_string(buffer),offset,len)}
    function caml_ephe_get_data(x)
     {return x[caml_ephe_data_offset] === undefined
              ?0
              :[0,x[caml_ephe_data_offset]]}
    function caml_xmlhttprequest_create(unit)
     {var g=joo_global_object;
      if(typeof g.XMLHttpRequest !== "undefined")
       try {return new (g.XMLHttpRequest)()}catch(e){}
      if(typeof g.activeXObject !== "undefined")
       {try {return new (g.activeXObject)("Msxml2.XMLHTTP")}catch(e){}
        try {return new (g.activeXObject)("Msxml3.XMLHTTP")}catch(e){}
        try {return new (g.activeXObject)("Microsoft.XMLHTTP")}catch(e){}}
      caml_failwith("Cannot create a XMLHttpRequest")}
    function caml_trampoline_return(f,args)
     {return {joo_tramp:f,joo_args:args}}
    function caml_array_append(a1,a2)
     {var l1=a1.length,l2=a2.length,l=l1 + l2 - 1,a=new Array(l);
      a[0] = 0;
      var i=1,j=1;
      for(;i < l1;i++)a[i] = a1[i];
      for(;i < l;i++,j++)a[i] = a2[j];
      return a}
    function caml_ml_set_channel_refill(chanid,f)
     {caml_ml_channels[chanid].refill = f;return 0}
    function caml_js_expr(s)
     {js_print_stderr("caml_js_expr: fallback to runtime evaluation\n");
      return eval(caml_jsstring_of_string(s))}
    function caml_int64_mul(x,y){return x.mul(y)}
    function caml_ml_runtime_warnings_enabled(_unit)
     {return caml_runtime_warnings}
    function caml_output_value_to_bytes(v,flags)
     {return caml_bytes_of_array(caml_output_val(v,flags))}
    function caml_hash_univ_param(count,limit,obj)
     {var hash_accu=0;
      function hash_aux(obj)
       {limit--;
        if(count < 0 || limit < 0)return;
        if(obj instanceof Array && obj[0] === (obj[0] | 0))
         switch(obj[0])
          {case 248:count--;hash_accu = hash_accu * 65599 + obj[2] | 0;break;
           case 250:limit++;hash_aux(obj);break;
           default:
            count--;
            hash_accu = hash_accu * 19 + obj[0] | 0;
            for(var i=obj.length - 1;i > 0;i--)hash_aux(obj[i])}
        else
         if(caml_is_ml_bytes(obj))
          {count--;
           switch(obj.t & 6)
            {default:caml_convert_string_to_bytes(obj);case 0:
              for(var b=obj.c,l=caml_ml_bytes_length(obj),i=0;i < l;i++)
               hash_accu = hash_accu * 19 + b.charCodeAt(i) | 0;
              break;
             case 2:
              for(var a=obj.c,l=caml_ml_bytes_length(obj),i=0;i < l;i++)
               hash_accu = hash_accu * 19 + a[i] | 0
             }}
         else
          if(caml_is_ml_string(obj))
           {var jsbytes=caml_jsbytes_of_string(obj);
            for(var b=jsbytes,l=jsbytes.length,i=0;i < l;i++)
             hash_accu = hash_accu * 19 + b.charCodeAt(i) | 0}
          else
           if(typeof obj === "string")
            for(var b=obj,l=obj.length,i=0;i < l;i++)
             hash_accu = hash_accu * 19 + b.charCodeAt(i) | 0;
           else
            if(obj === (obj | 0))
             {count--;hash_accu = hash_accu * 65599 + obj | 0}
            else
             if(obj === + obj)
              {count--;
               var p=caml_int64_to_bytes(caml_int64_bits_of_float(obj));
               for(var i=7;i >= 0;i--)hash_accu = hash_accu * 19 + p[i] | 0}
             else
              if(obj && obj.caml_custom)
               if
                (caml_custom_ops[obj.caml_custom]
                 &&
                 caml_custom_ops[obj.caml_custom].hash)
                {var h=caml_custom_ops[obj.caml_custom].hash(obj) | 0;
                 hash_accu = hash_accu * 65599 + h | 0}}
      hash_aux(obj);
      return hash_accu & 0x3FFFFFFF}
    function caml_string_equal(s1,s2){return caml_bytes_equal(s1,s2)}
    function caml_output_value_to_buffer(s,ofs,len,v,flags)
     {var t=caml_output_val(v,flags);
      if(t.length > len)caml_failwith("Marshal.to_buffer: buffer overflow");
      caml_blit_bytes(t,0,s,ofs,t.length);
      return 0}
    function re_replacement_text(repl,groups,orig)
     {var
       repl=caml_jsbytes_of_string(repl),
       len=repl.length,
       orig=caml_jsbytes_of_string(orig),
       res="",
       n=0,
       cur,
       start,
       end,
       c;
      while(n < len)
       {cur = repl.charAt(n++);
        if(cur != "\\")
         res += cur;
        else
         {if(n == len)
           caml_failwith("Str.replace: illegal backslash sequence");
          cur = repl.charAt(n++);
          switch(cur)
           {case "\\":res += cur;break;
            case "0":
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7":
            case "8":
            case "9":
             c = + cur;
             if(c * 2 >= groups.length - 1)
              caml_failwith("Str.replace: reference to unmatched group");
             start = caml_array_get(groups,c * 2);
             end = caml_array_get(groups,c * 2 + 1);
             if(start == - 1)
              caml_failwith("Str.replace: reference to unmatched group");
             res += orig.slice(start,end);
             break;
            default:res += "\\" + cur}}}
      return caml_string_of_jsbytes(res)}
    function caml_pure_js_expr(s)
     {js_print_stderr("caml_pure_js_expr: fallback to runtime evaluation\n");
      return eval(caml_jsstring_of_string(s))}
    function blit_nat(nat1,ofs1,nat2,ofs2,len)
     {for(var i=0;i < len;i++)nat1.data[ofs1 + i] = nat2.data[ofs2 + i];
      return 0}
    function caml_int64_ult(x,y){return x.ucompare(y) < 0}
    function caml_int64_xor(x,y){return x.xor(y)}
    function caml_bigstring_blit_ba_to_bytes(ba1,pos1,bytes2,pos2,len)
     {if(12 != ba1.kind)
       caml_invalid_argument
        ("caml_bigstring_blit_string_to_ba: kind mismatch");
      if(len == 0)return 0;
      var ofs1=ba1.offset(pos1);
      if(ofs1 + len > ba1.data.length)caml_array_bound_error();
      if(pos2 + len > caml_ml_bytes_length(bytes2))caml_array_bound_error();
      var slice=ba1.data.slice(ofs1,ofs1 + len);
      caml_blit_bytes(caml_bytes_of_array(slice),0,bytes2,pos2,len);
      return 0}
    function caml_register_named_value(nm,v)
     {caml_named_values[caml_jsbytes_of_string(nm)] = v;return 0}
    function caml_to_js_string(s){return caml_jsstring_of_string(s)}
    function caml_parse_sign_and_base(s)
     {var i=0,len=caml_ml_string_length(s),base=10,sign=1;
      if(len > 0)
       switch(caml_string_unsafe_get(s,i))
        {case 45:i++;sign = - 1;break;case 43:i++;sign = 1;break}
      if(i + 1 < len && caml_string_unsafe_get(s,i) == 48)
       switch(caml_string_unsafe_get(s,i + 1))
        {case 120:
         case 88:base = 16;i += 2;break;
         case 111:
         case 79:base = 8;i += 2;break;
         case 98:
         case 66:base = 2;i += 2;break;
         case 117:
         case 85:i += 2;break
         }
      return [i,sign,base]}
    function caml_parse_digit(c)
     {if(c >= 48 && c <= 57)return c - 48;
      if(c >= 65 && c <= 90)return c - 55;
      if(c >= 97 && c <= 122)return c - 87;
      return - 1}
    function caml_int64_of_string(s)
     {var
       r=caml_parse_sign_and_base(s),
       i=r[0],
       sign=r[1],
       base=r[2],
       base64=caml_int64_of_int32(base),
       threshold=
        new MlInt64(0xffffff,0xfffffff,0xffff).udivmod(base64).quotient,
       c=caml_string_unsafe_get(s,i),
       d=caml_parse_digit(c);
      if(d < 0 || d >= base)caml_failwith("int_of_string");
      var res=caml_int64_of_int32(d);
      for(;;)
       {i++;
        c = caml_string_unsafe_get(s,i);
        if(c == 95)continue;
        d = caml_parse_digit(c);
        if(d < 0 || d >= base)break;
        if(caml_int64_ult(threshold,res))caml_failwith("int_of_string");
        d = caml_int64_of_int32(d);
        res = caml_int64_add(caml_int64_mul(base64,res),d);
        if(caml_int64_ult(res,d))caml_failwith("int_of_string")}
      if(i != caml_ml_string_length(s))caml_failwith("int_of_string");
      if(base == 10 && caml_int64_ult(new MlInt64(0,0,0x8000),res))
       caml_failwith("int_of_string");
      if(sign < 0)res = caml_int64_neg(res);
      return res}
    function re_search_forward(re,s,pos)
     {if(pos < 0 || pos > caml_ml_string_length(s))
       caml_invalid_argument("Str.search_forward");
      while(pos <= caml_ml_string_length(s))
       {var res=re_match(re,s,pos,0);if(res)return res;pos++}
      return [0]}
    var caml_blit_string_to_bigstring=caml_bigstring_blit_string_to_ba;
    function caml_make_vect(len,init)
     {if(len < 0)caml_array_bound_error();
      var len=len + 1 | 0,b=new Array(len);
      b[0] = 0;
      for(var i=1;i < len;i++)b[i] = init;
      return b}
    function caml_ml_seek_in(chanid,pos)
     {var chan=caml_ml_channels[chanid];
      if(chan.refill != null)caml_raise_sys_error("Illegal seek");
      chan.offset = pos;
      return 0}
    function caml_sys_read_directory(name)
     {var
       root=resolve_fs_device(name),
       a=root.device.readdir(root.rest),
       l=new Array(a.length + 1);
      l[0] = 0;
      for(var i=0;i < a.length;i++)l[i + 1] = caml_string_of_jsbytes(a[i]);
      return l}
    function caml_ml_output_char(chanid,c)
     {var s=caml_string_of_jsbytes(String.fromCharCode(c));
      caml_ml_output(chanid,s,0,1);
      return 0}
    function caml_sys_const_ostype_win32(){return 0}
    function caml_obj_is_block(x){return + (x instanceof Array)}
    function caml_ml_input_char(chanid)
     {var chan=caml_ml_channels[chanid];
      caml_ml_may_refill_input(chanid);
      if(chan.offset >= chan.file.length())caml_raise_end_of_file();
      var res=chan.file.read_one(chan.offset);
      chan.offset++;
      return res}
    function caml_obj_set_raw_field(o,i,v){return o[i + 1] = v}
    function caml_js_var(x)
     {var x=caml_jsstring_of_string(x);
      if(! x.match(/^[a-zA-Z_$][a-zA-Z_$0-9]*(\.[a-zA-Z_$][a-zA-Z_$0-9]*)*$/))
       js_print_stderr
        ('caml_js_var: "'
         +
         x
         +
         '" is not a valid JavaScript variable. continuing ..');
      return eval(x)}
    function caml_trunc_float(x){return Math.trunc(x)}
    function caml_ephe_blit_data(src,dst)
     {dst[caml_ephe_data_offset] = src[caml_ephe_data_offset];return 0}
    function caml_is_printable(c){return + (c > 31 && c < 127)}
    function caml_equal(x,y){return + (caml_compare_val(x,y,false) == 0)}
    function re_partial_match(re,s,pos)
     {if(pos < 0 || pos > caml_ml_string_length(s))
       caml_invalid_argument("Str.partial_match");
      var res=re_match(re,s,pos,1);
      return res?res:[0]}
    function caml_sys_random_seed()
     {var now=new Date().getTime(),x=now ^ 0xffffffff * Math.random();
      return [0,x]}
    function caml_final_register_called_without_value(){return 0}
    function caml_ba_get_2(ba,i0,i1){return ba.get(ba.offset([i0,i1]))}
    function win_handle_fd(x){return x}
    function caml_ba_uint8_set16(ba,i0,v)
     {var ofs=ba.offset(i0);
      if(ofs + 1 >= ba.data.length)caml_array_bound_error();
      ba.set(ofs + 0,v & 0xff);
      ba.set(ofs + 1,v >>> 8 & 0xff);
      return 0}
    function caml_js_delete(o,f){delete o[f];return 0}
    function caml_int_of_string(s)
     {var
       r=caml_parse_sign_and_base(s),
       i=r[0],
       sign=r[1],
       base=r[2],
       len=caml_ml_string_length(s),
       threshold=- 1 >>> 0,
       c=i < len?caml_string_unsafe_get(s,i):0,
       d=caml_parse_digit(c);
      if(d < 0 || d >= base)caml_failwith("int_of_string");
      var res=d;
      for(i++;i < len;i++)
       {c = caml_string_unsafe_get(s,i);
        if(c == 95)continue;
        d = caml_parse_digit(c);
        if(d < 0 || d >= base)break;
        res = base * res + d;
        if(res > threshold)caml_failwith("int_of_string")}
      if(i != len)caml_failwith("int_of_string");
      res = sign * res;
      if(base == 10 && (res | 0) != res)caml_failwith("int_of_string");
      return res | 0}
    function caml_list_mount_point()
     {var prev=0;
      for(var i=0;i < jsoo_mount_point.length;i++)
       {var old=prev;
        prev = [0,caml_string_of_jsbytes(jsoo_mount_point[i].path),old]}
      return prev}
    var
     caml_marshal_constants=
      {PREFIX_SMALL_BLOCK:0x80,
       PREFIX_SMALL_INT:0x40,
       PREFIX_SMALL_STRING:0x20,
       CODE_INT8:0x00,
       CODE_INT16:0x01,
       CODE_INT32:0x02,
       CODE_INT64:0x03,
       CODE_SHARED8:0x04,
       CODE_SHARED16:0x05,
       CODE_SHARED32:0x06,
       CODE_BLOCK32:0x08,
       CODE_BLOCK64:0x13,
       CODE_STRING8:0x09,
       CODE_STRING32:0x0A,
       CODE_DOUBLE_BIG:0x0B,
       CODE_DOUBLE_LITTLE:0x0C,
       CODE_DOUBLE_ARRAY8_BIG:0x0D,
       CODE_DOUBLE_ARRAY8_LITTLE:0x0E,
       CODE_DOUBLE_ARRAY32_BIG:0x0F,
       CODE_DOUBLE_ARRAY32_LITTLE:0x07,
       CODE_CODEPOINTER:0x10,
       CODE_INFIXPOINTER:0x11,
       CODE_CUSTOM:0x12,
       CODE_CUSTOM_LEN:0x18,
       CODE_CUSTOM_FIXED:0x19};
    function caml_obj_raw_field(o,i){return o[i + 1]}
    function caml_js_equals(x,y){return + (x == y)}
    function bigstring_to_typed_array(bs){return bs.data}
    function caml_gr_arc_aux(ctx,cx,cy,ry,rx,a1,a2)
     {while(a1 > a2)a2 += 360;
      a1 /= 180;
      a2 /= 180;
      var
       rot=0,
       xPos,
       yPos,
       xPos_prev,
       yPos_prev,
       space=2,
       num=(a2 - a1) * Math.PI * ((rx + ry) / 2) / space | 0,
       delta=(a2 - a1) * Math.PI / num,
       i=a1 * Math.PI;
      for(var j=0;j <= num;j++)
       {xPos
        =
        cx
        -
        rx
        *
        Math.sin(i)
        *
        Math.sin(rot * Math.PI)
        +
        ry
        *
        Math.cos(i)
        *
        Math.cos(rot * Math.PI);
        xPos = xPos.toFixed(2);
        yPos
        =
        cy
        +
        ry
        *
        Math.cos(i)
        *
        Math.sin(rot * Math.PI)
        +
        rx
        *
        Math.sin(i)
        *
        Math.cos(rot * Math.PI);
        yPos = yPos.toFixed(2);
        if(j == 0)
         ctx.moveTo(xPos,yPos);
        else
         if(xPos_prev != xPos || yPos_prev != yPos)ctx.lineTo(xPos,yPos);
        xPos_prev = xPos;
        yPos_prev = yPos;
        i -= delta}
      return 0}
    function caml_gr_fill_arc(x,y,rx,ry,a1,a2)
     {var s=caml_gr_state_get();
      s.context.beginPath();
      caml_gr_arc_aux(s.context,x,s.height - y,rx,ry,a1,a2);
      s.context.fill();
      return 0}
    function caml_ba_slice(ba,vind)
     {vind = caml_js_from_array(vind);
      var num_inds=vind.length,index=[],sub_dims=[],ofs;
      if(num_inds > ba.dims.length)
       caml_invalid_argument("Bigarray.slice: too many indices");
      if(ba.layout == 0)
       {for(var i=0;i < num_inds;i++)index[i] = vind[i];
        for(;i < ba.dims.length;i++)index[i] = 0;
        sub_dims = ba.dims.slice(num_inds)}
      else
       {for(var i=0;i < num_inds;i++)
         index[ba.dims.length - num_inds + i] = vind[i];
        for(var i=0;i < ba.dims.length - num_inds;i++)index[i] = 1;
        sub_dims = ba.dims.slice(0,ba.dims.length - num_inds)}
      ofs = ba.offset(index);
      var
       size=caml_ba_get_size(sub_dims),
       size_per_element=caml_ba_get_size_per_element(ba.kind),
       new_data=
        ba.data.subarray
         (ofs * size_per_element,(ofs + size) * size_per_element);
      return caml_ba_create_unsafe(ba.kind,ba.layout,sub_dims,new_data)}
    function caml_marshal_data_size(s,ofs)
     {function get32(s,i)
       {return caml_bytes_unsafe_get(s,i)
               <<
               24
               |
               caml_bytes_unsafe_get(s,i + 1)
               <<
               16
               |
               caml_bytes_unsafe_get(s,i + 2)
               <<
               8
               |
               caml_bytes_unsafe_get(s,i + 3)}
      if(get32(s,ofs) != (0x8495A6BE | 0))
       caml_failwith("Marshal.data_size: bad object");
      return get32(s,ofs + 4)}
    function caml_input_value(chanid)
     {var chan=caml_ml_channels[chanid],buf=caml_create_bytes(8);
      chan.file.read(chan.offset,buf,0,8);
      var len=caml_marshal_data_size(buf,0) + 20,buf=caml_create_bytes(len);
      chan.file.read(chan.offset,buf,0,len);
      var offset=[0],res=caml_input_value_from_bytes(buf,offset);
      chan.offset = chan.offset + offset[0];
      return res}
    function caml_ba_kind(ba){return ba.kind}
    function caml_js_fun_call(f,a)
     {switch(a.length)
       {case 1:return f();
        case 2:return f(a[1]);
        case 3:return f(a[1],a[2]);
        case 4:return f(a[1],a[2],a[3]);
        case 5:return f(a[1],a[2],a[3],a[4]);
        case 6:return f(a[1],a[2],a[3],a[4],a[5]);
        case 7:return f(a[1],a[2],a[3],a[4],a[5],a[6]);
        case 8:return f(a[1],a[2],a[3],a[4],a[5],a[6],a[7])
        }
      return f.apply(null,caml_js_from_array(a))}
    function caml_js_pure_expr(f){return f()}
    function compare_digits_nat(nat1,ofs1,nat2,ofs2)
     {if(nat1.data[ofs1] > nat2.data[ofs2])return 1;
      if(nat1.data[ofs1] < nat2.data[ofs2])return - 1;
      return 0}
    function caml_ml_input(chanid,s,i,l)
     {var chan=caml_ml_channels[chanid],l2=chan.file.length() - chan.offset;
      if(l2 == 0 && chan.refill != null)l2 = caml_ml_refill_input(chan);
      if(l2 < l)l = l2;
      chan.file.read(chan.offset,s,i,l);
      chan.offset += l;
      return l}
    function caml_gr_wait_event(_evl)
     {caml_failwith
       ("caml_gr_wait_event not Implemented: use Graphics_js instead")}
    function caml_gr_sigio_handler(){return 0}
    function caml_hash_mix_bigstring(h,bs)
     {return caml_hash_mix_bytes_arr(h,bs.data)}
    function caml_record_backtrace(){return 0}
    function unix_gmtime(t)
     {var
       d=new Date(t * 1000),
       d_num=d.getTime(),
       januaryfirst=new Date(Date.UTC(d.getUTCFullYear(),0,1)).getTime(),
       doy=Math.floor((d_num - januaryfirst) / 86400000);
      return [0,
              d.getUTCSeconds(),
              d.getUTCMinutes(),
              d.getUTCHours(),
              d.getUTCDate(),
              d.getUTCMonth(),
              d.getUTCFullYear() - 1900,
              d.getUTCDay(),
              doy,
              false | 0]}
    function caml_sys_get_config()
     {return [0,caml_string_of_jsbytes("Unix"),32,0]}
    function caml_sys_const_backend_type()
     {return [0,caml_string_of_jsbytes("js_of_ocaml")]}
    function unix_time(){return Math.floor(unix_gettimeofday())}
    function caml_ml_out_channels_list()
     {var l=0;
      for(var c=0;c < caml_ml_channels.length;c++)
       if
        (caml_ml_channels[c]
         &&
         caml_ml_channels[c].opened
         &&
         caml_ml_channels[c].out)
        l = [0,caml_ml_channels[c].fd,l];
      return l}
    function bigstring_of_array_buffer(ab)
     {var ta=new (joo_global_object.Uint8Array)(ab);
      return caml_ba_create_unsafe(12,0,[ta.length],ta)}
    function caml_mod(x,y){if(y == 0)caml_raise_zero_divide();return x % y}
    function caml_ba_init(){return 0}
    function re_string_match(re,s,pos)
     {if(pos < 0 || pos > caml_ml_string_length(s))
       caml_invalid_argument("Str.string_match");
      var res=re_match(re,s,pos,0);
      return res?res:[0]}
    function BigStringReader(bs,i){this.s = bs;this.i = i}
    BigStringReader.prototype
    =
    {read8u:function(){return caml_ba_get_1(this.s,this.i++)},
     read8s:function(){return caml_ba_get_1(this.s,this.i++) << 24 >> 24},
     read16u:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 2;
       return caml_ba_get_1(s,i) << 8 | caml_ba_get_1(s,i + 1)},
     read16s:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 2;
       return caml_ba_get_1(s,i) << 24 >> 16 | caml_ba_get_1(s,i + 1)},
     read32u:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 4;
       return (caml_ba_get_1(s,i)
               <<
               24
               |
               caml_ba_get_1(s,i + 1)
               <<
               16
               |
               caml_ba_get_1(s,i + 2)
               <<
               8
               |
               caml_ba_get_1(s,i + 3))
              >>>
              0},
     read32s:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 4;
       return caml_ba_get_1(s,i)
              <<
              24
              |
              caml_ba_get_1(s,i + 1)
              <<
              16
              |
              caml_ba_get_1(s,i + 2)
              <<
              8
              |
              caml_ba_get_1(s,i + 3)},
     readstr:
     function(len)
      {var i=this.i,arr=new Array(len);
       for(var j=0;j < len;j++)arr[j] = caml_ba_get_1(this.s,i + j);
       this.i = i + len;
       return caml_string_of_array(arr)}};
    function caml_gr_dump_image(im)
     {var data=[0];
      for(var i=0;i < im.height;i++)
       {data[i + 1] = [0];
        for(var j=0;j < im.width;j++)
         {var
           o=i * (im.width * 4) + j * 4,
           r=im.data[o + 0],
           g=im.data[o + 1],
           b=im.data[o + 2];
          data[i + 1][j + 1] = (r << 16) + (g << 8) + b}}
      return data}
    function caml_ba_get_generic(ba,i)
     {var ofs=ba.offset(caml_js_from_array(i));return ba.get(ofs)}
    function caml_get_exception_backtrace(){return 0}
    function caml_format_float(fmt,x)
     {function toFixed(x,dp)
       {if(Math.abs(x) < 1.0)
         return x.toFixed(dp);
        else
         {var e=parseInt(x.toString().split("+")[1]);
          if(e > 20)
           {e -= 20;
            x /= Math.pow(10,e);
            x += new Array(e + 1).join("0");
            if(dp > 0)x = x + "." + new Array(dp + 1).join("0");
            return x}
          else
           return x.toFixed(dp)}}
      var s,f=caml_parse_format(fmt),prec=f.prec < 0?6:f.prec;
      if(x < 0 || x == 0 && 1 / x == - Infinity){f.sign = - 1;x = - x}
      if(isNaN(x))
       {s = "nan";f.filler = " "}
      else
       if(! isFinite(x))
        {s = "inf";f.filler = " "}
       else
        switch(f.conv)
         {case "e":
           var s=x.toExponential(prec),i=s.length;
           if(s.charAt(i - 3) == "e")
            s = s.slice(0,i - 1) + "0" + s.slice(i - 1);
           break;
          case "f":s = toFixed(x,prec);break;
          case "g":
           prec = prec?prec:1;
           s = x.toExponential(prec - 1);
           var j=s.indexOf("e"),exp=+ s.slice(j + 1);
           if(exp < - 4 || x >= 1e21 || x.toFixed(0).length > prec)
            {var i=j - 1;
             while(s.charAt(i) == "0")i--;
             if(s.charAt(i) == ".")i--;
             s = s.slice(0,i + 1) + s.slice(j);
             i = s.length;
             if(s.charAt(i - 3) == "e")
              s = s.slice(0,i - 1) + "0" + s.slice(i - 1);
             break}
           else
            {var p=prec;
             if(exp < 0)
              {p -= exp + 1;s = x.toFixed(p)}
             else
              while(s = x.toFixed(p),s.length > prec + 1)p--;
             if(p)
              {var i=s.length - 1;
               while(s.charAt(i) == "0")i--;
               if(s.charAt(i) == ".")i--;
               s = s.slice(0,i + 1)}}
           break
          }
      return caml_finish_formatting(f,s)}
    function caml_mount_autoload(name,f)
     {var path=caml_make_path(name),name=path.join("/") + "/";
      jsoo_mount_point.push({path:name,device:new MlFakeDevice(name,f)});
      return 0}
    function caml_bigstring_blit_ba_to_ba(ba1,pos1,ba2,pos2,len)
     {if(12 != ba1.kind)
       caml_invalid_argument("caml_bigstring_blit_ba_to_ba: kind mismatch");
      if(12 != ba2.kind)
       caml_invalid_argument("caml_bigstring_blit_ba_to_ba: kind mismatch");
      if(len == 0)return 0;
      var ofs1=ba1.offset(pos1),ofs2=ba2.offset(pos2);
      if(ofs1 + len > ba1.data.length)caml_array_bound_error();
      if(ofs2 + len > ba2.data.length)caml_array_bound_error();
      var slice=ba1.data.subarray(ofs1,ofs1 + len);
      ba2.data.set(slice,pos2);
      return 0}
    var caml_blit_bigstring_to_bigstring=caml_bigstring_blit_ba_to_ba;
    function caml_string_lessthan(s1,s2){return caml_bytes_lessthan(s1,s2)}
    function caml_string_greaterthan(s1,s2)
     {return caml_string_lessthan(s2,s1)}
    function caml_div(x,y)
     {if(y == 0)caml_raise_zero_divide();return x / y | 0}
    function caml_ephe_get_data_copy(x)
     {return x[caml_ephe_data_offset] === undefined
              ?0
              :[0,caml_obj_dup(x[caml_ephe_data_offset])]}
    function caml_memprof_start(rate,stack_size,tracker){return 0}
    function caml_sys_get_argv(a){return [0,caml_argv[1],caml_argv]}
    function caml_js_to_bool(x){return + x}
    function caml_gr_create_image(x,y)
     {var s=caml_gr_state_get();return s.context.createImageData(x,y)}
    var caml_ephe_get_key_copy=caml_weak_get_copy;
    function caml_lessthan(x,y){return + (caml_compare_val(x,y,false) < 0)}
    function caml_raw_backtrace_next_slot(){return 0}
    function caml_register_global(n,v,name_opt)
     {if(name_opt && joo_global_object.toplevelReloc)
       n = joo_global_object.toplevelReloc(name_opt);
      caml_global_data[n + 1] = v;
      if(name_opt)caml_global_data[name_opt] = v}
    function mult_nat(nat1,ofs1,len1,nat2,ofs2,len2,nat3,ofs3,len3)
     {var carry=0;
      for(var i=0;i < len3;i++)
       carry
       +=
       mult_digit_nat(nat1,ofs1 + i,len1 - i,nat2,ofs2,len2,nat3,ofs3 + i);
      return carry}
    function square_nat(nat1,ofs1,len1,nat2,ofs2,len2)
     {var carry=0;
      carry += add_nat(nat1,ofs1,len1,nat1,ofs1,len1,0);
      carry += mult_nat(nat1,ofs1,len1,nat2,ofs2,len2,nat2,ofs2,len2);
      return carry}
    function caml_js_from_float(x){return x}
    function caml_floatarray_create(len)
     {if(len < 0)caml_array_bound_error();
      var len=len + 1 | 0,b=new Array(len);
      b[0] = 254;
      for(var i=1;i < len;i++)b[i] = 0;
      return b}
    function caml_gc_stat(){return [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]}
    function caml_sys_modify_argv(arg){caml_argv = arg;return 0}
    var caml_method_cache=[];
    function caml_get_public_method(obj,tag,cacheid)
     {var meths=obj[1],ofs=caml_method_cache[cacheid];
      if(ofs === undefined)
       for(var i=caml_method_cache.length;i < cacheid;i++)
        caml_method_cache[i] = 0;
      else
       if(meths[ofs] === tag)return meths[ofs - 1];
      var li=3,hi=meths[1] * 2 + 1,mi;
      while(li < hi)
       {mi = li + hi >> 1 | 1;if(tag < meths[mi + 1])hi = mi - 2;else li = mi}
      caml_method_cache[cacheid] = li + 1;
      return tag == meths[li + 1]?meths[li]:0}
    function caml_js_get_console()
     {var
       c=joo_global_object.console?joo_global_object.console:{},
       m=
        ["log",
         "debug",
         "info",
         "warn",
         "error",
         "assert",
         "dir",
         "dirxml",
         "trace",
         "group",
         "groupCollapsed",
         "groupEnd",
         "time",
         "timeEnd"];
      function f(){}
      for(var i=0;i < m.length;i++)if(! c[m[i]])c[m[i]] = f;
      return c}
    function caml_sys_unsafe_getenv(name){return caml_sys_getenv(name)}
    function caml_ml_open_descriptor_in(fd)
     {var data=caml_global_data.fds[fd];
      if(data.flags.wronly)caml_raise_sys_error("fd " + fd + " is writeonly");
      var
       channel=
        {file:data.file,
         offset:data.offset,
         fd:fd,
         opened:true,
         out:false,
         refill:null};
      caml_ml_channels[channel.fd] = channel;
      return channel.fd}
    function bigstring_of_typed_array(ba)
     {var
       ta=
        new
         (joo_global_object.Uint8Array)
         (ba.buffer,ba.byteOffset,ba.length * ba.BYTES_PER_ELEMENT);
      return caml_ba_create_unsafe(12,0,[ta.length],ta)}
    function caml_round_float(x){return Math.round(x)}
    function caml_ojs_new_arr(c,a)
     {switch(a.length)
       {case 0:return new c();
        case 1:return new c(a[0]);
        case 2:return new c(a[0],a[1]);
        case 3:return new c(a[0],a[1],a[2]);
        case 4:return new c(a[0],a[1],a[2],a[3]);
        case 5:return new c(a[0],a[1],a[2],a[3],a[4]);
        case 6:return new c(a[0],a[1],a[2],a[3],a[4],a[5]);
        case 7:return new c(a[0],a[1],a[2],a[3],a[4],a[5],a[6])
        }
      function F(){return c.apply(this,a)}
      F.prototype = c.prototype;
      return new F()}
    function complement_nat(nat,ofs,len)
     {for(var i=0;i < len;i++)
       nat.data[ofs + i] = (- 1 >>> 0) - (nat.data[ofs + i] >>> 0)}
    var caml_js_regexps={amp:/&/g,lt:/</g,quot:/\"/g,all:/[&<\"]/};
    function caml_js_html_escape(s)
     {if(! caml_js_regexps.all.test(s))return s;
      return s.replace(caml_js_regexps.amp,"&amp;").replace
               (caml_js_regexps.lt,"&lt;").replace
              (caml_js_regexps.quot,"&quot;")}
    function caml_ba_dim_2(ba){return caml_ba_dim(ba,1)}
    function caml_js_wrap_meth_callback_arguments(f)
     {return function()
       {var len=arguments.length,args=new Array(len);
        for(var i=0;i < len;i++)args[i] = arguments[i];
        return caml_call_gen(f,[this,args])}}
    function caml_sinh_float(x){return (Math.exp(x) - Math.exp(- x)) / 2}
    function caml_ldexp_float(x,exp)
     {exp |= 0;
      if(exp > 1023)
       {exp -= 1023;
        x *= Math.pow(2,1023);
        if(exp > 1023){exp -= 1023;x *= Math.pow(2,1023)}}
      if(exp < - 1023){exp += 1023;x *= Math.pow(2,- 1023)}
      x *= Math.pow(2,exp);
      return x}
    function caml_gr_state_set(ctx)
     {caml_gr_state = ctx;caml_gr_state_init();return 0}
    function caml_js_wrap_callback_strict(arity,f)
     {return function()
       {var n=arguments.length;
        if(n == arity && f.length == arity)return f.apply(null,arguments);
        var args=new Array(arity),len=Math.min(arguments.length,arity);
        for(var i=0;i < len;i++)args[i] = arguments[i];
        return caml_call_gen(f,args)}}
    function caml_ba_set_1(ba,i0,v){ba.set(ba.offset(i0),v);return 0}
    function caml_get_current_callstack(){return [0]}
    function land_digit_nat(nat1,ofs1,nat2,ofs2)
     {nat1.data[ofs1] &= nat2.data[ofs2];return 0}
    function caml_int64_mod(x,y){return x.mod(y)}
    function caml_obj_set_tag(x,tag){x[0] = tag;return 0}
    function caml_create_file_extern(name,content)
     {if(joo_global_object.caml_create_file)
       joo_global_object.caml_create_file(name,content);
      else
       {if(! joo_global_object.caml_fs_tmp)joo_global_object.caml_fs_tmp = [];
        joo_global_object.caml_fs_tmp.push({name:name,content:content})}
      return 0}
    function caml_int32_bswap(x)
     {return (x & 0x000000FF)
             <<
             24
             |
             (x & 0x0000FF00)
             <<
             8
             |
             (x & 0x00FF0000)
             >>>
             8
             |
             (x & 0xFF000000)
             >>>
             24}
    function win_startup(){}
    function caml_ba_set_3(ba,i0,i1,i2,v)
     {ba.set(ba.offset([i0,i1,i2]),v);return 0}
    function caml_js_instanceof(o,c){return o instanceof c}
    var caml_blit_bigstring_to_string=caml_bigstring_blit_ba_to_bytes;
    function nth_digit_nat_native(nat,ofs){return nat.data[ofs]}
    function set_digit_nat_native(nat,ofs,digit)
     {nat.data[ofs] = digit;return 0}
    function caml_string_set64(s,i,i64){return caml_bytes_set64(s,i,i64)}
    function caml_gr_state_create(canvas,w,h)
     {var context=canvas.getContext("2d");
      return {context:context,
              canvas:canvas,
              x:0,
              y:0,
              width:w,
              height:h,
              line_width:1,
              font:caml_string_of_jsbytes("fixed"),
              text_size:26,
              color:0x000000,
              title:caml_string_of_jsbytes("")}}
    function caml_js_wrap_callback(f)
     {return function()
       {var len=arguments.length;
        if(len > 0)
         {var args=new Array(len);
          for(var i=0;i < len;i++)args[i] = arguments[i];
          return caml_call_gen(f,args)}
        else
         return caml_call_gen(f,[undefined])}}
    function caml_gr_draw_arc(x,y,rx,ry,a1,a2)
     {var s=caml_gr_state_get();
      s.context.beginPath();
      caml_gr_arc_aux(s.context,x,s.height - y,rx,ry,a1,a2);
      s.context.stroke();
      return 0}
    function caml_ba_map_file(vfd,kind,layout,shared,dims,pos)
     {caml_failwith("caml_ba_map_file not implemented")}
    function caml_ba_map_file_bytecode(argv,argn)
     {return caml_ba_map_file(argv[0],argv[1],argv[2],argv[3],argv[4],argv[5])}
    function caml_ba_create_from(data1,data2,jstyp,kind,layout,dims)
     {if(data2 || caml_ba_get_size_per_element(kind) == 2)
       caml_invalid_argument
        ("caml_ba_create_from: use return caml_ba_create_unsafe");
      return caml_ba_create_unsafe(kind,layout,dims,data1)}
    function caml_tanh_float(x)
     {var y=Math.exp(x),z=Math.exp(- x);return (y - z) / (y + z)}
    function caml_gr_draw_str(str)
     {var s=caml_gr_state_get(),m=s.context.measureText(str),dx=m.width;
      s.context.fillText(str,s.x,s.height - s.y);
      s.x += dx | 0;
      return 0}
    function caml_gr_draw_string(str)
     {caml_gr_draw_str(caml_jsstring_of_string(str));return 0}
    function caml_gr_draw_char(c)
     {caml_gr_draw_str(String.fromCharCode(c));return 0}
    function caml_unmount(name)
     {var path=caml_make_path(name),name=path.join("/") + "/",idx=- 1;
      for(var i=0;i < jsoo_mount_point.length;i++)
       if(jsoo_mount_point[i].path == name)idx = i;
      if(idx > - 1)jsoo_mount_point.splice(idx,1);
      return 0}
    function caml_input_value_from_string(s,ofs)
     {var reader=new MlStringReader(s,typeof ofs == "number"?ofs:ofs[0]);
      return caml_input_value_from_reader(reader,ofs)}
    function caml_ml_pos_in_64(chanid)
     {return caml_int64_of_float(caml_ml_channels[chanid].offset)}
    function caml_gr_draw_image(im,x,y)
     {var s=caml_gr_state_get();
      if(! im.image)
       {var canvas=document.createElement("canvas");
        canvas.width = s.width;
        canvas.height = s.height;
        canvas.getContext("2d").putImageData(im,0,0);
        var image=new (joo_global_object.Image)();
        image.onload
        =
        function()
         {s.context.drawImage(image,x,s.height - im.height - y);
          im.image = image};
        image.src = canvas.toDataURL("image/png")}
      else
       s.context.drawImage(im.image,x,s.height - im.height - y);
      return 0}
    function caml_register_channel_for_spacetime(_channel){return 0}
    function caml_string_set(s,i,c)
     {if(i >>> 0 >= s.l)caml_string_bound_error();
      return caml_string_unsafe_set(s,i,c)}
    function caml_ml_pos_out(chanid)
     {caml_ml_flush(chanid);return caml_ml_channels[chanid].offset}
    function caml_spacetime_enabled(_unit){return 0}
    function caml_bytes_notequal(s1,s2){return 1 - caml_string_equal(s1,s2)}
    function caml_runtime_parameters(_unit){return caml_string_of_jsbytes("")}
    function caml_js_object(a)
     {var o={};
      for(var i=1;i < a.length;i++)
       {var p=a[i];o[caml_jsstring_of_string(p[1])] = p[2]}
      return o}
    function caml_ba_create(kind,layout,dims_ml)
     {var
       dims=caml_js_from_array(dims_ml),
       data=caml_ba_create_buffer(kind,caml_ba_get_size(dims));
      return caml_ba_create_unsafe(kind,layout,dims,data)}
    function caml_weak_blit(a1,i1,a2,i2,len)
     {caml_array_blit
       (a1,caml_ephe_key_offset + i1 - 1,a2,caml_ephe_key_offset + i2 - 1,len);
      return 0}
    function caml_gr_remember_mode()
     {caml_failwith("caml_gr_remember_mode not Implemented")}
    function caml_bswap16(x){return (x & 0x00FF) << 8 | (x & 0xFF00) >> 8}
    function caml_ml_set_binary_mode(chanid,mode)
     {var chan=caml_ml_channels[chanid],data=caml_global_data.fds[chan.fd];
      data.flags.text = ! mode;
      data.flags.binary = mode;
      return 0}
    function caml_final_register(){return 0}
    function caml_gr_draw_rect(x,y,w,h)
     {var s=caml_gr_state_get();
      s.context.strokeRect(x,s.height - y,w,- h);
      return 0}
    function caml_string_get16(s,i)
     {if(i >>> 0 >= caml_ml_string_length(s) - 1)caml_string_bound_error();
      var b1=caml_string_unsafe_get(s,i),b2=caml_string_unsafe_get(s,i + 1);
      return b2 << 8 | b1}
    function caml_ephe_unset_data(x,data)
     {x[caml_ephe_data_offset] = undefined;return 0}
    function caml_output_value(chanid,v,flags)
     {var s=caml_output_value_to_string(v,flags);
      caml_ml_output(chanid,s,0,caml_ml_string_length(s));
      return 0}
    function caml_ba_get_3(ba,i0,i1,i2){return ba.get(ba.offset([i0,i1,i2]))}
    var
     caml_ephe_blit_key=caml_weak_blit,
     caml_initial_time=new Date().getTime() * 0.001;
    function caml_sys_time()
     {var now=new Date().getTime();return now * 0.001 - caml_initial_time}
    function caml_sys_time_include_children(b){return caml_sys_time()}
    function caml_check_bound(array,index)
     {if(index >>> 0 >= array.length - 1)caml_array_bound_error();
      return array}
    function caml_hash_mix_string(h,v)
     {return caml_hash_mix_jsbytes(h,caml_jsbytes_of_string(v))}
    function caml_hash(count,limit,seed,obj)
     {var queue,rd,wr,sz,num,h,v,i,len;
      sz = limit;
      if(sz < 0 || sz > 256)sz = 256;
      num = count;
      h = seed;
      queue = [obj];
      rd = 0;
      wr = 1;
      while(rd < wr && num > 0)
       {v = queue[rd++];
        if(v && v.caml_custom)
         {if
           (caml_custom_ops[v.caml_custom]
            &&
            caml_custom_ops[v.caml_custom].hash)
           {var hh=caml_custom_ops[v.caml_custom].hash(v);
            h = caml_hash_mix_int(h,hh);
            num--}}
        else
         if(v instanceof Array && v[0] === (v[0] | 0))
          switch(v[0])
           {case 248:h = caml_hash_mix_int(h,v[2]);num--;break;
            case 250:queue[--rd] = v[1];break;
            default:
             var tag=v.length - 1 << 10 | v[0];
             h = caml_hash_mix_int(h,tag);
             for(i = 1,len = v.length;i < len;i++)
              {if(wr >= sz)break;queue[wr++] = v[i]}
             break}
         else
          if(caml_is_ml_bytes(v))
           {h = caml_hash_mix_bytes(h,v);num--}
          else
           if(caml_is_ml_string(v))
            {h = caml_hash_mix_string(h,v);num--}
           else
            if(typeof v === "string")
             {h = caml_hash_mix_jsbytes(h,v);num--}
            else
             if(v === (v | 0))
              {h = caml_hash_mix_int(h,v + v + 1);num--}
             else
              if(v === + v){h = caml_hash_mix_float(h,v);num--}}
      h = caml_hash_mix_final(h);
      return h & 0x3FFFFFFF}
    function caml_obj_tag(x)
     {if(x instanceof Array && x[0] == x[0] >>> 0)
       return x[0];
      else
       if(caml_is_ml_bytes(x))
        return 252;
       else
        if(caml_is_ml_string(x))
         return 252;
        else
         if(x instanceof Function || typeof x == "function")
          return 247;
         else
          if(x && x.caml_custom)return 255;else return 1000}
    function caml_ba_to_typed_array(ba){return ba.data}
    function caml_js_export_var()
     {return typeof module !== "undefined" && module && module.exports
              ?module.exports
              :joo_global_object}
    function caml_bytes_get32(s,i)
     {if(i >>> 0 >= s.l - 3)caml_bytes_bound_error();
      var
       b1=caml_bytes_unsafe_get(s,i),
       b2=caml_bytes_unsafe_get(s,i + 1),
       b3=caml_bytes_unsafe_get(s,i + 2),
       b4=caml_bytes_unsafe_get(s,i + 3);
      return b4 << 24 | b3 << 16 | b2 << 8 | b1}
    function caml_frexp_float(x)
     {if(x == 0 || ! isFinite(x))return [0,x,0];
      var neg=x < 0;
      if(neg)x = - x;
      var exp=Math.max(- 1023,jsoo_floor_log2(x) + 1);
      x *= Math.pow(2,- exp);
      while(x < 0.5){x *= 2;exp--}
      while(x >= 1){x *= 0.5;exp++}
      if(neg)x = - x;
      return [0,x,exp]}
    function caml_string_get64(s,i)
     {if(i >>> 0 >= caml_ml_string_length(s) - 7)caml_string_bound_error();
      var a=new Array(8);
      for(var j=0;j < 8;j++)a[7 - j] = caml_string_unsafe_get(s,i + j);
      return caml_int64_of_bytes(a)}
    function caml_ml_pos_out_64(chanid)
     {caml_ml_flush(chanid);
      return caml_int64_of_float(caml_ml_channels[chanid].offset)}
    function caml_gr_close_subwindow(a)
     {caml_failwith("caml_gr_close_subwindow not Implemented")}
    function caml_floatarray_blit(a1,i1,a2,i2,len)
     {if(i2 <= i1)
       for(var j=1;j <= len;j++)a2[i2 + j] = a1[i1 + j];
      else
       for(var j=len;j >= 1;j--)a2[i2 + j] = a1[i1 + j];
      return 0}
    function caml_set_static_env(k,v)
     {if(! joo_global_object.jsoo_static_env)
       joo_global_object.jsoo_static_env = {};
      joo_global_object.jsoo_static_env[k] = v;
      return 0}
    function caml_ba_change_layout(ba,layout)
     {if(ba.layout == layout)return ba;
      var new_dims=[];
      for(var i=0;i < ba.dims.length;i++)
       new_dims[i] = ba.dims[ba.dims.length - i - 1];
      return caml_ba_create_unsafe(ba.kind,layout,new_dims,ba.data)}
    function caml_js_new(c,a)
     {switch(a.length)
       {case 1:return new c();
        case 2:return new c(a[1]);
        case 3:return new c(a[1],a[2]);
        case 4:return new c(a[1],a[2],a[3]);
        case 5:return new c(a[1],a[2],a[3],a[4]);
        case 6:return new c(a[1],a[2],a[3],a[4],a[5]);
        case 7:return new c(a[1],a[2],a[3],a[4],a[5],a[6]);
        case 8:return new c(a[1],a[2],a[3],a[4],a[5],a[6],a[7])
        }
      function F(){return c.apply(this,caml_js_from_array(a))}
      F.prototype = c.prototype;
      return new F()}
    function caml_gr_current_y(){var s=caml_gr_state_get();return s.y}
    function caml_format_int(fmt,i)
     {if(caml_jsbytes_of_string(fmt) == "%d")
       return caml_string_of_jsbytes("" + i);
      var f=caml_parse_format(fmt);
      if(i < 0)if(f.signedconv){f.sign = - 1;i = - i}else i >>>= 0;
      var s=i.toString(f.base);
      if(f.prec >= 0)
       {f.filler = " ";
        var n=f.prec - s.length;
        if(n > 0)s = caml_str_repeat(n,"0") + s}
      return caml_finish_formatting(f,s)}
    function caml_obj_truncate(x,s)
     {if(s <= 0 || s + 1 > x.length)caml_invalid_argument("Obj.truncate");
      if(x.length != s + 1)x.length = s + 1;
      return 0}
    function caml_js_to_string(s){return caml_string_of_jsstring(s)}
    function is_digit_odd(nat,ofs){if(nat.data[ofs] & 1)return 1;return 0}
    function caml_runtime_variant(_unit){return caml_string_of_jsbytes("")}
    function caml_ml_open_descriptor_out(fd)
     {var data=caml_global_data.fds[fd];
      if(data.flags.rdonly)caml_raise_sys_error("fd " + fd + " is readonly");
      var
       channel=
        {file:data.file,
         offset:data.offset,
         fd:fd,
         opened:true,
         out:true,
         buffer:""};
      caml_ml_channels[channel.fd] = channel;
      return channel.fd}
    function caml_array_concat(l)
     {var a=[0];
      while(l !== 0)
       {var b=l[1];for(var i=1;i < b.length;i++)a.push(b[i]);l = l[2]}
      return a}
    function caml_gr_open_graph(info)
     {var g=joo_global_object,info=caml_jsstring_of_string(info);
      function get(name)
       {var res=info.match("(^|,) *" + name + " *= *([a-zA-Z0-9_]+) *(,|$)");
        if(res)return res[2]}
      var specs=[];
      if(! (info == ""))specs.push(info);
      var target=get("target");
      if(! target)target = "";
      var status=get("status");
      if(! status)specs.push("status=1");
      var w=get("width");
      w = w?parseInt(w):200;
      specs.push("width=" + w);
      var h=get("height");
      h = h?parseInt(h):200;
      specs.push("height=" + h);
      var win=g.open("about:blank",target,specs.join(","));
      if(! win)caml_failwith("Graphics.open_graph: cannot open the window");
      var doc=win.document,canvas=doc.createElement("canvas");
      canvas.width = w;
      canvas.height = h;
      var ctx=caml_gr_state_create(canvas,w,h);
      ctx.set_title = function(title){doc.title = title};
      caml_gr_state_set(ctx);
      var body=doc.body;
      body.style.margin = "0px";
      body.appendChild(canvas);
      return 0}
    function caml_ephe_set_data(x,data)
     {x[caml_ephe_data_offset] = data;return 0}
    function caml_make_float_vect(len)
     {if(len < 0)caml_array_bound_error();
      var len=len + 1 | 0,b=new Array(len);
      b[0] = 254;
      for(var i=1;i < len;i++)b[i] = 0;
      return b}
    function caml_memprof_stop(unit){return 0}
    function caml_greaterequal(x,y)
     {return + (caml_compare_val(x,y,false) >= 0)}
    function caml_get_exception_raw_backtrace(){return [0]}
    function caml_log1p_float(x)
     {var y=1 + x,z=y - 1;return z == 0?x:x * Math.log(y) / z}
    function caml_int64_or(x,y){return x.or(y)}
    function caml_lazy_make_forward(v){return [250,v]}
    function lor_digit_nat(nat1,ofs1,nat2,ofs2)
     {nat1.data[ofs1] |= nat2.data[ofs2];return 0}
    function caml_gr_blit_image(im,x,y)
     {var
       s=caml_gr_state_get(),
       im2=
        s.context.getImageData(x,s.height - im.height - y,im.width,im.height);
      for(var i=0;i < im2.data.length;i += 4)
       {im.data[i] = im2.data[i];
        im.data[i + 1] = im2.data[i + 1];
        im.data[i + 2] = im2.data[i + 2];
        im.data[i + 3] = im2.data[i + 3]}
      return 0}
    function caml_gr_window_id(a)
     {caml_failwith("caml_gr_window_id not Implemented")}
    function caml_js_on_ie()
     {var
       ua=
        joo_global_object.navigator?joo_global_object.navigator.userAgent:"";
      return ua.indexOf("MSIE") != - 1 && ua.indexOf("Opera") != 0}
    function caml_int64_shift_right(x,s){return x.shift_right(s)}
    function caml_ba_layout(ba){return ba.layout}
    function caml_convert_raw_backtrace(){return [0]}
    function caml_array_set(array,index,newval)
     {if(index < 0 || index >= array.length - 1)caml_array_bound_error();
      array[index + 1] = newval;
      return 0}
    function caml_bytes_greaterequal(s1,s2)
     {return caml_bytes_lessequal(s2,s1)}
    function set_digit_nat(nat,ofs,digit){nat.data[ofs] = digit;return 0}
    function caml_update_dummy(x,y)
     {if(typeof y === "function"){x.fun = y;return 0}
      if(y.fun){x.fun = y.fun;return 0}
      var i=y.length;
      while(i--)x[i] = y[i];
      return 0}
    function caml_CamlinternalMod_update_mod(shape,real,x)
     {if(typeof shape === "number")
       switch(shape){case 0:case 1:case 2:default:caml_update_dummy(real,x)}
      else
       switch(shape[0])
        {case 0:
          for(var i=1;i < shape[1].length;i++)
           caml_CamlinternalMod_update_mod(shape[1][i],real[i],x[i]);
          break
         }
      return 0}
    function caml_gr_doc_of_state(state)
     {if(state.canvas.ownerDocument)return state.canvas.ownerDocument}
    function caml_ml_output_int(chanid,i)
     {var
       arr=[i >> 24 & 0xFF,i >> 16 & 0xFF,i >> 8 & 0xFF,i & 0xFF],
       s=caml_string_of_array(arr);
      caml_ml_output(chanid,s,0,4);
      return 0}
    function caml_obj_with_tag(tag,x)
     {var l=x.length,a=new Array(l);
      a[0] = tag;
      for(var i=1;i < l;i++)a[i] = x[i];
      return a}
    function caml_ml_channel_size(chanid)
     {var chan=caml_ml_channels[chanid];return chan.file.length()}
    function caml_raw_backtrace_slot()
     {caml_invalid_argument
       ("Printexc.get_raw_backtrace_slot: index out of bounds")}
    function caml_hexstring_of_float(x,prec,style)
     {if(! isFinite(x))
       {if(isNaN(x))return caml_string_of_jsstring("nan");
        return caml_string_of_jsstring(x > 0?"infinity":"-infinity")}
      var sign=x == 0 && 1 / x == - Infinity?1:x >= 0?0:1;
      if(sign)x = - x;
      var exp=0;
      if(x == 0)
       ;
      else
       if(x < 1)
        while(x < 1 && exp > - 1022){x *= 2;exp--}
       else
        while(x >= 2){x /= 2;exp++}
      var exp_sign=exp < 0?"":"+",sign_str="";
      if(sign)
       sign_str = "-";
      else
       switch(style)
        {case 43:sign_str = "+";break;
         case 32:sign_str = " ";break;
         default:break}
      if(prec >= 0 && prec < 13)
       {var cst=Math.pow(2,prec * 4);x = Math.round(x * cst) / cst}
      var x_str=x.toString(16);
      if(prec >= 0)
       {var idx=x_str.indexOf(".");
        if(idx < 0)
         x_str += "." + caml_str_repeat(prec,"0");
        else
         {var size=idx + 1 + prec;
          if(x_str.length < size)
           x_str += caml_str_repeat(size - x_str.length,"0");
          else
           x_str = x_str.substr(0,size)}}
      return caml_string_of_jsstring
              (sign_str + "0x" + x_str + "p" + exp_sign + exp.toString(10))}
    function caml_js_wrap_meth_callback_strict(arity,f)
     {return function()
       {var args=new Array(arity + 1),len=Math.min(arguments.length,arity);
        args[0] = this;
        for(var i=0;i < len;i++)args[i + 1] = arguments[i];
        return caml_call_gen(f,args)}}
    function caml_backtrace_status(){return 0}
    function caml_install_signal_handler(){return 0}
    function caml_sys_argv(a){return caml_argv}
    function caml_ba_fill(ba,v){ba.fill(v);return 0}
    function caml_modf_float(x)
     {if(isFinite(x))
       {var neg=1 / x < 0;
        x = Math.abs(x);
        var i=Math.floor(x),f=x - i;
        if(neg){i = - i;f = - f}
        return [0,f,i]}
      if(isNaN(x))return [0,NaN,NaN];
      return [0,1 / x,x]}
    function caml_gc_get(){return [0,0,0,0,0,0,0,0,0]}
    function caml_float_compare(x,y)
     {if(x === y)return 0;
      if(x < y)return - 1;
      if(x > y)return 1;
      if(x === x)return 1;
      if(y === y)return - 1;
      return 0}
    function caml_string_set32(s,i,i32){return caml_bytes_set32(s,i,i32)}
    function caml_parse_engine(tables,env,cmd,arg)
     {var
       ERRCODE=256,
       loop=6,
       testshift=7,
       shift=8,
       shift_recover=9,
       reduce=10,
       READ_TOKEN=0,
       RAISE_PARSE_ERROR=1,
       GROW_STACKS_1=2,
       GROW_STACKS_2=3,
       COMPUTE_SEMANTIC_ACTION=4,
       CALL_ERROR_FUNCTION=5,
       env_s_stack=1,
       env_v_stack=2,
       env_symb_start_stack=3,
       env_symb_end_stack=4,
       env_stacksize=5,
       env_stackbase=6,
       env_curr_char=7,
       env_lval=8,
       env_symb_start=9,
       env_symb_end=10,
       env_asp=11,
       env_rule_len=12,
       env_rule_number=13,
       env_sp=14,
       env_state=15,
       env_errflag=16,
       tbl_transl_const=2,
       tbl_transl_block=3,
       tbl_lhs=4,
       tbl_len=5,
       tbl_defred=6,
       tbl_dgoto=7,
       tbl_sindex=8,
       tbl_rindex=9,
       tbl_gindex=10,
       tbl_tablesize=11,
       tbl_table=12,
       tbl_check=13;
      if(! tables.dgoto)
       {tables.defred = caml_lex_array(tables[tbl_defred]);
        tables.sindex = caml_lex_array(tables[tbl_sindex]);
        tables.check = caml_lex_array(tables[tbl_check]);
        tables.rindex = caml_lex_array(tables[tbl_rindex]);
        tables.table = caml_lex_array(tables[tbl_table]);
        tables.len = caml_lex_array(tables[tbl_len]);
        tables.lhs = caml_lex_array(tables[tbl_lhs]);
        tables.gindex = caml_lex_array(tables[tbl_gindex]);
        tables.dgoto = caml_lex_array(tables[tbl_dgoto])}
      var
       res=0,
       n,
       n1,
       n2,
       state1,
       sp=env[env_sp],
       state=env[env_state],
       errflag=env[env_errflag];
      exit:
      for(;;)
       switch(cmd)
        {case 0:state = 0;errflag = 0;
         case 6:
          n = tables.defred[state];
          if(n != 0){cmd = reduce;break}
          if(env[env_curr_char] >= 0){cmd = testshift;break}
          res = READ_TOKEN;
          break exit;
         case 1:
          if(arg instanceof Array)
           {env[env_curr_char] = tables[tbl_transl_block][arg[0] + 1];
            env[env_lval] = arg[1]}
          else
           {env[env_curr_char] = tables[tbl_transl_const][arg + 1];
            env[env_lval] = 0}
         case 7:
          n1 = tables.sindex[state];
          n2 = n1 + env[env_curr_char];
          if
           (n1
            !=
            0
            &&
            n2
            >=
            0
            &&
            n2
            <=
            tables[tbl_tablesize]
            &&
            tables.check[n2]
            ==
            env[env_curr_char])
           {cmd = shift;break}
          n1 = tables.rindex[state];
          n2 = n1 + env[env_curr_char];
          if
           (n1
            !=
            0
            &&
            n2
            >=
            0
            &&
            n2
            <=
            tables[tbl_tablesize]
            &&
            tables.check[n2]
            ==
            env[env_curr_char])
           {n = tables.table[n2];cmd = reduce;break}
          if(errflag <= 0){res = CALL_ERROR_FUNCTION;break exit}
         case 5:
          if(errflag < 3)
           {errflag = 3;
            for(;;)
             {state1 = env[env_s_stack][sp + 1];
              n1 = tables.sindex[state1];
              n2 = n1 + ERRCODE;
              if
               (n1
                !=
                0
                &&
                n2
                >=
                0
                &&
                n2
                <=
                tables[tbl_tablesize]
                &&
                tables.check[n2]
                ==
                ERRCODE)
               {cmd = shift_recover;break}
              else
               {if(sp <= env[env_stackbase])return RAISE_PARSE_ERROR;sp--}}}
          else
           {if(env[env_curr_char] == 0)return RAISE_PARSE_ERROR;
            env[env_curr_char] = - 1;
            cmd = loop;
            break}
         case 8:env[env_curr_char] = - 1;if(errflag > 0)errflag--;
         case 9:
          state = tables.table[n2];
          sp++;
          if(sp >= env[env_stacksize]){res = GROW_STACKS_1;break exit}
         case 2:
          env[env_s_stack][sp + 1] = state;
          env[env_v_stack][sp + 1] = env[env_lval];
          env[env_symb_start_stack][sp + 1] = env[env_symb_start];
          env[env_symb_end_stack][sp + 1] = env[env_symb_end];
          cmd = loop;
          break;
         case 10:
          var m=tables.len[n];
          env[env_asp] = sp;
          env[env_rule_number] = n;
          env[env_rule_len] = m;
          sp = sp - m + 1;
          m = tables.lhs[n];
          state1 = env[env_s_stack][sp];
          n1 = tables.gindex[m];
          n2 = n1 + state1;
          if
           (n1
            !=
            0
            &&
            n2
            >=
            0
            &&
            n2
            <=
            tables[tbl_tablesize]
            &&
            tables.check[n2]
            ==
            state1)
           state = tables.table[n2];
          else
           state = tables.dgoto[m];
          if(sp >= env[env_stacksize]){res = GROW_STACKS_2;break exit}
         case 3:res = COMPUTE_SEMANTIC_ACTION;break exit;
         case 4:
          env[env_s_stack][sp + 1] = state;
          env[env_v_stack][sp + 1] = arg;
          var asp=env[env_asp];
          env[env_symb_end_stack][sp + 1] = env[env_symb_end_stack][asp + 1];
          if(sp > asp)
           env[env_symb_start_stack][sp + 1]
           =
           env[env_symb_end_stack][asp + 1];
          cmd = loop;
          break;
         default:return RAISE_PARSE_ERROR}
      env[env_sp] = sp;
      env[env_state] = state;
      env[env_errflag] = errflag;
      return res}
    function caml_array_fill(array,ofs,len,v)
     {for(var i=0;i < len;i++)array[ofs + i + 1] = v;return 0}
    function caml_string_notequal(s1,s2){return 1 - caml_string_equal(s1,s2)}
    function caml_bytes_greaterthan(s1,s2){return caml_bytes_lessthan(s2,s1)}
    function caml_gr_make_image(arr)
     {var
       s=caml_gr_state_get(),
       h=arr.length - 1,
       w=arr[1].length - 1,
       im=s.context.createImageData(w,h);
      for(var i=0;i < h;i++)
       for(var j=0;j < w;j++)
        {var c=arr[i + 1][j + 1],o=i * (w * 4) + j * 4;
         if(c == - 1)
          {im.data[o + 0] = 0;
           im.data[o + 1] = 0;
           im.data[o + 2] = 0;
           im.data[o + 3] = 0}
         else
          {im.data[o + 0] = c >> 16 & 0xff;
           im.data[o + 1] = c >> 8 & 0xff;
           im.data[o + 2] = c >> 0 & 0Xff;
           im.data[o + 3] = 0xff}}
      return im}
    function caml_ml_set_channel_output(chanid,f)
     {var chan=caml_ml_channels[chanid];
      caml_global_data.fds[chan.fd].output = f;
      return 0}
    function caml_read_file_content(name)
     {var
       name=typeof name == "string"?caml_string_of_jsbytes(name):name,
       root=resolve_fs_device(name);
      if(root.device.exists(root.rest))
       {var
         file=root.device.open(root.rest,{rdonly:1}),
         len=file.length(),
         buf=caml_create_bytes(len);
        file.read(0,buf,0,len);
        return caml_string_of_bytes(buf)}
      caml_raise_no_such_file(name)}
    function caml_js_to_float(x){return x}
    joo_global_object.jsoo_runtime
    =
    {caml_ephe_check_data:caml_ephe_check_data,
     caml_ephe_unset_data:caml_ephe_unset_data,
     caml_ephe_set_data:caml_ephe_set_data,
     caml_ephe_get_data_copy:caml_ephe_get_data_copy,
     caml_ephe_get_data:caml_ephe_get_data,
     caml_ephe_blit_data:caml_ephe_blit_data,
     caml_ephe_unset_key:caml_ephe_unset_key,
     caml_ephe_set_key:caml_ephe_set_key,
     caml_ephe_check_key:caml_ephe_check_key,
     caml_ephe_get_key_copy:caml_ephe_get_key_copy,
     caml_ephe_get_key:caml_ephe_get_key,
     caml_ephe_blit_key:caml_ephe_blit_key,
     caml_ephe_create:caml_ephe_create,
     caml_weak_blit:caml_weak_blit,
     caml_weak_check:caml_weak_check,
     caml_weak_get_copy:caml_weak_get_copy,
     caml_weak_get:caml_weak_get,
     caml_weak_set:caml_weak_set,
     caml_weak_create:caml_weak_create,
     caml_ephe_data_offset:caml_ephe_data_offset,
     caml_ephe_key_offset:caml_ephe_key_offset,
     unix_isatty:unix_isatty,
     win_handle_fd:win_handle_fd,
     win_cleanup:win_cleanup,
     win_startup:win_startup,
     unix_mktime:unix_mktime,
     unix_localtime:unix_localtime,
     unix_gmtime:unix_gmtime,
     unix_time:unix_time,
     unix_gettimeofday:unix_gettimeofday,
     re_replacement_text:re_replacement_text,
     re_partial_match:re_partial_match,
     re_string_match:re_string_match,
     re_search_backward:re_search_backward,
     re_search_forward:re_search_forward,
     re_match:re_match,
     caml_spacetime_only_works_for_native_code:
     caml_spacetime_only_works_for_native_code,
     caml_register_channel_for_spacetime:caml_register_channel_for_spacetime,
     caml_sys_const_naked_pointers_checked:
     caml_sys_const_naked_pointers_checked,
     caml_spacetime_enabled:caml_spacetime_enabled,
     caml_ml_runtime_warnings_enabled:caml_ml_runtime_warnings_enabled,
     caml_ml_enable_runtime_warnings:caml_ml_enable_runtime_warnings,
     caml_runtime_warnings:caml_runtime_warnings,
     unix_inet_addr_of_string:unix_inet_addr_of_string,
     caml_install_signal_handler:caml_install_signal_handler,
     caml_runtime_parameters:caml_runtime_parameters,
     caml_runtime_variant:caml_runtime_variant,
     caml_sys_isatty:caml_sys_isatty,
     caml_sys_get_config:caml_sys_get_config,
     caml_sys_const_backend_type:caml_sys_const_backend_type,
     caml_sys_const_ostype_cygwin:caml_sys_const_ostype_cygwin,
     caml_sys_const_ostype_win32:caml_sys_const_ostype_win32,
     caml_sys_const_ostype_unix:caml_sys_const_ostype_unix,
     caml_sys_const_max_wosize:caml_sys_const_max_wosize,
     caml_sys_const_int_size:caml_sys_const_int_size,
     caml_sys_const_word_size:caml_sys_const_word_size,
     caml_sys_const_big_endian:caml_sys_const_big_endian,
     caml_sys_random_seed:caml_sys_random_seed,
     caml_sys_time_include_children:caml_sys_time_include_children,
     caml_sys_time:caml_sys_time,
     caml_sys_system_command:caml_sys_system_command,
     caml_sys_executable_name:caml_sys_executable_name,
     caml_sys_modify_argv:caml_sys_modify_argv,
     caml_sys_argv:caml_sys_argv,
     caml_sys_get_argv:caml_sys_get_argv,
     caml_executable_name:caml_executable_name,
     caml_argv:caml_argv,
     caml_sys_unsafe_getenv:caml_sys_unsafe_getenv,
     caml_sys_getenv:caml_sys_getenv,
     caml_set_static_env:caml_set_static_env,
     caml_sys_exit:caml_sys_exit,
     caml_raise_sys_error:caml_raise_sys_error,
     caml_is_printable:caml_is_printable,
     caml_get_global_data:caml_get_global_data,
     caml_register_global:caml_register_global,
     caml_global_data:caml_global_data,
     caml_named_value:caml_named_value,
     caml_register_named_value:caml_register_named_value,
     caml_named_values:caml_named_values,
     caml_call_gen:caml_call_gen,
     caml_set_parser_trace:caml_set_parser_trace,
     caml_parse_engine:caml_parse_engine,
     caml_obj_set_raw_field:caml_obj_set_raw_field,
     caml_obj_raw_field:caml_obj_raw_field,
     caml_fresh_oo_id:caml_fresh_oo_id,
     caml_set_oo_id:caml_set_oo_id,
     caml_oo_last_id:caml_oo_last_id,
     caml_get_public_method:caml_get_public_method,
     caml_lazy_make_forward:caml_lazy_make_forward,
     caml_obj_make_forward:caml_obj_make_forward,
     caml_obj_truncate:caml_obj_truncate,
     caml_obj_dup:caml_obj_dup,
     caml_obj_with_tag:caml_obj_with_tag,
     caml_obj_block:caml_obj_block,
     caml_obj_set_tag:caml_obj_set_tag,
     caml_obj_tag:caml_obj_tag,
     caml_obj_is_block:caml_obj_is_block,
     caml_update_dummy:caml_update_dummy,
     deserialize_nat:deserialize_nat,
     serialize_nat:serialize_nat,
     lxor_digit_nat:lxor_digit_nat,
     lor_digit_nat:lor_digit_nat,
     land_digit_nat:land_digit_nat,
     compare_nat_real:compare_nat_real,
     compare_nat:compare_nat,
     compare_digits_nat:compare_digits_nat,
     shift_right_nat:shift_right_nat,
     div_nat:div_nat,
     div_digit_nat:div_digit_nat,
     div_helper:div_helper,
     shift_left_nat:shift_left_nat,
     square_nat:square_nat,
     mult_nat:mult_nat,
     mult_digit_nat:mult_digit_nat,
     sub_nat:sub_nat,
     decr_nat:decr_nat,
     complement_nat:complement_nat,
     add_nat:add_nat,
     incr_nat:incr_nat,
     is_digit_odd:is_digit_odd,
     is_digit_zero:is_digit_zero,
     is_digit_int:is_digit_int,
     num_leading_zero_bits_in_digit:num_leading_zero_bits_in_digit,
     num_digits_nat:num_digits_nat,
     nth_digit_nat_native:nth_digit_nat_native,
     set_digit_nat_native:set_digit_nat_native,
     nth_digit_nat:nth_digit_nat,
     set_digit_nat:set_digit_nat,
     blit_nat:blit_nat,
     set_to_zero_nat:set_to_zero_nat,
     create_nat:create_nat,
     nat_of_array:nat_of_array,
     caml_hash_nat:caml_hash_nat,
     MlNat:MlNat,
     initialize_nat:initialize_nat,
     caml_js_to_string:caml_js_to_string,
     caml_to_js_string:caml_to_js_string,
     caml_js_from_string:caml_js_from_string,
     caml_new_string:caml_new_string,
     caml_js_to_byte_string:caml_js_to_byte_string,
     caml_is_ml_string:caml_is_ml_string,
     caml_is_ml_bytes:caml_is_ml_bytes,
     caml_string_of_jsstring:caml_string_of_jsstring,
     caml_jsstring_of_string:caml_jsstring_of_string,
     caml_jsbytes_of_string:caml_jsbytes_of_string,
     caml_string_of_jsbytes:caml_string_of_jsbytes,
     caml_bytes_of_string:caml_bytes_of_string,
     caml_string_of_bytes:caml_string_of_bytes,
     caml_string_lessthan:caml_string_lessthan,
     caml_string_lessequal:caml_string_lessequal,
     caml_string_equal:caml_string_equal,
     caml_string_compare:caml_string_compare,
     caml_ml_string_length:caml_ml_string_length,
     caml_string_unsafe_set:caml_string_unsafe_set,
     caml_string_unsafe_get:caml_string_unsafe_get,
     caml_bytes_of_jsbytes:caml_bytes_of_jsbytes,
     caml_ml_bytes_length:caml_ml_bytes_length,
     caml_blit_string:caml_blit_string,
     caml_blit_bytes:caml_blit_bytes,
     caml_fill_string:caml_fill_string,
     caml_fill_bytes:caml_fill_bytes,
     caml_bytes_greaterthan:caml_bytes_greaterthan,
     caml_string_greaterthan:caml_string_greaterthan,
     caml_bytes_greaterequal:caml_bytes_greaterequal,
     caml_string_greaterequal:caml_string_greaterequal,
     caml_bytes_lessthan:caml_bytes_lessthan,
     caml_bytes_lessequal:caml_bytes_lessequal,
     caml_bytes_notequal:caml_bytes_notequal,
     caml_string_notequal:caml_string_notequal,
     caml_bytes_equal:caml_bytes_equal,
     caml_bytes_compare:caml_bytes_compare,
     caml_bytes_of_array:caml_bytes_of_array,
     caml_string_of_array:caml_string_of_array,
     caml_create_bytes:caml_create_bytes,
     caml_create_string:caml_create_string,
     caml_array_of_string:caml_array_of_string,
     caml_array_of_bytes:caml_array_of_bytes,
     caml_convert_bytes_to_array:caml_convert_bytes_to_array,
     caml_convert_string_to_bytes:caml_convert_string_to_bytes,
     MlBytes:MlBytes,
     caml_bytes_of_utf16_jsstring:caml_bytes_of_utf16_jsstring,
     caml_bytes_set:caml_bytes_set,
     caml_string_set64:caml_string_set64,
     caml_bytes_set64:caml_bytes_set64,
     caml_string_set32:caml_string_set32,
     caml_bytes_set32:caml_bytes_set32,
     caml_string_set16:caml_string_set16,
     caml_bytes_set16:caml_bytes_set16,
     caml_string_set:caml_string_set,
     caml_bytes_get:caml_bytes_get,
     caml_bytes_get64:caml_bytes_get64,
     caml_string_get64:caml_string_get64,
     caml_bytes_get32:caml_bytes_get32,
     caml_string_get32:caml_string_get32,
     caml_bytes_get16:caml_bytes_get16,
     caml_string_get16:caml_string_get16,
     caml_string_get:caml_string_get,
     caml_bytes_bound_error:caml_bytes_bound_error,
     caml_string_bound_error:caml_string_bound_error,
     caml_bytes_unsafe_set:caml_bytes_unsafe_set,
     caml_bytes_unsafe_get:caml_bytes_unsafe_get,
     jsoo_is_ascii:jsoo_is_ascii,
     caml_utf16_of_utf8:caml_utf16_of_utf8,
     caml_utf8_of_utf16:caml_utf8_of_utf16,
     caml_subarray_to_jsbytes:caml_subarray_to_jsbytes,
     caml_str_repeat:caml_str_repeat,
     caml_md5_bytes:caml_md5_bytes,
     caml_md5_string:caml_md5_string,
     caml_md5_chan:caml_md5_chan,
     caml_output_value_to_buffer:caml_output_value_to_buffer,
     caml_output_value_to_bytes:caml_output_value_to_bytes,
     caml_output_value_to_string:caml_output_value_to_string,
     caml_output_val:caml_output_val,
     caml_legacy_custom_code:caml_legacy_custom_code,
     MlObjectTable:MlObjectTable,
     caml_marshal_data_size:caml_marshal_data_size,
     caml_input_value_from_reader:caml_input_value_from_reader,
     caml_custom_ops:caml_custom_ops,
     caml_nativeint_unmarshal:caml_nativeint_unmarshal,
     caml_int32_unmarshal:caml_int32_unmarshal,
     caml_int64_marshal:caml_int64_marshal,
     caml_int64_unmarshal:caml_int64_unmarshal,
     caml_input_value_from_bytes:caml_input_value_from_bytes,
     caml_input_value_from_string:caml_input_value_from_string,
     caml_float_of_bytes:caml_float_of_bytes,
     BigStringReader:BigStringReader,
     MlStringReader:MlStringReader,
     caml_marshal_constants:caml_marshal_constants,
     caml_new_lex_engine:caml_new_lex_engine,
     caml_lex_engine:caml_lex_engine,
     caml_lex_array:caml_lex_array,
     caml_xmlhttprequest_create:caml_xmlhttprequest_create,
     caml_js_export_var:caml_js_export_var,
     caml_js_object:caml_js_object,
     caml_pure_js_expr:caml_pure_js_expr,
     caml_js_expr:caml_js_expr,
     caml_js_eval_string:caml_js_eval_string,
     caml_js_equals:caml_js_equals,
     caml_js_wrap_meth_callback_unsafe:caml_js_wrap_meth_callback_unsafe,
     caml_js_wrap_meth_callback_strict:caml_js_wrap_meth_callback_strict,
     caml_js_wrap_meth_callback_arguments:caml_js_wrap_meth_callback_arguments,
     caml_js_wrap_meth_callback:caml_js_wrap_meth_callback,
     caml_js_wrap_callback_strict:caml_js_wrap_callback_strict,
     caml_js_wrap_callback_arguments:caml_js_wrap_callback_arguments,
     caml_js_wrap_callback:caml_js_wrap_callback,
     caml_ojs_new_arr:caml_ojs_new_arr,
     caml_js_new:caml_js_new,
     caml_js_meth_call:caml_js_meth_call,
     caml_js_fun_call:caml_js_fun_call,
     caml_js_call:caml_js_call,
     caml_js_var:caml_js_var,
     caml_list_to_js_array:caml_list_to_js_array,
     caml_list_of_js_array:caml_list_of_js_array,
     caml_js_to_array:caml_js_to_array,
     caml_js_from_array:caml_js_from_array,
     caml_js_to_float:caml_js_to_float,
     caml_js_from_float:caml_js_from_float,
     caml_js_to_bool:caml_js_to_bool,
     caml_js_from_bool:caml_js_from_bool,
     caml_js_error_of_exception:caml_js_error_of_exception,
     caml_exn_with_js_backtrace:caml_exn_with_js_backtrace,
     caml_wrap_exception:caml_wrap_exception,
     caml_is_js:caml_is_js,
     js_print_stderr:js_print_stderr,
     js_print_stdout:js_print_stdout,
     caml_trampoline_return:caml_trampoline_return,
     caml_trampoline:caml_trampoline,
     caml_js_get_console:caml_js_get_console,
     caml_js_html_entities:caml_js_html_entities,
     caml_js_html_escape:caml_js_html_escape,
     caml_js_on_ie:caml_js_on_ie,
     caml_js_typeof:caml_js_typeof,
     caml_js_instanceof:caml_js_instanceof,
     caml_js_delete:caml_js_delete,
     caml_js_get:caml_js_get,
     caml_js_set:caml_js_set,
     caml_js_pure_expr:caml_js_pure_expr,
     caml_ml_output_int:caml_ml_output_int,
     caml_ml_pos_out_64:caml_ml_pos_out_64,
     caml_ml_pos_out:caml_ml_pos_out,
     caml_ml_seek_out_64:caml_ml_seek_out_64,
     caml_ml_seek_out:caml_ml_seek_out,
     caml_output_value:caml_output_value,
     caml_ml_output_char:caml_ml_output_char,
     caml_ml_output:caml_ml_output,
     caml_ml_output_bytes:caml_ml_output_bytes,
     caml_ml_flush:caml_ml_flush,
     caml_ml_input_scan_line:caml_ml_input_scan_line,
     caml_ml_pos_in_64:caml_ml_pos_in_64,
     caml_ml_pos_in:caml_ml_pos_in,
     caml_ml_seek_in_64:caml_ml_seek_in_64,
     caml_ml_seek_in:caml_ml_seek_in,
     caml_ml_input_int:caml_ml_input_int,
     caml_ml_input_char:caml_ml_input_char,
     caml_input_value:caml_input_value,
     caml_ml_input:caml_ml_input,
     caml_ml_may_refill_input:caml_ml_may_refill_input,
     caml_ml_refill_input:caml_ml_refill_input,
     caml_ml_set_channel_refill:caml_ml_set_channel_refill,
     caml_ml_set_channel_output:caml_ml_set_channel_output,
     caml_ml_channel_size_64:caml_ml_channel_size_64,
     caml_ml_channel_size:caml_ml_channel_size,
     caml_ml_close_channel:caml_ml_close_channel,
     caml_ml_set_binary_mode:caml_ml_set_binary_mode,
     caml_channel_descriptor:caml_channel_descriptor,
     caml_ml_open_descriptor_in:caml_ml_open_descriptor_in,
     caml_ml_open_descriptor_out:caml_ml_open_descriptor_out,
     caml_ml_out_channels_list:caml_ml_out_channels_list,
     caml_ml_channels:caml_ml_channels,
     caml_ml_set_channel_name:caml_ml_set_channel_name,
     caml_sys_open:caml_sys_open,
     caml_std_output:caml_std_output,
     caml_sys_close:caml_sys_close,
     caml_int64_bswap:caml_int64_bswap,
     caml_int32_bswap:caml_int32_bswap,
     caml_bswap16:caml_bswap16,
     caml_mod:caml_mod,
     caml_div:caml_div,
     caml_mul:caml_mul,
     caml_int_of_string:caml_int_of_string,
     caml_parse_digit:caml_parse_digit,
     caml_parse_sign_and_base:caml_parse_sign_and_base,
     caml_format_int:caml_format_int,
     caml_CamlinternalMod_update_mod:caml_CamlinternalMod_update_mod,
     caml_CamlinternalMod_init_mod:caml_CamlinternalMod_init_mod,
     caml_int64_hash:caml_int64_hash,
     caml_int64_to_bytes:caml_int64_to_bytes,
     caml_int64_of_bytes:caml_int64_of_bytes,
     caml_int64_hi32:caml_int64_hi32,
     caml_int64_lo32:caml_int64_lo32,
     caml_int64_create_lo_hi:caml_int64_create_lo_hi,
     caml_int64_create_lo_mi_hi:caml_int64_create_lo_mi_hi,
     caml_int64_of_string:caml_int64_of_string,
     caml_int64_format:caml_int64_format,
     caml_int64_of_float:caml_int64_of_float,
     caml_int64_to_float:caml_int64_to_float,
     caml_int64_to_int32:caml_int64_to_int32,
     caml_int64_of_int32:caml_int64_of_int32,
     caml_int64_mod:caml_int64_mod,
     caml_int64_div:caml_int64_div,
     caml_int64_shift_right:caml_int64_shift_right,
     caml_int64_shift_right_unsigned:caml_int64_shift_right_unsigned,
     caml_int64_shift_left:caml_int64_shift_left,
     caml_int64_xor:caml_int64_xor,
     caml_int64_or:caml_int64_or,
     caml_int64_and:caml_int64_and,
     caml_int64_is_negative:caml_int64_is_negative,
     caml_int64_is_zero:caml_int64_is_zero,
     caml_int64_mul:caml_int64_mul,
     caml_int64_sub:caml_int64_sub,
     caml_int64_add:caml_int64_add,
     caml_int64_neg:caml_int64_neg,
     caml_int64_compare:caml_int64_compare,
     caml_int64_ult:caml_int64_ult,
     MlInt64:MlInt64,
     caml_int64_offset:caml_int64_offset,
     caml_float_of_string:caml_float_of_string,
     caml_format_float:caml_format_float,
     caml_round_float:caml_round_float,
     caml_tanh_float:caml_tanh_float,
     caml_sinh_float:caml_sinh_float,
     caml_cosh_float:caml_cosh_float,
     caml_log10_float:caml_log10_float,
     caml_hypot_float:caml_hypot_float,
     caml_log1p_float:caml_log1p_float,
     caml_expm1_float:caml_expm1_float,
     caml_signbit_float:caml_signbit_float,
     caml_copysign_float:caml_copysign_float,
     caml_float_compare:caml_float_compare,
     caml_frexp_float:caml_frexp_float,
     caml_ldexp_float:caml_ldexp_float,
     caml_modf_float:caml_modf_float,
     caml_classify_float:caml_classify_float,
     caml_int32_float_of_bits:caml_int32_float_of_bits,
     caml_trunc_float:caml_trunc_float,
     caml_nextafter_float:caml_nextafter_float,
     caml_int64_float_of_bits:caml_int64_float_of_bits,
     caml_hexstring_of_float:caml_hexstring_of_float,
     caml_int32_bits_of_float:caml_int32_bits_of_float,
     caml_int64_bits_of_float:caml_int64_bits_of_float,
     jsoo_floor_log2:jsoo_floor_log2,
     caml_hash:caml_hash,
     caml_hash_mix_string:caml_hash_mix_string,
     caml_hash_mix_bytes:caml_hash_mix_bytes,
     caml_hash_mix_bytes_arr:caml_hash_mix_bytes_arr,
     caml_hash_mix_jsbytes:caml_hash_mix_jsbytes,
     caml_hash_mix_int64:caml_hash_mix_int64,
     caml_hash_mix_float:caml_hash_mix_float,
     caml_hash_mix_final:caml_hash_mix_final,
     caml_hash_mix_int:caml_hash_mix_int,
     caml_hash_univ_param:caml_hash_univ_param,
     caml_gr_close_subwindow:caml_gr_close_subwindow,
     caml_gr_open_subwindow:caml_gr_open_subwindow,
     caml_gr_window_id:caml_gr_window_id,
     caml_gr_display_mode:caml_gr_display_mode,
     caml_gr_remember_mode:caml_gr_remember_mode,
     caml_gr_synchronize:caml_gr_synchronize,
     caml_gr_wait_event:caml_gr_wait_event,
     caml_gr_sigio_signal:caml_gr_sigio_signal,
     caml_gr_sigio_handler:caml_gr_sigio_handler,
     caml_gr_blit_image:caml_gr_blit_image,
     caml_gr_create_image:caml_gr_create_image,
     caml_gr_draw_image:caml_gr_draw_image,
     caml_gr_dump_image:caml_gr_dump_image,
     caml_gr_make_image:caml_gr_make_image,
     caml_gr_text_size:caml_gr_text_size,
     caml_gr_set_text_size:caml_gr_set_text_size,
     caml_gr_set_font:caml_gr_set_font,
     caml_gr_draw_string:caml_gr_draw_string,
     caml_gr_draw_char:caml_gr_draw_char,
     caml_gr_draw_str:caml_gr_draw_str,
     caml_gr_fill_arc:caml_gr_fill_arc,
     caml_gr_fill_poly:caml_gr_fill_poly,
     caml_gr_fill_rect:caml_gr_fill_rect,
     caml_gr_set_line_width:caml_gr_set_line_width,
     caml_gr_draw_arc:caml_gr_draw_arc,
     caml_gr_arc_aux:caml_gr_arc_aux,
     caml_gr_draw_rect:caml_gr_draw_rect,
     caml_gr_lineto:caml_gr_lineto,
     caml_gr_current_y:caml_gr_current_y,
     caml_gr_current_x:caml_gr_current_x,
     caml_gr_moveto:caml_gr_moveto,
     caml_gr_point_color:caml_gr_point_color,
     caml_gr_plot:caml_gr_plot,
     caml_gr_set_color:caml_gr_set_color,
     caml_gr_size_y:caml_gr_size_y,
     caml_gr_size_x:caml_gr_size_x,
     caml_gr_clear_graph:caml_gr_clear_graph,
     caml_gr_resize_window:caml_gr_resize_window,
     caml_gr_set_window_title:caml_gr_set_window_title,
     caml_gr_close_graph:caml_gr_close_graph,
     caml_gr_doc_of_state:caml_gr_doc_of_state,
     caml_gr_state_create:caml_gr_state_create,
     caml_gr_state_init:caml_gr_state_init,
     caml_gr_open_graph:caml_gr_open_graph,
     caml_gr_state_set:caml_gr_state_set,
     caml_gr_state_get:caml_gr_state_get,
     caml_gr_state:caml_gr_state,
     caml_memprof_stop:caml_memprof_stop,
     caml_memprof_start:caml_memprof_start,
     caml_final_release:caml_final_release,
     caml_final_register_called_without_value:
     caml_final_register_called_without_value,
     caml_final_register:caml_final_register,
     caml_memprof_set:caml_memprof_set,
     caml_gc_get:caml_gc_get,
     caml_gc_set:caml_gc_set,
     caml_gc_stat:caml_gc_stat,
     caml_gc_quick_stat:caml_gc_quick_stat,
     caml_gc_counters:caml_gc_counters,
     caml_gc_compaction:caml_gc_compaction,
     caml_gc_full_major:caml_gc_full_major,
     caml_gc_major:caml_gc_major,
     caml_gc_minor:caml_gc_minor,
     MlNodeFile:MlNodeFile,
     MlNodeDevice:MlNodeDevice,
     fs_node_supported:fs_node_supported,
     MlFakeFile:MlFakeFile,
     MlFakeDevice:MlFakeDevice,
     caml_read_file_content:caml_read_file_content,
     caml_create_file:caml_create_file,
     caml_fs_init:caml_fs_init,
     caml_create_file_extern:caml_create_file_extern,
     caml_ba_map_file_bytecode:caml_ba_map_file_bytecode,
     caml_ba_map_file:caml_ba_map_file,
     caml_sys_rename:caml_sys_rename,
     caml_sys_is_directory:caml_sys_is_directory,
     caml_sys_remove:caml_sys_remove,
     caml_sys_read_directory:caml_sys_read_directory,
     caml_sys_file_exists:caml_sys_file_exists,
     caml_raise_not_a_dir:caml_raise_not_a_dir,
     caml_raise_no_such_file:caml_raise_no_such_file,
     caml_sys_chdir:caml_sys_chdir,
     caml_sys_getcwd:caml_sys_getcwd,
     caml_unmount:caml_unmount,
     caml_mount_autoload:caml_mount_autoload,
     resolve_fs_device:resolve_fs_device,
     caml_list_mount_point:caml_list_mount_point,
     jsoo_mount_point:jsoo_mount_point,
     caml_make_path:caml_make_path,
     MlFile:MlFile,
     caml_root:caml_root,
     caml_current_dir:caml_current_dir,
     caml_finish_formatting:caml_finish_formatting,
     caml_parse_format:caml_parse_format,
     caml_array_bound_error:caml_array_bound_error,
     caml_raise_not_found:caml_raise_not_found,
     caml_raise_zero_divide:caml_raise_zero_divide,
     caml_raise_end_of_file:caml_raise_end_of_file,
     caml_invalid_argument:caml_invalid_argument,
     caml_failwith:caml_failwith,
     caml_raise_with_string:caml_raise_with_string,
     caml_raise_with_arg:caml_raise_with_arg,
     caml_return_exn_constant:caml_return_exn_constant,
     caml_raise_constant:caml_raise_constant,
     caml_lessthan:caml_lessthan,
     caml_lessequal:caml_lessequal,
     caml_greaterthan:caml_greaterthan,
     caml_greaterequal:caml_greaterequal,
     caml_notequal:caml_notequal,
     caml_equal:caml_equal,
     caml_int_compare:caml_int_compare,
     caml_compare:caml_compare,
     caml_compare_val:caml_compare_val,
     caml_compare_val_number_custom:caml_compare_val_number_custom,
     caml_compare_val_get_custom:caml_compare_val_get_custom,
     caml_compare_val_tag:caml_compare_val_tag,
     caml_blit_string_to_bigstring:caml_blit_string_to_bigstring,
     caml_blit_bigstring_to_string:caml_blit_bigstring_to_string,
     caml_blit_bigstring_to_bigstring:caml_blit_bigstring_to_bigstring,
     caml_bigstring_blit_ba_to_bytes:caml_bigstring_blit_ba_to_bytes,
     caml_bigstring_blit_bytes_to_ba:caml_bigstring_blit_bytes_to_ba,
     caml_bigstring_blit_string_to_ba:caml_bigstring_blit_string_to_ba,
     caml_bigstring_blit_ba_to_ba:caml_bigstring_blit_ba_to_ba,
     caml_bigstring_memcmp:caml_bigstring_memcmp,
     bigstring_of_typed_array:bigstring_of_typed_array,
     bigstring_of_array_buffer:bigstring_of_array_buffer,
     bigstring_to_typed_array:bigstring_to_typed_array,
     bigstring_to_array_buffer:bigstring_to_array_buffer,
     caml_hash_mix_bigstring:caml_hash_mix_bigstring,
     caml_ba_from_typed_array:caml_ba_from_typed_array,
     caml_ba_kind_of_typed_array:caml_ba_kind_of_typed_array,
     caml_ba_to_typed_array:caml_ba_to_typed_array,
     caml_ba_hash:caml_ba_hash,
     caml_ba_create_from:caml_ba_create_from,
     caml_ba_deserialize:caml_ba_deserialize,
     caml_ba_serialize:caml_ba_serialize,
     caml_ba_reshape:caml_ba_reshape,
     caml_ba_slice:caml_ba_slice,
     caml_ba_sub:caml_ba_sub,
     caml_ba_blit:caml_ba_blit,
     caml_ba_fill:caml_ba_fill,
     caml_ba_set_3:caml_ba_set_3,
     caml_ba_set_2:caml_ba_set_2,
     caml_ba_set_1:caml_ba_set_1,
     caml_ba_uint8_set64:caml_ba_uint8_set64,
     caml_ba_uint8_set32:caml_ba_uint8_set32,
     caml_ba_uint8_set16:caml_ba_uint8_set16,
     caml_ba_set_generic:caml_ba_set_generic,
     caml_ba_get_3:caml_ba_get_3,
     caml_ba_get_2:caml_ba_get_2,
     caml_ba_get_1:caml_ba_get_1,
     caml_ba_uint8_get64:caml_ba_uint8_get64,
     caml_ba_uint8_get32:caml_ba_uint8_get32,
     caml_ba_uint8_get16:caml_ba_uint8_get16,
     caml_ba_get_generic:caml_ba_get_generic,
     caml_ba_dim_3:caml_ba_dim_3,
     caml_ba_dim_2:caml_ba_dim_2,
     caml_ba_dim_1:caml_ba_dim_1,
     caml_ba_dim:caml_ba_dim,
     caml_ba_num_dims:caml_ba_num_dims,
     caml_ba_layout:caml_ba_layout,
     caml_ba_kind:caml_ba_kind,
     caml_ba_change_layout:caml_ba_change_layout,
     caml_ba_create:caml_ba_create,
     caml_ba_create_unsafe:caml_ba_create_unsafe,
     caml_ba_compare:caml_ba_compare,
     Ml_Bigarray_c_1_1:Ml_Bigarray_c_1_1,
     Ml_Bigarray:Ml_Bigarray,
     caml_ba_custom_name:caml_ba_custom_name,
     caml_ba_create_buffer:caml_ba_create_buffer,
     caml_ba_get_size_per_element:caml_ba_get_size_per_element,
     caml_ba_get_size:caml_ba_get_size,
     caml_ba_init:caml_ba_init,
     caml_convert_raw_backtrace_slot:caml_convert_raw_backtrace_slot,
     caml_get_current_callstack:caml_get_current_callstack,
     caml_restore_raw_backtrace:caml_restore_raw_backtrace,
     caml_raw_backtrace_slot:caml_raw_backtrace_slot,
     caml_raw_backtrace_next_slot:caml_raw_backtrace_next_slot,
     caml_raw_backtrace_length:caml_raw_backtrace_length,
     caml_convert_raw_backtrace:caml_convert_raw_backtrace,
     caml_record_backtrace:caml_record_backtrace,
     caml_get_exception_raw_backtrace:caml_get_exception_raw_backtrace,
     caml_get_exception_backtrace:caml_get_exception_backtrace,
     caml_backtrace_status:caml_backtrace_status,
     caml_ml_debug_info_status:caml_ml_debug_info_status,
     caml_floatarray_create:caml_floatarray_create,
     caml_make_float_vect:caml_make_float_vect,
     caml_make_vect:caml_make_vect,
     caml_check_bound:caml_check_bound,
     caml_array_fill:caml_array_fill,
     caml_array_get:caml_array_get,
     caml_array_set:caml_array_set,
     caml_floatarray_blit:caml_floatarray_blit,
     caml_array_blit:caml_array_blit,
     caml_array_concat:caml_array_concat,
     caml_array_append:caml_array_append,
     caml_array_sub:caml_array_sub};
    caml_fs_init();
    caml_register_global
     (0,[248,caml_string_of_jsbytes("Out_of_memory"),0],"Out_of_memory");
    caml_register_global
     (1,[248,caml_string_of_jsbytes("Sys_error"),-1],"Sys_error");
    caml_register_global
     (2,[248,caml_string_of_jsbytes("Failure"),-2],"Failure");
    caml_register_global
     (3,
      [248,caml_string_of_jsbytes("Invalid_argument"),-3],
      "Invalid_argument");
    caml_register_global
     (4,[248,caml_string_of_jsbytes("End_of_file"),-4],"End_of_file");
    caml_register_global
     (5,
      [248,caml_string_of_jsbytes("Division_by_zero"),-5],
      "Division_by_zero");
    caml_register_global
     (6,[248,caml_string_of_jsbytes("Not_found"),-6],"Not_found");
    caml_register_global
     (7,[248,caml_string_of_jsbytes("Match_failure"),-7],"Match_failure");
    caml_register_global
     (8,[248,caml_string_of_jsbytes("Stack_overflow"),-8],"Stack_overflow");
    caml_register_global
     (9,[248,caml_string_of_jsbytes("Sys_blocked_io"),-9],"Sys_blocked_io");
    caml_register_global
     (10,[248,caml_string_of_jsbytes("Assert_failure"),-10],"Assert_failure");
    caml_register_global
     (11,
      [248,caml_string_of_jsbytes("Undefined_recursive_module"),-11],
      "Undefined_recursive_module");
    return}
  (function(){return this}()));


//# 1 ".js/stdlib/stdlib.cma.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_array_concat=runtime.caml_array_concat,
     caml_array_get=runtime.caml_array_get,
     caml_array_set=runtime.caml_array_set,
     caml_array_sub=runtime.caml_array_sub,
     caml_ba_change_layout=runtime.caml_ba_change_layout,
     caml_ba_create=runtime.caml_ba_create,
     caml_ba_dim_1=runtime.caml_ba_dim_1,
     caml_ba_dim_2=runtime.caml_ba_dim_2,
     caml_ba_kind=runtime.caml_ba_kind,
     caml_ba_num_dims=runtime.caml_ba_num_dims,
     caml_ba_reshape=runtime.caml_ba_reshape,
     caml_ba_set_1=runtime.caml_ba_set_1,
     caml_ba_set_2=runtime.caml_ba_set_2,
     caml_ba_set_3=runtime.caml_ba_set_3,
     caml_ba_set_generic=runtime.caml_ba_set_generic,
     caml_ba_slice=runtime.caml_ba_slice,
     caml_blit_bytes=runtime.caml_blit_bytes,
     caml_blit_string=runtime.caml_blit_string,
     caml_bswap16=runtime.caml_bswap16,
     caml_bytes_get=runtime.caml_bytes_get,
     caml_bytes_get16=runtime.caml_bytes_get16,
     caml_bytes_get32=runtime.caml_bytes_get32,
     caml_bytes_get64=runtime.caml_bytes_get64,
     caml_bytes_of_string=runtime.caml_bytes_of_string,
     caml_bytes_set=runtime.caml_bytes_set,
     caml_bytes_set16=runtime.caml_bytes_set16,
     caml_bytes_set32=runtime.caml_bytes_set32,
     caml_bytes_set64=runtime.caml_bytes_set64,
     caml_bytes_unsafe_get=runtime.caml_bytes_unsafe_get,
     caml_bytes_unsafe_set=runtime.caml_bytes_unsafe_set,
     caml_check_bound=runtime.caml_check_bound,
     caml_compare=runtime.caml_compare,
     caml_create_bytes=runtime.caml_create_bytes,
     caml_div=runtime.caml_div,
     caml_ephe_set_key=runtime.caml_ephe_set_key,
     caml_ephe_unset_key=runtime.caml_ephe_unset_key,
     caml_equal=runtime.caml_equal,
     caml_fill_bytes=runtime.caml_fill_bytes,
     caml_float_compare=runtime.caml_float_compare,
     caml_float_of_string=runtime.caml_float_of_string,
     caml_floatarray_blit=runtime.caml_floatarray_blit,
     caml_floatarray_create=runtime.caml_floatarray_create,
     caml_format_float=runtime.caml_format_float,
     caml_format_int=runtime.caml_format_int,
     caml_fresh_oo_id=runtime.caml_fresh_oo_id,
     caml_get_exception_raw_backtra=runtime.caml_get_exception_raw_backtrace,
     caml_get_public_method=runtime.caml_get_public_method,
     caml_greaterequal=runtime.caml_greaterequal,
     caml_greaterthan=runtime.caml_greaterthan,
     caml_hash=runtime.caml_hash,
     caml_input_value=runtime.caml_input_value,
     caml_int32_bswap=runtime.caml_int32_bswap,
     caml_int64_add=runtime.caml_int64_add,
     caml_int64_bswap=runtime.caml_int64_bswap,
     caml_int64_compare=runtime.caml_int64_compare,
     caml_int64_float_of_bits=runtime.caml_int64_float_of_bits,
     caml_int64_format=runtime.caml_int64_format,
     caml_int64_mul=runtime.caml_int64_mul,
     caml_int64_of_int32=runtime.caml_int64_of_int32,
     caml_int64_of_string=runtime.caml_int64_of_string,
     caml_int64_or=runtime.caml_int64_or,
     caml_int64_shift_left=runtime.caml_int64_shift_left,
     caml_int64_sub=runtime.caml_int64_sub,
     caml_int_compare=runtime.caml_int_compare,
     caml_int_of_string=runtime.caml_int_of_string,
     caml_lessequal=runtime.caml_lessequal,
     caml_lessthan=runtime.caml_lessthan,
     caml_make_vect=runtime.caml_make_vect,
     caml_marshal_data_size=runtime.caml_marshal_data_size,
     caml_md5_string=runtime.caml_md5_string,
     caml_ml_bytes_length=runtime.caml_ml_bytes_length,
     caml_ml_channel_size=runtime.caml_ml_channel_size,
     caml_ml_channel_size_64=runtime.caml_ml_channel_size_64,
     caml_ml_close_channel=runtime.caml_ml_close_channel,
     caml_ml_flush=runtime.caml_ml_flush,
     caml_ml_input=runtime.caml_ml_input,
     caml_ml_input_char=runtime.caml_ml_input_char,
     caml_ml_open_descriptor_in=runtime.caml_ml_open_descriptor_in,
     caml_ml_open_descriptor_out=runtime.caml_ml_open_descriptor_out,
     caml_ml_output=runtime.caml_ml_output,
     caml_ml_output_bytes=runtime.caml_ml_output_bytes,
     caml_ml_output_char=runtime.caml_ml_output_char,
     caml_ml_set_binary_mode=runtime.caml_ml_set_binary_mode,
     caml_ml_set_channel_name=runtime.caml_ml_set_channel_name,
     caml_ml_string_length=runtime.caml_ml_string_length,
     caml_mod=runtime.caml_mod,
     caml_mul=runtime.caml_mul,
     caml_nextafter_float=runtime.caml_nextafter_float,
     caml_notequal=runtime.caml_notequal,
     caml_obj_block=runtime.caml_obj_block,
     caml_obj_make_forward=runtime.caml_obj_make_forward,
     caml_obj_tag=runtime.caml_obj_tag,
     caml_output_value=runtime.caml_output_value,
     caml_register_global=runtime.caml_register_global,
     caml_register_named_value=runtime.caml_register_named_value,
     caml_restore_raw_backtrace=runtime.caml_restore_raw_backtrace,
     caml_set_oo_id=runtime.caml_set_oo_id,
     caml_signbit_float=runtime.caml_signbit_float,
     caml_string_compare=runtime.caml_string_compare,
     caml_string_equal=runtime.caml_string_equal,
     caml_string_get=runtime.caml_string_get,
     caml_string_notequal=runtime.caml_string_notequal,
     caml_string_of_bytes=runtime.caml_string_of_bytes,
     caml_string_of_jsbytes=runtime.caml_string_of_jsbytes,
     caml_string_unsafe_get=runtime.caml_string_unsafe_get,
     caml_sys_argv=runtime.caml_sys_argv,
     caml_sys_getenv=runtime.caml_sys_getenv,
     caml_sys_open=runtime.caml_sys_open,
     caml_sys_random_seed=runtime.caml_sys_random_seed,
     caml_trampoline=runtime.caml_trampoline,
     caml_trampoline_return=runtime.caml_trampoline_return,
     caml_wrap_exception=runtime.caml_wrap_exception;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5
              ?f(a0,a1,a2,a3,a4)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4])}
    function caml_call7(f,a0,a1,a2,a3,a4,a5,a6)
     {return f.length == 7
              ?f(a0,a1,a2,a3,a4,a5,a6)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5,a6])}
    var
     global_data=runtime.caml_get_global_data(),
     cst$0=caml_string_of_jsbytes("%,"),
     cst_really_input=caml_string_of_jsbytes("really_input"),
     cst_input=caml_string_of_jsbytes("input"),
     cst_output_substring=caml_string_of_jsbytes("output_substring"),
     cst_output=caml_string_of_jsbytes("output"),
     cst_12g=caml_string_of_jsbytes("%.12g"),
     cst=caml_string_of_jsbytes("."),
     cst_false$1=caml_string_of_jsbytes("false"),
     cst_true$1=caml_string_of_jsbytes("true"),
     cst_false$0=caml_string_of_jsbytes("false"),
     cst_true$0=caml_string_of_jsbytes("true"),
     cst_bool_of_string=caml_string_of_jsbytes("bool_of_string"),
     cst_true=caml_string_of_jsbytes("true"),
     cst_false=caml_string_of_jsbytes("false"),
     cst_char_of_int=caml_string_of_jsbytes("char_of_int"),
     cst_Stdlib_Exit=caml_string_of_jsbytes("Stdlib.Exit"),
     cst_Stdlib_Pervasives_Exit=
      caml_string_of_jsbytes("Stdlib.Pervasives.Exit"),
     cst_option_is_None=caml_string_of_jsbytes("option is None"),
     cst_result_is_Ok=caml_string_of_jsbytes("result is Ok _"),
     cst_result_is_Error=caml_string_of_jsbytes("result is Error _"),
     cst_true$2=caml_string_of_jsbytes("true"),
     cst_false$2=caml_string_of_jsbytes("false"),
     cst$1=caml_string_of_jsbytes("\\\\"),
     cst$2=caml_string_of_jsbytes("\\'"),
     cst_b=caml_string_of_jsbytes("\\b"),
     cst_t=caml_string_of_jsbytes("\\t"),
     cst_n=caml_string_of_jsbytes("\\n"),
     cst_r=caml_string_of_jsbytes("\\r"),
     cst_Char_chr=caml_string_of_jsbytes("Char.chr"),
     cst_is_not_a_latin1_character=
      caml_string_of_jsbytes(" is not a latin1 character"),
     cst_04X=caml_string_of_jsbytes("%04X"),
     cst_U=caml_string_of_jsbytes("U+"),
     cst_is_not_an_Unicode_scalar_v=
      caml_string_of_jsbytes(" is not an Unicode scalar value"),
     cst_X=caml_string_of_jsbytes("%X"),
     err_no_pred=caml_string_of_jsbytes("U+0000 has no predecessor"),
     err_no_succ=caml_string_of_jsbytes("U+10FFFF has no successor"),
     cst_Stdlib_Sys_Break=caml_string_of_jsbytes("Stdlib.Sys.Break"),
     ocaml_version=caml_string_of_jsbytes("4.12.0"),
     cst_List_map2=caml_string_of_jsbytes("List.map2"),
     cst_List_iter2=caml_string_of_jsbytes("List.iter2"),
     cst_List_fold_left2=caml_string_of_jsbytes("List.fold_left2"),
     cst_List_fold_right2=caml_string_of_jsbytes("List.fold_right2"),
     cst_List_for_all2=caml_string_of_jsbytes("List.for_all2"),
     cst_List_exists2=caml_string_of_jsbytes("List.exists2"),
     cst_List_combine=caml_string_of_jsbytes("List.combine"),
     cst_List_rev_map2=caml_string_of_jsbytes("List.rev_map2"),
     cst_List_init=caml_string_of_jsbytes("List.init"),
     cst_List_nth$0=caml_string_of_jsbytes("List.nth"),
     cst_nth=caml_string_of_jsbytes("nth"),
     cst_List_nth=caml_string_of_jsbytes("List.nth"),
     cst_tl=caml_string_of_jsbytes("tl"),
     cst_hd=caml_string_of_jsbytes("hd"),
     cst_Bytes_of_seq_cannot_grow_b=
      caml_string_of_jsbytes("Bytes.of_seq: cannot grow bytes"),
     cst_String_rcontains_from_Byte=
      caml_string_of_jsbytes("String.rcontains_from / Bytes.rcontains_from"),
     cst_String_contains_from_Bytes=
      caml_string_of_jsbytes("String.contains_from / Bytes.contains_from"),
     cst_String_rindex_from_opt_Byt=
      caml_string_of_jsbytes("String.rindex_from_opt / Bytes.rindex_from_opt"),
     cst_String_rindex_from_Bytes_r=
      caml_string_of_jsbytes("String.rindex_from / Bytes.rindex_from"),
     cst_String_index_from_opt_Byte=
      caml_string_of_jsbytes("String.index_from_opt / Bytes.index_from_opt"),
     cst_String_index_from_Bytes_in=
      caml_string_of_jsbytes("String.index_from / Bytes.index_from"),
     cst_Bytes_concat=caml_string_of_jsbytes("Bytes.concat"),
     cst_String_blit_Bytes_blit_str=
      caml_string_of_jsbytes("String.blit / Bytes.blit_string"),
     cst_Bytes_blit=caml_string_of_jsbytes("Bytes.blit"),
     cst_String_fill_Bytes_fill=
      caml_string_of_jsbytes("String.fill / Bytes.fill"),
     cst_Bytes_extend=caml_string_of_jsbytes("Bytes.extend"),
     cst_String_sub_Bytes_sub=caml_string_of_jsbytes("String.sub / Bytes.sub"),
     cst_String_rcontains_from_Byte$0=
      caml_string_of_jsbytes("String.rcontains_from / Bytes.rcontains_from"),
     cst_String_contains_from_Bytes$0=
      caml_string_of_jsbytes("String.contains_from / Bytes.contains_from"),
     cst_String_rindex_from_opt_Byt$0=
      caml_string_of_jsbytes("String.rindex_from_opt / Bytes.rindex_from_opt"),
     cst_String_rindex_from_Bytes_r$0=
      caml_string_of_jsbytes("String.rindex_from / Bytes.rindex_from"),
     cst_String_index_from_opt_Byte$0=
      caml_string_of_jsbytes("String.index_from_opt / Bytes.index_from_opt"),
     cst_String_index_from_Bytes_in$0=
      caml_string_of_jsbytes("String.index_from / Bytes.index_from"),
     cst$4=caml_string_of_jsbytes(""),
     cst$3=caml_string_of_jsbytes(""),
     cst_String_concat=caml_string_of_jsbytes("String.concat"),
     cst$5=caml_string_of_jsbytes("()"),
     cst_Marshal_from_bytes=caml_string_of_jsbytes("Marshal.from_bytes"),
     cst_Marshal_from_bytes$0=caml_string_of_jsbytes("Marshal.from_bytes"),
     cst_Marshal_data_size=caml_string_of_jsbytes("Marshal.data_size"),
     cst_Marshal_to_buffer_substrin=
      caml_string_of_jsbytes("Marshal.to_buffer: substring out of bounds"),
     cst_Obj_Ephemeron_blit_key=
      caml_string_of_jsbytes("Obj.Ephemeron.blit_key"),
     cst_Obj_Ephemeron_check_key=
      caml_string_of_jsbytes("Obj.Ephemeron.check_key"),
     cst_Obj_Ephemeron_unset_key=
      caml_string_of_jsbytes("Obj.Ephemeron.unset_key"),
     cst_Obj_Ephemeron_set_key=caml_string_of_jsbytes("Obj.Ephemeron.set_key"),
     cst_Obj_Ephemeron_get_key_copy=
      caml_string_of_jsbytes("Obj.Ephemeron.get_key_copy"),
     cst_Obj_Ephemeron_get_key=caml_string_of_jsbytes("Obj.Ephemeron.get_key"),
     cst_Obj_Ephemeron_create=caml_string_of_jsbytes("Obj.Ephemeron.create"),
     cst_Obj_extension_constructor$0=
      caml_string_of_jsbytes("Obj.extension_constructor"),
     cst_Obj_extension_constructor=
      caml_string_of_jsbytes("Obj.extension_constructor"),
     cst_Array_exists2=caml_string_of_jsbytes("Array.exists2"),
     cst_Array_for_all2=caml_string_of_jsbytes("Array.for_all2"),
     cst_Array_map2_arrays_must_hav=
      caml_string_of_jsbytes("Array.map2: arrays must have the same length"),
     cst_Array_iter2_arrays_must_ha=
      caml_string_of_jsbytes("Array.iter2: arrays must have the same length"),
     cst_Array_blit=caml_string_of_jsbytes("Array.blit"),
     cst_Array_fill=caml_string_of_jsbytes("Array.fill"),
     cst_Array_sub=caml_string_of_jsbytes("Array.sub"),
     cst_Array_init=caml_string_of_jsbytes("Array.init"),
     cst_Stdlib_Array_Bottom=caml_string_of_jsbytes("Stdlib.Array.Bottom"),
     cst_Float_Array_map2_arrays_mu=
      caml_string_of_jsbytes
       ("Float.Array.map2: arrays must have the same length"),
     cst_Float_Array_iter2_arrays_m=
      caml_string_of_jsbytes
       ("Float.Array.iter2: arrays must have the same length"),
     cst_Float_array_blit=caml_string_of_jsbytes("Float.array.blit"),
     cst_Float_array_blit$0=caml_string_of_jsbytes("Float.array.blit"),
     cst_Float_Array_fill=caml_string_of_jsbytes("Float.Array.fill"),
     cst_Float_Array_sub=caml_string_of_jsbytes("Float.Array.sub"),
     cst_Float_Array_concat=caml_string_of_jsbytes("Float.Array.concat"),
     cst_Float_Array_init=caml_string_of_jsbytes("Float.Array.init"),
     cst_Stdlib_Float_Array_Bottom=
      caml_string_of_jsbytes("Stdlib.Float.Array.Bottom"),
     cst_d=caml_string_of_jsbytes("%d"),
     cst_d$0=caml_string_of_jsbytes("%d"),
     zero$2=runtime.caml_int64_create_lo_mi_hi(0,0,0),
     one$2=runtime.caml_int64_create_lo_mi_hi(1,0,0),
     minus_one$2=runtime.caml_int64_create_lo_mi_hi(16777215,16777215,65535),
     min_int$2=runtime.caml_int64_create_lo_mi_hi(0,0,32768),
     max_int$2=runtime.caml_int64_create_lo_mi_hi(16777215,16777215,32767),
     cst_d$1=caml_string_of_jsbytes("%d"),
     cst_Lexing_lex_refill_cannot_g=
      caml_string_of_jsbytes("Lexing.lex_refill: cannot grow buffer"),
     dummy_pos=[0,caml_string_of_jsbytes(""),0,0,-1],
     zero_pos=[0,caml_string_of_jsbytes(""),1,0,0],
     cst_syntax_error=caml_string_of_jsbytes("syntax error"),
     cst_Stdlib_Parsing_YYexit=caml_string_of_jsbytes("Stdlib.Parsing.YYexit"),
     cst_Stdlib_Parsing_Parse_error=
      caml_string_of_jsbytes("Stdlib.Parsing.Parse_error"),
     cst_Set_remove_min_elt=caml_string_of_jsbytes("Set.remove_min_elt"),
     cst_Set_bal=caml_string_of_jsbytes("Set.bal"),
     cst_Set_bal$0=caml_string_of_jsbytes("Set.bal"),
     cst_Set_bal$1=caml_string_of_jsbytes("Set.bal"),
     cst_Set_bal$2=caml_string_of_jsbytes("Set.bal"),
     cst_Map_remove_min_elt=caml_string_of_jsbytes("Map.remove_min_elt"),
     cst_Map_bal=caml_string_of_jsbytes("Map.bal"),
     cst_Map_bal$0=caml_string_of_jsbytes("Map.bal"),
     cst_Map_bal$1=caml_string_of_jsbytes("Map.bal"),
     cst_Map_bal$2=caml_string_of_jsbytes("Map.bal"),
     cst_Stdlib_Stack_Empty=caml_string_of_jsbytes("Stdlib.Stack.Empty"),
     cst_Stdlib_Queue_Empty=caml_string_of_jsbytes("Stdlib.Queue.Empty"),
     cst_CamlinternalLazy_Undefined=
      caml_string_of_jsbytes("CamlinternalLazy.Undefined"),
     cst_count=caml_string_of_jsbytes("{count = "),
     cst_data=caml_string_of_jsbytes("; data = "),
     cst$6=caml_string_of_jsbytes("}"),
     cst_Sempty=caml_string_of_jsbytes("Sempty"),
     cst_Scons=caml_string_of_jsbytes("Scons ("),
     cst$7=caml_string_of_jsbytes(", "),
     cst$8=caml_string_of_jsbytes(")"),
     cst_Sapp=caml_string_of_jsbytes("Sapp ("),
     cst$9=caml_string_of_jsbytes(", "),
     cst$10=caml_string_of_jsbytes(")"),
     cst_Slazy=caml_string_of_jsbytes("Slazy"),
     cst_Sgen=caml_string_of_jsbytes("Sgen"),
     cst_Sbuffio=caml_string_of_jsbytes("Sbuffio"),
     cst_Stdlib_Stream_Failure=caml_string_of_jsbytes("Stdlib.Stream.Failure"),
     cst_Stdlib_Stream_Error=caml_string_of_jsbytes("Stdlib.Stream.Error"),
     cst_Buffer_truncate=caml_string_of_jsbytes("Buffer.truncate"),
     cst_Buffer_add_channel=caml_string_of_jsbytes("Buffer.add_channel"),
     cst_Buffer_add_substring_add_s=
      caml_string_of_jsbytes("Buffer.add_substring/add_subbytes"),
     cst_Buffer_add_cannot_grow_buf=
      caml_string_of_jsbytes("Buffer.add: cannot grow buffer"),
     cst_Buffer_nth=caml_string_of_jsbytes("Buffer.nth"),
     cst_Buffer_blit=caml_string_of_jsbytes("Buffer.blit"),
     cst_Buffer_sub=caml_string_of_jsbytes("Buffer.sub"),
     cst_c=caml_string_of_jsbytes("%c"),
     cst_s=caml_string_of_jsbytes("%s"),
     cst_i=caml_string_of_jsbytes("%i"),
     cst_li=caml_string_of_jsbytes("%li"),
     cst_ni=caml_string_of_jsbytes("%ni"),
     cst_Li=caml_string_of_jsbytes("%Li"),
     cst_f=caml_string_of_jsbytes("%f"),
     cst_B=caml_string_of_jsbytes("%B"),
     cst$21=caml_string_of_jsbytes("%{"),
     cst$22=caml_string_of_jsbytes("%}"),
     cst$23=caml_string_of_jsbytes("%("),
     cst$24=caml_string_of_jsbytes("%)"),
     cst_a=caml_string_of_jsbytes("%a"),
     cst_t$0=caml_string_of_jsbytes("%t"),
     cst$25=caml_string_of_jsbytes("%?"),
     cst_r$0=caml_string_of_jsbytes("%r"),
     cst_r$1=caml_string_of_jsbytes("%_r"),
     cst_u$0=caml_string_of_jsbytes("%u"),
     cst_Printf_bad_conversion=
      caml_string_of_jsbytes("Printf: bad conversion %["),
     cst_Printf_bad_conversion$0=
      caml_string_of_jsbytes("Printf: bad conversion %_"),
     cst$30=caml_string_of_jsbytes("@{"),
     cst$31=caml_string_of_jsbytes("@["),
     cst$32=caml_string_of_jsbytes("@{"),
     cst$33=caml_string_of_jsbytes("@["),
     cst$34=caml_string_of_jsbytes("@{"),
     cst$35=caml_string_of_jsbytes("@["),
     cst_0=caml_string_of_jsbytes("0"),
     cst_padding=caml_string_of_jsbytes("padding"),
     cst_precision=caml_string_of_jsbytes("precision"),
     cst$40=caml_string_of_jsbytes("'*'"),
     cst$38=caml_string_of_jsbytes("'-'"),
     cst_0$2=caml_string_of_jsbytes("'0'"),
     cst$39=caml_string_of_jsbytes("'*'"),
     cst_0$0=caml_string_of_jsbytes("0"),
     cst_0$1=caml_string_of_jsbytes("0"),
     cst_precision$0=caml_string_of_jsbytes("precision"),
     cst_precision$1=caml_string_of_jsbytes("precision"),
     cst$41=caml_string_of_jsbytes("'+'"),
     cst$42=caml_string_of_jsbytes("'#'"),
     cst$43=caml_string_of_jsbytes("' '"),
     cst_padding$0=caml_string_of_jsbytes("`padding'"),
     cst_precision$2=caml_string_of_jsbytes("`precision'"),
     cst$44=caml_string_of_jsbytes("'+'"),
     cst$45=caml_string_of_jsbytes("'_'"),
     sub_format=[0,0,caml_string_of_jsbytes("")],
     formatting_lit=[0,caml_string_of_jsbytes("@;"),1,0],
     cst_digit=caml_string_of_jsbytes("digit"),
     cst_character=caml_string_of_jsbytes("character ')'"),
     cst_character$0=caml_string_of_jsbytes("character '}'"),
     cst$49=caml_string_of_jsbytes("'#'"),
     cst$46=caml_string_of_jsbytes("'+'"),
     cst$47=caml_string_of_jsbytes("'+'"),
     cst$48=caml_string_of_jsbytes("' '"),
     cst$50=caml_string_of_jsbytes("'+'"),
     cst_non_zero_widths_are_unsupp=
      caml_string_of_jsbytes
       ("non-zero widths are unsupported for %c conversions"),
     cst_unexpected_end_of_format=
      caml_string_of_jsbytes("unexpected end of format"),
     cst$36=caml_string_of_jsbytes(""),
     cst$37=caml_string_of_jsbytes(""),
     cst_b$0=caml_string_of_jsbytes("b"),
     cst_h=caml_string_of_jsbytes("h"),
     cst_hov=caml_string_of_jsbytes("hov"),
     cst_hv=caml_string_of_jsbytes("hv"),
     cst_v=caml_string_of_jsbytes("v"),
     cst_nan=caml_string_of_jsbytes("nan"),
     cst_neg_infinity=caml_string_of_jsbytes("neg_infinity"),
     cst_infinity=caml_string_of_jsbytes("infinity"),
     cst$29=caml_string_of_jsbytes("."),
     cst_nd$0=caml_string_of_jsbytes("%+nd"),
     cst_nd$1=caml_string_of_jsbytes("% nd"),
     cst_ni$1=caml_string_of_jsbytes("%+ni"),
     cst_ni$2=caml_string_of_jsbytes("% ni"),
     cst_nx=caml_string_of_jsbytes("%nx"),
     cst_nx$0=caml_string_of_jsbytes("%#nx"),
     cst_nX=caml_string_of_jsbytes("%nX"),
     cst_nX$0=caml_string_of_jsbytes("%#nX"),
     cst_no=caml_string_of_jsbytes("%no"),
     cst_no$0=caml_string_of_jsbytes("%#no"),
     cst_nd=caml_string_of_jsbytes("%nd"),
     cst_ni$0=caml_string_of_jsbytes("%ni"),
     cst_nu=caml_string_of_jsbytes("%nu"),
     cst_ld$0=caml_string_of_jsbytes("%+ld"),
     cst_ld$1=caml_string_of_jsbytes("% ld"),
     cst_li$1=caml_string_of_jsbytes("%+li"),
     cst_li$2=caml_string_of_jsbytes("% li"),
     cst_lx=caml_string_of_jsbytes("%lx"),
     cst_lx$0=caml_string_of_jsbytes("%#lx"),
     cst_lX=caml_string_of_jsbytes("%lX"),
     cst_lX$0=caml_string_of_jsbytes("%#lX"),
     cst_lo=caml_string_of_jsbytes("%lo"),
     cst_lo$0=caml_string_of_jsbytes("%#lo"),
     cst_ld=caml_string_of_jsbytes("%ld"),
     cst_li$0=caml_string_of_jsbytes("%li"),
     cst_lu=caml_string_of_jsbytes("%lu"),
     cst_Ld$0=caml_string_of_jsbytes("%+Ld"),
     cst_Ld$1=caml_string_of_jsbytes("% Ld"),
     cst_Li$1=caml_string_of_jsbytes("%+Li"),
     cst_Li$2=caml_string_of_jsbytes("% Li"),
     cst_Lx=caml_string_of_jsbytes("%Lx"),
     cst_Lx$0=caml_string_of_jsbytes("%#Lx"),
     cst_LX=caml_string_of_jsbytes("%LX"),
     cst_LX$0=caml_string_of_jsbytes("%#LX"),
     cst_Lo=caml_string_of_jsbytes("%Lo"),
     cst_Lo$0=caml_string_of_jsbytes("%#Lo"),
     cst_Ld=caml_string_of_jsbytes("%Ld"),
     cst_Li$0=caml_string_of_jsbytes("%Li"),
     cst_Lu=caml_string_of_jsbytes("%Lu"),
     cst_d$3=caml_string_of_jsbytes("%+d"),
     cst_d$4=caml_string_of_jsbytes("% d"),
     cst_i$1=caml_string_of_jsbytes("%+i"),
     cst_i$2=caml_string_of_jsbytes("% i"),
     cst_x=caml_string_of_jsbytes("%x"),
     cst_x$0=caml_string_of_jsbytes("%#x"),
     cst_X$0=caml_string_of_jsbytes("%X"),
     cst_X$1=caml_string_of_jsbytes("%#X"),
     cst_o=caml_string_of_jsbytes("%o"),
     cst_o$0=caml_string_of_jsbytes("%#o"),
     cst_d$2=caml_string_of_jsbytes("%d"),
     cst_i$0=caml_string_of_jsbytes("%i"),
     cst_u=caml_string_of_jsbytes("%u"),
     cst$26=caml_string_of_jsbytes("%!"),
     cst$27=caml_string_of_jsbytes("@{"),
     cst$28=caml_string_of_jsbytes("@["),
     cst_0c=caml_string_of_jsbytes("0c"),
     cst$20=caml_string_of_jsbytes("%%"),
     cst$12=caml_string_of_jsbytes("@]"),
     cst$13=caml_string_of_jsbytes("@}"),
     cst$14=caml_string_of_jsbytes("@?"),
     cst$15=caml_string_of_jsbytes("@\n"),
     cst$16=caml_string_of_jsbytes("@."),
     cst$17=caml_string_of_jsbytes("@@"),
     cst$18=caml_string_of_jsbytes("@%"),
     cst$19=caml_string_of_jsbytes("@"),
     cst$11=caml_string_of_jsbytes(".*"),
     cst_CamlinternalFormat_Type_mi=
      caml_string_of_jsbytes("CamlinternalFormat.Type_mismatch"),
     cst$58=caml_string_of_jsbytes(""),
     cst$59=caml_string_of_jsbytes("\n"),
     cst_a_boolean=caml_string_of_jsbytes("a boolean"),
     cst_an_integer=caml_string_of_jsbytes("an integer"),
     cst_an_integer$0=caml_string_of_jsbytes("an integer"),
     cst_a_float=caml_string_of_jsbytes("a float"),
     cst_a_float$0=caml_string_of_jsbytes("a float"),
     cst$55=caml_string_of_jsbytes(""),
     cst$56=caml_string_of_jsbytes(" "),
     cst$57=caml_string_of_jsbytes(""),
     cst_one_of=caml_string_of_jsbytes("one of: "),
     cst_Arg_Expand_is_is_only_allo=
      caml_string_of_jsbytes
       ("Arg.Expand is is only allowed with Arg.parse_and_expand_argv_dynamic"),
     cst_no_argument=caml_string_of_jsbytes("no argument"),
     cst$54=caml_string_of_jsbytes("(?)"),
     cst_help$3=caml_string_of_jsbytes("--help"),
     cst_help$4=caml_string_of_jsbytes("-help"),
     cst_help$2=caml_string_of_jsbytes("-help"),
     cst_Display_this_list_of_optio=
      caml_string_of_jsbytes(" Display this list of options"),
     cst_help=caml_string_of_jsbytes("-help"),
     cst_help$1=caml_string_of_jsbytes("--help"),
     cst_Display_this_list_of_optio$0=
      caml_string_of_jsbytes(" Display this list of options"),
     cst_help$0=caml_string_of_jsbytes("--help"),
     cst$51=caml_string_of_jsbytes("}"),
     cst$52=caml_string_of_jsbytes("|"),
     cst$53=caml_string_of_jsbytes("{"),
     cst_none=caml_string_of_jsbytes("<none>"),
     cst_Stdlib_Arg_Bad=caml_string_of_jsbytes("Stdlib.Arg.Bad"),
     cst_Stdlib_Arg_Help=caml_string_of_jsbytes("Stdlib.Arg.Help"),
     cst_Stdlib_Arg_Stop=caml_string_of_jsbytes("Stdlib.Arg.Stop"),
     cst$61=caml_string_of_jsbytes(""),
     cst$65=caml_string_of_jsbytes(""),
     cst_Program_not_linked_with_g_=
      caml_string_of_jsbytes
       ("(Program not linked with -g, cannot print stack backtrace)\n"),
     cst_Raised_at=caml_string_of_jsbytes("Raised at"),
     cst_Re_raised_at=caml_string_of_jsbytes("Re-raised at"),
     cst_Raised_by_primitive_operat=
      caml_string_of_jsbytes("Raised by primitive operation at"),
     cst_Called_from=caml_string_of_jsbytes("Called from"),
     cst_inlined=caml_string_of_jsbytes(" (inlined)"),
     cst$64=caml_string_of_jsbytes(""),
     partial=[4,0,0,0,[12,45,[4,0,0,0,0]]],
     cst_Out_of_memory=caml_string_of_jsbytes("Out of memory"),
     cst_Stack_overflow=caml_string_of_jsbytes("Stack overflow"),
     cst_Pattern_matching_failed=
      caml_string_of_jsbytes("Pattern matching failed"),
     cst_Assertion_failed=caml_string_of_jsbytes("Assertion failed"),
     cst_Undefined_recursive_module=
      caml_string_of_jsbytes("Undefined recursive module"),
     cst$62=caml_string_of_jsbytes(""),
     cst$63=caml_string_of_jsbytes(""),
     cst$60=caml_string_of_jsbytes("_"),
     locfmt=
      [0,
       [11,
        caml_string_of_jsbytes('File "'),
        [2,
         0,
         [11,
          caml_string_of_jsbytes('", line '),
          [4,
           0,
           0,
           0,
           [11,
            caml_string_of_jsbytes(", characters "),
            [4,
             0,
             0,
             0,
             [12,45,[4,0,0,0,[11,caml_string_of_jsbytes(": "),[2,0,0]]]]]]]]]],
       caml_string_of_jsbytes('File "%s", line %d, characters %d-%d: %s')],
     cst_Fun_Finally_raised=caml_string_of_jsbytes("Fun.Finally_raised: "),
     cst_Stdlib_Fun_Finally_raised=
      caml_string_of_jsbytes("Stdlib.Fun.Finally_raised"),
     cst_Digest_from_hex$0=caml_string_of_jsbytes("Digest.from_hex"),
     cst_Digest_from_hex=caml_string_of_jsbytes("Digest.from_hex"),
     cst_Digest_to_hex=caml_string_of_jsbytes("Digest.to_hex"),
     cst_Digest_substring=caml_string_of_jsbytes("Digest.substring"),
     cst_Random_int64=caml_string_of_jsbytes("Random.int64"),
     cst_Random_int32=caml_string_of_jsbytes("Random.int32"),
     cst_Random_int=caml_string_of_jsbytes("Random.int"),
     cst_x$1=caml_string_of_jsbytes("x"),
     cst_Hashtbl_unsupported_hash_t=
      caml_string_of_jsbytes("Hashtbl: unsupported hash table format"),
     cst_OCAMLRUNPARAM=caml_string_of_jsbytes("OCAMLRUNPARAM"),
     cst_CAMLRUNPARAM=caml_string_of_jsbytes("CAMLRUNPARAM"),
     cst$66=caml_string_of_jsbytes(""),
     cst_Weak_Make_hash_bucket_cann=
      caml_string_of_jsbytes("Weak.Make: hash bucket cannot grow more"),
     cst_Weak_fill=caml_string_of_jsbytes("Weak.fill"),
     cst_Weak_blit=caml_string_of_jsbytes("Weak.blit"),
     cst_Weak_check=caml_string_of_jsbytes("Weak.check"),
     cst_Weak_get_copy=caml_string_of_jsbytes("Weak.get_copy"),
     cst_Weak_get=caml_string_of_jsbytes("Weak.get"),
     cst_Weak_set=caml_string_of_jsbytes("Weak.set"),
     cst_Weak_create=caml_string_of_jsbytes("Weak.create"),
     cst$84=caml_string_of_jsbytes(""),
     cst$85=caml_string_of_jsbytes(""),
     cst$83=caml_string_of_jsbytes("."),
     cst$80=caml_string_of_jsbytes(">"),
     cst$81=caml_string_of_jsbytes("<\/"),
     cst$82=caml_string_of_jsbytes(""),
     cst$77=caml_string_of_jsbytes(">"),
     cst$78=caml_string_of_jsbytes("<"),
     cst$79=caml_string_of_jsbytes(""),
     cst$76=caml_string_of_jsbytes("\n"),
     cst_Format_pp_set_geometry=
      caml_string_of_jsbytes("Format.pp_set_geometry: "),
     cst$72=caml_string_of_jsbytes(""),
     cst$73=caml_string_of_jsbytes(""),
     cst$74=caml_string_of_jsbytes(""),
     cst$75=caml_string_of_jsbytes(""),
     cst$68=caml_string_of_jsbytes(""),
     cst$69=caml_string_of_jsbytes(""),
     cst$70=caml_string_of_jsbytes(""),
     cst$71=caml_string_of_jsbytes(""),
     cst$67=caml_string_of_jsbytes(""),
     cst_Stdlib_Format_String_tag=
      caml_string_of_jsbytes("Stdlib.Format.String_tag"),
     cst_end_of_input_not_found=
      caml_string_of_jsbytes("end of input not found"),
     cst_scanf_bad_conversion_a=
      caml_string_of_jsbytes('scanf: bad conversion "%a"'),
     cst_scanf_bad_conversion_t=
      caml_string_of_jsbytes('scanf: bad conversion "%t"'),
     cst_scanf_missing_reader=caml_string_of_jsbytes("scanf: missing reader"),
     cst_scanf_bad_conversion_custo=
      caml_string_of_jsbytes('scanf: bad conversion "%?" (custom converter)'),
     cst_scanf_bad_conversion=
      caml_string_of_jsbytes('scanf: bad conversion "%*"'),
     cst_scanf_bad_conversion$0=
      caml_string_of_jsbytes('scanf: bad conversion "%*"'),
     cst_scanf_bad_conversion$1=
      caml_string_of_jsbytes('scanf: bad conversion "%-"'),
     cst_scanf_bad_conversion$2=
      caml_string_of_jsbytes('scanf: bad conversion "%*"'),
     cst$91=caml_string_of_jsbytes('"'),
     cst$92=caml_string_of_jsbytes('"'),
     cst$89=caml_string_of_jsbytes('"'),
     cst$90=caml_string_of_jsbytes('"'),
     cst$88=caml_string_of_jsbytes('"'),
     cst_in_format=caml_string_of_jsbytes(' in format "'),
     cst_an=caml_string_of_jsbytes("an"),
     cst_x$2=caml_string_of_jsbytes("x"),
     cst_nfinity=caml_string_of_jsbytes("nfinity"),
     cst_digits=caml_string_of_jsbytes("digits"),
     cst_decimal_digits=caml_string_of_jsbytes("decimal digits"),
     cst_0b=caml_string_of_jsbytes("0b"),
     cst_0o=caml_string_of_jsbytes("0o"),
     cst_0u=caml_string_of_jsbytes("0u"),
     cst_0x=caml_string_of_jsbytes("0x"),
     cst_false$3=caml_string_of_jsbytes("false"),
     cst_true$3=caml_string_of_jsbytes("true"),
     cst_not_a_valid_float_in_hexad=
      caml_string_of_jsbytes("not a valid float in hexadecimal notation"),
     cst_no_dot_or_exponent_part_fo=
      caml_string_of_jsbytes("no dot or exponent part found in float token"),
     cst$87=caml_string_of_jsbytes("-"),
     cst_unnamed_function=caml_string_of_jsbytes("unnamed function"),
     cst_unnamed_character_string=
      caml_string_of_jsbytes("unnamed character string"),
     cst_unnamed_Stdlib_input_chann=
      caml_string_of_jsbytes("unnamed Stdlib input channel"),
     cst$86=caml_string_of_jsbytes("-"),
     cst_Stdlib_Scanf_Scan_failure=
      caml_string_of_jsbytes("Stdlib.Scanf.Scan_failure"),
     cst_binary=caml_string_of_jsbytes("binary"),
     cst_octal=caml_string_of_jsbytes("octal"),
     cst_hexadecimal=caml_string_of_jsbytes("hexadecimal"),
     cst_a_Char=caml_string_of_jsbytes("a Char"),
     cst_a_String=caml_string_of_jsbytes("a String"),
     cst$93=caml_string_of_jsbytes(""),
     cst$94=caml_string_of_jsbytes(""),
     cst$95=caml_string_of_jsbytes(""),
     cst$96=caml_string_of_jsbytes(""),
     cst$97=caml_string_of_jsbytes(""),
     cst$99=caml_string_of_jsbytes(""),
     cst$98=caml_string_of_jsbytes(""),
     cst_Illegal_character=caml_string_of_jsbytes("Illegal character "),
     cst_Filename_chop_extension=
      caml_string_of_jsbytes("Filename.chop_extension"),
     cst$127=caml_string_of_jsbytes(""),
     cst_Filename_chop_suffix=caml_string_of_jsbytes("Filename.chop_suffix"),
     cst$126=caml_string_of_jsbytes(""),
     cst_2_1$0=caml_string_of_jsbytes(" 2>&1"),
     cst_2$0=caml_string_of_jsbytes(" 2>"),
     cst$125=caml_string_of_jsbytes(""),
     cst$117=caml_string_of_jsbytes(" >"),
     cst$124=caml_string_of_jsbytes(""),
     cst$118=caml_string_of_jsbytes(" <"),
     cst$123=caml_string_of_jsbytes(""),
     cst$119=caml_string_of_jsbytes(" "),
     cst$120=caml_string_of_jsbytes(" "),
     cst$121=caml_string_of_jsbytes('"'),
     cst$122=caml_string_of_jsbytes(""),
     cst_Filename_quote_command_bad=
      caml_string_of_jsbytes("Filename.quote_command: bad file name "),
     cst$115=caml_string_of_jsbytes('"'),
     cst$116=caml_string_of_jsbytes('"'),
     cst$113=caml_string_of_jsbytes("./"),
     cst$112=caml_string_of_jsbytes(".\\"),
     cst$111=caml_string_of_jsbytes("../"),
     cst$110=caml_string_of_jsbytes("..\\"),
     cst_2_1=caml_string_of_jsbytes(" 2>&1"),
     cst_2=caml_string_of_jsbytes(" 2>"),
     cst$109=caml_string_of_jsbytes(""),
     cst$104=caml_string_of_jsbytes(" >"),
     cst$108=caml_string_of_jsbytes(""),
     cst$105=caml_string_of_jsbytes(" <"),
     cst$107=caml_string_of_jsbytes(""),
     cst$106=caml_string_of_jsbytes(" "),
     cst$103=caml_string_of_jsbytes("./"),
     cst$102=caml_string_of_jsbytes("../"),
     cst$101=caml_string_of_jsbytes(""),
     cst$100=caml_string_of_jsbytes(""),
     null$0=caml_string_of_jsbytes("/dev/null"),
     current_dir_name=caml_string_of_jsbytes("."),
     parent_dir_name=caml_string_of_jsbytes(".."),
     dir_sep=caml_string_of_jsbytes("/"),
     cst_TMPDIR=caml_string_of_jsbytes("TMPDIR"),
     cst_tmp=caml_string_of_jsbytes("/tmp"),
     quotequote=caml_string_of_jsbytes("'\\''"),
     null$1=caml_string_of_jsbytes("NUL"),
     current_dir_name$0=caml_string_of_jsbytes("."),
     parent_dir_name$0=caml_string_of_jsbytes(".."),
     dir_sep$0=caml_string_of_jsbytes("\\"),
     cst_TEMP=caml_string_of_jsbytes("TEMP"),
     cst$114=caml_string_of_jsbytes("."),
     null$2=caml_string_of_jsbytes("/dev/null"),
     current_dir_name$1=caml_string_of_jsbytes("."),
     parent_dir_name$1=caml_string_of_jsbytes(".."),
     dir_sep$1=caml_string_of_jsbytes("/"),
     cst_Cygwin=caml_string_of_jsbytes("Cygwin"),
     cst_Win32=caml_string_of_jsbytes("Win32"),
     zero$4=[254,0.,0.],
     one$4=[254,1.,0.],
     i=[254,0.,1.],
     cst_Bigarray_array3_of_genarra=
      caml_string_of_jsbytes("Bigarray.array3_of_genarray"),
     cst_Bigarray_array2_of_genarra=
      caml_string_of_jsbytes("Bigarray.array2_of_genarray"),
     cst_Bigarray_array1_of_genarra=
      caml_string_of_jsbytes("Bigarray.array1_of_genarray"),
     cst_Bigarray_array0_of_genarra=
      caml_string_of_jsbytes("Bigarray.array0_of_genarray"),
     cst_Bigarray_Array3_of_array_n=
      caml_string_of_jsbytes("Bigarray.Array3.of_array: non-cubic data"),
     cst_Bigarray_Array3_of_array_n$0=
      caml_string_of_jsbytes("Bigarray.Array3.of_array: non-cubic data"),
     cst_Bigarray_Array2_of_array_n=
      caml_string_of_jsbytes("Bigarray.Array2.of_array: non-rectangular data"),
     Invalid_argument=global_data.Invalid_argument,
     Failure=global_data.Failure,
     Match_failure=global_data.Match_failure,
     Assert_failure=global_data.Assert_failure,
     Not_found=global_data.Not_found,
     Out_of_memory=global_data.Out_of_memory,
     Stack_overflow=global_data.Stack_overflow,
     Sys_error=global_data.Sys_error,
     End_of_file=global_data.End_of_file,
     Division_by_zero=global_data.Division_by_zero,
     Sys_blocked_io=global_data.Sys_blocked_io,
     Undefined_recursive_module=global_data.Undefined_recursive_module,
     _l_=[0,0,[0,6,0]],
     _k_=[0,0,[0,7,0]],
     _j_=[0,1,[0,3,[0,4,[0,6,0]]]],
     _i_=[0,1,[0,3,[0,4,[0,7,0]]]],
     _g_=[0,1],
     _h_=[0,0],
     _a_=runtime.caml_int64_create_lo_mi_hi(0,0,32752),
     _b_=runtime.caml_int64_create_lo_mi_hi(0,0,65520),
     _c_=runtime.caml_int64_create_lo_mi_hi(1,0,32752),
     _d_=runtime.caml_int64_create_lo_mi_hi(16777215,16777215,32751),
     _e_=runtime.caml_int64_create_lo_mi_hi(0,0,16),
     _f_=runtime.caml_int64_create_lo_mi_hi(0,0,15536),
     _p_=[0,0,0],
     _q_=[0,caml_string_of_jsbytes("obj.ml"),100,4],
     _u_=[0,caml_string_of_jsbytes("array.ml"),258,4],
     _w_=[0,caml_string_of_jsbytes("float.ml"),379,6],
     _v_=[0,caml_string_of_jsbytes("float.ml"),206,14],
     _H_=runtime.caml_int64_create_lo_mi_hi(16777215,16777215,65535),
     _G_=runtime.caml_int64_create_lo_mi_hi(0,0,0),
     _F_=runtime.caml_int64_create_lo_mi_hi(1,0,0),
     _E_=runtime.caml_int64_create_lo_mi_hi(1,0,0),
     _I_=[0,0,0,0],
     _J_=[0,0,0],
     _K_=[0,caml_string_of_jsbytes("set.ml"),570,18],
     _L_=[0,0,0,0],
     _M_=[0,caml_string_of_jsbytes("map.ml"),400,10],
     _N_=[0,0,0],
     _O_=[0,caml_string_of_jsbytes("stream.ml"),53,12],
     _P_=[0,0],
     _Q_=[0,caml_string_of_jsbytes("stream.ml"),82,12],
     ___=[0,caml_string_of_jsbytes("buffer.ml"),282,9],
     _Z_=[0,caml_string_of_jsbytes("buffer.ml"),263,2],
     _Y_=[0,caml_string_of_jsbytes("buffer.ml"),195,19],
     _X_=[0,caml_string_of_jsbytes("buffer.ml"),213,8],
     _W_=[0,caml_string_of_jsbytes("buffer.ml"),174,19],
     _V_=[0,caml_string_of_jsbytes("buffer.ml"),192,8],
     _U_=[0,caml_string_of_jsbytes("buffer.ml"),138,19],
     _T_=[0,caml_string_of_jsbytes("buffer.ml"),171,8],
     _S_=[0,caml_string_of_jsbytes("buffer.ml"),93,2],
     _R_=[0,caml_string_of_jsbytes("buffer.ml"),94,2],
     _aa_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),850,23],
     _al_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),814,21],
     _ad_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),815,21],
     _am_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),818,21],
     _ae_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),819,21],
     _an_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),822,19],
     _af_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),823,19],
     _ao_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),826,22],
     _ag_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),827,22],
     _ap_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),831,30],
     _ah_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),832,30],
     _aj_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),836,26],
     _ab_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),837,26],
     _ak_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),846,28],
     _ac_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),847,28],
     _ai_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),851,23],
     _ar_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),1558,4],
     _as_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),1626,39],
     _at_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),1649,31],
     _au_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),1650,31],
     _av_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),1830,8],
     _aZ_=
      [0,
       [11,
        caml_string_of_jsbytes("bad input: format type mismatch between "),
        [3,0,[11,caml_string_of_jsbytes(" and "),[3,0,0]]]],
       caml_string_of_jsbytes
        ("bad input: format type mismatch between %S and %S")],
     _aY_=
      [0,
       [11,
        caml_string_of_jsbytes("bad input: format type mismatch between "),
        [3,0,[11,caml_string_of_jsbytes(" and "),[3,0,0]]]],
       caml_string_of_jsbytes
        ("bad input: format type mismatch between %S and %S")],
     _aB_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(": at character number "),
          [4,0,0,0,[11,caml_string_of_jsbytes(", duplicate flag "),[1,0]]]]]],
       caml_string_of_jsbytes
        ("invalid format %S: at character number %d, duplicate flag %C")],
     _aC_=[0,1,0],
     _aD_=[0,0],
     _aE_=[1,0],
     _aF_=[1,1],
     _aH_=[1,1],
     _aG_=[1,1],
     _aL_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(": at character number "),
          [4,
           0,
           0,
           0,
           [11,
            caml_string_of_jsbytes(", flag "),
            [1,
             [11,
              caml_string_of_jsbytes(" is only allowed after the '"),
              [12,
               37,
               [11,
                caml_string_of_jsbytes("', before padding and precision"),
                0]]]]]]]]],
       caml_string_of_jsbytes
        ("invalid format %S: at character number %d, flag %C is only allowed after the '%%', before padding and precision")],
     _aI_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(": at character number "),
          [4,
           0,
           0,
           0,
           [11,
            caml_string_of_jsbytes(', invalid conversion "'),
            [12,37,[0,[12,34,0]]]]]]]],
       caml_string_of_jsbytes
        ('invalid format %S: at character number %d, invalid conversion "%%%c"')],
     _aJ_=[0,0],
     _aK_=[0,0],
     _aM_=[0,[12,64,0]],
     _aN_=[0,caml_string_of_jsbytes("@ "),1,0],
     _aO_=[0,caml_string_of_jsbytes("@,"),0,0],
     _aP_=[2,60],
     _aQ_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(": '"),
          [12,
           37,
           [11,
            caml_string_of_jsbytes
             ("' alone is not accepted in character sets, use "),
            [12,
             37,
             [12,
              37,
              [11,
               caml_string_of_jsbytes(" instead at position "),
               [4,0,0,0,[12,46,0]]]]]]]]]],
       caml_string_of_jsbytes
        ("invalid format %S: '%%' alone is not accepted in character sets, use %%%% instead at position %d.")],
     _aR_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(": integer "),
          [4,
           0,
           0,
           0,
           [11,
            caml_string_of_jsbytes(" is greater than the limit "),
            [4,0,0,0,0]]]]]],
       caml_string_of_jsbytes
        ("invalid format %S: integer %d is greater than the limit %d")],
     _aS_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),2837,11],
     _aT_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(': unclosed sub-format, expected "'),
          [12,
           37,
           [0,
            [11,caml_string_of_jsbytes('" at character number '),[4,0,0,0,0]]]]]]],
       caml_string_of_jsbytes
        ('invalid format %S: unclosed sub-format, expected "%%%c" at character number %d')],
     _aU_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),2899,34],
     _aV_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),2935,28],
     _aW_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),2957,11],
     _aX_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(": at character number "),
          [4,
           0,
           0,
           0,
           [11,
            caml_string_of_jsbytes(", "),
            [2,
             0,
             [11,
              caml_string_of_jsbytes(" is incompatible with '"),
              [0,[11,caml_string_of_jsbytes("' in sub-format "),[3,0,0]]]]]]]]]],
       caml_string_of_jsbytes
        ("invalid format %S: at character number %d, %s is incompatible with '%c' in sub-format %S")],
     _aA_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(": at character number "),
          [4,
           0,
           0,
           0,
           [11,
            caml_string_of_jsbytes(", "),
            [2,0,[11,caml_string_of_jsbytes(" expected, read "),[1,0]]]]]]]],
       caml_string_of_jsbytes
        ("invalid format %S: at character number %d, %s expected, read %C")],
     _az_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(": at character number "),
          [4,
           0,
           0,
           0,
           [11,
            caml_string_of_jsbytes(", '"),
            [0,[11,caml_string_of_jsbytes("' without "),[2,0,0]]]]]]]],
       caml_string_of_jsbytes
        ("invalid format %S: at character number %d, '%c' without %s")],
     _ay_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(": at character number "),
          [4,0,0,0,[11,caml_string_of_jsbytes(", "),[2,0,0]]]]]],
       caml_string_of_jsbytes("invalid format %S: at character number %d, %s")],
     _ax_=
      [0,
       [11,caml_string_of_jsbytes("invalid box description "),[3,0,0]],
       caml_string_of_jsbytes("invalid box description %S")],
     _aw_=[0,0,4],
     _aq_=[0,103],
     _$_=[0,0,0],
     _bj_=[0,[2,0,[0,0]],caml_string_of_jsbytes("%s%c")],
     _bd_=[0,[2,0,0],caml_string_of_jsbytes("%s")],
     _be_=[0,[2,0,0],caml_string_of_jsbytes("%s")],
     _bb_=[0,[2,0,0],caml_string_of_jsbytes("%s")],
     _bc_=[0,[2,0,0],caml_string_of_jsbytes("%s")],
     _a$_=[0,[2,0,0],caml_string_of_jsbytes("%s")],
     _ba_=[0,[2,0,0],caml_string_of_jsbytes("%s")],
     _a5_=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes(": unknown option '"),
         [2,0,[11,caml_string_of_jsbytes("'.\n"),0]]]],
       caml_string_of_jsbytes("%s: unknown option '%s'.\n")],
     _a8_=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes(": wrong argument '"),
         [2,
          0,
          [11,
           caml_string_of_jsbytes("'; option '"),
           [2,
            0,
            [11,
             caml_string_of_jsbytes("' expects "),
             [2,0,[11,caml_string_of_jsbytes(".\n"),0]]]]]]]],
       caml_string_of_jsbytes
        ("%s: wrong argument '%s'; option '%s' expects %s.\n")],
     _a9_=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes(": option '"),
         [2,0,[11,caml_string_of_jsbytes("' needs an argument.\n"),0]]]],
       caml_string_of_jsbytes("%s: option '%s' needs an argument.\n")],
     _a__=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes(": "),
         [2,0,[11,caml_string_of_jsbytes(".\n"),0]]]],
       caml_string_of_jsbytes("%s: %s.\n")],
     _a6_=[0,caml_string_of_jsbytes("-help")],
     _a7_=[0,caml_string_of_jsbytes("--help")],
     _a4_=[0,[2,0,0],caml_string_of_jsbytes("%s")],
     _a3_=[0,[2,0,[12,10,0]],caml_string_of_jsbytes("%s\n")],
     _a2_=[0,caml_string_of_jsbytes("-help")],
     _a0_=
      [0,
       [11,caml_string_of_jsbytes("  "),[2,0,[12,32,[2,0,[12,10,0]]]]],
       caml_string_of_jsbytes("  %s %s\n")],
     _a1_=
      [0,
       [11,caml_string_of_jsbytes("  "),[2,0,[12,32,[2,0,[2,0,[12,10,0]]]]]],
       caml_string_of_jsbytes("  %s %s%s\n")],
     _bo_=
      [0,
       [11,caml_string_of_jsbytes(", "),[2,0,[2,0,0]]],
       caml_string_of_jsbytes(", %s%s")],
     _bz_=
      [0,
       [11,caml_string_of_jsbytes("Fatal error: exception "),[2,0,[12,10,0]]],
       caml_string_of_jsbytes("Fatal error: exception %s\n")],
     _bx_=[0,[2,0,[12,10,0]],caml_string_of_jsbytes("%s\n")],
     _bv_=[0,[2,0,[12,10,0]],caml_string_of_jsbytes("%s\n")],
     _bw_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("(Program not linked with -g, cannot print stack backtrace)\n"),
        0],
       caml_string_of_jsbytes
        ("(Program not linked with -g, cannot print stack backtrace)\n")],
     _bt_=
      [0,
       [2,
        0,
        [12,
         32,
         [2,
          0,
          [11,
           caml_string_of_jsbytes(' in file "'),
           [2,
            0,
            [12,
             34,
             [2,
              0,
              [11,
               caml_string_of_jsbytes(", line "),
               [4,0,0,0,[11,caml_string_of_jsbytes(", characters "),partial]]]]]]]]]],
       caml_string_of_jsbytes
        ('%s %s in file "%s"%s, line %d, characters %d-%d')],
     _bu_=
      [0,
       [2,0,[11,caml_string_of_jsbytes(" unknown location"),0]],
       caml_string_of_jsbytes("%s unknown location")],
     _bs_=
      [0,
       [11,caml_string_of_jsbytes("Uncaught exception: "),[2,0,[12,10,0]]],
       caml_string_of_jsbytes("Uncaught exception: %s\n")],
     _br_=
      [0,
       [11,caml_string_of_jsbytes("Uncaught exception: "),[2,0,[12,10,0]]],
       caml_string_of_jsbytes("Uncaught exception: %s\n")],
     _bp_=[0,[12,40,[2,0,[2,0,[12,41,0]]]],caml_string_of_jsbytes("(%s%s)")],
     _bq_=[0,[12,40,[2,0,[12,41,0]]],caml_string_of_jsbytes("(%s)")],
     _bn_=[0,[4,0,0,0,0],caml_string_of_jsbytes("%d")],
     _bm_=[0,[3,0,0],caml_string_of_jsbytes("%S")],
     _by_=
      [0,
       caml_string_of_jsbytes(""),
       caml_string_of_jsbytes
        ("(Cannot print locations:\n bytecode executable program file not found)"),
       caml_string_of_jsbytes
        ("(Cannot print locations:\n bytecode executable program file appears to be corrupt)"),
       caml_string_of_jsbytes
        ("(Cannot print locations:\n bytecode executable program file has wrong magic number)"),
       caml_string_of_jsbytes
        ("(Cannot print locations:\n bytecode executable program file cannot be opened;\n -- too many open files. Try running with OCAMLRUNPARAM=b=2)")],
     _bG_=
      [0,
       [11,
        caml_string_of_jsbytes("minor_collections:      "),
        [4,0,0,0,[12,10,0]]],
       caml_string_of_jsbytes("minor_collections:      %d\n")],
     _bH_=
      [0,
       [11,
        caml_string_of_jsbytes("major_collections:      "),
        [4,0,0,0,[12,10,0]]],
       caml_string_of_jsbytes("major_collections:      %d\n")],
     _bI_=
      [0,
       [11,
        caml_string_of_jsbytes("compactions:            "),
        [4,0,0,0,[12,10,0]]],
       caml_string_of_jsbytes("compactions:            %d\n")],
     _bJ_=
      [0,
       [11,
        caml_string_of_jsbytes("forced_major_collections: "),
        [4,0,0,0,[12,10,0]]],
       caml_string_of_jsbytes("forced_major_collections: %d\n")],
     _bK_=[0,[12,10,0],caml_string_of_jsbytes("\n")],
     _bL_=[0,[8,[0,0,0],0,[0,0],0],caml_string_of_jsbytes("%.0f")],
     _bM_=
      [0,
       [11,
        caml_string_of_jsbytes("minor_words:    "),
        [8,[0,0,0],[1,1],[0,0],[12,10,0]]],
       caml_string_of_jsbytes("minor_words:    %*.0f\n")],
     _bN_=
      [0,
       [11,
        caml_string_of_jsbytes("promoted_words: "),
        [8,[0,0,0],[1,1],[0,0],[12,10,0]]],
       caml_string_of_jsbytes("promoted_words: %*.0f\n")],
     _bO_=
      [0,
       [11,
        caml_string_of_jsbytes("major_words:    "),
        [8,[0,0,0],[1,1],[0,0],[12,10,0]]],
       caml_string_of_jsbytes("major_words:    %*.0f\n")],
     _bP_=[0,[12,10,0],caml_string_of_jsbytes("\n")],
     _bQ_=[0,[4,0,0,0,0],caml_string_of_jsbytes("%d")],
     _bR_=
      [0,
       [11,caml_string_of_jsbytes("top_heap_words: "),[4,0,[1,1],0,[12,10,0]]],
       caml_string_of_jsbytes("top_heap_words: %*d\n")],
     _bS_=
      [0,
       [11,caml_string_of_jsbytes("heap_words:     "),[4,0,[1,1],0,[12,10,0]]],
       caml_string_of_jsbytes("heap_words:     %*d\n")],
     _bT_=
      [0,
       [11,caml_string_of_jsbytes("live_words:     "),[4,0,[1,1],0,[12,10,0]]],
       caml_string_of_jsbytes("live_words:     %*d\n")],
     _bU_=
      [0,
       [11,caml_string_of_jsbytes("free_words:     "),[4,0,[1,1],0,[12,10,0]]],
       caml_string_of_jsbytes("free_words:     %*d\n")],
     _bV_=
      [0,
       [11,caml_string_of_jsbytes("largest_free:   "),[4,0,[1,1],0,[12,10,0]]],
       caml_string_of_jsbytes("largest_free:   %*d\n")],
     _bW_=
      [0,
       [11,caml_string_of_jsbytes("fragments:      "),[4,0,[1,1],0,[12,10,0]]],
       caml_string_of_jsbytes("fragments:      %*d\n")],
     _bX_=[0,[12,10,0],caml_string_of_jsbytes("\n")],
     _bY_=
      [0,
       [11,caml_string_of_jsbytes("live_blocks: "),[4,0,0,0,[12,10,0]]],
       caml_string_of_jsbytes("live_blocks: %d\n")],
     _bZ_=
      [0,
       [11,caml_string_of_jsbytes("free_blocks: "),[4,0,0,0,[12,10,0]]],
       caml_string_of_jsbytes("free_blocks: %d\n")],
     _b0_=
      [0,
       [11,caml_string_of_jsbytes("heap_chunks: "),[4,0,0,0,[12,10,0]]],
       caml_string_of_jsbytes("heap_chunks: %d\n")],
     _b8_=runtime.caml_int64_create_lo_mi_hi(1,0,0),
     _b9_=runtime.caml_int64_create_lo_mi_hi(0,0,0),
     _b__=
      [0,
       987910699,
       495797812,
       364182224,
       414272206,
       318284740,
       990407751,
       383018966,
       270373319,
       840823159,
       24560019,
       536292337,
       512266505,
       189156120,
       730249596,
       143776328,
       51606627,
       140166561,
       366354223,
       1003410265,
       700563762,
       981890670,
       913149062,
       526082594,
       1021425055,
       784300257,
       667753350,
       630144451,
       949649812,
       48546892,
       415514493,
       258888527,
       511570777,
       89983870,
       283659902,
       308386020,
       242688715,
       482270760,
       865188196,
       1027664170,
       207196989,
       193777847,
       619708188,
       671350186,
       149669678,
       257044018,
       87658204,
       558145612,
       183450813,
       28133145,
       901332182,
       710253903,
       510646120,
       652377910,
       409934019,
       801085050],
     _cc_=[0,0],
     _cb_=[0,caml_string_of_jsbytes("hashtbl.ml"),102,23],
     _ci_=[3,0,3],
     _ch_=[1,caml_string_of_jsbytes("max_indent < 2")],
     _cf_=[1,caml_string_of_jsbytes("margin <= max_indent")],
     _cg_=[0,0],
     _ce_=[0,caml_string_of_jsbytes("")],
     _cd_=[0,caml_string_of_jsbytes(""),0,caml_string_of_jsbytes("")],
     _cy_=[0,91],
     _cx_=[0,123],
     _cz_=[0,caml_string_of_jsbytes("scanf.ml"),1453,13],
     _cA_=[0,[3,0,[10,0]],caml_string_of_jsbytes("%S%!")],
     _cw_=[0,37,caml_string_of_jsbytes("")],
     _cv_=
      [0,
       [11,
        caml_string_of_jsbytes("scanf: bad input at char number "),
        [4,3,0,0,[11,caml_string_of_jsbytes(": "),[2,0,0]]]],
       caml_string_of_jsbytes("scanf: bad input at char number %i: %s")],
     _cu_=
      [0,
       [11,
        caml_string_of_jsbytes("the character "),
        [1,[11,caml_string_of_jsbytes(" cannot start a boolean"),0]]],
       caml_string_of_jsbytes("the character %C cannot start a boolean")],
     _ct_=
      [0,
       [11,
        caml_string_of_jsbytes("bad character hexadecimal encoding \\"),
        [0,[0,0]]],
       caml_string_of_jsbytes("bad character hexadecimal encoding \\%c%c")],
     _cs_=
      [0,
       [11,
        caml_string_of_jsbytes("bad character decimal encoding \\"),
        [0,[0,[0,0]]]],
       caml_string_of_jsbytes("bad character decimal encoding \\%c%c%c")],
     _cr_=
      [0,
       [11,
        caml_string_of_jsbytes("character "),
        [1,
         [11,
          caml_string_of_jsbytes(" is not a valid "),
          [2,0,[11,caml_string_of_jsbytes(" digit"),0]]]]],
       caml_string_of_jsbytes("character %C is not a valid %s digit")],
     _cq_=
      [0,
       [11,
        caml_string_of_jsbytes("character "),
        [1,[11,caml_string_of_jsbytes(" is not a decimal digit"),0]]],
       caml_string_of_jsbytes("character %C is not a decimal digit")],
     _cp_=[0,caml_string_of_jsbytes("scanf.ml"),555,9],
     _co_=
      [0,
       [11,caml_string_of_jsbytes("invalid boolean '"),[2,0,[12,39,0]]],
       caml_string_of_jsbytes("invalid boolean '%s'")],
     _cn_=
      [0,
       [11,
        caml_string_of_jsbytes("looking for "),
        [1,[11,caml_string_of_jsbytes(", found "),[1,0]]]],
       caml_string_of_jsbytes("looking for %C, found %C")],
     _cm_=
      [0,
       [11,
        caml_string_of_jsbytes("scanning of "),
        [2,
         0,
         [11,
          caml_string_of_jsbytes
           (" failed: premature end of file occurred before end of token"),
          0]]],
       caml_string_of_jsbytes
        ("scanning of %s failed: premature end of file occurred before end of token")],
     _cl_=
      [0,
       [11,
        caml_string_of_jsbytes("scanning of "),
        [2,
         0,
         [11,
          caml_string_of_jsbytes
           (" failed: the specified length was too short for token"),
          0]]],
       caml_string_of_jsbytes
        ("scanning of %s failed: the specified length was too short for token")],
     _ck_=
      [0,
       [11,caml_string_of_jsbytes("illegal escape character "),[1,0]],
       caml_string_of_jsbytes("illegal escape character %C")],
     _cH_=[0,caml_string_of_jsbytes("camlinternalOO.ml"),438,17],
     _cG_=[0,caml_string_of_jsbytes("camlinternalOO.ml"),420,13],
     _cF_=[0,caml_string_of_jsbytes("camlinternalOO.ml"),417,13],
     _cE_=[0,caml_string_of_jsbytes("camlinternalOO.ml"),414,13],
     _cD_=[0,caml_string_of_jsbytes("camlinternalOO.ml"),411,13],
     _cC_=[0,caml_string_of_jsbytes("camlinternalOO.ml"),408,13],
     _cB_=[0,caml_string_of_jsbytes("camlinternalOO.ml"),281,50],
     _cK_=[0,0],
     _cJ_=[0,0],
     _cI_=[0,0],
     _cP_=[0,7,0],
     _cO_=[0,1,[0,3,[0,5,0]]],
     _cN_=[0,[2,0,[4,6,[0,2,6],0,[2,0,0]]],caml_string_of_jsbytes("%s%06x%s")],
     _cM_=[0,caml_string_of_jsbytes('"'),0],
     _cQ_=[254,0.,0.];
    function erase_rel(param)
     {if(typeof param === "number")
       return 0;
      else
       switch(param[0])
        {case 0:var rest=param[1];return [0,erase_rel(rest)];
         case 1:var rest$0=param[1];return [1,erase_rel(rest$0)];
         case 2:var rest$1=param[1];return [2,erase_rel(rest$1)];
         case 3:var rest$2=param[1];return [3,erase_rel(rest$2)];
         case 4:var rest$3=param[1];return [4,erase_rel(rest$3)];
         case 5:var rest$4=param[1];return [5,erase_rel(rest$4)];
         case 6:var rest$5=param[1];return [6,erase_rel(rest$5)];
         case 7:var rest$6=param[1];return [7,erase_rel(rest$6)];
         case 8:
          var rest$7=param[2],ty=param[1];return [8,ty,erase_rel(rest$7)];
         case 9:
          var rest$8=param[3],ty1=param[1];
          return [9,ty1,ty1,erase_rel(rest$8)];
         case 10:var rest$9=param[1];return [10,erase_rel(rest$9)];
         case 11:var rest$10=param[1];return [11,erase_rel(rest$10)];
         case 12:var rest$11=param[1];return [12,erase_rel(rest$11)];
         case 13:var rest$12=param[1];return [13,erase_rel(rest$12)];
         default:var rest$13=param[1];return [14,erase_rel(rest$13)]}}
    function concat_fmtty(fmtty1,fmtty2)
     {if(typeof fmtty1 === "number")
       return fmtty2;
      else
       switch(fmtty1[0])
        {case 0:var rest=fmtty1[1];return [0,concat_fmtty(rest,fmtty2)];
         case 1:var rest$0=fmtty1[1];return [1,concat_fmtty(rest$0,fmtty2)];
         case 2:var rest$1=fmtty1[1];return [2,concat_fmtty(rest$1,fmtty2)];
         case 3:var rest$2=fmtty1[1];return [3,concat_fmtty(rest$2,fmtty2)];
         case 4:var rest$3=fmtty1[1];return [4,concat_fmtty(rest$3,fmtty2)];
         case 5:var rest$4=fmtty1[1];return [5,concat_fmtty(rest$4,fmtty2)];
         case 6:var rest$5=fmtty1[1];return [6,concat_fmtty(rest$5,fmtty2)];
         case 7:var rest$6=fmtty1[1];return [7,concat_fmtty(rest$6,fmtty2)];
         case 8:
          var rest$7=fmtty1[2],ty=fmtty1[1];
          return [8,ty,concat_fmtty(rest$7,fmtty2)];
         case 9:
          var rest$8=fmtty1[3],ty2=fmtty1[2],ty1=fmtty1[1];
          return [9,ty1,ty2,concat_fmtty(rest$8,fmtty2)];
         case 10:var rest$9=fmtty1[1];return [10,concat_fmtty(rest$9,fmtty2)];
         case 11:
          var rest$10=fmtty1[1];return [11,concat_fmtty(rest$10,fmtty2)];
         case 12:
          var rest$11=fmtty1[1];return [12,concat_fmtty(rest$11,fmtty2)];
         case 13:
          var rest$12=fmtty1[1];return [13,concat_fmtty(rest$12,fmtty2)];
         default:
          var rest$13=fmtty1[1];return [14,concat_fmtty(rest$13,fmtty2)]}}
    function concat_fmt(fmt1,fmt2)
     {if(typeof fmt1 === "number")
       return fmt2;
      else
       switch(fmt1[0])
        {case 0:var rest=fmt1[1];return [0,concat_fmt(rest,fmt2)];
         case 1:var rest$0=fmt1[1];return [1,concat_fmt(rest$0,fmt2)];
         case 2:
          var rest$1=fmt1[2],pad=fmt1[1];
          return [2,pad,concat_fmt(rest$1,fmt2)];
         case 3:
          var rest$2=fmt1[2],pad$0=fmt1[1];
          return [3,pad$0,concat_fmt(rest$2,fmt2)];
         case 4:
          var rest$3=fmt1[4],prec=fmt1[3],pad$1=fmt1[2],iconv=fmt1[1];
          return [4,iconv,pad$1,prec,concat_fmt(rest$3,fmt2)];
         case 5:
          var rest$4=fmt1[4],prec$0=fmt1[3],pad$2=fmt1[2],iconv$0=fmt1[1];
          return [5,iconv$0,pad$2,prec$0,concat_fmt(rest$4,fmt2)];
         case 6:
          var rest$5=fmt1[4],prec$1=fmt1[3],pad$3=fmt1[2],iconv$1=fmt1[1];
          return [6,iconv$1,pad$3,prec$1,concat_fmt(rest$5,fmt2)];
         case 7:
          var rest$6=fmt1[4],prec$2=fmt1[3],pad$4=fmt1[2],iconv$2=fmt1[1];
          return [7,iconv$2,pad$4,prec$2,concat_fmt(rest$6,fmt2)];
         case 8:
          var rest$7=fmt1[4],prec$3=fmt1[3],pad$5=fmt1[2],fconv=fmt1[1];
          return [8,fconv,pad$5,prec$3,concat_fmt(rest$7,fmt2)];
         case 9:
          var rest$8=fmt1[2],pad$6=fmt1[1];
          return [9,pad$6,concat_fmt(rest$8,fmt2)];
         case 10:var rest$9=fmt1[1];return [10,concat_fmt(rest$9,fmt2)];
         case 11:
          var rest$10=fmt1[2],str=fmt1[1];
          return [11,str,concat_fmt(rest$10,fmt2)];
         case 12:
          var rest$11=fmt1[2],chr=fmt1[1];
          return [12,chr,concat_fmt(rest$11,fmt2)];
         case 13:
          var rest$12=fmt1[3],fmtty=fmt1[2],pad$7=fmt1[1];
          return [13,pad$7,fmtty,concat_fmt(rest$12,fmt2)];
         case 14:
          var rest$13=fmt1[3],fmtty$0=fmt1[2],pad$8=fmt1[1];
          return [14,pad$8,fmtty$0,concat_fmt(rest$13,fmt2)];
         case 15:var rest$14=fmt1[1];return [15,concat_fmt(rest$14,fmt2)];
         case 16:var rest$15=fmt1[1];return [16,concat_fmt(rest$15,fmt2)];
         case 17:
          var rest$16=fmt1[2],fmting_lit=fmt1[1];
          return [17,fmting_lit,concat_fmt(rest$16,fmt2)];
         case 18:
          var rest$17=fmt1[2],fmting_gen=fmt1[1];
          return [18,fmting_gen,concat_fmt(rest$17,fmt2)];
         case 19:var rest$18=fmt1[1];return [19,concat_fmt(rest$18,fmt2)];
         case 20:
          var rest$19=fmt1[3],char_set=fmt1[2],width_opt=fmt1[1];
          return [20,width_opt,char_set,concat_fmt(rest$19,fmt2)];
         case 21:
          var rest$20=fmt1[2],counter=fmt1[1];
          return [21,counter,concat_fmt(rest$20,fmt2)];
         case 22:var rest$21=fmt1[1];return [22,concat_fmt(rest$21,fmt2)];
         case 23:
          var rest$22=fmt1[2],ign=fmt1[1];
          return [23,ign,concat_fmt(rest$22,fmt2)];
         default:
          var rest$23=fmt1[3],f=fmt1[2],arity=fmt1[1];
          return [24,arity,f,concat_fmt(rest$23,fmt2)]}}
    var CamlinternalFormatBasics=[0,concat_fmtty,erase_rel,concat_fmt];
    caml_register_global
     (744,CamlinternalFormatBasics,"CamlinternalFormatBasics");
    function make(v){return [0,v]}
    function get(r){return r[1]}
    function set(r,v){r[1] = v;return 0}
    function exchange(r,v){var cur=r[1];r[1] = v;return cur}
    function compare_and_set(r,seen,v)
     {var cur=r[1];return cur === seen?(r[1] = v,1):0}
    function fetch_and_add(r,n){var cur=r[1];r[1] = cur + n | 0;return cur}
    function incr(r){fetch_and_add(r,1);return 0}
    function decr(r){fetch_and_add(r,-1);return 0}
    var
     include=
      [0,make,get,set,exchange,compare_and_set,fetch_and_add,incr,decr];
    caml_register_global(745,include,"CamlinternalAtomic");
    function failwith(s){throw [0,Failure,s]}
    function invalid_arg(s){throw [0,Invalid_argument,s]}
    var Exit=[248,cst_Stdlib_Exit,caml_fresh_oo_id(0)];
    function min(x,y){return caml_lessequal(x,y)?x:y}
    function max(x,y){return caml_greaterequal(x,y)?x:y}
    function abs(x){return 0 <= x?x:- x | 0}
    function lnot(x){return x ^ -1}
    var
     infinity=caml_int64_float_of_bits(_a_),
     neg_infinity=caml_int64_float_of_bits(_b_),
     nan=caml_int64_float_of_bits(_c_),
     max_float=caml_int64_float_of_bits(_d_),
     min_float=caml_int64_float_of_bits(_e_),
     epsilon=caml_int64_float_of_bits(_f_),
     max_int=2147483647,
     min_int=-2147483648;
    function symbol(s1,s2)
     {var
       l1=caml_ml_string_length(s1),
       l2=caml_ml_string_length(s2),
       s=caml_create_bytes(l1 + l2 | 0);
      caml_blit_string(s1,0,s,0,l1);
      caml_blit_string(s2,0,s,l1,l2);
      return caml_string_of_bytes(s)}
    function char_of_int(n)
     {if(0 <= n && ! (255 < n))return n;return invalid_arg(cst_char_of_int)}
    function string_of_bool(b){return b?cst_true:cst_false}
    function bool_of_string(param)
     {return caml_string_notequal(param,cst_false$0)
              ?caml_string_notequal(param,cst_true$0)
                ?invalid_arg(cst_bool_of_string)
                :1
              :0}
    function bool_of_string_opt(param)
     {return caml_string_notequal(param,cst_false$1)
              ?caml_string_notequal(param,cst_true$1)?0:_g_
              :_h_}
    function string_of_int(n){return caml_string_of_jsbytes("" + n)}
    function int_of_string_opt(s)
     {try
       {var _BP_=[0,caml_int_of_string(s)];return _BP_}
      catch(_BQ_)
       {_BQ_ = caml_wrap_exception(_BQ_);
        if(_BQ_[1] === Failure)return 0;
        throw _BQ_}}
    function valid_float_lexem(s)
     {var l=caml_ml_string_length(s),i=0;
      for(;;)
       {if(l <= i)return symbol(s,cst);
        var match=caml_string_get(s,i),switch$0=0;
        if(48 <= match)
         {if(! (58 <= match))switch$0 = 1}
        else
         if(45 === match)switch$0 = 1;
        if(switch$0){var i$0=i + 1 | 0,i=i$0;continue}
        return s}}
    function to_string(f)
     {return valid_float_lexem(caml_format_float(cst_12g,f))}
    function of_string_opt(s)
     {try
       {var _BN_=[0,caml_float_of_string(s)];return _BN_}
      catch(_BO_)
       {_BO_ = caml_wrap_exception(_BO_);
        if(_BO_[1] === Failure)return 0;
        throw _BO_}}
    function append(l1,l2)
     {if(l1){var tl=l1[2],hd=l1[1];return [0,hd,append(tl,l2)]}return l2}
    var
     stdin=caml_ml_open_descriptor_in(0),
     stdout=caml_ml_open_descriptor_out(1),
     stderr=caml_ml_open_descriptor_out(2);
    function open_out_gen(mode,perm,name)
     {var c=caml_ml_open_descriptor_out(caml_sys_open(name,mode,perm));
      caml_ml_set_channel_name(c,name);
      return c}
    function open_out(name){return open_out_gen(_i_,438,name)}
    function open_out_bin(name){return open_out_gen(_j_,438,name)}
    function flush_all(param)
     {function iter(param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var l=param$0[2],a=param$0[1];
            try
             {caml_ml_flush(a)}
            catch(_BM_)
             {_BM_ = caml_wrap_exception(_BM_);
              if(_BM_[1] !== Sys_error)throw _BM_;
              var _BL_=_BM_}
            var param$0=l;
            continue}
          return 0}}
      return iter(runtime.caml_ml_out_channels_list(0))}
    function output_bytes(oc,s)
     {return caml_ml_output_bytes(oc,s,0,caml_ml_bytes_length(s))}
    function output_string(oc,s)
     {return caml_ml_output(oc,s,0,caml_ml_string_length(s))}
    function output(oc,s,ofs,len)
     {if
       (0 <= ofs && 0 <= len && ! ((caml_ml_bytes_length(s) - len | 0) < ofs))
       return caml_ml_output_bytes(oc,s,ofs,len);
      return invalid_arg(cst_output)}
    function output_substring(oc,s,ofs,len)
     {if
       (0
        <=
        ofs
        &&
        0
        <=
        len
        &&
        !
        ((caml_ml_string_length(s) - len | 0) < ofs))
       return caml_ml_output(oc,s,ofs,len);
      return invalid_arg(cst_output_substring)}
    function output_value(chan,v){return caml_output_value(chan,v,0)}
    function close_out(oc){caml_ml_flush(oc);return caml_ml_close_channel(oc)}
    function close_out_noerr(oc)
     {try {caml_ml_flush(oc)}catch(_BK_){}
      try
       {var _BI_=caml_ml_close_channel(oc);return _BI_}
      catch(_BJ_){return 0}}
    function open_in_gen(mode,perm,name)
     {var c=caml_ml_open_descriptor_in(caml_sys_open(name,mode,perm));
      caml_ml_set_channel_name(c,name);
      return c}
    function open_in(name){return open_in_gen(_k_,0,name)}
    function open_in_bin(name){return open_in_gen(_l_,0,name)}
    function input(ic,s,ofs,len)
     {if
       (0 <= ofs && 0 <= len && ! ((caml_ml_bytes_length(s) - len | 0) < ofs))
       return caml_ml_input(ic,s,ofs,len);
      return invalid_arg(cst_input)}
    function unsafe_really_input(ic,s,ofs,len)
     {var ofs$0=ofs,len$0=len;
      for(;;)
       {if(0 < len$0)
         {var r=caml_ml_input(ic,s,ofs$0,len$0);
          if(0 === r)throw End_of_file;
          var len$1=len$0 - r | 0,ofs$1=ofs$0 + r | 0,ofs$0=ofs$1,len$0=len$1;
          continue}
        return 0}}
    function really_input(ic,s,ofs,len)
     {if
       (0 <= ofs && 0 <= len && ! ((caml_ml_bytes_length(s) - len | 0) < ofs))
       return unsafe_really_input(ic,s,ofs,len);
      return invalid_arg(cst_really_input)}
    function really_input_string(ic,len)
     {var s=caml_create_bytes(len);
      really_input(ic,s,0,len);
      return caml_string_of_bytes(s)}
    function input_line(chan)
     {function build_result(buf,pos,param)
       {var pos$0=pos,param$0=param;
        for(;;)
         {if(param$0)
           {var tl=param$0[2],hd=param$0[1],len=caml_ml_bytes_length(hd);
            caml_blit_bytes(hd,0,buf,pos$0 - len | 0,len);
            var pos$1=pos$0 - len | 0,pos$0=pos$1,param$0=tl;
            continue}
          return buf}}
      var accu=0,len=0;
      for(;;)
       {var n=runtime.caml_ml_input_scan_line(chan);
        if(0 === n)
         {if(! accu)throw End_of_file;
          var _BH_=build_result(caml_create_bytes(len),len,accu)}
        else
         {if(! (0 < n))
           {var beg=caml_create_bytes(- n | 0);
            caml_ml_input(chan,beg,0,- n | 0);
            var len$1=len - n | 0,accu$0=[0,beg,accu],accu=accu$0,len=len$1;
            continue}
          var res=caml_create_bytes(n - 1 | 0);
          caml_ml_input(chan,res,0,n - 1 | 0);
          caml_ml_input_char(chan);
          if(accu)
           var
            len$0=(len + n | 0) - 1 | 0,
            _BH_=build_result(caml_create_bytes(len$0),len$0,[0,res,accu]);
          else
           var _BH_=res}
        return caml_string_of_bytes(_BH_)}}
    function close_in_noerr(ic)
     {try
       {var _BF_=caml_ml_close_channel(ic);return _BF_}
      catch(_BG_){return 0}}
    function print_char(c){return caml_ml_output_char(stdout,c)}
    function print_string(s){return output_string(stdout,s)}
    function print_bytes(s){return output_bytes(stdout,s)}
    function print_int(i)
     {return output_string(stdout,caml_string_of_jsbytes("" + i))}
    function print_float(f){return output_string(stdout,to_string(f))}
    function print_endline(s)
     {output_string(stdout,s);
      caml_ml_output_char(stdout,10);
      return caml_ml_flush(stdout)}
    function print_newline(param)
     {caml_ml_output_char(stdout,10);return caml_ml_flush(stdout)}
    function prerr_char(c){return caml_ml_output_char(stderr,c)}
    function prerr_string(s){return output_string(stderr,s)}
    function prerr_bytes(s){return output_bytes(stderr,s)}
    function prerr_int(i)
     {return output_string(stderr,caml_string_of_jsbytes("" + i))}
    function prerr_float(f){return output_string(stderr,to_string(f))}
    function prerr_endline(s)
     {output_string(stderr,s);
      caml_ml_output_char(stderr,10);
      return caml_ml_flush(stderr)}
    function prerr_newline(param)
     {caml_ml_output_char(stderr,10);return caml_ml_flush(stderr)}
    function read_line(param){caml_ml_flush(stdout);return input_line(stdin)}
    function read_int(param){return caml_int_of_string(read_line(0))}
    function read_int_opt(param){return int_of_string_opt(read_line(0))}
    function read_float(param){return caml_float_of_string(read_line(0))}
    function read_float_opt(param){return of_string_opt(read_line(0))}
    function string_of_format(param){var str=param[2];return str}
    function symbol$0(param,_BD_)
     {var
       str2=_BD_[2],
       fmt2=_BD_[1],
       str1=param[2],
       fmt1=param[1],
       _BE_=symbol(str1,symbol(cst$0,str2));
      return [0,concat_fmt(fmt1,fmt2),_BE_]}
    var exit_function=[0,flush_all];
    function at_exit(f)
     {for(;;)
       {var
         f_yet_to_run=[0,1],
         old_exit=exit_function[1],
         new_exit$0=
          function(f_yet_to_run,old_exit)
           {function new_exit(param)
             {if(compare_and_set(f_yet_to_run,1,0))caml_call1(f,0);
              return caml_call1(old_exit,0)}
            return new_exit},
         new_exit=new_exit$0(f_yet_to_run,old_exit),
         success=compare_and_set(exit_function,old_exit,new_exit),
         _BC_=1 - success;
        if(_BC_)continue;
        return _BC_}}
    function do_at_exit(param){return caml_call1(exit_function[1],0)}
    function exit(retcode)
     {do_at_exit(0);return runtime.caml_sys_exit(retcode)}
    if(runtime.caml_sys_const_naked_pointers_checked(0))
     at_exit(function(_BB_){return runtime.caml_gc_major(_BB_)});
    var
     set_binary_mode_in=caml_ml_set_binary_mode,
     close_in=caml_ml_close_channel,
     in_channel_length=caml_ml_channel_size,
     pos_in=runtime.caml_ml_pos_in,
     seek_in=runtime.caml_ml_seek_in,
     input_value=caml_input_value,
     input_binary_int=runtime.caml_ml_input_int,
     input_byte=caml_ml_input_char,
     input_char=caml_ml_input_char,
     set_binary_mode_out=caml_ml_set_binary_mode,
     out_channel_length=caml_ml_channel_size,
     pos_out=runtime.caml_ml_pos_out,
     seek_out=runtime.caml_ml_seek_out,
     output_binary_int=runtime.caml_ml_output_int,
     output_byte=caml_ml_output_char,
     output_char=caml_ml_output_char,
     flush=caml_ml_flush,
     Stdlib=
      [0,
       invalid_arg,
       failwith,
       Exit,
       Match_failure,
       Assert_failure,
       Invalid_argument,
       Failure,
       Not_found,
       Out_of_memory,
       Stack_overflow,
       Sys_error,
       End_of_file,
       Division_by_zero,
       Sys_blocked_io,
       Undefined_recursive_module,
       min,
       max,
       abs,
       max_int,
       min_int,
       lnot,
       infinity,
       neg_infinity,
       nan,
       max_float,
       min_float,
       epsilon,
       symbol,
       char_of_int,
       string_of_bool,
       bool_of_string_opt,
       bool_of_string,
       string_of_int,
       int_of_string_opt,
       to_string,
       of_string_opt,
       append,
       stdin,
       stdout,
       stderr,
       print_char,
       print_string,
       print_bytes,
       print_int,
       print_float,
       print_endline,
       print_newline,
       prerr_char,
       prerr_string,
       prerr_bytes,
       prerr_int,
       prerr_float,
       prerr_endline,
       prerr_newline,
       read_line,
       read_int_opt,
       read_int,
       read_float_opt,
       read_float,
       open_out,
       open_out_bin,
       open_out_gen,
       flush,
       flush_all,
       output_char,
       output_string,
       output_bytes,
       output,
       output_substring,
       output_byte,
       output_binary_int,
       output_value,
       seek_out,
       pos_out,
       out_channel_length,
       close_out,
       close_out_noerr,
       set_binary_mode_out,
       open_in,
       open_in_bin,
       open_in_gen,
       input_char,
       input_line,
       input,
       really_input,
       really_input_string,
       input_byte,
       input_binary_int,
       input_value,
       seek_in,
       pos_in,
       in_channel_length,
       close_in,
       close_in_noerr,
       set_binary_mode_in,
       [0,
        runtime.caml_ml_seek_out_64,
        runtime.caml_ml_pos_out_64,
        caml_ml_channel_size_64,
        runtime.caml_ml_seek_in_64,
        runtime.caml_ml_pos_in_64,
        caml_ml_channel_size_64],
       string_of_format,
       symbol$0,
       exit,
       at_exit,
       valid_float_lexem,
       unsafe_really_input,
       do_at_exit];
    caml_register_global(758,Stdlib,"Stdlib");
    var
     Exit$0=[248,cst_Stdlib_Pervasives_Exit,caml_fresh_oo_id(0)],
     Stdlib_pervasives=
      [0,
       invalid_arg,
       failwith,
       Exit$0,
       min,
       max,
       abs,
       max_int,
       min_int,
       lnot,
       infinity,
       neg_infinity,
       nan,
       max_float,
       min_float,
       epsilon,
       symbol,
       char_of_int,
       string_of_bool,
       bool_of_string,
       bool_of_string_opt,
       string_of_int,
       int_of_string_opt,
       to_string,
       of_string_opt,
       append,
       stdin,
       stdout,
       stderr,
       print_char,
       print_string,
       print_bytes,
       print_int,
       print_float,
       print_endline,
       print_newline,
       prerr_char,
       prerr_string,
       prerr_bytes,
       prerr_int,
       prerr_float,
       prerr_endline,
       prerr_newline,
       read_line,
       read_int,
       read_int_opt,
       read_float,
       read_float_opt,
       open_out,
       open_out_bin,
       open_out_gen,
       flush,
       flush_all,
       output_char,
       output_string,
       output_bytes,
       output,
       output_substring,
       output_byte,
       output_binary_int,
       output_value,
       seek_out,
       pos_out,
       out_channel_length,
       close_out,
       close_out_noerr,
       set_binary_mode_out,
       open_in,
       open_in_bin,
       open_in_gen,
       input_char,
       input_line,
       input,
       really_input,
       really_input_string,
       input_byte,
       input_binary_int,
       input_value,
       seek_in,
       pos_in,
       in_channel_length,
       close_in,
       close_in_noerr,
       set_binary_mode_in,
       string_of_format,
       symbol$0,
       exit,
       at_exit,
       valid_float_lexem,
       do_at_exit];
    caml_register_global(759,Stdlib_pervasives,"Stdlib__pervasives");
    function empty(param){return 0}
    function return$0(x,param){return [0,x,empty]}
    function cons(x,next,param){return [0,x,next]}
    function append$0(seq1,seq2,param)
     {var match=caml_call1(seq1,0);
      if(match)
       {var next=match[2],x=match[1];
        return [0,x,function(_BA_){return append$0(next,seq2,_BA_)}]}
      return caml_call1(seq2,0)}
    function map(f,seq,param)
     {var match=caml_call1(seq,0);
      if(match)
       {var
         next=match[2],
         x=match[1],
         _By_=function(_Bz_){return map(f,next,_Bz_)};
        return [0,caml_call1(f,x),_By_]}
      return 0}
    function filter_map(f,seq,param)
     {var seq$0=seq;
      for(;;)
       {var match=caml_call1(seq$0,0);
        if(match)
         {var next=match[2],x=match[1],match$0=caml_call1(f,x);
          if(match$0)
           {var y=match$0[1];
            return [0,y,function(_Bx_){return filter_map(f,next,_Bx_)}]}
          var seq$0=next;
          continue}
        return 0}}
    function filter(f,seq,param)
     {var seq$0=seq;
      for(;;)
       {var match=caml_call1(seq$0,0);
        if(match)
         {var next=match[2],x=match[1];
          if(caml_call1(f,x))
           return [0,x,function(_Bw_){return filter(f,next,_Bw_)}];
          var seq$0=next;
          continue}
        return 0}}
    function flat_map$0(counter,f,seq,param)
     {var match=caml_call1(seq,0);
      if(match)
       {var next=match[2],x=match[1],_Bv_=caml_call1(f,x),_Bu_=0;
        if(counter < 50)
         {var counter$0=counter + 1 | 0;
          return flat_map_app$0(counter$0,f,_Bv_,next,_Bu_)}
        return caml_trampoline_return(flat_map_app$0,[0,f,_Bv_,next,_Bu_])}
      return 0}
    function flat_map_app$0(counter,f,seq,tail,param)
     {var match=caml_call1(seq,0);
      if(match)
       {var next=match[2],x=match[1];
        return [0,x,function(_Bt_){return flat_map_app(f,next,tail,_Bt_)}]}
      var _Bs_=0;
      if(counter < 50)
       {var counter$0=counter + 1 | 0;
        return flat_map$0(counter$0,f,tail,_Bs_)}
      return caml_trampoline_return(flat_map$0,[0,f,tail,_Bs_])}
    function flat_map(f,seq,param)
     {return caml_trampoline(flat_map$0(0,f,seq,param))}
    function flat_map_app(f,seq,tail,param)
     {return caml_trampoline(flat_map_app$0(0,f,seq,tail,param))}
    function fold_left(f,acc,seq)
     {var acc$0=acc,seq$0=seq;
      for(;;)
       {var match=caml_call1(seq$0,0);
        if(match)
         {var
           next=match[2],
           x=match[1],
           acc$1=caml_call2(f,acc$0,x),
           acc$0=acc$1,
           seq$0=next;
          continue}
        return acc$0}}
    function iter(f,seq)
     {var seq$0=seq;
      for(;;)
       {var match=caml_call1(seq$0,0);
        if(match)
         {var next=match[2],x=match[1];
          caml_call1(f,x);
          var seq$0=next;
          continue}
        return 0}}
    function unfold(f,u,param)
     {var match=caml_call1(f,u);
      if(match)
       {var match$0=match[1],u$0=match$0[2],x=match$0[1];
        return [0,x,function(_Br_){return unfold(f,u$0,_Br_)}]}
      return 0}
    var
     Stdlib_seq=
      [0,
       empty,
       return$0,
       cons,
       append$0,
       map,
       filter,
       filter_map,
       flat_map,
       fold_left,
       iter,
       unfold];
    caml_register_global(760,Stdlib_seq,"Stdlib__seq");
    var none=0;
    function some(v){return [0,v]}
    function value(o,default$0){if(o){var v=o[1];return v}return default$0}
    function get$0(param)
     {if(param){var v=param[1];return v}
      return invalid_arg(cst_option_is_None)}
    function bind(o,f){if(o){var v=o[1];return caml_call1(f,v)}return 0}
    function join(param){if(param){var o=param[1];return o}return 0}
    function map$0(f,o){if(o){var v=o[1];return [0,caml_call1(f,v)]}return 0}
    function fold(none,some,param)
     {if(param){var v=param[1];return caml_call1(some,v)}return none}
    function iter$0(f,param)
     {if(param){var v=param[1];return caml_call1(f,v)}return 0}
    function is_none(param){return param?0:1}
    function is_some(param){return param?1:0}
    function equal(eq,o0,o1)
     {if(o0)
       {if(o1){var v1=o1[1],v0=o0[1];return caml_call2(eq,v0,v1)}}
      else
       if(! o1)return 1;
      return 0}
    function compare(cmp,o0,o1)
     {if(o0)
       {var _Bq_=o0[1];
        if(o1){var v1=o1[1];return caml_call2(cmp,_Bq_,v1)}
        return 1}
      return o1?-1:0}
    function to_result(none,param)
     {if(param){var v=param[1];return [0,v]}return [1,none]}
    function to_list(param){if(param){var v=param[1];return [0,v,0]}return 0}
    function to_seq(param)
     {if(param){var v=param[1];return function(_Bp_){return return$0(v,_Bp_)}}
      return empty}
    var
     Stdlib_option=
      [0,
       none,
       some,
       value,
       get$0,
       bind,
       join,
       map$0,
       fold,
       iter$0,
       is_none,
       is_some,
       equal,
       compare,
       to_result,
       to_list,
       to_seq];
    caml_register_global(761,Stdlib_option,"Stdlib__option");
    function left(v){return [0,v]}
    function right(v){return [1,v]}
    function is_left(param){return 0 === param[0]?1:0}
    function is_right(param){return 0 === param[0]?0:1}
    function find_left(param)
     {if(0 === param[0]){var v=param[1];return [0,v]}return 0}
    function find_right(param)
     {if(0 === param[0])return 0;var v=param[1];return [0,v]}
    function map_left(f,e)
     {if(0 === e[0]){var v=e[1];return [0,caml_call1(f,v)]}return e}
    function map_right(f,e)
     {if(0 === e[0])return e;var v=e[1];return [1,caml_call1(f,v)]}
    function map$1(left,right,param)
     {if(0 === param[0]){var v=param[1];return [0,caml_call1(left,v)]}
      var v$0=param[1];
      return [1,caml_call1(right,v$0)]}
    function fold$0(left,right,param)
     {if(0 === param[0]){var v=param[1];return caml_call1(left,v)}
      var v$0=param[1];
      return caml_call1(right,v$0)}
    function equal$0(left,right,e1,match)
     {if(0 === e1[0])
       {var _Bn_=e1[1];
        if(0 === match[0]){var v2=match[1];return caml_call2(left,_Bn_,v2)}}
      else
       {var _Bo_=e1[1];
        if(0 !== match[0])
         {var v2$0=match[1];return caml_call2(right,_Bo_,v2$0)}}
      return 0}
    function compare$0(left,right,e1,match)
     {if(0 === e1[0])
       {var _Bl_=e1[1];
        if(0 === match[0]){var v2=match[1];return caml_call2(left,_Bl_,v2)}
        return -1}
      var _Bm_=e1[1];
      if(0 === match[0])return 1;
      var v2$0=match[1];
      return caml_call2(right,_Bm_,v2$0)}
    var
     Stdlib_either=
      [0,
       left,
       right,
       is_left,
       is_right,
       find_left,
       find_right,
       map_left,
       map_right,
       map$1,
       fold$0,
       fold$0,
       fold$0,
       equal$0,
       compare$0];
    caml_register_global(762,Stdlib_either,"Stdlib__either");
    function ok(v){return [0,v]}
    function error(e){return [1,e]}
    function value$0(r,default$0)
     {if(0 === r[0]){var v=r[1];return v}return default$0}
    function get_ok(param)
     {if(0 === param[0]){var v=param[1];return v}
      return invalid_arg(cst_result_is_Error)}
    function get_error(param)
     {if(0 === param[0])return invalid_arg(cst_result_is_Ok);
      var e=param[1];
      return e}
    function bind$0(r,f)
     {if(0 === r[0]){var v=r[1];return caml_call1(f,v)}return r}
    function join$0(e){if(0 === e[0]){var r=e[1];return r}return e}
    function map$2(f,e)
     {if(0 === e[0]){var v=e[1];return [0,caml_call1(f,v)]}return e}
    function map_error(f,v)
     {if(0 === v[0])return v;var e=v[1];return [1,caml_call1(f,e)]}
    function fold$1(ok,error,param)
     {if(0 === param[0]){var v=param[1];return caml_call1(ok,v)}
      var e=param[1];
      return caml_call1(error,e)}
    function iter$1(f,param)
     {if(0 === param[0]){var v=param[1];return caml_call1(f,v)}return 0}
    function iter_error(f,param)
     {if(0 === param[0])return 0;var e=param[1];return caml_call1(f,e)}
    function is_ok(param){return 0 === param[0]?1:0}
    function is_error(param){return 0 === param[0]?0:1}
    function equal$1(ok,error,r0,match)
     {if(0 === r0[0])
       {var _Bj_=r0[1];
        if(0 === match[0]){var v1=match[1];return caml_call2(ok,_Bj_,v1)}}
      else
       {var _Bk_=r0[1];
        if(0 !== match[0]){var e1=match[1];return caml_call2(error,_Bk_,e1)}}
      return 0}
    function compare$1(ok,error,r0,match)
     {if(0 === r0[0])
       {var _Bh_=r0[1];
        if(0 === match[0]){var v1=match[1];return caml_call2(ok,_Bh_,v1)}
        return -1}
      var _Bi_=r0[1];
      if(0 === match[0])return 1;
      var e1=match[1];
      return caml_call2(error,_Bi_,e1)}
    function to_option(param)
     {if(0 === param[0]){var v=param[1];return [0,v]}return 0}
    function to_list$0(param)
     {if(0 === param[0]){var v=param[1];return [0,v,0]}return 0}
    function to_seq$0(param)
     {if(0 === param[0])
       {var v=param[1];return function(_Bg_){return return$0(v,_Bg_)}}
      return empty}
    var
     Stdlib_result=
      [0,
       ok,
       error,
       value$0,
       get_ok,
       get_error,
       bind$0,
       join$0,
       map$2,
       map_error,
       fold$1,
       iter$1,
       iter_error,
       is_ok,
       is_error,
       equal$1,
       compare$1,
       to_option,
       to_list$0,
       to_seq$0];
    caml_register_global(763,Stdlib_result,"Stdlib__result");
    function equal$2(_Bf_,_Be_){return _Bf_ === _Be_?1:0}
    var compare$2=caml_int_compare;
    function to_float(param){return param?1.:0.}
    function to_string$0(param){return param?cst_true$2:cst_false$2}
    function _m_(_Bd_){return _Bd_}
    var
     Stdlib_bool=
      [0,
       function(_Bc_){return 1 - _Bc_},
       equal$2,
       compare$2,
       _m_,
       to_float,
       to_string$0];
    caml_register_global(764,Stdlib_bool,"Stdlib__bool");
    function chr(n)
     {if(0 <= n && ! (255 < n))return n;return invalid_arg(cst_Char_chr)}
    function escaped(c)
     {var switch$0=0;
      if(40 <= c)
       {if(92 === c)return cst$1;if(! (127 <= c))switch$0 = 1}
      else
       if(32 <= c)
        {if(39 <= c)return cst$2;switch$0 = 1}
       else
        if(! (14 <= c))
         switch(c)
          {case 8:return cst_b;
           case 9:return cst_t;
           case 10:return cst_n;
           case 13:return cst_r
           }
      if(switch$0)
       {var s$0=caml_create_bytes(1);
        caml_bytes_unsafe_set(s$0,0,c);
        return caml_string_of_bytes(s$0)}
      var s=caml_create_bytes(4);
      caml_bytes_unsafe_set(s,0,92);
      caml_bytes_unsafe_set(s,1,48 + (c / 100 | 0) | 0);
      caml_bytes_unsafe_set(s,2,48 + ((c / 10 | 0) % 10 | 0) | 0);
      caml_bytes_unsafe_set(s,3,48 + (c % 10 | 0) | 0);
      return caml_string_of_bytes(s)}
    function lowercase(c)
     {var _Bb_=c - 192 | 0,switch$0=0;
      if(30 < _Bb_ >>> 0)
       {if(! (25 < (_Bb_ + 127 | 0) >>> 0))switch$0 = 1}
      else
       if(23 !== _Bb_)switch$0 = 1;
      return switch$0?c + 32 | 0:c}
    function uppercase(c)
     {var _Ba_=c - 224 | 0,switch$0=0;
      if(30 < _Ba_ >>> 0)
       {if(! (25 < (_Ba_ + 127 | 0) >>> 0))switch$0 = 1}
      else
       if(23 !== _Ba_)switch$0 = 1;
      return switch$0?c - 32 | 0:c}
    function lowercase_ascii(c)
     {var switcher=c - 65 | 0;return 25 < switcher >>> 0?c:c + 32 | 0}
    function uppercase_ascii(c)
     {var switcher=c - 97 | 0;return 25 < switcher >>> 0?c:c - 32 | 0}
    function compare$3(c1,c2){return c1 - c2 | 0}
    function equal$3(c1,c2){return 0 === (c1 - c2 | 0)?1:0}
    var
     Stdlib_char=
      [0,
       chr,
       escaped,
       lowercase,
       uppercase,
       lowercase_ascii,
       uppercase_ascii,
       compare$3,
       equal$3];
    caml_register_global(765,Stdlib_char,"Stdlib__char");
    var
     min$0=0,
     max$0=1114111,
     lo_bound=55295,
     hi_bound=57344,
     bom=65279,
     rep=65533;
    function succ(u)
     {return u === 55295
              ?hi_bound
              :u === 1114111?invalid_arg(err_no_succ):u + 1 | 0}
    function pred(u)
     {return u === 57344?lo_bound:u === 0?invalid_arg(err_no_pred):u - 1 | 0}
    function is_valid(i)
     {var _A8_=0 <= i?1:0,_A9_=_A8_?i <= 55295?1:0:_A8_;
      if(_A9_)
       var _A__=_A9_;
      else
       var _A$_=57344 <= i?1:0,_A__=_A$_?i <= 1114111?1:0:_A$_;
      return _A__}
    function of_int(i)
     {return is_valid(i)
              ?i
              :invalid_arg
                (symbol
                  (caml_format_int(cst_X,i),cst_is_not_an_Unicode_scalar_v))}
    function is_char(u){return u < 256?1:0}
    function of_char(c){return c}
    function to_char(u)
     {return 255 < u
              ?invalid_arg
                (symbol
                  (cst_U,
                   symbol
                    (caml_format_int(cst_04X,u),cst_is_not_a_latin1_character)))
              :u}
    function unsafe_to_char(_A7_){return _A7_}
    function equal$4(_A6_,_A5_){return _A6_ === _A5_?1:0}
    var compare$4=caml_int_compare;
    function hash(_A4_){return _A4_}
    function _n_(_A3_){return _A3_}
    var
     Stdlib_uchar=
      [0,
       min$0,
       max$0,
       bom,
       rep,
       succ,
       pred,
       is_valid,
       of_int,
       function(_A2_){return _A2_},
       _n_,
       is_char,
       of_char,
       to_char,
       unsafe_to_char,
       equal$4,
       compare$4,
       hash];
    caml_register_global(766,Stdlib_uchar,"Stdlib__uchar");
    var
     executable_name=runtime.caml_sys_executable_name(0),
     match=runtime.caml_sys_get_config(0),
     os_type=match[1],
     match$0=runtime.caml_sys_const_backend_type(0),
     unix=runtime.caml_sys_const_ostype_unix(0),
     win32=runtime.caml_sys_const_ostype_win32(0),
     cygwin=runtime.caml_sys_const_ostype_cygwin(0),
     max_array_length=runtime.caml_sys_const_max_wosize(0),
     max_floatarray_length=max_array_length / 2 | 0,
     max_string_length=(4 * max_array_length | 0) - 1 | 0,
     big_endian=0,
     match$1=32,
     int_size=32;
    function getenv_opt(s)
     {try
       {var _A0_=[0,caml_sys_getenv(s)];return _A0_}
      catch(_A1_)
       {_A1_ = caml_wrap_exception(_A1_);
        if(_A1_ === Not_found)return 0;
        throw _A1_}}
    var interactive=[0,0];
    function set_signal(sig_num,sig_beh){return 0}
    var
     Break=[248,cst_Stdlib_Sys_Break,caml_fresh_oo_id(0)],
     sigabrt=-1,
     sigalrm=-2,
     sigfpe=-3,
     sighup=-4,
     sigill=-5,
     sigint=-6,
     sigkill=-7,
     sigpipe=-8,
     sigquit=-9,
     sigsegv=-10,
     sigterm=-11,
     sigusr1=-12,
     sigusr2=-13,
     sigchld=-14,
     sigcont=-15,
     sigstop=-16,
     sigtstp=-17,
     sigttin=-18,
     sigttou=-19,
     sigvtalrm=-20,
     sigprof=-21,
     sigbus=-22,
     sigpoll=-23,
     sigsys=-24,
     sigtrap=-25,
     sigurg=-26,
     sigxcpu=-27,
     sigxfsz=-28;
    function catch_break(on){return on?0:0}
    function Make(_AZ_,_AY_){return [0,1]}
    var
     Immediate64=[0,Make],
     Stdlib_sys=
      [0,
       executable_name,
       getenv_opt,
       interactive,
       os_type,
       match$0,
       unix,
       win32,
       cygwin,
       match$1,
       int_size,
       big_endian,
       max_string_length,
       max_array_length,
       max_floatarray_length,
       set_signal,
       sigabrt,
       sigalrm,
       sigfpe,
       sighup,
       sigill,
       sigint,
       sigkill,
       sigpipe,
       sigquit,
       sigsegv,
       sigterm,
       sigusr1,
       sigusr2,
       sigchld,
       sigcont,
       sigstop,
       sigtstp,
       sigttin,
       sigttou,
       sigvtalrm,
       sigprof,
       sigbus,
       sigpoll,
       sigsys,
       sigtrap,
       sigurg,
       sigxcpu,
       sigxfsz,
       Break,
       catch_break,
       ocaml_version,
       runtime.caml_ml_enable_runtime_warnings,
       runtime.caml_ml_runtime_warnings_enabled,
       Immediate64];
    caml_register_global(767,Stdlib_sys,"Stdlib__sys");
    function length(l)
     {var len=0,param=l;
      for(;;)
       {if(param)
         {var param$0=param[2],len$0=len + 1 | 0,len=len$0,param=param$0;
          continue}
        return len}}
    function cons$0(a,l){return [0,a,l]}
    function hd(param)
     {if(param){var a=param[1];return a}return failwith(cst_hd)}
    function tl(param)
     {if(param){var l=param[2];return l}return failwith(cst_tl)}
    function nth(l,n)
     {if(0 <= n)
       {var l$0=l,n$0=n;
        for(;;)
         {if(l$0)
           {var l$1=l$0[2],a=l$0[1];
            if(0 === n$0)return a;
            var n$1=n$0 - 1 | 0,l$0=l$1,n$0=n$1;
            continue}
          return failwith(cst_nth)}}
      return invalid_arg(cst_List_nth)}
    function nth_opt(l,n)
     {if(0 <= n)
       {var l$0=l,n$0=n;
        for(;;)
         {if(l$0)
           {var l$1=l$0[2],a=l$0[1];
            if(0 === n$0)return [0,a];
            var n$1=n$0 - 1 | 0,l$0=l$1,n$0=n$1;
            continue}
          return 0}}
      return invalid_arg(cst_List_nth$0)}
    function rev_append(l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {var l1$1=l1$0[2],a=l1$0[1],l2$1=[0,a,l2$0],l1$0=l1$1,l2$0=l2$1;
          continue}
        return l2$0}}
    function rev(l){return rev_append(l,0)}
    function init_aux(i,n,f)
     {if(n <= i)return 0;
      var r=caml_call1(f,i);
      return [0,r,init_aux(i + 1 | 0,n,f)]}
    var rev_init_threshold=typeof match$0 === "number"?10000:50;
    function init(len,f)
     {if(0 <= len)
       {if(rev_init_threshold < len)
         {var acc=0,i=0;
          for(;;)
           {if(len <= i)return rev(acc);
            var i$0=i + 1 | 0,acc$0=[0,caml_call1(f,i),acc],acc=acc$0,i=i$0;
            continue}}
        return init_aux(0,len,f)}
      return invalid_arg(cst_List_init)}
    function flatten(param)
     {if(param){var r=param[2],l=param[1];return append(l,flatten(r))}
      return 0}
    function map$3(f,param)
     {if(param)
       {var l=param[2],a=param[1],r=caml_call1(f,a);return [0,r,map$3(f,l)]}
      return 0}
    function _o_(i,f,param)
     {if(param)
       {var l=param[2],a=param[1],r=caml_call2(f,i,a);
        return [0,r,_o_(i + 1 | 0,f,l)]}
      return 0}
    function mapi(f,l){return _o_(0,f,l)}
    function rev_map(f,param)
     {var accu=0,param$0=param;
      for(;;)
       {if(param$0)
         {var
           l=param$0[2],
           a=param$0[1],
           accu$0=[0,caml_call1(f,a),accu],
           accu=accu$0,
           param$0=l;
          continue}
        return accu}}
    function iter$2(f,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],a=param$0[1];
          caml_call1(f,a);
          var param$0=l;
          continue}
        return 0}}
    function iteri(f,l$0)
     {var i=0,param=l$0;
      for(;;)
       {if(param)
         {var l=param[2],a=param[1];
          caml_call2(f,i,a);
          var i$0=i + 1 | 0,i=i$0,param=l;
          continue}
        return 0}}
    function fold_left$0(f,accu,l)
     {var accu$0=accu,l$0=l;
      for(;;)
       {if(l$0)
         {var
           l$1=l$0[2],
           a=l$0[1],
           accu$1=caml_call2(f,accu$0,a),
           accu$0=accu$1,
           l$0=l$1;
          continue}
        return accu$0}}
    function fold_right(f,l,accu)
     {if(l){var l$0=l[2],a=l[1];return caml_call2(f,a,fold_right(f,l$0,accu))}
      return accu}
    function map2(f,l1,l2)
     {if(l1)
       {if(l2)
         {var l2$0=l2[2],a2=l2[1],l1$0=l1[2],a1=l1[1],r=caml_call2(f,a1,a2);
          return [0,r,map2(f,l1$0,l2$0)]}}
      else
       if(! l2)return 0;
      return invalid_arg(cst_List_map2)}
    function rev_map2(f,l1,l2)
     {var accu=0,l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var
             l2$1=l2$0[2],
             a2=l2$0[1],
             l1$1=l1$0[2],
             a1=l1$0[1],
             accu$0=[0,caml_call2(f,a1,a2),accu],
             accu=accu$0,
             l1$0=l1$1,
             l2$0=l2$1;
            continue}}
        else
         if(! l2$0)return accu;
        return invalid_arg(cst_List_rev_map2)}}
    function iter2(f,l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var l2$1=l2$0[2],a2=l2$0[1],l1$1=l1$0[2],a1=l1$0[1];
            caml_call2(f,a1,a2);
            var l1$0=l1$1,l2$0=l2$1;
            continue}}
        else
         if(! l2$0)return 0;
        return invalid_arg(cst_List_iter2)}}
    function fold_left2(f,accu,l1,l2)
     {var accu$0=accu,l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var
             l2$1=l2$0[2],
             a2=l2$0[1],
             l1$1=l1$0[2],
             a1=l1$0[1],
             accu$1=caml_call3(f,accu$0,a1,a2),
             accu$0=accu$1,
             l1$0=l1$1,
             l2$0=l2$1;
            continue}}
        else
         if(! l2$0)return accu$0;
        return invalid_arg(cst_List_fold_left2)}}
    function fold_right2(f,l1,l2,accu)
     {if(l1)
       {if(l2)
         {var l2$0=l2[2],a2=l2[1],l1$0=l1[2],a1=l1[1];
          return caml_call3(f,a1,a2,fold_right2(f,l1$0,l2$0,accu))}}
      else
       if(! l2)return accu;
      return invalid_arg(cst_List_fold_right2)}
    function for_all(p,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],a=param$0[1],_AX_=caml_call1(p,a);
          if(_AX_){var param$0=l;continue}
          return _AX_}
        return 1}}
    function exists(p,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],a=param$0[1],_AW_=caml_call1(p,a);
          if(_AW_)return _AW_;
          var param$0=l;
          continue}
        return 0}}
    function for_all2(p,l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var
             l2$1=l2$0[2],
             a2=l2$0[1],
             l1$1=l1$0[2],
             a1=l1$0[1],
             _AV_=caml_call2(p,a1,a2);
            if(_AV_){var l1$0=l1$1,l2$0=l2$1;continue}
            return _AV_}}
        else
         if(! l2$0)return 1;
        return invalid_arg(cst_List_for_all2)}}
    function exists2(p,l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var
             l2$1=l2$0[2],
             a2=l2$0[1],
             l1$1=l1$0[2],
             a1=l1$0[1],
             _AU_=caml_call2(p,a1,a2);
            if(_AU_)return _AU_;
            var l1$0=l1$1,l2$0=l2$1;
            continue}}
        else
         if(! l2$0)return 0;
        return invalid_arg(cst_List_exists2)}}
    function mem(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],a=param$0[1],_AT_=0 === caml_compare(a,x)?1:0;
          if(_AT_)return _AT_;
          var param$0=l;
          continue}
        return 0}}
    function memq(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],a=param$0[1],_AS_=a === x?1:0;
          if(_AS_)return _AS_;
          var param$0=l;
          continue}
        return 0}}
    function assoc(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],match=param$0[1],b=match[2],a=match[1];
          if(0 === caml_compare(a,x))return b;
          var param$0=l;
          continue}
        throw Not_found}}
    function assoc_opt(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],match=param$0[1],b=match[2],a=match[1];
          if(0 === caml_compare(a,x))return [0,b];
          var param$0=l;
          continue}
        return 0}}
    function assq(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],match=param$0[1],b=match[2],a=match[1];
          if(a === x)return b;
          var param$0=l;
          continue}
        throw Not_found}}
    function assq_opt(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],match=param$0[1],b=match[2],a=match[1];
          if(a === x)return [0,b];
          var param$0=l;
          continue}
        return 0}}
    function mem_assoc(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var
           l=param$0[2],
           match=param$0[1],
           a=match[1],
           _AR_=0 === caml_compare(a,x)?1:0;
          if(_AR_)return _AR_;
          var param$0=l;
          continue}
        return 0}}
    function mem_assq(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],match=param$0[1],a=match[1],_AQ_=a === x?1:0;
          if(_AQ_)return _AQ_;
          var param$0=l;
          continue}
        return 0}}
    function remove_assoc(x,param)
     {if(param)
       {var l=param[2],pair=param[1],a=pair[1];
        return 0 === caml_compare(a,x)?l:[0,pair,remove_assoc(x,l)]}
      return 0}
    function remove_assq(x,param)
     {if(param)
       {var l=param[2],pair=param[1],a=pair[1];
        return a === x?l:[0,pair,remove_assq(x,l)]}
      return 0}
    function find(p,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],x=param$0[1];
          if(caml_call1(p,x))return x;
          var param$0=l;
          continue}
        throw Not_found}}
    function find_opt(p,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],x=param$0[1];
          if(caml_call1(p,x))return [0,x];
          var param$0=l;
          continue}
        return 0}}
    function find_map(f,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],x=param$0[1],result=caml_call1(f,x);
          if(result)return result;
          var param$0=l;
          continue}
        return 0}}
    function find_all(p)
     {var accu=0;
      return function(param$0)
       {var accu$0=accu,param=param$0;
        for(;;)
         {if(param)
           {var l=param[2],x=param[1];
            if(caml_call1(p,x))
             {var accu$1=[0,x,accu$0],accu$0=accu$1,param=l;continue}
            var param=l;
            continue}
          return rev(accu$0)}}}
    function filteri(p,param)
     {var i=0,acc=0,param$0=param;
      for(;;)
       {if(param$0)
         {var
           l=param$0[2],
           x=param$0[1],
           acc$0=caml_call2(p,i,x)?[0,x,acc]:acc,
           i$0=i + 1 | 0,
           i=i$0,
           acc=acc$0,
           param$0=l;
          continue}
        return rev(acc)}}
    function filter_map$0(f)
     {var accu=0;
      return function(param$0)
       {var accu$0=accu,param=param$0;
        for(;;)
         {if(param)
           {var l=param[2],x=param[1],match=caml_call1(f,x);
            if(match)
             {var v=match[1],accu$1=[0,v,accu$0],accu$0=accu$1,param=l;
              continue}
            var param=l;
            continue}
          return rev(accu$0)}}}
    function concat_map(f,param)
     {var acc=0,param$0=param;
      for(;;)
       {if(param$0)
         {var
           l=param$0[2],
           x=param$0[1],
           xs=caml_call1(f,x),
           acc$0=rev_append(xs,acc),
           acc=acc$0,
           param$0=l;
          continue}
        return rev(acc)}}
    function fold_left_map(f,accu,param)
     {var accu$0=accu,l_accu=0,param$0=param;
      for(;;)
       {if(param$0)
         {var
           l=param$0[2],
           x=param$0[1],
           match=caml_call2(f,accu$0,x),
           x$0=match[2],
           accu$1=match[1],
           l_accu$0=[0,x$0,l_accu],
           accu$0=accu$1,
           l_accu=l_accu$0,
           param$0=l;
          continue}
        return [0,accu$0,rev(l_accu)]}}
    function partition(p,param)
     {var yes=0,no=0,param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],x=param$0[1];
          if(caml_call1(p,x))
           {var yes$0=[0,x,yes],yes=yes$0,param$0=l;continue}
          var no$0=[0,x,no],no=no$0,param$0=l;
          continue}
        var _AP_=rev(no);
        return [0,rev(yes),_AP_]}}
    function partition_map(p,param)
     {var left=0,right=0,param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],x=param$0[1],match=caml_call1(p,x);
          if(0 === match[0])
           {var v=match[1],left$0=[0,v,left],left=left$0,param$0=l;continue}
          var v$0=match[1],right$0=[0,v$0,right],right=right$0,param$0=l;
          continue}
        var _AO_=rev(right);
        return [0,rev(left),_AO_]}}
    function split(param)
     {if(param)
       {var
         l=param[2],
         match=param[1],
         y=match[2],
         x=match[1],
         match$0=split(l),
         ry=match$0[2],
         rx=match$0[1];
        return [0,[0,x,rx],[0,y,ry]]}
      return _p_}
    function combine(l1,l2)
     {if(l1)
       {if(l2)
         {var l2$0=l2[2],a2=l2[1],l1$0=l1[2],a1=l1[1];
          return [0,[0,a1,a2],combine(l1$0,l2$0)]}}
      else
       if(! l2)return 0;
      return invalid_arg(cst_List_combine)}
    function merge(cmp,l1,match)
     {if(l1)
       {if(match)
         {var t2=match[2],h2=match[1],t1=l1[2],h1=l1[1];
          return 0 < caml_call2(cmp,h1,h2)
                  ?[0,h2,merge(cmp,l1,t2)]
                  :[0,h1,merge(cmp,t1,match)]}
        return l1}
      return match}
    function fast_sort(cmp,l)
     {function rev_sort(n,l)
       {if(2 === n)
         {if(l)
           {var _AK_=l[2];
            if(_AK_)
             {var
               tl=_AK_[2],
               x2=_AK_[1],
               x1=l[1],
               s=0 < caml_call2(cmp,x1,x2)?[0,x1,[0,x2,0]]:[0,x2,[0,x1,0]];
              return [0,s,tl]}}}
        else
         if(3 === n && l)
          {var _AM_=l[2];
           if(_AM_)
            {var _AN_=_AM_[2];
             if(_AN_)
              {var
                tl$1=_AN_[2],
                x3=_AN_[1],
                x2$0=_AM_[1],
                x1$0=l[1],
                s$0=
                 0 < caml_call2(cmp,x1$0,x2$0)
                  ?0 < caml_call2(cmp,x2$0,x3)
                    ?[0,x1$0,[0,x2$0,[0,x3,0]]]
                    :0 < caml_call2(cmp,x1$0,x3)
                      ?[0,x1$0,[0,x3,[0,x2$0,0]]]
                      :[0,x3,[0,x1$0,[0,x2$0,0]]]
                  :0 < caml_call2(cmp,x1$0,x3)
                    ?[0,x2$0,[0,x1$0,[0,x3,0]]]
                    :0 < caml_call2(cmp,x2$0,x3)
                      ?[0,x2$0,[0,x3,[0,x1$0,0]]]
                      :[0,x3,[0,x2$0,[0,x1$0,0]]];
               return [0,s$0,tl$1]}}}
        var
         n1=n >> 1,
         n2=n - n1 | 0,
         match=sort(n1,l),
         l2$0=match[2],
         s1=match[1],
         match$0=sort(n2,l2$0),
         tl$0=match$0[2],
         s2=match$0[1],
         l1=s1,
         l2=s2,
         accu=0;
        for(;;)
         {if(l1)
           {if(l2)
             {var t2=l2[2],h2=l2[1],t1=l1[2],h1=l1[1];
              if(0 < caml_call2(cmp,h1,h2))
               {var accu$0=[0,h2,accu],l2=t2,accu=accu$0;continue}
              var accu$1=[0,h1,accu],l1=t1,accu=accu$1;
              continue}
            var _AL_=rev_append(l1,accu)}
          else
           var _AL_=rev_append(l2,accu);
          return [0,_AL_,tl$0]}}
      function sort(n,l)
       {if(2 === n)
         {if(l)
           {var _AG_=l[2];
            if(_AG_)
             {var
               tl=_AG_[2],
               x2=_AG_[1],
               x1=l[1],
               s=0 < caml_call2(cmp,x1,x2)?[0,x2,[0,x1,0]]:[0,x1,[0,x2,0]];
              return [0,s,tl]}}}
        else
         if(3 === n && l)
          {var _AI_=l[2];
           if(_AI_)
            {var _AJ_=_AI_[2];
             if(_AJ_)
              {var
                tl$1=_AJ_[2],
                x3=_AJ_[1],
                x2$0=_AI_[1],
                x1$0=l[1],
                s$0=
                 0 < caml_call2(cmp,x1$0,x2$0)
                  ?0 < caml_call2(cmp,x1$0,x3)
                    ?0 < caml_call2(cmp,x2$0,x3)
                      ?[0,x3,[0,x2$0,[0,x1$0,0]]]
                      :[0,x2$0,[0,x3,[0,x1$0,0]]]
                    :[0,x2$0,[0,x1$0,[0,x3,0]]]
                  :0 < caml_call2(cmp,x2$0,x3)
                    ?0 < caml_call2(cmp,x1$0,x3)
                      ?[0,x3,[0,x1$0,[0,x2$0,0]]]
                      :[0,x1$0,[0,x3,[0,x2$0,0]]]
                    :[0,x1$0,[0,x2$0,[0,x3,0]]];
               return [0,s$0,tl$1]}}}
        var
         n1=n >> 1,
         n2=n - n1 | 0,
         match=rev_sort(n1,l),
         l2$0=match[2],
         s1=match[1],
         match$0=rev_sort(n2,l2$0),
         tl$0=match$0[2],
         s2=match$0[1],
         l1=s1,
         l2=s2,
         accu=0;
        for(;;)
         {if(l1)
           {if(l2)
             {var t2=l2[2],h2=l2[1],t1=l1[2],h1=l1[1];
              if(0 < caml_call2(cmp,h1,h2))
               {var accu$0=[0,h1,accu],l1=t1,accu=accu$0;continue}
              var accu$1=[0,h2,accu],l2=t2,accu=accu$1;
              continue}
            var _AH_=rev_append(l1,accu)}
          else
           var _AH_=rev_append(l2,accu);
          return [0,_AH_,tl$0]}}
      var len=length(l);
      return 2 <= len?sort(len,l)[1]:l}
    function sort_uniq(cmp,l)
     {function rev_sort(n,l)
       {if(2 === n)
         {if(l)
           {var _Ax_=l[2];
            if(_Ax_)
             {var
               tl=_Ax_[2],
               x2=_Ax_[1],
               x1=l[1],
               c$0=caml_call2(cmp,x1,x2),
               s=0 === c$0?[0,x1,0]:0 < c$0?[0,x1,[0,x2,0]]:[0,x2,[0,x1,0]];
              return [0,s,tl]}}}
        else
         if(3 === n && l)
          {var _Az_=l[2];
           if(_Az_)
            {var _AA_=_Az_[2];
             if(_AA_)
              {var
                tl$1=_AA_[2],
                x3=_AA_[1],
                x2$0=_Az_[1],
                x1$0=l[1],
                c$1=caml_call2(cmp,x1$0,x2$0);
               if(0 === c$1)
                var
                 c$2=caml_call2(cmp,x2$0,x3),
                 _AB_=
                  0 === c$2
                   ?[0,x2$0,0]
                   :0 < c$2?[0,x2$0,[0,x3,0]]:[0,x3,[0,x2$0,0]],
                 s$0=_AB_;
               else
                if(0 < c$1)
                 {var c$3=caml_call2(cmp,x2$0,x3);
                  if(0 === c$3)
                   var _AC_=[0,x1$0,[0,x2$0,0]];
                  else
                   if(0 < c$3)
                    var _AC_=[0,x1$0,[0,x2$0,[0,x3,0]]];
                   else
                    var
                     c$4=caml_call2(cmp,x1$0,x3),
                     _AD_=
                      0 === c$4
                       ?[0,x1$0,[0,x2$0,0]]
                       :0 < c$4
                         ?[0,x1$0,[0,x3,[0,x2$0,0]]]
                         :[0,x3,[0,x1$0,[0,x2$0,0]]],
                     _AC_=_AD_;
                  var s$0=_AC_}
                else
                 {var c$5=caml_call2(cmp,x1$0,x3);
                  if(0 === c$5)
                   var _AE_=[0,x2$0,[0,x1$0,0]];
                  else
                   if(0 < c$5)
                    var _AE_=[0,x2$0,[0,x1$0,[0,x3,0]]];
                   else
                    var
                     c$6=caml_call2(cmp,x2$0,x3),
                     _AF_=
                      0 === c$6
                       ?[0,x2$0,[0,x1$0,0]]
                       :0 < c$6
                         ?[0,x2$0,[0,x3,[0,x1$0,0]]]
                         :[0,x3,[0,x2$0,[0,x1$0,0]]],
                     _AE_=_AF_;
                  var s$0=_AE_}
               return [0,s$0,tl$1]}}}
        var
         n1=n >> 1,
         n2=n - n1 | 0,
         match=sort(n1,l),
         l2$0=match[2],
         s1=match[1],
         match$0=sort(n2,l2$0),
         tl$0=match$0[2],
         s2=match$0[1],
         l1=s1,
         l2=s2,
         accu=0;
        for(;;)
         {if(l1)
           {if(l2)
             {var t2=l2[2],h2=l2[1],t1=l1[2],h1=l1[1],c=caml_call2(cmp,h1,h2);
              if(0 === c)
               {var accu$0=[0,h1,accu],l1=t1,l2=t2,accu=accu$0;continue}
              if(0 <= c){var accu$1=[0,h2,accu],l2=t2,accu=accu$1;continue}
              var accu$2=[0,h1,accu],l1=t1,accu=accu$2;
              continue}
            var _Ay_=rev_append(l1,accu)}
          else
           var _Ay_=rev_append(l2,accu);
          return [0,_Ay_,tl$0]}}
      function sort(n,l)
       {if(2 === n)
         {if(l)
           {var _Ao_=l[2];
            if(_Ao_)
             {var
               tl=_Ao_[2],
               x2=_Ao_[1],
               x1=l[1],
               c$0=caml_call2(cmp,x1,x2),
               s=0 === c$0?[0,x1,0]:0 <= c$0?[0,x2,[0,x1,0]]:[0,x1,[0,x2,0]];
              return [0,s,tl]}}}
        else
         if(3 === n && l)
          {var _Aq_=l[2];
           if(_Aq_)
            {var _Ar_=_Aq_[2];
             if(_Ar_)
              {var
                tl$1=_Ar_[2],
                x3=_Ar_[1],
                x2$0=_Aq_[1],
                x1$0=l[1],
                c$1=caml_call2(cmp,x1$0,x2$0);
               if(0 === c$1)
                var
                 c$2=caml_call2(cmp,x2$0,x3),
                 _As_=
                  0 === c$2
                   ?[0,x2$0,0]
                   :0 <= c$2?[0,x3,[0,x2$0,0]]:[0,x2$0,[0,x3,0]],
                 s$0=_As_;
               else
                if(0 <= c$1)
                 {var c$3=caml_call2(cmp,x1$0,x3);
                  if(0 === c$3)
                   var _At_=[0,x2$0,[0,x1$0,0]];
                  else
                   if(0 <= c$3)
                    var
                     c$4=caml_call2(cmp,x2$0,x3),
                     _Au_=
                      0 === c$4
                       ?[0,x2$0,[0,x1$0,0]]
                       :0 <= c$4
                         ?[0,x3,[0,x2$0,[0,x1$0,0]]]
                         :[0,x2$0,[0,x3,[0,x1$0,0]]],
                     _At_=_Au_;
                   else
                    var _At_=[0,x2$0,[0,x1$0,[0,x3,0]]];
                  var s$0=_At_}
                else
                 {var c$5=caml_call2(cmp,x2$0,x3);
                  if(0 === c$5)
                   var _Av_=[0,x1$0,[0,x2$0,0]];
                  else
                   if(0 <= c$5)
                    var
                     c$6=caml_call2(cmp,x1$0,x3),
                     _Aw_=
                      0 === c$6
                       ?[0,x1$0,[0,x2$0,0]]
                       :0 <= c$6
                         ?[0,x3,[0,x1$0,[0,x2$0,0]]]
                         :[0,x1$0,[0,x3,[0,x2$0,0]]],
                     _Av_=_Aw_;
                   else
                    var _Av_=[0,x1$0,[0,x2$0,[0,x3,0]]];
                  var s$0=_Av_}
               return [0,s$0,tl$1]}}}
        var
         n1=n >> 1,
         n2=n - n1 | 0,
         match=rev_sort(n1,l),
         l2$0=match[2],
         s1=match[1],
         match$0=rev_sort(n2,l2$0),
         tl$0=match$0[2],
         s2=match$0[1],
         l1=s1,
         l2=s2,
         accu=0;
        for(;;)
         {if(l1)
           {if(l2)
             {var t2=l2[2],h2=l2[1],t1=l1[2],h1=l1[1],c=caml_call2(cmp,h1,h2);
              if(0 === c)
               {var accu$0=[0,h1,accu],l1=t1,l2=t2,accu=accu$0;continue}
              if(0 < c){var accu$1=[0,h1,accu],l1=t1,accu=accu$1;continue}
              var accu$2=[0,h2,accu],l2=t2,accu=accu$2;
              continue}
            var _Ap_=rev_append(l1,accu)}
          else
           var _Ap_=rev_append(l2,accu);
          return [0,_Ap_,tl$0]}}
      var len=length(l);
      return 2 <= len?sort(len,l)[1]:l}
    function compare_lengths(l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0){var l2$1=l2$0[2],l1$1=l1$0[2],l1$0=l1$1,l2$0=l2$1;continue}
          return 1}
        return l2$0?-1:0}}
    function compare_length_with(l,n)
     {var l$0=l,n$0=n;
      for(;;)
       {if(l$0)
         {var l$1=l$0[2];
          if(0 < n$0){var n$1=n$0 - 1 | 0,l$0=l$1,n$0=n$1;continue}
          return 1}
        return 0 === n$0?0:0 < n$0?-1:1}}
    function equal$5(eq,l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var
             l2$1=l2$0[2],
             a2=l2$0[1],
             l1$1=l1$0[2],
             a1=l1$0[1],
             _An_=caml_call2(eq,a1,a2);
            if(_An_){var l1$0=l1$1,l2$0=l2$1;continue}
            return _An_}}
        else
         if(! l2$0)return 1;
        return 0}}
    function compare$5(cmp,l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {var _Al_=l1$0[2],_Am_=l1$0[1];
          if(l2$0)
           {var l2$1=l2$0[2],a2=l2$0[1],c=caml_call2(cmp,_Am_,a2);
            if(0 === c){var l1$0=_Al_,l2$0=l2$1;continue}
            return c}
          return 1}
        return l2$0?-1:0}}
    function to_seq$1(l)
     {function aux(l,param)
       {if(l)
         {var tail=l[2],x=l[1];
          return [0,x,function(_Ak_){return aux(tail,_Ak_)}]}
        return 0}
      return function(_Aj_){return aux(l,_Aj_)}}
    function of_seq(seq)
     {function direct(depth,seq)
       {if(0 === depth)
         {var _Ai_=0;
          return rev(fold_left(function(acc,x){return [0,x,acc]},_Ai_,seq))}
        var match=caml_call1(seq,0);
        if(match)
         {var next=match[2],x=match[1];
          return [0,x,direct(depth - 1 | 0,next)]}
        return 0}
      return direct(500,seq)}
    var
     include$0=
      [0,
       length,
       compare_lengths,
       compare_length_with,
       cons$0,
       hd,
       tl,
       nth,
       nth_opt,
       rev,
       init,
       append,
       rev_append,
       flatten,
       flatten,
       equal$5,
       compare$5,
       iter$2,
       iteri,
       map$3,
       mapi,
       rev_map,
       filter_map$0,
       concat_map,
       fold_left_map,
       fold_left$0,
       fold_right,
       iter2,
       map2,
       rev_map2,
       fold_left2,
       fold_right2,
       for_all,
       exists,
       for_all2,
       exists2,
       mem,
       memq,
       find,
       find_opt,
       find_map,
       find_all,
       find_all,
       filteri,
       partition,
       partition_map,
       assoc,
       assoc_opt,
       assq,
       assq_opt,
       mem_assoc,
       mem_assq,
       remove_assoc,
       remove_assq,
       split,
       combine,
       fast_sort,
       fast_sort,
       fast_sort,
       sort_uniq,
       merge,
       to_seq$1,
       of_seq];
    caml_register_global(768,include$0,"Stdlib__list");
    function make$0(n,c)
     {var s=caml_create_bytes(n);caml_fill_bytes(s,0,n,c);return s}
    function init$0(n,f)
     {var s=caml_create_bytes(n),_Ag_=n - 1 | 0,_Af_=0;
      if(! (_Ag_ < 0))
       {var i=_Af_;
        for(;;)
         {caml_bytes_unsafe_set(s,i,caml_call1(f,i));
          var _Ah_=i + 1 | 0;
          if(_Ag_ !== i){var i=_Ah_;continue}
          break}}
      return s}
    var empty$0=caml_create_bytes(0);
    function copy(s)
     {var len=caml_ml_bytes_length(s),r=caml_create_bytes(len);
      caml_blit_bytes(s,0,r,0,len);
      return r}
    function to_string$1(b){return caml_string_of_bytes(copy(b))}
    function of_string(s){return copy(caml_bytes_of_string(s))}
    function sub(s,ofs,len)
     {if
       (0 <= ofs && 0 <= len && ! ((caml_ml_bytes_length(s) - len | 0) < ofs))
       {var r=caml_create_bytes(len);caml_blit_bytes(s,ofs,r,0,len);return r}
      return invalid_arg(cst_String_sub_Bytes_sub)}
    function sub_string(b,ofs,len)
     {return caml_string_of_bytes(sub(b,ofs,len))}
    function symbol$1(a,b)
     {var c=a + b | 0,_Ae_=b < 0?1:0,match=c < 0?1:0,switch$0=0;
      if(a < 0)
       {if(_Ae_ && ! match)switch$0 = 1}
      else
       if(! _Ae_ && match)switch$0 = 1;
      return switch$0?invalid_arg(cst_Bytes_extend):c}
    function extend(s,left,right)
     {var
       len=symbol$1(symbol$1(caml_ml_bytes_length(s),left),right),
       r=caml_create_bytes(len);
      if(0 <= left)
       var dstoff=left,srcoff=0;
      else
       var dstoff=0,srcoff=- left | 0;
      var cpylen=min(caml_ml_bytes_length(s) - srcoff | 0,len - dstoff | 0);
      if(0 < cpylen)caml_blit_bytes(s,srcoff,r,dstoff,cpylen);
      return r}
    function fill(s,ofs,len,c)
     {if
       (0 <= ofs && 0 <= len && ! ((caml_ml_bytes_length(s) - len | 0) < ofs))
       return caml_fill_bytes(s,ofs,len,c);
      return invalid_arg(cst_String_fill_Bytes_fill)}
    function blit(s1,ofs1,s2,ofs2,len)
     {if
       (0
        <=
        len
        &&
        0
        <=
        ofs1
        &&
        !
        ((caml_ml_bytes_length(s1) - len | 0) < ofs1)
        &&
        0
        <=
        ofs2
        &&
        !
        ((caml_ml_bytes_length(s2) - len | 0) < ofs2))
       return caml_blit_bytes(s1,ofs1,s2,ofs2,len);
      return invalid_arg(cst_Bytes_blit)}
    function blit$0(s1,ofs1,s2,ofs2,len)
     {if
       (0
        <=
        len
        &&
        0
        <=
        ofs1
        &&
        !
        ((caml_ml_string_length(s1) - len | 0) < ofs1)
        &&
        0
        <=
        ofs2
        &&
        !
        ((caml_ml_bytes_length(s2) - len | 0) < ofs2))
       return caml_blit_string(s1,ofs1,s2,ofs2,len);
      return invalid_arg(cst_String_blit_Bytes_blit_str)}
    function iter$3(f,a)
     {var _Ac_=caml_ml_bytes_length(a) - 1 | 0,_Ab_=0;
      if(! (_Ac_ < 0))
       {var i=_Ab_;
        for(;;)
         {caml_call1(f,caml_bytes_unsafe_get(a,i));
          var _Ad_=i + 1 | 0;
          if(_Ac_ !== i){var i=_Ad_;continue}
          break}}
      return 0}
    function iteri$0(f,a)
     {var _z$_=caml_ml_bytes_length(a) - 1 | 0,_z__=0;
      if(! (_z$_ < 0))
       {var i=_z__;
        for(;;)
         {caml_call2(f,i,caml_bytes_unsafe_get(a,i));
          var _Aa_=i + 1 | 0;
          if(_z$_ !== i){var i=_Aa_;continue}
          break}}
      return 0}
    function concat(sep,l)
     {if(l)
       {var seplen=caml_ml_bytes_length(sep),acc=0,param=l,pos$1=0;
        for(;;)
         {if(param)
           {var _z7_=param[1];
            if(param[2])
             {var
               tl=param[2],
               x=(caml_ml_bytes_length(_z7_) + seplen | 0) + acc | 0,
               acc$0=acc <= x?x:invalid_arg(cst_Bytes_concat),
               acc=acc$0,
               param=tl;
              continue}
            var _z9_=caml_ml_bytes_length(_z7_) + acc | 0}
          else
           var _z9_=acc;
          var dst=caml_create_bytes(_z9_),pos=pos$1,param$0=l;
          for(;;)
           {if(param$0)
             {var _z8_=param$0[1];
              if(param$0[2])
               {var tl$0=param$0[2];
                caml_blit_bytes(_z8_,0,dst,pos,caml_ml_bytes_length(_z8_));
                caml_blit_bytes
                 (sep,0,dst,pos + caml_ml_bytes_length(_z8_) | 0,seplen);
                var
                 pos$0=(pos + caml_ml_bytes_length(_z8_) | 0) + seplen | 0,
                 pos=pos$0,
                 param$0=tl$0;
                continue}
              caml_blit_bytes(_z8_,0,dst,pos,caml_ml_bytes_length(_z8_));
              return dst}
            return dst}}}
      return empty$0}
    function cat(s1,s2)
     {var
       l1=caml_ml_bytes_length(s1),
       l2=caml_ml_bytes_length(s2),
       r=caml_create_bytes(l1 + l2 | 0);
      caml_blit_bytes(s1,0,r,0,l1);
      caml_blit_bytes(s2,0,r,l1,l2);
      return r}
    function is_space(param)
     {var _z6_=param - 9 | 0,switch$0=0;
      if(4 < _z6_ >>> 0)
       {if(23 === _z6_)switch$0 = 1}
      else
       if(2 !== _z6_)switch$0 = 1;
      return switch$0?1:0}
    function trim(s)
     {var len=caml_ml_bytes_length(s),i=[0,0];
      for(;;)
       {if(i[1] < len && is_space(caml_bytes_unsafe_get(s,i[1])))
         {i[1]++;continue}
        var j=[0,len - 1 | 0];
        for(;;)
         {if(i[1] <= j[1] && is_space(caml_bytes_unsafe_get(s,j[1])))
           {j[1] += -1;continue}
          return i[1] <= j[1]?sub(s,i[1],(j[1] - i[1] | 0) + 1 | 0):empty$0}}}
    function escaped$0(s)
     {var n=[0,0],_zZ_=caml_ml_bytes_length(s) - 1 | 0,_zY_=0;
      if(! (_zZ_ < 0))
       {var i$0=_zY_;
        for(;;)
         {var match=caml_bytes_unsafe_get(s,i$0),switch$0=0;
          if(32 <= match)
           {var _z3_=match - 34 | 0,switch$1=0;
            if(58 < _z3_ >>> 0)
             {if(93 <= _z3_)switch$1 = 1}
            else
             if(56 < (_z3_ - 1 | 0) >>> 0){switch$0 = 1;switch$1 = 1}
            if(! switch$1){var _z4_=1;switch$0 = 2}}
          else
           if(11 <= match)
            {if(13 === match)switch$0 = 1}
           else
            if(8 <= match)switch$0 = 1;
          switch(switch$0){case 0:var _z4_=4;break;case 1:var _z4_=2;break}
          n[1] = n[1] + _z4_ | 0;
          var _z5_=i$0 + 1 | 0;
          if(_zZ_ !== i$0){var i$0=_z5_;continue}
          break}}
      if(n[1] === caml_ml_bytes_length(s))return copy(s);
      var s$0=caml_create_bytes(n[1]);
      n[1] = 0;
      var _z1_=caml_ml_bytes_length(s) - 1 | 0,_z0_=0;
      if(! (_z1_ < 0))
       {var i=_z0_;
        for(;;)
         {var c=caml_bytes_unsafe_get(s,i),switch$2=0;
          if(35 <= c)
           if(92 === c)
            switch$2 = 2;
           else
            if(127 <= c)switch$2 = 1;else switch$2 = 3;
          else
           if(32 <= c)
            if(34 <= c)switch$2 = 2;else switch$2 = 3;
           else
            if(14 <= c)
             switch$2 = 1;
            else
             switch(c)
              {case 8:
                caml_bytes_unsafe_set(s$0,n[1],92);
                n[1]++;
                caml_bytes_unsafe_set(s$0,n[1],98);
                break;
               case 9:
                caml_bytes_unsafe_set(s$0,n[1],92);
                n[1]++;
                caml_bytes_unsafe_set(s$0,n[1],116);
                break;
               case 10:
                caml_bytes_unsafe_set(s$0,n[1],92);
                n[1]++;
                caml_bytes_unsafe_set(s$0,n[1],110);
                break;
               case 13:
                caml_bytes_unsafe_set(s$0,n[1],92);
                n[1]++;
                caml_bytes_unsafe_set(s$0,n[1],114);
                break;
               default:switch$2 = 1}
          switch(switch$2)
           {case 1:
             caml_bytes_unsafe_set(s$0,n[1],92);
             n[1]++;
             caml_bytes_unsafe_set(s$0,n[1],48 + (c / 100 | 0) | 0);
             n[1]++;
             caml_bytes_unsafe_set(s$0,n[1],48 + ((c / 10 | 0) % 10 | 0) | 0);
             n[1]++;
             caml_bytes_unsafe_set(s$0,n[1],48 + (c % 10 | 0) | 0);
             break;
            case 2:
             caml_bytes_unsafe_set(s$0,n[1],92);
             n[1]++;
             caml_bytes_unsafe_set(s$0,n[1],c);
             break;
            case 3:caml_bytes_unsafe_set(s$0,n[1],c);break
            }
          n[1]++;
          var _z2_=i + 1 | 0;
          if(_z1_ !== i){var i=_z2_;continue}
          break}}
      return s$0}
    function map$4(f,s)
     {var l=caml_ml_bytes_length(s);
      if(0 === l)return s;
      var r=caml_create_bytes(l),_zW_=l - 1 | 0,_zV_=0;
      if(! (_zW_ < 0))
       {var i=_zV_;
        for(;;)
         {caml_bytes_unsafe_set(r,i,caml_call1(f,caml_bytes_unsafe_get(s,i)));
          var _zX_=i + 1 | 0;
          if(_zW_ !== i){var i=_zX_;continue}
          break}}
      return r}
    function mapi$0(f,s)
     {var l=caml_ml_bytes_length(s);
      if(0 === l)return s;
      var r=caml_create_bytes(l),_zT_=l - 1 | 0,_zS_=0;
      if(! (_zT_ < 0))
       {var i=_zS_;
        for(;;)
         {caml_bytes_unsafe_set
           (r,i,caml_call2(f,i,caml_bytes_unsafe_get(s,i)));
          var _zU_=i + 1 | 0;
          if(_zT_ !== i){var i=_zU_;continue}
          break}}
      return r}
    function uppercase_ascii$0(s){return map$4(uppercase_ascii,s)}
    function lowercase_ascii$0(s){return map$4(lowercase_ascii,s)}
    function apply1(f,s)
     {if(0 === caml_ml_bytes_length(s))return s;
      var r=copy(s);
      caml_bytes_unsafe_set(r,0,caml_call1(f,caml_bytes_unsafe_get(s,0)));
      return r}
    function capitalize_ascii(s){return apply1(uppercase_ascii,s)}
    function uncapitalize_ascii(s){return apply1(lowercase_ascii,s)}
    function index_rec(s,lim,i,c)
     {var i$0=i;
      for(;;)
       {if(lim <= i$0)throw Not_found;
        if(caml_bytes_unsafe_get(s,i$0) === c)return i$0;
        var i$1=i$0 + 1 | 0,i$0=i$1;
        continue}}
    function index(s,c){return index_rec(s,caml_ml_bytes_length(s),0,c)}
    function index_rec_opt(s,lim,i,c)
     {var i$0=i;
      for(;;)
       {if(lim <= i$0)return 0;
        if(caml_bytes_unsafe_get(s,i$0) === c)return [0,i$0];
        var i$1=i$0 + 1 | 0,i$0=i$1;
        continue}}
    function index_opt(s,c)
     {return index_rec_opt(s,caml_ml_bytes_length(s),0,c)}
    function index_from(s,i,c)
     {var l=caml_ml_bytes_length(s);
      if(0 <= i && ! (l < i))return index_rec(s,l,i,c);
      return invalid_arg(cst_String_index_from_Bytes_in)}
    function index_from_opt(s,i,c)
     {var l=caml_ml_bytes_length(s);
      if(0 <= i && ! (l < i))return index_rec_opt(s,l,i,c);
      return invalid_arg(cst_String_index_from_opt_Byte)}
    function rindex_rec(s,i,c)
     {var i$0=i;
      for(;;)
       {if(0 <= i$0)
         {if(caml_bytes_unsafe_get(s,i$0) === c)return i$0;
          var i$1=i$0 - 1 | 0,i$0=i$1;
          continue}
        throw Not_found}}
    function rindex(s,c)
     {return rindex_rec(s,caml_ml_bytes_length(s) - 1 | 0,c)}
    function rindex_from(s,i,c)
     {if(-1 <= i && ! (caml_ml_bytes_length(s) <= i))return rindex_rec(s,i,c);
      return invalid_arg(cst_String_rindex_from_Bytes_r)}
    function rindex_rec_opt(s,i,c)
     {var i$0=i;
      for(;;)
       {if(0 <= i$0)
         {if(caml_bytes_unsafe_get(s,i$0) === c)return [0,i$0];
          var i$1=i$0 - 1 | 0,i$0=i$1;
          continue}
        return 0}}
    function rindex_opt(s,c)
     {return rindex_rec_opt(s,caml_ml_bytes_length(s) - 1 | 0,c)}
    function rindex_from_opt(s,i,c)
     {if(-1 <= i && ! (caml_ml_bytes_length(s) <= i))
       return rindex_rec_opt(s,i,c);
      return invalid_arg(cst_String_rindex_from_opt_Byt)}
    function contains_from(s,i,c)
     {var l=caml_ml_bytes_length(s);
      if(0 <= i && ! (l < i))
       try
        {index_rec(s,l,i,c);var _zQ_=1;return _zQ_}
       catch(_zR_)
        {_zR_ = caml_wrap_exception(_zR_);
         if(_zR_ === Not_found)return 0;
         throw _zR_}
      return invalid_arg(cst_String_contains_from_Bytes)}
    function contains(s,c){return contains_from(s,0,c)}
    function rcontains_from(s,i,c)
     {if(0 <= i && ! (caml_ml_bytes_length(s) <= i))
       try
        {rindex_rec(s,i,c);var _zO_=1;return _zO_}
       catch(_zP_)
        {_zP_ = caml_wrap_exception(_zP_);
         if(_zP_ === Not_found)return 0;
         throw _zP_}
      return invalid_arg(cst_String_rcontains_from_Byte)}
    function compare$6(x,y){return runtime.caml_bytes_compare(x,y)}
    function uppercase$0(s){return map$4(uppercase,s)}
    function lowercase$0(s){return map$4(lowercase,s)}
    function capitalize(s){return apply1(uppercase,s)}
    function uncapitalize(s){return apply1(lowercase,s)}
    function to_seq$2(s)
     {function aux(i,param)
       {if(i === caml_ml_bytes_length(s))return 0;
        var x=caml_bytes_get(s,i),_zM_=i + 1 | 0;
        return [0,x,function(_zN_){return aux(_zM_,_zN_)}]}
      var _zK_=0;
      return function(_zL_){return aux(_zK_,_zL_)}}
    function to_seqi(s)
     {function aux(i,param)
       {if(i === caml_ml_bytes_length(s))return 0;
        var x=caml_bytes_get(s,i),_zI_=i + 1 | 0;
        return [0,[0,i,x],function(_zJ_){return aux(_zI_,_zJ_)}]}
      var _zG_=0;
      return function(_zH_){return aux(_zG_,_zH_)}}
    function of_seq$0(i)
     {var n=[0,0],buf=[0,make$0(256,0)];
      iter
       (function(c)
         {if(n[1] === caml_ml_bytes_length(buf[1]))
           {var
             new_len=
              min(2 * caml_ml_bytes_length(buf[1]) | 0,max_string_length);
            if(caml_ml_bytes_length(buf[1]) === new_len)
             failwith(cst_Bytes_of_seq_cannot_grow_b);
            var new_buf=make$0(new_len,0);
            blit(buf[1],0,new_buf,0,n[1]);
            buf[1] = new_buf}
          caml_bytes_set(buf[1],n[1],c);
          n[1]++;
          return 0},
        i);
      return sub(buf[1],0,n[1])}
    function get_int8(b,i){return caml_bytes_get(b,i) << 24 >> 24}
    function get_uint16_le(b,i){return caml_bytes_get16(b,i)}
    function get_uint16_be(b,i){return caml_bswap16(caml_bytes_get16(b,i))}
    function get_int16_ne(b,i){return caml_bytes_get16(b,i) << 16 >> 16}
    function get_int16_le(b,i){return caml_bytes_get16(b,i) << 16 >> 16}
    function get_int16_be(b,i){return get_uint16_be(b,i) << 16 >> 16}
    function get_int32_le(b,i){return caml_bytes_get32(b,i)}
    function get_int32_be(b,i){return caml_int32_bswap(caml_bytes_get32(b,i))}
    function get_int64_le(b,i){return caml_bytes_get64(b,i)}
    function get_int64_be(b,i){return caml_int64_bswap(caml_bytes_get64(b,i))}
    function set_int16_le(b,i,x){return caml_bytes_set16(b,i,x)}
    function set_int16_be(b,i,x){return caml_bytes_set16(b,i,caml_bswap16(x))}
    function set_int32_le(b,i,x){return caml_bytes_set32(b,i,x)}
    function set_int32_be(b,i,x)
     {return caml_bytes_set32(b,i,caml_int32_bswap(x))}
    function set_int64_le(b,i,x){return caml_bytes_set64(b,i,x)}
    function set_int64_be(b,i,x)
     {return caml_bytes_set64(b,i,caml_int64_bswap(x))}
    var
     set_uint8=caml_bytes_set,
     set_uint16_ne=caml_bytes_set16,
     set_int64_ne=caml_bytes_set64,
     set_int32_ne=caml_bytes_set32,
     set_int16_ne=caml_bytes_set16,
     set_int8=caml_bytes_set,
     get_int64_ne=caml_bytes_get64,
     get_int32_ne=caml_bytes_get32,
     get_uint16_ne=caml_bytes_get16,
     get_uint8=caml_bytes_get,
     unsafe_of_string=caml_bytes_of_string,
     unsafe_to_string=caml_string_of_bytes,
     equal$6=runtime.caml_bytes_equal,
     include$1=
      [0,
       make$0,
       init$0,
       empty$0,
       copy,
       of_string,
       to_string$1,
       sub,
       sub_string,
       extend,
       fill,
       blit,
       blit$0,
       concat,
       cat,
       iter$3,
       iteri$0,
       map$4,
       mapi$0,
       trim,
       escaped$0,
       index,
       index_opt,
       rindex,
       rindex_opt,
       index_from,
       index_from_opt,
       rindex_from,
       rindex_from_opt,
       contains,
       contains_from,
       rcontains_from,
       uppercase$0,
       lowercase$0,
       capitalize,
       uncapitalize,
       uppercase_ascii$0,
       lowercase_ascii$0,
       capitalize_ascii,
       uncapitalize_ascii,
       compare$6,
       equal$6,
       unsafe_to_string,
       unsafe_of_string,
       to_seq$2,
       to_seqi,
       of_seq$0,
       get_uint8,
       get_int8,
       get_uint16_ne,
       get_uint16_be,
       get_uint16_le,
       get_int16_ne,
       get_int16_be,
       get_int16_le,
       get_int32_ne,
       get_int32_be,
       get_int32_le,
       get_int64_ne,
       get_int64_be,
       get_int64_le,
       set_uint8,
       set_int8,
       set_uint16_ne,
       set_int16_be,
       set_int16_le,
       set_int16_ne,
       set_int16_be,
       set_int16_le,
       set_int32_ne,
       set_int32_be,
       set_int32_le,
       set_int64_ne,
       set_int64_be,
       set_int64_le];
    caml_register_global(769,include$1,"Stdlib__bytes");
    function make$1(n,c){return caml_string_of_bytes(make$0(n,c))}
    function init$1(n,f){return caml_string_of_bytes(init$0(n,f))}
    function copy$0(s)
     {return caml_string_of_bytes(copy(caml_bytes_of_string(s)))}
    function sub$0(s,ofs,len)
     {return caml_string_of_bytes(sub(caml_bytes_of_string(s),ofs,len))}
    function concat$0(sep,l)
     {if(l)
       {var seplen=caml_ml_string_length(sep),acc=0,param=l,pos$1=0;
        for(;;)
         {if(param)
           {var _zD_=param[1];
            if(param[2])
             {var
               tl=param[2],
               x=(caml_ml_string_length(_zD_) + seplen | 0) + acc | 0,
               acc$0=acc <= x?x:invalid_arg(cst_String_concat),
               acc=acc$0,
               param=tl;
              continue}
            var _zF_=caml_ml_string_length(_zD_) + acc | 0}
          else
           var _zF_=acc;
          var dst=caml_create_bytes(_zF_),pos=pos$1,param$0=l;
          for(;;)
           {if(param$0)
             {var _zE_=param$0[1];
              if(param$0[2])
               {var tl$0=param$0[2];
                caml_blit_string(_zE_,0,dst,pos,caml_ml_string_length(_zE_));
                caml_blit_string
                 (sep,0,dst,pos + caml_ml_string_length(_zE_) | 0,seplen);
                var
                 pos$0=(pos + caml_ml_string_length(_zE_) | 0) + seplen | 0,
                 pos=pos$0,
                 param$0=tl$0;
                continue}
              caml_blit_string(_zE_,0,dst,pos,caml_ml_string_length(_zE_))}
            return caml_string_of_bytes(dst)}}}
      return cst$3}
    function iter$4(f,s)
     {var _zB_=caml_ml_string_length(s) - 1 | 0,_zA_=0;
      if(! (_zB_ < 0))
       {var i=_zA_;
        for(;;)
         {caml_call1(f,caml_string_unsafe_get(s,i));
          var _zC_=i + 1 | 0;
          if(_zB_ !== i){var i=_zC_;continue}
          break}}
      return 0}
    function iteri$1(f,s)
     {var _zy_=caml_ml_string_length(s) - 1 | 0,_zx_=0;
      if(! (_zy_ < 0))
       {var i=_zx_;
        for(;;)
         {caml_call2(f,i,caml_string_unsafe_get(s,i));
          var _zz_=i + 1 | 0;
          if(_zy_ !== i){var i=_zz_;continue}
          break}}
      return 0}
    function map$5(f,s)
     {return caml_string_of_bytes(map$4(f,caml_bytes_of_string(s)))}
    function mapi$1(f,s)
     {return caml_string_of_bytes(mapi$0(f,caml_bytes_of_string(s)))}
    function is_space$0(param)
     {var _zw_=param - 9 | 0,switch$0=0;
      if(4 < _zw_ >>> 0)
       {if(23 === _zw_)switch$0 = 1}
      else
       if(2 !== _zw_)switch$0 = 1;
      return switch$0?1:0}
    function trim$0(s)
     {if(caml_string_equal(s,cst$4))return s;
      if
       (!
        is_space$0(caml_string_unsafe_get(s,0))
        &&
        !
        is_space$0(caml_string_unsafe_get(s,caml_ml_string_length(s) - 1 | 0)))
       return s;
      return caml_string_of_bytes(trim(caml_bytes_of_string(s)))}
    function escaped$1(s)
     {var n=caml_ml_string_length(s),i=0;
      for(;;)
       {if(n <= i)return s;
        var match=caml_string_unsafe_get(s,i),_zv_=match - 32 | 0,switch$0=0;
        if(59 < _zv_ >>> 0)
         {if(33 < (_zv_ - 61 | 0) >>> 0)switch$0 = 1}
        else
         if(2 === _zv_)switch$0 = 1;
        if(switch$0)
         return caml_string_of_bytes(escaped$0(caml_bytes_of_string(s)));
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    function index_rec$0(s,lim,i,c)
     {var i$0=i;
      for(;;)
       {if(lim <= i$0)throw Not_found;
        if(caml_string_unsafe_get(s,i$0) === c)return i$0;
        var i$1=i$0 + 1 | 0,i$0=i$1;
        continue}}
    function index$0(s,c){return index_rec$0(s,caml_ml_string_length(s),0,c)}
    function index_rec_opt$0(s,lim,i,c)
     {var i$0=i;
      for(;;)
       {if(lim <= i$0)return 0;
        if(caml_string_unsafe_get(s,i$0) === c)return [0,i$0];
        var i$1=i$0 + 1 | 0,i$0=i$1;
        continue}}
    function index_opt$0(s,c)
     {return index_rec_opt$0(s,caml_ml_string_length(s),0,c)}
    function index_from$0(s,i,c)
     {var l=caml_ml_string_length(s);
      if(0 <= i && ! (l < i))return index_rec$0(s,l,i,c);
      return invalid_arg(cst_String_index_from_Bytes_in$0)}
    function index_from_opt$0(s,i,c)
     {var l=caml_ml_string_length(s);
      if(0 <= i && ! (l < i))return index_rec_opt$0(s,l,i,c);
      return invalid_arg(cst_String_index_from_opt_Byte$0)}
    function rindex_rec$0(s,i,c)
     {var i$0=i;
      for(;;)
       {if(0 <= i$0)
         {if(caml_string_unsafe_get(s,i$0) === c)return i$0;
          var i$1=i$0 - 1 | 0,i$0=i$1;
          continue}
        throw Not_found}}
    function rindex$0(s,c)
     {return rindex_rec$0(s,caml_ml_string_length(s) - 1 | 0,c)}
    function rindex_from$0(s,i,c)
     {if(-1 <= i && ! (caml_ml_string_length(s) <= i))
       return rindex_rec$0(s,i,c);
      return invalid_arg(cst_String_rindex_from_Bytes_r$0)}
    function rindex_rec_opt$0(s,i,c)
     {var i$0=i;
      for(;;)
       {if(0 <= i$0)
         {if(caml_string_unsafe_get(s,i$0) === c)return [0,i$0];
          var i$1=i$0 - 1 | 0,i$0=i$1;
          continue}
        return 0}}
    function rindex_opt$0(s,c)
     {return rindex_rec_opt$0(s,caml_ml_string_length(s) - 1 | 0,c)}
    function rindex_from_opt$0(s,i,c)
     {if(-1 <= i && ! (caml_ml_string_length(s) <= i))
       return rindex_rec_opt$0(s,i,c);
      return invalid_arg(cst_String_rindex_from_opt_Byt$0)}
    function contains_from$0(s,i,c)
     {var l=caml_ml_string_length(s);
      if(0 <= i && ! (l < i))
       try
        {index_rec$0(s,l,i,c);var _zt_=1;return _zt_}
       catch(_zu_)
        {_zu_ = caml_wrap_exception(_zu_);
         if(_zu_ === Not_found)return 0;
         throw _zu_}
      return invalid_arg(cst_String_contains_from_Bytes$0)}
    function contains$0(s,c){return contains_from$0(s,0,c)}
    function rcontains_from$0(s,i,c)
     {if(0 <= i && ! (caml_ml_string_length(s) <= i))
       try
        {rindex_rec$0(s,i,c);var _zr_=1;return _zr_}
       catch(_zs_)
        {_zs_ = caml_wrap_exception(_zs_);
         if(_zs_ === Not_found)return 0;
         throw _zs_}
      return invalid_arg(cst_String_rcontains_from_Byte$0)}
    function uppercase_ascii$1(s)
     {return caml_string_of_bytes(uppercase_ascii$0(caml_bytes_of_string(s)))}
    function lowercase_ascii$1(s)
     {return caml_string_of_bytes(lowercase_ascii$0(caml_bytes_of_string(s)))}
    function capitalize_ascii$0(s)
     {return caml_string_of_bytes(capitalize_ascii(caml_bytes_of_string(s)))}
    function uncapitalize_ascii$0(s)
     {return caml_string_of_bytes(uncapitalize_ascii(caml_bytes_of_string(s)))}
    function split_on_char(sep,s)
     {var
       r=[0,0],
       j=[0,caml_ml_string_length(s)],
       _zn_=caml_ml_string_length(s) - 1 | 0;
      if(! (_zn_ < 0))
       {var i=_zn_;
        for(;;)
         {if(caml_string_unsafe_get(s,i) === sep)
           {var _zp_=r[1];
            r[1] = [0,sub$0(s,i + 1 | 0,(j[1] - i | 0) - 1 | 0),_zp_];
            j[1] = i}
          var _zq_=i - 1 | 0;
          if(0 !== i){var i=_zq_;continue}
          break}}
      var _zo_=r[1];
      return [0,sub$0(s,0,j[1]),_zo_]}
    function uppercase$1(s)
     {return caml_string_of_bytes(uppercase$0(caml_bytes_of_string(s)))}
    function lowercase$1(s)
     {return caml_string_of_bytes(lowercase$0(caml_bytes_of_string(s)))}
    function capitalize$0(s)
     {return caml_string_of_bytes(capitalize(caml_bytes_of_string(s)))}
    function uncapitalize$0(s)
     {return caml_string_of_bytes(uncapitalize(caml_bytes_of_string(s)))}
    function compare$7(x,y){return caml_string_compare(x,y)}
    function to_seq$3(s){return to_seq$2(caml_bytes_of_string(s))}
    function to_seqi$0(s){return to_seqi(caml_bytes_of_string(s))}
    function of_seq$1(g){return caml_string_of_bytes(of_seq$0(g))}
    var
     equal$7=caml_string_equal,
     include$2=
      [0,
       make$1,
       init$1,
       concat$0,
       equal$7,
       compare$7,
       contains_from$0,
       rcontains_from$0,
       contains$0,
       sub$0,
       split_on_char,
       map$5,
       mapi$1,
       trim$0,
       escaped$1,
       uppercase_ascii$1,
       lowercase_ascii$1,
       capitalize_ascii$0,
       uncapitalize_ascii$0,
       iter$4,
       iteri$1,
       index_from$0,
       index_from_opt$0,
       rindex_from$0,
       rindex_from_opt$0,
       index$0,
       index_opt$0,
       rindex$0,
       rindex_opt$0,
       to_seq$3,
       to_seqi$0,
       of_seq$1,
       blit$0,
       copy$0,
       fill,
       uppercase$1,
       lowercase$1,
       capitalize$0,
       uncapitalize$0];
    caml_register_global(770,include$2,"Stdlib__string");
    function equal$8(param,_zm_){return 1}
    function compare$8(param,_zl_){return 0}
    function to_string$2(param){return cst$5}
    var Stdlib_unit=[0,equal$8,compare$8,to_string$2];
    caml_register_global(771,Stdlib_unit,"Stdlib__unit");
    function to_buffer(buff,ofs,len,v,flags)
     {if
       (0
        <=
        ofs
        &&
        0
        <=
        len
        &&
        !
        ((caml_ml_bytes_length(buff) - len | 0) < ofs))
       return runtime.caml_output_value_to_buffer(buff,ofs,len,v,flags);
      return invalid_arg(cst_Marshal_to_buffer_substrin)}
    var header_size=20;
    function data_size(buff,ofs)
     {if(0 <= ofs && ! ((caml_ml_bytes_length(buff) - 20 | 0) < ofs))
       return caml_marshal_data_size(buff,ofs);
      return invalid_arg(cst_Marshal_data_size)}
    function total_size(buff,ofs){return 20 + data_size(buff,ofs) | 0}
    function from_bytes(buff,ofs)
     {if(0 <= ofs && ! ((caml_ml_bytes_length(buff) - 20 | 0) < ofs))
       {var len=caml_marshal_data_size(buff,ofs);
        return (caml_ml_bytes_length(buff) - (20 + len | 0) | 0) < ofs
                ?invalid_arg(cst_Marshal_from_bytes$0)
                :runtime.caml_input_value_from_bytes(buff,ofs)}
      return invalid_arg(cst_Marshal_from_bytes)}
    function from_string(buff,ofs)
     {return from_bytes(caml_bytes_of_string(buff),ofs)}
    var
     Stdlib_marshal=
      [0,
       caml_output_value,
       to_buffer,
       caml_input_value,
       from_bytes,
       from_string,
       header_size,
       data_size,
       total_size];
    caml_register_global(772,Stdlib_marshal,"Stdlib__marshal");
    function is_block(a){return 1 - (typeof a === "number"?1:0)}
    function double_field(x,i){return caml_array_get(x,i)}
    function set_double_field(x,i,v){return caml_array_set(x,i,v)}
    function marshal(obj){return runtime.caml_output_value_to_bytes(obj,0)}
    function unmarshal(str,pos)
     {var _zk_=pos + total_size(str,pos) | 0;
      return [0,from_bytes(str,pos),_zk_]}
    var
     first_non_constant_constructor=0,
     last_non_constant_constructor_=245,
     lazy_tag=246,
     closure_tag=247,
     object_tag=248,
     infix_tag=249,
     forward_tag=250,
     no_scan_tag=251,
     abstract_tag=251,
     string_tag=252,
     double_tag=253,
     double_array_tag=254,
     custom_tag=255,
     int_tag=1000,
     out_of_heap_tag=1001,
     unaligned_tag=1002;
    function info(obj)
     {if(caml_obj_tag(obj) === 247)
       {var
         info=runtime.caml_obj_raw_field(obj,1),
         arity=info >> 24,
         start_env=info << 8 >>> 9 | 0;
        return [0,arity,start_env]}
      throw [0,Assert_failure,_q_]}
    function of_val(x)
     {var switch$0=0;
      if(is_block(x) && caml_obj_tag(x) !== 248 && 1 <= x.length - 1)
       {var slot=x[1];switch$0 = 1}
      if(! switch$0)var slot=x;
      var switch$1=0;
      if(is_block(slot) && caml_obj_tag(slot) === 248)
       {var name=slot[1];switch$1 = 1}
      if(! switch$1)var name=invalid_arg(cst_Obj_extension_constructor$0);
      return caml_obj_tag(name) === 252
              ?slot
              :invalid_arg(cst_Obj_extension_constructor)}
    function name(slot){return slot[1]}
    function id(slot){return slot[2]}
    var
     Extension_constructor=[0,of_val,name,id],
     extension_constructor=Extension_constructor[1],
     extension_name=Extension_constructor[2],
     extension_id=Extension_constructor[3],
     max_ephe_length=max_array_length - 2 | 0;
    function create(l)
     {var _zi_=0 <= l?1:0,_zj_=_zi_?l <= max_ephe_length?1:0:_zi_;
      if(1 - _zj_)invalid_arg(cst_Obj_Ephemeron_create);
      return runtime.caml_ephe_create(l)}
    function length$0(x){return x.length - 1 - 2 | 0}
    function raise_if_invalid_offset(e,o,msg)
     {var _zf_=0 <= o?1:0,_zg_=_zf_?o < length$0(e)?1:0:_zf_,_zh_=1 - _zg_;
      return _zh_?invalid_arg(msg):_zh_}
    function get_key(e,o)
     {raise_if_invalid_offset(e,o,cst_Obj_Ephemeron_get_key);
      return runtime.caml_ephe_get_key(e,o)}
    function get_key_copy(e,o)
     {raise_if_invalid_offset(e,o,cst_Obj_Ephemeron_get_key_copy);
      return runtime.caml_ephe_get_key_copy(e,o)}
    function set_key(e,o,x)
     {raise_if_invalid_offset(e,o,cst_Obj_Ephemeron_set_key);
      return caml_ephe_set_key(e,o,x)}
    function unset_key(e,o)
     {raise_if_invalid_offset(e,o,cst_Obj_Ephemeron_unset_key);
      return caml_ephe_unset_key(e,o)}
    function check_key(e,o)
     {raise_if_invalid_offset(e,o,cst_Obj_Ephemeron_check_key);
      return runtime.caml_ephe_check_key(e,o)}
    function blit_key(e1,o1,e2,o2,l)
     {if
       (0
        <=
        l
        &&
        0
        <=
        o1
        &&
        !
        ((length$0(e1) - l | 0) < o1)
        &&
        0
        <=
        o2
        &&
        !
        ((length$0(e2) - l | 0) < o2))
       {var
         _zd_=0 !== l?1:0,
         _ze_=_zd_?runtime.caml_ephe_blit_key(e1,o1,e2,o2,l):_zd_;
        return _ze_}
      return invalid_arg(cst_Obj_Ephemeron_blit_key)}
    var
     _r_=runtime.caml_ephe_blit_data,
     _s_=runtime.caml_ephe_check_data,
     _t_=
      [0,
       create,
       length$0,
       get_key,
       get_key_copy,
       set_key,
       unset_key,
       check_key,
       blit_key,
       runtime.caml_ephe_get_data,
       runtime.caml_ephe_get_data_copy,
       runtime.caml_ephe_set_data,
       function(_zc_){return runtime.caml_ephe_unset_data(_zc_)},
       _s_,
       _r_,
       max_ephe_length],
     Stdlib_obj=
      [0,
       is_block,
       double_field,
       set_double_field,
       first_non_constant_constructor,
       last_non_constant_constructor_,
       lazy_tag,
       closure_tag,
       object_tag,
       infix_tag,
       forward_tag,
       no_scan_tag,
       abstract_tag,
       string_tag,
       double_tag,
       double_array_tag,
       custom_tag,
       custom_tag,
       int_tag,
       out_of_heap_tag,
       unaligned_tag,
       [0,info],
       Extension_constructor,
       extension_constructor,
       extension_name,
       extension_id,
       marshal,
       unmarshal,
       _t_];
    caml_register_global(773,Stdlib_obj,"Stdlib__obj");
    var make_float=runtime.caml_make_float_vect,Floatarray=[0];
    function init$2(l,f)
     {if(0 === l)return [0];
      if(0 <= l)
       {var res=caml_make_vect(l,caml_call1(f,0)),_za_=l - 1 | 0,_y$_=1;
        if(! (_za_ < 1))
         {var i=_y$_;
          for(;;)
           {res[1 + i] = caml_call1(f,i);
            var _zb_=i + 1 | 0;
            if(_za_ !== i){var i=_zb_;continue}
            break}}
        return res}
      return invalid_arg(cst_Array_init)}
    function create_matrix(sx,sy,init)
     {var res=caml_make_vect(sx,[0]),_y9_=sx - 1 | 0,_y8_=0;
      if(! (_y9_ < 0))
       {var x=_y8_;
        for(;;)
         {res[1 + x] = caml_make_vect(sy,init);
          var _y__=x + 1 | 0;
          if(_y9_ !== x){var x=_y__;continue}
          break}}
      return res}
    function copy$1(a)
     {var l=a.length - 1;return 0 === l?[0]:caml_array_sub(a,0,l)}
    function append$1(a1,a2)
     {var l1=a1.length - 1;
      return 0 === l1
              ?copy$1(a2)
              :0 === a2.length - 1
                ?caml_array_sub(a1,0,l1)
                :runtime.caml_array_append(a1,a2)}
    function sub$1(a,ofs,len)
     {if(0 <= ofs && 0 <= len && ! ((a.length - 1 - len | 0) < ofs))
       return caml_array_sub(a,ofs,len);
      return invalid_arg(cst_Array_sub)}
    function fill$0(a,ofs,len,v)
     {if(0 <= ofs && 0 <= len && ! ((a.length - 1 - len | 0) < ofs))
       return runtime.caml_array_fill(a,ofs,len,v);
      return invalid_arg(cst_Array_fill)}
    function blit$1(a1,ofs1,a2,ofs2,len)
     {if
       (0
        <=
        len
        &&
        0
        <=
        ofs1
        &&
        !
        ((a1.length - 1 - len | 0) < ofs1)
        &&
        0
        <=
        ofs2
        &&
        !
        ((a2.length - 1 - len | 0) < ofs2))
       return runtime.caml_array_blit(a1,ofs1,a2,ofs2,len);
      return invalid_arg(cst_Array_blit)}
    function iter$5(f,a)
     {var _y6_=a.length - 1 - 1 | 0,_y5_=0;
      if(! (_y6_ < 0))
       {var i=_y5_;
        for(;;)
         {caml_call1(f,a[1 + i]);
          var _y7_=i + 1 | 0;
          if(_y6_ !== i){var i=_y7_;continue}
          break}}
      return 0}
    function iter2$0(f,a,b)
     {if(a.length - 1 !== b.length - 1)
       return invalid_arg(cst_Array_iter2_arrays_must_ha);
      var _y3_=a.length - 1 - 1 | 0,_y2_=0;
      if(! (_y3_ < 0))
       {var i=_y2_;
        for(;;)
         {caml_call2(f,a[1 + i],b[1 + i]);
          var _y4_=i + 1 | 0;
          if(_y3_ !== i){var i=_y4_;continue}
          break}}
      return 0}
    function map$6(f,a)
     {var l=a.length - 1;
      if(0 === l)return [0];
      var r=caml_make_vect(l,caml_call1(f,a[1])),_y0_=l - 1 | 0,_yZ_=1;
      if(! (_y0_ < 1))
       {var i=_yZ_;
        for(;;)
         {r[1 + i] = caml_call1(f,a[1 + i]);
          var _y1_=i + 1 | 0;
          if(_y0_ !== i){var i=_y1_;continue}
          break}}
      return r}
    function map2$0(f,a,b)
     {var la=a.length - 1,lb=b.length - 1;
      if(la !== lb)return invalid_arg(cst_Array_map2_arrays_must_hav);
      if(0 === la)return [0];
      var r=caml_make_vect(la,caml_call2(f,a[1],b[1])),_yX_=la - 1 | 0,_yW_=1;
      if(! (_yX_ < 1))
       {var i=_yW_;
        for(;;)
         {r[1 + i] = caml_call2(f,a[1 + i],b[1 + i]);
          var _yY_=i + 1 | 0;
          if(_yX_ !== i){var i=_yY_;continue}
          break}}
      return r}
    function iteri$2(f,a)
     {var _yU_=a.length - 1 - 1 | 0,_yT_=0;
      if(! (_yU_ < 0))
       {var i=_yT_;
        for(;;)
         {caml_call2(f,i,a[1 + i]);
          var _yV_=i + 1 | 0;
          if(_yU_ !== i){var i=_yV_;continue}
          break}}
      return 0}
    function mapi$2(f,a)
     {var l=a.length - 1;
      if(0 === l)return [0];
      var r=caml_make_vect(l,caml_call2(f,0,a[1])),_yR_=l - 1 | 0,_yQ_=1;
      if(! (_yR_ < 1))
       {var i=_yQ_;
        for(;;)
         {r[1 + i] = caml_call2(f,i,a[1 + i]);
          var _yS_=i + 1 | 0;
          if(_yR_ !== i){var i=_yS_;continue}
          break}}
      return r}
    function to_list$1(a)
     {var i$1=a.length - 1 - 1 | 0,i=i$1,res=0;
      for(;;)
       {if(0 <= i)
         {var res$0=[0,a[1 + i],res],i$0=i - 1 | 0,i=i$0,res=res$0;continue}
        return res}}
    function list_length(accu,param)
     {var accu$0=accu,param$0=param;
      for(;;)
       {if(param$0)
         {var
           param$1=param$0[2],
           accu$1=accu$0 + 1 | 0,
           accu$0=accu$1,
           param$0=param$1;
          continue}
        return accu$0}}
    function of_list(l)
     {if(l)
       {var
         tl=l[2],
         hd=l[1],
         a=caml_make_vect(list_length(0,l),hd),
         i=1,
         param=tl;
        for(;;)
         {if(param)
           {var tl$0=param[2],hd$0=param[1];
            a[1 + i] = hd$0;
            var i$0=i + 1 | 0,i=i$0,param=tl$0;
            continue}
          return a}}
      return [0]}
    function fold_left$1(f,x,a)
     {var r=[0,x],_yO_=a.length - 1 - 1 | 0,_yN_=0;
      if(! (_yO_ < 0))
       {var i=_yN_;
        for(;;)
         {r[1] = caml_call2(f,r[1],a[1 + i]);
          var _yP_=i + 1 | 0;
          if(_yO_ !== i){var i=_yP_;continue}
          break}}
      return r[1]}
    function fold_right$0(f,a,x)
     {var r=[0,x],_yL_=a.length - 1 - 1 | 0;
      if(! (_yL_ < 0))
       {var i=_yL_;
        for(;;)
         {r[1] = caml_call2(f,a[1 + i],r[1]);
          var _yM_=i - 1 | 0;
          if(0 !== i){var i=_yM_;continue}
          break}}
      return r[1]}
    function exists$0(p,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 0;
        if(caml_call1(p,a[1 + i]))return 1;
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    function for_all$0(p,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 1;
        if(caml_call1(p,a[1 + i])){var i$0=i + 1 | 0,i=i$0;continue}
        return 0}}
    function for_all2$0(p,l1,l2)
     {var n1=l1.length - 1,n2=l2.length - 1;
      if(n1 !== n2)return invalid_arg(cst_Array_for_all2);
      var i=0;
      for(;;)
       {if(i === n1)return 1;
        if(caml_call2(p,l1[1 + i],l2[1 + i]))
         {var i$0=i + 1 | 0,i=i$0;continue}
        return 0}}
    function exists2$0(p,l1,l2)
     {var n1=l1.length - 1,n2=l2.length - 1;
      if(n1 !== n2)return invalid_arg(cst_Array_exists2);
      var i=0;
      for(;;)
       {if(i === n1)return 0;
        if(caml_call2(p,l1[1 + i],l2[1 + i]))return 1;
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    function mem$0(x,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 0;
        if(0 === caml_compare(a[1 + i],x))return 1;
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    function memq$0(x,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 0;
        if(x === a[1 + i])return 1;
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    var Bottom=[248,cst_Stdlib_Array_Bottom,caml_fresh_oo_id(0)];
    function sort(cmp,a)
     {function maxson(l,i)
       {var i31=((i + i | 0) + i | 0) + 1 | 0,x=[0,i31];
        if((i31 + 2 | 0) < l)
         {var _yE_=i31 + 1 | 0,_yF_=caml_check_bound(a,_yE_)[1 + _yE_];
          if(caml_call2(cmp,caml_check_bound(a,i31)[1 + i31],_yF_) < 0)
           x[1] = i31 + 1 | 0;
          var
           _yG_=i31 + 2 | 0,
           _yH_=caml_check_bound(a,_yG_)[1 + _yG_],
           _yI_=x[1];
          if(caml_call2(cmp,caml_check_bound(a,_yI_)[1 + _yI_],_yH_) < 0)
           x[1] = i31 + 2 | 0;
          return x[1]}
        if((i31 + 1 | 0) < l)
         {var _yJ_=i31 + 1 | 0,_yK_=caml_check_bound(a,_yJ_)[1 + _yJ_];
          if(! (0 <= caml_call2(cmp,caml_check_bound(a,i31)[1 + i31],_yK_)))
           return i31 + 1 | 0}
        if(i31 < l)return i31;
        throw [0,Bottom,i]}
      function trickledown(l,i,e)
       {var i$0=i;
        for(;;)
         {var j=maxson(l,i$0);
          if(0 < caml_call2(cmp,caml_check_bound(a,j)[1 + j],e))
           {var _yD_=caml_check_bound(a,j)[1 + j];
            caml_check_bound(a,i$0)[1 + i$0] = _yD_;
            var i$0=j;
            continue}
          caml_check_bound(a,i$0)[1 + i$0] = e;
          return 0}}
      function trickle(l,i,e)
       {try
         {var _yC_=trickledown(l,i,e);return _yC_}
        catch(exn)
         {exn = caml_wrap_exception(exn);
          if(exn[1] === Bottom)
           {var i$0=exn[2];caml_check_bound(a,i$0)[1 + i$0] = e;return 0}
          throw exn}}
      function bubbledown(l,i)
       {var i$0=i;
        for(;;)
         {var i$1=maxson(l,i$0),_yB_=caml_check_bound(a,i$1)[1 + i$1];
          caml_check_bound(a,i$0)[1 + i$0] = _yB_;
          var i$0=i$1;
          continue}}
      function bubble(l,i)
       {try
         {var _yA_=bubbledown(l,i);return _yA_}
        catch(exn)
         {exn = caml_wrap_exception(exn);
          if(exn[1] === Bottom){var i$0=exn[2];return i$0}
          throw exn}}
      var l=a.length - 1,_ys_=((l + 1 | 0) / 3 | 0) - 1 | 0;
      if(! (_ys_ < 0))
       {var i$2=_ys_;
        for(;;)
         {trickle(l,i$2,caml_check_bound(a,i$2)[1 + i$2]);
          var _yz_=i$2 - 1 | 0;
          if(0 !== i$2){var i$2=_yz_;continue}
          break}}
      var _yt_=l - 1 | 0;
      if(! (_yt_ < 2))
       {var i$0=_yt_;
        a:
        for(;;)
         {var
           e$0=caml_check_bound(a,i$0)[1 + i$0],
           _yx_=caml_check_bound(a,0)[1];
          caml_check_bound(a,i$0)[1 + i$0] = _yx_;
          var i$1=bubble(i$0,0),i=i$1;
          for(;;)
           {var father=(i - 1 | 0) / 3 | 0;
            if(i === father)throw [0,Assert_failure,_u_];
            if
             (0 <= caml_call2(cmp,caml_check_bound(a,father)[1 + father],e$0))
             caml_check_bound(a,i)[1 + i] = e$0;
            else
             {var _yr_=caml_check_bound(a,father)[1 + father];
              caml_check_bound(a,i)[1 + i] = _yr_;
              if(0 < father){var i=father;continue}
              caml_check_bound(a,0)[1] = e$0}
            var _yy_=i$0 - 1 | 0;
            if(2 !== i$0){var i$0=_yy_;continue a}
            break}
          break}}
      var _yu_=1 < l?1:0;
      if(_yu_)
       {var e=caml_check_bound(a,1)[2],_yv_=caml_check_bound(a,0)[1];
        caml_check_bound(a,1)[2] = _yv_;
        caml_check_bound(a,0)[1] = e;
        var _yw_=0}
      else
       var _yw_=_yu_;
      return _yw_}
    function fast_sort$0(cmp,a)
     {function merge(src1ofs,src1len,src2,src2ofs,src2len,dst,dstofs)
       {var
         src1r=src1ofs + src1len | 0,
         src2r=src2ofs + src2len | 0,
         s2$1=caml_check_bound(src2,src2ofs)[1 + src2ofs],
         s1$1=caml_check_bound(a,src1ofs)[1 + src1ofs],
         i1=src1ofs,
         s1=s1$1,
         i2=src2ofs,
         s2=s2$1,
         d=dstofs;
        for(;;)
         {if(0 < caml_call2(cmp,s1,s2))
           {caml_check_bound(dst,d)[1 + d] = s2;
            var i2$0=i2 + 1 | 0;
            if(i2$0 < src2r)
             {var
               d$0=d + 1 | 0,
               s2$0=caml_check_bound(src2,i2$0)[1 + i2$0],
               i2=i2$0,
               s2=s2$0,
               d=d$0;
              continue}
            return blit$1(a,i1,dst,d + 1 | 0,src1r - i1 | 0)}
          caml_check_bound(dst,d)[1 + d] = s1;
          var i1$0=i1 + 1 | 0;
          if(i1$0 < src1r)
           {var
             d$1=d + 1 | 0,
             s1$0=caml_check_bound(a,i1$0)[1 + i1$0],
             i1=i1$0,
             s1=s1$0,
             d=d$1;
            continue}
          return blit$1(src2,i2,dst,d + 1 | 0,src2r - i2 | 0)}}
      function isortto(srcofs,dst,dstofs,len)
       {var _yj_=len - 1 | 0,_yi_=0;
        if(! (_yj_ < 0))
         {var i=_yi_;
          a:
          for(;;)
           {var
             _yk_=srcofs + i | 0,
             e=caml_check_bound(a,_yk_)[1 + _yk_],
             j=[0,(dstofs + i | 0) - 1 | 0];
            for(;;)
             {if(dstofs <= j[1])
               {var _yl_=j[1];
                if(0 < caml_call2(cmp,caml_check_bound(dst,_yl_)[1 + _yl_],e))
                 {var
                   _ym_=j[1],
                   _yn_=caml_check_bound(dst,_ym_)[1 + _ym_],
                   _yo_=j[1] + 1 | 0;
                  caml_check_bound(dst,_yo_)[1 + _yo_] = _yn_;
                  j[1] += -1;
                  continue}}
              var _yp_=j[1] + 1 | 0;
              caml_check_bound(dst,_yp_)[1 + _yp_] = e;
              var _yq_=i + 1 | 0;
              if(_yj_ !== i){var i=_yq_;continue a}
              break}
            break}}
        return 0}
      function sortto(srcofs,dst,dstofs,len)
       {if(len <= 5)return isortto(srcofs,dst,dstofs,len);
        var l1=len / 2 | 0,l2=len - l1 | 0;
        sortto(srcofs + l1 | 0,dst,dstofs + l1 | 0,l2);
        sortto(srcofs,a,srcofs + l2 | 0,l1);
        return merge(srcofs + l2 | 0,l1,dst,dstofs + l1 | 0,l2,dst,dstofs)}
      var l=a.length - 1;
      if(l <= 5)return isortto(0,a,0,l);
      var
       l1=l / 2 | 0,
       l2=l - l1 | 0,
       t=caml_make_vect(l2,caml_check_bound(a,0)[1]);
      sortto(l1,t,0,l2);
      sortto(0,a,l2,l1);
      return merge(l2,l1,t,0,l2,a,0)}
    function to_seq$4(a)
     {function aux(i,param)
       {if(i < a.length - 1)
         {var x=a[1 + i],_yg_=i + 1 | 0;
          return [0,x,function(_yh_){return aux(_yg_,_yh_)}]}
        return 0}
      var _ye_=0;
      return function(_yf_){return aux(_ye_,_yf_)}}
    function to_seqi$1(a)
     {function aux(i,param)
       {if(i < a.length - 1)
         {var x=a[1 + i],_yc_=i + 1 | 0;
          return [0,[0,i,x],function(_yd_){return aux(_yc_,_yd_)}]}
        return 0}
      var _ya_=0;
      return function(_yb_){return aux(_ya_,_yb_)}}
    function of_seq$2(i$2)
     {var _x$_=0,l=fold_left(function(acc,x){return [0,x,acc]},_x$_,i$2);
      if(l)
       {var
         tl=l[2],
         hd=l[1],
         len=list_length(0,l),
         a=caml_make_vect(len,hd),
         i$1=len - 2 | 0,
         i=i$1,
         param=tl;
        for(;;)
         {if(param)
           {var tl$0=param[2],hd$0=param[1];
            a[1 + i] = hd$0;
            var i$0=i - 1 | 0,i=i$0,param=tl$0;
            continue}
          return a}}
      return [0]}
    var
     concat$1=caml_array_concat,
     include$3=
      [0,
       make_float,
       init$2,
       create_matrix,
       create_matrix,
       append$1,
       concat$1,
       sub$1,
       copy$1,
       fill$0,
       blit$1,
       to_list$1,
       of_list,
       iter$5,
       iteri$2,
       map$6,
       mapi$2,
       fold_left$1,
       fold_right$0,
       iter2$0,
       map2$0,
       for_all$0,
       exists$0,
       for_all2$0,
       exists2$0,
       mem$0,
       memq$0,
       sort,
       fast_sort$0,
       fast_sort$0,
       to_seq$4,
       to_seqi$1,
       of_seq$2,
       Floatarray];
    caml_register_global(774,include$3,"Stdlib__array");
    var zero=0.,one=1.,minus_one=-1.;
    function is_finite(x){return x - x == 0.?1:0}
    function is_infinite(x){return 1. / x == 0.?1:0}
    function is_nan(x){return x != x?1:0}
    var pi=3.14159265358979312;
    function is_integer(x)
     {var _x__=x == runtime.caml_trunc_float(x)?1:0;
      return _x__?is_finite(x):_x__}
    function succ$0(x){return caml_nextafter_float(x,infinity)}
    function pred$0(x){return caml_nextafter_float(x,neg_infinity)}
    function equal$9(x,y){return 0 === caml_float_compare(x,y)?1:0}
    function min$1(x,y)
     {if(! (x < y))
       {var switch$0=0;
        if(caml_signbit_float(y) || ! caml_signbit_float(x))switch$0 = 1;
        if(switch$0)return x != x?x:y}
      return y != y?y:x}
    function max$1(x,y)
     {if(! (x < y))
       {var switch$0=0;
        if(caml_signbit_float(y) || ! caml_signbit_float(x))switch$0 = 1;
        if(switch$0)return y != y?y:x}
      return x != x?x:y}
    function min_max(x,y)
     {if(x == x && y == y)
       {if(! (x < y))
         {var switch$0=0;
          if(caml_signbit_float(y) || ! caml_signbit_float(x))switch$0 = 1;
          if(switch$0)return [0,y,x]}
        return [0,x,y]}
      return [0,nan,nan]}
    function min_num(x,y)
     {if(! (x < y))
       {var switch$0=0;
        if(caml_signbit_float(y) || ! caml_signbit_float(x))switch$0 = 1;
        if(switch$0)return y != y?x:y}
      return x != x?y:x}
    function max_num(x,y)
     {if(! (x < y))
       {var switch$0=0;
        if(caml_signbit_float(y) || ! caml_signbit_float(x))switch$0 = 1;
        if(switch$0)return x != x?y:x}
      return y != y?x:y}
    function min_max_num(x,y)
     {if(x != x)return [0,y,y];
      if(y != y)return [0,x,x];
      if(! (x < y))
       {var switch$0=0;
        if(caml_signbit_float(y) || ! caml_signbit_float(x))switch$0 = 1;
        if(switch$0)return [0,y,x]}
      return [0,x,y]}
    function hash$0(x){return caml_hash(10,100,0,x)}
    function unsafe_fill(a,ofs,len,v)
     {var _x8_=(ofs + len | 0) - 1 | 0;
      if(! (_x8_ < ofs))
       {var i=ofs;
        for(;;)
         {a[1 + i] = v;
          var _x9_=i + 1 | 0;
          if(_x8_ !== i){var i=_x9_;continue}
          break}}
      return 0}
    function check(a,ofs,len,msg)
     {var _x4_=ofs < 0?1:0;
      if(_x4_)
       var _x5_=_x4_;
      else
       {var _x6_=len < 0?1:0;
        if(_x6_)
         var _x5_=_x6_;
        else
         var
          _x7_=(ofs + len | 0) < 0?1:0,
          _x5_=_x7_ || (a.length - 1 < (ofs + len | 0)?1:0)}
      return _x5_?invalid_arg(msg):_x5_}
    function make$2(n,v)
     {var result=caml_floatarray_create(n);
      unsafe_fill(result,0,n,v);
      return result}
    function init$3(l,f)
     {if(0 <= l)
       {var res=caml_floatarray_create(l),_x2_=l - 1 | 0,_x1_=0;
        if(! (_x2_ < 0))
         {var i=_x1_;
          for(;;)
           {res[1 + i] = caml_call1(f,i);
            var _x3_=i + 1 | 0;
            if(_x2_ !== i){var i=_x3_;continue}
            break}}
        return res}
      return invalid_arg(cst_Float_Array_init)}
    function append$2(a1,a2)
     {var
       l1=a1.length - 1,
       l2=a2.length - 1,
       result=caml_floatarray_create(l1 + l2 | 0);
      caml_floatarray_blit(a1,0,result,0,l1);
      caml_floatarray_blit(a2,0,result,l1,l2);
      return result}
    function concat$2(l)
     {var acc=0,param=l;
      for(;;)
       {if(param)
         {var
           tl=param[2],
           hd=param[1],
           x=hd.length - 1 + acc | 0,
           acc$0=acc <= x?x:invalid_arg(cst_Float_Array_concat),
           acc=acc$0,
           param=tl;
          continue}
        var result=caml_floatarray_create(acc),l$0=l,i=0;
        for(;;)
         {if(l$0)
           {var tl$0=l$0[2],hd$0=l$0[1],hlen=hd$0.length - 1;
            caml_floatarray_blit(hd$0,0,result,i,hlen);
            var i$0=i + hlen | 0,l$0=tl$0,i=i$0;
            continue}
          if(i === acc)return result;
          throw [0,Assert_failure,_v_]}}}
    function sub$2(a,ofs,len)
     {check(a,ofs,len,cst_Float_Array_sub);
      var result=caml_floatarray_create(len);
      caml_floatarray_blit(a,ofs,result,0,len);
      return result}
    function copy$2(a)
     {var l=a.length - 1,result=caml_floatarray_create(l);
      caml_floatarray_blit(a,0,result,0,l);
      return result}
    function fill$1(a,ofs,len,v)
     {check(a,ofs,len,cst_Float_Array_fill);return unsafe_fill(a,ofs,len,v)}
    function blit$2(src,sofs,dst,dofs,len)
     {check(src,sofs,len,cst_Float_array_blit);
      check(dst,dofs,len,cst_Float_array_blit$0);
      return caml_floatarray_blit(src,sofs,dst,dofs,len)}
    function to_list$2(a)
     {return init(a.length - 1,function(_x0_){return a[1 + _x0_]})}
    function of_list$0(l)
     {var result=caml_floatarray_create(length(l)),i=0,l$0=l;
      for(;;)
       {if(l$0)
         {var t=l$0[2],h=l$0[1];
          result[1 + i] = h;
          var i$0=i + 1 | 0,i=i$0,l$0=t;
          continue}
        return result}}
    function iter$6(f,a)
     {var _xY_=a.length - 1 - 1 | 0,_xX_=0;
      if(! (_xY_ < 0))
       {var i=_xX_;
        for(;;)
         {caml_call1(f,a[1 + i]);
          var _xZ_=i + 1 | 0;
          if(_xY_ !== i){var i=_xZ_;continue}
          break}}
      return 0}
    function iter2$1(f,a,b)
     {if(a.length - 1 !== b.length - 1)
       return invalid_arg(cst_Float_Array_iter2_arrays_m);
      var _xV_=a.length - 1 - 1 | 0,_xU_=0;
      if(! (_xV_ < 0))
       {var i=_xU_;
        for(;;)
         {caml_call2(f,a[1 + i],b[1 + i]);
          var _xW_=i + 1 | 0;
          if(_xV_ !== i){var i=_xW_;continue}
          break}}
      return 0}
    function map$7(f,a)
     {var l=a.length - 1,r=caml_floatarray_create(l),_xS_=l - 1 | 0,_xR_=0;
      if(! (_xS_ < 0))
       {var i=_xR_;
        for(;;)
         {r[1 + i] = caml_call1(f,a[1 + i]);
          var _xT_=i + 1 | 0;
          if(_xS_ !== i){var i=_xT_;continue}
          break}}
      return r}
    function map2$1(f,a,b)
     {var la=a.length - 1,lb=b.length - 1;
      if(la !== lb)return invalid_arg(cst_Float_Array_map2_arrays_mu);
      var r=caml_floatarray_create(la),_xP_=la - 1 | 0,_xO_=0;
      if(! (_xP_ < 0))
       {var i=_xO_;
        for(;;)
         {r[1 + i] = caml_call2(f,a[1 + i],b[1 + i]);
          var _xQ_=i + 1 | 0;
          if(_xP_ !== i){var i=_xQ_;continue}
          break}}
      return r}
    function iteri$3(f,a)
     {var _xM_=a.length - 1 - 1 | 0,_xL_=0;
      if(! (_xM_ < 0))
       {var i=_xL_;
        for(;;)
         {caml_call2(f,i,a[1 + i]);
          var _xN_=i + 1 | 0;
          if(_xM_ !== i){var i=_xN_;continue}
          break}}
      return 0}
    function mapi$3(f,a)
     {var l=a.length - 1,r=caml_floatarray_create(l),_xJ_=l - 1 | 0,_xI_=0;
      if(! (_xJ_ < 0))
       {var i=_xI_;
        for(;;)
         {r[1 + i] = caml_call2(f,i,a[1 + i]);
          var _xK_=i + 1 | 0;
          if(_xJ_ !== i){var i=_xK_;continue}
          break}}
      return r}
    function fold_left$2(f,x,a)
     {var r=[0,x],_xG_=a.length - 1 - 1 | 0,_xF_=0;
      if(! (_xG_ < 0))
       {var i=_xF_;
        for(;;)
         {r[1] = caml_call2(f,r[1],a[1 + i]);
          var _xH_=i + 1 | 0;
          if(_xG_ !== i){var i=_xH_;continue}
          break}}
      return r[1]}
    function fold_right$1(f,a,x)
     {var r=[0,x],_xD_=a.length - 1 - 1 | 0;
      if(! (_xD_ < 0))
       {var i=_xD_;
        for(;;)
         {r[1] = caml_call2(f,a[1 + i],r[1]);
          var _xE_=i - 1 | 0;
          if(0 !== i){var i=_xE_;continue}
          break}}
      return r[1]}
    function exists$1(p,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 0;
        if(caml_call1(p,a[1 + i]))return 1;
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    function for_all$1(p,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 1;
        if(caml_call1(p,a[1 + i])){var i$0=i + 1 | 0,i=i$0;continue}
        return 0}}
    function mem$1(x,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 0;
        if(0 === caml_float_compare(a[1 + i],x))return 1;
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    function mem_ieee(x,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 0;
        if(x == a[1 + i])return 1;
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    var Bottom$0=[248,cst_Stdlib_Float_Array_Bottom,caml_fresh_oo_id(0)];
    function sort$0(cmp,a)
     {function maxson(l,i)
       {var i31=((i + i | 0) + i | 0) + 1 | 0,x=[0,i31];
        if((i31 + 2 | 0) < l)
         {if
           (caml_call2
             (cmp,caml_array_get(a,i31),caml_array_get(a,i31 + 1 | 0))
            <
            0)
           x[1] = i31 + 1 | 0;
          if
           (caml_call2
             (cmp,caml_array_get(a,x[1]),caml_array_get(a,i31 + 2 | 0))
            <
            0)
           x[1] = i31 + 2 | 0;
          return x[1]}
        if
         ((i31 + 1 | 0)
          <
          l
          &&
          !
          (0
           <=
           caml_call2(cmp,caml_array_get(a,i31),caml_array_get(a,i31 + 1 | 0))))
         return i31 + 1 | 0;
        if(i31 < l)return i31;
        throw [0,Bottom$0,i]}
      function trickledown(l,i,e)
       {var i$0=i;
        for(;;)
         {var j=maxson(l,i$0);
          if(0 < caml_call2(cmp,caml_array_get(a,j),e))
           {caml_array_set(a,i$0,caml_array_get(a,j));var i$0=j;continue}
          return caml_array_set(a,i$0,e)}}
      function trickle(l,i,e)
       {try
         {var _xC_=trickledown(l,i,e);return _xC_}
        catch(exn)
         {exn = caml_wrap_exception(exn);
          if(exn[1] === Bottom$0)
           {var i$0=exn[2];return caml_array_set(a,i$0,e)}
          throw exn}}
      function bubbledown(l,i)
       {var i$0=i;
        for(;;)
         {var i$1=maxson(l,i$0);
          caml_array_set(a,i$0,caml_array_get(a,i$1));
          var i$0=i$1;
          continue}}
      function bubble(l,i)
       {try
         {var _xB_=bubbledown(l,i);return _xB_}
        catch(exn)
         {exn = caml_wrap_exception(exn);
          if(exn[1] === Bottom$0){var i$0=exn[2];return i$0}
          throw exn}}
      var l=a.length - 1,_xv_=((l + 1 | 0) / 3 | 0) - 1 | 0;
      if(! (_xv_ < 0))
       {var i$2=_xv_;
        for(;;)
         {trickle(l,i$2,caml_array_get(a,i$2));
          var _xA_=i$2 - 1 | 0;
          if(0 !== i$2){var i$2=_xA_;continue}
          break}}
      var _xw_=l - 1 | 0;
      if(! (_xw_ < 2))
       {var i$0=_xw_;
        a:
        for(;;)
         {var e$0=caml_array_get(a,i$0);
          caml_array_set(a,i$0,caml_array_get(a,0));
          var i$1=bubble(i$0,0),i=i$1;
          for(;;)
           {var father=(i - 1 | 0) / 3 | 0;
            if(i === father)throw [0,Assert_failure,_w_];
            if(0 <= caml_call2(cmp,caml_array_get(a,father),e$0))
             caml_array_set(a,i,e$0);
            else
             {caml_array_set(a,i,caml_array_get(a,father));
              if(0 < father){var i=father;continue}
              caml_array_set(a,0,e$0)}
            var _xz_=i$0 - 1 | 0;
            if(2 !== i$0){var i$0=_xz_;continue a}
            break}
          break}}
      var _xx_=1 < l?1:0;
      if(_xx_)
       {var e=caml_array_get(a,1);
        caml_array_set(a,1,caml_array_get(a,0));
        var _xy_=caml_array_set(a,0,e)}
      else
       var _xy_=_xx_;
      return _xy_}
    function stable_sort(cmp,a)
     {function merge(src1ofs,src1len,src2,src2ofs,src2len,dst,dstofs)
       {var
         src1r=src1ofs + src1len | 0,
         src2r=src2ofs + src2len | 0,
         s2$1=caml_array_get(src2,src2ofs),
         s1$1=caml_array_get(a,src1ofs),
         i1=src1ofs,
         s1=s1$1,
         i2=src2ofs,
         s2=s2$1,
         d=dstofs;
        for(;;)
         {if(0 < caml_call2(cmp,s1,s2))
           {caml_array_set(dst,d,s2);
            var i2$0=i2 + 1 | 0;
            if(i2$0 < src2r)
             {var
               d$0=d + 1 | 0,
               s2$0=caml_array_get(src2,i2$0),
               i2=i2$0,
               s2=s2$0,
               d=d$0;
              continue}
            return blit$2(a,i1,dst,d + 1 | 0,src1r - i1 | 0)}
          caml_array_set(dst,d,s1);
          var i1$0=i1 + 1 | 0;
          if(i1$0 < src1r)
           {var
             d$1=d + 1 | 0,
             s1$0=caml_array_get(a,i1$0),
             i1=i1$0,
             s1=s1$0,
             d=d$1;
            continue}
          return blit$2(src2,i2,dst,d + 1 | 0,src2r - i2 | 0)}}
      function isortto(srcofs,dst,dstofs,len)
       {var _xt_=len - 1 | 0,_xs_=0;
        if(! (_xt_ < 0))
         {var i=_xs_;
          a:
          for(;;)
           {var
             e=caml_array_get(a,srcofs + i | 0),
             j=[0,(dstofs + i | 0) - 1 | 0];
            for(;;)
             {if
               (dstofs
                <=
                j[1]
                &&
                0
                <
                caml_call2(cmp,caml_array_get(dst,j[1]),e))
               {caml_array_set(dst,j[1] + 1 | 0,caml_array_get(dst,j[1]));
                j[1] += -1;
                continue}
              caml_array_set(dst,j[1] + 1 | 0,e);
              var _xu_=i + 1 | 0;
              if(_xt_ !== i){var i=_xu_;continue a}
              break}
            break}}
        return 0}
      function sortto(srcofs,dst,dstofs,len)
       {if(len <= 5)return isortto(srcofs,dst,dstofs,len);
        var l1=len / 2 | 0,l2=len - l1 | 0;
        sortto(srcofs + l1 | 0,dst,dstofs + l1 | 0,l2);
        sortto(srcofs,a,srcofs + l2 | 0,l1);
        return merge(srcofs + l2 | 0,l1,dst,dstofs + l1 | 0,l2,dst,dstofs)}
      var l=a.length - 1;
      if(l <= 5)return isortto(0,a,0,l);
      var l1=l / 2 | 0,l2=l - l1 | 0,t=caml_floatarray_create(l2);
      sortto(l1,t,0,l2);
      sortto(0,a,l2,l1);
      return merge(l2,l1,t,0,l2,a,0)}
    function to_seq$5(a)
     {function aux(i,param)
       {if(i < a.length - 1)
         {var x=a[1 + i],_xq_=i + 1 | 0;
          return [0,x,function(_xr_){return aux(_xq_,_xr_)}]}
        return 0}
      var _xo_=0;
      return function(_xp_){return aux(_xo_,_xp_)}}
    function to_seqi$2(a)
     {function aux(i,param)
       {if(i < a.length - 1)
         {var x=a[1 + i],_xm_=i + 1 | 0;
          return [0,[0,i,x],function(_xn_){return aux(_xm_,_xn_)}]}
        return 0}
      var _xk_=0;
      return function(_xl_){return aux(_xk_,_xl_)}}
    function of_seq$3(i$2)
     {var
       _xj_=0,
       param$0=fold_left(function(acc,x){return [0,x,acc]},_xj_,i$2),
       len=length(param$0),
       a=caml_floatarray_create(len),
       i$1=len - 1 | 0,
       i=i$1,
       param=param$0;
      for(;;)
       {if(param)
         {var tl=param[2],hd=param[1];
          a[1 + i] = hd;
          var i$0=i - 1 | 0,i=i$0,param=tl;
          continue}
        return a}}
    function map_to_array(f,a)
     {var l=a.length - 1;
      if(0 === l)return [0];
      var r=caml_make_vect(l,caml_call1(f,a[1])),_xh_=l - 1 | 0,_xg_=1;
      if(! (_xh_ < 1))
       {var i=_xg_;
        for(;;)
         {r[1 + i] = caml_call1(f,a[1 + i]);
          var _xi_=i + 1 | 0;
          if(_xh_ !== i){var i=_xi_;continue}
          break}}
      return r}
    function map_from_array(f,a)
     {var l=a.length - 1,r=caml_floatarray_create(l),_xe_=l - 1 | 0,_xd_=0;
      if(! (_xe_ < 0))
       {var i=_xd_;
        for(;;)
         {r[1 + i] = caml_call1(f,a[1 + i]);
          var _xf_=i + 1 | 0;
          if(_xe_ !== i){var i=_xf_;continue}
          break}}
      return r}
    var
     _x_=caml_floatarray_create,
     _y_=caml_array_set,
     _z_=caml_array_get,
     _A_=
      [0,
       function(_xc_){return _xc_.length - 1},
       _z_,
       _y_,
       make$2,
       _x_,
       init$3,
       append$2,
       concat$2,
       sub$2,
       copy$2,
       fill$1,
       blit$2,
       to_list$2,
       of_list$0,
       iter$6,
       iteri$3,
       map$7,
       mapi$3,
       fold_left$2,
       fold_right$1,
       iter2$1,
       map2$1,
       for_all$1,
       exists$1,
       mem$1,
       mem_ieee,
       sort$0,
       stable_sort,
       stable_sort,
       to_seq$5,
       to_seqi$2,
       of_seq$3,
       map_to_array,
       map_from_array],
     _B_=caml_floatarray_create,
     _C_=caml_array_set,
     _D_=caml_array_get,
     Stdlib_float=
      [0,
       zero,
       one,
       minus_one,
       succ$0,
       pred$0,
       infinity,
       neg_infinity,
       nan,
       pi,
       max_float,
       min_float,
       epsilon,
       is_finite,
       is_infinite,
       is_nan,
       is_integer,
       of_string_opt,
       to_string,
       caml_float_compare,
       equal$9,
       min$1,
       max$1,
       min_max,
       min_num,
       max_num,
       min_max_num,
       hash$0,
       [0,
        function(_xb_){return _xb_.length - 1},
        _D_,
        _C_,
        make$2,
        _B_,
        init$3,
        append$2,
        concat$2,
        sub$2,
        copy$2,
        fill$1,
        blit$2,
        to_list$2,
        of_list$0,
        iter$6,
        iteri$3,
        map$7,
        mapi$3,
        fold_left$2,
        fold_right$1,
        iter2$1,
        map2$1,
        for_all$1,
        exists$1,
        mem$1,
        mem_ieee,
        sort$0,
        stable_sort,
        stable_sort,
        to_seq$5,
        to_seqi$2,
        of_seq$3,
        map_to_array,
        map_from_array],
       _A_];
    caml_register_global(775,Stdlib_float,"Stdlib__float");
    var zero$0=0,one$0=1,minus_one$0=-1;
    function abs$0(x){return 0 <= x?x:- x | 0}
    var max_int$0=2147483647,min_int$0=-2147483648;
    function lognot(x){return x ^ -1}
    function equal$10(_xa_,_w$_){return _xa_ === _w$_?1:0}
    var compare$9=caml_int_compare;
    function to_string$3(x){return caml_string_of_jsbytes("" + x)}
    var
     Stdlib_int=
      [0,
       zero$0,
       one$0,
       minus_one$0,
       abs$0,
       max_int$0,
       min_int$0,
       lognot,
       equal$10,
       compare$9,
       to_string$3];
    caml_register_global(776,Stdlib_int,"Stdlib__int");
    var zero$1=0,one$1=1,minus_one$1=-1;
    function succ$1(n){return n + 1 | 0}
    function pred$1(n){return n - 1 | 0}
    function abs$1(n){return caml_greaterequal(n,0)?n:- n | 0}
    var min_int$1=-2147483648,max_int$1=2147483647;
    function lognot$0(n){return n ^ -1}
    function unsigned_to_int(n)
     {if
       (!
        (0 < caml_int_compare(0,n))
        &&
        !
        (0 < caml_int_compare(n,2147483647)))
       return [0,n];
      return 0}
    function to_string$4(n){return caml_format_int(cst_d,n)}
    function of_string_opt$0(s)
     {try
       {var _w9_=[0,caml_int_of_string(s)];return _w9_}
      catch(_w__)
       {_w__ = caml_wrap_exception(_w__);
        if(_w__[1] === Failure)return 0;
        throw _w__}}
    function compare$10(x,y){return caml_int_compare(x,y)}
    function equal$11(x,y){return 0 === caml_int_compare(x,y)?1:0}
    function unsigned_compare(n,m)
     {return caml_int_compare(n + 2147483648 | 0,m + 2147483648 | 0)}
    function unsigned_div(n,d)
     {if(caml_lessthan(d,0))return 0 <= unsigned_compare(n,d)?one$1:zero$1;
      var q=caml_div(n >>> 1 | 0,d) << 1,r=n - caml_mul(q,d) | 0;
      return 0 <= unsigned_compare(r,d)?q + 1 | 0:q}
    function unsigned_rem(n,d){return n - caml_mul(unsigned_div(n,d),d) | 0}
    var
     Stdlib_int32=
      [0,
       zero$1,
       one$1,
       minus_one$1,
       unsigned_div,
       unsigned_rem,
       succ$1,
       pred$1,
       abs$1,
       max_int$1,
       min_int$1,
       lognot$0,
       unsigned_to_int,
       of_string_opt$0,
       to_string$4,
       compare$10,
       unsigned_compare,
       equal$11];
    caml_register_global(777,Stdlib_int32,"Stdlib__int32");
    function succ$2(n){return caml_int64_add(n,_E_)}
    function pred$2(n){return caml_int64_sub(n,_F_)}
    function abs$2(n)
     {return caml_greaterequal(n,_G_)?n:runtime.caml_int64_neg(n)}
    function lognot$1(n){return runtime.caml_int64_xor(n,_H_)}
    var max_int$3=caml_int64_of_int32(2147483647);
    function unsigned_to_int$0(n)
     {if
       (!
        (0 < caml_int64_compare(zero$2,n))
        &&
        !
        (0 < caml_int64_compare(n,max_int$3)))
       return [0,runtime.caml_int64_to_int32(n)];
      return 0}
    function to_string$5(n){return caml_int64_format(cst_d$0,n)}
    function of_string_opt$1(s)
     {try
       {var _w7_=[0,caml_int64_of_string(s)];return _w7_}
      catch(_w8_)
       {_w8_ = caml_wrap_exception(_w8_);
        if(_w8_[1] === Failure)return 0;
        throw _w8_}}
    function compare$11(x,y){return caml_int64_compare(x,y)}
    function equal$12(x,y){return 0 === caml_int64_compare(x,y)?1:0}
    function unsigned_compare$0(n,m)
     {return caml_int64_compare
              (caml_int64_sub(n,min_int$2),caml_int64_sub(m,min_int$2))}
    function unsigned_div$0(n,d)
     {if(caml_lessthan(d,zero$2))
       return 0 <= unsigned_compare$0(n,d)?one$2:zero$2;
      var
       q=
        caml_int64_shift_left
         (runtime.caml_int64_div
           (runtime.caml_int64_shift_right_unsigned(n,1),d),
          1),
       r=caml_int64_sub(n,caml_int64_mul(q,d));
      return 0 <= unsigned_compare$0(r,d)?succ$2(q):q}
    function unsigned_rem$0(n,d)
     {return caml_int64_sub(n,caml_int64_mul(unsigned_div$0(n,d),d))}
    var
     Stdlib_int64=
      [0,
       zero$2,
       one$2,
       minus_one$2,
       unsigned_div$0,
       unsigned_rem$0,
       succ$2,
       pred$2,
       abs$2,
       max_int$2,
       min_int$2,
       lognot$1,
       unsigned_to_int$0,
       of_string_opt$1,
       to_string$5,
       compare$11,
       unsigned_compare$0,
       equal$12];
    caml_register_global(778,Stdlib_int64,"Stdlib__int64");
    var zero$3=0,one$3=1,minus_one$3=-1;
    function succ$3(n){return n + 1 | 0}
    function pred$3(n){return n - 1 | 0}
    function abs$3(n){return caml_greaterequal(n,0)?n:- n | 0}
    var min_int$3=-2147483648,max_int$4=2147483647;
    function lognot$2(n){return n ^ -1}
    function unsigned_to_int$1(n)
     {if
       (!
        (0 < caml_int_compare(0,n))
        &&
        !
        (0 < caml_int_compare(n,2147483647)))
       return [0,n];
      return 0}
    function to_string$6(n){return caml_format_int(cst_d$1,n)}
    function of_string_opt$2(s)
     {try
       {var _w5_=[0,caml_int_of_string(s)];return _w5_}
      catch(_w6_)
       {_w6_ = caml_wrap_exception(_w6_);
        if(_w6_[1] === Failure)return 0;
        throw _w6_}}
    function compare$12(x,y){return caml_int_compare(x,y)}
    function equal$13(x,y){return 0 === caml_int_compare(x,y)?1:0}
    function unsigned_compare$1(n,m)
     {return caml_int_compare(n + 2147483648 | 0,m + 2147483648 | 0)}
    function unsigned_div$1(n,d)
     {if(caml_lessthan(d,0))return 0 <= unsigned_compare$1(n,d)?one$3:zero$3;
      var q=caml_div(n >>> 1 | 0,d) << 1,r=n - caml_mul(q,d) | 0;
      return 0 <= unsigned_compare$1(r,d)?q + 1 | 0:q}
    function unsigned_rem$1(n,d)
     {return n - caml_mul(unsigned_div$1(n,d),d) | 0}
    var
     Stdlib_nativeint=
      [0,
       zero$3,
       one$3,
       minus_one$3,
       unsigned_div$1,
       unsigned_rem$1,
       succ$3,
       pred$3,
       abs$3,
       match$1,
       max_int$4,
       min_int$3,
       lognot$2,
       unsigned_to_int$1,
       of_string_opt$2,
       to_string$6,
       compare$12,
       unsigned_compare$1,
       equal$13];
    caml_register_global(779,Stdlib_nativeint,"Stdlib__nativeint");
    function engine(tbl,state,buf)
     {var
       result=runtime.caml_lex_engine(tbl,state,buf),
       _w2_=0 <= result?1:0,
       _w3_=_w2_?buf[12] !== dummy_pos?1:0:_w2_;
      if(_w3_)
       {buf[11] = buf[12];
        var _w4_=buf[12];
        buf[12] = [0,_w4_[1],_w4_[2],_w4_[3],buf[4] + buf[6] | 0]}
      return result}
    function new_engine(tbl,state,buf)
     {var
       result=runtime.caml_new_lex_engine(tbl,state,buf),
       _wZ_=0 <= result?1:0,
       _w0_=_wZ_?buf[12] !== dummy_pos?1:0:_wZ_;
      if(_w0_)
       {buf[11] = buf[12];
        var _w1_=buf[12];
        buf[12] = [0,_w1_[1],_w1_[2],_w1_[3],buf[4] + buf[6] | 0]}
      return result}
    function from_function(opt,f)
     {if(opt)var sth=opt[1],with_positions=sth;else var with_positions=1;
      var
       _wL_=with_positions?zero_pos:dummy_pos,
       _wM_=with_positions?zero_pos:dummy_pos,
       aux_buffer=caml_create_bytes(512),
       _wN_=[0],
       _wO_=0,
       _wP_=0,
       _wQ_=0,
       _wR_=0,
       _wS_=0,
       _wT_=0,
       _wU_=0,
       _wV_=caml_create_bytes(1024);
      return [0,
              function(lexbuf)
               {var
                 read=
                  caml_call2(f,aux_buffer,caml_ml_bytes_length(aux_buffer)),
                 n=0 < read?read:(lexbuf[9] = 1,0);
                if(caml_ml_bytes_length(lexbuf[2]) < (lexbuf[3] + n | 0))
                 {if
                   (((lexbuf[3] - lexbuf[5] | 0) + n | 0)
                    <=
                    caml_ml_bytes_length(lexbuf[2]))
                   blit
                    (lexbuf[2],lexbuf[5],lexbuf[2],0,lexbuf[3] - lexbuf[5] | 0);
                  else
                   {var
                     newlen=
                      min
                       (2 * caml_ml_bytes_length(lexbuf[2]) | 0,max_string_length);
                    if(newlen < ((lexbuf[3] - lexbuf[5] | 0) + n | 0))
                     failwith(cst_Lexing_lex_refill_cannot_g);
                    var newbuf=caml_create_bytes(newlen);
                    blit(lexbuf[2],lexbuf[5],newbuf,0,lexbuf[3] - lexbuf[5] | 0);
                    lexbuf[2] = newbuf}
                  var s=lexbuf[5];
                  lexbuf[4] = lexbuf[4] + s | 0;
                  lexbuf[6] = lexbuf[6] - s | 0;
                  lexbuf[5] = 0;
                  lexbuf[7] = lexbuf[7] - s | 0;
                  lexbuf[3] = lexbuf[3] - s | 0;
                  var t=lexbuf[10],_wX_=t.length - 1 - 1 | 0,_wW_=0;
                  if(! (_wX_ < 0))
                   {var i=_wW_;
                    for(;;)
                     {var v=caml_check_bound(t,i)[1 + i];
                      if(0 <= v)caml_check_bound(t,i)[1 + i] = v - s | 0;
                      var _wY_=i + 1 | 0;
                      if(_wX_ !== i){var i=_wY_;continue}
                      break}}}
                blit(aux_buffer,0,lexbuf[2],lexbuf[3],n);
                lexbuf[3] = lexbuf[3] + n | 0;
                return 0},
              _wV_,
              _wU_,
              _wT_,
              _wS_,
              _wR_,
              _wQ_,
              _wP_,
              _wO_,
              _wN_,
              _wM_,
              _wL_]}
    function from_channel(with_positions,ic)
     {return from_function
              (with_positions,function(buf,n){return input(ic,buf,0,n)})}
    function from_string$0(opt,s)
     {if(opt)var sth=opt[1],with_positions=sth;else var with_positions=1;
      var
       _wA_=with_positions?zero_pos:dummy_pos,
       _wB_=with_positions?zero_pos:dummy_pos,
       _wC_=[0],
       _wD_=1,
       _wE_=0,
       _wF_=0,
       _wG_=0,
       _wH_=0,
       _wI_=0,
       _wJ_=caml_ml_string_length(s),
       _wK_=of_string(s);
      return [0,
              function(lexbuf){lexbuf[9] = 1;return 0},
              _wK_,
              _wJ_,
              _wI_,
              _wH_,
              _wG_,
              _wF_,
              _wE_,
              _wD_,
              _wC_,
              _wB_,
              _wA_]}
    function set_position(lexbuf,position)
     {lexbuf[12] = [0,lexbuf[12][1],position[2],position[3],position[4]];
      lexbuf[4] = position[4];
      return 0}
    function set_filename(lexbuf,fname)
     {var _wz_=lexbuf[12];
      lexbuf[12] = [0,fname,_wz_[2],_wz_[3],_wz_[4]];
      return 0}
    function with_positions(lexbuf){return lexbuf[12] !== dummy_pos?1:0}
    function lexeme(lexbuf)
     {var len=lexbuf[6] - lexbuf[5] | 0;
      return sub_string(lexbuf[2],lexbuf[5],len)}
    function sub_lexeme(lexbuf,i1,i2)
     {var len=i2 - i1 | 0;return sub_string(lexbuf[2],i1,len)}
    function sub_lexeme_opt(lexbuf,i1,i2)
     {if(0 <= i1){var len=i2 - i1 | 0;return [0,sub_string(lexbuf[2],i1,len)]}
      return 0}
    function sub_lexeme_char(lexbuf,i){return caml_bytes_get(lexbuf[2],i)}
    function sub_lexeme_char_opt(lexbuf,i)
     {return 0 <= i?[0,caml_bytes_get(lexbuf[2],i)]:0}
    function lexeme_char(lexbuf,i)
     {return caml_bytes_get(lexbuf[2],lexbuf[5] + i | 0)}
    function lexeme_start(lexbuf){return lexbuf[11][4]}
    function lexeme_end(lexbuf){return lexbuf[12][4]}
    function lexeme_start_p(lexbuf){return lexbuf[11]}
    function lexeme_end_p(lexbuf){return lexbuf[12]}
    function new_line(lexbuf)
     {var
       lcp=lexbuf[12],
       _wx_=lcp !== dummy_pos?1:0,
       _wy_=_wx_?(lexbuf[12] = [0,lcp[1],lcp[2] + 1 | 0,lcp[4],lcp[4]],0):_wx_;
      return _wy_}
    function flush_input(lb)
     {lb[6] = 0;
      lb[4] = 0;
      var lcp=lb[12];
      if(lcp !== dummy_pos)
       lb[12] = [0,lcp[1],zero_pos[2],zero_pos[3],zero_pos[4]];
      lb[3] = 0;
      return 0}
    var
     Stdlib_lexing=
      [0,
       dummy_pos,
       from_channel,
       from_string$0,
       from_function,
       set_position,
       set_filename,
       with_positions,
       lexeme,
       lexeme_char,
       lexeme_start,
       lexeme_end,
       lexeme_start_p,
       lexeme_end_p,
       new_line,
       flush_input,
       sub_lexeme,
       sub_lexeme_opt,
       sub_lexeme_char,
       sub_lexeme_char_opt,
       engine,
       new_engine];
    caml_register_global(780,Stdlib_lexing,"Stdlib__lexing");
    var
     YYexit=[248,cst_Stdlib_Parsing_YYexit,caml_fresh_oo_id(0)],
     Parse_error=[248,cst_Stdlib_Parsing_Parse_error,caml_fresh_oo_id(0)],
     env=
      [0,
       caml_make_vect(100,0),
       caml_make_vect(100,0),
       caml_make_vect(100,dummy_pos),
       caml_make_vect(100,dummy_pos),
       100,
       0,
       0,
       0,
       dummy_pos,
       dummy_pos,
       0,
       0,
       0,
       0,
       0,
       0];
    function grow_stacks(param)
     {var
       oldsize=env[5],
       newsize=oldsize * 2 | 0,
       new_s=caml_make_vect(newsize,0),
       new_v=caml_make_vect(newsize,0),
       new_start=caml_make_vect(newsize,dummy_pos),
       new_end=caml_make_vect(newsize,dummy_pos);
      blit$1(env[1],0,new_s,0,oldsize);
      env[1] = new_s;
      blit$1(env[2],0,new_v,0,oldsize);
      env[2] = new_v;
      blit$1(env[3],0,new_start,0,oldsize);
      env[3] = new_start;
      blit$1(env[4],0,new_end,0,oldsize);
      env[4] = new_end;
      env[5] = newsize;
      return 0}
    function clear_parser(param)
     {fill$0(env[2],0,env[5],0);env[8] = 0;return 0}
    var current_lookahead_fun=[0,function(param){return 0}];
    function yyparse(tables,start,lexer,lexbuf)
     {var
       init_asp=env[11],
       init_sp=env[14],
       init_stackbase=env[6],
       init_state=env[15],
       init_curr_char=env[7],
       init_lval=env[8],
       init_errflag=env[16];
      env[6] = env[14] + 1 | 0;
      env[7] = start;
      env[10] = lexbuf[12];
      try
       {var cmd=0,arg=0;
        for(;;)
         {var match=runtime.caml_parse_engine(tables,env,cmd,arg);
          switch(match)
           {case 0:
             var arg$0=caml_call1(lexer,lexbuf);
             env[9] = lexbuf[11];
             env[10] = lexbuf[12];
             var cmd=1,arg=arg$0;
             continue;
            case 1:throw Parse_error;
            case 2:grow_stacks(0);var cmd=2,arg=0;continue;
            case 3:grow_stacks(0);var cmd=3,arg=0;continue;
            case 4:
             try
              {var
                _wr_=env[13],
                _ws_=
                 caml_call1(caml_check_bound(tables[1],_wr_)[1 + _wr_],env),
                _wt_=4,
                arg$1=_ws_,
                cmd$0=_wt_}
             catch(_ww_)
              {_ww_ = caml_wrap_exception(_ww_);
               if(_ww_ !== Parse_error)throw _ww_;
               var arg$1=0,cmd$0=5,_wu_=_ww_}
             var cmd=cmd$0,arg=arg$1;
             continue;
            default:
             caml_call1(tables[14],cst_syntax_error);var cmd=5,arg=0;continue}}}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        var curr_char=env[7];
        env[11] = init_asp;
        env[14] = init_sp;
        env[6] = init_stackbase;
        env[15] = init_state;
        env[7] = init_curr_char;
        env[8] = init_lval;
        env[16] = init_errflag;
        if(exn[1] === YYexit){var v=exn[2];return v}
        current_lookahead_fun[1]
        =
        function(tok)
         {if(is_block(tok))
           {var _wv_=caml_obj_tag(tok);
            return caml_check_bound(tables[3],_wv_)[1 + _wv_] === curr_char
                    ?1
                    :0}
          return caml_check_bound(tables[2],tok)[1 + tok] === curr_char?1:0};
        throw exn}}
    function peek_val(env,n)
     {var _wq_=env[11] - n | 0;return caml_check_bound(env[2],_wq_)[1 + _wq_]}
    function symbol_start_pos(param)
     {var i=env[12];
      for(;;)
       {if(0 < i)
         {var
           _wn_=(env[11] - i | 0) + 1 | 0,
           st=caml_check_bound(env[3],_wn_)[1 + _wn_],
           _wo_=(env[11] - i | 0) + 1 | 0,
           en=caml_check_bound(env[4],_wo_)[1 + _wo_];
          if(caml_notequal(st,en))return st;
          var i$0=i - 1 | 0,i=i$0;
          continue}
        var _wp_=env[11];
        return caml_check_bound(env[4],_wp_)[1 + _wp_]}}
    function symbol_end_pos(param)
     {var _wm_=env[11];return caml_check_bound(env[4],_wm_)[1 + _wm_]}
    function rhs_start_pos(n)
     {var _wl_=env[11] - (env[12] - n | 0) | 0;
      return caml_check_bound(env[3],_wl_)[1 + _wl_]}
    function rhs_end_pos(n)
     {var _wk_=env[11] - (env[12] - n | 0) | 0;
      return caml_check_bound(env[4],_wk_)[1 + _wk_]}
    function symbol_start(param){return symbol_start_pos(0)[4]}
    function symbol_end(param){return symbol_end_pos(0)[4]}
    function rhs_start(n){return rhs_start_pos(n)[4]}
    function rhs_end(n){return rhs_end_pos(n)[4]}
    function is_current_lookahead(tok)
     {return caml_call1(current_lookahead_fun[1],tok)}
    function parse_error(param){return 0}
    var
     Stdlib_parsing=
      [0,
       symbol_start,
       symbol_end,
       rhs_start,
       rhs_end,
       symbol_start_pos,
       symbol_end_pos,
       rhs_start_pos,
       rhs_end_pos,
       clear_parser,
       Parse_error,
       function(_wj_){return runtime.caml_set_parser_trace(_wj_)},
       YYexit,
       yyparse,
       peek_val,
       is_current_lookahead,
       parse_error];
    caml_register_global(781,Stdlib_parsing,"Stdlib__parsing");
    var
     Stdlib_set=
      [0,
       function(Ord)
        {function height(param){if(param){var h=param[4];return h}return 0}
         function create(l,v,r)
          {if(l)var h=l[4],hl=h;else var hl=0;
           if(r)var h$0=r[4],hr=h$0;else var hr=0;
           var _wi_=hr <= hl?hl + 1 | 0:hr + 1 | 0;
           return [0,l,v,r,_wi_]}
         function bal(l,v,r)
          {if(l)var h=l[4],hl=h;else var hl=0;
           if(r)var h$0=r[4],hr=h$0;else var hr=0;
           if((hr + 2 | 0) < hl)
            {if(l)
              {var lr=l[3],lv=l[2],ll=l[1],_wd_=height(lr);
               if(_wd_ <= height(ll))return create(ll,lv,create(lr,v,r));
               if(lr)
                {var lrr=lr[3],lrv=lr[2],lrl=lr[1],_we_=create(lrr,v,r);
                 return create(create(ll,lv,lrl),lrv,_we_)}
               return invalid_arg(cst_Set_bal)}
             return invalid_arg(cst_Set_bal$0)}
           if((hl + 2 | 0) < hr)
            {if(r)
              {var rr=r[3],rv=r[2],rl=r[1],_wf_=height(rl);
               if(_wf_ <= height(rr))return create(create(l,v,rl),rv,rr);
               if(rl)
                {var rlr=rl[3],rlv=rl[2],rll=rl[1],_wg_=create(rlr,rv,rr);
                 return create(create(l,v,rll),rlv,_wg_)}
               return invalid_arg(cst_Set_bal$1)}
             return invalid_arg(cst_Set_bal$2)}
           var _wh_=hr <= hl?hl + 1 | 0:hr + 1 | 0;
           return [0,l,v,r,_wh_]}
         function add(x,t)
          {if(t)
            {var r=t[3],v=t[2],l=t[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)return t;
             if(0 <= c){var rr=add(x,r);return r === rr?t:bal(l,v,rr)}
             var ll=add(x,l);
             return l === ll?t:bal(ll,v,r)}
           return [0,0,x,0,1]}
         function singleton(x){return [0,0,x,0,1]}
         function add_min_element(x,param)
          {if(param)
            {var r=param[3],v=param[2],l=param[1];
             return bal(add_min_element(x,l),v,r)}
           return singleton(x)}
         function add_max_element(x,param)
          {if(param)
            {var r=param[3],v=param[2],l=param[1];
             return bal(l,v,add_max_element(x,r))}
           return singleton(x)}
         function join(l,v,r)
          {if(l)
            {if(r)
              {var
                rh=r[4],
                rr=r[3],
                rv=r[2],
                rl=r[1],
                lh=l[4],
                lr=l[3],
                lv=l[2],
                ll=l[1];
               return (rh + 2 | 0) < lh
                       ?bal(ll,lv,join(lr,v,r))
                       :(lh + 2 | 0) < rh?bal(join(l,v,rl),rv,rr):create(l,v,r)}
             return add_max_element(v,l)}
           return add_min_element(v,r)}
         function min_elt(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var _wc_=param$0[1];
               if(_wc_){var param$0=_wc_;continue}
               var v=param$0[2];
               return v}
             throw Not_found}}
         function min_elt_opt(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var _wb_=param$0[1];
               if(_wb_){var param$0=_wb_;continue}
               var v=param$0[2];
               return [0,v]}
             return 0}}
         function max_elt(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {if(param$0[3]){var param$1=param$0[3],param$0=param$1;continue}
               var v=param$0[2];
               return v}
             throw Not_found}}
         function max_elt_opt(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {if(param$0[3]){var param$1=param$0[3],param$0=param$1;continue}
               var v=param$0[2];
               return [0,v]}
             return 0}}
         function remove_min_elt(param)
          {if(param)
            {var _wa_=param[1];
             if(_wa_)
              {var r=param[3],v=param[2];return bal(remove_min_elt(_wa_),v,r)}
             var r$0=param[3];
             return r$0}
           return invalid_arg(cst_Set_remove_min_elt)}
         function concat(t,match)
          {if(t)
            {if(match)
              {var _v$_=remove_min_elt(match);
               return join(t,min_elt(match),_v$_)}
             return t}
           return match}
         function split(x,param)
          {if(param)
            {var r=param[3],v=param[2],l=param[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)return [0,l,1,r];
             if(0 <= c)
              {var match=split(x,r),rr=match[3],pres=match[2],lr=match[1];
               return [0,join(l,v,lr),pres,rr]}
             var
              match$0=split(x,l),
              rl=match$0[3],
              pres$0=match$0[2],
              ll=match$0[1];
             return [0,ll,pres$0,join(rl,v,r)]}
           return _I_}
         var empty=0;
         function is_empty(param){return param?0:1}
         function mem(x,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[3],
                v=param$0[2],
                l=param$0[1],
                c=caml_call2(Ord[1],x,v),
                _v__=0 === c?1:0;
               if(_v__)return _v__;
               var param$1=0 <= c?r:l,param$0=param$1;
               continue}
             return 0}}
         function remove(x,t)
          {if(t)
            {var r=t[3],v=t[2],l=t[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)
              {if(l)
                {if(r)
                  {var _v9_=remove_min_elt(r);return bal(l,min_elt(r),_v9_)}
                 return l}
               return r}
             if(0 <= c){var rr=remove(x,r);return r === rr?t:bal(l,v,rr)}
             var ll=remove(x,l);
             return l === ll?t:bal(ll,v,r)}
           return 0}
         function union(t1,match)
          {if(t1)
            {if(match)
              {var
                h2=match[4],
                r2=match[3],
                v2=match[2],
                l2=match[1],
                h1=t1[4],
                r1=t1[3],
                v1=t1[2],
                l1=t1[1];
               if(h2 <= h1)
                {if(1 === h2)return add(v2,t1);
                 var
                  match$0=split(v1,match),
                  r2$0=match$0[3],
                  l2$0=match$0[1],
                  _v7_=union(r1,r2$0);
                 return join(union(l1,l2$0),v1,_v7_)}
               if(1 === h1)return add(v1,match);
               var
                match$1=split(v2,t1),
                r1$0=match$1[3],
                l1$0=match$1[1],
                _v8_=union(r1$0,r2);
               return join(union(l1$0,l2),v2,_v8_)}
             return t1}
           return match}
         function inter(s1,match)
          {if(s1)
            {if(match)
              {var
                r1=s1[3],
                v1=s1[2],
                l1=s1[1],
                _v3_=split(v1,match),
                _v4_=_v3_[1];
               if(_v3_[2])
                {var r2=_v3_[3],_v5_=inter(r1,r2);
                 return join(inter(l1,_v4_),v1,_v5_)}
               var r2$0=_v3_[3],_v6_=inter(r1,r2$0);
               return concat(inter(l1,_v4_),_v6_)}
             return 0}
           return 0}
         function split_bis(x,param)
          {if(param)
            {var r=param[3],v=param[2],l=param[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)return 0;
             if(0 <= c)
              {var match=split_bis(x,r);
               if(match)
                {var rr=match[2],lr=match[1];return [0,join(l,v,lr),rr]}
               return 0}
             var match$0=split_bis(x,l);
             if(match$0)
              {var rl=match$0[2],ll=match$0[1];
               return [0,
                       ll,
                       function(param){return join(caml_call1(rl,0),v,r)}]}
             return 0}
           return [0,0,function(param){return 0}]}
         function disjoint(s1,s2)
          {var s1$0=s1,s2$0=s2;
           for(;;)
            {if(s1$0 && s2$0)
              {var r1=s1$0[3],v1=s1$0[2],l1=s1$0[1];
               if(s1$0 === s2$0)return 0;
               var match=split_bis(v1,s2$0);
               if(match)
                {var r2=match[2],l2=match[1],_v2_=disjoint(l1,l2);
                 if(_v2_)
                  {var s2$1=caml_call1(r2,0),s1$0=r1,s2$0=s2$1;continue}
                 return _v2_}
               return 0}
             return 1}}
         function diff(t1,match)
          {if(t1)
            {if(match)
              {var
                r1=t1[3],
                v1=t1[2],
                l1=t1[1],
                _vY_=split(v1,match),
                _vZ_=_vY_[1];
               if(_vY_[2])
                {var r2=_vY_[3],_v0_=diff(r1,r2);
                 return concat(diff(l1,_vZ_),_v0_)}
               var r2$0=_vY_[3],_v1_=diff(r1,r2$0);
               return join(diff(l1,_vZ_),v1,_v1_)}
             return t1}
           return 0}
         function cons_enum(s,e)
          {var s$0=s,e$0=e;
           for(;;)
            {if(s$0)
              {var
                r=s$0[3],
                v=s$0[2],
                s$1=s$0[1],
                e$1=[0,v,r,e$0],
                s$0=s$1,
                e$0=e$1;
               continue}
             return e$0}}
         function compare(s1,s2)
          {var e2$2=cons_enum(s2,0),e1$2=cons_enum(s1,0),e1=e1$2,e2=e2$2;
           for(;;)
            {if(e1)
              {if(e2)
                {var
                  e2$0=e2[3],
                  r2=e2[2],
                  v2=e2[1],
                  e1$0=e1[3],
                  r1=e1[2],
                  v1=e1[1],
                  c=caml_call2(Ord[1],v1,v2);
                 if(0 === c)
                  {var
                    e2$1=cons_enum(r2,e2$0),
                    e1$1=cons_enum(r1,e1$0),
                    e1=e1$1,
                    e2=e2$1;
                   continue}
                 return c}
               return 1}
             return e2?-1:0}}
         function equal(s1,s2){return 0 === compare(s1,s2)?1:0}
         function subset(s1,s2)
          {var s1$0=s1,s2$0=s2;
           for(;;)
            {if(s1$0)
              {if(s2$0)
                {var
                  r2=s2$0[3],
                  v2=s2$0[2],
                  l2=s2$0[1],
                  r1=s1$0[3],
                  v1=s1$0[2],
                  l1=s1$0[1],
                  c=caml_call2(Ord[1],v1,v2);
                 if(0 === c)
                  {var _vV_=subset(l1,l2);
                   if(_vV_){var s1$0=r1,s2$0=r2;continue}
                   return _vV_}
                 if(0 <= c)
                  {var _vW_=subset([0,0,v1,r1,0],r2);
                   if(_vW_){var s1$0=l1;continue}
                   return _vW_}
                 var _vX_=subset([0,l1,v1,0,0],l2);
                 if(_vX_){var s1$0=r1;continue}
                 return _vX_}
               return 0}
             return 1}}
         function iter(f,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var r=param$0[3],v=param$0[2],l=param$0[1];
               iter(f,l);
               caml_call1(f,v);
               var param$0=r;
               continue}
             return 0}}
         function fold(f,s,accu)
          {var s$0=s,accu$0=accu;
           for(;;)
            {if(s$0)
              {var
                r=s$0[3],
                v=s$0[2],
                l=s$0[1],
                accu$1=caml_call2(f,v,fold(f,l,accu$0)),
                s$0=r,
                accu$0=accu$1;
               continue}
             return accu$0}}
         function for_all(p,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[3],
                v=param$0[2],
                l=param$0[1],
                _vS_=caml_call1(p,v);
               if(_vS_)
                {var _vT_=for_all(p,l);
                 if(_vT_){var param$0=r;continue}
                 var _vU_=_vT_}
               else
                var _vU_=_vS_;
               return _vU_}
             return 1}}
         function exists(p,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[3],
                v=param$0[2],
                l=param$0[1],
                _vP_=caml_call1(p,v);
               if(_vP_)
                var _vQ_=_vP_;
               else
                {var _vR_=exists(p,l);
                 if(! _vR_){var param$0=r;continue}
                 var _vQ_=_vR_}
               return _vQ_}
             return 0}}
         function filter(p,t)
          {if(t)
            {var
              r=t[3],
              v=t[2],
              l=t[1],
              l$0=filter(p,l),
              pv=caml_call1(p,v),
              r$0=filter(p,r);
             if(pv){if(l === l$0 && r === r$0)return t;return join(l$0,v,r$0)}
             return concat(l$0,r$0)}
           return 0}
         function partition(p,param)
          {if(param)
            {var
              r=param[3],
              v=param[2],
              l=param[1],
              match=partition(p,l),
              lf=match[2],
              lt=match[1],
              pv=caml_call1(p,v),
              match$0=partition(p,r),
              rf=match$0[2],
              rt=match$0[1];
             if(pv){var _vN_=concat(lf,rf);return [0,join(lt,v,rt),_vN_]}
             var _vO_=join(lf,v,rf);
             return [0,concat(lt,rt),_vO_]}
           return _J_}
         function cardinal(param)
          {if(param)
            {var r=param[3],l=param[1],_vM_=cardinal(r);
             return (cardinal(l) + 1 | 0) + _vM_ | 0}
           return 0}
         function elements_aux(accu,param)
          {var accu$0=accu,param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[3],
                v=param$0[2],
                l=param$0[1],
                accu$1=[0,v,elements_aux(accu$0,r)],
                accu$0=accu$1,
                param$0=l;
               continue}
             return accu$0}}
         function elements(s){return elements_aux(0,s)}
         function find(x,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[3],
                v=param$0[2],
                l=param$0[1],
                c=caml_call2(Ord[1],x,v);
               if(0 === c)return v;
               var param$1=0 <= c?r:l,param$0=param$1;
               continue}
             throw Not_found}}
         function find_first(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var r$0=param$1[3],v$0=param$1[2],l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,param=l$0;
                 for(;;)
                  {if(param)
                    {var r=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,param=l;continue}
                     var param=r;
                     continue}
                   return v0}}
               var param$1=r$0;
               continue}
             throw Not_found}}
         function find_first_opt(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var r$0=param$1[3],v$0=param$1[2],l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,param=l$0;
                 for(;;)
                  {if(param)
                    {var r=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,param=l;continue}
                     var param=r;
                     continue}
                   return [0,v0]}}
               var param$1=r$0;
               continue}
             return 0}}
         function find_last(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var r$0=param$1[3],v$0=param$1[2],l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,param=r$0;
                 for(;;)
                  {if(param)
                    {var r=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,param=r;continue}
                     var param=l;
                     continue}
                   return v0}}
               var param$1=l$0;
               continue}
             throw Not_found}}
         function find_last_opt(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var r$0=param$1[3],v$0=param$1[2],l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,param=r$0;
                 for(;;)
                  {if(param)
                    {var r=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,param=r;continue}
                     var param=l;
                     continue}
                   return [0,v0]}}
               var param$1=l$0;
               continue}
             return 0}}
         function find_opt(x,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[3],
                v=param$0[2],
                l=param$0[1],
                c=caml_call2(Ord[1],x,v);
               if(0 === c)return [0,v];
               var param$1=0 <= c?r:l,param$0=param$1;
               continue}
             return 0}}
         function try_join(l,v,r)
          {var switch$0=0;
           if(0 !== l)
            {var _vL_=max_elt(l);
             if(0 <= caml_call2(Ord[1],_vL_,v))switch$0 = 1}
           if(! switch$0)
            {var switch$1=0;
             if(0 !== r)
              {var _vK_=min_elt(r);
               if(0 <= caml_call2(Ord[1],v,_vK_))switch$1 = 1}
             if(! switch$1)return join(l,v,r)}
           return union(l,add(v,r))}
         function map(f,t)
          {if(t)
            {var
              r=t[3],
              v=t[2],
              l=t[1],
              l$0=map(f,l),
              v$0=caml_call1(f,v),
              r$0=map(f,r);
             if(l === l$0 && v === v$0 && r === r$0)return t;
             return try_join(l$0,v$0,r$0)}
           return 0}
         function filter_map(f,t)
          {if(t)
            {var
              r=t[3],
              v=t[2],
              l=t[1],
              t$0=filter_map(f,l),
              v$0=caml_call1(f,v),
              match=filter_map(f,r);
             if(v$0)
              {var v$1=v$0[1];
               if(l === t$0 && v === v$1 && r === match)return t;
               return try_join(t$0,v$1,match)}
             if(t$0)
              {if(match)
                {var _vJ_=remove_min_elt(match);
                 return try_join(t$0,min_elt(match),_vJ_)}
               return t$0}
             return match}
           return 0}
         function of_list(l)
          {if(l)
            {var _vy_=l[2],_vz_=l[1];
             if(_vy_)
              {var _vA_=_vy_[2],_vB_=_vy_[1];
               if(_vA_)
                {var _vC_=_vA_[2],_vD_=_vA_[1];
                 if(_vC_)
                  {var _vE_=_vC_[2],_vF_=_vC_[1];
                   if(_vE_)
                    {if(_vE_[2])
                      {var
                        l$0=sort_uniq(Ord[1],l),
                        sub=
                         function(n,l)
                          {if(! (3 < n >>> 0))
                            switch(n)
                             {case 0:return [0,0,l];
                              case 1:
                               if(l){var l$3=l[2],x0=l[1];return [0,[0,0,x0,0,1],l$3]}
                               break;
                              case 2:
                               if(l)
                                {var _vG_=l[2];
                                 if(_vG_)
                                  {var l$4=_vG_[2],x1=_vG_[1],x0$0=l[1];
                                   return [0,[0,[0,0,x0$0,0,1],x1,0,2],l$4]}}
                               break;
                              default:
                               if(l)
                                {var _vH_=l[2];
                                 if(_vH_)
                                  {var _vI_=_vH_[2];
                                   if(_vI_)
                                    {var l$5=_vI_[2],x2=_vI_[1],x1$0=_vH_[1],x0$1=l[1];
                                     return [0,[0,[0,0,x0$1,0,1],x1$0,[0,0,x2,0,1],2],l$5]}}}}
                           var nl=n / 2 | 0,match=sub(nl,l),l$0=match[2],left=match[1];
                           if(l$0)
                            {var
                              l$1=l$0[2],
                              mid=l$0[1],
                              match$0=sub((n - nl | 0) - 1 | 0,l$1),
                              l$2=match$0[2],
                              right=match$0[1];
                             return [0,create(left,mid,right),l$2]}
                           throw [0,Assert_failure,_K_]};
                       return sub(length(l$0),l$0)[1]}
                     var x4=_vE_[1];
                     return add(x4,add(_vF_,add(_vD_,add(_vB_,singleton(_vz_)))))}
                   return add(_vF_,add(_vD_,add(_vB_,singleton(_vz_))))}
                 return add(_vD_,add(_vB_,singleton(_vz_)))}
               return add(_vB_,singleton(_vz_))}
             return singleton(_vz_)}
           return empty}
         function add_seq(i,m)
          {return fold_left(function(s,x){return add(x,s)},m,i)}
         function of_seq(i){return add_seq(i,empty)}
         function seq_of_enum(c,param)
          {if(c)
            {var rest=c[3],t=c[2],x=c[1],_vw_=cons_enum(t,rest);
             return [0,x,function(_vx_){return seq_of_enum(_vw_,_vx_)}]}
           return 0}
         function to_seq(c)
          {var _vu_=cons_enum(c,0);
           return function(_vv_){return seq_of_enum(_vu_,_vv_)}}
         function snoc_enum(s,e)
          {var s$0=s,e$0=e;
           for(;;)
            {if(s$0)
              {var
                s$1=s$0[3],
                v=s$0[2],
                l=s$0[1],
                e$1=[0,v,l,e$0],
                s$0=s$1,
                e$0=e$1;
               continue}
             return e$0}}
         function rev_seq_of_enum(c,param)
          {if(c)
            {var rest=c[3],t=c[2],x=c[1],_vs_=snoc_enum(t,rest);
             return [0,x,function(_vt_){return rev_seq_of_enum(_vs_,_vt_)}]}
           return 0}
         function to_rev_seq(c)
          {var _vq_=snoc_enum(c,0);
           return function(_vr_){return rev_seq_of_enum(_vq_,_vr_)}}
         function to_seq_from(low,s)
          {var s$0=s,c=0;
           for(;;)
            {if(s$0)
              {var r=s$0[3],v=s$0[2],l=s$0[1],n=caml_call2(Ord[1],v,low);
               if(0 !== n)
                {if(0 <= n){var c$0=[0,v,r,c],s$0=l,c=c$0;continue}
                 var s$0=r;
                 continue}
               var _vo_=[0,v,r,c]}
             else
              var _vo_=c;
             return function(_vp_){return seq_of_enum(_vo_,_vp_)}}}
         return [0,
                 empty,
                 is_empty,
                 mem,
                 add,
                 singleton,
                 remove,
                 union,
                 inter,
                 disjoint,
                 diff,
                 compare,
                 equal,
                 subset,
                 iter,
                 map,
                 fold,
                 for_all,
                 exists,
                 filter,
                 filter_map,
                 partition,
                 cardinal,
                 elements,
                 min_elt,
                 min_elt_opt,
                 max_elt,
                 max_elt_opt,
                 min_elt,
                 min_elt_opt,
                 split,
                 find,
                 find_opt,
                 find_first,
                 find_first_opt,
                 find_last,
                 find_last_opt,
                 of_list,
                 to_seq_from,
                 to_seq,
                 to_rev_seq,
                 add_seq,
                 of_seq]}];
    caml_register_global(782,Stdlib_set,"Stdlib__set");
    var
     Stdlib_map=
      [0,
       function(Ord)
        {function height(param){if(param){var h=param[5];return h}return 0}
         function create(l,x,d,r)
          {var hl=height(l),hr=height(r),_vn_=hr <= hl?hl + 1 | 0:hr + 1 | 0;
           return [0,l,x,d,r,_vn_]}
         function singleton(x,d){return [0,0,x,d,0,1]}
         function bal(l,x,d,r)
          {if(l)var h=l[5],hl=h;else var hl=0;
           if(r)var h$0=r[5],hr=h$0;else var hr=0;
           if((hr + 2 | 0) < hl)
            {if(l)
              {var lr=l[4],ld=l[3],lv=l[2],ll=l[1],_vi_=height(lr);
               if(_vi_ <= height(ll))return create(ll,lv,ld,create(lr,x,d,r));
               if(lr)
                {var
                  lrr=lr[4],
                  lrd=lr[3],
                  lrv=lr[2],
                  lrl=lr[1],
                  _vj_=create(lrr,x,d,r);
                 return create(create(ll,lv,ld,lrl),lrv,lrd,_vj_)}
               return invalid_arg(cst_Map_bal)}
             return invalid_arg(cst_Map_bal$0)}
           if((hl + 2 | 0) < hr)
            {if(r)
              {var rr=r[4],rd=r[3],rv=r[2],rl=r[1],_vk_=height(rl);
               if(_vk_ <= height(rr))return create(create(l,x,d,rl),rv,rd,rr);
               if(rl)
                {var
                  rlr=rl[4],
                  rld=rl[3],
                  rlv=rl[2],
                  rll=rl[1],
                  _vl_=create(rlr,rv,rd,rr);
                 return create(create(l,x,d,rll),rlv,rld,_vl_)}
               return invalid_arg(cst_Map_bal$1)}
             return invalid_arg(cst_Map_bal$2)}
           var _vm_=hr <= hl?hl + 1 | 0:hr + 1 | 0;
           return [0,l,x,d,r,_vm_]}
         var empty=0;
         function is_empty(param){return param?0:1}
         function add(x,data,m)
          {if(m)
            {var h=m[5],r=m[4],d=m[3],v=m[2],l=m[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)return d === data?m:[0,l,x,data,r,h];
             if(0 <= c){var rr=add(x,data,r);return r === rr?m:bal(l,v,d,rr)}
             var ll=add(x,data,l);
             return l === ll?m:bal(ll,v,d,r)}
           return [0,0,x,data,0,1]}
         function find(x,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[4],
                d=param$0[3],
                v=param$0[2],
                l=param$0[1],
                c=caml_call2(Ord[1],x,v);
               if(0 === c)return d;
               var param$1=0 <= c?r:l,param$0=param$1;
               continue}
             throw Not_found}}
         function find_first(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var
                r$0=param$1[4],
                d$0=param$1[3],
                v$0=param$1[2],
                l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,d0=d$0,param=l$0;
                 for(;;)
                  {if(param)
                    {var r=param[4],d=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,d0=d,param=l;continue}
                     var param=r;
                     continue}
                   return [0,v0,d0]}}
               var param$1=r$0;
               continue}
             throw Not_found}}
         function find_first_opt(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var
                r$0=param$1[4],
                d$0=param$1[3],
                v$0=param$1[2],
                l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,d0=d$0,param=l$0;
                 for(;;)
                  {if(param)
                    {var r=param[4],d=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,d0=d,param=l;continue}
                     var param=r;
                     continue}
                   return [0,[0,v0,d0]]}}
               var param$1=r$0;
               continue}
             return 0}}
         function find_last(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var
                r$0=param$1[4],
                d$0=param$1[3],
                v$0=param$1[2],
                l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,d0=d$0,param=r$0;
                 for(;;)
                  {if(param)
                    {var r=param[4],d=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,d0=d,param=r;continue}
                     var param=l;
                     continue}
                   return [0,v0,d0]}}
               var param$1=l$0;
               continue}
             throw Not_found}}
         function find_last_opt(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var
                r$0=param$1[4],
                d$0=param$1[3],
                v$0=param$1[2],
                l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,d0=d$0,param=r$0;
                 for(;;)
                  {if(param)
                    {var r=param[4],d=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,d0=d,param=r;continue}
                     var param=l;
                     continue}
                   return [0,[0,v0,d0]]}}
               var param$1=l$0;
               continue}
             return 0}}
         function find_opt(x,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[4],
                d=param$0[3],
                v=param$0[2],
                l=param$0[1],
                c=caml_call2(Ord[1],x,v);
               if(0 === c)return [0,d];
               var param$1=0 <= c?r:l,param$0=param$1;
               continue}
             return 0}}
         function mem(x,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[4],
                v=param$0[2],
                l=param$0[1],
                c=caml_call2(Ord[1],x,v),
                _vh_=0 === c?1:0;
               if(_vh_)return _vh_;
               var param$1=0 <= c?r:l,param$0=param$1;
               continue}
             return 0}}
         function min_binding(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var _vg_=param$0[1];
               if(_vg_){var param$0=_vg_;continue}
               var d=param$0[3],v=param$0[2];
               return [0,v,d]}
             throw Not_found}}
         function min_binding_opt(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var _vf_=param$0[1];
               if(_vf_){var param$0=_vf_;continue}
               var d=param$0[3],v=param$0[2];
               return [0,[0,v,d]]}
             return 0}}
         function max_binding(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {if(param$0[4]){var param$1=param$0[4],param$0=param$1;continue}
               var d=param$0[3],v=param$0[2];
               return [0,v,d]}
             throw Not_found}}
         function max_binding_opt(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {if(param$0[4]){var param$1=param$0[4],param$0=param$1;continue}
               var d=param$0[3],v=param$0[2];
               return [0,[0,v,d]]}
             return 0}}
         function remove_min_binding(param)
          {if(param)
            {var _ve_=param[1];
             if(_ve_)
              {var r=param[4],d=param[3],v=param[2];
               return bal(remove_min_binding(_ve_),v,d,r)}
             var r$0=param[4];
             return r$0}
           return invalid_arg(cst_Map_remove_min_elt)}
         function _uP_(t,match)
          {if(t)
            {if(match)
              {var match$0=min_binding(match),d=match$0[2],x=match$0[1];
               return bal(t,x,d,remove_min_binding(match))}
             return t}
           return match}
         function remove(x,m)
          {if(m)
            {var r=m[4],d=m[3],v=m[2],l=m[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)return _uP_(l,r);
             if(0 <= c){var rr=remove(x,r);return r === rr?m:bal(l,v,d,rr)}
             var ll=remove(x,l);
             return l === ll?m:bal(ll,v,d,r)}
           return 0}
         function update(x,f,m)
          {if(m)
            {var h=m[5],r=m[4],d=m[3],v=m[2],l=m[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)
              {var match=caml_call1(f,[0,d]);
               if(match)
                {var data=match[1];return d === data?m:[0,l,x,data,r,h]}
               return _uP_(l,r)}
             if(0 <= c){var rr=update(x,f,r);return r === rr?m:bal(l,v,d,rr)}
             var ll=update(x,f,l);
             return l === ll?m:bal(ll,v,d,r)}
           var match$0=caml_call1(f,0);
           if(match$0){var data$0=match$0[1];return [0,0,x,data$0,0,1]}
           return 0}
         function iter(f,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var r=param$0[4],d=param$0[3],v=param$0[2],l=param$0[1];
               iter(f,l);
               caml_call2(f,v,d);
               var param$0=r;
               continue}
             return 0}}
         function map(f,param)
          {if(param)
            {var
              h=param[5],
              r=param[4],
              d=param[3],
              v=param[2],
              l=param[1],
              l$0=map(f,l),
              d$0=caml_call1(f,d),
              r$0=map(f,r);
             return [0,l$0,v,d$0,r$0,h]}
           return 0}
         function mapi(f,param)
          {if(param)
            {var
              h=param[5],
              r=param[4],
              d=param[3],
              v=param[2],
              l=param[1],
              l$0=mapi(f,l),
              d$0=caml_call2(f,v,d),
              r$0=mapi(f,r);
             return [0,l$0,v,d$0,r$0,h]}
           return 0}
         function fold(f,m,accu)
          {var m$0=m,accu$0=accu;
           for(;;)
            {if(m$0)
              {var
                r=m$0[4],
                d=m$0[3],
                v=m$0[2],
                l=m$0[1],
                accu$1=caml_call3(f,v,d,fold(f,l,accu$0)),
                m$0=r,
                accu$0=accu$1;
               continue}
             return accu$0}}
         function for_all(p,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[4],
                d=param$0[3],
                v=param$0[2],
                l=param$0[1],
                _vb_=caml_call2(p,v,d);
               if(_vb_)
                {var _vc_=for_all(p,l);
                 if(_vc_){var param$0=r;continue}
                 var _vd_=_vc_}
               else
                var _vd_=_vb_;
               return _vd_}
             return 1}}
         function exists(p,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[4],
                d=param$0[3],
                v=param$0[2],
                l=param$0[1],
                _u__=caml_call2(p,v,d);
               if(_u__)
                var _u$_=_u__;
               else
                {var _va_=exists(p,l);
                 if(! _va_){var param$0=r;continue}
                 var _u$_=_va_}
               return _u$_}
             return 0}}
         function add_min_binding(k,x,param)
          {if(param)
            {var r=param[4],d=param[3],v=param[2],l=param[1];
             return bal(add_min_binding(k,x,l),v,d,r)}
           return singleton(k,x)}
         function add_max_binding(k,x,param)
          {if(param)
            {var r=param[4],d=param[3],v=param[2],l=param[1];
             return bal(l,v,d,add_max_binding(k,x,r))}
           return singleton(k,x)}
         function join(l,v,d,r)
          {if(l)
            {if(r)
              {var
                rh=r[5],
                rr=r[4],
                rd=r[3],
                rv=r[2],
                rl=r[1],
                lh=l[5],
                lr=l[4],
                ld=l[3],
                lv=l[2],
                ll=l[1];
               return (rh + 2 | 0) < lh
                       ?bal(ll,lv,ld,join(lr,v,d,r))
                       :(lh + 2 | 0) < rh
                         ?bal(join(l,v,d,rl),rv,rd,rr)
                         :create(l,v,d,r)}
             return add_max_binding(v,d,l)}
           return add_min_binding(v,d,r)}
         function concat(t,match)
          {if(t)
            {if(match)
              {var match$0=min_binding(match),d=match$0[2],x=match$0[1];
               return join(t,x,d,remove_min_binding(match))}
             return t}
           return match}
         function concat_or_join(t1,v,d,t2)
          {if(d){var d$0=d[1];return join(t1,v,d$0,t2)}return concat(t1,t2)}
         function split(x,param)
          {if(param)
            {var
              r=param[4],
              d=param[3],
              v=param[2],
              l=param[1],
              c=caml_call2(Ord[1],x,v);
             if(0 === c)return [0,l,[0,d],r];
             if(0 <= c)
              {var match=split(x,r),rr=match[3],pres=match[2],lr=match[1];
               return [0,join(l,v,d,lr),pres,rr]}
             var
              match$0=split(x,l),
              rl=match$0[3],
              pres$0=match$0[2],
              ll=match$0[1];
             return [0,ll,pres$0,join(rl,v,d,r)]}
           return _L_}
         function merge(f,s1,s2)
          {if(s1)
            {var h1=s1[5],r1=s1[4],d1=s1[3],v1=s1[2],l1=s1[1];
             if(height(s2) <= h1)
              {var
                match=split(v1,s2),
                r2=match[3],
                d2=match[2],
                l2=match[1],
                _u6_=merge(f,r1,r2),
                _u7_=caml_call3(f,v1,[0,d1],d2);
               return concat_or_join(merge(f,l1,l2),v1,_u7_,_u6_)}}
           else
            if(! s2)return 0;
           if(s2)
            {var
              r2$0=s2[4],
              d2$0=s2[3],
              v2=s2[2],
              l2$0=s2[1],
              match$0=split(v2,s1),
              r1$0=match$0[3],
              d1$0=match$0[2],
              l1$0=match$0[1],
              _u8_=merge(f,r1$0,r2$0),
              _u9_=caml_call3(f,v2,d1$0,[0,d2$0]);
             return concat_or_join(merge(f,l1$0,l2$0),v2,_u9_,_u8_)}
           throw [0,Assert_failure,_M_]}
         function union(f,s1,s2)
          {if(s1)
            {if(s2)
              {var
                h2=s2[5],
                r2=s2[4],
                d2=s2[3],
                v2=s2[2],
                l2=s2[1],
                h1=s1[5],
                r1=s1[4],
                d1=s1[3],
                v1=s1[2],
                l1=s1[1];
               if(h2 <= h1)
                {var
                  match=split(v1,s2),
                  r2$0=match[3],
                  d2$0=match[2],
                  l2$0=match[1],
                  l=union(f,l1,l2$0),
                  r=union(f,r1,r2$0);
                 if(d2$0)
                  {var d2$1=d2$0[1];
                   return concat_or_join(l,v1,caml_call3(f,v1,d1,d2$1),r)}
                 return join(l,v1,d1,r)}
               var
                match$0=split(v2,s1),
                r1$0=match$0[3],
                d1$0=match$0[2],
                l1$0=match$0[1],
                l$0=union(f,l1$0,l2),
                r$0=union(f,r1$0,r2);
               if(d1$0)
                {var d1$1=d1$0[1];
                 return concat_or_join(l$0,v2,caml_call3(f,v2,d1$1,d2),r$0)}
               return join(l$0,v2,d2,r$0)}
             var s=s1}
           else
            var s=s2;
           return s}
         function filter(p,m)
          {if(m)
            {var
              r=m[4],
              d=m[3],
              v=m[2],
              l=m[1],
              l$0=filter(p,l),
              pvd=caml_call2(p,v,d),
              r$0=filter(p,r);
             if(pvd)
              {if(l === l$0 && r === r$0)return m;return join(l$0,v,d,r$0)}
             return concat(l$0,r$0)}
           return 0}
         function filter_map(f,param)
          {if(param)
            {var
              r=param[4],
              d=param[3],
              v=param[2],
              l=param[1],
              l$0=filter_map(f,l),
              fvd=caml_call2(f,v,d),
              r$0=filter_map(f,r);
             if(fvd){var d$0=fvd[1];return join(l$0,v,d$0,r$0)}
             return concat(l$0,r$0)}
           return 0}
         function partition(p,param)
          {if(param)
            {var
              r=param[4],
              d=param[3],
              v=param[2],
              l=param[1],
              match=partition(p,l),
              lf=match[2],
              lt=match[1],
              pvd=caml_call2(p,v,d),
              match$0=partition(p,r),
              rf=match$0[2],
              rt=match$0[1];
             if(pvd){var _u4_=concat(lf,rf);return [0,join(lt,v,d,rt),_u4_]}
             var _u5_=join(lf,v,d,rf);
             return [0,concat(lt,rt),_u5_]}
           return _N_}
         function cons_enum(m,e)
          {var m$0=m,e$0=e;
           for(;;)
            {if(m$0)
              {var
                r=m$0[4],
                d=m$0[3],
                v=m$0[2],
                m$1=m$0[1],
                e$1=[0,v,d,r,e$0],
                m$0=m$1,
                e$0=e$1;
               continue}
             return e$0}}
         function compare(cmp,m1,m2)
          {var e2$2=cons_enum(m2,0),e1$2=cons_enum(m1,0),e1=e1$2,e2=e2$2;
           for(;;)
            {if(e1)
              {if(e2)
                {var
                  e2$0=e2[4],
                  r2=e2[3],
                  d2=e2[2],
                  v2=e2[1],
                  e1$0=e1[4],
                  r1=e1[3],
                  d1=e1[2],
                  v1=e1[1],
                  c=caml_call2(Ord[1],v1,v2);
                 if(0 === c)
                  {var c$0=caml_call2(cmp,d1,d2);
                   if(0 === c$0)
                    {var
                      e2$1=cons_enum(r2,e2$0),
                      e1$1=cons_enum(r1,e1$0),
                      e1=e1$1,
                      e2=e2$1;
                     continue}
                   return c$0}
                 return c}
               return 1}
             return e2?-1:0}}
         function equal(cmp,m1,m2)
          {var e2$2=cons_enum(m2,0),e1$2=cons_enum(m1,0),e1=e1$2,e2=e2$2;
           for(;;)
            {if(e1)
              {if(e2)
                {var
                  e2$0=e2[4],
                  r2=e2[3],
                  d2=e2[2],
                  v2=e2[1],
                  e1$0=e1[4],
                  r1=e1[3],
                  d1=e1[2],
                  v1=e1[1],
                  _u1_=0 === caml_call2(Ord[1],v1,v2)?1:0;
                 if(_u1_)
                  {var _u2_=caml_call2(cmp,d1,d2);
                   if(_u2_)
                    {var
                      e2$1=cons_enum(r2,e2$0),
                      e1$1=cons_enum(r1,e1$0),
                      e1=e1$1,
                      e2=e2$1;
                     continue}
                   var _u3_=_u2_}
                 else
                  var _u3_=_u1_;
                 return _u3_}
               return 0}
             return e2?0:1}}
         function cardinal(param)
          {if(param)
            {var r=param[4],l=param[1],_u0_=cardinal(r);
             return (cardinal(l) + 1 | 0) + _u0_ | 0}
           return 0}
         function bindings_aux(accu,param)
          {var accu$0=accu,param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[4],
                d=param$0[3],
                v=param$0[2],
                l=param$0[1],
                accu$1=[0,[0,v,d],bindings_aux(accu$0,r)],
                accu$0=accu$1,
                param$0=l;
               continue}
             return accu$0}}
         function bindings(s){return bindings_aux(0,s)}
         function add_seq(i,m)
          {return fold_left
                   (function(m,param)
                     {var v=param[2],k=param[1];return add(k,v,m)},
                    m,
                    i)}
         function of_seq(i){return add_seq(i,empty)}
         function seq_of_enum(c,param)
          {if(c)
            {var rest=c[4],t=c[3],v=c[2],k=c[1],_uY_=cons_enum(t,rest);
             return [0,[0,k,v],function(_uZ_){return seq_of_enum(_uY_,_uZ_)}]}
           return 0}
         function to_seq(m)
          {var _uW_=cons_enum(m,0);
           return function(_uX_){return seq_of_enum(_uW_,_uX_)}}
         function snoc_enum(s,e)
          {var s$0=s,e$0=e;
           for(;;)
            {if(s$0)
              {var
                s$1=s$0[4],
                d=s$0[3],
                v=s$0[2],
                l=s$0[1],
                e$1=[0,v,d,l,e$0],
                s$0=s$1,
                e$0=e$1;
               continue}
             return e$0}}
         function rev_seq_of_enum(c,param)
          {if(c)
            {var rest=c[4],t=c[3],v=c[2],k=c[1],_uU_=snoc_enum(t,rest);
             return [0,
                     [0,k,v],
                     function(_uV_){return rev_seq_of_enum(_uU_,_uV_)}]}
           return 0}
         function to_rev_seq(c)
          {var _uS_=snoc_enum(c,0);
           return function(_uT_){return rev_seq_of_enum(_uS_,_uT_)}}
         function to_seq_from(low,m)
          {var m$0=m,c=0;
           for(;;)
            {if(m$0)
              {var
                r=m$0[4],
                d=m$0[3],
                v=m$0[2],
                l=m$0[1],
                n=caml_call2(Ord[1],v,low);
               if(0 !== n)
                {if(0 <= n){var c$0=[0,v,d,r,c],m$0=l,c=c$0;continue}
                 var m$0=r;
                 continue}
               var _uQ_=[0,v,d,r,c]}
             else
              var _uQ_=c;
             return function(_uR_){return seq_of_enum(_uQ_,_uR_)}}}
         return [0,
                 empty,
                 is_empty,
                 mem,
                 add,
                 update,
                 singleton,
                 remove,
                 merge,
                 union,
                 compare,
                 equal,
                 iter,
                 fold,
                 for_all,
                 exists,
                 filter,
                 filter_map,
                 partition,
                 cardinal,
                 bindings,
                 min_binding,
                 min_binding_opt,
                 max_binding,
                 max_binding_opt,
                 min_binding,
                 min_binding_opt,
                 split,
                 find,
                 find_opt,
                 find_first,
                 find_first_opt,
                 find_last,
                 find_last_opt,
                 map,
                 mapi,
                 to_seq,
                 to_rev_seq,
                 to_seq_from,
                 add_seq,
                 of_seq]}];
    caml_register_global(783,Stdlib_map,"Stdlib__map");
    var Empty=[248,cst_Stdlib_Stack_Empty,caml_fresh_oo_id(0)];
    function create$0(param){return [0,0,0]}
    function clear(s){s[1] = 0;s[2] = 0;return 0}
    function copy$3(s){return [0,s[1],s[2]]}
    function push(x,s){s[1] = [0,x,s[1]];s[2] = s[2] + 1 | 0;return 0}
    function pop(s)
     {var _uO_=s[1];
      if(_uO_)
       {var tl=_uO_[2],hd=_uO_[1];s[1] = tl;s[2] = s[2] - 1 | 0;return hd}
      throw Empty}
    function pop_opt(s)
     {var _uN_=s[1];
      if(_uN_)
       {var tl=_uN_[2],hd=_uN_[1];s[1] = tl;s[2] = s[2] - 1 | 0;return [0,hd]}
      return 0}
    function top(s)
     {var _uM_=s[1];if(_uM_){var hd=_uM_[1];return hd}throw Empty}
    function top_opt(s)
     {var _uL_=s[1];if(_uL_){var hd=_uL_[1];return [0,hd]}return 0}
    function is_empty(s){return 0 === s[1]?1:0}
    function length$1(s){return s[2]}
    function iter$7(f,s){return iter$2(f,s[1])}
    function fold$2(f,acc,s){return fold_left$0(f,acc,s[1])}
    function to_seq$6(s){return to_seq$1(s[1])}
    function add_seq(q,i){return iter(function(x){return push(x,q)},i)}
    function of_seq$4(g){var s=create$0(0);add_seq(s,g);return s}
    var
     Stdlib_stack=
      [0,
       Empty,
       create$0,
       push,
       pop,
       pop_opt,
       top,
       top_opt,
       clear,
       copy$3,
       is_empty,
       length$1,
       iter$7,
       fold$2,
       to_seq$6,
       add_seq,
       of_seq$4];
    caml_register_global(784,Stdlib_stack,"Stdlib__stack");
    var Empty$0=[248,cst_Stdlib_Queue_Empty,caml_fresh_oo_id(0)];
    function create$1(param){return [0,0,0,0]}
    function clear$0(q){q[1] = 0;q[2] = 0;q[3] = 0;return 0}
    function add(x,q)
     {var cell=[0,x,0],_uK_=q[3];
      return _uK_
              ?(q[1] = q[1] + 1 | 0,_uK_[2] = cell,q[3] = cell,0)
              :(q[1] = 1,q[2] = cell,q[3] = cell,0)}
    function peek(q)
     {var _uJ_=q[2];if(_uJ_){var content=_uJ_[1];return content}throw Empty$0}
    function peek_opt(q)
     {var _uI_=q[2];if(_uI_){var content=_uI_[1];return [0,content]}return 0}
    function take(q)
     {var _uG_=q[2];
      if(_uG_)
       {var _uH_=_uG_[1];
        if(_uG_[2])
         {var next=_uG_[2];q[1] = q[1] - 1 | 0;q[2] = next;return _uH_}
        clear$0(q);
        return _uH_}
      throw Empty$0}
    function take_opt(q)
     {var _uE_=q[2];
      if(_uE_)
       {var _uF_=_uE_[1];
        if(_uE_[2])
         {var next=_uE_[2];q[1] = q[1] - 1 | 0;q[2] = next;return [0,_uF_]}
        clear$0(q);
        return [0,_uF_]}
      return 0}
    function copy$4(q)
     {var q_res=[0,q[1],0,0],prev=0,cell=q[2];
      for(;;)
       {if(cell)
         {var content=cell[1],next=cell[2],res=[0,content,0];
          if(prev)prev[2] = res;else q_res[2] = res;
          var prev=res,cell=next;
          continue}
        q_res[3] = prev;
        return q_res}}
    function is_empty$0(q){return 0 === q[1]?1:0}
    function length$2(q){return q[1]}
    function iter$8(f,q)
     {var cell=q[2];
      for(;;)
       {if(cell)
         {var content=cell[1],next=cell[2];
          caml_call1(f,content);
          var cell=next;
          continue}
        return 0}}
    function fold$3(f,accu$1,q)
     {var accu=accu$1,cell=q[2];
      for(;;)
       {if(cell)
         {var
           content=cell[1],
           next=cell[2],
           accu$0=caml_call2(f,accu,content),
           accu=accu$0,
           cell=next;
          continue}
        return accu}}
    function transfer(q1,q2)
     {var _uC_=0 < q1[1]?1:0;
      if(_uC_)
       {var _uD_=q2[3];
        return _uD_
                ?(q2[1]
                  =
                  q2[1]
                  +
                  q1[1]
                  |
                  0,
                  _uD_[2]
                  =
                  q1[2],
                  q2[3]
                  =
                  q1[3],
                  clear$0(q1))
                :(q2[1] = q1[1],q2[2] = q1[2],q2[3] = q1[3],clear$0(q1))}
      return _uC_}
    function to_seq$7(q)
     {function aux(c,param)
       {if(c)
         {var x=c[1],next=c[2];
          return [0,x,function(_uB_){return aux(next,_uB_)}]}
        return 0}
      var _uz_=q[2];
      return function(_uA_){return aux(_uz_,_uA_)}}
    function add_seq$0(q,i){return iter(function(x){return add(x,q)},i)}
    function of_seq$5(g){var q=create$1(0);add_seq$0(q,g);return q}
    var
     Stdlib_queue=
      [0,
       Empty$0,
       create$1,
       add,
       add,
       take,
       take_opt,
       take,
       peek,
       peek_opt,
       peek,
       clear$0,
       copy$4,
       is_empty$0,
       length$2,
       iter$8,
       fold$3,
       transfer,
       to_seq$7,
       add_seq$0,
       of_seq$5];
    caml_register_global(785,Stdlib_queue,"Stdlib__queue");
    var Undefined=[248,cst_CamlinternalLazy_Undefined,caml_fresh_oo_id(0)];
    function raise_undefined(param){throw Undefined}
    function force_lazy_block(blk)
     {var closure=blk[1];
      blk[1] = raise_undefined;
      try
       {var result=caml_call1(closure,0);
        caml_obj_make_forward(blk,result);
        return result}
      catch(e)
       {e = caml_wrap_exception(e);blk[1] = function(param){throw e};throw e}}
    function force_val_lazy_block(blk)
     {var closure=blk[1];
      blk[1] = raise_undefined;
      var result=caml_call1(closure,0);
      caml_obj_make_forward(blk,result);
      return result}
    function force(lzv)
     {var t=caml_obj_tag(lzv);
      return t === 250?lzv[1]:t !== 246?lzv:force_lazy_block(lzv)}
    function force_val(lzv)
     {var t=caml_obj_tag(lzv);
      return t === 250?lzv[1]:t !== 246?lzv:force_val_lazy_block(lzv)}
    var
     CamlinternalLazy=
      [0,Undefined,force_lazy_block,force_val_lazy_block,force,force_val];
    caml_register_global(786,CamlinternalLazy,"CamlinternalLazy");
    function from_fun(f){var x=caml_obj_block(246,1);x[1] = f;return x}
    function from_val(v)
     {var t=caml_obj_tag(v);
      if(t !== 250 && t !== 246 && t !== 253)return v;
      return runtime.caml_lazy_make_forward(v)}
    function is_val(l){return caml_obj_tag(l) !== 246?1:0}
    var
     Stdlib_lazy=
      [0,
       Undefined,
       force_val,
       from_fun,
       from_val,
       is_val,
       from_fun,
       from_val,
       is_val];
    caml_register_global(787,Stdlib_lazy,"Stdlib__lazy");
    var
     Failure$0=[248,cst_Stdlib_Stream_Failure,caml_fresh_oo_id(0)],
     Error=[248,cst_Stdlib_Stream_Error,caml_fresh_oo_id(0)];
    function count(param)
     {if(param){var match=param[1],count=match[1];return count}return 0}
    function data(param)
     {if(param){var match=param[1],data=match[2];return data}return 0}
    function fill_buff(b)
     {b[3] = input(b[1],b[2],0,caml_ml_bytes_length(b[2]));b[4] = 0;return 0}
    function get_data(count,d)
     {var d$0=d;
      for(;;)
       {if(typeof d$0 !== "number")
         switch(d$0[0])
          {case 1:
            var d2=d$0[2],d1=d$0[1],match=get_data(count,d1);
            if(typeof match === "number")
             {var d$0=d2;continue}
            else
             {if(0 === match[0])
               {var d11=match[2],a=match[1];return [0,a,[1,d11,d2]]}
              throw [0,Assert_failure,_O_]}
           case 2:
            var
             f=d$0[1],
             _uv_=caml_obj_tag(f),
             d$1=250 === _uv_?f[1]:246 === _uv_?force_lazy_block(f):f,
             d$0=d$1;
            continue;
           case 3:
            var _uw_=d$0[1],_ux_=_uw_[1];
            if(_ux_)
             {var _uy_=_ux_[1];
              if(_uy_){var a$0=_uy_[1];_uw_[1] = 0;return [0,a$0,d$0]}
              return 0}
            var match$0=caml_call1(_uw_[2],count);
            if(match$0){var a$1=match$0[1];return [0,a$1,d$0]}
            _uw_[1] = _P_;
            return 0;
           case 4:
            var b=d$0[1];
            if(b[3] <= b[4])fill_buff(b);
            if(0 === b[3])return 0;
            var r=caml_bytes_unsafe_get(b[2],b[4]);
            b[4] = b[4] + 1 | 0;
            return [0,r,d$0]
           }
        return d$0}}
    function peek_data(s)
     {for(;;)
       {var _uq_=s[2];
        if(typeof _uq_ === "number")
         return 0;
        else
         switch(_uq_[0])
          {case 0:var a=_uq_[1];return [0,a];
           case 1:
            var d=get_data(s[1],s[2]);
            if(typeof d === "number")
             return 0;
            else
             {if(0 === d[0]){var a$0=d[1];s[2] = d;return [0,a$0]}
              throw [0,Assert_failure,_Q_]}
           case 2:
            var
             f=_uq_[1],
             _ur_=caml_obj_tag(f),
             _us_=250 === _ur_?f[1]:246 === _ur_?force_lazy_block(f):f;
            s[2] = _us_;
            continue;
           case 3:
            var _ut_=_uq_[1],_uu_=_ut_[1];
            if(_uu_){var a$1=_uu_[1];return a$1}
            var x=caml_call1(_ut_[2],s[1]);
            _ut_[1] = [0,x];
            return x;
           default:
            var b=_uq_[1];
            if(b[3] <= b[4])fill_buff(b);
            return 0 === b[3]
                    ?(s[2] = 0,0)
                    :[0,caml_bytes_unsafe_get(b[2],b[4])]}}}
    function peek$0(param)
     {if(param){var s=param[1];return peek_data(s)}return 0}
    function junk_data(s)
     {for(;;)
       {var _uo_=s[2];
        if(typeof _uo_ !== "number")
         switch(_uo_[0])
          {case 0:var d=_uo_[2];s[1] = s[1] + 1 | 0;s[2] = d;return 0;
           case 3:
            var _up_=_uo_[1];
            if(_up_[1]){s[1] = s[1] + 1 | 0;_up_[1] = 0;return 0}
            break;
           case 4:
            var b=_uo_[1];
            if(b[3] <= b[4])fill_buff(b);
            return 0 === b[3]
                    ?(s[2] = 0,0)
                    :(s[1] = s[1] + 1 | 0,b[4] = b[4] + 1 | 0,0)
           }
        var match=peek_data(s);
        if(match)continue;
        return 0}}
    function junk(param)
     {if(param){var data=param[1];return junk_data(data)}return 0}
    function nget_data(n,s)
     {if(0 < n)
       {var match=peek_data(s);
        if(match)
         {var a=match[1];
          junk_data(s);
          var
           match$0=nget_data(n - 1 | 0,s),
           k=match$0[3],
           d=match$0[2],
           al=match$0[1];
          return [0,[0,a,al],[0,a,d],k + 1 | 0]}
        return [0,0,s[2],0]}
      return [0,0,s[2],0]}
    function npeek(n,param)
     {if(param)
       {var
         d$0=param[1],
         match=nget_data(n,d$0),
         len=match[3],
         d=match[2],
         al=match[1];
        d$0[1] = d$0[1] - len | 0;
        d$0[2] = d;
        return al}
      return 0}
    function next(s)
     {var match=peek$0(s);
      if(match){var a=match[1];junk(s);return a}
      throw Failure$0}
    function empty$1(s){var match=peek$0(s);if(match)throw Failure$0;return 0}
    function iter$9(f,strm)
     {for(;;)
       {var match=peek$0(strm);
        if(match){var a=match[1];junk(strm);caml_call1(f,a);continue}
        return 0}}
    function from(f){return [0,[0,0,[3,[0,0,f]]]]}
    function of_list$1(l)
     {var _un_=0;
      return [0,[0,0,fold_right(function(x,l){return [0,x,l]},l,_un_)]]}
    function of_string$0(s)
     {var count=[0,0];
      return from
              (function(param)
                {var c=count[1];
                 return c < caml_ml_string_length(s)
                         ?(count[1]++,[0,caml_string_get(s,c)])
                         :0})}
    function of_bytes(s)
     {var count=[0,0];
      return from
              (function(param)
                {var c=count[1];
                 return c < caml_ml_bytes_length(s)
                         ?(count[1]++,[0,caml_bytes_get(s,c)])
                         :0})}
    function of_channel(ic)
     {return [0,[0,0,[4,[0,ic,caml_create_bytes(4096),0,0]]]]}
    function iapp(i,s){var _um_=data(s);return [0,[0,0,[1,data(i),_um_]]]}
    function icons(i,s){return [0,[0,0,[0,i,data(s)]]]}
    function ising(i){return [0,[0,0,[0,i,0]]]}
    function lapp(f,s)
     {return [0,
              [0,
               0,
               [2,
                [246,
                 function(_uk_)
                  {var _ul_=data(s);return [1,data(caml_call1(f,0)),_ul_]}]]]]}
    function lcons(f,s)
     {return [0,
              [0,
               0,
               [2,
                [246,
                 function(_ui_)
                  {var _uj_=data(s);return [0,caml_call1(f,0),_uj_]}]]]]}
    function lsing(f)
     {return [0,[0,0,[2,[246,function(_uh_){return [0,caml_call1(f,0),0]}]]]]}
    var sempty=0;
    function slazy(f)
     {return [0,[0,0,[2,[246,function(_ug_){return data(caml_call1(f,0))}]]]]}
    function dump_data(f,param)
     {if(typeof param === "number")
       return print_string(cst_Sempty);
      else
       switch(param[0])
        {case 0:
          var d=param[2],a=param[1];
          print_string(cst_Scons);
          caml_call1(f,a);
          print_string(cst$7);
          dump_data(f,d);
          return print_string(cst$8);
         case 1:
          var d2=param[2],d1=param[1];
          print_string(cst_Sapp);
          dump_data(f,d1);
          print_string(cst$9);
          dump_data(f,d2);
          return print_string(cst$10);
         case 2:return print_string(cst_Slazy);
         case 3:return print_string(cst_Sgen);
         default:return print_string(cst_Sbuffio)}}
    function dump(f,s)
     {print_string(cst_count);
      print_int(count(s));
      print_string(cst_data);
      dump_data(f,data(s));
      print_string(cst$6);
      return print_newline(0)}
    var
     Stdlib_stream=
      [0,
       Failure$0,
       Error,
       from,
       of_list$1,
       of_string$0,
       of_bytes,
       of_channel,
       iter$9,
       next,
       empty$1,
       peek$0,
       junk,
       count,
       npeek,
       iapp,
       icons,
       ising,
       lapp,
       lcons,
       lsing,
       sempty,
       slazy,
       dump];
    caml_register_global(788,Stdlib_stream,"Stdlib__stream");
    function create$2(n)
     {var
       n$0=1 <= n?n:1,
       n$1=max_string_length < n$0?max_string_length:n$0,
       s=caml_create_bytes(n$1);
      return [0,s,0,n$1,s]}
    function contents(b){return sub_string(b[1],0,b[2])}
    function to_bytes(b){return sub(b[1],0,b[2])}
    function sub$3(b,ofs,len)
     {if(0 <= ofs && 0 <= len && ! ((b[2] - len | 0) < ofs))
       return sub_string(b[1],ofs,len);
      return invalid_arg(cst_Buffer_sub)}
    function blit$3(src,srcoff,dst,dstoff,len)
     {if
       (0
        <=
        len
        &&
        0
        <=
        srcoff
        &&
        !
        ((src[2] - len | 0) < srcoff)
        &&
        0
        <=
        dstoff
        &&
        !
        ((caml_ml_bytes_length(dst) - len | 0) < dstoff))
       return caml_blit_bytes(src[1],srcoff,dst,dstoff,len);
      return invalid_arg(cst_Buffer_blit)}
    function nth$0(b,ofs)
     {if(0 <= ofs && ! (b[2] <= ofs))return caml_bytes_unsafe_get(b[1],ofs);
      return invalid_arg(cst_Buffer_nth)}
    function length$3(b){return b[2]}
    function clear$1(b){b[2] = 0;return 0}
    function reset(b)
     {b[2] = 0;b[1] = b[4];b[3] = caml_ml_bytes_length(b[1]);return 0}
    function resize(b,more)
     {var old_pos=b[2],old_len=b[3],new_len=[0,old_len];
      for(;;)
       {if(new_len[1] < (old_pos + more | 0))
         {new_len[1] = 2 * new_len[1] | 0;continue}
        if(max_string_length < new_len[1])
         if((old_pos + more | 0) <= max_string_length)
          new_len[1] = max_string_length;
         else
          failwith(cst_Buffer_add_cannot_grow_buf);
        var new_buffer=caml_create_bytes(new_len[1]);
        blit(b[1],0,new_buffer,0,b[2]);
        b[1] = new_buffer;
        b[3] = new_len[1];
        if((b[2] + more | 0) <= b[3])
         {if((old_pos + more | 0) <= b[3])return 0;
          throw [0,Assert_failure,_R_]}
        throw [0,Assert_failure,_S_]}}
    function add_char(b,c)
     {var pos=b[2];
      if(b[3] <= pos)resize(b,1);
      caml_bytes_unsafe_set(b[1],pos,c);
      b[2] = pos + 1 | 0;
      return 0}
    function add_utf_8_uchar(b,u)
     {if(0 <= u)
       {if(127 < u)
         {if(2047 < u)
           {if(65535 < u)
             {if(1114111 < u)throw [0,Assert_failure,_T_];
              var pos=b[2];
              if(b[3] < (pos + 4 | 0))resize(b,4);
              caml_bytes_unsafe_set(b[1],pos,240 | u >>> 18 | 0);
              caml_bytes_unsafe_set
               (b[1],pos + 1 | 0,128 | (u >>> 12 | 0) & 63);
              caml_bytes_unsafe_set(b[1],pos + 2 | 0,128 | (u >>> 6 | 0) & 63);
              caml_bytes_unsafe_set(b[1],pos + 3 | 0,128 | u & 63);
              b[2] = pos + 4 | 0;
              return 0}
            var pos$0=b[2];
            if(b[3] < (pos$0 + 3 | 0))resize(b,3);
            caml_bytes_unsafe_set(b[1],pos$0,224 | u >>> 12 | 0);
            caml_bytes_unsafe_set(b[1],pos$0 + 1 | 0,128 | (u >>> 6 | 0) & 63);
            caml_bytes_unsafe_set(b[1],pos$0 + 2 | 0,128 | u & 63);
            b[2] = pos$0 + 3 | 0;
            return 0}
          var pos$1=b[2];
          if(b[3] < (pos$1 + 2 | 0))resize(b,2);
          caml_bytes_unsafe_set(b[1],pos$1,192 | u >>> 6 | 0);
          caml_bytes_unsafe_set(b[1],pos$1 + 1 | 0,128 | u & 63);
          b[2] = pos$1 + 2 | 0;
          return 0}
        return add_char(b,u)}
      throw [0,Assert_failure,_U_]}
    function add_utf_16be_uchar(b,u)
     {if(0 <= u)
       {if(65535 < u)
         {if(1114111 < u)throw [0,Assert_failure,_V_];
          var
           u$0=u - 65536 | 0,
           hi=55296 | u$0 >>> 10 | 0,
           lo=56320 | u$0 & 1023,
           pos=b[2];
          if(b[3] < (pos + 4 | 0))resize(b,4);
          caml_bytes_unsafe_set(b[1],pos,hi >>> 8 | 0);
          caml_bytes_unsafe_set(b[1],pos + 1 | 0,hi & 255);
          caml_bytes_unsafe_set(b[1],pos + 2 | 0,lo >>> 8 | 0);
          caml_bytes_unsafe_set(b[1],pos + 3 | 0,lo & 255);
          b[2] = pos + 4 | 0;
          return 0}
        var pos$0=b[2];
        if(b[3] < (pos$0 + 2 | 0))resize(b,2);
        caml_bytes_unsafe_set(b[1],pos$0,u >>> 8 | 0);
        caml_bytes_unsafe_set(b[1],pos$0 + 1 | 0,u & 255);
        b[2] = pos$0 + 2 | 0;
        return 0}
      throw [0,Assert_failure,_W_]}
    function add_utf_16le_uchar(b,u)
     {if(0 <= u)
       {if(65535 < u)
         {if(1114111 < u)throw [0,Assert_failure,_X_];
          var
           u$0=u - 65536 | 0,
           hi=55296 | u$0 >>> 10 | 0,
           lo=56320 | u$0 & 1023,
           pos=b[2];
          if(b[3] < (pos + 4 | 0))resize(b,4);
          caml_bytes_unsafe_set(b[1],pos,hi & 255);
          caml_bytes_unsafe_set(b[1],pos + 1 | 0,hi >>> 8 | 0);
          caml_bytes_unsafe_set(b[1],pos + 2 | 0,lo & 255);
          caml_bytes_unsafe_set(b[1],pos + 3 | 0,lo >>> 8 | 0);
          b[2] = pos + 4 | 0;
          return 0}
        var pos$0=b[2];
        if(b[3] < (pos$0 + 2 | 0))resize(b,2);
        caml_bytes_unsafe_set(b[1],pos$0,u & 255);
        caml_bytes_unsafe_set(b[1],pos$0 + 1 | 0,u >>> 8 | 0);
        b[2] = pos$0 + 2 | 0;
        return 0}
      throw [0,Assert_failure,_Y_]}
    function add_substring(b,s,offset,len)
     {var _ud_=offset < 0?1:0;
      if(_ud_)
       var _ue_=_ud_;
      else
       var
        _uf_=len < 0?1:0,
        _ue_=_uf_ || ((caml_ml_string_length(s) - len | 0) < offset?1:0);
      if(_ue_)invalid_arg(cst_Buffer_add_substring_add_s);
      var new_position=b[2] + len | 0;
      if(b[3] < new_position)resize(b,len);
      caml_blit_string(s,offset,b[1],b[2],len);
      b[2] = new_position;
      return 0}
    function add_subbytes(b,s,offset,len)
     {return add_substring(b,caml_string_of_bytes(s),offset,len)}
    function add_string(b,s)
     {var len=caml_ml_string_length(s),new_position=b[2] + len | 0;
      if(b[3] < new_position)resize(b,len);
      caml_blit_string(s,0,b[1],b[2],len);
      b[2] = new_position;
      return 0}
    function add_bytes(b,s){return add_string(b,caml_string_of_bytes(s))}
    function add_buffer(b,bs){return add_subbytes(b,bs[1],0,bs[2])}
    function add_channel(b,ic,len)
     {var _ub_=len < 0?1:0,_uc_=_ub_ || (max_string_length < len?1:0);
      if(_uc_)invalid_arg(cst_Buffer_add_channel);
      if(b[3] < (b[2] + len | 0))resize(b,len);
      var already_read=0,ofs=b[2],to_read=len,_ua_=b[1];
      for(;;)
       {if(0 !== to_read)
         {var r=input(ic,_ua_,ofs,to_read);
          if(0 !== r)
           {var
             already_read$0=already_read + r | 0,
             ofs$0=ofs + r | 0,
             to_read$0=to_read - r | 0,
             already_read=already_read$0,
             ofs=ofs$0,
             to_read=to_read$0;
            continue}}
        if((b[2] + already_read | 0) <= b[3])
         {b[2] = b[2] + already_read | 0;
          if(already_read < len)throw End_of_file;
          return 0}
        throw [0,Assert_failure,_Z_]}}
    function output_buffer(oc,b){return output(oc,b[1],0,b[2])}
    function add_substitute(b,f,s)
     {var lim$1=caml_ml_string_length(s),previous=32,i$7=0;
      for(;;)
       {if(i$7 < lim$1)
         {var current=caml_string_get(s,i$7);
          if(36 === current)
           {if(92 === previous)
             {add_char(b,current);
              var i$8=i$7 + 1 | 0,previous=32,i$7=i$8;
              continue}
            var start=i$7 + 1 | 0;
            if(lim$1 <= start)throw Not_found;
            var opening=caml_string_get(s,start),switch$0=0;
            if(40 !== opening && 123 !== opening)
             {var i$6=start + 1 | 0,lim$0=caml_ml_string_length(s),i$3=i$6;
              for(;;)
               {if(lim$0 <= i$3)
                 var stop=lim$0;
                else
                 {var match=caml_string_get(s,i$3),switch$1=0;
                  if(91 <= match)
                   {if(97 <= match)
                     {if(! (123 <= match))switch$1 = 1}
                    else
                     if(95 === match)switch$1 = 1}
                  else
                   if(58 <= match)
                    {if(65 <= match)switch$1 = 1}
                   else
                    if(48 <= match)switch$1 = 1;
                  if(switch$1){var i$4=i$3 + 1 | 0,i$3=i$4;continue}
                  var stop=i$3}
                var match$0=[0,sub$0(s,start,stop - start | 0),stop];
                switch$0 = 1;
                break}}
            if(! switch$0)
             {var i$5=start + 1 | 0,k$2=0;
              if(40 === opening)
               var _t__=41;
              else
               {if(123 !== opening)throw [0,Assert_failure,___];var _t__=125}
              var lim=caml_ml_string_length(s),k=k$2,i=i$5;
              for(;;)
               {if(lim <= i)throw Not_found;
                if(caml_string_get(s,i) === opening)
                 {var i$0=i + 1 | 0,k$0=k + 1 | 0,k=k$0,i=i$0;continue}
                if(caml_string_get(s,i) !== _t__)
                 {var i$2=i + 1 | 0,i=i$2;continue}
                if(0 !== k)
                 {var i$1=i + 1 | 0,k$1=k - 1 | 0,k=k$1,i=i$1;continue}
                var
                 match$0=
                  [0,sub$0(s,i$5,(i - start | 0) - 1 | 0),i + 1 | 0];
                break}}
            var next_i=match$0[2],ident=match$0[1];
            add_string(b,caml_call1(f,ident));
            var previous=32,i$7=next_i;
            continue}
          if(92 === previous)
           {add_char(b,92);
            add_char(b,current);
            var i$9=i$7 + 1 | 0,previous=32,i$7=i$9;
            continue}
          if(92 === current)
           {var i$10=i$7 + 1 | 0,previous=current,i$7=i$10;continue}
          add_char(b,current);
          var i$11=i$7 + 1 | 0,previous=current,i$7=i$11;
          continue}
        var _t$_=92 === previous?1:0;
        return _t$_?add_char(b,previous):_t$_}}
    function truncate(b,len)
     {if(0 <= len && ! (b[2] < len)){b[2] = len;return 0}
      return invalid_arg(cst_Buffer_truncate)}
    function to_seq$8(b)
     {function aux(i,param)
       {if(b[2] <= i)return 0;
        var x=caml_bytes_unsafe_get(b[1],i),_t8_=i + 1 | 0;
        return [0,x,function(_t9_){return aux(_t8_,_t9_)}]}
      var _t6_=0;
      return function(_t7_){return aux(_t6_,_t7_)}}
    function to_seqi$3(b)
     {function aux(i,param)
       {if(b[2] <= i)return 0;
        var x=caml_bytes_unsafe_get(b[1],i),_t4_=i + 1 | 0;
        return [0,[0,i,x],function(_t5_){return aux(_t4_,_t5_)}]}
      var _t2_=0;
      return function(_t3_){return aux(_t2_,_t3_)}}
    function add_seq$1(b,seq)
     {return iter(function(_t1_){return add_char(b,_t1_)},seq)}
    function of_seq$6(i){var b=create$2(32);add_seq$1(b,i);return b}
    function add_int8(b,x)
     {var new_position=b[2] + 1 | 0;
      if(b[3] < new_position)resize(b,1);
      caml_bytes_unsafe_set(b[1],b[2],x);
      b[2] = new_position;
      return 0}
    function add_int16_ne(b,x)
     {var new_position=b[2] + 2 | 0;
      if(b[3] < new_position)resize(b,2);
      caml_bytes_set16(b[1],b[2],x);
      b[2] = new_position;
      return 0}
    function add_int32_ne(b,x)
     {var new_position=b[2] + 4 | 0;
      if(b[3] < new_position)resize(b,4);
      caml_bytes_set32(b[1],b[2],x);
      b[2] = new_position;
      return 0}
    function add_int64_ne(b,x)
     {var new_position=b[2] + 8 | 0;
      if(b[3] < new_position)resize(b,8);
      caml_bytes_set64(b[1],b[2],x);
      b[2] = new_position;
      return 0}
    function add_int16_le(b,x){return add_int16_ne(b,x)}
    function add_int16_be(b,x)
     {var x$0=caml_bswap16(x);return add_int16_ne(b,x$0)}
    function add_int32_le(b,x){return add_int32_ne(b,x)}
    function add_int32_be(b,x)
     {var x$0=caml_int32_bswap(x);return add_int32_ne(b,x$0)}
    function add_int64_le(b,x){return add_int64_ne(b,x)}
    function add_int64_be(b,x)
     {var x$0=caml_int64_bswap(x);return add_int64_ne(b,x$0)}
    var
     Stdlib_buffer=
      [0,
       create$2,
       contents,
       to_bytes,
       sub$3,
       blit$3,
       nth$0,
       length$3,
       clear$1,
       reset,
       add_char,
       add_utf_8_uchar,
       add_utf_16le_uchar,
       add_utf_16be_uchar,
       add_string,
       add_bytes,
       add_substring,
       add_subbytes,
       add_substitute,
       add_buffer,
       add_channel,
       output_buffer,
       truncate,
       to_seq$8,
       to_seqi$3,
       add_seq$1,
       of_seq$6,
       add_int8,
       add_int8,
       add_int16_ne,
       add_int16_be,
       add_int16_le,
       add_int16_ne,
       add_int16_be,
       add_int16_le,
       add_int32_ne,
       add_int32_be,
       add_int32_le,
       add_int64_ne,
       add_int64_be,
       add_int64_le];
    caml_register_global(789,Stdlib_buffer,"Stdlib__buffer");
    function create_char_set(param){return make$0(32,0)}
    function add_in_char_set(char_set,c)
     {var str_ind=c >>> 3 | 0,mask=1 << (c & 7);
      return caml_bytes_set
              (char_set,
               str_ind,
               char_of_int(caml_bytes_get(char_set,str_ind) | mask))}
    function freeze_char_set(char_set){return to_string$1(char_set)}
    function rev_char_set(char_set)
     {var char_set$0=create_char_set(0),i=0;
      for(;;)
       {caml_bytes_set
         (char_set$0,i,char_of_int(caml_string_get(char_set,i) ^ 255));
        var _t0_=i + 1 | 0;
        if(31 !== i){var i=_t0_;continue}
        return caml_string_of_bytes(char_set$0)}}
    function is_in_char_set(char_set,c)
     {var str_ind=c >>> 3 | 0,mask=1 << (c & 7);
      return 0 !== (caml_string_get(char_set,str_ind) & mask)?1:0}
    function pad_of_pad_opt(pad_opt)
     {if(pad_opt){var width=pad_opt[1];return [0,1,width]}return 0}
    function param_format_of_ignored_format(ign,fmt)
     {if(typeof ign === "number")
       switch(ign)
        {case 0:return [0,[0,fmt]];
         case 1:return [0,[1,fmt]];
         case 2:return [0,[19,fmt]];
         default:return [0,[22,fmt]]}
      else
       switch(ign[0])
        {case 0:var pad_opt=ign[1];return [0,[2,pad_of_pad_opt(pad_opt),fmt]];
         case 1:
          var pad_opt$0=ign[1];return [0,[3,pad_of_pad_opt(pad_opt$0),fmt]];
         case 2:
          var pad_opt$1=ign[2],iconv=ign[1];
          return [0,[4,iconv,pad_of_pad_opt(pad_opt$1),0,fmt]];
         case 3:
          var pad_opt$2=ign[2],iconv$0=ign[1];
          return [0,[5,iconv$0,pad_of_pad_opt(pad_opt$2),0,fmt]];
         case 4:
          var pad_opt$3=ign[2],iconv$1=ign[1];
          return [0,[6,iconv$1,pad_of_pad_opt(pad_opt$3),0,fmt]];
         case 5:
          var pad_opt$4=ign[2],iconv$2=ign[1];
          return [0,[7,iconv$2,pad_of_pad_opt(pad_opt$4),0,fmt]];
         case 6:
          var prec_opt=ign[2],pad_opt$5=ign[1];
          if(prec_opt)var ndec=prec_opt[1],_tZ_=[0,ndec];else var _tZ_=0;
          return [0,[8,_$_,pad_of_pad_opt(pad_opt$5),_tZ_,fmt]];
         case 7:
          var pad_opt$6=ign[1];return [0,[9,pad_of_pad_opt(pad_opt$6),fmt]];
         case 8:
          var fmtty=ign[2],pad_opt$7=ign[1];
          return [0,[13,pad_opt$7,fmtty,fmt]];
         case 9:
          var fmtty$0=ign[2],pad_opt$8=ign[1];
          return [0,[14,pad_opt$8,fmtty$0,fmt]];
         case 10:
          var char_set=ign[2],width_opt=ign[1];
          return [0,[20,width_opt,char_set,fmt]];
         default:var counter=ign[1];return [0,[21,counter,fmt]]}}
    function default_float_precision(fconv){return 5 === fconv[2]?12:-6}
    function buffer_create(init_size)
     {return [0,0,caml_create_bytes(init_size)]}
    function buffer_check_size(buf,overhead)
     {var
       len=caml_ml_bytes_length(buf[2]),
       min_len=buf[1] + overhead | 0,
       _tX_=len < min_len?1:0;
      if(_tX_)
       {var
         new_len=max(len * 2 | 0,min_len),
         new_str=caml_create_bytes(new_len);
        blit(buf[2],0,new_str,0,len);
        buf[2] = new_str;
        var _tY_=0}
      else
       var _tY_=_tX_;
      return _tY_}
    function buffer_add_char(buf,c)
     {buffer_check_size(buf,1);
      caml_bytes_set(buf[2],buf[1],c);
      buf[1] = buf[1] + 1 | 0;
      return 0}
    function buffer_add_string(buf,s)
     {var str_len=caml_ml_string_length(s);
      buffer_check_size(buf,str_len);
      blit$0(s,0,buf[2],buf[1],str_len);
      buf[1] = buf[1] + str_len | 0;
      return 0}
    function buffer_contents(buf){return sub_string(buf[2],0,buf[1])}
    function char_of_iconv(iconv)
     {switch(iconv)
       {case 6:
        case 7:return 120;
        case 8:
        case 9:return 88;
        case 10:
        case 11:return 111;
        case 12:
        case 15:return 117;
        case 0:
        case 1:
        case 2:
        case 13:return 100;
        default:return 105}}
    function char_of_fconv(opt,fconv)
     {if(opt)var sth=opt[1],cF=sth;else var cF=70;
      switch(fconv[2])
       {case 0:return 102;
        case 1:return 101;
        case 2:return 69;
        case 3:return 103;
        case 4:return 71;
        case 5:return cF;
        case 6:return 104;
        case 7:return 72;
        default:return 70}}
    function bprint_padty(buf,padty)
     {switch(padty)
       {case 0:return buffer_add_char(buf,45);
        case 1:return 0;
        default:return buffer_add_char(buf,48)}}
    function bprint_ignored_flag(buf,ign_flag)
     {return ign_flag?buffer_add_char(buf,95):ign_flag}
    function bprint_pad_opt(buf,pad_opt)
     {if(pad_opt)
       {var width=pad_opt[1];
        return buffer_add_string(buf,caml_string_of_jsbytes("" + width))}
      return 0}
    function bprint_padding(buf,pad)
     {if(typeof pad === "number")
       return 0;
      else
       {if(0 === pad[0])
         {var n=pad[2],padty=pad[1];
          bprint_padty(buf,padty);
          return buffer_add_string(buf,caml_string_of_jsbytes("" + n))}
        var padty$0=pad[1];
        bprint_padty(buf,padty$0);
        return buffer_add_char(buf,42)}}
    function bprint_precision(buf,prec)
     {if(typeof prec === "number")return prec?buffer_add_string(buf,cst$11):0;
      var n=prec[1];
      buffer_add_char(buf,46);
      return buffer_add_string(buf,caml_string_of_jsbytes("" + n))}
    function bprint_iconv_flag(buf,iconv)
     {switch(iconv)
       {case 1:
        case 4:return buffer_add_char(buf,43);
        case 2:
        case 5:return buffer_add_char(buf,32);
        case 7:
        case 9:
        case 11:
        case 13:
        case 14:
        case 15:return buffer_add_char(buf,35);
        default:return 0}}
    function bprint_altint_fmt(buf,ign_flag,iconv,pad,prec,c)
     {buffer_add_char(buf,37);
      bprint_ignored_flag(buf,ign_flag);
      bprint_iconv_flag(buf,iconv);
      bprint_padding(buf,pad);
      bprint_precision(buf,prec);
      buffer_add_char(buf,c);
      return buffer_add_char(buf,char_of_iconv(iconv))}
    function bprint_fconv_flag(buf,fconv)
     {switch(fconv[1])
       {case 0:break;
        case 1:buffer_add_char(buf,43);break;
        default:buffer_add_char(buf,32)}
      return 8 <= fconv[2]?buffer_add_char(buf,35):0}
    function string_of_formatting_lit(formatting_lit)
     {if(typeof formatting_lit === "number")
       switch(formatting_lit)
        {case 0:return cst$12;
         case 1:return cst$13;
         case 2:return cst$14;
         case 3:return cst$15;
         case 4:return cst$16;
         case 5:return cst$17;
         default:return cst$18}
      else
       switch(formatting_lit[0])
        {case 0:var str=formatting_lit[1];return str;
         case 1:var str$0=formatting_lit[1];return str$0;
         default:var c=formatting_lit[1];return symbol(cst$19,make$1(1,c))}}
    function bprint_char_literal(buf,chr)
     {return 37 === chr?buffer_add_string(buf,cst$20):buffer_add_char(buf,chr)}
    function bprint_string_literal(buf,str)
     {var _tV_=caml_ml_string_length(str) - 1 | 0,_tU_=0;
      if(! (_tV_ < 0))
       {var i=_tU_;
        for(;;)
         {bprint_char_literal(buf,caml_string_get(str,i));
          var _tW_=i + 1 | 0;
          if(_tV_ !== i){var i=_tW_;continue}
          break}}
      return 0}
    function bprint_fmtty(buf,fmtty)
     {var fmtty$0=fmtty;
      for(;;)
       if(typeof fmtty$0 === "number")
        return 0;
       else
        switch(fmtty$0[0])
         {case 0:
           var rest=fmtty$0[1];
           buffer_add_string(buf,cst_c);
           var fmtty$0=rest;
           continue;
          case 1:
           var rest$0=fmtty$0[1];
           buffer_add_string(buf,cst_s);
           var fmtty$0=rest$0;
           continue;
          case 2:
           var rest$1=fmtty$0[1];
           buffer_add_string(buf,cst_i);
           var fmtty$0=rest$1;
           continue;
          case 3:
           var rest$2=fmtty$0[1];
           buffer_add_string(buf,cst_li);
           var fmtty$0=rest$2;
           continue;
          case 4:
           var rest$3=fmtty$0[1];
           buffer_add_string(buf,cst_ni);
           var fmtty$0=rest$3;
           continue;
          case 5:
           var rest$4=fmtty$0[1];
           buffer_add_string(buf,cst_Li);
           var fmtty$0=rest$4;
           continue;
          case 6:
           var rest$5=fmtty$0[1];
           buffer_add_string(buf,cst_f);
           var fmtty$0=rest$5;
           continue;
          case 7:
           var rest$6=fmtty$0[1];
           buffer_add_string(buf,cst_B);
           var fmtty$0=rest$6;
           continue;
          case 8:
           var rest$7=fmtty$0[2],sub_fmtty=fmtty$0[1];
           buffer_add_string(buf,cst$21);
           bprint_fmtty(buf,sub_fmtty);
           buffer_add_string(buf,cst$22);
           var fmtty$0=rest$7;
           continue;
          case 9:
           var rest$8=fmtty$0[3],sub_fmtty$0=fmtty$0[1];
           buffer_add_string(buf,cst$23);
           bprint_fmtty(buf,sub_fmtty$0);
           buffer_add_string(buf,cst$24);
           var fmtty$0=rest$8;
           continue;
          case 10:
           var rest$9=fmtty$0[1];
           buffer_add_string(buf,cst_a);
           var fmtty$0=rest$9;
           continue;
          case 11:
           var rest$10=fmtty$0[1];
           buffer_add_string(buf,cst_t$0);
           var fmtty$0=rest$10;
           continue;
          case 12:
           var rest$11=fmtty$0[1];
           buffer_add_string(buf,cst$25);
           var fmtty$0=rest$11;
           continue;
          case 13:
           var rest$12=fmtty$0[1];
           buffer_add_string(buf,cst_r$0);
           var fmtty$0=rest$12;
           continue;
          default:
           var rest$13=fmtty$0[1];
           buffer_add_string(buf,cst_r$1);
           var fmtty$0=rest$13;
           continue}}
    function int_of_custom_arity(param)
     {if(param){var x=param[1];return 1 + int_of_custom_arity(x) | 0}return 0}
    function string_of_fmt(fmt$1)
     {var buf=buffer_create(16),fmt=fmt$1,ign_flag=0;
      a:
      for(;;)
       if(typeof fmt === "number")
        return buffer_contents(buf);
       else
        switch(fmt[0])
         {case 0:
           var rest=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           buffer_add_char(buf,99);
           var fmt=rest,ign_flag=0;
           continue;
          case 1:
           var rest$0=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           buffer_add_char(buf,67);
           var fmt=rest$0,ign_flag=0;
           continue;
          case 2:
           var rest$1=fmt[2],pad=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_padding(buf,pad);
           buffer_add_char(buf,115);
           var fmt=rest$1,ign_flag=0;
           continue;
          case 3:
           var rest$2=fmt[2],pad$0=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_padding(buf,pad$0);
           buffer_add_char(buf,83);
           var fmt=rest$2,ign_flag=0;
           continue;
          case 4:
           var rest$3=fmt[4],prec=fmt[3],pad$1=fmt[2],iconv=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_iconv_flag(buf,iconv);
           bprint_padding(buf,pad$1);
           bprint_precision(buf,prec);
           buffer_add_char(buf,char_of_iconv(iconv));
           var fmt=rest$3,ign_flag=0;
           continue;
          case 5:
           var rest$4=fmt[4],prec$0=fmt[3],pad$2=fmt[2],iconv$0=fmt[1];
           bprint_altint_fmt(buf,ign_flag,iconv$0,pad$2,prec$0,108);
           var fmt=rest$4,ign_flag=0;
           continue;
          case 6:
           var rest$5=fmt[4],prec$1=fmt[3],pad$3=fmt[2],iconv$1=fmt[1];
           bprint_altint_fmt(buf,ign_flag,iconv$1,pad$3,prec$1,110);
           var fmt=rest$5,ign_flag=0;
           continue;
          case 7:
           var rest$6=fmt[4],prec$2=fmt[3],pad$4=fmt[2],iconv$2=fmt[1];
           bprint_altint_fmt(buf,ign_flag,iconv$2,pad$4,prec$2,76);
           var fmt=rest$6,ign_flag=0;
           continue;
          case 8:
           var rest$7=fmt[4],prec$3=fmt[3],pad$5=fmt[2],fconv=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_fconv_flag(buf,fconv);
           bprint_padding(buf,pad$5);
           bprint_precision(buf,prec$3);
           buffer_add_char(buf,char_of_fconv(0,fconv));
           var fmt=rest$7,ign_flag=0;
           continue;
          case 9:
           var rest$8=fmt[2],pad$6=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_padding(buf,pad$6);
           buffer_add_char(buf,66);
           var fmt=rest$8,ign_flag=0;
           continue;
          case 10:
           var rest$9=fmt[1];
           buffer_add_string(buf,cst$26);
           var fmt=rest$9;
           continue;
          case 11:
           var rest$10=fmt[2],str=fmt[1];
           bprint_string_literal(buf,str);
           var fmt=rest$10;
           continue;
          case 12:
           var rest$11=fmt[2],chr$0=fmt[1];
           bprint_char_literal(buf,chr$0);
           var fmt=rest$11;
           continue;
          case 13:
           var rest$12=fmt[3],fmtty=fmt[2],pad_opt=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_pad_opt(buf,pad_opt);
           buffer_add_char(buf,123);
           bprint_fmtty(buf,fmtty);
           buffer_add_char(buf,37);
           buffer_add_char(buf,125);
           var fmt=rest$12,ign_flag=0;
           continue;
          case 14:
           var rest$13=fmt[3],fmtty$0=fmt[2],pad_opt$0=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_pad_opt(buf,pad_opt$0);
           buffer_add_char(buf,40);
           bprint_fmtty(buf,fmtty$0);
           buffer_add_char(buf,37);
           buffer_add_char(buf,41);
           var fmt=rest$13,ign_flag=0;
           continue;
          case 15:
           var rest$14=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           buffer_add_char(buf,97);
           var fmt=rest$14,ign_flag=0;
           continue;
          case 16:
           var rest$15=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           buffer_add_char(buf,116);
           var fmt=rest$15,ign_flag=0;
           continue;
          case 17:
           var rest$16=fmt[2],fmting_lit=fmt[1];
           bprint_string_literal(buf,string_of_formatting_lit(fmting_lit));
           var fmt=rest$16;
           continue;
          case 18:
           var rest$17=fmt[2],fmting_gen=fmt[1];
           if(0 === fmting_gen[0])
            {var match$1=fmting_gen[1],str$0=match$1[2];
             buffer_add_string(buf,cst$27);
             buffer_add_string(buf,str$0)}
           else
            {var match$2=fmting_gen[1],str$1=match$2[2];
             buffer_add_string(buf,cst$28);
             buffer_add_string(buf,str$1)}
           var fmt=rest$17;
           continue;
          case 19:
           var rest$18=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           buffer_add_char(buf,114);
           var fmt=rest$18,ign_flag=0;
           continue;
          case 20:
           var rest$19=fmt[3],char_set=fmt[2],width_opt=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_pad_opt(buf,width_opt);
           var
            print_char=
             function(buf,i)
              {var c=char_of_int(i);
               return 37 === c
                       ?(buffer_add_char(buf,37),buffer_add_char(buf,37))
                       :64 === c
                         ?(buffer_add_char(buf,37),buffer_add_char(buf,64))
                         :buffer_add_char(buf,c)};
           buffer_add_char(buf,91);
           var
            _tK_=
             is_in_char_set(char_set,0)
              ?(buffer_add_char(buf,94),rev_char_set(char_set))
              :char_set,
            is_alone$0=
             function(_tP_)
              {function is_alone(c)
                {var
                  after=chr(c + 1 | 0),
                  before=chr(c - 1 | 0),
                  _tQ_=is_in_char_set(_tP_,c);
                 if(_tQ_)
                  var
                   _tR_=is_in_char_set(_tP_,before),
                   _tS_=_tR_?is_in_char_set(_tP_,after):_tR_,
                   _tT_=1 - _tS_;
                 else
                  var _tT_=_tQ_;
                 return _tT_}
               return is_alone},
            is_alone=is_alone$0(_tK_);
           if(is_alone(93))buffer_add_char(buf,93);
           var i=1;
           b:
           for(;;)
            {if(i < 256)
              {if(! is_in_char_set(_tK_,char_of_int(i)))
                {var i$0=i + 1 | 0,i=i$0;continue}
               var match=char_of_int(i),switcher=match - 45 | 0,switch$0=0;
               if(48 < switcher >>> 0)
                if(210 <= switcher)print_char(buf,255);else switch$0 = 1;
               else
                {var switcher$0=switcher - 1 | 0;
                 if(46 < switcher$0 >>> 0){var i$2=i + 1 | 0,i=i$2;continue}
                 switch$0 = 1}
               if(switch$0)
                {var i$1=i + 1 | 0;
                 if(! is_in_char_set(_tK_,char_of_int(i$1)))
                  {print_char(buf,i$1 - 1 | 0);
                   var i$6=i$1 + 1 | 0,i=i$6;
                   continue}
                 var
                  match$0=char_of_int(i$1),
                  switcher$1=match$0 - 45 | 0,
                  switch$1=0;
                 if(48 < switcher$1 >>> 0)
                  if(210 <= switcher$1)
                   {print_char(buf,254);print_char(buf,255)}
                  else
                   switch$1 = 1;
                 else
                  {var switcher$2=switcher$1 - 1 | 0;
                   if(46 < switcher$2 >>> 0)
                    {if(! is_in_char_set(_tK_,char_of_int(i$1 + 1 | 0)))
                      {print_char(buf,i$1 - 1 | 0);
                       var i$5=i$1 + 1 | 0,i=i$5;
                       continue}
                     switch$1 = 1}
                   else
                    switch$1 = 1}
                 if(switch$1)
                  {if(! is_in_char_set(_tK_,char_of_int(i$1 + 1 | 0)))
                    {print_char(buf,i$1 - 1 | 0);
                     print_char(buf,i$1);
                     var i$4=i$1 + 2 | 0,i=i$4;
                     continue}
                   var j=i$1 + 2 | 0,i$3=i$1 - 1 | 0,j$0=j;
                   for(;;)
                    {if(256 !== j$0 && is_in_char_set(_tK_,char_of_int(j$0)))
                      {var j$1=j$0 + 1 | 0,j$0=j$1;continue}
                     print_char(buf,i$3);
                     print_char(buf,45);
                     print_char(buf,j$0 - 1 | 0);
                     if(j$0 < 256){var i$7=j$0 + 1 | 0,i=i$7;continue b}
                     break}}}}
             if(is_alone(45))buffer_add_char(buf,45);
             buffer_add_char(buf,93);
             var fmt=rest$19,ign_flag=0;
             continue a}
          case 21:
           var rest$20=fmt[2],counter=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           switch(counter)
            {case 0:var _tL_=108;break;
             case 1:var _tL_=110;break;
             default:var _tL_=78}
           buffer_add_char(buf,_tL_);
           var fmt=rest$20,ign_flag=0;
           continue;
          case 22:
           var rest$21=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_string_literal(buf,cst_0c);
           var fmt=rest$21,ign_flag=0;
           continue;
          case 23:
           var
            rest$22=fmt[2],
            ign=fmt[1],
            match$3=param_format_of_ignored_format(ign,rest$22),
            fmt$0=match$3[1],
            fmt=fmt$0,
            ign_flag=1;
           continue;
          default:
           var
            rest$23=fmt[3],
            arity=fmt[1],
            _tN_=int_of_custom_arity(arity),
            _tM_=1;
           if(! (_tN_ < 1))
            {var i$8=_tM_;
             for(;;)
              {buffer_add_char(buf,37);
               bprint_ignored_flag(buf,ign_flag);
               buffer_add_char(buf,63);
               var _tO_=i$8 + 1 | 0;
               if(_tN_ !== i$8){var i$8=_tO_;continue}
               break}}
           var fmt=rest$23,ign_flag=0;
           continue}}
    function symm(param)
     {if(typeof param === "number")
       return 0;
      else
       switch(param[0])
        {case 0:var rest=param[1];return [0,symm(rest)];
         case 1:var rest$0=param[1];return [1,symm(rest$0)];
         case 2:var rest$1=param[1];return [2,symm(rest$1)];
         case 3:var rest$2=param[1];return [3,symm(rest$2)];
         case 4:var rest$3=param[1];return [4,symm(rest$3)];
         case 5:var rest$4=param[1];return [5,symm(rest$4)];
         case 6:var rest$5=param[1];return [6,symm(rest$5)];
         case 7:var rest$6=param[1];return [7,symm(rest$6)];
         case 8:var rest$7=param[2],ty=param[1];return [8,ty,symm(rest$7)];
         case 9:
          var rest$8=param[3],ty2=param[2],ty1=param[1];
          return [9,ty2,ty1,symm(rest$8)];
         case 10:var rest$9=param[1];return [10,symm(rest$9)];
         case 11:var rest$10=param[1];return [11,symm(rest$10)];
         case 12:var rest$11=param[1];return [12,symm(rest$11)];
         case 13:var rest$12=param[1];return [13,symm(rest$12)];
         default:var rest$13=param[1];return [14,symm(rest$13)]}}
    function trans(ty1,match)
     {var switch$0=0;
      if(typeof ty1 === "number")
       if(typeof match === "number")
        return 0;
       else
        switch(match[0])
         {case 10:break;
          case 11:switch$0 = 1;break;
          case 12:switch$0 = 2;break;
          case 13:switch$0 = 3;break;
          case 14:switch$0 = 4;break;
          case 8:switch$0 = 5;break;
          case 9:switch$0 = 6;break;
          default:throw [0,Assert_failure,_aa_]}
      else
       switch(ty1[0])
        {case 0:
          var switch$1=0,_tr_=ty1[1];
          if(typeof match !== "number")
           switch(match[0])
            {case 0:var rest2=match[1];return [0,trans(_tr_,rest2)];
             case 8:switch$0 = 5;switch$1 = 1;break;
             case 9:switch$0 = 6;switch$1 = 1;break;
             case 10:switch$1 = 1;break;
             case 11:switch$0 = 1;switch$1 = 1;break;
             case 12:switch$0 = 2;switch$1 = 1;break;
             case 13:switch$0 = 3;switch$1 = 1;break;
             case 14:switch$0 = 4;switch$1 = 1;break
             }
          if(! switch$1)switch$0 = 7;
          break;
         case 1:
          var switch$2=0,_ts_=ty1[1];
          if(typeof match !== "number")
           switch(match[0])
            {case 1:var rest2$0=match[1];return [1,trans(_ts_,rest2$0)];
             case 8:switch$0 = 5;switch$2 = 1;break;
             case 9:switch$0 = 6;switch$2 = 1;break;
             case 10:switch$2 = 1;break;
             case 11:switch$0 = 1;switch$2 = 1;break;
             case 12:switch$0 = 2;switch$2 = 1;break;
             case 13:switch$0 = 3;switch$2 = 1;break;
             case 14:switch$0 = 4;switch$2 = 1;break
             }
          if(! switch$2)switch$0 = 7;
          break;
         case 2:
          var switch$3=0,_tt_=ty1[1];
          if(typeof match === "number")
           switch$3 = 1;
          else
           switch(match[0])
            {case 2:var rest2$1=match[1];return [2,trans(_tt_,rest2$1)];
             case 8:switch$0 = 5;break;
             case 9:switch$0 = 6;break;
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$3 = 1}
          if(switch$3)switch$0 = 7;
          break;
         case 3:
          var switch$4=0,_tu_=ty1[1];
          if(typeof match === "number")
           switch$4 = 1;
          else
           switch(match[0])
            {case 3:var rest2$2=match[1];return [3,trans(_tu_,rest2$2)];
             case 8:switch$0 = 5;break;
             case 9:switch$0 = 6;break;
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$4 = 1}
          if(switch$4)switch$0 = 7;
          break;
         case 4:
          var switch$5=0,_tv_=ty1[1];
          if(typeof match === "number")
           switch$5 = 1;
          else
           switch(match[0])
            {case 4:var rest2$3=match[1];return [4,trans(_tv_,rest2$3)];
             case 8:switch$0 = 5;break;
             case 9:switch$0 = 6;break;
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$5 = 1}
          if(switch$5)switch$0 = 7;
          break;
         case 5:
          var switch$6=0,_tw_=ty1[1];
          if(typeof match === "number")
           switch$6 = 1;
          else
           switch(match[0])
            {case 5:var rest2$4=match[1];return [5,trans(_tw_,rest2$4)];
             case 8:switch$0 = 5;break;
             case 9:switch$0 = 6;break;
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$6 = 1}
          if(switch$6)switch$0 = 7;
          break;
         case 6:
          var switch$7=0,_tx_=ty1[1];
          if(typeof match === "number")
           switch$7 = 1;
          else
           switch(match[0])
            {case 6:var rest2$5=match[1];return [6,trans(_tx_,rest2$5)];
             case 8:switch$0 = 5;break;
             case 9:switch$0 = 6;break;
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$7 = 1}
          if(switch$7)switch$0 = 7;
          break;
         case 7:
          var switch$8=0,_ty_=ty1[1];
          if(typeof match === "number")
           switch$8 = 1;
          else
           switch(match[0])
            {case 7:var rest2$6=match[1];return [7,trans(_ty_,rest2$6)];
             case 8:switch$0 = 5;break;
             case 9:switch$0 = 6;break;
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$8 = 1}
          if(switch$8)switch$0 = 7;
          break;
         case 8:
          var switch$9=0,_tz_=ty1[2],_tA_=ty1[1];
          if(typeof match === "number")
           switch$9 = 1;
          else
           switch(match[0])
            {case 8:
              var rest2$7=match[2],ty2=match[1],_tB_=trans(_tz_,rest2$7);
              return [8,trans(_tA_,ty2),_tB_];
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$9 = 1}
          if(switch$9)throw [0,Assert_failure,_aj_];
          break;
         case 9:
          var switch$10=0,_tC_=ty1[3],_tD_=ty1[2],_tE_=ty1[1];
          if(typeof match === "number")
           switch$10 = 1;
          else
           switch(match[0])
            {case 8:switch$0 = 5;break;
             case 9:
              var
               rest2$8=match[3],
               ty22=match[2],
               ty21=match[1],
               ty=trans(symm(_tD_),ty21),
               match$0=fmtty_rel_det(ty),
               f4=match$0[4],
               f2=match$0[2];
              caml_call1(f2,0);
              caml_call1(f4,0);
              return [9,_tE_,ty22,trans(_tC_,rest2$8)];
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$10 = 1}
          if(switch$10)throw [0,Assert_failure,_ak_];
          break;
         case 10:
          var _tF_=ty1[1];
          if(typeof match !== "number" && 10 === match[0])
           {var rest2$9=match[1];return [10,trans(_tF_,rest2$9)]}
          throw [0,Assert_failure,_al_];
         case 11:
          var switch$11=0,_tG_=ty1[1];
          if(typeof match === "number")
           switch$11 = 1;
          else
           switch(match[0])
            {case 10:break;
             case 11:var rest2$10=match[1];return [11,trans(_tG_,rest2$10)];
             default:switch$11 = 1}
          if(switch$11)throw [0,Assert_failure,_am_];
          break;
         case 12:
          var switch$12=0,_tH_=ty1[1];
          if(typeof match === "number")
           switch$12 = 1;
          else
           switch(match[0])
            {case 10:break;
             case 11:switch$0 = 1;break;
             case 12:var rest2$11=match[1];return [12,trans(_tH_,rest2$11)];
             default:switch$12 = 1}
          if(switch$12)throw [0,Assert_failure,_an_];
          break;
         case 13:
          var switch$13=0,_tI_=ty1[1];
          if(typeof match === "number")
           switch$13 = 1;
          else
           switch(match[0])
            {case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:var rest2$12=match[1];return [13,trans(_tI_,rest2$12)];
             default:switch$13 = 1}
          if(switch$13)throw [0,Assert_failure,_ao_];
          break;
         default:
          var switch$14=0,_tJ_=ty1[1];
          if(typeof match === "number")
           switch$14 = 1;
          else
           switch(match[0])
            {case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:var rest2$13=match[1];return [14,trans(_tJ_,rest2$13)];
             default:switch$14 = 1}
          if(switch$14)throw [0,Assert_failure,_ap_]}
      switch(switch$0)
       {case 0:throw [0,Assert_failure,_ad_];
        case 1:throw [0,Assert_failure,_ae_];
        case 2:throw [0,Assert_failure,_af_];
        case 3:throw [0,Assert_failure,_ag_];
        case 4:throw [0,Assert_failure,_ah_];
        case 5:throw [0,Assert_failure,_ab_];
        case 6:throw [0,Assert_failure,_ac_];
        default:throw [0,Assert_failure,_ai_]}}
    function fmtty_rel_det(param)
     {if(typeof param === "number")
       {var
         _s5_=function(param){return 0},
         _s6_=function(param){return 0},
         _s7_=function(param){return 0};
        return [0,function(param){return 0},_s7_,_s6_,_s5_]}
      else
       switch(param[0])
        {case 0:
          var
           rest=param[1],
           match=fmtty_rel_det(rest),
           de=match[4],
           ed=match[3],
           af=match[2],
           fa=match[1],
           _s8_=function(param){caml_call1(af,0);return 0};
          return [0,function(param){caml_call1(fa,0);return 0},_s8_,ed,de];
         case 1:
          var
           rest$0=param[1],
           match$0=fmtty_rel_det(rest$0),
           de$0=match$0[4],
           ed$0=match$0[3],
           af$0=match$0[2],
           fa$0=match$0[1],
           _s9_=function(param){caml_call1(af$0,0);return 0};
          return [0,
                  function(param){caml_call1(fa$0,0);return 0},
                  _s9_,
                  ed$0,
                  de$0];
         case 2:
          var
           rest$1=param[1],
           match$1=fmtty_rel_det(rest$1),
           de$1=match$1[4],
           ed$1=match$1[3],
           af$1=match$1[2],
           fa$1=match$1[1],
           _s__=function(param){caml_call1(af$1,0);return 0};
          return [0,
                  function(param){caml_call1(fa$1,0);return 0},
                  _s__,
                  ed$1,
                  de$1];
         case 3:
          var
           rest$2=param[1],
           match$2=fmtty_rel_det(rest$2),
           de$2=match$2[4],
           ed$2=match$2[3],
           af$2=match$2[2],
           fa$2=match$2[1],
           _s$_=function(param){caml_call1(af$2,0);return 0};
          return [0,
                  function(param){caml_call1(fa$2,0);return 0},
                  _s$_,
                  ed$2,
                  de$2];
         case 4:
          var
           rest$3=param[1],
           match$3=fmtty_rel_det(rest$3),
           de$3=match$3[4],
           ed$3=match$3[3],
           af$3=match$3[2],
           fa$3=match$3[1],
           _ta_=function(param){caml_call1(af$3,0);return 0};
          return [0,
                  function(param){caml_call1(fa$3,0);return 0},
                  _ta_,
                  ed$3,
                  de$3];
         case 5:
          var
           rest$4=param[1],
           match$4=fmtty_rel_det(rest$4),
           de$4=match$4[4],
           ed$4=match$4[3],
           af$4=match$4[2],
           fa$4=match$4[1],
           _tb_=function(param){caml_call1(af$4,0);return 0};
          return [0,
                  function(param){caml_call1(fa$4,0);return 0},
                  _tb_,
                  ed$4,
                  de$4];
         case 6:
          var
           rest$5=param[1],
           match$5=fmtty_rel_det(rest$5),
           de$5=match$5[4],
           ed$5=match$5[3],
           af$5=match$5[2],
           fa$5=match$5[1],
           _tc_=function(param){caml_call1(af$5,0);return 0};
          return [0,
                  function(param){caml_call1(fa$5,0);return 0},
                  _tc_,
                  ed$5,
                  de$5];
         case 7:
          var
           rest$6=param[1],
           match$6=fmtty_rel_det(rest$6),
           de$6=match$6[4],
           ed$6=match$6[3],
           af$6=match$6[2],
           fa$6=match$6[1],
           _td_=function(param){caml_call1(af$6,0);return 0};
          return [0,
                  function(param){caml_call1(fa$6,0);return 0},
                  _td_,
                  ed$6,
                  de$6];
         case 8:
          var
           rest$7=param[2],
           match$7=fmtty_rel_det(rest$7),
           de$7=match$7[4],
           ed$7=match$7[3],
           af$7=match$7[2],
           fa$7=match$7[1],
           _te_=function(param){caml_call1(af$7,0);return 0};
          return [0,
                  function(param){caml_call1(fa$7,0);return 0},
                  _te_,
                  ed$7,
                  de$7];
         case 9:
          var
           rest$8=param[3],
           ty2=param[2],
           ty1=param[1],
           match$8=fmtty_rel_det(rest$8),
           de$8=match$8[4],
           ed$8=match$8[3],
           af$8=match$8[2],
           fa$8=match$8[1],
           ty=trans(symm(ty1),ty2),
           match$9=fmtty_rel_det(ty),
           jd=match$9[4],
           dj=match$9[3],
           ga=match$9[2],
           ag=match$9[1],
           _tf_=function(param){caml_call1(jd,0);caml_call1(de$8,0);return 0},
           _tg_=function(param){caml_call1(ed$8,0);caml_call1(dj,0);return 0},
           _th_=function(param){caml_call1(ga,0);caml_call1(af$8,0);return 0};
          return [0,
                  function(param)
                   {caml_call1(fa$8,0);caml_call1(ag,0);return 0},
                  _th_,
                  _tg_,
                  _tf_];
         case 10:
          var
           rest$9=param[1],
           match$10=fmtty_rel_det(rest$9),
           de$9=match$10[4],
           ed$9=match$10[3],
           af$9=match$10[2],
           fa$9=match$10[1],
           _ti_=function(param){caml_call1(af$9,0);return 0};
          return [0,
                  function(param){caml_call1(fa$9,0);return 0},
                  _ti_,
                  ed$9,
                  de$9];
         case 11:
          var
           rest$10=param[1],
           match$11=fmtty_rel_det(rest$10),
           de$10=match$11[4],
           ed$10=match$11[3],
           af$10=match$11[2],
           fa$10=match$11[1],
           _tj_=function(param){caml_call1(af$10,0);return 0};
          return [0,
                  function(param){caml_call1(fa$10,0);return 0},
                  _tj_,
                  ed$10,
                  de$10];
         case 12:
          var
           rest$11=param[1],
           match$12=fmtty_rel_det(rest$11),
           de$11=match$12[4],
           ed$11=match$12[3],
           af$11=match$12[2],
           fa$11=match$12[1],
           _tk_=function(param){caml_call1(af$11,0);return 0};
          return [0,
                  function(param){caml_call1(fa$11,0);return 0},
                  _tk_,
                  ed$11,
                  de$11];
         case 13:
          var
           rest$12=param[1],
           match$13=fmtty_rel_det(rest$12),
           de$12=match$13[4],
           ed$12=match$13[3],
           af$12=match$13[2],
           fa$12=match$13[1],
           _tl_=function(param){caml_call1(de$12,0);return 0},
           _tm_=function(param){caml_call1(ed$12,0);return 0},
           _tn_=function(param){caml_call1(af$12,0);return 0};
          return [0,
                  function(param){caml_call1(fa$12,0);return 0},
                  _tn_,
                  _tm_,
                  _tl_];
         default:
          var
           rest$13=param[1],
           match$14=fmtty_rel_det(rest$13),
           de$13=match$14[4],
           ed$13=match$14[3],
           af$13=match$14[2],
           fa$13=match$14[1],
           _to_=function(param){caml_call1(de$13,0);return 0},
           _tp_=function(param){caml_call1(ed$13,0);return 0},
           _tq_=function(param){caml_call1(af$13,0);return 0};
          return [0,
                  function(param){caml_call1(fa$13,0);return 0},
                  _tq_,
                  _tp_,
                  _to_]}}
    function fmtty_of_precision_fmtty(prec,fmtty)
     {return typeof prec === "number"?prec?[2,fmtty]:fmtty:fmtty}
    function fmtty_of_padding_fmtty(pad,fmtty)
     {return typeof pad === "number"?fmtty:0 === pad[0]?fmtty:[2,fmtty]}
    function fmtty_of_custom(arity,fmtty)
     {if(arity)
       {var arity$0=arity[1];return [12,fmtty_of_custom(arity$0,fmtty)]}
      return fmtty}
    function fmtty_of_fmt(fmtty)
     {var fmtty$0=fmtty;
      for(;;)
       if(typeof fmtty$0 === "number")
        return 0;
       else
        switch(fmtty$0[0])
         {case 0:var rest=fmtty$0[1];return [0,fmtty_of_fmt(rest)];
          case 1:var rest$0=fmtty$0[1];return [0,fmtty_of_fmt(rest$0)];
          case 2:
           var rest$1=fmtty$0[2],pad=fmtty$0[1];
           return fmtty_of_padding_fmtty(pad,[1,fmtty_of_fmt(rest$1)]);
          case 3:
           var rest$2=fmtty$0[2],pad$0=fmtty$0[1];
           return fmtty_of_padding_fmtty(pad$0,[1,fmtty_of_fmt(rest$2)]);
          case 4:
           var
            rest$3=fmtty$0[4],
            prec=fmtty$0[3],
            pad$1=fmtty$0[2],
            ty_rest=fmtty_of_fmt(rest$3),
            prec_ty=fmtty_of_precision_fmtty(prec,[2,ty_rest]);
           return fmtty_of_padding_fmtty(pad$1,prec_ty);
          case 5:
           var
            rest$4=fmtty$0[4],
            prec$0=fmtty$0[3],
            pad$2=fmtty$0[2],
            ty_rest$0=fmtty_of_fmt(rest$4),
            prec_ty$0=fmtty_of_precision_fmtty(prec$0,[3,ty_rest$0]);
           return fmtty_of_padding_fmtty(pad$2,prec_ty$0);
          case 6:
           var
            rest$5=fmtty$0[4],
            prec$1=fmtty$0[3],
            pad$3=fmtty$0[2],
            ty_rest$1=fmtty_of_fmt(rest$5),
            prec_ty$1=fmtty_of_precision_fmtty(prec$1,[4,ty_rest$1]);
           return fmtty_of_padding_fmtty(pad$3,prec_ty$1);
          case 7:
           var
            rest$6=fmtty$0[4],
            prec$2=fmtty$0[3],
            pad$4=fmtty$0[2],
            ty_rest$2=fmtty_of_fmt(rest$6),
            prec_ty$2=fmtty_of_precision_fmtty(prec$2,[5,ty_rest$2]);
           return fmtty_of_padding_fmtty(pad$4,prec_ty$2);
          case 8:
           var
            rest$7=fmtty$0[4],
            prec$3=fmtty$0[3],
            pad$5=fmtty$0[2],
            ty_rest$3=fmtty_of_fmt(rest$7),
            prec_ty$3=fmtty_of_precision_fmtty(prec$3,[6,ty_rest$3]);
           return fmtty_of_padding_fmtty(pad$5,prec_ty$3);
          case 9:
           var rest$8=fmtty$0[2],pad$6=fmtty$0[1];
           return fmtty_of_padding_fmtty(pad$6,[7,fmtty_of_fmt(rest$8)]);
          case 10:var fmtty$1=fmtty$0[1],fmtty$0=fmtty$1;continue;
          case 11:var fmtty$2=fmtty$0[2],fmtty$0=fmtty$2;continue;
          case 12:var fmtty$3=fmtty$0[2],fmtty$0=fmtty$3;continue;
          case 13:
           var rest$9=fmtty$0[3],ty=fmtty$0[2];
           return [8,ty,fmtty_of_fmt(rest$9)];
          case 14:
           var rest$10=fmtty$0[3],ty$0=fmtty$0[2];
           return [9,ty$0,ty$0,fmtty_of_fmt(rest$10)];
          case 15:var rest$11=fmtty$0[1];return [10,fmtty_of_fmt(rest$11)];
          case 16:var rest$12=fmtty$0[1];return [11,fmtty_of_fmt(rest$12)];
          case 17:var fmtty$4=fmtty$0[2],fmtty$0=fmtty$4;continue;
          case 18:
           var
            rest$13=fmtty$0[2],
            fmting_gen=fmtty$0[1],
            _s3_=fmtty_of_fmt(rest$13);
           if(0 === fmting_gen[0])
            var match=fmting_gen[1],fmt=match[1],_s4_=fmtty_of_fmt(fmt);
           else
            var
             match$0=fmting_gen[1],
             fmt$0=match$0[1],
             _s4_=fmtty_of_fmt(fmt$0);
           return concat_fmtty(_s4_,_s3_);
          case 19:var rest$14=fmtty$0[1];return [13,fmtty_of_fmt(rest$14)];
          case 20:var rest$15=fmtty$0[3];return [1,fmtty_of_fmt(rest$15)];
          case 21:var rest$16=fmtty$0[2];return [2,fmtty_of_fmt(rest$16)];
          case 22:var rest$17=fmtty$0[1];return [0,fmtty_of_fmt(rest$17)];
          case 23:
           var rest$18=fmtty$0[2],ign=fmtty$0[1];
           if(typeof ign === "number")
            switch(ign)
             {case 0:var fmtty$0=rest$18;continue;
              case 1:var fmtty$0=rest$18;continue;
              case 2:return [14,fmtty_of_fmt(rest$18)];
              default:var fmtty$0=rest$18;continue}
           else
            switch(ign[0])
             {case 0:var fmtty$0=rest$18;continue;
              case 1:var fmtty$0=rest$18;continue;
              case 2:var fmtty$0=rest$18;continue;
              case 3:var fmtty$0=rest$18;continue;
              case 4:var fmtty$0=rest$18;continue;
              case 5:var fmtty$0=rest$18;continue;
              case 6:var fmtty$0=rest$18;continue;
              case 7:var fmtty$0=rest$18;continue;
              case 8:var fmtty$0=rest$18;continue;
              case 9:
               var fmtty$5=ign[2];
               return concat_fmtty(fmtty$5,fmtty_of_fmt(rest$18));
              case 10:var fmtty$0=rest$18;continue;
              default:var fmtty$0=rest$18;continue}
          default:
           var rest$19=fmtty$0[3],arity=fmtty$0[1];
           return fmtty_of_custom(arity,fmtty_of_fmt(rest$19))}}
    var
     Type_mismatch=
      [248,cst_CamlinternalFormat_Type_mi,caml_fresh_oo_id(0)];
    function type_padding(pad,match)
     {if(typeof pad === "number")
       return [0,0,match];
      else
       {if(0 === pad[0])
         {var w=pad[2],padty=pad[1];return [0,[0,padty,w],match]}
        if(typeof match !== "number" && 2 === match[0])
         {var rest=match[1],padty$0=pad[1];return [0,[1,padty$0],rest]}
        throw Type_mismatch}}
    function type_padprec(pad,prec,fmtty)
     {var match=type_padding(pad,fmtty);
      if(typeof prec === "number")
       {if(prec)
         {var _s2_=match[2];
          if(typeof _s2_ !== "number" && 2 === _s2_[0])
           {var rest=_s2_[1],pad$0=match[1];return [0,pad$0,1,rest]}
          throw Type_mismatch}
        var rest$0=match[2],pad$1=match[1];
        return [0,pad$1,0,rest$0]}
      var rest$1=match[2],pad$2=match[1],p=prec[1];
      return [0,pad$2,[0,p],rest$1]}
    function type_ignored_format_substituti(sub_fmtty,fmt,match)
     {if(typeof sub_fmtty === "number")
       return [0,0,type_format_gen(fmt,match)];
      else
       switch(sub_fmtty[0])
        {case 0:
          if(typeof match !== "number" && 0 === match[0])
           {var
             fmtty_rest=match[1],
             sub_fmtty_rest=sub_fmtty[1],
             match$0=
              type_ignored_format_substituti(sub_fmtty_rest,fmt,fmtty_rest),
             fmt$0=match$0[2],
             sub_fmtty_rest$0=match$0[1];
            return [0,[0,sub_fmtty_rest$0],fmt$0]}
          break;
         case 1:
          if(typeof match !== "number" && 1 === match[0])
           {var
             fmtty_rest$0=match[1],
             sub_fmtty_rest$1=sub_fmtty[1],
             match$1=
              type_ignored_format_substituti
               (sub_fmtty_rest$1,fmt,fmtty_rest$0),
             fmt$1=match$1[2],
             sub_fmtty_rest$2=match$1[1];
            return [0,[1,sub_fmtty_rest$2],fmt$1]}
          break;
         case 2:
          if(typeof match !== "number" && 2 === match[0])
           {var
             fmtty_rest$1=match[1],
             sub_fmtty_rest$3=sub_fmtty[1],
             match$2=
              type_ignored_format_substituti
               (sub_fmtty_rest$3,fmt,fmtty_rest$1),
             fmt$2=match$2[2],
             sub_fmtty_rest$4=match$2[1];
            return [0,[2,sub_fmtty_rest$4],fmt$2]}
          break;
         case 3:
          if(typeof match !== "number" && 3 === match[0])
           {var
             fmtty_rest$2=match[1],
             sub_fmtty_rest$5=sub_fmtty[1],
             match$3=
              type_ignored_format_substituti
               (sub_fmtty_rest$5,fmt,fmtty_rest$2),
             fmt$3=match$3[2],
             sub_fmtty_rest$6=match$3[1];
            return [0,[3,sub_fmtty_rest$6],fmt$3]}
          break;
         case 4:
          if(typeof match !== "number" && 4 === match[0])
           {var
             fmtty_rest$3=match[1],
             sub_fmtty_rest$7=sub_fmtty[1],
             match$4=
              type_ignored_format_substituti
               (sub_fmtty_rest$7,fmt,fmtty_rest$3),
             fmt$4=match$4[2],
             sub_fmtty_rest$8=match$4[1];
            return [0,[4,sub_fmtty_rest$8],fmt$4]}
          break;
         case 5:
          if(typeof match !== "number" && 5 === match[0])
           {var
             fmtty_rest$4=match[1],
             sub_fmtty_rest$9=sub_fmtty[1],
             match$5=
              type_ignored_format_substituti
               (sub_fmtty_rest$9,fmt,fmtty_rest$4),
             fmt$5=match$5[2],
             sub_fmtty_rest$10=match$5[1];
            return [0,[5,sub_fmtty_rest$10],fmt$5]}
          break;
         case 6:
          if(typeof match !== "number" && 6 === match[0])
           {var
             fmtty_rest$5=match[1],
             sub_fmtty_rest$11=sub_fmtty[1],
             match$6=
              type_ignored_format_substituti
               (sub_fmtty_rest$11,fmt,fmtty_rest$5),
             fmt$6=match$6[2],
             sub_fmtty_rest$12=match$6[1];
            return [0,[6,sub_fmtty_rest$12],fmt$6]}
          break;
         case 7:
          if(typeof match !== "number" && 7 === match[0])
           {var
             fmtty_rest$6=match[1],
             sub_fmtty_rest$13=sub_fmtty[1],
             match$7=
              type_ignored_format_substituti
               (sub_fmtty_rest$13,fmt,fmtty_rest$6),
             fmt$7=match$7[2],
             sub_fmtty_rest$14=match$7[1];
            return [0,[7,sub_fmtty_rest$14],fmt$7]}
          break;
         case 8:
          if(typeof match !== "number" && 8 === match[0])
           {var
             fmtty_rest$7=match[2],
             sub2_fmtty=match[1],
             sub_fmtty_rest$15=sub_fmtty[2],
             sub2_fmtty$0=sub_fmtty[1];
            if(caml_notequal([0,sub2_fmtty$0],[0,sub2_fmtty]))
             throw Type_mismatch;
            var
             match$8=
              type_ignored_format_substituti
               (sub_fmtty_rest$15,fmt,fmtty_rest$7),
             fmt$8=match$8[2],
             sub_fmtty_rest$16=match$8[1];
            return [0,[8,sub2_fmtty,sub_fmtty_rest$16],fmt$8]}
          break;
         case 9:
          if(typeof match !== "number" && 9 === match[0])
           {var
             fmtty_rest$8=match[3],
             sub2_fmtty$1=match[2],
             sub1_fmtty=match[1],
             sub_fmtty_rest$17=sub_fmtty[3],
             sub2_fmtty$2=sub_fmtty[2],
             sub1_fmtty$0=sub_fmtty[1],
             _s0_=[0,erase_rel(sub1_fmtty)];
            if(caml_notequal([0,erase_rel(sub1_fmtty$0)],_s0_))
             throw Type_mismatch;
            var _s1_=[0,erase_rel(sub2_fmtty$1)];
            if(caml_notequal([0,erase_rel(sub2_fmtty$2)],_s1_))
             throw Type_mismatch;
            var
             sub_fmtty$0=trans(symm(sub1_fmtty),sub2_fmtty$1),
             match$9=fmtty_rel_det(sub_fmtty$0),
             f4=match$9[4],
             f2=match$9[2];
            caml_call1(f2,0);
            caml_call1(f4,0);
            var
             match$10=
              type_ignored_format_substituti
               (erase_rel(sub_fmtty_rest$17),fmt,fmtty_rest$8),
             fmt$9=match$10[2],
             sub_fmtty_rest$18=match$10[1];
            return [0,
                    [9,sub1_fmtty,sub2_fmtty$1,symm(sub_fmtty_rest$18)],
                    fmt$9]}
          break;
         case 10:
          if(typeof match !== "number" && 10 === match[0])
           {var
             fmtty_rest$9=match[1],
             sub_fmtty_rest$19=sub_fmtty[1],
             match$11=
              type_ignored_format_substituti
               (sub_fmtty_rest$19,fmt,fmtty_rest$9),
             fmt$10=match$11[2],
             sub_fmtty_rest$20=match$11[1];
            return [0,[10,sub_fmtty_rest$20],fmt$10]}
          break;
         case 11:
          if(typeof match !== "number" && 11 === match[0])
           {var
             fmtty_rest$10=match[1],
             sub_fmtty_rest$21=sub_fmtty[1],
             match$12=
              type_ignored_format_substituti
               (sub_fmtty_rest$21,fmt,fmtty_rest$10),
             fmt$11=match$12[2],
             sub_fmtty_rest$22=match$12[1];
            return [0,[11,sub_fmtty_rest$22],fmt$11]}
          break;
         case 13:
          if(typeof match !== "number" && 13 === match[0])
           {var
             fmtty_rest$11=match[1],
             sub_fmtty_rest$23=sub_fmtty[1],
             match$13=
              type_ignored_format_substituti
               (sub_fmtty_rest$23,fmt,fmtty_rest$11),
             fmt$12=match$13[2],
             sub_fmtty_rest$24=match$13[1];
            return [0,[13,sub_fmtty_rest$24],fmt$12]}
          break;
         case 14:
          if(typeof match !== "number" && 14 === match[0])
           {var
             fmtty_rest$12=match[1],
             sub_fmtty_rest$25=sub_fmtty[1],
             match$14=
              type_ignored_format_substituti
               (sub_fmtty_rest$25,fmt,fmtty_rest$12),
             fmt$13=match$14[2],
             sub_fmtty_rest$26=match$14[1];
            return [0,[14,sub_fmtty_rest$26],fmt$13]}
          break
         }
      throw Type_mismatch}
    function type_format_gen(fmt,fmtty)
     {if(typeof fmt === "number")
       return [0,0,fmtty];
      else
       switch(fmt[0])
        {case 0:
          if(typeof fmtty !== "number" && 0 === fmtty[0])
           {var
             fmtty_rest=fmtty[1],
             fmt_rest=fmt[1],
             match=type_format_gen(fmt_rest,fmtty_rest),
             fmtty$0=match[2],
             fmt$0=match[1];
            return [0,[0,fmt$0],fmtty$0]}
          break;
         case 1:
          if(typeof fmtty !== "number" && 0 === fmtty[0])
           {var
             fmtty_rest$0=fmtty[1],
             fmt_rest$0=fmt[1],
             match$0=type_format_gen(fmt_rest$0,fmtty_rest$0),
             fmtty$1=match$0[2],
             fmt$1=match$0[1];
            return [0,[1,fmt$1],fmtty$1]}
          break;
         case 2:
          var
           fmt_rest$1=fmt[2],
           pad=fmt[1],
           match$1=type_padding(pad,fmtty),
           _sJ_=match$1[2],
           _sI_=match$1[1];
          if(typeof _sJ_ !== "number" && 1 === _sJ_[0])
           {var
             fmtty_rest$1=_sJ_[1],
             match$2=type_format_gen(fmt_rest$1,fmtty_rest$1),
             fmtty$2=match$2[2],
             fmt$2=match$2[1];
            return [0,[2,_sI_,fmt$2],fmtty$2]}
          throw Type_mismatch;
         case 3:
          var
           fmt_rest$2=fmt[2],
           pad$0=fmt[1],
           match$3=type_padding(pad$0,fmtty),
           _sL_=match$3[2],
           _sK_=match$3[1];
          if(typeof _sL_ !== "number" && 1 === _sL_[0])
           {var
             fmtty_rest$2=_sL_[1],
             match$4=type_format_gen(fmt_rest$2,fmtty_rest$2),
             fmtty$3=match$4[2],
             fmt$3=match$4[1];
            return [0,[3,_sK_,fmt$3],fmtty$3]}
          throw Type_mismatch;
         case 4:
          var
           fmt_rest$3=fmt[4],
           prec=fmt[3],
           pad$1=fmt[2],
           iconv=fmt[1],
           match$5=type_padprec(pad$1,prec,fmtty),
           _sN_=match$5[3],
           _sM_=match$5[1];
          if(typeof _sN_ !== "number" && 2 === _sN_[0])
           {var
             fmtty_rest$3=_sN_[1],
             prec$0=match$5[2],
             match$6=type_format_gen(fmt_rest$3,fmtty_rest$3),
             fmtty$4=match$6[2],
             fmt$4=match$6[1];
            return [0,[4,iconv,_sM_,prec$0,fmt$4],fmtty$4]}
          throw Type_mismatch;
         case 5:
          var
           fmt_rest$4=fmt[4],
           prec$1=fmt[3],
           pad$2=fmt[2],
           iconv$0=fmt[1],
           match$7=type_padprec(pad$2,prec$1,fmtty),
           _sP_=match$7[3],
           _sO_=match$7[1];
          if(typeof _sP_ !== "number" && 3 === _sP_[0])
           {var
             fmtty_rest$4=_sP_[1],
             prec$2=match$7[2],
             match$8=type_format_gen(fmt_rest$4,fmtty_rest$4),
             fmtty$5=match$8[2],
             fmt$5=match$8[1];
            return [0,[5,iconv$0,_sO_,prec$2,fmt$5],fmtty$5]}
          throw Type_mismatch;
         case 6:
          var
           fmt_rest$5=fmt[4],
           prec$3=fmt[3],
           pad$3=fmt[2],
           iconv$1=fmt[1],
           match$9=type_padprec(pad$3,prec$3,fmtty),
           _sR_=match$9[3],
           _sQ_=match$9[1];
          if(typeof _sR_ !== "number" && 4 === _sR_[0])
           {var
             fmtty_rest$5=_sR_[1],
             prec$4=match$9[2],
             match$10=type_format_gen(fmt_rest$5,fmtty_rest$5),
             fmtty$6=match$10[2],
             fmt$6=match$10[1];
            return [0,[6,iconv$1,_sQ_,prec$4,fmt$6],fmtty$6]}
          throw Type_mismatch;
         case 7:
          var
           fmt_rest$6=fmt[4],
           prec$5=fmt[3],
           pad$4=fmt[2],
           iconv$2=fmt[1],
           match$11=type_padprec(pad$4,prec$5,fmtty),
           _sT_=match$11[3],
           _sS_=match$11[1];
          if(typeof _sT_ !== "number" && 5 === _sT_[0])
           {var
             fmtty_rest$6=_sT_[1],
             prec$6=match$11[2],
             match$12=type_format_gen(fmt_rest$6,fmtty_rest$6),
             fmtty$7=match$12[2],
             fmt$7=match$12[1];
            return [0,[7,iconv$2,_sS_,prec$6,fmt$7],fmtty$7]}
          throw Type_mismatch;
         case 8:
          var
           fmt_rest$7=fmt[4],
           prec$7=fmt[3],
           pad$5=fmt[2],
           fconv=fmt[1],
           match$13=type_padprec(pad$5,prec$7,fmtty),
           _sV_=match$13[3],
           _sU_=match$13[1];
          if(typeof _sV_ !== "number" && 6 === _sV_[0])
           {var
             fmtty_rest$7=_sV_[1],
             prec$8=match$13[2],
             match$14=type_format_gen(fmt_rest$7,fmtty_rest$7),
             fmtty$8=match$14[2],
             fmt$8=match$14[1];
            return [0,[8,fconv,_sU_,prec$8,fmt$8],fmtty$8]}
          throw Type_mismatch;
         case 9:
          var
           fmt_rest$8=fmt[2],
           pad$6=fmt[1],
           match$15=type_padding(pad$6,fmtty),
           _sX_=match$15[2],
           _sW_=match$15[1];
          if(typeof _sX_ !== "number" && 7 === _sX_[0])
           {var
             fmtty_rest$8=_sX_[1],
             match$16=type_format_gen(fmt_rest$8,fmtty_rest$8),
             fmtty$9=match$16[2],
             fmt$9=match$16[1];
            return [0,[9,_sW_,fmt$9],fmtty$9]}
          throw Type_mismatch;
         case 10:
          var
           fmt_rest$9=fmt[1],
           match$17=type_format_gen(fmt_rest$9,fmtty),
           fmtty$10=match$17[2],
           fmt$10=match$17[1];
          return [0,[10,fmt$10],fmtty$10];
         case 11:
          var
           fmt_rest$10=fmt[2],
           str=fmt[1],
           match$18=type_format_gen(fmt_rest$10,fmtty),
           fmtty$11=match$18[2],
           fmt$11=match$18[1];
          return [0,[11,str,fmt$11],fmtty$11];
         case 12:
          var
           fmt_rest$11=fmt[2],
           chr=fmt[1],
           match$19=type_format_gen(fmt_rest$11,fmtty),
           fmtty$12=match$19[2],
           fmt$12=match$19[1];
          return [0,[12,chr,fmt$12],fmtty$12];
         case 13:
          if(typeof fmtty !== "number" && 8 === fmtty[0])
           {var
             fmtty_rest$9=fmtty[2],
             sub_fmtty=fmtty[1],
             fmt_rest$12=fmt[3],
             sub_fmtty$0=fmt[2],
             pad_opt=fmt[1];
            if(caml_notequal([0,sub_fmtty$0],[0,sub_fmtty]))
             throw Type_mismatch;
            var
             match$20=type_format_gen(fmt_rest$12,fmtty_rest$9),
             fmtty$13=match$20[2],
             fmt$13=match$20[1];
            return [0,[13,pad_opt,sub_fmtty,fmt$13],fmtty$13]}
          break;
         case 14:
          if(typeof fmtty !== "number" && 9 === fmtty[0])
           {var
             fmtty_rest$10=fmtty[3],
             sub_fmtty1=fmtty[1],
             fmt_rest$13=fmt[3],
             sub_fmtty$1=fmt[2],
             pad_opt$0=fmt[1],
             _sY_=[0,erase_rel(sub_fmtty1)];
            if(caml_notequal([0,erase_rel(sub_fmtty$1)],_sY_))
             throw Type_mismatch;
            var
             match$21=type_format_gen(fmt_rest$13,erase_rel(fmtty_rest$10)),
             fmtty$14=match$21[2],
             fmt$14=match$21[1];
            return [0,[14,pad_opt$0,sub_fmtty1,fmt$14],fmtty$14]}
          break;
         case 15:
          if(typeof fmtty !== "number" && 10 === fmtty[0])
           {var
             fmtty_rest$11=fmtty[1],
             fmt_rest$14=fmt[1],
             match$22=type_format_gen(fmt_rest$14,fmtty_rest$11),
             fmtty$15=match$22[2],
             fmt$15=match$22[1];
            return [0,[15,fmt$15],fmtty$15]}
          break;
         case 16:
          if(typeof fmtty !== "number" && 11 === fmtty[0])
           {var
             fmtty_rest$12=fmtty[1],
             fmt_rest$15=fmt[1],
             match$23=type_format_gen(fmt_rest$15,fmtty_rest$12),
             fmtty$16=match$23[2],
             fmt$16=match$23[1];
            return [0,[16,fmt$16],fmtty$16]}
          break;
         case 17:
          var
           fmt_rest$16=fmt[2],
           formatting_lit=fmt[1],
           match$24=type_format_gen(fmt_rest$16,fmtty),
           fmtty$17=match$24[2],
           fmt$17=match$24[1];
          return [0,[17,formatting_lit,fmt$17],fmtty$17];
         case 18:
          var fmt_rest$17=fmt[2],formatting_gen=fmt[1];
          if(0 === formatting_gen[0])
           {var
             match$28=formatting_gen[1],
             str$0=match$28[2],
             fmt1=match$28[1],
             match$29=type_format_gen(fmt1,fmtty),
             fmtty2=match$29[2],
             fmt2=match$29[1],
             match$30=type_format_gen(fmt_rest$17,fmtty2),
             fmtty3=match$30[2],
             fmt3=match$30[1];
            return [0,[18,[0,[0,fmt2,str$0]],fmt3],fmtty3]}
          var
           match$31=formatting_gen[1],
           str$1=match$31[2],
           fmt1$0=match$31[1],
           match$32=type_format_gen(fmt1$0,fmtty),
           fmtty2$0=match$32[2],
           fmt2$0=match$32[1],
           match$33=type_format_gen(fmt_rest$17,fmtty2$0),
           fmtty3$0=match$33[2],
           fmt3$0=match$33[1];
          return [0,[18,[1,[0,fmt2$0,str$1]],fmt3$0],fmtty3$0];
         case 19:
          if(typeof fmtty !== "number" && 13 === fmtty[0])
           {var
             fmtty_rest$13=fmtty[1],
             fmt_rest$18=fmt[1],
             match$25=type_format_gen(fmt_rest$18,fmtty_rest$13),
             fmtty$18=match$25[2],
             fmt$18=match$25[1];
            return [0,[19,fmt$18],fmtty$18]}
          break;
         case 20:
          if(typeof fmtty !== "number" && 1 === fmtty[0])
           {var
             fmtty_rest$14=fmtty[1],
             fmt_rest$19=fmt[3],
             char_set=fmt[2],
             width_opt=fmt[1],
             match$26=type_format_gen(fmt_rest$19,fmtty_rest$14),
             fmtty$19=match$26[2],
             fmt$19=match$26[1];
            return [0,[20,width_opt,char_set,fmt$19],fmtty$19]}
          break;
         case 21:
          if(typeof fmtty !== "number" && 2 === fmtty[0])
           {var
             fmtty_rest$15=fmtty[1],
             fmt_rest$20=fmt[2],
             counter=fmt[1],
             match$27=type_format_gen(fmt_rest$20,fmtty_rest$15),
             fmtty$20=match$27[2],
             fmt$20=match$27[1];
            return [0,[21,counter,fmt$20],fmtty$20]}
          break;
         case 23:
          var rest=fmt[2],ign=fmt[1];
          if(typeof ign === "number")
           switch(ign)
            {case 0:return type_ignored_param_one(ign,rest,fmtty);
             case 1:return type_ignored_param_one(ign,rest,fmtty);
             case 2:
              if(typeof fmtty !== "number" && 14 === fmtty[0])
               {var
                 fmtty_rest$16=fmtty[1],
                 match$34=type_format_gen(rest,fmtty_rest$16),
                 fmtty$21=match$34[2],
                 fmt$21=match$34[1];
                return [0,[23,2,fmt$21],fmtty$21]}
              throw Type_mismatch;
             default:return type_ignored_param_one(ign,rest,fmtty)}
          else
           switch(ign[0])
            {case 0:return type_ignored_param_one(ign,rest,fmtty);
             case 1:return type_ignored_param_one(ign,rest,fmtty);
             case 2:return type_ignored_param_one(ign,rest,fmtty);
             case 3:return type_ignored_param_one(ign,rest,fmtty);
             case 4:return type_ignored_param_one(ign,rest,fmtty);
             case 5:return type_ignored_param_one(ign,rest,fmtty);
             case 6:return type_ignored_param_one(ign,rest,fmtty);
             case 7:return type_ignored_param_one(ign,rest,fmtty);
             case 8:
              var sub_fmtty$2=ign[2],pad_opt$1=ign[1];
              return type_ignored_param_one
                      ([8,pad_opt$1,sub_fmtty$2],rest,fmtty);
             case 9:
              var
               sub_fmtty$3=ign[2],
               pad_opt$2=ign[1],
               _sZ_=type_ignored_format_substituti(sub_fmtty$3,rest,fmtty),
               match$35=_sZ_[2],
               fmtty$22=match$35[2],
               fmt$22=match$35[1],
               sub_fmtty$4=_sZ_[1];
              return [0,[23,[9,pad_opt$2,sub_fmtty$4],fmt$22],fmtty$22];
             case 10:return type_ignored_param_one(ign,rest,fmtty);
             default:return type_ignored_param_one(ign,rest,fmtty)}
         }
      throw Type_mismatch}
    function type_ignored_param_one(ign,fmt,fmtty)
     {var match=type_format_gen(fmt,fmtty),fmtty$0=match[2],fmt$0=match[1];
      return [0,[23,ign,fmt$0],fmtty$0]}
    function type_format(fmt,fmtty)
     {var _sH_=type_format_gen(fmt,fmtty);
      if(typeof _sH_[2] === "number"){var fmt$0=_sH_[1];return fmt$0}
      throw Type_mismatch}
    function recast(fmt,fmtty){return type_format(fmt,erase_rel(symm(fmtty)))}
    function fix_padding(padty,width,str)
     {var
       len=caml_ml_string_length(str),
       padty$0=0 <= width?padty:0,
       width$0=abs(width);
      if(width$0 <= len)return str;
      var _sG_=2 === padty$0?48:32,res=make$0(width$0,_sG_);
      switch(padty$0)
       {case 0:blit$0(str,0,res,0,len);break;
        case 1:blit$0(str,0,res,width$0 - len | 0,len);break;
        default:
         var switch$0=0;
         if(0 < len)
          {var switch$1=0;
           if
            (43
             !==
             caml_string_get(str,0)
             &&
             45
             !==
             caml_string_get(str,0)
             &&
             32
             !==
             caml_string_get(str,0))
            {switch$0 = 1;switch$1 = 1}
           if(! switch$1)
            {caml_bytes_set(res,0,caml_string_get(str,0));
             blit$0(str,1,res,(width$0 - len | 0) + 1 | 0,len - 1 | 0)}}
         else
          switch$0 = 1;
         if(switch$0)
          {var switch$2=0;
           if(1 < len && 48 === caml_string_get(str,0))
            {var switch$3=0;
             if
              (120
               !==
               caml_string_get(str,1)
               &&
               88
               !==
               caml_string_get(str,1))
              {switch$2 = 1;switch$3 = 1}
             if(! switch$3)
              {caml_bytes_set(res,1,caml_string_get(str,1));
               blit$0(str,2,res,(width$0 - len | 0) + 2 | 0,len - 2 | 0)}}
           else
            switch$2 = 1;
           if(switch$2)blit$0(str,0,res,width$0 - len | 0,len)}}
      return caml_string_of_bytes(res)}
    function fix_int_precision(prec,str)
     {var
       prec$0=abs(prec),
       len=caml_ml_string_length(str),
       c=caml_string_get(str,0),
       switch$0=0;
      if(58 <= c)
       {if(71 <= c)
         {if(! (5 < (c - 97 | 0) >>> 0))switch$0 = 1}
        else
         if(65 <= c)switch$0 = 1}
      else
       {var switch$1=0;
        if(32 !== c)
         if(43 <= c)
          {var switcher=c - 43 | 0;
           switch(switcher)
            {case 5:
              if(len < (prec$0 + 2 | 0) && 1 < len)
               {var switch$2=0;
                if
                 (120
                  ===
                  caml_string_get(str,1)
                  ||
                  88
                  ===
                  caml_string_get(str,1))
                 switch$2 = 1;
                if(switch$2)
                 {var res$1=make$0(prec$0 + 2 | 0,48);
                  caml_bytes_set(res$1,1,caml_string_get(str,1));
                  blit$0(str,2,res$1,(prec$0 - len | 0) + 4 | 0,len - 2 | 0);
                  return caml_string_of_bytes(res$1)}}
              switch$0 = 1;
              switch$1 = 1;
              break;
             case 0:
             case 2:break;
             case 1:
             case 3:
             case 4:switch$1 = 1;break;
             default:switch$0 = 1;switch$1 = 1}}
         else
          switch$1 = 1;
        if(! switch$1 && len < (prec$0 + 1 | 0))
         {var res$0=make$0(prec$0 + 1 | 0,48);
          caml_bytes_set(res$0,0,c);
          blit$0(str,1,res$0,(prec$0 - len | 0) + 2 | 0,len - 1 | 0);
          return caml_string_of_bytes(res$0)}}
      if(switch$0 && len < prec$0)
       {var res=make$0(prec$0,48);
        blit$0(str,0,res,prec$0 - len | 0,len);
        return caml_string_of_bytes(res)}
      return str}
    function string_to_caml_string(str)
     {var
       str$0=escaped$1(str),
       l=caml_ml_string_length(str$0),
       res=make$0(l + 2 | 0,34);
      caml_blit_string(str$0,0,res,1,l);
      return caml_string_of_bytes(res)}
    function format_of_fconv(fconv,prec)
     {var
       prec$0=abs(prec),
       symb=char_of_fconv(_aq_,fconv),
       buf=buffer_create(16);
      buffer_add_char(buf,37);
      bprint_fconv_flag(buf,fconv);
      buffer_add_char(buf,46);
      buffer_add_string(buf,caml_string_of_jsbytes("" + prec$0));
      buffer_add_char(buf,symb);
      return buffer_contents(buf)}
    function transform_int_alt(iconv,s)
     {if(13 <= iconv)
       {var n=[0,0],_sB_=caml_ml_string_length(s) - 1 | 0,_sA_=0;
        if(! (_sB_ < 0))
         {var i$0=_sA_;
          for(;;)
           {var match=caml_string_unsafe_get(s,i$0),switcher$0=match - 48 | 0;
            if(! (9 < switcher$0 >>> 0))n[1]++;
            var _sF_=i$0 + 1 | 0;
            if(_sB_ !== i$0){var i$0=_sF_;continue}
            break}}
        var
         digits=n[1],
         buf=
          caml_create_bytes
           (caml_ml_string_length(s) + ((digits - 1 | 0) / 3 | 0) | 0),
         pos=[0,0],
         put=function(c){caml_bytes_set(buf,pos[1],c);pos[1]++;return 0},
         left=[0,((digits - 1 | 0) % 3 | 0) + 1 | 0],
         _sD_=caml_ml_string_length(s) - 1 | 0,
         _sC_=0;
        if(! (_sD_ < 0))
         {var i=_sC_;
          for(;;)
           {var c=caml_string_unsafe_get(s,i),switcher=c - 48 | 0;
            if(9 < switcher >>> 0)
             put(c);
            else
             {if(0 === left[1]){put(95);left[1] = 3}left[1] += -1;put(c)}
            var _sE_=i + 1 | 0;
            if(_sD_ !== i){var i=_sE_;continue}
            break}}
        return caml_string_of_bytes(buf)}
      return s}
    function convert_int(iconv,n)
     {switch(iconv)
       {case 1:var _sz_=cst_d$3;break;
        case 2:var _sz_=cst_d$4;break;
        case 4:var _sz_=cst_i$1;break;
        case 5:var _sz_=cst_i$2;break;
        case 6:var _sz_=cst_x;break;
        case 7:var _sz_=cst_x$0;break;
        case 8:var _sz_=cst_X$0;break;
        case 9:var _sz_=cst_X$1;break;
        case 10:var _sz_=cst_o;break;
        case 11:var _sz_=cst_o$0;break;
        case 0:
        case 13:var _sz_=cst_d$2;break;
        case 3:
        case 14:var _sz_=cst_i$0;break;
        default:var _sz_=cst_u}
      return transform_int_alt(iconv,caml_format_int(_sz_,n))}
    function convert_int32(iconv,n)
     {switch(iconv)
       {case 1:var _sy_=cst_ld$0;break;
        case 2:var _sy_=cst_ld$1;break;
        case 4:var _sy_=cst_li$1;break;
        case 5:var _sy_=cst_li$2;break;
        case 6:var _sy_=cst_lx;break;
        case 7:var _sy_=cst_lx$0;break;
        case 8:var _sy_=cst_lX;break;
        case 9:var _sy_=cst_lX$0;break;
        case 10:var _sy_=cst_lo;break;
        case 11:var _sy_=cst_lo$0;break;
        case 0:
        case 13:var _sy_=cst_ld;break;
        case 3:
        case 14:var _sy_=cst_li$0;break;
        default:var _sy_=cst_lu}
      return transform_int_alt(iconv,caml_format_int(_sy_,n))}
    function convert_nativeint(iconv,n)
     {switch(iconv)
       {case 1:var _sx_=cst_nd$0;break;
        case 2:var _sx_=cst_nd$1;break;
        case 4:var _sx_=cst_ni$1;break;
        case 5:var _sx_=cst_ni$2;break;
        case 6:var _sx_=cst_nx;break;
        case 7:var _sx_=cst_nx$0;break;
        case 8:var _sx_=cst_nX;break;
        case 9:var _sx_=cst_nX$0;break;
        case 10:var _sx_=cst_no;break;
        case 11:var _sx_=cst_no$0;break;
        case 0:
        case 13:var _sx_=cst_nd;break;
        case 3:
        case 14:var _sx_=cst_ni$0;break;
        default:var _sx_=cst_nu}
      return transform_int_alt(iconv,caml_format_int(_sx_,n))}
    function convert_int64(iconv,n)
     {switch(iconv)
       {case 1:var _sw_=cst_Ld$0;break;
        case 2:var _sw_=cst_Ld$1;break;
        case 4:var _sw_=cst_Li$1;break;
        case 5:var _sw_=cst_Li$2;break;
        case 6:var _sw_=cst_Lx;break;
        case 7:var _sw_=cst_Lx$0;break;
        case 8:var _sw_=cst_LX;break;
        case 9:var _sw_=cst_LX$0;break;
        case 10:var _sw_=cst_Lo;break;
        case 11:var _sw_=cst_Lo$0;break;
        case 0:
        case 13:var _sw_=cst_Ld;break;
        case 3:
        case 14:var _sw_=cst_Li$0;break;
        default:var _sw_=cst_Lu}
      return transform_int_alt(iconv,caml_int64_format(_sw_,n))}
    function convert_float(fconv,prec,x)
     {function hex(param)
       {switch(fconv[1])
         {case 0:var sign=45;break;
          case 1:var sign=43;break;
          default:var sign=32}
        return runtime.caml_hexstring_of_float(x,prec,sign)}
      function caml_special_val(str)
       {var match=runtime.caml_classify_float(x);
        return 3 === match
                ?x < 0.?cst_neg_infinity:cst_infinity
                :4 <= match?cst_nan:str}
      switch(fconv[2])
       {case 5:
         var
          str=caml_format_float(format_of_fconv(fconv,prec),x),
          len=caml_ml_string_length(str),
          i=0;
         for(;;)
          {if(i === len)
            var _su_=0;
           else
            {var match=caml_string_get(str,i),_st_=match - 46 | 0,switch$0=0;
             if(23 < _st_ >>> 0)
              {if(55 === _st_)switch$0 = 1}
             else
              if(21 < (_st_ - 1 | 0) >>> 0)switch$0 = 1;
             if(! switch$0){var i$0=i + 1 | 0,i=i$0;continue}
             var _su_=1}
           var _sv_=_su_?str:symbol(str,cst$29);
           return caml_special_val(_sv_)}
        case 6:return hex(0);
        case 7:return uppercase_ascii$1(hex(0));
        case 8:return caml_special_val(hex(0));
        default:return caml_format_float(format_of_fconv(fconv,prec),x)}}
    function string_of_fmtty(fmtty)
     {var buf=buffer_create(16);
      bprint_fmtty(buf,fmtty);
      return buffer_contents(buf)}
    function make_printf$0(counter,k,acc,fmt)
     {var k$0=k,acc$0=acc,fmt$0=fmt;
      for(;;)
       if(typeof fmt$0 === "number")
        return caml_call1(k$0,acc$0);
       else
        switch(fmt$0[0])
         {case 0:
           var rest=fmt$0[1];
           return function(c)
            {var new_acc=[5,acc$0,c];return make_printf(k$0,new_acc,rest)};
          case 1:
           var rest$0=fmt$0[1];
           return function(c)
            {var
              str=escaped(c),
              l=caml_ml_string_length(str),
              res=make$0(l + 2 | 0,39);
             caml_blit_string(str,0,res,1,l);
             var new_acc=[4,acc$0,caml_string_of_bytes(res)];
             return make_printf(k$0,new_acc,rest$0)};
          case 2:
           var rest$1=fmt$0[2],pad=fmt$0[1];
           return make_padding(k$0,acc$0,rest$1,pad,function(str){return str});
          case 3:
           var rest$2=fmt$0[2],pad$0=fmt$0[1];
           return make_padding(k$0,acc$0,rest$2,pad$0,string_to_caml_string);
          case 4:
           var rest$3=fmt$0[4],prec=fmt$0[3],pad$1=fmt$0[2],iconv=fmt$0[1];
           return make_int_padding_precision
                   (k$0,acc$0,rest$3,pad$1,prec,convert_int,iconv);
          case 5:
           var
            rest$4=fmt$0[4],
            prec$0=fmt$0[3],
            pad$2=fmt$0[2],
            iconv$0=fmt$0[1];
           return make_int_padding_precision
                   (k$0,acc$0,rest$4,pad$2,prec$0,convert_int32,iconv$0);
          case 6:
           var
            rest$5=fmt$0[4],
            prec$1=fmt$0[3],
            pad$3=fmt$0[2],
            iconv$1=fmt$0[1];
           return make_int_padding_precision
                   (k$0,acc$0,rest$5,pad$3,prec$1,convert_nativeint,iconv$1);
          case 7:
           var
            rest$6=fmt$0[4],
            prec$2=fmt$0[3],
            pad$4=fmt$0[2],
            iconv$2=fmt$0[1];
           return make_int_padding_precision
                   (k$0,acc$0,rest$6,pad$4,prec$2,convert_int64,iconv$2);
          case 8:
           var rest$7=fmt$0[4],prec$3=fmt$0[3],pad$5=fmt$0[2],fconv=fmt$0[1];
           if(typeof pad$5 === "number")
            {if(typeof prec$3 === "number")
              return prec$3
                      ?function(p,x)
                        {var str=convert_float(fconv,p,x);
                         return make_printf(k$0,[4,acc$0,str],rest$7)}
                      :function(x)
                        {var
                          str=
                           convert_float(fconv,default_float_precision(fconv),x);
                         return make_printf(k$0,[4,acc$0,str],rest$7)};
             var p=prec$3[1];
             return function(x)
              {var str=convert_float(fconv,p,x);
               return make_printf(k$0,[4,acc$0,str],rest$7)}}
           else
            {if(0 === pad$5[0])
              {var _sq_=pad$5[2],_sr_=pad$5[1];
               if(typeof prec$3 === "number")
                return prec$3
                        ?function(p,x)
                          {var str=fix_padding(_sr_,_sq_,convert_float(fconv,p,x));
                           return make_printf(k$0,[4,acc$0,str],rest$7)}
                        :function(x)
                          {var
                            str=convert_float(fconv,default_float_precision(fconv),x),
                            str$0=fix_padding(_sr_,_sq_,str);
                           return make_printf(k$0,[4,acc$0,str$0],rest$7)};
               var p$0=prec$3[1];
               return function(x)
                {var str=fix_padding(_sr_,_sq_,convert_float(fconv,p$0,x));
                 return make_printf(k$0,[4,acc$0,str],rest$7)}}
             var _ss_=pad$5[1];
             if(typeof prec$3 === "number")
              return prec$3
                      ?function(w,p,x)
                        {var str=fix_padding(_ss_,w,convert_float(fconv,p,x));
                         return make_printf(k$0,[4,acc$0,str],rest$7)}
                      :function(w,x)
                        {var
                          str=convert_float(fconv,default_float_precision(fconv),x),
                          str$0=fix_padding(_ss_,w,str);
                         return make_printf(k$0,[4,acc$0,str$0],rest$7)};
             var p$1=prec$3[1];
             return function(w,x)
              {var str=fix_padding(_ss_,w,convert_float(fconv,p$1,x));
               return make_printf(k$0,[4,acc$0,str],rest$7)}}
          case 9:
           var rest$8=fmt$0[2],pad$6=fmt$0[1];
           return make_padding(k$0,acc$0,rest$8,pad$6,string_of_bool);
          case 10:
           var fmt$1=fmt$0[1],acc$1=[7,acc$0],acc$0=acc$1,fmt$0=fmt$1;
           continue;
          case 11:
           var
            fmt$2=fmt$0[2],
            str=fmt$0[1],
            acc$2=[2,acc$0,str],
            acc$0=acc$2,
            fmt$0=fmt$2;
           continue;
          case 12:
           var
            fmt$3=fmt$0[2],
            chr=fmt$0[1],
            acc$3=[3,acc$0,chr],
            acc$0=acc$3,
            fmt$0=fmt$3;
           continue;
          case 13:
           var
            rest$9=fmt$0[3],
            sub_fmtty=fmt$0[2],
            ty=string_of_fmtty(sub_fmtty);
           return function(str){return make_printf(k$0,[4,acc$0,ty],rest$9)};
          case 14:
           var rest$10=fmt$0[3],fmtty=fmt$0[2];
           return function(param)
            {var fmt=param[1];
             return make_printf
                     (k$0,acc$0,concat_fmt(recast(fmt,fmtty),rest$10))};
          case 15:
           var rest$11=fmt$0[1];
           return function(f,x)
            {return make_printf
                     (k$0,
                      [6,acc$0,function(o){return caml_call2(f,o,x)}],
                      rest$11)};
          case 16:
           var rest$12=fmt$0[1];
           return function(f){return make_printf(k$0,[6,acc$0,f],rest$12)};
          case 17:
           var
            fmt$4=fmt$0[2],
            fmting_lit=fmt$0[1],
            acc$4=[0,acc$0,fmting_lit],
            acc$0=acc$4,
            fmt$0=fmt$4;
           continue;
          case 18:
           var _so_=fmt$0[1];
           if(0 === _so_[0])
            {var
              rest$13=fmt$0[2],
              match=_so_[1],
              fmt$5=match[1],
              k$3=
               function(acc,k,rest)
                {function k$0(kacc)
                  {return make_printf(k,[1,acc,[0,kacc]],rest)}
                 return k$0},
              k$1=k$3(acc$0,k$0,rest$13),
              k$0=k$1,
              acc$0=0,
              fmt$0=fmt$5;
             continue}
           var
            rest$14=fmt$0[2],
            match$0=_so_[1],
            fmt$6=match$0[1],
            k$4=
             function(acc,k,rest)
              {function k$0(kacc){return make_printf(k,[1,acc,[1,kacc]],rest)}
               return k$0},
            k$2=k$4(acc$0,k$0,rest$14),
            k$0=k$2,
            acc$0=0,
            fmt$0=fmt$6;
           continue;
          case 19:throw [0,Assert_failure,_ar_];
          case 20:
           var rest$15=fmt$0[3],new_acc=[8,acc$0,cst_Printf_bad_conversion];
           return function(param){return make_printf(k$0,new_acc,rest$15)};
          case 21:
           var rest$16=fmt$0[2];
           return function(n)
            {var new_acc=[4,acc$0,caml_format_int(cst_u$0,n)];
             return make_printf(k$0,new_acc,rest$16)};
          case 22:
           var rest$17=fmt$0[1];
           return function(c)
            {var new_acc=[5,acc$0,c];return make_printf(k$0,new_acc,rest$17)};
          case 23:
           var rest$18=fmt$0[2],ign=fmt$0[1];
           if(counter < 50)
            {var counter$1=counter + 1 | 0;
             return make_ignored_param$0(counter$1,k$0,acc$0,ign,rest$18)}
           return caml_trampoline_return
                   (make_ignored_param$0,[0,k$0,acc$0,ign,rest$18]);
          default:
           var
            rest$19=fmt$0[3],
            f=fmt$0[2],
            arity=fmt$0[1],
            _sp_=caml_call1(f,0);
           if(counter < 50)
            {var counter$0=counter + 1 | 0;
             return make_custom$0(counter$0,k$0,acc$0,rest$19,arity,_sp_)}
           return caml_trampoline_return
                   (make_custom$0,[0,k$0,acc$0,rest$19,arity,_sp_])}}
    function make_ignored_param$0(counter,k,acc,ign,fmt)
     {if(typeof ign === "number")
       switch(ign)
        {case 0:
          if(counter < 50)
           {var counter$0=counter + 1 | 0;
            return make_invalid_arg(counter$0,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 1:
          if(counter < 50)
           {var counter$1=counter + 1 | 0;
            return make_invalid_arg(counter$1,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 2:throw [0,Assert_failure,_as_];
         default:
          if(counter < 50)
           {var counter$2=counter + 1 | 0;
            return make_invalid_arg(counter$2,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt])}
      else
       switch(ign[0])
        {case 0:
          if(counter < 50)
           {var counter$3=counter + 1 | 0;
            return make_invalid_arg(counter$3,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 1:
          if(counter < 50)
           {var counter$4=counter + 1 | 0;
            return make_invalid_arg(counter$4,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 2:
          if(counter < 50)
           {var counter$5=counter + 1 | 0;
            return make_invalid_arg(counter$5,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 3:
          if(counter < 50)
           {var counter$6=counter + 1 | 0;
            return make_invalid_arg(counter$6,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 4:
          if(counter < 50)
           {var counter$7=counter + 1 | 0;
            return make_invalid_arg(counter$7,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 5:
          if(counter < 50)
           {var counter$8=counter + 1 | 0;
            return make_invalid_arg(counter$8,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 6:
          if(counter < 50)
           {var counter$9=counter + 1 | 0;
            return make_invalid_arg(counter$9,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 7:
          if(counter < 50)
           {var counter$10=counter + 1 | 0;
            return make_invalid_arg(counter$10,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 8:
          if(counter < 50)
           {var counter$11=counter + 1 | 0;
            return make_invalid_arg(counter$11,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 9:
          var fmtty=ign[2];
          if(counter < 50)
           {var counter$14=counter + 1 | 0;
            return make_from_fmtty$0(counter$14,k,acc,fmtty,fmt)}
          return caml_trampoline_return(make_from_fmtty$0,[0,k,acc,fmtty,fmt]);
         case 10:
          if(counter < 50)
           {var counter$12=counter + 1 | 0;
            return make_invalid_arg(counter$12,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         default:
          if(counter < 50)
           {var counter$13=counter + 1 | 0;
            return make_invalid_arg(counter$13,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt])}}
    function make_from_fmtty$0(counter,k,acc,fmtty,fmt)
     {if(typeof fmtty === "number")
       {if(counter < 50)
         {var counter$0=counter + 1 | 0;
          return make_invalid_arg(counter$0,k,acc,fmt)}
        return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt])}
      else
       switch(fmtty[0])
        {case 0:
          var rest=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest,fmt)};
         case 1:
          var rest$0=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$0,fmt)};
         case 2:
          var rest$1=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$1,fmt)};
         case 3:
          var rest$2=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$2,fmt)};
         case 4:
          var rest$3=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$3,fmt)};
         case 5:
          var rest$4=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$4,fmt)};
         case 6:
          var rest$5=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$5,fmt)};
         case 7:
          var rest$6=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$6,fmt)};
         case 8:
          var rest$7=fmtty[2];
          return function(param){return make_from_fmtty(k,acc,rest$7,fmt)};
         case 9:
          var
           rest$8=fmtty[3],
           ty2=fmtty[2],
           ty1=fmtty[1],
           ty=trans(symm(ty1),ty2);
          return function(param)
           {return make_from_fmtty(k,acc,concat_fmtty(ty,rest$8),fmt)};
         case 10:
          var rest$9=fmtty[1];
          return function(param,_sn_)
           {return make_from_fmtty(k,acc,rest$9,fmt)};
         case 11:
          var rest$10=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$10,fmt)};
         case 12:
          var rest$11=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$11,fmt)};
         case 13:throw [0,Assert_failure,_at_];
         default:throw [0,Assert_failure,_au_]}}
    function make_invalid_arg(counter,k,acc,fmt)
     {var _sm_=[8,acc,cst_Printf_bad_conversion$0];
      if(counter < 50)
       {var counter$0=counter + 1 | 0;
        return make_printf$0(counter$0,k,_sm_,fmt)}
      return caml_trampoline_return(make_printf$0,[0,k,_sm_,fmt])}
    function make_custom$0(counter,k,acc,rest,arity,f)
     {if(arity)
       {var arity$0=arity[1];
        return function(x)
         {return make_custom(k,acc,rest,arity$0,caml_call1(f,x))}}
      var _sl_=[4,acc,f];
      if(counter < 50)
       {var counter$0=counter + 1 | 0;
        return make_printf$0(counter$0,k,_sl_,rest)}
      return caml_trampoline_return(make_printf$0,[0,k,_sl_,rest])}
    function make_printf(k,acc,fmt)
     {return caml_trampoline(make_printf$0(0,k,acc,fmt))}
    function make_ignored_param(k,acc,ign,fmt)
     {return caml_trampoline(make_ignored_param$0(0,k,acc,ign,fmt))}
    function make_from_fmtty(k,acc,fmtty,fmt)
     {return caml_trampoline(make_from_fmtty$0(0,k,acc,fmtty,fmt))}
    function make_custom(k,acc,rest,arity,f)
     {return caml_trampoline(make_custom$0(0,k,acc,rest,arity,f))}
    function make_padding(k,acc,fmt,pad,trans)
     {if(typeof pad === "number")
       return function(x)
        {var new_acc=[4,acc,caml_call1(trans,x)];
         return make_printf(k,new_acc,fmt)};
      else
       {if(0 === pad[0])
         {var width=pad[2],padty=pad[1];
          return function(x)
           {var new_acc=[4,acc,fix_padding(padty,width,caml_call1(trans,x))];
            return make_printf(k,new_acc,fmt)}}
        var padty$0=pad[1];
        return function(w,x)
         {var new_acc=[4,acc,fix_padding(padty$0,w,caml_call1(trans,x))];
          return make_printf(k,new_acc,fmt)}}}
    function make_int_padding_precision(k,acc,fmt,pad,match,trans,iconv)
     {if(typeof pad === "number")
       {if(typeof match === "number")
         return match
                 ?function(p,x)
                   {var str=fix_int_precision(p,caml_call2(trans,iconv,x));
                    return make_printf(k,[4,acc,str],fmt)}
                 :function(x)
                   {var str=caml_call2(trans,iconv,x);
                    return make_printf(k,[4,acc,str],fmt)};
        var p=match[1];
        return function(x)
         {var str=fix_int_precision(p,caml_call2(trans,iconv,x));
          return make_printf(k,[4,acc,str],fmt)}}
      else
       {if(0 === pad[0])
         {var _si_=pad[2],_sj_=pad[1];
          if(typeof match === "number")
           return match
                   ?function(p,x)
                     {var
                       str=
                        fix_padding
                         (_sj_,_si_,fix_int_precision(p,caml_call2(trans,iconv,x)));
                      return make_printf(k,[4,acc,str],fmt)}
                   :function(x)
                     {var str=fix_padding(_sj_,_si_,caml_call2(trans,iconv,x));
                      return make_printf(k,[4,acc,str],fmt)};
          var p$0=match[1];
          return function(x)
           {var
             str=
              fix_padding
               (_sj_,_si_,fix_int_precision(p$0,caml_call2(trans,iconv,x)));
            return make_printf(k,[4,acc,str],fmt)}}
        var _sk_=pad[1];
        if(typeof match === "number")
         return match
                 ?function(w,p,x)
                   {var
                     str=
                      fix_padding
                       (_sk_,w,fix_int_precision(p,caml_call2(trans,iconv,x)));
                    return make_printf(k,[4,acc,str],fmt)}
                 :function(w,x)
                   {var str=fix_padding(_sk_,w,caml_call2(trans,iconv,x));
                    return make_printf(k,[4,acc,str],fmt)};
        var p$1=match[1];
        return function(w,x)
         {var
           str=
            fix_padding
             (_sk_,w,fix_int_precision(p$1,caml_call2(trans,iconv,x)));
          return make_printf(k,[4,acc,str],fmt)}}}
    function make_iprintf$0(counter,k,o,fmt)
     {var k$0=k,fmt$0=fmt;
      for(;;)
       if(typeof fmt$0 === "number")
        return caml_call1(k$0,o);
       else
        switch(fmt$0[0])
         {case 0:
           var rest=fmt$0[1],_rz_=make_iprintf(k$0,o,rest);
           return function(_sh_){return _rz_};
          case 1:
           var rest$0=fmt$0[1],_rA_=make_iprintf(k$0,o,rest$0);
           return function(_sg_){return _rA_};
          case 2:
           var _rB_=fmt$0[1];
           if(typeof _rB_ === "number")
            {var rest$1=fmt$0[2],_rC_=make_iprintf(k$0,o,rest$1);
             return function(_sc_){return _rC_}}
           else
            {if(0 === _rB_[0])
              {var rest$2=fmt$0[2],_rD_=make_iprintf(k$0,o,rest$2);
               return function(_sf_){return _rD_}}
             var
              rest$3=fmt$0[2],
              _rE_=make_iprintf(k$0,o,rest$3),
              _rF_=function(_se_){return _rE_};
             return function(_sd_){return _rF_}}
          case 3:
           var _rG_=fmt$0[1];
           if(typeof _rG_ === "number")
            {var rest$4=fmt$0[2],_rH_=make_iprintf(k$0,o,rest$4);
             return function(_r__){return _rH_}}
           else
            {if(0 === _rG_[0])
              {var rest$5=fmt$0[2],_rI_=make_iprintf(k$0,o,rest$5);
               return function(_sb_){return _rI_}}
             var
              rest$6=fmt$0[2],
              _rJ_=make_iprintf(k$0,o,rest$6),
              _rK_=function(_sa_){return _rJ_};
             return function(_r$_){return _rK_}}
          case 4:
           var rest$7=fmt$0[4],prec=fmt$0[3],pad=fmt$0[2];
           return fn_of_padding_precision(k$0,o,rest$7,pad,prec);
          case 5:
           var rest$8=fmt$0[4],prec$0=fmt$0[3],pad$0=fmt$0[2];
           return fn_of_padding_precision(k$0,o,rest$8,pad$0,prec$0);
          case 6:
           var rest$9=fmt$0[4],prec$1=fmt$0[3],pad$1=fmt$0[2];
           return fn_of_padding_precision(k$0,o,rest$9,pad$1,prec$1);
          case 7:
           var rest$10=fmt$0[4],prec$2=fmt$0[3],pad$2=fmt$0[2];
           return fn_of_padding_precision(k$0,o,rest$10,pad$2,prec$2);
          case 8:
           var rest$11=fmt$0[4],prec$3=fmt$0[3],pad$3=fmt$0[2];
           return fn_of_padding_precision(k$0,o,rest$11,pad$3,prec$3);
          case 9:
           var _rL_=fmt$0[1];
           if(typeof _rL_ === "number")
            {var rest$12=fmt$0[2],_rM_=make_iprintf(k$0,o,rest$12);
             return function(_r6_){return _rM_}}
           else
            {if(0 === _rL_[0])
              {var rest$13=fmt$0[2],_rN_=make_iprintf(k$0,o,rest$13);
               return function(_r9_){return _rN_}}
             var
              rest$14=fmt$0[2],
              _rO_=make_iprintf(k$0,o,rest$14),
              _rP_=function(_r8_){return _rO_};
             return function(_r7_){return _rP_}}
          case 10:var fmt$1=fmt$0[1],fmt$0=fmt$1;continue;
          case 11:var fmt$2=fmt$0[2],fmt$0=fmt$2;continue;
          case 12:var fmt$3=fmt$0[2],fmt$0=fmt$3;continue;
          case 13:
           var rest$15=fmt$0[3],_rQ_=make_iprintf(k$0,o,rest$15);
           return function(_r5_){return _rQ_};
          case 14:
           var rest$16=fmt$0[3],fmtty=fmt$0[2];
           return function(param)
            {var fmt=param[1];
             return make_iprintf(k$0,o,concat_fmt(recast(fmt,fmtty),rest$16))};
          case 15:
           var
            rest$17=fmt$0[1],
            _rR_=make_iprintf(k$0,o,rest$17),
            _rS_=function(_r4_){return _rR_};
           return function(_r3_){return _rS_};
          case 16:
           var rest$18=fmt$0[1],_rT_=make_iprintf(k$0,o,rest$18);
           return function(_r2_){return _rT_};
          case 17:var fmt$4=fmt$0[2],fmt$0=fmt$4;continue;
          case 18:
           var _rU_=fmt$0[1];
           if(0 === _rU_[0])
            {var
              rest$19=fmt$0[2],
              match=_rU_[1],
              fmt$5=match[1],
              k$3=
               function(k,rest)
                {function k$0(koc){return make_iprintf(k,koc,rest)}return k$0},
              k$1=k$3(k$0,rest$19),
              k$0=k$1,
              fmt$0=fmt$5;
             continue}
           var
            rest$20=fmt$0[2],
            match$0=_rU_[1],
            fmt$6=match$0[1],
            k$4=
             function(k,rest)
              {function k$0(koc){return make_iprintf(k,koc,rest)}return k$0},
            k$2=k$4(k$0,rest$20),
            k$0=k$2,
            fmt$0=fmt$6;
           continue;
          case 19:throw [0,Assert_failure,_av_];
          case 20:
           var rest$21=fmt$0[3],_rV_=make_iprintf(k$0,o,rest$21);
           return function(_r1_){return _rV_};
          case 21:
           var rest$22=fmt$0[2],_rW_=make_iprintf(k$0,o,rest$22);
           return function(_r0_){return _rW_};
          case 22:
           var rest$23=fmt$0[1],_rX_=make_iprintf(k$0,o,rest$23);
           return function(_rZ_){return _rX_};
          case 23:
           var rest$24=fmt$0[2],ign=fmt$0[1],_rY_=0;
           return make_ignored_param
                   (function(param){return caml_call1(k$0,o)},_rY_,ign,rest$24);
          default:
           var rest$25=fmt$0[3],arity=fmt$0[1];
           if(counter < 50)
            {var counter$0=counter + 1 | 0;
             return fn_of_custom_arity$0(counter$0,k$0,o,rest$25,arity)}
           return caml_trampoline_return
                   (fn_of_custom_arity$0,[0,k$0,o,rest$25,arity])}}
    function fn_of_custom_arity$0(counter,k,o,fmt,param)
     {if(param)
       {var arity=param[1],_rx_=fn_of_custom_arity(k,o,fmt,arity);
        return function(_ry_){return _rx_}}
      if(counter < 50)
       {var counter$0=counter + 1 | 0;
        return make_iprintf$0(counter$0,k,o,fmt)}
      return caml_trampoline_return(make_iprintf$0,[0,k,o,fmt])}
    function make_iprintf(k,o,fmt)
     {return caml_trampoline(make_iprintf$0(0,k,o,fmt))}
    function fn_of_custom_arity(k,o,fmt,param)
     {return caml_trampoline(fn_of_custom_arity$0(0,k,o,fmt,param))}
    function fn_of_padding_precision(k,o,fmt,pad,prec)
     {if(typeof pad === "number")
       {if(typeof prec === "number")
         {if(prec)
           {var _q5_=make_iprintf(k,o,fmt),_q6_=function(_rl_){return _q5_};
            return function(_rk_){return _q6_}}
          var _q7_=make_iprintf(k,o,fmt);
          return function(_rj_){return _q7_}}
        var _q8_=make_iprintf(k,o,fmt);
        return function(_ri_){return _q8_}}
      else
       {if(0 === pad[0])
         {if(typeof prec === "number")
           {if(prec)
             {var _q9_=make_iprintf(k,o,fmt),_q__=function(_rw_){return _q9_};
              return function(_rv_){return _q__}}
            var _q$_=make_iprintf(k,o,fmt);
            return function(_ru_){return _q$_}}
          var _ra_=make_iprintf(k,o,fmt);
          return function(_rt_){return _ra_}}
        if(typeof prec === "number")
         {if(prec)
           {var
             _rb_=make_iprintf(k,o,fmt),
             _rc_=function(_rs_){return _rb_},
             _rd_=function(_rr_){return _rc_};
            return function(_rq_){return _rd_}}
          var _re_=make_iprintf(k,o,fmt),_rf_=function(_rp_){return _re_};
          return function(_ro_){return _rf_}}
        var _rg_=make_iprintf(k,o,fmt),_rh_=function(_rn_){return _rg_};
        return function(_rm_){return _rh_}}}
    function output_acc(o,acc)
     {var acc$0=acc;
      for(;;)
       if(typeof acc$0 === "number")
        return 0;
       else
        switch(acc$0[0])
         {case 0:
           var
            fmting_lit=acc$0[2],
            p=acc$0[1],
            s=string_of_formatting_lit(fmting_lit);
           output_acc(o,p);
           return output_string(o,s);
          case 1:
           var _q3_=acc$0[2],_q4_=acc$0[1];
           if(0 === _q3_[0])
            {var acc$1=_q3_[1];
             output_acc(o,_q4_);
             output_string(o,cst$30);
             var acc$0=acc$1;
             continue}
           var acc$2=_q3_[1];
           output_acc(o,_q4_);
           output_string(o,cst$31);
           var acc$0=acc$2;
           continue;
          case 6:
           var f=acc$0[2],p$2=acc$0[1];
           output_acc(o,p$2);
           return caml_call1(f,o);
          case 7:var p$3=acc$0[1];output_acc(o,p$3);return caml_ml_flush(o);
          case 8:
           var msg=acc$0[2],p$4=acc$0[1];
           output_acc(o,p$4);
           return invalid_arg(msg);
          case 2:
          case 4:
           var s$0=acc$0[2],p$0=acc$0[1];
           output_acc(o,p$0);
           return output_string(o,s$0);
          default:
           var c=acc$0[2],p$1=acc$0[1];
           output_acc(o,p$1);
           return caml_ml_output_char(o,c)}}
    function bufput_acc(b,acc)
     {var acc$0=acc;
      for(;;)
       if(typeof acc$0 === "number")
        return 0;
       else
        switch(acc$0[0])
         {case 0:
           var
            fmting_lit=acc$0[2],
            p=acc$0[1],
            s=string_of_formatting_lit(fmting_lit);
           bufput_acc(b,p);
           return add_string(b,s);
          case 1:
           var _q1_=acc$0[2],_q2_=acc$0[1];
           if(0 === _q1_[0])
            {var acc$1=_q1_[1];
             bufput_acc(b,_q2_);
             add_string(b,cst$32);
             var acc$0=acc$1;
             continue}
           var acc$2=_q1_[1];
           bufput_acc(b,_q2_);
           add_string(b,cst$33);
           var acc$0=acc$2;
           continue;
          case 6:
           var f=acc$0[2],p$2=acc$0[1];
           bufput_acc(b,p$2);
           return caml_call1(f,b);
          case 7:var acc$3=acc$0[1],acc$0=acc$3;continue;
          case 8:
           var msg=acc$0[2],p$3=acc$0[1];
           bufput_acc(b,p$3);
           return invalid_arg(msg);
          case 2:
          case 4:
           var s$0=acc$0[2],p$0=acc$0[1];
           bufput_acc(b,p$0);
           return add_string(b,s$0);
          default:
           var c=acc$0[2],p$1=acc$0[1];bufput_acc(b,p$1);return add_char(b,c)}}
    function strput_acc(b,acc)
     {var acc$0=acc;
      for(;;)
       if(typeof acc$0 === "number")
        return 0;
       else
        switch(acc$0[0])
         {case 0:
           var
            fmting_lit=acc$0[2],
            p=acc$0[1],
            s=string_of_formatting_lit(fmting_lit);
           strput_acc(b,p);
           return add_string(b,s);
          case 1:
           var _qZ_=acc$0[2],_q0_=acc$0[1];
           if(0 === _qZ_[0])
            {var acc$1=_qZ_[1];
             strput_acc(b,_q0_);
             add_string(b,cst$34);
             var acc$0=acc$1;
             continue}
           var acc$2=_qZ_[1];
           strput_acc(b,_q0_);
           add_string(b,cst$35);
           var acc$0=acc$2;
           continue;
          case 6:
           var f=acc$0[2],p$2=acc$0[1];
           strput_acc(b,p$2);
           return add_string(b,caml_call1(f,0));
          case 7:var acc$3=acc$0[1],acc$0=acc$3;continue;
          case 8:
           var msg=acc$0[2],p$3=acc$0[1];
           strput_acc(b,p$3);
           return invalid_arg(msg);
          case 2:
          case 4:
           var s$0=acc$0[2],p$0=acc$0[1];
           strput_acc(b,p$0);
           return add_string(b,s$0);
          default:
           var c=acc$0[2],p$1=acc$0[1];strput_acc(b,p$1);return add_char(b,c)}}
    function failwith_message(param)
     {var fmt=param[1],buf=create$2(256);
      function k(acc){strput_acc(buf,acc);return failwith(contents(buf))}
      return make_printf(k,0,fmt)}
    function open_box_of_string(str)
     {if(caml_string_equal(str,cst$36))return _aw_;
      var len=caml_ml_string_length(str);
      function invalid_box(param)
       {return caml_call1(failwith_message(_ax_),str)}
      function parse_spaces(i)
       {var i$0=i;
        for(;;)
         {if(i$0 === len)return i$0;
          var match=caml_string_get(str,i$0);
          if(9 !== match && 32 !== match)return i$0;
          var i$1=i$0 + 1 | 0,i$0=i$1;
          continue}}
      function parse_lword(i,j)
       {var j$0=j;
        for(;;)
         {if(j$0 === len)return j$0;
          var match=caml_string_get(str,j$0),switcher=match - 97 | 0;
          if(25 < switcher >>> 0)return j$0;
          var j$1=j$0 + 1 | 0,j$0=j$1;
          continue}}
      function parse_int(i,j)
       {var j$0=j;
        for(;;)
         {if(j$0 === len)return j$0;
          var match=caml_string_get(str,j$0),switch$0=0;
          if(48 <= match)
           {if(! (58 <= match))switch$0 = 1}
          else
           if(45 === match)switch$0 = 1;
          if(switch$0){var j$1=j$0 + 1 | 0,j$0=j$1;continue}
          return j$0}}
      var
       wstart=parse_spaces(0),
       wend=parse_lword(wstart,wstart),
       box_name=sub$0(str,wstart,wend - wstart | 0),
       nstart=parse_spaces(wend),
       nend=parse_int(nstart,nstart);
      if(nstart === nend)
       var indent=0;
      else
       try
        {var
          _qX_=caml_int_of_string(sub$0(str,nstart,nend - nstart | 0)),
          indent=_qX_}
       catch(_qY_)
        {_qY_ = caml_wrap_exception(_qY_);
         if(_qY_[1] !== Failure)throw _qY_;
         var indent=invalid_box(0)}
      var exp_end=parse_spaces(nend);
      if(exp_end !== len)invalid_box(0);
      var switch$0=0;
      if
       (caml_string_notequal(box_name,cst$37)
        &&
        caml_string_notequal(box_name,cst_b$0))
       var
        box_type=
         caml_string_notequal(box_name,cst_h)
          ?caml_string_notequal(box_name,cst_hov)
            ?caml_string_notequal(box_name,cst_hv)
              ?caml_string_notequal(box_name,cst_v)?invalid_box(0):1
              :2
            :3
          :0;
      else
       switch$0 = 1;
      if(switch$0)var box_type=4;
      return [0,indent,box_type]}
    function make_padding_fmt_ebb(pad,fmt)
     {if(typeof pad === "number")
       return [0,0,fmt];
      else
       {if(0 === pad[0]){var w=pad[2],s=pad[1];return [0,[0,s,w],fmt]}
        var s$0=pad[1];
        return [0,[1,s$0],fmt]}}
    function make_padprec_fmt_ebb(pad,prec,fmt)
     {if(typeof prec === "number")
       var match=prec?[0,1,fmt]:[0,0,fmt];
      else
       var p=prec[1],match=[0,[0,p],fmt];
      var prec$0=match[1];
      if(typeof pad === "number")
       return [0,0,prec$0,fmt];
      else
       {if(0 === pad[0]){var w=pad[2],s=pad[1];return [0,[0,s,w],prec$0,fmt]}
        var s$0=pad[1];
        return [0,[1,s$0],prec$0,fmt]}}
    function fmt_ebb_of_string(legacy_behavior,str)
     {if(legacy_behavior)
       var flag=legacy_behavior[1],legacy_behavior$0=flag;
      else
       var legacy_behavior$0=1;
      function invalid_format_message(str_ind,msg)
       {return caml_call3(failwith_message(_ay_),str,str_ind,msg)}
      function unexpected_end_of_format(end_ind)
       {return invalid_format_message(end_ind,cst_unexpected_end_of_format)}
      function invalid_format_without(str_ind,c,s)
       {return caml_call4(failwith_message(_az_),str,str_ind,c,s)}
      function expected_character(str_ind,expected,read)
       {return caml_call4(failwith_message(_aA_),str,str_ind,expected,read)}
      function add_literal(lit_start,str_ind,fmt)
       {var size=str_ind - lit_start | 0;
        return 0 === size
                ?[0,fmt]
                :1 === size
                  ?[0,[12,caml_string_get(str,lit_start),fmt]]
                  :[0,[11,sub$0(str,lit_start,size),fmt]]}
      function parse_positive(str_ind,end_ind,acc)
       {var str_ind$0=str_ind,acc$0=acc;
        for(;;)
         {if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
          var c=caml_string_get(str,str_ind$0),switcher=c - 48 | 0;
          if(9 < switcher >>> 0)return [0,str_ind$0,acc$0];
          var acc$1=(acc$0 * 10 | 0) + (c - 48 | 0) | 0;
          if(max_string_length < acc$1)
           return caml_call3
                   (failwith_message(_aR_),str,acc$1,max_string_length);
          var str_ind$1=str_ind$0 + 1 | 0,str_ind$0=str_ind$1,acc$0=acc$1;
          continue}}
      function parse_integer(str_ind,end_ind)
       {if(str_ind === end_ind)unexpected_end_of_format(end_ind);
        var match=caml_string_get(str,str_ind);
        if(48 <= match)
         {if(! (58 <= match))return parse_positive(str_ind,end_ind,0)}
        else
         if(45 === match)
          {if((str_ind + 1 | 0) === end_ind)unexpected_end_of_format(end_ind);
           var c=caml_string_get(str,str_ind + 1 | 0),switcher=c - 48 | 0;
           if(9 < switcher >>> 0)
            return expected_character(str_ind + 1 | 0,cst_digit,c);
           var
            match$0=parse_positive(str_ind + 1 | 0,end_ind,0),
            n=match$0[2],
            next_ind=match$0[1];
           return [0,next_ind,- n | 0]}
        throw [0,Assert_failure,_aS_]}
      function parse_spaces(str_ind,end_ind)
       {var str_ind$0=str_ind;
        for(;;)
         {if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
          if(32 === caml_string_get(str,str_ind$0))
           {var str_ind$1=str_ind$0 + 1 | 0,str_ind$0=str_ind$1;continue}
          return str_ind$0}}
      function incompatible_flag(pct_ind,str_ind,symb,option)
       {var subfmt=sub$0(str,pct_ind,str_ind - pct_ind | 0);
        return caml_call5
                (failwith_message(_aX_),str,pct_ind,option,symb,subfmt)}
      function compute_int_conv(pct_ind,str_ind,plus,hash,space,symb)
       {var plus$0=plus,hash$0=hash,space$0=space;
        for(;;)
         {var switch$0=0;
          if(plus$0)
           {if(hash$0)
             switch$0 = 1;
            else
             if(! space$0){if(100 === symb)return 1;if(105 === symb)return 4}}
          else
           if(hash$0)
            if(space$0)
             switch$0 = 1;
            else
             {var switcher$0=symb - 88 | 0;
              if(32 < switcher$0 >>> 0)
               switch$0 = 1;
              else
               switch(switcher$0)
                {case 0:return 9;
                 case 12:return 13;
                 case 17:return 14;
                 case 23:return 11;
                 case 29:return 15;
                 case 32:return 7;
                 default:switch$0 = 1}}
           else
            if(space$0)
             {if(100 === symb)return 2;if(105 === symb)return 5}
            else
             {var switcher$1=symb - 88 | 0;
              if(! (32 < switcher$1 >>> 0))
               switch(switcher$1)
                {case 0:return 8;
                 case 12:return 0;
                 case 17:return 3;
                 case 23:return 10;
                 case 29:return 12;
                 case 32:return 6
                 }}
          if(switch$0)
           {var switcher=symb - 88 | 0;
            if(! (32 < switcher >>> 0))
             switch(switcher)
              {case 0:if(legacy_behavior$0)return 9;break;
               case 23:if(legacy_behavior$0)return 11;break;
               case 32:if(legacy_behavior$0)return 7;break;
               case 12:
               case 17:
               case 29:
                if(legacy_behavior$0){var hash$0=0;continue}
                return incompatible_flag(pct_ind,str_ind,symb,cst$49)
               }}
          if(plus$0)
           {if(space$0)
             {if(legacy_behavior$0){var space$0=0;continue}
              return incompatible_flag(pct_ind,str_ind,32,cst$46)}
            if(legacy_behavior$0){var plus$0=0;continue}
            return incompatible_flag(pct_ind,str_ind,symb,cst$47)}
          if(space$0)
           {if(legacy_behavior$0){var space$0=0;continue}
            return incompatible_flag(pct_ind,str_ind,symb,cst$48)}
          throw [0,Assert_failure,_aV_]}}
      function search_subformat_end(str_ind,end_ind,c)
       {var str_ind$0=str_ind;
        for(;;)
         {if(str_ind$0 === end_ind)
           caml_call3(failwith_message(_aT_),str,c,end_ind);
          var match=caml_string_get(str,str_ind$0);
          if(37 === match)
           {if((str_ind$0 + 1 | 0) === end_ind)
             unexpected_end_of_format(end_ind);
            if(caml_string_get(str,str_ind$0 + 1 | 0) === c)return str_ind$0;
            var match$0=caml_string_get(str,str_ind$0 + 1 | 0);
            if(95 <= match$0)
             {if(123 <= match$0)
               {if(! (126 <= match$0))
                 {var switcher=match$0 - 123 | 0;
                  switch(switcher)
                   {case 0:
                     var
                      sub_end=search_subformat_end(str_ind$0 + 2 | 0,end_ind,125),
                      str_ind$2=sub_end + 2 | 0,
                      str_ind$0=str_ind$2;
                     continue;
                    case 1:break;
                    default:
                     return expected_character
                             (str_ind$0 + 1 | 0,cst_character,125)}}}
              else
               if(! (96 <= match$0))
                {if((str_ind$0 + 2 | 0) === end_ind)
                  unexpected_end_of_format(end_ind);
                 var match$1=caml_string_get(str,str_ind$0 + 2 | 0);
                 if(40 === match$1)
                  {var
                    sub_end$0=search_subformat_end(str_ind$0 + 3 | 0,end_ind,41),
                    str_ind$3=sub_end$0 + 2 | 0,
                    str_ind$0=str_ind$3;
                   continue}
                 if(123 === match$1)
                  {var
                    sub_end$1=
                     search_subformat_end(str_ind$0 + 3 | 0,end_ind,125),
                    str_ind$4=sub_end$1 + 2 | 0,
                    str_ind$0=str_ind$4;
                   continue}
                 var str_ind$5=str_ind$0 + 3 | 0,str_ind$0=str_ind$5;
                 continue}}
            else
             {if(40 === match$0)
               {var
                 sub_end$2=search_subformat_end(str_ind$0 + 2 | 0,end_ind,41),
                 str_ind$6=sub_end$2 + 2 | 0,
                 str_ind$0=str_ind$6;
                continue}
              if(41 === match$0)
               return expected_character(str_ind$0 + 1 | 0,cst_character$0,41)}
            var str_ind$1=str_ind$0 + 2 | 0,str_ind$0=str_ind$1;
            continue}
          var str_ind$7=str_ind$0 + 1 | 0,str_ind$0=str_ind$7;
          continue}}
      function parse_magic_size(str_ind,end_ind)
       {try
         {var
           str_ind_1=parse_spaces(str_ind,end_ind),
           match$2=caml_string_get(str,str_ind_1),
           switch$0=0;
          if(48 <= match$2)
           {if(! (58 <= match$2))switch$0 = 1}
          else
           if(45 === match$2)switch$0 = 1;
          if(switch$0)
           {var
             match$3=parse_integer(str_ind_1,end_ind),
             size=match$3[2],
             str_ind_2=match$3[1],
             str_ind_3=parse_spaces(str_ind_2,end_ind);
            if(62 !== caml_string_get(str,str_ind_3))throw Not_found;
            var
             s=sub$0(str,str_ind - 2 | 0,(str_ind_3 - str_ind | 0) + 3 | 0),
             _qV_=[0,[0,str_ind_3 + 1 | 0,[1,s,size]]]}
          else
           var _qV_=0;
          var _qU_=_qV_}
        catch(_qW_)
         {_qW_ = caml_wrap_exception(_qW_);
          if(_qW_ !== Not_found && _qW_[1] !== Failure)throw _qW_;
          var _qU_=0}
        if(_qU_)
         {var
           match=_qU_[1],
           formatting_lit=match[2],
           next_ind=match[1],
           match$0=parse(next_ind,end_ind),
           fmt_rest=match$0[1];
          return [0,[17,formatting_lit,fmt_rest]]}
        var match$1=parse(str_ind,end_ind),fmt_rest$0=match$1[1];
        return [0,[17,_aP_,fmt_rest$0]]}
      function parse_good_break(str_ind,end_ind)
       {try
         {var
           _qN_=str_ind === end_ind?1:0,
           _qO_=_qN_ || (60 !== caml_string_get(str,str_ind)?1:0);
          if(_qO_)throw Not_found;
          var
           str_ind_1=parse_spaces(str_ind + 1 | 0,end_ind),
           match$0=caml_string_get(str,str_ind_1),
           switch$0=0;
          if(48 <= match$0)
           {if(! (58 <= match$0))switch$0 = 1}
          else
           if(45 === match$0)switch$0 = 1;
          if(! switch$0)throw Not_found;
          var
           match$1=parse_integer(str_ind_1,end_ind),
           width=match$1[2],
           str_ind_2=match$1[1],
           str_ind_3=parse_spaces(str_ind_2,end_ind),
           match$2=caml_string_get(str,str_ind_3),
           switcher=match$2 - 45 | 0,
           switch$1=0;
          if(12 < switcher >>> 0)
           if(17 === switcher)
            var
             s=sub$0(str,str_ind - 2 | 0,(str_ind_3 - str_ind | 0) + 3 | 0),
             _qP_=[0,s,width,0],
             _qQ_=str_ind_3 + 1 | 0,
             formatting_lit$0=_qP_,
             next_ind=_qQ_;
           else
            switch$1 = 1;
          else
           {var switcher$0=switcher - 1 | 0;
            if(1 < switcher$0 >>> 0)
             {var
               match$3=parse_integer(str_ind_3,end_ind),
               offset=match$3[2],
               str_ind_4=match$3[1],
               str_ind_5=parse_spaces(str_ind_4,end_ind);
              if(62 !== caml_string_get(str,str_ind_5))throw Not_found;
              var
               s$0=
                sub$0(str,str_ind - 2 | 0,(str_ind_5 - str_ind | 0) + 3 | 0),
               _qR_=[0,s$0,width,offset],
               _qS_=str_ind_5 + 1 | 0,
               formatting_lit$0=_qR_,
               next_ind=_qS_}
            else
             switch$1 = 1}
          if(switch$1)throw Not_found}
        catch(_qT_)
         {_qT_ = caml_wrap_exception(_qT_);
          if(_qT_ !== Not_found && _qT_[1] !== Failure)throw _qT_;
          var formatting_lit$0=formatting_lit,next_ind=str_ind}
        var match=parse(next_ind,end_ind),fmt_rest=match[1];
        return [0,[17,formatting_lit$0,fmt_rest]]}
      function parse_tag(is_open_tag,str_ind,end_ind)
       {try
         {if(str_ind === end_ind)throw Not_found;
          var match$0=caml_string_get(str,str_ind);
          if(60 === match$0)
           {var ind=index_from$0(str,str_ind + 1 | 0,62);
            if(end_ind <= ind)throw Not_found;
            var
             sub_str=sub$0(str,str_ind,(ind - str_ind | 0) + 1 | 0),
             match$1=parse(ind + 1 | 0,end_ind),
             fmt_rest$0=match$1[1],
             match$2=parse(str_ind,ind + 1 | 0),
             sub_fmt=match$2[1],
             sub_format$0=[0,sub_fmt,sub_str],
             formatting$0=is_open_tag?[0,sub_format$0]:[1,sub_format$0],
             _qL_=[0,[18,formatting$0,fmt_rest$0]];
            return _qL_}
          throw Not_found}
        catch(_qM_)
         {_qM_ = caml_wrap_exception(_qM_);
          if(_qM_ === Not_found)
           {var
             match=parse(str_ind,end_ind),
             fmt_rest=match[1],
             formatting=is_open_tag?[0,sub_format]:[1,sub_format];
            return [0,[18,formatting,fmt_rest]]}
          throw _qM_}}
      function parse_flags(pct_ind,str_ind,end_ind,ign)
       {var zero=[0,0],minus=[0,0],plus=[0,0],space=[0,0],hash=[0,0];
        function set_flag(str_ind,flag)
         {var _qI_=flag[1],_qJ_=_qI_?1 - legacy_behavior$0:_qI_;
          if(_qJ_)
           {var _qK_=caml_string_get(str,str_ind);
            caml_call3(failwith_message(_aB_),str,str_ind,_qK_)}
          flag[1] = 1;
          return 0}
        var str_ind$0=str_ind;
        for(;;)
         {if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
          var match=caml_string_get(str,str_ind$0),switcher=match - 32 | 0;
          if(! (16 < switcher >>> 0))
           switch(switcher)
            {case 0:
              set_flag(str_ind$0,space);
              var str_ind$1=str_ind$0 + 1 | 0,str_ind$0=str_ind$1;
              continue;
             case 3:
              set_flag(str_ind$0,hash);
              var str_ind$2=str_ind$0 + 1 | 0,str_ind$0=str_ind$2;
              continue;
             case 11:
              set_flag(str_ind$0,plus);
              var str_ind$3=str_ind$0 + 1 | 0,str_ind$0=str_ind$3;
              continue;
             case 13:
              set_flag(str_ind$0,minus);
              var str_ind$4=str_ind$0 + 1 | 0,str_ind$0=str_ind$4;
              continue;
             case 16:
              set_flag(str_ind$0,zero);
              var str_ind$5=str_ind$0 + 1 | 0,str_ind$0=str_ind$5;
              continue
             }
          var
           _qD_=space[1],
           _qE_=hash[1],
           _qF_=plus[1],
           _qG_=minus[1],
           _qH_=zero[1];
          if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
          var
           padty=
            _qH_
             ?_qG_
               ?legacy_behavior$0
                 ?0
                 :incompatible_flag(pct_ind,str_ind$0,45,cst_0)
               :2
             :_qG_?0:1,
           match$0=caml_string_get(str,str_ind$0);
          if(48 <= match$0)
           {if(! (58 <= match$0))
             {var
               match$1=parse_positive(str_ind$0,end_ind,0),
               width=match$1[2],
               new_ind=match$1[1];
              return parse_after_padding
                      (pct_ind,
                       new_ind,
                       end_ind,
                       _qG_,
                       _qF_,
                       _qE_,
                       _qD_,
                       ign,
                       [0,padty,width])}}
          else
           if(42 === match$0)
            return parse_after_padding
                    (pct_ind,
                     str_ind$0 + 1 | 0,
                     end_ind,
                     _qG_,
                     _qF_,
                     _qE_,
                     _qD_,
                     ign,
                     [1,padty]);
          switch(padty)
           {case 0:
             if(1 - legacy_behavior$0)
              invalid_format_without(str_ind$0 - 1 | 0,45,cst_padding);
             return parse_after_padding
                     (pct_ind,str_ind$0,end_ind,_qG_,_qF_,_qE_,_qD_,ign,0);
            case 1:
             return parse_after_padding
                     (pct_ind,str_ind$0,end_ind,_qG_,_qF_,_qE_,_qD_,ign,0);
            default:
             return parse_after_padding
                     (pct_ind,str_ind$0,end_ind,_qG_,_qF_,_qE_,_qD_,ign,_aC_)}}}
      function parse_after_padding
       (pct_ind,str_ind,end_ind,minus,plus,hash,space,ign,pad)
       {if(str_ind === end_ind)unexpected_end_of_format(end_ind);
        var symb=caml_string_get(str,str_ind);
        if(46 === symb)
         {var str_ind$0=str_ind + 1 | 0;
          if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
          var
           parse_literal=
            function(minus,str_ind)
             {var
               match=parse_positive(str_ind,end_ind,0),
               prec=match[2],
               new_ind=match[1];
              return parse_after_precision
                      (pct_ind,
                       new_ind,
                       end_ind,
                       minus,
                       plus,
                       hash,
                       space,
                       ign,
                       pad,
                       [0,prec])},
           symb$0=caml_string_get(str,str_ind$0);
          if(48 <= symb$0)
           {if(! (58 <= symb$0))return parse_literal(minus,str_ind$0)}
          else
           if(42 <= symb$0)
            {var switcher=symb$0 - 42 | 0;
             switch(switcher)
              {case 0:
                return parse_after_precision
                        (pct_ind,
                         str_ind$0 + 1 | 0,
                         end_ind,
                         minus,
                         plus,
                         hash,
                         space,
                         ign,
                         pad,
                         1);
               case 1:
               case 3:
                if(legacy_behavior$0)
                 {var
                   _qC_=str_ind$0 + 1 | 0,
                   minus$0=minus || (45 === symb$0?1:0);
                  return parse_literal(minus$0,_qC_)}
                break
               }}
          return legacy_behavior$0
                  ?parse_after_precision
                    (pct_ind,
                     str_ind$0,
                     end_ind,
                     minus,
                     plus,
                     hash,
                     space,
                     ign,
                     pad,
                     _aD_)
                  :invalid_format_without(str_ind$0 - 1 | 0,46,cst_precision)}
        return parse_conversion
                (pct_ind,
                 str_ind + 1 | 0,
                 end_ind,
                 plus,
                 hash,
                 space,
                 ign,
                 pad,
                 0,
                 pad,
                 symb)}
      function parse_after_precision
       (pct_ind,str_ind,end_ind,minus,plus,hash,space,ign,pad,match)
       {if(str_ind === end_ind)unexpected_end_of_format(end_ind);
        function parse_conv(padprec)
         {return parse_conversion
                  (pct_ind,
                   str_ind + 1 | 0,
                   end_ind,
                   plus,
                   hash,
                   space,
                   ign,
                   pad,
                   match,
                   padprec,
                   caml_string_get(str,str_ind))}
        if(typeof pad === "number")
         {if(typeof match === "number" && ! match)return parse_conv(0);
          if(minus)
           {if(typeof match === "number")return parse_conv(_aE_);
            var n=match[1];
            return parse_conv([0,0,n])}
          if(typeof match === "number")return parse_conv(_aF_);
          var n$0=match[1];
          return parse_conv([0,1,n$0])}
        return parse_conv(pad)}
      function parse_conversion
       (pct_ind,str_ind,end_ind,plus,hash,space,ign,pad,prec,padprec,symb)
       {var
         plus_used=[0,0],
         hash_used=[0,0],
         space_used=[0,0],
         ign_used=[0,0],
         pad_used=[0,0],
         prec_used=[0,0];
        function get_plus(param){plus_used[1] = 1;return plus}
        function get_hash(param){hash_used[1] = 1;return hash}
        function get_space(param){space_used[1] = 1;return space}
        function get_ign(param){ign_used[1] = 1;return ign}
        function get_pad(param){pad_used[1] = 1;return pad}
        function get_prec(param){prec_used[1] = 1;return prec}
        function get_padprec(param){pad_used[1] = 1;return padprec}
        function get_int_pad(param)
         {var pad=get_pad(0),match=get_prec(0);
          if(typeof match === "number" && ! match)return pad;
          if(typeof pad === "number")
           return 0;
          else
           {if(0 === pad[0])
             {if(2 <= pad[1])
               {var n=pad[2];
                return legacy_behavior$0
                        ?[0,1,n]
                        :incompatible_flag(pct_ind,str_ind,48,cst_precision$0)}
              return pad}
            return 2 <= pad[1]
                    ?legacy_behavior$0
                      ?_aG_
                      :incompatible_flag(pct_ind,str_ind,48,cst_precision$1)
                    :pad}}
        function check_no_0(symb,pad)
         {if(typeof pad === "number")
           return pad;
          else
           {if(0 === pad[0])
             {if(2 <= pad[1])
               {var width=pad[2];
                return legacy_behavior$0
                        ?[0,1,width]
                        :incompatible_flag(pct_ind,str_ind,symb,cst_0$0)}
              return pad}
            return 2 <= pad[1]
                    ?legacy_behavior$0
                      ?_aH_
                      :incompatible_flag(pct_ind,str_ind,symb,cst_0$1)
                    :pad}}
        function opt_of_pad(c,pad)
         {if(typeof pad === "number")
           return 0;
          else
           {if(0 === pad[0])
             switch(pad[1])
              {case 0:
                var width=pad[2];
                return legacy_behavior$0
                        ?[0,width]
                        :incompatible_flag(pct_ind,str_ind,c,cst$38);
               case 1:var width$0=pad[2];return [0,width$0];
               default:
                var width$1=pad[2];
                return legacy_behavior$0
                        ?[0,width$1]
                        :incompatible_flag(pct_ind,str_ind,c,cst_0$2)}
            return incompatible_flag(pct_ind,str_ind,c,cst$39)}}
        function get_pad_opt(c){return opt_of_pad(c,get_pad(0))}
        function get_padprec_opt(c){return opt_of_pad(c,get_padprec(0))}
        var switch$0=0;
        if(124 <= symb)
         switch$0 = 1;
        else
         switch(symb)
          {case 33:
            var
             match$6=parse(str_ind,end_ind),
             fmt_rest$5=match$6[1],
             fmt_result=[0,[10,fmt_rest$5]];
            break;
           case 40:
            var
             sub_end=search_subformat_end(str_ind,end_ind,41),
             match$8=parse(sub_end + 2 | 0,end_ind),
             fmt_rest$7=match$8[1],
             match$9=parse(str_ind,sub_end),
             sub_fmt=match$9[1],
             sub_fmtty=fmtty_of_fmt(sub_fmt);
            if(get_ign(0))
             var
              ignored$2=[9,get_pad_opt(95),sub_fmtty],
              _p$_=[0,[23,ignored$2,fmt_rest$7]];
            else
             var _p$_=[0,[14,get_pad_opt(40),sub_fmtty,fmt_rest$7]];
            var fmt_result=_p$_;
            break;
           case 44:var fmt_result=parse(str_ind,end_ind);break;
           case 67:
            var
             match$12=parse(str_ind,end_ind),
             fmt_rest$10=match$12[1],
             _qb_=get_ign(0)?[0,[23,1,fmt_rest$10]]:[0,[1,fmt_rest$10]],
             fmt_result=_qb_;
            break;
           case 78:
            var
             match$16=parse(str_ind,end_ind),
             fmt_rest$14=match$16[1],
             counter$0=2;
            if(get_ign(0))
             var ignored$6=[11,counter$0],_qh_=[0,[23,ignored$6,fmt_rest$14]];
            else
             var _qh_=[0,[21,counter$0,fmt_rest$14]];
            var fmt_result=_qh_;
            break;
           case 83:
            var
             pad$6=check_no_0(symb,get_padprec(0)),
             match$17=parse(str_ind,end_ind),
             fmt_rest$15=match$17[1];
            if(get_ign(0))
             var
              ignored$7=[1,get_padprec_opt(95)],
              _qi_=[0,[23,ignored$7,fmt_rest$15]];
            else
             var
              match$18=make_padding_fmt_ebb(pad$6,fmt_rest$15),
              fmt_rest$16=match$18[2],
              pad$7=match$18[1],
              _qi_=[0,[3,pad$7,fmt_rest$16]];
            var fmt_result=_qi_;
            break;
           case 91:
            if(str_ind === end_ind)unexpected_end_of_format(end_ind);
            var
             char_set=create_char_set(0),
             add_char=function(c){return add_in_char_set(char_set,c)},
             add_range=
              function(c$0,c)
               {if(! (c < c$0))
                 {var i=c$0;
                  for(;;)
                   {add_in_char_set(char_set,char_of_int(i));
                    var _qB_=i + 1 | 0;
                    if(c !== i){var i=_qB_;continue}
                    break}}
                return 0},
             fail_single_percent=
              function(str_ind)
               {return caml_call2(failwith_message(_aQ_),str,str_ind)},
             parse_char_set_content=
              function(counter,str_ind,end_ind)
               {var str_ind$0=str_ind;
                for(;;)
                 {if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
                  var c=caml_string_get(str,str_ind$0);
                  if(45 === c)
                   {add_char(45);
                    var str_ind$1=str_ind$0 + 1 | 0,str_ind$0=str_ind$1;
                    continue}
                  if(93 === c)return str_ind$0 + 1 | 0;
                  var _qA_=str_ind$0 + 1 | 0;
                  if(counter < 50)
                   {var counter$0=counter + 1 | 0;
                    return parse_char_set_after_char$0(counter$0,_qA_,end_ind,c)}
                  return caml_trampoline_return
                          (parse_char_set_after_char$0,[0,_qA_,end_ind,c])}},
             parse_char_set_after_char$0=
              function(counter,str_ind,end_ind,c)
               {var str_ind$0=str_ind,c$0=c;
                for(;;)
                 {if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
                  var c$1=caml_string_get(str,str_ind$0),switch$0=0;
                  if(46 <= c$1)
                   {if(64 === c$1)
                     switch$0 = 1;
                    else
                     if(93 === c$1){add_char(c$0);return str_ind$0 + 1 | 0}}
                  else
                   if(37 === c$1)
                    switch$0 = 1;
                   else
                    if(45 <= c$1)
                     {var str_ind$2=str_ind$0 + 1 | 0;
                      if(str_ind$2 === end_ind)unexpected_end_of_format(end_ind);
                      var c$2=caml_string_get(str,str_ind$2);
                      if(37 === c$2)
                       {if((str_ind$2 + 1 | 0) === end_ind)
                         unexpected_end_of_format(end_ind);
                        var c$3=caml_string_get(str,str_ind$2 + 1 | 0);
                        if(37 !== c$3 && 64 !== c$3)
                         return fail_single_percent(str_ind$2);
                        add_range(c$0,c$3);
                        var _qy_=str_ind$2 + 2 | 0;
                        if(counter < 50)
                         {var counter$2=counter + 1 | 0;
                          return parse_char_set_content(counter$2,_qy_,end_ind)}
                        return caml_trampoline_return
                                (parse_char_set_content,[0,_qy_,end_ind])}
                      if(93 === c$2)
                       {add_char(c$0);add_char(45);return str_ind$2 + 1 | 0}
                      add_range(c$0,c$2);
                      var _qz_=str_ind$2 + 1 | 0;
                      if(counter < 50)
                       {var counter$1=counter + 1 | 0;
                        return parse_char_set_content(counter$1,_qz_,end_ind)}
                      return caml_trampoline_return
                              (parse_char_set_content,[0,_qz_,end_ind])}
                  if(switch$0 && 37 === c$0)
                   {add_char(c$1);
                    var _qx_=str_ind$0 + 1 | 0;
                    if(counter < 50)
                     {var counter$0=counter + 1 | 0;
                      return parse_char_set_content(counter$0,_qx_,end_ind)}
                    return caml_trampoline_return
                            (parse_char_set_content,[0,_qx_,end_ind])}
                  if(37 === c$0)fail_single_percent(str_ind$0);
                  add_char(c$0);
                  var str_ind$1=str_ind$0 + 1 | 0,str_ind$0=str_ind$1,c$0=c$1;
                  continue}},
             parse_char_set_after_char=
              function(str_ind,end_ind,c)
               {return caml_trampoline
                        (parse_char_set_after_char$0(0,str_ind,end_ind,c))};
            if(str_ind === end_ind)unexpected_end_of_format(end_ind);
            var match$31=caml_string_get(str,str_ind);
            if(94 === match$31)
             var str_ind$0=str_ind + 1 | 0,reverse=1,str_ind$1=str_ind$0;
            else
             var reverse=0,str_ind$1=str_ind;
            if(str_ind$1 === end_ind)unexpected_end_of_format(end_ind);
            var
             c=caml_string_get(str,str_ind$1),
             next_ind=parse_char_set_after_char(str_ind$1 + 1 | 0,end_ind,c),
             char_set$0=freeze_char_set(char_set),
             char_set$1=reverse?rev_char_set(char_set$0):char_set$0,
             match$21=parse(next_ind,end_ind),
             fmt_rest$19=match$21[1];
            if(get_ign(0))
             var
              ignored$9=[10,get_pad_opt(95),char_set$1],
              _qn_=[0,[23,ignored$9,fmt_rest$19]];
            else
             var _qn_=[0,[20,get_pad_opt(91),char_set$1,fmt_rest$19]];
            var fmt_result=_qn_;
            break;
           case 97:
            var
             match$22=parse(str_ind,end_ind),
             fmt_rest$20=match$22[1],
             fmt_result=[0,[15,fmt_rest$20]];
            break;
           case 99:
            var
             char_format=
              function(fmt_rest)
               {return get_ign(0)?[0,[23,0,fmt_rest]]:[0,[0,fmt_rest]]},
             match$23=parse(str_ind,end_ind),
             fmt_rest$21=match$23[1],
             match$24=get_pad_opt(99);
            if(match$24)
             {if(0 === match$24[1])
               var
                _qo_=get_ign(0)?[0,[23,3,fmt_rest$21]]:[0,[22,fmt_rest$21]],
                _qp_=_qo_;
              else
               var
                _qp_=
                 legacy_behavior$0
                  ?char_format(fmt_rest$21)
                  :invalid_format_message
                    (str_ind,cst_non_zero_widths_are_unsupp);
              var _qq_=_qp_}
            else
             var _qq_=char_format(fmt_rest$21);
            var fmt_result=_qq_;
            break;
           case 114:
            var
             match$25=parse(str_ind,end_ind),
             fmt_rest$22=match$25[1],
             _qr_=get_ign(0)?[0,[23,2,fmt_rest$22]]:[0,[19,fmt_rest$22]],
             fmt_result=_qr_;
            break;
           case 115:
            var
             pad$9=check_no_0(symb,get_padprec(0)),
             match$26=parse(str_ind,end_ind),
             fmt_rest$23=match$26[1];
            if(get_ign(0))
             var
              ignored$10=[0,get_padprec_opt(95)],
              _qs_=[0,[23,ignored$10,fmt_rest$23]];
            else
             var
              match$27=make_padding_fmt_ebb(pad$9,fmt_rest$23),
              fmt_rest$24=match$27[2],
              pad$10=match$27[1],
              _qs_=[0,[2,pad$10,fmt_rest$24]];
            var fmt_result=_qs_;
            break;
           case 116:
            var
             match$28=parse(str_ind,end_ind),
             fmt_rest$25=match$28[1],
             fmt_result=[0,[16,fmt_rest$25]];
            break;
           case 123:
            var
             sub_end$0=search_subformat_end(str_ind,end_ind,125),
             match$29=parse(str_ind,sub_end$0),
             sub_fmt$0=match$29[1],
             match$30=parse(sub_end$0 + 2 | 0,end_ind),
             fmt_rest$26=match$30[1],
             sub_fmtty$0=fmtty_of_fmt(sub_fmt$0);
            if(get_ign(0))
             var
              ignored$11=[8,get_pad_opt(95),sub_fmtty$0],
              _qt_=[0,[23,ignored$11,fmt_rest$26]];
            else
             var _qt_=[0,[13,get_pad_opt(123),sub_fmtty$0,fmt_rest$26]];
            var fmt_result=_qt_;
            break;
           case 66:
           case 98:
            var
             pad$3=check_no_0(symb,get_padprec(0)),
             match$10=parse(str_ind,end_ind),
             fmt_rest$8=match$10[1];
            if(get_ign(0))
             var
              ignored$3=[7,get_padprec_opt(95)],
              _qa_=[0,[23,ignored$3,fmt_rest$8]];
            else
             var
              match$11=make_padding_fmt_ebb(pad$3,fmt_rest$8),
              fmt_rest$9=match$11[2],
              pad$4=match$11[1],
              _qa_=[0,[9,pad$4,fmt_rest$9]];
            var fmt_result=_qa_;
            break;
           case 37:
           case 64:
            var
             match$7=parse(str_ind,end_ind),
             fmt_rest$6=match$7[1],
             fmt_result=[0,[12,symb,fmt_rest$6]];
            break;
           case 76:
           case 108:
           case 110:
            var switch$1=0;
            if(str_ind !== end_ind)
             {var
               symb$0=caml_string_get(str,str_ind),
               _qu_=symb$0 - 88 | 0,
               switch$2=0;
              if(! (32 < _qu_ >>> 0))
               switch(_qu_)
                {case 0:
                 case 12:
                 case 17:
                 case 23:
                 case 29:
                 case 32:var _qg_=1;switch$2 = 1;break
                 }
              if(! switch$2)var _qg_=0;
              if(_qg_){switch$0 = 1;switch$1 = 1}}
            if(! switch$1)
             {var
               match$15=parse(str_ind,end_ind),
               fmt_rest$13=match$15[1],
               switch$3=0;
              if(108 <= symb)
               {if(! (111 <= symb))
                 {var switcher$0=symb - 108 | 0;
                  switch(switcher$0)
                   {case 0:var counter=0;switch$3 = 1;break;
                    case 1:break;
                    default:var counter=1;switch$3 = 1}}}
              else
               if(76 === symb){var counter=2;switch$3 = 1}
              if(! switch$3)throw [0,Assert_failure,_aU_];
              if(get_ign(0))
               var ignored$5=[11,counter],_qf_=[0,[23,ignored$5,fmt_rest$13]];
              else
               var _qf_=[0,[21,counter,fmt_rest$13]];
              var fmt_result=_qf_}
            break;
           case 32:
           case 35:
           case 43:
           case 45:
           case 95:
            var
             fmt_result=
              caml_call3(failwith_message(_aL_),str,pct_ind,symb);
            break;
           case 88:
           case 100:
           case 105:
           case 111:
           case 117:
           case 120:
            var
             _qj_=get_space(0),
             _qk_=get_hash(0),
             iconv$2=
              compute_int_conv(pct_ind,str_ind,get_plus(0),_qk_,_qj_,symb),
             match$19=parse(str_ind,end_ind),
             fmt_rest$17=match$19[1];
            if(get_ign(0))
             var
              ignored$8=[2,iconv$2,get_pad_opt(95)],
              _ql_=[0,[23,ignored$8,fmt_rest$17]];
            else
             var
              _qm_=get_prec(0),
              match$20=make_padprec_fmt_ebb(get_int_pad(0),_qm_,fmt_rest$17),
              fmt_rest$18=match$20[3],
              prec$4=match$20[2],
              pad$8=match$20[1],
              _ql_=[0,[4,iconv$2,pad$8,prec$4,fmt_rest$18]];
            var fmt_result=_ql_;
            break;
           case 69:
           case 70:
           case 71:
           case 72:
           case 101:
           case 102:
           case 103:
           case 104:
            var
             space$1=get_space(0),
             hash$1=get_hash(0),
             plus$2=get_plus(0),
             flag=
              plus$2
               ?space$1
                 ?legacy_behavior$0
                   ?1
                   :incompatible_flag(pct_ind,str_ind,32,cst$50)
                 :1
               :space$1?2:0,
             switch$4=0;
            if(73 <= symb)
             {var switcher$1=symb - 101 | 0;
              if(3 < switcher$1 >>> 0)
               switch$4 = 1;
              else
               {switch(switcher$1)
                 {case 0:var _qv_=1;break;
                  case 1:var _qv_=0;break;
                  case 2:var _qv_=3;break;
                  default:var _qv_=6}
                var kind=_qv_}}
            else
             if(69 <= symb)
              {var switcher$2=symb - 69 | 0,switch$5=0;
               switch(switcher$2)
                {case 0:var _qw_=2;break;
                 case 1:switch$4 = 1;switch$5 = 1;break;
                 case 2:var _qw_=4;break;
                 default:var _qw_=7}
               if(! switch$5)var kind=_qw_}
             else
              switch$4 = 1;
            if(switch$4)
             {var switch$6=0;
              if(hash$1)
               if(70 === symb)var kind=8;else switch$6 = 1;
              else
               if(70 === symb)var kind=5;else switch$6 = 1;
              if(switch$6)throw [0,Assert_failure,_aW_]}
            var
             fconv=[0,flag,kind],
             match$13=parse(str_ind,end_ind),
             fmt_rest$11=match$13[1];
            if(get_ign(0))
             {var match=get_prec(0);
              if(typeof match === "number")
               var _qc_=match?incompatible_flag(pct_ind,str_ind,95,cst$40):0;
              else
               var ndec=match[1],_qc_=[0,ndec];
              var
               ignored$4=[6,get_pad_opt(95),_qc_],
               _qd_=[0,[23,ignored$4,fmt_rest$11]]}
            else
             var
              _qe_=get_prec(0),
              match$14=make_padprec_fmt_ebb(get_pad(0),_qe_,fmt_rest$11),
              fmt_rest$12=match$14[3],
              prec$3=match$14[2],
              pad$5=match$14[1],
              _qd_=[0,[8,fconv,pad$5,prec$3,fmt_rest$12]];
            var fmt_result=_qd_;
            break;
           default:switch$0 = 1}
        if(switch$0)
         {var switch$7=0;
          if(108 <= symb)
           if(111 <= symb)
            switch$7 = 1;
           else
            {var switcher=symb - 108 | 0,switch$8=0;
             switch(switcher)
              {case 0:
                var
                 _pV_=caml_string_get(str,str_ind),
                 _pW_=get_space(0),
                 _pX_=get_hash(0),
                 iconv=
                  compute_int_conv
                   (pct_ind,str_ind + 1 | 0,get_plus(0),_pX_,_pW_,_pV_),
                 match$0=parse(str_ind + 1 | 0,end_ind),
                 fmt_rest=match$0[1];
                if(get_ign(0))
                 var
                  ignored=[3,iconv,get_pad_opt(95)],
                  _pY_=[0,[23,ignored,fmt_rest]];
                else
                 var
                  _p0_=get_prec(0),
                  match$1=make_padprec_fmt_ebb(get_int_pad(0),_p0_,fmt_rest),
                  fmt_rest$0=match$1[3],
                  prec$0=match$1[2],
                  pad$0=match$1[1],
                  _pY_=[0,[5,iconv,pad$0,prec$0,fmt_rest$0]];
                var _pZ_=_pY_;
                break;
               case 1:switch$7 = 1;switch$8 = 1;break;
               default:
                var
                 _p1_=caml_string_get(str,str_ind),
                 _p2_=get_space(0),
                 _p3_=get_hash(0),
                 iconv$0=
                  compute_int_conv
                   (pct_ind,str_ind + 1 | 0,get_plus(0),_p3_,_p2_,_p1_),
                 match$2=parse(str_ind + 1 | 0,end_ind),
                 fmt_rest$1=match$2[1];
                if(get_ign(0))
                 var
                  ignored$0=[4,iconv$0,get_pad_opt(95)],
                  _p4_=[0,[23,ignored$0,fmt_rest$1]];
                else
                 var
                  _p5_=get_prec(0),
                  match$3=make_padprec_fmt_ebb(get_int_pad(0),_p5_,fmt_rest$1),
                  fmt_rest$2=match$3[3],
                  prec$1=match$3[2],
                  pad$1=match$3[1],
                  _p4_=[0,[6,iconv$0,pad$1,prec$1,fmt_rest$2]];
                var _pZ_=_p4_}
             if(! switch$8)var fmt_result=_pZ_}
          else
           if(76 === symb)
            {var
              _p6_=caml_string_get(str,str_ind),
              _p7_=get_space(0),
              _p8_=get_hash(0),
              iconv$1=
               compute_int_conv
                (pct_ind,str_ind + 1 | 0,get_plus(0),_p8_,_p7_,_p6_),
              match$4=parse(str_ind + 1 | 0,end_ind),
              fmt_rest$3=match$4[1];
             if(get_ign(0))
              var
               ignored$1=[5,iconv$1,get_pad_opt(95)],
               _p9_=[0,[23,ignored$1,fmt_rest$3]];
             else
              var
               _p__=get_prec(0),
               match$5=make_padprec_fmt_ebb(get_int_pad(0),_p__,fmt_rest$3),
               fmt_rest$4=match$5[3],
               prec$2=match$5[2],
               pad$2=match$5[1],
               _p9_=[0,[7,iconv$1,pad$2,prec$2,fmt_rest$4]];
             var fmt_result=_p9_}
           else
            switch$7 = 1;
          if(switch$7)
           var
            fmt_result=
             caml_call3(failwith_message(_aI_),str,str_ind - 1 | 0,symb)}
        if(1 - legacy_behavior$0)
         {var _pM_=1 - plus_used[1],plus$0=_pM_?plus:_pM_;
          if(plus$0)incompatible_flag(pct_ind,str_ind,symb,cst$41);
          var _pN_=1 - hash_used[1],hash$0=_pN_?hash:_pN_;
          if(hash$0)incompatible_flag(pct_ind,str_ind,symb,cst$42);
          var _pO_=1 - space_used[1],space$0=_pO_?space:_pO_;
          if(space$0)incompatible_flag(pct_ind,str_ind,symb,cst$43);
          var _pP_=1 - pad_used[1],_pQ_=_pP_?caml_notequal([0,pad],_aJ_):_pP_;
          if(_pQ_)incompatible_flag(pct_ind,str_ind,symb,cst_padding$0);
          var
           _pR_=1 - prec_used[1],
           _pS_=_pR_?caml_notequal([0,prec],_aK_):_pR_;
          if(_pS_)
           {var _pT_=ign?95:symb;
            incompatible_flag(pct_ind,str_ind,_pT_,cst_precision$2)}
          var plus$1=ign?plus:ign;
          if(plus$1)incompatible_flag(pct_ind,str_ind,95,cst$44)}
        var _pU_=1 - ign_used[1],ign$0=_pU_?ign:_pU_;
        if(ign$0)
         {var switch$9=0;
          if(38 <= symb)
           {if(44 !== symb && 64 !== symb)switch$9 = 1}
          else
           if(33 !== symb && ! (37 <= symb))switch$9 = 1;
          var switch$10=0;
          if(switch$9 || ! legacy_behavior$0)switch$10 = 1;
          if(switch$10)incompatible_flag(pct_ind,str_ind,symb,cst$45)}
        return fmt_result}
      function parse(lit_start,end_ind)
       {var str_ind=lit_start;
        for(;;)
         {if(str_ind === end_ind)return add_literal(lit_start,str_ind,0);
          var match=caml_string_get(str,str_ind);
          if(37 === match)
           {var str_ind$2=str_ind + 1 | 0;
            if(str_ind$2 === end_ind)unexpected_end_of_format(end_ind);
            var
             match$1=caml_string_get(str,str_ind$2),
             _pL_=
              95 === match$1
               ?parse_flags(str_ind,str_ind$2 + 1 | 0,end_ind,1)
               :parse_flags(str_ind,str_ind$2,end_ind,0),
             fmt_rest=_pL_[1];
            return add_literal(lit_start,str_ind,fmt_rest)}
          if(64 === match)
           {var str_ind$0=str_ind + 1 | 0;
            if(str_ind$0 === end_ind)
             var match$0=_aM_;
            else
             {var c=caml_string_get(str,str_ind$0),switch$0=0;
              if(65 <= c)
               if(94 <= c)
                {var switcher=c - 123 | 0;
                 if(2 < switcher >>> 0)
                  switch$0 = 1;
                 else
                  switch(switcher)
                   {case 0:
                     var match$0=parse_tag(1,str_ind$0 + 1 | 0,end_ind);break;
                    case 1:switch$0 = 1;break;
                    default:
                     var
                      match$3=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$2=match$3[1],
                      match$0=[0,[17,1,fmt_rest$2]]}}
               else
                if(91 <= c)
                 {var switcher$0=c - 91 | 0;
                  switch(switcher$0)
                   {case 0:
                     var match$0=parse_tag(0,str_ind$0 + 1 | 0,end_ind);break;
                    case 1:switch$0 = 1;break;
                    default:
                     var
                      match$4=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$3=match$4[1],
                      match$0=[0,[17,0,fmt_rest$3]]}}
                else
                 switch$0 = 1;
              else
               if(10 === c)
                var
                 match$5=parse(str_ind$0 + 1 | 0,end_ind),
                 fmt_rest$4=match$5[1],
                 match$0=[0,[17,3,fmt_rest$4]];
               else
                if(32 <= c)
                 {var switcher$1=c - 32 | 0;
                  switch(switcher$1)
                   {case 0:
                     var
                      match$6=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$5=match$6[1],
                      match$0=[0,[17,_aN_,fmt_rest$5]];
                     break;
                    case 5:
                     var switch$1=0;
                     if
                      ((str_ind$0 + 1 | 0)
                       <
                       end_ind
                       &&
                       37
                       ===
                       caml_string_get(str,str_ind$0 + 1 | 0))
                      {var
                        match$7=parse(str_ind$0 + 2 | 0,end_ind),
                        fmt_rest$6=match$7[1],
                        match$0=[0,[17,6,fmt_rest$6]];
                       switch$1 = 1}
                     if(! switch$1)
                      var
                       match$8=parse(str_ind$0,end_ind),
                       fmt_rest$7=match$8[1],
                       match$0=[0,[12,64,fmt_rest$7]];
                     break;
                    case 12:
                     var
                      match$9=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$8=match$9[1],
                      match$0=[0,[17,_aO_,fmt_rest$8]];
                     break;
                    case 14:
                     var
                      match$10=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$9=match$10[1],
                      match$0=[0,[17,4,fmt_rest$9]];
                     break;
                    case 27:
                     var match$0=parse_good_break(str_ind$0 + 1 | 0,end_ind);
                     break;
                    case 28:
                     var match$0=parse_magic_size(str_ind$0 + 1 | 0,end_ind);
                     break;
                    case 31:
                     var
                      match$11=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$10=match$11[1],
                      match$0=[0,[17,2,fmt_rest$10]];
                     break;
                    case 32:
                     var
                      match$12=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$11=match$12[1],
                      match$0=[0,[17,5,fmt_rest$11]];
                     break;
                    default:switch$0 = 1}}
                else
                 switch$0 = 1;
              if(switch$0)
               var
                match$2=parse(str_ind$0 + 1 | 0,end_ind),
                fmt_rest$1=match$2[1],
                match$0=[0,[17,[2,c],fmt_rest$1]]}
            var fmt_rest$0=match$0[1];
            return add_literal(lit_start,str_ind,fmt_rest$0)}
          var str_ind$1=str_ind + 1 | 0,str_ind=str_ind$1;
          continue}}
      return parse(0,caml_ml_string_length(str))}
    function format_of_string_fmtty(str,fmtty)
     {var match=fmt_ebb_of_string(0,str),fmt=match[1];
      try
       {var _pJ_=[0,type_format(fmt,fmtty),str];return _pJ_}
      catch(_pK_)
       {_pK_ = caml_wrap_exception(_pK_);
        if(_pK_ === Type_mismatch)
         {var _pI_=string_of_fmtty(fmtty);
          return caml_call2(failwith_message(_aY_),str,_pI_)}
        throw _pK_}}
    function format_of_string_format(str,param)
     {var
       str$0=param[2],
       fmt=param[1],
       match=fmt_ebb_of_string(0,str),
       fmt$0=match[1];
      try
       {var _pG_=[0,type_format(fmt$0,fmtty_of_fmt(fmt)),str];return _pG_}
      catch(_pH_)
       {_pH_ = caml_wrap_exception(_pH_);
        if(_pH_ === Type_mismatch)
         return caml_call2(failwith_message(_aZ_),str,str$0);
        throw _pH_}}
    var
     CamlinternalFormat=
      [0,
       is_in_char_set,
       rev_char_set,
       create_char_set,
       add_in_char_set,
       freeze_char_set,
       param_format_of_ignored_format,
       make_printf,
       make_iprintf,
       output_acc,
       bufput_acc,
       strput_acc,
       type_format,
       fmt_ebb_of_string,
       format_of_string_fmtty,
       format_of_string_format,
       char_of_iconv,
       string_of_formatting_lit,
       string_of_fmtty,
       string_of_fmt,
       open_box_of_string,
       symm,
       trans,
       recast];
    caml_register_global(790,CamlinternalFormat,"CamlinternalFormat");
    function kfprintf(k,o,param)
     {var fmt=param[1],_pF_=0;
      return make_printf
              (function(acc){output_acc(o,acc);return caml_call1(k,o)},
               _pF_,
               fmt)}
    function kbprintf(k,b,param)
     {var fmt=param[1],_pE_=0;
      return make_printf
              (function(acc){bufput_acc(b,acc);return caml_call1(k,b)},
               _pE_,
               fmt)}
    function ikfprintf(k,oc,param)
     {var fmt=param[1];return make_iprintf(k,oc,fmt)}
    function fprintf(oc,fmt){return kfprintf(function(_pD_){return 0},oc,fmt)}
    function bprintf(b,fmt){return kbprintf(function(_pC_){return 0},b,fmt)}
    function ifprintf(oc,fmt)
     {return ikfprintf(function(_pB_){return 0},oc,fmt)}
    function ibprintf(b,fmt){return ikfprintf(function(_pA_){return 0},b,fmt)}
    function printf(fmt){return fprintf(stdout,fmt)}
    function eprintf(fmt){return fprintf(stderr,fmt)}
    function ksprintf(k,param)
     {var fmt=param[1];
      function k$0(acc)
       {var buf=create$2(64);
        strput_acc(buf,acc);
        return caml_call1(k,contents(buf))}
      return make_printf(k$0,0,fmt)}
    function sprintf(fmt){return ksprintf(function(s){return s},fmt)}
    var
     Stdlib_printf=
      [0,
       fprintf,
       printf,
       eprintf,
       sprintf,
       bprintf,
       ifprintf,
       ibprintf,
       kfprintf,
       ikfprintf,
       ksprintf,
       kbprintf,
       ikfprintf,
       ksprintf];
    caml_register_global(791,Stdlib_printf,"Stdlib__printf");
    var
     Bad=[248,cst_Stdlib_Arg_Bad,caml_fresh_oo_id(0)],
     Help=[248,cst_Stdlib_Arg_Help,caml_fresh_oo_id(0)],
     Stop=[248,cst_Stdlib_Arg_Stop,caml_fresh_oo_id(0)];
    function assoc3(x,l)
     {var l$0=l;
      for(;;)
       {if(l$0)
         {var match=l$0[1],y2=match[2],y1=match[1];
          if(caml_equal(y1,x))return y2;
          var l$1=l$0[2],l$0=l$1;
          continue}
        throw Not_found}}
    function split$0(s)
     {var
       i=index$0(s,61),
       len=caml_ml_string_length(s),
       _pz_=sub$0(s,i + 1 | 0,len - (i + 1 | 0) | 0);
      return [0,sub$0(s,0,i),_pz_]}
    function make_symlist(prefix,sep,suffix,l)
     {if(l)
       {var t=l[2],h=l[1],_py_=symbol(prefix,h);
        return symbol
                (fold_left$0
                  (function(x,y){return symbol(x,symbol(sep,y))},_py_,t),
                 suffix)}
      return cst_none}
    function help_action(param){throw [0,Stop,_a2_]}
    function add_help(speclist)
     {try
       {assoc3(cst_help$2,speclist);var _pv_=0,_pt_=_pv_}
      catch(_px_)
       {_px_ = caml_wrap_exception(_px_);
        if(_px_ !== Not_found)throw _px_;
        var
         _pt_=
          [0,[0,cst_help,[0,help_action],cst_Display_this_list_of_optio],0]}
      try
       {assoc3(cst_help$1,speclist);var _pu_=0,add2=_pu_}
      catch(_pw_)
       {_pw_ = caml_wrap_exception(_pw_);
        if(_pw_ !== Not_found)throw _pw_;
        var
         add2=
          [0,
           [0,cst_help$0,[0,help_action],cst_Display_this_list_of_optio$0],
           0]}
      return append(speclist,append(_pt_,add2))}
    function usage_b(buf,speclist,errmsg)
     {caml_call1(bprintf(buf,_a3_),errmsg);
      var _pq_=add_help(speclist);
      return iter$2
              (function(param)
                {var
                  doc=param[3],
                  spec=param[2],
                  key=param[1],
                  _pr_=0 < caml_ml_string_length(doc)?1:0;
                 if(_pr_)
                  {if(11 === spec[0])
                    {var l=spec[1],_ps_=make_symlist(cst$53,cst$52,cst$51,l);
                     return caml_call3(bprintf(buf,_a1_),key,_ps_,doc)}
                   return caml_call2(bprintf(buf,_a0_),key,doc)}
                 return _pr_},
               _pq_)}
    function usage_string(speclist,errmsg)
     {var b=create$2(200);usage_b(b,speclist,errmsg);return contents(b)}
    function usage(speclist,errmsg)
     {var _pp_=usage_string(speclist,errmsg);
      return caml_call1(eprintf(_a4_),_pp_)}
    var current=[0,0];
    function bool_of_string_opt$0(x)
     {try
       {var _pn_=[0,bool_of_string(x)];return _pn_}
      catch(_po_)
       {_po_ = caml_wrap_exception(_po_);
        if(_po_[1] === Invalid_argument)return 0;
        throw _po_}}
    function int_of_string_opt$0(x)
     {try
       {var _pl_=[0,caml_int_of_string(x)];return _pl_}
      catch(_pm_)
       {_pm_ = caml_wrap_exception(_pm_);
        if(_pm_[1] === Failure)return 0;
        throw _pm_}}
    function float_of_string_opt(x)
     {try
       {var _pj_=[0,caml_float_of_string(x)];return _pj_}
      catch(_pk_)
       {_pk_ = caml_wrap_exception(_pk_);
        if(_pk_[1] === Failure)return 0;
        throw _pk_}}
    function parse_and_expand_argv_dynamic_
     (allow_expand,current,argv,speclist,anonfun,errmsg)
     {var initpos=current[1];
      function convert_error(error)
       {var
         b=create$2(200),
         progname=
          initpos < argv[1].length - 1
           ?caml_check_bound(argv[1],initpos)[1 + initpos]
           :cst$54;
        switch(error[0])
         {case 0:
           var _pi_=error[1];
           if
            (caml_string_notequal(_pi_,cst_help$3)
             &&
             caml_string_notequal(_pi_,cst_help$4))
            caml_call2(bprintf(b,_a5_),progname,_pi_);
           break;
          case 1:
           var expected=error[3],arg=error[2],opt=error[1];
           caml_call4(bprintf(b,_a8_),progname,arg,opt,expected);
           break;
          case 2:var s=error[1];caml_call2(bprintf(b,_a9_),progname,s);break;
          default:var s$0=error[1];caml_call2(bprintf(b,_a__),progname,s$0)}
        usage_b(b,speclist[1],errmsg);
        if(! caml_equal(error,_a6_) && ! caml_equal(error,_a7_))
         return [0,Bad,contents(b)];
        return [0,Help,contents(b)]}
      current[1]++;
      for(;;)
       {if(current[1] < argv[1].length - 1)
         {try
           {var
             _o9_=current[1],
             s=caml_check_bound(argv[1],_o9_)[1 + _o9_],
             switch$0=0;
            if(1 <= caml_ml_string_length(s) && 45 === caml_string_get(s,0))
             {try
               {var
                 follow$1=0,
                 _o$_=assoc3(s,speclist[1]),
                 follow$0=follow$1,
                 action=_o$_}
              catch(_pg_)
               {_pg_ = caml_wrap_exception(_pg_);
                if(_pg_ !== Not_found)throw _pg_;
                try
                 {var
                   match=split$0(s),
                   arg=match[2],
                   keyword=match[1],
                   follow=[0,arg],
                   _o__=assoc3(keyword,speclist[1])}
                catch(_ph_)
                 {_ph_ = caml_wrap_exception(_ph_);
                  if(_ph_ === Not_found)throw [0,Stop,[0,s]];
                  throw _ph_;
                  var _pa_=_ph_}
                var follow$0=follow,action=_o__,_pb_=_pg_}
              var
               no_arg$0=
                function(s,follow)
                 {function no_arg(param)
                   {if(follow)
                     {var arg=follow[1];throw [0,Stop,[1,s,arg,cst_no_argument]]}
                    return 0}
                  return no_arg},
               no_arg=no_arg$0(s,follow$0),
               get_arg$0=
                function(s,follow)
                 {function get_arg(param)
                   {if(follow){var arg=follow[1];return arg}
                    if((current[1] + 1 | 0) < argv[1].length - 1)
                     {var _pf_=current[1] + 1 | 0;
                      return caml_check_bound(argv[1],_pf_)[1 + _pf_]}
                    throw [0,Stop,[2,s]]}
                  return get_arg},
               get_arg=get_arg$0(s,follow$0),
               consume_arg$0=
                function(follow)
                 {function consume_arg(param)
                   {return follow?0:(current[1]++,0)}
                  return consume_arg},
               consume_arg=consume_arg$0(follow$0),
               treat_action$0=
                function(s,no_arg,get_arg,consume_arg)
                 {function treat_action(param)
                   {switch(param[0])
                     {case 0:var f=param[1];no_arg(0);return caml_call1(f,0);
                      case 1:
                       var
                        f$0=param[1],
                        arg=get_arg(0),
                        match=bool_of_string_opt$0(arg);
                       if(match)
                        {var s$0=match[1];caml_call1(f$0,s$0);return consume_arg(0)}
                       throw [0,Stop,[1,s,arg,cst_a_boolean]];
                      case 2:var r=param[1];no_arg(0);r[1] = 1;return 0;
                      case 3:var r$0=param[1];no_arg(0);r$0[1] = 0;return 0;
                      case 4:
                       var f$1=param[1],arg$0=get_arg(0);
                       caml_call1(f$1,arg$0);
                       return consume_arg(0);
                      case 5:
                       var r$1=param[1];r$1[1] = get_arg(0);return consume_arg(0);
                      case 6:
                       var
                        f$2=param[1],
                        arg$1=get_arg(0),
                        match$0=int_of_string_opt$0(arg$1);
                       if(match$0)
                        {var x=match$0[1];caml_call1(f$2,x);return consume_arg(0)}
                       throw [0,Stop,[1,s,arg$1,cst_an_integer]];
                      case 7:
                       var
                        r$2=param[1],
                        arg$2=get_arg(0),
                        match$1=int_of_string_opt$0(arg$2);
                       if(match$1)
                        {var x$0=match$1[1];r$2[1] = x$0;return consume_arg(0)}
                       throw [0,Stop,[1,s,arg$2,cst_an_integer$0]];
                      case 8:
                       var
                        f$3=param[1],
                        arg$3=get_arg(0),
                        match$2=float_of_string_opt(arg$3);
                       if(match$2)
                        {var x$1=match$2[1];
                         caml_call1(f$3,x$1);
                         return consume_arg(0)}
                       throw [0,Stop,[1,s,arg$3,cst_a_float]];
                      case 9:
                       var
                        r$3=param[1],
                        arg$4=get_arg(0),
                        match$3=float_of_string_opt(arg$4);
                       if(match$3)
                        {var x$2=match$3[1];r$3[1] = x$2;return consume_arg(0)}
                       throw [0,Stop,[1,s,arg$4,cst_a_float$0]];
                      case 10:
                       var specs=param[1];
                       no_arg(0);
                       return iter$2(treat_action,specs);
                      case 11:
                       var f$4=param[2],symb=param[1],arg$5=get_arg(0);
                       if(mem(arg$5,symb))
                        {caml_call1(f$4,arg$5);return consume_arg(0)}
                       throw [0,
                              Stop,
                              [1,
                               s,
                               arg$5,
                               symbol(cst_one_of,make_symlist(cst$57,cst$56,cst$55,symb))]];
                      case 12:
                       var f$5=param[1];
                       no_arg(0);
                       for(;;)
                        {if(current[1] < (argv[1].length - 1 - 1 | 0))
                          {var _pc_=current[1] + 1 | 0;
                           caml_call1(f$5,caml_check_bound(argv[1],_pc_)[1 + _pc_]);
                           consume_arg(0);
                           continue}
                         return 0}
                      case 13:
                       var f$6=param[1];
                       no_arg(0);
                       var acc=[0,0];
                       for(;;)
                        {if(current[1] < (argv[1].length - 1 - 1 | 0))
                          {var _pe_=current[1] + 1 | 0,_pd_=acc[1];
                           acc[1] = [0,caml_check_bound(argv[1],_pe_)[1 + _pe_],_pd_];
                           consume_arg(0);
                           continue}
                         return caml_call1(f$6,rev(acc[1]))}
                      default:
                       var f$7=param[1];
                       if(1 - allow_expand)
                        throw [0,Invalid_argument,cst_Arg_Expand_is_is_only_allo];
                       var arg$6=get_arg(0),newarg=caml_call1(f$7,arg$6);
                       consume_arg(0);
                       var
                        before=sub$1(argv[1],0,current[1] + 1 | 0),
                        after=
                         sub$1
                          (argv[1],
                           current[1] + 1 | 0,
                           (argv[1].length - 1 - current[1] | 0) - 1 | 0);
                       argv[1]
                       =
                       caml_array_concat([0,before,[0,newarg,[0,after,0]]]);
                       return 0}}
                  return treat_action},
               treat_action=treat_action$0(s,no_arg,get_arg,consume_arg);
              treat_action(action);
              switch$0 = 1}
            if(! switch$0)caml_call1(anonfun,s)}
          catch(exn$0)
           {exn$0 = caml_wrap_exception(exn$0);
            if(exn$0[1] === Bad){var m=exn$0[2];throw convert_error([3,m])}
            if(exn$0[1] === Stop){var e=exn$0[2];throw convert_error(e)}
            throw exn$0;
            var exn=exn$0}
          current[1]++;
          continue}
        return 0}}
    function parse_and_expand_argv_dynamic
     (current,argv,speclist,anonfun,errmsg)
     {return parse_and_expand_argv_dynamic_
              (1,current,argv,speclist,anonfun,errmsg)}
    function parse_argv_dynamic(opt,argv,speclist,anonfun,errmsg)
     {if(opt)var sth=opt[1],current$0=sth;else var current$0=current;
      return parse_and_expand_argv_dynamic_
              (0,current$0,[0,argv],speclist,anonfun,errmsg)}
    function parse_argv(opt,argv,speclist,anonfun,errmsg)
     {if(opt)var sth=opt[1],current$0=sth;else var current$0=current;
      return parse_argv_dynamic
              ([0,current$0],argv,[0,speclist],anonfun,errmsg)}
    function parse(l,f,msg)
     {try
       {var _o8_=parse_argv(0,caml_sys_argv(0),l,f,msg);return _o8_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] === Bad)
         {var msg$0=exn[2];caml_call1(eprintf(_a$_),msg$0);return exit(2)}
        if(exn[1] === Help)
         {var msg$1=exn[2];caml_call1(printf(_ba_),msg$1);return exit(0)}
        throw exn}}
    function parse_dynamic(l,f,msg)
     {try
       {var _o7_=parse_argv_dynamic(0,caml_sys_argv(0),l,f,msg);return _o7_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] === Bad)
         {var msg$0=exn[2];caml_call1(eprintf(_bb_),msg$0);return exit(2)}
        if(exn[1] === Help)
         {var msg$1=exn[2];caml_call1(printf(_bc_),msg$1);return exit(0)}
        throw exn}}
    function parse_expand(l,f,msg)
     {try
       {var
         argv=[0,caml_sys_argv(0)],
         spec=[0,l],
         current$0=[0,current[1]],
         _o6_=parse_and_expand_argv_dynamic(current$0,argv,spec,f,msg);
        return _o6_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] === Bad)
         {var msg$0=exn[2];caml_call1(eprintf(_bd_),msg$0);return exit(2)}
        if(exn[1] === Help)
         {var msg$1=exn[2];caml_call1(printf(_be_),msg$1);return exit(0)}
        throw exn}}
    function second_word(s)
     {var len=caml_ml_string_length(s);
      function loop(n)
       {var n$0=n;
        for(;;)
         {if(len <= n$0)return len;
          if(32 === caml_string_get(s,n$0))
           {var n$1=n$0 + 1 | 0,n$0=n$1;continue}
          return n$0}}
      try
       {var n$0=index$0(s,9)}
      catch(_o4_)
       {_o4_ = caml_wrap_exception(_o4_);
        if(_o4_ === Not_found)
         {try
           {var n=index$0(s,32)}
          catch(_o5_)
           {_o5_ = caml_wrap_exception(_o5_);
            if(_o5_ === Not_found)return len;
            throw _o5_}
          return loop(n + 1 | 0)}
        throw _o4_}
      return loop(n$0 + 1 | 0)}
    function max_arg_len(cur,param)
     {var doc=param[3],spec=param[2],kwd=param[1];
      return 11 === spec[0]
              ?max(cur,caml_ml_string_length(kwd))
              :max(cur,caml_ml_string_length(kwd) + second_word(doc) | 0)}
    function replace_leading_tab(s)
     {var seen=[0,0];
      return map$5
              (function(c)
                {if(9 === c && ! seen[1]){seen[1] = 1;return 32}return c},
               s)}
    function align(opt,speclist)
     {if(opt)var sth=opt[1],limit=sth;else var limit=max_int;
      var
       completed=add_help(speclist),
       len=fold_left$0(max_arg_len,0,completed),
       len$0=min(len,limit);
      return map$3
              (function(ksd)
                {var _o2_=ksd[1],_o3_=ksd[2];
                 if(caml_string_notequal(ksd[3],cst$58))
                  {if(11 === _o3_[0])
                    {var
                      msg$0=ksd[3],
                      cutcol$0=second_word(msg$0),
                      spaces$0=make$1(max(0,len$0 - cutcol$0 | 0) + 3 | 0,32);
                     return [0,
                             _o2_,
                             _o3_,
                             symbol(cst$59,symbol(spaces$0,replace_leading_tab(msg$0)))]}
                   var
                    msg=ksd[3],
                    spec=ksd[2],
                    cutcol=second_word(msg),
                    kwd_len=caml_ml_string_length(_o2_),
                    diff=(len$0 - kwd_len | 0) - cutcol | 0;
                   if(0 < diff)
                    {var
                      spaces=make$1(diff,32),
                      prefix=sub$0(replace_leading_tab(msg),0,cutcol),
                      suffix=
                       sub$0(msg,cutcol,caml_ml_string_length(msg) - cutcol | 0);
                     return [0,_o2_,spec,symbol(prefix,symbol(spaces,suffix))]}
                   return [0,_o2_,spec,replace_leading_tab(msg)]}
                 return ksd},
               completed)}
    function read_aux(trim,sep,file)
     {var ic=open_in_bin(file),buf=create$2(200),words=[0,0];
      function stash(param)
       {var s=contents(buf);
        if(trim)
         {var len=caml_ml_string_length(s),switch$0=0;
          if(0 < len && 13 === caml_string_get(s,len - 1 | 0))
           {var _o1_=sub$0(s,0,len - 1 | 0);switch$0 = 1}
          if(! switch$0)var _o1_=s;
          var word=_o1_}
        else
         var word=s;
        words[1] = [0,word,words[1]];
        return clear$1(buf)}
      try
       {for(;;)
         {var c=caml_ml_input_char(ic);
          if(c === sep)stash(0);else add_char(buf,c);
          continue}}
      catch(_o0_)
       {_o0_ = caml_wrap_exception(_o0_);
        if(_o0_ === End_of_file)
         {if(0 < buf[2])stash(0);
          caml_ml_close_channel(ic);
          return of_list(rev(words[1]))}
        throw _o0_}}
    var _bf_=10,_bg_=1;
    function read_arg(_oZ_){return read_aux(_bg_,_bf_,_oZ_)}
    var _bh_=0,_bi_=0;
    function read_arg0(_oY_){return read_aux(_bi_,_bh_,_oY_)}
    function write_aux(sep,file,args)
     {var oc=open_out_bin(file);
      iter$5(function(s){return caml_call2(fprintf(oc,_bj_),s,sep)},args);
      return close_out(oc)}
    var _bk_=10;
    function write_arg(_oW_,_oX_){return write_aux(_bk_,_oW_,_oX_)}
    var _bl_=0;
    function write_arg0(_oU_,_oV_){return write_aux(_bl_,_oU_,_oV_)}
    var
     Stdlib_arg=
      [0,
       parse,
       parse_dynamic,
       parse_argv,
       parse_argv_dynamic,
       parse_and_expand_argv_dynamic,
       parse_expand,
       Help,
       Bad,
       usage,
       usage_string,
       align,
       current,
       read_arg,
       read_arg0,
       write_arg,
       write_arg0];
    caml_register_global(792,Stdlib_arg,"Stdlib__arg");
    var
     Stdlib_atomic=
      [0,make,get,set,exchange,compare_and_set,fetch_and_add,incr,decr];
    caml_register_global(793,Stdlib_atomic,"Stdlib__atomic");
    var printers=[0,0];
    function field(x,i)
     {var f=x[1 + i];
      return is_block(f)
              ?caml_obj_tag(f) === 252
                ?caml_call1(sprintf(_bm_),f)
                :caml_obj_tag(f) === 253?to_string(f):cst$60
              :caml_call1(sprintf(_bn_),f)}
    function other_fields(x,i)
     {if(x.length - 1 <= i)return cst$61;
      var _oS_=other_fields(x,i + 1 | 0),_oT_=field(x,i);
      return caml_call2(sprintf(_bo_),_oT_,_oS_)}
    function use_printers(x)
     {function conv(param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var tl=param$0[2],hd=param$0[1];
            try
             {var switch$0=0,val=caml_call1(hd,x);switch$0 = 1}
            catch(_oR_){}
            if(switch$0 && val){var s=val[1];return [0,s]}
            var param$0=tl;
            continue}
          return 0}}
      return conv(printers[1])}
    function to_string_default(x)
     {if(x === Out_of_memory)return cst_Out_of_memory;
      if(x === Stack_overflow)return cst_Stack_overflow;
      if(x[1] === Match_failure)
       {var match$0=x[2],char$0=match$0[3],line=match$0[2],file=match$0[1];
        return caml_call5
                (sprintf(locfmt),
                 file,
                 line,
                 char$0,
                 char$0 + 5 | 0,
                 cst_Pattern_matching_failed)}
      if(x[1] === Assert_failure)
       {var
         match$1=x[2],
         char$1=match$1[3],
         line$0=match$1[2],
         file$0=match$1[1];
        return caml_call5
                (sprintf(locfmt),
                 file$0,
                 line$0,
                 char$1,
                 char$1 + 6 | 0,
                 cst_Assertion_failed)}
      if(x[1] === Undefined_recursive_module)
       {var
         match$2=x[2],
         char$2=match$2[3],
         line$1=match$2[2],
         file$1=match$2[1];
        return caml_call5
                (sprintf(locfmt),
                 file$1,
                 line$1,
                 char$2,
                 char$2 + 6 | 0,
                 cst_Undefined_recursive_module)}
      if(0 === caml_obj_tag(x))
       {var constructor=x[1][1],match=x.length - 1;
        if(2 < match >>> 0)
         var
          _oN_=other_fields(x,2),
          _oO_=field(x,1),
          _oQ_=caml_call2(sprintf(_bp_),_oO_,_oN_);
        else
         switch(match)
          {case 0:var _oQ_=cst$62;break;
           case 1:var _oQ_=cst$63;break;
           default:var _oP_=field(x,1),_oQ_=caml_call1(sprintf(_bq_),_oP_)}
        return symbol(constructor,_oQ_)}
      return x[1]}
    function to_string$7(e)
     {var match=use_printers(e);
      if(match){var s=match[1];return s}
      return to_string_default(e)}
    function print(fct,arg)
     {try
       {var _oM_=caml_call1(fct,arg);return _oM_}
      catch(x)
       {x = caml_wrap_exception(x);
        var _oL_=to_string$7(x);
        caml_call1(eprintf(_br_),_oL_);
        caml_ml_flush(stderr);
        throw x}}
    function catch$0(fct,arg)
     {try
       {var _oK_=caml_call1(fct,arg);return _oK_}
      catch(x)
       {x = caml_wrap_exception(x);
        caml_ml_flush(stdout);
        var _oJ_=to_string$7(x);
        caml_call1(eprintf(_bs_),_oJ_);
        return exit(2)}}
    function raw_backtrace_entries(bt){return bt}
    function convert_raw_backtrace(bt)
     {return [0,runtime.caml_convert_raw_backtrace(bt)]}
    function format_backtrace_slot(pos,slot)
     {function info(is_raise)
       {return is_raise
                ?0 === pos?cst_Raised_at:cst_Re_raised_at
                :0 === pos?cst_Raised_by_primitive_operat:cst_Called_from}
      if(0 === slot[0])
       {var
         _oB_=slot[5],
         _oC_=slot[4],
         _oD_=slot[3],
         _oE_=slot[6]?cst_inlined:cst$64,
         _oF_=slot[2],
         _oG_=slot[7],
         _oH_=info(slot[1]);
        return [0,
                caml_call7(sprintf(_bt_),_oH_,_oG_,_oF_,_oE_,_oD_,_oC_,_oB_)]}
      if(slot[1])return 0;
      var _oI_=info(0);
      return [0,caml_call1(sprintf(_bu_),_oI_)]}
    function print_raw_backtrace(outchan,raw_backtrace)
     {var backtrace=convert_raw_backtrace(raw_backtrace);
      if(backtrace)
       {var a=backtrace[1],_oz_=a.length - 1 - 1 | 0,_oy_=0;
        if(! (_oz_ < 0))
         {var i=_oy_;
          for(;;)
           {var match=format_backtrace_slot(i,caml_check_bound(a,i)[1 + i]);
            if(match){var str=match[1];caml_call1(fprintf(outchan,_bv_),str)}
            var _oA_=i + 1 | 0;
            if(_oz_ !== i){var i=_oA_;continue}
            break}}
        return 0}
      return fprintf(outchan,_bw_)}
    function print_backtrace(outchan)
     {return print_raw_backtrace(outchan,caml_get_exception_raw_backtra(0))}
    function raw_backtrace_to_string(raw_backtrace)
     {var backtrace=convert_raw_backtrace(raw_backtrace);
      if(backtrace)
       {var a=backtrace[1],b=create$2(1024),_ow_=a.length - 1 - 1 | 0,_ov_=0;
        if(! (_ow_ < 0))
         {var i=_ov_;
          for(;;)
           {var match=format_backtrace_slot(i,caml_check_bound(a,i)[1 + i]);
            if(match){var str=match[1];caml_call1(bprintf(b,_bx_),str)}
            var _ox_=i + 1 | 0;
            if(_ow_ !== i){var i=_ox_;continue}
            break}}
        return contents(b)}
      return cst_Program_not_linked_with_g_}
    function backtrace_slot_is_raise(param)
     {return 0 === param[0]?param[1]:param[1]}
    function backtrace_slot_is_inline(param){return 0 === param[0]?param[6]:0}
    function backtrace_slot_location(param)
     {return 0 === param[0]?[0,[0,param[2],param[3],param[4],param[5]]]:0}
    function backtrace_slot_defname(param)
     {if(0 === param[0] && caml_string_notequal(param[7],cst$65))
       return [0,param[7]];
      return 0}
    function backtrace_slots(raw_backtrace)
     {var match=convert_raw_backtrace(raw_backtrace);
      if(match)
       {var backtrace=match[1],i$1=backtrace.length - 1 - 1 | 0,i=i$1;
        for(;;)
         {if(-1 === i)
           var _ou_=0;
          else
           {var
             param=caml_check_bound(backtrace,i)[1 + i],
             _ot_=0 === param[0]?1:0;
            if(! _ot_){var i$0=i - 1 | 0,i=i$0;continue}
            var _ou_=_ot_}
          return _ou_?[0,backtrace]:0}}
      return 0}
    function backtrace_slots_of_raw_entry(entry)
     {return backtrace_slots([0,entry])}
    function raw_backtrace_length(bt){return bt.length - 1}
    function get_backtrace(param)
     {return raw_backtrace_to_string(caml_get_exception_raw_backtra(0))}
    function register_printer(fn)
     {for(;;)
       {var
         old_printers=printers[1],
         new_printers=[0,fn,old_printers],
         success=compare_and_set(printers,old_printers,new_printers),
         _os_=1 - success;
        if(_os_)continue;
        return _os_}}
    function exn_slot(x){return 0 === caml_obj_tag(x)?x[1]:x}
    function exn_slot_id(x){var slot=exn_slot(x);return slot[2]}
    function exn_slot_name(x){var slot=exn_slot(x);return slot[1]}
    var errors=_by_.slice();
    function default_uncaught_exception_han(exn,raw_backtrace)
     {var _oq_=to_string$7(exn);
      caml_call1(eprintf(_bz_),_oq_);
      print_raw_backtrace(stderr,raw_backtrace);
      var status=runtime.caml_ml_debug_info_status(0);
      if(status < 0)
       {var _or_=abs(status);
        prerr_endline(caml_check_bound(errors,_or_)[1 + _or_])}
      return caml_ml_flush(stderr)}
    var uncaught_exception_handler=[0,default_uncaught_exception_han];
    function set_uncaught_exception_handler(fn)
     {uncaught_exception_handler[1] = fn;return 0}
    function _bA_(_op_){return runtime.caml_raw_backtrace_next_slot(_op_)}
    function _bB_(_oo_){return runtime.caml_convert_raw_backtrace_slot(_oo_)}
    function _bC_(_on_,_om_)
     {return runtime.caml_raw_backtrace_slot(_on_,_om_)}
    var
     _bD_=
      [0,
       backtrace_slot_is_raise,
       backtrace_slot_is_inline,
       backtrace_slot_location,
       backtrace_slot_defname,
       format_backtrace_slot];
    function _bE_(_ol_){return caml_get_exception_raw_backtra(_ol_)}
    function _bF_(_ok_){return runtime.caml_backtrace_status(_ok_)}
    var
     Stdlib_printexc=
      [0,
       to_string$7,
       to_string_default,
       print,
       catch$0,
       print_backtrace,
       get_backtrace,
       function(_oj_){return runtime.caml_record_backtrace(_oj_)},
       _bF_,
       register_printer,
       use_printers,
       raw_backtrace_entries,
       _bE_,
       print_raw_backtrace,
       raw_backtrace_to_string,
       default_uncaught_exception_han,
       set_uncaught_exception_handler,
       backtrace_slots,
       backtrace_slots_of_raw_entry,
       _bD_,
       raw_backtrace_length,
       _bC_,
       _bB_,
       _bA_,
       exn_slot_id,
       exn_slot_name];
    caml_register_global(794,Stdlib_printexc,"Stdlib__printexc");
    function const$0(c,param){return c}
    function flip(f,x,y){return caml_call2(f,y,x)}
    function negate(p,v){return 1 - caml_call1(p,v)}
    var
     Finally_raised=
      [248,cst_Stdlib_Fun_Finally_raised,caml_fresh_oo_id(0)];
    register_printer
     (function(param)
       {if(param[1] === Finally_raised)
         {var exn=param[2];
          return [0,symbol(cst_Fun_Finally_raised,to_string$7(exn))]}
        return 0});
    function protect(finally$0,work)
     {function finally_no_exn(param)
       {try
         {var _oi_=caml_call1(finally$0,0);return _oi_}
        catch(e)
         {e = caml_wrap_exception(e);
          var bt=caml_get_exception_raw_backtra(0),exn=[0,Finally_raised,e];
          caml_restore_raw_backtrace(exn,bt);
          throw exn}}
      try
       {var result=caml_call1(work,0)}
      catch(work_exn)
       {work_exn = caml_wrap_exception(work_exn);
        var work_bt=caml_get_exception_raw_backtra(0);
        finally_no_exn(0);
        caml_restore_raw_backtrace(work_exn,work_bt);
        throw work_exn}
      finally_no_exn(0);
      return result}
    var Stdlib_fun=[0,const$0,flip,negate,protect,Finally_raised];
    caml_register_global(795,Stdlib_fun,"Stdlib__fun");
    function print_stat(c)
     {var st=runtime.caml_gc_stat(0),_n2_=st[4];
      caml_call1(fprintf(c,_bG_),_n2_);
      var _n3_=st[5];
      caml_call1(fprintf(c,_bH_),_n3_);
      var _n4_=st[14];
      caml_call1(fprintf(c,_bI_),_n4_);
      var _n5_=st[17];
      caml_call1(fprintf(c,_bJ_),_n5_);
      fprintf(c,_bK_);
      var
       _n6_=st[1],
       l1=caml_ml_string_length(caml_call1(sprintf(_bL_),_n6_)),
       _n7_=st[1];
      caml_call2(fprintf(c,_bM_),l1,_n7_);
      var _n8_=st[2];
      caml_call2(fprintf(c,_bN_),l1,_n8_);
      var _n9_=st[3];
      caml_call2(fprintf(c,_bO_),l1,_n9_);
      fprintf(c,_bP_);
      var
       _n__=st[15],
       l2=caml_ml_string_length(caml_call1(sprintf(_bQ_),_n__)),
       _n$_=st[15];
      caml_call2(fprintf(c,_bR_),l2,_n$_);
      var _oa_=st[6];
      caml_call2(fprintf(c,_bS_),l2,_oa_);
      var _ob_=st[8];
      caml_call2(fprintf(c,_bT_),l2,_ob_);
      var _oc_=st[10];
      caml_call2(fprintf(c,_bU_),l2,_oc_);
      var _od_=st[12];
      caml_call2(fprintf(c,_bV_),l2,_od_);
      var _oe_=st[13];
      caml_call2(fprintf(c,_bW_),l2,_oe_);
      fprintf(c,_bX_);
      var _of_=st[9];
      caml_call1(fprintf(c,_bY_),_of_);
      var _og_=st[11];
      caml_call1(fprintf(c,_bZ_),_og_);
      var _oh_=st[7];
      return caml_call1(fprintf(c,_b0_),_oh_)}
    function allocated_bytes(param)
     {var
       match=runtime.caml_gc_counters(0),
       ma=match[3],
       pro=match[2],
       mi=match[1];
      return (mi + ma - pro) * 4}
    function create_alarm(f){return [0,1]}
    function delete_alarm(a){a[1] = 0;return 0}
    function _b1_(param){return 0}
    function _b2_(param){return 0}
    function _b3_(param){return 0}
    function _b4_(param){return 0}
    var null_tracker=[0,function(param){return 0},_b4_,_b3_,_b2_,_b1_];
    function start(sampling_rate,opt,tracker)
     {if(opt)
       var sth=opt[1],callstack_size=sth;
      else
       var callstack_size=max_int;
      return runtime.caml_memprof_start(sampling_rate,callstack_size,tracker)}
    var _b5_=[0,null_tracker,start,runtime.caml_memprof_stop];
    function _b6_(_n1_){return runtime.caml_final_release(_n1_)}
    function _b7_(_n0_,_nZ_)
     {return runtime.caml_final_register_called_without_value(_n0_,_nZ_)}
    var
     Stdlib_gc=
      [0,
       print_stat,
       allocated_bytes,
       function(_nY_,_nX_){return runtime.caml_final_register(_nY_,_nX_)},
       _b7_,
       _b6_,
       create_alarm,
       delete_alarm,
       _b5_];
    caml_register_global(796,Stdlib_gc,"Stdlib__gc");
    function string(str)
     {return caml_md5_string(str,0,caml_ml_string_length(str))}
    function bytes(b){return string(caml_string_of_bytes(b))}
    function substring(str,ofs,len)
     {if
       (0
        <=
        ofs
        &&
        0
        <=
        len
        &&
        !
        ((caml_ml_string_length(str) - len | 0) < ofs))
       return caml_md5_string(str,ofs,len);
      return invalid_arg(cst_Digest_substring)}
    function subbytes(b,ofs,len)
     {return substring(caml_string_of_bytes(b),ofs,len)}
    function file(filename)
     {var ic=open_in_bin(filename);
      try
       {var d=runtime.caml_md5_chan(ic,-1)}
      catch(e){e = caml_wrap_exception(e);caml_ml_close_channel(ic);throw e}
      caml_ml_close_channel(ic);
      return d}
    function output$0(chan,digest){return output_string(chan,digest)}
    function input$0(chan){return really_input_string(chan,16)}
    function char_hex(n){var _nW_=10 <= n?87:48;return n + _nW_ | 0}
    function to_hex(d)
     {if(16 !== caml_ml_string_length(d))invalid_arg(cst_Digest_to_hex);
      var result=caml_create_bytes(32),i=0;
      for(;;)
       {var x=caml_string_get(d,i);
        caml_bytes_unsafe_set(result,i * 2 | 0,char_hex(x >>> 4 | 0));
        caml_bytes_unsafe_set(result,(i * 2 | 0) + 1 | 0,char_hex(x & 15));
        var _nV_=i + 1 | 0;
        if(15 !== i){var i=_nV_;continue}
        return caml_string_of_bytes(result)}}
    function from_hex(s)
     {if(32 !== caml_ml_string_length(s))invalid_arg(cst_Digest_from_hex);
      function digit(c)
       {if(65 <= c)
         {if(97 <= c)
           {if(! (103 <= c))return (c - 97 | 0) + 10 | 0}
          else
           if(! (71 <= c))return (c - 65 | 0) + 10 | 0}
        else
         {var switcher=c - 48 | 0;if(! (9 < switcher >>> 0))return c - 48 | 0}
        throw [0,Invalid_argument,cst_Digest_from_hex$0]}
      var result=caml_create_bytes(16),i=0;
      for(;;)
       {var i$0=2 * i | 0,_nT_=digit(caml_string_get(s,i$0 + 1 | 0));
        caml_bytes_set
         (result,i,chr((digit(caml_string_get(s,i$0)) << 4) + _nT_ | 0));
        var _nU_=i + 1 | 0;
        if(15 !== i){var i=_nU_;continue}
        return caml_string_of_bytes(result)}}
    var
     Stdlib_digest=
      [0,
       compare$7,
       equal$7,
       string,
       bytes,
       substring,
       subbytes,
       file,
       output$0,
       input$0,
       to_hex,
       from_hex];
    caml_register_global(797,Stdlib_digest,"Stdlib__digest");
    function new_state(param){return [0,caml_make_vect(55,0),0]}
    function assign(st1,st2)
     {blit$1(st2[1],0,st1[1],0,55);st1[2] = st2[2];return 0}
    function full_init(s,seed)
     {var seed$0=0 === seed.length - 1?[0,0]:seed,l=seed$0.length - 1,i$0=0;
      for(;;)
       {caml_check_bound(s[1],i$0)[1 + i$0] = i$0;
        var _nS_=i$0 + 1 | 0;
        if(54 !== i$0){var i$0=_nS_;continue}
        var accu=[0,cst_x$1],_nO_=54 + max(55,l) | 0,_nN_=0;
        if(! (_nO_ < 0))
         {var i=_nN_;
          for(;;)
           {var
             j=i % 55 | 0,
             k=caml_mod(i,l),
             x=caml_check_bound(seed$0,k)[1 + k];
            accu[1] = string(symbol(accu[1],caml_string_of_jsbytes("" + x)));
            var
             _nP_=accu[1],
             _nJ_=caml_string_get(_nP_,3) << 24,
             _nK_=caml_string_get(_nP_,2) << 16,
             _nL_=caml_string_get(_nP_,1) << 8,
             _nM_=((caml_string_get(_nP_,0) + _nL_ | 0) + _nK_ | 0) + _nJ_ | 0,
             _nQ_=(caml_check_bound(s[1],j)[1 + j] ^ _nM_) & 1073741823;
            caml_check_bound(s[1],j)[1 + j] = _nQ_;
            var _nR_=i + 1 | 0;
            if(_nO_ !== i){var i=_nR_;continue}
            break}}
        s[2] = 0;
        return 0}}
    function make$3(seed)
     {var result=new_state(0);full_init(result,seed);return result}
    function make_self_init(param){return make$3(caml_sys_random_seed(0))}
    function copy$5(s){var result=new_state(0);assign(result,s);return result}
    function bits(s)
     {s[2] = (s[2] + 1 | 0) % 55 | 0;
      var
       _nG_=s[2],
       curval=caml_check_bound(s[1],_nG_)[1 + _nG_],
       _nH_=(s[2] + 24 | 0) % 55 | 0,
       newval=
        caml_check_bound(s[1],_nH_)[1 + _nH_]
        +
        (curval ^ (curval >>> 25 | 0) & 31)
        |
        0,
       newval30=newval & 1073741823,
       _nI_=s[2];
      caml_check_bound(s[1],_nI_)[1 + _nI_] = newval30;
      return newval30}
    function int$0(s,bound)
     {if(! (1073741823 < bound) && 0 < bound)
       for(;;)
        {var r=bits(s),v=caml_mod(r,bound);
         if(((1073741823 - bound | 0) + 1 | 0) < (r - v | 0))continue;
         return v}
      return invalid_arg(cst_Random_int)}
    function int32(s,bound)
     {if(caml_lessequal(bound,0))return invalid_arg(cst_Random_int32);
      for(;;)
       {var b1=bits(s),b2=(bits(s) & 1) << 30,r=b1 | b2,v=caml_mod(r,bound);
        if(caml_greaterthan(r - v | 0,(2147483647 - bound | 0) + 1 | 0))
         continue;
        return v}}
    function int64(s,bound)
     {if(caml_lessequal(bound,_b9_))return invalid_arg(cst_Random_int64);
      for(;;)
       {var
         b1=caml_int64_of_int32(bits(s)),
         b2=caml_int64_shift_left(caml_int64_of_int32(bits(s)),30),
         b3=caml_int64_shift_left(caml_int64_of_int32(bits(s) & 7),60),
         r=caml_int64_or(b1,caml_int64_or(b2,b3)),
         v=runtime.caml_int64_mod(r,bound);
        if
         (caml_greaterthan
           (caml_int64_sub(r,v),
            caml_int64_add(caml_int64_sub(max_int$2,bound),_b8_)))
         continue;
        return v}}
    function nativeint(s,bound){return int32(s,bound)}
    function float$0(s,bound)
     {var r1=bits(s),r2=bits(s);
      return (r1 / 1073741824. + r2) / 1073741824. * bound}
    function bool(s){return 0 === (bits(s) & 1)?1:0}
    var default$0=[0,_b__.slice(),0];
    function bits$0(param){return bits(default$0)}
    function int$1(bound){return int$0(default$0,bound)}
    function int32$0(bound){return int32(default$0,bound)}
    function nativeint$0(bound){return nativeint(default$0,bound)}
    function int64$0(bound){return int64(default$0,bound)}
    function float$1(scale){return float$0(default$0,scale)}
    function bool$0(param){return bool(default$0)}
    function full_init$0(seed){return full_init(default$0,seed)}
    function init$4(seed){return full_init(default$0,[0,seed])}
    function self_init(param){return full_init$0(caml_sys_random_seed(0))}
    function get_state(param){return copy$5(default$0)}
    function set_state(s){return assign(default$0,s)}
    var
     _b$_=
      [0,
       make$3,
       make_self_init,
       copy$5,
       bits,
       int$0,
       int32,
       nativeint,
       int64,
       float$0,
       bool],
     Stdlib_random=
      [0,
       init$4,
       full_init$0,
       self_init,
       bits$0,
       int$1,
       int32$0,
       nativeint$0,
       int64$0,
       float$1,
       bool$0,
       _b$_,
       get_state,
       set_state];
    caml_register_global(798,Stdlib_random,"Stdlib__random");
    function ongoing_traversal(h)
     {var _nE_=h.length - 1 < 4?1:0,_nF_=_nE_ || (h[4] < 0?1:0);return _nF_}
    function flip_ongoing_traversal(h){h[4] = - h[4] | 0;return 0}
    try
     {var _cU_=caml_sys_getenv(cst_OCAMLRUNPARAM),params=_cU_}
    catch(_nC_)
     {_nC_ = caml_wrap_exception(_nC_);
      if(_nC_ !== Not_found)throw _nC_;
      try
       {var _cT_=caml_sys_getenv(cst_CAMLRUNPARAM),_ca_=_cT_}
      catch(_nD_)
       {_nD_ = caml_wrap_exception(_nD_);
        if(_nD_ !== Not_found)throw _nD_;
        var _ca_=cst$66}
      var params=_ca_}
    var
     randomized_default=contains$0(params,82),
     randomized=[0,randomized_default];
    function randomize(param){randomized[1] = 1;return 0}
    function is_randomized(param){return randomized[1]}
    var prng=[246,function(_nB_){return caml_call1(_b$_[2],0)}];
    function power_2_above(x,n)
     {var x$0=x;
      for(;;)
       {if(n <= x$0)return x$0;
        if(max_array_length < (x$0 * 2 | 0))return x$0;
        var x$1=x$0 * 2 | 0,x$0=x$1;
        continue}}
    function create$3(opt,initial_size)
     {if(opt)var sth=opt[1],random=sth;else var random=randomized[1];
      var s=power_2_above(16,initial_size);
      if(random)
       var
        _nz_=caml_obj_tag(prng),
        _nA_=250 === _nz_?prng[1]:246 === _nz_?force_lazy_block(prng):prng,
        seed=caml_call1(_b$_[4],_nA_);
      else
       var seed=0;
      return [0,0,caml_make_vect(s,0),seed,s]}
    function clear$2(h)
     {var _ny_=0 < h[1]?1:0;
      return _ny_?(h[1] = 0,fill$0(h[2],0,h[2].length - 1,0)):_ny_}
    function reset$0(h)
     {var len=h[2].length - 1;
      if(4 <= h.length - 1 && len !== abs(h[4]))
       {h[1] = 0;h[2] = caml_make_vect(abs(h[4]),0);return 0}
      return clear$2(h)}
    function copy_bucketlist(param)
     {if(param)
       {var
         key=param[1],
         data=param[2],
         next=param[3],
         prec$0=[0,key,data,next],
         prec=prec$0,
         param$0=next;
        for(;;)
         {if(param$0)
           {var
             key$0=param$0[1],
             data$0=param$0[2],
             next$0=param$0[3],
             r=[0,key$0,data$0,next$0];
            if(prec){prec[3] = r;var prec=r,param$0=next$0;continue}
            throw [0,Assert_failure,_cb_]}
          return prec$0}}
      return 0}
    function copy$6(init)
     {var _nv_=init[4],_nw_=init[3],_nx_=map$6(copy_bucketlist,init[2]);
      return [0,init[1],_nx_,_nw_,_nv_]}
    function length$4(h){return h[1]}
    function insert_all_buckets(indexfun,inplace,odata,ndata)
     {var
       nsize=ndata.length - 1,
       ndata_tail=caml_make_vect(nsize,0),
       _np_=odata.length - 1 - 1 | 0,
       _no_=0;
      if(! (_np_ < 0))
       {var i$0=_no_;
        a:
        for(;;)
         {var cell$1=caml_check_bound(odata,i$0)[1 + i$0],cell=cell$1;
          for(;;)
           {if(cell)
             {var
               key=cell[1],
               data=cell[2],
               next=cell[3],
               cell$0=inplace?cell:[0,key,data,0],
               nidx=caml_call1(indexfun,key),
               match=caml_check_bound(ndata_tail,nidx)[1 + nidx];
              if(match)
               match[3] = cell$0;
              else
               caml_check_bound(ndata,nidx)[1 + nidx] = cell$0;
              caml_check_bound(ndata_tail,nidx)[1 + nidx] = cell$0;
              var cell=next;
              continue}
            var _nu_=i$0 + 1 | 0;
            if(_np_ !== i$0){var i$0=_nu_;continue a}
            break}
          break}}
      if(inplace)
       {var _nr_=nsize - 1 | 0,_nq_=0;
        if(! (_nr_ < 0))
         {var i=_nq_;
          for(;;)
           {var match$0=caml_check_bound(ndata_tail,i)[1 + i];
            if(match$0)match$0[3] = 0;
            var _nt_=i + 1 | 0;
            if(_nr_ !== i){var i=_nt_;continue}
            break}}
        var _ns_=0}
      else
       var _ns_=inplace;
      return _ns_}
    function resize$0(indexfun,h)
     {var
       odata=h[2],
       osize=odata.length - 1,
       nsize=osize * 2 | 0,
       _nn_=nsize < max_array_length?1:0;
      if(_nn_)
       {var ndata=caml_make_vect(nsize,0),inplace=1 - ongoing_traversal(h);
        h[2] = ndata;
        return insert_all_buckets(caml_call1(indexfun,h),inplace,odata,ndata)}
      return _nn_}
    function iter$10(f,h)
     {function do_bucket(param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var key=param$0[1],data=param$0[2],next=param$0[3];
            caml_call2(f,key,data);
            var param$0=next;
            continue}
          return 0}}
      var old_trav=ongoing_traversal(h);
      if(1 - old_trav)flip_ongoing_traversal(h);
      try
       {var d=h[2],_nj_=d.length - 1 - 1 | 0,_ni_=0;
        if(! (_nj_ < 0))
         {var i=_ni_;
          for(;;)
           {do_bucket(caml_check_bound(d,i)[1 + i]);
            var _nm_=i + 1 | 0;
            if(_nj_ !== i){var i=_nm_;continue}
            break}}
        var _nk_=1 - old_trav,_nl_=_nk_?flip_ongoing_traversal(h):_nk_;
        return _nl_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(old_trav)throw exn;
        flip_ongoing_traversal(h);
        throw exn}}
    function filter_map_inplace_bucket(f,h,i,prec,slot)
     {var prec$0=prec,slot$0=slot;
      for(;;)
       {if(slot$0)
         {var
           key=slot$0[1],
           data=slot$0[2],
           next=slot$0[3],
           match=caml_call2(f,key,data);
          if(match)
           {var data$0=match[1];
            if(prec$0)
             prec$0[3] = slot$0;
            else
             caml_check_bound(h[2],i)[1 + i] = slot$0;
            slot$0[2] = data$0;
            var prec$0=slot$0,slot$0=next;
            continue}
          h[1] = h[1] - 1 | 0;
          var slot$0=next;
          continue}
        return prec$0
                ?(prec$0[3] = 0,0)
                :(caml_check_bound(h[2],i)[1 + i] = 0,0)}}
    function filter_map_inplace(f,h)
     {var d=h[2],old_trav=ongoing_traversal(h);
      if(1 - old_trav)flip_ongoing_traversal(h);
      try
       {var _ne_=d.length - 1 - 1 | 0,_nd_=0;
        if(! (_ne_ < 0))
         {var i=_nd_;
          for(;;)
           {filter_map_inplace_bucket(f,h,i,0,caml_check_bound(h[2],i)[1 + i]);
            var _nh_=i + 1 | 0;
            if(_ne_ !== i){var i=_nh_;continue}
            break}}
        var _nf_=1 - old_trav,_ng_=_nf_?flip_ongoing_traversal(h):_nf_;
        return _ng_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(old_trav)throw exn;
        flip_ongoing_traversal(h);
        throw exn}}
    function fold$4(f,h,init)
     {function do_bucket(b,accu)
       {var b$0=b,accu$0=accu;
        for(;;)
         {if(b$0)
           {var
             key=b$0[1],
             data=b$0[2],
             next=b$0[3],
             accu$1=caml_call3(f,key,data,accu$0),
             b$0=next,
             accu$0=accu$1;
            continue}
          return accu$0}}
      var old_trav=ongoing_traversal(h);
      if(1 - old_trav)flip_ongoing_traversal(h);
      try
       {var d=h[2],accu=[0,init],_m$_=d.length - 1 - 1 | 0,_m__=0;
        if(! (_m$_ < 0))
         {var i=_m__;
          for(;;)
           {var _nb_=accu[1];
            accu[1] = do_bucket(caml_check_bound(d,i)[1 + i],_nb_);
            var _nc_=i + 1 | 0;
            if(_m$_ !== i){var i=_nc_;continue}
            break}}
        if(1 - old_trav)flip_ongoing_traversal(h);
        var _na_=accu[1];
        return _na_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(old_trav)throw exn;
        flip_ongoing_traversal(h);
        throw exn}}
    function bucket_length(accu,param)
     {var accu$0=accu,param$0=param;
      for(;;)
       {if(param$0)
         {var
           param$1=param$0[3],
           accu$1=accu$0 + 1 | 0,
           accu$0=accu$1,
           param$0=param$1;
          continue}
        return accu$0}}
    function stats(h)
     {var
       _m6_=h[2],
       _m7_=0,
       mbl=
        fold_left$1(function(m,b){return max(m,bucket_length(0,b))},_m7_,_m6_),
       histo=caml_make_vect(mbl + 1 | 0,0),
       _m8_=h[2];
      iter$5
       (function(b)
         {var
           l=bucket_length(0,b),
           _m9_=caml_check_bound(histo,l)[1 + l] + 1 | 0;
          caml_check_bound(histo,l)[1 + l] = _m9_;
          return 0},
        _m8_);
      return [0,h[1],h[2].length - 1,mbl,histo]}
    function to_seq$9(tbl)
     {var tbl_data=tbl[2];
      function aux(i,buck,param)
       {var i$0=i,buck$0=buck;
        for(;;)
         {if(buck$0)
           {var key=buck$0[1],data=buck$0[2],next=buck$0[3];
            return [0,[0,key,data],function(_m5_){return aux(i$0,next,_m5_)}]}
          if(i$0 === tbl_data.length - 1)return 0;
          var
           buck$1=caml_check_bound(tbl_data,i$0)[1 + i$0],
           i$1=i$0 + 1 | 0,
           i$0=i$1,
           buck$0=buck$1;
          continue}}
      var _m2_=0,_m3_=0;
      return function(_m4_){return aux(_m3_,_m2_,_m4_)}}
    function to_seq_keys(m)
     {var _mY_=to_seq$9(m);
      function _mZ_(_m1_){return _m1_[1]}
      return function(_m0_){return map(_mZ_,_mY_,_m0_)}}
    function to_seq_values(m)
     {var _mU_=to_seq$9(m);
      function _mV_(_mX_){return _mX_[2]}
      return function(_mW_){return map(_mV_,_mU_,_mW_)}}
    function MakeSeeded(H)
     {function key_index(h,key)
       {var _mT_=h[2].length - 1 - 1 | 0;
        return caml_call2(H[2],h[3],key) & _mT_}
      function add(h,key,data)
       {var
         i=key_index(h,key),
         bucket=[0,key,data,caml_check_bound(h[2],i)[1 + i]];
        caml_check_bound(h[2],i)[1 + i] = bucket;
        h[1] = h[1] + 1 | 0;
        var _mS_=h[2].length - 1 << 1 < h[1]?1:0;
        return _mS_?resize$0(key_index,h):_mS_}
      function remove(h,key)
       {var
         i=key_index(h,key),
         c$0=caml_check_bound(h[2],i)[1 + i],
         prec=0,
         c=c$0;
        for(;;)
         {if(c)
           {var k=c[1],next=c[3];
            if(caml_call2(H[1],k,key))
             {h[1] = h[1] - 1 | 0;
              return prec
                      ?(prec[3] = next,0)
                      :(caml_check_bound(h[2],i)[1 + i] = next,0)}
            var prec=c,c=next;
            continue}
          return 0}}
      function find(h,key)
       {var _mR_=key_index(h,key),match=caml_check_bound(h[2],_mR_)[1 + _mR_];
        if(match)
         {var k1=match[1],d1=match[2],next1=match[3];
          if(caml_call2(H[1],key,k1))return d1;
          if(next1)
           {var k2=next1[1],d2=next1[2],next2=next1[3];
            if(caml_call2(H[1],key,k2))return d2;
            if(next2)
             {var k3=next2[1],d3=next2[2],next3=next2[3];
              if(caml_call2(H[1],key,k3))return d3;
              var param=next3;
              for(;;)
               {if(param)
                 {var k=param[1],data=param[2],next=param[3];
                  if(caml_call2(H[1],key,k))return data;
                  var param=next;
                  continue}
                throw Not_found}}
            throw Not_found}
          throw Not_found}
        throw Not_found}
      function find_opt(h,key)
       {var _mQ_=key_index(h,key),match=caml_check_bound(h[2],_mQ_)[1 + _mQ_];
        if(match)
         {var k1=match[1],d1=match[2],next1=match[3];
          if(caml_call2(H[1],key,k1))return [0,d1];
          if(next1)
           {var k2=next1[1],d2=next1[2],next2=next1[3];
            if(caml_call2(H[1],key,k2))return [0,d2];
            if(next2)
             {var k3=next2[1],d3=next2[2],next3=next2[3];
              if(caml_call2(H[1],key,k3))return [0,d3];
              var param=next3;
              for(;;)
               {if(param)
                 {var k=param[1],data=param[2],next=param[3];
                  if(caml_call2(H[1],key,k))return [0,data];
                  var param=next;
                  continue}
                return 0}}
            return 0}
          return 0}
        return 0}
      function find_all(h,key)
       {function find_in_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var k=param$0[1],d=param$0[2],next=param$0[3];
              if(caml_call2(H[1],k,key))return [0,d,find_in_bucket(next)];
              var param$0=next;
              continue}
            return 0}}
        var _mP_=key_index(h,key);
        return find_in_bucket(caml_check_bound(h[2],_mP_)[1 + _mP_])}
      function replace(h,key,data)
       {var
         i=key_index(h,key),
         param$0=caml_check_bound(h[2],i)[1 + i],
         param=param$0;
        for(;;)
         {if(param)
           {var k=param[1],next=param[3];
            if(! caml_call2(H[1],k,key)){var param=next;continue}
            param[1] = key;
            param[2] = data;
            var _mM_=0}
          else
           var _mM_=1;
          if(_mM_)
           {caml_check_bound(h[2],i)[1 + i] = [0,key,data,param$0];
            h[1] = h[1] + 1 | 0;
            var _mN_=h[2].length - 1 << 1 < h[1]?1:0;
            if(_mN_)return resize$0(key_index,h);
            var _mO_=_mN_}
          else
           var _mO_=_mM_;
          return _mO_}}
      function mem(h,key)
       {var
         _mL_=key_index(h,key),
         param$0=caml_check_bound(h[2],_mL_)[1 + _mL_],
         param=param$0;
        for(;;)
         {if(param)
           {var k=param[1],next=param[3],_mK_=caml_call2(H[1],k,key);
            if(_mK_)return _mK_;
            var param=next;
            continue}
          return 0}}
      function add_seq(tbl,i)
       {return iter
                (function(param)
                  {var v=param[2],k=param[1];return add(tbl,k,v)},
                 i)}
      function replace_seq(tbl,i)
       {return iter
                (function(param)
                  {var v=param[2],k=param[1];return replace(tbl,k,v)},
                 i)}
      function of_seq(i){var tbl=create$3(0,16);replace_seq(tbl,i);return tbl}
      return [0,
              create$3,
              clear$2,
              reset$0,
              copy$6,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter$10,
              filter_map_inplace,
              fold$4,
              length$4,
              stats,
              to_seq$9,
              to_seq_keys,
              to_seq_values,
              add_seq,
              replace_seq,
              of_seq]}
    function Make$0(H)
     {var equal=H[1];
      function hash(seed,x){return caml_call1(H[2],x)}
      var
       include=MakeSeeded([0,equal,hash]),
       clear=include[2],
       reset=include[3],
       copy=include[4],
       add=include[5],
       remove=include[6],
       find=include[7],
       find_opt=include[8],
       find_all=include[9],
       replace=include[10],
       mem=include[11],
       iter=include[12],
       filter_map_inplace=include[13],
       fold=include[14],
       length=include[15],
       stats=include[16],
       to_seq=include[17],
       to_seq_keys=include[18],
       to_seq_values=include[19],
       add_seq=include[20],
       replace_seq=include[21],
       _mJ_=include[1];
      function create(sz){return caml_call2(_mJ_,_cc_,sz)}
      function of_seq(i)
       {var tbl=create(16);caml_call2(replace_seq,tbl,i);return tbl}
      return [0,
              create,
              clear,
              reset,
              copy,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter,
              filter_map_inplace,
              fold,
              length,
              stats,
              to_seq,
              to_seq_keys,
              to_seq_values,
              add_seq,
              replace_seq,
              of_seq]}
    function hash$1(x){return caml_hash(10,100,0,x)}
    function hash_param(n1,n2,x){return caml_hash(n1,n2,0,x)}
    function seeded_hash(seed,x){return caml_hash(10,100,seed,x)}
    function key_index(h,key)
     {return 4 <= h.length - 1
              ?caml_hash(10,100,h[3],key) & (h[2].length - 1 - 1 | 0)
              :invalid_arg(cst_Hashtbl_unsupported_hash_t)}
    function add$0(h,key,data)
     {var
       i=key_index(h,key),
       bucket=[0,key,data,caml_check_bound(h[2],i)[1 + i]];
      caml_check_bound(h[2],i)[1 + i] = bucket;
      h[1] = h[1] + 1 | 0;
      var _mI_=h[2].length - 1 << 1 < h[1]?1:0;
      return _mI_?resize$0(key_index,h):_mI_}
    function remove(h,key)
     {var i=key_index(h,key),c$0=caml_check_bound(h[2],i)[1 + i],prec=0,c=c$0;
      for(;;)
       {if(c)
         {var k=c[1],next=c[3];
          if(0 === caml_compare(k,key))
           {h[1] = h[1] - 1 | 0;
            return prec
                    ?(prec[3] = next,0)
                    :(caml_check_bound(h[2],i)[1 + i] = next,0)}
          var prec=c,c=next;
          continue}
        return 0}}
    function find$0(h,key)
     {var _mH_=key_index(h,key),match=caml_check_bound(h[2],_mH_)[1 + _mH_];
      if(match)
       {var k1=match[1],d1=match[2],next1=match[3];
        if(0 === caml_compare(key,k1))return d1;
        if(next1)
         {var k2=next1[1],d2=next1[2],next2=next1[3];
          if(0 === caml_compare(key,k2))return d2;
          if(next2)
           {var k3=next2[1],d3=next2[2],next3=next2[3];
            if(0 === caml_compare(key,k3))return d3;
            var param=next3;
            for(;;)
             {if(param)
               {var k=param[1],data=param[2],next=param[3];
                if(0 === caml_compare(key,k))return data;
                var param=next;
                continue}
              throw Not_found}}
          throw Not_found}
        throw Not_found}
      throw Not_found}
    function find_opt$0(h,key)
     {var _mG_=key_index(h,key),match=caml_check_bound(h[2],_mG_)[1 + _mG_];
      if(match)
       {var k1=match[1],d1=match[2],next1=match[3];
        if(0 === caml_compare(key,k1))return [0,d1];
        if(next1)
         {var k2=next1[1],d2=next1[2],next2=next1[3];
          if(0 === caml_compare(key,k2))return [0,d2];
          if(next2)
           {var k3=next2[1],d3=next2[2],next3=next2[3];
            if(0 === caml_compare(key,k3))return [0,d3];
            var param=next3;
            for(;;)
             {if(param)
               {var k=param[1],data=param[2],next=param[3];
                if(0 === caml_compare(key,k))return [0,data];
                var param=next;
                continue}
              return 0}}
          return 0}
        return 0}
      return 0}
    function find_all$0(h,key)
     {function find_in_bucket(param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var k=param$0[1],data=param$0[2],next=param$0[3];
            if(0 === caml_compare(k,key))return [0,data,find_in_bucket(next)];
            var param$0=next;
            continue}
          return 0}}
      var _mF_=key_index(h,key);
      return find_in_bucket(caml_check_bound(h[2],_mF_)[1 + _mF_])}
    function replace(h,key,data)
     {var
       i=key_index(h,key),
       param$0=caml_check_bound(h[2],i)[1 + i],
       param=param$0;
      for(;;)
       {if(param)
         {var k=param[1],next=param[3];
          if(0 !== caml_compare(k,key)){var param=next;continue}
          param[1] = key;
          param[2] = data;
          var _mC_=0}
        else
         var _mC_=1;
        if(_mC_)
         {caml_check_bound(h[2],i)[1 + i] = [0,key,data,param$0];
          h[1] = h[1] + 1 | 0;
          var _mD_=h[2].length - 1 << 1 < h[1]?1:0;
          if(_mD_)return resize$0(key_index,h);
          var _mE_=_mD_}
        else
         var _mE_=_mC_;
        return _mE_}}
    function mem$2(h,key)
     {var
       _mB_=key_index(h,key),
       param$0=caml_check_bound(h[2],_mB_)[1 + _mB_],
       param=param$0;
      for(;;)
       {if(param)
         {var k=param[1],next=param[3],_mA_=0 === caml_compare(k,key)?1:0;
          if(_mA_)return _mA_;
          var param=next;
          continue}
        return 0}}
    function add_seq$2(tbl,i)
     {return iter
              (function(param)
                {var v=param[2],k=param[1];return add$0(tbl,k,v)},
               i)}
    function replace_seq(tbl,i)
     {return iter
              (function(param)
                {var v=param[2],k=param[1];return replace(tbl,k,v)},
               i)}
    function of_seq$7(i){var tbl=create$3(0,16);replace_seq(tbl,i);return tbl}
    function rebuild(opt,h)
     {if(opt)var sth=opt[1],random=sth;else var random=randomized[1];
      var s=power_2_above(16,h[2].length - 1);
      if(random)
       var
        _mt_=caml_obj_tag(prng),
        _mu_=250 === _mt_?prng[1]:246 === _mt_?force_lazy_block(prng):prng,
        seed=caml_call1(_b$_[4],_mu_);
      else
       var seed=4 <= h.length - 1?h[3]:0;
      var
       _mv_=4 <= h.length - 1?h[4]:s,
       h$0=[0,h[1],caml_make_vect(s,0),seed,_mv_],
       _mw_=h$0[2],
       _mx_=h[2],
       _my_=0;
      insert_all_buckets
       (function(_mz_){return key_index(h$0,_mz_)},_my_,_mx_,_mw_);
      return h$0}
    var
     Stdlib_hashtbl=
      [0,
       create$3,
       clear$2,
       reset$0,
       copy$6,
       add$0,
       find$0,
       find_opt$0,
       find_all$0,
       mem$2,
       remove,
       replace,
       iter$10,
       filter_map_inplace,
       fold$4,
       length$4,
       randomize,
       is_randomized,
       rebuild,
       stats,
       to_seq$9,
       to_seq_keys,
       to_seq_values,
       add_seq$2,
       replace_seq,
       of_seq$7,
       Make$0,
       MakeSeeded,
       hash$1,
       seeded_hash,
       hash_param,
       caml_hash];
    caml_register_global(799,Stdlib_hashtbl,"Stdlib__hashtbl");
    function weak_create(l)
     {var _mr_=0 <= l?1:0,_ms_=_mr_?l <= _t_[15]?1:0:_mr_;
      if(1 - _ms_)invalid_arg(cst_Weak_create);
      return runtime.caml_weak_create(l)}
    function length$5(x){return x.length - 1 - 2 | 0}
    function raise_if_invalid_offset$0(e,o,msg)
     {var _mo_=0 <= o?1:0,_mp_=_mo_?o < length$5(e)?1:0:_mo_,_mq_=1 - _mp_;
      return _mq_?invalid_arg(msg):_mq_}
    function set$0(e,o,x)
     {raise_if_invalid_offset$0(e,o,cst_Weak_set);
      if(x){var x$0=x[1];return caml_ephe_set_key(e,o,x$0)}
      return caml_ephe_unset_key(e,o)}
    function get$1(e,o)
     {raise_if_invalid_offset$0(e,o,cst_Weak_get);
      return runtime.caml_weak_get(e,o)}
    function get_copy(e,o)
     {raise_if_invalid_offset$0(e,o,cst_Weak_get_copy);
      return runtime.caml_weak_get_copy(e,o)}
    function check$0(e,o)
     {raise_if_invalid_offset$0(e,o,cst_Weak_check);
      return runtime.caml_weak_check(e,o)}
    function blit$4(e1,o1,e2,o2,l)
     {if
       (0
        <=
        l
        &&
        0
        <=
        o1
        &&
        !
        ((length$5(e1) - l | 0) < o1)
        &&
        0
        <=
        o2
        &&
        !
        ((length$5(e2) - l | 0) < o2))
       {var
         _mm_=0 !== l?1:0,
         _mn_=_mm_?runtime.caml_weak_blit(e1,o1,e2,o2,l):_mm_;
        return _mn_}
      return invalid_arg(cst_Weak_blit)}
    function fill$2(ar,ofs,len,x)
     {if(0 <= ofs && 0 <= len && ! ((length$5(ar) - len | 0) < ofs))
       {var _mk_=(ofs + len | 0) - 1 | 0;
        if(! (_mk_ < ofs))
         {var i=ofs;
          for(;;)
           {set$0(ar,i,x);
            var _ml_=i + 1 | 0;
            if(_mk_ !== i){var i=_ml_;continue}
            break}}
        return 0}
      throw [0,Invalid_argument,cst_Weak_fill]}
    function Make$1(H)
     {var emptybucket=weak_create(0);
      function get_index(t,h){return caml_mod(h & 2147483647,t[1].length - 1)}
      var limit=7;
      function create(sz)
       {var
         sz$0=7 <= sz?sz:7,
         sz$1=max_array_length < sz$0?max_array_length:sz$0;
        return [0,
                caml_make_vect(sz$1,emptybucket),
                caml_make_vect(sz$1,[0]),
                limit,
                0,
                0]}
      function clear(t)
       {var _mi_=t[1].length - 1 - 1 | 0,_mh_=0;
        if(! (_mi_ < 0))
         {var i=_mh_;
          for(;;)
           {caml_check_bound(t[1],i)[1 + i] = emptybucket;
            caml_check_bound(t[2],i)[1 + i] = [0];
            var _mj_=i + 1 | 0;
            if(_mi_ !== i){var i=_mj_;continue}
            break}}
        t[3] = limit;
        t[4] = 0;
        return 0}
      function fold(f,t,init)
       {var _mg_=t[1],i=0;
        return fold_right$0
                (function(b,accu$1)
                  {var i$0=i,accu=accu$1;
                   for(;;)
                    {if(length$5(b) <= i$0)return accu;
                     var match=get$1(b,i$0);
                     if(match)
                      {var
                        v=match[1],
                        accu$0=caml_call2(f,v,accu),
                        i$1=i$0 + 1 | 0,
                        i$0=i$1,
                        accu=accu$0;
                       continue}
                     var i$2=i$0 + 1 | 0,i$0=i$2;
                     continue}},
                 _mg_,
                 init)}
      function iter(f,t)
       {var _mf_=t[1],i=0;
        return iter$5
                (function(b)
                  {var i$0=i;
                   for(;;)
                    {if(length$5(b) <= i$0)return 0;
                     var match=get$1(b,i$0);
                     if(match)
                      {var v=match[1];
                       caml_call1(f,v);
                       var i$1=i$0 + 1 | 0,i$0=i$1;
                       continue}
                     var i$2=i$0 + 1 | 0,i$0=i$2;
                     continue}},
                 _mf_)}
      function count_bucket(i,b,accu)
       {var i$0=i,accu$0=accu;
        for(;;)
         {if(length$5(b) <= i$0)return accu$0;
          var
           _me_=check$0(b,i$0)?1:0,
           accu$1=accu$0 + _me_ | 0,
           i$1=i$0 + 1 | 0,
           i$0=i$1,
           accu$0=accu$1;
          continue}}
      function count(t)
       {var _l$_=0,_ma_=t[1],_mb_=0;
        return fold_right$0
                (function(_mc_,_md_){return count_bucket(_mb_,_mc_,_md_)},
                 _ma_,
                 _l$_)}
      function add_aux(t,setter,d,h,index)
       {var
         bucket$0=caml_check_bound(t[1],index)[1 + index],
         hashes=caml_check_bound(t[2],index)[1 + index],
         sz=length$5(bucket$0),
         i$3=0;
        for(;;)
         {if(sz <= i$3)
           {var
             newsz=
              min(((3 * sz | 0) / 2 | 0) + 3 | 0,max_array_length - 2 | 0);
            if(newsz <= sz)failwith(cst_Weak_Make_hash_bucket_cann);
            var
             newbucket$0=weak_create(newsz),
             newhashes=caml_make_vect(newsz,0);
            blit$4(bucket$0,0,newbucket$0,0,sz);
            blit$1(hashes,0,newhashes,0,sz);
            caml_call3(setter,newbucket$0,sz,d);
            caml_check_bound(newhashes,sz)[1 + sz] = h;
            caml_check_bound(t[1],index)[1 + index] = newbucket$0;
            caml_check_bound(t[2],index)[1 + index] = newhashes;
            var _l7_=sz <= t[3]?1:0,_l8_=_l7_?t[3] < newsz?1:0:_l7_;
            if(_l8_)
             {t[4] = t[4] + 1 | 0;
              var i$4=0;
              for(;;)
               {var
                 _lX_=t[5],
                 bucket=caml_check_bound(t[1],_lX_)[1 + _lX_],
                 _lY_=t[5],
                 hbucket=caml_check_bound(t[2],_lY_)[1 + _lY_],
                 n=length$5(bucket),
                 prev_len=(((n - 3 | 0) * 2 | 0) + 2 | 0) / 3 | 0,
                 live=count_bucket(0,bucket,0);
                if(live <= prev_len)
                 {var j$2=length$5(bucket) - 1 | 0,i$0=0,j=j$2;
                  for(;;)
                   {if(prev_len <= j)
                     {if(check$0(bucket,i$0))
                       {var i$1=i$0 + 1 | 0,i$0=i$1;continue}
                      if(check$0(bucket,j))
                       {blit$4(bucket,j,bucket,i$0,1);
                        var _lZ_=caml_check_bound(hbucket,j)[1 + j];
                        caml_check_bound(hbucket,i$0)[1 + i$0] = _lZ_;
                        var j$0=j - 1 | 0,i$2=i$0 + 1 | 0,i$0=i$2,j=j$0;
                        continue}
                      var j$1=j - 1 | 0,j=j$1;
                      continue}
                    if(0 === prev_len)
                     {var _l0_=t[5];
                      caml_check_bound(t[1],_l0_)[1 + _l0_] = emptybucket;
                      var _l1_=t[5];
                      caml_check_bound(t[2],_l1_)[1 + _l1_] = [0]}
                    else
                     {var newbucket=weak_create(prev_len);
                      blit$4(bucket,0,newbucket,0,prev_len);
                      var _l4_=t[5];
                      caml_check_bound(t[1],_l4_)[1 + _l4_] = newbucket;
                      var _l5_=sub$1(hbucket,0,prev_len),_l6_=t[5];
                      caml_check_bound(t[2],_l6_)[1 + _l6_] = _l5_}
                    var _l2_=t[3] < n?1:0,_l3_=_l2_?prev_len <= t[3]?1:0:_l2_;
                    if(_l3_)t[4] = t[4] - 1 | 0;
                    break}}
                t[5] = caml_mod(t[5] + 1 | 0,t[1].length - 1);
                var _l__=i$4 + 1 | 0;
                if(2 !== i$4){var i$4=_l__;continue}
                break}}
            var _l9_=((t[1].length - 1) / 2 | 0) < t[4]?1:0;
            if(_l9_)
             {var
               n$0=t[1].length - 1,
               newlen=min(((3 * n$0 | 0) / 2 | 0) + 3 | 0,max_array_length);
              if(n$0 < newlen)
               {var newt=create(newlen),_lW_=t[1],i=0;
                iteri$2
                 (function(j,ob)
                   {var i$0=i;
                    for(;;)
                     {if(length$5(ob) <= i$0)return 0;
                      var match=check$0(ob,i$0);
                      if(match)
                       {var
                         oh=caml_check_bound(t[2],j)[1 + j],
                         setter$0=
                          function(i)
                           {function setter(nb,ni,param){return blit$4(ob,i,nb,ni,1)}
                            return setter},
                         setter=setter$0(i$0),
                         h=caml_check_bound(oh,i$0)[1 + i$0];
                        add_aux(newt,setter,0,h,get_index(newt,h));
                        var i$1=i$0 + 1 | 0,i$0=i$1;
                        continue}
                      var i$2=i$0 + 1 | 0,i$0=i$2;
                      continue}},
                  _lW_);
                t[1] = newt[1];
                t[2] = newt[2];
                t[3] = newt[3];
                t[4] = newt[4];
                t[5] = caml_mod(t[5],newt[1].length - 1);
                return 0}
              t[3] = max_int;
              t[4] = 0;
              return 0}
            return _l9_}
          if(check$0(bucket$0,i$3)){var i$5=i$3 + 1 | 0,i$3=i$5;continue}
          caml_call3(setter,bucket$0,i$3,d);
          caml_check_bound(hashes,i$3)[1 + i$3] = h;
          return 0}}
      function add(t,d)
       {var h=caml_call1(H[2],d);
        return add_aux(t,set$0,[0,d],h,get_index(t,h))}
      function find_or(t,d,ifnotfound)
       {var
         h=caml_call1(H[2],d),
         index=get_index(t,h),
         bucket=caml_check_bound(t[1],index)[1 + index],
         hashes=caml_check_bound(t[2],index)[1 + index],
         sz=length$5(bucket),
         i=0;
        for(;;)
         {if(sz <= i)return caml_call2(ifnotfound,h,index);
          if(h === caml_check_bound(hashes,i)[1 + i])
           {var match=get_copy(bucket,i);
            if(match)
             {var v=match[1];
              if(caml_call2(H[1],v,d))
               {var match$0=get$1(bucket,i);
                if(match$0){var v$0=match$0[1];return v$0}
                var i$0=i + 1 | 0,i=i$0;
                continue}}
            var i$1=i + 1 | 0,i=i$1;
            continue}
          var i$2=i + 1 | 0,i=i$2;
          continue}}
      function merge(t,d)
       {return find_or
                (t,
                 d,
                 function(h,index){add_aux(t,set$0,[0,d],h,index);return d})}
      function find(t,d)
       {return find_or(t,d,function(h,index){throw Not_found})}
      function find_opt(t,d)
       {var
         h=caml_call1(H[2],d),
         index=get_index(t,h),
         bucket=caml_check_bound(t[1],index)[1 + index],
         hashes=caml_check_bound(t[2],index)[1 + index],
         sz=length$5(bucket),
         i=0;
        for(;;)
         {if(sz <= i)return 0;
          if(h === caml_check_bound(hashes,i)[1 + i])
           {var match=get_copy(bucket,i);
            if(match)
             {var v=match[1];
              if(caml_call2(H[1],v,d))
               {var v$0=get$1(bucket,i);
                if(v$0)return v$0;
                var i$0=i + 1 | 0,i=i$0;
                continue}}
            var i$1=i + 1 | 0,i=i$1;
            continue}
          var i$2=i + 1 | 0,i=i$2;
          continue}}
      function find_shadow(t,d,iffound,ifnotfound)
       {var
         h=caml_call1(H[2],d),
         index=get_index(t,h),
         bucket=caml_check_bound(t[1],index)[1 + index],
         hashes=caml_check_bound(t[2],index)[1 + index],
         sz=length$5(bucket),
         i=0;
        for(;;)
         {if(sz <= i)return ifnotfound;
          if(h === caml_check_bound(hashes,i)[1 + i])
           {var match=get_copy(bucket,i);
            if(match)
             {var v=match[1];
              if(caml_call2(H[1],v,d))return caml_call2(iffound,bucket,i)}
            var i$0=i + 1 | 0,i=i$0;
            continue}
          var i$1=i + 1 | 0,i=i$1;
          continue}}
      function remove(t,d)
       {var _lV_=0;
        return find_shadow(t,d,function(w,i){return set$0(w,i,0)},_lV_)}
      function mem(t,d)
       {var _lU_=0;return find_shadow(t,d,function(w,i){return 1},_lU_)}
      function find_all(t,d)
       {var
         h=caml_call1(H[2],d),
         index=get_index(t,h),
         bucket=caml_check_bound(t[1],index)[1 + index],
         hashes=caml_check_bound(t[2],index)[1 + index],
         sz=length$5(bucket),
         i=0,
         accu=0;
        for(;;)
         {if(sz <= i)return accu;
          if(h === caml_check_bound(hashes,i)[1 + i])
           {var match=get_copy(bucket,i);
            if(match)
             {var v=match[1];
              if(caml_call2(H[1],v,d))
               {var match$0=get$1(bucket,i);
                if(match$0)
                 {var
                   v$0=match$0[1],
                   accu$0=[0,v$0,accu],
                   i$0=i + 1 | 0,
                   i=i$0,
                   accu=accu$0;
                  continue}
                var i$1=i + 1 | 0,i=i$1;
                continue}}
            var i$2=i + 1 | 0,i=i$2;
            continue}
          var i$3=i + 1 | 0,i=i$3;
          continue}}
      function stats(t)
       {var len=t[1].length - 1,lens=map$6(length$5,t[1]);
        sort(caml_int_compare,lens);
        var
         _lM_=0,
         totlen=
          fold_left$1(function(_lT_,_lS_){return _lT_ + _lS_ | 0},_lM_,lens),
         _lN_=len - 1 | 0,
         _lP_=len / 2 | 0,
         _lO_=caml_check_bound(lens,_lN_)[1 + _lN_],
         _lQ_=caml_check_bound(lens,_lP_)[1 + _lP_],
         _lR_=caml_check_bound(lens,0)[1];
        return [0,len,count(t),totlen,_lR_,_lQ_,_lO_]}
      return [0,
              create,
              clear,
              merge,
              add,
              remove,
              find,
              find_opt,
              find_all,
              mem,
              iter,
              fold,
              count,
              stats]}
    var
     Stdlib_weak=
      [0,
       weak_create,
       length$5,
       set$0,
       get$1,
       get_copy,
       check$0,
       fill$2,
       blit$4,
       Make$1];
    caml_register_global(800,Stdlib_weak,"Stdlib__weak");
    function id$0(x){return x}
    var
     String_tag=[248,cst_Stdlib_Format_String_tag,caml_fresh_oo_id(0)],
     size=0,
     unknown=-1;
    function pp_enqueue(state,token)
     {state[13] = state[13] + token[3] | 0;return add(token,state[28])}
    var pp_infinity=1000000010;
    function pp_output_string(state,s)
     {return caml_call3(state[17],s,0,caml_ml_string_length(s))}
    function pp_output_newline(state){return caml_call1(state[19],0)}
    function format_pp_text(state,size,text)
     {state[9] = state[9] - size | 0;
      pp_output_string(state,text);
      state[11] = 0;
      return 0}
    function format_string(state,s)
     {var _lL_=caml_string_notequal(s,cst$67);
      return _lL_?format_pp_text(state,caml_ml_string_length(s),s):_lL_}
    function break_new_line(state,param,width)
     {var after=param[3],offset=param[2],before=param[1];
      format_string(state,before);
      pp_output_newline(state);
      state[11] = 1;
      var
       indent=(state[6] - width | 0) + offset | 0,
       real_indent=min(state[8],indent);
      state[10] = real_indent;
      state[9] = state[6] - state[10] | 0;
      caml_call1(state[21],state[10]);
      return format_string(state,after)}
    function break_line(state,width){return break_new_line(state,_cd_,width)}
    function break_same_line(state,param)
     {var after=param[3],width=param[2],before=param[1];
      format_string(state,before);
      state[9] = state[9] - width | 0;
      caml_call1(state[20],width);
      return format_string(state,after)}
    function advance_left(state)
     {for(;;)
       {var match$12=peek_opt(state[28]);
        if(match$12)
         {var
           match$13=match$12[1],
           size$0=match$13[1],
           length$0=match$13[3],
           token=match$13[2],
           pending_count=state[13] - state[12] | 0,
           _lJ_=0 <= size$0?1:0,
           _lK_=_lJ_ || (state[9] <= pending_count?1:0);
          if(_lK_)
           {take(state[28]);
            var size$1=0 <= size$0?size$0:pp_infinity;
            if(typeof token === "number")
             switch(token)
              {case 0:
                var match$3=top_opt(state[3]);
                if(match$3)
                 {var
                   match$4=match$3[1],
                   tabs=match$4[1],
                   add_tab=
                    function(n,ls)
                     {if(ls)
                       {var l=ls[2],x=ls[1];
                        return caml_lessthan(n,x)?[0,n,ls]:[0,x,add_tab(n,l)]}
                      return [0,n,0]};
                  tabs[1] = add_tab(state[6] - state[9] | 0,tabs[1])}
                break;
               case 1:pop_opt(state[2]);break;
               case 2:pop_opt(state[3]);break;
               case 3:
                var match$5=top_opt(state[2]);
                if(match$5)
                 {var match$6=match$5[1],width$0=match$6[2];
                  break_line(state,width$0)}
                else
                 pp_output_newline(state);
                break;
               case 4:
                if(state[10] !== (state[6] - state[9] | 0))
                 {var match$1=take_opt(state[28]);
                  if(match$1)
                   {var match$2=match$1[1],size=match$2[1],length=match$2[3];
                    state[12] = state[12] - length | 0;
                    state[9] = state[9] + size | 0}}
                break;
               default:
                var match$7=pop_opt(state[5]);
                if(match$7)
                 {var
                   tag_name=match$7[1],
                   marker=caml_call1(state[25],tag_name);
                  pp_output_string(state,marker)}}
            else
             switch(token[0])
              {case 0:var s=token[1];format_pp_text(state,size$1,s);break;
               case 1:
                var
                 breaks=token[2],
                 fits=token[1],
                 off=breaks[2],
                 before=breaks[1],
                 match$8=top_opt(state[2]);
                if(match$8)
                 {var
                   match$9=match$8[1],
                   width$1=match$9[2],
                   box_type$0=match$9[1];
                  switch(box_type$0)
                   {case 0:break_same_line(state,fits);break;
                    case 1:break_new_line(state,breaks,width$1);break;
                    case 2:break_new_line(state,breaks,width$1);break;
                    case 3:
                     if(state[9] < (size$1 + caml_ml_string_length(before) | 0))
                      break_new_line(state,breaks,width$1);
                     else
                      break_same_line(state,fits);
                     break;
                    case 4:
                     if(state[11])
                      break_same_line(state,fits);
                     else
                      if(state[9] < (size$1 + caml_ml_string_length(before) | 0))
                       break_new_line(state,breaks,width$1);
                      else
                       if(((state[6] - width$1 | 0) + off | 0) < state[10])
                        break_new_line(state,breaks,width$1);
                       else
                        break_same_line(state,fits);
                     break;
                    default:break_same_line(state,fits)}}
                break;
               case 2:
                var
                 off$0=token[2],
                 n=token[1],
                 insertion_point=state[6] - state[9] | 0,
                 match$10=top_opt(state[3]);
                if(match$10)
                 {var match$11=match$10[1],tabs$0=match$11[1],_lH_=tabs$0[1];
                  if(_lH_)
                   {var first=_lH_[1],param=tabs$0[1];
                    for(;;)
                     {if(param)
                       {var tail=param[2],head=param[1];
                        if(! (insertion_point <= head)){var param=tail;continue}
                        var _lI_=head}
                      else
                       var _lI_=first;
                      var tab=_lI_;
                      break}}
                  else
                   var tab=insertion_point;
                  var offset=tab - insertion_point | 0;
                  if(0 <= offset)
                   break_same_line(state,[0,cst$69,offset + n | 0,cst$68]);
                  else
                   break_new_line
                    (state,[0,cst$71,tab + off$0 | 0,cst$70],state[6])}
                break;
               case 3:
                var
                 ty=token[2],
                 off$1=token[1],
                 insertion_point$0=state[6] - state[9] | 0;
                if(state[8] < insertion_point$0)
                 {var match=top_opt(state[2]);
                  if(match)
                   {var match$0=match[1],width=match$0[2],box_type=match$0[1];
                    if(state[9] < width)
                     {var switcher=box_type - 1 | 0;
                      if(! (3 < switcher >>> 0))break_line(state,width)}}
                  else
                   pp_output_newline(state)}
                var
                 width$2=state[9] - off$1 | 0,
                 box_type$1=1 === ty?1:state[9] < size$1?ty:5;
                push([0,box_type$1,width$2],state[2]);
                break;
               case 4:var tbox=token[1];push(tbox,state[3]);break;
               default:
                var
                 tag_name$0=token[1],
                 marker$0=caml_call1(state[24],tag_name$0);
                pp_output_string(state,marker$0);
                push(tag_name$0,state[5])}
            state[12] = length$0 + state[12] | 0;
            continue}
          return _lK_}
        return 0}}
    function enqueue_advance(state,tok)
     {pp_enqueue(state,tok);return advance_left(state)}
    function enqueue_string_as(state,size,s)
     {return enqueue_advance(state,[0,size,[0,s],size])}
    function initialize_scan_stack(stack)
     {clear(stack);
      var queue_elem=[0,unknown,_ce_,0];
      return push([0,-1,queue_elem],stack)}
    function set_size(state,ty)
     {var match=top_opt(state[1]);
      if(match)
       {var
         match$0=match[1],
         queue_elem=match$0[2],
         left_total=match$0[1],
         _lE_=queue_elem[1];
        if(left_total < state[12])return initialize_scan_stack(state[1]);
        var _lF_=queue_elem[2];
        if(typeof _lF_ !== "number")
         switch(_lF_[0])
          {case 3:
            var _lG_=1 - ty;
            return _lG_
                    ?(queue_elem[1] = state[13] + _lE_ | 0,pop_opt(state[1]),0)
                    :_lG_;
           case 1:
           case 2:
            return ty
                    ?(queue_elem[1] = state[13] + _lE_ | 0,pop_opt(state[1]),0)
                    :ty
           }
        return 0}
      return 0}
    function scan_push(state,b,token)
     {pp_enqueue(state,token);
      if(b)set_size(state,1);
      var elem=[0,state[13],token];
      return push(elem,state[1])}
    function pp_open_box_gen(state,indent,br_ty)
     {state[14] = state[14] + 1 | 0;
      if(state[14] < state[15])
       {var size=- state[13] | 0,elem=[0,size,[3,indent,br_ty],0];
        return scan_push(state,0,elem)}
      var _lC_=state[14] === state[15]?1:0;
      if(_lC_)
       {var _lD_=state[16];
        return enqueue_string_as(state,caml_ml_string_length(_lD_),_lD_)}
      return _lC_}
    function pp_close_box(state,param)
     {var _lA_=1 < state[14]?1:0;
      if(_lA_)
       {if(state[14] < state[15])
         {pp_enqueue(state,[0,size,1,0]);set_size(state,1);set_size(state,0)}
        state[14] = state[14] - 1 | 0;
        var _lB_=0}
      else
       var _lB_=_lA_;
      return _lB_}
    function pp_open_stag(state,tag_name)
     {if(state[22]){push(tag_name,state[4]);caml_call1(state[26],tag_name)}
      var _lz_=state[23];
      if(_lz_)
       {var token=[5,tag_name];return pp_enqueue(state,[0,size,token,0])}
      return _lz_}
    function pp_close_stag(state,param)
     {if(state[23])pp_enqueue(state,[0,size,5,0]);
      var _lx_=state[22];
      if(_lx_)
       {var match=pop_opt(state[4]);
        if(match){var tag_name=match[1];return caml_call1(state[27],tag_name)}
        var _ly_=0}
      else
       var _ly_=_lx_;
      return _ly_}
    function pp_open_tag(state,s){return pp_open_stag(state,[0,String_tag,s])}
    function pp_close_tag(state,param){return pp_close_stag(state,0)}
    function pp_set_print_tags(state,b){state[22] = b;return 0}
    function pp_set_mark_tags(state,b){state[23] = b;return 0}
    function pp_get_print_tags(state,param){return state[22]}
    function pp_get_mark_tags(state,param){return state[23]}
    function pp_set_tags(state,b)
     {pp_set_print_tags(state,b);return pp_set_mark_tags(state,b)}
    function pp_get_formatter_stag_function(state,param)
     {return [0,state[24],state[25],state[26],state[27]]}
    function pp_set_formatter_stag_function(state,param)
     {var pct=param[4],pot=param[3],mct=param[2],mot=param[1];
      state[24] = mot;
      state[25] = mct;
      state[26] = pot;
      state[27] = pct;
      return 0}
    function pp_rinit(state)
     {state[12] = 1;
      state[13] = 1;
      clear$0(state[28]);
      initialize_scan_stack(state[1]);
      clear(state[2]);
      clear(state[3]);
      clear(state[4]);
      clear(state[5]);
      state[10] = 0;
      state[14] = 0;
      state[9] = state[6];
      return pp_open_box_gen(state,0,3)}
    function pp_flush_queue(state,b)
     {var _lw_=state[4];
      iter$7(function(param){return pp_close_tag(state,0)},_lw_);
      for(;;)
       {if(1 < state[14]){pp_close_box(state,0);continue}
        state[13] = pp_infinity;
        advance_left(state);
        if(b)pp_output_newline(state);
        return pp_rinit(state)}}
    function pp_print_as_size(state,size,s)
     {var _lv_=state[14] < state[15]?1:0;
      return _lv_?enqueue_string_as(state,size,s):_lv_}
    function pp_print_as(state,isize,s)
     {return pp_print_as_size(state,isize,s)}
    function pp_print_string(state,s)
     {return pp_print_as(state,caml_ml_string_length(s),s)}
    function pp_print_int(state,i)
     {return pp_print_string(state,caml_string_of_jsbytes("" + i))}
    function pp_print_float(state,f)
     {return pp_print_string(state,to_string(f))}
    function pp_print_bool(state,b)
     {return pp_print_string(state,string_of_bool(b))}
    function pp_print_char(state,c){return pp_print_as(state,1,make$1(1,c))}
    function pp_open_hbox(state,param){return pp_open_box_gen(state,0,0)}
    function pp_open_vbox(state,indent)
     {return pp_open_box_gen(state,indent,1)}
    function pp_open_hvbox(state,indent)
     {return pp_open_box_gen(state,indent,2)}
    function pp_open_hovbox(state,indent)
     {return pp_open_box_gen(state,indent,3)}
    function pp_open_box(state,indent){return pp_open_box_gen(state,indent,4)}
    function pp_print_newline(state,param)
     {pp_flush_queue(state,1);return caml_call1(state[18],0)}
    function pp_print_flush(state,param)
     {pp_flush_queue(state,0);return caml_call1(state[18],0)}
    function pp_force_newline(state,param)
     {var _lu_=state[14] < state[15]?1:0;
      return _lu_?enqueue_advance(state,[0,size,3,0]):_lu_}
    function pp_print_if_newline(state,param)
     {var _lt_=state[14] < state[15]?1:0;
      return _lt_?enqueue_advance(state,[0,size,4,0]):_lt_}
    function pp_print_custom_break(state,fits,breaks)
     {var
       after=fits[3],
       width=fits[2],
       before=fits[1],
       _ls_=state[14] < state[15]?1:0;
      if(_ls_)
       {var
         size=- state[13] | 0,
         token=[1,fits,breaks],
         length=
          (caml_ml_string_length(before) + width | 0)
          +
          caml_ml_string_length(after)
          |
          0,
         elem=[0,size,token,length];
        return scan_push(state,1,elem)}
      return _ls_}
    function pp_print_break(state,width,offset)
     {return pp_print_custom_break
              (state,[0,cst$75,width,cst$74],[0,cst$73,offset,cst$72])}
    function pp_print_space(state,param){return pp_print_break(state,1,0)}
    function pp_print_cut(state,param){return pp_print_break(state,0,0)}
    function pp_open_tbox(state,param)
     {state[14] = state[14] + 1 | 0;
      var _lr_=state[14] < state[15]?1:0;
      if(_lr_)
       {var elem=[0,size,[4,[0,[0,0]]],0];return enqueue_advance(state,elem)}
      return _lr_}
    function pp_close_tbox(state,param)
     {var _lo_=1 < state[14]?1:0;
      if(_lo_)
       {var _lp_=state[14] < state[15]?1:0;
        if(_lp_)
         {var elem=[0,size,2,0];
          enqueue_advance(state,elem);
          state[14] = state[14] - 1 | 0;
          var _lq_=0}
        else
         var _lq_=_lp_}
      else
       var _lq_=_lo_;
      return _lq_}
    function pp_print_tbreak(state,width,offset)
     {var _ln_=state[14] < state[15]?1:0;
      if(_ln_)
       {var size=- state[13] | 0,elem=[0,size,[2,width,offset],width];
        return scan_push(state,1,elem)}
      return _ln_}
    function pp_print_tab(state,param){return pp_print_tbreak(state,0,0)}
    function pp_set_tab(state,param)
     {var _lm_=state[14] < state[15]?1:0;
      if(_lm_){var elem=[0,size,0,0];return enqueue_advance(state,elem)}
      return _lm_}
    function pp_set_max_boxes(state,n)
     {var _lk_=1 < n?1:0,_ll_=_lk_?(state[15] = n,0):_lk_;return _ll_}
    function pp_get_max_boxes(state,param){return state[15]}
    function pp_over_max_boxes(state,param)
     {return state[14] === state[15]?1:0}
    function pp_set_ellipsis_text(state,s){state[16] = s;return 0}
    function pp_get_ellipsis_text(state,param){return state[16]}
    function pp_limit(n){return n < 1000000010?n:1000000009}
    function pp_set_max_indent(state,n$0)
     {var _lj_=1 < n$0?1:0;
      if(_lj_)
       {var n$1=state[6] - n$0 | 0,_li_=1 <= n$1?1:0;
        if(_li_)
         {var n=pp_limit(n$1);
          state[7] = n;
          state[8] = state[6] - state[7] | 0;
          return pp_rinit(state)}
        return _li_}
      return _lj_}
    function pp_get_max_indent(state,param){return state[8]}
    function pp_set_margin(state,n)
     {var _lh_=1 <= n?1:0;
      if(_lh_)
       {var n$0=pp_limit(n);
        state[6] = n$0;
        var
         new_max_indent=
          state[8] <= state[6]
           ?state[8]
           :max(max(state[6] - state[7] | 0,state[6] / 2 | 0),1);
        return pp_set_max_indent(state,new_max_indent)}
      return _lh_}
    function validate_geometry(param)
     {var margin=param[2],max_indent=param[1];
      return 2 <= max_indent?margin <= max_indent?_cf_:_cg_:_ch_}
    function check_geometry(geometry)
     {var match=validate_geometry(geometry);return 0 === match[0]?1:0}
    function pp_get_margin(state,param){return state[6]}
    function pp_set_full_geometry(state,param)
     {var margin=param[2],max_indent=param[1];
      pp_set_margin(state,margin);
      pp_set_max_indent(state,max_indent);
      return 0}
    function pp_set_geometry(state,max_indent,margin)
     {var geometry=[0,max_indent,margin],match=validate_geometry(geometry);
      if(0 === match[0])return pp_set_full_geometry(state,geometry);
      var msg=match[1];
      throw [0,Invalid_argument,symbol(cst_Format_pp_set_geometry,msg)]}
    function pp_safe_set_geometry(state,max_indent,margin)
     {var geometry=[0,max_indent,margin],match=validate_geometry(geometry);
      return 0 === match[0]?pp_set_full_geometry(state,geometry):0}
    function pp_get_geometry(state,param){return [0,state[8],state[6]]}
    function pp_update_geometry(state,update)
     {var geometry=pp_get_geometry(state,0);
      return pp_set_full_geometry(state,caml_call1(update,geometry))}
    function pp_set_formatter_out_functions(state,param)
     {var j=param[5],i=param[4],h=param[3],g=param[2],f=param[1];
      state[17] = f;
      state[18] = g;
      state[19] = h;
      state[20] = i;
      state[21] = j;
      return 0}
    function pp_get_formatter_out_functions(state,param)
     {return [0,state[17],state[18],state[19],state[20],state[21]]}
    function pp_set_formatter_output_functi(state,f,g)
     {state[17] = f;state[18] = g;return 0}
    function pp_get_formatter_output_functi(state,param)
     {return [0,state[17],state[18]]}
    function display_newline(state,param)
     {return caml_call3(state[17],cst$76,0,1)}
    var blank_line=make$1(80,32);
    function display_indent(state,n)
     {var n$0=n;
      for(;;)
       {var _lg_=0 < n$0?1:0;
        if(_lg_)
         {if(80 < n$0)
           {caml_call3(state[17],blank_line,0,80);
            var n$1=n$0 - 80 | 0,n$0=n$1;
            continue}
          return caml_call3(state[17],blank_line,0,n$0)}
        return _lg_}}
    function pp_set_formatter_out_channel(state,oc)
     {state[17]
      =
      function(_ld_,_le_,_lf_){return output_substring(oc,_ld_,_le_,_lf_)};
      state[18] = function(param){return caml_ml_flush(oc)};
      state[19] = function(_lc_){return display_newline(state,_lc_)};
      state[20] = function(_lb_){return display_indent(state,_lb_)};
      state[21] = function(_la_){return display_indent(state,_la_)};
      return 0}
    function default_pp_mark_open_tag(param)
     {if(param[1] === String_tag)
       {var s=param[2];return symbol(cst$78,symbol(s,cst$77))}
      return cst$79}
    function default_pp_mark_close_tag(param)
     {if(param[1] === String_tag)
       {var s=param[2];return symbol(cst$81,symbol(s,cst$80))}
      return cst$82}
    function default_pp_print_open_tag(_k$_){return 0}
    function default_pp_print_close_tag(_k__){return 0}
    function pp_make_formatter(f,g,h,i,j)
     {var pp_queue=create$1(0),sys_tok=[0,unknown,_ci_,0];
      add(sys_tok,pp_queue);
      var scan_stack=create$0(0);
      initialize_scan_stack(scan_stack);
      push([0,1,sys_tok],scan_stack);
      var _k7_=create$0(0),_k8_=create$0(0),_k9_=create$0(0);
      return [0,
              scan_stack,
              create$0(0),
              _k9_,
              _k8_,
              _k7_,
              78,
              10,
              68,
              78,
              0,
              1,
              1,
              1,
              1,
              max_int,
              cst$83,
              f,
              g,
              h,
              i,
              j,
              0,
              0,
              default_pp_mark_open_tag,
              default_pp_mark_close_tag,
              default_pp_print_open_tag,
              default_pp_print_close_tag,
              pp_queue]}
    function formatter_of_out_functions(out_funs)
     {return pp_make_formatter
              (out_funs[1],out_funs[2],out_funs[3],out_funs[4],out_funs[5])}
    function make_formatter(output,flush)
     {function _kZ_(_k6_){return 0}
      function _k0_(_k5_){return 0}
      var
       ppf=
        pp_make_formatter(output,flush,function(_k4_){return 0},_k0_,_kZ_);
      ppf[19] = function(_k3_){return display_newline(ppf,_k3_)};
      ppf[20] = function(_k2_){return display_indent(ppf,_k2_)};
      ppf[21] = function(_k1_){return display_indent(ppf,_k1_)};
      return ppf}
    function formatter_of_out_channel(oc)
     {function _kV_(param){return caml_ml_flush(oc)}
      return make_formatter
              (function(_kW_,_kX_,_kY_)
                {return output_substring(oc,_kW_,_kX_,_kY_)},
               _kV_)}
    function formatter_of_buffer(b)
     {function _kQ_(_kU_){return 0}
      return make_formatter
              (function(_kR_,_kS_,_kT_)
                {return add_substring(b,_kR_,_kS_,_kT_)},
               _kQ_)}
    var pp_buffer_size=512;
    function pp_make_buffer(param){return create$2(pp_buffer_size)}
    var
     stdbuf=pp_make_buffer(0),
     std_formatter=formatter_of_out_channel(stdout),
     err_formatter=formatter_of_out_channel(stderr),
     str_formatter=formatter_of_buffer(stdbuf);
    function flush_buffer_formatter(buf,ppf)
     {pp_flush_queue(ppf,0);var s=contents(buf);reset(buf);return s}
    function flush_str_formatter(param)
     {return flush_buffer_formatter(stdbuf,str_formatter)}
    function make_symbolic_output_buffer(param){return [0,0]}
    function clear_symbolic_output_buffer(sob){sob[1] = 0;return 0}
    function get_symbolic_output_buffer(sob){return rev(sob[1])}
    function flush_symbolic_output_buffer(sob)
     {var items=get_symbolic_output_buffer(sob);
      clear_symbolic_output_buffer(sob);
      return items}
    function add_symbolic_output_item(sob,item)
     {sob[1] = [0,item,sob[1]];return 0}
    function formatter_of_symbolic_output_b(sob)
     {function f(s,i,n){return add_symbolic_output_item(sob,[0,sub$0(s,i,n)])}
      function g(_kP_){return add_symbolic_output_item(sob,0)}
      function h(_kO_){return add_symbolic_output_item(sob,1)}
      function i(n){return add_symbolic_output_item(sob,[1,n])}
      function j(n){return add_symbolic_output_item(sob,[2,n])}
      return pp_make_formatter(f,g,h,i,j)}
    function open_hbox(_kN_){return pp_open_hbox(std_formatter,_kN_)}
    function open_vbox(_kM_){return pp_open_vbox(std_formatter,_kM_)}
    function open_hvbox(_kL_){return pp_open_hvbox(std_formatter,_kL_)}
    function open_hovbox(_kK_){return pp_open_hovbox(std_formatter,_kK_)}
    function open_box(_kJ_){return pp_open_box(std_formatter,_kJ_)}
    function close_box(_kI_){return pp_close_box(std_formatter,_kI_)}
    function open_tag(_kH_){return pp_open_tag(std_formatter,_kH_)}
    function close_tag(_kG_){return pp_close_tag(std_formatter,_kG_)}
    function open_stag(_kF_){return pp_open_stag(std_formatter,_kF_)}
    function close_stag(_kE_){return pp_close_stag(std_formatter,_kE_)}
    function print_as(_kC_,_kD_){return pp_print_as(std_formatter,_kC_,_kD_)}
    function print_string$0(_kB_){return pp_print_string(std_formatter,_kB_)}
    function print_int$0(_kA_){return pp_print_int(std_formatter,_kA_)}
    function print_float$0(_kz_){return pp_print_float(std_formatter,_kz_)}
    function print_char$0(_ky_){return pp_print_char(std_formatter,_ky_)}
    function print_bool(_kx_){return pp_print_bool(std_formatter,_kx_)}
    function print_break(_kv_,_kw_)
     {return pp_print_break(std_formatter,_kv_,_kw_)}
    function print_cut(_ku_){return pp_print_cut(std_formatter,_ku_)}
    function print_space(_kt_){return pp_print_space(std_formatter,_kt_)}
    function force_newline(_ks_){return pp_force_newline(std_formatter,_ks_)}
    function print_flush(_kr_){return pp_print_flush(std_formatter,_kr_)}
    function print_newline$0(_kq_)
     {return pp_print_newline(std_formatter,_kq_)}
    function print_if_newline(_kp_)
     {return pp_print_if_newline(std_formatter,_kp_)}
    function open_tbox(_ko_){return pp_open_tbox(std_formatter,_ko_)}
    function close_tbox(_kn_){return pp_close_tbox(std_formatter,_kn_)}
    function print_tbreak(_kl_,_km_)
     {return pp_print_tbreak(std_formatter,_kl_,_km_)}
    function set_tab(_kk_){return pp_set_tab(std_formatter,_kk_)}
    function print_tab(_kj_){return pp_print_tab(std_formatter,_kj_)}
    function set_margin(_ki_){return pp_set_margin(std_formatter,_ki_)}
    function get_margin(_kh_){return std_formatter[6]}
    function set_max_indent(_kg_)
     {return pp_set_max_indent(std_formatter,_kg_)}
    function get_max_indent(_kf_){return std_formatter[8]}
    function set_geometry(_kd_,_ke_)
     {return pp_set_geometry(std_formatter,_kd_,_ke_)}
    function safe_set_geometry(_kb_,_kc_)
     {return pp_safe_set_geometry(std_formatter,_kb_,_kc_)}
    function get_geometry(_ka_){return pp_get_geometry(std_formatter,_ka_)}
    function update_geometry(_j$_)
     {return pp_update_geometry(std_formatter,_j$_)}
    function set_max_boxes(_j__){return pp_set_max_boxes(std_formatter,_j__)}
    function get_max_boxes(_j9_){return std_formatter[15]}
    function over_max_boxes(_j8_)
     {return pp_over_max_boxes(std_formatter,_j8_)}
    function set_ellipsis_text(_j7_)
     {return pp_set_ellipsis_text(std_formatter,_j7_)}
    function get_ellipsis_text(_j6_){return std_formatter[16]}
    function set_formatter_out_channel(_j5_)
     {return pp_set_formatter_out_channel(std_formatter,_j5_)}
    function set_formatter_out_functions(_j4_)
     {return pp_set_formatter_out_functions(std_formatter,_j4_)}
    function get_formatter_out_functions(_j3_)
     {return pp_get_formatter_out_functions(std_formatter,_j3_)}
    function set_formatter_output_functions(_j1_,_j2_)
     {return pp_set_formatter_output_functi(std_formatter,_j1_,_j2_)}
    function get_formatter_output_functions(_j0_)
     {return pp_get_formatter_output_functi(std_formatter,_j0_)}
    function set_formatter_stag_functions(_jZ_)
     {return pp_set_formatter_stag_function(std_formatter,_jZ_)}
    function get_formatter_stag_functions(_jY_)
     {return pp_get_formatter_stag_function(std_formatter,_jY_)}
    function set_print_tags(_jX_)
     {return pp_set_print_tags(std_formatter,_jX_)}
    function get_print_tags(_jW_){return std_formatter[22]}
    function set_mark_tags(_jV_){return pp_set_mark_tags(std_formatter,_jV_)}
    function get_mark_tags(_jU_){return std_formatter[23]}
    function set_tags(_jT_){return pp_set_tags(std_formatter,_jT_)}
    function pp_print_list(opt,pp_v,ppf,param)
     {var opt$0=opt,param$0=param;
      for(;;)
       {if(opt$0)var sth=opt$0[1],pp_sep=sth;else var pp_sep=pp_print_cut;
        if(param$0)
         {var _jS_=param$0[1];
          if(param$0[2])
           {var vs=param$0[2];
            caml_call2(pp_v,ppf,_jS_);
            caml_call2(pp_sep,ppf,0);
            var opt$1=[0,pp_sep],opt$0=opt$1,param$0=vs;
            continue}
          return caml_call2(pp_v,ppf,_jS_)}
        return 0}}
    function pp_print_seq(opt,pp_v,ppf,seq$1)
     {if(opt)var sth=opt[1],pp_sep=sth;else var pp_sep=pp_print_cut;
      var match$0=caml_call1(seq$1,0);
      if(match$0)
       {var seq$2=match$0[2],v$0=match$0[1];
        caml_call2(pp_v,ppf,v$0);
        var seq=seq$2;
        for(;;)
         {var match=caml_call1(seq,0);
          if(match)
           {var seq$0=match[2],v=match[1];
            caml_call2(pp_sep,ppf,0);
            caml_call2(pp_v,ppf,v);
            var seq=seq$0;
            continue}
          return 0}}
      return 0}
    function pp_print_text(ppf,s)
     {var len=caml_ml_string_length(s),left=[0,0],right=[0,0];
      function flush(param)
       {pp_print_string(ppf,sub$0(s,left[1],right[1] - left[1] | 0));
        right[1]++;
        left[1] = right[1];
        return 0}
      for(;;)
       {if(right[1] !== len)
         {var match=caml_string_get(s,right[1]);
          if(10 === match)
           {flush(0);pp_force_newline(ppf,0)}
          else
           if(32 === match){flush(0);pp_print_space(ppf,0)}else right[1]++;
          continue}
        var _jR_=left[1] !== len?1:0;
        return _jR_?flush(0):_jR_}}
    function pp_print_option(opt,pp_v,ppf,param)
     {if(opt)
       var sth=opt[1],none=sth;
      else
       var none=function(param,_jQ_){return 0};
      if(param){var v=param[1];return caml_call2(pp_v,ppf,v)}
      return caml_call2(none,ppf,0)}
    function pp_print_result(ok,error,ppf,param)
     {if(0 === param[0]){var v=param[1];return caml_call2(ok,ppf,v)}
      var e=param[1];
      return caml_call2(error,ppf,e)}
    function compute_tag(output,tag_acc)
     {var buf=create$2(16),ppf=formatter_of_buffer(buf);
      caml_call2(output,ppf,tag_acc);
      pp_print_flush(ppf,0);
      var len=buf[2];
      return 2 <= len?sub$3(buf,1,len - 2 | 0):contents(buf)}
    function output_formatting_lit(ppf,fmting_lit)
     {if(typeof fmting_lit === "number")
       switch(fmting_lit)
        {case 0:return pp_close_box(ppf,0);
         case 1:return pp_close_tag(ppf,0);
         case 2:return pp_print_flush(ppf,0);
         case 3:return pp_force_newline(ppf,0);
         case 4:return pp_print_newline(ppf,0);
         case 5:return pp_print_char(ppf,64);
         default:return pp_print_char(ppf,37)}
      else
       switch(fmting_lit[0])
        {case 0:
          var offset=fmting_lit[3],width=fmting_lit[2];
          return pp_print_break(ppf,width,offset);
         case 1:return 0;
         default:
          var c=fmting_lit[1];
          pp_print_char(ppf,64);
          return pp_print_char(ppf,c)}}
    function output_acc$0(ppf,acc)
     {var switch$0=0;
      if(typeof acc === "number")
       return 0;
      else
       switch(acc[0])
        {case 0:
          var f=acc[2],p=acc[1];
          output_acc$0(ppf,p);
          return output_formatting_lit(ppf,f);
         case 1:
          var _jG_=acc[2],_jH_=acc[1];
          if(0 === _jG_[0])
           {var acc$0=_jG_[1];
            output_acc$0(ppf,_jH_);
            return pp_open_stag
                    (ppf,[0,String_tag,compute_tag(output_acc$0,acc$0)])}
          var acc$1=_jG_[1];
          output_acc$0(ppf,_jH_);
          var
           match=open_box_of_string(compute_tag(output_acc$0,acc$1)),
           bty=match[2],
           indent=match[1];
          return pp_open_box_gen(ppf,indent,bty);
         case 2:
          var _jI_=acc[1],switch$1=0;
          if(typeof _jI_ !== "number" && 0 === _jI_[0])
           {var _jJ_=_jI_[2],switch$2=0;
            if(typeof _jJ_ !== "number" && 1 === _jJ_[0])
             {var s$0=acc[2],size=_jJ_[2],p$1=_jI_[1];
              switch$1 = 1;
              switch$2 = 1}}
          if(! switch$1){var s=acc[2],p$0=_jI_;switch$0 = 2}
          break;
         case 3:
          var _jK_=acc[1],switch$3=0;
          if(typeof _jK_ !== "number" && 0 === _jK_[0])
           {var _jL_=_jK_[2],switch$4=0;
            if(typeof _jL_ !== "number" && 1 === _jL_[0])
             {var c$0=acc[2],size$0=_jL_[2],p$3=_jK_[1];
              switch$0 = 1;
              switch$3 = 1;
              switch$4 = 1}}
          if(! switch$3){var c=acc[2],p$2=_jK_;switch$0 = 3}
          break;
         case 4:
          var _jM_=acc[1],switch$5=0;
          if(typeof _jM_ !== "number" && 0 === _jM_[0])
           {var _jN_=_jM_[2],switch$6=0;
            if(typeof _jN_ !== "number" && 1 === _jN_[0])
             {var s$0=acc[2],size=_jN_[2],p$1=_jM_[1];
              switch$5 = 1;
              switch$6 = 1}}
          if(! switch$5){var s=acc[2],p$0=_jM_;switch$0 = 2}
          break;
         case 5:
          var _jO_=acc[1],switch$7=0;
          if(typeof _jO_ === "number" || ! (0 === _jO_[0]))
           switch$7 = 1;
          else
           {var _jP_=_jO_[2],switch$8=0;
            if(typeof _jP_ !== "number" && 1 === _jP_[0])
             {var c$0=acc[2],size$0=_jP_[2],p$3=_jO_[1];
              switch$0 = 1;
              switch$8 = 1}
            if(! switch$8)switch$7 = 1}
          if(switch$7){var c=acc[2],p$2=_jO_;switch$0 = 3}
          break;
         case 6:
          var f$0=acc[2],p$4=acc[1];
          output_acc$0(ppf,p$4);
          return caml_call1(f$0,ppf);
         case 7:
          var p$5=acc[1];output_acc$0(ppf,p$5);return pp_print_flush(ppf,0);
         default:
          var msg=acc[2],p$6=acc[1];
          output_acc$0(ppf,p$6);
          return invalid_arg(msg)}
      switch(switch$0)
       {case 0:output_acc$0(ppf,p$1);return pp_print_as_size(ppf,size,s$0);
        case 1:
         output_acc$0(ppf,p$3);
         return pp_print_as_size(ppf,size$0,make$1(1,c$0));
        case 2:output_acc$0(ppf,p$0);return pp_print_string(ppf,s);
        default:output_acc$0(ppf,p$2);return pp_print_char(ppf,c)}}
    function strput_acc$0(ppf,acc)
     {var switch$0=0;
      if(typeof acc === "number")
       return 0;
      else
       switch(acc[0])
        {case 0:
          var f=acc[2],p=acc[1];
          strput_acc$0(ppf,p);
          return output_formatting_lit(ppf,f);
         case 1:
          var _ju_=acc[2],_jv_=acc[1];
          if(0 === _ju_[0])
           {var acc$0=_ju_[1];
            strput_acc$0(ppf,_jv_);
            return pp_open_stag
                    (ppf,[0,String_tag,compute_tag(strput_acc$0,acc$0)])}
          var acc$1=_ju_[1];
          strput_acc$0(ppf,_jv_);
          var
           match=open_box_of_string(compute_tag(strput_acc$0,acc$1)),
           bty=match[2],
           indent=match[1];
          return pp_open_box_gen(ppf,indent,bty);
         case 2:
          var _jw_=acc[1],switch$1=0;
          if(typeof _jw_ !== "number" && 0 === _jw_[0])
           {var _jx_=_jw_[2],switch$2=0;
            if(typeof _jx_ !== "number" && 1 === _jx_[0])
             {var s$0=acc[2],size=_jx_[2],p$1=_jw_[1];
              switch$1 = 1;
              switch$2 = 1}}
          if(! switch$1){var s=acc[2],p$0=_jw_;switch$0 = 2}
          break;
         case 3:
          var _jy_=acc[1],switch$3=0;
          if(typeof _jy_ !== "number" && 0 === _jy_[0])
           {var _jz_=_jy_[2],switch$4=0;
            if(typeof _jz_ !== "number" && 1 === _jz_[0])
             {var c$0=acc[2],size$0=_jz_[2],p$3=_jy_[1];
              switch$0 = 1;
              switch$3 = 1;
              switch$4 = 1}}
          if(! switch$3){var c=acc[2],p$2=_jy_;switch$0 = 3}
          break;
         case 4:
          var _jA_=acc[1],switch$5=0;
          if(typeof _jA_ !== "number" && 0 === _jA_[0])
           {var _jB_=_jA_[2],switch$6=0;
            if(typeof _jB_ !== "number" && 1 === _jB_[0])
             {var s$0=acc[2],size=_jB_[2],p$1=_jA_[1];
              switch$5 = 1;
              switch$6 = 1}}
          if(! switch$5){var s=acc[2],p$0=_jA_;switch$0 = 2}
          break;
         case 5:
          var _jC_=acc[1],switch$7=0;
          if(typeof _jC_ === "number" || ! (0 === _jC_[0]))
           switch$7 = 1;
          else
           {var _jD_=_jC_[2],switch$8=0;
            if(typeof _jD_ !== "number" && 1 === _jD_[0])
             {var c$0=acc[2],size$0=_jD_[2],p$3=_jC_[1];
              switch$0 = 1;
              switch$8 = 1}
            if(! switch$8)switch$7 = 1}
          if(switch$7){var c=acc[2],p$2=_jC_;switch$0 = 3}
          break;
         case 6:
          var _jE_=acc[1];
          if(typeof _jE_ !== "number" && 0 === _jE_[0])
           {var _jF_=_jE_[2];
            if(typeof _jF_ !== "number" && 1 === _jF_[0])
             {var f$1=acc[2],size$1=_jF_[2],p$4=_jE_[1];
              strput_acc$0(ppf,p$4);
              return pp_print_as_size(ppf,size$1,caml_call1(f$1,0))}}
          var f$0=acc[2];
          strput_acc$0(ppf,_jE_);
          return pp_print_string(ppf,caml_call1(f$0,0));
         case 7:
          var p$5=acc[1];strput_acc$0(ppf,p$5);return pp_print_flush(ppf,0);
         default:
          var msg=acc[2],p$6=acc[1];
          strput_acc$0(ppf,p$6);
          return invalid_arg(msg)}
      switch(switch$0)
       {case 0:strput_acc$0(ppf,p$1);return pp_print_as_size(ppf,size,s$0);
        case 1:
         strput_acc$0(ppf,p$3);
         return pp_print_as_size(ppf,size$0,make$1(1,c$0));
        case 2:strput_acc$0(ppf,p$0);return pp_print_string(ppf,s);
        default:strput_acc$0(ppf,p$2);return pp_print_char(ppf,c)}}
    function kfprintf$0(k,ppf,param)
     {var fmt=param[1],_jt_=0;
      return make_printf
              (function(acc){output_acc$0(ppf,acc);return caml_call1(k,ppf)},
               _jt_,
               fmt)}
    function ikfprintf$0(k,ppf,param)
     {var fmt=param[1];return make_iprintf(k,ppf,fmt)}
    function ifprintf$0(ppf,param)
     {var fmt=param[1],_jr_=0;
      return make_iprintf(function(_js_){return 0},_jr_,fmt)}
    function fprintf$0(ppf)
     {function _jo_(_jq_){return 0}
      return function(_jp_){return kfprintf$0(_jo_,ppf,_jp_)}}
    function printf$0(fmt){return caml_call1(fprintf$0(std_formatter),fmt)}
    function eprintf$0(fmt){return caml_call1(fprintf$0(err_formatter),fmt)}
    function kdprintf(k,param)
     {var fmt=param[1],_jn_=0;
      return make_printf
              (function(acc)
                {return caml_call1
                         (k,function(ppf){return output_acc$0(ppf,acc)})},
               _jn_,
               fmt)}
    function dprintf(fmt){return kdprintf(function(i){return i},fmt)}
    function kprintf(k,param)
     {var fmt=param[1],b=pp_make_buffer(0),ppf=formatter_of_buffer(b);
      function k$0(acc)
       {strput_acc$0(ppf,acc);
        return caml_call1(k,flush_buffer_formatter(b,ppf))}
      return make_printf(k$0,0,fmt)}
    function sprintf$0(fmt){return kprintf(id$0,fmt)}
    function kasprintf(k,param)
     {var fmt=param[1],b=pp_make_buffer(0),ppf=formatter_of_buffer(b);
      function k$0(acc)
       {output_acc$0(ppf,acc);
        return caml_call1(k,flush_buffer_formatter(b,ppf))}
      return make_printf(k$0,0,fmt)}
    function asprintf(fmt){return kasprintf(id$0,fmt)}
    function flush_standard_formatters(param)
     {pp_print_flush(std_formatter,0);return pp_print_flush(err_formatter,0)}
    at_exit(flush_standard_formatters);
    function pp_set_all_formatter_output_fu(state,f,g,h,i)
     {pp_set_formatter_output_functi(state,f,g);
      state[19] = h;
      state[20] = i;
      return 0}
    function pp_get_all_formatter_output_fu(state,param)
     {return [0,state[17],state[18],state[19],state[20]]}
    function set_all_formatter_output_funct(_jj_,_jk_,_jl_,_jm_)
     {return pp_set_all_formatter_output_fu(std_formatter,_jj_,_jk_,_jl_,_jm_)}
    function get_all_formatter_output_funct(_ji_)
     {return pp_get_all_formatter_output_fu(std_formatter,_ji_)}
    function bprintf$0(b,param)
     {var fmt=param[1],ppf=formatter_of_buffer(b);
      function k(acc){output_acc$0(ppf,acc);return pp_flush_queue(ppf,0)}
      return make_printf(k,0,fmt)}
    function pp_set_formatter_tag_functions(state,param)
     {var pct=param[4],pot=param[3],mct=param[2],mot=param[1];
      function stringify(f,e,param)
       {if(param[1] === String_tag){var s=param[2];return caml_call1(f,s)}
        return e}
      state[24] = function(_jh_){return stringify(mot,cst$84,_jh_)};
      state[25] = function(_jg_){return stringify(mct,cst$85,_jg_)};
      var _jc_=0;
      state[26] = function(_jf_){return stringify(pot,_jc_,_jf_)};
      var _jd_=0;
      state[27] = function(_je_){return stringify(pct,_jd_,_je_)};
      return 0}
    function pp_get_formatter_tag_functions(fmt,param)
     {var funs=pp_get_formatter_stag_function(fmt,0);
      function mark_open_tag(s){return caml_call1(funs[1],[0,String_tag,s])}
      function mark_close_tag(s){return caml_call1(funs[2],[0,String_tag,s])}
      function print_open_tag(s){return caml_call1(funs[3],[0,String_tag,s])}
      function print_close_tag(s){return caml_call1(funs[4],[0,String_tag,s])}
      return [0,mark_open_tag,mark_close_tag,print_open_tag,print_close_tag]}
    function set_formatter_tag_functions(_jb_)
     {return pp_set_formatter_tag_functions(std_formatter,_jb_)}
    function get_formatter_tag_functions(_ja_)
     {return pp_get_formatter_tag_functions(std_formatter,_ja_)}
    var
     Stdlib_format=
      [0,
       pp_open_box,
       open_box,
       pp_close_box,
       close_box,
       pp_open_hbox,
       open_hbox,
       pp_open_vbox,
       open_vbox,
       pp_open_hvbox,
       open_hvbox,
       pp_open_hovbox,
       open_hovbox,
       pp_print_string,
       print_string$0,
       pp_print_as,
       print_as,
       pp_print_int,
       print_int$0,
       pp_print_float,
       print_float$0,
       pp_print_char,
       print_char$0,
       pp_print_bool,
       print_bool,
       pp_print_space,
       print_space,
       pp_print_cut,
       print_cut,
       pp_print_break,
       print_break,
       pp_print_custom_break,
       pp_force_newline,
       force_newline,
       pp_print_if_newline,
       print_if_newline,
       pp_print_flush,
       print_flush,
       pp_print_newline,
       print_newline$0,
       pp_set_margin,
       set_margin,
       pp_get_margin,
       get_margin,
       pp_set_max_indent,
       set_max_indent,
       pp_get_max_indent,
       get_max_indent,
       check_geometry,
       pp_set_geometry,
       set_geometry,
       pp_safe_set_geometry,
       safe_set_geometry,
       pp_update_geometry,
       update_geometry,
       pp_get_geometry,
       get_geometry,
       pp_set_max_boxes,
       set_max_boxes,
       pp_get_max_boxes,
       get_max_boxes,
       pp_over_max_boxes,
       over_max_boxes,
       pp_open_tbox,
       open_tbox,
       pp_close_tbox,
       close_tbox,
       pp_set_tab,
       set_tab,
       pp_print_tab,
       print_tab,
       pp_print_tbreak,
       print_tbreak,
       pp_set_ellipsis_text,
       set_ellipsis_text,
       pp_get_ellipsis_text,
       get_ellipsis_text,
       String_tag,
       pp_open_stag,
       open_stag,
       pp_close_stag,
       close_stag,
       pp_set_tags,
       set_tags,
       pp_set_print_tags,
       set_print_tags,
       pp_set_mark_tags,
       set_mark_tags,
       pp_get_print_tags,
       get_print_tags,
       pp_get_mark_tags,
       get_mark_tags,
       pp_set_formatter_out_channel,
       set_formatter_out_channel,
       pp_set_formatter_output_functi,
       set_formatter_output_functions,
       pp_get_formatter_output_functi,
       get_formatter_output_functions,
       pp_set_formatter_out_functions,
       set_formatter_out_functions,
       pp_get_formatter_out_functions,
       get_formatter_out_functions,
       pp_set_formatter_stag_function,
       set_formatter_stag_functions,
       pp_get_formatter_stag_function,
       get_formatter_stag_functions,
       formatter_of_out_channel,
       std_formatter,
       err_formatter,
       formatter_of_buffer,
       stdbuf,
       str_formatter,
       flush_str_formatter,
       make_formatter,
       formatter_of_out_functions,
       make_symbolic_output_buffer,
       clear_symbolic_output_buffer,
       get_symbolic_output_buffer,
       flush_symbolic_output_buffer,
       add_symbolic_output_item,
       formatter_of_symbolic_output_b,
       pp_print_list,
       pp_print_seq,
       pp_print_text,
       pp_print_option,
       pp_print_result,
       fprintf$0,
       printf$0,
       eprintf$0,
       sprintf$0,
       asprintf,
       dprintf,
       ifprintf$0,
       kfprintf$0,
       kdprintf,
       ikfprintf$0,
       kprintf,
       kasprintf,
       bprintf$0,
       kprintf,
       set_all_formatter_output_funct,
       get_all_formatter_output_funct,
       pp_set_all_formatter_output_fu,
       pp_get_all_formatter_output_fu,
       pp_open_tag,
       open_tag,
       pp_close_tag,
       close_tag,
       pp_set_formatter_tag_functions,
       set_formatter_tag_functions,
       pp_get_formatter_tag_functions,
       get_formatter_tag_functions];
    caml_register_global(801,Stdlib_format,"Stdlib__format");
    var null_char=0;
    function next_char(ib)
     {try
       {var c=caml_call1(ib[7],0);
        ib[2] = c;
        ib[3] = 1;
        ib[4] = ib[4] + 1 | 0;
        if(10 === c)ib[5] = ib[5] + 1 | 0;
        return c}
      catch(_i$_)
       {_i$_ = caml_wrap_exception(_i$_);
        if(_i$_ === End_of_file)
         {ib[2] = null_char;ib[3] = 0;ib[1] = 1;return null_char}
        throw _i$_}}
    function peek_char(ib){return ib[3]?ib[2]:next_char(ib)}
    function checked_peek_char(ib)
     {var c=peek_char(ib);if(ib[1])throw End_of_file;return c}
    function end_of_input(ib){peek_char(ib);return ib[1]}
    function beginning_of_input(ib){return 0 === ib[4]?1:0}
    function name_of_input(ib)
     {var _i__=ib[9];
      if(typeof _i__ === "number")
       return 0 === _i__?cst_unnamed_function:cst_unnamed_character_string;
      else
       {if(0 === _i__[0])return cst_unnamed_Stdlib_input_chann;
        var fname=_i__[1];
        return fname}}
    function char_count(ib){return ib[3]?ib[4] - 1 | 0:ib[4]}
    function reset_token(ib){return reset(ib[8])}
    function invalidate_current_char(ib){ib[3] = 0;return 0}
    function token_string(ib)
     {var token_buffer=ib[8],tok=contents(token_buffer);
      clear$1(token_buffer);
      ib[6] = ib[6] + 1 | 0;
      return tok}
    function skip_char(width,ib){invalidate_current_char(ib);return width}
    function ignore_char(width,ib){return skip_char(width - 1 | 0,ib)}
    function store_char(width,ib,c)
     {add_char(ib[8],c);return ignore_char(width,ib)}
    var default_token_buffer_size=1024;
    function create$4(iname,next)
     {return [0,
              0,
              null_char,
              0,
              0,
              0,
              0,
              next,
              create$2(default_token_buffer_size),
              iname]}
    function from_string$1(s)
     {var i=[0,0],len=caml_ml_string_length(s);
      function next(param)
       {if(len <= i[1])throw End_of_file;
        var c=caml_string_get(s,i[1]);
        i[1]++;
        return c}
      return create$4(1,next)}
    var _cj_=0;
    function from_function$0(_i9_){return create$4(_cj_,_i9_)}
    var len=1024;
    function scan_close_at_end(ic)
     {caml_ml_close_channel(ic);throw End_of_file}
    function scan_raise_at_end(ic){throw End_of_file}
    function from_ic(scan_close_ic,iname,ic)
     {var buf=caml_create_bytes(1024),i=[0,0],lim=[0,0],eof=[0,0];
      function next(param)
       {if(i[1] < lim[1]){var c=caml_bytes_get(buf,i[1]);i[1]++;return c}
        if(eof[1])throw End_of_file;
        lim[1] = input(ic,buf,0,len);
        return 0 === lim[1]
                ?(eof[1] = 1,caml_call1(scan_close_ic,ic))
                :(i[1] = 1,caml_bytes_get(buf,0))}
      return create$4(iname,next)}
    var stdib=from_ic(scan_raise_at_end,[1,cst$86,stdin],stdin);
    function open_in_file(open_in,fname)
     {if(caml_string_notequal(fname,cst$87))
       {var ic=caml_call1(open_in,fname);
        return from_ic(scan_close_at_end,[1,fname,ic],ic)}
      return stdib}
    function from_file(_i8_){return open_in_file(open_in,_i8_)}
    function from_file_bin(_i7_){return open_in_file(open_in_bin,_i7_)}
    function from_channel$0(ic){return from_ic(scan_raise_at_end,[0,ic],ic)}
    function close_in$0(ib)
     {var _i6_=ib[9];
      if(typeof _i6_ === "number")
       return 0;
      else
       {if(0 === _i6_[0]){var ic=_i6_[1];return caml_ml_close_channel(ic)}
        var ic$0=_i6_[2];
        return caml_ml_close_channel(ic$0)}}
    var memo=[0,0];
    function memo_from_ic(scan_close_ic,ic)
     {try
       {var _i4_=assq(ic,memo[1]);return _i4_}
      catch(_i5_)
       {_i5_ = caml_wrap_exception(_i5_);
        if(_i5_ === Not_found)
         {var ib=from_ic(scan_close_ic,[0,ic],ic);
          memo[1] = [0,[0,ic,ib],memo[1]];
          return ib}
        throw _i5_}}
    function memo_from_channel(_i3_)
     {return memo_from_ic(scan_raise_at_end,_i3_)}
    var Scan_failure=[248,cst_Stdlib_Scanf_Scan_failure,caml_fresh_oo_id(0)];
    function bad_input(s){throw [0,Scan_failure,s]}
    function bad_input_escape(c)
     {return bad_input(caml_call1(sprintf(_ck_),c))}
    function bad_token_length(message)
     {return bad_input(caml_call1(sprintf(_cl_),message))}
    function bad_float(param)
     {return bad_input(cst_no_dot_or_exponent_part_fo)}
    function bad_hex_float(param)
     {return bad_input(cst_not_a_valid_float_in_hexad)}
    function character_mismatch(c,ci)
     {return bad_input(caml_call2(sprintf(_cn_),c,ci))}
    function check_this_char(ib,c)
     {var ci=checked_peek_char(ib);
      return ci === c?invalidate_current_char(ib):character_mismatch(c,ci)}
    function check_char(ib,c$0)
     {if(10 === c$0)
       {var ci=checked_peek_char(ib);
        return 10 === ci
                ?invalidate_current_char(ib)
                :13 === ci
                  ?(invalidate_current_char(ib),check_this_char(ib,10))
                  :character_mismatch(10,ci)}
      if(32 === c$0)
       for(;;)
        {var c=peek_char(ib),_i1_=1 - ib[1];
         if(_i1_)
          {var _i2_=c - 9 | 0,switch$0=0;
           if(4 < _i2_ >>> 0)
            {if(23 === _i2_)switch$0 = 1}
           else
            if(1 < (_i2_ - 2 | 0) >>> 0)switch$0 = 1;
           if(switch$0){invalidate_current_char(ib);continue}
           return 0}
         return _i1_}
      return check_this_char(ib,c$0)}
    function token_char(ib){return caml_string_get(token_string(ib),0)}
    function token_bool(ib)
     {var s=token_string(ib);
      return caml_string_notequal(s,cst_false$3)
              ?caml_string_notequal(s,cst_true$3)
                ?bad_input(caml_call1(sprintf(_co_),s))
                :1
              :0}
    function integer_conversion_of_char(param)
     {var switcher=param - 88 | 0;
      if(! (32 < switcher >>> 0))
       switch(switcher)
        {case 10:return 0;
         case 12:return 1;
         case 17:return 2;
         case 23:return 3;
         case 29:return 4;
         case 0:
         case 32:return 5
         }
      throw [0,Assert_failure,_cp_]}
    function token_int_literal(conv,ib)
     {switch(conv)
       {case 0:var tok=symbol(cst_0b,token_string(ib));break;
        case 3:var tok=symbol(cst_0o,token_string(ib));break;
        case 4:var tok=symbol(cst_0u,token_string(ib));break;
        case 5:var tok=symbol(cst_0x,token_string(ib));break;
        default:var tok=token_string(ib)}
      var l=caml_ml_string_length(tok);
      if(0 !== l && 43 === caml_string_get(tok,0))
       return sub$0(tok,1,l - 1 | 0);
      return tok}
    function token_float(ib){return caml_float_of_string(token_string(ib))}
    function scan_decimal_digit_star(width,ib)
     {var width$0=width;
      for(;;)
       {if(0 === width$0)return width$0;
        var c=peek_char(ib);
        if(ib[1])return width$0;
        if(58 <= c)
         {if(95 === c)
           {var width$1=ignore_char(width$0,ib),width$0=width$1;continue}}
        else
         if(48 <= c)
          {var width$2=store_char(width$0,ib,c),width$0=width$2;continue}
        return width$0}}
    function scan_unsigned_decimal_int(width,ib)
     {if(0 === width)return bad_token_length(cst_decimal_digits);
      var c=checked_peek_char(ib),switcher=c - 48 | 0;
      if(9 < switcher >>> 0)return bad_input(caml_call1(sprintf(_cq_),c));
      var width$0=store_char(width,ib,c);
      return scan_decimal_digit_star(width$0,ib)}
    function scan_digit_plus(basis,digitp,width$2,ib)
     {if(0 === width$2)return bad_token_length(cst_digits);
      var c$0=checked_peek_char(ib);
      if(caml_call1(digitp,c$0))
       {var width$3=store_char(width$2,ib,c$0),width=width$3;
        for(;;)
         {if(0 === width)return width;
          var c=peek_char(ib);
          if(ib[1])return width;
          if(caml_call1(digitp,c))
           {var width$0=store_char(width,ib,c),width=width$0;continue}
          if(95 === c)
           {var width$1=ignore_char(width,ib),width=width$1;continue}
          return width}}
      return bad_input(caml_call2(sprintf(_cr_),c$0,basis))}
    function is_binary_digit(param)
     {var switcher=param - 48 | 0;return 1 < switcher >>> 0?0:1}
    function scan_binary_int(_iZ_,_i0_)
     {return scan_digit_plus(cst_binary,is_binary_digit,_iZ_,_i0_)}
    function is_octal_digit(param)
     {var switcher=param - 48 | 0;return 7 < switcher >>> 0?0:1}
    function scan_octal_int(_iX_,_iY_)
     {return scan_digit_plus(cst_octal,is_octal_digit,_iX_,_iY_)}
    function is_hexa_digit(param)
     {var _iW_=param - 48 | 0,switch$0=0;
      if(22 < _iW_ >>> 0)
       {if(! (5 < (_iW_ - 49 | 0) >>> 0))switch$0 = 1}
      else
       if(6 < (_iW_ - 10 | 0) >>> 0)switch$0 = 1;
      return switch$0?1:0}
    function scan_hexadecimal_int(_iU_,_iV_)
     {return scan_digit_plus(cst_hexadecimal,is_hexa_digit,_iU_,_iV_)}
    function scan_sign(width,ib)
     {var c=checked_peek_char(ib),switcher=c - 43 | 0;
      if(! (2 < switcher >>> 0))
       switch(switcher)
        {case 0:return store_char(width,ib,c);
         case 1:break;
         default:return store_char(width,ib,c)}
      return width}
    function scan_optionally_signed_decimal(width,ib)
     {var width$0=scan_sign(width,ib);
      return scan_unsigned_decimal_int(width$0,ib)}
    function scan_int_conversion(conv,width$1,ib)
     {switch(conv)
       {case 0:return scan_binary_int(width$1,ib);
        case 1:return scan_optionally_signed_decimal(width$1,ib);
        case 2:
         var width$0=scan_sign(width$1,ib),c=checked_peek_char(ib);
         if(48 === c)
          {var width=store_char(width$0,ib,c);
           if(0 === width)return width;
           var c$0=peek_char(ib);
           if(ib[1])return width;
           var switch$0=0;
           if(99 <= c$0)
            {if(111 === c$0)
              return scan_octal_int(store_char(width,ib,c$0),ib);
             if(120 === c$0)switch$0 = 1}
           else
            if(88 === c$0)
             switch$0 = 1;
            else
             if(98 <= c$0)return scan_binary_int(store_char(width,ib,c$0),ib);
           return switch$0
                   ?scan_hexadecimal_int(store_char(width,ib,c$0),ib)
                   :scan_decimal_digit_star(width,ib)}
         return scan_unsigned_decimal_int(width$0,ib);
        case 3:return scan_octal_int(width$1,ib);
        case 4:return scan_unsigned_decimal_int(width$1,ib);
        default:return scan_hexadecimal_int(width$1,ib)}}
    function scan_fractional_part(width,ib)
     {if(0 === width)return width;
      var c=peek_char(ib);
      if(ib[1])return width;
      var switcher=c - 48 | 0;
      return 9 < switcher >>> 0
              ?width
              :scan_decimal_digit_star(store_char(width,ib,c),ib)}
    function scan_exponent_part(width,ib)
     {if(0 === width)return width;
      var c=peek_char(ib);
      if(ib[1])return width;
      if(69 !== c && 101 !== c)return width;
      return scan_optionally_signed_decimal(store_char(width,ib,c),ib)}
    function scan_float(width$1,precision,ib)
     {var
       width=scan_sign(width$1,ib),
       width$0=scan_decimal_digit_star(width,ib);
      if(0 === width$0)return [0,width$0,precision];
      var c=peek_char(ib);
      if(ib[1])return [0,width$0,precision];
      if(46 === c)
       {var
         width$2=store_char(width$0,ib,c),
         precision$0=min(width$2,precision),
         width$3=
          width$2
          -
          (precision$0 - scan_fractional_part(precision$0,ib) | 0)
          |
          0;
        return [0,scan_exponent_part(width$3,ib),precision$0]}
      return [0,scan_exponent_part(width$0,ib),precision]}
    function check_case_insensitive_string(width,ib,error,str)
     {function lowercase(c)
       {var switcher=c - 65 | 0;
        return 25 < switcher >>> 0?c:char_of_int((c - 65 | 0) + 97 | 0)}
      var
       len=caml_ml_string_length(str),
       width$0=[0,width],
       _iR_=len - 1 | 0,
       _iQ_=0;
      if(! (_iR_ < 0))
       {var i=_iQ_;
        for(;;)
         {var c=peek_char(ib),_iS_=lowercase(caml_string_get(str,i));
          if(lowercase(c) !== _iS_)caml_call1(error,0);
          if(0 === width$0[1])caml_call1(error,0);
          width$0[1] = store_char(width$0[1],ib,c);
          var _iT_=i + 1 | 0;
          if(_iR_ !== i){var i=_iT_;continue}
          break}}
      return width$0[1]}
    function scan_hex_float(width,precision,ib)
     {var _iD_=0 === width?1:0,_iE_=_iD_ || end_of_input(ib);
      if(_iE_)bad_hex_float(0);
      var
       width$0=scan_sign(width,ib),
       _iF_=0 === width$0?1:0,
       _iG_=_iF_ || end_of_input(ib);
      if(_iG_)bad_hex_float(0);
      var c=peek_char(ib),switch$0=0;
      if(78 <= c)
       {var switcher=c - 79 | 0;
        if(30 < switcher >>> 0)
         {if(! (32 <= switcher))
           {var
             width$1=store_char(width$0,ib,c),
             _iH_=0 === width$1?1:0,
             _iI_=_iH_ || end_of_input(ib);
            if(_iI_)bad_hex_float(0);
            return check_case_insensitive_string
                    (width$1,ib,bad_hex_float,cst_an)}}
        else
         if(26 === switcher)switch$0 = 1}
      else
       {if(48 === c)
         {var
           width$3=store_char(width$0,ib,c),
           _iL_=0 === width$3?1:0,
           _iM_=_iL_ || end_of_input(ib);
          if(_iM_)bad_hex_float(0);
          var
           width$4=
            check_case_insensitive_string(width$3,ib,bad_hex_float,cst_x$2);
          if(0 !== width$4 && ! end_of_input(ib))
           {var match=peek_char(ib),_iN_=match - 46 | 0,switch$1=0;
            if(34 < _iN_ >>> 0)
             {if(66 === _iN_)switch$1 = 1}
            else
             if(32 < (_iN_ - 1 | 0) >>> 0)switch$1 = 1;
            var width$5=switch$1?width$4:scan_hexadecimal_int(width$4,ib);
            if(0 !== width$5 && ! end_of_input(ib))
             {var c$0=peek_char(ib);
              if(46 === c$0)
               {var width$6=store_char(width$5,ib,c$0),switch$2=0;
                if(0 !== width$6 && ! end_of_input(ib))
                 {var match$0=peek_char(ib),switch$3=0;
                  if(80 !== match$0 && 112 !== match$0)
                   {var
                     precision$0=min(width$6,precision),
                     width$10=
                      width$6
                      -
                      (precision$0 - scan_hexadecimal_int(precision$0,ib) | 0)
                      |
                      0;
                    switch$3 = 1}
                  if(! switch$3)var width$10=width$6;
                  var width$7=width$10;
                  switch$2 = 1}
                if(! switch$2)var width$7=width$6;
                var width$8=width$7}
              else
               var width$8=width$5;
              if(0 !== width$8 && ! end_of_input(ib))
               {var c$1=peek_char(ib);
                if(80 !== c$1 && 112 !== c$1)return width$8;
                var
                 width$9=store_char(width$8,ib,c$1),
                 _iO_=0 === width$9?1:0,
                 _iP_=_iO_ || end_of_input(ib);
                if(_iP_)bad_hex_float(0);
                return scan_optionally_signed_decimal(width$9,ib)}
              return width$8}
            return width$5}
          return width$4}
        if(73 === c)switch$0 = 1}
      if(switch$0)
       {var
         width$2=store_char(width$0,ib,c),
         _iJ_=0 === width$2?1:0,
         _iK_=_iJ_ || end_of_input(ib);
        if(_iK_)bad_hex_float(0);
        return check_case_insensitive_string
                (width$2,ib,bad_hex_float,cst_nfinity)}
      return bad_hex_float(0)}
    function scan_caml_float_rest(width,precision,ib)
     {var _iz_=0 === width?1:0,_iA_=_iz_ || end_of_input(ib);
      if(_iA_)bad_float(0);
      var
       width$0=scan_decimal_digit_star(width,ib),
       _iB_=0 === width$0?1:0,
       _iC_=_iB_ || end_of_input(ib);
      if(_iC_)bad_float(0);
      var c=peek_char(ib),switcher=c - 69 | 0;
      if(32 < switcher >>> 0)
       {if(-23 === switcher)
         {var
           width$1=store_char(width$0,ib,c),
           precision$0=min(width$1,precision),
           width_precision=scan_fractional_part(precision$0,ib),
           frac_width=precision$0 - width_precision | 0,
           width$2=width$1 - frac_width | 0;
          return scan_exponent_part(width$2,ib)}}
      else
       {var switcher$0=switcher - 1 | 0;
        if(30 < switcher$0 >>> 0)return scan_exponent_part(width$0,ib)}
      return bad_float(0)}
    function scan_caml_float(width,precision,ib)
     {var _il_=0 === width?1:0,_im_=_il_ || end_of_input(ib);
      if(_im_)bad_float(0);
      var
       width$0=scan_sign(width,ib),
       _in_=0 === width$0?1:0,
       _io_=_in_ || end_of_input(ib);
      if(_io_)bad_float(0);
      var c=peek_char(ib);
      if(49 <= c)
       {if(! (58 <= c))
         {var
           width$1=store_char(width$0,ib,c),
           _ip_=0 === width$1?1:0,
           _iq_=_ip_ || end_of_input(ib);
          if(_iq_)bad_float(0);
          return scan_caml_float_rest(width$1,precision,ib)}}
      else
       if(48 <= c)
        {var
          width$2=store_char(width$0,ib,c),
          _ir_=0 === width$2?1:0,
          _is_=_ir_ || end_of_input(ib);
         if(_is_)bad_float(0);
         var c$0=peek_char(ib);
         if(88 !== c$0 && 120 !== c$0)
          return scan_caml_float_rest(width$2,precision,ib);
         var
          width$3=store_char(width$2,ib,c$0),
          _it_=0 === width$3?1:0,
          _iu_=_it_ || end_of_input(ib);
         if(_iu_)bad_float(0);
         var
          width$4=scan_hexadecimal_int(width$3,ib),
          _iv_=0 === width$4?1:0,
          _iw_=_iv_ || end_of_input(ib);
         if(_iw_)bad_float(0);
         var c$1=peek_char(ib),switcher=c$1 - 80 | 0,switch$0=0;
         if(32 < switcher >>> 0)
          if(-34 === switcher)
           {var width$5=store_char(width$4,ib,c$1),switch$1=0;
            if(0 !== width$5 && ! end_of_input(ib))
             {var match=peek_char(ib),switch$2=0;
              if(80 !== match && 112 !== match)
               {var
                 precision$0=min(width$5,precision),
                 width$10=
                  width$5
                  -
                  (precision$0 - scan_hexadecimal_int(precision$0,ib) | 0)
                  |
                  0;
                switch$2 = 1}
              if(! switch$2)var width$10=width$5;
              var width$6=width$10;
              switch$1 = 1}
            if(! switch$1)var width$6=width$5;
            var width$7=width$6}
          else
           switch$0 = 1;
         else
          {var switcher$0=switcher - 1 | 0;
           if(30 < switcher$0 >>> 0)var width$7=width$4;else switch$0 = 1}
         var width$8=switch$0?bad_float(0):width$7;
         if(0 !== width$8 && ! end_of_input(ib))
          {var c$2=peek_char(ib);
           if(80 !== c$2 && 112 !== c$2)return width$8;
           var
            width$9=store_char(width$8,ib,c$2),
            _ix_=0 === width$9?1:0,
            _iy_=_ix_ || end_of_input(ib);
           if(_iy_)bad_hex_float(0);
           return scan_optionally_signed_decimal(width$9,ib)}
         return width$8}
      return bad_float(0)}
    function scan_string(stp,width,ib)
     {var width$0=width;
      for(;;)
       {if(0 === width$0)return width$0;
        var c=peek_char(ib);
        if(ib[1])return width$0;
        if(stp)
         {var c$0=stp[1];
          if(c === c$0)return skip_char(width$0,ib);
          var width$1=store_char(width$0,ib,c),width$0=width$1;
          continue}
        var _ik_=c - 9 | 0,switch$0=0;
        if(4 < _ik_ >>> 0)
         {if(23 === _ik_)switch$0 = 1}
        else
         if(1 < (_ik_ - 2 | 0) >>> 0)switch$0 = 1;
        if(switch$0)return width$0;
        var width$2=store_char(width$0,ib,c),width$0=width$2;
        continue}}
    function scan_char(width,ib)
     {return store_char(width,ib,checked_peek_char(ib))}
    function hexadecimal_value_of_char(d)
     {return 97 <= d?d - 87 | 0:65 <= d?d - 55 | 0:d - 48 | 0}
    function check_next_char(message,width,ib)
     {if(0 === width)return bad_token_length(message);
      var c=peek_char(ib);
      return ib[1]?bad_input(caml_call1(sprintf(_cm_),message)):c}
    function check_next_char_for_char(_ii_,_ij_)
     {return check_next_char(cst_a_Char,_ii_,_ij_)}
    function check_next_char_for_string(_ig_,_ih_)
     {return check_next_char(cst_a_String,_ig_,_ih_)}
    function scan_backslash_char(width,ib)
     {var c0=check_next_char_for_char(width,ib),switch$0=0;
      if(40 <= c0)
       {if(58 <= c0)
         {var switcher$0=c0 - 92 | 0;
          if(! (28 < switcher$0 >>> 0))
           switch(switcher$0)
            {case 28:
              var
               get_digit=
                function(param)
                 {var c=next_char(ib),_if_=c - 48 | 0,switch$0=0;
                  if(22 < _if_ >>> 0)
                   {if(! (5 < (_if_ - 49 | 0) >>> 0))switch$0 = 1}
                  else
                   if(6 < (_if_ - 10 | 0) >>> 0)switch$0 = 1;
                  return switch$0?c:bad_input_escape(c)},
               c1=get_digit(0),
               c2=get_digit(0),
               _ib_=hexadecimal_value_of_char(c2),
               c$0=(16 * hexadecimal_value_of_char(c1) | 0) + _ib_ | 0,
               switch$1=0;
              if(0 <= c$0 && ! (255 < c$0))
               {var _id_=char_of_int(c$0);switch$1 = 1}
              if(! switch$1)
               var _id_=bad_input(caml_call2(sprintf(_ct_),c1,c2));
              return store_char(width - 2 | 0,ib,_id_);
             case 0:
             case 6:
             case 18:
             case 22:
             case 24:switch$0 = 1;break
             }}
        else
         if(48 <= c0)
          {var
            get_digit$0=
             function(param)
              {var c=next_char(ib),switcher=c - 48 | 0;
               return 9 < switcher >>> 0?bad_input_escape(c):c},
            c1$0=get_digit$0(0),
            c2$0=get_digit$0(0),
            c=
             ((100 * (c0 - 48 | 0) | 0) + (10 * (c1$0 - 48 | 0) | 0) | 0)
             +
             (c2$0 - 48 | 0)
             |
             0,
            switch$2=0;
           if(0 <= c && ! (255 < c)){var _ie_=char_of_int(c);switch$2 = 1}
           if(! switch$2)
            var _ie_=bad_input(caml_call3(sprintf(_cs_),c0,c1$0,c2$0));
           return store_char(width - 2 | 0,ib,_ie_)}}
      else
       if(34 === c0 || 39 <= c0)switch$0 = 1;
      if(switch$0)
       {var switch$3=0;
        if(110 <= c0)
         if(117 <= c0)
          switch$3 = 1;
         else
          {var switcher=c0 - 110 | 0;
           switch(switcher)
            {case 0:var _ic_=10;break;
             case 4:var _ic_=13;break;
             case 6:var _ic_=9;break;
             default:switch$3 = 1}}
        else
         if(98 === c0)var _ic_=8;else switch$3 = 1;
        if(switch$3)var _ic_=c0;
        return store_char(width,ib,_ic_)}
      return bad_input_escape(c0)}
    function scan_caml_char(width,ib)
     {function find_stop(width)
       {var c=check_next_char_for_char(width,ib);
        return 39 === c?ignore_char(width,ib):character_mismatch(39,c)}
      var c=checked_peek_char(ib);
      if(39 === c)
       {var
         width$0=ignore_char(width,ib),
         c$0=check_next_char_for_char(width$0,ib);
        return 92 === c$0
                ?find_stop(scan_backslash_char(ignore_char(width$0,ib),ib))
                :find_stop(store_char(width$0,ib,c$0))}
      return character_mismatch(39,c)}
    function scan_caml_string(width,ib)
     {function find_stop$0(counter,width)
       {var width$0=width;
        for(;;)
         {var c=check_next_char_for_string(width$0,ib);
          if(34 === c)return ignore_char(width$0,ib);
          if(92 === c)
           {var
             width$1=ignore_char(width$0,ib),
             match=check_next_char_for_string(width$1,ib);
            if(10 === match)
             {var _h$_=ignore_char(width$1,ib);
              if(counter < 50)
               {var counter$0=counter + 1 | 0;
                return skip_spaces(counter$0,_h$_)}
              return caml_trampoline_return(skip_spaces,[0,_h$_])}
            if(13 === match)
             {var
               width$3=ignore_char(width$1,ib),
               match$0=check_next_char_for_string(width$3,ib);
              if(10 === match$0)
               {var _ia_=ignore_char(width$3,ib);
                if(counter < 50)
                 {var counter$1=counter + 1 | 0;
                  return skip_spaces(counter$1,_ia_)}
                return caml_trampoline_return(skip_spaces,[0,_ia_])}
              var width$5=store_char(width$3,ib,13),width$0=width$5;
              continue}
            var width$4=scan_backslash_char(width$1,ib),width$0=width$4;
            continue}
          var width$2=store_char(width$0,ib,c),width$0=width$2;
          continue}}
      function skip_spaces(counter,width)
       {var width$0=width;
        for(;;)
         {var match=check_next_char_for_string(width$0,ib);
          if(32 === match)
           {var width$1=ignore_char(width$0,ib),width$0=width$1;continue}
          if(counter < 50)
           {var counter$0=counter + 1 | 0;
            return find_stop$0(counter$0,width$0)}
          return caml_trampoline_return(find_stop$0,[0,width$0])}}
      function find_stop(width){return caml_trampoline(find_stop$0(0,width))}
      var c=checked_peek_char(ib);
      return 34 === c
              ?find_stop(ignore_char(width,ib))
              :character_mismatch(34,c)}
    function scan_chars_in_char_set(char_set,scan_indic,width,ib)
     {function scan_chars(i,stp)
       {var i$0=i;
        for(;;)
         {var c=peek_char(ib),_h7_=0 < i$0?1:0;
          if(_h7_)
           {var _h8_=1 - ib[1];
            if(_h8_)
             var _h9_=is_in_char_set(char_set,c),_h__=_h9_?c !== stp?1:0:_h9_;
            else
             var _h__=_h8_}
          else
           var _h__=_h7_;
          if(_h__)
           {store_char(max_int,ib,c);var i$1=i$0 - 1 | 0,i$0=i$1;continue}
          return _h__}}
      if(scan_indic)
       {var c=scan_indic[1];
        scan_chars(width,c);
        var _h6_=1 - ib[1];
        if(_h6_)
         {var ci=peek_char(ib);
          return c === ci?invalidate_current_char(ib):character_mismatch(c,ci)}
        return _h6_}
      return scan_chars(width,-1)}
    function scanf_bad_input(ib,x)
     {if(x[1] === Scan_failure)
       var s=x[2];
      else
       {if(x[1] !== Failure)throw x;var s=x[2]}
      var i=char_count(ib);
      return bad_input(caml_call2(sprintf(_cv_),i,s))}
    function get_counter(ib,counter)
     {switch(counter)
       {case 0:return ib[5];case 1:return char_count(ib);default:return ib[6]}}
    function width_of_pad_opt(pad_opt)
     {if(pad_opt){var width=pad_opt[1];return width}return max_int}
    function stopper_of_formatting_lit(fmting)
     {if(6 === fmting)return _cw_;
      var
       str=string_of_formatting_lit(fmting),
       stp=caml_string_get(str,1),
       sub_str=sub$0(str,2,caml_ml_string_length(str) - 2 | 0);
      return [0,stp,sub_str]}
    function take_format_readers$0(counter,k,fmt)
     {var fmt$0=fmt;
      for(;;)
       if(typeof fmt$0 === "number")
        return caml_call1(k,0);
       else
        switch(fmt$0[0])
         {case 0:var fmt$1=fmt$0[1],fmt$0=fmt$1;continue;
          case 1:var fmt$2=fmt$0[1],fmt$0=fmt$2;continue;
          case 2:var fmt$3=fmt$0[2],fmt$0=fmt$3;continue;
          case 3:var fmt$4=fmt$0[2],fmt$0=fmt$4;continue;
          case 4:var fmt$5=fmt$0[4],fmt$0=fmt$5;continue;
          case 5:var fmt$6=fmt$0[4],fmt$0=fmt$6;continue;
          case 6:var fmt$7=fmt$0[4],fmt$0=fmt$7;continue;
          case 7:var fmt$8=fmt$0[4],fmt$0=fmt$8;continue;
          case 8:var fmt$9=fmt$0[4],fmt$0=fmt$9;continue;
          case 9:var fmt$10=fmt$0[2],fmt$0=fmt$10;continue;
          case 10:var fmt$11=fmt$0[1],fmt$0=fmt$11;continue;
          case 11:var fmt$12=fmt$0[2],fmt$0=fmt$12;continue;
          case 12:var fmt$13=fmt$0[2],fmt$0=fmt$13;continue;
          case 13:var fmt$14=fmt$0[3],fmt$0=fmt$14;continue;
          case 14:
           var rest=fmt$0[3],fmtty=fmt$0[2],_h4_=erase_rel(symm(fmtty));
           if(counter < 50)
            {var counter$0=counter + 1 | 0;
             return take_fmtty_format_readers$0(counter$0,k,_h4_,rest)}
           return caml_trampoline_return
                   (take_fmtty_format_readers$0,[0,k,_h4_,rest]);
          case 15:var fmt$15=fmt$0[1],fmt$0=fmt$15;continue;
          case 16:var fmt$16=fmt$0[1],fmt$0=fmt$16;continue;
          case 17:var fmt$17=fmt$0[2],fmt$0=fmt$17;continue;
          case 18:
           var _h5_=fmt$0[1];
           if(0 === _h5_[0])
            {var
              rest$0=fmt$0[2],
              match=_h5_[1],
              fmt$18=match[1],
              fmt$19=concat_fmt(fmt$18,rest$0),
              fmt$0=fmt$19;
             continue}
           var
            rest$1=fmt$0[2],
            match$0=_h5_[1],
            fmt$20=match$0[1],
            fmt$21=concat_fmt(fmt$20,rest$1),
            fmt$0=fmt$21;
           continue;
          case 19:
           var fmt_rest=fmt$0[1];
           return function(reader)
            {function new_k(readers_rest)
              {return caml_call1(k,[0,reader,readers_rest])}
             return take_format_readers(new_k,fmt_rest)};
          case 20:var fmt$22=fmt$0[3],fmt$0=fmt$22;continue;
          case 21:var fmt$23=fmt$0[2],fmt$0=fmt$23;continue;
          case 22:var fmt$24=fmt$0[1],fmt$0=fmt$24;continue;
          case 23:
           var rest$2=fmt$0[2],ign=fmt$0[1];
           if(typeof ign === "number")
            switch(ign)
             {case 0:var fmt$0=rest$2;continue;
              case 1:var fmt$0=rest$2;continue;
              case 2:
               return function(reader)
                {function new_k(readers_rest)
                  {return caml_call1(k,[0,reader,readers_rest])}
                 return take_format_readers(new_k,rest$2)};
              default:var fmt$0=rest$2;continue}
           else
            switch(ign[0])
             {case 0:var fmt$0=rest$2;continue;
              case 1:var fmt$0=rest$2;continue;
              case 2:var fmt$0=rest$2;continue;
              case 3:var fmt$0=rest$2;continue;
              case 4:var fmt$0=rest$2;continue;
              case 5:var fmt$0=rest$2;continue;
              case 6:var fmt$0=rest$2;continue;
              case 7:var fmt$0=rest$2;continue;
              case 8:var fmt$0=rest$2;continue;
              case 9:
               var fmtty$0=ign[2];
               if(counter < 50)
                {var counter$1=counter + 1 | 0;
                 return take_fmtty_format_readers$0
                         (counter$1,k,fmtty$0,rest$2)}
               return caml_trampoline_return
                       (take_fmtty_format_readers$0,[0,k,fmtty$0,rest$2]);
              case 10:var fmt$0=rest$2;continue;
              default:var fmt$0=rest$2;continue}
          default:var fmt$25=fmt$0[3],fmt$0=fmt$25;continue}}
    function take_fmtty_format_readers$0(counter,k,fmtty,fmt)
     {var fmtty$0=fmtty;
      for(;;)
       if(typeof fmtty$0 === "number")
        {if(counter < 50)
          {var counter$0=counter + 1 | 0;
           return take_format_readers$0(counter$0,k,fmt)}
         return caml_trampoline_return(take_format_readers$0,[0,k,fmt])}
       else
        switch(fmtty$0[0])
         {case 0:var fmtty$1=fmtty$0[1],fmtty$0=fmtty$1;continue;
          case 1:var fmtty$2=fmtty$0[1],fmtty$0=fmtty$2;continue;
          case 2:var fmtty$3=fmtty$0[1],fmtty$0=fmtty$3;continue;
          case 3:var fmtty$4=fmtty$0[1],fmtty$0=fmtty$4;continue;
          case 4:var fmtty$5=fmtty$0[1],fmtty$0=fmtty$5;continue;
          case 5:var fmtty$6=fmtty$0[1],fmtty$0=fmtty$6;continue;
          case 6:var fmtty$7=fmtty$0[1],fmtty$0=fmtty$7;continue;
          case 7:var fmtty$8=fmtty$0[1],fmtty$0=fmtty$8;continue;
          case 8:var fmtty$9=fmtty$0[2],fmtty$0=fmtty$9;continue;
          case 9:
           var
            rest=fmtty$0[3],
            ty2=fmtty$0[2],
            ty1=fmtty$0[1],
            ty=trans(symm(ty1),ty2),
            fmtty$10=concat_fmtty(ty,rest),
            fmtty$0=fmtty$10;
           continue;
          case 10:var fmtty$11=fmtty$0[1],fmtty$0=fmtty$11;continue;
          case 11:var fmtty$12=fmtty$0[1],fmtty$0=fmtty$12;continue;
          case 12:var fmtty$13=fmtty$0[1],fmtty$0=fmtty$13;continue;
          case 13:
           var fmt_rest=fmtty$0[1];
           return function(reader)
            {function new_k(readers_rest)
              {return caml_call1(k,[0,reader,readers_rest])}
             return take_fmtty_format_readers(new_k,fmt_rest,fmt)};
          default:
           var fmt_rest$0=fmtty$0[1];
           return function(reader)
            {function new_k(readers_rest)
              {return caml_call1(k,[0,reader,readers_rest])}
             return take_fmtty_format_readers(new_k,fmt_rest$0,fmt)}}}
    function take_format_readers(k,fmt)
     {return caml_trampoline(take_format_readers$0(0,k,fmt))}
    function take_fmtty_format_readers(k,fmtty,fmt)
     {return caml_trampoline(take_fmtty_format_readers$0(0,k,fmtty,fmt))}
    function make_scanf(ib,fmt,readers)
     {var fmt$0=fmt;
      for(;;)
       if(typeof fmt$0 === "number")
        return 0;
       else
        switch(fmt$0[0])
         {case 0:
           var rest=fmt$0[1];
           scan_char(0,ib);
           var c=token_char(ib);
           return [0,c,make_scanf(ib,rest,readers)];
          case 1:
           var rest$0=fmt$0[1];
           scan_caml_char(0,ib);
           var c$0=token_char(ib);
           return [0,c$0,make_scanf(ib,rest$0,readers)];
          case 2:
           var _hR_=fmt$0[1],_hS_=fmt$0[2];
           if(typeof _hS_ !== "number")
            switch(_hS_[0])
             {case 17:
               var
                rest$2=_hS_[2],
                fmting_lit=_hS_[1],
                match=stopper_of_formatting_lit(fmting_lit),
                str=match[2],
                stp=match[1],
                scan$0=
                 function(width,param,ib)
                  {return scan_string([0,stp],width,ib)},
                str_rest=[11,str,rest$2];
               return pad_prec_scanf
                       (ib,str_rest,readers,_hR_,0,scan$0,token_string);
              case 18:
               var _hT_=_hS_[1];
               if(0 === _hT_[0])
                {var
                  rest$3=_hS_[2],
                  match$0=_hT_[1],
                  fmt$1=match$0[1],
                  scan$1=
                   function(width,param,ib){return scan_string(_cx_,width,ib)};
                 return pad_prec_scanf
                         (ib,
                          concat_fmt(fmt$1,rest$3),
                          readers,
                          _hR_,
                          0,
                          scan$1,
                          token_string)}
               var
                rest$4=_hS_[2],
                match$1=_hT_[1],
                fmt$2=match$1[1],
                scan$2=
                 function(width,param,ib){return scan_string(_cy_,width,ib)};
               return pad_prec_scanf
                       (ib,
                        concat_fmt(fmt$2,rest$4),
                        readers,
                        _hR_,
                        0,
                        scan$2,
                        token_string)
              }
           var
            rest$1=fmt$0[2],
            scan=function(width,param,ib){return scan_string(0,width,ib)};
           return pad_prec_scanf(ib,rest$1,readers,_hR_,0,scan,token_string);
          case 3:
           var
            rest$5=fmt$0[2],
            pad=fmt$0[1],
            scan$3=function(width,param,ib){return scan_caml_string(width,ib)};
           return pad_prec_scanf(ib,rest$5,readers,pad,0,scan$3,token_string);
          case 4:
           var
            rest$6=fmt$0[4],
            prec=fmt$0[3],
            pad$0=fmt$0[2],
            iconv=fmt$0[1],
            conv=integer_conversion_of_char(char_of_iconv(iconv)),
            scan$4=
             function(width,param,ib)
              {return scan_int_conversion(conv,width,ib)};
           return pad_prec_scanf
                   (ib,
                    rest$6,
                    readers,
                    pad$0,
                    prec,
                    scan$4,
                    function(ib)
                     {return caml_int_of_string(token_int_literal(conv,ib))});
          case 5:
           var
            rest$7=fmt$0[4],
            prec$0=fmt$0[3],
            pad$1=fmt$0[2],
            iconv$0=fmt$0[1],
            conv$0=integer_conversion_of_char(char_of_iconv(iconv$0)),
            scan$5=
             function(width,param,ib)
              {return scan_int_conversion(conv$0,width,ib)};
           return pad_prec_scanf
                   (ib,
                    rest$7,
                    readers,
                    pad$1,
                    prec$0,
                    scan$5,
                    function(ib)
                     {return caml_int_of_string(token_int_literal(conv$0,ib))});
          case 6:
           var
            rest$8=fmt$0[4],
            prec$1=fmt$0[3],
            pad$2=fmt$0[2],
            iconv$1=fmt$0[1],
            conv$1=integer_conversion_of_char(char_of_iconv(iconv$1)),
            scan$6=
             function(width,param,ib)
              {return scan_int_conversion(conv$1,width,ib)};
           return pad_prec_scanf
                   (ib,
                    rest$8,
                    readers,
                    pad$2,
                    prec$1,
                    scan$6,
                    function(ib)
                     {return caml_int_of_string(token_int_literal(conv$1,ib))});
          case 7:
           var
            rest$9=fmt$0[4],
            prec$2=fmt$0[3],
            pad$3=fmt$0[2],
            iconv$2=fmt$0[1],
            conv$2=integer_conversion_of_char(char_of_iconv(iconv$2)),
            scan$7=
             function(width,param,ib)
              {return scan_int_conversion(conv$2,width,ib)};
           return pad_prec_scanf
                   (ib,
                    rest$9,
                    readers,
                    pad$3,
                    prec$2,
                    scan$7,
                    function(ib)
                     {return caml_int64_of_string(token_int_literal(conv$2,ib))});
          case 8:
           switch(fmt$0[1][2])
            {case 5:
             case 8:
              var rest$11=fmt$0[4],prec$4=fmt$0[3],pad$5=fmt$0[2];
              return pad_prec_scanf
                      (ib,
                       rest$11,
                       readers,
                       pad$5,
                       prec$4,
                       scan_caml_float,
                       token_float);
             case 6:
             case 7:
              var rest$12=fmt$0[4],prec$5=fmt$0[3],pad$6=fmt$0[2];
              return pad_prec_scanf
                      (ib,rest$12,readers,pad$6,prec$5,scan_hex_float,token_float);
             default:
              var rest$10=fmt$0[4],prec$3=fmt$0[3],pad$4=fmt$0[2];
              return pad_prec_scanf
                      (ib,rest$10,readers,pad$4,prec$3,scan_float,token_float)}
          case 9:
           var
            rest$13=fmt$0[2],
            pad$7=fmt$0[1],
            scan$8=
             function(param,_h3_,ib)
              {var
                c=checked_peek_char(ib),
                m=
                 102 === c
                  ?5
                  :116 === c?4:bad_input(caml_call1(sprintf(_cu_),c));
               return scan_string(0,m,ib)};
           return pad_prec_scanf(ib,rest$13,readers,pad$7,0,scan$8,token_bool);
          case 10:
           var rest$14=fmt$0[1];
           if(end_of_input(ib)){var fmt$0=rest$14;continue}
           return bad_input(cst_end_of_input_not_found);
          case 11:
           var rest$15=fmt$0[2],str$0=fmt$0[1];
           iter$4(function(_h2_){return check_char(ib,_h2_)},str$0);
           var fmt$0=rest$15;
           continue;
          case 12:
           var rest$16=fmt$0[2],chr=fmt$0[1];
           check_char(ib,chr);
           var fmt$0=rest$16;
           continue;
          case 13:
           var rest$17=fmt$0[3],fmtty=fmt$0[2],pad_opt=fmt$0[1];
           scan_caml_string(width_of_pad_opt(pad_opt),ib);
           var s=token_string(ib);
           try
            {var _hU_=format_of_string_fmtty(s,fmtty),fmt$3=_hU_}
           catch(exn)
            {exn = caml_wrap_exception(exn);
             if(exn[1] !== Failure)throw exn;
             var msg=exn[2],fmt$3=bad_input(msg)}
           return [0,fmt$3,make_scanf(ib,rest$17,readers)];
          case 14:
           var rest$18=fmt$0[3],fmtty$0=fmt$0[2],pad_opt$0=fmt$0[1];
           scan_caml_string(width_of_pad_opt(pad_opt$0),ib);
           var s$0=token_string(ib);
           try
            {var
              match$2=fmt_ebb_of_string(0,s$0),
              fmt$6=match$2[1],
              match$3=fmt_ebb_of_string(0,s$0),
              fmt$7=match$3[1],
              fmt$8=type_format(fmt$7,erase_rel(symm(fmtty$0))),
              _hW_=type_format(fmt$6,erase_rel(fmtty$0)),
              fmt$5=fmt$8,
              fmt$4=_hW_}
           catch(exn)
            {exn = caml_wrap_exception(exn);
             if(exn[1] !== Failure)throw exn;
             var
              msg$0=exn[2],
              _hV_=bad_input(msg$0),
              fmt$5=_hV_[2],
              fmt$4=_hV_[1]}
           return [0,
                   [0,fmt$4,s$0],
                   make_scanf(ib,concat_fmt(fmt$5,rest$18),readers)];
          case 15:return invalid_arg(cst_scanf_bad_conversion_a);
          case 16:return invalid_arg(cst_scanf_bad_conversion_t);
          case 17:
           var
            rest$19=fmt$0[2],
            formatting_lit=fmt$0[1],
            _hX_=string_of_formatting_lit(formatting_lit);
           iter$4(function(_h1_){return check_char(ib,_h1_)},_hX_);
           var fmt$0=rest$19;
           continue;
          case 18:
           var _hY_=fmt$0[1];
           if(0 === _hY_[0])
            {var rest$20=fmt$0[2],match$4=_hY_[1],fmt$9=match$4[1];
             check_char(ib,64);
             check_char(ib,123);
             var fmt$10=concat_fmt(fmt$9,rest$20),fmt$0=fmt$10;
             continue}
           var rest$21=fmt$0[2],match$5=_hY_[1],fmt$11=match$5[1];
           check_char(ib,64);
           check_char(ib,91);
           var fmt$12=concat_fmt(fmt$11,rest$21),fmt$0=fmt$12;
           continue;
          case 19:
           var fmt_rest=fmt$0[1];
           if(readers)
            {var
              readers_rest=readers[2],
              reader=readers[1],
              x=caml_call1(reader,ib);
             return [0,x,make_scanf(ib,fmt_rest,readers_rest)]}
           return invalid_arg(cst_scanf_missing_reader);
          case 20:
           var _hZ_=fmt$0[1],_h0_=fmt$0[3];
           if(typeof _h0_ !== "number" && 17 === _h0_[0])
            {var
              rest$23=_h0_[2],
              fmting_lit$0=_h0_[1],
              char_set$0=fmt$0[2],
              match$6=stopper_of_formatting_lit(fmting_lit$0),
              str$1=match$6[2],
              stp$0=match$6[1],
              width$0=width_of_pad_opt(_hZ_);
             scan_chars_in_char_set(char_set$0,[0,stp$0],width$0,ib);
             var s$2=token_string(ib),str_rest$0=[11,str$1,rest$23];
             return [0,s$2,make_scanf(ib,str_rest$0,readers)]}
           var
            rest$22=fmt$0[3],
            char_set=fmt$0[2],
            width=width_of_pad_opt(_hZ_);
           scan_chars_in_char_set(char_set,0,width,ib);
           var s$1=token_string(ib);
           return [0,s$1,make_scanf(ib,rest$22,readers)];
          case 21:
           var
            rest$24=fmt$0[2],
            counter=fmt$0[1],
            count=get_counter(ib,counter);
           return [0,count,make_scanf(ib,rest$24,readers)];
          case 22:
           var rest$25=fmt$0[1],c$1=checked_peek_char(ib);
           return [0,c$1,make_scanf(ib,rest$25,readers)];
          case 23:
           var
            rest$26=fmt$0[2],
            ign=fmt$0[1],
            match$7=param_format_of_ignored_format(ign,rest$26),
            fmt$13=match$7[1],
            match$8=make_scanf(ib,fmt$13,readers);
           if(match$8){var arg_rest=match$8[2];return arg_rest}
           throw [0,Assert_failure,_cz_];
          default:return invalid_arg(cst_scanf_bad_conversion_custo)}}
    function pad_prec_scanf(ib,fmt,readers,pad,prec,scan,token)
     {if(typeof pad === "number")
       {if(typeof prec === "number")
         {if(prec)return invalid_arg(cst_scanf_bad_conversion);
          caml_call3(scan,max_int,max_int,ib);
          var x=caml_call1(token,ib);
          return [0,x,make_scanf(ib,fmt,readers)]}
        var p=prec[1];
        caml_call3(scan,max_int,p,ib);
        var x$0=caml_call1(token,ib);
        return [0,x$0,make_scanf(ib,fmt,readers)]}
      else
       {if(0 === pad[0])
         {if(pad[1])
           {var _hQ_=pad[2];
            if(typeof prec === "number")
             {if(prec)return invalid_arg(cst_scanf_bad_conversion$0);
              caml_call3(scan,_hQ_,max_int,ib);
              var x$1=caml_call1(token,ib);
              return [0,x$1,make_scanf(ib,fmt,readers)]}
            var p$0=prec[1];
            caml_call3(scan,_hQ_,p$0,ib);
            var x$2=caml_call1(token,ib);
            return [0,x$2,make_scanf(ib,fmt,readers)]}
          return invalid_arg(cst_scanf_bad_conversion$1)}
        return invalid_arg(cst_scanf_bad_conversion$2)}}
    function kscanf(ib,ef,param)
     {var str=param[2],fmt=param[1];
      function apply(f,args)
       {var f$0=f,args$0=args;
        for(;;)
         {if(args$0)
           {var
             r=args$0[2],
             x=args$0[1],
             f$1=caml_call1(f$0,x),
             f$0=f$1,
             args$0=r;
            continue}
          return f$0}}
      function k(readers,f)
       {reset_token(ib);
        try
         {var _hP_=[0,make_scanf(ib,fmt,readers)],_hO_=_hP_}
        catch(exc)
         {exc = caml_wrap_exception(exc);
          var switch$0=0;
          if
           (exc[1]
            !==
            Scan_failure
            &&
            exc[1]
            !==
            Failure
            &&
            exc
            !==
            End_of_file)
           {if(exc[1] !== Invalid_argument)throw exc;
            var
             msg=exc[2],
             _hN_=
              invalid_arg
               (symbol
                 (msg,symbol(cst_in_format,symbol(escaped$1(str),cst$88))));
            switch$0 = 1}
          if(! switch$0)var _hN_=[1,exc];
          var _hO_=_hN_}
        if(0 === _hO_[0]){var args=_hO_[1];return apply(f,args)}
        var exc=_hO_[1];
        return caml_call2(ef,ib,exc)}
      return take_format_readers(k,fmt)}
    function bscanf(ib,fmt){return kscanf(ib,scanf_bad_input,fmt)}
    function ksscanf(s,ef,fmt){return kscanf(from_string$1(s),ef,fmt)}
    function sscanf(s,fmt)
     {return kscanf(from_string$1(s),scanf_bad_input,fmt)}
    function scanf(fmt){return kscanf(stdib,scanf_bad_input,fmt)}
    function bscanf_format(ib,format,f)
     {scan_caml_string(max_int,ib);
      var str=token_string(ib);
      try
       {var _hM_=format_of_string_format(str,format),fmt=_hM_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] !== Failure)throw exn;
        var msg=exn[2],fmt=bad_input(msg)}
      return caml_call1(f,fmt)}
    function sscanf_format(s,format,f)
     {return bscanf_format(from_string$1(s),format,f)}
    function format_from_string(s,fmt)
     {function _hL_(x){return x}
      return sscanf_format
              (symbol(cst$90,symbol(escaped$1(s),cst$89)),fmt,_hL_)}
    function unescaped(s)
     {function _hK_(x){return x}
      return caml_call1(sscanf(symbol(cst$92,symbol(s,cst$91)),_cA_),_hK_)}
    function kfscanf(ic,ef,fmt){return kscanf(memo_from_channel(ic),ef,fmt)}
    function fscanf(ic,fmt)
     {return kscanf(memo_from_channel(ic),scanf_bad_input,fmt)}
    var
     Stdlib_scanf=
      [0,
       [0,
        stdib,
        from_file,
        from_file_bin,
        close_in$0,
        from_file,
        from_file_bin,
        from_string$1,
        from_function$0,
        from_channel$0,
        end_of_input,
        beginning_of_input,
        name_of_input,
        stdib],
       Scan_failure,
       bscanf,
       sscanf,
       scanf,
       kscanf,
       ksscanf,
       bscanf_format,
       sscanf_format,
       format_from_string,
       unescaped,
       fscanf,
       kfscanf];
    caml_register_global(802,Stdlib_scanf,"Stdlib__scanf");
    function register(name,v){return caml_register_named_value(name,v)}
    function register_exception(name,exn)
     {var slot=caml_obj_tag(exn) === 248?exn:exn[1];
      return caml_register_named_value(name,slot)}
    var Stdlib_callback=[0,register,register_exception];
    caml_register_global(803,Stdlib_callback,"Stdlib__callback");
    function copy$7(o){var o$0=o.slice();return caml_set_oo_id(o$0)}
    var params$0=[0,1,1,1,3,16],initial_object_size=2,dummy_item=0;
    function public_method_label(s)
     {var accu=[0,0],_hH_=caml_ml_string_length(s) - 1 | 0,_hG_=0;
      if(! (_hH_ < 0))
       {var i=_hG_;
        for(;;)
         {var _hI_=caml_string_get(s,i);
          accu[1] = (223 * accu[1] | 0) + _hI_ | 0;
          var _hJ_=i + 1 | 0;
          if(_hH_ !== i){var i=_hJ_;continue}
          break}}
      accu[1] = accu[1] & 2147483647;
      var tag=1073741823 < accu[1]?accu[1] + 2147483648 | 0:accu[1];
      return tag}
    function compare$13(x,y){return caml_string_compare(x,y)}
    var Vars=caml_call1(Stdlib_map[1],[0,compare$13]);
    function compare$14(x,y){return caml_string_compare(x,y)}
    var
     Meths=caml_call1(Stdlib_map[1],[0,compare$14]),
     compare$15=caml_int_compare,
     Labs=caml_call1(Stdlib_map[1],[0,compare$15]),
     dummy_table=[0,0,[0,dummy_item],Meths[1],Labs[1],0,0,Vars[1],0],
     table_count=[0,0],
     dummy_met=caml_obj_block(0,0);
    function fit_size(n){return 2 < n?fit_size((n + 1 | 0) / 2 | 0) * 2 | 0:n}
    function new_table(pub_labels)
     {table_count[1]++;
      var
       len=pub_labels.length - 1,
       methods=caml_make_vect((len * 2 | 0) + 2 | 0,dummy_met);
      caml_check_bound(methods,0)[1] = len;
      var _hA_=((fit_size(len) * 32 | 0) / 8 | 0) - 1 | 0;
      caml_check_bound(methods,1)[2] = _hA_;
      var _hC_=len - 1 | 0,_hB_=0;
      if(! (_hC_ < 0))
       {var i=_hB_;
        for(;;)
         {var
           _hE_=(i * 2 | 0) + 3 | 0,
           _hD_=caml_check_bound(pub_labels,i)[1 + i];
          caml_check_bound(methods,_hE_)[1 + _hE_] = _hD_;
          var _hF_=i + 1 | 0;
          if(_hC_ !== i){var i=_hF_;continue}
          break}}
      return [0,initial_object_size,methods,Meths[1],Labs[1],0,0,Vars[1],0]}
    function resize$1(array,new_size)
     {var old_size=array[2].length - 1,_hy_=old_size < new_size?1:0;
      if(_hy_)
       {var new_buck=caml_make_vect(new_size,dummy_met);
        blit$1(array[2],0,new_buck,0,old_size);
        array[2] = new_buck;
        var _hz_=0}
      else
       var _hz_=_hy_;
      return _hz_}
    var method_count=[0,0],inst_var_count=[0,0];
    function new_method(table)
     {var index=table[2].length - 1;
      resize$1(table,index + 1 | 0);
      return index}
    function get_method_label(table,name)
     {try
       {var _hw_=caml_call2(Meths[28],name,table[3]);return _hw_}
      catch(_hx_)
       {_hx_ = caml_wrap_exception(_hx_);
        if(_hx_ === Not_found)
         {var label=new_method(table);
          table[3] = caml_call3(Meths[4],name,label,table[3]);
          table[4] = caml_call3(Labs[4],label,1,table[4]);
          return label}
        throw _hx_}}
    function get_method_labels(table,names)
     {return map$6(function(_hv_){return get_method_label(table,_hv_)},names)}
    function set_method(table,label,element)
     {method_count[1]++;
      return caml_call2(Labs[28],label,table[4])
              ?(resize$1(table,label + 1 | 0),
                caml_check_bound(table[2],label)[1 + label]
                =
                element,
                0)
              :(table[6] = [0,[0,label,element],table[6]],0)}
    function get_method(table,label)
     {try
       {var _ht_=assoc(label,table[6]);return _ht_}
      catch(_hu_)
       {_hu_ = caml_wrap_exception(_hu_);
        if(_hu_ === Not_found)
         return caml_check_bound(table[2],label)[1 + label];
        throw _hu_}}
    function to_list$3(arr){return 0 === arr?0:to_list$1(arr)}
    function narrow(table,vars,virt_meths,concr_meths)
     {var
       vars$0=to_list$3(vars),
       virt_meths$0=to_list$3(virt_meths),
       concr_meths$0=to_list$3(concr_meths),
       virt_meth_labs=
        map$3
         (function(_hs_){return get_method_label(table,_hs_)},virt_meths$0),
       concr_meth_labs=
        map$3
         (function(_hr_){return get_method_label(table,_hr_)},concr_meths$0);
      table[5]
      =
      [0,
       [0,table[3],table[4],table[6],table[7],virt_meth_labs,vars$0],
       table[5]];
      var _hi_=Vars[1],_hj_=table[7];
      function _hk_(lab,info,tvars)
       {return mem(lab,vars$0)?caml_call3(Vars[4],lab,info,tvars):tvars}
      table[7] = caml_call3(Vars[13],_hk_,_hj_,_hi_);
      var by_name=[0,Meths[1]],by_label=[0,Labs[1]];
      iter2
       (function(met,label)
         {by_name[1] = caml_call3(Meths[4],met,label,by_name[1]);
          var _hn_=by_label[1];
          try
           {var _hp_=caml_call2(Labs[28],label,table[4]),_ho_=_hp_}
          catch(_hq_)
           {_hq_ = caml_wrap_exception(_hq_);
            if(_hq_ !== Not_found)throw _hq_;
            var _ho_=1}
          by_label[1] = caml_call3(Labs[4],label,_ho_,_hn_);
          return 0},
        concr_meths$0,
        concr_meth_labs);
      iter2
       (function(met,label)
         {by_name[1] = caml_call3(Meths[4],met,label,by_name[1]);
          by_label[1] = caml_call3(Labs[4],label,0,by_label[1]);
          return 0},
        virt_meths$0,
        virt_meth_labs);
      table[3] = by_name[1];
      table[4] = by_label[1];
      var _hl_=0,_hm_=table[6];
      table[6]
      =
      fold_right
       (function(met,hm)
         {var lab=met[1];return mem(lab,virt_meth_labs)?hm:[0,met,hm]},
        _hm_,
        _hl_);
      return 0}
    function widen(table)
     {var
       match=hd(table[5]),
       vars=match[6],
       virt_meths=match[5],
       saved_vars=match[4],
       saved_hidden_meths=match[3],
       by_label=match[2],
       by_name=match[1];
      table[5] = tl(table[5]);
      table[7]
      =
      fold_left$0
       (function(s,v)
         {var _hh_=caml_call2(Vars[28],v,table[7]);
          return caml_call3(Vars[4],v,_hh_,s)},
        saved_vars,
        vars);
      table[3] = by_name;
      table[4] = by_label;
      var _hg_=table[6];
      table[6]
      =
      fold_right
       (function(met,hm)
         {var lab=met[1];return mem(lab,virt_meths)?hm:[0,met,hm]},
        _hg_,
        saved_hidden_meths);
      return 0}
    function new_slot(table)
     {var index=table[1];table[1] = index + 1 | 0;return index}
    function new_variable(table,name)
     {try
       {var _he_=caml_call2(Vars[28],name,table[7]);return _he_}
      catch(_hf_)
       {_hf_ = caml_wrap_exception(_hf_);
        if(_hf_ === Not_found)
         {var index=new_slot(table);
          if(caml_string_notequal(name,cst$93))
           table[7] = caml_call3(Vars[4],name,index,table[7]);
          return index}
        throw _hf_}}
    function to_array(arr){return caml_equal(arr,0)?[0]:arr}
    function new_methods_variables(table,meths,vals)
     {var
       meths$0=to_array(meths),
       nmeths=meths$0.length - 1,
       nvals=vals.length - 1,
       res=caml_make_vect(nmeths + nvals | 0,0),
       _g8_=nmeths - 1 | 0,
       _g7_=0;
      if(! (_g8_ < 0))
       {var i$0=_g7_;
        for(;;)
         {var
           _hc_=
            get_method_label(table,caml_check_bound(meths$0,i$0)[1 + i$0]);
          caml_check_bound(res,i$0)[1 + i$0] = _hc_;
          var _hd_=i$0 + 1 | 0;
          if(_g8_ !== i$0){var i$0=_hd_;continue}
          break}}
      var _g__=nvals - 1 | 0,_g9_=0;
      if(! (_g__ < 0))
       {var i=_g9_;
        for(;;)
         {var
           _ha_=i + nmeths | 0,
           _g$_=new_variable(table,caml_check_bound(vals,i)[1 + i]);
          caml_check_bound(res,_ha_)[1 + _ha_] = _g$_;
          var _hb_=i + 1 | 0;
          if(_g__ !== i){var i=_hb_;continue}
          break}}
      return res}
    function get_variable(table,name)
     {try
       {var _g5_=caml_call2(Vars[28],name,table[7]);return _g5_}
      catch(_g6_)
       {_g6_ = caml_wrap_exception(_g6_);
        if(_g6_ === Not_found)throw [0,Assert_failure,_cB_];
        throw _g6_}}
    function get_variables(table,names)
     {return map$6(function(_g4_){return get_variable(table,_g4_)},names)}
    function add_initializer(table,f){table[8] = [0,f,table[8]];return 0}
    function create_table(public_methods)
     {if(0 === public_methods)return new_table([0]);
      var
       tags=map$6(public_method_label,public_methods),
       table=new_table(tags);
      iteri$2
       (function(i,met)
         {var lab=(i * 2 | 0) + 2 | 0;
          table[3] = caml_call3(Meths[4],met,lab,table[3]);
          table[4] = caml_call3(Labs[4],lab,1,table[4]);
          return 0},
        public_methods);
      return table}
    function init_class(table)
     {inst_var_count[1] = (inst_var_count[1] + table[1] | 0) - 1 | 0;
      table[8] = rev(table[8]);
      return resize$1
              (table,
               3 + ((caml_check_bound(table[2],1)[2] * 16 | 0) / 32 | 0) | 0)}
    function inherits(cla,vals,virt_meths,concr_meths,param,top)
     {var env=param[4],super$0=param[2];
      narrow(cla,vals,virt_meths,concr_meths);
      var init=top?caml_call2(super$0,cla,env):caml_call1(super$0,cla);
      widen(cla);
      var
       _gZ_=0,
       _g0_=to_array(concr_meths),
       _g1_=
        [0,
         map$6
          (function(nm){return get_method(cla,get_method_label(cla,nm))},_g0_),
         _gZ_],
       _g2_=to_array(vals);
      return caml_array_concat
              ([0,
                [0,init],
                [0,
                 map$6(function(_g3_){return get_variable(cla,_g3_)},_g2_),
                 _g1_]])}
    function make_class(pub_meths,class_init)
     {var table=create_table(pub_meths),env_init=caml_call1(class_init,table);
      init_class(table);
      return [0,caml_call1(env_init,0),class_init,env_init,0]}
    function make_class_store(pub_meths,class_init,init_table)
     {var table=create_table(pub_meths),env_init=caml_call1(class_init,table);
      init_class(table);
      init_table[2] = class_init;
      init_table[1] = env_init;
      return 0}
    function dummy_class(loc)
     {function undef(param){throw [0,Undefined_recursive_module,loc]}
      return [0,undef,undef,undef,0]}
    function create_object(table)
     {var obj=caml_obj_block(248,table[1]);
      obj[1] = table[2];
      return caml_set_oo_id(obj)}
    function create_object_opt(obj_0,table)
     {if(obj_0)return obj_0;
      var obj=caml_obj_block(248,table[1]);
      obj[1] = table[2];
      return caml_set_oo_id(obj)}
    function iter_f(obj,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],f=param$0[1];
          caml_call1(f,obj);
          var param$0=l;
          continue}
        return 0}}
    function run_initializers(obj,table)
     {var inits=table[8],_gY_=0 !== inits?1:0;
      return _gY_?iter_f(obj,inits):_gY_}
    function run_initializers_opt(obj_0,obj,table)
     {if(obj_0)return obj;
      var inits=table[8];
      if(0 !== inits)iter_f(obj,inits);
      return obj}
    function create_object_and_run_initiali(obj_0,table)
     {if(obj_0)return obj_0;
      var obj=create_object(table);
      run_initializers(obj,table);
      return obj}
    function get_data$0(param)
     {if(param)return param[2];throw [0,Assert_failure,_cF_]}
    function build_path(n,keys,tables)
     {var res=[0,0,0,0],r=[0,res],_gU_=0;
      if(! (n < 0))
       {var i=_gU_;
        for(;;)
         {var _gW_=r[1];
          r[1] = [0,caml_check_bound(keys,i)[1 + i],_gW_,0];
          var _gX_=i + 1 | 0;
          if(n !== i){var i=_gX_;continue}
          break}}
      var _gV_=r[1];
      if(tables){tables[2] = _gV_;return res}
      throw [0,Assert_failure,_cC_]}
    function lookup_tables(root,keys)
     {var tables$2=get_data$0(root);
      if(tables$2)
       {var i$1=keys.length - 1 - 1 | 0,i=i$1,tables=tables$2;
        a:
        for(;;)
         {if(0 <= i)
           {var key=caml_check_bound(keys,i)[1 + i],tables$0=tables;
            for(;;)
             {if(tables$0)
               {if(tables$0[1] === key)
                 {var tables$1=get_data$0(tables$0);
                  if(tables$1)
                   {var i$0=i - 1 | 0,i=i$0,tables=tables$1;continue a}
                  throw [0,Assert_failure,_cH_]}
                if(tables$0)
                 {var _gT_=tables$0[3];
                  if(_gT_){var tables$0=_gT_;continue}
                  var v=[0,key,0,0];
                  if(tables$0)
                   {tables$0[3] = v;return build_path(i - 1 | 0,keys,v)}
                  throw [0,Assert_failure,_cD_]}
                throw [0,Assert_failure,_cG_]}
              throw [0,Assert_failure,_cE_]}}
          return tables}}
      return build_path(keys.length - 1 - 1 | 0,keys,root)}
    function new_cache(table)
     {var n=new_method(table),switch$0=0;
      if
       (0
        !==
        (n % 2 | 0)
        &&
        !
        ((2 + ((caml_check_bound(table[2],1)[2] * 16 | 0) / 32 | 0) | 0) < n))
       {var n$0=new_method(table);switch$0 = 1}
      if(! switch$0)var n$0=n;
      caml_check_bound(table[2],n$0)[1 + n$0] = 0;
      return n$0}
    function set_methods(table,methods)
     {var len=methods.length - 1,i=[0,0];
      for(;;)
       {if(i[1] < len)
         {var
           _gN_=i[1],
           label=caml_check_bound(methods,_gN_)[1 + _gN_],
           next=
            function(param)
             {i[1]++;
              var _gS_=i[1];
              return caml_check_bound(methods,_gS_)[1 + _gS_]},
           clo=next(0);
          if(typeof clo === "number")
           switch(clo)
            {case 0:
              var
               x=next(0),
               clo$0=function(x){return function(obj){return x}}(x);
              break;
             case 1:
              var
               n=next(0),
               clo$0=function(n){return function(obj){return obj[1 + n]}}(n);
              break;
             case 2:
              var
               e=next(0),
               n$0=next(0),
               clo$0=
                function(e,n){return function(obj){return obj[1 + e][1 + n]}}
                 (e,n$0);
              break;
             case 3:
              var
               n$1=next(0),
               clo$0=
                function(n)
                  {return function(obj){return caml_call1(obj[1][1 + n],obj)}}
                 (n$1);
              break;
             case 4:
              var
               n$2=next(0),
               clo$0=
                function(n){return function(obj,x){obj[1 + n] = x;return 0}}
                 (n$2);
              break;
             case 5:
              var
               f=next(0),
               x$0=next(0),
               clo$0=
                function(f,x){return function(obj){return caml_call1(f,x)}}
                 (f,x$0);
              break;
             case 6:
              var
               f$0=next(0),
               n$3=next(0),
               clo$0=
                function(f,n)
                  {return function(obj){return caml_call1(f,obj[1 + n])}}
                 (f$0,n$3);
              break;
             case 7:
              var
               f$1=next(0),
               e$0=next(0),
               n$4=next(0),
               clo$0=
                function(f,e,n)
                  {return function(obj)
                    {return caml_call1(f,obj[1 + e][1 + n])}}
                 (f$1,e$0,n$4);
              break;
             case 8:
              var
               f$2=next(0),
               n$5=next(0),
               clo$0=
                function(f,n)
                  {return function(obj)
                    {return caml_call1(f,caml_call1(obj[1][1 + n],obj))}}
                 (f$2,n$5);
              break;
             case 9:
              var
               f$3=next(0),
               x$1=next(0),
               y=next(0),
               clo$0=
                function(f,x,y)
                  {return function(obj){return caml_call2(f,x,y)}}
                 (f$3,x$1,y);
              break;
             case 10:
              var
               f$4=next(0),
               x$2=next(0),
               n$6=next(0),
               clo$0=
                function(f,x,n)
                  {return function(obj){return caml_call2(f,x,obj[1 + n])}}
                 (f$4,x$2,n$6);
              break;
             case 11:
              var
               f$5=next(0),
               x$3=next(0),
               e$1=next(0),
               n$7=next(0),
               clo$0=
                function(f,x,e,n)
                  {return function(obj)
                    {return caml_call2(f,x,obj[1 + e][1 + n])}}
                 (f$5,x$3,e$1,n$7);
              break;
             case 12:
              var
               f$6=next(0),
               x$4=next(0),
               n$8=next(0),
               clo$0=
                function(f,x,n)
                  {return function(obj)
                    {return caml_call2(f,x,caml_call1(obj[1][1 + n],obj))}}
                 (f$6,x$4,n$8);
              break;
             case 13:
              var
               f$7=next(0),
               n$9=next(0),
               x$5=next(0),
               clo$0=
                function(f,n,x)
                  {return function(obj){return caml_call2(f,obj[1 + n],x)}}
                 (f$7,n$9,x$5);
              break;
             case 14:
              var
               f$8=next(0),
               e$2=next(0),
               n$10=next(0),
               x$6=next(0),
               clo$0=
                function(f,e,n,x)
                  {return function(obj)
                    {return caml_call2(f,obj[1 + e][1 + n],x)}}
                 (f$8,e$2,n$10,x$6);
              break;
             case 15:
              var
               f$9=next(0),
               n$11=next(0),
               x$7=next(0),
               clo$0=
                function(f,n,x)
                  {return function(obj)
                    {return caml_call2(f,caml_call1(obj[1][1 + n],obj),x)}}
                 (f$9,n$11,x$7);
              break;
             case 16:
              var
               n$12=next(0),
               x$8=next(0),
               clo$0=
                function(n,x)
                  {return function(obj)
                    {return caml_call2(obj[1][1 + n],obj,x)}}
                 (n$12,x$8);
              break;
             case 17:
              var
               n$13=next(0),
               m=next(0),
               clo$0=
                function(n,m)
                  {return function(obj)
                    {return caml_call2(obj[1][1 + n],obj,obj[1 + m])}}
                 (n$13,m);
              break;
             case 18:
              var
               n$14=next(0),
               e$3=next(0),
               m$0=next(0),
               clo$0=
                function(n,e,m)
                  {return function(obj)
                    {return caml_call2(obj[1][1 + n],obj,obj[1 + e][1 + m])}}
                 (n$14,e$3,m$0);
              break;
             case 19:
              var
               n$15=next(0),
               m$1=next(0),
               clo$0=
                function(n,m)
                  {return function(obj)
                    {var _gQ_=caml_call1(obj[1][1 + m],obj);
                     return caml_call2(obj[1][1 + n],obj,_gQ_)}}
                 (n$15,m$1);
              break;
             case 20:
              var
               m$2=next(0),
               x$9=next(0),
               c=new_cache(table),
               clo$0=
                function(m,x,c)
                  {return function(obj)
                    {return caml_call2(caml_get_public_method(x,m,0),x,c)}}
                 (m$2,x$9,c);
              break;
             case 21:
              var
               m$3=next(0),
               n$16=next(0),
               c$0=new_cache(table),
               clo$0=
                function(m,n,c)
                  {return function(obj)
                    {var _gP_=obj[1 + n];
                     return caml_call2(caml_get_public_method(_gP_,m,0),_gP_,c)}}
                 (m$3,n$16,c$0);
              break;
             case 22:
              var
               m$4=next(0),
               e$4=next(0),
               n$17=next(0),
               c$1=new_cache(table),
               clo$0=
                function(m,e,n,c)
                  {return function(obj)
                    {var _gO_=obj[1 + e][1 + n];
                     return caml_call2(caml_get_public_method(_gO_,m,0),_gO_,c)}}
                 (m$4,e$4,n$17,c$1);
              break;
             default:
              var
               m$5=next(0),
               n$18=next(0),
               c$2=new_cache(table),
               clo$0=
                function(m,n,c)
                  {return function(obj)
                    {var _gR_=caml_call1(obj[1][1 + n],obj);
                     return caml_call2(caml_get_public_method(_gR_,m,0),_gR_,c)}}
                 (m$5,n$18,c$2)}
          else
           var clo$0=clo;
          set_method(table,label,clo$0);
          i[1]++;
          continue}
        return 0}}
    function stats$0(param)
     {return [0,table_count[1],method_count[1],inst_var_count[1]]}
    var
     CamlinternalOO=
      [0,
       public_method_label,
       new_method,
       new_variable,
       new_methods_variables,
       get_variable,
       get_variables,
       get_method_label,
       get_method_labels,
       get_method,
       set_method,
       set_methods,
       narrow,
       widen,
       add_initializer,
       dummy_table,
       create_table,
       init_class,
       inherits,
       make_class,
       make_class_store,
       dummy_class,
       copy$7,
       create_object,
       create_object_opt,
       run_initializers,
       run_initializers_opt,
       create_object_and_run_initiali,
       lookup_tables,
       params$0,
       stats$0];
    caml_register_global(804,CamlinternalOO,"CamlinternalOO");
    var Stdlib_oo=[0,copy$7,public_method_label,public_method_label];
    caml_register_global(805,Stdlib_oo,"Stdlib__oo");
    var
     update_mod=runtime.caml_CamlinternalMod_update_mod,
     init_mod=runtime.caml_CamlinternalMod_init_mod,
     CamlinternalMod=[0,init_mod,update_mod];
    caml_register_global(806,CamlinternalMod,"CamlinternalMod");
    var
     initial_buffer=caml_create_bytes(32),
     buffer=[0,initial_buffer],
     bufpos=[0,0];
    function reset_buffer(param)
     {buffer[1] = initial_buffer;bufpos[1] = 0;return 0}
    function store(c)
     {if(caml_ml_bytes_length(buffer[1]) <= bufpos[1])
       {var newbuffer=caml_create_bytes(2 * bufpos[1] | 0);
        blit(buffer[1],0,newbuffer,0,bufpos[1]);
        buffer[1] = newbuffer}
      caml_bytes_set(buffer[1],bufpos[1],c);
      bufpos[1]++;
      return 0}
    function get_string(param)
     {var s=sub_string(buffer[1],0,bufpos[1]);
      buffer[1] = initial_buffer;
      return s}
    function make_lexer(keywords)
     {var kwd_table=caml_call2(Stdlib_hashtbl[1],0,17);
      iter$2
       (function(s){return caml_call3(Stdlib_hashtbl[5],kwd_table,s,[0,s])},
        keywords);
      function ident_or_keyword(id)
       {try
         {var _gL_=caml_call2(Stdlib_hashtbl[6],kwd_table,id);return _gL_}
        catch(_gM_)
         {_gM_ = caml_wrap_exception(_gM_);
          if(_gM_ === Not_found)return [1,id];
          throw _gM_}}
      function keyword_or_error(c)
       {var s=make$1(1,c);
        try
         {var _gJ_=caml_call2(Stdlib_hashtbl[6],kwd_table,s);return _gJ_}
        catch(_gK_)
         {_gK_ = caml_wrap_exception(_gK_);
          if(_gK_ === Not_found)
           throw [0,Error,symbol(cst_Illegal_character,s)];
          throw _gK_}}
      function comment(strm)
       {a:
        for(;;)
         {var match=peek$0(strm);
          if(match)
           {var switcher=match[1] - 40 | 0;
            if(! (2 < switcher >>> 0))
             switch(switcher)
              {case 0:
                junk(strm);
                var match$0=peek$0(strm);
                if(match$0)
                 {if(42 === match$0[1]){junk(strm);comment(strm);continue}
                  junk(strm);
                  continue}
                throw Failure$0;
               case 1:break;
               default:
                junk(strm);
                for(;;)
                 {var match$1=peek$0(strm);
                  if(match$1)
                   {var _gI_=match$1[1];
                    if(41 === _gI_){junk(strm);return 0}
                    if(42 === _gI_){junk(strm);continue}
                    junk(strm);
                    continue a}
                  throw Failure$0}}
            junk(strm);
            continue}
          throw Failure$0}}
      function escape(strm)
       {var match=peek$0(strm);
        if(match)
         {var _gF_=match[1];
          if(58 <= _gF_)
           {var switcher=_gF_ - 110 | 0;
            if(! (6 < switcher >>> 0))
             switch(switcher)
              {case 0:junk(strm);return 10;
               case 4:junk(strm);return 13;
               case 6:junk(strm);return 9
               }}
          else
           if(48 <= _gF_)
            {junk(strm);
             var match$0=peek$0(strm);
             if(match$0)
              {var _gG_=match$0[1],switcher$0=_gG_ - 48 | 0;
               if(! (9 < switcher$0 >>> 0))
                {junk(strm);
                 var match$1=peek$0(strm);
                 if(match$1)
                  {var _gH_=match$1[1],switcher$1=_gH_ - 48 | 0;
                   if(! (9 < switcher$1 >>> 0))
                    {junk(strm);
                     return chr
                             ((((_gF_ - 48 | 0) * 100 | 0)
                               +
                               ((_gG_ - 48 | 0) * 10 | 0)
                               |
                               0)
                              +
                              (_gH_ - 48 | 0)
                              |
                              0)}}
                 throw [0,Error,cst$99]}}
             throw [0,Error,cst$98]}
          junk(strm);
          return _gF_}
        throw Failure$0}
      function end_exponent_part(strm)
       {for(;;)
         {var match=peek$0(strm);
          if(match)
           {var _gE_=match[1],switcher=_gE_ - 48 | 0;
            if(! (9 < switcher >>> 0)){junk(strm);store(_gE_);continue}}
          return [0,[3,caml_float_of_string(get_string(0))]]}}
      function exponent_part(strm)
       {var match=peek$0(strm);
        if(match)
         {var _gD_=match[1],switch$0=0;
          if(43 !== _gD_ && 45 !== _gD_)switch$0 = 1;
          if(! switch$0)
           {junk(strm);store(_gD_);return end_exponent_part(strm)}}
        return end_exponent_part(strm)}
      function number(s)
       {for(;;)
         {var match=peek$0(s);
          if(match)
           {var _gA_=match[1];
            if(58 <= _gA_)
             {var switch$0=0;
              if(69 === _gA_ || 101 === _gA_)switch$0 = 1;
              if(switch$0){junk(s);store(69);return exponent_part(s)}}
            else
             {if(46 === _gA_)
               {junk(s);
                store(46);
                for(;;)
                 {var match$0=peek$0(s);
                  if(match$0)
                   {var _gB_=match$0[1],_gC_=_gB_ - 69 | 0;
                    if(32 < _gC_ >>> 0)
                     {var switcher=_gC_ + 21 | 0;
                      if(! (9 < switcher >>> 0)){junk(s);store(_gB_);continue}}
                    else
                     {var switcher$0=_gC_ - 1 | 0;
                      if(30 < switcher$0 >>> 0)
                       {junk(s);store(69);return exponent_part(s)}}}
                  return [0,[3,caml_float_of_string(get_string(0))]]}}
              if(48 <= _gA_){junk(s);store(_gA_);continue}}}
          return [0,[2,caml_int_of_string(get_string(0))]]}}
      function ident2(strm)
       {for(;;)
         {var match=peek$0(strm);
          if(match)
           {var _gy_=match[1],switch$0=0;
            if(94 <= _gy_)
             {var _gz_=_gy_ - 95 | 0;
              if(30 < _gz_ >>> 0)
               {if(! (32 <= _gz_))switch$0 = 1}
              else
               if(29 === _gz_)switch$0 = 1}
            else
             if(65 <= _gy_)
              {if(92 === _gy_)switch$0 = 1}
             else
              if(33 <= _gy_)
               switch(_gy_ - 33 | 0)
                {case 0:
                 case 2:
                 case 3:
                 case 4:
                 case 5:
                 case 9:
                 case 10:
                 case 12:
                 case 14:
                 case 25:
                 case 27:
                 case 28:
                 case 29:
                 case 30:
                 case 31:switch$0 = 1;break
                 }
            if(switch$0){junk(strm);store(_gy_);continue}}
          return [0,ident_or_keyword(get_string(0))]}}
      function neg_number(s)
       {var match=peek$0(s);
        if(match)
         {var _gx_=match[1],switcher=_gx_ - 48 | 0;
          if(! (9 < switcher >>> 0))
           {junk(s);reset_buffer(0);store(45);store(_gx_);return number(s)}}
        reset_buffer(0);
        store(45);
        return ident2(s)}
      function ident(strm)
       {for(;;)
         {var match=peek$0(strm);
          if(match)
           {var _gv_=match[1],switch$0=0;
            if(91 <= _gv_)
             {var _gw_=_gv_ - 95 | 0;
              if(27 < _gw_ >>> 0)
               {if(97 <= _gw_)switch$0 = 1}
              else
               if(1 !== _gw_)switch$0 = 1}
            else
             if(48 <= _gv_)
              {if(6 < (_gv_ - 58 | 0) >>> 0)switch$0 = 1}
             else
              if(39 === _gv_)switch$0 = 1;
            if(switch$0){junk(strm);store(_gv_);continue}}
          return [0,ident_or_keyword(get_string(0))]}}
      function next_token$0(counter,strm)
       {for(;;)
         {var match=peek$0(strm);
          if(match)
           {var _gl_=match[1],switch$0=0;
            if(124 <= _gl_)
             {if(127 <= _gl_)
               {if(192 <= _gl_)switch$0 = 1}
              else
               if(125 !== _gl_)switch$0 = 2}
            else
             {var _gm_=_gl_ - 65 | 0;
              if(57 < _gm_ >>> 0)
               {if(! (58 <= _gm_))
                 {var switcher=_gm_ + 65 | 0;
                  switch(switcher)
                   {case 34:
                     junk(strm);
                     reset_buffer(0);
                     for(;;)
                      {var match$1=peek$0(strm);
                       if(match$1)
                        {var _go_=match$1[1];
                         if(34 === _go_){junk(strm);return [0,[4,get_string(0)]]}
                         if(92 === _go_)
                          {junk(strm);
                           try
                            {var c$0=escape(strm)}
                           catch(_gu_)
                            {_gu_ = caml_wrap_exception(_gu_);
                             if(_gu_ === Failure$0)throw [0,Error,cst$96];
                             throw _gu_;
                             var _gr_=_gu_}
                           store(c$0);
                           continue}
                         junk(strm);
                         store(_go_);
                         continue}
                       throw Failure$0}
                    case 39:
                     junk(strm);
                     try
                      {var match$2=peek$0(strm);
                       if(! match$2)throw Failure$0;
                       var _gp_=match$2[1];
                       if(92 === _gp_)
                        {junk(strm);
                         try
                          {var _gq_=escape(strm)}
                         catch(_gt_)
                          {_gt_ = caml_wrap_exception(_gt_);
                           if(_gt_ === Failure$0)throw [0,Error,cst$97];
                           throw _gt_}
                         var c=_gq_}
                       else
                        {junk(strm);var c=_gp_}}
                     catch(_gs_)
                      {_gs_ = caml_wrap_exception(_gs_);
                       if(_gs_ === Failure$0)throw [0,Error,cst$94];
                       throw _gs_}
                     var match$0=peek$0(strm);
                     if(match$0 && 39 === match$0[1])
                      {junk(strm);return [0,[5,c]]}
                     throw [0,Error,cst$95];
                    case 40:
                     junk(strm);
                     if(counter < 50)
                      {var counter$0=counter + 1 | 0;
                       return maybe_comment(counter$0,strm)}
                     return caml_trampoline_return(maybe_comment,[0,strm]);
                    case 45:junk(strm);return neg_number(strm);
                    case 9:
                    case 10:
                    case 12:
                    case 13:
                    case 26:
                    case 32:junk(strm);continue;
                    case 48:
                    case 49:
                    case 50:
                    case 51:
                    case 52:
                    case 53:
                    case 54:
                    case 55:
                    case 56:
                    case 57:
                     junk(strm);reset_buffer(0);store(_gl_);return number(strm);
                    case 33:
                    case 35:
                    case 36:
                    case 37:
                    case 38:
                    case 42:
                    case 43:
                    case 47:
                    case 58:
                    case 60:
                    case 61:
                    case 62:
                    case 63:
                    case 64:switch$0 = 2;break
                    }}}
              else
               {var _gn_=_gm_ - 26 | 0;
                if(5 < _gn_ >>> 0)
                 switch$0 = 1;
                else
                 switch(_gn_)
                  {case 4:switch$0 = 1;break;case 1:case 3:switch$0 = 2;break}}}
            switch(switch$0)
             {case 0:junk(strm);return [0,keyword_or_error(_gl_)];
              case 1:
               junk(strm);reset_buffer(0);store(_gl_);return ident(strm);
              default:
               junk(strm);reset_buffer(0);store(_gl_);return ident2(strm)}}
          return 0}}
      function maybe_comment(counter,strm)
       {var match=peek$0(strm);
        if(match && 42 === match[1])
         {junk(strm);
          comment(strm);
          if(counter < 50)
           {var counter$0=counter + 1 | 0;return next_token$0(counter$0,strm)}
          return caml_trampoline_return(next_token$0,[0,strm])}
        return [0,keyword_or_error(40)]}
      function next_token(strm){return caml_trampoline(next_token$0(0,strm))}
      return function(input)
       {return from(function(count){return next_token(input)})}}
    var Stdlib_genlex=[0,make_lexer];
    caml_register_global(807,Stdlib_genlex,"Stdlib__genlex");
    function MakeSeeded$0(H)
     {var prng=[246,function(_gk_){return caml_call1(_b$_[2],0)}];
      function create(opt,initial_size)
       {if(opt)
         var sth=opt[1],random=sth;
        else
         var random=caml_call1(Stdlib_hashtbl[17],0);
        var x=16;
        for(;;)
         {if(! (initial_size <= x) && ! (max_array_length < (x * 2 | 0)))
           {var x$0=x * 2 | 0,x=x$0;continue}
          if(random)
           var
            _gi_=caml_obj_tag(prng),
            _gj_=250 === _gi_?prng[1]:246 === _gi_?force_lazy_block(prng):prng,
            seed=caml_call1(_b$_[4],_gj_);
          else
           var seed=0;
          return [0,0,caml_make_vect(x,0),seed,x]}}
      function clear(h)
       {h[1] = 0;
        var len=h[2].length - 1,_gg_=len - 1 | 0,_gf_=0;
        if(! (_gg_ < 0))
         {var i=_gf_;
          for(;;)
           {caml_check_bound(h[2],i)[1 + i] = 0;
            var _gh_=i + 1 | 0;
            if(_gg_ !== i){var i=_gh_;continue}
            break}}
        return 0}
      function reset(h)
       {var len=h[2].length - 1;
        return len === h[4]
                ?clear(h)
                :(h[1] = 0,h[2] = caml_make_vect(h[4],0),0)}
      function copy(init)
       {var _gc_=init[4],_gd_=init[3],_ge_=copy$1(init[2]);
        return [0,init[1],_ge_,_gd_,_gc_]}
      function key_index(h,hkey){return hkey & (h[2].length - 1 - 1 | 0)}
      function clean(h)
       {function do_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var hkey=param$0[1],rest=param$0[3],c=param$0[2];
              if(caml_call1(H[7],c))
               {var rest$0=param$0[3],c$0=param$0[2];
                return [0,hkey,c$0,do_bucket(rest$0)]}
              h[1] = h[1] - 1 | 0;
              var param$0=rest;
              continue}
            return 0}}
        var d=h[2],_f$_=d.length - 1 - 1 | 0,_f__=0;
        if(! (_f$_ < 0))
         {var i=_f__;
          for(;;)
           {var _ga_=do_bucket(caml_check_bound(d,i)[1 + i]);
            caml_check_bound(d,i)[1 + i] = _ga_;
            var _gb_=i + 1 | 0;
            if(_f$_ !== i){var i=_gb_;continue}
            break}}
        return 0}
      function resize(h)
       {var odata=h[2],osize=odata.length - 1,nsize=osize * 2 | 0;
        clean(h);
        var
         _f3_=nsize < max_array_length?1:0,
         _f4_=_f3_?(osize >>> 1 | 0) <= h[1]?1:0:_f3_;
        if(_f4_)
         {var ndata=caml_make_vect(nsize,0);
          h[2] = ndata;
          var
           insert_bucket=
            function(param)
             {if(param)
               {var rest=param[3],data=param[2],hkey=param[1];
                insert_bucket(rest);
                var
                 nidx=key_index(h,hkey),
                 _f9_=[0,hkey,data,caml_check_bound(ndata,nidx)[1 + nidx]];
                caml_check_bound(ndata,nidx)[1 + nidx] = _f9_;
                return 0}
              return 0},
           _f6_=osize - 1 | 0,
           _f5_=0;
          if(! (_f6_ < 0))
           {var i=_f5_;
            for(;;)
             {insert_bucket(caml_check_bound(odata,i)[1 + i]);
              var _f8_=i + 1 | 0;
              if(_f6_ !== i){var i=_f8_;continue}
              break}}
          var _f7_=0}
        else
         var _f7_=_f4_;
        return _f7_}
      function add(h,key,info)
       {var
         hkey=caml_call2(H[2],h[3],key),
         i=key_index(h,hkey),
         container=caml_call2(H[1],key,info),
         bucket=[0,hkey,container,caml_check_bound(h[2],i)[1 + i]];
        caml_check_bound(h[2],i)[1 + i] = bucket;
        h[1] = h[1] + 1 | 0;
        var _f2_=h[2].length - 1 << 1 < h[1]?1:0;
        return _f2_?resize(h):_f2_}
      function remove(h,key)
       {var hkey=caml_call2(H[2],h[3],key);
        function remove_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var hk=param$0[1],next=param$0[3],c=param$0[2];
              if(hkey === hk)
               {var match=caml_call2(H[3],c,key);
                switch(match)
                 {case 0:h[1] = h[1] - 1 | 0;return next;
                  case 1:return [0,hk,c,remove_bucket(next)];
                  default:h[1] = h[1] - 1 | 0;var param$0=next;continue}}
              var next$0=param$0[3],c$0=param$0[2];
              return [0,hk,c$0,remove_bucket(next$0)]}
            return 0}}
        var
         i=key_index(h,hkey),
         _f1_=remove_bucket(caml_check_bound(h[2],i)[1 + i]);
        caml_check_bound(h[2],i)[1 + i] = _f1_;
        return 0}
      function find(h,key)
       {var
         hkey=caml_call2(H[2],h[3],key),
         _f0_=key_index(h,hkey),
         param$1=caml_check_bound(h[2],_f0_)[1 + _f0_],
         param=param$1;
        for(;;)
         {if(param)
           {var hk=param[1],rest=param[3],c=param[2];
            if(hkey === hk)
             {var match=caml_call2(H[3],c,key);
              switch(match)
               {case 0:
                 var match$0=caml_call1(H[4],c);
                 if(match$0){var d=match$0[1];return d}
                 var param=rest;
                 continue;
                case 1:var param=rest;continue;
                default:var param=rest;continue}}
            var param$0=param[3],param=param$0;
            continue}
          throw Not_found}}
      function find_opt(h,key)
       {var
         hkey=caml_call2(H[2],h[3],key),
         _fZ_=key_index(h,hkey),
         param$1=caml_check_bound(h[2],_fZ_)[1 + _fZ_],
         param=param$1;
        for(;;)
         {if(param)
           {var hk=param[1],rest=param[3],c=param[2];
            if(hkey === hk)
             {var match=caml_call2(H[3],c,key);
              switch(match)
               {case 0:
                 var d=caml_call1(H[4],c);
                 if(d)return d;
                 var param=rest;
                 continue;
                case 1:var param=rest;continue;
                default:var param=rest;continue}}
            var param$0=param[3],param=param$0;
            continue}
          return 0}}
      function find_all(h,key)
       {var hkey=caml_call2(H[2],h[3],key);
        function find_in_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var hk=param$0[1],rest=param$0[3],c=param$0[2];
              if(hkey === hk)
               {var match=caml_call2(H[3],c,key);
                switch(match)
                 {case 0:
                   var match$0=caml_call1(H[4],c);
                   if(match$0)
                    {var d=match$0[1];return [0,d,find_in_bucket(rest)]}
                   var param$0=rest;
                   continue;
                  case 1:var param$0=rest;continue;
                  default:var param$0=rest;continue}}
              var param$1=param$0[3],param$0=param$1;
              continue}
            return 0}}
        var _fY_=key_index(h,hkey);
        return find_in_bucket(caml_check_bound(h[2],_fY_)[1 + _fY_])}
      function replace(h,key,info)
       {var hkey=caml_call2(H[2],h[3],key);
        function replace_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var hk=param$0[1],next=param$0[3],c=param$0[2];
              if(hkey === hk)
               {var match=caml_call2(H[3],c,key);
                if(match){var param$0=next;continue}
                return caml_call3(H[6],c,key,info)}
              var param$1=param$0[3],param$0=param$1;
              continue}
            throw Not_found}}
        var i=key_index(h,hkey),l=caml_check_bound(h[2],i)[1 + i];
        try
         {var _fW_=replace_bucket(l);return _fW_}
        catch(_fX_)
         {_fX_ = caml_wrap_exception(_fX_);
          if(_fX_ === Not_found)
           {var container=caml_call2(H[1],key,info);
            caml_check_bound(h[2],i)[1 + i] = [0,hkey,container,l];
            h[1] = h[1] + 1 | 0;
            var _fV_=h[2].length - 1 << 1 < h[1]?1:0;
            return _fV_?resize(h):_fV_}
          throw _fX_}}
      function mem(h,key)
       {var
         hkey=caml_call2(H[2],h[3],key),
         _fU_=key_index(h,hkey),
         param$1=caml_check_bound(h[2],_fU_)[1 + _fU_],
         param=param$1;
        for(;;)
         {if(param)
           {var hk=param[1],rest=param[3],c=param[2];
            if(hk === hkey)
             {var match=caml_call2(H[3],c,key);
              if(match){var param=rest;continue}
              return 1}
            var param$0=param[3],param=param$0;
            continue}
          return 0}}
      function iter$0(f,h)
       {var d$0=h[2],_fS_=d$0.length - 1 - 1 | 0,_fR_=0;
        if(! (_fS_ < 0))
         {var i=_fR_;
          a:
          for(;;)
           {var param$0=caml_check_bound(d$0,i)[1 + i],param=param$0;
            for(;;)
             {if(param)
               {var
                 rest=param[3],
                 c=param[2],
                 match=caml_call1(H[5],c),
                 match$0=caml_call1(H[4],c),
                 switch$0=0;
                if(match && match$0)
                 {var d=match$0[1],k=match[1];caml_call2(f,k,d);switch$0 = 1}
                var param=rest;
                continue}
              var _fT_=i + 1 | 0;
              if(_fS_ !== i){var i=_fT_;continue a}
              break}
            break}}
        return 0}
      function fold(f,h,init)
       {var d$0=h[2],accu$1=[0,init],_fO_=d$0.length - 1 - 1 | 0,_fN_=0;
        if(! (_fO_ < 0))
         {var i=_fN_;
          a:
          for(;;)
           {var
             _fP_=accu$1[1],
             b$0=caml_check_bound(d$0,i)[1 + i],
             b=b$0,
             accu=_fP_;
            for(;;)
             {if(b)
               {var
                 rest=b[3],
                 c=b[2],
                 match=caml_call1(H[5],c),
                 match$0=caml_call1(H[4],c),
                 switch$0=0;
                if(match && match$0)
                 {var d=match$0[1],k=match[1],accu$0=caml_call3(f,k,d,accu);
                  switch$0 = 1}
                if(! switch$0)var accu$0=accu;
                var b=rest,accu=accu$0;
                continue}
              accu$1[1] = accu;
              var _fQ_=i + 1 | 0;
              if(_fO_ !== i){var i=_fQ_;continue a}
              break}
            break}}
        return accu$1[1]}
      function filter_map_inplace(f,h)
       {function do_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var
               rest=param$0[3],
               c=param$0[2],
               hk=param$0[1],
               match=caml_call1(H[5],c),
               match$0=caml_call1(H[4],c);
              if(match && match$0)
               {var d=match$0[1],k=match[1],match$1=caml_call2(f,k,d);
                if(match$1)
                 {var new_d=match$1[1];
                  caml_call3(H[6],c,k,new_d);
                  return [0,hk,c,do_bucket(rest)]}
                var param$0=rest;
                continue}
              var param$0=rest;
              continue}
            return 0}}
        var d=h[2],_fK_=d.length - 1 - 1 | 0,_fJ_=0;
        if(! (_fK_ < 0))
         {var i=_fJ_;
          for(;;)
           {var _fL_=do_bucket(caml_check_bound(d,i)[1 + i]);
            caml_check_bound(d,i)[1 + i] = _fL_;
            var _fM_=i + 1 | 0;
            if(_fK_ !== i){var i=_fM_;continue}
            break}}
        return 0}
      function length(h){return h[1]}
      function bucket_length(accu,param)
       {var accu$0=accu,param$0=param;
        for(;;)
         {if(param$0)
           {var
             param$1=param$0[3],
             accu$1=accu$0 + 1 | 0,
             accu$0=accu$1,
             param$0=param$1;
            continue}
          return accu$0}}
      function stats(h)
       {var
         _fF_=h[2],
         _fG_=0,
         mbl=
          fold_left$1
           (function(m,b){return max(m,bucket_length(0,b))},_fG_,_fF_),
         histo=caml_make_vect(mbl + 1 | 0,0),
         _fH_=h[2];
        iter$5
         (function(b)
           {var
             l=bucket_length(0,b),
             _fI_=caml_check_bound(histo,l)[1 + l] + 1 | 0;
            caml_check_bound(histo,l)[1 + l] = _fI_;
            return 0},
          _fH_);
        return [0,h[1],h[2].length - 1,mbl,histo]}
      function bucket_length_alive(accu,param)
       {var accu$0=accu,param$0=param;
        for(;;)
         {if(param$0)
           {var rest=param$0[3],c=param$0[2];
            if(caml_call1(H[7],c))
             {var accu$1=accu$0 + 1 | 0,accu$0=accu$1,param$0=rest;continue}
            var param$1=param$0[3],param$0=param$1;
            continue}
          return accu$0}}
      function stats_alive(h)
       {var
         size=[0,0],
         _fB_=h[2],
         _fC_=0,
         mbl=
          fold_left$1
           (function(m,b){return max(m,bucket_length_alive(0,b))},_fC_,_fB_),
         histo=caml_make_vect(mbl + 1 | 0,0),
         _fD_=h[2];
        iter$5
         (function(b)
           {var l=bucket_length_alive(0,b);
            size[1] = size[1] + l | 0;
            var _fE_=caml_check_bound(histo,l)[1 + l] + 1 | 0;
            caml_check_bound(histo,l)[1 + l] = _fE_;
            return 0},
          _fD_);
        return [0,size[1],h[2].length - 1,mbl,histo]}
      function to_seq(tbl)
       {var tbl_data=tbl[2];
        function aux(i,buck,param)
         {var i$0=i,buck$0=buck;
          for(;;)
           {if(buck$0)
             {var
               next=buck$0[3],
               c=buck$0[2],
               match=caml_call1(H[5],c),
               match$0=caml_call1(H[4],c);
              if(match && match$0)
               {var data=match$0[1],key=match[1];
                return [0,
                        [0,key,data],
                        function(_fA_){return aux(i$0,next,_fA_)}]}
              var buck$0=next;
              continue}
            if(i$0 === tbl_data.length - 1)return 0;
            var
             buck$1=caml_check_bound(tbl_data,i$0)[1 + i$0],
             i$1=i$0 + 1 | 0,
             i$0=i$1,
             buck$0=buck$1;
            continue}}
        var _fx_=0,_fy_=0;
        return function(_fz_){return aux(_fy_,_fx_,_fz_)}}
      function to_seq_keys(m)
       {var _ft_=to_seq(m);
        function _fu_(_fw_){return _fw_[1]}
        return function(_fv_){return map(_fu_,_ft_,_fv_)}}
      function to_seq_values(m)
       {var _fp_=to_seq(m);
        function _fq_(_fs_){return _fs_[2]}
        return function(_fr_){return map(_fq_,_fp_,_fr_)}}
      function add_seq(tbl,i)
       {return iter
                (function(param)
                  {var v=param[2],k=param[1];return add(tbl,k,v)},
                 i)}
      function replace_seq(tbl,i)
       {return iter
                (function(param)
                  {var v=param[2],k=param[1];return replace(tbl,k,v)},
                 i)}
      function of_seq(i){var tbl=create(0,16);replace_seq(tbl,i);return tbl}
      return [0,
              create,
              clear,
              reset,
              copy,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter$0,
              filter_map_inplace,
              fold,
              length,
              stats,
              to_seq,
              to_seq_keys,
              to_seq_values,
              add_seq,
              replace_seq,
              of_seq,
              clean,
              stats_alive]}
    function create$5(param){return caml_call1(_t_[1],1)}
    function get_key$0(t){return caml_call2(_t_[3],t,0)}
    function get_key_copy$0(t){return caml_call2(_t_[4],t,0)}
    function set_key$0(t,k){return caml_call3(_t_[5],t,0,k)}
    function unset_key$0(t){return caml_call2(_t_[6],t,0)}
    function check_key$0(t){return caml_call2(_t_[7],t,0)}
    function blit_key$0(t1,t2){return caml_call5(_t_[8],t1,0,t2,0,1)}
    function get_data$1(t){return caml_call1(_t_[9],t)}
    function get_data_copy(t){return caml_call1(_t_[10],t)}
    function set_data(t,d){return caml_call2(_t_[11],t,d)}
    function unset_data(t){return caml_call1(_t_[12],t)}
    function check_data(t){return caml_call1(_t_[13],t)}
    function blit_data(t1,t2){return caml_call2(_t_[14],t1,t2)}
    function MakeSeeded$1(H)
     {function create(k,d)
       {var c=create$5(0);set_data(c,d);set_key$0(c,k);return c}
      var hash=H[2];
      function equal(c,k)
       {var match=get_key$0(c);
        if(match){var k$0=match[1];return caml_call2(H[1],k,k$0)?0:1}
        return 2}
      function set_key_data(c,k,d)
       {unset_data(c);set_key$0(c,k);return set_data(c,d)}
      return MakeSeeded$0
              ([0,
                create,
                hash,
                equal,
                get_data$1,
                get_key$0,
                set_key_data,
                check_key$0])}
    function Make$2(H)
     {var equal=H[1];
      function hash(seed,x){return caml_call1(H[2],x)}
      var
       include=MakeSeeded$1([0,equal,hash]),
       clear=include[2],
       reset=include[3],
       copy=include[4],
       add=include[5],
       remove=include[6],
       find=include[7],
       find_opt=include[8],
       find_all=include[9],
       replace=include[10],
       mem=include[11],
       iter=include[12],
       filter_map_inplace=include[13],
       fold=include[14],
       length=include[15],
       stats=include[16],
       to_seq=include[17],
       to_seq_keys=include[18],
       to_seq_values=include[19],
       add_seq=include[20],
       replace_seq=include[21],
       clean=include[23],
       stats_alive=include[24],
       _fo_=include[1];
      function create(sz){return caml_call2(_fo_,_cI_,sz)}
      function of_seq(i)
       {var tbl=create(16);caml_call2(replace_seq,tbl,i);return tbl}
      return [0,
              create,
              clear,
              reset,
              copy,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter,
              filter_map_inplace,
              fold,
              length,
              stats,
              to_seq,
              to_seq_keys,
              to_seq_values,
              add_seq,
              replace_seq,
              of_seq,
              clean,
              stats_alive]}
    function create$6(param){return caml_call1(_t_[1],2)}
    function get_key1(t){return caml_call2(_t_[3],t,0)}
    function get_key1_copy(t){return caml_call2(_t_[4],t,0)}
    function set_key1(t,k){return caml_call3(_t_[5],t,0,k)}
    function unset_key1(t){return caml_call2(_t_[6],t,0)}
    function check_key1(t){return caml_call2(_t_[7],t,0)}
    function get_key2(t){return caml_call2(_t_[3],t,1)}
    function get_key2_copy(t){return caml_call2(_t_[4],t,1)}
    function set_key2(t,k){return caml_call3(_t_[5],t,1,k)}
    function unset_key2(t){return caml_call2(_t_[6],t,1)}
    function check_key2(t){return caml_call2(_t_[7],t,1)}
    function blit_key1(t1,t2){return caml_call5(_t_[8],t1,0,t2,0,1)}
    function blit_key2(t1,t2){return caml_call5(_t_[8],t1,1,t2,1,1)}
    function blit_key12(t1,t2){return caml_call5(_t_[8],t1,0,t2,0,2)}
    function get_data$2(t){return caml_call1(_t_[9],t)}
    function get_data_copy$0(t){return caml_call1(_t_[10],t)}
    function set_data$0(t,d){return caml_call2(_t_[11],t,d)}
    function unset_data$0(t){return caml_call1(_t_[12],t)}
    function check_data$0(t){return caml_call1(_t_[13],t)}
    function blit_data$0(t1,t2){return caml_call2(_t_[14],t1,t2)}
    function MakeSeeded$2(H1,H2)
     {function create(param,d)
       {var k2=param[2],k1=param[1],c=create$6(0);
        set_data$0(c,d);
        set_key1(c,k1);
        set_key2(c,k2);
        return c}
      function hash(seed,param)
       {var
         k2=param[2],
         k1=param[1],
         _fn_=caml_call2(H2[2],seed,k2) * 65599 | 0;
        return caml_call2(H1[2],seed,k1) + _fn_ | 0}
      function equal(c,param)
       {var k2=param[2],k1=param[1],match=get_key1(c),match$0=get_key2(c);
        if(match && match$0)
         {var k2$0=match$0[1],k1$0=match[1];
          if(caml_call2(H1[1],k1,k1$0) && caml_call2(H2[1],k2,k2$0))return 0;
          return 1}
        return 2}
      function get_key(c)
       {var match=get_key1(c),match$0=get_key2(c);
        if(match && match$0)
         {var k2=match$0[1],k1=match[1];return [0,[0,k1,k2]]}
        return 0}
      function set_key_data(c,param,d)
       {var k2=param[2],k1=param[1];
        unset_data$0(c);
        set_key1(c,k1);
        set_key2(c,k2);
        return set_data$0(c,d)}
      function check_key(c)
       {var _fm_=check_key1(c);return _fm_?check_key2(c):_fm_}
      return MakeSeeded$0
              ([0,create,hash,equal,get_data$2,get_key,set_key_data,check_key])}
    function Make$3(H1,H2)
     {var equal=H2[1];
      function hash(seed,x){return caml_call1(H2[2],x)}
      var equal$0=H1[1],_fk_=[0,equal,hash];
      function hash$0(seed,x){return caml_call1(H1[2],x)}
      var
       include=MakeSeeded$2([0,equal$0,hash$0],_fk_),
       clear=include[2],
       reset=include[3],
       copy=include[4],
       add=include[5],
       remove=include[6],
       find=include[7],
       find_opt=include[8],
       find_all=include[9],
       replace=include[10],
       mem=include[11],
       iter=include[12],
       filter_map_inplace=include[13],
       fold=include[14],
       length=include[15],
       stats=include[16],
       to_seq=include[17],
       to_seq_keys=include[18],
       to_seq_values=include[19],
       add_seq=include[20],
       replace_seq=include[21],
       clean=include[23],
       stats_alive=include[24],
       _fl_=include[1];
      function create(sz){return caml_call2(_fl_,_cJ_,sz)}
      function of_seq(i)
       {var tbl=create(16);caml_call2(replace_seq,tbl,i);return tbl}
      return [0,
              create,
              clear,
              reset,
              copy,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter,
              filter_map_inplace,
              fold,
              length,
              stats,
              to_seq,
              to_seq_keys,
              to_seq_values,
              add_seq,
              replace_seq,
              of_seq,
              clean,
              stats_alive]}
    function create$7(n){return caml_call1(_t_[1],n)}
    function length$6(k){return caml_call1(_t_[2],k)}
    function get_key$1(t,n){return caml_call2(_t_[3],t,n)}
    function get_key_copy$1(t,n){return caml_call2(_t_[4],t,n)}
    function set_key$1(t,n,k){return caml_call3(_t_[5],t,n,k)}
    function unset_key$1(t,n){return caml_call2(_t_[6],t,n)}
    function check_key$1(t,n){return caml_call2(_t_[7],t,n)}
    function blit_key$1(t1,o1,t2,o2,l)
     {return caml_call5(_t_[8],t1,o1,t2,o2,l)}
    function get_data$3(t){return caml_call1(_t_[9],t)}
    function get_data_copy$1(t){return caml_call1(_t_[10],t)}
    function set_data$1(t,d){return caml_call2(_t_[11],t,d)}
    function unset_data$1(t){return caml_call1(_t_[12],t)}
    function check_data$1(t){return caml_call1(_t_[13],t)}
    function blit_data$1(t1,t2){return caml_call2(_t_[14],t1,t2)}
    function MakeSeeded$3(H)
     {function create(k,d)
       {var c=create$7(k.length - 1);
        set_data$1(c,d);
        var _fi_=k.length - 1 - 1 | 0,_fh_=0;
        if(! (_fi_ < 0))
         {var i=_fh_;
          for(;;)
           {set_key$1(c,i,caml_check_bound(k,i)[1 + i]);
            var _fj_=i + 1 | 0;
            if(_fi_ !== i){var i=_fj_;continue}
            break}}
        return c}
      function hash(seed,k)
       {var h=[0,0],_fd_=k.length - 1 - 1 | 0,_fc_=0;
        if(! (_fd_ < 0))
         {var i=_fc_;
          for(;;)
           {var _fe_=h[1],_ff_=caml_check_bound(k,i)[1 + i];
            h[1] = (caml_call2(H[2],seed,_ff_) * 65599 | 0) + _fe_ | 0;
            var _fg_=i + 1 | 0;
            if(_fd_ !== i){var i=_fg_;continue}
            break}}
        return h[1]}
      function equal(c,k)
       {var len=k.length - 1,len$0=length$6(c);
        if(len !== len$0)return 1;
        var i$1=len - 1 | 0,i=i$1;
        for(;;)
         {if(0 <= i)
           {var match=get_key$1(c,i);
            if(match)
             {var ki=match[1],_fb_=caml_check_bound(k,i)[1 + i];
              if(caml_call2(H[1],_fb_,ki)){var i$0=i - 1 | 0,i=i$0;continue}
              return 1}
            return 2}
          return 0}}
      function get_key(c)
       {var len=length$6(c);
        if(0 === len)return [0,[0]];
        var match=get_key$1(c,0);
        if(match)
         {var k0=match[1],a=caml_make_vect(len,k0),i$1=len - 1 | 0,i=i$1;
          for(;;)
           {if(1 <= i)
             {var match$0=get_key$1(c,i);
              if(match$0)
               {var ki=match$0[1];
                caml_check_bound(a,i)[1 + i] = ki;
                var i$0=i - 1 | 0,i=i$0;
                continue}
              return 0}
            return [0,a]}}
        return 0}
      function set_key_data(c,k,d)
       {unset_data$1(c);
        var _e$_=k.length - 1 - 1 | 0,_e__=0;
        if(! (_e$_ < 0))
         {var i=_e__;
          for(;;)
           {set_key$1(c,i,caml_check_bound(k,i)[1 + i]);
            var _fa_=i + 1 | 0;
            if(_e$_ !== i){var i=_fa_;continue}
            break}}
        return set_data$1(c,d)}
      function check_key(c)
       {var i$1=length$6(c) - 1 | 0,i=i$1;
        for(;;)
         {var _e7_=i < 0?1:0;
          if(_e7_)
           var _e8_=_e7_;
          else
           {var _e9_=check_key$1(c,i);
            if(_e9_){var i$0=i - 1 | 0,i=i$0;continue}
            var _e8_=_e9_}
          return _e8_}}
      return MakeSeeded$0
              ([0,create,hash,equal,get_data$3,get_key,set_key_data,check_key])}
    function Make$4(H)
     {var equal=H[1];
      function hash(seed,x){return caml_call1(H[2],x)}
      var
       include=MakeSeeded$3([0,equal,hash]),
       clear=include[2],
       reset=include[3],
       copy=include[4],
       add=include[5],
       remove=include[6],
       find=include[7],
       find_opt=include[8],
       find_all=include[9],
       replace=include[10],
       mem=include[11],
       iter=include[12],
       filter_map_inplace=include[13],
       fold=include[14],
       length=include[15],
       stats=include[16],
       to_seq=include[17],
       to_seq_keys=include[18],
       to_seq_values=include[19],
       add_seq=include[20],
       replace_seq=include[21],
       clean=include[23],
       stats_alive=include[24],
       _e6_=include[1];
      function create(sz){return caml_call2(_e6_,_cK_,sz)}
      function of_seq(i)
       {var tbl=create(16);caml_call2(replace_seq,tbl,i);return tbl}
      return [0,
              create,
              clear,
              reset,
              copy,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter,
              filter_map_inplace,
              fold,
              length,
              stats,
              to_seq,
              to_seq_keys,
              to_seq_values,
              add_seq,
              replace_seq,
              of_seq,
              clean,
              stats_alive]}
    var
     Stdlib_ephemeron=
      [0,
       [0,
        create$5,
        get_key$0,
        get_key_copy$0,
        set_key$0,
        unset_key$0,
        check_key$0,
        blit_key$0,
        get_data$1,
        get_data_copy,
        set_data,
        unset_data,
        check_data,
        blit_data,
        Make$2,
        MakeSeeded$1],
       [0,
        create$6,
        get_key1,
        get_key1_copy,
        set_key1,
        unset_key1,
        check_key1,
        get_key2,
        get_key2_copy,
        set_key2,
        unset_key2,
        check_key2,
        blit_key1,
        blit_key2,
        blit_key12,
        get_data$2,
        get_data_copy$0,
        set_data$0,
        unset_data$0,
        check_data$0,
        blit_data$0,
        Make$3,
        MakeSeeded$2],
       [0,
        create$7,
        get_key$1,
        get_key_copy$1,
        set_key$1,
        unset_key$1,
        check_key$1,
        blit_key$1,
        get_data$3,
        get_data_copy$1,
        set_data$1,
        unset_data$1,
        check_data$1,
        blit_data$1,
        Make$4,
        MakeSeeded$3],
       [0,
        function(_e5_)
         {return MakeSeeded$0
                  ([0,_e5_[3],_e5_[1],_e5_[2],_e5_[5],_e5_[4],_e5_[6],_e5_[7]])}]];
    caml_register_global(808,Stdlib_ephemeron,"Stdlib__ephemeron");
    function generic_basename(is_dir_sep,current_dir_name,name)
     {if(caml_string_equal(name,cst$100))return current_dir_name;
      var n$3=caml_ml_string_length(name) - 1 | 0,n=n$3;
      for(;;)
       {if(0 <= n)
         {if(caml_call2(is_dir_sep,name,n)){var n$0=n - 1 | 0,n=n$0;continue}
          var p=n + 1 | 0,n$1=n;
          for(;;)
           {if(0 <= n$1)
             {if(caml_call2(is_dir_sep,name,n$1))
               return sub$0(name,n$1 + 1 | 0,(p - n$1 | 0) - 1 | 0);
              var n$2=n$1 - 1 | 0,n$1=n$2;
              continue}
            return sub$0(name,0,p)}}
        return sub$0(name,0,1)}}
    function generic_dirname(is_dir_sep,current_dir_name,name)
     {if(caml_string_equal(name,cst$101))return current_dir_name;
      var n$5=caml_ml_string_length(name) - 1 | 0,n=n$5;
      for(;;)
       {if(0 <= n)
         {if(caml_call2(is_dir_sep,name,n)){var n$0=n - 1 | 0,n=n$0;continue}
          var n$1=n;
          for(;;)
           {if(0 <= n$1)
             {if(caml_call2(is_dir_sep,name,n$1))
               {var n$3=n$1;
                for(;;)
                 {if(0 <= n$3)
                   {if(caml_call2(is_dir_sep,name,n$3))
                     {var n$4=n$3 - 1 | 0,n$3=n$4;continue}
                    return sub$0(name,0,n$3 + 1 | 0)}
                  return sub$0(name,0,1)}}
              var n$2=n$1 - 1 | 0,n$1=n$2;
              continue}
            return current_dir_name}}
        return sub$0(name,0,1)}}
    function is_dir_sep(s,i){return 47 === caml_string_get(s,i)?1:0}
    function is_relative(n)
     {var
       _e3_=caml_ml_string_length(n) < 1?1:0,
       _e4_=_e3_ || (47 !== caml_string_get(n,0)?1:0);
      return _e4_}
    function is_implicit(n)
     {var _eY_=is_relative(n);
      if(_eY_)
       {var
         _eZ_=caml_ml_string_length(n) < 2?1:0,
         _e0_=_eZ_ || caml_string_notequal(sub$0(n,0,2),cst$103);
        if(_e0_)
         var
          _e1_=caml_ml_string_length(n) < 3?1:0,
          _e2_=_e1_ || caml_string_notequal(sub$0(n,0,3),cst$102);
        else
         var _e2_=_e0_}
      else
       var _e2_=_eY_;
      return _e2_}
    function check_suffix(name,suff)
     {var
       _eW_=caml_ml_string_length(suff) <= caml_ml_string_length(name)?1:0,
       _eX_=
        _eW_
         ?caml_string_equal
           (sub$0
             (name,
              caml_ml_string_length(name) - caml_ml_string_length(suff) | 0,
              caml_ml_string_length(suff)),
            suff)
         :_eW_;
      return _eX_}
    function chop_suffix_opt(suffix,filename)
     {var
       len_s=caml_ml_string_length(suffix),
       len_f=caml_ml_string_length(filename);
      if(len_s <= len_f)
       {var r=sub$0(filename,len_f - len_s | 0,len_s);
        return caml_string_equal(r,suffix)
                ?[0,sub$0(filename,0,len_f - len_s | 0)]
                :0}
      return 0}
    try
     {var _cS_=caml_sys_getenv(cst_TMPDIR),_cL_=_cS_}
    catch(_eV_)
     {_eV_ = caml_wrap_exception(_eV_);
      if(_eV_ !== Not_found)throw _eV_;
      var _cL_=cst_tmp}
    function quote(s)
     {var l=caml_ml_string_length(s),b=create$2(l + 20 | 0);
      add_char(b,39);
      var _eT_=l - 1 | 0,_eS_=0;
      if(! (_eT_ < 0))
       {var i=_eS_;
        for(;;)
         {if(39 === caml_string_get(s,i))
           add_string(b,quotequote);
          else
           add_char(b,caml_string_get(s,i));
          var _eU_=i + 1 | 0;
          if(_eT_ !== i){var i=_eU_;continue}
          break}}
      add_char(b,39);
      return contents(b)}
    function quote_command(cmd,stdin,stdout,stderr,args)
     {if(stderr)
       var
        f=stderr[1],
        _eM_=caml_equal(stderr,stdout)?cst_2_1:symbol(cst_2,quote(f)),
        _eN_=_eM_;
      else
       var _eN_=cst$109;
      if(stdout)
       var f$0=stdout[1],_eO_=symbol(cst$104,quote(f$0));
      else
       var _eO_=cst$108;
      var _eP_=symbol(_eO_,_eN_);
      if(stdin)
       var f$1=stdin[1],_eQ_=symbol(cst$105,quote(f$1));
      else
       var _eQ_=cst$107;
      var _eR_=symbol(_eQ_,_eP_);
      return symbol(concat$0(cst$106,map$3(quote,[0,cmd,args])),_eR_)}
    function basename(_eL_)
     {return generic_basename(is_dir_sep,current_dir_name,_eL_)}
    function dirname(_eK_)
     {return generic_dirname(is_dir_sep,current_dir_name,_eK_)}
    var
     Unix=
      [0,
       null$0,
       current_dir_name,
       parent_dir_name,
       dir_sep,
       is_dir_sep,
       is_relative,
       is_implicit,
       check_suffix,
       chop_suffix_opt,
       _cL_,
       quote,
       quote_command,
       basename,
       dirname];
    function is_dir_sep$0(s,i)
     {var c=caml_string_get(s,i),_eH_=47 === c?1:0;
      if(_eH_)
       var _eI_=_eH_;
      else
       var _eJ_=92 === c?1:0,_eI_=_eJ_ || (58 === c?1:0);
      return _eI_}
    function is_relative$0(n)
     {var
       _eB_=caml_ml_string_length(n) < 1?1:0,
       _eC_=_eB_ || (47 !== caml_string_get(n,0)?1:0);
      if(_eC_)
       {var
         _eD_=caml_ml_string_length(n) < 1?1:0,
         _eE_=_eD_ || (92 !== caml_string_get(n,0)?1:0);
        if(_eE_)
         var
          _eF_=caml_ml_string_length(n) < 2?1:0,
          _eG_=_eF_ || (58 !== caml_string_get(n,1)?1:0);
        else
         var _eG_=_eE_}
      else
       var _eG_=_eC_;
      return _eG_}
    function is_implicit$0(n)
     {var _es_=is_relative$0(n);
      if(_es_)
       {var
         _et_=caml_ml_string_length(n) < 2?1:0,
         _eu_=_et_ || caml_string_notequal(sub$0(n,0,2),cst$113);
        if(_eu_)
         {var
           _ev_=caml_ml_string_length(n) < 2?1:0,
           _ew_=_ev_ || caml_string_notequal(sub$0(n,0,2),cst$112);
          if(_ew_)
           {var
             _ex_=caml_ml_string_length(n) < 3?1:0,
             _ey_=_ex_ || caml_string_notequal(sub$0(n,0,3),cst$111);
            if(_ey_)
             var
              _ez_=caml_ml_string_length(n) < 3?1:0,
              _eA_=_ez_ || caml_string_notequal(sub$0(n,0,3),cst$110);
            else
             var _eA_=_ey_}
          else
           var _eA_=_ew_}
        else
         var _eA_=_eu_}
      else
       var _eA_=_es_;
      return _eA_}
    function check_suffix$0(name,suff)
     {var _ep_=caml_ml_string_length(suff) <= caml_ml_string_length(name)?1:0;
      if(_ep_)
       var
        s=
         sub$0
          (name,
           caml_ml_string_length(name) - caml_ml_string_length(suff) | 0,
           caml_ml_string_length(suff)),
        _eq_=lowercase_ascii$1(suff),
        _er_=caml_string_equal(lowercase_ascii$1(s),_eq_);
      else
       var _er_=_ep_;
      return _er_}
    function chop_suffix_opt$0(suffix,filename)
     {var
       len_s=caml_ml_string_length(suffix),
       len_f=caml_ml_string_length(filename);
      if(len_s <= len_f)
       {var
         r=sub$0(filename,len_f - len_s | 0,len_s),
         _eo_=lowercase_ascii$1(suffix);
        return caml_string_equal(lowercase_ascii$1(r),_eo_)
                ?[0,sub$0(filename,0,len_f - len_s | 0)]
                :0}
      return 0}
    try
     {var _cR_=caml_sys_getenv(cst_TEMP),temp_dir_name=_cR_}
    catch(_en_)
     {_en_ = caml_wrap_exception(_en_);
      if(_en_ !== Not_found)throw _en_;
      var temp_dir_name=cst$114}
    function quote$0(s)
     {var l=caml_ml_string_length(s),b=create$2(l + 20 | 0);
      add_char(b,34);
      function add_bs(n)
       {var _el_=1;
        if(! (n < 1))
         {var j=_el_;
          for(;;)
           {add_char(b,92);
            var _em_=j + 1 | 0;
            if(n !== j){var j=_em_;continue}
            break}}
        return 0}
      function loop$0(counter,i)
       {var i$0=i;
        for(;;)
         {if(i$0 === l)return add_char(b,34);
          var c=caml_string_get(s,i$0);
          if(34 === c)
           {var _ej_=0;
            if(counter < 50)
             {var counter$1=counter + 1 | 0;
              return loop_bs(counter$1,_ej_,i$0)}
            return caml_trampoline_return(loop_bs,[0,_ej_,i$0])}
          if(92 === c)
           {var _ek_=0;
            if(counter < 50)
             {var counter$0=counter + 1 | 0;
              return loop_bs(counter$0,_ek_,i$0)}
            return caml_trampoline_return(loop_bs,[0,_ek_,i$0])}
          add_char(b,c);
          var i$1=i$0 + 1 | 0,i$0=i$1;
          continue}}
      function loop_bs(counter,n,i)
       {var n$0=n,i$0=i;
        for(;;)
         {if(i$0 === l){add_char(b,34);return add_bs(n$0)}
          var match=caml_string_get(s,i$0);
          if(34 === match)
           {add_bs((2 * n$0 | 0) + 1 | 0);
            add_char(b,34);
            var _ei_=i$0 + 1 | 0;
            if(counter < 50)
             {var counter$1=counter + 1 | 0;return loop$0(counter$1,_ei_)}
            return caml_trampoline_return(loop$0,[0,_ei_])}
          if(92 === match)
           {var i$1=i$0 + 1 | 0,n$1=n$0 + 1 | 0,n$0=n$1,i$0=i$1;continue}
          add_bs(n$0);
          if(counter < 50)
           {var counter$0=counter + 1 | 0;return loop$0(counter$0,i$0)}
          return caml_trampoline_return(loop$0,[0,i$0])}}
      function loop(i){return caml_trampoline(loop$0(0,i))}
      loop(0);
      return contents(b)}
    function quote_cmd_filename(f)
     {if(! contains$0(f,34) && ! contains$0(f,37))
       return contains$0(f,32)?symbol(cst$116,symbol(f,cst$115)):f;
      return failwith(symbol(cst_Filename_quote_command_bad,f))}
    function quote_command$0(cmd,stdin,stdout,stderr,args)
     {if(stderr)
       var
        f=stderr[1],
        _d$_=
         caml_equal(stderr,stdout)
          ?cst_2_1$0
          :symbol(cst_2$0,quote_cmd_filename(f)),
        _ea_=_d$_;
      else
       var _ea_=cst$125;
      var _eb_=[0,_ea_,_cM_];
      if(stdout)
       var f$0=stdout[1],_ec_=symbol(cst$117,quote_cmd_filename(f$0));
      else
       var _ec_=cst$124;
      var _ed_=[0,_ec_,_eb_];
      if(stdin)
       var f$1=stdin[1],_ee_=symbol(cst$118,quote_cmd_filename(f$1));
      else
       var _ee_=cst$123;
      var
       s=concat$0(cst$119,map$3(quote$0,args)),
       b=create$2(caml_ml_string_length(s) + 20 | 0),
       _ef_=[0,_ee_,_ed_];
      iter$4
       (function(c)
         {var switch$0=0;
          if(62 <= c)
           {var _eh_=c - 63 | 0;
            if(60 < _eh_ >>> 0)
             {if(! (62 <= _eh_))switch$0 = 1}
            else
             if(31 === _eh_)switch$0 = 1}
          else
           if(42 <= c)
            {if(60 === c)switch$0 = 1}
           else
            if(33 <= c)
             switch(c - 33 | 0)
              {case 2:case 3:case 6:break;default:switch$0 = 1}
          return switch$0?(add_char(b,94),add_char(b,c)):add_char(b,c)},
        s);
      var _eg_=[0,cst$120,[0,contents(b),_ef_]];
      return concat$0(cst$122,[0,cst$121,[0,quote_cmd_filename(cmd),_eg_]])}
    function drive_and_path(s)
     {var _d7_=2 <= caml_ml_string_length(s)?1:0;
      if(_d7_)
       {var param=caml_string_get(s,0),switch$0=0;
        if(91 <= param)
         {if(! (25 < (param - 97 | 0) >>> 0))switch$0 = 1}
        else
         if(65 <= param)switch$0 = 1;
        var _d8_=switch$0?1:0,_d9_=_d8_?58 === caml_string_get(s,1)?1:0:_d8_}
      else
       var _d9_=_d7_;
      if(_d9_)
       {var _d__=sub$0(s,2,caml_ml_string_length(s) - 2 | 0);
        return [0,sub$0(s,0,2),_d__]}
      return [0,cst$126,s]}
    function dirname$0(s)
     {var
       match=drive_and_path(s),
       path=match[2],
       drive=match[1],
       dir=generic_dirname(is_dir_sep$0,current_dir_name$0,path);
      return symbol(drive,dir)}
    function basename$0(s)
     {var match=drive_and_path(s),path=match[2];
      return generic_basename(is_dir_sep$0,current_dir_name$0,path)}
    var
     Win32=
      [0,
       null$1,
       current_dir_name$0,
       parent_dir_name$0,
       dir_sep$0,
       is_dir_sep$0,
       is_relative$0,
       is_implicit$0,
       check_suffix$0,
       chop_suffix_opt$0,
       temp_dir_name,
       quote$0,
       quote_command$0,
       basename$0,
       dirname$0];
    function basename$1(_d6_)
     {return generic_basename(is_dir_sep$0,current_dir_name$1,_d6_)}
    function dirname$1(_d5_)
     {return generic_dirname(is_dir_sep$0,current_dir_name$1,_d5_)}
    var
     Cygwin=
      [0,
       null$2,
       current_dir_name$1,
       parent_dir_name$1,
       dir_sep$1,
       is_dir_sep$0,
       is_relative$0,
       is_implicit$0,
       check_suffix$0,
       chop_suffix_opt$0,
       _cL_,
       quote,
       quote_command,
       basename$1,
       dirname$1],
     Sysdeps=
      caml_string_notequal(os_type,cst_Cygwin)
       ?caml_string_notequal(os_type,cst_Win32)?Unix:Win32
       :Cygwin,
     null$3=Sysdeps[1],
     current_dir_name$2=Sysdeps[2],
     parent_dir_name$2=Sysdeps[3],
     dir_sep$2=Sysdeps[4],
     is_dir_sep$1=Sysdeps[5],
     is_relative$1=Sysdeps[6],
     is_implicit$1=Sysdeps[7],
     check_suffix$1=Sysdeps[8],
     chop_suffix_opt$1=Sysdeps[9],
     temp_dir_name$0=Sysdeps[10],
     quote$1=Sysdeps[11],
     quote_command$1=Sysdeps[12],
     basename$2=Sysdeps[13],
     dirname$2=Sysdeps[14];
    function concat$3(dirname,filename)
     {var l=caml_ml_string_length(dirname);
      if(0 !== l && ! is_dir_sep$1(dirname,l - 1 | 0))
       return symbol(dirname,symbol(dir_sep$2,filename));
      return symbol(dirname,filename)}
    function chop_suffix(name,suff)
     {var n=caml_ml_string_length(name) - caml_ml_string_length(suff) | 0;
      return 0 <= n?sub$0(name,0,n):invalid_arg(cst_Filename_chop_suffix)}
    function extension_len(name)
     {var i$4=caml_ml_string_length(name) - 1 | 0,i$1=i$4;
      for(;;)
       {if(0 <= i$1 && ! is_dir_sep$1(name,i$1))
         {if(46 === caml_string_get(name,i$1))
           {var i$2=i$1 - 1 | 0,i=i$2;
            for(;;)
             {if(0 <= i && ! is_dir_sep$1(name,i))
               {if(46 === caml_string_get(name,i))
                 {var i$0=i - 1 | 0,i=i$0;continue}
                return caml_ml_string_length(name) - i$1 | 0}
              return 0}}
          var i$3=i$1 - 1 | 0,i$1=i$3;
          continue}
        return 0}}
    function extension(name)
     {var l=extension_len(name);
      return 0 === l?cst$127:sub$0(name,caml_ml_string_length(name) - l | 0,l)}
    function chop_extension(name)
     {var l=extension_len(name);
      return 0 === l
              ?invalid_arg(cst_Filename_chop_extension)
              :sub$0(name,0,caml_ml_string_length(name) - l | 0)}
    function remove_extension(name)
     {var l=extension_len(name);
      return 0 === l?name:sub$0(name,0,caml_ml_string_length(name) - l | 0)}
    var prng$0=[246,function(_d4_){return caml_call1(_b$_[2],0)}];
    function temp_file_name(temp_dir,prefix,suffix)
     {var
       _d2_=caml_obj_tag(prng$0),
       _d3_=
        250 === _d2_?prng$0[1]:246 === _d2_?force_lazy_block(prng$0):prng$0,
       rnd=caml_call1(_b$_[4],_d3_) & 16777215;
      return concat$3(temp_dir,caml_call3(sprintf(_cN_),prefix,rnd,suffix))}
    var current_temp_dir_name=[0,temp_dir_name$0];
    function set_temp_dir_name(s){current_temp_dir_name[1] = s;return 0}
    function get_temp_dir_name(param){return current_temp_dir_name[1]}
    function temp_file(opt,prefix,suffix)
     {if(opt)
       var sth=opt[1],temp_dir=sth;
      else
       var temp_dir=current_temp_dir_name[1];
      function try_name(counter)
       {var counter$0=counter;
        for(;;)
         {var name=temp_file_name(temp_dir,prefix,suffix);
          try
           {runtime.caml_sys_close(caml_sys_open(name,_cO_,384));return name}
          catch(e)
           {e = caml_wrap_exception(e);
            if(e[1] === Sys_error)
             {if(1000 <= counter$0)throw e;
              var counter$1=counter$0 + 1 | 0,counter$0=counter$1;
              continue}
            throw e}}}
      return try_name(0)}
    function open_temp_file(opt,_d0_,_dZ_,prefix,suffix)
     {if(opt)var sth=opt[1],mode=sth;else var mode=_cP_;
      if(_d0_)var sth$0=_d0_[1],perms=sth$0;else var perms=384;
      if(_dZ_)
       var sth$1=_dZ_[1],temp_dir=sth$1;
      else
       var temp_dir=current_temp_dir_name[1];
      function try_name(counter)
       {var counter$0=counter;
        for(;;)
         {var name=temp_file_name(temp_dir,prefix,suffix);
          try
           {var _d1_=[0,name,open_out_gen([0,1,[0,3,[0,5,mode]]],perms,name)];
            return _d1_}
          catch(e)
           {e = caml_wrap_exception(e);
            if(e[1] === Sys_error)
             {if(1000 <= counter$0)throw e;
              var counter$1=counter$0 + 1 | 0,counter$0=counter$1;
              continue}
            throw e}}}
      return try_name(0)}
    var
     Stdlib_filename=
      [0,
       current_dir_name$2,
       parent_dir_name$2,
       dir_sep$2,
       concat$3,
       is_relative$1,
       is_implicit$1,
       check_suffix$1,
       chop_suffix,
       chop_suffix_opt$1,
       extension,
       remove_extension,
       chop_extension,
       basename$2,
       dirname$2,
       null$3,
       temp_file,
       open_temp_file,
       get_temp_dir_name,
       set_temp_dir_name,
       temp_dir_name$0,
       quote$1,
       quote_command$1];
    caml_register_global(809,Stdlib_filename,"Stdlib__filename");
    function add$1(x,y){return [254,x[1] + y[1],x[2] + y[2]]}
    function sub$4(x,y){return [254,x[1] - y[1],x[2] - y[2]]}
    function neg(x){return [254,- x[1],- x[2]]}
    function conj(x){return [254,x[1],- x[2]]}
    function mul(x,y)
     {return [254,x[1] * y[1] - x[2] * y[2],x[1] * y[2] + x[2] * y[1]]}
    function div(x,y)
     {if(Math.abs(y[2]) <= Math.abs(y[1]))
       {var r=y[2] / y[1],d=y[1] + r * y[2];
        return [254,(x[1] + r * x[2]) / d,(x[2] - r * x[1]) / d]}
      var r$0=y[1] / y[2],d$0=y[2] + r$0 * y[1];
      return [254,(r$0 * x[1] + x[2]) / d$0,(r$0 * x[2] - x[1]) / d$0]}
    function inv(x){return div(one$4,x)}
    function norm2(x){return x[1] * x[1] + x[2] * x[2]}
    function norm(x)
     {var r=Math.abs(x[1]),i=Math.abs(x[2]);
      if(r == 0.)return i;
      if(i == 0.)return r;
      if(i <= r){var q=i / r;return r * Math.sqrt(1. + q * q)}
      var q$0=r / i;
      return i * Math.sqrt(1. + q$0 * q$0)}
    function arg(x){return Math.atan2(x[2],x[1])}
    function polar(n,a){return [254,Math.cos(a) * n,Math.sin(a) * n]}
    function sqrt(x)
     {if(x[1] == 0. && x[2] == 0.)return _cQ_;
      var r=Math.abs(x[1]),i=Math.abs(x[2]);
      if(i <= r)
       var
        q=i / r,
        w=Math.sqrt(r) * Math.sqrt(0.5 * (1. + Math.sqrt(1. + q * q)));
      else
       var
        q$0=r / i,
        w=Math.sqrt(i) * Math.sqrt(0.5 * (q$0 + Math.sqrt(1. + q$0 * q$0)));
      if(0. <= x[1])return [254,w,0.5 * x[2] / w];
      var w$0=0. <= x[2]?w:- w;
      return [254,0.5 * i / w,w$0]}
    function exp(x)
     {var e=Math.exp(x[1]);return [254,e * Math.cos(x[2]),e * Math.sin(x[2])]}
    function log(x)
     {var _dY_=Math.atan2(x[2],x[1]);return [254,Math.log(norm(x)),_dY_]}
    function pow(x,y){return exp(mul(y,log(x)))}
    var
     Stdlib_complex=
      [0,
       zero$4,
       one$4,
       i,
       neg,
       conj,
       add$1,
       sub$4,
       mul,
       inv,
       div,
       sqrt,
       norm2,
       norm,
       arg,
       polar,
       exp,
       log,
       pow];
    caml_register_global(810,Stdlib_complex,"Stdlib__complex");
    var
     Stdlib_arrayLabels=
      [0,
       make_float,
       init$2,
       create_matrix,
       create_matrix,
       append$1,
       concat$1,
       sub$1,
       copy$1,
       fill$0,
       blit$1,
       to_list$1,
       of_list,
       iter$5,
       iteri$2,
       map$6,
       mapi$2,
       fold_left$1,
       fold_right$0,
       iter2$0,
       map2$0,
       for_all$0,
       exists$0,
       for_all2$0,
       exists2$0,
       mem$0,
       memq$0,
       sort,
       fast_sort$0,
       fast_sort$0,
       to_seq$4,
       to_seqi$1,
       of_seq$2,
       Floatarray];
    caml_register_global(811,Stdlib_arrayLabels,"Stdlib__arrayLabels");
    var
     Stdlib_listLabels=
      [0,
       length,
       compare_lengths,
       compare_length_with,
       cons$0,
       hd,
       tl,
       nth,
       nth_opt,
       rev,
       init,
       append,
       rev_append,
       flatten,
       flatten,
       equal$5,
       compare$5,
       iter$2,
       iteri,
       map$3,
       mapi,
       rev_map,
       filter_map$0,
       concat_map,
       fold_left_map,
       fold_left$0,
       fold_right,
       iter2,
       map2,
       rev_map2,
       fold_left2,
       fold_right2,
       for_all,
       exists,
       for_all2,
       exists2,
       mem,
       memq,
       find,
       find_opt,
       find_map,
       find_all,
       find_all,
       filteri,
       partition,
       partition_map,
       assoc,
       assoc_opt,
       assq,
       assq_opt,
       mem_assoc,
       mem_assq,
       remove_assoc,
       remove_assq,
       split,
       combine,
       fast_sort,
       fast_sort,
       fast_sort,
       sort_uniq,
       merge,
       to_seq$1,
       of_seq];
    caml_register_global(812,Stdlib_listLabels,"Stdlib__listLabels");
    var
     Stdlib_bytesLabels=
      [0,
       make$0,
       init$0,
       empty$0,
       copy,
       of_string,
       to_string$1,
       sub,
       sub_string,
       extend,
       fill,
       blit,
       blit$0,
       concat,
       cat,
       iter$3,
       iteri$0,
       map$4,
       mapi$0,
       trim,
       escaped$0,
       index,
       index_opt,
       rindex,
       rindex_opt,
       index_from,
       index_from_opt,
       rindex_from,
       rindex_from_opt,
       contains,
       contains_from,
       rcontains_from,
       uppercase$0,
       lowercase$0,
       capitalize,
       uncapitalize,
       uppercase_ascii$0,
       lowercase_ascii$0,
       capitalize_ascii,
       uncapitalize_ascii,
       compare$6,
       equal$6,
       unsafe_to_string,
       unsafe_of_string,
       to_seq$2,
       to_seqi,
       of_seq$0,
       get_uint8,
       get_int8,
       get_uint16_ne,
       get_uint16_be,
       get_uint16_le,
       get_int16_ne,
       get_int16_be,
       get_int16_le,
       get_int32_ne,
       get_int32_be,
       get_int32_le,
       get_int64_ne,
       get_int64_be,
       get_int64_le,
       set_uint8,
       set_int8,
       set_uint16_ne,
       set_int16_be,
       set_int16_le,
       set_int16_ne,
       set_int16_be,
       set_int16_le,
       set_int32_ne,
       set_int32_be,
       set_int32_le,
       set_int64_ne,
       set_int64_be,
       set_int64_le];
    caml_register_global(813,Stdlib_bytesLabels,"Stdlib__bytesLabels");
    var
     Stdlib_stringLabels=
      [0,
       make$1,
       init$1,
       concat$0,
       equal$7,
       compare$7,
       contains_from$0,
       rcontains_from$0,
       contains$0,
       sub$0,
       split_on_char,
       map$5,
       mapi$1,
       trim$0,
       escaped$1,
       uppercase_ascii$1,
       lowercase_ascii$1,
       capitalize_ascii$0,
       uncapitalize_ascii$0,
       iter$4,
       iteri$1,
       index_from$0,
       index_from_opt$0,
       rindex_from$0,
       rindex_from_opt$0,
       index$0,
       index_opt$0,
       rindex$0,
       rindex_opt$0,
       to_seq$3,
       to_seqi$0,
       of_seq$1,
       blit$0,
       copy$0,
       fill,
       uppercase$1,
       lowercase$1,
       capitalize$0,
       uncapitalize$0];
    caml_register_global(814,Stdlib_stringLabels,"Stdlib__stringLabels");
    var Stdlib_moreLabels=[0,Stdlib_hashtbl,Stdlib_map,Stdlib_set];
    caml_register_global(815,Stdlib_moreLabels,"Stdlib__moreLabels");
    var Stdlib_stdLabels=[0];
    caml_register_global(816,Stdlib_stdLabels,"Stdlib__stdLabels");
    var
     float32=0,
     float64=1,
     int8_signed=2,
     int8_unsigned=3,
     int16_signed=4,
     int16_unsigned=5,
     int32$1=6,
     int64$1=7,
     int$2=8,
     nativeint$1=9,
     complex32=10,
     complex64=11,
     char$0=12;
    function kind_size_in_bytes(param)
     {switch(param)
       {case 0:return 4;
        case 1:return 8;
        case 2:return 1;
        case 3:return 1;
        case 4:return 2;
        case 5:return 2;
        case 6:return 4;
        case 7:return 8;
        case 8:return 4;
        case 9:return 4;
        case 10:return 8;
        case 11:return 16;
        default:return 1}}
    var c_layout=0,fortran_layout=1;
    function cloop(arr,idx,f,col,max)
     {if(col === idx.length - 1)
       return caml_ba_set_generic(arr,idx,caml_call1(f,idx));
      var _dW_=caml_check_bound(max,col)[1 + col] - 1 | 0,_dV_=0;
      if(! (_dW_ < 0))
       {var j=_dV_;
        for(;;)
         {caml_check_bound(idx,col)[1 + col] = j;
          cloop(arr,idx,f,col + 1 | 0,max);
          var _dX_=j + 1 | 0;
          if(_dW_ !== j){var j=_dX_;continue}
          break}}
      return 0}
    function floop(arr,idx,f,col,max)
     {if(0 <= col)
       {var _dT_=caml_check_bound(max,col)[1 + col],_dS_=1;
        if(! (_dT_ < 1))
         {var j=_dS_;
          for(;;)
           {caml_check_bound(idx,col)[1 + col] = j;
            floop(arr,idx,f,col - 1 | 0,max);
            var _dU_=j + 1 | 0;
            if(_dT_ !== j){var j=_dU_;continue}
            break}}
        return 0}
      return caml_ba_set_generic(arr,idx,caml_call1(f,idx))}
    function init$5(kind,layout,dims,f)
     {var arr=caml_ba_create(kind,layout,dims),dlen=dims.length - 1;
      return 0 === dlen
              ?arr
              :layout
                ?(floop(arr,caml_make_vect(dlen,1),f,dlen - 1 | 0,dims),arr)
                :(cloop(arr,caml_make_vect(dlen,0),f,0,dims),arr)}
    function dims(a)
     {var n=caml_ba_num_dims(a),d=caml_make_vect(n,0),_dP_=n - 1 | 0,_dO_=0;
      if(! (_dP_ < 0))
       {var i=_dO_;
        for(;;)
         {var _dQ_=runtime.caml_ba_dim(a,i);
          caml_check_bound(d,i)[1 + i] = _dQ_;
          var _dR_=i + 1 | 0;
          if(_dP_ !== i){var i=_dR_;continue}
          break}}
      return d}
    function size_in_bytes(arr)
     {var _dN_=fold_left$1(caml_mul,1,dims(arr));
      return caml_mul(kind_size_in_bytes(caml_ba_kind(arr)),_dN_)}
    function create$8(kind,layout){return caml_ba_create(kind,layout,[0])}
    function get$2(arr){return runtime.caml_ba_get_generic(arr,[0])}
    function set$1(arr)
     {var _dL_=[0];
      return function(_dM_){return caml_ba_set_generic(arr,_dL_,_dM_)}}
    function size_in_bytes$0(arr)
     {return kind_size_in_bytes(caml_ba_kind(arr))}
    function of_value(kind,layout,v)
     {var a=create$8(kind,layout);caml_call1(set$1(a),v);return a}
    function create$9(kind,layout,dim)
     {return caml_ba_create(kind,layout,[0,dim])}
    function size_in_bytes$1(arr)
     {var _dK_=caml_ba_dim_1(arr);
      return caml_mul(kind_size_in_bytes(caml_ba_kind(arr)),_dK_)}
    function slice(a,n)
     {var match=runtime.caml_ba_layout(a);
      return match?caml_ba_slice(a,[0,n]):caml_ba_slice(a,[0,n])}
    function init$6(kind,layout,dim,f)
     {var arr=create$9(kind,layout,dim);
      if(layout)
       {var _dI_=1;
        if(! (dim < 1))
         {var i$0=_dI_;
          for(;;)
           {caml_ba_set_1(arr,i$0,caml_call1(f,i$0));
            var _dJ_=i$0 + 1 | 0;
            if(dim !== i$0){var i$0=_dJ_;continue}
            break}}
        return arr}
      var _dG_=dim - 1 | 0,_dF_=0;
      if(! (_dG_ < 0))
       {var i=_dF_;
        for(;;)
         {caml_ba_set_1(arr,i,caml_call1(f,i));
          var _dH_=i + 1 | 0;
          if(_dG_ !== i){var i=_dH_;continue}
          break}}
      return arr}
    function of_array(kind,layout,data)
     {var
       ba=create$9(kind,layout,data.length - 1),
       ofs=layout?1:0,
       _dD_=data.length - 1 - 1 | 0,
       _dC_=0;
      if(! (_dD_ < 0))
       {var i=_dC_;
        for(;;)
         {caml_ba_set_1(ba,i + ofs | 0,caml_check_bound(data,i)[1 + i]);
          var _dE_=i + 1 | 0;
          if(_dD_ !== i){var i=_dE_;continue}
          break}}
      return ba}
    function create$10(kind,layout,dim1,dim2)
     {return caml_ba_create(kind,layout,[0,dim1,dim2])}
    function size_in_bytes$2(arr)
     {var _dA_=caml_ba_dim_2(arr),_dB_=caml_ba_dim_1(arr);
      return caml_mul
              (caml_mul(kind_size_in_bytes(caml_ba_kind(arr)),_dB_),_dA_)}
    function slice_left(a,n){return caml_ba_slice(a,[0,n])}
    function slice_right(a,n){return caml_ba_slice(a,[0,n])}
    function init$7(kind,layout,dim1,dim2,f)
     {var arr=create$10(kind,layout,dim1,dim2);
      if(layout)
       {var _dw_=1;
        if(! (dim2 < 1))
         {var j$0=_dw_;
          for(;;)
           {var _dx_=1;
            if(! (dim1 < 1))
             {var i$0=_dx_;
              for(;;)
               {caml_ba_set_2(arr,i$0,j$0,caml_call2(f,i$0,j$0));
                var _dz_=i$0 + 1 | 0;
                if(dim1 !== i$0){var i$0=_dz_;continue}
                break}}
            var _dy_=j$0 + 1 | 0;
            if(dim2 !== j$0){var j$0=_dy_;continue}
            break}}
        return arr}
      var _dr_=dim1 - 1 | 0,_dq_=0;
      if(! (_dr_ < 0))
       {var i=_dq_;
        for(;;)
         {var _dt_=dim2 - 1 | 0,_ds_=0;
          if(! (_dt_ < 0))
           {var j=_ds_;
            for(;;)
             {caml_ba_set_2(arr,i,j,caml_call2(f,i,j));
              var _dv_=j + 1 | 0;
              if(_dt_ !== j){var j=_dv_;continue}
              break}}
          var _du_=i + 1 | 0;
          if(_dr_ !== i){var i=_du_;continue}
          break}}
      return arr}
    function of_array$0(kind,layout,data)
     {var
       dim1=data.length - 1,
       dim2=0 === dim1?0:caml_check_bound(data,0)[1].length - 1,
       ba=create$10(kind,layout,dim1,dim2),
       ofs=layout?1:0,
       _dl_=dim1 - 1 | 0,
       _dk_=0;
      if(! (_dl_ < 0))
       {var i=_dk_;
        for(;;)
         {var row=caml_check_bound(data,i)[1 + i];
          if(row.length - 1 !== dim2)
           invalid_arg(cst_Bigarray_Array2_of_array_n);
          var _dn_=dim2 - 1 | 0,_dm_=0;
          if(! (_dn_ < 0))
           {var j=_dm_;
            for(;;)
             {caml_ba_set_2
               (ba,i + ofs | 0,j + ofs | 0,caml_check_bound(row,j)[1 + j]);
              var _dp_=j + 1 | 0;
              if(_dn_ !== j){var j=_dp_;continue}
              break}}
          var _do_=i + 1 | 0;
          if(_dl_ !== i){var i=_do_;continue}
          break}}
      return ba}
    function create$11(kind,layout,dim1,dim2,dim3)
     {return caml_ba_create(kind,layout,[0,dim1,dim2,dim3])}
    function size_in_bytes$3(arr)
     {var
       _dh_=runtime.caml_ba_dim_3(arr),
       _di_=caml_ba_dim_2(arr),
       _dj_=caml_ba_dim_1(arr);
      return caml_mul
              (caml_mul
                (caml_mul(kind_size_in_bytes(caml_ba_kind(arr)),_dj_),_di_),
               _dh_)}
    function slice_left_1(a,n,m){return caml_ba_slice(a,[0,n,m])}
    function slice_right_1(a,n,m){return caml_ba_slice(a,[0,n,m])}
    function slice_left_2(a,n){return caml_ba_slice(a,[0,n])}
    function slice_right_2(a,n){return caml_ba_slice(a,[0,n])}
    function init$8(kind,layout,dim1,dim2,dim3,f)
     {var arr=create$11(kind,layout,dim1,dim2,dim3);
      if(layout)
       {var _db_=1;
        if(! (dim3 < 1))
         {var k$0=_db_;
          for(;;)
           {var _dc_=1;
            if(! (dim2 < 1))
             {var j$0=_dc_;
              for(;;)
               {var _de_=1;
                if(! (dim1 < 1))
                 {var i$0=_de_;
                  for(;;)
                   {caml_ba_set_3(arr,i$0,j$0,k$0,caml_call3(f,i$0,j$0,k$0));
                    var _dg_=i$0 + 1 | 0;
                    if(dim1 !== i$0){var i$0=_dg_;continue}
                    break}}
                var _df_=j$0 + 1 | 0;
                if(dim2 !== j$0){var j$0=_df_;continue}
                break}}
            var _dd_=k$0 + 1 | 0;
            if(dim3 !== k$0){var k$0=_dd_;continue}
            break}}
        return arr}
      var _c5_=dim1 - 1 | 0,_c4_=0;
      if(! (_c5_ < 0))
       {var i=_c4_;
        for(;;)
         {var _c7_=dim2 - 1 | 0,_c6_=0;
          if(! (_c7_ < 0))
           {var j=_c6_;
            for(;;)
             {var _c__=dim3 - 1 | 0,_c9_=0;
              if(! (_c__ < 0))
               {var k=_c9_;
                for(;;)
                 {caml_ba_set_3(arr,i,j,k,caml_call3(f,i,j,k));
                  var _da_=k + 1 | 0;
                  if(_c__ !== k){var k=_da_;continue}
                  break}}
              var _c$_=j + 1 | 0;
              if(_c7_ !== j){var j=_c$_;continue}
              break}}
          var _c8_=i + 1 | 0;
          if(_c5_ !== i){var i=_c8_;continue}
          break}}
      return arr}
    function of_array$1(kind,layout,data)
     {var
       dim1=data.length - 1,
       dim2=0 === dim1?0:caml_check_bound(data,0)[1].length - 1,
       dim3=
        0 === dim2
         ?0
         :caml_check_bound(caml_check_bound(data,0)[1],0)[1].length - 1,
       ba=create$11(kind,layout,dim1,dim2,dim3),
       ofs=layout?1:0,
       _cW_=dim1 - 1 | 0,
       _cV_=0;
      if(! (_cW_ < 0))
       {var i=_cV_;
        for(;;)
         {var row=caml_check_bound(data,i)[1 + i];
          if(row.length - 1 !== dim2)
           invalid_arg(cst_Bigarray_Array3_of_array_n);
          var _cY_=dim2 - 1 | 0,_cX_=0;
          if(! (_cY_ < 0))
           {var j=_cX_;
            for(;;)
             {var col=caml_check_bound(row,j)[1 + j];
              if(col.length - 1 !== dim3)
               invalid_arg(cst_Bigarray_Array3_of_array_n$0);
              var _c1_=dim3 - 1 | 0,_c0_=0;
              if(! (_c1_ < 0))
               {var k=_c0_;
                for(;;)
                 {caml_ba_set_3
                   (ba,
                    i + ofs | 0,
                    j + ofs | 0,
                    k + ofs | 0,
                    caml_check_bound(col,k)[1 + k]);
                  var _c3_=k + 1 | 0;
                  if(_c1_ !== k){var k=_c3_;continue}
                  break}}
              var _c2_=j + 1 | 0;
              if(_cY_ !== j){var j=_c2_;continue}
              break}}
          var _cZ_=i + 1 | 0;
          if(_cW_ !== i){var i=_cZ_;continue}
          break}}
      return ba}
    function array0_of_genarray(a)
     {return 0 === caml_ba_num_dims(a)
              ?a
              :invalid_arg(cst_Bigarray_array0_of_genarra)}
    function array1_of_genarray(a)
     {return 1 === caml_ba_num_dims(a)
              ?a
              :invalid_arg(cst_Bigarray_array1_of_genarra)}
    function array2_of_genarray(a)
     {return 2 === caml_ba_num_dims(a)
              ?a
              :invalid_arg(cst_Bigarray_array2_of_genarra)}
    function array3_of_genarray(a)
     {return 3 === caml_ba_num_dims(a)
              ?a
              :invalid_arg(cst_Bigarray_array3_of_genarra)}
    function reshape_0(a){return caml_ba_reshape(a,[0])}
    function reshape_1(a,dim1){return caml_ba_reshape(a,[0,dim1])}
    function reshape_2(a,dim1,dim2){return caml_ba_reshape(a,[0,dim1,dim2])}
    function reshape_3(a,dim1,dim2,dim3)
     {return caml_ba_reshape(a,[0,dim1,dim2,dim3])}
    var
     Stdlib_bigarray=
      [0,
       float32,
       float64,
       complex32,
       complex64,
       int8_signed,
       int8_unsigned,
       int16_signed,
       int16_unsigned,
       int$2,
       int32$1,
       int64$1,
       nativeint$1,
       char$0,
       kind_size_in_bytes,
       c_layout,
       fortran_layout,
       [0,init$5,dims,size_in_bytes],
       [0,
        create$8,
        of_value,
        caml_ba_change_layout,
        size_in_bytes$0,
        get$2,
        set$1,
        of_value],
       [0,
        create$9,
        init$6,
        caml_ba_change_layout,
        size_in_bytes$1,
        slice,
        of_array],
       [0,
        create$10,
        init$7,
        caml_ba_change_layout,
        size_in_bytes$2,
        slice_left,
        slice_right,
        of_array$0],
       [0,
        create$11,
        init$8,
        caml_ba_change_layout,
        size_in_bytes$3,
        slice_left_1,
        slice_right_1,
        slice_left_2,
        slice_right_2,
        of_array$1],
       array0_of_genarray,
       array1_of_genarray,
       array2_of_genarray,
       array3_of_genarray,
       caml_ba_reshape,
       reshape_0,
       reshape_1,
       reshape_2,
       reshape_3];
    caml_register_global(817,Stdlib_bigarray,"Stdlib__bigarray");
    return}
  (function(){return this}()));


//# 1 ".js/num.core/nums.cma.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     add_nat=runtime.add_nat,
     blit_nat=runtime.blit_nat,
     caml_bytes_get=runtime.caml_bytes_get,
     caml_bytes_set=runtime.caml_bytes_set,
     caml_div=runtime.caml_div,
     caml_equal=runtime.caml_equal,
     caml_greaterequal=runtime.caml_greaterequal,
     caml_greaterthan=runtime.caml_greaterthan,
     caml_int64_and=runtime.caml_int64_and,
     caml_int64_neg=runtime.caml_int64_neg,
     caml_int64_of_int32=runtime.caml_int64_of_int32,
     caml_int64_or=runtime.caml_int64_or,
     caml_int64_to_float=runtime.caml_int64_to_float,
     caml_int64_to_int32=runtime.caml_int64_to_int32,
     caml_ldexp_float=runtime.caml_ldexp_float,
     caml_ml_bytes_length=runtime.caml_ml_bytes_length,
     caml_ml_string_length=runtime.caml_ml_string_length,
     caml_mod=runtime.caml_mod,
     caml_mul=runtime.caml_mul,
     caml_register_global=runtime.caml_register_global,
     caml_string_get=runtime.caml_string_get,
     caml_string_of_jsbytes=runtime.caml_string_of_jsbytes,
     caml_wrap_exception=runtime.caml_wrap_exception,
     compare_nat=runtime.compare_nat,
     complement_nat=runtime.complement_nat,
     create_nat=runtime.create_nat,
     decr_nat=runtime.decr_nat,
     div_digit_nat=runtime.div_digit_nat,
     div_nat=runtime.div_nat,
     incr_nat=runtime.incr_nat,
     is_digit_int=runtime.is_digit_int,
     is_digit_zero=runtime.is_digit_zero,
     land_digit_nat=runtime.land_digit_nat,
     mult_digit_nat=runtime.mult_digit_nat,
     mult_nat=runtime.mult_nat,
     nth_digit_nat=runtime.nth_digit_nat,
     nth_digit_nat_native=runtime.nth_digit_nat_native,
     num_digits_nat=runtime.num_digits_nat,
     num_leading_zero_bits_in_digit=runtime.num_leading_zero_bits_in_digit,
     set_digit_nat=runtime.set_digit_nat,
     set_digit_nat_native=runtime.set_digit_nat_native,
     set_to_zero_nat=runtime.set_to_zero_nat,
     shift_right_nat=runtime.shift_right_nat,
     square_nat=runtime.square_nat,
     sub_nat=runtime.sub_nat;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5
              ?f(a0,a1,a2,a3,a4)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4])}
    var
     global_data=runtime.caml_get_global_data(),
     cst_invalid_digit=caml_string_of_jsbytes("invalid digit"),
     cst_number_too_long=caml_string_of_jsbytes("number too long"),
     cst_power_base_int=caml_string_of_jsbytes("power_base_int"),
     cst_nat_of_int=caml_string_of_jsbytes("nat_of_int"),
     cst_int_of_nat=caml_string_of_jsbytes("int_of_nat"),
     cst_make_nat=caml_string_of_jsbytes("make_nat"),
     cst_xor_big_int=caml_string_of_jsbytes("xor_big_int"),
     cst_or_big_int=caml_string_of_jsbytes("or_big_int"),
     cst_and_big_int=caml_string_of_jsbytes("and_big_int"),
     cst_extract_big_int=caml_string_of_jsbytes("extract_big_int"),
     cst_shift_right_big_int=caml_string_of_jsbytes("shift_right_big_int"),
     cst_two_power_m1_big_int=caml_string_of_jsbytes("two_power_m1_big_int"),
     cst_shift_right_towards_zero_b=
      caml_string_of_jsbytes("shift_right_towards_zero_big_int"),
     cst_shift_left_big_int=caml_string_of_jsbytes("shift_left_big_int"),
     cst_100000000=caml_string_of_jsbytes("100000000"),
     cst_963295986=caml_string_of_jsbytes("963295986"),
     cst$0=caml_string_of_jsbytes("-"),
     sign=caml_string_of_jsbytes(""),
     cst_e=caml_string_of_jsbytes("e"),
     cst_1=caml_string_of_jsbytes("1."),
     cst_e$0=caml_string_of_jsbytes("e"),
     cst$1=caml_string_of_jsbytes("."),
     cst_sqrt_big_int=caml_string_of_jsbytes("sqrt_big_int"),
     cst_base_power_big_int=caml_string_of_jsbytes("base_power_big_int"),
     cst_base_power_big_int$0=caml_string_of_jsbytes("base_power_big_int"),
     cst_base_power_big_int$1=caml_string_of_jsbytes("base_power_big_int"),
     cst_power_big_int_positive_big=
      caml_string_of_jsbytes("power_big_int_positive_big_int"),
     cst_power_int_positive_big_int=
      caml_string_of_jsbytes("power_int_positive_big_int"),
     cst_power_big_int_positive_int=
      caml_string_of_jsbytes("power_big_int_positive_int"),
     cst_power_int_positive_int=
      caml_string_of_jsbytes("power_int_positive_int"),
     cst_sys_big_int_of_string$1=
      caml_string_of_jsbytes("sys_big_int_of_string"),
     cst_sys_big_int_of_string$0=
      caml_string_of_jsbytes("sys_big_int_of_string"),
     cst_sys_big_int_of_string=caml_string_of_jsbytes("sys_big_int_of_string"),
     cst=caml_string_of_jsbytes("-"),
     cst_nat_of_big_int=caml_string_of_jsbytes("nat_of_big_int"),
     cst_int64_of_big_int$1=caml_string_of_jsbytes("int64_of_big_int"),
     cst_int64_of_big_int=caml_string_of_jsbytes("int64_of_big_int"),
     cst_int64_of_big_int$0=caml_string_of_jsbytes("int64_of_big_int"),
     cst_int32_of_big_int=caml_string_of_jsbytes("int32_of_big_int"),
     cst_nativeint_of_big_int=caml_string_of_jsbytes("nativeint_of_big_int"),
     cst_nativeint_of_big_int$0=caml_string_of_jsbytes("nativeint_of_big_int"),
     cst_nativeint_of_big_int$1=caml_string_of_jsbytes("nativeint_of_big_int"),
     cst_int_of_big_int=caml_string_of_jsbytes("int_of_big_int"),
     cst_create_big_int=caml_string_of_jsbytes("create_big_int"),
     cst$5=caml_string_of_jsbytes("/"),
     cst_approx_ratio_exp=caml_string_of_jsbytes("approx_ratio_exp"),
     cst_approx_ratio_exp$0=caml_string_of_jsbytes("approx_ratio_exp"),
     cst_0$0=caml_string_of_jsbytes("+0."),
     cst$4=caml_string_of_jsbytes(""),
     cst_1$1=caml_string_of_jsbytes("-1."),
     cst_1$2=caml_string_of_jsbytes("+1."),
     cst_0$1=caml_string_of_jsbytes("-0."),
     cst_0$2=caml_string_of_jsbytes("+0."),
     cst_approx_ratio_fix=caml_string_of_jsbytes("approx_ratio_fix"),
     cst_0=caml_string_of_jsbytes("+0"),
     cst_1$0=caml_string_of_jsbytes("1"),
     cst_msd_ratio=caml_string_of_jsbytes("msd_ratio"),
     cst_big_int_of_ratio=caml_string_of_jsbytes("big_int_of_ratio"),
     cst_nat_of_ratio$0=caml_string_of_jsbytes("nat_of_ratio"),
     cst_nat_of_ratio=caml_string_of_jsbytes("nat_of_ratio"),
     cst_integer_argument_required=
      caml_string_of_jsbytes("integer argument required"),
     cst_integer_ratio=caml_string_of_jsbytes("integer_ratio"),
     cst_inverse_ratio=caml_string_of_jsbytes("inverse_ratio"),
     cst_create_normalized_ratio=
      caml_string_of_jsbytes("create_normalized_ratio"),
     cst_create_ratio=caml_string_of_jsbytes("create_ratio"),
     cst$3=caml_string_of_jsbytes(""),
     s=caml_string_of_jsbytes("infinite or undefined rational number"),
     cst$2=caml_string_of_jsbytes(" "),
     cst_num_of_string=caml_string_of_jsbytes("num_of_string"),
     cst_power_num=caml_string_of_jsbytes("power_num"),
     cst_Normalization_during_compu=
      caml_string_of_jsbytes("Normalization during computation"),
     cst_returned_by_get_normalize_=
      caml_string_of_jsbytes("     (returned by get_normalize_ratio ())"),
     cst_modifiable_with_set_normal=
      caml_string_of_jsbytes
       ("     (modifiable with set_normalize_ratio <your choice>)"),
     cst_Normalization_when_printin=
      caml_string_of_jsbytes("Normalization when printing"),
     cst_returned_by_get_normalize_$0=
      caml_string_of_jsbytes
       ("     (returned by get_normalize_ratio_when_printing ())"),
     cst_modifiable_with_set_normal$0=
      caml_string_of_jsbytes
       ("     (modifiable with set_normalize_ratio_when_printing <your choice>)"),
     cst_Floating_point_approximati=
      caml_string_of_jsbytes
       ("Floating point approximation when printing rational numbers"),
     cst_returned_by_get_approx_pri=
      caml_string_of_jsbytes("     (returned by get_approx_printing ())"),
     cst_modifiable_with_set_approx=
      caml_string_of_jsbytes
       ("     (modifiable with set_approx_printing <your choice>)"),
     cst_Default_precision=caml_string_of_jsbytes("  Default precision = "),
     cst_returned_by_get_floating_p=
      caml_string_of_jsbytes("     (returned by get_floating_precision ())"),
     cst_modifiable_with_set_floati=
      caml_string_of_jsbytes
       ("     (modifiable with set_floating_precision <your choice>)"),
     cst_Error_when_a_rational_deno=
      caml_string_of_jsbytes("Error when a rational denominator is null"),
     cst_returned_by_get_error_when=
      caml_string_of_jsbytes
       ("     (returned by get_error_when_null_denominator ())"),
     cst_modifiable_with_set_error_=
      caml_string_of_jsbytes
       ("     (modifiable with set_error_when_null_denominator <your choice>)"),
     cst_ON=caml_string_of_jsbytes("ON"),
     cst_OFF=caml_string_of_jsbytes("OFF"),
     cst$6=caml_string_of_jsbytes(" --> "),
     Stdlib=global_data.Stdlib,
     Stdlib_sys=global_data.Stdlib__sys,
     Stdlib_string=global_data.Stdlib__string,
     Stdlib_bytes=global_data.Stdlib__bytes,
     Stdlib_char=global_data.Stdlib__char,
     Assert_failure=global_data.Assert_failure,
     Stdlib_int64=global_data.Stdlib__int64,
     Stdlib_nativeint=global_data.Stdlib__nativeint,
     _z_=[0,caml_string_of_jsbytes("nat.ml"),273,9],
     _y_=runtime.caml_int64_create_lo_mi_hi(6553600,11973543,3552),
     _x_=[0,caml_string_of_jsbytes("nat.ml"),280,9],
     _w_=[0,caml_string_of_jsbytes("nat.ml"),287,9],
     _v_=[0,caml_string_of_jsbytes("nat.ml"),293,9],
     _u_=runtime.caml_int64_create_lo_mi_hi(6553600,11973543,3552),
     _l_=[0,caml_string_of_jsbytes("big_int.ml"),879,2],
     _k_=runtime.caml_int64_create_lo_mi_hi(1,0,0),
     _j_=runtime.caml_int64_create_lo_mi_hi(16777215,255,0),
     _g_=runtime.caml_int64_create_lo_mi_hi(16777215,255,0),
     _h_=runtime.caml_int64_create_lo_mi_hi(0,0,0),
     _i_=runtime.caml_int64_create_lo_mi_hi(0,0,0),
     _d_=runtime.caml_int64_create_lo_mi_hi(0,0,0),
     _e_=runtime.caml_int64_create_lo_mi_hi(0,0,0),
     _f_=runtime.caml_int64_create_lo_mi_hi(0,0,0),
     _n_=[0,caml_string_of_jsbytes("ratio.ml"),575,11],
     _m_=[0,caml_string_of_jsbytes("e0"),0],
     _r_=[0,1],
     _s_=[0,1],
     _t_=[0,1],
     _o_=[0,1],
     _p_=[0,1],
     _q_=[0,1];
    function gcd_int(i1,i2)
     {var i1$0=i1,i2$0=i2;
      for(;;)
       {if(0 === i2$0)return caml_call1(Stdlib[18],i1$0);
        var i2$1=caml_mod(i1$0,i2$0),i1$0=i2$0,i2$0=i2$1;
        continue}}
    function num_bits_int_aux(n)
     {return 0 === n?0:num_bits_int_aux(n >>> 1 | 0) + 1 | 0}
    function num_bits_int(n)
     {return num_bits_int_aux(caml_call1(Stdlib[18],n))}
    function sign_int(i){return 0 === i?0:0 < i?1:-1}
    var
     length_of_int=Stdlib_sys[10] - 1 | 0,
     monster_int=1 << length_of_int,
     biggest_int=monster_int - 1 | 0,
     least_int=- biggest_int | 0;
    function compare_int(n1,n2)
     {return n1 === n2?0:caml_greaterthan(n1,n2)?1:-1}
    var
     Int_misc=
      [0,
       gcd_int,
       num_bits_int,
       compare_int,
       sign_int,
       length_of_int,
       biggest_int,
       least_int,
       monster_int];
    caml_register_global(122,Int_misc,"Int_misc");
    runtime.initialize_nat(0);
    function length_nat(n){return n.length - 1 - 1 | 0}
    var _a_=Stdlib_sys[9];
    function make_nat(len)
     {if(0 <= len)
       {var res=create_nat(len);set_to_zero_nat(res,0,len);return res}
      return caml_call1(Stdlib[1],cst_make_nat)}
    var a_2=make_nat(2),a_1=make_nat(1),b_2=make_nat(2);
    function copy_nat(nat,off_set,length)
     {var res=create_nat(length);
      blit_nat(res,0,nat,off_set,length);
      return res}
    function is_zero_nat(n,off,len)
     {var _dl_=num_digits_nat(n,off,len);
      return 0 === compare_nat(make_nat(1),0,1,n,off,_dl_)?1:0}
    function is_nat_int(nat,off,len)
     {var
       _dj_=1 === num_digits_nat(nat,off,len)?1:0,
       _dk_=_dj_?is_digit_int(nat,off):_dj_;
      return _dk_}
    function int_of_nat(nat)
     {var len=length_nat(nat);
      return is_nat_int(nat,0,len)
              ?nth_digit_nat(nat,0)
              :caml_call1(Stdlib[2],cst_int_of_nat)}
    function nat_of_int(i)
     {if(0 <= i)
       {var res=make_nat(1);return 0 === i?res:(set_digit_nat(res,0,i),res)}
      return caml_call1(Stdlib[1],cst_nat_of_int)}
    function eq_nat(nat1,off1,len1,nat2,off2,len2)
     {var _di_=num_digits_nat(nat2,off2,len2);
      return 0
              ===
              compare_nat
               (nat1,off1,num_digits_nat(nat1,off1,len1),nat2,off2,_di_)
              ?1
              :0}
    function le_nat(nat1,off1,len1,nat2,off2,len2)
     {var _dh_=num_digits_nat(nat2,off2,len2);
      return compare_nat
               (nat1,off1,num_digits_nat(nat1,off1,len1),nat2,off2,_dh_)
              <=
              0
              ?1
              :0}
    function lt_nat(nat1,off1,len1,nat2,off2,len2)
     {var _dg_=num_digits_nat(nat2,off2,len2);
      return compare_nat
               (nat1,off1,num_digits_nat(nat1,off1,len1),nat2,off2,_dg_)
              <
              0
              ?1
              :0}
    function ge_nat(nat1,off1,len1,nat2,off2,len2)
     {var _df_=num_digits_nat(nat2,off2,len2);
      return 0
              <=
              compare_nat
               (nat1,off1,num_digits_nat(nat1,off1,len1),nat2,off2,_df_)
              ?1
              :0}
    function gt_nat(nat1,off1,len1,nat2,off2,len2)
     {var _de_=num_digits_nat(nat2,off2,len2);
      return 0
              <
              compare_nat
               (nat1,off1,num_digits_nat(nat1,off1,len1),nat2,off2,_de_)
              ?1
              :0}
    function exchange(r1,r2)
     {var old1=r1[1];r1[1] = r2[1];r2[1] = old1;return 0}
    function gcd_nat(nat1,off1,len1,nat2,off2,len2)
     {if(is_zero_nat(nat1,off1,len1))
       {blit_nat(nat1,off1,nat2,off2,len2);return len2}
      var
       copy1=[0,create_nat(len1 + 1 | 0)],
       copy2=[0,create_nat(len2 + 1 | 0)];
      blit_nat(copy1[1],0,nat1,off1,len1);
      blit_nat(copy2[1],0,nat2,off2,len2);
      set_digit_nat(copy1[1],len1,0);
      set_digit_nat(copy2[1],len2,0);
      if(lt_nat(copy1[1],0,len1,copy2[1],0,len2))exchange(copy1,copy2);
      var
       _dc_=length_nat(copy1[1]),
       real_len1=[0,num_digits_nat(copy1[1],0,_dc_)],
       _dd_=length_nat(copy2[1]),
       real_len2=[0,num_digits_nat(copy2[1],0,_dd_)];
      for(;;)
       {if(is_zero_nat(copy2[1],0,real_len2[1]))
         {blit_nat(nat1,off1,copy1[1],0,real_len1[1]);return real_len1[1]}
        set_digit_nat(copy1[1],real_len1[1],0);
        div_nat(copy1[1],0,real_len1[1] + 1 | 0,copy2[1],0,real_len2[1]);
        exchange(copy1,copy2);
        real_len1[1] = real_len2[1];
        real_len2[1] = num_digits_nat(copy2[1],0,real_len2[1]);
        continue}}
    function sqrt_nat(rad,off,len)
     {var
       len$0=num_digits_nat(rad,off,len),
       len_parity=len$0 % 2 | 0,
       rad_len=(len$0 + 1 | 0) + len_parity | 0,
       rad$0=create_nat(rad_len);
      blit_nat(rad$0,0,rad,off,len$0);
      set_digit_nat(rad$0,len$0,0);
      set_digit_nat(rad$0,rad_len - 1 | 0,0);
      var
       cand_len=(len$0 + 1 | 0) / 2 | 0,
       cand_rest=rad_len - cand_len | 0,
       cand=make_nat(cand_len),
       shift_cand=
        (num_leading_zero_bits_in_digit(rad$0,len$0 - 1 | 0)
         +
         caml_mul(_a_,len_parity)
         |
         0)
        /
        2
        |
        0;
      if(shift_cand === _a_)return cand;
      complement_nat(cand,0,cand_len);
      shift_right_nat(cand,0,1,a_1,0,shift_cand);
      var next_cand=create_nat(rad_len);
      for(;;)
       {blit_nat(next_cand,0,rad$0,0,rad_len);
        div_nat(next_cand,0,rad_len,cand,0,cand_len);
        add_nat(next_cand,cand_len,cand_rest,cand,0,cand_len,0);
        shift_right_nat(next_cand,cand_len,cand_rest,a_1,0,1);
        if(lt_nat(next_cand,cand_len,cand_rest,cand,0,cand_len))
         {blit_nat(cand,0,next_cand,cand_len,cand_len);continue}
        return cand}}
    var power_base_max=make_nat(2);
    if(32 === _a_)
     set_digit_nat(power_base_max,0,1000000000);
    else
     {if(64 !== _a_)throw [0,Assert_failure,_z_];
      set_digit_nat(power_base_max,0,caml_int64_to_int32(_y_));
      mult_digit_nat(power_base_max,0,2,power_base_max,0,1,nat_of_int(9),0)}
    if(32 === _a_)
     var _b_=9;
    else
     {if(64 !== _a_)throw [0,Assert_failure,_x_];var _b_=19}
    if(32 === _a_)
     var _c_=9;
    else
     {if(64 !== _a_)throw [0,Assert_failure,_w_];var _c_=18}
    if(32 === _a_)
     var max_power_10_power_in_int=nat_of_int(1000000000);
    else
     {if(64 !== _a_)throw [0,Assert_failure,_v_];
      var max_power_10_power_in_int=nat_of_int(caml_int64_to_int32(_u_))}
    function raw_string_of_digit(nat,off)
     {if(is_nat_int(nat,off,1))
       {var _c$_=nth_digit_nat(nat,off);return caml_call1(Stdlib[33],_c$_)}
      blit_nat(b_2,0,nat,off,1);
      div_digit_nat(a_2,0,a_1,0,b_2,0,2,max_power_10_power_in_int,0);
      var
       leading_digits=nth_digit_nat(a_2,0),
       _da_=nth_digit_nat(a_1,0),
       s1=caml_call1(Stdlib[33],_da_),
       len=caml_ml_string_length(s1);
      if(10 <= leading_digits)
       {var
         result=caml_call2(Stdlib_bytes[1],_c_ + 2 | 0,48),
         _db_=caml_call1(Stdlib[33],leading_digits);
        caml_call5(Stdlib_string[32],_db_,0,result,0,2);
        caml_call5
         (Stdlib_string[32],
          s1,
          0,
          result,
          caml_ml_bytes_length(result) - len | 0,
          len);
        return caml_call1(Stdlib_bytes[6],result)}
      var result$0=caml_call2(Stdlib_bytes[1],_c_ + 1 | 0,48);
      caml_bytes_set
       (result$0,0,caml_call1(Stdlib_char[1],48 + leading_digits | 0));
      caml_call5
       (Stdlib_string[32],
        s1,
        0,
        result$0,
        caml_ml_bytes_length(result$0) - len | 0,
        len);
      return caml_call1(Stdlib_bytes[6],result$0)}
    function make_power_base(base,power_base)
     {var i=[0,0],j=[0,0];
      set_digit_nat(power_base,0,base);
      for(;;)
       {i[1]++;
        if(is_digit_zero(power_base,i[1]))
         {mult_digit_nat
           (power_base,i[1],2,power_base,i[1] - 1 | 0,1,power_base,0);
          continue}
        for(;;)
         {if(j[1] < (i[1] - 1 | 0) && is_digit_int(power_base,j[1]))
           {j[1]++;continue}
          return [0,i[1] - 2 | 0,j[1]]}}}
    function power_base_int(base,i)
     {if(0 !== i && 1 !== base)
       {if(0 === base)return nat_of_int(0);
        if(0 <= i)
         {var
           power_base=make_nat(_a_ + 1 | 0),
           match=make_power_base(base,power_base),
           pmax=match[1],
           n=caml_div(i,pmax + 1 | 0),
           rem=caml_mod(i,pmax + 1 | 0);
          if(0 < n)
           {var
             newn=i === biggest_int?n:n + 1 | 0,
             res=make_nat(newn),
             res2=make_nat(newn),
             l=num_bits_int(n) - 2 | 0;
            blit_nat(res,0,power_base,pmax,1);
            if(! (l < 0))
             {var i$0=l;
              for(;;)
               {var
                 len=num_digits_nat(res,0,newn),
                 len2=caml_call2(Stdlib[16],n,2 * len | 0),
                 succ_len2=len2 + 1 | 0;
                square_nat(res2,0,len2,res,0,len);
                if(0 < (n & 1 << i$0))
                 {set_to_zero_nat(res,0,len);
                  mult_digit_nat(res,0,succ_len2,res2,0,len2,power_base,pmax)}
                else
                 blit_nat(res,0,res2,0,len2);
                set_to_zero_nat(res2,0,len2);
                var _c__=i$0 - 1 | 0;
                if(0 !== i$0){var i$0=_c__;continue}
                break}}
            return 0 < rem
                    ?(mult_digit_nat(res2,0,newn,res,0,n,power_base,rem - 1 | 0),
                      res2)
                    :res}
          return copy_nat(power_base,rem - 1 | 0,1)}
        return caml_call1(Stdlib[1],cst_power_base_int)}
      return nat_of_int(1)}
    function unadjusted_string_of_nat(nat,off,len_nat)
     {var len=num_digits_nat(nat,off,len_nat);
      if(1 === len)return raw_string_of_digit(nat,off);
      var
       len_copy=[0,len + 1 | 0],
       copy1=create_nat(len_copy[1]),
       copy2=make_nat(len_copy[1]),
       rest_digit=make_nat(2);
      if(caml_div(biggest_int,_b_ + 1 | 0) < len)
       return caml_call1(Stdlib[2],cst_number_too_long);
      var
       len_s=caml_mul(_b_ + 1 | 0,len),
       s=caml_call2(Stdlib_bytes[1],len_s,48),
       pos_ref=[0,len_s];
      len_copy[1] = len_copy[1] - 1 | 0;
      blit_nat(copy1,0,nat,off,len);
      set_digit_nat(copy1,len,0);
      for(;;)
       {if(is_zero_nat(copy1,0,len_copy[1]))
         return caml_call1(Stdlib_bytes[42],s);
        div_digit_nat
         (copy2,0,rest_digit,0,copy1,0,len_copy[1] + 1 | 0,power_base_max,0);
        var str=raw_string_of_digit(rest_digit,0);
        caml_call5
         (Stdlib_string[32],
          str,
          0,
          s,
          pos_ref[1] - caml_ml_string_length(str) | 0,
          caml_ml_string_length(str));
        pos_ref[1] = pos_ref[1] - _b_ | 0;
        len_copy[1] = num_digits_nat(copy2,0,len_copy[1]);
        blit_nat(copy1,0,copy2,0,len_copy[1]);
        set_digit_nat(copy1,len_copy[1],0);
        continue}}
    function string_of_nat(nat)
     {var s=unadjusted_string_of_nat(nat,0,length_nat(nat)),index=[0,0];
      try
       {var _c7_=caml_ml_string_length(s) - 2 | 0,_c6_=0;
        if(! (_c7_ < 0))
         {var i=_c6_;
          for(;;)
           {if(48 !== caml_string_get(s,i)){index[1] = i;throw Stdlib[3]}
            var _c8_=i + 1 | 0;
            if(_c7_ !== i){var i=_c8_;continue}
            break}}}
      catch(_c9_)
       {_c9_ = caml_wrap_exception(_c9_);if(_c9_ !== Stdlib[3])throw _c9_}
      return caml_call3
              (Stdlib_string[9],
               s,
               index[1],
               caml_ml_string_length(s) - index[1] | 0)}
    function sys_nat_of_string(base,s,off,len)
     {var
       power_base=make_nat(_a_ + 1 | 0),
       match=make_power_base(base,power_base),
       pint=match[2],
       pmax=match[1],
       _cY_=1 + caml_div(len,pmax + 1 | 0) | 0,
       current_len=[0,1],
       possible_len=[0,caml_call2(Stdlib[16],2,_cY_)],
       nat1=make_nat(_cY_),
       nat2=make_nat(_cY_),
       digits_read=[0,0],
       bound=(off + len | 0) - 1 | 0,
       int$0=[0,0];
      if(! (bound < off))
       {var i=off;
        for(;;)
         {var n=caml_string_get(s,i),switch$0=0;
          if(32 <= n)
           {if(93 <= n)
             {if(95 === n && off < i)switch$0 = 2}
            else
             if(58 < (n - 33 | 0) >>> 0)switch$0 = 1}
          else
           if(11 <= n){if(13 === n)switch$0 = 1}else if(9 <= n)switch$0 = 1;
          switch(switch$0)
           {case 0:
             var switch$1=0;
             if(48 <= n && n <= (47 + caml_call2(Stdlib[16],base,10) | 0))
              var _c5_=n - 48 | 0;
             else
              switch$1 = 1;
             if(switch$1)
              {var switch$2=0;
               if(65 <= n && n <= ((65 + base | 0) - 11 | 0))
                var _c5_=n - 55 | 0;
               else
                switch$2 = 1;
               if(switch$2)
                {var switch$3=0;
                 if(97 <= n && n <= ((97 + base | 0) - 11 | 0))
                  var _c5_=n - 87 | 0;
                 else
                  switch$3 = 1;
                 if(switch$3)var _c5_=caml_call1(Stdlib[2],cst_invalid_digit)}}
             int$0[1] = caml_mul(int$0[1],base) + _c5_ | 0;
             digits_read[1]++;
             break;
            case 1:break
            }
          var
           _cZ_=digits_read[1] === pint?1:0,
           _c0_=_cZ_ || (i === bound?1:0),
           _c1_=_c0_?1 - (0 === digits_read[1]?1:0):_c0_;
          if(_c1_)
           {set_digit_nat(nat1,0,int$0[1]);
            var
             erase_len=
              _cY_ === current_len[1]?current_len[1] - 1 | 0:current_len[1],
             _c2_=1;
            if(! (erase_len < 1))
             {var j=_c2_;
              for(;;)
               {set_digit_nat(nat1,j,0);
                var _c4_=j + 1 | 0;
                if(erase_len !== j){var j=_c4_;continue}
                break}}
            mult_digit_nat
             (nat1,
              0,
              possible_len[1],
              nat2,
              0,
              current_len[1],
              power_base,
              digits_read[1] - 1 | 0);
            blit_nat(nat2,0,nat1,0,possible_len[1]);
            current_len[1] = num_digits_nat(nat1,0,possible_len[1]);
            possible_len[1]
            =
            caml_call2(Stdlib[16],_cY_,current_len[1] + 1 | 0);
            int$0[1] = 0;
            digits_read[1] = 0}
          var _c3_=i + 1 | 0;
          if(bound !== i){var i=_c3_;continue}
          break}}
      var nat=create_nat(current_len[1]);
      blit_nat(nat,0,nat1,0,current_len[1]);
      return nat}
    function nat_of_string(s)
     {return sys_nat_of_string(10,s,0,caml_ml_string_length(s))}
    function float_of_nat(nat)
     {return runtime.caml_float_of_string(string_of_nat(nat))}
    var
     Nat=
      [0,
       make_nat,
       copy_nat,
       length_nat,
       is_zero_nat,
       is_nat_int,
       int_of_nat,
       nat_of_int,
       eq_nat,
       le_nat,
       lt_nat,
       ge_nat,
       gt_nat,
       gcd_nat,
       sqrt_nat,
       string_of_nat,
       nat_of_string,
       sys_nat_of_string,
       float_of_nat,
       make_power_base,
       power_base_int,
       _a_];
    caml_register_global(127,Nat,"Nat");
    function sign_big_int(bi){return bi[1]}
    var zero_big_int=[0,0,make_nat(1)],unit_big_int=[0,1,nat_of_int(1)];
    function num_digits_big_int(bi)
     {var _cX_=length_nat(bi[2]);return num_digits_nat(bi[2],0,_cX_)}
    function num_bits_big_int(bi)
     {var
       _cW_=length_nat(bi[2]),
       nd=num_digits_nat(bi[2],0,_cW_),
       lz=num_leading_zero_bits_in_digit(bi[2],nd - 1 | 0);
      return caml_mul(nd,_a_) - lz | 0}
    function minus_big_int(bi)
     {var _cU_=num_digits_big_int(bi),_cV_=copy_nat(bi[2],0,_cU_);
      return [0,- bi[1] | 0,_cV_]}
    function abs_big_int(bi)
     {var
       _cR_=num_digits_big_int(bi),
       _cS_=copy_nat(bi[2],0,_cR_),
       _cT_=0 === bi[1]?0:1;
      return [0,_cT_,_cS_]}
    function compare_big_int(bi1,bi2)
     {if(0 === bi1[1] && 0 === bi2[1])return 0;
      if(bi1[1] < bi2[1])return -1;
      if(bi2[1] < bi1[1])return 1;
      if(1 === bi1[1])
       {var
         _cL_=num_digits_big_int(bi2),
         _cM_=bi2[2],
         _cN_=num_digits_big_int(bi1);
        return compare_nat(bi1[2],0,_cN_,_cM_,0,_cL_)}
      var
       _cO_=num_digits_big_int(bi1),
       _cP_=bi1[2],
       _cQ_=num_digits_big_int(bi2);
      return compare_nat(bi2[2],0,_cQ_,_cP_,0,_cO_)}
    function eq_big_int(bi1,bi2){return 0 === compare_big_int(bi1,bi2)?1:0}
    function le_big_int(bi1,bi2){return compare_big_int(bi1,bi2) <= 0?1:0}
    function ge_big_int(bi1,bi2){return 0 <= compare_big_int(bi1,bi2)?1:0}
    function lt_big_int(bi1,bi2){return compare_big_int(bi1,bi2) < 0?1:0}
    function gt_big_int(bi1,bi2){return 0 < compare_big_int(bi1,bi2)?1:0}
    function max_big_int(bi1,bi2){return lt_big_int(bi1,bi2)?bi2:bi1}
    function min_big_int(bi1,bi2){return gt_big_int(bi1,bi2)?bi2:bi1}
    function pred_big_int(bi)
     {var _cJ_=bi[1];
      if(0 === _cJ_)return [0,-1,nat_of_int(1)];
      if(1 === _cJ_)
       {var size_bi=num_digits_big_int(bi),copy_bi=copy_nat(bi[2],0,size_bi);
        decr_nat(copy_bi,0,size_bi,0);
        var _cK_=is_zero_nat(copy_bi,0,size_bi)?0:1;
        return [0,_cK_,copy_bi]}
      var
       size_bi$0=num_digits_big_int(bi),
       size_res=size_bi$0 + 1 | 0,
       copy_bi$0=create_nat(size_res);
      blit_nat(copy_bi$0,0,bi[2],0,size_bi$0);
      set_digit_nat(copy_bi$0,size_bi$0,0);
      incr_nat(copy_bi$0,0,size_res,1);
      return [0,-1,copy_bi$0]}
    function succ_big_int(bi)
     {var _cH_=bi[1];
      if(-1 === _cH_)
       {var size_bi=num_digits_big_int(bi),copy_bi=copy_nat(bi[2],0,size_bi);
        decr_nat(copy_bi,0,size_bi,0);
        var _cI_=is_zero_nat(copy_bi,0,size_bi)?0:-1;
        return [0,_cI_,copy_bi]}
      if(0 === _cH_)return [0,1,nat_of_int(1)];
      var
       size_bi$0=num_digits_big_int(bi),
       size_res=size_bi$0 + 1 | 0,
       copy_bi$0=create_nat(size_res);
      blit_nat(copy_bi$0,0,bi[2],0,size_bi$0);
      set_digit_nat(copy_bi$0,size_bi$0,0);
      incr_nat(copy_bi$0,0,size_res,1);
      return [0,1,copy_bi$0]}
    function add_big_int(bi1,bi2)
     {var size_bi1=num_digits_big_int(bi1),size_bi2=num_digits_big_int(bi2);
      if(bi1[1] === bi2[1])
       {var match=compare_nat(bi1[2],0,size_bi1,bi2[2],0,size_bi2);
        if(-1 === match)
         {var res=create_nat(size_bi2 + 1 | 0);
          blit_nat(res,0,bi2[2],0,size_bi2);
          set_digit_nat(res,size_bi2,0);
          add_nat(res,0,size_bi2 + 1 | 0,bi1[2],0,size_bi1,0);
          var res$0=res}
        else
         {var res$1=create_nat(size_bi1 + 1 | 0);
          blit_nat(res$1,0,bi1[2],0,size_bi1);
          set_digit_nat(res$1,size_bi1,0);
          add_nat(res$1,0,size_bi1 + 1 | 0,bi2[2],0,size_bi2,0);
          var res$0=res$1}
        return [0,bi1[1],res$0]}
      var match$0=compare_nat(bi1[2],0,size_bi1,bi2[2],0,size_bi2);
      if(0 === match$0)return zero_big_int;
      if(1 === match$0)
       {var res$2=copy_nat(bi1[2],0,size_bi1);
        sub_nat(res$2,0,size_bi1,bi2[2],0,size_bi2,1);
        return [0,bi1[1],res$2]}
      var res$3=copy_nat(bi2[2],0,size_bi2);
      sub_nat(res$3,0,size_bi2,bi1[2],0,size_bi1,1);
      return [0,bi2[1],res$3]}
    function big_int_of_int(i)
     {var res=create_nat(1);
      if(i === monster_int)
       {set_digit_nat(res,0,biggest_int);incr_nat(res,0,1,1)}
      else
       set_digit_nat(res,0,caml_call1(Stdlib[18],i));
      return [0,sign_int(i),res]}
    function add_int_big_int(i,bi){return add_big_int(big_int_of_int(i),bi)}
    function sub_big_int(bi1,bi2){return add_big_int(bi1,minus_big_int(bi2))}
    function mult_int_big_int(i,bi)
     {var size_bi=num_digits_big_int(bi),size_res=size_bi + 1 | 0;
      if(i === monster_int)
       {var res=create_nat(size_res);
        blit_nat(res,0,bi[2],0,size_bi);
        set_digit_nat(res,size_bi,0);
        var _cE_=nat_of_int(biggest_int);
        mult_digit_nat(res,0,size_res,bi[2],0,size_bi,_cE_,0);
        return [0,- bi[1] | 0,res]}
      var res$0=make_nat(size_res),_cF_=nat_of_int(caml_call1(Stdlib[18],i));
      mult_digit_nat(res$0,0,size_res,bi[2],0,size_bi,_cF_,0);
      var _cG_=bi[1];
      return [0,caml_mul(sign_int(i),_cG_),res$0]}
    function mult_big_int(bi1,bi2)
     {var
       size_bi1=num_digits_big_int(bi1),
       size_bi2=num_digits_big_int(bi2),
       size_res=size_bi1 + size_bi2 | 0,
       res=make_nat(size_res);
      if(size_bi1 < size_bi2)
       mult_nat(res,0,size_res,bi2[2],0,size_bi2,bi1[2],0,size_bi1);
      else
       mult_nat(res,0,size_res,bi1[2],0,size_bi1,bi2[2],0,size_bi2);
      return [0,caml_mul(bi1[1],bi2[1]),res]}
    function quomod_big_int(bi1,bi2)
     {if(0 === bi2[1])throw Stdlib[13];
      var
       size_bi1=num_digits_big_int(bi1),
       size_bi2=num_digits_big_int(bi2),
       match=compare_nat(bi1[2],0,size_bi1,bi2[2],0,size_bi2);
      if(-1 === match)
       {if(0 <= bi1[1])return [0,big_int_of_int(0),bi1];
        if(0 <= bi2[1])
         {var _cx_=add_big_int(bi2,bi1);return [0,big_int_of_int(-1),_cx_]}
        var _cy_=sub_big_int(bi1,bi2);
        return [0,big_int_of_int(1),_cy_]}
      if(0 === match)
       return [0,big_int_of_int(caml_mul(bi1[1],bi2[1])),zero_big_int];
      var
       bi1_negatif=-1 === bi1[1]?1:0,
       _cz_=
        bi1_negatif
         ?caml_call2(Stdlib[17],(size_bi1 - size_bi2 | 0) + 1 | 0,1) + 1 | 0
         :caml_call2(Stdlib[17],(size_bi1 - size_bi2 | 0) + 1 | 0,1),
       size_r=caml_call2(Stdlib[17],size_bi1,size_bi2) + 1 | 0,
       q=create_nat(_cz_),
       r=create_nat(size_r);
      blit_nat(r,0,bi1[2],0,size_bi1);
      set_to_zero_nat(r,size_bi1,size_r - size_bi1 | 0);
      div_nat(r,0,size_r,bi2[2],0,size_bi2);
      blit_nat(q,0,r,size_bi2,size_r - size_bi2 | 0);
      var not_null_mod=1 - is_zero_nat(r,0,size_bi2);
      if(bi1_negatif && not_null_mod)
       {var new_r=copy_nat(bi2[2],0,size_bi2);
        sub_nat(new_r,0,size_bi2,r,0,size_bi2,1);
        set_digit_nat(q,_cz_ - 1 | 0,0);
        incr_nat(q,0,_cz_,1);
        return [0,[0,- bi2[1] | 0,q],[0,1,new_r]]}
      if(bi1_negatif)set_digit_nat(q,_cz_ - 1 | 0,0);
      var
       _cA_=copy_nat(r,0,size_bi2),
       _cB_=not_null_mod?1:0,
       _cC_=[0,_cB_,_cA_],
       _cD_=is_zero_nat(q,0,_cz_)?0:caml_mul(bi1[1],bi2[1]);
      return [0,[0,_cD_,q],_cC_]}
    function div_big_int(bi1,bi2){return quomod_big_int(bi1,bi2)[1]}
    function mod_big_int(bi1,bi2){return quomod_big_int(bi1,bi2)[2]}
    function gcd_big_int(bi1,bi2)
     {var size_bi1=num_digits_big_int(bi1),size_bi2=num_digits_big_int(bi2);
      if(is_zero_nat(bi1[2],0,size_bi1))return abs_big_int(bi2);
      if(is_zero_nat(bi2[2],0,size_bi2))return [0,1,bi1[2]];
      var match=compare_nat(bi1[2],0,size_bi1,bi2[2],0,size_bi2);
      if(0 === match)
       var _cw_=bi1[2];
      else
       if(1 === match)
        var
         res=copy_nat(bi1[2],0,size_bi1),
         len=gcd_nat(res,0,size_bi1,bi2[2],0,size_bi2),
         _cw_=copy_nat(res,0,len);
       else
        var
         res$0=copy_nat(bi2[2],0,size_bi2),
         len$0=gcd_nat(res$0,0,size_bi2,bi1[2],0,size_bi1),
         _cw_=copy_nat(res$0,0,len$0);
      return [0,1,_cw_]}
    var
     monster_big_int=big_int_of_int(monster_int),
     monster_nat=monster_big_int[2];
    function is_int_big_int(bi)
     {var _cu_=1 === num_digits_big_int(bi)?1:0;
      if(_cu_)
       {var match=compare_nat(bi[2],0,1,monster_nat,0,1);
        if(-1 !== match)return 0 === match?-1 === bi[1]?1:0:0;
        var _cv_=1}
      else
       var _cv_=_cu_;
      return _cv_}
    function int_of_big_int(bi)
     {try
       {var n=int_of_nat(bi[2]),_cs_=-1 === bi[1]?- n | 0:n;return _cs_}
      catch(_ct_)
       {_ct_ = caml_wrap_exception(_ct_);
        if(_ct_[1] === Stdlib[7])
         return eq_big_int(bi,monster_big_int)
                 ?monster_int
                 :caml_call1(Stdlib[2],cst_int_of_big_int);
        throw _ct_}}
    function int_of_big_int_opt(bi)
     {try
       {var _cq_=[0,int_of_big_int(bi)];return _cq_}
      catch(_cr_)
       {_cr_ = caml_wrap_exception(_cr_);
        if(_cr_[1] === Stdlib[7])return 0;
        throw _cr_}}
    function big_int_of_nativeint(i)
     {if(caml_equal(i,0))return zero_big_int;
      if(caml_greaterthan(i,0))
       {var res=create_nat(1);set_digit_nat_native(res,0,i);return [0,1,res]}
      var res$0=create_nat(1);
      set_digit_nat_native(res$0,0,- i | 0);
      return [0,-1,res$0]}
    function nativeint_of_big_int(bi)
     {if(1 < num_digits_big_int(bi))
       caml_call1(Stdlib[2],cst_nativeint_of_big_int);
      var i=nth_digit_nat_native(bi[2],0);
      if(0 <= bi[1])
       return caml_greaterequal(i,0)
               ?i
               :caml_call1(Stdlib[2],cst_nativeint_of_big_int$0);
      if(! caml_greaterequal(i,0) && ! caml_equal(i,Stdlib_nativeint[11]))
       return caml_call1(Stdlib[2],cst_nativeint_of_big_int$1);
      return - i | 0}
    function nativeint_of_big_int_opt(bi)
     {try
       {var _co_=[0,nativeint_of_big_int(bi)];return _co_}
      catch(_cp_)
       {_cp_ = caml_wrap_exception(_cp_);
        if(_cp_[1] === Stdlib[7])return 0;
        throw _cp_}}
    function big_int_of_int32(i){return big_int_of_nativeint(i)}
    function int32_of_big_int(bi)
     {var i=nativeint_of_big_int(bi);
      if
       (runtime.caml_lessequal(i,2147483647)
        &&
        caml_greaterequal(i,-2147483648))
       return i;
      return caml_call1(Stdlib[2],cst_int32_of_big_int)}
    function int32_of_big_int_opt(bi)
     {try
       {var _cm_=[0,int32_of_big_int(bi)];return _cm_}
      catch(_cn_)
       {_cn_ = caml_wrap_exception(_cn_);
        if(_cn_[1] === Stdlib[7])return 0;
        throw _cn_}}
    function big_int_of_int64(i)
     {if(64 === Stdlib_sys[9])
       return big_int_of_nativeint(caml_int64_to_int32(i));
      if(caml_equal(i,_d_))
       var absi=_e_,sg=0;
      else
       if(caml_greaterthan(i,_f_))
        var absi=i,sg=1;
       else
        var absi$0=caml_int64_neg(i),absi=absi$0,sg=-1;
      var res=create_nat(2);
      set_digit_nat_native(res,0,caml_int64_to_int32(absi));
      set_digit_nat_native
       (res,1,caml_int64_to_int32(runtime.caml_int64_shift_right(absi,32)));
      return [0,sg,res]}
    function int64_of_big_int(bi)
     {if(64 === Stdlib_sys[9])
       return caml_int64_of_int32(nativeint_of_big_int(bi));
      var match=num_digits_big_int(bi);
      if(1 === match)
       var
        i=
         caml_int64_and
          (caml_int64_of_int32(nth_digit_nat_native(bi[2],0)),_g_);
      else
       if(2 === match)
        var
         _cl_=
          runtime.caml_int64_shift_left
           (caml_int64_of_int32(nth_digit_nat_native(bi[2],1)),32),
         i=
          caml_int64_or
           (caml_int64_and
             (caml_int64_of_int32(nth_digit_nat_native(bi[2],0)),_j_),
            _cl_);
       else
        var i=caml_call1(Stdlib[2],cst_int64_of_big_int$1);
      if(0 <= bi[1])
       return caml_greaterequal(i,_h_)
               ?i
               :caml_call1(Stdlib[2],cst_int64_of_big_int);
      if(! caml_greaterequal(i,_i_) && ! caml_equal(i,Stdlib_int64[10]))
       return caml_call1(Stdlib[2],cst_int64_of_big_int$0);
      return caml_int64_neg(i)}
    function int64_of_big_int_opt(bi)
     {try
       {var _cj_=[0,int64_of_big_int(bi)];return _cj_}
      catch(_ck_)
       {_ck_ = caml_wrap_exception(_ck_);
        if(_ck_[1] === Stdlib[7])return 0;
        throw _ck_}}
    function nat_of_big_int(bi)
     {if(-1 === bi[1])return caml_call1(Stdlib[2],cst_nat_of_big_int);
      var _ci_=num_digits_big_int(bi);
      return copy_nat(bi[2],0,_ci_)}
    function sys_big_int_of_nat(nat,off,len)
     {var
       length=num_digits_nat(nat,off,len),
       _cg_=copy_nat(nat,off,length),
       _ch_=is_zero_nat(nat,off,length)?0:1;
      return [0,_ch_,_cg_]}
    function big_int_of_nat(nat)
     {return sys_big_int_of_nat(nat,0,length_nat(nat))}
    function string_of_big_int(bi)
     {if(-1 === bi[1])
       {var _cf_=string_of_nat(bi[2]);return caml_call2(Stdlib[28],cst,_cf_)}
      return string_of_nat(bi[2])}
    function sys_big_int_of_string_aux(s,ofs,len,sgn,base)
     {if(len < 1)caml_call1(Stdlib[2],cst_sys_big_int_of_string);
      var n=sys_nat_of_string(base,s,ofs,len);
      return is_zero_nat(n,0,length_nat(n))?zero_big_int:[0,sgn,n]}
    function sys_big_int_of_string_base(s,ofs,len,sgn)
     {if(len < 1)caml_call1(Stdlib[2],cst_sys_big_int_of_string$0);
      if(2 <= len)
       {var
         match=caml_string_get(s,ofs),
         match$0=caml_string_get(s,ofs + 1 | 0);
        if(48 === match)
         {var switch$0=0;
          if(89 <= match$0)
           {if(98 === match$0)
             switch$0 = 3;
            else
             if(111 === match$0)
              switch$0 = 2;
             else
              if(120 === match$0)switch$0 = 1}
          else
           if(66 === match$0)
            switch$0 = 3;
           else
            if(79 === match$0)switch$0 = 2;else if(88 <= match$0)switch$0 = 1;
          switch(switch$0)
           {case 0:break;
            case 1:
             return sys_big_int_of_string_aux
                     (s,ofs + 2 | 0,len - 2 | 0,sgn,16);
            case 2:
             return sys_big_int_of_string_aux(s,ofs + 2 | 0,len - 2 | 0,sgn,8);
            default:
             return sys_big_int_of_string_aux(s,ofs + 2 | 0,len - 2 | 0,sgn,2)}}
        return sys_big_int_of_string_aux(s,ofs,len,sgn,10)}
      return sys_big_int_of_string_aux(s,ofs,len,sgn,10)}
    function sys_big_int_of_string(s,ofs,len)
     {if(len < 1)caml_call1(Stdlib[2],cst_sys_big_int_of_string$1);
      var match=caml_string_get(s,ofs),switcher=match - 43 | 0;
      if(! (2 < switcher >>> 0))
       switch(switcher)
        {case 0:
          return sys_big_int_of_string_base(s,ofs + 1 | 0,len - 1 | 0,1);
         case 1:break;
         default:
          return sys_big_int_of_string_base(s,ofs + 1 | 0,len - 1 | 0,-1)}
      return sys_big_int_of_string_base(s,ofs,len,1)}
    function big_int_of_string(s)
     {return sys_big_int_of_string(s,0,caml_ml_string_length(s))}
    function big_int_of_string_opt(s)
     {try
       {var _cd_=[0,big_int_of_string(s)];return _cd_}
      catch(_ce_)
       {_ce_ = caml_wrap_exception(_ce_);
        if(_ce_[1] === Stdlib[7])return 0;
        throw _ce_}}
    function power_int_positive_int(i,n)
     {var match=sign_int(n);
      if(-1 === match)return caml_call1(Stdlib[1],cst_power_int_positive_int);
      if(0 === match)return unit_big_int;
      var
       nat=power_base_int(caml_call1(Stdlib[18],i),n),
       _cc_=0 <= i?sign_int(i):0 === (n & 1)?1:-1;
      return [0,_cc_,nat]}
    function power_big_int_positive_int(bi,n)
     {var match=sign_int(n);
      if(-1 === match)
       return caml_call1(Stdlib[1],cst_power_big_int_positive_int);
      if(0 === match)return unit_big_int;
      var
       bi_len=num_digits_big_int(bi),
       res_len=caml_mul(bi_len,n),
       res=make_nat(res_len),
       res2=make_nat(res_len),
       l=num_bits_int(n) - 2 | 0;
      blit_nat(res,0,bi[2],0,bi_len);
      if(! (l < 0))
       {var i=l;
        for(;;)
         {var
           len=num_digits_nat(res,0,res_len),
           len2=caml_call2(Stdlib[16],res_len,2 * len | 0);
          set_to_zero_nat(res2,0,len2);
          square_nat(res2,0,len2,res,0,len);
          if(0 < (n & 1 << i))
           {var lenp=caml_call2(Stdlib[16],res_len,len2 + bi_len | 0);
            set_to_zero_nat(res,0,lenp);
            mult_nat(res,0,lenp,res2,0,len2,bi[2],0,bi_len)}
          else
           blit_nat(res,0,res2,0,len2);
          var _cb_=i - 1 | 0;
          if(0 !== i){var i=_cb_;continue}
          break}}
      var _ca_=0 <= bi[1]?bi[1]:0 === (n & 1)?1:-1;
      return [0,_ca_,res]}
    function power_int_positive_big_int(i$0,bi)
     {var match$1=bi[1];
      if(-1 === match$1)
       return caml_call1(Stdlib[1],cst_power_int_positive_big_int);
      if(0 === match$1)return unit_big_int;
      var
       len$0=num_digits_big_int(bi),
       _b__=bi[2],
       base=caml_call1(Stdlib[18],i$0),
       off=0;
      if(0 === base)
       var nat=nat_of_int(0);
      else
       {var switch$0=0;
        if(is_zero_nat(_b__,off,len$0) || 1 === base)
         switch$0 = 1;
        else
         {var
           power_base=make_nat(_a_ + 1 | 0),
           match=make_power_base(base,power_base),
           pmax=match[1],
           _b8_=big_int_of_int(pmax + 1 | 0),
           match$0=quomod_big_int(sys_big_int_of_nat(_b__,off,len$0),_b8_),
           y=match$0[2],
           x=match$0[1],
           rem=int_of_big_int(y),
           n=int_of_big_int(x);
          if(0 === n)
           var nat=copy_nat(power_base,rem - 1 | 0,1);
          else
           {var
             res=make_nat(n),
             res2=make_nat(n + 1 | 0),
             l=num_bits_int(n) - 2 | 0;
            blit_nat(res,0,power_base,pmax,1);
            if(! (l < 0))
             {var i=l;
              for(;;)
               {var
                 len=num_digits_nat(res,0,n),
                 len2=caml_call2(Stdlib[16],n,2 * len | 0),
                 succ_len2=len2 + 1 | 0;
                square_nat(res2,0,len2,res,0,len);
                if(0 < (n & 1 << i))
                 {set_to_zero_nat(res,0,len);
                  mult_digit_nat(res,0,succ_len2,res2,0,len2,power_base,pmax)}
                else
                 blit_nat(res,0,res2,0,len2);
                set_to_zero_nat(res2,0,len2);
                var _b9_=i - 1 | 0;
                if(0 !== i){var i=_b9_;continue}
                break}}
            var
             nat=
              0 < rem
               ?(mult_digit_nat
                  (res2,0,n + 1 | 0,res,0,n,power_base,rem - 1 | 0),
                 res2)
               :res}}
        if(switch$0)var nat=nat_of_int(1)}
      var _b$_=0 <= i$0?sign_int(i$0):runtime.is_digit_odd(bi[2],0)?-1:1;
      return [0,_b$_,nat]}
    function power_big_int_positive_big_int(bi1,bi2)
     {var match=bi2[1];
      if(-1 === match)
       return caml_call1(Stdlib[1],cst_power_big_int_positive_big);
      if(0 === match)return unit_big_int;
      try
       {var _b5_=power_big_int_positive_int(bi1,int_of_big_int(bi2));
        return _b5_}
      catch(_b6_)
       {_b6_ = caml_wrap_exception(_b6_);
        if(_b6_[1] === Stdlib[7])
         try
          {var _b4_=power_int_positive_big_int(int_of_big_int(bi1),bi2);
           return _b4_}
         catch(_b7_)
          {_b7_ = caml_wrap_exception(_b7_);
           if(_b7_[1] === Stdlib[7])throw Stdlib[9];
           throw _b7_}
        throw _b6_}}
    function base_power_big_int(base,n,bi)
     {var match=sign_int(n);
      if(-1 === match)
       {var
         nat=power_base_int(base,- n | 0),
         len_nat=num_digits_nat(nat,0,length_nat(nat)),
         len_bi=num_digits_big_int(bi);
        if(len_bi < len_nat)
         return caml_call1(Stdlib[1],cst_base_power_big_int);
        if
         (len_bi
          ===
          len_nat
          &&
          -1
          ===
          runtime.compare_digits_nat(bi[2],len_bi,nat,len_nat))
         return caml_call1(Stdlib[1],cst_base_power_big_int$0);
        var copy=create_nat(len_bi + 1 | 0);
        blit_nat(copy,0,bi[2],0,len_bi);
        set_digit_nat(copy,len_bi,0);
        div_nat(copy,0,len_bi + 1 | 0,nat,0,len_nat);
        if(is_zero_nat(copy,0,len_nat))
         {var _b2_=copy_nat(copy,len_nat,1);return [0,bi[1],_b2_]}
        return caml_call1(Stdlib[1],cst_base_power_big_int$1)}
      if(0 === match)return bi;
      var
       nat$0=power_base_int(base,n),
       len_nat$0=num_digits_nat(nat$0,0,length_nat(nat$0)),
       len_bi$0=num_digits_big_int(bi),
       new_len=len_bi$0 + len_nat$0 | 0,
       nat$1=make_nat(new_len);
      if(len_nat$0 < len_bi$0)
       mult_nat(nat$1,0,new_len,bi[2],0,len_bi$0,nat$0,0,len_nat$0);
      else
       mult_nat(nat$1,0,new_len,nat$0,0,len_nat$0,bi[2],0,len_bi$0);
      if(is_zero_nat(nat$1,0,new_len))return zero_big_int;
      var _b3_=bi[1];
      if(1 !== _b3_ && -1 !== _b3_)
       {var switch$0=0;
        if
         (0
          !==
          _b3_
          ||
          !
          is_zero_nat(nat$1,0,num_digits_nat(nat$1,0,length_nat(nat$1))))
         switch$0 = 1;
        if(switch$0)return caml_call1(Stdlib[1],cst_create_big_int)}
      return [0,_b3_,nat$1]}
    function sqrt_big_int(bi)
     {var _b0_=bi[1];
      if(-1 === _b0_)return caml_call1(Stdlib[1],cst_sqrt_big_int);
      if(0 === _b0_)return zero_big_int;
      var _b1_=num_digits_big_int(bi);
      return [0,1,sqrt_nat(bi[2],0,_b1_)]}
    function square_big_int(bi)
     {if(0 === bi[1])return zero_big_int;
      var
       len_bi=num_digits_big_int(bi),
       len_res=2 * len_bi | 0,
       res=make_nat(len_res);
      square_nat(res,0,len_res,bi[2],0,len_bi);
      return [0,1,res]}
    function round_futur_last_digit(s,off_set,length)
     {var l=(length + off_set | 0) - 1 | 0;
      if(53 <= caml_bytes_get(s,l))
       {var l$2=l - 1 | 0,l$0=l$2;
        for(;;)
         {if(l$0 < off_set)return 1;
          var current_char=caml_bytes_get(s,l$0);
          if(57 === current_char)
           {caml_bytes_set(s,l$0,48);var l$1=l$0 - 1 | 0,l$0=l$1;continue}
          caml_bytes_set
           (s,l$0,caml_call1(Stdlib_char[1],current_char + 1 | 0));
          return 0}}
      return 0}
    function approx_big_int(prec,bi)
     {var
       len_bi=num_digits_big_int(bi),
       _bK_=big_int_of_string(cst_100000000),
       _bL_=big_int_of_string(cst_963295986),
       _bM_=
        int_of_big_int
         (add_int_big_int
           (- prec | 0,
            div_big_int
             (mult_big_int(big_int_of_int(len_bi - 1 | 0),_bL_),_bK_))),
       n=caml_call2(Stdlib[17],0,_bM_),
       _bN_=string_of_big_int(div_big_int(bi,power_int_positive_int(10,n))),
       s=caml_call1(Stdlib_bytes[5],_bN_);
      if(45 === caml_bytes_get(s,0))
       var off=1,sign$0=cst$0;
      else
       var off=0,sign$0=sign;
      if(round_futur_last_digit(s,off,prec + 1 | 0))
       {var
         _bO_=
          caml_call1
           (Stdlib[33],((n + 1 | 0) - off | 0) + caml_ml_bytes_length(s) | 0),
         _bP_=caml_call2(Stdlib[28],cst_e,_bO_),
         _bQ_=caml_call2(Stdlib_string[1],prec,48),
         _bR_=caml_call2(Stdlib[28],_bQ_,_bP_),
         _bS_=caml_call2(Stdlib[28],cst_1,_bR_);
        return caml_call2(Stdlib[28],sign$0,_bS_)}
      var
       _bT_=
        caml_call1
         (Stdlib[33],(n - (off + 1 | 0) | 0) + caml_ml_bytes_length(s) | 0),
       _bU_=caml_call2(Stdlib[28],cst_e$0,_bT_),
       _bV_=caml_call3(Stdlib_bytes[8],s,off + 1 | 0,prec - 1 | 0),
       _bW_=caml_call2(Stdlib[28],_bV_,_bU_),
       _bX_=caml_call2(Stdlib[28],cst$1,_bW_),
       _bY_=caml_call3(Stdlib_bytes[8],s,off,1),
       _bZ_=caml_call2(Stdlib[28],_bY_,_bX_);
      return caml_call2(Stdlib[28],sign$0,_bZ_)}
    function shift_left_big_int(bi,n)
     {if(0 <= n)
       {if(0 === n)return bi;
        if(0 === bi[1])return bi;
        var
         size_bi=num_digits_big_int(bi),
         size_res=size_bi + caml_div((n + _a_ | 0) - 1 | 0,_a_) | 0,
         res=create_nat(size_res),
         ndigits=caml_div(n,_a_);
        set_to_zero_nat(res,0,ndigits);
        blit_nat(res,ndigits,bi[2],0,size_bi);
        var nbits=caml_mod(n,_a_);
        if(0 < nbits)
         runtime.shift_left_nat
          (res,ndigits,size_bi,res,ndigits + size_bi | 0,nbits);
        return [0,bi[1],res]}
      return caml_call1(Stdlib[1],cst_shift_left_big_int)}
    function shift_right_towards_zero_big_i(bi,n)
     {if(0 <= n)
       {if(0 === n)return bi;
        if(0 === bi[1])return bi;
        var
         size_bi=num_digits_big_int(bi),
         ndigits=caml_div(n,_a_),
         nbits=caml_mod(n,_a_);
        if(size_bi <= ndigits)return zero_big_int;
        var size_res=size_bi - ndigits | 0,res=create_nat(size_res);
        blit_nat(res,0,bi[2],ndigits,size_res);
        if(0 < nbits)
         {var tmp=create_nat(1);shift_right_nat(res,0,size_res,tmp,0,nbits)}
        return is_zero_nat(res,0,size_res)?zero_big_int:[0,bi[1],res]}
      return caml_call1(Stdlib[1],cst_shift_right_towards_zero_b)}
    function shift_right_big_int(bi,n)
     {if(0 <= n)
       {if(0 <= bi[1])return shift_right_towards_zero_big_i(bi,n);
        if(0 <= n)
         if(0 === n)
          var _bJ_=zero_big_int;
         else
          {var
            idx=caml_div(n,_a_),
            size_res=idx + 1 | 0,
            res=make_nat(size_res);
           set_digit_nat_native(res,idx,1 << caml_mod(n,_a_));
           decr_nat(res,0,size_res,0);
           var _bJ_=[0,1,res]}
        else
         var _bJ_=caml_call1(Stdlib[1],cst_two_power_m1_big_int);
        return shift_right_towards_zero_big_i(sub_big_int(bi,_bJ_),n)}
      return caml_call1(Stdlib[1],cst_shift_right_big_int)}
    function extract_big_int(bi,ofs,n)
     {if(0 <= ofs && 0 <= n)
       {if(0 === bi[1])return bi;
        var
         size_bi=num_digits_big_int(bi),
         size_res=caml_div((n + _a_ | 0) - 1 | 0,_a_),
         ndigits=caml_div(ofs,_a_),
         nbits=caml_mod(ofs,_a_),
         res=make_nat(size_res);
        if(ndigits < size_bi)
         {var _bE_=caml_call2(Stdlib[16],size_res,size_bi - ndigits | 0);
          blit_nat(res,0,bi[2],ndigits,_bE_)}
        if(bi[1] < 0)
         {complement_nat(res,0,size_res);
          var i=0;
          for(;;)
           {var _bF_=ndigits <= i?1:0;
            if(_bF_)
             var _bG_=_bF_;
            else
             {var _bH_=size_bi <= i?1:0;
              if(_bH_)
               var _bG_=_bH_;
              else
               {var _bI_=is_digit_zero(bi[2],i);
                if(_bI_){var i$0=i + 1 | 0,i=i$0;continue}
                var _bG_=_bI_}}
            if(_bG_)incr_nat(res,0,size_res,1);
            break}}
        if(0 < nbits)
         {var tmp=create_nat(1);shift_right_nat(res,0,size_res,tmp,0,nbits)}
        var n$0=caml_mod(n,_a_);
        if(0 < n$0)
         {var tmp$0=create_nat(1);
          set_digit_nat_native(tmp$0,0,-1 >>> (_a_ - n$0 | 0) | 0);
          land_digit_nat(res,size_res - 1 | 0,tmp$0,0)}
        return is_zero_nat(res,0,size_res)?zero_big_int:[0,1,res]}
      return caml_call1(Stdlib[1],cst_extract_big_int)}
    function and_big_int(a,b)
     {if(0 <= a[1] && 0 <= b[1])
       {if(0 !== a[1] && 0 !== b[1])
         {var
           size_a=num_digits_big_int(a),
           size_b=num_digits_big_int(b),
           size_res=caml_call2(Stdlib[16],size_a,size_b),
           res=create_nat(size_res);
          blit_nat(res,0,a[2],0,size_res);
          var _bC_=size_res - 1 | 0,_bB_=0;
          if(! (_bC_ < 0))
           {var i=_bB_;
            for(;;)
             {land_digit_nat(res,i,b[2],i);
              var _bD_=i + 1 | 0;
              if(_bC_ !== i){var i=_bD_;continue}
              break}}
          return is_zero_nat(res,0,size_res)?zero_big_int:[0,1,res]}
        return zero_big_int}
      return caml_call1(Stdlib[1],cst_and_big_int)}
    function or_big_int(a,b)
     {if(0 <= a[1] && 0 <= b[1])
       {if(0 === a[1])return b;
        if(0 === b[1])return a;
        var
         size_a=num_digits_big_int(a),
         size_b=num_digits_big_int(b),
         size_res=caml_call2(Stdlib[17],size_a,size_b),
         res=create_nat(size_res),
         or_aux=
          function(a,b,size_b)
           {blit_nat(res,0,a[2],0,size_res);
            var _bz_=size_b - 1 | 0,_by_=0;
            if(! (_bz_ < 0))
             {var i=_by_;
              for(;;)
               {runtime.lor_digit_nat(res,i,b[2],i);
                var _bA_=i + 1 | 0;
                if(_bz_ !== i){var i=_bA_;continue}
                break}}
            return 0};
        if(size_b <= size_a)or_aux(a,b,size_b);else or_aux(b,a,size_a);
        return is_zero_nat(res,0,size_res)?zero_big_int:[0,1,res]}
      return caml_call1(Stdlib[1],cst_or_big_int)}
    function xor_big_int(a,b)
     {if(0 <= a[1] && 0 <= b[1])
       {if(0 === a[1])return b;
        if(0 === b[1])return a;
        var
         size_a=num_digits_big_int(a),
         size_b=num_digits_big_int(b),
         size_res=caml_call2(Stdlib[17],size_a,size_b),
         res=create_nat(size_res),
         xor_aux=
          function(a,b,size_b)
           {blit_nat(res,0,a[2],0,size_res);
            var _bw_=size_b - 1 | 0,_bv_=0;
            if(! (_bw_ < 0))
             {var i=_bv_;
              for(;;)
               {runtime.lxor_digit_nat(res,i,b[2],i);
                var _bx_=i + 1 | 0;
                if(_bw_ !== i){var i=_bx_;continue}
                break}}
            return 0};
        if(size_b <= size_a)xor_aux(a,b,size_b);else xor_aux(b,a,size_a);
        return is_zero_nat(res,0,size_res)?zero_big_int:[0,1,res]}
      return caml_call1(Stdlib[1],cst_xor_big_int)}
    function round_big_int_to_float(x,exact)
     {var n=num_bits_big_int(x),_bt_=55 <= n?1:0,_bu_=_bt_?n <= 63?1:0:_bt_;
      if(_bu_)
       {var m=int64_of_big_int(x),m$0=exact?m:caml_int64_or(m,_k_);
        return caml_int64_to_float(m$0)}
      throw [0,Assert_failure,_l_]}
    function float_of_big_int(x)
     {var n=num_bits_big_int(x);
      if(63 < n)
       {var
         n$0=n - 55 | 0,
         top=shift_right_big_int(x,n$0),
         exact=eq_big_int(x,shift_left_big_int(top,n$0));
        return caml_ldexp_float(round_big_int_to_float(top,exact),n$0)}
      return caml_int64_to_float(int64_of_big_int(x))}
    var
     Big_int=
      [0,
       zero_big_int,
       unit_big_int,
       minus_big_int,
       abs_big_int,
       add_big_int,
       succ_big_int,
       add_int_big_int,
       sub_big_int,
       pred_big_int,
       mult_big_int,
       mult_int_big_int,
       square_big_int,
       sqrt_big_int,
       quomod_big_int,
       div_big_int,
       mod_big_int,
       gcd_big_int,
       power_int_positive_int,
       power_big_int_positive_int,
       power_int_positive_big_int,
       power_big_int_positive_big_int,
       sign_big_int,
       compare_big_int,
       eq_big_int,
       le_big_int,
       ge_big_int,
       lt_big_int,
       gt_big_int,
       max_big_int,
       min_big_int,
       num_digits_big_int,
       num_bits_big_int,
       string_of_big_int,
       big_int_of_string,
       big_int_of_string_opt,
       big_int_of_int,
       is_int_big_int,
       int_of_big_int,
       int_of_big_int_opt,
       big_int_of_int32,
       big_int_of_nativeint,
       big_int_of_int64,
       int32_of_big_int,
       int32_of_big_int_opt,
       nativeint_of_big_int,
       nativeint_of_big_int_opt,
       int64_of_big_int,
       int64_of_big_int_opt,
       float_of_big_int,
       and_big_int,
       or_big_int,
       xor_big_int,
       shift_left_big_int,
       shift_right_big_int,
       shift_right_towards_zero_big_i,
       extract_big_int,
       nat_of_big_int,
       big_int_of_nat,
       base_power_big_int,
       sys_big_int_of_string,
       round_futur_last_digit,
       approx_big_int,
       round_big_int_to_float];
    caml_register_global(130,Big_int,"Big_int");
    var
     error_when_null_denominator_fl=[0,1],
     normalize_ratio_flag=[0,0],
     normalize_ratio_when_printing_=[0,1],
     floating_precision=[0,12],
     approx_printing_flag=[0,0],
     Arith_flags=
      [0,
       error_when_null_denominator_fl,
       normalize_ratio_flag,
       normalize_ratio_when_printing_,
       floating_precision,
       approx_printing_flag];
    caml_register_global(131,Arith_flags,"Arith_flags");
    function failwith_zero(name)
     {if(0 === caml_ml_string_length(name))
       var s$0=s;
      else
       var
        _bs_=caml_call2(Stdlib[28],cst$2,s),
        s$0=caml_call2(Stdlib[28],name,_bs_);
      return caml_call1(Stdlib[2],s$0)}
    function numerator_ratio(r){return r[1]}
    function denominator_ratio(r){return r[2]}
    function null_denominator(r){return 0 === r[2][1]?1:0}
    function verify_null_denominator(r)
     {return 0 === r[2][1]
              ?error_when_null_denominator_fl[1]?failwith_zero(cst$3):1
              :0}
    function sign_ratio(r){return r[1][1]}
    function normalize_ratio(r)
     {if(r[3])return r;
      if(verify_null_denominator(r))
       {r[1] = big_int_of_int(r[1][1]);r[3] = 1;return r}
      var p=gcd_big_int(r[1],r[2]);
      return eq_big_int(p,unit_big_int)
              ?(r[3] = 1,r)
              :(r[1]
                =
                div_big_int(r[1],p),
                r[2]
                =
                div_big_int(r[2],p),
                r[3]
                =
                1,
                r)}
    function cautious_normalize_ratio(r)
     {return normalize_ratio_flag[1]?normalize_ratio(r):r}
    function cautious_normalize_ratio_when_(r)
     {return normalize_ratio_when_printing_[1]?normalize_ratio(r):r}
    function create_ratio(bi1,bi2)
     {var match=bi2[1];
      if(-1 === match)
       {var _br_=minus_big_int(bi2);
        return cautious_normalize_ratio([0,minus_big_int(bi1),_br_,0])}
      return 0 === match
              ?error_when_null_denominator_fl[1]
                ?failwith_zero(cst_create_ratio)
                :cautious_normalize_ratio([0,bi1,bi2,0])
              :cautious_normalize_ratio([0,bi1,bi2,0])}
    function create_normalized_ratio(bi1,bi2)
     {var match=bi2[1];
      if(-1 === match)
       {var _bq_=minus_big_int(bi2);return [0,minus_big_int(bi1),_bq_,1]}
      return 0 === match
              ?error_when_null_denominator_fl[1]
                ?failwith_zero(cst_create_normalized_ratio)
                :[0,bi1,bi2,1]
              :[0,bi1,bi2,1]}
    function is_normalized_ratio(r){return r[3]}
    function report_sign_ratio(r,bi)
     {return -1 === sign_ratio(r)?minus_big_int(bi):bi}
    function abs_ratio(r)
     {var _bo_=r[3],_bp_=r[2];return [0,abs_big_int(r[1]),_bp_,_bo_]}
    function is_integer_ratio(r)
     {return eq_big_int(normalize_ratio(r)[2],unit_big_int)}
    function add_ratio(r1,r2)
     {if(normalize_ratio_flag[1])
       {var
         _bh_=normalize_ratio(r2)[2],
         p=gcd_big_int(normalize_ratio(r1)[2],_bh_);
        if(eq_big_int(p,unit_big_int))
         {var _bi_=mult_big_int(r1[2],r2[2]),_bj_=mult_big_int(r2[1],r1[2]);
          return [0,add_big_int(mult_big_int(r1[1],r2[2]),_bj_),_bi_,1]}
        var
         d1=div_big_int(r1[2],p),
         d2=div_big_int(r2[2],p),
         _bk_=mult_big_int(d1,r2[1]),
         n=add_big_int(mult_big_int(r1[1],d2),_bk_),
         p$0=gcd_big_int(n,p),
         _bl_=mult_big_int(d1,div_big_int(r2[2],p$0));
        return [0,div_big_int(n,p$0),_bl_,1]}
      var _bm_=mult_big_int(r1[2],r2[2]),_bn_=mult_big_int(r1[2],r2[1]);
      return [0,add_big_int(mult_big_int(r1[1],r2[2]),_bn_),_bm_,0]}
    function minus_ratio(r)
     {var _bf_=r[3],_bg_=r[2];return [0,minus_big_int(r[1]),_bg_,_bf_]}
    function add_int_ratio(i,r)
     {cautious_normalize_ratio(r);
      var _bc_=r[3],_bd_=r[2],_be_=r[1];
      return [0,add_big_int(mult_int_big_int(i,r[2]),_be_),_bd_,_bc_]}
    function add_big_int_ratio(bi,r)
     {cautious_normalize_ratio(r);
      var _a$_=r[3],_ba_=r[2],_bb_=r[1];
      return [0,add_big_int(mult_big_int(bi,r[2]),_bb_),_ba_,_a$_]}
    function sub_ratio(r1,r2){return add_ratio(r1,minus_ratio(r2))}
    function mult_ratio(r1,r2)
     {if(normalize_ratio_flag[1])
       {var
         _a6_=normalize_ratio(r2)[2],
         p1=gcd_big_int(normalize_ratio(r1)[1],_a6_),
         p2=gcd_big_int(r2[1],r1[2]);
        if(eq_big_int(p1,unit_big_int))
         var _a8_=r2[2],_a7_=r1[1];
        else
         var d2=div_big_int(r2[2],p1),_a8_=d2,_a7_=div_big_int(r1[1],p1);
        if(eq_big_int(p2,unit_big_int))
         var d1=r1[2],n2=r2[1];
        else
         var
          d1$0=div_big_int(r1[2],p2),
          n2$0=div_big_int(r2[1],p2),
          d1=d1$0,
          n2=n2$0;
        var _a9_=mult_big_int(d1,_a8_);
        return [0,mult_big_int(_a7_,n2),_a9_,1]}
      var _a__=mult_big_int(r1[2],r2[2]);
      return [0,mult_big_int(r1[1],r2[1]),_a__,0]}
    function mult_int_ratio(i,r)
     {if(normalize_ratio_flag[1])
       {var _a0_=big_int_of_int(i),p=gcd_big_int(normalize_ratio(r)[2],_a0_);
        if(eq_big_int(p,unit_big_int))
         {var _a1_=r[2],_a2_=r[1];
          return [0,mult_big_int(big_int_of_int(i),_a2_),_a1_,1]}
        var _a3_=div_big_int(r[2],p),_a4_=r[1];
        return [0,mult_big_int(div_big_int(big_int_of_int(i),p),_a4_),_a3_,1]}
      var _a5_=r[2];
      return [0,mult_int_big_int(i,r[1]),_a5_,0]}
    function mult_big_int_ratio(bi,r)
     {if(normalize_ratio_flag[1])
       {var p=gcd_big_int(normalize_ratio(r)[2],bi);
        if(eq_big_int(p,unit_big_int))
         {var _aW_=r[2];return [0,mult_big_int(bi,r[1]),_aW_,1]}
        var _aX_=div_big_int(r[2],p),_aY_=r[1];
        return [0,mult_big_int(div_big_int(bi,p),_aY_),_aX_,1]}
      var _aZ_=r[2];
      return [0,mult_big_int(bi,r[1]),_aZ_,0]}
    function square_ratio(r)
     {cautious_normalize_ratio(r);
      var _aU_=r[3],_aV_=square_big_int(r[2]);
      return [0,square_big_int(r[1]),_aV_,_aU_]}
    function inverse_ratio(r)
     {if(error_when_null_denominator_fl[1] && 0 === r[1][1])
       return failwith_zero(cst_inverse_ratio);
      var _aS_=r[3],_aT_=abs_big_int(r[1]);
      return [0,report_sign_ratio(r,r[2]),_aT_,_aS_]}
    function div_ratio(r1,r2){return mult_ratio(r1,inverse_ratio(r2))}
    function integer_ratio(r)
     {if(null_denominator(r))return failwith_zero(cst_integer_ratio);
      if(0 === sign_ratio(r))return zero_big_int;
      var _aR_=abs_big_int(r[2]);
      return report_sign_ratio(r,div_big_int(abs_big_int(r[1]),_aR_))}
    function floor_ratio(r)
     {verify_null_denominator(r);return div_big_int(r[1],r[2])}
    function round_ratio(r)
     {verify_null_denominator(r);
      var
       abs_num=abs_big_int(r[1]),
       bi=div_big_int(abs_num,r[2]),
       _aQ_=r[2],
       bi$0=
        -1
         ===
         sub_big_int
           (mult_int_big_int(2,sub_big_int(abs_num,mult_big_int(r[2],bi))),
            _aQ_)
          [1]
         ?bi
         :succ_big_int(bi);
      return report_sign_ratio(r,bi$0)}
    function ceiling_ratio(r)
     {return is_integer_ratio(r)?r[1]:succ_big_int(floor_ratio(r))}
    function eq_ratio(r1,r2)
     {normalize_ratio(r1);
      normalize_ratio(r2);
      var _aP_=eq_big_int(r1[1],r2[1]);
      return _aP_?eq_big_int(r1[2],r2[2]):_aP_}
    function compare_ratio(r1,r2)
     {if(verify_null_denominator(r1))
       {var sign_num_r1=r1[1][1];
        if(verify_null_denominator(r2))
         {var sign_num_r2=r2[1][1];
          if(1 === sign_num_r1 && -1 === sign_num_r2)return 1;
          if(-1 === sign_num_r1 && 1 === sign_num_r2)return -1;
          return 0}
        return sign_num_r1}
      if(verify_null_denominator(r2))return - r2[1][1] | 0;
      var match=compare_int(r1[1][1],r2[1][1]),switcher=match + 1 | 0;
      if(! (2 < switcher >>> 0))
       switch(switcher){case 0:return -1;case 1:break;default:return 1}
      if(eq_big_int(r1[2],r2[2]))return compare_big_int(r1[1],r2[1]);
      var _aO_=mult_big_int(r1[2],r2[1]);
      return compare_big_int(mult_big_int(r1[1],r2[2]),_aO_)}
    function lt_ratio(r1,r2){return compare_ratio(r1,r2) < 0?1:0}
    function le_ratio(r1,r2){return compare_ratio(r1,r2) <= 0?1:0}
    function gt_ratio(r1,r2){return 0 < compare_ratio(r1,r2)?1:0}
    function ge_ratio(r1,r2){return 0 <= compare_ratio(r1,r2)?1:0}
    function max_ratio(r1,r2){return lt_ratio(r1,r2)?r2:r1}
    function min_ratio(r1,r2){return gt_ratio(r1,r2)?r2:r1}
    function eq_big_int_ratio(bi,r)
     {var _aN_=is_integer_ratio(r);return _aN_?eq_big_int(bi,r[1]):_aN_}
    function compare_big_int_ratio(bi,r)
     {normalize_ratio(r);
      if(verify_null_denominator(r))return - r[1][1] | 0;
      var _aM_=r[1];
      return compare_big_int(mult_big_int(bi,r[2]),_aM_)}
    function lt_big_int_ratio(bi,r)
     {return compare_big_int_ratio(bi,r) < 0?1:0}
    function le_big_int_ratio(bi,r)
     {return compare_big_int_ratio(bi,r) <= 0?1:0}
    function gt_big_int_ratio(bi,r)
     {return 0 < compare_big_int_ratio(bi,r)?1:0}
    function ge_big_int_ratio(bi,r)
     {return 0 <= compare_big_int_ratio(bi,r)?1:0}
    function int_of_ratio(r)
     {if(is_integer_ratio(r) && is_int_big_int(r[1]))
       return int_of_big_int(r[1]);
      return caml_call1(Stdlib[2],cst_integer_argument_required)}
    function ratio_of_int(i){return [0,big_int_of_int(i),unit_big_int,1]}
    function ratio_of_nat(nat){return [0,big_int_of_nat(nat),unit_big_int,1]}
    function nat_of_ratio(r)
     {normalize_ratio(r);
      return is_integer_ratio(r)
              ?-1 < r[1][1]
                ?nat_of_big_int(r[1])
                :caml_call1(Stdlib[2],cst_nat_of_ratio)
              :caml_call1(Stdlib[2],cst_nat_of_ratio$0)}
    function ratio_of_big_int(bi){return [0,bi,unit_big_int,1]}
    function big_int_of_ratio(r)
     {normalize_ratio(r);
      return is_integer_ratio(r)
              ?r[1]
              :caml_call1(Stdlib[2],cst_big_int_of_ratio)}
    function div_int_ratio(i,r)
     {verify_null_denominator(r);return mult_int_ratio(i,inverse_ratio(r))}
    function div_ratio_int(r,i){return div_ratio(r,ratio_of_int(i))}
    function div_big_int_ratio(bi,r)
     {verify_null_denominator(r);
      return mult_big_int_ratio(bi,inverse_ratio(r))}
    function div_ratio_big_int(r,bi){return div_ratio(r,ratio_of_big_int(bi))}
    function approx_ratio_fix(n,r)
     {if(null_denominator(r))return failwith_zero(cst_approx_ratio_fix);
      var sign_r=sign_ratio(r);
      if(0 === sign_r)return cst_0;
      if(0 <= n)
       {var
         _aG_=r[2],
         s1=
          string_of_nat
           (nat_of_big_int
             (div_big_int
               (base_power_big_int(10,n + 1 | 0,abs_big_int(r[1])),_aG_))),
         s1$0=caml_call1(Stdlib_bytes[5],s1);
        if(round_futur_last_digit(s1$0,0,caml_ml_bytes_length(s1$0)))
         var
          _aH_=caml_call1(Stdlib_bytes[5],cst_1$0),
          s2=caml_call2(Stdlib_bytes[14],_aH_,s1$0);
        else
         var s2=s1$0;
        var l2=caml_ml_bytes_length(s2) - 1 | 0;
        if(n < l2)
         {var
           s=caml_call2(Stdlib_bytes[1],l2 + 2 | 0,48),
           _aI_=-1 === sign_r?45:43;
          caml_bytes_set(s,0,_aI_);
          caml_call5(Stdlib_bytes[11],s2,0,s,1,l2 - n | 0);
          caml_bytes_set(s,(l2 - n | 0) + 1 | 0,46);
          caml_call5(Stdlib_bytes[11],s2,l2 - n | 0,s,(l2 - n | 0) + 2 | 0,n);
          return caml_call1(Stdlib_bytes[42],s)}
        var
         s$0=caml_call2(Stdlib_bytes[1],n + 3 | 0,48),
         _aJ_=-1 === sign_r?45:43;
        caml_bytes_set(s$0,0,_aJ_);
        caml_bytes_set(s$0,2,46);
        caml_call5(Stdlib_bytes[11],s2,0,s$0,(n + 3 | 0) - l2 | 0,l2);
        return caml_call1(Stdlib_bytes[42],s$0)}
      var
       _aK_=base_power_big_int(10,- n | 0,r[2]),
       s$1=string_of_big_int(div_big_int(abs_big_int(r[1]),_aK_)),
       len=caml_ml_string_length(s$1) + 1 | 0,
       s$2=caml_call2(Stdlib_bytes[1],len,48),
       _aL_=-1 === sign_r?45:43;
      caml_bytes_set(s$2,0,_aL_);
      caml_call5(Stdlib_string[32],s$1,0,s$2,1,len - 1 | 0);
      return caml_call1(Stdlib_bytes[42],s$2)}
    function num_decimal_digits_int(n)
     {return caml_ml_string_length(caml_call1(Stdlib[33],n))}
    function approx_ratio_exp(n,r)
     {if(null_denominator(r))return failwith_zero(cst_approx_ratio_exp);
      if(0 < n)
       {var sign_r=sign_ratio(r),i$4=[0,n + 3 | 0];
        if(0 === sign_r)
         {var _ar_=[0,cst_0$0,[0,caml_call2(Stdlib_string[1],n,48),_m_]];
          return caml_call2(Stdlib_string[3],cst$4,_ar_)}
        var r$0=abs_ratio(r);
        cautious_normalize_ratio(r$0);
        if(null_denominator(r$0))
         var msd=failwith_zero(cst_msd_ratio);
        else
         if(0 === r$0[1][1])
          var msd=0;
         else
          {var
            s1=string_of_big_int(r$0[1]),
            s=string_of_big_int(r$0[2]),
            size_num=caml_ml_string_length(s1),
            lim=caml_ml_string_length(s),
            i$3=caml_call2(Stdlib[16],size_num,lim),
            m=size_num - lim | 0,
            i=0;
           for(;;)
            {if(i$3 <= i)
              var cmp=0;
             else
              {var
                c1=caml_string_get(s1,i),
                c2=caml_string_get(s,i),
                c=compare_int(c1,c2);
               if(0 === c){var i$0=i + 1 | 0,i=i$0;continue}
               var cmp=c}
             var switcher=cmp + 1 | 0,switch$0=0;
             if(2 < switcher >>> 0)
              switch$0 = 1;
             else
              switch(switcher)
               {case 0:var msd=m - 1 | 0;break;
                case 1:switch$0 = 1;break;
                default:var msd=m}
             if(switch$0)
              if(0 <= m)
               var msd=m;
              else
               {var i$1=i$3;
                for(;;)
                 {var _ao_=lim <= i$1?1:0;
                  if(_ao_)
                   var _ap_=_ao_;
                  else
                   {var _aq_=48 === caml_string_get(s,i$1)?1:0;
                    if(_aq_){var i$2=i$1 + 1 | 0,i$1=i$2;continue}
                    var _ap_=_aq_}
                  var msd=_ap_?m:m - 1 | 0;
                  break}}
             break}}
        var k=n - msd | 0;
        if(0 <= k)
         var
          _as_=r[2],
          _at_=div_big_int(base_power_big_int(10,k,abs_big_int(r[1])),_as_);
        else
         var
          _aF_=base_power_big_int(10,- k | 0,r[2]),
          _at_=div_big_int(abs_big_int(r[1]),_aF_);
        var
         nat=nat_of_big_int(_at_),
         s$0=string_of_nat(nat),
         s$1=caml_call1(Stdlib_bytes[5],s$0);
        if(round_futur_last_digit(s$1,0,caml_ml_bytes_length(s$1)))
         {var
           m$0=num_decimal_digits_int(msd + 1 | 0),
           str=caml_call2(Stdlib_bytes[1],(n + m$0 | 0) + 4 | 0,48),
           _au_=3,
           _av_=0,
           _aw_=0,
           _ax_=-1 === sign_r?cst_1$1:cst_1$2;
          caml_call5(Stdlib_string[32],_ax_,_aw_,str,_av_,_au_);
          caml_bytes_set(str,i$4[1],101);
          i$4[1]++;
          if(0 === m$0)
           caml_bytes_set(str,i$4[1],48);
          else
           {var _ay_=i$4[1],_az_=caml_call1(Stdlib[33],msd + 1 | 0);
            caml_call5(Stdlib_string[32],_az_,0,str,_ay_,m$0)}
          return caml_call1(Stdlib_bytes[42],str)}
        var
         m$1=num_decimal_digits_int(msd + 1 | 0),
         p=n + 3 | 0,
         str$0=caml_call2(Stdlib_bytes[1],(m$1 + p | 0) + 1 | 0,48),
         _aA_=3,
         _aB_=0,
         _aC_=0,
         _aD_=-1 === sign_r?cst_0$1:cst_0$2;
        caml_call5(Stdlib_string[32],_aD_,_aC_,str$0,_aB_,_aA_);
        caml_call5(Stdlib_bytes[11],s$1,0,str$0,3,n);
        caml_bytes_set(str$0,p,101);
        if(0 === m$1)
         caml_bytes_set(str$0,p + 1 | 0,48);
        else
         {var _aE_=caml_call1(Stdlib[33],msd + 1 | 0);
          caml_call5(Stdlib_string[32],_aE_,0,str$0,p + 1 | 0,m$1)}
        return caml_call1(Stdlib_bytes[42],str$0)}
      return caml_call1(Stdlib[1],cst_approx_ratio_exp$0)}
    function float_of_rational_string(r)
     {var s=approx_ratio_exp(floating_precision[1],r);
      return 43 === caml_string_get(s,0)
              ?caml_call3
                (Stdlib_string[9],s,1,caml_ml_string_length(s) - 1 | 0)
              :s}
    function string_of_ratio(r)
     {cautious_normalize_ratio_when_(r);
      if(approx_printing_flag[1])return float_of_rational_string(r);
      var
       _al_=string_of_big_int(r[2]),
       _am_=caml_call2(Stdlib[28],cst$5,_al_),
       _an_=string_of_big_int(r[1]);
      return caml_call2(Stdlib[28],_an_,_am_)}
    function ratio_of_string(s)
     {try
       {var
         n=caml_call2(Stdlib_string[25],s,47),
         _ai_=
          sys_big_int_of_string
           (s,n + 1 | 0,(caml_ml_string_length(s) - n | 0) - 1 | 0),
         _aj_=create_ratio(sys_big_int_of_string(s,0,n),_ai_);
        return _aj_}
      catch(_ak_)
       {_ak_ = caml_wrap_exception(_ak_);
        if(_ak_ === Stdlib[8])return [0,big_int_of_string(s),unit_big_int,1];
        throw _ak_}}
    function float_of_ratio(r)
     {var p=r[1],q=r[2];
      if(0 === q[1])
       {var match=p[1],switcher=match + 1 | 0;
        if(2 < switcher >>> 0)throw [0,Assert_failure,_n_];
        switch(switcher)
         {case 0:return Stdlib[23];
          case 1:return Stdlib[24];
          default:return Stdlib[22]}}
      if(0 === p[1])return 0.;
      var np=num_bits_big_int(p),nq=num_bits_big_int(q);
      if(! (53 < np) && ! (53 < nq))
       {var _ah_=caml_int64_to_float(int64_of_big_int(q));
        return caml_int64_to_float(int64_of_big_int(p)) / _ah_}
      var ap=abs_big_int(p),n=55 - (np - nq | 0) | 0;
      if(0 <= n)
       var q$0=q,p$0=shift_left_big_int(ap,n);
      else
       var q$1=shift_left_big_int(q,- n | 0),q$0=q$1,p$0=ap;
      var
       match$0=quomod_big_int(p$0,q$0),
       rem=match$0[2],
       quo=match$0[1],
       f=round_big_int_to_float(quo,0 === rem[1]?1:0),
       f$0=caml_ldexp_float(f,- n | 0);
      return 0 <= p[1]?f$0:- f$0}
    function power_ratio_positive_int(r,n)
     {var _ag_=power_big_int_positive_int(r[2],n);
      return create_ratio(power_big_int_positive_int(r[1],n),_ag_)}
    function power_ratio_positive_big_int(r,bi)
     {var _af_=power_big_int_positive_big_int(r[2],bi);
      return create_ratio(power_big_int_positive_big_int(r[1],bi),_af_)}
    var
     Ratio=
      [0,
       null_denominator,
       numerator_ratio,
       denominator_ratio,
       sign_ratio,
       normalize_ratio,
       cautious_normalize_ratio,
       cautious_normalize_ratio_when_,
       create_ratio,
       create_normalized_ratio,
       is_normalized_ratio,
       report_sign_ratio,
       abs_ratio,
       is_integer_ratio,
       add_ratio,
       minus_ratio,
       add_int_ratio,
       add_big_int_ratio,
       sub_ratio,
       mult_ratio,
       mult_int_ratio,
       mult_big_int_ratio,
       square_ratio,
       inverse_ratio,
       div_ratio,
       integer_ratio,
       floor_ratio,
       round_ratio,
       ceiling_ratio,
       eq_ratio,
       compare_ratio,
       lt_ratio,
       le_ratio,
       gt_ratio,
       ge_ratio,
       max_ratio,
       min_ratio,
       eq_big_int_ratio,
       compare_big_int_ratio,
       lt_big_int_ratio,
       le_big_int_ratio,
       gt_big_int_ratio,
       ge_big_int_ratio,
       int_of_ratio,
       ratio_of_int,
       ratio_of_nat,
       nat_of_ratio,
       ratio_of_big_int,
       big_int_of_ratio,
       div_int_ratio,
       div_ratio_int,
       div_big_int_ratio,
       div_ratio_big_int,
       approx_ratio_fix,
       approx_ratio_exp,
       float_of_rational_string,
       string_of_ratio,
       ratio_of_string,
       float_of_ratio,
       power_ratio_positive_int,
       power_ratio_positive_big_int];
    caml_register_global(132,Ratio,"Ratio");
    var
     biggest_INT=big_int_of_int(biggest_int),
     least_INT=big_int_of_int(least_int);
    function num_of_big_int(bi)
     {if(le_big_int(bi,biggest_INT) && ge_big_int(bi,least_INT))
       return [0,int_of_big_int(bi)];
      return [1,bi]}
    function num_of_ratio(r)
     {normalize_ratio(r);
      return is_integer_ratio(r)
              ?is_int_big_int(r[1])?[0,int_of_big_int(r[1])]:[1,r[1]]
              :[2,r]}
    function add_num(a,match)
     {switch(a[0])
       {case 0:
         var _ab_=a[1];
         switch(match[0])
          {case 0:
            var int2=match[1],r=_ab_ + int2 | 0;
            if(0 <= (_ab_ ^ int2 | _ab_ ^ r ^ -1))
             {var _ac_=big_int_of_int(int2);
              return [1,add_big_int(big_int_of_int(_ab_),_ac_)]}
            return [0,r];
           case 1:
            var bi=match[1];return num_of_big_int(add_int_big_int(_ab_,bi));
           default:var r$0=match[1];return [2,add_int_ratio(_ab_,r$0)]}
        case 1:
         var _ad_=a[1];
         switch(match[0])
          {case 0:
            var i=match[1];return num_of_big_int(add_int_big_int(i,_ad_));
           case 1:
            var bi2=match[1];return num_of_big_int(add_big_int(_ad_,bi2));
           default:var r$1=match[1];return [2,add_big_int_ratio(_ad_,r$1)]}
        default:
         var _ae_=a[1];
         switch(match[0])
          {case 0:var i$0=match[1];return [2,add_int_ratio(i$0,_ae_)];
           case 1:var bi$0=match[1];return [2,add_big_int_ratio(bi$0,_ae_)];
           default:var r2=match[1];return num_of_ratio(add_ratio(_ae_,r2))}}}
    function minus_num(param)
     {switch(param[0])
       {case 0:
         var i=param[1];
         return i === monster_int
                 ?[1,minus_big_int(big_int_of_int(i))]
                 :[0,- i | 0];
        case 1:var bi=param[1];return [1,minus_big_int(bi)];
        default:var r=param[1];return [2,minus_ratio(r)]}}
    function sub_num(n1,n2){return add_num(n1,minus_num(n2))}
    function mult_num(a,match)
     {switch(a[0])
       {case 0:
         var _Y_=a[1];
         switch(match[0])
          {case 0:
            var int2=match[1],_Z_=num_bits_int(int2);
            if((num_bits_int(_Y_) + _Z_ | 0) < length_of_int)
             return [0,caml_mul(_Y_,int2)];
            var ___=big_int_of_int(int2);
            return num_of_big_int(mult_big_int(big_int_of_int(_Y_),___));
           case 1:
            var bi=match[1];return num_of_big_int(mult_int_big_int(_Y_,bi));
           default:var r=match[1];return num_of_ratio(mult_int_ratio(_Y_,r))}
        case 1:
         var _$_=a[1];
         switch(match[0])
          {case 0:
            var i=match[1];return num_of_big_int(mult_int_big_int(i,_$_));
           case 1:
            var bi2=match[1];return num_of_big_int(mult_big_int(_$_,bi2));
           default:
            var r$0=match[1];return num_of_ratio(mult_big_int_ratio(_$_,r$0))}
        default:
         var _aa_=a[1];
         switch(match[0])
          {case 0:
            var i$0=match[1];return num_of_ratio(mult_int_ratio(i$0,_aa_));
           case 1:
            var bi$0=match[1];
            return num_of_ratio(mult_big_int_ratio(bi$0,_aa_));
           default:var r2=match[1];return num_of_ratio(mult_ratio(_aa_,r2))}}}
    function square_num(param)
     {switch(param[0])
       {case 0:
         var i=param[1];
         return (2 * num_bits_int(i) | 0) < length_of_int
                 ?[0,caml_mul(i,i)]
                 :num_of_big_int(square_big_int(big_int_of_int(i)));
        case 1:var bi=param[1];return [1,square_big_int(bi)];
        default:var r=param[1];return [2,square_ratio(r)]}}
    function div_num(n1,n2)
     {switch(n1[0])
       {case 0:
         var i1=n1[1];
         switch(n2[0])
          {case 0:
            var i2=n2[1],_X_=big_int_of_int(i2);
            return num_of_ratio(create_ratio(big_int_of_int(i1),_X_));
           case 1:
            var bi2=n2[1];
            return num_of_ratio(create_ratio(big_int_of_int(i1),bi2));
           default:var r2=n2[1];return num_of_ratio(div_int_ratio(i1,r2))}
        case 1:
         var bi1=n1[1];
         switch(n2[0])
          {case 0:
            var i2$0=n2[1];
            return num_of_ratio(create_ratio(bi1,big_int_of_int(i2$0)));
           case 1:
            var bi2$0=n2[1];return num_of_ratio(create_ratio(bi1,bi2$0));
           default:
            var r2$0=n2[1];return num_of_ratio(div_big_int_ratio(bi1,r2$0))}
        default:
         var r1=n1[1];
         switch(n2[0])
          {case 0:var i2$1=n2[1];return num_of_ratio(div_ratio_int(r1,i2$1));
           case 1:
            var bi2$1=n2[1];return num_of_ratio(div_ratio_big_int(r1,bi2$1));
           default:var r2$1=n2[1];return num_of_ratio(div_ratio(r1,r2$1))}}}
    function floor_num(n)
     {switch(n[0])
       {case 0:return n;
        case 1:return n;
        default:var r=n[1];return num_of_big_int(floor_ratio(r))}}
    function ratio_of_num(param)
     {switch(param[0])
       {case 0:var i=param[1];return ratio_of_int(i);
        case 1:var bi=param[1];return ratio_of_big_int(bi);
        default:var r=param[1];return r}}
    function quo_num(n1,n2)
     {switch(n1[0])
       {case 0:
         var _V_=n1[1];
         switch(n2[0])
          {case 0:
            var
             i2=n2[1],
             q=caml_div(_V_,i2),
             r=caml_mod(_V_,i2),
             q$0=0 <= r?q:0 < i2?q - 1 | 0:q + 1 | 0;
            return [0,q$0];
           case 1:
            var bi2=n2[1];
            return num_of_big_int(div_big_int(big_int_of_int(_V_),bi2));
           default:
            var r2=n2[1];
            return num_of_big_int
                    (report_sign_ratio
                      (r2,floor_ratio(div_int_ratio(_V_,abs_ratio(r2)))))}
        case 1:
         var _W_=n1[1];
         switch(n2[0])
          {case 0:
            var i2$0=n2[1];
            return num_of_big_int(div_big_int(_W_,big_int_of_int(i2$0)));
           case 1:
            var bi2$0=n2[1];return num_of_big_int(div_big_int(_W_,bi2$0));
           default:
            var r2$0=n2[1];
            return num_of_big_int
                    (report_sign_ratio
                      (r2$0,floor_ratio(div_big_int_ratio(_W_,abs_ratio(r2$0)))))}
        default:
         var r1=n1[1],r2$1=ratio_of_num(n2);
         return num_of_big_int
                 (report_sign_ratio
                   (r2$1,floor_ratio(div_ratio(r1,abs_ratio(r2$1)))))}}
    function mod_num(n1,n2)
     {switch(n1[0])
       {case 0:
         var _T_=n1[1];
         switch(n2[0])
          {case 0:
            var
             i2=n2[1],
             r=caml_mod(_T_,i2),
             r$0=0 <= r?r:0 < i2?r + i2 | 0:r - i2 | 0;
            return [0,r$0];
           case 1:
            var bi2=n2[1];
            return num_of_big_int(mod_big_int(big_int_of_int(_T_),bi2))
           }
         break;
        case 1:
         var _U_=n1[1];
         switch(n2[0])
          {case 0:
            var i2$0=n2[1];
            return num_of_big_int(mod_big_int(_U_,big_int_of_int(i2$0)));
           case 1:
            var bi2$0=n2[1];return num_of_big_int(mod_big_int(_U_,bi2$0))
           }
         break
        }
      return sub_num(n1,mult_num(n2,quo_num(n1,n2)))}
    function power_num(n,match$5)
     {switch(match$5[0])
       {case 0:
         var i$1=match$5[1];
         switch(n[0])
          {case 0:
            var i=n[1],match=sign_int(i$1);
            return 0 === match
                    ?_o_
                    :1 === match
                      ?num_of_big_int(power_int_positive_int(i,i$1))
                      :[2,
                        create_normalized_ratio
                         (unit_big_int,power_int_positive_int(i,- i$1 | 0))];
           case 1:
            var bi=n[1],match$0=sign_int(i$1);
            return 0 === match$0
                    ?_p_
                    :1 === match$0
                      ?num_of_big_int(power_big_int_positive_int(bi,i$1))
                      :[2,
                        create_normalized_ratio
                         (unit_big_int,power_big_int_positive_int(bi,- i$1 | 0))];
           default:
            var r=n[1],match$1=sign_int(i$1);
            return 0 === match$1
                    ?_q_
                    :1 === match$1
                      ?[2,power_ratio_positive_int(r,i$1)]
                      :[2,power_ratio_positive_int(inverse_ratio(r),- i$1 | 0)]}
        case 1:
         var bi$1=match$5[1];
         switch(n[0])
          {case 0:
            var i$0=n[1],match$2=bi$1[1];
            return 0 === match$2
                    ?_r_
                    :1 === match$2
                      ?num_of_big_int(power_int_positive_big_int(i$0,bi$1))
                      :[2,
                        create_normalized_ratio
                         (unit_big_int,
                          power_int_positive_big_int(i$0,minus_big_int(bi$1)))];
           case 1:
            var bi$0=n[1],match$3=bi$1[1];
            return 0 === match$3
                    ?_s_
                    :1 === match$3
                      ?num_of_big_int(power_big_int_positive_big_int(bi$0,bi$1))
                      :[2,
                        create_normalized_ratio
                         (unit_big_int,
                          power_big_int_positive_big_int(bi$0,minus_big_int(bi$1)))];
           default:
            var r$0=n[1],match$4=bi$1[1];
            if(0 === match$4)return _t_;
            if(1 === match$4)
             return [2,power_ratio_positive_big_int(r$0,bi$1)];
            var _S_=minus_big_int(bi$1);
            return [2,power_ratio_positive_big_int(inverse_ratio(r$0),_S_)]}
        default:return caml_call1(Stdlib[1],cst_power_num)}}
    function is_integer_num(param)
     {switch(param[0])
       {case 0:return 1;
        case 1:return 1;
        default:var r=param[1];return is_integer_ratio(r)}}
    function integer_num(n)
     {switch(n[0])
       {case 0:return n;
        case 1:return n;
        default:var r=n[1];return num_of_big_int(integer_ratio(r))}}
    function round_num(n)
     {switch(n[0])
       {case 0:return n;
        case 1:return n;
        default:var r=n[1];return num_of_big_int(round_ratio(r))}}
    function ceiling_num(n)
     {switch(n[0])
       {case 0:return n;
        case 1:return n;
        default:var r=n[1];return num_of_big_int(ceiling_ratio(r))}}
    function sign_num(param)
     {switch(param[0])
       {case 0:var i=param[1];return sign_int(i);
        case 1:var bi=param[1];return bi[1];
        default:var r=param[1];return sign_ratio(r)}}
    function eq_num(a,match)
     {switch(a[0])
       {case 0:
         var _P_=a[1];
         switch(match[0])
          {case 0:var int2=match[1];return _P_ === int2?1:0;
           case 1:var bi=match[1];return eq_big_int(big_int_of_int(_P_),bi);
           default:
            var r=match[1];return eq_big_int_ratio(big_int_of_int(_P_),r)}
        case 1:
         var _Q_=a[1];
         switch(match[0])
          {case 0:var i=match[1];return eq_big_int(big_int_of_int(i),_Q_);
           case 1:var bi2=match[1];return eq_big_int(_Q_,bi2);
           default:var r$0=match[1];return eq_big_int_ratio(_Q_,r$0)}
        default:
         var _R_=a[1];
         switch(match[0])
          {case 0:
            var i$0=match[1];return eq_big_int_ratio(big_int_of_int(i$0),_R_);
           case 1:var bi$0=match[1];return eq_big_int_ratio(bi$0,_R_);
           default:var r2=match[1];return eq_ratio(_R_,r2)}}}
    function symbol(a,b){return 1 - eq_num(a,b)}
    function compare_num(a,match)
     {switch(a[0])
       {case 0:
         var _M_=a[1];
         switch(match[0])
          {case 0:var int2=match[1];return compare_int(_M_,int2);
           case 1:
            var bi=match[1];return compare_big_int(big_int_of_int(_M_),bi);
           default:
            var r=match[1];return compare_big_int_ratio(big_int_of_int(_M_),r)}
        case 1:
         var _N_=a[1];
         switch(match[0])
          {case 0:
            var i=match[1];return compare_big_int(_N_,big_int_of_int(i));
           case 1:var bi2=match[1];return compare_big_int(_N_,bi2);
           default:var r$0=match[1];return compare_big_int_ratio(_N_,r$0)}
        default:
         var _O_=a[1];
         switch(match[0])
          {case 0:
            var i$0=match[1];
            return - compare_big_int_ratio(big_int_of_int(i$0),_O_) | 0;
           case 1:
            var bi$0=match[1];return - compare_big_int_ratio(bi$0,_O_) | 0;
           default:var r2=match[1];return compare_ratio(_O_,r2)}}}
    function lt_num(num1,num2){return compare_num(num1,num2) < 0?1:0}
    function le_num(num1,num2){return compare_num(num1,num2) <= 0?1:0}
    function gt_num(num1,num2){return 0 < compare_num(num1,num2)?1:0}
    function ge_num(num1,num2){return 0 <= compare_num(num1,num2)?1:0}
    function max_num(num1,num2){return lt_num(num1,num2)?num2:num1}
    function min_num(num1,num2){return gt_num(num1,num2)?num2:num1}
    function int_of_num(param)
     {switch(param[0])
       {case 0:var i=param[1];return i;
        case 1:var bi=param[1];return int_of_big_int(bi);
        default:var r=param[1];return int_of_ratio(r)}}
    function int_of_num_opt(param)
     {switch(param[0])
       {case 0:var i=param[1];return [0,i];
        case 1:var bi=param[1];return int_of_big_int_opt(bi);
        default:
         var r=param[1];
         try
          {var _K_=[0,int_of_ratio(r)];return _K_}
         catch(_L_)
          {_L_ = caml_wrap_exception(_L_);
           if(_L_[1] === Stdlib[7])return 0;
           throw _L_}}}
    function num_of_int(i)
     {return i === monster_int?[1,big_int_of_int(i)]:[0,i]}
    function nat_of_num(param)
     {switch(param[0])
       {case 0:var i=param[1];return nat_of_int(i);
        case 1:var bi=param[1];return nat_of_big_int(bi);
        default:var r=param[1];return nat_of_ratio(r)}}
    function num_of_nat(nat)
     {return is_nat_int(nat,0,length_nat(nat))
              ?[0,nth_digit_nat(nat,0)]
              :[1,big_int_of_nat(nat)]}
    function nat_of_num_opt(x)
     {try
       {var _I_=[0,nat_of_num(x)];return _I_}
      catch(_J_)
       {_J_ = caml_wrap_exception(_J_);
        if(_J_[1] === Stdlib[7])return 0;
        throw _J_}}
    function big_int_of_num(param)
     {switch(param[0])
       {case 0:var i=param[1];return big_int_of_int(i);
        case 1:var bi=param[1];return bi;
        default:var r=param[1];return big_int_of_ratio(r)}}
    function big_int_of_num_opt(x)
     {try
       {var _G_=[0,big_int_of_num(x)];return _G_}
      catch(_H_)
       {_H_ = caml_wrap_exception(_H_);
        if(_H_[1] === Stdlib[7])return 0;
        throw _H_}}
    function string_of_num(n)
     {if(normalize_ratio_when_printing_[1])
       switch(n[0])
        {case 0:var i=n[1],_F_=[0,i];break;
         case 1:var bi=n[1],_F_=num_of_big_int(bi);break;
         default:var r=n[1],_F_=is_integer_ratio(r)?num_of_big_int(r[1]):[2,r]}
      else
       var _F_=n;
      switch(_F_[0])
       {case 0:var i$0=_F_[1];return caml_call1(Stdlib[33],i$0);
        case 1:
         var bi$0=_F_[1];
         return approx_printing_flag[1]
                 ?approx_big_int(floating_precision[1],bi$0)
                 :string_of_big_int(bi$0);
        default:var r$0=_F_[1];return string_of_ratio(r$0)}}
    function num_of_string(s)
     {try
       {var flag=normalize_ratio_flag[1];
        normalize_ratio_flag[1] = 1;
        var r=ratio_of_string(s);
        normalize_ratio_flag[1] = flag;
        var _D_=eq_big_int(r[2],unit_big_int)?num_of_big_int(r[1]):[2,r];
        return _D_}
      catch(_E_)
       {_E_ = caml_wrap_exception(_E_);
        if(_E_[1] === Stdlib[7])
         return caml_call1(Stdlib[2],cst_num_of_string);
        throw _E_}}
    function num_of_string_opt(s)
     {try
       {var _B_=[0,num_of_string(s)];return _B_}
      catch(_C_)
       {_C_ = caml_wrap_exception(_C_);
        if(_C_[1] === Stdlib[7])return 0;
        throw _C_}}
    function float_of_num(param)
     {switch(param[0])
       {case 0:var i=param[1];return i;
        case 1:var bi=param[1];return float_of_big_int(bi);
        default:var r=param[1];return float_of_ratio(r)}}
    function succ_num(param)
     {switch(param[0])
       {case 0:
         var i=param[1];
         return i === biggest_int
                 ?[1,succ_big_int(big_int_of_int(i))]
                 :[0,i + 1 | 0];
        case 1:var bi=param[1];return num_of_big_int(succ_big_int(bi));
        default:var r=param[1];return [2,add_int_ratio(1,r)]}}
    function pred_num(param)
     {switch(param[0])
       {case 0:
         var i=param[1];
         return i === monster_int
                 ?[1,pred_big_int(big_int_of_int(i))]
                 :[0,i - 1 | 0];
        case 1:var bi=param[1];return num_of_big_int(pred_big_int(bi));
        default:var r=param[1];return [2,add_int_ratio(-1,r)]}}
    function abs_num(param)
     {switch(param[0])
       {case 0:
         var i=param[1];
         return i === monster_int
                 ?[1,minus_big_int(big_int_of_int(i))]
                 :[0,caml_call1(Stdlib[18],i)];
        case 1:var bi=param[1];return [1,abs_big_int(bi)];
        default:var r=param[1];return [2,abs_ratio(r)]}}
    function approx_num_fix(n,num)
     {return approx_ratio_fix(n,ratio_of_num(num))}
    function approx_num_exp(n,num)
     {return approx_ratio_exp(n,ratio_of_num(num))}
    function incr_num(r){r[1] = succ_num(r[1]);return 0}
    function decr_num(r){r[1] = pred_num(r[1]);return 0}
    var
     Num=
      [0,
       add_num,
       add_num,
       minus_num,
       sub_num,
       sub_num,
       mult_num,
       mult_num,
       square_num,
       div_num,
       div_num,
       quo_num,
       mod_num,
       power_num,
       power_num,
       abs_num,
       succ_num,
       pred_num,
       incr_num,
       decr_num,
       is_integer_num,
       integer_num,
       floor_num,
       round_num,
       ceiling_num,
       sign_num,
       eq_num,
       lt_num,
       gt_num,
       le_num,
       ge_num,
       symbol,
       eq_num,
       lt_num,
       le_num,
       gt_num,
       ge_num,
       compare_num,
       max_num,
       min_num,
       string_of_num,
       approx_num_fix,
       approx_num_exp,
       num_of_string,
       num_of_string_opt,
       int_of_num,
       int_of_num_opt,
       num_of_int,
       nat_of_num,
       nat_of_num_opt,
       num_of_nat,
       num_of_big_int,
       big_int_of_num,
       big_int_of_num_opt,
       ratio_of_num,
       num_of_ratio,
       float_of_num];
    caml_register_global(133,Num,"Num");
    function get_error_when_null_denominato(param)
     {return error_when_null_denominator_fl[1]}
    function set_error_when_null_denominato(choice)
     {error_when_null_denominator_fl[1] = choice;return 0}
    function get_normalize_ratio(param){return normalize_ratio_flag[1]}
    function set_normalize_ratio(choice)
     {normalize_ratio_flag[1] = choice;return 0}
    function get_normalize_ratio_when_print(param)
     {return normalize_ratio_when_printing_[1]}
    function set_normalize_ratio_when_print(choice)
     {normalize_ratio_when_printing_[1] = choice;return 0}
    function get_floating_precision(param){return floating_precision[1]}
    function set_floating_precision(i){floating_precision[1] = i;return 0}
    function get_approx_printing(param){return approx_printing_flag[1]}
    function set_approx_printing(b){approx_printing_flag[1] = b;return 0}
    function arith_print_string(s)
     {caml_call1(Stdlib[42],s);return caml_call1(Stdlib[42],cst$6)}
    function arith_print_bool(param)
     {return param
              ?caml_call1(Stdlib[42],cst_ON)
              :caml_call1(Stdlib[42],cst_OFF)}
    function arith_status(param)
     {caml_call1(Stdlib[47],0);
      arith_print_string(cst_Normalization_during_compu);
      arith_print_bool(get_normalize_ratio(0));
      caml_call1(Stdlib[47],0);
      caml_call1(Stdlib[42],cst_returned_by_get_normalize_);
      caml_call1(Stdlib[47],0);
      caml_call1(Stdlib[42],cst_modifiable_with_set_normal);
      caml_call1(Stdlib[47],0);
      caml_call1(Stdlib[47],0);
      arith_print_string(cst_Normalization_when_printin);
      arith_print_bool(get_normalize_ratio_when_print(0));
      caml_call1(Stdlib[47],0);
      caml_call1(Stdlib[42],cst_returned_by_get_normalize_$0);
      caml_call1(Stdlib[47],0);
      caml_call1(Stdlib[42],cst_modifiable_with_set_normal$0);
      caml_call1(Stdlib[47],0);
      caml_call1(Stdlib[47],0);
      arith_print_string(cst_Floating_point_approximati);
      arith_print_bool(get_approx_printing(0));
      caml_call1(Stdlib[47],0);
      caml_call1(Stdlib[42],cst_returned_by_get_approx_pri);
      caml_call1(Stdlib[47],0);
      caml_call1(Stdlib[42],cst_modifiable_with_set_approx);
      caml_call1(Stdlib[47],0);
      if(get_approx_printing(0))
       {caml_call1(Stdlib[42],cst_Default_precision);
        var _A_=get_floating_precision(0);
        caml_call1(Stdlib[44],_A_);
        caml_call1(Stdlib[47],0);
        caml_call1(Stdlib[42],cst_returned_by_get_floating_p);
        caml_call1(Stdlib[47],0);
        caml_call1(Stdlib[42],cst_modifiable_with_set_floati);
        caml_call1(Stdlib[47],0);
        caml_call1(Stdlib[47],0)}
      else
       caml_call1(Stdlib[47],0);
      arith_print_string(cst_Error_when_a_rational_deno);
      arith_print_bool(get_error_when_null_denominato(0));
      caml_call1(Stdlib[47],0);
      caml_call1(Stdlib[42],cst_returned_by_get_error_when);
      caml_call1(Stdlib[47],0);
      caml_call1(Stdlib[42],cst_modifiable_with_set_error_);
      return caml_call1(Stdlib[47],0)}
    var
     Arith_status=
      [0,
       arith_status,
       get_error_when_null_denominato,
       set_error_when_null_denominato,
       get_normalize_ratio,
       set_normalize_ratio,
       get_normalize_ratio_when_print,
       set_normalize_ratio_when_print,
       get_approx_printing,
       set_approx_printing,
       get_floating_precision,
       set_floating_precision];
    caml_register_global(134,Arith_status,"Arith_status");
    return}
  (function(){return this}()));


//# 1 ".js/str/str.cma.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_bytes_get=runtime.caml_bytes_get,
     caml_bytes_set=runtime.caml_bytes_set,
     caml_check_bound=runtime.caml_check_bound,
     caml_create_bytes=runtime.caml_create_bytes,
     caml_make_vect=runtime.caml_make_vect,
     caml_ml_string_length=runtime.caml_ml_string_length,
     caml_string_equal=runtime.caml_string_equal,
     caml_string_get=runtime.caml_string_get,
     caml_string_of_jsbytes=runtime.caml_string_of_jsbytes,
     caml_trampoline=runtime.caml_trampoline,
     caml_trampoline_return=runtime.caml_trampoline_return,
     caml_wrap_exception=runtime.caml_wrap_exception;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5
              ?f(a0,a1,a2,a3,a4)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4])}
    var
     global_data=runtime.caml_get_global_data(),
     cst=caml_string_of_jsbytes(""),
     cst$0=caml_string_of_jsbytes(""),
     cst$5=caml_string_of_jsbytes(""),
     cst$4=caml_string_of_jsbytes(""),
     cst$3=caml_string_of_jsbytes(""),
     cst_Str_matched_group=caml_string_of_jsbytes("Str.matched_group"),
     cst_Str_group_end=caml_string_of_jsbytes("Str.group_end"),
     cst_Str_group_beginning=caml_string_of_jsbytes("Str.group_beginning"),
     cst_group_not_closed_by=
      caml_string_of_jsbytes("\\( group not closed by \\)"),
     cst_class_not_closed_by=caml_string_of_jsbytes("[ class not closed by ]"),
     cst_spurious_in_regular_expres=
      caml_string_of_jsbytes("spurious \\) in regular expression"),
     cst_too_many_r_or_r_where_r_is=
      caml_string_of_jsbytes("too many r* or r+ where r is nullable"),
     cst$1=caml_string_of_jsbytes(""),
     cst$2=caml_string_of_jsbytes(""),
     Stdlib_list=global_data.Stdlib__list,
     Stdlib_string=global_data.Stdlib__string,
     Stdlib=global_data.Stdlib,
     Stdlib_bytes=global_data.Stdlib__bytes,
     Assert_failure=global_data.Assert_failure,
     Stdlib_buffer=global_data.Stdlib__buffer,
     Stdlib_char=global_data.Stdlib__char,
     Stdlib_array=global_data.Stdlib__array,
     Stdlib_map=global_data.Stdlib__map,
     _b_=[0,92],
     _c_=[0,caml_string_of_jsbytes("str.ml"),520,10],
     _a_=[0,caml_string_of_jsbytes("str.ml"),213,11];
    function string_before(s,n){return caml_call3(Stdlib_string[9],s,0,n)}
    function string_after(s,n)
     {return caml_call3(Stdlib_string[9],s,n,caml_ml_string_length(s) - n | 0)}
    function first_chars(s,n){return caml_call3(Stdlib_string[9],s,0,n)}
    function last_chars(s,n)
     {return caml_call3(Stdlib_string[9],s,caml_ml_string_length(s) - n | 0,n)}
    var full=caml_call2(Stdlib_bytes[1],32,255);
    function make_empty(param){return caml_call2(Stdlib_bytes[1],32,0)}
    function add(s,i)
     {var _ao_=caml_bytes_get(s,i >>> 3 | 0) | 1 << (i & 7);
      return caml_bytes_set(s,i >>> 3 | 0,caml_call1(Stdlib_char[1],_ao_))}
    function singleton(c){var s=make_empty(0);add(s,c);return s}
    function complement(s)
     {var r=caml_create_bytes(32),i=0;
      for(;;)
       {var _am_=caml_bytes_get(s,i) ^ 255;
        caml_bytes_set(r,i,caml_call1(Stdlib_char[1],_am_));
        var _an_=i + 1 | 0;
        if(31 !== i){var i=_an_;continue}
        return r}}
    function union(s1,s2)
     {var r=caml_create_bytes(32),i=0;
      for(;;)
       {var _aj_=caml_bytes_get(s2,i),_ak_=caml_bytes_get(s1,i) | _aj_;
        caml_bytes_set(r,i,caml_call1(Stdlib_char[1],_ak_));
        var _al_=i + 1 | 0;
        if(31 !== i){var i=_al_;continue}
        return r}}
    function disjoint(s1,s2)
     {try
       {var i=0;
        for(;;)
         {var _ag_=caml_bytes_get(s2,i);
          if(0 !== (caml_bytes_get(s1,i) & _ag_))throw Stdlib[3];
          var _ah_=i + 1 | 0;
          if(31 !== i){var i=_ah_;continue}
          var _af_=1;
          return _af_}}
      catch(_ai_)
       {_ai_ = caml_wrap_exception(_ai_);
        if(_ai_ === Stdlib[3])return 0;
        throw _ai_}}
    function iter(fn,s)
     {var i=0;
      for(;;)
       {var c=caml_bytes_get(s,i);
        if(0 !== c)
         {var j=0;
          for(;;)
           {if(0 !== (c & 1 << j))
             caml_call1(fn,caml_call1(Stdlib_char[1],(i << 3) + j | 0));
            var _ae_=j + 1 | 0;
            if(7 !== j){var j=_ae_;continue}
            break}}
        var _ad_=i + 1 | 0;
        if(31 !== i){var i=_ad_;continue}
        return 0}}
    function fold_case(s)
     {var r=make_empty(0);
      iter
       (function(c)
         {add(r,caml_call1(Stdlib_char[3],c));
          return add(r,caml_call1(Stdlib_char[4],c))},
        s);
      return r}
    var
     op_CHAR=0,
     op_CHARNORM=1,
     op_STRING=2,
     op_STRINGNORM=3,
     op_CHARCLASS=4,
     op_BOL=5,
     op_EOL=6,
     op_WORDBOUNDARY=7,
     op_BEGGROUP=8,
     op_ENDGROUP=9,
     op_REFGROUP=10,
     op_ACCEPT=11,
     op_SIMPLEOPT=12,
     op_SIMPLESTAR=13,
     op_SIMPLEPLUS=14,
     op_GOTO=15,
     op_PUSHBACK=16,
     op_SETMARK=17,
     op_CHECKPROGRESS=18;
    function instr(opc,arg){return opc | arg << 8}
    function displ(dest,from){return (dest - from | 0) - 1 | 0}
    function is_nullable(param)
     {var param$0=param;
      for(;;)
       if(typeof param$0 === "number")
        switch(param$0){case 0:return 1;case 1:return 1;default:return 1}
       else
        switch(param$0[0])
         {case 0:return 0;
          case 1:var s=param$0[1];return caml_string_equal(s,cst);
          case 2:return 0;
          case 3:
           var rl=param$0[1];
           return caml_call2(Stdlib_list[32],is_nullable,rl);
          case 4:
           var r2=param$0[2],r1=param$0[1],_ac_=is_nullable(r1);
           if(_ac_)return _ac_;
           var param$0=r2;
           continue;
          case 5:return 1;
          case 6:var param$1=param$0[1],param$0=param$1;continue;
          case 7:return 1;
          case 8:var param$2=param$0[2],param$0=param$2;continue;
          default:return 1}}
    function first$0(counter,param)
     {var param$0=param;
      for(;;)
       if(typeof param$0 === "number")
        switch(param$0)
         {case 0:return full;case 1:return full;default:return full}
       else
        switch(param$0[0])
         {case 0:var c=param$0[1];return singleton(c);
          case 1:
           var s=param$0[1];
           return caml_string_equal(s,cst$0)
                   ?full
                   :singleton(caml_string_get(s,0));
          case 2:
           var cmpl=param$0[2],cl=param$0[1];return cmpl?complement(cl):cl;
          case 3:
           var rl=param$0[1];
           if(counter < 50)
            {var counter$0=counter + 1 | 0;return first_seq$0(counter$0,rl)}
           return caml_trampoline_return(first_seq$0,[0,rl]);
          case 4:
           var r2=param$0[2],r1=param$0[1],_ab_=first(r2);
           return union(first(r1),_ab_);
          case 5:return full;
          case 6:var param$1=param$0[1],param$0=param$1;continue;
          case 7:return full;
          case 8:var param$2=param$0[2],param$0=param$2;continue;
          default:return full}}
    function first_seq$0(counter,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var ___=param$0[1];
          if(typeof ___ === "number")
           {var param$1=param$0[2],param$0=param$1;continue}
          else
           switch(___[0])
            {case 5:
              var rl=param$0[2],r=___[1],_$_=first_seq(rl);
              return union(first(r),_$_);
             case 7:
              var rl$0=param$0[2],r$0=___[1],_aa_=first_seq(rl$0);
              return union(first(r$0),_aa_);
             default:
              if(counter < 50)
               {var counter$0=counter + 1 | 0;return first$0(counter$0,___)}
              return caml_trampoline_return(first$0,[0,___])}}
        return full}}
    function first(param){return caml_trampoline(first$0(0,param))}
    function first_seq(param){return caml_trampoline(first_seq$0(0,param))}
    function charclass_of_regexp(fold_case$0,re)
     {var switch$0=0;
      if(typeof re !== "number")
       switch(re[0])
        {case 0:var c=re[1],compl=0,cl1=singleton(c);switch$0 = 1;break;
         case 2:
          var compl$0=re[2],cl=re[1],compl=compl$0,cl1=cl;switch$0 = 1;break
         }
      if(switch$0)
       {var cl2=fold_case$0?fold_case(cl1):cl1,_Z_=compl?complement(cl2):cl2;
        return caml_call1(Stdlib_bytes[6],_Z_)}
      throw [0,Assert_failure,_a_]}
    var t=caml_create_bytes(256),i=0;
    for(;;)
     {var _d_=caml_call1(Stdlib_char[1],i);
      caml_bytes_set(t,i,caml_call1(Stdlib_char[3],_d_));
      var _e_=i + 1 | 0;
      if(255 !== i){var i=_e_;continue}
      var
       fold_case_table=caml_call1(Stdlib_bytes[6],t),
       compare=function(x,y){return runtime.caml_string_compare(x,y)},
       StringMap=caml_call1(Stdlib_map[1],[0,compare]),
       compile=
        function(fold_case$0,re)
         {var
           prog=[0,caml_make_vect(32,0)],
           progpos=[0,0],
           cpool=[0,StringMap[1]],
           cpoolpos=[0,0],
           numgroups=[0,1],
           numregs=[0,0];
          function emit_instr(opc,arg)
           {if(prog[1].length - 1 <= progpos[1])
             {var newlen=[0,prog[1].length - 1];
              for(;;)
               {if(newlen[1] <= progpos[1])
                 {newlen[1] = newlen[1] * 2 | 0;continue}
                var nprog=caml_make_vect(newlen[1],0);
                caml_call5
                 (Stdlib_array[10],prog[1],0,nprog,0,prog[1].length - 1);
                prog[1] = nprog;
                break}}
            var _X_=instr(opc,arg),_Y_=progpos[1];
            caml_check_bound(prog[1],_Y_)[1 + _Y_] = _X_;
            progpos[1]++;
            return 0}
          function emit_hole(param)
           {var p=progpos[1];emit_instr(op_CHAR,0);return p}
          function patch_instr(pos,opc,dest)
           {var _W_=instr(opc,displ(dest,pos));
            caml_check_bound(prog[1],pos)[1 + pos] = _W_;
            return 0}
          function cpool_index(s)
           {try
             {var _U_=caml_call2(StringMap[28],s,cpool[1]);return _U_}
            catch(_V_)
             {_V_ = caml_wrap_exception(_V_);
              if(_V_ === Stdlib[8])
               {var p=cpoolpos[1];
                cpool[1] = caml_call3(StringMap[4],s,p,cpool[1]);
                cpoolpos[1]++;
                return p}
              throw _V_}}
          function allocate_register_if_nullable(r)
           {if(is_nullable(r))
             {var n=numregs[1];
              if(64 <= n)caml_call1(Stdlib[2],cst_too_many_r_or_r_where_r_is);
              numregs[1]++;
              return n}
            return -1}
          function disjoint_modulo_case(c1,c2)
           {if(fold_case$0)
             {var _T_=fold_case(c2);return disjoint(fold_case(c1),_T_)}
            return disjoint(c1,c2)}
          function emit_code(param)
           {if(typeof param === "number")
             switch(param)
              {case 0:return emit_instr(op_BOL,0);
               case 1:return emit_instr(op_EOL,0);
               default:return emit_instr(op_WORDBOUNDARY,0)}
            else
             switch(param[0])
              {case 0:
                var c=param[1];
                return fold_case$0
                        ?emit_instr(op_CHARNORM,caml_call1(Stdlib_char[3],c))
                        :emit_instr(op_CHAR,c);
               case 1:
                var s=param[1],match=caml_ml_string_length(s);
                if(0 === match)return 0;
                if(1 === match)
                 {if(fold_case$0)
                   {var _Q_=caml_string_get(s,0);
                    return emit_instr
                            (op_CHARNORM,caml_call1(Stdlib_char[3],_Q_))}
                  return emit_instr(op_CHAR,caml_string_get(s,0))}
                try
                 {var i=caml_call2(Stdlib_string[25],s,0);
                  emit_code([1,string_before(s,i)]);
                  emit_instr(op_CHAR,0);
                  var _R_=emit_code([1,string_after(s,i + 1 | 0)]);
                  return _R_}
                catch(_S_)
                 {_S_ = caml_wrap_exception(_S_);
                  if(_S_ === Stdlib[8])
                   return fold_case$0
                           ?emit_instr
                             (op_STRINGNORM,cpool_index(caml_call1(Stdlib_string[36],s)))
                           :emit_instr(op_STRING,cpool_index(s));
                  throw _S_}
               case 2:
                var
                 compl=param[2],
                 cl=param[1],
                 cl1=fold_case$0?fold_case(cl):cl,
                 cl2=compl?complement(cl1):cl1;
                return emit_instr
                        (op_CHARCLASS,cpool_index(caml_call1(Stdlib_bytes[6],cl2)));
               case 3:var rl=param[1];return emit_seq_code(rl);
               case 4:
                var r2=param[2],r1=param[1],pos_pushback=emit_hole(0);
                emit_code(r1);
                var pos_goto_end=emit_hole(0),lbl1=progpos[1];
                emit_code(r2);
                var lbl2=progpos[1];
                patch_instr(pos_pushback,op_PUSHBACK,lbl1);
                return patch_instr(pos_goto_end,op_GOTO,lbl2);
               case 5:
                var
                 r=param[1],
                 regno=allocate_register_if_nullable(r),
                 lbl1$0=emit_hole(0);
                if(0 <= regno)emit_instr(op_SETMARK,regno);
                emit_code(r);
                if(0 <= regno)emit_instr(op_CHECKPROGRESS,regno);
                emit_instr(op_GOTO,displ(lbl1$0,progpos[1]));
                var lbl2$0=progpos[1];
                return patch_instr(lbl1$0,op_PUSHBACK,lbl2$0);
               case 6:
                var
                 r$0=param[1],
                 regno$0=allocate_register_if_nullable(r$0),
                 lbl1$1=progpos[1];
                emit_code(r$0);
                if(0 <= regno$0)emit_instr(op_CHECKPROGRESS,regno$0);
                var pos_pushback$0=emit_hole(0);
                if(0 <= regno$0)emit_instr(op_SETMARK,regno$0);
                emit_instr(op_GOTO,displ(lbl1$1,progpos[1]));
                var lbl2$1=progpos[1];
                return patch_instr(pos_pushback$0,op_PUSHBACK,lbl2$1);
               case 7:
                var r$1=param[1],pos_pushback$1=emit_hole(0);
                emit_code(r$1);
                var lbl=progpos[1];
                return patch_instr(pos_pushback$1,op_PUSHBACK,lbl);
               case 8:
                var r$2=param[2],n=param[1];
                emit_instr(op_BEGGROUP,n);
                emit_code(r$2);
                emit_instr(op_ENDGROUP,n);
                numgroups[1] = caml_call2(Stdlib[17],numgroups[1],n + 1 | 0);
                return 0;
               default:
                var n$0=param[1];
                emit_instr(op_REFGROUP,n$0);
                numgroups[1]
                =
                caml_call2(Stdlib[17],numgroups[1],n$0 + 1 | 0);
                return 0}}
          function emit_seq_code(param)
           {var param$0=param;
            for(;;)
             {if(param$0)
               {var _J_=param$0[1];
                if(typeof _J_ !== "number")
                 switch(_J_[0])
                  {case 5:
                    var _K_=_J_[1],switch$0=0;
                    if(typeof _K_ === "number")
                     switch$0 = 1;
                    else
                     switch(_K_[0])
                      {case 0:
                       case 2:
                        var rl$0=param$0[2],_L_=first_seq(rl$0);
                        if(disjoint_modulo_case(first(_K_),_L_))
                         {emit_instr
                           (op_SIMPLESTAR,
                            cpool_index(charclass_of_regexp(fold_case$0,_K_)));
                          var param$0=rl$0;
                          continue}
                        break;
                       default:switch$0 = 1}
                    break;
                   case 6:
                    var _M_=_J_[1],switch$1=0;
                    if(typeof _M_ === "number")
                     switch$1 = 1;
                    else
                     switch(_M_[0])
                      {case 0:
                       case 2:
                        var rl$1=param$0[2],_N_=first_seq(rl$1);
                        if(disjoint_modulo_case(first(_M_),_N_))
                         {emit_instr
                           (op_SIMPLEPLUS,
                            cpool_index(charclass_of_regexp(fold_case$0,_M_)));
                          var param$0=rl$1;
                          continue}
                        break;
                       default:switch$1 = 1}
                    break;
                   case 7:
                    var _O_=_J_[1],switch$2=0;
                    if(typeof _O_ === "number")
                     switch$2 = 1;
                    else
                     switch(_O_[0])
                      {case 0:
                       case 2:
                        var rl$2=param$0[2],_P_=first_seq(rl$2);
                        if(disjoint_modulo_case(first(_O_),_P_))
                         {emit_instr
                           (op_SIMPLEOPT,
                            cpool_index(charclass_of_regexp(fold_case$0,_O_)));
                          var param$0=rl$2;
                          continue}
                        break;
                       default:switch$2 = 1}
                    break
                   }
                var rl=param$0[2];
                emit_code(_J_);
                var param$0=rl;
                continue}
              return 0}}
          emit_code(re);
          emit_instr(op_ACCEPT,0);
          var start=first(re),start$0=fold_case$0?fold_case(start):start;
          if(runtime.caml_bytes_equal(start,full))
           var start_pos=-1;
          else
           {var r=caml_call2(Stdlib_bytes[1],256,0);
            iter(function(c){return caml_bytes_set(r,c,1)},start$0);
            var start_pos=cpool_index(caml_call1(Stdlib_bytes[6],r))}
          var constantpool=caml_make_vect(cpoolpos[1],cst$1),_F_=cpool[1];
          function _G_(str,idx)
           {caml_check_bound(constantpool,idx)[1 + idx] = str;return 0}
          caml_call2(StringMap[12],_G_,_F_);
          var
           _H_=numregs[1],
           _I_=numgroups[1],
           fold_case_table$0=fold_case$0?fold_case_table:cst$2;
          return [0,
                  caml_call3(Stdlib_array[7],prog[1],0,progpos[1]),
                  constantpool,
                  fold_case_table$0,
                  _I_,
                  _H_,
                  start_pos]},
       flush=
        function(buf)
         {var s=caml_call1(Stdlib_buffer[2],buf[1]);
          caml_call1(Stdlib_buffer[8],buf[1]);
          var match=caml_ml_string_length(s);
          if(0 === match)return 0;
          if(1 === match)
           {var _E_=buf[2];buf[2] = [0,[0,caml_string_get(s,0)],_E_];return 0}
          buf[2] = [0,[1,s],buf[2]];
          return 0},
       dotclass=complement(singleton(10)),
       parse=
        function(s)
         {var len=caml_ml_string_length(s),group_counter=[0,1];
          function regexpclass1(start)
           {var c=make_empty(0),i$0=start;
            for(;;)
             {if(len <= i$0)caml_call1(Stdlib[2],cst_class_not_closed_by);
              if(93 === caml_string_get(s,i$0) && start < i$0)
               {var j=i$0 + 1 | 0;return [0,c,j]}
              var c1=caml_string_get(s,i$0);
              if
               ((i$0 + 2 | 0)
                <
                len
                &&
                45
                ===
                caml_string_get(s,i$0 + 1 | 0)
                &&
                93
                !==
                caml_string_get(s,i$0 + 2 | 0))
               {var c2=caml_string_get(s,i$0 + 2 | 0);
                if(! (c2 < c1))
                 {var i=c1;
                  for(;;)
                   {add(c,caml_call1(Stdlib_char[1],i));
                    var _D_=i + 1 | 0;
                    if(c2 !== i){var i=_D_;continue}
                    break}}
                var i$2=i$0 + 3 | 0,i$0=i$2;
                continue}
              add(c,c1);
              var i$1=i$0 + 1 | 0,i$0=i$1;
              continue}}
          function regexp1(i)
           {var sb=[0,caml_call1(Stdlib_buffer[1],16),0],i$0=i;
            a:
            for(;;)
             {if(! (len <= i$0))
               {var switch$0=0;
                if((i$0 + 2 | 0) <= len && 92 === caml_string_get(s,i$0))
                 {var
                   c$0=caml_string_get(s,i$0 + 1 | 0),
                   _A_=124 === c$0?1:0,
                   _B_=_A_ || (41 === c$0?1:0);
                  if(_B_)switch$0 = 1}
                if(! switch$0)
                 {var c$1=caml_string_get(s,i$0);
                  if(36 === c$1)
                   var match=[0,1,i$0 + 1 | 0];
                  else
                   {var switch$1=0;
                    if(91 <= c$1)
                     if(95 <= c$1)
                      switch$1 = 1;
                     else
                      {var switcher$0=c$1 - 91 | 0;
                       switch(switcher$0)
                        {case 0:
                          var i$4=i$0 + 1 | 0,switch$2=0;
                          if(i$4 < len && 94 === caml_string_get(s,i$4))
                           {var
                             match$3=regexpclass1(i$4 + 1 | 0),
                             j$3=match$3[2],
                             c$4=match$3[1],
                             match$1=[0,c$4,1,j$3];
                            switch$2 = 1}
                          if(! switch$2)
                           var
                            match$4=regexpclass1(i$4),
                            j$4=match$4[2],
                            c$5=match$4[1],
                            match$1=[0,c$5,0,j$4];
                          var
                           j$1=match$1[3],
                           compl=match$1[2],
                           c$2=match$1[1],
                           match=[0,[2,c$2,compl],j$1];
                          break;
                         case 1:
                          var i$5=i$0 + 1 | 0;
                          if(len <= i$5)
                           var _C_=[0,_b_,i$5];
                          else
                           {var c$3=caml_string_get(s,i$5),switch$3=0;
                            if(58 <= c$3)
                             if(98 === c$3)
                              var _C_=[0,2,i$5 + 1 | 0];
                             else
                              if(124 === c$3)switch$3 = 2;else switch$3 = 1;
                            else
                             {var switcher$1=c$3 - 40 | 0;
                              if(1 < switcher$1 >>> 0)
                               if(9 <= switcher$1)
                                var _C_=[0,[9,c$3 - 48 | 0],i$5 + 1 | 0];
                               else
                                switch$3 = 1;
                              else
                               if(switcher$1)
                                switch$3 = 2;
                               else
                                {var group_no=group_counter[1];
                                 group_counter[1]++;
                                 var
                                  match$2=regexp0(i$5 + 1 | 0),
                                  j$2=match$2[2],
                                  r$4=match$2[1],
                                  switch$4=0;
                                 if
                                  ((j$2 + 1 | 0)
                                   <
                                   len
                                   &&
                                   92
                                   ===
                                   caml_string_get(s,j$2)
                                   &&
                                   41
                                   ===
                                   caml_string_get(s,j$2 + 1 | 0))
                                  {var _C_=[0,[8,group_no,r$4],j$2 + 2 | 0];switch$4 = 1}
                                 if(! switch$4)
                                  var _C_=caml_call1(Stdlib[2],cst_group_not_closed_by)}}
                            switch(switch$3)
                             {case 1:var _C_=[0,[0,c$3],i$5 + 1 | 0];break;
                              case 2:throw [0,Assert_failure,_c_]
                              }}
                          var match=_C_;
                          break;
                         case 2:switch$1 = 1;break;
                         default:var match=[0,0,i$0 + 1 | 0]}}
                    else
                     if(46 === c$1)
                      var match=[0,[2,dotclass,0],i$0 + 1 | 0];
                     else
                      switch$1 = 1;
                    if(switch$1)var match=[0,[0,c$1],i$0 + 1 | 0]}
                  var j=match[2],r=match[1],r$0=r,j$0=j;
                  for(;;)
                   {if(! (len <= j$0))
                     {var
                       match$0=caml_string_get(s,j$0),
                       switcher=match$0 - 42 | 0;
                      if(! (1 < switcher >>> 0))
                       {if(switcher)
                         {var i$2=j$0 + 1 | 0,r$2=[6,r$0],r$0=r$2,j$0=i$2;continue}
                        var i$3=j$0 + 1 | 0,r$3=[5,r$0],r$0=r$3,j$0=i$3;
                        continue}
                      if(21 === switcher)
                       {var i$1=j$0 + 1 | 0,r$1=[7,r$0],r$0=r$1,j$0=i$1;continue}}
                    var switch$5=0;
                    if(typeof r$0 !== "number" && 0 === r$0[0])
                     {var c=r$0[1];
                      caml_call2(Stdlib_buffer[10],sb[1],c);
                      switch$5 = 1}
                    if(! switch$5){flush(sb);sb[2] = [0,r$0,sb[2]]}
                    var i$0=j$0;
                    continue a}}}
              flush(sb);
              return [0,[3,caml_call1(Stdlib_list[9],sb[2])],i$0]}}
          function regexp0(i)
           {var match=regexp1(i),j=match[2],r=match[1],r1=r,i$0=j;
            for(;;)
             {if
               ((i$0 + 2 | 0)
                <=
                len
                &&
                92
                ===
                caml_string_get(s,i$0)
                &&
                124
                ===
                caml_string_get(s,i$0 + 1 | 0))
               {var
                 match$0=regexp1(i$0 + 2 | 0),
                 i$1=match$0[2],
                 r2=match$0[1],
                 r1$0=[4,r1,r2],
                 r1=r1$0,
                 i$0=i$1;
                continue}
              return [0,r1,i$0]}}
          var match=regexp0(0),j=match[2],r=match[1];
          return j === len
                  ?r
                  :caml_call1(Stdlib[2],cst_spurious_in_regular_expres)},
       regexp=function(e){return compile(0,parse(e))},
       regexp_case_fold=function(e){return compile(1,parse(e))},
       quote=
        function(s)
         {var
           len=caml_ml_string_length(s),
           buf=caml_create_bytes(2 * len | 0),
           pos=[0,0],
           _w_=len - 1 | 0,
           _v_=0;
          if(! (_w_ < 0))
           {var i=_v_;
            for(;;)
             {var c=caml_string_get(s,i),_x_=c - 63 | 0,switch$0=0;
              if(31 < _x_ >>> 0)
               {var _y_=_x_ + 27 | 0;
                if(! (10 < _y_ >>> 0))
                 switch(_y_){case 0:case 6:case 7:case 10:switch$0 = 1;break}}
              else
               if(26 < (_x_ - 1 | 0) >>> 0)switch$0 = 1;
              if(switch$0)
               {caml_bytes_set(buf,pos[1],92);
                caml_bytes_set(buf,pos[1] + 1 | 0,c);
                pos[1] = pos[1] + 2 | 0}
              else
               {caml_bytes_set(buf,pos[1],c);pos[1] = pos[1] + 1 | 0}
              var _z_=i + 1 | 0;
              if(_w_ !== i){var i=_z_;continue}
              break}}
          return caml_call3(Stdlib_bytes[8],buf,0,pos[1])},
       regexp_string=function(s){return compile(0,[1,s])},
       regexp_string_case_fold=function(s){return compile(1,[1,s])},
       last_search_result=[0,[0]],
       string_match=
        function(re,s,pos)
         {var res=runtime.re_string_match(re,s,pos);
          last_search_result[1] = res;
          return 0 < res.length - 1?1:0},
       string_partial_match=
        function(re,s,pos)
         {var res=runtime.re_partial_match(re,s,pos);
          last_search_result[1] = res;
          return 0 < res.length - 1?1:0},
       search_forward=
        function(re,s,pos)
         {var res=runtime.re_search_forward(re,s,pos);
          last_search_result[1] = res;
          if(0 === res.length - 1)throw Stdlib[8];
          return caml_check_bound(res,0)[1]},
       search_backward=
        function(re,s,pos)
         {var res=runtime.re_search_backward(re,s,pos);
          last_search_result[1] = res;
          if(0 === res.length - 1)throw Stdlib[8];
          return caml_check_bound(res,0)[1]},
       group_beginning=
        function(n)
         {var n2=n + n | 0;
          if(0 <= n && ! (last_search_result[1].length - 1 <= n2))
           {var pos=caml_check_bound(last_search_result[1],n2)[1 + n2];
            if(-1 === pos)throw Stdlib[8];
            return pos}
          return caml_call1(Stdlib[1],cst_Str_group_beginning)},
       group_end=
        function(n)
         {var n2=n + n | 0;
          if(0 <= n && ! (last_search_result[1].length - 1 <= n2))
           {var
             _u_=n2 + 1 | 0,
             pos=caml_check_bound(last_search_result[1],_u_)[1 + _u_];
            if(-1 === pos)throw Stdlib[8];
            return pos}
          return caml_call1(Stdlib[1],cst_Str_group_end)},
       matched_group=
        function(n,txt)
         {var n2=n + n | 0;
          if(0 <= n && ! (last_search_result[1].length - 1 <= n2))
           {var
             b=caml_check_bound(last_search_result[1],n2)[1 + n2],
             _t_=n2 + 1 | 0,
             e=caml_check_bound(last_search_result[1],_t_)[1 + _t_];
            if(-1 === b)throw Stdlib[8];
            return caml_call3(Stdlib_string[9],txt,b,e - b | 0)}
          return caml_call1(Stdlib[1],cst_Str_matched_group)},
       match_beginning=function(param){return group_beginning(0)},
       match_end=function(param){return group_end(0)},
       matched_string=function(txt){return matched_group(0,txt)},
       replace_matched=
        function(repl,matched)
         {return runtime.re_replacement_text
                  (repl,last_search_result[1],matched)},
       substitute_first=
        function(expr,repl_fun,text)
         {try
           {var
             pos=search_forward(expr,text,0),
             _o_=[0,string_after(text,match_end(0)),0],
             _p_=[0,caml_call1(repl_fun,text),_o_],
             _q_=[0,string_before(text,pos),_p_],
             _r_=caml_call2(Stdlib_string[3],cst$3,_q_);
            return _r_}
          catch(_s_)
           {_s_ = caml_wrap_exception(_s_);
            if(_s_ === Stdlib[8])return text;
            throw _s_}},
       opt_search_forward=
        function(re,s,pos)
         {try
           {var _m_=[0,search_forward(re,s,pos)];return _m_}
          catch(_n_)
           {_n_ = caml_wrap_exception(_n_);
            if(_n_ === Stdlib[8])return 0;
            throw _n_}},
       global_substitute=
        function(expr,repl_fun,text)
         {var accu=0,start=0,last_was_empty=0;
          for(;;)
           {var startpos=last_was_empty?start + 1 | 0:start;
            if(caml_ml_string_length(text) < startpos)
             var _k_=[0,string_after(text,start),accu];
            else
             {var match=opt_search_forward(expr,text,startpos);
              if(match)
               {var
                 pos=match[1],
                 start$0=match_end(0),
                 repl_text=caml_call1(repl_fun,text),
                 last_was_empty$0=start$0 === pos?1:0,
                 accu$0=
                  [0,
                   repl_text,
                   [0,
                    caml_call3(Stdlib_string[9],text,start,pos - start | 0),
                    accu]],
                 accu=accu$0,
                 start=start$0,
                 last_was_empty=last_was_empty$0;
                continue}
              var _k_=[0,string_after(text,start),accu]}
            var _l_=caml_call1(Stdlib_list[9],_k_);
            return caml_call2(Stdlib_string[3],cst$4,_l_)}},
       global_replace=
        function(expr,repl,text)
         {return global_substitute
                  (expr,function(_j_){return replace_matched(repl,_j_)},text)},
       replace_first=
        function(expr,repl,text)
         {return substitute_first
                  (expr,function(_i_){return replace_matched(repl,_i_)},text)},
       opt_search_forward_progress=
        function(expr,text,start)
         {var match=opt_search_forward(expr,text,start);
          if(match)
           {var pos=match[1];
            return start < match_end(0)
                    ?[0,pos]
                    :start < caml_ml_string_length(text)
                      ?opt_search_forward(expr,text,start + 1 | 0)
                      :0}
          return 0},
       bounded_split=
        function(expr,text,num)
         {var
           start=string_match(expr,text,0)?match_end(0):0,
           accu=0,
           start$0=start,
           n=num;
          for(;;)
           {if(caml_ml_string_length(text) <= start$0)
             var _h_=accu;
            else
             if(1 === n)
              var _h_=[0,string_after(text,start$0),accu];
             else
              {var match=opt_search_forward_progress(expr,text,start$0);
               if(match)
                {var
                  pos=match[1],
                  n$0=n - 1 | 0,
                  start$1=match_end(0),
                  accu$0=
                   [0,
                    caml_call3(Stdlib_string[9],text,start$0,pos - start$0 | 0),
                    accu],
                  accu=accu$0,
                  start$0=start$1,
                  n=n$0;
                 continue}
               var _h_=[0,string_after(text,start$0),accu]}
            return caml_call1(Stdlib_list[9],_h_)}},
       split=function(expr,text){return bounded_split(expr,text,0)},
       bounded_split_delim=
        function(expr,text,num)
         {if(caml_string_equal(text,cst$5))return 0;
          var accu=0,start=0,n=num;
          for(;;)
           {if(caml_ml_string_length(text) < start)
             var _g_=accu;
            else
             if(1 === n)
              var _g_=[0,string_after(text,start),accu];
             else
              {var match=opt_search_forward_progress(expr,text,start);
               if(match)
                {var
                  pos=match[1],
                  n$0=n - 1 | 0,
                  start$0=match_end(0),
                  accu$0=
                   [0,
                    caml_call3(Stdlib_string[9],text,start,pos - start | 0),
                    accu],
                  accu=accu$0,
                  start=start$0,
                  n=n$0;
                 continue}
               var _g_=[0,string_after(text,start),accu]}
            return caml_call1(Stdlib_list[9],_g_)}},
       split_delim=
        function(expr,text){return bounded_split_delim(expr,text,0)},
       bounded_full_split=
        function(expr,text,num)
         {var accu=0,start=0,n=num;
          for(;;)
           {if(caml_ml_string_length(text) <= start)
             var _f_=accu;
            else
             if(1 === n)
              var _f_=[0,[0,string_after(text,start)],accu];
             else
              {var match=opt_search_forward_progress(expr,text,start);
               if(match)
                {var pos=match[1],s=matched_string(text);
                 if(start < pos)
                  {var
                    n$0=n - 1 | 0,
                    start$0=match_end(0),
                    accu$0=
                     [0,
                      [1,s],
                      [0,
                       [0,caml_call3(Stdlib_string[9],text,start,pos - start | 0)],
                       accu]],
                    accu=accu$0,
                    start=start$0,
                    n=n$0;
                   continue}
                 var
                  n$1=n - 1 | 0,
                  start$1=match_end(0),
                  accu$1=[0,[1,s],accu],
                  accu=accu$1,
                  start=start$1,
                  n=n$1;
                 continue}
               var _f_=[0,[0,string_after(text,start)],accu]}
            return caml_call1(Stdlib_list[9],_f_)}},
       full_split=function(expr,text){return bounded_full_split(expr,text,0)},
       Str=
        [0,
         regexp,
         regexp_case_fold,
         quote,
         regexp_string,
         regexp_string_case_fold,
         string_match,
         search_forward,
         search_backward,
         string_partial_match,
         matched_string,
         match_beginning,
         match_end,
         matched_group,
         group_beginning,
         group_end,
         global_replace,
         replace_first,
         global_substitute,
         substitute_first,
         replace_matched,
         split,
         bounded_split,
         split_delim,
         bounded_split_delim,
         full_split,
         bounded_full_split,
         string_before,
         string_after,
         first_chars,
         last_chars];
      runtime.caml_register_global(26,Str,"Str");
      return}}
  (function(){return this}()));


//# 1 ".js/uutf/uutf.cma.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_blit_bytes=runtime.caml_blit_bytes,
     caml_bytes_unsafe_get=runtime.caml_bytes_unsafe_get,
     caml_check_bound=runtime.caml_check_bound,
     caml_create_bytes=runtime.caml_create_bytes,
     caml_ml_bytes_length=runtime.caml_ml_bytes_length,
     caml_ml_string_length=runtime.caml_ml_string_length,
     caml_string_compare=runtime.caml_string_compare,
     caml_string_get=runtime.caml_string_get,
     caml_string_notequal=runtime.caml_string_notequal,
     caml_string_of_jsbytes=runtime.caml_string_of_jsbytes;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    var
     global_data=runtime.caml_get_global_data(),
     cst_UTF_8$0=caml_string_of_jsbytes("UTF-8"),
     cst_US_ASCII$0=caml_string_of_jsbytes("US-ASCII"),
     cst_ISO_8859_1$1=caml_string_of_jsbytes("ISO-8859-1"),
     cst_UTF_16$0=caml_string_of_jsbytes("UTF-16"),
     cst_UTF_16LE$0=caml_string_of_jsbytes("UTF-16LE"),
     cst_UTF_16BE$0=caml_string_of_jsbytes("UTF-16BE"),
     cst_ISO646_US=caml_string_of_jsbytes("ISO646-US"),
     cst_CSISOLATIN1=caml_string_of_jsbytes("CSISOLATIN1"),
     cst_ANSI_X3_4_1968=caml_string_of_jsbytes("ANSI_X3.4-1968"),
     cst_ANSI_X3_4_1986=caml_string_of_jsbytes("ANSI_X3.4-1986"),
     cst_ASCII=caml_string_of_jsbytes("ASCII"),
     cst_CP367=caml_string_of_jsbytes("CP367"),
     cst_CP819=caml_string_of_jsbytes("CP819"),
     cst_CSASCII=caml_string_of_jsbytes("CSASCII"),
     cst_IBM367=caml_string_of_jsbytes("IBM367"),
     cst_IBM819=caml_string_of_jsbytes("IBM819"),
     cst_ISO_8859_1$0=caml_string_of_jsbytes("ISO-8859-1"),
     cst_ISO_IR_100=caml_string_of_jsbytes("ISO-IR-100"),
     cst_ISO_IR_6=caml_string_of_jsbytes("ISO-IR-6"),
     cst_US=caml_string_of_jsbytes("US"),
     cst_ISO_646_IRV_1991=caml_string_of_jsbytes("ISO_646.IRV:1991"),
     cst_ISO_8859_1=caml_string_of_jsbytes("ISO_8859-1"),
     cst_ISO_8859_1_1987=caml_string_of_jsbytes("ISO_8859-1:1987"),
     cst_L1=caml_string_of_jsbytes("L1"),
     cst_LATIN1=caml_string_of_jsbytes("LATIN1"),
     cst_US_ASCII=caml_string_of_jsbytes("US-ASCII"),
     cst_UTF_16=caml_string_of_jsbytes("UTF-16"),
     cst_UTF_16BE=caml_string_of_jsbytes("UTF-16BE"),
     cst_UTF_16LE=caml_string_of_jsbytes("UTF-16LE"),
     cst_UTF_8=caml_string_of_jsbytes("UTF-8"),
     cst_expected_Await_encode=
      caml_string_of_jsbytes("expected `Await encode"),
     Stdlib_uchar=global_data.Stdlib__uchar,
     Stdlib_buffer=global_data.Stdlib__buffer,
     Stdlib_bytes=global_data.Stdlib__bytes,
     Stdlib=global_data.Stdlib,
     Assert_failure=global_data.Assert_failure,
     Stdlib_string=global_data.Stdlib__string,
     Stdlib_printf=global_data.Stdlib__printf,
     Stdlib_format=global_data.Stdlib__format,
     _a_=Stdlib_format[126],
     _B_=[0,caml_string_of_jsbytes("src/uutf.ml"),364,9],
     _u_=
      [0,
       [11,caml_string_of_jsbytes("`Await"),0],
       caml_string_of_jsbytes("`Await")],
     _v_=
      [0,[11,caml_string_of_jsbytes("`End"),0],caml_string_of_jsbytes("`End")],
     _w_=
      [0,
       [18,
        [1,[0,0,caml_string_of_jsbytes("")]],
        [11,caml_string_of_jsbytes("`Uchar U+"),[4,8,[0,2,4],0,[17,0,0]]]],
       caml_string_of_jsbytes("@[`Uchar U+%04X@]")],
     _x_=
      [0,
       [18,
        [1,[0,0,caml_string_of_jsbytes("")]],
        [11,caml_string_of_jsbytes("`Malformed ("),0]],
       caml_string_of_jsbytes("@[`Malformed (")],
     _y_=[0,[4,8,[0,2,2],0,0],caml_string_of_jsbytes("%02X")],
     _A_=[0,[12,32,[4,8,[0,2,2],0,0]],caml_string_of_jsbytes(" %02X")],
     _z_=[0,[12,41,[17,0,0]],caml_string_of_jsbytes(")@]")],
     _p_=[0,-211555818,3299808],
     _k_=[0,-211558048,3299808],
     _q_=[0,684370880,3299808],
     _o_=[0,684370880,427938126],
     _l_=[0,-211558048,427938126],
     _m_=[0,caml_string_of_jsbytes("src/uutf.ml"),154,55],
     _n_=[0,684370880,427938126],
     _r_=[0,caml_string_of_jsbytes("src/uutf.ml"),153,55],
     _s_=[0,caml_string_of_jsbytes("src/uutf.ml"),155,55],
     _t_=[0,684370880,3455931],
     _j_=[0,caml_string_of_jsbytes("src/uutf.ml"),121,9],
     _c_=[0,684370880],
     _d_=[0,-211555818],
     _e_=[0,-211558048],
     _f_=[0,143365725],
     _g_=[0,423112016],
     _h_=[0,338302576],
     _b_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid bounds (index "),
        [4,0,0,0,[11,caml_string_of_jsbytes(", length "),[4,0,0,0,[12,41,0]]]]],
       caml_string_of_jsbytes("invalid bounds (index %d, length %d)")],
     _i_=
      [0,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       3,
       3,
       3,
       3,
       3,
       3,
       3,
       3,
       3,
       3,
       3,
       3,
       3,
       3,
       3,
       3,
       4,
       4,
       4,
       4,
       4,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0];
    function invalid_bounds(j,l)
     {var _aF_=caml_call3(Stdlib_printf[4],_b_,j,l);
      return caml_call1(Stdlib[1],_aF_)}
    function unsafe_set_byte(s,j,byte$0)
     {runtime.caml_bytes_unsafe_set(s,j,byte$0);return 0}
    var
     u_bom=caml_call1(Stdlib_uchar[9],65279),
     u_rep=caml_call1(Stdlib_uchar[9],65533);
    function encoding_of_string(s)
     {var
       match=caml_call1(Stdlib_string[35],s),
       _aD_=caml_string_compare(match,cst_ISO646_US),
       switch$1=0;
      if(0 <= _aD_)
       {if(0 < _aD_)
         {var switch$0=caml_string_compare(match,cst_US);
          if(0 <= switch$0)
           {if(0 < switch$0 && caml_string_notequal(match,cst_US_ASCII))
             {if(! caml_string_notequal(match,cst_UTF_16))return _f_;
              if(! caml_string_notequal(match,cst_UTF_16BE))return _e_;
              if(! caml_string_notequal(match,cst_UTF_16LE))return _d_;
              if(! caml_string_notequal(match,cst_UTF_8))return _c_;
              switch$1 = 2}}
          else
           if(caml_string_notequal(match,cst_ISO_646_IRV_1991))
            if
             (caml_string_notequal(match,cst_ISO_8859_1)
              &&
              caml_string_notequal(match,cst_ISO_8859_1_1987)
              &&
              caml_string_notequal(match,cst_L1)
              &&
              caml_string_notequal(match,cst_LATIN1))
             switch$1 = 2;
            else
             switch$1 = 1}}
      else
       {var _aE_=caml_string_compare(match,cst_CSISOLATIN1);
        if(0 <= _aE_)
         if(0 < _aE_)
          {if(caml_string_notequal(match,cst_IBM367))
            if
             (caml_string_notequal(match,cst_IBM819)
              &&
              caml_string_notequal(match,cst_ISO_8859_1$0)
              &&
              caml_string_notequal(match,cst_ISO_IR_100))
             {if(caml_string_notequal(match,cst_ISO_IR_6))switch$1 = 2}
            else
             switch$1 = 1}
         else
          switch$1 = 1;
        else
         if
          (caml_string_notequal(match,cst_ANSI_X3_4_1968)
           &&
           caml_string_notequal(match,cst_ANSI_X3_4_1986)
           &&
           caml_string_notequal(match,cst_ASCII)
           &&
           caml_string_notequal(match,cst_CP367))
          if(caml_string_notequal(match,cst_CP819))
           {if(caml_string_notequal(match,cst_CSASCII))switch$1 = 2}
          else
           switch$1 = 1}
      switch(switch$1){case 2:return 0;case 0:return _g_;default:return _h_}}
    function encoding_to_string(param)
     {return 143365725 <= param
              ?423112016 <= param
                ?684370880 <= param?cst_UTF_8$0:cst_US_ASCII$0
                :338302576 <= param?cst_ISO_8859_1$1:cst_UTF_16$0
              :-211555818 <= param?cst_UTF_16LE$0:cst_UTF_16BE$0}
    function malformed(s,j,l)
     {return [0,659980059,caml_call3(Stdlib_bytes[8],s,j,l)]}
    function malformed_pair(be,hi,s,j,l)
     {var bs1=caml_call3(Stdlib_bytes[7],s,j,l),bs0=caml_create_bytes(2);
      if(be)var j1=1,j0=0;else var j1=0,j0=1;
      unsafe_set_byte(bs0,j0,hi >>> 8 | 0);
      unsafe_set_byte(bs0,j1,hi & 255);
      var _aC_=caml_call2(Stdlib_bytes[14],bs0,bs1);
      return [0,659980059,caml_call1(Stdlib_bytes[42],_aC_)]}
    var utf_8_len=_i_.slice();
    function r_utf_8(s,j,l)
     {function uchar(c){return [0,852405675,caml_call1(Stdlib_uchar[9],c)]}
      var switcher=l - 1 | 0;
      if(3 < switcher >>> 0)throw [0,Assert_failure,_j_];
      switch(switcher)
       {case 0:return uchar(caml_bytes_unsafe_get(s,j));
        case 1:
         var
          b0=caml_bytes_unsafe_get(s,j),
          b1=caml_bytes_unsafe_get(s,j + 1 | 0);
         return 2 === (b1 >>> 6 | 0)
                 ?uchar((b0 & 31) << 6 | b1 & 63)
                 :malformed(s,j,l);
        case 2:
         var
          b0$0=caml_bytes_unsafe_get(s,j),
          b1$0=caml_bytes_unsafe_get(s,j + 1 | 0),
          b2=caml_bytes_unsafe_get(s,j + 2 | 0),
          c=(b0$0 & 15) << 12 | (b1$0 & 63) << 6 | b2 & 63;
         if(2 === (b2 >>> 6 | 0))
          {if(224 === b0$0)
            {if(160 <= b1$0 && ! (191 < b1$0))return uchar(c);
             return malformed(s,j,l)}
           if(237 === b0$0)
            {if(128 <= b1$0 && ! (159 < b1$0))return uchar(c);
             return malformed(s,j,l)}
           return 2 === (b1$0 >>> 6 | 0)?uchar(c):malformed(s,j,l)}
         return malformed(s,j,l);
        default:
         var
          b0$1=caml_bytes_unsafe_get(s,j),
          b1$1=caml_bytes_unsafe_get(s,j + 1 | 0),
          b2$0=caml_bytes_unsafe_get(s,j + 2 | 0),
          b3=caml_bytes_unsafe_get(s,j + 3 | 0),
          c$0=
           (b0$1 & 7)
           <<
           18
           |
           (b1$1 & 63)
           <<
           12
           |
           (b2$0 & 63)
           <<
           6
           |
           b3
           &
           63;
         if(2 === (b3 >>> 6 | 0) && 2 === (b2$0 >>> 6 | 0))
          {if(240 === b0$1)
            {if(144 <= b1$1 && ! (191 < b1$1))return uchar(c$0);
             return malformed(s,j,l)}
           if(244 === b0$1)
            {if(128 <= b1$1 && ! (143 < b1$1))return uchar(c$0);
             return malformed(s,j,l)}
           return 2 === (b1$1 >>> 6 | 0)?uchar(c$0):malformed(s,j,l)}
         return malformed(s,j,l)}}
    function r_utf_16(s,j0,j1)
     {var
       b0=caml_bytes_unsafe_get(s,j0),
       b1=caml_bytes_unsafe_get(s,j1),
       u=b0 << 8 | b1;
      if(55296 <= u && ! (57343 < u))
       return 56319 < u
               ?malformed(s,caml_call2(Stdlib[16],j0,j1),2)
               :[0,16161,u];
      return [0,852405675,caml_call1(Stdlib_uchar[9],u)]}
    function r_utf_16_lo(hi,s,j0,j1)
     {var
       b0=caml_bytes_unsafe_get(s,j0),
       b1=caml_bytes_unsafe_get(s,j1),
       lo=b0 << 8 | b1;
      if(56320 <= lo && ! (57343 < lo))
       return [0,
               852405675,
               caml_call1
                (Stdlib_uchar[9],((hi & 1023) << 10 | lo & 1023) + 65536 | 0)];
      return malformed_pair(j0 < j1?1:0,hi,s,caml_call2(Stdlib[16],j0,j1),2)}
    function r_encoding(s,j,l)
     {function some(i){return i < l?[0,caml_bytes_unsafe_get(s,j + i | 0)]:0}
      var match=some(0),match$0=some(1),match$1=some(2);
      if(match)
       {var _aB_=match[1],switch$0=0;
        if(240 <= _aB_)
         if(254 === _aB_)
          {if(match$0){if(255 === match$0[1])return _k_;switch$0 = 1}}
         else
          if(255 === _aB_)
           {if(match$0){if(254 === match$0[1])return _p_;switch$0 = 1}}
          else
           switch$0 = 1;
        else
         if(0 === _aB_)
          {if(match$0)
            {var p=match$0[1];
             if(0 < p)return [0,-211558048,[0,605782321,p]];
             switch$0 = 1}}
         else
          if(239 <= _aB_)
           {if(match$0)
             if(187 === match$0[1])
              {if(match$1 && 191 === match$1[1])return _q_}
             else
              switch$0 = 1}
          else
           switch$0 = 1;
        if(switch$0 && match$0 && 0 === match$0[1] && 0 < _aB_)
         return [0,-211555818,[0,605782321,_aB_]];
        if(0 === caml_check_bound(utf_8_len,_aB_)[1 + _aB_])
         {if(match$0)return _l_;
          if(match$1)throw [0,Assert_failure,_m_];
          return _n_}
        return _o_}
      if(match$0)throw [0,Assert_failure,_r_];
      if(match$1)throw [0,Assert_failure,_s_];
      return _t_}
    function pp_decode(ppf,param)
     {if(typeof param === "number")
       return 1006505782 <= param
               ?caml_call2(_a_,ppf,_u_)
               :caml_call2(_a_,ppf,_v_);
      if(852405675 <= param[1])
       {var u=param[2];
        return caml_call3(_a_,ppf,_w_,caml_call1(Stdlib_uchar[10],u))}
      var bs=param[2],l=caml_ml_string_length(bs);
      caml_call2(_a_,ppf,_x_);
      if(0 < l)caml_call3(_a_,ppf,_y_,caml_string_get(bs,0));
      var _az_=l - 1 | 0,_ay_=1;
      if(! (_az_ < 1))
       {var i=_ay_;
        for(;;)
         {caml_call3(_a_,ppf,_A_,caml_string_get(bs,i));
          var _aA_=i + 1 | 0;
          if(_az_ !== i){var i=_aA_;continue}
          break}}
      return caml_call2(_a_,ppf,_z_)}
    function i_rem(d){return (d[7] - d[6] | 0) + 1 | 0}
    function eoi(d)
     {d[5] = Stdlib_bytes[3];d[6] = 0;d[7] = Stdlib[20];return 0}
    function src(d,s,j,l)
     {if(0 <= j && 0 <= l && ! (caml_ml_bytes_length(s) < (j + l | 0)))
       return 0 === l?eoi(d):(d[5] = s,d[6] = j,d[7] = (j + l | 0) - 1 | 0,0);
      return invalid_bounds(j,l)}
    function refill(k,d)
     {var _ax_=d[1];
      if(typeof _ax_ === "number"){d[18] = k;return 1006505782}
      if(438511779 <= _ax_[1])
       {var
         ic=_ax_[2],
         rc=caml_call4(Stdlib[84],ic,d[5],0,caml_ml_bytes_length(d[5]));
        src(d,d[5],0,rc);
        return caml_call1(k,d)}
      eoi(d);
      return caml_call1(k,d)}
    function t_need(d,need){d[9] = 0;d[10] = need;return 0}
    function t_fill(k,d)
     {function blit(d,l)
       {caml_blit_bytes(d[5],d[6],d[8],d[9],l);
        d[6] = d[6] + l | 0;
        d[9] = d[9] + l | 0;
        return 0}
      var rem=i_rem(d);
      if(0 <= rem)
       {var need=d[10] - d[9] | 0;
        return rem < need
                ?(blit(d,rem),refill(function(_aw_){return t_fill(k,_aw_)},d))
                :(blit(d,need),caml_call1(k,d))}
      return caml_call1(k,d)}
    function ret(k,v,byte_count,d)
     {d[18] = k;d[15] = d[15] + byte_count | 0;return caml_call2(d[17],d,v)}
    function decode_us_ascii(d)
     {var rem=i_rem(d);
      if(0 < rem)
       {var j=d[6];
        d[6] = d[6] + 1 | 0;
        var
         _au_=d[5],
         b0=caml_bytes_unsafe_get(_au_,j),
         _at_=1,
         _av_=
          127 < b0
           ?malformed(_au_,j,1)
           :[0,852405675,caml_call1(Stdlib_uchar[9],b0)];
        return ret(decode_us_ascii,_av_,_at_,d)}
      return 0 <= rem?refill(decode_us_ascii,d):3455931}
    function decode_iso_8859_1(d)
     {var rem=i_rem(d);
      if(0 < rem)
       {var j=d[6];
        d[6] = d[6] + 1 | 0;
        return ret
                (decode_iso_8859_1,
                 [0,
                  852405675,
                  caml_call1(Stdlib_uchar[9],caml_bytes_unsafe_get(d[5],j))],
                 1,
                 d)}
      return 0 <= rem?refill(decode_iso_8859_1,d):3455931}
    function t_decode_utf_8(d)
     {if(d[9] < d[10])
       {var _ar_=d[9];return ret(decode_utf_8,malformed(d[8],0,d[9]),_ar_,d)}
      var _as_=d[9];
      return ret(decode_utf_8,r_utf_8(d[8],0,d[9]),_as_,d)}
    function decode_utf_8(d)
     {var rem=i_rem(d);
      if(0 < rem)
       {var need=utf_8_len[1 + caml_bytes_unsafe_get(d[5],d[6])];
        if(rem < need){t_need(d,need);return t_fill(t_decode_utf_8,d)}
        var j=d[6];
        return 0 === need
                ?(d[6]
                  =
                  d[6]
                  +
                  1
                  |
                  0,
                  ret(decode_utf_8,malformed(d[5],j,1),1,d))
                :(d[6]
                  =
                  d[6]
                  +
                  need
                  |
                  0,
                  ret(decode_utf_8,r_utf_8(d[5],j,need),need,d))}
      return 0 <= rem?refill(decode_utf_8,d):3455931}
    function t_decode_utf_16be_lo(hi,d)
     {var bcount=d[9] + 2 | 0;
      return d[9] < d[10]
              ?ret(decode_utf_16be,malformed_pair(1,hi,d[8],0,d[9]),bcount,d)
              :ret(decode_utf_16be,r_utf_16_lo(hi,d[8],0,1),bcount,d)}
    function decode_utf_16be_lo(v,d)
     {if(659980059 <= v[1])return ret(decode_utf_16be,v,2,d);
      var hi=v[2],rem=i_rem(d);
      if(2 <= rem)
       {var j=d[6];
        d[6] = d[6] + 2 | 0;
        return ret(decode_utf_16be,r_utf_16_lo(hi,d[5],j,j + 1 | 0),4,d)}
      t_need(d,2);
      return t_fill(function(_aq_){return t_decode_utf_16be_lo(hi,_aq_)},d)}
    function t_decode_utf_16be(d)
     {if(d[9] < d[10])
       {var _ap_=d[9];
        return ret(decode_utf_16be,malformed(d[8],0,d[9]),_ap_,d)}
      return decode_utf_16be_lo(r_utf_16(d[8],0,1),d)}
    function decode_utf_16be(d)
     {var rem=i_rem(d);
      if(0 < rem)
       {if(2 <= rem)
         {var j=d[6];
          d[6] = d[6] + 2 | 0;
          return decode_utf_16be_lo(r_utf_16(d[5],j,j + 1 | 0),d)}
        t_need(d,2);
        return t_fill(t_decode_utf_16be,d)}
      return 0 <= rem?refill(decode_utf_16be,d):3455931}
    function t_decode_utf_16_lo(hi,d)
     {var bcount=d[9] + 2 | 0;
      return d[9] < d[10]
              ?ret(decode_utf_16,malformed_pair(0,hi,d[8],0,d[9]),bcount,d)
              :ret(decode_utf_16,r_utf_16_lo(hi,d[8],1,0),bcount,d)}
    function decode_utf_16le_lo(v,d)
     {if(659980059 <= v[1])return ret(decode_utf_16,v,2,d);
      var hi=v[2],rem=i_rem(d);
      if(2 <= rem)
       {var j=d[6];
        d[6] = d[6] + 2 | 0;
        return ret(decode_utf_16,r_utf_16_lo(hi,d[5],j + 1 | 0,j),4,d)}
      t_need(d,2);
      return t_fill(function(_ao_){return t_decode_utf_16_lo(hi,_ao_)},d)}
    function t_decode_utf_16(d)
     {if(d[9] < d[10])
       {var _an_=d[9];return ret(decode_utf_16,malformed(d[8],0,d[9]),_an_,d)}
      return decode_utf_16le_lo(r_utf_16(d[8],1,0),d)}
    function decode_utf_16(d)
     {var rem=i_rem(d);
      if(0 < rem)
       {if(2 <= rem)
         {var j=d[6];
          d[6] = d[6] + 2 | 0;
          return decode_utf_16le_lo(r_utf_16(d[5],j + 1 | 0,j),d)}
        t_need(d,2);
        return t_fill(t_decode_utf_16,d)}
      return 0 <= rem?refill(decode_utf_16,d):3455931}
    function guessed_utf_16(d,be,v)
     {if(be)
       var
        j1=1,
        j0=0,
        t_decode_utf_16_lo$0=t_decode_utf_16be_lo,
        t_decode_utf_16$0=t_decode_utf_16be,
        decode_utf_16$0=decode_utf_16be;
      else
       var
        j1=0,
        j0=1,
        t_decode_utf_16_lo$0=t_decode_utf_16_lo,
        t_decode_utf_16$0=t_decode_utf_16,
        decode_utf_16$0=decode_utf_16;
      function b3(k,d)
       {return 3 <= d[9]
                ?(d[10]
                  =
                  2,
                  d[9]
                  =
                  1,
                  unsafe_set_byte(d[8],0,caml_bytes_unsafe_get(d[8],2)),
                  t_fill(k,d))
                :decode_utf_16$0(d)}
      if(typeof v === "number")
       {if(427938126 <= v)
         {var v$0=r_utf_16(d[8],j0,j1);
          if(659980059 <= v$0[1])
           {var _ad_=2;
            return ret
                    (function(_am_){return b3(t_decode_utf_16$0,_am_)},
                     v$0,
                     _ad_,
                     d)}
          var hi=v$0[2];
          if(3 <= d[9])
           return b3(function(_al_){return t_decode_utf_16_lo$0(hi,_al_)},d);
          var _ae_=d[9];
          return ret
                  (decode_utf_16$0,
                   malformed_pair(be,hi,Stdlib_bytes[3],0,0),
                   _ae_,
                   d)}
        var _af_=2,_ag_=[0,852405675,u_bom];
        return ret
                (function(_ak_){return b3(t_decode_utf_16$0,_ak_)},
                 _ag_,
                 _af_,
                 d)}
      var u=v[2],_ah_=2,_ai_=[0,852405675,caml_call1(Stdlib_uchar[9],u)];
      return ret
              (function(_aj_){return b3(t_decode_utf_16$0,_aj_)},_ai_,_ah_,d)}
    function k(d)
     {function setup(d)
       {var match=r_encoding(d[8],0,d[9]),_ac_=match[1];
        if(-211555818 === _ac_)
         {var r=match[2];
          d[2] = -211555818;
          d[18] = decode_utf_16;
          return guessed_utf_16(d,0,r)}
        if(684370880 <= _ac_)
         {var r$0=match[2];
          d[2] = 684370880;
          d[18] = decode_utf_8;
          if(3455931 === r$0)return 3455931;
          if(427938126 <= r$0)
           {var
             b3=
              function(d)
               {var
                 b3=caml_bytes_unsafe_get(d[8],2),
                 n=caml_check_bound(utf_8_len,b3)[1 + b3];
                return 0 === n
                        ?ret(decode_utf_8,malformed(d[8],2,1),1,d)
                        :(d[10]
                          =
                          n,
                          d[9]
                          =
                          1,
                          unsafe_set_byte(d[8],0,b3),
                          t_fill(t_decode_utf_8,d))},
             b2=
              function(d)
               {var
                 b2=caml_bytes_unsafe_get(d[8],1),
                 b3$0=2 < d[9]?b3:decode_utf_8,
                 n=caml_check_bound(utf_8_len,b2)[1 + b2];
                if(0 === n)return ret(b3$0,malformed(d[8],1,1),1,d);
                if(1 === n)return ret(b3$0,r_utf_8(d[8],1,1),1,d);
                d[10] = n;
                unsafe_set_byte(d[8],0,b2);
                if(3 <= d[9])
                 {d[9] = 2;
                  unsafe_set_byte(d[8],1,caml_bytes_unsafe_get(d[8],2))}
                else
                 d[9] = 1;
                return t_fill(t_decode_utf_8,d)},
             b1=caml_bytes_unsafe_get(d[8],0),
             b2$0=1 < d[9]?b2:decode_utf_8,
             n=caml_check_bound(utf_8_len,b1)[1 + b1];
            if(4 < n >>> 0)throw [0,Assert_failure,_B_];
            switch(n)
             {case 0:return ret(b2$0,malformed(d[8],0,1),1,d);
              case 1:return ret(b2$0,r_utf_8(d[8],0,1),1,d);
              case 2:
               return 2 <= d[9]
                       ?3 <= d[9]
                         ?ret(b3,r_utf_8(d[8],0,2),2,d)
                         :ret(decode_utf_8,r_utf_8(d[8],0,2),2,d)
                       :ret(decode_utf_8,malformed(d[8],0,1),1,d);
              case 3:
               if(3 <= d[9])return ret(decode_utf_8,r_utf_8(d[8],0,3),3,d);
               var _aa_=d[9];
               return ret(decode_utf_8,malformed(d[8],0,d[9]),_aa_,d);
              default:
               if(3 <= d[9]){d[10] = 4;return t_fill(t_decode_utf_8,d)}
               var _ab_=d[9];
               return ret(decode_utf_8,malformed(d[8],0,d[9]),_ab_,d)}}
          return ret(decode_utf_8,[0,852405675,u_bom],3,d)}
        var r$1=match[2];
        d[2] = -211558048;
        d[18] = decode_utf_16be;
        return guessed_utf_16(d,1,r$1)}
      t_need(d,3);
      return t_fill(setup,d)}
    function nline(d){d[14] = 0;d[13] = d[13] + 1 | 0;return 0}
    function ncol(d){d[14] = d[14] + 1 | 0;return 0}
    function ncount(d){d[16] = d[16] + 1 | 0;return 0}
    function cr(d,b){d[12] = b;return 0}
    function pp(d,v)
     {if(852405675 <= v[1])
       {var
         u=v[2],
         match=caml_call1(Stdlib_uchar[10],u),
         _$_=match - 133 | 0,
         switch$0=0;
        if(8100 < _$_ >>> 0)
         {var switcher=_$_ + 123 | 0;
          if(! (3 < switcher >>> 0))
           switch(switcher)
            {case 0:
              var last_cr=d[12];
              cr(d,0);
              ncount(d);
              return last_cr?v:(nline(d),v);
             case 1:break;
             case 2:switch$0 = 1;break;
             default:cr(d,1);ncount(d);nline(d);return v}}
        else
         if(8097 < (_$_ - 1 | 0) >>> 0)switch$0 = 1;
        return switch$0
                ?(cr(d,0),ncount(d),nline(d),v)
                :(cr(d,0),ncount(d),ncol(d),v)}
      cr(d,0);
      ncount(d);
      ncol(d);
      return v}
    function pp_nln_readline(d,v)
     {if(852405675 <= v[1])
       {var
         u=v[2],
         match=caml_call1(Stdlib_uchar[10],u),
         ___=match - 133 | 0,
         switch$0=0;
        if(8100 < ___ >>> 0)
         {var switcher=___ + 123 | 0;
          if(! (3 < switcher >>> 0))
           switch(switcher)
            {case 0:
              var last_cr=d[12];
              cr(d,0);
              return last_cr
                      ?caml_call1(d[18],d)
                      :(ncount(d),nline(d),[0,852405675,d[4]]);
             case 1:break;
             case 2:switch$0 = 1;break;
             default:cr(d,1);ncount(d);nline(d);return [0,852405675,d[4]]}}
        else
         if(8097 < (___ - 1 | 0) >>> 0)switch$0 = 1;
        return switch$0
                ?(cr(d,0),ncount(d),nline(d),[0,852405675,d[4]])
                :(cr(d,0),ncount(d),ncol(d),v)}
      cr(d,0);
      ncount(d);
      ncol(d);
      return v}
    function pp_nln_nlf(d,v)
     {if(852405675 <= v[1])
       {var u=v[2],match=caml_call1(Stdlib_uchar[10],u),switch$0=0;
        if(14 <= match)
         {if(8232 <= match)
           {if(! (8234 <= match))switch$0 = 1}
          else
           if(133 === match)
            {cr(d,0);ncount(d);nline(d);return [0,852405675,d[4]]}}
        else
         if(10 <= match)
          {var switcher=match - 10 | 0;
           switch(switcher)
            {case 0:
              var last_cr=d[12];
              cr(d,0);
              return last_cr
                      ?caml_call1(d[18],d)
                      :(ncount(d),nline(d),[0,852405675,d[4]]);
             case 1:break;
             case 2:switch$0 = 1;break;
             default:cr(d,1);ncount(d);nline(d);return [0,852405675,d[4]]}}
        return switch$0
                ?(cr(d,0),ncount(d),nline(d),v)
                :(cr(d,0),ncount(d),ncol(d),v)}
      cr(d,0);
      ncount(d);
      ncol(d);
      return v}
    function pp_nln_ascii(d,v)
     {if(852405675 <= v[1])
       {var
         u=v[2],
         match=caml_call1(Stdlib_uchar[10],u),
         _Z_=match - 133 | 0,
         switch$0=0;
        if(8100 < _Z_ >>> 0)
         {var switcher=_Z_ + 123 | 0;
          if(! (3 < switcher >>> 0))
           switch(switcher)
            {case 0:
              var last_cr=d[12];
              cr(d,0);
              return last_cr
                      ?caml_call1(d[18],d)
                      :(ncount(d),nline(d),[0,852405675,d[4]]);
             case 1:break;
             case 2:switch$0 = 1;break;
             default:cr(d,1);ncount(d);nline(d);return [0,852405675,d[4]]}}
        else
         if(8097 < (_Z_ - 1 | 0) >>> 0)switch$0 = 1;
        return switch$0
                ?(cr(d,0),ncount(d),nline(d),v)
                :(cr(d,0),ncount(d),ncol(d),v)}
      cr(d,0);
      ncount(d);
      ncol(d);
      return v}
    function decode_fun(param)
     {return 143365725 <= param
              ?423112016 <= param
                ?684370880 <= param?decode_utf_8:decode_us_ascii
                :338302576 <= param?decode_iso_8859_1:decode_utf_16be
              :-211555818 <= param?decode_utf_16:decode_utf_16be}
    function decoder(nln,encoding,src)
     {if(nln)
       {var _X_=nln[1],_Y_=_X_[1];
        if(3895880 === _Y_)
         var nl=_X_[2],nl$0=nl,pp$0=pp_nln_nlf;
        else
         if(605782321 <= _Y_)
          var nl$1=_X_[2],nl$0=nl$1,pp$0=pp_nln_ascii;
         else
          var nl$2=_X_[2],nl$0=nl$2,pp$0=pp_nln_readline}
      else
       var nl$3=caml_call1(Stdlib_uchar[9],10),nl$0=nl$3,pp$0=pp;
      if(encoding)
       var e=encoding[1],k$0=decode_fun(e),encoding$0=e;
      else
       var k$0=k,encoding$0=684370880;
      if(typeof src === "number")
       var i_max=0,i_pos=1,i=Stdlib_bytes[3];
      else
       if(438511779 <= src[1])
        var i_max=0,i_pos=1,i=caml_create_bytes(65536);
       else
        var
         s=src[2],
         i_max$0=caml_ml_string_length(s) - 1 | 0,
         i$0=caml_call1(Stdlib_bytes[43],s),
         i_max=i_max$0,
         i_pos=0,
         i=i$0;
      var utf16=143365725 === encoding$0?1:0;
      return [0,
              src,
              encoding$0,
              nln,
              nl$0,
              i,
              i_pos,
              i_max,
              caml_create_bytes(4),
              0,
              0,
              0,
              0,
              1,
              0,
              0,
              0,
              function(d,v)
               {if(852405675 <= v[1])
                 {var u=v[2],match=caml_call1(Stdlib_uchar[10],u);
                  if(65279 === match)
                   {if(utf16){d[2] = -211558048;d[18] = decode_utf_16be}
                    d[11] = 1;
                    d[17] = pp$0;
                    return caml_call1(d[18],d)}
                  if(65534 === match && utf16)
                   {d[2] = -211555818;
                    d[18] = decode_utf_16;
                    d[11] = 1;
                    d[17] = pp$0;
                    return caml_call1(d[18],d)}
                  d[11] = 0;
                  d[17] = pp$0;
                  return caml_call2(d[17],d,v)}
                d[11] = 0;
                d[17] = pp$0;
                return caml_call2(d[17],d,v)},
              k$0]}
    function decode(d){return caml_call1(d[18],d)}
    function decoder_line(d){return d[13]}
    function decoder_col(d){return d[14]}
    function decoder_byte_count(d){return d[15]}
    function decoder_count(d){return d[16]}
    function decoder_removed_bom(d){return d[11]}
    function decoder_src(d){return d[1]}
    function decoder_nln(d){return d[3]}
    function decoder_encoding(d){return d[2]}
    function set_decoder_encoding(d,e)
     {d[2] = e;d[18] = decode_fun(e);return 0}
    function o_rem(e){return (e[5] - e[4] | 0) + 1 | 0}
    function dst(e,s,j,l)
     {var _U_=j < 0?1:0;
      if(_U_)
       var _V_=_U_;
      else
       var
        _W_=l < 0?1:0,
        _V_=_W_ || (caml_ml_bytes_length(s) < (j + l | 0)?1:0);
      if(_V_)invalid_bounds(j,l);
      e[3] = s;
      e[4] = j;
      e[5] = (j + l | 0) - 1 | 0;
      return 0}
    function flush(k,e)
     {var _T_=e[1];
      if(typeof _T_ === "number")
       {e[9]
        =
        function(e,param)
         {if(typeof param === "number" && 1006505782 <= param)
           return caml_call1(k,e);
          return caml_call1(Stdlib[1],cst_expected_Await_encode)};
        return 939392865}
      if(438511779 <= _T_[1])
       {var oc=_T_[2];
        caml_call4(Stdlib[68],oc,e[3],0,e[4]);
        e[4] = 0;
        return caml_call1(k,e)}
      var b=_T_[2],o=caml_call1(Stdlib_bytes[42],e[3]);
      caml_call4(Stdlib_buffer[16],b,o,0,e[4]);
      e[4] = 0;
      return caml_call1(k,e)}
    function t_range(e,max){e[7] = 0;e[8] = max;return 0}
    function t_flush(k,e)
     {function blit(e,l)
       {caml_blit_bytes(e[6],e[7],e[3],e[4],l);
        e[4] = e[4] + l | 0;
        e[7] = e[7] + l | 0;
        return 0}
      var rem=o_rem(e),len=(e[8] - e[7] | 0) + 1 | 0;
      return rem < len
              ?(blit(e,rem),flush(function(_S_){return t_flush(k,_S_)},e))
              :(blit(e,len),caml_call1(k,e))}
    function encode_utf_8(e,v)
     {function k(e){e[9] = encode_utf_8;return 17724}
      if(typeof v === "number")return 1006505782 <= v?k(e):flush(k,e);
      var u=v[2],u$0=caml_call1(Stdlib_uchar[10],u),rem=o_rem(e);
      if(127 < u$0)
       {if(2047 < u$0)
         {if(65535 < u$0)
           {if(4 <= rem)
             {var j=e[4];e[4] = e[4] + 4 | 0;var k$0=k,j$0=j,s=e[3]}
            else
             {t_range(e,3);
              var
               _M_=function(_R_){return t_flush(k,_R_)},
               k$0=_M_,
               j$0=0,
               s=e[6]}
            unsafe_set_byte(s,j$0,240 | u$0 >>> 18 | 0);
            unsafe_set_byte(s,j$0 + 1 | 0,128 | (u$0 >>> 12 | 0) & 63);
            unsafe_set_byte(s,j$0 + 2 | 0,128 | (u$0 >>> 6 | 0) & 63);
            unsafe_set_byte(s,j$0 + 3 | 0,128 | u$0 & 63);
            return k$0(e)}
          if(3 <= rem)
           {var j$1=e[4];e[4] = e[4] + 3 | 0;var k$1=k,j$2=j$1,s$0=e[3]}
          else
           {t_range(e,2);
            var
             _N_=function(_Q_){return t_flush(k,_Q_)},
             k$1=_N_,
             j$2=0,
             s$0=e[6]}
          unsafe_set_byte(s$0,j$2,224 | u$0 >>> 12 | 0);
          unsafe_set_byte(s$0,j$2 + 1 | 0,128 | (u$0 >>> 6 | 0) & 63);
          unsafe_set_byte(s$0,j$2 + 2 | 0,128 | u$0 & 63);
          return k$1(e)}
        if(2 <= rem)
         {var j$3=e[4];e[4] = e[4] + 2 | 0;var k$2=k,j$4=j$3,s$1=e[3]}
        else
         {t_range(e,1);
          var _O_=function(_P_){return t_flush(k,_P_)},k$2=_O_,j$4=0,s$1=e[6]}
        unsafe_set_byte(s$1,j$4,192 | u$0 >>> 6 | 0);
        unsafe_set_byte(s$1,j$4 + 1 | 0,128 | u$0 & 63);
        return k$2(e)}
      return 1 <= rem
              ?(unsafe_set_byte(e[3],e[4],u$0),e[4] = e[4] + 1 | 0,k(e))
              :flush(function(e){return encode_utf_8(e,v)},e)}
    function encode_utf_16be(e,v)
     {function k(e){e[9] = encode_utf_16be;return 17724}
      if(typeof v === "number")return 1006505782 <= v?k(e):flush(k,e);
      var u=v[2],u$0=caml_call1(Stdlib_uchar[10],u),rem=o_rem(e);
      if(65536 <= u$0)
       {if(4 <= rem)
         {var j=e[4];e[4] = e[4] + 4 | 0;var k$0=k,j$0=j,s=e[3]}
        else
         {t_range(e,3);
          var _I_=function(_L_){return t_flush(k,_L_)},k$0=_I_,j$0=0,s=e[6]}
        var
         u$1=u$0 - 65536 | 0,
         hi=55296 | u$1 >>> 10 | 0,
         lo=56320 | u$1 & 1023;
        unsafe_set_byte(s,j$0,hi >>> 8 | 0);
        unsafe_set_byte(s,j$0 + 1 | 0,hi & 255);
        unsafe_set_byte(s,j$0 + 2 | 0,lo >>> 8 | 0);
        unsafe_set_byte(s,j$0 + 3 | 0,lo & 255);
        return k$0(e)}
      if(2 <= rem)
       {var j$1=e[4];e[4] = e[4] + 2 | 0;var k$1=k,j$2=j$1,s$0=e[3]}
      else
       {t_range(e,1);
        var _J_=function(_K_){return t_flush(k,_K_)},k$1=_J_,j$2=0,s$0=e[6]}
      unsafe_set_byte(s$0,j$2,u$0 >>> 8 | 0);
      unsafe_set_byte(s$0,j$2 + 1 | 0,u$0 & 255);
      return k$1(e)}
    function encode_utf_16le(e,v)
     {function k(e){e[9] = encode_utf_16le;return 17724}
      if(typeof v === "number")return 1006505782 <= v?k(e):flush(k,e);
      var u=v[2],u$0=caml_call1(Stdlib_uchar[10],u),rem=o_rem(e);
      if(65536 <= u$0)
       {if(4 <= rem)
         {var j=e[4];e[4] = e[4] + 4 | 0;var k$0=k,j$0=j,s=e[3]}
        else
         {t_range(e,3);
          var _E_=function(_H_){return t_flush(k,_H_)},k$0=_E_,j$0=0,s=e[6]}
        var
         u$1=u$0 - 65536 | 0,
         hi=55296 | u$1 >>> 10 | 0,
         lo=56320 | u$1 & 1023;
        unsafe_set_byte(s,j$0,hi & 255);
        unsafe_set_byte(s,j$0 + 1 | 0,hi >>> 8 | 0);
        unsafe_set_byte(s,j$0 + 2 | 0,lo & 255);
        unsafe_set_byte(s,j$0 + 3 | 0,lo >>> 8 | 0);
        return k$0(e)}
      if(2 <= rem)
       {var j$1=e[4];e[4] = e[4] + 2 | 0;var k$1=k,j$2=j$1,s$0=e[3]}
      else
       {t_range(e,1);
        var _F_=function(_G_){return t_flush(k,_G_)},k$1=_F_,j$2=0,s$0=e[6]}
      unsafe_set_byte(s$0,j$2,u$0 & 255);
      unsafe_set_byte(s$0,j$2 + 1 | 0,u$0 >>> 8 | 0);
      return k$1(e)}
    function encoder(encoding,dst)
     {if(typeof dst === "number")
       var o_max=0,o_pos=1,o=Stdlib_bytes[3];
      else
       var o$0=caml_create_bytes(65536),o_max=65535,o_pos=0,o=o$0;
      var
       _D_=
        143365725 <= encoding
         ?684370880 <= encoding?encode_utf_8:encode_utf_16be
         :-211555818 <= encoding?encode_utf_16le:encode_utf_16be;
      return [0,dst,encoding,o,o_pos,o_max,caml_create_bytes(4),1,0,_D_]}
    function encode(e,v){return caml_call2(e[9],e,v)}
    function encoder_encoding(e){return e[2]}
    function encoder_dst(e){return e[1]}
    var Manual=[0,src,dst,o_rem];
    function encoding_guess(s)
     {var
       s$0=caml_call1(Stdlib_bytes[43],s),
       match=
        r_encoding(s$0,0,caml_call2(Stdlib[17],caml_ml_bytes_length(s$0),3)),
       _C_=match[1];
      if(-211555818 === _C_)
       {var d=match[2];return [0,-211555818,3299808 === d?1:0]}
      if(684370880 <= _C_)
       {var d$0=match[2];return [0,684370880,3299808 === d$0?1:0]}
      var d$1=match[2];
      return [0,-211558048,3299808 === d$1?1:0]}
    function fold_utf_8(opt,len,f,acc,s)
     {if(opt)var sth=opt[1],pos=sth;else var pos=0;
      if(len)
       var l=len[1],len$0=l;
      else
       var len$0=caml_ml_string_length(s) - pos | 0;
      var
       last=(pos + len$0 | 0) - 1 | 0,
       s$0=caml_call1(Stdlib_bytes[43],s),
       acc$0=acc,
       i=pos;
      for(;;)
       {if(last < i)return acc$0;
        var need=utf_8_len[1 + caml_bytes_unsafe_get(s$0,i)];
        if(0 === need)
         {var
           i$0=i + 1 | 0,
           acc$1=caml_call3(f,acc$0,i,malformed(s$0,i,1)),
           acc$0=acc$1,
           i=i$0;
          continue}
        var rem=(last - i | 0) + 1 | 0;
        if(rem < need)return caml_call3(f,acc$0,i,malformed(s$0,i,rem));
        var
         i$1=i + need | 0,
         acc$2=caml_call3(f,acc$0,i,r_utf_8(s$0,i,need)),
         acc$0=acc$2,
         i=i$1;
        continue}}
    function fold_utf_16be(opt,len,f,acc,s)
     {if(opt)var sth=opt[1],pos=sth;else var pos=0;
      if(len)
       var l=len[1],len$0=l;
      else
       var len$0=caml_ml_string_length(s) - pos | 0;
      var
       last=(pos + len$0 | 0) - 1 | 0,
       s$0=caml_call1(Stdlib_bytes[43],s),
       acc$0=acc,
       i=pos;
      for(;;)
       {if(last < i)return acc$0;
        var rem=(last - i | 0) + 1 | 0;
        if(2 <= rem)
         {var v=r_utf_16(s$0,i,i + 1 | 0);
          if(659980059 <= v[1])
           {var i$0=i + 2 | 0,acc$1=caml_call3(f,acc$0,i,v),acc$0=acc$1,i=i$0;
            continue}
          var hi=v[2];
          if(4 <= rem)
           {var
             i$1=i + 4 | 0,
             acc$2=
              caml_call3(f,acc$0,i,r_utf_16_lo(hi,s$0,i + 2 | 0,i + 3 | 0)),
             acc$0=acc$2,
             i=i$1;
            continue}
          return caml_call3(f,acc$0,i,malformed(s$0,i,rem))}
        return caml_call3(f,acc$0,i,malformed(s$0,i,1))}}
    function fold_utf_16le(opt,len,f,acc,s)
     {if(opt)var sth=opt[1],pos=sth;else var pos=0;
      if(len)
       var l=len[1],len$0=l;
      else
       var len$0=caml_ml_string_length(s) - pos | 0;
      var
       last=(pos + len$0 | 0) - 1 | 0,
       s$0=caml_call1(Stdlib_bytes[43],s),
       acc$0=acc,
       i=pos;
      for(;;)
       {if(last < i)return acc$0;
        var rem=(last - i | 0) + 1 | 0;
        if(2 <= rem)
         {var v=r_utf_16(s$0,i + 1 | 0,i);
          if(659980059 <= v[1])
           {var i$0=i + 2 | 0,acc$1=caml_call3(f,acc$0,i,v),acc$0=acc$1,i=i$0;
            continue}
          var hi=v[2];
          if(4 <= rem)
           {var
             i$1=i + 4 | 0,
             acc$2=
              caml_call3(f,acc$0,i,r_utf_16_lo(hi,s$0,i + 3 | 0,i + 2 | 0)),
             acc$0=acc$2,
             i=i$1;
            continue}
          return caml_call3(f,acc$0,i,malformed(s$0,i,rem))}
        return caml_call3(f,acc$0,i,malformed(s$0,i,1))}}
    var String=[0,encoding_guess,fold_utf_8,fold_utf_16be,fold_utf_16le];
    function add_utf_8(b,u)
     {var u$0=caml_call1(Stdlib_uchar[10],u);
      function w(byte$0){return caml_call2(Stdlib_buffer[10],b,byte$0)}
      return 127 < u$0
              ?2047 < u$0
                ?65535 < u$0
                  ?(w(240 | u$0 >>> 18 | 0),
                    w(128 | (u$0 >>> 12 | 0) & 63),
                    w(128 | (u$0 >>> 6 | 0) & 63),
                    w(128 | u$0 & 63))
                  :(w(224 | u$0 >>> 12 | 0),
                    w(128 | (u$0 >>> 6 | 0) & 63),
                    w(128 | u$0 & 63))
                :(w(192 | u$0 >>> 6 | 0),w(128 | u$0 & 63))
              :w(u$0)}
    function add_utf_16be(b,u)
     {var u$0=caml_call1(Stdlib_uchar[10],u);
      function w(byte$0){return caml_call2(Stdlib_buffer[10],b,byte$0)}
      if(65536 <= u$0)
       {var
         u$1=u$0 - 65536 | 0,
         hi=55296 | u$1 >>> 10 | 0,
         lo=56320 | u$1 & 1023;
        w(hi >>> 8 | 0);
        w(hi & 255);
        w(lo >>> 8 | 0);
        return w(lo & 255)}
      w(u$0 >>> 8 | 0);
      return w(u$0 & 255)}
    function add_utf_16le(b,u)
     {var u$0=caml_call1(Stdlib_uchar[10],u);
      function w(byte$0){return caml_call2(Stdlib_buffer[10],b,byte$0)}
      if(65536 <= u$0)
       {var
         u$1=u$0 - 65536 | 0,
         hi=55296 | u$1 >>> 10 | 0,
         lo=56320 | u$1 & 1023;
        w(hi & 255);
        w(hi >>> 8 | 0);
        w(lo & 255);
        return w(lo >>> 8 | 0)}
      w(u$0 & 255);
      return w(u$0 >>> 8 | 0)}
    var
     Buffer=[0,add_utf_8,add_utf_16be,add_utf_16le],
     Uutf=
      [0,
       u_bom,
       u_rep,
       encoding_of_string,
       encoding_to_string,
       decoder,
       decode,
       decoder_encoding,
       set_decoder_encoding,
       decoder_line,
       decoder_col,
       decoder_byte_count,
       decoder_count,
       decoder_removed_bom,
       decoder_src,
       decoder_nln,
       pp_decode,
       encoder,
       encode,
       encoder_encoding,
       encoder_dst,
       Manual,
       String,
       Buffer];
    runtime.caml_register_global(66,Uutf,"Uutf");
    return}
  (function(){return this}()));


//# 1 ".ace_common.objs/ace_common.cma.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_check_bound=runtime.caml_check_bound,
     caml_create_bytes=runtime.caml_create_bytes,
     caml_fresh_oo_id=runtime.caml_fresh_oo_id,
     caml_int64_and=runtime.caml_int64_and,
     caml_int64_of_int32=runtime.caml_int64_of_int32,
     caml_ml_string_length=runtime.caml_ml_string_length,
     caml_mod=runtime.caml_mod,
     caml_register_global=runtime.caml_register_global,
     caml_string_compare=runtime.caml_string_compare,
     caml_string_equal=runtime.caml_string_equal,
     caml_string_notequal=runtime.caml_string_notequal,
     caml_string_of_jsbytes=runtime.caml_string_of_jsbytes,
     caml_trampoline=runtime.caml_trampoline,
     caml_trampoline_return=runtime.caml_trampoline_return,
     caml_wrap_exception=runtime.caml_wrap_exception;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5
              ?f(a0,a1,a2,a3,a4)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4])}
    function caml_call6(f,a0,a1,a2,a3,a4,a5)
     {return f.length == 6
              ?f(a0,a1,a2,a3,a4,a5)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5])}
    function caml_call7(f,a0,a1,a2,a3,a4,a5,a6)
     {return f.length == 7
              ?f(a0,a1,a2,a3,a4,a5,a6)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5,a6])}
    function caml_call8(f,a0,a1,a2,a3,a4,a5,a6,a7)
     {return f.length == 8
              ?f(a0,a1,a2,a3,a4,a5,a6,a7)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5,a6,a7])}
    function caml_call10(f,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9)
     {return f.length == 10
              ?f(a0,a1,a2,a3,a4,a5,a6,a7,a8,a9)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5,a6,a7,a8,a9])}
    var
     global_data=runtime.caml_get_global_data(),
     cst_Not_a_valid_int32=caml_string_of_jsbytes("Not a valid int32."),
     cst_eng=caml_string_of_jsbytes("eng"),
     cst_fra=caml_string_of_jsbytes("fra"),
     cst_ger=caml_string_of_jsbytes("ger"),
     cst_ita=caml_string_of_jsbytes("ita"),
     cst_jap=caml_string_of_jsbytes("jap"),
     cst_spa=caml_string_of_jsbytes("spa"),
     cst_1=caml_string_of_jsbytes("1"),
     cst_2=caml_string_of_jsbytes("2"),
     cst_3=caml_string_of_jsbytes("3"),
     cst_4=caml_string_of_jsbytes("4"),
     cst_5=caml_string_of_jsbytes("5"),
     cst_1$0=caml_string_of_jsbytes("1"),
     cst_2$0=caml_string_of_jsbytes("2"),
     cst_3$0=caml_string_of_jsbytes("3"),
     cst_Unknown_answer=caml_string_of_jsbytes("Unknown answer."),
     cst_Old_rod=caml_string_of_jsbytes("Old rod"),
     cst_Good_rod=caml_string_of_jsbytes("Good rod"),
     cst_Super_rod=caml_string_of_jsbytes("Super rod"),
     cst_Save_InvalidSave=caml_string_of_jsbytes("Save.InvalidSave"),
     cst_Preprocess_VarNotFound=
      caml_string_of_jsbytes("Preprocess.VarNotFound"),
     partial=[12,32,[5,0,0,0,[17,4,0]]],
     cst_adc$0=caml_string_of_jsbytes("adc"),
     cst_sbc$0=caml_string_of_jsbytes("sbc"),
     cst_bic$0=caml_string_of_jsbytes("bic"),
     cst_and$0=caml_string_of_jsbytes("and"),
     cst_adc=caml_string_of_jsbytes("adc"),
     cst_and=caml_string_of_jsbytes("and"),
     cst_bic=caml_string_of_jsbytes("bic"),
     cst_sbc=caml_string_of_jsbytes("sbc"),
     cst_Not_implemented$0=caml_string_of_jsbytes("Not implemented"),
     cst_Not_implemented=caml_string_of_jsbytes("Not implemented"),
     cst_Arm_InvalidCommand=caml_string_of_jsbytes("Arm.InvalidCommand"),
     spacing_char=caml_string_of_jsbytes("_"),
     invalid_char=caml_string_of_jsbytes("\xe2\x9c\x96"),
     cst$1=caml_string_of_jsbytes(" "),
     cst=caml_string_of_jsbytes(""),
     cst$0=caml_string_of_jsbytes(" "),
     cst_Not_implemented$2=caml_string_of_jsbytes("Not implemented"),
     cst_Not_implemented$1=caml_string_of_jsbytes("Not implemented"),
     cst_Optimizer_CannotOptimize=
      caml_string_of_jsbytes("Optimizer.CannotOptimize"),
     cst_B$0=caml_string_of_jsbytes("B"),
     cst_ADC=caml_string_of_jsbytes("ADC"),
     cst_AND=caml_string_of_jsbytes("AND"),
     cst_BIC=caml_string_of_jsbytes("BIC"),
     cst_LDR=caml_string_of_jsbytes("LDR"),
     cst_MOV=caml_string_of_jsbytes("MOV"),
     cst_MVN=caml_string_of_jsbytes("MVN"),
     cst_SBC=caml_string_of_jsbytes("SBC"),
     cst_STR=caml_string_of_jsbytes("STR"),
     cst_r15=caml_string_of_jsbytes("r15"),
     cst_r1=caml_string_of_jsbytes("r1"),
     cst_fp=caml_string_of_jsbytes("fp"),
     cst_ip=caml_string_of_jsbytes("ip"),
     cst_lr=caml_string_of_jsbytes("lr"),
     cst_pc=caml_string_of_jsbytes("pc"),
     cst_r0=caml_string_of_jsbytes("r0"),
     cst_r10=caml_string_of_jsbytes("r10"),
     cst_r11=caml_string_of_jsbytes("r11"),
     cst_r12=caml_string_of_jsbytes("r12"),
     cst_r13=caml_string_of_jsbytes("r13"),
     cst_r14=caml_string_of_jsbytes("r14"),
     cst_r7=caml_string_of_jsbytes("r7"),
     cst_r2=caml_string_of_jsbytes("r2"),
     cst_r3=caml_string_of_jsbytes("r3"),
     cst_r4=caml_string_of_jsbytes("r4"),
     cst_r5=caml_string_of_jsbytes("r5"),
     cst_r6=caml_string_of_jsbytes("r6"),
     cst_r8=caml_string_of_jsbytes("r8"),
     cst_r9=caml_string_of_jsbytes("r9"),
     cst_sb=caml_string_of_jsbytes("sb"),
     cst_sl=caml_string_of_jsbytes("sl"),
     cst_sp=caml_string_of_jsbytes("sp"),
     cst_L$0=caml_string_of_jsbytes("L"),
     cst_S$0=caml_string_of_jsbytes("S"),
     mods=[0,0,0,0,0],
     cst_L=caml_string_of_jsbytes("L"),
     cst_S=caml_string_of_jsbytes("S"),
     cst_BT=caml_string_of_jsbytes("BT"),
     cst_SB=caml_string_of_jsbytes("SB"),
     cst_SH=caml_string_of_jsbytes("SH"),
     cst_B=caml_string_of_jsbytes("B"),
     cst_H=caml_string_of_jsbytes("H"),
     cst_T=caml_string_of_jsbytes("T"),
     cst_W=caml_string_of_jsbytes("W"),
     cst_LE=caml_string_of_jsbytes("LE"),
     cst_AL=caml_string_of_jsbytes("AL"),
     cst_CC=caml_string_of_jsbytes("CC"),
     cst_CS=caml_string_of_jsbytes("CS"),
     cst_EQ=caml_string_of_jsbytes("EQ"),
     cst_GE=caml_string_of_jsbytes("GE"),
     cst_GT=caml_string_of_jsbytes("GT"),
     cst_HI=caml_string_of_jsbytes("HI"),
     cst_HS=caml_string_of_jsbytes("HS"),
     cst_LO=caml_string_of_jsbytes("LO"),
     cst_LS=caml_string_of_jsbytes("LS"),
     cst_LT=caml_string_of_jsbytes("LT"),
     cst_MI=caml_string_of_jsbytes("MI"),
     cst_NE=caml_string_of_jsbytes("NE"),
     cst_PL=caml_string_of_jsbytes("PL"),
     cst_VC=caml_string_of_jsbytes("VC"),
     cst_VS=caml_string_of_jsbytes("VS"),
     cst_Parser_ast_CommandError=
      caml_string_of_jsbytes("Parser_ast.CommandError"),
     cst_Parser_ast_StructError=
      caml_string_of_jsbytes("Parser_ast.StructError"),
     cst_Parser_MenhirBasics_Error=
      caml_string_of_jsbytes("Parser.MenhirBasics.Error"),
     cst_Unexpected_char=caml_string_of_jsbytes("Unexpected char: "),
     cst_String_cannot_be_multiline=
      caml_string_of_jsbytes("String cannot be multiline"),
     cst_String_is_not_terminated=
      caml_string_of_jsbytes("String is not terminated"),
     cst_Illegal_string_character=
      caml_string_of_jsbytes("Illegal string character: "),
     cst_Lexer_SyntaxError=caml_string_of_jsbytes("Lexer.SyntaxError"),
     ocaml_lex_tables=
      [0,
       caml_string_of_jsbytes
        ("\0\0\xd7\xff\xd8\xff\xd9\xff\xda\xff\xdf\xff\xe0\xff\xe1\xff\xe2\xff\xe3\xff\xe4\xff\xe5\xff\xe7\xff\xe8\xff\xe9\xff\xea\xff\xeb\xff\xec\xff\xee\xffO\0\x9a\0\xa4\0\xf1\xff\x01\0\x02\0\x07\x001\0\xf4\xff\t\0c\0\x0e\0N\0N\0Q\0\xed\x008\x01\x83\x01N\0R\0m\0n\0o\0p\0\xfe\xff\xce\x01\x19\x02d\x02\xaf\x02\xfa\x02E\x03\x90\x03\xdb\x03&\x04q\x04\xfa\xff\xf9\xff\xf7\xff\xf6\xff\xf5\xff\xf2\xff\x04\0\xae\0\xb7\0\xbc\x04\xb9\0\xd3\x04\xc4\0\xd7\0\xec\x04\xf5\xff\xf6\xff\x07\0\xed\x04\xcc\x04\xff\xff\xf8\xff\xf9\xff\xfa\xff\xfb\xff\xfc\xff\xfd\xff\xfe\xff\x0f\0\xfd\xff\xfe\xff\xff\xff\b\0"),
       caml_string_of_jsbytes
        ('\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x10\0\x0f\0\x0f\0\xff\xff\x0e\0(\0\f\0!\0\xff\xff"\0#\0$\0\x19\0(\0(\0\x10\0\x10\0\x10\0\x0b\0\x12\0\x07\0\xff\xff\xff\xff\0\0\xff\xff\x10\0\x10\0\x02\0\x10\0\x10\0\x03\0\x10\0\x10\0\x10\0\x04\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\r\0\xff\xff\xff\xff\xff\xff\xff\xff\x0f\0\x0f\0\x0f\0\xff\xff\xff\xff\xff\xff\t\0\b\0\x0b\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0'),
       caml_string_of_jsbytes
        ("\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\0\0\0\0\0\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffH\0\0\0\0\0\xff\xffH\0\xff\xff\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0S\0\0\0\0\0\0\0\xff\xff"),
       caml_string_of_jsbytes
        ("\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x19\0\x16\0\x16\0;\0\x17\0;\0<\0\x19\0F\0U\0\0\0\0\0\0\0\0\0\0\0\0\0U\0\0\0\0\0V\0\0\0\0\0\0\0\x19\0\x1f\0\x12\0\x11\0\0\0\x1c\0\x1d\0\x19\0\t\0\b\0\x05\0\x07\0\f\0\x06\0\x1b\0\x1a\0\x15\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\n\0\x1b\0!\0&\0 \0\x0b\0%\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x10\0\x18\0\x0f\0\x04\0\x13\0\x1b\0\x13\0\x13\0\x13\0\x13\0\x13\0\"\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0$\0\x13\0\x13\0\x13\0\x13\0\x13\0#\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x0e\0\x1e\0\r\0\x03\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0:\x009\x008\x007\x006\0+\0'\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0(\0)\0*\0*\0\x13\0\0\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0C\0C\0C\0C\0C\0C\0C\0C\0>\0B\0B\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0=\0B\0B\0\0\0\0\0\0\0@\0\0\0\0\0?\0\0\0\0\0\0\0\x02\0\0\0\0\0\0\0\0\0\0\0>\0C\0C\0C\0C\0C\0C\0C\0C\0T\0\0\0\0\0\0\0=\0\0\0\0\0\0\0\0\0\0\0@\0\0\0\0\0?\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\0\0\0\0\0\0\0\0\x13\0\0\x002\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\0\0\0\0\0\0\0\0\x13\0\0\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0/\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\0\0\0\0\0\0\0\0\x13\0\0\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0,\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\0\0\0\0\0\0\0\0\x13\0\0\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0-\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\0\0\0\0\0\0\0\0\x13\0\0\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0.\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\0\0\0\0\0\0\0\0\x13\0\0\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\0\0\0\0\0\0\0\0\x13\0\0\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\x000\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\0\0\0\0\0\0\0\0\x13\0\0\0\x13\0\x13\0\x13\0\x13\x001\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\0\0\0\0\0\0\0\0\x13\0\0\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\0\0\0\0\0\0\0\0\x13\0\0\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\x003\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\0\0\0\0\0\0\0\0\x13\0\0\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\x004\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\0\0\0\0\0\0\0\0\x13\0\0\0\x13\0\x13\0\x13\0\x13\x005\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\0\0\0\0\0\0\0\0\x13\0\0\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0F\0\xff\xff\0\0G\0\xff\xffQ\0\0\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0\0\0J\0\xff\xff\0\0\0\0\0\0\0\0A\0A\0A\0A\0A\0A\0\0\0\0\0\0\0A\0A\0A\0A\0A\0A\0\0\0\0\0\0\0\0\0\0\0P\0\0\0\0\0\0\0\0\0\0\0O\0\0\0\0\0\0\0N\0\0\0A\0A\0A\0A\0A\0A\0M\0\0\0\0\0\0\0L\0\0\0K\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0I\0\xff\xff\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0E\0\xff\xff"),
       caml_string_of_jsbytes
        ('\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\x17\0\x18\0\0\0<\0\x18\0\x19\0G\0V\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\0\xff\xff\xff\xffR\0\xff\xff\xff\xff\xff\xff\0\0\0\0\0\0\0\0\xff\xff\0\0\0\0\x19\0\0\0\0\0\0\0\0\0\0\0\0\0\x1c\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x1a\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x1d\0\x1e\0\x1f\0 \0!\0%\0&\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\'\0(\0)\0*\0\x13\0\xff\xff\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x15\0\x15\0\x15\0\x15\0\x15\0\x15\0\x15\0\x15\0\x15\0\x15\0=\0=\0=\0=\0=\0=\0=\0=\0\x15\0>\0>\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0\x15\0B\0B\0\xff\xff\xff\xff\xff\xff\x15\0\xff\xff\xff\xff\x15\0\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x15\0C\0C\0C\0C\0C\0C\0C\0C\0R\0\xff\xff\xff\xff\xff\xff\x15\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x15\0\xff\xff\xff\xff\x15\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0\xff\xff\xff\xff\xff\xff\xff\xff"\0\xff\xff"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0\xff\xff\xff\xff\xff\xff\xff\xff#\0\xff\xff#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0\xff\xff\xff\xff\xff\xff\xff\xff$\0\xff\xff$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0\xff\xff\xff\xff\xff\xff\xff\xff,\0\xff\xff,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0\xff\xff\xff\xff\xff\xff\xff\xff-\0\xff\xff-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0\xff\xff\xff\xff\xff\xff\xff\xff.\0\xff\xff.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0\xff\xff\xff\xff\xff\xff\xff\xff/\0\xff\xff/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff0\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\0\xff\xff\xff\xff\xff\xff\xff\xff0\0\xff\xff0\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\0\xff\xff\xff\xff\xff\xff\xff\xff1\0\xff\xff1\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff2\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\0\xff\xff\xff\xff\xff\xff\xff\xff2\0\xff\xff2\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff3\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\0\xff\xff\xff\xff\xff\xff\xff\xff3\0\xff\xff3\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff4\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\0\xff\xff\xff\xff\xff\xff\xff\xff4\0\xff\xff4\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff5\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\0\xff\xff\xff\xff\xff\xff\xff\xff5\0\xff\xff5\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\0?\0?\0?\0?\0?\0?\0?\0?\0?\0?\0D\0H\0\xff\xffD\0H\0I\0\xff\xff?\0?\0?\0?\0?\0?\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0\xff\xffD\0H\0\xff\xff\xff\xff\xff\xff\xff\xffA\0A\0A\0A\0A\0A\0\xff\xff\xff\xff\xff\xff?\0?\0?\0?\0?\0?\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffI\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffI\0\xff\xff\xff\xff\xff\xffI\0\xff\xffA\0A\0A\0A\0A\0A\0I\0\xff\xff\xff\xff\xff\xffI\0\xff\xffI\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffD\0H\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffD\0H\0'),
       caml_string_of_jsbytes(""),
       caml_string_of_jsbytes(""),
       caml_string_of_jsbytes(""),
       caml_string_of_jsbytes(""),
       caml_string_of_jsbytes(""),
       caml_string_of_jsbytes("")],
     cst_Parse_InvalidContent=caml_string_of_jsbytes("Parse.InvalidContent"),
     cst_filename=caml_string_of_jsbytes("filename"),
     cst_Please_specify_the_filenam=
      caml_string_of_jsbytes
       ("Please specify the 'filename' header everywhere."),
     cst_Invalid_headers=caml_string_of_jsbytes("Invalid headers."),
     cst_start=caml_string_of_jsbytes("start"),
     cst_Exit_code_has_invalid_head=
      caml_string_of_jsbytes("Exit code has invalid headers."),
     cst_txt=caml_string_of_jsbytes(".txt"),
     cst_Exit_codes_cannot_be_tweak=
      caml_string_of_jsbytes
       ("Exit codes cannot be tweaked (please remove interrogation marks)."),
     cst_Exit_NoExitCode=caml_string_of_jsbytes("Exit.NoExitCode"),
     cst_Invalid_starting_position=
      caml_string_of_jsbytes("Invalid starting position."),
     cst_Some_codes_cannot_be_posit=
      caml_string_of_jsbytes
       ("Some codes cannot be positionned due to non-consecutive 0xFF bytes."),
     cst_Result_is_inconsistent_Ple=
      caml_string_of_jsbytes
       ("Result is inconsistent. Please check the fillers."),
     cst_Result_is_inconsistent_Ple$0=
      caml_string_of_jsbytes
       ("Result is inconsistent. Please check the fillers."),
     cst_Boxes_BoxFittingError=caml_string_of_jsbytes("Boxes.BoxFittingError"),
     nop_code=[0,0,[0,0,[0,0,[0,0,0]]]],
     nop_code2=[0,0,[0,0,[0,0,[0,176,0]]]],
     cst$8=caml_string_of_jsbytes("!"),
     cst$9=caml_string_of_jsbytes(""),
     cst_Not_implemented$4=caml_string_of_jsbytes("Not implemented"),
     cst_Not_implemented$3=caml_string_of_jsbytes("Not implemented"),
     cst_L$1=caml_string_of_jsbytes("L"),
     cst$7=caml_string_of_jsbytes(""),
     cst_S$1=caml_string_of_jsbytes("S"),
     cst$6=caml_string_of_jsbytes(""),
     cst$4=caml_string_of_jsbytes("-"),
     cst$5=caml_string_of_jsbytes(""),
     cst_B$1=caml_string_of_jsbytes("B"),
     cst_SB$0=caml_string_of_jsbytes("SB"),
     cst_H$0=caml_string_of_jsbytes("H"),
     cst_SH$0=caml_string_of_jsbytes("SH"),
     cst$3=caml_string_of_jsbytes(""),
     cst_T$0=caml_string_of_jsbytes("T"),
     cst_BT$0=caml_string_of_jsbytes("BT"),
     cst_EQ$0=caml_string_of_jsbytes("EQ"),
     cst_NE$0=caml_string_of_jsbytes("NE"),
     cst_CS$0=caml_string_of_jsbytes("CS"),
     cst_HS$0=caml_string_of_jsbytes("HS"),
     cst_CC$0=caml_string_of_jsbytes("CC"),
     cst_LO$0=caml_string_of_jsbytes("LO"),
     cst_MI$0=caml_string_of_jsbytes("MI"),
     cst_PL$0=caml_string_of_jsbytes("PL"),
     cst_VS$0=caml_string_of_jsbytes("VS"),
     cst_VC$0=caml_string_of_jsbytes("VC"),
     cst_HI$0=caml_string_of_jsbytes("HI"),
     cst_LS$0=caml_string_of_jsbytes("LS"),
     cst_GE$0=caml_string_of_jsbytes("GE"),
     cst_LT$0=caml_string_of_jsbytes("LT"),
     cst_GT$0=caml_string_of_jsbytes("GT"),
     cst_LE$0=caml_string_of_jsbytes("LE"),
     cst$2=caml_string_of_jsbytes(""),
     cst_Invalid_filler=caml_string_of_jsbytes("Invalid filler."),
     cst_Invalid_headers$0=caml_string_of_jsbytes("Invalid headers."),
     cst_onlyraw=caml_string_of_jsbytes("onlyraw"),
     cst_Invalid_headers$3=caml_string_of_jsbytes("Invalid headers."),
     cst_Only_raw_mode_does_not_sup=
      caml_string_of_jsbytes("Only-raw mode does not support exit codes."),
     cst_start$0=caml_string_of_jsbytes("start"),
     cst_Invalid_headers$2=caml_string_of_jsbytes("Invalid headers."),
     cst_fill=caml_string_of_jsbytes("fill"),
     cst_fill$0=caml_string_of_jsbytes("fill"),
     cst_The_fill_header_has_a_diff=
      caml_string_of_jsbytes
       ("The 'fill' header has a different value in the main code and in the exit code."),
     cst_Invalid_headers$1=caml_string_of_jsbytes("Invalid headers."),
     cst_The_exit_code_overlaps_thi=
      caml_string_of_jsbytes
       ("The exit code overlaps this code (too long?).@."),
     Stdlib_format=global_data.Stdlib__format,
     Stdlib_list=global_data.Stdlib__list,
     Stdlib_int32=global_data.Stdlib__int32,
     Assert_failure=global_data.Assert_failure,
     Stdlib_string=global_data.Stdlib__string,
     Stdlib_int64=global_data.Stdlib__int64,
     Stdlib=global_data.Stdlib,
     Stdlib_filename=global_data.Stdlib__filename,
     Stdlib_array=global_data.Stdlib__array,
     Stdlib_bytes=global_data.Stdlib__bytes,
     Big_int=global_data.Big_int,
     Stdlib_scanf=global_data.Stdlib__scanf,
     Stdlib_map=global_data.Stdlib__map,
     Stdlib_set=global_data.Stdlib__set,
     Stdlib_printf=global_data.Stdlib__printf,
     Stdlib_lexing=global_data.Stdlib__lexing,
     Stdlib_buffer=global_data.Stdlib__buffer,
     Uutf=global_data.Uutf,
     _f_=[0,[2,0,0],caml_string_of_jsbytes("%s")],
     _g_=[0,[15,0],caml_string_of_jsbytes("%a")],
     _c_=runtime.caml_int64_create_lo_mi_hi(16777215,255,0),
     _b_=[0,caml_string_of_jsbytes("IO/utils.ml"),21,45],
     _a_=runtime.caml_int64_create_lo_mi_hi(0,16776960,65535),
     _h_=
      [0,
       caml_string_of_jsbytes("GAEM"),
       caml_string_of_jsbytes("GAME"),
       caml_string_of_jsbytes("GEAM"),
       caml_string_of_jsbytes("GEMA"),
       caml_string_of_jsbytes("GMAE"),
       caml_string_of_jsbytes("GMEA"),
       caml_string_of_jsbytes("AGEM"),
       caml_string_of_jsbytes("AGME"),
       caml_string_of_jsbytes("AEGM"),
       caml_string_of_jsbytes("AEMG"),
       caml_string_of_jsbytes("AMGE"),
       caml_string_of_jsbytes("AMEG"),
       caml_string_of_jsbytes("EGAM"),
       caml_string_of_jsbytes("EGMA"),
       caml_string_of_jsbytes("EAGM"),
       caml_string_of_jsbytes("EAMG"),
       caml_string_of_jsbytes("EMGA"),
       caml_string_of_jsbytes("EMAG"),
       caml_string_of_jsbytes("MGAE"),
       caml_string_of_jsbytes("MGEA"),
       caml_string_of_jsbytes("MAGE"),
       caml_string_of_jsbytes("MAEG"),
       caml_string_of_jsbytes("MEGA"),
       caml_string_of_jsbytes("MEAG")],
     _w_=[0,caml_string_of_jsbytes("Pokemon/seed.ml"),66,2],
     _o_=runtime.caml_int64_create_lo_mi_hi(12996205,65,0),
     _p_=runtime.caml_int64_create_lo_mi_hi(24691,0,0),
     _q_=runtime.caml_int64_create_lo_mi_hi(12184421,238,0),
     _r_=runtime.caml_int64_create_lo_mi_hi(3498401,10,0),
     _s_=runtime.caml_int64_create_lo_mi_hi(0,256,0),
     _t_=runtime.caml_int64_create_lo_mi_hi(12141755,833,0),
     _v_=runtime.caml_int64_create_lo_mi_hi(16777215,255,0),
     _z_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("Please enter your seed (use 0x prefix if hexadecimal): "),
        [17,2,0]],
       caml_string_of_jsbytes
        ("Please enter your seed (use 0x prefix if hexadecimal): @?")],
     _A_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("Do you want to obtain this seed using the freeze PRNG ACE code ?"),
        [17,4,0]],
       caml_string_of_jsbytes
        ("Do you want to obtain this seed using the freeze PRNG ACE code ?@.")],
     _B_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("1. Yes, for method H1 (wild pokemon) using sweet scent."),
        [17,4,0]],
       caml_string_of_jsbytes
        ("1. Yes, for method H1 (wild pokemon) using sweet scent.@.")],
     _C_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("2. Yes, for mass outbreaks (method H1, using sweet scent)."),
        [17,4,0]],
       caml_string_of_jsbytes
        ("2. Yes, for mass outbreaks (method H1, using sweet scent).@.")],
     _D_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("3. Yes, for method H1 (wild pokemon) using a rod."),
        [17,4,0]],
       caml_string_of_jsbytes
        ("3. Yes, for method H1 (wild pokemon) using a rod.@.")],
     _E_=
      [0,
       [11,
        caml_string_of_jsbytes("4. Yes, for method 1 (stationnary pokemon)."),
        [17,4,0]],
       caml_string_of_jsbytes("4. Yes, for method 1 (stationnary pokemon).@.")],
     _F_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("5. No, but please show me the seeds in the vicinity."),
        [17,4,0]],
       caml_string_of_jsbytes
        ("5. No, but please show me the seeds in the vicinity.@.")],
     _G_=
      [0,
       [11,caml_string_of_jsbytes("6. No (quit)."),[17,4,0]],
       caml_string_of_jsbytes("6. No (quit).@.")],
     _H_=
      [0,
       [11,caml_string_of_jsbytes("Cycle from seed 0: "),[5,12,0,0,[17,4,0]]],
       caml_string_of_jsbytes("Cycle from seed 0: %lu@.")],
     _I_=
      [0,
       [4,
        3,
        0,
        0,
        [11,
         caml_string_of_jsbytes(": "),
         [5,
          12,
          0,
          0,
          [11,caml_string_of_jsbytes(" ("),[5,7,0,0,[12,41,[17,4,0]]]]]]],
       caml_string_of_jsbytes("%i: %lu (%#lx)@.")],
     _J_=
      [0,
       [11,
        caml_string_of_jsbytes("Please enter the range (example: -25 5):"),
        [17,4,0]],
       caml_string_of_jsbytes("Please enter the range (example: -25 5):@.")],
     _K_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("For most legendaries, you should use the seed at cycle -3."),
        [17,4,0]],
       caml_string_of_jsbytes
        ("For most legendaries, you should use the seed at cycle -3.@.")],
     _L_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("Please refer to the instructions on the freeze PRNG ACE code for other stationnary pokemons."),
        [17,4,0]],
       caml_string_of_jsbytes
        ("Please refer to the instructions on the freeze PRNG ACE code for other stationnary pokemons.@.")],
     _M_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("You should start the battle as soon as you can"),
        0],
       caml_string_of_jsbytes
        ("You should start the battle as soon as you can")],
     _N_=
      [0,
       [11,
        caml_string_of_jsbytes
         (" (just after having executed the ACE and closed the menu)."),
        [17,4,0]],
       caml_string_of_jsbytes
        (" (just after having executed the ACE and closed the menu).@.")],
     _O_=
      [0,
       [11,
        caml_string_of_jsbytes("Please select your configuration:"),
        [17,4,0]],
       caml_string_of_jsbytes("Please select your configuration:@.")],
     _P_=
      [0,
       [11,
        caml_string_of_jsbytes("1. I will not be fishing on route 119."),
        [17,4,0]],
       caml_string_of_jsbytes("1. I will not be fishing on route 119.@.")],
     _Q_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("2. I will be fishing on route 119, but not for a feebas."),
        [17,4,0]],
       caml_string_of_jsbytes
        ("2. I will be fishing on route 119, but not for a feebas.@.")],
     _R_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("3. I will be fishing for feebas on a feebas tile."),
        [17,4,0]],
       caml_string_of_jsbytes
        ("3. I will be fishing for feebas on a feebas tile.@.")],
     _S_=
      [0,
       [11,
        caml_string_of_jsbytes("You should use the seed "),
        [5,
         7,
         0,
         0,
         [11,
          caml_string_of_jsbytes(" (1 cycle before your target)."),
          [17,4,0]]]],
       caml_string_of_jsbytes
        ("You should use the seed %#lx (1 cycle before your target).@.")],
     _T_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("You should use sweet scent directly after triggering the ACE,"),
        0],
       caml_string_of_jsbytes
        ("You should use sweet scent directly after triggering the ACE,")],
     _U_=
      [0,
       [11,
        caml_string_of_jsbytes(" without closing the pokemon menu."),
        [17,4,0]],
       caml_string_of_jsbytes(" without closing the pokemon menu.@.")],
     _V_=
      [0,
       [11,
        caml_string_of_jsbytes("You should use the seed "),
        [5,
         7,
         0,
         0,
         [11,
          caml_string_of_jsbytes(" (2 cycles before your target)."),
          [17,4,0]]]],
       caml_string_of_jsbytes
        ("You should use the seed %#lx (2 cycles before your target).@.")],
     _W_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("You should use sweet scent directly after triggering the ACE,"),
        0],
       caml_string_of_jsbytes
        ("You should use sweet scent directly after triggering the ACE,")],
     _X_=
      [0,
       [11,
        caml_string_of_jsbytes(" without closing the pokemon menu."),
        [17,4,0]],
       caml_string_of_jsbytes(" without closing the pokemon menu.@.")],
     _Y_=
      [0,
       [12,32,[4,3,0,0,[12,32,[4,3,0,0,0]]]],
       caml_string_of_jsbytes(" %i %i")],
     _ag_=[0,caml_string_of_jsbytes("Main/seed_tools_common.ml"),82,13],
     _aa_=[0,[2,0,[12,58,[17,4,0]]],caml_string_of_jsbytes("%s:@.")],
     _ab_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("\tWith lead: Must have Suction Cup or Sticky Hold lead"),
        [17,4,0]],
       caml_string_of_jsbytes
        ("\tWith lead: Must have Suction Cup or Sticky Hold lead@.")],
     _ac_=
      [0,
       [11,
        caml_string_of_jsbytes("\tUse seed "),
        [5,
         7,
         0,
         0,
         [11,
          caml_string_of_jsbytes(" to generate target on advancement "),
          [4,3,0,0,[17,4,0]]]]],
       caml_string_of_jsbytes
        ("\tUse seed %#lx to generate target on advancement %i@.")],
     _ad_=
      [0,
       [11,caml_string_of_jsbytes("\tWith lead: No lead necessary"),[17,4,0]],
       caml_string_of_jsbytes("\tWith lead: No lead necessary@.")],
     _ae_=
      [0,
       [11,
        caml_string_of_jsbytes("\tUse seed "),
        [5,
         7,
         0,
         0,
         [11,
          caml_string_of_jsbytes(" to generate target on advancement "),
          [4,3,0,0,[17,4,0]]]]],
       caml_string_of_jsbytes
        ("\tUse seed %#lx to generate target on advancement %i@.")],
     _af_=
      [0,
       [11,caml_string_of_jsbytes("\tNo matches found"),[17,4,0]],
       caml_string_of_jsbytes("\tNo matches found@.")],
     _Z_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("You should use the rod directly after triggering the ACE"),
        0],
       caml_string_of_jsbytes
        ("You should use the rod directly after triggering the ACE")],
     ___=
      [0,
       [11,
        caml_string_of_jsbytes(" (leave the pokemon menu and enter the bag)."),
        [17,4,0]],
       caml_string_of_jsbytes
        (" (leave the pokemon menu and enter the bag).@.")],
     _$_=
      [0,
       [11,caml_string_of_jsbytes("Thanks to Shao for this script."),[17,4,0]],
       caml_string_of_jsbytes("Thanks to Shao for this script.@.")],
     _ah_=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes(" = "),
         [5,
          3,
          0,
          0,
          [11,caml_string_of_jsbytes(" ("),[5,7,0,0,[12,41,[17,4,0]]]]]]],
       caml_string_of_jsbytes("%s = %li (%#lx)@.")],
     _ai_=[0,[17,4,0],caml_string_of_jsbytes("@.")],
     _aj_=
      [0,
       [11,caml_string_of_jsbytes("Please enter low-PID: "),[17,2,0]],
       caml_string_of_jsbytes("Please enter low-PID: @?")],
     _ak_=[0,[12,32,[5,3,0,0,0]],caml_string_of_jsbytes(" %li")],
     _al_=
      [0,
       [11,caml_string_of_jsbytes("Please enter high-PID: "),[17,2,0]],
       caml_string_of_jsbytes("Please enter high-PID: @?")],
     _am_=[0,[12,32,[5,3,0,0,0]],caml_string_of_jsbytes(" %li")],
     _an_=
      [0,
       [11,
        caml_string_of_jsbytes("Please enter original trainer visible TID: "),
        [17,2,0]],
       caml_string_of_jsbytes("Please enter original trainer visible TID: @?")],
     _ao_=[0,[12,32,[5,3,0,0,0]],caml_string_of_jsbytes(" %li")],
     _ap_=
      [0,
       [11,
        caml_string_of_jsbytes("Please enter original trainer secret TID: "),
        [17,2,0]],
       caml_string_of_jsbytes("Please enter original trainer secret TID: @?")],
     _aq_=[0,[12,32,[5,3,0,0,0]],caml_string_of_jsbytes(" %li")],
     _ar_=
      [0,
       [11,
        caml_string_of_jsbytes("Misc substructure position: "),
        [4,0,0,0,[17,4,0]]],
       caml_string_of_jsbytes("Misc substructure position: %d@.")],
     _as_=
      [0,
       [11,caml_string_of_jsbytes("IVEA offset: "),[4,7,0,0,[17,4,0]]],
       caml_string_of_jsbytes("IVEA offset: %#x@.")],
     _at_=
      [0,
       [11,caml_string_of_jsbytes("Please enter low-IVEA: "),[17,2,0]],
       caml_string_of_jsbytes("Please enter low-IVEA: @?")],
     _au_=[0,[12,32,[5,3,0,0,0]],caml_string_of_jsbytes(" %li")],
     _av_=
      [0,
       [11,caml_string_of_jsbytes("Please enter high-IVEA: "),[17,2,0]],
       caml_string_of_jsbytes("Please enter high-IVEA: @?")],
     _aw_=[0,[12,32,[5,3,0,0,0]],caml_string_of_jsbytes(" %li")],
     _ax_=
      [0,
       [11,
        caml_string_of_jsbytes("Unencrypted IVEA data: "),
        [5,7,0,0,[17,4,0]]],
       caml_string_of_jsbytes("Unencrypted IVEA data: %#lx@.")],
     _ay_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("Pokemon IVs (hp atk def speed sp_atk sp_def): "),
        [5,
         0,
         0,
         0,
         [12,
          32,
          [5,
           0,
           0,
           0,
           [12,32,[5,0,0,0,[12,32,[5,0,0,0,[12,32,[5,0,0,0,partial]]]]]]]]]],
       caml_string_of_jsbytes
        ("Pokemon IVs (hp atk def speed sp_atk sp_def): %ld %ld %ld %ld %ld %ld@.")],
     _az_=
      [0,
       [11,caml_string_of_jsbytes("Maxing IVs..."),[17,4,0]],
       caml_string_of_jsbytes("Maxing IVs...@.")],
     _aA_=
      [0,
       [11,
        caml_string_of_jsbytes("New unencrypted IVEA data: "),
        [5,7,0,0,[17,4,0]]],
       caml_string_of_jsbytes("New unencrypted IVEA data: %#lx@.")],
     _aB_=
      [0,
       [11,caml_string_of_jsbytes("New low-IVEA: "),[5,7,0,0,[17,4,0]]],
       caml_string_of_jsbytes("New low-IVEA: %#lx@.")],
     _aC_=
      [0,
       [11,caml_string_of_jsbytes("New high-IVEA: "),[5,7,0,0,[17,4,0]]],
       caml_string_of_jsbytes("New high-IVEA: %#lx@.")],
     _aD_=
      [0,
       [11,caml_string_of_jsbytes("Checksum diff: "),[5,7,0,0,[17,4,0]]],
       caml_string_of_jsbytes("Checksum diff: %#lx@.")],
     _aH_=[0,caml_string_of_jsbytes("ARM/arm.ml"),240,9],
     _aE_=[0,1,0],
     _aF_=[0,1,1],
     _aG_=[0,0,0],
     _aI_=
      [0,
       [2,caml_string_of_jsbytes("_")],
       [1,caml_string_of_jsbytes("\xc3\x80")],
       [1,caml_string_of_jsbytes("\xc3\x81")],
       [1,caml_string_of_jsbytes("\xc3\x82")],
       [1,caml_string_of_jsbytes("\xc3\x87")],
       [1,caml_string_of_jsbytes("\xc3\x88")],
       [1,caml_string_of_jsbytes("\xc3\x89")],
       [1,caml_string_of_jsbytes("\xc3\x8a")],
       [1,caml_string_of_jsbytes("\xc3\x8b")],
       [1,caml_string_of_jsbytes("\xc3\x8c")],
       0,
       [1,caml_string_of_jsbytes("\xc3\x8e")],
       [1,caml_string_of_jsbytes("\xc3\x8f")],
       [1,caml_string_of_jsbytes("\xc3\x92")],
       [1,caml_string_of_jsbytes("\xc3\x93")],
       [1,caml_string_of_jsbytes("\xc3\x94")],
       [1,caml_string_of_jsbytes("\xc5\x92")],
       [1,caml_string_of_jsbytes("\xc3\x99")],
       [1,caml_string_of_jsbytes("\xc3\x9a")],
       [1,caml_string_of_jsbytes("\xc3\x9b")],
       [1,caml_string_of_jsbytes("\xc3\x91")],
       [1,caml_string_of_jsbytes("\xc3\x9f")],
       [1,caml_string_of_jsbytes("\xc3\xa0")],
       [1,caml_string_of_jsbytes("\xc3\xa1")],
       0,
       [1,caml_string_of_jsbytes("\xc3\xa7")],
       [1,caml_string_of_jsbytes("\xc3\xa8")],
       [1,caml_string_of_jsbytes("\xc3\xa9")],
       [1,caml_string_of_jsbytes("\xc3\xaa")],
       [1,caml_string_of_jsbytes("\xc3\xab")],
       [1,caml_string_of_jsbytes("\xc3\xac")],
       0,
       [1,caml_string_of_jsbytes("\xc3\xae")],
       [1,caml_string_of_jsbytes("\xc3\xaf")],
       [1,caml_string_of_jsbytes("\xc3\xb2")],
       [1,caml_string_of_jsbytes("\xc3\xb3")],
       [1,caml_string_of_jsbytes("\xc3\xb4")],
       [1,caml_string_of_jsbytes("\xc5\x93")],
       [1,caml_string_of_jsbytes("\xc3\xb9")],
       [1,caml_string_of_jsbytes("\xc3\xba")],
       [1,caml_string_of_jsbytes("\xc3\xbb")],
       [1,caml_string_of_jsbytes("\xc3\xb1")],
       [1,caml_string_of_jsbytes("\xc2\xba")],
       [1,caml_string_of_jsbytes("\xc2\xaa")],
       [1,caml_string_of_jsbytes("\xe1\xb5\x89\xca\xb3")],
       [1,caml_string_of_jsbytes("&")],
       [1,caml_string_of_jsbytes("+")],
       0,
       0,
       0,
       0,
       0,
       [1,caml_string_of_jsbytes("Lv")],
       [1,caml_string_of_jsbytes("=")],
       [1,caml_string_of_jsbytes(";")],
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       [1,caml_string_of_jsbytes("\xe2\x96\xaf")],
       [1,caml_string_of_jsbytes("\xc2\xbf")],
       [1,caml_string_of_jsbytes("\xc2\xa1")],
       [1,caml_string_of_jsbytes("PK")],
       [1,caml_string_of_jsbytes("MN")],
       [1,caml_string_of_jsbytes("PO")],
       [1,caml_string_of_jsbytes("K\xc3\xa9")],
       [0,caml_string_of_jsbytes("0x57")],
       [0,caml_string_of_jsbytes("0x58")],
       [0,caml_string_of_jsbytes("0x59")],
       [1,caml_string_of_jsbytes("\xc3\x8d")],
       [1,caml_string_of_jsbytes("%")],
       [1,caml_string_of_jsbytes("(")],
       [1,caml_string_of_jsbytes(")")],
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       [1,caml_string_of_jsbytes("\xc3\xa2")],
       0,
       0,
       0,
       0,
       0,
       0,
       [1,caml_string_of_jsbytes("\xc3\xad")],
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       [1,caml_string_of_jsbytes("\xe2\xac\x86")],
       [1,caml_string_of_jsbytes("\xe2\xac\x87")],
       [1,caml_string_of_jsbytes("\xe2\xac\x85")],
       [1,caml_string_of_jsbytes("\xe2\x9e\xa1")],
       [1,caml_string_of_jsbytes("*")],
       [1,caml_string_of_jsbytes("*")],
       [1,caml_string_of_jsbytes("*")],
       [1,caml_string_of_jsbytes("*")],
       [1,caml_string_of_jsbytes("*")],
       [1,caml_string_of_jsbytes("*")],
       [1,caml_string_of_jsbytes("*")],
       [1,caml_string_of_jsbytes("\xe1\xb5\x89")],
       [1,caml_string_of_jsbytes("<")],
       [1,caml_string_of_jsbytes(">")],
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       [1,caml_string_of_jsbytes("\xca\xb3\xe1\xb5\x89")],
       [2,caml_string_of_jsbytes("0")],
       [2,caml_string_of_jsbytes("1")],
       [2,caml_string_of_jsbytes("2")],
       [2,caml_string_of_jsbytes("3")],
       [2,caml_string_of_jsbytes("4")],
       [2,caml_string_of_jsbytes("5")],
       [2,caml_string_of_jsbytes("6")],
       [2,caml_string_of_jsbytes("7")],
       [2,caml_string_of_jsbytes("8")],
       [2,caml_string_of_jsbytes("9")],
       [2,caml_string_of_jsbytes("!")],
       [2,caml_string_of_jsbytes("?")],
       [2,caml_string_of_jsbytes(".")],
       [2,caml_string_of_jsbytes("\xe2\x80\x93")],
       [1,caml_string_of_jsbytes("\xe3\x83\xbb")],
       [2,caml_string_of_jsbytes("\xe2\x80\xa6")],
       [2,caml_string_of_jsbytes("\xe2\x80\x9c")],
       [2,caml_string_of_jsbytes("\xe2\x80\x9d")],
       [2,caml_string_of_jsbytes("\xe2\x80\x98")],
       [2,caml_string_of_jsbytes("\xe2\x80\x99")],
       [2,caml_string_of_jsbytes("\xe2\x99\x82")],
       [2,caml_string_of_jsbytes("\xe2\x99\x80")],
       [1,caml_string_of_jsbytes("Pk$")],
       [2,caml_string_of_jsbytes(",")],
       [1,caml_string_of_jsbytes("\xc3\x97")],
       [2,caml_string_of_jsbytes("/")],
       [2,caml_string_of_jsbytes("A")],
       [2,caml_string_of_jsbytes("B")],
       [2,caml_string_of_jsbytes("C")],
       [2,caml_string_of_jsbytes("D")],
       [2,caml_string_of_jsbytes("E")],
       [2,caml_string_of_jsbytes("F")],
       [2,caml_string_of_jsbytes("G")],
       [2,caml_string_of_jsbytes("H")],
       [2,caml_string_of_jsbytes("I")],
       [2,caml_string_of_jsbytes("J")],
       [2,caml_string_of_jsbytes("K")],
       [2,caml_string_of_jsbytes("L")],
       [2,caml_string_of_jsbytes("M")],
       [2,caml_string_of_jsbytes("N")],
       [2,caml_string_of_jsbytes("O")],
       [2,caml_string_of_jsbytes("P")],
       [2,caml_string_of_jsbytes("Q")],
       [2,caml_string_of_jsbytes("R")],
       [2,caml_string_of_jsbytes("S")],
       [2,caml_string_of_jsbytes("T")],
       [2,caml_string_of_jsbytes("U")],
       [2,caml_string_of_jsbytes("V")],
       [2,caml_string_of_jsbytes("W")],
       [2,caml_string_of_jsbytes("X")],
       [2,caml_string_of_jsbytes("Y")],
       [2,caml_string_of_jsbytes("Z")],
       [2,caml_string_of_jsbytes("a")],
       [2,caml_string_of_jsbytes("b")],
       [2,caml_string_of_jsbytes("c")],
       [2,caml_string_of_jsbytes("d")],
       [2,caml_string_of_jsbytes("e")],
       [2,caml_string_of_jsbytes("f")],
       [2,caml_string_of_jsbytes("g")],
       [2,caml_string_of_jsbytes("h")],
       [2,caml_string_of_jsbytes("i")],
       [2,caml_string_of_jsbytes("j")],
       [2,caml_string_of_jsbytes("k")],
       [2,caml_string_of_jsbytes("l")],
       [2,caml_string_of_jsbytes("m")],
       [2,caml_string_of_jsbytes("n")],
       [2,caml_string_of_jsbytes("o")],
       [2,caml_string_of_jsbytes("p")],
       [2,caml_string_of_jsbytes("q")],
       [2,caml_string_of_jsbytes("r")],
       [2,caml_string_of_jsbytes("s")],
       [2,caml_string_of_jsbytes("t")],
       [2,caml_string_of_jsbytes("u")],
       [2,caml_string_of_jsbytes("v")],
       [2,caml_string_of_jsbytes("w")],
       [2,caml_string_of_jsbytes("x")],
       [2,caml_string_of_jsbytes("y")],
       [2,caml_string_of_jsbytes("z")],
       [1,caml_string_of_jsbytes("\xe2\x96\xb6")],
       [1,caml_string_of_jsbytes(":")],
       [1,caml_string_of_jsbytes("\xc3\x84")],
       [1,caml_string_of_jsbytes("\xc3\x96")],
       [1,caml_string_of_jsbytes("\xc3\x9c")],
       [1,caml_string_of_jsbytes("\xc3\xa4")],
       [1,caml_string_of_jsbytes("\xc3\xb6")],
       [1,caml_string_of_jsbytes("\xc3\xbc")],
       0,
       0,
       0,
       [0,caml_string_of_jsbytes("0xFA")],
       [0,caml_string_of_jsbytes("0xFB")],
       [0,caml_string_of_jsbytes("0xFC")],
       [0,caml_string_of_jsbytes("0xFD")],
       [0,caml_string_of_jsbytes("0xFE")],
       [0,caml_string_of_jsbytes("0xFF")]],
     _aJ_=[2,caml_string_of_jsbytes("\xe2\x80\x9e")],
     _aK_=[2,caml_string_of_jsbytes("\xe2\x80\x9c")],
     _aL_=[2,caml_string_of_jsbytes("\xc2\xab")],
     _aM_=[2,caml_string_of_jsbytes("\xc2\xbb")],
     _aN_=
      [0,
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("\xe3\x81\x82")],
       [2,caml_string_of_jsbytes("\xe3\x81\x84")],
       [2,caml_string_of_jsbytes("\xe3\x81\x86")],
       [2,caml_string_of_jsbytes("\xe3\x81\x88")],
       [2,caml_string_of_jsbytes("\xe3\x81\x8a")],
       [2,caml_string_of_jsbytes("\xe3\x81\x8b")],
       [2,caml_string_of_jsbytes("\xe3\x81\x8d")],
       [2,caml_string_of_jsbytes("\xe3\x81\x8f")],
       [2,caml_string_of_jsbytes("\xe3\x81\x91")],
       [2,caml_string_of_jsbytes("\xe3\x81\x93")],
       [2,caml_string_of_jsbytes("\xe3\x81\x95")],
       [2,caml_string_of_jsbytes("\xe3\x81\x97")],
       [2,caml_string_of_jsbytes("\xe3\x81\x99")],
       [2,caml_string_of_jsbytes("\xe3\x81\x9b")],
       [2,caml_string_of_jsbytes("\xe3\x81\x9d")],
       [2,caml_string_of_jsbytes("\xe3\x81\x9f")],
       [2,caml_string_of_jsbytes("\xe3\x81\xa1")],
       [2,caml_string_of_jsbytes("\xe3\x81\xa4")],
       [2,caml_string_of_jsbytes("\xe3\x81\xa6")],
       [2,caml_string_of_jsbytes("\xe3\x81\xa8")],
       [2,caml_string_of_jsbytes("\xe3\x81\xaa")],
       [2,caml_string_of_jsbytes("\xe3\x81\xab")],
       [2,caml_string_of_jsbytes("\xe3\x81\xac")],
       [2,caml_string_of_jsbytes("\xe3\x81\xad")],
       [2,caml_string_of_jsbytes("\xe3\x81\xae")],
       [2,caml_string_of_jsbytes("\xe3\x81\xaf")],
       [2,caml_string_of_jsbytes("\xe3\x81\xb2")],
       [2,caml_string_of_jsbytes("\xe3\x81\xb5")],
       [2,caml_string_of_jsbytes("\xe3\x81\xb8")],
       [2,caml_string_of_jsbytes("\xe3\x81\xbb")],
       [2,caml_string_of_jsbytes("\xe3\x81\xbe")],
       [2,caml_string_of_jsbytes("\xe3\x81\xbf")],
       [2,caml_string_of_jsbytes("\xe3\x82\x80")],
       [2,caml_string_of_jsbytes("\xe3\x82\x81")],
       [2,caml_string_of_jsbytes("\xe3\x82\x82")],
       [2,caml_string_of_jsbytes("\xe3\x82\x84")],
       [2,caml_string_of_jsbytes("\xe3\x82\x86")],
       [2,caml_string_of_jsbytes("\xe3\x82\x88")],
       [2,caml_string_of_jsbytes("\xe3\x82\x89")],
       [2,caml_string_of_jsbytes("\xe3\x82\x8a")],
       [2,caml_string_of_jsbytes("\xe3\x82\x8b")],
       [2,caml_string_of_jsbytes("\xe3\x82\x8c")],
       [2,caml_string_of_jsbytes("\xe3\x82\x8d")],
       [2,caml_string_of_jsbytes("\xe3\x82\x8f")],
       [2,caml_string_of_jsbytes("\xe3\x82\x92")],
       [2,caml_string_of_jsbytes("\xe3\x82\x93")],
       [2,caml_string_of_jsbytes("\xe3\x81\x81")],
       [2,caml_string_of_jsbytes("\xe3\x81\x83")],
       [2,caml_string_of_jsbytes("\xe3\x81\x85")],
       [2,caml_string_of_jsbytes("\xe3\x81\x87")],
       [2,caml_string_of_jsbytes("\xe3\x81\x89")],
       [2,caml_string_of_jsbytes("\xe3\x82\x83")],
       [2,caml_string_of_jsbytes("\xe3\x82\x85")],
       [2,caml_string_of_jsbytes("\xe3\x82\x87")],
       [2,caml_string_of_jsbytes("\xe3\x81\x8c")],
       [2,caml_string_of_jsbytes("\xe3\x81\x8e")],
       [2,caml_string_of_jsbytes("\xe3\x81\x90")],
       [2,caml_string_of_jsbytes("\xe3\x81\x92")],
       [2,caml_string_of_jsbytes("\xe3\x81\x94")],
       [2,caml_string_of_jsbytes("\xe3\x81\x96")],
       [2,caml_string_of_jsbytes("\xe3\x81\x98")],
       [2,caml_string_of_jsbytes("\xe3\x81\x9a")],
       [2,caml_string_of_jsbytes("\xe3\x81\x9c")],
       [2,caml_string_of_jsbytes("\xe3\x81\x9e")],
       [2,caml_string_of_jsbytes("\xe3\x81\xa0")],
       [2,caml_string_of_jsbytes("\xe3\x81\xa2")],
       [2,caml_string_of_jsbytes("\xe3\x81\xa5")],
       [2,caml_string_of_jsbytes("\xe3\x81\xa7")],
       [2,caml_string_of_jsbytes("\xe3\x81\xa9")],
       [2,caml_string_of_jsbytes("\xe3\x81\xb0")],
       [2,caml_string_of_jsbytes("\xe3\x81\xb3")],
       [2,caml_string_of_jsbytes("\xe3\x81\xb6")],
       [2,caml_string_of_jsbytes("\xe3\x81\xb9")],
       [2,caml_string_of_jsbytes("\xe3\x81\xbc")],
       [2,caml_string_of_jsbytes("\xe3\x81\xb1")],
       [2,caml_string_of_jsbytes("\xe3\x81\xb4")],
       [2,caml_string_of_jsbytes("\xe3\x81\xb7")],
       [2,caml_string_of_jsbytes("\xe3\x81\xba")],
       [2,caml_string_of_jsbytes("\xe3\x81\xbd")],
       [2,caml_string_of_jsbytes("\xe3\x81\xa3")],
       [2,caml_string_of_jsbytes("\xe3\x82\xa2")],
       [2,caml_string_of_jsbytes("\xe3\x82\xa4")],
       [2,caml_string_of_jsbytes("\xe3\x82\xa6")],
       [2,caml_string_of_jsbytes("\xe3\x82\xa8")],
       [2,caml_string_of_jsbytes("\xe3\x82\xaa")],
       [2,caml_string_of_jsbytes("\xe3\x82\xab")],
       [2,caml_string_of_jsbytes("\xe3\x82\xad")],
       [2,caml_string_of_jsbytes("\xe3\x82\xaf")],
       [2,caml_string_of_jsbytes("\xe3\x82\xb1")],
       [2,caml_string_of_jsbytes("\xe3\x82\xb3")],
       [2,caml_string_of_jsbytes("\xe3\x82\xb5")],
       [2,caml_string_of_jsbytes("\xe3\x82\xb7")],
       [2,caml_string_of_jsbytes("\xe3\x82\xb9")],
       [2,caml_string_of_jsbytes("\xe3\x82\xbb")],
       [2,caml_string_of_jsbytes("\xe3\x82\xbd")],
       [2,caml_string_of_jsbytes("\xe3\x82\xbf")],
       [2,caml_string_of_jsbytes("\xe3\x83\x81")],
       [2,caml_string_of_jsbytes("\xe3\x83\x84")],
       [2,caml_string_of_jsbytes("\xe3\x83\x86")],
       [2,caml_string_of_jsbytes("\xe3\x83\x88")],
       [2,caml_string_of_jsbytes("\xe3\x83\x8a")],
       [2,caml_string_of_jsbytes("\xe3\x83\x8b")],
       [2,caml_string_of_jsbytes("\xe3\x83\x8c")],
       [2,caml_string_of_jsbytes("\xe3\x83\x8d")],
       [2,caml_string_of_jsbytes("\xe3\x83\x8e")],
       [2,caml_string_of_jsbytes("\xe3\x83\x8f")],
       [2,caml_string_of_jsbytes("\xe3\x83\x92")],
       [2,caml_string_of_jsbytes("\xe3\x83\x95")],
       [2,caml_string_of_jsbytes("\xe3\x83\x98")],
       [2,caml_string_of_jsbytes("\xe3\x83\x9b")],
       [2,caml_string_of_jsbytes("\xe3\x83\x9e")],
       [2,caml_string_of_jsbytes("\xe3\x83\x9f")],
       [2,caml_string_of_jsbytes("\xe3\x83\xa0")],
       [2,caml_string_of_jsbytes("\xe3\x83\xa1")],
       [2,caml_string_of_jsbytes("\xe3\x83\xa2")],
       [2,caml_string_of_jsbytes("\xe3\x83\xa4")],
       [2,caml_string_of_jsbytes("\xe3\x83\xa6")],
       [2,caml_string_of_jsbytes("\xe3\x83\xa8")],
       [2,caml_string_of_jsbytes("\xe3\x83\xa9")],
       [2,caml_string_of_jsbytes("\xe3\x83\xaa")],
       [2,caml_string_of_jsbytes("\xe3\x83\xab")],
       [2,caml_string_of_jsbytes("\xe3\x83\xac")],
       [2,caml_string_of_jsbytes("\xe3\x83\xad")],
       [2,caml_string_of_jsbytes("\xe3\x83\xaf")],
       [2,caml_string_of_jsbytes("\xe3\x83\xb2")],
       [2,caml_string_of_jsbytes("\xe3\x83\xb3")],
       [2,caml_string_of_jsbytes("\xe3\x82\xa1")],
       [2,caml_string_of_jsbytes("\xe3\x82\xa3")],
       [2,caml_string_of_jsbytes("\xe3\x82\xa5")],
       [2,caml_string_of_jsbytes("\xe3\x82\xa7")],
       [2,caml_string_of_jsbytes("\xe3\x82\xa9")],
       [2,caml_string_of_jsbytes("\xe3\x83\xa3")],
       [2,caml_string_of_jsbytes("\xe3\x83\xa5")],
       [2,caml_string_of_jsbytes("\xe3\x83\xa7")],
       [2,caml_string_of_jsbytes("\xe3\x82\xac")],
       [2,caml_string_of_jsbytes("\xe3\x82\xae")],
       [2,caml_string_of_jsbytes("\xe3\x82\xb0")],
       [2,caml_string_of_jsbytes("\xe3\x82\xb2")],
       [2,caml_string_of_jsbytes("\xe3\x82\xb4")],
       [2,caml_string_of_jsbytes("\xe3\x82\xb6")],
       [2,caml_string_of_jsbytes("\xe3\x82\xb8")],
       [2,caml_string_of_jsbytes("\xe3\x82\xba")],
       [2,caml_string_of_jsbytes("\xe3\x82\xbc")],
       [2,caml_string_of_jsbytes("\xe3\x82\xbe")],
       [2,caml_string_of_jsbytes("\xe3\x83\x80")],
       [2,caml_string_of_jsbytes("\xe3\x83\x82")],
       [2,caml_string_of_jsbytes("\xe3\x83\x85")],
       [2,caml_string_of_jsbytes("\xe3\x83\x87")],
       [2,caml_string_of_jsbytes("\xe3\x83\x89")],
       [2,caml_string_of_jsbytes("\xe3\x83\x90")],
       [2,caml_string_of_jsbytes("\xe3\x83\x93")],
       [2,caml_string_of_jsbytes("\xe3\x83\x96")],
       [2,caml_string_of_jsbytes("\xe3\x83\x99")],
       [2,caml_string_of_jsbytes("\xe3\x83\x9c")],
       [2,caml_string_of_jsbytes("\xe3\x83\x91")],
       [2,caml_string_of_jsbytes("\xe3\x83\x94")],
       [2,caml_string_of_jsbytes("\xe3\x83\x97")],
       [2,caml_string_of_jsbytes("\xe3\x83\x9a")],
       [2,caml_string_of_jsbytes("\xe3\x83\x9d")],
       [2,caml_string_of_jsbytes("\xe3\x83\x83")],
       [2,caml_string_of_jsbytes("0")],
       [2,caml_string_of_jsbytes("1")],
       [2,caml_string_of_jsbytes("2")],
       [2,caml_string_of_jsbytes("3")],
       [2,caml_string_of_jsbytes("4")],
       [2,caml_string_of_jsbytes("5")],
       [2,caml_string_of_jsbytes("6")],
       [2,caml_string_of_jsbytes("7")],
       [2,caml_string_of_jsbytes("8")],
       [2,caml_string_of_jsbytes("9")],
       [2,caml_string_of_jsbytes("\xef\xbc\x81")],
       [2,caml_string_of_jsbytes("\xef\xbc\x9f")],
       [2,caml_string_of_jsbytes("\xe3\x80\x82")],
       [2,caml_string_of_jsbytes("\xe3\x83\xbc")],
       [2,caml_string_of_jsbytes("\xe3\x83\xbb")],
       [2,caml_string_of_jsbytes("\xe2\x80\xa5")],
       [2,caml_string_of_jsbytes("\xe3\x80\x8e")],
       [2,caml_string_of_jsbytes("\xe3\x80\x8f")],
       [2,caml_string_of_jsbytes("\xe3\x80\x8c")],
       [2,caml_string_of_jsbytes("\xe3\x80\x8d")],
       [2,caml_string_of_jsbytes("\xe2\x99\x82")],
       [2,caml_string_of_jsbytes("\xe2\x99\x80")],
       [1,caml_string_of_jsbytes("\xe5\x86\x86")],
       [1,caml_string_of_jsbytes(".")],
       [1,caml_string_of_jsbytes("\xc3\x97")],
       [2,caml_string_of_jsbytes("/")],
       [2,caml_string_of_jsbytes("A")],
       [2,caml_string_of_jsbytes("B")],
       [2,caml_string_of_jsbytes("C")],
       [2,caml_string_of_jsbytes("D")],
       [2,caml_string_of_jsbytes("E")],
       [2,caml_string_of_jsbytes("F")],
       [2,caml_string_of_jsbytes("G")],
       [2,caml_string_of_jsbytes("H")],
       [2,caml_string_of_jsbytes("I")],
       [2,caml_string_of_jsbytes("J")],
       [2,caml_string_of_jsbytes("K")],
       [2,caml_string_of_jsbytes("L")],
       [2,caml_string_of_jsbytes("M")],
       [2,caml_string_of_jsbytes("N")],
       [2,caml_string_of_jsbytes("O")],
       [2,caml_string_of_jsbytes("P")],
       [2,caml_string_of_jsbytes("Q")],
       [2,caml_string_of_jsbytes("R")],
       [2,caml_string_of_jsbytes("S")],
       [2,caml_string_of_jsbytes("T")],
       [2,caml_string_of_jsbytes("U")],
       [2,caml_string_of_jsbytes("V")],
       [2,caml_string_of_jsbytes("W")],
       [2,caml_string_of_jsbytes("X")],
       [2,caml_string_of_jsbytes("Y")],
       [2,caml_string_of_jsbytes("Z")],
       [2,caml_string_of_jsbytes("a")],
       [2,caml_string_of_jsbytes("b")],
       [2,caml_string_of_jsbytes("c")],
       [2,caml_string_of_jsbytes("d")],
       [2,caml_string_of_jsbytes("e")],
       [2,caml_string_of_jsbytes("f")],
       [2,caml_string_of_jsbytes("g")],
       [2,caml_string_of_jsbytes("h")],
       [2,caml_string_of_jsbytes("i")],
       [2,caml_string_of_jsbytes("j")],
       [2,caml_string_of_jsbytes("k")],
       [2,caml_string_of_jsbytes("l")],
       [2,caml_string_of_jsbytes("m")],
       [2,caml_string_of_jsbytes("n")],
       [2,caml_string_of_jsbytes("o")],
       [2,caml_string_of_jsbytes("p")],
       [2,caml_string_of_jsbytes("q")],
       [2,caml_string_of_jsbytes("r")],
       [2,caml_string_of_jsbytes("s")],
       [2,caml_string_of_jsbytes("t")],
       [2,caml_string_of_jsbytes("u")],
       [2,caml_string_of_jsbytes("v")],
       [2,caml_string_of_jsbytes("w")],
       [2,caml_string_of_jsbytes("x")],
       [2,caml_string_of_jsbytes("y")],
       [2,caml_string_of_jsbytes("z")],
       [1,caml_string_of_jsbytes("\xe2\x96\xb6")],
       [1,caml_string_of_jsbytes(":")],
       [1,caml_string_of_jsbytes("\xc3\x84")],
       [1,caml_string_of_jsbytes("\xc3\x96")],
       [1,caml_string_of_jsbytes("\xc3\x9c")],
       [1,caml_string_of_jsbytes("\xc3\xa4")],
       [1,caml_string_of_jsbytes("\xc3\xb6")],
       [1,caml_string_of_jsbytes("\xc3\xbc")],
       0,
       0,
       0,
       [0,caml_string_of_jsbytes("0xFA")],
       [0,caml_string_of_jsbytes("0xFB")],
       [0,caml_string_of_jsbytes("0xFC")],
       [0,caml_string_of_jsbytes("0xFD")],
       [0,caml_string_of_jsbytes("0xFE")],
       [0,caml_string_of_jsbytes("0xFF")]],
     _aQ_=[0,[2,0,0],caml_string_of_jsbytes("%s")],
     _aP_=[0,[2,0,[2,0,0]],caml_string_of_jsbytes("%s%s")],
     _aO_=[0,caml_string_of_jsbytes("Boxes/name.ml"),34,9],
     _a0_=[0,caml_string_of_jsbytes("ARM/optimizer.ml"),202,11],
     _aZ_=[0,caml_string_of_jsbytes("ARM/optimizer.ml"),177,11],
     _aY_=[0,65536,65536,65536,512,64,8,1],
     _bp_=[0,0,0,1,0],
     _bq_=[0,0,0,0,1],
     _bn_=[0,caml_string_of_jsbytes("S")],
     _bo_=[0,caml_string_of_jsbytes("L")],
     _bk_=[0,3],
     _bl_=[0,1],
     _bm_=[0,6],
     _bg_=[0,4],
     _bh_=[0,5],
     _bi_=[0,2],
     _bj_=[0,0],
     _a__=[0,3],
     _a$_=[0,10],
     _ba_=[0,14],
     _bb_=[0,12],
     _bc_=[0,0],
     _bd_=[0,2],
     _be_=[0,4],
     _bf_=[0,16],
     _a1_=[0,8],
     _a2_=[0,9],
     _a3_=[0,7],
     _a4_=[0,1],
     _a5_=[0,6],
     _a6_=[0,13],
     _a7_=[0,11],
     _a8_=[0,5],
     _a9_=[0,15],
     _br_=[0,caml_string_of_jsbytes("IO/parser.ml"),143,8],
     _bs_=[0,caml_string_of_jsbytes("IO/parser.ml"),167,8],
     _bt_=[0,caml_string_of_jsbytes("IO/parser.ml"),191,8],
     _bu_=[0,caml_string_of_jsbytes("IO/parser.ml"),215,8],
     _bv_=[0,caml_string_of_jsbytes("IO/parser.ml"),239,8],
     _bw_=[0,caml_string_of_jsbytes("IO/parser.ml"),263,8],
     _bx_=[0,caml_string_of_jsbytes("IO/parser.ml"),287,8],
     _by_=[0,caml_string_of_jsbytes("IO/parser.ml"),311,8],
     _bz_=[0,caml_string_of_jsbytes("IO/parser.ml"),335,8],
     _bA_=[0,caml_string_of_jsbytes("IO/parser.ml"),359,8],
     _bB_=[0,caml_string_of_jsbytes("IO/parser.ml"),383,8],
     _bC_=[0,caml_string_of_jsbytes("IO/parser.ml"),407,8],
     _bD_=[0,caml_string_of_jsbytes("IO/parser.ml"),431,8],
     _bE_=[0,caml_string_of_jsbytes("IO/parser.ml"),455,8],
     _bF_=[0,caml_string_of_jsbytes("IO/parser.ml"),479,8],
     _bG_=[0,caml_string_of_jsbytes("IO/parser.ml"),503,8],
     _bH_=[0,caml_string_of_jsbytes("IO/parser.ml"),540,16],
     _bI_=[0,caml_string_of_jsbytes("IO/parser.ml"),546,12],
     _bJ_=[0,caml_string_of_jsbytes("IO/parser.ml"),1320,8],
     _bK_=[0,caml_string_of_jsbytes("IO/parser.ml"),1367,12],
     _bL_=[0,caml_string_of_jsbytes("IO/parser.ml"),1266,8],
     _bM_=[0,caml_string_of_jsbytes("IO/parser.ml"),1313,12],
     _bN_=[0,caml_string_of_jsbytes("IO/parser.ml"),1139,8],
     _bO_=[0,caml_string_of_jsbytes("IO/parser.ml"),1176,12],
     _bP_=[0,caml_string_of_jsbytes("IO/parser.ml"),1093,8],
     _bQ_=[0,caml_string_of_jsbytes("IO/parser.ml"),1132,12],
     _bR_=[0,caml_string_of_jsbytes("IO/parser.ml"),1043,8],
     _bS_=[0,caml_string_of_jsbytes("IO/parser.ml"),1086,12],
     _bT_=[0,caml_string_of_jsbytes("IO/parser.ml"),979,8],
     _bV_=[0,caml_string_of_jsbytes("IO/parser.ml"),1008,16],
     _bU_=[0,caml_string_of_jsbytes("IO/parser.ml"),1036,12],
     _bW_=[0,caml_string_of_jsbytes("IO/parser.ml"),937,8],
     _bX_=[0,caml_string_of_jsbytes("IO/parser.ml"),972,12],
     _bY_=[0,caml_string_of_jsbytes("IO/parser.ml"),899,8],
     _bZ_=[0,caml_string_of_jsbytes("IO/parser.ml"),930,12],
     _b0_=[0,caml_string_of_jsbytes("IO/parser.ml"),865,8],
     _b1_=[0,caml_string_of_jsbytes("IO/parser.ml"),892,12],
     _b2_=[0,caml_string_of_jsbytes("IO/parser.ml"),835,8],
     _b3_=[0,caml_string_of_jsbytes("IO/parser.ml"),858,12],
     _b4_=[0,caml_string_of_jsbytes("IO/parser.ml"),801,8],
     _b5_=[0,caml_string_of_jsbytes("IO/parser.ml"),828,12],
     _b6_=[0,caml_string_of_jsbytes("IO/parser.ml"),775,8],
     _b7_=[0,caml_string_of_jsbytes("IO/parser.ml"),794,12],
     _b8_=[0,caml_string_of_jsbytes("IO/parser.ml"),729,8],
     _b9_=[0,caml_string_of_jsbytes("IO/parser.ml"),748,12],
     _b__=[0,caml_string_of_jsbytes("IO/parser.ml"),699,8],
     _b$_=[0,caml_string_of_jsbytes("IO/parser.ml"),722,12],
     _ca_=[0,caml_string_of_jsbytes("IO/parser.ml"),649,8],
     _cb_=[0,caml_string_of_jsbytes("IO/parser.ml"),682,12],
     _cc_=[0,caml_string_of_jsbytes("IO/parser.ml"),597,8],
     _cd_=[0,caml_string_of_jsbytes("IO/parser.ml"),642,12],
     _ce_=[0,caml_string_of_jsbytes("IO/parser.ml"),1213,8],
     _cf_=[0,caml_string_of_jsbytes("IO/parser.ml"),1259,12],
     _cg_=[0,caml_string_of_jsbytes("IO/parser.ml"),1379,4],
     _ch_=[0,caml_string_of_jsbytes("IO/parser.ml"),1402,12],
     _ci_=[0,caml_string_of_jsbytes("IO/parser.ml"),1406,8],
     _cj_=[0,caml_string_of_jsbytes("IO/parser.ml"),1554,8],
     _ck_=[0,caml_string_of_jsbytes("IO/parser.ml"),1588,8],
     _cm_=[0,caml_string_of_jsbytes("IO/parser.ml"),1650,12],
     _cn_=[0,caml_string_of_jsbytes("IO/parser.ml"),1633,12],
     _cl_=[0,caml_string_of_jsbytes("IO/parser.ml"),1654,8],
     _co_=[0,caml_string_of_jsbytes("IO/parser.ml"),1662,4],
     _cq_=[0,caml_string_of_jsbytes("IO/parser.ml"),1681,12],
     _cp_=[0,caml_string_of_jsbytes("IO/parser.ml"),1694,8],
     _cr_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("Internal failure -- please contact the parser generator's developers.\n"),
        [10,0]],
       caml_string_of_jsbytes
        ("Internal failure -- please contact the parser generator's developers.\n%!")],
     _cs_=[0,caml_string_of_jsbytes("IO/parser.ml"),1703,4],
     _ct_=[0,caml_string_of_jsbytes("IO/parser.ml"),1726,8],
     _cu_=[0,caml_string_of_jsbytes("IO/parser.ml"),1772,8],
     _cv_=[0,caml_string_of_jsbytes("IO/parser.ml"),1797,8],
     _cw_=[0,caml_string_of_jsbytes("IO/parser.ml"),1822,8],
     _cx_=[0,caml_string_of_jsbytes("IO/parser.ml"),1868,8],
     _cy_=[0,caml_string_of_jsbytes("IO/parser.ml"),1876,4],
     _cz_=[0,caml_string_of_jsbytes("IO/parser.ml"),1889,12],
     _cA_=[0,caml_string_of_jsbytes("IO/parser.ml"),1893,8],
     _cB_=[0,caml_string_of_jsbytes("IO/parser.ml"),1925,4],
     _cD_=[0,caml_string_of_jsbytes("IO/parser.ml"),1981,12],
     _cC_=[0,caml_string_of_jsbytes("IO/parser.ml"),2006,8],
     _cH_=[0,caml_string_of_jsbytes("IO/parser.ml"),2065,16],
     _cG_=[0,caml_string_of_jsbytes("IO/parser.ml"),2091,20],
     _cF_=[0,caml_string_of_jsbytes("IO/parser.ml"),2123,16],
     _cI_=[0,caml_string_of_jsbytes("IO/parser.ml"),2129,12],
     _cE_=[0,caml_string_of_jsbytes("IO/parser.ml"),2135,8],
     _cJ_=[0,caml_string_of_jsbytes("IO/parser.ml"),2162,8],
     _cK_=[0,caml_string_of_jsbytes("IO/parser.ml"),2198,8],
     _cL_=[0,caml_string_of_jsbytes("IO/parser.ml"),2241,8],
     _cN_=[0,caml_string_of_jsbytes("IO/parser.ml"),2283,16],
     _cM_=[0,caml_string_of_jsbytes("IO/parser.ml"),2291,12],
     _cO_=[0,caml_string_of_jsbytes("IO/parser.ml"),2296,8],
     _cR_=[0,caml_string_of_jsbytes("IO/parser.ml"),2414,24],
     _cS_=[0,caml_string_of_jsbytes("IO/parser.ml"),2419,20],
     _cQ_=[0,caml_string_of_jsbytes("IO/parser.ml"),2424,16],
     _cV_=[0,caml_string_of_jsbytes("IO/parser.ml"),2456,20],
     _cT_=[0,caml_string_of_jsbytes("IO/parser.ml"),2484,24],
     _cU_=[0,caml_string_of_jsbytes("IO/parser.ml"),2488,20],
     _cW_=[0,caml_string_of_jsbytes("IO/parser.ml"),2493,16],
     _cP_=[0,caml_string_of_jsbytes("IO/parser.ml"),2498,12],
     _cX_=[0,caml_string_of_jsbytes("IO/parser.ml"),2686,8],
     _cY_=[0,caml_string_of_jsbytes("IO/parser.ml"),2719,8],
     _cZ_=[0,caml_string_of_jsbytes("IO/parser.ml"),2740,8],
     _c0_=[3,1],
     _c1_=[3,0],
     _c5_=
      [0,
       [15,[11,caml_string_of_jsbytes(": command error\n"),0]],
       caml_string_of_jsbytes("%a: command error\n")],
     _c3_=
      [0,
       [15,[11,caml_string_of_jsbytes(": "),[2,0,[12,10,0]]]],
       caml_string_of_jsbytes("%a: %s\n")],
     _c4_=
      [0,
       [15,[11,caml_string_of_jsbytes(": parser error\n"),0]],
       caml_string_of_jsbytes("%a: parser error\n")],
     _c2_=
      [0,
       [2,0,[12,58,[4,0,0,0,[12,58,[4,0,0,0,0]]]]],
       caml_string_of_jsbytes("%s:%d:%d")],
     _c6_=
      [0,
       [11,caml_string_of_jsbytes("Available characters: "),[17,4,0]],
       caml_string_of_jsbytes("Available characters: @.")],
     _c7_=[0,[2,0,0],caml_string_of_jsbytes("%s")],
     _c8_=
      [0,
       [17,
        4,
        [11,caml_string_of_jsbytes("Please enter text to encode: "),[17,2,0]]],
       caml_string_of_jsbytes("@.Please enter text to encode: @?")],
     _c9_=
      [0,
       [4,8,[0,2,2],0,[4,8,[0,2,2],0,[12,32,0]]],
       caml_string_of_jsbytes("%02X%02X ")],
     _c__=[0,caml_string_of_jsbytes("Main/encoder_common.ml"),34,11],
     _c$_=
      [0,
       [4,
        8,
        [0,2,2],
        0,
        [4,8,[0,2,2],0,[4,8,[0,2,2],0,[4,8,[0,2,2],0,[12,32,0]]]]],
       caml_string_of_jsbytes("%02X%02X%02X%02X ")],
     _da_=[0,caml_string_of_jsbytes("Main/encoder_common.ml"),42,11],
     _dc_=
      [0,
       [11,caml_string_of_jsbytes("Encoded data (1-byte): "),[17,4,0]],
       caml_string_of_jsbytes("Encoded data (1-byte): @.")],
     _dd_=[0,[4,8,[0,2,2],0,[12,32,0]],caml_string_of_jsbytes("%02X ")],
     _di_=[0,0,0],
     _de_=
      [0,
       [17,4,[11,caml_string_of_jsbytes("Encoded data (2-bytes): "),[17,4,0]]],
       caml_string_of_jsbytes("@.Encoded data (2-bytes): @.")],
     _dh_=[0,0,[0,0,0]],
     _df_=
      [0,
       [17,4,[11,caml_string_of_jsbytes("Encoded data (4-bytes): "),[17,4,0]]],
       caml_string_of_jsbytes("@.Encoded data (4-bytes): @.")],
     _dg_=[0,[17,4,0],caml_string_of_jsbytes("@.")],
     _db_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("An error occured. Please check you only use available characters."),
        0],
       caml_string_of_jsbytes
        ("An error occured. Please check you only use available characters.")],
     _do_=[0,0],
     _ds_=
      [0,[4,8,[0,2,2],0,[12,32,[17,2,0]]],caml_string_of_jsbytes("%02X @?")],
     _dr_=
      [0,
       [11,
        caml_string_of_jsbytes("Box "),
        [4,
         3,
         [0,1,2],
         0,
         [11,
          caml_string_of_jsbytes(": "),
          [15,[11,caml_string_of_jsbytes("\t["),[15,[12,93,[17,4,0]]]]]]]],
       caml_string_of_jsbytes("Box %2i: %a\t[%a]@.")],
     _dq_=[0,1],
     _dp_=[0,0],
     _dn_=[0,caml_string_of_jsbytes("Boxes/boxes.ml"),35,12],
     _dj_=[0,0,[0,0,[0,0,[0,255,0]]]],
     _dk_=[0,0,[0,0,[0,255,[0,0,0]]]],
     _dl_=[0,0,[0,255,[0,0,[0,0,0]]]],
     _dm_=[0,255,[0,0,[0,0,[0,0,0]]]],
     _dC_=
      [0,
       [11,
        caml_string_of_jsbytes("LDR"),
        [2,0,[2,0,[12,32,[15,[11,caml_string_of_jsbytes(", "),[15,0]]]]]]],
       caml_string_of_jsbytes("LDR%s%s %a, %a")],
     _dD_=
      [0,
       [11,
        caml_string_of_jsbytes("STR"),
        [2,0,[2,0,[12,32,[15,[11,caml_string_of_jsbytes(", "),[15,0]]]]]]],
       caml_string_of_jsbytes("STR%s%s %a, %a")],
     _dE_=
      [0,
       [11,
        caml_string_of_jsbytes("MOV"),
        [2,0,[2,0,[12,32,[15,[11,caml_string_of_jsbytes(", "),[15,0]]]]]]],
       caml_string_of_jsbytes("MOV%s%s %a, %a")],
     _dF_=
      [0,
       [11,
        caml_string_of_jsbytes("MVN"),
        [2,0,[2,0,[12,32,[15,[11,caml_string_of_jsbytes(", "),[15,0]]]]]]],
       caml_string_of_jsbytes("MVN%s%s %a, %a")],
     _dG_=
      [0,
       [11,
        caml_string_of_jsbytes("ADC"),
        [2,
         0,
         [2,
          0,
          [12,
           32,
           [15,
            [11,
             caml_string_of_jsbytes(", "),
             [15,[11,caml_string_of_jsbytes(", "),[15,0]]]]]]]]],
       caml_string_of_jsbytes("ADC%s%s %a, %a, %a")],
     _dH_=
      [0,
       [11,
        caml_string_of_jsbytes("SBC"),
        [2,
         0,
         [2,
          0,
          [12,
           32,
           [15,
            [11,
             caml_string_of_jsbytes(", "),
             [15,[11,caml_string_of_jsbytes(", "),[15,0]]]]]]]]],
       caml_string_of_jsbytes("SBC%s%s %a, %a, %a")],
     _dI_=
      [0,
       [11,
        caml_string_of_jsbytes("BIC"),
        [2,
         0,
         [2,
          0,
          [12,
           32,
           [15,
            [11,
             caml_string_of_jsbytes(", "),
             [15,[11,caml_string_of_jsbytes(", "),[15,0]]]]]]]]],
       caml_string_of_jsbytes("BIC%s%s %a, %a, %a")],
     _dJ_=
      [0,
       [11,
        caml_string_of_jsbytes("AND"),
        [2,
         0,
         [2,
          0,
          [12,
           32,
           [15,
            [11,
             caml_string_of_jsbytes(", "),
             [15,[11,caml_string_of_jsbytes(", "),[15,0]]]]]]]]],
       caml_string_of_jsbytes("AND%s%s %a, %a, %a")],
     _dK_=
      [0,
       [12,66,[2,0,[2,0,[12,32,[15,0]]]]],
       caml_string_of_jsbytes("B%s%s %a")],
     _dy_=
      [0,
       [12,91,[15,[11,caml_string_of_jsbytes("], "),[15,0]]]],
       caml_string_of_jsbytes("[%a], %a")],
     _dz_=
      [0,
       [12,91,[15,[11,caml_string_of_jsbytes(", "),[15,[12,93,[2,0,0]]]]]],
       caml_string_of_jsbytes("[%a, %a]%s")],
     _dA_=
      [0,
       [12,91,[15,[11,caml_string_of_jsbytes("], "),[2,0,[15,0]]]]],
       caml_string_of_jsbytes("[%a], %s%a")],
     _dB_=
      [0,
       [12,
        91,
        [15,[11,caml_string_of_jsbytes(", "),[2,0,[15,[12,93,[2,0,0]]]]]]],
       caml_string_of_jsbytes("[%a, %s%a]%s")],
     _dx_=[0,[12,35,[2,0,[5,7,0,0,0]]],caml_string_of_jsbytes("#%s%#lx")],
     _dw_=[0,[15,0],caml_string_of_jsbytes("%a")],
     _dv_=[0,[12,35,[5,7,0,0,0]],caml_string_of_jsbytes("#%#lx")],
     _du_=[0,[12,114,[4,0,0,0,0]],caml_string_of_jsbytes("r%d")],
     _dt_=[0,[5,8,[0,2,8],0,0],caml_string_of_jsbytes("%08lX")],
     _dM_=
      [0,
       [11,caml_string_of_jsbytes("filler"),[21,1,0]],
       caml_string_of_jsbytes("filler%n")],
     _dN_=
      [0,
       [17,
        4,
        [11,caml_string_of_jsbytes("Raw data (in hexadecimal):"),[17,4,0]]],
       caml_string_of_jsbytes("@.Raw data (in hexadecimal):@.")],
     _dO_=
      [0,[4,8,[0,2,2],0,[12,32,[17,2,0]]],caml_string_of_jsbytes("%02X @?")],
     _dP_=[0,[17,4,0],caml_string_of_jsbytes("@.")],
     _dQ_=[0,[17,4,[15,[17,4,0]]],caml_string_of_jsbytes("@.%a@.")],
     _dR_=
      [0,
       [11,
        caml_string_of_jsbytes("Warning: Not enough space... Need "),
        [21,1,[12,47,[21,1,[11,caml_string_of_jsbytes(" boxes."),[17,4,0]]]]]],
       caml_string_of_jsbytes
        ("Warning: Not enough space... Need %n/%n boxes.@.")],
     _dS_=
      [0,
       [11,
        caml_string_of_jsbytes("Warning: Contains unwritable characters..."),
        [17,4,0]],
       caml_string_of_jsbytes("Warning: Contains unwritable characters...@.")],
     _dW_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("Warning: A box name cannot be written (only contains spaces)..."),
        [17,4,0]],
       caml_string_of_jsbytes
        ("Warning: A box name cannot be written (only contains spaces)...@.")],
     _dT_=
      [0,
       [11,caml_string_of_jsbytes("Raw data (in hexadecimal):"),[17,4,0]],
       caml_string_of_jsbytes("Raw data (in hexadecimal):@.")],
     _dU_=[0,[15,0],caml_string_of_jsbytes("%a")],
     _dV_=[0,[17,4,0],caml_string_of_jsbytes("@.")],
     _dL_=
      [0,
       [15,[11,caml_string_of_jsbytes(" \t"),[15,[12,9,[15,[17,4,0]]]]]],
       caml_string_of_jsbytes("%a \t%a\t%a@.")];
    function enumerate_files(dirname,ext)
     {var
       _mG_=runtime.caml_sys_read_directory(dirname),
       _mH_=caml_call1(Stdlib_array[11],_mG_);
      function _mI_(x)
       {return caml_string_equal(caml_call1(Stdlib_filename[10],x),ext)}
      return caml_call2(Stdlib_list[41],_mI_,_mH_)}
    function uint32_of_str(str)
     {var
       str$0=caml_call1(Stdlib_string[16],str),
       i64=runtime.caml_int64_of_string(str$0);
      if(caml_call2(Stdlib_int64[17],Stdlib_int64[1],caml_int64_and(_a_,i64)))
       return runtime.caml_int64_to_int32(i64);
      throw [0,Stdlib[7],cst_Not_a_valid_int32]}
    function uint32_to_int(v)
     {var match=caml_call1(Stdlib_int32[12],v);
      if(match){var i=match[1];return i}
      throw [0,Assert_failure,_b_]}
    function int64_of_uint32(x)
     {return caml_int64_and(_c_,caml_int64_of_int32(x))}
    function _d_(param){return 0}
    function _e_(param,_mF_,_mE_){return 0}
    var dummy_fmt=caml_call2(Stdlib_format[113],_e_,_d_);
    function concat_strings(lst)
     {function pp(fmt,lst)
       {function _mD_(str){return caml_call3(Stdlib_format[126],fmt,_f_,str)}
        return caml_call2(Stdlib_list[17],_mD_,lst)}
      return caml_call3(Stdlib_format[130],_g_,pp,lst)}
    var
     Utils=
      [0,
       enumerate_files,
       uint32_of_str,
       uint32_to_int,
       int64_of_uint32,
       dummy_fmt,
       concat_strings];
    caml_register_global(461,Utils,"Utils");
    function int32_from_low_high(l,h){return l | h << 16}
    function int32_to_low_high(i)
     {var l=65535 & i,h=i >>> 16 | 0;return [0,l,h]}
    var
     substructures_order=_h_.slice(),
     data_offset=32,
     len=48,
     pid_offset=0,
     otid_offset=4,
     checksum_offset=28;
    function pkmn_from_bytes(buf)
     {var
       pid=caml_call2(Stdlib_bytes[57],buf,pid_offset),
       otid=caml_call2(Stdlib_bytes[57],buf,otid_offset);
      return [0,pid,otid]}
    function substructure_position(param,ss)
     {var
       pid=param[1],
       i=uint32_to_int(caml_call2(Stdlib_int32[5],pid,24)),
       order=caml_check_bound(substructures_order,i)[1 + i],
       i$0=0;
      for(;;)
       {if(runtime.caml_string_get(order,i$0) === ss)return i$0;
        var i$1=i$0 + 1 | 0,i$0=i$1;
        continue}}
    function substructure_offset(pkmn,ss)
     {var p=substructure_position(pkmn,ss);return 32 + (12 * p | 0) | 0}
    function encrypt_aligned_int32(pkmn,i)
     {var otid=pkmn[2],pid=pkmn[1],key=pid ^ otid;return i ^ key}
    function checksum_diff_for_aligned_int3(o,n)
     {var
       match=int32_to_low_high(o),
       ho=match[2],
       lo=match[1],
       match$0=int32_to_low_high(n),
       hn=match$0[2],
       ln=match$0[1],
       diff=(ln - lo | 0) + (hn - ho | 0) | 0;
      return diff & 65535}
    function enc_dec(pkmn,buf,offset,len)
     {var offset$0=offset;
      for(;;)
       {if((offset + len | 0) <= offset$0)return 0;
        var
         i=caml_call2(Stdlib_bytes[57],buf,offset$0),
         i$0=encrypt_aligned_int32(pkmn,i);
        caml_call3(Stdlib_bytes[71],buf,offset$0,i$0);
        var offset$1=offset$0 + 4 | 0,offset$0=offset$1;
        continue}}
    function extract_data(buf)
     {var
       pkmn=pkmn_from_bytes(buf),
       res=caml_call3(Stdlib_bytes[7],buf,data_offset,len);
      enc_dec(pkmn,res,0,len);
      return res}
    function update_with_data(buf,data)
     {var pkmn=pkmn_from_bytes(buf),acc=Stdlib_int32[1],i=0;
      for(;;)
       {if(48 <= i)
         {var low=acc & 65535,checksum=uint32_to_int(low);
          caml_call5(Stdlib_bytes[11],data,0,buf,data_offset,len);
          enc_dec(pkmn,buf,data_offset,len);
          return caml_call3(Stdlib_bytes[65],buf,checksum_offset,checksum)}
        var
         nb=caml_call2(Stdlib_bytes[51],data,i),
         i$0=i + 2 | 0,
         acc$0=acc + nb | 0,
         acc=acc$0,
         i=i$0;
        continue}}
    function species_offset(pkmn){return substructure_offset(pkmn,71)}
    function species_offset_relative_to_dat(pkmn)
     {return substructure_offset(pkmn,71) - 32 | 0}
    function ivea_offset(pkmn){return substructure_offset(pkmn,77) + 4 | 0}
    function ivea_data_to_ivs(data)
     {var
       hp=31 & data,
       data$0=data >>> 5 | 0,
       atk=31 & data$0,
       data$1=data$0 >>> 5 | 0,
       def=31 & data$1,
       data$2=data$1 >>> 5 | 0,
       speed=31 & data$2,
       data$3=data$2 >>> 5 | 0,
       sp_atk=31 & data$3,
       data$4=data$3 >>> 5 | 0,
       sp_def=31 & data$4,
       data$5=data$4 >>> 5 | 0;
      return [0,hp,atk,def,speed,sp_atk,sp_def,data$5]}
    function ivs_to_ivea_data(param)
     {var
       data=param[7],
       sp_def=param[6],
       sp_atk=param[5],
       speed=param[4],
       def=param[3],
       atk=param[2],
       hp=param[1],
       data$0=data << 5,
       data$1=data$0 | sp_def,
       data$2=data$1 << 5,
       data$3=data$2 | sp_atk,
       data$4=data$3 << 5,
       data$5=data$4 | speed,
       data$6=data$5 << 5,
       data$7=data$6 | def,
       data$8=data$7 << 5,
       data$9=data$8 | atk,
       data$10=data$9 << 5,
       data$11=data$10 | hp;
      return data$11}
    var
     Structure=
      [0,
       int32_from_low_high,
       int32_to_low_high,
       pkmn_from_bytes,
       substructure_position,
       substructure_offset,
       extract_data,
       update_with_data,
       encrypt_aligned_int32,
       encrypt_aligned_int32,
       checksum_diff_for_aligned_int3,
       species_offset,
       species_offset_relative_to_dat,
       ivea_offset,
       ivea_data_to_ivs,
       ivs_to_ivea_data];
    caml_register_global(463,Structure,"Structure");
    var lang=[0,0],tweaker_mode=[0,1];
    function configure(language)
     {tweaker_mode[1] = 1;
      return caml_string_notequal(language,cst_eng)
              ?caml_string_notequal(language,cst_fra)
                ?caml_string_notequal(language,cst_ger)
                  ?caml_string_notequal(language,cst_ita)
                    ?caml_string_notequal(language,cst_jap)
                      ?caml_string_notequal(language,cst_spa)
                        ?(lang[1] = 0,0)
                        :(lang[1] = 3,0)
                      :(lang[1] = 5,tweaker_mode[1] = 0,0)
                    :(lang[1] = 2,0)
                  :(lang[1] = 4,0)
                :(lang[1] = 1,0)
              :(lang[1] = 0,0)}
    var Settings=[0,lang,tweaker_mode,configure];
    caml_register_global(464,Settings,"Settings");
    function mult_mod(x,y,m)
     {var _mC_=caml_call2(Big_int[10],x,y);
      return caml_call2(Big_int[16],_mC_,m)}
    var
     _i_=Big_int[9],
     _k_=Big_int[11],
     _l_=Big_int[50],
     _m_=Big_int[53],
     _j_=Big_int[6],
     _n_=Big_int[54],
     two_big_int=caml_call1(Big_int[36],2);
    caml_call1(Big_int[36],3);
    caml_call1(Big_int[36],4);
    var
     a=caml_call1(Big_int[42],_o_),
     b=caml_call1(Big_int[42],_p_),
     a_inv=caml_call1(Big_int[42],_q_),
     b_inv=caml_call1(Big_int[42],_r_),
     m=caml_call1(Big_int[42],_s_),
     b_1=caml_call1(Big_int[42],_t_),
     _u_=caml_call2(_k_,4,m),
     cycle_part_product=mult_mod(caml_call1(_i_,a),b_1,_u_),
     mask32=caml_call1(Big_int[42],_v_);
    function even(n)
     {var _mB_=caml_call2(_l_,n,Big_int[2]);
      return caml_call2(Big_int[24],Big_int[1],_mB_)}
    function odd(n){return 1 - even(n)}
    function mpow(base,exp,n)
     {var base$0=base,exp$0=exp;
      for(;;)
       {var base$1=caml_call2(Big_int[16],base$0,n);
        if(caml_call2(Big_int[24],exp$0,Big_int[1]))return Big_int[2];
        if(caml_call2(Big_int[24],exp$0,Big_int[2]))return base$1;
        if(even(exp$0))
         {var
           exp$1=caml_call2(Big_int[15],exp$0,two_big_int),
           base$2=caml_call2(Big_int[10],base$1,base$1),
           base$0=base$2,
           exp$0=exp$1;
          continue}
        return mult_mod(base$1,mpow(base$1,caml_call1(_i_,exp$0),n),n)}}
    function pow(base,exp)
     {var base$0=base,exp$0=exp;
      for(;;)
       {if(caml_call2(Big_int[24],exp$0,Big_int[1]))return Big_int[2];
        if(caml_call2(Big_int[24],exp$0,Big_int[2]))return base$0;
        if(even(exp$0))
         {var
           exp$1=caml_call2(Big_int[15],exp$0,two_big_int),
           base$1=caml_call2(Big_int[10],base$0,base$0),
           base$0=base$1,
           exp$0=exp$1;
          continue}
        var _mA_=pow(base$0,caml_call1(_i_,exp$0));
        return caml_call2(Big_int[10],base$0,_mA_)}}
    caml_fresh_oo_id(0);
    function _x_(seed)
     {var _mz_=caml_call2(Big_int[10],seed,a);
      return caml_call2(_l_,mask32,caml_call2(Big_int[5],b,_mz_))}
    function _y_(seed)
     {var _my_=caml_call2(Big_int[10],seed,a_inv);
      return caml_call2(_l_,mask32,caml_call2(Big_int[5],b_inv,_my_))}
    function big_int_of_uint32(i32)
     {var _mx_=int64_of_uint32(i32);return caml_call1(Big_int[42],_mx_)}
    function uint32_of_bigint(bi)
     {var
       maxint32=caml_call1(Big_int[40],Stdlib_int32[9]),
       minint32=caml_call1(Big_int[40],Stdlib_int32[10]),
       _mw_=caml_call2(Big_int[8],maxint32,minint32),
       total=caml_call1(Big_int[6],_mw_),
       bi$0=
        caml_call2(Big_int[28],bi,maxint32)?caml_call2(Big_int[8],bi,total):bi;
      return caml_call1(Big_int[43],bi$0)}
    function rng_of(seed)
     {var _mv_=caml_call2(_n_,seed,16);return caml_call1(Big_int[38],_mv_)}
    var
     aPresses=[0,1,3,6],
     moreAPresses=[0,0,10,30],
     old_rod=0,
     good_rod=1,
     super_rod=2;
    function next_seed(seed)
     {return uint32_of_bigint(_x_(big_int_of_uint32(seed)))}
    function prev_seed(seed)
     {return uint32_of_bigint(_y_(big_int_of_uint32(seed)))}
    function cycle_to(seed)
     {var
       seed$0=big_int_of_uint32(seed),
       y=caml_call2(_k_,4,m),
       x=caml_call1(_j_,mult_mod(seed$0,cycle_part_product,y)),
       power=caml_call2(Big_int[26],x,y)?caml_call2(Big_int[8],x,y):x,
       m$0=pow(two_big_int,caml_call1(Big_int[36],34));
      if(odd(a) && odd(power))
       {var
         bitmask=caml_call1(_i_,pow(two_big_int,caml_call1(Big_int[36],31))),
         ls=runtime.caml_make_vect(32,power),
         i=1,
         l=power;
        for(;;)
         {if(i < 32)
           {var l$0=mult_mod(l,l,m$0);
            caml_check_bound(ls,i)[1 + i] = l$0;
            var i$0=i + 1 | 0,i=i$0,l=l$0;
            continue}
          var i$1=31,b=Big_int[1],bit=Big_int[2];
          for(;;)
           {if(0 <= i$1)
             {var
               _mt_=mpow(a,caml_call2(_l_,bitmask,caml_call2(_m_,b,i$1)),m$0),
               _mu_=caml_check_bound(ls,i$1)[1 + i$1],
               b$0=
                1 - caml_call2(Big_int[24],_mu_,_mt_)
                 ?caml_call2(Big_int[5],b,bit)
                 :b,
               bit$0=caml_call2(_m_,bit,1),
               i$2=i$1 - 1 | 0,
               i$1=i$2,
               b=b$0,
               bit=bit$0;
              continue}
            return uint32_of_bigint(b)}}}
      throw [0,Assert_failure,_w_]}
    function seed_at(cycle)
     {var
       cycle$0=big_int_of_uint32(cycle),
       _mr_=caml_call1(_i_,a),
       y=caml_call2(Big_int[10],_mr_,m),
       x=caml_call1(_i_,mpow(a,cycle$0,y)),
       op1=caml_call2(Big_int[26],x,Big_int[1])?x:caml_call2(Big_int[5],x,y),
       _ms_=caml_call1(_i_,a),
       aux=caml_call2(Big_int[15],op1,_ms_);
      return uint32_of_bigint(mult_mod(aux,b,m))}
    function best_seed_for_rod(route119,feebas,target_seed,rod)
     {var
       target_seed$0=big_int_of_uint32(target_seed),
       maxAdditionalOffsets=[0,0,1,4],
       bestResults=[0,0],
       starting_seed=[0,_y_(target_seed$0)],
       for$2=1;
      for(;;)
       {starting_seed[1] = _y_(starting_seed[1]);
        var _mq_=for$2 + 1 | 0;
        if(8 !== for$2){var for$2=_mq_;continue}
        var switch$0=0;
        if(route119 && ! feebas)
         {starting_seed[1] = _y_(starting_seed[1]);
          var offset119=1;
          switch$0 = 1}
        if(! switch$0)var offset119=0;
        var _mf_=caml_check_bound(maxAdditionalOffsets,rod)[1 + rod],_me_=0;
        if(! (_mf_ < 0))
         {var additionalOffset=_me_;
          a:
          for(;;)
           {var seed=[0,starting_seed[1]],for$1=1;
            for(;;)
             {seed[1] = _x_(seed[1]);
              var _md_=for$1 + 1 | 0;
              if(7 !== for$1){var for$1=_md_;continue}
              var
               _l__=caml_check_bound(aPresses,rod)[1 + rod],
               minRounds=caml_mod(rng_of(seed[1]),_l__) + 1 | 0;
              seed[1] = _x_(seed[1]);
              seed[1] = _x_(seed[1]);
              var
               biteRoll=rng_of(seed[1]) % 100 | 0,
               biteResult=0 === (biteRoll & 1)?0:14 < biteRoll?1:2,
               _ma_=minRounds - 1 | 0,
               _l$_=1;
              if(! (_ma_ < 1))
               {var for$0=_l$_;
                for(;;)
                 {seed[1] = _x_(seed[1]);
                  var _mc_=for$0 + 1 | 0;
                  if(_ma_ !== for$0){var for$0=_mc_;continue}
                  break}}
              var advancement=[0,7 + minRounds | 0];
              if(1 === minRounds)
               {seed[1] = _x_(seed[1]);
                advancement[1] = advancement[1] + 1 | 0;
                var biteRoll$0=rng_of(seed[1]) % 100 | 0;
                if(biteRoll$0 < caml_check_bound(moreAPresses,rod)[1 + rod])
                 {seed[1] = _x_(seed[1]);
                  advancement[1] = advancement[1] + 1 | 0}}
              seed[1] = _x_(seed[1]);
              var
               feebasResult=(rng_of(seed[1]) % 100 | 0) < 50?1:0,
               _mb_=route119?1 - feebas:route119;
              if(_mb_)advancement[1] = advancement[1] + 1 | 0;
              var advancement$0=advancement[1];
              starting_seed[1] = _y_(starting_seed[1]);
              var _mh_=biteResult < 2?1:0;
              if(_mh_)
               var
                _mi_=1 - feebas,
                _mj_=_mi_ || feebasResult,
                _mk_=
                 _mj_
                  ?((9 + additionalOffset | 0) + offset119 | 0)
                    ===
                    advancement$0
                    ?1
                    :0
                  :_mj_;
              else
               var _mk_=_mh_;
              if(_mk_)
               {var _ml_=bestResults[1];
                if(_ml_)
                 {var
                   match=_ml_[1],
                   br=match[1],
                   s=match[3],
                   adv=match[2],
                   switch$1=0;
                  if(0 === br && 1 === biteResult)
                   {var _mm_=[0,[0,br,adv,s]];switch$1 = 1}
                  if(! switch$1)
                   {var s$0=match[3],adv$0=match[2],switch$2=0;
                    if(br === biteResult && adv$0 < advancement$0)
                     {var _mp_=[0,[0,br,adv$0,s$0]];switch$2 = 1}
                    if(! switch$2)
                     var
                      _mp_=
                       [0,[0,biteResult,advancement$0,_x_(starting_seed[1])]];
                    var _mm_=_mp_}
                  var _mn_=_mm_}
                else
                 var
                  _mn_=
                   [0,[0,biteResult,advancement$0,_x_(starting_seed[1])]];
                bestResults[1] = _mn_}
              var _mo_=additionalOffset + 1 | 0;
              if(_mf_ !== additionalOffset)
               {var additionalOffset=_mo_;continue a}
              break}
            break}}
        var _mg_=bestResults[1];
        if(_mg_)
         {var match$0=_mg_[1],s$1=match$0[3],i=match$0[2],b=match$0[1];
          return [0,[0,1 === b?1:0,i,uint32_of_bigint(s$1)]]}
        return 0}}
    var
     Seed=
      [0,
       prev_seed,
       next_seed,
       cycle_to,
       seed_at,
       old_rod,
       good_rod,
       super_rod,
       best_seed_for_rod];
    caml_register_global(466,Seed,"Seed");
    function main(fmt)
     {caml_call2(Stdlib_format[126],fmt,_z_);return [0,main_1]}
    function main_3(seed,fmt,str)
     {if(caml_string_notequal(str,cst_1$0))
       if(caml_string_notequal(str,cst_2$0))
        if(caml_string_notequal(str,cst_3$0))
         var
          _l6_=caml_call1(Stdlib[2],cst_Unknown_answer),
          feebas=_l6_[2],
          route119=_l6_[1];
        else
         var feebas=1,route119=1;
       else
        var feebas=0,route119=1;
      else
       var feebas=0,route119=0;
      var rod=old_rod;
      for(;;)
       {if(rod === 0)
         var rodname=cst_Old_rod;
        else
         {if(rod === 1)
           var _l9_=cst_Good_rod;
          else
           {if(rod !== 2)throw [0,Assert_failure,_ag_];var _l9_=cst_Super_rod}
          var rodname=_l9_}
        caml_call3(Stdlib_format[126],fmt,_aa_,rodname);
        var match=best_seed_for_rod(route119,feebas,seed,rod);
        if(match)
         {var _l7_=match[1];
          if(_l7_[1])
           {var seed$0=_l7_[3],adv=_l7_[2];
            caml_call2(Stdlib_format[126],fmt,_ab_);
            caml_call4(Stdlib_format[126],fmt,_ac_,seed$0,adv)}
          else
           {var seed$1=_l7_[3],adv$0=_l7_[2];
            caml_call2(Stdlib_format[126],fmt,_ad_);
            caml_call4(Stdlib_format[126],fmt,_ae_,seed$1,adv$0)}}
        else
         caml_call2(Stdlib_format[126],fmt,_af_);
        var _l8_=rod + 1 | 0;
        if(2 !== rod){var rod=_l8_;continue}
        caml_call2(Stdlib_format[126],fmt,_Z_);
        caml_call2(Stdlib_format[126],fmt,___);
        caml_call2(Stdlib_format[126],fmt,_$_);
        return 0}}
    function show_vicinity(fmt,print_cycle,seed,start,stop)
     {var cycle=cycle_to(seed);
      if(print_cycle)caml_call3(Stdlib_format[126],fmt,_H_,cycle);
      var start_seed=[0,seed_at(cycle + start | 0)];
      if(! (stop < start))
       {var i=start;
        for(;;)
         {caml_call5(Stdlib_format[126],fmt,_I_,i,start_seed[1],start_seed[1]);
          start_seed[1] = next_seed(start_seed[1]);
          var _l5_=i + 1 | 0;
          if(stop !== i){var i=_l5_;continue}
          break}}
      return 0}
    function main_vicinity(seed,fmt,str)
     {function _l4_(i,j){return [0,i,j]}
      var
       match=caml_call3(Stdlib_scanf[4],str,_Y_,_l4_),
       stop=match[2],
       start=match[1];
      show_vicinity(fmt,1,seed,start,stop);
      return 0}
    function main_2(seed,fmt,str)
     {if(caml_string_notequal(str,cst_1))
       {if(caml_string_notequal(str,cst_2))
         return caml_string_notequal(str,cst_3)
                 ?caml_string_notequal(str,cst_4)
                   ?caml_string_notequal(str,cst_5)
                     ?0
                     :(caml_call2(Stdlib_format[126],fmt,_J_),
                       [0,
                        function(_l0_,_l1_){return main_vicinity(seed,_l0_,_l1_)}])
                   :(caml_call2(Stdlib_format[126],fmt,_K_),
                     caml_call2(Stdlib_format[126],fmt,_L_),
                     caml_call2(Stdlib_format[126],fmt,_M_),
                     caml_call2(Stdlib_format[126],fmt,_N_),
                     show_vicinity(fmt,0,seed,-10,0),
                     0)
                 :(caml_call2(Stdlib_format[126],fmt,_O_),
                   caml_call2(Stdlib_format[126],fmt,_P_),
                   caml_call2(Stdlib_format[126],fmt,_Q_),
                   caml_call2(Stdlib_format[126],fmt,_R_),
                   [0,function(_l2_,_l3_){return main_3(seed,_l2_,_l3_)}]);
        var _lY_=prev_seed(seed);
        caml_call3(Stdlib_format[126],fmt,_S_,_lY_);
        caml_call2(Stdlib_format[126],fmt,_T_);
        caml_call2(Stdlib_format[126],fmt,_U_);
        return 0}
      var _lZ_=prev_seed(prev_seed(seed));
      caml_call3(Stdlib_format[126],fmt,_V_,_lZ_);
      caml_call2(Stdlib_format[126],fmt,_W_);
      caml_call2(Stdlib_format[126],fmt,_X_);
      return 0}
    function main_1(fmt,str)
     {var seed=uint32_of_str(str);
      caml_call2(Stdlib_format[126],fmt,_A_);
      caml_call2(Stdlib_format[126],fmt,_B_);
      caml_call2(Stdlib_format[126],fmt,_C_);
      caml_call2(Stdlib_format[126],fmt,_D_);
      caml_call2(Stdlib_format[126],fmt,_E_);
      caml_call2(Stdlib_format[126],fmt,_F_);
      caml_call2(Stdlib_format[126],fmt,_G_);
      return [0,function(_lW_,_lX_){return main_2(seed,_lW_,_lX_)}]}
    var
     Seed_tools_common=
      [0,main,main_1,show_vicinity,main_2,main_vicinity,main_3];
    caml_register_global(468,Seed_tools_common,"Seed_tools_common");
    var
     InvalidSave=[248,cst_Save_InvalidSave,caml_fresh_oo_id(0)],
     game_save_A=0,
     game_save_B=57344,
     section_size=4096,
     section_id_offset=4084,
     checksum_offset$0=4086,
     save_index_offset=4092,
     box_names_section_id=13,
     box_names_section_data_length=2000,
     box_names_offset=1860,
     box_names_length=126,
     team_items_section_id=1,
     team_items_section_data_length=3968,
     team_size_offset=564,
     pkmn_data_size=100;
    function read_section(inc,section_id)
     {var rbuf=caml_create_bytes(4096);
      function aux(base,i)
       {var i$0=i;
        for(;;)
         {if(14 <= i$0)throw InvalidSave;
          var addr=base + (i$0 * 4096 | 0) | 0;
          caml_call2(Stdlib[90],inc,addr);
          caml_call4(Stdlib[85],inc,rbuf,0,section_size);
          var
           id=caml_call2(Stdlib_bytes[51],rbuf,section_id_offset),
           index=caml_call2(Stdlib_bytes[57],rbuf,save_index_offset);
          if(id === section_id)return [0,addr,index];
          var i$1=i$0 + 1 | 0,i$0=i$1;
          continue}}
      var
       match=aux(game_save_A,0),
       indexa=match[2],
       addra=match[1],
       match$0=aux(game_save_B,0),
       indexb=match$0[2],
       addrb=match$0[1],
       addr=0 <= caml_call2(Stdlib_int32[16],indexa,indexb)?addra:addrb,
       res=caml_create_bytes(4096);
      caml_call2(Stdlib[90],inc,addr);
      caml_call4(Stdlib[85],inc,res,0,section_size);
      return [0,addr,res]}
    function write_section(oc,addr,buf)
     {caml_call2(Stdlib[73],oc,addr);
      caml_call2(Stdlib[67],oc,buf);
      return caml_call1(Stdlib[63],oc)}
    function compute_checksum(buf,start,len)
     {var acc=Stdlib_int32[1],i=start;
      for(;;)
       {if((start + len | 0) <= i)
         {var high=acc >>> 16 | 0,low=acc & 65535,res=high + low | 0;
          return uint32_to_int(res & 65535)}
        var
         nb=caml_call2(Stdlib_bytes[57],buf,i),
         i$0=i + 4 | 0,
         acc$0=acc + nb | 0,
         acc=acc$0,
         i=i$0;
        continue}}
    function extract_box_names_from_section(buf)
     {return caml_call3(Stdlib_bytes[7],buf,box_names_offset,box_names_length)}
    function update_box_names(buf,box_names)
     {var len=runtime.caml_ml_bytes_length(box_names);
      caml_call5(Stdlib_bytes[11],box_names,0,buf,box_names_offset,len);
      var checksum=compute_checksum(buf,0,box_names_section_data_length);
      return caml_call3(Stdlib_bytes[65],buf,checksum_offset$0,checksum)}
    function empty_pkmn(param){return caml_create_bytes(100)}
    function extract_team_from_section(buf)
     {var acc=0,i=5;
      for(;;)
       {if(0 <= i)
         {var
           addr=568 + (100 * i | 0) | 0,
           pkmn=caml_call3(Stdlib_bytes[7],buf,addr,pkmn_data_size),
           i$0=i - 1 | 0,
           acc$0=[0,pkmn,acc],
           acc=acc$0,
           i=i$0;
          continue}
        return acc}}
    function update_team(buf,pkmns)
     {var len=caml_call1(Stdlib_list[1],pkmns);
      caml_call3(Stdlib_bytes[71],buf,team_size_offset,len);
      function update_pkmn(i,pkmn)
       {var addr=568 + (100 * i | 0) | 0;
        return caml_call5(Stdlib_bytes[11],pkmn,0,buf,addr,pkmn_data_size)}
      caml_call2(Stdlib_list[18],update_pkmn,pkmns);
      var checksum=compute_checksum(buf,0,team_items_section_data_length);
      return caml_call3(Stdlib_bytes[65],buf,checksum_offset$0,checksum)}
    var
     Save=
      [0,
       InvalidSave,
       box_names_section_id,
       team_items_section_id,
       extract_box_names_from_section,
       update_box_names,
       empty_pkmn,
       extract_team_from_section,
       update_team,
       write_section,
       read_section];
    caml_register_global(469,Save,"Save");
    var
     StrMap=caml_call1(Stdlib_map[1],[0,Stdlib_string[5]]),
     VarNotFound=[248,cst_Preprocess_VarNotFound,caml_fresh_oo_id(0)];
    function get_param(lst,name)
     {var lst$0=lst;
      for(;;)
       {if(lst$0)
         {var _lV_=lst$0[1];
          if(0 === _lV_[0])
           {var n=_lV_[1],v=_lV_[2];
            if(caml_call2(Stdlib_string[4],n,name))return v;
            var lst$1=lst$0[2],lst$0=lst$1;
            continue}
          var lst$2=lst$0[2],lst$0=lst$2;
          continue}
        return 0}}
    function eval_meta_expr(env,e)
     {function aux(e)
       {var e$0=e;
        for(;;)
         switch(e$0[0])
          {case 0:var i=e$0[1];return i;
           case 1:
            var e2=e$0[3],e1=e$0[2],op=e$0[1],i1=aux(e1),i2=aux(e2);
            switch(op)
             {case 0:return i1 + i2 | 0;
              case 1:return i1 - i2 | 0;
              case 2:return runtime.caml_mul(i1,i2);
              case 3:return caml_call2(Stdlib_int32[4],i1,i2);
              case 4:return caml_call2(Stdlib_int32[5],i1,i2);
              case 5:return i1 & i2;
              case 6:return i1 ^ i2;
              case 7:return i1 | i2;
              case 8:return i1 << uint32_to_int(i2);
              case 9:return i1 >>> uint32_to_int(i2) | 0;
              case 10:
               return caml_call2(Stdlib_int32[17],i1,i2)
                       ?Stdlib_int32[2]
                       :Stdlib_int32[1];
              case 11:
               return caml_call2(Stdlib_int32[17],i1,i2)
                       ?Stdlib_int32[1]
                       :Stdlib_int32[2];
              case 12:
               if
                (caml_call2(Stdlib_int32[17],i1,Stdlib_int32[1])
                 &&
                 caml_call2(Stdlib_int32[17],i2,Stdlib_int32[1]))
                return Stdlib_int32[1];
               return Stdlib_int32[2];
              default:
               if
                (!
                 caml_call2(Stdlib_int32[17],i1,Stdlib_int32[1])
                 &&
                 !
                 caml_call2(Stdlib_int32[17],i2,Stdlib_int32[1]))
                return Stdlib_int32[2];
               return Stdlib_int32[1]}
           case 2:
            var e$1=e$0[2],op$0=e$0[1],i$0=aux(e$1);
            switch(op$0)
             {case 0:return i$0;
              case 1:return - i$0 | 0;
              case 2:return caml_call1(Stdlib_int32[11],i$0);
              default:
               return caml_call2(Stdlib_int32[17],i$0,Stdlib_int32[1])
                       ?Stdlib_int32[2]
                       :Stdlib_int32[1]}
           case 3:
            var str=e$0[1];
            if(caml_call2(StrMap[3],str,env))
             return caml_call2(StrMap[28],str,env);
            throw [0,VarNotFound,str];
           default:
            var e2$0=e$0[3],e1$0=e$0[2],e0=e$0[1],i0=aux(e0);
            if(caml_call2(Stdlib_int32[17],i0,Stdlib_int32[1]))
             {var e$0=e2$0;continue}
            var e$0=e1$0;
            continue}}
      return aux(e)}
    var empty_env=StrMap[1];
    function env_from_headers(fmt,headers)
     {function treat_def(param,def)
       {var acc=param[2],printed=param[1];
        if(0 === def[0])return [0,printed,acc];
        var expr=def[3],print=def[2],str=def[1],i=eval_meta_expr(acc,expr);
        if(print)caml_call5(Stdlib_format[126],fmt,_ah_,str,i,i);
        var _lU_=caml_call3(StrMap[4],str,i,acc),printed$0=printed || print;
        return [0,printed$0,_lU_]}
      var
       match=caml_call3(Stdlib_list[25],treat_def,[0,0,StrMap[1]],headers),
       res=match[2],
       printed=match[1];
      if(printed)caml_call2(Stdlib_format[126],fmt,_ai_);
      return res}
    function concat_env(env1,env2)
     {function _lT_(k,v,acc){return caml_call3(StrMap[4],k,v,acc)}
      return caml_call3(StrMap[13],_lT_,env2,env1)}
    var
     Preprocess=
      [0,
       VarNotFound,
       get_param,
       eval_meta_expr,
       empty_env,
       env_from_headers,
       concat_env];
    caml_register_global(471,Preprocess,"Preprocess");
    function main$0(fmt)
     {caml_call2(Stdlib_format[126],fmt,_aj_);return [0,main_1$0]}
    function main_6(pkmn,livea,fmt,str)
     {function _lS_(i){return i}
      var
       hivea=caml_call3(Stdlib_scanf[4],str,_aw_,_lS_),
       ivea=int32_from_low_high(livea,hivea),
       uivea=encrypt_aligned_int32(pkmn,ivea);
      caml_call3(Stdlib_format[126],fmt,_ax_,uivea);
      var
       match=ivea_data_to_ivs(uivea),
       data=match[7],
       sp_def=match[6],
       sp_atk=match[5],
       speed=match[4],
       def=match[3],
       atk=match[2],
       hp=match[1];
      caml_call8(Stdlib_format[126],fmt,_ay_,hp,atk,def,speed,sp_atk,sp_def);
      caml_call2(Stdlib_format[126],fmt,_az_);
      var uivea$0=ivs_to_ivea_data([0,31,31,31,31,31,31,data]);
      caml_call3(Stdlib_format[126],fmt,_aA_,uivea$0);
      var
       ivea$0=encrypt_aligned_int32(pkmn,uivea$0),
       match$0=int32_to_low_high(ivea$0),
       hivea$0=match$0[2],
       livea$0=match$0[1];
      caml_call3(Stdlib_format[126],fmt,_aB_,livea$0);
      caml_call3(Stdlib_format[126],fmt,_aC_,hivea$0);
      var checksum_diff=checksum_diff_for_aligned_int3(uivea,uivea$0);
      caml_call3(Stdlib_format[126],fmt,_aD_,checksum_diff);
      return 0}
    function main_5(pkmn,fmt,str)
     {function _lP_(i){return i}
      var livea=caml_call3(Stdlib_scanf[4],str,_au_,_lP_);
      caml_call2(Stdlib_format[126],fmt,_av_);
      return [0,function(_lQ_,_lR_){return main_6(pkmn,livea,_lQ_,_lR_)}]}
    function main_4(pid,vid,fmt,str)
     {function _lM_(i){return i}
      var
       sid=caml_call3(Stdlib_scanf[4],str,_aq_,_lM_),
       tid=int32_from_low_high(vid,sid),
       pkmn=[0,pid,tid],
       misc_pos=substructure_position(pkmn,77),
       ivea_offset$0=ivea_offset(pkmn);
      caml_call3(Stdlib_format[126],fmt,_ar_,misc_pos + 1 | 0);
      caml_call3(Stdlib_format[126],fmt,_as_,ivea_offset$0);
      caml_call2(Stdlib_format[126],fmt,_at_);
      return [0,function(_lN_,_lO_){return main_5(pkmn,_lN_,_lO_)}]}
    function main_3$0(pid,fmt,str)
     {function _lJ_(i){return i}
      var vid=caml_call3(Stdlib_scanf[4],str,_ao_,_lJ_);
      caml_call2(Stdlib_format[126],fmt,_ap_);
      return [0,function(_lK_,_lL_){return main_4(pid,vid,_lK_,_lL_)}]}
    function main_2$0(lpid,fmt,str)
     {function _lG_(i){return i}
      var
       hpid=caml_call3(Stdlib_scanf[4],str,_am_,_lG_),
       pid=int32_from_low_high(lpid,hpid);
      caml_call2(Stdlib_format[126],fmt,_an_);
      return [0,function(_lH_,_lI_){return main_3$0(pid,_lH_,_lI_)}]}
    function main_1$0(fmt,str)
     {function _lD_(i){return i}
      var lpid=caml_call3(Stdlib_scanf[4],str,_ak_,_lD_);
      caml_call2(Stdlib_format[126],fmt,_al_);
      return [0,function(_lE_,_lF_){return main_2$0(lpid,_lE_,_lF_)}]}
    var
     Pkmn_data_common=
      [0,main$0,main_1$0,main_2$0,main_3$0,main_4,main_5,main_6];
    caml_register_global(472,Pkmn_data_common,"Pkmn_data_common");
    var
     InvalidCommand=[248,cst_Arm_InvalidCommand,caml_fresh_oo_id(0)],
     a1=0,
     a2=1,
     a3=2,
     a4=3,
     v1=4,
     v2=5,
     v3=6,
     v4=7,
     v5=8,
     v6=9,
     v7=10,
     v8=11,
     sb=9,
     sl=10,
     fp=11,
     ip=12,
     sp=13,
     lr=14,
     pc=15,
     sign_plus=1,
     sign_minus=0,
     mask8=255,
     mask9=511,
     mask12=4095;
    function add_condition_code(c,v)
     {switch(c)
       {case 0:var _lC_=0;break;
        case 1:var _lC_=1;break;
        case 6:var _lC_=4;break;
        case 7:var _lC_=5;break;
        case 8:var _lC_=6;break;
        case 9:var _lC_=7;break;
        case 10:var _lC_=8;break;
        case 11:var _lC_=9;break;
        case 12:var _lC_=10;break;
        case 13:var _lC_=11;break;
        case 14:var _lC_=12;break;
        case 15:var _lC_=13;break;
        case 16:var _lC_=14;break;
        case 2:
        case 3:var _lC_=2;break;
        default:var _lC_=3}
      return v | _lC_ << 28}
    function add_rn_code(rn,v){return v | rn << 16}
    function add_rd_code(rd,v){return v | rd << 12}
    function rotate_right(v)
     {var lb=v & 1,v$0=v >>> 1 | 0;return v$0 | lb << 31}
    function rotate_left(v)
     {var hb=v & -2147483648,v$0=v << 1;return v$0 | hb >>> 31 | 0}
    function addr_mode_1(rs)
     {switch(rs[0])
       {case 0:
         var
          i=rs[1],
          aux=
           function(n,imm)
            {if(15 < n)return 0;
             var
              others=aux(n + 1 | 0,rotate_left(rotate_left(imm))),
              imm8=imm & 255;
             return caml_call2(Stdlib_int32[17],imm8,imm)
                     ?[0,[0,n,imm8],others]
                     :others},
          res=aux(0,i);
         if(0 === res)throw InvalidCommand;
         var
          _lA_=
           function(param)
            {var imm8=param[2],rr=param[1];return [0,1,imm8 | rr << 8]},
          possibilities=caml_call2(Stdlib_list[19],_lA_,res);
         break;
        case 1:var rm=rs[1],possibilities=[0,[0,0,rm],0];break;
        default:var possibilities=caml_call1(Stdlib[2],cst_Not_implemented)}
      function _lB_(param)
       {var v=param[2],imm=param[1],i=imm << 25;return v | i}
      return caml_call2(Stdlib_list[19],_lB_,possibilities)}
    function p_and_w(addr_typ)
     {switch(addr_typ)
       {case 0:return _aE_;case 1:return _aF_;default:return _aG_}}
    function ldr_str_to_binary(is_ldr,typ,cond,rd,param)
     {var addr_typ=param[2],rn=param[1];
      function check_post_addr(param)
       {if(2 <= addr_typ)return 0;throw InvalidCommand}
      if(is_ldr)
       switch(typ)
        {case 0:var opcode=72351744;break;
         case 1:var opcode=1048784;break;
         case 2:var opcode=1048752;break;
         case 3:var opcode=1048816;break;
         case 4:var opcode=68157440;break;
         case 5:check_post_addr(0);var opcode=70254592;break;
         default:check_post_addr(0);var opcode=74448896}
      else
       switch(typ)
        {case 0:var opcode=71303168;break;
         case 1:throw InvalidCommand;
         case 2:var opcode=176;break;
         case 3:throw InvalidCommand;
         case 4:var opcode=67108864;break;
         case 5:check_post_addr(0);var opcode=69206016;break;
         default:check_post_addr(0);var opcode=73400320}
      var
       _lz_=add_condition_code(cond,opcode),
       v$3=add_rd_code(rd,add_rn_code(rn[1],_lz_)),
       switcher=typ - 1 | 0;
      if(2 < switcher >>> 0)
       {switch(rn[0])
         {case 0:
           var v=rn[3],sign=rn[2];
           if(0 < caml_call2(Stdlib_int32[16],v,mask12))throw InvalidCommand;
           var v$0=v,reg=0,sign$0=sign;
           break;
          case 1:var rm=rn[3],sign$1=rn[2],v$0=rm,reg=1,sign$0=sign$1;break;
          default:
           var
            _ly_=caml_call1(Stdlib[2],cst_Not_implemented$0),
            v$0=_ly_[3],
            reg=_ly_[2],
            sign$0=_ly_[1]}
        var
         match=p_and_w(addr_typ),
         w=match[2],
         p=match[1],
         i=reg << 25,
         u=sign$0 << 23,
         p$0=p << 24,
         w$0=w << 21,
         addr_mode=i | w$0 | p$0 | v$0 | u}
      else
       {switch(rn[0])
         {case 0:
           var v$1=rn[3],sign$2=rn[2];
           if(0 < caml_call2(Stdlib_int32[16],v$1,mask8))throw InvalidCommand;
           var
            immedL=15 & v$1,
            immedH=15 & (v$1 >>> 4 | 0),
            v$2=immedL | immedH << 8,
            imm=1,
            sign$3=sign$2;
           break;
          case 1:
           var rm$0=rn[3],sign$4=rn[2],v$2=rm$0,imm=0,sign$3=sign$4;break;
          default:throw InvalidCommand}
        var
         match$0=p_and_w(addr_typ),
         w$1=match$0[2],
         p$1=match$0[1],
         i$0=imm << 22,
         u$0=sign$3 << 23,
         p$2=p$1 << 24,
         w$2=w$1 << 21,
         addr_mode=i$0 | w$2 | p$2 | v$2 | u$0}
      return [0,v$3 | addr_mode,0]}
    function mov_mvn_to_binary(is_mov,s,cond,rd,rs)
     {var
       opcode=is_mov?27262976:31457280,
       scode=s?1:0,
       scode$0=scode << 20,
       v=scode$0 | add_rd_code(rd,add_condition_code(cond,opcode)),
       _lw_=addr_mode_1(rs);
      function _lx_(addr_mode){return v | addr_mode}
      return caml_call2(Stdlib_list[19],_lx_,_lw_)}
    function calculation_to_binary(typ,s,cond,rd,rn,op2)
     {if(caml_string_notequal(typ,cst_adc))
       if(caml_string_notequal(typ,cst_and))
        if(caml_string_notequal(typ,cst_bic))
         {if(caml_string_notequal(typ,cst_sbc))throw [0,Assert_failure,_aH_];
          var opcode=12582912}
        else
         var opcode=29360128;
       else
        var opcode=0;
      else
       var opcode=10485760;
      var
       scode=s?1:0,
       scode$0=scode << 20,
       v=
        scode$0
        |
        add_rn_code(rn,add_rd_code(rd,add_condition_code(cond,opcode))),
       _lu_=addr_mode_1(op2);
      function _lv_(addr_mode){return v | addr_mode}
      return caml_call2(Stdlib_list[19],_lv_,_lu_)}
    function arm_to_binary(arm)
     {switch(arm[0])
       {case 0:var i$1=arm[1];return [0,i$1,0];
        case 1:
         var ro=arm[4],rd=arm[3],cond=arm[2],typ=arm[1];
         return ldr_str_to_binary(1,typ,cond,rd,ro);
        case 2:
         var ro$0=arm[4],rd$0=arm[3],cond$0=arm[2],typ$0=arm[1];
         return ldr_str_to_binary(0,typ$0,cond$0,rd$0,ro$0);
        case 3:
         var rs=arm[4],rd$1=arm[3],cond$1=arm[2],s=arm[1];
         return mov_mvn_to_binary(1,s,cond$1,rd$1,rs);
        case 4:
         var rs$0=arm[4],rd$2=arm[3],cond$2=arm[2],s$0=arm[1];
         return mov_mvn_to_binary(0,s$0,cond$2,rd$2,rs$0);
        case 5:
         var op2=arm[5],rn=arm[4],rd$3=arm[3],cond$3=arm[2],s$1=arm[1];
         return calculation_to_binary(cst_adc$0,s$1,cond$3,rd$3,rn,op2);
        case 6:
         var op2$0=arm[5],rn$0=arm[4],rd$4=arm[3],cond$4=arm[2],s$2=arm[1];
         return calculation_to_binary(cst_sbc$0,s$2,cond$4,rd$4,rn$0,op2$0);
        case 7:
         var op2$1=arm[5],rn$1=arm[4],rd$5=arm[3],cond$5=arm[2],s$3=arm[1];
         return calculation_to_binary(cst_bic$0,s$3,cond$5,rd$5,rn$1,op2$1);
        case 8:
         var op2$2=arm[5],rn$2=arm[4],rd$6=arm[3],cond$6=arm[2],s$4=arm[1];
         return calculation_to_binary(cst_and$0,s$4,cond$6,rd$6,rn$2,op2$2);
        default:
         var
          target=arm[3],
          cond$7=arm[2],
          l=arm[1],
          opcode=l?184549376:167772160,
          v=add_condition_code(cond$7,opcode),
          i$0=target - 8 | 0;
         if(caml_call2(Stdlib_int32[17],i$0 & 3,Stdlib_int32[1]))
          {var i=i$0 >> 2,ms9=i >>> 23 | 0;
           if
            (!
             caml_call2(Stdlib_int32[17],ms9,mask9)
             &&
             !
             caml_call2(Stdlib_int32[17],ms9,Stdlib_int32[1]))
            throw InvalidCommand;
           var imm=i & 16777215;
           return [0,v | imm,0]}
         throw InvalidCommand}}
    function reverse_endianness(v)
     {var
       v1=(255 & v) << 24,
       v$0=v >>> 8 | 0,
       v2=(255 & v$0) << 16,
       v$1=v$0 >>> 8 | 0,
       v3=(255 & v$1) << 8,
       v$2=v$1 >>> 8 | 0,
       v4=255 & v$2;
      return v4 | v3 | v1 | v2}
    var
     Arm=
      [0,
       InvalidCommand,
       sign_plus,
       sign_minus,
       a1,
       a2,
       a3,
       a4,
       v1,
       v2,
       v3,
       v4,
       v5,
       v6,
       v7,
       v8,
       sb,
       sl,
       fp,
       ip,
       sp,
       lr,
       pc,
       arm_to_binary,
       reverse_endianness,
       rotate_right,
       rotate_left];
    caml_register_global(473,Arm,"Arm");
    var
     charset_eng=_aI_.slice(),
     charset_ita=caml_call1(Stdlib_array[8],charset_eng),
     charset_spa=caml_call1(Stdlib_array[8],charset_eng),
     charset_ger=caml_call1(Stdlib_array[8],charset_eng);
    caml_check_bound(charset_ger,177)[178] = _aJ_;
    caml_check_bound(charset_ger,178)[179] = _aK_;
    var charset_fra=caml_call1(Stdlib_array[8],charset_eng);
    caml_check_bound(charset_fra,177)[178] = _aL_;
    caml_check_bound(charset_fra,178)[179] = _aM_;
    var charset_jap=_aN_.slice();
    function charset(param)
     {switch(lang[1])
       {case 0:return charset_eng;
        case 1:return charset_fra;
        case 2:return charset_ita;
        case 3:return charset_spa;
        case 4:return charset_ger;
        default:return charset_jap}}
    function is_code_available(code)
     {var match=caml_check_bound(charset(0),code)[1 + code];
      if(typeof match !== "number" && 2 === match[0])return 1;
      return 0}
    function is_code_readable(code)
     {var match=caml_check_bound(charset(0),code)[1 + code];
      if(typeof match !== "number" && 0 !== match[0])return 1;
      return 0}
    function is_code_used(code)
     {var match=caml_check_bound(charset(0),code)[1 + code];
      return typeof match === "number"?0:1}
    function char_at(code)
     {var match=caml_check_bound(charset(0),code)[1 + code];
      if(typeof match === "number")return invalid_char;
      var str=match[1];
      return str}
    function readable_char_at(code)
     {var match=caml_check_bound(charset(0),code)[1 + code];
      if(typeof match !== "number" && 0 !== match[0])
       {var str=match[1];return str}
      return invalid_char}
    function writable_char_at(code)
     {var match=caml_check_bound(charset(0),code)[1 + code];
      if(typeof match !== "number" && 2 === match[0])
       {var str=match[1];return str}
      return invalid_char}
    var acc=0,i=255;
    for(;;)
     {if(0 <= i)
       {var match=caml_check_bound(charset(0),i)[1 + i];
        if(typeof match !== "number" && 2 === match[0])
         {var str=match[1],i$1=i - 1 | 0,acc$0=[0,str,acc],acc=acc$0,i=i$1;
          continue}
        var i$0=i - 1 | 0,i=i$0;
        continue}
      var
       encode_writable_char=
        function(str)
         {var i=255;
          for(;;)
           {if(0 <= i)
             {var match=caml_check_bound(charset(0),i)[1 + i];
              if(typeof match !== "number" && 2 === match[0])
               {var str$0=match[1];
                if(caml_call2(Stdlib_string[4],str,str$0))return i}
              var i$0=i - 1 | 0,i=i$0;
              continue}
            throw Stdlib[8]}},
       Charset=
        [0,
         is_code_available,
         is_code_readable,
         is_code_used,
         spacing_char,
         invalid_char,
         char_at,
         readable_char_at,
         writable_char_at,
         acc,
         encode_writable_char];
      caml_register_global(474,Charset,"Charset");
      var
       eof=255,
       space=0,
       codes_for_command=
        function(v)
         {var
           v1=255 & v,
           v$0=v >>> 8 | 0,
           v2=255 & v$0,
           v$1=v$0 >>> 8 | 0,
           v3=255 & v$1,
           v$2=v$1 >>> 8 | 0,
           v4=255 & v$2,
           _lr_=[0,uint32_to_int(v4),0],
           _ls_=[0,uint32_to_int(v3),_lr_],
           _lt_=[0,uint32_to_int(v2),_ls_];
          return [0,uint32_to_int(v1),_lt_]},
       command_for_codes=
        function(codes)
         {if(codes)
           {var _lo_=codes[2];
            if(_lo_)
             {var _lp_=_lo_[2];
              if(_lp_)
               {var _lq_=_lp_[2];
                if(_lq_ && ! _lq_[2])
                 {var
                   c4=_lq_[1],
                   c3=_lp_[1],
                   c2=_lo_[1],
                   c1=codes[1],
                   v=c4 << 8,
                   v$0=v | c3,
                   v$1=v$0 << 8,
                   v$2=v$1 | c2,
                   v$3=v$2 << 8;
                  return v$3 | c1}}}}
          throw [0,Assert_failure,_aO_]},
       codes_to_chars=
        function(c){return caml_call2(Stdlib_list[19],writable_char_at,c)},
       chars_for_command=
        function(v){return codes_to_chars(codes_for_command(v))},
       pp_chars=
        function(fmt,lst)
         {function _lm_(i,str)
           {var _ln_=0 === i?cst:cst$0;
            return caml_call4(Stdlib_format[126],fmt,_aP_,_ln_,str)}
          return caml_call2(Stdlib_list[18],_lm_,lst)},
       pp_chars_raw=
        function(fmt,lst)
         {function _ll_(str)
           {var str$0=caml_string_equal(str,spacing_char)?cst$1:str;
            return caml_call3(Stdlib_format[126],fmt,_aQ_,str$0)}
          return caml_call2(Stdlib_list[17],_ll_,lst)},
       is_code_writable=
        function(codes)
         {return caml_call2(Stdlib_list[32],is_code_available,codes)},
       first_code=
        function(f,codes)
         {var codes$0=codes;
          for(;;)
           {if(codes$0)
             {var codes$1=codes$0[2],code=codes$0[1];
              if(caml_call1(f,code))return code;
              var codes$0=codes$1;
              continue}
            throw Stdlib[8]}},
       first_writable_code=
        function(codes){return first_code(is_code_writable,codes)},
       is_code_writable_or_one_eof=
        function(code)
         {function _lg_(c){return c !== 255?1:0}
          var _lh_=is_code_writable(caml_call2(Stdlib_list[41],_lg_,code));
          if(_lh_)
           var
            _li_=0,
            _lj_=function(nb,c){return c === 255?nb + 1 | 0:nb},
            _lk_=caml_call3(Stdlib_list[25],_lj_,_li_,code) <= 1?1:0;
          else
           var _lk_=_lh_;
          return _lk_},
       preferred_code=
        function(codes)
         {try
           {var _ld_=first_writable_code(codes);return _ld_}
          catch(_le_)
           {_le_ = caml_wrap_exception(_le_);
            if(_le_ === Stdlib[8])
             try
              {var _lc_=first_code(is_code_writable_or_one_eof,codes);
               return _lc_}
             catch(_lf_)
              {_lf_ = caml_wrap_exception(_lf_);
               if(_lf_ === Stdlib[8])return caml_call1(Stdlib_list[5],codes);
               throw _lf_}
            throw _le_}},
       is_full_of_spaces=
        function(codes)
         {function _lb_(c){return c === 0?1:0}
          return caml_call2(Stdlib_list[32],_lb_,codes)},
       Name=
        [0,
         eof,
         space,
         codes_for_command,
         command_for_codes,
         chars_for_command,
         codes_to_chars,
         pp_chars,
         pp_chars_raw,
         is_code_writable,
         first_writable_code,
         preferred_code,
         is_full_of_spaces];
      caml_register_global(475,Name,"Name");
      var
       CannotOptimize=[248,cst_Optimizer_CannotOptimize,caml_fresh_oo_id(0)],
       compare=Stdlib_int32[16],
       UInt32=[0,compare],
       UInt32Set=caml_call1(Stdlib_set[1],UInt32),
       padding_code=[0,Stdlib_int32[1]],
       acc$1=0,
       i$2=Stdlib_int32[1],
       max=255;
      for(;;)
       {if(caml_call2(Stdlib_int32[17],i$2,max))
         {var
           immed8=[0,i$2,acc$1],
           _aR_=function(i){return is_code_writable([0,uint32_to_int(i),0])},
           immed8$0=caml_call2(Stdlib_list[41],_aR_,immed8),
           _aS_=
            function(i$1)
             {var acc$1=[0,i$1,0],acc=acc$1,i=i$1;
              for(;;)
               {var i$0=rotate_right(rotate_right(i));
                if(caml_call2(Stdlib_int32[17],i$0,i$1))return acc;
                var acc$0=[0,i$0,acc],acc=acc$0,i=i$0;
                continue}},
           _aT_=caml_call2(Stdlib_list[19],_aS_,immed8$0),
           _aU_=caml_call1(Stdlib_list[14],_aT_),
           constants_set=caml_call1(UInt32Set[37],_aU_),
           _aV_=
            function(i)
             {return 1
                     -
                     (caml_call2(Stdlib_int32[15],i,Stdlib_int32[1]) < 0?1:0)},
           _aW_=caml_call2(UInt32Set[19],_aV_,constants_set),
           constants_set_no_carry=
            caml_call2(UInt32Set[6],Stdlib_int32[1],_aW_),
           constants=caml_call1(UInt32Set[23],constants_set),
           rev_constants=caml_call1(Stdlib_list[9],constants),
           nset=caml_call2(UInt32Set[15],Stdlib_int32[11],constants_set),
           _aX_=caml_call2(UInt32Set[7],constants_set_no_carry,nset),
           constants_mov_mvn=caml_call1(UInt32Set[23],_aX_),
           rev_constants_mov_mvn=caml_call1(Stdlib_list[9],constants_mov_mvn),
           tad0=_aY_.slice(),
           remove_while=
            function(f,lst)
             {var lst$0=lst;
              for(;;)
               {if(lst$0)
                 {var lst$1=lst$0[2],i=lst$0[1];
                  if(caml_call1(f,i)){var lst$0=lst$1;continue}
                  return lst$0}
                return 0}},
           synthesis=
            function(mov_mvn,additive,incr,max_card,i,is_valid_fst,is_valid)
             {var tad0_len=tad0.length - 1;
              if(tad0_len < max_card)
               var
                _k2_=tad0_len - 1 | 0,
                tad0$0=caml_check_bound(tad0,_k2_)[1 + _k2_];
              else
               var
                _k4_=max_card - 1 | 0,
                tad0$0=caml_check_bound(tad0,_k4_)[1 + _k4_];
              function remove(i)
               {function _k$_(j)
                 {return caml_call2(Stdlib_int32[16],i,j) < 0?1:0}
                return function(_la_){return remove_while(_k$_,_la_)}}
              function next(acc,rc,i)
               {var rc$0=rc;
                for(;;)
                 {if(caml_call2(Stdlib_int32[17],i,Stdlib_int32[1]))
                   return [0,acc];
                  var depth=caml_call1(Stdlib_list[1],acc);
                  if(max_card <= depth)return 0;
                  var
                   rem_depth=caml_int64_of_int32(max_card - depth | 0),
                   i64=int64_of_uint32(i),
                   ii=incr?caml_call1(Stdlib_int32[7],i):i,
                   match=caml_call1(remove(ii),rc$0);
                  if(match)
                   {var
                     fst=match[1],
                     _k9_=incr?caml_call1(Stdlib_int32[6],fst):fst,
                     _k__=runtime.caml_int64_mul(int64_of_uint32(_k9_),rem_depth);
                    if(0 <= caml_call2(Stdlib_int64[16],_k__,i64))
                     {var
                       rc$1=match[2],
                       remainder=ii - fst | 0,
                       match$0=next([0,fst,acc],[0,fst,rc$1],remainder);
                      if(match$0){var res=match$0[1];return [0,res]}
                      var rc$0=rc$1;
                      continue}
                    return 0}
                  return 0}}
              var
               filtered_rev_constants=
                caml_call2(Stdlib_list[41],is_valid,rev_constants),
               remove_init=
                additive
                 ?remove
                 :function(i)
                   {function _k7_(j)
                     {return 0 < caml_call2(Stdlib_int32[16],i,j)?1:0}
                    return function(_k8_){return remove_while(_k7_,_k8_)}},
               op_init=
                additive
                 ?function(_k6_,_k5_){return _k6_ - _k5_ | 0}
                 :function(x,y){return y - x | 0},
               init_rc=
                additive
                 ?mov_mvn?rev_constants_mov_mvn:rev_constants
                 :mov_mvn?constants_mov_mvn:constants,
               rc$1=caml_call2(Stdlib_list[41],is_valid_fst,init_rc),
               try_nb=0,
               rc=rc$1;
              for(;;)
               {if(tad0$0 <= try_nb)
                 var _k3_=0;
                else
                 {var match=caml_call1(remove_init(i),rc);
                  if(match)
                   {var
                     rc$0=match[2],
                     fst=match[1],
                     remainder=op_init(i,fst),
                     match$0=next([0,fst,0],filtered_rev_constants,remainder);
                    if(! match$0)
                     {var try_nb$0=try_nb + 1 | 0,try_nb=try_nb$0,rc=rc$0;
                      continue}
                    var res=match$0[1],_k3_=[0,res]}
                  else
                   var _k3_=0}
                if(_k3_)
                 {var lst=_k3_[1];return [0,caml_call1(Stdlib_list[9],lst)]}
                return 0}},
           synthesis_optimal=
            function(mov_mvn,inv,max_card,i,is_valid_fst,is_valid)
             {var card=1;
              for(;;)
               {if(max_card < card)return 0;
                var
                 match=
                  synthesis
                   (mov_mvn,1,inv,card,i,is_valid_fst,caml_call1(is_valid,1));
                if(match){var lst=match[1];return [0,[0,lst,1]]}
                var
                 match$0=
                  synthesis
                   (mov_mvn,
                    0,
                    1 - inv,
                    card,
                    i,
                    is_valid_fst,
                    caml_call1(is_valid,0));
                if(match$0){var lst$0=match$0[1];return [0,[0,lst$0,0]]}
                var card$0=card + 1 | 0,card=card$0;
                continue}},
           synthesis_test=
            function(max_card,i)
             {function _k0_(param,_k1_){return 1}
              return synthesis_optimal
                      (1,0,max_card,i,function(param){return 1},_k0_)},
           is_command_valid=
            function(arm)
             {try
               {var
                 _kW_=arm_to_binary(arm),
                 _kX_=
                  function(i){return is_code_writable(codes_for_command(i))},
                 _kY_=caml_call2(Stdlib_list[33],_kX_,_kW_);
                return _kY_}
              catch(_kZ_)
               {_kZ_ = caml_wrap_exception(_kZ_);
                if(_kZ_ === InvalidCommand)return 0;
                throw _kZ_}},
           tweak_mov_or_mvn=
            function(is_mov,s,cond,rd,rs,max_card)
             {var cmd=is_mov?[3,s,cond,rd,rs]:[4,s,cond,rd,rs];
              switch(rs[0])
               {case 0:
                 var
                  i=rs[1],
                  mk_cmd_first=
                   function(fst)
                    {var
                      nfst=caml_call1(Stdlib_int32[11],fst),
                      _kV_=
                       is_mov
                        ?caml_call2(UInt32Set[3],fst,constants_set_no_carry)
                        :is_mov,
                      is_mov$0=
                       _kV_
                       ||
                       1
                       -
                       caml_call2(UInt32Set[3],nfst,constants_set);
                     return is_mov$0?[3,1,cond,rd,[0,fst]]:[4,0,cond,rd,[0,nfst]]},
                  mk_cmd=
                   function(additive,i)
                    {if(additive)
                      {var
                        _kT_=15 === rd?1:0,
                        _kS_=[0,i],
                        _kU_=_kT_ || (0 === rd?1:0);
                       return [5,_kU_,cond,rd,rd,_kS_]}
                     return [6,0,cond,rd,rd,[0,i]]},
                  i$0=is_mov?i:caml_call1(Stdlib_int32[11],i),
                  _kM_=function(add,i){return is_command_valid(mk_cmd(add,i))},
                  match=
                   synthesis_optimal
                    (1,
                     0,
                     max_card,
                     i$0,
                     function(i){return is_command_valid(mk_cmd_first(i))},
                     _kM_);
                 if(match)
                  {var _kN_=match[1],_kO_=_kN_[1];
                   if(_kO_)
                    {var
                      additive=_kN_[2],
                      lst=_kO_[2],
                      fst=_kO_[1],
                      _kP_=function(_kR_){return mk_cmd(additive,_kR_)},
                      _kQ_=caml_call2(Stdlib_list[19],_kP_,lst);
                     return [0,mk_cmd_first(fst),_kQ_]}
                   throw [0,Assert_failure,_aZ_]}
                 return [0,cmd,0];
                case 1:return [0,cmd,0];
                default:return caml_call1(Stdlib[2],cst_Not_implemented$1)}},
           tweak_adc_or_sbc=
            function(is_adc,s,cond,rd,rn,op2,max_card)
             {var cmd=is_adc?[5,s,cond,rd,rn,op2]:[6,s,cond,rd,rn,op2];
              switch(op2[0])
               {case 0:
                 var
                  i=op2[1],
                  mk_cmd_first=
                   function(fst)
                    {if(is_adc)
                      {var
                        _kK_=15 === rn?1:0,
                        _kJ_=[0,fst],
                        _kL_=_kK_ || (0 === rn?1:0);
                       return [5,_kL_,cond,rd,rn,_kJ_]}
                     return [6,0,cond,rd,rn,[0,fst]]},
                  mk_cmd=
                   function(additive,i)
                    {var switch$0=0;
                     if(additive && is_adc)switch$0 = 1;
                     if(! switch$0)
                      {var switch$1=0;
                       if(additive || is_adc)switch$1 = 1;
                       if(switch$1)return [6,0,cond,rd,rd,[0,i]]}
                     var
                      _kH_=15 === rd?1:0,
                      _kG_=[0,i],
                      _kI_=_kH_ || (0 === rd?1:0);
                     return [5,_kI_,cond,rd,rd,_kG_]},
                  _kA_=function(add,i){return is_command_valid(mk_cmd(add,i))},
                  match=
                   synthesis_optimal
                    (0,
                     1 - is_adc,
                     max_card,
                     i,
                     function(i){return is_command_valid(mk_cmd_first(i))},
                     _kA_);
                 if(match)
                  {var _kB_=match[1],_kC_=_kB_[1];
                   if(_kC_)
                    {var
                      additive=_kB_[2],
                      lst=_kC_[2],
                      fst=_kC_[1],
                      _kD_=function(_kF_){return mk_cmd(additive,_kF_)},
                      _kE_=caml_call2(Stdlib_list[19],_kD_,lst);
                     return [0,mk_cmd_first(fst),_kE_]}
                   throw [0,Assert_failure,_a0_]}
                 return [0,cmd,0];
                case 1:return [0,cmd,0];
                default:return caml_call1(Stdlib[2],cst_Not_implemented$2)}},
           tweak_command=
            function(param)
             {var optimize=param[2],arm=param[1];
              function optimize_with_card(arm,n,pad)
               {switch(arm[0])
                 {case 3:
                   var
                    rs=arm[4],
                    rd=arm[3],
                    cond=arm[2],
                    s=arm[1],
                    res=tweak_mov_or_mvn(1,s,cond,rd,rs,n);
                   break;
                  case 4:
                   var
                    rs$0=arm[4],
                    rd$0=arm[3],
                    cond$0=arm[2],
                    s$0=arm[1],
                    res=tweak_mov_or_mvn(0,s$0,cond$0,rd$0,rs$0,n);
                   break;
                  case 5:
                   var
                    op2=arm[5],
                    rn=arm[4],
                    rd$1=arm[3],
                    cond$1=arm[2],
                    s$1=arm[1],
                    res=tweak_adc_or_sbc(1,s$1,cond$1,rd$1,rn,op2,n);
                   break;
                  case 6:
                   var
                    op2$0=arm[5],
                    rn$0=arm[4],
                    rd$2=arm[3],
                    cond$2=arm[2],
                    s$2=arm[1],
                    res=tweak_adc_or_sbc(0,s$2,cond$2,rd$2,rn$0,op2$0,n);
                   break;
                  default:var res=[0,arm,0]}
                if(pad)
                 {var
                   _ky_=function(param){return padding_code},
                   _kz_=n - caml_call1(Stdlib_list[1],res) | 0,
                   padding=caml_call2(Stdlib_list[10],_kz_,_ky_);
                  return caml_call2(Stdlib[37],res,padding)}
                return res}
              if(typeof optimize === "number")
               return optimize?optimize_with_card(arm,5,0):[0,arm,0];
              var card=optimize[1];
              return optimize_with_card(arm,card,1)},
           tweak_arm=
            function(lst)
             {var _kx_=caml_call2(Stdlib_list[19],tweak_command,lst);
              return caml_call1(Stdlib_list[14],_kx_)},
           do_not_tweak_arm=
            function(lst)
             {function _kw_(param)
               {var optimize=param[2],arm=param[1];
                if(0 === optimize)return arm;
                throw CannotOptimize}
              return caml_call2(Stdlib_list[19],_kw_,lst)},
           Optimizer=
            [0,CannotOptimize,synthesis_test,tweak_arm,do_not_tweak_arm];
          caml_register_global(477,Optimizer,"Optimizer");
          var
           CommandError=[248,cst_Parser_ast_CommandError,caml_fresh_oo_id(0)],
           StructError=[248,cst_Parser_ast_StructError,caml_fresh_oo_id(0)],
           preprocess=
            function(env,ui)
             {if(0 === ui[0]){var i=ui[1];return i}
              var e=ui[1];
              return eval_meta_expr(env,e)},
           combine_opt=
            function(o1,o2)
             {if(o1)
               {var _kv_=o1[1];if(o2)throw StructError;var s=_kv_}
              else
               {if(! o2)return 0;var s=o2[1]}
              return [0,s]},
           combine_bool=
            function(b1,b2)
             {if(b1){if(b2)throw StructError}else if(! b2)return 0;return 1},
           recognize_modifiers=
            function(str$3,i)
             {var n$2=caml_ml_string_length(str$3),mods$1=mods,i$0=i;
              for(;;)
               {if(n$2 <= i$0)return mods$1;
                var
                 n=caml_ml_string_length(str$3),
                 _kl_=caml_call2(Stdlib[16],2,n - i$0 | 0),
                 str=caml_call3(Stdlib_string[9],str$3,i$0,_kl_),
                 switch$0=caml_string_compare(str,cst_LE),
                 switch$1=0;
                if(0 <= switch$0)
                 if(0 < switch$0)
                  if(caml_string_notequal(str,cst_LO))
                   if(caml_string_notequal(str,cst_LS))
                    if(caml_string_notequal(str,cst_LT))
                     if(caml_string_notequal(str,cst_MI))
                      if(caml_string_notequal(str,cst_NE))
                       if(caml_string_notequal(str,cst_PL))
                        if(caml_string_notequal(str,cst_VC))
                         if(caml_string_notequal(str,cst_VS))
                          switch$1 = 1;
                         else
                          var _kp_=[0,_a1_,i$0 + 2 | 0];
                        else
                         var _kp_=[0,_a2_,i$0 + 2 | 0];
                       else
                        var _kp_=[0,_a3_,i$0 + 2 | 0];
                      else
                       var _kp_=[0,_a4_,i$0 + 2 | 0];
                     else
                      var _kp_=[0,_a5_,i$0 + 2 | 0];
                    else
                     var _kp_=[0,_a6_,i$0 + 2 | 0];
                   else
                    var _kp_=[0,_a7_,i$0 + 2 | 0];
                  else
                   var _kp_=[0,_a8_,i$0 + 2 | 0];
                 else
                  var _kp_=[0,_a9_,i$0 + 2 | 0];
                else
                 if(caml_string_notequal(str,cst_AL))
                  if(caml_string_notequal(str,cst_CC))
                   if(caml_string_notequal(str,cst_CS))
                    if(caml_string_notequal(str,cst_EQ))
                     if(caml_string_notequal(str,cst_GE))
                      if(caml_string_notequal(str,cst_GT))
                       if(caml_string_notequal(str,cst_HI))
                        if(caml_string_notequal(str,cst_HS))
                         switch$1 = 1;
                        else
                         var _kp_=[0,_a__,i$0 + 2 | 0];
                       else
                        var _kp_=[0,_a$_,i$0 + 2 | 0];
                      else
                       var _kp_=[0,_ba_,i$0 + 2 | 0];
                     else
                      var _kp_=[0,_bb_,i$0 + 2 | 0];
                    else
                     var _kp_=[0,_bc_,i$0 + 2 | 0];
                   else
                    var _kp_=[0,_bd_,i$0 + 2 | 0];
                  else
                   var _kp_=[0,_be_,i$0 + 2 | 0];
                 else
                  var _kp_=[0,_bf_,i$0 + 2 | 0];
                if(switch$1)var _kp_=[0,0,i$0];
                var _kq_=_kp_[1];
                if(_kq_)
                 var i$1=_kp_[2],c=_kq_[1],i$2=i$1,nmods=[0,[0,c],0,0,0];
                else
                 {var
                   i$3=_kp_[2],
                   n$0=caml_ml_string_length(str$3),
                   _km_=caml_call2(Stdlib[16],2,n$0 - i$3 | 0),
                   str$0=caml_call3(Stdlib_string[9],str$3,i$3,_km_);
                  if(caml_string_notequal(str$0,cst_BT))
                   if(caml_string_notequal(str$0,cst_SB))
                    if(caml_string_notequal(str$0,cst_SH))
                     var
                      _kn_=caml_call2(Stdlib[16],1,n$0 - i$3 | 0),
                      str$1=caml_call3(Stdlib_string[9],str$0,0,_kn_),
                      _kr_=
                       caml_string_notequal(str$1,cst_B)
                        ?caml_string_notequal(str$1,cst_H)
                          ?caml_string_notequal(str$1,cst_T)
                            ?caml_string_notequal(str$1,cst_W)
                              ?[0,0,i$3]
                              :[0,_bg_,i$3 + 1 | 0]
                            :[0,_bh_,i$3 + 1 | 0]
                          :[0,_bi_,i$3 + 1 | 0]
                        :[0,_bj_,i$3 + 1 | 0];
                    else
                     var _kr_=[0,_bk_,i$3 + 2 | 0];
                   else
                    var _kr_=[0,_bl_,i$3 + 2 | 0];
                  else
                   var _kr_=[0,_bm_,i$3 + 2 | 0];
                  var _ks_=_kr_[1];
                  if(_ks_)
                   var
                    i$4=_kr_[2],
                    lst$2=_ks_[1],
                    i$2=i$4,
                    nmods=[0,0,[0,lst$2],0,0];
                  else
                   {var
                     i$5=_kr_[2],
                     n$1=caml_ml_string_length(str$3),
                     _ko_=caml_call2(Stdlib[16],1,n$1 - i$5 | 0),
                     str$2=caml_call3(Stdlib_string[9],str$3,i$5,_ko_),
                     match=
                      caml_string_notequal(str$2,cst_L)
                       ?caml_string_notequal(str$2,cst_S)
                         ?[0,0,i$5]
                         :[0,_bn_,i$5 + 1 | 0]
                       :[0,_bo_,i$5 + 1 | 0],
                     _kt_=match[1],
                     switch$2=0;
                    if(_kt_)
                     {var _ku_=_kt_[1];
                      if(caml_string_notequal(_ku_,cst_L$0))
                       if(caml_string_notequal(_ku_,cst_S$0))
                        switch$2 = 1;
                       else
                        var i$6=match[2],i$2=i$6,nmods=_bp_;
                      else
                       var i$7=match[2],i$2=i$7,nmods=_bq_}
                    else
                     switch$2 = 1;
                    if(switch$2)throw StructError}}
                var
                 l=nmods[4],
                 s=nmods[3],
                 lst=nmods[2],
                 cond=nmods[1],
                 l$0=mods$1[4],
                 s$0=mods$1[3],
                 lst$0=mods$1[2],
                 cond$0=mods$1[1],
                 cond$1=combine_opt(cond$0,cond),
                 lst$1=combine_opt(lst$0,lst),
                 s$1=combine_bool(s$0,s),
                 l$1=combine_bool(l$0,l),
                 mods$0=[0,cond$1,lst$1,s$1,l$1],
                 mods$1=mods$0,
                 i$0=i$2;
                continue}},
           register_of_str=
            function(str)
             {var
               str$0=caml_call1(Stdlib_string[16],str),
               switch$0=caml_string_compare(str$0,cst_r15);
              if(0 <= switch$0)
               {if(! (0 < switch$0))return 15;
                var switch$1=caml_string_compare(str$0,cst_r7);
                if(0 <= switch$1)
                 {if(! (0 < switch$1))return 7;
                  if(! caml_string_notequal(str$0,cst_r8))return 8;
                  if(! caml_string_notequal(str$0,cst_r9))return 9;
                  if(! caml_string_notequal(str$0,cst_sb))return sb;
                  if(! caml_string_notequal(str$0,cst_sl))return sl;
                  if(! caml_string_notequal(str$0,cst_sp))return sp}
                else
                 {if(! caml_string_notequal(str$0,cst_r2))return 2;
                  if(! caml_string_notequal(str$0,cst_r3))return 3;
                  if(! caml_string_notequal(str$0,cst_r4))return 4;
                  if(! caml_string_notequal(str$0,cst_r5))return 5;
                  if(! caml_string_notequal(str$0,cst_r6))return 6}}
              else
               {var switch$2=caml_string_compare(str$0,cst_r1);
                if(0 <= switch$2)
                 {if(! (0 < switch$2))return 1;
                  if(! caml_string_notequal(str$0,cst_r10))return 10;
                  if(! caml_string_notequal(str$0,cst_r11))return 11;
                  if(! caml_string_notequal(str$0,cst_r12))return 12;
                  if(! caml_string_notequal(str$0,cst_r13))return 13;
                  if(! caml_string_notequal(str$0,cst_r14))return 14}
                else
                 {if(! caml_string_notequal(str$0,cst_fp))return fp;
                  if(! caml_string_notequal(str$0,cst_ip))return ip;
                  if(! caml_string_notequal(str$0,cst_lr))return lr;
                  if(! caml_string_notequal(str$0,cst_pc))return pc;
                  if(! caml_string_notequal(str$0,cst_r0))return 0}}
              throw StructError},
           get_register=
            function(arg)
             {if(0 === arg[0]){var str=arg[1];return register_of_str(str)}
              throw StructError},
           get_rd=
            function(args)
             {return get_register(caml_call1(Stdlib_list[5],args))},
           get_rn=
            function(args)
             {var n=caml_call1(Stdlib_list[1],args);
              return get_register(caml_call2(Stdlib_list[7],args,n - 2 | 0))},
           get_op2=
            function(env,args)
             {var
               n=caml_call1(Stdlib_list[1],args),
               arg=caml_call2(Stdlib_list[7],args,n - 1 | 0);
              switch(arg[0])
               {case 0:var str=arg[1];return [1,register_of_str(str)];
                case 1:var i=arg[1];return [0,preprocess(env,i)];
                default:throw StructError}},
           get_ro=
            function(env,args)
             {var
               n=caml_call1(Stdlib_list[1],args),
               match=caml_call2(Stdlib_list[7],args,n - 1 | 0);
              if(2 === match[0])
               {var
                 addr_typ=match[3],
                 offset=match[2],
                 str=match[1],
                 r=register_of_str(str);
                if(0 === offset[0])
                 var
                  i=offset[2],
                  sign=offset[1],
                  ro=[0,r,sign,preprocess(env,i)];
                else
                 var
                  str$0=offset[2],
                  sign$0=offset[1],
                  ro=[1,r,sign$0,register_of_str(str$0)];
                return [0,ro,addr_typ]}
              throw StructError},
           get_target=
            function(env,args)
             {var arg=caml_call1(Stdlib_list[5],args);
              if(1 === arg[0]){var i=arg[1];return preprocess(env,i)}
              throw StructError},
           cmd_to_arm=
            function(env,cmd$1)
             {if(0 === cmd$1[0])
               {var
                 optimize=cmd$1[4],
                 args=cmd$1[3],
                 cmd$2=cmd$1[2],
                 pos=cmd$1[1];
                try
                 {try
                   {if(caml_ml_string_length(cmd$2) < 3)throw StructError;
                    var
                     cmd=caml_call1(Stdlib_string[15],cmd$2),
                     match=recognize_modifiers(cmd,3),
                     s=match[3],
                     typ=match[2],
                     cond=match[1];
                    if(cond)var c=cond[1],cond$0=c;else var cond$0=16;
                    if(typ)var typ$0=typ[1],typ$1=typ$0;else var typ$1=4;
                    try
                     {var match$0=caml_call3(Stdlib_string[9],cmd,0,3);
                      if(caml_string_notequal(match$0,cst_ADC))
                       if(caml_string_notequal(match$0,cst_AND))
                        if(caml_string_notequal(match$0,cst_BIC))
                         if(caml_string_notequal(match$0,cst_LDR))
                          if(caml_string_notequal(match$0,cst_MOV))
                           if(caml_string_notequal(match$0,cst_MVN))
                            if(caml_string_notequal(match$0,cst_SBC))
                             {if(caml_string_notequal(match$0,cst_STR))throw StructError;
                              var
                               _j3_=get_ro(env,args),
                               _j4_=[2,typ$1,cond$0,get_rd(args),_j3_]}
                            else
                             var
                              _j5_=get_op2(env,args),
                              _j6_=get_rn(args),
                              _j4_=[6,s,cond$0,get_rd(args),_j6_,_j5_];
                           else
                            var
                             _j7_=get_op2(env,args),
                             _j4_=[4,s,cond$0,get_rd(args),_j7_];
                          else
                           var
                            _j8_=get_op2(env,args),
                            _j4_=[3,s,cond$0,get_rd(args),_j8_];
                         else
                          var
                           _j9_=get_ro(env,args),
                           _j4_=[1,typ$1,cond$0,get_rd(args),_j9_];
                        else
                         var
                          _j__=get_op2(env,args),
                          _j$_=get_rn(args),
                          _j4_=[7,s,cond$0,get_rd(args),_j$_,_j__];
                       else
                        var
                         _ka_=get_op2(env,args),
                         _kb_=get_rn(args),
                         _j4_=[8,s,cond$0,get_rd(args),_kb_,_ka_];
                      else
                       var
                        _kc_=get_op2(env,args),
                        _kd_=get_rn(args),
                        _j4_=[5,s,cond$0,get_rd(args),_kd_,_kc_]}
                    catch(_kk_)
                     {_kk_ = caml_wrap_exception(_kk_);
                      if(_kk_[1] !== Stdlib[7] && _kk_[1] !== Stdlib[6])
                       throw _kk_;
                      throw StructError}
                    var _kf_=_j4_}
                  catch(_ki_)
                   {_ki_ = caml_wrap_exception(_ki_);
                    if(_ki_ !== StructError)throw _ki_;
                    if(caml_ml_string_length(cmd$2) < 1)throw StructError;
                    var
                     cmd$0=caml_call1(Stdlib_string[15],cmd$2),
                     match$1=recognize_modifiers(cmd$0,1),
                     l=match$1[4],
                     cond$1=match$1[1];
                    if(cond$1)var c$0=cond$1[1],cond$2=c$0;else var cond$2=16;
                    try
                     {var match$2=caml_call3(Stdlib_string[9],cmd$0,0,1);
                      if(caml_string_notequal(match$2,cst_B$0))throw StructError;
                      var _ke_=[9,l,cond$2,get_target(env,args)]}
                    catch(_kj_)
                     {_kj_ = caml_wrap_exception(_kj_);
                      if(_kj_[1] !== Stdlib[7] && _kj_[1] !== Stdlib[6])
                       throw _kj_;
                      throw StructError}
                    var _kf_=_ke_}
                  var _kg_=[0,_kf_,optimize];
                  return _kg_}
                catch(_kh_)
                 {_kh_ = caml_wrap_exception(_kh_);
                  if(_kh_ === StructError)throw [0,CommandError,pos];
                  throw _kh_}}
              var i=cmd$1[2];
              return [0,[0,preprocess(env,i)],0]},
           to_arm=
            function(env,ast)
             {function _j1_(_j2_){return cmd_to_arm(env,_j2_)}
              return caml_call2(Stdlib_list[19],_j1_,ast)},
           Parser_ast=[0,CommandError,to_arm];
          caml_register_global(478,Parser_ast,"Parser_ast");
          var
           eRR=[248,cst_Parser_MenhirBasics_Error,caml_fresh_oo_id(0)],
           menhir_discard=
            function(menhir_env)
             {var
               lexer=menhir_env[1],
               lexbuf=menhir_env[2],
               tok=caml_call1(lexer,lexbuf);
              return [0,lexer,lexbuf,tok,0]},
           menhir_errorcase=
            function(menhir_env,menhir_stack,menhir_s)
             {var menhir_stack$0=menhir_stack,menhir_s$0=menhir_s;
              for(;;)
               switch(menhir_s$0)
                {case 0:
                  var
                   match=menhir_stack$0[1],
                   menhir_s$1=match[2],
                   menhir_stack$1=match[1],
                   menhir_stack$0=menhir_stack$1,
                   menhir_s$0=menhir_s$1;
                  continue;
                 case 1:throw eRR;
                 case 2:throw eRR;
                 case 3:throw eRR;
                 case 4:
                  var
                   menhir_s$2=menhir_stack$0[2],
                   menhir_stack$2=menhir_stack$0[1],
                   menhir_stack$0=menhir_stack$2,
                   menhir_s$0=menhir_s$2;
                  continue;
                 case 5:
                  var
                   menhir_s$3=menhir_stack$0[2],
                   menhir_stack$3=menhir_stack$0[1],
                   menhir_stack$0=menhir_stack$3,
                   menhir_s$0=menhir_s$3;
                  continue;
                 case 6:
                  var
                   menhir_s$4=menhir_stack$0[2],
                   menhir_stack$4=menhir_stack$0[1],
                   menhir_stack$0=menhir_stack$4,
                   menhir_s$0=menhir_s$4;
                  continue;
                 case 7:
                  var
                   match$0=menhir_stack$0[1],
                   menhir_s$5=match$0[2],
                   menhir_stack$5=match$0[1],
                   menhir_stack$0=menhir_stack$5,
                   menhir_s$0=menhir_s$5;
                  continue;
                 case 8:
                  var
                   menhir_s$6=menhir_stack$0[2],
                   menhir_stack$6=menhir_stack$0[1],
                   menhir_stack$0=menhir_stack$6,
                   menhir_s$0=menhir_s$6;
                  continue;
                 case 9:
                  var
                   menhir_s$7=menhir_stack$0[2],
                   menhir_stack$7=menhir_stack$0[1],
                   menhir_stack$0=menhir_stack$7,
                   menhir_s$0=menhir_s$7;
                  continue;
                 case 10:
                  var
                   menhir_s$8=menhir_stack$0[2],
                   menhir_stack$8=menhir_stack$0[1],
                   menhir_stack$0=menhir_stack$8,
                   menhir_s$0=menhir_s$8;
                  continue;
                 case 11:
                  var
                   menhir_s$9=menhir_stack$0[2],
                   menhir_stack$9=menhir_stack$0[1],
                   menhir_stack$0=menhir_stack$9,
                   menhir_s$0=menhir_s$9;
                  continue;
                 case 12:
                  var
                   menhir_s$10=menhir_stack$0[2],
                   menhir_stack$10=menhir_stack$0[1],
                   menhir_stack$0=menhir_stack$10,
                   menhir_s$0=menhir_s$10;
                  continue;
                 case 13:
                  var
                   match$1=menhir_stack$0[1],
                   menhir_s$11=match$1[2],
                   menhir_stack$11=match$1[1],
                   menhir_stack$0=menhir_stack$11,
                   menhir_s$0=menhir_s$11;
                  continue;
                 case 14:
                  var
                   menhir_s$12=menhir_stack$0[2],
                   menhir_stack$12=menhir_stack$0[1],
                   menhir_stack$0=menhir_stack$12,
                   menhir_s$0=menhir_s$12;
                  continue;
                 case 15:
                  var
                   menhir_s$13=menhir_stack$0[2],
                   menhir_stack$13=menhir_stack$0[1],
                   menhir_stack$0=menhir_stack$13,
                   menhir_s$0=menhir_s$13;
                  continue;
                 case 16:
                  var
                   menhir_s$14=menhir_stack$0[2],
                   menhir_stack$14=menhir_stack$0[1],
                   menhir_stack$0=menhir_stack$14,
                   menhir_s$0=menhir_s$14;
                  continue;
                 case 17:
                  var
                   menhir_s$15=menhir_stack$0[2],
                   menhir_stack$15=menhir_stack$0[1],
                   menhir_stack$0=menhir_stack$15,
                   menhir_s$0=menhir_s$15;
                  continue;
                 case 18:
                  var
                   menhir_s$16=menhir_stack$0[2],
                   menhir_stack$16=menhir_stack$0[1],
                   menhir_stack$0=menhir_stack$16,
                   menhir_s$0=menhir_s$16;
                  continue;
                 case 19:
                  var
                   menhir_s$17=menhir_stack$0[2],
                   menhir_stack$17=menhir_stack$0[1],
                   menhir_stack$0=menhir_stack$17,
                   menhir_s$0=menhir_s$17;
                  continue;
                 case 20:
                  var
                   menhir_s$18=menhir_stack$0[2],
                   menhir_stack$18=menhir_stack$0[1],
                   menhir_stack$0=menhir_stack$18,
                   menhir_s$0=menhir_s$18;
                  continue;
                 case 21:
                  var
                   menhir_s$19=menhir_stack$0[2],
                   menhir_stack$19=menhir_stack$0[1],
                   menhir_stack$0=menhir_stack$19,
                   menhir_s$0=menhir_s$19;
                  continue;
                 case 22:
                  var
                   menhir_s$20=menhir_stack$0[2],
                   menhir_stack$20=menhir_stack$0[1],
                   menhir_stack$0=menhir_stack$20,
                   menhir_s$0=menhir_s$20;
                  continue;
                 case 23:
                  var
                   menhir_s$21=menhir_stack$0[2],
                   menhir_stack$21=menhir_stack$0[1],
                   menhir_stack$0=menhir_stack$21,
                   menhir_s$0=menhir_s$21;
                  continue;
                 case 24:
                  var
                   menhir_s$22=menhir_stack$0[2],
                   menhir_stack$22=menhir_stack$0[1],
                   menhir_stack$0=menhir_stack$22,
                   menhir_s$0=menhir_s$22;
                  continue;
                 case 25:
                  var
                   menhir_s$23=menhir_stack$0[2],
                   menhir_stack$23=menhir_stack$0[1],
                   menhir_stack$0=menhir_stack$23,
                   menhir_s$0=menhir_s$23;
                  continue;
                 case 26:
                  var
                   menhir_s$24=menhir_stack$0[2],
                   menhir_stack$24=menhir_stack$0[1],
                   menhir_stack$0=menhir_stack$24,
                   menhir_s$0=menhir_s$24;
                  continue;
                 case 27:
                  var
                   menhir_s$25=menhir_stack$0[2],
                   menhir_stack$25=menhir_stack$0[1],
                   menhir_stack$0=menhir_stack$25,
                   menhir_s$0=menhir_s$25;
                  continue;
                 case 28:
                  var
                   menhir_s$26=menhir_stack$0[2],
                   menhir_stack$26=menhir_stack$0[1],
                   menhir_stack$0=menhir_stack$26,
                   menhir_s$0=menhir_s$26;
                  continue;
                 case 29:
                  var
                   menhir_s$27=menhir_stack$0[2],
                   menhir_stack$27=menhir_stack$0[1],
                   menhir_stack$0=menhir_stack$27,
                   menhir_s$0=menhir_s$27;
                  continue;
                 case 30:
                  var
                   menhir_s$28=menhir_stack$0[2],
                   menhir_stack$28=menhir_stack$0[1],
                   menhir_stack$0=menhir_stack$28,
                   menhir_s$0=menhir_s$28;
                  continue;
                 case 31:
                  var
                   menhir_s$29=menhir_stack$0[2],
                   menhir_stack$29=menhir_stack$0[1],
                   menhir_stack$0=menhir_stack$29,
                   menhir_s$0=menhir_s$29;
                  continue;
                 case 32:
                  var
                   menhir_s$30=menhir_stack$0[2],
                   menhir_stack$30=menhir_stack$0[1],
                   menhir_stack$0=menhir_stack$30,
                   menhir_s$0=menhir_s$30;
                  continue;
                 case 33:
                  var
                   menhir_s$31=menhir_stack$0[2],
                   menhir_stack$31=menhir_stack$0[1],
                   menhir_stack$0=menhir_stack$31,
                   menhir_s$0=menhir_s$31;
                  continue;
                 case 34:
                  var
                   menhir_s$32=menhir_stack$0[2],
                   menhir_stack$32=menhir_stack$0[1],
                   menhir_stack$0=menhir_stack$32,
                   menhir_s$0=menhir_s$32;
                  continue;
                 case 35:
                  var
                   menhir_s$33=menhir_stack$0[2],
                   menhir_stack$33=menhir_stack$0[1],
                   menhir_stack$0=menhir_stack$33,
                   menhir_s$0=menhir_s$33;
                  continue;
                 case 36:
                  var
                   menhir_s$34=menhir_stack$0[2],
                   menhir_stack$34=menhir_stack$0[1],
                   menhir_stack$0=menhir_stack$34,
                   menhir_s$0=menhir_s$34;
                  continue;
                 case 37:
                  var
                   menhir_s$35=menhir_stack$0[2],
                   menhir_stack$35=menhir_stack$0[1],
                   menhir_stack$0=menhir_stack$35,
                   menhir_s$0=menhir_s$35;
                  continue;
                 case 38:
                  var
                   menhir_s$36=menhir_stack$0[2],
                   menhir_stack$36=menhir_stack$0[1],
                   menhir_stack$0=menhir_stack$36,
                   menhir_s$0=menhir_s$36;
                  continue;
                 default:throw eRR}},
           menhir_fail=
            function(param)
             {caml_call2(Stdlib_printf[1],Stdlib[40],_cr_);
              throw [0,Assert_failure,_cs_]},
           menhir_goto_ast=
            function(menhir_env,menhir_stack,menhir_s,v)
             {var menhir_stack$0=menhir_stack,menhir_s$0=menhir_s,v$0=v;
              for(;;)
               {if(4 === menhir_s$0)
                 {var
                   cmd=menhir_stack$0[3],
                   match=menhir_stack$0[1],
                   menhir_s$1=match[2],
                   menhir_stack$1=match[1],
                   v$1=[0,cmd,v$0],
                   menhir_stack$0=menhir_stack$1,
                   menhir_s$0=menhir_s$1,
                   v$0=v$1;
                  continue}
                return 39 <= menhir_s$0?v$0:menhir_fail(0)}},
           menhir_goto_headers=
            function(menhir_env,menhir_stack,menhir_s,v)
             {var menhir_stack$0=menhir_stack,menhir_s$0=menhir_s,v$0=v;
              for(;;)
               {if(3 === menhir_s$0)return v$0;
                if(menhir_s$0)return menhir_fail(0);
                var
                 d=menhir_stack$0[2],
                 match=menhir_stack$0[1],
                 menhir_s$1=match[2],
                 menhir_stack$1=match[1],
                 v$1=[0,d,v$0],
                 menhir_stack$0=menhir_stack$1,
                 menhir_s$0=menhir_s$1,
                 v$0=v$1;
                continue}},
           menhir_run15=
            function(counter,menhir_env,menhir_stack)
             {var menhir_env$0=menhir_discard(menhir_env),tok=menhir_env$0[3];
              if(typeof tok === "number")
               switch(tok)
                {case 6:
                  var _jS_=30;
                  if(counter < 50)
                   {var counter$6=counter + 1 | 0;
                    return menhir_run6(counter$6,menhir_env$0,menhir_stack,_jS_)}
                  return caml_trampoline_return
                          (menhir_run6,[0,menhir_env$0,menhir_stack,_jS_]);
                 case 9:
                  var _jT_=30;
                  if(counter < 50)
                   {var counter$4=counter + 1 | 0;
                    return menhir_run8(counter$4,menhir_env$0,menhir_stack,_jT_)}
                  return caml_trampoline_return
                          (menhir_run8,[0,menhir_env$0,menhir_stack,_jT_]);
                 case 12:
                  var _jU_=30;
                  if(counter < 50)
                   {var counter$3=counter + 1 | 0;
                    return menhir_run9(counter$3,menhir_env$0,menhir_stack,_jU_)}
                  return caml_trampoline_return
                          (menhir_run9,[0,menhir_env$0,menhir_stack,_jU_]);
                 case 14:
                  var _jV_=30;
                  if(counter < 50)
                   {var counter$2=counter + 1 | 0;
                    return menhir_run10
                            (counter$2,menhir_env$0,menhir_stack,_jV_)}
                  return caml_trampoline_return
                          (menhir_run10,[0,menhir_env$0,menhir_stack,_jV_]);
                 case 20:
                  var _jW_=30;
                  if(counter < 50)
                   {var counter$0=counter + 1 | 0;
                    return menhir_run12
                            (counter$0,menhir_env$0,menhir_stack,_jW_)}
                  return caml_trampoline_return
                          (menhir_run12,[0,menhir_env$0,menhir_stack,_jW_])
                 }
              else
               switch(tok[0])
                {case 1:
                  var v=tok[1],_jX_=menhir_env$0[2][11],_jY_=30;
                  if(counter < 50)
                   {var counter$5=counter + 1 | 0;
                    return menhir_run7
                            (counter$5,menhir_env$0,menhir_stack,_jY_,v,_jX_)}
                  return caml_trampoline_return
                          (menhir_run7,[0,menhir_env$0,menhir_stack,_jY_,v,_jX_]);
                 case 2:
                  var v$0=tok[1],_jZ_=menhir_env$0[2][11],_j0_=30;
                  if(counter < 50)
                   {var counter$1=counter + 1 | 0;
                    return menhir_run11
                            (counter$1,menhir_env$0,menhir_stack,_j0_,v$0,_jZ_)}
                  return caml_trampoline_return
                          (menhir_run11,[0,menhir_env$0,menhir_stack,_j0_,v$0,_jZ_])
                 }
              if(menhir_env$0[4])throw [0,Assert_failure,_br_];
              menhir_env$0[4] = 1;
              return menhir_errorcase(menhir_env$0,menhir_stack,30)},
           menhir_run17=
            function(counter,menhir_env,menhir_stack)
             {var menhir_env$0=menhir_discard(menhir_env),tok=menhir_env$0[3];
              if(typeof tok === "number")
               switch(tok)
                {case 6:
                  var _jJ_=29;
                  if(counter < 50)
                   {var counter$6=counter + 1 | 0;
                    return menhir_run6(counter$6,menhir_env$0,menhir_stack,_jJ_)}
                  return caml_trampoline_return
                          (menhir_run6,[0,menhir_env$0,menhir_stack,_jJ_]);
                 case 9:
                  var _jK_=29;
                  if(counter < 50)
                   {var counter$4=counter + 1 | 0;
                    return menhir_run8(counter$4,menhir_env$0,menhir_stack,_jK_)}
                  return caml_trampoline_return
                          (menhir_run8,[0,menhir_env$0,menhir_stack,_jK_]);
                 case 12:
                  var _jL_=29;
                  if(counter < 50)
                   {var counter$3=counter + 1 | 0;
                    return menhir_run9(counter$3,menhir_env$0,menhir_stack,_jL_)}
                  return caml_trampoline_return
                          (menhir_run9,[0,menhir_env$0,menhir_stack,_jL_]);
                 case 14:
                  var _jM_=29;
                  if(counter < 50)
                   {var counter$2=counter + 1 | 0;
                    return menhir_run10
                            (counter$2,menhir_env$0,menhir_stack,_jM_)}
                  return caml_trampoline_return
                          (menhir_run10,[0,menhir_env$0,menhir_stack,_jM_]);
                 case 20:
                  var _jN_=29;
                  if(counter < 50)
                   {var counter$0=counter + 1 | 0;
                    return menhir_run12
                            (counter$0,menhir_env$0,menhir_stack,_jN_)}
                  return caml_trampoline_return
                          (menhir_run12,[0,menhir_env$0,menhir_stack,_jN_])
                 }
              else
               switch(tok[0])
                {case 1:
                  var v=tok[1],_jO_=menhir_env$0[2][11],_jP_=29;
                  if(counter < 50)
                   {var counter$5=counter + 1 | 0;
                    return menhir_run7
                            (counter$5,menhir_env$0,menhir_stack,_jP_,v,_jO_)}
                  return caml_trampoline_return
                          (menhir_run7,[0,menhir_env$0,menhir_stack,_jP_,v,_jO_]);
                 case 2:
                  var v$0=tok[1],_jQ_=menhir_env$0[2][11],_jR_=29;
                  if(counter < 50)
                   {var counter$1=counter + 1 | 0;
                    return menhir_run11
                            (counter$1,menhir_env$0,menhir_stack,_jR_,v$0,_jQ_)}
                  return caml_trampoline_return
                          (menhir_run11,[0,menhir_env$0,menhir_stack,_jR_,v$0,_jQ_])
                 }
              if(menhir_env$0[4])throw [0,Assert_failure,_bs_];
              menhir_env$0[4] = 1;
              return menhir_errorcase(menhir_env$0,menhir_stack,29)},
           menhir_run19=
            function(counter,menhir_env,menhir_stack)
             {var menhir_env$0=menhir_discard(menhir_env),tok=menhir_env$0[3];
              if(typeof tok === "number")
               switch(tok)
                {case 6:
                  var _jA_=28;
                  if(counter < 50)
                   {var counter$6=counter + 1 | 0;
                    return menhir_run6(counter$6,menhir_env$0,menhir_stack,_jA_)}
                  return caml_trampoline_return
                          (menhir_run6,[0,menhir_env$0,menhir_stack,_jA_]);
                 case 9:
                  var _jB_=28;
                  if(counter < 50)
                   {var counter$4=counter + 1 | 0;
                    return menhir_run8(counter$4,menhir_env$0,menhir_stack,_jB_)}
                  return caml_trampoline_return
                          (menhir_run8,[0,menhir_env$0,menhir_stack,_jB_]);
                 case 12:
                  var _jC_=28;
                  if(counter < 50)
                   {var counter$3=counter + 1 | 0;
                    return menhir_run9(counter$3,menhir_env$0,menhir_stack,_jC_)}
                  return caml_trampoline_return
                          (menhir_run9,[0,menhir_env$0,menhir_stack,_jC_]);
                 case 14:
                  var _jD_=28;
                  if(counter < 50)
                   {var counter$2=counter + 1 | 0;
                    return menhir_run10
                            (counter$2,menhir_env$0,menhir_stack,_jD_)}
                  return caml_trampoline_return
                          (menhir_run10,[0,menhir_env$0,menhir_stack,_jD_]);
                 case 20:
                  var _jE_=28;
                  if(counter < 50)
                   {var counter$0=counter + 1 | 0;
                    return menhir_run12
                            (counter$0,menhir_env$0,menhir_stack,_jE_)}
                  return caml_trampoline_return
                          (menhir_run12,[0,menhir_env$0,menhir_stack,_jE_])
                 }
              else
               switch(tok[0])
                {case 1:
                  var v=tok[1],_jF_=menhir_env$0[2][11],_jG_=28;
                  if(counter < 50)
                   {var counter$5=counter + 1 | 0;
                    return menhir_run7
                            (counter$5,menhir_env$0,menhir_stack,_jG_,v,_jF_)}
                  return caml_trampoline_return
                          (menhir_run7,[0,menhir_env$0,menhir_stack,_jG_,v,_jF_]);
                 case 2:
                  var v$0=tok[1],_jH_=menhir_env$0[2][11],_jI_=28;
                  if(counter < 50)
                   {var counter$1=counter + 1 | 0;
                    return menhir_run11
                            (counter$1,menhir_env$0,menhir_stack,_jI_,v$0,_jH_)}
                  return caml_trampoline_return
                          (menhir_run11,[0,menhir_env$0,menhir_stack,_jI_,v$0,_jH_])
                 }
              if(menhir_env$0[4])throw [0,Assert_failure,_bt_];
              menhir_env$0[4] = 1;
              return menhir_errorcase(menhir_env$0,menhir_stack,28)},
           menhir_run21=
            function(counter,menhir_env,menhir_stack)
             {var menhir_env$0=menhir_discard(menhir_env),tok=menhir_env$0[3];
              if(typeof tok === "number")
               switch(tok)
                {case 6:
                  var _jr_=27;
                  if(counter < 50)
                   {var counter$6=counter + 1 | 0;
                    return menhir_run6(counter$6,menhir_env$0,menhir_stack,_jr_)}
                  return caml_trampoline_return
                          (menhir_run6,[0,menhir_env$0,menhir_stack,_jr_]);
                 case 9:
                  var _js_=27;
                  if(counter < 50)
                   {var counter$4=counter + 1 | 0;
                    return menhir_run8(counter$4,menhir_env$0,menhir_stack,_js_)}
                  return caml_trampoline_return
                          (menhir_run8,[0,menhir_env$0,menhir_stack,_js_]);
                 case 12:
                  var _jt_=27;
                  if(counter < 50)
                   {var counter$3=counter + 1 | 0;
                    return menhir_run9(counter$3,menhir_env$0,menhir_stack,_jt_)}
                  return caml_trampoline_return
                          (menhir_run9,[0,menhir_env$0,menhir_stack,_jt_]);
                 case 14:
                  var _ju_=27;
                  if(counter < 50)
                   {var counter$2=counter + 1 | 0;
                    return menhir_run10
                            (counter$2,menhir_env$0,menhir_stack,_ju_)}
                  return caml_trampoline_return
                          (menhir_run10,[0,menhir_env$0,menhir_stack,_ju_]);
                 case 20:
                  var _jv_=27;
                  if(counter < 50)
                   {var counter$0=counter + 1 | 0;
                    return menhir_run12
                            (counter$0,menhir_env$0,menhir_stack,_jv_)}
                  return caml_trampoline_return
                          (menhir_run12,[0,menhir_env$0,menhir_stack,_jv_])
                 }
              else
               switch(tok[0])
                {case 1:
                  var v=tok[1],_jw_=menhir_env$0[2][11],_jx_=27;
                  if(counter < 50)
                   {var counter$5=counter + 1 | 0;
                    return menhir_run7
                            (counter$5,menhir_env$0,menhir_stack,_jx_,v,_jw_)}
                  return caml_trampoline_return
                          (menhir_run7,[0,menhir_env$0,menhir_stack,_jx_,v,_jw_]);
                 case 2:
                  var v$0=tok[1],_jy_=menhir_env$0[2][11],_jz_=27;
                  if(counter < 50)
                   {var counter$1=counter + 1 | 0;
                    return menhir_run11
                            (counter$1,menhir_env$0,menhir_stack,_jz_,v$0,_jy_)}
                  return caml_trampoline_return
                          (menhir_run11,[0,menhir_env$0,menhir_stack,_jz_,v$0,_jy_])
                 }
              if(menhir_env$0[4])throw [0,Assert_failure,_bu_];
              menhir_env$0[4] = 1;
              return menhir_errorcase(menhir_env$0,menhir_stack,27)},
           menhir_run38=
            function(counter,menhir_env,menhir_stack)
             {var menhir_env$0=menhir_discard(menhir_env),tok=menhir_env$0[3];
              if(typeof tok === "number")
               switch(tok)
                {case 6:
                  var _ji_=19;
                  if(counter < 50)
                   {var counter$6=counter + 1 | 0;
                    return menhir_run6(counter$6,menhir_env$0,menhir_stack,_ji_)}
                  return caml_trampoline_return
                          (menhir_run6,[0,menhir_env$0,menhir_stack,_ji_]);
                 case 9:
                  var _jj_=19;
                  if(counter < 50)
                   {var counter$4=counter + 1 | 0;
                    return menhir_run8(counter$4,menhir_env$0,menhir_stack,_jj_)}
                  return caml_trampoline_return
                          (menhir_run8,[0,menhir_env$0,menhir_stack,_jj_]);
                 case 12:
                  var _jk_=19;
                  if(counter < 50)
                   {var counter$3=counter + 1 | 0;
                    return menhir_run9(counter$3,menhir_env$0,menhir_stack,_jk_)}
                  return caml_trampoline_return
                          (menhir_run9,[0,menhir_env$0,menhir_stack,_jk_]);
                 case 14:
                  var _jl_=19;
                  if(counter < 50)
                   {var counter$2=counter + 1 | 0;
                    return menhir_run10
                            (counter$2,menhir_env$0,menhir_stack,_jl_)}
                  return caml_trampoline_return
                          (menhir_run10,[0,menhir_env$0,menhir_stack,_jl_]);
                 case 20:
                  var _jm_=19;
                  if(counter < 50)
                   {var counter$0=counter + 1 | 0;
                    return menhir_run12
                            (counter$0,menhir_env$0,menhir_stack,_jm_)}
                  return caml_trampoline_return
                          (menhir_run12,[0,menhir_env$0,menhir_stack,_jm_])
                 }
              else
               switch(tok[0])
                {case 1:
                  var v=tok[1],_jn_=menhir_env$0[2][11],_jo_=19;
                  if(counter < 50)
                   {var counter$5=counter + 1 | 0;
                    return menhir_run7
                            (counter$5,menhir_env$0,menhir_stack,_jo_,v,_jn_)}
                  return caml_trampoline_return
                          (menhir_run7,[0,menhir_env$0,menhir_stack,_jo_,v,_jn_]);
                 case 2:
                  var v$0=tok[1],_jp_=menhir_env$0[2][11],_jq_=19;
                  if(counter < 50)
                   {var counter$1=counter + 1 | 0;
                    return menhir_run11
                            (counter$1,menhir_env$0,menhir_stack,_jq_,v$0,_jp_)}
                  return caml_trampoline_return
                          (menhir_run11,[0,menhir_env$0,menhir_stack,_jq_,v$0,_jp_])
                 }
              if(menhir_env$0[4])throw [0,Assert_failure,_bv_];
              menhir_env$0[4] = 1;
              return menhir_errorcase(menhir_env$0,menhir_stack,19)},
           menhir_run29=
            function(counter,menhir_env,menhir_stack)
             {var menhir_env$0=menhir_discard(menhir_env),tok=menhir_env$0[3];
              if(typeof tok === "number")
               switch(tok)
                {case 6:
                  var _i$_=23;
                  if(counter < 50)
                   {var counter$6=counter + 1 | 0;
                    return menhir_run6(counter$6,menhir_env$0,menhir_stack,_i$_)}
                  return caml_trampoline_return
                          (menhir_run6,[0,menhir_env$0,menhir_stack,_i$_]);
                 case 9:
                  var _ja_=23;
                  if(counter < 50)
                   {var counter$4=counter + 1 | 0;
                    return menhir_run8(counter$4,menhir_env$0,menhir_stack,_ja_)}
                  return caml_trampoline_return
                          (menhir_run8,[0,menhir_env$0,menhir_stack,_ja_]);
                 case 12:
                  var _jb_=23;
                  if(counter < 50)
                   {var counter$3=counter + 1 | 0;
                    return menhir_run9(counter$3,menhir_env$0,menhir_stack,_jb_)}
                  return caml_trampoline_return
                          (menhir_run9,[0,menhir_env$0,menhir_stack,_jb_]);
                 case 14:
                  var _jc_=23;
                  if(counter < 50)
                   {var counter$2=counter + 1 | 0;
                    return menhir_run10
                            (counter$2,menhir_env$0,menhir_stack,_jc_)}
                  return caml_trampoline_return
                          (menhir_run10,[0,menhir_env$0,menhir_stack,_jc_]);
                 case 20:
                  var _jd_=23;
                  if(counter < 50)
                   {var counter$0=counter + 1 | 0;
                    return menhir_run12
                            (counter$0,menhir_env$0,menhir_stack,_jd_)}
                  return caml_trampoline_return
                          (menhir_run12,[0,menhir_env$0,menhir_stack,_jd_])
                 }
              else
               switch(tok[0])
                {case 1:
                  var v=tok[1],_je_=menhir_env$0[2][11],_jf_=23;
                  if(counter < 50)
                   {var counter$5=counter + 1 | 0;
                    return menhir_run7
                            (counter$5,menhir_env$0,menhir_stack,_jf_,v,_je_)}
                  return caml_trampoline_return
                          (menhir_run7,[0,menhir_env$0,menhir_stack,_jf_,v,_je_]);
                 case 2:
                  var v$0=tok[1],_jg_=menhir_env$0[2][11],_jh_=23;
                  if(counter < 50)
                   {var counter$1=counter + 1 | 0;
                    return menhir_run11
                            (counter$1,menhir_env$0,menhir_stack,_jh_,v$0,_jg_)}
                  return caml_trampoline_return
                          (menhir_run11,[0,menhir_env$0,menhir_stack,_jh_,v$0,_jg_])
                 }
              if(menhir_env$0[4])throw [0,Assert_failure,_bw_];
              menhir_env$0[4] = 1;
              return menhir_errorcase(menhir_env$0,menhir_stack,23)},
           menhir_run23=
            function(counter,menhir_env,menhir_stack)
             {var menhir_env$0=menhir_discard(menhir_env),tok=menhir_env$0[3];
              if(typeof tok === "number")
               switch(tok)
                {case 6:
                  var _i2_=26;
                  if(counter < 50)
                   {var counter$6=counter + 1 | 0;
                    return menhir_run6(counter$6,menhir_env$0,menhir_stack,_i2_)}
                  return caml_trampoline_return
                          (menhir_run6,[0,menhir_env$0,menhir_stack,_i2_]);
                 case 9:
                  var _i3_=26;
                  if(counter < 50)
                   {var counter$4=counter + 1 | 0;
                    return menhir_run8(counter$4,menhir_env$0,menhir_stack,_i3_)}
                  return caml_trampoline_return
                          (menhir_run8,[0,menhir_env$0,menhir_stack,_i3_]);
                 case 12:
                  var _i4_=26;
                  if(counter < 50)
                   {var counter$3=counter + 1 | 0;
                    return menhir_run9(counter$3,menhir_env$0,menhir_stack,_i4_)}
                  return caml_trampoline_return
                          (menhir_run9,[0,menhir_env$0,menhir_stack,_i4_]);
                 case 14:
                  var _i5_=26;
                  if(counter < 50)
                   {var counter$2=counter + 1 | 0;
                    return menhir_run10
                            (counter$2,menhir_env$0,menhir_stack,_i5_)}
                  return caml_trampoline_return
                          (menhir_run10,[0,menhir_env$0,menhir_stack,_i5_]);
                 case 20:
                  var _i6_=26;
                  if(counter < 50)
                   {var counter$0=counter + 1 | 0;
                    return menhir_run12
                            (counter$0,menhir_env$0,menhir_stack,_i6_)}
                  return caml_trampoline_return
                          (menhir_run12,[0,menhir_env$0,menhir_stack,_i6_])
                 }
              else
               switch(tok[0])
                {case 1:
                  var v=tok[1],_i7_=menhir_env$0[2][11],_i8_=26;
                  if(counter < 50)
                   {var counter$5=counter + 1 | 0;
                    return menhir_run7
                            (counter$5,menhir_env$0,menhir_stack,_i8_,v,_i7_)}
                  return caml_trampoline_return
                          (menhir_run7,[0,menhir_env$0,menhir_stack,_i8_,v,_i7_]);
                 case 2:
                  var v$0=tok[1],_i9_=menhir_env$0[2][11],_i__=26;
                  if(counter < 50)
                   {var counter$1=counter + 1 | 0;
                    return menhir_run11
                            (counter$1,menhir_env$0,menhir_stack,_i__,v$0,_i9_)}
                  return caml_trampoline_return
                          (menhir_run11,[0,menhir_env$0,menhir_stack,_i__,v$0,_i9_])
                 }
              if(menhir_env$0[4])throw [0,Assert_failure,_bx_];
              menhir_env$0[4] = 1;
              return menhir_errorcase(menhir_env$0,menhir_stack,26)},
           menhir_run27=
            function(counter,menhir_env,menhir_stack)
             {var menhir_env$0=menhir_discard(menhir_env),tok=menhir_env$0[3];
              if(typeof tok === "number")
               switch(tok)
                {case 6:
                  var _iT_=24;
                  if(counter < 50)
                   {var counter$6=counter + 1 | 0;
                    return menhir_run6(counter$6,menhir_env$0,menhir_stack,_iT_)}
                  return caml_trampoline_return
                          (menhir_run6,[0,menhir_env$0,menhir_stack,_iT_]);
                 case 9:
                  var _iU_=24;
                  if(counter < 50)
                   {var counter$4=counter + 1 | 0;
                    return menhir_run8(counter$4,menhir_env$0,menhir_stack,_iU_)}
                  return caml_trampoline_return
                          (menhir_run8,[0,menhir_env$0,menhir_stack,_iU_]);
                 case 12:
                  var _iV_=24;
                  if(counter < 50)
                   {var counter$3=counter + 1 | 0;
                    return menhir_run9(counter$3,menhir_env$0,menhir_stack,_iV_)}
                  return caml_trampoline_return
                          (menhir_run9,[0,menhir_env$0,menhir_stack,_iV_]);
                 case 14:
                  var _iW_=24;
                  if(counter < 50)
                   {var counter$2=counter + 1 | 0;
                    return menhir_run10
                            (counter$2,menhir_env$0,menhir_stack,_iW_)}
                  return caml_trampoline_return
                          (menhir_run10,[0,menhir_env$0,menhir_stack,_iW_]);
                 case 20:
                  var _iX_=24;
                  if(counter < 50)
                   {var counter$0=counter + 1 | 0;
                    return menhir_run12
                            (counter$0,menhir_env$0,menhir_stack,_iX_)}
                  return caml_trampoline_return
                          (menhir_run12,[0,menhir_env$0,menhir_stack,_iX_])
                 }
              else
               switch(tok[0])
                {case 1:
                  var v=tok[1],_iY_=menhir_env$0[2][11],_iZ_=24;
                  if(counter < 50)
                   {var counter$5=counter + 1 | 0;
                    return menhir_run7
                            (counter$5,menhir_env$0,menhir_stack,_iZ_,v,_iY_)}
                  return caml_trampoline_return
                          (menhir_run7,[0,menhir_env$0,menhir_stack,_iZ_,v,_iY_]);
                 case 2:
                  var v$0=tok[1],_i0_=menhir_env$0[2][11],_i1_=24;
                  if(counter < 50)
                   {var counter$1=counter + 1 | 0;
                    return menhir_run11
                            (counter$1,menhir_env$0,menhir_stack,_i1_,v$0,_i0_)}
                  return caml_trampoline_return
                          (menhir_run11,[0,menhir_env$0,menhir_stack,_i1_,v$0,_i0_])
                 }
              if(menhir_env$0[4])throw [0,Assert_failure,_by_];
              menhir_env$0[4] = 1;
              return menhir_errorcase(menhir_env$0,menhir_stack,24)},
           menhir_run31=
            function(counter,menhir_env,menhir_stack)
             {var menhir_env$0=menhir_discard(menhir_env),tok=menhir_env$0[3];
              if(typeof tok === "number")
               switch(tok)
                {case 6:
                  var _iK_=22;
                  if(counter < 50)
                   {var counter$6=counter + 1 | 0;
                    return menhir_run6(counter$6,menhir_env$0,menhir_stack,_iK_)}
                  return caml_trampoline_return
                          (menhir_run6,[0,menhir_env$0,menhir_stack,_iK_]);
                 case 9:
                  var _iL_=22;
                  if(counter < 50)
                   {var counter$4=counter + 1 | 0;
                    return menhir_run8(counter$4,menhir_env$0,menhir_stack,_iL_)}
                  return caml_trampoline_return
                          (menhir_run8,[0,menhir_env$0,menhir_stack,_iL_]);
                 case 12:
                  var _iM_=22;
                  if(counter < 50)
                   {var counter$3=counter + 1 | 0;
                    return menhir_run9(counter$3,menhir_env$0,menhir_stack,_iM_)}
                  return caml_trampoline_return
                          (menhir_run9,[0,menhir_env$0,menhir_stack,_iM_]);
                 case 14:
                  var _iN_=22;
                  if(counter < 50)
                   {var counter$2=counter + 1 | 0;
                    return menhir_run10
                            (counter$2,menhir_env$0,menhir_stack,_iN_)}
                  return caml_trampoline_return
                          (menhir_run10,[0,menhir_env$0,menhir_stack,_iN_]);
                 case 20:
                  var _iO_=22;
                  if(counter < 50)
                   {var counter$0=counter + 1 | 0;
                    return menhir_run12
                            (counter$0,menhir_env$0,menhir_stack,_iO_)}
                  return caml_trampoline_return
                          (menhir_run12,[0,menhir_env$0,menhir_stack,_iO_])
                 }
              else
               switch(tok[0])
                {case 1:
                  var v=tok[1],_iP_=menhir_env$0[2][11],_iQ_=22;
                  if(counter < 50)
                   {var counter$5=counter + 1 | 0;
                    return menhir_run7
                            (counter$5,menhir_env$0,menhir_stack,_iQ_,v,_iP_)}
                  return caml_trampoline_return
                          (menhir_run7,[0,menhir_env$0,menhir_stack,_iQ_,v,_iP_]);
                 case 2:
                  var v$0=tok[1],_iR_=menhir_env$0[2][11],_iS_=22;
                  if(counter < 50)
                   {var counter$1=counter + 1 | 0;
                    return menhir_run11
                            (counter$1,menhir_env$0,menhir_stack,_iS_,v$0,_iR_)}
                  return caml_trampoline_return
                          (menhir_run11,[0,menhir_env$0,menhir_stack,_iS_,v$0,_iR_])
                 }
              if(menhir_env$0[4])throw [0,Assert_failure,_bz_];
              menhir_env$0[4] = 1;
              return menhir_errorcase(menhir_env$0,menhir_stack,22)},
           menhir_run40=
            function(counter,menhir_env,menhir_stack)
             {var menhir_env$0=menhir_discard(menhir_env),tok=menhir_env$0[3];
              if(typeof tok === "number")
               switch(tok)
                {case 6:
                  var _iB_=18;
                  if(counter < 50)
                   {var counter$6=counter + 1 | 0;
                    return menhir_run6(counter$6,menhir_env$0,menhir_stack,_iB_)}
                  return caml_trampoline_return
                          (menhir_run6,[0,menhir_env$0,menhir_stack,_iB_]);
                 case 9:
                  var _iC_=18;
                  if(counter < 50)
                   {var counter$4=counter + 1 | 0;
                    return menhir_run8(counter$4,menhir_env$0,menhir_stack,_iC_)}
                  return caml_trampoline_return
                          (menhir_run8,[0,menhir_env$0,menhir_stack,_iC_]);
                 case 12:
                  var _iD_=18;
                  if(counter < 50)
                   {var counter$3=counter + 1 | 0;
                    return menhir_run9(counter$3,menhir_env$0,menhir_stack,_iD_)}
                  return caml_trampoline_return
                          (menhir_run9,[0,menhir_env$0,menhir_stack,_iD_]);
                 case 14:
                  var _iE_=18;
                  if(counter < 50)
                   {var counter$2=counter + 1 | 0;
                    return menhir_run10
                            (counter$2,menhir_env$0,menhir_stack,_iE_)}
                  return caml_trampoline_return
                          (menhir_run10,[0,menhir_env$0,menhir_stack,_iE_]);
                 case 20:
                  var _iF_=18;
                  if(counter < 50)
                   {var counter$0=counter + 1 | 0;
                    return menhir_run12
                            (counter$0,menhir_env$0,menhir_stack,_iF_)}
                  return caml_trampoline_return
                          (menhir_run12,[0,menhir_env$0,menhir_stack,_iF_])
                 }
              else
               switch(tok[0])
                {case 1:
                  var v=tok[1],_iG_=menhir_env$0[2][11],_iH_=18;
                  if(counter < 50)
                   {var counter$5=counter + 1 | 0;
                    return menhir_run7
                            (counter$5,menhir_env$0,menhir_stack,_iH_,v,_iG_)}
                  return caml_trampoline_return
                          (menhir_run7,[0,menhir_env$0,menhir_stack,_iH_,v,_iG_]);
                 case 2:
                  var v$0=tok[1],_iI_=menhir_env$0[2][11],_iJ_=18;
                  if(counter < 50)
                   {var counter$1=counter + 1 | 0;
                    return menhir_run11
                            (counter$1,menhir_env$0,menhir_stack,_iJ_,v$0,_iI_)}
                  return caml_trampoline_return
                          (menhir_run11,[0,menhir_env$0,menhir_stack,_iJ_,v$0,_iI_])
                 }
              if(menhir_env$0[4])throw [0,Assert_failure,_bA_];
              menhir_env$0[4] = 1;
              return menhir_errorcase(menhir_env$0,menhir_stack,18)},
           menhir_run33=
            function(counter,menhir_env,menhir_stack)
             {var menhir_env$0=menhir_discard(menhir_env),tok=menhir_env$0[3];
              if(typeof tok === "number")
               switch(tok)
                {case 6:
                  var _is_=21;
                  if(counter < 50)
                   {var counter$6=counter + 1 | 0;
                    return menhir_run6(counter$6,menhir_env$0,menhir_stack,_is_)}
                  return caml_trampoline_return
                          (menhir_run6,[0,menhir_env$0,menhir_stack,_is_]);
                 case 9:
                  var _it_=21;
                  if(counter < 50)
                   {var counter$4=counter + 1 | 0;
                    return menhir_run8(counter$4,menhir_env$0,menhir_stack,_it_)}
                  return caml_trampoline_return
                          (menhir_run8,[0,menhir_env$0,menhir_stack,_it_]);
                 case 12:
                  var _iu_=21;
                  if(counter < 50)
                   {var counter$3=counter + 1 | 0;
                    return menhir_run9(counter$3,menhir_env$0,menhir_stack,_iu_)}
                  return caml_trampoline_return
                          (menhir_run9,[0,menhir_env$0,menhir_stack,_iu_]);
                 case 14:
                  var _iv_=21;
                  if(counter < 50)
                   {var counter$2=counter + 1 | 0;
                    return menhir_run10
                            (counter$2,menhir_env$0,menhir_stack,_iv_)}
                  return caml_trampoline_return
                          (menhir_run10,[0,menhir_env$0,menhir_stack,_iv_]);
                 case 20:
                  var _iw_=21;
                  if(counter < 50)
                   {var counter$0=counter + 1 | 0;
                    return menhir_run12
                            (counter$0,menhir_env$0,menhir_stack,_iw_)}
                  return caml_trampoline_return
                          (menhir_run12,[0,menhir_env$0,menhir_stack,_iw_])
                 }
              else
               switch(tok[0])
                {case 1:
                  var v=tok[1],_ix_=menhir_env$0[2][11],_iy_=21;
                  if(counter < 50)
                   {var counter$5=counter + 1 | 0;
                    return menhir_run7
                            (counter$5,menhir_env$0,menhir_stack,_iy_,v,_ix_)}
                  return caml_trampoline_return
                          (menhir_run7,[0,menhir_env$0,menhir_stack,_iy_,v,_ix_]);
                 case 2:
                  var v$0=tok[1],_iz_=menhir_env$0[2][11],_iA_=21;
                  if(counter < 50)
                   {var counter$1=counter + 1 | 0;
                    return menhir_run11
                            (counter$1,menhir_env$0,menhir_stack,_iA_,v$0,_iz_)}
                  return caml_trampoline_return
                          (menhir_run11,[0,menhir_env$0,menhir_stack,_iA_,v$0,_iz_])
                 }
              if(menhir_env$0[4])throw [0,Assert_failure,_bB_];
              menhir_env$0[4] = 1;
              return menhir_errorcase(menhir_env$0,menhir_stack,21)},
           menhir_run25=
            function(counter,menhir_env,menhir_stack)
             {var menhir_env$0=menhir_discard(menhir_env),tok=menhir_env$0[3];
              if(typeof tok === "number")
               switch(tok)
                {case 6:
                  var _ij_=25;
                  if(counter < 50)
                   {var counter$6=counter + 1 | 0;
                    return menhir_run6(counter$6,menhir_env$0,menhir_stack,_ij_)}
                  return caml_trampoline_return
                          (menhir_run6,[0,menhir_env$0,menhir_stack,_ij_]);
                 case 9:
                  var _ik_=25;
                  if(counter < 50)
                   {var counter$4=counter + 1 | 0;
                    return menhir_run8(counter$4,menhir_env$0,menhir_stack,_ik_)}
                  return caml_trampoline_return
                          (menhir_run8,[0,menhir_env$0,menhir_stack,_ik_]);
                 case 12:
                  var _il_=25;
                  if(counter < 50)
                   {var counter$3=counter + 1 | 0;
                    return menhir_run9(counter$3,menhir_env$0,menhir_stack,_il_)}
                  return caml_trampoline_return
                          (menhir_run9,[0,menhir_env$0,menhir_stack,_il_]);
                 case 14:
                  var _im_=25;
                  if(counter < 50)
                   {var counter$2=counter + 1 | 0;
                    return menhir_run10
                            (counter$2,menhir_env$0,menhir_stack,_im_)}
                  return caml_trampoline_return
                          (menhir_run10,[0,menhir_env$0,menhir_stack,_im_]);
                 case 20:
                  var _in_=25;
                  if(counter < 50)
                   {var counter$0=counter + 1 | 0;
                    return menhir_run12
                            (counter$0,menhir_env$0,menhir_stack,_in_)}
                  return caml_trampoline_return
                          (menhir_run12,[0,menhir_env$0,menhir_stack,_in_])
                 }
              else
               switch(tok[0])
                {case 1:
                  var v=tok[1],_io_=menhir_env$0[2][11],_ip_=25;
                  if(counter < 50)
                   {var counter$5=counter + 1 | 0;
                    return menhir_run7
                            (counter$5,menhir_env$0,menhir_stack,_ip_,v,_io_)}
                  return caml_trampoline_return
                          (menhir_run7,[0,menhir_env$0,menhir_stack,_ip_,v,_io_]);
                 case 2:
                  var v$0=tok[1],_iq_=menhir_env$0[2][11],_ir_=25;
                  if(counter < 50)
                   {var counter$1=counter + 1 | 0;
                    return menhir_run11
                            (counter$1,menhir_env$0,menhir_stack,_ir_,v$0,_iq_)}
                  return caml_trampoline_return
                          (menhir_run11,[0,menhir_env$0,menhir_stack,_ir_,v$0,_iq_])
                 }
              if(menhir_env$0[4])throw [0,Assert_failure,_bC_];
              menhir_env$0[4] = 1;
              return menhir_errorcase(menhir_env$0,menhir_stack,25)},
           menhir_run44=
            function(counter,menhir_env,menhir_stack)
             {var menhir_env$0=menhir_discard(menhir_env),tok=menhir_env$0[3];
              if(typeof tok === "number")
               switch(tok)
                {case 6:
                  var _ia_=16;
                  if(counter < 50)
                   {var counter$6=counter + 1 | 0;
                    return menhir_run6(counter$6,menhir_env$0,menhir_stack,_ia_)}
                  return caml_trampoline_return
                          (menhir_run6,[0,menhir_env$0,menhir_stack,_ia_]);
                 case 9:
                  var _ib_=16;
                  if(counter < 50)
                   {var counter$4=counter + 1 | 0;
                    return menhir_run8(counter$4,menhir_env$0,menhir_stack,_ib_)}
                  return caml_trampoline_return
                          (menhir_run8,[0,menhir_env$0,menhir_stack,_ib_]);
                 case 12:
                  var _ic_=16;
                  if(counter < 50)
                   {var counter$3=counter + 1 | 0;
                    return menhir_run9(counter$3,menhir_env$0,menhir_stack,_ic_)}
                  return caml_trampoline_return
                          (menhir_run9,[0,menhir_env$0,menhir_stack,_ic_]);
                 case 14:
                  var _id_=16;
                  if(counter < 50)
                   {var counter$2=counter + 1 | 0;
                    return menhir_run10
                            (counter$2,menhir_env$0,menhir_stack,_id_)}
                  return caml_trampoline_return
                          (menhir_run10,[0,menhir_env$0,menhir_stack,_id_]);
                 case 20:
                  var _ie_=16;
                  if(counter < 50)
                   {var counter$0=counter + 1 | 0;
                    return menhir_run12
                            (counter$0,menhir_env$0,menhir_stack,_ie_)}
                  return caml_trampoline_return
                          (menhir_run12,[0,menhir_env$0,menhir_stack,_ie_])
                 }
              else
               switch(tok[0])
                {case 1:
                  var v=tok[1],_if_=menhir_env$0[2][11],_ig_=16;
                  if(counter < 50)
                   {var counter$5=counter + 1 | 0;
                    return menhir_run7
                            (counter$5,menhir_env$0,menhir_stack,_ig_,v,_if_)}
                  return caml_trampoline_return
                          (menhir_run7,[0,menhir_env$0,menhir_stack,_ig_,v,_if_]);
                 case 2:
                  var v$0=tok[1],_ih_=menhir_env$0[2][11],_ii_=16;
                  if(counter < 50)
                   {var counter$1=counter + 1 | 0;
                    return menhir_run11
                            (counter$1,menhir_env$0,menhir_stack,_ii_,v$0,_ih_)}
                  return caml_trampoline_return
                          (menhir_run11,[0,menhir_env$0,menhir_stack,_ii_,v$0,_ih_])
                 }
              if(menhir_env$0[4])throw [0,Assert_failure,_bD_];
              menhir_env$0[4] = 1;
              return menhir_errorcase(menhir_env$0,menhir_stack,16)},
           menhir_run46=
            function(counter,menhir_env,menhir_stack)
             {var menhir_env$0=menhir_discard(menhir_env),tok=menhir_env$0[3];
              if(typeof tok === "number")
               switch(tok)
                {case 6:
                  var _h3_=15;
                  if(counter < 50)
                   {var counter$6=counter + 1 | 0;
                    return menhir_run6(counter$6,menhir_env$0,menhir_stack,_h3_)}
                  return caml_trampoline_return
                          (menhir_run6,[0,menhir_env$0,menhir_stack,_h3_]);
                 case 9:
                  var _h4_=15;
                  if(counter < 50)
                   {var counter$4=counter + 1 | 0;
                    return menhir_run8(counter$4,menhir_env$0,menhir_stack,_h4_)}
                  return caml_trampoline_return
                          (menhir_run8,[0,menhir_env$0,menhir_stack,_h4_]);
                 case 12:
                  var _h5_=15;
                  if(counter < 50)
                   {var counter$3=counter + 1 | 0;
                    return menhir_run9(counter$3,menhir_env$0,menhir_stack,_h5_)}
                  return caml_trampoline_return
                          (menhir_run9,[0,menhir_env$0,menhir_stack,_h5_]);
                 case 14:
                  var _h6_=15;
                  if(counter < 50)
                   {var counter$2=counter + 1 | 0;
                    return menhir_run10
                            (counter$2,menhir_env$0,menhir_stack,_h6_)}
                  return caml_trampoline_return
                          (menhir_run10,[0,menhir_env$0,menhir_stack,_h6_]);
                 case 20:
                  var _h7_=15;
                  if(counter < 50)
                   {var counter$0=counter + 1 | 0;
                    return menhir_run12
                            (counter$0,menhir_env$0,menhir_stack,_h7_)}
                  return caml_trampoline_return
                          (menhir_run12,[0,menhir_env$0,menhir_stack,_h7_])
                 }
              else
               switch(tok[0])
                {case 1:
                  var v=tok[1],_h8_=menhir_env$0[2][11],_h9_=15;
                  if(counter < 50)
                   {var counter$5=counter + 1 | 0;
                    return menhir_run7
                            (counter$5,menhir_env$0,menhir_stack,_h9_,v,_h8_)}
                  return caml_trampoline_return
                          (menhir_run7,[0,menhir_env$0,menhir_stack,_h9_,v,_h8_]);
                 case 2:
                  var v$0=tok[1],_h__=menhir_env$0[2][11],_h$_=15;
                  if(counter < 50)
                   {var counter$1=counter + 1 | 0;
                    return menhir_run11
                            (counter$1,menhir_env$0,menhir_stack,_h$_,v$0,_h__)}
                  return caml_trampoline_return
                          (menhir_run11,[0,menhir_env$0,menhir_stack,_h$_,v$0,_h__])
                 }
              if(menhir_env$0[4])throw [0,Assert_failure,_bE_];
              menhir_env$0[4] = 1;
              return menhir_errorcase(menhir_env$0,menhir_stack,15)},
           menhir_run35=
            function(counter,menhir_env,menhir_stack)
             {var menhir_env$0=menhir_discard(menhir_env),tok=menhir_env$0[3];
              if(typeof tok === "number")
               switch(tok)
                {case 6:
                  var _hU_=20;
                  if(counter < 50)
                   {var counter$6=counter + 1 | 0;
                    return menhir_run6(counter$6,menhir_env$0,menhir_stack,_hU_)}
                  return caml_trampoline_return
                          (menhir_run6,[0,menhir_env$0,menhir_stack,_hU_]);
                 case 9:
                  var _hV_=20;
                  if(counter < 50)
                   {var counter$4=counter + 1 | 0;
                    return menhir_run8(counter$4,menhir_env$0,menhir_stack,_hV_)}
                  return caml_trampoline_return
                          (menhir_run8,[0,menhir_env$0,menhir_stack,_hV_]);
                 case 12:
                  var _hW_=20;
                  if(counter < 50)
                   {var counter$3=counter + 1 | 0;
                    return menhir_run9(counter$3,menhir_env$0,menhir_stack,_hW_)}
                  return caml_trampoline_return
                          (menhir_run9,[0,menhir_env$0,menhir_stack,_hW_]);
                 case 14:
                  var _hX_=20;
                  if(counter < 50)
                   {var counter$2=counter + 1 | 0;
                    return menhir_run10
                            (counter$2,menhir_env$0,menhir_stack,_hX_)}
                  return caml_trampoline_return
                          (menhir_run10,[0,menhir_env$0,menhir_stack,_hX_]);
                 case 20:
                  var _hY_=20;
                  if(counter < 50)
                   {var counter$0=counter + 1 | 0;
                    return menhir_run12
                            (counter$0,menhir_env$0,menhir_stack,_hY_)}
                  return caml_trampoline_return
                          (menhir_run12,[0,menhir_env$0,menhir_stack,_hY_])
                 }
              else
               switch(tok[0])
                {case 1:
                  var v=tok[1],_hZ_=menhir_env$0[2][11],_h0_=20;
                  if(counter < 50)
                   {var counter$5=counter + 1 | 0;
                    return menhir_run7
                            (counter$5,menhir_env$0,menhir_stack,_h0_,v,_hZ_)}
                  return caml_trampoline_return
                          (menhir_run7,[0,menhir_env$0,menhir_stack,_h0_,v,_hZ_]);
                 case 2:
                  var v$0=tok[1],_h1_=menhir_env$0[2][11],_h2_=20;
                  if(counter < 50)
                   {var counter$1=counter + 1 | 0;
                    return menhir_run11
                            (counter$1,menhir_env$0,menhir_stack,_h2_,v$0,_h1_)}
                  return caml_trampoline_return
                          (menhir_run11,[0,menhir_env$0,menhir_stack,_h2_,v$0,_h1_])
                 }
              if(menhir_env$0[4])throw [0,Assert_failure,_bF_];
              menhir_env$0[4] = 1;
              return menhir_errorcase(menhir_env$0,menhir_stack,20)},
           menhir_goto_offset=
            function(counter,menhir_env,menhir_stack,menhir_s,o)
             {if(7 === menhir_s)
               {if(menhir_env[4])throw [0,Assert_failure,_bG_];
                var tok=menhir_env[3];
                if(typeof tok === "number" && 4 === tok)
                 {var
                   menhir_env$0=menhir_discard(menhir_env),
                   tok$0=menhir_env$0[3];
                  if(typeof tok$0 === "number" && 17 <= tok$0)
                   {var switcher=tok$0 - 17 | 0;
                    switch(switcher)
                     {case 3:
                       var
                        menhir_env$1=menhir_discard(menhir_env$0),
                        id$0=menhir_stack[2],
                        match$0=menhir_stack[1],
                        menhir_s$1=match$0[2],
                        menhir_stack$1=match$0[1],
                        v$0=[2,id$0,o,1];
                       if(counter < 50)
                        {var counter$1=counter + 1 | 0;
                         return menhir_goto_arg
                                 (counter$1,menhir_env$1,menhir_stack$1,menhir_s$1,v$0)}
                       return caml_trampoline_return
                               (menhir_goto_arg,
                                [0,menhir_env$1,menhir_stack$1,menhir_s$1,v$0]);
                      case 0:
                      case 6:
                      case 7:
                      case 9:
                       var
                        id=menhir_stack[2],
                        match=menhir_stack[1],
                        menhir_s$0=match[2],
                        menhir_stack$0=match[1],
                        v=[2,id,o,0];
                       if(counter < 50)
                        {var counter$2=counter + 1 | 0;
                         return menhir_goto_arg
                                 (counter$2,menhir_env$0,menhir_stack$0,menhir_s$0,v)}
                       return caml_trampoline_return
                               (menhir_goto_arg,
                                [0,menhir_env$0,menhir_stack$0,menhir_s$0,v])
                      }}
                  if(menhir_env$0[4])throw [0,Assert_failure,_bH_];
                  menhir_env$0[4] = 1;
                  return menhir_errorcase(menhir_env$0,menhir_stack,menhir_s)}
                if(menhir_env[4])throw [0,Assert_failure,_bI_];
                menhir_env[4] = 1;
                return menhir_errorcase(menhir_env,menhir_stack,menhir_s)}
              if(13 === menhir_s)
               {var
                 id$1=menhir_stack[2],
                 match$1=menhir_stack[1],
                 menhir_s$2=match$1[2],
                 menhir_stack$2=match$1[1],
                 v$1=[2,id$1,o,2];
                if(counter < 50)
                 {var counter$0=counter + 1 | 0;
                  return menhir_goto_arg
                          (counter$0,menhir_env,menhir_stack$2,menhir_s$2,v$1)}
                return caml_trampoline_return
                        (menhir_goto_arg,
                         [0,menhir_env,menhir_stack$2,menhir_s$2,v$1])}
              return menhir_fail(0)},
           menhir_goto_meta_expr=
            function(counter,menhir_env,menhir_stack,menhir_s,v)
             {var
               menhir_env$0=menhir_env,
               menhir_stack$0=menhir_stack,
               menhir_s$0=menhir_s,
               v$0=v;
              for(;;)
               {var menhir_stack$1=[0,menhir_stack$0,menhir_s$0,v$0];
                switch(menhir_s$0)
                 {case 1:
                   if(menhir_env$0[4])throw [0,Assert_failure,_bJ_];
                   var tok=menhir_env$0[3];
                   if(typeof tok === "number")
                    switch(tok)
                     {case 0:
                       if(counter < 50)
                        {var counter$176=counter + 1 | 0;
                         return menhir_run15(counter$176,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run15,[0,menhir_env$0,menhir_stack$1]);
                      case 1:
                       if(counter < 50)
                        {var counter$159=counter + 1 | 0;
                         return menhir_run17(counter$159,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run17,[0,menhir_env$0,menhir_stack$1]);
                      case 2:
                       if(counter < 50)
                        {var counter$146=counter + 1 | 0;
                         return menhir_run19(counter$146,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run19,[0,menhir_env$0,menhir_stack$1]);
                      case 6:
                       if(counter < 50)
                        {var counter$131=counter + 1 | 0;
                         return menhir_run21(counter$131,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run21,[0,menhir_env$0,menhir_stack$1]);
                      case 7:
                       if(counter < 50)
                        {var counter$123=counter + 1 | 0;
                         return menhir_run38(counter$123,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run38,[0,menhir_env$0,menhir_stack$1]);
                      case 10:
                       if(counter < 50)
                        {var counter$112=counter + 1 | 0;
                         return menhir_run29(counter$112,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run29,[0,menhir_env$0,menhir_stack$1]);
                      case 11:
                       if(counter < 50)
                        {var counter$95=counter + 1 | 0;
                         return menhir_run23(counter$95,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run23,[0,menhir_env$0,menhir_stack$1]);
                      case 12:
                       if(counter < 50)
                        {var counter$80=counter + 1 | 0;
                         return menhir_run27(counter$80,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run27,[0,menhir_env$0,menhir_stack$1]);
                      case 13:
                       if(counter < 50)
                        {var counter$67=counter + 1 | 0;
                         return menhir_run31(counter$67,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run31,[0,menhir_env$0,menhir_stack$1]);
                      case 17:
                       if(counter < 50)
                        {var counter$61=counter + 1 | 0;
                         return menhir_run40(counter$61,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run40,[0,menhir_env$0,menhir_stack$1]);
                      case 22:
                       if(counter < 50)
                        {var counter$50=counter + 1 | 0;
                         return menhir_run33(counter$50,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run33,[0,menhir_env$0,menhir_stack$1]);
                      case 23:
                       var
                        e=menhir_stack$1[3],
                        match=menhir_stack$1[1],
                        id=match[2],
                        menhir_stack$3=match[1],
                        v$1=[1,id,0,e];
                       if(counter < 50)
                        {var counter$0=counter + 1 | 0;
                         return menhir_goto_definition
                                 (counter$0,menhir_env$0,menhir_stack$3,v$1)}
                       return caml_trampoline_return
                               (menhir_goto_definition,[0,menhir_env$0,menhir_stack$3,v$1]);
                      case 25:
                       if(counter < 50)
                        {var counter$33=counter + 1 | 0;
                         return menhir_run25(counter$33,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run25,[0,menhir_env$0,menhir_stack$1]);
                      case 28:
                       if(counter < 50)
                        {var counter$27=counter + 1 | 0;
                         return menhir_run44(counter$27,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run44,[0,menhir_env$0,menhir_stack$1]);
                      case 29:
                       if(counter < 50)
                        {var counter$20=counter + 1 | 0;
                         return menhir_run46(counter$20,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run46,[0,menhir_env$0,menhir_stack$1]);
                      case 30:
                       if(counter < 50)
                        {var counter$10=counter + 1 | 0;
                         return menhir_run35(counter$10,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run35,[0,menhir_env$0,menhir_stack$1])
                      }
                   if(menhir_env$0[4])throw [0,Assert_failure,_bK_];
                   menhir_env$0[4] = 1;
                   var
                    menhir_s$1=menhir_stack$1[2],
                    menhir_stack$2=menhir_stack$1[1];
                   return menhir_errorcase
                           (menhir_env$0,menhir_stack$2,menhir_s$1);
                  case 2:
                   if(menhir_env$0[4])throw [0,Assert_failure,_bL_];
                   var tok$0=menhir_env$0[3];
                   if(typeof tok$0 === "number")
                    switch(tok$0)
                     {case 0:
                       if(counter < 50)
                        {var counter$177=counter + 1 | 0;
                         return menhir_run15(counter$177,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run15,[0,menhir_env$0,menhir_stack$1]);
                      case 1:
                       if(counter < 50)
                        {var counter$160=counter + 1 | 0;
                         return menhir_run17(counter$160,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run17,[0,menhir_env$0,menhir_stack$1]);
                      case 2:
                       if(counter < 50)
                        {var counter$147=counter + 1 | 0;
                         return menhir_run19(counter$147,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run19,[0,menhir_env$0,menhir_stack$1]);
                      case 6:
                       if(counter < 50)
                        {var counter$132=counter + 1 | 0;
                         return menhir_run21(counter$132,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run21,[0,menhir_env$0,menhir_stack$1]);
                      case 7:
                       if(counter < 50)
                        {var counter$124=counter + 1 | 0;
                         return menhir_run38(counter$124,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run38,[0,menhir_env$0,menhir_stack$1]);
                      case 10:
                       if(counter < 50)
                        {var counter$113=counter + 1 | 0;
                         return menhir_run29(counter$113,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run29,[0,menhir_env$0,menhir_stack$1]);
                      case 11:
                       if(counter < 50)
                        {var counter$96=counter + 1 | 0;
                         return menhir_run23(counter$96,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run23,[0,menhir_env$0,menhir_stack$1]);
                      case 12:
                       if(counter < 50)
                        {var counter$81=counter + 1 | 0;
                         return menhir_run27(counter$81,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run27,[0,menhir_env$0,menhir_stack$1]);
                      case 13:
                       if(counter < 50)
                        {var counter$68=counter + 1 | 0;
                         return menhir_run31(counter$68,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run31,[0,menhir_env$0,menhir_stack$1]);
                      case 17:
                       if(counter < 50)
                        {var counter$62=counter + 1 | 0;
                         return menhir_run40(counter$62,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run40,[0,menhir_env$0,menhir_stack$1]);
                      case 22:
                       if(counter < 50)
                        {var counter$51=counter + 1 | 0;
                         return menhir_run33(counter$51,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run33,[0,menhir_env$0,menhir_stack$1]);
                      case 23:
                       var
                        e$0=menhir_stack$1[3],
                        match$0=menhir_stack$1[1],
                        id$0=match$0[2],
                        menhir_stack$5=match$0[1],
                        v$2=[1,id$0,1,e$0];
                       if(counter < 50)
                        {var counter$1=counter + 1 | 0;
                         return menhir_goto_definition
                                 (counter$1,menhir_env$0,menhir_stack$5,v$2)}
                       return caml_trampoline_return
                               (menhir_goto_definition,[0,menhir_env$0,menhir_stack$5,v$2]);
                      case 25:
                       if(counter < 50)
                        {var counter$34=counter + 1 | 0;
                         return menhir_run25(counter$34,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run25,[0,menhir_env$0,menhir_stack$1]);
                      case 28:
                       if(counter < 50)
                        {var counter$28=counter + 1 | 0;
                         return menhir_run44(counter$28,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run44,[0,menhir_env$0,menhir_stack$1]);
                      case 29:
                       if(counter < 50)
                        {var counter$21=counter + 1 | 0;
                         return menhir_run46(counter$21,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run46,[0,menhir_env$0,menhir_stack$1]);
                      case 30:
                       if(counter < 50)
                        {var counter$11=counter + 1 | 0;
                         return menhir_run35(counter$11,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run35,[0,menhir_env$0,menhir_stack$1])
                      }
                   if(menhir_env$0[4])throw [0,Assert_failure,_bM_];
                   menhir_env$0[4] = 1;
                   var
                    menhir_s$2=menhir_stack$1[2],
                    menhir_stack$4=menhir_stack$1[1];
                   return menhir_errorcase
                           (menhir_env$0,menhir_stack$4,menhir_s$2);
                  case 15:
                   if(menhir_env$0[4])throw [0,Assert_failure,_bN_];
                   var tok$1=menhir_env$0[3];
                   if(typeof tok$1 === "number")
                    switch(tok$1)
                     {case 0:
                       if(counter < 50)
                        {var counter$178=counter + 1 | 0;
                         return menhir_run15(counter$178,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run15,[0,menhir_env$0,menhir_stack$1]);
                      case 1:
                       if(counter < 50)
                        {var counter$161=counter + 1 | 0;
                         return menhir_run17(counter$161,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run17,[0,menhir_env$0,menhir_stack$1]);
                      case 2:
                       if(counter < 50)
                        {var counter$148=counter + 1 | 0;
                         return menhir_run19(counter$148,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run19,[0,menhir_env$0,menhir_stack$1]);
                      case 6:
                       if(counter < 50)
                        {var counter$133=counter + 1 | 0;
                         return menhir_run21(counter$133,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run21,[0,menhir_env$0,menhir_stack$1]);
                      case 7:
                       if(counter < 50)
                        {var counter$125=counter + 1 | 0;
                         return menhir_run38(counter$125,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run38,[0,menhir_env$0,menhir_stack$1]);
                      case 10:
                       if(counter < 50)
                        {var counter$114=counter + 1 | 0;
                         return menhir_run29(counter$114,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run29,[0,menhir_env$0,menhir_stack$1]);
                      case 11:
                       if(counter < 50)
                        {var counter$97=counter + 1 | 0;
                         return menhir_run23(counter$97,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run23,[0,menhir_env$0,menhir_stack$1]);
                      case 12:
                       if(counter < 50)
                        {var counter$82=counter + 1 | 0;
                         return menhir_run27(counter$82,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run27,[0,menhir_env$0,menhir_stack$1]);
                      case 13:
                       if(counter < 50)
                        {var counter$69=counter + 1 | 0;
                         return menhir_run31(counter$69,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run31,[0,menhir_env$0,menhir_stack$1]);
                      case 22:
                       if(counter < 50)
                        {var counter$52=counter + 1 | 0;
                         return menhir_run33(counter$52,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run33,[0,menhir_env$0,menhir_stack$1]);
                      case 25:
                       if(counter < 50)
                        {var counter$35=counter + 1 | 0;
                         return menhir_run25(counter$35,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run25,[0,menhir_env$0,menhir_stack$1]);
                      case 30:
                       if(counter < 50)
                        {var counter$12=counter + 1 | 0;
                         return menhir_run35(counter$12,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run35,[0,menhir_env$0,menhir_stack$1]);
                      case 3:
                      case 5:
                      case 17:
                      case 23:
                      case 27:
                      case 28:
                      case 29:
                       var
                        e2=menhir_stack$1[3],
                        match$1=menhir_stack$1[1],
                        e1=match$1[3],
                        menhir_s$3=match$1[2],
                        menhir_stack$6=match$1[1],
                        v$3=[1,13,e1,e2],
                        menhir_stack$0=menhir_stack$6,
                        menhir_s$0=menhir_s$3,
                        v$0=v$3;
                       continue
                      }
                   if(menhir_env$0[4])throw [0,Assert_failure,_bO_];
                   menhir_env$0[4] = 1;
                   var
                    menhir_s$4=menhir_stack$1[2],
                    menhir_stack$7=menhir_stack$1[1];
                   return menhir_errorcase
                           (menhir_env$0,menhir_stack$7,menhir_s$4);
                  case 16:
                   if(menhir_env$0[4])throw [0,Assert_failure,_bP_];
                   var tok$2=menhir_env$0[3];
                   if(typeof tok$2 === "number")
                    switch(tok$2)
                     {case 0:
                       if(counter < 50)
                        {var counter$179=counter + 1 | 0;
                         return menhir_run15(counter$179,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run15,[0,menhir_env$0,menhir_stack$1]);
                      case 1:
                       if(counter < 50)
                        {var counter$162=counter + 1 | 0;
                         return menhir_run17(counter$162,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run17,[0,menhir_env$0,menhir_stack$1]);
                      case 2:
                       if(counter < 50)
                        {var counter$149=counter + 1 | 0;
                         return menhir_run19(counter$149,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run19,[0,menhir_env$0,menhir_stack$1]);
                      case 6:
                       if(counter < 50)
                        {var counter$134=counter + 1 | 0;
                         return menhir_run21(counter$134,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run21,[0,menhir_env$0,menhir_stack$1]);
                      case 7:
                       if(counter < 50)
                        {var counter$126=counter + 1 | 0;
                         return menhir_run38(counter$126,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run38,[0,menhir_env$0,menhir_stack$1]);
                      case 10:
                       if(counter < 50)
                        {var counter$115=counter + 1 | 0;
                         return menhir_run29(counter$115,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run29,[0,menhir_env$0,menhir_stack$1]);
                      case 11:
                       if(counter < 50)
                        {var counter$98=counter + 1 | 0;
                         return menhir_run23(counter$98,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run23,[0,menhir_env$0,menhir_stack$1]);
                      case 12:
                       if(counter < 50)
                        {var counter$83=counter + 1 | 0;
                         return menhir_run27(counter$83,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run27,[0,menhir_env$0,menhir_stack$1]);
                      case 13:
                       if(counter < 50)
                        {var counter$70=counter + 1 | 0;
                         return menhir_run31(counter$70,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run31,[0,menhir_env$0,menhir_stack$1]);
                      case 22:
                       if(counter < 50)
                        {var counter$53=counter + 1 | 0;
                         return menhir_run33(counter$53,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run33,[0,menhir_env$0,menhir_stack$1]);
                      case 25:
                       if(counter < 50)
                        {var counter$36=counter + 1 | 0;
                         return menhir_run25(counter$36,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run25,[0,menhir_env$0,menhir_stack$1]);
                      case 29:
                       if(counter < 50)
                        {var counter$22=counter + 1 | 0;
                         return menhir_run46(counter$22,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run46,[0,menhir_env$0,menhir_stack$1]);
                      case 30:
                       if(counter < 50)
                        {var counter$13=counter + 1 | 0;
                         return menhir_run35(counter$13,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run35,[0,menhir_env$0,menhir_stack$1]);
                      case 3:
                      case 5:
                      case 17:
                      case 23:
                      case 27:
                      case 28:
                       var
                        e2$0=menhir_stack$1[3],
                        match$2=menhir_stack$1[1],
                        e1$0=match$2[3],
                        menhir_s$5=match$2[2],
                        menhir_stack$8=match$2[1],
                        v$4=[1,12,e1$0,e2$0],
                        menhir_stack$0=menhir_stack$8,
                        menhir_s$0=menhir_s$5,
                        v$0=v$4;
                       continue
                      }
                   if(menhir_env$0[4])throw [0,Assert_failure,_bQ_];
                   menhir_env$0[4] = 1;
                   var
                    menhir_s$6=menhir_stack$1[2],
                    menhir_stack$9=menhir_stack$1[1];
                   return menhir_errorcase
                           (menhir_env$0,menhir_stack$9,menhir_s$6);
                  case 17:
                   if(menhir_env$0[4])throw [0,Assert_failure,_bR_];
                   var tok$3=menhir_env$0[3];
                   if(typeof tok$3 === "number")
                    switch(tok$3)
                     {case 0:
                       if(counter < 50)
                        {var counter$180=counter + 1 | 0;
                         return menhir_run15(counter$180,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run15,[0,menhir_env$0,menhir_stack$1]);
                      case 1:
                       if(counter < 50)
                        {var counter$163=counter + 1 | 0;
                         return menhir_run17(counter$163,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run17,[0,menhir_env$0,menhir_stack$1]);
                      case 2:
                       if(counter < 50)
                        {var counter$150=counter + 1 | 0;
                         return menhir_run19(counter$150,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run19,[0,menhir_env$0,menhir_stack$1]);
                      case 6:
                       if(counter < 50)
                        {var counter$135=counter + 1 | 0;
                         return menhir_run21(counter$135,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run21,[0,menhir_env$0,menhir_stack$1]);
                      case 7:
                       if(counter < 50)
                        {var counter$127=counter + 1 | 0;
                         return menhir_run38(counter$127,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run38,[0,menhir_env$0,menhir_stack$1]);
                      case 10:
                       if(counter < 50)
                        {var counter$116=counter + 1 | 0;
                         return menhir_run29(counter$116,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run29,[0,menhir_env$0,menhir_stack$1]);
                      case 11:
                       if(counter < 50)
                        {var counter$99=counter + 1 | 0;
                         return menhir_run23(counter$99,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run23,[0,menhir_env$0,menhir_stack$1]);
                      case 12:
                       if(counter < 50)
                        {var counter$84=counter + 1 | 0;
                         return menhir_run27(counter$84,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run27,[0,menhir_env$0,menhir_stack$1]);
                      case 13:
                       if(counter < 50)
                        {var counter$71=counter + 1 | 0;
                         return menhir_run31(counter$71,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run31,[0,menhir_env$0,menhir_stack$1]);
                      case 17:
                       if(counter < 50)
                        {var counter$63=counter + 1 | 0;
                         return menhir_run40(counter$63,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run40,[0,menhir_env$0,menhir_stack$1]);
                      case 22:
                       if(counter < 50)
                        {var counter$54=counter + 1 | 0;
                         return menhir_run33(counter$54,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run33,[0,menhir_env$0,menhir_stack$1]);
                      case 25:
                       if(counter < 50)
                        {var counter$37=counter + 1 | 0;
                         return menhir_run25(counter$37,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run25,[0,menhir_env$0,menhir_stack$1]);
                      case 28:
                       if(counter < 50)
                        {var counter$29=counter + 1 | 0;
                         return menhir_run44(counter$29,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run44,[0,menhir_env$0,menhir_stack$1]);
                      case 29:
                       if(counter < 50)
                        {var counter$23=counter + 1 | 0;
                         return menhir_run46(counter$23,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run46,[0,menhir_env$0,menhir_stack$1]);
                      case 30:
                       if(counter < 50)
                        {var counter$14=counter + 1 | 0;
                         return menhir_run35(counter$14,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run35,[0,menhir_env$0,menhir_stack$1]);
                      case 3:
                      case 5:
                      case 23:
                      case 27:
                       var
                        e2$1=menhir_stack$1[3],
                        _hK_=menhir_stack$1[1],
                        e1$1=_hK_[3],
                        match$3=_hK_[1],
                        e0=match$3[3],
                        menhir_s$7=match$3[2],
                        menhir_stack$10=match$3[1],
                        v$5=[4,e0,e1$1,e2$1],
                        menhir_stack$0=menhir_stack$10,
                        menhir_s$0=menhir_s$7,
                        v$0=v$5;
                       continue
                      }
                   if(menhir_env$0[4])throw [0,Assert_failure,_bS_];
                   menhir_env$0[4] = 1;
                   var
                    menhir_s$8=menhir_stack$1[2],
                    menhir_stack$11=menhir_stack$1[1];
                   return menhir_errorcase
                           (menhir_env$0,menhir_stack$11,menhir_s$8);
                  case 18:
                   if(menhir_env$0[4])throw [0,Assert_failure,_bT_];
                   var tok$4=menhir_env$0[3];
                   if(typeof tok$4 === "number")
                    switch(tok$4)
                     {case 0:
                       if(counter < 50)
                        {var counter$181=counter + 1 | 0;
                         return menhir_run15(counter$181,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run15,[0,menhir_env$0,menhir_stack$1]);
                      case 1:
                       if(counter < 50)
                        {var counter$164=counter + 1 | 0;
                         return menhir_run17(counter$164,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run17,[0,menhir_env$0,menhir_stack$1]);
                      case 2:
                       if(counter < 50)
                        {var counter$151=counter + 1 | 0;
                         return menhir_run19(counter$151,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run19,[0,menhir_env$0,menhir_stack$1]);
                      case 6:
                       if(counter < 50)
                        {var counter$136=counter + 1 | 0;
                         return menhir_run21(counter$136,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run21,[0,menhir_env$0,menhir_stack$1]);
                      case 7:
                       if(counter < 50)
                        {var counter$128=counter + 1 | 0;
                         return menhir_run38(counter$128,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run38,[0,menhir_env$0,menhir_stack$1]);
                      case 10:
                       if(counter < 50)
                        {var counter$117=counter + 1 | 0;
                         return menhir_run29(counter$117,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run29,[0,menhir_env$0,menhir_stack$1]);
                      case 11:
                       if(counter < 50)
                        {var counter$100=counter + 1 | 0;
                         return menhir_run23(counter$100,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run23,[0,menhir_env$0,menhir_stack$1]);
                      case 12:
                       if(counter < 50)
                        {var counter$85=counter + 1 | 0;
                         return menhir_run27(counter$85,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run27,[0,menhir_env$0,menhir_stack$1]);
                      case 13:
                       if(counter < 50)
                        {var counter$72=counter + 1 | 0;
                         return menhir_run31(counter$72,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run31,[0,menhir_env$0,menhir_stack$1]);
                      case 17:
                       if(counter < 50)
                        {var counter$64=counter + 1 | 0;
                         return menhir_run40(counter$64,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run40,[0,menhir_env$0,menhir_stack$1]);
                      case 22:
                       if(counter < 50)
                        {var counter$55=counter + 1 | 0;
                         return menhir_run33(counter$55,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run33,[0,menhir_env$0,menhir_stack$1]);
                      case 25:
                       if(counter < 50)
                        {var counter$38=counter + 1 | 0;
                         return menhir_run25(counter$38,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run25,[0,menhir_env$0,menhir_stack$1]);
                      case 27:
                       var
                        menhir_env$1=menhir_discard(menhir_env$0),
                        tok$5=menhir_env$1[3];
                       if(typeof tok$5 === "number")
                        switch(tok$5)
                         {case 6:
                           var _hL_=17;
                           if(counter < 50)
                            {var counter$8=counter + 1 | 0;
                             return menhir_run6
                                     (counter$8,menhir_env$1,menhir_stack$1,_hL_)}
                           return caml_trampoline_return
                                   (menhir_run6,[0,menhir_env$1,menhir_stack$1,_hL_]);
                          case 9:
                           var _hM_=17;
                           if(counter < 50)
                            {var counter$6=counter + 1 | 0;
                             return menhir_run8
                                     (counter$6,menhir_env$1,menhir_stack$1,_hM_)}
                           return caml_trampoline_return
                                   (menhir_run8,[0,menhir_env$1,menhir_stack$1,_hM_]);
                          case 12:
                           var _hN_=17;
                           if(counter < 50)
                            {var counter$5=counter + 1 | 0;
                             return menhir_run9
                                     (counter$5,menhir_env$1,menhir_stack$1,_hN_)}
                           return caml_trampoline_return
                                   (menhir_run9,[0,menhir_env$1,menhir_stack$1,_hN_]);
                          case 14:
                           var _hO_=17;
                           if(counter < 50)
                            {var counter$4=counter + 1 | 0;
                             return menhir_run10
                                     (counter$4,menhir_env$1,menhir_stack$1,_hO_)}
                           return caml_trampoline_return
                                   (menhir_run10,[0,menhir_env$1,menhir_stack$1,_hO_]);
                          case 20:
                           var _hP_=17;
                           if(counter < 50)
                            {var counter$2=counter + 1 | 0;
                             return menhir_run12
                                     (counter$2,menhir_env$1,menhir_stack$1,_hP_)}
                           return caml_trampoline_return
                                   (menhir_run12,[0,menhir_env$1,menhir_stack$1,_hP_])
                          }
                       else
                        switch(tok$5[0])
                         {case 1:
                           var v$6=tok$5[1],_hQ_=menhir_env$1[2][11],_hR_=17;
                           if(counter < 50)
                            {var counter$7=counter + 1 | 0;
                             return menhir_run7
                                     (counter$7,menhir_env$1,menhir_stack$1,_hR_,v$6,_hQ_)}
                           return caml_trampoline_return
                                   (menhir_run7,[0,menhir_env$1,menhir_stack$1,_hR_,v$6,_hQ_]);
                          case 2:
                           var v$7=tok$5[1],_hS_=menhir_env$1[2][11],_hT_=17;
                           if(counter < 50)
                            {var counter$3=counter + 1 | 0;
                             return menhir_run11
                                     (counter$3,menhir_env$1,menhir_stack$1,_hT_,v$7,_hS_)}
                           return caml_trampoline_return
                                   (menhir_run11,[0,menhir_env$1,menhir_stack$1,_hT_,v$7,_hS_])
                          }
                       if(menhir_env$1[4])throw [0,Assert_failure,_bV_];
                       menhir_env$1[4] = 1;
                       return menhir_errorcase(menhir_env$1,menhir_stack$1,17);
                      case 28:
                       if(counter < 50)
                        {var counter$30=counter + 1 | 0;
                         return menhir_run44(counter$30,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run44,[0,menhir_env$0,menhir_stack$1]);
                      case 29:
                       if(counter < 50)
                        {var counter$24=counter + 1 | 0;
                         return menhir_run46(counter$24,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run46,[0,menhir_env$0,menhir_stack$1]);
                      case 30:
                       if(counter < 50)
                        {var counter$15=counter + 1 | 0;
                         return menhir_run35(counter$15,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run35,[0,menhir_env$0,menhir_stack$1])
                      }
                   if(menhir_env$0[4])throw [0,Assert_failure,_bU_];
                   menhir_env$0[4] = 1;
                   var
                    menhir_s$9=menhir_stack$1[2],
                    menhir_stack$12=menhir_stack$1[1];
                   return menhir_errorcase
                           (menhir_env$0,menhir_stack$12,menhir_s$9);
                  case 19:
                   if(menhir_env$0[4])throw [0,Assert_failure,_bW_];
                   var tok$6=menhir_env$0[3];
                   if(typeof tok$6 === "number")
                    switch(tok$6)
                     {case 0:
                       if(counter < 50)
                        {var counter$182=counter + 1 | 0;
                         return menhir_run15(counter$182,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run15,[0,menhir_env$0,menhir_stack$1]);
                      case 1:
                       if(counter < 50)
                        {var counter$165=counter + 1 | 0;
                         return menhir_run17(counter$165,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run17,[0,menhir_env$0,menhir_stack$1]);
                      case 2:
                       if(counter < 50)
                        {var counter$152=counter + 1 | 0;
                         return menhir_run19(counter$152,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run19,[0,menhir_env$0,menhir_stack$1]);
                      case 6:
                       if(counter < 50)
                        {var counter$137=counter + 1 | 0;
                         return menhir_run21(counter$137,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run21,[0,menhir_env$0,menhir_stack$1]);
                      case 10:
                       if(counter < 50)
                        {var counter$118=counter + 1 | 0;
                         return menhir_run29(counter$118,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run29,[0,menhir_env$0,menhir_stack$1]);
                      case 11:
                       if(counter < 50)
                        {var counter$101=counter + 1 | 0;
                         return menhir_run23(counter$101,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run23,[0,menhir_env$0,menhir_stack$1]);
                      case 12:
                       if(counter < 50)
                        {var counter$86=counter + 1 | 0;
                         return menhir_run27(counter$86,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run27,[0,menhir_env$0,menhir_stack$1]);
                      case 13:
                       if(counter < 50)
                        {var counter$73=counter + 1 | 0;
                         return menhir_run31(counter$73,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run31,[0,menhir_env$0,menhir_stack$1]);
                      case 22:
                       if(counter < 50)
                        {var counter$56=counter + 1 | 0;
                         return menhir_run33(counter$56,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run33,[0,menhir_env$0,menhir_stack$1]);
                      case 25:
                       if(counter < 50)
                        {var counter$39=counter + 1 | 0;
                         return menhir_run25(counter$39,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run25,[0,menhir_env$0,menhir_stack$1]);
                      case 30:
                       if(counter < 50)
                        {var counter$16=counter + 1 | 0;
                         return menhir_run35(counter$16,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run35,[0,menhir_env$0,menhir_stack$1]);
                      case 3:
                      case 5:
                      case 7:
                      case 17:
                      case 23:
                      case 27:
                      case 28:
                      case 29:
                       var
                        e2$2=menhir_stack$1[3],
                        match$4=menhir_stack$1[1],
                        e1$2=match$4[3],
                        menhir_s$10=match$4[2],
                        menhir_stack$13=match$4[1],
                        v$8=[1,7,e1$2,e2$2],
                        menhir_stack$0=menhir_stack$13,
                        menhir_s$0=menhir_s$10,
                        v$0=v$8;
                       continue
                      }
                   if(menhir_env$0[4])throw [0,Assert_failure,_bX_];
                   menhir_env$0[4] = 1;
                   var
                    menhir_s$11=menhir_stack$1[2],
                    menhir_stack$14=menhir_stack$1[1];
                   return menhir_errorcase
                           (menhir_env$0,menhir_stack$14,menhir_s$11);
                  case 20:
                   if(menhir_env$0[4])throw [0,Assert_failure,_bY_];
                   var tok$7=menhir_env$0[3];
                   if(typeof tok$7 === "number")
                    switch(tok$7)
                     {case 1:
                       if(counter < 50)
                        {var counter$166=counter + 1 | 0;
                         return menhir_run17(counter$166,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run17,[0,menhir_env$0,menhir_stack$1]);
                      case 2:
                       if(counter < 50)
                        {var counter$153=counter + 1 | 0;
                         return menhir_run19(counter$153,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run19,[0,menhir_env$0,menhir_stack$1]);
                      case 6:
                       if(counter < 50)
                        {var counter$138=counter + 1 | 0;
                         return menhir_run21(counter$138,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run21,[0,menhir_env$0,menhir_stack$1]);
                      case 10:
                       if(counter < 50)
                        {var counter$119=counter + 1 | 0;
                         return menhir_run29(counter$119,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run29,[0,menhir_env$0,menhir_stack$1]);
                      case 11:
                       if(counter < 50)
                        {var counter$102=counter + 1 | 0;
                         return menhir_run23(counter$102,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run23,[0,menhir_env$0,menhir_stack$1]);
                      case 12:
                       if(counter < 50)
                        {var counter$87=counter + 1 | 0;
                         return menhir_run27(counter$87,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run27,[0,menhir_env$0,menhir_stack$1]);
                      case 13:
                       if(counter < 50)
                        {var counter$74=counter + 1 | 0;
                         return menhir_run31(counter$74,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run31,[0,menhir_env$0,menhir_stack$1]);
                      case 22:
                       if(counter < 50)
                        {var counter$57=counter + 1 | 0;
                         return menhir_run33(counter$57,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run33,[0,menhir_env$0,menhir_stack$1]);
                      case 25:
                       if(counter < 50)
                        {var counter$40=counter + 1 | 0;
                         return menhir_run25(counter$40,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run25,[0,menhir_env$0,menhir_stack$1]);
                      case 0:
                      case 3:
                      case 5:
                      case 7:
                      case 17:
                      case 23:
                      case 27:
                      case 28:
                      case 29:
                      case 30:
                       var
                        e2$3=menhir_stack$1[3],
                        match$5=menhir_stack$1[1],
                        e1$3=match$5[3],
                        menhir_s$12=match$5[2],
                        menhir_stack$15=match$5[1],
                        v$9=[1,5,e1$3,e2$3],
                        menhir_stack$0=menhir_stack$15,
                        menhir_s$0=menhir_s$12,
                        v$0=v$9;
                       continue
                      }
                   if(menhir_env$0[4])throw [0,Assert_failure,_bZ_];
                   menhir_env$0[4] = 1;
                   var
                    menhir_s$13=menhir_stack$1[2],
                    menhir_stack$16=menhir_stack$1[1];
                   return menhir_errorcase
                           (menhir_env$0,menhir_stack$16,menhir_s$13);
                  case 21:
                   if(menhir_env$0[4])throw [0,Assert_failure,_b0_];
                   var tok$8=menhir_env$0[3];
                   if(typeof tok$8 === "number")
                    switch(tok$8)
                     {case 1:
                       if(counter < 50)
                        {var counter$167=counter + 1 | 0;
                         return menhir_run17(counter$167,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run17,[0,menhir_env$0,menhir_stack$1]);
                      case 2:
                       if(counter < 50)
                        {var counter$154=counter + 1 | 0;
                         return menhir_run19(counter$154,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run19,[0,menhir_env$0,menhir_stack$1]);
                      case 6:
                       if(counter < 50)
                        {var counter$139=counter + 1 | 0;
                         return menhir_run21(counter$139,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run21,[0,menhir_env$0,menhir_stack$1]);
                      case 11:
                       if(counter < 50)
                        {var counter$103=counter + 1 | 0;
                         return menhir_run23(counter$103,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run23,[0,menhir_env$0,menhir_stack$1]);
                      case 12:
                       if(counter < 50)
                        {var counter$88=counter + 1 | 0;
                         return menhir_run27(counter$88,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run27,[0,menhir_env$0,menhir_stack$1]);
                      case 13:
                       if(counter < 50)
                        {var counter$75=counter + 1 | 0;
                         return menhir_run31(counter$75,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run31,[0,menhir_env$0,menhir_stack$1]);
                      case 25:
                       if(counter < 50)
                        {var counter$41=counter + 1 | 0;
                         return menhir_run25(counter$41,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run25,[0,menhir_env$0,menhir_stack$1]);
                      case 4:
                      case 8:
                      case 9:
                      case 14:
                      case 15:
                      case 16:
                      case 18:
                      case 19:
                      case 20:
                      case 21:
                      case 24:
                      case 26:break;
                      default:
                       var
                        e2$4=menhir_stack$1[3],
                        match$6=menhir_stack$1[1],
                        e1$4=match$6[3],
                        menhir_s$14=match$6[2],
                        menhir_stack$17=match$6[1],
                        v$10=[1,10,e1$4,e2$4],
                        menhir_stack$0=menhir_stack$17,
                        menhir_s$0=menhir_s$14,
                        v$0=v$10;
                       continue}
                   if(menhir_env$0[4])throw [0,Assert_failure,_b1_];
                   menhir_env$0[4] = 1;
                   var
                    menhir_s$15=menhir_stack$1[2],
                    menhir_stack$18=menhir_stack$1[1];
                   return menhir_errorcase
                           (menhir_env$0,menhir_stack$18,menhir_s$15);
                  case 22:
                   if(menhir_env$0[4])throw [0,Assert_failure,_b2_];
                   var tok$9=menhir_env$0[3];
                   if(typeof tok$9 === "number")
                    switch(tok$9)
                     {case 1:
                       if(counter < 50)
                        {var counter$168=counter + 1 | 0;
                         return menhir_run17(counter$168,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run17,[0,menhir_env$0,menhir_stack$1]);
                      case 6:
                       if(counter < 50)
                        {var counter$140=counter + 1 | 0;
                         return menhir_run21(counter$140,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run21,[0,menhir_env$0,menhir_stack$1]);
                      case 11:
                       if(counter < 50)
                        {var counter$104=counter + 1 | 0;
                         return menhir_run23(counter$104,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run23,[0,menhir_env$0,menhir_stack$1]);
                      case 12:
                       if(counter < 50)
                        {var counter$89=counter + 1 | 0;
                         return menhir_run27(counter$89,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run27,[0,menhir_env$0,menhir_stack$1]);
                      case 25:
                       if(counter < 50)
                        {var counter$42=counter + 1 | 0;
                         return menhir_run25(counter$42,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run25,[0,menhir_env$0,menhir_stack$1]);
                      case 4:
                      case 8:
                      case 9:
                      case 14:
                      case 15:
                      case 16:
                      case 18:
                      case 19:
                      case 20:
                      case 21:
                      case 24:
                      case 26:break;
                      default:
                       var
                        e2$5=menhir_stack$1[3],
                        match$7=menhir_stack$1[1],
                        e1$5=match$7[3],
                        menhir_s$16=match$7[2],
                        menhir_stack$19=match$7[1],
                        v$11=[1,8,e1$5,e2$5],
                        menhir_stack$0=menhir_stack$19,
                        menhir_s$0=menhir_s$16,
                        v$0=v$11;
                       continue}
                   if(menhir_env$0[4])throw [0,Assert_failure,_b3_];
                   menhir_env$0[4] = 1;
                   var
                    menhir_s$17=menhir_stack$1[2],
                    menhir_stack$20=menhir_stack$1[1];
                   return menhir_errorcase
                           (menhir_env$0,menhir_stack$20,menhir_s$17);
                  case 23:
                   if(menhir_env$0[4])throw [0,Assert_failure,_b4_];
                   var tok$10=menhir_env$0[3];
                   if(typeof tok$10 === "number")
                    switch(tok$10)
                     {case 1:
                       if(counter < 50)
                        {var counter$169=counter + 1 | 0;
                         return menhir_run17(counter$169,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run17,[0,menhir_env$0,menhir_stack$1]);
                      case 2:
                       if(counter < 50)
                        {var counter$155=counter + 1 | 0;
                         return menhir_run19(counter$155,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run19,[0,menhir_env$0,menhir_stack$1]);
                      case 6:
                       if(counter < 50)
                        {var counter$141=counter + 1 | 0;
                         return menhir_run21(counter$141,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run21,[0,menhir_env$0,menhir_stack$1]);
                      case 11:
                       if(counter < 50)
                        {var counter$105=counter + 1 | 0;
                         return menhir_run23(counter$105,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run23,[0,menhir_env$0,menhir_stack$1]);
                      case 12:
                       if(counter < 50)
                        {var counter$90=counter + 1 | 0;
                         return menhir_run27(counter$90,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run27,[0,menhir_env$0,menhir_stack$1]);
                      case 13:
                       if(counter < 50)
                        {var counter$76=counter + 1 | 0;
                         return menhir_run31(counter$76,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run31,[0,menhir_env$0,menhir_stack$1]);
                      case 25:
                       if(counter < 50)
                        {var counter$43=counter + 1 | 0;
                         return menhir_run25(counter$43,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run25,[0,menhir_env$0,menhir_stack$1]);
                      case 4:
                      case 8:
                      case 9:
                      case 14:
                      case 15:
                      case 16:
                      case 18:
                      case 19:
                      case 20:
                      case 21:
                      case 24:
                      case 26:break;
                      default:
                       var
                        e2$6=menhir_stack$1[3],
                        match$8=menhir_stack$1[1],
                        e1$6=match$8[3],
                        menhir_s$18=match$8[2],
                        menhir_stack$21=match$8[1],
                        v$12=[1,11,e1$6,e2$6],
                        menhir_stack$0=menhir_stack$21,
                        menhir_s$0=menhir_s$18,
                        v$0=v$12;
                       continue}
                   if(menhir_env$0[4])throw [0,Assert_failure,_b5_];
                   menhir_env$0[4] = 1;
                   var
                    menhir_s$19=menhir_stack$1[2],
                    menhir_stack$22=menhir_stack$1[1];
                   return menhir_errorcase
                           (menhir_env$0,menhir_stack$22,menhir_s$19);
                  case 24:
                   if(menhir_env$0[4])throw [0,Assert_failure,_b6_];
                   var tok$11=menhir_env$0[3];
                   if(typeof tok$11 === "number")
                    switch(tok$11)
                     {case 1:
                       if(counter < 50)
                        {var counter$170=counter + 1 | 0;
                         return menhir_run17(counter$170,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run17,[0,menhir_env$0,menhir_stack$1]);
                      case 11:
                       if(counter < 50)
                        {var counter$106=counter + 1 | 0;
                         return menhir_run23(counter$106,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run23,[0,menhir_env$0,menhir_stack$1]);
                      case 25:
                       if(counter < 50)
                        {var counter$44=counter + 1 | 0;
                         return menhir_run25(counter$44,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run25,[0,menhir_env$0,menhir_stack$1]);
                      case 4:
                      case 8:
                      case 9:
                      case 14:
                      case 15:
                      case 16:
                      case 18:
                      case 19:
                      case 20:
                      case 21:
                      case 24:
                      case 26:break;
                      default:
                       var
                        e2$7=menhir_stack$1[3],
                        match$9=menhir_stack$1[1],
                        e1$7=match$9[3],
                        menhir_s$20=match$9[2],
                        menhir_stack$23=match$9[1],
                        v$13=[1,1,e1$7,e2$7],
                        menhir_stack$0=menhir_stack$23,
                        menhir_s$0=menhir_s$20,
                        v$0=v$13;
                       continue}
                   if(menhir_env$0[4])throw [0,Assert_failure,_b7_];
                   menhir_env$0[4] = 1;
                   var
                    menhir_s$21=menhir_stack$1[2],
                    menhir_stack$24=menhir_stack$1[1];
                   return menhir_errorcase
                           (menhir_env$0,menhir_stack$24,menhir_s$21);
                  case 25:
                   var
                    e2$8=menhir_stack$1[3],
                    match$10=menhir_stack$1[1],
                    e1$8=match$10[3],
                    menhir_s$22=match$10[2],
                    menhir_stack$25=match$10[1],
                    v$14=[1,3,e1$8,e2$8],
                    menhir_stack$0=menhir_stack$25,
                    menhir_s$0=menhir_s$22,
                    v$0=v$14;
                   continue;
                  case 26:
                   var
                    e2$9=menhir_stack$1[3],
                    match$11=menhir_stack$1[1],
                    e1$9=match$11[3],
                    menhir_s$23=match$11[2],
                    menhir_stack$26=match$11[1],
                    v$15=[1,4,e1$9,e2$9],
                    menhir_stack$0=menhir_stack$26,
                    menhir_s$0=menhir_s$23,
                    v$0=v$15;
                   continue;
                  case 27:
                   if(menhir_env$0[4])throw [0,Assert_failure,_b8_];
                   var tok$12=menhir_env$0[3];
                   if(typeof tok$12 === "number")
                    switch(tok$12)
                     {case 1:
                       if(counter < 50)
                        {var counter$171=counter + 1 | 0;
                         return menhir_run17(counter$171,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run17,[0,menhir_env$0,menhir_stack$1]);
                      case 11:
                       if(counter < 50)
                        {var counter$107=counter + 1 | 0;
                         return menhir_run23(counter$107,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run23,[0,menhir_env$0,menhir_stack$1]);
                      case 25:
                       if(counter < 50)
                        {var counter$45=counter + 1 | 0;
                         return menhir_run25(counter$45,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run25,[0,menhir_env$0,menhir_stack$1]);
                      case 4:
                      case 8:
                      case 9:
                      case 14:
                      case 15:
                      case 16:
                      case 18:
                      case 19:
                      case 20:
                      case 21:
                      case 24:
                      case 26:break;
                      default:
                       var
                        e2$10=menhir_stack$1[3],
                        match$12=menhir_stack$1[1],
                        e1$10=match$12[3],
                        menhir_s$24=match$12[2],
                        menhir_stack$27=match$12[1],
                        v$16=[1,0,e1$10,e2$10],
                        menhir_stack$0=menhir_stack$27,
                        menhir_s$0=menhir_s$24,
                        v$0=v$16;
                       continue}
                   if(menhir_env$0[4])throw [0,Assert_failure,_b9_];
                   menhir_env$0[4] = 1;
                   var
                    menhir_s$25=menhir_stack$1[2],
                    menhir_stack$28=menhir_stack$1[1];
                   return menhir_errorcase
                           (menhir_env$0,menhir_stack$28,menhir_s$25);
                  case 28:
                   if(menhir_env$0[4])throw [0,Assert_failure,_b__];
                   var tok$13=menhir_env$0[3];
                   if(typeof tok$13 === "number")
                    switch(tok$13)
                     {case 1:
                       if(counter < 50)
                        {var counter$172=counter + 1 | 0;
                         return menhir_run17(counter$172,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run17,[0,menhir_env$0,menhir_stack$1]);
                      case 6:
                       if(counter < 50)
                        {var counter$142=counter + 1 | 0;
                         return menhir_run21(counter$142,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run21,[0,menhir_env$0,menhir_stack$1]);
                      case 11:
                       if(counter < 50)
                        {var counter$108=counter + 1 | 0;
                         return menhir_run23(counter$108,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run23,[0,menhir_env$0,menhir_stack$1]);
                      case 12:
                       if(counter < 50)
                        {var counter$91=counter + 1 | 0;
                         return menhir_run27(counter$91,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run27,[0,menhir_env$0,menhir_stack$1]);
                      case 25:
                       if(counter < 50)
                        {var counter$46=counter + 1 | 0;
                         return menhir_run25(counter$46,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run25,[0,menhir_env$0,menhir_stack$1]);
                      case 4:
                      case 8:
                      case 9:
                      case 14:
                      case 15:
                      case 16:
                      case 18:
                      case 19:
                      case 20:
                      case 21:
                      case 24:
                      case 26:break;
                      default:
                       var
                        e2$11=menhir_stack$1[3],
                        match$13=menhir_stack$1[1],
                        e1$11=match$13[3],
                        menhir_s$26=match$13[2],
                        menhir_stack$29=match$13[1],
                        v$17=[1,9,e1$11,e2$11],
                        menhir_stack$0=menhir_stack$29,
                        menhir_s$0=menhir_s$26,
                        v$0=v$17;
                       continue}
                   if(menhir_env$0[4])throw [0,Assert_failure,_b$_];
                   menhir_env$0[4] = 1;
                   var
                    menhir_s$27=menhir_stack$1[2],
                    menhir_stack$30=menhir_stack$1[1];
                   return menhir_errorcase
                           (menhir_env$0,menhir_stack$30,menhir_s$27);
                  case 29:
                   var
                    e2$12=menhir_stack$1[3],
                    match$14=menhir_stack$1[1],
                    e1$12=match$14[3],
                    menhir_s$28=match$14[2],
                    menhir_stack$31=match$14[1],
                    v$18=[1,2,e1$12,e2$12],
                    menhir_stack$0=menhir_stack$31,
                    menhir_s$0=menhir_s$28,
                    v$0=v$18;
                   continue;
                  case 30:
                   if(menhir_env$0[4])throw [0,Assert_failure,_ca_];
                   var tok$14=menhir_env$0[3];
                   if(typeof tok$14 === "number")
                    switch(tok$14)
                     {case 1:
                       if(counter < 50)
                        {var counter$173=counter + 1 | 0;
                         return menhir_run17(counter$173,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run17,[0,menhir_env$0,menhir_stack$1]);
                      case 2:
                       if(counter < 50)
                        {var counter$156=counter + 1 | 0;
                         return menhir_run19(counter$156,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run19,[0,menhir_env$0,menhir_stack$1]);
                      case 6:
                       if(counter < 50)
                        {var counter$143=counter + 1 | 0;
                         return menhir_run21(counter$143,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run21,[0,menhir_env$0,menhir_stack$1]);
                      case 10:
                       if(counter < 50)
                        {var counter$120=counter + 1 | 0;
                         return menhir_run29(counter$120,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run29,[0,menhir_env$0,menhir_stack$1]);
                      case 11:
                       if(counter < 50)
                        {var counter$109=counter + 1 | 0;
                         return menhir_run23(counter$109,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run23,[0,menhir_env$0,menhir_stack$1]);
                      case 12:
                       if(counter < 50)
                        {var counter$92=counter + 1 | 0;
                         return menhir_run27(counter$92,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run27,[0,menhir_env$0,menhir_stack$1]);
                      case 13:
                       if(counter < 50)
                        {var counter$77=counter + 1 | 0;
                         return menhir_run31(counter$77,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run31,[0,menhir_env$0,menhir_stack$1]);
                      case 22:
                       if(counter < 50)
                        {var counter$58=counter + 1 | 0;
                         return menhir_run33(counter$58,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run33,[0,menhir_env$0,menhir_stack$1]);
                      case 25:
                       if(counter < 50)
                        {var counter$47=counter + 1 | 0;
                         return menhir_run25(counter$47,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run25,[0,menhir_env$0,menhir_stack$1]);
                      case 30:
                       if(counter < 50)
                        {var counter$17=counter + 1 | 0;
                         return menhir_run35(counter$17,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run35,[0,menhir_env$0,menhir_stack$1]);
                      case 0:
                      case 3:
                      case 5:
                      case 7:
                      case 17:
                      case 23:
                      case 27:
                      case 28:
                      case 29:
                       var
                        e2$13=menhir_stack$1[3],
                        match$15=menhir_stack$1[1],
                        e1$13=match$15[3],
                        menhir_s$29=match$15[2],
                        menhir_stack$32=match$15[1],
                        v$19=[1,6,e1$13,e2$13],
                        menhir_stack$0=menhir_stack$32,
                        menhir_s$0=menhir_s$29,
                        v$0=v$19;
                       continue
                      }
                   if(menhir_env$0[4])throw [0,Assert_failure,_cb_];
                   menhir_env$0[4] = 1;
                   var
                    menhir_s$30=menhir_stack$1[2],
                    menhir_stack$33=menhir_stack$1[1];
                   return menhir_errorcase
                           (menhir_env$0,menhir_stack$33,menhir_s$30);
                  case 31:
                   var
                    e$1=menhir_stack$1[3],
                    match$16=menhir_stack$1[1],
                    menhir_s$31=match$16[2],
                    menhir_stack$34=match$16[1],
                    v$20=[2,3,e$1],
                    menhir_stack$0=menhir_stack$34,
                    menhir_s$0=menhir_s$31,
                    v$0=v$20;
                   continue;
                  case 32:
                   if(menhir_env$0[4])throw [0,Assert_failure,_cc_];
                   var tok$15=menhir_env$0[3];
                   if(typeof tok$15 === "number")
                    switch(tok$15)
                     {case 0:
                       if(counter < 50)
                        {var counter$183=counter + 1 | 0;
                         return menhir_run15(counter$183,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run15,[0,menhir_env$0,menhir_stack$1]);
                      case 1:
                       if(counter < 50)
                        {var counter$174=counter + 1 | 0;
                         return menhir_run17(counter$174,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run17,[0,menhir_env$0,menhir_stack$1]);
                      case 2:
                       if(counter < 50)
                        {var counter$157=counter + 1 | 0;
                         return menhir_run19(counter$157,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run19,[0,menhir_env$0,menhir_stack$1]);
                      case 3:
                       var
                        menhir_env$2=menhir_discard(menhir_env$0),
                        v$21=menhir_stack$1[3],
                        match$17=menhir_stack$1[1],
                        menhir_s$32=match$17[2],
                        menhir_stack$35=match$17[1],
                        menhir_env$0=menhir_env$2,
                        menhir_stack$0=menhir_stack$35,
                        menhir_s$0=menhir_s$32,
                        v$0=v$21;
                       continue;
                      case 6:
                       if(counter < 50)
                        {var counter$144=counter + 1 | 0;
                         return menhir_run21(counter$144,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run21,[0,menhir_env$0,menhir_stack$1]);
                      case 7:
                       if(counter < 50)
                        {var counter$129=counter + 1 | 0;
                         return menhir_run38(counter$129,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run38,[0,menhir_env$0,menhir_stack$1]);
                      case 10:
                       if(counter < 50)
                        {var counter$121=counter + 1 | 0;
                         return menhir_run29(counter$121,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run29,[0,menhir_env$0,menhir_stack$1]);
                      case 11:
                       if(counter < 50)
                        {var counter$110=counter + 1 | 0;
                         return menhir_run23(counter$110,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run23,[0,menhir_env$0,menhir_stack$1]);
                      case 12:
                       if(counter < 50)
                        {var counter$93=counter + 1 | 0;
                         return menhir_run27(counter$93,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run27,[0,menhir_env$0,menhir_stack$1]);
                      case 13:
                       if(counter < 50)
                        {var counter$78=counter + 1 | 0;
                         return menhir_run31(counter$78,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run31,[0,menhir_env$0,menhir_stack$1]);
                      case 17:
                       if(counter < 50)
                        {var counter$65=counter + 1 | 0;
                         return menhir_run40(counter$65,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run40,[0,menhir_env$0,menhir_stack$1]);
                      case 22:
                       if(counter < 50)
                        {var counter$59=counter + 1 | 0;
                         return menhir_run33(counter$59,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run33,[0,menhir_env$0,menhir_stack$1]);
                      case 25:
                       if(counter < 50)
                        {var counter$48=counter + 1 | 0;
                         return menhir_run25(counter$48,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run25,[0,menhir_env$0,menhir_stack$1]);
                      case 28:
                       if(counter < 50)
                        {var counter$31=counter + 1 | 0;
                         return menhir_run44(counter$31,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run44,[0,menhir_env$0,menhir_stack$1]);
                      case 29:
                       if(counter < 50)
                        {var counter$25=counter + 1 | 0;
                         return menhir_run46(counter$25,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run46,[0,menhir_env$0,menhir_stack$1]);
                      case 30:
                       if(counter < 50)
                        {var counter$18=counter + 1 | 0;
                         return menhir_run35(counter$18,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run35,[0,menhir_env$0,menhir_stack$1])
                      }
                   if(menhir_env$0[4])throw [0,Assert_failure,_cd_];
                   menhir_env$0[4] = 1;
                   var
                    menhir_s$33=menhir_stack$1[2],
                    menhir_stack$36=menhir_stack$1[1];
                   return menhir_errorcase
                           (menhir_env$0,menhir_stack$36,menhir_s$33);
                  case 33:
                   var
                    e$2=menhir_stack$1[3],
                    match$18=menhir_stack$1[1],
                    menhir_s$34=match$18[2],
                    menhir_stack$37=match$18[1],
                    v$22=[2,1,e$2],
                    menhir_stack$0=menhir_stack$37,
                    menhir_s$0=menhir_s$34,
                    v$0=v$22;
                   continue;
                  case 34:
                   var
                    e$3=menhir_stack$1[3],
                    match$19=menhir_stack$1[1],
                    menhir_s$35=match$19[2],
                    menhir_stack$38=match$19[1],
                    v$23=[2,2,e$3],
                    menhir_stack$0=menhir_stack$38,
                    menhir_s$0=menhir_s$35,
                    v$0=v$23;
                   continue;
                  case 35:
                   var
                    e$4=menhir_stack$1[3],
                    match$20=menhir_stack$1[1],
                    menhir_s$36=match$20[2],
                    menhir_stack$39=match$20[1],
                    v$24=[2,0,e$4],
                    menhir_stack$0=menhir_stack$39,
                    menhir_s$0=menhir_s$36,
                    v$0=v$24;
                   continue;
                  case 36:
                   if(menhir_env$0[4])throw [0,Assert_failure,_ce_];
                   var tok$16=menhir_env$0[3];
                   if(typeof tok$16 === "number")
                    switch(tok$16)
                     {case 0:
                       if(counter < 50)
                        {var counter$184=counter + 1 | 0;
                         return menhir_run15(counter$184,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run15,[0,menhir_env$0,menhir_stack$1]);
                      case 1:
                       if(counter < 50)
                        {var counter$175=counter + 1 | 0;
                         return menhir_run17(counter$175,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run17,[0,menhir_env$0,menhir_stack$1]);
                      case 2:
                       if(counter < 50)
                        {var counter$158=counter + 1 | 0;
                         return menhir_run19(counter$158,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run19,[0,menhir_env$0,menhir_stack$1]);
                      case 5:
                       var
                        menhir_env$3=menhir_discard(menhir_env$0),
                        e$5=menhir_stack$1[3],
                        match$21=menhir_stack$1[1],
                        startpos_1=match$21[3],
                        menhir_s$38=match$21[2],
                        menhir_stack$41=match$21[1],
                        v$25=[1,e$5];
                       if(counter < 50)
                        {var counter$9=counter + 1 | 0;
                         return menhir_goto_number
                                 (counter$9,
                                  menhir_env$3,
                                  menhir_stack$41,
                                  menhir_s$38,
                                  v$25,
                                  startpos_1)}
                       return caml_trampoline_return
                               (menhir_goto_number,
                                [0,menhir_env$3,menhir_stack$41,menhir_s$38,v$25,startpos_1]);
                      case 6:
                       if(counter < 50)
                        {var counter$145=counter + 1 | 0;
                         return menhir_run21(counter$145,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run21,[0,menhir_env$0,menhir_stack$1]);
                      case 7:
                       if(counter < 50)
                        {var counter$130=counter + 1 | 0;
                         return menhir_run38(counter$130,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run38,[0,menhir_env$0,menhir_stack$1]);
                      case 10:
                       if(counter < 50)
                        {var counter$122=counter + 1 | 0;
                         return menhir_run29(counter$122,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run29,[0,menhir_env$0,menhir_stack$1]);
                      case 11:
                       if(counter < 50)
                        {var counter$111=counter + 1 | 0;
                         return menhir_run23(counter$111,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run23,[0,menhir_env$0,menhir_stack$1]);
                      case 12:
                       if(counter < 50)
                        {var counter$94=counter + 1 | 0;
                         return menhir_run27(counter$94,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run27,[0,menhir_env$0,menhir_stack$1]);
                      case 13:
                       if(counter < 50)
                        {var counter$79=counter + 1 | 0;
                         return menhir_run31(counter$79,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run31,[0,menhir_env$0,menhir_stack$1]);
                      case 17:
                       if(counter < 50)
                        {var counter$66=counter + 1 | 0;
                         return menhir_run40(counter$66,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run40,[0,menhir_env$0,menhir_stack$1]);
                      case 22:
                       if(counter < 50)
                        {var counter$60=counter + 1 | 0;
                         return menhir_run33(counter$60,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run33,[0,menhir_env$0,menhir_stack$1]);
                      case 25:
                       if(counter < 50)
                        {var counter$49=counter + 1 | 0;
                         return menhir_run25(counter$49,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run25,[0,menhir_env$0,menhir_stack$1]);
                      case 28:
                       if(counter < 50)
                        {var counter$32=counter + 1 | 0;
                         return menhir_run44(counter$32,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run44,[0,menhir_env$0,menhir_stack$1]);
                      case 29:
                       if(counter < 50)
                        {var counter$26=counter + 1 | 0;
                         return menhir_run46(counter$26,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run46,[0,menhir_env$0,menhir_stack$1]);
                      case 30:
                       if(counter < 50)
                        {var counter$19=counter + 1 | 0;
                         return menhir_run35(counter$19,menhir_env$0,menhir_stack$1)}
                       return caml_trampoline_return
                               (menhir_run35,[0,menhir_env$0,menhir_stack$1])
                      }
                   if(menhir_env$0[4])throw [0,Assert_failure,_cf_];
                   menhir_env$0[4] = 1;
                   var
                    menhir_s$37=menhir_stack$1[2],
                    menhir_stack$40=menhir_stack$1[1];
                   return menhir_errorcase
                           (menhir_env$0,menhir_stack$40,menhir_s$37);
                  default:return menhir_fail(0)}}},
           menhir_goto_command=
            function(counter,menhir_env,menhir_stack,menhir_s,v)
             {var menhir_stack$0=[0,menhir_stack,menhir_s,v];
              if(menhir_env[4])throw [0,Assert_failure,_cg_];
              var tok=menhir_env[3];
              if(typeof tok === "number")
               {if(23 === tok)
                 {var
                   menhir_env$0=menhir_discard(menhir_env),
                   tok$0=menhir_env$0[3],
                   switch$0=0;
                  if(typeof tok$0 === "number")
                   switch(tok$0)
                    {case 23:
                      var _hJ_=4;
                      if(counter < 50)
                       {var counter$0=counter + 1 | 0;
                        return menhir_run1$0
                                (counter$0,menhir_env$0,menhir_stack$0,_hJ_)}
                      return caml_trampoline_return
                              (menhir_run1$0,[0,menhir_env$0,menhir_stack$0,_hJ_]);
                     case 16:
                     case 24:switch$0 = 1;break
                     }
                  else
                   switch(tok$0[0]){case 0:case 3:break;default:switch$0 = 1}
                  if(switch$0)
                   {var _hI_=4;
                    if(counter < 50)
                     {var counter$1=counter + 1 | 0;
                      return menhir_reduce26$0
                              (counter$1,menhir_env$0,menhir_stack$0,_hI_)}
                    return caml_trampoline_return
                            (menhir_reduce26$0,[0,menhir_env$0,menhir_stack$0,_hI_])}
                  if(menhir_env$0[4])throw [0,Assert_failure,_ch_];
                  menhir_env$0[4] = 1;
                  return menhir_errorcase(menhir_env$0,menhir_stack$0,4)}
                if(24 === tok)
                 {var
                   cmd=menhir_stack$0[3],
                   match=menhir_stack$0[1],
                   menhir_s$0=match[2],
                   menhir_stack$1=match[1],
                   v$0=[0,cmd,0];
                  return menhir_goto_ast
                          (menhir_env,menhir_stack$1,menhir_s$0,v$0)}}
              if(menhir_env[4])throw [0,Assert_failure,_ci_];
              menhir_env[4] = 1;
              var
               menhir_s$1=menhir_stack$0[2],
               menhir_stack$2=menhir_stack$0[1];
              return menhir_errorcase(menhir_env,menhir_stack$2,menhir_s$1)},
           menhir_goto_number=
            function(counter,menhir_env,menhir_stack,menhir_s,nb,startpos)
             {switch(menhir_s)
               {case 6:
                 var
                  menhir_s$0=menhir_stack[2],
                  menhir_stack$0=menhir_stack[1],
                  v$0=[1,nb];
                 if(counter < 50)
                  {var counter$0=counter + 1 | 0;
                   return menhir_goto_arg
                           (counter$0,menhir_env,menhir_stack$0,menhir_s$0,v$0)}
                 return caml_trampoline_return
                         (menhir_goto_arg,
                          [0,menhir_env,menhir_stack$0,menhir_s$0,v$0]);
                case 8:
                 var
                  match=menhir_stack[1],
                  menhir_s$1=match[2],
                  menhir_stack$1=match[1],
                  v$2=[0,sign_minus,nb];
                 if(counter < 50)
                  {var counter$3=counter + 1 | 0;
                   return menhir_goto_offset
                           (counter$3,menhir_env,menhir_stack$1,menhir_s$1,v$2)}
                 return caml_trampoline_return
                         (menhir_goto_offset,
                          [0,menhir_env,menhir_stack$1,menhir_s$1,v$2]);
                case 9:
                 var
                  match$0=menhir_stack[1],
                  menhir_s$2=match$0[2],
                  menhir_stack$2=match$0[1],
                  v$3=[0,sign_plus,nb];
                 if(counter < 50)
                  {var counter$4=counter + 1 | 0;
                   return menhir_goto_offset
                           (counter$4,menhir_env,menhir_stack$2,menhir_s$2,v$3)}
                 return caml_trampoline_return
                         (menhir_goto_offset,
                          [0,menhir_env,menhir_stack$2,menhir_s$2,v$3]);
                case 10:
                 var
                  menhir_s$3=menhir_stack[2],
                  menhir_stack$3=menhir_stack[1],
                  v$4=[0,sign_plus,nb];
                 if(counter < 50)
                  {var counter$5=counter + 1 | 0;
                   return menhir_goto_offset
                           (counter$5,menhir_env,menhir_stack$3,menhir_s$3,v$4)}
                 return caml_trampoline_return
                         (menhir_goto_offset,
                          [0,menhir_env,menhir_stack$3,menhir_s$3,v$4]);
                case 11:
                 var
                  menhir_s$4=menhir_stack[2],
                  menhir_stack$4=menhir_stack[1],
                  v$5=[0,sign_minus,nb];
                 if(counter < 50)
                  {var counter$6=counter + 1 | 0;
                   return menhir_goto_offset
                           (counter$6,menhir_env,menhir_stack$4,menhir_s$4,v$5)}
                 return caml_trampoline_return
                         (menhir_goto_offset,
                          [0,menhir_env,menhir_stack$4,menhir_s$4,v$5]);
                case 12:
                 var
                  menhir_s$5=menhir_stack[2],
                  menhir_stack$5=menhir_stack[1],
                  v$6=[0,sign_plus,nb];
                 if(counter < 50)
                  {var counter$7=counter + 1 | 0;
                   return menhir_goto_offset
                           (counter$7,menhir_env,menhir_stack$5,menhir_s$5,v$6)}
                 return caml_trampoline_return
                         (menhir_goto_offset,
                          [0,menhir_env,menhir_stack$5,menhir_s$5,v$6]);
                case 37:
                 var v$7=[1,startpos,nb];
                 if(counter < 50)
                  {var counter$2=counter + 1 | 0;
                   return menhir_goto_command
                           (counter$2,menhir_env,menhir_stack,menhir_s,v$7)}
                 return caml_trampoline_return
                         (menhir_goto_command,
                          [0,menhir_env,menhir_stack,menhir_s,v$7]);
                case 7:
                case 13:
                 var v$1=[0,sign_plus,nb];
                 if(counter < 50)
                  {var counter$8=counter + 1 | 0;
                   return menhir_goto_offset
                           (counter$8,menhir_env,menhir_stack,menhir_s,v$1)}
                 return caml_trampoline_return
                         (menhir_goto_offset,
                          [0,menhir_env,menhir_stack,menhir_s,v$1]);
                case 5:
                case 14:
                 var v=[1,nb];
                 if(counter < 50)
                  {var counter$1=counter + 1 | 0;
                   return menhir_goto_arg
                           (counter$1,menhir_env,menhir_stack,menhir_s,v)}
                 return caml_trampoline_return
                         (menhir_goto_arg,[0,menhir_env,menhir_stack,menhir_s,v]);
                default:return menhir_fail(0)}},
           menhir_run59=
            function(counter,menhir_env,menhir_stack,menhir_s)
             {var
               menhir_stack$0=[0,menhir_stack,menhir_s],
               menhir_env$0=menhir_discard(menhir_env),
               tok=menhir_env$0[3];
              if(typeof tok === "number")
               {if(16 === tok)
                 {var _hE_=menhir_env$0[2][11],_hF_=12;
                  if(counter < 50)
                   {var counter$0=counter + 1 | 0;
                    return menhir_run5
                            (counter$0,menhir_env$0,menhir_stack$0,_hF_,_hE_)}
                  return caml_trampoline_return
                          (menhir_run5,[0,menhir_env$0,menhir_stack$0,_hF_,_hE_])}}
              else
               switch(tok[0])
                {case 1:
                  var v=tok[1],_hG_=menhir_env$0[2][11],_hH_=12;
                  if(counter < 50)
                   {var counter$1=counter + 1 | 0;
                    return menhir_run4
                            (counter$1,menhir_env$0,menhir_stack$0,_hH_,v,_hG_)}
                  return caml_trampoline_return
                          (menhir_run4,[0,menhir_env$0,menhir_stack$0,_hH_,v,_hG_]);
                 case 2:
                  var
                   v$0=tok[1],
                   menhir_env$1=menhir_discard(menhir_env$0),
                   menhir_s$0=menhir_stack$0[2],
                   menhir_stack$1=menhir_stack$0[1],
                   v$1=[1,sign_plus,v$0];
                  if(counter < 50)
                   {var counter$2=counter + 1 | 0;
                    return menhir_goto_offset
                            (counter$2,menhir_env$1,menhir_stack$1,menhir_s$0,v$1)}
                  return caml_trampoline_return
                          (menhir_goto_offset,
                           [0,menhir_env$1,menhir_stack$1,menhir_s$0,v$1])
                 }
              if(menhir_env$0[4])throw [0,Assert_failure,_cj_];
              menhir_env$0[4] = 1;
              return menhir_errorcase(menhir_env$0,menhir_stack$0,12)},
           menhir_run62=
            function(counter,menhir_env,menhir_stack,menhir_s)
             {var
               menhir_stack$0=[0,menhir_stack,menhir_s],
               menhir_env$0=menhir_discard(menhir_env),
               tok=menhir_env$0[3];
              if(typeof tok === "number")
               {if(16 === tok)
                 {var _hA_=menhir_env$0[2][11],_hB_=11;
                  if(counter < 50)
                   {var counter$0=counter + 1 | 0;
                    return menhir_run5
                            (counter$0,menhir_env$0,menhir_stack$0,_hB_,_hA_)}
                  return caml_trampoline_return
                          (menhir_run5,[0,menhir_env$0,menhir_stack$0,_hB_,_hA_])}}
              else
               switch(tok[0])
                {case 1:
                  var v=tok[1],_hC_=menhir_env$0[2][11],_hD_=11;
                  if(counter < 50)
                   {var counter$1=counter + 1 | 0;
                    return menhir_run4
                            (counter$1,menhir_env$0,menhir_stack$0,_hD_,v,_hC_)}
                  return caml_trampoline_return
                          (menhir_run4,[0,menhir_env$0,menhir_stack$0,_hD_,v,_hC_]);
                 case 2:
                  var
                   v$0=tok[1],
                   menhir_env$1=menhir_discard(menhir_env$0),
                   menhir_s$0=menhir_stack$0[2],
                   menhir_stack$1=menhir_stack$0[1],
                   v$1=[1,sign_minus,v$0];
                  if(counter < 50)
                   {var counter$2=counter + 1 | 0;
                    return menhir_goto_offset
                            (counter$2,menhir_env$1,menhir_stack$1,menhir_s$0,v$1)}
                  return caml_trampoline_return
                          (menhir_goto_offset,
                           [0,menhir_env$1,menhir_stack$1,menhir_s$0,v$1])
                 }
              if(menhir_env$0[4])throw [0,Assert_failure,_ck_];
              menhir_env$0[4] = 1;
              return menhir_errorcase(menhir_env$0,menhir_stack$0,11)},
           menhir_run65=
            function(counter,menhir_env,menhir_stack,menhir_s,id,startpos)
             {var menhir_env$0=menhir_discard(menhir_env),v=[1,sign_plus,id];
              if(counter < 50)
               {var counter$0=counter + 1 | 0;
                return menhir_goto_offset
                        (counter$0,menhir_env$0,menhir_stack,menhir_s,v)}
              return caml_trampoline_return
                      (menhir_goto_offset,
                       [0,menhir_env$0,menhir_stack,menhir_s,v])},
           menhir_run66=
            function(counter,menhir_env,menhir_stack,menhir_s)
             {var
               menhir_stack$0=[0,menhir_stack,menhir_s],
               menhir_env$0=menhir_discard(menhir_env),
               tok=menhir_env$0[3];
              if(typeof tok === "number")
               switch(tok)
                {case 6:
                  var
                   menhir_stack$1=[0,menhir_stack$0,10],
                   menhir_env$1=menhir_discard(menhir_env$0),
                   tok$0=menhir_env$1[3];
                  if(typeof tok$0 === "number")
                   {if(16 === tok$0)
                     {var _ho_=menhir_env$1[2][11],_hp_=9;
                      if(counter < 50)
                       {var counter$0=counter + 1 | 0;
                        return menhir_run5
                                (counter$0,menhir_env$1,menhir_stack$1,_hp_,_ho_)}
                      return caml_trampoline_return
                              (menhir_run5,[0,menhir_env$1,menhir_stack$1,_hp_,_ho_])}}
                  else
                   if(1 === tok$0[0])
                    {var v=tok$0[1],_hq_=menhir_env$1[2][11],_hr_=9;
                     if(counter < 50)
                      {var counter$3=counter + 1 | 0;
                       return menhir_run4
                               (counter$3,menhir_env$1,menhir_stack$1,_hr_,v,_hq_)}
                     return caml_trampoline_return
                             (menhir_run4,[0,menhir_env$1,menhir_stack$1,_hr_,v,_hq_])}
                  if(menhir_env$1[4])throw [0,Assert_failure,_cm_];
                  menhir_env$1[4] = 1;
                  return menhir_errorcase(menhir_env$1,menhir_stack$1,9);
                 case 12:
                  var
                   menhir_stack$2=[0,menhir_stack$0,10],
                   menhir_env$2=menhir_discard(menhir_env$0),
                   tok$1=menhir_env$2[3];
                  if(typeof tok$1 === "number")
                   {if(16 === tok$1)
                     {var _hs_=menhir_env$2[2][11],_ht_=8;
                      if(counter < 50)
                       {var counter$1=counter + 1 | 0;
                        return menhir_run5
                                (counter$1,menhir_env$2,menhir_stack$2,_ht_,_hs_)}
                      return caml_trampoline_return
                              (menhir_run5,[0,menhir_env$2,menhir_stack$2,_ht_,_hs_])}}
                  else
                   if(1 === tok$1[0])
                    {var v$0=tok$1[1],_hu_=menhir_env$2[2][11],_hv_=8;
                     if(counter < 50)
                      {var counter$4=counter + 1 | 0;
                       return menhir_run4
                               (counter$4,menhir_env$2,menhir_stack$2,_hv_,v$0,_hu_)}
                     return caml_trampoline_return
                             (menhir_run4,[0,menhir_env$2,menhir_stack$2,_hv_,v$0,_hu_])}
                  if(menhir_env$2[4])throw [0,Assert_failure,_cn_];
                  menhir_env$2[4] = 1;
                  return menhir_errorcase(menhir_env$2,menhir_stack$2,8);
                 case 16:
                  var _hw_=menhir_env$0[2][11],_hx_=10;
                  if(counter < 50)
                   {var counter$2=counter + 1 | 0;
                    return menhir_run5
                            (counter$2,menhir_env$0,menhir_stack$0,_hx_,_hw_)}
                  return caml_trampoline_return
                          (menhir_run5,[0,menhir_env$0,menhir_stack$0,_hx_,_hw_])
                 }
              else
               if(1 === tok[0])
                {var v$1=tok[1],_hy_=menhir_env$0[2][11],_hz_=10;
                 if(counter < 50)
                  {var counter$5=counter + 1 | 0;
                   return menhir_run4
                           (counter$5,menhir_env$0,menhir_stack$0,_hz_,v$1,_hy_)}
                 return caml_trampoline_return
                         (menhir_run4,[0,menhir_env$0,menhir_stack$0,_hz_,v$1,_hy_])}
              if(menhir_env$0[4])throw [0,Assert_failure,_cl_];
              menhir_env$0[4] = 1;
              return menhir_errorcase(menhir_env$0,menhir_stack$0,10)},
           menhir_goto_arg=
            function(counter,menhir_env,menhir_stack$1,menhir_s$1,v$1)
             {var menhir_stack$2=[0,menhir_stack$1,menhir_s$1,v$1];
              if(menhir_env[4])throw [0,Assert_failure,_co_];
              var tok=menhir_env[3];
              if(typeof tok === "number")
               {var switcher=tok - 17 | 0;
                if(! (9 < switcher >>> 0))
                 switch(switcher)
                  {case 9:
                    var
                     menhir_env$0=menhir_discard(menhir_env),
                     tok$0=menhir_env$0[3];
                    if(typeof tok$0 === "number")
                     switch(tok$0)
                      {case 15:
                        var _hg_=5;
                        if(counter < 50)
                         {var counter$3=counter + 1 | 0;
                          return menhir_run54
                                  (counter$3,menhir_env$0,menhir_stack$2,_hg_)}
                        return caml_trampoline_return
                                (menhir_run54,[0,menhir_env$0,menhir_stack$2,_hg_]);
                       case 16:
                        var _hh_=menhir_env$0[2][11],_hi_=5;
                        if(counter < 50)
                         {var counter$2=counter + 1 | 0;
                          return menhir_run5
                                  (counter$2,menhir_env$0,menhir_stack$2,_hi_,_hh_)}
                        return caml_trampoline_return
                                (menhir_run5,[0,menhir_env$0,menhir_stack$2,_hi_,_hh_]);
                       case 19:
                        var _hj_=5;
                        if(counter < 50)
                         {var counter$0=counter + 1 | 0;
                          return menhir_run79
                                  (counter$0,menhir_env$0,menhir_stack$2,_hj_)}
                        return caml_trampoline_return
                                (menhir_run79,[0,menhir_env$0,menhir_stack$2,_hj_])
                       }
                    else
                     switch(tok$0[0])
                      {case 1:
                        var v$3=tok$0[1],_hk_=menhir_env$0[2][11],_hl_=5;
                        if(counter < 50)
                         {var counter$4=counter + 1 | 0;
                          return menhir_run4
                                  (counter$4,menhir_env$0,menhir_stack$2,_hl_,v$3,_hk_)}
                        return caml_trampoline_return
                                (menhir_run4,[0,menhir_env$0,menhir_stack$2,_hl_,v$3,_hk_]);
                       case 2:
                        var v$4=tok$0[1],_hm_=menhir_env$0[2][11],_hn_=5;
                        if(counter < 50)
                         {var counter$1=counter + 1 | 0;
                          return menhir_run78
                                  (counter$1,menhir_env$0,menhir_stack$2,_hn_,v$4,_hm_)}
                        return caml_trampoline_return
                                (menhir_run78,[0,menhir_env$0,menhir_stack$2,_hn_,v$4,_hm_])
                       }
                    if(menhir_env$0[4])throw [0,Assert_failure,_cq_];
                    menhir_env$0[4] = 1;
                    return menhir_errorcase(menhir_env$0,menhir_stack$2,5);
                   case 0:
                   case 6:
                   case 7:
                    var
                     x$0=menhir_stack$2[3],
                     menhir_s$3=menhir_stack$2[2],
                     menhir_stack$4=menhir_stack$2[1],
                     v$2=[0,x$0,0],
                     menhir_stack=menhir_stack$4,
                     menhir_s=menhir_s$3,
                     v=v$2;
                    for(;;)
                     {if(5 === menhir_s)
                       {var
                         x=menhir_stack[3],
                         menhir_s$0=menhir_stack[2],
                         menhir_stack$0=menhir_stack[1],
                         v$0=[0,x,v],
                         menhir_stack=menhir_stack$0,
                         menhir_s=menhir_s$0,
                         v=v$0;
                        continue}
                      if(14 === menhir_s)
                       {if(counter < 50)
                         {var counter$5=counter + 1 | 0;
                          return menhir_goto_loption_separated_
                                  (counter$5,menhir_env,menhir_stack,menhir_s,v)}
                        return caml_trampoline_return
                                (menhir_goto_loption_separated_,
                                 [0,menhir_env,menhir_stack,menhir_s,v])}
                      return menhir_fail(0)}
                   }}
              if(menhir_env[4])throw [0,Assert_failure,_cp_];
              menhir_env[4] = 1;
              var
               menhir_s$2=menhir_stack$2[2],
               menhir_stack$3=menhir_stack$2[1];
              return menhir_errorcase(menhir_env,menhir_stack$3,menhir_s$2)},
           menhir_run6=
            function(counter,menhir_env,menhir_stack,menhir_s)
             {var
               menhir_env$0=menhir_env,
               menhir_stack$0=menhir_stack,
               menhir_s$0=menhir_s;
              for(;;)
               {var
                 menhir_stack$1=[0,menhir_stack$0,menhir_s$0],
                 menhir_env$1=menhir_discard(menhir_env$0),
                 tok=menhir_env$1[3];
                if(typeof tok === "number")
                 switch(tok)
                  {case 6:
                    var
                     menhir_env$0=menhir_env$1,
                     menhir_stack$0=menhir_stack$1,
                     menhir_s$0=35;
                    continue;
                   case 9:
                    var _g__=35;
                    if(counter < 50)
                     {var counter$4=counter + 1 | 0;
                      return menhir_run8
                              (counter$4,menhir_env$1,menhir_stack$1,_g__)}
                    return caml_trampoline_return
                            (menhir_run8,[0,menhir_env$1,menhir_stack$1,_g__]);
                   case 12:
                    var _g$_=35;
                    if(counter < 50)
                     {var counter$3=counter + 1 | 0;
                      return menhir_run9
                              (counter$3,menhir_env$1,menhir_stack$1,_g$_)}
                    return caml_trampoline_return
                            (menhir_run9,[0,menhir_env$1,menhir_stack$1,_g$_]);
                   case 14:
                    var _ha_=35;
                    if(counter < 50)
                     {var counter$2=counter + 1 | 0;
                      return menhir_run10
                              (counter$2,menhir_env$1,menhir_stack$1,_ha_)}
                    return caml_trampoline_return
                            (menhir_run10,[0,menhir_env$1,menhir_stack$1,_ha_]);
                   case 20:
                    var _hb_=35;
                    if(counter < 50)
                     {var counter$0=counter + 1 | 0;
                      return menhir_run12
                              (counter$0,menhir_env$1,menhir_stack$1,_hb_)}
                    return caml_trampoline_return
                            (menhir_run12,[0,menhir_env$1,menhir_stack$1,_hb_])
                   }
                else
                 switch(tok[0])
                  {case 1:
                    var v=tok[1],_hc_=menhir_env$1[2][11],_hd_=35;
                    if(counter < 50)
                     {var counter$5=counter + 1 | 0;
                      return menhir_run7
                              (counter$5,menhir_env$1,menhir_stack$1,_hd_,v,_hc_)}
                    return caml_trampoline_return
                            (menhir_run7,[0,menhir_env$1,menhir_stack$1,_hd_,v,_hc_]);
                   case 2:
                    var v$0=tok[1],_he_=menhir_env$1[2][11],_hf_=35;
                    if(counter < 50)
                     {var counter$1=counter + 1 | 0;
                      return menhir_run11
                              (counter$1,menhir_env$1,menhir_stack$1,_hf_,v$0,_he_)}
                    return caml_trampoline_return
                            (menhir_run11,[0,menhir_env$1,menhir_stack$1,_hf_,v$0,_he_])
                   }
                if(menhir_env$1[4])throw [0,Assert_failure,_ct_];
                menhir_env$1[4] = 1;
                return menhir_errorcase(menhir_env$1,menhir_stack$1,35)}},
           menhir_run7=
            function(counter,menhir_env,menhir_stack,menhir_s,i,startpos)
             {var menhir_env$0=menhir_discard(menhir_env),v=[0,i];
              if(counter < 50)
               {var counter$0=counter + 1 | 0;
                return menhir_goto_meta_expr
                        (counter$0,menhir_env$0,menhir_stack,menhir_s,v)}
              return caml_trampoline_return
                      (menhir_goto_meta_expr,
                       [0,menhir_env$0,menhir_stack,menhir_s,v])},
           menhir_run8=
            function(counter,menhir_env,menhir_stack,menhir_s)
             {var
               menhir_env$0=menhir_env,
               menhir_stack$0=menhir_stack,
               menhir_s$0=menhir_s;
              for(;;)
               {var
                 menhir_stack$1=[0,menhir_stack$0,menhir_s$0],
                 menhir_env$1=menhir_discard(menhir_env$0),
                 tok=menhir_env$1[3];
                if(typeof tok === "number")
                 switch(tok)
                  {case 6:
                    var _g2_=34;
                    if(counter < 50)
                     {var counter$5=counter + 1 | 0;
                      return menhir_run6
                              (counter$5,menhir_env$1,menhir_stack$1,_g2_)}
                    return caml_trampoline_return
                            (menhir_run6,[0,menhir_env$1,menhir_stack$1,_g2_]);
                   case 9:
                    var
                     menhir_env$0=menhir_env$1,
                     menhir_stack$0=menhir_stack$1,
                     menhir_s$0=34;
                    continue;
                   case 12:
                    var _g3_=34;
                    if(counter < 50)
                     {var counter$3=counter + 1 | 0;
                      return menhir_run9
                              (counter$3,menhir_env$1,menhir_stack$1,_g3_)}
                    return caml_trampoline_return
                            (menhir_run9,[0,menhir_env$1,menhir_stack$1,_g3_]);
                   case 14:
                    var _g4_=34;
                    if(counter < 50)
                     {var counter$2=counter + 1 | 0;
                      return menhir_run10
                              (counter$2,menhir_env$1,menhir_stack$1,_g4_)}
                    return caml_trampoline_return
                            (menhir_run10,[0,menhir_env$1,menhir_stack$1,_g4_]);
                   case 20:
                    var _g5_=34;
                    if(counter < 50)
                     {var counter$0=counter + 1 | 0;
                      return menhir_run12
                              (counter$0,menhir_env$1,menhir_stack$1,_g5_)}
                    return caml_trampoline_return
                            (menhir_run12,[0,menhir_env$1,menhir_stack$1,_g5_])
                   }
                else
                 switch(tok[0])
                  {case 1:
                    var v=tok[1],_g6_=menhir_env$1[2][11],_g7_=34;
                    if(counter < 50)
                     {var counter$4=counter + 1 | 0;
                      return menhir_run7
                              (counter$4,menhir_env$1,menhir_stack$1,_g7_,v,_g6_)}
                    return caml_trampoline_return
                            (menhir_run7,[0,menhir_env$1,menhir_stack$1,_g7_,v,_g6_]);
                   case 2:
                    var v$0=tok[1],_g8_=menhir_env$1[2][11],_g9_=34;
                    if(counter < 50)
                     {var counter$1=counter + 1 | 0;
                      return menhir_run11
                              (counter$1,menhir_env$1,menhir_stack$1,_g9_,v$0,_g8_)}
                    return caml_trampoline_return
                            (menhir_run11,[0,menhir_env$1,menhir_stack$1,_g9_,v$0,_g8_])
                   }
                if(menhir_env$1[4])throw [0,Assert_failure,_cu_];
                menhir_env$1[4] = 1;
                return menhir_errorcase(menhir_env$1,menhir_stack$1,34)}},
           menhir_run9=
            function(counter,menhir_env,menhir_stack,menhir_s)
             {var
               menhir_env$0=menhir_env,
               menhir_stack$0=menhir_stack,
               menhir_s$0=menhir_s;
              for(;;)
               {var
                 menhir_stack$1=[0,menhir_stack$0,menhir_s$0],
                 menhir_env$1=menhir_discard(menhir_env$0),
                 tok=menhir_env$1[3];
                if(typeof tok === "number")
                 switch(tok)
                  {case 6:
                    var _gU_=33;
                    if(counter < 50)
                     {var counter$5=counter + 1 | 0;
                      return menhir_run6
                              (counter$5,menhir_env$1,menhir_stack$1,_gU_)}
                    return caml_trampoline_return
                            (menhir_run6,[0,menhir_env$1,menhir_stack$1,_gU_]);
                   case 9:
                    var _gV_=33;
                    if(counter < 50)
                     {var counter$3=counter + 1 | 0;
                      return menhir_run8
                              (counter$3,menhir_env$1,menhir_stack$1,_gV_)}
                    return caml_trampoline_return
                            (menhir_run8,[0,menhir_env$1,menhir_stack$1,_gV_]);
                   case 12:
                    var
                     menhir_env$0=menhir_env$1,
                     menhir_stack$0=menhir_stack$1,
                     menhir_s$0=33;
                    continue;
                   case 14:
                    var _gW_=33;
                    if(counter < 50)
                     {var counter$2=counter + 1 | 0;
                      return menhir_run10
                              (counter$2,menhir_env$1,menhir_stack$1,_gW_)}
                    return caml_trampoline_return
                            (menhir_run10,[0,menhir_env$1,menhir_stack$1,_gW_]);
                   case 20:
                    var _gX_=33;
                    if(counter < 50)
                     {var counter$0=counter + 1 | 0;
                      return menhir_run12
                              (counter$0,menhir_env$1,menhir_stack$1,_gX_)}
                    return caml_trampoline_return
                            (menhir_run12,[0,menhir_env$1,menhir_stack$1,_gX_])
                   }
                else
                 switch(tok[0])
                  {case 1:
                    var v=tok[1],_gY_=menhir_env$1[2][11],_gZ_=33;
                    if(counter < 50)
                     {var counter$4=counter + 1 | 0;
                      return menhir_run7
                              (counter$4,menhir_env$1,menhir_stack$1,_gZ_,v,_gY_)}
                    return caml_trampoline_return
                            (menhir_run7,[0,menhir_env$1,menhir_stack$1,_gZ_,v,_gY_]);
                   case 2:
                    var v$0=tok[1],_g0_=menhir_env$1[2][11],_g1_=33;
                    if(counter < 50)
                     {var counter$1=counter + 1 | 0;
                      return menhir_run11
                              (counter$1,menhir_env$1,menhir_stack$1,_g1_,v$0,_g0_)}
                    return caml_trampoline_return
                            (menhir_run11,[0,menhir_env$1,menhir_stack$1,_g1_,v$0,_g0_])
                   }
                if(menhir_env$1[4])throw [0,Assert_failure,_cv_];
                menhir_env$1[4] = 1;
                return menhir_errorcase(menhir_env$1,menhir_stack$1,33)}},
           menhir_run10=
            function(counter,menhir_env,menhir_stack,menhir_s)
             {var
               menhir_env$0=menhir_env,
               menhir_stack$0=menhir_stack,
               menhir_s$0=menhir_s;
              for(;;)
               {var
                 menhir_stack$1=[0,menhir_stack$0,menhir_s$0],
                 menhir_env$1=menhir_discard(menhir_env$0),
                 tok=menhir_env$1[3];
                if(typeof tok === "number")
                 switch(tok)
                  {case 6:
                    var _gM_=32;
                    if(counter < 50)
                     {var counter$5=counter + 1 | 0;
                      return menhir_run6
                              (counter$5,menhir_env$1,menhir_stack$1,_gM_)}
                    return caml_trampoline_return
                            (menhir_run6,[0,menhir_env$1,menhir_stack$1,_gM_]);
                   case 9:
                    var _gN_=32;
                    if(counter < 50)
                     {var counter$3=counter + 1 | 0;
                      return menhir_run8
                              (counter$3,menhir_env$1,menhir_stack$1,_gN_)}
                    return caml_trampoline_return
                            (menhir_run8,[0,menhir_env$1,menhir_stack$1,_gN_]);
                   case 12:
                    var _gO_=32;
                    if(counter < 50)
                     {var counter$2=counter + 1 | 0;
                      return menhir_run9
                              (counter$2,menhir_env$1,menhir_stack$1,_gO_)}
                    return caml_trampoline_return
                            (menhir_run9,[0,menhir_env$1,menhir_stack$1,_gO_]);
                   case 14:
                    var
                     menhir_env$0=menhir_env$1,
                     menhir_stack$0=menhir_stack$1,
                     menhir_s$0=32;
                    continue;
                   case 20:
                    var _gP_=32;
                    if(counter < 50)
                     {var counter$0=counter + 1 | 0;
                      return menhir_run12
                              (counter$0,menhir_env$1,menhir_stack$1,_gP_)}
                    return caml_trampoline_return
                            (menhir_run12,[0,menhir_env$1,menhir_stack$1,_gP_])
                   }
                else
                 switch(tok[0])
                  {case 1:
                    var v=tok[1],_gQ_=menhir_env$1[2][11],_gR_=32;
                    if(counter < 50)
                     {var counter$4=counter + 1 | 0;
                      return menhir_run7
                              (counter$4,menhir_env$1,menhir_stack$1,_gR_,v,_gQ_)}
                    return caml_trampoline_return
                            (menhir_run7,[0,menhir_env$1,menhir_stack$1,_gR_,v,_gQ_]);
                   case 2:
                    var v$0=tok[1],_gS_=menhir_env$1[2][11],_gT_=32;
                    if(counter < 50)
                     {var counter$1=counter + 1 | 0;
                      return menhir_run11
                              (counter$1,menhir_env$1,menhir_stack$1,_gT_,v$0,_gS_)}
                    return caml_trampoline_return
                            (menhir_run11,[0,menhir_env$1,menhir_stack$1,_gT_,v$0,_gS_])
                   }
                if(menhir_env$1[4])throw [0,Assert_failure,_cw_];
                menhir_env$1[4] = 1;
                return menhir_errorcase(menhir_env$1,menhir_stack$1,32)}},
           menhir_run11=
            function(counter,menhir_env,menhir_stack,menhir_s,v,startpos)
             {var menhir_env$0=menhir_discard(menhir_env),v$0=[3,v];
              if(counter < 50)
               {var counter$0=counter + 1 | 0;
                return menhir_goto_meta_expr
                        (counter$0,menhir_env$0,menhir_stack,menhir_s,v$0)}
              return caml_trampoline_return
                      (menhir_goto_meta_expr,
                       [0,menhir_env$0,menhir_stack,menhir_s,v$0])},
           menhir_run12=
            function(counter,menhir_env,menhir_stack,menhir_s)
             {var
               menhir_env$0=menhir_env,
               menhir_stack$0=menhir_stack,
               menhir_s$0=menhir_s;
              for(;;)
               {var
                 menhir_stack$1=[0,menhir_stack$0,menhir_s$0],
                 menhir_env$1=menhir_discard(menhir_env$0),
                 tok=menhir_env$1[3];
                if(typeof tok === "number")
                 switch(tok)
                  {case 6:
                    var _gE_=31;
                    if(counter < 50)
                     {var counter$5=counter + 1 | 0;
                      return menhir_run6
                              (counter$5,menhir_env$1,menhir_stack$1,_gE_)}
                    return caml_trampoline_return
                            (menhir_run6,[0,menhir_env$1,menhir_stack$1,_gE_]);
                   case 9:
                    var _gF_=31;
                    if(counter < 50)
                     {var counter$3=counter + 1 | 0;
                      return menhir_run8
                              (counter$3,menhir_env$1,menhir_stack$1,_gF_)}
                    return caml_trampoline_return
                            (menhir_run8,[0,menhir_env$1,menhir_stack$1,_gF_]);
                   case 12:
                    var _gG_=31;
                    if(counter < 50)
                     {var counter$2=counter + 1 | 0;
                      return menhir_run9
                              (counter$2,menhir_env$1,menhir_stack$1,_gG_)}
                    return caml_trampoline_return
                            (menhir_run9,[0,menhir_env$1,menhir_stack$1,_gG_]);
                   case 14:
                    var _gH_=31;
                    if(counter < 50)
                     {var counter$1=counter + 1 | 0;
                      return menhir_run10
                              (counter$1,menhir_env$1,menhir_stack$1,_gH_)}
                    return caml_trampoline_return
                            (menhir_run10,[0,menhir_env$1,menhir_stack$1,_gH_]);
                   case 20:
                    var
                     menhir_env$0=menhir_env$1,
                     menhir_stack$0=menhir_stack$1,
                     menhir_s$0=31;
                    continue
                   }
                else
                 switch(tok[0])
                  {case 1:
                    var v=tok[1],_gI_=menhir_env$1[2][11],_gJ_=31;
                    if(counter < 50)
                     {var counter$4=counter + 1 | 0;
                      return menhir_run7
                              (counter$4,menhir_env$1,menhir_stack$1,_gJ_,v,_gI_)}
                    return caml_trampoline_return
                            (menhir_run7,[0,menhir_env$1,menhir_stack$1,_gJ_,v,_gI_]);
                   case 2:
                    var v$0=tok[1],_gK_=menhir_env$1[2][11],_gL_=31;
                    if(counter < 50)
                     {var counter$0=counter + 1 | 0;
                      return menhir_run11
                              (counter$0,menhir_env$1,menhir_stack$1,_gL_,v$0,_gK_)}
                    return caml_trampoline_return
                            (menhir_run11,[0,menhir_env$1,menhir_stack$1,_gL_,v$0,_gK_])
                   }
                if(menhir_env$1[4])throw [0,Assert_failure,_cx_];
                menhir_env$1[4] = 1;
                return menhir_errorcase(menhir_env$1,menhir_stack$1,31)}},
           menhir_goto_definition=
            function(counter,menhir_env,menhir_stack,v)
             {var menhir_stack$0=[0,menhir_stack,v];
              if(menhir_env[4])throw [0,Assert_failure,_cy_];
              var tok=menhir_env[3];
              if(typeof tok === "number" && 23 === tok)
               {var
                 menhir_env$0=menhir_discard(menhir_env),
                 tok$0=menhir_env$0[3],
                 switch$0=0;
                if(typeof tok$0 === "number")
                 switch(tok$0)
                  {case 23:
                    var _gD_=0;
                    if(counter < 50)
                     {var counter$0=counter + 1 | 0;
                      return menhir_run1$0
                              (counter$0,menhir_env$0,menhir_stack$0,_gD_)}
                    return caml_trampoline_return
                            (menhir_run1$0,[0,menhir_env$0,menhir_stack$0,_gD_]);
                   case 18:switch$0 = 1;break
                   }
                else
                 if(2 === tok$0[0])switch$0 = 1;
                if(switch$0)
                 {var _gC_=0;
                  if(counter < 50)
                   {var counter$1=counter + 1 | 0;
                    return menhir_reduce26$0
                            (counter$1,menhir_env$0,menhir_stack$0,_gC_)}
                  return caml_trampoline_return
                          (menhir_reduce26$0,[0,menhir_env$0,menhir_stack$0,_gC_])}
                if(menhir_env$0[4])throw [0,Assert_failure,_cz_];
                menhir_env$0[4] = 1;
                return menhir_errorcase(menhir_env$0,menhir_stack$0,0)}
              if(menhir_env[4])throw [0,Assert_failure,_cA_];
              menhir_env[4] = 1;
              var
               match=menhir_stack$0[1],
               menhir_s=match[2],
               menhir_stack$1=match[1];
              return menhir_errorcase(menhir_env,menhir_stack$1,menhir_s)},
           menhir_goto_loption_separated_=
            function(counter,menhir_env,match,menhir_s,args)
             {if(menhir_env[4])throw [0,Assert_failure,_cB_];
              var tok=menhir_env[3];
              if(typeof tok === "number")
               if(23 <= tok)
                {if(! (25 <= tok))
                  {var
                    startpos_id=match[4],
                    id=match[3],
                    menhir_s$0=match[2],
                    menhir_stack=match[1],
                    v=[0,startpos_id,id,args,0];
                   if(counter < 50)
                    {var counter$0=counter + 1 | 0;
                     return menhir_goto_command
                             (counter$0,menhir_env,menhir_stack,menhir_s$0,v)}
                   return caml_trampoline_return
                           (menhir_goto_command,
                            [0,menhir_env,menhir_stack,menhir_s$0,v])}}
               else
                if(17 === tok)
                 {var
                   menhir_env$0=menhir_discard(menhir_env),
                   tok$0=menhir_env$0[3];
                  if(typeof tok$0 === "number")
                   switch(tok$0)
                    {case 23:
                     case 24:
                      var
                       startpos_id$0=match[4],
                       id$0=match[3],
                       menhir_s$1=match[2],
                       menhir_stack$0=match[1],
                       v$0=[0,startpos_id$0,id$0,args,1];
                      if(counter < 50)
                       {var counter$2=counter + 1 | 0;
                        return menhir_goto_command
                                (counter$2,menhir_env$0,menhir_stack$0,menhir_s$1,v$0)}
                      return caml_trampoline_return
                              (menhir_goto_command,
                               [0,menhir_env$0,menhir_stack$0,menhir_s$1,v$0])
                     }
                  else
                   if(1 === tok$0[0])
                    {var
                      v$1=tok$0[1],
                      menhir_env$1=menhir_discard(menhir_env$0),
                      startpos_id$1=match[4],
                      id$1=match[3],
                      menhir_s$2=match[2],
                      menhir_stack$1=match[1],
                      v$2=[0,startpos_id$1,id$1,args,[0,uint32_to_int(v$1)]];
                     if(counter < 50)
                      {var counter$1=counter + 1 | 0;
                       return menhir_goto_command
                               (counter$1,menhir_env$1,menhir_stack$1,menhir_s$2,v$2)}
                     return caml_trampoline_return
                             (menhir_goto_command,
                              [0,menhir_env$1,menhir_stack$1,menhir_s$2,v$2])}
                  if(menhir_env$0[4])throw [0,Assert_failure,_cD_];
                  menhir_env$0[4] = 1;
                  return menhir_errorcase(menhir_env$0,match,menhir_s)}
              if(menhir_env[4])throw [0,Assert_failure,_cC_];
              menhir_env[4] = 1;
              return menhir_errorcase(menhir_env,match,menhir_s)},
           menhir_run4=
            function(counter,menhir_env,menhir_stack,menhir_s,i,startpos_i)
             {var menhir_env$0=menhir_discard(menhir_env),v=[0,i];
              if(counter < 50)
               {var counter$0=counter + 1 | 0;
                return menhir_goto_number
                        (counter$0,menhir_env$0,menhir_stack,menhir_s,v,startpos_i)}
              return caml_trampoline_return
                      (menhir_goto_number,
                       [0,menhir_env$0,menhir_stack,menhir_s,v,startpos_i])},
           menhir_run54=
            function(counter,menhir_env,menhir_stack,menhir_s)
             {var
               menhir_stack$0=[0,menhir_stack,menhir_s],
               menhir_env$0=menhir_discard(menhir_env),
               tok=menhir_env$0[3];
              if(typeof tok !== "number" && 2 === tok[0])
               {var
                 v=tok[1],
                 startpos=menhir_env$0[2][11],
                 menhir_stack$2=[0,menhir_stack$0,v,startpos],
                 menhir_env$1=menhir_discard(menhir_env$0),
                 tok$0=menhir_env$1[3];
                if(typeof tok$0 === "number")
                 {if(4 === tok$0)
                   {var
                     menhir_env$2=menhir_discard(menhir_env$1),
                     tok$1=menhir_env$2[3];
                    if(typeof tok$1 === "number" && 17 <= tok$1)
                     {var switcher=tok$1 - 17 | 0;
                      switch(switcher)
                       {case 3:
                         var
                          menhir_env$3=menhir_discard(menhir_env$2),
                          id$0=menhir_stack$2[2],
                          match$1=menhir_stack$2[1],
                          menhir_s$3=match$1[2],
                          menhir_stack$5=match$1[1],
                          v$1=[2,id$0,[0,sign_plus,[0,Stdlib_int32[1]]],1];
                         if(counter < 50)
                          {var counter$4=counter + 1 | 0;
                           return menhir_goto_arg
                                   (counter$4,menhir_env$3,menhir_stack$5,menhir_s$3,v$1)}
                         return caml_trampoline_return
                                 (menhir_goto_arg,
                                  [0,menhir_env$3,menhir_stack$5,menhir_s$3,v$1]);
                        case 9:
                         var
                          menhir_env$4=menhir_discard(menhir_env$2),
                          tok$2=menhir_env$4[3];
                         if(typeof tok$2 === "number")
                          switch(tok$2)
                           {case 6:
                             var _gk_=13;
                             if(counter < 50)
                              {var counter$13=counter + 1 | 0;
                               return menhir_run59
                                       (counter$13,menhir_env$4,menhir_stack$2,_gk_)}
                             return caml_trampoline_return
                                     (menhir_run59,[0,menhir_env$4,menhir_stack$2,_gk_]);
                            case 12:
                             var _gl_=13;
                             if(counter < 50)
                              {var counter$11=counter + 1 | 0;
                               return menhir_run62
                                       (counter$11,menhir_env$4,menhir_stack$2,_gl_)}
                             return caml_trampoline_return
                                     (menhir_run62,[0,menhir_env$4,menhir_stack$2,_gl_]);
                            case 16:
                             var _gm_=menhir_env$4[2][11],_gn_=13;
                             if(counter < 50)
                              {var counter$1=counter + 1 | 0;
                               return menhir_run5
                                       (counter$1,menhir_env$4,menhir_stack$2,_gn_,_gm_)}
                             return caml_trampoline_return
                                     (menhir_run5,[0,menhir_env$4,menhir_stack$2,_gn_,_gm_]);
                            case 19:
                             var _go_=13;
                             if(counter < 50)
                              {var counter$7=counter + 1 | 0;
                               return menhir_run66
                                       (counter$7,menhir_env$4,menhir_stack$2,_go_)}
                             return caml_trampoline_return
                                     (menhir_run66,[0,menhir_env$4,menhir_stack$2,_go_])
                            }
                         else
                          switch(tok$2[0])
                           {case 1:
                             var v$2=tok$2[1],_gp_=menhir_env$4[2][11],_gq_=13;
                             if(counter < 50)
                              {var counter$3=counter + 1 | 0;
                               return menhir_run4
                                       (counter$3,menhir_env$4,menhir_stack$2,_gq_,v$2,_gp_)}
                             return caml_trampoline_return
                                     (menhir_run4,[0,menhir_env$4,menhir_stack$2,_gq_,v$2,_gp_]);
                            case 2:
                             var v$3=tok$2[1],_gr_=menhir_env$4[2][11],_gs_=13;
                             if(counter < 50)
                              {var counter$9=counter + 1 | 0;
                               return menhir_run65
                                       (counter$9,menhir_env$4,menhir_stack$2,_gs_,v$3,_gr_)}
                             return caml_trampoline_return
                                     (menhir_run65,[0,menhir_env$4,menhir_stack$2,_gs_,v$3,_gr_])
                            }
                         if(menhir_env$4[4])throw [0,Assert_failure,_cG_];
                         menhir_env$4[4] = 1;
                         return menhir_errorcase(menhir_env$4,menhir_stack$2,13);
                        case 0:
                        case 6:
                        case 7:
                         var
                          id=menhir_stack$2[2],
                          match=menhir_stack$2[1],
                          menhir_s$1=match[2],
                          menhir_stack$3=match[1],
                          v$0=[2,id,[0,sign_plus,[0,Stdlib_int32[1]]],0];
                         if(counter < 50)
                          {var counter$5=counter + 1 | 0;
                           return menhir_goto_arg
                                   (counter$5,menhir_env$2,menhir_stack$3,menhir_s$1,v$0)}
                         return caml_trampoline_return
                                 (menhir_goto_arg,
                                  [0,menhir_env$2,menhir_stack$3,menhir_s$1,v$0])
                        }}
                    if(menhir_env$2[4])throw [0,Assert_failure,_cF_];
                    menhir_env$2[4] = 1;
                    var
                     match$0=menhir_stack$2[1],
                     menhir_s$2=match$0[2],
                     menhir_stack$4=match$0[1];
                    return menhir_errorcase
                            (menhir_env$2,menhir_stack$4,menhir_s$2)}
                  if(26 === tok$0)
                   {var
                     menhir_env$5=menhir_discard(menhir_env$1),
                     tok$3=menhir_env$5[3];
                    if(typeof tok$3 === "number")
                     switch(tok$3)
                      {case 6:
                        var _gt_=7;
                        if(counter < 50)
                         {var counter$12=counter + 1 | 0;
                          return menhir_run59
                                  (counter$12,menhir_env$5,menhir_stack$2,_gt_)}
                        return caml_trampoline_return
                                (menhir_run59,[0,menhir_env$5,menhir_stack$2,_gt_]);
                       case 12:
                        var _gu_=7;
                        if(counter < 50)
                         {var counter$10=counter + 1 | 0;
                          return menhir_run62
                                  (counter$10,menhir_env$5,menhir_stack$2,_gu_)}
                        return caml_trampoline_return
                                (menhir_run62,[0,menhir_env$5,menhir_stack$2,_gu_]);
                       case 16:
                        var _gv_=menhir_env$5[2][11],_gw_=7;
                        if(counter < 50)
                         {var counter$0=counter + 1 | 0;
                          return menhir_run5
                                  (counter$0,menhir_env$5,menhir_stack$2,_gw_,_gv_)}
                        return caml_trampoline_return
                                (menhir_run5,[0,menhir_env$5,menhir_stack$2,_gw_,_gv_]);
                       case 19:
                        var _gx_=7;
                        if(counter < 50)
                         {var counter$6=counter + 1 | 0;
                          return menhir_run66
                                  (counter$6,menhir_env$5,menhir_stack$2,_gx_)}
                        return caml_trampoline_return
                                (menhir_run66,[0,menhir_env$5,menhir_stack$2,_gx_])
                       }
                    else
                     switch(tok$3[0])
                      {case 1:
                        var v$4=tok$3[1],_gy_=menhir_env$5[2][11],_gz_=7;
                        if(counter < 50)
                         {var counter$2=counter + 1 | 0;
                          return menhir_run4
                                  (counter$2,menhir_env$5,menhir_stack$2,_gz_,v$4,_gy_)}
                        return caml_trampoline_return
                                (menhir_run4,[0,menhir_env$5,menhir_stack$2,_gz_,v$4,_gy_]);
                       case 2:
                        var v$5=tok$3[1],_gA_=menhir_env$5[2][11],_gB_=7;
                        if(counter < 50)
                         {var counter$8=counter + 1 | 0;
                          return menhir_run65
                                  (counter$8,menhir_env$5,menhir_stack$2,_gB_,v$5,_gA_)}
                        return caml_trampoline_return
                                (menhir_run65,[0,menhir_env$5,menhir_stack$2,_gB_,v$5,_gA_])
                       }
                    if(menhir_env$5[4])throw [0,Assert_failure,_cH_];
                    menhir_env$5[4] = 1;
                    return menhir_errorcase(menhir_env$5,menhir_stack$2,7)}}
                if(menhir_env$1[4])throw [0,Assert_failure,_cI_];
                menhir_env$1[4] = 1;
                var
                 match$2=menhir_stack$2[1],
                 menhir_s$4=match$2[2],
                 menhir_stack$6=match$2[1];
                return menhir_errorcase
                        (menhir_env$1,menhir_stack$6,menhir_s$4)}
              if(menhir_env$0[4])throw [0,Assert_failure,_cE_];
              menhir_env$0[4] = 1;
              var
               menhir_s$0=menhir_stack$0[2],
               menhir_stack$1=menhir_stack$0[1];
              return menhir_errorcase(menhir_env$0,menhir_stack$1,menhir_s$0)},
           menhir_run5=
            function(counter,menhir_env,menhir_stack,menhir_s,startpos)
             {var
               menhir_stack$0=[0,menhir_stack,menhir_s,startpos],
               menhir_env$0=menhir_discard(menhir_env),
               tok=menhir_env$0[3];
              if(typeof tok === "number")
               switch(tok)
                {case 6:
                  var _gb_=36;
                  if(counter < 50)
                   {var counter$6=counter + 1 | 0;
                    return menhir_run6
                            (counter$6,menhir_env$0,menhir_stack$0,_gb_)}
                  return caml_trampoline_return
                          (menhir_run6,[0,menhir_env$0,menhir_stack$0,_gb_]);
                 case 9:
                  var _gc_=36;
                  if(counter < 50)
                   {var counter$4=counter + 1 | 0;
                    return menhir_run8
                            (counter$4,menhir_env$0,menhir_stack$0,_gc_)}
                  return caml_trampoline_return
                          (menhir_run8,[0,menhir_env$0,menhir_stack$0,_gc_]);
                 case 12:
                  var _gd_=36;
                  if(counter < 50)
                   {var counter$3=counter + 1 | 0;
                    return menhir_run9
                            (counter$3,menhir_env$0,menhir_stack$0,_gd_)}
                  return caml_trampoline_return
                          (menhir_run9,[0,menhir_env$0,menhir_stack$0,_gd_]);
                 case 14:
                  var _ge_=36;
                  if(counter < 50)
                   {var counter$2=counter + 1 | 0;
                    return menhir_run10
                            (counter$2,menhir_env$0,menhir_stack$0,_ge_)}
                  return caml_trampoline_return
                          (menhir_run10,[0,menhir_env$0,menhir_stack$0,_ge_]);
                 case 20:
                  var _gf_=36;
                  if(counter < 50)
                   {var counter$0=counter + 1 | 0;
                    return menhir_run12
                            (counter$0,menhir_env$0,menhir_stack$0,_gf_)}
                  return caml_trampoline_return
                          (menhir_run12,[0,menhir_env$0,menhir_stack$0,_gf_])
                 }
              else
               switch(tok[0])
                {case 1:
                  var v=tok[1],_gg_=menhir_env$0[2][11],_gh_=36;
                  if(counter < 50)
                   {var counter$5=counter + 1 | 0;
                    return menhir_run7
                            (counter$5,menhir_env$0,menhir_stack$0,_gh_,v,_gg_)}
                  return caml_trampoline_return
                          (menhir_run7,[0,menhir_env$0,menhir_stack$0,_gh_,v,_gg_]);
                 case 2:
                  var v$0=tok[1],_gi_=menhir_env$0[2][11],_gj_=36;
                  if(counter < 50)
                   {var counter$1=counter + 1 | 0;
                    return menhir_run11
                            (counter$1,menhir_env$0,menhir_stack$0,_gj_,v$0,_gi_)}
                  return caml_trampoline_return
                          (menhir_run11,[0,menhir_env$0,menhir_stack$0,_gj_,v$0,_gi_])
                 }
              if(menhir_env$0[4])throw [0,Assert_failure,_cJ_];
              menhir_env$0[4] = 1;
              return menhir_errorcase(menhir_env$0,menhir_stack$0,36)},
           menhir_run78=
            function(counter,menhir_env,menhir_stack,menhir_s,id,startpos)
             {var menhir_env$0=menhir_discard(menhir_env),v=[0,id];
              if(counter < 50)
               {var counter$0=counter + 1 | 0;
                return menhir_goto_arg
                        (counter$0,menhir_env$0,menhir_stack,menhir_s,v)}
              return caml_trampoline_return
                      (menhir_goto_arg,[0,menhir_env$0,menhir_stack,menhir_s,v])},
           menhir_run79=
            function(counter,menhir_env,menhir_stack,menhir_s)
             {var
               menhir_stack$0=[0,menhir_stack,menhir_s],
               menhir_env$0=menhir_discard(menhir_env),
               tok=menhir_env$0[3];
              if(typeof tok === "number")
               {if(16 === tok)
                 {var _f9_=menhir_env$0[2][11],_f__=6;
                  if(counter < 50)
                   {var counter$0=counter + 1 | 0;
                    return menhir_run5
                            (counter$0,menhir_env$0,menhir_stack$0,_f__,_f9_)}
                  return caml_trampoline_return
                          (menhir_run5,[0,menhir_env$0,menhir_stack$0,_f__,_f9_])}}
              else
               if(1 === tok[0])
                {var v=tok[1],_f$_=menhir_env$0[2][11],_ga_=6;
                 if(counter < 50)
                  {var counter$1=counter + 1 | 0;
                   return menhir_run4
                           (counter$1,menhir_env$0,menhir_stack$0,_ga_,v,_f$_)}
                 return caml_trampoline_return
                         (menhir_run4,[0,menhir_env$0,menhir_stack$0,_ga_,v,_f$_])}
              if(menhir_env$0[4])throw [0,Assert_failure,_cK_];
              menhir_env$0[4] = 1;
              return menhir_errorcase(menhir_env$0,menhir_stack$0,6)},
           menhir_reduce26$0=
            function(counter,menhir_env$11,menhir_stack$9,menhir_s$7)
             {var menhir_stack=menhir_stack$9,menhir_s=menhir_s$7,v=0;
              for(;;)
               {var menhir_stack$0=[0,menhir_stack,menhir_s,v];
                if(38 <= menhir_s)
                 {if(! (39 <= menhir_s))
                   {var
                     xs=menhir_stack$0[3],
                     match=menhir_stack$0[1],
                     menhir_s$2=match[2],
                     menhir_stack$3=match[1],
                     v$5=[0,0,xs],
                     menhir_stack=menhir_stack$3,
                     menhir_s=menhir_s$2,
                     v=v$5;
                    continue}}
                else
                 {var switch$0=0;
                  if(! (5 <= menhir_s))
                   switch(menhir_s)
                    {case 4:switch$0 = 1;break;
                     case 1:
                     case 2:break;
                     default:
                      if(menhir_env$11[4])throw [0,Assert_failure,_cO_];
                      var tok$1=menhir_env$11[3];
                      if(typeof tok$1 === "number")
                       {if(18 === tok$1)
                         {var
                           menhir_env$0=menhir_discard(menhir_env$11),
                           tok$2=menhir_env$0[3];
                          if(typeof tok$2 === "number")
                           switch(tok$2)
                            {case 23:
                              var
                               menhir_s$5=menhir_stack$0[2],
                               menhir_stack$6=menhir_stack$0[1];
                              return menhir_goto_headers
                                      (menhir_env$0,menhir_stack$6,menhir_s$5,0);
                             case 24:
                              var
                               menhir_s$6=menhir_stack$0[2],
                               menhir_stack$7=menhir_stack$0[1];
                              return menhir_goto_headers
                                      (menhir_env$0,menhir_stack$7,menhir_s$6,0)
                             }
                          else
                           if(2 === tok$2[0])
                            {var
                              id=tok$2[1],
                              menhir_env$1=menhir_discard(menhir_env$0),
                              tok$3=menhir_env$1[3];
                             if(typeof tok$3 === "number" && 21 === tok$3)
                              {var
                                menhir_env$2=menhir_discard(menhir_env$1),
                                tok$4=menhir_env$2[3];
                               if(typeof tok$4 === "number")
                                {if(8 === tok$4)
                                  {var menhir_env$3=menhir_discard(menhir_env$2),v$6=[0,id,0];
                                   if(counter < 50)
                                    {var counter$8=counter + 1 | 0;
                                     return menhir_goto_definition
                                             (counter$8,menhir_env$3,menhir_stack$0,v$6)}
                                   return caml_trampoline_return
                                           (menhir_goto_definition,[0,menhir_env$3,menhir_stack$0,v$6])}}
                               else
                                switch(tok$4[0])
                                 {case 0:
                                   var
                                    v$7=tok$4[1],
                                    menhir_env$4=menhir_discard(menhir_env$2),
                                    v$8=[0,id,[0,v$7]];
                                   if(counter < 50)
                                    {var counter$9=counter + 1 | 0;
                                     return menhir_goto_definition
                                             (counter$9,menhir_env$4,menhir_stack$0,v$8)}
                                   return caml_trampoline_return
                                           (menhir_goto_definition,[0,menhir_env$4,menhir_stack$0,v$8]);
                                  case 1:
                                   var
                                    v$9=tok$4[1],
                                    menhir_env$5=menhir_discard(menhir_env$2),
                                    v$10=[0,id,[1,v$9]];
                                   if(counter < 50)
                                    {var counter$10=counter + 1 | 0;
                                     return menhir_goto_definition
                                             (counter$10,menhir_env$5,menhir_stack$0,v$10)}
                                   return caml_trampoline_return
                                           (menhir_goto_definition,
                                            [0,menhir_env$5,menhir_stack$0,v$10]);
                                  case 3:
                                   var
                                    v$11=tok$4[1],
                                    menhir_env$6=menhir_discard(menhir_env$2),
                                    v$12=[0,id,[2,v$11]];
                                   if(counter < 50)
                                    {var counter$11=counter + 1 | 0;
                                     return menhir_goto_definition
                                             (counter$11,menhir_env$6,menhir_stack$0,v$12)}
                                   return caml_trampoline_return
                                           (menhir_goto_definition,
                                            [0,menhir_env$6,menhir_stack$0,v$12])
                                  }
                               if(menhir_env$2[4])throw [0,Assert_failure,_cR_];
                               menhir_env$2[4] = 1;
                               throw eRR}
                             if(menhir_env$1[4])throw [0,Assert_failure,_cS_];
                             menhir_env$1[4] = 1;
                             throw eRR}
                          if(menhir_env$0[4])throw [0,Assert_failure,_cQ_];
                          menhir_env$0[4] = 1;
                          var
                           menhir_s$4=menhir_stack$0[2],
                           menhir_stack$5=menhir_stack$0[1];
                          return menhir_errorcase
                                  (menhir_env$0,menhir_stack$5,menhir_s$4)}}
                      else
                       if(2 === tok$1[0])
                        {var
                          v$13=tok$1[1],
                          startpos$0=menhir_env$11[2][11],
                          menhir_stack$8=[0,menhir_stack$0,v$13,startpos$0],
                          menhir_env$7=menhir_discard(menhir_env$11),
                          tok$5=menhir_env$7[3];
                         if(typeof tok$5 === "number")
                          {if(17 === tok$5)
                            {var
                              menhir_env$8=menhir_discard(menhir_env$7),
                              tok$6=menhir_env$8[3];
                             if(typeof tok$6 === "number" && 21 === tok$6)
                              {var
                                menhir_env$9=menhir_discard(menhir_env$8),
                                tok$7=menhir_env$9[3];
                               if(typeof tok$7 === "number")
                                switch(tok$7)
                                 {case 6:
                                   var _fR_=2;
                                   if(counter < 50)
                                    {var counter$25=counter + 1 | 0;
                                     return menhir_run6
                                             (counter$25,menhir_env$9,menhir_stack$8,_fR_)}
                                   return caml_trampoline_return
                                           (menhir_run6,[0,menhir_env$9,menhir_stack$8,_fR_]);
                                  case 9:
                                   var _fS_=2;
                                   if(counter < 50)
                                    {var counter$21=counter + 1 | 0;
                                     return menhir_run8
                                             (counter$21,menhir_env$9,menhir_stack$8,_fS_)}
                                   return caml_trampoline_return
                                           (menhir_run8,[0,menhir_env$9,menhir_stack$8,_fS_]);
                                  case 12:
                                   var _fT_=2;
                                   if(counter < 50)
                                    {var counter$19=counter + 1 | 0;
                                     return menhir_run9
                                             (counter$19,menhir_env$9,menhir_stack$8,_fT_)}
                                   return caml_trampoline_return
                                           (menhir_run9,[0,menhir_env$9,menhir_stack$8,_fT_]);
                                  case 14:
                                   var _fU_=2;
                                   if(counter < 50)
                                    {var counter$17=counter + 1 | 0;
                                     return menhir_run10
                                             (counter$17,menhir_env$9,menhir_stack$8,_fU_)}
                                   return caml_trampoline_return
                                           (menhir_run10,[0,menhir_env$9,menhir_stack$8,_fU_]);
                                  case 20:
                                   var _fV_=2;
                                   if(counter < 50)
                                    {var counter$13=counter + 1 | 0;
                                     return menhir_run12
                                             (counter$13,menhir_env$9,menhir_stack$8,_fV_)}
                                   return caml_trampoline_return
                                           (menhir_run12,[0,menhir_env$9,menhir_stack$8,_fV_])
                                  }
                               else
                                switch(tok$7[0])
                                 {case 1:
                                   var v$14=tok$7[1],_fW_=menhir_env$9[2][11],_fX_=2;
                                   if(counter < 50)
                                    {var counter$23=counter + 1 | 0;
                                     return menhir_run7
                                             (counter$23,menhir_env$9,menhir_stack$8,_fX_,v$14,_fW_)}
                                   return caml_trampoline_return
                                           (menhir_run7,[0,menhir_env$9,menhir_stack$8,_fX_,v$14,_fW_]);
                                  case 2:
                                   var v$15=tok$7[1],_fY_=menhir_env$9[2][11],_fZ_=2;
                                   if(counter < 50)
                                    {var counter$15=counter + 1 | 0;
                                     return menhir_run11
                                             (counter$15,menhir_env$9,menhir_stack$8,_fZ_,v$15,_fY_)}
                                   return caml_trampoline_return
                                           (menhir_run11,
                                            [0,menhir_env$9,menhir_stack$8,_fZ_,v$15,_fY_])
                                  }
                               if(menhir_env$9[4])throw [0,Assert_failure,_cT_];
                               menhir_env$9[4] = 1;
                               return menhir_errorcase(menhir_env$9,menhir_stack$8,2)}
                             if(menhir_env$8[4])throw [0,Assert_failure,_cU_];
                             menhir_env$8[4] = 1;
                             throw eRR}
                           if(21 === tok$5)
                            {var
                              menhir_env$10=menhir_discard(menhir_env$7),
                              tok$8=menhir_env$10[3];
                             if(typeof tok$8 === "number")
                              switch(tok$8)
                               {case 6:
                                 var _f0_=1;
                                 if(counter < 50)
                                  {var counter$24=counter + 1 | 0;
                                   return menhir_run6
                                           (counter$24,menhir_env$10,menhir_stack$8,_f0_)}
                                 return caml_trampoline_return
                                         (menhir_run6,[0,menhir_env$10,menhir_stack$8,_f0_]);
                                case 9:
                                 var _f1_=1;
                                 if(counter < 50)
                                  {var counter$20=counter + 1 | 0;
                                   return menhir_run8
                                           (counter$20,menhir_env$10,menhir_stack$8,_f1_)}
                                 return caml_trampoline_return
                                         (menhir_run8,[0,menhir_env$10,menhir_stack$8,_f1_]);
                                case 12:
                                 var _f2_=1;
                                 if(counter < 50)
                                  {var counter$18=counter + 1 | 0;
                                   return menhir_run9
                                           (counter$18,menhir_env$10,menhir_stack$8,_f2_)}
                                 return caml_trampoline_return
                                         (menhir_run9,[0,menhir_env$10,menhir_stack$8,_f2_]);
                                case 14:
                                 var _f3_=1;
                                 if(counter < 50)
                                  {var counter$16=counter + 1 | 0;
                                   return menhir_run10
                                           (counter$16,menhir_env$10,menhir_stack$8,_f3_)}
                                 return caml_trampoline_return
                                         (menhir_run10,[0,menhir_env$10,menhir_stack$8,_f3_]);
                                case 20:
                                 var _f4_=1;
                                 if(counter < 50)
                                  {var counter$12=counter + 1 | 0;
                                   return menhir_run12
                                           (counter$12,menhir_env$10,menhir_stack$8,_f4_)}
                                 return caml_trampoline_return
                                         (menhir_run12,[0,menhir_env$10,menhir_stack$8,_f4_])
                                }
                             else
                              switch(tok$8[0])
                               {case 1:
                                 var v$16=tok$8[1],_f5_=menhir_env$10[2][11],_f6_=1;
                                 if(counter < 50)
                                  {var counter$22=counter + 1 | 0;
                                   return menhir_run7
                                           (counter$22,menhir_env$10,menhir_stack$8,_f6_,v$16,_f5_)}
                                 return caml_trampoline_return
                                         (menhir_run7,
                                          [0,menhir_env$10,menhir_stack$8,_f6_,v$16,_f5_]);
                                case 2:
                                 var v$17=tok$8[1],_f7_=menhir_env$10[2][11],_f8_=1;
                                 if(counter < 50)
                                  {var counter$14=counter + 1 | 0;
                                   return menhir_run11
                                           (counter$14,menhir_env$10,menhir_stack$8,_f8_,v$17,_f7_)}
                                 return caml_trampoline_return
                                         (menhir_run11,
                                          [0,menhir_env$10,menhir_stack$8,_f8_,v$17,_f7_])
                                }
                             if(menhir_env$10[4])throw [0,Assert_failure,_cV_];
                             menhir_env$10[4] = 1;
                             return menhir_errorcase(menhir_env$10,menhir_stack$8,1)}}
                         if(menhir_env$7[4])throw [0,Assert_failure,_cW_];
                         menhir_env$7[4] = 1;
                         throw eRR}
                      if(menhir_env$11[4])throw [0,Assert_failure,_cP_];
                      menhir_env$11[4] = 1;
                      var
                       menhir_s$3=menhir_stack$0[2],
                       menhir_stack$4=menhir_stack$0[1];
                      return menhir_errorcase
                              (menhir_env$11,menhir_stack$4,menhir_s$3)}
                  if(! switch$0)return menhir_fail(0)}
                if(menhir_env$11[4])throw [0,Assert_failure,_cL_];
                var tok=menhir_env$11[3];
                if(typeof tok === "number")
                 switch(tok)
                  {case 16:
                    var _fF_=menhir_env$11[2][11],_fG_=37;
                    if(counter < 50)
                     {var counter$2=counter + 1 | 0;
                      return menhir_run5
                              (counter$2,menhir_env$11,menhir_stack$0,_fG_,_fF_)}
                    return caml_trampoline_return
                            (menhir_run5,[0,menhir_env$11,menhir_stack$0,_fG_,_fF_]);
                   case 24:
                    var
                     menhir_s$0=menhir_stack$0[2],
                     menhir_stack$1=menhir_stack$0[1];
                    return menhir_goto_ast
                            (menhir_env$11,menhir_stack$1,menhir_s$0,0)
                   }
                else
                 switch(tok[0])
                  {case 1:
                    var v$0=tok[1],_fH_=menhir_env$11[2][11],_fI_=37;
                    if(counter < 50)
                     {var counter$5=counter + 1 | 0;
                      return menhir_run4
                              (counter$5,menhir_env$11,menhir_stack$0,_fI_,v$0,_fH_)}
                    return caml_trampoline_return
                            (menhir_run4,[0,menhir_env$11,menhir_stack$0,_fI_,v$0,_fH_]);
                   case 2:
                    var
                     v$1=tok[1],
                     startpos=menhir_env$11[2][11],
                     menhir_stack$2=[0,menhir_stack$0,37,v$1,startpos],
                     menhir_env=menhir_discard(menhir_env$11),
                     tok$0=menhir_env[3];
                    if(typeof tok$0 === "number")
                     switch(tok$0)
                      {case 15:
                        var _fJ_=14;
                        if(counter < 50)
                         {var counter$4=counter + 1 | 0;
                          return menhir_run54
                                  (counter$4,menhir_env,menhir_stack$2,_fJ_)}
                        return caml_trampoline_return
                                (menhir_run54,[0,menhir_env,menhir_stack$2,_fJ_]);
                       case 16:
                        var _fK_=menhir_env[2][11],_fL_=14;
                        if(counter < 50)
                         {var counter$3=counter + 1 | 0;
                          return menhir_run5
                                  (counter$3,menhir_env,menhir_stack$2,_fL_,_fK_)}
                        return caml_trampoline_return
                                (menhir_run5,[0,menhir_env,menhir_stack$2,_fL_,_fK_]);
                       case 19:
                        var _fM_=14;
                        if(counter < 50)
                         {var counter$0=counter + 1 | 0;
                          return menhir_run79
                                  (counter$0,menhir_env,menhir_stack$2,_fM_)}
                        return caml_trampoline_return
                                (menhir_run79,[0,menhir_env,menhir_stack$2,_fM_]);
                       case 17:
                       case 23:
                       case 24:
                        var menhir_s$1=14,v$2=0;
                        if(counter < 50)
                         {var counter$7=counter + 1 | 0;
                          return menhir_goto_loption_separated_
                                  (counter$7,menhir_env,menhir_stack$2,menhir_s$1,v$2)}
                        return caml_trampoline_return
                                (menhir_goto_loption_separated_,
                                 [0,menhir_env,menhir_stack$2,menhir_s$1,v$2])
                       }
                    else
                     switch(tok$0[0])
                      {case 1:
                        var v$3=tok$0[1],_fN_=menhir_env[2][11],_fO_=14;
                        if(counter < 50)
                         {var counter$6=counter + 1 | 0;
                          return menhir_run4
                                  (counter$6,menhir_env,menhir_stack$2,_fO_,v$3,_fN_)}
                        return caml_trampoline_return
                                (menhir_run4,[0,menhir_env,menhir_stack$2,_fO_,v$3,_fN_]);
                       case 2:
                        var v$4=tok$0[1],_fP_=menhir_env[2][11],_fQ_=14;
                        if(counter < 50)
                         {var counter$1=counter + 1 | 0;
                          return menhir_run78
                                  (counter$1,menhir_env,menhir_stack$2,_fQ_,v$4,_fP_)}
                        return caml_trampoline_return
                                (menhir_run78,[0,menhir_env,menhir_stack$2,_fQ_,v$4,_fP_])
                       }
                    if(menhir_env[4])throw [0,Assert_failure,_cN_];
                    menhir_env[4] = 1;
                    return menhir_errorcase(menhir_env,menhir_stack$2,14)
                   }
                if(menhir_env$11[4])throw [0,Assert_failure,_cM_];
                menhir_env$11[4] = 1;
                return menhir_errorcase(menhir_env$11,menhir_stack$0,37)}},
           menhir_run1$0=
            function(counter,menhir_env,menhir_stack,menhir_s)
             {var
               menhir_env$0=menhir_env,
               menhir_stack$0=menhir_stack,
               menhir_s$0=menhir_s;
              for(;;)
               {var
                 menhir_stack$1=[0,menhir_stack$0,menhir_s$0],
                 menhir_env$1=menhir_discard(menhir_env$0),
                 tok=menhir_env$1[3],
                 switch$0=0;
                if(typeof tok === "number")
                 switch(tok)
                  {case 23:
                    var
                     menhir_env$0=menhir_env$1,
                     menhir_stack$0=menhir_stack$1,
                     menhir_s$0=38;
                    continue;
                   case 16:
                   case 18:
                   case 24:switch$0 = 1;break
                   }
                else
                 switch(tok[0]){case 0:case 3:break;default:switch$0 = 1}
                if(switch$0)
                 {var _fE_=38;
                  if(counter < 50)
                   {var counter$0=counter + 1 | 0;
                    return menhir_reduce26$0
                            (counter$0,menhir_env$1,menhir_stack$1,_fE_)}
                  return caml_trampoline_return
                          (menhir_reduce26$0,[0,menhir_env$1,menhir_stack$1,_fE_])}
                if(menhir_env$1[4])throw [0,Assert_failure,_cX_];
                menhir_env$1[4] = 1;
                return menhir_errorcase(menhir_env$1,menhir_stack$1,38)}},
           menhir_reduce26=
            function(menhir_env,menhir_stack,menhir_s)
             {return caml_trampoline
                      (menhir_reduce26$0(0,menhir_env,menhir_stack,menhir_s))},
           menhir_run1=
            function(menhir_env,menhir_stack,menhir_s)
             {return caml_trampoline
                      (menhir_run1$0(0,menhir_env,menhir_stack,menhir_s))},
           ast=
            function(lexer,lexbuf)
             {var
               menhir_env=[0,lexer,lexbuf,0,0],
               menhir_stack=[0,0,menhir_env[2][12]],
               menhir_env$0=menhir_discard(menhir_env),
               tok=menhir_env$0[3],
               switch$0=0;
              if(typeof tok === "number")
               switch(tok)
                {case 23:return menhir_run1(menhir_env$0,menhir_stack,39);
                 case 16:
                 case 24:switch$0 = 1;break
                 }
              else
               switch(tok[0]){case 0:case 3:break;default:switch$0 = 1}
              if(switch$0)
               return menhir_reduce26(menhir_env$0,menhir_stack,39);
              if(menhir_env$0[4])throw [0,Assert_failure,_cY_];
              menhir_env$0[4] = 1;
              return menhir_errorcase(menhir_env$0,menhir_stack,39)},
           headers=
            function(lexer,lexbuf)
             {var
               menhir_env=[0,lexer,lexbuf,0,0],
               menhir_stack=[0,0,menhir_env[2][12]],
               menhir_env$0=menhir_discard(menhir_env),
               tok=menhir_env$0[3],
               switch$0=0;
              if(typeof tok === "number")
               switch(tok)
                {case 23:return menhir_run1(menhir_env$0,menhir_stack,3);
                 case 18:switch$0 = 1;break
                 }
              else
               if(2 === tok[0])switch$0 = 1;
              if(switch$0)return menhir_reduce26(menhir_env$0,menhir_stack,3);
              if(menhir_env$0[4])throw [0,Assert_failure,_cZ_];
              menhir_env$0[4] = 1;
              return menhir_errorcase(menhir_env$0,menhir_stack,3)},
           Parser=[0,eRR,headers,ast];
          caml_register_global(480,Parser,"Parser");
          var
           SyntaxError=[248,cst_Lexer_SyntaxError,caml_fresh_oo_id(0)],
           next_line=
            function(lexbuf)
             {var pos=lexbuf[12];
              lexbuf[12] = [0,pos[1],pos[2] + 1 | 0,lexbuf[6],pos[4]];
              return 0},
           eof_reached=function(lexbuf){lexbuf[9] = 1;return 0},
           read_comment$0=
            function(counter,lexbuf)
             {var _fD_=82;
              if(counter < 50)
               {var counter$0=counter + 1 | 0;
                return ocaml_lex_read_comment_rec$0(counter$0,lexbuf,_fD_)}
              return caml_trampoline_return
                      (ocaml_lex_read_comment_rec$0,[0,lexbuf,_fD_])},
           ocaml_lex_read_comment_rec$0=
            function(counter,lexbuf,ocaml_lex_state)
             {var ocaml_lex_state$0=ocaml_lex_state;
              for(;;)
               {var
                 ocaml_lex_state$1=
                  caml_call3
                   (Stdlib_lexing[20],
                    ocaml_lex_tables,
                    ocaml_lex_state$0,
                    lexbuf);
                if(2 < ocaml_lex_state$1 >>> 0)
                 {caml_call1(lexbuf[1],lexbuf);
                  var ocaml_lex_state$0=ocaml_lex_state$1;
                  continue}
                switch(ocaml_lex_state$1)
                 {case 0:next_line(lexbuf);return 23;
                  case 1:eof_reached(lexbuf);return 24;
                  default:
                   if(counter < 50)
                    {var counter$0=counter + 1 | 0;
                     return read_comment$0(counter$0,lexbuf)}
                   return caml_trampoline_return(read_comment$0,[0,lexbuf])}}},
           read_comment=
            function(lexbuf){return caml_trampoline(read_comment$0(0,lexbuf))},
           ocaml_lex_read_comment_rec=
            function(lexbuf,ocaml_lex_state)
             {return caml_trampoline
                      (ocaml_lex_read_comment_rec$0(0,lexbuf,ocaml_lex_state))},
           read_string$0=
            function(counter,buf,lexbuf)
             {var _fC_=68;
              if(counter < 50)
               {var counter$0=counter + 1 | 0;
                return ocaml_lex_read_string_rec$0(counter$0,buf,lexbuf,_fC_)}
              return caml_trampoline_return
                      (ocaml_lex_read_string_rec$0,[0,buf,lexbuf,_fC_])},
           ocaml_lex_read_string_rec$0=
            function(counter,buf,lexbuf,ocaml_lex_state)
             {var ocaml_lex_state$0=ocaml_lex_state;
              for(;;)
               {var
                 ocaml_lex_state$1=
                  caml_call3
                   (Stdlib_lexing[20],
                    ocaml_lex_tables,
                    ocaml_lex_state$0,
                    lexbuf);
                if(11 < ocaml_lex_state$1 >>> 0)
                 {caml_call1(lexbuf[1],lexbuf);
                  var ocaml_lex_state$0=ocaml_lex_state$1;
                  continue}
                switch(ocaml_lex_state$1)
                 {case 0:return [0,caml_call1(Stdlib_buffer[2],buf)];
                  case 1:
                   caml_call2(Stdlib_buffer[10],buf,47);
                   if(counter < 50)
                    {var counter$0=counter + 1 | 0;
                     return read_string$0(counter$0,buf,lexbuf)}
                   return caml_trampoline_return(read_string$0,[0,buf,lexbuf]);
                  case 2:
                   caml_call2(Stdlib_buffer[10],buf,92);
                   if(counter < 50)
                    {var counter$1=counter + 1 | 0;
                     return read_string$0(counter$1,buf,lexbuf)}
                   return caml_trampoline_return(read_string$0,[0,buf,lexbuf]);
                  case 3:
                   caml_call2(Stdlib_buffer[10],buf,8);
                   if(counter < 50)
                    {var counter$2=counter + 1 | 0;
                     return read_string$0(counter$2,buf,lexbuf)}
                   return caml_trampoline_return(read_string$0,[0,buf,lexbuf]);
                  case 4:
                   caml_call2(Stdlib_buffer[10],buf,12);
                   if(counter < 50)
                    {var counter$3=counter + 1 | 0;
                     return read_string$0(counter$3,buf,lexbuf)}
                   return caml_trampoline_return(read_string$0,[0,buf,lexbuf]);
                  case 5:
                   caml_call2(Stdlib_buffer[10],buf,10);
                   if(counter < 50)
                    {var counter$4=counter + 1 | 0;
                     return read_string$0(counter$4,buf,lexbuf)}
                   return caml_trampoline_return(read_string$0,[0,buf,lexbuf]);
                  case 6:
                   caml_call2(Stdlib_buffer[10],buf,13);
                   if(counter < 50)
                    {var counter$5=counter + 1 | 0;
                     return read_string$0(counter$5,buf,lexbuf)}
                   return caml_trampoline_return(read_string$0,[0,buf,lexbuf]);
                  case 7:
                   caml_call2(Stdlib_buffer[10],buf,9);
                   if(counter < 50)
                    {var counter$6=counter + 1 | 0;
                     return read_string$0(counter$6,buf,lexbuf)}
                   return caml_trampoline_return(read_string$0,[0,buf,lexbuf]);
                  case 8:
                   var _fA_=caml_call1(Stdlib_lexing[8],lexbuf);
                   caml_call2(Stdlib_buffer[14],buf,_fA_);
                   if(counter < 50)
                    {var counter$7=counter + 1 | 0;
                     return read_string$0(counter$7,buf,lexbuf)}
                   return caml_trampoline_return(read_string$0,[0,buf,lexbuf]);
                  case 9:throw [0,SyntaxError,cst_String_cannot_be_multiline];
                  case 10:throw [0,SyntaxError,cst_String_is_not_terminated];
                  default:
                   var _fB_=caml_call1(Stdlib_lexing[8],lexbuf);
                   throw [0,
                          SyntaxError,
                          caml_call2(Stdlib[28],cst_Illegal_string_character,_fB_)]}}},
           read_string=
            function(buf,lexbuf)
             {return caml_trampoline(read_string$0(0,buf,lexbuf))},
           ocaml_lex_read_string_rec=
            function(buf,lexbuf,ocaml_lex_state)
             {return caml_trampoline
                      (ocaml_lex_read_string_rec$0(0,buf,lexbuf,ocaml_lex_state))},
           read$0=
            function(counter,lexbuf)
             {var _fz_=0;
              if(counter < 50)
               {var counter$0=counter + 1 | 0;
                return ocaml_lex_read_rec$0(counter$0,lexbuf,_fz_)}
              return caml_trampoline_return
                      (ocaml_lex_read_rec$0,[0,lexbuf,_fz_])},
           ocaml_lex_read_rec$0=
            function(counter,lexbuf,ocaml_lex_state)
             {var ocaml_lex_state$0=ocaml_lex_state;
              for(;;)
               {var
                 ocaml_lex_state$1=
                  caml_call3
                   (Stdlib_lexing[20],
                    ocaml_lex_tables,
                    ocaml_lex_state$0,
                    lexbuf);
                if(40 < ocaml_lex_state$1 >>> 0)
                 {caml_call1(lexbuf[1],lexbuf);
                  var ocaml_lex_state$0=ocaml_lex_state$1;
                  continue}
                switch(ocaml_lex_state$1)
                 {case 0:return 24;
                  case 1:return 18;
                  case 2:return 8;
                  case 3:return _c0_;
                  case 4:return _c1_;
                  case 5:return 13;
                  case 6:return 2;
                  case 7:return 22;
                  case 8:return 10;
                  case 9:return 28;
                  case 10:return 29;
                  case 11:return read_comment(lexbuf);
                  case 12:
                   if(counter < 50)
                    {var counter$0=counter + 1 | 0;
                     return read$0(counter$0,lexbuf)}
                   return caml_trampoline_return(read$0,[0,lexbuf]);
                  case 13:
                   next_line(lexbuf);
                   if(counter < 50)
                    {var counter$1=counter + 1 | 0;
                     return read$0(counter$1,lexbuf)}
                   return caml_trampoline_return(read$0,[0,lexbuf]);
                  case 14:next_line(lexbuf);return 23;
                  case 15:
                   return [1,
                           uint32_of_str(caml_call1(Stdlib_lexing[8],lexbuf))];
                  case 16:return [2,caml_call1(Stdlib_lexing[8],lexbuf)];
                  case 17:
                   return read_string(caml_call1(Stdlib_buffer[1],17),lexbuf);
                  case 18:return 21;
                  case 19:return 19;
                  case 20:return 15;
                  case 21:return 4;
                  case 22:return 16;
                  case 23:return 5;
                  case 24:return 26;
                  case 25:return 20;
                  case 26:return 17;
                  case 27:return 27;
                  case 28:return 14;
                  case 29:return 3;
                  case 30:return 6;
                  case 31:return 12;
                  case 32:return 1;
                  case 33:return 25;
                  case 34:return 11;
                  case 35:return 30;
                  case 36:return 7;
                  case 37:return 0;
                  case 38:return 9;
                  case 39:eof_reached(lexbuf);return 24;
                  default:
                   var _fy_=caml_call1(Stdlib_lexing[8],lexbuf);
                   throw [0,
                          SyntaxError,
                          caml_call2(Stdlib[28],cst_Unexpected_char,_fy_)]}}},
           read=function(lexbuf){return caml_trampoline(read$0(0,lexbuf))},
           ocaml_lex_read_rec=
            function(lexbuf,ocaml_lex_state)
             {return caml_trampoline
                      (ocaml_lex_read_rec$0(0,lexbuf,ocaml_lex_state))},
           Lexer=
            [0,
             SyntaxError,
             next_line,
             eof_reached,
             ocaml_lex_tables,
             read,
             ocaml_lex_read_rec,
             read_string,
             ocaml_lex_read_string_rec,
             read_comment,
             ocaml_lex_read_comment_rec];
          caml_register_global(483,Lexer,"Lexer");
          var
           InvalidContent=[248,cst_Parse_InvalidContent,caml_fresh_oo_id(0)],
           print_position=
            function(fmt,pos)
             {return caml_call5
                      (Stdlib_format[126],
                       fmt,
                       _c2_,
                       pos[1],
                       pos[2],
                       (pos[4] - pos[3] | 0) + 1 | 0)},
           print_lexbuf_pos=
            function(fmt,lexbuf){return print_position(fmt,lexbuf[12])},
           parse_with_error=
            function(f,lexbuf)
             {try
               {var _fx_=caml_call1(f,lexbuf);return _fx_}
              catch(exn)
               {exn = caml_wrap_exception(exn);
                if(exn[1] === SyntaxError)
                 {var msg=exn[2];
                  throw [0,
                         InvalidContent,
                         caml_call4
                          (Stdlib_format[130],_c3_,print_lexbuf_pos,lexbuf,msg)]}
                if(exn === eRR)
                 throw [0,
                        InvalidContent,
                        caml_call3(Stdlib_format[130],_c4_,print_lexbuf_pos,lexbuf)];
                throw exn}},
           from_lexbuf=
            function(headers$0,lexbuf)
             {var
               headers$1=
                headers$0
                 ?parse_with_error
                   (function(_fw_){return headers(read,_fw_)},lexbuf)
                 :0,
               ast$0=
                parse_with_error(function(_fv_){return ast(read,_fv_)},lexbuf);
              return [0,headers$1,ast$0]},
           from_filename=
            function(headers,filename)
             {var
               channel=caml_call1(Stdlib[79],filename),
               lexbuf=caml_call2(Stdlib_lexing[2],0,channel),
               _fu_=lexbuf[12];
              lexbuf[12] = [0,filename,_fu_[2],_fu_[3],_fu_[4]];
              var res=from_lexbuf(headers,lexbuf);
              caml_call1(Stdlib[93],channel);
              return res},
           from_str=
            function(headers,str)
             {return from_lexbuf(headers,caml_call2(Stdlib_lexing[3],0,str))},
           parsed_ast_to_arm=
            function(optimize,env,lst)
             {try
               {var
                 _fr_=to_arm(env,lst),
                 _fs_=optimize?tweak_arm:do_not_tweak_arm,
                 _ft_=_fs_(_fr_);
                return _ft_}
              catch(exn)
               {exn = caml_wrap_exception(exn);
                if(exn[1] === CommandError)
                 {var pos=exn[2];
                  throw [0,
                         InvalidContent,
                         caml_call3(Stdlib_format[130],_c5_,print_position,pos)]}
                throw exn}},
           parsed_content_to_arm=
            function(fmt,optimize,env,param)
             {var
               lst=param[2],
               headers=param[1],
               env$0=concat_env(env,env_from_headers(fmt,headers));
              return parsed_ast_to_arm(optimize,env$0,lst)},
           Parse=
            [0,
             InvalidContent,
             from_lexbuf,
             from_str,
             from_filename,
             parsed_ast_to_arm,
             parsed_content_to_arm];
          caml_register_global(484,Parse,"Parse");
          var
           StrMap$0=caml_call1(Stdlib_map[1],[0,Stdlib_string[5]]),
           parse=
            function(lexbuf)
             {lexbuf[9] = 0;
              var main_file=from_lexbuf(1,lexbuf),acc=StrMap$0[1];
              for(;;)
               {if(lexbuf[9])return [0,main_file,acc];
                var
                 match=from_lexbuf(1,lexbuf),
                 arm=match[2],
                 headers=match[1],
                 match$0=get_param(headers,cst_filename);
                if(typeof match$0 === "number")
                 var fn=caml_call1(Stdlib[2],cst_Please_specify_the_filenam);
                else
                 if(0 === match$0[0])
                  var fn$0=match$0[1],fn=fn$0;
                 else
                  var fn=caml_call1(Stdlib[2],cst_Invalid_headers);
                var
                 acc$0=caml_call3(StrMap$0[4],fn,[0,headers,arm],acc),
                 acc=acc$0;
                continue}},
           from_filename$0=
            function(filename)
             {var
               channel=caml_call1(Stdlib[79],filename),
               lexbuf=caml_call2(Stdlib_lexing[2],0,channel),
               _fq_=lexbuf[12];
              lexbuf[12] = [0,filename,_fq_[2],_fq_[3],_fq_[4]];
              var res=parse(lexbuf);
              caml_call1(Stdlib[93],channel);
              return res},
           from_str$0=
            function(str){return parse(caml_call2(Stdlib_lexing[3],0,str))},
           main_file=function(param){var mf=param[1];return mf},
           get_file=
            function(name,param)
             {var files=param[2];return caml_call2(StrMap$0[28],name,files)},
           Fs=[0,from_str$0,from_filename$0,main_file,get_file];
          caml_register_global(485,Fs,"Fs");
          var
           load_from_dir=
            function(env,dirname)
             {try
               {var
                 _ff_=enumerate_files(dirname,cst_txt),
                 _fg_=
                  function(x)
                   {var
                     path=caml_call2(Stdlib_filename[4],dirname,x),
                     _fn_=caml_call1(Stdlib_filename[13],x),
                     str=caml_call1(Stdlib_filename[11],_fn_),
                     i=runtime.caml_int_of_string(str),
                     arm=
                      parsed_content_to_arm(dummy_fmt,0,env,from_filename(0,path));
                    function _fo_(arm)
                     {var _fp_=arm_to_binary(arm);
                      return preferred_code
                              (caml_call2(Stdlib_list[19],codes_for_command,_fp_))}
                    var codes=caml_call2(Stdlib_list[19],_fo_,arm);
                    return [0,i,codes]},
                 _fh_=caml_call2(Stdlib_list[19],_fg_,_ff_),
                 _fi_=
                  function(param,_fm_)
                   {var j=_fm_[1],i=param[1];
                    return runtime.caml_int_compare(i,j)},
                 _fj_=caml_call2(Stdlib_list[56],_fi_,_fh_),
                 _fk_=function(x){return [0,x,0]}(_fj_);
                return _fk_}
              catch(_fl_)
               {_fl_ = caml_wrap_exception(_fl_);
                if(_fl_ === CannotOptimize)
                 return caml_call1(Stdlib[2],cst_Exit_codes_cannot_be_tweak);
                throw _fl_}},
           load_from_parsed_file=
            function(fmt,env,param)
             {var
               arm=param[2],
               h=param[1],
               _fc_=parsed_content_to_arm(fmt,1,env,[0,h,arm]);
              function _fd_(arm)
               {var _fe_=arm_to_binary(arm);
                return preferred_code
                        (caml_call2(Stdlib_list[19],codes_for_command,_fe_))}
              var
               codes=caml_call2(Stdlib_list[19],_fd_,_fc_),
               match=get_param(h,cst_start);
              if(typeof match === "number")
               return [0,0,[0,codes]];
              else
               {if(1 === match[0])
                 {var i=match[1];
                  return [0,[0,[0,uint32_to_int(i),codes],0],0]}
                return caml_call1(Stdlib[2],cst_Exit_code_has_invalid_head)}},
           load_from_file=
            function(fmt,env,filename)
             {var
               match=from_filename(1,filename),
               ast=match[2],
               headers=match[1];
              return [0,
                      headers,
                      load_from_parsed_file(fmt,env,[0,headers,ast])]},
           NoExitCode=[248,cst_Exit_NoExitCode,caml_fresh_oo_id(0)],
           get_preferred=
            function(param,i)
             {var default$0=param[2],lst=param[1];
              try
               {var
                 aux=
                  function(lst)
                   {var lst$0=lst;
                    for(;;)
                     {if(lst$0)
                       {var match=lst$0[1],c=match[2],j=match[1];
                        if(runtime.caml_lessequal(i,j))return [0,j,c];
                        var lst$1=lst$0[2],lst$0=lst$1;
                        continue}
                      throw NoExitCode}},
                 _fa_=aux(lst);
                return _fa_}
              catch(_fb_)
               {_fb_ = caml_wrap_exception(_fb_);
                if(_fb_ === NoExitCode)
                 {if(default$0){var c=default$0[1];return [0,i,c]}
                  throw NoExitCode}
                throw _fb_}},
           Exit=
            [0,
             load_from_dir,
             load_from_file,
             load_from_parsed_file,
             NoExitCode,
             get_preferred];
          caml_register_global(486,Exit,"Exit");
          var
           string_of_uchar=
            function(uchar)
             {var buffer=caml_call1(Stdlib_buffer[1],4);
              caml_call2(Uutf[23][1],buffer,uchar);
              return caml_call1(Stdlib_buffer[2],buffer)},
           decompose_into_uchars=
            function(str)
             {var _e9_=0;
              function _e__(acc,param,uc)
               {if(852405675 <= uc[1]){var uc$0=uc[2];return [0,uc$0,acc]}
                throw Stdlib[8]}
              var _e$_=caml_call5(Uutf[22][2],0,0,_e__,_e9_,str);
              return caml_call1(Stdlib_list[9],_e$_)},
           main$1=
            function(fmt)
             {caml_call2(Stdlib_format[126],fmt,_c6_);
              var _e8_=caml_call2(Stdlib_format[126],fmt,_c7_);
              caml_call2(Stdlib_list[17],_e8_,acc);
              caml_call2(Stdlib_format[126],fmt,_c8_);
              return [0,main_1$1]},
           main_1$1=
            function(fmt,str)
             {function aux2(lst)
               {var lst$0=lst;
                for(;;)
                 {if(lst$0)
                   {var _e7_=lst$0[2];
                    if(_e7_)
                     {var lst$1=_e7_[2],b=_e7_[1],a=lst$0[1];
                      caml_call4(Stdlib_format[126],fmt,_c9_,b,a);
                      var lst$0=lst$1;
                      continue}
                    throw [0,Assert_failure,_c__]}
                  return 0}}
              function aux4(lst)
               {var lst$0=lst;
                for(;;)
                 {if(lst$0)
                   {var _e4_=lst$0[2];
                    if(_e4_)
                     {var _e5_=_e4_[2];
                      if(_e5_)
                       {var _e6_=_e5_[2];
                        if(_e6_)
                         {var lst$1=_e6_[2],d=_e6_[1],c=_e5_[1],b=_e4_[1],a=lst$0[1];
                          caml_call6(Stdlib_format[126],fmt,_c$_,d,c,b,a);
                          var lst$0=lst$1;
                          continue}}}
                    throw [0,Assert_failure,_da_]}
                  return 0}}
              try
               {var
                 _e0_=decompose_into_uchars(str),
                 _e1_=caml_call2(Stdlib_list[19],string_of_uchar,_e0_),
                 encoding=
                  caml_call2(Stdlib_list[19],encode_writable_char,_e1_),
                 encoding$0=caml_call2(Stdlib[37],encoding,[0,eof,0]);
                caml_call2(Stdlib_format[126],fmt,_dc_);
                var _e2_=caml_call2(Stdlib_format[126],fmt,_dd_);
                caml_call2(Stdlib_list[17],_e2_,encoding$0);
                var
                 n=caml_call1(Stdlib_list[1],encoding$0),
                 encoding$1=
                  0 === (n % 2 | 0)
                   ?encoding$0
                   :caml_call2(Stdlib[37],encoding$0,_di_);
                caml_call2(Stdlib_format[126],fmt,_de_);
                aux2(encoding$1);
                var
                 n$0=caml_call1(Stdlib_list[1],encoding$1),
                 encoding$2=
                  0 === (n$0 % 4 | 0)
                   ?encoding$1
                   :caml_call2(Stdlib[37],encoding$1,_dh_);
                caml_call2(Stdlib_format[126],fmt,_df_);
                aux4(encoding$2);
                caml_call2(Stdlib_format[126],fmt,_dg_)}
              catch(_e3_)
               {_e3_ = caml_wrap_exception(_e3_);
                if(_e3_ !== Stdlib[8])throw _e3_;
                caml_call2(Stdlib_format[126],fmt,_db_)}
              return 0},
           Encoder_common=
            [0,string_of_uchar,decompose_into_uchars,main$1,main_1$1];
          caml_register_global(488,Encoder_common,"Encoder_common");
          var Constants=[0,33703148,100];
          caml_register_global(489,Constants,"Constants");
          var
           BoxFittingError=[248,cst_Boxes_BoxFittingError,caml_fresh_oo_id(0)],
           default_fillers=[0,_dm_,_dl_,_dk_,_dj_],
           nb_boxes=14,
           no_eof=
            function(codes)
             {function _eZ_(c){return c !== 255?1:0}
              return caml_call2(Stdlib_list[32],_eZ_,codes)},
           pad_nb=
            function(fillers,pos$0,nb)
             {if(0 <= nb)
               {if(0 === nb)return 0;
                var pos=pos$0 % 9 | 0,n=caml_call1(Stdlib_list[1],nop_code);
                if((pos + n | 0) <= 8)
                 var code=nop_code;
                else
                 var
                  _eX_=8 - pos | 0,
                  code=caml_check_bound(fillers,_eX_)[1 + _eX_];
                var
                 m=caml_call1(Stdlib_list[1],code),
                 _eY_=pad_nb(fillers,pos$0 + m | 0,nb - m | 0);
                return caml_call2(Stdlib[37],code,_eY_)}
              return caml_call1(Stdlib[2],cst_Invalid_starting_position)},
           fit_code_at_pos=
            function(opt,fillers,pos,codes$9)
             {if(opt)var sth=opt[1],next=sth;else var next=_do_;
              var pos$0=pos % 9 | 0,n$0=caml_call1(Stdlib_list[1],codes$9);
              if(no_eof(codes$9))
               var is_ok_here=(pos$0 + n$0 | 0) <= 8?1:0;
              else
               {var codes=codes$9;
                for(;;)
                 {if(codes)
                   {var c=codes[1],codes$0=codes[2];
                    if(c !== 255){var codes=codes$0;continue}
                    if(codes$0)
                     {var codes$1=codes$0[2],c$0=codes$0[1];
                      if(c$0 === 255)
                       {var codes$2=[0,c$0,codes$1],codes=codes$2;continue}}
                    var codes$3=codes[2],_eO_=no_eof(codes$3)}
                  else
                   var _eO_=1;
                  if(! _eO_)
                   throw [0,BoxFittingError,cst_Some_codes_cannot_be_posit];
                  var
                   n=caml_call1(Stdlib_list[1],codes$9),
                   codes$4=caml_call1(Stdlib_list[9],codes$9),
                   acc=0,
                   codes$5=codes$4;
                  for(;;)
                   {if(! codes$5)throw [0,Assert_failure,_dn_];
                    var c$1=codes$5[1];
                    if(c$1 !== 255)
                     {var
                       codes$6=codes$5[2],
                       acc$0=acc + 1 | 0,
                       acc=acc$0,
                       codes$5=codes$6;
                      continue}
                    var i=(n - 1 | 0) - acc | 0;
                    if(next)
                     {var next$0=next[1],acc$1=0,codes$7=next$0;
                      for(;;)
                       {if(codes$7)
                         {var codes$8=codes$7[2],c$2=codes$7[1];
                          if(c$2 === 255)
                           {var acc$2=acc$1 + 1 | 0,acc$1=acc$2,codes$7=codes$8;
                            continue}}
                        var j=acc$1;
                        break}}
                    else
                     var j=0;
                    var _eP_=(pos$0 + i | 0) === 8?1:0;
                    if(_eP_)
                     var _eQ_=_eP_;
                    else
                     {var
                       _eR_=i === (n$0 - 1 | 0)?1:0,
                       _eS_=_eR_?((pos$0 + i | 0) + 1 | 0) === 8?1:0:_eR_;
                      if(_eS_)
                       var _eQ_=_eS_;
                      else
                       {var
                         _eT_=i === (n$0 - 1 | 0)?1:0,
                         _eU_=_eT_?((pos$0 + i | 0) + j | 0) === 8?1:0:_eT_;
                        if(_eU_)
                         var _eQ_=_eU_;
                        else
                         {var _eV_=0 === next?1:0;
                          if(_eV_)
                           var
                            _eW_=i === (n$0 - 1 | 0)?1:0,
                            _eQ_=_eW_?(pos$0 + i | 0) <= 8?1:0:_eW_;
                          else
                           var _eQ_=_eV_}}}
                    var is_ok_here=_eQ_;
                    break}
                  break}}
              if(is_ok_here)return codes$9;
              if((pos$0 + n$0 | 0) <= 8)
               var nop_code$0=nop_code;
              else
               var
                _eN_=8 - pos$0 | 0,
                nop_code$0=caml_check_bound(fillers,_eN_)[1 + _eN_];
              var
               m=caml_call1(Stdlib_list[1],nop_code$0),
               _eM_=fit_code_at_pos([0,next],fillers,pos$0 + m | 0,codes$9);
              return caml_call2(Stdlib[37],nop_code$0,_eM_)},
           add_codes_after=
            function(opt,fillers,res,codes)
             {if(opt)var sth=opt[1],final$0=sth;else var final$0=0;
              var acc=res,codes$0=codes;
              for(;;)
               {if(codes$0)
                 {var _eJ_=codes$0[2],_eK_=codes$0[1];
                  if(_eJ_)
                   {var
                     codes$1=_eJ_[2],
                     c2=_eJ_[1],
                     nc=
                      fit_code_at_pos
                       ([0,[0,c2]],fillers,caml_call1(Stdlib_list[1],acc),_eK_),
                     codes$2=[0,c2,codes$1],
                     acc$0=caml_call2(Stdlib[37],acc,nc),
                     acc=acc$0,
                     codes$0=codes$2;
                    continue}
                  var
                   next=final$0?0:_dp_,
                   _eL_=
                    fit_code_at_pos
                     ([0,next],fillers,caml_call1(Stdlib_list[1],acc),_eK_);
                  return caml_call2(Stdlib[37],acc,_eL_)}
                return acc}},
           split_raw_into_boxes=
            function(opt,raw)
             {if(opt)var sth=opt[1],fill_last=sth;else var fill_last=0;
              var finished=0,current=0,codes=raw,i=0;
              for(;;)
               {if(codes)
                 {var c=codes[1],codes$0=codes[2];
                  if(i === 8)
                   {if(c !== 255)
                     throw [0,BoxFittingError,cst_Result_is_inconsistent_Ple];
                    var
                     finished$0=[0,current,finished],
                     finished=finished$0,
                     current=0,
                     codes=codes$0,
                     i=0;
                    continue}
                  if(c === 255)
                   {var i$0=i + 1 | 0,codes=codes$0,i=i$0;continue}
                  var codes$1=codes[2];
                  if(caml_call1(Stdlib_list[1],current) !== i)
                   throw [0,BoxFittingError,cst_Result_is_inconsistent_Ple$0];
                  var
                   i$1=i + 1 | 0,
                   current$0=[0,c,current],
                   current=current$0,
                   codes=codes$1,
                   i=i$1;
                  continue}
                if(0 === i)
                 var _eH_=finished;
                else
                 {var n=caml_call1(Stdlib_list[1],current),switch$0=0;
                  if(fill_last && n === i)
                   {var
                     _eF_=function(param){return space},
                     _eG_=caml_call2(Stdlib_list[10],8 - n | 0,_eF_),
                     current$1=caml_call2(Stdlib[37],_eG_,current);
                    switch$0 = 1}
                  if(! switch$0)var current$1=current;
                  var _eH_=[0,current$1,finished]}
                var _eI_=caml_call2(Stdlib_list[19],Stdlib_list[9],_eH_);
                return caml_call1(Stdlib_list[9],_eI_)}},
           fit_codes_into_boxes=
            function(opt,_eB_,_eA_,_ez_,codes)
             {if(opt)var sth=opt[1],fill_last=sth;else var fill_last=1;
              if(_eB_)
               var sth$0=_eB_[1],fillers=sth$0;
              else
               var fillers=default_fillers;
              if(_eA_)var sth$1=_eA_[1],start=sth$1;else var start=0;
              if(_ez_)var sth$2=_ez_[1],exit=sth$2;else var exit=0;
              var
               padding=pad_nb(fillers,0,start),
               res=add_codes_after([0,0 === exit?1:0],fillers,padding,codes);
              if(exit)
               var
                exit$0=exit[1],
                i=caml_call1(Stdlib_list[1],res),
                match=get_preferred(exit$0,i),
                ecode=match[2],
                j=match[1],
                padding$0=pad_nb(fillers,i,j - i | 0),
                res$0=caml_call2(Stdlib[37],res,padding$0),
                res$1=add_codes_after(_dq_,fillers,res$0,ecode);
              else
               var res$1=res;
              var res$2=split_raw_into_boxes([0,fill_last],res$1);
              function _eC_(i,lst)
               {if(is_full_of_spaces(lst))
                 {var
                   y=caml_call1(Stdlib_list[1],nop_code2),
                   x=(- i | 0) * 9 | 0,
                   result=caml_mod(x,y),
                   pos=0 <= result?result:result + y | 0,
                   _eD_=function(param){return space},
                   prefix=caml_call2(Stdlib_list[10],pos,_eD_),
                   suffix_len=
                    (caml_call1(Stdlib_list[1],lst) - pos | 0)
                    -
                    y
                    |
                    0;
                  if(0 <= suffix_len)
                   {var
                     _eE_=function(param){return space},
                     suffix=caml_call2(Stdlib_list[10],suffix_len,_eE_);
                    return caml_call1
                            (Stdlib_list[13],[0,prefix,[0,nop_code2,[0,suffix,0]]])}
                  return lst}
                return lst}
              return caml_call2(Stdlib_list[20],_eC_,res$2)},
           pp_boxes_names=
            function(fmt,lst)
             {function pp_box(i,codes)
               {var chars=codes_to_chars(codes);
                return caml_call7
                        (Stdlib_format[126],
                         fmt,
                         _dr_,
                         i + 1 | 0,
                         pp_chars,
                         chars,
                         pp_chars_raw,
                         chars)}
              return caml_call2(Stdlib_list[18],pp_box,lst)},
           pp_box_raw=
            function(fmt,lst)
             {function _ev_(param){return eof}
              var
               _ew_=9 - caml_call1(Stdlib_list[1],lst) | 0,
               pad=caml_call2(Stdlib_list[10],_ew_,_ev_),
               _ex_=caml_call2(Stdlib[37],lst,pad),
               _ey_=caml_call2(Stdlib_format[126],fmt,_ds_);
              return caml_call2(Stdlib_list[17],_ey_,_ex_)},
           Boxes=
            [0,
             BoxFittingError,
             default_fillers,
             fit_codes_into_boxes,
             split_raw_into_boxes,
             pp_boxes_names,
             pp_box_raw,
             nb_boxes];
          caml_register_global(490,Boxes,"Boxes");
          var
           pp_hex=
            function(fmt,i){return caml_call3(Stdlib_format[126],fmt,_dt_,i)},
           cond_to_str=
            function(c)
             {switch(c)
               {case 0:return cst_EQ$0;
                case 1:return cst_NE$0;
                case 2:return cst_CS$0;
                case 3:return cst_HS$0;
                case 4:return cst_CC$0;
                case 5:return cst_LO$0;
                case 6:return cst_MI$0;
                case 7:return cst_PL$0;
                case 8:return cst_VS$0;
                case 9:return cst_VC$0;
                case 10:return cst_HI$0;
                case 11:return cst_LS$0;
                case 12:return cst_GE$0;
                case 13:return cst_LT$0;
                case 14:return cst_GT$0;
                case 15:return cst_LE$0;
                default:return cst$2}},
           ldr_str_type_to_str=
            function(t)
             {switch(t)
               {case 0:return cst_B$1;
                case 1:return cst_SB$0;
                case 2:return cst_H$0;
                case 3:return cst_SH$0;
                case 4:return cst$3;
                case 5:return cst_T$0;
                default:return cst_BT$0}},
           sign_to_str=function(sign){return sign === 0?cst$4:cst$5},
           s_to_str=function(s){return s?cst_S$1:cst$6},
           print_register=
            function(fmt,r){return caml_call3(Stdlib_format[126],fmt,_du_,r)},
           print_immediate=
            function(fmt,i){return caml_call3(Stdlib_format[126],fmt,_dv_,i)},
           print_operand=
            function(fmt,op)
             {switch(op[0])
               {case 0:var i=op[1];return print_immediate(fmt,i);
                case 1:
                 var r=op[1];
                 return caml_call4
                         (Stdlib_format[126],fmt,_dw_,print_register,r);
                default:return caml_call1(Stdlib[2],cst_Not_implemented$3)}},
           print_immediate_offset=
            function(fmt,param)
             {var i=param[2],s=param[1],_eu_=sign_to_str(s);
              return caml_call4(Stdlib_format[126],fmt,_dx_,_eu_,i)},
           print_register_offset=
            function(fmt,param)
             {var
               addr_typ=param[2],
               ro=param[1],
               str=1 === addr_typ?cst$8:cst$9;
              switch(ro[0])
               {case 0:
                 var _eq_=ro[1];
                 if(2 <= addr_typ)
                  {var i=ro[3],s=ro[2];
                   return caml_call6
                           (Stdlib_format[126],
                            fmt,
                            _dy_,
                            print_register,
                            _eq_,
                            print_immediate_offset,
                            [0,s,i])}
                 var i$0=ro[3],s$0=ro[2];
                 return caml_call7
                         (Stdlib_format[126],
                          fmt,
                          _dz_,
                          print_register,
                          _eq_,
                          print_immediate_offset,
                          [0,s$0,i$0],
                          str);
                case 1:
                 var _er_=ro[1];
                 if(2 <= addr_typ)
                  {var ro$0=ro[3],s$1=ro[2],_es_=sign_to_str(s$1);
                   return caml_call7
                           (Stdlib_format[126],
                            fmt,
                            _dA_,
                            print_register,
                            _er_,
                            _es_,
                            print_register,
                            ro$0)}
                 var ro$1=ro[3],s$2=ro[2],_et_=sign_to_str(s$2);
                 return caml_call8
                         (Stdlib_format[126],
                          fmt,
                          _dB_,
                          print_register,
                          _er_,
                          _et_,
                          print_register,
                          ro$1,
                          str);
                default:return caml_call1(Stdlib[2],cst_Not_implemented$4)}},
           pp_arm=
            function(fmt,arm)
             {switch(arm[0])
               {case 0:var i=arm[1];return pp_hex(fmt,i);
                case 1:
                 var
                  ro=arm[4],
                  rd=arm[3],
                  cond=arm[2],
                  typ=arm[1],
                  _d__=ldr_str_type_to_str(typ),
                  _d$_=cond_to_str(cond);
                 return caml_call8
                         (Stdlib_format[126],
                          fmt,
                          _dC_,
                          _d$_,
                          _d__,
                          print_register,
                          rd,
                          print_register_offset,
                          ro);
                case 2:
                 var
                  ro$0=arm[4],
                  rd$0=arm[3],
                  cond$0=arm[2],
                  typ$0=arm[1],
                  _ea_=ldr_str_type_to_str(typ$0),
                  _eb_=cond_to_str(cond$0);
                 return caml_call8
                         (Stdlib_format[126],
                          fmt,
                          _dD_,
                          _eb_,
                          _ea_,
                          print_register,
                          rd$0,
                          print_register_offset,
                          ro$0);
                case 3:
                 var
                  rs=arm[4],
                  rd$1=arm[3],
                  cond$1=arm[2],
                  s=arm[1],
                  _ec_=s_to_str(s),
                  _ed_=cond_to_str(cond$1);
                 return caml_call8
                         (Stdlib_format[126],
                          fmt,
                          _dE_,
                          _ed_,
                          _ec_,
                          print_register,
                          rd$1,
                          print_operand,
                          rs);
                case 4:
                 var
                  rs$0=arm[4],
                  rd$2=arm[3],
                  cond$2=arm[2],
                  s$0=arm[1],
                  _ee_=s_to_str(s$0),
                  _ef_=cond_to_str(cond$2);
                 return caml_call8
                         (Stdlib_format[126],
                          fmt,
                          _dF_,
                          _ef_,
                          _ee_,
                          print_register,
                          rd$2,
                          print_operand,
                          rs$0);
                case 5:
                 var
                  op2=arm[5],
                  rn=arm[4],
                  rd$3=arm[3],
                  cond$3=arm[2],
                  s$1=arm[1],
                  _eg_=s_to_str(s$1),
                  _eh_=cond_to_str(cond$3);
                 return caml_call10
                         (Stdlib_format[126],
                          fmt,
                          _dG_,
                          _eh_,
                          _eg_,
                          print_register,
                          rd$3,
                          print_register,
                          rn,
                          print_operand,
                          op2);
                case 6:
                 var
                  op2$0=arm[5],
                  rn$0=arm[4],
                  rd$4=arm[3],
                  cond$4=arm[2],
                  s$2=arm[1],
                  _ei_=s_to_str(s$2),
                  _ej_=cond_to_str(cond$4);
                 return caml_call10
                         (Stdlib_format[126],
                          fmt,
                          _dH_,
                          _ej_,
                          _ei_,
                          print_register,
                          rd$4,
                          print_register,
                          rn$0,
                          print_operand,
                          op2$0);
                case 7:
                 var
                  op2$1=arm[5],
                  rn$1=arm[4],
                  rd$5=arm[3],
                  cond$5=arm[2],
                  s$3=arm[1],
                  _ek_=s_to_str(s$3),
                  _el_=cond_to_str(cond$5);
                 return caml_call10
                         (Stdlib_format[126],
                          fmt,
                          _dI_,
                          _el_,
                          _ek_,
                          print_register,
                          rd$5,
                          print_register,
                          rn$1,
                          print_operand,
                          op2$1);
                case 8:
                 var
                  op2$2=arm[5],
                  rn$2=arm[4],
                  rd$6=arm[3],
                  cond$6=arm[2],
                  s$4=arm[1],
                  _em_=s_to_str(s$4),
                  _en_=cond_to_str(cond$6);
                 return caml_call10
                         (Stdlib_format[126],
                          fmt,
                          _dJ_,
                          _en_,
                          _em_,
                          print_register,
                          rd$6,
                          print_register,
                          rn$2,
                          print_operand,
                          op2$2);
                default:
                 var
                  target=arm[3],
                  cond$7=arm[2],
                  l=arm[1],
                  _eo_=cond_to_str(cond$7),
                  _ep_=l?cst_L$1:cst$7;
                 return caml_call6
                         (Stdlib_format[126],
                          fmt,
                          _dK_,
                          _ep_,
                          _eo_,
                          print_immediate,
                          target)}},
           Arm_printer=[0,pp_arm,pp_hex];
          caml_register_global(491,Arm_printer,"Arm_printer");
          var
           treat_command=
            function(fmt,arm)
             {var
               hexs=arm_to_binary(arm),
               codes=caml_call2(Stdlib_list[19],codes_for_command,hexs),
               code=preferred_code(codes),
               hex=command_for_codes(code),
               chars=codes_to_chars(code);
              caml_call8
               (Stdlib_format[126],
                fmt,
                _dL_,
                pp_chars,
                chars,
                pp_hex,
                hex,
                pp_arm,
                arm);
              return code},
           main$2=
            function(fmt,env,param,parsed,exit)
             {var
               headers2=param[2],
               headers=param[1],
               match=get_param(headers,cst_onlyraw);
              if(typeof match === "number")
               var onlyraw=0;
              else
               if(2 === match[0])
                var b$0=match[1],onlyraw=b$0;
               else
                var onlyraw=caml_call1(Stdlib[2],cst_Invalid_headers$3);
              var _dX_=onlyraw?0 !== exit?1:0:onlyraw;
              if(_dX_)caml_call1(Stdlib[2],cst_Only_raw_mode_does_not_sup);
              var match$0=get_param(headers,cst_start$0);
              if(typeof match$0 === "number")
               var start=0;
              else
               if(1 === match$0[0])
                var i=match$0[1],start=uint32_to_int(i);
               else
                var start=caml_call1(Stdlib[2],cst_Invalid_headers$2);
              function _dY_(n)
               {var
                 header_name=caml_call2(Stdlib_format[129],_dM_,n + 1 | 0),
                 match=get_param(headers,header_name);
                if(typeof match === "number")
                 return caml_check_bound(default_fillers,n)[1 + n];
                else
                 {if(1 === match[0])
                   {var i=match[1],codes=codes_for_command(i);
                    if(caml_call2(Stdlib_list[7],codes,n) !== 255)
                     caml_call1(Stdlib[2],cst_Invalid_filler);
                    return codes}
                  return caml_call1(Stdlib[2],cst_Invalid_headers$0)}}
              var
               fillers=caml_call2(Stdlib_array[2],4,_dY_),
               match$1=get_param(headers,cst_fill),
               match$2=get_param(headers2,cst_fill$0),
               switch$0=0;
              if(typeof match$1 === "number")
               if(typeof match$2 === "number")
                var fill_last=1;
               else
                if(2 === match$2[0])
                 {var b=match$2[1];switch$0 = 2}
                else
                 switch$0 = 1;
              else
               if(2 === match$1[0])
                {var _d7_=match$1[1];
                 if(typeof match$2 === "number")
                  {var b=_d7_;switch$0 = 2}
                 else
                  if(2 === match$2[0])
                   var
                    b2=match$2[1],
                    b1=
                     _d7_ === b2
                      ?_d7_
                      :caml_call1(Stdlib[2],cst_The_fill_header_has_a_diff),
                    fill_last=b1;
                  else
                   switch$0 = 1}
               else
                switch$0 = 1;
              switch(switch$0)
               {case 1:
                 var fill_last=caml_call1(Stdlib[2],cst_Invalid_headers$1);
                 break;
                case 2:var fill_last=b;break
                }
              var _dZ_=parsed_ast_to_arm(1,env,parsed);
              function _d0_(_d9_){return treat_command(fmt,_d9_)}
              var res=caml_call2(Stdlib_list[19],_d0_,_dZ_);
              if(onlyraw)
               {var
                 _d1_=function(param){return 0},
                 start$0=caml_call2(Stdlib_list[10],start,_d1_),
                 res$0=caml_call1(Stdlib_list[13],[0,start$0,res]);
                caml_call2(Stdlib_format[126],fmt,_dN_);
                var _d2_=caml_call2(Stdlib_format[126],fmt,_dO_);
                caml_call2(Stdlib_list[17],_d2_,res$0);
                caml_call2(Stdlib_format[126],fmt,_dP_);
                return 0}
              try
               {var
                 boxes_codes=
                  fit_codes_into_boxes
                   ([0,fill_last],[0,fillers],[0,start],[0,exit],res);
                caml_call4
                 (Stdlib_format[126],fmt,_dQ_,pp_boxes_names,boxes_codes);
                var size=caml_call1(Stdlib_list[1],boxes_codes);
                if(14 < size)
                 caml_call4(Stdlib_format[126],fmt,_dR_,size,nb_boxes);
                var _d3_=function(c){return 1 - is_code_writable(c)};
                if(caml_call2(Stdlib_list[33],_d3_,boxes_codes))
                 caml_call2(Stdlib_format[126],fmt,_dS_);
                else
                 if(caml_call2(Stdlib_list[33],is_full_of_spaces,boxes_codes))
                  caml_call2(Stdlib_format[126],fmt,_dW_);
                caml_call2(Stdlib_format[126],fmt,_dT_);
                var _d4_=caml_call3(Stdlib_format[126],fmt,_dU_,pp_box_raw);
                caml_call2(Stdlib_list[17],_d4_,boxes_codes);
                caml_call2(Stdlib_format[126],fmt,_dV_);
                var
                 _d5_=function(c){return concat_strings(codes_to_chars(c))},
                 _d6_=[0,caml_call2(Stdlib_list[19],_d5_,boxes_codes)];
                return _d6_}
              catch(_d8_)
               {_d8_ = caml_wrap_exception(_d8_);
                if(_d8_ === NoExitCode)
                 return caml_call1(Stdlib[2],cst_The_exit_code_overlaps_thi);
                throw _d8_}},
           Ace_common=[0,treat_command,main$2];
          caml_register_global(492,Ace_common,"Ace_common");
          return}
        var
         i$3=caml_call1(Stdlib_int32[6],i$2),
         acc$2=[0,i$2,acc$1],
         acc$1=acc$2,
         i$2=i$3;
        continue}}}
  (function(){return this}()));


//# 1 ".js/js_of_ocaml/js_of_ocaml.cma.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_exn_with_js_backtrace=runtime.caml_exn_with_js_backtrace,
     caml_float_of_string=runtime.caml_float_of_string,
     caml_fresh_oo_id=runtime.caml_fresh_oo_id,
     caml_int_of_string=runtime.caml_int_of_string,
     caml_js_from_array=runtime.caml_js_from_array,
     caml_js_get=runtime.caml_js_get,
     caml_js_html_escape=runtime.caml_js_html_escape,
     caml_js_set=runtime.caml_js_set,
     caml_js_wrap_callback=runtime.caml_js_wrap_callback,
     caml_js_wrap_meth_callback=runtime.caml_js_wrap_meth_callback,
     caml_jsbytes_of_string=runtime.caml_jsbytes_of_string,
     caml_jsstring_of_string=runtime.caml_jsstring_of_string,
     caml_list_of_js_array=runtime.caml_list_of_js_array,
     caml_ml_string_length=runtime.caml_ml_string_length,
     caml_register_global=runtime.caml_register_global,
     caml_string_compare=runtime.caml_string_compare,
     caml_string_notequal=runtime.caml_string_notequal,
     caml_string_of_array=runtime.caml_string_of_array,
     caml_string_of_jsbytes=runtime.caml_string_of_jsbytes,
     caml_string_of_jsstring=runtime.caml_string_of_jsstring,
     caml_wrap_exception=runtime.caml_wrap_exception;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5
              ?f(a0,a1,a2,a3,a4)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4])}
    var
     global_data=runtime.caml_get_global_data(),
     cst_parseFloat=caml_string_of_jsbytes("parseFloat"),
     cst_parseInt=caml_string_of_jsbytes("parseInt"),
     cst_Js_of_ocaml_Js_Error=caml_string_of_jsbytes("Js_of_ocaml__Js.Error"),
     cst_jsError=caml_string_of_jsbytes("jsError"),
     cst_can_t_retrieve_file_name_n=
      caml_string_of_jsbytes("can't retrieve file name: not implemented"),
     cst_endings=caml_string_of_jsbytes("endings"),
     cst_type=caml_string_of_jsbytes("type"),
     cst_loadstart=caml_string_of_jsbytes("loadstart"),
     cst_progress=caml_string_of_jsbytes("progress"),
     cst_abort=caml_string_of_jsbytes("abort"),
     cst_error=caml_string_of_jsbytes("error"),
     cst_load=caml_string_of_jsbytes("load"),
     cst_loadend=caml_string_of_jsbytes("loadend"),
     cst_a$1=caml_string_of_jsbytes("a"),
     cst_area$1=caml_string_of_jsbytes("area"),
     cst_audio$1=caml_string_of_jsbytes("audio"),
     cst_base$1=caml_string_of_jsbytes("base"),
     cst_blockquote$1=caml_string_of_jsbytes("blockquote"),
     cst_body$1=caml_string_of_jsbytes("body"),
     cst_br$1=caml_string_of_jsbytes("br"),
     cst_button$1=caml_string_of_jsbytes("button"),
     cst_canvas$1=caml_string_of_jsbytes("canvas"),
     cst_caption$1=caml_string_of_jsbytes("caption"),
     cst_col$1=caml_string_of_jsbytes("col"),
     cst_colgroup$1=caml_string_of_jsbytes("colgroup"),
     cst_del$1=caml_string_of_jsbytes("del"),
     cst_div$1=caml_string_of_jsbytes("div"),
     cst_dl$1=caml_string_of_jsbytes("dl"),
     cst_embed$1=caml_string_of_jsbytes("embed"),
     cst_fieldset$1=caml_string_of_jsbytes("fieldset"),
     cst_form$1=caml_string_of_jsbytes("form"),
     cst_frame$1=caml_string_of_jsbytes("frame"),
     cst_frameset$1=caml_string_of_jsbytes("frameset"),
     cst_h1$1=caml_string_of_jsbytes("h1"),
     cst_h2$1=caml_string_of_jsbytes("h2"),
     cst_h3$1=caml_string_of_jsbytes("h3"),
     cst_h4$1=caml_string_of_jsbytes("h4"),
     cst_h5$1=caml_string_of_jsbytes("h5"),
     cst_h6$1=caml_string_of_jsbytes("h6"),
     cst_head$1=caml_string_of_jsbytes("head"),
     cst_hr$1=caml_string_of_jsbytes("hr"),
     cst_html$1=caml_string_of_jsbytes("html"),
     cst_iframe$1=caml_string_of_jsbytes("iframe"),
     cst_img$1=caml_string_of_jsbytes("img"),
     cst_input$2=caml_string_of_jsbytes("input"),
     cst_ins$1=caml_string_of_jsbytes("ins"),
     cst_label$1=caml_string_of_jsbytes("label"),
     cst_legend$1=caml_string_of_jsbytes("legend"),
     cst_li$1=caml_string_of_jsbytes("li"),
     cst_link$1=caml_string_of_jsbytes("link"),
     cst_map$1=caml_string_of_jsbytes("map"),
     cst_meta$1=caml_string_of_jsbytes("meta"),
     cst_object$1=caml_string_of_jsbytes("object"),
     cst_ol$1=caml_string_of_jsbytes("ol"),
     cst_optgroup$1=caml_string_of_jsbytes("optgroup"),
     cst_option$1=caml_string_of_jsbytes("option"),
     cst_p$1=caml_string_of_jsbytes("p"),
     cst_param$1=caml_string_of_jsbytes("param"),
     cst_pre$1=caml_string_of_jsbytes("pre"),
     cst_q$1=caml_string_of_jsbytes("q"),
     cst_script$1=caml_string_of_jsbytes("script"),
     cst_select$2=caml_string_of_jsbytes("select"),
     cst_style$1=caml_string_of_jsbytes("style"),
     cst_table$1=caml_string_of_jsbytes("table"),
     cst_tbody$1=caml_string_of_jsbytes("tbody"),
     cst_td$1=caml_string_of_jsbytes("td"),
     cst_textarea$1=caml_string_of_jsbytes("textarea"),
     cst_tfoot$1=caml_string_of_jsbytes("tfoot"),
     cst_th$1=caml_string_of_jsbytes("th"),
     cst_thead$1=caml_string_of_jsbytes("thead"),
     cst_title$1=caml_string_of_jsbytes("title"),
     cst_tr$1=caml_string_of_jsbytes("tr"),
     cst_ul$1=caml_string_of_jsbytes("ul"),
     cst_video$1=caml_string_of_jsbytes("video"),
     cst_KeyH=caml_string_of_jsbytes("KeyH"),
     cst_Digit6=caml_string_of_jsbytes("Digit6"),
     cst_BrowserRefresh=caml_string_of_jsbytes("BrowserRefresh"),
     cst_Backslash=caml_string_of_jsbytes("Backslash"),
     cst_AltLeft=caml_string_of_jsbytes("AltLeft"),
     cst_AltRight=caml_string_of_jsbytes("AltRight"),
     cst_ArrowDown=caml_string_of_jsbytes("ArrowDown"),
     cst_ArrowLeft=caml_string_of_jsbytes("ArrowLeft"),
     cst_ArrowRight=caml_string_of_jsbytes("ArrowRight"),
     cst_ArrowUp=caml_string_of_jsbytes("ArrowUp"),
     cst_Backquote=caml_string_of_jsbytes("Backquote"),
     cst_Backspace=caml_string_of_jsbytes("Backspace"),
     cst_BracketLeft=caml_string_of_jsbytes("BracketLeft"),
     cst_BracketRight=caml_string_of_jsbytes("BracketRight"),
     cst_BrowserBack=caml_string_of_jsbytes("BrowserBack"),
     cst_BrowserFavorites=caml_string_of_jsbytes("BrowserFavorites"),
     cst_BrowserForward=caml_string_of_jsbytes("BrowserForward"),
     cst_BrowserHome=caml_string_of_jsbytes("BrowserHome"),
     cst_Delete=caml_string_of_jsbytes("Delete"),
     cst_BrowserSearch=caml_string_of_jsbytes("BrowserSearch"),
     cst_BrowserStop=caml_string_of_jsbytes("BrowserStop"),
     cst_CapsLock=caml_string_of_jsbytes("CapsLock"),
     cst_Comma=caml_string_of_jsbytes("Comma"),
     cst_ContextMenu=caml_string_of_jsbytes("ContextMenu"),
     cst_ControlLeft=caml_string_of_jsbytes("ControlLeft"),
     cst_ControlRight=caml_string_of_jsbytes("ControlRight"),
     cst_Digit0=caml_string_of_jsbytes("Digit0"),
     cst_Digit1=caml_string_of_jsbytes("Digit1"),
     cst_Digit2=caml_string_of_jsbytes("Digit2"),
     cst_Digit3=caml_string_of_jsbytes("Digit3"),
     cst_Digit4=caml_string_of_jsbytes("Digit4"),
     cst_Digit5=caml_string_of_jsbytes("Digit5"),
     cst_F6=caml_string_of_jsbytes("F6"),
     cst_F1=caml_string_of_jsbytes("F1"),
     cst_Digit7=caml_string_of_jsbytes("Digit7"),
     cst_Digit8=caml_string_of_jsbytes("Digit8"),
     cst_Digit9=caml_string_of_jsbytes("Digit9"),
     cst_End=caml_string_of_jsbytes("End"),
     cst_Enter=caml_string_of_jsbytes("Enter"),
     cst_Equal=caml_string_of_jsbytes("Equal"),
     cst_Escape=caml_string_of_jsbytes("Escape"),
     cst_F10=caml_string_of_jsbytes("F10"),
     cst_F11=caml_string_of_jsbytes("F11"),
     cst_F12=caml_string_of_jsbytes("F12"),
     cst_F2=caml_string_of_jsbytes("F2"),
     cst_F3=caml_string_of_jsbytes("F3"),
     cst_F4=caml_string_of_jsbytes("F4"),
     cst_F5=caml_string_of_jsbytes("F5"),
     cst_KeyA=caml_string_of_jsbytes("KeyA"),
     cst_F7=caml_string_of_jsbytes("F7"),
     cst_F8=caml_string_of_jsbytes("F8"),
     cst_F9=caml_string_of_jsbytes("F9"),
     cst_Home=caml_string_of_jsbytes("Home"),
     cst_Insert=caml_string_of_jsbytes("Insert"),
     cst_IntlBackslash=caml_string_of_jsbytes("IntlBackslash"),
     cst_IntlYen=caml_string_of_jsbytes("IntlYen"),
     cst_KeyB=caml_string_of_jsbytes("KeyB"),
     cst_KeyC=caml_string_of_jsbytes("KeyC"),
     cst_KeyD=caml_string_of_jsbytes("KeyD"),
     cst_KeyE=caml_string_of_jsbytes("KeyE"),
     cst_KeyF=caml_string_of_jsbytes("KeyF"),
     cst_KeyG=caml_string_of_jsbytes("KeyG"),
     cst_Numpad4=caml_string_of_jsbytes("Numpad4"),
     cst_KeyX=caml_string_of_jsbytes("KeyX"),
     cst_KeyP=caml_string_of_jsbytes("KeyP"),
     cst_KeyI=caml_string_of_jsbytes("KeyI"),
     cst_KeyJ=caml_string_of_jsbytes("KeyJ"),
     cst_KeyK=caml_string_of_jsbytes("KeyK"),
     cst_KeyL=caml_string_of_jsbytes("KeyL"),
     cst_KeyM=caml_string_of_jsbytes("KeyM"),
     cst_KeyN=caml_string_of_jsbytes("KeyN"),
     cst_KeyO=caml_string_of_jsbytes("KeyO"),
     cst_KeyQ=caml_string_of_jsbytes("KeyQ"),
     cst_KeyR=caml_string_of_jsbytes("KeyR"),
     cst_KeyS=caml_string_of_jsbytes("KeyS"),
     cst_KeyT=caml_string_of_jsbytes("KeyT"),
     cst_KeyU=caml_string_of_jsbytes("KeyU"),
     cst_KeyV=caml_string_of_jsbytes("KeyV"),
     cst_KeyW=caml_string_of_jsbytes("KeyW"),
     cst_MetaRight=caml_string_of_jsbytes("MetaRight"),
     cst_KeyY=caml_string_of_jsbytes("KeyY"),
     cst_KeyZ=caml_string_of_jsbytes("KeyZ"),
     cst_MediaPlayPause=caml_string_of_jsbytes("MediaPlayPause"),
     cst_MediaStop=caml_string_of_jsbytes("MediaStop"),
     cst_MediaTrackNext=caml_string_of_jsbytes("MediaTrackNext"),
     cst_MediaTrackPrevious=caml_string_of_jsbytes("MediaTrackPrevious"),
     cst_MetaLeft=caml_string_of_jsbytes("MetaLeft"),
     cst_Minus=caml_string_of_jsbytes("Minus"),
     cst_NumLock=caml_string_of_jsbytes("NumLock"),
     cst_Numpad0=caml_string_of_jsbytes("Numpad0"),
     cst_Numpad1=caml_string_of_jsbytes("Numpad1"),
     cst_Numpad2=caml_string_of_jsbytes("Numpad2"),
     cst_Numpad3=caml_string_of_jsbytes("Numpad3"),
     cst_PageUp=caml_string_of_jsbytes("PageUp"),
     cst_NumpadDivide=caml_string_of_jsbytes("NumpadDivide"),
     cst_Numpad5=caml_string_of_jsbytes("Numpad5"),
     cst_Numpad6=caml_string_of_jsbytes("Numpad6"),
     cst_Numpad7=caml_string_of_jsbytes("Numpad7"),
     cst_Numpad8=caml_string_of_jsbytes("Numpad8"),
     cst_Numpad9=caml_string_of_jsbytes("Numpad9"),
     cst_NumpadAdd=caml_string_of_jsbytes("NumpadAdd"),
     cst_NumpadDecimal=caml_string_of_jsbytes("NumpadDecimal"),
     cst_NumpadEnter=caml_string_of_jsbytes("NumpadEnter"),
     cst_NumpadEqual=caml_string_of_jsbytes("NumpadEqual"),
     cst_NumpadMultiply=caml_string_of_jsbytes("NumpadMultiply"),
     cst_NumpadSubtract=caml_string_of_jsbytes("NumpadSubtract"),
     cst_OSLeft=caml_string_of_jsbytes("OSLeft"),
     cst_OSRight=caml_string_of_jsbytes("OSRight"),
     cst_PageDown=caml_string_of_jsbytes("PageDown"),
     cst_ShiftRight=caml_string_of_jsbytes("ShiftRight"),
     cst_Pause=caml_string_of_jsbytes("Pause"),
     cst_Period=caml_string_of_jsbytes("Period"),
     cst_PrintScreen=caml_string_of_jsbytes("PrintScreen"),
     cst_Quote=caml_string_of_jsbytes("Quote"),
     cst_ScrollLock=caml_string_of_jsbytes("ScrollLock"),
     cst_Semicolon=caml_string_of_jsbytes("Semicolon"),
     cst_ShiftLeft=caml_string_of_jsbytes("ShiftLeft"),
     cst_Slash=caml_string_of_jsbytes("Slash"),
     cst_Space=caml_string_of_jsbytes("Space"),
     cst_Tab=caml_string_of_jsbytes("Tab"),
     cst_VolumeDown=caml_string_of_jsbytes("VolumeDown"),
     cst_VolumeMute=caml_string_of_jsbytes("VolumeMute"),
     cst_VolumeUp=caml_string_of_jsbytes("VolumeUp"),
     cst_mouseout$0=caml_string_of_jsbytes("mouseout"),
     cst_mouseover$0=caml_string_of_jsbytes("mouseover"),
     cst_video$0=caml_string_of_jsbytes("video"),
     cst_audio$0=caml_string_of_jsbytes("audio"),
     cst_ul$0=caml_string_of_jsbytes("ul"),
     cst_tr$0=caml_string_of_jsbytes("tr"),
     cst_title$0=caml_string_of_jsbytes("title"),
     cst_thead$0=caml_string_of_jsbytes("thead"),
     cst_th$0=caml_string_of_jsbytes("th"),
     cst_tfoot$0=caml_string_of_jsbytes("tfoot"),
     cst_textarea$0=caml_string_of_jsbytes("textarea"),
     cst_td$0=caml_string_of_jsbytes("td"),
     cst_tbody$0=caml_string_of_jsbytes("tbody"),
     cst_table$0=caml_string_of_jsbytes("table"),
     cst_style$0=caml_string_of_jsbytes("style"),
     cst_select$1=caml_string_of_jsbytes("select"),
     cst_script$0=caml_string_of_jsbytes("script"),
     cst_q$0=caml_string_of_jsbytes("q"),
     cst_pre$0=caml_string_of_jsbytes("pre"),
     cst_param$0=caml_string_of_jsbytes("param"),
     cst_p$0=caml_string_of_jsbytes("p"),
     cst_option$0=caml_string_of_jsbytes("option"),
     cst_optgroup$0=caml_string_of_jsbytes("optgroup"),
     cst_ol$0=caml_string_of_jsbytes("ol"),
     cst_object$0=caml_string_of_jsbytes("object"),
     cst_meta$0=caml_string_of_jsbytes("meta"),
     cst_map$0=caml_string_of_jsbytes("map"),
     cst_link$0=caml_string_of_jsbytes("link"),
     cst_li$0=caml_string_of_jsbytes("li"),
     cst_legend$0=caml_string_of_jsbytes("legend"),
     cst_label$0=caml_string_of_jsbytes("label"),
     cst_ins$0=caml_string_of_jsbytes("ins"),
     cst_input$1=caml_string_of_jsbytes("input"),
     cst_img$0=caml_string_of_jsbytes("img"),
     cst_iframe$0=caml_string_of_jsbytes("iframe"),
     cst_html$0=caml_string_of_jsbytes("html"),
     cst_hr$0=caml_string_of_jsbytes("hr"),
     cst_head$0=caml_string_of_jsbytes("head"),
     cst_h6$0=caml_string_of_jsbytes("h6"),
     cst_h5$0=caml_string_of_jsbytes("h5"),
     cst_h4$0=caml_string_of_jsbytes("h4"),
     cst_h3$0=caml_string_of_jsbytes("h3"),
     cst_h2$0=caml_string_of_jsbytes("h2"),
     cst_h1$0=caml_string_of_jsbytes("h1"),
     cst_frame$0=caml_string_of_jsbytes("frame"),
     cst_frameset$0=caml_string_of_jsbytes("frameset"),
     cst_form$0=caml_string_of_jsbytes("form"),
     cst_embed$0=caml_string_of_jsbytes("embed"),
     cst_fieldset$0=caml_string_of_jsbytes("fieldset"),
     cst_dl$0=caml_string_of_jsbytes("dl"),
     cst_div$0=caml_string_of_jsbytes("div"),
     cst_del$0=caml_string_of_jsbytes("del"),
     cst_colgroup$0=caml_string_of_jsbytes("colgroup"),
     cst_col$0=caml_string_of_jsbytes("col"),
     cst_caption$0=caml_string_of_jsbytes("caption"),
     cst_canvas$0=caml_string_of_jsbytes("canvas"),
     cst_button$0=caml_string_of_jsbytes("button"),
     cst_br$0=caml_string_of_jsbytes("br"),
     cst_body$0=caml_string_of_jsbytes("body"),
     cst_blockquote$0=caml_string_of_jsbytes("blockquote"),
     cst_base$0=caml_string_of_jsbytes("base"),
     cst_area$0=caml_string_of_jsbytes("area"),
     cst_a$0=caml_string_of_jsbytes("a"),
     cst_canvas=caml_string_of_jsbytes("canvas"),
     cst_video=caml_string_of_jsbytes("video"),
     cst_audio=caml_string_of_jsbytes("audio"),
     cst_iframe=caml_string_of_jsbytes("iframe"),
     cst_frame=caml_string_of_jsbytes("frame"),
     cst_frameset=caml_string_of_jsbytes("frameset"),
     cst_address=caml_string_of_jsbytes("address"),
     cst_noscript=caml_string_of_jsbytes("noscript"),
     cst_dt=caml_string_of_jsbytes("dt"),
     cst_dd=caml_string_of_jsbytes("dd"),
     cst_abbr=caml_string_of_jsbytes("abbr"),
     cst_var=caml_string_of_jsbytes("var"),
     cst_kbd=caml_string_of_jsbytes("kbd"),
     cst_samp=caml_string_of_jsbytes("samp"),
     cst_code=caml_string_of_jsbytes("code"),
     cst_dfn=caml_string_of_jsbytes("dfn"),
     cst_cite=caml_string_of_jsbytes("cite"),
     cst_strong=caml_string_of_jsbytes("strong"),
     cst_em=caml_string_of_jsbytes("em"),
     cst_small=caml_string_of_jsbytes("small"),
     cst_big=caml_string_of_jsbytes("big"),
     cst_b=caml_string_of_jsbytes("b"),
     cst_i=caml_string_of_jsbytes("i"),
     cst_tt=caml_string_of_jsbytes("tt"),
     cst_span=caml_string_of_jsbytes("span"),
     cst_sup=caml_string_of_jsbytes("sup"),
     cst_sub=caml_string_of_jsbytes("sub"),
     cst_td=caml_string_of_jsbytes("td"),
     cst_th=caml_string_of_jsbytes("th"),
     cst_tr=caml_string_of_jsbytes("tr"),
     cst_tbody=caml_string_of_jsbytes("tbody"),
     cst_tfoot=caml_string_of_jsbytes("tfoot"),
     cst_thead=caml_string_of_jsbytes("thead"),
     cst_colgroup=caml_string_of_jsbytes("colgroup"),
     cst_col=caml_string_of_jsbytes("col"),
     cst_caption=caml_string_of_jsbytes("caption"),
     cst_table=caml_string_of_jsbytes("table"),
     cst_script=caml_string_of_jsbytes("script"),
     cst_area=caml_string_of_jsbytes("area"),
     cst_map=caml_string_of_jsbytes("map"),
     cst_param=caml_string_of_jsbytes("param"),
     cst_object=caml_string_of_jsbytes("object"),
     cst_img=caml_string_of_jsbytes("img"),
     cst_a=caml_string_of_jsbytes("a"),
     cst_del=caml_string_of_jsbytes("del"),
     cst_ins=caml_string_of_jsbytes("ins"),
     cst_hr=caml_string_of_jsbytes("hr"),
     cst_br=caml_string_of_jsbytes("br"),
     cst_pre=caml_string_of_jsbytes("pre"),
     cst_blockquote=caml_string_of_jsbytes("blockquote"),
     cst_q=caml_string_of_jsbytes("q"),
     cst_h6=caml_string_of_jsbytes("h6"),
     cst_h5=caml_string_of_jsbytes("h5"),
     cst_h4=caml_string_of_jsbytes("h4"),
     cst_h3=caml_string_of_jsbytes("h3"),
     cst_h2=caml_string_of_jsbytes("h2"),
     cst_h1=caml_string_of_jsbytes("h1"),
     cst_p=caml_string_of_jsbytes("p"),
     cst_embed=caml_string_of_jsbytes("embed"),
     cst_div=caml_string_of_jsbytes("div"),
     cst_li=caml_string_of_jsbytes("li"),
     cst_dl=caml_string_of_jsbytes("dl"),
     cst_ol=caml_string_of_jsbytes("ol"),
     cst_ul=caml_string_of_jsbytes("ul"),
     cst_legend=caml_string_of_jsbytes("legend"),
     cst_fieldset=caml_string_of_jsbytes("fieldset"),
     cst_label=caml_string_of_jsbytes("label"),
     cst_button=caml_string_of_jsbytes("button"),
     cst_textarea=caml_string_of_jsbytes("textarea"),
     cst_input$0=caml_string_of_jsbytes("input"),
     cst_select$0=caml_string_of_jsbytes("select"),
     cst_option=caml_string_of_jsbytes("option"),
     cst_optgroup=caml_string_of_jsbytes("optgroup"),
     cst_form=caml_string_of_jsbytes("form"),
     cst_body=caml_string_of_jsbytes("body"),
     cst_style=caml_string_of_jsbytes("style"),
     cst_base=caml_string_of_jsbytes("base"),
     cst_meta=caml_string_of_jsbytes("meta"),
     cst_title=caml_string_of_jsbytes("title"),
     cst_link=caml_string_of_jsbytes("link"),
     cst_head=caml_string_of_jsbytes("head"),
     cst_html=caml_string_of_jsbytes("html"),
     cst_click=caml_string_of_jsbytes("click"),
     cst_copy=caml_string_of_jsbytes("copy"),
     cst_cut=caml_string_of_jsbytes("cut"),
     cst_paste=caml_string_of_jsbytes("paste"),
     cst_dblclick=caml_string_of_jsbytes("dblclick"),
     cst_mousedown=caml_string_of_jsbytes("mousedown"),
     cst_mouseup=caml_string_of_jsbytes("mouseup"),
     cst_mouseover=caml_string_of_jsbytes("mouseover"),
     cst_mousemove=caml_string_of_jsbytes("mousemove"),
     cst_mouseout=caml_string_of_jsbytes("mouseout"),
     cst_keypress=caml_string_of_jsbytes("keypress"),
     cst_keydown=caml_string_of_jsbytes("keydown"),
     cst_keyup=caml_string_of_jsbytes("keyup"),
     cst_mousewheel=caml_string_of_jsbytes("mousewheel"),
     cst_DOMMouseScroll=caml_string_of_jsbytes("DOMMouseScroll"),
     cst_touchstart=caml_string_of_jsbytes("touchstart"),
     cst_touchmove=caml_string_of_jsbytes("touchmove"),
     cst_touchend=caml_string_of_jsbytes("touchend"),
     cst_touchcancel=caml_string_of_jsbytes("touchcancel"),
     cst_dragstart=caml_string_of_jsbytes("dragstart"),
     cst_dragend=caml_string_of_jsbytes("dragend"),
     cst_dragenter=caml_string_of_jsbytes("dragenter"),
     cst_dragover=caml_string_of_jsbytes("dragover"),
     cst_dragleave=caml_string_of_jsbytes("dragleave"),
     cst_drag=caml_string_of_jsbytes("drag"),
     cst_drop=caml_string_of_jsbytes("drop"),
     cst_hashchange=caml_string_of_jsbytes("hashchange"),
     cst_change=caml_string_of_jsbytes("change"),
     cst_input=caml_string_of_jsbytes("input"),
     cst_timeupdate=caml_string_of_jsbytes("timeupdate"),
     cst_submit=caml_string_of_jsbytes("submit"),
     cst_scroll=caml_string_of_jsbytes("scroll"),
     cst_focus=caml_string_of_jsbytes("focus"),
     cst_blur=caml_string_of_jsbytes("blur"),
     cst_load$0=caml_string_of_jsbytes("load"),
     cst_unload=caml_string_of_jsbytes("unload"),
     cst_beforeunload=caml_string_of_jsbytes("beforeunload"),
     cst_resize=caml_string_of_jsbytes("resize"),
     cst_orientationchange=caml_string_of_jsbytes("orientationchange"),
     cst_popstate=caml_string_of_jsbytes("popstate"),
     cst_error$0=caml_string_of_jsbytes("error"),
     cst_abort$0=caml_string_of_jsbytes("abort"),
     cst_select=caml_string_of_jsbytes("select"),
     cst_online=caml_string_of_jsbytes("online"),
     cst_offline=caml_string_of_jsbytes("offline"),
     cst_checking=caml_string_of_jsbytes("checking"),
     cst_noupdate=caml_string_of_jsbytes("noupdate"),
     cst_downloading=caml_string_of_jsbytes("downloading"),
     cst_progress$0=caml_string_of_jsbytes("progress"),
     cst_updateready=caml_string_of_jsbytes("updateready"),
     cst_cached=caml_string_of_jsbytes("cached"),
     cst_obsolete=caml_string_of_jsbytes("obsolete"),
     cst_DOMContentLoaded=caml_string_of_jsbytes("DOMContentLoaded"),
     cst_animationstart=caml_string_of_jsbytes("animationstart"),
     cst_animationend=caml_string_of_jsbytes("animationend"),
     cst_animationiteration=caml_string_of_jsbytes("animationiteration"),
     cst_animationcancel=caml_string_of_jsbytes("animationcancel"),
     cst_canplay=caml_string_of_jsbytes("canplay"),
     cst_canplaythrough=caml_string_of_jsbytes("canplaythrough"),
     cst_durationchange=caml_string_of_jsbytes("durationchange"),
     cst_emptied=caml_string_of_jsbytes("emptied"),
     cst_ended=caml_string_of_jsbytes("ended"),
     cst_gotpointercapture=caml_string_of_jsbytes("gotpointercapture"),
     cst_loadeddata=caml_string_of_jsbytes("loadeddata"),
     cst_loadedmetadata=caml_string_of_jsbytes("loadedmetadata"),
     cst_loadstart$0=caml_string_of_jsbytes("loadstart"),
     cst_lostpointercapture=caml_string_of_jsbytes("lostpointercapture"),
     cst_pause=caml_string_of_jsbytes("pause"),
     cst_play=caml_string_of_jsbytes("play"),
     cst_playing=caml_string_of_jsbytes("playing"),
     cst_pointerenter=caml_string_of_jsbytes("pointerenter"),
     cst_pointercancel=caml_string_of_jsbytes("pointercancel"),
     cst_pointerdown=caml_string_of_jsbytes("pointerdown"),
     cst_pointerleave=caml_string_of_jsbytes("pointerleave"),
     cst_pointermove=caml_string_of_jsbytes("pointermove"),
     cst_pointerout=caml_string_of_jsbytes("pointerout"),
     cst_pointerover=caml_string_of_jsbytes("pointerover"),
     cst_pointerup=caml_string_of_jsbytes("pointerup"),
     cst_ratechange=caml_string_of_jsbytes("ratechange"),
     cst_seeked=caml_string_of_jsbytes("seeked"),
     cst_seeking=caml_string_of_jsbytes("seeking"),
     cst_stalled=caml_string_of_jsbytes("stalled"),
     cst_suspend=caml_string_of_jsbytes("suspend"),
     cst_volumechange=caml_string_of_jsbytes("volumechange"),
     cst_waiting=caml_string_of_jsbytes("waiting"),
     cst_Js_of_ocaml_Dom_html_Canva=
      caml_string_of_jsbytes("Js_of_ocaml__Dom_html.Canvas_not_available"),
     cst_checkbox=caml_string_of_jsbytes("checkbox"),
     cst_file=caml_string_of_jsbytes("file"),
     cst_password=caml_string_of_jsbytes("password"),
     cst_radio=caml_string_of_jsbytes("radio"),
     cst_reset=caml_string_of_jsbytes("reset"),
     cst_submit$0=caml_string_of_jsbytes("submit"),
     cst_text=caml_string_of_jsbytes("text"),
     cst_readystatechange=caml_string_of_jsbytes("readystatechange"),
     cst_loadstart$1=caml_string_of_jsbytes("loadstart"),
     cst_progress$1=caml_string_of_jsbytes("progress"),
     cst_abort$1=caml_string_of_jsbytes("abort"),
     cst_error$1=caml_string_of_jsbytes("error"),
     cst_load$1=caml_string_of_jsbytes("load"),
     cst_timeout=caml_string_of_jsbytes("timeout"),
     cst_loadend$0=caml_string_of_jsbytes("loadend"),
     cst_Worker_onmessage_is_undefi$0=
      caml_string_of_jsbytes("Worker.onmessage is undefined"),
     cst_Worker_onmessage_is_undefi=
      caml_string_of_jsbytes("Worker.onmessage is undefined"),
     cst_Worker_import_scripts_is_u=
      caml_string_of_jsbytes("Worker.import_scripts is undefined"),
     cst_webglcontextlost=caml_string_of_jsbytes("webglcontextlost"),
     cst_webglcontextrestored=caml_string_of_jsbytes("webglcontextrestored"),
     cst_webglcontextcreationerror=
      caml_string_of_jsbytes("webglcontextcreationerror"),
     cst_g=caml_string_of_jsbytes("g"),
     cst=caml_string_of_jsbytes("[\\][()\\\\|+*.?{}^$]"),
     cst$37=caml_string_of_jsbytes(""),
     cst$13=caml_string_of_jsbytes(""),
     cst$21=caml_string_of_jsbytes(""),
     cst$14=caml_string_of_jsbytes("#"),
     cst$15=caml_string_of_jsbytes("?"),
     cst$20=caml_string_of_jsbytes(""),
     cst$16=caml_string_of_jsbytes("/"),
     cst$17=caml_string_of_jsbytes("/"),
     cst$19=caml_string_of_jsbytes(":"),
     cst$18=caml_string_of_jsbytes(""),
     cst_http$1=caml_string_of_jsbytes("http://"),
     cst$22=caml_string_of_jsbytes(""),
     cst$30=caml_string_of_jsbytes(""),
     cst$23=caml_string_of_jsbytes("#"),
     cst$24=caml_string_of_jsbytes("?"),
     cst$29=caml_string_of_jsbytes(""),
     cst$25=caml_string_of_jsbytes("/"),
     cst$26=caml_string_of_jsbytes("/"),
     cst$28=caml_string_of_jsbytes(":"),
     cst$27=caml_string_of_jsbytes(""),
     cst_https$1=caml_string_of_jsbytes("https://"),
     cst$31=caml_string_of_jsbytes(""),
     cst$36=caml_string_of_jsbytes(""),
     cst$32=caml_string_of_jsbytes("#"),
     cst$33=caml_string_of_jsbytes("?"),
     cst$35=caml_string_of_jsbytes(""),
     cst$34=caml_string_of_jsbytes("/"),
     cst_file$2=caml_string_of_jsbytes("file://"),
     cst$12=caml_string_of_jsbytes(""),
     cst$11=caml_string_of_jsbytes(""),
     cst$10=caml_string_of_jsbytes(""),
     cst$9=caml_string_of_jsbytes(""),
     cst$8=caml_string_of_jsbytes(""),
     cst$7=caml_string_of_jsbytes(""),
     cst$6=caml_string_of_jsbytes(""),
     cst$4=caml_string_of_jsbytes("="),
     cst$5=caml_string_of_jsbytes("&"),
     cst$2=caml_string_of_jsbytes(""),
     cst$3=caml_string_of_jsbytes(""),
     cst_file$0=caml_string_of_jsbytes("file"),
     cst_file$1=caml_string_of_jsbytes("file:"),
     cst_http=caml_string_of_jsbytes("http"),
     cst_http$0=caml_string_of_jsbytes("http:"),
     cst_https=caml_string_of_jsbytes("https"),
     cst_https$0=caml_string_of_jsbytes("https:"),
     cst$1=caml_string_of_jsbytes(" "),
     cst_2B=caml_string_of_jsbytes("%2B"),
     cst_Js_of_ocaml_Url_Local_exn=
      caml_string_of_jsbytes("Js_of_ocaml__Url.Local_exn"),
     cst$0=caml_string_of_jsbytes("+"),
     cst_Js_of_ocaml_Url_Not_an_htt=
      caml_string_of_jsbytes("Js_of_ocaml__Url.Not_an_http_protocol"),
     cst_Hh_Tt_Tt_Pp_Ss_0_9a_zA_Z_0=
      caml_string_of_jsbytes
       ("^([Hh][Tt][Tt][Pp][Ss]?)://([0-9a-zA-Z.-]+|\\[[0-9a-zA-Z.-]+\\]|\\[[0-9A-Fa-f:.]+\\])?(:([0-9]+))?(/([^\\?#]*)(\\?([^#]*))?(#(.*))?)?$"),
     cst_Ff_Ii_Ll_Ee=
      caml_string_of_jsbytes
       ("^([Ff][Ii][Ll][Ee])://([^\\?#]*)(\\?([^#]*))?(#(.*))?$"),
     s=caml_string_of_jsbytes("3.9.0"),
     git_version=caml_string_of_jsbytes(""),
     cst$38=caml_string_of_jsbytes(""),
     cst$41=caml_string_of_jsbytes("+"),
     cst_Jstable_keys=caml_string_of_jsbytes("Jstable.keys"),
     dummy_string=caml_string_of_jsbytes(""),
     dummy_int64=runtime.caml_int64_create_lo_mi_hi(1,0,0),
     cst_is_not_a_valid_length$0=
      caml_string_of_jsbytes(" is not a valid length"),
     cst_d_d_deg_grad_rad_turns=
      caml_string_of_jsbytes("^(\\d*(?:\\.\\d*))(deg|grad|rad|turns)$"),
     cst_length_conversion_error$0=
      caml_string_of_jsbytes("length conversion error: "),
     cst_deg$0=caml_string_of_jsbytes("deg"),
     cst_grad$0=caml_string_of_jsbytes("grad"),
     cst_rad$0=caml_string_of_jsbytes("rad"),
     cst_turns$0=caml_string_of_jsbytes("turns"),
     cst_deg=caml_string_of_jsbytes("deg"),
     cst_grad=caml_string_of_jsbytes("grad"),
     cst_rad=caml_string_of_jsbytes("rad"),
     cst_turns=caml_string_of_jsbytes("turns"),
     cst_is_not_a_valid_length=
      caml_string_of_jsbytes(" is not a valid length"),
     cst_0$0=caml_string_of_jsbytes("0"),
     cst_d_d_s_S=caml_string_of_jsbytes("^(\\d*(?:\\.\\d*)?)\\s*(\\S*)$"),
     cst_length_conversion_error=
      caml_string_of_jsbytes("length conversion error: "),
     cst_pc$0=caml_string_of_jsbytes("pc"),
     cst_ch$0=caml_string_of_jsbytes("ch"),
     cst_cm$0=caml_string_of_jsbytes("cm"),
     cst_em$1=caml_string_of_jsbytes("em"),
     cst_ex$0=caml_string_of_jsbytes("ex"),
     cst_gd$0=caml_string_of_jsbytes("gd"),
     cst_in$0=caml_string_of_jsbytes("in"),
     cst_mm$0=caml_string_of_jsbytes("mm"),
     cst_pt$0=caml_string_of_jsbytes("pt"),
     cst_px$0=caml_string_of_jsbytes("px"),
     cst_rem$0=caml_string_of_jsbytes("rem"),
     cst_vh$0=caml_string_of_jsbytes("vh"),
     cst_vm$0=caml_string_of_jsbytes("vm"),
     cst_vw$0=caml_string_of_jsbytes("vw"),
     cst_0=caml_string_of_jsbytes("0"),
     cst_em$0=caml_string_of_jsbytes("em"),
     cst_ex=caml_string_of_jsbytes("ex"),
     cst_px=caml_string_of_jsbytes("px"),
     cst_gd=caml_string_of_jsbytes("gd"),
     cst_rem=caml_string_of_jsbytes("rem"),
     cst_vw=caml_string_of_jsbytes("vw"),
     cst_vh=caml_string_of_jsbytes("vh"),
     cst_vm=caml_string_of_jsbytes("vm"),
     cst_ch=caml_string_of_jsbytes("ch"),
     cst_mm=caml_string_of_jsbytes("mm"),
     cst_cm=caml_string_of_jsbytes("cm"),
     cst_in=caml_string_of_jsbytes("in"),
     cst_pt=caml_string_of_jsbytes("pt"),
     cst_pc=caml_string_of_jsbytes("pc"),
     cst$40=caml_string_of_jsbytes("): "),
     cst_color_conversion_error$0=
      caml_string_of_jsbytes("color conversion error ("),
     cst$39=caml_string_of_jsbytes("): "),
     cst_color_conversion_error=
      caml_string_of_jsbytes("color conversion error ("),
     cst_is_not_a_valid_color$0=
      caml_string_of_jsbytes(" is not a valid color"),
     cst_rgba_d_d_d_d_d=
      caml_string_of_jsbytes
       ("(rgba?)\\((?:(\\d*),(\\d*),(\\d*)(?:,(\\d*(?:\\.\\d*)?))?)\\)"),
     cst_rgba_d_d_d_d_d$0=
      caml_string_of_jsbytes
       ("(rgba?)\\((?:(\\d*)%,(\\d*)%,(\\d*)%(?:,(\\d*(?:\\.\\d*)?))?)\\)"),
     cst_hsla_d_d_d_d_d=
      caml_string_of_jsbytes
       ("(hsla?)\\((?:(\\d*),(\\d*)%,(\\d*)%(?:,(\\d*(?:\\.\\d*)?))?)\\)"),
     cst_rgb=caml_string_of_jsbytes("rgb"),
     cst_rgba=caml_string_of_jsbytes("rgba"),
     cst_rgb$0=caml_string_of_jsbytes("rgb"),
     cst_rgba$0=caml_string_of_jsbytes("rgba"),
     cst_hsl=caml_string_of_jsbytes("hsl"),
     cst_hsla=caml_string_of_jsbytes("hsla"),
     cst_rgb_s_d_s_d_s_d=
      caml_string_of_jsbytes("^rgb\\(\\s*\\d*,\\s*\\d*,\\s*\\d*\\)$"),
     cst_rgb_s_d_s_d_s_d$0=
      caml_string_of_jsbytes("^rgb\\(\\s*\\d*%,\\s*\\d*%,\\s*\\d*%\\)$"),
     cst_rgba_s_d_s_d_s_d_d_d=
      caml_string_of_jsbytes
       ("^rgba\\(\\s*\\d*,\\s*\\d*,\\s*\\d*,\\d*\\.?\\d*\\)$"),
     cst_rgba_s_d_s_d_s_d_d_d$0=
      caml_string_of_jsbytes
       ("^rgba\\(\\s*\\d*%,\\s*\\d*%,\\s*\\d*%,\\d*\\.?\\d*\\)$"),
     cst_hsl_s_d_s_d_s_d=
      caml_string_of_jsbytes("^hsl\\(\\s*\\d*,\\s*\\d*%,\\s*\\d*%\\)$"),
     cst_hsla_s_d_s_d_s_d_d_d=
      caml_string_of_jsbytes
       ("^hsla\\(\\s*\\d*,\\s*\\d*%,\\s*\\d*%,\\d*\\.?\\d*\\)$"),
     cst_is_not_a_valid_color=caml_string_of_jsbytes(" is not a valid color"),
     cst_is_out_of_valid_range=
      caml_string_of_jsbytes(" is out of valid range"),
     partial=[8,[0,0,0],0,0,[12,41,0]],
     partial$0=[12,41,0],
     partial$1=[0,0,0],
     cst_lightgrey$0=caml_string_of_jsbytes("lightgrey"),
     cst_darkslategray$0=caml_string_of_jsbytes("darkslategray"),
     cst_cornsilk$0=caml_string_of_jsbytes("cornsilk"),
     cst_blue$0=caml_string_of_jsbytes("blue"),
     cst_aliceblue$0=caml_string_of_jsbytes("aliceblue"),
     cst_antiquewhite$0=caml_string_of_jsbytes("antiquewhite"),
     cst_aqua$0=caml_string_of_jsbytes("aqua"),
     cst_aquamarine$0=caml_string_of_jsbytes("aquamarine"),
     cst_azure$0=caml_string_of_jsbytes("azure"),
     cst_beige$0=caml_string_of_jsbytes("beige"),
     cst_bisque$0=caml_string_of_jsbytes("bisque"),
     cst_black$0=caml_string_of_jsbytes("black"),
     cst_blanchedalmond$0=caml_string_of_jsbytes("blanchedalmond"),
     cst_blueviolet$0=caml_string_of_jsbytes("blueviolet"),
     cst_brown$0=caml_string_of_jsbytes("brown"),
     cst_burlywood$0=caml_string_of_jsbytes("burlywood"),
     cst_cadetblue$0=caml_string_of_jsbytes("cadetblue"),
     cst_chartreuse$0=caml_string_of_jsbytes("chartreuse"),
     cst_chocolate$0=caml_string_of_jsbytes("chocolate"),
     cst_coral$0=caml_string_of_jsbytes("coral"),
     cst_cornflowerblue$0=caml_string_of_jsbytes("cornflowerblue"),
     cst_darkkhaki$0=caml_string_of_jsbytes("darkkhaki"),
     cst_crimson$0=caml_string_of_jsbytes("crimson"),
     cst_cyan$0=caml_string_of_jsbytes("cyan"),
     cst_darkblue$0=caml_string_of_jsbytes("darkblue"),
     cst_darkcyan$0=caml_string_of_jsbytes("darkcyan"),
     cst_darkgoldenrod$0=caml_string_of_jsbytes("darkgoldenrod"),
     cst_darkgray$0=caml_string_of_jsbytes("darkgray"),
     cst_darkgreen$0=caml_string_of_jsbytes("darkgreen"),
     cst_darkgrey$0=caml_string_of_jsbytes("darkgrey"),
     cst_darkmagenta$0=caml_string_of_jsbytes("darkmagenta"),
     cst_darkolivegreen$0=caml_string_of_jsbytes("darkolivegreen"),
     cst_darkorange$0=caml_string_of_jsbytes("darkorange"),
     cst_darkorchid$0=caml_string_of_jsbytes("darkorchid"),
     cst_darkred$0=caml_string_of_jsbytes("darkred"),
     cst_darksalmon$0=caml_string_of_jsbytes("darksalmon"),
     cst_darkseagreen$0=caml_string_of_jsbytes("darkseagreen"),
     cst_darkslateblue$0=caml_string_of_jsbytes("darkslateblue"),
     cst_greenyellow$0=caml_string_of_jsbytes("greenyellow"),
     cst_floralwhite$0=caml_string_of_jsbytes("floralwhite"),
     cst_darkslategrey$0=caml_string_of_jsbytes("darkslategrey"),
     cst_darkturquoise$0=caml_string_of_jsbytes("darkturquoise"),
     cst_darkviolet$0=caml_string_of_jsbytes("darkviolet"),
     cst_deeppink$0=caml_string_of_jsbytes("deeppink"),
     cst_deepskyblue$0=caml_string_of_jsbytes("deepskyblue"),
     cst_dimgray$0=caml_string_of_jsbytes("dimgray"),
     cst_dimgrey$0=caml_string_of_jsbytes("dimgrey"),
     cst_dodgerblue$0=caml_string_of_jsbytes("dodgerblue"),
     cst_firebrick$0=caml_string_of_jsbytes("firebrick"),
     cst_forestgreen$0=caml_string_of_jsbytes("forestgreen"),
     cst_fuchsia$0=caml_string_of_jsbytes("fuchsia"),
     cst_gainsboro$0=caml_string_of_jsbytes("gainsboro"),
     cst_ghostwhite$0=caml_string_of_jsbytes("ghostwhite"),
     cst_gold$0=caml_string_of_jsbytes("gold"),
     cst_goldenrod$0=caml_string_of_jsbytes("goldenrod"),
     cst_gray$0=caml_string_of_jsbytes("gray"),
     cst_green$0=caml_string_of_jsbytes("green"),
     cst_lavenderblush$0=caml_string_of_jsbytes("lavenderblush"),
     cst_grey$0=caml_string_of_jsbytes("grey"),
     cst_honeydew$0=caml_string_of_jsbytes("honeydew"),
     cst_hotpink$0=caml_string_of_jsbytes("hotpink"),
     cst_indianred$0=caml_string_of_jsbytes("indianred"),
     cst_indigo$0=caml_string_of_jsbytes("indigo"),
     cst_ivory$0=caml_string_of_jsbytes("ivory"),
     cst_khaki$0=caml_string_of_jsbytes("khaki"),
     cst_lavender$0=caml_string_of_jsbytes("lavender"),
     cst_lawngreen$0=caml_string_of_jsbytes("lawngreen"),
     cst_lemonchiffon$0=caml_string_of_jsbytes("lemonchiffon"),
     cst_lightblue$0=caml_string_of_jsbytes("lightblue"),
     cst_lightcoral$0=caml_string_of_jsbytes("lightcoral"),
     cst_lightcyan$0=caml_string_of_jsbytes("lightcyan"),
     cst_lightgoldenrodyellow$0=caml_string_of_jsbytes("lightgoldenrodyellow"),
     cst_lightgray$0=caml_string_of_jsbytes("lightgray"),
     cst_lightgreen$0=caml_string_of_jsbytes("lightgreen"),
     cst_paleturquoise$0=caml_string_of_jsbytes("paleturquoise"),
     cst_mediumslateblue$0=caml_string_of_jsbytes("mediumslateblue"),
     cst_limegreen$0=caml_string_of_jsbytes("limegreen"),
     cst_lightpink$0=caml_string_of_jsbytes("lightpink"),
     cst_lightsalmon$0=caml_string_of_jsbytes("lightsalmon"),
     cst_lightseagreen$0=caml_string_of_jsbytes("lightseagreen"),
     cst_lightskyblue$0=caml_string_of_jsbytes("lightskyblue"),
     cst_lightslategray$0=caml_string_of_jsbytes("lightslategray"),
     cst_lightslategrey$0=caml_string_of_jsbytes("lightslategrey"),
     cst_lightsteelblue$0=caml_string_of_jsbytes("lightsteelblue"),
     cst_lightyellow$0=caml_string_of_jsbytes("lightyellow"),
     cst_lime$0=caml_string_of_jsbytes("lime"),
     cst_linen$0=caml_string_of_jsbytes("linen"),
     cst_magenta$0=caml_string_of_jsbytes("magenta"),
     cst_maroon$0=caml_string_of_jsbytes("maroon"),
     cst_mediumaquamarine$0=caml_string_of_jsbytes("mediumaquamarine"),
     cst_mediumblue$0=caml_string_of_jsbytes("mediumblue"),
     cst_mediumorchid$0=caml_string_of_jsbytes("mediumorchid"),
     cst_mediumpurple$0=caml_string_of_jsbytes("mediumpurple"),
     cst_mediumseagreen$0=caml_string_of_jsbytes("mediumseagreen"),
     cst_navy$0=caml_string_of_jsbytes("navy"),
     cst_mediumspringgreen$0=caml_string_of_jsbytes("mediumspringgreen"),
     cst_mediumturquoise$0=caml_string_of_jsbytes("mediumturquoise"),
     cst_mediumvioletred$0=caml_string_of_jsbytes("mediumvioletred"),
     cst_midnightblue$0=caml_string_of_jsbytes("midnightblue"),
     cst_mintcream$0=caml_string_of_jsbytes("mintcream"),
     cst_mistyrose$0=caml_string_of_jsbytes("mistyrose"),
     cst_moccasin$0=caml_string_of_jsbytes("moccasin"),
     cst_navajowhite$0=caml_string_of_jsbytes("navajowhite"),
     cst_oldlace$0=caml_string_of_jsbytes("oldlace"),
     cst_olive$0=caml_string_of_jsbytes("olive"),
     cst_olivedrab$0=caml_string_of_jsbytes("olivedrab"),
     cst_orange$0=caml_string_of_jsbytes("orange"),
     cst_orangered$0=caml_string_of_jsbytes("orangered"),
     cst_orchid$0=caml_string_of_jsbytes("orchid"),
     cst_palegoldenrod$0=caml_string_of_jsbytes("palegoldenrod"),
     cst_palegreen$0=caml_string_of_jsbytes("palegreen"),
     cst_skyblue$0=caml_string_of_jsbytes("skyblue"),
     cst_rosybrown$0=caml_string_of_jsbytes("rosybrown"),
     cst_palevioletred$0=caml_string_of_jsbytes("palevioletred"),
     cst_papayawhip$0=caml_string_of_jsbytes("papayawhip"),
     cst_peachpuff$0=caml_string_of_jsbytes("peachpuff"),
     cst_peru$0=caml_string_of_jsbytes("peru"),
     cst_pink$0=caml_string_of_jsbytes("pink"),
     cst_plum$0=caml_string_of_jsbytes("plum"),
     cst_powderblue$0=caml_string_of_jsbytes("powderblue"),
     cst_purple$0=caml_string_of_jsbytes("purple"),
     cst_red$0=caml_string_of_jsbytes("red"),
     cst_royalblue$0=caml_string_of_jsbytes("royalblue"),
     cst_saddlebrown$0=caml_string_of_jsbytes("saddlebrown"),
     cst_salmon$0=caml_string_of_jsbytes("salmon"),
     cst_sandybrown$0=caml_string_of_jsbytes("sandybrown"),
     cst_seagreen$0=caml_string_of_jsbytes("seagreen"),
     cst_seashell$0=caml_string_of_jsbytes("seashell"),
     cst_sienna$0=caml_string_of_jsbytes("sienna"),
     cst_silver$0=caml_string_of_jsbytes("silver"),
     cst_thistle$0=caml_string_of_jsbytes("thistle"),
     cst_slateblue$0=caml_string_of_jsbytes("slateblue"),
     cst_slategray$0=caml_string_of_jsbytes("slategray"),
     cst_slategrey$0=caml_string_of_jsbytes("slategrey"),
     cst_snow$0=caml_string_of_jsbytes("snow"),
     cst_springgreen$0=caml_string_of_jsbytes("springgreen"),
     cst_steelblue$0=caml_string_of_jsbytes("steelblue"),
     cst_tan$0=caml_string_of_jsbytes("tan"),
     cst_teal$0=caml_string_of_jsbytes("teal"),
     cst_tomato$0=caml_string_of_jsbytes("tomato"),
     cst_turquoise$0=caml_string_of_jsbytes("turquoise"),
     cst_violet$0=caml_string_of_jsbytes("violet"),
     cst_wheat$0=caml_string_of_jsbytes("wheat"),
     cst_white$0=caml_string_of_jsbytes("white"),
     cst_whitesmoke$0=caml_string_of_jsbytes("whitesmoke"),
     cst_yellow$0=caml_string_of_jsbytes("yellow"),
     cst_yellowgreen$0=caml_string_of_jsbytes("yellowgreen"),
     cst_is_not_a_valid_color_name=
      caml_string_of_jsbytes(" is not a valid color name"),
     cst_aliceblue=caml_string_of_jsbytes("aliceblue"),
     cst_antiquewhite=caml_string_of_jsbytes("antiquewhite"),
     cst_aqua=caml_string_of_jsbytes("aqua"),
     cst_aquamarine=caml_string_of_jsbytes("aquamarine"),
     cst_azure=caml_string_of_jsbytes("azure"),
     cst_beige=caml_string_of_jsbytes("beige"),
     cst_bisque=caml_string_of_jsbytes("bisque"),
     cst_black=caml_string_of_jsbytes("black"),
     cst_blanchedalmond=caml_string_of_jsbytes("blanchedalmond"),
     cst_blue=caml_string_of_jsbytes("blue"),
     cst_blueviolet=caml_string_of_jsbytes("blueviolet"),
     cst_brown=caml_string_of_jsbytes("brown"),
     cst_burlywood=caml_string_of_jsbytes("burlywood"),
     cst_cadetblue=caml_string_of_jsbytes("cadetblue"),
     cst_chartreuse=caml_string_of_jsbytes("chartreuse"),
     cst_chocolate=caml_string_of_jsbytes("chocolate"),
     cst_coral=caml_string_of_jsbytes("coral"),
     cst_cornflowerblue=caml_string_of_jsbytes("cornflowerblue"),
     cst_cornsilk=caml_string_of_jsbytes("cornsilk"),
     cst_crimson=caml_string_of_jsbytes("crimson"),
     cst_cyan=caml_string_of_jsbytes("cyan"),
     cst_darkblue=caml_string_of_jsbytes("darkblue"),
     cst_darkcyan=caml_string_of_jsbytes("darkcyan"),
     cst_darkgoldenrod=caml_string_of_jsbytes("darkgoldenrod"),
     cst_darkgray=caml_string_of_jsbytes("darkgray"),
     cst_darkgreen=caml_string_of_jsbytes("darkgreen"),
     cst_darkgrey=caml_string_of_jsbytes("darkgrey"),
     cst_darkkhaki=caml_string_of_jsbytes("darkkhaki"),
     cst_darkmagenta=caml_string_of_jsbytes("darkmagenta"),
     cst_darkolivegreen=caml_string_of_jsbytes("darkolivegreen"),
     cst_darkorange=caml_string_of_jsbytes("darkorange"),
     cst_darkorchid=caml_string_of_jsbytes("darkorchid"),
     cst_darkred=caml_string_of_jsbytes("darkred"),
     cst_darksalmon=caml_string_of_jsbytes("darksalmon"),
     cst_darkseagreen=caml_string_of_jsbytes("darkseagreen"),
     cst_darkslateblue=caml_string_of_jsbytes("darkslateblue"),
     cst_darkslategray=caml_string_of_jsbytes("darkslategray"),
     cst_darkslategrey=caml_string_of_jsbytes("darkslategrey"),
     cst_darkturquoise=caml_string_of_jsbytes("darkturquoise"),
     cst_darkviolet=caml_string_of_jsbytes("darkviolet"),
     cst_deeppink=caml_string_of_jsbytes("deeppink"),
     cst_deepskyblue=caml_string_of_jsbytes("deepskyblue"),
     cst_dimgray=caml_string_of_jsbytes("dimgray"),
     cst_dimgrey=caml_string_of_jsbytes("dimgrey"),
     cst_dodgerblue=caml_string_of_jsbytes("dodgerblue"),
     cst_firebrick=caml_string_of_jsbytes("firebrick"),
     cst_floralwhite=caml_string_of_jsbytes("floralwhite"),
     cst_forestgreen=caml_string_of_jsbytes("forestgreen"),
     cst_fuchsia=caml_string_of_jsbytes("fuchsia"),
     cst_gainsboro=caml_string_of_jsbytes("gainsboro"),
     cst_ghostwhite=caml_string_of_jsbytes("ghostwhite"),
     cst_gold=caml_string_of_jsbytes("gold"),
     cst_goldenrod=caml_string_of_jsbytes("goldenrod"),
     cst_gray=caml_string_of_jsbytes("gray"),
     cst_grey=caml_string_of_jsbytes("grey"),
     cst_green=caml_string_of_jsbytes("green"),
     cst_greenyellow=caml_string_of_jsbytes("greenyellow"),
     cst_honeydew=caml_string_of_jsbytes("honeydew"),
     cst_hotpink=caml_string_of_jsbytes("hotpink"),
     cst_indianred=caml_string_of_jsbytes("indianred"),
     cst_indigo=caml_string_of_jsbytes("indigo"),
     cst_ivory=caml_string_of_jsbytes("ivory"),
     cst_khaki=caml_string_of_jsbytes("khaki"),
     cst_lavender=caml_string_of_jsbytes("lavender"),
     cst_lavenderblush=caml_string_of_jsbytes("lavenderblush"),
     cst_lawngreen=caml_string_of_jsbytes("lawngreen"),
     cst_lemonchiffon=caml_string_of_jsbytes("lemonchiffon"),
     cst_lightblue=caml_string_of_jsbytes("lightblue"),
     cst_lightcoral=caml_string_of_jsbytes("lightcoral"),
     cst_lightcyan=caml_string_of_jsbytes("lightcyan"),
     cst_lightgoldenrodyellow=caml_string_of_jsbytes("lightgoldenrodyellow"),
     cst_lightgray=caml_string_of_jsbytes("lightgray"),
     cst_lightgreen=caml_string_of_jsbytes("lightgreen"),
     cst_lightgrey=caml_string_of_jsbytes("lightgrey"),
     cst_lightpink=caml_string_of_jsbytes("lightpink"),
     cst_lightsalmon=caml_string_of_jsbytes("lightsalmon"),
     cst_lightseagreen=caml_string_of_jsbytes("lightseagreen"),
     cst_lightskyblue=caml_string_of_jsbytes("lightskyblue"),
     cst_lightslategray=caml_string_of_jsbytes("lightslategray"),
     cst_lightslategrey=caml_string_of_jsbytes("lightslategrey"),
     cst_lightsteelblue=caml_string_of_jsbytes("lightsteelblue"),
     cst_lightyellow=caml_string_of_jsbytes("lightyellow"),
     cst_lime=caml_string_of_jsbytes("lime"),
     cst_limegreen=caml_string_of_jsbytes("limegreen"),
     cst_linen=caml_string_of_jsbytes("linen"),
     cst_magenta=caml_string_of_jsbytes("magenta"),
     cst_maroon=caml_string_of_jsbytes("maroon"),
     cst_mediumaquamarine=caml_string_of_jsbytes("mediumaquamarine"),
     cst_mediumblue=caml_string_of_jsbytes("mediumblue"),
     cst_mediumorchid=caml_string_of_jsbytes("mediumorchid"),
     cst_mediumpurple=caml_string_of_jsbytes("mediumpurple"),
     cst_mediumseagreen=caml_string_of_jsbytes("mediumseagreen"),
     cst_mediumslateblue=caml_string_of_jsbytes("mediumslateblue"),
     cst_mediumspringgreen=caml_string_of_jsbytes("mediumspringgreen"),
     cst_mediumturquoise=caml_string_of_jsbytes("mediumturquoise"),
     cst_mediumvioletred=caml_string_of_jsbytes("mediumvioletred"),
     cst_midnightblue=caml_string_of_jsbytes("midnightblue"),
     cst_mintcream=caml_string_of_jsbytes("mintcream"),
     cst_mistyrose=caml_string_of_jsbytes("mistyrose"),
     cst_moccasin=caml_string_of_jsbytes("moccasin"),
     cst_navajowhite=caml_string_of_jsbytes("navajowhite"),
     cst_navy=caml_string_of_jsbytes("navy"),
     cst_oldlace=caml_string_of_jsbytes("oldlace"),
     cst_olive=caml_string_of_jsbytes("olive"),
     cst_olivedrab=caml_string_of_jsbytes("olivedrab"),
     cst_orange=caml_string_of_jsbytes("orange"),
     cst_orangered=caml_string_of_jsbytes("orangered"),
     cst_orchid=caml_string_of_jsbytes("orchid"),
     cst_palegoldenrod=caml_string_of_jsbytes("palegoldenrod"),
     cst_palegreen=caml_string_of_jsbytes("palegreen"),
     cst_paleturquoise=caml_string_of_jsbytes("paleturquoise"),
     cst_palevioletred=caml_string_of_jsbytes("palevioletred"),
     cst_papayawhip=caml_string_of_jsbytes("papayawhip"),
     cst_peachpuff=caml_string_of_jsbytes("peachpuff"),
     cst_peru=caml_string_of_jsbytes("peru"),
     cst_pink=caml_string_of_jsbytes("pink"),
     cst_plum=caml_string_of_jsbytes("plum"),
     cst_powderblue=caml_string_of_jsbytes("powderblue"),
     cst_purple=caml_string_of_jsbytes("purple"),
     cst_red=caml_string_of_jsbytes("red"),
     cst_rosybrown=caml_string_of_jsbytes("rosybrown"),
     cst_royalblue=caml_string_of_jsbytes("royalblue"),
     cst_saddlebrown=caml_string_of_jsbytes("saddlebrown"),
     cst_salmon=caml_string_of_jsbytes("salmon"),
     cst_sandybrown=caml_string_of_jsbytes("sandybrown"),
     cst_seagreen=caml_string_of_jsbytes("seagreen"),
     cst_seashell=caml_string_of_jsbytes("seashell"),
     cst_sienna=caml_string_of_jsbytes("sienna"),
     cst_silver=caml_string_of_jsbytes("silver"),
     cst_skyblue=caml_string_of_jsbytes("skyblue"),
     cst_slateblue=caml_string_of_jsbytes("slateblue"),
     cst_slategray=caml_string_of_jsbytes("slategray"),
     cst_slategrey=caml_string_of_jsbytes("slategrey"),
     cst_snow=caml_string_of_jsbytes("snow"),
     cst_springgreen=caml_string_of_jsbytes("springgreen"),
     cst_steelblue=caml_string_of_jsbytes("steelblue"),
     cst_tan=caml_string_of_jsbytes("tan"),
     cst_teal=caml_string_of_jsbytes("teal"),
     cst_thistle=caml_string_of_jsbytes("thistle"),
     cst_tomato=caml_string_of_jsbytes("tomato"),
     cst_turquoise=caml_string_of_jsbytes("turquoise"),
     cst_violet=caml_string_of_jsbytes("violet"),
     cst_wheat=caml_string_of_jsbytes("wheat"),
     cst_white=caml_string_of_jsbytes("white"),
     cst_whitesmoke=caml_string_of_jsbytes("whitesmoke"),
     cst_yellow=caml_string_of_jsbytes("yellow"),
     cst_yellowgreen=caml_string_of_jsbytes("yellowgreen"),
     cst_vkern$0=caml_string_of_jsbytes("vkern"),
     cst_view$0=caml_string_of_jsbytes("view"),
     cst_use$0=caml_string_of_jsbytes("use"),
     cst_tspan$0=caml_string_of_jsbytes("tspan"),
     cst_tref$0=caml_string_of_jsbytes("tref"),
     cst_title$3=caml_string_of_jsbytes("title"),
     cst_textpath$0=caml_string_of_jsbytes("textpath"),
     cst_text$1=caml_string_of_jsbytes("text"),
     cst_symbol$0=caml_string_of_jsbytes("symbol"),
     cst_switch$0=caml_string_of_jsbytes("switch"),
     cst_svg$0=caml_string_of_jsbytes("svg"),
     cst_style$3=caml_string_of_jsbytes("style"),
     cst_stop$0=caml_string_of_jsbytes("stop"),
     cst_set$0=caml_string_of_jsbytes("set"),
     cst_script$3=caml_string_of_jsbytes("script"),
     cst_rect$0=caml_string_of_jsbytes("rect"),
     cst_radialgradient$0=caml_string_of_jsbytes("radialgradient"),
     cst_polyline$0=caml_string_of_jsbytes("polyline"),
     cst_polygon$0=caml_string_of_jsbytes("polygon"),
     cst_pattern$0=caml_string_of_jsbytes("pattern"),
     cst_path$0=caml_string_of_jsbytes("path"),
     cst_mpath$0=caml_string_of_jsbytes("mpath"),
     cst_missing_glyph$0=caml_string_of_jsbytes("missing-glyph"),
     cst_metadata$0=caml_string_of_jsbytes("metadata"),
     cst_mask$0=caml_string_of_jsbytes("mask"),
     cst_lineargradient$0=caml_string_of_jsbytes("lineargradient"),
     cst_line$0=caml_string_of_jsbytes("line"),
     cst_image$0=caml_string_of_jsbytes("image"),
     cst_hkern$0=caml_string_of_jsbytes("hkern"),
     cst_glyphref$0=caml_string_of_jsbytes("glyphref"),
     cst_glyph$0=caml_string_of_jsbytes("glyph"),
     cst_g$1=caml_string_of_jsbytes("g"),
     cst_foreignobject=caml_string_of_jsbytes("foreignobject"),
     cst_font_face_uri$0=caml_string_of_jsbytes("font-face-uri"),
     cst_font_face_src$0=caml_string_of_jsbytes("font-face-src"),
     cst_font_face_name$0=caml_string_of_jsbytes("font-face-name"),
     cst_font_face_format$0=caml_string_of_jsbytes("font-face-format"),
     cst_font_face$0=caml_string_of_jsbytes("font-face"),
     cst_font$0=caml_string_of_jsbytes("font"),
     cst_filter$0=caml_string_of_jsbytes("filter"),
     cst_ellipse$0=caml_string_of_jsbytes("ellipse"),
     cst_desc$0=caml_string_of_jsbytes("desc"),
     cst_defs$0=caml_string_of_jsbytes("defs"),
     cst_cursor$0=caml_string_of_jsbytes("cursor"),
     cst_clippath$0=caml_string_of_jsbytes("clippath"),
     cst_circle$0=caml_string_of_jsbytes("circle"),
     cst_animatetransform$0=caml_string_of_jsbytes("animatetransform"),
     cst_animatemotion$0=caml_string_of_jsbytes("animatemotion"),
     cst_animatecolor$0=caml_string_of_jsbytes("animatecolor"),
     cst_animate$0=caml_string_of_jsbytes("animate"),
     cst_altglyphitem$0=caml_string_of_jsbytes("altglyphitem"),
     cst_altglyphdef$0=caml_string_of_jsbytes("altglyphdef"),
     cst_altglyph$0=caml_string_of_jsbytes("altglyph"),
     cst_a$3=caml_string_of_jsbytes("a"),
     cst_vkern=caml_string_of_jsbytes("vkern"),
     cst_view=caml_string_of_jsbytes("view"),
     cst_use=caml_string_of_jsbytes("use"),
     cst_tspan=caml_string_of_jsbytes("tspan"),
     cst_tref=caml_string_of_jsbytes("tref"),
     cst_title$2=caml_string_of_jsbytes("title"),
     cst_textpath=caml_string_of_jsbytes("textpath"),
     cst_text$0=caml_string_of_jsbytes("text"),
     cst_symbol=caml_string_of_jsbytes("symbol"),
     cst_switch=caml_string_of_jsbytes("switch"),
     cst_svg=caml_string_of_jsbytes("svg"),
     cst_style$2=caml_string_of_jsbytes("style"),
     cst_stop=caml_string_of_jsbytes("stop"),
     cst_set=caml_string_of_jsbytes("set"),
     cst_script$2=caml_string_of_jsbytes("script"),
     cst_rect=caml_string_of_jsbytes("rect"),
     cst_radialgradient=caml_string_of_jsbytes("radialgradient"),
     cst_polyline=caml_string_of_jsbytes("polyline"),
     cst_polygon=caml_string_of_jsbytes("polygon"),
     cst_pattern=caml_string_of_jsbytes("pattern"),
     cst_path=caml_string_of_jsbytes("path"),
     cst_mpath=caml_string_of_jsbytes("mpath"),
     cst_missing_glyph=caml_string_of_jsbytes("missing-glyph"),
     cst_metadata=caml_string_of_jsbytes("metadata"),
     cst_mask=caml_string_of_jsbytes("mask"),
     cst_lineargradient=caml_string_of_jsbytes("lineargradient"),
     cst_line=caml_string_of_jsbytes("line"),
     cst_image=caml_string_of_jsbytes("image"),
     cst_hkern=caml_string_of_jsbytes("hkern"),
     cst_glyphref=caml_string_of_jsbytes("glyphref"),
     cst_glyph=caml_string_of_jsbytes("glyph"),
     cst_g$0=caml_string_of_jsbytes("g"),
     cst_foreignObject=caml_string_of_jsbytes("foreignObject"),
     cst_font_face_uri=caml_string_of_jsbytes("font-face-uri"),
     cst_font_face_src=caml_string_of_jsbytes("font-face-src"),
     cst_font_face_name=caml_string_of_jsbytes("font-face-name"),
     cst_font_face_format=caml_string_of_jsbytes("font-face-format"),
     cst_font_face=caml_string_of_jsbytes("font-face"),
     cst_font=caml_string_of_jsbytes("font"),
     cst_filter=caml_string_of_jsbytes("filter"),
     cst_ellipse=caml_string_of_jsbytes("ellipse"),
     cst_desc=caml_string_of_jsbytes("desc"),
     cst_defs=caml_string_of_jsbytes("defs"),
     cst_cursor=caml_string_of_jsbytes("cursor"),
     cst_clippath=caml_string_of_jsbytes("clippath"),
     cst_circle=caml_string_of_jsbytes("circle"),
     cst_animatetransform=caml_string_of_jsbytes("animatetransform"),
     cst_animatemotion=caml_string_of_jsbytes("animatemotion"),
     cst_animatecolor=caml_string_of_jsbytes("animatecolor"),
     cst_animate=caml_string_of_jsbytes("animate"),
     cst_altglyphitem=caml_string_of_jsbytes("altglyphitem"),
     cst_altglyphdef=caml_string_of_jsbytes("altglyphdef"),
     cst_altglyph=caml_string_of_jsbytes("altglyph"),
     cst_a$2=caml_string_of_jsbytes("a"),
     cst_Js_of_ocaml_Dom_svg_SVGErr=
      caml_string_of_jsbytes("Js_of_ocaml__Dom_svg.SVGError"),
     Stdlib_string=global_data.Stdlib__string,
     Stdlib_char=global_data.Stdlib__char,
     Stdlib=global_data.Stdlib,
     Stdlib_callback=global_data.Stdlib__callback,
     Stdlib_printexc=global_data.Stdlib__printexc,
     Assert_failure=global_data.Assert_failure,
     Stdlib_list=global_data.Stdlib__list,
     Stdlib_array=global_data.Stdlib__array,
     Stdlib_uchar=global_data.Stdlib__uchar,
     Stdlib_printf=global_data.Stdlib__printf,
     Js_of_ocaml=[0];
    caml_register_global(1632,Js_of_ocaml,"Js_of_ocaml__");
    var
     Poly=[0],
     _f_=[0,caml_string_of_jsbytes("lib/js_of_ocaml/dom.ml"),351,67],
     _g_=[0,caml_string_of_jsbytes("transparent")],
     _h_=[0,caml_string_of_jsbytes("native")],
     _l_=[0,caml_string_of_jsbytes("lib/js_of_ocaml/dom_html.ml"),2816,58],
     _k_=[0,caml_string_of_jsbytes("lib/js_of_ocaml/dom_html.ml"),2815,61],
     _j_=
      [0,
       [11,
        caml_string_of_jsbytes("getElementById_exn: "),
        [3,0,[11,caml_string_of_jsbytes(" not found"),0]]],
       caml_string_of_jsbytes("getElementById_exn: %S not found")],
     _n_=[0,caml_string_of_jsbytes("lib/js_of_ocaml/form.ml"),177,13],
     _m_=[0,1],
     _o_=[0,caml_string_of_jsbytes("lib/js_of_ocaml/regexp.ml"),34,64],
     _p_=[0,caml_string_of_jsbytes(""),0],
     _cj_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _ck_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _cl_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _cm_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _b7_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _b8_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _b9_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _b__=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _b$_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _ca_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _cb_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _cc_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _cd_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _ce_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _cf_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _cg_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _ch_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _ci_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _b6_=
      caml_list_of_js_array
       ([caml_string_of_jsbytes("aliceblue"),
         caml_string_of_jsbytes("antiquewhite"),
         caml_string_of_jsbytes("aqua"),
         caml_string_of_jsbytes("aquamarine"),
         caml_string_of_jsbytes("azure"),
         caml_string_of_jsbytes("beige"),
         caml_string_of_jsbytes("bisque"),
         caml_string_of_jsbytes("black"),
         caml_string_of_jsbytes("blanchedalmond"),
         caml_string_of_jsbytes("blue"),
         caml_string_of_jsbytes("blueviolet"),
         caml_string_of_jsbytes("brown"),
         caml_string_of_jsbytes("burlywood"),
         caml_string_of_jsbytes("cadetblue"),
         caml_string_of_jsbytes("chartreuse"),
         caml_string_of_jsbytes("chocolate"),
         caml_string_of_jsbytes("coral"),
         caml_string_of_jsbytes("cornflowerblue"),
         caml_string_of_jsbytes("cornsilk"),
         caml_string_of_jsbytes("crimson"),
         caml_string_of_jsbytes("cyan"),
         caml_string_of_jsbytes("darkblue"),
         caml_string_of_jsbytes("darkcyan"),
         caml_string_of_jsbytes("darkgoldenrod"),
         caml_string_of_jsbytes("darkgray"),
         caml_string_of_jsbytes("darkgreen"),
         caml_string_of_jsbytes("darkgrey"),
         caml_string_of_jsbytes("darkkhaki"),
         caml_string_of_jsbytes("darkmagenta"),
         caml_string_of_jsbytes("darkolivegreen"),
         caml_string_of_jsbytes("darkorange"),
         caml_string_of_jsbytes("darkorchid"),
         caml_string_of_jsbytes("darkred"),
         caml_string_of_jsbytes("darksalmon"),
         caml_string_of_jsbytes("darkseagreen"),
         caml_string_of_jsbytes("darkslateblue"),
         caml_string_of_jsbytes("darkslategray"),
         caml_string_of_jsbytes("darkslategrey"),
         caml_string_of_jsbytes("darkturquoise"),
         caml_string_of_jsbytes("darkviolet"),
         caml_string_of_jsbytes("deeppink"),
         caml_string_of_jsbytes("deepskyblue"),
         caml_string_of_jsbytes("dimgray"),
         caml_string_of_jsbytes("dimgrey"),
         caml_string_of_jsbytes("dodgerblue"),
         caml_string_of_jsbytes("firebrick"),
         caml_string_of_jsbytes("floralwhite"),
         caml_string_of_jsbytes("forestgreen"),
         caml_string_of_jsbytes("fuchsia"),
         caml_string_of_jsbytes("gainsboro"),
         caml_string_of_jsbytes("ghostwhite"),
         caml_string_of_jsbytes("gold"),
         caml_string_of_jsbytes("goldenrod"),
         caml_string_of_jsbytes("gray"),
         caml_string_of_jsbytes("green"),
         caml_string_of_jsbytes("greenyellow"),
         caml_string_of_jsbytes("grey"),
         caml_string_of_jsbytes("honeydew"),
         caml_string_of_jsbytes("hotpink"),
         caml_string_of_jsbytes("indianred"),
         caml_string_of_jsbytes("indigo"),
         caml_string_of_jsbytes("ivory"),
         caml_string_of_jsbytes("khaki"),
         caml_string_of_jsbytes("lavender"),
         caml_string_of_jsbytes("lavenderblush"),
         caml_string_of_jsbytes("lawngreen"),
         caml_string_of_jsbytes("lemonchiffon"),
         caml_string_of_jsbytes("lightblue"),
         caml_string_of_jsbytes("lightcoral"),
         caml_string_of_jsbytes("lightcyan"),
         caml_string_of_jsbytes("lightgoldenrodyellow"),
         caml_string_of_jsbytes("lightgray"),
         caml_string_of_jsbytes("lightgreen"),
         caml_string_of_jsbytes("lightgrey"),
         caml_string_of_jsbytes("lightpink"),
         caml_string_of_jsbytes("lightsalmon"),
         caml_string_of_jsbytes("lightseagreen"),
         caml_string_of_jsbytes("lightskyblue"),
         caml_string_of_jsbytes("lightslategray"),
         caml_string_of_jsbytes("lightslategrey"),
         caml_string_of_jsbytes("lightsteelblue"),
         caml_string_of_jsbytes("lightyellow"),
         caml_string_of_jsbytes("lime"),
         caml_string_of_jsbytes("limegreen"),
         caml_string_of_jsbytes("linen"),
         caml_string_of_jsbytes("magenta"),
         caml_string_of_jsbytes("maroon"),
         caml_string_of_jsbytes("mediumaquamarine"),
         caml_string_of_jsbytes("mediumblue"),
         caml_string_of_jsbytes("mediumorchid"),
         caml_string_of_jsbytes("mediumpurple"),
         caml_string_of_jsbytes("mediumseagreen"),
         caml_string_of_jsbytes("mediumslateblue"),
         caml_string_of_jsbytes("mediumspringgreen"),
         caml_string_of_jsbytes("mediumturquoise"),
         caml_string_of_jsbytes("mediumvioletred"),
         caml_string_of_jsbytes("midnightblue"),
         caml_string_of_jsbytes("mintcream"),
         caml_string_of_jsbytes("mistyrose"),
         caml_string_of_jsbytes("moccasin"),
         caml_string_of_jsbytes("navajowhite"),
         caml_string_of_jsbytes("navy"),
         caml_string_of_jsbytes("oldlace"),
         caml_string_of_jsbytes("olive"),
         caml_string_of_jsbytes("olivedrab"),
         caml_string_of_jsbytes("orange"),
         caml_string_of_jsbytes("orangered"),
         caml_string_of_jsbytes("orchid"),
         caml_string_of_jsbytes("palegoldenrod"),
         caml_string_of_jsbytes("palegreen"),
         caml_string_of_jsbytes("paleturquoise"),
         caml_string_of_jsbytes("palevioletred"),
         caml_string_of_jsbytes("papayawhip"),
         caml_string_of_jsbytes("peachpuff"),
         caml_string_of_jsbytes("peru"),
         caml_string_of_jsbytes("pink"),
         caml_string_of_jsbytes("plum"),
         caml_string_of_jsbytes("powderblue"),
         caml_string_of_jsbytes("purple"),
         caml_string_of_jsbytes("red"),
         caml_string_of_jsbytes("rosybrown"),
         caml_string_of_jsbytes("royalblue"),
         caml_string_of_jsbytes("saddlebrown"),
         caml_string_of_jsbytes("salmon"),
         caml_string_of_jsbytes("sandybrown"),
         caml_string_of_jsbytes("seagreen"),
         caml_string_of_jsbytes("seashell"),
         caml_string_of_jsbytes("sienna"),
         caml_string_of_jsbytes("silver"),
         caml_string_of_jsbytes("skyblue"),
         caml_string_of_jsbytes("slateblue"),
         caml_string_of_jsbytes("slategray"),
         caml_string_of_jsbytes("slategrey"),
         caml_string_of_jsbytes("snow"),
         caml_string_of_jsbytes("springgreen"),
         caml_string_of_jsbytes("steelblue"),
         caml_string_of_jsbytes("tan"),
         caml_string_of_jsbytes("teal"),
         caml_string_of_jsbytes("thistle"),
         caml_string_of_jsbytes("tomato"),
         caml_string_of_jsbytes("turquoise"),
         caml_string_of_jsbytes("violet"),
         caml_string_of_jsbytes("wheat"),
         caml_string_of_jsbytes("white"),
         caml_string_of_jsbytes("whitesmoke"),
         caml_string_of_jsbytes("yellow"),
         caml_string_of_jsbytes("yellowgreen")]),
     _b5_=
      [0,
       [12,35,[4,8,[0,2,2],0,[4,8,[0,2,2],0,[4,8,[0,2,2],0,0]]]],
       caml_string_of_jsbytes("#%02X%02X%02X")],
     _bZ_=
      [0,
       [11,
        caml_string_of_jsbytes("rgb("),
        [4,0,0,0,[12,44,[4,0,0,0,[12,44,[4,0,0,0,[12,41,0]]]]]]],
       caml_string_of_jsbytes("rgb(%d,%d,%d)")],
     _b0_=
      [0,
       [11,
        caml_string_of_jsbytes("rgb("),
        [4,
         0,
         0,
         0,
         [12,37,[12,44,[4,0,0,0,[12,37,[12,44,[4,0,0,0,[12,37,[12,41,0]]]]]]]]]],
       caml_string_of_jsbytes("rgb(%d%%,%d%%,%d%%)")],
     _b1_=
      [0,
       [11,
        caml_string_of_jsbytes("rgba("),
        [4,
         0,
         0,
         0,
         [12,44,[4,0,0,0,[12,44,[4,0,0,0,[12,44,[8,[0,0,0],0,0,[12,41,0]]]]]]]]],
       caml_string_of_jsbytes("rgba(%d,%d,%d,%f)")],
     _b2_=
      [0,
       [11,
        caml_string_of_jsbytes("rgba("),
        [4,
         0,
         0,
         0,
         [12,
          37,
          [12,44,[4,0,0,0,[12,37,[12,44,[4,0,0,0,[12,37,[12,44,partial]]]]]]]]]],
       caml_string_of_jsbytes("rgba(%d%%,%d%%,%d%%,%f)")],
     _b3_=
      [0,
       [11,
        caml_string_of_jsbytes("hsl("),
        [4,
         0,
         0,
         0,
         [12,44,[4,0,0,0,[12,37,[12,44,[4,0,0,0,[12,37,[12,41,0]]]]]]]]],
       caml_string_of_jsbytes("hsl(%d,%d%%,%d%%)")],
     _b4_=
      [0,
       [11,
        caml_string_of_jsbytes("hsla("),
        [4,
         0,
         0,
         0,
         [12,
          44,
          [4,
           0,
           0,
           0,
           [12,
            37,
            [12,44,[4,0,0,0,[12,37,[12,44,[8,partial$1,0,0,partial$0]]]]]]]]]],
       caml_string_of_jsbytes("hsla(%d,%d%%,%d%%,%f)")],
     _w_=[0,240,248,255],
     _x_=[0,250,235,215],
     _y_=[0,0,255,255],
     _z_=[0,127,255,212],
     _A_=[0,240,255,255],
     _B_=[0,245,245,220],
     _C_=[0,255,228,196],
     _D_=[0,0,0,0],
     _E_=[0,255,235,205],
     _F_=[0,0,0,255],
     _G_=[0,138,43,226],
     _H_=[0,165,42,42],
     _I_=[0,222,184,135],
     _J_=[0,95,158,160],
     _K_=[0,127,255,0],
     _L_=[0,210,105,30],
     _M_=[0,255,127,80],
     _N_=[0,100,149,237],
     _O_=[0,255,248,220],
     _P_=[0,220,20,60],
     _Q_=[0,0,255,255],
     _R_=[0,0,0,139],
     _S_=[0,0,139,139],
     _T_=[0,184,134,11],
     _U_=[0,169,169,169],
     _V_=[0,0,100,0],
     _W_=[0,169,169,169],
     _X_=[0,189,183,107],
     _Y_=[0,139,0,139],
     _Z_=[0,85,107,47],
     ___=[0,255,140,0],
     _$_=[0,153,50,204],
     _aa_=[0,139,0,0],
     _ab_=[0,233,150,122],
     _ac_=[0,143,188,143],
     _ad_=[0,72,61,139],
     _ae_=[0,47,79,79],
     _af_=[0,47,79,79],
     _ag_=[0,0,206,209],
     _ah_=[0,148,0,211],
     _ai_=[0,255,20,147],
     _aj_=[0,0,191,255],
     _ak_=[0,105,105,105],
     _al_=[0,105,105,105],
     _am_=[0,30,144,255],
     _an_=[0,178,34,34],
     _ao_=[0,255,250,240],
     _ap_=[0,34,139,34],
     _aq_=[0,255,0,255],
     _ar_=[0,220,220,220],
     _as_=[0,248,248,255],
     _at_=[0,255,215,0],
     _au_=[0,218,165,32],
     _av_=[0,128,128,128],
     _aw_=[0,128,128,128],
     _ax_=[0,0,128,0],
     _ay_=[0,173,255,47],
     _az_=[0,240,255,240],
     _aA_=[0,255,105,180],
     _aB_=[0,205,92,92],
     _aC_=[0,75,0,130],
     _aD_=[0,255,255,240],
     _aE_=[0,240,230,140],
     _aF_=[0,230,230,250],
     _aG_=[0,255,240,245],
     _aH_=[0,124,252,0],
     _aI_=[0,255,250,205],
     _aJ_=[0,173,216,230],
     _aK_=[0,240,128,128],
     _aL_=[0,224,255,255],
     _aM_=[0,250,250,210],
     _aN_=[0,211,211,211],
     _aO_=[0,144,238,144],
     _aP_=[0,211,211,211],
     _aQ_=[0,255,182,193],
     _aR_=[0,255,160,122],
     _aS_=[0,32,178,170],
     _aT_=[0,135,206,250],
     _aU_=[0,119,136,153],
     _aV_=[0,119,136,153],
     _aW_=[0,176,196,222],
     _aX_=[0,255,255,224],
     _aY_=[0,0,255,0],
     _aZ_=[0,50,205,50],
     _a0_=[0,250,240,230],
     _a1_=[0,255,0,255],
     _a2_=[0,128,0,0],
     _a3_=[0,102,205,170],
     _a4_=[0,0,0,205],
     _a5_=[0,186,85,211],
     _a6_=[0,147,112,219],
     _a7_=[0,60,179,113],
     _a8_=[0,123,104,238],
     _a9_=[0,0,250,154],
     _a__=[0,72,209,204],
     _a$_=[0,199,21,133],
     _ba_=[0,25,25,112],
     _bb_=[0,245,255,250],
     _bc_=[0,255,228,225],
     _bd_=[0,255,228,181],
     _be_=[0,255,222,173],
     _bf_=[0,0,0,128],
     _bg_=[0,253,245,230],
     _bh_=[0,128,128,0],
     _bi_=[0,107,142,35],
     _bj_=[0,255,165,0],
     _bk_=[0,255,69,0],
     _bl_=[0,218,112,214],
     _bm_=[0,238,232,170],
     _bn_=[0,152,251,152],
     _bo_=[0,175,238,238],
     _bp_=[0,219,112,147],
     _bq_=[0,255,239,213],
     _br_=[0,255,218,185],
     _bs_=[0,205,133,63],
     _bt_=[0,255,192,203],
     _bu_=[0,221,160,221],
     _bv_=[0,176,224,230],
     _bw_=[0,128,0,128],
     _bx_=[0,255,0,0],
     _by_=[0,188,143,143],
     _bz_=[0,65,105,225],
     _bA_=[0,139,69,19],
     _bB_=[0,250,128,114],
     _bC_=[0,244,164,96],
     _bD_=[0,46,139,87],
     _bE_=[0,255,245,238],
     _bF_=[0,160,82,45],
     _bG_=[0,192,192,192],
     _bH_=[0,135,206,235],
     _bI_=[0,106,90,205],
     _bJ_=[0,112,128,144],
     _bK_=[0,112,128,144],
     _bL_=[0,255,250,250],
     _bM_=[0,0,255,127],
     _bN_=[0,70,130,180],
     _bO_=[0,210,180,140],
     _bP_=[0,0,128,128],
     _bQ_=[0,216,191,216],
     _bR_=[0,255,99,71],
     _bS_=[0,64,224,208],
     _bT_=[0,238,130,238],
     _bU_=[0,245,222,179],
     _bV_=[0,255,255,255],
     _bW_=[0,245,245,245],
     _bX_=[0,255,255,0],
     _bY_=[0,154,205,50];
    function symbol(x,y){return x < y?1:0}
    function symbol$0(x,y){return x <= y?1:0}
    function symbol$1(x,y){return x !== y?1:0}
    function symbol$2(x,y){return x === y?1:0}
    function symbol$3(x,y){return y < x?1:0}
    function symbol$4(x,y){return y <= x?1:0}
    var compare=runtime.caml_int_compare;
    function equal(x,y){return x === y?1:0}
    function max(x,y){return y <= x?x:y}
    function min(x,y){return x <= y?x:y}
    var
     Int_replace_polymorphic_compar=
      [0,
       symbol,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       compare,
       equal,
       max,
       min],
     make=Stdlib_string[1],
     init=Stdlib_string[2],
     concat=Stdlib_string[3],
     compare$0=Stdlib_string[5],
     contains_from=Stdlib_string[6],
     rcontains_from=Stdlib_string[7],
     contains=Stdlib_string[8],
     sub=Stdlib_string[9],
     split_on_char=Stdlib_string[10],
     map=Stdlib_string[11],
     mapi=Stdlib_string[12],
     trim=Stdlib_string[13],
     escaped=Stdlib_string[14],
     uppercase_ascii=Stdlib_string[15],
     lowercase_ascii=Stdlib_string[16],
     capitalize_ascii=Stdlib_string[17],
     uncapitalize_ascii=Stdlib_string[18],
     iter=Stdlib_string[19],
     iteri=Stdlib_string[20],
     index_from=Stdlib_string[21],
     index_from_opt=Stdlib_string[22],
     rindex_from=Stdlib_string[23],
     rindex_from_opt=Stdlib_string[24],
     index=Stdlib_string[25],
     index_opt=Stdlib_string[26],
     rindex=Stdlib_string[27],
     rindex_opt=Stdlib_string[28],
     to_seq=Stdlib_string[29],
     to_seqi=Stdlib_string[30],
     of_seq=Stdlib_string[31],
     blit=Stdlib_string[32],
     copy=Stdlib_string[33],
     fill=Stdlib_string[34],
     uppercase=Stdlib_string[35],
     lowercase=Stdlib_string[36],
     capitalize=Stdlib_string[37],
     uncapitalize=Stdlib_string[38];
    function equal$0(x,y){return runtime.caml_string_equal(x,y)}
    var
     String=
      [0,
       make,
       init,
       concat,
       compare$0,
       contains_from,
       rcontains_from,
       contains,
       sub,
       split_on_char,
       map,
       mapi,
       trim,
       escaped,
       uppercase_ascii,
       lowercase_ascii,
       capitalize_ascii,
       uncapitalize_ascii,
       iter,
       iteri,
       index_from,
       index_from_opt,
       rindex_from,
       rindex_from_opt,
       index,
       index_opt,
       rindex,
       rindex_opt,
       to_seq,
       to_seqi,
       of_seq,
       blit,
       copy,
       fill,
       uppercase,
       lowercase,
       capitalize,
       uncapitalize,
       equal$0],
     chr=Stdlib_char[1],
     escaped$0=Stdlib_char[2],
     lowercase$0=Stdlib_char[3],
     uppercase$0=Stdlib_char[4],
     lowercase_ascii$0=Stdlib_char[5],
     uppercase_ascii$0=Stdlib_char[6],
     compare$1=Stdlib_char[7];
    function equal$1(x,y){return x === y?1:0}
    var
     Char=
      [0,
       chr,
       escaped$0,
       lowercase$0,
       uppercase$0,
       lowercase_ascii$0,
       uppercase_ascii$0,
       compare$1,
       equal$1],
     symbol$5=Int_replace_polymorphic_compar[1],
     symbol$6=Int_replace_polymorphic_compar[2],
     symbol$7=Int_replace_polymorphic_compar[3],
     symbol$8=Int_replace_polymorphic_compar[4],
     symbol$9=Int_replace_polymorphic_compar[5],
     symbol$10=Int_replace_polymorphic_compar[6],
     compare$2=Int_replace_polymorphic_compar[7],
     equal$2=Int_replace_polymorphic_compar[8],
     max$0=Int_replace_polymorphic_compar[9],
     min$0=Int_replace_polymorphic_compar[10],
     Js_of_ocaml_Import=
      [0,
       Poly,
       Int_replace_polymorphic_compar,
       String,
       Char,
       symbol$5,
       symbol$6,
       symbol$7,
       symbol$8,
       symbol$9,
       symbol$10,
       compare$2,
       equal$2,
       max$0,
       min$0];
    caml_register_global(1635,Js_of_ocaml_Import,"Js_of_ocaml__Import");
    var
     global=joo_global_object,
     Unsafe=[0,global],
     no_handler=null,
     t39=undefined;
    function return$0(_gH_){return _gH_}
    function map$0(x,f){return x == no_handler?no_handler:caml_call1(f,x)}
    function bind(x,f){return x == no_handler?no_handler:caml_call1(f,x)}
    function test(x){return 1 - (x == no_handler?1:0)}
    function iter$0(x,f)
     {var _gG_=1 - (x == no_handler?1:0);return _gG_?caml_call1(f,x):_gG_}
    function case$0(x,f,g)
     {return x == no_handler?caml_call1(f,0):caml_call1(g,x)}
    function get(x,f){return x == no_handler?caml_call1(f,0):x}
    function option(x){if(x){var x$0=x[1];return x$0}return no_handler}
    function to_option(x)
     {function _gF_(x){return [0,x]}
      return case$0(x,function(param){return 0},_gF_)}
    var
     Opt=
      [0,
       no_handler,
       return$0,
       map$0,
       bind,
       test,
       iter$0,
       case$0,
       get,
       option,
       to_option];
    function return$1(_gE_){return _gE_}
    function map$1(x,f){return x === t39?t39:caml_call1(f,x)}
    function bind$0(x,f){return x === t39?t39:caml_call1(f,x)}
    function test$0(x){return x !== t39?1:0}
    function iter$1(x,f)
     {var _gD_=x !== t39?1:0;return _gD_?caml_call1(f,x):_gD_}
    function case$1(x,f,g){return x === t39?caml_call1(f,0):caml_call1(g,x)}
    function get$0(x,f){return x === t39?caml_call1(f,0):x}
    function option$0(x){if(x){var x$0=x[1];return x$0}return t39}
    function to_option$0(x)
     {function _gC_(x){return [0,x]}
      return case$1(x,function(param){return 0},_gC_)}
    var
     Optdef=
      [0,
       t39,
       return$1,
       map$1,
       bind$0,
       test$0,
       iter$1,
       case$1,
       get$0,
       option$0,
       to_option$0];
    function coerce(x,f,g)
     {function _gA_(param){return caml_call1(g,x)}
      var _gB_=caml_call1(f,x);
      return caml_call2(Opt[8],_gB_,_gA_)}
    function coerce_opt(x,f,g)
     {function _gy_(param){return caml_call1(g,x)}
      var _gz_=caml_call2(Opt[4],x,f);
      return caml_call2(Opt[8],_gz_,_gy_)}
    var
     t25=true,
     t4=false,
     string_constr=Unsafe[1].String,
     t11=Unsafe[1].RegExp,
     t4$0=Unsafe[1].Object;
    function object_keys(t3){return t4$0.keys(t3)}
    var
     array_length=Unsafe[1].Array,
     array_get=caml_js_get,
     array_set=caml_js_set;
    function array_map(f,a)
     {return a.map
              (caml_js_wrap_callback
                (function(x,idx,param){return caml_call1(f,x)}))}
    function array_mapi(f,a)
     {return a.map
              (caml_js_wrap_callback
                (function(x,idx,param){return caml_call2(f,idx,x)}))}
    function str_array(_gx_){return _gx_}
    function match_result(_gw_){return _gw_}
    var
     t121=Unsafe[1].Date,
     math=Unsafe[1].Math,
     Error=[248,cst_Js_of_ocaml_Js_Error,caml_fresh_oo_id(0)],
     error_constr=Unsafe[1].Error;
    caml_call2(Stdlib_callback[2],cst_jsError,[0,Error,{}]);
    function raise_js_error(exn){throw exn}
    var JSON=Unsafe[1].JSON;
    function decodeURI(s){return Unsafe[1].decodeURI(s)}
    function decodeURIComponent(s){return Unsafe[1].decodeURIComponent(s)}
    function encodeURI(s){return Unsafe[1].encodeURI(s)}
    function encodeURIComponent(s){return Unsafe[1].encodeURIComponent(s)}
    function escape(s){return Unsafe[1].escape(s)}
    function unescape(s){return Unsafe[1].unescape(s)}
    function isNaN(i){return Unsafe[1].isNaN(i) | 0}
    function parseInt(s)
     {var s$0=Unsafe[1].parseInt(s);
      return isNaN(s$0)?caml_call1(Stdlib[2],cst_parseInt):s$0}
    function parseFloat(s)
     {var s$0=Unsafe[1].parseFloat(s);
      return isNaN(s$0)?caml_call1(Stdlib[2],cst_parseFloat):s$0}
    function _a_(param)
     {if(param[1] === Error)
       {var e=param[2];return [0,caml_string_of_jsstring(e.toString())]}
      return 0}
    caml_call1(Stdlib_printexc[9],_a_);
    function _b_(e)
     {return e instanceof array_length
              ?0
              :[0,caml_string_of_jsstring(e.toString())]}
    caml_call1(Stdlib_printexc[9],_b_);
    function string_of_error(e){return caml_string_of_jsstring(e.toString())}
    function export_js(field,x)
     {return runtime.caml_js_export_var(0)[field] = x}
    function export$0(field,x)
     {return export_js(caml_jsstring_of_string(field),x)}
    function export_all(obj)
     {var
       t25=object_keys(obj),
       t24=
        caml_js_wrap_callback
         (function(key,param,_gv_){return export_js(key,obj[key])});
      return t25.forEach(t24)}
    var _c_=runtime.caml_js_error_of_exception,_d_=caml_exn_with_js_backtrace;
    function _e_(_gu_){return _gu_}
    var
     Js_of_ocaml_Js=
      [0,
       no_handler,
       function(_gt_){return _gt_},
       t39,
       _e_,
       Opt,
       Optdef,
       t25,
       t4,
       string_constr,
       t11,
       t11,
       t11,
       object_keys,
       array_length,
       array_length,
       array_get,
       array_set,
       array_map,
       array_mapi,
       str_array,
       match_result,
       t121,
       t121,
       t121,
       t121,
       t121,
       t121,
       t121,
       t121,
       t121,
       math,
       error_constr,
       string_of_error,
       raise_js_error,
       _d_,
       _c_,
       Error,
       JSON,
       decodeURI,
       decodeURIComponent,
       encodeURI,
       encodeURIComponent,
       escape,
       unescape,
       isNaN,
       parseInt,
       parseFloat,
       coerce,
       coerce_opt,
       export$0,
       export_all,
       Unsafe];
    caml_register_global(1639,Js_of_ocaml_Js,"Js_of_ocaml__Js");
    function list_of_nodeList(nodeList)
     {var length=nodeList.length,acc=0,i=0;
      for(;;)
       {if(caml_call2(symbol$5,i,length))
         {var _gs_=nodeList.item(i),match=caml_call1(Opt[10],_gs_);
          if(match)
           {var e=match[1],i$0=i + 1 | 0,acc$0=[0,e,acc],acc=acc$0,i=i$0;
            continue}
          var i$1=i + 1 | 0,i=i$1;
          continue}
        return caml_call1(Stdlib_list[9],acc)}}
    var
     disconnected=1,
     preceding=2,
     following=4,
     contains$0=8,
     contained_by=16,
     implementation_specific=32;
    function has(t,mask){return caml_call2(symbol$8,t & mask,mask)}
    function add(x,y){return x | y}
    var
     DocumentPosition=
      [0,
       disconnected,
       preceding,
       following,
       contains$0,
       contained_by,
       implementation_specific,
       has,
       add,
       add];
    function appendChild(p,n){p.appendChild(n);return 0}
    function removeChild(p,n){p.removeChild(n);return 0}
    function replaceChild(p,n,o){p.replaceChild(n,o);return 0}
    function insertBefore(p,n,o){p.insertBefore(n,o);return 0}
    function nodeType(e)
     {var match=e.nodeType;
      if(match)
       {var switcher=match - 1 | 0;
        switch(switcher)
         {case 0:return [0,e];case 1:return [1,e];case 2:case 3:return [2,e]}}
      return [3,e]}
    function cast(e,t){return e.nodeType === t?e:no_handler}
    function element(e){return cast(e,1)}
    function text(e)
     {if(3 !== e.nodeType && 4 !== e.nodeType)return no_handler;return e}
    function attr(e){return cast(e,2)}
    function handler(f)
     {return function(e)
       {if(caml_call1(Opt[5],e))
         {var res=caml_call1(f,e);
          if(1 - (res | 0))e.preventDefault();
          return res}
        var e$0=event,res$0=caml_call1(f,e$0);
        if(1 - (res$0 | 0))e$0.returnValue = res$0;
        return res$0}}
    function full_handler(f)
     {return runtime.caml_js_wrap_meth_callback_unsafe
              (function(this$0,e)
                {if(caml_call1(Opt[5],e))
                  {var res=caml_call2(f,this$0,e);
                   if(1 - (res | 0))e.preventDefault();
                   return res}
                 var e$0=event,res$0=caml_call2(f,this$0,e$0);
                 if(1 - (res$0 | 0))e$0.returnValue = res$0;
                 return res$0})}
    function invoke_handler(f,this$0,event){return f.call(this$0,event)}
    function eventTarget(e)
     {function _gp_(param)
       {function _gr_(param){throw Stdlib[8]}
        return caml_call2(Opt[8],e.srcElement,_gr_)}
      var target=caml_call2(Opt[8],e.target,_gp_);
      if(target instanceof Unsafe[1].Node)
       {if(3 === target.nodeType)
         {var _gq_=function(param){throw [0,Assert_failure,_f_]};
          return caml_call2(Opt[8],target.parentNode,_gq_)}
        return target}
      return target}
    function make$0(s){return caml_jsstring_of_string(s)}
    var Event=[0,make$0];
    function addEventListenerWithOptions(t50,t47,capture,once,passive,t48)
     {if(t50.addEventListener === t39)
       {var
         t34="on".concat(t47),
         t35=
          function(e)
           {var _gm_=[0,t48,e,[0]];
            return function(_gn_,_go_)
             {return runtime.caml_js_call(_gm_,_gn_,_go_)}};
        t50.attachEvent(t34,t35);
        return function(param){return t50.detachEvent(t34,t35)}}
      var t49={};
      function iter(t,f){if(t){var b=t[1];return caml_call1(f,b)}return 0}
      iter(capture,function(b){return t49.capture = b});
      iter(once,function(b){return t49.once = b});
      iter(passive,function(b){return t49.passive = b});
      t50.addEventListener(t47,t48,t49);
      return function(param){return t50.removeEventListener(t47,t48,t49)}}
    function addEventListener(e,typ,h,capt)
     {return addEventListenerWithOptions(e,typ,[0,capt],0,0,h)}
    function removeEventListener(id){return caml_call1(id,0)}
    function preventDefault(ev)
     {return caml_call1(Optdef[5],ev.preventDefault)
              ?ev.preventDefault()
              :ev.returnValue = ! ! 0}
    function createCustomEvent(bubbles,cancelable,detail,t62)
     {function opt_iter(f,param)
       {if(param){var x=param[1];return caml_call1(f,x)}return 0}
      var t63={};
      opt_iter(function(x){return t63.bubbles = ! ! x},bubbles);
      opt_iter(function(x){return t63.cancelable = ! ! x},cancelable);
      opt_iter(function(x){return t63.detail = x},detail);
      var t64=Unsafe[1].CustomEvent;
      return new t64(t62,t63)}
    var
     Js_of_ocaml_Dom=
      [0,
       DocumentPosition,
       insertBefore,
       replaceChild,
       removeChild,
       appendChild,
       list_of_nodeList,
       nodeType,
       [0,element,text,attr],
       no_handler,
       handler,
       full_handler,
       invoke_handler,
       eventTarget,
       Event,
       addEventListenerWithOptions,
       addEventListener,
       removeEventListener,
       preventDefault,
       createCustomEvent];
    caml_register_global(1642,Js_of_ocaml_Dom,"Js_of_ocaml__Dom");
    var
     arrayBuffer=Unsafe[1].ArrayBuffer,
     int8Array_inBuffer=Unsafe[1].Int8Array,
     t11$0=Unsafe[1].Uint8Array,
     int16Array_inBuffer=Unsafe[1].Int16Array,
     uint16Array_inBuffer=Unsafe[1].Uint16Array,
     int32Array_inBuffer=Unsafe[1].Int32Array,
     uint32Array_inBuffer=Unsafe[1].Uint32Array,
     float32Array_inBuffer=Unsafe[1].Float32Array,
     float64Array_inBuffer=Unsafe[1].Float64Array,
     set=caml_js_set;
    function get$1(a,i){return a[i]}
    function unsafe_get(a,i){return a[i]}
    var dataView=Unsafe[1].DataView;
    function of_arrayBuffer(ab)
     {var uint8=new t11$0(ab);return caml_string_of_array(uint8)}
    var
     Js_of_ocaml_Typed_array=
      [0,
       arrayBuffer,
       runtime.caml_ba_kind_of_typed_array,
       runtime.caml_ba_to_typed_array,
       runtime.caml_ba_from_typed_array,
       int8Array_inBuffer,
       int8Array_inBuffer,
       int8Array_inBuffer,
       int8Array_inBuffer,
       int8Array_inBuffer,
       t11$0,
       t11$0,
       t11$0,
       t11$0,
       t11$0,
       int16Array_inBuffer,
       int16Array_inBuffer,
       int16Array_inBuffer,
       int16Array_inBuffer,
       int16Array_inBuffer,
       uint16Array_inBuffer,
       uint16Array_inBuffer,
       uint16Array_inBuffer,
       uint16Array_inBuffer,
       uint16Array_inBuffer,
       int32Array_inBuffer,
       int32Array_inBuffer,
       int32Array_inBuffer,
       int32Array_inBuffer,
       int32Array_inBuffer,
       uint32Array_inBuffer,
       uint32Array_inBuffer,
       uint32Array_inBuffer,
       uint32Array_inBuffer,
       uint32Array_inBuffer,
       float32Array_inBuffer,
       float32Array_inBuffer,
       float32Array_inBuffer,
       float32Array_inBuffer,
       float32Array_inBuffer,
       float64Array_inBuffer,
       float64Array_inBuffer,
       float64Array_inBuffer,
       float64Array_inBuffer,
       float64Array_inBuffer,
       set,
       get$1,
       unsafe_get,
       dataView,
       dataView,
       [0,
        runtime.bigstring_to_array_buffer,
        runtime.bigstring_to_typed_array,
        runtime.bigstring_of_array_buffer,
        runtime.bigstring_of_typed_array],
       [0,of_arrayBuffer,caml_string_of_array]];
    caml_register_global
     (1643,Js_of_ocaml_Typed_array,"Js_of_ocaml__Typed_array");
    var t3=Unsafe[1].Blob;
    function filter_map(f,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var q=param$0[2],v=param$0[1],match=caml_call1(f,v);
          if(match){var v$0=match[1];return [0,v$0,filter_map(f,q)]}
          var param$0=q;
          continue}
        return 0}}
    function blob_raw(contentType,endings,a)
     {var _gi_=0;
      if(endings)
       var _gj_=116179762 <= endings[1]?_g_:_h_,_gk_=_gj_;
      else
       var _gk_=0;
      var
       _gl_=[0,[0,cst_type,contentType],[0,[0,cst_endings,_gk_],_gi_]],
       options=
        filter_map
         (function(param)
           {var v=param[2],name=param[1];
            if(v)
             {var v$0=v[1];return [0,[0,name,caml_jsstring_of_string(v$0)]]}
            return 0},
          _gl_),
       options$0=
        options
         ?runtime.caml_js_object(caml_call1(Stdlib_array[12],options))
         :t39,
       t1=caml_js_from_array(a);
      return new t3(t1,options$0)}
    function blob_from_string(contentType,endings,s)
     {return blob_raw(contentType,endings,[0,caml_jsstring_of_string(s)])}
    function blob_from_any(contentType,endings,l)
     {function _gg_(param)
       {var _gh_=param[1];
        if(155580615 === _gh_){var s=param[2];return s}
        if(486041214 <= _gh_)
         {if(1037850489 <= _gh_){var a=param[2];return a}
          var a$0=param[2];
          return a$0}
        if(288368849 <= _gh_)
         {var s$0=param[2];return caml_jsstring_of_string(s$0)}
        var b=param[2];
        return b}
      var l$0=caml_call2(Stdlib_list[19],_gg_,l);
      return blob_raw(contentType,endings,caml_call1(Stdlib_array[12],l$0))}
    function filename(file)
     {var match=caml_call1(Optdef[10],file.name);
      if(match){var name=match[1];return name}
      var match$0=caml_call1(Optdef[10],file.fileName);
      if(match$0){var name$0=match$0[1];return name$0}
      return caml_call1(Stdlib[2],cst_can_t_retrieve_file_name_n)}
    var doc_constr=Unsafe[1].Document;
    function document(e){return e instanceof doc_constr?e:no_handler}
    function blob(e){return e instanceof t3?e:no_handler}
    function string(e){return typeof e === "string"?e:no_handler}
    function arrayBuffer$0(e){return e instanceof arrayBuffer?e:no_handler}
    var
     loadstart=caml_call1(Event[1],cst_loadstart),
     progress=caml_call1(Event[1],cst_progress),
     abort=caml_call1(Event[1],cst_abort),
     error=caml_call1(Event[1],cst_error),
     load=caml_call1(Event[1],cst_load),
     loadend=caml_call1(Event[1],cst_loadend),
     ReaderEvent=[0,loadstart,progress,abort,error,load,loadend],
     fileReader=Unsafe[1].FileReader,
     Js_of_ocaml_File=
      [0,
       blob_from_string,
       blob_from_any,
       [0,document,blob,function(_gf_){return _gf_},string,arrayBuffer$0],
       ReaderEvent,
       filename,
       fileReader,
       addEventListener];
    caml_register_global(1645,Js_of_ocaml_File,"Js_of_ocaml__File");
    var
     onIE=runtime.caml_js_on_ie(0) | 0,
     click=caml_call1(Event[1],cst_click),
     copy$0=caml_call1(Event[1],cst_copy),
     cut=caml_call1(Event[1],cst_cut),
     paste=caml_call1(Event[1],cst_paste),
     dblclick=caml_call1(Event[1],cst_dblclick),
     mousedown=caml_call1(Event[1],cst_mousedown),
     mouseup=caml_call1(Event[1],cst_mouseup),
     mouseover=caml_call1(Event[1],cst_mouseover),
     mousemove=caml_call1(Event[1],cst_mousemove),
     mouseout=caml_call1(Event[1],cst_mouseout),
     keypress=caml_call1(Event[1],cst_keypress),
     keydown=caml_call1(Event[1],cst_keydown),
     keyup=caml_call1(Event[1],cst_keyup),
     mousewheel=caml_call1(Event[1],cst_mousewheel),
     DOMMouseScroll=caml_call1(Event[1],cst_DOMMouseScroll),
     touchstart=caml_call1(Event[1],cst_touchstart),
     touchmove=caml_call1(Event[1],cst_touchmove),
     touchend=caml_call1(Event[1],cst_touchend),
     touchcancel=caml_call1(Event[1],cst_touchcancel),
     dragstart=caml_call1(Event[1],cst_dragstart),
     dragend=caml_call1(Event[1],cst_dragend),
     dragenter=caml_call1(Event[1],cst_dragenter),
     dragover=caml_call1(Event[1],cst_dragover),
     dragleave=caml_call1(Event[1],cst_dragleave),
     drag=caml_call1(Event[1],cst_drag),
     drop=caml_call1(Event[1],cst_drop),
     hashchange=caml_call1(Event[1],cst_hashchange),
     change=caml_call1(Event[1],cst_change),
     input=caml_call1(Event[1],cst_input),
     timeupdate=caml_call1(Event[1],cst_timeupdate),
     submit=caml_call1(Event[1],cst_submit),
     scroll=caml_call1(Event[1],cst_scroll),
     focus=caml_call1(Event[1],cst_focus),
     blur=caml_call1(Event[1],cst_blur),
     load$0=caml_call1(Event[1],cst_load$0),
     unload=caml_call1(Event[1],cst_unload),
     beforeunload=caml_call1(Event[1],cst_beforeunload),
     resize=caml_call1(Event[1],cst_resize),
     orientationchange=caml_call1(Event[1],cst_orientationchange),
     popstate=caml_call1(Event[1],cst_popstate),
     error$0=caml_call1(Event[1],cst_error$0),
     abort$0=caml_call1(Event[1],cst_abort$0),
     select=caml_call1(Event[1],cst_select),
     online=caml_call1(Event[1],cst_online),
     offline=caml_call1(Event[1],cst_offline),
     checking=caml_call1(Event[1],cst_checking),
     noupdate=caml_call1(Event[1],cst_noupdate),
     downloading=caml_call1(Event[1],cst_downloading),
     progress$0=caml_call1(Event[1],cst_progress$0),
     updateready=caml_call1(Event[1],cst_updateready),
     cached=caml_call1(Event[1],cst_cached),
     obsolete=caml_call1(Event[1],cst_obsolete),
     domContentLoaded=caml_call1(Event[1],cst_DOMContentLoaded),
     animationstart=caml_call1(Event[1],cst_animationstart),
     animationend=caml_call1(Event[1],cst_animationend),
     animationiteration=caml_call1(Event[1],cst_animationiteration),
     animationcancel=caml_call1(Event[1],cst_animationcancel),
     canplay=caml_call1(Event[1],cst_canplay),
     canplaythrough=caml_call1(Event[1],cst_canplaythrough),
     durationchange=caml_call1(Event[1],cst_durationchange),
     emptied=caml_call1(Event[1],cst_emptied),
     ended=caml_call1(Event[1],cst_ended),
     gotpointercapture=caml_call1(Event[1],cst_gotpointercapture),
     loadeddata=caml_call1(Event[1],cst_loadeddata),
     loadedmetadata=caml_call1(Event[1],cst_loadedmetadata),
     loadstart$0=caml_call1(Event[1],cst_loadstart$0),
     lostpointercapture=caml_call1(Event[1],cst_lostpointercapture),
     pause=caml_call1(Event[1],cst_pause),
     play=caml_call1(Event[1],cst_play),
     playing=caml_call1(Event[1],cst_playing),
     pointerenter=caml_call1(Event[1],cst_pointerenter),
     pointercancel=caml_call1(Event[1],cst_pointercancel),
     pointerdown=caml_call1(Event[1],cst_pointerdown),
     pointerleave=caml_call1(Event[1],cst_pointerleave),
     pointermove=caml_call1(Event[1],cst_pointermove),
     pointerout=caml_call1(Event[1],cst_pointerout),
     pointerover=caml_call1(Event[1],cst_pointerover),
     pointerup=caml_call1(Event[1],cst_pointerup),
     ratechange=caml_call1(Event[1],cst_ratechange),
     seeked=caml_call1(Event[1],cst_seeked),
     seeking=caml_call1(Event[1],cst_seeking),
     stalled=caml_call1(Event[1],cst_stalled),
     suspend=caml_call1(Event[1],cst_suspend),
     volumechange=caml_call1(Event[1],cst_volumechange),
     waiting=caml_call1(Event[1],cst_waiting),
     make$1=Event[1],
     Event$0=
      [0,
       click,
       copy$0,
       cut,
       paste,
       dblclick,
       mousedown,
       mouseup,
       mouseover,
       mousemove,
       mouseout,
       keypress,
       keydown,
       keyup,
       mousewheel,
       DOMMouseScroll,
       touchstart,
       touchmove,
       touchend,
       touchcancel,
       dragstart,
       dragend,
       dragenter,
       dragover,
       dragleave,
       drag,
       drop,
       hashchange,
       change,
       input,
       timeupdate,
       submit,
       scroll,
       focus,
       blur,
       load$0,
       unload,
       beforeunload,
       resize,
       orientationchange,
       popstate,
       error$0,
       abort$0,
       select,
       online,
       offline,
       checking,
       noupdate,
       downloading,
       progress$0,
       updateready,
       cached,
       obsolete,
       domContentLoaded,
       animationstart,
       animationend,
       animationiteration,
       animationcancel,
       canplay,
       canplaythrough,
       durationchange,
       emptied,
       ended,
       gotpointercapture,
       loadeddata,
       loadedmetadata,
       loadstart$0,
       lostpointercapture,
       pause,
       play,
       playing,
       pointerenter,
       pointercancel,
       pointerdown,
       pointerleave,
       pointermove,
       pointerout,
       pointerover,
       pointerup,
       ratechange,
       seeked,
       seeking,
       stalled,
       suspend,
       volumechange,
       waiting,
       make$1],
     d="2d";
    function location_origin(loc)
     {function _gd_(o){return o}
      function _ge_(param)
       {var t8=loc.protocol,t7=loc.hostname,port=loc.port;
        if
         (caml_call2(symbol$8,t8.length,0)
          &&
          caml_call2(symbol$8,t7.length,0))
         return "";
        var t13=t8.concat("//",t7);
        if(caml_call2(symbol$9,port.length,0))
         {var t12=loc.port;return t13.concat(":",t12)}
        return t13}
      return caml_call3(Optdef[7],loc.origin,_ge_,_gd_)}
    var _i_=Unsafe[1],t22=_i_.document;
    function getElementById(id)
     {function _ga_(pnode){return pnode}
      function _gb_(param){throw Stdlib[8]}
      var t15=caml_jsstring_of_string(id),_gc_=t22.getElementById(t15);
      return caml_call3(Opt[7],_gc_,_gb_,_ga_)}
    function getElementById_exn(id)
     {function _f8_(pnode){return pnode}
      function _f9_(param)
       {var _f$_=caml_call2(Stdlib_printf[4],_j_,id);
        return caml_call1(Stdlib[2],_f$_)}
      var t17=caml_jsstring_of_string(id),_f__=t22.getElementById(t17);
      return caml_call3(Opt[7],_f__,_f9_,_f8_)}
    function getElementById_opt(id)
     {var t19=caml_jsstring_of_string(id),_f7_=t22.getElementById(t19);
      return caml_call1(Opt[10],_f7_)}
    function getElementById_coerce(id,coerce)
     {function _f3_(e)
       {var _f6_=caml_call1(coerce,e);return caml_call1(Opt[10],_f6_)}
      function _f4_(param){return 0}
      var t21=caml_jsstring_of_string(id),_f5_=t22.getElementById(t21);
      return caml_call3(Opt[7],_f5_,_f4_,_f3_)}
    function opt_iter(x,f){if(x){var v=x[1];return caml_call1(f,v)}return 0}
    function createElement(t24,name)
     {var t23=caml_jsstring_of_string(name);return t24.createElement(t23)}
    function unsafeCreateElement(doc,name){return createElement(doc,name)}
    var createElementSyntax=[0,785140586];
    function unsafeCreateElementEx(type,name,doc,elt)
     {for(;;)
       {if(0 === type && 0 === name)return createElement(doc,elt);
        var _fX_=createElementSyntax[1];
        if(785140586 === _fX_)
         {try
           {var
             el=t22.createElement('<input name="x">'),
             _f0_=el.tagName.toLowerCase() === "input"?1:0,
             _f1_=_f0_?el.name === "x"?1:0:_f0_,
             _fY_=_f1_}
          catch(_f2_){var _fY_=0}
          var _fZ_=_fY_?982028505:-1003883683;
          createElementSyntax[1] = _fZ_;
          continue}
        if(982028505 <= _fX_)
         {var t40=new array_length();
          t40.push("<",caml_jsstring_of_string(elt));
          opt_iter
           (type,
            function(t)
             {var t34=caml_js_html_escape(t);
              t40.push(' type="',t34,'"');
              return 0});
          opt_iter
           (name,
            function(n)
             {var t38=caml_js_html_escape(n);
              t40.push(' name="',t38,'"');
              return 0});
          t40.push(">");
          return doc.createElement(t40.join(""))}
        var res=createElement(doc,elt);
        opt_iter(type,function(t){return res.type = t});
        opt_iter(name,function(n){return res.name = n});
        return res}}
    function createHtml(doc){return unsafeCreateElement(doc,cst_html)}
    function createHead(doc){return unsafeCreateElement(doc,cst_head)}
    function createLink(doc){return unsafeCreateElement(doc,cst_link)}
    function createTitle(doc){return unsafeCreateElement(doc,cst_title)}
    function createMeta(doc){return unsafeCreateElement(doc,cst_meta)}
    function createBase(doc){return unsafeCreateElement(doc,cst_base)}
    function createStyle(doc){return unsafeCreateElement(doc,cst_style)}
    function createBody(doc){return unsafeCreateElement(doc,cst_body)}
    function createForm(doc){return unsafeCreateElement(doc,cst_form)}
    function createOptgroup(doc){return unsafeCreateElement(doc,cst_optgroup)}
    function createOption(doc){return unsafeCreateElement(doc,cst_option)}
    function createSelect(type,name,doc)
     {return unsafeCreateElementEx(type,name,doc,cst_select$0)}
    function createInput(type,name,doc)
     {return unsafeCreateElementEx(type,name,doc,cst_input$0)}
    function createTextarea(type,name,doc)
     {return unsafeCreateElementEx(type,name,doc,cst_textarea)}
    function createButton(type,name,doc)
     {return unsafeCreateElementEx(type,name,doc,cst_button)}
    function createLabel(doc){return unsafeCreateElement(doc,cst_label)}
    function createFieldset(doc){return unsafeCreateElement(doc,cst_fieldset)}
    function createLegend(doc){return unsafeCreateElement(doc,cst_legend)}
    function createUl(doc){return unsafeCreateElement(doc,cst_ul)}
    function createOl(doc){return unsafeCreateElement(doc,cst_ol)}
    function createDl(doc){return unsafeCreateElement(doc,cst_dl)}
    function createLi(doc){return unsafeCreateElement(doc,cst_li)}
    function createDiv(doc){return unsafeCreateElement(doc,cst_div)}
    function createEmbed(doc){return unsafeCreateElement(doc,cst_embed)}
    function createP(doc){return unsafeCreateElement(doc,cst_p)}
    function createH1(doc){return unsafeCreateElement(doc,cst_h1)}
    function createH2(doc){return unsafeCreateElement(doc,cst_h2)}
    function createH3(doc){return unsafeCreateElement(doc,cst_h3)}
    function createH4(doc){return unsafeCreateElement(doc,cst_h4)}
    function createH5(doc){return unsafeCreateElement(doc,cst_h5)}
    function createH6(doc){return unsafeCreateElement(doc,cst_h6)}
    function createQ(doc){return unsafeCreateElement(doc,cst_q)}
    function createBlockquote(doc)
     {return unsafeCreateElement(doc,cst_blockquote)}
    function createPre(doc){return unsafeCreateElement(doc,cst_pre)}
    function createBr(doc){return unsafeCreateElement(doc,cst_br)}
    function createHr(doc){return unsafeCreateElement(doc,cst_hr)}
    function createIns(doc){return unsafeCreateElement(doc,cst_ins)}
    function createDel(doc){return unsafeCreateElement(doc,cst_del)}
    function createA(doc){return unsafeCreateElement(doc,cst_a)}
    function createImg(doc){return unsafeCreateElement(doc,cst_img)}
    function createObject(doc){return unsafeCreateElement(doc,cst_object)}
    function createParam(doc){return unsafeCreateElement(doc,cst_param)}
    function createMap(doc){return unsafeCreateElement(doc,cst_map)}
    function createArea(doc){return unsafeCreateElement(doc,cst_area)}
    function createScript(doc){return unsafeCreateElement(doc,cst_script)}
    function createTable(doc){return unsafeCreateElement(doc,cst_table)}
    function createCaption(doc){return unsafeCreateElement(doc,cst_caption)}
    function createCol(doc){return unsafeCreateElement(doc,cst_col)}
    function createColgroup(doc){return unsafeCreateElement(doc,cst_colgroup)}
    function createThead(doc){return unsafeCreateElement(doc,cst_thead)}
    function createTfoot(doc){return unsafeCreateElement(doc,cst_tfoot)}
    function createTbody(doc){return unsafeCreateElement(doc,cst_tbody)}
    function createTr(doc){return unsafeCreateElement(doc,cst_tr)}
    function createTh(doc){return unsafeCreateElement(doc,cst_th)}
    function createTd(doc){return unsafeCreateElement(doc,cst_td)}
    function createSub(doc){return createElement(doc,cst_sub)}
    function createSup(doc){return createElement(doc,cst_sup)}
    function createSpan(doc){return createElement(doc,cst_span)}
    function createTt(doc){return createElement(doc,cst_tt)}
    function createI(doc){return createElement(doc,cst_i)}
    function createB(doc){return createElement(doc,cst_b)}
    function createBig(doc){return createElement(doc,cst_big)}
    function createSmall(doc){return createElement(doc,cst_small)}
    function createEm(doc){return createElement(doc,cst_em)}
    function createStrong(doc){return createElement(doc,cst_strong)}
    function createCite(doc){return createElement(doc,cst_cite)}
    function createDfn(doc){return createElement(doc,cst_dfn)}
    function createCode(doc){return createElement(doc,cst_code)}
    function createSamp(doc){return createElement(doc,cst_samp)}
    function createKbd(doc){return createElement(doc,cst_kbd)}
    function createVar(doc){return createElement(doc,cst_var)}
    function createAbbr(doc){return createElement(doc,cst_abbr)}
    function createDd(doc){return createElement(doc,cst_dd)}
    function createDt(doc){return createElement(doc,cst_dt)}
    function createNoscript(doc){return createElement(doc,cst_noscript)}
    function createAddress(doc){return createElement(doc,cst_address)}
    function createFrameset(doc){return unsafeCreateElement(doc,cst_frameset)}
    function createFrame(doc){return unsafeCreateElement(doc,cst_frame)}
    function createIframe(doc){return unsafeCreateElement(doc,cst_iframe)}
    function createAudio(doc){return unsafeCreateElement(doc,cst_audio)}
    function createVideo(doc){return unsafeCreateElement(doc,cst_video)}
    var
     Canvas_not_available=
      [248,cst_Js_of_ocaml_Dom_html_Canva,caml_fresh_oo_id(0)];
    function createCanvas(doc)
     {var c=unsafeCreateElement(doc,cst_canvas);
      if(1 - caml_call1(Opt[5],c.getContext))throw Canvas_not_available;
      return c}
    var
     html_element=Unsafe[1].HTMLElement,
     element$0=
      html_element === t39
       ?function(e){return e.innerHTML === t39?no_handler:e}
       :function(e){return e instanceof html_element?e:no_handler};
    function unsafeCoerce(tag,e)
     {var t56=e.tagName,_fW_=caml_jsstring_of_string(tag);
      return t56.toLowerCase() === _fW_?e:no_handler}
    function a(e){return unsafeCoerce(cst_a$0,e)}
    function area(e){return unsafeCoerce(cst_area$0,e)}
    function base(e){return unsafeCoerce(cst_base$0,e)}
    function blockquote(e){return unsafeCoerce(cst_blockquote$0,e)}
    function body(e){return unsafeCoerce(cst_body$0,e)}
    function br(e){return unsafeCoerce(cst_br$0,e)}
    function button(e){return unsafeCoerce(cst_button$0,e)}
    function canvas(e){return unsafeCoerce(cst_canvas$0,e)}
    function caption(e){return unsafeCoerce(cst_caption$0,e)}
    function col(e){return unsafeCoerce(cst_col$0,e)}
    function colgroup(e){return unsafeCoerce(cst_colgroup$0,e)}
    function del(e){return unsafeCoerce(cst_del$0,e)}
    function div(e){return unsafeCoerce(cst_div$0,e)}
    function dl(e){return unsafeCoerce(cst_dl$0,e)}
    function fieldset(e){return unsafeCoerce(cst_fieldset$0,e)}
    function embed(e){return unsafeCoerce(cst_embed$0,e)}
    function form(e){return unsafeCoerce(cst_form$0,e)}
    function frameset(e){return unsafeCoerce(cst_frameset$0,e)}
    function frame(e){return unsafeCoerce(cst_frame$0,e)}
    function h1(e){return unsafeCoerce(cst_h1$0,e)}
    function h2(e){return unsafeCoerce(cst_h2$0,e)}
    function h3(e){return unsafeCoerce(cst_h3$0,e)}
    function h4(e){return unsafeCoerce(cst_h4$0,e)}
    function h5(e){return unsafeCoerce(cst_h5$0,e)}
    function h6(e){return unsafeCoerce(cst_h6$0,e)}
    function head(e){return unsafeCoerce(cst_head$0,e)}
    function hr(e){return unsafeCoerce(cst_hr$0,e)}
    function html(e){return unsafeCoerce(cst_html$0,e)}
    function iframe(e){return unsafeCoerce(cst_iframe$0,e)}
    function img(e){return unsafeCoerce(cst_img$0,e)}
    function input$0(e){return unsafeCoerce(cst_input$1,e)}
    function ins(e){return unsafeCoerce(cst_ins$0,e)}
    function label(e){return unsafeCoerce(cst_label$0,e)}
    function legend(e){return unsafeCoerce(cst_legend$0,e)}
    function li(e){return unsafeCoerce(cst_li$0,e)}
    function link(e){return unsafeCoerce(cst_link$0,e)}
    function map$2(e){return unsafeCoerce(cst_map$0,e)}
    function meta(e){return unsafeCoerce(cst_meta$0,e)}
    function object(e){return unsafeCoerce(cst_object$0,e)}
    function ol(e){return unsafeCoerce(cst_ol$0,e)}
    function optgroup(e){return unsafeCoerce(cst_optgroup$0,e)}
    function option$1(e){return unsafeCoerce(cst_option$0,e)}
    function p(e){return unsafeCoerce(cst_p$0,e)}
    function param(e){return unsafeCoerce(cst_param$0,e)}
    function pre(e){return unsafeCoerce(cst_pre$0,e)}
    function q(e){return unsafeCoerce(cst_q$0,e)}
    function script(e){return unsafeCoerce(cst_script$0,e)}
    function select$0(e){return unsafeCoerce(cst_select$1,e)}
    function style(e){return unsafeCoerce(cst_style$0,e)}
    function table(e){return unsafeCoerce(cst_table$0,e)}
    function tbody(e){return unsafeCoerce(cst_tbody$0,e)}
    function td(e){return unsafeCoerce(cst_td$0,e)}
    function textarea(e){return unsafeCoerce(cst_textarea$0,e)}
    function tfoot(e){return unsafeCoerce(cst_tfoot$0,e)}
    function th(e){return unsafeCoerce(cst_th$0,e)}
    function thead(e){return unsafeCoerce(cst_thead$0,e)}
    function title(e){return unsafeCoerce(cst_title$0,e)}
    function tr(e){return unsafeCoerce(cst_tr$0,e)}
    function ul(e){return unsafeCoerce(cst_ul$0,e)}
    function audio(e){return unsafeCoerce(cst_audio$0,e)}
    function video(e){return unsafeCoerce(cst_video$0,e)}
    function unsafeCoerceEvent(constr,ev)
     {if(constr !== t39 && ev instanceof constr)return ev;return no_handler}
    function mouseEvent(ev){return unsafeCoerceEvent(Unsafe[1].MouseEvent,ev)}
    function keyboardEvent(ev)
     {return unsafeCoerceEvent(Unsafe[1].KeyboardEvent,ev)}
    function wheelEvent(ev){return unsafeCoerceEvent(Unsafe[1].WheelEvent,ev)}
    function mouseScrollEvent(ev)
     {return unsafeCoerceEvent(Unsafe[1].MouseScrollEvent,ev)}
    function popStateEvent(ev)
     {return unsafeCoerceEvent(Unsafe[1].PopStateEvent,ev)}
    function eventRelatedTarget(e)
     {function _fT_(param)
       {var match=caml_string_of_jsstring(e.type);
        if(caml_string_notequal(match,cst_mouseout$0))
         {if(caml_string_notequal(match,cst_mouseover$0))return no_handler;
          var _fU_=function(param){throw [0,Assert_failure,_k_]};
          return caml_call2(Optdef[8],e.fromElement,_fU_)}
        function _fV_(param){throw [0,Assert_failure,_l_]}
        return caml_call2(Optdef[8],e.toElement,_fV_)}
      return caml_call2(Optdef[8],e.relatedTarget,_fT_)}
    function eventAbsolutePosition(e)
     {var body=t22.body,html=t22.documentElement;
      return [0,
              (e.clientX + body.scrollLeft | 0) + html.scrollLeft | 0,
              (e.clientY + body.scrollTop | 0) + html.scrollTop | 0]}
    function eventAbsolutePosition$0(e)
     {function _fP_(x)
       {function _fR_(y){return [0,x,y]}
        function _fS_(param){return eventAbsolutePosition(e)}
        return caml_call3(Optdef[7],e.pageY,_fS_,_fR_)}
      function _fQ_(param){return eventAbsolutePosition(e)}
      return caml_call3(Optdef[7],e.pageX,_fQ_,_fP_)}
    function elementClientPosition(e)
     {var r=e.getBoundingClientRect(),body=t22.body,html=t22.documentElement;
      return [0,
              ((r.left | 0) - body.clientLeft | 0) - html.clientLeft | 0,
              ((r.top | 0) - body.clientTop | 0) - html.clientTop | 0]}
    function getDocumentScroll(param)
     {var body=t22.body,html=t22.documentElement;
      return [0,
              body.scrollLeft + html.scrollLeft | 0,
              body.scrollTop + html.scrollTop | 0]}
    function buttonPressed(ev)
     {function _fN_(x){return x}
      function _fO_(param)
       {var match=ev.button,switcher=match - 1 | 0;
        if(! (3 < switcher >>> 0))
         switch(switcher)
          {case 0:return 1;case 1:return 3;case 2:break;default:return 2}
        return 0}
      return caml_call3(Optdef[7],ev.which,_fO_,_fN_)}
    function addMousewheelEventListenerWith(e,capture,once,passive,h)
     {var t95=createDiv(t22);
      t95.setAttribute("onmousewheel","return;");
      if(typeof t95.onmousewheel === "function")
       {var
         _fJ_=
          handler
           (function(e)
             {function _fL_(param){return 0}
              var
               dx=
                (- caml_call2(Optdef[8],e.wheelDeltaX,_fL_) | 0) / 40 | 0;
              function _fM_(param){return e.wheelDelta}
              var
               dy=
                (- caml_call2(Optdef[8],e.wheelDeltaY,_fM_) | 0) / 40 | 0;
              return caml_call3(h,e,dx,dy)});
        return addEventListenerWithOptions
                (e,Event$0[14],capture,once,passive,_fJ_)}
      var
       _fK_=
        handler
         (function(e)
           {var d=e.detail;
            return e.axis === e.HORIZONTAL
                    ?caml_call3(h,e,d,0)
                    :caml_call3(h,e,0,d)});
      return addEventListenerWithOptions
              (e,Event$0[15],capture,once,passive,_fK_)}
    function addMousewheelEventListener(e,h,capt)
     {return addMousewheelEventListenerWith(e,[0,capt],0,0,h)}
    function f(v)
     {var
       match=caml_string_of_jsstring(v),
       switch$0=caml_string_compare(match,cst_KeyH);
      if(0 <= switch$0)
       {if(! (0 < switch$0))return 8;
        var switch$1=caml_string_compare(match,cst_Numpad4);
        if(0 <= switch$1)
         {if(! (0 < switch$1))return 72;
          var switch$2=caml_string_compare(match,cst_PageUp);
          if(0 <= switch$2)
           {if(! (0 < switch$2))return 98;
            var switch$3=caml_string_compare(match,cst_ShiftRight);
            if(0 <= switch$3)
             {if(! (0 < switch$3))return 91;
              if(! caml_string_notequal(match,cst_Slash))return 55;
              if(! caml_string_notequal(match,cst_Space))return 41;
              if(! caml_string_notequal(match,cst_Tab))return 39;
              if(! caml_string_notequal(match,cst_VolumeDown))return 103;
              if(! caml_string_notequal(match,cst_VolumeMute))return 102;
              if(! caml_string_notequal(match,cst_VolumeUp))return 104}
            else
             {if(! caml_string_notequal(match,cst_Pause))return 123;
              if(! caml_string_notequal(match,cst_Period))return 54;
              if(! caml_string_notequal(match,cst_PrintScreen))return 120;
              if(! caml_string_notequal(match,cst_Quote))return 50;
              if(! caml_string_notequal(match,cst_ScrollLock))return 119;
              if(! caml_string_notequal(match,cst_Semicolon))return 49;
              if(! caml_string_notequal(match,cst_ShiftLeft))return 90}}
          else
           {var switch$4=caml_string_compare(match,cst_NumpadDivide);
            if(0 <= switch$4)
             {if(! (0 < switch$4))return 84;
              if(! caml_string_notequal(match,cst_NumpadEnter))return 83;
              if(! caml_string_notequal(match,cst_NumpadEqual))return 82;
              if(! caml_string_notequal(match,cst_NumpadMultiply))return 78;
              if(! caml_string_notequal(match,cst_NumpadSubtract))return 79;
              if(! caml_string_notequal(match,cst_OSLeft))return 117;
              if(! caml_string_notequal(match,cst_OSRight))return 118;
              if(! caml_string_notequal(match,cst_PageDown))return 99}
            else
             {if(! caml_string_notequal(match,cst_Numpad5))return 73;
              if(! caml_string_notequal(match,cst_Numpad6))return 74;
              if(! caml_string_notequal(match,cst_Numpad7))return 75;
              if(! caml_string_notequal(match,cst_Numpad8))return 76;
              if(! caml_string_notequal(match,cst_Numpad9))return 77;
              if(! caml_string_notequal(match,cst_NumpadAdd))return 80;
              if(! caml_string_notequal(match,cst_NumpadDecimal))return 81}}}
        else
         {var switch$5=caml_string_compare(match,cst_KeyX);
          if(0 <= switch$5)
           {if(! (0 < switch$5))return 24;
            var switch$6=caml_string_compare(match,cst_MetaRight);
            if(0 <= switch$6)
             {if(! (0 < switch$6))return 89;
              if(! caml_string_notequal(match,cst_Minus))return 37;
              if(! caml_string_notequal(match,cst_NumLock))return 85;
              if(! caml_string_notequal(match,cst_Numpad0))return 68;
              if(! caml_string_notequal(match,cst_Numpad1))return 69;
              if(! caml_string_notequal(match,cst_Numpad2))return 70;
              if(! caml_string_notequal(match,cst_Numpad3))return 71}
            else
             {if(! caml_string_notequal(match,cst_KeyY))return 25;
              if(! caml_string_notequal(match,cst_KeyZ))return 26;
              if(! caml_string_notequal(match,cst_MediaPlayPause))return 107;
              if(! caml_string_notequal(match,cst_MediaStop))return 108;
              if(! caml_string_notequal(match,cst_MediaTrackNext))return 106;
              if(! caml_string_notequal(match,cst_MediaTrackPrevious))
               return 105;
              if(! caml_string_notequal(match,cst_MetaLeft))return 88}}
          else
           {var switch$7=caml_string_compare(match,cst_KeyP);
            if(0 <= switch$7)
             {if(! (0 < switch$7))return 16;
              if(! caml_string_notequal(match,cst_KeyQ))return 17;
              if(! caml_string_notequal(match,cst_KeyR))return 18;
              if(! caml_string_notequal(match,cst_KeyS))return 19;
              if(! caml_string_notequal(match,cst_KeyT))return 20;
              if(! caml_string_notequal(match,cst_KeyU))return 21;
              if(! caml_string_notequal(match,cst_KeyV))return 22;
              if(! caml_string_notequal(match,cst_KeyW))return 23}
            else
             {if(! caml_string_notequal(match,cst_KeyI))return 9;
              if(! caml_string_notequal(match,cst_KeyJ))return 10;
              if(! caml_string_notequal(match,cst_KeyK))return 11;
              if(! caml_string_notequal(match,cst_KeyL))return 12;
              if(! caml_string_notequal(match,cst_KeyM))return 13;
              if(! caml_string_notequal(match,cst_KeyN))return 14;
              if(! caml_string_notequal(match,cst_KeyO))return 15}}}}
      else
       {var switch$8=caml_string_compare(match,cst_Digit6);
        if(0 <= switch$8)
         {if(! (0 < switch$8))return 33;
          var switch$9=caml_string_compare(match,cst_F6);
          if(0 <= switch$9)
           {if(! (0 < switch$9))return 61;
            var switch$10=caml_string_compare(match,cst_KeyA);
            if(0 <= switch$10)
             {if(! (0 < switch$10))return 1;
              if(! caml_string_notequal(match,cst_KeyB))return 2;
              if(! caml_string_notequal(match,cst_KeyC))return 3;
              if(! caml_string_notequal(match,cst_KeyD))return 4;
              if(! caml_string_notequal(match,cst_KeyE))return 5;
              if(! caml_string_notequal(match,cst_KeyF))return 6;
              if(! caml_string_notequal(match,cst_KeyG))return 7}
            else
             {if(! caml_string_notequal(match,cst_F7))return 62;
              if(! caml_string_notequal(match,cst_F8))return 63;
              if(! caml_string_notequal(match,cst_F9))return 64;
              if(! caml_string_notequal(match,cst_Home))return 100;
              if(! caml_string_notequal(match,cst_Insert))return 44;
              if(! caml_string_notequal(match,cst_IntlBackslash))return 121;
              if(! caml_string_notequal(match,cst_IntlYen))return 122}}
          else
           {var switch$11=caml_string_compare(match,cst_F1);
            if(0 <= switch$11)
             {if(! (0 < switch$11))return 56;
              if(! caml_string_notequal(match,cst_F10))return 65;
              if(! caml_string_notequal(match,cst_F11))return 66;
              if(! caml_string_notequal(match,cst_F12))return 67;
              if(! caml_string_notequal(match,cst_F2))return 57;
              if(! caml_string_notequal(match,cst_F3))return 58;
              if(! caml_string_notequal(match,cst_F4))return 59;
              if(! caml_string_notequal(match,cst_F5))return 60}
            else
             {if(! caml_string_notequal(match,cst_Digit7))return 34;
              if(! caml_string_notequal(match,cst_Digit8))return 35;
              if(! caml_string_notequal(match,cst_Digit9))return 36;
              if(! caml_string_notequal(match,cst_End))return 101;
              if(! caml_string_notequal(match,cst_Enter))return 40;
              if(! caml_string_notequal(match,cst_Equal))return 38;
              if(! caml_string_notequal(match,cst_Escape))return 42}}}
        else
         {var switch$12=caml_string_compare(match,cst_BrowserRefresh);
          if(0 <= switch$12)
           {if(! (0 < switch$12))return 113;
            var switch$13=caml_string_compare(match,cst_Delete);
            if(0 <= switch$13)
             {if(! (0 < switch$13))return 45;
              if(! caml_string_notequal(match,cst_Digit0))return 27;
              if(! caml_string_notequal(match,cst_Digit1))return 28;
              if(! caml_string_notequal(match,cst_Digit2))return 29;
              if(! caml_string_notequal(match,cst_Digit3))return 30;
              if(! caml_string_notequal(match,cst_Digit4))return 31;
              if(! caml_string_notequal(match,cst_Digit5))return 32}
            else
             {if(! caml_string_notequal(match,cst_BrowserSearch))return 110;
              if(! caml_string_notequal(match,cst_BrowserStop))return 114;
              if(! caml_string_notequal(match,cst_CapsLock))return 46;
              if(! caml_string_notequal(match,cst_Comma))return 53;
              if(! caml_string_notequal(match,cst_ContextMenu))return 109;
              if(! caml_string_notequal(match,cst_ControlLeft))return 86;
              if(! caml_string_notequal(match,cst_ControlRight))return 87}}
          else
           {var switch$14=caml_string_compare(match,cst_Backslash);
            if(0 <= switch$14)
             {if(! (0 < switch$14))return 52;
              if(! caml_string_notequal(match,cst_Backspace))return 43;
              if(! caml_string_notequal(match,cst_BracketLeft))return 47;
              if(! caml_string_notequal(match,cst_BracketRight))return 48;
              if(! caml_string_notequal(match,cst_BrowserBack))return 116;
              if(! caml_string_notequal(match,cst_BrowserFavorites))
               return 112;
              if(! caml_string_notequal(match,cst_BrowserForward))return 115;
              if(! caml_string_notequal(match,cst_BrowserHome))return 111}
            else
             {if(! caml_string_notequal(match,cst_AltLeft))return 92;
              if(! caml_string_notequal(match,cst_AltRight))return 93;
              if(! caml_string_notequal(match,cst_ArrowDown))return 97;
              if(! caml_string_notequal(match,cst_ArrowLeft))return 94;
              if(! caml_string_notequal(match,cst_ArrowRight))return 95;
              if(! caml_string_notequal(match,cst_ArrowUp))return 96;
              if(! caml_string_notequal(match,cst_Backquote))return 51}}}}
      return 0}
    function try_key_code_left(param)
     {if(19 <= param)
       {if(91 === param)return 88}
      else
       if(16 <= param)
        {var switcher=param - 16 | 0;
         switch(switcher){case 0:return 90;case 1:return 86;default:return 92}}
      return 0}
    function try_key_code_right(param)
     {if(19 <= param)
       {if(91 === param)return 89}
      else
       if(16 <= param)
        {var switcher=param - 16 | 0;
         switch(switcher){case 0:return 91;case 1:return 87;default:return 93}}
      return 0}
    function try_key_code_numpad(param)
     {if(47 <= param)
       {var switcher=param - 96 | 0;
        if(! (15 < switcher >>> 0))
         switch(switcher)
          {case 0:return 68;
           case 1:return 69;
           case 2:return 70;
           case 3:return 71;
           case 4:return 72;
           case 5:return 73;
           case 6:return 74;
           case 7:return 75;
           case 8:return 76;
           case 9:return 77;
           case 10:return 78;
           case 11:return 80;
           case 12:break;
           case 13:return 79;
           case 14:return 81;
           default:return 84}}
      else
       if(12 <= param)
        {var switcher$0=param - 12 | 0;
         switch(switcher$0)
          {case 0:return 73;
           case 1:return 83;
           case 21:return 77;
           case 22:return 71;
           case 23:return 69;
           case 24:return 75;
           case 25:return 72;
           case 26:return 76;
           case 27:return 74;
           case 28:return 70;
           case 33:return 68;
           case 34:return 81
           }}
      return 0}
    function try_key_code_normal(param)
     {var switcher=param - 8 | 0;
      if(! (214 < switcher >>> 0))
       {var _fI_=switcher;
        if(67 <= _fI_)
         switch(_fI_)
          {case 67:return 11;
           case 68:return 12;
           case 69:return 13;
           case 70:return 14;
           case 71:return 15;
           case 72:return 16;
           case 73:return 17;
           case 74:return 18;
           case 75:return 19;
           case 76:return 20;
           case 77:return 21;
           case 78:return 22;
           case 79:return 23;
           case 80:return 24;
           case 81:return 25;
           case 82:return 26;
           case 85:return 109;
           case 104:return 56;
           case 105:return 57;
           case 106:return 58;
           case 107:return 59;
           case 108:return 60;
           case 109:return 61;
           case 110:return 62;
           case 111:return 63;
           case 112:return 64;
           case 113:return 65;
           case 114:return 66;
           case 115:return 67;
           case 137:return 119;
           case 178:return 49;
           case 179:return 38;
           case 180:return 53;
           case 181:return 37;
           case 182:return 54;
           case 183:return 55;
           case 184:return 51;
           case 211:return 47;
           case 212:return 52;
           case 213:return 48;
           case 214:return 50
           }
        else
         switch(_fI_)
          {case 0:return 43;
           case 1:return 39;
           case 5:return 40;
           case 11:return 123;
           case 12:return 46;
           case 19:return 42;
           case 24:return 41;
           case 25:return 98;
           case 26:return 99;
           case 27:return 101;
           case 28:return 100;
           case 29:return 94;
           case 30:return 96;
           case 31:return 95;
           case 32:return 97;
           case 34:return 120;
           case 37:return 44;
           case 38:return 45;
           case 40:return 27;
           case 41:return 28;
           case 42:return 29;
           case 43:return 30;
           case 44:return 31;
           case 45:return 32;
           case 46:return 33;
           case 47:return 34;
           case 48:return 35;
           case 49:return 36;
           case 57:return 1;
           case 58:return 2;
           case 59:return 3;
           case 60:return 4;
           case 61:return 5;
           case 62:return 6;
           case 63:return 7;
           case 64:return 8;
           case 65:return 9;
           case 66:return 10
           }}
      return 0}
    function make_unidentified(param){return 0}
    function run_next(value,f,v){return v?v:caml_call1(f,value)}
    function symbol$11(x,f){return caml_call1(f,x)}
    function of_event(evt)
     {var _fB_=evt.keyCode;
      function _fC_(_fH_){return run_next(_fB_,try_key_code_normal,_fH_)}
      var match=evt.location,switcher=match - 1 | 0;
      if(2 < switcher >>> 0)
       var _fD_=make_unidentified;
      else
       switch(switcher)
        {case 0:
          var
           _fy_=evt.keyCode,
           _fD_=function(_fF_){return run_next(_fy_,try_key_code_left,_fF_)};
          break;
         case 1:
          var
           _fz_=evt.keyCode,
           _fD_=function(_fE_){return run_next(_fz_,try_key_code_right,_fE_)};
          break;
         default:
          var
           _fA_=evt.keyCode,
           _fD_=function(_fG_){return run_next(_fA_,try_key_code_numpad,_fG_)}}
      var value=evt.code;
      return symbol$11
              (symbol$11
                (symbol$11
                  (0,
                   function(v)
                    {return v?v:caml_call3(Optdef[7],value,make_unidentified,f)}),
                 _fD_),
               _fC_)}
    function char_of_int(value)
     {if(caml_call2(symbol$5,0,value))
       try
        {var _fw_=[0,caml_call1(Stdlib_uchar[8],value)];return _fw_}
       catch(_fx_){return 0}
      return 0}
    function empty_string(param){return ""}
    function none(param){return 0}
    function of_event$0(evt)
     {var t109=caml_call2(Optdef[8],evt.key,empty_string),match=t109.length;
      return 0 === match
              ?caml_call3(Optdef[7],evt.charCode,none,char_of_int)
              :1 === match?char_of_int(t109.charCodeAt(0) | 0):0}
    function element$1(_fv_){return _fv_}
    function tagged(e)
     {var t111=e.tagName,tag=caml_string_of_jsbytes(t111.toLowerCase());
      if(caml_call2(symbol$8,caml_ml_string_length(tag),0))return [61,e];
      var match=runtime.caml_string_unsafe_get(tag,0),switcher=match - 97 | 0;
      if(! (21 < switcher >>> 0))
       switch(switcher)
        {case 0:
          return caml_string_notequal(tag,cst_a$1)
                  ?caml_string_notequal(tag,cst_area$1)
                    ?caml_string_notequal(tag,cst_audio$1)?[61,e]:[2,e]
                    :[1,e]
                  :[0,e];
         case 1:
          return caml_string_notequal(tag,cst_base$1)
                  ?caml_string_notequal(tag,cst_blockquote$1)
                    ?caml_string_notequal(tag,cst_body$1)
                      ?caml_string_notequal(tag,cst_br$1)
                        ?caml_string_notequal(tag,cst_button$1)?[61,e]:[7,e]
                        :[6,e]
                      :[5,e]
                    :[4,e]
                  :[3,e];
         case 2:
          return caml_string_notequal(tag,cst_canvas$1)
                  ?caml_string_notequal(tag,cst_caption$1)
                    ?caml_string_notequal(tag,cst_col$1)
                      ?caml_string_notequal(tag,cst_colgroup$1)?[61,e]:[11,e]
                      :[10,e]
                    :[9,e]
                  :[8,e];
         case 3:
          return caml_string_notequal(tag,cst_del$1)
                  ?caml_string_notequal(tag,cst_div$1)
                    ?caml_string_notequal(tag,cst_dl$1)?[61,e]:[14,e]
                    :[13,e]
                  :[12,e];
         case 4:return caml_string_notequal(tag,cst_embed$1)?[61,e]:[15,e];
         case 5:
          return caml_string_notequal(tag,cst_fieldset$1)
                  ?caml_string_notequal(tag,cst_form$1)
                    ?caml_string_notequal(tag,cst_frame$1)
                      ?caml_string_notequal(tag,cst_frameset$1)?[61,e]:[18,e]
                      :[19,e]
                    :[17,e]
                  :[16,e];
         case 7:
          return caml_string_notequal(tag,cst_h1$1)
                  ?caml_string_notequal(tag,cst_h2$1)
                    ?caml_string_notequal(tag,cst_h3$1)
                      ?caml_string_notequal(tag,cst_h4$1)
                        ?caml_string_notequal(tag,cst_h5$1)
                          ?caml_string_notequal(tag,cst_h6$1)
                            ?caml_string_notequal(tag,cst_head$1)
                              ?caml_string_notequal(tag,cst_hr$1)
                                ?caml_string_notequal(tag,cst_html$1)?[61,e]:[28,e]
                                :[27,e]
                              :[26,e]
                            :[25,e]
                          :[24,e]
                        :[23,e]
                      :[22,e]
                    :[21,e]
                  :[20,e];
         case 8:
          return caml_string_notequal(tag,cst_iframe$1)
                  ?caml_string_notequal(tag,cst_img$1)
                    ?caml_string_notequal(tag,cst_input$2)
                      ?caml_string_notequal(tag,cst_ins$1)?[61,e]:[32,e]
                      :[31,e]
                    :[30,e]
                  :[29,e];
         case 11:
          return caml_string_notequal(tag,cst_label$1)
                  ?caml_string_notequal(tag,cst_legend$1)
                    ?caml_string_notequal(tag,cst_li$1)
                      ?caml_string_notequal(tag,cst_link$1)?[61,e]:[36,e]
                      :[35,e]
                    :[34,e]
                  :[33,e];
         case 12:
          return caml_string_notequal(tag,cst_map$1)
                  ?caml_string_notequal(tag,cst_meta$1)?[61,e]:[38,e]
                  :[37,e];
         case 14:
          return caml_string_notequal(tag,cst_object$1)
                  ?caml_string_notequal(tag,cst_ol$1)
                    ?caml_string_notequal(tag,cst_optgroup$1)
                      ?caml_string_notequal(tag,cst_option$1)?[61,e]:[42,e]
                      :[41,e]
                    :[40,e]
                  :[39,e];
         case 15:
          return caml_string_notequal(tag,cst_p$1)
                  ?caml_string_notequal(tag,cst_param$1)
                    ?caml_string_notequal(tag,cst_pre$1)?[61,e]:[45,e]
                    :[44,e]
                  :[43,e];
         case 16:return caml_string_notequal(tag,cst_q$1)?[61,e]:[46,e];
         case 18:
          return caml_string_notequal(tag,cst_script$1)
                  ?caml_string_notequal(tag,cst_select$2)
                    ?caml_string_notequal(tag,cst_style$1)?[61,e]:[49,e]
                    :[48,e]
                  :[47,e];
         case 19:
          return caml_string_notequal(tag,cst_table$1)
                  ?caml_string_notequal(tag,cst_tbody$1)
                    ?caml_string_notequal(tag,cst_td$1)
                      ?caml_string_notequal(tag,cst_textarea$1)
                        ?caml_string_notequal(tag,cst_tfoot$1)
                          ?caml_string_notequal(tag,cst_th$1)
                            ?caml_string_notequal(tag,cst_thead$1)
                              ?caml_string_notequal(tag,cst_title$1)
                                ?caml_string_notequal(tag,cst_tr$1)?[61,e]:[58,e]
                                :[57,e]
                              :[56,e]
                            :[55,e]
                          :[54,e]
                        :[53,e]
                      :[52,e]
                    :[51,e]
                  :[50,e];
         case 20:return caml_string_notequal(tag,cst_ul$1)?[61,e]:[59,e];
         case 21:return caml_string_notequal(tag,cst_video$1)?[61,e]:[60,e]
         }
      return [61,e]}
    function opt_tagged(e)
     {function _ft_(e){return [0,tagged(e)]}
      function _fu_(param){return 0}
      return caml_call3(Opt[7],e,_fu_,_ft_)}
    function taggedEvent(ev)
     {function _fe_(ev){return [0,ev]}
      function _ff_(param)
       {function _fh_(ev){return [1,ev]}
        function _fi_(param)
         {function _fk_(ev){return [2,ev]}
          function _fl_(param)
           {function _fn_(ev){return [3,ev]}
            function _fo_(param)
             {function _fq_(ev){return [4,ev]}
              function _fr_(param){return [5,ev]}
              var _fs_=popStateEvent(ev);
              return caml_call3(Opt[7],_fs_,_fr_,_fq_)}
            var _fp_=mouseScrollEvent(ev);
            return caml_call3(Opt[7],_fp_,_fo_,_fn_)}
          var _fm_=wheelEvent(ev);
          return caml_call3(Opt[7],_fm_,_fl_,_fk_)}
        var _fj_=keyboardEvent(ev);
        return caml_call3(Opt[7],_fj_,_fi_,_fh_)}
      var _fg_=mouseEvent(ev);
      return caml_call3(Opt[7],_fg_,_ff_,_fe_)}
    function opt_taggedEvent(ev)
     {function _fc_(ev){return [0,taggedEvent(ev)]}
      function _fd_(param){return 0}
      return caml_call3(Opt[7],ev,_fd_,_fc_)}
    function stopPropagation(ev)
     {function _fa_(param){return ev.stopPropagation()}
      function _fb_(param){return ev.cancelBubble = t25}
      return caml_call3(Optdef[7],ev.stopPropagation,_fb_,_fa_)}
    var
     requestAnimationFrame=
      runtime.caml_js_pure_expr
       (function(param)
         {var
           l=
            [0,
             _i_.requestAnimationFrame,
             [0,
              _i_.mozRequestAnimationFrame,
              [0,
               _i_.webkitRequestAnimationFrame,
               [0,
                _i_.oRequestAnimationFrame,
                [0,_i_.msRequestAnimationFrame,0]]]]];
          try
           {var
             _e9_=function(c){return caml_call1(Optdef[5],c)},
             req=caml_call2(Stdlib_list[38],_e9_,l),
             _e__=function(callback){return req(callback)};
            return _e__}
          catch(_e$_)
           {_e$_ = caml_wrap_exception(_e$_);
            if(_e$_ === Stdlib[8])
             {var
               now=function(param){var t122=new t121();return t122.getTime()},
               last=[0,now(0)];
              return function(callback)
               {var
                 t=now(0),
                 dt=last[1] + 16.6666666666666679 - t,
                 dt$0=dt < 0.?0.:dt;
                last[1] = t;
                _i_.setTimeout(callback,dt$0);
                return 0}}
            throw _e$_}});
    function hasPushState(param)
     {return caml_call1(Optdef[5],_i_.history.pushState)}
    function hasPlaceholder(param)
     {var i=createInput(0,0,t22);return caml_call1(Optdef[5],i.placeholder)}
    function hasRequired(param)
     {var i=createInput(0,0,t22);return caml_call1(Optdef[5],i.required)}
    var overflow_limit=2147483000.;
    function setTimeout(callback,d)
     {var id=[0,0];
      function loop(step,param)
       {if(2147483000. < step)
         var remain=step - 2147483000.,step$0=overflow_limit;
        else
         var remain=0.,step$0=step;
        var
         cb=remain == 0.?callback:function(_e8_){return loop(remain,_e8_)},
         t130=caml_js_wrap_callback(cb);
        id[1] = [0,_i_.setTimeout(t130,step$0)];
        return 0}
      loop(d,0);
      return id}
    function clearTimeout(id)
     {var _e7_=id[1];
      if(_e7_){var x=_e7_[1];id[1] = 0;return _i_.clearTimeout(x)}
      return 0}
    function js_array_of_collection(c){return [].slice.call(c)}
    var
     Js_of_ocaml_Dom_html=
      [0,
       d,
       t22,
       getElementById_opt,
       getElementById_exn,
       getElementById_coerce,
       getElementById,
       location_origin,
       _i_,
       no_handler,
       handler,
       full_handler,
       invoke_handler,
       eventTarget,
       eventRelatedTarget,
       Event$0,
       addEventListenerWithOptions,
       addEventListener,
       removeEventListener,
       addMousewheelEventListenerWith,
       addMousewheelEventListener,
       createCustomEvent,
       buttonPressed,
       eventAbsolutePosition$0,
       elementClientPosition,
       getDocumentScroll,
       [0,of_event,try_key_code_normal],
       [0,of_event$0],
       createHtml,
       createHead,
       createLink,
       createTitle,
       createMeta,
       createBase,
       createStyle,
       createBody,
       createForm,
       createOptgroup,
       createOption,
       createSelect,
       createInput,
       createTextarea,
       createButton,
       createLabel,
       createFieldset,
       createLegend,
       createUl,
       createOl,
       createDl,
       createLi,
       createDiv,
       createEmbed,
       createP,
       createH1,
       createH2,
       createH3,
       createH4,
       createH5,
       createH6,
       createQ,
       createBlockquote,
       createPre,
       createBr,
       createHr,
       createIns,
       createDel,
       createA,
       createImg,
       createObject,
       createParam,
       createMap,
       createArea,
       createScript,
       createTable,
       createCaption,
       createCol,
       createColgroup,
       createThead,
       createTfoot,
       createTbody,
       createTr,
       createTh,
       createTd,
       createSub,
       createSup,
       createSpan,
       createTt,
       createI,
       createB,
       createBig,
       createSmall,
       createEm,
       createStrong,
       createCite,
       createDfn,
       createCode,
       createSamp,
       createKbd,
       createVar,
       createAbbr,
       createDd,
       createDt,
       createNoscript,
       createAddress,
       createFrameset,
       createFrame,
       createIframe,
       createAudio,
       createVideo,
       Canvas_not_available,
       createCanvas,
       element$1,
       tagged,
       opt_tagged,
       taggedEvent,
       opt_taggedEvent,
       stopPropagation,
       [0,
        element$0,
        a,
        area,
        audio,
        base,
        blockquote,
        body,
        br,
        button,
        canvas,
        caption,
        col,
        colgroup,
        del,
        div,
        embed,
        dl,
        fieldset,
        form,
        frameset,
        frame,
        h1,
        h2,
        h3,
        h4,
        h5,
        h6,
        head,
        hr,
        html,
        iframe,
        img,
        input$0,
        ins,
        label,
        legend,
        li,
        link,
        map$2,
        meta,
        object,
        ol,
        optgroup,
        option$1,
        p,
        param,
        pre,
        q,
        script,
        select$0,
        style,
        table,
        tbody,
        td,
        textarea,
        tfoot,
        th,
        thead,
        title,
        tr,
        ul,
        video,
        mouseEvent,
        keyboardEvent,
        wheelEvent,
        mouseScrollEvent,
        popStateEvent],
       setTimeout,
       clearTimeout,
       js_array_of_collection,
       requestAnimationFrame,
       runtime.caml_js_html_entities,
       onIE,
       hasPushState,
       hasPlaceholder,
       hasRequired];
    caml_register_global(1648,Js_of_ocaml_Dom_html,"Js_of_ocaml__Dom_html");
    var formData=Unsafe[1].FormData,formData_form=Unsafe[1].FormData;
    function filter_map$0(f,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var q=param$0[2],v=param$0[1],match=caml_call1(f,v);
          if(match){var v$0=match[1];return [0,v$0,filter_map$0(f,q)]}
          var param$0=q;
          continue}
        return 0}}
    function have_content(elt)
     {var
       _e5_=caml_call2(symbol$9,elt.name.length,0),
       _e6_=_e5_?1 - (elt.disabled | 0):_e5_;
      return _e6_}
    function form_elements(get,form)
     {var length=form.elements.length;
      function _eT_(i)
       {var t34=form.elements,_e4_=t34.item(i);
        return caml_call1(Opt[10],_e4_)}
      var
       _eU_=caml_call2(Stdlib_array[2],length,_eT_),
       elements=caml_call1(Stdlib_array[11],_eU_);
      function _eV_(param)
       {if(param)
         {var v=param[1],match$3=tagged(v);
          switch(match$3[0])
           {case 31:
             var v$0=match$3[1];
             if(get)var sth=get[1],get$0=sth;else var get$0=0;
             if(have_content(v$0))
              {var
                name$1=caml_string_of_jsstring(v$0.name),
                value=v$0.value,
                t20=v$0.type,
                match=caml_string_of_jsbytes(t20.toLowerCase());
               if(caml_string_notequal(match,cst_checkbox))
                {if(! caml_string_notequal(match,cst_file))
                  {if(get$0)return [0,[0,name$1,[0,-976970511,value]],0];
                   var match$0=caml_call1(Optdef[10],v$0.files);
                   if(match$0)
                    {var list=match$0[1];
                     if(caml_call2(symbol$8,list.length,0))
                      return [0,[0,name$1,[0,-976970511,""]],0];
                     var match$1=caml_call1(Optdef[10],v$0.multiple);
                     if(match$1 && match$1[1])
                      {var
                        _eZ_=function(t28){return list.item(t28)},
                        _e0_=caml_call2(Stdlib_array[2],list.length,_eZ_),
                        _e1_=caml_call1(Stdlib_array[11],_e0_);
                       return filter_map$0
                               (function(f)
                                 {var match=caml_call1(Opt[10],f);
                                  if(match)
                                   {var file=match[1];return [0,[0,name$1,[0,781515420,file]]]}
                                  return 0},
                                _e1_)}
                     var _e2_=list.item(0),match$2=caml_call1(Opt[10],_e2_);
                     if(match$2)
                      {var file=match$2[1];
                       return [0,[0,name$1,[0,781515420,file]],0]}
                     return 0}
                   return 0}
                 var switch$0=0;
                 if(caml_string_notequal(match,cst_password))
                  {if(caml_string_notequal(match,cst_radio))
                    {var switch$1=0;
                     if
                      (caml_string_notequal(match,cst_reset)
                       &&
                       caml_string_notequal(match,cst_submit$0))
                      {if(caml_string_notequal(match,cst_text))
                        return [0,[0,name$1,[0,-976970511,value]],0];
                       switch$0 = 1;
                       switch$1 = 1}
                     if(! switch$1)return 0}}
                 else
                  switch$0 = 1;
                 if(switch$0)return [0,[0,name$1,[0,-976970511,value]],0]}
               return v$0.checked | 0?[0,[0,name$1,[0,-976970511,value]],0]:0}
             return 0;
            case 48:
             var v$1=match$3[1];
             if(have_content(v$1))
              {var name$0=caml_string_of_jsstring(v$1.name);
               if(v$1.multiple | 0)
                {var
                  _eX_=
                   function(i)
                    {var t13=v$1.options,_e3_=t13.item(i);
                     return caml_call1(Opt[10],_e3_)},
                  options=caml_call2(Stdlib_array[2],v$1.options.length,_eX_),
                  _eY_=caml_call1(Stdlib_array[11],options);
                 return filter_map$0
                         (function(param)
                           {if(param)
                             {var e=param[1];
                              return e.selected | 0
                                      ?[0,[0,name$0,[0,-976970511,e.value]]]
                                      :0}
                            return 0},
                          _eY_)}
               return [0,[0,name$0,[0,-976970511,v$1.value]],0]}
             return 0;
            case 53:
             var v$2=match$3[1];
             if(have_content(v$2))
              {var name=caml_string_of_jsstring(v$2.name);
               return [0,[0,name,[0,-976970511,v$2.value]],0]}
             return 0;
            default:return 0}}
        return 0}
      var
       _eW_=caml_call2(Stdlib_list[19],_eV_,elements),
       contents=caml_call1(Stdlib_list[14],_eW_);
      return contents}
    function append(form_contents,form_elt)
     {if(891486873 <= form_contents[1])
       {var list=form_contents[2];list[1] = [0,form_elt,list[1]];return 0}
      var f=form_contents[2],_eR_=form_elt[2],_eS_=form_elt[1];
      if(781515420 <= _eR_[1])
       {var file=_eR_[2],t38=caml_jsstring_of_string(_eS_);
        return f.append(t38,file)}
      var s=_eR_[2],t35=caml_jsstring_of_string(_eS_);
      return f.append(t35,s)}
    function empty_form_contents(param)
     {var match=caml_call1(Optdef[10],formData);
      if(match){var constr=match[1];return [0,808620462,new constr()]}
      return [0,891486873,[0,0]]}
    function post_form_contents(form)
     {var contents=empty_form_contents(0),_eO_=form_elements(0,form);
      function _eP_(_eQ_){return append(contents,_eQ_)}
      caml_call2(Stdlib_list[17],_eP_,_eO_);
      return contents}
    function get_form_contents(form)
     {var _eL_=form_elements(_m_,form);
      function _eM_(param)
       {var _eN_=param[2];
        if(typeof _eN_ !== "number" && -976970511 === _eN_[1])
         {var s=_eN_[2],name=param[1];
          return [0,name,caml_string_of_jsstring(s)]}
        throw [0,Assert_failure,_n_]}
      return caml_call2(Stdlib_list[19],_eM_,_eL_)}
    var
     Js_of_ocaml_Form=
      [0,
       formData,
       formData_form,
       append,
       post_form_contents,
       get_form_contents,
       empty_form_contents,
       form_elements];
    caml_register_global(1649,Js_of_ocaml_Form,"Js_of_ocaml__Form");
    var
     readystatechange=caml_call1(Event[1],cst_readystatechange),
     loadstart$1=caml_call1(Event[1],cst_loadstart$1),
     progress$1=caml_call1(Event[1],cst_progress$1),
     abort$1=caml_call1(Event[1],cst_abort$1),
     error$1=caml_call1(Event[1],cst_error$1),
     load$1=caml_call1(Event[1],cst_load$1),
     timeout=caml_call1(Event[1],cst_timeout),
     loadend$0=caml_call1(Event[1],cst_loadend$0),
     Event$1=
      [0,
       readystatechange,
       loadstart$1,
       progress$1,
       abort$1,
       error$1,
       load$1,
       timeout,
       loadend$0],
     Js_of_ocaml_XmlHttpRequest=[0,runtime.caml_xmlhttprequest_create,Event$1];
    caml_register_global
     (1650,Js_of_ocaml_XmlHttpRequest,"Js_of_ocaml__XmlHttpRequest");
    var t2=Unsafe[1].Worker;
    function create(script)
     {var t1=caml_jsstring_of_string(script);return new t2(t1)}
    function import_scripts(scripts)
     {if(Unsafe[1].importScripts === t39)
       caml_call1(Stdlib[1],cst_Worker_import_scripts_is_u);
      var _eI_=caml_call1(Stdlib_array[12],scripts);
      function _eJ_(s){return caml_jsstring_of_string(s)}
      var _eK_=caml_call2(Stdlib_array[15],_eJ_,_eI_);
      return runtime.caml_js_fun_call(Unsafe[1].importScripts,_eK_)}
    function set_onmessage(handler)
     {if(Unsafe[1].onmessage === t39)
       caml_call1(Stdlib[1],cst_Worker_onmessage_is_undefi);
      function js_handler(ev){return caml_call1(handler,ev.data)}
      return Unsafe[1].onmessage = caml_js_wrap_callback(js_handler)}
    function post_message(t10)
     {if(Unsafe[1].postMessage === t39)
       caml_call1(Stdlib[1],cst_Worker_onmessage_is_undefi$0);
      return Unsafe[1].postMessage(t10)}
    var
     Js_of_ocaml_Worker=
      [0,create,import_scripts,set_onmessage,post_message];
    caml_register_global(1651,Js_of_ocaml_Worker,"Js_of_ocaml__Worker");
    var webSocket=Unsafe[1].WebSocket;
    function is_supported(param){return caml_call1(Optdef[5],webSocket)}
    var Js_of_ocaml_WebSockets=[0,webSocket,webSocket,webSocket,is_supported];
    caml_register_global
     (1652,Js_of_ocaml_WebSockets,"Js_of_ocaml__WebSockets");
    var
     defaultContextAttributes=
      {"alpha":t25,
       "depth":t25,
       "stencil":t4,
       "antialias":t25,
       "premultipliedAlpha":t4,
       "preserveDrawingBuffer":t4,
       "preferLowPowerToHighPerformance":t4,
       "failIfMajorPerformanceCaveat":t4},
     webglcontextlost=caml_call1(Event$0[86],cst_webglcontextlost),
     webglcontextrestored=caml_call1(Event$0[86],cst_webglcontextrestored),
     webglcontextcreationerror=
      caml_call1(Event$0[86],cst_webglcontextcreationerror),
     Event$2=
      [0,webglcontextlost,webglcontextrestored,webglcontextcreationerror];
    function getContext(t3)
     {var ctx=t3.getContext("webgl");
      return caml_call1(Opt[5],ctx)?ctx:t3.getContext("experimental-webgl")}
    function getContextWithAttributes(t9,t8)
     {var ctx=t9.getContext("webgl",t8);
      return caml_call1(Opt[5],ctx)?ctx:t9.getContext("experimental-webgl",t8)}
    var
     Js_of_ocaml_WebGL=
      [0,defaultContextAttributes,Event$2,getContext,getContextWithAttributes];
    caml_register_global(1653,Js_of_ocaml_WebGL,"Js_of_ocaml__WebGL");
    function regexp(s)
     {var t0=caml_jsbytes_of_string(s);return new t11(t0,"g")}
    function regexp_case_fold(s)
     {var t3=caml_jsbytes_of_string(s);return new t11(t3,"gi")}
    function regexp_with_flag(s,f)
     {var
       t7=caml_jsstring_of_string(caml_call2(Stdlib[28],cst_g,f)),
       t6=caml_jsbytes_of_string(s);
      return new t11(t6,t7)}
    function blunt_str_array_get(a,i)
     {function _eH_(param){throw [0,Assert_failure,_o_]}
      return caml_string_of_jsbytes(caml_call2(Optdef[8],a[i],_eH_))}
    function string_match(r,s,i)
     {r.lastIndex = i;
      var
       t11=caml_jsbytes_of_string(s),
       _eF_=r.exec(t11),
       _eG_=caml_call2(Opt[3],_eF_,match_result);
      return caml_call1(Opt[10],_eG_)}
    function search_forward(r,s,i)
     {r.lastIndex = i;
      var t15=caml_jsbytes_of_string(s);
      function _eC_(res){return [0,res.index,res]}
      var _eD_=r.exec(t15),_eE_=caml_call2(Opt[3],_eD_,_eC_);
      return caml_call1(Opt[10],_eE_)}
    function matched_string(r){return blunt_str_array_get(r,0)}
    function matched_group(r,i)
     {var _eB_=caml_call2(Optdef[3],r[i],caml_string_of_jsbytes);
      return caml_call1(Optdef[10],_eB_)}
    var t21=new t11("[$]","g");
    function quote_repl(s)
     {var t23=caml_jsbytes_of_string(s);return t23.replace(t21,"$$$$")}
    function global_replace(r,s,s_by)
     {r.lastIndex = 0;
      var t27=quote_repl(s_by),t28=caml_jsbytes_of_string(s);
      return caml_string_of_jsbytes(t28.replace(r,t27))}
    function replace_first(r,s,s_by)
     {var
       match=r.ignoreCase | 0,
       match$0=r.multiline | 0,
       flags=match?match$0?"mi":"i":match$0?"m":"",
       t32=r.source,
       t35=new t11(t32,flags),
       t36=quote_repl(s_by),
       t37=caml_jsbytes_of_string(s);
      return caml_string_of_jsbytes(t37.replace(t35,t36))}
    function list_of_js_array(a)
     {var idx$1=a.length - 1 | 0,accu=0,idx=idx$1;
      for(;;)
       {if(caml_call2(symbol$5,idx,0))return accu;
        var
         idx$0=idx - 1 | 0,
         accu$0=[0,blunt_str_array_get(a,idx),accu],
         accu=accu$0,
         idx=idx$0;
        continue}}
    function split(r,s)
     {r.lastIndex = 0;
      var t42=caml_jsbytes_of_string(s);
      return list_of_js_array(t42.split(r))}
    function bounded_split(r,s,i)
     {r.lastIndex = 0;
      var t47=caml_jsbytes_of_string(s);
      return list_of_js_array(t47.split(r,i))}
    var t48=regexp(cst);
    function quote(s)
     {var t50=caml_jsbytes_of_string(s);
      return caml_string_of_jsbytes(t50.replace(t48,"\\$&"))}
    function regexp_string(s){return regexp(quote(s))}
    function regexp_string_case_fold(s){return regexp_case_fold(quote(s))}
    var
     Js_of_ocaml_Regexp=
      [0,
       regexp,
       regexp_case_fold,
       regexp_with_flag,
       quote,
       regexp_string,
       regexp_string_case_fold,
       string_match,
       search_forward,
       search_forward,
       matched_string,
       matched_group,
       global_replace,
       replace_first,
       split,
       bounded_split];
    caml_register_global(1654,Js_of_ocaml_Regexp,"Js_of_ocaml__Regexp");
    var Local_exn=[248,cst_Js_of_ocaml_Url_Local_exn,caml_fresh_oo_id(0)];
    function interrupt(param){throw Local_exn}
    var plus_re=regexp_string(cst$0),t14=new t11("\\+","g");
    function urldecode_js_string_string(s)
     {t14.lastIndex = 0;
      return caml_string_of_jsbytes(unescape(s.replace(t14," ")))}
    function urldecode(s)
     {return caml_string_of_jsbytes
              (unescape
                (caml_jsbytes_of_string(global_replace(plus_re,s,cst$1))))}
    function urlencode(opt,s)
     {if(opt)var sth=opt[1],with_plus=sth;else var with_plus=1;
      if(with_plus)
       {var s$0=caml_string_of_jsbytes(escape(caml_jsbytes_of_string(s)));
        return global_replace(plus_re,s$0,cst_2B)}
      return caml_string_of_jsbytes(escape(caml_jsbytes_of_string(s)))}
    var
     Not_an_http_protocol=
      [248,cst_Js_of_ocaml_Url_Not_an_htt,caml_fresh_oo_id(0)],
     default_http_port=80,
     default_https_port=443;
    function path_of_path_string(s)
     {var l=caml_ml_string_length(s);
      function aux(i)
       {try
         {var _ez_=caml_call3(String[20],s,i,47),j=_ez_}
        catch(_eA_)
         {_eA_ = caml_wrap_exception(_eA_);
          if(_eA_ !== Stdlib[8])throw _eA_;
          var j=l}
        var word=caml_call3(String[8],s,i,j - i | 0);
        return caml_call2(symbol$10,j,l)?[0,word,0]:[0,word,aux(j + 1 | 0)]}
      var a=aux(0);
      if(a && ! caml_string_notequal(a[1],cst$2))
       {var _ey_=a[2];
        if(! _ey_)return 0;
        if(! caml_string_notequal(_ey_[1],cst$3) && ! _ey_[2])return _p_}
      return a}
    function encode_arguments(l)
     {function _et_(param)
       {var
         v=param[2],
         n=param[1],
         _ev_=urlencode(0,v),
         _ew_=caml_call2(Stdlib[28],cst$4,_ev_),
         _ex_=urlencode(0,n);
        return caml_call2(Stdlib[28],_ex_,_ew_)}
      var _eu_=caml_call2(Stdlib_list[19],_et_,l);
      return caml_call2(String[3],cst$5,_eu_)}
    function decode_arguments_js_string(s)
     {var
       t0=caml_jsstring_of_string(caml_call2(String[1],1,38)),
       arr=s.split(t0),
       len=arr.length;
      function aux(acc,idx)
       {var idx$0=idx;
        for(;;)
         {if(caml_call2(symbol$5,idx$0,0))return acc;
          try
           {var
             _el_=idx$0 - 1 | 0,
             _em_=
              function(s)
               {function _er_(param)
                 {var
                   y=param[2],
                   x=param[1],
                   _es_=urldecode_js_string_string(y);
                  return [0,urldecode_js_string_string(x),_es_]}
                var
                 t2=caml_jsstring_of_string(caml_call2(String[1],1,61)),
                 t5=s.indexOf(t2);
                if(caml_call2(symbol$5,t5,0))
                 var _eq_=t39;
                else
                 var
                  t7=t5 + 1 | 0,
                  _ep_=s.slice(t7),
                  _eq_=[0,s.slice(0,t5),_ep_];
                return caml_call3(Optdef[7],_eq_,interrupt,_er_)},
             _en_=
              aux
               ([0,caml_call3(Optdef[7],arr[idx$0],interrupt,_em_),acc],_el_);
            return _en_}
          catch(_eo_)
           {_eo_ = caml_wrap_exception(_eo_);
            if(_eo_ === Local_exn)
             {var idx$1=idx$0 - 1 | 0,idx$0=idx$1;continue}
            throw _eo_}}}
      return aux(0,len - 1 | 0)}
    function decode_arguments(s)
     {return decode_arguments_js_string(caml_jsbytes_of_string(s))}
    var
     t19=caml_jsbytes_of_string(cst_Hh_Tt_Tt_Pp_Ss_0_9a_zA_Z_0),
     t24=new t11(t19),
     t21$0=caml_jsbytes_of_string(cst_Ff_Ii_Ll_Ee),
     t26=new t11(t21$0);
    function url_of_js_string(s)
     {function _d4_(res)
       {var
         prot_string=caml_call2(Optdef[8],res[1],interrupt),
         match=caml_string_of_jsbytes(prot_string.toLowerCase());
        if
         (caml_string_notequal(match,cst_file$0)
          &&
          caml_string_notequal(match,cst_file$1))
         {var switch$0=0;
          if
           (caml_string_notequal(match,cst_http)
            &&
            caml_string_notequal(match,cst_http$0))
           {var switch$1=0;
            if
             (caml_string_notequal(match,cst_https)
              &&
              caml_string_notequal(match,cst_https$0))
             switch$1 = 1;
            if(! switch$1){var ssl=1;switch$0 = 2}}
          else
           switch$0 = 1;
          var switch$2=0;
          switch(switch$0)
           {case 1:var ssl=0;switch$2 = 1;break;
            case 0:break;
            default:switch$2 = 1}
          if(switch$2)
           {var
             _ec_=function(param){return caml_jsbytes_of_string(cst$7)},
             path_str=
              urldecode_js_string_string(caml_call2(Optdef[8],res[6],_ec_)),
             _ed_=function(param){return caml_jsbytes_of_string(cst$8)},
             _ee_=
              urldecode_js_string_string(caml_call2(Optdef[8],res[10],_ed_)),
             _ef_=function(param){return caml_jsbytes_of_string(cst$9)},
             _eg_=
              decode_arguments_js_string(caml_call2(Optdef[8],res[8],_ef_)),
             _eh_=path_of_path_string(path_str),
             _ei_=function(param){return caml_jsbytes_of_string(cst$10)},
             s=caml_string_of_jsbytes(caml_call2(Optdef[8],res[4],_ei_)),
             _ej_=
              caml_string_notequal(s,cst$6)?caml_int_of_string(s):ssl?443:80,
             url=
              [0,
               urldecode_js_string_string
                (caml_call2(Optdef[8],res[2],interrupt)),
               _ej_,
               _eh_,
               path_str,
               _eg_,
               _ee_],
             _ek_=ssl?[1,url]:[0,url];
            return [0,_ek_]}}
        throw Not_an_http_protocol}
      function _d5_(param)
       {function _d7_(res)
         {var
           path_str=
            urldecode_js_string_string(caml_call2(Optdef[8],res[2],interrupt));
          function _d__(param){return caml_jsbytes_of_string(cst$11)}
          var _d$_=caml_string_of_jsbytes(caml_call2(Optdef[8],res[6],_d__));
          function _ea_(param){return caml_jsbytes_of_string(cst$12)}
          var
           _eb_=
            decode_arguments_js_string(caml_call2(Optdef[8],res[4],_ea_));
          return [0,[2,[0,path_of_path_string(path_str),path_str,_eb_,_d$_]]]}
        function _d8_(param){return 0}
        var _d9_=t26.exec(s);
        return caml_call3(Opt[7],_d9_,_d8_,_d7_)}
      var _d6_=t24.exec(s);
      return caml_call3(Opt[7],_d6_,_d5_,_d4_)}
    function url_of_string(s)
     {return url_of_js_string(caml_jsbytes_of_string(s))}
    function string_of_url(param)
     {switch(param[0])
       {case 0:
         var
          match=param[1],
          frag=match[6],
          args=match[5],
          path=match[3],
          port=match[2],
          host=match[1];
         if(caml_string_notequal(frag,cst$13))
          var _dr_=urlencode(0,frag),_ds_=caml_call2(Stdlib[28],cst$14,_dr_);
         else
          var _ds_=cst$21;
         if(args)
          var
           _dt_=encode_arguments(args),
           _du_=caml_call2(Stdlib[28],cst$15,_dt_);
         else
          var _du_=cst$20;
         var
          _dv_=caml_call2(Stdlib[28],_du_,_ds_),
          _dw_=function(x){return urlencode(0,x)},
          _dx_=caml_call2(Stdlib_list[19],_dw_,path),
          _dy_=caml_call2(String[3],cst$16,_dx_),
          _dz_=caml_call2(Stdlib[28],_dy_,_dv_),
          _dA_=caml_call2(Stdlib[28],cst$17,_dz_);
         if(80 === port)
          var _dB_=cst$18;
         else
          var
           _dF_=caml_call1(Stdlib[33],port),
           _dB_=caml_call2(Stdlib[28],cst$19,_dF_);
         var
          _dC_=caml_call2(Stdlib[28],_dB_,_dA_),
          _dD_=urlencode(0,host),
          _dE_=caml_call2(Stdlib[28],_dD_,_dC_);
         return caml_call2(Stdlib[28],cst_http$1,_dE_);
        case 1:
         var
          match$0=param[1],
          frag$0=match$0[6],
          args$0=match$0[5],
          path$0=match$0[3],
          port$0=match$0[2],
          host$0=match$0[1];
         if(caml_string_notequal(frag$0,cst$22))
          var
           _dG_=urlencode(0,frag$0),
           _dH_=caml_call2(Stdlib[28],cst$23,_dG_);
         else
          var _dH_=cst$30;
         if(args$0)
          var
           _dI_=encode_arguments(args$0),
           _dJ_=caml_call2(Stdlib[28],cst$24,_dI_);
         else
          var _dJ_=cst$29;
         var
          _dK_=caml_call2(Stdlib[28],_dJ_,_dH_),
          _dL_=function(x){return urlencode(0,x)},
          _dM_=caml_call2(Stdlib_list[19],_dL_,path$0),
          _dN_=caml_call2(String[3],cst$25,_dM_),
          _dO_=caml_call2(Stdlib[28],_dN_,_dK_),
          _dP_=caml_call2(Stdlib[28],cst$26,_dO_);
         if(443 === port$0)
          var _dQ_=cst$27;
         else
          var
           _dU_=caml_call1(Stdlib[33],port$0),
           _dQ_=caml_call2(Stdlib[28],cst$28,_dU_);
         var
          _dR_=caml_call2(Stdlib[28],_dQ_,_dP_),
          _dS_=urlencode(0,host$0),
          _dT_=caml_call2(Stdlib[28],_dS_,_dR_);
         return caml_call2(Stdlib[28],cst_https$1,_dT_);
        default:
         var
          match$1=param[1],
          frag$1=match$1[4],
          args$1=match$1[3],
          path$1=match$1[1];
         if(caml_string_notequal(frag$1,cst$31))
          var
           _dV_=urlencode(0,frag$1),
           _dW_=caml_call2(Stdlib[28],cst$32,_dV_);
         else
          var _dW_=cst$36;
         if(args$1)
          var
           _dX_=encode_arguments(args$1),
           _dY_=caml_call2(Stdlib[28],cst$33,_dX_);
         else
          var _dY_=cst$35;
         var
          _dZ_=caml_call2(Stdlib[28],_dY_,_dW_),
          _d0_=function(x){return urlencode(0,x)},
          _d1_=caml_call2(Stdlib_list[19],_d0_,path$1),
          _d2_=caml_call2(String[3],cst$34,_d1_),
          _d3_=caml_call2(Stdlib[28],_d2_,_dZ_);
         return caml_call2(Stdlib[28],cst_file$2,_d3_)}}
    var _q_=caml_call1(Optdef[2],_i_.location);
    if(caml_call1(Optdef[5],_q_))
     var _r_=_i_.location;
    else
     var
      t42=function(param,_dq_){return 0},
      t41=function(param,_dp_){return 0},
      t40=function(param){return 0},
      _r_=
       {"href":"",
        "protocol":"",
        "host":"",
        "hostname":"",
        "port":"",
        "pathname":"",
        "search":"",
        "hash":"",
        "origin":t39,
        "reload":caml_js_wrap_meth_callback(t40),
        "replace":caml_js_wrap_meth_callback(t41),
        "assign":caml_js_wrap_meth_callback(t42)};
    var
     host=urldecode_js_string_string(_r_.hostname),
     protocol=urldecode_js_string_string(_r_.protocol),
     _s_=0,
     port=
      function(param)
        {try
          {var _dn_=[0,caml_int_of_string(caml_string_of_jsbytes(_r_.port))];
           return _dn_}
         catch(_do_)
          {_do_ = caml_wrap_exception(_do_);
           if(_do_[1] === Stdlib[7])return 0;
           throw _do_}}
       (_s_),
     path_string=urldecode_js_string_string(_r_.pathname),
     path=path_of_path_string(path_string),
     t49=_r_.search;
    if(t49.charAt(0) === "?")
     var t52=_r_.search,_t_=t52.slice(1);
    else
     var _t_=_r_.search;
    var arguments$0=decode_arguments_js_string(_t_);
    function get_fragment(param)
     {function _dk_(res){return caml_string_of_jsstring(res[1])}
      function _dl_(param){return cst$37}
      var t57=new t11("#(.*)"),t58=_r_.href,_dm_=t58.match(t57);
      return caml_call3(Opt[7],_dm_,_dl_,_dk_)}
    function set_fragment(s)
     {return _r_.hash = caml_jsbytes_of_string(urlencode(0,s))}
    function get$2(param){return url_of_js_string(_r_.href)}
    function set$0(u)
     {return _r_.href = caml_jsbytes_of_string(string_of_url(u))}
    var
     as_string=urldecode_js_string_string(_r_.href),
     Js_of_ocaml_Url=
      [0,
       urldecode,
       urlencode,
       default_http_port,
       default_https_port,
       path_of_path_string,
       encode_arguments,
       decode_arguments,
       url_of_string,
       string_of_url,
       [0,
        host,
        port,
        protocol,
        path_string,
        path,
        arguments$0,
        get_fragment,
        set_fragment,
        get$2,
        set$0,
        as_string]];
    caml_register_global(1656,Js_of_ocaml_Url,"Js_of_ocaml__Url");
    var Js_of_ocaml_Lib_version=[0,s,git_version];
    caml_register_global
     (1657,Js_of_ocaml_Lib_version,"Js_of_ocaml__Lib_version");
    function update_file(name,content)
     {var oc=caml_call1(Stdlib[60],name);
      caml_call2(Stdlib[66],oc,content);
      return caml_call1(Stdlib[76],oc)}
    function set_channel_flusher(out_channel,f)
     {var
       f$0=
        caml_js_wrap_callback
         (function(s){return caml_call1(f,caml_string_of_jsbytes(s))});
      return runtime.caml_ml_set_channel_output(out_channel,f$0)}
    function set_channel_filler(in_channel,f)
     {var f$0=caml_js_wrap_callback(f);
      return runtime.caml_ml_set_channel_refill(in_channel,f$0)}
    function mount(path,f)
     {return runtime.caml_mount_autoload
              (path,
               caml_js_wrap_callback
                (function(prefix,path){return caml_call2(f,prefix,path)}))}
    function unmount(path){return runtime.caml_unmount(path)}
    if(caml_call2(String[38],git_version,cst$38))
     var js_of_ocaml_version=s;
    else
     var
      _cn_=caml_call2(Stdlib[28],cst$41,git_version),
      js_of_ocaml_version=caml_call2(Stdlib[28],s,_cn_);
    var
     _u_=runtime.caml_create_file,
     _v_=runtime.caml_read_file_content,
     Js_of_ocaml_Sys_js=
      [0,
       set_channel_flusher,
       set_channel_filler,
       function(_dj_){return runtime.caml_list_mount_point(_dj_)},
       unmount,
       mount,
       _v_,
       _u_,
       update_file,
       js_of_ocaml_version];
    caml_register_global(1658,Js_of_ocaml_Sys_js,"Js_of_ocaml__Sys_js");
    function empty_resize_observer_options(param){return {}}
    var t2$0=Unsafe[1].ResizeObserver;
    function is_supported$0(param){return caml_call1(Optdef[5],t2$0)}
    function observe(node,f,box,param)
     {var t1=caml_js_wrap_callback(f),t4=new t2$0(t1);
      if(box)
       {var box$0=box[1],t8={};t8.box = box$0;t4.observe(node,t8)}
      else
       t4.observe(node);
      return t4}
    var
     Js_of_ocaml_ResizeObserver=
      [0,empty_resize_observer_options,t2$0,is_supported$0,observe];
    caml_register_global
     (1659,Js_of_ocaml_ResizeObserver,"Js_of_ocaml__ResizeObserver");
    function empty_mutation_observer_init(param){return {}}
    var t2$1=Unsafe[1].MutationObserver;
    function is_supported$1(param){return caml_call1(Optdef[5],t2$1)}
    function observe$0
     (node,
      f,
      child_list,
      attributes,
      character_data,
      subtree,
      attribute_old_value,
      character_data_old_value,
      attribute_filter,
      param)
     {function opt_iter(x,f)
       {if(x){var x$0=x[1];return caml_call1(f,x$0)}return 0}
      var t1=caml_js_wrap_callback(f),t19=new t2$1(t1),t18={};
      opt_iter(child_list,function(v){return t18.childList = v});
      opt_iter(attributes,function(v){return t18.attributes = v});
      opt_iter(character_data,function(v){return t18.characterData = v});
      opt_iter(subtree,function(v){return t18.subtree = v});
      opt_iter
       (attribute_old_value,function(v){return t18.attributeOldValue = v});
      opt_iter
       (character_data_old_value,
        function(v){return t18.characterDataOldValue = v});
      opt_iter
       (attribute_filter,
        function(l)
         {return t18.attributeFilter
                 =
                 caml_js_from_array(caml_call1(Stdlib_array[12],l))});
      t19.observe(node,t18);
      return t19}
    var
     Js_of_ocaml_MutationObserver=
      [0,empty_mutation_observer_init,t2$1,is_supported$1,observe$0];
    caml_register_global
     (1660,Js_of_ocaml_MutationObserver,"Js_of_ocaml__MutationObserver");
    var t1=Unsafe[1].Object;
    function create$0(param){return new t1()}
    function add$0(t,k,v){return t[k.concat("_")] = v}
    function remove(t,k){return delete t[k.concat("_")]}
    function find(t,k){return t[k.concat("_")]}
    function keys(t)
     {var
       t10=Unsafe[1].Object,
       key_array=t10.keys(t),
       res=[0,0],
       _df_=key_array.length - 1 | 0,
       _de_=0;
      if(! (_df_ < 0))
       {var i=_de_;
        for(;;)
         {var
           _dg_=function(param){return caml_call1(Stdlib[2],cst_Jstable_keys)},
           t15=caml_call2(Optdef[8],key_array[i],_dg_),
           t14=t15.length - 1 | 0,
           _dh_=res[1];
          res[1] = [0,t15.substring(0,t14),_dh_];
          var _di_=i + 1 | 0;
          if(_df_ !== i){var i=_di_;continue}
          break}}
      return caml_call1(Stdlib_list[9],res[1])}
    var Js_of_ocaml_Jstable=[0,create$0,add$0,remove,find,keys];
    caml_register_global(1661,Js_of_ocaml_Jstable,"Js_of_ocaml__Jstable");
    var t12=Unsafe[1].JSON;
    function reviver(this$0,key,value)
     {if(typeof value == typeof "foo")return caml_string_of_jsbytes(value);
      if
       (value instanceof array_length
        &&
        4
        ===
        value.length
        &&
        255
        ===
        value[0])
       return runtime.caml_int64_create_lo_mi_hi(value[1],value[2],value[3]);
      return value}
    var t3$0=caml_js_wrap_meth_callback(reviver);
    function unsafe_input(t2){return t12.parse(t2,t3$0)}
    var
     mlString_constr=dummy_string.constructor,
     mlInt64_constr=dummy_int64.constructor;
    function t11$1(key,value)
     {return value instanceof mlString_constr
              ?caml_jsbytes_of_string(value)
              :value instanceof mlInt64_constr
                ?caml_js_from_array([0,255,value.lo,value.mi,value.hi])
                :value}
    function output(t10){return t12.stringify(t10,t11$1)}
    var Js_of_ocaml_Json=[0,output,unsafe_input];
    caml_register_global(1662,Js_of_ocaml_Json,"Js_of_ocaml__Json");
    function string_of_name(param)
     {var _dd_=param;
      if(74 <= _dd_)
       {if(111 <= _dd_)
         switch(_dd_)
          {case 111:return cst_palevioletred;
           case 112:return cst_papayawhip;
           case 113:return cst_peachpuff;
           case 114:return cst_peru;
           case 115:return cst_pink;
           case 116:return cst_plum;
           case 117:return cst_powderblue;
           case 118:return cst_purple;
           case 119:return cst_red;
           case 120:return cst_rosybrown;
           case 121:return cst_royalblue;
           case 122:return cst_saddlebrown;
           case 123:return cst_salmon;
           case 124:return cst_sandybrown;
           case 125:return cst_seagreen;
           case 126:return cst_seashell;
           case 127:return cst_sienna;
           case 128:return cst_silver;
           case 129:return cst_skyblue;
           case 130:return cst_slateblue;
           case 131:return cst_slategray;
           case 132:return cst_slategrey;
           case 133:return cst_snow;
           case 134:return cst_springgreen;
           case 135:return cst_steelblue;
           case 136:return cst_tan;
           case 137:return cst_teal;
           case 138:return cst_thistle;
           case 139:return cst_tomato;
           case 140:return cst_turquoise;
           case 141:return cst_violet;
           case 142:return cst_wheat;
           case 143:return cst_white;
           case 144:return cst_whitesmoke;
           case 145:return cst_yellow;
           default:return cst_yellowgreen}
        switch(_dd_)
         {case 74:return cst_lightpink;
          case 75:return cst_lightsalmon;
          case 76:return cst_lightseagreen;
          case 77:return cst_lightskyblue;
          case 78:return cst_lightslategray;
          case 79:return cst_lightslategrey;
          case 80:return cst_lightsteelblue;
          case 81:return cst_lightyellow;
          case 82:return cst_lime;
          case 83:return cst_limegreen;
          case 84:return cst_linen;
          case 85:return cst_magenta;
          case 86:return cst_maroon;
          case 87:return cst_mediumaquamarine;
          case 88:return cst_mediumblue;
          case 89:return cst_mediumorchid;
          case 90:return cst_mediumpurple;
          case 91:return cst_mediumseagreen;
          case 92:return cst_mediumslateblue;
          case 93:return cst_mediumspringgreen;
          case 94:return cst_mediumturquoise;
          case 95:return cst_mediumvioletred;
          case 96:return cst_midnightblue;
          case 97:return cst_mintcream;
          case 98:return cst_mistyrose;
          case 99:return cst_moccasin;
          case 100:return cst_navajowhite;
          case 101:return cst_navy;
          case 102:return cst_oldlace;
          case 103:return cst_olive;
          case 104:return cst_olivedrab;
          case 105:return cst_orange;
          case 106:return cst_orangered;
          case 107:return cst_orchid;
          case 108:return cst_palegoldenrod;
          case 109:return cst_palegreen;
          default:return cst_paleturquoise}}
      if(37 <= _dd_)
       switch(_dd_)
        {case 37:return cst_darkslategrey;
         case 38:return cst_darkturquoise;
         case 39:return cst_darkviolet;
         case 40:return cst_deeppink;
         case 41:return cst_deepskyblue;
         case 42:return cst_dimgray;
         case 43:return cst_dimgrey;
         case 44:return cst_dodgerblue;
         case 45:return cst_firebrick;
         case 46:return cst_floralwhite;
         case 47:return cst_forestgreen;
         case 48:return cst_fuchsia;
         case 49:return cst_gainsboro;
         case 50:return cst_ghostwhite;
         case 51:return cst_gold;
         case 52:return cst_goldenrod;
         case 53:return cst_gray;
         case 54:return cst_grey;
         case 55:return cst_green;
         case 56:return cst_greenyellow;
         case 57:return cst_honeydew;
         case 58:return cst_hotpink;
         case 59:return cst_indianred;
         case 60:return cst_indigo;
         case 61:return cst_ivory;
         case 62:return cst_khaki;
         case 63:return cst_lavender;
         case 64:return cst_lavenderblush;
         case 65:return cst_lawngreen;
         case 66:return cst_lemonchiffon;
         case 67:return cst_lightblue;
         case 68:return cst_lightcoral;
         case 69:return cst_lightcyan;
         case 70:return cst_lightgoldenrodyellow;
         case 71:return cst_lightgray;
         case 72:return cst_lightgreen;
         default:return cst_lightgrey}
      switch(_dd_)
       {case 0:return cst_aliceblue;
        case 1:return cst_antiquewhite;
        case 2:return cst_aqua;
        case 3:return cst_aquamarine;
        case 4:return cst_azure;
        case 5:return cst_beige;
        case 6:return cst_bisque;
        case 7:return cst_black;
        case 8:return cst_blanchedalmond;
        case 9:return cst_blue;
        case 10:return cst_blueviolet;
        case 11:return cst_brown;
        case 12:return cst_burlywood;
        case 13:return cst_cadetblue;
        case 14:return cst_chartreuse;
        case 15:return cst_chocolate;
        case 16:return cst_coral;
        case 17:return cst_cornflowerblue;
        case 18:return cst_cornsilk;
        case 19:return cst_crimson;
        case 20:return cst_cyan;
        case 21:return cst_darkblue;
        case 22:return cst_darkcyan;
        case 23:return cst_darkgoldenrod;
        case 24:return cst_darkgray;
        case 25:return cst_darkgreen;
        case 26:return cst_darkgrey;
        case 27:return cst_darkkhaki;
        case 28:return cst_darkmagenta;
        case 29:return cst_darkolivegreen;
        case 30:return cst_darkorange;
        case 31:return cst_darkorchid;
        case 32:return cst_darkred;
        case 33:return cst_darksalmon;
        case 34:return cst_darkseagreen;
        case 35:return cst_darkslateblue;
        default:return cst_darkslategray}}
    function name_of_string(s)
     {var switch$0=caml_string_compare(s,cst_lightgrey$0);
      if(0 <= switch$0)
       {if(! (0 < switch$0))return 73;
        var switch$1=caml_string_compare(s,cst_paleturquoise$0);
        if(0 <= switch$1)
         {if(! (0 < switch$1))return 110;
          var switch$2=caml_string_compare(s,cst_skyblue$0);
          if(0 <= switch$2)
           {if(! (0 < switch$2))return 129;
            var switch$3=caml_string_compare(s,cst_thistle$0);
            if(0 <= switch$3)
             {if(! (0 < switch$3))return 138;
              if(! caml_string_notequal(s,cst_tomato$0))return 139;
              if(! caml_string_notequal(s,cst_turquoise$0))return 140;
              if(! caml_string_notequal(s,cst_violet$0))return 141;
              if(! caml_string_notequal(s,cst_wheat$0))return 142;
              if(! caml_string_notequal(s,cst_white$0))return 143;
              if(! caml_string_notequal(s,cst_whitesmoke$0))return 144;
              if(! caml_string_notequal(s,cst_yellow$0))return 145;
              if(! caml_string_notequal(s,cst_yellowgreen$0))return 146}
            else
             {if(! caml_string_notequal(s,cst_slateblue$0))return 130;
              if(! caml_string_notequal(s,cst_slategray$0))return 131;
              if(! caml_string_notequal(s,cst_slategrey$0))return 132;
              if(! caml_string_notequal(s,cst_snow$0))return 133;
              if(! caml_string_notequal(s,cst_springgreen$0))return 134;
              if(! caml_string_notequal(s,cst_steelblue$0))return 135;
              if(! caml_string_notequal(s,cst_tan$0))return 136;
              if(! caml_string_notequal(s,cst_teal$0))return 137}}
          else
           {var switch$4=caml_string_compare(s,cst_rosybrown$0);
            if(0 <= switch$4)
             {if(! (0 < switch$4))return 120;
              if(! caml_string_notequal(s,cst_royalblue$0))return 121;
              if(! caml_string_notequal(s,cst_saddlebrown$0))return 122;
              if(! caml_string_notequal(s,cst_salmon$0))return 123;
              if(! caml_string_notequal(s,cst_sandybrown$0))return 124;
              if(! caml_string_notequal(s,cst_seagreen$0))return 125;
              if(! caml_string_notequal(s,cst_seashell$0))return 126;
              if(! caml_string_notequal(s,cst_sienna$0))return 127;
              if(! caml_string_notequal(s,cst_silver$0))return 128}
            else
             {if(! caml_string_notequal(s,cst_palevioletred$0))return 111;
              if(! caml_string_notequal(s,cst_papayawhip$0))return 112;
              if(! caml_string_notequal(s,cst_peachpuff$0))return 113;
              if(! caml_string_notequal(s,cst_peru$0))return 114;
              if(! caml_string_notequal(s,cst_pink$0))return 115;
              if(! caml_string_notequal(s,cst_plum$0))return 116;
              if(! caml_string_notequal(s,cst_powderblue$0))return 117;
              if(! caml_string_notequal(s,cst_purple$0))return 118;
              if(! caml_string_notequal(s,cst_red$0))return 119}}}
        else
         {var switch$5=caml_string_compare(s,cst_mediumslateblue$0);
          if(0 <= switch$5)
           {if(! (0 < switch$5))return 92;
            var switch$6=caml_string_compare(s,cst_navy$0);
            if(0 <= switch$6)
             {if(! (0 < switch$6))return 101;
              if(! caml_string_notequal(s,cst_oldlace$0))return 102;
              if(! caml_string_notequal(s,cst_olive$0))return 103;
              if(! caml_string_notequal(s,cst_olivedrab$0))return 104;
              if(! caml_string_notequal(s,cst_orange$0))return 105;
              if(! caml_string_notequal(s,cst_orangered$0))return 106;
              if(! caml_string_notequal(s,cst_orchid$0))return 107;
              if(! caml_string_notequal(s,cst_palegoldenrod$0))return 108;
              if(! caml_string_notequal(s,cst_palegreen$0))return 109}
            else
             {if(! caml_string_notequal(s,cst_mediumspringgreen$0))return 93;
              if(! caml_string_notequal(s,cst_mediumturquoise$0))return 94;
              if(! caml_string_notequal(s,cst_mediumvioletred$0))return 95;
              if(! caml_string_notequal(s,cst_midnightblue$0))return 96;
              if(! caml_string_notequal(s,cst_mintcream$0))return 97;
              if(! caml_string_notequal(s,cst_mistyrose$0))return 98;
              if(! caml_string_notequal(s,cst_moccasin$0))return 99;
              if(! caml_string_notequal(s,cst_navajowhite$0))return 100}}
          else
           {var switch$7=caml_string_compare(s,cst_limegreen$0);
            if(0 <= switch$7)
             {if(! (0 < switch$7))return 83;
              if(! caml_string_notequal(s,cst_linen$0))return 84;
              if(! caml_string_notequal(s,cst_magenta$0))return 85;
              if(! caml_string_notequal(s,cst_maroon$0))return 86;
              if(! caml_string_notequal(s,cst_mediumaquamarine$0))return 87;
              if(! caml_string_notequal(s,cst_mediumblue$0))return 88;
              if(! caml_string_notequal(s,cst_mediumorchid$0))return 89;
              if(! caml_string_notequal(s,cst_mediumpurple$0))return 90;
              if(! caml_string_notequal(s,cst_mediumseagreen$0))return 91}
            else
             {if(! caml_string_notequal(s,cst_lightpink$0))return 74;
              if(! caml_string_notequal(s,cst_lightsalmon$0))return 75;
              if(! caml_string_notequal(s,cst_lightseagreen$0))return 76;
              if(! caml_string_notequal(s,cst_lightskyblue$0))return 77;
              if(! caml_string_notequal(s,cst_lightslategray$0))return 78;
              if(! caml_string_notequal(s,cst_lightslategrey$0))return 79;
              if(! caml_string_notequal(s,cst_lightsteelblue$0))return 80;
              if(! caml_string_notequal(s,cst_lightyellow$0))return 81;
              if(! caml_string_notequal(s,cst_lime$0))return 82}}}}
      else
       {var switch$8=caml_string_compare(s,cst_darkslategray$0);
        if(0 <= switch$8)
         {if(! (0 < switch$8))return 36;
          var switch$9=caml_string_compare(s,cst_greenyellow$0);
          if(0 <= switch$9)
           {if(! (0 < switch$9))return 56;
            var switch$10=caml_string_compare(s,cst_lavenderblush$0);
            if(0 <= switch$10)
             {if(! (0 < switch$10))return 64;
              if(! caml_string_notequal(s,cst_lawngreen$0))return 65;
              if(! caml_string_notequal(s,cst_lemonchiffon$0))return 66;
              if(! caml_string_notequal(s,cst_lightblue$0))return 67;
              if(! caml_string_notequal(s,cst_lightcoral$0))return 68;
              if(! caml_string_notequal(s,cst_lightcyan$0))return 69;
              if(! caml_string_notequal(s,cst_lightgoldenrodyellow$0))
               return 70;
              if(! caml_string_notequal(s,cst_lightgray$0))return 71;
              if(! caml_string_notequal(s,cst_lightgreen$0))return 72}
            else
             {if(! caml_string_notequal(s,cst_grey$0))return 54;
              if(! caml_string_notequal(s,cst_honeydew$0))return 57;
              if(! caml_string_notequal(s,cst_hotpink$0))return 58;
              if(! caml_string_notequal(s,cst_indianred$0))return 59;
              if(! caml_string_notequal(s,cst_indigo$0))return 60;
              if(! caml_string_notequal(s,cst_ivory$0))return 61;
              if(! caml_string_notequal(s,cst_khaki$0))return 62;
              if(! caml_string_notequal(s,cst_lavender$0))return 63}}
          else
           {var switch$11=caml_string_compare(s,cst_floralwhite$0);
            if(0 <= switch$11)
             {if(! (0 < switch$11))return 46;
              if(! caml_string_notequal(s,cst_forestgreen$0))return 47;
              if(! caml_string_notequal(s,cst_fuchsia$0))return 48;
              if(! caml_string_notequal(s,cst_gainsboro$0))return 49;
              if(! caml_string_notequal(s,cst_ghostwhite$0))return 50;
              if(! caml_string_notequal(s,cst_gold$0))return 51;
              if(! caml_string_notequal(s,cst_goldenrod$0))return 52;
              if(! caml_string_notequal(s,cst_gray$0))return 53;
              if(! caml_string_notequal(s,cst_green$0))return 55}
            else
             {if(! caml_string_notequal(s,cst_darkslategrey$0))return 37;
              if(! caml_string_notequal(s,cst_darkturquoise$0))return 38;
              if(! caml_string_notequal(s,cst_darkviolet$0))return 39;
              if(! caml_string_notequal(s,cst_deeppink$0))return 40;
              if(! caml_string_notequal(s,cst_deepskyblue$0))return 41;
              if(! caml_string_notequal(s,cst_dimgray$0))return 42;
              if(! caml_string_notequal(s,cst_dimgrey$0))return 43;
              if(! caml_string_notequal(s,cst_dodgerblue$0))return 44;
              if(! caml_string_notequal(s,cst_firebrick$0))return 45}}}
        else
         {var switch$12=caml_string_compare(s,cst_cornsilk$0);
          if(0 <= switch$12)
           {if(! (0 < switch$12))return 18;
            var switch$13=caml_string_compare(s,cst_darkkhaki$0);
            if(0 <= switch$13)
             {if(! (0 < switch$13))return 27;
              if(! caml_string_notequal(s,cst_darkmagenta$0))return 28;
              if(! caml_string_notequal(s,cst_darkolivegreen$0))return 29;
              if(! caml_string_notequal(s,cst_darkorange$0))return 30;
              if(! caml_string_notequal(s,cst_darkorchid$0))return 31;
              if(! caml_string_notequal(s,cst_darkred$0))return 32;
              if(! caml_string_notequal(s,cst_darksalmon$0))return 33;
              if(! caml_string_notequal(s,cst_darkseagreen$0))return 34;
              if(! caml_string_notequal(s,cst_darkslateblue$0))return 35}
            else
             {if(! caml_string_notequal(s,cst_crimson$0))return 19;
              if(! caml_string_notequal(s,cst_cyan$0))return 20;
              if(! caml_string_notequal(s,cst_darkblue$0))return 21;
              if(! caml_string_notequal(s,cst_darkcyan$0))return 22;
              if(! caml_string_notequal(s,cst_darkgoldenrod$0))return 23;
              if(! caml_string_notequal(s,cst_darkgray$0))return 24;
              if(! caml_string_notequal(s,cst_darkgreen$0))return 25;
              if(! caml_string_notequal(s,cst_darkgrey$0))return 26}}
          else
           {var switch$14=caml_string_compare(s,cst_blue$0);
            if(0 <= switch$14)
             {if(! (0 < switch$14))return 9;
              if(! caml_string_notequal(s,cst_blueviolet$0))return 10;
              if(! caml_string_notequal(s,cst_brown$0))return 11;
              if(! caml_string_notequal(s,cst_burlywood$0))return 12;
              if(! caml_string_notequal(s,cst_cadetblue$0))return 13;
              if(! caml_string_notequal(s,cst_chartreuse$0))return 14;
              if(! caml_string_notequal(s,cst_chocolate$0))return 15;
              if(! caml_string_notequal(s,cst_coral$0))return 16;
              if(! caml_string_notequal(s,cst_cornflowerblue$0))return 17}
            else
             {if(! caml_string_notequal(s,cst_aliceblue$0))return 0;
              if(! caml_string_notequal(s,cst_antiquewhite$0))return 1;
              if(! caml_string_notequal(s,cst_aqua$0))return 2;
              if(! caml_string_notequal(s,cst_aquamarine$0))return 3;
              if(! caml_string_notequal(s,cst_azure$0))return 4;
              if(! caml_string_notequal(s,cst_beige$0))return 5;
              if(! caml_string_notequal(s,cst_bisque$0))return 6;
              if(! caml_string_notequal(s,cst_black$0))return 7;
              if(! caml_string_notequal(s,cst_blanchedalmond$0))return 8}}}}
      var _dc_=caml_call2(Stdlib[28],s,cst_is_not_a_valid_color_name);
      throw [0,Stdlib[6],_dc_]}
    function rgb_of_name(param)
     {var _db_=param;
      if(74 <= _db_)
       {if(111 <= _db_)
         switch(_db_)
          {case 111:return _bp_;
           case 112:return _bq_;
           case 113:return _br_;
           case 114:return _bs_;
           case 115:return _bt_;
           case 116:return _bu_;
           case 117:return _bv_;
           case 118:return _bw_;
           case 119:return _bx_;
           case 120:return _by_;
           case 121:return _bz_;
           case 122:return _bA_;
           case 123:return _bB_;
           case 124:return _bC_;
           case 125:return _bD_;
           case 126:return _bE_;
           case 127:return _bF_;
           case 128:return _bG_;
           case 129:return _bH_;
           case 130:return _bI_;
           case 131:return _bJ_;
           case 132:return _bK_;
           case 133:return _bL_;
           case 134:return _bM_;
           case 135:return _bN_;
           case 136:return _bO_;
           case 137:return _bP_;
           case 138:return _bQ_;
           case 139:return _bR_;
           case 140:return _bS_;
           case 141:return _bT_;
           case 142:return _bU_;
           case 143:return _bV_;
           case 144:return _bW_;
           case 145:return _bX_;
           default:return _bY_}
        switch(_db_)
         {case 74:return _aQ_;
          case 75:return _aR_;
          case 76:return _aS_;
          case 77:return _aT_;
          case 78:return _aU_;
          case 79:return _aV_;
          case 80:return _aW_;
          case 81:return _aX_;
          case 82:return _aY_;
          case 83:return _aZ_;
          case 84:return _a0_;
          case 85:return _a1_;
          case 86:return _a2_;
          case 87:return _a3_;
          case 88:return _a4_;
          case 89:return _a5_;
          case 90:return _a6_;
          case 91:return _a7_;
          case 92:return _a8_;
          case 93:return _a9_;
          case 94:return _a__;
          case 95:return _a$_;
          case 96:return _ba_;
          case 97:return _bb_;
          case 98:return _bc_;
          case 99:return _bd_;
          case 100:return _be_;
          case 101:return _bf_;
          case 102:return _bg_;
          case 103:return _bh_;
          case 104:return _bi_;
          case 105:return _bj_;
          case 106:return _bk_;
          case 107:return _bl_;
          case 108:return _bm_;
          case 109:return _bn_;
          default:return _bo_}}
      if(37 <= _db_)
       switch(_db_)
        {case 37:return _af_;
         case 38:return _ag_;
         case 39:return _ah_;
         case 40:return _ai_;
         case 41:return _aj_;
         case 42:return _ak_;
         case 43:return _al_;
         case 44:return _am_;
         case 45:return _an_;
         case 46:return _ao_;
         case 47:return _ap_;
         case 48:return _aq_;
         case 49:return _ar_;
         case 50:return _as_;
         case 51:return _at_;
         case 52:return _au_;
         case 53:return _av_;
         case 54:return _aw_;
         case 55:return _ax_;
         case 56:return _ay_;
         case 57:return _az_;
         case 58:return _aA_;
         case 59:return _aB_;
         case 60:return _aC_;
         case 61:return _aD_;
         case 62:return _aE_;
         case 63:return _aF_;
         case 64:return _aG_;
         case 65:return _aH_;
         case 66:return _aI_;
         case 67:return _aJ_;
         case 68:return _aK_;
         case 69:return _aL_;
         case 70:return _aM_;
         case 71:return _aN_;
         case 72:return _aO_;
         default:return _aP_}
      switch(_db_)
       {case 0:return _w_;
        case 1:return _x_;
        case 2:return _y_;
        case 3:return _z_;
        case 4:return _A_;
        case 5:return _B_;
        case 6:return _C_;
        case 7:return _D_;
        case 8:return _E_;
        case 9:return _F_;
        case 10:return _G_;
        case 11:return _H_;
        case 12:return _I_;
        case 13:return _J_;
        case 14:return _K_;
        case 15:return _L_;
        case 16:return _M_;
        case 17:return _N_;
        case 18:return _O_;
        case 19:return _P_;
        case 20:return _Q_;
        case 21:return _R_;
        case 22:return _S_;
        case 23:return _T_;
        case 24:return _U_;
        case 25:return _V_;
        case 26:return _W_;
        case 27:return _X_;
        case 28:return _Y_;
        case 29:return _Z_;
        case 30:return ___;
        case 31:return _$_;
        case 32:return _aa_;
        case 33:return _ab_;
        case 34:return _ac_;
        case 35:return _ad_;
        default:return _ae_}}
    function rgb(a,r,g,b)
     {if(a){var a$0=a[1];return [3,[0,r,g,b,a$0]]}return [1,[0,r,g,b]]}
    function hsl(a,h,s,l)
     {if(a){var a$0=a[1];return [6,[0,h,s,l,a$0]]}return [5,[0,h,s,l]]}
    function string_of_t(param)
     {switch(param[0])
       {case 0:var n=param[1];return string_of_name(n);
        case 1:
         var match=param[1],b=match[3],g=match[2],r=match[1];
         return caml_call4(Stdlib_printf[4],_bZ_,r,g,b);
        case 2:
         var match$0=param[1],b$0=match$0[3],g$0=match$0[2],r$0=match$0[1];
         return caml_call4(Stdlib_printf[4],_b0_,r$0,g$0,b$0);
        case 3:
         var
          match$1=param[1],
          a=match$1[4],
          b$1=match$1[3],
          g$1=match$1[2],
          r$1=match$1[1];
         return caml_call5(Stdlib_printf[4],_b1_,r$1,g$1,b$1,a);
        case 4:
         var
          match$2=param[1],
          a$0=match$2[4],
          b$2=match$2[3],
          g$2=match$2[2],
          r$2=match$2[1];
         return caml_call5(Stdlib_printf[4],_b2_,r$2,g$2,b$2,a$0);
        case 5:
         var match$3=param[1],l=match$3[3],s=match$3[2],h=match$3[1];
         return caml_call4(Stdlib_printf[4],_b3_,h,s,l);
        default:
         var
          match$4=param[1],
          a$1=match$4[4],
          l$0=match$4[3],
          s$0=match$4[2],
          h$0=match$4[1];
         return caml_call5(Stdlib_printf[4],_b4_,h$0,s$0,l$0,a$1)}}
    function hex_of_rgb(param)
     {var blue=param[3],green=param[2],red=param[1];
      function in_range(i)
       {var
         _c9_=caml_call2(symbol$5,i,0),
         _c__=_c9_ || caml_call2(symbol$9,i,255);
        if(_c__)
         {var
           _c$_=caml_call1(Stdlib[33],i),
           _da_=caml_call2(Stdlib[28],_c$_,cst_is_out_of_valid_range);
          throw [0,Stdlib[6],_da_]}
        return _c__}
      in_range(red);
      in_range(green);
      in_range(blue);
      return caml_call4(Stdlib_printf[4],_b5_,red,green,blue)}
    function js_t_of_js_string(s)
     {var
       t0=caml_jsbytes_of_string(cst_rgb_s_d_s_d_s_d),
       t13=new t11(t0),
       t2=caml_jsbytes_of_string(cst_rgb_s_d_s_d_s_d$0),
       t17=new t11(t2),
       t4=caml_jsbytes_of_string(cst_rgba_s_d_s_d_s_d_d_d),
       t15=new t11(t4),
       t6=caml_jsbytes_of_string(cst_rgba_s_d_s_d_s_d_d_d$0),
       t19=new t11(t6),
       t8=caml_jsbytes_of_string(cst_hsl_s_d_s_d_s_d),
       t21=new t11(t8),
       t10=caml_jsbytes_of_string(cst_hsla_s_d_s_d_s_d_d_d),
       t23=new t11(t10);
      if
       (!
        (t13.test(s) | 0)
        &&
        !
        (t15.test(s) | 0)
        &&
        !
        (t17.test(s) | 0)
        &&
        !
        (t19.test(s) | 0)
        &&
        !
        (t21.test(s) | 0)
        &&
        !
        (t23.test(s) | 0))
       {var _c6_=caml_string_of_jsstring(s);
        if(caml_call2(Stdlib_list[36],_c6_,_b6_))return s;
        var
         _c7_=caml_string_of_jsstring(s),
         _c8_=caml_call2(Stdlib[28],_c7_,cst_is_not_a_valid_color);
        throw [0,Stdlib[6],_c8_]}
      return s}
    function js(c)
     {if(0 === c[0])
       {var n=c[1];return caml_jsstring_of_string(string_of_name(n))}
      return caml_jsstring_of_string(string_of_t(c))}
    function ml(c)
     {var s=caml_string_of_jsstring(c);
      try
       {var _cT_=[0,name_of_string(s)];return _cT_}
      catch(_cU_)
       {_cU_ = caml_wrap_exception(_cU_);
        if(_cU_[1] === Stdlib[6])
         {var
           fail=
            function(param)
             {var _c5_=caml_call2(Stdlib[28],s,cst_is_not_a_valid_color$0);
              throw [0,Stdlib[6],_c5_]},
           re_rgb=regexp(cst_rgba_d_d_d_d_d),
           re_rgb_pct=regexp(cst_rgba_d_d_d_d_d$0),
           re_hsl=regexp(cst_hsla_d_d_d_d_d),
           i_of_s_o=
            function(param)
             {if(param)
               {var i=param[1];
                try
                 {var _c3_=caml_int_of_string(i);return _c3_}
                catch(_c4_)
                 {_c4_ = caml_wrap_exception(_c4_);
                  if(_c4_[1] === Stdlib[6])
                   var s=_c4_[2];
                  else
                   {if(_c4_[1] !== Stdlib[7])throw _c4_;var s=_c4_[2]}
                  var
                   _c0_=caml_call2(Stdlib[28],cst$39,s),
                   _c1_=caml_call2(Stdlib[28],i,_c0_),
                   _c2_=caml_call2(Stdlib[28],cst_color_conversion_error,_c1_);
                  throw [0,Stdlib[6],_c2_]}}
              return fail(0)},
           f_of_s=
            function(f)
             {try
               {var _cY_=caml_float_of_string(f);return _cY_}
              catch(_cZ_)
               {_cZ_ = caml_wrap_exception(_cZ_);
                if(_cZ_[1] === Stdlib[6])
                 var s=_cZ_[2];
                else
                 {if(_cZ_[1] !== Stdlib[7])throw _cZ_;var s=_cZ_[2]}
                var
                 _cV_=caml_call2(Stdlib[28],cst$40,s),
                 _cW_=caml_call2(Stdlib[28],f,_cV_),
                 _cX_=caml_call2(Stdlib[28],cst_color_conversion_error$0,_cW_);
                throw [0,Stdlib[6],_cX_]}},
           match=string_match(re_rgb,s,0);
          if(match)
           {var
             r=match[1],
             red=matched_group(r,2),
             green=matched_group(r,3),
             blue=matched_group(r,4),
             alpha=matched_group(r,5),
             match$0=matched_group(r,1);
            if(match$0)
             {var _cB_=match$0[1];
              if(! caml_string_notequal(_cB_,cst_rgb))
               {if(alpha)return fail(0);
                var _cF_=i_of_s_o(blue),_cG_=i_of_s_o(green);
                return [1,[0,i_of_s_o(red),_cG_,_cF_]]}
              if(! caml_string_notequal(_cB_,cst_rgba))
               {if(alpha)
                 {var
                   a=alpha[1],
                   _cC_=f_of_s(a),
                   _cD_=i_of_s_o(blue),
                   _cE_=i_of_s_o(green);
                  return [3,[0,i_of_s_o(red),_cE_,_cD_,_cC_]]}
                return fail(0)}}
            return fail(0)}
          var match$1=string_match(re_rgb_pct,s,0);
          if(match$1)
           {var
             r$0=match$1[1],
             red$0=matched_group(r$0,2),
             green$0=matched_group(r$0,3),
             blue$0=matched_group(r$0,4),
             alpha$0=matched_group(r$0,5),
             match$2=matched_group(r$0,1);
            if(match$2)
             {var _cH_=match$2[1];
              if(! caml_string_notequal(_cH_,cst_rgb$0))
               {if(alpha$0)return fail(0);
                var _cL_=i_of_s_o(blue$0),_cM_=i_of_s_o(green$0);
                return [2,[0,i_of_s_o(red$0),_cM_,_cL_]]}
              if(! caml_string_notequal(_cH_,cst_rgba$0))
               {if(alpha$0)
                 {var
                   a$0=alpha$0[1],
                   _cI_=f_of_s(a$0),
                   _cJ_=i_of_s_o(blue$0),
                   _cK_=i_of_s_o(green$0);
                  return [4,[0,i_of_s_o(red$0),_cK_,_cJ_,_cI_]]}
                return fail(0)}}
            return fail(0)}
          var match$3=string_match(re_hsl,s,0);
          if(match$3)
           {var
             r$1=match$3[1],
             red$1=matched_group(r$1,2),
             green$1=matched_group(r$1,3),
             blue$1=matched_group(r$1,4),
             alpha$1=matched_group(r$1,5),
             match$4=matched_group(r$1,1);
            if(match$4)
             {var _cN_=match$4[1];
              if(! caml_string_notequal(_cN_,cst_hsl))
               {if(alpha$1)return fail(0);
                var _cR_=i_of_s_o(blue$1),_cS_=i_of_s_o(green$1);
                return [5,[0,i_of_s_o(red$1),_cS_,_cR_]]}
              if(! caml_string_notequal(_cN_,cst_hsla))
               {if(alpha$1)
                 {var
                   a$1=alpha$1[1],
                   _cO_=f_of_s(a$1),
                   _cP_=i_of_s_o(blue$1),
                   _cQ_=i_of_s_o(green$1);
                  return [6,[0,i_of_s_o(red$1),_cQ_,_cP_,_cO_]]}
                return fail(0)}}
            return fail(0)}
          return fail(0)}
        throw _cU_}}
    function string_of_t$0(param)
     {if(typeof param === "number")
       return cst_0;
      else
       switch(param[0])
        {case 0:
          var f=param[1];return caml_call3(Stdlib_printf[4],_b7_,f,cst_em$0);
         case 1:
          var f$0=param[1];
          return caml_call3(Stdlib_printf[4],_b8_,f$0,cst_ex);
         case 2:
          var f$1=param[1];
          return caml_call3(Stdlib_printf[4],_b9_,f$1,cst_px);
         case 3:
          var f$2=param[1];
          return caml_call3(Stdlib_printf[4],_b__,f$2,cst_gd);
         case 4:
          var f$3=param[1];
          return caml_call3(Stdlib_printf[4],_b$_,f$3,cst_rem);
         case 5:
          var f$4=param[1];
          return caml_call3(Stdlib_printf[4],_ca_,f$4,cst_vw);
         case 6:
          var f$5=param[1];
          return caml_call3(Stdlib_printf[4],_cb_,f$5,cst_vh);
         case 7:
          var f$6=param[1];
          return caml_call3(Stdlib_printf[4],_cc_,f$6,cst_vm);
         case 8:
          var f$7=param[1];
          return caml_call3(Stdlib_printf[4],_cd_,f$7,cst_ch);
         case 9:
          var f$8=param[1];
          return caml_call3(Stdlib_printf[4],_ce_,f$8,cst_mm);
         case 10:
          var f$9=param[1];
          return caml_call3(Stdlib_printf[4],_cf_,f$9,cst_cm);
         case 11:
          var f$10=param[1];
          return caml_call3(Stdlib_printf[4],_cg_,f$10,cst_in);
         case 12:
          var f$11=param[1];
          return caml_call3(Stdlib_printf[4],_ch_,f$11,cst_pt);
         default:
          var f$12=param[1];
          return caml_call3(Stdlib_printf[4],_ci_,f$12,cst_pc)}}
    function js$0(t){return caml_jsstring_of_string(string_of_t$0(t))}
    function ml$0(t)
     {var s=caml_string_of_jsstring(t);
      if(caml_call2(String[38],s,cst_0$0))return 0;
      function fail(param)
       {var _cA_=caml_call2(Stdlib[28],s,cst_is_not_a_valid_length);
        throw [0,Stdlib[6],_cA_]}
      var re=regexp(cst_d_d_s_S),match=string_match(re,s,0);
      if(match)
       {var r=match[1],match$0=matched_group(r,1);
        if(match$0)
         {var f=match$0[1];
          try
           {var _cy_=caml_float_of_string(f)}
          catch(exn)
           {exn = caml_wrap_exception(exn);
            if(exn[1] === Stdlib[6])
             {var
               s$0=exn[2],
               _cx_=caml_call2(Stdlib[28],cst_length_conversion_error,s$0);
              throw [0,Stdlib[6],_cx_]}
            throw exn}
          var f$0=_cy_}
        else
         var f$0=fail(0);
        var match$1=matched_group(r,2);
        if(match$1)
         {var _cz_=match$1[1],switch$0=caml_string_compare(_cz_,cst_pc$0);
          if(0 <= switch$0)
           {if(! (0 < switch$0))return [13,f$0];
            if(! caml_string_notequal(_cz_,cst_pt$0))return [12,f$0];
            if(! caml_string_notequal(_cz_,cst_px$0))return [2,f$0];
            if(! caml_string_notequal(_cz_,cst_rem$0))return [4,f$0];
            if(! caml_string_notequal(_cz_,cst_vh$0))return [6,f$0];
            if(! caml_string_notequal(_cz_,cst_vm$0))return [7,f$0];
            if(! caml_string_notequal(_cz_,cst_vw$0))return [5,f$0]}
          else
           {if(! caml_string_notequal(_cz_,cst_ch$0))return [8,f$0];
            if(! caml_string_notequal(_cz_,cst_cm$0))return [10,f$0];
            if(! caml_string_notequal(_cz_,cst_em$1))return [0,f$0];
            if(! caml_string_notequal(_cz_,cst_ex$0))return [1,f$0];
            if(! caml_string_notequal(_cz_,cst_gd$0))return [3,f$0];
            if(! caml_string_notequal(_cz_,cst_in$0))return [11,f$0];
            if(! caml_string_notequal(_cz_,cst_mm$0))return [9,f$0]}
          return fail(0)}
        return fail(0)}
      return fail(0)}
    var Length=[0,string_of_t$0,js$0,ml$0];
    function string_of_t$1(param)
     {switch(param[0])
       {case 0:
         var f=param[1];return caml_call3(Stdlib_printf[4],_cj_,f,cst_deg);
        case 1:
         var f$0=param[1];
         return caml_call3(Stdlib_printf[4],_ck_,f$0,cst_grad);
        case 2:
         var f$1=param[1];
         return caml_call3(Stdlib_printf[4],_cl_,f$1,cst_rad);
        default:
         var f$2=param[1];
         return caml_call3(Stdlib_printf[4],_cm_,f$2,cst_turns)}}
    function js$1(t){return caml_jsstring_of_string(string_of_t$1(t))}
    function ml$1(j)
     {var s=caml_string_of_jsstring(j),re=regexp(cst_d_d_deg_grad_rad_turns);
      function fail(param)
       {var _cw_=caml_call2(Stdlib[28],s,cst_is_not_a_valid_length$0);
        throw [0,Stdlib[6],_cw_]}
      var match=string_match(re,s,0);
      if(match)
       {var r=match[1],match$0=matched_group(r,1);
        if(match$0)
         {var f=match$0[1];
          try
           {var _cu_=caml_float_of_string(f)}
          catch(exn)
           {exn = caml_wrap_exception(exn);
            if(exn[1] === Stdlib[6])
             {var
               s$0=exn[2],
               _ct_=caml_call2(Stdlib[28],cst_length_conversion_error$0,s$0);
              throw [0,Stdlib[6],_ct_]}
            throw exn}
          var f$0=_cu_}
        else
         var f$0=fail(0);
        var match$1=matched_group(r,2);
        if(match$1)
         {var _cv_=match$1[1];
          if(! caml_string_notequal(_cv_,cst_deg$0))return [0,f$0];
          if(! caml_string_notequal(_cv_,cst_grad$0))return [1,f$0];
          if(! caml_string_notequal(_cv_,cst_rad$0))return [2,f$0];
          if(! caml_string_notequal(_cv_,cst_turns$0))return [3,f$0]}
        return fail(0)}
      return fail(0)}
    var
     Angle=[0,string_of_t$1,js$1,ml$1],
     Js_of_ocaml_CSS=
      [0,
       [0,
        string_of_name,
        rgb_of_name,
        hex_of_rgb,
        rgb,
        hsl,
        string_of_t,
        js,
        ml,
        js_t_of_js_string],
       Length,
       Angle];
    caml_register_global(1663,Js_of_ocaml_CSS,"Js_of_ocaml__CSS");
    function listen(opt,target,typ,cb)
     {if(opt)var sth=opt[1],capture=sth;else var capture=0;
      var _cs_=! ! capture;
      return addEventListener
              (target,
               typ,
               full_handler(function(n,e){return ! ! caml_call2(cb,n,e)}),
               _cs_)}
    var Js_of_ocaml_Dom_events=[0,Event$0,listen,removeEventListener];
    caml_register_global
     (1664,Js_of_ocaml_Dom_events,"Js_of_ocaml__Dom_events");
    var
     t0="http://www.w3.org/2000/svg",
     SVGError=[248,cst_Js_of_ocaml_Dom_svg_SVGErr,caml_fresh_oo_id(0)];
    function createElement$0(t2,name)
     {var t1=caml_jsstring_of_string(name);
      return t2.createElementNS("http://www.w3.org/2000/svg",t1)}
    function unsafeCreateElement$0(doc,name){return createElement$0(doc,name)}
    function createA$0(doc){return unsafeCreateElement$0(doc,cst_a$2)}
    function createAltGlyph(doc)
     {return unsafeCreateElement$0(doc,cst_altglyph)}
    function createAltGlyphDef(doc)
     {return unsafeCreateElement$0(doc,cst_altglyphdef)}
    function createAltGlyphItem(doc)
     {return unsafeCreateElement$0(doc,cst_altglyphitem)}
    function createAnimate(doc){return unsafeCreateElement$0(doc,cst_animate)}
    function createAnimateColor(doc)
     {return unsafeCreateElement$0(doc,cst_animatecolor)}
    function createAnimateMotion(doc)
     {return unsafeCreateElement$0(doc,cst_animatemotion)}
    function createAnimateTransform(doc)
     {return unsafeCreateElement$0(doc,cst_animatetransform)}
    function createCircle(doc){return unsafeCreateElement$0(doc,cst_circle)}
    function createClipPath(doc)
     {return unsafeCreateElement$0(doc,cst_clippath)}
    function createCursor(doc){return unsafeCreateElement$0(doc,cst_cursor)}
    function createDefs(doc){return unsafeCreateElement$0(doc,cst_defs)}
    function createDesc(doc){return unsafeCreateElement$0(doc,cst_desc)}
    function createEllipse(doc){return unsafeCreateElement$0(doc,cst_ellipse)}
    function createFilter(doc){return unsafeCreateElement$0(doc,cst_filter)}
    function createFont(doc){return unsafeCreateElement$0(doc,cst_font)}
    function createFontFace(doc)
     {return unsafeCreateElement$0(doc,cst_font_face)}
    function createFontFaceFormat(doc)
     {return unsafeCreateElement$0(doc,cst_font_face_format)}
    function createFontFaceName(doc)
     {return unsafeCreateElement$0(doc,cst_font_face_name)}
    function createFontFaceSrc(doc)
     {return unsafeCreateElement$0(doc,cst_font_face_src)}
    function createFontFaceUri(doc)
     {return unsafeCreateElement$0(doc,cst_font_face_uri)}
    function createForeignObject(doc)
     {return unsafeCreateElement$0(doc,cst_foreignObject)}
    function createG(doc){return unsafeCreateElement$0(doc,cst_g$0)}
    function createGlyph(doc){return unsafeCreateElement$0(doc,cst_glyph)}
    function createGlyphRef(doc)
     {return unsafeCreateElement$0(doc,cst_glyphref)}
    function createhkern(doc){return unsafeCreateElement$0(doc,cst_hkern)}
    function createImage(doc){return unsafeCreateElement$0(doc,cst_image)}
    function createLineElement(doc)
     {return unsafeCreateElement$0(doc,cst_line)}
    function createLinearElement(doc)
     {return unsafeCreateElement$0(doc,cst_lineargradient)}
    function createMask(doc){return unsafeCreateElement$0(doc,cst_mask)}
    function createMetaData(doc)
     {return unsafeCreateElement$0(doc,cst_metadata)}
    function createMissingGlyph(doc)
     {return unsafeCreateElement$0(doc,cst_missing_glyph)}
    function createMPath(doc){return unsafeCreateElement$0(doc,cst_mpath)}
    function createPath(doc){return unsafeCreateElement$0(doc,cst_path)}
    function createPattern(doc){return unsafeCreateElement$0(doc,cst_pattern)}
    function createPolygon(doc){return unsafeCreateElement$0(doc,cst_polygon)}
    function createPolyline(doc)
     {return unsafeCreateElement$0(doc,cst_polyline)}
    function createRadialgradient(doc)
     {return unsafeCreateElement$0(doc,cst_radialgradient)}
    function createRect(doc){return unsafeCreateElement$0(doc,cst_rect)}
    function createScript$0(doc)
     {return unsafeCreateElement$0(doc,cst_script$2)}
    function createSet(doc){return unsafeCreateElement$0(doc,cst_set)}
    function createStop(doc){return unsafeCreateElement$0(doc,cst_stop)}
    function createStyle$0(doc){return unsafeCreateElement$0(doc,cst_style$2)}
    function createSvg(doc){return unsafeCreateElement$0(doc,cst_svg)}
    function createSwitch(doc){return unsafeCreateElement$0(doc,cst_switch)}
    function createSymbol(doc){return unsafeCreateElement$0(doc,cst_symbol)}
    function createTextElement(doc)
     {return unsafeCreateElement$0(doc,cst_text$0)}
    function createTextpath(doc)
     {return unsafeCreateElement$0(doc,cst_textpath)}
    function createTitle$0(doc){return unsafeCreateElement$0(doc,cst_title$2)}
    function createTref(doc){return unsafeCreateElement$0(doc,cst_tref)}
    function createTspan(doc){return unsafeCreateElement$0(doc,cst_tspan)}
    function createUse(doc){return unsafeCreateElement$0(doc,cst_use)}
    function createView(doc){return unsafeCreateElement$0(doc,cst_view)}
    function createvkern(doc){return unsafeCreateElement$0(doc,cst_vkern)}
    var svg_element=Unsafe[1].SVGElement,document$0=Unsafe[1].document;
    function getElementById$0(id)
     {function _cp_(e){if(e instanceof svg_element)return e;throw Stdlib[8]}
      function _cq_(param){throw Stdlib[8]}
      var
       t6=caml_jsstring_of_string(id),
       t7=Unsafe[1].document,
       _cr_=t7.getElementById(t6);
      return caml_call3(Opt[7],_cr_,_cq_,_cp_)}
    function element$2(e){return e instanceof svg_element?e:no_handler}
    function unsafeCoerce$0(e,tag)
     {var t9=e.tagName,_co_=caml_jsstring_of_string(tag);
      return t9.toLowerCase() === _co_?e:no_handler}
    function a$0(e){return unsafeCoerce$0(e,cst_a$3)}
    function altGlyph(e){return unsafeCoerce$0(e,cst_altglyph$0)}
    function altGlyphDef(e){return unsafeCoerce$0(e,cst_altglyphdef$0)}
    function altGlyphItem(e){return unsafeCoerce$0(e,cst_altglyphitem$0)}
    function animate(e){return unsafeCoerce$0(e,cst_animate$0)}
    function animateColor(e){return unsafeCoerce$0(e,cst_animatecolor$0)}
    function animateMotion(e){return unsafeCoerce$0(e,cst_animatemotion$0)}
    function animateTransform(e)
     {return unsafeCoerce$0(e,cst_animatetransform$0)}
    function circle(e){return unsafeCoerce$0(e,cst_circle$0)}
    function clipPath(e){return unsafeCoerce$0(e,cst_clippath$0)}
    function cursor(e){return unsafeCoerce$0(e,cst_cursor$0)}
    function defs(e){return unsafeCoerce$0(e,cst_defs$0)}
    function desc(e){return unsafeCoerce$0(e,cst_desc$0)}
    function ellipse(e){return unsafeCoerce$0(e,cst_ellipse$0)}
    function filter(e){return unsafeCoerce$0(e,cst_filter$0)}
    function font(e){return unsafeCoerce$0(e,cst_font$0)}
    function fontFace(e){return unsafeCoerce$0(e,cst_font_face$0)}
    function fontFaceFormat(e)
     {return unsafeCoerce$0(e,cst_font_face_format$0)}
    function fontFaceName(e){return unsafeCoerce$0(e,cst_font_face_name$0)}
    function fontFaceSrc(e){return unsafeCoerce$0(e,cst_font_face_src$0)}
    function fontFaceUri(e){return unsafeCoerce$0(e,cst_font_face_uri$0)}
    function foreignObject(e){return unsafeCoerce$0(e,cst_foreignobject)}
    function g(e){return unsafeCoerce$0(e,cst_g$1)}
    function glyph(e){return unsafeCoerce$0(e,cst_glyph$0)}
    function glyphRef(e){return unsafeCoerce$0(e,cst_glyphref$0)}
    function hkern(e){return unsafeCoerce$0(e,cst_hkern$0)}
    function image(e){return unsafeCoerce$0(e,cst_image$0)}
    function lineElement(e){return unsafeCoerce$0(e,cst_line$0)}
    function linearElement(e){return unsafeCoerce$0(e,cst_lineargradient$0)}
    function mask(e){return unsafeCoerce$0(e,cst_mask$0)}
    function metaData(e){return unsafeCoerce$0(e,cst_metadata$0)}
    function missingGlyph(e){return unsafeCoerce$0(e,cst_missing_glyph$0)}
    function mPath(e){return unsafeCoerce$0(e,cst_mpath$0)}
    function path$0(e){return unsafeCoerce$0(e,cst_path$0)}
    function pattern(e){return unsafeCoerce$0(e,cst_pattern$0)}
    function polygon(e){return unsafeCoerce$0(e,cst_polygon$0)}
    function polyline(e){return unsafeCoerce$0(e,cst_polyline$0)}
    function radialgradient(e){return unsafeCoerce$0(e,cst_radialgradient$0)}
    function rect(e){return unsafeCoerce$0(e,cst_rect$0)}
    function script$0(e){return unsafeCoerce$0(e,cst_script$3)}
    function set$1(e){return unsafeCoerce$0(e,cst_set$0)}
    function stop(e){return unsafeCoerce$0(e,cst_stop$0)}
    function style$0(e){return unsafeCoerce$0(e,cst_style$3)}
    function svg(e){return unsafeCoerce$0(e,cst_svg$0)}
    function switch$0(e){return unsafeCoerce$0(e,cst_switch$0)}
    function symbol$12(e){return unsafeCoerce$0(e,cst_symbol$0)}
    function textElement(e){return unsafeCoerce$0(e,cst_text$1)}
    function textpath(e){return unsafeCoerce$0(e,cst_textpath$0)}
    function title$0(e){return unsafeCoerce$0(e,cst_title$3)}
    function tref(e){return unsafeCoerce$0(e,cst_tref$0)}
    function tspan(e){return unsafeCoerce$0(e,cst_tspan$0)}
    function use(e){return unsafeCoerce$0(e,cst_use$0)}
    function view(e){return unsafeCoerce$0(e,cst_view$0)}
    function vkern(e){return unsafeCoerce$0(e,cst_vkern$0)}
    var
     Js_of_ocaml_Dom_svg=
      [0,
       t0,
       SVGError,
       createElement$0,
       createA$0,
       createAltGlyph,
       createAltGlyphDef,
       createAltGlyphItem,
       createAnimate,
       createAnimateColor,
       createAnimateMotion,
       createAnimateTransform,
       createCircle,
       createClipPath,
       createCursor,
       createDefs,
       createDesc,
       createEllipse,
       createFilter,
       createFont,
       createFontFace,
       createFontFaceFormat,
       createFontFaceName,
       createFontFaceSrc,
       createFontFaceUri,
       createForeignObject,
       createG,
       createGlyph,
       createGlyphRef,
       createhkern,
       createImage,
       createLineElement,
       createLinearElement,
       createMask,
       createMetaData,
       createMissingGlyph,
       createMPath,
       createPath,
       createPattern,
       createPolygon,
       createPolyline,
       createRadialgradient,
       createRect,
       createScript$0,
       createSet,
       createStop,
       createStyle$0,
       createSvg,
       createSwitch,
       createSymbol,
       createTextElement,
       createTextpath,
       createTitle$0,
       createTref,
       createTspan,
       createUse,
       createView,
       createvkern,
       svg_element,
       document$0,
       getElementById$0,
       [0,
        element$2,
        a$0,
        altGlyph,
        altGlyphDef,
        altGlyphItem,
        animate,
        animateColor,
        animateMotion,
        animateTransform,
        circle,
        clipPath,
        cursor,
        defs,
        desc,
        ellipse,
        filter,
        font,
        fontFace,
        fontFaceFormat,
        fontFaceName,
        fontFaceSrc,
        fontFaceUri,
        foreignObject,
        g,
        glyph,
        glyphRef,
        hkern,
        image,
        lineElement,
        linearElement,
        mask,
        metaData,
        missingGlyph,
        mPath,
        path$0,
        pattern,
        polygon,
        polyline,
        radialgradient,
        rect,
        script$0,
        set$1,
        stop,
        style$0,
        svg,
        switch$0,
        symbol$12,
        textElement,
        textpath,
        title$0,
        tref,
        tspan,
        use,
        view,
        vkern]];
    caml_register_global(1665,Js_of_ocaml_Dom_svg,"Js_of_ocaml__Dom_svg");
    function withCredentials(b)
     {var init={};init.withCredentials = ! ! b;return init}
    var
     eventSource=Unsafe[1].EventSource,
     eventSource_options=Unsafe[1].EventSource,
     Js_of_ocaml_EventSource=
      [0,withCredentials,eventSource,eventSource_options,addEventListener];
    caml_register_global
     (1666,Js_of_ocaml_EventSource,"Js_of_ocaml__EventSource");
    var
     console=runtime.caml_js_get_console(0),
     Js_of_ocaml_Firebug=[0,console];
    caml_register_global(1667,Js_of_ocaml_Firebug,"Js_of_ocaml__Firebug");
    function empty_position_options(param){return {}}
    var
     x=Unsafe[1].navigator,
     geolocation=caml_call1(Optdef[5],x)?x.geolocation:x;
    function is_supported$2(param){return caml_call1(Optdef[5],geolocation)}
    var
     Js_of_ocaml_Geolocation=
      [0,empty_position_options,geolocation,is_supported$2];
    caml_register_global
     (1668,Js_of_ocaml_Geolocation,"Js_of_ocaml__Geolocation");
    function empty_intersection_observer_op(param){return {}}
    var intersectionObserver_unsafe=Unsafe[1].IntersectionObserver;
    function is_supported$3(param)
     {return caml_call1(Optdef[5],intersectionObserver_unsafe)}
    var
     Js_of_ocaml_IntersectionObserv=
      [0,
       empty_intersection_observer_op,
       is_supported$3,
       intersectionObserver_unsafe];
    caml_register_global
     (1669,Js_of_ocaml_IntersectionObserv,"Js_of_ocaml__IntersectionObserver");
    function object_options(param){return {"localeMatcher":"best fit"}}
    function options(param)
     {return {"localeMatcher":"best fit",
              "usage":"sort",
              "sensitivity":"variant",
              "ignorePunctuation":t4,
              "numeric":t4,
              "caseFirst":"false"}}
    var Collator=[0,object_options,options];
    function options$0(param)
     {return {"localeMatcher":"best fit",
              "timeZone":t39,
              "hour12":t39,
              "hourCycle":t39,
              "formatMatcher":"best fit",
              "weekday":t39,
              "era":t39,
              "year":t39,
              "month":t39,
              "day":t39,
              "hour":t39,
              "minute":t39,
              "second":t39,
              "timeZoneName":t39}}
    var DateTimeFormat=[0,object_options,options$0];
    function options$1(param)
     {return {"localeMatcher":"best fit",
              "style":"decimal",
              "currency":t39,
              "currencyDisplay":t39,
              "useGrouping":t25,
              "minimumIntegerDigits":t39,
              "minimumFractionDigits":t39,
              "maximumFractionDigits":t39,
              "minimumSignificantDigits":t39,
              "maximumSignificantDigits":t39}}
    var NumberFormat=[0,object_options,options$1];
    function options$2(param)
     {return {"localeMatcher":"best fit","type":"cardinal"}}
    var
     PluralRules=[0,object_options,options$2],
     intl=Unsafe[1].Intl,
     collator_constr=Unsafe[1].Intl.Collator,
     dateTimeFormat_constr=Unsafe[1].Intl.DateTimeFormat,
     numberFormat_constr=Unsafe[1].Intl.NumberFormat,
     pluralRules_constr=Unsafe[1].Intl.PluralRules;
    function is_supported$4(param){return caml_call1(Optdef[5],intl)}
    var
     Js_of_ocaml_Intl=
      [0,
       Collator,
       DateTimeFormat,
       NumberFormat,
       PluralRules,
       intl,
       collator_constr,
       dateTimeFormat_constr,
       numberFormat_constr,
       pluralRules_constr,
       is_supported$4];
    caml_register_global(1670,Js_of_ocaml_Intl,"Js_of_ocaml__Intl");
    var Js_of_ocaml$0=[0];
    caml_register_global(1671,Js_of_ocaml$0,"Js_of_ocaml");
    return}
  (function(){return this}()));


//# 1 ".ace_js.eobjs/byte/dune__exe__Ace_js.cmo.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_string_of_jsbytes=runtime.caml_string_of_jsbytes,
     caml_string_of_jsstring=runtime.caml_string_of_jsstring,
     caml_wrap_exception=runtime.caml_wrap_exception;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5
              ?f(a0,a1,a2,a3,a4)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4])}
    var
     global_data=runtime.caml_get_global_data(),
     cst_compute=caml_string_of_jsbytes("compute"),
     cst_click=caml_string_of_jsbytes("click"),
     cst_main=caml_string_of_jsbytes("main"),
     cst_secondary=caml_string_of_jsbytes("secondary"),
     cst_output=caml_string_of_jsbytes("output"),
     cst_lang=caml_string_of_jsbytes("lang"),
     cst=caml_string_of_jsbytes(""),
     cst$0=caml_string_of_jsbytes("\n=====\n"),
     cst_exit=caml_string_of_jsbytes("exit"),
     cst_Invalid_headers=caml_string_of_jsbytes("Invalid headers."),
     cst_load=caml_string_of_jsbytes("load"),
     Js_of_ocaml_Dom_html=global_data.Js_of_ocaml__Dom_html,
     Stdlib_option=global_data.Stdlib__option,
     Js_of_ocaml_Js=global_data.Js_of_ocaml__Js,
     Stdlib=global_data.Stdlib,
     Settings=global_data.Settings,
     Stdlib_buffer=global_data.Stdlib__buffer,
     Stdlib_format=global_data.Stdlib__format,
     Fs=global_data.Fs,
     Preprocess=global_data.Preprocess,
     Exit=global_data.Exit,
     Ace_common=global_data.Ace_common,
     Stdlib_printexc=global_data.Stdlib__printexc;
    function treat_input(lang,str)
     {caml_call1(Settings[3],lang);
      var
       buffer=caml_call1(Stdlib_buffer[1],1000),
       fmt=caml_call1(Stdlib_format[109],buffer);
      try
       {var
         fs=caml_call1(Fs[1],str),
         match=caml_call1(Fs[3],fs),
         program=match[2],
         headers=match[1],
         env=caml_call2(Preprocess[5],fmt,headers),
         match$0=caml_call2(Preprocess[2],headers,cst_exit);
        if(typeof match$0 === "number")
         var headers2=0,exit=0;
        else
         if(0 === match$0[0])
          var
           fn=match$0[1],
           match$1=caml_call2(Fs[4],fn,fs),
           ast=match$1[2],
           headers$0=match$1[1],
           exit$0=caml_call3(Exit[3],fmt,env,[0,headers$0,ast]),
           headers2=headers$0,
           exit=[0,exit$0];
         else
          var
           _l_=caml_call1(Stdlib[2],cst_Invalid_headers),
           headers2=_l_[2],
           exit=_l_[1];
        caml_call5(Ace_common[2],fmt,env,[0,headers,headers2],program,exit)}
      catch(e)
       {e = caml_wrap_exception(e);
        var _k_=caml_call1(Stdlib_printexc[1],e);
        caml_call2(Stdlib_buffer[14],buffer,_k_)}
      caml_call2(Stdlib_format[36],fmt,0);
      return caml_call1(Stdlib_buffer[2],buffer)}
    function is_blank_str(s)
     {var i$1=runtime.caml_ml_string_length(s) - 1 | 0,i=i$1;
      for(;;)
       {if(0 <= i)
         {var c=runtime.caml_string_get(s,i);
          if(32 !== c && 9 !== c && 10 !== c && 13 !== c)return 0;
          var i$0=i - 1 | 0,i=i$0;
          continue}
        return 1}}
    function compute(param)
     {var
       _f_=
        caml_call2
         (Js_of_ocaml_Dom_html[5],cst_main,Js_of_ocaml_Dom_html[117][55]),
       main_input=caml_call1(Stdlib_option[4],_f_),
       _g_=
        caml_call2
         (Js_of_ocaml_Dom_html[5],cst_secondary,Js_of_ocaml_Dom_html[117][55]),
       secondary_input=caml_call1(Stdlib_option[4],_g_),
       _h_=
        caml_call2
         (Js_of_ocaml_Dom_html[5],cst_output,Js_of_ocaml_Dom_html[117][55]),
       output=caml_call1(Stdlib_option[4],_h_),
       _i_=
        caml_call2
         (Js_of_ocaml_Dom_html[5],cst_lang,Js_of_ocaml_Dom_html[117][50]),
       lang=caml_call1(Stdlib_option[4],_i_),
       main_input$0=caml_string_of_jsstring(main_input.value),
       secondary_input$0=caml_string_of_jsstring(secondary_input.value),
       _j_=
        is_blank_str(secondary_input$0)
         ?cst
         :caml_call2(Stdlib[28],cst$0,secondary_input$0),
       input=caml_call2(Stdlib[28],main_input$0,_j_),
       lang$0=caml_string_of_jsstring(lang.value),
       res=treat_input(lang$0,input);
      output.value = runtime.caml_jsstring_of_string(res);
      return Js_of_ocaml_Js[7]}
    function init(param)
     {var
       _c_=
        caml_call2
         (Js_of_ocaml_Dom_html[5],cst_compute,Js_of_ocaml_Dom_html[117][9]),
       compute_button=caml_call1(Stdlib_option[4],_c_),
       _d_=caml_call1(Js_of_ocaml_Dom_html[10],compute),
       _e_=caml_call1(Js_of_ocaml_Dom_html[15][86],cst_click);
      caml_call4(Js_of_ocaml_Dom_html[17],compute_button,_e_,_d_,! ! 0);
      return Js_of_ocaml_Js[8]}
    var
     _a_=caml_call1(Js_of_ocaml_Dom_html[10],init),
     _b_=caml_call1(Js_of_ocaml_Dom_html[15][86],cst_load);
    caml_call4(Js_of_ocaml_Dom_html[17],Js_of_ocaml_Dom_html[8],_b_,_a_,! ! 0);
    var Dune_exe_Ace_js=[0,treat_input,is_blank_str,compute,init];
    runtime.caml_register_global(27,Dune_exe_Ace_js,"Dune__exe__Ace_js");
    return}
  (function(){return this}()));


//# 1 ".js/stdlib/std_exit.cmo.js"
(function(joo_global_object)
   {"use strict";
    var runtime=joo_global_object.jsoo_runtime;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    var global_data=runtime.caml_get_global_data(),Stdlib=global_data.Stdlib;
    caml_call1(Stdlib[103],0);
    var Std_exit=[0];
    runtime.caml_register_global(1,Std_exit,"Std_exit");
    return}
  (function(){return this}()));


//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJhY2VfanMuYmMuanMiLCJzb3VyY2VSb290IjoiIiwibmFtZXMiOlsiY2FtbF9pbnQ2NF9pc196ZXJvIiwieCIsImNhbWxfc3RyX3JlcGVhdCIsIm4iLCJzIiwiciIsImwiLCJjYW1sX2ludDY0X29mZnNldCIsIk1hdGgiLCJjYW1sX3JhaXNlX2NvbnN0YW50IiwidGFnIiwiY2FtbF9nbG9iYWxfZGF0YSIsImNhbWxfcmFpc2VfemVyb19kaXZpZGUiLCJNbEludDY0IiwibG8iLCJtaSIsImhpIiwidGhpcyIsInhoaSIsImgiLCJzaWduIiwib2Zmc2V0IiwibW9kdWx1cyIsImRpdmlzb3IiLCJxdW90aWVudCIsInkiLCJxIiwiY2FtbF9pbnQ2NF9vZl9pbnQzMiIsImNhbWxfaW50NjRfdG9faW50MzIiLCJjYW1sX2ludDY0X2lzX25lZ2F0aXZlIiwiY2FtbF9pbnQ2NF9uZWciLCJjYW1sX3N1YmFycmF5X3RvX2pzYnl0ZXMiLCJhIiwiaSIsImxlbiIsImYiLCJTdHJpbmciLCJudWxsIiwiY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyIsImNhbWxfanNieXRlc19vZl9zdHJpbmciLCJjYW1sX3JhaXNlX3dpdGhfYXJnIiwiYXJnIiwianNvb19pc19hc2NpaSIsImNhbWxfdXRmMTZfb2ZfdXRmOCIsImIiLCJ0IiwiYyIsImMxIiwiYzIiLCJ2IiwiaiIsIk1sQnl0ZXMiLCJjb250ZW50cyIsImxlbmd0aCIsImNvbnRlbnQiLCJjYW1sX2J5dGVzX29mX2pzYnl0ZXMiLCJjYW1sX3N0cmluZ19vZl9qc2J5dGVzIiwiY2FtbF9yYWlzZV93aXRoX3N0cmluZyIsIm1zZyIsImNhbWxfaW52YWxpZF9hcmd1bWVudCIsImNhbWxfcGFyc2VfZm9ybWF0IiwiZm10IiwiY2FtbF9maW5pc2hfZm9ybWF0dGluZyIsInJhd2J1ZmZlciIsImJ1ZmZlciIsImNhbWxfaW50NjRfZm9ybWF0Iiwid2Jhc2UiLCJjdnRibCIsInAiLCJjYW1sX2V4cG0xX2Zsb2F0IiwieiIsImNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nIiwiam9vX2dsb2JhbF9vYmplY3QiLCJjYW1sX2N1cnJlbnRfZGlyIiwiY2FtbF9tYWtlX3BhdGgiLCJuYW1lIiwiY29tcCIsIm5jb21wIiwiY2FtbF9pc19tbF9ieXRlcyIsImNhbWxfaXNfbWxfc3RyaW5nIiwiY2FtbF9ieXRlc19vZl9hcnJheSIsImNhbWxfYnl0ZXNfb2Zfc3RyaW5nIiwiY2FtbF91dGY4X29mX3V0ZjE2IiwiZCIsImNhbWxfYnl0ZXNfb2ZfdXRmMTZfanNzdHJpbmciLCJjYW1sX3N0cmluZ19vZl9qc3N0cmluZyIsImNhbWxfcmFpc2Vfc3lzX2Vycm9yIiwiY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUiLCJjYW1sX2J5dGVzX2JvdW5kX2Vycm9yIiwiY2FtbF9ieXRlc191bnNhZmVfZ2V0IiwiY2FtbF9ieXRlc19nZXQiLCJjYW1sX2NyZWF0ZV9ieXRlcyIsImNhbWxfbWxfYnl0ZXNfbGVuZ3RoIiwiY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5IiwiQXJyYXkiLCJjYW1sX2JsaXRfYnl0ZXMiLCJzMSIsImkxIiwiczIiLCJpMiIsImNhbWxfYmxpdF9zdHJpbmciLCJlIiwiTWxGaWxlIiwiTWxGYWtlRmlsZSIsIm9sZCIsImJ1ZiIsInBvcyIsImNsZW4iLCJuZXdfc3RyIiwib2xkX2RhdGEiLCJNbEZha2VEZXZpY2UiLCJyb290IiwicmVzIiwibmFtZV9zbGFzaCIsIlJlZ0V4cCIsInNlZW4iLCJtIiwib2siLCJmaWxlIiwiYnl0ZXMiLCJjYW1sX21sX3N0cmluZ19sZW5ndGgiLCJjYW1sX3N0cmluZ191bnNhZmVfZ2V0IiwiY2FtbF9hcnJheV9vZl9zdHJpbmciLCJjYW1sX2FycmF5X29mX2J5dGVzIiwiY2FtbF9ieXRlc191bnNhZmVfc2V0IiwiY2FtbF9ieXRlc19zZXQiLCJNbE5vZGVGaWxlIiwiZmQiLCJyZXF1aXJlIiwiZXJyIiwiYnVmX29mZnNldCIsIk1sTm9kZURldmljZSIsImNvbnN0cyIsImtleSIsIm8iLCJjYW1sX3Jvb3QiLCJmc19ub2RlX3N1cHBvcnRlZCIsImpzb29fbW91bnRfcG9pbnQiLCJyZXNvbHZlX2ZzX2RldmljZSIsInBhdGgiLCJjYW1sX3N5c19pc19kaXJlY3RvcnkiLCJjYW1sX3JhaXNlX25vdF9mb3VuZCIsImNhbWxfc3lzX2dldGVudiIsImciLCJ1bmRlZmluZWQiLCJzaGlmdF9yaWdodF9uYXQiLCJuYXQxIiwib2ZzMSIsImxlbjEiLCJuYXQyIiwib2ZzMiIsIm5iaXRzIiwid3JhcCIsImNhbWxfbmFtZWRfdmFsdWVzIiwiY2FtbF9uYW1lZF92YWx1ZSIsIm5tIiwiY2FtbF9ncl9zdGF0ZSIsImNhbWxfZ3Jfc3RhdGVfZ2V0IiwiY2FtbF9ncl9wb2ludF9jb2xvciIsImltIiwiTWxPYmplY3RUYWJsZSIsIk5haXZlTG9va3VwIiwib2JqcyIsImNhbWxfZmFpbHdpdGgiLCJjYW1sX3N5c19yZW5hbWUiLCJvX3Jvb3QiLCJuX3Jvb3QiLCJjYW1sX2xvZzEwX2Zsb2F0IiwiY2FtbF9ydW50aW1lX3dhcm5pbmdzIiwiY2FtbF9tbF9lbmFibGVfcnVudGltZV93YXJuaW5ncyIsImJvb2wiLCJjYW1sX2NsYXNzaWZ5X2Zsb2F0IiwiaXNGaW5pdGUiLCJpc05hTiIsImNhbWxfbWxfcmVmaWxsX2lucHV0IiwiY2hhbiIsInN0ciIsInN0cl9sZW4iLCJjYW1sX21sX2NoYW5uZWxzIiwiY2FtbF9tbF9tYXlfcmVmaWxsX2lucHV0IiwiY2hhbmlkIiwiY2FtbF9hcnJheV9ib3VuZF9lcnJvciIsImNhbWxfbWxfaW5wdXRfc2Nhbl9saW5lIiwiY2FtbF9nY19taW5vciIsImNhbWxfaW50NjRfb2ZfYnl0ZXMiLCJjYW1sX2JhX3VpbnQ4X2dldDY0IiwiYmEiLCJpMCIsIm9mcyIsImIxIiwiYjIiLCJiMyIsImI0IiwiYjUiLCJiNiIsImI3IiwiYjgiLCJjYW1sX2ludDY0X3RvX2J5dGVzIiwiY2FtbF9pbnQ2NF9tYXJzaGFsIiwid3JpdGVyIiwic2l6ZXMiLCJjYW1sX2JhX251bV9kaW1zIiwiY2FtbF9yZXR1cm5fZXhuX2NvbnN0YW50IiwiY2FtbF93cmFwX2V4Y2VwdGlvbiIsImNhbWxfY3JlYXRlX2ZpbGUiLCJjYW1sX2ZzX2luaXQiLCJ0bXAiLCJjYW1sX3NldF9wYXJzZXJfdHJhY2UiLCJjYW1sX2xpc3Rfb2ZfanNfYXJyYXkiLCJ1bml4X2dldHRpbWVvZmRheSIsIkRhdGUiLCJjYW1sX211bCIsImNhbWxfaGFzaF9taXhfaW50IiwibnVtX2RpZ2l0c19uYXQiLCJuYXQiLCJjYW1sX2hhc2hfbmF0IiwiY2FtbF9jYWxsX2dlbiIsImFyZ3MiLCJhcmdzTGVuIiwiZXh0cmFfYXJncyIsImFyZ3VtZW50cyIsIm5hcmdzIiwiY2FtbF9qc193cmFwX2NhbGxiYWNrX2FyZ3VtZW50cyIsImNhbWxfc3lzX2NoZGlyIiwiZGlyIiwiY2FtbF9nY19jb3VudGVycyIsImNhbWxfZ3Jfc3luY2hyb25pemUiLCJsb2cyX29rIiwianNvb19mbG9vcl9sb2cyIiwiSW5maW5pdHkiLCJjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXQiLCJmbG9hdDMyYSIsImludDMyYSIsImNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpIiwiY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0IiwiZXhwIiwiayIsInIzIiwicjIiLCJyMSIsImNhbWxfYmFfc2VyaWFsaXplIiwic3oiLCJjb21wbGV4IiwiY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudCIsImtpbmQiLCJjYW1sX2JhX2NyZWF0ZV9idWZmZXIiLCJzaXplIiwidmlldyIsImRhdGEiLCJjYW1sX2ludDMyX2Zsb2F0X29mX2JpdHMiLCJjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMiLCJOYU4iLCJjYW1sX2JhX2dldF9zaXplIiwiZGltcyIsIm5fZGltcyIsImNhbWxfaW50NjRfY3JlYXRlX2xvX2hpIiwiY2FtbF9pbnQ2NF9oaTMyIiwiY2FtbF9pbnQ2NF9sbzMyIiwiY2FtbF9iYV9jdXN0b21fbmFtZSIsIk1sX0JpZ2FycmF5IiwibGF5b3V0IiwicmUiLCJ0b3RhbCIsImsxIiwiazIiLCJNbF9CaWdhcnJheV9jXzFfMSIsImNhbWxfYmFfY3JlYXRlX3Vuc2FmZSIsInNpemVfcGVyX2VsZW1lbnQiLCJjYW1sX2JhX2Rlc2VyaWFsaXplIiwicmVhZGVyIiwibnVtX2RpbXMiLCJzaXplX2RpbSIsInNpemVfZGltX2hpIiwic2l6ZV9kaW1fbG8iLCJzaXh0eSIsImludDY0IiwiY2FtbF9iYV9jb21wYXJlIiwiY2FtbF9oYXNoX21peF9pbnQ2NCIsImNhbWxfaGFzaF9taXhfZmxvYXQiLCJ2MCIsImNhbWxfYmFfaGFzaCIsIm51bV9lbHRzIiwidyIsImNhbWxfaW50MzJfdW5tYXJzaGFsIiwiY2FtbF9uYXRpdmVpbnRfdW5tYXJzaGFsIiwiY2FtbF9pbnQ2NF91bm1hcnNoYWwiLCJjYW1sX2ludDY0X2NvbXBhcmUiLCJjYW1sX2ludDY0X2hhc2giLCJjYW1sX2N1c3RvbV9vcHMiLCJjYW1sX2NvbXBhcmVfdmFsX2dldF9jdXN0b20iLCJjYW1sX2NvbXBhcmVfdmFsX251bWJlcl9jdXN0b20iLCJudW0iLCJjdXN0b20iLCJzd2FwIiwiY2FtbF9jb21wYXJlX3ZhbF90YWciLCJOdW1iZXIiLCJjYW1sX2ludF9jb21wYXJlIiwiY2FtbF9ieXRlc19jb21wYXJlIiwiY2FtbF9zdHJpbmdfY29tcGFyZSIsImNhbWxfY29tcGFyZV92YWwiLCJzdGFjayIsInRhZ19hIiwidGFnX2IiLCJjYW1sX2dyZWF0ZXJ0aGFuIiwiZGl2X2hlbHBlciIsImRpdl9kaWdpdF9uYXQiLCJuYXRxIiwib2ZzcSIsIm5hdHIiLCJvZnNyIiwicmVtIiwibnVtX2xlYWRpbmdfemVyb19iaXRzX2luX2RpZ2l0Iiwic2hpZnRfbGVmdF9uYXQiLCJNbE5hdCIsImNyZWF0ZV9uYXQiLCJhcnIiLCJzZXRfdG9femVyb19uYXQiLCJpbmNyX25hdCIsImNhcnJ5X2luIiwiY2FycnkiLCJhZGRfbmF0IiwibGVuMiIsIm5hdF9vZl9hcnJheSIsIm11bHRfZGlnaXRfbmF0IiwibmF0MyIsIm9mczMiLCJ4MSIsIngyIiwieDMiLCJkZWNyX25hdCIsImJvcnJvdyIsInN1Yl9uYXQiLCJjb21wYXJlX25hdCIsImRpdl9uYXQiLCJxdW8iLCJjYW1sX2JhX2JsaXQiLCJzcmMiLCJkc3QiLCJpc19kaWdpdF9pbnQiLCJjYW1sX2ludDY0X2RpdiIsImNhbWxfanNfaHRtbF9lbnRpdGllcyIsImVudGl0eSIsInRlbXAiLCJkb2N1bWVudCIsImNhbWxfc3RyaW5nX3Vuc2FmZV9zZXQiLCJjYW1sX2ludDY0X29mX2Zsb2F0IiwiY2FtbF9tbF9jaGFubmVsX3NpemVfNjQiLCJjYW1sX2JhX3NldF8yIiwiY2FtbF9hcmd2IiwibWFpbiIsImFyZ3YiLCJhcmdzMiIsImNhbWxfZXhlY3V0YWJsZV9uYW1lIiwiY2FtbF9qc19ldmFsX3N0cmluZyIsImV2YWwiLCJjYW1sX0NhbWxpbnRlcm5hbE1vZF9pbml0X21vZCIsImxvYyIsInNoYXBlIiwidW5kZWZfbW9kdWxlIiwiX3giLCJsb29wIiwic3RydWN0IiwiaWR4Iiwic2VyaWFsaXplX25hdCIsImNhbWxfbWVtcHJvZl9zZXQiLCJfY29udHJvbCIsImNhbWxfc3lzX2V4aXQiLCJjb2RlIiwiY2FtbF9jaGFubmVsX2Rlc2NyaXB0b3IiLCJjYW1sX2pzX2Zyb21fYXJyYXkiLCJjYW1sX2JhX3Jlc2hhcGUiLCJ2aW5kIiwibmV3X2RpbSIsImNhbWxfb29fbGFzdF9pZCIsImNhbWxfc2V0X29vX2lkIiwiY2FtbF9ncl9maWxsX3JlY3QiLCJjYW1sX2JpZ3N0cmluZ19ibGl0X3N0cmluZ190b19iYSIsInN0cjEiLCJwb3MxIiwiYmEyIiwicG9zMiIsInNsaWNlIiwiY2FtbF9ncl9zZXRfd2luZG93X3RpdGxlIiwianNuYW1lIiwiY2FtbF9nZXRfZ2xvYmFsX2RhdGEiLCJjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0X3Vuc2lnbmVkIiwiY2FtbF9iYV91aW50OF9nZXQxNiIsImNhbWxfY29tcGFyZSIsImNhbWxfZnJlc2hfb29faWQiLCJjYW1sX2ludDY0X3RvX2Zsb2F0IiwiY2FtbF9iYV9nZXRfMSIsImNhbWxfYmlnc3RyaW5nX21lbWNtcCIsImNhbWxfbmV3X3N0cmluZyIsImNhbWxfYmFfdWludDhfZ2V0MzIiLCJjYW1sX3Jhd19iYWNrdHJhY2VfbGVuZ3RoIiwiY2FtbF9vYmpfYmxvY2siLCJjYW1sX2dyX2NsZWFyX2dyYXBoIiwiYmlnc3RyaW5nX3RvX2FycmF5X2J1ZmZlciIsImJzIiwiY2FtbF9zeXNfY29uc3RfbmFrZWRfcG9pbnRlcnNfY2hlY2tlZCIsIl91bml0IiwibHhvcl9kaWdpdF9uYXQiLCJjYW1sX2ZpbmFsX3JlbGVhc2UiLCJjYW1sX2pzX3RvX2FycmF5IiwiY2FtbF9ncl9wbG90IiwiY29sb3IiLCJjYW1sX2J5dGVzX3NldDY0IiwiaTY0IiwiY2FtbF9ieXRlc19zZXQxNiIsImkxNiIsImNhbWxfc3RyaW5nX3NldDE2IiwiY2FtbF9pbnQ2NF9ic3dhcCIsImNhbWxfZmlsbF9ieXRlcyIsImNhbWxfZmlsbF9zdHJpbmciLCJjYW1sX2djX21ham9yIiwiY2FtbF9sZXhfYXJyYXkiLCJjYW1sX2xleF9lbmdpbmUiLCJ0YmwiLCJzdGFydF9zdGF0ZSIsImxleGJ1ZiIsImxleF9idWZmZXIiLCJsZXhfYnVmZmVyX2xlbiIsImxleF9zdGFydF9wb3MiLCJsZXhfY3Vycl9wb3MiLCJsZXhfbGFzdF9wb3MiLCJsZXhfbGFzdF9hY3Rpb24iLCJsZXhfZW9mX3JlYWNoZWQiLCJsZXhfYmFzZSIsImxleF9iYWNrdHJrIiwibGV4X2RlZmF1bHQiLCJsZXhfdHJhbnMiLCJsZXhfY2hlY2siLCJzdGF0ZSIsImJhc2UiLCJiYWNrdHJrIiwiY2FtbF9zeXNfZmlsZV9leGlzdHMiLCJjYW1sX2NvbnZlcnRfcmF3X2JhY2t0cmFjZV9zbG90IiwiY2FtbF9hcnJheV9zdWIiLCJhMiIsImNhbWxfYnl0ZXNfZXF1YWwiLCJjYW1sX2dyX3NpemVfeCIsImNhbWxfbWxfZGVidWdfaW5mb19zdGF0dXMiLCJjYW1sX3N5c19jb25zdF9vc3R5cGVfY3lnd2luIiwiY2FtbF9jb3NoX2Zsb2F0IiwiY2FtbF9lcGhlX2tleV9vZmZzZXQiLCJjYW1sX3dlYWtfY2hlY2siLCJjYW1sX2VwaGVfY2hlY2tfa2V5IiwiY2FtbF9oYXNoX21peF9maW5hbCIsImNhbWxfZ3JfdGV4dF9zaXplIiwidHh0IiwiY2FtbF9sZXhfcnVuX21lbSIsIm1lbSIsImN1cnJfcG9zIiwiY2FtbF9sZXhfcnVuX3RhZyIsImNhbWxfbmV3X2xleF9lbmdpbmUiLCJsZXhfbWVtIiwibGV4X2Jhc2VfY29kZSIsImxleF9iYWNrdHJrX2NvZGUiLCJsZXhfZGVmYXVsdF9jb2RlIiwibGV4X3RyYW5zX2NvZGUiLCJsZXhfY2hlY2tfY29kZSIsImxleF9jb2RlIiwicGNfb2ZmIiwicHN0YXRlIiwiYmFzZV9jb2RlIiwiY2FtbF9iYV91aW50OF9zZXQ2NCIsImNhbWxfc3lzX2V4ZWN1dGFibGVfbmFtZSIsImNhbWxfbGVzc2VxdWFsIiwiY2FtbF9tbF9mbHVzaCIsIm91dHB1dCIsImNhbWxfbWxfc2Vla19vdXRfNjQiLCJjb21wYXJlX25hdF9yZWFsIiwiY2FtbF9nY19zZXQiLCJjYW1sX2pzX2dldCIsImNhbWxfZ2NfY29tcGFjdGlvbiIsImNhbWxfd2Vha19nZXQiLCJjYW1sX2VwaGVfZ2V0X2tleSIsImNhbWxfYmlnc3RyaW5nX2JsaXRfYnl0ZXNfdG9fYmEiLCJ3aW5fY2xlYW51cCIsImNhbWxfc3lzX2Nsb3NlIiwiY2FtbF9tbF9jbG9zZV9jaGFubmVsIiwiY2FtbF9leG5fd2l0aF9qc19iYWNrdHJhY2UiLCJleG4iLCJmb3JjZSIsImNhbWxfc3lzX2lzYXR0eSIsIl9jaGFuIiwiaXNfZGlnaXRfemVybyIsInVuaXhfaW5ldF9hZGRyX29mX3N0cmluZyIsImNhbWxfanNfc2V0IiwiY2FtbF9hcnJheV9nZXQiLCJhcnJheSIsImluZGV4IiwiY2FtbF9zcGFjZXRpbWVfb25seV93b3Jrc19mb3JfbmF0aXZlX2NvZGUiLCJjYW1sX2ludDY0X3N1YiIsImNhbWxfbWxfc2Vla19pbl82NCIsImNhbWxfaW50NjRfc2hpZnRfbGVmdCIsImNhbWxfbm90ZXF1YWwiLCJjYW1sX3N5c19jb25zdF9pbnRfc2l6ZSIsImNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrIiwiY2FtbF9pc19qcyIsImNhbWxfYmFfZGltIiwiY2FtbF9iYV9kaW1fMSIsInVuaXhfbG9jYWx0aW1lIiwiZF9udW0iLCJqYW51YXJ5Zmlyc3QiLCJkb3kiLCJqYW4iLCJqdWwiLCJzdGRUaW1lem9uZU9mZnNldCIsImNhbWxfanNfbWV0aF9jYWxsIiwiY2FtbF93ZWFrX2NyZWF0ZSIsImNhbWxfZXBoZV9jcmVhdGUiLCJjYW1sX2pzX3RvX2J5dGVfc3RyaW5nIiwidW5peF9ta3RpbWUiLCJ0bSIsInRtMiIsImNhbWxfdHJhbXBvbGluZSIsImNhbWxfYnl0ZXNfZ2V0NjQiLCJjYW1sX3dlYWtfc2V0IiwiY2FtbF9zeXNfcmVtb3ZlIiwiY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IiLCJjYW1sX3N0cmluZ19nZXQzMiIsImNhbWxfaHlwb3RfZmxvYXQiLCJjYW1sX2pzX2NhbGwiLCJjYW1sX3N5c19jb25zdF9tYXhfd29zaXplIiwiY2FtbF9lcGhlX3Vuc2V0X2tleSIsImNhbWxfaGFzaF9taXhfYnl0ZXNfYXJyIiwiY2FtbF9oYXNoX21peF9qc2J5dGVzIiwiY2FtbF9oYXNoX21peF9ieXRlcyIsImNhbWxfYnl0ZXNfbGVzc3RoYW4iLCJjYW1sX2dyX2ZpbGxfcG9seSIsImFyIiwiY2FtbF9nY19xdWlja19zdGF0IiwiY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZSIsImNhbWxfbWxfaW5wdXRfaW50IiwiY2FtbF9ncl9kaXNwbGF5X21vZGUiLCJudGhfZGlnaXRfbmF0IiwiY2FtbF9hcnJheV9ibGl0IiwiYTEiLCJjYW1sX2Zsb2F0X29mX3N0cmluZyIsIm0zIiwibWFudGlzc2EiLCJwYXJzZUludCIsImV4cG9uZW50IiwiY2FtbF9zeXNfZ2V0Y3dkIiwiY2FtbF9zeXNfY29uc3RfYmlnX2VuZGlhbiIsImNhbWxfbGlzdF90b19qc19hcnJheSIsImNhbWxfbGVnYWN5X2N1c3RvbV9jb2RlIiwiY2FtbF9vdXRwdXRfdmFsIiwiV3JpdGVyIiwidmFsdWUiLCJmbGFncyIsIm5vX3NoYXJpbmciLCJjbG9zdXJlcyIsImludGVybl9vYmpfdGFibGUiLCJtZW1vIiwiZXhpc3Rpbmdfb2Zmc2V0IiwiZXh0ZXJuX3JlYyIsIm9wcyIsInN6XzMyXzY0IiwiaGVhZGVyX3BvcyIsIm9sZF9wb3MiLCJ0eXBlX29mX3YiLCJjYW1sX3N0cmluZ19vZl9hcnJheSIsImNhbWxfb3V0cHV0X3ZhbHVlX3RvX3N0cmluZyIsImNhbWxfcmFpc2Vfbm90X2FfZGlyIiwiY2FtbF9zeXNfc3lzdGVtX2NvbW1hbmQiLCJjbWQiLCJ1bml4X2lzYXR0eSIsImZpbGVEZXNjcmlwdG9yIiwidHR5IiwiY2FtbF9qc19lcnJvcl9vZl9leGNlcHRpb24iLCJkZXNlcmlhbGl6ZV9uYXQiLCJpbml0aWFsaXplX25hdCIsImNhbWxfZ3Jfb3Blbl9zdWJ3aW5kb3ciLCJqc19wcmludF9zdGRvdXQiLCJjYW1sX2NvcHlzaWduX2Zsb2F0IiwiY2FtbF9ncl9zZXRfdGV4dF9zaXplIiwiY2FtbF9tZDVfYnl0ZXMiLCJhZGQiLCJ4eCIsImZmIiwiZ2ciLCJoaCIsImlpIiwibWQ1IiwiY2FtbF9iYV9zZXRfZ2VuZXJpYyIsImNhbWxfZXBoZV9zZXRfa2V5IiwiY2FtbF9ieXRlc19sZXNzZXF1YWwiLCJjYW1sX3N0cmluZ19sZXNzZXF1YWwiLCJjYW1sX3N0cmluZ19ncmVhdGVyZXF1YWwiLCJjYW1sX2ludDY0X2FkZCIsImNhbWxfbmV4dGFmdGVyX2Zsb2F0IiwiYml0cyIsIm9uZSIsImNhbWxfZ3Jfc2l6ZV95IiwiY2FtbF9tbF9wb3NfaW4iLCJjYW1sX2ludDY0X2FuZCIsImNhbWxfc3lzX2NvbnN0X3dvcmRfc2l6ZSIsImNhbWxfc3RkX291dHB1dCIsInNsZW4iLCJqc19wcmludF9zdGRlcnIiLCJjYW1sX3N5c19vcGVuX2ludGVybmFsIiwiaW5mbyIsImNhbWxfc3lzX29wZW4iLCJfcGVybXMiLCJNbFN0cmluZ1JlYWRlciIsImNhbWxfZmxvYXRfb2ZfYnl0ZXMiLCJjYW1sX2lucHV0X3ZhbHVlX2Zyb21fcmVhZGVyIiwiX21hZ2ljIiwiX2Jsb2NrX2xlbiIsIm51bV9vYmplY3RzIiwiX3NpemVfMzIiLCJfc2l6ZV82NCIsIm9ial9jb3VudGVyIiwiaW50ZXJuX3JlYyIsImhlYWRlciIsImV4cGVjdGVkX3NpemUiLCJjYW1sX3N0cmluZ19vZl9ieXRlcyIsImNhbWxfaW5wdXRfdmFsdWVfZnJvbV9ieXRlcyIsImNhbWxfc3RyaW5nX2dldCIsInJlX21hdGNoIiwicmVfd29yZF9sZXR0ZXJzIiwib3Bjb2RlcyIsImlzX3dvcmRfbGV0dGVyIiwiaW5fYml0c2V0IiwicmVfbWF0Y2hfaW1wbCIsInBhcnRpYWwiLCJwcm9nIiwiY3Bvb2wiLCJub3JtdGFibGUiLCJudW1ncm91cHMiLCJudW1yZWdpc3RlcnMiLCJzdGFydGNoYXJzIiwicGMiLCJxdWl0IiwiZ3JvdXBzIiwicmVfcmVnaXN0ZXIiLCJiYWNrdHJhY2siLCJpdGVtIiwicHVzaCIsImFjY2VwdCIsInJlc3VsdCIsInByZWZpeF9tYXRjaCIsIm9wIiwic2FyZyIsInVhcmciLCJncm91cCIsIkVycm9yIiwicmVfc2VhcmNoX2JhY2t3YXJkIiwiY2FtbF9qc19mcm9tX3N0cmluZyIsImNhbWxfYmFfc3ViIiwiY2hhbmdlZF9kaW0iLCJtdWwiLCJuZXdfZGltcyIsIm5ld19kYXRhIiwiY2FtbF9nY19mdWxsX21ham9yIiwiY2FtbF9ieXRlc19zZXQzMiIsImkzMiIsImNhbWxfZ3Jfc2lnaW9fc2lnbmFsIiwiY2FtbF9iYV91aW50OF9zZXQzMiIsImNhbWxfc3lzX2NvbnN0X29zdHlwZV91bml4IiwiY2FtbF9zaWduYml0X2Zsb2F0IiwiY2FtbF9ncl9jdXJyZW50X3giLCJjYW1sX2dyX3NldF9saW5lX3dpZHRoIiwiY2FtbF9ncl9zZXRfZm9udCIsImNhbWxfZ3Jfc2V0X2NvbG9yIiwiY29udmVydCIsIm51bWJlciIsImNfc3RyIiwiY2FtbF9ncl9tb3ZldG8iLCJjYW1sX2dyX3Jlc2l6ZV93aW5kb3ciLCJjYW1sX2dyX3N0YXRlX2luaXQiLCJjYW1sX2JhX2tpbmRfb2ZfdHlwZWRfYXJyYXkiLCJ0YSIsImNhbWxfYmFfZnJvbV90eXBlZF9hcnJheSIsImNhbWxfbWxfc2Vla19vdXQiLCJjYW1sX2pzX3R5cGVvZiIsImNhbWxfcmVzdG9yZV9yYXdfYmFja3RyYWNlIiwiYnQiLCJjYW1sX2dyX2xpbmV0byIsImNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrX3Vuc2FmZSIsImNhbWxfYmFfZGltXzMiLCJjYW1sX2VwaGVfZGF0YV9vZmZzZXQiLCJjYW1sX2VwaGVfY2hlY2tfZGF0YSIsImNhbWxfYnl0ZXNfZ2V0MTYiLCJjYW1sX29ial9tYWtlX2ZvcndhcmQiLCJjYW1sX2pzX2Zyb21fYm9vbCIsImNhbWxfbWxfc2V0X2NoYW5uZWxfbmFtZSIsImNhbWxfZ3JfY2xvc2VfZ3JhcGgiLCJjYW1sX2NyZWF0ZV9zdHJpbmciLCJjYW1sX21kNV9zdHJpbmciLCJjYW1sX21kNV9jaGFuIiwiY2hhbl9sZW4iLCJjYW1sX29ial9kdXAiLCJjYW1sX3dlYWtfZ2V0X2NvcHkiLCJjYW1sX21sX291dHB1dF9ieXRlcyIsInN0cmluZyIsImpzc3RyaW5nIiwiaWQiLCJjYW1sX21sX291dHB1dCIsImNhbWxfZXBoZV9nZXRfZGF0YSIsImNhbWxfeG1saHR0cHJlcXVlc3RfY3JlYXRlIiwidW5pdCIsImNhbWxfdHJhbXBvbGluZV9yZXR1cm4iLCJjYW1sX2FycmF5X2FwcGVuZCIsImwxIiwibDIiLCJjYW1sX21sX3NldF9jaGFubmVsX3JlZmlsbCIsImNhbWxfanNfZXhwciIsImNhbWxfaW50NjRfbXVsIiwiY2FtbF9tbF9ydW50aW1lX3dhcm5pbmdzX2VuYWJsZWQiLCJjYW1sX291dHB1dF92YWx1ZV90b19ieXRlcyIsImNhbWxfaGFzaF91bml2X3BhcmFtIiwiY291bnQiLCJsaW1pdCIsIm9iaiIsImhhc2hfYWNjdSIsImhhc2hfYXV4IiwianNieXRlcyIsImNhbWxfc3RyaW5nX2VxdWFsIiwiY2FtbF9vdXRwdXRfdmFsdWVfdG9fYnVmZmVyIiwicmVfcmVwbGFjZW1lbnRfdGV4dCIsInJlcGwiLCJvcmlnIiwiY3VyIiwic3RhcnQiLCJlbmQiLCJjYW1sX3B1cmVfanNfZXhwciIsImJsaXRfbmF0IiwiY2FtbF9pbnQ2NF91bHQiLCJjYW1sX2ludDY0X3hvciIsImNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYnl0ZXMiLCJiYTEiLCJieXRlczIiLCJjYW1sX3JlZ2lzdGVyX25hbWVkX3ZhbHVlIiwiY2FtbF90b19qc19zdHJpbmciLCJjYW1sX3BhcnNlX3NpZ25fYW5kX2Jhc2UiLCJjYW1sX3BhcnNlX2RpZ2l0IiwiY2FtbF9pbnQ2NF9vZl9zdHJpbmciLCJiYXNlNjQiLCJ0aHJlc2hvbGQiLCJyZV9zZWFyY2hfZm9yd2FyZCIsImNhbWxfYmxpdF9zdHJpbmdfdG9fYmlnc3RyaW5nIiwiY2FtbF9tYWtlX3ZlY3QiLCJpbml0IiwiY2FtbF9tbF9zZWVrX2luIiwiY2FtbF9zeXNfcmVhZF9kaXJlY3RvcnkiLCJjYW1sX21sX291dHB1dF9jaGFyIiwiY2FtbF9zeXNfY29uc3Rfb3N0eXBlX3dpbjMyIiwiY2FtbF9vYmpfaXNfYmxvY2siLCJjYW1sX21sX2lucHV0X2NoYXIiLCJjYW1sX29ial9zZXRfcmF3X2ZpZWxkIiwiY2FtbF9qc192YXIiLCJjYW1sX3RydW5jX2Zsb2F0IiwiY2FtbF9lcGhlX2JsaXRfZGF0YSIsImNhbWxfaXNfcHJpbnRhYmxlIiwiY2FtbF9lcXVhbCIsInJlX3BhcnRpYWxfbWF0Y2giLCJjYW1sX3N5c19yYW5kb21fc2VlZCIsIm5vdyIsImNhbWxfZmluYWxfcmVnaXN0ZXJfY2FsbGVkX3dpdGhvdXRfdmFsdWUiLCJjYW1sX2JhX2dldF8yIiwid2luX2hhbmRsZV9mZCIsImNhbWxfYmFfdWludDhfc2V0MTYiLCJjYW1sX2pzX2RlbGV0ZSIsImNhbWxfaW50X29mX3N0cmluZyIsImNhbWxfbGlzdF9tb3VudF9wb2ludCIsInByZXYiLCJjYW1sX21hcnNoYWxfY29uc3RhbnRzIiwiY2FtbF9vYmpfcmF3X2ZpZWxkIiwiY2FtbF9qc19lcXVhbHMiLCJiaWdzdHJpbmdfdG9fdHlwZWRfYXJyYXkiLCJjYW1sX2dyX2FyY19hdXgiLCJjdHgiLCJjeCIsImN5IiwicnkiLCJyeCIsInJvdCIsInhQb3MiLCJ5UG9zIiwieFBvc19wcmV2IiwieVBvc19wcmV2Iiwic3BhY2UiLCJkZWx0YSIsImNhbWxfZ3JfZmlsbF9hcmMiLCJjYW1sX2JhX3NsaWNlIiwibnVtX2luZHMiLCJzdWJfZGltcyIsImNhbWxfbWFyc2hhbF9kYXRhX3NpemUiLCJnZXQzMiIsImNhbWxfaW5wdXRfdmFsdWUiLCJjYW1sX2JhX2tpbmQiLCJjYW1sX2pzX2Z1bl9jYWxsIiwiY2FtbF9qc19wdXJlX2V4cHIiLCJjb21wYXJlX2RpZ2l0c19uYXQiLCJjYW1sX21sX2lucHV0IiwiY2FtbF9ncl93YWl0X2V2ZW50IiwiX2V2bCIsImNhbWxfZ3Jfc2lnaW9faGFuZGxlciIsImNhbWxfaGFzaF9taXhfYmlnc3RyaW5nIiwiY2FtbF9yZWNvcmRfYmFja3RyYWNlIiwidW5peF9nbXRpbWUiLCJjYW1sX3N5c19nZXRfY29uZmlnIiwiY2FtbF9zeXNfY29uc3RfYmFja2VuZF90eXBlIiwidW5peF90aW1lIiwiY2FtbF9tbF9vdXRfY2hhbm5lbHNfbGlzdCIsImJpZ3N0cmluZ19vZl9hcnJheV9idWZmZXIiLCJhYiIsImNhbWxfbW9kIiwiY2FtbF9iYV9pbml0IiwicmVfc3RyaW5nX21hdGNoIiwiQmlnU3RyaW5nUmVhZGVyIiwiY2FtbF9ncl9kdW1wX2ltYWdlIiwiY2FtbF9iYV9nZXRfZ2VuZXJpYyIsImNhbWxfZ2V0X2V4Y2VwdGlvbl9iYWNrdHJhY2UiLCJjYW1sX2Zvcm1hdF9mbG9hdCIsInRvRml4ZWQiLCJkcCIsInByZWMiLCJjYW1sX21vdW50X2F1dG9sb2FkIiwiY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19iYSIsImNhbWxfYmxpdF9iaWdzdHJpbmdfdG9fYmlnc3RyaW5nIiwiY2FtbF9zdHJpbmdfbGVzc3RoYW4iLCJjYW1sX3N0cmluZ19ncmVhdGVydGhhbiIsImNhbWxfZGl2IiwiY2FtbF9lcGhlX2dldF9kYXRhX2NvcHkiLCJjYW1sX21lbXByb2Zfc3RhcnQiLCJyYXRlIiwic3RhY2tfc2l6ZSIsInRyYWNrZXIiLCJjYW1sX3N5c19nZXRfYXJndiIsImNhbWxfanNfdG9fYm9vbCIsImNhbWxfZ3JfY3JlYXRlX2ltYWdlIiwiY2FtbF9lcGhlX2dldF9rZXlfY29weSIsImNhbWxfbGVzc3RoYW4iLCJjYW1sX3Jhd19iYWNrdHJhY2VfbmV4dF9zbG90IiwiY2FtbF9yZWdpc3Rlcl9nbG9iYWwiLCJuYW1lX29wdCIsIm11bHRfbmF0IiwibGVuMyIsInNxdWFyZV9uYXQiLCJjYW1sX2pzX2Zyb21fZmxvYXQiLCJjYW1sX2Zsb2F0YXJyYXlfY3JlYXRlIiwiY2FtbF9nY19zdGF0IiwiY2FtbF9zeXNfbW9kaWZ5X2FyZ3YiLCJjYW1sX21ldGhvZF9jYWNoZSIsImNhbWxfZ2V0X3B1YmxpY19tZXRob2QiLCJjYWNoZWlkIiwibWV0aHMiLCJsaSIsImNhbWxfanNfZ2V0X2NvbnNvbGUiLCJjYW1sX3N5c191bnNhZmVfZ2V0ZW52IiwiY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3JfaW4iLCJjaGFubmVsIiwiYmlnc3RyaW5nX29mX3R5cGVkX2FycmF5IiwiY2FtbF9yb3VuZF9mbG9hdCIsImNhbWxfb2pzX25ld19hcnIiLCJGIiwiY29tcGxlbWVudF9uYXQiLCJjYW1sX2pzX3JlZ2V4cHMiLCJjYW1sX2pzX2h0bWxfZXNjYXBlIiwiY2FtbF9iYV9kaW1fMiIsImNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrX2FyZ3VtZW50cyIsImNhbWxfc2luaF9mbG9hdCIsImNhbWxfbGRleHBfZmxvYXQiLCJjYW1sX2dyX3N0YXRlX3NldCIsImNhbWxfanNfd3JhcF9jYWxsYmFja19zdHJpY3QiLCJhcml0eSIsImNhbWxfYmFfc2V0XzEiLCJjYW1sX2dldF9jdXJyZW50X2NhbGxzdGFjayIsImxhbmRfZGlnaXRfbmF0IiwiY2FtbF9pbnQ2NF9tb2QiLCJjYW1sX29ial9zZXRfdGFnIiwiY2FtbF9jcmVhdGVfZmlsZV9leHRlcm4iLCJjYW1sX2ludDMyX2Jzd2FwIiwid2luX3N0YXJ0dXAiLCJjYW1sX2JhX3NldF8zIiwiY2FtbF9qc19pbnN0YW5jZW9mIiwiY2FtbF9ibGl0X2JpZ3N0cmluZ190b19zdHJpbmciLCJudGhfZGlnaXRfbmF0X25hdGl2ZSIsInNldF9kaWdpdF9uYXRfbmF0aXZlIiwiZGlnaXQiLCJjYW1sX3N0cmluZ19zZXQ2NCIsImNhbWxfZ3Jfc3RhdGVfY3JlYXRlIiwiY2FudmFzIiwiY29udGV4dCIsImNhbWxfanNfd3JhcF9jYWxsYmFjayIsImNhbWxfZ3JfZHJhd19hcmMiLCJjYW1sX2JhX21hcF9maWxlIiwidmZkIiwic2hhcmVkIiwiY2FtbF9iYV9tYXBfZmlsZV9ieXRlY29kZSIsImFyZ24iLCJjYW1sX2JhX2NyZWF0ZV9mcm9tIiwiZGF0YTEiLCJkYXRhMiIsImpzdHlwIiwiY2FtbF90YW5oX2Zsb2F0IiwiY2FtbF9ncl9kcmF3X3N0ciIsImR4IiwiY2FtbF9ncl9kcmF3X3N0cmluZyIsImNhbWxfZ3JfZHJhd19jaGFyIiwiY2FtbF91bm1vdW50IiwiY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3N0cmluZyIsImNhbWxfbWxfcG9zX2luXzY0IiwiY2FtbF9ncl9kcmF3X2ltYWdlIiwiaW1hZ2UiLCJjYW1sX3JlZ2lzdGVyX2NoYW5uZWxfZm9yX3NwYWNldGltZSIsIl9jaGFubmVsIiwiY2FtbF9zdHJpbmdfc2V0IiwiY2FtbF9tbF9wb3Nfb3V0IiwiY2FtbF9zcGFjZXRpbWVfZW5hYmxlZCIsImNhbWxfYnl0ZXNfbm90ZXF1YWwiLCJjYW1sX3J1bnRpbWVfcGFyYW1ldGVycyIsImNhbWxfanNfb2JqZWN0IiwiY2FtbF9iYV9jcmVhdGUiLCJkaW1zX21sIiwiY2FtbF93ZWFrX2JsaXQiLCJjYW1sX2dyX3JlbWVtYmVyX21vZGUiLCJjYW1sX2Jzd2FwMTYiLCJjYW1sX21sX3NldF9iaW5hcnlfbW9kZSIsIm1vZGUiLCJjYW1sX2ZpbmFsX3JlZ2lzdGVyIiwiY2FtbF9ncl9kcmF3X3JlY3QiLCJjYW1sX3N0cmluZ19nZXQxNiIsImNhbWxfZXBoZV91bnNldF9kYXRhIiwiY2FtbF9vdXRwdXRfdmFsdWUiLCJjYW1sX2JhX2dldF8zIiwiY2FtbF9lcGhlX2JsaXRfa2V5IiwiY2FtbF9pbml0aWFsX3RpbWUiLCJjYW1sX3N5c190aW1lIiwiY2FtbF9zeXNfdGltZV9pbmNsdWRlX2NoaWxkcmVuIiwiY2FtbF9jaGVja19ib3VuZCIsImNhbWxfaGFzaF9taXhfc3RyaW5nIiwiY2FtbF9oYXNoIiwic2VlZCIsInF1ZXVlIiwicmQiLCJ3ciIsImNhbWxfb2JqX3RhZyIsIkZ1bmN0aW9uIiwiY2FtbF9iYV90b190eXBlZF9hcnJheSIsImNhbWxfanNfZXhwb3J0X3ZhciIsIm1vZHVsZSIsImNhbWxfYnl0ZXNfZ2V0MzIiLCJjYW1sX2ZyZXhwX2Zsb2F0IiwibmVnIiwiY2FtbF9zdHJpbmdfZ2V0NjQiLCJjYW1sX21sX3Bvc19vdXRfNjQiLCJjYW1sX2dyX2Nsb3NlX3N1YndpbmRvdyIsImNhbWxfZmxvYXRhcnJheV9ibGl0IiwiY2FtbF9zZXRfc3RhdGljX2VudiIsImNhbWxfYmFfY2hhbmdlX2xheW91dCIsImNhbWxfanNfbmV3IiwiY2FtbF9ncl9jdXJyZW50X3kiLCJjYW1sX2Zvcm1hdF9pbnQiLCJjYW1sX29ial90cnVuY2F0ZSIsImNhbWxfanNfdG9fc3RyaW5nIiwiaXNfZGlnaXRfb2RkIiwiY2FtbF9ydW50aW1lX3ZhcmlhbnQiLCJjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9vdXQiLCJjYW1sX2FycmF5X2NvbmNhdCIsImNhbWxfZ3Jfb3Blbl9ncmFwaCIsImdldCIsInNwZWNzIiwidGFyZ2V0Iiwic3RhdHVzIiwid2luIiwiZG9jIiwidGl0bGUiLCJib2R5IiwiY2FtbF9lcGhlX3NldF9kYXRhIiwiY2FtbF9tYWtlX2Zsb2F0X3ZlY3QiLCJjYW1sX21lbXByb2Zfc3RvcCIsImNhbWxfZ3JlYXRlcmVxdWFsIiwiY2FtbF9nZXRfZXhjZXB0aW9uX3Jhd19iYWNrdHJhY2UiLCJjYW1sX2xvZzFwX2Zsb2F0IiwiY2FtbF9pbnQ2NF9vciIsImNhbWxfbGF6eV9tYWtlX2ZvcndhcmQiLCJsb3JfZGlnaXRfbmF0IiwiY2FtbF9ncl9ibGl0X2ltYWdlIiwiaW0yIiwiY2FtbF9ncl93aW5kb3dfaWQiLCJjYW1sX2pzX29uX2llIiwidWEiLCJjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0IiwiY2FtbF9iYV9sYXlvdXQiLCJjYW1sX2NvbnZlcnRfcmF3X2JhY2t0cmFjZSIsImNhbWxfYXJyYXlfc2V0IiwibmV3dmFsIiwiY2FtbF9ieXRlc19ncmVhdGVyZXF1YWwiLCJzZXRfZGlnaXRfbmF0IiwiY2FtbF91cGRhdGVfZHVtbXkiLCJjYW1sX0NhbWxpbnRlcm5hbE1vZF91cGRhdGVfbW9kIiwicmVhbCIsImNhbWxfZ3JfZG9jX29mX3N0YXRlIiwiY2FtbF9tbF9vdXRwdXRfaW50IiwiY2FtbF9vYmpfd2l0aF90YWciLCJjYW1sX21sX2NoYW5uZWxfc2l6ZSIsImNhbWxfcmF3X2JhY2t0cmFjZV9zbG90IiwiY2FtbF9oZXhzdHJpbmdfb2ZfZmxvYXQiLCJzdHlsZSIsImV4cF9zaWduIiwic2lnbl9zdHIiLCJjc3QiLCJ4X3N0ciIsImNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrX3N0cmljdCIsImNhbWxfYmFja3RyYWNlX3N0YXR1cyIsImNhbWxfaW5zdGFsbF9zaWduYWxfaGFuZGxlciIsImNhbWxfc3lzX2FyZ3YiLCJjYW1sX2JhX2ZpbGwiLCJjYW1sX21vZGZfZmxvYXQiLCJjYW1sX2djX2dldCIsImNhbWxfZmxvYXRfY29tcGFyZSIsImNhbWxfc3RyaW5nX3NldDMyIiwiY2FtbF9wYXJzZV9lbmdpbmUiLCJ0YWJsZXMiLCJlbnYiLCJFUlJDT0RFIiwidGVzdHNoaWZ0Iiwic2hpZnQiLCJzaGlmdF9yZWNvdmVyIiwicmVkdWNlIiwiUkVBRF9UT0tFTiIsIlJBSVNFX1BBUlNFX0VSUk9SIiwiR1JPV19TVEFDS1NfMSIsIkdST1dfU1RBQ0tTXzIiLCJDT01QVVRFX1NFTUFOVElDX0FDVElPTiIsIkNBTExfRVJST1JfRlVOQ1RJT04iLCJlbnZfc19zdGFjayIsImVudl92X3N0YWNrIiwiZW52X3N5bWJfc3RhcnRfc3RhY2siLCJlbnZfc3ltYl9lbmRfc3RhY2siLCJlbnZfc3RhY2tzaXplIiwiZW52X3N0YWNrYmFzZSIsImVudl9jdXJyX2NoYXIiLCJlbnZfbHZhbCIsImVudl9zeW1iX3N0YXJ0IiwiZW52X3N5bWJfZW5kIiwiZW52X2FzcCIsImVudl9ydWxlX2xlbiIsImVudl9ydWxlX251bWJlciIsImVudl9zcCIsImVudl9zdGF0ZSIsImVudl9lcnJmbGFnIiwidGJsX3RyYW5zbF9jb25zdCIsInRibF90cmFuc2xfYmxvY2siLCJ0YmxfbGhzIiwidGJsX2xlbiIsInRibF9kZWZyZWQiLCJ0YmxfZGdvdG8iLCJ0Ymxfc2luZGV4IiwidGJsX3JpbmRleCIsInRibF9naW5kZXgiLCJ0YmxfdGFibGVzaXplIiwidGJsX3RhYmxlIiwidGJsX2NoZWNrIiwibjEiLCJuMiIsInN0YXRlMSIsInNwIiwiZXJyZmxhZyIsImFzcCIsImNhbWxfYXJyYXlfZmlsbCIsImNhbWxfc3RyaW5nX25vdGVxdWFsIiwiY2FtbF9ieXRlc19ncmVhdGVydGhhbiIsImNhbWxfZ3JfbWFrZV9pbWFnZSIsImNhbWxfbWxfc2V0X2NoYW5uZWxfb3V0cHV0IiwiY2FtbF9yZWFkX2ZpbGVfY29udGVudCIsImNhbWxfanNfdG9fZmxvYXQiLCJlcnJfbm9fcHJlZCIsImVycl9ub19zdWNjIiwiemVybyQyIiwib25lJDIiLCJtaW51c19vbmUkMiIsIm1pbl9pbnQkMiIsIm1heF9pbnQkMiIsImR1bW15X3BvcyIsInplcm9fcG9zIiwic3ViX2Zvcm1hdCIsImZvcm1hdHRpbmdfbGl0IiwibG9jZm10IiwibnVsbCQwIiwiY3VycmVudF9kaXJfbmFtZSIsInBhcmVudF9kaXJfbmFtZSIsImRpcl9zZXAiLCJxdW90ZXF1b3RlIiwibnVsbCQxIiwiY3VycmVudF9kaXJfbmFtZSQwIiwicGFyZW50X2Rpcl9uYW1lJDAiLCJkaXJfc2VwJDAiLCJudWxsJDIiLCJjdXJyZW50X2Rpcl9uYW1lJDEiLCJwYXJlbnRfZGlyX25hbWUkMSIsImRpcl9zZXAkMSIsInplcm8kNCIsIm9uZSQ0IiwiaSIsImVyYXNlX3JlbCIsInJlc3QiLCJyZXN0JDAiLCJyZXN0JDEiLCJyZXN0JDIiLCJyZXN0JDMiLCJyZXN0JDQiLCJyZXN0JDUiLCJyZXN0JDYiLCJyZXN0JDciLCJ0eSIsInJlc3QkOCIsInR5MSIsInJlc3QkOSIsInJlc3QkMTAiLCJyZXN0JDExIiwicmVzdCQxMiIsInJlc3QkMTMiLCJjb25jYXRfZm10dHkiLCJmbXR0eTEiLCJmbXR0eTIiLCJ0eTIiLCJjb25jYXRfZm10IiwiZm10MSIsImZtdDIiLCJwYWQiLCJwYWQkMCIsInByZWMiLCJwYWQkMSIsImljb252IiwicHJlYyQwIiwicGFkJDIiLCJpY29udiQwIiwicHJlYyQxIiwicGFkJDMiLCJpY29udiQxIiwicHJlYyQyIiwicGFkJDQiLCJpY29udiQyIiwicHJlYyQzIiwicGFkJDUiLCJmY29udiIsInBhZCQ2Iiwic3RyIiwiY2hyIiwiZm10dHkiLCJwYWQkNyIsImZtdHR5JDAiLCJwYWQkOCIsInJlc3QkMTQiLCJyZXN0JDE1IiwicmVzdCQxNiIsImZtdGluZ19saXQiLCJyZXN0JDE3IiwiZm10aW5nX2dlbiIsInJlc3QkMTgiLCJyZXN0JDE5IiwiY2hhcl9zZXQiLCJ3aWR0aF9vcHQiLCJyZXN0JDIwIiwiY291bnRlciIsInJlc3QkMjEiLCJyZXN0JDIyIiwiaWduIiwicmVzdCQyMyIsImYiLCJhcml0eSIsInYiLCJyIiwiY3VyIiwic2VlbiIsIm4iLCJmYWlsd2l0aCIsInMiLCJpbnZhbGlkX2FyZyIsIm1pbiIsIngiLCJ5IiwibWF4IiwiYWJzIiwibG5vdCIsImluZmluaXR5IiwibmVnX2luZmluaXR5IiwibmFuIiwibWF4X2Zsb2F0IiwibWluX2Zsb2F0IiwiZXBzaWxvbiIsIm1heF9pbnQiLCJtaW5faW50Iiwic3ltYm9sIiwiczEiLCJzMiIsImwxIiwibDIiLCJjaGFyX29mX2ludCIsInN0cmluZ19vZl9ib29sIiwiYiIsImJvb2xfb2Zfc3RyaW5nIiwiYm9vbF9vZl9zdHJpbmdfb3B0Iiwic3RyaW5nX29mX2ludCIsImludF9vZl9zdHJpbmdfb3B0IiwidmFsaWRfZmxvYXRfbGV4ZW0iLCJsIiwiaSQwIiwidG9fc3RyaW5nIiwib2Zfc3RyaW5nX29wdCIsImFwcGVuZCIsInRsIiwiaGQiLCJzdGRpbiIsInN0ZG91dCIsInN0ZGVyciIsIm9wZW5fb3V0X2dlbiIsIm1vZGUiLCJwZXJtIiwibmFtZSIsImMiLCJvcGVuX291dCIsIm9wZW5fb3V0X2JpbiIsImZsdXNoX2FsbCIsIml0ZXIiLCJhIiwib3V0cHV0X2J5dGVzIiwib2MiLCJvdXRwdXRfc3RyaW5nIiwib3V0cHV0Iiwib2ZzIiwibGVuIiwib3V0cHV0X3N1YnN0cmluZyIsIm91dHB1dF92YWx1ZSIsImNoYW4iLCJjbG9zZV9vdXQiLCJjbG9zZV9vdXRfbm9lcnIiLCJvcGVuX2luX2dlbiIsIm9wZW5faW4iLCJvcGVuX2luX2JpbiIsImlucHV0IiwiaWMiLCJ1bnNhZmVfcmVhbGx5X2lucHV0Iiwib2ZzJDAiLCJsZW4kMCIsImxlbiQxIiwib2ZzJDEiLCJyZWFsbHlfaW5wdXQiLCJyZWFsbHlfaW5wdXRfc3RyaW5nIiwiaW5wdXRfbGluZSIsImJ1aWxkX3Jlc3VsdCIsImJ1ZiIsImFjY3UiLCJiZWciLCJhY2N1JDAiLCJyZXMiLCJjbG9zZV9pbl9ub2VyciIsInByaW50X2NoYXIiLCJwcmludF9zdHJpbmciLCJwcmludF9ieXRlcyIsInByaW50X2ludCIsInByaW50X2Zsb2F0IiwicHJpbnRfZW5kbGluZSIsInByaW50X25ld2xpbmUiLCJwcmVycl9jaGFyIiwicHJlcnJfc3RyaW5nIiwicHJlcnJfYnl0ZXMiLCJwcmVycl9pbnQiLCJwcmVycl9mbG9hdCIsInByZXJyX2VuZGxpbmUiLCJwcmVycl9uZXdsaW5lIiwicmVhZF9saW5lIiwicmVhZF9pbnQiLCJyZWFkX2ludF9vcHQiLCJyZWFkX2Zsb2F0IiwicmVhZF9mbG9hdF9vcHQiLCJzdHJpbmdfb2ZfZm9ybWF0Iiwic3ltYm9sJDAiLCJzdHIyIiwic3RyMSIsImV4aXRfZnVuY3Rpb24iLCJhdF9leGl0IiwiZl95ZXRfdG9fcnVuIiwib2xkX2V4aXQiLCJuZXdfZXhpdCQwIiwibmV3X2V4aXQiLCJzdWNjZXNzIiwiZG9fYXRfZXhpdCIsImV4aXQiLCJyZXRjb2RlIiwic2V0X2JpbmFyeV9tb2RlX2luIiwiY2xvc2VfaW4iLCJpbl9jaGFubmVsX2xlbmd0aCIsInBvc19pbiIsInNlZWtfaW4iLCJpbnB1dF92YWx1ZSIsImlucHV0X2JpbmFyeV9pbnQiLCJpbnB1dF9ieXRlIiwiaW5wdXRfY2hhciIsInNldF9iaW5hcnlfbW9kZV9vdXQiLCJvdXRfY2hhbm5lbF9sZW5ndGgiLCJwb3Nfb3V0Iiwic2Vla19vdXQiLCJvdXRwdXRfYmluYXJ5X2ludCIsIm91dHB1dF9ieXRlIiwib3V0cHV0X2NoYXIiLCJmbHVzaCIsImVtcHR5IiwicmV0dXJuJDAiLCJjb25zIiwibmV4dCIsImFwcGVuZCQwIiwic2VxMSIsInNlcTIiLCJtYXAiLCJzZXEiLCJmaWx0ZXJfbWFwIiwic2VxJDAiLCJmaWx0ZXIiLCJmbGF0X21hcCQwIiwiZmxhdF9tYXBfYXBwJDAiLCJ0YWlsIiwiZmxhdF9tYXBfYXBwIiwiZmxhdF9tYXAiLCJmb2xkX2xlZnQiLCJhY2MiLCJhY2MkMCIsImFjYyQxIiwidW5mb2xkIiwidSIsInUkMCIsIm5vbmUiLCJzb21lIiwidmFsdWUiLCJvIiwiZGVmYXVsdCQwIiwiZ2V0JDAiLCJiaW5kIiwiam9pbiIsIm1hcCQwIiwiZm9sZCIsIml0ZXIkMCIsImlzX25vbmUiLCJpc19zb21lIiwiZXF1YWwiLCJlcSIsIm8wIiwibzEiLCJ2MSIsInYwIiwiY29tcGFyZSIsImNtcCIsInRvX3Jlc3VsdCIsInRvX2xpc3QiLCJ0b19zZXEiLCJsZWZ0IiwicmlnaHQiLCJpc19sZWZ0IiwiaXNfcmlnaHQiLCJmaW5kX2xlZnQiLCJmaW5kX3JpZ2h0IiwibWFwX2xlZnQiLCJlIiwibWFwX3JpZ2h0IiwibWFwJDEiLCJ2JDAiLCJmb2xkJDAiLCJlcXVhbCQwIiwiZTEiLCJtYXRjaCIsInYyIiwidjIkMCIsImNvbXBhcmUkMCIsIm9rIiwiZXJyb3IiLCJ2YWx1ZSQwIiwiZ2V0X29rIiwiZ2V0X2Vycm9yIiwiYmluZCQwIiwiam9pbiQwIiwibWFwJDIiLCJtYXBfZXJyb3IiLCJmb2xkJDEiLCJpdGVyJDEiLCJpdGVyX2Vycm9yIiwiaXNfb2siLCJpc19lcnJvciIsImVxdWFsJDEiLCJyMCIsImNvbXBhcmUkMSIsInRvX29wdGlvbiIsInRvX2xpc3QkMCIsInRvX3NlcSQwIiwiZXF1YWwkMiIsImNvbXBhcmUkMiIsInRvX2Zsb2F0IiwidG9fc3RyaW5nJDAiLCJlc2NhcGVkIiwicyQwIiwibG93ZXJjYXNlIiwidXBwZXJjYXNlIiwibG93ZXJjYXNlX2FzY2lpIiwidXBwZXJjYXNlX2FzY2lpIiwiY29tcGFyZSQzIiwiYzEiLCJjMiIsImVxdWFsJDMiLCJtaW4kMCIsIm1heCQwIiwibG9fYm91bmQiLCJoaV9ib3VuZCIsImJvbSIsInJlcCIsInN1Y2MiLCJwcmVkIiwiaXNfdmFsaWQiLCJvZl9pbnQiLCJpc19jaGFyIiwib2ZfY2hhciIsInRvX2NoYXIiLCJ1bnNhZmVfdG9fY2hhciIsImVxdWFsJDQiLCJjb21wYXJlJDQiLCJoYXNoIiwibWF0Y2gkMSIsImxlbmd0aCIsInBhcmFtJDAiLCJjb25zJDAiLCJudGgiLCJsJDAiLCJuJDAiLCJsJDEiLCJuJDEiLCJudGhfb3B0IiwicmV2X2FwcGVuZCIsImwxJDAiLCJsMiQwIiwibDEkMSIsImwyJDEiLCJyZXYiLCJpbml0X2F1eCIsInJldl9pbml0X3RocmVzaG9sZCIsInBhcmFtIiwiYWNjdSQxIiwiYTIiLCJhMSIsInAiLCJwYWlyIiwicmVzdWx0IiwieHMiLCJ4JDAiLCJyeSIsInJ4IiwidDIiLCJoMiIsInQxIiwiaDEiLCJyZXZfc29ydCIsIngyIiwieDEiLCJ0bCQxIiwieDMiLCJ4MiQwIiwieDEkMCIsIm4xIiwibjIiLCJzb3J0IiwidGwkMCIsImMkMCIsImMkMSIsImMkMiIsImMkMyIsImMkNCIsImMkNSIsImMkNiIsImFjY3UkMiIsImF1eCIsImRpcmVjdCIsImRlcHRoIiwic3ltYm9sJDEiLCJkc3RvZmYiLCJzcmNvZmYiLCJjcHlsZW4iLCJvZnMxIiwib2ZzMiIsInNlcCIsInNlcGxlbiIsImRzdCIsImlzX3NwYWNlIiwiaiIsImFwcGx5MSIsImluZGV4X3JlYyIsImxpbSIsImkkMSIsImluZGV4X3JlY19vcHQiLCJyaW5kZXhfcmVjIiwicmluZGV4X3JlY19vcHQiLCJuZXdfbGVuIiwibmV3X2J1ZiIsImlzX3NwYWNlJDAiLCJpbmRleF9yZWMkMCIsImluZGV4X3JlY19vcHQkMCIsInJpbmRleF9yZWMkMCIsInJpbmRleF9yZWNfb3B0JDAiLCJnIiwiZXF1YWwkOCIsImNvbXBhcmUkOCIsInRvX3N0cmluZyQyIiwidG9fYnVmZmVyIiwiYnVmZiIsImZsYWdzIiwiaGVhZGVyX3NpemUiLCJkYXRhX3NpemUiLCJ0b3RhbF9zaXplIiwiZnJvbV9ieXRlcyIsImZyb21fc3RyaW5nIiwiaXNfYmxvY2siLCJkb3VibGVfZmllbGQiLCJzZXRfZG91YmxlX2ZpZWxkIiwibWFyc2hhbCIsIm9iaiIsInVubWFyc2hhbCIsInBvcyIsImZpcnN0X25vbl9jb25zdGFudF9jb25zdHJ1Y3RvciIsImxhc3Rfbm9uX2NvbnN0YW50X2NvbnN0cnVjdG9yXyIsImxhenlfdGFnIiwiY2xvc3VyZV90YWciLCJvYmplY3RfdGFnIiwiaW5maXhfdGFnIiwiZm9yd2FyZF90YWciLCJub19zY2FuX3RhZyIsImFic3RyYWN0X3RhZyIsInN0cmluZ190YWciLCJkb3VibGVfdGFnIiwiZG91YmxlX2FycmF5X3RhZyIsImN1c3RvbV90YWciLCJpbnRfdGFnIiwib3V0X29mX2hlYXBfdGFnIiwidW5hbGlnbmVkX3RhZyIsImluZm8iLCJzdGFydF9lbnYiLCJvZl92YWwiLCJzbG90IiwiaWQiLCJleHRlbnNpb25fY29uc3RydWN0b3IiLCJleHRlbnNpb25fbmFtZSIsImV4dGVuc2lvbl9pZCIsIm1heF9lcGhlX2xlbmd0aCIsImNyZWF0ZSIsImxlbmd0aCQwIiwicmFpc2VfaWZfaW52YWxpZF9vZmZzZXQiLCJtc2ciLCJnZXRfa2V5IiwiZ2V0X2tleV9jb3B5Iiwic2V0X2tleSIsInVuc2V0X2tleSIsImNoZWNrX2tleSIsImJsaXRfa2V5IiwiZTIiLCJvMiIsInN4Iiwic3kiLCJpbml0IiwibGEiLCJsYiIsInJlcyQwIiwibGlzdF9sZW5ndGgiLCJwYXJhbSQxIiwiaGQkMCIsIm1heHNvbiIsImkzMSIsInRyaWNrbGVkb3duIiwidHJpY2tsZSIsImJ1YmJsZWRvd24iLCJidWJibGUiLCJpJDIiLCJlJDAiLCJmYXRoZXIiLCJtZXJnZSIsInNyYzFvZnMiLCJzcmMxbGVuIiwic3JjMiIsInNyYzJvZnMiLCJzcmMybGVuIiwiZHN0b2ZzIiwic3JjMXIiLCJzcmMyciIsInMyJDEiLCJzMSQxIiwiaTEiLCJpMiIsImQiLCJpMiQwIiwiZCQwIiwiczIkMCIsImkxJDAiLCJkJDEiLCJzMSQwIiwiaXNvcnR0byIsInNyY29mcyIsInNvcnR0byIsInQiLCJ6ZXJvIiwib25lIiwibWludXNfb25lIiwiaXNfZmluaXRlIiwiaXNfaW5maW5pdGUiLCJpc19uYW4iLCJwaSIsImlzX2ludGVnZXIiLCJzdWNjJDAiLCJwcmVkJDAiLCJlcXVhbCQ5IiwibWluJDEiLCJtYXgkMSIsIm1pbl9tYXgiLCJtaW5fbnVtIiwibWF4X251bSIsIm1pbl9tYXhfbnVtIiwiaGFzaCQwIiwidW5zYWZlX2ZpbGwiLCJjaGVjayIsIm1ha2UkMiIsImluaXQkMyIsImFwcGVuZCQyIiwiY29uY2F0JDIiLCJobGVuIiwic3ViJDIiLCJjb3B5JDIiLCJmaWxsJDEiLCJibGl0JDIiLCJzcmMiLCJzb2ZzIiwiZG9mcyIsInRvX2xpc3QkMiIsIm9mX2xpc3QkMCIsImgiLCJpdGVyJDYiLCJpdGVyMiQxIiwibWFwJDciLCJtYXAyJDEiLCJpdGVyaSQzIiwibWFwaSQzIiwiZm9sZF9sZWZ0JDIiLCJmb2xkX3JpZ2h0JDEiLCJleGlzdHMkMSIsImZvcl9hbGwkMSIsIm1lbSQxIiwibWVtX2llZWUiLCJzb3J0JDAiLCJzdGFibGVfc29ydCIsInRvX3NlcSQ1IiwidG9fc2VxaSQyIiwib2Zfc2VxJDMiLCJtYXBfdG9fYXJyYXkiLCJtYXBfZnJvbV9hcnJheSIsInplcm8kMCIsIm9uZSQwIiwibWludXNfb25lJDAiLCJhYnMkMCIsIm1heF9pbnQkMCIsIm1pbl9pbnQkMCIsImxvZ25vdCIsImVxdWFsJDEwIiwiY29tcGFyZSQ5IiwidG9fc3RyaW5nJDMiLCJ6ZXJvJDEiLCJvbmUkMSIsIm1pbnVzX29uZSQxIiwic3VjYyQxIiwicHJlZCQxIiwiYWJzJDEiLCJtaW5faW50JDEiLCJtYXhfaW50JDEiLCJsb2dub3QkMCIsInVuc2lnbmVkX3RvX2ludCIsInRvX3N0cmluZyQ0Iiwib2Zfc3RyaW5nX29wdCQwIiwiY29tcGFyZSQxMCIsImVxdWFsJDExIiwidW5zaWduZWRfY29tcGFyZSIsIm0iLCJ1bnNpZ25lZF9kaXYiLCJxIiwidW5zaWduZWRfcmVtIiwic3VjYyQyIiwicHJlZCQyIiwiYWJzJDIiLCJsb2dub3QkMSIsIm1heF9pbnQkMyIsInVuc2lnbmVkX3RvX2ludCQwIiwidG9fc3RyaW5nJDUiLCJvZl9zdHJpbmdfb3B0JDEiLCJjb21wYXJlJDExIiwiZXF1YWwkMTIiLCJ1bnNpZ25lZF9jb21wYXJlJDAiLCJ1bnNpZ25lZF9kaXYkMCIsInVuc2lnbmVkX3JlbSQwIiwiemVybyQzIiwib25lJDMiLCJtaW51c19vbmUkMyIsInN1Y2MkMyIsInByZWQkMyIsImFicyQzIiwibWluX2ludCQzIiwibWF4X2ludCQ0IiwibG9nbm90JDIiLCJ1bnNpZ25lZF90b19pbnQkMSIsInRvX3N0cmluZyQ2Iiwib2Zfc3RyaW5nX29wdCQyIiwiY29tcGFyZSQxMiIsImVxdWFsJDEzIiwidW5zaWduZWRfY29tcGFyZSQxIiwidW5zaWduZWRfZGl2JDEiLCJ1bnNpZ25lZF9yZW0kMSIsImVuZ2luZSIsInRibCIsInN0YXRlIiwibmV3X2VuZ2luZSIsImZyb21fZnVuY3Rpb24iLCJvcHQiLCJzdGgiLCJ3aXRoX3Bvc2l0aW9ucyIsImF1eF9idWZmZXIiLCJsZXhidWYiLCJyZWFkIiwibmV3bGVuIiwibmV3YnVmIiwiZnJvbV9jaGFubmVsIiwiZnJvbV9zdHJpbmckMCIsInNldF9wb3NpdGlvbiIsInBvc2l0aW9uIiwic2V0X2ZpbGVuYW1lIiwiZm5hbWUiLCJsZXhlbWUiLCJzdWJfbGV4ZW1lIiwic3ViX2xleGVtZV9vcHQiLCJzdWJfbGV4ZW1lX2NoYXIiLCJzdWJfbGV4ZW1lX2NoYXJfb3B0IiwibGV4ZW1lX2NoYXIiLCJsZXhlbWVfc3RhcnQiLCJsZXhlbWVfZW5kIiwibGV4ZW1lX3N0YXJ0X3AiLCJsZXhlbWVfZW5kX3AiLCJuZXdfbGluZSIsImxjcCIsImZsdXNoX2lucHV0IiwiZW52IiwiZ3Jvd19zdGFja3MiLCJvbGRzaXplIiwibmV3c2l6ZSIsIm5ld19zIiwibmV3X3YiLCJuZXdfc3RhcnQiLCJuZXdfZW5kIiwiY2xlYXJfcGFyc2VyIiwiY3VycmVudF9sb29rYWhlYWRfZnVuIiwieXlwYXJzZSIsInRhYmxlcyIsInN0YXJ0IiwibGV4ZXIiLCJpbml0X2FzcCIsImluaXRfc3AiLCJpbml0X3N0YWNrYmFzZSIsImluaXRfc3RhdGUiLCJpbml0X2N1cnJfY2hhciIsImluaXRfbHZhbCIsImluaXRfZXJyZmxhZyIsImNtZCIsImFyZyIsImFyZyQwIiwiYXJnJDEiLCJjbWQkMCIsImV4biIsImN1cnJfY2hhciIsInRvayIsInBlZWtfdmFsIiwic3ltYm9sX3N0YXJ0X3BvcyIsInN0IiwiZW4iLCJzeW1ib2xfZW5kX3BvcyIsInJoc19zdGFydF9wb3MiLCJyaHNfZW5kX3BvcyIsInN5bWJvbF9zdGFydCIsInN5bWJvbF9lbmQiLCJyaHNfc3RhcnQiLCJyaHNfZW5kIiwiaXNfY3VycmVudF9sb29rYWhlYWQiLCJwYXJzZV9lcnJvciIsImhlaWdodCIsImhsIiwiaCQwIiwiaHIiLCJiYWwiLCJsciIsImx2IiwibGwiLCJscnIiLCJscnYiLCJscmwiLCJyciIsInJ2IiwicmwiLCJybHIiLCJybHYiLCJybGwiLCJhZGQiLCJzaW5nbGV0b24iLCJhZGRfbWluX2VsZW1lbnQiLCJhZGRfbWF4X2VsZW1lbnQiLCJyaCIsImxoIiwibWluX2VsdCIsIm1pbl9lbHRfb3B0IiwibWF4X2VsdCIsIm1heF9lbHRfb3B0IiwicmVtb3ZlX21pbl9lbHQiLCJyJDAiLCJjb25jYXQiLCJzcGxpdCIsInByZXMiLCJwcmVzJDAiLCJpc19lbXB0eSIsIm1lbSIsInJlbW92ZSIsInVuaW9uIiwicjIiLCJyMSIsInIyJDAiLCJyMSQwIiwiaW50ZXIiLCJzcGxpdF9iaXMiLCJkaXNqb2ludCIsImRpZmYiLCJjb25zX2VudW0iLCJzJDEiLCJlJDEiLCJlMiQyIiwiZTEkMiIsImUyJDAiLCJlMSQwIiwiZTIkMSIsImUxJDEiLCJzdWJzZXQiLCJmb3JfYWxsIiwiZXhpc3RzIiwicHYiLCJwYXJ0aXRpb24iLCJsZiIsImx0IiwicmYiLCJydCIsImNhcmRpbmFsIiwiZWxlbWVudHNfYXV4IiwiZWxlbWVudHMiLCJmaW5kIiwiZmluZF9maXJzdCIsImZpbmRfZmlyc3Rfb3B0IiwiZmluZF9sYXN0IiwiZmluZF9sYXN0X29wdCIsImZpbmRfb3B0IiwidHJ5X2pvaW4iLCJ0JDAiLCJ2JDEiLCJvZl9saXN0Iiwic3ViIiwibCQzIiwieDAiLCJsJDQiLCJ4MCQwIiwibCQ1IiwieDAkMSIsIm5sIiwibWlkIiwibCQyIiwieDQiLCJhZGRfc2VxIiwib2Zfc2VxIiwic2VxX29mX2VudW0iLCJzbm9jX2VudW0iLCJyZXZfc2VxX29mX2VudW0iLCJ0b19yZXZfc2VxIiwidG9fc2VxX2Zyb20iLCJsb3ciLCJsZCIsImxyZCIsInJkIiwicmxkIiwiZGF0YSIsIm1pbl9iaW5kaW5nIiwibWluX2JpbmRpbmdfb3B0IiwibWF4X2JpbmRpbmciLCJtYXhfYmluZGluZ19vcHQiLCJyZW1vdmVfbWluX2JpbmRpbmciLCJ1cGRhdGUiLCJkYXRhJDAiLCJtYXBpIiwibSQwIiwiYWRkX21pbl9iaW5kaW5nIiwiayIsImFkZF9tYXhfYmluZGluZyIsImNvbmNhdF9vcl9qb2luIiwiZDEiLCJkMiIsImQyJDAiLCJkMSQwIiwiZDIkMSIsImQxJDEiLCJwdmQiLCJmdmQiLCJtJDEiLCJtMSIsIm0yIiwiYmluZGluZ3NfYXV4IiwiYmluZGluZ3MiLCJjcmVhdGUkMCIsImNsZWFyIiwiY29weSQzIiwicHVzaCIsInBvcCIsInBvcF9vcHQiLCJ0b3AiLCJ0b3Bfb3B0IiwibGVuZ3RoJDEiLCJpdGVyJDciLCJmb2xkJDIiLCJ0b19zZXEkNiIsIm9mX3NlcSQ0IiwiY3JlYXRlJDEiLCJjbGVhciQwIiwiY2VsbCIsInBlZWsiLCJjb250ZW50IiwicGVla19vcHQiLCJ0YWtlIiwidGFrZV9vcHQiLCJjb3B5JDQiLCJxX3JlcyIsInByZXYiLCJpc19lbXB0eSQwIiwibGVuZ3RoJDIiLCJpdGVyJDgiLCJmb2xkJDMiLCJ0cmFuc2ZlciIsInExIiwicTIiLCJ0b19zZXEkNyIsImFkZF9zZXEkMCIsIm9mX3NlcSQ1IiwicmFpc2VfdW5kZWZpbmVkIiwiZm9yY2VfbGF6eV9ibG9jayIsImJsayIsImNsb3N1cmUiLCJmb3JjZV92YWxfbGF6eV9ibG9jayIsImZvcmNlIiwibHp2IiwiZm9yY2VfdmFsIiwiZnJvbV9mdW4iLCJmcm9tX3ZhbCIsImlzX3ZhbCIsImNvdW50IiwiZmlsbF9idWZmIiwiZ2V0X2RhdGEiLCJkMTEiLCJhJDAiLCJhJDEiLCJwZWVrX2RhdGEiLCJwZWVrJDAiLCJqdW5rX2RhdGEiLCJqdW5rIiwibmdldF9kYXRhIiwiYWwiLCJucGVlayIsImVtcHR5JDEiLCJpdGVyJDkiLCJzdHJtIiwiZnJvbSIsIm9mX2xpc3QkMSIsIm9mX3N0cmluZyQwIiwib2ZfYnl0ZXMiLCJvZl9jaGFubmVsIiwiaWFwcCIsImljb25zIiwiaXNpbmciLCJsYXBwIiwibGNvbnMiLCJsc2luZyIsInNlbXB0eSIsInNsYXp5IiwiZHVtcF9kYXRhIiwiZHVtcCIsImNyZWF0ZSQyIiwiY29udGVudHMiLCJ0b19ieXRlcyIsInN1YiQzIiwiYmxpdCQzIiwibnRoJDAiLCJsZW5ndGgkMyIsImNsZWFyJDEiLCJyZXNldCIsInJlc2l6ZSIsIm1vcmUiLCJvbGRfcG9zIiwib2xkX2xlbiIsIm5ld19idWZmZXIiLCJhZGRfY2hhciIsImFkZF91dGZfOF91Y2hhciIsInBvcyQwIiwicG9zJDEiLCJhZGRfdXRmXzE2YmVfdWNoYXIiLCJoaSIsImxvIiwiYWRkX3V0Zl8xNmxlX3VjaGFyIiwiYWRkX3N1YnN0cmluZyIsIm9mZnNldCIsIm5ld19wb3NpdGlvbiIsImFkZF9zdWJieXRlcyIsImFkZF9zdHJpbmciLCJhZGRfYnl0ZXMiLCJhZGRfYnVmZmVyIiwiYnMiLCJhZGRfY2hhbm5lbCIsImFscmVhZHlfcmVhZCIsInRvX3JlYWQiLCJhbHJlYWR5X3JlYWQkMCIsInRvX3JlYWQkMCIsIm91dHB1dF9idWZmZXIiLCJhZGRfc3Vic3RpdHV0ZSIsImxpbSQxIiwicHJldmlvdXMiLCJpJDciLCJjdXJyZW50IiwiaSQ4Iiwib3BlbmluZyIsImkkNiIsImxpbSQwIiwiaSQzIiwic3RvcCIsImkkNCIsImkkNSIsImskMiIsImskMCIsImskMSIsIm5leHRfaSIsImlkZW50IiwiaSQ5IiwiaSQxMCIsImkkMTEiLCJ0cnVuY2F0ZSIsInRvX3NlcSQ4IiwidG9fc2VxaSQzIiwiYWRkX3NlcSQxIiwib2Zfc2VxJDYiLCJhZGRfaW50OCIsImFkZF9pbnQxNl9uZSIsImFkZF9pbnQzMl9uZSIsImFkZF9pbnQ2NF9uZSIsImFkZF9pbnQxNl9sZSIsImFkZF9pbnQxNl9iZSIsImFkZF9pbnQzMl9sZSIsImFkZF9pbnQzMl9iZSIsImFkZF9pbnQ2NF9sZSIsImFkZF9pbnQ2NF9iZSIsImNyZWF0ZV9jaGFyX3NldCIsImFkZF9pbl9jaGFyX3NldCIsInN0cl9pbmQiLCJtYXNrIiwiZnJlZXplX2NoYXJfc2V0IiwicmV2X2NoYXJfc2V0IiwiY2hhcl9zZXQkMCIsImlzX2luX2NoYXJfc2V0IiwicGFkX29mX3BhZF9vcHQiLCJwYWRfb3B0Iiwid2lkdGgiLCJwYXJhbV9mb3JtYXRfb2ZfaWdub3JlZF9mb3JtYXQiLCJmbXQiLCJwYWRfb3B0JDAiLCJwYWRfb3B0JDEiLCJwYWRfb3B0JDIiLCJwYWRfb3B0JDMiLCJwYWRfb3B0JDQiLCJwcmVjX29wdCIsInBhZF9vcHQkNSIsIm5kZWMiLCJwYWRfb3B0JDYiLCJwYWRfb3B0JDciLCJwYWRfb3B0JDgiLCJkZWZhdWx0X2Zsb2F0X3ByZWNpc2lvbiIsImJ1ZmZlcl9jcmVhdGUiLCJpbml0X3NpemUiLCJidWZmZXJfY2hlY2tfc2l6ZSIsIm92ZXJoZWFkIiwibWluX2xlbiIsIm5ld19zdHIiLCJidWZmZXJfYWRkX2NoYXIiLCJidWZmZXJfYWRkX3N0cmluZyIsInN0cl9sZW4iLCJidWZmZXJfY29udGVudHMiLCJjaGFyX29mX2ljb252IiwiY2hhcl9vZl9mY29udiIsImNGIiwiYnByaW50X3BhZHR5IiwicGFkdHkiLCJicHJpbnRfaWdub3JlZF9mbGFnIiwiaWduX2ZsYWciLCJicHJpbnRfcGFkX29wdCIsImJwcmludF9wYWRkaW5nIiwicGFkdHkkMCIsImJwcmludF9wcmVjaXNpb24iLCJicHJpbnRfaWNvbnZfZmxhZyIsImJwcmludF9hbHRpbnRfZm10IiwiYnByaW50X2Zjb252X2ZsYWciLCJzdHJpbmdfb2ZfZm9ybWF0dGluZ19saXQiLCJzdHIkMCIsImJwcmludF9jaGFyX2xpdGVyYWwiLCJicHJpbnRfc3RyaW5nX2xpdGVyYWwiLCJicHJpbnRfZm10dHkiLCJzdWJfZm10dHkiLCJzdWJfZm10dHkkMCIsImludF9vZl9jdXN0b21fYXJpdHkiLCJzdHJpbmdfb2ZfZm10IiwiZm10JDEiLCJjaHIkMCIsInN0ciQxIiwiaXNfYWxvbmUkMCIsImlzX2Fsb25lIiwiYWZ0ZXIiLCJiZWZvcmUiLCJqJDAiLCJqJDEiLCJmbXQkMCIsInN5bW0iLCJ0cmFucyIsInJlc3QyIiwicmVzdDIkMCIsInJlc3QyJDEiLCJyZXN0MiQyIiwicmVzdDIkMyIsInJlc3QyJDQiLCJyZXN0MiQ1IiwicmVzdDIkNiIsInJlc3QyJDciLCJyZXN0MiQ4IiwidHkyMiIsInR5MjEiLCJmbXR0eV9yZWxfZGV0IiwiZjQiLCJmMiIsInJlc3QyJDkiLCJyZXN0MiQxMCIsInJlc3QyJDExIiwicmVzdDIkMTIiLCJyZXN0MiQxMyIsImRlIiwiZWQiLCJhZiIsImZhIiwiZGUkMCIsImVkJDAiLCJhZiQwIiwiZmEkMCIsImRlJDEiLCJlZCQxIiwiYWYkMSIsImZhJDEiLCJkZSQyIiwiZWQkMiIsImFmJDIiLCJmYSQyIiwiZGUkMyIsImVkJDMiLCJhZiQzIiwiZmEkMyIsImRlJDQiLCJlZCQ0IiwiYWYkNCIsImZhJDQiLCJkZSQ1IiwiZWQkNSIsImFmJDUiLCJmYSQ1IiwiZGUkNiIsImVkJDYiLCJhZiQ2IiwiZmEkNiIsImRlJDciLCJlZCQ3IiwiYWYkNyIsImZhJDciLCJkZSQ4IiwiZWQkOCIsImFmJDgiLCJmYSQ4IiwiamQiLCJkaiIsImdhIiwiYWciLCJkZSQ5IiwiZWQkOSIsImFmJDkiLCJmYSQ5IiwiZGUkMTAiLCJlZCQxMCIsImFmJDEwIiwiZmEkMTAiLCJkZSQxMSIsImVkJDExIiwiYWYkMTEiLCJmYSQxMSIsImRlJDEyIiwiZWQkMTIiLCJhZiQxMiIsImZhJDEyIiwiZGUkMTMiLCJlZCQxMyIsImFmJDEzIiwiZmEkMTMiLCJmbXR0eV9vZl9wcmVjaXNpb25fZm10dHkiLCJmbXR0eV9vZl9wYWRkaW5nX2ZtdHR5IiwiZm10dHlfb2ZfY3VzdG9tIiwiYXJpdHkkMCIsImZtdHR5X29mX2ZtdCIsInR5X3Jlc3QiLCJwcmVjX3R5IiwidHlfcmVzdCQwIiwicHJlY190eSQwIiwidHlfcmVzdCQxIiwicHJlY190eSQxIiwidHlfcmVzdCQyIiwicHJlY190eSQyIiwidHlfcmVzdCQzIiwicHJlY190eSQzIiwiZm10dHkkMSIsImZtdHR5JDIiLCJmbXR0eSQzIiwidHkkMCIsImZtdHR5JDQiLCJmbXR0eSQ1IiwidHlwZV9wYWRkaW5nIiwidyIsInR5cGVfcGFkcHJlYyIsInR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aSIsInR5cGVfZm9ybWF0X2dlbiIsImZtdHR5X3Jlc3QiLCJzdWJfZm10dHlfcmVzdCIsInN1Yl9mbXR0eV9yZXN0JDAiLCJmbXR0eV9yZXN0JDAiLCJzdWJfZm10dHlfcmVzdCQxIiwic3ViX2ZtdHR5X3Jlc3QkMiIsImZtdHR5X3Jlc3QkMSIsInN1Yl9mbXR0eV9yZXN0JDMiLCJmbXQkMiIsInN1Yl9mbXR0eV9yZXN0JDQiLCJmbXR0eV9yZXN0JDIiLCJzdWJfZm10dHlfcmVzdCQ1IiwiZm10JDMiLCJzdWJfZm10dHlfcmVzdCQ2IiwiZm10dHlfcmVzdCQzIiwic3ViX2ZtdHR5X3Jlc3QkNyIsImZtdCQ0Iiwic3ViX2ZtdHR5X3Jlc3QkOCIsImZtdHR5X3Jlc3QkNCIsInN1Yl9mbXR0eV9yZXN0JDkiLCJmbXQkNSIsInN1Yl9mbXR0eV9yZXN0JDEwIiwiZm10dHlfcmVzdCQ1Iiwic3ViX2ZtdHR5X3Jlc3QkMTEiLCJmbXQkNiIsInN1Yl9mbXR0eV9yZXN0JDEyIiwiZm10dHlfcmVzdCQ2Iiwic3ViX2ZtdHR5X3Jlc3QkMTMiLCJmbXQkNyIsInN1Yl9mbXR0eV9yZXN0JDE0IiwiZm10dHlfcmVzdCQ3Iiwic3ViMl9mbXR0eSIsInN1Yl9mbXR0eV9yZXN0JDE1Iiwic3ViMl9mbXR0eSQwIiwiZm10JDgiLCJzdWJfZm10dHlfcmVzdCQxNiIsImZtdHR5X3Jlc3QkOCIsInN1YjJfZm10dHkkMSIsInN1YjFfZm10dHkiLCJzdWJfZm10dHlfcmVzdCQxNyIsInN1YjJfZm10dHkkMiIsInN1YjFfZm10dHkkMCIsImZtdCQ5Iiwic3ViX2ZtdHR5X3Jlc3QkMTgiLCJmbXR0eV9yZXN0JDkiLCJzdWJfZm10dHlfcmVzdCQxOSIsImZtdCQxMCIsInN1Yl9mbXR0eV9yZXN0JDIwIiwiZm10dHlfcmVzdCQxMCIsInN1Yl9mbXR0eV9yZXN0JDIxIiwiZm10JDExIiwic3ViX2ZtdHR5X3Jlc3QkMjIiLCJmbXR0eV9yZXN0JDExIiwic3ViX2ZtdHR5X3Jlc3QkMjMiLCJmbXQkMTIiLCJzdWJfZm10dHlfcmVzdCQyNCIsImZtdHR5X3Jlc3QkMTIiLCJzdWJfZm10dHlfcmVzdCQyNSIsImZtdCQxMyIsInN1Yl9mbXR0eV9yZXN0JDI2IiwiZm10X3Jlc3QiLCJmbXRfcmVzdCQwIiwiZm10X3Jlc3QkMSIsImZtdF9yZXN0JDIiLCJmbXRfcmVzdCQzIiwiZm10X3Jlc3QkNCIsImZtdF9yZXN0JDUiLCJwcmVjJDQiLCJmbXR0eSQ2IiwiZm10X3Jlc3QkNiIsInByZWMkNSIsInByZWMkNiIsImZtdHR5JDciLCJmbXRfcmVzdCQ3IiwicHJlYyQ3IiwicHJlYyQ4IiwiZm10dHkkOCIsImZtdF9yZXN0JDgiLCJmbXR0eSQ5IiwiZm10X3Jlc3QkOSIsImZtdHR5JDEwIiwiZm10X3Jlc3QkMTAiLCJmbXR0eSQxMSIsImZtdF9yZXN0JDExIiwiZm10dHkkMTIiLCJmbXRfcmVzdCQxMiIsImZtdHR5JDEzIiwic3ViX2ZtdHR5MSIsImZtdF9yZXN0JDEzIiwic3ViX2ZtdHR5JDEiLCJmbXR0eSQxNCIsImZtdCQxNCIsImZtdF9yZXN0JDE0IiwiZm10dHkkMTUiLCJmbXQkMTUiLCJmbXRfcmVzdCQxNSIsImZtdHR5JDE2IiwiZm10JDE2IiwiZm10X3Jlc3QkMTYiLCJmbXR0eSQxNyIsImZtdCQxNyIsImZtdF9yZXN0JDE3IiwiZm9ybWF0dGluZ19nZW4iLCJmbXR0eTMiLCJmbXQzIiwiZm10MSQwIiwiZm10dHkyJDAiLCJmbXQyJDAiLCJmbXR0eTMkMCIsImZtdDMkMCIsImZtdHR5X3Jlc3QkMTMiLCJmbXRfcmVzdCQxOCIsImZtdHR5JDE4IiwiZm10JDE4IiwiZm10dHlfcmVzdCQxNCIsImZtdF9yZXN0JDE5IiwiZm10dHkkMTkiLCJmbXQkMTkiLCJmbXR0eV9yZXN0JDE1IiwiZm10X3Jlc3QkMjAiLCJmbXR0eSQyMCIsImZtdCQyMCIsInR5cGVfaWdub3JlZF9wYXJhbV9vbmUiLCJmbXR0eV9yZXN0JDE2IiwiZm10dHkkMjEiLCJmbXQkMjEiLCJzdWJfZm10dHkkMiIsInN1Yl9mbXR0eSQzIiwiZm10dHkkMjIiLCJmbXQkMjIiLCJzdWJfZm10dHkkNCIsInR5cGVfZm9ybWF0IiwicmVjYXN0IiwiZml4X3BhZGRpbmciLCJ3aWR0aCQwIiwiZml4X2ludF9wcmVjaXNpb24iLCJyZXMkMSIsInN0cmluZ190b19jYW1sX3N0cmluZyIsImZvcm1hdF9vZl9mY29udiIsInN5bWIiLCJ0cmFuc2Zvcm1faW50X2FsdCIsImRpZ2l0cyIsInB1dCIsImNvbnZlcnRfaW50IiwiY29udmVydF9pbnQzMiIsImNvbnZlcnRfbmF0aXZlaW50IiwiY29udmVydF9pbnQ2NCIsImNvbnZlcnRfZmxvYXQiLCJoZXgiLCJzaWduIiwiY2FtbF9zcGVjaWFsX3ZhbCIsInN0cmluZ19vZl9mbXR0eSIsIm1ha2VfcHJpbnRmJDAiLCJuZXdfYWNjIiwibWFrZV9wcmludGYiLCJtYWtlX3BhZGRpbmciLCJtYWtlX2ludF9wYWRkaW5nX3ByZWNpc2lvbiIsInAkMCIsInAkMSIsImFjYyQyIiwiYWNjJDMiLCJhY2MkNCIsImskMyIsImthY2MiLCJrJDQiLCJtYWtlX2lnbm9yZWRfcGFyYW0kMCIsIm1ha2VfY3VzdG9tJDAiLCJtYWtlX2ludmFsaWRfYXJnIiwibWFrZV9mcm9tX2ZtdHR5JDAiLCJtYWtlX2Zyb21fZm10dHkiLCJtYWtlX2N1c3RvbSIsIm1ha2VfaWdub3JlZF9wYXJhbSIsIm1ha2VfaXByaW50ZiQwIiwibWFrZV9pcHJpbnRmIiwiZm5fb2ZfcGFkZGluZ19wcmVjaXNpb24iLCJrb2MiLCJyZXN0JDI0IiwicmVzdCQyNSIsImZuX29mX2N1c3RvbV9hcml0eSQwIiwiZm5fb2ZfY3VzdG9tX2FyaXR5Iiwib3V0cHV0X2FjYyIsInAkMiIsInAkMyIsInAkNCIsImJ1ZnB1dF9hY2MiLCJzdHJwdXRfYWNjIiwiZmFpbHdpdGhfbWVzc2FnZSIsIm9wZW5fYm94X29mX3N0cmluZyIsImludmFsaWRfYm94IiwicGFyc2Vfc3BhY2VzIiwicGFyc2VfbHdvcmQiLCJwYXJzZV9pbnQiLCJ3c3RhcnQiLCJ3ZW5kIiwiYm94X25hbWUiLCJuc3RhcnQiLCJuZW5kIiwiaW5kZW50IiwiZXhwX2VuZCIsImJveF90eXBlIiwibWFrZV9wYWRkaW5nX2ZtdF9lYmIiLCJtYWtlX3BhZHByZWNfZm10X2ViYiIsImZtdF9lYmJfb2Zfc3RyaW5nIiwibGVnYWN5X2JlaGF2aW9yIiwiZmxhZyIsImxlZ2FjeV9iZWhhdmlvciQwIiwiaW52YWxpZF9mb3JtYXRfbWVzc2FnZSIsInVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCIsImVuZF9pbmQiLCJpbnZhbGlkX2Zvcm1hdF93aXRob3V0IiwiZXhwZWN0ZWRfY2hhcmFjdGVyIiwiZXhwZWN0ZWQiLCJhZGRfbGl0ZXJhbCIsImxpdF9zdGFydCIsInNpemUiLCJwYXJzZV9wb3NpdGl2ZSIsInN0cl9pbmQkMCIsInN0cl9pbmQkMSIsInBhcnNlX2ludGVnZXIiLCJuZXh0X2luZCIsImluY29tcGF0aWJsZV9mbGFnIiwicGN0X2luZCIsIm9wdGlvbiIsInN1YmZtdCIsImNvbXB1dGVfaW50X2NvbnYiLCJwbHVzIiwic3BhY2UiLCJwbHVzJDAiLCJzcGFjZSQwIiwic2VhcmNoX3N1YmZvcm1hdF9lbmQiLCJzdWJfZW5kIiwic3RyX2luZCQyIiwic3ViX2VuZCQwIiwic3RyX2luZCQzIiwic3ViX2VuZCQxIiwic3RyX2luZCQ0Iiwic3RyX2luZCQ1Iiwic3ViX2VuZCQyIiwic3RyX2luZCQ2Iiwic3RyX2luZCQ3IiwicGFyc2VfbWFnaWNfc2l6ZSIsInN0cl9pbmRfMSIsInN0cl9pbmRfMiIsInN0cl9pbmRfMyIsInBhcnNlIiwicGFyc2VfZ29vZF9icmVhayIsImZvcm1hdHRpbmdfbGl0JDAiLCJzdHJfaW5kXzQiLCJzdHJfaW5kXzUiLCJwYXJzZV90YWciLCJpc19vcGVuX3RhZyIsImluZCIsInN1Yl9zdHIiLCJzdWJfZm10Iiwic3ViX2Zvcm1hdCQwIiwiZm9ybWF0dGluZyQwIiwiZm9ybWF0dGluZyIsInBhcnNlX2ZsYWdzIiwibWludXMiLCJzZXRfZmxhZyIsIm5ld19pbmQiLCJwYXJzZV9hZnRlcl9wYWRkaW5nIiwicGFyc2VfbGl0ZXJhbCIsInBhcnNlX2FmdGVyX3ByZWNpc2lvbiIsInN5bWIkMCIsIm1pbnVzJDAiLCJwYXJzZV9jb252ZXJzaW9uIiwicGFyc2VfY29udiIsInBhZHByZWMiLCJwbHVzX3VzZWQiLCJoYXNoX3VzZWQiLCJzcGFjZV91c2VkIiwiaWduX3VzZWQiLCJwYWRfdXNlZCIsInByZWNfdXNlZCIsImdldF9wbHVzIiwiZ2V0X2hhc2giLCJnZXRfc3BhY2UiLCJnZXRfaWduIiwiZ2V0X3BhZCIsImdldF9wcmVjIiwiZ2V0X3BhZHByZWMiLCJnZXRfaW50X3BhZCIsImNoZWNrX25vXzAiLCJvcHRfb2ZfcGFkIiwid2lkdGgkMSIsImdldF9wYWRfb3B0IiwiZ2V0X3BhZHByZWNfb3B0IiwiZm10X3Jlc3VsdCIsImlnbm9yZWQkMiIsImNvdW50ZXIkMCIsImlnbm9yZWQkNiIsImlnbm9yZWQkNyIsImFkZF9yYW5nZSIsImZhaWxfc2luZ2xlX3BlcmNlbnQiLCJwYXJzZV9jaGFyX3NldF9jb250ZW50IiwicGFyc2VfY2hhcl9zZXRfYWZ0ZXJfY2hhciQwIiwicGFyc2VfY2hhcl9zZXRfYWZ0ZXJfY2hhciIsInJldmVyc2UiLCJjaGFyX3NldCQxIiwiaWdub3JlZCQ5IiwiY2hhcl9mb3JtYXQiLCJmbXRfcmVzdCQyMSIsImZtdF9yZXN0JDIyIiwicGFkJDkiLCJmbXRfcmVzdCQyMyIsImlnbm9yZWQkMTAiLCJmbXRfcmVzdCQyNCIsInBhZCQxMCIsImZtdF9yZXN0JDI1Iiwic3ViX2ZtdCQwIiwiZm10X3Jlc3QkMjYiLCJpZ25vcmVkJDExIiwiaWdub3JlZCQzIiwiaWdub3JlZCQ1IiwiaWdub3JlZCQ4Iiwic3BhY2UkMSIsImhhc2gkMSIsInBsdXMkMiIsImtpbmQiLCJpZ25vcmVkJDQiLCJpZ25vcmVkIiwiaWdub3JlZCQwIiwiaWdub3JlZCQxIiwicGx1cyQxIiwiaWduJDAiLCJmb3JtYXRfb2Zfc3RyaW5nX2ZtdHR5IiwiZm9ybWF0X29mX3N0cmluZ19mb3JtYXQiLCJrZnByaW50ZiIsImticHJpbnRmIiwiaWtmcHJpbnRmIiwiZnByaW50ZiIsImJwcmludGYiLCJpZnByaW50ZiIsImlicHJpbnRmIiwicHJpbnRmIiwiZXByaW50ZiIsImtzcHJpbnRmIiwic3ByaW50ZiIsImFzc29jMyIsInkyIiwieTEiLCJzcGxpdCQwIiwibWFrZV9zeW1saXN0IiwicHJlZml4Iiwic3VmZml4IiwiaGVscF9hY3Rpb24iLCJhZGRfaGVscCIsInNwZWNsaXN0IiwiYWRkMiIsInVzYWdlX2IiLCJlcnJtc2ciLCJkb2MiLCJzcGVjIiwia2V5IiwidXNhZ2Vfc3RyaW5nIiwidXNhZ2UiLCJib29sX29mX3N0cmluZ19vcHQkMCIsImludF9vZl9zdHJpbmdfb3B0JDAiLCJmbG9hdF9vZl9zdHJpbmdfb3B0IiwicGFyc2VfYW5kX2V4cGFuZF9hcmd2X2R5bmFtaWNfIiwiYWxsb3dfZXhwYW5kIiwiYXJndiIsImFub25mdW4iLCJpbml0cG9zIiwiY29udmVydF9lcnJvciIsInByb2duYW1lIiwiZm9sbG93JDAiLCJhY3Rpb24iLCJrZXl3b3JkIiwibm9fYXJnJDAiLCJmb2xsb3ciLCJub19hcmciLCJnZXRfYXJnJDAiLCJnZXRfYXJnIiwiY29uc3VtZV9hcmckMCIsImNvbnN1bWVfYXJnIiwidHJlYXRfYWN0aW9uJDAiLCJ0cmVhdF9hY3Rpb24iLCJmJDAiLCJmJDEiLCJyJDEiLCJmJDIiLCJyJDIiLCJhcmckMiIsImYkMyIsImFyZyQzIiwieCQxIiwiciQzIiwiYXJnJDQiLCJ4JDIiLCJzcGVjcyIsImYkNCIsImFyZyQ1IiwiZiQ1IiwiZiQ2IiwiZiQ3IiwiYXJnJDYiLCJuZXdhcmciLCJwYXJzZV9hbmRfZXhwYW5kX2FyZ3ZfZHluYW1pYyIsInBhcnNlX2FyZ3ZfZHluYW1pYyIsImN1cnJlbnQkMCIsInBhcnNlX2FyZ3YiLCJtc2ckMCIsIm1zZyQxIiwicGFyc2VfZHluYW1pYyIsInBhcnNlX2V4cGFuZCIsInNlY29uZF93b3JkIiwibG9vcCIsIm1heF9hcmdfbGVuIiwia3dkIiwicmVwbGFjZV9sZWFkaW5nX3RhYiIsImFsaWduIiwibGltaXQiLCJjb21wbGV0ZWQiLCJrc2QiLCJjdXRjb2wkMCIsInNwYWNlcyQwIiwiY3V0Y29sIiwia3dkX2xlbiIsInNwYWNlcyIsInJlYWRfYXV4IiwidHJpbSIsImZpbGUiLCJ3b3JkcyIsInN0YXNoIiwid29yZCIsInJlYWRfYXJnIiwicmVhZF9hcmcwIiwid3JpdGVfYXV4IiwiYXJncyIsIndyaXRlX2FyZyIsIndyaXRlX2FyZzAiLCJwcmludGVycyIsImZpZWxkIiwib3RoZXJfZmllbGRzIiwidXNlX3ByaW50ZXJzIiwiY29udiIsInRvX3N0cmluZ19kZWZhdWx0IiwiY2hhciQwIiwibGluZSIsImNoYXIkMSIsImxpbmUkMCIsImZpbGUkMCIsImNoYXIkMiIsImxpbmUkMSIsImZpbGUkMSIsImNvbnN0cnVjdG9yIiwidG9fc3RyaW5nJDciLCJwcmludCIsImZjdCIsImNhdGNoJDAiLCJyYXdfYmFja3RyYWNlX2VudHJpZXMiLCJidCIsImNvbnZlcnRfcmF3X2JhY2t0cmFjZSIsImZvcm1hdF9iYWNrdHJhY2Vfc2xvdCIsImlzX3JhaXNlIiwicHJpbnRfcmF3X2JhY2t0cmFjZSIsIm91dGNoYW4iLCJyYXdfYmFja3RyYWNlIiwiYmFja3RyYWNlIiwicHJpbnRfYmFja3RyYWNlIiwicmF3X2JhY2t0cmFjZV90b19zdHJpbmciLCJiYWNrdHJhY2Vfc2xvdF9pc19yYWlzZSIsImJhY2t0cmFjZV9zbG90X2lzX2lubGluZSIsImJhY2t0cmFjZV9zbG90X2xvY2F0aW9uIiwiYmFja3RyYWNlX3Nsb3RfZGVmbmFtZSIsImJhY2t0cmFjZV9zbG90cyIsImJhY2t0cmFjZV9zbG90c19vZl9yYXdfZW50cnkiLCJlbnRyeSIsInJhd19iYWNrdHJhY2VfbGVuZ3RoIiwiZ2V0X2JhY2t0cmFjZSIsInJlZ2lzdGVyX3ByaW50ZXIiLCJmbiIsIm9sZF9wcmludGVycyIsIm5ld19wcmludGVycyIsImV4bl9zbG90IiwiZXhuX3Nsb3RfaWQiLCJleG5fc2xvdF9uYW1lIiwiZXJyb3JzIiwiZGVmYXVsdF91bmNhdWdodF9leGNlcHRpb25faGFuIiwic3RhdHVzIiwidW5jYXVnaHRfZXhjZXB0aW9uX2hhbmRsZXIiLCJzZXRfdW5jYXVnaHRfZXhjZXB0aW9uX2hhbmRsZXIiLCJjb25zdCQwIiwiZmxpcCIsIm5lZ2F0ZSIsInByb3RlY3QiLCJmaW5hbGx5JDAiLCJ3b3JrIiwiZmluYWxseV9ub19leG4iLCJ3b3JrX2V4biIsIndvcmtfYnQiLCJwcmludF9zdGF0IiwiYWxsb2NhdGVkX2J5dGVzIiwibWEiLCJwcm8iLCJtaSIsImNyZWF0ZV9hbGFybSIsImRlbGV0ZV9hbGFybSIsIm51bGxfdHJhY2tlciIsInNhbXBsaW5nX3JhdGUiLCJ0cmFja2VyIiwiY2FsbHN0YWNrX3NpemUiLCJzdHJpbmciLCJieXRlcyIsInN1YnN0cmluZyIsInN1YmJ5dGVzIiwiZmlsZW5hbWUiLCJvdXRwdXQkMCIsImRpZ2VzdCIsImlucHV0JDAiLCJjaGFyX2hleCIsInRvX2hleCIsImZyb21faGV4IiwiZGlnaXQiLCJuZXdfc3RhdGUiLCJhc3NpZ24iLCJzdDEiLCJzdDIiLCJmdWxsX2luaXQiLCJzZWVkIiwic2VlZCQwIiwibWFrZSQzIiwibWFrZV9zZWxmX2luaXQiLCJjb3B5JDUiLCJiaXRzIiwiY3VydmFsIiwibmV3dmFsIiwibmV3dmFsMzAiLCJpbnQkMCIsImJvdW5kIiwiaW50MzIiLCJiMSIsImIyIiwiaW50NjQiLCJiMyIsIm5hdGl2ZWludCIsImZsb2F0JDAiLCJib29sIiwiYml0cyQwIiwiaW50JDEiLCJpbnQzMiQwIiwibmF0aXZlaW50JDAiLCJpbnQ2NCQwIiwiZmxvYXQkMSIsInNjYWxlIiwiYm9vbCQwIiwiZnVsbF9pbml0JDAiLCJpbml0JDQiLCJzZWxmX2luaXQiLCJnZXRfc3RhdGUiLCJzZXRfc3RhdGUiLCJvbmdvaW5nX3RyYXZlcnNhbCIsImZsaXBfb25nb2luZ190cmF2ZXJzYWwiLCJwYXJhbXMiLCJyYW5kb21pemVkX2RlZmF1bHQiLCJyYW5kb21pemVkIiwicmFuZG9taXplIiwiaXNfcmFuZG9taXplZCIsInBybmciLCJwb3dlcl8yX2Fib3ZlIiwiY3JlYXRlJDMiLCJpbml0aWFsX3NpemUiLCJyYW5kb20iLCJjbGVhciQyIiwicmVzZXQkMCIsImNvcHlfYnVja2V0bGlzdCIsImtleSQwIiwibmV4dCQwIiwiY29weSQ2IiwibGVuZ3RoJDQiLCJpbnNlcnRfYWxsX2J1Y2tldHMiLCJpbmRleGZ1biIsImlucGxhY2UiLCJvZGF0YSIsIm5kYXRhIiwibnNpemUiLCJuZGF0YV90YWlsIiwiY2VsbCQwIiwibmlkeCIsIm1hdGNoJDAiLCJyZXNpemUkMCIsIm9zaXplIiwiaXRlciQxMCIsImRvX2J1Y2tldCIsIm9sZF90cmF2IiwiZmlsdGVyX21hcF9pbnBsYWNlX2J1Y2tldCIsImZpbHRlcl9tYXBfaW5wbGFjZSIsImZvbGQkNCIsImIkMCIsImJ1Y2tldF9sZW5ndGgiLCJzdGF0cyIsIm1ibCIsImhpc3RvIiwidG9fc2VxJDkiLCJ0YmxfZGF0YSIsImJ1Y2siLCJidWNrJDAiLCJidWNrJDEiLCJ0b19zZXFfa2V5cyIsInRvX3NlcV92YWx1ZXMiLCJrZXlfaW5kZXgiLCJidWNrZXQiLCJrMSIsIm5leHQxIiwiazIiLCJuZXh0MiIsImszIiwiZDMiLCJuZXh0MyIsImZpbmRfYWxsIiwiZmluZF9pbl9idWNrZXQiLCJyZXBsYWNlIiwicmVwbGFjZV9zZXEiLCJjb3B5Iiwic3oiLCJoYXNoX3BhcmFtIiwic2VlZGVkX2hhc2giLCJhZGQkMCIsImZpbmQkMCIsImZpbmRfb3B0JDAiLCJmaW5kX2FsbCQwIiwibWVtJDIiLCJhZGRfc2VxJDIiLCJvZl9zZXEkNyIsInJlYnVpbGQiLCJ3ZWFrX2NyZWF0ZSIsImxlbmd0aCQ1IiwicmFpc2VfaWZfaW52YWxpZF9vZmZzZXQkMCIsInNldCQwIiwiZ2V0JDEiLCJnZXRfY29weSIsImNoZWNrJDAiLCJibGl0JDQiLCJmaWxsJDIiLCJhciIsImVtcHR5YnVja2V0IiwiZ2V0X2luZGV4Iiwic3okMCIsInN6JDEiLCJjb3VudF9idWNrZXQiLCJhZGRfYXV4Iiwic2V0dGVyIiwiaW5kZXgiLCJidWNrZXQkMCIsImhhc2hlcyIsIm5ld3N6IiwibmV3YnVja2V0JDAiLCJuZXdoYXNoZXMiLCJoYnVja2V0IiwicHJldl9sZW4iLCJsaXZlIiwiaiQyIiwibmV3YnVja2V0IiwibmV3dCIsIm9iIiwib2giLCJzZXR0ZXIkMCIsIm5iIiwibmkiLCJmaW5kX29yIiwiaWZub3Rmb3VuZCIsImZpbmRfc2hhZG93IiwiaWZmb3VuZCIsImxlbnMiLCJ0b3RsZW4iLCJpZCQwIiwidW5rbm93biIsInBwX2VucXVldWUiLCJ0b2tlbiIsInBwX2luZmluaXR5IiwicHBfb3V0cHV0X3N0cmluZyIsInBwX291dHB1dF9uZXdsaW5lIiwiZm9ybWF0X3BwX3RleHQiLCJ0ZXh0IiwiZm9ybWF0X3N0cmluZyIsImJyZWFrX25ld19saW5lIiwicmVhbF9pbmRlbnQiLCJicmVha19saW5lIiwiYnJlYWtfc2FtZV9saW5lIiwiYWR2YW5jZV9sZWZ0Iiwic2l6ZSQwIiwicGVuZGluZ19jb3VudCIsInNpemUkMSIsInRhYnMiLCJhZGRfdGFiIiwibHMiLCJ0YWdfbmFtZSIsIm1hcmtlciIsImJyZWFrcyIsImZpdHMiLCJvZmYiLCJib3hfdHlwZSQwIiwib2ZmJDAiLCJpbnNlcnRpb25fcG9pbnQiLCJ0YWJzJDAiLCJmaXJzdCIsImhlYWQiLCJ0YWIiLCJvZmYkMSIsImluc2VydGlvbl9wb2ludCQwIiwid2lkdGgkMiIsImJveF90eXBlJDEiLCJ0Ym94IiwidGFnX25hbWUkMCIsIm1hcmtlciQwIiwiZW5xdWV1ZV9hZHZhbmNlIiwiZW5xdWV1ZV9zdHJpbmdfYXMiLCJpbml0aWFsaXplX3NjYW5fc3RhY2siLCJzdGFjayIsInF1ZXVlX2VsZW0iLCJzZXRfc2l6ZSIsImxlZnRfdG90YWwiLCJzY2FuX3B1c2giLCJlbGVtIiwicHBfb3Blbl9ib3hfZ2VuIiwiYnJfdHkiLCJwcF9jbG9zZV9ib3giLCJwcF9vcGVuX3N0YWciLCJwcF9jbG9zZV9zdGFnIiwicHBfb3Blbl90YWciLCJwcF9jbG9zZV90YWciLCJwcF9zZXRfcHJpbnRfdGFncyIsInBwX3NldF9tYXJrX3RhZ3MiLCJwcF9nZXRfcHJpbnRfdGFncyIsInBwX2dldF9tYXJrX3RhZ3MiLCJwcF9zZXRfdGFncyIsInBwX2dldF9mb3JtYXR0ZXJfc3RhZ19mdW5jdGlvbiIsInBwX3NldF9mb3JtYXR0ZXJfc3RhZ19mdW5jdGlvbiIsInBjdCIsInBvdCIsIm1jdCIsIm1vdCIsInBwX3Jpbml0IiwicHBfZmx1c2hfcXVldWUiLCJwcF9wcmludF9hc19zaXplIiwicHBfcHJpbnRfYXMiLCJpc2l6ZSIsInBwX3ByaW50X3N0cmluZyIsInBwX3ByaW50X2ludCIsInBwX3ByaW50X2Zsb2F0IiwicHBfcHJpbnRfYm9vbCIsInBwX3ByaW50X2NoYXIiLCJwcF9vcGVuX2hib3giLCJwcF9vcGVuX3Zib3giLCJwcF9vcGVuX2h2Ym94IiwicHBfb3Blbl9ob3Zib3giLCJwcF9vcGVuX2JveCIsInBwX3ByaW50X25ld2xpbmUiLCJwcF9wcmludF9mbHVzaCIsInBwX2ZvcmNlX25ld2xpbmUiLCJwcF9wcmludF9pZl9uZXdsaW5lIiwicHBfcHJpbnRfY3VzdG9tX2JyZWFrIiwicHBfcHJpbnRfYnJlYWsiLCJwcF9wcmludF9zcGFjZSIsInBwX3ByaW50X2N1dCIsInBwX29wZW5fdGJveCIsInBwX2Nsb3NlX3Rib3giLCJwcF9wcmludF90YnJlYWsiLCJwcF9wcmludF90YWIiLCJwcF9zZXRfdGFiIiwicHBfc2V0X21heF9ib3hlcyIsInBwX2dldF9tYXhfYm94ZXMiLCJwcF9vdmVyX21heF9ib3hlcyIsInBwX3NldF9lbGxpcHNpc190ZXh0IiwicHBfZ2V0X2VsbGlwc2lzX3RleHQiLCJwcF9saW1pdCIsInBwX3NldF9tYXhfaW5kZW50IiwicHBfZ2V0X21heF9pbmRlbnQiLCJwcF9zZXRfbWFyZ2luIiwibmV3X21heF9pbmRlbnQiLCJ2YWxpZGF0ZV9nZW9tZXRyeSIsIm1hcmdpbiIsIm1heF9pbmRlbnQiLCJjaGVja19nZW9tZXRyeSIsImdlb21ldHJ5IiwicHBfZ2V0X21hcmdpbiIsInBwX3NldF9mdWxsX2dlb21ldHJ5IiwicHBfc2V0X2dlb21ldHJ5IiwicHBfc2FmZV9zZXRfZ2VvbWV0cnkiLCJwcF9nZXRfZ2VvbWV0cnkiLCJwcF91cGRhdGVfZ2VvbWV0cnkiLCJwcF9zZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMiLCJwcF9nZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMiLCJwcF9zZXRfZm9ybWF0dGVyX291dHB1dF9mdW5jdGkiLCJwcF9nZXRfZm9ybWF0dGVyX291dHB1dF9mdW5jdGkiLCJkaXNwbGF5X25ld2xpbmUiLCJibGFua19saW5lIiwiZGlzcGxheV9pbmRlbnQiLCJwcF9zZXRfZm9ybWF0dGVyX291dF9jaGFubmVsIiwiZGVmYXVsdF9wcF9tYXJrX29wZW5fdGFnIiwiZGVmYXVsdF9wcF9tYXJrX2Nsb3NlX3RhZyIsImRlZmF1bHRfcHBfcHJpbnRfb3Blbl90YWciLCJkZWZhdWx0X3BwX3ByaW50X2Nsb3NlX3RhZyIsInBwX21ha2VfZm9ybWF0dGVyIiwicHBfcXVldWUiLCJzeXNfdG9rIiwic2Nhbl9zdGFjayIsImZvcm1hdHRlcl9vZl9vdXRfZnVuY3Rpb25zIiwib3V0X2Z1bnMiLCJtYWtlX2Zvcm1hdHRlciIsInBwZiIsImZvcm1hdHRlcl9vZl9vdXRfY2hhbm5lbCIsImZvcm1hdHRlcl9vZl9idWZmZXIiLCJwcF9idWZmZXJfc2l6ZSIsInBwX21ha2VfYnVmZmVyIiwic3RkYnVmIiwic3RkX2Zvcm1hdHRlciIsImVycl9mb3JtYXR0ZXIiLCJzdHJfZm9ybWF0dGVyIiwiZmx1c2hfYnVmZmVyX2Zvcm1hdHRlciIsImZsdXNoX3N0cl9mb3JtYXR0ZXIiLCJtYWtlX3N5bWJvbGljX291dHB1dF9idWZmZXIiLCJjbGVhcl9zeW1ib2xpY19vdXRwdXRfYnVmZmVyIiwic29iIiwiZ2V0X3N5bWJvbGljX291dHB1dF9idWZmZXIiLCJmbHVzaF9zeW1ib2xpY19vdXRwdXRfYnVmZmVyIiwiaXRlbXMiLCJhZGRfc3ltYm9saWNfb3V0cHV0X2l0ZW0iLCJpdGVtIiwiZm9ybWF0dGVyX29mX3N5bWJvbGljX291dHB1dF9iIiwib3Blbl9oYm94Iiwib3Blbl92Ym94Iiwib3Blbl9odmJveCIsIm9wZW5faG92Ym94Iiwib3Blbl9ib3giLCJjbG9zZV9ib3giLCJvcGVuX3RhZyIsImNsb3NlX3RhZyIsIm9wZW5fc3RhZyIsImNsb3NlX3N0YWciLCJwcmludF9hcyIsInByaW50X3N0cmluZyQwIiwicHJpbnRfaW50JDAiLCJwcmludF9mbG9hdCQwIiwicHJpbnRfY2hhciQwIiwicHJpbnRfYm9vbCIsInByaW50X2JyZWFrIiwicHJpbnRfY3V0IiwicHJpbnRfc3BhY2UiLCJmb3JjZV9uZXdsaW5lIiwicHJpbnRfZmx1c2giLCJwcmludF9uZXdsaW5lJDAiLCJwcmludF9pZl9uZXdsaW5lIiwib3Blbl90Ym94IiwiY2xvc2VfdGJveCIsInByaW50X3RicmVhayIsInNldF90YWIiLCJwcmludF90YWIiLCJzZXRfbWFyZ2luIiwiZ2V0X21hcmdpbiIsInNldF9tYXhfaW5kZW50IiwiZ2V0X21heF9pbmRlbnQiLCJzZXRfZ2VvbWV0cnkiLCJzYWZlX3NldF9nZW9tZXRyeSIsImdldF9nZW9tZXRyeSIsInVwZGF0ZV9nZW9tZXRyeSIsInNldF9tYXhfYm94ZXMiLCJnZXRfbWF4X2JveGVzIiwib3Zlcl9tYXhfYm94ZXMiLCJzZXRfZWxsaXBzaXNfdGV4dCIsImdldF9lbGxpcHNpc190ZXh0Iiwic2V0X2Zvcm1hdHRlcl9vdXRfY2hhbm5lbCIsInNldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyIsImdldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyIsInNldF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyIsImdldF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyIsInNldF9mb3JtYXR0ZXJfc3RhZ19mdW5jdGlvbnMiLCJnZXRfZm9ybWF0dGVyX3N0YWdfZnVuY3Rpb25zIiwic2V0X3ByaW50X3RhZ3MiLCJnZXRfcHJpbnRfdGFncyIsInNldF9tYXJrX3RhZ3MiLCJnZXRfbWFya190YWdzIiwic2V0X3RhZ3MiLCJwcF9wcmludF9saXN0IiwicHBfdiIsIm9wdCQwIiwicHBfc2VwIiwidnMiLCJvcHQkMSIsInBwX3ByaW50X3NlcSIsInNlcSQxIiwic2VxJDIiLCJwcF9wcmludF90ZXh0IiwicHBfcHJpbnRfb3B0aW9uIiwicHBfcHJpbnRfcmVzdWx0IiwiY29tcHV0ZV90YWciLCJ0YWdfYWNjIiwib3V0cHV0X2Zvcm1hdHRpbmdfbGl0Iiwib3V0cHV0X2FjYyQwIiwiYnR5IiwicCQ1IiwicCQ2Iiwic3RycHV0X2FjYyQwIiwia2ZwcmludGYkMCIsImlrZnByaW50ZiQwIiwiaWZwcmludGYkMCIsImZwcmludGYkMCIsInByaW50ZiQwIiwiZXByaW50ZiQwIiwia2RwcmludGYiLCJkcHJpbnRmIiwia3ByaW50ZiIsInNwcmludGYkMCIsImthc3ByaW50ZiIsImFzcHJpbnRmIiwiZmx1c2hfc3RhbmRhcmRfZm9ybWF0dGVycyIsInBwX3NldF9hbGxfZm9ybWF0dGVyX291dHB1dF9mdSIsInBwX2dldF9hbGxfZm9ybWF0dGVyX291dHB1dF9mdSIsInNldF9hbGxfZm9ybWF0dGVyX291dHB1dF9mdW5jdCIsImdldF9hbGxfZm9ybWF0dGVyX291dHB1dF9mdW5jdCIsImJwcmludGYkMCIsInBwX3NldF9mb3JtYXR0ZXJfdGFnX2Z1bmN0aW9ucyIsInN0cmluZ2lmeSIsInBwX2dldF9mb3JtYXR0ZXJfdGFnX2Z1bmN0aW9ucyIsImZ1bnMiLCJtYXJrX29wZW5fdGFnIiwibWFya19jbG9zZV90YWciLCJwcmludF9vcGVuX3RhZyIsInByaW50X2Nsb3NlX3RhZyIsInNldF9mb3JtYXR0ZXJfdGFnX2Z1bmN0aW9ucyIsImdldF9mb3JtYXR0ZXJfdGFnX2Z1bmN0aW9ucyIsIm51bGxfY2hhciIsIm5leHRfY2hhciIsImliIiwicGVla19jaGFyIiwiY2hlY2tlZF9wZWVrX2NoYXIiLCJlbmRfb2ZfaW5wdXQiLCJiZWdpbm5pbmdfb2ZfaW5wdXQiLCJuYW1lX29mX2lucHV0IiwiY2hhcl9jb3VudCIsInJlc2V0X3Rva2VuIiwiaW52YWxpZGF0ZV9jdXJyZW50X2NoYXIiLCJ0b2tlbl9zdHJpbmciLCJ0b2tlbl9idWZmZXIiLCJza2lwX2NoYXIiLCJpZ25vcmVfY2hhciIsInN0b3JlX2NoYXIiLCJkZWZhdWx0X3Rva2VuX2J1ZmZlcl9zaXplIiwiY3JlYXRlJDQiLCJpbmFtZSIsImZyb21fc3RyaW5nJDEiLCJmcm9tX2Z1bmN0aW9uJDAiLCJzY2FuX2Nsb3NlX2F0X2VuZCIsInNjYW5fcmFpc2VfYXRfZW5kIiwiZnJvbV9pYyIsInNjYW5fY2xvc2VfaWMiLCJlb2YiLCJzdGRpYiIsIm9wZW5faW5fZmlsZSIsImZyb21fZmlsZSIsImZyb21fZmlsZV9iaW4iLCJmcm9tX2NoYW5uZWwkMCIsImNsb3NlX2luJDAiLCJpYyQwIiwibWVtbyIsIm1lbW9fZnJvbV9pYyIsIm1lbW9fZnJvbV9jaGFubmVsIiwiYmFkX2lucHV0IiwiYmFkX2lucHV0X2VzY2FwZSIsImJhZF90b2tlbl9sZW5ndGgiLCJtZXNzYWdlIiwiYmFkX2Zsb2F0IiwiYmFkX2hleF9mbG9hdCIsImNoYXJhY3Rlcl9taXNtYXRjaCIsImNpIiwiY2hlY2tfdGhpc19jaGFyIiwiY2hlY2tfY2hhciIsInRva2VuX2NoYXIiLCJ0b2tlbl9ib29sIiwiaW50ZWdlcl9jb252ZXJzaW9uX29mX2NoYXIiLCJ0b2tlbl9pbnRfbGl0ZXJhbCIsInRva2VuX2Zsb2F0Iiwic2Nhbl9kZWNpbWFsX2RpZ2l0X3N0YXIiLCJzY2FuX3Vuc2lnbmVkX2RlY2ltYWxfaW50Iiwic2Nhbl9kaWdpdF9wbHVzIiwiYmFzaXMiLCJkaWdpdHAiLCJ3aWR0aCQzIiwiaXNfYmluYXJ5X2RpZ2l0Iiwic2Nhbl9iaW5hcnlfaW50IiwiaXNfb2N0YWxfZGlnaXQiLCJzY2FuX29jdGFsX2ludCIsImlzX2hleGFfZGlnaXQiLCJzY2FuX2hleGFkZWNpbWFsX2ludCIsInNjYW5fc2lnbiIsInNjYW5fb3B0aW9uYWxseV9zaWduZWRfZGVjaW1hbCIsInNjYW5faW50X2NvbnZlcnNpb24iLCJzY2FuX2ZyYWN0aW9uYWxfcGFydCIsInNjYW5fZXhwb25lbnRfcGFydCIsInNjYW5fZmxvYXQiLCJwcmVjaXNpb24iLCJwcmVjaXNpb24kMCIsImNoZWNrX2Nhc2VfaW5zZW5zaXRpdmVfc3RyaW5nIiwic2Nhbl9oZXhfZmxvYXQiLCJ3aWR0aCQ0Iiwid2lkdGgkNSIsIndpZHRoJDYiLCJ3aWR0aCQxMCIsIndpZHRoJDciLCJ3aWR0aCQ4Iiwid2lkdGgkOSIsInNjYW5fY2FtbF9mbG9hdF9yZXN0Iiwid2lkdGhfcHJlY2lzaW9uIiwiZnJhY193aWR0aCIsInNjYW5fY2FtbF9mbG9hdCIsInNjYW5fc3RyaW5nIiwic3RwIiwic2Nhbl9jaGFyIiwiaGV4YWRlY2ltYWxfdmFsdWVfb2ZfY2hhciIsImNoZWNrX25leHRfY2hhciIsImNoZWNrX25leHRfY2hhcl9mb3JfY2hhciIsImNoZWNrX25leHRfY2hhcl9mb3Jfc3RyaW5nIiwic2Nhbl9iYWNrc2xhc2hfY2hhciIsImMwIiwiZ2V0X2RpZ2l0IiwiZ2V0X2RpZ2l0JDAiLCJjMSQwIiwiYzIkMCIsInNjYW5fY2FtbF9jaGFyIiwiZmluZF9zdG9wIiwic2Nhbl9jYW1sX3N0cmluZyIsImZpbmRfc3RvcCQwIiwic2tpcF9zcGFjZXMiLCJzY2FuX2NoYXJzX2luX2NoYXJfc2V0Iiwic2Nhbl9pbmRpYyIsInNjYW5fY2hhcnMiLCJzY2FuZl9iYWRfaW5wdXQiLCJnZXRfY291bnRlciIsIndpZHRoX29mX3BhZF9vcHQiLCJzdG9wcGVyX29mX2Zvcm1hdHRpbmdfbGl0IiwiZm10aW5nIiwidGFrZV9mb3JtYXRfcmVhZGVycyQwIiwidGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyQwIiwicmVhZGVyIiwibmV3X2siLCJyZWFkZXJzX3Jlc3QiLCJ0YWtlX2Zvcm1hdF9yZWFkZXJzIiwiZm10JDIzIiwiZm10JDI0IiwiZm10JDI1IiwidGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyIsIm1ha2Vfc2NhbmYiLCJyZWFkZXJzIiwic2NhbiQwIiwic3RyX3Jlc3QiLCJwYWRfcHJlY19zY2FuZiIsInNjYW4kMSIsInNjYW4kMiIsInNjYW4iLCJzY2FuJDMiLCJzY2FuJDQiLCJjb252JDAiLCJzY2FuJDUiLCJjb252JDEiLCJzY2FuJDYiLCJjb252JDIiLCJzY2FuJDciLCJzY2FuJDgiLCJmbXRpbmdfbGl0JDAiLCJzdHAkMCIsInMkMiIsInN0cl9yZXN0JDAiLCJyZXN0JDI2IiwiYXJnX3Jlc3QiLCJrc2NhbmYiLCJlZiIsImFwcGx5IiwiYXJncyQwIiwiZXhjIiwiYnNjYW5mIiwia3NzY2FuZiIsInNzY2FuZiIsInNjYW5mIiwiYnNjYW5mX2Zvcm1hdCIsImZvcm1hdCIsInNzY2FuZl9mb3JtYXQiLCJmb3JtYXRfZnJvbV9zdHJpbmciLCJ1bmVzY2FwZWQiLCJrZnNjYW5mIiwiZnNjYW5mIiwicmVnaXN0ZXIiLCJyZWdpc3Rlcl9leGNlcHRpb24iLCJvJDAiLCJwYXJhbXMkMCIsImluaXRpYWxfb2JqZWN0X3NpemUiLCJkdW1teV9pdGVtIiwidGFnIiwiY29tcGFyZSQxMyIsImNvbXBhcmUkMTQiLCJjb21wYXJlJDE1IiwiZHVtbXlfdGFibGUiLCJ0YWJsZV9jb3VudCIsImR1bW15X21ldCIsImZpdF9zaXplIiwibmV3X3RhYmxlIiwicHViX2xhYmVscyIsIm1ldGhvZHMiLCJyZXNpemUkMSIsImFycmF5IiwibmV3X3NpemUiLCJvbGRfc2l6ZSIsIm5ld19idWNrIiwibWV0aG9kX2NvdW50IiwiaW5zdF92YXJfY291bnQiLCJuZXdfbWV0aG9kIiwidGFibGUiLCJnZXRfbWV0aG9kX2xhYmVsIiwibGFiZWwiLCJnZXRfbWV0aG9kX2xhYmVscyIsIm5hbWVzIiwic2V0X21ldGhvZCIsImVsZW1lbnQiLCJnZXRfbWV0aG9kIiwidG9fbGlzdCQzIiwiYXJyIiwibmFycm93IiwidmFycyIsInZpcnRfbWV0aHMiLCJjb25jcl9tZXRocyIsInZhcnMkMCIsInZpcnRfbWV0aHMkMCIsImNvbmNyX21ldGhzJDAiLCJ2aXJ0X21ldGhfbGFicyIsImNvbmNyX21ldGhfbGFicyIsImxhYiIsInR2YXJzIiwiYnlfbmFtZSIsImJ5X2xhYmVsIiwibWV0IiwiaG0iLCJ3aWRlbiIsInNhdmVkX3ZhcnMiLCJzYXZlZF9oaWRkZW5fbWV0aHMiLCJuZXdfc2xvdCIsIm5ld192YXJpYWJsZSIsInRvX2FycmF5IiwibmV3X21ldGhvZHNfdmFyaWFibGVzIiwibWV0aHMiLCJ2YWxzIiwibWV0aHMkMCIsIm5tZXRocyIsIm52YWxzIiwiZ2V0X3ZhcmlhYmxlIiwiZ2V0X3ZhcmlhYmxlcyIsImFkZF9pbml0aWFsaXplciIsImNyZWF0ZV90YWJsZSIsInB1YmxpY19tZXRob2RzIiwidGFncyIsImluaXRfY2xhc3MiLCJpbmhlcml0cyIsImNsYSIsInN1cGVyJDAiLCJubSIsIm1ha2VfY2xhc3MiLCJwdWJfbWV0aHMiLCJjbGFzc19pbml0IiwiZW52X2luaXQiLCJtYWtlX2NsYXNzX3N0b3JlIiwiaW5pdF90YWJsZSIsImR1bW15X2NsYXNzIiwibG9jIiwidW5kZWYiLCJjcmVhdGVfb2JqZWN0IiwiY3JlYXRlX29iamVjdF9vcHQiLCJvYmpfMCIsIml0ZXJfZiIsInJ1bl9pbml0aWFsaXplcnMiLCJpbml0cyIsInJ1bl9pbml0aWFsaXplcnNfb3B0IiwiY3JlYXRlX29iamVjdF9hbmRfcnVuX2luaXRpYWxpIiwiZ2V0X2RhdGEkMCIsImJ1aWxkX3BhdGgiLCJrZXlzIiwibG9va3VwX3RhYmxlcyIsInJvb3QiLCJ0YWJsZXMkMiIsInRhYmxlcyQwIiwidGFibGVzJDEiLCJuZXdfY2FjaGUiLCJzZXRfbWV0aG9kcyIsImNsbyIsImNsbyQwIiwibiQyIiwibiQzIiwibiQ0IiwibiQ1IiwibiQ2IiwieCQzIiwibiQ3IiwieCQ0IiwibiQ4IiwibiQ5IiwieCQ1IiwiZiQ4IiwiZSQyIiwibiQxMCIsIngkNiIsImYkOSIsIm4kMTEiLCJ4JDciLCJuJDEyIiwieCQ4IiwibiQxMyIsIm4kMTQiLCJlJDMiLCJuJDE1IiwibSQyIiwieCQ5IiwibSQzIiwibiQxNiIsIm0kNCIsImUkNCIsIm4kMTciLCJtJDUiLCJuJDE4Iiwic3RhdHMkMCIsImluaXRpYWxfYnVmZmVyIiwiYnVmZmVyIiwiYnVmcG9zIiwicmVzZXRfYnVmZmVyIiwic3RvcmUiLCJuZXdidWZmZXIiLCJnZXRfc3RyaW5nIiwibWFrZV9sZXhlciIsImtleXdvcmRzIiwia3dkX3RhYmxlIiwiaWRlbnRfb3Jfa2V5d29yZCIsImtleXdvcmRfb3JfZXJyb3IiLCJjb21tZW50IiwiZXNjYXBlIiwiZW5kX2V4cG9uZW50X3BhcnQiLCJleHBvbmVudF9wYXJ0IiwibnVtYmVyIiwiaWRlbnQyIiwibmVnX251bWJlciIsIm5leHRfdG9rZW4kMCIsIm1heWJlX2NvbW1lbnQiLCJuZXh0X3Rva2VuIiwiaGtleSIsImNsZWFuIiwiaW5zZXJ0X2J1Y2tldCIsImNvbnRhaW5lciIsInJlbW92ZV9idWNrZXQiLCJoayIsInJlcGxhY2VfYnVja2V0IiwibmV3X2QiLCJidWNrZXRfbGVuZ3RoX2FsaXZlIiwic3RhdHNfYWxpdmUiLCJjcmVhdGUkNSIsImdldF9rZXkkMCIsImdldF9rZXlfY29weSQwIiwic2V0X2tleSQwIiwidW5zZXRfa2V5JDAiLCJjaGVja19rZXkkMCIsImJsaXRfa2V5JDAiLCJnZXRfZGF0YSQxIiwiZ2V0X2RhdGFfY29weSIsInNldF9kYXRhIiwidW5zZXRfZGF0YSIsImNoZWNrX2RhdGEiLCJibGl0X2RhdGEiLCJzZXRfa2V5X2RhdGEiLCJjcmVhdGUkNiIsImdldF9rZXkxIiwiZ2V0X2tleTFfY29weSIsInNldF9rZXkxIiwidW5zZXRfa2V5MSIsImNoZWNrX2tleTEiLCJnZXRfa2V5MiIsImdldF9rZXkyX2NvcHkiLCJzZXRfa2V5MiIsInVuc2V0X2tleTIiLCJjaGVja19rZXkyIiwiYmxpdF9rZXkxIiwiYmxpdF9rZXkyIiwiYmxpdF9rZXkxMiIsImdldF9kYXRhJDIiLCJnZXRfZGF0YV9jb3B5JDAiLCJzZXRfZGF0YSQwIiwidW5zZXRfZGF0YSQwIiwiY2hlY2tfZGF0YSQwIiwiYmxpdF9kYXRhJDAiLCJrMiQwIiwiazEkMCIsImNyZWF0ZSQ3IiwibGVuZ3RoJDYiLCJnZXRfa2V5JDEiLCJnZXRfa2V5X2NvcHkkMSIsInNldF9rZXkkMSIsInVuc2V0X2tleSQxIiwiY2hlY2tfa2V5JDEiLCJibGl0X2tleSQxIiwiZ2V0X2RhdGEkMyIsImdldF9kYXRhX2NvcHkkMSIsInNldF9kYXRhJDEiLCJ1bnNldF9kYXRhJDEiLCJjaGVja19kYXRhJDEiLCJibGl0X2RhdGEkMSIsImtpIiwiazAiLCJnZW5lcmljX2Jhc2VuYW1lIiwiaXNfZGlyX3NlcCIsImdlbmVyaWNfZGlybmFtZSIsImlzX3JlbGF0aXZlIiwiaXNfaW1wbGljaXQiLCJjaGVja19zdWZmaXgiLCJzdWZmIiwiY2hvcF9zdWZmaXhfb3B0IiwibGVuX3MiLCJsZW5fZiIsInF1b3RlIiwicXVvdGVfY29tbWFuZCIsImJhc2VuYW1lIiwiZGlybmFtZSIsImlzX2Rpcl9zZXAkMCIsImlzX3JlbGF0aXZlJDAiLCJpc19pbXBsaWNpdCQwIiwiY2hlY2tfc3VmZml4JDAiLCJjaG9wX3N1ZmZpeF9vcHQkMCIsInRlbXBfZGlyX25hbWUiLCJxdW90ZSQwIiwiYWRkX2JzIiwibG9vcCQwIiwibG9vcF9icyIsInF1b3RlX2NtZF9maWxlbmFtZSIsInF1b3RlX2NvbW1hbmQkMCIsImRyaXZlX2FuZF9wYXRoIiwiZGlybmFtZSQwIiwicGF0aCIsImRyaXZlIiwiZGlyIiwiYmFzZW5hbWUkMCIsImJhc2VuYW1lJDEiLCJkaXJuYW1lJDEiLCJudWxsJDMiLCJjdXJyZW50X2Rpcl9uYW1lJDIiLCJwYXJlbnRfZGlyX25hbWUkMiIsImRpcl9zZXAkMiIsImlzX2Rpcl9zZXAkMSIsImlzX3JlbGF0aXZlJDEiLCJpc19pbXBsaWNpdCQxIiwiY2hlY2tfc3VmZml4JDEiLCJjaG9wX3N1ZmZpeF9vcHQkMSIsInRlbXBfZGlyX25hbWUkMCIsInF1b3RlJDEiLCJxdW90ZV9jb21tYW5kJDEiLCJiYXNlbmFtZSQyIiwiZGlybmFtZSQyIiwiY29uY2F0JDMiLCJjaG9wX3N1ZmZpeCIsImV4dGVuc2lvbl9sZW4iLCJleHRlbnNpb24iLCJjaG9wX2V4dGVuc2lvbiIsInJlbW92ZV9leHRlbnNpb24iLCJwcm5nJDAiLCJ0ZW1wX2ZpbGVfbmFtZSIsInRlbXBfZGlyIiwicm5kIiwiY3VycmVudF90ZW1wX2Rpcl9uYW1lIiwic2V0X3RlbXBfZGlyX25hbWUiLCJnZXRfdGVtcF9kaXJfbmFtZSIsInRlbXBfZmlsZSIsInRyeV9uYW1lIiwiY291bnRlciQxIiwib3Blbl90ZW1wX2ZpbGUiLCJzdGgkMCIsInBlcm1zIiwic3RoJDEiLCJhZGQkMSIsInN1YiQ0IiwibmVnIiwiY29uaiIsIm11bCIsImRpdiIsImludiIsIm5vcm0yIiwibm9ybSIsInEkMCIsInBvbGFyIiwic3FydCIsInckMCIsImV4cCIsImxvZyIsInBvdyIsImZsb2F0MzIiLCJmbG9hdDY0IiwiaW50OF9zaWduZWQiLCJpbnQ4X3Vuc2lnbmVkIiwiaW50MTZfc2lnbmVkIiwiaW50MTZfdW5zaWduZWQiLCJpbnQzMiQxIiwiaW50NjQkMSIsImludCQyIiwibmF0aXZlaW50JDEiLCJjb21wbGV4MzIiLCJjb21wbGV4NjQiLCJraW5kX3NpemVfaW5fYnl0ZXMiLCJjX2xheW91dCIsImZvcnRyYW5fbGF5b3V0IiwiY2xvb3AiLCJpZHgiLCJjb2wiLCJmbG9vcCIsImluaXQkNSIsImxheW91dCIsImRpbXMiLCJkbGVuIiwic2l6ZV9pbl9ieXRlcyIsImNyZWF0ZSQ4IiwiZ2V0JDIiLCJzZXQkMSIsInNpemVfaW5fYnl0ZXMkMCIsIm9mX3ZhbHVlIiwiY3JlYXRlJDkiLCJkaW0iLCJzaXplX2luX2J5dGVzJDEiLCJzbGljZSIsImluaXQkNiIsIm9mX2FycmF5IiwiYmEiLCJjcmVhdGUkMTAiLCJkaW0xIiwiZGltMiIsInNpemVfaW5fYnl0ZXMkMiIsInNsaWNlX2xlZnQiLCJzbGljZV9yaWdodCIsImluaXQkNyIsIm9mX2FycmF5JDAiLCJyb3ciLCJjcmVhdGUkMTEiLCJkaW0zIiwic2l6ZV9pbl9ieXRlcyQzIiwic2xpY2VfbGVmdF8xIiwic2xpY2VfcmlnaHRfMSIsInNsaWNlX2xlZnRfMiIsInNsaWNlX3JpZ2h0XzIiLCJpbml0JDgiLCJvZl9hcnJheSQxIiwiYXJyYXkwX29mX2dlbmFycmF5IiwiYXJyYXkxX29mX2dlbmFycmF5IiwiYXJyYXkyX29mX2dlbmFycmF5IiwiYXJyYXkzX29mX2dlbmFycmF5IiwicmVzaGFwZV8wIiwicmVzaGFwZV8xIiwicmVzaGFwZV8yIiwicmVzaGFwZV8zIiwic3BhY2luZ19jaGFyIiwiaW52YWxpZF9jaGFyIiwibW9kcyIsIm9jYW1sX2xleF90YWJsZXMiLCJub3BfY29kZSIsIm5vcF9jb2RlMiIsImVudW1lcmF0ZV9maWxlcyIsImRpcm5hbWUiLCJleHQiLCJ4IiwidWludDMyX29mX3N0ciIsInN0ciIsInN0ciQwIiwiaTY0IiwidWludDMyX3RvX2ludCIsInYiLCJpIiwiaW50NjRfb2ZfdWludDMyIiwiZHVtbXlfZm10IiwiY29uY2F0X3N0cmluZ3MiLCJsc3QiLCJwcCIsImZtdCIsImludDMyX2Zyb21fbG93X2hpZ2giLCJsIiwiaCIsImludDMyX3RvX2xvd19oaWdoIiwic3Vic3RydWN0dXJlc19vcmRlciIsImRhdGFfb2Zmc2V0IiwibGVuIiwicGlkX29mZnNldCIsIm90aWRfb2Zmc2V0IiwiY2hlY2tzdW1fb2Zmc2V0IiwicGttbl9mcm9tX2J5dGVzIiwiYnVmIiwicGlkIiwib3RpZCIsInN1YnN0cnVjdHVyZV9wb3NpdGlvbiIsInNzIiwib3JkZXIiLCJpJDAiLCJpJDEiLCJzdWJzdHJ1Y3R1cmVfb2Zmc2V0IiwicGttbiIsInAiLCJlbmNyeXB0X2FsaWduZWRfaW50MzIiLCJrZXkiLCJjaGVja3N1bV9kaWZmX2Zvcl9hbGlnbmVkX2ludDMiLCJvIiwibiIsImhvIiwibG8iLCJobiIsImxuIiwiZGlmZiIsImVuY19kZWMiLCJvZmZzZXQiLCJvZmZzZXQkMCIsIm9mZnNldCQxIiwiZXh0cmFjdF9kYXRhIiwicmVzIiwidXBkYXRlX3dpdGhfZGF0YSIsImRhdGEiLCJhY2MiLCJsb3ciLCJjaGVja3N1bSIsIm5iIiwiYWNjJDAiLCJzcGVjaWVzX29mZnNldCIsInNwZWNpZXNfb2Zmc2V0X3JlbGF0aXZlX3RvX2RhdCIsIml2ZWFfb2Zmc2V0IiwiaXZlYV9kYXRhX3RvX2l2cyIsImhwIiwiZGF0YSQwIiwiYXRrIiwiZGF0YSQxIiwiZGVmIiwiZGF0YSQyIiwic3BlZWQiLCJkYXRhJDMiLCJzcF9hdGsiLCJkYXRhJDQiLCJzcF9kZWYiLCJkYXRhJDUiLCJpdnNfdG9faXZlYV9kYXRhIiwiZGF0YSQ2IiwiZGF0YSQ3IiwiZGF0YSQ4IiwiZGF0YSQ5IiwiZGF0YSQxMCIsImRhdGEkMTEiLCJsYW5nIiwidHdlYWtlcl9tb2RlIiwiY29uZmlndXJlIiwibGFuZ3VhZ2UiLCJtdWx0X21vZCIsInkiLCJtIiwidHdvX2JpZ19pbnQiLCJhIiwiYiIsImFfaW52IiwiYl9pbnYiLCJiXzEiLCJjeWNsZV9wYXJ0X3Byb2R1Y3QiLCJtYXNrMzIiLCJldmVuIiwib2RkIiwibXBvdyIsImJhc2UiLCJleHAiLCJiYXNlJDAiLCJleHAkMCIsImJhc2UkMSIsImV4cCQxIiwiYmFzZSQyIiwicG93Iiwic2VlZCIsImJpZ19pbnRfb2ZfdWludDMyIiwiaTMyIiwidWludDMyX29mX2JpZ2ludCIsImJpIiwibWF4aW50MzIiLCJtaW5pbnQzMiIsInRvdGFsIiwiYmkkMCIsInJuZ19vZiIsImFQcmVzc2VzIiwibW9yZUFQcmVzc2VzIiwib2xkX3JvZCIsImdvb2Rfcm9kIiwic3VwZXJfcm9kIiwibmV4dF9zZWVkIiwicHJldl9zZWVkIiwiY3ljbGVfdG8iLCJzZWVkJDAiLCJwb3dlciIsIm0kMCIsImJpdG1hc2siLCJscyIsImwkMCIsImJpdCIsImIkMCIsImJpdCQwIiwiaSQyIiwic2VlZF9hdCIsImN5Y2xlIiwiY3ljbGUkMCIsIm9wMSIsImF1eCIsImJlc3Rfc2VlZF9mb3Jfcm9kIiwicm91dGUxMTkiLCJmZWViYXMiLCJ0YXJnZXRfc2VlZCIsInJvZCIsInRhcmdldF9zZWVkJDAiLCJtYXhBZGRpdGlvbmFsT2Zmc2V0cyIsImJlc3RSZXN1bHRzIiwic3RhcnRpbmdfc2VlZCIsIm9mZnNldDExOSIsImFkZGl0aW9uYWxPZmZzZXQiLCJtaW5Sb3VuZHMiLCJiaXRlUm9sbCIsImJpdGVSZXN1bHQiLCJhZHZhbmNlbWVudCIsImJpdGVSb2xsJDAiLCJmZWViYXNSZXN1bHQiLCJhZHZhbmNlbWVudCQwIiwiYnIiLCJzIiwiYWR2IiwicyQwIiwiYWR2JDAiLCJzJDEiLCJtYWluIiwibWFpbl8xIiwibWFpbl8zIiwicm9kbmFtZSIsInNlZWQkMSIsInNob3dfdmljaW5pdHkiLCJwcmludF9jeWNsZSIsInN0YXJ0Iiwic3RvcCIsInN0YXJ0X3NlZWQiLCJtYWluX3ZpY2luaXR5IiwiaiIsIm1haW5fMiIsImdhbWVfc2F2ZV9BIiwiZ2FtZV9zYXZlX0IiLCJzZWN0aW9uX3NpemUiLCJzZWN0aW9uX2lkX29mZnNldCIsImNoZWNrc3VtX29mZnNldCQwIiwic2F2ZV9pbmRleF9vZmZzZXQiLCJib3hfbmFtZXNfc2VjdGlvbl9pZCIsImJveF9uYW1lc19zZWN0aW9uX2RhdGFfbGVuZ3RoIiwiYm94X25hbWVzX29mZnNldCIsImJveF9uYW1lc19sZW5ndGgiLCJ0ZWFtX2l0ZW1zX3NlY3Rpb25faWQiLCJ0ZWFtX2l0ZW1zX3NlY3Rpb25fZGF0YV9sZW5ndGgiLCJ0ZWFtX3NpemVfb2Zmc2V0IiwicGttbl9kYXRhX3NpemUiLCJyZWFkX3NlY3Rpb24iLCJpbmMiLCJzZWN0aW9uX2lkIiwicmJ1ZiIsImFkZHIiLCJpZCIsImluZGV4IiwiaW5kZXhhIiwiYWRkcmEiLCJpbmRleGIiLCJhZGRyYiIsIndyaXRlX3NlY3Rpb24iLCJvYyIsImNvbXB1dGVfY2hlY2tzdW0iLCJoaWdoIiwiZXh0cmFjdF9ib3hfbmFtZXNfZnJvbV9zZWN0aW9uIiwidXBkYXRlX2JveF9uYW1lcyIsImJveF9uYW1lcyIsImVtcHR5X3BrbW4iLCJleHRyYWN0X3RlYW1fZnJvbV9zZWN0aW9uIiwidXBkYXRlX3RlYW0iLCJwa21ucyIsInVwZGF0ZV9wa21uIiwiZ2V0X3BhcmFtIiwibmFtZSIsImxzdCQwIiwibHN0JDEiLCJsc3QkMiIsImV2YWxfbWV0YV9leHByIiwiZW52IiwiZSIsImUkMCIsImUyIiwiZTEiLCJvcCIsImkxIiwiaTIiLCJlJDEiLCJvcCQwIiwiZTIkMCIsImUxJDAiLCJlMCIsImkwIiwiZW1wdHlfZW52IiwiZW52X2Zyb21faGVhZGVycyIsImhlYWRlcnMiLCJ0cmVhdF9kZWYiLCJwcmludGVkIiwiZXhwciIsInByaW50IiwicHJpbnRlZCQwIiwiY29uY2F0X2VudiIsImVudjEiLCJlbnYyIiwiayIsIm1haW4kMCIsIm1haW5fMSQwIiwibWFpbl82IiwibGl2ZWEiLCJoaXZlYSIsIml2ZWEiLCJ1aXZlYSIsInVpdmVhJDAiLCJpdmVhJDAiLCJoaXZlYSQwIiwibGl2ZWEkMCIsImNoZWNrc3VtX2RpZmYiLCJtYWluXzUiLCJtYWluXzQiLCJ2aWQiLCJzaWQiLCJ0aWQiLCJtaXNjX3BvcyIsIml2ZWFfb2Zmc2V0JDAiLCJtYWluXzMkMCIsIm1haW5fMiQwIiwibHBpZCIsImhwaWQiLCJhMSIsImEyIiwiYTMiLCJhNCIsInYxIiwidjIiLCJ2MyIsInY0IiwidjUiLCJ2NiIsInY3IiwidjgiLCJzYiIsInNsIiwiZnAiLCJpcCIsInNwIiwibHIiLCJwYyIsInNpZ25fcGx1cyIsInNpZ25fbWludXMiLCJtYXNrOCIsIm1hc2s5IiwibWFzazEyIiwiYWRkX2NvbmRpdGlvbl9jb2RlIiwiYyIsImFkZF9ybl9jb2RlIiwicm4iLCJhZGRfcmRfY29kZSIsInJkIiwicm90YXRlX3JpZ2h0IiwibGIiLCJ2JDAiLCJyb3RhdGVfbGVmdCIsImhiIiwiYWRkcl9tb2RlXzEiLCJycyIsImltbSIsIm90aGVycyIsImltbTgiLCJyciIsInBvc3NpYmlsaXRpZXMiLCJybSIsInBfYW5kX3ciLCJhZGRyX3R5cCIsImxkcl9zdHJfdG9fYmluYXJ5IiwiaXNfbGRyIiwidHlwIiwiY29uZCIsImNoZWNrX3Bvc3RfYWRkciIsIm9wY29kZSIsInYkMyIsInNpZ24iLCJyZWciLCJzaWduJDAiLCJzaWduJDEiLCJ3IiwidSIsInAkMCIsInckMCIsImFkZHJfbW9kZSIsInYkMSIsInNpZ24kMiIsImltbWVkTCIsImltbWVkSCIsInYkMiIsInNpZ24kMyIsInJtJDAiLCJzaWduJDQiLCJ3JDEiLCJwJDEiLCJ1JDAiLCJwJDIiLCJ3JDIiLCJtb3ZfbXZuX3RvX2JpbmFyeSIsImlzX21vdiIsInNjb2RlIiwic2NvZGUkMCIsImNhbGN1bGF0aW9uX3RvX2JpbmFyeSIsIm9wMiIsImFybV90b19iaW5hcnkiLCJhcm0iLCJybyIsInJvJDAiLCJyZCQwIiwiY29uZCQwIiwidHlwJDAiLCJyZCQxIiwiY29uZCQxIiwicnMkMCIsInJkJDIiLCJjb25kJDIiLCJyZCQzIiwiY29uZCQzIiwib3AyJDAiLCJybiQwIiwicmQkNCIsImNvbmQkNCIsInMkMiIsIm9wMiQxIiwicm4kMSIsInJkJDUiLCJjb25kJDUiLCJzJDMiLCJvcDIkMiIsInJuJDIiLCJyZCQ2IiwiY29uZCQ2IiwicyQ0IiwidGFyZ2V0IiwiY29uZCQ3IiwibXM5IiwicmV2ZXJzZV9lbmRpYW5uZXNzIiwiY2hhcnNldF9lbmciLCJjaGFyc2V0X2l0YSIsImNoYXJzZXRfc3BhIiwiY2hhcnNldF9nZXIiLCJjaGFyc2V0X2ZyYSIsImNoYXJzZXRfamFwIiwiY2hhcnNldCIsImlzX2NvZGVfYXZhaWxhYmxlIiwiY29kZSIsImlzX2NvZGVfcmVhZGFibGUiLCJpc19jb2RlX3VzZWQiLCJjaGFyX2F0IiwicmVhZGFibGVfY2hhcl9hdCIsIndyaXRhYmxlX2NoYXJfYXQiLCJlbmNvZGVfd3JpdGFibGVfY2hhciIsImVvZiIsInNwYWNlIiwiY29kZXNfZm9yX2NvbW1hbmQiLCJjb21tYW5kX2Zvcl9jb2RlcyIsImNvZGVzIiwiYzQiLCJjMyIsImMyIiwiYzEiLCJjb2Rlc190b19jaGFycyIsImNoYXJzX2Zvcl9jb21tYW5kIiwicHBfY2hhcnMiLCJwcF9jaGFyc19yYXciLCJpc19jb2RlX3dyaXRhYmxlIiwiZmlyc3RfY29kZSIsImYiLCJjb2RlcyQwIiwiY29kZXMkMSIsImZpcnN0X3dyaXRhYmxlX2NvZGUiLCJpc19jb2RlX3dyaXRhYmxlX29yX29uZV9lb2YiLCJwcmVmZXJyZWRfY29kZSIsImlzX2Z1bGxfb2Zfc3BhY2VzIiwiY29tcGFyZSIsInBhZGRpbmdfY29kZSIsImFjYyQxIiwibWF4IiwiaW1tZWQ4IiwiaW1tZWQ4JDAiLCJjb25zdGFudHNfc2V0IiwiY29uc3RhbnRzX3NldF9ub19jYXJyeSIsImNvbnN0YW50cyIsInJldl9jb25zdGFudHMiLCJuc2V0IiwiY29uc3RhbnRzX21vdl9tdm4iLCJyZXZfY29uc3RhbnRzX21vdl9tdm4iLCJ0YWQwIiwicmVtb3ZlX3doaWxlIiwic3ludGhlc2lzIiwibW92X212biIsImFkZGl0aXZlIiwiaW5jciIsIm1heF9jYXJkIiwiaXNfdmFsaWRfZnN0IiwiaXNfdmFsaWQiLCJ0YWQwX2xlbiIsInRhZDAkMCIsInJlbW92ZSIsIm5leHQiLCJyYyIsInJjJDAiLCJkZXB0aCIsInJlbV9kZXB0aCIsImlpIiwiZnN0IiwicmMkMSIsInJlbWFpbmRlciIsImZpbHRlcmVkX3Jldl9jb25zdGFudHMiLCJyZW1vdmVfaW5pdCIsIm9wX2luaXQiLCJpbml0X3JjIiwidHJ5X25iIiwidHJ5X25iJDAiLCJzeW50aGVzaXNfb3B0aW1hbCIsImludiIsImNhcmQiLCJjYXJkJDAiLCJzeW50aGVzaXNfdGVzdCIsImlzX2NvbW1hbmRfdmFsaWQiLCJ0d2Vha19tb3Zfb3JfbXZuIiwiY21kIiwibWtfY21kX2ZpcnN0IiwibmZzdCIsImlzX21vdiQwIiwibWtfY21kIiwiYWRkIiwidHdlYWtfYWRjX29yX3NiYyIsImlzX2FkYyIsInR3ZWFrX2NvbW1hbmQiLCJvcHRpbWl6ZSIsIm9wdGltaXplX3dpdGhfY2FyZCIsInBhZCIsInBhZGRpbmciLCJ0d2Vha19hcm0iLCJkb19ub3RfdHdlYWtfYXJtIiwicHJlcHJvY2VzcyIsInVpIiwiY29tYmluZV9vcHQiLCJvMSIsIm8yIiwiY29tYmluZV9ib29sIiwiYjEiLCJiMiIsInJlY29nbml6ZV9tb2RpZmllcnMiLCJzdHIkMyIsIm4kMiIsIm1vZHMkMSIsIm5tb2RzIiwiaSQzIiwibiQwIiwic3RyJDEiLCJpJDQiLCJpJDUiLCJuJDEiLCJzdHIkMiIsImkkNiIsImkkNyIsImwkMSIsIm1vZHMkMCIsInJlZ2lzdGVyX29mX3N0ciIsImdldF9yZWdpc3RlciIsImFyZyIsImdldF9yZCIsImFyZ3MiLCJnZXRfcm4iLCJnZXRfb3AyIiwiZ2V0X3JvIiwiciIsImdldF90YXJnZXQiLCJjbWRfdG9fYXJtIiwiY21kJDEiLCJjbWQkMiIsInBvcyIsInR5cCQxIiwiY21kJDAiLCJjJDAiLCJ0b19hcm0iLCJhc3QiLCJlUlIiLCJtZW5oaXJfZGlzY2FyZCIsIm1lbmhpcl9lbnYiLCJsZXhlciIsImxleGJ1ZiIsInRvayIsIm1lbmhpcl9lcnJvcmNhc2UiLCJtZW5oaXJfc3RhY2siLCJtZW5oaXJfcyIsIm1lbmhpcl9zdGFjayQwIiwibWVuaGlyX3MkMCIsIm1lbmhpcl9zJDEiLCJtZW5oaXJfc3RhY2skMSIsIm1lbmhpcl9zJDIiLCJtZW5oaXJfc3RhY2skMiIsIm1lbmhpcl9zJDMiLCJtZW5oaXJfc3RhY2skMyIsIm1lbmhpcl9zJDQiLCJtZW5oaXJfc3RhY2skNCIsIm1lbmhpcl9zJDUiLCJtZW5oaXJfc3RhY2skNSIsIm1lbmhpcl9zJDYiLCJtZW5oaXJfc3RhY2skNiIsIm1lbmhpcl9zJDciLCJtZW5oaXJfc3RhY2skNyIsIm1lbmhpcl9zJDgiLCJtZW5oaXJfc3RhY2skOCIsIm1lbmhpcl9zJDkiLCJtZW5oaXJfc3RhY2skOSIsIm1lbmhpcl9zJDEwIiwibWVuaGlyX3N0YWNrJDEwIiwibWVuaGlyX3MkMTEiLCJtZW5oaXJfc3RhY2skMTEiLCJtZW5oaXJfcyQxMiIsIm1lbmhpcl9zdGFjayQxMiIsIm1lbmhpcl9zJDEzIiwibWVuaGlyX3N0YWNrJDEzIiwibWVuaGlyX3MkMTQiLCJtZW5oaXJfc3RhY2skMTQiLCJtZW5oaXJfcyQxNSIsIm1lbmhpcl9zdGFjayQxNSIsIm1lbmhpcl9zJDE2IiwibWVuaGlyX3N0YWNrJDE2IiwibWVuaGlyX3MkMTciLCJtZW5oaXJfc3RhY2skMTciLCJtZW5oaXJfcyQxOCIsIm1lbmhpcl9zdGFjayQxOCIsIm1lbmhpcl9zJDE5IiwibWVuaGlyX3N0YWNrJDE5IiwibWVuaGlyX3MkMjAiLCJtZW5oaXJfc3RhY2skMjAiLCJtZW5oaXJfcyQyMSIsIm1lbmhpcl9zdGFjayQyMSIsIm1lbmhpcl9zJDIyIiwibWVuaGlyX3N0YWNrJDIyIiwibWVuaGlyX3MkMjMiLCJtZW5oaXJfc3RhY2skMjMiLCJtZW5oaXJfcyQyNCIsIm1lbmhpcl9zdGFjayQyNCIsIm1lbmhpcl9zJDI1IiwibWVuaGlyX3N0YWNrJDI1IiwibWVuaGlyX3MkMjYiLCJtZW5oaXJfc3RhY2skMjYiLCJtZW5oaXJfcyQyNyIsIm1lbmhpcl9zdGFjayQyNyIsIm1lbmhpcl9zJDI4IiwibWVuaGlyX3N0YWNrJDI4IiwibWVuaGlyX3MkMjkiLCJtZW5oaXJfc3RhY2skMjkiLCJtZW5oaXJfcyQzMCIsIm1lbmhpcl9zdGFjayQzMCIsIm1lbmhpcl9zJDMxIiwibWVuaGlyX3N0YWNrJDMxIiwibWVuaGlyX3MkMzIiLCJtZW5oaXJfc3RhY2skMzIiLCJtZW5oaXJfcyQzMyIsIm1lbmhpcl9zdGFjayQzMyIsIm1lbmhpcl9zJDM0IiwibWVuaGlyX3N0YWNrJDM0IiwibWVuaGlyX3MkMzUiLCJtZW5oaXJfc3RhY2skMzUiLCJtZW5oaXJfcyQzNiIsIm1lbmhpcl9zdGFjayQzNiIsIm1lbmhpcl9mYWlsIiwibWVuaGlyX2dvdG9fYXN0IiwibWVuaGlyX2dvdG9faGVhZGVycyIsImQiLCJtZW5oaXJfcnVuMTUiLCJtZW5oaXJfZW52JDAiLCJtZW5oaXJfcnVuNiIsIm1lbmhpcl9ydW44IiwibWVuaGlyX3J1bjkiLCJtZW5oaXJfcnVuMTAiLCJtZW5oaXJfcnVuMTIiLCJtZW5oaXJfcnVuNyIsIm1lbmhpcl9ydW4xMSIsIm1lbmhpcl9ydW4xNyIsIm1lbmhpcl9ydW4xOSIsIm1lbmhpcl9ydW4yMSIsIm1lbmhpcl9ydW4zOCIsIm1lbmhpcl9ydW4yOSIsIm1lbmhpcl9ydW4yMyIsIm1lbmhpcl9ydW4yNyIsIm1lbmhpcl9ydW4zMSIsIm1lbmhpcl9ydW40MCIsIm1lbmhpcl9ydW4zMyIsIm1lbmhpcl9ydW4yNSIsIm1lbmhpcl9ydW40NCIsIm1lbmhpcl9ydW40NiIsIm1lbmhpcl9ydW4zNSIsIm1lbmhpcl9nb3RvX29mZnNldCIsInRvayQwIiwibWVuaGlyX2VudiQxIiwiaWQkMCIsIm1lbmhpcl9nb3RvX2FyZyIsImlkJDEiLCJtZW5oaXJfZ290b19tZXRhX2V4cHIiLCJtZW5oaXJfZ290b19kZWZpbml0aW9uIiwidG9rJDEiLCJ0b2skMiIsInYkNCIsInRvayQzIiwiZTIkMSIsImUxJDEiLCJ2JDUiLCJ0b2skNCIsInRvayQ1IiwidiQ2IiwidiQ3IiwidG9rJDYiLCJlMiQyIiwiZTEkMiIsInYkOCIsInRvayQ3IiwiZTIkMyIsImUxJDMiLCJ2JDkiLCJ0b2skOCIsImUyJDQiLCJlMSQ0IiwidiQxMCIsInRvayQ5IiwiZTIkNSIsImUxJDUiLCJ2JDExIiwidG9rJDEwIiwiZTIkNiIsImUxJDYiLCJ2JDEyIiwidG9rJDExIiwiZTIkNyIsImUxJDciLCJ2JDEzIiwiZTIkOCIsImUxJDgiLCJ2JDE0IiwiZTIkOSIsImUxJDkiLCJ2JDE1IiwidG9rJDEyIiwiZTIkMTAiLCJlMSQxMCIsInYkMTYiLCJ0b2skMTMiLCJlMiQxMSIsImUxJDExIiwidiQxNyIsImUyJDEyIiwiZTEkMTIiLCJ2JDE4IiwidG9rJDE0IiwiZTIkMTMiLCJlMSQxMyIsInYkMTkiLCJ2JDIwIiwidG9rJDE1IiwibWVuaGlyX2VudiQyIiwidiQyMSIsImUkMiIsIm1lbmhpcl9zdGFjayQzNyIsInYkMjIiLCJlJDMiLCJtZW5oaXJfc3RhY2skMzgiLCJ2JDIzIiwiZSQ0IiwibWVuaGlyX3N0YWNrJDM5IiwidiQyNCIsInRvayQxNiIsIm1lbmhpcl9lbnYkMyIsImUkNSIsInN0YXJ0cG9zXzEiLCJtZW5oaXJfcyQzOCIsIm1lbmhpcl9zdGFjayQ0MSIsInYkMjUiLCJtZW5oaXJfZ290b19udW1iZXIiLCJtZW5oaXJfcyQzNyIsIm1lbmhpcl9zdGFjayQ0MCIsIm1lbmhpcl9nb3RvX2NvbW1hbmQiLCJtZW5oaXJfcnVuMSQwIiwibWVuaGlyX3JlZHVjZTI2JDAiLCJzdGFydHBvcyIsIm1lbmhpcl9ydW41OSIsIm1lbmhpcl9ydW41IiwibWVuaGlyX3J1bjQiLCJtZW5oaXJfcnVuNjIiLCJtZW5oaXJfcnVuNjUiLCJtZW5oaXJfcnVuNjYiLCJtZW5oaXJfcnVuNTQiLCJtZW5oaXJfcnVuNzkiLCJtZW5oaXJfcnVuNzgiLCJ4JDAiLCJtZW5oaXJfZ290b19sb3B0aW9uX3NlcGFyYXRlZF8iLCJtYXRjaCIsInN0YXJ0cG9zX2lkIiwic3RhcnRwb3NfaWQkMCIsInN0YXJ0cG9zX2lkJDEiLCJzdGFydHBvc19pIiwibWVuaGlyX2VudiQ0IiwibWVuaGlyX2VudiQ1IiwibWVuaGlyX2VudiQxMSIsInhzIiwibWVuaGlyX2VudiQ2Iiwic3RhcnRwb3MkMCIsIm1lbmhpcl9lbnYkNyIsIm1lbmhpcl9lbnYkOCIsIm1lbmhpcl9lbnYkOSIsIm1lbmhpcl9lbnYkMTAiLCJtZW5oaXJfcmVkdWNlMjYiLCJtZW5oaXJfcnVuMSIsIm5leHRfbGluZSIsImVvZl9yZWFjaGVkIiwicmVhZF9jb21tZW50JDAiLCJvY2FtbF9sZXhfcmVhZF9jb21tZW50X3JlYyQwIiwib2NhbWxfbGV4X3N0YXRlIiwib2NhbWxfbGV4X3N0YXRlJDAiLCJvY2FtbF9sZXhfc3RhdGUkMSIsInJlYWRfY29tbWVudCIsIm9jYW1sX2xleF9yZWFkX2NvbW1lbnRfcmVjIiwicmVhZF9zdHJpbmckMCIsIm9jYW1sX2xleF9yZWFkX3N0cmluZ19yZWMkMCIsInJlYWRfc3RyaW5nIiwib2NhbWxfbGV4X3JlYWRfc3RyaW5nX3JlYyIsInJlYWQkMCIsIm9jYW1sX2xleF9yZWFkX3JlYyQwIiwicmVhZCIsIm9jYW1sX2xleF9yZWFkX3JlYyIsInByaW50X3Bvc2l0aW9uIiwicHJpbnRfbGV4YnVmX3BvcyIsInBhcnNlX3dpdGhfZXJyb3IiLCJtc2ciLCJmcm9tX2xleGJ1ZiIsImhlYWRlcnMkMCIsImhlYWRlcnMkMSIsImFzdCQwIiwiZnJvbV9maWxlbmFtZSIsImZpbGVuYW1lIiwiY2hhbm5lbCIsImZyb21fc3RyIiwicGFyc2VkX2FzdF90b19hcm0iLCJwYXJzZWRfY29udGVudF90b19hcm0iLCJlbnYkMCIsInBhcnNlIiwibWFpbl9maWxlIiwiZm4iLCJmbiQwIiwiZnJvbV9maWxlbmFtZSQwIiwiZnJvbV9zdHIkMCIsIm1mIiwiZ2V0X2ZpbGUiLCJmaWxlcyIsImxvYWRfZnJvbV9kaXIiLCJwYXRoIiwibG9hZF9mcm9tX3BhcnNlZF9maWxlIiwibG9hZF9mcm9tX2ZpbGUiLCJnZXRfcHJlZmVycmVkIiwiZGVmYXVsdCQwIiwic3RyaW5nX29mX3VjaGFyIiwidWNoYXIiLCJidWZmZXIiLCJkZWNvbXBvc2VfaW50b191Y2hhcnMiLCJ1YyIsInVjJDAiLCJtYWluJDEiLCJtYWluXzEkMSIsImF1eDIiLCJhdXg0IiwiZW5jb2RpbmciLCJlbmNvZGluZyQwIiwiZW5jb2RpbmckMSIsImVuY29kaW5nJDIiLCJkZWZhdWx0X2ZpbGxlcnMiLCJuYl9ib3hlcyIsIm5vX2VvZiIsInBhZF9uYiIsImZpbGxlcnMiLCJwb3MkMCIsImZpdF9jb2RlX2F0X3BvcyIsIm9wdCIsImNvZGVzJDkiLCJzdGgiLCJpc19va19oZXJlIiwiY29kZXMkMiIsImNvZGVzJDMiLCJjb2RlcyQ0IiwiY29kZXMkNSIsImMkMSIsImNvZGVzJDYiLCJuZXh0JDAiLCJjb2RlcyQ3IiwiY29kZXMkOCIsImMkMiIsImFjYyQyIiwibm9wX2NvZGUkMCIsImFkZF9jb2Rlc19hZnRlciIsImZpbmFsJDAiLCJuYyIsInNwbGl0X3Jhd19pbnRvX2JveGVzIiwicmF3IiwiZmlsbF9sYXN0IiwiZmluaXNoZWQiLCJjdXJyZW50IiwiZmluaXNoZWQkMCIsImN1cnJlbnQkMCIsImN1cnJlbnQkMSIsImZpdF9jb2Rlc19pbnRvX2JveGVzIiwic3RoJDAiLCJzdGgkMSIsInN0aCQyIiwiZXhpdCIsImV4aXQkMCIsImVjb2RlIiwicGFkZGluZyQwIiwicmVzJDAiLCJyZXMkMSIsInJlcyQyIiwicmVzdWx0IiwicHJlZml4Iiwic3VmZml4X2xlbiIsInN1ZmZpeCIsInBwX2JveGVzX25hbWVzIiwicHBfYm94IiwiY2hhcnMiLCJwcF9ib3hfcmF3IiwicHBfaGV4IiwiY29uZF90b19zdHIiLCJsZHJfc3RyX3R5cGVfdG9fc3RyIiwidCIsInNpZ25fdG9fc3RyIiwic190b19zdHIiLCJwcmludF9yZWdpc3RlciIsInByaW50X2ltbWVkaWF0ZSIsInByaW50X29wZXJhbmQiLCJwcmludF9pbW1lZGlhdGVfb2Zmc2V0IiwicHJpbnRfcmVnaXN0ZXJfb2Zmc2V0Iiwicm8kMSIsInBwX2FybSIsInRyZWF0X2NvbW1hbmQiLCJoZXhzIiwiaGV4IiwibWFpbiQyIiwicGFyc2VkIiwiaGVhZGVyczIiLCJvbmx5cmF3IiwiaGVhZGVyX25hbWUiLCJzdGFydCQwIiwiYm94ZXNfY29kZXMiLCJzaXplIiwiam9vX2dsb2JhbF9vYmplY3QiLCJudWxsIiwidW5kZWZpbmVkIiwiZXhuIiwiZXZlbnQiLCJ0cmVhdF9pbnB1dCIsImxhbmciLCJzdHIiLCJidWZmZXIiLCJmbXQiLCJmcyIsInByb2dyYW0iLCJoZWFkZXJzIiwiZW52IiwiaGVhZGVyczIiLCJleGl0IiwiZm4iLCJhc3QiLCJoZWFkZXJzJDAiLCJleGl0JDAiLCJlIiwiaXNfYmxhbmtfc3RyIiwicyIsImkkMSIsImkiLCJjIiwiaSQwIiwiY29tcHV0ZSIsIm1haW5faW5wdXQiLCJzZWNvbmRhcnlfaW5wdXQiLCJvdXRwdXQiLCJtYWluX2lucHV0JDAiLCJzZWNvbmRhcnlfaW5wdXQkMCIsImlucHV0IiwibGFuZyQwIiwicmVzIiwiaW5pdCIsImNvbXB1dGVfYnV0dG9uIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vK2ludDY0LmpzIiwiL2J1aWx0aW4vK21sQnl0ZXMuanMiLCIvYnVpbHRpbi8rZmFpbC5qcyIsIi9idWlsdGluLytzdGRsaWIuanMiLCIvYnVpbHRpbi8rZm9ybWF0LmpzIiwiL2J1aWx0aW4vK2llZWVfNzU0LmpzIiwiL2J1aWx0aW4vK2ZzLmpzIiwiL2J1aWx0aW4vK3N5cy5qcyIsIi9idWlsdGluLytmc19mYWtlLmpzIiwiL2J1aWx0aW4vK2ZzX25vZGUuanMiLCIvYnVpbHRpbi8rbmF0LmpzIiwiL2J1aWx0aW4vK2dyYXBoaWNzLmpzIiwiL2J1aWx0aW4vK21hcnNoYWwuanMiLCIvYnVpbHRpbi8raW8uanMiLCIvYnVpbHRpbi8rZ2MuanMiLCIvYnVpbHRpbi8rYmlnYXJyYXkuanMiLCIvYnVpbHRpbi8ranNsaWIuanMiLCIvYnVpbHRpbi8rcGFyc2luZy5qcyIsIi9idWlsdGluLytqc2xpYl9qc19vZl9vY2FtbC5qcyIsIi9idWlsdGluLyt1bml4LmpzIiwiL2J1aWx0aW4vK2ludHMuanMiLCIvYnVpbHRpbi8raGFzaC5qcyIsIi9idWlsdGluLytjb21wYXJlLmpzIiwiL2J1aWx0aW4vK2ludGVybmFsTW9kLmpzIiwiL2J1aWx0aW4vK29iai5qcyIsIi9idWlsdGluLytiaWdzdHJpbmcuanMiLCIvYnVpbHRpbi8rYmFja3RyYWNlLmpzIiwiL2J1aWx0aW4vK2xleGluZy5qcyIsIi9idWlsdGluLythcnJheS5qcyIsIi9idWlsdGluLyt3ZWFrLmpzIiwiL2J1aWx0aW4vK21kNS5qcyIsIi9idWlsdGluLytzdHIuanMiLCIvYnVpbHRpbi8rYmlnc3RyaW5nLWNzdHJ1Y3QuanMiLCIvaG9tZS9taWNrLy5vcGFtLzQuMTIuMC9saWIvb2NhbWwvdWNoYXIubWwiLCIvaG9tZS9taWNrLy5vcGFtLzQuMTIuMC9saWIvb2NhbWwvaW50NjQubWwiLCIvaG9tZS9taWNrLy5vcGFtLzQuMTIuMC9saWIvb2NhbWwvbGV4aW5nLm1sIiwiL2hvbWUvbWljay8ub3BhbS80LjEyLjAvbGliL29jYW1sL2NhbWxpbnRlcm5hbEZvcm1hdC5tbCIsIi9ob21lL21pY2svLm9wYW0vNC4xMi4wL2xpYi9vY2FtbC9wcmludGV4Yy5tbCIsIi9ob21lL21pY2svLm9wYW0vNC4xMi4wL2xpYi9vY2FtbC9maWxlbmFtZS5tbCIsIi9ob21lL21pY2svLm9wYW0vNC4xMi4wL2xpYi9vY2FtbC9jb21wbGV4Lm1sIiwiL2hvbWUvbWljay8ub3BhbS80LjEyLjAvbGliL29jYW1sL2NhbWxpbnRlcm5hbEZvcm1hdEJhc2ljcy5tbCIsIi9ob21lL21pY2svLm9wYW0vNC4xMi4wL2xpYi9vY2FtbC9jYW1saW50ZXJuYWxBdG9taWMubWwiLCIvaG9tZS9taWNrLy5vcGFtLzQuMTIuMC9saWIvb2NhbWwvc3RkbGliLm1sIiwiL2hvbWUvbWljay8ub3BhbS80LjEyLjAvbGliL29jYW1sL3BlcnZhc2l2ZXMubWwiLCIvaG9tZS9taWNrLy5vcGFtLzQuMTIuMC9saWIvb2NhbWwvZmxvYXQubWwiLCIvaG9tZS9taWNrLy5vcGFtLzQuMTIuMC9saWIvb2NhbWwvbmF0aXZlaW50Lm1sIiwiL2hvbWUvbWljay8ub3BhbS80LjEyLjAvbGliL29jYW1sL2xpc3QubWwiLCIvaG9tZS9taWNrLy5vcGFtLzQuMTIuMC9saWIvb2NhbWwvc2VxLm1sIiwiL2hvbWUvbWljay8ub3BhbS80LjEyLjAvbGliL29jYW1sL29wdGlvbi5tbCIsIi9ob21lL21pY2svLm9wYW0vNC4xMi4wL2xpYi9vY2FtbC9laXRoZXIubWwiLCIvaG9tZS9taWNrLy5vcGFtLzQuMTIuMC9saWIvb2NhbWwvcmVzdWx0Lm1sIiwiL2hvbWUvbWljay8ub3BhbS80LjEyLjAvbGliL29jYW1sL2Jvb2wubWwiLCIvaG9tZS9taWNrLy5vcGFtLzQuMTIuMC9saWIvb2NhbWwvY2hhci5tbCIsIi9ob21lL21pY2svLm9wYW0vNC4xMi4wL2xpYi9vY2FtbC9ieXRlcy5tbCIsIi9ob21lL21pY2svLm9wYW0vNC4xMi4wL2xpYi9vY2FtbC9zdHJpbmcubWwiLCIvaG9tZS9taWNrLy5vcGFtLzQuMTIuMC9saWIvb2NhbWwvdW5pdC5tbCIsIi9ob21lL21pY2svLm9wYW0vNC4xMi4wL2xpYi9vY2FtbC9tYXJzaGFsLm1sIiwiL2hvbWUvbWljay8ub3BhbS80LjEyLjAvbGliL29jYW1sL29iai5tbCIsIi9ob21lL21pY2svLm9wYW0vNC4xMi4wL2xpYi9vY2FtbC9hcnJheS5tbCIsIi9ob21lL21pY2svLm9wYW0vNC4xMi4wL2xpYi9vY2FtbC9pbnQubWwiLCIvaG9tZS9taWNrLy5vcGFtLzQuMTIuMC9saWIvb2NhbWwvaW50MzIubWwiLCIvaG9tZS9taWNrLy5vcGFtLzQuMTIuMC9saWIvb2NhbWwvcGFyc2luZy5tbCIsIi9ob21lL21pY2svLm9wYW0vNC4xMi4wL2xpYi9vY2FtbC9zZXQubWwiLCIvaG9tZS9taWNrLy5vcGFtLzQuMTIuMC9saWIvb2NhbWwvbWFwLm1sIiwiL2hvbWUvbWljay8ub3BhbS80LjEyLjAvbGliL29jYW1sL3N0YWNrLm1sIiwiL2hvbWUvbWljay8ub3BhbS80LjEyLjAvbGliL29jYW1sL3F1ZXVlLm1sIiwiL2hvbWUvbWljay8ub3BhbS80LjEyLjAvbGliL29jYW1sL2NhbWxpbnRlcm5hbExhenkubWwiLCIvaG9tZS9taWNrLy5vcGFtLzQuMTIuMC9saWIvb2NhbWwvbGF6eS5tbCIsIi9ob21lL21pY2svLm9wYW0vNC4xMi4wL2xpYi9vY2FtbC9zdHJlYW0ubWwiLCIvaG9tZS9taWNrLy5vcGFtLzQuMTIuMC9saWIvb2NhbWwvYnVmZmVyLm1sIiwiL2hvbWUvbWljay8ub3BhbS80LjEyLjAvbGliL29jYW1sL3ByaW50Zi5tbCIsIi9ob21lL21pY2svLm9wYW0vNC4xMi4wL2xpYi9vY2FtbC9hcmcubWwiLCIvaG9tZS9taWNrLy5vcGFtLzQuMTIuMC9saWIvb2NhbWwvZnVuLm1sIiwiL2hvbWUvbWljay8ub3BhbS80LjEyLjAvbGliL29jYW1sL2djLm1sIiwiL2hvbWUvbWljay8ub3BhbS80LjEyLjAvbGliL29jYW1sL2RpZ2VzdC5tbCIsIi9ob21lL21pY2svLm9wYW0vNC4xMi4wL2xpYi9vY2FtbC9yYW5kb20ubWwiLCIvaG9tZS9taWNrLy5vcGFtLzQuMTIuMC9saWIvb2NhbWwvaGFzaHRibC5tbCIsIi9ob21lL21pY2svLm9wYW0vNC4xMi4wL2xpYi9vY2FtbC93ZWFrLm1sIiwiL2hvbWUvbWljay8ub3BhbS80LjEyLjAvbGliL29jYW1sL2Zvcm1hdC5tbCIsIi9ob21lL21pY2svLm9wYW0vNC4xMi4wL2xpYi9vY2FtbC9zY2FuZi5tbCIsIi9ob21lL21pY2svLm9wYW0vNC4xMi4wL2xpYi9vY2FtbC9jYWxsYmFjay5tbCIsIi9ob21lL21pY2svLm9wYW0vNC4xMi4wL2xpYi9vY2FtbC9jYW1saW50ZXJuYWxPTy5tbCIsIi9ob21lL21pY2svLm9wYW0vNC4xMi4wL2xpYi9vY2FtbC9nZW5sZXgubWwiLCIvaG9tZS9taWNrLy5vcGFtLzQuMTIuMC9saWIvb2NhbWwvZXBoZW1lcm9uLm1sIiwiL2hvbWUvbWljay8ub3BhbS80LjEyLjAvbGliL29jYW1sL2JpZ2FycmF5Lm1sIiwiL21udC9jL1VzZXJzL01pY2svRGVza3RvcC9FbWVyYWxkQUNFL19idWlsZC9kZWZhdWx0L0JveGVzL2NoYXJzZXQubWwiLCIvbW50L2MvVXNlcnMvTWljay9EZXNrdG9wL0VtZXJhbGRBQ0UvX2J1aWxkL2RlZmF1bHQvQVJNL3BhcnNlcl9hc3QubWwiLCIvbW50L2MvVXNlcnMvTWljay9EZXNrdG9wL0VtZXJhbGRBQ0UvX2J1aWxkL2RlZmF1bHQvSU8vbGV4ZXIubWwiLCIvbW50L2MvVXNlcnMvTWljay9EZXNrdG9wL0VtZXJhbGRBQ0UvX2J1aWxkL2RlZmF1bHQvQm94ZXMvYm94ZXMubWwiLCIvbW50L2MvVXNlcnMvTWljay9EZXNrdG9wL0VtZXJhbGRBQ0UvX2J1aWxkL2RlZmF1bHQvSU8vdXRpbHMubWwiLCIvbW50L2MvVXNlcnMvTWljay9EZXNrdG9wL0VtZXJhbGRBQ0UvX2J1aWxkL2RlZmF1bHQvUG9rZW1vbi9zdHJ1Y3R1cmUubWwiLCIvbW50L2MvVXNlcnMvTWljay9EZXNrdG9wL0VtZXJhbGRBQ0UvX2J1aWxkL2RlZmF1bHQvTWFpbi9zZXR0aW5ncy5tbCIsIi9tbnQvYy9Vc2Vycy9NaWNrL0Rlc2t0b3AvRW1lcmFsZEFDRS9fYnVpbGQvZGVmYXVsdC9Qb2tlbW9uL3NlZWQubWwiLCIvbW50L2MvVXNlcnMvTWljay9EZXNrdG9wL0VtZXJhbGRBQ0UvX2J1aWxkL2RlZmF1bHQvTWFpbi9zZWVkX3Rvb2xzX2NvbW1vbi5tbCIsIi9tbnQvYy9Vc2Vycy9NaWNrL0Rlc2t0b3AvRW1lcmFsZEFDRS9fYnVpbGQvZGVmYXVsdC9TYXZlL3NhdmUubWwiLCIvbW50L2MvVXNlcnMvTWljay9EZXNrdG9wL0VtZXJhbGRBQ0UvX2J1aWxkL2RlZmF1bHQvSU8vcHJlcHJvY2Vzcy5tbCIsIi9tbnQvYy9Vc2Vycy9NaWNrL0Rlc2t0b3AvRW1lcmFsZEFDRS9fYnVpbGQvZGVmYXVsdC9NYWluL3BrbW5fZGF0YV9jb21tb24ubWwiLCIvbW50L2MvVXNlcnMvTWljay9EZXNrdG9wL0VtZXJhbGRBQ0UvX2J1aWxkL2RlZmF1bHQvQVJNL2FybS5tbCIsIi9tbnQvYy9Vc2Vycy9NaWNrL0Rlc2t0b3AvRW1lcmFsZEFDRS9fYnVpbGQvZGVmYXVsdC9Cb3hlcy9uYW1lLm1sIiwiL21udC9jL1VzZXJzL01pY2svRGVza3RvcC9FbWVyYWxkQUNFL19idWlsZC9kZWZhdWx0L0FSTS9vcHRpbWl6ZXIubWwiLCIvbW50L2MvVXNlcnMvTWljay9EZXNrdG9wL0VtZXJhbGRBQ0UvX2J1aWxkL2RlZmF1bHQvSU8vcGFyc2VyLm1sIiwiL21udC9jL1VzZXJzL01pY2svRGVza3RvcC9FbWVyYWxkQUNFL19idWlsZC9kZWZhdWx0L0lPL3BhcnNlci5tbHkiLCIvbW50L2MvVXNlcnMvTWljay9EZXNrdG9wL0VtZXJhbGRBQ0UvX2J1aWxkL2RlZmF1bHQvSU8vbGV4ZXIubWxsIiwiL21udC9jL1VzZXJzL01pY2svRGVza3RvcC9FbWVyYWxkQUNFL19idWlsZC9kZWZhdWx0L0lPL3BhcnNlLm1sIiwiL21udC9jL1VzZXJzL01pY2svRGVza3RvcC9FbWVyYWxkQUNFL19idWlsZC9kZWZhdWx0L0lPL2ZzLm1sIiwiL21udC9jL1VzZXJzL01pY2svRGVza3RvcC9FbWVyYWxkQUNFL19idWlsZC9kZWZhdWx0L0JveGVzL2V4aXQubWwiLCIvbW50L2MvVXNlcnMvTWljay9EZXNrdG9wL0VtZXJhbGRBQ0UvX2J1aWxkL2RlZmF1bHQvTWFpbi9lbmNvZGVyX2NvbW1vbi5tbCIsIi9tbnQvYy9Vc2Vycy9NaWNrL0Rlc2t0b3AvRW1lcmFsZEFDRS9fYnVpbGQvZGVmYXVsdC9BUk0vYXJtX3ByaW50ZXIubWwiLCIvbW50L2MvVXNlcnMvTWljay9EZXNrdG9wL0VtZXJhbGRBQ0UvX2J1aWxkL2RlZmF1bHQvTWFpbi9hY2VfY29tbW9uLm1sIiwiIiwiL21udC9jL1VzZXJzL01pY2svRGVza3RvcC9FbWVyYWxkQUNFL19idWlsZC9kZWZhdWx0L01haW4vYWNlX2pzLm1sIiwiL2hvbWUvbWljay8ub3BhbS80LjEyLjAvbGliL29jYW1sL3N0ZF9leGl0Lm1sIl0sIm1hcHBpbmdzIjoiOzs7O0lBME9BLFNBQVNBLG1CQUFtQkMsR0FBSyxTQUFRLFVBQVk7SUN6THJELFNBQVNDLGdCQUFnQkMsRUFBR0M7TUFDMUIsR0FBR0QsT0FBUTtNQUNYLEdBQUlDLFNBQVUsT0FBUSxTQUFTRDtNQUMvQixJQUFNLEtBQVE7TUFDZDtPQUFRLENBQ04sR0FBSUEsTUFBT0UsS0FBS0Q7UUFDaEJEO1FBQ0EsR0FBSUEsT0FBUSxPQUFPRTtRQUNuQkQsS0FBS0E7UUFDTEU7UUFDQSxHQUFJQSxPQUFRLGFBTWhCO0lEN0NBLElBQUlDLGtCQUFvQjtJRUF4QixTQUFTRSxvQkFBcUJDLEtBQU8sTUFBTUEsR0FBSztJQzJDaEQsSUFBSUM7SURSSixTQUFTQztNQUNQLG9CQUFvQkQsa0NBQ3RCO0lGakNBLFNBQVNFLFFBQVNDLEdBQUdDLEdBQUdDO01BQ3RCQyxVQUFVSCxjQUNWRyxVQUFVRixjQUNWRSxVQUFVRCxXQUNaO0lBQ0FIO0lBQ0FBOztlQUNFLFdBQVdBLFFBQVFJLFFBQVFBLFFBQVFBLFFBRFo7SUFJekJKOzthQUF1Q1o7TUFDckMsR0FBSWdCLFVBQVVoQixLQUFNO01BQ3BCLEdBQUlnQixVQUFVaEIsS0FBTTtNQUNwQixHQUFJZ0IsVUFBVWhCLEtBQU07TUFDcEIsR0FBSWdCLFVBQVVoQixLQUFN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Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1U7Ozs7Ozs7SWM3QjFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0NrQksraUM7S0FDQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQ3dCQUM7S0FDQUM7S0FDQUM7S0FJQUM7S0FDQUM7Ozs7S0N6QkFDO0tBb0hBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0NtOUVNQztLQVFRQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0NsbEZkQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0NzRUVDO0tBQ0FDO0tBQ0FDO0tBQ0FDOzs7S0EvRVlDO0tBcUhaQztLQUNBQztLQUNBQztLQUNBQzs7O0tBbUlBQztLQUNBQztLQUNBQztLQUNBQzs7O0tDMVBGQztLQUNBQztLQUNBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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TGxELFNDakpUaUQ7TURrVW1CLG9CQzFVbkJqRCxXRDBVNEMscUJDMVU1Q0EsT0QwVXdEO0lBakwvQyxTQ2hKVGtELFdEcVVXNUMsR0FBSSwyQkM3VWZMLE9ENlVXSyxFQUF3QjtJQXJMMUIsU0MvSVQ2QyxhRHFVYXhGLEdBQUkscUJDOVVqQnNDLE9EOFVhdEMsRUFBMEI7SUF0TDlCLFNDOUlUeUYsWURxVVl6RixHQUFJLG9CQy9VaEJzQyxPRCtVWXRDLEVBQXlCO0lBdkw1QixTQzdJVDBGLFVEcVVVcEs7TUFBeUIscUJDaFZuQ2dILE9EZ1ZtQyw0QkFBekJoSCxHQUEwQztJQXhMM0MsU0M1SVRxSyxZRHFVWW5HLEdBQXlCLHFCQ2pWckM4QyxPRGlWcUMsVUFBekI5QyxHQUE0QztJQXpML0MsU0MzSVRvRyxjRHFVYzVGO01BQ2hCLGNDblZFc0MsT0RrVmN0QztNQUNRLG9CQ25WdEJzQztNRG1WK0MscUJDblYvQ0EsT0RtVjJEO0lBM0xsRCxTQzFJVHVEO01Ec1VtQixvQkNwVm5CdkQsV0RvVjRDLHFCQ3BWNUNBLE9Eb1Z3RDtJQTVML0MsU0N6SVR3RCxpQkR5VWUsY0N6VmZ6RCxRRHlWZSxrQkMxVmZELE1EMFY2QztJQWhNcEMsU0N4SVQyRCxnQkR5VXdDLDBCQUFiLGFBQWE7SUFqTS9CLFNDdklUQyxvQkR5VW1DLHNDQUFhO0lBbE12QyxTQ3RJVEMsa0JEeVU0Qyw0QkFBYixhQUFhO0lBbk1uQyxTQ3JJVEMsc0JEeVV1QyxrQ0FBYTtJQXBNM0MsU0MxRVRDLHdCWDVPTCxJVW9oQnFDakk7SUE5TnZCLFNDdEVUa0k7TUQ0U007T0FGc0NDO09BQU50SjtPQUFoQnVKO09BQU54SjtPQUVWLFlBRmdCd0osS0FFVCxhQUYrQkQ7TUFDdEMscUJBRFV2SixLQUFzQkM7SUFRdEIsSUFBaEJ3SixpQkNsV0F6RDtJRGtXZ0IsU0NoVGhCMEQsUURrVFloSDtNQUNkO1FBRW1COztTQUNKLFNBTmIrRztTQU1hO21CQURYRSxhQUNBQztxQkFDQUU7Y0FDQyxtQkFIREgsa0JBR3FELFdBTjNDakg7Y0FNK0Msa0JBRnpE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Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0NrTktDO0tBQ0FDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0NoSFVDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQ2hGVkM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tDUEFDO0tBQ0FDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1lDQ0NxdkI7S0RERDtnQkNDQ0M7S0RERCxJQ0NDQztJREREOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs0QkNDWUMsS0FBTyxNQUFNQSxHQUF2Qjs7MEJEREY7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztnQkNDQ0MsTURERDs7Ozs7Ozs7Ozt5QkNDQ0EsTURERDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUNBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7YUNNS0MsWUFBWUMsS0FBS0M7TUFDbkIsdUJBRGNEO01BRUQ7O09BQ0gsa0NBRE5FO01BQ007UUFFQzs2QkFMUUQ7U0FNUSx1QkFEckJHO1NBQ3FCOztTQUNmLDZCQUpSRCxJQUdHRztTQUdHLGlDQUhIQTtRQUdHO2FBREdFLFdBQU5DOztTQUNHO1VBR2lCO1dBRGJDO1dBQ2EseUJBRGJBLEdBTlJOO1dBT3FCOztXQUNWLDBCQVZiRCxJQUlFSSxPQUtLSyxVQUFTRDtXQUpQSCxTQUlGSTtXQUpKSCxRQUtHSTs7VUFFQzs7V0FQRUw7V0FBTkM7UUFTTCx5QkFkRU4sSUFJRUksT0FEQ0QsUUFFTUUsVUFGR0gsUUFFVEk7WUFVQUs7O1FBQThCLHNDQUE5QkE7UUFBSyw2QkFoQlJaO01BaUJKLDZCQWhCSUM7TUFnQkosbUNBakJJRCxPQWtCa0I7YUFFcEJhLGFBQWFDO01BQ2Ysc0NBRGVBLFdBQ0RFO01BQ1o7Z0JBRFlBO1VBR0YsSUFBSkMsRUFBSSx3QkFKR0gsRUFDREU7b0JBR05DLHFDQUVDO1VBRkcsSUFDNEMsSUFKMUNEOztRQUNFLFNBTVc7YUFFekJHO01BR0U7Ozs7T0FERjtPQUtFOzs7T0FERjtPQUtFOzs7T0FERjtPQUtFOzs7T0FERjtPQUc4QyxxQ0FoQjVDQztPQWlCc0QsMENBYnREQztPQWVDO3FCQUZERzs7VUFHVyw0QkFIWEE7T0FDUSw0QkFGUkQ7T0FNZ0MsK0JBVmhDekI7T0FXTSxnQkFETjRCLE9BSkFEO01BVkFILGVBZ0JjLGdDQURkSzs4QkFFSTthQUVOQztNQUdFOzs7O09BREY7T0FJMEIsd0NBbEMxQlQ7T0FrQ0E7TUFERixvQ0FKSVU7TUFNRCx3QkFDTTtJQUdnQjs2Q0FYdkJEO0tBV0Y7SUFETTtJQUNtQix1QkF2RXZCL0IsWUFzQkFnQixhQVVBTSxRQTRCQVM7SUFZQztVRDlFTjs7Ozs7OztJQ0FBOzs7O0lDa0JTOzs7VURsQlQiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9vZmZzZXRcbnZhciBjYW1sX2ludDY0X29mZnNldCA9IE1hdGgucG93KDIsIC0yNCk7XG5cbi8vUHJvdmlkZXM6IE1sSW50NjRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2Zmc2V0LCBjYW1sX3JhaXNlX3plcm9fZGl2aWRlXG5mdW5jdGlvbiBNbEludDY0IChsbyxtaSxoaSkge1xuICB0aGlzLmxvID0gbG8gJiAweGZmZmZmZjtcbiAgdGhpcy5taSA9IG1pICYgMHhmZmZmZmY7XG4gIHRoaXMuaGkgPSBoaSAmIDB4ZmZmZjtcbn1cbk1sSW50NjQucHJvdG90eXBlLmNhbWxfY3VzdG9tID0gXCJfalwiXG5NbEludDY0LnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gbmV3IE1sSW50NjQodGhpcy5sbyx0aGlzLm1pLHRoaXMuaGkpO1xufVxuXG5NbEludDY0LnByb3RvdHlwZS51Y29tcGFyZSA9IGZ1bmN0aW9uICh4KSB7XG4gIGlmICh0aGlzLmhpID4geC5oaSkgcmV0dXJuIDE7XG4gIGlmICh0aGlzLmhpIDwgeC5oaSkgcmV0dXJuIC0xO1xuICBpZiAodGhpcy5taSA+IHgubWkpIHJldHVybiAxO1xuICBpZiAodGhpcy5taSA8IHgubWkpIHJldHVybiAtMTtcbiAgaWYgKHRoaXMubG8gPiB4LmxvKSByZXR1cm4gMTtcbiAgaWYgKHRoaXMubG8gPCB4LmxvKSByZXR1cm4gLTE7XG4gIHJldHVybiAwO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uICh4KSB7XG4gIHZhciBoaSA9IHRoaXMuaGkgPDwgMTY7XG4gIHZhciB4aGkgPSB4LmhpIDw8IDE2O1xuICBpZiAoaGkgPiB4aGkpIHJldHVybiAxO1xuICBpZiAoaGkgPCB4aGkpIHJldHVybiAtMTtcbiAgaWYgKHRoaXMubWkgPiB4Lm1pKSByZXR1cm4gMTtcbiAgaWYgKHRoaXMubWkgPCB4Lm1pKSByZXR1cm4gLTE7XG4gIGlmICh0aGlzLmxvID4geC5sbykgcmV0dXJuIDE7XG4gIGlmICh0aGlzLmxvIDwgeC5sbykgcmV0dXJuIC0xO1xuICByZXR1cm4gMDtcbn1cbk1sSW50NjQucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGxvID0gLSB0aGlzLmxvO1xuICB2YXIgbWkgPSAtIHRoaXMubWkgKyAobG8gPj4gMjQpO1xuICB2YXIgaGkgPSAtIHRoaXMuaGkgKyAobWkgPj4gMjQpO1xuICByZXR1cm4gbmV3IE1sSW50NjQobG8sIG1pLCBoaSk7XG59XG5NbEludDY0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoeCkge1xuICB2YXIgbG8gPSB0aGlzLmxvICsgeC5sbztcbiAgdmFyIG1pID0gdGhpcy5taSArIHgubWkgKyAobG8gPj4gMjQpO1xuICB2YXIgaGkgPSB0aGlzLmhpICsgeC5oaSArIChtaSA+PiAyNCk7XG4gIHJldHVybiBuZXcgTWxJbnQ2NChsbywgbWksIGhpKTtcbn1cbk1sSW50NjQucHJvdG90eXBlLnN1YiA9IGZ1bmN0aW9uICh4KSB7XG4gIHZhciBsbyA9IHRoaXMubG8gLSB4LmxvO1xuICB2YXIgbWkgPSB0aGlzLm1pIC0geC5taSArIChsbyA+PiAyNCk7XG4gIHZhciBoaSA9IHRoaXMuaGkgLSB4LmhpICsgKG1pID4+IDI0KTtcbiAgcmV0dXJuIG5ldyBNbEludDY0KGxvLCBtaSwgaGkpO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gKHgpIHtcbiAgdmFyIGxvID0gdGhpcy5sbyAqIHgubG87XG4gIHZhciBtaSA9ICgobG8gKiBjYW1sX2ludDY0X29mZnNldCkgfCAwKSArIHRoaXMubWkgKiB4LmxvICsgdGhpcy5sbyAqIHgubWk7XG4gIHZhciBoaSA9ICgobWkgKiBjYW1sX2ludDY0X29mZnNldCkgfCAwKSArIHRoaXMuaGkgKiB4LmxvICsgdGhpcy5taSAqIHgubWkgKyB0aGlzLmxvICogeC5oaTtcbiAgcmV0dXJuIG5ldyBNbEludDY0KGxvLCBtaSwgaGkpO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUuaXNaZXJvID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gKHRoaXMubG98dGhpcy5taXx0aGlzLmhpKSA9PSAwO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUuaXNOZWcgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAodGhpcy5oaSA8PCAxNikgPCAwO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUuYW5kID0gZnVuY3Rpb24gKHgpIHtcbiAgcmV0dXJuIG5ldyBNbEludDY0KHRoaXMubG8gJiB4LmxvLCB0aGlzLm1pICYgeC5taSwgdGhpcy5oaSAmIHguaGkpO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUub3IgPSBmdW5jdGlvbiAoeCkge1xuICByZXR1cm4gbmV3IE1sSW50NjQodGhpcy5sb3x4LmxvLCB0aGlzLm1pfHgubWksIHRoaXMuaGl8eC5oaSk7XG59XG5NbEludDY0LnByb3RvdHlwZS54b3IgPSBmdW5jdGlvbiAoeCkge1xuICByZXR1cm4gbmV3IE1sSW50NjQodGhpcy5sb154LmxvLCB0aGlzLm1pXngubWksIHRoaXMuaGleeC5oaSk7XG59XG5NbEludDY0LnByb3RvdHlwZS5zaGlmdF9sZWZ0ID0gZnVuY3Rpb24gKHMpIHtcbiAgcyA9IHMgJiA2MztcbiAgaWYgKHMgPT0gMCkgcmV0dXJuIHRoaXM7XG4gIGlmIChzIDwgMjQpIHtcbiAgICByZXR1cm4gbmV3IE1sSW50NjQgKHRoaXMubG8gPDwgcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzLm1pIDw8IHMpIHwgKHRoaXMubG8gPj4gKDI0IC0gcykpLFxuICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMuaGkgPDwgcykgfCAodGhpcy5taSA+PiAoMjQgLSBzKSkpO1xuICB9XG4gIGlmIChzIDwgNDgpXG4gICAgcmV0dXJuIG5ldyBNbEludDY0ICgwLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sbyA8PCAocyAtIDI0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzLm1pIDw8IChzIC0gMjQpKSB8ICh0aGlzLmxvID4+ICg0OCAtIHMpKSk7XG4gIHJldHVybiBuZXcgTWxJbnQ2NCgwLCAwLCB0aGlzLmxvIDw8IChzIC0gNDgpKVxufVxuTWxJbnQ2NC5wcm90b3R5cGUuc2hpZnRfcmlnaHRfdW5zaWduZWQgPSBmdW5jdGlvbiAocykge1xuICBzID0gcyAmIDYzO1xuICBpZiAocyA9PSAwKSByZXR1cm4gdGhpcztcbiAgaWYgKHMgPCAyNClcbiAgICByZXR1cm4gbmV3IE1sSW50NjQgKFxuICAgICAgKHRoaXMubG8gPj4gcykgfCAodGhpcy5taSA8PCAoMjQgLSBzKSksXG4gICAgICAodGhpcy5taSA+PiBzKSB8ICh0aGlzLmhpIDw8ICgyNCAtIHMpKSxcbiAgICAgICh0aGlzLmhpID4+IHMpKTtcbiAgaWYgKHMgPCA0OClcbiAgICByZXR1cm4gbmV3IE1sSW50NjQgKFxuICAgICAgKHRoaXMubWkgPj4gKHMgLSAyNCkpIHwgKHRoaXMuaGkgPDwgKDQ4IC0gcykpLFxuICAgICAgKHRoaXMuaGkgPj4gKHMgLSAyNCkpLFxuICAgICAgMCk7XG4gIHJldHVybiBuZXcgTWxJbnQ2NCAodGhpcy5oaSA+PiAocyAtIDQ4KSwgMCwgMCk7XG59XG5NbEludDY0LnByb3RvdHlwZS5zaGlmdF9yaWdodCA9IGZ1bmN0aW9uIChzKSB7XG4gIHMgPSBzICYgNjM7XG4gIGlmIChzID09IDApIHJldHVybiB0aGlzO1xuICB2YXIgaCA9ICh0aGlzLmhpIDw8IDE2KSA+PiAxNjtcbiAgaWYgKHMgPCAyNClcbiAgICByZXR1cm4gbmV3IE1sSW50NjQgKFxuICAgICAgKHRoaXMubG8gPj4gcykgfCAodGhpcy5taSA8PCAoMjQgLSBzKSksXG4gICAgICAodGhpcy5taSA+PiBzKSB8IChoIDw8ICgyNCAtIHMpKSxcbiAgICAgICgodGhpcy5oaSA8PCAxNikgPj4gcykgPj4+IDE2KTtcbiAgdmFyIHNpZ24gPSAodGhpcy5oaSA8PCAxNikgPj4gMzE7XG4gIGlmIChzIDwgNDgpXG4gICAgcmV0dXJuIG5ldyBNbEludDY0IChcbiAgICAgICh0aGlzLm1pID4+IChzIC0gMjQpKSB8ICh0aGlzLmhpIDw8ICg0OCAtIHMpKSxcbiAgICAgICh0aGlzLmhpIDw8IDE2KSA+PiAocyAtIDI0KSA+PiAxNixcbiAgICAgIHNpZ24gJiAweGZmZmYpO1xuICByZXR1cm4gbmV3IE1sSW50NjQgKCh0aGlzLmhpIDw8IDE2KSA+PiAocyAtIDMyKSwgc2lnbiwgc2lnbik7XG59XG5NbEludDY0LnByb3RvdHlwZS5sc2wxID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmhpID0gKHRoaXMuaGkgPDwgMSkgfCAodGhpcy5taSA+PiAyMyk7XG4gIHRoaXMubWkgPSAoKHRoaXMubWkgPDwgMSkgfCAodGhpcy5sbyA+PiAyMykpICYgMHhmZmZmZmY7XG4gIHRoaXMubG8gPSAodGhpcy5sbyA8PCAxKSAmIDB4ZmZmZmZmO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUubHNyMSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5sbyA9ICgodGhpcy5sbyA+Pj4gMSkgfCAodGhpcy5taSA8PCAyMykpICYgMHhmZmZmZmY7XG4gIHRoaXMubWkgPSAoKHRoaXMubWkgPj4+IDEpIHwgKHRoaXMuaGkgPDwgMjMpKSAmIDB4ZmZmZmZmO1xuICB0aGlzLmhpID0gdGhpcy5oaSA+Pj4gMTtcbn1cbk1sSW50NjQucHJvdG90eXBlLnVkaXZtb2QgPSBmdW5jdGlvbiAoeCkge1xuICB2YXIgb2Zmc2V0ID0gMDtcbiAgdmFyIG1vZHVsdXMgPSB0aGlzLmNvcHkoKTtcbiAgdmFyIGRpdmlzb3IgPSB4LmNvcHkoKTtcbiAgdmFyIHF1b3RpZW50ID0gbmV3IE1sSW50NjQoMCwwLDApO1xuICB3aGlsZSAobW9kdWx1cy51Y29tcGFyZShkaXZpc29yKSA+IDApIHtcbiAgICBvZmZzZXQrKztcbiAgICBkaXZpc29yLmxzbDEoKTtcbiAgfVxuICB3aGlsZSAob2Zmc2V0ID49IDApIHtcbiAgICBvZmZzZXQgLS07XG4gICAgcXVvdGllbnQubHNsMSgpO1xuICAgIGlmIChtb2R1bHVzLnVjb21wYXJlKGRpdmlzb3IpID49IDApIHtcbiAgICAgIHF1b3RpZW50LmxvICsrO1xuICAgICAgbW9kdWx1cyA9IG1vZHVsdXMuc3ViKGRpdmlzb3IpO1xuICAgIH1cbiAgICBkaXZpc29yLmxzcjEoKTtcbiAgfVxuICByZXR1cm4geyBxdW90aWVudCA6IHF1b3RpZW50LCBtb2R1bHVzIDogbW9kdWx1cyB9O1xufVxuTWxJbnQ2NC5wcm90b3R5cGUuZGl2ID0gZnVuY3Rpb24gKHkpXG57XG4gIHZhciB4ID0gdGhpcztcbiAgaWYgKHkuaXNaZXJvKCkpIGNhbWxfcmFpc2VfemVyb19kaXZpZGUgKCk7XG4gIHZhciBzaWduID0geC5oaSBeIHkuaGk7XG4gIGlmICh4LmhpICYgMHg4MDAwKSB4ID0geC5uZWcoKTtcbiAgaWYgKHkuaGkgJiAweDgwMDApIHkgPSB5Lm5lZygpO1xuICB2YXIgcSA9IHgudWRpdm1vZCh5KS5xdW90aWVudDtcbiAgaWYgKHNpZ24gJiAweDgwMDApIHEgPSBxLm5lZygpO1xuICByZXR1cm4gcTtcbn1cbk1sSW50NjQucHJvdG90eXBlLm1vZCA9IGZ1bmN0aW9uICh5KVxue1xuICB2YXIgeCA9IHRoaXM7XG4gIGlmICh5LmlzWmVybygpKSBjYW1sX3JhaXNlX3plcm9fZGl2aWRlICgpO1xuICB2YXIgc2lnbiA9IHguaGk7XG4gIGlmICh4LmhpICYgMHg4MDAwKSB4ID0geC5uZWcoKTtcbiAgaWYgKHkuaGkgJiAweDgwMDApIHkgPSB5Lm5lZygpO1xuICB2YXIgciA9IHgudWRpdm1vZCh5KS5tb2R1bHVzO1xuICBpZiAoc2lnbiAmIDB4ODAwMCkgciA9IHIubmVnKCk7XG4gIHJldHVybiByO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUudG9JbnQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmxvIHwgKHRoaXMubWkgPDwgMjQpO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUudG9GbG9hdCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICgodGhpcy5oaSA8PCAxNikgKiBNYXRoLnBvdygyLCAzMikgKyB0aGlzLm1pICogTWF0aC5wb3coMiwgMjQpKSArIHRoaXMubG87XG59XG5NbEludDY0LnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gW3RoaXMuaGkgPj4gOCxcbiAgICAgICAgICB0aGlzLmhpICYgMHhmZixcbiAgICAgICAgICB0aGlzLm1pID4+IDE2LFxuICAgICAgICAgICh0aGlzLm1pID4+IDgpICYgMHhmZixcbiAgICAgICAgICB0aGlzLm1pICYgMHhmZixcbiAgICAgICAgICB0aGlzLmxvID4+IDE2LFxuICAgICAgICAgICh0aGlzLmxvID4+IDgpICYgMHhmZixcbiAgICAgICAgICB0aGlzLmxvICYgMHhmZl07XG59XG5NbEludDY0LnByb3RvdHlwZS5sbzMyID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5sbyB8ICgodGhpcy5taSAmIDB4ZmYpIDw8IDI0KTtcbn1cbk1sSW50NjQucHJvdG90eXBlLmhpMzIgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAoKHRoaXMubWkgPj4+IDgpICYgMHhmZmZmKSB8ICh0aGlzLmhpIDw8IDE2KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF91bHQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfdWx0KHgseSkgeyByZXR1cm4geC51Y29tcGFyZSh5KSA8IDA7IH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9jb21wYXJlIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2NvbXBhcmUoeCx5LCB0b3RhbCkgeyByZXR1cm4geC5jb21wYXJlKHkpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9uZWcgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfbmVnICh4KSB7IHJldHVybiB4Lm5lZygpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9hZGQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfYWRkICh4LCB5KSB7IHJldHVybiB4LmFkZCh5KSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfc3ViIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X3N1YiAoeCwgeSkgeyByZXR1cm4geC5zdWIoeSkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X211bCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZmZzZXRcbmZ1bmN0aW9uIGNhbWxfaW50NjRfbXVsKHgseSkgeyByZXR1cm4geC5tdWwoeSkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2lzX3plcm8gY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfaXNfemVybyh4KSB7IHJldHVybiAreC5pc1plcm8oKTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2lzX25lZ2F0aXZlIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2lzX25lZ2F0aXZlKHgpIHsgcmV0dXJuICt4LmlzTmVnKCk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9hbmQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfYW5kICh4LCB5KSB7IHJldHVybiB4LmFuZCh5KTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X29yIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X29yICh4LCB5KSB7IHJldHVybiB4Lm9yKHkpOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfeG9yIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X3hvciAoeCwgeSkgeyByZXR1cm4geC54b3IoeSkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3NoaWZ0X2xlZnQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfc2hpZnRfbGVmdCAoeCwgcykgeyByZXR1cm4geC5zaGlmdF9sZWZ0KHMpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9zaGlmdF9yaWdodF91bnNpZ25lZCBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9zaGlmdF9yaWdodF91bnNpZ25lZCAoeCwgcykgeyByZXR1cm4geC5zaGlmdF9yaWdodF91bnNpZ25lZChzKSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfc2hpZnRfcmlnaHQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfc2hpZnRfcmlnaHQgKHgsIHMpIHsgcmV0dXJuIHguc2hpZnRfcmlnaHQocykgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2RpdiBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9kaXYgKHgsIHkpIHsgcmV0dXJuIHguZGl2KHkpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9tb2QgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfbW9kICh4LCB5KSB7IHJldHVybiB4Lm1vZCh5KSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfb2ZfaW50MzIgY29uc3Rcbi8vUmVxdWlyZXM6IE1sSW50NjRcbmZ1bmN0aW9uIGNhbWxfaW50NjRfb2ZfaW50MzIgKHgpIHtcbiAgcmV0dXJuIG5ldyBNbEludDY0KHggJiAweGZmZmZmZiwgKHggPj4gMjQpICYgMHhmZmZmZmYsICh4ID4+IDMxKSAmIDB4ZmZmZilcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF90b19pbnQzMiBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF90b19pbnQzMiAoeCkgeyByZXR1cm4geC50b0ludCgpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF90b19mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF90b19mbG9hdCAoeCkgeyByZXR1cm4geC50b0Zsb2F0ICgpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9vZl9mbG9hdCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZmZzZXQsIE1sSW50NjRcbmZ1bmN0aW9uIGNhbWxfaW50NjRfb2ZfZmxvYXQgKHgpIHtcbiAgaWYgKHggPCAwKSB4ID0gTWF0aC5jZWlsKHgpO1xuICByZXR1cm4gbmV3IE1sSW50NjQoXG4gICAgeCAmIDB4ZmZmZmZmLFxuICAgIE1hdGguZmxvb3IoeCAqIGNhbWxfaW50NjRfb2Zmc2V0KSAmIDB4ZmZmZmZmLFxuICAgIE1hdGguZmxvb3IoeCAqIGNhbWxfaW50NjRfb2Zmc2V0ICogY2FtbF9pbnQ2NF9vZmZzZXQpICYgMHhmZmZmKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9mb3JtYXQgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfcGFyc2VfZm9ybWF0LCBjYW1sX2ZpbmlzaF9mb3JtYXR0aW5nXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2lzX25lZ2F0aXZlLCBjYW1sX2ludDY0X25lZ1xuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZl9pbnQzMiwgY2FtbF9pbnQ2NF90b19pbnQzMlxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9pc196ZXJvLCBjYW1sX3N0cl9yZXBlYXRcbmZ1bmN0aW9uIGNhbWxfaW50NjRfZm9ybWF0IChmbXQsIHgpIHtcbiAgdmFyIGYgPSBjYW1sX3BhcnNlX2Zvcm1hdChmbXQpO1xuICBpZiAoZi5zaWduZWRjb252ICYmIGNhbWxfaW50NjRfaXNfbmVnYXRpdmUoeCkpIHtcbiAgICBmLnNpZ24gPSAtMTsgeCA9IGNhbWxfaW50NjRfbmVnKHgpO1xuICB9XG4gIHZhciBidWZmZXIgPSBcIlwiO1xuICB2YXIgd2Jhc2UgPSBjYW1sX2ludDY0X29mX2ludDMyKGYuYmFzZSk7XG4gIHZhciBjdnRibCA9IFwiMDEyMzQ1Njc4OWFiY2RlZlwiO1xuICBkbyB7XG4gICAgdmFyIHAgPSB4LnVkaXZtb2Qod2Jhc2UpO1xuICAgIHggPSBwLnF1b3RpZW50O1xuICAgIGJ1ZmZlciA9IGN2dGJsLmNoYXJBdChjYW1sX2ludDY0X3RvX2ludDMyKHAubW9kdWx1cykpICsgYnVmZmVyO1xuICB9IHdoaWxlICghIGNhbWxfaW50NjRfaXNfemVybyh4KSk7XG4gIGlmIChmLnByZWMgPj0gMCkge1xuICAgIGYuZmlsbGVyID0gJyAnO1xuICAgIHZhciBuID0gZi5wcmVjIC0gYnVmZmVyLmxlbmd0aDtcbiAgICBpZiAobiA+IDApIGJ1ZmZlciA9IGNhbWxfc3RyX3JlcGVhdCAobiwgJzAnKSArIGJ1ZmZlcjtcbiAgfVxuICByZXR1cm4gY2FtbF9maW5pc2hfZm9ybWF0dGluZyhmLCBidWZmZXIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X29mX3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9wYXJzZV9zaWduX2FuZF9iYXNlLCBjYW1sX2ZhaWx3aXRoLCBjYW1sX3BhcnNlX2RpZ2l0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2ludDMyLCBjYW1sX2ludDY0X3VsdFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9hZGQsIGNhbWxfaW50NjRfbXVsLCBjYW1sX2ludDY0X25lZ1xuLy9SZXF1aXJlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoLGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQsIE1sSW50NjRcbmZ1bmN0aW9uIGNhbWxfaW50NjRfb2Zfc3RyaW5nKHMpIHtcbiAgdmFyIHIgPSBjYW1sX3BhcnNlX3NpZ25fYW5kX2Jhc2UgKHMpO1xuICB2YXIgaSA9IHJbMF0sIHNpZ24gPSByWzFdLCBiYXNlID0gclsyXTtcbiAgdmFyIGJhc2U2NCA9IGNhbWxfaW50NjRfb2ZfaW50MzIoYmFzZSk7XG4gIHZhciB0aHJlc2hvbGQgPVxuICAgICAgbmV3IE1sSW50NjQoMHhmZmZmZmYsIDB4ZmZmZmZmZiwgMHhmZmZmKS51ZGl2bW9kKGJhc2U2NCkucXVvdGllbnQ7XG4gIHZhciBjID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldChzLCBpKTtcbiAgdmFyIGQgPSBjYW1sX3BhcnNlX2RpZ2l0KGMpO1xuICBpZiAoZCA8IDAgfHwgZCA+PSBiYXNlKSBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgdmFyIHJlcyA9IGNhbWxfaW50NjRfb2ZfaW50MzIoZCk7XG4gIGZvciAoOzspIHtcbiAgICBpKys7XG4gICAgYyA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQocywgaSk7XG4gICAgaWYgKGMgPT0gOTUpIGNvbnRpbnVlO1xuICAgIGQgPSBjYW1sX3BhcnNlX2RpZ2l0KGMpO1xuICAgIGlmIChkIDwgMCB8fCBkID49IGJhc2UpIGJyZWFrO1xuICAgIC8qIERldGVjdCBvdmVyZmxvdyBpbiBtdWx0aXBsaWNhdGlvbiBiYXNlICogcmVzICovXG4gICAgaWYgKGNhbWxfaW50NjRfdWx0KHRocmVzaG9sZCwgcmVzKSkgY2FtbF9mYWlsd2l0aChcImludF9vZl9zdHJpbmdcIik7XG4gICAgZCA9IGNhbWxfaW50NjRfb2ZfaW50MzIoZCk7XG4gICAgcmVzID0gY2FtbF9pbnQ2NF9hZGQoY2FtbF9pbnQ2NF9tdWwoYmFzZTY0LCByZXMpLCBkKTtcbiAgICAvKiBEZXRlY3Qgb3ZlcmZsb3cgaW4gYWRkaXRpb24gKGJhc2UgKiByZXMpICsgZCAqL1xuICAgIGlmIChjYW1sX2ludDY0X3VsdChyZXMsIGQpKSBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgfVxuICBpZiAoaSAhPSBjYW1sX21sX3N0cmluZ19sZW5ndGgocykpIGNhbWxfZmFpbHdpdGgoXCJpbnRfb2Zfc3RyaW5nXCIpO1xuICBpZiAoYmFzZSA9PSAxMCAmJiBjYW1sX2ludDY0X3VsdChuZXcgTWxJbnQ2NCgwLCAwLCAweDgwMDApLCByZXMpKVxuICAgIGNhbWxfZmFpbHdpdGgoXCJpbnRfb2Zfc3RyaW5nXCIpO1xuICBpZiAoc2lnbiA8IDApIHJlcyA9IGNhbWxfaW50NjRfbmVnKHJlcyk7XG4gIHJldHVybiByZXM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpIGNvbnN0XG4vL1JlcXVpcmVzOiBNbEludDY0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2NyZWF0ZV9sb19taV9oaShsbywgbWksIGhpKXtcbiAgcmV0dXJuIG5ldyBNbEludDY0KGxvLCBtaSwgaGkpXG59XG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2NyZWF0ZV9sb19oaSBjb25zdFxuLy9SZXF1aXJlczogTWxJbnQ2NFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9jcmVhdGVfbG9faGkobG8sIGhpKXtcbiAgcmV0dXJuIG5ldyBNbEludDY0IChcbiAgICBsbyAmIDB4ZmZmZmZmLFxuICAgICgobG8gPj4+IDI0KSAmIDB4ZmYpIHwgKChoaSAmIDB4ZmZmZikgPDwgOCksXG4gICAgKGhpID4+PiAxNikgJiAweGZmZmYpO1xufVxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9sbzMyIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2xvMzIodil7IHJldHVybiB2LmxvMzIoKSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfaGkzMiBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9oaTMyKHYpeyByZXR1cm4gdi5oaTMyKCkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X29mX2J5dGVzIGNvbnN0XG4vL1JlcXVpcmVzOiBNbEludDY0XG5mdW5jdGlvbiBjYW1sX2ludDY0X29mX2J5dGVzKGEpIHtcbiAgcmV0dXJuIG5ldyBNbEludDY0KGFbN10gPDwgMCB8IChhWzZdIDw8IDgpIHwgKGFbNV0gPDwgMTYpLFxuICAgICAgICAgICAgICAgICAgICAgYVs0XSA8PCAwIHwgKGFbM10gPDwgOCkgfCAoYVsyXSA8PCAxNiksXG4gICAgICAgICAgICAgICAgICAgICBhWzFdIDw8IDAgfCAoYVswXSA8PCA4KSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3RvX2J5dGVzIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X3RvX2J5dGVzKHgpIHsgcmV0dXJuIHgudG9BcnJheSgpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9oYXNoIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2hhc2godil7XG4gIHJldHVybiAodi5sbzMyKCkpIF4gKHYuaGkzMigpKVxufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwLTIwMTQgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8gQW4gT0NhbWwgc3RyaW5nIGlzIGFuIG9iamVjdCB3aXRoIHRocmVlIGZpZWxkczpcbi8vIC0gdGFnICd0J1xuLy8gLSBsZW5ndGggJ2wnXG4vLyAtIGNvbnRlbnRzICdjJ1xuLy9cbi8vIFRoZSBjb250ZW50cyBvZiB0aGUgc3RyaW5nIGNhbiBiZSBlaXRoZXIgYSBKYXZhU2NyaXB0IGFycmF5IG9yXG4vLyBhIEphdmFTY3JpcHQgc3RyaW5nLiBUaGUgbGVuZ3RoIG9mIHRoaXMgc3RyaW5nIGNhbiBiZSBsZXNzIHRoYW4gdGhlXG4vLyBsZW5ndGggb2YgdGhlIE9DYW1sIHN0cmluZy4gSW4gdGhpcyBjYXNlLCByZW1haW5pbmcgYnl0ZXMgYXJlXG4vLyBhc3N1bWVkIHRvIGJlIHplcm9lcy4gQXJyYXlzIGFyZSBtdXRhYmxlIGJ1dCBjb25zdW1lcyBtb3JlIG1lbW9yeVxuLy8gdGhhbiBzdHJpbmdzLiBBIGNvbW1vbiBwYXR0ZXJuIGlzIHRvIHN0YXJ0IGZyb20gYW4gZW1wdHkgc3RyaW5nIGFuZFxuLy8gcHJvZ3Jlc3NpdmVseSBmaWxsIGl0IGZyb20gdGhlIHN0YXJ0LiBQYXJ0aWFsIHN0cmluZ3MgbWFrZXMgaXRcbi8vIHBvc3NpYmxlIHRvIGltcGxlbWVudCB0aGlzIGVmZmljaWVudGx5LlxuLy9cbi8vIFdoZW4gY29udmVydGluZyB0byBhbmQgZnJvbSBVVEYtMTYsIHdlIGtlZXAgdHJhY2sgb2Ygd2hldGhlciB0aGVcbi8vIHN0cmluZyBpcyBjb21wb3NlZCBvbmx5IG9mIEFTQ0lJIGNoYXJhY3RlcnMgKGluIHdoaWNoIGNhc2UsIG5vXG4vLyBjb252ZXJzaW9uIG5lZWRzIHRvIGJlIHBlcmZvcm1lZCkgb3Igbm90LlxuLy9cbi8vIFRoZSBzdHJpbmcgdGFnIGNhbiB0aHVzIHRha2UgdGhlIGZvbGxvd2luZyB2YWx1ZXM6XG4vLyAgIGZ1bGwgc3RyaW5nICAgICBCWVRFIHwgVU5LTk9XTjogICAgICAwXG4vLyAgICAgICAgICAgICAgICAgICBCWVRFIHwgQVNDSUk6ICAgICAgICA5XG4vLyAgICAgICAgICAgICAgICAgICBCWVRFIHwgTk9UX0FTQ0lJOiAgICA4XG4vLyAgIHN0cmluZyBwcmVmaXggICBQQVJUSUFMOiAgICAgICAgICAgICAyXG4vLyAgIGFycmF5ICAgICAgICAgICBBUlJBWTogICAgICAgICAgICAgICA0XG4vL1xuLy8gT25lIGNhbiB1c2UgYml0IG1hc2tpbmcgdG8gZGlzY3JpbWluYXRlIHRoZXNlIGRpZmZlcmVudCBjYXNlczpcbi8vICAga25vd25fZW5jb2RpbmcoeCkgPSB4Jjhcbi8vICAgaXNfYXNjaWkoeCkgPSAgICAgICB4JjFcbi8vICAga2luZCh4KSA9ICAgICAgICAgICB4JjZcblxuLy9Qcm92aWRlczogY2FtbF9zdHJfcmVwZWF0XG5mdW5jdGlvbiBjYW1sX3N0cl9yZXBlYXQobiwgcykge1xuICBpZihuID09IDApIHJldHVybiBcIlwiO1xuICBpZiAocy5yZXBlYXQpIHtyZXR1cm4gcy5yZXBlYXQobik7fSAvLyBFQ01Bc2NyaXB0IDYgYW5kIEZpcmVmb3ggMjQrXG4gIHZhciByID0gXCJcIiwgbCA9IDA7XG4gIGZvcig7Oykge1xuICAgIGlmIChuICYgMSkgciArPSBzO1xuICAgIG4gPj49IDE7XG4gICAgaWYgKG4gPT0gMCkgcmV0dXJuIHI7XG4gICAgcyArPSBzO1xuICAgIGwrKztcbiAgICBpZiAobCA9PSA5KSB7XG4gICAgICBzLnNsaWNlKDAsMSk7IC8vIGZsYXR0ZW4gdGhlIHN0cmluZ1xuICAgICAgLy8gdGhlbiwgdGhlIGZsYXR0ZW5pbmcgb2YgdGhlIHdob2xlIHN0cmluZyB3aWxsIGJlIGZhc3RlcixcbiAgICAgIC8vIGFzIGl0IHdpbGwgYmUgY29tcG9zZWQgb2YgbGFyZ2VyIHBpZWNlc1xuICAgIH1cbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N1YmFycmF5X3RvX2pzYnl0ZXNcbi8vV2Vha2RlZlxuLy8gUHJlIEVDTUFTY3JpcHQgNSwgW2FwcGx5XSB3b3VsZCBub3Qgc3VwcG9ydCBhcnJheS1saWtlIG9iamVjdC5cbi8vIEluIHN1Y2ggc2V0dXAsIFR5cGVkX2FycmF5IHdvdWxkIGJlIGltcGxlbWVudGVkIGFzIHBvbHlmaWxsLCBhbmQgW2YuYXBwbHldIHdvdWxkXG4vLyBmYWlsIGhlcmUuIE1hcmsgdGhlIHByaW1pdGl2ZSBhcyBXZWFrZGVmLCBzbyB0aGF0IHBlb3BsZSBjYW4gb3ZlcnJpZGUgaXQgZWFzaWx5LlxuZnVuY3Rpb24gY2FtbF9zdWJhcnJheV90b19qc2J5dGVzIChhLCBpLCBsZW4pIHtcbiAgdmFyIGYgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuICBpZiAoaSA9PSAwICYmIGxlbiA8PSA0MDk2ICYmIGxlbiA9PSBhLmxlbmd0aCkgcmV0dXJuIGYuYXBwbHkgKG51bGwsIGEpO1xuICB2YXIgcyA9IFwiXCI7XG4gIGZvciAoOyAwIDwgbGVuOyBpICs9IDEwMjQsbGVuLT0xMDI0KVxuICAgIHMgKz0gZi5hcHBseSAobnVsbCwgYS5zbGljZShpLGkgKyBNYXRoLm1pbihsZW4sIDEwMjQpKSk7XG4gIHJldHVybiBzO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3V0Zjhfb2ZfdXRmMTZcbmZ1bmN0aW9uIGNhbWxfdXRmOF9vZl91dGYxNihzKSB7XG4gIGZvciAodmFyIGIgPSBcIlwiLCB0ID0gYiwgYywgZCwgaSA9IDAsIGwgPSBzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGMgPSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGMgPCAweDgwKSB7XG4gICAgICBmb3IgKHZhciBqID0gaSArIDE7IChqIDwgbCkgJiYgKGMgPSBzLmNoYXJDb2RlQXQoaikpIDwgMHg4MDsgaisrKTtcbiAgICAgIGlmIChqIC0gaSA+IDUxMikgeyB0LnN1YnN0cigwLCAxKTsgYiArPSB0OyB0ID0gXCJcIjsgYiArPSBzLnNsaWNlKGksIGopIH1cbiAgICAgIGVsc2UgdCArPSBzLnNsaWNlKGksIGopO1xuICAgICAgaWYgKGogPT0gbCkgYnJlYWs7XG4gICAgICBpID0gajtcbiAgICB9XG4gICAgaWYgKGMgPCAweDgwMCkge1xuICAgICAgdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4YzAgfCAoYyA+PiA2KSk7XG4gICAgICB0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHg4MCB8IChjICYgMHgzZikpO1xuICAgIH0gZWxzZSBpZiAoYyA8IDB4ZDgwMCB8fCBjID49IDB4ZGZmZikge1xuICAgICAgdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZTAgfCAoYyA+PiAxMiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg4MCB8ICgoYyA+PiA2KSAmIDB4M2YpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4ODAgfCAoYyAmIDB4M2YpKTtcbiAgICB9IGVsc2UgaWYgKGMgPj0gMHhkYmZmIHx8IGkgKyAxID09IGwgfHxcbiAgICAgICAgICAgICAgIChkID0gcy5jaGFyQ29kZUF0KGkgKyAxKSkgPCAweGRjMDAgfHwgZCA+IDB4ZGZmZikge1xuICAgICAgLy8gVW5tYXRjaGVkIHN1cnJvZ2F0ZSBwYWlyLCByZXBsYWNlZCBieSBcXHVmZmZkIChyZXBsYWNlbWVudCBjaGFyYWN0ZXIpXG4gICAgICB0ICs9IFwiXFx4ZWZcXHhiZlxceGJkXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGkrKztcbiAgICAgIGMgPSAoYyA8PCAxMCkgKyBkIC0gMHgzNWZkYzAwO1xuICAgICAgdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZjAgfCAoYyA+PiAxOCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg4MCB8ICgoYyA+PiAxMikgJiAweDNmKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDgwIHwgKChjID4+IDYpICYgMHgzZiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg4MCB8IChjICYgMHgzZikpO1xuICAgIH1cbiAgICBpZiAodC5sZW5ndGggPiAxMDI0KSB7dC5zdWJzdHIoMCwgMSk7IGIgKz0gdDsgdCA9IFwiXCI7fVxuICB9XG4gIHJldHVybiBiK3Q7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdXRmMTZfb2ZfdXRmOFxuZnVuY3Rpb24gY2FtbF91dGYxNl9vZl91dGY4KHMpIHtcbiAgZm9yICh2YXIgYiA9IFwiXCIsIHQgPSBcIlwiLCBjLCBjMSwgYzIsIHYsIGkgPSAwLCBsID0gcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBjMSA9IHMuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoYzEgPCAweDgwKSB7XG4gICAgICBmb3IgKHZhciBqID0gaSArIDE7IChqIDwgbCkgJiYgKGMxID0gcy5jaGFyQ29kZUF0KGopKSA8IDB4ODA7IGorKyk7XG4gICAgICBpZiAoaiAtIGkgPiA1MTIpIHsgdC5zdWJzdHIoMCwgMSk7IGIgKz0gdDsgdCA9IFwiXCI7IGIgKz0gcy5zbGljZShpLCBqKSB9XG4gICAgICBlbHNlIHQgKz0gcy5zbGljZShpLCBqKTtcbiAgICAgIGlmIChqID09IGwpIGJyZWFrO1xuICAgICAgaSA9IGo7XG4gICAgfVxuICAgIHYgPSAxO1xuICAgIGlmICgoKytpIDwgbCkgJiYgKCgoYzIgPSBzLmNoYXJDb2RlQXQoaSkpICYgLTY0KSA9PSAxMjgpKSB7XG4gICAgICBjID0gYzIgKyAoYzEgPDwgNik7XG4gICAgICBpZiAoYzEgPCAweGUwKSB7XG4gICAgICAgIHYgPSBjIC0gMHgzMDgwO1xuICAgICAgICBpZiAodiA8IDB4ODApIHYgPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdiA9IDI7XG4gICAgICAgIGlmICgoKytpIDwgbCkgJiYgKCgoYzIgPSBzLmNoYXJDb2RlQXQoaSkpICYgLTY0KSA9PSAxMjgpKSB7XG4gICAgICAgICAgYyA9IGMyICsgKGMgPDwgNik7XG4gICAgICAgICAgaWYgKGMxIDwgMHhmMCkge1xuICAgICAgICAgICAgdiA9IGMgLSAweGUyMDgwO1xuICAgICAgICAgICAgaWYgKCh2IDwgMHg4MDApIHx8ICgodiA+PSAweGQ3ZmYpICYmICh2IDwgMHhlMDAwKSkpIHYgPSAyO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2ID0gMztcbiAgICAgICAgICAgIGlmICgoKytpIDwgbCkgJiYgKCgoYzIgPSBzLmNoYXJDb2RlQXQoaSkpICYgLTY0KSA9PSAxMjgpICYmXG4gICAgICAgICAgICAgICAgKGMxIDwgMHhmNSkpIHtcbiAgICAgICAgICAgICAgdiA9IGMyIC0gMHgzYzgyMDgwICsgKGMgPDwgNik7XG4gICAgICAgICAgICAgIGlmICh2IDwgMHgxMDAwMCB8fCB2ID4gMHgxMGZmZmYpIHYgPSAzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAodiA8IDQpIHsgLy8gSW52YWxpZCBzZXF1ZW5jZVxuICAgICAgaSAtPSB2O1xuICAgICAgdCArPSBcIlxcdWZmZmRcIjtcbiAgICB9IGVsc2UgaWYgKHYgPiAweGZmZmYpXG4gICAgICB0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhkN2MwICsgKHYgPj4gMTApLCAweGRjMDAgKyAodiAmIDB4M0ZGKSlcbiAgICBlbHNlXG4gICAgICB0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodik7XG4gICAgaWYgKHQubGVuZ3RoID4gMTAyNCkge3Quc3Vic3RyKDAsIDEpOyBiICs9IHQ7IHQgPSBcIlwiO31cbiAgfVxuICByZXR1cm4gYit0O1xufVxuXG4vL1Byb3ZpZGVzOiBqc29vX2lzX2FzY2lpXG5mdW5jdGlvbiBqc29vX2lzX2FzY2lpIChzKSB7XG4gIC8vIFRoZSByZWd1bGFyIGV4cHJlc3Npb24gZ2V0cyBiZXR0ZXIgYXQgYXJvdW5kIHRoaXMgcG9pbnQgZm9yIGFsbCBicm93c2Vyc1xuICBpZiAocy5sZW5ndGggPCAyNCkge1xuICAgIC8vIFNwaWRlcm1vbmtleSBnZXRzIG11Y2ggc2xvd2VyIHdoZW4gcy5sZW5ndGggPj0gMjQgKG9uIDY0IGJpdCBhcmNocylcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHMubGVuZ3RoOyBpKyspIGlmIChzLmNoYXJDb2RlQXQoaSkgPiAxMjcpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlXG4gICAgcmV0dXJuICEvW15cXHgwMC1cXHg3Zl0vLnRlc3Qocyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfdW5zYWZlX2dldCBtdXRhYmxlXG5mdW5jdGlvbiBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQgKHMsIGkpIHtcbiAgc3dpdGNoIChzLnQgJiA2KSB7XG4gIGRlZmF1bHQ6IC8qIFBBUlRJQUwgKi9cbiAgICBpZiAoaSA+PSBzLmMubGVuZ3RoKSByZXR1cm4gMDtcbiAgY2FzZSAwOiAvKiBCWVRFUyAqL1xuICAgIHJldHVybiBzLmMuY2hhckNvZGVBdChpKTtcbiAgY2FzZSA0OiAvKiBBUlJBWSAqL1xuICAgIHJldHVybiBzLmNbaV1cbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX3Vuc2FmZV9zZXRcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9ieXRlc190b19hcnJheVxuZnVuY3Rpb24gY2FtbF9ieXRlc191bnNhZmVfc2V0IChzLCBpLCBjKSB7XG4gIC8vIFRoZSBPQ2FtbCBjb21waWxlciB1c2VzIENoYXIudW5zYWZlX2NociBvbiBpbnRlZ2VycyBsYXJnZXIgdGhhbiAyNTUhXG4gIGMgJj0gMHhmZjtcbiAgaWYgKHMudCAhPSA0IC8qIEFSUkFZICovKSB7XG4gICAgaWYgKGkgPT0gcy5jLmxlbmd0aCkge1xuICAgICAgcy5jICs9IFN0cmluZy5mcm9tQ2hhckNvZGUgKGMpO1xuICAgICAgaWYgKGkgKyAxID09IHMubCkgcy50ID0gMDsgLypCWVRFUyB8IFVOS09XTiovXG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5IChzKTtcbiAgfVxuICBzLmNbaV0gPSBjO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfYm91bmRfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IgKCkge1xuICBjYW1sX2ludmFsaWRfYXJndW1lbnQgKFwiaW5kZXggb3V0IG9mIGJvdW5kc1wiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yICgpIHtcbiAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50IChcImluZGV4IG91dCBvZiBib3VuZHNcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2dldFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IsIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9zdHJpbmdfZ2V0IChzLCBpKSB7XG4gIGlmIChpID4+PiAwID49IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSkgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IoKTtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19nZXQxNlxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfdW5zYWZlX2dldCwgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9zdHJpbmdfZ2V0MTYocyxpKSB7XG4gIGlmIChpID4+PiAwID49IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSAtIDEpIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yKCk7XG4gIHZhciBiMSA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkpLFxuICAgICAgYjIgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpICsgMSk7XG4gIHJldHVybiAoYjIgPDwgOCB8IGIxKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19nZXQxNlxuLy9SZXF1aXJlczogY2FtbF9ieXRlc191bnNhZmVfZ2V0LCBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2dldDE2KHMsaSkge1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwgLSAxKSBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yKCk7XG4gIHZhciBiMSA9IGNhbWxfYnl0ZXNfdW5zYWZlX2dldCAocywgaSksXG4gICAgICBiMiA9IGNhbWxfYnl0ZXNfdW5zYWZlX2dldCAocywgaSArIDEpO1xuICByZXR1cm4gKGIyIDw8IDggfCBiMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2dldDMyXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0LCBjYW1sX3N0cmluZ19ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19nZXQzMihzLGkpIHtcbiAgaWYgKGkgPj4+IDAgPj0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpIC0gMykgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGIxID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSksXG4gICAgICBiMiA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkgKyAxKSxcbiAgICAgIGIzID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSArIDIpLFxuICAgICAgYjQgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpICsgMyk7XG4gIHJldHVybiAoYjQgPDwgMjQgfCBiMyA8PCAxNiB8IGIyIDw8IDggfCBiMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfZ2V0MzJcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfdW5zYWZlX2dldCwgY2FtbF9ieXRlc19ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9ieXRlc19nZXQzMihzLGkpIHtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sIC0gMykgY2FtbF9ieXRlc19ib3VuZF9lcnJvcigpO1xuICB2YXIgYjEgPSBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQgKHMsIGkpLFxuICAgICAgYjIgPSBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQgKHMsIGkgKyAxKSxcbiAgICAgIGIzID0gY2FtbF9ieXRlc191bnNhZmVfZ2V0IChzLCBpICsgMiksXG4gICAgICBiNCA9IGNhbWxfYnl0ZXNfdW5zYWZlX2dldCAocywgaSArIDMpO1xuICByZXR1cm4gKGI0IDw8IDI0IHwgYjMgPDwgMTYgfCBiMiA8PCA4IHwgYjEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19nZXQ2NFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfdW5zYWZlX2dldCwgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9zdHJpbmdfZ2V0NjQocyxpKSB7XG4gIGlmIChpID4+PiAwID49IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSAtIDcpIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yKCk7XG4gIHZhciBhID0gbmV3IEFycmF5KDgpO1xuICBmb3IodmFyIGogPSAwOyBqIDwgODsgaisrKXtcbiAgICBhWzcgLSBqXSA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkgKyBqKTtcbiAgfVxuICByZXR1cm4gY2FtbF9pbnQ2NF9vZl9ieXRlcyhhKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19nZXQ2NFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc191bnNhZmVfZ2V0LCBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2dldDY0KHMsaSkge1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwgLSA3KSBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yKCk7XG4gIHZhciBhID0gbmV3IEFycmF5KDgpO1xuICBmb3IodmFyIGogPSAwOyBqIDwgODsgaisrKXtcbiAgICBhWzcgLSBqXSA9IGNhbWxfYnl0ZXNfdW5zYWZlX2dldCAocywgaSArIGopO1xuICB9XG4gIHJldHVybiBjYW1sX2ludDY0X29mX2J5dGVzKGEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2dldFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19ib3VuZF9lcnJvciwgY2FtbF9ieXRlc191bnNhZmVfZ2V0XG5mdW5jdGlvbiBjYW1sX2J5dGVzX2dldCAocywgaSkge1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwpIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IoKTtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfdW5zYWZlX2dldCAocywgaSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3NldFxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19zZXQgKHMsIGksIGMpIHtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfc3RyaW5nX3NldFwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ191bnNhZmVfc2V0LCBjYW1sX3N0cmluZ19ib3VuZF9lcnJvclxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfc2V0IChzLCBpLCBjKSB7XG4gIGlmIChpID4+PiAwID49IHMubCkgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IoKTtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX3Vuc2FmZV9zZXQgKHMsIGksIGMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX3NldDE2XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yLCBjYW1sX2J5dGVzX3Vuc2FmZV9zZXRcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfc2V0MTYocyxpLGkxNil7XG4gIGlmIChpID4+PiAwID49IHMubCAtIDEpIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGIyID0gMHhGRiAmIGkxNiA+PiA4LFxuICAgICAgYjEgPSAweEZGICYgaTE2O1xuICBjYW1sX2J5dGVzX3Vuc2FmZV9zZXQgKHMsIGkgKyAwLCBiMSk7XG4gIGNhbWxfYnl0ZXNfdW5zYWZlX3NldCAocywgaSArIDEsIGIyKTtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfc2V0MTZcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfc2V0MTYocyxpLGkxNil7XG4gICAgY2FtbF9mYWlsd2l0aChcImNhbWxfc3RyaW5nX3NldDE2XCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19zZXQxNlxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19zZXQxNlxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfc2V0MTYocyxpLGkxNil7XG4gIHJldHVybiBjYW1sX2J5dGVzX3NldDE2KHMsaSxpMTYpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX3NldDMyXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yLCBjYW1sX2J5dGVzX3Vuc2FmZV9zZXRcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfc2V0MzIocyxpLGkzMil7XG4gIGlmIChpID4+PiAwID49IHMubCAtIDMpIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGI0ID0gMHhGRiAmIGkzMiA+PiAyNCxcbiAgICAgIGIzID0gMHhGRiAmIGkzMiA+PiAxNixcbiAgICAgIGIyID0gMHhGRiAmIGkzMiA+PiA4LFxuICAgICAgYjEgPSAweEZGICYgaTMyO1xuICBjYW1sX2J5dGVzX3Vuc2FmZV9zZXQgKHMsIGkgKyAwLCBiMSk7XG4gIGNhbWxfYnl0ZXNfdW5zYWZlX3NldCAocywgaSArIDEsIGIyKTtcbiAgY2FtbF9ieXRlc191bnNhZmVfc2V0IChzLCBpICsgMiwgYjMpO1xuICBjYW1sX2J5dGVzX3Vuc2FmZV9zZXQgKHMsIGkgKyAzLCBiNCk7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3NldDMyXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3NldDMyKHMsaSxpMzIpe1xuICAgIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3N0cmluZ19zZXQzMlwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfc2V0MzJcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfc2V0MzJcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3NldDMyKHMsaSxpMzIpe1xuICByZXR1cm4gY2FtbF9ieXRlc19zZXQzMihzLGksaTMyKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19zZXQ2NFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19ib3VuZF9lcnJvciwgY2FtbF9ieXRlc191bnNhZmVfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3RvX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX3NldDY0KHMsaSxpNjQpe1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwgLSA3KSBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yKCk7XG4gIHZhciBhID0gY2FtbF9pbnQ2NF90b19ieXRlcyhpNjQpO1xuICBmb3IodmFyIGogPSAwOyBqIDwgODsgaisrKSB7XG4gICAgY2FtbF9ieXRlc191bnNhZmVfc2V0IChzLCBpICsgNyAtIGosIGFbal0pO1xuICB9XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3NldDY0XG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3NldDY0KHMsaSxpNjQpe1xuICAgIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3N0cmluZ19zZXQ2NFwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfc2V0NjRcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfc2V0NjRcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3NldDY0KHMsaSxpNjQpe1xuICByZXR1cm4gY2FtbF9ieXRlc19zZXQ2NChzLGksaTY0KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19zZXRcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IsIGNhbWxfYnl0ZXNfdW5zYWZlX3NldFxuZnVuY3Rpb24gY2FtbF9ieXRlc19zZXQgKHMsIGksIGMpIHtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sKSBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yKCk7XG4gIHJldHVybiBjYW1sX2J5dGVzX3Vuc2FmZV9zZXQgKHMsIGksIGMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX29mX3V0ZjE2X2pzc3RyaW5nXG4vL1JlcXVpcmVzOiBqc29vX2lzX2FzY2lpLCBjYW1sX3V0Zjhfb2ZfdXRmMTYsIE1sQnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfb2ZfdXRmMTZfanNzdHJpbmcgKHMpIHtcbiAgdmFyIHRhZyA9IDkgLyogQllURVMgfCBBU0NJSSAqLztcbiAgaWYgKCFqc29vX2lzX2FzY2lpKHMpKVxuICAgIHRhZyA9IDggLyogQllURVMgfCBOT1RfQVNDSUkgKi8sIHMgPSBjYW1sX3V0Zjhfb2ZfdXRmMTYocyk7XG4gIHJldHVybiBuZXcgTWxCeXRlcyh0YWcsIHMsIHMubGVuZ3RoKTtcbn1cblxuXG4vL1Byb3ZpZGVzOiBNbEJ5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzLCBqc29vX2lzX2FzY2lpLCBjYW1sX3V0ZjE2X29mX3V0ZjhcbmZ1bmN0aW9uIE1sQnl0ZXMgKHRhZywgY29udGVudHMsIGxlbmd0aCkge1xuICB0aGlzLnQ9dGFnOyB0aGlzLmM9Y29udGVudHM7IHRoaXMubD1sZW5ndGg7XG59XG5NbEJ5dGVzLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCl7XG4gIHN3aXRjaCAodGhpcy50KSB7XG4gIGNhc2UgOTogLypCWVRFUyB8IEFTQ0lJKi9cbiAgICByZXR1cm4gdGhpcy5jO1xuICBkZWZhdWx0OlxuICAgIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXModGhpcyk7XG4gIGNhc2UgMDogLypCWVRFUyB8IFVOS09XTiovXG4gICAgaWYgKGpzb29faXNfYXNjaWkodGhpcy5jKSkge1xuICAgICAgdGhpcy50ID0gOTsgLypCWVRFUyB8IEFTQ0lJKi9cbiAgICAgIHJldHVybiB0aGlzLmM7XG4gICAgfVxuICAgIHRoaXMudCA9IDg7IC8qQllURVMgfCBOT1RfQVNDSUkqL1xuICBjYXNlIDg6IC8qQllURVMgfCBOT1RfQVNDSUkqL1xuICAgIHJldHVybiB0aGlzLmM7XG4gIH1cbn07XG5NbEJ5dGVzLnByb3RvdHlwZS50b1V0ZjE2ID0gZnVuY3Rpb24gKCl7XG4gIHZhciByID0gdGhpcy50b1N0cmluZygpO1xuICBpZih0aGlzLnQgPT0gOSkgcmV0dXJuIHJcbiAgcmV0dXJuIGNhbWxfdXRmMTZfb2ZfdXRmOChyKTtcbn1cbk1sQnl0ZXMucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gKCl7XG4gIHZhciBjb250ZW50ID0gdGhpcy50ID09IDQgPyB0aGlzLmMuc2xpY2UoKSA6IHRoaXMuYztcbiAgcmV0dXJuIG5ldyBNbEJ5dGVzKHRoaXMudCxjb250ZW50LHRoaXMubCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfc3RyX3JlcGVhdCwgY2FtbF9zdWJhcnJheV90b19qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzIChzKSB7XG4gIC8qIEFzc3VtZXMgbm90IEJZVEVTICovXG4gIGlmIChzLnQgPT0gMiAvKiBQQVJUSUFMICovKVxuICAgIHMuYyArPSBjYW1sX3N0cl9yZXBlYXQocy5sIC0gcy5jLmxlbmd0aCwgJ1xcMCcpXG4gIGVsc2VcbiAgICBzLmMgPSBjYW1sX3N1YmFycmF5X3RvX2pzYnl0ZXMgKHMuYywgMCwgcy5jLmxlbmd0aCk7XG4gIHMudCA9IDA7IC8qQllURVMgfCBVTktPV04qL1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfY29udmVydF9ieXRlc190b19hcnJheSAocykge1xuICAvKiBBc3N1bWVzIG5vdCBBUlJBWSAqL1xuICBpZihqb29fZ2xvYmFsX29iamVjdC5VaW50OEFycmF5KSB7XG4gICAgdmFyIGEgPSBuZXcgam9vX2dsb2JhbF9vYmplY3QuVWludDhBcnJheShzLmwpO1xuICB9IGVsc2Uge1xuICAgIHZhciBhID0gbmV3IEFycmF5KHMubCk7XG4gIH1cbiAgdmFyIGIgPSBzLmMsIGwgPSBiLmxlbmd0aCwgaSA9IDA7XG4gIGZvciAoOyBpIDwgbDsgaSsrKSBhW2ldID0gYi5jaGFyQ29kZUF0KGkpO1xuICBmb3IgKGwgPSBzLmw7IGkgPCBsOyBpKyspIGFbaV0gPSAwO1xuICBzLmMgPSBhO1xuICBzLnQgPSA0OyAvKiBBUlJBWSAqL1xuICByZXR1cm4gYTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9vZl9ieXRlcyBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfYXJyYXlfb2ZfYnl0ZXMgKHMpIHtcbiAgaWYgKHMudCAhPSA0IC8qIEFSUkFZICovKSBjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXkocyk7XG4gIHJldHVybiBzLmM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYXJyYXlfb2Zfc3RyaW5nIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9ieXRlc190b19hcnJheVxuLy9SZXF1aXJlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoLCBjYW1sX3N0cmluZ191bnNhZmVfZ2V0XG5mdW5jdGlvbiBjYW1sX2FycmF5X29mX3N0cmluZyAocykge1xuICB2YXIgbCA9IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKTtcbiAgdmFyIGEgPSBuZXcgQXJyYXkobCk7XG4gIHZhciBpID0gMDtcbiAgZm9yICg7IGkgPCBsOyBpKyspIGFbaV0gPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0KHMsaSk7XG4gIHJldHVybiBhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NyZWF0ZV9zdHJpbmcgY29uc3Rcbi8vUmVxdWlyZXM6IE1sQnl0ZXMsIGNhbWxfaW52YWxpZF9hcmd1bWVudFxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9jcmVhdGVfc3RyaW5nKGxlbikge1xuICBpZihsZW4gPCAwKSBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJTdHJpbmcuY3JlYXRlXCIpO1xuICByZXR1cm4gbmV3IE1sQnl0ZXMobGVuPzI6OSxcIlwiLGxlbik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY3JlYXRlX3N0cmluZyBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfY3JlYXRlX3N0cmluZyhsZW4pIHtcbiAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiU3RyaW5nLmNyZWF0ZVwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jcmVhdGVfYnl0ZXMgY29uc3Rcbi8vUmVxdWlyZXM6IE1sQnl0ZXMsY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX2NyZWF0ZV9ieXRlcyhsZW4pIHtcbiAgaWYgKGxlbiA8IDApIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJ5dGVzLmNyZWF0ZVwiKTtcbiAgcmV0dXJuIG5ldyBNbEJ5dGVzKGxlbj8yOjksXCJcIixsZW4pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19vZl9hcnJheVxuLy9SZXF1aXJlczogY2FtbF9zdWJhcnJheV90b19qc2J5dGVzLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19vZl9hcnJheSAoYSkge1xuICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhjYW1sX3N1YmFycmF5X3RvX2pzYnl0ZXMoYSwwLGEubGVuZ3RoKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfb2ZfYXJyYXlcbi8vUmVxdWlyZXM6IE1sQnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfb2ZfYXJyYXkgKGEpIHtcbiAgcmV0dXJuIG5ldyBNbEJ5dGVzKDQsYSxhLmxlbmd0aCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfY29tcGFyZSBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2NvbXBhcmUoczEsIHMyKSB7XG4gIChzMS50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzMSk7XG4gIChzMi50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzMik7XG4gIHJldHVybiAoczEuYyA8IHMyLmMpPy0xOihzMS5jID4gczIuYyk/MTowO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfZXF1YWwgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlc1xuZnVuY3Rpb24gY2FtbF9ieXRlc19lcXVhbChzMSwgczIpIHtcbiAgaWYoczEgPT09IHMyKSByZXR1cm4gMTtcbiAgKHMxLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMxKTtcbiAgKHMyLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMyKTtcbiAgcmV0dXJuIChzMS5jID09IHMyLmMpPzE6MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfbm90ZXF1YWwgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfZXF1YWxcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX25vdGVxdWFsKHMxLCBzMikgeyByZXR1cm4gMS1jYW1sX3N0cmluZ19lcXVhbChzMSwgczIpOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfbm90ZXF1YWwgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfZXF1YWxcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfbm90ZXF1YWwoczEsIHMyKSB7IHJldHVybiAxLWNhbWxfc3RyaW5nX2VxdWFsKHMxLCBzMik7IH1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19sZXNzZXF1YWwgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlc1xuZnVuY3Rpb24gY2FtbF9ieXRlc19sZXNzZXF1YWwoczEsIHMyKSB7XG4gIChzMS50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzMSk7XG4gIChzMi50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzMik7XG4gIHJldHVybiAoczEuYyA8PSBzMi5jKT8xOjA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfbGVzc3RoYW4gbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlc1xuZnVuY3Rpb24gY2FtbF9ieXRlc19sZXNzdGhhbihzMSwgczIpIHtcbiAgKHMxLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMxKTtcbiAgKHMyLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMyKTtcbiAgcmV0dXJuIChzMS5jIDwgczIuYyk/MTowO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19ncmVhdGVyZXF1YWxcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX2xlc3NlcXVhbFxuZnVuY3Rpb24gY2FtbF9zdHJpbmdfZ3JlYXRlcmVxdWFsKHMxLCBzMikge1xuICByZXR1cm4gY2FtbF9zdHJpbmdfbGVzc2VxdWFsKHMyLHMxKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfZ3JlYXRlcmVxdWFsXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2xlc3NlcXVhbFxuZnVuY3Rpb24gY2FtbF9ieXRlc19ncmVhdGVyZXF1YWwoczEsIHMyKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX2xlc3NlcXVhbChzMixzMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2dyZWF0ZXJ0aGFuXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19sZXNzdGhhblxuZnVuY3Rpb24gY2FtbF9zdHJpbmdfZ3JlYXRlcnRoYW4oczEsIHMyKSB7XG4gIHJldHVybiBjYW1sX3N0cmluZ19sZXNzdGhhbihzMiwgczEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2dyZWF0ZXJ0aGFuXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2xlc3N0aGFuXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2dyZWF0ZXJ0aGFuKHMxLCBzMikge1xuICByZXR1cm4gY2FtbF9ieXRlc19sZXNzdGhhbihzMiwgczEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ZpbGxfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfc3RyX3JlcGVhdCwgY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5XG5mdW5jdGlvbiBjYW1sX2ZpbGxfYnl0ZXMocywgaSwgbCwgYykge1xuICBpZiAobCA+IDApIHtcbiAgICBpZiAoaSA9PSAwICYmIChsID49IHMubCB8fCAocy50ID09IDIgLyogUEFSVElBTCAqLyAmJiBsID49IHMuYy5sZW5ndGgpKSkge1xuICAgICAgaWYgKGMgPT0gMCkge1xuICAgICAgICBzLmMgPSBcIlwiO1xuICAgICAgICBzLnQgPSAyOyAvKiBQQVJUSUFMICovXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzLmMgPSBjYW1sX3N0cl9yZXBlYXQgKGwsIFN0cmluZy5mcm9tQ2hhckNvZGUoYykpO1xuICAgICAgICBzLnQgPSAobCA9PSBzLmwpPzAgLyogQllURVMgfCBVTktPV04gKi8gOjI7IC8qIFBBUlRJQUwgKi9cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHMudCAhPSA0IC8qIEFSUkFZICovKSBjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXkocyk7XG4gICAgICBmb3IgKGwgKz0gaTsgaSA8IGw7IGkrKykgcy5jW2ldID0gYztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmlsbF9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfZmlsbF9ieXRlc1xudmFyIGNhbWxfZmlsbF9zdHJpbmcgPSBjYW1sX2ZpbGxfYnl0ZXNcblxuLy9Qcm92aWRlczogY2FtbF9ibGl0X2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX3N1YmFycmF5X3RvX2pzYnl0ZXMsIGNhbWxfY29udmVydF9ieXRlc190b19hcnJheVxuZnVuY3Rpb24gY2FtbF9ibGl0X2J5dGVzKHMxLCBpMSwgczIsIGkyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PSAwKSByZXR1cm4gMDtcbiAgaWYgKChpMiA9PSAwKSAmJlxuICAgICAgKGxlbiA+PSBzMi5sIHx8IChzMi50ID09IDIgLyogUEFSVElBTCAqLyAmJiBsZW4gPj0gczIuYy5sZW5ndGgpKSkge1xuICAgIHMyLmMgPSAoczEudCA9PSA0IC8qIEFSUkFZICovKT9cbiAgICAgIGNhbWxfc3ViYXJyYXlfdG9fanNieXRlcyhzMS5jLCBpMSwgbGVuKTpcbiAgICAgIChpMSA9PSAwICYmIHMxLmMubGVuZ3RoID09IGxlbik/czEuYzpzMS5jLnN1YnN0cihpMSwgbGVuKTtcbiAgICBzMi50ID0gKHMyLmMubGVuZ3RoID09IHMyLmwpPzAgLyogQllURVMgfCBVTktPV04gKi8gOjI7IC8qIFBBUlRJQUwgKi9cbiAgfSBlbHNlIGlmIChzMi50ID09IDIgLyogUEFSVElBTCAqLyAmJiBpMiA9PSBzMi5jLmxlbmd0aCkge1xuICAgIHMyLmMgKz0gKHMxLnQgPT0gNCAvKiBBUlJBWSAqLyk/XG4gICAgICBjYW1sX3N1YmFycmF5X3RvX2pzYnl0ZXMoczEuYywgaTEsIGxlbik6XG4gICAgICAoaTEgPT0gMCAmJiBzMS5jLmxlbmd0aCA9PSBsZW4pP3MxLmM6czEuYy5zdWJzdHIoaTEsIGxlbik7XG4gICAgczIudCA9IChzMi5jLmxlbmd0aCA9PSBzMi5sKT8wIC8qIEJZVEVTIHwgVU5LT1dOICovIDoyOyAvKiBQQVJUSUFMICovXG4gIH0gZWxzZSB7XG4gICAgaWYgKHMyLnQgIT0gNCAvKiBBUlJBWSAqLykgY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5KHMyKTtcbiAgICB2YXIgYzEgPSBzMS5jLCBjMiA9IHMyLmM7XG4gICAgaWYgKHMxLnQgPT0gNCAvKiBBUlJBWSAqLykge1xuICAgICAgaWYgKGkyIDw9IGkxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIGMyIFtpMiArIGldID0gYzEgW2kxICsgaV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpID0gbGVuIC0gMTsgaSA+PSAwOyBpLS0pIGMyIFtpMiArIGldID0gYzEgW2kxICsgaV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBsID0gTWF0aC5taW4gKGxlbiwgYzEubGVuZ3RoIC0gaTEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIGMyIFtpMiArIGldID0gYzEuY2hhckNvZGVBdChpMSArIGkpO1xuICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykgYzIgW2kyICsgaV0gPSAwO1xuICAgIH1cbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ibGl0X3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9ibGl0X2J5dGVzLCBjYW1sX2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9ibGl0X3N0cmluZyhhLGIsYyxkLGUpIHtcbiAgICBjYW1sX2JsaXRfYnl0ZXMoY2FtbF9ieXRlc19vZl9zdHJpbmcoYSksYixjLGQsZSk7XG4gICAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9ieXRlc19sZW5ndGggY29uc3RcbmZ1bmN0aW9uIGNhbWxfbWxfYnl0ZXNfbGVuZ3RoKHMpIHsgcmV0dXJuIHMubCB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgY29uc3Rcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSkge1xuICByZXR1cm4gcy5jaGFyQ29kZUF0KGkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ191bnNhZmVfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3Vuc2FmZV9zZXQgKHMsIGksIGMpIHtcbiAgICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9zdHJpbmdfdW5zYWZlX3NldFwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoIGNvbnN0XG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSB7XG4gIHJldHVybiBzLmxlbmd0aFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19jb21wYXJlIGNvbnN0XG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2NvbXBhcmUoczEsIHMyKSB7XG4gIHJldHVybiAoczEgPCBzMik/LTE6KHMxID4gczIpPzE6MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfZXF1YWwgY29uc3Rcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfZXF1YWwoczEsIHMyKSB7XG4gIGlmKHMxID09PSBzMikgcmV0dXJuIDE7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19sZXNzZXF1YWwgY29uc3Rcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfbGVzc2VxdWFsKHMxLCBzMikge1xuICByZXR1cm4gKHMxIDw9IHMyKT8xOjA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2xlc3N0aGFuIGNvbnN0XG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2xlc3N0aGFuKHMxLCBzMikge1xuICByZXR1cm4gKHMxIDwgczIpPzE6MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfb2ZfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfb2ZfYnl0ZXMocykge1xuICAgIChzLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMpO1xuICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhzLmMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX29mX3N0cmluZyBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19vZl9qc2J5dGVzLCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfb2Zfc3RyaW5nKHMpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfb2ZfanNieXRlcyhjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKHMpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlcyBjb25zdFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKHgpIHsgcmV0dXJuIHggfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nIGNvbnN0XG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfanNieXRlc19vZl9zdHJpbmcoeCkgeyByZXR1cm4geCB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nIGNvbnN0XG4vL1JlcXVpcmVzOiBqc29vX2lzX2FzY2lpLCBjYW1sX3V0ZjE2X29mX3V0Zjhcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocykge1xuICBpZihqc29vX2lzX2FzY2lpKHMpKVxuICAgIHJldHVybiBzO1xuICByZXR1cm4gY2FtbF91dGYxNl9vZl91dGY4KHMpOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nIGNvbnN0XG4vL1JlcXVpcmVzOiBqc29vX2lzX2FzY2lpLCBjYW1sX3V0Zjhfb2ZfdXRmMTYsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcgKHMpIHtcbiAgaWYgKGpzb29faXNfYXNjaWkocykpXG4gICAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMocylcbiAgZWxzZSByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhjYW1sX3V0Zjhfb2ZfdXRmMTYocykpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX29mX2pzYnl0ZXMgY29uc3Rcbi8vUmVxdWlyZXM6IE1sQnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfb2ZfanNieXRlcyhzKSB7IHJldHVybiBuZXcgTWxCeXRlcygwLHMscy5sZW5ndGgpOyB9XG5cblxuLy8gVGhlIHNlY3Rpb24gYmVsb3cgc2hvdWxkIGJlIHVzZWQgd2hlbiB1c2UtanMtc3RyaW5nPWZhbHNlXG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfdW5zYWZlX2dldFxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSkge1xuICByZXR1cm4gY2FtbF9ieXRlc191bnNhZmVfZ2V0KHMsaSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9zZXRcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfdW5zYWZlX3NldFxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfdW5zYWZlX3NldCAocywgaSwgYykge1xuICByZXR1cm4gY2FtbF9ieXRlc191bnNhZmVfc2V0KHMsaSxjKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX21sX2J5dGVzX2xlbmd0aFxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpIHtcbiAgcmV0dXJuIGNhbWxfbWxfYnl0ZXNfbGVuZ3RoKHMpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2NvbXBhcmVcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfY29tcGFyZVxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfY29tcGFyZShzMSwgczIpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfY29tcGFyZShzMSxzMilcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfZXF1YWxcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfZXF1YWxcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2VxdWFsKHMxLCBzMikge1xuICByZXR1cm4gY2FtbF9ieXRlc19lcXVhbChzMSxzMilcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfbGVzc2VxdWFsXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2xlc3NlcXVhbFxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfbGVzc2VxdWFsKHMxLCBzMikge1xuICByZXR1cm4gY2FtbF9ieXRlc19sZXNzZXF1YWwoczEsczIpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2xlc3N0aGFuXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2xlc3N0aGFuXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19sZXNzdGhhbihzMSwgczIpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfbGVzc3RoYW4oczEsczIpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX29mX2J5dGVzXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19vZl9ieXRlcyhzKSB7IHJldHVybiBzIH1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19vZl9zdHJpbmcgY29uc3Rcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfb2Zfc3RyaW5nKHMpIHsgcmV0dXJuIHMgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX29mX2pzYnl0ZXNcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMocykgeyByZXR1cm4gY2FtbF9ieXRlc19vZl9qc2J5dGVzKHMpOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmcgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXNcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfanNieXRlc19vZl9zdHJpbmcocykge1xuICBpZiAoKHMudCAmIDYpICE9IDAgLyogQllURVMgKi8pIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMocyk7XG4gIHJldHVybiBzLmMgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyBtdXRhYmxlIChjb25zdClcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHMpe1xuICByZXR1cm4gcy50b1V0ZjE2KClcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfb2ZfdXRmMTZfanNzdHJpbmdcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nIChzKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX29mX3V0ZjE2X2pzc3RyaW5nKHMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lzX21sX2J5dGVzXG4vL1JlcXVpcmVzOiBNbEJ5dGVzXG5mdW5jdGlvbiBjYW1sX2lzX21sX2J5dGVzKHMpIHtcbiAgcmV0dXJuIChzIGluc3RhbmNlb2YgTWxCeXRlcyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaXNfbWxfc3RyaW5nXG4vL1JlcXVpcmVzOiBqc29vX2lzX2FzY2lpXG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfaXNfbWxfc3RyaW5nKHMpIHtcbiAgcmV0dXJuICh0eXBlb2YgcyA9PT0gXCJzdHJpbmdcIiAmJiAhL1teXFx4MDAtXFx4ZmZdLy50ZXN0KHMpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pc19tbF9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfaXNfbWxfYnl0ZXNcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfaXNfbWxfc3RyaW5nKHMpIHtcbiAgcmV0dXJuIGNhbWxfaXNfbWxfYnl0ZXMocyk7XG59XG5cbi8vIFRoZSBmdW5jdGlvbnMgYmVsb3cgYXJlIGRlcHJlY2F0ZWRcblxuLy9Qcm92aWRlczogY2FtbF9qc190b19ieXRlX3N0cmluZyBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9qc190b19ieXRlX3N0cmluZyhzKSB7IHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKHMpIH1cblxuLy9Qcm92aWRlczogY2FtbF9uZXdfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX25ld19zdHJpbmcgKHMpIHsgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMocykgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2Zyb21fc3RyaW5nIG11dGFibGUgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfanNfZnJvbV9zdHJpbmcocykge1xuICByZXR1cm4gY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocylcbn1cblxuLy9Qcm92aWRlczogY2FtbF90b19qc19zdHJpbmcgbXV0YWJsZSAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF90b19qc19zdHJpbmcocykge1xuICByZXR1cm4gY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocylcbn1cblxuLy9Qcm92aWRlczogY2FtbF9qc190b19zdHJpbmcgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2pzX3RvX3N0cmluZyAocykge1xuICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcocyk7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1JhaXNlIGV4Y2VwdGlvblxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JhaXNlX2NvbnN0YW50IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfcmFpc2VfY29uc3RhbnQgKHRhZykgeyB0aHJvdyB0YWc7IH1cblxuLy9Qcm92aWRlczogY2FtbF9yZXR1cm5fZXhuX2NvbnN0YW50IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfcmV0dXJuX2V4bl9jb25zdGFudCAodGFnKSB7IHJldHVybiB0YWc7IH1cblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV93aXRoX2FyZyAoY29uc3QsIGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9yYWlzZV93aXRoX2FyZyAodGFnLCBhcmcpIHsgdGhyb3cgWzAsIHRhZywgYXJnXTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JhaXNlX3dpdGhfc3RyaW5nIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3dpdGhfYXJnLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX3JhaXNlX3dpdGhfc3RyaW5nICh0YWcsIG1zZykge1xuICBjYW1sX3JhaXNlX3dpdGhfYXJnICh0YWcsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMobXNnKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmFpbHdpdGggKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV93aXRoX3N0cmluZywgY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9mYWlsd2l0aCAobXNnKSB7XG4gIGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcoY2FtbF9nbG9iYWxfZGF0YS5GYWlsdXJlLCBtc2cpO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3dpdGhfc3RyaW5nLCBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX2ludmFsaWRfYXJndW1lbnQgKG1zZykge1xuICBjYW1sX3JhaXNlX3dpdGhfc3RyaW5nKGNhbWxfZ2xvYmFsX2RhdGEuSW52YWxpZF9hcmd1bWVudCwgbXNnKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9jb25zdGFudCwgY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZSAoKSB7XG4gIGNhbWxfcmFpc2VfY29uc3RhbnQoY2FtbF9nbG9iYWxfZGF0YS5FbmRfb2ZfZmlsZSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2VfemVyb19kaXZpZGVcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2VfY29uc3RhbnQsIGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfcmFpc2VfemVyb19kaXZpZGUgKCkge1xuICBjYW1sX3JhaXNlX2NvbnN0YW50KGNhbWxfZ2xvYmFsX2RhdGEuRGl2aXNpb25fYnlfemVybyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2Vfbm90X2ZvdW5kXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX2NvbnN0YW50LCBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX3JhaXNlX25vdF9mb3VuZCAoKSB7XG4gIGNhbWxfcmFpc2VfY29uc3RhbnQoY2FtbF9nbG9iYWxfZGF0YS5Ob3RfZm91bmQpOyB9XG5cblxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yICgpIHtcbiAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiaW5kZXggb3V0IG9mIGJvdW5kc1wiKTtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxMCBKw6lyw7RtZSBWb3VpbGxvblxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NhbGxfZ2VuIChjb25zdCwgc2hhbGxvdylcbi8vV2Vha2RlZlxuZnVuY3Rpb24gY2FtbF9jYWxsX2dlbihmLCBhcmdzKSB7XG4gIGlmKGYuZnVuKVxuICAgIHJldHVybiBjYW1sX2NhbGxfZ2VuKGYuZnVuLCBhcmdzKTtcbiAgLy9GSVhNRSwgY2FuIGhhcHBlbiB3aXRoIHRvbyBtYW55IGFyZ3VtZW50c1xuICBpZih0eXBlb2YgZiAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gZjtcbiAgdmFyIG4gPSBmLmxlbmd0aCB8IDA7XG4gIGlmKG4gPT09IDApIHJldHVybiBmLmFwcGx5KG51bGwsYXJncyk7XG4gIHZhciBhcmdzTGVuID0gYXJncy5sZW5ndGggfCAwO1xuICB2YXIgZCA9IG4gLSBhcmdzTGVuIHwgMDtcbiAgaWYgKGQgPT0gMClcbiAgICByZXR1cm4gZi5hcHBseShudWxsLCBhcmdzKTtcbiAgZWxzZSBpZiAoZCA8IDApIHtcbiAgICByZXR1cm4gY2FtbF9jYWxsX2dlbihmLmFwcGx5KG51bGwsYXJncy5zbGljZSgwLG4pKSxhcmdzLnNsaWNlKG4pKTtcbiAgfVxuICBlbHNlIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCl7XG4gICAgICB2YXIgZXh0cmFfYXJncyA9IChhcmd1bWVudHMubGVuZ3RoID09IDApPzE6YXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIHZhciBuYXJncyA9IG5ldyBBcnJheShhcmdzLmxlbmd0aCtleHRyYV9hcmdzKTtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrICkgbmFyZ3NbaV0gPSBhcmdzW2ldO1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKyApIG5hcmdzW2FyZ3MubGVuZ3RoK2ldID0gYXJndW1lbnRzW2ldO1xuICAgICAgcmV0dXJuIGNhbWxfY2FsbF9nZW4oZiwgbmFyZ3MpXG4gICAgfVxuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbmFtZWRfdmFsdWVzXG52YXIgY2FtbF9uYW1lZF92YWx1ZXMgPSB7fTtcblxuLy9Qcm92aWRlczogY2FtbF9yZWdpc3Rlcl9uYW1lZF92YWx1ZSAoY29uc3QsY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX25hbWVkX3ZhbHVlcywgY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9yZWdpc3Rlcl9uYW1lZF92YWx1ZShubSx2KSB7XG4gIGNhbWxfbmFtZWRfdmFsdWVzW2NhbWxfanNieXRlc19vZl9zdHJpbmcobm0pXSA9IHY7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX25hbWVkX3ZhbHVlXG4vL1JlcXVpcmVzOiBjYW1sX25hbWVkX3ZhbHVlc1xuZnVuY3Rpb24gY2FtbF9uYW1lZF92YWx1ZShubSkge1xuICByZXR1cm4gY2FtbF9uYW1lZF92YWx1ZXNbbm1dXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2xvYmFsX2RhdGFcbnZhciBjYW1sX2dsb2JhbF9kYXRhID0gWzBdO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX3JlZ2lzdGVyX2dsb2JhbCAoY29uc3QsIHNoYWxsb3csIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9yZWdpc3Rlcl9nbG9iYWwgKG4sIHYsIG5hbWVfb3B0KSB7XG4gIGlmKG5hbWVfb3B0ICYmIGpvb19nbG9iYWxfb2JqZWN0LnRvcGxldmVsUmVsb2MpXG4gICAgbiA9IGpvb19nbG9iYWxfb2JqZWN0LnRvcGxldmVsUmVsb2MobmFtZV9vcHQpO1xuICBjYW1sX2dsb2JhbF9kYXRhW24gKyAxXSA9IHY7XG4gIGlmKG5hbWVfb3B0KSBjYW1sX2dsb2JhbF9kYXRhW25hbWVfb3B0XSA9IHY7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2V0X2dsb2JhbF9kYXRhIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfZ2V0X2dsb2JhbF9kYXRhICgpIHsgcmV0dXJuIGNhbWxfZ2xvYmFsX2RhdGE7IH1cblxuLy9Qcm92aWRlczogY2FtbF9pc19wcmludGFibGUgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9pc19wcmludGFibGUoYykgeyByZXR1cm4gKyhjID4gMzEgJiYgYyA8IDEyNyk7IH1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vLy8vLy8vLy8vLy8gRm9ybWF0XG5cbi8vUHJvdmlkZXM6IGNhbWxfcGFyc2VfZm9ybWF0XG4vL1JlcXVpcmVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nLCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfcGFyc2VfZm9ybWF0IChmbXQpIHtcbiAgZm10ID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhmbXQpO1xuICB2YXIgbGVuID0gZm10Lmxlbmd0aDtcbiAgaWYgKGxlbiA+IDMxKSBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJmb3JtYXRfaW50OiBmb3JtYXQgdG9vIGxvbmdcIik7XG4gIHZhciBmID1cbiAgICAgIHsganVzdGlmeTonKycsIHNpZ25zdHlsZTonLScsIGZpbGxlcjonICcsIGFsdGVybmF0ZTpmYWxzZSxcbiAgICAgICAgYmFzZTowLCBzaWduZWRjb252OmZhbHNlLCB3aWR0aDowLCB1cHBlcmNhc2U6ZmFsc2UsXG4gICAgICAgIHNpZ246MSwgcHJlYzotMSwgY29udjonZicgfTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBjID0gZm10LmNoYXJBdChpKTtcbiAgICBzd2l0Y2ggKGMpIHtcbiAgICBjYXNlICctJzpcbiAgICAgIGYuanVzdGlmeSA9ICctJzsgYnJlYWs7XG4gICAgY2FzZSAnKyc6IGNhc2UgJyAnOlxuICAgICAgZi5zaWduc3R5bGUgPSBjOyBicmVhaztcbiAgICBjYXNlICcwJzpcbiAgICAgIGYuZmlsbGVyID0gJzAnOyBicmVhaztcbiAgICBjYXNlICcjJzpcbiAgICAgIGYuYWx0ZXJuYXRlID0gdHJ1ZTsgYnJlYWs7XG4gICAgY2FzZSAnMSc6IGNhc2UgJzInOiBjYXNlICczJzogY2FzZSAnNCc6IGNhc2UgJzUnOlxuICAgIGNhc2UgJzYnOiBjYXNlICc3JzogY2FzZSAnOCc6IGNhc2UgJzknOlxuICAgICAgZi53aWR0aCA9IDA7XG4gICAgICB3aGlsZSAoYz1mbXQuY2hhckNvZGVBdChpKSAtIDQ4LCBjID49IDAgJiYgYyA8PSA5KSB7XG4gICAgICAgIGYud2lkdGggPSBmLndpZHRoICogMTAgKyBjOyBpKytcbiAgICAgIH1cbiAgICAgIGktLTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJy4nOlxuICAgICAgZi5wcmVjID0gMDtcbiAgICAgIGkrKztcbiAgICAgIHdoaWxlIChjPWZtdC5jaGFyQ29kZUF0KGkpIC0gNDgsIGMgPj0gMCAmJiBjIDw9IDkpIHtcbiAgICAgICAgZi5wcmVjID0gZi5wcmVjICogMTAgKyBjOyBpKytcbiAgICAgIH1cbiAgICAgIGktLTtcbiAgICBjYXNlICdkJzogY2FzZSAnaSc6XG4gICAgICBmLnNpZ25lZGNvbnYgPSB0cnVlOyAvKiBmYWxsdGhyb3VnaCAqL1xuICAgIGNhc2UgJ3UnOlxuICAgICAgZi5iYXNlID0gMTA7IGJyZWFrO1xuICAgIGNhc2UgJ3gnOlxuICAgICAgZi5iYXNlID0gMTY7IGJyZWFrO1xuICAgIGNhc2UgJ1gnOlxuICAgICAgZi5iYXNlID0gMTY7IGYudXBwZXJjYXNlID0gdHJ1ZTsgYnJlYWs7XG4gICAgY2FzZSAnbyc6XG4gICAgICBmLmJhc2UgPSA4OyBicmVhaztcbiAgICBjYXNlICdlJzogY2FzZSAnZic6IGNhc2UgJ2cnOlxuICAgICAgZi5zaWduZWRjb252ID0gdHJ1ZTsgZi5jb252ID0gYzsgYnJlYWs7XG4gICAgY2FzZSAnRSc6IGNhc2UgJ0YnOiBjYXNlICdHJzpcbiAgICAgIGYuc2lnbmVkY29udiA9IHRydWU7IGYudXBwZXJjYXNlID0gdHJ1ZTtcbiAgICAgIGYuY29udiA9IGMudG9Mb3dlckNhc2UgKCk7IGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9maW5pc2hfZm9ybWF0dGluZ1xuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9maW5pc2hfZm9ybWF0dGluZyhmLCByYXdidWZmZXIpIHtcbiAgaWYgKGYudXBwZXJjYXNlKSByYXdidWZmZXIgPSByYXdidWZmZXIudG9VcHBlckNhc2UoKTtcbiAgdmFyIGxlbiA9IHJhd2J1ZmZlci5sZW5ndGg7XG4gIC8qIEFkanVzdCBsZW4gdG8gcmVmbGVjdCBhZGRpdGlvbmFsIGNoYXJzIChzaWduLCBldGMpICovXG4gIGlmIChmLnNpZ25lZGNvbnYgJiYgKGYuc2lnbiA8IDAgfHwgZi5zaWduc3R5bGUgIT0gJy0nKSkgbGVuKys7XG4gIGlmIChmLmFsdGVybmF0ZSkge1xuICAgIGlmIChmLmJhc2UgPT0gOCkgbGVuICs9IDE7XG4gICAgaWYgKGYuYmFzZSA9PSAxNikgbGVuICs9IDI7XG4gIH1cbiAgLyogRG8gdGhlIGZvcm1hdHRpbmcgKi9cbiAgdmFyIGJ1ZmZlciA9IFwiXCI7XG4gIGlmIChmLmp1c3RpZnkgPT0gJysnICYmIGYuZmlsbGVyID09ICcgJylcbiAgICBmb3IgKHZhciBpID0gbGVuOyBpIDwgZi53aWR0aDsgaSsrKSBidWZmZXIgKz0gJyAnO1xuICBpZiAoZi5zaWduZWRjb252KSB7XG4gICAgaWYgKGYuc2lnbiA8IDApIGJ1ZmZlciArPSAnLSc7XG4gICAgZWxzZSBpZiAoZi5zaWduc3R5bGUgIT0gJy0nKSBidWZmZXIgKz0gZi5zaWduc3R5bGU7XG4gIH1cbiAgaWYgKGYuYWx0ZXJuYXRlICYmIGYuYmFzZSA9PSA4KSBidWZmZXIgKz0gJzAnO1xuICBpZiAoZi5hbHRlcm5hdGUgJiYgZi5iYXNlID09IDE2KSBidWZmZXIgKz0gXCIweFwiO1xuICBpZiAoZi5qdXN0aWZ5ID09ICcrJyAmJiBmLmZpbGxlciA9PSAnMCcpXG4gICAgZm9yICh2YXIgaSA9IGxlbjsgaSA8IGYud2lkdGg7IGkrKykgYnVmZmVyICs9ICcwJztcbiAgYnVmZmVyICs9IHJhd2J1ZmZlcjtcbiAgaWYgKGYuanVzdGlmeSA9PSAnLScpXG4gICAgZm9yICh2YXIgaSA9IGxlbjsgaSA8IGYud2lkdGg7IGkrKykgYnVmZmVyICs9ICcgJztcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoYnVmZmVyKTtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxMCBKw6lyw7RtZSBWb3VpbGxvblxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBqc29vX2Zsb29yX2xvZzJcbnZhciBsb2cyX29rID0gTWF0aC5sb2cyICYmIE1hdGgubG9nMigxLjEyMzU1ODIwOTI4ODk0NzRFKzMwNykgPT0gMTAyMFxuZnVuY3Rpb24ganNvb19mbG9vcl9sb2cyKHgpIHtcbiAgaWYobG9nMl9vaykgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5sb2cyKHgpKVxuICB2YXIgaSA9IDA7XG4gIGlmICh4ID09IDApIHJldHVybiAtSW5maW5pdHk7XG4gIGlmKHg+PTEpIHt3aGlsZSAoeD49Mikge3gvPTI7IGkrK30gfVxuICBlbHNlIHt3aGlsZSAoeCA8IDEpIHt4Kj0yOyBpLS19IH07XG4gIHJldHVybiBpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQgY29uc3Rcbi8vUmVxdWlyZXM6IGpzb29fZmxvb3JfbG9nMiwgY2FtbF9pbnQ2NF9jcmVhdGVfbG9fbWlfaGlcbmZ1bmN0aW9uIGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCAoeCkge1xuICBpZiAoIWlzRmluaXRlKHgpKSB7XG4gICAgaWYgKGlzTmFOKHgpKVxuICAgICAgcmV0dXJuIGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpKDEsIDAsIDB4N2ZmMCk7XG4gICAgaWYgKHggPiAwKVxuICAgICAgcmV0dXJuIGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpKDAsIDAsIDB4N2ZmMClcbiAgICBlbHNlXG4gICAgICByZXR1cm4gY2FtbF9pbnQ2NF9jcmVhdGVfbG9fbWlfaGkoMCwgMCwgMHhmZmYwKVxuICB9XG4gIHZhciBzaWduID0gKHg9PTAgJiYgMS94ID09IC1JbmZpbml0eSk/MHg4MDAwOih4Pj0wKT8wOjB4ODAwMDtcbiAgaWYgKHNpZ24pIHggPSAteDtcbiAgLy8gSW50NjQuYml0c19vZl9mbG9hdCAxLjEyMzU1ODIwOTI4ODk0NzRFKzMwNyA9IDB4N2ZiMDAwMDAwMDAwMDAwMExcbiAgLy8gdXNpbmcgTWF0aC5MT0cyRSpNYXRoLmxvZyh4KSBpbiBwbGFjZSBvZiBNYXRoLmxvZzIgcmVzdWx0IGluIHByZWNpc2lvbiBsb3N0XG4gIHZhciBleHAgPSBqc29vX2Zsb29yX2xvZzIoeCkgKyAxMDIzO1xuICBpZiAoZXhwIDw9IDApIHtcbiAgICBleHAgPSAwO1xuICAgIHggLz0gTWF0aC5wb3coMiwtMTAyNik7XG4gIH0gZWxzZSB7XG4gICAgeCAvPSBNYXRoLnBvdygyLGV4cC0xMDI3KTtcbiAgICBpZiAoeCA8IDE2KSB7XG4gICAgICB4ICo9IDI7IGV4cCAtPTE7IH1cbiAgICBpZiAoZXhwID09IDApIHtcbiAgICAgIHggLz0gMjsgfVxuICB9XG4gIHZhciBrID0gTWF0aC5wb3coMiwyNCk7XG4gIHZhciByMyA9IHh8MDtcbiAgeCA9ICh4IC0gcjMpICogaztcbiAgdmFyIHIyID0geHwwO1xuICB4ID0gKHggLSByMikgKiBrO1xuICB2YXIgcjEgPSB4fDA7XG4gIHIzID0gKHIzICYweGYpIHwgc2lnbiB8IGV4cCA8PCA0O1xuICByZXR1cm4gY2FtbF9pbnQ2NF9jcmVhdGVfbG9fbWlfaGkocjEsIHIyLCByMyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50MzJfYml0c19vZl9mbG9hdCBjb25zdFxuLy9SZXF1aXJlczoganNvb19mbG9vcl9sb2cyXG5mdW5jdGlvbiBjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXQgKHgpIHtcbiAgdmFyIGZsb2F0MzJhID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0LkZsb2F0MzJBcnJheSgxKTtcbiAgZmxvYXQzMmFbMF0gPSB4O1xuICB2YXIgaW50MzJhID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0LkludDMyQXJyYXkoZmxvYXQzMmEuYnVmZmVyKTtcbiAgcmV0dXJuIGludDMyYVswXSB8IDA7XG59XG5cbi8vRlAgbGl0ZXJhbHMgY2FuIGJlIHdyaXR0ZW4gdXNpbmcgdGhlIGhleGFkZWNpbWFsXG4vL25vdGF0aW9uIDB4PG1hbnRpc3NhIGluIGhleD5wPGV4cG9uZW50PiBmcm9tIElTTyBDOTkuXG4vL2h0dHBzOi8vZ2l0aHViLmNvbS9kYW5rb2dhaS9qcy1oZXhmbG9hdC9ibG9iL21hc3Rlci9oZXhmbG9hdC5qc1xuLy9Qcm92aWRlczogY2FtbF9oZXhzdHJpbmdfb2ZfZmxvYXQgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nLCBjYW1sX3N0cl9yZXBlYXRcbmZ1bmN0aW9uIGNhbWxfaGV4c3RyaW5nX29mX2Zsb2F0ICh4LCBwcmVjLCBzdHlsZSkge1xuICBpZiAoIWlzRmluaXRlKHgpKSB7XG4gICAgaWYgKGlzTmFOKHgpKSByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcoXCJuYW5cIik7XG4gICAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nICgoeCA+IDApP1wiaW5maW5pdHlcIjpcIi1pbmZpbml0eVwiKTtcbiAgfVxuICB2YXIgc2lnbiA9ICh4PT0wICYmIDEveCA9PSAtSW5maW5pdHkpPzE6KHg+PTApPzA6MTtcbiAgaWYoc2lnbikgeCA9IC14O1xuICB2YXIgZXhwID0gMDtcbiAgaWYgKHggPT0gMCkgeyB9XG4gIGVsc2UgaWYgKHggPCAxKSB7XG4gICAgd2hpbGUgKHggPCAxICYmIGV4cCA+IC0xMDIyKSAgeyB4ICo9IDI7IGV4cC0tIH1cbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAoeCA+PSAyKSB7IHggLz0gMjsgZXhwKysgfVxuICB9XG4gIHZhciBleHBfc2lnbiA9IGV4cCA8IDAgPyAnJyA6ICcrJztcbiAgdmFyIHNpZ25fc3RyID0gJyc7XG4gIGlmIChzaWduKSBzaWduX3N0ciA9ICctJ1xuICBlbHNlIHtcbiAgICBzd2l0Y2goc3R5bGUpe1xuICAgIGNhc2UgNDMgLyogJysnICovOiBzaWduX3N0ciA9ICcrJzsgYnJlYWs7XG4gICAgY2FzZSAzMiAvKiAnICcgKi86IHNpZ25fc3RyID0gJyAnOyBicmVhaztcbiAgICBkZWZhdWx0OiBicmVhaztcbiAgICB9XG4gIH1cbiAgaWYgKHByZWMgPj0gMCAmJiBwcmVjIDwgMTMpIHtcbiAgICAvKiBJZiBhIHByZWNpc2lvbiBpcyBnaXZlbiwgYW5kIGlzIHNtYWxsLCByb3VuZCBtYW50aXNzYSBhY2NvcmRpbmdseSAqL1xuICAgIHZhciBjc3QgPSBNYXRoLnBvdygyLHByZWMgKiA0KTtcbiAgICB4ID0gTWF0aC5yb3VuZCh4ICogY3N0KSAvIGNzdDtcbiAgfVxuICB2YXIgeF9zdHIgPSB4LnRvU3RyaW5nKDE2KTtcbiAgaWYocHJlYyA+PSAwKXtcbiAgICB2YXIgaWR4ID0geF9zdHIuaW5kZXhPZignLicpO1xuICAgIGlmKGlkeDwwKSB7XG4gICAgICB4X3N0ciArPSAnLicgKyBjYW1sX3N0cl9yZXBlYXQocHJlYywgJzAnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2YXIgc2l6ZSA9IGlkeCsxK3ByZWM7XG4gICAgICBpZih4X3N0ci5sZW5ndGggPCBzaXplKVxuICAgICAgICB4X3N0ciArPSBjYW1sX3N0cl9yZXBlYXQoc2l6ZSAtIHhfc3RyLmxlbmd0aCwgJzAnKTtcbiAgICAgIGVsc2VcbiAgICAgICAgeF9zdHIgPSB4X3N0ci5zdWJzdHIoMCxzaXplKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nIChzaWduX3N0ciArICcweCcgKyB4X3N0ciArICdwJyArIGV4cF9zaWduICsgZXhwLnRvU3RyaW5nKDEwKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cyBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzICh4KSB7XG4gIHZhciBsbyA9IHgubG87XG4gIHZhciBtaSA9IHgubWk7XG4gIHZhciBoaSA9IHguaGk7XG4gIHZhciBleHAgPSAoaGkgJiAweDdmZmYpID4+IDQ7XG4gIGlmIChleHAgPT0gMjA0Nykge1xuICAgIGlmICgobG98bWl8KGhpJjB4ZikpID09IDApXG4gICAgICByZXR1cm4gKGhpICYgMHg4MDAwKT8oLUluZmluaXR5KTpJbmZpbml0eTtcbiAgICBlbHNlXG4gICAgICByZXR1cm4gTmFOO1xuICB9XG4gIHZhciBrID0gTWF0aC5wb3coMiwtMjQpO1xuICB2YXIgcmVzID0gKGxvKmsrbWkpKmsrKGhpJjB4Zik7XG4gIGlmIChleHAgPiAwKSB7XG4gICAgcmVzICs9IDE2O1xuICAgIHJlcyAqPSBNYXRoLnBvdygyLGV4cC0xMDI3KTtcbiAgfSBlbHNlXG4gICAgcmVzICo9IE1hdGgucG93KDIsLTEwMjYpO1xuICBpZiAoaGkgJiAweDgwMDApIHJlcyA9IC0gcmVzO1xuICByZXR1cm4gcmVzO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX25leHRhZnRlcl9mbG9hdCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzLCBjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQsIGNhbWxfaW50NjRfYWRkLCBjYW1sX2ludDY0X3N1YixjYW1sX2ludDY0X29mX2ludDMyXG5mdW5jdGlvbiBjYW1sX25leHRhZnRlcl9mbG9hdCAoeCx5KSB7XG4gIGlmKGlzTmFOKHgpIHx8IGlzTmFOKHkpKSByZXR1cm4gTmFOO1xuICBpZih4PT15KSByZXR1cm4geTtcbiAgaWYoeD09MCl7XG4gICAgaWYoeSA8IDApXG4gICAgICByZXR1cm4gLU1hdGgucG93KDIsIC0xMDc0KVxuICAgIGVsc2VcbiAgICAgIHJldHVybiBNYXRoLnBvdygyLCAtMTA3NClcbiAgfVxuICB2YXIgYml0cyA9IGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCh4KTtcbiAgdmFyIG9uZSA9IGNhbWxfaW50NjRfb2ZfaW50MzIoMSk7XG4gIGlmICgoeDx5KSA9PSAoeD4wKSlcbiAgICBiaXRzID0gY2FtbF9pbnQ2NF9hZGQoYml0cywgb25lKVxuICBlbHNlXG4gICAgYml0cyA9IGNhbWxfaW50NjRfc3ViKGJpdHMsIG9uZSlcbiAgcmV0dXJuIGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cyhiaXRzKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF90cnVuY19mbG9hdFxuZnVuY3Rpb24gY2FtbF90cnVuY19mbG9hdCh4KXtcbiAgcmV0dXJuIE1hdGgudHJ1bmMoeCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50MzJfZmxvYXRfb2ZfYml0cyBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQzMl9mbG9hdF9vZl9iaXRzICh4KSB7XG4gIHZhciBpbnQzMmEgPSBuZXcgam9vX2dsb2JhbF9vYmplY3QuSW50MzJBcnJheSgxKTtcbiAgaW50MzJhWzBdID0geDtcbiAgdmFyIGZsb2F0MzJhID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0LkZsb2F0MzJBcnJheShpbnQzMmEuYnVmZmVyKTtcbiAgcmV0dXJuIGZsb2F0MzJhWzBdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NsYXNzaWZ5X2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2NsYXNzaWZ5X2Zsb2F0ICh4KSB7XG4gIGlmIChpc0Zpbml0ZSAoeCkpIHtcbiAgICBpZiAoTWF0aC5hYnMoeCkgPj0gMi4yMjUwNzM4NTg1MDcyMDE0ZS0zMDgpIHJldHVybiAwO1xuICAgIGlmICh4ICE9IDApIHJldHVybiAxO1xuICAgIHJldHVybiAyO1xuICB9XG4gIHJldHVybiBpc05hTih4KT80OjM7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX21vZGZfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfbW9kZl9mbG9hdCAoeCkge1xuICBpZiAoaXNGaW5pdGUgKHgpKSB7XG4gICAgdmFyIG5lZyA9ICgxL3gpIDwgMDtcbiAgICB4ID0gTWF0aC5hYnMoeCk7XG4gICAgdmFyIGkgPSBNYXRoLmZsb29yICh4KTtcbiAgICB2YXIgZiA9IHggLSBpO1xuICAgIGlmIChuZWcpIHsgaSA9IC1pOyBmID0gLWY7IH1cbiAgICByZXR1cm4gWzAsIGYsIGldO1xuICB9XG4gIGlmIChpc05hTiAoeCkpIHJldHVybiBbMCwgTmFOLCBOYU5dO1xuICByZXR1cm4gWzAsIDEveCwgeF07XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2xkZXhwX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2xkZXhwX2Zsb2F0ICh4LGV4cCkge1xuICBleHAgfD0gMDtcbiAgaWYgKGV4cCA+IDEwMjMpIHtcbiAgICBleHAgLT0gMTAyMztcbiAgICB4ICo9IE1hdGgucG93KDIsIDEwMjMpO1xuICAgIGlmIChleHAgPiAxMDIzKSB7ICAvLyBpbiBjYXNlIHggaXMgc3Vibm9ybWFsXG4gICAgICBleHAgLT0gMTAyMztcbiAgICAgIHggKj0gTWF0aC5wb3coMiwgMTAyMyk7XG4gICAgfVxuICB9XG4gIGlmIChleHAgPCAtMTAyMykge1xuICAgIGV4cCArPSAxMDIzO1xuICAgIHggKj0gTWF0aC5wb3coMiwgLTEwMjMpO1xuICB9XG4gIHggKj0gTWF0aC5wb3coMiwgZXhwKTtcbiAgcmV0dXJuIHg7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2ZyZXhwX2Zsb2F0IGNvbnN0XG4vL1JlcXVpcmVzOiBqc29vX2Zsb29yX2xvZzJcbmZ1bmN0aW9uIGNhbWxfZnJleHBfZmxvYXQgKHgpIHtcbiAgaWYgKCh4ID09IDApIHx8ICFpc0Zpbml0ZSh4KSkgcmV0dXJuIFswLCB4LCAwXTtcbiAgdmFyIG5lZyA9IHggPCAwO1xuICBpZiAobmVnKSB4ID0gLSB4O1xuICB2YXIgZXhwID0gTWF0aC5tYXgoLTEwMjMsIGpzb29fZmxvb3JfbG9nMih4KSArIDEpO1xuICB4ICo9IE1hdGgucG93KDIsLWV4cCk7XG4gIHdoaWxlICh4IDwgMC41KSB7XG4gICAgeCAqPSAyO1xuICAgIGV4cC0tO1xuICB9XG4gIHdoaWxlICh4ID49IDEpIHtcbiAgICB4ICo9IDAuNTtcbiAgICBleHArKztcbiAgfVxuICBpZiAobmVnKSB4ID0gLSB4O1xuICByZXR1cm4gWzAsIHgsIGV4cF07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmxvYXRfY29tcGFyZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9mbG9hdF9jb21wYXJlICh4LCB5KSB7XG4gIGlmICh4ID09PSB5KSByZXR1cm4gMDtcbiAgaWYgKHggPCB5KSByZXR1cm4gLTE7XG4gIGlmICh4ID4geSkgcmV0dXJuIDE7XG4gIGlmICh4ID09PSB4KSByZXR1cm4gMTtcbiAgaWYgKHkgPT09IHkpIHJldHVybiAtMTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY29weXNpZ25fZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfY29weXNpZ25fZmxvYXQgKHgsIHkpIHtcbiAgaWYgKHkgPT0gMCkgeSA9IDEgLyB5O1xuICB4ID0gTWF0aC5hYnMoeCk7XG4gIHJldHVybiAoeSA8IDApPygteCk6eDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zaWduYml0X2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX3NpZ25iaXRfZmxvYXQoeCkge1xuICBpZiAoeCA9PSAwKSB4ID0gMSAvIHg7XG4gIHJldHVybiAoeCA8IDApPzE6MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9leHBtMV9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9leHBtMV9mbG9hdCAoeCkge1xuICB2YXIgeSA9IE1hdGguZXhwKHgpLCB6ID0geSAtIDE7XG4gIHJldHVybiAoTWF0aC5hYnMoeCk+MT96Oih6PT0wP3g6eCp6L01hdGgubG9nKHkpKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbG9nMXBfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfbG9nMXBfZmxvYXQgKHgpIHtcbiAgdmFyIHkgPSAxICsgeCwgeiA9IHkgLSAxO1xuICByZXR1cm4gKHo9PTA/eDp4Kk1hdGgubG9nKHkpL3opO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2h5cG90X2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2h5cG90X2Zsb2F0ICh4LCB5KSB7XG4gIHZhciB4ID0gTWF0aC5hYnMoeCksIHkgPSBNYXRoLmFicyh5KTtcbiAgdmFyIGEgPSBNYXRoLm1heCh4LCB5KSwgYiA9IE1hdGgubWluKHgseSkgLyAoYT9hOjEpO1xuICByZXR1cm4gKGEgKiBNYXRoLnNxcnQoMSArIGIqYikpO1xufVxuXG4vLyBGSVg6IHRoZXNlIGZpdmUgZnVuY3Rpb25zIG9ubHkgZ2l2ZSBhcHByb3hpbWF0ZSByZXN1bHRzLlxuLy9Qcm92aWRlczogY2FtbF9sb2cxMF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9sb2cxMF9mbG9hdCAoeCkgeyByZXR1cm4gTWF0aC5MT0cxMEUgKiBNYXRoLmxvZyh4KTsgfVxuLy9Qcm92aWRlczogY2FtbF9jb3NoX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2Nvc2hfZmxvYXQgKHgpIHsgcmV0dXJuIChNYXRoLmV4cCh4KSArIE1hdGguZXhwKC14KSkgLyAyOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX3NpbmhfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfc2luaF9mbG9hdCAoeCkgeyByZXR1cm4gKE1hdGguZXhwKHgpIC0gTWF0aC5leHAoLXgpKSAvIDI7IH1cbi8vUHJvdmlkZXM6IGNhbWxfdGFuaF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF90YW5oX2Zsb2F0ICh4KSB7XG4gIHZhciB5ID0gTWF0aC5leHAoeCksIHogPSBNYXRoLmV4cCgteCk7XG4gIHJldHVybiAoeSAtIHopIC8gKHkgKyB6KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9yb3VuZF9mbG9hdFxuZnVuY3Rpb24gY2FtbF9yb3VuZF9mbG9hdCAoeCkgeyByZXR1cm4gTWF0aC5yb3VuZCh4KTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2Zvcm1hdF9mbG9hdCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9wYXJzZV9mb3JtYXQsIGNhbWxfZmluaXNoX2Zvcm1hdHRpbmdcbmZ1bmN0aW9uIGNhbWxfZm9ybWF0X2Zsb2F0IChmbXQsIHgpIHtcbiAgZnVuY3Rpb24gdG9GaXhlZCh4LGRwKSB7XG4gICAgaWYgKE1hdGguYWJzKHgpIDwgMS4wKSB7XG4gICAgICByZXR1cm4geC50b0ZpeGVkKGRwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGUgPSBwYXJzZUludCh4LnRvU3RyaW5nKCkuc3BsaXQoJysnKVsxXSk7XG4gICAgICBpZiAoZSA+IDIwKSB7XG4gICAgICAgIGUgLT0gMjA7XG4gICAgICAgIHggLz0gTWF0aC5wb3coMTAsZSk7XG4gICAgICAgIHggKz0gKG5ldyBBcnJheShlKzEpKS5qb2luKCcwJyk7XG4gICAgICAgIGlmKGRwID4gMCkge1xuICAgICAgICAgIHggPSB4ICsgJy4nICsgKG5ldyBBcnJheShkcCsxKSkuam9pbignMCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4O1xuICAgICAgfVxuICAgICAgZWxzZSByZXR1cm4geC50b0ZpeGVkKGRwKVxuICAgIH1cbiAgfVxuICB2YXIgcywgZiA9IGNhbWxfcGFyc2VfZm9ybWF0KGZtdCk7XG4gIHZhciBwcmVjID0gKGYucHJlYyA8IDApPzY6Zi5wcmVjO1xuICBpZiAoeCA8IDAgfHwgKHggPT0gMCAmJiAxL3ggPT0gLUluZmluaXR5KSkgeyBmLnNpZ24gPSAtMTsgeCA9IC14OyB9XG4gIGlmIChpc05hTih4KSkgeyBzID0gXCJuYW5cIjsgZi5maWxsZXIgPSAnICc7IH1cbiAgZWxzZSBpZiAoIWlzRmluaXRlKHgpKSB7IHMgPSBcImluZlwiOyBmLmZpbGxlciA9ICcgJzsgfVxuICBlbHNlXG4gICAgc3dpdGNoIChmLmNvbnYpIHtcbiAgICBjYXNlICdlJzpcbiAgICAgIHZhciBzID0geC50b0V4cG9uZW50aWFsKHByZWMpO1xuICAgICAgLy8gZXhwb25lbnQgc2hvdWxkIGJlIGF0IGxlYXN0IHR3byBkaWdpdHNcbiAgICAgIHZhciBpID0gcy5sZW5ndGg7XG4gICAgICBpZiAocy5jaGFyQXQoaSAtIDMpID09ICdlJylcbiAgICAgICAgcyA9IHMuc2xpY2UgKDAsIGkgLSAxKSArICcwJyArIHMuc2xpY2UgKGkgLSAxKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2YnOlxuICAgICAgcyA9IHRvRml4ZWQoeCwgcHJlYyk7IGJyZWFrO1xuICAgIGNhc2UgJ2cnOlxuICAgICAgcHJlYyA9IHByZWM/cHJlYzoxO1xuICAgICAgcyA9IHgudG9FeHBvbmVudGlhbChwcmVjIC0gMSk7XG4gICAgICB2YXIgaiA9IHMuaW5kZXhPZignZScpO1xuICAgICAgdmFyIGV4cCA9ICtzLnNsaWNlKGogKyAxKTtcbiAgICAgIGlmIChleHAgPCAtNCB8fCB4ID49IDFlMjEgfHwgeC50b0ZpeGVkKDApLmxlbmd0aCA+IHByZWMpIHtcbiAgICAgICAgLy8gcmVtb3ZlIHRyYWlsaW5nIHplcm9lc1xuICAgICAgICB2YXIgaSA9IGogLSAxOyB3aGlsZSAocy5jaGFyQXQoaSkgPT0gJzAnKSBpLS07XG4gICAgICAgIGlmIChzLmNoYXJBdChpKSA9PSAnLicpIGktLTtcbiAgICAgICAgcyA9IHMuc2xpY2UoMCwgaSArIDEpICsgcy5zbGljZShqKTtcbiAgICAgICAgaSA9IHMubGVuZ3RoO1xuICAgICAgICBpZiAocy5jaGFyQXQoaSAtIDMpID09ICdlJylcbiAgICAgICAgICBzID0gcy5zbGljZSAoMCwgaSAtIDEpICsgJzAnICsgcy5zbGljZSAoaSAtIDEpO1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBwID0gcHJlYztcbiAgICAgICAgaWYgKGV4cCA8IDApIHsgcCAtPSBleHAgKyAxOyBzID0geC50b0ZpeGVkKHApOyB9XG4gICAgICAgIGVsc2Ugd2hpbGUgKHMgPSB4LnRvRml4ZWQocCksIHMubGVuZ3RoID4gcHJlYyArIDEpIHAtLTtcbiAgICAgICAgaWYgKHApIHtcbiAgICAgICAgICAvLyByZW1vdmUgdHJhaWxpbmcgemVyb2VzXG4gICAgICAgICAgdmFyIGkgPSBzLmxlbmd0aCAtIDE7IHdoaWxlIChzLmNoYXJBdChpKSA9PSAnMCcpIGktLTtcbiAgICAgICAgICBpZiAocy5jaGFyQXQoaSkgPT0gJy4nKSBpLS07XG4gICAgICAgICAgcyA9IHMuc2xpY2UoMCwgaSArIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gIHJldHVybiBjYW1sX2ZpbmlzaF9mb3JtYXR0aW5nKGYsIHMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2Zsb2F0X29mX3N0cmluZyAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoLCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2Zsb2F0X29mX3N0cmluZyhzKSB7XG4gIHZhciByZXM7XG4gIHMgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKHMpXG4gIHJlcyA9ICtzO1xuICBpZiAoKHMubGVuZ3RoID4gMCkgJiYgKHJlcyA9PT0gcmVzKSkgcmV0dXJuIHJlcztcbiAgcyA9IHMucmVwbGFjZSgvXy9nLFwiXCIpO1xuICByZXMgPSArcztcbiAgaWYgKCgocy5sZW5ndGggPiAwKSAmJiAocmVzID09PSByZXMpKSB8fCAvXlsrLV0/bmFuJC9pLnRlc3QocykpIHJldHVybiByZXM7XG4gIHZhciBtID0gL14gKihbKy1dPykweChbMC05YS1mXSspXFwuPyhbMC05YS1mXSopcChbKy1dP1swLTldKykvaS5leGVjKHMpO1xuICAvLyAgICAgICAgICAxICAgICAgICAyICAgICAgICAgICAgIDMgICAgICAgICAgIDRcbiAgaWYobSl7XG4gICAgdmFyIG0zID0gbVszXS5yZXBsYWNlKC8wKyQvLCcnKTtcbiAgICB2YXIgbWFudGlzc2EgPSBwYXJzZUludChtWzFdICsgbVsyXSArIG0zLCAxNik7XG4gICAgdmFyIGV4cG9uZW50ID0gKG1bNF18MCkgLSA0Km0zLmxlbmd0aDtcbiAgICByZXMgPSBtYW50aXNzYSAqIE1hdGgucG93KDIsIGV4cG9uZW50KTtcbiAgICByZXR1cm4gcmVzO1xuICB9XG4gIGlmKC9eXFwrP2luZihpbml0eSk/JC9pLnRlc3QocykpIHJldHVybiBJbmZpbml0eTtcbiAgaWYoL14taW5mKGluaXR5KT8kL2kudGVzdChzKSkgcmV0dXJuIC1JbmZpbml0eTtcbiAgY2FtbF9mYWlsd2l0aChcImZsb2F0X29mX3N0cmluZ1wiKTtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxNCBKw6lyw7RtZSBWb3VpbGxvbiwgSHVnbyBIZXV6YXJkXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vLy8vLy8vLy8vLy8gRHVtbXkgZmlsZXN5c3RlbVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2N1cnJlbnRfZGlyXG5pZihqb29fZ2xvYmFsX29iamVjdC5wcm9jZXNzICYmIGpvb19nbG9iYWxfb2JqZWN0LnByb2Nlc3MuY3dkKVxuICB2YXIgY2FtbF9jdXJyZW50X2RpciA9IGpvb19nbG9iYWxfb2JqZWN0LnByb2Nlc3MuY3dkKCkucmVwbGFjZSgvXFxcXC9nLCcvJyk7XG5lbHNlXG4gIHZhciBjYW1sX2N1cnJlbnRfZGlyID0gIFwiL3N0YXRpY1wiO1xuaWYoY2FtbF9jdXJyZW50X2Rpci5zbGljZSgtMSkgIT09IFwiL1wiKSBjYW1sX2N1cnJlbnRfZGlyICs9IFwiL1wiXG5cbi8vUHJvdmlkZXM6IGNhbWxfcm9vdFxuLy9SZXF1aXJlczogY2FtbF9jdXJyZW50X2RpclxudmFyIGNhbWxfcm9vdCA9IGNhbWxfY3VycmVudF9kaXIubWF0Y2goL1teXFwvXSpcXC8vKVswXTtcblxuXG4vL1Byb3ZpZGVzOiBNbEZpbGVcbmZ1bmN0aW9uIE1sRmlsZSgpeyAgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21ha2VfcGF0aFxuLy9SZXF1aXJlczogY2FtbF9jdXJyZW50X2RpclxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfbWFrZV9wYXRoIChuYW1lKSB7XG4gIG5hbWU9Y2FtbF9qc3N0cmluZ19vZl9zdHJpbmcobmFtZSk7XG4gIGlmKG5hbWUuY2hhckNvZGVBdCgwKSAhPSA0NylcbiAgICBuYW1lID0gY2FtbF9jdXJyZW50X2RpciArIG5hbWU7XG4gIHZhciBjb21wID0gbmFtZS5zcGxpdChcIi9cIik7XG4gIHZhciBuY29tcCA9IFtdXG4gIGZvcih2YXIgaSA9IDA7IGk8Y29tcC5sZW5ndGg7IGkrKyl7XG4gICAgc3dpdGNoKGNvbXBbaV0pe1xuICAgIGNhc2UgXCIuLlwiOiBpZihuY29tcC5sZW5ndGg+MSkgbmNvbXAucG9wKCk7IGJyZWFrO1xuICAgIGNhc2UgXCIuXCI6IGJyZWFrO1xuICAgIGNhc2UgXCJcIjogaWYobmNvbXAubGVuZ3RoID09IDApIG5jb21wLnB1c2goXCJcIik7IGJyZWFrO1xuICAgIGRlZmF1bHQ6IG5jb21wLnB1c2goY29tcFtpXSk7YnJlYWtcbiAgICB9XG4gIH1cbiAgbmNvbXAub3JpZyA9IG5hbWU7XG4gIHJldHVybiBuY29tcDtcbn1cblxuLy9Qcm92aWRlczpqc29vX21vdW50X3BvaW50XG4vL1JlcXVpcmVzOiBNbEZha2VEZXZpY2UsIE1sTm9kZURldmljZSwgY2FtbF9yb290LCBmc19ub2RlX3N1cHBvcnRlZFxudmFyIGpzb29fbW91bnRfcG9pbnQgPSBbXVxuaWYgKGZzX25vZGVfc3VwcG9ydGVkKCkpIHtcbiAganNvb19tb3VudF9wb2ludC5wdXNoKHtwYXRoOmNhbWxfcm9vdCxkZXZpY2U6bmV3IE1sTm9kZURldmljZShjYW1sX3Jvb3QpfSk7XG59IGVsc2Uge1xuICBqc29vX21vdW50X3BvaW50LnB1c2goe3BhdGg6Y2FtbF9yb290LGRldmljZTpuZXcgTWxGYWtlRGV2aWNlKGNhbWxfcm9vdCl9KTtcbn1cbmpzb29fbW91bnRfcG9pbnQucHVzaCh7cGF0aDpjYW1sX3Jvb3QrXCJzdGF0aWMvXCIsIGRldmljZTpuZXcgTWxGYWtlRGV2aWNlKGNhbWxfcm9vdCtcInN0YXRpYy9cIil9KTtcblxuLy9Qcm92aWRlczpjYW1sX2xpc3RfbW91bnRfcG9pbnRcbi8vUmVxdWlyZXM6IGpzb29fbW91bnRfcG9pbnQsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfbGlzdF9tb3VudF9wb2ludCgpe1xuICB2YXIgcHJldiA9IDBcbiAgZm9yKHZhciBpID0gMDsgaSA8IGpzb29fbW91bnRfcG9pbnQubGVuZ3RoOyBpKyspe1xuICAgIHZhciBvbGQgPSBwcmV2O1xuICAgIHByZXYgPSBbMCwgY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhqc29vX21vdW50X3BvaW50W2ldLnBhdGgpLCBvbGRdXG4gIH1cbiAgcmV0dXJuIHByZXY7XG59XG5cbi8vUHJvdmlkZXM6IHJlc29sdmVfZnNfZGV2aWNlXG4vL1JlcXVpcmVzOiBjYW1sX21ha2VfcGF0aCwganNvb19tb3VudF9wb2ludFxuZnVuY3Rpb24gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSl7XG4gIHZhciBwYXRoID0gY2FtbF9tYWtlX3BhdGgobmFtZSk7XG4gIHZhciBuYW1lID0gcGF0aC5qb2luKFwiL1wiKTtcbiAgdmFyIG5hbWVfc2xhc2ggPSBuYW1lICsgXCIvXCI7XG4gIHZhciByZXM7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBqc29vX21vdW50X3BvaW50Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG0gPSBqc29vX21vdW50X3BvaW50W2ldO1xuICAgIGlmKG5hbWVfc2xhc2guc2VhcmNoKG0ucGF0aCkgPT0gMFxuICAgICAgICYmICghcmVzIHx8IHJlcy5wYXRoLmxlbmd0aCA8IG0ucGF0aC5sZW5ndGgpKVxuICAgICAgcmVzID0ge3BhdGg6bS5wYXRoLGRldmljZTptLmRldmljZSxyZXN0Om5hbWUuc3Vic3RyaW5nKG0ucGF0aC5sZW5ndGgsbmFtZS5sZW5ndGgpfTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21vdW50X2F1dG9sb2FkXG4vL1JlcXVpcmVzOiBNbEZha2VEZXZpY2UsIGNhbWxfbWFrZV9wYXRoLCBqc29vX21vdW50X3BvaW50XG5mdW5jdGlvbiBjYW1sX21vdW50X2F1dG9sb2FkKG5hbWUsZil7XG4gIHZhciBwYXRoID0gY2FtbF9tYWtlX3BhdGgobmFtZSk7XG4gIHZhciBuYW1lID0gcGF0aC5qb2luKFwiL1wiKSArIFwiL1wiO1xuICBqc29vX21vdW50X3BvaW50LnB1c2goe3BhdGg6bmFtZSxkZXZpY2U6bmV3IE1sRmFrZURldmljZShuYW1lLGYpfSlcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5tb3VudFxuLy9SZXF1aXJlczoganNvb19tb3VudF9wb2ludCwgY2FtbF9tYWtlX3BhdGhcbmZ1bmN0aW9uIGNhbWxfdW5tb3VudChuYW1lKXtcbiAgdmFyIHBhdGggPSBjYW1sX21ha2VfcGF0aChuYW1lKTtcbiAgdmFyIG5hbWUgPSBwYXRoLmpvaW4oXCIvXCIpICsgXCIvXCI7XG4gIHZhciBpZHggPSAtMTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGpzb29fbW91bnRfcG9pbnQubGVuZ3RoOyBpKyspXG4gICAgaWYoanNvb19tb3VudF9wb2ludFtpXS5wYXRoID09IG5hbWUpIGlkeCA9IGk7XG4gIGlmKGlkeCA+IC0xKSBqc29vX21vdW50X3BvaW50LnNwbGljZShpZHgsMSk7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2dldGN3ZFxuLy9SZXF1aXJlczogY2FtbF9jdXJyZW50X2RpciwgY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9zeXNfZ2V0Y3dkKCkge1xuICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhjYW1sX2N1cnJlbnRfZGlyKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfY2hkaXJcbi8vUmVxdWlyZXM6IGNhbWxfY3VycmVudF9kaXIsIGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlLCByZXNvbHZlX2ZzX2RldmljZVxuZnVuY3Rpb24gY2FtbF9zeXNfY2hkaXIoZGlyKSB7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UoZGlyKTtcbiAgaWYocm9vdC5kZXZpY2UuZXhpc3RzKHJvb3QucmVzdCkpIHtcbiAgICBpZihyb290LnJlc3QpIGNhbWxfY3VycmVudF9kaXIgPSByb290LnBhdGggKyByb290LnJlc3QgKyBcIi9cIjtcbiAgICBlbHNlIGNhbWxfY3VycmVudF9kaXIgPSByb290LnBhdGg7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgZWxzZSB7XG4gICAgY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUoZGlyKTtcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXNfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlKG5hbWUpe1xuICBuYW1lID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhuYW1lKTtcbiAgY2FtbF9yYWlzZV9zeXNfZXJyb3IgKG5hbWUgKyBcIjogTm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeVwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV9ub3RfYV9kaXJcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfc3lzX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3JhaXNlX25vdF9hX2RpcihuYW1lKXtcbiAgbmFtZSA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcobmFtZSk7XG4gIGNhbWxfcmFpc2Vfc3lzX2Vycm9yIChuYW1lICsgXCI6IE5vdCBhIGRpcmVjdG9yeVwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfZmlsZV9leGlzdHNcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlXG5mdW5jdGlvbiBjYW1sX3N5c19maWxlX2V4aXN0cyAobmFtZSkge1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICByZXR1cm4gcm9vdC5kZXZpY2UuZXhpc3RzKHJvb3QucmVzdCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX3JlYWRfZGlyZWN0b3J5XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX25vdF9hX2RpciwgcmVzb2x2ZV9mc19kZXZpY2VcbmZ1bmN0aW9uIGNhbWxfc3lzX3JlYWRfZGlyZWN0b3J5KG5hbWUpe1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICB2YXIgYSA9IHJvb3QuZGV2aWNlLnJlYWRkaXIocm9vdC5yZXN0KTtcbiAgdmFyIGwgPSBuZXcgQXJyYXkoYS5sZW5ndGggKyAxKTtcbiAgbFswXSA9IDA7XG4gIGZvcih2YXIgaT0wO2k8YS5sZW5ndGg7aSsrKVxuICAgIGxbaSsxXSA9IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoYVtpXSk7XG4gIHJldHVybiBsO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19yZW1vdmVcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlLCByZXNvbHZlX2ZzX2RldmljZVxuZnVuY3Rpb24gY2FtbF9zeXNfcmVtb3ZlKG5hbWUpe1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICB2YXIgb2sgPSByb290LmRldmljZS51bmxpbmsocm9vdC5yZXN0KTtcbiAgaWYob2sgPT0gMCkgY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUobmFtZSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19pc19kaXJlY3Rvcnlcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlXG5mdW5jdGlvbiBjYW1sX3N5c19pc19kaXJlY3RvcnkobmFtZSl7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIHZhciBhID0gcm9vdC5kZXZpY2UuaXNfZGlyKHJvb3QucmVzdCk7XG4gIHJldHVybiBhPzE6MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfcmVuYW1lXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoLCByZXNvbHZlX2ZzX2RldmljZVxuZnVuY3Rpb24gY2FtbF9zeXNfcmVuYW1lKG8sbil7XG4gIHZhciBvX3Jvb3QgPSByZXNvbHZlX2ZzX2RldmljZShvKTtcbiAgdmFyIG5fcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG4pO1xuICBpZihvX3Jvb3QuZGV2aWNlICE9IG5fcm9vdC5kZXZpY2UpXG4gICAgY2FtbF9mYWlsd2l0aChcImNhbWxfc3lzX3JlbmFtZTogY2Fubm90IG1vdmUgZmlsZSBiZXR3ZWVuIHR3byBmaWxlc3lzdGVtXCIpO1xuICBpZighb19yb290LmRldmljZS5yZW5hbWUpXG4gICAgY2FtbF9mYWlsd2l0aChcImNhbWxfc3lzX3JlbmFtZTogbm8gaW1wbGVtZW50ZWRcIik7XG4gIG9fcm9vdC5kZXZpY2UucmVuYW1lKG9fcm9vdC5yZXN0LCBuX3Jvb3QucmVzdCk7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9iYV9tYXBfZmlsZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9iYV9tYXBfZmlsZSh2ZmQsIGtpbmQsIGxheW91dCwgc2hhcmVkLCBkaW1zLCBwb3MpIHtcbiAgLy8gdmFyIGRhdGEgPSBjYW1sX2dsb2JhbF9kYXRhLmZkc1t2ZmRdO1xuICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9iYV9tYXBfZmlsZSBub3QgaW1wbGVtZW50ZWRcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfbWFwX2ZpbGVfYnl0ZWNvZGVcbi8vUmVxdWlyZXM6IGNhbWxfYmFfbWFwX2ZpbGVcbmZ1bmN0aW9uIGNhbWxfYmFfbWFwX2ZpbGVfYnl0ZWNvZGUoYXJndixhcmduKXtcbiAgcmV0dXJuIGNhbWxfYmFfbWFwX2ZpbGUoYXJndlswXSxhcmd2WzFdLGFyZ3ZbMl0sYXJndlszXSxhcmd2WzRdLGFyZ3ZbNV0pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NyZWF0ZV9maWxlX2V4dGVyblxuZnVuY3Rpb24gY2FtbF9jcmVhdGVfZmlsZV9leHRlcm4obmFtZSxjb250ZW50KXtcbiAgaWYoam9vX2dsb2JhbF9vYmplY3QuY2FtbF9jcmVhdGVfZmlsZSlcbiAgICBqb29fZ2xvYmFsX29iamVjdC5jYW1sX2NyZWF0ZV9maWxlKG5hbWUsY29udGVudCk7XG4gIGVsc2Uge1xuICAgIGlmKCFqb29fZ2xvYmFsX29iamVjdC5jYW1sX2ZzX3RtcCkgam9vX2dsb2JhbF9vYmplY3QuY2FtbF9mc190bXAgPSBbXTtcbiAgICBqb29fZ2xvYmFsX29iamVjdC5jYW1sX2ZzX3RtcC5wdXNoKHtuYW1lOm5hbWUsY29udGVudDpjb250ZW50fSk7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZnNfaW5pdFxuLy9SZXF1aXJlczogY2FtbF9jcmVhdGVfZmlsZVxuZnVuY3Rpb24gY2FtbF9mc19pbml0ICgpe1xuICB2YXIgdG1wPWpvb19nbG9iYWxfb2JqZWN0LmNhbWxfZnNfdG1wXG4gIGlmKHRtcCl7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHRtcC5sZW5ndGg7IGkrKyl7XG4gICAgICBjYW1sX2NyZWF0ZV9maWxlKHRtcFtpXS5uYW1lLHRtcFtpXS5jb250ZW50KTtcbiAgICB9XG4gIH1cbiAgam9vX2dsb2JhbF9vYmplY3QuY2FtbF9jcmVhdGVfZmlsZSA9IGNhbWxfY3JlYXRlX2ZpbGU7XG4gIGpvb19nbG9iYWxfb2JqZWN0LmNhbWxfZnNfdG1wID0gW107XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NyZWF0ZV9maWxlXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoLCByZXNvbHZlX2ZzX2RldmljZSwgY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9jcmVhdGVfZmlsZShuYW1lLGNvbnRlbnQpIHtcbiAgdmFyIG5hbWUgPSAodHlwZW9mIG5hbWUgPT0gXCJzdHJpbmdcIik/Y2FtbF9zdHJpbmdfb2ZfanNieXRlcyhuYW1lKTpuYW1lO1xuICB2YXIgY29udGVudCA9ICh0eXBlb2YgY29udGVudCA9PSBcInN0cmluZ1wiKT9jYW1sX3N0cmluZ19vZl9qc2J5dGVzKGNvbnRlbnQpOmNvbnRlbnQ7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIGlmKCEgcm9vdC5kZXZpY2UucmVnaXN0ZXIpIGNhbWxfZmFpbHdpdGgoXCJjYW5ub3QgcmVnaXN0ZXIgZmlsZVwiKTtcbiAgcm9vdC5kZXZpY2UucmVnaXN0ZXIocm9vdC5yZXN0LGNvbnRlbnQpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9yZWFkX2ZpbGVfY29udGVudFxuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2UsIGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlLCBjYW1sX2NyZWF0ZV9ieXRlcywgY2FtbF9zdHJpbmdfb2ZfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfcmVhZF9maWxlX2NvbnRlbnQgKG5hbWUpIHtcbiAgdmFyIG5hbWUgPSAodHlwZW9mIG5hbWUgPT0gXCJzdHJpbmdcIik/Y2FtbF9zdHJpbmdfb2ZfanNieXRlcyhuYW1lKTpuYW1lO1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICBpZihyb290LmRldmljZS5leGlzdHMocm9vdC5yZXN0KSkge1xuICAgIHZhciBmaWxlID0gcm9vdC5kZXZpY2Uub3Blbihyb290LnJlc3Qse3Jkb25seToxfSk7XG4gICAgdmFyIGxlbiAgPSBmaWxlLmxlbmd0aCgpO1xuICAgIHZhciBidWYgID0gY2FtbF9jcmVhdGVfYnl0ZXMobGVuKTtcbiAgICBmaWxlLnJlYWQoMCxidWYsMCxsZW4pO1xuICAgIHJldHVybiBjYW1sX3N0cmluZ19vZl9ieXRlcyhidWYpXG4gIH1cbiAgY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUobmFtZSk7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vLy8vLy8vLy8vLy8vIFN5c1xuXG4vL1Byb3ZpZGVzOiBjYW1sX3JhaXNlX3N5c19lcnJvciAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3dpdGhfc3RyaW5nLCBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX3JhaXNlX3N5c19lcnJvciAobXNnKSB7XG4gIGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcoY2FtbF9nbG9iYWxfZGF0YS5TeXNfZXJyb3IsIG1zZyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2V4aXRcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9zeXNfZXhpdCAoY29kZSkge1xuICB2YXIgZyA9IGpvb19nbG9iYWxfb2JqZWN0O1xuICBpZihnLnF1aXQpIGcucXVpdChjb2RlKTtcbiAgLy9ub2RlanNcbiAgaWYoZy5wcm9jZXNzICYmIGcucHJvY2Vzcy5leGl0KVxuICAgIGcucHJvY2Vzcy5leGl0KGNvZGUpO1xuICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJGdW5jdGlvbiAnZXhpdCcgbm90IGltcGxlbWVudGVkXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3NldF9zdGF0aWNfZW52XG5mdW5jdGlvbiBjYW1sX3NldF9zdGF0aWNfZW52KGssdil7XG4gIGlmKCFqb29fZ2xvYmFsX29iamVjdC5qc29vX3N0YXRpY19lbnYpXG4gICAgam9vX2dsb2JhbF9vYmplY3QuanNvb19zdGF0aWNfZW52ID0ge31cbiAgam9vX2dsb2JhbF9vYmplY3QuanNvb19zdGF0aWNfZW52W2tdID0gdjtcbiAgcmV0dXJuIDA7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19nZXRlbnYgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9ub3RfZm91bmRcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9zeXNfZ2V0ZW52IChuYW1lKSB7XG4gIHZhciBnID0gam9vX2dsb2JhbF9vYmplY3Q7XG4gIHZhciBuID0gY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcobmFtZSk7XG4gIC8vbm9kZWpzIGVudlxuICBpZihnLnByb2Nlc3NcbiAgICAgJiYgZy5wcm9jZXNzLmVudlxuICAgICAmJiBnLnByb2Nlc3MuZW52W25dICE9IHVuZGVmaW5lZClcbiAgICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcoZy5wcm9jZXNzLmVudltuXSk7XG4gIGlmKGpvb19nbG9iYWxfb2JqZWN0Lmpzb29fc3RhdGljX2VudlxuICAgICAmJiBqb29fZ2xvYmFsX29iamVjdC5qc29vX3N0YXRpY19lbnZbbl0pXG4gICAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKGpvb19nbG9iYWxfb2JqZWN0Lmpzb29fc3RhdGljX2VudltuXSlcbiAgY2FtbF9yYWlzZV9ub3RfZm91bmQgKCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX3Vuc2FmZV9nZXRlbnZcbi8vUmVxdWlyZXM6IGNhbWxfc3lzX2dldGVudlxuZnVuY3Rpb24gY2FtbF9zeXNfdW5zYWZlX2dldGVudihuYW1lKXtcbiAgcmV0dXJuIGNhbWxfc3lzX2dldGVudiAobmFtZSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYXJndlxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmdcbnZhciBjYW1sX2FyZ3YgPSAoKGZ1bmN0aW9uICgpIHtcbiAgdmFyIGcgPSBqb29fZ2xvYmFsX29iamVjdDtcbiAgdmFyIG1haW4gPSBcImEub3V0XCI7XG4gIHZhciBhcmdzID0gW11cblxuICBpZihnLnByb2Nlc3NcbiAgICAgJiYgZy5wcm9jZXNzLmFyZ3ZcbiAgICAgJiYgZy5wcm9jZXNzLmFyZ3YubGVuZ3RoID4gMSkge1xuICAgIHZhciBhcmd2ID0gZy5wcm9jZXNzLmFyZ3ZcbiAgICAvL25vZGVqc1xuICAgIG1haW4gPSBhcmd2WzFdO1xuICAgIGFyZ3MgPSBhcmd2LnNsaWNlKDIpO1xuICB9XG5cbiAgdmFyIHAgPSBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhtYWluKTtcbiAgdmFyIGFyZ3MyID0gWzAsIHBdO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKylcbiAgICBhcmdzMi5wdXNoKGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKGFyZ3NbaV0pKTtcbiAgcmV0dXJuIGFyZ3MyO1xufSkoKSlcblxuLy9Qcm92aWRlczogY2FtbF9leGVjdXRhYmxlX25hbWVcbi8vUmVxdWlyZXM6IGNhbWxfYXJndlxudmFyIGNhbWxfZXhlY3V0YWJsZV9uYW1lID0gY2FtbF9hcmd2WzFdXG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2dldF9hcmd2XG4vL1JlcXVpcmVzOiBjYW1sX2FyZ3ZcbmZ1bmN0aW9uIGNhbWxfc3lzX2dldF9hcmd2IChhKSB7XG4gIHJldHVybiBbMCwgY2FtbF9hcmd2WzFdLCBjYW1sX2FyZ3ZdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19hcmd2XG4vL1JlcXVpcmVzOiBjYW1sX2FyZ3ZcbmZ1bmN0aW9uIGNhbWxfc3lzX2FyZ3YgKGEpIHtcbiAgcmV0dXJuIGNhbWxfYXJndjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfbW9kaWZ5X2FyZ3Zcbi8vUmVxdWlyZXM6IGNhbWxfYXJndlxuZnVuY3Rpb24gY2FtbF9zeXNfbW9kaWZ5X2FyZ3YoYXJnKXtcbiAgY2FtbF9hcmd2ID0gYXJnO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfZXhlY3V0YWJsZV9uYW1lIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2V4ZWN1dGFibGVfbmFtZVxuZnVuY3Rpb24gY2FtbF9zeXNfZXhlY3V0YWJsZV9uYW1lKGEpe1xuICByZXR1cm4gY2FtbF9leGVjdXRhYmxlX25hbWVcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfc3lzdGVtX2NvbW1hbmRcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N5c19zeXN0ZW1fY29tbWFuZChjbWQpe1xuICB2YXIgY21kID0gY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcoY21kKTtcbiAgaWYgKHR5cGVvZiByZXF1aXJlICE9IFwidW5kZWZpbmVkXCJcbiAgICAgICYmIHJlcXVpcmUoJ2NoaWxkX3Byb2Nlc3MnKVxuICAgICAgJiYgcmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpLmV4ZWNTeW5jKSB7XG4gICAgdHJ5IHtyZXF1aXJlKCdjaGlsZF9wcm9jZXNzJykuZXhlY1N5bmMoY21kLHtzdGRpbzogJ2luaGVyaXQnfSk7IHJldHVybiAwfVxuICAgIGNhdGNoIChlKSB7cmV0dXJuIDF9XG4gIH1cbiAgZWxzZSByZXR1cm4gMTI3O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c190aW1lIG11dGFibGVcbnZhciBjYW1sX2luaXRpYWxfdGltZSA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkgKiAwLjAwMTtcbmZ1bmN0aW9uIGNhbWxfc3lzX3RpbWUgKCkge1xuICB2YXIgbm93ID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcbiAgcmV0dXJuIG5vdyAqIDAuMDAxIC0gY2FtbF9pbml0aWFsX3RpbWU7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX3RpbWVfaW5jbHVkZV9jaGlsZHJlblxuLy9SZXF1aXJlczogY2FtbF9zeXNfdGltZVxuZnVuY3Rpb24gY2FtbF9zeXNfdGltZV9pbmNsdWRlX2NoaWxkcmVuKGIpIHtcbiAgcmV0dXJuIGNhbWxfc3lzX3RpbWUoKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfcmFuZG9tX3NlZWQgbXV0YWJsZVxuLy9UaGUgZnVuY3Rpb24gbmVlZHMgdG8gcmV0dXJuIGFuIGFycmF5IHNpbmNlIE9DYW1sIDQuMC4uLlxuZnVuY3Rpb24gY2FtbF9zeXNfcmFuZG9tX3NlZWQgKCkge1xuICB2YXIgbm93ID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcbiAgdmFyIHggPSBub3deMHhmZmZmZmZmZipNYXRoLnJhbmRvbSgpO1xuICByZXR1cm4gWzAseF07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X2JpZ19lbmRpYW4gY29uc3RcbmZ1bmN0aW9uIGNhbWxfc3lzX2NvbnN0X2JpZ19lbmRpYW4gKCkgeyByZXR1cm4gMDsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jb25zdF93b3JkX3NpemUgY29uc3RcbmZ1bmN0aW9uIGNhbWxfc3lzX2NvbnN0X3dvcmRfc2l6ZSAoKSB7IHJldHVybiAzMjsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jb25zdF9pbnRfc2l6ZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9zeXNfY29uc3RfaW50X3NpemUgKCkgeyByZXR1cm4gMzI7IH1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfY29uc3RfbWF4X3dvc2l6ZSBjb25zdFxuLy8gbWF4X2ludCAvIDQgc28gdGhhdCB0aGUgZm9sbG93aW5nIGRvZXMgbm90IG92ZXJmbG93XG4vL2xldCBtYXhfc3RyaW5nX2xlbmd0aCA9IHdvcmRfc2l6ZSAvIDggKiBtYXhfYXJyYXlfbGVuZ3RoIC0gMTs7XG5mdW5jdGlvbiBjYW1sX3N5c19jb25zdF9tYXhfd29zaXplICgpIHsgcmV0dXJuICgweDdGRkZGRkZGLzQpIHwgMDt9XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X29zdHlwZV91bml4IGNvbnN0XG5mdW5jdGlvbiBjYW1sX3N5c19jb25zdF9vc3R5cGVfdW5peCAoKSB7IHJldHVybiAxOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jb25zdF9vc3R5cGVfd2luMzIgY29uc3RcbmZ1bmN0aW9uIGNhbWxfc3lzX2NvbnN0X29zdHlwZV93aW4zMiAoKSB7IHJldHVybiAwOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jb25zdF9vc3R5cGVfY3lnd2luIGNvbnN0XG5mdW5jdGlvbiBjYW1sX3N5c19jb25zdF9vc3R5cGVfY3lnd2luICgpIHsgcmV0dXJuIDA7IH1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfY29uc3RfYmFja2VuZF90eXBlIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX3N5c19jb25zdF9iYWNrZW5kX3R5cGUgKCkge1xuICByZXR1cm4gWzAsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoXCJqc19vZl9vY2FtbFwiKV07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2dldF9jb25maWcgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfc3lzX2dldF9jb25maWcgKCkge1xuICByZXR1cm4gWzAsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoXCJVbml4XCIpLCAzMiwgMF07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2lzYXR0eVxuZnVuY3Rpb24gY2FtbF9zeXNfaXNhdHR5KF9jaGFuKSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3J1bnRpbWVfdmFyaWFudFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9ydW50aW1lX3ZhcmlhbnQoX3VuaXQpIHtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoXCJcIik7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX3J1bnRpbWVfcGFyYW1ldGVyc1xuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9ydW50aW1lX3BhcmFtZXRlcnMoX3VuaXQpIHtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoXCJcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW5zdGFsbF9zaWduYWxfaGFuZGxlciBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnN0YWxsX3NpZ25hbF9oYW5kbGVyKCl7cmV0dXJuIDB9XG5cbi8vUHJvdmlkZXM6IHVuaXhfaW5ldF9hZGRyX29mX3N0cmluZ1xuZnVuY3Rpb24gdW5peF9pbmV0X2FkZHJfb2Zfc3RyaW5nICgpIHtyZXR1cm4gMDt9XG5cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX3J1bnRpbWVfd2FybmluZ3NcbnZhciBjYW1sX3J1bnRpbWVfd2FybmluZ3MgPSAwO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2VuYWJsZV9ydW50aW1lX3dhcm5pbmdzXG4vL1JlcXVpcmVzOiBjYW1sX3J1bnRpbWVfd2FybmluZ3NcbmZ1bmN0aW9uIGNhbWxfbWxfZW5hYmxlX3J1bnRpbWVfd2FybmluZ3MgKGJvb2wpIHtcbiAgY2FtbF9ydW50aW1lX3dhcm5pbmdzID0gYm9vbDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfcnVudGltZV93YXJuaW5nc19lbmFibGVkXG4vL1JlcXVpcmVzOiBjYW1sX3J1bnRpbWVfd2FybmluZ3NcbmZ1bmN0aW9uIGNhbWxfbWxfcnVudGltZV93YXJuaW5nc19lbmFibGVkIChfdW5pdCkge1xuICByZXR1cm4gY2FtbF9ydW50aW1lX3dhcm5pbmdzO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfc3BhY2V0aW1lX2VuYWJsZWQgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9zcGFjZXRpbWVfZW5hYmxlZChfdW5pdCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfY29uc3RfbmFrZWRfcG9pbnRlcnNfY2hlY2tlZCBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX3N5c19jb25zdF9uYWtlZF9wb2ludGVyc19jaGVja2VkKF91bml0KSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JlZ2lzdGVyX2NoYW5uZWxfZm9yX3NwYWNldGltZSBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX3JlZ2lzdGVyX2NoYW5uZWxfZm9yX3NwYWNldGltZShfY2hhbm5lbCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zcGFjZXRpbWVfb25seV93b3Jrc19mb3JfbmF0aXZlX2NvZGVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfc3BhY2V0aW1lX29ubHlfd29ya3NfZm9yX25hdGl2ZV9jb2RlKCkge1xuICBjYW1sX2ZhaWx3aXRoKFwiU3BhY2V0aW1lIHByb2ZpbGluZyBvbmx5IHdvcmtzIGZvciBuYXRpdmUgY29kZVwiKTtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxNCBKw6lyw7RtZSBWb3VpbGxvbiwgSHVnbyBIZXV6YXJkXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUHJvdmlkZXM6IE1sRmFrZURldmljZVxuLy9SZXF1aXJlczogTWxGYWtlRmlsZSwgY2FtbF9jcmVhdGVfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfc3lzX2Vycm9yLCBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZVxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlcywgY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfb2ZfYXJyYXksIGNhbWxfYnl0ZXNfb2Zfc3RyaW5nLCBjYW1sX2J5dGVzX29mX2pzYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfaXNfbWxfYnl0ZXMsIGNhbWxfaXNfbWxfc3RyaW5nXG5mdW5jdGlvbiBNbEZha2VEZXZpY2UgKHJvb3QsIGYpIHtcbiAgdGhpcy5jb250ZW50PXt9O1xuICB0aGlzLnJvb3QgPSByb290O1xuICB0aGlzLmxvb2t1cEZ1biA9IGY7XG59XG5NbEZha2VEZXZpY2UucHJvdG90eXBlLm5tID0gZnVuY3Rpb24obmFtZSkge1xuICByZXR1cm4gKHRoaXMucm9vdCArIG5hbWUpO1xufVxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5sb29rdXAgPSBmdW5jdGlvbihuYW1lKSB7XG4gIGlmKCF0aGlzLmNvbnRlbnRbbmFtZV0gJiYgdGhpcy5sb29rdXBGdW4pIHtcbiAgICB2YXIgcmVzID0gdGhpcy5sb29rdXBGdW4oY2FtbF9zdHJpbmdfb2ZfanNieXRlcyh0aGlzLnJvb3QpLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKG5hbWUpKTtcbiAgICBpZihyZXMgIT09IDApIHRoaXMuY29udGVudFtuYW1lXT1uZXcgTWxGYWtlRmlsZShjYW1sX2J5dGVzX29mX3N0cmluZyhyZXNbMV0pKTtcbiAgfVxufVxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5leGlzdHMgPSBmdW5jdGlvbihuYW1lKSB7XG4gIC8vIFRoZSByb290IG9mIHRoZSBkZXZpY2UgZXhpc3RzXG4gIGlmKG5hbWUgPT0gXCJcIikgcmV0dXJuIDE7XG4gIC8vIENoZWNrIGlmIGEgZGlyZWN0b3J5IGV4aXN0c1xuICB2YXIgbmFtZV9zbGFzaCA9IChuYW1lICsgXCIvXCIpO1xuICB2YXIgciA9IG5ldyBSZWdFeHAoXCJeXCIgKyBuYW1lX3NsYXNoKTtcbiAgZm9yKHZhciBuIGluIHRoaXMuY29udGVudCkge1xuICAgIGlmIChuLm1hdGNoKHIpKSByZXR1cm4gMVxuICB9XG4gIC8vIENoZWNrIGlmIGEgZmlsZSBleGlzdHNcbiAgdGhpcy5sb29rdXAobmFtZSk7XG4gIHJldHVybiB0aGlzLmNvbnRlbnRbbmFtZV0/MTowO1xufVxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5yZWFkZGlyID0gZnVuY3Rpb24obmFtZSkge1xuICB2YXIgbmFtZV9zbGFzaCA9IChuYW1lID09IFwiXCIpP1wiXCI6KG5hbWUgKyBcIi9cIik7XG4gIHZhciByID0gbmV3IFJlZ0V4cChcIl5cIiArIG5hbWVfc2xhc2ggKyBcIihbXi9dKilcIik7XG4gIHZhciBzZWVuID0ge31cbiAgdmFyIGEgPSBbXTtcbiAgZm9yKHZhciBuIGluIHRoaXMuY29udGVudCkge1xuICAgIHZhciBtID0gbi5tYXRjaChyKTtcbiAgICBpZihtICYmICFzZWVuW21bMV1dKSB7c2VlblttWzFdXSA9IHRydWU7IGEucHVzaChtWzFdKX1cbiAgfVxuICByZXR1cm4gYTtcbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUuaXNfZGlyID0gZnVuY3Rpb24obmFtZSkge1xuICB2YXIgbmFtZV9zbGFzaCA9IChuYW1lID09IFwiXCIpP1wiXCI6KG5hbWUgKyBcIi9cIik7XG4gIHZhciByID0gbmV3IFJlZ0V4cChcIl5cIiArIG5hbWVfc2xhc2ggKyBcIihbXi9dKilcIik7XG4gIHZhciBhID0gW107XG4gIGZvcih2YXIgbiBpbiB0aGlzLmNvbnRlbnQpIHtcbiAgICB2YXIgbSA9IG4ubWF0Y2gocik7XG4gICAgaWYobSkgcmV0dXJuIDFcbiAgfVxuICByZXR1cm4gMFxufVxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS51bmxpbmsgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHZhciBvayA9IHRoaXMuY29udGVudFtuYW1lXT90cnVlOmZhbHNlO1xuICBkZWxldGUgdGhpcy5jb250ZW50W25hbWVdO1xuICByZXR1cm4gb2s7XG59XG5NbEZha2VEZXZpY2UucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbihuYW1lLCBmKSB7XG4gIGlmKGYucmRvbmx5ICYmIGYud3Jvbmx5KVxuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHRoaXMubm0obmFtZSkgKyBcIiA6IGZsYWdzIE9wZW5fcmRvbmx5IGFuZCBPcGVuX3dyb25seSBhcmUgbm90IGNvbXBhdGlibGVcIik7XG4gIGlmKGYudGV4dCAmJiBmLmJpbmFyeSlcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcih0aGlzLm5tKG5hbWUpICsgXCIgOiBmbGFncyBPcGVuX3RleHQgYW5kIE9wZW5fYmluYXJ5IGFyZSBub3QgY29tcGF0aWJsZVwiKTtcbiAgdGhpcy5sb29rdXAobmFtZSk7XG4gIGlmICh0aGlzLmNvbnRlbnRbbmFtZV0pIHtcbiAgICBpZiAodGhpcy5pc19kaXIobmFtZSkpIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHRoaXMubm0obmFtZSkgKyBcIiA6IGlzIGEgZGlyZWN0b3J5XCIpO1xuICAgIGlmIChmLmNyZWF0ZSAmJiBmLmV4Y2wpIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHRoaXMubm0obmFtZSkgKyBcIiA6IGZpbGUgYWxyZWFkeSBleGlzdHNcIik7XG4gICAgdmFyIGZpbGUgPSB0aGlzLmNvbnRlbnRbbmFtZV07XG4gICAgaWYoZi50cnVuY2F0ZSkgZmlsZS50cnVuY2F0ZSgpO1xuICAgIHJldHVybiBmaWxlO1xuICB9IGVsc2UgaWYgKGYuY3JlYXRlKSB7XG4gICAgdGhpcy5jb250ZW50W25hbWVdID0gbmV3IE1sRmFrZUZpbGUoY2FtbF9jcmVhdGVfYnl0ZXMoMCkpO1xuICAgIHJldHVybiB0aGlzLmNvbnRlbnRbbmFtZV07XG4gIH0gZWxzZSB7XG4gICAgY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUgKHRoaXMubm0obmFtZSkpO1xuICB9XG59XG5cbk1sRmFrZURldmljZS5wcm90b3R5cGUucmVnaXN0ZXI9IGZ1bmN0aW9uIChuYW1lLGNvbnRlbnQpe1xuICBpZih0aGlzLmNvbnRlbnRbbmFtZV0pIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHRoaXMubm0obmFtZSkgKyBcIiA6IGZpbGUgYWxyZWFkeSBleGlzdHNcIik7XG4gIGlmKGNhbWxfaXNfbWxfYnl0ZXMoY29udGVudCkpXG4gICAgdGhpcy5jb250ZW50W25hbWVdID0gbmV3IE1sRmFrZUZpbGUoY29udGVudCk7XG4gIGlmKGNhbWxfaXNfbWxfc3RyaW5nKGNvbnRlbnQpKVxuICAgIHRoaXMuY29udGVudFtuYW1lXSA9IG5ldyBNbEZha2VGaWxlKGNhbWxfYnl0ZXNfb2Zfc3RyaW5nKGNvbnRlbnQpKTtcbiAgZWxzZSBpZihjb250ZW50IGluc3RhbmNlb2YgQXJyYXkpXG4gICAgdGhpcy5jb250ZW50W25hbWVdID0gbmV3IE1sRmFrZUZpbGUoY2FtbF9ieXRlc19vZl9hcnJheShjb250ZW50KSk7XG4gIGVsc2UgaWYodHlwZW9mIGNvbnRlbnQgPT09IFwic3RyaW5nXCIpXG4gICAgdGhpcy5jb250ZW50W25hbWVdID0gbmV3IE1sRmFrZUZpbGUoY2FtbF9ieXRlc19vZl9qc2J5dGVzKGNvbnRlbnQpKTtcbiAgZWxzZSBpZihjb250ZW50LnRvU3RyaW5nKSB7XG4gICAgdmFyIGJ5dGVzID0gY2FtbF9ieXRlc19vZl9zdHJpbmcoY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcoY29udGVudC50b1N0cmluZygpKSk7XG4gICAgdGhpcy5jb250ZW50W25hbWVdID0gbmV3IE1sRmFrZUZpbGUoYnl0ZXMpO1xuICB9XG4gIGVsc2UgY2FtbF9yYWlzZV9zeXNfZXJyb3IodGhpcy5ubShuYW1lKSArIFwiIDogcmVnaXN0ZXJpbmcgZmlsZSB3aXRoIGludmFsaWQgY29udGVudCB0eXBlXCIpO1xufVxuXG5NbEZha2VEZXZpY2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWxGYWtlRGV2aWNlXG5cbi8vUHJvdmlkZXM6IE1sRmFrZUZpbGVcbi8vUmVxdWlyZXM6IE1sRmlsZVxuLy9SZXF1aXJlczogY2FtbF9jcmVhdGVfYnl0ZXMsIGNhbWxfbWxfYnl0ZXNfbGVuZ3RoLCBjYW1sX2JsaXRfYnl0ZXMsIGNhbWxfYmxpdF9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfZ2V0XG5mdW5jdGlvbiBNbEZha2VGaWxlKGNvbnRlbnQpe1xuICB0aGlzLmRhdGEgPSBjb250ZW50O1xufVxuTWxGYWtlRmlsZS5wcm90b3R5cGUgPSBuZXcgTWxGaWxlICgpO1xuTWxGYWtlRmlsZS5wcm90b3R5cGUudHJ1bmNhdGUgPSBmdW5jdGlvbihsZW4pe1xuICB2YXIgb2xkID0gdGhpcy5kYXRhO1xuICB0aGlzLmRhdGEgPSBjYW1sX2NyZWF0ZV9ieXRlcyhsZW58MCk7XG4gIGNhbWxfYmxpdF9ieXRlcyhvbGQsIDAsIHRoaXMuZGF0YSwgMCwgbGVuKTtcbn1cbk1sRmFrZUZpbGUucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGNhbWxfbWxfYnl0ZXNfbGVuZ3RoKHRoaXMuZGF0YSk7XG59XG5NbEZha2VGaWxlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKG9mZnNldCxidWYscG9zLGxlbil7XG4gIHZhciBjbGVuID0gdGhpcy5sZW5ndGgoKTtcbiAgaWYob2Zmc2V0ICsgbGVuID49IGNsZW4pIHtcbiAgICB2YXIgbmV3X3N0ciA9IGNhbWxfY3JlYXRlX2J5dGVzKG9mZnNldCArIGxlbik7XG4gICAgdmFyIG9sZF9kYXRhID0gdGhpcy5kYXRhO1xuICAgIHRoaXMuZGF0YSA9IG5ld19zdHI7XG4gICAgY2FtbF9ibGl0X2J5dGVzKG9sZF9kYXRhLCAwLCB0aGlzLmRhdGEsIDAsIGNsZW4pO1xuICB9XG4gIGNhbWxfYmxpdF9zdHJpbmcoYnVmLCBwb3MsIHRoaXMuZGF0YSwgb2Zmc2V0LCBsZW4pO1xuICByZXR1cm4gMFxufVxuTWxGYWtlRmlsZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uKG9mZnNldCxidWYscG9zLGxlbil7XG4gIHZhciBjbGVuID0gdGhpcy5sZW5ndGgoKTtcbiAgY2FtbF9ibGl0X2J5dGVzKHRoaXMuZGF0YSwgb2Zmc2V0LCBidWYsIHBvcywgbGVuKTtcbiAgcmV0dXJuIDBcbn1cbk1sRmFrZUZpbGUucHJvdG90eXBlLnJlYWRfb25lID0gZnVuY3Rpb24ob2Zmc2V0KXtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfZ2V0KHRoaXMuZGF0YSwgb2Zmc2V0KTtcbn1cbk1sRmFrZUZpbGUucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKXtcblxufVxuTWxGYWtlRmlsZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNbEZha2VGaWxlXG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTQgSsOpcsO0bWUgVm91aWxsb24sIEh1Z28gSGV1emFyZFxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBmc19ub2RlX3N1cHBvcnRlZFxuZnVuY3Rpb24gZnNfbm9kZV9zdXBwb3J0ZWQgKCkge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiBqb29fZ2xvYmFsX29iamVjdC5wcm9jZXNzICE9PSAndW5kZWZpbmVkJ1xuICAgICAgJiYgdHlwZW9mIGpvb19nbG9iYWxfb2JqZWN0LnByb2Nlc3MudmVyc2lvbnMgIT09ICd1bmRlZmluZWQnXG4gICAgICAmJiB0eXBlb2Ygam9vX2dsb2JhbF9vYmplY3QucHJvY2Vzcy52ZXJzaW9ucy5ub2RlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgJiYgam9vX2dsb2JhbF9vYmplY3QucHJvY2Vzcy5wbGF0Zm9ybSAhPT0gXCJicm93c2VyXCIpXG59XG5cblxuLy9Qcm92aWRlczogTWxOb2RlRGV2aWNlXG4vL1JlcXVpcmVzOiBNbE5vZGVGaWxlLCBjYW1sX3JhaXNlX3N5c19lcnJvclxuZnVuY3Rpb24gTWxOb2RlRGV2aWNlKHJvb3QpIHtcbiAgdGhpcy5mcyA9IHJlcXVpcmUoJ2ZzJyk7XG4gIHRoaXMucm9vdCA9IHJvb3Q7XG59XG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLm5tID0gZnVuY3Rpb24obmFtZSkge1xuICByZXR1cm4gKHRoaXMucm9vdCArIG5hbWUpO1xufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5leGlzdHMgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHRoaXMuZnMuZXhpc3RzU3luYyh0aGlzLm5tKG5hbWUpKT8xOjA7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKGVyci50b1N0cmluZygpKTtcbiAgfVxufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5yZWFkZGlyID0gZnVuY3Rpb24obmFtZSkge1xuICB0cnkge1xuICAgIHJldHVybiB0aGlzLmZzLnJlYWRkaXJTeW5jKHRoaXMubm0obmFtZSkpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihlcnIudG9TdHJpbmcoKSk7XG4gIH1cbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUuaXNfZGlyID0gZnVuY3Rpb24obmFtZSkge1xuICB0cnkge1xuICAgIHJldHVybiB0aGlzLmZzLnN0YXRTeW5jKHRoaXMubm0obmFtZSkpLmlzRGlyZWN0b3J5KCk/MTowO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihlcnIudG9TdHJpbmcoKSk7XG4gIH1cbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUudW5saW5rID0gZnVuY3Rpb24obmFtZSkge1xuICB0cnkge1xuICAgIHZhciBiID0gdGhpcy5mcy5leGlzdHNTeW5jKHRoaXMubm0obmFtZSkpPzE6MDtcbiAgICB0aGlzLmZzLnVubGlua1N5bmModGhpcy5ubShuYW1lKSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKGVyci50b1N0cmluZygpKTtcbiAgfVxuICByZXR1cm4gYlxufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24obmFtZSwgZikge1xuICB2YXIgY29uc3RzID0gcmVxdWlyZSgnY29uc3RhbnRzJyk7XG4gIHZhciByZXMgPSAwO1xuICBmb3IodmFyIGtleSBpbiBmKXtcbiAgICBzd2l0Y2goa2V5KXtcbiAgICBjYXNlIFwicmRvbmx5XCIgIDogcmVzIHw9IGNvbnN0cy5PX1JET05MWTsgYnJlYWs7XG4gICAgY2FzZSBcIndyb25seVwiICA6IHJlcyB8PSBjb25zdHMuT19XUk9OTFk7IGJyZWFrO1xuICAgIGNhc2UgXCJhcHBlbmRcIiAgOlxuICAgICAgcmVzIHw9IGNvbnN0cy5PX1dST05MWSB8IGNvbnN0cy5PX0FQUEVORDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJjcmVhdGVcIiAgIDogcmVzIHw9IGNvbnN0cy5PX0NSRUFUOyAgICBicmVhaztcbiAgICBjYXNlIFwidHJ1bmNhdGVcIiA6IHJlcyB8PSBjb25zdHMuT19UUlVOQzsgICAgYnJlYWs7XG4gICAgY2FzZSBcImV4Y2xcIiAgICAgOiByZXMgfD0gY29uc3RzLk9fRVhDTDsgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJiaW5hcnlcIiAgIDogcmVzIHw9IGNvbnN0cy5PX0JJTkFSWTsgICBicmVhaztcbiAgICBjYXNlIFwidGV4dFwiICAgICA6IHJlcyB8PSBjb25zdHMuT19URVhUOyAgICAgYnJlYWs7XG4gICAgY2FzZSBcIm5vbmJsb2NrXCIgOiByZXMgfD0gY29uc3RzLk9fTk9OQkxPQ0s7IGJyZWFrO1xuICAgIH1cbiAgfVxuICB0cnkge1xuICAgIHZhciBmZCA9IHRoaXMuZnMub3BlblN5bmModGhpcy5ubShuYW1lKSwgcmVzKTtcbiAgICByZXR1cm4gbmV3IE1sTm9kZUZpbGUoZmQpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihlcnIudG9TdHJpbmcoKSk7XG4gIH1cbn1cblxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5yZW5hbWUgPSBmdW5jdGlvbihvLG4pIHtcbiAgdHJ5IHtcbiAgICB0aGlzLmZzLnJlbmFtZVN5bmModGhpcy5ubShvKSwgdGhpcy5ubShuKSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKGVyci50b1N0cmluZygpKTtcbiAgfVxufVxuXG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWxOb2RlRGV2aWNlXG5cbi8vUHJvdmlkZXM6IE1sTm9kZUZpbGVcbi8vUmVxdWlyZXM6IE1sRmlsZSwgY2FtbF9hcnJheV9vZl9zdHJpbmcsIGNhbWxfYXJyYXlfb2ZfYnl0ZXMsIGNhbWxfYnl0ZXNfc2V0LCBjYW1sX3JhaXNlX3N5c19lcnJvclxuZnVuY3Rpb24gTWxOb2RlRmlsZShmZCl7XG4gIHRoaXMuZnMgPSByZXF1aXJlKCdmcycpO1xuICB0aGlzLmZkID0gZmQ7XG59XG5NbE5vZGVGaWxlLnByb3RvdHlwZSA9IG5ldyBNbEZpbGUgKCk7XG5cbk1sTm9kZUZpbGUucHJvdG90eXBlLnRydW5jYXRlID0gZnVuY3Rpb24obGVuKXtcbiAgdHJ5IHtcbiAgICB0aGlzLmZzLmZ0cnVuY2F0ZVN5bmModGhpcy5mZCxsZW58MClcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoZXJyLnRvU3RyaW5nKCkpO1xuICB9XG59XG5NbE5vZGVGaWxlLnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHRoaXMuZnMuZnN0YXRTeW5jKHRoaXMuZmQpLnNpemU7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKGVyci50b1N0cmluZygpKTtcbiAgfVxufVxuTWxOb2RlRmlsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihvZmZzZXQsYnVmLGJ1Zl9vZmZzZXQsbGVuKXtcbiAgdmFyIGEgPSBjYW1sX2FycmF5X29mX3N0cmluZyhidWYpO1xuICBpZighIChhIGluc3RhbmNlb2Ygam9vX2dsb2JhbF9vYmplY3QuVWludDhBcnJheSkpXG4gICAgYSA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5VaW50OEFycmF5KGEpO1xuICB2YXIgYnVmZmVyID0gam9vX2dsb2JhbF9vYmplY3QuQnVmZmVyLmZyb20oYSk7XG4gIHRyeSB7XG4gICAgdGhpcy5mcy53cml0ZVN5bmModGhpcy5mZCwgYnVmZmVyLCBidWZfb2Zmc2V0LCBsZW4sIG9mZnNldCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKGVyci50b1N0cmluZygpKTtcbiAgfVxuICByZXR1cm4gMDtcbn1cbk1sTm9kZUZpbGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbihvZmZzZXQsYnVmLGJ1Zl9vZmZzZXQsbGVuKXtcbiAgdmFyIGEgPSBjYW1sX2FycmF5X29mX2J5dGVzKGJ1Zik7XG4gIGlmKCEgKGEgaW5zdGFuY2VvZiBqb29fZ2xvYmFsX29iamVjdC5VaW50OEFycmF5KSlcbiAgICBhID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0LlVpbnQ4QXJyYXkoYSk7XG4gIHZhciBidWZmZXIgPSBqb29fZ2xvYmFsX29iamVjdC5CdWZmZXIuZnJvbShhKTtcbiAgdHJ5IHtcbiAgICB0aGlzLmZzLnJlYWRTeW5jKHRoaXMuZmQsIGJ1ZmZlciwgYnVmX29mZnNldCwgbGVuLCBvZmZzZXQpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihlcnIudG9TdHJpbmcoKSk7XG4gIH1cbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKXtcbiAgICBjYW1sX2J5dGVzX3NldChidWYsYnVmX29mZnNldCArIGksYnVmZmVyW2J1Zl9vZmZzZXQraV0pO1xuICB9XG4gIHJldHVybiAwXG59XG5NbE5vZGVGaWxlLnByb3RvdHlwZS5yZWFkX29uZSA9IGZ1bmN0aW9uKG9mZnNldCl7XG4gIHZhciBhID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0LlVpbnQ4QXJyYXkoMSk7XG4gIHZhciBidWZmZXIgPSBqb29fZ2xvYmFsX29iamVjdC5CdWZmZXIuZnJvbShhKTtcbiAgdHJ5IHtcbiAgICB0aGlzLmZzLnJlYWRTeW5jKHRoaXMuZmQsIGJ1ZmZlciwgMCwgMSwgb2Zmc2V0KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoZXJyLnRvU3RyaW5nKCkpO1xuICB9XG4gIHJldHVybiBidWZmZXJbMF07XG59XG5NbE5vZGVGaWxlLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCl7XG4gIHRyeSB7XG4gICAgdGhpcy5mcy5jbG9zZVN5bmModGhpcy5mZCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKGVyci50b1N0cmluZygpKTtcbiAgfVxufVxuXG5NbE5vZGVGaWxlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1sTm9kZUZpbGU7XG4iLCIvL1Byb3ZpZGVzOiBpbml0aWFsaXplX25hdFxuLy9SZXF1aXJlczogY2FtbF9jdXN0b21fb3BzXG4vL1JlcXVpcmVzOiBzZXJpYWxpemVfbmF0LCBkZXNlcmlhbGl6ZV9uYXQsIGNhbWxfaGFzaF9uYXRcbmZ1bmN0aW9uIGluaXRpYWxpemVfbmF0KCkge1xuICBjYW1sX2N1c3RvbV9vcHNbXCJfbmF0XCJdID1cbiAgICB7IGRlc2VyaWFsaXplIDogZGVzZXJpYWxpemVfbmF0LFxuICAgICAgc2VyaWFsaXplIDogc2VyaWFsaXplX25hdCxcbiAgICAgIGhhc2ggOiBjYW1sX2hhc2hfbmF0XG4gICAgfVxufVxuXG4vL1Byb3ZpZGVzOiBNbE5hdFxuZnVuY3Rpb24gTWxOYXQoeCl7XG4gIHRoaXMuZGF0YSA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5JbnQzMkFycmF5KHgpO1xuICAvLyBsZW5ndGhfbmF0IGlzbid0IGV4dGVybmFsLCBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhlIE9iai5zaXplXG4gIC8vIHdvcmsgb3V0IHJpZ2h0LiBUaGUgKzIgdG8gYXJyYXkgbGVuZ3RoIHNlZW1zIHRvIHdvcmsuXG4gIHRoaXMubGVuZ3RoID0gdGhpcy5kYXRhLmxlbmd0aCArIDJcbn1cblxuTWxOYXQucHJvdG90eXBlLmNhbWxfY3VzdG9tID0gXCJfbmF0XCI7XG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9uYXRcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfaW50LCBudW1fZGlnaXRzX25hdFxuZnVuY3Rpb24gY2FtbF9oYXNoX25hdCh4KSB7XG4gIHZhciBsZW4gPSBudW1fZGlnaXRzX25hdCh4LCAwLCB4LmRhdGEubGVuZ3RoKTtcbiAgdmFyIGggPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHguZGF0YVtpXSk7XG4gIH1cbiAgcmV0dXJuIGg7XG59XG5cblxuLy9Qcm92aWRlczogbmF0X29mX2FycmF5XG4vL1JlcXVpcmVzOiBNbE5hdFxuZnVuY3Rpb24gbmF0X29mX2FycmF5KGwpe1xuICByZXR1cm4gbmV3IE1sTmF0KGwpO1xufVxuXG4vL1Byb3ZpZGVzOiBjcmVhdGVfbmF0XG4vL1JlcXVpcmVzOiBNbE5hdFxuZnVuY3Rpb24gY3JlYXRlX25hdChzaXplKSB7XG4gIHZhciBhcnIgPSBuZXcgTWxOYXQoc2l6ZSk7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICBhcnIuZGF0YVtpXSA9IC0xO1xuICB9XG4gIHJldHVybiBhcnI7XG59XG5cbi8vUHJvdmlkZXM6IHNldF90b196ZXJvX25hdFxuZnVuY3Rpb24gc2V0X3RvX3plcm9fbmF0KG5hdCwgb2ZzLCBsZW4pIHtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgbmF0LmRhdGFbb2ZzK2ldID0gMDtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogYmxpdF9uYXRcbmZ1bmN0aW9uIGJsaXRfbmF0KG5hdDEsIG9mczEsIG5hdDIsIG9mczIsIGxlbikge1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBuYXQxLmRhdGFbb2ZzMStpXSA9IG5hdDIuZGF0YVtvZnMyK2ldO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBzZXRfZGlnaXRfbmF0XG5mdW5jdGlvbiBzZXRfZGlnaXRfbmF0KG5hdCwgb2ZzLCBkaWdpdCkge1xuICBuYXQuZGF0YVtvZnNdID0gZGlnaXQ7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBudGhfZGlnaXRfbmF0XG5mdW5jdGlvbiBudGhfZGlnaXRfbmF0KG5hdCwgb2ZzKSB7XG4gIHJldHVybiBuYXQuZGF0YVtvZnNdO1xufVxuXG4vL1Byb3ZpZGVzOiBzZXRfZGlnaXRfbmF0X25hdGl2ZVxuZnVuY3Rpb24gc2V0X2RpZ2l0X25hdF9uYXRpdmUobmF0LCBvZnMsIGRpZ2l0KSB7XG4gIG5hdC5kYXRhW29mc10gPSBkaWdpdDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IG50aF9kaWdpdF9uYXRfbmF0aXZlXG5mdW5jdGlvbiBudGhfZGlnaXRfbmF0X25hdGl2ZShuYXQsIG9mcykge1xuICByZXR1cm4gbmF0LmRhdGFbb2ZzXTtcbn1cblxuLy9Qcm92aWRlczogbnVtX2RpZ2l0c19uYXRcbmZ1bmN0aW9uIG51bV9kaWdpdHNfbmF0KG5hdCwgb2ZzLCBsZW4pIHtcbiAgZm9yKHZhciBpID0gbGVuIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZihuYXQuZGF0YVtvZnMraV0gIT0gMCkgcmV0dXJuIGkrMTtcbiAgfVxuICByZXR1cm4gMTsgLy8gMCBjb3VudHMgYXMgMSBkaWdpdFxufVxuXG4vL1Byb3ZpZGVzOiBudW1fbGVhZGluZ196ZXJvX2JpdHNfaW5fZGlnaXRcbmZ1bmN0aW9uIG51bV9sZWFkaW5nX3plcm9fYml0c19pbl9kaWdpdChuYXQsIG9mcykge1xuICB2YXIgYSA9IG5hdC5kYXRhW29mc107XG4gIHZhciBiID0gMDtcbiAgaWYoYSAmIDB4RkZGRjAwMDApIHsgYiArPTE2OyBhID4+Pj0xNjsgfVxuICBpZihhICYgMHhGRjAwKSAgICAgeyBiICs9IDg7IGEgPj4+PSA4OyB9XG4gIGlmKGEgJiAweEYwKSAgICAgICB7IGIgKz0gNDsgYSA+Pj49IDQ7IH1cbiAgaWYoYSAmIDEyKSAgICAgICAgIHsgYiArPSAyOyBhID4+Pj0gMjsgfVxuICBpZihhICYgMikgICAgICAgICAgeyBiICs9IDE7IGEgPj4+PSAxOyB9XG4gIGlmKGEgJiAxKSAgICAgICAgICB7IGIgKz0gMTsgfVxuICByZXR1cm4gMzIgLSBiO1xufVxuXG4vL1Byb3ZpZGVzOiBpc19kaWdpdF9pbnRcbmZ1bmN0aW9uIGlzX2RpZ2l0X2ludChuYXQsIG9mcykge1xuICBpZiAobmF0LmRhdGFbb2ZzXSA+PSAwKSByZXR1cm4gMVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogaXNfZGlnaXRfemVyb1xuZnVuY3Rpb24gaXNfZGlnaXRfemVybyhuYXQsIG9mcykge1xuICBpZihuYXQuZGF0YVtvZnNdID09IDApIHJldHVybiAxO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogaXNfZGlnaXRfb2RkXG5mdW5jdGlvbiBpc19kaWdpdF9vZGQobmF0LCBvZnMpIHtcbiAgaWYobmF0LmRhdGFbb2ZzXSAmIDEpIHJldHVybiAxO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogaW5jcl9uYXRcbmZ1bmN0aW9uIGluY3JfbmF0KG5hdCwgb2ZzLCBsZW4sIGNhcnJ5X2luKSB7XG4gIHZhciBjYXJyeSA9IGNhcnJ5X2luO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgeCA9IChuYXQuZGF0YVtvZnMraV0gPj4+IDApICsgY2Fycnk7XG4gICAgbmF0LmRhdGFbb2ZzK2ldID0gKHggfCAwKTtcbiAgICBpZih4ID09ICh4ID4+PiAwKSkge1xuICAgICAgY2FycnkgPSAwO1xuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhcnJ5ID0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNhcnJ5O1xufVxuXG4vLyBsZW4xID49IGxlbjJcbi8vUHJvdmlkZXM6IGFkZF9uYXRcbi8vUmVxdWlyZXM6IGluY3JfbmF0XG5mdW5jdGlvbiBhZGRfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIGxlbjIsIGNhcnJ5X2luKSB7XG4gIHZhciBjYXJyeSA9IGNhcnJ5X2luO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuMjsgaSsrKSB7XG4gICAgdmFyIHggPSAobmF0MS5kYXRhW29mczEraV0gPj4+IDApICsgKG5hdDIuZGF0YVtvZnMyK2ldID4+PiAwKSArIGNhcnJ5O1xuICAgIG5hdDEuZGF0YVtvZnMxK2ldID0geFxuICAgIGlmKHggPT0gKHggPj4+IDApKSB7XG4gICAgICBjYXJyeSA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhcnJ5ID0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGluY3JfbmF0KG5hdDEsIG9mczErbGVuMiwgbGVuMS1sZW4yLCBjYXJyeSk7XG59XG5cbi8vUHJvdmlkZXM6IGNvbXBsZW1lbnRfbmF0XG5mdW5jdGlvbiBjb21wbGVtZW50X25hdChuYXQsIG9mcywgbGVuKSB7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIG5hdC5kYXRhW29mcytpXSA9ICgtMSA+Pj4gMCkgLSAobmF0LmRhdGFbb2ZzK2ldID4+PiAwKTtcbiAgfVxufVxuXG4vLyBvY2FtbCBmbGlwcyBjYXJyeV9pblxuLy9Qcm92aWRlczogZGVjcl9uYXRcbmZ1bmN0aW9uIGRlY3JfbmF0KG5hdCwgb2ZzLCBsZW4sIGNhcnJ5X2luKSB7XG4gIHZhciBib3Jyb3cgPSAoY2FycnlfaW4gPT0gMSkgPyAwIDogMTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIHggPSAobmF0LmRhdGFbb2ZzK2ldID4+PjApIC0gYm9ycm93O1xuICAgIG5hdC5kYXRhW29mcytpXSA9IHg7XG4gICAgaWYgKHggPj0gMCkge1xuICAgICAgYm9ycm93ID0gMDtcbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSB7XG4gICAgICBib3Jyb3cgPSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gKGJvcnJvdyA9PSAxKSA/IDAgOiAxO1xufVxuXG4vLyBvY2FtbCBmbGlwcyBjYXJyeV9pblxuLy8gbGVuMSA+PSBsZW4yXG4vL1Byb3ZpZGVzOiBzdWJfbmF0XG4vL1JlcXVpcmVzOiBkZWNyX25hdFxuZnVuY3Rpb24gc3ViX25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBsZW4yLCBjYXJyeV9pbikge1xuICB2YXIgYm9ycm93ID0gKGNhcnJ5X2luID09IDEpID8gMCA6IDE7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW4yOyBpKyspIHtcbiAgICB2YXIgeCA9IChuYXQxLmRhdGFbb2ZzMStpXSA+Pj4gMCkgLSAobmF0Mi5kYXRhW29mczIraV0gPj4+IDApIC0gYm9ycm93O1xuICAgIG5hdDEuZGF0YVtvZnMxK2ldID0geDtcbiAgICBpZiAoeCA+PSAwKSB7XG4gICAgICBib3Jyb3cgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBib3Jyb3cgPSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVjcl9uYXQobmF0MSwgb2ZzMStsZW4yLCBsZW4xLWxlbjIsIChib3Jyb3c9PTEpPzA6MSk7XG59XG5cbi8vIG5hdDEgKz0gbmF0MiAqIG5hdDNbb2ZzM11cbi8vIGxlbjEgPj0gbGVuMlxuLy9Qcm92aWRlczogbXVsdF9kaWdpdF9uYXRcbi8vUmVxdWlyZXM6IGFkZF9uYXQsIG5hdF9vZl9hcnJheVxuZnVuY3Rpb24gbXVsdF9kaWdpdF9uYXQobmF0MSwgb2ZzMSwgbGVuMSwgbmF0Miwgb2ZzMiwgbGVuMiwgbmF0Mywgb2ZzMykge1xuICB2YXIgY2FycnkgPSAwO1xuICB2YXIgYSA9IChuYXQzLmRhdGFbb2ZzM10gPj4+IDApO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuMjsgaSsrKSB7XG4gICAgdmFyIHgxID0gKG5hdDEuZGF0YVtvZnMxK2ldID4+PiAwKSArIChuYXQyLmRhdGFbb2ZzMitpXSA+Pj4gMCkgKiAoYSAmIDB4MDAwMEZGRkYpICsgY2Fycnk7XG4gICAgdmFyIHgyID0gKG5hdDIuZGF0YVtvZnMyK2ldID4+PiAwKSAqIChhID4+PiAxNik7XG4gICAgY2FycnkgPSBNYXRoLmZsb29yKHgyLzY1NTM2KTtcbiAgICB2YXIgeDMgPSB4MSArICh4MiAlIDY1NTM2KSAqIDY1NTM2O1xuICAgIG5hdDEuZGF0YVtvZnMxK2ldID0geDM7XG4gICAgY2FycnkgKz0gTWF0aC5mbG9vcih4My80Mjk0OTY3Mjk2KTtcbiAgfVxuXG4gIGlmKGxlbjIgPCBsZW4xICYmIGNhcnJ5KSB7XG4gICAgcmV0dXJuIGFkZF9uYXQobmF0MSwgb2ZzMStsZW4yLCBsZW4xLWxlbjIsIG5hdF9vZl9hcnJheShbY2FycnldKSwgMCwgMSwgMCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNhcnJ5O1xuICB9XG59XG5cbi8vIG5hdDEgKz0gbmF0MiAqIG5hdDNcbi8vIGxlbjEgPj0gbGVuMiArIGxlbjMuXG4vL1Byb3ZpZGVzOiBtdWx0X25hdFxuLy9SZXF1aXJlczogbXVsdF9kaWdpdF9uYXRcbmZ1bmN0aW9uIG11bHRfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIGxlbjIsIG5hdDMsIG9mczMsIGxlbjMpIHtcbiAgdmFyIGNhcnJ5ID0gMDtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjM7IGkrKykge1xuICAgIGNhcnJ5ICs9IG11bHRfZGlnaXRfbmF0KG5hdDEsIG9mczEraSwgbGVuMS1pLCBuYXQyLCBvZnMyLCBsZW4yLCBuYXQzLCBvZnMzK2kpO1xuICB9XG4gIHJldHVybiBjYXJyeTtcbn1cblxuLy8gbmF0MSA9IDIgKiBuYXQxICsgbmF0MiAqIG5hdDJcbi8vIGxlbjEgPj0gMiAqIGxlbjJcbi8vUHJvdmlkZXM6IHNxdWFyZV9uYXRcbi8vUmVxdWlyZXM6IG11bHRfbmF0LCBhZGRfbmF0XG5mdW5jdGlvbiBzcXVhcmVfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIGxlbjIpIHtcbiAgdmFyIGNhcnJ5ID0gMDtcbiAgY2FycnkgKz0gYWRkX25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQxLCBvZnMxLCBsZW4xLCAwKTtcbiAgY2FycnkgKz0gbXVsdF9uYXQobmF0MSwgb2ZzMSwgbGVuMSwgbmF0Miwgb2ZzMiwgbGVuMiwgbmF0Miwgb2ZzMiwgbGVuMik7XG4gIHJldHVybiBjYXJyeTtcbn1cblxuXG4vLyAwIDw9IHNoaWZ0IDwgMzJcbi8vUHJvdmlkZXM6IHNoaWZ0X2xlZnRfbmF0XG5mdW5jdGlvbiBzaGlmdF9sZWZ0X25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBuYml0cykge1xuICBpZihuYml0cyA9PSAwKSB7XG4gICAgbmF0Mi5kYXRhW29mczJdID0gMDtcbiAgICByZXR1cm4gMDtcbiAgfVxuICB2YXIgd3JhcCA9IDA7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW4xOyBpKyspIHtcbiAgICB2YXIgYSA9IChuYXQxLmRhdGFbb2ZzMStpXSA+Pj4gMCk7XG4gICAgbmF0MS5kYXRhW29mczEraV0gPSAoYSA8PCBuYml0cykgfCB3cmFwO1xuICAgIHdyYXAgPSBhID4+PiAoMzIgLSBuYml0cyk7XG4gIH1cbiAgbmF0Mi5kYXRhW29mczJdID0gd3JhcDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vIEFzc3VtaW5nIGMgPiBhLCByZXR1cm5zIFtxdW90aWVudCwgcmVtYWluZGVyXSBvZiAoYTw8MzIgKyBiKS9jXG4vL1Byb3ZpZGVzOiBkaXZfaGVscGVyXG5mdW5jdGlvbiBkaXZfaGVscGVyKGEsIGIsIGMpIHtcbiAgdmFyIHggPSBhICogNjU1MzYgKyAoYj4+PjE2KTtcbiAgdmFyIHkgPSBNYXRoLmZsb29yKHgvYykgKiA2NTUzNjtcbiAgdmFyIHogPSAoeCAlIGMpICogNjU1MzY7XG4gIHZhciB3ID0geiArIChiICYgMHgwMDAwRkZGRik7XG4gIHJldHVybiBbeSArIE1hdGguZmxvb3Iody9jKSwgdyAlIGNdO1xufVxuXG4vLyBuYXQxW29mczErbGVuXSA8IG5hdDJbb2ZzMl1cbi8vUHJvdmlkZXM6IGRpdl9kaWdpdF9uYXRcbi8vUmVxdWlyZXM6IGRpdl9oZWxwZXJcbmZ1bmN0aW9uIGRpdl9kaWdpdF9uYXQobmF0cSwgb2ZzcSwgbmF0ciwgb2ZzciwgbmF0MSwgb2ZzMSwgbGVuLCBuYXQyLCBvZnMyKSB7XG4gIHZhciByZW0gPSAobmF0MS5kYXRhW29mczErbGVuLTFdID4+PjApO1xuICAvLyBuYXRxW29mc3ErbGVuLTFdIGlzIGd1YXJhbnRlZWQgdG8gYmUgemVybyAoZHVlIHRvIHRoZSBNU0QgcmVxdWlyZW1lbnQpLFxuICAvLyBhbmQgc2hvdWxkIG5vdCBiZSB3cml0dGVuIHRvLlxuICBmb3IodmFyIGkgPSBsZW4tMjsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgeCA9IGRpdl9oZWxwZXIocmVtLCAobmF0MS5kYXRhW29mczEraV0gPj4+IDApLCAobmF0Mi5kYXRhW29mczJdID4+PiAwKSk7XG4gICAgbmF0cS5kYXRhW29mc3EraV0gPSB4WzBdO1xuICAgIHJlbSA9IHhbMV07XG4gIH1cbiAgbmF0ci5kYXRhW29mc3JdID0gcmVtO1xuICByZXR1cm4gMDtcbn1cblxuLy8gbmF0MVtuYXQyOl0gOj0gbmF0MSAvIG5hdDJcbi8vIG5hdDFbOm5hdDJdIDo9IG5hdDEgJSBuYXQyXG4vLyBsZW4xID4gbGVuMiwgbmF0MltvZnMyK2xlbjItMV0gPiBuYXQxW29mczErbGVuMS0xXVxuLy9Qcm92aWRlczogZGl2X25hdFxuLy9SZXF1aXJlczogZGl2X2RpZ2l0X25hdCwgZGl2X2hlbHBlciwgbnVtX2xlYWRpbmdfemVyb19iaXRzX2luX2RpZ2l0LCBzaGlmdF9sZWZ0X25hdCwgc2hpZnRfcmlnaHRfbmF0LCBjcmVhdGVfbmF0LCBzZXRfdG9femVyb19uYXQsIG11bHRfZGlnaXRfbmF0LCBzdWJfbmF0LCBjb21wYXJlX25hdCwgbmF0X29mX2FycmF5XG5mdW5jdGlvbiBkaXZfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIGxlbjIpIHtcbiAgaWYobGVuMiA9PSAxKSB7XG4gICAgZGl2X2RpZ2l0X25hdChuYXQxLCBvZnMxKzEsIG5hdDEsIG9mczEsIG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIpO1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgdmFyIHMgPSBudW1fbGVhZGluZ196ZXJvX2JpdHNfaW5fZGlnaXQobmF0Miwgb2ZzMitsZW4yLTEpO1xuICBzaGlmdF9sZWZ0X25hdChuYXQyLCBvZnMyLCBsZW4yLCBuYXRfb2ZfYXJyYXkoWzBdKSwgMCwgcyk7XG4gIHNoaWZ0X2xlZnRfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdF9vZl9hcnJheShbMF0pLCAwLCBzKTtcblxuICB2YXIgZCA9IChuYXQyLmRhdGFbb2ZzMitsZW4yLTFdID4+PiAwKSArIDE7XG4gIHZhciBhID0gY3JlYXRlX25hdChsZW4yKzEpO1xuICBmb3IgKHZhciBpID0gbGVuMSAtIDE7IGkgPj0gbGVuMjsgaS0tKSB7XG4gICAgLy8gRGVjZW50IGxvd2VyIGJvdW5kIG9uIHF1b1xuICAgIHZhciBxdW8gPSBkID09IDQyOTQ5NjcyOTYgPyAobmF0MS5kYXRhW29mczEraV0gPj4+IDApIDogZGl2X2hlbHBlcigobmF0MS5kYXRhW29mczEraV0gPj4+IDApLCAobmF0MS5kYXRhW29mczEraS0xXSA+Pj4wKSwgZClbMF07XG4gICAgc2V0X3RvX3plcm9fbmF0KGEsIDAsIGxlbjIrMSk7XG4gICAgbXVsdF9kaWdpdF9uYXQoYSwgMCwgbGVuMisxLCBuYXQyLCBvZnMyLCBsZW4yLCBuYXRfb2ZfYXJyYXkoW3F1b10pLCAwKTtcbiAgICBzdWJfbmF0KG5hdDEsIG9mczEraS1sZW4yLCBsZW4yKzEsIGEsIDAsIGxlbjIrMSwgMSk7XG5cbiAgICB3aGlsZSAobmF0MS5kYXRhW29mczEraV0gIT0gMCB8fCBjb21wYXJlX25hdChuYXQxLCBvZnMxK2ktbGVuMiwgbGVuMiwgbmF0Miwgb2ZzMiwgbGVuMikgPj0gMCkge1xuICAgICAgcXVvID0gcXVvICsgMTtcbiAgICAgIHN1Yl9uYXQobmF0MSwgb2ZzMStpLWxlbjIsIGxlbjIrMSwgbmF0Miwgb2ZzMiwgbGVuMiwgMSk7XG4gICAgfVxuXG4gICAgbmF0MS5kYXRhW29mczEraV0gPSBxdW87XG4gIH1cblxuICBzaGlmdF9yaWdodF9uYXQobmF0MSwgb2ZzMSwgbGVuMiwgbmF0X29mX2FycmF5KFswXSksIDAsIHMpOyAvLyBzaGlmdCByZW1haW5kZXJcbiAgc2hpZnRfcmlnaHRfbmF0KG5hdDIsIG9mczIsIGxlbjIsIG5hdF9vZl9hcnJheShbMF0pLCAwLCBzKTsgLy8gcmVzdG9yZVxuICByZXR1cm4gMDtcbn1cblxuXG4vLyAwIDw9IHNoaWZ0IDwgMzJcbi8vUHJvdmlkZXM6IHNoaWZ0X3JpZ2h0X25hdFxuZnVuY3Rpb24gc2hpZnRfcmlnaHRfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIG5iaXRzKSB7XG4gIGlmKG5iaXRzID09IDApIHtcbiAgICBuYXQyLmRhdGFbb2ZzMl0gPSAwO1xuICAgIHJldHVybiAwO1xuICB9XG4gIHZhciB3cmFwID0gMDtcbiAgZm9yKHZhciBpID0gbGVuMS0xOyBpID49IDA7IGktLSkge1xuICAgIHZhciBhID0gbmF0MS5kYXRhW29mczEraV0gPj4+IDA7XG4gICAgbmF0MS5kYXRhW29mczEraV0gPSAoYSA+Pj4gbmJpdHMpIHwgd3JhcDtcbiAgICB3cmFwID0gYSA8PCAoMzIgLSBuYml0cyk7XG4gIH1cbiAgbmF0Mi5kYXRhW29mczJdID0gd3JhcDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNvbXBhcmVfZGlnaXRzX25hdFxuZnVuY3Rpb24gY29tcGFyZV9kaWdpdHNfbmF0KG5hdDEsIG9mczEsIG5hdDIsIG9mczIpIHtcbiAgaWYobmF0MS5kYXRhW29mczFdID4gbmF0Mi5kYXRhW29mczJdKSByZXR1cm4gMTtcbiAgaWYobmF0MS5kYXRhW29mczFdIDwgbmF0Mi5kYXRhW29mczJdKSByZXR1cm4gLTE7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjb21wYXJlX25hdFxuLy9SZXF1aXJlczogbnVtX2RpZ2l0c19uYXRcbmZ1bmN0aW9uIGNvbXBhcmVfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIGxlbjIpIHtcbiAgdmFyIGEgPSBudW1fZGlnaXRzX25hdChuYXQxLCBvZnMxLCBsZW4xKTtcbiAgdmFyIGIgPSBudW1fZGlnaXRzX25hdChuYXQyLCBvZnMyLCBsZW4yKTtcbiAgaWYoYSA+IGIpIHJldHVybiAxO1xuICBpZihhIDwgYikgcmV0dXJuIC0xO1xuICBmb3IodmFyIGkgPSBsZW4xIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAoKG5hdDEuZGF0YVtvZnMxK2ldID4+PiAwKSA+IChuYXQyLmRhdGFbb2ZzMitpXSA+Pj4gMCkpIHJldHVybiAxO1xuICAgIGlmICgobmF0MS5kYXRhW29mczEraV0gPj4+IDApIDwgKG5hdDIuZGF0YVtvZnMyK2ldID4+PiAwKSkgcmV0dXJuIC0xO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjb21wYXJlX25hdF9yZWFsXG4vL1JlcXVpcmVzOiBjb21wYXJlX25hdFxuZnVuY3Rpb24gY29tcGFyZV9uYXRfcmVhbChuYXQxLG5hdDIpe1xuICByZXR1cm4gY29tcGFyZV9uYXQobmF0MSwwLG5hdDEuZGF0YS5sZW5ndGgsbmF0MiwwLG5hdDIuZGF0YS5sZW5ndGgpO1xufVxuXG4vL1Byb3ZpZGVzOiBsYW5kX2RpZ2l0X25hdFxuZnVuY3Rpb24gbGFuZF9kaWdpdF9uYXQobmF0MSwgb2ZzMSwgbmF0Miwgb2ZzMikge1xuICBuYXQxLmRhdGFbb2ZzMV0gJj0gbmF0Mi5kYXRhW29mczJdO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogbG9yX2RpZ2l0X25hdFxuZnVuY3Rpb24gbG9yX2RpZ2l0X25hdChuYXQxLCBvZnMxLCBuYXQyLCBvZnMyKSB7XG4gIG5hdDEuZGF0YVtvZnMxXSB8PSBuYXQyLmRhdGFbb2ZzMl07XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBseG9yX2RpZ2l0X25hdFxuZnVuY3Rpb24gbHhvcl9kaWdpdF9uYXQobmF0MSwgb2ZzMSwgbmF0Miwgb2ZzMikge1xuICBuYXQxLmRhdGFbb2ZzMV0gXj0gbmF0Mi5kYXRhW29mczJdO1xuICByZXR1cm4gMDtcbn1cblxuXG4vL1Byb3ZpZGVzOiBzZXJpYWxpemVfbmF0XG5mdW5jdGlvbiBzZXJpYWxpemVfbmF0KHdyaXRlciwgbmF0LCBzeil7XG4gIHZhciBsZW4gPSBuYXQuZGF0YS5sZW5ndGg7XG4gIHdyaXRlci53cml0ZSgzMiwgbGVuKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKXtcbiAgICB3cml0ZXIud3JpdGUoMzIsIG5hdC5kYXRhW2ldKTtcbiAgfVxuICBzelswXSA9IGxlbiAqIDQ7XG4gIHN6WzFdID0gbGVuICogODtcbn1cblxuLy9Qcm92aWRlczogZGVzZXJpYWxpemVfbmF0XG4vL1JlcXVpcmVzOiBNbE5hdFxuZnVuY3Rpb24gZGVzZXJpYWxpemVfbmF0KHJlYWRlciwgc3ope1xuICB2YXIgbGVuID0gcmVhZGVyLnJlYWQzMnMoKTtcbiAgdmFyIG5hdCA9IG5ldyBNbE5hdChsZW4pO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspe1xuICAgIG5hdC5kYXRhW2ldID0gcmVhZGVyLnJlYWQzMnMoKTtcbiAgfVxuICBzelswXSA9IGxlbiAqIDQ7XG4gIHJldHVybiBuYXQ7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTQgSHVnbyBIZXV6YXJkXG5cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3N0YXRlXG52YXIgY2FtbF9ncl9zdGF0ZTtcblxuLy9Qcm92aWRlczogY2FtbF9ncl9zdGF0ZV9nZXRcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVcbi8vUmVxdWlyZXM6IGNhbWxfbmFtZWRfdmFsdWUsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfZ3Jfc3RhdGVfZ2V0KCkge1xuICBpZihjYW1sX2dyX3N0YXRlKSB7XG4gICAgcmV0dXJuIGNhbWxfZ3Jfc3RhdGU7XG4gIH1cbiAgdGhyb3cgWzAsY2FtbF9uYW1lZF92YWx1ZShcIkdyYXBoaWNzLkdyYXBoaWNfZmFpbHVyZVwiKSwgY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhcIk5vdCBpbml0aWFsaXplZFwiKV1cbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc3RhdGVfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlLGNhbWxfZ3Jfc3RhdGVfaW5pdFxuZnVuY3Rpb24gY2FtbF9ncl9zdGF0ZV9zZXQoY3R4KSB7XG4gIGNhbWxfZ3Jfc3RhdGU9Y3R4O1xuICBjYW1sX2dyX3N0YXRlX2luaXQoKVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9vcGVuX2dyYXBoXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2NyZWF0ZVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9zZXRcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2dyX29wZW5fZ3JhcGgoaW5mbyl7XG4gIHZhciBnID0gam9vX2dsb2JhbF9vYmplY3Q7XG4gIHZhciBpbmZvID0gY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcoaW5mbyk7XG4gIGZ1bmN0aW9uIGdldChuYW1lKXtcbiAgICB2YXIgcmVzID0gaW5mby5tYXRjaChcIihefCwpICpcIituYW1lK1wiICo9ICooW2EtekEtWjAtOV9dKykgKigsfCQpXCIpO1xuICAgIGlmKHJlcykgcmV0dXJuIHJlc1syXTtcbiAgfVxuICB2YXIgc3BlY3MgPSBbXTtcbiAgaWYoIShpbmZvPT1cIlwiKSkgc3BlY3MucHVzaChpbmZvKTtcbiAgdmFyIHRhcmdldCA9IGdldChcInRhcmdldFwiKTtcbiAgaWYoIXRhcmdldCkgdGFyZ2V0PVwiXCI7XG4gIHZhciBzdGF0dXMgPSBnZXQoXCJzdGF0dXNcIik7XG4gIGlmKCFzdGF0dXMpIHNwZWNzLnB1c2goXCJzdGF0dXM9MVwiKVxuXG4gIHZhciB3ID0gZ2V0KFwid2lkdGhcIik7XG4gIHcgPSB3P3BhcnNlSW50KHcpOjIwMDtcbiAgc3BlY3MucHVzaChcIndpZHRoPVwiK3cpO1xuXG4gIHZhciBoID0gZ2V0KFwiaGVpZ2h0XCIpO1xuICBoID0gaD9wYXJzZUludChoKToyMDA7XG4gIHNwZWNzLnB1c2goXCJoZWlnaHQ9XCIraCk7XG5cbiAgdmFyIHdpbiA9IGcub3BlbihcImFib3V0OmJsYW5rXCIsdGFyZ2V0LHNwZWNzLmpvaW4oXCIsXCIpKTtcbiAgaWYoIXdpbikge2NhbWxfZmFpbHdpdGgoXCJHcmFwaGljcy5vcGVuX2dyYXBoOiBjYW5ub3Qgb3BlbiB0aGUgd2luZG93XCIpfVxuICB2YXIgZG9jID0gd2luLmRvY3VtZW50O1xuICB2YXIgY2FudmFzID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gIGNhbnZhcy53aWR0aCA9IHc7XG4gIGNhbnZhcy5oZWlnaHQgPSBoO1xuICB2YXIgY3R4ID0gY2FtbF9ncl9zdGF0ZV9jcmVhdGUoY2FudmFzLHcsaCk7XG4gIGN0eC5zZXRfdGl0bGUgPSBmdW5jdGlvbiAodGl0bGUpIHtcbiAgICBkb2MudGl0bGUgPSB0aXRsZTtcbiAgfTtcbiAgY2FtbF9ncl9zdGF0ZV9zZXQoY3R4KTtcbiAgdmFyIGJvZHkgPSBkb2MuYm9keTtcbiAgYm9keS5zdHlsZS5tYXJnaW4gPSBcIjBweFwiO1xuICBib2R5LmFwcGVuZENoaWxkKGNhbnZhcyk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3N0YXRlX2luaXRcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc2V0X2NvbG9yLGNhbWxfZ3JfbW92ZXRvLGNhbWxfZ3JfcmVzaXplX3dpbmRvd1xuLy9SZXF1aXJlczogY2FtbF9ncl9zZXRfbGluZV93aWR0aCxjYW1sX2dyX3NldF90ZXh0X3NpemUsY2FtbF9ncl9zZXRfZm9udFxuLy9SZXF1aXJlczogY2FtbF9ncl9zZXRfd2luZG93X3RpdGxlXG5mdW5jdGlvbiBjYW1sX2dyX3N0YXRlX2luaXQoKXtcbiAgY2FtbF9ncl9tb3ZldG8oY2FtbF9ncl9zdGF0ZS54LGNhbWxfZ3Jfc3RhdGUueSk7XG4gIGNhbWxfZ3JfcmVzaXplX3dpbmRvdyhjYW1sX2dyX3N0YXRlLndpZHRoLGNhbWxfZ3Jfc3RhdGUuaGVpZ2h0KTtcbiAgY2FtbF9ncl9zZXRfbGluZV93aWR0aChjYW1sX2dyX3N0YXRlLmxpbmVfd2lkdGgpO1xuICBjYW1sX2dyX3NldF90ZXh0X3NpemUoY2FtbF9ncl9zdGF0ZS50ZXh0X3NpemUpO1xuICBjYW1sX2dyX3NldF9mb250KGNhbWxfZ3Jfc3RhdGUuZm9udCk7XG4gIGNhbWxfZ3Jfc2V0X2NvbG9yKGNhbWxfZ3Jfc3RhdGUuY29sb3IpO1xuICBjYW1sX2dyX3NldF93aW5kb3dfdGl0bGUoY2FtbF9ncl9zdGF0ZS50aXRsZSk7XG4gIC8vY2FtbF9ncl9yZXNpemVfd2luZG93IG1pZ2h0IHJlc2V0IHNvbWUgY2FudmFzJyBwcm9wZXJ0aWVzXG4gIGNhbWxfZ3Jfc3RhdGUuY29udGV4dC50ZXh0QmFzZWxpbmUgPSAnYm90dG9tJztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9zdGF0ZV9jcmVhdGVcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfZ3Jfc3RhdGVfY3JlYXRlKGNhbnZhcyx3LGgpe1xuICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gIHJldHVybiB7XG4gICAgY29udGV4dDogY29udGV4dCxcbiAgICBjYW52YXMgOiBjYW52YXMsXG4gICAgeCA6IDAsXG4gICAgeSA6IDAsXG4gICAgd2lkdGggOiB3LFxuICAgIGhlaWdodCA6IGgsXG4gICAgbGluZV93aWR0aCA6IDEsXG4gICAgZm9udCA6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoXCJmaXhlZFwiKSxcbiAgICB0ZXh0X3NpemUgOiAyNixcbiAgICBjb2xvciA6IDB4MDAwMDAwLFxuICAgIHRpdGxlIDogY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhcIlwiKVxuICB9O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2RvY19vZl9zdGF0ZVxuZnVuY3Rpb24gY2FtbF9ncl9kb2Nfb2Zfc3RhdGUoc3RhdGUpIHtcbiAgaWYoc3RhdGUuY2FudmFzLm93bmVyRG9jdW1lbnQpXG4gICAgcmV0dXJuIHN0YXRlLmNhbnZhcy5vd25lckRvY3VtZW50O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2Nsb3NlX2dyYXBoXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9jbG9zZV9ncmFwaCgpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMuY2FudmFzLndpZHRoID0gMDtcbiAgcy5jYW52YXMuaGVpZ2h0ID0gMDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc2V0X3dpbmRvd190aXRsZVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2dyX3NldF93aW5kb3dfdGl0bGUobmFtZSl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy50aXRsZSA9IG5hbWU7XG4gIHZhciBqc25hbWUgPSBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhuYW1lKTtcbiAgaWYocy5zZXRfdGl0bGUpIHMuc2V0X3RpdGxlKGpzbmFtZSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3Jlc2l6ZV93aW5kb3dcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX3Jlc2l6ZV93aW5kb3codyxoKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpXG4gIHMud2lkdGggPSB3O1xuICBzLmhlaWdodCA9IGg7XG4gIHMuY2FudmFzLndpZHRoID0gdztcbiAgcy5jYW52YXMuaGVpZ2h0ID0gaDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfY2xlYXJfZ3JhcGhcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2NsZWFyX2dyYXBoKCl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy5jYW52YXMud2lkdGggPSBzLndpZHRoO1xuICBzLmNhbnZhcy5oZWlnaHQgPSBzLmhlaWdodDtcbiAgLy8gIHMuY29udGV4dC5zdHJva2VSZWN0ICgwLiwgMC4sIHMud2lkdGgsIHMuaGVpZ2h0KTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc2l6ZV94XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9zaXplX3goKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICByZXR1cm4gcy53aWR0aDtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc2l6ZV95XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9zaXplX3koKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICByZXR1cm4gcy5oZWlnaHQ7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9ncl9zZXRfY29sb3Jcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX3NldF9jb2xvcihjb2xvcil7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgZnVuY3Rpb24gY29udmVydChudW1iZXIpIHtcbiAgICB2YXIgc3RyID0gJycgKyBudW1iZXIudG9TdHJpbmcoMTYpO1xuICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgMikgc3RyID0gJzAnICsgc3RyO1xuICAgIHJldHVybiBzdHI7XG4gIH1cbiAgdmFyXG4gIHIgPSAoY29sb3IgPj4gMTYpICYgMHhmZixcbiAgZyA9IChjb2xvciA+PiA4KSAgJiAweGZmLFxuICBiID0gKGNvbG9yID4+IDApICAmIDB4ZmY7XG4gIHMuY29sb3I9Y29sb3I7XG4gIHZhciBjX3N0ciA9ICcjJyArIGNvbnZlcnQocikgKyBjb252ZXJ0KGcpICsgY29udmVydChiKTtcbiAgcy5jb250ZXh0LmZpbGxTdHlsZSA9ICAgY19zdHI7XG4gIHMuY29udGV4dC5zdHJva2VTdHlsZSA9IGNfc3RyO1xuICByZXR1cm4gMDtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfcGxvdFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfcGxvdCh4LHkpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHZhciBpbT1zLmNvbnRleHQuY3JlYXRlSW1hZ2VEYXRhKDEsMSk7XG4gIHZhciBkID0gaW0uZGF0YTtcbiAgdmFyIGNvbG9yID0gcy5jb2xvcjtcbiAgZFswXSA9IChjb2xvciA+PiAxNikgJiAweGZmOyAvL3JcbiAgZFsxXSA9IChjb2xvciA+PiA4KSAgJiAweGZmLCAvL2dcbiAgZFsyXSA9IChjb2xvciA+PiAwKSAgJiAweGZmOyAvL2JcbiAgZFszXSA9IDB4RkY7IC8vYVxuICBzLng9eDtcbiAgcy55PXk7XG4gIHMuY29udGV4dC5wdXRJbWFnZURhdGEoaW0seCxzLmhlaWdodCAtIHkpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9wb2ludF9jb2xvclxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfcG9pbnRfY29sb3IoeCx5KXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICB2YXIgaW09cy5jb250ZXh0LmdldEltYWdlRGF0YSh4LHMuaGVpZ2h0IC0geSwxLDEpO1xuICB2YXIgZCA9IGltLmRhdGE7XG4gIHJldHVybiAoZFswXSA8PCAxNikgKyAoZFsxXSA8PCA4KSArIGRbMl07XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX21vdmV0b1xuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfbW92ZXRvKHgseSl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy54PXg7XG4gIHMueT15O1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9jdXJyZW50X3hcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2N1cnJlbnRfeCgpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHJldHVybiBzLnhcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfY3VycmVudF95XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9jdXJyZW50X3koKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICByZXR1cm4gcy55XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2xpbmV0b1xuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfbGluZXRvKHgseSl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy5jb250ZXh0LmJlZ2luUGF0aCgpO1xuICBzLmNvbnRleHQubW92ZVRvKHMueCxzLmhlaWdodCAtIHMueSk7XG4gIHMuY29udGV4dC5saW5lVG8oeCxzLmhlaWdodCAtIHkpO1xuICBzLmNvbnRleHQuc3Ryb2tlKCk7XG4gIHMueD14O1xuICBzLnk9eTtcbiAgcmV0dXJuIDA7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2RyYXdfcmVjdFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfZHJhd19yZWN0KHgseSx3LGgpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMuY29udGV4dC5zdHJva2VSZWN0KHgscy5oZWlnaHQgLSB5LHcsLWgpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9hcmNfYXV4XG5mdW5jdGlvbiBjYW1sX2dyX2FyY19hdXgoY3R4LGN4LGN5LHJ5LHJ4LGExLGEyKXtcbiAgd2hpbGUoYTE+YTIpIGEyKz0zNjA7XG4gIGExIC89IDE4MDtcbiAgYTIgLz0gMTgwO1xuICB2YXIgcm90ID0gMCx4UG9zLHlQb3MseFBvc19wcmV2LHlQb3NfcHJldjtcbiAgdmFyIHNwYWNlID0gMjtcbiAgdmFyIG51bSA9ICgoKGEyIC0gYTEpICogTWF0aC5QSSAqICgocngrcnkpLzIpKSAvIHNwYWNlKSB8IDA7XG4gIHZhciBkZWx0YSA9IChhMiAtIGExKSAqIE1hdGguUEkgLyBudW07XG4gIHZhciBpID0gYTEgKiBNYXRoLlBJO1xuICBmb3IgKHZhciBqPTA7ajw9bnVtO2orKyl7XG4gICAgeFBvcyA9IGN4IC0gKHJ4ICogTWF0aC5zaW4oaSkpICogTWF0aC5zaW4ocm90ICogTWF0aC5QSSkgKyAocnkgKiBNYXRoLmNvcyhpKSkgKiBNYXRoLmNvcyhyb3QgKiBNYXRoLlBJKTtcbiAgICB4UG9zID0geFBvcy50b0ZpeGVkKDIpO1xuICAgIHlQb3MgPSBjeSArIChyeSAqIE1hdGguY29zKGkpKSAqIE1hdGguc2luKHJvdCAqIE1hdGguUEkpICsgKHJ4ICogTWF0aC5zaW4oaSkpICogTWF0aC5jb3Mocm90ICogTWF0aC5QSSk7XG4gICAgeVBvcyA9IHlQb3MudG9GaXhlZCgyKTtcbiAgICBpZiAoaj09MCkge1xuICAgICAgY3R4Lm1vdmVUbyh4UG9zLCB5UG9zKTtcbiAgICB9IGVsc2UgaWYgKHhQb3NfcHJldiE9eFBvcyB8fCB5UG9zX3ByZXYhPXlQb3Mpe1xuICAgICAgY3R4LmxpbmVUbyh4UG9zLCB5UG9zKTtcbiAgICB9XG4gICAgeFBvc19wcmV2PXhQb3M7XG4gICAgeVBvc19wcmV2PXlQb3M7XG4gICAgaS09IGRlbHRhOy8vY2N3XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9ncl9kcmF3X2FyY1xuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXQsIGNhbWxfZ3JfYXJjX2F1eFxuZnVuY3Rpb24gY2FtbF9ncl9kcmF3X2FyYyh4LHkscngscnksYTEsYTIpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMuY29udGV4dC5iZWdpblBhdGgoKTtcbiAgY2FtbF9ncl9hcmNfYXV4KHMuY29udGV4dCx4LHMuaGVpZ2h0IC0geSxyeCxyeSxhMSxhMik7XG4gIHMuY29udGV4dC5zdHJva2UoKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc2V0X2xpbmVfd2lkdGhcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX3NldF9saW5lX3dpZHRoKHcpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMubGluZV93aWR0aCA9IHc7XG4gIHMuY29udGV4dC5saW5lV2lkdGggPSB3XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2ZpbGxfcmVjdFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfZmlsbF9yZWN0KHgseSx3LGgpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMuY29udGV4dC5maWxsUmVjdCh4LHMuaGVpZ2h0IC0geSx3LC1oKTtcbiAgcmV0dXJuIDA7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2ZpbGxfcG9seVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfZmlsbF9wb2x5KGFyKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLmNvbnRleHQuYmVnaW5QYXRoKCk7XG4gIHMuY29udGV4dC5tb3ZlVG8oYXJbMV1bMV0scy5oZWlnaHQgLSBhclsxXVsyXSk7XG4gIGZvcih2YXIgaSA9IDI7IGkgPCBhci5sZW5ndGg7IGkrKylcbiAgICBzLmNvbnRleHQubGluZVRvKGFyW2ldWzFdLHMuaGVpZ2h0IC0gYXJbaV1bMl0pO1xuICBzLmNvbnRleHQubGluZVRvKGFyWzFdWzFdLHMuaGVpZ2h0IC0gYXJbMV1bMl0pO1xuICBzLmNvbnRleHQuZmlsbCgpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9maWxsX2FyY1xuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXQsIGNhbWxfZ3JfYXJjX2F1eFxuZnVuY3Rpb24gY2FtbF9ncl9maWxsX2FyYyh4LHkscngscnksYTEsYTIpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMuY29udGV4dC5iZWdpblBhdGgoKTtcbiAgY2FtbF9ncl9hcmNfYXV4KHMuY29udGV4dCx4LHMuaGVpZ2h0IC0geSxyeCxyeSxhMSxhMik7XG4gIHMuY29udGV4dC5maWxsKCk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2RyYXdfc3RyXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9kcmF3X3N0cihzdHIpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHZhciBtID0gcy5jb250ZXh0Lm1lYXN1cmVUZXh0KHN0cik7XG4gIHZhciBkeCA9IG0ud2lkdGg7XG4gIHMuY29udGV4dC5maWxsVGV4dChzdHIscy54LHMuaGVpZ2h0IC0gcy55KTtcbiAgcy54ICs9IGR4IHwgMDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfZHJhd19jaGFyXG4vL1JlcXVpcmVzOiBjYW1sX2dyX2RyYXdfc3RyXG5mdW5jdGlvbiBjYW1sX2dyX2RyYXdfY2hhcihjKXtcbiAgY2FtbF9ncl9kcmF3X3N0cihTdHJpbmcuZnJvbUNoYXJDb2RlKGMpKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfZHJhd19zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfZ3JfZHJhd19zdHJcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2dyX2RyYXdfc3RyaW5nKHN0cil7XG4gIGNhbWxfZ3JfZHJhd19zdHIoY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcoc3RyKSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3NldF9mb250XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfZ3Jfc2V0X2ZvbnQoZil7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy5mb250ID0gZjtcbiAgcy5jb250ZXh0LmZvbnQgPSBzLnRleHRfc2l6ZSArIFwicHggXCIgKyBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhzLmZvbnQpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9zZXRfdGV4dF9zaXplXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfZ3Jfc2V0X3RleHRfc2l6ZShzaXplKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLnRleHRfc2l6ZSA9IHNpemU7XG4gIHMuY29udGV4dC5mb250ID0gcy50ZXh0X3NpemUgKyBcInB4IFwiICsgY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocy5mb250KTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfdGV4dF9zaXplXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfZ3JfdGV4dF9zaXplKHR4dCl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgdmFyIHcgPSBzLmNvbnRleHQubWVhc3VyZVRleHQoY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcodHh0KSkud2lkdGg7XG4gIHJldHVybiBbMCx3LHMudGV4dF9zaXplXTtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX21ha2VfaW1hZ2Vcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX21ha2VfaW1hZ2UoYXJyKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICB2YXIgaCA9IGFyci5sZW5ndGggLSAxIDtcbiAgdmFyIHcgPSBhcnJbMV0ubGVuZ3RoIC0gMTtcbiAgdmFyIGltID0gcy5jb250ZXh0LmNyZWF0ZUltYWdlRGF0YSh3LGgpO1xuICBmb3IodmFyIGk9MDtpPGg7aSsrKXtcbiAgICBmb3IodmFyIGo9MDtqPHc7aisrKXtcbiAgICAgIHZhciBjID0gYXJyW2krMV1baisxXTtcbiAgICAgIHZhciBvID0gaSoodyo0KSArIChqICogNCk7XG4gICAgICBpZihjID09IC0xKSB7XG4gICAgICAgIGltLmRhdGFbbyArIDBdID0gMDtcbiAgICAgICAgaW0uZGF0YVtvICsgMV0gPSAwO1xuICAgICAgICBpbS5kYXRhW28gKyAyXSA9IDA7XG4gICAgICAgIGltLmRhdGFbbyArIDNdID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGltLmRhdGFbbyArIDBdID0gYyA+PiAxNiAmIDB4ZmY7XG4gICAgICAgIGltLmRhdGFbbyArIDFdID0gYyA+PiAgOCAmIDB4ZmY7XG4gICAgICAgIGltLmRhdGFbbyArIDJdID0gYyA+PiAgMCAmIDBYZmY7XG4gICAgICAgIGltLmRhdGFbbyArIDNdID0gMHhmZjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGltXG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2R1bXBfaW1hZ2Vcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2R1bXBfaW1hZ2UoaW0pe1xuICB2YXIgZGF0YSA9IFswXVxuICBmb3IodmFyIGk9MDsgaTxpbS5oZWlnaHQ7aSsrKXtcbiAgICBkYXRhW2krMV0gPSBbMF1cbiAgICBmb3IodmFyIGo9MDsgajxpbS53aWR0aDtqKyspe1xuICAgICAgdmFyIG8gPSBpKihpbS53aWR0aCo0KSArIChqICogNCksXG4gICAgICAgICAgciA9IGltLmRhdGFbbyswXSxcbiAgICAgICAgICBnID0gaW0uZGF0YVtvKzFdLFxuICAgICAgICAgIGIgPSBpbS5kYXRhW28rMl07XG4gICAgICBkYXRhW2krMV1baisxXSA9IChyIDw8IDE2KSArIChnIDw8IDgpICsgYlxuICAgIH1cbiAgfVxuICByZXR1cm4gZGF0YVxufVxuLy9Qcm92aWRlczogY2FtbF9ncl9kcmF3X2ltYWdlXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9kcmF3X2ltYWdlKGltLHgseSl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgaWYoIWltLmltYWdlKSB7XG4gICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgY2FudmFzLndpZHRoID0gcy53aWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gcy5oZWlnaHQ7XG4gICAgY2FudmFzLmdldENvbnRleHQoXCIyZFwiKS5wdXRJbWFnZURhdGEoaW0sMCwwKTtcbiAgICB2YXIgaW1hZ2UgPSBuZXcgam9vX2dsb2JhbF9vYmplY3QuSW1hZ2UoKTtcbiAgICBpbWFnZS5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBzLmNvbnRleHQuZHJhd0ltYWdlKGltYWdlLHgscy5oZWlnaHQgLSBpbS5oZWlnaHQgLSB5KTtcbiAgICAgIGltLmltYWdlID0gaW1hZ2U7XG4gICAgfVxuICAgIGltYWdlLnNyYyA9IGNhbnZhcy50b0RhdGFVUkwoXCJpbWFnZS9wbmdcIik7XG4gIH0gZWxzZSB7XG4gICAgcy5jb250ZXh0LmRyYXdJbWFnZShpbS5pbWFnZSx4LHMuaGVpZ2h0IC0gaW0uaGVpZ2h0IC0geSk7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2NyZWF0ZV9pbWFnZVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfY3JlYXRlX2ltYWdlKHgseSl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcmV0dXJuIHMuY29udGV4dC5jcmVhdGVJbWFnZURhdGEoeCx5KTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfYmxpdF9pbWFnZVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfYmxpdF9pbWFnZShpbSx4LHkpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHZhciBpbTIgPSBzLmNvbnRleHQuZ2V0SW1hZ2VEYXRhKHgscy5oZWlnaHQgLSBpbS5oZWlnaHQgLSB5LGltLndpZHRoLGltLmhlaWdodCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaW0yLmRhdGEubGVuZ3RoOyBpKz00KXtcbiAgICBpbS5kYXRhW2ldID0gaW0yLmRhdGFbaV07XG4gICAgaW0uZGF0YVtpKzFdID0gaW0yLmRhdGFbaSsxXTtcbiAgICBpbS5kYXRhW2krMl0gPSBpbTIuZGF0YVtpKzJdO1xuICAgIGltLmRhdGFbaSszXSA9IGltMi5kYXRhW2krM107XG4gIH1cbiAgcmV0dXJuIDA7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3NpZ2lvX2hhbmRsZXJcbmZ1bmN0aW9uIGNhbWxfZ3Jfc2lnaW9faGFuZGxlcigpe3JldHVybiAwfVxuLy9Qcm92aWRlczogY2FtbF9ncl9zaWdpb19zaWduYWxcbmZ1bmN0aW9uIGNhbWxfZ3Jfc2lnaW9fc2lnbmFsKCl7cmV0dXJuIDB9XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3dhaXRfZXZlbnRcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfZ3Jfd2FpdF9ldmVudChfZXZsKXtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfZ3Jfd2FpdF9ldmVudCBub3QgSW1wbGVtZW50ZWQ6IHVzZSBHcmFwaGljc19qcyBpbnN0ZWFkXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3N5bmNocm9uaXplXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2dyX3N5bmNocm9uaXplICgpIHtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfZ3Jfc3luY2hyb25pemUgbm90IEltcGxlbWVudGVkXCIpO1xufVxuLy9Qcm92aWRlczogY2FtbF9ncl9yZW1lbWJlcl9tb2RlXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2dyX3JlbWVtYmVyX21vZGUgKCkge1xuICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9ncl9yZW1lbWJlcl9tb2RlIG5vdCBJbXBsZW1lbnRlZFwiKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfZGlzcGxheV9tb2RlXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2dyX2Rpc3BsYXlfbW9kZSgpIHtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfZ3JfZGlzcGxheV9tb2RlIG5vdCBJbXBsZW1lbnRlZFwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl93aW5kb3dfaWRcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfZ3Jfd2luZG93X2lkKGEpIHtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfZ3Jfd2luZG93X2lkIG5vdCBJbXBsZW1lbnRlZFwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9vcGVuX3N1YndpbmRvd1xuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9ncl9vcGVuX3N1YndpbmRvdyhhLGIsYyxkKSB7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX2dyX29wZW5fc3Vid2luZG93IG5vdCBJbXBsZW1lbnRlZFwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9jbG9zZV9zdWJ3aW5kb3dcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfZ3JfY2xvc2Vfc3Vid2luZG93KGEpIHtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfZ3JfY2xvc2Vfc3Vid2luZG93IG5vdCBJbXBsZW1lbnRlZFwiKTtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxMCBKw6lyw7RtZSBWb3VpbGxvblxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBjYW1sX21hcnNoYWxfY29uc3RhbnRzXG52YXIgY2FtbF9tYXJzaGFsX2NvbnN0YW50cyA9IHtcbiAgUFJFRklYX1NNQUxMX0JMT0NLOiAgICAgICAgIDB4ODAsXG4gIFBSRUZJWF9TTUFMTF9JTlQ6ICAgICAgICAgICAweDQwLFxuICBQUkVGSVhfU01BTExfU1RSSU5HOiAgICAgICAgMHgyMCxcbiAgQ09ERV9JTlQ4OiAgICAgICAgICAgICAgICAgIDB4MDAsXG4gIENPREVfSU5UMTY6ICAgICAgICAgICAgICAgICAweDAxLFxuICBDT0RFX0lOVDMyOiAgICAgICAgICAgICAgICAgMHgwMixcbiAgQ09ERV9JTlQ2NDogICAgICAgICAgICAgICAgIDB4MDMsXG4gIENPREVfU0hBUkVEODogICAgICAgICAgICAgICAweDA0LFxuICBDT0RFX1NIQVJFRDE2OiAgICAgICAgICAgICAgMHgwNSxcbiAgQ09ERV9TSEFSRUQzMjogICAgICAgICAgICAgIDB4MDYsXG4gIENPREVfQkxPQ0szMjogICAgICAgICAgICAgICAweDA4LFxuICBDT0RFX0JMT0NLNjQ6ICAgICAgICAgICAgICAgMHgxMyxcbiAgQ09ERV9TVFJJTkc4OiAgICAgICAgICAgICAgIDB4MDksXG4gIENPREVfU1RSSU5HMzI6ICAgICAgICAgICAgICAweDBBLFxuICBDT0RFX0RPVUJMRV9CSUc6ICAgICAgICAgICAgMHgwQixcbiAgQ09ERV9ET1VCTEVfTElUVExFOiAgICAgICAgIDB4MEMsXG4gIENPREVfRE9VQkxFX0FSUkFZOF9CSUc6ICAgICAweDBELFxuICBDT0RFX0RPVUJMRV9BUlJBWThfTElUVExFOiAgMHgwRSxcbiAgQ09ERV9ET1VCTEVfQVJSQVkzMl9CSUc6ICAgIDB4MEYsXG4gIENPREVfRE9VQkxFX0FSUkFZMzJfTElUVExFOiAweDA3LFxuICBDT0RFX0NPREVQT0lOVEVSOiAgICAgICAgICAgMHgxMCxcbiAgQ09ERV9JTkZJWFBPSU5URVI6ICAgICAgICAgIDB4MTEsXG4gIENPREVfQ1VTVE9NOiAgICAgICAgICAgICAgICAweDEyLFxuICBDT0RFX0NVU1RPTV9MRU46ICAgICAgICAgICAgMHgxOCxcbiAgQ09ERV9DVVNUT01fRklYRUQ6ICAgICAgICAgIDB4MTlcbn1cblxuXG4vL1Byb3ZpZGVzOiBNbFN0cmluZ1JlYWRlclxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlcywgY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gTWxTdHJpbmdSZWFkZXIgKHMsIGkpIHsgdGhpcy5zID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhzKTsgdGhpcy5pID0gaTsgfVxuTWxTdHJpbmdSZWFkZXIucHJvdG90eXBlID0ge1xuICByZWFkOHU6ZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5zLmNoYXJDb2RlQXQodGhpcy5pKyspOyB9LFxuICByZWFkOHM6ZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5zLmNoYXJDb2RlQXQodGhpcy5pKyspIDw8IDI0ID4+IDI0OyB9LFxuICByZWFkMTZ1OmZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IHRoaXMucywgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgMjtcbiAgICByZXR1cm4gKHMuY2hhckNvZGVBdChpKSA8PCA4KSB8IHMuY2hhckNvZGVBdChpICsgMSlcbiAgfSxcbiAgcmVhZDE2czpmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDI7XG4gICAgcmV0dXJuIChzLmNoYXJDb2RlQXQoaSkgPDwgMjQgPj4gMTYpIHwgcy5jaGFyQ29kZUF0KGkgKyAxKTtcbiAgfSxcbiAgcmVhZDMydTpmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDQ7XG4gICAgcmV0dXJuICgocy5jaGFyQ29kZUF0KGkpIDw8IDI0KSB8IChzLmNoYXJDb2RlQXQoaSsxKSA8PCAxNikgfFxuICAgICAgICAgICAgKHMuY2hhckNvZGVBdChpKzIpIDw8IDgpIHwgcy5jaGFyQ29kZUF0KGkrMykpID4+PiAwO1xuICB9LFxuICByZWFkMzJzOmZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IHRoaXMucywgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgNDtcbiAgICByZXR1cm4gKHMuY2hhckNvZGVBdChpKSA8PCAyNCkgfCAocy5jaGFyQ29kZUF0KGkrMSkgPDwgMTYpIHxcbiAgICAgIChzLmNoYXJDb2RlQXQoaSsyKSA8PCA4KSB8IHMuY2hhckNvZGVBdChpKzMpO1xuICB9LFxuICByZWFkc3RyOmZ1bmN0aW9uIChsZW4pIHtcbiAgICB2YXIgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgbGVuO1xuICAgIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKHRoaXMucy5zdWJzdHJpbmcoaSwgaSArIGxlbikpO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IEJpZ1N0cmluZ1JlYWRlclxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfYXJyYXksIGNhbWxfYmFfZ2V0XzFcbmZ1bmN0aW9uIEJpZ1N0cmluZ1JlYWRlciAoYnMsIGkpIHsgdGhpcy5zID0gYnM7IHRoaXMuaSA9IGk7IH1cbkJpZ1N0cmluZ1JlYWRlci5wcm90b3R5cGUgPSB7XG4gIHJlYWQ4dTpmdW5jdGlvbiAoKSB7IHJldHVybiBjYW1sX2JhX2dldF8xKHRoaXMucyx0aGlzLmkrKyk7IH0sXG4gIHJlYWQ4czpmdW5jdGlvbiAoKSB7IHJldHVybiBjYW1sX2JhX2dldF8xKHRoaXMucyx0aGlzLmkrKykgPDwgMjQgPj4gMjQ7IH0sXG4gIHJlYWQxNnU6ZnVuY3Rpb24gKCkge1xuICAgIHZhciBzID0gdGhpcy5zLCBpID0gdGhpcy5pO1xuICAgIHRoaXMuaSA9IGkgKyAyO1xuICAgIHJldHVybiAoY2FtbF9iYV9nZXRfMShzLGkpIDw8IDgpIHwgY2FtbF9iYV9nZXRfMShzLGkgKyAxKVxuICB9LFxuICByZWFkMTZzOmZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IHRoaXMucywgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgMjtcbiAgICByZXR1cm4gKGNhbWxfYmFfZ2V0XzEocyxpKSA8PCAyNCA+PiAxNikgfCBjYW1sX2JhX2dldF8xKHMsaSArIDEpO1xuICB9LFxuICByZWFkMzJ1OmZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IHRoaXMucywgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgNDtcbiAgICByZXR1cm4gKChjYW1sX2JhX2dldF8xKHMsaSkgICA8PCAyNCkgfCAoY2FtbF9iYV9nZXRfMShzLGkrMSkgPDwgMTYpIHxcbiAgICAgICAgICAgIChjYW1sX2JhX2dldF8xKHMsaSsyKSA8PCA4KSAgfCBjYW1sX2JhX2dldF8xKHMsaSszKSAgICAgICAgICkgPj4+IDA7XG4gIH0sXG4gIHJlYWQzMnM6ZnVuY3Rpb24gKCkge1xuICAgIHZhciBzID0gdGhpcy5zLCBpID0gdGhpcy5pO1xuICAgIHRoaXMuaSA9IGkgKyA0O1xuICAgIHJldHVybiAoY2FtbF9iYV9nZXRfMShzLGkpICAgPDwgMjQpIHwgKGNhbWxfYmFfZ2V0XzEocyxpKzEpIDw8IDE2KSB8XG4gICAgICAoY2FtbF9iYV9nZXRfMShzLGkrMikgPDwgOCkgIHwgY2FtbF9iYV9nZXRfMShzLGkrMyk7XG4gIH0sXG4gIHJlYWRzdHI6ZnVuY3Rpb24gKGxlbikge1xuICAgIHZhciBpID0gdGhpcy5pO1xuICAgIHZhciBhcnIgPSBuZXcgQXJyYXkobGVuKVxuICAgIGZvcih2YXIgaiA9IDA7IGogPCBsZW47IGorKyl7XG4gICAgICBhcnJbal0gPSBjYW1sX2JhX2dldF8xKHRoaXMucywgaStqKTtcbiAgICB9XG4gICAgdGhpcy5pID0gaSArIGxlbjtcbiAgICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfYXJyYXkoYXJyKTtcbiAgfVxufVxuXG5cblxuLy9Qcm92aWRlczogY2FtbF9mbG9hdF9vZl9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzLCBjYW1sX2ludDY0X29mX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2Zsb2F0X29mX2J5dGVzIChhKSB7XG4gIHJldHVybiBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMgKGNhbWxfaW50NjRfb2ZfYnl0ZXMgKGEpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3N0cmluZyBtdXRhYmxlXG4vL1JlcXVpcmVzOiBNbFN0cmluZ1JlYWRlciwgY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3JlYWRlclxuZnVuY3Rpb24gY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3N0cmluZyhzLG9mcykge1xuICB2YXIgcmVhZGVyID0gbmV3IE1sU3RyaW5nUmVhZGVyIChzLCB0eXBlb2Ygb2ZzPT1cIm51bWJlclwiP29mczpvZnNbMF0pO1xuICByZXR1cm4gY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3JlYWRlcihyZWFkZXIsIG9mcylcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnB1dF92YWx1ZV9mcm9tX2J5dGVzIG11dGFibGVcbi8vUmVxdWlyZXM6IE1sU3RyaW5nUmVhZGVyLCBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fcmVhZGVyLCBjYW1sX3N0cmluZ19vZl9ieXRlc1xuZnVuY3Rpb24gY2FtbF9pbnB1dF92YWx1ZV9mcm9tX2J5dGVzKHMsb2ZzKSB7XG4gIHZhciByZWFkZXIgPSBuZXcgTWxTdHJpbmdSZWFkZXIgKGNhbWxfc3RyaW5nX29mX2J5dGVzKHMpLCB0eXBlb2Ygb2ZzPT1cIm51bWJlclwiP29mczpvZnNbMF0pO1xuICByZXR1cm4gY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3JlYWRlcihyZWFkZXIsIG9mcylcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF91bm1hcnNoYWxcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfaW50NjRfdW5tYXJzaGFsKHJlYWRlciwgc2l6ZSl7XG4gIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgZm9yICh2YXIgaiA9IDA7aiA8IDg7aisrKSB0W2pdID0gcmVhZGVyLnJlYWQ4dSgpO1xuICBzaXplWzBdID0gODtcbiAgcmV0dXJuIGNhbWxfaW50NjRfb2ZfYnl0ZXMgKHQpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X21hcnNoYWxcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfdG9fYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfaW50NjRfbWFyc2hhbCh3cml0ZXIsIHYsIHNpemVzKSB7XG4gIHZhciBiID0gY2FtbF9pbnQ2NF90b19ieXRlcyAodik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSsrKSB3cml0ZXIud3JpdGUgKDgsIGJbaV0pO1xuICBzaXplc1swXSA9IDg7IHNpemVzWzFdID0gODtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQzMl91bm1hcnNoYWxcbmZ1bmN0aW9uIGNhbWxfaW50MzJfdW5tYXJzaGFsKHJlYWRlciwgc2l6ZSl7XG4gIHNpemVbMF0gPSA0O1xuICByZXR1cm4gcmVhZGVyLnJlYWQzMnMgKCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbmF0aXZlaW50X3VubWFyc2hhbFxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9uYXRpdmVpbnRfdW5tYXJzaGFsKHJlYWRlciwgc2l6ZSl7XG4gIHN3aXRjaCAocmVhZGVyLnJlYWQ4dSAoKSkge1xuICBjYXNlIDE6XG4gICAgc2l6ZVswXSA9IDQ7XG4gICAgcmV0dXJuIHJlYWRlci5yZWFkMzJzICgpO1xuICBjYXNlIDI6XG4gICAgY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiBuYXRpdmUgaW50ZWdlciB2YWx1ZSB0b28gbGFyZ2VcIik7XG4gIGRlZmF1bHQ6IGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogaWxsLWZvcm1lZCBuYXRpdmUgaW50ZWdlclwiKTtcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2N1c3RvbV9vcHNcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfdW5tYXJzaGFsLCBjYW1sX2ludDY0X21hcnNoYWwsIGNhbWxfaW50NjRfY29tcGFyZSwgY2FtbF9pbnQ2NF9oYXNoXG4vL1JlcXVpcmVzOiBjYW1sX2ludDMyX3VubWFyc2hhbCwgY2FtbF9uYXRpdmVpbnRfdW5tYXJzaGFsXG4vL1JlcXVpcmVzOiBjYW1sX2JhX3NlcmlhbGl6ZSwgY2FtbF9iYV9kZXNlcmlhbGl6ZSwgY2FtbF9iYV9jb21wYXJlLCBjYW1sX2JhX2hhc2hcbnZhciBjYW1sX2N1c3RvbV9vcHMgPVxuICAgIHtcIl9qXCI6IHtcbiAgICAgIGRlc2VyaWFsaXplIDogY2FtbF9pbnQ2NF91bm1hcnNoYWwsXG4gICAgICBzZXJpYWxpemUgIDogY2FtbF9pbnQ2NF9tYXJzaGFsLFxuICAgICAgZml4ZWRfbGVuZ3RoIDogOCxcbiAgICAgIGNvbXBhcmUgOiBjYW1sX2ludDY0X2NvbXBhcmUsXG4gICAgICBoYXNoIDogY2FtbF9pbnQ2NF9oYXNoXG4gICAgfSxcbiAgICAgXCJfaVwiOiB7XG4gICAgICAgZGVzZXJpYWxpemUgOiBjYW1sX2ludDMyX3VubWFyc2hhbCxcbiAgICAgICBmaXhlZF9sZW5ndGggOiA0LFxuICAgICB9LFxuICAgICBcIl9uXCI6IHtcbiAgICAgICBkZXNlcmlhbGl6ZSA6IGNhbWxfbmF0aXZlaW50X3VubWFyc2hhbCxcbiAgICAgICBmaXhlZF9sZW5ndGggOiA0LFxuICAgICB9LFxuICAgICBcIl9iaWdhcnJheVwiOntcbiAgICAgICBkZXNlcmlhbGl6ZSA6IChmdW5jdGlvbiAocmVhZGVyLCBzeikge3JldHVybiBjYW1sX2JhX2Rlc2VyaWFsaXplIChyZWFkZXIsc3osXCJfYmlnYXJyYXlcIil9KSxcbiAgICAgICBzZXJpYWxpemUgOiBjYW1sX2JhX3NlcmlhbGl6ZSxcbiAgICAgICBjb21wYXJlIDogY2FtbF9iYV9jb21wYXJlLFxuICAgICAgIGhhc2g6IGNhbWxfYmFfaGFzaCxcbiAgICAgfSxcbiAgICAgXCJfYmlnYXJyMDJcIjp7XG4gICAgICAgZGVzZXJpYWxpemUgOiAoZnVuY3Rpb24gKHJlYWRlciwgc3opIHtyZXR1cm4gY2FtbF9iYV9kZXNlcmlhbGl6ZSAocmVhZGVyLHN6LFwiX2JpZ2FycjAyXCIpfSksXG4gICAgICAgc2VyaWFsaXplIDogY2FtbF9iYV9zZXJpYWxpemUsXG4gICAgICAgY29tcGFyZSA6IGNhbWxfYmFfY29tcGFyZSxcbiAgICAgICBoYXNoOiBjYW1sX2JhX2hhc2gsXG4gICAgIH1cbiAgICB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9yZWFkZXIgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuLy9SZXF1aXJlczogY2FtbF9mbG9hdF9vZl9ieXRlcywgY2FtbF9jdXN0b21fb3BzXG5cbmZ1bmN0aW9uIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9yZWFkZXIocmVhZGVyLCBvZnMpIHtcbiAgdmFyIF9tYWdpYyA9IHJlYWRlci5yZWFkMzJ1ICgpXG4gIHZhciBfYmxvY2tfbGVuID0gcmVhZGVyLnJlYWQzMnUgKCk7XG4gIHZhciBudW1fb2JqZWN0cyA9IHJlYWRlci5yZWFkMzJ1ICgpO1xuICB2YXIgX3NpemVfMzIgPSByZWFkZXIucmVhZDMydSAoKTtcbiAgdmFyIF9zaXplXzY0ID0gcmVhZGVyLnJlYWQzMnUgKCk7XG4gIHZhciBzdGFjayA9IFtdO1xuICB2YXIgaW50ZXJuX29ial90YWJsZSA9IChudW1fb2JqZWN0cyA+IDApP1tdOm51bGw7XG4gIHZhciBvYmpfY291bnRlciA9IDA7XG4gIGZ1bmN0aW9uIGludGVybl9yZWMgKCkge1xuICAgIHZhciBjb2RlID0gcmVhZGVyLnJlYWQ4dSAoKTtcbiAgICBpZiAoY29kZSA+PSAweDQwIC8qY3N0LlBSRUZJWF9TTUFMTF9JTlQqLykge1xuICAgICAgaWYgKGNvZGUgPj0gMHg4MCAvKmNzdC5QUkVGSVhfU01BTExfQkxPQ0sqLykge1xuICAgICAgICB2YXIgdGFnID0gY29kZSAmIDB4RjtcbiAgICAgICAgdmFyIHNpemUgPSAoY29kZSA+PiA0KSAmIDB4NztcbiAgICAgICAgdmFyIHYgPSBbdGFnXTtcbiAgICAgICAgaWYgKHNpemUgPT0gMCkgcmV0dXJuIHY7XG4gICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgc3RhY2sucHVzaCh2LCBzaXplKTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgICB9IGVsc2VcbiAgICAgICAgcmV0dXJuIChjb2RlICYgMHgzRik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjb2RlID49IDB4MjAvKmNzdC5QUkVGSVhfU01BTExfU1RSSU5HICovKSB7XG4gICAgICAgIHZhciBsZW4gPSBjb2RlICYgMHgxRjtcbiAgICAgICAgdmFyIHYgPSByZWFkZXIucmVhZHN0ciAobGVuKTtcbiAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICByZXR1cm4gdjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN3aXRjaChjb2RlKSB7XG4gICAgICAgIGNhc2UgMHgwMDogLy9jc3QuQ09ERV9JTlQ4OlxuICAgICAgICAgIHJldHVybiByZWFkZXIucmVhZDhzICgpO1xuICAgICAgICBjYXNlIDB4MDE6IC8vY3N0LkNPREVfSU5UMTY6XG4gICAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkMTZzICgpO1xuICAgICAgICBjYXNlIDB4MDI6IC8vY3N0LkNPREVfSU5UMzI6XG4gICAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkMzJzICgpO1xuICAgICAgICBjYXNlIDB4MDM6IC8vY3N0LkNPREVfSU5UNjQ6XG4gICAgICAgICAgY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiBpbnRlZ2VyIHRvbyBsYXJnZVwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAweDA0OiAvL2NzdC5DT0RFX1NIQVJFRDg6XG4gICAgICAgICAgdmFyIG9mZnNldCA9IHJlYWRlci5yZWFkOHUgKCk7XG4gICAgICAgICAgcmV0dXJuIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIgLSBvZmZzZXRdO1xuICAgICAgICBjYXNlIDB4MDU6IC8vY3N0LkNPREVfU0hBUkVEMTY6XG4gICAgICAgICAgdmFyIG9mZnNldCA9IHJlYWRlci5yZWFkMTZ1ICgpO1xuICAgICAgICAgIHJldHVybiBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyIC0gb2Zmc2V0XTtcbiAgICAgICAgY2FzZSAweDA2OiAvL2NzdC5DT0RFX1NIQVJFRDMyOlxuICAgICAgICAgIHZhciBvZmZzZXQgPSByZWFkZXIucmVhZDMydSAoKTtcbiAgICAgICAgICByZXR1cm4gaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlciAtIG9mZnNldF07XG4gICAgICAgIGNhc2UgMHgwODogLy9jc3QuQ09ERV9CTE9DSzMyOlxuICAgICAgICAgIHZhciBoZWFkZXIgPSByZWFkZXIucmVhZDMydSAoKTtcbiAgICAgICAgICB2YXIgdGFnID0gaGVhZGVyICYgMHhGRjtcbiAgICAgICAgICB2YXIgc2l6ZSA9IGhlYWRlciA+PiAxMDtcbiAgICAgICAgICB2YXIgdiA9IFt0YWddO1xuICAgICAgICAgIGlmIChzaXplID09IDApIHJldHVybiB2O1xuICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICBzdGFjay5wdXNoKHYsIHNpemUpO1xuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjYXNlIDB4MTM6IC8vY3N0LkNPREVfQkxPQ0s2NDpcbiAgICAgICAgICBjYW1sX2ZhaWx3aXRoIChcImlucHV0X3ZhbHVlOiBkYXRhIGJsb2NrIHRvbyBsYXJnZVwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAweDA5OiAvL2NzdC5DT0RFX1NUUklORzg6XG4gICAgICAgICAgdmFyIGxlbiA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgICAgICB2YXIgdiA9IHJlYWRlci5yZWFkc3RyIChsZW4pO1xuICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgY2FzZSAweDBBOiAvL2NzdC5DT0RFX1NUUklORzMyOlxuICAgICAgICAgIHZhciBsZW4gPSByZWFkZXIucmVhZDMydSgpO1xuICAgICAgICAgIHZhciB2ID0gcmVhZGVyLnJlYWRzdHIgKGxlbik7XG4gICAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjYXNlIDB4MEM6IC8vY3N0LkNPREVfRE9VQkxFX0xJVFRMRTpcbiAgICAgICAgICB2YXIgdCA9IG5ldyBBcnJheSg4KTs7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7aSA8IDg7aSsrKSB0WzcgLSBpXSA9IHJlYWRlci5yZWFkOHUgKCk7XG4gICAgICAgICAgdmFyIHYgPSBjYW1sX2Zsb2F0X29mX2J5dGVzICh0KTtcbiAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGNhc2UgMHgwQjogLy9jc3QuQ09ERV9ET1VCTEVfQklHOlxuICAgICAgICAgIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDtpIDwgODtpKyspIHRbaV0gPSByZWFkZXIucmVhZDh1ICgpO1xuICAgICAgICAgIHZhciB2ID0gY2FtbF9mbG9hdF9vZl9ieXRlcyAodCk7XG4gICAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjYXNlIDB4MEU6IC8vY3N0LkNPREVfRE9VQkxFX0FSUkFZOF9MSVRUTEU6XG4gICAgICAgICAgdmFyIGxlbiA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgICAgICB2YXIgdiA9IG5ldyBBcnJheShsZW4rMSk7XG4gICAgICAgICAgdlswXSA9IDI1NDtcbiAgICAgICAgICB2YXIgdCA9IG5ldyBBcnJheSg4KTs7XG4gICAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICAgIGZvciAodmFyIGkgPSAxO2kgPD0gbGVuO2krKykge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7aiA8IDg7aisrKSB0WzcgLSBqXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgICAgICAgIHZbaV0gPSBjYW1sX2Zsb2F0X29mX2J5dGVzICh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGNhc2UgMHgwRDogLy9jc3QuQ09ERV9ET1VCTEVfQVJSQVk4X0JJRzpcbiAgICAgICAgICB2YXIgbGVuID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgICAgIHZhciB2ID0gbmV3IEFycmF5KGxlbisxKTtcbiAgICAgICAgICB2WzBdID0gMjU0O1xuICAgICAgICAgIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDE7aSA8PSBsZW47aSsrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDtqIDwgODtqKyspIHRbal0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICAgICAgICB2IFtpXSA9IGNhbWxfZmxvYXRfb2ZfYnl0ZXMgKHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgY2FzZSAweDA3OiAvL2NzdC5DT0RFX0RPVUJMRV9BUlJBWTMyX0xJVFRMRTpcbiAgICAgICAgICB2YXIgbGVuID0gcmVhZGVyLnJlYWQzMnUoKTtcbiAgICAgICAgICB2YXIgdiA9IG5ldyBBcnJheShsZW4rMSk7XG4gICAgICAgICAgdlswXSA9IDI1NDtcbiAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7O1xuICAgICAgICAgIGZvciAodmFyIGkgPSAxO2kgPD0gbGVuO2krKykge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7aiA8IDg7aisrKSB0WzcgLSBqXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgICAgICAgIHZbaV0gPSBjYW1sX2Zsb2F0X29mX2J5dGVzICh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGNhc2UgMHgwRjogLy9jc3QuQ09ERV9ET1VCTEVfQVJSQVkzMl9CSUc6XG4gICAgICAgICAgdmFyIGxlbiA9IHJlYWRlci5yZWFkMzJ1KCk7XG4gICAgICAgICAgdmFyIHYgPSBuZXcgQXJyYXkobGVuKzEpO1xuICAgICAgICAgIHZbMF0gPSAyNTQ7XG4gICAgICAgICAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7O1xuICAgICAgICAgIGZvciAodmFyIGkgPSAxO2kgPD0gbGVuO2krKykge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7aiA8IDg7aisrKSB0W2pdID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgICAgICAgdiBbaV0gPSBjYW1sX2Zsb2F0X29mX2J5dGVzICh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGNhc2UgMHgxMDogLy9jc3QuQ09ERV9DT0RFUE9JTlRFUjpcbiAgICAgICAgY2FzZSAweDExOiAvL2NzdC5DT0RFX0lORklYUE9JTlRFUjpcbiAgICAgICAgICBjYW1sX2ZhaWx3aXRoIChcImlucHV0X3ZhbHVlOiBjb2RlIHBvaW50ZXJcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMHgxMjogLy9jc3QuQ09ERV9DVVNUT006XG4gICAgICAgIGNhc2UgMHgxODogLy9jc3QuQ09ERV9DVVNUT01fTEVOOlxuICAgICAgICBjYXNlIDB4MTk6IC8vY3N0LkNPREVfQ1VTVE9NX0ZJWEVEOlxuICAgICAgICAgIHZhciBjLCBzID0gXCJcIjtcbiAgICAgICAgICB3aGlsZSAoKGMgPSByZWFkZXIucmVhZDh1ICgpKSAhPSAwKSBzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUgKGMpO1xuICAgICAgICAgIHZhciBvcHMgPSBjYW1sX2N1c3RvbV9vcHNbc107XG4gICAgICAgICAgdmFyIGV4cGVjdGVkX3NpemU7XG4gICAgICAgICAgaWYoIW9wcylcbiAgICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogdW5rbm93biBjdXN0b20gYmxvY2sgaWRlbnRpZmllclwiKTtcbiAgICAgICAgICBzd2l0Y2goY29kZSl7XG4gICAgICAgICAgY2FzZSAweDEyOiAvLyBjc3QuQ09ERV9DVVNUT00gKGRlcHJlY2F0ZWQpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDB4MTk6IC8vIGNzdC5DT0RFX0NVU1RPTV9GSVhFRFxuICAgICAgICAgICAgaWYoIW9wcy5maXhlZF9sZW5ndGgpXG4gICAgICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogZXhwZWN0ZWQgYSBmaXhlZC1zaXplIGN1c3RvbSBibG9ja1wiKTtcbiAgICAgICAgICAgIGV4cGVjdGVkX3NpemUgPSBvcHMuZml4ZWRfbGVuZ3RoO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAweDE4OiAvLyBjc3QuQ09ERV9DVVNUT01fTEVOXG4gICAgICAgICAgICBleHBlY3RlZF9zaXplID0gcmVhZGVyLnJlYWQzMnUgKCk7XG4gICAgICAgICAgICAvLyBTa2lwIHNpemU2NFxuICAgICAgICAgICAgcmVhZGVyLnJlYWQzMnMoKTsgcmVhZGVyLnJlYWQzMnMoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgb2xkX3BvcyA9IHJlYWRlci5pO1xuICAgICAgICAgIHZhciBzaXplID0gWzBdO1xuICAgICAgICAgIHZhciB2ID0gb3BzLmRlc2VyaWFsaXplKHJlYWRlciwgc2l6ZSk7XG4gICAgICAgICAgaWYoZXhwZWN0ZWRfc2l6ZSAhPSB1bmRlZmluZWQpe1xuICAgICAgICAgICAgaWYoZXhwZWN0ZWRfc2l6ZSAhPSBzaXplWzBdKVxuICAgICAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwiaW5wdXRfdmFsdWU6IGluY29ycmVjdCBsZW5ndGggb2Ygc2VyaWFsaXplZCBjdXN0b20gYmxvY2tcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjYW1sX2ZhaWx3aXRoIChcImlucHV0X3ZhbHVlOiBpbGwtZm9ybWVkIG1lc3NhZ2VcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdmFyIHJlcyA9IGludGVybl9yZWMgKCk7XG4gIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgdmFyIHNpemUgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgdiA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBkID0gdi5sZW5ndGg7XG4gICAgaWYgKGQgPCBzaXplKSBzdGFjay5wdXNoKHYsIHNpemUpO1xuICAgIHZbZF0gPSBpbnRlcm5fcmVjICgpO1xuICB9XG4gIGlmICh0eXBlb2Ygb2ZzIT1cIm51bWJlclwiKSBvZnNbMF0gPSByZWFkZXIuaTtcbiAgcmV0dXJuIHJlcztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tYXJzaGFsX2RhdGFfc2l6ZSBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoLCBjYW1sX2J5dGVzX3Vuc2FmZV9nZXRcbmZ1bmN0aW9uIGNhbWxfbWFyc2hhbF9kYXRhX3NpemUgKHMsIG9mcykge1xuICBmdW5jdGlvbiBnZXQzMihzLGkpIHtcbiAgICByZXR1cm4gKGNhbWxfYnl0ZXNfdW5zYWZlX2dldChzLCBpKSA8PCAyNCkgfFxuICAgICAgKGNhbWxfYnl0ZXNfdW5zYWZlX2dldChzLCBpICsgMSkgPDwgMTYpIHxcbiAgICAgIChjYW1sX2J5dGVzX3Vuc2FmZV9nZXQocywgaSArIDIpIDw8IDgpIHxcbiAgICAgIGNhbWxfYnl0ZXNfdW5zYWZlX2dldChzLCBpICsgMyk7XG4gIH1cbiAgaWYgKGdldDMyKHMsIG9mcykgIT0gKDB4ODQ5NUE2QkV8MCkpXG4gICAgY2FtbF9mYWlsd2l0aChcIk1hcnNoYWwuZGF0YV9zaXplOiBiYWQgb2JqZWN0XCIpO1xuICByZXR1cm4gKGdldDMyKHMsIG9mcyArIDQpKTtcbn1cblxuLy9Qcm92aWRlczogTWxPYmplY3RUYWJsZVxudmFyIE1sT2JqZWN0VGFibGU7XG5pZiAodHlwZW9mIGpvb19nbG9iYWxfb2JqZWN0LldlYWtNYXAgPT09ICd1bmRlZmluZWQnKSB7XG4gIE1sT2JqZWN0VGFibGUgPSBmdW5jdGlvbigpIHtcbiAgICAvKiBwb2x5ZmlsbCAodXNpbmcgbGluZWFyIHNlYXJjaCkgKi9cbiAgICBmdW5jdGlvbiBOYWl2ZUxvb2t1cChvYmpzKSB7IHRoaXMub2JqcyA9IG9ianM7IH1cbiAgICBOYWl2ZUxvb2t1cC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24odikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm9ianMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMub2Jqc1tpXSA9PT0gdikgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfTtcbiAgICBOYWl2ZUxvb2t1cC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAvLyBEbyBub3RoaW5nIGhlcmUuIFtNbE9iamVjdFRhYmxlLnN0b3JlXSB3aWxsIHB1c2ggdG8gW3RoaXMub2Jqc10gZGlyZWN0bHkuXG4gICAgfTtcblxuICAgIHJldHVybiBmdW5jdGlvbiBNbE9iamVjdFRhYmxlKCkge1xuICAgICAgdGhpcy5vYmpzID0gW107IHRoaXMubG9va3VwID0gbmV3IE5haXZlTG9va3VwKHRoaXMub2Jqcyk7XG4gICAgfTtcbiAgfSgpO1xufVxuZWxzZSB7XG4gIE1sT2JqZWN0VGFibGUgPSBmdW5jdGlvbiBNbE9iamVjdFRhYmxlKCkge1xuICAgIHRoaXMub2JqcyA9IFtdOyB0aGlzLmxvb2t1cCA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5XZWFrTWFwKCk7XG4gIH07XG59XG5cbk1sT2JqZWN0VGFibGUucHJvdG90eXBlLnN0b3JlID0gZnVuY3Rpb24odikge1xuICB0aGlzLmxvb2t1cC5zZXQodiwgdGhpcy5vYmpzLmxlbmd0aCk7XG4gIHRoaXMub2Jqcy5wdXNoKHYpO1xufVxuXG5NbE9iamVjdFRhYmxlLnByb3RvdHlwZS5yZWNhbGwgPSBmdW5jdGlvbih2KSB7XG4gIHZhciBpID0gdGhpcy5sb29rdXAuZ2V0KHYpO1xuICByZXR1cm4gKGkgPT09IHVuZGVmaW5lZClcbiAgICA/IHVuZGVmaW5lZCA6IHRoaXMub2Jqcy5sZW5ndGggLSBpOyAgIC8qIGluZGV4IGlzIHJlbGF0aXZlICovXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbGVnYWN5X2N1c3RvbV9jb2RlXG4vL1ZlcnNpb246ID49IDQuMDhcbnZhciBjYW1sX2xlZ2FjeV9jdXN0b21fY29kZSA9IGZhbHNlXG5cbi8vUHJvdmlkZXM6IGNhbWxfbGVnYWN5X2N1c3RvbV9jb2RlXG4vL1ZlcnNpb246IDwgNC4wOFxudmFyIGNhbWxfbGVnYWN5X2N1c3RvbV9jb2RlID0gdHJ1ZVxuXG4vL1Byb3ZpZGVzOiBjYW1sX291dHB1dF92YWxcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfdG9fYnl0ZXMsIGNhbWxfZmFpbHdpdGhcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfYml0c19vZl9mbG9hdFxuLy9SZXF1aXJlczogY2FtbF9pc19tbF9ieXRlcywgY2FtbF9tbF9ieXRlc19sZW5ndGgsIGNhbWxfYnl0ZXNfdW5zYWZlX2dldFxuLy9SZXF1aXJlczogY2FtbF9pc19tbF9zdHJpbmcsIGNhbWxfbWxfc3RyaW5nX2xlbmd0aCwgY2FtbF9zdHJpbmdfdW5zYWZlX2dldFxuLy9SZXF1aXJlczogTWxPYmplY3RUYWJsZSwgY2FtbF9saXN0X3RvX2pzX2FycmF5LCBjYW1sX2xlZ2FjeV9jdXN0b21fY29kZSwgY2FtbF9jdXN0b21fb3BzXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnQsY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xudmFyIGNhbWxfb3V0cHV0X3ZhbCA9IGZ1bmN0aW9uICgpe1xuICBmdW5jdGlvbiBXcml0ZXIgKCkgeyB0aGlzLmNodW5rID0gW107IH1cbiAgV3JpdGVyLnByb3RvdHlwZSA9IHtcbiAgICBjaHVua19pZHg6MjAsIGJsb2NrX2xlbjowLCBvYmpfY291bnRlcjowLCBzaXplXzMyOjAsIHNpemVfNjQ6MCxcbiAgICB3cml0ZTpmdW5jdGlvbiAoc2l6ZSwgdmFsdWUpIHtcbiAgICAgIGZvciAodmFyIGkgPSBzaXplIC0gODtpID49IDA7aSAtPSA4KVxuICAgICAgICB0aGlzLmNodW5rW3RoaXMuY2h1bmtfaWR4KytdID0gKHZhbHVlID4+IGkpICYgMHhGRjtcbiAgICB9LFxuICAgIHdyaXRlX2F0OmZ1bmN0aW9uIChwb3MsIHNpemUsIHZhbHVlKSB7XG4gICAgICB2YXIgcG9zID0gcG9zO1xuICAgICAgZm9yICh2YXIgaSA9IHNpemUgLSA4O2kgPj0gMDtpIC09IDgpXG4gICAgICAgIHRoaXMuY2h1bmtbcG9zKytdID0gKHZhbHVlID4+IGkpICYgMHhGRjtcbiAgICB9LFxuICAgIHdyaXRlX2NvZGU6ZnVuY3Rpb24gKHNpemUsIGNvZGUsIHZhbHVlKSB7XG4gICAgICB0aGlzLmNodW5rW3RoaXMuY2h1bmtfaWR4KytdID0gY29kZTtcbiAgICAgIGZvciAodmFyIGkgPSBzaXplIC0gODtpID49IDA7aSAtPSA4KVxuICAgICAgICB0aGlzLmNodW5rW3RoaXMuY2h1bmtfaWR4KytdID0gKHZhbHVlID4+IGkpICYgMHhGRjtcbiAgICB9LFxuICAgIHdyaXRlX3NoYXJlZDpmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICBpZiAob2Zmc2V0IDwgKDEgPDwgOCkpIHRoaXMud3JpdGVfY29kZSg4LCAweDA0IC8qY3N0LkNPREVfU0hBUkVEOCovLCBvZmZzZXQpO1xuICAgICAgZWxzZSBpZiAob2Zmc2V0IDwgKDEgPDwgMTYpKSB0aGlzLndyaXRlX2NvZGUoMTYsIDB4MDUgLypjc3QuQ09ERV9TSEFSRUQxNiovLCBvZmZzZXQpO1xuICAgICAgZWxzZSB0aGlzLndyaXRlX2NvZGUoMzIsIDB4MDYgLypjc3QuQ09ERV9TSEFSRUQzMiovLCBvZmZzZXQpO1xuICAgIH0sXG4gICAgcG9zOmZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuY2h1bmtfaWR4IH0sXG4gICAgZmluYWxpemU6ZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5ibG9ja19sZW4gPSB0aGlzLmNodW5rX2lkeCAtIDIwO1xuICAgICAgdGhpcy5jaHVua19pZHggPSAwO1xuICAgICAgdGhpcy53cml0ZSAoMzIsIDB4ODQ5NUE2QkUpO1xuICAgICAgdGhpcy53cml0ZSAoMzIsIHRoaXMuYmxvY2tfbGVuKTtcbiAgICAgIHRoaXMud3JpdGUgKDMyLCB0aGlzLm9ial9jb3VudGVyKTtcbiAgICAgIHRoaXMud3JpdGUgKDMyLCB0aGlzLnNpemVfMzIpO1xuICAgICAgdGhpcy53cml0ZSAoMzIsIHRoaXMuc2l6ZV82NCk7XG4gICAgICByZXR1cm4gdGhpcy5jaHVuaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uICh2LCBmbGFncykge1xuICAgIGZsYWdzID0gY2FtbF9saXN0X3RvX2pzX2FycmF5KGZsYWdzKTtcblxuICAgIHZhciBub19zaGFyaW5nID0gKGZsYWdzLmluZGV4T2YoMCAvKk1hcnNoYWwuTm9fc2hhcmluZyovKSAhPT0gLTEpLFxuICAgICAgICBjbG9zdXJlcyA9ICAoZmxhZ3MuaW5kZXhPZigxIC8qTWFyc2hhbC5DbG9zdXJlcyovKSAhPT0gLTEpO1xuICAgICAgICAvKiBNYXJzaGFsLkNvbXBhdF8zMiBpcyByZWR1bmRhbnQgc2luY2UgaW50ZWdlcnMgYXJlIDMyLWJpdCBhbnl3YXkgKi9cblxuICAgIGlmIChjbG9zdXJlcylcbiAgICAgIGpvb19nbG9iYWxfb2JqZWN0LmNvbnNvbGUud2FybihcImluIGNhbWxfb3V0cHV0X3ZhbDogZmxhZyBNYXJzaGFsLkNsb3N1cmVzIGlzIG5vdCBzdXBwb3J0ZWQuXCIpO1xuXG4gICAgdmFyIHdyaXRlciA9IG5ldyBXcml0ZXIgKCk7XG4gICAgdmFyIHN0YWNrID0gW107XG4gICAgdmFyIGludGVybl9vYmpfdGFibGUgPSBub19zaGFyaW5nID8gbnVsbCA6IG5ldyBNbE9iamVjdFRhYmxlKCk7XG5cbiAgICBmdW5jdGlvbiBtZW1vKHYpIHtcbiAgICAgIGlmIChub19zaGFyaW5nKSByZXR1cm4gZmFsc2U7XG4gICAgICB2YXIgZXhpc3Rpbmdfb2Zmc2V0ID0gaW50ZXJuX29ial90YWJsZS5yZWNhbGwodik7XG4gICAgICBpZiAoZXhpc3Rpbmdfb2Zmc2V0KSB7IHdyaXRlci53cml0ZV9zaGFyZWQoZXhpc3Rpbmdfb2Zmc2V0KTsgcmV0dXJuIHRydWU7IH1cbiAgICAgIGVsc2UgeyBpbnRlcm5fb2JqX3RhYmxlLnN0b3JlKHYpOyByZXR1cm4gZmFsc2U7IH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHRlcm5fcmVjICh2KSB7XG4gICAgICBpZiAodi5jYW1sX2N1c3RvbSkge1xuICAgICAgICBpZiAobWVtbyh2KSkgcmV0dXJuO1xuICAgICAgICB2YXIgbmFtZSA9IHYuY2FtbF9jdXN0b207XG4gICAgICAgIHZhciBvcHMgPSBjYW1sX2N1c3RvbV9vcHNbbmFtZV07XG4gICAgICAgIHZhciBzel8zMl82NCA9IFswLDBdO1xuICAgICAgICBpZighb3BzLnNlcmlhbGl6ZSlcbiAgICAgICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJvdXRwdXRfdmFsdWU6IGFic3RyYWN0IHZhbHVlIChDdXN0b20pXCIpO1xuICAgICAgICBpZihjYW1sX2xlZ2FjeV9jdXN0b21fY29kZSkge1xuICAgICAgICAgIHdyaXRlci53cml0ZSAoOCwgMHgxMiAvKmNzdC5DT0RFX0NVU1RPTSovKTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWUubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIG5hbWUuY2hhckNvZGVBdChpKSk7XG4gICAgICAgICAgd3JpdGVyLndyaXRlKDgsIDApO1xuICAgICAgICAgIG9wcy5zZXJpYWxpemUod3JpdGVyLCB2LCBzel8zMl82NCk7XG4gICAgICAgIH0gZWxzZSBpZihvcHMuZml4ZWRfbGVuZ3RoID09IHVuZGVmaW5lZCl7XG4gICAgICAgICAgd3JpdGVyLndyaXRlICg4LCAweDE4IC8qY3N0LkNPREVfQ1VTVE9NX0xFTiovKTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWUubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIG5hbWUuY2hhckNvZGVBdChpKSk7XG4gICAgICAgICAgd3JpdGVyLndyaXRlKDgsIDApO1xuICAgICAgICAgIHZhciBoZWFkZXJfcG9zID0gd3JpdGVyLnBvcyAoKTtcbiAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgd3JpdGVyLndyaXRlKDgsIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvcHMuc2VyaWFsaXplKHdyaXRlciwgdiwgc3pfMzJfNjQpO1xuICAgICAgICAgIHdyaXRlci53cml0ZV9hdChoZWFkZXJfcG9zLCAzMiwgc3pfMzJfNjRbMF0pO1xuICAgICAgICAgIHdyaXRlci53cml0ZV9hdChoZWFkZXJfcG9zICsgNCwgMzIsIDApOyAvLyB6ZXJvXG4gICAgICAgICAgd3JpdGVyLndyaXRlX2F0KGhlYWRlcl9wb3MgKyA4LCAzMiwgc3pfMzJfNjRbMV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdyaXRlci53cml0ZSAoOCwgMHgxOSAvKmNzdC5DT0RFX0NVU1RPTV9GSVhFRCovKTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWUubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIG5hbWUuY2hhckNvZGVBdChpKSk7XG4gICAgICAgICAgd3JpdGVyLndyaXRlKDgsIDApO1xuICAgICAgICAgIHZhciBvbGRfcG9zID0gd3JpdGVyLnBvcygpO1xuICAgICAgICAgIG9wcy5zZXJpYWxpemUod3JpdGVyLCB2LCBzel8zMl82NCk7XG4gICAgICAgICAgaWYgKG9wcy5maXhlZF9sZW5ndGggIT0gd3JpdGVyLnBvcygpIC0gb2xkX3BvcylcbiAgICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJvdXRwdXRfdmFsdWU6IGluY29ycmVjdCBmaXhlZCBzaXplcyBzcGVjaWZpZWQgYnkgXCIgKyBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICB3cml0ZXIuc2l6ZV8zMiArPSAyICsgKChzel8zMl82NFswXSArIDMpID4+IDIpO1xuICAgICAgICB3cml0ZXIuc2l6ZV82NCArPSAyICsgKChzel8zMl82NFsxXSArIDcpID4+IDMpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodiBpbnN0YW5jZW9mIEFycmF5ICYmIHZbMF0gPT09ICh2WzBdfDApKSB7XG4gICAgICAgIGlmICh2WzBdID09IDI1MSkge1xuICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJvdXRwdXRfdmFsdWU6IGFic3RyYWN0IHZhbHVlIChBYnN0cmFjdClcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHYubGVuZ3RoID4gMSAmJiBtZW1vKHYpKSByZXR1cm47XG4gICAgICAgIGlmICh2WzBdIDwgMTYgJiYgdi5sZW5ndGggLSAxIDwgOClcbiAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIDB4ODAgLypjc3QuUFJFRklYX1NNQUxMX0JMT0NLKi8gKyB2WzBdICsgKCh2Lmxlbmd0aCAtIDEpPDw0KSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB3cml0ZXIud3JpdGVfY29kZSgzMiwgMHgwOCAvKmNzdC5DT0RFX0JMT0NLMzIqLywgKCh2Lmxlbmd0aC0xKSA8PCAxMCkgfCB2WzBdKTtcbiAgICAgICAgd3JpdGVyLnNpemVfMzIgKz0gdi5sZW5ndGg7XG4gICAgICAgIHdyaXRlci5zaXplXzY0ICs9IHYubGVuZ3RoO1xuICAgICAgICBpZiAodi5sZW5ndGggPiAxKSBzdGFjay5wdXNoICh2LCAxKTtcbiAgICAgIH0gZWxzZSBpZiAoY2FtbF9pc19tbF9ieXRlcyh2KSkge1xuICAgICAgICBpZighKGNhbWxfaXNfbWxfYnl0ZXMoY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhcIlwiKSkpKSB7XG4gICAgICAgICAgY2FtbF9mYWlsd2l0aChcIm91dHB1dF92YWx1ZTogW0J5dGVzLnRdIGNhbm5vdCBzYWZlbHkgYmUgbWFyc2hhbGVkIHdpdGggWy0tZW5hYmxlIHVzZS1qcy1zdHJpbmddXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZW1vKHYpKSByZXR1cm47XG4gICAgICAgIHZhciBsZW4gPSBjYW1sX21sX2J5dGVzX2xlbmd0aCh2KTtcbiAgICAgICAgaWYgKGxlbiA8IDB4MjApXG4gICAgICAgICAgd3JpdGVyLndyaXRlICg4LCAweDIwIC8qY3N0LlBSRUZJWF9TTUFMTF9TVFJJTkcqLyArIGxlbik7XG4gICAgICAgIGVsc2UgaWYgKGxlbiA8IDB4MTAwKVxuICAgICAgICAgIHdyaXRlci53cml0ZV9jb2RlICg4LCAweDA5Lypjc3QuQ09ERV9TVFJJTkc4Ki8sIGxlbik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB3cml0ZXIud3JpdGVfY29kZSAoMzIsIDB4MEEgLypjc3QuQ09ERV9TVFJJTkczMiovLCBsZW4pO1xuICAgICAgICBmb3IgKHZhciBpID0gMDtpIDwgbGVuO2krKylcbiAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIGNhbWxfYnl0ZXNfdW5zYWZlX2dldCh2LGkpKTtcbiAgICAgICAgd3JpdGVyLnNpemVfMzIgKz0gMSArICgoKGxlbiArIDQpIC8gNCl8MCk7XG4gICAgICAgIHdyaXRlci5zaXplXzY0ICs9IDEgKyAoKChsZW4gKyA4KSAvIDgpfDApO1xuICAgICAgfSBlbHNlIGlmIChjYW1sX2lzX21sX3N0cmluZyh2KSkge1xuICAgICAgICB2YXIgbGVuID0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHYpO1xuICAgICAgICBpZiAobGVuIDwgMHgyMClcbiAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIDB4MjAgLypjc3QuUFJFRklYX1NNQUxMX1NUUklORyovICsgbGVuKTtcbiAgICAgICAgZWxzZSBpZiAobGVuIDwgMHgxMDApXG4gICAgICAgICAgd3JpdGVyLndyaXRlX2NvZGUgKDgsIDB4MDkvKmNzdC5DT0RFX1NUUklORzgqLywgbGVuKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHdyaXRlci53cml0ZV9jb2RlICgzMiwgMHgwQSAvKmNzdC5DT0RFX1NUUklORzMyKi8sIGxlbik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwO2kgPCBsZW47aSsrKVxuICAgICAgICAgIHdyaXRlci53cml0ZSAoOCwgY2FtbF9zdHJpbmdfdW5zYWZlX2dldCh2LGkpKTtcbiAgICAgICAgd3JpdGVyLnNpemVfMzIgKz0gMSArICgoKGxlbiArIDQpIC8gNCl8MCk7XG4gICAgICAgIHdyaXRlci5zaXplXzY0ICs9IDEgKyAoKChsZW4gKyA4KSAvIDgpfDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHYgIT0gKHZ8MCkpe1xuICAgICAgICAgIHZhciB0eXBlX29mX3YgPSB0eXBlb2YgdjtcbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIElmIGEgZmxvYXQgaGFwcGVucyB0byBiZSBhbiBpbnRlZ2VyIGl0IGlzIHNlcmlhbGl6ZWQgYXMgYW4gaW50ZWdlclxuICAgICAgICAgIC8vIChKc19vZl9vY2FtbCBjYW5ub3QgdGVsbCB3aGV0aGVyIHRoZSB0eXBlIG9mIGFuIGludGVnZXIgbnVtYmVyIGlzXG4gICAgICAgICAgLy8gZmxvYXQgb3IgaW50ZWdlci4pIFRoaXMgY2FuIHJlc3VsdCBpbiB1bmV4cGVjdGVkIGNyYXNoZXMgd2hlblxuICAgICAgICAgIC8vIHVubWFyc2hhbGxpbmcgdXNpbmcgdGhlIHN0YW5kYXJkIHJ1bnRpbWUuIEl0IHNlZW1zIGJldHRlciB0b1xuICAgICAgICAgIC8vIHN5c3RlbWF0aWNhbGx5IGZhaWwgb24gbWFyc2hhbGxpbmcuXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyAgICAgICAgICBpZih0eXBlX29mX3YgIT0gXCJudW1iZXJcIilcbiAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwib3V0cHV0X3ZhbHVlOiBhYnN0cmFjdCB2YWx1ZSAoXCIrdHlwZV9vZl92K1wiKVwiKTtcbiAgICAgICAgICAvLyAgICAgICAgICB2YXIgdCA9IGNhbWxfaW50NjRfdG9fYnl0ZXMoY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0KHYpKTtcbiAgICAgICAgICAvLyAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIDB4MEIgLypjc3QuQ09ERV9ET1VCTEVfQklHKi8pO1xuICAgICAgICAgIC8vICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGk8ODsgaSsrKXt3cml0ZXIud3JpdGUoOCx0W2ldKX1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2ID49IDAgJiYgdiA8IDB4NDApIHtcbiAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIDBYNDAgLypjc3QuUFJFRklYX1NNQUxMX0lOVCovICsgdik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHYgPj0gLSgxIDw8IDcpICYmIHYgPCAoMSA8PCA3KSlcbiAgICAgICAgICAgIHdyaXRlci53cml0ZV9jb2RlKDgsIDB4MDAgLypjc3QuQ09ERV9JTlQ4Ki8sIHYpO1xuICAgICAgICAgIGVsc2UgaWYgKHYgPj0gLSgxIDw8IDE1KSAmJiB2IDwgKDEgPDwgMTUpKVxuICAgICAgICAgICAgd3JpdGVyLndyaXRlX2NvZGUoMTYsIDB4MDEgLypjc3QuQ09ERV9JTlQxNiovLCB2KTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB3cml0ZXIud3JpdGVfY29kZSgzMiwgMHgwMiAvKmNzdC5DT0RFX0lOVDMyKi8sIHYpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGV4dGVybl9yZWMgKHYpO1xuICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgaSA9IHN0YWNrLnBvcCAoKTtcbiAgICAgIHZhciB2ID0gc3RhY2sucG9wICgpO1xuICAgICAgaWYgKGkgKyAxIDwgdi5sZW5ndGgpIHN0YWNrLnB1c2ggKHYsIGkgKyAxKTtcbiAgICAgIGV4dGVybl9yZWMgKHZbaV0pO1xuICAgIH1cbiAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgd3JpdGVyLm9ial9jb3VudGVyID0gaW50ZXJuX29ial90YWJsZS5vYmpzLmxlbmd0aDtcbiAgICB3cml0ZXIuZmluYWxpemUoKTtcbiAgICByZXR1cm4gd3JpdGVyLmNodW5rO1xuICB9XG59ICgpO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX291dHB1dF92YWx1ZV90b19zdHJpbmcgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9vdXRwdXRfdmFsLCBjYW1sX3N0cmluZ19vZl9hcnJheVxuZnVuY3Rpb24gY2FtbF9vdXRwdXRfdmFsdWVfdG9fc3RyaW5nICh2LCBmbGFncykge1xuICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfYXJyYXkgKGNhbWxfb3V0cHV0X3ZhbCAodiwgZmxhZ3MpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vdXRwdXRfdmFsdWVfdG9fYnl0ZXMgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9vdXRwdXRfdmFsLCBjYW1sX2J5dGVzX29mX2FycmF5XG5mdW5jdGlvbiBjYW1sX291dHB1dF92YWx1ZV90b19ieXRlcyAodiwgZmxhZ3MpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfb2ZfYXJyYXkgKGNhbWxfb3V0cHV0X3ZhbCAodiwgZmxhZ3MpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vdXRwdXRfdmFsdWVfdG9fYnVmZmVyXG4vL1JlcXVpcmVzOiBjYW1sX291dHB1dF92YWwsIGNhbWxfZmFpbHdpdGgsIGNhbWxfYmxpdF9ieXRlc1xuZnVuY3Rpb24gY2FtbF9vdXRwdXRfdmFsdWVfdG9fYnVmZmVyIChzLCBvZnMsIGxlbiwgdiwgZmxhZ3MpIHtcbiAgdmFyIHQgPSBjYW1sX291dHB1dF92YWwgKHYsIGZsYWdzKTtcbiAgaWYgKHQubGVuZ3RoID4gbGVuKSBjYW1sX2ZhaWx3aXRoIChcIk1hcnNoYWwudG9fYnVmZmVyOiBidWZmZXIgb3ZlcmZsb3dcIik7XG4gIGNhbWxfYmxpdF9ieXRlcyh0LCAwLCBzLCBvZnMsIHQubGVuZ3RoKTtcbiAgcmV0dXJuIDA7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTQgSsOpcsO0bWUgVm91aWxsb24sIEh1Z28gSGV1emFyZFxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vLy8vLy8vLy8vLy8vIElvXG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2Nsb3NlXG4vL1JlcXVpcmVzOiBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX3N5c19jbG9zZShmZCkge1xuICBkZWxldGUgY2FtbF9nbG9iYWxfZGF0YS5mZHNbZmRdO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdGRfb3V0cHV0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzLCBjYW1sX21sX3N0cmluZ19sZW5ndGgsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfc3RkX291dHB1dChjaGFuaWQscyl7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICB2YXIgc3RyID0gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhzKTtcbiAgdmFyIHNsZW4gPSBjYW1sX21sX3N0cmluZ19sZW5ndGgoc3RyKTtcbiAgY2hhbi5maWxlLndyaXRlKGNoYW4ub2Zmc2V0LCBzdHIsIDAsIHNsZW4pO1xuICBjaGFuLm9mZnNldCArPSBzbGVuO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfb3BlblxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXNfZXJyb3IsIGNhbWxfZ2xvYmFsX2RhdGFcbi8vUmVxdWlyZXM6IGNhbWxfY3JlYXRlX2J5dGVzLE1sRmFrZUZpbGVcbi8vUmVxdWlyZXM6IGpzX3ByaW50X3N0ZGVyciwganNfcHJpbnRfc3Rkb3V0XG4vL1JlcXVpcmVzOiBjYW1sX3N0ZF9vdXRwdXRcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlXG4vL1JlcXVpcmVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N5c19vcGVuX2ludGVybmFsKGlkeCxvdXRwdXQsZmlsZSxmbGFncykge1xuICBpZihjYW1sX2dsb2JhbF9kYXRhLmZkcyA9PT0gdW5kZWZpbmVkKSBjYW1sX2dsb2JhbF9kYXRhLmZkcyA9IG5ldyBBcnJheSgpO1xuICBmbGFncz1mbGFncz9mbGFnczp7fTtcbiAgdmFyIGluZm8gPSB7fTtcbiAgaW5mby5maWxlID0gZmlsZTtcbiAgaW5mby5vZmZzZXQgPSBmbGFncy5hcHBlbmQ/ZmlsZS5sZW5ndGgoKTowO1xuICBpbmZvLmZsYWdzID0gZmxhZ3M7XG4gIGluZm8ub3V0cHV0ID0gb3V0cHV0O1xuICBjYW1sX2dsb2JhbF9kYXRhLmZkc1tpZHhdID0gaW5mbztcbiAgaWYoIWNhbWxfZ2xvYmFsX2RhdGEuZmRfbGFzdF9pZHggfHwgaWR4ID4gY2FtbF9nbG9iYWxfZGF0YS5mZF9sYXN0X2lkeClcbiAgICBjYW1sX2dsb2JhbF9kYXRhLmZkX2xhc3RfaWR4ID0gaWR4O1xuICByZXR1cm4gaWR4O1xufVxuZnVuY3Rpb24gY2FtbF9zeXNfb3BlbiAobmFtZSwgZmxhZ3MsIF9wZXJtcykge1xuICB2YXIgZiA9IHt9O1xuICB3aGlsZShmbGFncyl7XG4gICAgc3dpdGNoKGZsYWdzWzFdKXtcbiAgICBjYXNlIDA6IGYucmRvbmx5ID0gMTticmVhaztcbiAgICBjYXNlIDE6IGYud3Jvbmx5ID0gMTticmVhaztcbiAgICBjYXNlIDI6IGYuYXBwZW5kID0gMTticmVhaztcbiAgICBjYXNlIDM6IGYuY3JlYXRlID0gMTticmVhaztcbiAgICBjYXNlIDQ6IGYudHJ1bmNhdGUgPSAxO2JyZWFrO1xuICAgIGNhc2UgNTogZi5leGNsID0gMTsgYnJlYWs7XG4gICAgY2FzZSA2OiBmLmJpbmFyeSA9IDE7YnJlYWs7XG4gICAgY2FzZSA3OiBmLnRleHQgPSAxO2JyZWFrO1xuICAgIGNhc2UgODogZi5ub25ibG9jayA9IDE7YnJlYWs7XG4gICAgfVxuICAgIGZsYWdzPWZsYWdzWzJdO1xuICB9XG4gIGlmKGYucmRvbmx5ICYmIGYud3Jvbmx5KVxuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKGNhbWxfanNieXRlc19vZl9zdHJpbmcobmFtZSkgKyBcIiA6IGZsYWdzIE9wZW5fcmRvbmx5IGFuZCBPcGVuX3dyb25seSBhcmUgbm90IGNvbXBhdGlibGVcIik7XG4gIGlmKGYudGV4dCAmJiBmLmJpbmFyeSlcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKG5hbWUpICsgXCIgOiBmbGFncyBPcGVuX3RleHQgYW5kIE9wZW5fYmluYXJ5IGFyZSBub3QgY29tcGF0aWJsZVwiKTtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgdmFyIGZpbGUgPSByb290LmRldmljZS5vcGVuKHJvb3QucmVzdCxmKTtcbiAgdmFyIGlkeCA9IGNhbWxfZ2xvYmFsX2RhdGEuZmRfbGFzdF9pZHg/Y2FtbF9nbG9iYWxfZGF0YS5mZF9sYXN0X2lkeDowO1xuICByZXR1cm4gY2FtbF9zeXNfb3Blbl9pbnRlcm5hbCAoaWR4KzEsY2FtbF9zdGRfb3V0cHV0LGZpbGUsZik7XG59XG5jYW1sX3N5c19vcGVuX2ludGVybmFsKDAsY2FtbF9zdGRfb3V0cHV0LCBuZXcgTWxGYWtlRmlsZShjYW1sX2NyZWF0ZV9ieXRlcygwKSkpOyAvL3N0ZGluXG5jYW1sX3N5c19vcGVuX2ludGVybmFsKDEsanNfcHJpbnRfc3Rkb3V0LCBuZXcgTWxGYWtlRmlsZShjYW1sX2NyZWF0ZV9ieXRlcygwKSkpOyAvL3N0ZG91dFxuY2FtbF9zeXNfb3Blbl9pbnRlcm5hbCgyLGpzX3ByaW50X3N0ZGVyciwgbmV3IE1sRmFrZUZpbGUoY2FtbF9jcmVhdGVfYnl0ZXMoMCkpKTsgLy9zdGRlcnJcblxuXG4vLyBvY2FtbCBDaGFubmVsc1xuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3NldF9jaGFubmVsX25hbWVcbmZ1bmN0aW9uIGNhbWxfbWxfc2V0X2NoYW5uZWxfbmFtZSgpIHtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9jaGFubmVsc1xudmFyIGNhbWxfbWxfY2hhbm5lbHMgPSBuZXcgQXJyYXkoKTtcblxuLy9Qcm92aWRlczogY2FtbF9tbF9vdXRfY2hhbm5lbHNfbGlzdFxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9vdXRfY2hhbm5lbHNfbGlzdCAoKSB7XG4gIHZhciBsID0gMDtcbiAgZm9yKHZhciBjID0gMDsgYyA8IGNhbWxfbWxfY2hhbm5lbHMubGVuZ3RoOyBjKyspe1xuICAgIGlmKGNhbWxfbWxfY2hhbm5lbHNbY10gJiYgY2FtbF9tbF9jaGFubmVsc1tjXS5vcGVuZWQgJiYgY2FtbF9tbF9jaGFubmVsc1tjXS5vdXQpXG4gICAgICBsPVswLGNhbWxfbWxfY2hhbm5lbHNbY10uZmQsbF07XG4gIH1cbiAgcmV0dXJuIGw7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3Jfb3V0XG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxzLCBjYW1sX2dsb2JhbF9kYXRhXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3N5c19lcnJvclxuZnVuY3Rpb24gY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3Jfb3V0IChmZCkge1xuICB2YXIgZGF0YSA9IGNhbWxfZ2xvYmFsX2RhdGEuZmRzW2ZkXTtcbiAgaWYoZGF0YS5mbGFncy5yZG9ubHkpIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKFwiZmQgXCIrIGZkICsgXCIgaXMgcmVhZG9ubHlcIik7XG4gIHZhciBjaGFubmVsID0ge1xuICAgIGZpbGU6ZGF0YS5maWxlLFxuICAgIG9mZnNldDpkYXRhLm9mZnNldCxcbiAgICBmZDpmZCxcbiAgICBvcGVuZWQ6dHJ1ZSxcbiAgICBvdXQ6dHJ1ZSxcbiAgICBidWZmZXI6XCJcIlxuICB9O1xuICBjYW1sX21sX2NoYW5uZWxzW2NoYW5uZWwuZmRdPWNoYW5uZWw7XG4gIHJldHVybiBjaGFubmVsLmZkO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9pblxuLy9SZXF1aXJlczogY2FtbF9nbG9iYWxfZGF0YSxjYW1sX3N5c19vcGVuLGNhbWxfcmFpc2Vfc3lzX2Vycm9yLCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9pbiAoZmQpICB7XG4gIHZhciBkYXRhID0gY2FtbF9nbG9iYWxfZGF0YS5mZHNbZmRdO1xuICBpZihkYXRhLmZsYWdzLndyb25seSkgY2FtbF9yYWlzZV9zeXNfZXJyb3IoXCJmZCBcIisgZmQgKyBcIiBpcyB3cml0ZW9ubHlcIik7XG5cbiAgdmFyIGNoYW5uZWwgPSB7XG4gICAgZmlsZTpkYXRhLmZpbGUsXG4gICAgb2Zmc2V0OmRhdGEub2Zmc2V0LFxuICAgIGZkOmZkLFxuICAgIG9wZW5lZDp0cnVlLFxuICAgIG91dDogZmFsc2UsXG4gICAgcmVmaWxsOm51bGxcbiAgfTtcbiAgY2FtbF9tbF9jaGFubmVsc1tjaGFubmVsLmZkXT1jaGFubmVsO1xuICByZXR1cm4gY2hhbm5lbC5mZDtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NoYW5uZWxfZGVzY3JpcHRvclxuLy9SZXF1aXJlczogY2FtbF9nbG9iYWxfZGF0YSwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9jaGFubmVsX2Rlc2NyaXB0b3IoY2hhbmlkKXtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIHJldHVybiBjaGFuLmZkO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2V0X2JpbmFyeV9tb2RlXG4vL1JlcXVpcmVzOiBjYW1sX2dsb2JhbF9kYXRhLCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX3NldF9iaW5hcnlfbW9kZShjaGFuaWQsbW9kZSl7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICB2YXIgZGF0YSA9IGNhbWxfZ2xvYmFsX2RhdGEuZmRzW2NoYW4uZmRdO1xuICBkYXRhLmZsYWdzLnRleHQgPSAhbW9kZVxuICBkYXRhLmZsYWdzLmJpbmFyeSA9IG1vZGVcbiAgcmV0dXJuIDA7XG59XG5cbi8vSW5wdXQgZnJvbSBpbl9jaGFubmVsXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfY2xvc2VfY2hhbm5lbFxuLy9SZXF1aXJlczogY2FtbF9tbF9mbHVzaCwgY2FtbF9tbF9jaGFubmVsc1xuLy9SZXF1aXJlczogY2FtbF9zeXNfY2xvc2VcbmZ1bmN0aW9uIGNhbWxfbWxfY2xvc2VfY2hhbm5lbCAoY2hhbmlkKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICBjYW1sX21sX2ZsdXNoKGNoYW5pZCk7XG4gIGNoYW4ub3BlbmVkID0gZmFsc2U7XG4gIGNoYW4uZmlsZS5jbG9zZSgpO1xuICBjYW1sX3N5c19jbG9zZShjaGFuLmZkKVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9jaGFubmVsX3NpemVcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfY2hhbm5lbF9zaXplKGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgcmV0dXJuIGNoYW4uZmlsZS5sZW5ndGgoKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9jaGFubmVsX3NpemVfNjRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfZmxvYXQsY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9jaGFubmVsX3NpemVfNjQoY2hhbmlkKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICByZXR1cm4gY2FtbF9pbnQ2NF9vZl9mbG9hdChjaGFuLmZpbGUubGVuZ3RoICgpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9zZXRfY2hhbm5lbF9vdXRwdXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbHMsIGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfbWxfc2V0X2NoYW5uZWxfb3V0cHV0KGNoYW5pZCxmKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICBjYW1sX2dsb2JhbF9kYXRhLmZkc1tjaGFuLmZkXS5vdXRwdXQgPSBmO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9zZXRfY2hhbm5lbF9yZWZpbGxcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbHMsIGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfbWxfc2V0X2NoYW5uZWxfcmVmaWxsKGNoYW5pZCxmKSB7XG4gIGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXS5yZWZpbGwgPSBmO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9yZWZpbGxfaW5wdXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9tbF9yZWZpbGxfaW5wdXQgKGNoYW4pIHtcbiAgdmFyIHN0ciA9IGNoYW4ucmVmaWxsKCk7XG4gIHZhciBzdHJfbGVuID0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHN0cik7XG4gIGlmIChzdHJfbGVuID09IDApIGNoYW4ucmVmaWxsID0gbnVsbDtcbiAgY2hhbi5maWxlLndyaXRlKGNoYW4uZmlsZS5sZW5ndGgoKSwgc3RyLCAwLCBzdHJfbGVuKTtcbiAgcmV0dXJuIHN0cl9sZW47XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfbWF5X3JlZmlsbF9pbnB1dFxuLy9SZXF1aXJlczogY2FtbF9tbF9yZWZpbGxfaW5wdXQsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfbWF5X3JlZmlsbF9pbnB1dCAoY2hhbmlkKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICBpZiAoY2hhbi5yZWZpbGwgPT0gbnVsbCkgcmV0dXJuO1xuICBpZiAoY2hhbi5maWxlLmxlbmd0aCgpICE9IGNoYW4ub2Zmc2V0KSByZXR1cm47XG4gIGNhbWxfbWxfcmVmaWxsX2lucHV0IChjaGFuKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9pbnB1dFxuLy9SZXF1aXJlczogY2FtbF9tbF9yZWZpbGxfaW5wdXQsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfaW5wdXQgKGNoYW5pZCwgcywgaSwgbCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgdmFyIGwyID0gY2hhbi5maWxlLmxlbmd0aCgpIC0gY2hhbi5vZmZzZXQ7XG4gIGlmIChsMiA9PSAwICYmIGNoYW4ucmVmaWxsICE9IG51bGwpIGwyID0gY2FtbF9tbF9yZWZpbGxfaW5wdXQoY2hhbik7XG4gIGlmIChsMiA8IGwpIGwgPSBsMjtcbiAgY2hhbi5maWxlLnJlYWQoY2hhbi5vZmZzZXQsIHMsIGksIGwpO1xuICBjaGFuLm9mZnNldCArPSBsO1xuICByZXR1cm4gbDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnB1dF92YWx1ZVxuLy9SZXF1aXJlczogY2FtbF9tYXJzaGFsX2RhdGFfc2l6ZSwgY2FtbF9pbnB1dF92YWx1ZV9mcm9tX2J5dGVzLCBjYW1sX2NyZWF0ZV9ieXRlcywgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9pbnB1dF92YWx1ZSAoY2hhbmlkKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuXG4gIHZhciBidWYgPSBjYW1sX2NyZWF0ZV9ieXRlcyg4KTtcbiAgY2hhbi5maWxlLnJlYWQoY2hhbi5vZmZzZXQsYnVmLDAsOCk7XG5cbiAgLy8gSGVhZGVyIGlzIDIwIGJ5dGVzXG4gIHZhciBsZW4gPSBjYW1sX21hcnNoYWxfZGF0YV9zaXplIChidWYsIDApICsgMjA7XG5cbiAgdmFyIGJ1ZiA9IGNhbWxfY3JlYXRlX2J5dGVzKGxlbik7XG4gIGNoYW4uZmlsZS5yZWFkKGNoYW4ub2Zmc2V0LGJ1ZiwwLGxlbik7XG5cbiAgdmFyIG9mZnNldCA9IFswXTtcbiAgdmFyIHJlcyA9IGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9ieXRlcyhidWYsIG9mZnNldCk7XG4gIGNoYW4ub2Zmc2V0ID0gY2hhbi5vZmZzZXQgKyBvZmZzZXRbMF07XG4gIHJldHVybiByZXM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfaW5wdXRfY2hhclxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZSwgY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9tbF9tYXlfcmVmaWxsX2lucHV0LCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX2lucHV0X2NoYXIgKGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgY2FtbF9tbF9tYXlfcmVmaWxsX2lucHV0KGNoYW5pZCk7XG4gIGlmIChjaGFuLm9mZnNldCA+PSBjaGFuLmZpbGUubGVuZ3RoKCkpXG4gICAgY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZSgpO1xuICB2YXIgcmVzID0gY2hhbi5maWxlLnJlYWRfb25lKGNoYW4ub2Zmc2V0KTtcbiAgY2hhbi5vZmZzZXQrKztcbiAgcmV0dXJuIHJlcztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9pbnB1dF9pbnRcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2VfZW5kX29mX2ZpbGVcbi8vUmVxdWlyZXM6IGNhbWxfbWxfcmVmaWxsX2lucHV0LCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX2lucHV0X2ludCAoY2hhbmlkKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICB2YXIgZmlsZSA9IGNoYW4uZmlsZTtcbiAgd2hpbGUgKChjaGFuLm9mZnNldCArIDMpID49IGZpbGUubGVuZ3RoKCkpIHtcbiAgICB2YXIgbCA9IGNhbWxfbWxfcmVmaWxsX2lucHV0KGNoYW4pO1xuICAgIGlmIChsID09IDApIGNhbWxfcmFpc2VfZW5kX29mX2ZpbGUoKTtcbiAgfVxuICB2YXIgbyA9IGNoYW4ub2Zmc2V0O1xuICB2YXIgciA9KGZpbGUucmVhZF9vbmUobyAgKSA8PCAyNClcbiAgICAgIHwgIChmaWxlLnJlYWRfb25lKG8rMSkgPDwgMTYpXG4gICAgICB8ICAoZmlsZS5yZWFkX29uZShvKzIpIDw8IDgpXG4gICAgICB8ICAoZmlsZS5yZWFkX29uZShvKzMpKTtcbiAgY2hhbi5vZmZzZXQrPTQ7XG4gIHJldHVybiByO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3NlZWtfaW5cbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfc3lzX2Vycm9yLCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX3NlZWtfaW4oY2hhbmlkLHBvcyl7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICBpZiAoY2hhbi5yZWZpbGwgIT0gbnVsbCkgY2FtbF9yYWlzZV9zeXNfZXJyb3IoXCJJbGxlZ2FsIHNlZWtcIik7XG4gIGNoYW4ub2Zmc2V0ID0gcG9zO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9zZWVrX2luXzY0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3RvX2Zsb2F0LCBjYW1sX3JhaXNlX3N5c19lcnJvciwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9zZWVrX2luXzY0KGNoYW5pZCxwb3Mpe1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgaWYgKGNoYW4ucmVmaWxsICE9IG51bGwpIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKFwiSWxsZWdhbCBzZWVrXCIpO1xuICBjaGFuLm9mZnNldCA9IGNhbWxfaW50NjRfdG9fZmxvYXQocG9zKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfcG9zX2luXG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX3Bvc19pbihjaGFuaWQpIHtyZXR1cm4gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdLm9mZnNldH1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9wb3NfaW5fNjRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfZmxvYXQsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfcG9zX2luXzY0KGNoYW5pZCkge3JldHVybiBjYW1sX2ludDY0X29mX2Zsb2F0KGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXS5vZmZzZXQpfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2lucHV0X3NjYW5fbGluZVxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9tbF9tYXlfcmVmaWxsX2lucHV0LCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX2lucHV0X3NjYW5fbGluZShjaGFuaWQpe1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgY2FtbF9tbF9tYXlfcmVmaWxsX2lucHV0KGNoYW5pZCk7XG4gIHZhciBwID0gY2hhbi5vZmZzZXQ7XG4gIHZhciBsZW4gPSBjaGFuLmZpbGUubGVuZ3RoKCk7XG4gIGlmKHAgPj0gbGVuKSB7IHJldHVybiAwO31cbiAgd2hpbGUodHJ1ZSkge1xuICAgIGlmKHAgPj0gbGVuKSByZXR1cm4gLSAocCAtIGNoYW4ub2Zmc2V0KTtcbiAgICBpZihjaGFuLmZpbGUucmVhZF9vbmUocCkgPT0gMTApIHJldHVybiBwIC0gY2hhbi5vZmZzZXQgKyAxO1xuICAgIHArKztcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2ZsdXNoXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3N5c19lcnJvciwgY2FtbF9nbG9iYWxfZGF0YSwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9mbHVzaCAoY2hhbmlkKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICBpZighIGNoYW4ub3BlbmVkKSBjYW1sX3JhaXNlX3N5c19lcnJvcihcIkNhbm5vdCBmbHVzaCBhIGNsb3NlZCBjaGFubmVsXCIpO1xuICBpZighY2hhbi5idWZmZXIgfHwgY2hhbi5idWZmZXIgPT0gXCJcIikgcmV0dXJuIDA7XG4gIGlmKGNoYW4uZmRcbiAgICAgJiYgY2FtbF9nbG9iYWxfZGF0YS5mZHNbY2hhbi5mZF1cbiAgICAgJiYgY2FtbF9nbG9iYWxfZGF0YS5mZHNbY2hhbi5mZF0ub3V0cHV0KSB7XG4gICAgdmFyIG91dHB1dCA9IGNhbWxfZ2xvYmFsX2RhdGEuZmRzW2NoYW4uZmRdLm91dHB1dDtcbiAgICBzd2l0Y2gob3V0cHV0Lmxlbmd0aCl7XG4gICAgY2FzZSAyOiBvdXRwdXQoY2hhbmlkLGNoYW4uYnVmZmVyKTticmVhaztcbiAgICBkZWZhdWx0OiBvdXRwdXQoY2hhbi5idWZmZXIpXG4gICAgfTtcbiAgfVxuICBjaGFuLmJ1ZmZlciA9IFwiXCI7XG4gIHJldHVybiAwO1xufVxuXG4vL291dHB1dCB0byBvdXRfY2hhbm5lbFxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX291dHB1dF9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9tbF9mbHVzaCxjYW1sX21sX2J5dGVzX2xlbmd0aFxuLy9SZXF1aXJlczogY2FtbF9jcmVhdGVfYnl0ZXMsIGNhbWxfYmxpdF9ieXRlcywgY2FtbF9yYWlzZV9zeXNfZXJyb3IsIGNhbWxfbWxfY2hhbm5lbHMsIGNhbWxfc3RyaW5nX29mX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX21sX291dHB1dF9ieXRlcyhjaGFuaWQsYnVmZmVyLG9mZnNldCxsZW4pIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIGlmKCEgY2hhbi5vcGVuZWQpIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKFwiQ2Fubm90IG91dHB1dCB0byBhIGNsb3NlZCBjaGFubmVsXCIpO1xuICB2YXIgYnl0ZXM7XG4gIGlmKG9mZnNldCA9PSAwICYmIGNhbWxfbWxfYnl0ZXNfbGVuZ3RoKGJ1ZmZlcikgPT0gbGVuKVxuICAgIGJ5dGVzID0gYnVmZmVyO1xuICBlbHNlIHtcbiAgICBieXRlcyA9IGNhbWxfY3JlYXRlX2J5dGVzKGxlbik7XG4gICAgY2FtbF9ibGl0X2J5dGVzKGJ1ZmZlcixvZmZzZXQsYnl0ZXMsMCxsZW4pO1xuICB9XG4gIHZhciBzdHJpbmcgPSBjYW1sX3N0cmluZ19vZl9ieXRlcyhieXRlcyk7XG4gIHZhciBqc3N0cmluZyA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcoc3RyaW5nKTtcbiAgdmFyIGlkID0ganNzdHJpbmcubGFzdEluZGV4T2YoXCJcXG5cIik7XG4gIGlmKGlkIDwgMClcbiAgICBjaGFuLmJ1ZmZlcis9anNzdHJpbmc7XG4gIGVsc2Uge1xuICAgIGNoYW4uYnVmZmVyKz1qc3N0cmluZy5zdWJzdHIoMCxpZCsxKTtcbiAgICBjYW1sX21sX2ZsdXNoIChjaGFuaWQpO1xuICAgIGNoYW4uYnVmZmVyICs9IGpzc3RyaW5nLnN1YnN0cihpZCsxKTtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9vdXRwdXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfb3V0cHV0X2J5dGVzLCBjYW1sX2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9tbF9vdXRwdXQoY2hhbmlkLGJ1ZmZlcixvZmZzZXQsbGVuKXtcbiAgcmV0dXJuIGNhbWxfbWxfb3V0cHV0X2J5dGVzKGNoYW5pZCxjYW1sX2J5dGVzX29mX3N0cmluZyhidWZmZXIpLG9mZnNldCxsZW4pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX291dHB1dF9jaGFyXG4vL1JlcXVpcmVzOiBjYW1sX21sX291dHB1dFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9tbF9vdXRwdXRfY2hhciAoY2hhbmlkLGMpIHtcbiAgdmFyIHMgPSBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKFN0cmluZy5mcm9tQ2hhckNvZGUoYykpO1xuICBjYW1sX21sX291dHB1dChjaGFuaWQscywwLDEpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vdXRwdXRfdmFsdWVcbi8vUmVxdWlyZXM6IGNhbWxfb3V0cHV0X3ZhbHVlX3RvX3N0cmluZywgY2FtbF9tbF9vdXRwdXQsY2FtbF9tbF9zdHJpbmdfbGVuZ3RoXG5mdW5jdGlvbiBjYW1sX291dHB1dF92YWx1ZSAoY2hhbmlkLHYsZmxhZ3MpIHtcbiAgdmFyIHMgPSBjYW1sX291dHB1dF92YWx1ZV90b19zdHJpbmcodiwgZmxhZ3MpO1xuICBjYW1sX21sX291dHB1dChjaGFuaWQscywwLGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSk7XG4gIHJldHVybiAwO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2Vla19vdXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbHMsIGNhbWxfbWxfZmx1c2hcbmZ1bmN0aW9uIGNhbWxfbWxfc2Vla19vdXQoY2hhbmlkLHBvcyl7XG4gIGNhbWxfbWxfZmx1c2goY2hhbmlkKTtcbiAgY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdLm9mZnNldCA9IHBvcztcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2Vla19vdXRfNjRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfdG9fZmxvYXQsIGNhbWxfbWxfY2hhbm5lbHMsIGNhbWxfbWxfZmx1c2hcbmZ1bmN0aW9uIGNhbWxfbWxfc2Vla19vdXRfNjQoY2hhbmlkLHBvcyl7XG4gIGNhbWxfbWxfZmx1c2goY2hhbmlkKTtcbiAgY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdLm9mZnNldCA9IGNhbWxfaW50NjRfdG9fZmxvYXQocG9zKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfcG9zX291dFxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVscywgY2FtbF9tbF9mbHVzaFxuZnVuY3Rpb24gY2FtbF9tbF9wb3Nfb3V0KGNoYW5pZCkge1xuICBjYW1sX21sX2ZsdXNoKGNoYW5pZCk7XG4gIHJldHVybiBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF0ub2Zmc2V0XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfcG9zX291dF82NFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZl9mbG9hdCwgY2FtbF9tbF9jaGFubmVscywgY2FtbF9tbF9mbHVzaFxuZnVuY3Rpb24gY2FtbF9tbF9wb3Nfb3V0XzY0KGNoYW5pZCkge1xuICBjYW1sX21sX2ZsdXNoKGNoYW5pZCk7XG4gIHJldHVybiBjYW1sX2ludDY0X29mX2Zsb2F0IChjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF0ub2Zmc2V0KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9vdXRwdXRfaW50XG4vL1JlcXVpcmVzOiBjYW1sX21sX291dHB1dFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfYXJyYXlcbmZ1bmN0aW9uIGNhbWxfbWxfb3V0cHV0X2ludCAoY2hhbmlkLGkpIHtcbiAgdmFyIGFyciA9IFsoaT4+MjQpICYgMHhGRiwoaT4+MTYpICYgMHhGRiwoaT4+OCkgJiAweEZGLGkgJiAweEZGIF07XG4gIHZhciBzID0gY2FtbF9zdHJpbmdfb2ZfYXJyYXkoYXJyKTtcbiAgY2FtbF9tbF9vdXRwdXQoY2hhbmlkLHMsMCw0KTtcbiAgcmV0dXJuIDBcbn1cbiIsIlxuXG4vL1Byb3ZpZGVzOiBjYW1sX2djX21pbm9yXG5mdW5jdGlvbiBjYW1sX2djX21pbm9yKCl7IHJldHVybiAwfVxuLy9Qcm92aWRlczogY2FtbF9nY19tYWpvclxuZnVuY3Rpb24gY2FtbF9nY19tYWpvcigpeyByZXR1cm4gMH1cbi8vUHJvdmlkZXM6IGNhbWxfZ2NfZnVsbF9tYWpvclxuZnVuY3Rpb24gY2FtbF9nY19mdWxsX21ham9yKCl7IHJldHVybiAwfVxuLy9Qcm92aWRlczogY2FtbF9nY19jb21wYWN0aW9uXG5mdW5jdGlvbiBjYW1sX2djX2NvbXBhY3Rpb24oKXsgcmV0dXJuIDB9XG4vL1Byb3ZpZGVzOiBjYW1sX2djX2NvdW50ZXJzXG5mdW5jdGlvbiBjYW1sX2djX2NvdW50ZXJzKCkgeyByZXR1cm4gWzI1NCwwLDAsMF0gfVxuLy9Qcm92aWRlczogY2FtbF9nY19xdWlja19zdGF0XG5mdW5jdGlvbiBjYW1sX2djX3F1aWNrX3N0YXQoKXtcbiAgcmV0dXJuIFswLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDBdXG59XG4vL1Byb3ZpZGVzOiBjYW1sX2djX3N0YXRcbmZ1bmN0aW9uIGNhbWxfZ2Nfc3RhdCgpIHtcbiAgcmV0dXJuIFswLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDBdXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2Nfc2V0XG5mdW5jdGlvbiBjYW1sX2djX3NldChfY29udHJvbCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9nY19nZXRcbmZ1bmN0aW9uIGNhbWxfZ2NfZ2V0KCl7XG4gIHJldHVybiBbMCwwLDAsMCwwLDAsMCwwLDBdXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWVtcHJvZl9zZXRcbmZ1bmN0aW9uIGNhbWxfbWVtcHJvZl9zZXQoX2NvbnRyb2wpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmluYWxfcmVnaXN0ZXIgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZmluYWxfcmVnaXN0ZXIgKCkgeyByZXR1cm4gMDsgfVxuLy9Qcm92aWRlczogY2FtbF9maW5hbF9yZWdpc3Rlcl9jYWxsZWRfd2l0aG91dF92YWx1ZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9maW5hbF9yZWdpc3Rlcl9jYWxsZWRfd2l0aG91dF92YWx1ZSAoKSB7IHJldHVybiAwOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2ZpbmFsX3JlbGVhc2UgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZmluYWxfcmVsZWFzZSAoKSB7IHJldHVybiAwOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWVtcHJvZl9zdGFydFxuZnVuY3Rpb24gY2FtbF9tZW1wcm9mX3N0YXJ0KHJhdGUsc3RhY2tfc2l6ZSx0cmFja2VyKXtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWVtcHJvZl9zdG9wXG5mdW5jdGlvbiBjYW1sX21lbXByb2Zfc3RvcCh1bml0KSB7XG4gIHJldHVybiAwO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDE0IErDqXLDtG1lIFZvdWlsbG9uLCBIdWdvIEhldXphcmQsIEFuZHkgUmF5XG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG4vL1xuLy8gQmlnYXJyYXkuXG4vL1xuLy8gLSBhbGwgYmlnYXJyYXkgdHlwZXMgaW5jbHVkaW5nIEludDY0IGFuZCBDb21wbGV4LlxuLy8gLSBmb3J0cmFuICsgYyBsYXlvdXRzXG4vLyAtIHN1Yi9zbGljZS9yZXNoYXBlXG4vLyAtIHJldGFpbiBmYXN0IHBhdGggZm9yIDFkIGFycmF5IGFjY2Vzc1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2luaXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfYmFfaW5pdCgpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZ2V0X3NpemVcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9iYV9nZXRfc2l6ZShkaW1zKSB7XG4gIHZhciBuX2RpbXMgPSBkaW1zLmxlbmd0aDtcbiAgdmFyIHNpemUgPSAxO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG5fZGltczsgaSsrKSB7XG4gICAgaWYgKGRpbXNbaV0gPCAwKVxuICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkuY3JlYXRlOiBuZWdhdGl2ZSBkaW1lbnNpb25cIik7XG4gICAgc2l6ZSA9IHNpemUgKiBkaW1zW2ldO1xuICB9XG4gIHJldHVybiBzaXplO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50XG5mdW5jdGlvbiBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50KGtpbmQpe1xuICBzd2l0Y2goa2luZCl7XG4gIGNhc2UgNzogY2FzZSAxMDogY2FzZSAxMTogcmV0dXJuIDI7XG4gIGRlZmF1bHQ6IHJldHVybiAxO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfY3JlYXRlX2J1ZmZlclxuLy9SZXF1aXJlczogY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudFxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX2JhX2NyZWF0ZV9idWZmZXIoa2luZCwgc2l6ZSl7XG4gIHZhciBnID0gam9vX2dsb2JhbF9vYmplY3Q7XG4gIHZhciB2aWV3O1xuICBzd2l0Y2goa2luZCl7XG4gIGNhc2UgMDogIHZpZXcgPSBnLkZsb2F0MzJBcnJheTsgYnJlYWs7XG4gIGNhc2UgMTogIHZpZXcgPSBnLkZsb2F0NjRBcnJheTsgYnJlYWs7XG4gIGNhc2UgMjogIHZpZXcgPSBnLkludDhBcnJheTsgYnJlYWs7XG4gIGNhc2UgMzogIHZpZXcgPSBnLlVpbnQ4QXJyYXk7IGJyZWFrO1xuICBjYXNlIDQ6ICB2aWV3ID0gZy5JbnQxNkFycmF5OyBicmVhaztcbiAgY2FzZSA1OiAgdmlldyA9IGcuVWludDE2QXJyYXk7IGJyZWFrO1xuICBjYXNlIDY6ICB2aWV3ID0gZy5JbnQzMkFycmF5OyBicmVhaztcbiAgY2FzZSA3OiAgdmlldyA9IGcuSW50MzJBcnJheTsgYnJlYWs7XG4gIGNhc2UgODogIHZpZXcgPSBnLkludDMyQXJyYXk7IGJyZWFrO1xuICBjYXNlIDk6ICB2aWV3ID0gZy5JbnQzMkFycmF5OyBicmVhaztcbiAgY2FzZSAxMDogdmlldyA9IGcuRmxvYXQzMkFycmF5OyBicmVhaztcbiAgY2FzZSAxMTogdmlldyA9IGcuRmxvYXQ2NEFycmF5OyBicmVhaztcbiAgY2FzZSAxMjogdmlldyA9IGcuVWludDhBcnJheTsgYnJlYWs7XG4gIH1cbiAgaWYgKCF2aWV3KSBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5jcmVhdGU6IHVuc3VwcG9ydGVkIGtpbmRcIik7XG4gIHZhciBkYXRhID0gbmV3IHZpZXcoc2l6ZSAqIGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnQoa2luZCkpO1xuICByZXR1cm4gZGF0YTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9jdXN0b21fbmFtZVxuLy9WZXJzaW9uOiA8IDQuMTFcbnZhciBjYW1sX2JhX2N1c3RvbV9uYW1lID0gXCJfYmlnYXJyYXlcIlxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2N1c3RvbV9uYW1lXG4vL1ZlcnNpb246ID49IDQuMTFcbnZhciBjYW1sX2JhX2N1c3RvbV9uYW1lID0gXCJfYmlnYXJyMDJcIlxuXG4vL1Byb3ZpZGVzOiBNbF9CaWdhcnJheVxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvciwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2JhX2N1c3RvbV9uYW1lXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2NyZWF0ZV9sb19oaSwgY2FtbF9pbnQ2NF9oaTMyLCBjYW1sX2ludDY0X2xvMzJcbmZ1bmN0aW9uIE1sX0JpZ2FycmF5IChraW5kLCBsYXlvdXQsIGRpbXMsIGJ1ZmZlcikge1xuXG4gIHRoaXMua2luZCAgID0ga2luZCA7XG4gIHRoaXMubGF5b3V0ID0gbGF5b3V0O1xuICB0aGlzLmRpbXMgICA9IGRpbXM7XG4gIHRoaXMuZGF0YSA9IGJ1ZmZlcjtcbn1cblxuTWxfQmlnYXJyYXkucHJvdG90eXBlLmNhbWxfY3VzdG9tID0gY2FtbF9iYV9jdXN0b21fbmFtZTtcblxuTWxfQmlnYXJyYXkucHJvdG90eXBlLm9mZnNldCA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgdmFyIG9mcyA9IDA7XG4gIGlmKHR5cGVvZiBhcmcgPT09IFwibnVtYmVyXCIpIGFyZyA9IFthcmddO1xuICBpZiAoISAoYXJnIGluc3RhbmNlb2YgQXJyYXkpKSBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJiaWdhcnJheS5qczogaW52YWxpZCBvZmZzZXRcIik7XG4gIGlmICh0aGlzLmRpbXMubGVuZ3RoICE9IGFyZy5sZW5ndGgpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkuZ2V0L3NldDogYmFkIG51bWJlciBvZiBkaW1lbnNpb25zXCIpO1xuICBpZih0aGlzLmxheW91dCA9PSAwIC8qIGNfbGF5b3V0ICovKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRpbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhcmdbaV0gPCAwIHx8IGFyZ1tpXSA+PSB0aGlzLmRpbXNbaV0pXG4gICAgICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgICAgIG9mcyA9IChvZnMgKiB0aGlzLmRpbXNbaV0pICsgYXJnW2ldO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5kaW1zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBpZiAoYXJnW2ldIDwgMSB8fCBhcmdbaV0gPiB0aGlzLmRpbXNbaV0pe1xuICAgICAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gICAgICB9XG4gICAgICBvZnMgPSAob2ZzICogdGhpcy5kaW1zW2ldKSArIChhcmdbaV0gLSAxKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9mcztcbn1cblxuTWxfQmlnYXJyYXkucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChvZnMpIHtcbiAgc3dpdGNoKHRoaXMua2luZCl7XG4gIGNhc2UgNzpcbiAgICAvLyBJbnQ2NFxuICAgIHZhciBsID0gdGhpcy5kYXRhW29mcyAqIDIgKyAwXTtcbiAgICB2YXIgaCA9IHRoaXMuZGF0YVtvZnMgKiAyICsgMV07XG4gICAgcmV0dXJuIGNhbWxfaW50NjRfY3JlYXRlX2xvX2hpKGwsaCk7XG4gIGNhc2UgMTA6IGNhc2UgMTE6XG4gICAgLy8gQ29tcGxleDMyLCBDb21wbGV4NjRcbiAgICB2YXIgciA9IHRoaXMuZGF0YVtvZnMgKiAyICsgMF07XG4gICAgdmFyIGkgPSB0aGlzLmRhdGFbb2ZzICogMiArIDFdO1xuICAgIHJldHVybiBbMjU0LCByLCBpXTtcbiAgZGVmYXVsdDpcbiAgICByZXR1cm4gdGhpcy5kYXRhW29mc11cbiAgfVxufVxuXG5NbF9CaWdhcnJheS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKG9mcyx2KSB7XG4gIHN3aXRjaCh0aGlzLmtpbmQpe1xuICBjYXNlIDc6XG4gICAgLy8gSW50NjRcbiAgICB0aGlzLmRhdGFbb2ZzICogMiArIDBdID0gY2FtbF9pbnQ2NF9sbzMyKHYpO1xuICAgIHRoaXMuZGF0YVtvZnMgKiAyICsgMV0gPSBjYW1sX2ludDY0X2hpMzIodik7XG4gICAgYnJlYWs7XG4gIGNhc2UgMTA6IGNhc2UgMTE6XG4gICAgLy8gQ29tcGxleDMyLCBDb21wbGV4NjRcbiAgICB0aGlzLmRhdGFbb2ZzICogMiArIDBdID0gdlsxXTtcbiAgICB0aGlzLmRhdGFbb2ZzICogMiArIDFdID0gdlsyXTtcbiAgICBicmVhaztcbiAgZGVmYXVsdDpcbiAgICB0aGlzLmRhdGFbb2ZzXSA9IHY7XG4gICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIDBcbn1cblxuXG5NbF9CaWdhcnJheS5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uICh2KSB7XG4gIHN3aXRjaCh0aGlzLmtpbmQpe1xuICBjYXNlIDc6XG4gICAgLy8gSW50NjRcbiAgICB2YXIgYSA9IGNhbWxfaW50NjRfbG8zMih2KTtcbiAgICB2YXIgYiA9IGNhbWxfaW50NjRfaGkzMih2KTtcbiAgICBpZihhID09IGIpe1xuICAgICAgdGhpcy5kYXRhLmZpbGwoYSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZm9yKHZhciBpID0gMDsgaTx0aGlzLmRhdGEubGVuZ3RoOyBpKyspe1xuICAgICAgICB0aGlzLmRhdGFbaV0gPSAoaSUyID09IDApID8gYSA6IGI7XG4gICAgICB9XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDEwOiBjYXNlIDExOlxuICAgIC8vIENvbXBsZXgzMiwgQ29tcGxleDY0XG4gICAgdmFyIGltID0gdlsxXTtcbiAgICB2YXIgcmUgPSB2WzJdO1xuICAgIGlmKGltID09IHJlKXtcbiAgICAgIHRoaXMuZGF0YS5maWxsKGltKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBmb3IodmFyIGkgPSAwOyBpPHRoaXMuZGF0YS5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHRoaXMuZGF0YVtpXSA9IChpJTIgPT0gMCkgPyBpbSA6IHJlO1xuICAgICAgfVxuICAgIH1cbiAgICBicmVhaztcbiAgZGVmYXVsdDpcbiAgICB0aGlzLmRhdGEuZmlsbCh2KTtcbiAgICBicmVhaztcbiAgfVxufVxuXG5cbk1sX0JpZ2FycmF5LnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gKGIsIHRvdGFsKSB7XG4gIGlmICh0aGlzLmxheW91dCAhPSBiLmxheW91dCB8fCB0aGlzLmtpbmQgIT0gYi5raW5kKSB7XG4gICAgdmFyIGsxID0gdGhpcy5raW5kIHwgKHRoaXMubGF5b3V0IDw8IDgpO1xuICAgIHZhciBrMiA9ICAgIGIua2luZCB8IChiLmxheW91dCA8PCA4KTtcbiAgICByZXR1cm4gazIgLSBrMTtcbiAgfVxuICBpZiAodGhpcy5kaW1zLmxlbmd0aCAhPSBiLmRpbXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGIuZGltcy5sZW5ndGggLSB0aGlzLmRpbXMubGVuZ3RoO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kaW1zLmxlbmd0aDsgaSsrKVxuICAgIGlmICh0aGlzLmRpbXNbaV0gIT0gYi5kaW1zW2ldKVxuICAgICAgcmV0dXJuICh0aGlzLmRpbXNbaV0gPCBiLmRpbXNbaV0pID8gLTEgOiAxO1xuICBzd2l0Y2ggKHRoaXMua2luZCkge1xuICBjYXNlIDA6XG4gIGNhc2UgMTpcbiAgY2FzZSAxMDpcbiAgY2FzZSAxMTpcbiAgICAvLyBGbG9hdHNcbiAgICB2YXIgeCwgeTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgeCA9IHRoaXMuZGF0YVtpXTtcbiAgICAgIHkgPSBiLmRhdGFbaV07XG4gICAgICBpZiAoeCA8IHkpXG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIGlmICh4ID4geSlcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICBpZiAoeCAhPSB5KSB7XG4gICAgICAgIGlmICghdG90YWwpIHJldHVybiBOYU47XG4gICAgICAgIGlmICh4ID09IHgpIHJldHVybiAxO1xuICAgICAgICBpZiAoeSA9PSB5KSByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDc6XG4gICAgLy8gSW50NjRcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7IGkrPTIpIHtcbiAgICAgIC8vIENoZWNrIGhpZ2hlc3QgYml0cyBmaXJzdFxuICAgICAgaWYgKHRoaXMuZGF0YVtpKzFdIDwgYi5kYXRhW2krMV0pXG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIGlmICh0aGlzLmRhdGFbaSsxXSA+IGIuZGF0YVtpKzFdKVxuICAgICAgICByZXR1cm4gMTtcbiAgICAgIGlmICgodGhpcy5kYXRhW2ldID4+PiAwKSA8IChiLmRhdGFbaV0gPj4+IDApKVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgICBpZiAoKHRoaXMuZGF0YVtpXSA+Pj4gMCkgPiAoYi5kYXRhW2ldID4+PiAwKSlcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDI6XG4gIGNhc2UgMzpcbiAgY2FzZSA0OlxuICBjYXNlIDU6XG4gIGNhc2UgNjpcbiAgY2FzZSA4OlxuICBjYXNlIDk6XG4gIGNhc2UgMTI6XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLmRhdGFbaV0gPCBiLmRhdGFbaV0pXG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIGlmICh0aGlzLmRhdGFbaV0gPiBiLmRhdGFbaV0pXG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBicmVhaztcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogTWxfQmlnYXJyYXlfY18xXzFcbi8vUmVxdWlyZXM6IE1sX0JpZ2FycmF5LCBjYW1sX2FycmF5X2JvdW5kX2Vycm9yLCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIE1sX0JpZ2FycmF5X2NfMV8xKGtpbmQsIGxheW91dCwgZGltcywgYnVmZmVyKSB7XG4gIHRoaXMua2luZCAgID0ga2luZCA7XG4gIHRoaXMubGF5b3V0ID0gbGF5b3V0O1xuICB0aGlzLmRpbXMgICA9IGRpbXM7XG4gIHRoaXMuZGF0YSAgID0gYnVmZmVyO1xufVxuXG5NbF9CaWdhcnJheV9jXzFfMS5wcm90b3R5cGUgPSBuZXcgTWxfQmlnYXJyYXkoKVxuTWxfQmlnYXJyYXlfY18xXzEucHJvdG90eXBlLm9mZnNldCA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgaWYodHlwZW9mIGFyZyAhPT0gXCJudW1iZXJcIil7XG4gICAgaWYoKGFyZyBpbnN0YW5jZW9mIEFycmF5KSAmJiBhcmcubGVuZ3RoID09IDEpXG4gICAgICBhcmcgPSBhcmdbMF07XG4gICAgZWxzZSBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJNbF9CaWdhcnJheV9jXzFfMS5vZmZzZXRcIik7XG4gIH1cbiAgaWYgKGFyZyA8IDAgfHwgYXJnID49IHRoaXMuZGltc1swXSlcbiAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHJldHVybiBhcmc7XG59XG5cbk1sX0JpZ2FycmF5X2NfMV8xLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAob2ZzKSB7XG4gIHJldHVybiB0aGlzLmRhdGFbb2ZzXTtcbn1cblxuTWxfQmlnYXJyYXlfY18xXzEucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChvZnMsdikge1xuICB0aGlzLmRhdGFbb2ZzXSA9IHY7XG4gIHJldHVybiAwXG59XG5cbk1sX0JpZ2FycmF5X2NfMV8xLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gKHYpIHtcbiAgdGhpcy5kYXRhLmZpbGwodik7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfY29tcGFyZVxuZnVuY3Rpb24gY2FtbF9iYV9jb21wYXJlKGEsYix0b3RhbCl7XG4gIHJldHVybiBhLmNvbXBhcmUoYix0b3RhbClcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9jcmVhdGVfdW5zYWZlXG4vL1JlcXVpcmVzOiBNbF9CaWdhcnJheSwgTWxfQmlnYXJyYXlfY18xXzEsIGNhbWxfYmFfZ2V0X3NpemUsIGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnRcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGtpbmQsIGxheW91dCwgZGltcywgZGF0YSl7XG4gIHZhciBzaXplX3Blcl9lbGVtZW50ID0gY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudChraW5kKTtcbiAgaWYoY2FtbF9iYV9nZXRfc2l6ZShkaW1zKSAqIHNpemVfcGVyX2VsZW1lbnQgIT0gZGF0YS5sZW5ndGgpIHtcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJsZW5ndGggZG9lc24ndCBtYXRjaCBkaW1zXCIpO1xuICB9XG4gIGlmKGxheW91dCA9PSAwICYmIC8vIGNfbGF5b3V0XG4gICAgIGRpbXMubGVuZ3RoID09IDEgJiYgLy8gQXJyYXkxXG4gICAgIHNpemVfcGVyX2VsZW1lbnQgPT0gMSkgLy8gMS10by0xIG1hcHBpbmdcbiAgICByZXR1cm4gbmV3IE1sX0JpZ2FycmF5X2NfMV8xKGtpbmQsIGxheW91dCwgZGltcywgZGF0YSk7XG4gIHJldHVybiBuZXcgTWxfQmlnYXJyYXkoa2luZCwgbGF5b3V0LCBkaW1zLCBkYXRhKTtcblxufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfY3JlYXRlXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZ2V0X3NpemUsIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZVxuLy9SZXF1aXJlczogY2FtbF9iYV9jcmVhdGVfYnVmZmVyXG5mdW5jdGlvbiBjYW1sX2JhX2NyZWF0ZShraW5kLCBsYXlvdXQsIGRpbXNfbWwpIHtcbiAgdmFyIGRpbXMgPSBjYW1sX2pzX2Zyb21fYXJyYXkoZGltc19tbCk7XG4gIHZhciBkYXRhID0gY2FtbF9iYV9jcmVhdGVfYnVmZmVyKGtpbmQsIGNhbWxfYmFfZ2V0X3NpemUoZGltcykpO1xuICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGtpbmQsIGxheW91dCwgZGltcywgZGF0YSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfY2hhbmdlX2xheW91dFxuLy9SZXF1aXJlczogY2FtbF9iYV9jcmVhdGVfdW5zYWZlXG5mdW5jdGlvbiBjYW1sX2JhX2NoYW5nZV9sYXlvdXQoYmEsIGxheW91dCkge1xuICBpZihiYS5sYXlvdXQgPT0gbGF5b3V0KSByZXR1cm4gYmE7XG4gIHZhciBuZXdfZGltcyA9IFtdXG4gIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kaW1zLmxlbmd0aDsgaSsrKSBuZXdfZGltc1tpXSA9IGJhLmRpbXNbYmEuZGltcy5sZW5ndGggLSBpIC0gMV07XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoYmEua2luZCwgbGF5b3V0LCBuZXdfZGltcywgYmEuZGF0YSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfa2luZFxuZnVuY3Rpb24gY2FtbF9iYV9raW5kKGJhKSB7XG4gIHJldHVybiBiYS5raW5kO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2xheW91dFxuZnVuY3Rpb24gY2FtbF9iYV9sYXlvdXQoYmEpIHtcbiAgcmV0dXJuIGJhLmxheW91dDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9udW1fZGltc1xuZnVuY3Rpb24gY2FtbF9iYV9udW1fZGltcyhiYSkge1xuICByZXR1cm4gYmEuZGltcy5sZW5ndGg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZGltXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfYmFfZGltKGJhLCBpKSB7XG4gIGlmIChpIDwgMCB8fCBpID49IGJhLmRpbXMubGVuZ3RoKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LmRpbVwiKTtcbiAgcmV0dXJuIGJhLmRpbXNbaV07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZGltXzFcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZGltXG5mdW5jdGlvbiBjYW1sX2JhX2RpbV8xKGJhKSB7XG4gIHJldHVybiBjYW1sX2JhX2RpbShiYSwgMCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZGltXzJcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZGltXG5mdW5jdGlvbiBjYW1sX2JhX2RpbV8yKGJhKSB7XG4gIHJldHVybiBjYW1sX2JhX2RpbShiYSwgMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZGltXzNcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZGltXG5mdW5jdGlvbiBjYW1sX2JhX2RpbV8zKGJhKSB7XG4gIHJldHVybiBjYW1sX2JhX2RpbShiYSwgMik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZ2V0X2dlbmVyaWNcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheVxuZnVuY3Rpb24gY2FtbF9iYV9nZXRfZ2VuZXJpYyhiYSwgaSkge1xuICB2YXIgb2ZzID0gYmEub2Zmc2V0KGNhbWxfanNfZnJvbV9hcnJheShpKSk7XG4gIHJldHVybiBiYS5nZXQob2ZzKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV91aW50OF9nZXQxNlxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9iYV91aW50OF9nZXQxNihiYSwgaTApIHtcbiAgdmFyIG9mcyA9IGJhLm9mZnNldChpMCk7XG4gIGlmKG9mcyArIDEgPj0gYmEuZGF0YS5sZW5ndGgpIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGIxID0gYmEuZ2V0KG9mcyk7XG4gIHZhciBiMiA9IGJhLmdldChvZnMgKyAxKTtcbiAgcmV0dXJuIChiMSB8IChiMiA8PCA4KSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfdWludDhfZ2V0MzJcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfYmFfdWludDhfZ2V0MzIoYmEsIGkwKSB7XG4gIHZhciBvZnMgPSBiYS5vZmZzZXQoaTApO1xuICBpZihvZnMgKyAzID49IGJhLmRhdGEubGVuZ3RoKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHZhciBiMSA9IGJhLmdldChvZnMrMCk7XG4gIHZhciBiMiA9IGJhLmdldChvZnMrMSk7XG4gIHZhciBiMyA9IGJhLmdldChvZnMrMik7XG4gIHZhciBiNCA9IGJhLmdldChvZnMrMyk7XG4gIHJldHVybiAoIChiMSA8PCAwKSAgfFxuICAgICAgICAgICAoYjIgPDwgOCkgIHxcbiAgICAgICAgICAgKGIzIDw8IDE2KSB8XG4gICAgICAgICAgIChiNCA8PCAyNCkgKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV91aW50OF9nZXQ2NFxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvciwgY2FtbF9pbnQ2NF9vZl9ieXRlc1xuZnVuY3Rpb24gY2FtbF9iYV91aW50OF9nZXQ2NChiYSwgaTApIHtcbiAgdmFyIG9mcyA9IGJhLm9mZnNldChpMCk7XG4gIGlmKG9mcyArIDcgPj0gYmEuZGF0YS5sZW5ndGgpIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGIxID0gYmEuZ2V0KG9mcyswKTtcbiAgdmFyIGIyID0gYmEuZ2V0KG9mcysxKTtcbiAgdmFyIGIzID0gYmEuZ2V0KG9mcysyKTtcbiAgdmFyIGI0ID0gYmEuZ2V0KG9mcyszKTtcbiAgdmFyIGI1ID0gYmEuZ2V0KG9mcys0KTtcbiAgdmFyIGI2ID0gYmEuZ2V0KG9mcys1KTtcbiAgdmFyIGI3ID0gYmEuZ2V0KG9mcys2KTtcbiAgdmFyIGI4ID0gYmEuZ2V0KG9mcys3KTtcbiAgcmV0dXJuIGNhbWxfaW50NjRfb2ZfYnl0ZXMoW2I4LGI3LGI2LGI1LGI0LGIzLGIyLGIxXSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZ2V0XzFcbmZ1bmN0aW9uIGNhbWxfYmFfZ2V0XzEoYmEsIGkwKSB7XG4gIHJldHVybiBiYS5nZXQoYmEub2Zmc2V0KGkwKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZ2V0XzJcbmZ1bmN0aW9uIGNhbWxfYmFfZ2V0XzIoYmEsIGkwLCBpMSkge1xuICByZXR1cm4gYmEuZ2V0KGJhLm9mZnNldChbaTAsaTFdKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZ2V0XzNcbmZ1bmN0aW9uIGNhbWxfYmFfZ2V0XzMoYmEsIGkwLCBpMSwgaTIpIHtcbiAgcmV0dXJuIGJhLmdldChiYS5vZmZzZXQoW2kwLGkxLGkyXSkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3NldF9nZW5lcmljXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfYmFfc2V0X2dlbmVyaWMoYmEsIGksIHYpIHtcbiAgYmEuc2V0KGJhLm9mZnNldChjYW1sX2pzX2Zyb21fYXJyYXkoaSkpLCB2KTtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV91aW50OF9zZXQxNlxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9iYV91aW50OF9zZXQxNihiYSwgaTAsIHYpIHtcbiAgdmFyIG9mcyA9IGJhLm9mZnNldChpMCk7XG4gIGlmKG9mcyArIDEgPj0gYmEuZGF0YS5sZW5ndGgpIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgYmEuc2V0KG9mcyswLCAgdiAgICAgICAgJiAweGZmKTtcbiAgYmEuc2V0KG9mcysxLCAodiA+Pj4gOCkgJiAweGZmKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfdWludDhfc2V0MzJcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfYmFfdWludDhfc2V0MzIoYmEsIGkwLCB2KSB7XG4gIHZhciBvZnMgPSBiYS5vZmZzZXQoaTApO1xuICBpZihvZnMgKyAzID49IGJhLmRhdGEubGVuZ3RoKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIGJhLnNldChvZnMrMCwgIHYgICAgICAgICAmIDB4ZmYpO1xuICBiYS5zZXQob2ZzKzEsICh2ID4+PiA4KSAgJiAweGZmKTtcbiAgYmEuc2V0KG9mcysyLCAodiA+Pj4gMTYpICYgMHhmZik7XG4gIGJhLnNldChvZnMrMywgKHYgPj4+IDI0KSAmIDB4ZmYpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV91aW50OF9zZXQ2NFxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvciwgY2FtbF9pbnQ2NF90b19ieXRlc1xuZnVuY3Rpb24gY2FtbF9iYV91aW50OF9zZXQ2NChiYSwgaTAsIHYpIHtcbiAgdmFyIG9mcyA9IGJhLm9mZnNldChpMCk7XG4gIGlmKG9mcyArIDcgPj0gYmEuZGF0YS5sZW5ndGgpIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgdmFyIHYgPSBjYW1sX2ludDY0X3RvX2J5dGVzKHYpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgODsgaSsrKSBiYS5zZXQob2ZzK2ksIHZbNy1pXSlcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfc2V0XzFcbmZ1bmN0aW9uIGNhbWxfYmFfc2V0XzEoYmEsIGkwLCB2KSB7XG4gIGJhLnNldChiYS5vZmZzZXQoaTApLCB2KTtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9zZXRfMlxuZnVuY3Rpb24gY2FtbF9iYV9zZXRfMihiYSwgaTAsIGkxLCB2KSB7XG4gIGJhLnNldChiYS5vZmZzZXQoW2kwLGkxXSksIHYpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9zZXRfM1xuZnVuY3Rpb24gY2FtbF9iYV9zZXRfMyhiYSwgaTAsIGkxLCBpMiwgdikge1xuICBiYS5zZXQoYmEub2Zmc2V0KFtpMCxpMSxpMl0pLCB2KTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZmlsbFxuZnVuY3Rpb24gY2FtbF9iYV9maWxsKGJhLCB2KSB7XG4gIGJhLmZpbGwodik7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2JsaXRcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9iYV9ibGl0KHNyYywgZHN0KSB7XG4gIGlmIChkc3QuZGltcy5sZW5ndGggIT0gc3JjLmRpbXMubGVuZ3RoKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LmJsaXQ6IGRpbWVuc2lvbiBtaXNtYXRjaFwiKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkc3QuZGltcy5sZW5ndGg7IGkrKylcbiAgICBpZiAoZHN0LmRpbXNbaV0gIT0gc3JjLmRpbXNbaV0pXG4gICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5ibGl0OiBkaW1lbnNpb24gbWlzbWF0Y2hcIik7XG4gIGRzdC5kYXRhLnNldChzcmMuZGF0YSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3N1YlxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2JhX2NyZWF0ZV91bnNhZmUsIGNhbWxfYmFfZ2V0X3NpemVcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnRcbmZ1bmN0aW9uIGNhbWxfYmFfc3ViKGJhLCBvZnMsIGxlbikge1xuICB2YXIgY2hhbmdlZF9kaW07XG4gIHZhciBtdWwgPSAxO1xuICBpZiAoYmEubGF5b3V0ID09IDApIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGJhLmRpbXMubGVuZ3RoOyBpKyspXG4gICAgICBtdWwgPSBtdWwgKiBiYS5kaW1zW2ldO1xuICAgIGNoYW5nZWRfZGltID0gMDtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IChiYS5kaW1zLmxlbmd0aCAtIDEpOyBpKyspXG4gICAgICBtdWwgPSBtdWwgKiBiYS5kaW1zW2ldO1xuICAgIGNoYW5nZWRfZGltID0gYmEuZGltcy5sZW5ndGggLSAxO1xuICAgIG9mcyA9IG9mcyAtIDE7XG4gIH1cbiAgaWYgKG9mcyA8IDAgfHwgbGVuIDwgMCB8fCAob2ZzICsgbGVuKSA+IGJhLmRpbXNbY2hhbmdlZF9kaW1dKXtcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5zdWI6IGJhZCBzdWItYXJyYXlcIik7XG4gIH1cbiAgdmFyIG5ld19kaW1zID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYmEuZGltcy5sZW5ndGg7IGkrKylcbiAgICBuZXdfZGltc1tpXSA9IGJhLmRpbXNbaV07XG4gIG5ld19kaW1zW2NoYW5nZWRfZGltXSA9IGxlbjtcbiAgbXVsICo9IGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnQoYmEua2luZCk7XG4gIHZhciBuZXdfZGF0YSA9IGJhLmRhdGEuc3ViYXJyYXkob2ZzICogbXVsLCAob2ZzICsgbGVuKSAqIG11bCk7XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoYmEua2luZCwgYmEubGF5b3V0LCBuZXdfZGltcywgbmV3X2RhdGEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3NsaWNlXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXksIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZSwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2JhX2dldF9zaXplXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50XG5mdW5jdGlvbiBjYW1sX2JhX3NsaWNlKGJhLCB2aW5kKSB7XG4gIHZpbmQgPSBjYW1sX2pzX2Zyb21fYXJyYXkodmluZCk7XG4gIHZhciBudW1faW5kcyA9IHZpbmQubGVuZ3RoO1xuICB2YXIgaW5kZXggPSBbXTtcbiAgdmFyIHN1Yl9kaW1zID0gW107XG4gIHZhciBvZnM7XG5cbiAgaWYgKG51bV9pbmRzID4gYmEuZGltcy5sZW5ndGgpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkuc2xpY2U6IHRvbyBtYW55IGluZGljZXNcIik7XG5cbiAgLy8gQ29tcHV0ZSBvZmZzZXQgYW5kIGNoZWNrIGJvdW5kc1xuICBpZiAoYmEubGF5b3V0ID09IDApIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9pbmRzOyBpKyspXG4gICAgICBpbmRleFtpXSA9IHZpbmRbaV07XG4gICAgZm9yICg7IGkgPCBiYS5kaW1zLmxlbmd0aDsgaSsrKVxuICAgICAgaW5kZXhbaV0gPSAwO1xuICAgIHN1Yl9kaW1zID0gYmEuZGltcy5zbGljZShudW1faW5kcyk7XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1faW5kczsgaSsrKVxuICAgICAgaW5kZXhbYmEuZGltcy5sZW5ndGggLSBudW1faW5kcyArIGldID0gdmluZFtpXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJhLmRpbXMubGVuZ3RoIC0gbnVtX2luZHM7IGkrKylcbiAgICAgIGluZGV4W2ldID0gMTtcbiAgICBzdWJfZGltcyA9IGJhLmRpbXMuc2xpY2UoMCwgYmEuZGltcy5sZW5ndGggLSBudW1faW5kcyk7XG4gIH1cbiAgb2ZzID0gYmEub2Zmc2V0KGluZGV4KTtcbiAgdmFyIHNpemUgPSBjYW1sX2JhX2dldF9zaXplKHN1Yl9kaW1zKTtcbiAgdmFyIHNpemVfcGVyX2VsZW1lbnQgPSBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50KGJhLmtpbmQpO1xuICB2YXIgbmV3X2RhdGEgPSBiYS5kYXRhLnN1YmFycmF5KG9mcyAqIHNpemVfcGVyX2VsZW1lbnQsIChvZnMgKyBzaXplKSAqIHNpemVfcGVyX2VsZW1lbnQpO1xuICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGJhLmtpbmQsIGJhLmxheW91dCwgc3ViX2RpbXMsIG5ld19kYXRhKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9yZXNoYXBlXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXksIGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9iYV9jcmVhdGVfdW5zYWZlLCBjYW1sX2JhX2dldF9zaXplXG5mdW5jdGlvbiBjYW1sX2JhX3Jlc2hhcGUoYmEsIHZpbmQpIHtcbiAgdmluZCA9IGNhbWxfanNfZnJvbV9hcnJheSh2aW5kKTtcbiAgdmFyIG5ld19kaW0gPSBbXTtcbiAgdmFyIG51bV9kaW1zID0gdmluZC5sZW5ndGg7XG5cbiAgaWYgKG51bV9kaW1zIDwgMCB8fCBudW1fZGltcyA+IDE2KXtcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5yZXNoYXBlOiBiYWQgbnVtYmVyIG9mIGRpbWVuc2lvbnNcIik7XG4gIH1cbiAgdmFyIG51bV9lbHRzID0gMTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1fZGltczsgaSsrKSB7XG4gICAgbmV3X2RpbVtpXSA9IHZpbmRbaV07XG4gICAgaWYgKG5ld19kaW1baV0gPCAwKVxuICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkucmVzaGFwZTogbmVnYXRpdmUgZGltZW5zaW9uXCIpO1xuICAgIG51bV9lbHRzID0gbnVtX2VsdHMgKiBuZXdfZGltW2ldO1xuICB9XG5cbiAgdmFyIHNpemUgPSBjYW1sX2JhX2dldF9zaXplKGJhLmRpbXMpO1xuICAvLyBDaGVjayB0aGF0IHNpemVzIGFncmVlXG4gIGlmIChudW1fZWx0cyAhPSBzaXplKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LnJlc2hhcGU6IHNpemUgbWlzbWF0Y2hcIik7XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoYmEua2luZCwgYmEubGF5b3V0LCBuZXdfZGltLCBiYS5kYXRhKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9zZXJpYWxpemVcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCwgY2FtbF9pbnQ2NF90b19ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9pbnQzMl9iaXRzX29mX2Zsb2F0XG5mdW5jdGlvbiBjYW1sX2JhX3NlcmlhbGl6ZSh3cml0ZXIsIGJhLCBzeikge1xuICB3cml0ZXIud3JpdGUoMzIsIGJhLmRpbXMubGVuZ3RoKTtcbiAgd3JpdGVyLndyaXRlKDMyLCAoYmEua2luZCB8IChiYS5sYXlvdXQgPDwgOCkpKTtcbiAgaWYoYmEuY2FtbF9jdXN0b20gPT0gXCJfYmlnYXJyMDJcIilcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGltcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYoYmEuZGltc1tpXSA8IDB4ZmZmZilcbiAgICAgICAgd3JpdGVyLndyaXRlKDE2LCBiYS5kaW1zW2ldKTtcbiAgICAgIGVsc2Uge1xuICAgICAgICB3cml0ZXIud3JpdGUoMTYsIDB4ZmZmZik7XG4gICAgICAgIHdyaXRlci53cml0ZSgzMiwgMCk7XG4gICAgICAgIHdyaXRlci53cml0ZSgzMiwgYmEuZGltc1tpXSk7XG4gICAgICB9XG4gICAgfVxuICBlbHNlXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRpbXMubGVuZ3RoOyBpKyspIHdyaXRlci53cml0ZSgzMixiYS5kaW1zW2ldKVxuICBzd2l0Y2goYmEua2luZCl7XG4gIGNhc2UgMjogIC8vSW50OEFycmF5XG4gIGNhc2UgMzogIC8vVWludDhBcnJheVxuICBjYXNlIDEyOiAvL1VpbnQ4QXJyYXlcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGF0YS5sZW5ndGg7IGkrKyl7XG4gICAgICB3cml0ZXIud3JpdGUoOCwgYmEuZGF0YVtpXSk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDQ6ICAvLyBJbnQxNkFycmF5XG4gIGNhc2UgNTogIC8vIFVpbnQxNkFycmF5XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRhdGEubGVuZ3RoOyBpKyspe1xuICAgICAgd3JpdGVyLndyaXRlKDE2LCBiYS5kYXRhW2ldKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgNjogIC8vIEludDMyQXJyYXkgKGludDMyKVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kYXRhLmxlbmd0aDsgaSsrKXtcbiAgICAgIHdyaXRlci53cml0ZSgzMiwgYmEuZGF0YVtpXSk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDg6ICAvLyBJbnQzMkFycmF5IChpbnQpXG4gIGNhc2UgOTogIC8vIEludDMyQXJyYXkgKG5hdGl2ZWludClcbiAgICB3cml0ZXIud3JpdGUoOCwwKTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGF0YS5sZW5ndGg7IGkrKyl7XG4gICAgICB3cml0ZXIud3JpdGUoMzIsIGJhLmRhdGFbaV0pO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSA3OiAgLy8gSW50MzJBcnJheSAoaW50NjQpXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRhdGEubGVuZ3RoIC8gMjsgaSsrKXtcbiAgICAgIHZhciBiID0gY2FtbF9pbnQ2NF90b19ieXRlcyhiYS5nZXQoaSkpO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCA4OyBqKyspIHdyaXRlci53cml0ZSAoOCwgYltqXSk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDE6ICAvLyBGbG9hdDY0QXJyYXlcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGF0YS5sZW5ndGg7IGkrKyl7XG4gICAgICB2YXIgYiA9IGNhbWxfaW50NjRfdG9fYnl0ZXMoY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0KGJhLmdldChpKSkpO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCA4OyBqKyspIHdyaXRlci53cml0ZSAoOCwgYltqXSk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDA6ICAvLyBGbG9hdDMyQXJyYXlcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGF0YS5sZW5ndGg7IGkrKyl7XG4gICAgICB2YXIgYiA9IGNhbWxfaW50MzJfYml0c19vZl9mbG9hdChiYS5nZXQoaSkpO1xuICAgICAgd3JpdGVyLndyaXRlKDMyLCBiKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMTA6IC8vIEZsb2F0MzJBcnJheSAoY29tcGxleDMyKVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kYXRhLmxlbmd0aCAvIDI7IGkrKyl7XG4gICAgICB2YXIgaiA9IGJhLmdldChpKTtcbiAgICAgIHdyaXRlci53cml0ZSgzMiwgY2FtbF9pbnQzMl9iaXRzX29mX2Zsb2F0KGpbMV0pKTtcbiAgICAgIHdyaXRlci53cml0ZSgzMiwgY2FtbF9pbnQzMl9iaXRzX29mX2Zsb2F0KGpbMl0pKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMTE6IC8vIEZsb2F0NjRBcnJheSAoY29tcGxleDY0KVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kYXRhLmxlbmd0aCAvIDI7IGkrKyl7XG4gICAgICB2YXIgY29tcGxleCA9IGJhLmdldChpKTtcbiAgICAgIHZhciBiID0gY2FtbF9pbnQ2NF90b19ieXRlcyhjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQoY29tcGxleFsxXSkpO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCA4OyBqKyspIHdyaXRlci53cml0ZSAoOCwgYltqXSk7XG4gICAgICB2YXIgYiA9IGNhbWxfaW50NjRfdG9fYnl0ZXMoY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0KGNvbXBsZXhbMl0pKTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgODsgaisrKSB3cml0ZXIud3JpdGUgKDgsIGJbal0pO1xuICAgIH1cbiAgICBicmVhaztcbiAgfVxuICBzelswXSA9ICg0ICsgYmEuZGltcy5sZW5ndGgpICogNDtcbiAgc3pbMV0gPSAoNCArIGJhLmRpbXMubGVuZ3RoKSAqIDg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZGVzZXJpYWxpemVcbi8vUmVxdWlyZXM6IGNhbWxfYmFfY3JlYXRlX3Vuc2FmZSwgY2FtbF9mYWlsd2l0aFxuLy9SZXF1aXJlczogY2FtbF9iYV9nZXRfc2l6ZVxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZl9ieXRlcywgY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzXG4vL1JlcXVpcmVzOiBjYW1sX2ludDMyX2Zsb2F0X29mX2JpdHNcbi8vUmVxdWlyZXM6IGNhbWxfYmFfY3JlYXRlX2J1ZmZlclxuZnVuY3Rpb24gY2FtbF9iYV9kZXNlcmlhbGl6ZShyZWFkZXIsIHN6LCBuYW1lKXtcbiAgdmFyIG51bV9kaW1zID0gcmVhZGVyLnJlYWQzMnMoKTtcbiAgaWYgKG51bV9kaW1zIDwgMCB8fCBudW1fZGltcyA+IDE2KVxuICAgIGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogd3JvbmcgbnVtYmVyIG9mIGJpZ2FycmF5IGRpbWVuc2lvbnNcIik7XG4gIHZhciB0YWcgPSByZWFkZXIucmVhZDMycygpO1xuICB2YXIga2luZCA9IHRhZyAmIDB4ZmZcbiAgdmFyIGxheW91dCA9ICh0YWcgPj4gOCkgJiAxO1xuICB2YXIgZGltcyA9IFtdXG4gIGlmKG5hbWUgPT0gXCJfYmlnYXJyMDJcIilcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9kaW1zOyBpKyspIHtcbiAgICAgIHZhciBzaXplX2RpbSA9IHJlYWRlci5yZWFkMTZ1KCk7XG4gICAgICBpZihzaXplX2RpbSA9PSAweGZmZmYpe1xuICAgICAgICB2YXIgc2l6ZV9kaW1faGkgPSByZWFkZXIucmVhZDMydSgpO1xuICAgICAgICB2YXIgc2l6ZV9kaW1fbG8gPSByZWFkZXIucmVhZDMydSgpO1xuICAgICAgICBpZihzaXplX2RpbV9oaSAhPSAwKVxuICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogYmlnYXJyYXkgZGltZW5zaW9uIG92ZXJmbG93IGluIDMyYml0XCIpO1xuICAgICAgICBzaXplX2RpbSA9IHNpemVfZGltX2xvO1xuICAgICAgfVxuICAgICAgZGltcy5wdXNoKHNpemVfZGltKTtcbiAgICB9XG4gIGVsc2VcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9kaW1zOyBpKyspIGRpbXMucHVzaChyZWFkZXIucmVhZDMydSgpKTtcbiAgdmFyIHNpemUgPSBjYW1sX2JhX2dldF9zaXplKGRpbXMpO1xuICB2YXIgZGF0YSA9IGNhbWxfYmFfY3JlYXRlX2J1ZmZlcihraW5kLCBzaXplKTtcbiAgdmFyIGJhID0gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGtpbmQsIGxheW91dCwgZGltcywgZGF0YSk7XG4gIHN3aXRjaChraW5kKXtcbiAgY2FzZSAyOiAgLy9JbnQ4QXJyYXlcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIGRhdGFbaV0gPSByZWFkZXIucmVhZDhzKCk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDM6ICAvL1VpbnQ4QXJyYXlcbiAgY2FzZSAxMjogLy9VaW50OEFycmF5XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICBkYXRhW2ldID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSA0OiAgLy8gSW50MTZBcnJheVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspe1xuICAgICAgZGF0YVtpXSA9IHJlYWRlci5yZWFkMTZzKCk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDU6ICAvLyBVaW50MTZBcnJheVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspe1xuICAgICAgZGF0YVtpXSA9IHJlYWRlci5yZWFkMTZ1KCk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDY6ICAvLyBJbnQzMkFycmF5IChpbnQzMilcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIGRhdGFbaV0gPSByZWFkZXIucmVhZDMycygpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSA4OiAgLy8gSW50MzJBcnJheSAoaW50KVxuICBjYXNlIDk6ICAvLyBJbnQzMkFycmF5IChuYXRpdmVpbnQpXG4gICAgdmFyIHNpeHR5ID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgIGlmKHNpeHR5KSBjYW1sX2ZhaWx3aXRoKFwiaW5wdXRfdmFsdWU6IGNhbm5vdCByZWFkIGJpZ2FycmF5IHdpdGggNjQtYml0IE9DYW1sIGludHNcIik7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICBkYXRhW2ldID0gcmVhZGVyLnJlYWQzMnMoKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgNzogLy8gKGludDY0KVxuICAgIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFtqXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgIHZhciBpbnQ2NCA9IGNhbWxfaW50NjRfb2ZfYnl0ZXModCk7XG4gICAgICBiYS5zZXQoaSxpbnQ2NCk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDE6ICAvLyBGbG9hdDY0QXJyYXlcbiAgICB2YXIgdCA9IG5ldyBBcnJheSg4KTs7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICBmb3IgKHZhciBqID0gMDtqIDwgODtqKyspIHRbal0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICB2YXIgZiA9IGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cyhjYW1sX2ludDY0X29mX2J5dGVzKHQpKTtcbiAgICAgIGJhLnNldChpLGYpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAwOiAgLy8gRmxvYXQzMkFycmF5XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICB2YXIgZiA9IGNhbWxfaW50MzJfZmxvYXRfb2ZfYml0cyhyZWFkZXIucmVhZDMycygpKTtcbiAgICAgIGJhLnNldChpLGYpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAxMDogLy8gRmxvYXQzMkFycmF5IChjb21wbGV4MzIpXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICB2YXIgcmUgPSBjYW1sX2ludDMyX2Zsb2F0X29mX2JpdHMocmVhZGVyLnJlYWQzMnMoKSk7XG4gICAgICB2YXIgaW0gPSBjYW1sX2ludDMyX2Zsb2F0X29mX2JpdHMocmVhZGVyLnJlYWQzMnMoKSk7XG4gICAgICBiYS5zZXQoaSxbMjU0LHJlLGltXSk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDExOiAvLyBGbG9hdDY0QXJyYXkgKGNvbXBsZXg2NClcbiAgICB2YXIgdCA9IG5ldyBBcnJheSg4KTs7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICBmb3IgKHZhciBqID0gMDtqIDwgODtqKyspIHRbal0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICB2YXIgcmUgPSBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMoY2FtbF9pbnQ2NF9vZl9ieXRlcyh0KSk7XG4gICAgICBmb3IgKHZhciBqID0gMDtqIDwgODtqKyspIHRbal0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICB2YXIgaW0gPSBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMoY2FtbF9pbnQ2NF9vZl9ieXRlcyh0KSk7XG4gICAgICBiYS5zZXQoaSxbMjU0LHJlLGltXSk7XG4gICAgfVxuICAgIGJyZWFrXG4gIH1cbiAgc3pbMF0gPSAoNCArIG51bV9kaW1zKSAqIDQ7XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoa2luZCwgbGF5b3V0LCBkaW1zLCBkYXRhKTtcbn1cblxuLy9EZXByZWNhdGVkXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2NyZWF0ZV9mcm9tXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUsIGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudFxuZnVuY3Rpb24gY2FtbF9iYV9jcmVhdGVfZnJvbShkYXRhMSwgZGF0YTIsIGpzdHlwLCBraW5kLCBsYXlvdXQsIGRpbXMpe1xuICBpZihkYXRhMiB8fCBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50KGtpbmQpID09IDIpe1xuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNhbWxfYmFfY3JlYXRlX2Zyb206IHVzZSByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlXCIpO1xuICB9XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoa2luZCwgbGF5b3V0LCBkaW1zLCBkYXRhMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfaGFzaCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9iYV9nZXRfc2l6ZSwgY2FtbF9oYXNoX21peF9pbnQsIGNhbWxfaGFzaF9taXhfZmxvYXRcbmZ1bmN0aW9uIGNhbWxfYmFfaGFzaChiYSl7XG4gIHZhciBudW1fZWx0cyA9IGNhbWxfYmFfZ2V0X3NpemUoYmEuZGltcyk7XG4gIHZhciBoID0gMDtcbiAgc3dpdGNoKGJhLmtpbmQpe1xuICBjYXNlIDI6ICAvL0ludDhBcnJheVxuICBjYXNlIDM6ICAvL1VpbnQ4QXJyYXlcbiAgY2FzZSAxMjogLy9VaW50OEFycmF5XG4gICAgaWYobnVtX2VsdHMgPiAyNTYpIG51bV9lbHRzID0gMjU2O1xuICAgIHZhciB3ID0gMCwgaSA9MDtcbiAgICBmb3IoaSA9IDA7IGkgKyA0IDw9IGJhLmRhdGEubGVuZ3RoOyBpKz00KXtcbiAgICAgIHcgPSBiYS5kYXRhW2krMF0gfCAoYmEuZGF0YVtpKzFdIDw8IDgpIHwgKGJhLmRhdGFbaSsyXSA8PCAxNikgfCAoYmEuZGF0YVtpKzNdIDw8IDI0KTtcbiAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLHcpO1xuICAgIH1cbiAgICB3ID0gMDtcbiAgICBzd2l0Y2ggKG51bV9lbHRzICYgMykge1xuICAgIGNhc2UgMzogdyAgPSBiYS5kYXRhW2krMl0gPDwgMTY7ICAgIC8qIGZhbGx0aHJvdWdoICovXG4gICAgY2FzZSAyOiB3IHw9IGJhLmRhdGFbaSsxXSA8PCA4OyAgICAgLyogZmFsbHRocm91Z2ggKi9cbiAgICBjYXNlIDE6IHcgfD0gYmEuZGF0YVtpKzBdO1xuICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHcpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSA0OiAgLy8gSW50MTZBcnJheVxuICBjYXNlIDU6ICAvLyBVaW50MTZBcnJheVxuICAgIGlmKG51bV9lbHRzID4gMTI4KSBudW1fZWx0cyA9IDEyODtcbiAgICB2YXIgdyA9IDAsIGkgPTA7XG4gICAgZm9yKGkgPSAwOyBpICsgMiA8PSBiYS5kYXRhLmxlbmd0aDsgaSs9Mil7XG4gICAgICB3ID0gYmEuZGF0YVtpKzBdIHwgKGJhLmRhdGFbaSsxXSA8PCAxNik7XG4gICAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCx3KTtcbiAgICB9XG4gICAgaWYgKChudW1fZWx0cyAmIDEpICE9IDApXG4gICAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgYmEuZGF0YVtpXSk7XG4gICAgYnJlYWs7XG4gIGNhc2UgNjogIC8vIEludDMyQXJyYXkgKGludDMyKVxuICAgIGlmIChudW1fZWx0cyA+IDY0KSBudW1fZWx0cyA9IDY0O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2VsdHM7IGkrKykgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIGJhLmRhdGFbaV0pO1xuICAgIGJyZWFrO1xuICBjYXNlIDg6ICAvLyBJbnQzMkFycmF5IChpbnQpXG4gIGNhc2UgOTogIC8vIEludDMyQXJyYXkgKG5hdGl2ZWludClcbiAgICBpZiAobnVtX2VsdHMgPiA2NCkgbnVtX2VsdHMgPSA2NDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9lbHRzOyBpKyspIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCBiYS5kYXRhW2ldKTtcbiAgICBicmVhaztcbiAgY2FzZSA3OiAgLy8gSW50MzJBcnJheSAoaW50NjQpXG4gICAgaWYgKG51bV9lbHRzID4gMzIpIG51bV9lbHRzID0gMzI7XG4gICAgbnVtX2VsdHMgKj0gMlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2VsdHM7IGkrKykge1xuICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIGJhLmRhdGFbaV0pO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAxMDogLy8gRmxvYXQzMkFycmF5IChjb21wbGV4MzIpXG4gICAgbnVtX2VsdHMgKj0yOyAvKiBmYWxsdGhyb3VnaCAqL1xuICBjYXNlIDA6ICAvLyBGbG9hdDMyQXJyYXlcbiAgICBpZiAobnVtX2VsdHMgPiA2NCkgbnVtX2VsdHMgPSA2NDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9lbHRzOyBpKyspIGggPSBjYW1sX2hhc2hfbWl4X2Zsb2F0KGgsIGJhLmRhdGFbaV0pO1xuICAgIGJyZWFrO1xuICBjYXNlIDExOiAvLyBGbG9hdDY0QXJyYXkgKGNvbXBsZXg2NClcbiAgICBudW1fZWx0cyAqPTI7IC8qIGZhbGx0aHJvdWdoICovXG4gIGNhc2UgMTogIC8vIEZsb2F0NjRBcnJheVxuICAgIGlmIChudW1fZWx0cyA+IDMyKSBudW1fZWx0cyA9IDMyO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2VsdHM7IGkrKykgaCA9IGNhbWxfaGFzaF9taXhfZmxvYXQoaCwgYmEuZGF0YVtpXSk7XG4gICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIGg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfdG9fdHlwZWRfYXJyYXkgbXV0YWJsZVxuZnVuY3Rpb24gY2FtbF9iYV90b190eXBlZF9hcnJheShiYSl7XG4gIHJldHVybiBiYS5kYXRhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2tpbmRfb2ZfdHlwZWRfYXJyYXkgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX2JhX2tpbmRfb2ZfdHlwZWRfYXJyYXkodGEpe1xuICB2YXIgZyA9IGpvb19nbG9iYWxfb2JqZWN0O1xuICB2YXIga2luZDtcbiAgaWYgKHRhIGluc3RhbmNlb2YgZy5GbG9hdDMyQXJyYXkpIGtpbmQgPSAwO1xuICBlbHNlIGlmICh0YSBpbnN0YW5jZW9mIGcuRmxvYXQ2NEFycmF5KSBraW5kID0gMTtcbiAgZWxzZSBpZiAodGEgaW5zdGFuY2VvZiBnLkludDhBcnJheSkga2luZCA9IDI7XG4gIGVsc2UgaWYgKHRhIGluc3RhbmNlb2YgZy5VaW50OEFycmF5KSBraW5kID0gMztcbiAgZWxzZSBpZiAodGEgaW5zdGFuY2VvZiBnLkludDE2QXJyYXkpIGtpbmQgPSA0O1xuICBlbHNlIGlmICh0YSBpbnN0YW5jZW9mIGcuVWludDE2QXJyYXkpIGtpbmQgPSA1O1xuICBlbHNlIGlmICh0YSBpbnN0YW5jZW9mIGcuSW50MzJBcnJheSkga2luZCA9IDY7XG4gIGVsc2UgaWYgKHRhIGluc3RhbmNlb2YgZy5VaW50MzJBcnJheSkga2luZCA9IDY7XG4gIGVsc2UgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY2FtbF9iYV9raW5kX29mX3R5cGVkX2FycmF5OiB1bnN1cHBvcnRlZCBraW5kXCIpO1xuICByZXR1cm4ga2luZDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9mcm9tX3R5cGVkX2FycmF5IG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfYmFfa2luZF9vZl90eXBlZF9hcnJheVxuLy9SZXF1aXJlczogY2FtbF9iYV9jcmVhdGVfdW5zYWZlXG5mdW5jdGlvbiBjYW1sX2JhX2Zyb21fdHlwZWRfYXJyYXkodGEpe1xuICB2YXIga2luZCA9IGNhbWxfYmFfa2luZF9vZl90eXBlZF9hcnJheSh0YSk7XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoa2luZCwgMCwgW3RhLmxlbmd0aF0sIHRhKTtcbn1cbiIsIi8vIEpzX29mX29jYW1sIGxpYnJhcnlcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8vLy8vLy8vLy8vLyBKc2xpYlxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3B1cmVfZXhwciBjb25zdFxuZnVuY3Rpb24gY2FtbF9qc19wdXJlX2V4cHIgKGYpIHsgcmV0dXJuIGYoKTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3NldCAobXV0YWJsZSwgY29uc3QsIGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc19zZXQobyxmLHYpIHsgb1tmXT12O3JldHVybiAwfVxuLy9Qcm92aWRlczogY2FtbF9qc19nZXQgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc19nZXQobyxmKSB7IHJldHVybiBvW2ZdOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2RlbGV0ZSAobXV0YWJsZSwgY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX2RlbGV0ZShvLGYpIHsgZGVsZXRlIG9bZl07IHJldHVybiAwfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2luc3RhbmNlb2YgKGNvbnN0LCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfaW5zdGFuY2VvZihvLGMpIHsgcmV0dXJuIG8gaW5zdGFuY2VvZiBjOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfdHlwZW9mIChjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfdHlwZW9mKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfb25faWUgY29uc3RcbmZ1bmN0aW9uIGNhbWxfanNfb25faWUgKCkge1xuICB2YXIgdWEgPVxuICAgICAgam9vX2dsb2JhbF9vYmplY3QubmF2aWdhdG9yP2pvb19nbG9iYWxfb2JqZWN0Lm5hdmlnYXRvci51c2VyQWdlbnQ6XCJcIjtcbiAgcmV0dXJuIHVhLmluZGV4T2YoXCJNU0lFXCIpICE9IC0xICYmIHVhLmluZGV4T2YoXCJPcGVyYVwiKSAhPSAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2h0bWxfZXNjYXBlIGNvbnN0IChjb25zdClcbnZhciBjYW1sX2pzX3JlZ2V4cHMgPSB7IGFtcDovJi9nLCBsdDovPC9nLCBxdW90Oi9cXFwiL2csIGFsbDovWyY8XFxcIl0vIH07XG5mdW5jdGlvbiBjYW1sX2pzX2h0bWxfZXNjYXBlIChzKSB7XG4gIGlmICghY2FtbF9qc19yZWdleHBzLmFsbC50ZXN0KHMpKSByZXR1cm4gcztcbiAgcmV0dXJuIHMucmVwbGFjZShjYW1sX2pzX3JlZ2V4cHMuYW1wLCBcIiZhbXA7XCIpXG4gICAgLnJlcGxhY2UoY2FtbF9qc19yZWdleHBzLmx0LCBcIiZsdDtcIilcbiAgICAucmVwbGFjZShjYW1sX2pzX3JlZ2V4cHMucXVvdCwgXCImcXVvdDtcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfaHRtbF9lbnRpdGllc1xuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9qc19odG1sX2VudGl0aWVzKHMpIHtcbiAgdmFyIGVudGl0eSA9IC9eJiM/WzAtOWEtekEtWl0rOyQvXG4gIGlmKHMubWF0Y2goZW50aXR5KSlcbiAge1xuICAgIHZhciBzdHIsIHRlbXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJyk7XG4gICAgdGVtcC5pbm5lckhUTUw9IHM7XG4gICAgc3RyPSB0ZW1wLnRleHRDb250ZW50IHx8IHRlbXAuaW5uZXJUZXh0O1xuICAgIHRlbXA9bnVsbDtcbiAgICByZXR1cm4gc3RyO1xuICB9XG4gIGVsc2Uge1xuICAgIGNhbWxfZmFpbHdpdGgoXCJJbnZhbGlkIGVudGl0eSBcIiArIHMpO1xuICB9XG59XG5cbi8vLy8vLy8vLy8vIERlYnVnZ2luZyBjb25zb2xlXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2dldF9jb25zb2xlIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2pzX2dldF9jb25zb2xlICgpIHtcbiAgdmFyIGMgPSBqb29fZ2xvYmFsX29iamVjdC5jb25zb2xlP2pvb19nbG9iYWxfb2JqZWN0LmNvbnNvbGU6e307XG4gIHZhciBtID0gW1wibG9nXCIsIFwiZGVidWdcIiwgXCJpbmZvXCIsIFwid2FyblwiLCBcImVycm9yXCIsIFwiYXNzZXJ0XCIsIFwiZGlyXCIsIFwiZGlyeG1sXCIsXG4gICAgICAgICAgIFwidHJhY2VcIiwgXCJncm91cFwiLCBcImdyb3VwQ29sbGFwc2VkXCIsIFwiZ3JvdXBFbmRcIiwgXCJ0aW1lXCIsIFwidGltZUVuZFwiXTtcbiAgZnVuY3Rpb24gZiAoKSB7fVxuICBmb3IgKHZhciBpID0gMDsgaSA8IG0ubGVuZ3RoOyBpKyspIGlmICghY1ttW2ldXSkgY1ttW2ldXT1mO1xuICByZXR1cm4gYztcbn1cblxuLy9Qcm92aWRlczpjYW1sX3RyYW1wb2xpbmVcbmZ1bmN0aW9uIGNhbWxfdHJhbXBvbGluZShyZXMpIHtcbiAgdmFyIGMgPSAxO1xuICB3aGlsZShyZXMgJiYgcmVzLmpvb190cmFtcCl7XG4gICAgcmVzID0gcmVzLmpvb190cmFtcC5hcHBseShudWxsLCByZXMuam9vX2FyZ3MpO1xuICAgIGMrKztcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG4vL1Byb3ZpZGVzOmNhbWxfdHJhbXBvbGluZV9yZXR1cm5cbmZ1bmN0aW9uIGNhbWxfdHJhbXBvbGluZV9yZXR1cm4oZixhcmdzKSB7XG4gIHJldHVybiB7am9vX3RyYW1wOmYsam9vX2FyZ3M6YXJnc307XG59XG5cbi8vUHJvdmlkZXM6IGpzX3ByaW50X3N0ZG91dCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX3V0ZjE2X29mX3V0ZjhcbmZ1bmN0aW9uIGpzX3ByaW50X3N0ZG91dChzKSB7XG4gIHZhciBzID0gY2FtbF91dGYxNl9vZl91dGY4KHMpO1xuICB2YXIgZyA9IGpvb19nbG9iYWxfb2JqZWN0O1xuICBpZiAoZy5wcm9jZXNzICYmIGcucHJvY2Vzcy5zdGRvdXQgJiYgZy5wcm9jZXNzLnN0ZG91dC53cml0ZSkge1xuICAgIGcucHJvY2Vzcy5zdGRvdXQud3JpdGUocylcbiAgfSBlbHNlIHtcbiAgICAvLyBEbyBub3Qgb3V0cHV0IHRoZSBsYXN0IFxcbiBpZiBwcmVzZW50XG4gICAgLy8gYXMgY29uc29sZSBsb2dnaW5nIGRpc3BsYXkgYSBuZXdsaW5lIGF0IHRoZSBlbmRcbiAgICBpZihzLmNoYXJDb2RlQXQocy5sZW5ndGggLSAxKSA9PSAxMClcbiAgICAgIHMgPSBzLnN1YnN0cigwLHMubGVuZ3RoIC0gMSApO1xuICAgIHZhciB2ID0gZy5jb25zb2xlO1xuICAgIHYgICYmIHYubG9nICYmIHYubG9nKHMpO1xuICB9XG59XG4vL1Byb3ZpZGVzOiBqc19wcmludF9zdGRlcnIgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF91dGYxNl9vZl91dGY4XG5mdW5jdGlvbiBqc19wcmludF9zdGRlcnIocykge1xuICB2YXIgcyA9IGNhbWxfdXRmMTZfb2ZfdXRmOChzKTtcbiAgdmFyIGcgPSBqb29fZ2xvYmFsX29iamVjdDtcbiAgaWYgKGcucHJvY2VzcyAmJiBnLnByb2Nlc3Muc3Rkb3V0ICYmIGcucHJvY2Vzcy5zdGRvdXQud3JpdGUpIHtcbiAgICBnLnByb2Nlc3Muc3RkZXJyLndyaXRlKHMpXG4gIH0gZWxzZSB7XG4gICAgLy8gRG8gbm90IG91dHB1dCB0aGUgbGFzdCBcXG4gaWYgcHJlc2VudFxuICAgIC8vIGFzIGNvbnNvbGUgbG9nZ2luZyBkaXNwbGF5IGEgbmV3bGluZSBhdCB0aGUgZW5kXG4gICAgaWYocy5jaGFyQ29kZUF0KHMubGVuZ3RoIC0gMSkgPT0gMTApXG4gICAgICBzID0gcy5zdWJzdHIoMCxzLmxlbmd0aCAtIDEgKTtcbiAgICB2YXIgdiA9IGcuY29uc29sZTtcbiAgICB2ICYmIHYuZXJyb3IgJiYgdi5lcnJvcihzKTtcbiAgfVxufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfaXNfanNcbmZ1bmN0aW9uIGNhbWxfaXNfanMoKSB7XG4gIHJldHVybiAxO1xufVxuXG5cblxuLy9Qcm92aWRlczogY2FtbF93cmFwX2V4Y2VwdGlvbiBjb25zdCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2dsb2JhbF9kYXRhLGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nLGNhbWxfbmFtZWRfdmFsdWVcbi8vUmVxdWlyZXM6IGNhbWxfcmV0dXJuX2V4bl9jb25zdGFudFxuZnVuY3Rpb24gY2FtbF93cmFwX2V4Y2VwdGlvbihlKSB7XG4gIGlmKGUgaW5zdGFuY2VvZiBBcnJheSkgcmV0dXJuIGU7XG4gIC8vU3RhY2tfb3ZlcmZsb3c6IGNocm9tZSwgc2FmYXJpXG4gIGlmKGpvb19nbG9iYWxfb2JqZWN0LlJhbmdlRXJyb3JcbiAgICAgJiYgZSBpbnN0YW5jZW9mIGpvb19nbG9iYWxfb2JqZWN0LlJhbmdlRXJyb3JcbiAgICAgJiYgZS5tZXNzYWdlXG4gICAgICYmIGUubWVzc2FnZS5tYXRjaCgvbWF4aW11bSBjYWxsIHN0YWNrL2kpKVxuICAgIHJldHVybiBjYW1sX3JldHVybl9leG5fY29uc3RhbnQoY2FtbF9nbG9iYWxfZGF0YS5TdGFja19vdmVyZmxvdyk7XG4gIC8vU3RhY2tfb3ZlcmZsb3c6IGZpcmVmb3hcbiAgaWYoam9vX2dsb2JhbF9vYmplY3QuSW50ZXJuYWxFcnJvclxuICAgICAmJiBlIGluc3RhbmNlb2Ygam9vX2dsb2JhbF9vYmplY3QuSW50ZXJuYWxFcnJvclxuICAgICAmJiBlLm1lc3NhZ2VcbiAgICAgJiYgZS5tZXNzYWdlLm1hdGNoKC90b28gbXVjaCByZWN1cnNpb24vaSkpXG4gICAgcmV0dXJuIGNhbWxfcmV0dXJuX2V4bl9jb25zdGFudChjYW1sX2dsb2JhbF9kYXRhLlN0YWNrX292ZXJmbG93KTtcbiAgLy9XcmFwIEVycm9yIGluIEpzLkVycm9yIGV4Y2VwdGlvblxuICBpZihlIGluc3RhbmNlb2Ygam9vX2dsb2JhbF9vYmplY3QuRXJyb3IgJiYgY2FtbF9uYW1lZF92YWx1ZShcImpzRXJyb3JcIikpXG4gICAgcmV0dXJuIFswLGNhbWxfbmFtZWRfdmFsdWUoXCJqc0Vycm9yXCIpLGVdO1xuICAvL2ZhbGxiYWNrOiB3cmFwcGVkIGluIEZhaWx1cmVcbiAgcmV0dXJuIFswLGNhbWxfZ2xvYmFsX2RhdGEuRmFpbHVyZSxjYW1sX3N0cmluZ19vZl9qc3N0cmluZyAoU3RyaW5nKGUpKV07XG59XG5cbi8vIEV4cGVyaW1lbnRhbFxuLy9Qcm92aWRlczogY2FtbF9leG5fd2l0aF9qc19iYWNrdHJhY2Vcbi8vUmVxdWlyZXM6IGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfZXhuX3dpdGhfanNfYmFja3RyYWNlKGV4biwgZm9yY2UpIHtcbiAgLy9uZXZlciByZXJhaXNlIGZvciBjb25zdGFudCBleG5cbiAgaWYoIWV4bi5qc19lcnJvciB8fCBmb3JjZSB8fCBleG5bMF0gPT0gMjQ4KSBleG4uanNfZXJyb3IgPSBuZXcgam9vX2dsb2JhbF9vYmplY3QuRXJyb3IoXCJKcyBleGNlcHRpb24gY29udGFpbmluZyBiYWNrdHJhY2VcIik7XG4gIHJldHVybiBleG47XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZXJyb3Jfb2ZfZXhjZXB0aW9uXG5mdW5jdGlvbiBjYW1sX2pzX2Vycm9yX29mX2V4Y2VwdGlvbihleG4pIHtcbiAgaWYoZXhuLmpzX2Vycm9yKSB7IHJldHVybiBleG4uanNfZXJyb3I7IH1cbiAgcmV0dXJuIG51bGw7XG59XG4iLCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdGl2ZSBDYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKiAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKiAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICovXG4vKiAgZW4gQXV0b21hdGlxdWUuICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkICAgICovXG4vKiAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UsIHdpdGggICAgICovXG4vKiAgdGhlIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIGZpbGUgLi4vTElDRU5TRS4gICAgICovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8qICRJZDogcGFyc2luZy5jIDg5ODMgMjAwOC0wOC0wNiAwOTozODoyNVogeGxlcm95ICQgKi9cblxuLyogVGhlIFBEQSBhdXRvbWF0b24gZm9yIHBhcnNlcnMgZ2VuZXJhdGVkIGJ5IGNhbWx5YWNjICovXG5cbi8qIFRoZSBwdXNoZG93biBhdXRvbWF0YSAqL1xuXG4vL1Byb3ZpZGVzOiBjYW1sX3BhcnNlX2VuZ2luZVxuLy9SZXF1aXJlczogY2FtbF9sZXhfYXJyYXlcbmZ1bmN0aW9uIGNhbWxfcGFyc2VfZW5naW5lKHRhYmxlcywgZW52LCBjbWQsIGFyZylcbntcbiAgdmFyIEVSUkNPREUgPSAyNTY7XG5cbiAgLy92YXIgU1RBUlQgPSAwO1xuICAvL3ZhciBUT0tFTl9SRUFEID0gMTtcbiAgLy92YXIgU1RBQ0tTX0dST1dOXzEgPSAyO1xuICAvL3ZhciBTVEFDS1NfR1JPV05fMiA9IDM7XG4gIC8vdmFyIFNFTUFOVElDX0FDVElPTl9DT01QVVRFRCA9IDQ7XG4gIC8vdmFyIEVSUk9SX0RFVEVDVEVEID0gNTtcbiAgdmFyIGxvb3AgPSA2O1xuICB2YXIgdGVzdHNoaWZ0ID0gNztcbiAgdmFyIHNoaWZ0ID0gODtcbiAgdmFyIHNoaWZ0X3JlY292ZXIgPSA5O1xuICB2YXIgcmVkdWNlID0gMTA7XG5cbiAgdmFyIFJFQURfVE9LRU4gPSAwO1xuICB2YXIgUkFJU0VfUEFSU0VfRVJST1IgPSAxO1xuICB2YXIgR1JPV19TVEFDS1NfMSA9IDI7XG4gIHZhciBHUk9XX1NUQUNLU18yID0gMztcbiAgdmFyIENPTVBVVEVfU0VNQU5USUNfQUNUSU9OID0gNDtcbiAgdmFyIENBTExfRVJST1JfRlVOQ1RJT04gPSA1O1xuXG4gIHZhciBlbnZfc19zdGFjayA9IDE7XG4gIHZhciBlbnZfdl9zdGFjayA9IDI7XG4gIHZhciBlbnZfc3ltYl9zdGFydF9zdGFjayA9IDM7XG4gIHZhciBlbnZfc3ltYl9lbmRfc3RhY2sgPSA0O1xuICB2YXIgZW52X3N0YWNrc2l6ZSA9IDU7XG4gIHZhciBlbnZfc3RhY2tiYXNlID0gNjtcbiAgdmFyIGVudl9jdXJyX2NoYXIgPSA3O1xuICB2YXIgZW52X2x2YWwgPSA4O1xuICB2YXIgZW52X3N5bWJfc3RhcnQgPSA5O1xuICB2YXIgZW52X3N5bWJfZW5kID0gMTA7XG4gIHZhciBlbnZfYXNwID0gMTE7XG4gIHZhciBlbnZfcnVsZV9sZW4gPSAxMjtcbiAgdmFyIGVudl9ydWxlX251bWJlciA9IDEzO1xuICB2YXIgZW52X3NwID0gMTQ7XG4gIHZhciBlbnZfc3RhdGUgPSAxNTtcbiAgdmFyIGVudl9lcnJmbGFnID0gMTY7XG5cbiAgLy8gdmFyIF90YmxfYWN0aW9ucyA9IDE7XG4gIHZhciB0YmxfdHJhbnNsX2NvbnN0ID0gMjtcbiAgdmFyIHRibF90cmFuc2xfYmxvY2sgPSAzO1xuICB2YXIgdGJsX2xocyA9IDQ7XG4gIHZhciB0YmxfbGVuID0gNTtcbiAgdmFyIHRibF9kZWZyZWQgPSA2O1xuICB2YXIgdGJsX2Rnb3RvID0gNztcbiAgdmFyIHRibF9zaW5kZXggPSA4O1xuICB2YXIgdGJsX3JpbmRleCA9IDk7XG4gIHZhciB0YmxfZ2luZGV4ID0gMTA7XG4gIHZhciB0YmxfdGFibGVzaXplID0gMTE7XG4gIHZhciB0YmxfdGFibGUgPSAxMjtcbiAgdmFyIHRibF9jaGVjayA9IDEzO1xuICAvLyB2YXIgX3RibF9lcnJvcl9mdW5jdGlvbiA9IDE0O1xuICAvLyB2YXIgX3RibF9uYW1lc19jb25zdCA9IDE1O1xuICAvLyB2YXIgX3RibF9uYW1lc19ibG9jayA9IDE2O1xuXG4gIGlmICghdGFibGVzLmRnb3RvKSB7XG4gICAgdGFibGVzLmRlZnJlZCA9IGNhbWxfbGV4X2FycmF5ICh0YWJsZXNbdGJsX2RlZnJlZF0pO1xuICAgIHRhYmxlcy5zaW5kZXggPSBjYW1sX2xleF9hcnJheSAodGFibGVzW3RibF9zaW5kZXhdKTtcbiAgICB0YWJsZXMuY2hlY2sgID0gY2FtbF9sZXhfYXJyYXkgKHRhYmxlc1t0YmxfY2hlY2tdKTtcbiAgICB0YWJsZXMucmluZGV4ID0gY2FtbF9sZXhfYXJyYXkgKHRhYmxlc1t0YmxfcmluZGV4XSk7XG4gICAgdGFibGVzLnRhYmxlICA9IGNhbWxfbGV4X2FycmF5ICh0YWJsZXNbdGJsX3RhYmxlXSk7XG4gICAgdGFibGVzLmxlbiAgICA9IGNhbWxfbGV4X2FycmF5ICh0YWJsZXNbdGJsX2xlbl0pO1xuICAgIHRhYmxlcy5saHMgICAgPSBjYW1sX2xleF9hcnJheSAodGFibGVzW3RibF9saHNdKTtcbiAgICB0YWJsZXMuZ2luZGV4ID0gY2FtbF9sZXhfYXJyYXkgKHRhYmxlc1t0YmxfZ2luZGV4XSk7XG4gICAgdGFibGVzLmRnb3RvICA9IGNhbWxfbGV4X2FycmF5ICh0YWJsZXNbdGJsX2Rnb3RvXSk7XG4gIH1cblxuICB2YXIgcmVzID0gMCwgbiwgbjEsIG4yLCBzdGF0ZTE7XG5cbiAgLy8gUkVTVE9SRVxuICB2YXIgc3AgPSBlbnZbZW52X3NwXTtcbiAgdmFyIHN0YXRlID0gZW52W2Vudl9zdGF0ZV07XG4gIHZhciBlcnJmbGFnID0gZW52W2Vudl9lcnJmbGFnXTtcblxuICBleGl0OmZvciAoOzspIHtcbiAgICBzd2l0Y2goY21kKSB7XG4gICAgY2FzZSAwOi8vU1RBUlQ6XG4gICAgICBzdGF0ZSA9IDA7XG4gICAgICBlcnJmbGFnID0gMDtcbiAgICAgIC8vIEZhbGwgdGhyb3VnaFxuXG4gICAgY2FzZSA2Oi8vbG9vcDpcbiAgICAgIG4gPSB0YWJsZXMuZGVmcmVkW3N0YXRlXTtcbiAgICAgIGlmIChuICE9IDApIHsgY21kID0gcmVkdWNlOyBicmVhazsgfVxuICAgICAgaWYgKGVudltlbnZfY3Vycl9jaGFyXSA+PSAwKSB7IGNtZCA9IHRlc3RzaGlmdDsgYnJlYWs7IH1cbiAgICAgIHJlcyA9IFJFQURfVE9LRU47XG4gICAgICBicmVhayBleGl0O1xuICAgICAgLyogVGhlIE1MIGNvZGUgY2FsbHMgdGhlIGxleGVyIGFuZCB1cGRhdGVzICovXG4gICAgICAvKiBzeW1iX3N0YXJ0IGFuZCBzeW1iX2VuZCAqL1xuICAgIGNhc2UgMTovL1RPS0VOX1JFQUQ6XG4gICAgICBpZiAoYXJnIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgZW52W2Vudl9jdXJyX2NoYXJdID0gdGFibGVzW3RibF90cmFuc2xfYmxvY2tdW2FyZ1swXSArIDFdO1xuICAgICAgICBlbnZbZW52X2x2YWxdID0gYXJnWzFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW52W2Vudl9jdXJyX2NoYXJdID0gdGFibGVzW3RibF90cmFuc2xfY29uc3RdW2FyZyArIDFdO1xuICAgICAgICBlbnZbZW52X2x2YWxdID0gMDtcbiAgICAgIH1cbiAgICAgIC8vIEZhbGwgdGhyb3VnaFxuXG4gICAgY2FzZSA3Oi8vdGVzdHNoaWZ0OlxuICAgICAgbjEgPSB0YWJsZXMuc2luZGV4W3N0YXRlXTtcbiAgICAgIG4yID0gbjEgKyBlbnZbZW52X2N1cnJfY2hhcl07XG4gICAgICBpZiAobjEgIT0gMCAmJiBuMiA+PSAwICYmIG4yIDw9IHRhYmxlc1t0YmxfdGFibGVzaXplXSAmJlxuICAgICAgICAgIHRhYmxlcy5jaGVja1tuMl0gPT0gZW52W2Vudl9jdXJyX2NoYXJdKSB7XG4gICAgICAgIGNtZCA9IHNoaWZ0OyBicmVhaztcbiAgICAgIH1cbiAgICAgIG4xID0gdGFibGVzLnJpbmRleFtzdGF0ZV07XG4gICAgICBuMiA9IG4xICsgZW52W2Vudl9jdXJyX2NoYXJdO1xuICAgICAgaWYgKG4xICE9IDAgJiYgbjIgPj0gMCAmJiBuMiA8PSB0YWJsZXNbdGJsX3RhYmxlc2l6ZV0gJiZcbiAgICAgICAgICB0YWJsZXMuY2hlY2tbbjJdID09IGVudltlbnZfY3Vycl9jaGFyXSkge1xuICAgICAgICBuID0gdGFibGVzLnRhYmxlW24yXTtcbiAgICAgICAgY21kID0gcmVkdWNlOyBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChlcnJmbGFnIDw9IDApIHtcbiAgICAgICAgcmVzID0gQ0FMTF9FUlJPUl9GVU5DVElPTjtcbiAgICAgICAgYnJlYWsgZXhpdDtcbiAgICAgIH1cbiAgICAgIC8vIEZhbGwgdGhyb3VnaFxuICAgICAgLyogVGhlIE1MIGNvZGUgY2FsbHMgdGhlIGVycm9yIGZ1bmN0aW9uICovXG4gICAgY2FzZSA1Oi8vRVJST1JfREVURUNURUQ6XG4gICAgICBpZiAoZXJyZmxhZyA8IDMpIHtcbiAgICAgICAgZXJyZmxhZyA9IDM7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICBzdGF0ZTEgPSBlbnZbZW52X3Nfc3RhY2tdW3NwICsgMV07XG4gICAgICAgICAgbjEgPSB0YWJsZXMuc2luZGV4W3N0YXRlMV07XG4gICAgICAgICAgbjIgPSBuMSArIEVSUkNPREU7XG4gICAgICAgICAgaWYgKG4xICE9IDAgJiYgbjIgPj0gMCAmJiBuMiA8PSB0YWJsZXNbdGJsX3RhYmxlc2l6ZV0gJiZcbiAgICAgICAgICAgICAgdGFibGVzLmNoZWNrW24yXSA9PSBFUlJDT0RFKSB7XG4gICAgICAgICAgICBjbWQgPSBzaGlmdF9yZWNvdmVyOyBicmVhaztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHNwIDw9IGVudltlbnZfc3RhY2tiYXNlXSkgcmV0dXJuIFJBSVNFX1BBUlNFX0VSUk9SO1xuICAgICAgICAgICAgLyogVGhlIE1MIGNvZGUgcmFpc2VzIFBhcnNlX2Vycm9yICovXG4gICAgICAgICAgICBzcC0tO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGVudltlbnZfY3Vycl9jaGFyXSA9PSAwKSByZXR1cm4gUkFJU0VfUEFSU0VfRVJST1I7XG4gICAgICAgIC8qIFRoZSBNTCBjb2RlIHJhaXNlcyBQYXJzZV9lcnJvciAqL1xuICAgICAgICBlbnZbZW52X2N1cnJfY2hhcl0gPSAtMTtcbiAgICAgICAgY21kID0gbG9vcDsgYnJlYWs7XG4gICAgICB9XG4gICAgICAvLyBGYWxsIHRocm91Z2hcbiAgICBjYXNlIDg6Ly9zaGlmdDpcbiAgICAgIGVudltlbnZfY3Vycl9jaGFyXSA9IC0xO1xuICAgICAgaWYgKGVycmZsYWcgPiAwKSBlcnJmbGFnLS07XG4gICAgICAvLyBGYWxsIHRocm91Z2hcbiAgICBjYXNlIDk6Ly9zaGlmdF9yZWNvdmVyOlxuICAgICAgc3RhdGUgPSB0YWJsZXMudGFibGVbbjJdO1xuICAgICAgc3ArKztcbiAgICAgIGlmIChzcCA+PSBlbnZbZW52X3N0YWNrc2l6ZV0pIHtcbiAgICAgICAgcmVzID0gR1JPV19TVEFDS1NfMTtcbiAgICAgICAgYnJlYWsgZXhpdDtcbiAgICAgIH1cbiAgICAgIC8vIEZhbGwgdGhyb3VnaFxuICAgICAgLyogVGhlIE1MIGNvZGUgcmVzaXplcyB0aGUgc3RhY2tzICovXG4gICAgY2FzZSAyOi8vU1RBQ0tTX0dST1dOXzE6XG4gICAgICBlbnZbZW52X3Nfc3RhY2tdW3NwICsgMV0gPSBzdGF0ZTtcbiAgICAgIGVudltlbnZfdl9zdGFja11bc3AgKyAxXSA9IGVudltlbnZfbHZhbF07XG4gICAgICBlbnZbZW52X3N5bWJfc3RhcnRfc3RhY2tdW3NwICsgMV0gPSBlbnZbZW52X3N5bWJfc3RhcnRdO1xuICAgICAgZW52W2Vudl9zeW1iX2VuZF9zdGFja11bc3AgKyAxXSA9IGVudltlbnZfc3ltYl9lbmRdO1xuICAgICAgY21kID0gbG9vcDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAxMDovL3JlZHVjZTpcbiAgICAgIHZhciBtID0gdGFibGVzLmxlbltuXTtcbiAgICAgIGVudltlbnZfYXNwXSA9IHNwO1xuICAgICAgZW52W2Vudl9ydWxlX251bWJlcl0gPSBuO1xuICAgICAgZW52W2Vudl9ydWxlX2xlbl0gPSBtO1xuICAgICAgc3AgPSBzcCAtIG0gKyAxO1xuICAgICAgbSA9IHRhYmxlcy5saHNbbl07XG4gICAgICBzdGF0ZTEgPSBlbnZbZW52X3Nfc3RhY2tdW3NwXTtcbiAgICAgIG4xID0gdGFibGVzLmdpbmRleFttXTtcbiAgICAgIG4yID0gbjEgKyBzdGF0ZTE7XG4gICAgICBpZiAobjEgIT0gMCAmJiBuMiA+PSAwICYmIG4yIDw9IHRhYmxlc1t0YmxfdGFibGVzaXplXSAmJlxuICAgICAgICAgIHRhYmxlcy5jaGVja1tuMl0gPT0gc3RhdGUxKVxuICAgICAgICBzdGF0ZSA9IHRhYmxlcy50YWJsZVtuMl07XG4gICAgICBlbHNlXG4gICAgICAgIHN0YXRlID0gdGFibGVzLmRnb3RvW21dO1xuICAgICAgaWYgKHNwID49IGVudltlbnZfc3RhY2tzaXplXSkge1xuICAgICAgICByZXMgPSBHUk9XX1NUQUNLU18yO1xuICAgICAgICBicmVhayBleGl0O1xuICAgICAgfVxuICAgICAgLy8gRmFsbCB0aHJvdWdoXG4gICAgICAvKiBUaGUgTUwgY29kZSByZXNpemVzIHRoZSBzdGFja3MgKi9cbiAgICBjYXNlIDM6Ly9TVEFDS1NfR1JPV05fMjpcbiAgICAgIHJlcyA9IENPTVBVVEVfU0VNQU5USUNfQUNUSU9OO1xuICAgICAgYnJlYWsgZXhpdDtcbiAgICAgIC8qIFRoZSBNTCBjb2RlIGNhbGxzIHRoZSBzZW1hbnRpYyBhY3Rpb24gKi9cbiAgICBjYXNlIDQ6Ly9TRU1BTlRJQ19BQ1RJT05fQ09NUFVURUQ6XG4gICAgICBlbnZbZW52X3Nfc3RhY2tdW3NwICsgMV0gPSBzdGF0ZTtcbiAgICAgIGVudltlbnZfdl9zdGFja11bc3AgKyAxXSA9IGFyZztcbiAgICAgIHZhciBhc3AgPSBlbnZbZW52X2FzcF07XG4gICAgICBlbnZbZW52X3N5bWJfZW5kX3N0YWNrXVtzcCArIDFdID0gZW52W2Vudl9zeW1iX2VuZF9zdGFja11bYXNwICsgMV07XG4gICAgICBpZiAoc3AgPiBhc3ApIHtcbiAgICAgICAgLyogVGhpcyBpcyBhbiBlcHNpbG9uIHByb2R1Y3Rpb24uIFRha2Ugc3ltYl9zdGFydCBlcXVhbCB0byBzeW1iX2VuZC4gKi9cbiAgICAgICAgZW52W2Vudl9zeW1iX3N0YXJ0X3N0YWNrXVtzcCArIDFdID0gZW52W2Vudl9zeW1iX2VuZF9zdGFja11bYXNwICsgMV07XG4gICAgICB9XG4gICAgICBjbWQgPSBsb29wOyBicmVhaztcbiAgICAgIC8qIFNob3VsZCBub3QgaGFwcGVuICovXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBSQUlTRV9QQVJTRV9FUlJPUjtcbiAgICB9XG4gIH1cbiAgLy8gU0FWRVxuICBlbnZbZW52X3NwXSA9IHNwO1xuICBlbnZbZW52X3N0YXRlXSA9IHN0YXRlO1xuICBlbnZbZW52X2VycmZsYWddID0gZXJyZmxhZztcbiAgcmV0dXJuIHJlcztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zZXRfcGFyc2VyX3RyYWNlIGNvbnN0XG4vL0R1bW15IGZ1bmN0aW9uIVxuZnVuY3Rpb24gY2FtbF9zZXRfcGFyc2VyX3RyYWNlKCkgeyByZXR1cm4gMDsgfVxuIiwiLy8gSnNfb2Zfb2NhbWwgbGlicmFyeVxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxMCBKw6lyw7RtZSBWb3VpbGxvblxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vLy8vLy8vLy8vLy8vIEpzbGliOiBjb2RlIHNwZWNpZmljIHRvIEpzX29mX29jYW1sXG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZnJvbV9ib29sIGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfZnJvbV9ib29sKHgpIHsgcmV0dXJuICEheDsgfVxuLy9Qcm92aWRlczogY2FtbF9qc190b19ib29sIGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfdG9fYm9vbCh4KSB7IHJldHVybiAreDsgfVxuLy9Qcm92aWRlczogY2FtbF9qc19mcm9tX2Zsb2F0IGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfZnJvbV9mbG9hdCh4KSB7IHJldHVybiB4OyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3RvX2Zsb2F0IGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfdG9fZmxvYXQoeCkgeyByZXR1cm4geDsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2Zyb21fYXJyYXkgbXV0YWJsZSAoc2hhbGxvdylcbmZ1bmN0aW9uIGNhbWxfanNfZnJvbV9hcnJheShhKSB7XG4gIHJldHVybiBhLnNsaWNlKDEpO1xufVxuLy9Qcm92aWRlczogY2FtbF9qc190b19hcnJheSBtdXRhYmxlIChzaGFsbG93KVxuZnVuY3Rpb24gY2FtbF9qc190b19hcnJheShhKSB7XG4gIHZhciBsZW4gPSBhLmxlbmd0aDtcbiAgdmFyIGIgPSBuZXcgQXJyYXkobGVuKzEpO1xuICBiWzBdID0gMDtcbiAgZm9yKHZhciBpPTA7aTxsZW47aSsrKSBiW2krMV0gPSBhW2ldO1xuICByZXR1cm4gYjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9saXN0X29mX2pzX2FycmF5IGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfbGlzdF9vZl9qc19hcnJheShhKXtcbiAgdmFyIGwgPSAwO1xuICBmb3IodmFyIGk9YS5sZW5ndGggLSAxOyBpPj0wOyBpLS0pe1xuICAgIHZhciBlID0gYVtpXTtcbiAgICBsID0gWzAsZSxsXTtcbiAgfVxuICByZXR1cm4gbFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2xpc3RfdG9fanNfYXJyYXkgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9saXN0X3RvX2pzX2FycmF5KGwpe1xuICB2YXIgYSA9IFtdO1xuICBmb3IoOyBsICE9PSAwOyBsID0gbFsyXSkge1xuICAgIGEucHVzaChsWzFdKTtcbiAgfVxuICByZXR1cm4gYTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9qc192YXIgbXV0YWJsZSAoY29uc3QpXG4vL1JlcXVpcmVzOiBqc19wcmludF9zdGRlcnJcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2pzX3Zhcih4KSB7XG4gIHZhciB4ID0gY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcoeCk7XG4gIC8vQ2hlY2tzIHRoYXQgeCBoYXMgdGhlIGZvcm0gaWRlbnRbLmlkZW50XSpcbiAgaWYoIXgubWF0Y2goL15bYS16QS1aXyRdW2EtekEtWl8kMC05XSooXFwuW2EtekEtWl8kXVthLXpBLVpfJDAtOV0qKSokLykpe1xuICAgIGpzX3ByaW50X3N0ZGVycihcImNhbWxfanNfdmFyOiBcXFwiXCIgKyB4ICsgXCJcXFwiIGlzIG5vdCBhIHZhbGlkIEphdmFTY3JpcHQgdmFyaWFibGUuIGNvbnRpbnVpbmcgLi5cIik7XG4gICAgLy9qb29fZ2xvYmFsX29iamVjdC5jb25zb2xlLmVycm9yKFwiSnMuVW5zYWZlLmV2YWxfc3RyaW5nXCIpXG4gIH1cbiAgcmV0dXJuIGV2YWwoeCk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2NhbGwgKGNvbnN0LCBtdXRhYmxlLCBzaGFsbG93KVxuLy9SZXF1aXJlczogY2FtbF9qc19mcm9tX2FycmF5XG5mdW5jdGlvbiBjYW1sX2pzX2NhbGwoZiwgbywgYXJncykgeyByZXR1cm4gZi5hcHBseShvLCBjYW1sX2pzX2Zyb21fYXJyYXkoYXJncykpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2Z1bl9jYWxsIChjb25zdCwgc2hhbGxvdylcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheVxuZnVuY3Rpb24gY2FtbF9qc19mdW5fY2FsbChmLCBhKSB7XG4gIHN3aXRjaCAoYS5sZW5ndGgpIHtcbiAgY2FzZSAxOiByZXR1cm4gZigpO1xuICBjYXNlIDI6IHJldHVybiBmIChhWzFdKTtcbiAgY2FzZSAzOiByZXR1cm4gZiAoYVsxXSxhWzJdKTtcbiAgY2FzZSA0OiByZXR1cm4gZiAoYVsxXSxhWzJdLGFbM10pO1xuICBjYXNlIDU6IHJldHVybiBmIChhWzFdLGFbMl0sYVszXSxhWzRdKTtcbiAgY2FzZSA2OiByZXR1cm4gZiAoYVsxXSxhWzJdLGFbM10sYVs0XSxhWzVdKTtcbiAgY2FzZSA3OiByZXR1cm4gZiAoYVsxXSxhWzJdLGFbM10sYVs0XSxhWzVdLGFbNl0pO1xuICBjYXNlIDg6IHJldHVybiBmIChhWzFdLGFbMl0sYVszXSxhWzRdLGFbNV0sYVs2XSxhWzddKTtcbiAgfVxuICByZXR1cm4gZi5hcHBseShudWxsLCBjYW1sX2pzX2Zyb21fYXJyYXkoYSkpO1xufVxuLy9Qcm92aWRlczogY2FtbF9qc19tZXRoX2NhbGwgKG11dGFibGUsIGNvbnN0LCBzaGFsbG93KVxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheVxuZnVuY3Rpb24gY2FtbF9qc19tZXRoX2NhbGwobywgZiwgYXJncykge1xuICByZXR1cm4gb1tjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhmKV0uYXBwbHkobywgY2FtbF9qc19mcm9tX2FycmF5KGFyZ3MpKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfbmV3IChjb25zdCwgc2hhbGxvdylcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheVxuZnVuY3Rpb24gY2FtbF9qc19uZXcoYywgYSkge1xuICBzd2l0Y2ggKGEubGVuZ3RoKSB7XG4gIGNhc2UgMTogcmV0dXJuIG5ldyBjO1xuICBjYXNlIDI6IHJldHVybiBuZXcgYyAoYVsxXSk7XG4gIGNhc2UgMzogcmV0dXJuIG5ldyBjIChhWzFdLGFbMl0pO1xuICBjYXNlIDQ6IHJldHVybiBuZXcgYyAoYVsxXSxhWzJdLGFbM10pO1xuICBjYXNlIDU6IHJldHVybiBuZXcgYyAoYVsxXSxhWzJdLGFbM10sYVs0XSk7XG4gIGNhc2UgNjogcmV0dXJuIG5ldyBjIChhWzFdLGFbMl0sYVszXSxhWzRdLGFbNV0pO1xuICBjYXNlIDc6IHJldHVybiBuZXcgYyAoYVsxXSxhWzJdLGFbM10sYVs0XSxhWzVdLGFbNl0pO1xuICBjYXNlIDg6IHJldHVybiBuZXcgYyAoYVsxXSxhWzJdLGFbM10sYVs0XSxhWzVdLGFbNl0sYVs3XSk7XG4gIH1cbiAgZnVuY3Rpb24gRigpIHsgcmV0dXJuIGMuYXBwbHkodGhpcywgY2FtbF9qc19mcm9tX2FycmF5KGEpKTsgfVxuICBGLnByb3RvdHlwZSA9IGMucHJvdG90eXBlO1xuICByZXR1cm4gbmV3IEY7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX29qc19uZXdfYXJyIChjb25zdCwgc2hhbGxvdylcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheVxuZnVuY3Rpb24gY2FtbF9vanNfbmV3X2FycihjLCBhKSB7XG4gIHN3aXRjaCAoYS5sZW5ndGgpIHtcbiAgY2FzZSAwOiByZXR1cm4gbmV3IGM7XG4gIGNhc2UgMTogcmV0dXJuIG5ldyBjIChhWzBdKTtcbiAgY2FzZSAyOiByZXR1cm4gbmV3IGMgKGFbMF0sYVsxXSk7XG4gIGNhc2UgMzogcmV0dXJuIG5ldyBjIChhWzBdLGFbMV0sYVsyXSk7XG4gIGNhc2UgNDogcmV0dXJuIG5ldyBjIChhWzBdLGFbMV0sYVsyXSxhWzNdKTtcbiAgY2FzZSA1OiByZXR1cm4gbmV3IGMgKGFbMF0sYVsxXSxhWzJdLGFbM10sYVs0XSk7XG4gIGNhc2UgNjogcmV0dXJuIG5ldyBjIChhWzBdLGFbMV0sYVsyXSxhWzNdLGFbNF0sYVs1XSk7XG4gIGNhc2UgNzogcmV0dXJuIG5ldyBjIChhWzBdLGFbMV0sYVsyXSxhWzNdLGFbNF0sYVs1XSxhWzZdKTtcbiAgfVxuICBmdW5jdGlvbiBGKCkgeyByZXR1cm4gYy5hcHBseSh0aGlzLCBhKTsgfVxuICBGLnByb3RvdHlwZSA9IGMucHJvdG90eXBlO1xuICByZXR1cm4gbmV3IEY7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3dyYXBfY2FsbGJhY2sgY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jYWxsX2dlblxuZnVuY3Rpb24gY2FtbF9qc193cmFwX2NhbGxiYWNrKGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBpZihsZW4gPiAwKXtcbiAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGxlbik7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgICAgcmV0dXJuIGNhbWxfY2FsbF9nZW4oZiwgYXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjYW1sX2NhbGxfZ2VuKGYsIFt1bmRlZmluZWRdKTtcbiAgICB9XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9qc193cmFwX2NhbGxiYWNrX2FyZ3VtZW50c1xuLy9SZXF1aXJlczogY2FtbF9jYWxsX2dlblxuZnVuY3Rpb24gY2FtbF9qc193cmFwX2NhbGxiYWNrX2FyZ3VtZW50cyhmKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgcmV0dXJuIGNhbWxfY2FsbF9nZW4oZiwgW2FyZ3NdKTtcbiAgfVxufVxuLy9Qcm92aWRlczogY2FtbF9qc193cmFwX2NhbGxiYWNrX3N0cmljdCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9jYWxsX2dlblxuZnVuY3Rpb24gY2FtbF9qc193cmFwX2NhbGxiYWNrX3N0cmljdChhcml0eSwgZikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBpZihuID09IGFyaXR5ICYmIGYubGVuZ3RoID09IGFyaXR5KSByZXR1cm4gZi5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyaXR5KTtcbiAgICB2YXIgbGVuID0gTWF0aC5taW4oYXJndW1lbnRzLmxlbmd0aCwgYXJpdHkpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICByZXR1cm4gY2FtbF9jYWxsX2dlbihmLCBhcmdzKTtcbiAgfTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrIGNvbnN0IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY2FsbF9nZW5cbmZ1bmN0aW9uIGNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrKGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShsZW4gKyAxKTtcbiAgICBhcmdzWzBdID0gdGhpcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSBhcmdzW2krMV0gPSBhcmd1bWVudHNbaV07XG4gICAgcmV0dXJuIGNhbWxfY2FsbF9nZW4oZixhcmdzKTtcbiAgfVxufVxuLy9Qcm92aWRlczogY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2tfYXJndW1lbnRzIGNvbnN0IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY2FsbF9nZW5cbmZ1bmN0aW9uIGNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrX2FyZ3VtZW50cyhmKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkobGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIHJldHVybiBjYW1sX2NhbGxfZ2VuKGYsW3RoaXMsYXJnc10pO1xuICB9XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja19zdHJpY3QgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfY2FsbF9nZW5cbmZ1bmN0aW9uIGNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrX3N0cmljdChhcml0eSwgZikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyaXR5ICsgMSk7XG4gICAgdmFyIGxlbiA9IE1hdGgubWluKGFyZ3VtZW50cy5sZW5ndGgsIGFyaXR5KVxuICAgIGFyZ3NbMF0gPSB0aGlzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIGFyZ3NbaSsxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICByZXR1cm4gY2FtbF9jYWxsX2dlbihmLCBhcmdzKTtcbiAgfTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrX3Vuc2FmZSBjb25zdCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NhbGxfZ2VuXG5mdW5jdGlvbiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja191bnNhZmUoZikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGxlbiArIDEpO1xuICAgIGFyZ3NbMF0gPSB0aGlzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIGFyZ3NbaSsxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICByZXR1cm4gZi5hcHBseShudWxsLCBhcmdzKTsgfVxufVxuLy9Qcm92aWRlczogY2FtbF9qc19lcXVhbHMgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc19lcXVhbHMgKHgsIHkpIHsgcmV0dXJuICsoeCA9PSB5KTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2V2YWxfc3RyaW5nIChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2pzX2V2YWxfc3RyaW5nIChzKSB7cmV0dXJuIGV2YWwoY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocykpO31cblxuLy9Qcm92aWRlczogY2FtbF9qc19leHByIChjb25zdClcbi8vUmVxdWlyZXM6IGpzX3ByaW50X3N0ZGVyclxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfanNfZXhwcihzKSB7XG4gIGpzX3ByaW50X3N0ZGVycihcImNhbWxfanNfZXhwcjogZmFsbGJhY2sgdG8gcnVudGltZSBldmFsdWF0aW9uXFxuXCIpO1xuICByZXR1cm4gZXZhbChjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhzKSk7fVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3B1cmVfanNfZXhwciBjb25zdCAoY29uc3QpXG4vL1JlcXVpcmVzOiBqc19wcmludF9zdGRlcnJcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3B1cmVfanNfZXhwciAocyl7XG4gIGpzX3ByaW50X3N0ZGVycihcImNhbWxfcHVyZV9qc19leHByOiBmYWxsYmFjayB0byBydW50aW1lIGV2YWx1YXRpb25cXG5cIik7XG4gIHJldHVybiBldmFsKGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHMpKTt9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfb2JqZWN0IChvYmplY3RfbGl0ZXJhbClcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2pzX29iamVjdCAoYSkge1xuICB2YXIgbyA9IHt9O1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcCA9IGFbaV07XG4gICAgb1tjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhwWzFdKV0gPSBwWzJdO1xuICB9XG4gIHJldHVybiBvO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZXhwb3J0X3ZhclxuZnVuY3Rpb24gY2FtbF9qc19leHBvcnRfdmFyICgpe1xuICBpZih0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUgJiYgbW9kdWxlLmV4cG9ydHMpXG4gICAgcmV0dXJuIG1vZHVsZS5leHBvcnRzXG4gIGVsc2VcbiAgICByZXR1cm4gam9vX2dsb2JhbF9vYmplY3Q7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF94bWxodHRwcmVxdWVzdF9jcmVhdGVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbi8vV2Vha2RlZlxuZnVuY3Rpb24gY2FtbF94bWxodHRwcmVxdWVzdF9jcmVhdGUodW5pdCl7XG4gIHZhciBnID0gam9vX2dsb2JhbF9vYmplY3Q7XG4gIGlmKHR5cGVvZiBnLlhNTEh0dHBSZXF1ZXN0ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHRyeSB7IHJldHVybiBuZXcgZy5YTUxIdHRwUmVxdWVzdCB9IGNhdGNoIChlKSB7IH07XG4gIH1cbiAgaWYodHlwZW9mIGcuYWN0aXZlWE9iamVjdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0cnkgeyByZXR1cm4gbmV3IGcuYWN0aXZlWE9iamVjdChcIk1zeG1sMi5YTUxIVFRQXCIpIH0gY2F0Y2goZSl7IH07XG4gICAgdHJ5IHsgcmV0dXJuIG5ldyBnLmFjdGl2ZVhPYmplY3QoXCJNc3htbDMuWE1MSFRUUFwiKSB9IGNhdGNoKGUpeyB9O1xuICAgIHRyeSB7IHJldHVybiBuZXcgZy5hY3RpdmVYT2JqZWN0KFwiTWljcm9zb2Z0LlhNTEhUVFBcIikgfSBjYXRjaChlKXsgfTtcbiAgfVxuICBjYW1sX2ZhaWx3aXRoKFwiQ2Fubm90IGNyZWF0ZSBhIFhNTEh0dHBSZXF1ZXN0XCIpO1xufVxuIiwiLy9Qcm92aWRlczogdW5peF9nZXR0aW1lb2ZkYXlcbmZ1bmN0aW9uIHVuaXhfZ2V0dGltZW9mZGF5ICgpIHtcbiAgcmV0dXJuIChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkgLyAxMDAwO1xufVxuXG4vL1Byb3ZpZGVzOiB1bml4X3RpbWVcbi8vUmVxdWlyZXM6IHVuaXhfZ2V0dGltZW9mZGF5XG5mdW5jdGlvbiB1bml4X3RpbWUgKCkge1xuICByZXR1cm4gTWF0aC5mbG9vcih1bml4X2dldHRpbWVvZmRheSAoKSk7XG59XG5cbi8vUHJvdmlkZXM6IHVuaXhfZ210aW1lXG5mdW5jdGlvbiB1bml4X2dtdGltZSAodCkge1xuICB2YXIgZCA9IG5ldyBEYXRlICh0ICogMTAwMCk7XG4gIHZhciBkX251bSA9IGQuZ2V0VGltZSgpO1xuICB2YXIgamFudWFyeWZpcnN0ID0gKG5ldyBEYXRlKERhdGUuVVRDKGQuZ2V0VVRDRnVsbFllYXIoKSwgMCwgMSkpKS5nZXRUaW1lKCk7XG4gIHZhciBkb3kgPSBNYXRoLmZsb29yKChkX251bSAtIGphbnVhcnlmaXJzdCkgLyA4NjQwMDAwMCk7XG4gIHJldHVybiBCTE9DSygwLCBkLmdldFVUQ1NlY29uZHMoKSwgZC5nZXRVVENNaW51dGVzKCksIGQuZ2V0VVRDSG91cnMoKSxcbiAgICAgICAgICBkLmdldFVUQ0RhdGUoKSwgZC5nZXRVVENNb250aCgpLCBkLmdldFVUQ0Z1bGxZZWFyKCkgLSAxOTAwLFxuICAgICAgICAgIGQuZ2V0VVRDRGF5KCksIGRveSxcbiAgICAgICAgICBmYWxzZSB8IDAgLyogZm9yIFVUQyBkYXlsaWdodCBzYXZpbmdzIHRpbWUgaXMgZmFsc2UgKi8pXG59XG5cbi8vUHJvdmlkZXM6IHVuaXhfbG9jYWx0aW1lXG5mdW5jdGlvbiB1bml4X2xvY2FsdGltZSAodCkge1xuICB2YXIgZCA9IG5ldyBEYXRlICh0ICogMTAwMCk7XG4gIHZhciBkX251bSA9IGQuZ2V0VGltZSgpO1xuICB2YXIgamFudWFyeWZpcnN0ID0gKG5ldyBEYXRlKGQuZ2V0RnVsbFllYXIoKSwgMCwgMSkpLmdldFRpbWUoKTtcbiAgdmFyIGRveSA9IE1hdGguZmxvb3IoKGRfbnVtIC0gamFudWFyeWZpcnN0KSAvIDg2NDAwMDAwKTtcbiAgdmFyIGphbiA9IG5ldyBEYXRlKGQuZ2V0RnVsbFllYXIoKSwgMCwgMSk7XG4gIHZhciBqdWwgPSBuZXcgRGF0ZShkLmdldEZ1bGxZZWFyKCksIDYsIDEpO1xuICB2YXIgc3RkVGltZXpvbmVPZmZzZXQgPSBNYXRoLm1heChqYW4uZ2V0VGltZXpvbmVPZmZzZXQoKSwganVsLmdldFRpbWV6b25lT2Zmc2V0KCkpO1xuICByZXR1cm4gQkxPQ0soMCwgZC5nZXRTZWNvbmRzKCksIGQuZ2V0TWludXRlcygpLCBkLmdldEhvdXJzKCksXG4gICAgICAgICAgZC5nZXREYXRlKCksIGQuZ2V0TW9udGgoKSwgZC5nZXRGdWxsWWVhcigpIC0gMTkwMCxcbiAgICAgICAgICBkLmdldERheSgpLCBkb3ksXG4gICAgICAgICAgKGQuZ2V0VGltZXpvbmVPZmZzZXQoKSA8IHN0ZFRpbWV6b25lT2Zmc2V0KSB8IDAgLyogZGF5bGlnaHQgc2F2aW5ncyB0aW1lICBmaWVsZC4gKi8pXG59XG5cbi8vUHJvdmlkZXM6IHVuaXhfbWt0aW1lXG4vL1JlcXVpcmVzOiB1bml4X2xvY2FsdGltZVxuZnVuY3Rpb24gdW5peF9ta3RpbWUodG0pe1xuICB2YXIgZCA9IChuZXcgRGF0ZSh0bVs2XSsxOTAwLHRtWzVdLHRtWzRdLHRtWzNdLHRtWzJdLHRtWzFdKSkuZ2V0VGltZSgpO1xuICB2YXIgdCA9IE1hdGguZmxvb3IoZCAvIDEwMDApO1xuICB2YXIgdG0yID0gdW5peF9sb2NhbHRpbWUodCk7XG4gIHJldHVybiBCTE9DSygwLHQsdG0yKTtcbn1cblxuLy9Qcm92aWRlczogd2luX3N0YXJ0dXAgY29uc3RcbmZ1bmN0aW9uIHdpbl9zdGFydHVwKCkge31cblxuLy9Qcm92aWRlczogd2luX2NsZWFudXAgY29uc3RcbmZ1bmN0aW9uIHdpbl9jbGVhbnVwKCkge31cblxuLy9Qcm92aWRlczogd2luX2hhbmRsZV9mZCBjb25zdFxuZnVuY3Rpb24gd2luX2hhbmRsZV9mZCh4KSB7cmV0dXJuIHg7fVxuXG4vL1Byb3ZpZGVzOiB1bml4X2lzYXR0eSBcbi8vUmVxdWlyZXM6IGZzX25vZGVfc3VwcG9ydGVkXG5mdW5jdGlvbiB1bml4X2lzYXR0eShmaWxlRGVzY3JpcHRvcikge1xuICBpZihmc19ub2RlX3N1cHBvcnRlZCgpKSB7XG4gICAgdmFyIHR0eSA9IHJlcXVpcmUoJ3R0eScpO1xuICAgIHJldHVybiB0dHkuaXNhdHR5KGZpbGVEZXNjcmlwdG9yKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUHJvdmlkZXM6IGNhbWxfZm9ybWF0X2ludCBjb25zdCAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9wYXJzZV9mb3JtYXQsIGNhbWxfZmluaXNoX2Zvcm1hdHRpbmcsIGNhbWxfc3RyX3JlcGVhdFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlcywgY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9mb3JtYXRfaW50KGZtdCwgaSkge1xuICBpZiAoY2FtbF9qc2J5dGVzX29mX3N0cmluZyhmbXQpID09IFwiJWRcIikgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoXCJcIitpKTtcbiAgdmFyIGYgPSBjYW1sX3BhcnNlX2Zvcm1hdChmbXQpO1xuICBpZiAoaSA8IDApIHsgaWYgKGYuc2lnbmVkY29udikgeyBmLnNpZ24gPSAtMTsgaSA9IC1pOyB9IGVsc2UgaSA+Pj49IDA7IH1cbiAgdmFyIHMgPSBpLnRvU3RyaW5nKGYuYmFzZSk7XG4gIGlmIChmLnByZWMgPj0gMCkge1xuICAgIGYuZmlsbGVyID0gJyAnO1xuICAgIHZhciBuID0gZi5wcmVjIC0gcy5sZW5ndGg7XG4gICAgaWYgKG4gPiAwKSBzID0gY2FtbF9zdHJfcmVwZWF0IChuLCAnMCcpICsgcztcbiAgfVxuICByZXR1cm4gY2FtbF9maW5pc2hfZm9ybWF0dGluZyhmLCBzKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9wYXJzZV9zaWduX2FuZF9iYXNlXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0LCBjYW1sX21sX3N0cmluZ19sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfcGFyc2Vfc2lnbl9hbmRfYmFzZSAocykge1xuICB2YXIgaSA9IDAsIGxlbiA9IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSwgYmFzZSA9IDEwLCBzaWduID0gMTtcbiAgaWYgKGxlbiA+IDApIHtcbiAgICBzd2l0Y2ggKGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQocyxpKSkge1xuICAgIGNhc2UgNDU6IGkrKzsgc2lnbiA9IC0xOyBicmVhaztcbiAgICBjYXNlIDQzOiBpKys7IHNpZ24gPSAxOyBicmVhaztcbiAgICB9XG4gIH1cbiAgaWYgKGkgKyAxIDwgbGVuICYmIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQocywgaSkgPT0gNDgpXG4gICAgc3dpdGNoIChjYW1sX3N0cmluZ191bnNhZmVfZ2V0KHMsIGkgKyAxKSkge1xuICAgIGNhc2UgMTIwOiBjYXNlIDg4OiBiYXNlID0gMTY7IGkgKz0gMjsgYnJlYWs7XG4gICAgY2FzZSAxMTE6IGNhc2UgNzk6IGJhc2UgPSAgODsgaSArPSAyOyBicmVhaztcbiAgICBjYXNlICA5ODogY2FzZSA2NjogYmFzZSA9ICAyOyBpICs9IDI7IGJyZWFrO1xuICAgIGNhc2UgMTE3OiBjYXNlIDg1OiBpICs9IDI7IGJyZWFrO1xuICAgIH1cbiAgcmV0dXJuIFtpLCBzaWduLCBiYXNlXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9wYXJzZV9kaWdpdFxuZnVuY3Rpb24gY2FtbF9wYXJzZV9kaWdpdChjKSB7XG4gIGlmIChjID49IDQ4ICYmIGMgPD0gNTcpICByZXR1cm4gYyAtIDQ4O1xuICBpZiAoYyA+PSA2NSAmJiBjIDw9IDkwKSAgcmV0dXJuIGMgLSA1NTtcbiAgaWYgKGMgPj0gOTcgJiYgYyA8PSAxMjIpIHJldHVybiBjIC0gODc7XG4gIHJldHVybiAtMTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnRfb2Zfc3RyaW5nIChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aCwgY2FtbF9zdHJpbmdfdW5zYWZlX2dldFxuLy9SZXF1aXJlczogY2FtbF9wYXJzZV9zaWduX2FuZF9iYXNlLCBjYW1sX3BhcnNlX2RpZ2l0LCBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2ludF9vZl9zdHJpbmcgKHMpIHtcbiAgdmFyIHIgPSBjYW1sX3BhcnNlX3NpZ25fYW5kX2Jhc2UgKHMpO1xuICB2YXIgaSA9IHJbMF0sIHNpZ24gPSByWzFdLCBiYXNlID0gclsyXTtcbiAgdmFyIGxlbiA9IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKTtcbiAgdmFyIHRocmVzaG9sZCA9IC0xID4+PiAwO1xuICB2YXIgYyA9IChpIDwgbGVuKT9jYW1sX3N0cmluZ191bnNhZmVfZ2V0KHMsIGkpOjA7XG4gIHZhciBkID0gY2FtbF9wYXJzZV9kaWdpdChjKTtcbiAgaWYgKGQgPCAwIHx8IGQgPj0gYmFzZSkgY2FtbF9mYWlsd2l0aChcImludF9vZl9zdHJpbmdcIik7XG4gIHZhciByZXMgPSBkO1xuICBmb3IgKGkrKztpPGxlbjtpKyspIHtcbiAgICBjID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldChzLCBpKTtcbiAgICBpZiAoYyA9PSA5NSkgY29udGludWU7XG4gICAgZCA9IGNhbWxfcGFyc2VfZGlnaXQoYyk7XG4gICAgaWYgKGQgPCAwIHx8IGQgPj0gYmFzZSkgYnJlYWs7XG4gICAgcmVzID0gYmFzZSAqIHJlcyArIGQ7XG4gICAgaWYgKHJlcyA+IHRocmVzaG9sZCkgY2FtbF9mYWlsd2l0aChcImludF9vZl9zdHJpbmdcIik7XG4gIH1cbiAgaWYgKGkgIT0gbGVuKSBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgLy8gRm9yIGJhc2UgZGlmZmVyZW50IGZyb20gMTAsIHdlIGV4cGVjdCBhbiB1bnNpZ25lZCByZXByZXNlbnRhdGlvbixcbiAgLy8gaGVuY2UgYW55IHZhbHVlIG9mICdyZXMnIChsZXNzIHRoYW4gJ3RocmVzaG9sZCcpIGlzIGFjY2VwdGFibGUuXG4gIC8vIEJ1dCB3ZSBoYXZlIHRvIGNvbnZlcnQgdGhlIHJlc3VsdCBiYWNrIHRvIGEgc2lnbmVkIGludGVnZXIuXG4gIHJlcyA9IHNpZ24gKiByZXM7XG4gIGlmICgoYmFzZSA9PSAxMCkgJiYgKChyZXMgfCAwKSAhPSByZXMpKVxuICAgIC8qIFNpZ25lZCByZXByZXNlbnRhdGlvbiBleHBlY3RlZCwgYWxsb3cgLTJeKG5iaXRzLTEpIHRvIDJeKG5iaXRzLTEpIC0gMSAqL1xuICAgIGNhbWxfZmFpbHdpdGgoXCJpbnRfb2Zfc3RyaW5nXCIpO1xuICByZXR1cm4gcmVzIHwgMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tdWwgY29uc3RcbmZ1bmN0aW9uIGNhbWxfbXVsKGEsYil7XG4gIHJldHVybiBNYXRoLmltdWwoYSxiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9kaXZcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2VfemVyb19kaXZpZGVcbmZ1bmN0aW9uIGNhbWxfZGl2KHgseSkge1xuICBpZiAoeSA9PSAwKSBjYW1sX3JhaXNlX3plcm9fZGl2aWRlICgpO1xuICByZXR1cm4gKHgveSl8MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tb2Rcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2VfemVyb19kaXZpZGVcbmZ1bmN0aW9uIGNhbWxfbW9kKHgseSkge1xuICBpZiAoeSA9PSAwKSBjYW1sX3JhaXNlX3plcm9fZGl2aWRlICgpO1xuICByZXR1cm4geCV5O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2Jzd2FwMTZcbmZ1bmN0aW9uIGNhbWxfYnN3YXAxNih4KSB7XG4gIHJldHVybiAoKCgoeCAmIDB4MDBGRikgPDwgOCkgfFxuICAgICAgICAgICAoKHggJiAweEZGMDApID4+IDgpKSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2ludDMyX2Jzd2FwXG5mdW5jdGlvbiBjYW1sX2ludDMyX2Jzd2FwKHgpIHtcbiAgcmV0dXJuICgoKHggJiAweDAwMDAwMEZGKSA8PCAyNCkgfFxuICAgICAgICAgICgoeCAmIDB4MDAwMEZGMDApIDw8IDgpIHxcbiAgICAgICAgICAoKHggJiAweDAwRkYwMDAwKSA+Pj4gOCkgfFxuICAgICAgICAgICgoeCAmIDB4RkYwMDAwMDApID4+PiAyNCkpO1xufVxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9ic3dhcFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF90b19ieXRlcywgY2FtbF9pbnQ2NF9vZl9ieXRlc1xuZnVuY3Rpb24gY2FtbF9pbnQ2NF9ic3dhcCh4KSB7XG4gIHZhciB5ID0gY2FtbF9pbnQ2NF90b19ieXRlcyh4KTtcbiAgcmV0dXJuIGNhbWxfaW50NjRfb2ZfYnl0ZXMoW3lbN10sIHlbNl0sIHlbNV0sIHlbNF0sIHlbM10sIHlbMl0sIHlbMV0sIHlbMF1dKTtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vLy8vLy8vLy8vLy8gSGFzaHRibFxuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfdW5pdl9wYXJhbSBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2lzX21sX3N0cmluZywgY2FtbF9pc19tbF9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF90b19ieXRlcywgY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0LCBjYW1sX2N1c3RvbV9vcHNcbi8vUmVxdWlyZXM6IGNhbWxfbWxfYnl0ZXNfbGVuZ3RoLCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2hhc2hfdW5pdl9wYXJhbSAoY291bnQsIGxpbWl0LCBvYmopIHtcbiAgdmFyIGhhc2hfYWNjdSA9IDA7XG4gIGZ1bmN0aW9uIGhhc2hfYXV4IChvYmopIHtcbiAgICBsaW1pdCAtLTtcbiAgICBpZiAoY291bnQgPCAwIHx8IGxpbWl0IDwgMCkgcmV0dXJuO1xuICAgIGlmIChvYmogaW5zdGFuY2VvZiBBcnJheSAmJiBvYmpbMF0gPT09IChvYmpbMF18MCkpIHtcbiAgICAgIHN3aXRjaCAob2JqWzBdKSB7XG4gICAgICBjYXNlIDI0ODpcbiAgICAgICAgLy8gT2JqZWN0XG4gICAgICAgIGNvdW50IC0tO1xuICAgICAgICBoYXNoX2FjY3UgPSAoaGFzaF9hY2N1ICogNjU1OTkgKyBvYmpbMl0pIHwgMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI1MDpcbiAgICAgICAgLy8gRm9yd2FyZFxuICAgICAgICBsaW1pdCsrOyBoYXNoX2F1eChvYmopOyBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGNvdW50IC0tO1xuICAgICAgICBoYXNoX2FjY3UgPSAoaGFzaF9hY2N1ICogMTkgKyBvYmpbMF0pIHwgMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IG9iai5sZW5ndGggLSAxOyBpID4gMDsgaS0tKSBoYXNoX2F1eCAob2JqW2ldKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNhbWxfaXNfbWxfYnl0ZXMob2JqKSkge1xuICAgICAgY291bnQgLS07XG4gICAgICBzd2l0Y2ggKG9iai50ICYgNikge1xuICAgICAgZGVmYXVsdDogLyogUEFSVElBTCAqL1xuICAgICAgICBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKG9iaik7XG4gICAgICBjYXNlIDA6IC8qIEJZVEVTICovXG4gICAgICAgIGZvciAodmFyIGIgPSBvYmouYywgbCA9IGNhbWxfbWxfYnl0ZXNfbGVuZ3RoKG9iaiksIGkgPSAwOyBpIDwgbDsgaSsrKVxuICAgICAgICAgIGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiAxOSArIGIuY2hhckNvZGVBdChpKSkgfCAwO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjogLyogQVJSQVkgKi9cbiAgICAgICAgZm9yICh2YXIgYSA9IG9iai5jLCBsID0gY2FtbF9tbF9ieXRlc19sZW5ndGgob2JqKSwgaSA9IDA7IGkgPCBsOyBpKyspXG4gICAgICAgICAgaGFzaF9hY2N1ID0gKGhhc2hfYWNjdSAqIDE5ICsgYVtpXSkgfCAwO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2FtbF9pc19tbF9zdHJpbmcob2JqKSkge1xuICAgICAgICB2YXIganNieXRlcyA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcob2JqKTtcbiAgICAgICAgZm9yICh2YXIgYiA9IGpzYnl0ZXMsIGwgPSBqc2J5dGVzLmxlbmd0aCwgaSA9IDA7IGkgPCBsOyBpKyspXG4gICAgICAgICAgaGFzaF9hY2N1ID0gKGhhc2hfYWNjdSAqIDE5ICsgYi5jaGFyQ29kZUF0KGkpKSB8IDA7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGZvciAodmFyIGIgPSBvYmosIGwgPSBvYmoubGVuZ3RoLCBpID0gMDsgaSA8IGw7IGkrKylcbiAgICAgICAgICBoYXNoX2FjY3UgPSAoaGFzaF9hY2N1ICogMTkgKyBiLmNoYXJDb2RlQXQoaSkpIHwgMDtcbiAgICB9IGVsc2UgaWYgKG9iaiA9PT0gKG9ianwwKSkge1xuICAgICAgLy8gSW50ZWdlclxuICAgICAgY291bnQgLS07XG4gICAgICBoYXNoX2FjY3UgPSAoaGFzaF9hY2N1ICogNjU1OTkgKyBvYmopIHwgMDtcbiAgICB9IGVsc2UgaWYgKG9iaiA9PT0gK29iaikge1xuICAgICAgLy8gRmxvYXRcbiAgICAgIGNvdW50LS07XG4gICAgICB2YXIgcCA9IGNhbWxfaW50NjRfdG9fYnl0ZXMgKGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCAob2JqKSk7XG4gICAgICBmb3IgKHZhciBpID0gNzsgaSA+PSAwOyBpLS0pIGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiAxOSArIHBbaV0pIHwgMDtcbiAgICB9IGVsc2UgaWYob2JqICYmIG9iai5jYW1sX2N1c3RvbSkge1xuICAgICAgaWYoY2FtbF9jdXN0b21fb3BzW29iai5jYW1sX2N1c3RvbV0gJiYgY2FtbF9jdXN0b21fb3BzW29iai5jYW1sX2N1c3RvbV0uaGFzaCkge1xuICAgICAgICB2YXIgaCA9IGNhbWxfY3VzdG9tX29wc1tvYmouY2FtbF9jdXN0b21dLmhhc2gob2JqKSB8IDA7XG4gICAgICAgIGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiA2NTU5OSArIGgpIHwgMDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaGFzaF9hdXggKG9iaik7XG4gIHJldHVybiBoYXNoX2FjY3UgJiAweDNGRkZGRkZGO1xufVxuXG4vL2Z1bmN0aW9uIFJPVEwzMih4LG4pIHsgcmV0dXJuICgoeCA8PCBuKSB8ICh4ID4+PiAoMzItbikpKTsgfVxuLy9Qcm92aWRlczogY2FtbF9oYXNoX21peF9pbnRcbi8vUmVxdWlyZXM6IGNhbWxfbXVsXG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X2ludChoLGQpIHtcbiAgZCA9IGNhbWxfbXVsKGQsIDB4Y2M5ZTJkNTF8MCk7XG4gIGQgPSAoKGQgPDwgMTUpIHwgKGQgPj4+ICgzMi0xNSkpKTsgLy8gUk9UTDMyKGQsIDE1KTtcbiAgZCA9IGNhbWxfbXVsKGQsIDB4MWI4NzM1OTMpO1xuICBoIF49IGQ7XG4gIGggPSAoKGggPDwgMTMpIHwgKGggPj4+ICgzMi0xMykpKTsgICAvL1JPVEwzMihoLCAxMyk7XG4gIHJldHVybiAoKChoICsgKGggPDwgMikpfDApICsgKDB4ZTY1NDZiNjR8MCkpfDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfZmluYWxcbi8vUmVxdWlyZXM6IGNhbWxfbXVsXG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X2ZpbmFsKGgpIHtcbiAgaCBePSBoID4+PiAxNjtcbiAgaCA9IGNhbWxfbXVsIChoLCAweDg1ZWJjYTZifDApO1xuICBoIF49IGggPj4+IDEzO1xuICBoID0gY2FtbF9tdWwgKGgsIDB4YzJiMmFlMzV8MCk7XG4gIGggXj0gaCA+Pj4gMTY7XG4gIHJldHVybiBoO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbWl4X2Zsb2F0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQsIGNhbWxfaGFzaF9taXhfaW50NjRcbmZ1bmN0aW9uIGNhbWxfaGFzaF9taXhfZmxvYXQgKGgsIHYwKSB7XG4gIHJldHVybiBjYW1sX2hhc2hfbWl4X2ludDY0KGgsIGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCAodjApKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfaW50NjRcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfaW50XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2xvMzIsIGNhbWxfaW50NjRfaGkzMlxuZnVuY3Rpb24gY2FtbF9oYXNoX21peF9pbnQ2NCAoaCwgdikge1xuICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgY2FtbF9pbnQ2NF9sbzMyKHYpKTtcbiAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIGNhbWxfaW50NjRfaGkzMih2KSk7XG4gIHJldHVybiBoO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbWl4X2pzYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfaW50XG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X2pzYnl0ZXMoaCwgcykge1xuICB2YXIgbGVuID0gcy5sZW5ndGgsIGksIHc7XG4gIGZvciAoaSA9IDA7IGkgKyA0IDw9IGxlbjsgaSArPSA0KSB7XG4gICAgdyA9IHMuY2hhckNvZGVBdChpKVxuICAgICAgfCAocy5jaGFyQ29kZUF0KGkrMSkgPDwgOClcbiAgICAgIHwgKHMuY2hhckNvZGVBdChpKzIpIDw8IDE2KVxuICAgICAgfCAocy5jaGFyQ29kZUF0KGkrMykgPDwgMjQpO1xuICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCB3KTtcbiAgfVxuICB3ID0gMDtcbiAgc3dpdGNoIChsZW4gJiAzKSB7XG4gIGNhc2UgMzogdyAgPSBzLmNoYXJDb2RlQXQoaSsyKSA8PCAxNjtcbiAgY2FzZSAyOiB3IHw9IHMuY2hhckNvZGVBdChpKzEpIDw8IDg7XG4gIGNhc2UgMTpcbiAgICB3IHw9IHMuY2hhckNvZGVBdChpKTtcbiAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgdyk7XG4gIGRlZmF1bHQ6XG4gIH1cbiAgaCBePSBsZW47XG4gIHJldHVybiBoO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbWl4X2J5dGVzX2FyclxuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9pbnRcbmZ1bmN0aW9uIGNhbWxfaGFzaF9taXhfYnl0ZXNfYXJyKGgsIHMpIHtcbiAgdmFyIGxlbiA9IHMubGVuZ3RoLCBpLCB3O1xuICBmb3IgKGkgPSAwOyBpICsgNCA8PSBsZW47IGkgKz0gNCkge1xuICAgIHcgPSBzW2ldXG4gICAgICB8IChzW2krMV0gPDwgOClcbiAgICAgIHwgKHNbaSsyXSA8PCAxNilcbiAgICAgIHwgKHNbaSszXSA8PCAyNCk7XG4gICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHcpO1xuICB9XG4gIHcgPSAwO1xuICBzd2l0Y2ggKGxlbiAmIDMpIHtcbiAgY2FzZSAzOiB3ICA9IHNbaSsyXSA8PCAxNjtcbiAgY2FzZSAyOiB3IHw9IHNbaSsxXSA8PCA4O1xuICBjYXNlIDE6IHcgfD0gc1tpXTtcbiAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgdyk7XG4gIGRlZmF1bHQ6XG4gIH1cbiAgaCBePSBsZW47XG4gIHJldHVybiBoO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbWl4X2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2pzYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfYnl0ZXNfYXJyXG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X2J5dGVzKGgsIHYpIHtcbiAgc3dpdGNoICh2LnQgJiA2KSB7XG4gIGRlZmF1bHQ6XG4gICAgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyAodik7XG4gIGNhc2UgMDogLyogQllURVMgKi9cbiAgICBoID0gY2FtbF9oYXNoX21peF9qc2J5dGVzKGgsIHYuYyk7XG4gICAgYnJlYWs7XG4gIGNhc2UgMjogLyogQVJSQVkgKi9cbiAgICBoID0gY2FtbF9oYXNoX21peF9ieXRlc19hcnIoaCwgdi5jKTtcbiAgfVxuICByZXR1cm4gaFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbWl4X3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9qc2J5dGVzLCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X3N0cmluZyhoLCB2KSB7XG4gIHJldHVybiBjYW1sX2hhc2hfbWl4X2pzYnl0ZXMoaCwgY2FtbF9qc2J5dGVzX29mX3N0cmluZyh2KSk7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9oYXNoIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfaXNfbWxfc3RyaW5nLCBjYW1sX2lzX21sX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2ludCwgY2FtbF9oYXNoX21peF9maW5hbFxuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9mbG9hdCwgY2FtbF9oYXNoX21peF9zdHJpbmcsIGNhbWxfaGFzaF9taXhfYnl0ZXMsIGNhbWxfY3VzdG9tX29wc1xuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX2hhc2ggKGNvdW50LCBsaW1pdCwgc2VlZCwgb2JqKSB7XG4gIHZhciBxdWV1ZSwgcmQsIHdyLCBzeiwgbnVtLCBoLCB2LCBpLCBsZW47XG4gIHN6ID0gbGltaXQ7XG4gIGlmIChzeiA8IDAgfHwgc3ogPiAyNTYpIHN6ID0gMjU2O1xuICBudW0gPSBjb3VudDtcbiAgaCA9IHNlZWQ7XG4gIHF1ZXVlID0gW29ial07IHJkID0gMDsgd3IgPSAxO1xuICB3aGlsZSAocmQgPCB3ciAmJiBudW0gPiAwKSB7XG4gICAgdiA9IHF1ZXVlW3JkKytdO1xuICAgIGlmICh2ICYmIHYuY2FtbF9jdXN0b20pe1xuICAgICAgaWYoY2FtbF9jdXN0b21fb3BzW3YuY2FtbF9jdXN0b21dICYmIGNhbWxfY3VzdG9tX29wc1t2LmNhbWxfY3VzdG9tXS5oYXNoKSB7XG4gICAgICAgIHZhciBoaCA9IGNhbWxfY3VzdG9tX29wc1t2LmNhbWxfY3VzdG9tXS5oYXNoKHYpO1xuICAgICAgICBoID0gY2FtbF9oYXNoX21peF9pbnQgKGgsIGhoKTtcbiAgICAgICAgbnVtIC0tO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh2IGluc3RhbmNlb2YgQXJyYXkgJiYgdlswXSA9PT0gKHZbMF18MCkpIHtcbiAgICAgIHN3aXRjaCAodlswXSkge1xuICAgICAgY2FzZSAyNDg6XG4gICAgICAgIC8vIE9iamVjdFxuICAgICAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgdlsyXSk7XG4gICAgICAgIG51bS0tO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjUwOlxuICAgICAgICAvLyBGb3J3YXJkXG4gICAgICAgIHF1ZXVlWy0tcmRdID0gdlsxXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB2YXIgdGFnID0gKCh2Lmxlbmd0aCAtIDEpIDw8IDEwKSB8IHZbMF07XG4gICAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCB0YWcpO1xuICAgICAgICBmb3IgKGkgPSAxLCBsZW4gPSB2Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgaWYgKHdyID49IHN6KSBicmVhaztcbiAgICAgICAgICBxdWV1ZVt3cisrXSA9IHZbaV07XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjYW1sX2lzX21sX2J5dGVzKHYpKSB7XG4gICAgICBoID0gY2FtbF9oYXNoX21peF9ieXRlcyhoLHYpXG4gICAgICBudW0tLTtcbiAgICB9IGVsc2UgaWYgKGNhbWxfaXNfbWxfc3RyaW5nKHYpKSB7XG4gICAgICBoID0gY2FtbF9oYXNoX21peF9zdHJpbmcoaCx2KVxuICAgICAgbnVtLS07XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgaCA9IGNhbWxfaGFzaF9taXhfanNieXRlcyhoLHYpXG4gICAgICBudW0tLTtcbiAgICB9IGVsc2UgaWYgKHYgPT09ICh2fDApKSB7XG4gICAgICAvLyBJbnRlZ2VyXG4gICAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgdit2KzEpO1xuICAgICAgbnVtLS07XG4gICAgfSBlbHNlIGlmICh2ID09PSArdikge1xuICAgICAgLy8gRmxvYXRcbiAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2Zsb2F0KGgsdik7XG4gICAgICBudW0tLTtcbiAgICB9XG4gIH1cbiAgaCA9IGNhbWxfaGFzaF9taXhfZmluYWwoaCk7XG4gIHJldHVybiBoICYgMHgzRkZGRkZGRjtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUHJvdmlkZXM6IGNhbWxfY29tcGFyZV92YWxfdGFnXG4vL1JlcXVpcmVzOiBjYW1sX2lzX21sX3N0cmluZywgY2FtbF9pc19tbF9ieXRlc1xuZnVuY3Rpb24gY2FtbF9jb21wYXJlX3ZhbF90YWcoYSl7XG4gIGlmICh0eXBlb2YgYSA9PT0gXCJudW1iZXJcIikgcmV0dXJuIDEwMDA7IC8vIGludF90YWcgKHdlIHVzZSBpdCBmb3IgYWxsIG51bWJlcnMpXG4gIGVsc2UgaWYgKGNhbWxfaXNfbWxfYnl0ZXMoYSkpIHJldHVybiAyNTI7IC8vIHN0cmluZ190YWdcbiAgZWxzZSBpZiAoY2FtbF9pc19tbF9zdHJpbmcoYSkpIHJldHVybiAxMjUyOyAvLyBvY2FtbCBzdHJpbmcgKGlmIGRpZmZlcmVudCBmcm9tIGJ5dGVzKVxuICBlbHNlIGlmIChhIGluc3RhbmNlb2YgQXJyYXkgJiYgYVswXSA9PT0gKGFbMF0+Pj4wKSAmJiBhWzBdIDw9IDI1NSkge1xuICAgIC8vIExvb2sgbGlrZSBhbiBvY2FtbCBibG9ja1xuICAgIHZhciB0YWcgPSBhWzBdIHwgMDtcbiAgICAvLyBpZ25vcmUgZG91YmxlX2FycmF5X3RhZyBiZWNhdXNlIHdlIGNhbm5vdCBhY2N1cmF0ZWx5IHNldFxuICAgIC8vIHRoaXMgdGFnIHdoZW4gd2UgY3JlYXRlIGFuIGFycmF5IG9mIGZsb2F0LlxuICAgIHJldHVybiAodGFnID09IDI1NCk/MDp0YWdcbiAgfVxuICBlbHNlIGlmIChhIGluc3RhbmNlb2YgU3RyaW5nKSByZXR1cm4gMTI1MjA7IC8vIGphdmFzY3JpcHQgc3RyaW5nLCBsaWtlIHN0cmluZ190YWcgKDI1MilcbiAgZWxzZSBpZiAodHlwZW9mIGEgPT0gXCJzdHJpbmdcIikgcmV0dXJuIDEyNTIwOyAvLyBqYXZhc2NyaXB0IHN0cmluZywgbGlrZSBzdHJpbmdfdGFnICgyNTIpXG4gIGVsc2UgaWYgKGEgaW5zdGFuY2VvZiBOdW1iZXIpIHJldHVybiAxMDAwOyAvLyBpbnRfdGFnICh3ZSB1c2UgaXQgZm9yIGFsbCBudW1iZXJzKVxuICBlbHNlIGlmIChhICYmIGEuY2FtbF9jdXN0b20pIHJldHVybiAxMjU1OyAvLyBsaWtlIGN1c3RvbV90YWcgKDI1NSlcbiAgZWxzZSBpZiAoYSAmJiBhLmNvbXBhcmUpIHJldHVybiAxMjU2OyAvLyBsaWtlIGN1c3RvbV90YWcgKDI1NSlcbiAgZWxzZSBpZiAodHlwZW9mIGEgPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gMTI0NzsgLy8gbGlrZSBjbG9zdXJlX3RhZyAoMjQ3KVxuICBlbHNlIGlmICh0eXBlb2YgYSA9PSBcInN5bWJvbFwiKSByZXR1cm4gMTI1MTtcbiAgcmV0dXJuIDEwMDE7IC8vb3V0X29mX2hlYXBfdGFnXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY29tcGFyZV92YWxfZ2V0X2N1c3RvbVxuLy9SZXF1aXJlczogY2FtbF9jdXN0b21fb3BzXG5mdW5jdGlvbiBjYW1sX2NvbXBhcmVfdmFsX2dldF9jdXN0b20oYSl7XG4gIHJldHVybiBjYW1sX2N1c3RvbV9vcHNbYS5jYW1sX2N1c3RvbV0gJiYgY2FtbF9jdXN0b21fb3BzW2EuY2FtbF9jdXN0b21dLmNvbXBhcmU7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY29tcGFyZV92YWxfbnVtYmVyX2N1c3RvbVxuLy9SZXF1aXJlczogY2FtbF9jb21wYXJlX3ZhbF9nZXRfY3VzdG9tXG5mdW5jdGlvbiBjYW1sX2NvbXBhcmVfdmFsX251bWJlcl9jdXN0b20obnVtLCBjdXN0b20sIHN3YXAsIHRvdGFsKSB7XG4gIHZhciBjb21wID0gY2FtbF9jb21wYXJlX3ZhbF9nZXRfY3VzdG9tKGN1c3RvbSk7XG4gIGlmKGNvbXApIHtcbiAgICB2YXIgeCA9IChzd2FwID4gMCk/Y29tcChjdXN0b20sbnVtLHRvdGFsKTpjb21wKG51bSxjdXN0b20sdG90YWwpO1xuICAgIGlmKHRvdGFsICYmIHggIT0geCkgcmV0dXJuIHN3YXA7IC8vIHRvdGFsICYmIG5hblxuICAgIGlmKCt4ICE9ICt4KSByZXR1cm4gK3g7IC8vIG5hblxuICAgIGlmKCh4IHwgMCkgIT0gMCkgcmV0dXJuICh4IHwgMCk7IC8vICFuYW5cbiAgfVxuICByZXR1cm4gc3dhcFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvbXBhcmVfdmFsIChjb25zdCwgY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9pbnRfY29tcGFyZSwgY2FtbF9zdHJpbmdfY29tcGFyZSwgY2FtbF9ieXRlc19jb21wYXJlXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfY29tcGFyZV92YWxfZ2V0X2N1c3RvbSwgY2FtbF9jb21wYXJlX3ZhbF90YWdcbi8vUmVxdWlyZXM6IGNhbWxfY29tcGFyZV92YWxfbnVtYmVyX2N1c3RvbVxuLy9SZXF1aXJlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9jb21wYXJlX3ZhbCAoYSwgYiwgdG90YWwpIHtcbiAgdmFyIHN0YWNrID0gW107XG4gIGZvcig7Oykge1xuICAgIGlmICghKHRvdGFsICYmIGEgPT09IGIpKSB7XG4gICAgICB2YXIgdGFnX2EgPSBjYW1sX2NvbXBhcmVfdmFsX3RhZyhhKTtcbiAgICAgIC8vIGZvcndhcmRfdGFnID9cbiAgICAgIGlmKHRhZ19hID09IDI1MCkgeyBhID0gYVsxXTsgY29udGludWUgfVxuXG4gICAgICB2YXIgdGFnX2IgPSBjYW1sX2NvbXBhcmVfdmFsX3RhZyhiKTtcbiAgICAgIC8vIGZvcndhcmRfdGFnID9cbiAgICAgIGlmKHRhZ19iID09IDI1MCkgeyBiID0gYlsxXTsgY29udGludWUgfVxuXG4gICAgICAvLyB0YWdzIGFyZSBkaWZmZXJlbnRcbiAgICAgIGlmKHRhZ19hICE9PSB0YWdfYikge1xuICAgICAgICBpZih0YWdfYSA9PSAxMDAwKSB7XG4gICAgICAgICAgaWYodGFnX2IgPT0gMTI1NSkgeyAvL2ltbWVkaWF0ZSBjYW4gY29tcGFyZSBhZ2FpbnN0IGN1c3RvbVxuICAgICAgICAgICAgcmV0dXJuIGNhbWxfY29tcGFyZV92YWxfbnVtYmVyX2N1c3RvbShhLCBiLCAtMSwgdG90YWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gLTFcbiAgICAgICAgfVxuICAgICAgICBpZih0YWdfYiA9PSAxMDAwKSB7XG4gICAgICAgICAgaWYodGFnX2EgPT0gMTI1NSkgeyAvL2ltbWVkaWF0ZSBjYW4gY29tcGFyZSBhZ2FpbnN0IGN1c3RvbVxuICAgICAgICAgICAgcmV0dXJuIGNhbWxfY29tcGFyZV92YWxfbnVtYmVyX2N1c3RvbShiLCBhLCAxLCB0b3RhbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAxXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICh0YWdfYSA8IHRhZ19iKT8tMToxO1xuICAgICAgfVxuICAgICAgc3dpdGNoKHRhZ19hKXtcbiAgICAgICAgLy8gMjQ2OiBMYXp5X3RhZyBoYW5kbGVkIGJlbGxvd1xuICAgICAgY2FzZSAyNDc6IC8vIENsb3N1cmVfdGFnXG4gICAgICAgIC8vIENhbm5vdCBoYXBwZW5cbiAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY29tcGFyZTogZnVuY3Rpb25hbCB2YWx1ZVwiKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgMjQ4OiAvLyBPYmplY3RcbiAgICAgICAgdmFyIHggPSBjYW1sX2ludF9jb21wYXJlKGFbMl0sIGJbMl0pO1xuICAgICAgICBpZiAoeCAhPSAwKSByZXR1cm4gKHggfCAwKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI0OTogLy8gSW5maXhcbiAgICAgICAgLy8gQ2Fubm90IGhhcHBlblxuICAgICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJjb21wYXJlOiBmdW5jdGlvbmFsIHZhbHVlXCIpO1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSAyNTA6IC8vIEZvcndhcmQgdGFnXG4gICAgICAgIC8vIENhbm5vdCBoYXBwZW4sIGhhbmRsZWQgYWJvdmVcbiAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiZXF1YWw6IGdvdCBGb3J3YXJkX3RhZywgc2hvdWxkIG5vdCBoYXBwZW5cIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNTE6IC8vQWJzdHJhY3RcbiAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiZXF1YWw6IGFic3RyYWN0IHZhbHVlXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjUyOiAvLyBPQ2FtbCBieXRlc1xuICAgICAgICBpZiAoYSAhPT0gYikge1xuICAgICAgICAgIHZhciB4ID0gY2FtbF9ieXRlc19jb21wYXJlKGEsIGIpO1xuICAgICAgICAgIGlmICh4ICE9IDApIHJldHVybiAoeCB8IDApO1xuICAgICAgICB9O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjUzOiAvLyBEb3VibGVfdGFnXG4gICAgICAgIC8vIENhbm5vdCBoYXBwZW5cbiAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiZXF1YWw6IGdvdCBEb3VibGVfdGFnLCBzaG91bGQgbm90IGhhcHBlblwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI1NDogLy8gRG91YmxlX2FycmF5X3RhZ1xuICAgICAgICAvLyBDYW5ub3QgaGFwcGVuLCBoYW5kbGVkIGFib3ZlXG4gICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImVxdWFsOiBnb3QgRG91YmxlX2FycmF5X3RhZywgc2hvdWxkIG5vdCBoYXBwZW5cIik7XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIDI1NTogLy8gQ3VzdG9tX3RhZ1xuICAgICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJlcXVhbDogZ290IEN1c3RvbV90YWcsIHNob3VsZCBub3QgaGFwcGVuXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTI0NzogLy8gRnVuY3Rpb25cbiAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY29tcGFyZTogZnVuY3Rpb25hbCB2YWx1ZVwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEyNTU6IC8vIEN1c3RvbVxuICAgICAgICB2YXIgY29tcCA9IGNhbWxfY29tcGFyZV92YWxfZ2V0X2N1c3RvbShhKTtcbiAgICAgICAgaWYoY29tcCAhPSBjYW1sX2NvbXBhcmVfdmFsX2dldF9jdXN0b20oYikpe1xuICAgICAgICAgIHJldHVybiAoYS5jYW1sX2N1c3RvbTxiLmNhbWxfY3VzdG9tKT8tMToxO1xuICAgICAgICB9XG4gICAgICAgIGlmKCFjb21wKVxuICAgICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNvbXBhcmU6IGFic3RyYWN0IHZhbHVlXCIpO1xuICAgICAgICB2YXIgeCA9IGNvbXAoYSxiLHRvdGFsKTtcbiAgICAgICAgaWYoeCAhPSB4KXsgLy8gUHJvdGVjdCBhZ2FpbnN0IGludmFsaWQgVU5PUkRFUkVEXG4gICAgICAgICAgcmV0dXJuIHRvdGFsPy0xOng7XG4gICAgICAgIH1cbiAgICAgICAgaWYoeCAhPT0gKHh8MCkpeyAvLyBQcm90ZWN0IGFnYWluc3QgaW52YWxpZCByZXR1cm4gdmFsdWVcbiAgICAgICAgICByZXR1cm4gLTFcbiAgICAgICAgfVxuICAgICAgICBpZiAoeCAhPSAwKSByZXR1cm4gKHggfCAwKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEyNTY6IC8vIGNvbXBhcmUgZnVuY3Rpb25cbiAgICAgICAgdmFyIHggPSBhLmNvbXBhcmUoYix0b3RhbCk7XG4gICAgICAgIGlmKHggIT0geCkgeyAvLyBQcm90ZWN0IGFnYWluc3QgaW52YWxpZCBVTk9SREVSRURcbiAgICAgICAgICByZXR1cm4gdG90YWw/LTE6eDtcbiAgICAgICAgfVxuICAgICAgICBpZih4ICE9PSAoeHwwKSl7IC8vIFByb3RlY3QgYWdhaW5zdCBpbnZhbGlkIHJldHVybiB2YWx1ZVxuICAgICAgICAgIHJldHVybiAtMVxuICAgICAgICB9XG4gICAgICAgIGlmICh4ICE9IDApIHJldHVybiAoeCB8IDApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTAwMDogLy8gTnVtYmVyXG4gICAgICAgIGEgPSArYTtcbiAgICAgICAgYiA9ICtiO1xuICAgICAgICBpZiAoYSA8IGIpIHJldHVybiAtMTtcbiAgICAgICAgaWYgKGEgPiBiKSByZXR1cm4gMTtcbiAgICAgICAgaWYgKGEgIT0gYikge1xuICAgICAgICAgIGlmICghdG90YWwpIHJldHVybiBOYU47XG4gICAgICAgICAgaWYgKGEgPT0gYSkgcmV0dXJuIDE7XG4gICAgICAgICAgaWYgKGIgPT0gYikgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxMDAxOiAvLyBUaGUgcmVzdFxuICAgICAgICAvLyBIZXJlIHdlIGNhbiBiZSBpbiB0aGUgZm9sbG93aW5nIGNhc2VzOlxuICAgICAgICAvLyAxLiBKYXZhU2NyaXB0IHByaW1pdGl2ZSB0eXBlc1xuICAgICAgICAvLyAyLiBKYXZhU2NyaXB0IG9iamVjdCB0aGF0IGNhbiBiZSBjb2VyY2VkIHRvIHByaW1pdGl2ZSB0eXBlc1xuICAgICAgICAvLyAzLiBKYXZhU2NyaXB0IG9iamVjdCB0aGFuIGNhbm5vdCBiZSBjb2VyY2VkIHRvIHByaW1pdGl2ZSB0eXBlc1xuICAgICAgICAvL1xuICAgICAgICAvLyAoMykgd2lsbCByYWlzZSBhIFtUeXBlRXJyb3JdXG4gICAgICAgIC8vICgyKSB3aWxsIGNvZXJjZSB0byBwcmltaXRpdmUgdHlwZXMgdXNpbmcgW3ZhbHVlT2ZdIG9yIFt0b1N0cmluZ11cbiAgICAgICAgLy8gKDIpIGFuZCAoMyksIGFmdGVyIGV2ZW50dWFsIGNvZXJjaW9uXG4gICAgICAgIC8vIC0gaWYgYSBhbmQgYiBhcmUgc3RyaW5ncywgYXBwbHkgbGV4aWNvZ3JhcGhpYyBjb21wYXJpc29uXG4gICAgICAgIC8vIC0gaWYgYSBvciBiIGFyZSBub3Qgc3RyaW5ncywgY29udmVydCBhIGFuZCBiIHRvIG51bWJlclxuICAgICAgICAvLyAgIGFuZCBhcHBseSBzdGFuZGFyZCBjb21wYXJpc29uXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEV4Y2VwdGlvbjogYCE9YCB3aWxsIG5vdCBjb2VyY2UvY29udmVydCBpZiBib3RoIGEgYW5kIGIgYXJlIG9iamVjdHNcbiAgICAgICAgaWYgKGEgPCBiKSByZXR1cm4gLTE7XG4gICAgICAgIGlmIChhID4gYikgcmV0dXJuIDE7XG4gICAgICAgIGlmIChhICE9IGIpIHtcbiAgICAgICAgICBpZiAoIXRvdGFsKSByZXR1cm4gTmFOO1xuICAgICAgICAgIGlmIChhID09IGEpIHJldHVybiAxO1xuICAgICAgICAgIGlmIChiID09IGIpIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTI1MTogLy8gSmF2YVNjcmlwdCBTeW1ib2wsIG5vIG9yZGVyaW5nLlxuICAgICAgICBpZihhICE9PSBiKSB7XG4gICAgICAgICAgaWYgKCF0b3RhbCkgcmV0dXJuIE5hTjtcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTI1MjogLy8gb2NhbWwgc3RyaW5nc1xuICAgICAgICB2YXIgYSA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcoYSk7XG4gICAgICAgIHZhciBiID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhiKTtcbiAgICAgICAgaWYoYSAhPT0gYikge1xuICAgICAgICAgIGlmKGEgPCBiKSByZXR1cm4gLTE7XG4gICAgICAgICAgaWYoYSA+IGIpIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxMjUyMDogLy8gamF2YXNjcmlwdCBzdHJpbmdzXG4gICAgICAgIHZhciBhID0gYS50b1N0cmluZygpO1xuICAgICAgICB2YXIgYiA9IGIudG9TdHJpbmcoKTtcbiAgICAgICAgaWYoYSAhPT0gYikge1xuICAgICAgICAgIGlmKGEgPCBiKSByZXR1cm4gLTE7XG4gICAgICAgICAgaWYoYSA+IGIpIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNDY6IC8vIExhenlfdGFnXG4gICAgICBjYXNlIDI1NDogLy8gRG91YmxlX2FycmF5XG4gICAgICBkZWZhdWx0OiAvLyBCbG9jayB3aXRoIG90aGVyIHRhZ1xuICAgICAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpIHJldHVybiAoYS5sZW5ndGggPCBiLmxlbmd0aCk/LTE6MTtcbiAgICAgICAgaWYgKGEubGVuZ3RoID4gMSkgc3RhY2sucHVzaChhLCBiLCAxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzdGFjay5sZW5ndGggPT0gMCkgcmV0dXJuIDA7XG4gICAgdmFyIGkgPSBzdGFjay5wb3AoKTtcbiAgICBiID0gc3RhY2sucG9wKCk7XG4gICAgYSA9IHN0YWNrLnBvcCgpO1xuICAgIGlmIChpICsgMSA8IGEubGVuZ3RoKSBzdGFjay5wdXNoKGEsIGIsIGkgKyAxKTtcbiAgICBhID0gYVtpXTtcbiAgICBiID0gYltpXTtcbiAgfVxufVxuLy9Qcm92aWRlczogY2FtbF9jb21wYXJlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsXG5mdW5jdGlvbiBjYW1sX2NvbXBhcmUgKGEsIGIpIHsgcmV0dXJuIGNhbWxfY29tcGFyZV92YWwgKGEsIGIsIHRydWUpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2ludF9jb21wYXJlIG11dGFibGUgKGNvbnN0LCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfaW50X2NvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKGEgPCBiKSByZXR1cm4gKC0xKTsgaWYgKGEgPT0gYikgcmV0dXJuIDA7IHJldHVybiAxO1xufVxuLy9Qcm92aWRlczogY2FtbF9lcXVhbCBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsXG5mdW5jdGlvbiBjYW1sX2VxdWFsICh4LCB5KSB7IHJldHVybiArKGNhbWxfY29tcGFyZV92YWwoeCx5LGZhbHNlKSA9PSAwKTsgfVxuLy9Qcm92aWRlczogY2FtbF9ub3RlcXVhbCBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsXG5mdW5jdGlvbiBjYW1sX25vdGVxdWFsICh4LCB5KSB7IHJldHVybiArKGNhbWxfY29tcGFyZV92YWwoeCx5LGZhbHNlKSAhPSAwKTsgfVxuLy9Qcm92aWRlczogY2FtbF9ncmVhdGVyZXF1YWwgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jb21wYXJlX3ZhbFxuZnVuY3Rpb24gY2FtbF9ncmVhdGVyZXF1YWwgKHgsIHkpIHsgcmV0dXJuICsoY2FtbF9jb21wYXJlX3ZhbCh4LHksZmFsc2UpID49IDApOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2dyZWF0ZXJ0aGFuIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY29tcGFyZV92YWxcbmZ1bmN0aW9uIGNhbWxfZ3JlYXRlcnRoYW4gKHgsIHkpIHsgcmV0dXJuICsoY2FtbF9jb21wYXJlX3ZhbCh4LHksZmFsc2UpID4gMCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfbGVzc2VxdWFsIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY29tcGFyZV92YWxcbmZ1bmN0aW9uIGNhbWxfbGVzc2VxdWFsICh4LCB5KSB7IHJldHVybiArKGNhbWxfY29tcGFyZV92YWwoeCx5LGZhbHNlKSA8PSAwKTsgfVxuLy9Qcm92aWRlczogY2FtbF9sZXNzdGhhbiBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsXG5mdW5jdGlvbiBjYW1sX2xlc3N0aGFuICh4LCB5KSB7IHJldHVybiArKGNhbWxfY29tcGFyZV92YWwoeCx5LGZhbHNlKSA8IDApOyB9XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTQgSsOpcsO0bWUgVm91aWxsb24sIEh1Z28gSGV1emFyZFxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBjYW1sX0NhbWxpbnRlcm5hbE1vZF9pbml0X21vZFxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV93aXRoX2FyZywgY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9DYW1saW50ZXJuYWxNb2RfaW5pdF9tb2QobG9jLHNoYXBlKSB7XG4gIGZ1bmN0aW9uIHVuZGVmX21vZHVsZSAoX3gpIHtcbiAgICBjYW1sX3JhaXNlX3dpdGhfYXJnKGNhbWxfZ2xvYmFsX2RhdGEuVW5kZWZpbmVkX3JlY3Vyc2l2ZV9tb2R1bGUsIGxvYyk7XG4gIH1cbiAgZnVuY3Rpb24gbG9vcCAoc2hhcGUsc3RydWN0LGlkeCl7XG4gICAgaWYodHlwZW9mIHNoYXBlID09PSBcIm51bWJlclwiKVxuICAgICAgc3dpdGNoKHNoYXBlKXtcbiAgICAgIGNhc2UgMDovL2Z1bmN0aW9uXG4gICAgICAgIHN0cnVjdFtpZHhdPXtmdW46dW5kZWZfbW9kdWxlfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDE6Ly9sYXp5XG4gICAgICAgIHN0cnVjdFtpZHhdPVsyNDYsIHVuZGVmX21vZHVsZV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDovL2Nhc2UgMjovL2NsYXNzXG4gICAgICAgIHN0cnVjdFtpZHhdPVtdO1xuICAgICAgfVxuICAgIGVsc2VcbiAgICAgIHN3aXRjaChzaGFwZVswXSl7XG4gICAgICBjYXNlIDA6Ly9tb2R1bGVcbiAgICAgICAgc3RydWN0W2lkeF0gPSBbMF07XG4gICAgICAgIGZvcih2YXIgaT0xO2k8c2hhcGVbMV0ubGVuZ3RoO2krKylcbiAgICAgICAgICBsb29wKHNoYXBlWzFdW2ldLHN0cnVjdFtpZHhdLGkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6Ly9jYXNlIDE6Ly9WYWx1ZVxuICAgICAgICBzdHJ1Y3RbaWR4XSA9IHNoYXBlWzFdO1xuICAgICAgfVxuICB9XG4gIHZhciByZXMgPSBbXTtcbiAgbG9vcChzaGFwZSxyZXMsMCk7XG4gIHJldHVybiByZXNbMF1cbn1cbi8vUHJvdmlkZXM6IGNhbWxfQ2FtbGludGVybmFsTW9kX3VwZGF0ZV9tb2Rcbi8vUmVxdWlyZXM6IGNhbWxfdXBkYXRlX2R1bW15XG5mdW5jdGlvbiBjYW1sX0NhbWxpbnRlcm5hbE1vZF91cGRhdGVfbW9kKHNoYXBlLHJlYWwseCkge1xuICBpZih0eXBlb2Ygc2hhcGUgPT09IFwibnVtYmVyXCIpXG4gICAgc3dpdGNoKHNoYXBlKXtcbiAgICBjYXNlIDA6Ly9mdW5jdGlvblxuICAgIGNhc2UgMTovL2xhenlcbiAgICBjYXNlIDI6Ly9jbGFzc1xuICAgIGRlZmF1bHQ6XG4gICAgICBjYW1sX3VwZGF0ZV9kdW1teShyZWFsLHgpO1xuICAgIH1cbiAgZWxzZVxuICAgIHN3aXRjaChzaGFwZVswXSl7XG4gICAgY2FzZSAwOi8vbW9kdWxlXG4gICAgICBmb3IodmFyIGk9MTtpPHNoYXBlWzFdLmxlbmd0aDtpKyspXG4gICAgICAgIGNhbWxfQ2FtbGludGVybmFsTW9kX3VwZGF0ZV9tb2Qoc2hhcGVbMV1baV0scmVhbFtpXSx4W2ldKTtcbiAgICAgIGJyZWFrO1xuICAgICAgLy9jYXNlIDE6Ly9WYWx1ZVxuICAgIGRlZmF1bHQ6XG4gICAgfTtcbiAgcmV0dXJuIDBcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUHJvdmlkZXM6IGNhbWxfdXBkYXRlX2R1bW15XG5mdW5jdGlvbiBjYW1sX3VwZGF0ZV9kdW1teSAoeCwgeSkge1xuICBpZiggdHlwZW9mIHk9PT1cImZ1bmN0aW9uXCIgKSB7IHguZnVuID0geTsgcmV0dXJuIDA7IH1cbiAgaWYoIHkuZnVuICkgeyB4LmZ1biA9IHkuZnVuOyByZXR1cm4gMDsgfVxuICB2YXIgaSA9IHkubGVuZ3RoOyB3aGlsZSAoaS0tKSB4W2ldID0geVtpXTsgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX2lzX2Jsb2NrIGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfb2JqX2lzX2Jsb2NrICh4KSB7IHJldHVybiArKHggaW5zdGFuY2VvZiBBcnJheSk7IH1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX29ial90YWdcbi8vUmVxdWlyZXM6IGNhbWxfaXNfbWxfYnl0ZXMsIGNhbWxfaXNfbWxfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX29ial90YWcgKHgpIHtcbiAgaWYgKCh4IGluc3RhbmNlb2YgQXJyYXkpICYmIHhbMF0gPT0gKHhbMF0gPj4+IDApKVxuICAgIHJldHVybiB4WzBdXG4gIGVsc2UgaWYgKGNhbWxfaXNfbWxfYnl0ZXMoeCkpXG4gICAgcmV0dXJuIDI1MlxuICBlbHNlIGlmIChjYW1sX2lzX21sX3N0cmluZyh4KSlcbiAgICByZXR1cm4gMjUyXG4gIGVsc2UgaWYgKCh4IGluc3RhbmNlb2YgRnVuY3Rpb24pIHx8IHR5cGVvZiB4ID09IFwiZnVuY3Rpb25cIilcbiAgICByZXR1cm4gMjQ3XG4gIGVsc2UgaWYgKHggJiYgeC5jYW1sX2N1c3RvbSlcbiAgICByZXR1cm4gMjU1XG4gIGVsc2VcbiAgICByZXR1cm4gMTAwMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29ial9zZXRfdGFnIChtdXRhYmxlLCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfb2JqX3NldF90YWcgKHgsIHRhZykgeyB4WzBdID0gdGFnOyByZXR1cm4gMDsgfVxuLy9Qcm92aWRlczogY2FtbF9vYmpfYmxvY2sgY29uc3QgKGNvbnN0LGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9vYmpfYmxvY2sgKHRhZywgc2l6ZSkge1xuICB2YXIgbyA9IG5ldyBBcnJheShzaXplKzEpO1xuICBvWzBdPXRhZztcbiAgZm9yICh2YXIgaSA9IDE7IGkgPD0gc2l6ZTsgaSsrKSBvW2ldID0gMDtcbiAgcmV0dXJuIG87XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX3dpdGhfdGFnXG5mdW5jdGlvbiBjYW1sX29ial93aXRoX3RhZyh0YWcseCkge1xuICB2YXIgbCA9IHgubGVuZ3RoO1xuICB2YXIgYSA9IG5ldyBBcnJheShsKTtcbiAgYVswXSA9IHRhZztcbiAgZm9yKHZhciBpID0gMTsgaSA8IGw7IGkrKyApIGFbaV0gPSB4W2ldO1xuICByZXR1cm4gYTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfZHVwIG11dGFibGUgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9vYmpfZHVwICh4KSB7XG4gIHZhciBsID0geC5sZW5ndGg7XG4gIHZhciBhID0gbmV3IEFycmF5KGwpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbDsgaSsrICkgYVtpXSA9IHhbaV07XG4gIHJldHVybiBhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29ial90cnVuY2F0ZSAobXV0YWJsZSwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfb2JqX3RydW5jYXRlICh4LCBzKSB7XG4gIGlmIChzPD0wIHx8IHMgKyAxID4geC5sZW5ndGgpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50IChcIk9iai50cnVuY2F0ZVwiKTtcbiAgaWYgKHgubGVuZ3RoICE9IHMgKyAxKSB4Lmxlbmd0aCA9IHMgKyAxO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfbWFrZV9mb3J3YXJkXG5mdW5jdGlvbiBjYW1sX29ial9tYWtlX2ZvcndhcmQgKGIsdikge1xuICBiWzBdPTI1MDtcbiAgYlsxXT12O1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2xhenlfbWFrZV9mb3J3YXJkIGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfbGF6eV9tYWtlX2ZvcndhcmQgKHYpIHsgcmV0dXJuIFsyNTAsIHZdOyB9XG5cbi8vLy8vLy8vLy8vLy8gQ2FtbGludGVybmFsT09cbi8vUHJvdmlkZXM6IGNhbWxfZ2V0X3B1YmxpY19tZXRob2QgY29uc3RcbnZhciBjYW1sX21ldGhvZF9jYWNoZSA9IFtdO1xuZnVuY3Rpb24gY2FtbF9nZXRfcHVibGljX21ldGhvZCAob2JqLCB0YWcsIGNhY2hlaWQpIHtcbiAgdmFyIG1ldGhzID0gb2JqWzFdO1xuICB2YXIgb2ZzID0gY2FtbF9tZXRob2RfY2FjaGVbY2FjaGVpZF07XG4gIGlmIChvZnMgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE1ha2Ugc3VyZSB0aGUgYXJyYXkgaXMgbm90IHNwYXJzZVxuICAgIGZvciAodmFyIGkgPSBjYW1sX21ldGhvZF9jYWNoZS5sZW5ndGg7IGkgPCBjYWNoZWlkOyBpKyspXG4gICAgICBjYW1sX21ldGhvZF9jYWNoZVtpXSA9IDA7XG4gIH0gZWxzZSBpZiAobWV0aHNbb2ZzXSA9PT0gdGFnKSB7XG4gICAgcmV0dXJuIG1ldGhzW29mcyAtIDFdO1xuICB9XG4gIHZhciBsaSA9IDMsIGhpID0gbWV0aHNbMV0gKiAyICsgMSwgbWk7XG4gIHdoaWxlIChsaSA8IGhpKSB7XG4gICAgbWkgPSAoKGxpK2hpKSA+PiAxKSB8IDE7XG4gICAgaWYgKHRhZyA8IG1ldGhzW21pKzFdKSBoaSA9IG1pLTI7XG4gICAgZWxzZSBsaSA9IG1pO1xuICB9XG4gIGNhbWxfbWV0aG9kX2NhY2hlW2NhY2hlaWRdID0gbGkgKyAxO1xuICAvKiByZXR1cm4gMCBpZiB0YWcgaXMgbm90IHRoZXJlICovXG4gIHJldHVybiAodGFnID09IG1ldGhzW2xpKzFdID8gbWV0aHNbbGldIDogMCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb29fbGFzdF9pZFxudmFyIGNhbWxfb29fbGFzdF9pZCA9IDA7XG5cbi8vUHJvdmlkZXM6IGNhbWxfc2V0X29vX2lkXG4vL1JlcXVpcmVzOiBjYW1sX29vX2xhc3RfaWRcbmZ1bmN0aW9uIGNhbWxfc2V0X29vX2lkIChiKSB7XG4gIGJbMl09Y2FtbF9vb19sYXN0X2lkKys7XG4gIHJldHVybiBiO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ZyZXNoX29vX2lkXG4vL1JlcXVpcmVzOiBjYW1sX29vX2xhc3RfaWRcbmZ1bmN0aW9uIGNhbWxfZnJlc2hfb29faWQoKSB7XG4gIHJldHVybiBjYW1sX29vX2xhc3RfaWQrKztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfcmF3X2ZpZWxkXG5mdW5jdGlvbiBjYW1sX29ial9yYXdfZmllbGQobyxpKSB7IHJldHVybiBvW2krMV0gfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29ial9zZXRfcmF3X2ZpZWxkXG5mdW5jdGlvbiBjYW1sX29ial9zZXRfcmF3X2ZpZWxkKG8saSx2KSB7IHJldHVybiBvW2krMV0gPSB2IH1cbiIsIi8vLy8vLy8vLyBCSUdTVFJJTkdcblxuLy9Qcm92aWRlczogY2FtbF9oYXNoX21peF9iaWdzdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfYnl0ZXNfYXJyXG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X2JpZ3N0cmluZyhoLCBicykge1xuICByZXR1cm4gY2FtbF9oYXNoX21peF9ieXRlc19hcnIoaCxicy5kYXRhKTtcbn1cblxuLy9Qcm92aWRlczogYmlnc3RyaW5nX3RvX2FycmF5X2J1ZmZlciBtdXRhYmxlXG5mdW5jdGlvbiBiaWdzdHJpbmdfdG9fYXJyYXlfYnVmZmVyKGJzKSB7XG4gIHJldHVybiBicy5kYXRhLmJ1ZmZlclxufVxuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdfdG9fdHlwZWRfYXJyYXkgbXV0YWJsZVxuZnVuY3Rpb24gYmlnc3RyaW5nX3RvX3R5cGVkX2FycmF5KGJzKSB7XG4gIHJldHVybiBicy5kYXRhXG59XG5cbi8vUHJvdmlkZXM6IGJpZ3N0cmluZ19vZl9hcnJheV9idWZmZXIgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9iYV9jcmVhdGVfdW5zYWZlXG5mdW5jdGlvbiBiaWdzdHJpbmdfb2ZfYXJyYXlfYnVmZmVyKGFiKSB7XG4gIHZhciB0YSA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5VaW50OEFycmF5KGFiKTtcbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZSgxMiwgMCwgW3RhLmxlbmd0aF0sIHRhKTtcbn1cblxuLy9Qcm92aWRlczogYmlnc3RyaW5nX29mX3R5cGVkX2FycmF5IG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfYmFfY3JlYXRlX3Vuc2FmZVxuZnVuY3Rpb24gYmlnc3RyaW5nX29mX3R5cGVkX2FycmF5KGJhKSB7XG4gIHZhciB0YSA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5VaW50OEFycmF5KGJhLmJ1ZmZlciwgYmEuYnl0ZU9mZnNldCwgYmEubGVuZ3RoICogYmEuQllURVNfUEVSX0VMRU1FTlQpO1xuICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKDEyLCAwLCBbdGEubGVuZ3RoXSwgdGEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JpZ3N0cmluZ19tZW1jbXBcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZ2V0XzFcbmZ1bmN0aW9uIGNhbWxfYmlnc3RyaW5nX21lbWNtcChzMSwgcG9zMSwgczIsIHBvczIsIGxlbil7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgYSA9IGNhbWxfYmFfZ2V0XzEoczEscG9zMSArIGkpO1xuICAgIHZhciBiID0gY2FtbF9iYV9nZXRfMShzMixwb3MyICsgaSk7XG4gICAgaWYgKGEgPCBiKSByZXR1cm4gLTE7XG4gICAgaWYgKGEgPiBiKSByZXR1cm4gMTtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19iYVxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX2JpZ3N0cmluZ19ibGl0X2JhX3RvX2JhKGJhMSwgcG9zMSwgYmEyLCBwb3MyLCBsZW4pe1xuICBpZigxMiAhPSBiYTEua2luZClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJjYW1sX2JpZ3N0cmluZ19ibGl0X2JhX3RvX2JhOiBraW5kIG1pc21hdGNoXCIpO1xuICBpZigxMiAhPSBiYTIua2luZClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJjYW1sX2JpZ3N0cmluZ19ibGl0X2JhX3RvX2JhOiBraW5kIG1pc21hdGNoXCIpO1xuICBpZihsZW4gPT0gMCkgcmV0dXJuIDA7XG4gIHZhciBvZnMxID0gYmExLm9mZnNldChwb3MxKTtcbiAgdmFyIG9mczIgPSBiYTIub2Zmc2V0KHBvczIpO1xuICBpZihvZnMxICsgbGVuID4gYmExLmRhdGEubGVuZ3RoKXtcbiAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIH1cbiAgaWYob2ZzMiArIGxlbiA+IGJhMi5kYXRhLmxlbmd0aCl7XG4gICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB9XG4gIHZhciBzbGljZSA9IGJhMS5kYXRhLnN1YmFycmF5KG9mczEsb2ZzMStsZW4pO1xuICBiYTIuZGF0YS5zZXQoc2xpY2UscG9zMik7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmlnc3RyaW5nX2JsaXRfc3RyaW5nX3RvX2JhXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IsIGNhbWxfYXJyYXlfb2Zfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfYmlnc3RyaW5nX2JsaXRfc3RyaW5nX3RvX2JhKHN0cjEsIHBvczEsIGJhMiwgcG9zMiwgbGVuKXtcbiAgaWYoMTIgIT0gYmEyLmtpbmQpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY2FtbF9iaWdzdHJpbmdfYmxpdF9zdHJpbmdfdG9fYmE6IGtpbmQgbWlzbWF0Y2hcIik7XG4gIGlmKGxlbiA9PSAwKSByZXR1cm4gMDtcbiAgdmFyIG9mczIgPSBiYTIub2Zmc2V0KHBvczIpO1xuICBpZihwb3MxICsgbGVuID4gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHN0cjEpKSB7XG4gICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB9XG4gIGlmKG9mczIgKyBsZW4gPiBiYTIuZGF0YS5sZW5ndGgpIHtcbiAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIH1cbiAgdmFyIHNsaWNlID0gY2FtbF9hcnJheV9vZl9zdHJpbmcoc3RyMSkuc2xpY2UocG9zMSxwb3MxICsgbGVuKTtcbiAgYmEyLmRhdGEuc2V0KHNsaWNlLG9mczIpO1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JpZ3N0cmluZ19ibGl0X2J5dGVzX3RvX2JhXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IsIGNhbWxfYXJyYXlfb2ZfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfbWxfYnl0ZXNfbGVuZ3RoXG5mdW5jdGlvbiBjYW1sX2JpZ3N0cmluZ19ibGl0X2J5dGVzX3RvX2JhKHN0cjEsIHBvczEsIGJhMiwgcG9zMiwgbGVuKXtcbiAgaWYoMTIgIT0gYmEyLmtpbmQpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY2FtbF9iaWdzdHJpbmdfYmxpdF9zdHJpbmdfdG9fYmE6IGtpbmQgbWlzbWF0Y2hcIik7XG4gIGlmKGxlbiA9PSAwKSByZXR1cm4gMDtcbiAgdmFyIG9mczIgPSBiYTIub2Zmc2V0KHBvczIpO1xuICBpZihwb3MxICsgbGVuID4gY2FtbF9tbF9ieXRlc19sZW5ndGgoc3RyMSkpIHtcbiAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIH1cbiAgaWYob2ZzMiArIGxlbiA+IGJhMi5kYXRhLmxlbmd0aCkge1xuICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgfVxuICB2YXIgc2xpY2UgPSBjYW1sX2FycmF5X29mX2J5dGVzKHN0cjEpLnNsaWNlKHBvczEscG9zMSArIGxlbik7XG4gIGJhMi5kYXRhLnNldChzbGljZSxvZnMyKTtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX2JsaXRfYnl0ZXMsIGNhbWxfYnl0ZXNfb2ZfYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfbWxfYnl0ZXNfbGVuZ3RoXG5mdW5jdGlvbiBjYW1sX2JpZ3N0cmluZ19ibGl0X2JhX3RvX2J5dGVzKGJhMSwgcG9zMSwgYnl0ZXMyLCBwb3MyLCBsZW4pe1xuICBpZigxMiAhPSBiYTEua2luZClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJjYW1sX2JpZ3N0cmluZ19ibGl0X3N0cmluZ190b19iYToga2luZCBtaXNtYXRjaFwiKTtcbiAgaWYobGVuID09IDApIHJldHVybiAwO1xuICB2YXIgb2ZzMSA9IGJhMS5vZmZzZXQocG9zMSk7XG4gIGlmKG9mczEgKyBsZW4gPiBiYTEuZGF0YS5sZW5ndGgpe1xuICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgfVxuICBpZihwb3MyICsgbGVuID4gY2FtbF9tbF9ieXRlc19sZW5ndGgoYnl0ZXMyKSl7XG4gICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB9XG4gIHZhciBzbGljZSA9IGJhMS5kYXRhLnNsaWNlKG9mczEsIG9mczErbGVuKTtcbiAgY2FtbF9ibGl0X2J5dGVzKGNhbWxfYnl0ZXNfb2ZfYXJyYXkoc2xpY2UpLCAwLCBieXRlczIsIHBvczIsIGxlbik7XG4gIHJldHVybiAwXG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2RlYnVnX2luZm9fc3RhdHVzIGNvbnN0XG5mdW5jdGlvbiBjYW1sX21sX2RlYnVnX2luZm9fc3RhdHVzICgpIHsgcmV0dXJuIDA7IH1cbi8vUHJvdmlkZXM6IGNhbWxfYmFja3RyYWNlX3N0YXR1cyBjb25zdFxuZnVuY3Rpb24gY2FtbF9iYWNrdHJhY2Vfc3RhdHVzICgpIHsgcmV0dXJuIDA7IH1cbi8vUHJvdmlkZXM6IGNhbWxfZ2V0X2V4Y2VwdGlvbl9iYWNrdHJhY2UgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZ2V0X2V4Y2VwdGlvbl9iYWNrdHJhY2UgKCkgeyByZXR1cm4gMDsgfVxuLy9Qcm92aWRlczogY2FtbF9nZXRfZXhjZXB0aW9uX3Jhd19iYWNrdHJhY2UgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZ2V0X2V4Y2VwdGlvbl9yYXdfYmFja3RyYWNlICgpIHsgcmV0dXJuIFswXTsgfVxuLy9Qcm92aWRlczogY2FtbF9yZWNvcmRfYmFja3RyYWNlXG5mdW5jdGlvbiBjYW1sX3JlY29yZF9iYWNrdHJhY2UgKCkgeyByZXR1cm4gMDsgfVxuLy9Qcm92aWRlczogY2FtbF9jb252ZXJ0X3Jhd19iYWNrdHJhY2UgY29uc3RcbmZ1bmN0aW9uIGNhbWxfY29udmVydF9yYXdfYmFja3RyYWNlICgpIHsgcmV0dXJuIFswXTsgfVxuLy9Qcm92aWRlczogY2FtbF9yYXdfYmFja3RyYWNlX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9yYXdfYmFja3RyYWNlX2xlbmd0aCgpIHsgcmV0dXJuIDA7IH1cbi8vUHJvdmlkZXM6IGNhbWxfcmF3X2JhY2t0cmFjZV9uZXh0X3Nsb3RcbmZ1bmN0aW9uIGNhbWxfcmF3X2JhY2t0cmFjZV9uZXh0X3Nsb3QoKSB7IHJldHVybiAwIH1cbi8vUHJvdmlkZXM6IGNhbWxfcmF3X2JhY2t0cmFjZV9zbG90XG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfcmF3X2JhY2t0cmFjZV9zbG90ICgpIHtcbiAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiUHJpbnRleGMuZ2V0X3Jhd19iYWNrdHJhY2Vfc2xvdDogaW5kZXggb3V0IG9mIGJvdW5kc1wiKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfcmVzdG9yZV9yYXdfYmFja3RyYWNlXG5mdW5jdGlvbiBjYW1sX3Jlc3RvcmVfcmF3X2JhY2t0cmFjZShleG4sIGJ0KSB7IHJldHVybiAwIH1cbi8vUHJvdmlkZXM6IGNhbWxfZ2V0X2N1cnJlbnRfY2FsbHN0YWNrIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2dldF9jdXJyZW50X2NhbGxzdGFjayAoKSB7IHJldHVybiBbMF07IH1cblxuLy9Qcm92aWRlczogY2FtbF9jb252ZXJ0X3Jhd19iYWNrdHJhY2Vfc2xvdFxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9jb252ZXJ0X3Jhd19iYWNrdHJhY2Vfc2xvdCgpe1xuICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9jb252ZXJ0X3Jhd19iYWNrdHJhY2Vfc2xvdFwiKTtcbn1cbiIsIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0aXZlIENhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgKi9cbi8qICBlbiBBdXRvbWF0aXF1ZS4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgICAgKi9cbi8qICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSwgd2l0aCAgICAgKi9cbi8qICB0aGUgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gZmlsZSAuLi9MSUNFTlNFLiAgICAgKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLyogJElkOiBsZXhpbmcuYyA2MDQ1IDIwMDQtMDEtMDEgMTY6NDI6NDNaIGRvbGlnZXogJCAqL1xuXG4vKiBUaGUgdGFibGUtZHJpdmVuIGF1dG9tYXRvbiBmb3IgbGV4ZXJzIGdlbmVyYXRlZCBieSBjYW1sbGV4LiAqL1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2xleF9hcnJheVxuLy9SZXF1aXJlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9sZXhfYXJyYXkocykge1xuICBzID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhzKTtcbiAgdmFyIGwgPSBzLmxlbmd0aCAvIDI7XG4gIHZhciBhID0gbmV3IEFycmF5KGwpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKylcbiAgICBhW2ldID0gKHMuY2hhckNvZGVBdCgyICogaSkgfCAocy5jaGFyQ29kZUF0KDIgKiBpICsgMSkgPDwgOCkpIDw8IDE2ID4+IDE2O1xuICByZXR1cm4gYTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9sZXhfZW5naW5lXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoLCBjYW1sX2xleF9hcnJheSwgY2FtbF9hcnJheV9vZl9ieXRlc1xuZnVuY3Rpb24gY2FtbF9sZXhfZW5naW5lKHRibCwgc3RhcnRfc3RhdGUsIGxleGJ1Zikge1xuICB2YXIgbGV4X2J1ZmZlciA9IDI7XG4gIHZhciBsZXhfYnVmZmVyX2xlbiA9IDM7XG4gIHZhciBsZXhfc3RhcnRfcG9zID0gNTtcbiAgdmFyIGxleF9jdXJyX3BvcyA9IDY7XG4gIHZhciBsZXhfbGFzdF9wb3MgPSA3O1xuICB2YXIgbGV4X2xhc3RfYWN0aW9uID0gODtcbiAgdmFyIGxleF9lb2ZfcmVhY2hlZCA9IDk7XG4gIHZhciBsZXhfYmFzZSA9IDE7XG4gIHZhciBsZXhfYmFja3RyayA9IDI7XG4gIHZhciBsZXhfZGVmYXVsdCA9IDM7XG4gIHZhciBsZXhfdHJhbnMgPSA0O1xuICB2YXIgbGV4X2NoZWNrID0gNTtcblxuICBpZiAoIXRibC5sZXhfZGVmYXVsdCkge1xuICAgIHRibC5sZXhfYmFzZSA9ICAgIGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2Jhc2VdKTtcbiAgICB0YmwubGV4X2JhY2t0cmsgPSBjYW1sX2xleF9hcnJheSAodGJsW2xleF9iYWNrdHJrXSk7XG4gICAgdGJsLmxleF9jaGVjayA9ICAgY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfY2hlY2tdKTtcbiAgICB0YmwubGV4X3RyYW5zID0gICBjYW1sX2xleF9hcnJheSAodGJsW2xleF90cmFuc10pO1xuICAgIHRibC5sZXhfZGVmYXVsdCA9IGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2RlZmF1bHRdKTtcbiAgfVxuXG4gIHZhciBjLCBzdGF0ZSA9IHN0YXJ0X3N0YXRlO1xuXG4gIHZhciBidWZmZXIgPSBjYW1sX2FycmF5X29mX2J5dGVzKGxleGJ1ZltsZXhfYnVmZmVyXSk7XG5cbiAgaWYgKHN0YXRlID49IDApIHtcbiAgICAvKiBGaXJzdCBlbnRyeSAqL1xuICAgIGxleGJ1ZltsZXhfbGFzdF9wb3NdID0gbGV4YnVmW2xleF9zdGFydF9wb3NdID0gbGV4YnVmW2xleF9jdXJyX3Bvc107XG4gICAgbGV4YnVmW2xleF9sYXN0X2FjdGlvbl0gPSAtMTtcbiAgfSBlbHNlIHtcbiAgICAvKiBSZWVudHJ5IGFmdGVyIHJlZmlsbCAqL1xuICAgIHN0YXRlID0gLXN0YXRlIC0gMTtcbiAgfVxuICBmb3IoOzspIHtcbiAgICAvKiBMb29rdXAgYmFzZSBhZGRyZXNzIG9yIGFjdGlvbiBudW1iZXIgZm9yIGN1cnJlbnQgc3RhdGUgKi9cbiAgICB2YXIgYmFzZSA9IHRibC5sZXhfYmFzZVtzdGF0ZV07XG4gICAgaWYgKGJhc2UgPCAwKSByZXR1cm4gLWJhc2UtMTtcbiAgICAvKiBTZWUgaWYgaXQncyBhIGJhY2t0cmFjayBwb2ludCAqL1xuICAgIHZhciBiYWNrdHJrID0gdGJsLmxleF9iYWNrdHJrW3N0YXRlXTtcbiAgICBpZiAoYmFja3RyayA+PSAwKSB7XG4gICAgICBsZXhidWZbbGV4X2xhc3RfcG9zXSA9IGxleGJ1ZltsZXhfY3Vycl9wb3NdO1xuICAgICAgbGV4YnVmW2xleF9sYXN0X2FjdGlvbl0gPSBiYWNrdHJrO1xuICAgIH1cbiAgICAvKiBTZWUgaWYgd2UgbmVlZCBhIHJlZmlsbCAqL1xuICAgIGlmIChsZXhidWZbbGV4X2N1cnJfcG9zXSA+PSBsZXhidWZbbGV4X2J1ZmZlcl9sZW5dKXtcbiAgICAgIGlmIChsZXhidWZbbGV4X2VvZl9yZWFjaGVkXSA9PSAwKVxuICAgICAgICByZXR1cm4gLXN0YXRlIC0gMTtcbiAgICAgIGVsc2VcbiAgICAgICAgYyA9IDI1NjtcbiAgICB9ZWxzZXtcbiAgICAgIC8qIFJlYWQgbmV4dCBpbnB1dCBjaGFyICovXG4gICAgICBjID0gYnVmZmVyW2xleGJ1ZltsZXhfY3Vycl9wb3NdXTtcbiAgICAgIGxleGJ1ZltsZXhfY3Vycl9wb3NdICsrO1xuICAgIH1cbiAgICAvKiBEZXRlcm1pbmUgbmV4dCBzdGF0ZSAqL1xuICAgIGlmICh0YmwubGV4X2NoZWNrW2Jhc2UgKyBjXSA9PSBzdGF0ZSlcbiAgICAgIHN0YXRlID0gdGJsLmxleF90cmFuc1tiYXNlICsgY107XG4gICAgZWxzZVxuICAgICAgc3RhdGUgPSB0YmwubGV4X2RlZmF1bHRbc3RhdGVdO1xuICAgIC8qIElmIG5vIHRyYW5zaXRpb24gb24gdGhpcyBjaGFyLCByZXR1cm4gdG8gbGFzdCBiYWNrdHJhY2sgcG9pbnQgKi9cbiAgICBpZiAoc3RhdGUgPCAwKSB7XG4gICAgICBsZXhidWZbbGV4X2N1cnJfcG9zXSA9IGxleGJ1ZltsZXhfbGFzdF9wb3NdO1xuICAgICAgaWYgKGxleGJ1ZltsZXhfbGFzdF9hY3Rpb25dID09IC0xKVxuICAgICAgICBjYW1sX2ZhaWx3aXRoKFwibGV4aW5nOiBlbXB0eSB0b2tlblwiKTtcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIGxleGJ1ZltsZXhfbGFzdF9hY3Rpb25dO1xuICAgIH1lbHNle1xuICAgICAgLyogRXJhc2UgdGhlIEVPRiBjb25kaXRpb24gb25seSBpZiB0aGUgRU9GIHBzZXVkby1jaGFyYWN0ZXIgd2FzXG4gICAgICAgICBjb25zdW1lZCBieSB0aGUgYXV0b21hdG9uIChpLmUuIHRoZXJlIHdhcyBubyBiYWNrdHJhY2sgYWJvdmUpXG4gICAgICAqL1xuICAgICAgaWYgKGMgPT0gMjU2KSBsZXhidWZbbGV4X2VvZl9yZWFjaGVkXSA9IDA7XG4gICAgfVxuICB9XG59XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qIE5ldyBsZXhlciBlbmdpbmUsIHdpdGggbWVtb3J5IG9mIHBvc2l0aW9ucyAgKi9cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLy9Qcm92aWRlczogY2FtbF9uZXdfbGV4X2VuZ2luZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aCwgY2FtbF9sZXhfYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmcsIGNhbWxfYXJyYXlfb2ZfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfbGV4X3J1bl9tZW0ocywgaSwgbWVtLCBjdXJyX3Bvcykge1xuICBmb3IgKDs7KSB7XG4gICAgdmFyIGRzdCA9IHMuY2hhckNvZGVBdChpKTsgaSsrO1xuICAgIGlmIChkc3QgPT0gMHhmZikgcmV0dXJuO1xuICAgIHZhciBzcmMgPSBzLmNoYXJDb2RlQXQoaSk7IGkrKztcbiAgICBpZiAoc3JjID09IDB4ZmYpXG4gICAgICBtZW0gW2RzdCArIDFdID0gY3Vycl9wb3M7XG4gICAgZWxzZVxuICAgICAgbWVtIFtkc3QgKyAxXSA9IG1lbSBbc3JjICsgMV07XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FtbF9sZXhfcnVuX3RhZyhzLCBpLCBtZW0pIHtcbiAgZm9yICg7Oykge1xuICAgIHZhciBkc3QgPSBzLmNoYXJDb2RlQXQoaSk7IGkrKztcbiAgICBpZiAoZHN0ID09IDB4ZmYpIHJldHVybiA7XG4gICAgdmFyIHNyYyA9IHMuY2hhckNvZGVBdChpKTsgaSsrO1xuICAgIGlmIChzcmMgPT0gMHhmZilcbiAgICAgIG1lbSBbZHN0ICsgMV0gPSAtMTtcbiAgICBlbHNlXG4gICAgICBtZW0gW2RzdCArIDFdID0gbWVtIFtzcmMgKyAxXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYW1sX25ld19sZXhfZW5naW5lKHRibCwgc3RhcnRfc3RhdGUsIGxleGJ1Zikge1xuICB2YXIgbGV4X2J1ZmZlciA9IDI7XG4gIHZhciBsZXhfYnVmZmVyX2xlbiA9IDM7XG4gIHZhciBsZXhfc3RhcnRfcG9zID0gNTtcbiAgdmFyIGxleF9jdXJyX3BvcyA9IDY7XG4gIHZhciBsZXhfbGFzdF9wb3MgPSA3O1xuICB2YXIgbGV4X2xhc3RfYWN0aW9uID0gODtcbiAgdmFyIGxleF9lb2ZfcmVhY2hlZCA9IDk7XG4gIHZhciBsZXhfbWVtID0gMTA7XG4gIHZhciBsZXhfYmFzZSA9IDE7XG4gIHZhciBsZXhfYmFja3RyayA9IDI7XG4gIHZhciBsZXhfZGVmYXVsdCA9IDM7XG4gIHZhciBsZXhfdHJhbnMgPSA0O1xuICB2YXIgbGV4X2NoZWNrID0gNTtcbiAgdmFyIGxleF9iYXNlX2NvZGUgPSA2O1xuICB2YXIgbGV4X2JhY2t0cmtfY29kZSA9IDc7XG4gIHZhciBsZXhfZGVmYXVsdF9jb2RlID0gODtcbiAgdmFyIGxleF90cmFuc19jb2RlID0gOTtcbiAgdmFyIGxleF9jaGVja19jb2RlID0gMTA7XG4gIHZhciBsZXhfY29kZSA9IDExO1xuXG4gIGlmICghdGJsLmxleF9kZWZhdWx0KSB7XG4gICAgdGJsLmxleF9iYXNlID0gICAgY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfYmFzZV0pO1xuICAgIHRibC5sZXhfYmFja3RyayA9IGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2JhY2t0cmtdKTtcbiAgICB0YmwubGV4X2NoZWNrID0gICBjYW1sX2xleF9hcnJheSAodGJsW2xleF9jaGVja10pO1xuICAgIHRibC5sZXhfdHJhbnMgPSAgIGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X3RyYW5zXSk7XG4gICAgdGJsLmxleF9kZWZhdWx0ID0gY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfZGVmYXVsdF0pO1xuICB9XG4gIGlmICghdGJsLmxleF9kZWZhdWx0X2NvZGUpIHtcbiAgICB0YmwubGV4X2Jhc2VfY29kZSA9ICAgIGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2Jhc2VfY29kZV0pO1xuICAgIHRibC5sZXhfYmFja3Rya19jb2RlID0gY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfYmFja3Rya19jb2RlXSk7XG4gICAgdGJsLmxleF9jaGVja19jb2RlID0gICBjYW1sX2xleF9hcnJheSAodGJsW2xleF9jaGVja19jb2RlXSk7XG4gICAgdGJsLmxleF90cmFuc19jb2RlID0gICBjYW1sX2xleF9hcnJheSAodGJsW2xleF90cmFuc19jb2RlXSk7XG4gICAgdGJsLmxleF9kZWZhdWx0X2NvZGUgPSBjYW1sX2xleF9hcnJheSAodGJsW2xleF9kZWZhdWx0X2NvZGVdKTtcbiAgfVxuICBpZiAodGJsLmxleF9jb2RlID09IG51bGwpIHRibC5sZXhfY29kZSA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcodGJsW2xleF9jb2RlXSk7XG5cbiAgdmFyIGMsIHN0YXRlID0gc3RhcnRfc3RhdGU7XG5cbiAgdmFyIGJ1ZmZlciA9IGNhbWxfYXJyYXlfb2ZfYnl0ZXMobGV4YnVmW2xleF9idWZmZXJdKTtcblxuICBpZiAoc3RhdGUgPj0gMCkge1xuICAgIC8qIEZpcnN0IGVudHJ5ICovXG4gICAgbGV4YnVmW2xleF9sYXN0X3Bvc10gPSBsZXhidWZbbGV4X3N0YXJ0X3Bvc10gPSBsZXhidWZbbGV4X2N1cnJfcG9zXTtcbiAgICBsZXhidWZbbGV4X2xhc3RfYWN0aW9uXSA9IC0xO1xuICB9IGVsc2Uge1xuICAgIC8qIFJlZW50cnkgYWZ0ZXIgcmVmaWxsICovXG4gICAgc3RhdGUgPSAtc3RhdGUgLSAxO1xuICB9XG4gIGZvcig7Oykge1xuICAgIC8qIExvb2t1cCBiYXNlIGFkZHJlc3Mgb3IgYWN0aW9uIG51bWJlciBmb3IgY3VycmVudCBzdGF0ZSAqL1xuICAgIHZhciBiYXNlID0gdGJsLmxleF9iYXNlW3N0YXRlXTtcbiAgICBpZiAoYmFzZSA8IDApIHtcbiAgICAgIHZhciBwY19vZmYgPSB0YmwubGV4X2Jhc2VfY29kZVtzdGF0ZV07XG4gICAgICBjYW1sX2xleF9ydW5fdGFnKHRibC5sZXhfY29kZSwgcGNfb2ZmLCBsZXhidWZbbGV4X21lbV0pO1xuICAgICAgcmV0dXJuIC1iYXNlLTE7XG4gICAgfVxuICAgIC8qIFNlZSBpZiBpdCdzIGEgYmFja3RyYWNrIHBvaW50ICovXG4gICAgdmFyIGJhY2t0cmsgPSB0YmwubGV4X2JhY2t0cmtbc3RhdGVdO1xuICAgIGlmIChiYWNrdHJrID49IDApIHtcbiAgICAgIHZhciBwY19vZmYgPSB0YmwubGV4X2JhY2t0cmtfY29kZVtzdGF0ZV07XG4gICAgICBjYW1sX2xleF9ydW5fdGFnKHRibC5sZXhfY29kZSwgcGNfb2ZmLCBsZXhidWZbbGV4X21lbV0pO1xuICAgICAgbGV4YnVmW2xleF9sYXN0X3Bvc10gPSBsZXhidWZbbGV4X2N1cnJfcG9zXTtcbiAgICAgIGxleGJ1ZltsZXhfbGFzdF9hY3Rpb25dID0gYmFja3RyaztcbiAgICB9XG4gICAgLyogU2VlIGlmIHdlIG5lZWQgYSByZWZpbGwgKi9cbiAgICBpZiAobGV4YnVmW2xleF9jdXJyX3Bvc10gPj0gbGV4YnVmW2xleF9idWZmZXJfbGVuXSl7XG4gICAgICBpZiAobGV4YnVmW2xleF9lb2ZfcmVhY2hlZF0gPT0gMClcbiAgICAgICAgcmV0dXJuIC1zdGF0ZSAtIDE7XG4gICAgICBlbHNlXG4gICAgICAgIGMgPSAyNTY7XG4gICAgfWVsc2V7XG4gICAgICAvKiBSZWFkIG5leHQgaW5wdXQgY2hhciAqL1xuICAgICAgYyA9IGJ1ZmZlcltsZXhidWZbbGV4X2N1cnJfcG9zXV07XG4gICAgICBsZXhidWZbbGV4X2N1cnJfcG9zXSArKztcbiAgICB9XG4gICAgLyogRGV0ZXJtaW5lIG5leHQgc3RhdGUgKi9cbiAgICB2YXIgcHN0YXRlID0gc3RhdGUgO1xuICAgIGlmICh0YmwubGV4X2NoZWNrW2Jhc2UgKyBjXSA9PSBzdGF0ZSlcbiAgICAgIHN0YXRlID0gdGJsLmxleF90cmFuc1tiYXNlICsgY107XG4gICAgZWxzZVxuICAgICAgc3RhdGUgPSB0YmwubGV4X2RlZmF1bHRbc3RhdGVdO1xuICAgIC8qIElmIG5vIHRyYW5zaXRpb24gb24gdGhpcyBjaGFyLCByZXR1cm4gdG8gbGFzdCBiYWNrdHJhY2sgcG9pbnQgKi9cbiAgICBpZiAoc3RhdGUgPCAwKSB7XG4gICAgICBsZXhidWZbbGV4X2N1cnJfcG9zXSA9IGxleGJ1ZltsZXhfbGFzdF9wb3NdO1xuICAgICAgaWYgKGxleGJ1ZltsZXhfbGFzdF9hY3Rpb25dID09IC0xKVxuICAgICAgICBjYW1sX2ZhaWx3aXRoKFwibGV4aW5nOiBlbXB0eSB0b2tlblwiKTtcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIGxleGJ1ZltsZXhfbGFzdF9hY3Rpb25dO1xuICAgIH1lbHNle1xuICAgICAgLyogSWYgc29tZSB0cmFuc2l0aW9uLCBnZXQgYW5kIHBlcmZvcm0gbWVtb3J5IG1vdmVzICovXG4gICAgICB2YXIgYmFzZV9jb2RlID0gdGJsLmxleF9iYXNlX2NvZGVbcHN0YXRlXSwgcGNfb2ZmO1xuICAgICAgaWYgKHRibC5sZXhfY2hlY2tfY29kZVtiYXNlX2NvZGUgKyBjXSA9PSBwc3RhdGUpXG4gICAgICAgIHBjX29mZiA9IHRibC5sZXhfdHJhbnNfY29kZVtiYXNlX2NvZGUgKyBjXTtcbiAgICAgIGVsc2VcbiAgICAgICAgcGNfb2ZmID0gdGJsLmxleF9kZWZhdWx0X2NvZGVbcHN0YXRlXTtcbiAgICAgIGlmIChwY19vZmYgPiAwKVxuICAgICAgICBjYW1sX2xleF9ydW5fbWVtXG4gICAgICAodGJsLmxleF9jb2RlLCBwY19vZmYsIGxleGJ1ZltsZXhfbWVtXSwgbGV4YnVmW2xleF9jdXJyX3Bvc10pO1xuICAgICAgLyogRXJhc2UgdGhlIEVPRiBjb25kaXRpb24gb25seSBpZiB0aGUgRU9GIHBzZXVkby1jaGFyYWN0ZXIgd2FzXG4gICAgICAgICBjb25zdW1lZCBieSB0aGUgYXV0b21hdG9uIChpLmUuIHRoZXJlIHdhcyBubyBiYWNrdHJhY2sgYWJvdmUpXG4gICAgICAqL1xuICAgICAgaWYgKGMgPT0gMjU2KSBsZXhidWZbbGV4X2VvZl9yZWFjaGVkXSA9IDA7XG4gICAgfVxuICB9XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vLy8vLy8vLy8vLy8vIEFycmF5XG5cbi8vUHJvdmlkZXM6IGNhbWxfYXJyYXlfc3ViIG11dGFibGVcbmZ1bmN0aW9uIGNhbWxfYXJyYXlfc3ViIChhLCBpLCBsZW4pIHtcbiAgdmFyIGEyID0gbmV3IEFycmF5KGxlbisxKTtcbiAgYTJbMF09MDtcbiAgZm9yKHZhciBpMiA9IDEsIGkxPSBpKzE7IGkyIDw9IGxlbjsgaTIrKyxpMSsrICl7XG4gICAgYTJbaTJdPWFbaTFdO1xuICB9XG4gIHJldHVybiBhMjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9hcHBlbmQgbXV0YWJsZVxuZnVuY3Rpb24gY2FtbF9hcnJheV9hcHBlbmQoYTEsIGEyKSB7XG4gIHZhciBsMSA9IGExLmxlbmd0aCwgbDIgPSBhMi5sZW5ndGg7XG4gIHZhciBsID0gbDErbDItMVxuICB2YXIgYSA9IG5ldyBBcnJheShsKTtcbiAgYVswXSA9IDA7XG4gIHZhciBpID0gMSxqID0gMTtcbiAgZm9yKDtpPGwxO2krKykgYVtpXT1hMVtpXTtcbiAgZm9yKDtpPGw7aSsrLGorKykgYVtpXT1hMltqXTtcbiAgcmV0dXJuIGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYXJyYXlfY29uY2F0IG11dGFibGVcbmZ1bmN0aW9uIGNhbWxfYXJyYXlfY29uY2F0KGwpIHtcbiAgdmFyIGEgPSBbMF07XG4gIHdoaWxlIChsICE9PSAwKSB7XG4gICAgdmFyIGIgPSBsWzFdO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYi5sZW5ndGg7IGkrKykgYS5wdXNoKGJbaV0pO1xuICAgIGwgPSBsWzJdO1xuICB9XG4gIHJldHVybiBhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X2JsaXRcbmZ1bmN0aW9uIGNhbWxfYXJyYXlfYmxpdChhMSwgaTEsIGEyLCBpMiwgbGVuKSB7XG4gIGlmIChpMiA8PSBpMSkge1xuICAgIGZvciAodmFyIGogPSAxOyBqIDw9IGxlbjsgaisrKSBhMltpMiArIGpdID0gYTFbaTEgKyBqXTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBqID0gbGVuOyBqID49IDE7IGotLSkgYTJbaTIgKyBqXSA9IGExW2kxICsgal07XG4gIH07XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2Zsb2F0YXJyYXlfYmxpdFxuZnVuY3Rpb24gY2FtbF9mbG9hdGFycmF5X2JsaXQoYTEsIGkxLCBhMiwgaTIsIGxlbikge1xuICBpZiAoaTIgPD0gaTEpIHtcbiAgICBmb3IgKHZhciBqID0gMTsgaiA8PSBsZW47IGorKykgYTJbaTIgKyBqXSA9IGExW2kxICsgal07XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaiA9IGxlbjsgaiA+PSAxOyBqLS0pIGEyW2kyICsgal0gPSBhMVtpMSArIGpdO1xuICB9O1xuICByZXR1cm4gMDtcbn1cblxuLy8vLy8vLy8vLy8vLyBQZXJ2YXNpdmVcbi8vUHJvdmlkZXM6IGNhbWxfYXJyYXlfc2V0IChtdXRhYmxlLCBjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX2FycmF5X3NldCAoYXJyYXksIGluZGV4LCBuZXd2YWwpIHtcbiAgaWYgKChpbmRleCA8IDApIHx8IChpbmRleCA+PSBhcnJheS5sZW5ndGggLSAxKSkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICBhcnJheVtpbmRleCsxXT1uZXd2YWw7IHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X2dldCBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX2FycmF5X2dldCAoYXJyYXksIGluZGV4KSB7XG4gIGlmICgoaW5kZXggPCAwKSB8fCAoaW5kZXggPj0gYXJyYXkubGVuZ3RoIC0gMSkpIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgcmV0dXJuIGFycmF5W2luZGV4KzFdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X2ZpbGxcbmZ1bmN0aW9uIGNhbWxfYXJyYXlfZmlsbChhcnJheSwgb2ZzLCBsZW4sIHYpe1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspe1xuICAgIGFycmF5W29mcytpKzFdID0gdjtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jaGVja19ib3VuZCAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9jaGVja19ib3VuZCAoYXJyYXksIGluZGV4KSB7XG4gIGlmIChpbmRleCA+Pj4gMCA+PSBhcnJheS5sZW5ndGggLSAxKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHJldHVybiBhcnJheTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tYWtlX3ZlY3QgY29uc3QgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfbWFrZV92ZWN0IChsZW4sIGluaXQpIHtcbiAgaWYgKGxlbiA8IDApIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGxlbiA9IGxlbiArIDEgfCAwO1xuICB2YXIgYiA9IG5ldyBBcnJheShsZW4pO1xuICBiWzBdPTA7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuOyBpKyspIGJbaV0gPSBpbml0O1xuICByZXR1cm4gYjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tYWtlX2Zsb2F0X3ZlY3QgY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9tYWtlX2Zsb2F0X3ZlY3QobGVuKXtcbiAgaWYgKGxlbiA8IDApIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGxlbiA9IGxlbiArIDEgfCAwO1xuICB2YXIgYiA9IG5ldyBBcnJheShsZW4pO1xuICBiWzBdPTI1NDtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBsZW47IGkrKykgYltpXSA9IDA7XG4gIHJldHVybiBiXG59XG4vL1Byb3ZpZGVzOiBjYW1sX2Zsb2F0YXJyYXlfY3JlYXRlIGNvbnN0IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfZmxvYXRhcnJheV9jcmVhdGUobGVuKXtcbiAgaWYgKGxlbiA8IDApIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGxlbiA9IGxlbiArIDEgfCAwO1xuICB2YXIgYiA9IG5ldyBBcnJheShsZW4pO1xuICBiWzBdPTI1NDtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBsZW47IGkrKykgYltpXSA9IDA7XG4gIHJldHVybiBiXG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8gV2VhayBBUEksIGJ1dCB3aXRob3V0IHRoZSB3ZWFrIHNlbWFudGljc1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfa2V5X29mZnNldFxuLy9WZXJzaW9uOiA8IDQuMDNcbnZhciBjYW1sX2VwaGVfa2V5X29mZnNldCA9IDJcblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2tleV9vZmZzZXRcbi8vVmVyc2lvbjogPj0gNC4wM1xudmFyIGNhbWxfZXBoZV9rZXlfb2Zmc2V0ID0gM1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfZGF0YV9vZmZzZXRcbi8vVmVyc2lvbjogPj0gNC4wM1xudmFyIGNhbWxfZXBoZV9kYXRhX29mZnNldCA9IDJcblxuLy9Qcm92aWRlczogY2FtbF93ZWFrX2NyZWF0ZVxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2tleV9vZmZzZXQsIGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF93ZWFrX2NyZWF0ZSAobikge1xuICBpZiAobiA8IDApIGNhbWxfaW52YWxpZF9hcmd1bWVudCAoXCJXZWFrLmNyZWF0ZVwiKTtcbiAgdmFyIHggPSBbMjUxLFwiY2FtbF9lcGhlX2xpc3RfaGVhZFwiXTtcbiAgeC5sZW5ndGggPSBjYW1sX2VwaGVfa2V5X29mZnNldCArIG47XG4gIHJldHVybiB4O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3dlYWtfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfa2V5X29mZnNldCwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX3dlYWtfc2V0KHgsIGksIHYpIHtcbiAgaWYoaSA8IDAgfHwgY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpID49IHgubGVuZ3RoKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudCAoXCJXZWFrLnNldFwiKTtcbiAgeFtjYW1sX2VwaGVfa2V5X29mZnNldCArIGldID0gdjtcbiAgcmV0dXJuIDA7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX3dlYWtfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfa2V5X29mZnNldCwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX3dlYWtfZ2V0KHgsIGkpIHtcbiAgaWYoaSA8IDAgfHwgY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpID49IHgubGVuZ3RoKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudCAoXCJXZWFrLmdldF9rZXlcIik7XG4gIHJldHVybiAoeFtjYW1sX2VwaGVfa2V5X29mZnNldCArIGkgXT09PXVuZGVmaW5lZCk/MDp4W2NhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaV07XG59XG4vL1Byb3ZpZGVzOiBjYW1sX3dlYWtfZ2V0X2NvcHlcbi8vUmVxdWlyZXM6IGNhbWxfd2Vha19nZXQsY2FtbF9lcGhlX2tleV9vZmZzZXRcbi8vUmVxdWlyZXM6IGNhbWxfb2JqX2R1cCwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX3dlYWtfZ2V0X2NvcHkoeCwgaSkge1xuICBpZihpIDwgMCB8fCBjYW1sX2VwaGVfa2V5X29mZnNldCArIGkgPj0geC5sZW5ndGgpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50IChcIldlYWsuZ2V0X2NvcHlcIik7XG4gIHZhciB5ID0gY2FtbF93ZWFrX2dldCh4LCBpKTtcbiAgaWYgKHkgPT09IDApIHJldHVybiB5O1xuICB2YXIgeiA9IHlbMV07XG4gIGlmICh6IGluc3RhbmNlb2YgQXJyYXkpIHJldHVybiBbMCwgY2FtbF9vYmpfZHVwKHopXTtcbiAgcmV0dXJuIHk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfd2Vha19jaGVjayBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfa2V5X29mZnNldFxuZnVuY3Rpb24gY2FtbF93ZWFrX2NoZWNrKHgsIGkpIHtcbiAgaWYoeFtjYW1sX2VwaGVfa2V5X29mZnNldCArIGldIT09dW5kZWZpbmVkICYmIHhbY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpXSAhPT0wKVxuICAgIHJldHVybiAxO1xuICBlbHNlXG4gICAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfd2Vha19ibGl0XG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JsaXRcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9rZXlfb2Zmc2V0XG5mdW5jdGlvbiBjYW1sX3dlYWtfYmxpdChhMSwgaTEsIGEyLCBpMiwgbGVuKSB7XG4gIC8vIG1pbnVzIG9uZSBiZWNhdXNlIGNhbWxfYXJyYXlfYmxpdCB3b3JrcyBvbiBvY2FtbCBhcnJheVxuICBjYW1sX2FycmF5X2JsaXQoYTEsIGNhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaTEgLSAxLFxuICAgICAgICAgICAgICAgICAgYTIsIGNhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaTIgLSAxLFxuICAgICAgICAgICAgICAgICAgbGVuKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9jcmVhdGVcbi8vUmVxdWlyZXM6IGNhbWxfd2Vha19jcmVhdGVcbnZhciBjYW1sX2VwaGVfY3JlYXRlID0gY2FtbF93ZWFrX2NyZWF0ZVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfYmxpdF9rZXlcbi8vUmVxdWlyZXM6IGNhbWxfd2Vha19ibGl0XG52YXIgY2FtbF9lcGhlX2JsaXRfa2V5ID0gY2FtbF93ZWFrX2JsaXRcblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2dldF9rZXlcbi8vUmVxdWlyZXM6IGNhbWxfd2Vha19nZXRcbnZhciBjYW1sX2VwaGVfZ2V0X2tleSA9IGNhbWxfd2Vha19nZXRcblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2dldF9rZXlfY29weVxuLy9SZXF1aXJlczogY2FtbF93ZWFrX2dldF9jb3B5XG52YXIgY2FtbF9lcGhlX2dldF9rZXlfY29weSA9IGNhbWxfd2Vha19nZXRfY29weVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfY2hlY2tfa2V5XG4vL1JlcXVpcmVzOiBjYW1sX3dlYWtfY2hlY2tcbnZhciBjYW1sX2VwaGVfY2hlY2tfa2V5ID0gY2FtbF93ZWFrX2NoZWNrXG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9zZXRfa2V5XG4vL1JlcXVpcmVzOiBjYW1sX3dlYWtfc2V0XG5mdW5jdGlvbiBjYW1sX2VwaGVfc2V0X2tleSh4LCBpLCB2KSB7XG4gIHJldHVybiBjYW1sX3dlYWtfc2V0KHgsIGksIFswLCB2XSlcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX3Vuc2V0X2tleVxuLy9SZXF1aXJlczogY2FtbF93ZWFrX3NldFxuZnVuY3Rpb24gY2FtbF9lcGhlX3Vuc2V0X2tleSh4LCBpKSB7XG4gIHJldHVybiBjYW1sX3dlYWtfc2V0KHgsIGksIDApXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9ibGl0X2RhdGFcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9kYXRhX29mZnNldFxuLy9WZXJzaW9uOiA+PSA0LjAzXG5mdW5jdGlvbiBjYW1sX2VwaGVfYmxpdF9kYXRhKHNyYywgZHN0KXtcbiAgZHN0W2NhbWxfZXBoZV9kYXRhX29mZnNldF0gPSBzcmNbY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9nZXRfZGF0YVxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XG4vL1ZlcnNpb246ID49IDQuMDNcbmZ1bmN0aW9uIGNhbWxfZXBoZV9nZXRfZGF0YSh4KXtcbiAgaWYoeFtjYW1sX2VwaGVfZGF0YV9vZmZzZXRdID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIDA7XG4gIGVsc2VcbiAgICByZXR1cm4gWzAsIHhbY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XV07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9nZXRfZGF0YV9jb3B5XG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfZGF0YV9vZmZzZXRcbi8vUmVxdWlyZXM6IGNhbWxfb2JqX2R1cFxuLy9WZXJzaW9uOiA+PSA0LjAzXG5mdW5jdGlvbiBjYW1sX2VwaGVfZ2V0X2RhdGFfY29weSh4KXtcbiAgaWYoeFtjYW1sX2VwaGVfZGF0YV9vZmZzZXRdID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIDA7XG4gIGVsc2VcbiAgICByZXR1cm4gWzAsIGNhbWxfb2JqX2R1cCh4W2NhbWxfZXBoZV9kYXRhX29mZnNldF0pXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX3NldF9kYXRhXG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfZGF0YV9vZmZzZXRcbi8vVmVyc2lvbjogPj0gNC4wM1xuZnVuY3Rpb24gY2FtbF9lcGhlX3NldF9kYXRhKHgsIGRhdGEpe1xuICB4W2NhbWxfZXBoZV9kYXRhX29mZnNldF0gPSBkYXRhO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX3Vuc2V0X2RhdGFcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9kYXRhX29mZnNldFxuLy9WZXJzaW9uOiA+PSA0LjAzXG5mdW5jdGlvbiBjYW1sX2VwaGVfdW5zZXRfZGF0YSh4LCBkYXRhKXtcbiAgeFtjYW1sX2VwaGVfZGF0YV9vZmZzZXRdID0gdW5kZWZpbmVkO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2NoZWNrX2RhdGFcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9kYXRhX29mZnNldFxuLy9WZXJzaW9uOiA+PSA0LjAzXG5mdW5jdGlvbiBjYW1sX2VwaGVfY2hlY2tfZGF0YSh4KXtcbiAgaWYoeFtjYW1sX2VwaGVfZGF0YV9vZmZzZXRdID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIDA7XG4gIGVsc2VcbiAgICByZXR1cm4gMTtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxMCBKw6lyw7RtZSBWb3VpbGxvblxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWQ1X2NoYW5cbi8vUmVxdWlyZXM6IGNhbWxfbWQ1X3N0cmluZywgY2FtbF9zdHJpbmdfb2ZfYXJyYXksY2FtbF9tbF9jaGFubmVsc1xuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZSwgY2FtbF9jcmVhdGVfYnl0ZXMsIGNhbWxfc3RyaW5nX29mX2J5dGVzXG5mdW5jdGlvbiBjYW1sX21kNV9jaGFuKGNoYW5pZCxsZW4pe1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgdmFyIGNoYW5fbGVuID0gY2hhbi5maWxlLmxlbmd0aCgpO1xuICBpZihsZW48MCkgbGVuID0gY2hhbl9sZW4gLSBjaGFuLm9mZnNldDtcbiAgaWYoY2hhbi5vZmZzZXQgKyBsZW4gPiBjaGFuX2xlbikgY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZSgpO1xuICB2YXIgYnVmID0gY2FtbF9jcmVhdGVfYnl0ZXMobGVuKTtcbiAgY2hhbi5maWxlLnJlYWQoY2hhbi5vZmZzZXQsYnVmLDAsbGVuKTtcbiAgcmV0dXJuIGNhbWxfbWQ1X3N0cmluZyhjYW1sX3N0cmluZ19vZl9ieXRlcyhidWYpLDAsbGVuKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tZDVfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX29mX3N0cmluZywgY2FtbF9tZDVfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfbWQ1X3N0cmluZyhzLCBvZnMsIGxlbikge1xuICByZXR1cm4gY2FtbF9tZDVfYnl0ZXMoY2FtbF9ieXRlc19vZl9zdHJpbmcocyksb2ZzLGxlbik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWQ1X2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9hcnJheSwgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlc1xudmFyIGNhbWxfbWQ1X2J5dGVzID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBhZGQgKHgsIHkpIHsgcmV0dXJuICh4ICsgeSkgfCAwOyB9XG4gIGZ1bmN0aW9uIHh4KHEsYSxiLHgscyx0KSB7XG4gICAgYSA9IGFkZChhZGQoYSwgcSksIGFkZCh4LCB0KSk7XG4gICAgcmV0dXJuIGFkZCgoYSA8PCBzKSB8IChhID4+PiAoMzIgLSBzKSksIGIpO1xuICB9XG4gIGZ1bmN0aW9uIGZmKGEsYixjLGQseCxzLHQpIHtcbiAgICByZXR1cm4geHgoKGIgJiBjKSB8ICgofmIpICYgZCksIGEsIGIsIHgsIHMsIHQpO1xuICB9XG4gIGZ1bmN0aW9uIGdnKGEsYixjLGQseCxzLHQpIHtcbiAgICByZXR1cm4geHgoKGIgJiBkKSB8IChjICYgKH5kKSksIGEsIGIsIHgsIHMsIHQpO1xuICB9XG4gIGZ1bmN0aW9uIGhoKGEsYixjLGQseCxzLHQpIHsgcmV0dXJuIHh4KGIgXiBjIF4gZCwgYSwgYiwgeCwgcywgdCk7IH1cbiAgZnVuY3Rpb24gaWkoYSxiLGMsZCx4LHMsdCkgeyByZXR1cm4geHgoYyBeIChiIHwgKH5kKSksIGEsIGIsIHgsIHMsIHQpOyB9XG5cbiAgZnVuY3Rpb24gbWQ1KGJ1ZmZlciwgbGVuZ3RoKSB7XG4gICAgdmFyIGkgPSBsZW5ndGg7XG4gICAgYnVmZmVyW2kgPj4gMl0gfD0gMHg4MCA8PCAoOCAqIChpICYgMykpO1xuICAgIGZvciAoaSA9IChpICYgfjB4MykgKyA4OyhpICYgMHgzRikgPCA2MCA7aSArPSA0KVxuICAgICAgYnVmZmVyWyhpID4+IDIpIC0gMV0gPSAwO1xuICAgIGJ1ZmZlclsoaSA+PiAyKSAtMV0gPSBsZW5ndGggPDwgMztcbiAgICBidWZmZXJbaSA+PiAyXSA9IChsZW5ndGggPj4gMjkpICYgMHgxRkZGRkZGRjtcblxuICAgIHZhciB3ID0gWzB4Njc0NTIzMDEsIDB4RUZDREFCODksIDB4OThCQURDRkUsIDB4MTAzMjU0NzZdO1xuXG4gICAgZm9yKGkgPSAwOyBpIDwgYnVmZmVyLmxlbmd0aDsgaSArPSAxNikge1xuICAgICAgdmFyIGEgPSB3WzBdLCBiID0gd1sxXSwgYyA9IHdbMl0sIGQgPSB3WzNdO1xuXG4gICAgICBhID0gZmYoYSwgYiwgYywgZCwgYnVmZmVyW2krIDBdLCA3LCAweEQ3NkFBNDc4KTtcbiAgICAgIGQgPSBmZihkLCBhLCBiLCBjLCBidWZmZXJbaSsgMV0sIDEyLCAweEU4QzdCNzU2KTtcbiAgICAgIGMgPSBmZihjLCBkLCBhLCBiLCBidWZmZXJbaSsgMl0sIDE3LCAweDI0MjA3MERCKTtcbiAgICAgIGIgPSBmZihiLCBjLCBkLCBhLCBidWZmZXJbaSsgM10sIDIyLCAweEMxQkRDRUVFKTtcbiAgICAgIGEgPSBmZihhLCBiLCBjLCBkLCBidWZmZXJbaSsgNF0sIDcsIDB4RjU3QzBGQUYpO1xuICAgICAgZCA9IGZmKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKyA1XSwgMTIsIDB4NDc4N0M2MkEpO1xuICAgICAgYyA9IGZmKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKyA2XSwgMTcsIDB4QTgzMDQ2MTMpO1xuICAgICAgYiA9IGZmKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKyA3XSwgMjIsIDB4RkQ0Njk1MDEpO1xuICAgICAgYSA9IGZmKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKyA4XSwgNywgMHg2OTgwOThEOCk7XG4gICAgICBkID0gZmYoZCwgYSwgYiwgYywgYnVmZmVyW2krIDldLCAxMiwgMHg4QjQ0RjdBRik7XG4gICAgICBjID0gZmYoYywgZCwgYSwgYiwgYnVmZmVyW2krMTBdLCAxNywgMHhGRkZGNUJCMSk7XG4gICAgICBiID0gZmYoYiwgYywgZCwgYSwgYnVmZmVyW2krMTFdLCAyMiwgMHg4OTVDRDdCRSk7XG4gICAgICBhID0gZmYoYSwgYiwgYywgZCwgYnVmZmVyW2krMTJdLCA3LCAweDZCOTAxMTIyKTtcbiAgICAgIGQgPSBmZihkLCBhLCBiLCBjLCBidWZmZXJbaSsxM10sIDEyLCAweEZEOTg3MTkzKTtcbiAgICAgIGMgPSBmZihjLCBkLCBhLCBiLCBidWZmZXJbaSsxNF0sIDE3LCAweEE2Nzk0MzhFKTtcbiAgICAgIGIgPSBmZihiLCBjLCBkLCBhLCBidWZmZXJbaSsxNV0sIDIyLCAweDQ5QjQwODIxKTtcblxuICAgICAgYSA9IGdnKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKyAxXSwgNSwgMHhGNjFFMjU2Mik7XG4gICAgICBkID0gZ2coZCwgYSwgYiwgYywgYnVmZmVyW2krIDZdLCA5LCAweEMwNDBCMzQwKTtcbiAgICAgIGMgPSBnZyhjLCBkLCBhLCBiLCBidWZmZXJbaSsxMV0sIDE0LCAweDI2NUU1QTUxKTtcbiAgICAgIGIgPSBnZyhiLCBjLCBkLCBhLCBidWZmZXJbaSsgMF0sIDIwLCAweEU5QjZDN0FBKTtcbiAgICAgIGEgPSBnZyhhLCBiLCBjLCBkLCBidWZmZXJbaSsgNV0sIDUsIDB4RDYyRjEwNUQpO1xuICAgICAgZCA9IGdnKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKzEwXSwgOSwgMHgwMjQ0MTQ1Myk7XG4gICAgICBjID0gZ2coYywgZCwgYSwgYiwgYnVmZmVyW2krMTVdLCAxNCwgMHhEOEExRTY4MSk7XG4gICAgICBiID0gZ2coYiwgYywgZCwgYSwgYnVmZmVyW2krIDRdLCAyMCwgMHhFN0QzRkJDOCk7XG4gICAgICBhID0gZ2coYSwgYiwgYywgZCwgYnVmZmVyW2krIDldLCA1LCAweDIxRTFDREU2KTtcbiAgICAgIGQgPSBnZyhkLCBhLCBiLCBjLCBidWZmZXJbaSsxNF0sIDksIDB4QzMzNzA3RDYpO1xuICAgICAgYyA9IGdnKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKyAzXSwgMTQsIDB4RjRENTBEODcpO1xuICAgICAgYiA9IGdnKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKyA4XSwgMjAsIDB4NDU1QTE0RUQpO1xuICAgICAgYSA9IGdnKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKzEzXSwgNSwgMHhBOUUzRTkwNSk7XG4gICAgICBkID0gZ2coZCwgYSwgYiwgYywgYnVmZmVyW2krIDJdLCA5LCAweEZDRUZBM0Y4KTtcbiAgICAgIGMgPSBnZyhjLCBkLCBhLCBiLCBidWZmZXJbaSsgN10sIDE0LCAweDY3NkYwMkQ5KTtcbiAgICAgIGIgPSBnZyhiLCBjLCBkLCBhLCBidWZmZXJbaSsxMl0sIDIwLCAweDhEMkE0QzhBKTtcblxuICAgICAgYSA9IGhoKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKyA1XSwgNCwgMHhGRkZBMzk0Mik7XG4gICAgICBkID0gaGgoZCwgYSwgYiwgYywgYnVmZmVyW2krIDhdLCAxMSwgMHg4NzcxRjY4MSk7XG4gICAgICBjID0gaGgoYywgZCwgYSwgYiwgYnVmZmVyW2krMTFdLCAxNiwgMHg2RDlENjEyMik7XG4gICAgICBiID0gaGgoYiwgYywgZCwgYSwgYnVmZmVyW2krMTRdLCAyMywgMHhGREU1MzgwQyk7XG4gICAgICBhID0gaGgoYSwgYiwgYywgZCwgYnVmZmVyW2krIDFdLCA0LCAweEE0QkVFQTQ0KTtcbiAgICAgIGQgPSBoaChkLCBhLCBiLCBjLCBidWZmZXJbaSsgNF0sIDExLCAweDRCREVDRkE5KTtcbiAgICAgIGMgPSBoaChjLCBkLCBhLCBiLCBidWZmZXJbaSsgN10sIDE2LCAweEY2QkI0QjYwKTtcbiAgICAgIGIgPSBoaChiLCBjLCBkLCBhLCBidWZmZXJbaSsxMF0sIDIzLCAweEJFQkZCQzcwKTtcbiAgICAgIGEgPSBoaChhLCBiLCBjLCBkLCBidWZmZXJbaSsxM10sIDQsIDB4Mjg5QjdFQzYpO1xuICAgICAgZCA9IGhoKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKyAwXSwgMTEsIDB4RUFBMTI3RkEpO1xuICAgICAgYyA9IGhoKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKyAzXSwgMTYsIDB4RDRFRjMwODUpO1xuICAgICAgYiA9IGhoKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKyA2XSwgMjMsIDB4MDQ4ODFEMDUpO1xuICAgICAgYSA9IGhoKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKyA5XSwgNCwgMHhEOUQ0RDAzOSk7XG4gICAgICBkID0gaGgoZCwgYSwgYiwgYywgYnVmZmVyW2krMTJdLCAxMSwgMHhFNkRCOTlFNSk7XG4gICAgICBjID0gaGgoYywgZCwgYSwgYiwgYnVmZmVyW2krMTVdLCAxNiwgMHgxRkEyN0NGOCk7XG4gICAgICBiID0gaGgoYiwgYywgZCwgYSwgYnVmZmVyW2krIDJdLCAyMywgMHhDNEFDNTY2NSk7XG5cbiAgICAgIGEgPSBpaShhLCBiLCBjLCBkLCBidWZmZXJbaSsgMF0sIDYsIDB4RjQyOTIyNDQpO1xuICAgICAgZCA9IGlpKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKyA3XSwgMTAsIDB4NDMyQUZGOTcpO1xuICAgICAgYyA9IGlpKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKzE0XSwgMTUsIDB4QUI5NDIzQTcpO1xuICAgICAgYiA9IGlpKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKyA1XSwgMjEsIDB4RkM5M0EwMzkpO1xuICAgICAgYSA9IGlpKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKzEyXSwgNiwgMHg2NTVCNTlDMyk7XG4gICAgICBkID0gaWkoZCwgYSwgYiwgYywgYnVmZmVyW2krIDNdLCAxMCwgMHg4RjBDQ0M5Mik7XG4gICAgICBjID0gaWkoYywgZCwgYSwgYiwgYnVmZmVyW2krMTBdLCAxNSwgMHhGRkVGRjQ3RCk7XG4gICAgICBiID0gaWkoYiwgYywgZCwgYSwgYnVmZmVyW2krIDFdLCAyMSwgMHg4NTg0NUREMSk7XG4gICAgICBhID0gaWkoYSwgYiwgYywgZCwgYnVmZmVyW2krIDhdLCA2LCAweDZGQTg3RTRGKTtcbiAgICAgIGQgPSBpaShkLCBhLCBiLCBjLCBidWZmZXJbaSsxNV0sIDEwLCAweEZFMkNFNkUwKTtcbiAgICAgIGMgPSBpaShjLCBkLCBhLCBiLCBidWZmZXJbaSsgNl0sIDE1LCAweEEzMDE0MzE0KTtcbiAgICAgIGIgPSBpaShiLCBjLCBkLCBhLCBidWZmZXJbaSsxM10sIDIxLCAweDRFMDgxMUExKTtcbiAgICAgIGEgPSBpaShhLCBiLCBjLCBkLCBidWZmZXJbaSsgNF0sIDYsIDB4Rjc1MzdFODIpO1xuICAgICAgZCA9IGlpKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKzExXSwgMTAsIDB4QkQzQUYyMzUpO1xuICAgICAgYyA9IGlpKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKyAyXSwgMTUsIDB4MkFEN0QyQkIpO1xuICAgICAgYiA9IGlpKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKyA5XSwgMjEsIDB4RUI4NkQzOTEpO1xuXG4gICAgICB3WzBdID0gYWRkKGEsIHdbMF0pO1xuICAgICAgd1sxXSA9IGFkZChiLCB3WzFdKTtcbiAgICAgIHdbMl0gPSBhZGQoYywgd1syXSk7XG4gICAgICB3WzNdID0gYWRkKGQsIHdbM10pO1xuICAgIH1cblxuICAgIHZhciB0ID0gbmV3IEFycmF5KDE2KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKylcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgNDsgaisrKVxuICAgICAgICB0W2kgKiA0ICsgal0gPSAod1tpXSA+PiAoOCAqIGopKSAmIDB4RkY7XG4gICAgcmV0dXJuIHQ7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKHMsIG9mcywgbGVuKSB7XG4gICAgLy8gRklYOiBtYXliZSB3ZSBzaG91bGQgcGVyZm9ybSB0aGUgY29tcHV0YXRpb24gYnkgY2h1bmsgb2YgNjQgYnl0ZXNcbiAgICAvLyBhcyBpbiBodHRwOi8vd3d3Lm15ZXJzZGFpbHkub3JnL2pvc2VwaC9qYXZhc2NyaXB0L21kNS5qc1xuICAgIHZhciBidWYgPSBbXTtcbiAgICBzd2l0Y2ggKHMudCAmIDYpIHtcbiAgICBkZWZhdWx0OlxuICAgICAgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzKTtcbiAgICBjYXNlIDA6IC8qIEJZVEVTICovXG4gICAgICB2YXIgYiA9IHMuYztcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKz00KSB7XG4gICAgICAgIHZhciBqID0gaSArIG9mcztcbiAgICAgICAgYnVmW2k+PjJdID1cbiAgICAgICAgICBiLmNoYXJDb2RlQXQoaikgfCAoYi5jaGFyQ29kZUF0KGorMSkgPDwgOCkgfFxuICAgICAgICAgIChiLmNoYXJDb2RlQXQoaisyKSA8PCAxNikgfCAoYi5jaGFyQ29kZUF0KGorMykgPDwgMjQpO1xuICAgICAgfVxuICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykgYnVmW2k+PjJdIHw9IGIuY2hhckNvZGVBdChpICsgb2ZzKSA8PCAoOCAqIChpICYgMykpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSA0OiAvKiBBUlJBWSAqL1xuICAgICAgdmFyIGEgPSBzLmM7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSs9NCkge1xuICAgICAgICB2YXIgaiA9IGkgKyBvZnM7XG4gICAgICAgIGJ1ZltpPj4yXSA9IGFbal0gfCAoYVtqKzFdIDw8IDgpIHwgKGFbaisyXSA8PCAxNikgfCAoYVtqKzNdIDw8IDI0KTtcbiAgICAgIH1cbiAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIGJ1ZltpPj4yXSB8PSBhW2kgKyBvZnNdIDw8ICg4ICogKGkgJiAzKSk7XG4gICAgfVxuICAgIHJldHVybiBjYW1sX3N0cmluZ19vZl9hcnJheShtZDUoYnVmLCBsZW4pKTtcbiAgfVxufSAoKTtcbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAyMCAtIEh1Z28gSGV1emFyZFxuLy8gQ29weXJpZ2h0IChDKSAyMDIwIC0gU2hhY2hhciBJdHpoYWt5XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vLyBCYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vb2NhbWwvb2NhbWwvYmxvYi80LjA3L290aGVybGlicy9zdHIvc3Ryc3R1YnMuY1xuLy8gQ29waWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2pzY29xL2pzY29xL2Jsb2IvdjguMTEvY29xLWpzL2pzX3N0dWIvc3RyLmpzXG5cbi8vUHJvdmlkZXM6IHJlX21hdGNoXG4vL1JlcXVpcmVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nLCBjYW1sX2pzX2Zyb21fYXJyYXksIGNhbWxfYXJyYXlfb2Zfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19nZXRcblxudmFyIHJlX21hdGNoID0gZnVuY3Rpb24oKXtcbiAgdmFyIHJlX3dvcmRfbGV0dGVycyA9IFtcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAgICAgICAvKiAweDAwLTB4MUY6IG5vbmUgKi9cbiAgICAweDAwLCAweDAwLCAweEZGLCAweDAzLCAgICAgICAvKiAweDIwLTB4M0Y6IGRpZ2l0cyAwLTkgKi9cbiAgICAweEZFLCAweEZGLCAweEZGLCAweDg3LCAgICAgICAvKiAweDQwLTB4NUY6IEEgdG8gWiwgXyAqL1xuICAgIDB4RkUsIDB4RkYsIDB4RkYsIDB4MDcsICAgICAgIC8qIDB4NjAtMHg3RjogYSB0byB6ICovXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgICAgICAgLyogMHg4MC0weDlGOiBub25lICovXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgICAgICAgLyogMHhBMC0weEJGOiBub25lICovXG4gICAgMHhGRiwgMHhGRiwgMHg3RiwgMHhGRiwgICAgICAgLyogMHhDMC0weERGOiBMYXRpbi0xIGFjY2VudGVkIHVwcGVyY2FzZSAqL1xuICAgIDB4RkYsIDB4RkYsIDB4N0YsIDB4RkYgICAgICAgIC8qIDB4RTAtMHhGRjogTGF0aW4tMSBhY2NlbnRlZCBsb3dlcmNhc2UgKi9cbiAgXTtcblxuICB2YXIgb3Bjb2RlcyA9IHtcbiAgICBDSEFSOiAwLCBDSEFSTk9STTogMSwgU1RSSU5HOiAyLCBTVFJJTkdOT1JNOiAzLCBDSEFSQ0xBU1M6IDQsXG4gICAgQk9MOiA1LCBFT0w6IDYsIFdPUkRCT1VOREFSWTogNyxcbiAgICBCRUdHUk9VUDogOCwgRU5ER1JPVVA6IDksIFJFRkdST1VQOiAxMCxcbiAgICBBQ0NFUFQ6IDExLFxuICAgIFNJTVBMRU9QVDogMTIsIFNJTVBMRVNUQVI6IDEzLCBTSU1QTEVQTFVTOiAxNCxcbiAgICBHT1RPOiAxNSwgUFVTSEJBQ0s6IDE2LCBTRVRNQVJLOiAxNyxcbiAgICBDSEVDS1BST0dSRVNTOiAxOFxuICB9O1xuXG4gIGZ1bmN0aW9uIGlzX3dvcmRfbGV0dGVyKGMpIHtcbiAgICByZXR1cm4gKHJlX3dvcmRfbGV0dGVyc1sgIChjID4+IDMpXSA+PiAoYyAmIDcpKSAmIDE7XG4gIH1cblxuICBmdW5jdGlvbiBpbl9iaXRzZXQocyxpKSB7XG4gICAgcmV0dXJuIChjYW1sX3N0cmluZ19nZXQocywoaSA+PiAzKSkgPj4gKGkgJiA3KSkgJiAxO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVfbWF0Y2hfaW1wbChyZSwgcywgcG9zLCBwYXJ0aWFsKSB7XG5cbiAgICB2YXIgcHJvZyAgICAgICAgICA9IGNhbWxfanNfZnJvbV9hcnJheShyZVsxXSksXG4gICAgICAgIGNwb29sICAgICAgICAgPSBjYW1sX2pzX2Zyb21fYXJyYXkocmVbMl0pLFxuICAgICAgICBub3JtdGFibGUgICAgID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhyZVszXSksXG4gICAgICAgIG51bWdyb3VwcyAgICAgPSByZVs0XSB8IDAsXG4gICAgICAgIG51bXJlZ2lzdGVycyAgPSByZVs1XSB8IDAsXG4gICAgICAgIHN0YXJ0Y2hhcnMgICAgPSByZVs2XSB8IDA7XG5cbiAgICB2YXIgcyA9IGNhbWxfYXJyYXlfb2Zfc3RyaW5nKHMpO1xuXG4gICAgdmFyIHBjID0gMCxcbiAgICAgICAgcXVpdCA9IGZhbHNlLFxuICAgICAgICBzdGFjayA9IFtdLFxuICAgICAgICBncm91cHMgPSBuZXcgQXJyYXkobnVtZ3JvdXBzKSxcbiAgICAgICAgcmVfcmVnaXN0ZXIgPSBuZXcgQXJyYXkobnVtcmVnaXN0ZXJzKTtcblxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspe1xuICAgICAgZ3JvdXBzW2ldID0ge3N0YXJ0OiAtMSwgZW5kOi0xfVxuICAgIH1cbiAgICBncm91cHNbMF0uc3RhcnQgPSBwb3M7XG5cbiAgICB2YXIgYmFja3RyYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCkge1xuICAgICAgICB2YXIgaXRlbSA9IHN0YWNrLnBvcCgpO1xuICAgICAgICBpZiAoaXRlbS51bmRvKSB7XG4gICAgICAgICAgaXRlbS51bmRvLm9ialtpdGVtLnVuZG8ucHJvcF0gPSBpdGVtLnVuZG8udmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZihpdGVtLnBvcykge1xuICAgICAgICAgIHBjID0gaXRlbS5wb3MucGM7XG4gICAgICAgICAgcG9zID0gaXRlbS5wb3MudHh0O1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcXVpdCA9IHRydWU7XG4gICAgfTtcblxuICAgIHZhciBwdXNoID0gZnVuY3Rpb24oaXRlbSkgeyBzdGFjay5wdXNoKGl0ZW0pOyB9O1xuXG4gICAgdmFyIGFjY2VwdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGdyb3Vwc1swXS5lbmQgPSBwb3M7XG4gICAgICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KDEgKyBncm91cHMubGVuZ3RoKjIpO1xuICAgICAgcmVzdWx0WzBdID0gMDsgLy8gdGFnXG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGcgPSBncm91cHNbaV07XG4gICAgICAgIGlmKGcuc3RhcnQgPCAwIHx8IGcuZW5kIDwgMCkge1xuICAgICAgICAgIGcuc3RhcnQgPSBnLmVuZCA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdFsyKmkgKyAxIF0gPSBnLnN0YXJ0O1xuICAgICAgICByZXN1bHRbMippICsgMSArIDEgXSA9IGcuZW5kO1xuICAgICAgfTtcbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9O1xuXG4gICAgdmFyIHByZWZpeF9tYXRjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmKHBhcnRpYWwpIHJldHVybiBhY2NlcHQgKCk7XG4gICAgICBlbHNlIGJhY2t0cmFjayAoKTtcbiAgICB9XG5cbiAgICAvKiBNYWluIERGQSBpbnRlcnByZXRlciBsb29wICovXG4gICAgd2hpbGUgKCFxdWl0KSB7XG4gICAgICB2YXIgb3AgPSBwcm9nW3BjXSAmIDB4ZmYsXG4gICAgICAgICAgc2FyZyA9IHByb2dbcGNdID4+IDgsXG4gICAgICAgICAgdWFyZyA9IHNhcmcgJiAweGZmLFxuICAgICAgICAgIGMgPSBzW3Bvc10sXG4gICAgICAgICAgZ3JvdXA7XG5cbiAgICAgIHBjKys7XG5cbiAgICAgIHN3aXRjaCAob3ApIHtcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5DSEFSOlxuICAgICAgICBpZihwb3MgPT09IHMubGVuZ3RoKSB7cHJlZml4X21hdGNoICgpOyBicmVha307XG4gICAgICAgIGlmIChjID09PSB1YXJnKSBwb3MrKztcbiAgICAgICAgZWxzZSBiYWNrdHJhY2soKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuQ0hBUk5PUk06XG4gICAgICAgIGlmKHBvcyA9PT0gcy5sZW5ndGgpIHtwcmVmaXhfbWF0Y2ggKCk7IGJyZWFrfTtcbiAgICAgICAgaWYgKG5vcm10YWJsZS5jaGFyQ29kZUF0KGMpID09PSB1YXJnKSBwb3MrKztcbiAgICAgICAgZWxzZSBiYWNrdHJhY2soKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuU1RSSU5HOlxuICAgICAgICBmb3IgKHZhciBhcmcgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKGNwb29sW3VhcmddKSwgaSA9IDA7IGkgPCBhcmcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZihwb3MgPT09IHMubGVuZ3RoKSB7cHJlZml4X21hdGNoICgpOyBicmVha307XG4gICAgICAgICAgaWYgKGMgPT09IGFyZy5jaGFyQ29kZUF0KGkpKVxuICAgICAgICAgICAgYyA9IHNbKytwb3NdO1xuICAgICAgICAgIGVsc2UgeyBiYWNrdHJhY2soKTsgYnJlYWs7IH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5TVFJJTkdOT1JNOlxuICAgICAgICBmb3IgKHZhciBhcmcgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKGNwb29sW3VhcmddKSwgaSA9IDA7IGkgPCBhcmcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZihwb3MgPT09IHMubGVuZ3RoKSB7cHJlZml4X21hdGNoICgpOyBicmVha307XG4gICAgICAgICAgaWYgKG5vcm10YWJsZS5jaGFyQ29kZUF0KGMpID09PSBhcmcuY2hhckNvZGVBdChpKSlcbiAgICAgICAgICAgIGMgPSBzWysrcG9zXTtcbiAgICAgICAgICBlbHNlIHsgYmFja3RyYWNrKCk7IGJyZWFrOyB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuQ0hBUkNMQVNTOlxuICAgICAgaWYocG9zID09PSBzLmxlbmd0aCkge3ByZWZpeF9tYXRjaCAoKTsgYnJlYWt9O1xuICAgICAgICBpZiAoaW5fYml0c2V0KGNwb29sW3VhcmddLCBjKSkgcG9zKys7XG4gICAgICAgIGVsc2UgYmFja3RyYWNrKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLkJPTDpcbiAgICAgICAgaWYocG9zID4gMCAmJiBzW3BvcyAtIDFdICE9IDEwIC8qIFxcbiAqLykge2JhY2t0cmFjaygpfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5FT0w6XG4gICAgICAgIGlmKHBvcyA8IHMubGVuZ3RoICYmIHNbcG9zXSAhPSAxMCAvKiBcXG4gKi8pIHtiYWNrdHJhY2soKX1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuV09SREJPVU5EQVJZOlxuICAgICAgICBpZihwb3MgPT0gMCkge1xuICAgICAgICAgIGlmKHBvcyA9PT0gcy5sZW5ndGgpIHtwcmVmaXhfbWF0Y2ggKCk7IGJyZWFrfTtcbiAgICAgICAgICBpZihpc193b3JkX2xldHRlcihzWzBdKSkgYnJlYWs7XG4gICAgICAgICAgYmFja3RyYWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocG9zID09PSBzLmxlbmd0aCkge1xuICAgICAgICAgIGlmKGlzX3dvcmRfbGV0dGVyKHNbcG9zIC0gMV0pKSBicmVhaztcbiAgICAgICAgICBiYWNrdHJhY2sgKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYoaXNfd29yZF9sZXR0ZXIoc1twb3MgLSAxXSkgIT0gaXNfd29yZF9sZXR0ZXIoc1twb3NdKSkgYnJlYWs7XG4gICAgICAgICAgYmFja3RyYWNrICgpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLkJFR0dST1VQOlxuICAgICAgICBncm91cCA9IGdyb3Vwc1t1YXJnXTtcbiAgICAgICAgcHVzaCh7dW5kbzoge29iajpncm91cCxcbiAgICAgICAgICAgICAgICAgICAgIHByb3A6J3N0YXJ0JyxcbiAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBncm91cC5zdGFydH19KTtcbiAgICAgICAgZ3JvdXAuc3RhcnQgPSBwb3M7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLkVOREdST1VQOlxuICAgICAgICBncm91cCA9IGdyb3Vwc1t1YXJnXTtcbiAgICAgICAgcHVzaCh7dW5kbzoge29iajogZ3JvdXAsXG4gICAgICAgICAgICAgICAgICAgICBwcm9wOidlbmQnLFxuICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGdyb3VwLmVuZH19KTtcbiAgICAgICAgZ3JvdXAuZW5kID0gcG9zO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5SRUZHUk9VUDpcbiAgICAgICAgZ3JvdXAgPSBncm91cHNbdWFyZ107XG4gICAgICAgIGlmKGdyb3VwLnN0YXJ0IDwgMCB8fCBncm91cC5lbmQgPCAwKSB7YmFja3RyYWNrICgpOyBicmVha31cbiAgICAgICAgZm9yICh2YXIgaSA9IGdyb3VwLnN0YXJ0OyBpIDwgZ3JvdXAuZW5kOyBpKyspe1xuICAgICAgICAgIGlmKHBvcyA9PT0gcy5sZW5ndGgpIHtwcmVmaXhfbWF0Y2ggKCk7IGJyZWFrfTtcbiAgICAgICAgICBpZihzW2ldICE9IHNbcG9zXSkge2JhY2t0cmFjayAoKTsgYnJlYWt9XG4gICAgICAgICAgcG9zKys7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuU0lNUExFT1BUOlxuICAgICAgICBpZiAoaW5fYml0c2V0KGNwb29sW3VhcmddLCBjKSkgcG9zKys7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLlNJTVBMRVNUQVI6XG4gICAgICAgIHdoaWxlIChpbl9iaXRzZXQoY3Bvb2xbdWFyZ10sIGMpKVxuICAgICAgICAgIGMgPSBzWysrcG9zXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuU0lNUExFUExVUzpcbiAgICAgICAgaWYocG9zID09PSBzLmxlbmd0aCkge3ByZWZpeF9tYXRjaCAoKTsgYnJlYWt9O1xuICAgICAgICBpZiAoaW5fYml0c2V0KGNwb29sW3VhcmddLCBjKSkge1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIGMgPSBzWysrcG9zXTtcbiAgICAgICAgICB9IHdoaWxlIChpbl9iaXRzZXQoY3Bvb2xbdWFyZ10sIGMpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGJhY2t0cmFjaygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5BQ0NFUFQ6XG4gICAgICAgIHJldHVybiBhY2NlcHQoKTtcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5HT1RPOlxuICAgICAgICBwYyA9IHBjICsgc2FyZztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuUFVTSEJBQ0s6XG4gICAgICAgIHB1c2goe3Bvczoge3BjOiBwYyArIHNhcmcsIHR4dDogcG9zfX0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5TRVRNQVJLOlxuICAgICAgICBwdXNoKHt1bmRvOiB7b2JqOnJlX3JlZ2lzdGVyLFxuICAgICAgICAgICAgICAgICAgICAgcHJvcDogdWFyZyxcbiAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiByZV9yZWdpc3Rlclt1YXJnXX19KTtcbiAgICAgICAgcmVfcmVnaXN0ZXJbdWFyZ10gPSBwb3M7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLkNIRUNLUFJPR1JFU1M6XG4gICAgICAgIGlmIChyZV9yZWdpc3Rlclt1YXJnXSA9PT0gcG9zKSBiYWNrdHJhY2soKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGJ5dGVjb2RlXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHJldHVybiByZV9tYXRjaF9pbXBsO1xufSgpO1xuXG5cbi8vUHJvdmlkZXM6IHJlX3NlYXJjaF9mb3J3YXJkXG4vL1JlcXVpcmVzOiByZV9tYXRjaCwgY2FtbF9tbF9zdHJpbmdfbGVuZ3RoLCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIHJlX3NlYXJjaF9mb3J3YXJkKHJlLCBzLCBwb3MpIHtcbiAgaWYocG9zIDwgMCB8fCBwb3MgPiBjYW1sX21sX3N0cmluZ19sZW5ndGgocykpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiU3RyLnNlYXJjaF9mb3J3YXJkXCIpXG4gIHdoaWxlIChwb3MgPD0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpKSB7XG4gICAgdmFyIHJlcyA9IHJlX21hdGNoKHJlLCBzLCBwb3MsIDApO1xuICAgIGlmIChyZXMpIHJldHVybiByZXM7XG4gICAgcG9zKys7XG4gIH1cblxuICByZXR1cm4gWzBdOyAgLyogW3x8XSA6IGludCBhcnJheSAqL1xufVxuXG4vL1Byb3ZpZGVzOiByZV9zZWFyY2hfYmFja3dhcmRcbi8vUmVxdWlyZXM6IHJlX21hdGNoLCBjYW1sX21sX3N0cmluZ19sZW5ndGgsIGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gcmVfc2VhcmNoX2JhY2t3YXJkKHJlLCBzLCBwb3MpIHtcbiAgaWYocG9zIDwgMCB8fCBwb3MgPiBjYW1sX21sX3N0cmluZ19sZW5ndGgocykpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiU3RyLnNlYXJjaF9iYWNrd2FyZFwiKVxuICB3aGlsZSAocG9zID49IDApIHtcbiAgICB2YXIgcmVzID0gcmVfbWF0Y2gocmUsIHMsIHBvcywgMCk7XG4gICAgaWYgKHJlcykgcmV0dXJuIHJlcztcbiAgICBwb3MtLTtcbiAgfVxuXG4gIHJldHVybiBbMF07ICAvKiBbfHxdIDogaW50IGFycmF5ICovXG59XG5cblxuLy9Qcm92aWRlczogcmVfc3RyaW5nX21hdGNoXG4vL1JlcXVpcmVzOiByZV9tYXRjaCwgY2FtbF9tbF9zdHJpbmdfbGVuZ3RoLCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIHJlX3N0cmluZ19tYXRjaChyZSxzLHBvcyl7XG4gIGlmKHBvcyA8IDAgfHwgcG9zID4gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIlN0ci5zdHJpbmdfbWF0Y2hcIilcbiAgdmFyIHJlcyA9IHJlX21hdGNoKHJlLCBzLCBwb3MsIDApO1xuICBpZiAocmVzKSByZXR1cm4gcmVzO1xuICBlbHNlIHJldHVybiBbMF07XG59XG5cbi8vUHJvdmlkZXM6IHJlX3BhcnRpYWxfbWF0Y2hcbi8vUmVxdWlyZXM6IHJlX21hdGNoLCBjYW1sX21sX3N0cmluZ19sZW5ndGgsIGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gcmVfcGFydGlhbF9tYXRjaChyZSxzLHBvcyl7XG4gIGlmKHBvcyA8IDAgfHwgcG9zID4gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIlN0ci5wYXJ0aWFsX21hdGNoXCIpXG4gIHZhciByZXMgPSByZV9tYXRjaChyZSwgcywgcG9zLCAxKTtcbiAgaWYgKHJlcykgcmV0dXJuIHJlcztcbiAgZWxzZSByZXR1cm4gWzBdO1xufVxuXG4vL1Byb3ZpZGVzOiByZV9yZXBsYWNlbWVudF90ZXh0XG4vL1JlcXVpcmVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2dldFxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuLy8gZXh0ZXJuYWwgcmVfcmVwbGFjZW1lbnRfdGV4dDogc3RyaW5nIC0+IGludCBhcnJheSAtPiBzdHJpbmcgLT4gc3RyaW5nXG5mdW5jdGlvbiByZV9yZXBsYWNlbWVudF90ZXh0KHJlcGwsZ3JvdXBzLG9yaWcpIHtcbiAgdmFyIHJlcGwgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKHJlcGwpO1xuICB2YXIgbGVuID0gcmVwbC5sZW5ndGg7XG4gIHZhciBvcmlnID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhvcmlnKTtcbiAgdmFyIHJlcyA9IFwiXCI7IC8vcmVzdWx0XG4gIHZhciBuID0gMDsgLy8gY3VycmVudCBwb3NpdGlvblxuICB2YXIgY3VyOyAvL2N1cnJlbnQgY2hhclxuICB2YXIgc3RhcnQsIGVuZCwgYztcbiAgd2hpbGUobiA8IGxlbil7XG4gICAgY3VyID0gcmVwbC5jaGFyQXQobisrKTtcbiAgICBpZihjdXIgIT0gJ1xcXFwnKXtcbiAgICAgIHJlcyArPSBjdXI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaWYobiA9PSBsZW4pIGNhbWxfZmFpbHdpdGgoXCJTdHIucmVwbGFjZTogaWxsZWdhbCBiYWNrc2xhc2ggc2VxdWVuY2VcIik7XG4gICAgICBjdXIgPSByZXBsLmNoYXJBdChuKyspO1xuICAgICAgc3dpdGNoKGN1cil7XG4gICAgICBjYXNlICdcXFxcJzpcbiAgICAgICAgcmVzICs9IGN1cjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICcwJzogY2FzZSAnMSc6IGNhc2UgJzInOiBjYXNlICczJzogY2FzZSAnNCc6XG4gICAgICBjYXNlICc1JzogY2FzZSAnNic6IGNhc2UgJzcnOiBjYXNlICc4JzogY2FzZSAnOSc6XG4gICAgICAgIGMgPSArY3VyO1xuICAgICAgICBpZiAoYyoyID49IGdyb3Vwcy5sZW5ndGggLSAxIClcbiAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwiU3RyLnJlcGxhY2U6IHJlZmVyZW5jZSB0byB1bm1hdGNoZWQgZ3JvdXBcIiApO1xuICAgICAgICBzdGFydCA9IGNhbWxfYXJyYXlfZ2V0KGdyb3VwcyxjKjIpO1xuICAgICAgICBlbmQgPSBjYW1sX2FycmF5X2dldChncm91cHMsIGMqMiArMSk7XG4gICAgICAgIGlmIChzdGFydCA9PSAtMSlcbiAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwiU3RyLnJlcGxhY2U6IHJlZmVyZW5jZSB0byB1bm1hdGNoZWQgZ3JvdXBcIik7XG4gICAgICAgIHJlcys9b3JpZy5zbGljZShzdGFydCxlbmQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJlcyArPSAoJ1xcXFwnICArIGN1cik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKHJlcyk7IH1cbiIsIi8vVGhlIGZvbGxvd2luZyBhcmUgZGVmaW5lZCBpbiBDc3RydWN0XG4vL1RoZXJlIGFyZSBqdXN0IHByb3ZpZGVkIGhlcmUgZm9yIGNvbXBhdGliaWxpdHkgcmVhc29uc1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2JsaXRfYmlnc3RyaW5nX3RvX2JpZ3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19iYVxuLy9XZWFrZGVmXG52YXIgY2FtbF9ibGl0X2JpZ3N0cmluZ190b19iaWdzdHJpbmcgPSBjYW1sX2JpZ3N0cmluZ19ibGl0X2JhX3RvX2JhXG4vL1Byb3ZpZGVzOiBjYW1sX2JsaXRfYmlnc3RyaW5nX3RvX3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19ieXRlc1xuLy9XZWFrZGVmXG52YXIgY2FtbF9ibGl0X2JpZ3N0cmluZ190b19zdHJpbmcgPSBjYW1sX2JpZ3N0cmluZ19ibGl0X2JhX3RvX2J5dGVzXG4vL1Byb3ZpZGVzOiBjYW1sX2JsaXRfc3RyaW5nX3RvX2JpZ3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9iaWdzdHJpbmdfYmxpdF9zdHJpbmdfdG9fYmFcbi8vV2Vha2RlZlxudmFyIGNhbWxfYmxpdF9zdHJpbmdfdG9fYmlnc3RyaW5nID0gY2FtbF9iaWdzdHJpbmdfYmxpdF9zdHJpbmdfdG9fYmFcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgRGFuaWVsIEMuIEJ1ZW56bGkgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMTQgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuZXh0ZXJuYWwgZm9ybWF0X2ludCA6IHN0cmluZyAtPiBpbnQgLT4gc3RyaW5nID0gXCJjYW1sX2Zvcm1hdF9pbnRcIlxuXG5sZXQgZXJyX25vX3ByZWQgPSBcIlUrMDAwMCBoYXMgbm8gcHJlZGVjZXNzb3JcIlxubGV0IGVycl9ub19zdWNjID0gXCJVKzEwRkZGRiBoYXMgbm8gc3VjY2Vzc29yXCJcbmxldCBlcnJfbm90X3N2IGkgPSBmb3JtYXRfaW50IFwiJVhcIiBpIF4gXCIgaXMgbm90IGFuIFVuaWNvZGUgc2NhbGFyIHZhbHVlXCJcbmxldCBlcnJfbm90X2xhdGluMSB1ID0gXCJVK1wiIF4gZm9ybWF0X2ludCBcIiUwNFhcIiB1IF4gXCIgaXMgbm90IGEgbGF0aW4xIGNoYXJhY3RlclwiXG5cbnR5cGUgdCA9IGludFxuXG5sZXQgbWluID0gMHgwMDAwXG5sZXQgbWF4ID0gMHgxMEZGRkZcbmxldCBsb19ib3VuZCA9IDB4RDdGRlxubGV0IGhpX2JvdW5kID0gMHhFMDAwXG5cbmxldCBib20gPSAweEZFRkZcbmxldCByZXAgPSAweEZGRkRcblxubGV0IHN1Y2MgdSA9XG4gIGlmIHUgPSBsb19ib3VuZCB0aGVuIGhpX2JvdW5kIGVsc2VcbiAgaWYgdSA9IG1heCB0aGVuIGludmFsaWRfYXJnIGVycl9ub19zdWNjIGVsc2VcbiAgdSArIDFcblxubGV0IHByZWQgdSA9XG4gIGlmIHUgPSBoaV9ib3VuZCB0aGVuIGxvX2JvdW5kIGVsc2VcbiAgaWYgdSA9IG1pbiB0aGVuIGludmFsaWRfYXJnIGVycl9ub19wcmVkIGVsc2VcbiAgdSAtIDFcblxubGV0IGlzX3ZhbGlkIGkgPSAobWluIDw9IGkgJiYgaSA8PSBsb19ib3VuZCkgfHwgKGhpX2JvdW5kIDw9IGkgJiYgaSA8PSBtYXgpXG5sZXQgb2ZfaW50IGkgPSBpZiBpc192YWxpZCBpIHRoZW4gaSBlbHNlIGludmFsaWRfYXJnIChlcnJfbm90X3N2IGkpXG5leHRlcm5hbCB1bnNhZmVfb2ZfaW50IDogaW50IC0+IHQgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCB0b19pbnQgOiB0IC0+IGludCA9IFwiJWlkZW50aXR5XCJcblxubGV0IGlzX2NoYXIgdSA9IHUgPCAyNTZcbmxldCBvZl9jaGFyIGMgPSBDaGFyLmNvZGUgY1xubGV0IHRvX2NoYXIgdSA9XG4gIGlmIHUgPiAyNTUgdGhlbiBpbnZhbGlkX2FyZyAoZXJyX25vdF9sYXRpbjEgdSkgZWxzZVxuICBDaGFyLnVuc2FmZV9jaHIgdVxuXG5sZXQgdW5zYWZlX3RvX2NoYXIgPSBDaGFyLnVuc2FmZV9jaHJcblxubGV0IGVxdWFsIDogaW50IC0+IGludCAtPiBib29sID0gKCA9IClcbmxldCBjb21wYXJlIDogaW50IC0+IGludCAtPiBpbnQgPSBTdGRsaWIuY29tcGFyZVxubGV0IGhhc2ggPSB0b19pbnRcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogTW9kdWxlIFtJbnQ2NF06IDY0LWJpdCBpbnRlZ2VycyAqKVxuXG5leHRlcm5hbCBuZWcgOiBpbnQ2NCAtPiBpbnQ2NCA9IFwiJWludDY0X25lZ1wiXG5leHRlcm5hbCBhZGQgOiBpbnQ2NCAtPiBpbnQ2NCAtPiBpbnQ2NCA9IFwiJWludDY0X2FkZFwiXG5leHRlcm5hbCBzdWIgOiBpbnQ2NCAtPiBpbnQ2NCAtPiBpbnQ2NCA9IFwiJWludDY0X3N1YlwiXG5leHRlcm5hbCBtdWwgOiBpbnQ2NCAtPiBpbnQ2NCAtPiBpbnQ2NCA9IFwiJWludDY0X211bFwiXG5leHRlcm5hbCBkaXYgOiBpbnQ2NCAtPiBpbnQ2NCAtPiBpbnQ2NCA9IFwiJWludDY0X2RpdlwiXG5leHRlcm5hbCByZW0gOiBpbnQ2NCAtPiBpbnQ2NCAtPiBpbnQ2NCA9IFwiJWludDY0X21vZFwiXG5leHRlcm5hbCBsb2dhbmQgOiBpbnQ2NCAtPiBpbnQ2NCAtPiBpbnQ2NCA9IFwiJWludDY0X2FuZFwiXG5leHRlcm5hbCBsb2dvciA6IGludDY0IC0+IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfb3JcIlxuZXh0ZXJuYWwgbG9neG9yIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF94b3JcIlxuZXh0ZXJuYWwgc2hpZnRfbGVmdCA6IGludDY0IC0+IGludCAtPiBpbnQ2NCA9IFwiJWludDY0X2xzbFwiXG5leHRlcm5hbCBzaGlmdF9yaWdodCA6IGludDY0IC0+IGludCAtPiBpbnQ2NCA9IFwiJWludDY0X2FzclwiXG5leHRlcm5hbCBzaGlmdF9yaWdodF9sb2dpY2FsIDogaW50NjQgLT4gaW50IC0+IGludDY0ID0gXCIlaW50NjRfbHNyXCJcbmV4dGVybmFsIG9mX2ludCA6IGludCAtPiBpbnQ2NCA9IFwiJWludDY0X29mX2ludFwiXG5leHRlcm5hbCB0b19pbnQgOiBpbnQ2NCAtPiBpbnQgPSBcIiVpbnQ2NF90b19pbnRcIlxuZXh0ZXJuYWwgb2ZfZmxvYXQgOiBmbG9hdCAtPiBpbnQ2NFxuICA9IFwiY2FtbF9pbnQ2NF9vZl9mbG9hdFwiIFwiY2FtbF9pbnQ2NF9vZl9mbG9hdF91bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHRvX2Zsb2F0IDogaW50NjQgLT4gZmxvYXRcbiAgPSBcImNhbWxfaW50NjRfdG9fZmxvYXRcIiBcImNhbWxfaW50NjRfdG9fZmxvYXRfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBvZl9pbnQzMiA6IGludDMyIC0+IGludDY0ID0gXCIlaW50NjRfb2ZfaW50MzJcIlxuZXh0ZXJuYWwgdG9faW50MzIgOiBpbnQ2NCAtPiBpbnQzMiA9IFwiJWludDY0X3RvX2ludDMyXCJcbmV4dGVybmFsIG9mX25hdGl2ZWludCA6IG5hdGl2ZWludCAtPiBpbnQ2NCA9IFwiJWludDY0X29mX25hdGl2ZWludFwiXG5leHRlcm5hbCB0b19uYXRpdmVpbnQgOiBpbnQ2NCAtPiBuYXRpdmVpbnQgPSBcIiVpbnQ2NF90b19uYXRpdmVpbnRcIlxuXG5sZXQgemVybyA9IDBMXG5sZXQgb25lID0gMUxcbmxldCBtaW51c19vbmUgPSAtMUxcbmxldCBzdWNjIG4gPSBhZGQgbiAxTFxubGV0IHByZWQgbiA9IHN1YiBuIDFMXG5sZXQgYWJzIG4gPSBpZiBuID49IDBMIHRoZW4gbiBlbHNlIG5lZyBuXG5sZXQgbWluX2ludCA9IDB4ODAwMDAwMDAwMDAwMDAwMExcbmxldCBtYXhfaW50ID0gMHg3RkZGRkZGRkZGRkZGRkZGTFxubGV0IGxvZ25vdCBuID0gbG9neG9yIG4gKC0xTClcblxubGV0IHVuc2lnbmVkX3RvX2ludCA9XG4gIGxldCBtYXhfaW50ID0gb2ZfaW50IFN0ZGxpYi5tYXhfaW50IGluXG4gIGZ1biBuIC0+XG4gICAgaWYgY29tcGFyZSB6ZXJvIG4gPD0gMCAmJiBjb21wYXJlIG4gbWF4X2ludCA8PSAwIHRoZW5cbiAgICAgIFNvbWUgKHRvX2ludCBuKVxuICAgIGVsc2VcbiAgICAgIE5vbmVcblxuZXh0ZXJuYWwgZm9ybWF0IDogc3RyaW5nIC0+IGludDY0IC0+IHN0cmluZyA9IFwiY2FtbF9pbnQ2NF9mb3JtYXRcIlxubGV0IHRvX3N0cmluZyBuID0gZm9ybWF0IFwiJWRcIiBuXG5cbmV4dGVybmFsIG9mX3N0cmluZyA6IHN0cmluZyAtPiBpbnQ2NCA9IFwiY2FtbF9pbnQ2NF9vZl9zdHJpbmdcIlxuXG5sZXQgb2Zfc3RyaW5nX29wdCBzID1cbiAgKCogVE9ETzogZXhwb3NlIGEgbm9uLXJhaXNpbmcgcHJpbWl0aXZlIGRpcmVjdGx5LiAqKVxuICB0cnkgU29tZSAob2Zfc3RyaW5nIHMpXG4gIHdpdGggRmFpbHVyZSBfIC0+IE5vbmVcblxuXG5cbmV4dGVybmFsIGJpdHNfb2ZfZmxvYXQgOiBmbG9hdCAtPiBpbnQ2NFxuICA9IFwiY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0XCIgXCJjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXRfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBmbG9hdF9vZl9iaXRzIDogaW50NjQgLT4gZmxvYXRcbiAgPSBcImNhbWxfaW50NjRfZmxvYXRfb2ZfYml0c1wiIFwiY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzX3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuXG50eXBlIHQgPSBpbnQ2NFxuXG5sZXQgY29tcGFyZSAoeDogdCkgKHk6IHQpID0gU3RkbGliLmNvbXBhcmUgeCB5XG5sZXQgZXF1YWwgKHg6IHQpICh5OiB0KSA9IGNvbXBhcmUgeCB5ID0gMFxuXG5sZXQgdW5zaWduZWRfY29tcGFyZSBuIG0gPVxuICBjb21wYXJlIChzdWIgbiBtaW5faW50KSAoc3ViIG0gbWluX2ludClcblxuKCogVW5zaWduZWQgZGl2aXNpb24gZnJvbSBzaWduZWQgZGl2aXNpb24gb2YgdGhlIHNhbWVcbiAgIGJpdG5lc3MuIFNlZSBXYXJyZW4gSnIuLCBIZW5yeSBTLiAoMjAxMykuIEhhY2tlcidzIERlbGlnaHQgKDIgZWQuKSwgU2VjIDktMy5cbiopXG5sZXQgdW5zaWduZWRfZGl2IG4gZCA9XG4gIGlmIGQgPCB6ZXJvIHRoZW5cbiAgICBpZiB1bnNpZ25lZF9jb21wYXJlIG4gZCA8IDAgdGhlbiB6ZXJvIGVsc2Ugb25lXG4gIGVsc2VcbiAgICBsZXQgcSA9IHNoaWZ0X2xlZnQgKGRpdiAoc2hpZnRfcmlnaHRfbG9naWNhbCBuIDEpIGQpIDEgaW5cbiAgICBsZXQgciA9IHN1YiBuIChtdWwgcSBkKSBpblxuICAgIGlmIHVuc2lnbmVkX2NvbXBhcmUgciBkID49IDAgdGhlbiBzdWNjIHEgZWxzZSBxXG5cbmxldCB1bnNpZ25lZF9yZW0gbiBkID1cbiAgc3ViIG4gKG11bCAodW5zaWduZWRfZGl2IG4gZCkgZClcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogVGhlIHJ1bi10aW1lIGxpYnJhcnkgZm9yIGxleGVycyBnZW5lcmF0ZWQgYnkgY2FtbGxleCAqKVxuXG50eXBlIHBvc2l0aW9uID0ge1xuICBwb3NfZm5hbWUgOiBzdHJpbmc7XG4gIHBvc19sbnVtIDogaW50O1xuICBwb3NfYm9sIDogaW50O1xuICBwb3NfY251bSA6IGludDtcbn1cblxubGV0IGR1bW15X3BvcyA9IHtcbiAgcG9zX2ZuYW1lID0gXCJcIjtcbiAgcG9zX2xudW0gPSAwO1xuICBwb3NfYm9sID0gMDtcbiAgcG9zX2NudW0gPSAtMTtcbn1cblxudHlwZSBsZXhidWYgPVxuICB7IHJlZmlsbF9idWZmIDogbGV4YnVmIC0+IHVuaXQ7XG4gICAgbXV0YWJsZSBsZXhfYnVmZmVyIDogYnl0ZXM7XG4gICAgbXV0YWJsZSBsZXhfYnVmZmVyX2xlbiA6IGludDtcbiAgICBtdXRhYmxlIGxleF9hYnNfcG9zIDogaW50O1xuICAgIG11dGFibGUgbGV4X3N0YXJ0X3BvcyA6IGludDtcbiAgICBtdXRhYmxlIGxleF9jdXJyX3BvcyA6IGludDtcbiAgICBtdXRhYmxlIGxleF9sYXN0X3BvcyA6IGludDtcbiAgICBtdXRhYmxlIGxleF9sYXN0X2FjdGlvbiA6IGludDtcbiAgICBtdXRhYmxlIGxleF9lb2ZfcmVhY2hlZCA6IGJvb2w7XG4gICAgbXV0YWJsZSBsZXhfbWVtIDogaW50IGFycmF5O1xuICAgIG11dGFibGUgbGV4X3N0YXJ0X3AgOiBwb3NpdGlvbjtcbiAgICBtdXRhYmxlIGxleF9jdXJyX3AgOiBwb3NpdGlvbjtcbiAgfVxuXG50eXBlIGxleF90YWJsZXMgPVxuICB7IGxleF9iYXNlOiBzdHJpbmc7XG4gICAgbGV4X2JhY2t0cms6IHN0cmluZztcbiAgICBsZXhfZGVmYXVsdDogc3RyaW5nO1xuICAgIGxleF90cmFuczogc3RyaW5nO1xuICAgIGxleF9jaGVjazogc3RyaW5nO1xuICAgIGxleF9iYXNlX2NvZGUgOiBzdHJpbmc7XG4gICAgbGV4X2JhY2t0cmtfY29kZSA6IHN0cmluZztcbiAgICBsZXhfZGVmYXVsdF9jb2RlIDogc3RyaW5nO1xuICAgIGxleF90cmFuc19jb2RlIDogc3RyaW5nO1xuICAgIGxleF9jaGVja19jb2RlIDogc3RyaW5nO1xuICAgIGxleF9jb2RlOiBzdHJpbmc7fVxuXG5leHRlcm5hbCBjX2VuZ2luZSA6IGxleF90YWJsZXMgLT4gaW50IC0+IGxleGJ1ZiAtPiBpbnQgPSBcImNhbWxfbGV4X2VuZ2luZVwiXG5leHRlcm5hbCBjX25ld19lbmdpbmUgOiBsZXhfdGFibGVzIC0+IGludCAtPiBsZXhidWYgLT4gaW50XG4gICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfbmV3X2xleF9lbmdpbmVcIlxuXG5sZXQgZW5naW5lIHRibCBzdGF0ZSBidWYgPVxuICBsZXQgcmVzdWx0ID0gY19lbmdpbmUgdGJsIHN0YXRlIGJ1ZiBpblxuICBpZiByZXN1bHQgPj0gMCAmJiBidWYubGV4X2N1cnJfcCAhPSBkdW1teV9wb3MgdGhlbiBiZWdpblxuICAgIGJ1Zi5sZXhfc3RhcnRfcCA8LSBidWYubGV4X2N1cnJfcDtcbiAgICBidWYubGV4X2N1cnJfcCA8LSB7YnVmLmxleF9jdXJyX3BcbiAgICAgICAgICAgICAgICAgICAgICAgd2l0aCBwb3NfY251bSA9IGJ1Zi5sZXhfYWJzX3BvcyArIGJ1Zi5sZXhfY3Vycl9wb3N9O1xuICBlbmQ7XG4gIHJlc3VsdFxuXG5cbmxldCBuZXdfZW5naW5lIHRibCBzdGF0ZSBidWYgPVxuICBsZXQgcmVzdWx0ID0gY19uZXdfZW5naW5lIHRibCBzdGF0ZSBidWYgaW5cbiAgaWYgcmVzdWx0ID49IDAgJiYgYnVmLmxleF9jdXJyX3AgIT0gZHVtbXlfcG9zIHRoZW4gYmVnaW5cbiAgICBidWYubGV4X3N0YXJ0X3AgPC0gYnVmLmxleF9jdXJyX3A7XG4gICAgYnVmLmxleF9jdXJyX3AgPC0ge2J1Zi5sZXhfY3Vycl9wXG4gICAgICAgICAgICAgICAgICAgICAgIHdpdGggcG9zX2NudW0gPSBidWYubGV4X2Fic19wb3MgKyBidWYubGV4X2N1cnJfcG9zfTtcbiAgZW5kO1xuICByZXN1bHRcblxuXG5sZXQgbGV4X3JlZmlsbCByZWFkX2Z1biBhdXhfYnVmZmVyIGxleGJ1ZiA9XG4gIGxldCByZWFkID1cbiAgICByZWFkX2Z1biBhdXhfYnVmZmVyIChCeXRlcy5sZW5ndGggYXV4X2J1ZmZlcikgaW5cbiAgbGV0IG4gPVxuICAgIGlmIHJlYWQgPiAwXG4gICAgdGhlbiByZWFkXG4gICAgZWxzZSAobGV4YnVmLmxleF9lb2ZfcmVhY2hlZCA8LSB0cnVlOyAwKSBpblxuICAoKiBDdXJyZW50IHN0YXRlIG9mIHRoZSBidWZmZXI6XG4gICAgICAgIDwtLS0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLT5cbiAgICAgICAgfCAganVuayB8ICAgICAgdmFsaWQgZGF0YSAgICAgfCAgIGp1bmsgICAgfFxuICAgICAgICBeICAgICAgIF4gICAgICAgICAgICAgICAgICAgICBeICAgICAgICAgICBeXG4gICAgICAgIDAgICAgc3RhcnRfcG9zICAgICAgICAgICAgIGJ1ZmZlcl9lbmQgICAgQnl0ZXMubGVuZ3RoIGJ1ZmZlclxuICAqKVxuICBpZiBsZXhidWYubGV4X2J1ZmZlcl9sZW4gKyBuID4gQnl0ZXMubGVuZ3RoIGxleGJ1Zi5sZXhfYnVmZmVyIHRoZW4gYmVnaW5cbiAgICAoKiBUaGVyZSBpcyBub3QgZW5vdWdoIHNwYWNlIGF0IHRoZSBlbmQgb2YgdGhlIGJ1ZmZlciAqKVxuICAgIGlmIGxleGJ1Zi5sZXhfYnVmZmVyX2xlbiAtIGxleGJ1Zi5sZXhfc3RhcnRfcG9zICsgblxuICAgICAgIDw9IEJ5dGVzLmxlbmd0aCBsZXhidWYubGV4X2J1ZmZlclxuICAgIHRoZW4gYmVnaW5cbiAgICAgICgqIEJ1dCB0aGVyZSBpcyBlbm91Z2ggc3BhY2UgaWYgd2UgcmVjbGFpbSB0aGUganVuayBhdCB0aGUgYmVnaW5uaW5nXG4gICAgICAgICBvZiB0aGUgYnVmZmVyICopXG4gICAgICBCeXRlcy5ibGl0IGxleGJ1Zi5sZXhfYnVmZmVyIGxleGJ1Zi5sZXhfc3RhcnRfcG9zXG4gICAgICAgICAgICAgICAgICBsZXhidWYubGV4X2J1ZmZlciAwXG4gICAgICAgICAgICAgICAgICAobGV4YnVmLmxleF9idWZmZXJfbGVuIC0gbGV4YnVmLmxleF9zdGFydF9wb3MpXG4gICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICgqIFdlIG11c3QgZ3JvdyB0aGUgYnVmZmVyLiAgRG91YmxpbmcgaXRzIHNpemUgd2lsbCBwcm92aWRlIGVub3VnaFxuICAgICAgICAgc3BhY2Ugc2luY2UgbiA8PSBTdHJpbmcubGVuZ3RoIGF1eF9idWZmZXIgPD0gU3RyaW5nLmxlbmd0aCBidWZmZXIuXG4gICAgICAgICBXYXRjaCBvdXQgZm9yIHN0cmluZyBsZW5ndGggb3ZlcmZsb3csIHRob3VnaC4gKilcbiAgICAgIGxldCBuZXdsZW4gPVxuICAgICAgICBtaW4gKDIgKiBCeXRlcy5sZW5ndGggbGV4YnVmLmxleF9idWZmZXIpIFN5cy5tYXhfc3RyaW5nX2xlbmd0aCBpblxuICAgICAgaWYgbGV4YnVmLmxleF9idWZmZXJfbGVuIC0gbGV4YnVmLmxleF9zdGFydF9wb3MgKyBuID4gbmV3bGVuXG4gICAgICB0aGVuIGZhaWx3aXRoIFwiTGV4aW5nLmxleF9yZWZpbGw6IGNhbm5vdCBncm93IGJ1ZmZlclwiO1xuICAgICAgbGV0IG5ld2J1ZiA9IEJ5dGVzLmNyZWF0ZSBuZXdsZW4gaW5cbiAgICAgICgqIENvcHkgdGhlIHZhbGlkIGRhdGEgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgbmV3IGJ1ZmZlciAqKVxuICAgICAgQnl0ZXMuYmxpdCBsZXhidWYubGV4X2J1ZmZlciBsZXhidWYubGV4X3N0YXJ0X3Bvc1xuICAgICAgICAgICAgICAgICAgbmV3YnVmIDBcbiAgICAgICAgICAgICAgICAgIChsZXhidWYubGV4X2J1ZmZlcl9sZW4gLSBsZXhidWYubGV4X3N0YXJ0X3Bvcyk7XG4gICAgICBsZXhidWYubGV4X2J1ZmZlciA8LSBuZXdidWZcbiAgICBlbmQ7XG4gICAgKCogUmVhbGxvY2F0aW9uIG9yIG5vdCwgd2UgaGF2ZSBzaGlmdGVkIHRoZSBkYXRhIGxlZnQgYnlcbiAgICAgICBzdGFydF9wb3MgY2hhcmFjdGVyczsgdXBkYXRlIHRoZSBwb3NpdGlvbnMgKilcbiAgICBsZXQgcyA9IGxleGJ1Zi5sZXhfc3RhcnRfcG9zIGluXG4gICAgbGV4YnVmLmxleF9hYnNfcG9zIDwtIGxleGJ1Zi5sZXhfYWJzX3BvcyArIHM7XG4gICAgbGV4YnVmLmxleF9jdXJyX3BvcyA8LSBsZXhidWYubGV4X2N1cnJfcG9zIC0gcztcbiAgICBsZXhidWYubGV4X3N0YXJ0X3BvcyA8LSAwO1xuICAgIGxleGJ1Zi5sZXhfbGFzdF9wb3MgPC0gbGV4YnVmLmxleF9sYXN0X3BvcyAtIHM7XG4gICAgbGV4YnVmLmxleF9idWZmZXJfbGVuIDwtIGxleGJ1Zi5sZXhfYnVmZmVyX2xlbiAtIHMgO1xuICAgIGxldCB0ID0gbGV4YnVmLmxleF9tZW0gaW5cbiAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIHQtMSBkb1xuICAgICAgbGV0IHYgPSB0LihpKSBpblxuICAgICAgaWYgdiA+PSAwIHRoZW5cbiAgICAgICAgdC4oaSkgPC0gdi1zXG4gICAgZG9uZVxuICBlbmQ7XG4gICgqIFRoZXJlIGlzIG5vdyBlbm91Z2ggc3BhY2UgYXQgdGhlIGVuZCBvZiB0aGUgYnVmZmVyICopXG4gIEJ5dGVzLmJsaXQgYXV4X2J1ZmZlciAwIGxleGJ1Zi5sZXhfYnVmZmVyIGxleGJ1Zi5sZXhfYnVmZmVyX2xlbiBuO1xuICBsZXhidWYubGV4X2J1ZmZlcl9sZW4gPC0gbGV4YnVmLmxleF9idWZmZXJfbGVuICsgblxuXG5sZXQgemVyb19wb3MgPSB7XG4gIHBvc19mbmFtZSA9IFwiXCI7XG4gIHBvc19sbnVtID0gMTtcbiAgcG9zX2JvbCA9IDA7XG4gIHBvc19jbnVtID0gMDtcbn1cblxubGV0IGZyb21fZnVuY3Rpb24gPyh3aXRoX3Bvc2l0aW9ucyA9IHRydWUpIGYgPVxuICB7IHJlZmlsbF9idWZmID0gbGV4X3JlZmlsbCBmIChCeXRlcy5jcmVhdGUgNTEyKTtcbiAgICBsZXhfYnVmZmVyID0gQnl0ZXMuY3JlYXRlIDEwMjQ7XG4gICAgbGV4X2J1ZmZlcl9sZW4gPSAwO1xuICAgIGxleF9hYnNfcG9zID0gMDtcbiAgICBsZXhfc3RhcnRfcG9zID0gMDtcbiAgICBsZXhfY3Vycl9wb3MgPSAwO1xuICAgIGxleF9sYXN0X3BvcyA9IDA7XG4gICAgbGV4X2xhc3RfYWN0aW9uID0gMDtcbiAgICBsZXhfbWVtID0gW3x8XTtcbiAgICBsZXhfZW9mX3JlYWNoZWQgPSBmYWxzZTtcbiAgICBsZXhfc3RhcnRfcCA9IGlmIHdpdGhfcG9zaXRpb25zIHRoZW4gemVyb19wb3MgZWxzZSBkdW1teV9wb3M7XG4gICAgbGV4X2N1cnJfcCA9IGlmIHdpdGhfcG9zaXRpb25zIHRoZW4gemVyb19wb3MgZWxzZSBkdW1teV9wb3M7XG4gIH1cblxubGV0IGZyb21fY2hhbm5lbCA/d2l0aF9wb3NpdGlvbnMgaWMgPVxuICBmcm9tX2Z1bmN0aW9uID93aXRoX3Bvc2l0aW9ucyAoZnVuIGJ1ZiBuIC0+IGlucHV0IGljIGJ1ZiAwIG4pXG5cbmxldCBmcm9tX3N0cmluZyA/KHdpdGhfcG9zaXRpb25zID0gdHJ1ZSkgcyA9XG4gIHsgcmVmaWxsX2J1ZmYgPSAoZnVuIGxleGJ1ZiAtPiBsZXhidWYubGV4X2VvZl9yZWFjaGVkIDwtIHRydWUpO1xuICAgIGxleF9idWZmZXIgPSBCeXRlcy5vZl9zdHJpbmcgczsgKCogaGF2ZSB0byBtYWtlIGEgY29weSBmb3IgY29tcGF0aWJpbGl0eVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2l0aCB1bnNhZmUtc3RyaW5nIG1vZGUgKilcbiAgICBsZXhfYnVmZmVyX2xlbiA9IFN0cmluZy5sZW5ndGggcztcbiAgICBsZXhfYWJzX3BvcyA9IDA7XG4gICAgbGV4X3N0YXJ0X3BvcyA9IDA7XG4gICAgbGV4X2N1cnJfcG9zID0gMDtcbiAgICBsZXhfbGFzdF9wb3MgPSAwO1xuICAgIGxleF9sYXN0X2FjdGlvbiA9IDA7XG4gICAgbGV4X21lbSA9IFt8fF07XG4gICAgbGV4X2VvZl9yZWFjaGVkID0gdHJ1ZTtcbiAgICBsZXhfc3RhcnRfcCA9IGlmIHdpdGhfcG9zaXRpb25zIHRoZW4gemVyb19wb3MgZWxzZSBkdW1teV9wb3M7XG4gICAgbGV4X2N1cnJfcCA9IGlmIHdpdGhfcG9zaXRpb25zIHRoZW4gemVyb19wb3MgZWxzZSBkdW1teV9wb3M7XG4gIH1cblxubGV0IHNldF9wb3NpdGlvbiBsZXhidWYgcG9zaXRpb24gPVxuICBsZXhidWYubGV4X2N1cnJfcCAgPC0ge3Bvc2l0aW9uIHdpdGggcG9zX2ZuYW1lID0gbGV4YnVmLmxleF9jdXJyX3AucG9zX2ZuYW1lfTtcbiAgbGV4YnVmLmxleF9hYnNfcG9zIDwtIHBvc2l0aW9uLnBvc19jbnVtXG5cbmxldCBzZXRfZmlsZW5hbWUgbGV4YnVmIGZuYW1lID1cbiAgbGV4YnVmLmxleF9jdXJyX3AgPC0ge2xleGJ1Zi5sZXhfY3Vycl9wIHdpdGggcG9zX2ZuYW1lID0gZm5hbWV9XG5cbmxldCB3aXRoX3Bvc2l0aW9ucyBsZXhidWYgPSBsZXhidWYubGV4X2N1cnJfcCAhPSBkdW1teV9wb3NcblxubGV0IGxleGVtZSBsZXhidWYgPVxuICBsZXQgbGVuID0gbGV4YnVmLmxleF9jdXJyX3BvcyAtIGxleGJ1Zi5sZXhfc3RhcnRfcG9zIGluXG4gIEJ5dGVzLnN1Yl9zdHJpbmcgbGV4YnVmLmxleF9idWZmZXIgbGV4YnVmLmxleF9zdGFydF9wb3MgbGVuXG5cbmxldCBzdWJfbGV4ZW1lIGxleGJ1ZiBpMSBpMiA9XG4gIGxldCBsZW4gPSBpMi1pMSBpblxuICBCeXRlcy5zdWJfc3RyaW5nIGxleGJ1Zi5sZXhfYnVmZmVyIGkxIGxlblxuXG5sZXQgc3ViX2xleGVtZV9vcHQgbGV4YnVmIGkxIGkyID1cbiAgaWYgaTEgPj0gMCB0aGVuIGJlZ2luXG4gICAgbGV0IGxlbiA9IGkyLWkxIGluXG4gICAgU29tZSAoQnl0ZXMuc3ViX3N0cmluZyBsZXhidWYubGV4X2J1ZmZlciBpMSBsZW4pXG4gIGVuZCBlbHNlIGJlZ2luXG4gICAgTm9uZVxuICBlbmRcblxubGV0IHN1Yl9sZXhlbWVfY2hhciBsZXhidWYgaSA9IEJ5dGVzLmdldCBsZXhidWYubGV4X2J1ZmZlciBpXG5cbmxldCBzdWJfbGV4ZW1lX2NoYXJfb3B0IGxleGJ1ZiBpID1cbiAgaWYgaSA+PSAwIHRoZW5cbiAgICBTb21lIChCeXRlcy5nZXQgbGV4YnVmLmxleF9idWZmZXIgaSlcbiAgZWxzZVxuICAgIE5vbmVcblxuXG5sZXQgbGV4ZW1lX2NoYXIgbGV4YnVmIGkgPVxuICBCeXRlcy5nZXQgbGV4YnVmLmxleF9idWZmZXIgKGxleGJ1Zi5sZXhfc3RhcnRfcG9zICsgaSlcblxubGV0IGxleGVtZV9zdGFydCBsZXhidWYgPSBsZXhidWYubGV4X3N0YXJ0X3AucG9zX2NudW1cbmxldCBsZXhlbWVfZW5kIGxleGJ1ZiA9IGxleGJ1Zi5sZXhfY3Vycl9wLnBvc19jbnVtXG5cbmxldCBsZXhlbWVfc3RhcnRfcCBsZXhidWYgPSBsZXhidWYubGV4X3N0YXJ0X3BcbmxldCBsZXhlbWVfZW5kX3AgbGV4YnVmID0gbGV4YnVmLmxleF9jdXJyX3BcblxubGV0IG5ld19saW5lIGxleGJ1ZiA9XG4gIGxldCBsY3AgPSBsZXhidWYubGV4X2N1cnJfcCBpblxuICBpZiBsY3AgIT0gZHVtbXlfcG9zIHRoZW5cbiAgICBsZXhidWYubGV4X2N1cnJfcCA8LVxuICAgICAgeyBsY3Agd2l0aFxuICAgICAgICBwb3NfbG51bSA9IGxjcC5wb3NfbG51bSArIDE7XG4gICAgICAgIHBvc19ib2wgPSBsY3AucG9zX2NudW07XG4gICAgICB9XG5cblxuXG4oKiBEaXNjYXJkIGRhdGEgbGVmdCBpbiBsZXhlciBidWZmZXIuICopXG5cbmxldCBmbHVzaF9pbnB1dCBsYiA9XG4gIGxiLmxleF9jdXJyX3BvcyA8LSAwO1xuICBsYi5sZXhfYWJzX3BvcyA8LSAwO1xuICBsZXQgbGNwID0gbGIubGV4X2N1cnJfcCBpblxuICBpZiBsY3AgIT0gZHVtbXlfcG9zIHRoZW5cbiAgICBsYi5sZXhfY3Vycl9wIDwtIHt6ZXJvX3BvcyB3aXRoIHBvc19mbmFtZSA9IGxjcC5wb3NfZm5hbWV9O1xuICBsYi5sZXhfYnVmZmVyX2xlbiA8LSAwO1xuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgIEJlbm9pdCBWYXVnb24sIEVOU1RBICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxNCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5vcGVuIENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljc1xuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAoKiBUb29scyB0byBtYW5pcHVsYXRlIHNjYW5uaW5nIHNldCBvZiBjaGFycyAoc2VlICVbLi4uXSkgKilcblxudHlwZSBtdXRhYmxlX2NoYXJfc2V0ID0gYnl0ZXNcblxuKCogQ3JlYXRlIGEgZnJlc2gsIGVtcHR5LCBtdXRhYmxlIGNoYXIgc2V0LiAqKVxubGV0IGNyZWF0ZV9jaGFyX3NldCAoKSA9IEJ5dGVzLm1ha2UgMzIgJ1xcMDAwJ1xuXG4oKiBBZGQgYSBjaGFyIGluIGEgbXV0YWJsZSBjaGFyIHNldC4gKilcbmxldCBhZGRfaW5fY2hhcl9zZXQgY2hhcl9zZXQgYyA9XG4gIGxldCBpbmQgPSBpbnRfb2ZfY2hhciBjIGluXG4gIGxldCBzdHJfaW5kID0gaW5kIGxzciAzIGFuZCBtYXNrID0gMSBsc2wgKGluZCBsYW5kIDBiMTExKSBpblxuICBCeXRlcy5zZXQgY2hhcl9zZXQgc3RyX2luZFxuICAgIChjaGFyX29mX2ludCAoaW50X29mX2NoYXIgKEJ5dGVzLmdldCBjaGFyX3NldCBzdHJfaW5kKSBsb3IgbWFzaykpXG5cbmxldCBmcmVlemVfY2hhcl9zZXQgY2hhcl9zZXQgPVxuICBCeXRlcy50b19zdHJpbmcgY2hhcl9zZXRcblxuKCogQ29tcHV0ZSB0aGUgY29tcGxlbWVudCBvZiBhIGNoYXIgc2V0LiAqKVxubGV0IHJldl9jaGFyX3NldCBjaGFyX3NldCA9XG4gIGxldCBjaGFyX3NldCcgPSBjcmVhdGVfY2hhcl9zZXQgKCkgaW5cbiAgZm9yIGkgPSAwIHRvIDMxIGRvXG4gICAgQnl0ZXMuc2V0IGNoYXJfc2V0JyBpXG4gICAgICAoY2hhcl9vZl9pbnQgKGludF9vZl9jaGFyIChTdHJpbmcuZ2V0IGNoYXJfc2V0IGkpIGx4b3IgMHhGRikpO1xuICBkb25lO1xuICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIGNoYXJfc2V0J1xuXG4oKiBSZXR1cm4gdHJ1ZSBpZiBhIGBjJyBpcyBpbiBgY2hhcl9zZXQnLiAqKVxubGV0IGlzX2luX2NoYXJfc2V0IGNoYXJfc2V0IGMgPVxuICBsZXQgaW5kID0gaW50X29mX2NoYXIgYyBpblxuICBsZXQgc3RyX2luZCA9IGluZCBsc3IgMyBhbmQgbWFzayA9IDEgbHNsIChpbmQgbGFuZCAwYjExMSkgaW5cbiAgKGludF9vZl9jaGFyIChTdHJpbmcuZ2V0IGNoYXJfc2V0IHN0cl9pbmQpIGxhbmQgbWFzaykgPD4gMFxuXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgKCogSWdub3JlZCBwYXJhbSBjb252ZXJzaW9uICopXG5cbigqIEdBRFQgdXNlZCB0byBhYnN0cmFjdCBhbiBleGlzdGVudGlhbCB0eXBlIHBhcmFtZXRlci4gKilcbigqIFNlZSBwYXJhbV9mb3JtYXRfb2ZfaWdub3JlZF9mb3JtYXQuICopXG50eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBwYXJhbV9mb3JtYXRfZWJiID0gUGFyYW1fZm9ybWF0X0VCQiA6XG4gICAgKCd4IC0+ICdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBwYXJhbV9mb3JtYXRfZWJiXG5cbigqIENvbXB1dGUgYSBwYWRkaW5nIGFzc29jaWF0ZWQgdG8gYSBwYWRfb3B0aW9uIChzZWUgXCIlXzQyZFwiKS4gKilcbmxldCBwYWRfb2ZfcGFkX29wdCBwYWRfb3B0ID0gbWF0Y2ggcGFkX29wdCB3aXRoXG4gIHwgTm9uZSAtPiBOb19wYWRkaW5nXG4gIHwgU29tZSB3aWR0aCAtPiBMaXRfcGFkZGluZyAoUmlnaHQsIHdpZHRoKVxuXG4oKiBDb21wdXRlIGEgcHJlY2lzaW9uIGFzc29jaWF0ZWQgdG8gYSBwcmVjX29wdGlvbiAoc2VlIFwiJV8uNDJmXCIpLiAqKVxubGV0IHByZWNfb2ZfcHJlY19vcHQgcHJlY19vcHQgPSBtYXRjaCBwcmVjX29wdCB3aXRoXG4gIHwgTm9uZSAtPiBOb19wcmVjaXNpb25cbiAgfCBTb21lIG5kZWMgLT4gTGl0X3ByZWNpc2lvbiBuZGVjXG5cbigqIFR1cm4gYW4gaWdub3JlZCBwYXJhbSBpbnRvIGl0cyBlcXVpdmFsZW50IG5vdC1pZ25vcmVkIGZvcm1hdCBub2RlLiAqKVxuKCogVXNlZCBmb3IgZm9ybWF0IHByZXR0eS1wcmludGluZyBhbmQgU2NhbmYuICopXG5sZXQgcGFyYW1fZm9ybWF0X29mX2lnbm9yZWRfZm9ybWF0IDogdHlwZSBhIGIgYyBkIGUgZiB4IHkgLlxuICAgIChhLCBiLCBjLCBkLCB5LCB4KSBpZ25vcmVkIC0+ICh4LCBiLCBjLCB5LCBlLCBmKSBmbXQgLT5cbiAgICAgIChhLCBiLCBjLCBkLCBlLCBmKSBwYXJhbV9mb3JtYXRfZWJiID1cbmZ1biBpZ24gZm10IC0+IG1hdGNoIGlnbiB3aXRoXG4gIHwgSWdub3JlZF9jaGFyIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQiAoQ2hhciBmbXQpXG4gIHwgSWdub3JlZF9jYW1sX2NoYXIgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChDYW1sX2NoYXIgZm10KVxuICB8IElnbm9yZWRfc3RyaW5nIHBhZF9vcHQgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChTdHJpbmcgKHBhZF9vZl9wYWRfb3B0IHBhZF9vcHQsIGZtdCkpXG4gIHwgSWdub3JlZF9jYW1sX3N0cmluZyBwYWRfb3B0IC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQiAoQ2FtbF9zdHJpbmcgKHBhZF9vZl9wYWRfb3B0IHBhZF9vcHQsIGZtdCkpXG4gIHwgSWdub3JlZF9pbnQgKGljb252LCBwYWRfb3B0KSAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkIgKEludCAoaWNvbnYsIHBhZF9vZl9wYWRfb3B0IHBhZF9vcHQsIE5vX3ByZWNpc2lvbiwgZm10KSlcbiAgfCBJZ25vcmVkX2ludDMyIChpY29udiwgcGFkX29wdCkgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCXG4gICAgICAoSW50MzIgKGljb252LCBwYWRfb2ZfcGFkX29wdCBwYWRfb3B0LCBOb19wcmVjaXNpb24sIGZtdCkpXG4gIHwgSWdub3JlZF9uYXRpdmVpbnQgKGljb252LCBwYWRfb3B0KSAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkJcbiAgICAgIChOYXRpdmVpbnQgKGljb252LCBwYWRfb2ZfcGFkX29wdCBwYWRfb3B0LCBOb19wcmVjaXNpb24sIGZtdCkpXG4gIHwgSWdub3JlZF9pbnQ2NCAoaWNvbnYsIHBhZF9vcHQpIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQlxuICAgICAgKEludDY0IChpY29udiwgcGFkX29mX3BhZF9vcHQgcGFkX29wdCwgTm9fcHJlY2lzaW9uLCBmbXQpKVxuICB8IElnbm9yZWRfZmxvYXQgKHBhZF9vcHQsIHByZWNfb3B0KSAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkJcbiAgICAgIChGbG9hdCAoKEZsb2F0X2ZsYWdfLCBGbG9hdF9mKSxcbiAgICAgICAgICAgICAgcGFkX29mX3BhZF9vcHQgcGFkX29wdCwgcHJlY19vZl9wcmVjX29wdCBwcmVjX29wdCwgZm10KSlcbiAgfCBJZ25vcmVkX2Jvb2wgcGFkX29wdCAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkIgKEJvb2wgKHBhZF9vZl9wYWRfb3B0IHBhZF9vcHQsIGZtdCkpXG4gIHwgSWdub3JlZF9mb3JtYXRfYXJnIChwYWRfb3B0LCBmbXR0eSkgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChGb3JtYXRfYXJnIChwYWRfb3B0LCBmbXR0eSwgZm10KSlcbiAgfCBJZ25vcmVkX2Zvcm1hdF9zdWJzdCAocGFkX29wdCwgZm10dHkpIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQlxuICAgICAgKEZvcm1hdF9zdWJzdCAocGFkX29wdCwgZm10dHksIGZtdCkpXG4gIHwgSWdub3JlZF9yZWFkZXIgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChSZWFkZXIgZm10KVxuICB8IElnbm9yZWRfc2Nhbl9jaGFyX3NldCAod2lkdGhfb3B0LCBjaGFyX3NldCkgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChTY2FuX2NoYXJfc2V0ICh3aWR0aF9vcHQsIGNoYXJfc2V0LCBmbXQpKVxuICB8IElnbm9yZWRfc2Nhbl9nZXRfY291bnRlciBjb3VudGVyIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQiAoU2Nhbl9nZXRfY291bnRlciAoY291bnRlciwgZm10KSlcbiAgfCBJZ25vcmVkX3NjYW5fbmV4dF9jaGFyIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQiAoU2Nhbl9uZXh0X2NoYXIgZm10KVxuXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBUeXBlcyAqKVxuXG50eXBlICgnYiwgJ2MpIGFjY19mb3JtYXR0aW5nX2dlbiA9XG4gIHwgQWNjX29wZW5fdGFnIG9mICgnYiwgJ2MpIGFjY1xuICB8IEFjY19vcGVuX2JveCBvZiAoJ2IsICdjKSBhY2NcblxuKCogUmV2ZXJzZWQgbGlzdCBvZiBwcmludGluZyBhdG9tcy4gKilcbigqIFVzZWQgdG8gYWNjdW11bGF0ZSBwcmludGYgYXJndW1lbnRzLiAqKVxuYW5kICgnYiwgJ2MpIGFjYyA9XG4gIHwgQWNjX2Zvcm1hdHRpbmdfbGl0IG9mICgnYiwgJ2MpIGFjYyAqIGZvcm1hdHRpbmdfbGl0XG4gICAgICAoKiBTcGVjaWFsIGZtdHRpbmcgKGJveCkgKilcbiAgfCBBY2NfZm9ybWF0dGluZ19nZW4gb2YgKCdiLCAnYykgYWNjICogKCdiLCAnYykgYWNjX2Zvcm1hdHRpbmdfZ2VuXG4gICAgICAoKiBTcGVjaWFsIGZtdHRpbmcgKGJveCkgKilcbiAgfCBBY2Nfc3RyaW5nX2xpdGVyYWwgb2YgKCdiLCAnYykgYWNjICogc3RyaW5nICAgICAoKiBMaXRlcmFsIHN0cmluZyAqKVxuICB8IEFjY19jaGFyX2xpdGVyYWwgICBvZiAoJ2IsICdjKSBhY2MgKiBjaGFyICAgICAgICgqIExpdGVyYWwgY2hhciAqKVxuICB8IEFjY19kYXRhX3N0cmluZyAgICBvZiAoJ2IsICdjKSBhY2MgKiBzdHJpbmcgICAgICgqIEdlbmVyYXRlZCBzdHJpbmcgKilcbiAgfCBBY2NfZGF0YV9jaGFyICAgICAgb2YgKCdiLCAnYykgYWNjICogY2hhciAgICAgICAoKiBHZW5lcmF0ZWQgY2hhciAqKVxuICB8IEFjY19kZWxheSAgICAgICAgICBvZiAoJ2IsICdjKSBhY2MgKiAoJ2IgLT4gJ2MpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBEZWxheWVkIHByaW50aW5nICglYSwgJXQpICopXG4gIHwgQWNjX2ZsdXNoICAgICAgICAgIG9mICgnYiwgJ2MpIGFjYyAgICAgICAgICAgICAgKCogRmx1c2ggKilcbiAgfCBBY2NfaW52YWxpZF9hcmcgICAgb2YgKCdiLCAnYykgYWNjICogc3RyaW5nXG4gICAgICAoKiBSYWlzZSBJbnZhbGlkX2FyZ3VtZW50IG1zZyAqKVxuICB8IEVuZF9vZl9hY2NcblxuKCogTGlzdCBvZiBoZXRlcm9nZW5lb3VzIHZhbHVlcy4gKilcbigqIFVzZWQgdG8gYWNjdW11bGF0ZSBzY2FuZiBjYWxsYmFjayBhcmd1bWVudHMuICopXG50eXBlICgnYSwgJ2IpIGhldGVyX2xpc3QgPVxuICB8IENvbnMgOiAnYyAqICgnYSwgJ2IpIGhldGVyX2xpc3QgLT4gKCdjIC0+ICdhLCAnYikgaGV0ZXJfbGlzdFxuICB8IE5pbCA6ICgnYiwgJ2IpIGhldGVyX2xpc3RcblxuKCogRXhpc3RlbnRpYWwgQmxhY2sgQm94ZXMuICopXG4oKiBVc2VkIHRvIGFic3RyYWN0IHNvbWUgZXhpc3RlbnRpYWwgdHlwZSBwYXJhbWV0ZXJzLiAqKVxuXG4oKiBHQURUIHR5cGUgYXNzb2NpYXRpbmcgYSBwYWRkaW5nIGFuZCBhbiBmbXR0eS4gKilcbigqIFNlZSB0aGUgdHlwZV9wYWRkaW5nIGZ1bmN0aW9uLiAqKVxudHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgcGFkZGluZ19mbXR0eV9lYmIgPSBQYWRkaW5nX2ZtdHR5X0VCQiA6XG4gICAgICgneCwgJ3kpIHBhZGRpbmcgKiAoJ3ksICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHkgLT5cbiAgICAgKCd4LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIHBhZGRpbmdfZm10dHlfZWJiXG5cbigqIEdBRFQgdHlwZSBhc3NvY2lhdGluZyBhIHBhZGRpbmcsIGEgcHJlY2lzaW9uIGFuZCBhbiBmbXR0eS4gKilcbigqIFNlZSB0aGUgdHlwZV9wYWRwcmVjIGZ1bmN0aW9uLiAqKVxudHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgcGFkcHJlY19mbXR0eV9lYmIgPSBQYWRwcmVjX2ZtdHR5X0VCQiA6XG4gICAgICgneCwgJ3kpIHBhZGRpbmcgKiAoJ3ksICd6KSBwcmVjaXNpb24gKiAoJ3osICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHkgLT5cbiAgICAgKCd4LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIHBhZHByZWNfZm10dHlfZWJiXG5cbigqIEdBRFQgdHlwZSBhc3NvY2lhdGluZyBhIHBhZGRpbmcgYW5kIGFuIGZtdC4gKilcbigqIFNlZSBtYWtlX3BhZGRpbmdfZm10X2ViYiBhbmQgcGFyc2VfZm9ybWF0IGZ1bmN0aW9ucy4gKilcbnR5cGUgKCdhLCAnYiwgJ2MsICdlLCAnZikgcGFkZGluZ19mbXRfZWJiID0gUGFkZGluZ19mbXRfRUJCIDpcbiAgICAgKF8sICd4IC0+ICdhKSBwYWRkaW5nICpcbiAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAoJ3gsICdiLCAnYywgJ2UsICdmKSBwYWRkaW5nX2ZtdF9lYmJcblxuKCogR0FEVCB0eXBlIGFzc29jaWF0aW5nIGEgcHJlY2lzaW9uIGFuZCBhbiBmbXQuICopXG4oKiBTZWUgbWFrZV9wcmVjaXNpb25fZm10X2ViYiBhbmQgcGFyc2VfZm9ybWF0IGZ1bmN0aW9ucy4gKilcbnR5cGUgKCdhLCAnYiwgJ2MsICdlLCAnZikgcHJlY2lzaW9uX2ZtdF9lYmIgPSBQcmVjaXNpb25fZm10X0VCQiA6XG4gICAgIChfLCAneCAtPiAnYSkgcHJlY2lzaW9uICpcbiAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAoJ3gsICdiLCAnYywgJ2UsICdmKSBwcmVjaXNpb25fZm10X2ViYlxuXG4oKiBHQURUIHR5cGUgYXNzb2NpYXRpbmcgYSBwYWRkaW5nLCBhIHByZWNpc2lvbiBhbmQgYW4gZm10LiAqKVxuKCogU2VlIG1ha2VfcGFkcHJlY19mbXRfZWJiIGFuZCBwYXJzZV9mb3JtYXQgZnVuY3Rpb25zLiAqKVxudHlwZSAoJ3AsICdiLCAnYywgJ2UsICdmKSBwYWRwcmVjX2ZtdF9lYmIgPSBQYWRwcmVjX2ZtdF9FQkIgOlxuICAgICAoJ3gsICd5KSBwYWRkaW5nICogKCd5LCAncCAtPiAnYSkgcHJlY2lzaW9uICpcbiAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAoJ3AsICdiLCAnYywgJ2UsICdmKSBwYWRwcmVjX2ZtdF9lYmJcblxuKCogQWJzdHJhY3QgdGhlICdhIGFuZCAnZCBwYXJhbWV0ZXJzIG9mIGFuIGZtdC4gKilcbigqIE91dHB1dCB0eXBlIG9mIHRoZSBmb3JtYXQgcGFyc2luZyBmdW5jdGlvbi4gKilcbnR5cGUgKCdiLCAnYywgJ2UsICdmKSBmbXRfZWJiID0gRm10X0VCQiA6XG4gICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgKCdiLCAnYywgJ2UsICdmKSBmbXRfZWJiXG5cbigqIEdBRFQgdHlwZSBhc3NvY2lhdGluZyBhbiBmbXR0eSBhbmQgYW4gZm10LiAqKVxuKCogU2VlIHRoZSB0eXBlX2Zvcm1hdF9nZW4gZnVuY3Rpb24uICopXG50eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRfZm10dHlfZWJiID0gRm10X2ZtdHR5X0VCQiA6XG4gICAgICgnYSwgJ2IsICdjLCAnZCwgJ3ksICd4KSBmbXQgKlxuICAgICAoJ3gsICdiLCAnYywgJ3ksICdlLCAnZikgZm10dHkgLT5cbiAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdF9mbXR0eV9lYmJcblxuKCogR0FEVCB0eXBlIGFzc29jaWF0aW5nIGFuIGZtdHR5IGFuZCBhbiBmbXQuICopXG4oKiBTZWUgdGhlIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIGZ1bmN0aW9uLiAqKVxudHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHlfZm10X2ViYiA9IEZtdHR5X2ZtdF9FQkIgOlxuICAgICAoJ2EsICdiLCAnYywgJ2QsICd5LCAneCkgZm10dHkgKlxuICAgICAoJ3gsICdiLCAnYywgJ3ksICdlLCAnZikgZm10X2ZtdHR5X2ViYiAtPlxuICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHlfZm10X2ViYlxuXG4oKiBBYnN0cmFjdCBhbGwgZm10dHkgdHlwZSBwYXJhbWV0ZXJzLiAqKVxuKCogVXNlZCB0byBjb21wYXJlIGZvcm1hdCB0eXBlcy4gKilcbnR5cGUgZm10dHlfZWJiID0gRm10dHlfRUJCIDogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdHR5IC0+IGZtdHR5X2ViYlxuXG4oKiBBYnN0cmFjdCBhbGwgcGFkZGluZyB0eXBlIHBhcmFtZXRlcnMuICopXG4oKiBVc2VkIHRvIGNvbXBhcmUgcGFkZGluZ3MuICopXG50eXBlIHBhZGRpbmdfZWJiID0gUGFkZGluZ19FQkIgOiAoJ2EsICdiKSBwYWRkaW5nIC0+IHBhZGRpbmdfZWJiXG5cbigqIEFic3RyYWN0IGFsbCBwcmVjaXNpb24gdHlwZSBwYXJhbWV0ZXJzLiAqKVxuKCogVXNlZCB0byBjb21wYXJlIHByZWNpc2lvbnMuICopXG50eXBlIHByZWNpc2lvbl9lYmIgPSBQcmVjaXNpb25fRUJCIDogKCdhLCAnYikgcHJlY2lzaW9uIC0+IHByZWNpc2lvbl9lYmJcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBDb25zdGFudHMgKilcblxuKCogRGVmYXVsdCBwcmVjaXNpb24gZm9yIGZsb2F0IHByaW50aW5nLiAqKVxubGV0IGRlZmF1bHRfZmxvYXRfcHJlY2lzaW9uIGZjb252ID1cbiAgbWF0Y2ggc25kIGZjb252IHdpdGhcbiAgfCBGbG9hdF9mIHwgRmxvYXRfZSB8IEZsb2F0X0UgfCBGbG9hdF9nIHwgRmxvYXRfRyB8IEZsb2F0X2ggfCBGbG9hdF9IXG4gIHwgRmxvYXRfQ0YgLT4gLTZcbiAgKCogRm9yICVoICVIIGFuZCAlI0YgZm9ybWF0cywgYSBuZWdhdGl2ZSBwcmVjaXNpb24gbWVhbnMgXCJhcyBtYW55IGRpZ2l0cyBhc1xuICAgICBuZWNlc3NhcnlcIi4gIEZvciB0aGUgb3RoZXIgRlAgZm9ybWF0cywgd2UgdGFrZSB0aGUgYWJzb2x1dGUgdmFsdWVcbiAgICAgb2YgdGhlIHByZWNpc2lvbiwgaGVuY2UgNiBkaWdpdHMgYnkgZGVmYXVsdC4gKilcbiAgfCBGbG9hdF9GIC0+IDEyXG4gICgqIERlZmF1bHQgcHJlY2lzaW9uIGZvciBPQ2FtbCBmbG9hdCBwcmludGluZyAoJUYpLiAqKVxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEV4dGVybmFscyAqKVxuXG5leHRlcm5hbCBmb3JtYXRfZmxvYXQ6IHN0cmluZyAtPiBmbG9hdCAtPiBzdHJpbmdcbiAgPSBcImNhbWxfZm9ybWF0X2Zsb2F0XCJcbmV4dGVybmFsIGZvcm1hdF9pbnQ6IHN0cmluZyAtPiBpbnQgLT4gc3RyaW5nXG4gID0gXCJjYW1sX2Zvcm1hdF9pbnRcIlxuZXh0ZXJuYWwgZm9ybWF0X2ludDMyOiBzdHJpbmcgLT4gaW50MzIgLT4gc3RyaW5nXG4gID0gXCJjYW1sX2ludDMyX2Zvcm1hdFwiXG5leHRlcm5hbCBmb3JtYXRfbmF0aXZlaW50OiBzdHJpbmcgLT4gbmF0aXZlaW50IC0+IHN0cmluZ1xuICA9IFwiY2FtbF9uYXRpdmVpbnRfZm9ybWF0XCJcbmV4dGVybmFsIGZvcm1hdF9pbnQ2NDogc3RyaW5nIC0+IGludDY0IC0+IHN0cmluZ1xuICA9IFwiY2FtbF9pbnQ2NF9mb3JtYXRcIlxuZXh0ZXJuYWwgaGV4c3RyaW5nX29mX2Zsb2F0OiBmbG9hdCAtPiBpbnQgLT4gY2hhciAtPiBzdHJpbmdcbiAgPSBcImNhbWxfaGV4c3RyaW5nX29mX2Zsb2F0XCJcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICgqIFRvb2xzIHRvIHByZXR0eS1wcmludCBmb3JtYXRzICopXG5cbigqIFR5cGUgb2YgZXh0ZW5zaWJsZSBjaGFyYWN0ZXIgYnVmZmVycy4gKilcbnR5cGUgYnVmZmVyID0ge1xuICBtdXRhYmxlIGluZCA6IGludDtcbiAgbXV0YWJsZSBieXRlcyA6IGJ5dGVzO1xufVxuXG4oKiBDcmVhdGUgYSBmcmVzaCBidWZmZXIuICopXG5sZXQgYnVmZmVyX2NyZWF0ZSBpbml0X3NpemUgPSB7IGluZCA9IDA7IGJ5dGVzID0gQnl0ZXMuY3JlYXRlIGluaXRfc2l6ZSB9XG5cbigqIENoZWNrIHNpemUgb2YgdGhlIGJ1ZmZlciBhbmQgZ3JvdyBpdCBpZiBuZWVkZWQuICopXG5sZXQgYnVmZmVyX2NoZWNrX3NpemUgYnVmIG92ZXJoZWFkID1cbiAgbGV0IGxlbiA9IEJ5dGVzLmxlbmd0aCBidWYuYnl0ZXMgaW5cbiAgbGV0IG1pbl9sZW4gPSBidWYuaW5kICsgb3ZlcmhlYWQgaW5cbiAgaWYgbWluX2xlbiA+IGxlbiB0aGVuIChcbiAgICBsZXQgbmV3X2xlbiA9IG1heCAobGVuICogMikgbWluX2xlbiBpblxuICAgIGxldCBuZXdfc3RyID0gQnl0ZXMuY3JlYXRlIG5ld19sZW4gaW5cbiAgICBCeXRlcy5ibGl0IGJ1Zi5ieXRlcyAwIG5ld19zdHIgMCBsZW47XG4gICAgYnVmLmJ5dGVzIDwtIG5ld19zdHI7XG4gIClcblxuKCogQWRkIHRoZSBjaGFyYWN0ZXIgYGMnIHRvIHRoZSBidWZmZXIgYGJ1ZicuICopXG5sZXQgYnVmZmVyX2FkZF9jaGFyIGJ1ZiBjID1cbiAgYnVmZmVyX2NoZWNrX3NpemUgYnVmIDE7XG4gIEJ5dGVzLnNldCBidWYuYnl0ZXMgYnVmLmluZCBjO1xuICBidWYuaW5kIDwtIGJ1Zi5pbmQgKyAxXG5cbigqIEFkZCB0aGUgc3RyaW5nIGBzJyB0byB0aGUgYnVmZmVyIGBidWYnLiAqKVxubGV0IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBzID1cbiAgbGV0IHN0cl9sZW4gPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgYnVmZmVyX2NoZWNrX3NpemUgYnVmIHN0cl9sZW47XG4gIFN0cmluZy5ibGl0IHMgMCBidWYuYnl0ZXMgYnVmLmluZCBzdHJfbGVuO1xuICBidWYuaW5kIDwtIGJ1Zi5pbmQgKyBzdHJfbGVuXG5cbigqIEdldCB0aGUgY29udGVudCBvZiB0aGUgYnVmZmVyLiAqKVxubGV0IGJ1ZmZlcl9jb250ZW50cyBidWYgPVxuICBCeXRlcy5zdWJfc3RyaW5nIGJ1Zi5ieXRlcyAwIGJ1Zi5pbmRcblxuKCoqKilcblxuKCogQ29udmVydCBhbiBpbnRlZ2VyIGNvbnZlcnNpb24gdG8gY2hhci4gKilcbmxldCBjaGFyX29mX2ljb252IGljb252ID0gbWF0Y2ggaWNvbnYgd2l0aFxuICB8IEludF9kIHwgSW50X3BkIHwgSW50X3NkIHwgSW50X0NkIC0+ICdkJyB8IEludF9pIHwgSW50X3BpIHwgSW50X3NpXG4gIHwgSW50X0NpIC0+ICdpJyB8IEludF94IHwgSW50X0N4IC0+ICd4JyB8IEludF9YIHwgSW50X0NYIC0+ICdYJyB8IEludF9vXG4gIHwgSW50X0NvIC0+ICdvJyB8IEludF91IHwgSW50X0N1IC0+ICd1J1xuXG4oKiBDb252ZXJ0IGEgZmxvYXQgY29udmVyc2lvbiB0byBjaGFyLiAqKVxuKCogYGNGJyB3aWxsIGJlICdGJyBmb3IgZGlzcGxheWluZyBmb3JtYXQgYW5kICdnJyB0byBjYWxsIGxpYmMgcHJpbnRmICopXG5sZXQgY2hhcl9vZl9mY29udiA/KGNGPSdGJykgZmNvbnYgPSBtYXRjaCBzbmQgZmNvbnYgd2l0aFxuICB8IEZsb2F0X2YgLT4gJ2YnIHwgRmxvYXRfZSAtPiAnZSdcbiAgfCBGbG9hdF9FIC0+ICdFJyB8IEZsb2F0X2cgLT4gJ2cnXG4gIHwgRmxvYXRfRyAtPiAnRycgfCBGbG9hdF9GIC0+IGNGXG4gIHwgRmxvYXRfaCAtPiAnaCcgfCBGbG9hdF9IIC0+ICdIJ1xuICB8IEZsb2F0X0NGIC0+ICdGJ1xuXG5cbigqIENvbnZlcnQgYSBzY2FubmluZyBjb3VudGVyIHRvIGNoYXIuICopXG5sZXQgY2hhcl9vZl9jb3VudGVyIGNvdW50ZXIgPSBtYXRjaCBjb3VudGVyIHdpdGhcbiAgfCBMaW5lX2NvdW50ZXIgIC0+ICdsJ1xuICB8IENoYXJfY291bnRlciAgLT4gJ24nXG4gIHwgVG9rZW5fY291bnRlciAtPiAnTidcblxuKCoqKilcblxuKCogUHJpbnQgYSBjaGFyX3NldCBpbiBhIGJ1ZmZlciB3aXRoIHRoZSBPQ2FtbCBmb3JtYXQgbGV4aWNhbCBjb252ZW50aW9uLiAqKVxubGV0IGJwcmludF9jaGFyX3NldCBidWYgY2hhcl9zZXQgPVxuICBsZXQgcmVjIHByaW50X3N0YXJ0IHNldCA9XG4gICAgbGV0IGlzX2Fsb25lIGMgPVxuICAgICAgbGV0IGJlZm9yZSwgYWZ0ZXIgPSBDaGFyLihjaHIgKGNvZGUgYyAtIDEpLCBjaHIgKGNvZGUgYyArIDEpKSBpblxuICAgICAgaXNfaW5fY2hhcl9zZXQgc2V0IGNcbiAgICAgICYmIG5vdCAoaXNfaW5fY2hhcl9zZXQgc2V0IGJlZm9yZSAmJiBpc19pbl9jaGFyX3NldCBzZXQgYWZ0ZXIpIGluXG4gICAgaWYgaXNfYWxvbmUgJ10nIHRoZW4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnXSc7XG4gICAgcHJpbnRfb3V0IHNldCAxO1xuICAgIGlmIGlzX2Fsb25lICctJyB0aGVuIGJ1ZmZlcl9hZGRfY2hhciBidWYgJy0nO1xuICBhbmQgcHJpbnRfb3V0IHNldCBpID1cbiAgICBpZiBpIDwgMjU2IHRoZW5cbiAgICAgIGlmIGlzX2luX2NoYXJfc2V0IHNldCAoY2hhcl9vZl9pbnQgaSkgdGhlbiBwcmludF9maXJzdCBzZXQgaVxuICAgICAgZWxzZSBwcmludF9vdXQgc2V0IChpICsgMSlcbiAgYW5kIHByaW50X2ZpcnN0IHNldCBpID1cbiAgICBtYXRjaCBjaGFyX29mX2ludCBpIHdpdGhcbiAgICB8ICdcXDI1NScgLT4gcHJpbnRfY2hhciBidWYgMjU1O1xuICAgIHwgJ10nIHwgJy0nIC0+IHByaW50X291dCBzZXQgKGkgKyAxKTtcbiAgICB8IF8gLT4gcHJpbnRfc2Vjb25kIHNldCAoaSArIDEpO1xuICBhbmQgcHJpbnRfc2Vjb25kIHNldCBpID1cbiAgICBpZiBpc19pbl9jaGFyX3NldCBzZXQgKGNoYXJfb2ZfaW50IGkpIHRoZW5cbiAgICAgIG1hdGNoIGNoYXJfb2ZfaW50IGkgd2l0aFxuICAgICAgfCAnXFwyNTUnIC0+XG4gICAgICAgIHByaW50X2NoYXIgYnVmIDI1NDtcbiAgICAgICAgcHJpbnRfY2hhciBidWYgMjU1O1xuICAgICAgfCAnXScgfCAnLScgd2hlbiBub3QgKGlzX2luX2NoYXJfc2V0IHNldCAoY2hhcl9vZl9pbnQgKGkgKyAxKSkpIC0+XG4gICAgICAgIHByaW50X2NoYXIgYnVmIChpIC0gMSk7XG4gICAgICAgIHByaW50X291dCBzZXQgKGkgKyAxKTtcbiAgICAgIHwgXyB3aGVuIG5vdCAoaXNfaW5fY2hhcl9zZXQgc2V0IChjaGFyX29mX2ludCAoaSArIDEpKSkgLT5cbiAgICAgICAgcHJpbnRfY2hhciBidWYgKGkgLSAxKTtcbiAgICAgICAgcHJpbnRfY2hhciBidWYgaTtcbiAgICAgICAgcHJpbnRfb3V0IHNldCAoaSArIDIpO1xuICAgICAgfCBfIC0+XG4gICAgICAgIHByaW50X2luIHNldCAoaSAtIDEpIChpICsgMik7XG4gICAgZWxzZSAoXG4gICAgICBwcmludF9jaGFyIGJ1ZiAoaSAtIDEpO1xuICAgICAgcHJpbnRfb3V0IHNldCAoaSArIDEpO1xuICAgIClcbiAgYW5kIHByaW50X2luIHNldCBpIGogPVxuICAgIGlmIGogPSAyNTYgfHwgbm90IChpc19pbl9jaGFyX3NldCBzZXQgKGNoYXJfb2ZfaW50IGopKSB0aGVuIChcbiAgICAgIHByaW50X2NoYXIgYnVmIGk7XG4gICAgICBwcmludF9jaGFyIGJ1ZiAoaW50X29mX2NoYXIgJy0nKTtcbiAgICAgIHByaW50X2NoYXIgYnVmIChqIC0gMSk7XG4gICAgICBpZiBqIDwgMjU2IHRoZW4gcHJpbnRfb3V0IHNldCAoaiArIDEpO1xuICAgICkgZWxzZVxuICAgICAgcHJpbnRfaW4gc2V0IGkgKGogKyAxKTtcbiAgYW5kIHByaW50X2NoYXIgYnVmIGkgPSBtYXRjaCBjaGFyX29mX2ludCBpIHdpdGhcbiAgICB8ICclJyAtPiBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7XG4gICAgfCAnQCcgLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJ0AnO1xuICAgIHwgYyAgIC0+IGJ1ZmZlcl9hZGRfY2hhciBidWYgYztcbiAgaW5cbiAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnWyc7XG4gIHByaW50X3N0YXJ0IChcbiAgICBpZiBpc19pbl9jaGFyX3NldCBjaGFyX3NldCAnXFwwMDAnXG4gICAgdGhlbiAoIGJ1ZmZlcl9hZGRfY2hhciBidWYgJ14nOyByZXZfY2hhcl9zZXQgY2hhcl9zZXQgKVxuICAgIGVsc2UgY2hhcl9zZXRcbiAgKTtcbiAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnXSdcblxuKCoqKilcblxuKCogUHJpbnQgYSBwYWR0eSBpbiBhIGJ1ZmZlciB3aXRoIHRoZSBmb3JtYXQtbGlrZSBzeW50YXguICopXG5sZXQgYnByaW50X3BhZHR5IGJ1ZiBwYWR0eSA9IG1hdGNoIHBhZHR5IHdpdGhcbiAgfCBMZWZ0ICAtPiBidWZmZXJfYWRkX2NoYXIgYnVmICctJ1xuICB8IFJpZ2h0IC0+ICgpXG4gIHwgWmVyb3MgLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnMCdcblxuKCogUHJpbnQgdGhlICdfJyBvZiBhbiBpZ25vcmVkIGZsYWcgaWYgbmVlZGVkLiAqKVxubGV0IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnID1cbiAgaWYgaWduX2ZsYWcgdGhlbiBidWZmZXJfYWRkX2NoYXIgYnVmICdfJ1xuXG4oKioqKVxuXG5sZXQgYnByaW50X3BhZF9vcHQgYnVmIHBhZF9vcHQgPSBtYXRjaCBwYWRfb3B0IHdpdGhcbiAgfCBOb25lIC0+ICgpXG4gIHwgU29tZSB3aWR0aCAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgKEludC50b19zdHJpbmcgd2lkdGgpXG5cbigqKiopXG5cbigqIFByaW50IHBhZGRpbmcgaW4gYSBidWZmZXIgd2l0aCB0aGUgZm9ybWF0LWxpa2Ugc3ludGF4LiAqKVxubGV0IGJwcmludF9wYWRkaW5nIDogdHlwZSBhIGIgLiBidWZmZXIgLT4gKGEsIGIpIHBhZGRpbmcgLT4gdW5pdCA9XG5mdW4gYnVmIHBhZCAtPiBtYXRjaCBwYWQgd2l0aFxuICB8IE5vX3BhZGRpbmcgLT4gKClcbiAgfCBMaXRfcGFkZGluZyAocGFkdHksIG4pIC0+XG4gICAgYnByaW50X3BhZHR5IGJ1ZiBwYWR0eTtcbiAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgKEludC50b19zdHJpbmcgbik7XG4gIHwgQXJnX3BhZGRpbmcgcGFkdHkgLT5cbiAgICBicHJpbnRfcGFkdHkgYnVmIHBhZHR5O1xuICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyonXG5cbigqIFByaW50IHByZWNpc2lvbiBpbiBhIGJ1ZmZlciB3aXRoIHRoZSBmb3JtYXQtbGlrZSBzeW50YXguICopXG5sZXQgYnByaW50X3ByZWNpc2lvbiA6IHR5cGUgYSBiIC4gYnVmZmVyIC0+IChhLCBiKSBwcmVjaXNpb24gLT4gdW5pdCA9XG4gIGZ1biBidWYgcHJlYyAtPiBtYXRjaCBwcmVjIHdpdGhcbiAgfCBOb19wcmVjaXNpb24gLT4gKClcbiAgfCBMaXRfcHJlY2lzaW9uIG4gLT5cbiAgICBidWZmZXJfYWRkX2NoYXIgYnVmICcuJztcbiAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgKEludC50b19zdHJpbmcgbik7XG4gIHwgQXJnX3ByZWNpc2lvbiAtPlxuICAgIGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIi4qXCJcblxuKCoqKilcblxuKCogUHJpbnQgdGhlIG9wdGlvbmFsICcrJywgJyAnIG9yICcjJyBhc3NvY2lhdGVkIHRvIGFuIGludCBjb252ZXJzaW9uLiAqKVxubGV0IGJwcmludF9pY29udl9mbGFnIGJ1ZiBpY29udiA9IG1hdGNoIGljb252IHdpdGhcbiAgfCBJbnRfcGQgfCBJbnRfcGkgLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnKydcbiAgfCBJbnRfc2QgfCBJbnRfc2kgLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnICdcbiAgfCBJbnRfQ3ggfCBJbnRfQ1ggfCBJbnRfQ28gfCBJbnRfQ2QgfCBJbnRfQ2kgfCBJbnRfQ3UgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyMnXG4gIHwgSW50X2QgfCBJbnRfaSB8IEludF94IHwgSW50X1ggfCBJbnRfbyB8IEludF91IC0+ICgpXG5cbigqIFByaW50IGFuIGNvbXBsZXRlIGludCBmb3JtYXQgaW4gYSBidWZmZXIgKGV4OiBcIiUzLipkXCIpLiAqKVxubGV0IGJwcmludF9pbnRfZm10IGJ1ZiBpZ25fZmxhZyBpY29udiBwYWQgcHJlYyA9XG4gIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnO1xuICBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgYnByaW50X2ljb252X2ZsYWcgYnVmIGljb252O1xuICBicHJpbnRfcGFkZGluZyBidWYgcGFkO1xuICBicHJpbnRfcHJlY2lzaW9uIGJ1ZiBwcmVjO1xuICBidWZmZXJfYWRkX2NoYXIgYnVmIChjaGFyX29mX2ljb252IGljb252KVxuXG4oKiBQcmludCBhIGNvbXBsZXRlIGludDMyLCBuYXRpdmVpbnQgb3IgaW50NjQgZm9ybWF0IGluIGEgYnVmZmVyLiAqKVxubGV0IGJwcmludF9hbHRpbnRfZm10IGJ1ZiBpZ25fZmxhZyBpY29udiBwYWQgcHJlYyBjID1cbiAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7XG4gIGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICBicHJpbnRfaWNvbnZfZmxhZyBidWYgaWNvbnY7XG4gIGJwcmludF9wYWRkaW5nIGJ1ZiBwYWQ7XG4gIGJwcmludF9wcmVjaXNpb24gYnVmIHByZWM7XG4gIGJ1ZmZlcl9hZGRfY2hhciBidWYgYztcbiAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAoY2hhcl9vZl9pY29udiBpY29udilcblxuKCoqKilcblxuKCogUHJpbnQgdGhlIG9wdGlvbmFsICcrJywgJyAnIGFuZC9vciAnIycgYXNzb2NpYXRlZCB0byBhIGZsb2F0IGNvbnZlcnNpb24uICopXG5sZXQgYnByaW50X2Zjb252X2ZsYWcgYnVmIGZjb252ID1cbiAgYmVnaW4gbWF0Y2ggZnN0IGZjb252IHdpdGhcbiAgfCBGbG9hdF9mbGFnX3AgLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnKydcbiAgfCBGbG9hdF9mbGFnX3MgLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnICdcbiAgfCBGbG9hdF9mbGFnXyAtPiAoKSBlbmQ7XG4gIG1hdGNoIHNuZCBmY29udiB3aXRoXG4gIHwgRmxvYXRfQ0YgLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnIydcbiAgfCBGbG9hdF9mIHwgRmxvYXRfZSB8IEZsb2F0X0UgfCBGbG9hdF9nIHwgRmxvYXRfR1xuICB8IEZsb2F0X0YgfCBGbG9hdF9oIHwgRmxvYXRfSCAtPiAoKVxuXG4oKiBQcmludCBhIGNvbXBsZXRlIGZsb2F0IGZvcm1hdCBpbiBhIGJ1ZmZlciAoZXg6IFwiJSsqLjNmXCIpLiAqKVxubGV0IGJwcmludF9mbG9hdF9mbXQgYnVmIGlnbl9mbGFnIGZjb252IHBhZCBwcmVjID1cbiAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7XG4gIGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICBicHJpbnRfZmNvbnZfZmxhZyBidWYgZmNvbnY7XG4gIGJwcmludF9wYWRkaW5nIGJ1ZiBwYWQ7XG4gIGJwcmludF9wcmVjaXNpb24gYnVmIHByZWM7XG4gIGJ1ZmZlcl9hZGRfY2hhciBidWYgKGNoYXJfb2ZfZmNvbnYgZmNvbnYpXG5cbigqIENvbXB1dGUgdGhlIGxpdGVyYWwgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgRm9ybWF0dGluZ19saXQuICopXG4oKiBVc2VkIGJ5IFByaW50ZiBhbmQgU2NhbmYgd2hlcmUgZm9ybWF0dGluZyBpcyBub3QgaW50ZXJwcmV0ZWQuICopXG5sZXQgc3RyaW5nX29mX2Zvcm1hdHRpbmdfbGl0IGZvcm1hdHRpbmdfbGl0ID0gbWF0Y2ggZm9ybWF0dGluZ19saXQgd2l0aFxuICB8IENsb3NlX2JveCAgICAgICAgICAgIC0+IFwiQF1cIlxuICB8IENsb3NlX3RhZyAgICAgICAgICAgIC0+IFwiQH1cIlxuICB8IEJyZWFrIChzdHIsIF8sIF8pICAgIC0+IHN0clxuICB8IEZGbHVzaCAgICAgICAgICAgICAgIC0+IFwiQD9cIlxuICB8IEZvcmNlX25ld2xpbmUgICAgICAgIC0+IFwiQFxcblwiXG4gIHwgRmx1c2hfbmV3bGluZSAgICAgICAgLT4gXCJALlwiXG4gIHwgTWFnaWNfc2l6ZSAoc3RyLCBfKSAgLT4gc3RyXG4gIHwgRXNjYXBlZF9hdCAgICAgICAgICAgLT4gXCJAQFwiXG4gIHwgRXNjYXBlZF9wZXJjZW50ICAgICAgLT4gXCJAJVwiXG4gIHwgU2Nhbl9pbmRpYyBjIC0+IFwiQFwiIF4gKFN0cmluZy5tYWtlIDEgYylcblxuKCoqKilcblxuKCogUHJpbnQgYSBsaXRlcmFsIGNoYXIgaW4gYSBidWZmZXIsIGVzY2FwZSAnJScgYnkgXCIlJVwiLiAqKVxubGV0IGJwcmludF9jaGFyX2xpdGVyYWwgYnVmIGNociA9IG1hdGNoIGNociB3aXRoXG4gIHwgJyUnIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiUlXCJcbiAgfCBfIC0+IGJ1ZmZlcl9hZGRfY2hhciBidWYgY2hyXG5cbigqIFByaW50IGEgbGl0ZXJhbCBzdHJpbmcgaW4gYSBidWZmZXIsIGVzY2FwZSBhbGwgJyUnIGJ5IFwiJSVcIi4gKilcbmxldCBicHJpbnRfc3RyaW5nX2xpdGVyYWwgYnVmIHN0ciA9XG4gIGZvciBpID0gMCB0byBTdHJpbmcubGVuZ3RoIHN0ciAtIDEgZG9cbiAgICBicHJpbnRfY2hhcl9saXRlcmFsIGJ1ZiBzdHIuW2ldXG4gIGRvbmVcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKCogRm9ybWF0IHByZXR0eS1wcmludGluZyAqKVxuXG4oKiBQcmludCBhIGNvbXBsZXRlIGZvcm1hdCB0eXBlIChhbiBmbXR0eSkgaW4gYSBidWZmZXIuICopXG5sZXQgcmVjIGJwcmludF9mbXR0eSA6IHR5cGUgYSBiIGMgZCBlIGYgZyBoIGkgaiBrIGwgLlxuICAgIGJ1ZmZlciAtPiAoYSwgYiwgYywgZCwgZSwgZiwgZywgaCwgaSwgaiwgaywgbCkgZm10dHlfcmVsIC0+IHVuaXQgPVxuZnVuIGJ1ZiBmbXR0eSAtPiBtYXRjaCBmbXR0eSB3aXRoXG4gIHwgQ2hhcl90eSByZXN0ICAgICAgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJWNcIjsgIGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBTdHJpbmdfdHkgcmVzdCAgICAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlc1wiOyAgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IEludF90eSByZXN0ICAgICAgIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiVpXCI7ICBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgSW50MzJfdHkgcmVzdCAgICAgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJWxpXCI7IGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBOYXRpdmVpbnRfdHkgcmVzdCAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlbmlcIjsgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IEludDY0X3R5IHJlc3QgICAgIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiVMaVwiOyBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgRmxvYXRfdHkgcmVzdCAgICAgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJWZcIjsgIGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBCb29sX3R5IHJlc3QgICAgICAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlQlwiOyAgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IEFscGhhX3R5IHJlc3QgICAgIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiVhXCI7ICBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgVGhldGFfdHkgcmVzdCAgICAgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJXRcIjsgIGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBBbnlfdHkgcmVzdCAgICAgICAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlP1wiOyAgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IFJlYWRlcl90eSByZXN0ICAgIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiVyXCI7ICBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG5cbiAgfCBJZ25vcmVkX3JlYWRlcl90eSByZXN0IC0+XG4gICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJV9yXCI7XG4gICAgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuXG4gIHwgRm9ybWF0X2FyZ190eSAoc3ViX2ZtdHR5LCByZXN0KSAtPlxuICAgIGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiV7XCI7IGJwcmludF9mbXR0eSBidWYgc3ViX2ZtdHR5O1xuICAgIGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiV9XCI7IGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBGb3JtYXRfc3Vic3RfdHkgKHN1Yl9mbXR0eSwgXywgcmVzdCkgLT5cbiAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlKFwiOyBicHJpbnRfZm10dHkgYnVmIHN1Yl9mbXR0eTtcbiAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlKVwiOyBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG5cbiAgfCBFbmRfb2ZfZm10dHkgLT4gKClcblxuKCoqKilcblxubGV0IHJlYyBpbnRfb2ZfY3VzdG9tX2FyaXR5IDogdHlwZSBhIGIgYyAuXG4gIChhLCBiLCBjKSBjdXN0b21fYXJpdHkgLT4gaW50ID1cbiAgZnVuY3Rpb25cbiAgfCBDdXN0b21femVybyAtPiAwXG4gIHwgQ3VzdG9tX3N1Y2MgeCAtPiAxICsgaW50X29mX2N1c3RvbV9hcml0eSB4XG5cbigqIFByaW50IGEgY29tcGxldGUgZm9ybWF0IGluIGEgYnVmZmVyLiAqKVxubGV0IGJwcmludF9mbXQgYnVmIGZtdCA9XG4gIGxldCByZWMgZm10aXRlciA6IHR5cGUgYSBiIGMgZCBlIGYgLlxuICAgICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPiBib29sIC0+IHVuaXQgPVxuICBmdW4gZm10IGlnbl9mbGFnIC0+IG1hdGNoIGZtdCB3aXRoXG4gICAgfCBTdHJpbmcgKHBhZCwgcmVzdCkgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJwcmludF9wYWRkaW5nIGJ1ZiBwYWQ7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJ3MnO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgQ2FtbF9zdHJpbmcgKHBhZCwgcmVzdCkgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJwcmludF9wYWRkaW5nIGJ1ZiBwYWQ7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJ1MnO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuXG4gICAgfCBJbnQgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgICBicHJpbnRfaW50X2ZtdCBidWYgaWduX2ZsYWcgaWNvbnYgcGFkIHByZWM7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBJbnQzMiAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICAgIGJwcmludF9hbHRpbnRfZm10IGJ1ZiBpZ25fZmxhZyBpY29udiBwYWQgcHJlYyAnbCc7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBOYXRpdmVpbnQgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgICBicHJpbnRfYWx0aW50X2ZtdCBidWYgaWduX2ZsYWcgaWNvbnYgcGFkIHByZWMgJ24nO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgSW50NjQgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgICBicHJpbnRfYWx0aW50X2ZtdCBidWYgaWduX2ZsYWcgaWNvbnYgcGFkIHByZWMgJ0wnO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgRmxvYXQgKGZjb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgICBicHJpbnRfZmxvYXRfZm10IGJ1ZiBpZ25fZmxhZyBmY29udiBwYWQgcHJlYztcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcblxuICAgIHwgQ2hhciByZXN0IC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICdjJzsgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgQ2FtbF9jaGFyIHJlc3QgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJ0MnOyBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBCb29sIChwYWQsIHJlc3QpIC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBicHJpbnRfcGFkZGluZyBidWYgcGFkOyBidWZmZXJfYWRkX2NoYXIgYnVmICdCJztcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IEFscGhhIHJlc3QgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJ2EnOyBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBUaGV0YSByZXN0IC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICd0JzsgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgQ3VzdG9tIChhcml0eSwgXywgcmVzdCkgLT5cbiAgICAgIGZvciBfaSA9IDEgdG8gaW50X29mX2N1c3RvbV9hcml0eSBhcml0eSBkb1xuICAgICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJz8nO1xuICAgICAgZG9uZTtcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IFJlYWRlciByZXN0IC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICdyJzsgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgRmx1c2ggcmVzdCAtPlxuICAgICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJSFcIjtcbiAgICAgIGZtdGl0ZXIgcmVzdCBpZ25fZmxhZztcblxuICAgIHwgU3RyaW5nX2xpdGVyYWwgKHN0ciwgcmVzdCkgLT5cbiAgICAgIGJwcmludF9zdHJpbmdfbGl0ZXJhbCBidWYgc3RyO1xuICAgICAgZm10aXRlciByZXN0IGlnbl9mbGFnO1xuICAgIHwgQ2hhcl9saXRlcmFsIChjaHIsIHJlc3QpIC0+XG4gICAgICBicHJpbnRfY2hhcl9saXRlcmFsIGJ1ZiBjaHI7XG4gICAgICBmbXRpdGVyIHJlc3QgaWduX2ZsYWc7XG5cbiAgICB8IEZvcm1hdF9hcmcgKHBhZF9vcHQsIGZtdHR5LCByZXN0KSAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnByaW50X3BhZF9vcHQgYnVmIHBhZF9vcHQ7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJ3snO1xuICAgICAgYnByaW50X2ZtdHR5IGJ1ZiBmbXR0eTsgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJ30nO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgRm9ybWF0X3N1YnN0IChwYWRfb3B0LCBmbXR0eSwgcmVzdCkgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJwcmludF9wYWRfb3B0IGJ1ZiBwYWRfb3B0OyBidWZmZXJfYWRkX2NoYXIgYnVmICcoJztcbiAgICAgIGJwcmludF9mbXR0eSBidWYgZm10dHk7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBidWZmZXJfYWRkX2NoYXIgYnVmICcpJztcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcblxuICAgIHwgU2Nhbl9jaGFyX3NldCAod2lkdGhfb3B0LCBjaGFyX3NldCwgcmVzdCkgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJwcmludF9wYWRfb3B0IGJ1ZiB3aWR0aF9vcHQ7IGJwcmludF9jaGFyX3NldCBidWYgY2hhcl9zZXQ7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBTY2FuX2dldF9jb3VudGVyIChjb3VudGVyLCByZXN0KSAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAoY2hhcl9vZl9jb3VudGVyIGNvdW50ZXIpO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgU2Nhbl9uZXh0X2NoYXIgcmVzdCAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnByaW50X3N0cmluZ19saXRlcmFsIGJ1ZiBcIjBjXCI7IGZtdGl0ZXIgcmVzdCBmYWxzZTtcblxuICAgIHwgSWdub3JlZF9wYXJhbSAoaWduLCByZXN0KSAtPlxuICAgICAgbGV0IFBhcmFtX2Zvcm1hdF9FQkIgZm10JyA9IHBhcmFtX2Zvcm1hdF9vZl9pZ25vcmVkX2Zvcm1hdCBpZ24gcmVzdCBpblxuICAgICAgZm10aXRlciBmbXQnIHRydWU7XG5cbiAgICB8IEZvcm1hdHRpbmdfbGl0IChmbXRpbmdfbGl0LCByZXN0KSAtPlxuICAgICAgYnByaW50X3N0cmluZ19saXRlcmFsIGJ1ZiAoc3RyaW5nX29mX2Zvcm1hdHRpbmdfbGl0IGZtdGluZ19saXQpO1xuICAgICAgZm10aXRlciByZXN0IGlnbl9mbGFnO1xuICAgIHwgRm9ybWF0dGluZ19nZW4gKGZtdGluZ19nZW4sIHJlc3QpIC0+XG4gICAgICBiZWdpbiBtYXRjaCBmbXRpbmdfZ2VuIHdpdGhcbiAgICAgIHwgT3Blbl90YWcgKEZvcm1hdCAoXywgc3RyKSkgLT5cbiAgICAgICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiQHtcIjsgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIHN0clxuICAgICAgfCBPcGVuX2JveCAoRm9ybWF0IChfLCBzdHIpKSAtPlxuICAgICAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgXCJAW1wiOyBidWZmZXJfYWRkX3N0cmluZyBidWYgc3RyXG4gICAgICBlbmQ7XG4gICAgICBmbXRpdGVyIHJlc3QgaWduX2ZsYWc7XG5cbiAgICB8IEVuZF9vZl9mb3JtYXQgLT4gKClcblxuICBpbiBmbXRpdGVyIGZtdCBmYWxzZVxuXG4oKioqKVxuXG4oKiBDb252ZXJ0IGEgZm9ybWF0IHRvIHN0cmluZy4gKilcbmxldCBzdHJpbmdfb2ZfZm10IGZtdCA9XG4gIGxldCBidWYgPSBidWZmZXJfY3JlYXRlIDE2IGluXG4gIGJwcmludF9mbXQgYnVmIGZtdDtcbiAgYnVmZmVyX2NvbnRlbnRzIGJ1ZlxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBUeXBlIGV4dHJhY3Rpb24gKilcblxudHlwZSAoXywgXykgZXEgPSBSZWZsIDogKCdhLCAnYSkgZXFcblxuKCogSW52YXJpYW50OiB0aGlzIGZ1bmN0aW9uIGlzIHRoZSBpZGVudGl0eSBvbiB2YWx1ZXMuXG5cbiAgIEluIHBhcnRpY3VsYXIsIGlmICh0eTEsIHR5MikgaGF2ZSBlcXVhbCB2YWx1ZXMsIHRoZW5cbiAgICh0cmFucyAoc3ltbSB0eTEpIHR5MikgcmVzcGVjdHMgdGhlICd0cmFucycgcHJlY29uZGl0aW9uLiAqKVxubGV0IHJlYyBzeW1tIDogdHlwZSBhMSBiMSBjMSBkMSBlMSBmMSBhMiBiMiBjMiBkMiBlMiBmMiAuXG4gICAoYTEsIGIxLCBjMSwgZDEsIGUxLCBmMSxcbiAgICBhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXR0eV9yZWxcbi0+IChhMiwgYjIsIGMyLCBkMiwgZTIsIGYyLFxuICAgIGExLCBiMSwgYzEsIGQxLCBlMSwgZjEpIGZtdHR5X3JlbFxuPSBmdW5jdGlvblxuICB8IENoYXJfdHkgcmVzdCAtPiBDaGFyX3R5IChzeW1tIHJlc3QpXG4gIHwgSW50X3R5IHJlc3QgLT4gSW50X3R5IChzeW1tIHJlc3QpXG4gIHwgSW50MzJfdHkgcmVzdCAtPiBJbnQzMl90eSAoc3ltbSByZXN0KVxuICB8IEludDY0X3R5IHJlc3QgLT4gSW50NjRfdHkgKHN5bW0gcmVzdClcbiAgfCBOYXRpdmVpbnRfdHkgcmVzdCAtPiBOYXRpdmVpbnRfdHkgKHN5bW0gcmVzdClcbiAgfCBGbG9hdF90eSByZXN0IC0+IEZsb2F0X3R5IChzeW1tIHJlc3QpXG4gIHwgQm9vbF90eSByZXN0IC0+IEJvb2xfdHkgKHN5bW0gcmVzdClcbiAgfCBTdHJpbmdfdHkgcmVzdCAtPiBTdHJpbmdfdHkgKHN5bW0gcmVzdClcbiAgfCBUaGV0YV90eSByZXN0IC0+IFRoZXRhX3R5IChzeW1tIHJlc3QpXG4gIHwgQWxwaGFfdHkgcmVzdCAtPiBBbHBoYV90eSAoc3ltbSByZXN0KVxuICB8IEFueV90eSByZXN0IC0+IEFueV90eSAoc3ltbSByZXN0KVxuICB8IFJlYWRlcl90eSByZXN0IC0+IFJlYWRlcl90eSAoc3ltbSByZXN0KVxuICB8IElnbm9yZWRfcmVhZGVyX3R5IHJlc3QgLT4gSWdub3JlZF9yZWFkZXJfdHkgKHN5bW0gcmVzdClcbiAgfCBGb3JtYXRfYXJnX3R5ICh0eSwgcmVzdCkgLT5cbiAgICBGb3JtYXRfYXJnX3R5ICh0eSwgc3ltbSByZXN0KVxuICB8IEZvcm1hdF9zdWJzdF90eSAodHkxLCB0eTIsIHJlc3QpIC0+XG4gICAgRm9ybWF0X3N1YnN0X3R5ICh0eTIsIHR5MSwgc3ltbSByZXN0KVxuICB8IEVuZF9vZl9mbXR0eSAtPiBFbmRfb2ZfZm10dHlcblxubGV0IHJlYyBmbXR0eV9yZWxfZGV0IDogdHlwZSBhMSBiIGMgZDEgZTEgZjEgYTIgZDIgZTIgZjIgLlxuICAoYTEsIGIsIGMsIGQxLCBlMSwgZjEsXG4gICBhMiwgYiwgYywgZDIsIGUyLCBmMikgZm10dHlfcmVsIC0+XG4gICAgKChmMSwgZjIpIGVxIC0+IChhMSwgYTIpIGVxKVxuICAqICgoYTEsIGEyKSBlcSAtPiAoZjEsIGYyKSBlcSlcbiAgKiAoKGUxLCBlMikgZXEgLT4gKGQxLCBkMikgZXEpXG4gICogKChkMSwgZDIpIGVxIC0+IChlMSwgZTIpIGVxKVxuPSBmdW5jdGlvblxuICB8IEVuZF9vZl9mbXR0eSAtPlxuICAgIChmdW4gUmVmbCAtPiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBSZWZsKVxuICB8IENoYXJfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcbiAgfCBTdHJpbmdfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcbiAgfCBJbnRfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcbiAgfCBJbnQzMl90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuICB8IEludDY0X3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG4gIHwgTmF0aXZlaW50X3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG4gIHwgRmxvYXRfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcbiAgfCBCb29sX3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG5cbiAgfCBUaGV0YV90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuICB8IEFscGhhX3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG4gIHwgQW55X3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG4gIHwgUmVhZGVyX3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZWQgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBkZSBSZWZsIGluIFJlZmwpXG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBlZCBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGRlIFJlZmwgaW4gUmVmbClcbiAgfCBGb3JtYXRfYXJnX3R5IChfdHksIHJlc3QpIC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuICB8IEZvcm1hdF9zdWJzdF90eSAodHkxLCB0eTIsIHJlc3QpIC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgbGV0IHR5ID0gdHJhbnMgKHN5bW0gdHkxKSB0eTIgaW5cbiAgICBsZXQgYWcsIGdhLCBkaiwgamQgPSBmbXR0eV9yZWxfZGV0IHR5IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBsZXQgUmVmbCA9IGFnIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZ2EgUmVmbCBpbiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZWQgUmVmbCBpbiBsZXQgUmVmbCA9IGRqIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gamQgUmVmbCBpbiBsZXQgUmVmbCA9IGRlIFJlZmwgaW4gUmVmbClcblxuKCogUHJlY29uZGl0aW9uOiB3ZSBhc3N1bWUgdGhhdCB0aGUgdHdvIGZtdHR5X3JlbCBhcmd1bWVudHMgaGF2ZSBlcXVhbFxuICAgdmFsdWVzIChhdCBwb3NzaWJseSBkaXN0aW5jdCB0eXBlcyk7IHRoaXMgaW52YXJpYW50IGNvbWVzIGZyb20gdGhlIHdheVxuICAgZm10dHlfcmVsIHdpdG5lc3NlcyBhcmUgcHJvZHVjZWQgYnkgdGhlIHR5cGUtY2hlY2tlclxuXG4gICBUaGUgY29kZSBiZWxvdyB1c2VzIChhc3NlcnQgZmFsc2UpIHdoZW4gdGhpcyBhc3N1bXB0aW9uIGlzIGJyb2tlbi4gVGhlXG4gICBjb2RlIHBhdHRlcm4gaXMgdGhlIGZvbGxvd2luZzpcblxuICAgICB8IEZvbyB4LCBGb28geSAtPlxuICAgICAgICgqIGNhc2Ugd2hlcmUgaW5kZWVkIGJvdGggdmFsdWVzXG4gICAgICAgICAgc3RhcnQgd2l0aCBjb25zdHJ1Y3RvciBGb28gKilcbiAgICAgfCBGb28gXywgX1xuICAgICB8IF8sIEZvbyBfIC0+XG4gICAgICAgKCogZGlmZmVyZW50IGhlYWQgY29uc3RydWN0b3JzOiBicm9rZW4gcHJlY29uZGl0aW9uICopXG4gICAgICAgYXNzZXJ0IGZhbHNlXG4qKVxuYW5kIHRyYW5zIDogdHlwZVxuICBhMSBiMSBjMSBkMSBlMSBmMVxuICBhMiBiMiBjMiBkMiBlMiBmMlxuICBhMyBiMyBjMyBkMyBlMyBmM1xuLlxuICAgKGExLCBiMSwgYzEsIGQxLCBlMSwgZjEsXG4gICAgYTIsIGIyLCBjMiwgZDIsIGUyLCBmMikgZm10dHlfcmVsXG4tPiAoYTIsIGIyLCBjMiwgZDIsIGUyLCBmMixcbiAgICBhMywgYjMsIGMzLCBkMywgZTMsIGYzKSBmbXR0eV9yZWxcbi0+IChhMSwgYjEsIGMxLCBkMSwgZTEsIGYxLFxuICAgIGEzLCBiMywgYzMsIGQzLCBlMywgZjMpIGZtdHR5X3JlbFxuPSBmdW4gdHkxIHR5MiAtPiBtYXRjaCB0eTEsIHR5MiB3aXRoXG4gIHwgQ2hhcl90eSByZXN0MSwgQ2hhcl90eSByZXN0MiAtPiBDaGFyX3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBTdHJpbmdfdHkgcmVzdDEsIFN0cmluZ190eSByZXN0MiAtPiBTdHJpbmdfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IEJvb2xfdHkgcmVzdDEsIEJvb2xfdHkgcmVzdDIgLT4gQm9vbF90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgSW50X3R5IHJlc3QxLCBJbnRfdHkgcmVzdDIgLT4gSW50X3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBJbnQzMl90eSByZXN0MSwgSW50MzJfdHkgcmVzdDIgLT4gSW50MzJfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IEludDY0X3R5IHJlc3QxLCBJbnQ2NF90eSByZXN0MiAtPiBJbnQ2NF90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgTmF0aXZlaW50X3R5IHJlc3QxLCBOYXRpdmVpbnRfdHkgcmVzdDIgLT4gTmF0aXZlaW50X3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBGbG9hdF90eSByZXN0MSwgRmxvYXRfdHkgcmVzdDIgLT4gRmxvYXRfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuXG4gIHwgQWxwaGFfdHkgcmVzdDEsIEFscGhhX3R5IHJlc3QyIC0+IEFscGhhX3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBBbHBoYV90eSBfLCBfIC0+IGFzc2VydCBmYWxzZVxuICB8IF8sIEFscGhhX3R5IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiAgfCBUaGV0YV90eSByZXN0MSwgVGhldGFfdHkgcmVzdDIgLT4gVGhldGFfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IFRoZXRhX3R5IF8sIF8gLT4gYXNzZXJ0IGZhbHNlXG4gIHwgXywgVGhldGFfdHkgXyAtPiBhc3NlcnQgZmFsc2VcblxuICB8IEFueV90eSByZXN0MSwgQW55X3R5IHJlc3QyIC0+IEFueV90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgQW55X3R5IF8sIF8gLT4gYXNzZXJ0IGZhbHNlXG4gIHwgXywgQW55X3R5IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiAgfCBSZWFkZXJfdHkgcmVzdDEsIFJlYWRlcl90eSByZXN0MiAtPiBSZWFkZXJfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IFJlYWRlcl90eSBfLCBfIC0+IGFzc2VydCBmYWxzZVxuICB8IF8sIFJlYWRlcl90eSBfIC0+IGFzc2VydCBmYWxzZVxuXG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgcmVzdDEsIElnbm9yZWRfcmVhZGVyX3R5IHJlc3QyIC0+XG4gICAgSWdub3JlZF9yZWFkZXJfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IElnbm9yZWRfcmVhZGVyX3R5IF8sIF8gLT4gYXNzZXJ0IGZhbHNlXG4gIHwgXywgSWdub3JlZF9yZWFkZXJfdHkgXyAtPiBhc3NlcnQgZmFsc2VcblxuICB8IEZvcm1hdF9hcmdfdHkgKHR5MSwgcmVzdDEpLCBGb3JtYXRfYXJnX3R5ICh0eTIsIHJlc3QyKSAtPlxuICAgIEZvcm1hdF9hcmdfdHkgKHRyYW5zIHR5MSB0eTIsIHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IEZvcm1hdF9hcmdfdHkgXywgXyAtPiBhc3NlcnQgZmFsc2VcbiAgfCBfLCBGb3JtYXRfYXJnX3R5IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiAgfCBGb3JtYXRfc3Vic3RfdHkgKHR5MTEsIHR5MTIsIHJlc3QxKSxcbiAgICBGb3JtYXRfc3Vic3RfdHkgKHR5MjEsIHR5MjIsIHJlc3QyKSAtPlxuICAgIGxldCB0eSA9IHRyYW5zIChzeW1tIHR5MTIpIHR5MjEgaW5cbiAgICBsZXQgXywgZjIsIF8sIGY0ID0gZm10dHlfcmVsX2RldCB0eSBpblxuICAgIGxldCBSZWZsID0gZjIgUmVmbCBpblxuICAgIGxldCBSZWZsID0gZjQgUmVmbCBpblxuICAgIEZvcm1hdF9zdWJzdF90eSAodHkxMSwgdHkyMiwgdHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgRm9ybWF0X3N1YnN0X3R5IF8sIF8gLT4gYXNzZXJ0IGZhbHNlXG4gIHwgXywgRm9ybWF0X3N1YnN0X3R5IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiAgfCBFbmRfb2ZfZm10dHksIEVuZF9vZl9mbXR0eSAtPiBFbmRfb2ZfZm10dHlcbiAgfCBFbmRfb2ZfZm10dHksIF8gLT4gYXNzZXJ0IGZhbHNlXG4gIHwgXywgRW5kX29mX2ZtdHR5IC0+IGFzc2VydCBmYWxzZVxuXG5sZXQgcmVjIGZtdHR5X29mX2Zvcm1hdHRpbmdfZ2VuIDogdHlwZSBhIGIgYyBkIGUgZiAuXG4gIChhLCBiLCBjLCBkLCBlLCBmKSBmb3JtYXR0aW5nX2dlbiAtPlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSA9XG5mdW4gZm9ybWF0dGluZ19nZW4gLT4gbWF0Y2ggZm9ybWF0dGluZ19nZW4gd2l0aFxuICB8IE9wZW5fdGFnIChGb3JtYXQgKGZtdCwgXykpIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBPcGVuX2JveCAoRm9ybWF0IChmbXQsIF8pKSAtPiBmbXR0eV9vZl9mbXQgZm10XG5cbigqIEV4dHJhY3QgdGhlIHR5cGUgcmVwcmVzZW50YXRpb24gKGFuIGZtdHR5KSBvZiBhIGZvcm1hdC4gKilcbmFuZCBmbXR0eV9vZl9mbXQgOiB0eXBlIGEgYiBjIGQgZSBmIC5cbiAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10dHkgPVxuZnVuIGZtdHR5IC0+IG1hdGNoIGZtdHR5IHdpdGhcbiAgfCBTdHJpbmcgKHBhZCwgcmVzdCkgLT5cbiAgICBmbXR0eV9vZl9wYWRkaW5nX2ZtdHR5IHBhZCAoU3RyaW5nX3R5IChmbXR0eV9vZl9mbXQgcmVzdCkpXG4gIHwgQ2FtbF9zdHJpbmcgKHBhZCwgcmVzdCkgLT5cbiAgICBmbXR0eV9vZl9wYWRkaW5nX2ZtdHR5IHBhZCAoU3RyaW5nX3R5IChmbXR0eV9vZl9mbXQgcmVzdCkpXG5cbiAgfCBJbnQgKF8sIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBsZXQgdHlfcmVzdCA9IGZtdHR5X29mX2ZtdCByZXN0IGluXG4gICAgbGV0IHByZWNfdHkgPSBmbXR0eV9vZl9wcmVjaXNpb25fZm10dHkgcHJlYyAoSW50X3R5IHR5X3Jlc3QpIGluXG4gICAgZm10dHlfb2ZfcGFkZGluZ19mbXR0eSBwYWQgcHJlY190eVxuICB8IEludDMyIChfLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbGV0IHR5X3Jlc3QgPSBmbXR0eV9vZl9mbXQgcmVzdCBpblxuICAgIGxldCBwcmVjX3R5ID0gZm10dHlfb2ZfcHJlY2lzaW9uX2ZtdHR5IHByZWMgKEludDMyX3R5IHR5X3Jlc3QpIGluXG4gICAgZm10dHlfb2ZfcGFkZGluZ19mbXR0eSBwYWQgcHJlY190eVxuICB8IE5hdGl2ZWludCAoXywgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIGxldCB0eV9yZXN0ID0gZm10dHlfb2ZfZm10IHJlc3QgaW5cbiAgICBsZXQgcHJlY190eSA9IGZtdHR5X29mX3ByZWNpc2lvbl9mbXR0eSBwcmVjIChOYXRpdmVpbnRfdHkgdHlfcmVzdCkgaW5cbiAgICBmbXR0eV9vZl9wYWRkaW5nX2ZtdHR5IHBhZCBwcmVjX3R5XG4gIHwgSW50NjQgKF8sIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBsZXQgdHlfcmVzdCA9IGZtdHR5X29mX2ZtdCByZXN0IGluXG4gICAgbGV0IHByZWNfdHkgPSBmbXR0eV9vZl9wcmVjaXNpb25fZm10dHkgcHJlYyAoSW50NjRfdHkgdHlfcmVzdCkgaW5cbiAgICBmbXR0eV9vZl9wYWRkaW5nX2ZtdHR5IHBhZCBwcmVjX3R5XG4gIHwgRmxvYXQgKF8sIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBsZXQgdHlfcmVzdCA9IGZtdHR5X29mX2ZtdCByZXN0IGluXG4gICAgbGV0IHByZWNfdHkgPSBmbXR0eV9vZl9wcmVjaXNpb25fZm10dHkgcHJlYyAoRmxvYXRfdHkgdHlfcmVzdCkgaW5cbiAgICBmbXR0eV9vZl9wYWRkaW5nX2ZtdHR5IHBhZCBwcmVjX3R5XG5cbiAgfCBDaGFyIHJlc3QgICAgICAgICAgICAgICAgICAtPiBDaGFyX3R5IChmbXR0eV9vZl9mbXQgcmVzdClcbiAgfCBDYW1sX2NoYXIgcmVzdCAgICAgICAgICAgICAtPiBDaGFyX3R5IChmbXR0eV9vZl9mbXQgcmVzdClcbiAgfCBCb29sIChwYWQsIHJlc3QpICAgICAgICAgICAtPlxuICAgICAgZm10dHlfb2ZfcGFkZGluZ19mbXR0eSBwYWQgKEJvb2xfdHkgKGZtdHR5X29mX2ZtdCByZXN0KSlcbiAgfCBBbHBoYSByZXN0ICAgICAgICAgICAgICAgICAtPiBBbHBoYV90eSAoZm10dHlfb2ZfZm10IHJlc3QpXG4gIHwgVGhldGEgcmVzdCAgICAgICAgICAgICAgICAgLT4gVGhldGFfdHkgKGZtdHR5X29mX2ZtdCByZXN0KVxuICB8IEN1c3RvbSAoYXJpdHksIF8sIHJlc3QpICAgIC0+IGZtdHR5X29mX2N1c3RvbSBhcml0eSAoZm10dHlfb2ZfZm10IHJlc3QpXG4gIHwgUmVhZGVyIHJlc3QgICAgICAgICAgICAgICAgLT4gUmVhZGVyX3R5IChmbXR0eV9vZl9mbXQgcmVzdClcblxuICB8IEZvcm1hdF9hcmcgKF8sIHR5LCByZXN0KSAtPlxuICAgIEZvcm1hdF9hcmdfdHkgKHR5LCBmbXR0eV9vZl9mbXQgcmVzdClcbiAgfCBGb3JtYXRfc3Vic3QgKF8sIHR5LCByZXN0KSAtPlxuICAgIEZvcm1hdF9zdWJzdF90eSAodHksIHR5LCBmbXR0eV9vZl9mbXQgcmVzdClcblxuICB8IEZsdXNoIHJlc3QgICAgICAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCByZXN0XG4gIHwgU3RyaW5nX2xpdGVyYWwgKF8sIHJlc3QpICAgLT4gZm10dHlfb2ZfZm10IHJlc3RcbiAgfCBDaGFyX2xpdGVyYWwgKF8sIHJlc3QpICAgICAtPiBmbXR0eV9vZl9mbXQgcmVzdFxuXG4gIHwgU2Nhbl9jaGFyX3NldCAoXywgXywgcmVzdCkgLT4gU3RyaW5nX3R5IChmbXR0eV9vZl9mbXQgcmVzdClcbiAgfCBTY2FuX2dldF9jb3VudGVyIChfLCByZXN0KSAtPiBJbnRfdHkgKGZtdHR5X29mX2ZtdCByZXN0KVxuICB8IFNjYW5fbmV4dF9jaGFyIHJlc3QgICAgICAgIC0+IENoYXJfdHkgKGZtdHR5X29mX2ZtdCByZXN0KVxuICB8IElnbm9yZWRfcGFyYW0gKGlnbiwgcmVzdCkgIC0+IGZtdHR5X29mX2lnbm9yZWRfZm9ybWF0IGlnbiByZXN0XG4gIHwgRm9ybWF0dGluZ19saXQgKF8sIHJlc3QpICAgLT4gZm10dHlfb2ZfZm10IHJlc3RcbiAgfCBGb3JtYXR0aW5nX2dlbiAoZm10aW5nX2dlbiwgcmVzdCkgIC0+XG4gICAgY29uY2F0X2ZtdHR5IChmbXR0eV9vZl9mb3JtYXR0aW5nX2dlbiBmbXRpbmdfZ2VuKSAoZm10dHlfb2ZfZm10IHJlc3QpXG5cbiAgfCBFbmRfb2ZfZm9ybWF0ICAgICAgICAgICAgICAtPiBFbmRfb2ZfZm10dHlcblxuYW5kIGZtdHR5X29mX2N1c3RvbSA6IHR5cGUgeCB5IGEgYiBjIGQgZSBmIC5cbiAgKGEsIHgsIHkpIGN1c3RvbV9hcml0eSAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10dHkgLT5cbiAgKHksIGIsIGMsIGQsIGUsIGYpIGZtdHR5ID1cbmZ1biBhcml0eSBmbXR0eSAtPiBtYXRjaCBhcml0eSB3aXRoXG4gIHwgQ3VzdG9tX3plcm8gLT4gZm10dHlcbiAgfCBDdXN0b21fc3VjYyBhcml0eSAtPiBBbnlfdHkgKGZtdHR5X29mX2N1c3RvbSBhcml0eSBmbXR0eSlcblxuKCogRXh0cmFjdCB0aGUgZm10dHkgb2YgYW4gaWdub3JlZCBwYXJhbWV0ZXIgZm9sbG93ZWQgYnkgdGhlIHJlc3Qgb2ZcbiAgIHRoZSBmb3JtYXQuICopXG5hbmQgZm10dHlfb2ZfaWdub3JlZF9mb3JtYXQgOiB0eXBlIHggeSBhIGIgYyBkIGUgZiAuXG4gICAgKGEsIGIsIGMsIGQsIHksIHgpIGlnbm9yZWQgLT5cbiAgICAoeCwgYiwgYywgeSwgZSwgZikgZm10IC0+XG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5ID1cbmZ1biBpZ24gZm10IC0+IG1hdGNoIGlnbiB3aXRoXG4gIHwgSWdub3JlZF9jaGFyICAgICAgICAgICAgICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9jYW1sX2NoYXIgICAgICAgICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9zdHJpbmcgXyAgICAgICAgICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9jYW1sX3N0cmluZyBfICAgICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9pbnQgKF8sIF8pICAgICAgICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9pbnQzMiAoXywgXykgICAgICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9uYXRpdmVpbnQgKF8sIF8pICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9pbnQ2NCAoXywgXykgICAgICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9mbG9hdCAoXywgXykgICAgICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9ib29sIF8gICAgICAgICAgICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9mb3JtYXRfYXJnIF8gICAgICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9mb3JtYXRfc3Vic3QgKF8sIGZtdHR5KSAtPiBjb25jYXRfZm10dHkgZm10dHkgKGZtdHR5X29mX2ZtdCBmbXQpXG4gIHwgSWdub3JlZF9yZWFkZXIgICAgICAgICAgICAgICAgICAtPiBJZ25vcmVkX3JlYWRlcl90eSAoZm10dHlfb2ZfZm10IGZtdClcbiAgfCBJZ25vcmVkX3NjYW5fY2hhcl9zZXQgXyAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX3NjYW5fZ2V0X2NvdW50ZXIgXyAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX3NjYW5fbmV4dF9jaGFyICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcblxuKCogQWRkIGFuIEludF90eSBub2RlIGlmIHBhZGRpbmcgaXMgdGFrZW4gYXMgYW4gZXh0cmEgYXJndW1lbnQgKGV4OiBcIiUqc1wiKS4gKilcbmFuZCBmbXR0eV9vZl9wYWRkaW5nX2ZtdHR5IDogdHlwZSB4IGEgYiBjIGQgZSBmIC5cbiAgICAoeCwgYSkgcGFkZGluZyAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10dHkgLT4gKHgsIGIsIGMsIGQsIGUsIGYpIGZtdHR5ID1cbiAgZnVuIHBhZCBmbXR0eSAtPiBtYXRjaCBwYWQgd2l0aFxuICAgIHwgTm9fcGFkZGluZyAgICAtPiBmbXR0eVxuICAgIHwgTGl0X3BhZGRpbmcgXyAtPiBmbXR0eVxuICAgIHwgQXJnX3BhZGRpbmcgXyAtPiBJbnRfdHkgZm10dHlcblxuKCogQWRkIGFuIEludF90eSBub2RlIGlmIHByZWNpc2lvbiBpcyB0YWtlbiBhcyBhbiBleHRyYSBhcmd1bWVudCAoZXg6IFwiJS4qZlwiKS4qKVxuYW5kIGZtdHR5X29mX3ByZWNpc2lvbl9mbXR0eSA6IHR5cGUgeCBhIGIgYyBkIGUgZiAuXG4gICAgKHgsIGEpIHByZWNpc2lvbiAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10dHkgLT4gKHgsIGIsIGMsIGQsIGUsIGYpIGZtdHR5ID1cbiAgZnVuIHByZWMgZm10dHkgLT4gbWF0Y2ggcHJlYyB3aXRoXG4gICAgfCBOb19wcmVjaXNpb24gICAgLT4gZm10dHlcbiAgICB8IExpdF9wcmVjaXNpb24gXyAtPiBmbXR0eVxuICAgIHwgQXJnX3ByZWNpc2lvbiAgIC0+IEludF90eSBmbXR0eVxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEZvcm1hdCB0eXBpbmcgKilcblxuKCogRXhjZXB0aW9uIHJhaXNlZCB3aGVuIGEgZm9ybWF0IGRvZXMgbm90IG1hdGNoIGEgZ2l2ZW4gZm9ybWF0IHR5cGUuICopXG5leGNlcHRpb24gVHlwZV9taXNtYXRjaFxuXG4oKiBUeXBlIGEgcGFkZGluZy4gKilcbigqIFRha2UgYW4gSW50X3R5IGZyb20gdGhlIGZtdHR5IGlmIHRoZSBpbnRlZ2VyIHNob3VsZCBiZSBrZXB0IGFzIGFyZ3VtZW50LiAqKVxuKCogUmFpc2UgVHlwZV9taXNtYXRjaCBpbiBjYXNlIG9mIHR5cGUgbWlzbWF0Y2guICopXG5sZXQgdHlwZV9wYWRkaW5nIDogdHlwZSBhIGIgYyBkIGUgZiB4IHkgLlxuICAgICh4LCB5KSBwYWRkaW5nIC0+IChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSAtPlxuICAgICAgKGEsIGIsIGMsIGQsIGUsIGYpIHBhZGRpbmdfZm10dHlfZWJiID1cbmZ1biBwYWQgZm10dHkgLT4gbWF0Y2ggcGFkLCBmbXR0eSB3aXRoXG4gIHwgTm9fcGFkZGluZywgXyAtPiBQYWRkaW5nX2ZtdHR5X0VCQiAoTm9fcGFkZGluZywgZm10dHkpXG4gIHwgTGl0X3BhZGRpbmcgKHBhZHR5LCB3KSwgXyAtPiBQYWRkaW5nX2ZtdHR5X0VCQiAoTGl0X3BhZGRpbmcgKHBhZHR5LHcpLGZtdHR5KVxuICB8IEFyZ19wYWRkaW5nIHBhZHR5LCBJbnRfdHkgcmVzdCAtPiBQYWRkaW5nX2ZtdHR5X0VCQiAoQXJnX3BhZGRpbmcgcGFkdHkscmVzdClcbiAgfCBfIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcblxuKCogQ29udmVydCBhICh1cGFkZGluZywgdXByZWNpc2lvbikgdG8gYSAocGFkZGluZywgcHJlY2lzaW9uKS4gKilcbigqIFRha2Ugb25lIG9yIHR3byBJbnRfdHkgZnJvbSB0aGUgZm10dHkgaWYgbmVlZGVkLiAqKVxuKCogUmFpc2UgVHlwZV9taXNtYXRjaCBpbiBjYXNlIG9mIHR5cGUgbWlzbWF0Y2guICopXG5sZXQgdHlwZV9wYWRwcmVjIDogdHlwZSBhIGIgYyBkIGUgZiB4IHkgeiAuXG4gICh4LCB5KSBwYWRkaW5nIC0+ICh5LCB6KSBwcmVjaXNpb24gLT4gKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5IC0+XG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIHBhZHByZWNfZm10dHlfZWJiID1cbmZ1biBwYWQgcHJlYyBmbXR0eSAtPiBtYXRjaCBwcmVjLCB0eXBlX3BhZGRpbmcgcGFkIGZtdHR5IHdpdGhcbiAgfCBOb19wcmVjaXNpb24sIFBhZGRpbmdfZm10dHlfRUJCIChwYWQsIHJlc3QpIC0+XG4gICAgUGFkcHJlY19mbXR0eV9FQkIgKHBhZCwgTm9fcHJlY2lzaW9uLCByZXN0KVxuICB8IExpdF9wcmVjaXNpb24gcCwgUGFkZGluZ19mbXR0eV9FQkIgKHBhZCwgcmVzdCkgLT5cbiAgICBQYWRwcmVjX2ZtdHR5X0VCQiAocGFkLCBMaXRfcHJlY2lzaW9uIHAsIHJlc3QpXG4gIHwgQXJnX3ByZWNpc2lvbiwgUGFkZGluZ19mbXR0eV9FQkIgKHBhZCwgSW50X3R5IHJlc3QpIC0+XG4gICAgUGFkcHJlY19mbXR0eV9FQkIgKHBhZCwgQXJnX3ByZWNpc2lvbiwgcmVzdClcbiAgfCBfLCBQYWRkaW5nX2ZtdHR5X0VCQiAoXywgXykgLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuXG4oKiBUeXBlIGEgZm9ybWF0IGFjY29yZGluZyB0byBhbiBmbXR0eS4gKilcbigqIElmIHR5cGluZyBzdWNjZWVkLCBnZW5lcmF0ZSBhIGNvcHkgb2YgdGhlIGZvcm1hdCB3aXRoIHRoZSBzYW1lXG4gICAgdHlwZSBwYXJhbWV0ZXJzIGFzIHRoZSBmbXR0eS4gKilcbigqIFJhaXNlIFtGYWlsdXJlXSB3aXRoIGFuIGVycm9yIG1lc3NhZ2UgaW4gY2FzZSBvZiB0eXBlIG1pc21hdGNoLiAqKVxubGV0IHJlYyB0eXBlX2Zvcm1hdCA6XG4gIHR5cGUgYTEgYjEgYzEgZDEgZTEgZjFcbiAgICAgICBhMiBiMiBjMiBkMiBlMiBmMiAgLlxuICAgICAoYTEsIGIxLCBjMSwgZDEsIGUxLCBmMSkgZm10XG4gIC0+IChhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXR0eVxuICAtPiAoYTIsIGIyLCBjMiwgZDIsIGUyLCBmMikgZm10XG49IGZ1biBmbXQgZm10dHkgLT4gbWF0Y2ggdHlwZV9mb3JtYXRfZ2VuIGZtdCBmbXR0eSB3aXRoXG4gIHwgRm10X2ZtdHR5X0VCQiAoZm10JywgRW5kX29mX2ZtdHR5KSAtPiBmbXQnXG4gIHwgXyAtPiByYWlzZSBUeXBlX21pc21hdGNoXG5cbmFuZCB0eXBlX2Zvcm1hdF9nZW4gOlxuICB0eXBlIGExIGIxIGMxIGQxIGUxIGYxXG4gICAgICAgYTIgYjIgYzIgZDIgZTIgZjIgIC5cbiAgICAgKGExLCBiMSwgYzEsIGQxLCBlMSwgZjEpIGZtdFxuICAtPiAoYTIsIGIyLCBjMiwgZDIsIGUyLCBmMikgZm10dHlcbiAgLT4gKGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIpIGZtdF9mbXR0eV9lYmJcbj0gZnVuIGZtdCBmbXR0eSAtPiBtYXRjaCBmbXQsIGZtdHR5IHdpdGhcbiAgfCBDaGFyIGZtdF9yZXN0LCBDaGFyX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoQ2hhciBmbXQnLCBmbXR0eScpXG4gIHwgQ2FtbF9jaGFyIGZtdF9yZXN0LCBDaGFyX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoQ2FtbF9jaGFyIGZtdCcsIGZtdHR5JylcbiAgfCBTdHJpbmcgKHBhZCwgZm10X3Jlc3QpLCBfIC0+IChcbiAgICBtYXRjaCB0eXBlX3BhZGRpbmcgcGFkIGZtdHR5IHdpdGhcbiAgICB8IFBhZGRpbmdfZm10dHlfRUJCIChwYWQsIFN0cmluZ190eSBmbXR0eV9yZXN0KSAtPlxuICAgICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgICAgRm10X2ZtdHR5X0VCQiAoU3RyaW5nIChwYWQsIGZtdCcpLCBmbXR0eScpXG4gICAgfCBQYWRkaW5nX2ZtdHR5X0VCQiAoXywgXykgLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuICApXG4gIHwgQ2FtbF9zdHJpbmcgKHBhZCwgZm10X3Jlc3QpLCBfIC0+IChcbiAgICBtYXRjaCB0eXBlX3BhZGRpbmcgcGFkIGZtdHR5IHdpdGhcbiAgICB8IFBhZGRpbmdfZm10dHlfRUJCIChwYWQsIFN0cmluZ190eSBmbXR0eV9yZXN0KSAtPlxuICAgICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgICAgRm10X2ZtdHR5X0VCQiAoQ2FtbF9zdHJpbmcgKHBhZCwgZm10JyksIGZtdHR5JylcbiAgICB8IFBhZGRpbmdfZm10dHlfRUJCIChfLCBfKSAtPiByYWlzZSBUeXBlX21pc21hdGNoXG4gIClcbiAgfCBJbnQgKGljb252LCBwYWQsIHByZWMsIGZtdF9yZXN0KSwgXyAtPiAoXG4gICAgbWF0Y2ggdHlwZV9wYWRwcmVjIHBhZCBwcmVjIGZtdHR5IHdpdGhcbiAgICB8IFBhZHByZWNfZm10dHlfRUJCIChwYWQsIHByZWMsIEludF90eSBmbXR0eV9yZXN0KSAtPlxuICAgICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgICAgRm10X2ZtdHR5X0VCQiAoSW50IChpY29udiwgcGFkLCBwcmVjLCBmbXQnKSwgZm10dHknKVxuICAgIHwgUGFkcHJlY19mbXR0eV9FQkIgKF8sIF8sIF8pIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcbiAgKVxuICB8IEludDMyIChpY29udiwgcGFkLCBwcmVjLCBmbXRfcmVzdCksIF8gLT4gKFxuICAgIG1hdGNoIHR5cGVfcGFkcHJlYyBwYWQgcHJlYyBmbXR0eSB3aXRoXG4gICAgfCBQYWRwcmVjX2ZtdHR5X0VCQiAocGFkLCBwcmVjLCBJbnQzMl90eSBmbXR0eV9yZXN0KSAtPlxuICAgICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgICAgRm10X2ZtdHR5X0VCQiAoSW50MzIgKGljb252LCBwYWQsIHByZWMsIGZtdCcpLCBmbXR0eScpXG4gICAgfCBQYWRwcmVjX2ZtdHR5X0VCQiAoXywgXywgXykgLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuICApXG4gIHwgTmF0aXZlaW50IChpY29udiwgcGFkLCBwcmVjLCBmbXRfcmVzdCksIF8gLT4gKFxuICAgIG1hdGNoIHR5cGVfcGFkcHJlYyBwYWQgcHJlYyBmbXR0eSB3aXRoXG4gICAgfCBQYWRwcmVjX2ZtdHR5X0VCQiAocGFkLCBwcmVjLCBOYXRpdmVpbnRfdHkgZm10dHlfcmVzdCkgLT5cbiAgICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICAgIEZtdF9mbXR0eV9FQkIgKE5hdGl2ZWludCAoaWNvbnYsIHBhZCwgcHJlYywgZm10JyksIGZtdHR5JylcbiAgICB8IFBhZHByZWNfZm10dHlfRUJCIChfLCBfLCBfKSAtPiByYWlzZSBUeXBlX21pc21hdGNoXG4gIClcbiAgfCBJbnQ2NCAoaWNvbnYsIHBhZCwgcHJlYywgZm10X3Jlc3QpLCBfIC0+IChcbiAgICBtYXRjaCB0eXBlX3BhZHByZWMgcGFkIHByZWMgZm10dHkgd2l0aFxuICAgIHwgUGFkcHJlY19mbXR0eV9FQkIgKHBhZCwgcHJlYywgSW50NjRfdHkgZm10dHlfcmVzdCkgLT5cbiAgICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICAgIEZtdF9mbXR0eV9FQkIgKEludDY0IChpY29udiwgcGFkLCBwcmVjLCBmbXQnKSwgZm10dHknKVxuICAgIHwgUGFkcHJlY19mbXR0eV9FQkIgKF8sIF8sIF8pIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcbiAgKVxuICB8IEZsb2F0IChmY29udiwgcGFkLCBwcmVjLCBmbXRfcmVzdCksIF8gLT4gKFxuICAgIG1hdGNoIHR5cGVfcGFkcHJlYyBwYWQgcHJlYyBmbXR0eSB3aXRoXG4gICAgfCBQYWRwcmVjX2ZtdHR5X0VCQiAocGFkLCBwcmVjLCBGbG9hdF90eSBmbXR0eV9yZXN0KSAtPlxuICAgICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgICAgRm10X2ZtdHR5X0VCQiAoRmxvYXQgKGZjb252LCBwYWQsIHByZWMsIGZtdCcpLCBmbXR0eScpXG4gICAgfCBQYWRwcmVjX2ZtdHR5X0VCQiAoXywgXywgXykgLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuICApXG4gIHwgQm9vbCAocGFkLCBmbXRfcmVzdCksIF8gLT4gKFxuICAgIG1hdGNoIHR5cGVfcGFkZGluZyBwYWQgZm10dHkgd2l0aFxuICAgIHwgUGFkZGluZ19mbXR0eV9FQkIgKHBhZCwgQm9vbF90eSBmbXR0eV9yZXN0KSAtPlxuICAgICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgICAgRm10X2ZtdHR5X0VCQiAoQm9vbCAocGFkLCBmbXQnKSwgZm10dHknKVxuICAgIHwgUGFkZGluZ19mbXR0eV9FQkIgKF8sIF8pIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcbiAgKVxuICB8IEZsdXNoIGZtdF9yZXN0LCBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKEZsdXNoIGZtdCcsIGZtdHR5JylcblxuICB8IFN0cmluZ19saXRlcmFsIChzdHIsIGZtdF9yZXN0KSwgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChTdHJpbmdfbGl0ZXJhbCAoc3RyLCBmbXQnKSwgZm10dHknKVxuICB8IENoYXJfbGl0ZXJhbCAoY2hyLCBmbXRfcmVzdCksIGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoQ2hhcl9saXRlcmFsIChjaHIsIGZtdCcpLCBmbXR0eScpXG5cbiAgfCBGb3JtYXRfYXJnIChwYWRfb3B0LCBzdWJfZm10dHksIGZtdF9yZXN0KSxcbiAgICBGb3JtYXRfYXJnX3R5IChzdWJfZm10dHknLCBmbXR0eV9yZXN0KSAtPlxuICAgIGlmIEZtdHR5X0VCQiBzdWJfZm10dHkgPD4gRm10dHlfRUJCIHN1Yl9mbXR0eScgdGhlbiByYWlzZSBUeXBlX21pc21hdGNoO1xuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChGb3JtYXRfYXJnIChwYWRfb3B0LCBzdWJfZm10dHknLCBmbXQnKSwgZm10dHknKVxuICB8IEZvcm1hdF9zdWJzdCAocGFkX29wdCwgc3ViX2ZtdHR5LCBmbXRfcmVzdCksXG4gICAgRm9ybWF0X3N1YnN0X3R5IChzdWJfZm10dHkxLCBfc3ViX2ZtdHR5MiwgZm10dHlfcmVzdCkgLT5cbiAgICBpZiBGbXR0eV9FQkIgKGVyYXNlX3JlbCBzdWJfZm10dHkpIDw+IEZtdHR5X0VCQiAoZXJhc2VfcmVsIHN1Yl9mbXR0eTEpIHRoZW5cbiAgICAgIHJhaXNlIFR5cGVfbWlzbWF0Y2g7XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPVxuICAgICAgdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IChlcmFzZV9yZWwgZm10dHlfcmVzdClcbiAgICBpblxuICAgIEZtdF9mbXR0eV9FQkIgKEZvcm1hdF9zdWJzdCAocGFkX29wdCwgc3ViX2ZtdHR5MSwgZm10JyksIGZtdHR5JylcbiAgKCogUHJpbnRmIGFuZCBGb3JtYXQgc3BlY2lmaWMgY29uc3RydWN0b3JzOiAqKVxuICB8IEFscGhhIGZtdF9yZXN0LCBBbHBoYV90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKEFscGhhIGZtdCcsIGZtdHR5JylcbiAgfCBUaGV0YSBmbXRfcmVzdCwgVGhldGFfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChUaGV0YSBmbXQnLCBmbXR0eScpXG5cbiAgKCogRm9ybWF0IHNwZWNpZmljIGNvbnN0cnVjdG9yczogKilcbiAgfCBGb3JtYXR0aW5nX2xpdCAoZm9ybWF0dGluZ19saXQsIGZtdF9yZXN0KSwgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChGb3JtYXR0aW5nX2xpdCAoZm9ybWF0dGluZ19saXQsIGZtdCcpLCBmbXR0eScpXG4gIHwgRm9ybWF0dGluZ19nZW4gKGZvcm1hdHRpbmdfZ2VuLCBmbXRfcmVzdCksIGZtdHR5X3Jlc3QgLT5cbiAgICB0eXBlX2Zvcm1hdHRpbmdfZ2VuIGZvcm1hdHRpbmdfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3RcblxuICAoKiBTY2FuZiBzcGVjaWZpYyBjb25zdHJ1Y3RvcnM6ICopXG4gIHwgUmVhZGVyIGZtdF9yZXN0LCBSZWFkZXJfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChSZWFkZXIgZm10JywgZm10dHknKVxuICB8IFNjYW5fY2hhcl9zZXQgKHdpZHRoX29wdCwgY2hhcl9zZXQsIGZtdF9yZXN0KSwgU3RyaW5nX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoU2Nhbl9jaGFyX3NldCAod2lkdGhfb3B0LCBjaGFyX3NldCwgZm10JyksIGZtdHR5JylcbiAgfCBTY2FuX2dldF9jb3VudGVyIChjb3VudGVyLCBmbXRfcmVzdCksIEludF90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKFNjYW5fZ2V0X2NvdW50ZXIgKGNvdW50ZXIsIGZtdCcpLCBmbXR0eScpXG4gIHwgSWdub3JlZF9wYXJhbSAoaWduLCByZXN0KSwgZm10dHlfcmVzdCAtPlxuICAgIHR5cGVfaWdub3JlZF9wYXJhbSBpZ24gcmVzdCBmbXR0eV9yZXN0XG5cbiAgfCBFbmRfb2ZfZm9ybWF0LCBmbXR0eV9yZXN0IC0+IEZtdF9mbXR0eV9FQkIgKEVuZF9vZl9mb3JtYXQsIGZtdHR5X3Jlc3QpXG5cbiAgfCBfIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcblxuYW5kIHR5cGVfZm9ybWF0dGluZ19nZW4gOiB0eXBlIGExIGEzIGIxIGIzIGMxIGMzIGQxIGQzIGUxIGUyIGUzIGYxIGYyIGYzIC5cbiAgICAoYTEsIGIxLCBjMSwgZDEsIGUxLCBmMSkgZm9ybWF0dGluZ19nZW4gLT5cbiAgICAoZjEsIGIxLCBjMSwgZTEsIGUyLCBmMikgZm10IC0+XG4gICAgKGEzLCBiMywgYzMsIGQzLCBlMywgZjMpIGZtdHR5IC0+XG4gICAgKGEzLCBiMywgYzMsIGQzLCBlMywgZjMpIGZtdF9mbXR0eV9lYmIgPVxuZnVuIGZvcm1hdHRpbmdfZ2VuIGZtdDAgZm10dHkwIC0+IG1hdGNoIGZvcm1hdHRpbmdfZ2VuIHdpdGhcbiAgfCBPcGVuX3RhZyAoRm9ybWF0IChmbXQxLCBzdHIpKSAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQyLCBmbXR0eTIpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdDEgZm10dHkwIGluXG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdDMsIGZtdHR5MykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10MCBmbXR0eTIgaW5cbiAgICBGbXRfZm10dHlfRUJCIChGb3JtYXR0aW5nX2dlbiAoT3Blbl90YWcgKEZvcm1hdCAoZm10Miwgc3RyKSksIGZtdDMpLCBmbXR0eTMpXG4gIHwgT3Blbl9ib3ggKEZvcm1hdCAoZm10MSwgc3RyKSkgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10MiwgZm10dHkyKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXQxIGZtdHR5MCBpblxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQzLCBmbXR0eTMpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdDAgZm10dHkyIGluXG4gICAgRm10X2ZtdHR5X0VCQiAoRm9ybWF0dGluZ19nZW4gKE9wZW5fYm94IChGb3JtYXQgKGZtdDIsIHN0cikpLCBmbXQzKSwgZm10dHkzKVxuXG4oKiBUeXBlIGFuIElnbm9yZWRfcGFyYW0gbm9kZSBhY2NvcmRpbmcgdG8gYW4gZm10dHkuICopXG5hbmQgdHlwZV9pZ25vcmVkX3BhcmFtIDogdHlwZSBwIHEgeCB5IHogdCB1IHYgYSBiIGMgZCBlIGYgLlxuICAgICh4LCB5LCB6LCB0LCBxLCBwKSBpZ25vcmVkIC0+XG4gICAgKHAsIHksIHosIHEsIHUsIHYpIGZtdCAtPlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSAtPlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXRfZm10dHlfZWJiID1cbmZ1biBpZ24gZm10IGZtdHR5IC0+IG1hdGNoIGlnbiB3aXRoXG4gIHwgSWdub3JlZF9jaGFyICAgICAgICAgICAgICAgYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9jYW1sX2NoYXIgICAgICAgICAgYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9zdHJpbmcgXyAgICAgICAgICAgYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9jYW1sX3N0cmluZyBfICAgICAgYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9pbnQgXyAgICAgICAgICAgICAgYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9pbnQzMiBfICAgICAgICAgICAgYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9uYXRpdmVpbnQgXyAgICAgICAgYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9pbnQ2NCBfICAgICAgICAgICAgYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9mbG9hdCBfICAgICAgICAgICAgYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9ib29sIF8gICAgICAgICAgICAgYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9zY2FuX2NoYXJfc2V0IF8gICAgYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9zY2FuX2dldF9jb3VudGVyIF8gYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9zY2FuX25leHRfY2hhciAgICAgYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9mb3JtYXRfYXJnIChwYWRfb3B0LCBzdWJfZm10dHkpIC0+XG4gICAgdHlwZV9pZ25vcmVkX3BhcmFtX29uZSAoSWdub3JlZF9mb3JtYXRfYXJnIChwYWRfb3B0LCBzdWJfZm10dHkpKSBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX2Zvcm1hdF9zdWJzdCAocGFkX29wdCwgc3ViX2ZtdHR5KSAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHknLCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHkgZm10IGZtdHR5IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoSWdub3JlZF9wYXJhbSAoSWdub3JlZF9mb3JtYXRfc3Vic3QgKHBhZF9vcHQsIHN1Yl9mbXR0eScpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZtdCcpLFxuICAgICAgICAgICAgICAgICAgIGZtdHR5JylcbiAgfCBJZ25vcmVkX3JlYWRlciAtPiAoXG4gICAgbWF0Y2ggZm10dHkgd2l0aFxuICAgIHwgSWdub3JlZF9yZWFkZXJfdHkgZm10dHlfcmVzdCAtPlxuICAgICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10IGZtdHR5X3Jlc3QgaW5cbiAgICAgIEZtdF9mbXR0eV9FQkIgKElnbm9yZWRfcGFyYW0gKElnbm9yZWRfcmVhZGVyLCBmbXQnKSwgZm10dHknKVxuICAgIHwgXyAtPiByYWlzZSBUeXBlX21pc21hdGNoXG4gIClcblxuYW5kIHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgOiB0eXBlIGExIGEyIGIxIGIyIGMxIGMyIGQxIGQyIGUxIGUyIGYxIGYyIC5cbiAgICAoYTIsIGIyLCBjMiwgZDIsIGQyLCBhMikgaWdub3JlZCAtPlxuICAgIChhMSwgYjEsIGMxLCBkMSwgZTEsIGYxKSBmbXQgLT5cbiAgICAoYTIsIGIyLCBjMiwgZDIsIGUyLCBmMikgZm10dHkgLT5cbiAgICAoYTIsIGIyLCBjMiwgZDIsIGUyLCBmMikgZm10X2ZtdHR5X2ViYlxuPSBmdW4gaWduIGZtdCBmbXR0eSAtPlxuICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXQgZm10dHkgaW5cbiAgRm10X2ZtdHR5X0VCQiAoSWdub3JlZF9wYXJhbSAoaWduLCBmbXQnKSwgZm10dHknKVxuXG4oKiBUeXBpbmcgb2YgdGhlIGNvbXBsZXggY2FzZTogXCIlXyguLi4lKVwiLiAqKVxuYW5kIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIDogdHlwZSB3IHggeSB6IHAgcyB0IHUgYSBiIGMgZCBlIGYgLlxuICAgICh3LCB4LCB5LCB6LCBzLCBwKSBmbXR0eSAtPlxuICAgIChwLCB4LCB5LCBzLCB0LCB1KSBmbXQgLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10dHkgLT4gKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5X2ZtdF9lYmIgPVxuZnVuIHN1Yl9mbXR0eSBmbXQgZm10dHkgLT4gbWF0Y2ggc3ViX2ZtdHR5LCBmbXR0eSB3aXRoXG4gIHwgQ2hhcl90eSBzdWJfZm10dHlfcmVzdCwgQ2hhcl90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChDaGFyX3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcbiAgfCBTdHJpbmdfdHkgc3ViX2ZtdHR5X3Jlc3QsIFN0cmluZ190eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChTdHJpbmdfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuICB8IEludF90eSBzdWJfZm10dHlfcmVzdCwgSW50X3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKEludF90eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG4gIHwgSW50MzJfdHkgc3ViX2ZtdHR5X3Jlc3QsIEludDMyX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKEludDMyX3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcbiAgfCBOYXRpdmVpbnRfdHkgc3ViX2ZtdHR5X3Jlc3QsIE5hdGl2ZWludF90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChOYXRpdmVpbnRfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuICB8IEludDY0X3R5IHN1Yl9mbXR0eV9yZXN0LCBJbnQ2NF90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChJbnQ2NF90eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG4gIHwgRmxvYXRfdHkgc3ViX2ZtdHR5X3Jlc3QsIEZsb2F0X3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKEZsb2F0X3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcbiAgfCBCb29sX3R5IHN1Yl9mbXR0eV9yZXN0LCBCb29sX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKEJvb2xfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuICB8IEFscGhhX3R5IHN1Yl9mbXR0eV9yZXN0LCBBbHBoYV90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChBbHBoYV90eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG4gIHwgVGhldGFfdHkgc3ViX2ZtdHR5X3Jlc3QsIFRoZXRhX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKFRoZXRhX3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcbiAgfCBSZWFkZXJfdHkgc3ViX2ZtdHR5X3Jlc3QsIFJlYWRlcl90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChSZWFkZXJfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuICB8IElnbm9yZWRfcmVhZGVyX3R5IHN1Yl9mbXR0eV9yZXN0LCBJZ25vcmVkX3JlYWRlcl90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChJZ25vcmVkX3JlYWRlcl90eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG5cbiAgfCBGb3JtYXRfYXJnX3R5IChzdWIyX2ZtdHR5LCBzdWJfZm10dHlfcmVzdCksXG4gICAgRm9ybWF0X2FyZ190eSAoc3ViMl9mbXR0eScsIGZtdHR5X3Jlc3QpIC0+XG4gICAgaWYgRm10dHlfRUJCIHN1YjJfZm10dHkgPD4gRm10dHlfRUJCIHN1YjJfZm10dHknIHRoZW4gcmFpc2UgVHlwZV9taXNtYXRjaDtcbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKEZvcm1hdF9hcmdfdHkgKHN1YjJfZm10dHknLCBzdWJfZm10dHlfcmVzdCcpLCBmbXQnKVxuICB8IEZvcm1hdF9zdWJzdF90eSAoc3ViMV9mbXR0eSwgIHN1YjJfZm10dHksICBzdWJfZm10dHlfcmVzdCksXG4gICAgRm9ybWF0X3N1YnN0X3R5IChzdWIxX2ZtdHR5Jywgc3ViMl9mbXR0eScsIGZtdHR5X3Jlc3QpIC0+XG4gICAgKCogVE9ETyBkZWZpbmUgRm10dHlfcmVsX0VCQiB0byByZW1vdmUgdGhvc2UgZXJhc2VfcmVsICopXG4gICAgaWYgRm10dHlfRUJCIChlcmFzZV9yZWwgc3ViMV9mbXR0eSkgPD4gRm10dHlfRUJCIChlcmFzZV9yZWwgc3ViMV9mbXR0eScpXG4gICAgdGhlbiByYWlzZSBUeXBlX21pc21hdGNoO1xuICAgIGlmIEZtdHR5X0VCQiAoZXJhc2VfcmVsIHN1YjJfZm10dHkpIDw+IEZtdHR5X0VCQiAoZXJhc2VfcmVsIHN1YjJfZm10dHknKVxuICAgIHRoZW4gcmFpc2UgVHlwZV9taXNtYXRjaDtcbiAgICBsZXQgc3ViX2ZtdHR5JyA9IHRyYW5zIChzeW1tIHN1YjFfZm10dHknKSBzdWIyX2ZtdHR5JyBpblxuICAgIGxldCBfLCBmMiwgXywgZjQgPSBmbXR0eV9yZWxfZGV0IHN1Yl9mbXR0eScgaW5cbiAgICBsZXQgUmVmbCA9IGYyIFJlZmwgaW5cbiAgICBsZXQgUmVmbCA9IGY0IFJlZmwgaW5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiAoZXJhc2VfcmVsIHN1Yl9mbXR0eV9yZXN0KSBmbXQgZm10dHlfcmVzdFxuICAgIGluXG4gICAgRm10dHlfZm10X0VCQiAoRm9ybWF0X3N1YnN0X3R5IChzdWIxX2ZtdHR5Jywgc3ViMl9mbXR0eScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1tIHN1Yl9mbXR0eV9yZXN0JyksXG4gICAgICAgICAgICAgICAgICAgZm10JylcbiAgfCBFbmRfb2ZfZm10dHksIGZtdHR5IC0+XG4gICAgRm10dHlfZm10X0VCQiAoRW5kX29mX2ZtdHR5LCB0eXBlX2Zvcm1hdF9nZW4gZm10IGZtdHR5KVxuICB8IF8gLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuXG4oKiBUaGlzIGltcGxlbWVudGF0aW9uIG9mIGByZWNhc3RgIGlzIGEgYml0IGRpc2FwcG9pbnRpbmcuIFRoZVxuICAgaW52YXJpYW50IHByb3ZpZGVkIGJ5IHRoZSB0eXBlIGFyZSB2ZXJ5IHN0cm9uZzogdGhlIGlucHV0IGZvcm1hdCdzXG4gICB0eXBlIGlzIGluIHJlbGF0aW9uIHRvIHRoZSBvdXRwdXQgdHlwZSdzIGFzIHdpdG5lc3NlZCBieSB0aGVcbiAgIGZtdHR5X3JlbCBhcmd1bWVudC4gT25lIHdvdWxkIGF0IGZpcnN0IGV4cGVjdCB0aGlzIGZ1bmN0aW9uIHRvIGJlXG4gICB0b3RhbCwgYW5kIGltcGxlbWVudGFibGUgYnkgZXhoYXVzdGl2ZSBwYXR0ZXJuIG1hdGNoaW5nLiBJbnN0ZWFkLFxuICAgd2UgcmV1c2UgdGhlIGhpZ2hseSBwYXJ0aWFsIGFuZCBtdWNoIGxlc3Mgd2VsbC1kZWZpbmVkIGZ1bmN0aW9uXG4gICBgdHlwZV9mb3JtYXRgIHRoYXQgaGFzIGxvc3QgYWxsIGtub3dsZWRnZSBvZiB0aGUgY29ycmVzcG9uZGVuY2VcbiAgIGJldHdlZW4gdGhlIGFyZ3VtZW50J3MgdHlwZXMuXG5cbiAgIEJlc2lkZXMgdGhlIGZhY3QgdGhhdCB0aGlzIGZ1bmN0aW9uIHJldXNlcyBhIGxvdCBvZiB0aGVcbiAgIGB0eXBlX2Zvcm1hdGAgbG9naWMgKGVnLjogc2VlaW5nIEludF90eSBpbiB0aGUgZm10dHkgcGFyYW1ldGVyIGRvZXNcbiAgIG5vdCBsZXQgeW91IG1hdGNoIG9uIEludCBvbmx5LCBhcyB5b3UgbWF5IGluIGZhY3QgaGF2ZSBGbG9hdFxuICAgKEFyZ19wYWRkaW5nLCAuLi4pIChcIiUuKmRcIikgYmVnaW5uaW5nIHdpdGggYW4gSW50X3R5KSwgaXQgaXMgYWxzb1xuICAgYSBwYXJ0aWFsIGZ1bmN0aW9uLCBiZWNhdXNlIHRoZSB0eXBpbmcgaW5mb3JtYXRpb24gaW4gYSBmb3JtYXQgaXNcbiAgIG5vdCBxdWl0ZSBlbm91Z2ggdG8gcmVjb25zdHJ1Y3QgaXQgdW5hbWJpZ3VvdXNseS4gRm9yIGV4YW1wbGUsIHRoZVxuICAgZm9ybWF0IHR5cGVzIG9mIFwiJWQlX3JcIiBhbmQgXCIlX3IlZFwiIGhhdmUgdGhlIHNhbWUgZm9ybWF0NlxuICAgcGFyYW1ldGVycywgYnV0IHRoZXkgYXJlIG5vdCBhdCBhbGwgZXhjaGFuZ2VhYmxlLCBhbmQgcHV0dGluZyBvbmVcbiAgIGluIHBsYWNlIG9mIHRoZSBvdGhlciBtdXN0IHJlc3VsdCBpbiBhIGR5bmFtaWMgZmFpbHVyZS5cblxuICAgR2l2ZW4gdGhhdDpcbiAgIC0gd2UnZCBoYXZlIHRvIGR1cGxpY2F0ZSBhIGxvdCBvZiBub24tdHJpdmlhbCB0eXBpbmcgbG9naWMgZnJvbSB0eXBlX2Zvcm1hdFxuICAgLSB0aGlzIHdvdWxkbid0IGV2ZW4gZWxpbWluYXRlIChhbGwpIHRoZSBkeW5hbWljIGZhaWx1cmVzXG4gICB3ZSBkZWNpZGVkIHRvIGp1c3QgcmV1c2UgdHlwZV9mb3JtYXQgZGlyZWN0bHkgZm9yIG5vdy5cbiopXG5sZXQgcmVjYXN0IDpcbiAgdHlwZSBhMSBiMSBjMSBkMSBlMSBmMVxuICAgICAgIGEyIGIyIGMyIGQyIGUyIGYyXG4gIC5cbiAgICAgKGExLCBiMSwgYzEsIGQxLCBlMSwgZjEpIGZtdFxuICAtPiAoYTEsIGIxLCBjMSwgZDEsIGUxLCBmMSxcbiAgICAgIGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIpIGZtdHR5X3JlbFxuICAtPiAoYTIsIGIyLCBjMiwgZDIsIGUyLCBmMikgZm10XG49IGZ1biBmbXQgZm10dHkgLT5cbiAgdHlwZV9mb3JtYXQgZm10IChlcmFzZV9yZWwgKHN5bW0gZm10dHkpKVxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBQcmludGluZyB0b29scyAqKVxuXG4oKiBBZGQgcGFkZGluZyBzcGFjZXMgYXJvdW5kIGEgc3RyaW5nLiAqKVxubGV0IGZpeF9wYWRkaW5nIHBhZHR5IHdpZHRoIHN0ciA9XG4gIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHN0ciBpblxuICBsZXQgd2lkdGgsIHBhZHR5ID1cbiAgICBhYnMgd2lkdGgsXG4gICAgKCogd2hpbGUgbGl0ZXJhbCBwYWRkaW5nIHdpZHRocyBhcmUgYWx3YXlzIG5vbi1uZWdhdGl2ZSxcbiAgICAgICBkeW5hbWljYWxseS1zZXQgd2lkdGhzIChBcmdfcGFkZGluZywgZWcuICUqZCkgbWF5IGJlIG5lZ2F0aXZlO1xuICAgICAgIHdlIGludGVycHJldCB0aG9zZSBhcyBzcGVjaWZ5aW5nIGEgcGFkZGluZy10by10aGUtbGVmdDsgdGhpc1xuICAgICAgIG1lYW5zIHRoYXQgJzAnIG1heSBnZXQgZHJvcHBlZCBldmVuIGlmIGl0IHdhcyBleHBsaWNpdGx5IHNldCxcbiAgICAgICBidXQ6XG4gICAgICAgLSB0aGlzIGlzIHdoYXQgdGhlIGxlZ2FjeSBpbXBsZW1lbnRhdGlvbiBkb2VzLCBhbmRcbiAgICAgICAgIHdlIHByZXNlcnZlIGNvbXBhdGliaWxpdHkgaWYgcG9zc2libGVcbiAgICAgICAtIHdlIGNvdWxkIG9ubHkgc2lnbmFsIHRoaXMgaXNzdWUgYnkgZmFpbGluZyBhdCBydW50aW1lLFxuICAgICAgICAgd2hpY2ggaXMgbm90IHZlcnkgbmljZS4uLiAqKVxuICAgIGlmIHdpZHRoIDwgMCB0aGVuIExlZnQgZWxzZSBwYWR0eSBpblxuICBpZiB3aWR0aCA8PSBsZW4gdGhlbiBzdHIgZWxzZVxuICAgIGxldCByZXMgPSBCeXRlcy5tYWtlIHdpZHRoIChpZiBwYWR0eSA9IFplcm9zIHRoZW4gJzAnIGVsc2UgJyAnKSBpblxuICAgIGJlZ2luIG1hdGNoIHBhZHR5IHdpdGhcbiAgICB8IExlZnQgIC0+IFN0cmluZy5ibGl0IHN0ciAwIHJlcyAwIGxlblxuICAgIHwgUmlnaHQgLT4gU3RyaW5nLmJsaXQgc3RyIDAgcmVzICh3aWR0aCAtIGxlbikgbGVuXG4gICAgfCBaZXJvcyB3aGVuIGxlbiA+IDAgJiYgKHN0ci5bMF0gPSAnKycgfHwgc3RyLlswXSA9ICctJyB8fCBzdHIuWzBdID0gJyAnKSAtPlxuICAgICAgQnl0ZXMuc2V0IHJlcyAwIHN0ci5bMF07XG4gICAgICBTdHJpbmcuYmxpdCBzdHIgMSByZXMgKHdpZHRoIC0gbGVuICsgMSkgKGxlbiAtIDEpXG4gICAgfCBaZXJvcyB3aGVuIGxlbiA+IDEgJiYgc3RyLlswXSA9ICcwJyAmJiAoc3RyLlsxXSA9ICd4JyB8fCBzdHIuWzFdID0gJ1gnKSAtPlxuICAgICAgQnl0ZXMuc2V0IHJlcyAxIHN0ci5bMV07XG4gICAgICBTdHJpbmcuYmxpdCBzdHIgMiByZXMgKHdpZHRoIC0gbGVuICsgMikgKGxlbiAtIDIpXG4gICAgfCBaZXJvcyAtPlxuICAgICAgU3RyaW5nLmJsaXQgc3RyIDAgcmVzICh3aWR0aCAtIGxlbikgbGVuXG4gICAgZW5kO1xuICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcmVzXG5cbigqIEFkZCAnMCcgcGFkZGluZyB0byBpbnQsIGludDMyLCBuYXRpdmVpbnQgb3IgaW50NjQgc3RyaW5nIHJlcHJlc2VudGF0aW9uLiAqKVxubGV0IGZpeF9pbnRfcHJlY2lzaW9uIHByZWMgc3RyID1cbiAgbGV0IHByZWMgPSBhYnMgcHJlYyBpblxuICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzdHIgaW5cbiAgbWF0Y2ggc3RyLlswXSB3aXRoXG4gIHwgKCcrJyB8ICctJyB8ICcgJykgYXMgYyB3aGVuIHByZWMgKyAxID4gbGVuIC0+XG4gICAgbGV0IHJlcyA9IEJ5dGVzLm1ha2UgKHByZWMgKyAxKSAnMCcgaW5cbiAgICBCeXRlcy5zZXQgcmVzIDAgYztcbiAgICBTdHJpbmcuYmxpdCBzdHIgMSByZXMgKHByZWMgLSBsZW4gKyAyKSAobGVuIC0gMSk7XG4gICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyByZXNcbiAgfCAnMCcgd2hlbiBwcmVjICsgMiA+IGxlbiAmJiBsZW4gPiAxICYmIChzdHIuWzFdID0gJ3gnIHx8IHN0ci5bMV0gPSAnWCcpIC0+XG4gICAgbGV0IHJlcyA9IEJ5dGVzLm1ha2UgKHByZWMgKyAyKSAnMCcgaW5cbiAgICBCeXRlcy5zZXQgcmVzIDEgc3RyLlsxXTtcbiAgICBTdHJpbmcuYmxpdCBzdHIgMiByZXMgKHByZWMgLSBsZW4gKyA0KSAobGVuIC0gMik7XG4gICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyByZXNcbiAgfCAnMCcgLi4gJzknIHwgJ2EnIC4uICdmJyB8ICdBJyAuLiAnRicgd2hlbiBwcmVjID4gbGVuIC0+XG4gICAgbGV0IHJlcyA9IEJ5dGVzLm1ha2UgcHJlYyAnMCcgaW5cbiAgICBTdHJpbmcuYmxpdCBzdHIgMCByZXMgKHByZWMgLSBsZW4pIGxlbjtcbiAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHJlc1xuICB8IF8gLT5cbiAgICBzdHJcblxuKCogRXNjYXBlIGEgc3RyaW5nIGFjY29yZGluZyB0byB0aGUgT0NhbWwgbGV4aW5nIGNvbnZlbnRpb24uICopXG5sZXQgc3RyaW5nX3RvX2NhbWxfc3RyaW5nIHN0ciA9XG4gIGxldCBzdHIgPSBTdHJpbmcuZXNjYXBlZCBzdHIgaW5cbiAgbGV0IGwgPSBTdHJpbmcubGVuZ3RoIHN0ciBpblxuICBsZXQgcmVzID0gQnl0ZXMubWFrZSAobCArIDIpICdcXFwiJyBpblxuICBTdHJpbmcudW5zYWZlX2JsaXQgc3RyIDAgcmVzIDEgbDtcbiAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyByZXNcblxuKCogR2VuZXJhdGUgdGhlIGZvcm1hdF9pbnQvaW50MzIvbmF0aXZlaW50L2ludDY0IGZpcnN0IGFyZ3VtZW50XG4gICBmcm9tIGFuIGludF9jb252LiAqKVxubGV0IGZvcm1hdF9vZl9pY29udiA9IGZ1bmN0aW9uXG4gIHwgSW50X2QgfCBJbnRfQ2QgLT4gXCIlZFwiIHwgSW50X3BkIC0+IFwiJStkXCIgfCBJbnRfc2QgLT4gXCIlIGRcIlxuICB8IEludF9pIHwgSW50X0NpIC0+IFwiJWlcIiB8IEludF9waSAtPiBcIiUraVwiIHwgSW50X3NpIC0+IFwiJSBpXCJcbiAgfCBJbnRfeCAtPiBcIiV4XCIgfCBJbnRfQ3ggLT4gXCIlI3hcIlxuICB8IEludF9YIC0+IFwiJVhcIiB8IEludF9DWCAtPiBcIiUjWFwiXG4gIHwgSW50X28gLT4gXCIlb1wiIHwgSW50X0NvIC0+IFwiJSNvXCJcbiAgfCBJbnRfdSB8IEludF9DdSAtPiBcIiV1XCJcblxubGV0IGZvcm1hdF9vZl9pY29udkwgPSBmdW5jdGlvblxuICB8IEludF9kIHwgSW50X0NkIC0+IFwiJUxkXCIgfCBJbnRfcGQgLT4gXCIlK0xkXCIgfCBJbnRfc2QgLT4gXCIlIExkXCJcbiAgfCBJbnRfaSB8IEludF9DaSAtPiBcIiVMaVwiIHwgSW50X3BpIC0+IFwiJStMaVwiIHwgSW50X3NpIC0+IFwiJSBMaVwiXG4gIHwgSW50X3ggLT4gXCIlTHhcIiB8IEludF9DeCAtPiBcIiUjTHhcIlxuICB8IEludF9YIC0+IFwiJUxYXCIgfCBJbnRfQ1ggLT4gXCIlI0xYXCJcbiAgfCBJbnRfbyAtPiBcIiVMb1wiIHwgSW50X0NvIC0+IFwiJSNMb1wiXG4gIHwgSW50X3UgfCBJbnRfQ3UgLT4gXCIlTHVcIlxuXG5sZXQgZm9ybWF0X29mX2ljb252bCA9IGZ1bmN0aW9uXG4gIHwgSW50X2QgfCBJbnRfQ2QgLT4gXCIlbGRcIiB8IEludF9wZCAtPiBcIiUrbGRcIiB8IEludF9zZCAtPiBcIiUgbGRcIlxuICB8IEludF9pIHwgSW50X0NpIC0+IFwiJWxpXCIgfCBJbnRfcGkgLT4gXCIlK2xpXCIgfCBJbnRfc2kgLT4gXCIlIGxpXCJcbiAgfCBJbnRfeCAtPiBcIiVseFwiIHwgSW50X0N4IC0+IFwiJSNseFwiXG4gIHwgSW50X1ggLT4gXCIlbFhcIiB8IEludF9DWCAtPiBcIiUjbFhcIlxuICB8IEludF9vIC0+IFwiJWxvXCIgfCBJbnRfQ28gLT4gXCIlI2xvXCJcbiAgfCBJbnRfdSB8IEludF9DdSAtPiBcIiVsdVwiXG5cbmxldCBmb3JtYXRfb2ZfaWNvbnZuID0gZnVuY3Rpb25cbiAgfCBJbnRfZCB8IEludF9DZCAtPiBcIiVuZFwiIHwgSW50X3BkIC0+IFwiJStuZFwiIHwgSW50X3NkIC0+IFwiJSBuZFwiXG4gIHwgSW50X2kgfCBJbnRfQ2kgLT4gXCIlbmlcIiB8IEludF9waSAtPiBcIiUrbmlcIiB8IEludF9zaSAtPiBcIiUgbmlcIlxuICB8IEludF94IC0+IFwiJW54XCIgfCBJbnRfQ3ggLT4gXCIlI254XCJcbiAgfCBJbnRfWCAtPiBcIiVuWFwiIHwgSW50X0NYIC0+IFwiJSNuWFwiXG4gIHwgSW50X28gLT4gXCIlbm9cIiB8IEludF9DbyAtPiBcIiUjbm9cIlxuICB8IEludF91IHwgSW50X0N1IC0+IFwiJW51XCJcblxuKCogR2VuZXJhdGUgdGhlIGZvcm1hdF9mbG9hdCBmaXJzdCBhcmd1bWVudCBmcm9tIGEgZmxvYXRfY29udi4gKilcbmxldCBmb3JtYXRfb2ZfZmNvbnYgZmNvbnYgcHJlYyA9XG4gICAgbGV0IHByZWMgPSBhYnMgcHJlYyBpblxuICAgIGxldCBzeW1iID0gY2hhcl9vZl9mY29udiB+Y0Y6J2cnIGZjb252IGluXG4gICAgbGV0IGJ1ZiA9IGJ1ZmZlcl9jcmVhdGUgMTYgaW5cbiAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJztcbiAgICBicHJpbnRfZmNvbnZfZmxhZyBidWYgZmNvbnY7XG4gICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnLic7XG4gICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIChJbnQudG9fc3RyaW5nIHByZWMpO1xuICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgc3ltYjtcbiAgICBidWZmZXJfY29udGVudHMgYnVmXG5cbmxldCB0cmFuc2Zvcm1faW50X2FsdCBpY29udiBzID1cbiAgbWF0Y2ggaWNvbnYgd2l0aFxuICB8IEludF9DZCB8IEludF9DaSB8IEludF9DdSAtPlxuICAgIGxldCBkaWdpdHMgPVxuICAgICAgbGV0IG4gPSByZWYgMCBpblxuICAgICAgZm9yIGkgPSAwIHRvIFN0cmluZy5sZW5ndGggcyAtIDEgZG9cbiAgICAgICAgbWF0Y2ggU3RyaW5nLnVuc2FmZV9nZXQgcyBpIHdpdGhcbiAgICAgICAgfCAnMCcuLic5JyAtPiBpbmNyIG5cbiAgICAgICAgfCBfIC0+ICgpXG4gICAgICBkb25lO1xuICAgICAgIW5cbiAgICBpblxuICAgIGxldCBidWYgPSBCeXRlcy5jcmVhdGUgKFN0cmluZy5sZW5ndGggcyArIChkaWdpdHMgLSAxKSAvIDMpIGluXG4gICAgbGV0IHBvcyA9IHJlZiAwIGluXG4gICAgbGV0IHB1dCBjID0gQnl0ZXMuc2V0IGJ1ZiAhcG9zIGM7IGluY3IgcG9zIGluXG4gICAgbGV0IGxlZnQgPSByZWYgKChkaWdpdHMgLSAxKSBtb2QgMyArIDEpIGluXG4gICAgZm9yIGkgPSAwIHRvIFN0cmluZy5sZW5ndGggcyAtIDEgZG9cbiAgICAgIG1hdGNoIFN0cmluZy51bnNhZmVfZ2V0IHMgaSB3aXRoXG4gICAgICB8ICcwJy4uJzknIGFzIGMgLT5cbiAgICAgICAgICBpZiAhbGVmdCA9IDAgdGhlbiAocHV0ICdfJzsgbGVmdCA6PSAzKTsgZGVjciBsZWZ0OyBwdXQgY1xuICAgICAgfCBjIC0+IHB1dCBjXG4gICAgZG9uZTtcbiAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIGJ1ZlxuICB8IF8gLT4gc1xuXG4oKiBDb252ZXJ0IGFuIGludGVnZXIgdG8gYSBzdHJpbmcgYWNjb3JkaW5nIHRvIGEgY29udmVyc2lvbi4gKilcbmxldCBjb252ZXJ0X2ludCBpY29udiBuID1cbiAgdHJhbnNmb3JtX2ludF9hbHQgaWNvbnYgKGZvcm1hdF9pbnQgKGZvcm1hdF9vZl9pY29udiBpY29udikgbilcbmxldCBjb252ZXJ0X2ludDMyIGljb252IG4gPVxuICB0cmFuc2Zvcm1faW50X2FsdCBpY29udiAoZm9ybWF0X2ludDMyIChmb3JtYXRfb2ZfaWNvbnZsIGljb252KSBuKVxubGV0IGNvbnZlcnRfbmF0aXZlaW50IGljb252IG4gPVxuICB0cmFuc2Zvcm1faW50X2FsdCBpY29udiAoZm9ybWF0X25hdGl2ZWludCAoZm9ybWF0X29mX2ljb252biBpY29udikgbilcbmxldCBjb252ZXJ0X2ludDY0IGljb252IG4gPVxuICB0cmFuc2Zvcm1faW50X2FsdCBpY29udiAoZm9ybWF0X2ludDY0IChmb3JtYXRfb2ZfaWNvbnZMIGljb252KSBuKVxuXG4oKiBDb252ZXJ0IGEgZmxvYXQgdG8gc3RyaW5nLiAqKVxuKCogRml4IHNwZWNpYWwgY2FzZSBvZiBcIk9DYW1sIGZsb2F0IGZvcm1hdFwiLiAqKVxubGV0IGNvbnZlcnRfZmxvYXQgZmNvbnYgcHJlYyB4ID1cbiAgbGV0IGhleCAoKSA9XG4gICAgbGV0IHNpZ24gPVxuICAgICAgbWF0Y2ggZnN0IGZjb252IHdpdGhcbiAgICAgIHwgRmxvYXRfZmxhZ19wIC0+ICcrJ1xuICAgICAgfCBGbG9hdF9mbGFnX3MgLT4gJyAnXG4gICAgICB8IF8gLT4gJy0nIGluXG4gICAgaGV4c3RyaW5nX29mX2Zsb2F0IHggcHJlYyBzaWduIGluXG4gIGxldCBhZGRfZG90X2lmX25lZWRlZCBzdHIgPVxuICAgIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHN0ciBpblxuICAgIGxldCByZWMgaXNfdmFsaWQgaSA9XG4gICAgICBpZiBpID0gbGVuIHRoZW4gZmFsc2UgZWxzZVxuICAgICAgICBtYXRjaCBzdHIuW2ldIHdpdGhcbiAgICAgICAgfCAnLicgfCAnZScgfCAnRScgLT4gdHJ1ZVxuICAgICAgICB8IF8gLT4gaXNfdmFsaWQgKGkgKyAxKSBpblxuICAgIGlmIGlzX3ZhbGlkIDAgdGhlbiBzdHIgZWxzZSBzdHIgXiBcIi5cIiBpblxuICBsZXQgY2FtbF9zcGVjaWFsX3ZhbCBzdHIgPSBtYXRjaCBjbGFzc2lmeV9mbG9hdCB4IHdpdGhcbiAgICB8IEZQX25vcm1hbCB8IEZQX3N1Ym5vcm1hbCB8IEZQX3plcm8gLT4gc3RyXG4gICAgfCBGUF9pbmZpbml0ZSAtPiBpZiB4IDwgMC4wIHRoZW4gXCJuZWdfaW5maW5pdHlcIiBlbHNlIFwiaW5maW5pdHlcIlxuICAgIHwgRlBfbmFuIC0+IFwibmFuXCIgaW5cbiAgbWF0Y2ggc25kIGZjb252IHdpdGhcbiAgfCBGbG9hdF9oIC0+IGhleCAoKVxuICB8IEZsb2F0X0ggLT4gU3RyaW5nLnVwcGVyY2FzZV9hc2NpaSAoaGV4ICgpKVxuICB8IEZsb2F0X0NGIC0+IGNhbWxfc3BlY2lhbF92YWwgKGhleCAoKSlcbiAgfCBGbG9hdF9GIC0+XG4gICAgbGV0IHN0ciA9IGZvcm1hdF9mbG9hdCAoZm9ybWF0X29mX2Zjb252IGZjb252IHByZWMpIHggaW5cbiAgICBjYW1sX3NwZWNpYWxfdmFsIChhZGRfZG90X2lmX25lZWRlZCBzdHIpXG4gIHwgRmxvYXRfZiB8IEZsb2F0X2UgfCBGbG9hdF9FIHwgRmxvYXRfZyB8IEZsb2F0X0cgLT5cbiAgICBmb3JtYXRfZmxvYXQgKGZvcm1hdF9vZl9mY29udiBmY29udiBwcmVjKSB4XG5cbigqIENvbnZlcnQgYSBjaGFyIHRvIGEgc3RyaW5nIGFjY29yZGluZyB0byB0aGUgT0NhbWwgbGV4aWNhbCBjb252ZW50aW9uLiAqKVxubGV0IGZvcm1hdF9jYW1sX2NoYXIgYyA9XG4gIGxldCBzdHIgPSBDaGFyLmVzY2FwZWQgYyBpblxuICBsZXQgbCA9IFN0cmluZy5sZW5ndGggc3RyIGluXG4gIGxldCByZXMgPSBCeXRlcy5tYWtlIChsICsgMikgJ1xcJycgaW5cbiAgU3RyaW5nLnVuc2FmZV9ibGl0IHN0ciAwIHJlcyAxIGw7XG4gIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcmVzXG5cbigqIENvbnZlcnQgYSBmb3JtYXQgdHlwZSB0byBzdHJpbmcgKilcbmxldCBzdHJpbmdfb2ZfZm10dHkgZm10dHkgPVxuICBsZXQgYnVmID0gYnVmZmVyX2NyZWF0ZSAxNiBpblxuICBicHJpbnRfZm10dHkgYnVmIGZtdHR5O1xuICBidWZmZXJfY29udGVudHMgYnVmXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAoKiBHZW5lcmljIHByaW50aW5nIGZ1bmN0aW9uICopXG5cbigqIE1ha2UgYSBnZW5lcmljIHByaW50aW5nIGZ1bmN0aW9uLiAqKVxuKCogVXNlZCB0byBnZW5lcmF0ZSBQcmludGYgYW5kIEZvcm1hdCBwcmludGluZyBmdW5jdGlvbnMuICopXG4oKiBQYXJhbWV0ZXJzOlxuICAgICBrOiBhIGNvbnRpbnVhdGlvbiBmaW5hbGx5IGFwcGxpZWQgdG8gdGhlIG91dHB1dCBzdHJlYW0gYW5kIHRoZSBhY2N1bXVsYXRvci5cbiAgICAgbzogdGhlIG91dHB1dCBzdHJlYW0gKHNlZSBrLCAlYSBhbmQgJXQpLlxuICAgICBhY2M6IHJldiBsaXN0IG9mIHByaW50aW5nIGVudGl0aWVzIChzdHJpbmcsIGNoYXIsIGZsdXNoLCBmb3JtYXR0aW5nLCAuLi4pLlxuICAgICBmbXQ6IHRoZSBmb3JtYXQuICopXG5sZXQgcmVjIG1ha2VfcHJpbnRmIDogdHlwZSBhIGIgYyBkIGUgZiAuXG4gICAgKChiLCBjKSBhY2MgLT4gZikgLT4gKGIsIGMpIGFjYyAtPlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT4gYSA9XG5mdW4gayBhY2MgZm10IC0+IG1hdGNoIGZtdCB3aXRoXG4gIHwgQ2hhciByZXN0IC0+XG4gICAgZnVuIGMgLT5cbiAgICAgIGxldCBuZXdfYWNjID0gQWNjX2RhdGFfY2hhciAoYWNjLCBjKSBpblxuICAgICAgbWFrZV9wcmludGYgayBuZXdfYWNjIHJlc3RcbiAgfCBDYW1sX2NoYXIgcmVzdCAtPlxuICAgIGZ1biBjIC0+XG4gICAgICBsZXQgbmV3X2FjYyA9IEFjY19kYXRhX3N0cmluZyAoYWNjLCBmb3JtYXRfY2FtbF9jaGFyIGMpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG5ld19hY2MgcmVzdFxuICB8IFN0cmluZyAocGFkLCByZXN0KSAtPlxuICAgIG1ha2VfcGFkZGluZyBrIGFjYyByZXN0IHBhZCAoZnVuIHN0ciAtPiBzdHIpXG4gIHwgQ2FtbF9zdHJpbmcgKHBhZCwgcmVzdCkgLT5cbiAgICBtYWtlX3BhZGRpbmcgayBhY2MgcmVzdCBwYWQgc3RyaW5nX3RvX2NhbWxfc3RyaW5nXG4gIHwgSW50IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIG1ha2VfaW50X3BhZGRpbmdfcHJlY2lzaW9uIGsgYWNjIHJlc3QgcGFkIHByZWMgY29udmVydF9pbnQgaWNvbnZcbiAgfCBJbnQzMiAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBtYWtlX2ludF9wYWRkaW5nX3ByZWNpc2lvbiBrIGFjYyByZXN0IHBhZCBwcmVjIGNvbnZlcnRfaW50MzIgaWNvbnZcbiAgfCBOYXRpdmVpbnQgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbWFrZV9pbnRfcGFkZGluZ19wcmVjaXNpb24gayBhY2MgcmVzdCBwYWQgcHJlYyBjb252ZXJ0X25hdGl2ZWludCBpY29udlxuICB8IEludDY0IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIG1ha2VfaW50X3BhZGRpbmdfcHJlY2lzaW9uIGsgYWNjIHJlc3QgcGFkIHByZWMgY29udmVydF9pbnQ2NCBpY29udlxuICB8IEZsb2F0IChmY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIG1ha2VfZmxvYXRfcGFkZGluZ19wcmVjaXNpb24gayBhY2MgcmVzdCBwYWQgcHJlYyBmY29udlxuICB8IEJvb2wgKHBhZCwgcmVzdCkgLT5cbiAgICBtYWtlX3BhZGRpbmcgayBhY2MgcmVzdCBwYWQgc3RyaW5nX29mX2Jvb2xcbiAgfCBBbHBoYSByZXN0IC0+XG4gICAgZnVuIGYgeCAtPiBtYWtlX3ByaW50ZiBrIChBY2NfZGVsYXkgKGFjYywgZnVuIG8gLT4gZiBvIHgpKSByZXN0XG4gIHwgVGhldGEgcmVzdCAtPlxuICAgIGZ1biBmIC0+IG1ha2VfcHJpbnRmIGsgKEFjY19kZWxheSAoYWNjLCBmKSkgcmVzdFxuICB8IEN1c3RvbSAoYXJpdHksIGYsIHJlc3QpIC0+XG4gICAgbWFrZV9jdXN0b20gayBhY2MgcmVzdCBhcml0eSAoZiAoKSlcbiAgfCBSZWFkZXIgXyAtPlxuICAgICgqIFRoaXMgY2FzZSBpcyBpbXBvc3NpYmxlLCBieSB0eXBpbmcgb2YgZm9ybWF0cy4gKilcbiAgICAoKiBJbmRlZWQsIHNpbmNlIHByaW50ZiBhbmQgY28uIHRha2UgYSBmb3JtYXQ0IGFzIGFyZ3VtZW50LCB0aGUgJ2QgYW5kICdlXG4gICAgICAgdHlwZSBwYXJhbWV0ZXJzIG9mIGZtdCBhcmUgb2J2aW91c2x5IGVxdWFscy4gVGhlIFJlYWRlciBpcyB0aGVcbiAgICAgICBvbmx5IGNvbnN0cnVjdG9yIHdoaWNoIHRvdWNoICdkIGFuZCAnZSB0eXBlIHBhcmFtZXRlcnMgb2YgdGhlIGZvcm1hdFxuICAgICAgIHR5cGUsIGl0IGFkZHMgYW4gKC0+KSB0byB0aGUgJ2QgcGFyYW1ldGVycy4gQ29uc2VxdWVudGx5LCBhIGZvcm1hdDRcbiAgICAgICBjYW5ub3QgY29udGFpbiBhIFJlYWRlciBub2RlLCBleGNlcHQgaW4gdGhlIHN1Yi1mb3JtYXQgYXNzb2NpYXRlZCB0b1xuICAgICAgIGFuICV7Li4uJX0uIEl0J3Mgbm90IGEgcHJvYmxlbSBiZWNhdXNlIG1ha2VfcHJpbnRmIGRvIG5vdCBjYWxsXG4gICAgICAgaXRzZWxmIHJlY3Vyc2l2ZWx5IG9uIHRoZSBzdWItZm9ybWF0IGFzc29jaWF0ZWQgdG8gJXsuLi4lfS4gKilcbiAgICBhc3NlcnQgZmFsc2VcbiAgfCBGbHVzaCByZXN0IC0+XG4gICAgbWFrZV9wcmludGYgayAoQWNjX2ZsdXNoIGFjYykgcmVzdFxuXG4gIHwgU3RyaW5nX2xpdGVyYWwgKHN0ciwgcmVzdCkgLT5cbiAgICBtYWtlX3ByaW50ZiBrIChBY2Nfc3RyaW5nX2xpdGVyYWwgKGFjYywgc3RyKSkgcmVzdFxuICB8IENoYXJfbGl0ZXJhbCAoY2hyLCByZXN0KSAtPlxuICAgIG1ha2VfcHJpbnRmIGsgKEFjY19jaGFyX2xpdGVyYWwgKGFjYywgY2hyKSkgcmVzdFxuXG4gIHwgRm9ybWF0X2FyZyAoXywgc3ViX2ZtdHR5LCByZXN0KSAtPlxuICAgIGxldCB0eSA9IHN0cmluZ19vZl9mbXR0eSBzdWJfZm10dHkgaW5cbiAgICAoZnVuIHN0ciAtPlxuICAgICAgaWdub3JlIHN0cjtcbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCB0eSkpIHJlc3QpXG4gIHwgRm9ybWF0X3N1YnN0IChfLCBmbXR0eSwgcmVzdCkgLT5cbiAgICBmdW4gKEZvcm1hdCAoZm10LCBfKSkgLT4gbWFrZV9wcmludGYgayBhY2NcbiAgICAgIChjb25jYXRfZm10IChyZWNhc3QgZm10IGZtdHR5KSByZXN0KVxuXG4gIHwgU2Nhbl9jaGFyX3NldCAoXywgXywgcmVzdCkgLT5cbiAgICBsZXQgbmV3X2FjYyA9IEFjY19pbnZhbGlkX2FyZyAoYWNjLCBcIlByaW50ZjogYmFkIGNvbnZlcnNpb24gJVtcIikgaW5cbiAgICBmdW4gXyAtPiBtYWtlX3ByaW50ZiBrIG5ld19hY2MgcmVzdFxuICB8IFNjYW5fZ2V0X2NvdW50ZXIgKF8sIHJlc3QpIC0+XG4gICAgKCogVGhpcyBjYXNlIHNob3VsZCBiZSByZWZ1c2VkIGZvciBQcmludGYuICopXG4gICAgKCogQWNjZXB0ZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkuICopXG4gICAgKCogSW50ZXJwcmV0ICVsLCAlbiBhbmQgJUwgYXMgJXUuICopXG4gICAgZnVuIG4gLT5cbiAgICAgIGxldCBuZXdfYWNjID0gQWNjX2RhdGFfc3RyaW5nIChhY2MsIGZvcm1hdF9pbnQgXCIldVwiIG4pIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG5ld19hY2MgcmVzdFxuICB8IFNjYW5fbmV4dF9jaGFyIHJlc3QgLT5cbiAgICBmdW4gYyAtPlxuICAgICAgbGV0IG5ld19hY2MgPSBBY2NfZGF0YV9jaGFyIChhY2MsIGMpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG5ld19hY2MgcmVzdFxuICB8IElnbm9yZWRfcGFyYW0gKGlnbiwgcmVzdCkgLT5cbiAgICBtYWtlX2lnbm9yZWRfcGFyYW0gayBhY2MgaWduIHJlc3RcblxuICB8IEZvcm1hdHRpbmdfbGl0IChmbXRpbmdfbGl0LCByZXN0KSAtPlxuICAgIG1ha2VfcHJpbnRmIGsgKEFjY19mb3JtYXR0aW5nX2xpdCAoYWNjLCBmbXRpbmdfbGl0KSkgcmVzdFxuICB8IEZvcm1hdHRpbmdfZ2VuIChPcGVuX3RhZyAoRm9ybWF0IChmbXQnLCBfKSksIHJlc3QpIC0+XG4gICAgbGV0IGsnIGthY2MgPVxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2Zvcm1hdHRpbmdfZ2VuIChhY2MsIEFjY19vcGVuX3RhZyBrYWNjKSkgcmVzdCBpblxuICAgIG1ha2VfcHJpbnRmIGsnIEVuZF9vZl9hY2MgZm10J1xuICB8IEZvcm1hdHRpbmdfZ2VuIChPcGVuX2JveCAoRm9ybWF0IChmbXQnLCBfKSksIHJlc3QpIC0+XG4gICAgbGV0IGsnIGthY2MgPVxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2Zvcm1hdHRpbmdfZ2VuIChhY2MsIEFjY19vcGVuX2JveCBrYWNjKSkgcmVzdCBpblxuICAgIG1ha2VfcHJpbnRmIGsnIEVuZF9vZl9hY2MgZm10J1xuXG4gIHwgRW5kX29mX2Zvcm1hdCAtPlxuICAgIGsgYWNjXG5cbigqIERlbGF5IHRoZSBlcnJvciAoSW52YWxpZF9hcmd1bWVudCBcIlByaW50ZjogYmFkIGNvbnZlcnNpb24gJV9cIikuICopXG4oKiBHZW5lcmF0ZSBmdW5jdGlvbnMgdG8gdGFrZSByZW1haW5pbmcgYXJndW1lbnRzIChhZnRlciB0aGUgXCIlX1wiKS4gKilcbmFuZCBtYWtlX2lnbm9yZWRfcGFyYW0gOiB0eXBlIHggeSBhIGIgYyBkIGUgZiAuXG4gICAgKChiLCBjKSBhY2MgLT4gZikgLT4gKGIsIGMpIGFjYyAtPlxuICAgIChhLCBiLCBjLCBkLCB5LCB4KSBpZ25vcmVkIC0+XG4gICAgKHgsIGIsIGMsIHksIGUsIGYpIGZtdCAtPiBhID1cbmZ1biBrIGFjYyBpZ24gZm10IC0+IG1hdGNoIGlnbiB3aXRoXG4gIHwgSWdub3JlZF9jaGFyICAgICAgICAgICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuICB8IElnbm9yZWRfY2FtbF9jaGFyICAgICAgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcbiAgfCBJZ25vcmVkX3N0cmluZyBfICAgICAgICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG4gIHwgSWdub3JlZF9jYW1sX3N0cmluZyBfICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuICB8IElnbm9yZWRfaW50IChfLCBfKSAgICAgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcbiAgfCBJZ25vcmVkX2ludDMyIChfLCBfKSAgICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG4gIHwgSWdub3JlZF9uYXRpdmVpbnQgKF8sIF8pICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuICB8IElnbm9yZWRfaW50NjQgKF8sIF8pICAgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcbiAgfCBJZ25vcmVkX2Zsb2F0IChfLCBfKSAgICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG4gIHwgSWdub3JlZF9ib29sIF8gICAgICAgICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuICB8IElnbm9yZWRfZm9ybWF0X2FyZyBfICAgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcbiAgfCBJZ25vcmVkX2Zvcm1hdF9zdWJzdCAoXywgZm10dHkpIC0+IG1ha2VfZnJvbV9mbXR0eSBrIGFjYyBmbXR0eSBmbXRcbiAgfCBJZ25vcmVkX3JlYWRlciAgICAgICAgICAgICAgICAgIC0+IGFzc2VydCBmYWxzZVxuICB8IElnbm9yZWRfc2Nhbl9jaGFyX3NldCBfICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcbiAgfCBJZ25vcmVkX3NjYW5fZ2V0X2NvdW50ZXIgXyAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG4gIHwgSWdub3JlZF9zY2FuX25leHRfY2hhciAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuXG5cbigqIFNwZWNpYWwgY2FzZSBvZiBwcmludGYgXCIlXyhcIi4gKilcbmFuZCBtYWtlX2Zyb21fZm10dHkgOiB0eXBlIHggeSBhIGIgYyBkIGUgZiAuXG4gICAgKChiLCBjKSBhY2MgLT4gZikgLT4gKGIsIGMpIGFjYyAtPlxuICAgIChhLCBiLCBjLCBkLCB5LCB4KSBmbXR0eSAtPlxuICAgICh4LCBiLCBjLCB5LCBlLCBmKSBmbXQgLT4gYSA9XG5mdW4gayBhY2MgZm10dHkgZm10IC0+IG1hdGNoIGZtdHR5IHdpdGhcbiAgfCBDaGFyX3R5IHJlc3QgICAgICAgICAgICAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgcmVzdCBmbXRcbiAgfCBTdHJpbmdfdHkgcmVzdCAgICAgICAgICAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgcmVzdCBmbXRcbiAgfCBJbnRfdHkgcmVzdCAgICAgICAgICAgICAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgcmVzdCBmbXRcbiAgfCBJbnQzMl90eSByZXN0ICAgICAgICAgICAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgcmVzdCBmbXRcbiAgfCBOYXRpdmVpbnRfdHkgcmVzdCAgICAgICAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgcmVzdCBmbXRcbiAgfCBJbnQ2NF90eSByZXN0ICAgICAgICAgICAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgcmVzdCBmbXRcbiAgfCBGbG9hdF90eSByZXN0ICAgICAgICAgICAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgcmVzdCBmbXRcbiAgfCBCb29sX3R5IHJlc3QgICAgICAgICAgICAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgcmVzdCBmbXRcbiAgfCBBbHBoYV90eSByZXN0ICAgICAgICAgICAtPiBmdW4gXyBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIGFjYyByZXN0IGZtdFxuICB8IFRoZXRhX3R5IHJlc3QgICAgICAgICAgIC0+IGZ1biBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIGFjYyByZXN0IGZtdFxuICB8IEFueV90eSByZXN0ICAgICAgICAgICAgIC0+IGZ1biBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIGFjYyByZXN0IGZtdFxuICB8IFJlYWRlcl90eSBfICAgICAgICAgICAgIC0+IGFzc2VydCBmYWxzZVxuICB8IElnbm9yZWRfcmVhZGVyX3R5IF8gICAgIC0+IGFzc2VydCBmYWxzZVxuICB8IEZvcm1hdF9hcmdfdHkgKF8sIHJlc3QpIC0+IGZ1biBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIGFjYyByZXN0IGZtdFxuICB8IEVuZF9vZl9mbXR0eSAgICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG4gIHwgRm9ybWF0X3N1YnN0X3R5ICh0eTEsIHR5MiwgcmVzdCkgLT5cbiAgICBsZXQgdHkgPSB0cmFucyAoc3ltbSB0eTEpIHR5MiBpblxuICAgIGZ1biBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIGFjYyAoY29uY2F0X2ZtdHR5IHR5IHJlc3QpIGZtdFxuXG4oKiBJbnNlcnQgYW4gQWNjX2ludmFsaWRfYXJnIGluIHRoZSBhY2N1bXVsYXRvciBhbmQgY29udGludWUgdG8gZ2VuZXJhdGVcbiAgIGNsb3N1cmVzIHRvIGdldCB0aGUgcmVtYWluaW5nIGFyZ3VtZW50cy4gKilcbmFuZCBtYWtlX2ludmFsaWRfYXJnIDogdHlwZSBhIGIgYyBkIGUgZiAuXG4gICAgKChiLCBjKSBhY2MgLT4gZikgLT4gKGIsIGMpIGFjYyAtPlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT4gYSA9XG5mdW4gayBhY2MgZm10IC0+XG4gIG1ha2VfcHJpbnRmIGsgKEFjY19pbnZhbGlkX2FyZyAoYWNjLCBcIlByaW50ZjogYmFkIGNvbnZlcnNpb24gJV9cIikpIGZtdFxuXG4oKiBGaXggcGFkZGluZywgdGFrZSBpdCBhcyBhbiBleHRyYSBpbnRlZ2VyIGFyZ3VtZW50IGlmIG5lZWRlZC4gKilcbmFuZCBtYWtlX3BhZGRpbmcgOiB0eXBlIHggeiBhIGIgYyBkIGUgZiAuXG4gICAgKChiLCBjKSBhY2MgLT4gZikgLT4gKGIsIGMpIGFjYyAtPlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT5cbiAgICAoeCwgeiAtPiBhKSBwYWRkaW5nIC0+ICh6IC0+IHN0cmluZykgLT4geCA9XG4gIGZ1biBrIGFjYyBmbXQgcGFkIHRyYW5zIC0+IG1hdGNoIHBhZCB3aXRoXG4gIHwgTm9fcGFkZGluZyAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBsZXQgbmV3X2FjYyA9IEFjY19kYXRhX3N0cmluZyAoYWNjLCB0cmFucyB4KSBpblxuICAgICAgbWFrZV9wcmludGYgayBuZXdfYWNjIGZtdFxuICB8IExpdF9wYWRkaW5nIChwYWR0eSwgd2lkdGgpIC0+XG4gICAgZnVuIHggLT5cbiAgICAgIGxldCBuZXdfYWNjID0gQWNjX2RhdGFfc3RyaW5nIChhY2MsIGZpeF9wYWRkaW5nIHBhZHR5IHdpZHRoICh0cmFucyB4KSkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgbmV3X2FjYyBmbXRcbiAgfCBBcmdfcGFkZGluZyBwYWR0eSAtPlxuICAgIGZ1biB3IHggLT5cbiAgICAgIGxldCBuZXdfYWNjID0gQWNjX2RhdGFfc3RyaW5nIChhY2MsIGZpeF9wYWRkaW5nIHBhZHR5IHcgKHRyYW5zIHgpKSBpblxuICAgICAgbWFrZV9wcmludGYgayBuZXdfYWNjIGZtdFxuXG4oKiBGaXggcGFkZGluZyBhbmQgcHJlY2lzaW9uIGZvciBpbnQsIGludDMyLCBuYXRpdmVpbnQgb3IgaW50NjQuICopXG4oKiBUYWtlIG9uZSBvciB0d28gZXh0cmEgaW50ZWdlciBhcmd1bWVudHMgaWYgbmVlZGVkLiAqKVxuYW5kIG1ha2VfaW50X3BhZGRpbmdfcHJlY2lzaW9uIDogdHlwZSB4IHkgeiBhIGIgYyBkIGUgZiAuXG4gICAgKChiLCBjKSBhY2MgLT4gZikgLT4gKGIsIGMpIGFjYyAtPlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT5cbiAgICAoeCwgeSkgcGFkZGluZyAtPiAoeSwgeiAtPiBhKSBwcmVjaXNpb24gLT4gKGludF9jb252IC0+IHogLT4gc3RyaW5nKSAtPlxuICAgIGludF9jb252IC0+IHggPVxuICBmdW4gayBhY2MgZm10IHBhZCBwcmVjIHRyYW5zIGljb252IC0+IG1hdGNoIHBhZCwgcHJlYyB3aXRoXG4gIHwgTm9fcGFkZGluZywgTm9fcHJlY2lzaW9uIC0+XG4gICAgZnVuIHggLT5cbiAgICAgIGxldCBzdHIgPSB0cmFucyBpY29udiB4IGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgTm9fcGFkZGluZywgTGl0X3ByZWNpc2lvbiBwIC0+XG4gICAgZnVuIHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfaW50X3ByZWNpc2lvbiBwICh0cmFucyBpY29udiB4KSBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IE5vX3BhZGRpbmcsIEFyZ19wcmVjaXNpb24gLT5cbiAgICBmdW4gcCB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X2ludF9wcmVjaXNpb24gcCAodHJhbnMgaWNvbnYgeCkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBMaXRfcGFkZGluZyAocGFkdHksIHcpLCBOb19wcmVjaXNpb24gLT5cbiAgICBmdW4geCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgKHRyYW5zIGljb252IHgpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgTGl0X3BhZGRpbmcgKHBhZHR5LCB3KSwgTGl0X3ByZWNpc2lvbiBwIC0+XG4gICAgZnVuIHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfcGFkZGluZyBwYWR0eSB3IChmaXhfaW50X3ByZWNpc2lvbiBwICh0cmFucyBpY29udiB4KSkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBMaXRfcGFkZGluZyAocGFkdHksIHcpLCBBcmdfcHJlY2lzaW9uIC0+XG4gICAgZnVuIHAgeCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgKGZpeF9pbnRfcHJlY2lzaW9uIHAgKHRyYW5zIGljb252IHgpKSBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IEFyZ19wYWRkaW5nIHBhZHR5LCBOb19wcmVjaXNpb24gLT5cbiAgICBmdW4gdyB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X3BhZGRpbmcgcGFkdHkgdyAodHJhbnMgaWNvbnYgeCkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBBcmdfcGFkZGluZyBwYWR0eSwgTGl0X3ByZWNpc2lvbiBwIC0+XG4gICAgZnVuIHcgeCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgKGZpeF9pbnRfcHJlY2lzaW9uIHAgKHRyYW5zIGljb252IHgpKSBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IEFyZ19wYWRkaW5nIHBhZHR5LCBBcmdfcHJlY2lzaW9uIC0+XG4gICAgZnVuIHcgcCB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X3BhZGRpbmcgcGFkdHkgdyAoZml4X2ludF9wcmVjaXNpb24gcCAodHJhbnMgaWNvbnYgeCkpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG5cbigqIENvbnZlcnQgYSBmbG9hdCwgZml4IHBhZGRpbmcgYW5kIHByZWNpc2lvbiBpZiBuZWVkZWQuICopXG4oKiBUYWtlIHRoZSBmbG9hdCBhcmd1bWVudCBhbmQgb25lIG9yIHR3byBleHRyYSBpbnRlZ2VyIGFyZ3VtZW50cyBpZiBuZWVkZWQuICopXG5hbmQgbWFrZV9mbG9hdF9wYWRkaW5nX3ByZWNpc2lvbiA6IHR5cGUgeCB5IGEgYiBjIGQgZSBmIC5cbiAgICAoKGIsIGMpIGFjYyAtPiBmKSAtPiAoYiwgYykgYWNjIC0+XG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPlxuICAgICh4LCB5KSBwYWRkaW5nIC0+ICh5LCBmbG9hdCAtPiBhKSBwcmVjaXNpb24gLT4gZmxvYXRfY29udiAtPiB4ID1cbiAgZnVuIGsgYWNjIGZtdCBwYWQgcHJlYyBmY29udiAtPiBtYXRjaCBwYWQsIHByZWMgd2l0aFxuICB8IE5vX3BhZGRpbmcsIE5vX3ByZWNpc2lvbiAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBsZXQgc3RyID0gY29udmVydF9mbG9hdCBmY29udiAoZGVmYXVsdF9mbG9hdF9wcmVjaXNpb24gZmNvbnYpIHggaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBOb19wYWRkaW5nLCBMaXRfcHJlY2lzaW9uIHAgLT5cbiAgICBmdW4geCAtPlxuICAgICAgbGV0IHN0ciA9IGNvbnZlcnRfZmxvYXQgZmNvbnYgcCB4IGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgTm9fcGFkZGluZywgQXJnX3ByZWNpc2lvbiAtPlxuICAgIGZ1biBwIHggLT5cbiAgICAgIGxldCBzdHIgPSBjb252ZXJ0X2Zsb2F0IGZjb252IHAgeCBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IExpdF9wYWRkaW5nIChwYWR0eSwgdyksIE5vX3ByZWNpc2lvbiAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBsZXQgc3RyID0gY29udmVydF9mbG9hdCBmY29udiAoZGVmYXVsdF9mbG9hdF9wcmVjaXNpb24gZmNvbnYpIHggaW5cbiAgICAgIGxldCBzdHInID0gZml4X3BhZGRpbmcgcGFkdHkgdyBzdHIgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHInKSkgZm10XG4gIHwgTGl0X3BhZGRpbmcgKHBhZHR5LCB3KSwgTGl0X3ByZWNpc2lvbiBwIC0+XG4gICAgZnVuIHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfcGFkZGluZyBwYWR0eSB3IChjb252ZXJ0X2Zsb2F0IGZjb252IHAgeCkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBMaXRfcGFkZGluZyAocGFkdHksIHcpLCBBcmdfcHJlY2lzaW9uIC0+XG4gICAgZnVuIHAgeCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgKGNvbnZlcnRfZmxvYXQgZmNvbnYgcCB4KSBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IEFyZ19wYWRkaW5nIHBhZHR5LCBOb19wcmVjaXNpb24gLT5cbiAgICBmdW4gdyB4IC0+XG4gICAgICBsZXQgc3RyID0gY29udmVydF9mbG9hdCBmY29udiAoZGVmYXVsdF9mbG9hdF9wcmVjaXNpb24gZmNvbnYpIHggaW5cbiAgICAgIGxldCBzdHInID0gZml4X3BhZGRpbmcgcGFkdHkgdyBzdHIgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHInKSkgZm10XG4gIHwgQXJnX3BhZGRpbmcgcGFkdHksIExpdF9wcmVjaXNpb24gcCAtPlxuICAgIGZ1biB3IHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfcGFkZGluZyBwYWR0eSB3IChjb252ZXJ0X2Zsb2F0IGZjb252IHAgeCkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBBcmdfcGFkZGluZyBwYWR0eSwgQXJnX3ByZWNpc2lvbiAtPlxuICAgIGZ1biB3IHAgeCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgKGNvbnZlcnRfZmxvYXQgZmNvbnYgcCB4KSBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuYW5kIG1ha2VfY3VzdG9tIDogdHlwZSB4IHkgYSBiIGMgZCBlIGYgLlxuICAoKGIsIGMpIGFjYyAtPiBmKSAtPiAoYiwgYykgYWNjIC0+XG4gIChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT5cbiAgKGEsIHgsIHkpIGN1c3RvbV9hcml0eSAtPiB4IC0+IHkgPVxuICBmdW4gayBhY2MgcmVzdCBhcml0eSBmIC0+IG1hdGNoIGFyaXR5IHdpdGhcbiAgfCBDdXN0b21femVybyAtPiBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgZikpIHJlc3RcbiAgfCBDdXN0b21fc3VjYyBhcml0eSAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBtYWtlX2N1c3RvbSBrIGFjYyByZXN0IGFyaXR5IChmIHgpXG5cbmxldCBjb25zdCB4IF8gPSB4XG5cbmxldCByZWMgbWFrZV9pcHJpbnRmIDogdHlwZSBhIGIgYyBkIGUgZiBzdGF0ZS5cbiAgKHN0YXRlIC0+IGYpIC0+IHN0YXRlIC0+IChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT4gYSA9XG4gIGZ1biBrIG8gZm10IC0+IG1hdGNoIGZtdCB3aXRoXG4gICAgfCBDaGFyIHJlc3QgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IENhbWxfY2hhciByZXN0IC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBTdHJpbmcgKE5vX3BhZGRpbmcsIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBTdHJpbmcgKExpdF9wYWRkaW5nIF8sIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBTdHJpbmcgKEFyZ19wYWRkaW5nIF8sIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KSlcbiAgICB8IENhbWxfc3RyaW5nIChOb19wYWRkaW5nLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgQ2FtbF9zdHJpbmcgKExpdF9wYWRkaW5nIF8sIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBDYW1sX3N0cmluZyAoQXJnX3BhZGRpbmcgXywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpKVxuICAgIHwgSW50IChfLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgICAgIGZuX29mX3BhZGRpbmdfcHJlY2lzaW9uIGsgbyByZXN0IHBhZCBwcmVjXG4gICAgfCBJbnQzMiAoXywgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgICAgICBmbl9vZl9wYWRkaW5nX3ByZWNpc2lvbiBrIG8gcmVzdCBwYWQgcHJlY1xuICAgIHwgTmF0aXZlaW50IChfLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgICAgIGZuX29mX3BhZGRpbmdfcHJlY2lzaW9uIGsgbyByZXN0IHBhZCBwcmVjXG4gICAgfCBJbnQ2NCAoXywgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgICAgICBmbl9vZl9wYWRkaW5nX3ByZWNpc2lvbiBrIG8gcmVzdCBwYWQgcHJlY1xuICAgIHwgRmxvYXQgKF8sIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICAgICAgZm5fb2ZfcGFkZGluZ19wcmVjaXNpb24gayBvIHJlc3QgcGFkIHByZWNcbiAgICB8IEJvb2wgKE5vX3BhZGRpbmcsIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBCb29sIChMaXRfcGFkZGluZyBfLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgQm9vbCAoQXJnX3BhZGRpbmcgXywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpKVxuICAgIHwgQWxwaGEgcmVzdCAtPlxuICAgICAgICBjb25zdCAoY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdCkpXG4gICAgfCBUaGV0YSByZXN0IC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBDdXN0b20gKGFyaXR5LCBfLCByZXN0KSAtPlxuICAgICAgICBmbl9vZl9jdXN0b21fYXJpdHkgayBvIHJlc3QgYXJpdHlcbiAgICB8IFJlYWRlciBfIC0+XG4gICAgICAgICgqIFRoaXMgY2FzZSBpcyBpbXBvc3NpYmxlLCBieSB0eXBpbmcgb2YgZm9ybWF0cy4gIFNlZSB0aGVcbiAgICAgICAgICAgbm90ZSBpbiB0aGUgY29ycmVzcG9uZGluZyBjYXNlIGZvciBtYWtlX3ByaW50Zi4gKilcbiAgICAgICAgYXNzZXJ0IGZhbHNlXG4gICAgfCBGbHVzaCByZXN0IC0+XG4gICAgICAgIG1ha2VfaXByaW50ZiBrIG8gcmVzdFxuICAgIHwgU3RyaW5nX2xpdGVyYWwgKF8sIHJlc3QpIC0+XG4gICAgICAgIG1ha2VfaXByaW50ZiBrIG8gcmVzdFxuICAgIHwgQ2hhcl9saXRlcmFsIChfLCByZXN0KSAtPlxuICAgICAgICBtYWtlX2lwcmludGYgayBvIHJlc3RcbiAgICB8IEZvcm1hdF9hcmcgKF8sIF8sIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBGb3JtYXRfc3Vic3QgKF8sIGZtdHR5LCByZXN0KSAtPlxuICAgICAgICBmdW4gKEZvcm1hdCAoZm10LCBfKSkgLT5cbiAgICAgICAgICBtYWtlX2lwcmludGYgayBvXG4gICAgICAgICAgICAoY29uY2F0X2ZtdCAocmVjYXN0IGZtdCBmbXR0eSkgcmVzdClcbiAgICB8IFNjYW5fY2hhcl9zZXQgKF8sIF8sIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBTY2FuX2dldF9jb3VudGVyIChfLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgU2Nhbl9uZXh0X2NoYXIgcmVzdCAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgSWdub3JlZF9wYXJhbSAoaWduLCByZXN0KSAtPlxuICAgICAgICBtYWtlX2lnbm9yZWRfcGFyYW0gKGZ1biBfIC0+IGsgbykgKEVuZF9vZl9hY2MpIGlnbiByZXN0XG4gICAgfCBGb3JtYXR0aW5nX2xpdCAoXywgcmVzdCkgLT5cbiAgICAgICAgbWFrZV9pcHJpbnRmIGsgbyByZXN0XG4gICAgfCBGb3JtYXR0aW5nX2dlbiAoT3Blbl90YWcgKEZvcm1hdCAoZm10JywgXykpLCByZXN0KSAtPlxuICAgICAgICBtYWtlX2lwcmludGYgKGZ1biBrb2MgLT4gbWFrZV9pcHJpbnRmIGsga29jIHJlc3QpIG8gZm10J1xuICAgIHwgRm9ybWF0dGluZ19nZW4gKE9wZW5fYm94IChGb3JtYXQgKGZtdCcsIF8pKSwgcmVzdCkgLT5cbiAgICAgICAgbWFrZV9pcHJpbnRmIChmdW4ga29jIC0+IG1ha2VfaXByaW50ZiBrIGtvYyByZXN0KSBvIGZtdCdcbiAgICB8IEVuZF9vZl9mb3JtYXQgLT5cbiAgICAgICAgayBvXG5hbmQgZm5fb2ZfcGFkZGluZ19wcmVjaXNpb24gOlxuICB0eXBlIHggeSB6IGEgYiBjIGQgZSBmIHN0YXRlLlxuICAoc3RhdGUgLT4gZikgLT4gc3RhdGUgLT4gKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPlxuICAoeCwgeSkgcGFkZGluZyAtPiAoeSwgeiAtPiBhKSBwcmVjaXNpb24gLT4geCA9XG4gIGZ1biBrIG8gZm10IHBhZCBwcmVjIC0+IG1hdGNoIHBhZCwgcHJlYyB3aXRoXG4gICAgfCBOb19wYWRkaW5nICAgLCBOb19wcmVjaXNpb24gICAgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gZm10KVxuICAgIHwgTm9fcGFkZGluZyAgICwgTGl0X3ByZWNpc2lvbiBfIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIGZtdClcbiAgICB8IE5vX3BhZGRpbmcgICAsIEFyZ19wcmVjaXNpb24gICAtPlxuICAgICAgICBjb25zdCAoY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gZm10KSlcbiAgICB8IExpdF9wYWRkaW5nIF8sIE5vX3ByZWNpc2lvbiAgICAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyBmbXQpXG4gICAgfCBMaXRfcGFkZGluZyBfLCBMaXRfcHJlY2lzaW9uIF8gLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gZm10KVxuICAgIHwgTGl0X3BhZGRpbmcgXywgQXJnX3ByZWNpc2lvbiAgIC0+XG4gICAgICAgIGNvbnN0IChjb25zdCAobWFrZV9pcHJpbnRmIGsgbyBmbXQpKVxuICAgIHwgQXJnX3BhZGRpbmcgXywgTm9fcHJlY2lzaW9uICAgIC0+XG4gICAgICAgIGNvbnN0IChjb25zdCAobWFrZV9pcHJpbnRmIGsgbyBmbXQpKVxuICAgIHwgQXJnX3BhZGRpbmcgXywgTGl0X3ByZWNpc2lvbiBfIC0+XG4gICAgICAgIGNvbnN0IChjb25zdCAobWFrZV9pcHJpbnRmIGsgbyBmbXQpKVxuICAgIHwgQXJnX3BhZGRpbmcgXywgQXJnX3ByZWNpc2lvbiAgIC0+XG4gICAgICAgIGNvbnN0IChjb25zdCAoY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gZm10KSkpXG5hbmQgZm5fb2ZfY3VzdG9tX2FyaXR5IDogdHlwZSB4IHkgYSBiIGMgZCBlIGYgc3RhdGUuXG4gIChzdGF0ZSAtPiBmKSAtPlxuICBzdGF0ZSAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+IChhLCB4LCB5KSBjdXN0b21fYXJpdHkgLT4geSA9XG4gIGZ1biBrIG8gZm10IC0+IGZ1bmN0aW9uXG4gICAgfCBDdXN0b21femVybyAtPlxuICAgICAgICBtYWtlX2lwcmludGYgayBvIGZtdFxuICAgIHwgQ3VzdG9tX3N1Y2MgYXJpdHkgLT5cbiAgICAgICAgY29uc3QgKGZuX29mX2N1c3RvbV9hcml0eSBrIG8gZm10IGFyaXR5KVxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBDb250aW51YXRpb25zIGZvciBtYWtlX3ByaW50ZiAqKVxuXG4oKiBSZWN1cnNpdmVseSBvdXRwdXQgYW4gXCJhY2N1bXVsYXRvclwiIGNvbnRhaW5pbmcgYSByZXZlcnNlZCBsaXN0IG9mXG4gICBwcmludGluZyBlbnRpdGllcyAoc3RyaW5nLCBjaGFyLCBmbHVzLCAuLi4pIGluIGFuIG91dHB1dF9zdHJlYW0uICopXG4oKiBVc2VkIGFzIGEgY29udGludWF0aW9uIG9mIG1ha2VfcHJpbnRmLiAqKVxubGV0IHJlYyBvdXRwdXRfYWNjIG8gYWNjID0gbWF0Y2ggYWNjIHdpdGhcbiAgfCBBY2NfZm9ybWF0dGluZ19saXQgKHAsIGZtdGluZ19saXQpIC0+XG4gICAgbGV0IHMgPSBzdHJpbmdfb2ZfZm9ybWF0dGluZ19saXQgZm10aW5nX2xpdCBpblxuICAgIG91dHB1dF9hY2MgbyBwOyBvdXRwdXRfc3RyaW5nIG8gcztcbiAgfCBBY2NfZm9ybWF0dGluZ19nZW4gKHAsIEFjY19vcGVuX3RhZyBhY2MnKSAtPlxuICAgIG91dHB1dF9hY2MgbyBwOyBvdXRwdXRfc3RyaW5nIG8gXCJAe1wiOyBvdXRwdXRfYWNjIG8gYWNjJztcbiAgfCBBY2NfZm9ybWF0dGluZ19nZW4gKHAsIEFjY19vcGVuX2JveCBhY2MnKSAtPlxuICAgIG91dHB1dF9hY2MgbyBwOyBvdXRwdXRfc3RyaW5nIG8gXCJAW1wiOyBvdXRwdXRfYWNjIG8gYWNjJztcbiAgfCBBY2Nfc3RyaW5nX2xpdGVyYWwgKHAsIHMpXG4gIHwgQWNjX2RhdGFfc3RyaW5nIChwLCBzKSAgIC0+IG91dHB1dF9hY2MgbyBwOyBvdXRwdXRfc3RyaW5nIG8gc1xuICB8IEFjY19jaGFyX2xpdGVyYWwgKHAsIGMpXG4gIHwgQWNjX2RhdGFfY2hhciAocCwgYykgICAgIC0+IG91dHB1dF9hY2MgbyBwOyBvdXRwdXRfY2hhciBvIGNcbiAgfCBBY2NfZGVsYXkgKHAsIGYpICAgICAgICAgLT4gb3V0cHV0X2FjYyBvIHA7IGYgb1xuICB8IEFjY19mbHVzaCBwICAgICAgICAgICAgICAtPiBvdXRwdXRfYWNjIG8gcDsgZmx1c2ggb1xuICB8IEFjY19pbnZhbGlkX2FyZyAocCwgbXNnKSAtPiBvdXRwdXRfYWNjIG8gcDsgaW52YWxpZF9hcmcgbXNnO1xuICB8IEVuZF9vZl9hY2MgICAgICAgICAgICAgICAtPiAoKVxuXG4oKiBSZWN1cnNpdmVseSBvdXRwdXQgYW4gXCJhY2N1bXVsYXRvclwiIGNvbnRhaW5pbmcgYSByZXZlcnNlZCBsaXN0IG9mXG4gICBwcmludGluZyBlbnRpdGllcyAoc3RyaW5nLCBjaGFyLCBmbHVzLCAuLi4pIGluIGEgYnVmZmVyLiAqKVxuKCogVXNlZCBhcyBhIGNvbnRpbnVhdGlvbiBvZiBtYWtlX3ByaW50Zi4gKilcbmxldCByZWMgYnVmcHV0X2FjYyBiIGFjYyA9IG1hdGNoIGFjYyB3aXRoXG4gIHwgQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBmbXRpbmdfbGl0KSAtPlxuICAgIGxldCBzID0gc3RyaW5nX29mX2Zvcm1hdHRpbmdfbGl0IGZtdGluZ19saXQgaW5cbiAgICBidWZwdXRfYWNjIGIgcDsgQnVmZmVyLmFkZF9zdHJpbmcgYiBzO1xuICB8IEFjY19mb3JtYXR0aW5nX2dlbiAocCwgQWNjX29wZW5fdGFnIGFjYycpIC0+XG4gICAgYnVmcHV0X2FjYyBiIHA7IEJ1ZmZlci5hZGRfc3RyaW5nIGIgXCJAe1wiOyBidWZwdXRfYWNjIGIgYWNjJztcbiAgfCBBY2NfZm9ybWF0dGluZ19nZW4gKHAsIEFjY19vcGVuX2JveCBhY2MnKSAtPlxuICAgIGJ1ZnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX3N0cmluZyBiIFwiQFtcIjsgYnVmcHV0X2FjYyBiIGFjYyc7XG4gIHwgQWNjX3N0cmluZ19saXRlcmFsIChwLCBzKVxuICB8IEFjY19kYXRhX3N0cmluZyAocCwgcykgICAtPiBidWZwdXRfYWNjIGIgcDsgQnVmZmVyLmFkZF9zdHJpbmcgYiBzXG4gIHwgQWNjX2NoYXJfbGl0ZXJhbCAocCwgYylcbiAgfCBBY2NfZGF0YV9jaGFyIChwLCBjKSAgICAgLT4gYnVmcHV0X2FjYyBiIHA7IEJ1ZmZlci5hZGRfY2hhciBiIGNcbiAgfCBBY2NfZGVsYXkgKHAsIGYpICAgICAgICAgLT4gYnVmcHV0X2FjYyBiIHA7IGYgYlxuICB8IEFjY19mbHVzaCBwICAgICAgICAgICAgICAtPiBidWZwdXRfYWNjIGIgcDtcbiAgfCBBY2NfaW52YWxpZF9hcmcgKHAsIG1zZykgLT4gYnVmcHV0X2FjYyBiIHA7IGludmFsaWRfYXJnIG1zZztcbiAgfCBFbmRfb2ZfYWNjICAgICAgICAgICAgICAgLT4gKClcblxuKCogUmVjdXJzaXZlbHkgb3V0cHV0IGFuIFwiYWNjdW11bGF0b3JcIiBjb250YWluaW5nIGEgcmV2ZXJzZWQgbGlzdCBvZlxuICAgcHJpbnRpbmcgZW50aXRpZXMgKHN0cmluZywgY2hhciwgZmx1cywgLi4uKSBpbiBhIGJ1ZmZlci4gKilcbigqIERpZmZlciBmcm9tIGJ1ZnB1dF9hY2MgYnkgdGhlIGludGVycHJldGF0aW9uIG9mICVhIGFuZCAldC4gKilcbigqIFVzZWQgYXMgYSBjb250aW51YXRpb24gb2YgbWFrZV9wcmludGYuICopXG5sZXQgcmVjIHN0cnB1dF9hY2MgYiBhY2MgPSBtYXRjaCBhY2Mgd2l0aFxuICB8IEFjY19mb3JtYXR0aW5nX2xpdCAocCwgZm10aW5nX2xpdCkgLT5cbiAgICBsZXQgcyA9IHN0cmluZ19vZl9mb3JtYXR0aW5nX2xpdCBmbXRpbmdfbGl0IGluXG4gICAgc3RycHV0X2FjYyBiIHA7IEJ1ZmZlci5hZGRfc3RyaW5nIGIgcztcbiAgfCBBY2NfZm9ybWF0dGluZ19nZW4gKHAsIEFjY19vcGVuX3RhZyBhY2MnKSAtPlxuICAgIHN0cnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX3N0cmluZyBiIFwiQHtcIjsgc3RycHV0X2FjYyBiIGFjYyc7XG4gIHwgQWNjX2Zvcm1hdHRpbmdfZ2VuIChwLCBBY2Nfb3Blbl9ib3ggYWNjJykgLT5cbiAgICBzdHJwdXRfYWNjIGIgcDsgQnVmZmVyLmFkZF9zdHJpbmcgYiBcIkBbXCI7IHN0cnB1dF9hY2MgYiBhY2MnO1xuICB8IEFjY19zdHJpbmdfbGl0ZXJhbCAocCwgcylcbiAgfCBBY2NfZGF0YV9zdHJpbmcgKHAsIHMpICAgLT4gc3RycHV0X2FjYyBiIHA7IEJ1ZmZlci5hZGRfc3RyaW5nIGIgc1xuICB8IEFjY19jaGFyX2xpdGVyYWwgKHAsIGMpXG4gIHwgQWNjX2RhdGFfY2hhciAocCwgYykgICAgIC0+IHN0cnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX2NoYXIgYiBjXG4gIHwgQWNjX2RlbGF5IChwLCBmKSAgICAgICAgIC0+IHN0cnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX3N0cmluZyBiIChmICgpKVxuICB8IEFjY19mbHVzaCBwICAgICAgICAgICAgICAtPiBzdHJwdXRfYWNjIGIgcDtcbiAgfCBBY2NfaW52YWxpZF9hcmcgKHAsIG1zZykgLT4gc3RycHV0X2FjYyBiIHA7IGludmFsaWRfYXJnIG1zZztcbiAgfCBFbmRfb2ZfYWNjICAgICAgICAgICAgICAgLT4gKClcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKCogRXJyb3IgbWFuYWdlbWVudCAqKVxuXG4oKiBSYWlzZSBbRmFpbHVyZV0gd2l0aCBhIHByZXR0eS1wcmludGVkIGVycm9yIG1lc3NhZ2UuICopXG5sZXQgZmFpbHdpdGhfbWVzc2FnZSAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIGxldCBidWYgPSBCdWZmZXIuY3JlYXRlIDI1NiBpblxuICBsZXQgayBhY2MgPSBzdHJwdXRfYWNjIGJ1ZiBhY2M7IGZhaWx3aXRoIChCdWZmZXIuY29udGVudHMgYnVmKSBpblxuICBtYWtlX3ByaW50ZiBrIEVuZF9vZl9hY2MgZm10XG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogRm9ybWF0dGluZyB0b29scyAqKVxuXG4oKiBDb252ZXJ0IGEgc3RyaW5nIHRvIGFuIG9wZW4gYmxvY2sgZGVzY3JpcHRpb24gKGluZGVudCwgYmxvY2tfdHlwZSkgKilcbmxldCBvcGVuX2JveF9vZl9zdHJpbmcgc3RyID1cbiAgaWYgc3RyID0gXCJcIiB0aGVuICgwLCBQcF9ib3gpIGVsc2VcbiAgICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzdHIgaW5cbiAgICBsZXQgaW52YWxpZF9ib3ggKCkgPSBmYWlsd2l0aF9tZXNzYWdlIFwiaW52YWxpZCBib3ggZGVzY3JpcHRpb24gJVNcIiBzdHIgaW5cbiAgICBsZXQgcmVjIHBhcnNlX3NwYWNlcyBpID1cbiAgICAgIGlmIGkgPSBsZW4gdGhlbiBpIGVsc2VcbiAgICAgICAgbWF0Y2ggc3RyLltpXSB3aXRoXG4gICAgICAgIHwgJyAnIHwgJ1xcdCcgLT4gcGFyc2Vfc3BhY2VzIChpICsgMSlcbiAgICAgICAgfCBfIC0+IGlcbiAgICBhbmQgcGFyc2VfbHdvcmQgaSBqID1cbiAgICAgIGlmIGogPSBsZW4gdGhlbiBqIGVsc2VcbiAgICAgICAgbWF0Y2ggc3RyLltqXSB3aXRoXG4gICAgICAgIHwgJ2EnIC4uICd6JyAtPiBwYXJzZV9sd29yZCBpIChqICsgMSlcbiAgICAgICAgfCBfIC0+IGpcbiAgICBhbmQgcGFyc2VfaW50IGkgaiA9XG4gICAgICBpZiBqID0gbGVuIHRoZW4gaiBlbHNlXG4gICAgICAgIG1hdGNoIHN0ci5bal0gd2l0aFxuICAgICAgICB8ICcwJyAuLiAnOScgfCAnLScgLT4gcGFyc2VfaW50IGkgKGogKyAxKVxuICAgICAgICB8IF8gLT4gaiBpblxuICAgIGxldCB3c3RhcnQgPSBwYXJzZV9zcGFjZXMgMCBpblxuICAgIGxldCB3ZW5kID0gcGFyc2VfbHdvcmQgd3N0YXJ0IHdzdGFydCBpblxuICAgIGxldCBib3hfbmFtZSA9IFN0cmluZy5zdWIgc3RyIHdzdGFydCAod2VuZCAtIHdzdGFydCkgaW5cbiAgICBsZXQgbnN0YXJ0ID0gcGFyc2Vfc3BhY2VzIHdlbmQgaW5cbiAgICBsZXQgbmVuZCA9IHBhcnNlX2ludCBuc3RhcnQgbnN0YXJ0IGluXG4gICAgbGV0IGluZGVudCA9XG4gICAgICBpZiBuc3RhcnQgPSBuZW5kIHRoZW4gMCBlbHNlXG4gICAgICAgIHRyeSBpbnRfb2Zfc3RyaW5nIChTdHJpbmcuc3ViIHN0ciBuc3RhcnQgKG5lbmQgLSBuc3RhcnQpKVxuICAgICAgICB3aXRoIEZhaWx1cmUgXyAtPiBpbnZhbGlkX2JveCAoKSBpblxuICAgIGxldCBleHBfZW5kID0gcGFyc2Vfc3BhY2VzIG5lbmQgaW5cbiAgICBpZiBleHBfZW5kIDw+IGxlbiB0aGVuIGludmFsaWRfYm94ICgpO1xuICAgIGxldCBib3hfdHlwZSA9IG1hdGNoIGJveF9uYW1lIHdpdGhcbiAgICAgIHwgXCJcIiB8IFwiYlwiIC0+IFBwX2JveFxuICAgICAgfCBcImhcIiAgICAgIC0+IFBwX2hib3hcbiAgICAgIHwgXCJ2XCIgICAgICAtPiBQcF92Ym94XG4gICAgICB8IFwiaHZcIiAgICAgLT4gUHBfaHZib3hcbiAgICAgIHwgXCJob3ZcIiAgICAtPiBQcF9ob3Zib3hcbiAgICAgIHwgXyAgICAgICAgLT4gaW52YWxpZF9ib3ggKCkgaW5cbiAgICAoaW5kZW50LCBib3hfdHlwZSlcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBQYXJzaW5nIHRvb2xzICopXG5cbigqIENyZWF0ZSBhIHBhZGRpbmdfZm10X2ViYiBmcm9tIGEgcGFkZGluZyBhbmQgYSBmb3JtYXQuICopXG4oKiBDb3B5IHRoZSBwYWRkaW5nIHRvIGRpc2pvaW4gdGhlIHR5cGUgcGFyYW1ldGVycyBvZiBhcmd1bWVudCBhbmQgcmVzdWx0LiAqKVxubGV0IG1ha2VfcGFkZGluZ19mbXRfZWJiIDogdHlwZSB4IHkgLlxuICAgICh4LCB5KSBwYWRkaW5nIC0+IChfLCBfLCBfLCBfLCBfLCBfKSBmbXQgLT5cbiAgICAgIChfLCBfLCBfLCBfLCBfKSBwYWRkaW5nX2ZtdF9lYmIgPVxuZnVuIHBhZCBmbXQgLT4gbWF0Y2ggcGFkIHdpdGhcbiAgfCBOb19wYWRkaW5nICAgICAgICAgLT4gUGFkZGluZ19mbXRfRUJCIChOb19wYWRkaW5nLCBmbXQpXG4gIHwgTGl0X3BhZGRpbmcgKHMsIHcpIC0+IFBhZGRpbmdfZm10X0VCQiAoTGl0X3BhZGRpbmcgKHMsIHcpLCBmbXQpXG4gIHwgQXJnX3BhZGRpbmcgcyAgICAgIC0+IFBhZGRpbmdfZm10X0VCQiAoQXJnX3BhZGRpbmcgcywgZm10KVxuXG4oKiBDcmVhdGUgYSBwcmVjaXNpb25fZm10X2ViYiBmcm9tIGEgcHJlY2lzaW9uIGFuZCBhIGZvcm1hdC4gKilcbigqIENvcHkgdGhlIHByZWNpc2lvbiB0byBkaXNqb2luIHRoZSB0eXBlIHBhcmFtZXRlcnMgb2YgYXJndW1lbnQgYW5kIHJlc3VsdC4gKilcbmxldCBtYWtlX3ByZWNpc2lvbl9mbXRfZWJiIDogdHlwZSB4IHkgLlxuICAgICh4LCB5KSBwcmVjaXNpb24gLT4gKF8sIF8sIF8sIF8sIF8sIF8pIGZtdCAtPlxuICAgICAgKF8sIF8sIF8sIF8sIF8pIHByZWNpc2lvbl9mbXRfZWJiID1cbmZ1biBwcmVjIGZtdCAtPiBtYXRjaCBwcmVjIHdpdGhcbiAgfCBOb19wcmVjaXNpb24gICAgLT4gUHJlY2lzaW9uX2ZtdF9FQkIgKE5vX3ByZWNpc2lvbiwgZm10KVxuICB8IExpdF9wcmVjaXNpb24gcCAtPiBQcmVjaXNpb25fZm10X0VCQiAoTGl0X3ByZWNpc2lvbiBwLCBmbXQpXG4gIHwgQXJnX3ByZWNpc2lvbiAgIC0+IFByZWNpc2lvbl9mbXRfRUJCIChBcmdfcHJlY2lzaW9uLCBmbXQpXG5cbigqIENyZWF0ZSBhIHBhZHByZWNfZm10X2ViYiBmcm9tIGEgcGFkZGluZywgYSBwcmVjaXNpb24gYW5kIGEgZm9ybWF0LiAqKVxuKCogQ29weSB0aGUgcGFkZGluZyBhbmQgdGhlIHByZWNpc2lvbiB0byBkaXNqb2luIHR5cGUgcGFyYW1ldGVycyBvZiBhcmd1bWVudHNcbiAgIGFuZCByZXN1bHQuICopXG5sZXQgbWFrZV9wYWRwcmVjX2ZtdF9lYmIgOiB0eXBlIHggeSB6IHQgLlxuICAgICh4LCB5KSBwYWRkaW5nIC0+ICh6LCB0KSBwcmVjaXNpb24gLT5cbiAgICAoXywgXywgXywgXywgXywgXykgZm10IC0+XG4gICAgKF8sIF8sIF8sIF8sIF8pIHBhZHByZWNfZm10X2ViYiA9XG5mdW4gcGFkIHByZWMgZm10IC0+XG4gIGxldCBQcmVjaXNpb25fZm10X0VCQiAocHJlYywgZm10JykgPSBtYWtlX3ByZWNpc2lvbl9mbXRfZWJiIHByZWMgZm10IGluXG4gIG1hdGNoIHBhZCB3aXRoXG4gIHwgTm9fcGFkZGluZyAgICAgICAgIC0+IFBhZHByZWNfZm10X0VCQiAoTm9fcGFkZGluZywgcHJlYywgZm10JylcbiAgfCBMaXRfcGFkZGluZyAocywgdykgLT4gUGFkcHJlY19mbXRfRUJCIChMaXRfcGFkZGluZyAocywgdyksIHByZWMsIGZtdCcpXG4gIHwgQXJnX3BhZGRpbmcgcyAgICAgIC0+IFBhZHByZWNfZm10X0VCQiAoQXJnX3BhZGRpbmcgcywgcHJlYywgZm10JylcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogRm9ybWF0IHBhcnNpbmcgKilcblxuKCogUGFyc2UgYSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZm9ybWF0IGFuZCBjcmVhdGUgYSBmbXRfZWJiLiAqKVxuKCogUmFpc2UgW0ZhaWx1cmVdIGluIGNhc2Ugb2YgaW52YWxpZCBmb3JtYXQuICopXG5sZXQgZm10X2ViYl9vZl9zdHJpbmcgP2xlZ2FjeV9iZWhhdmlvciBzdHIgPVxuICAoKiBQYXJhbWV0ZXJzIG5hbWluZyBjb252ZW50aW9uOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4gICgqICAgLSBsaXRfc3RhcnQ6IHN0YXJ0IG9mIHRoZSBsaXRlcmFsIHNlcXVlbmNlLiAgICAgICAgICAgICAgICAgICAgKilcbiAgKCogICAtIHN0cl9pbmQ6IGN1cnJlbnQgaW5kZXggaW4gdGhlIHN0cmluZy4gICAgICAgICAgICAgICAgICAgICAgICAqKVxuICAoKiAgIC0gZW5kX2luZDogZW5kIG9mIHRoZSBjdXJyZW50IChzdWItKWZvcm1hdC4gICAgICAgICAgICAgICAgICAgICopXG4gICgqICAgLSBwY3RfaW5kOiBpbmRleCBvZiB0aGUgJyUnIGluIHRoZSBjdXJyZW50IG1pY3JvLWZvcm1hdC4gICAgICAgKilcbiAgKCogICAtIHplcm86ICBpcyB0aGUgJzAnIGZsYWcgZGVmaW5lZCBpbiB0aGUgY3VycmVudCBtaWNyby1mb3JtYXQuICAqKVxuICAoKiAgIC0gbWludXM6IGlzIHRoZSAnLScgZmxhZyBkZWZpbmVkIGluIHRoZSBjdXJyZW50IG1pY3JvLWZvcm1hdC4gICopXG4gICgqICAgLSBwbHVzOiAgaXMgdGhlICcrJyBmbGFnIGRlZmluZWQgaW4gdGhlIGN1cnJlbnQgbWljcm8tZm9ybWF0LiAgKilcbiAgKCogICAtIGhhc2g6ICBpcyB0aGUgJyMnIGZsYWcgZGVmaW5lZCBpbiB0aGUgY3VycmVudCBtaWNyby1mb3JtYXQuICAqKVxuICAoKiAgIC0gc3BhY2U6IGlzIHRoZSAnICcgZmxhZyBkZWZpbmVkIGluIHRoZSBjdXJyZW50IG1pY3JvLWZvcm1hdC4gICopXG4gICgqICAgLSBpZ246ICAgaXMgdGhlICdfJyBmbGFnIGRlZmluZWQgaW4gdGhlIGN1cnJlbnQgbWljcm8tZm9ybWF0LiAgKilcbiAgKCogICAtIHBhZDogcGFkZGluZyBvZiB0aGUgY3VycmVudCBtaWNyby1mb3JtYXQuICAgICAgICAgICAgICAgICAgICAqKVxuICAoKiAgIC0gcHJlYzogcHJlY2lzaW9uIG9mIHRoZSBjdXJyZW50IG1pY3JvLWZvcm1hdC4gICAgICAgICAgICAgICAgICopXG4gICgqICAgLSBzeW1iOiBjaGFyIHJlcHJlc2VudGluZyB0aGUgY29udmVyc2lvbiAoJ2MnLCAncycsICdkJywgLi4uKS4gKilcbiAgKCogICAtIGNoYXJfc2V0OiBzZXQgb2YgY2hhcmFjdGVycyBhcyBiaXRtYXAgKHNlZSBzY2FuZiAlWy4uLl0pLiAgICAqKVxuXG4gIGxldCBsZWdhY3lfYmVoYXZpb3IgPSBtYXRjaCBsZWdhY3lfYmVoYXZpb3Igd2l0aFxuICAgIHwgU29tZSBmbGFnIC0+IGZsYWdcbiAgICB8IE5vbmUgLT4gdHJ1ZVxuICAoKiAgV2hlbiB0aGlzIGZsYWcgaXMgZW5hYmxlZCwgdGhlIGZvcm1hdCBwYXJzZXIgdHJpZXMgdG8gYmVoYXZlIGFzXG4gICAgICB0aGUgPDQuMDIgaW1wbGVtZW50YXRpb25zLCBpbiBwYXJ0aWN1bGFyIGl0IGlnbm9yZXMgbW9zdCBiZW5pbmVcbiAgICAgIG5vbnNlbnNpY2FsIGZvcm1hdC4gV2hlbiB0aGUgZmxhZyBpcyBkaXNhYmxlZCwgaXQgd2lsbCByZWplY3QgYW55XG4gICAgICBmb3JtYXQgdGhhdCBpcyBub3QgYWNjZXB0ZWQgYnkgdGhlIHNwZWNpZmljYXRpb24uXG5cbiAgICAgIEEgdHlwaWNhbCBleGFtcGxlIHdvdWxkIGJlIFwiJSsgZFwiOiBzcGVjaWZ5aW5nIGJvdGggJysnIChpZiB0aGVcbiAgICAgIG51bWJlciBpcyBwb3NpdGl2ZSwgcGFkIHdpdGggYSAnKycgdG8gZ2V0IHRoZSBzYW1lIHdpZHRoIGFzXG4gICAgICBuZWdhdGl2ZSBudW1iZXJzKSBhbmQgJyAnIChpZiB0aGUgbnVtYmVyIGlzIHBvc2l0aXZlLCBwYWQgd2l0aFxuICAgICAgYSBzcGFjZSkgZG9lcyBub3QgbWFrZSBzZW5zZSwgYnV0IHRoZSBsZWdhY3kgKDwgNC4wMilcbiAgICAgIGltcGxlbWVudGF0aW9uIHdhcyBoYXBweSB0byBqdXN0IGlnbm9yZSB0aGUgc3BhY2UuXG4gICopXG4gIGluXG5cbiAgKCogUmFpc2UgW0ZhaWx1cmVdIHdpdGggYSBmcmllbmRseSBlcnJvciBtZXNzYWdlLiAqKVxuICBsZXQgaW52YWxpZF9mb3JtYXRfbWVzc2FnZSBzdHJfaW5kIG1zZyA9XG4gICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgXCJpbnZhbGlkIGZvcm1hdCAlUzogYXQgY2hhcmFjdGVyIG51bWJlciAlZCwgJXNcIlxuICAgICAgc3RyIHN0cl9pbmQgbXNnXG4gIGluXG5cbiAgKCogVXNlZCB3aGVuIHRoZSBlbmQgb2YgdGhlIGZvcm1hdCAob3IgdGhlIGN1cnJlbnQgc3ViLWZvcm1hdCkgd2FzIGVuY291bnRlcmVkXG4gICAgICB1bmV4cGVjdGVkbHkuICopXG4gIGxldCB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZCA9XG4gICAgaW52YWxpZF9mb3JtYXRfbWVzc2FnZSBlbmRfaW5kXG4gICAgICBcInVuZXhwZWN0ZWQgZW5kIG9mIGZvcm1hdFwiXG4gIGluXG5cbiAgKCogVXNlZCBmb3IgJTBjOiBubyBvdGhlciB3aWR0aHMgYXJlIGltcGxlbWVudGVkICopXG4gIGxldCBpbnZhbGlkX25vbm51bGxfY2hhcl93aWR0aCBzdHJfaW5kID1cbiAgICBpbnZhbGlkX2Zvcm1hdF9tZXNzYWdlIHN0cl9pbmRcbiAgICAgIFwibm9uLXplcm8gd2lkdGhzIGFyZSB1bnN1cHBvcnRlZCBmb3IgJWMgY29udmVyc2lvbnNcIlxuICBpblxuICAoKiBSYWlzZSBbRmFpbHVyZV0gd2l0aCBhIGZyaWVuZGx5IGVycm9yIG1lc3NhZ2UgYWJvdXQgYW4gb3B0aW9uIGRlcGVuZGVuY3lcbiAgICAgcHJvYmxlbS4gKilcbiAgbGV0IGludmFsaWRfZm9ybWF0X3dpdGhvdXQgc3RyX2luZCBjIHMgPVxuICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgIFwiaW52YWxpZCBmb3JtYXQgJVM6IGF0IGNoYXJhY3RlciBudW1iZXIgJWQsICclYycgd2l0aG91dCAlc1wiXG4gICAgICBzdHIgc3RyX2luZCBjIHNcbiAgaW5cblxuICAoKiBSYWlzZSBbRmFpbHVyZV0gd2l0aCBhIGZyaWVuZGx5IGVycm9yIG1lc3NhZ2UgYWJvdXQgYW4gdW5leHBlY3RlZFxuICAgICBjaGFyYWN0ZXIuICopXG4gIGxldCBleHBlY3RlZF9jaGFyYWN0ZXIgc3RyX2luZCBleHBlY3RlZCByZWFkID1cbiAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgIFwiaW52YWxpZCBmb3JtYXQgJVM6IGF0IGNoYXJhY3RlciBudW1iZXIgJWQsICVzIGV4cGVjdGVkLCByZWFkICVDXCJcbiAgICAgIHN0ciBzdHJfaW5kIGV4cGVjdGVkIHJlYWRcbiAgaW5cblxuICAoKiBQYXJzZSB0aGUgc3RyaW5nIGZyb20gYmVnX2luZCAoaW5jbHVkZWQpIHRvIGVuZF9pbmQgKGV4Y2x1ZGVkKS4gKilcbiAgbGV0IHJlYyBwYXJzZSA6IHR5cGUgZSBmIC4gaW50IC0+IGludCAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBiZWdfaW5kIGVuZF9pbmQgLT4gcGFyc2VfbGl0ZXJhbCBiZWdfaW5kIGJlZ19pbmQgZW5kX2luZFxuXG4gICgqIFJlYWQgbGl0ZXJhbCBjaGFyYWN0ZXJzIHVwIHRvICclJyBvciAnQCcgc3BlY2lhbCBjaGFyYWN0ZXJzLiAqKVxuICBhbmQgcGFyc2VfbGl0ZXJhbCA6IHR5cGUgZSBmIC4gaW50IC0+IGludCAtPiBpbnQgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gbGl0X3N0YXJ0IHN0cl9pbmQgZW5kX2luZCAtPlxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gYWRkX2xpdGVyYWwgbGl0X3N0YXJ0IHN0cl9pbmQgRW5kX29mX2Zvcm1hdCBlbHNlXG4gICAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICAgIHwgJyUnIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2VfZm9ybWF0IHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgICBhZGRfbGl0ZXJhbCBsaXRfc3RhcnQgc3RyX2luZCBmbXRfcmVzdFxuICAgICAgfCAnQCcgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZV9hZnRlcl9hdCAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgYWRkX2xpdGVyYWwgbGl0X3N0YXJ0IHN0cl9pbmQgZm10X3Jlc3RcbiAgICAgIHwgXyAtPlxuICAgICAgICBwYXJzZV9saXRlcmFsIGxpdF9zdGFydCAoc3RyX2luZCArIDEpIGVuZF9pbmRcblxuICAoKiBQYXJzZSBhIGZvcm1hdCBhZnRlciAnJScgKilcbiAgYW5kIHBhcnNlX2Zvcm1hdCA6IHR5cGUgZSBmIC4gaW50IC0+IGludCAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBwY3RfaW5kIGVuZF9pbmQgLT4gcGFyc2VfaWduIHBjdF9pbmQgKHBjdF9pbmQgKyAxKSBlbmRfaW5kXG5cbiAgYW5kIHBhcnNlX2lnbiA6IHR5cGUgZSBmIC4gaW50IC0+IGludCAtPiBpbnQgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgLT5cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgICAgfCAnXycgLT4gcGFyc2VfZmxhZ3MgcGN0X2luZCAoc3RyX2luZCsxKSBlbmRfaW5kIHRydWVcbiAgICAgIHwgXyAtPiBwYXJzZV9mbGFncyBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCBmYWxzZVxuXG4gIGFuZCBwYXJzZV9mbGFncyA6IHR5cGUgZSBmIC4gaW50IC0+IGludCAtPiBpbnQgLT4gYm9vbCAtPiAoXywgXywgZSwgZikgZm10X2ViYlxuICA9XG4gIGZ1biBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCBpZ24gLT5cbiAgICBsZXQgemVybyA9IHJlZiBmYWxzZSBhbmQgbWludXMgPSByZWYgZmFsc2VcbiAgICBhbmQgcGx1cyA9IHJlZiBmYWxzZSBhbmQgc3BhY2UgPSByZWYgZmFsc2VcbiAgICBhbmQgaGFzaCA9IHJlZiBmYWxzZSBpblxuICAgIGxldCBzZXRfZmxhZyBzdHJfaW5kIGZsYWcgPVxuICAgICAgKCogaW4gbGVnYWN5IG1vZGUsIGR1cGxpY2F0ZSBmbGFncyBhcmUgYWNjZXB0ZWQgKilcbiAgICAgIGlmICFmbGFnICYmIG5vdCBsZWdhY3lfYmVoYXZpb3IgdGhlblxuICAgICAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICAgICAgXCJpbnZhbGlkIGZvcm1hdCAlUzogYXQgY2hhcmFjdGVyIG51bWJlciAlZCwgZHVwbGljYXRlIGZsYWcgJUNcIlxuICAgICAgICAgIHN0ciBzdHJfaW5kIHN0ci5bc3RyX2luZF07XG4gICAgICBmbGFnIDo9IHRydWU7XG4gICAgaW5cbiAgICBsZXQgcmVjIHJlYWRfZmxhZ3Mgc3RyX2luZCA9XG4gICAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgYmVnaW4gbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgICB8ICcwJyAtPiBzZXRfZmxhZyBzdHJfaW5kIHplcm87ICByZWFkX2ZsYWdzIChzdHJfaW5kICsgMSlcbiAgICAgIHwgJy0nIC0+IHNldF9mbGFnIHN0cl9pbmQgbWludXM7IHJlYWRfZmxhZ3MgKHN0cl9pbmQgKyAxKVxuICAgICAgfCAnKycgLT4gc2V0X2ZsYWcgc3RyX2luZCBwbHVzOyAgcmVhZF9mbGFncyAoc3RyX2luZCArIDEpXG4gICAgICB8ICcjJyAtPiBzZXRfZmxhZyBzdHJfaW5kIGhhc2g7IHJlYWRfZmxhZ3MgKHN0cl9pbmQgKyAxKVxuICAgICAgfCAnICcgLT4gc2V0X2ZsYWcgc3RyX2luZCBzcGFjZTsgcmVhZF9mbGFncyAoc3RyX2luZCArIDEpXG4gICAgICB8IF8gLT5cbiAgICAgICAgcGFyc2VfcGFkZGluZyBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZFxuICAgICAgICAgICF6ZXJvICFtaW51cyAhcGx1cyAhaGFzaCAhc3BhY2UgaWduXG4gICAgICBlbmRcbiAgICBpblxuICAgIHJlYWRfZmxhZ3Mgc3RyX2luZFxuXG4gICgqIFRyeSB0byByZWFkIGEgZGlnaXRhbCBvciBhICcqJyBwYWRkaW5nLiAqKVxuICBhbmQgcGFyc2VfcGFkZGluZyA6IHR5cGUgZSBmIC5cbiAgICAgIGludCAtPiBpbnQgLT4gaW50IC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+XG4gICAgICAgIChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIHplcm8gbWludXMgcGx1cyBoYXNoIHNwYWNlIGlnbiAtPlxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgbGV0IHBhZHR5ID0gbWF0Y2ggemVybywgbWludXMgd2l0aFxuICAgICAgfCBmYWxzZSwgZmFsc2UgLT4gUmlnaHRcbiAgICAgIHwgZmFsc2UsIHRydWUgIC0+IExlZnRcbiAgICAgIHwgIHRydWUsIGZhbHNlIC0+IFplcm9zXG4gICAgICB8ICB0cnVlLCB0cnVlICAtPlxuICAgICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiBMZWZ0XG4gICAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kICctJyBcIjBcIiBpblxuICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgIHwgJzAnIC4uICc5JyAtPlxuICAgICAgbGV0IG5ld19pbmQsIHdpZHRoID0gcGFyc2VfcG9zaXRpdmUgc3RyX2luZCBlbmRfaW5kIDAgaW5cbiAgICAgIHBhcnNlX2FmdGVyX3BhZGRpbmcgcGN0X2luZCBuZXdfaW5kIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlIGlnblxuICAgICAgICAoTGl0X3BhZGRpbmcgKHBhZHR5LCB3aWR0aCkpXG4gICAgfCAnKicgLT5cbiAgICAgIHBhcnNlX2FmdGVyX3BhZGRpbmcgcGN0X2luZCAoc3RyX2luZCArIDEpIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlXG4gICAgICAgIGlnbiAoQXJnX3BhZGRpbmcgcGFkdHkpXG4gICAgfCBfIC0+XG4gICAgICBiZWdpbiBtYXRjaCBwYWR0eSB3aXRoXG4gICAgICB8IExlZnQgIC0+XG4gICAgICAgIGlmIG5vdCBsZWdhY3lfYmVoYXZpb3IgdGhlblxuICAgICAgICAgIGludmFsaWRfZm9ybWF0X3dpdGhvdXQgKHN0cl9pbmQgLSAxKSAnLScgXCJwYWRkaW5nXCI7XG4gICAgICAgIHBhcnNlX2FmdGVyX3BhZGRpbmcgcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlIGlnblxuICAgICAgICAgIE5vX3BhZGRpbmdcbiAgICAgIHwgWmVyb3MgLT5cbiAgICAgICAgICgqIGEgJzAnIHBhZGRpbmcgaW5kaWNhdGlvbiBub3QgZm9sbG93ZWQgYnkgYW55dGhpbmcgc2hvdWxkXG4gICAgICAgICAgIGJlIGludGVycHJldGVkIGFzIGEgUmlnaHQgcGFkZGluZyBvZiB3aWR0aCAwLiBUaGlzIGlzIHVzZWRcbiAgICAgICAgICAgYnkgc2Nhbm5pbmcgY29udmVyc2lvbnMgJTBzIGFuZCAlMGMgKilcbiAgICAgICAgcGFyc2VfYWZ0ZXJfcGFkZGluZyBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2UgaWduXG4gICAgICAgICAgKExpdF9wYWRkaW5nIChSaWdodCwgMCkpXG4gICAgICB8IFJpZ2h0IC0+XG4gICAgICAgIHBhcnNlX2FmdGVyX3BhZGRpbmcgcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlIGlnblxuICAgICAgICAgIE5vX3BhZGRpbmdcbiAgICAgIGVuZFxuXG4gICgqIElzIHByZWNpc2lvbiBkZWZpbmVkPyAqKVxuICBhbmQgcGFyc2VfYWZ0ZXJfcGFkZGluZyA6IHR5cGUgeCBlIGYgLlxuICAgICAgaW50IC0+IGludCAtPiBpbnQgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+XG4gICAgICAgICh4LCBfKSBwYWRkaW5nIC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZSBpZ24gcGFkIC0+XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICB8ICcuJyAtPlxuICAgICAgcGFyc2VfcHJlY2lzaW9uIHBjdF9pbmQgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZSBpZ25cbiAgICAgICAgcGFkXG4gICAgfCBzeW1iIC0+XG4gICAgICBwYXJzZV9jb252ZXJzaW9uIHBjdF9pbmQgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIHBsdXMgaGFzaCBzcGFjZSBpZ24gcGFkXG4gICAgICAgIE5vX3ByZWNpc2lvbiBwYWQgc3ltYlxuXG4gICgqIFJlYWQgdGhlIGRpZ2l0YWwgb3IgJyonIHByZWNpc2lvbi4gKilcbiAgYW5kIHBhcnNlX3ByZWNpc2lvbiA6IHR5cGUgeCBlIGYgLlxuICAgICAgaW50IC0+IGludCAtPiBpbnQgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+XG4gICAgICAgICh4LCBfKSBwYWRkaW5nIC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZSBpZ24gcGFkIC0+XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICBsZXQgcGFyc2VfbGl0ZXJhbCBtaW51cyBzdHJfaW5kID1cbiAgICAgIGxldCBuZXdfaW5kLCBwcmVjID0gcGFyc2VfcG9zaXRpdmUgc3RyX2luZCBlbmRfaW5kIDAgaW5cbiAgICAgIHBhcnNlX2FmdGVyX3ByZWNpc2lvbiBwY3RfaW5kIG5ld19pbmQgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2UgaWduXG4gICAgICAgIHBhZCAoTGl0X3ByZWNpc2lvbiBwcmVjKSBpblxuICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgIHwgJzAnIC4uICc5JyAtPiBwYXJzZV9saXRlcmFsIG1pbnVzIHN0cl9pbmRcbiAgICB8ICgnKycgfCAnLScpIGFzIHN5bWIgd2hlbiBsZWdhY3lfYmVoYXZpb3IgLT5cbiAgICAgICgqIExlZ2FjeSBtb2RlIHdvdWxkIGFjY2VwdCBhbmQgaWdub3JlICcrJyBvciAnLScgYmVmb3JlIHRoZVxuICAgICAgICAgaW50ZWdlciBkZXNjcmliaW5nIHRoZSBkZXNpcmVkIHByZWNpc2lvbjsgbm90ZSB0aGF0IHRoaXNcbiAgICAgICAgIGNhbm5vdCBoYXBwZW4gZm9yIHBhZGRpbmcgd2lkdGgsIGFzICcrJyBhbmQgJy0nIGFscmVhZHkgaGF2ZVxuICAgICAgICAgYSBzZW1hbnRpY3MgdGhlcmUuXG5cbiAgICAgICAgIFRoYXQgc2FpZCwgdGhlIGlkZWEgKHN1cHBvcnRlZCBieSB0aGlzIHR3ZWFrKSB0aGF0IHdpZHRoIGFuZFxuICAgICAgICAgcHJlY2lzaW9uIGxpdGVyYWxzIGFyZSBcImludGVnZXIgbGl0ZXJhbHNcIiBpbiB0aGUgT0NhbWwgc2Vuc2UgaXNcbiAgICAgICAgIHN0aWxsIGJsYXRhbnRseSB3cm9uZywgYXMgMTIzXzQ1NiBvciAweEZGIGFyZSByZWplY3RlZC4gKilcbiAgICAgIHBhcnNlX2xpdGVyYWwgKG1pbnVzIHx8IHN5bWIgPSAnLScpIChzdHJfaW5kICsgMSlcbiAgICB8ICcqJyAtPlxuICAgICAgcGFyc2VfYWZ0ZXJfcHJlY2lzaW9uIHBjdF9pbmQgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZVxuICAgICAgICBpZ24gcGFkIEFyZ19wcmVjaXNpb25cbiAgICB8IF8gLT5cbiAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuXG4gICAgICAgICgqIG5vdGUgdGhhdCBsZWdhY3kgaW1wbGVtZW50YXRpb24gZGlkIG5vdCBpZ25vcmUgJy4nIHdpdGhvdXRcbiAgICAgICAgICAgYSBudW1iZXIgKGFzIGl0IGRvZXMgZm9yIHBhZGRpbmcgaW5kaWNhdGlvbnMpLCBidXRcbiAgICAgICAgICAgaW50ZXJwcmV0cyBpdCBhcyAnLjAnICopXG4gICAgICAgIHBhcnNlX2FmdGVyX3ByZWNpc2lvbiBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2UgaWduXG4gICAgICAgICAgcGFkIChMaXRfcHJlY2lzaW9uIDApXG4gICAgICBlbHNlXG4gICAgICAgIGludmFsaWRfZm9ybWF0X3dpdGhvdXQgKHN0cl9pbmQgLSAxKSAnLicgXCJwcmVjaXNpb25cIlxuXG4gICgqIFRyeSB0byByZWFkIHRoZSBjb252ZXJzaW9uLiAqKVxuICBhbmQgcGFyc2VfYWZ0ZXJfcHJlY2lzaW9uIDogdHlwZSB4IHkgeiB0IGUgZiAuXG4gICAgICBpbnQgLT4gaW50IC0+IGludCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT5cbiAgICAgICAgKHgsIHkpIHBhZGRpbmcgLT4gKHosIHQpIHByZWNpc2lvbiAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2UgaWduIHBhZCBwcmVjIC0+XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICBsZXQgcGFyc2VfY29udiAodHlwZSB1KSAodHlwZSB2KSAocGFkcHJlYyA6ICh1LCB2KSBwYWRkaW5nKSA9XG4gICAgICBwYXJzZV9jb252ZXJzaW9uIHBjdF9pbmQgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIHBsdXMgaGFzaCBzcGFjZSBpZ24gcGFkXG4gICAgICAgIHByZWMgcGFkcHJlYyBzdHIuW3N0cl9pbmRdIGluXG4gICAgKCogaW4gbGVnYWN5IG1vZGUsIHNvbWUgZm9ybWF0cyAoJXMgYW5kICVTKSBhY2NlcHQgYSB3ZWlyZCBtaXggb2ZcbiAgICAgICBwYWRkaW5nIGFuZCBwcmVjaXNpb24sIHdoaWNoIGlzIG1lcmdlZCBhcyBhIHNpbmdsZSBwYWRkaW5nXG4gICAgICAgaW5mb3JtYXRpb24uIEZvciBleGFtcGxlLCBpbiAlLjEwcyB0aGUgcHJlY2lzaW9uIGlzIGltcGxpY2l0bHlcbiAgICAgICB1bmRlcnN0b29kIGFzIHBhZGRpbmcgJTEwcywgYnV0IHRoZSBsZWZ0LXBhZGRpbmcgY29tcG9uZW50IG1heVxuICAgICAgIGJlIHNwZWNpZmllZCBlaXRoZXIgYXMgYSBsZWZ0IHBhZGRpbmcgb3IgYSBuZWdhdGl2ZSBwcmVjaXNpb246XG4gICAgICAgJS0uM3MgYW5kICUuLTNzIGFyZSBlcXVpdmFsZW50IHRvICUtM3MgKilcbiAgICBtYXRjaCBwYWQgd2l0aFxuICAgIHwgTm9fcGFkZGluZyAtPiAoXG4gICAgICBtYXRjaCBtaW51cywgcHJlYyB3aXRoXG4gICAgICAgIHwgXywgTm9fcHJlY2lzaW9uIC0+IHBhcnNlX2NvbnYgTm9fcGFkZGluZ1xuICAgICAgICB8IGZhbHNlLCBMaXRfcHJlY2lzaW9uIG4gLT4gcGFyc2VfY29udiAoTGl0X3BhZGRpbmcgKFJpZ2h0LCBuKSlcbiAgICAgICAgfCB0cnVlLCBMaXRfcHJlY2lzaW9uIG4gLT4gcGFyc2VfY29udiAoTGl0X3BhZGRpbmcgKExlZnQsIG4pKVxuICAgICAgICB8IGZhbHNlLCBBcmdfcHJlY2lzaW9uIC0+IHBhcnNlX2NvbnYgKEFyZ19wYWRkaW5nIFJpZ2h0KVxuICAgICAgICB8IHRydWUsIEFyZ19wcmVjaXNpb24gLT4gcGFyc2VfY29udiAoQXJnX3BhZGRpbmcgTGVmdClcbiAgICApXG4gICAgfCBwYWQgLT4gcGFyc2VfY29udiBwYWRcblxuICAoKiBDYXNlIGFuYWx5c2lzIG9uIGNvbnZlcnNpb24uICopXG4gIGFuZCBwYXJzZV9jb252ZXJzaW9uIDogdHlwZSB4IHkgeiB0IHUgdiBlIGYgLlxuICAgICAgaW50IC0+IGludCAtPiBpbnQgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiAoeCwgeSkgcGFkZGluZyAtPlxuICAgICAgICAoeiwgdCkgcHJlY2lzaW9uIC0+ICh1LCB2KSBwYWRkaW5nIC0+IGNoYXIgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgcGx1cyBoYXNoIHNwYWNlIGlnbiBwYWQgcHJlYyBwYWRwcmVjIHN5bWIgLT5cbiAgICAoKiBGbGFncyB1c2VkIHRvIGNoZWNrIG9wdGlvbiB1c2FnZXMvY29tcGF0aWJpbGl0aWVzLiAqKVxuICAgIGxldCBwbHVzX3VzZWQgID0gcmVmIGZhbHNlIGFuZCBoYXNoX3VzZWQgPSByZWYgZmFsc2VcbiAgICBhbmQgc3BhY2VfdXNlZCA9IHJlZiBmYWxzZSBhbmQgaWduX3VzZWQgICA9IHJlZiBmYWxzZVxuICAgIGFuZCBwYWRfdXNlZCAgID0gcmVmIGZhbHNlIGFuZCBwcmVjX3VzZWQgID0gcmVmIGZhbHNlIGluXG5cbiAgICAoKiBBY2Nlc3MgdG8gb3B0aW9ucywgdXBkYXRlIGZsYWdzLiAqKVxuICAgIGxldCBnZXRfcGx1cyAgICAoKSA9IHBsdXNfdXNlZCAgOj0gdHJ1ZTsgcGx1c1xuICAgIGFuZCBnZXRfaGFzaCAgICgpID0gaGFzaF91c2VkIDo9IHRydWU7IGhhc2hcbiAgICBhbmQgZ2V0X3NwYWNlICAgKCkgPSBzcGFjZV91c2VkIDo9IHRydWU7IHNwYWNlXG4gICAgYW5kIGdldF9pZ24gICAgICgpID0gaWduX3VzZWQgICA6PSB0cnVlOyBpZ25cbiAgICBhbmQgZ2V0X3BhZCAgICAgKCkgPSBwYWRfdXNlZCAgIDo9IHRydWU7IHBhZFxuICAgIGFuZCBnZXRfcHJlYyAgICAoKSA9IHByZWNfdXNlZCAgOj0gdHJ1ZTsgcHJlY1xuICAgIGFuZCBnZXRfcGFkcHJlYyAoKSA9IHBhZF91c2VkICAgOj0gdHJ1ZTsgcGFkcHJlYyBpblxuXG4gICAgbGV0IGdldF9pbnRfcGFkICgpIDogKHgseSkgcGFkZGluZyA9XG4gICAgICAoKiAlNS4zZCBpcyBhY2NlcHRlZCBhbmQgbWVhbmluZ2Z1bDogcGFkIHRvIGxlbmd0aCA1IHdpdGhcbiAgICAgICAgIHNwYWNlcywgYnV0IGZpcnN0IHBhZCB3aXRoIHplcm9zIHVwdG8gbGVuZ3RoIDMgKDAtcGFkZGluZ1xuICAgICAgICAgaXMgdGhlIGludGVycHJldGF0aW9uIG9mIFwicHJlY2lzaW9uXCIgZm9yIGludGVnZXIgZm9ybWF0cykuXG5cbiAgICAgICAgICUwNS4zZCBpcyByZWR1bmRhbnQ6IHBhZCB0byBsZW5ndGggNSAqd2l0aCB6ZXJvcyosIGJ1dFxuICAgICAgICAgZmlyc3QgcGFkIHdpdGggemVyb3MuLi4gVG8gYWRkIGluc3VsdCB0byB0aGUgaW5qdXJ5LCB0aGVcbiAgICAgICAgIGxlZ2FjeSBpbXBsZW1lbnRhdGlvbiBpZ25vcmVzIHRoZSAwLXBhZGRpbmcgaW5kaWNhdGlvbiBhbmRcbiAgICAgICAgIGRvZXMgdGhlIDUgcGFkZGluZyB3aXRoIHNwYWNlcyBpbnN0ZWFkLiBXZSByZXVzZSB0aGlzXG4gICAgICAgICBpbnRlcnByZXRhdGlvbiBmb3IgY29tcGF0aWJpbGl0eSwgYnV0IHN0YXRpY2FsbHkgcmVqZWN0IHRoaXNcbiAgICAgICAgIGZvcm1hdCB3aGVuIHRoZSBsZWdhY3kgbW9kZSBpcyBkaXNhYmxlZCwgdG8gcHJvdGVjdCBzdHJpY3RcbiAgICAgICAgIHVzZXJzIGZyb20gdGhpcyBjb3JuZXIgY2FzZS4gKilcbiAgICAgICBtYXRjaCBnZXRfcGFkICgpLCBnZXRfcHJlYyAoKSB3aXRoXG4gICAgICAgICB8IHBhZCwgTm9fcHJlY2lzaW9uIC0+IHBhZFxuICAgICAgICAgfCBOb19wYWRkaW5nLCBfICAgICAtPiBOb19wYWRkaW5nXG4gICAgICAgICB8IExpdF9wYWRkaW5nIChaZXJvcywgbiksIF8gLT5cbiAgICAgICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW4gTGl0X3BhZGRpbmcgKFJpZ2h0LCBuKVxuICAgICAgICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCAnMCcgXCJwcmVjaXNpb25cIlxuICAgICAgICAgfCBBcmdfcGFkZGluZyBaZXJvcywgXyAtPlxuICAgICAgICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiBBcmdfcGFkZGluZyBSaWdodFxuICAgICAgICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCAnMCcgXCJwcmVjaXNpb25cIlxuICAgICAgICAgfCBMaXRfcGFkZGluZyBfIGFzIHBhZCwgXyAtPiBwYWRcbiAgICAgICAgIHwgQXJnX3BhZGRpbmcgXyBhcyBwYWQsIF8gLT4gcGFkIGluXG5cbiAgICAoKiBDaGVjayB0aGF0IHBhZHR5IDw+IFplcm9zLiAqKVxuICAgIGxldCBjaGVja19ub18wIHN5bWIgKHR5cGUgYSBiKSAocGFkIDogKGEsIGIpIHBhZGRpbmcpIDogKGEsYikgcGFkZGluZyA9XG4gICAgICBtYXRjaCBwYWQgd2l0aFxuICAgICAgfCBOb19wYWRkaW5nIC0+IHBhZFxuICAgICAgfCBMaXRfcGFkZGluZyAoKExlZnQgfCBSaWdodCksIF8pIC0+IHBhZFxuICAgICAgfCBBcmdfcGFkZGluZyAoTGVmdCB8IFJpZ2h0KSAtPiBwYWRcbiAgICAgIHwgTGl0X3BhZGRpbmcgKFplcm9zLCB3aWR0aCkgLT5cbiAgICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW4gTGl0X3BhZGRpbmcgKFJpZ2h0LCB3aWR0aClcbiAgICAgICAgZWxzZSBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgc3ltYiBcIjBcIlxuICAgICAgfCBBcmdfcGFkZGluZyBaZXJvcyAtPlxuICAgICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiBBcmdfcGFkZGluZyBSaWdodFxuICAgICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiMFwiXG4gICAgaW5cblxuICAgICgqIEdldCBwYWRkaW5nIGFzIGEgcGFkX29wdGlvbiAoc2VlIFwiJV9cIiwgXCIle1wiLCBcIiUoXCIgYW5kIFwiJVtcIikuXG4gICAgICAgKG5vIG5lZWQgZm9yIGxlZ2FjeSBtb2RlIHR3ZWFraW5nLCB0aG9zZSB3ZXJlIHJlamVjdGVkIGJ5IHRoZVxuICAgICAgIGxlZ2FjeSBwYXJzZXIgYXMgd2VsbCkgKilcbiAgICBsZXQgb3B0X29mX3BhZCBjICh0eXBlIGEpICh0eXBlIGIpIChwYWQgOiAoYSwgYikgcGFkZGluZykgPSBtYXRjaCBwYWQgd2l0aFxuICAgICAgfCBOb19wYWRkaW5nIC0+IE5vbmVcbiAgICAgIHwgTGl0X3BhZGRpbmcgKFJpZ2h0LCB3aWR0aCkgLT4gU29tZSB3aWR0aFxuICAgICAgfCBMaXRfcGFkZGluZyAoWmVyb3MsIHdpZHRoKSAtPlxuICAgICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiBTb21lIHdpZHRoXG4gICAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIGMgXCInMCdcIlxuICAgICAgfCBMaXRfcGFkZGluZyAoTGVmdCwgd2lkdGgpIC0+XG4gICAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuIFNvbWUgd2lkdGhcbiAgICAgICAgZWxzZSBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgYyBcIictJ1wiXG4gICAgICB8IEFyZ19wYWRkaW5nIF8gLT4gaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIGMgXCInKidcIlxuICAgIGluXG4gICAgbGV0IGdldF9wYWRfb3B0IGMgPSBvcHRfb2ZfcGFkIGMgKGdldF9wYWQgKCkpIGluXG4gICAgbGV0IGdldF9wYWRwcmVjX29wdCBjID0gb3B0X29mX3BhZCBjIChnZXRfcGFkcHJlYyAoKSkgaW5cblxuICAgICgqIEdldCBwcmVjaXNpb24gYXMgYSBwcmVjX29wdGlvbiAoc2VlIFwiJV9mXCIpLlxuICAgICAgIChubyBuZWVkIGZvciBsZWdhY3kgbW9kZSB0d2Vha2luZywgdGhvc2Ugd2VyZSByZWplY3RlZCBieSB0aGVcbiAgICAgICBsZWdhY3kgcGFyc2VyIGFzIHdlbGwpICopXG4gICAgbGV0IGdldF9wcmVjX29wdCAoKSA9IG1hdGNoIGdldF9wcmVjICgpIHdpdGhcbiAgICAgIHwgTm9fcHJlY2lzaW9uICAgICAgIC0+IE5vbmVcbiAgICAgIHwgTGl0X3ByZWNpc2lvbiBuZGVjIC0+IFNvbWUgbmRlY1xuICAgICAgfCBBcmdfcHJlY2lzaW9uICAgICAgLT4gaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kICdfJyBcIicqJ1wiXG4gICAgaW5cblxuICAgIGxldCBmbXRfcmVzdWx0ID0gbWF0Y2ggc3ltYiB3aXRoXG4gICAgfCAnLCcgLT5cbiAgICAgIHBhcnNlIHN0cl9pbmQgZW5kX2luZFxuICAgIHwgJ2MnIC0+XG4gICAgICBsZXQgY2hhcl9mb3JtYXQgZm10X3Jlc3QgPSAoKiAlYyAqKVxuICAgICAgICBpZiBnZXRfaWduICgpXG4gICAgICAgIHRoZW4gRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoSWdub3JlZF9jaGFyLCBmbXRfcmVzdCkpXG4gICAgICAgIGVsc2UgRm10X0VCQiAoQ2hhciBmbXRfcmVzdClcbiAgICAgIGluXG4gICAgICBsZXQgc2Nhbl9mb3JtYXQgZm10X3Jlc3QgPSAoKiAlMGMgKilcbiAgICAgICAgaWYgZ2V0X2lnbiAoKVxuICAgICAgICB0aGVuIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKElnbm9yZWRfc2Nhbl9uZXh0X2NoYXIsIGZtdF9yZXN0KSlcbiAgICAgICAgZWxzZSBGbXRfRUJCIChTY2FuX25leHRfY2hhciBmbXRfcmVzdClcbiAgICAgIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgYmVnaW4gbWF0Y2ggZ2V0X3BhZF9vcHQgJ2MnIHdpdGhcbiAgICAgICAgfCBOb25lIC0+IGNoYXJfZm9ybWF0IGZtdF9yZXN0XG4gICAgICAgIHwgU29tZSAwIC0+IHNjYW5fZm9ybWF0IGZtdF9yZXN0XG4gICAgICAgIHwgU29tZSBfbiAtPlxuICAgICAgICAgICBpZiBub3QgbGVnYWN5X2JlaGF2aW9yXG4gICAgICAgICAgIHRoZW4gaW52YWxpZF9ub25udWxsX2NoYXJfd2lkdGggc3RyX2luZFxuICAgICAgICAgICBlbHNlICgqIGxlZ2FjeSBpZ25vcmVzICVjIHdpZHRocyAqKSBjaGFyX2Zvcm1hdCBmbXRfcmVzdFxuICAgICAgZW5kXG4gICAgfCAnQycgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW4gRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoSWdub3JlZF9jYW1sX2NoYXIsZm10X3Jlc3QpKVxuICAgICAgZWxzZSBGbXRfRUJCIChDYW1sX2NoYXIgZm10X3Jlc3QpXG4gICAgfCAncycgLT5cbiAgICAgIGxldCBwYWQgPSBjaGVja19ub18wIHN5bWIgKGdldF9wYWRwcmVjICgpKSBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfc3RyaW5nIChnZXRfcGFkcHJlY19vcHQgJ18nKSBpblxuICAgICAgICBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChpZ25vcmVkLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlXG4gICAgICAgIGxldCBQYWRkaW5nX2ZtdF9FQkIgKHBhZCcsIGZtdF9yZXN0JykgPVxuICAgICAgICAgIG1ha2VfcGFkZGluZ19mbXRfZWJiIHBhZCBmbXRfcmVzdCBpblxuICAgICAgICBGbXRfRUJCIChTdHJpbmcgKHBhZCcsIGZtdF9yZXN0JykpXG4gICAgfCAnUycgLT5cbiAgICAgIGxldCBwYWQgPSBjaGVja19ub18wIHN5bWIgKGdldF9wYWRwcmVjICgpKSBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfY2FtbF9zdHJpbmcgKGdldF9wYWRwcmVjX29wdCAnXycpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IFBhZGRpbmdfZm10X0VCQiAocGFkJywgZm10X3Jlc3QnKSA9XG4gICAgICAgICAgbWFrZV9wYWRkaW5nX2ZtdF9lYmIgcGFkIGZtdF9yZXN0IGluXG4gICAgICAgIEZtdF9FQkIgKENhbWxfc3RyaW5nIChwYWQnLCBmbXRfcmVzdCcpKVxuICAgIHwgJ2QnIHwgJ2knIHwgJ3gnIHwgJ1gnIHwgJ28nIHwgJ3UnIC0+XG4gICAgICBsZXQgaWNvbnYgPSBjb21wdXRlX2ludF9jb252IHBjdF9pbmQgc3RyX2luZCAoZ2V0X3BsdXMgKCkpIChnZXRfaGFzaCAoKSlcbiAgICAgICAgKGdldF9zcGFjZSAoKSkgc3ltYiBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfaW50IChpY29udiwgZ2V0X3BhZF9vcHQgJ18nKSBpblxuICAgICAgICBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChpZ25vcmVkLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlXG4gICAgICAgIGxldCBQYWRwcmVjX2ZtdF9FQkIgKHBhZCcsIHByZWMnLCBmbXRfcmVzdCcpID1cbiAgICAgICAgICBtYWtlX3BhZHByZWNfZm10X2ViYiAoZ2V0X2ludF9wYWQgKCkpIChnZXRfcHJlYyAoKSkgZm10X3Jlc3QgaW5cbiAgICAgICAgRm10X0VCQiAoSW50IChpY29udiwgcGFkJywgcHJlYycsIGZtdF9yZXN0JykpXG4gICAgfCAnTicgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBsZXQgY291bnRlciA9IFRva2VuX2NvdW50ZXIgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfc2Nhbl9nZXRfY291bnRlciBjb3VudGVyIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgRm10X0VCQiAoU2Nhbl9nZXRfY291bnRlciAoY291bnRlciwgZm10X3Jlc3QpKVxuICAgIHwgJ2wnIHwgJ24nIHwgJ0wnIHdoZW4gc3RyX2luZD1lbmRfaW5kIHx8IG5vdCAoaXNfaW50X2Jhc2Ugc3RyLltzdHJfaW5kXSkgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBsZXQgY291bnRlciA9IGNvdW50ZXJfb2ZfY2hhciBzeW1iIGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBJZ25vcmVkX3NjYW5fZ2V0X2NvdW50ZXIgY291bnRlciBpblxuICAgICAgICBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChpZ25vcmVkLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlXG4gICAgICAgIEZtdF9FQkIgKFNjYW5fZ2V0X2NvdW50ZXIgKGNvdW50ZXIsIGZtdF9yZXN0KSlcbiAgICB8ICdsJyAtPlxuICAgICAgbGV0IGljb252ID1cbiAgICAgICAgY29tcHV0ZV9pbnRfY29udiBwY3RfaW5kIChzdHJfaW5kICsgMSkgKGdldF9wbHVzICgpKSAoZ2V0X2hhc2ggKCkpXG4gICAgICAgICAgKGdldF9zcGFjZSAoKSkgc3RyLltzdHJfaW5kXSBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfaW50MzIgKGljb252LCBnZXRfcGFkX29wdCAnXycpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IFBhZHByZWNfZm10X0VCQiAocGFkJywgcHJlYycsIGZtdF9yZXN0JykgPVxuICAgICAgICAgIG1ha2VfcGFkcHJlY19mbXRfZWJiIChnZXRfaW50X3BhZCAoKSkgKGdldF9wcmVjICgpKSBmbXRfcmVzdCBpblxuICAgICAgICBGbXRfRUJCIChJbnQzMiAoaWNvbnYsIHBhZCcsIHByZWMnLCBmbXRfcmVzdCcpKVxuICAgIHwgJ24nIC0+XG4gICAgICBsZXQgaWNvbnYgPVxuICAgICAgICBjb21wdXRlX2ludF9jb252IHBjdF9pbmQgKHN0cl9pbmQgKyAxKSAoZ2V0X3BsdXMgKCkpXG4gICAgICAgICAgKGdldF9oYXNoICgpKSAoZ2V0X3NwYWNlICgpKSBzdHIuW3N0cl9pbmRdIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9uYXRpdmVpbnQgKGljb252LCBnZXRfcGFkX29wdCAnXycpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IFBhZHByZWNfZm10X0VCQiAocGFkJywgcHJlYycsIGZtdF9yZXN0JykgPVxuICAgICAgICAgIG1ha2VfcGFkcHJlY19mbXRfZWJiIChnZXRfaW50X3BhZCAoKSkgKGdldF9wcmVjICgpKSBmbXRfcmVzdCBpblxuICAgICAgICBGbXRfRUJCIChOYXRpdmVpbnQgKGljb252LCBwYWQnLCBwcmVjJywgZm10X3Jlc3QnKSlcbiAgICB8ICdMJyAtPlxuICAgICAgbGV0IGljb252ID1cbiAgICAgICAgY29tcHV0ZV9pbnRfY29udiBwY3RfaW5kIChzdHJfaW5kICsgMSkgKGdldF9wbHVzICgpKSAoZ2V0X2hhc2ggKCkpXG4gICAgICAgICAgKGdldF9zcGFjZSAoKSkgc3RyLltzdHJfaW5kXSBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfaW50NjQgKGljb252LCBnZXRfcGFkX29wdCAnXycpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IFBhZHByZWNfZm10X0VCQiAocGFkJywgcHJlYycsIGZtdF9yZXN0JykgPVxuICAgICAgICAgIG1ha2VfcGFkcHJlY19mbXRfZWJiIChnZXRfaW50X3BhZCAoKSkgKGdldF9wcmVjICgpKSBmbXRfcmVzdCBpblxuICAgICAgICBGbXRfRUJCIChJbnQ2NCAoaWNvbnYsIHBhZCcsIHByZWMnLCBmbXRfcmVzdCcpKVxuICAgIHwgJ2YnIHwgJ2UnIHwgJ0UnIHwgJ2cnIHwgJ0cnIHwgJ0YnIHwgJ2gnIHwgJ0gnIC0+XG4gICAgICBsZXQgZmNvbnYgPVxuICAgICAgICBjb21wdXRlX2Zsb2F0X2NvbnYgcGN0X2luZCBzdHJfaW5kXG4gICAgICAgICAgKGdldF9wbHVzICgpKSAoZ2V0X2hhc2ggKCkpIChnZXRfc3BhY2UgKCkpIHN5bWIgaW5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBJZ25vcmVkX2Zsb2F0IChnZXRfcGFkX29wdCAnXycsIGdldF9wcmVjX29wdCAoKSkgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBsZXQgUGFkcHJlY19mbXRfRUJCIChwYWQnLCBwcmVjJywgZm10X3Jlc3QnKSA9XG4gICAgICAgICAgbWFrZV9wYWRwcmVjX2ZtdF9lYmIgKGdldF9wYWQgKCkpIChnZXRfcHJlYyAoKSkgZm10X3Jlc3QgaW5cbiAgICAgICAgRm10X0VCQiAoRmxvYXQgKGZjb252LCBwYWQnLCBwcmVjJywgZm10X3Jlc3QnKSlcbiAgICB8ICdiJyB8ICdCJyAtPlxuICAgICAgbGV0IHBhZCA9IGNoZWNrX25vXzAgc3ltYiAoZ2V0X3BhZHByZWMgKCkpIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9ib29sIChnZXRfcGFkcHJlY19vcHQgJ18nKSBpblxuICAgICAgICBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChpZ25vcmVkLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlXG4gICAgICAgIGxldCBQYWRkaW5nX2ZtdF9FQkIgKHBhZCcsIGZtdF9yZXN0JykgPVxuICAgICAgICAgIG1ha2VfcGFkZGluZ19mbXRfZWJiIHBhZCBmbXRfcmVzdCBpblxuICAgICAgICBGbXRfRUJCIChCb29sIChwYWQnLCBmbXRfcmVzdCcpKVxuICAgIHwgJ2EnIC0+XG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgRm10X0VCQiAoQWxwaGEgZm10X3Jlc3QpXG4gICAgfCAndCcgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBGbXRfRUJCIChUaGV0YSBmbXRfcmVzdClcbiAgICB8ICdyJyAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlbiBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChJZ25vcmVkX3JlYWRlciwgZm10X3Jlc3QpKVxuICAgICAgZWxzZSBGbXRfRUJCIChSZWFkZXIgZm10X3Jlc3QpXG4gICAgfCAnIScgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBGbXRfRUJCIChGbHVzaCBmbXRfcmVzdClcbiAgICB8ICgnJScgfCAnQCcpIGFzIGMgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBGbXRfRUJCIChDaGFyX2xpdGVyYWwgKGMsIGZtdF9yZXN0KSlcbiAgICB8ICd7JyAtPlxuICAgICAgbGV0IHN1Yl9lbmQgPSBzZWFyY2hfc3ViZm9ybWF0X2VuZCBzdHJfaW5kIGVuZF9pbmQgJ30nIGluXG4gICAgICBsZXQgRm10X0VCQiBzdWJfZm10ID0gcGFyc2Ugc3RyX2luZCBzdWJfZW5kIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdWJfZW5kICsgMikgZW5kX2luZCBpblxuICAgICAgbGV0IHN1Yl9mbXR0eSA9IGZtdHR5X29mX2ZtdCBzdWJfZm10IGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBJZ25vcmVkX2Zvcm1hdF9hcmcgKGdldF9wYWRfb3B0ICdfJywgc3ViX2ZtdHR5KSBpblxuICAgICAgICBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChpZ25vcmVkLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdF9hcmcgKGdldF9wYWRfb3B0ICd7Jywgc3ViX2ZtdHR5LCBmbXRfcmVzdCkpXG4gICAgfCAnKCcgLT5cbiAgICAgIGxldCBzdWJfZW5kID0gc2VhcmNoX3N1YmZvcm1hdF9lbmQgc3RyX2luZCBlbmRfaW5kICcpJyBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3ViX2VuZCArIDIpIGVuZF9pbmQgaW5cbiAgICAgIGxldCBGbXRfRUJCIHN1Yl9mbXQgPSBwYXJzZSBzdHJfaW5kIHN1Yl9lbmQgaW5cbiAgICAgIGxldCBzdWJfZm10dHkgPSBmbXR0eV9vZl9mbXQgc3ViX2ZtdCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9mb3JtYXRfc3Vic3QgKGdldF9wYWRfb3B0ICdfJywgc3ViX2ZtdHR5KSBpblxuICAgICAgICBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChpZ25vcmVkLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdF9zdWJzdCAoZ2V0X3BhZF9vcHQgJygnLCBzdWJfZm10dHksIGZtdF9yZXN0KSlcbiAgICB8ICdbJyAtPlxuICAgICAgbGV0IG5leHRfaW5kLCBjaGFyX3NldCA9IHBhcnNlX2NoYXJfc2V0IHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBuZXh0X2luZCBlbmRfaW5kIGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBJZ25vcmVkX3NjYW5fY2hhcl9zZXQgKGdldF9wYWRfb3B0ICdfJywgY2hhcl9zZXQpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgRm10X0VCQiAoU2Nhbl9jaGFyX3NldCAoZ2V0X3BhZF9vcHQgJ1snLCBjaGFyX3NldCwgZm10X3Jlc3QpKVxuICAgIHwgJy0nIHwgJysnIHwgJyMnIHwgJyAnIHwgJ18nIC0+XG4gICAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICAgIFwiaW52YWxpZCBmb3JtYXQgJVM6IGF0IGNoYXJhY3RlciBudW1iZXIgJWQsIFxcXG4gICAgICAgICBmbGFnICVDIGlzIG9ubHkgYWxsb3dlZCBhZnRlciB0aGUgJyUlJywgYmVmb3JlIHBhZGRpbmcgYW5kIHByZWNpc2lvblwiXG4gICAgICAgIHN0ciBwY3RfaW5kIHN5bWJcbiAgICB8IF8gLT5cbiAgICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgICAgXCJpbnZhbGlkIGZvcm1hdCAlUzogYXQgY2hhcmFjdGVyIG51bWJlciAlZCwgXFxcbiAgICAgICAgIGludmFsaWQgY29udmVyc2lvbiBcXFwiJSUlY1xcXCJcIiBzdHIgKHN0cl9pbmQgLSAxKSBzeW1iXG4gICAgaW5cbiAgICAoKiBDaGVjayBmb3IgdW51c2VkIG9wdGlvbnMsIGFuZCByZWplY3QgdGhlbSBhcyBpbmNvbXBhdGlibGUuXG5cbiAgICAgICBTdWNoIGNoZWNrcyBuZWVkIHRvIGJlIGRpc2FibGVkIGluIGxlZ2FjeSBtb2RlLCBhcyB0aGUgbGVnYWN5XG4gICAgICAgcGFyc2VyIHNpbGVudGx5IGlnbm9yZWQgaW5jb21wYXRpYmxlIGZsYWdzLiAqKVxuICAgIGlmIG5vdCBsZWdhY3lfYmVoYXZpb3IgdGhlbiBiZWdpblxuICAgIGlmIG5vdCAhcGx1c191c2VkICYmIHBsdXMgdGhlblxuICAgICAgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIHN5bWIgXCInKydcIjtcbiAgICBpZiBub3QgIWhhc2hfdXNlZCAmJiBoYXNoIHRoZW5cbiAgICAgIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiJyMnXCI7XG4gICAgaWYgbm90ICFzcGFjZV91c2VkICYmIHNwYWNlIHRoZW5cbiAgICAgIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiJyAnXCI7XG4gICAgaWYgbm90ICFwYWRfdXNlZCAgJiYgUGFkZGluZ19FQkIgcGFkIDw+IFBhZGRpbmdfRUJCIE5vX3BhZGRpbmcgdGhlblxuICAgICAgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIHN5bWIgXCJgcGFkZGluZydcIjtcbiAgICBpZiBub3QgIXByZWNfdXNlZCAmJiBQcmVjaXNpb25fRUJCIHByZWMgPD4gUHJlY2lzaW9uX0VCQiBOb19wcmVjaXNpb24gdGhlblxuICAgICAgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIChpZiBpZ24gdGhlbiAnXycgZWxzZSBzeW1iKVxuICAgICAgICBcImBwcmVjaXNpb24nXCI7XG4gICAgaWYgaWduICYmIHBsdXMgdGhlbiBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgJ18nIFwiJysnXCI7XG4gICAgZW5kO1xuICAgICgqIHRoaXMgbGFzdCB0ZXN0IG11c3Qgbm90IGJlIGRpc2FibGVkIGluIGxlZ2FjeSBtb2RlLFxuICAgICAgIGFzIGlnbm9yaW5nIGl0IHdvdWxkIHR5cGljYWxseSByZXN1bHQgaW4gYSBkaWZmZXJlbnQgdHlwaW5nXG4gICAgICAgdGhhbiB3aGF0IHRoZSBsZWdhY3kgcGFyc2VyIHVzZWQgKilcbiAgICBpZiBub3QgIWlnbl91c2VkICYmIGlnbiB0aGVuXG4gICAgICBiZWdpbiBtYXRjaCBzeW1iIHdpdGhcbiAgICAgICAgKCogYXJndW1lbnQtbGVzcyBmb3JtYXRzIGNhbiBzYWZlbHkgYmUgaWdub3JlZCBpbiBsZWdhY3kgbW9kZSAqKVxuICAgICAgICB8ICgnQCcgfCAnJScgfCAnIScgfCAnLCcpIHdoZW4gbGVnYWN5X2JlaGF2aW9yIC0+ICgpXG4gICAgICAgIHwgXyAtPlxuICAgICAgICAgIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiJ18nXCJcbiAgICAgIGVuZDtcbiAgICBmbXRfcmVzdWx0XG5cbiAgKCogUGFyc2UgZm9ybWF0dGluZyBpbmZvcm1hdGlvbiAoYWZ0ZXIgJ0AnKS4gKilcbiAgYW5kIHBhcnNlX2FmdGVyX2F0IDogdHlwZSBlIGYgLiBpbnQgLT4gaW50IC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIHN0cl9pbmQgZW5kX2luZCAtPlxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gRm10X0VCQiAoQ2hhcl9saXRlcmFsICgnQCcsIEVuZF9vZl9mb3JtYXQpKVxuICAgIGVsc2VcbiAgICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgICAgfCAnWycgLT5cbiAgICAgICAgcGFyc2VfdGFnIGZhbHNlIChzdHJfaW5kICsgMSkgZW5kX2luZFxuICAgICAgfCAnXScgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKENsb3NlX2JveCwgZm10X3Jlc3QpKVxuICAgICAgfCAneycgLT5cbiAgICAgICAgcGFyc2VfdGFnIHRydWUgKHN0cl9pbmQgKyAxKSBlbmRfaW5kXG4gICAgICB8ICd9JyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoQ2xvc2VfdGFnLCBmbXRfcmVzdCkpXG4gICAgICB8ICcsJyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoQnJlYWsgKFwiQCxcIiwgMCwgMCksIGZtdF9yZXN0KSlcbiAgICAgIHwgJyAnIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChCcmVhayAoXCJAIFwiLCAxLCAwKSwgZm10X3Jlc3QpKVxuICAgICAgfCAnOycgLT5cbiAgICAgICAgcGFyc2VfZ29vZF9icmVhayAoc3RyX2luZCArIDEpIGVuZF9pbmRcbiAgICAgIHwgJz8nIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChGRmx1c2gsIGZtdF9yZXN0KSlcbiAgICAgIHwgJ1xcbicgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKEZvcmNlX25ld2xpbmUsIGZtdF9yZXN0KSlcbiAgICAgIHwgJy4nIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChGbHVzaF9uZXdsaW5lLCBmbXRfcmVzdCkpXG4gICAgICB8ICc8JyAtPlxuICAgICAgICBwYXJzZV9tYWdpY19zaXplIChzdHJfaW5kICsgMSkgZW5kX2luZFxuICAgICAgfCAnQCcgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKEVzY2FwZWRfYXQsIGZtdF9yZXN0KSlcbiAgICAgIHwgJyUnIHdoZW4gc3RyX2luZCArIDEgPCBlbmRfaW5kICYmIHN0ci5bc3RyX2luZCArIDFdID0gJyUnIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAyKSBlbmRfaW5kIGluXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChFc2NhcGVkX3BlcmNlbnQsIGZtdF9yZXN0KSlcbiAgICAgIHwgJyUnIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICAgIEZtdF9FQkIgKENoYXJfbGl0ZXJhbCAoJ0AnLCBmbXRfcmVzdCkpXG4gICAgICB8IGMgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKFNjYW5faW5kaWMgYywgZm10X3Jlc3QpKVxuXG4gICgqIFRyeSB0byByZWFkIHRoZSBvcHRpb25hbCA8bmFtZT4gYWZ0ZXIgXCJAe1wiIG9yIFwiQFtcIi4gKilcbiAgYW5kIHBhcnNlX3RhZyA6IHR5cGUgZSBmIC4gYm9vbCAtPiBpbnQgLT4gaW50IC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIGlzX29wZW5fdGFnIHN0cl9pbmQgZW5kX2luZCAtPlxuICAgIHRyeVxuICAgICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiByYWlzZSBOb3RfZm91bmQ7XG4gICAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICAgIHwgJzwnIC0+XG4gICAgICAgIGxldCBpbmQgPSBTdHJpbmcuaW5kZXhfZnJvbSBzdHIgKHN0cl9pbmQgKyAxKSAnPicgaW5cbiAgICAgICAgaWYgaW5kID49IGVuZF9pbmQgdGhlbiByYWlzZSBOb3RfZm91bmQ7XG4gICAgICAgIGxldCBzdWJfc3RyID0gU3RyaW5nLnN1YiBzdHIgc3RyX2luZCAoaW5kIC0gc3RyX2luZCArIDEpIGluXG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKGluZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgbGV0IEZtdF9FQkIgc3ViX2ZtdCA9IHBhcnNlIHN0cl9pbmQgKGluZCArIDEpIGluXG4gICAgICAgIGxldCBzdWJfZm9ybWF0ID0gRm9ybWF0IChzdWJfZm10LCBzdWJfc3RyKSBpblxuICAgICAgICBsZXQgZm9ybWF0dGluZyA9XG4gICAgICAgICAgaWYgaXNfb3Blbl90YWcgdGhlbiBPcGVuX3RhZyBzdWJfZm9ybWF0IGVsc2UgT3Blbl9ib3ggc3ViX2Zvcm1hdCBpblxuICAgICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2dlbiAoZm9ybWF0dGluZywgZm10X3Jlc3QpKVxuICAgICAgfCBfIC0+XG4gICAgICAgIHJhaXNlIE5vdF9mb3VuZFxuICAgIHdpdGggTm90X2ZvdW5kIC0+XG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgbGV0IHN1Yl9mb3JtYXQgPSBGb3JtYXQgKEVuZF9vZl9mb3JtYXQsIFwiXCIpIGluXG4gICAgICBsZXQgZm9ybWF0dGluZyA9XG4gICAgICAgIGlmIGlzX29wZW5fdGFnIHRoZW4gT3Blbl90YWcgc3ViX2Zvcm1hdCBlbHNlIE9wZW5fYm94IHN1Yl9mb3JtYXQgaW5cbiAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfZ2VuIChmb3JtYXR0aW5nLCBmbXRfcmVzdCkpXG5cbiAgKCogVHJ5IHRvIHJlYWQgdGhlIG9wdGlvbmFsIDx3aWR0aCBvZmZzZXQ+IGFmdGVyIFwiQDtcIi4gKilcbiAgYW5kIHBhcnNlX2dvb2RfYnJlYWsgOiB0eXBlIGUgZiAuIGludCAtPiBpbnQgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gc3RyX2luZCBlbmRfaW5kIC0+XG4gICAgbGV0IG5leHRfaW5kLCBmb3JtYXR0aW5nX2xpdCA9XG4gICAgICB0cnlcbiAgICAgICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgfHwgc3RyLltzdHJfaW5kXSA8PiAnPCcgdGhlbiByYWlzZSBOb3RfZm91bmQ7XG4gICAgICAgIGxldCBzdHJfaW5kXzEgPSBwYXJzZV9zcGFjZXMgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICAgIG1hdGNoIHN0ci5bc3RyX2luZF8xXSB3aXRoXG4gICAgICAgIHwgJzAnIC4uICc5JyB8ICctJyAtPiAoXG4gICAgICAgICAgbGV0IHN0cl9pbmRfMiwgd2lkdGggPSBwYXJzZV9pbnRlZ2VyIHN0cl9pbmRfMSBlbmRfaW5kIGluXG4gICAgICAgICAgICBsZXQgc3RyX2luZF8zID0gcGFyc2Vfc3BhY2VzIHN0cl9pbmRfMiBlbmRfaW5kIGluXG4gICAgICAgICAgICBtYXRjaCBzdHIuW3N0cl9pbmRfM10gd2l0aFxuICAgICAgICAgICAgICB8ICc+JyAtPlxuICAgICAgICAgICAgICAgIGxldCBzID0gU3RyaW5nLnN1YiBzdHIgKHN0cl9pbmQtMikgKHN0cl9pbmRfMy1zdHJfaW5kKzMpIGluXG4gICAgICAgICAgICAgICAgc3RyX2luZF8zICsgMSwgQnJlYWsgKHMsIHdpZHRoLCAwKVxuICAgICAgICAgICAgICB8ICcwJyAuLiAnOScgfCAnLScgLT5cbiAgICAgICAgICAgICAgICBsZXQgc3RyX2luZF80LCBvZmZzZXQgPSBwYXJzZV9pbnRlZ2VyIHN0cl9pbmRfMyBlbmRfaW5kIGluXG4gICAgICAgICAgICAgICAgbGV0IHN0cl9pbmRfNSA9IHBhcnNlX3NwYWNlcyBzdHJfaW5kXzQgZW5kX2luZCBpblxuICAgICAgICAgICAgICAgIGlmIHN0ci5bc3RyX2luZF81XSA8PiAnPicgdGhlbiByYWlzZSBOb3RfZm91bmQ7XG4gICAgICAgICAgICAgICAgbGV0IHMgPSBTdHJpbmcuc3ViIHN0ciAoc3RyX2luZC0yKSAoc3RyX2luZF81LXN0cl9pbmQrMykgaW5cbiAgICAgICAgICAgICAgICBzdHJfaW5kXzUgKyAxLCBCcmVhayAocywgd2lkdGgsIG9mZnNldClcbiAgICAgICAgICAgICAgfCBfIC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgICApXG4gICAgICAgIHwgXyAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgIHdpdGggTm90X2ZvdW5kIHwgRmFpbHVyZSBfIC0+XG4gICAgICAgIHN0cl9pbmQsIEJyZWFrIChcIkA7XCIsIDEsIDApXG4gICAgaW5cbiAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIG5leHRfaW5kIGVuZF9pbmQgaW5cbiAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoZm9ybWF0dGluZ19saXQsIGZtdF9yZXN0KSlcblxuICAoKiBQYXJzZSB0aGUgc2l6ZSBpbiBhIDxuPi4gKilcbiAgYW5kIHBhcnNlX21hZ2ljX3NpemUgOiB0eXBlIGUgZiAuIGludCAtPiBpbnQgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gc3RyX2luZCBlbmRfaW5kIC0+XG4gICAgbWF0Y2hcbiAgICAgIHRyeVxuICAgICAgICBsZXQgc3RyX2luZF8xID0gcGFyc2Vfc3BhY2VzIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgICBtYXRjaCBzdHIuW3N0cl9pbmRfMV0gd2l0aFxuICAgICAgICB8ICcwJyAuLiAnOScgfCAnLScgLT5cbiAgICAgICAgICBsZXQgc3RyX2luZF8yLCBzaXplID0gcGFyc2VfaW50ZWdlciBzdHJfaW5kXzEgZW5kX2luZCBpblxuICAgICAgICAgIGxldCBzdHJfaW5kXzMgPSBwYXJzZV9zcGFjZXMgc3RyX2luZF8yIGVuZF9pbmQgaW5cbiAgICAgICAgICBpZiBzdHIuW3N0cl9pbmRfM10gPD4gJz4nIHRoZW4gcmFpc2UgTm90X2ZvdW5kO1xuICAgICAgICAgIGxldCBzID0gU3RyaW5nLnN1YiBzdHIgKHN0cl9pbmQgLSAyKSAoc3RyX2luZF8zIC0gc3RyX2luZCArIDMpIGluXG4gICAgICAgICAgU29tZSAoc3RyX2luZF8zICsgMSwgTWFnaWNfc2l6ZSAocywgc2l6ZSkpXG4gICAgICAgIHwgXyAtPiBOb25lXG4gICAgICB3aXRoIE5vdF9mb3VuZCB8IEZhaWx1cmUgXyAtPlxuICAgICAgICBOb25lXG4gICAgd2l0aFxuICAgIHwgU29tZSAobmV4dF9pbmQsIGZvcm1hdHRpbmdfbGl0KSAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBuZXh0X2luZCBlbmRfaW5kIGluXG4gICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoZm9ybWF0dGluZ19saXQsIGZtdF9yZXN0KSlcbiAgICB8IE5vbmUgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoU2Nhbl9pbmRpYyAnPCcsIGZtdF9yZXN0KSlcblxuICAoKiBQYXJzZSBhbmQgY29uc3RydWN0IGEgY2hhciBzZXQuICopXG4gIGFuZCBwYXJzZV9jaGFyX3NldCBzdHJfaW5kIGVuZF9pbmQgPVxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG5cbiAgICBsZXQgY2hhcl9zZXQgPSBjcmVhdGVfY2hhcl9zZXQgKCkgaW5cbiAgICBsZXQgYWRkX2NoYXIgYyA9XG4gICAgICBhZGRfaW5fY2hhcl9zZXQgY2hhcl9zZXQgYztcbiAgICBpblxuICAgIGxldCBhZGRfcmFuZ2UgYyBjJyA9XG4gICAgICBmb3IgaSA9IGludF9vZl9jaGFyIGMgdG8gaW50X29mX2NoYXIgYycgZG9cbiAgICAgICAgYWRkX2luX2NoYXJfc2V0IGNoYXJfc2V0IChjaGFyX29mX2ludCBpKTtcbiAgICAgIGRvbmU7XG4gICAgaW5cblxuICAgIGxldCBmYWlsX3NpbmdsZV9wZXJjZW50IHN0cl9pbmQgPVxuICAgICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgICBcImludmFsaWQgZm9ybWF0ICVTOiAnJSUnIGFsb25lIGlzIG5vdCBhY2NlcHRlZCBpbiBjaGFyYWN0ZXIgc2V0cywgXFxcbiAgICAgICAgIHVzZSAlJSUlIGluc3RlYWQgYXQgcG9zaXRpb24gJWQuXCIgc3RyIHN0cl9pbmRcbiAgICBpblxuXG4gICAgKCogUGFyc2UgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBhIGNoYXIgc2V0LiAqKVxuICAgIGxldCByZWMgcGFyc2VfY2hhcl9zZXRfc3RhcnQgc3RyX2luZCBlbmRfaW5kID1cbiAgICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgICBsZXQgYyA9IHN0ci5bc3RyX2luZF0gaW5cbiAgICAgIHBhcnNlX2NoYXJfc2V0X2FmdGVyX2NoYXIgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGNcblxuICAgICgqIFBhcnNlIHRoZSBjb250ZW50IG9mIGEgY2hhciBzZXQgdW50aWwgdGhlIGZpcnN0ICddJy4gKilcbiAgICBhbmQgcGFyc2VfY2hhcl9zZXRfY29udGVudCBzdHJfaW5kIGVuZF9pbmQgPVxuICAgICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgICAgfCAnXScgLT5cbiAgICAgICAgc3RyX2luZCArIDFcbiAgICAgIHwgJy0nIC0+XG4gICAgICAgIGFkZF9jaGFyICctJztcbiAgICAgICAgcGFyc2VfY2hhcl9zZXRfY29udGVudCAoc3RyX2luZCArIDEpIGVuZF9pbmRcbiAgICAgIHwgYyAtPlxuICAgICAgICBwYXJzZV9jaGFyX3NldF9hZnRlcl9jaGFyIChzdHJfaW5kICsgMSkgZW5kX2luZCBjXG5cbiAgICAoKiBUZXN0IGZvciByYW5nZSBpbiBjaGFyIHNldC4gKilcbiAgICBhbmQgcGFyc2VfY2hhcl9zZXRfYWZ0ZXJfY2hhciBzdHJfaW5kIGVuZF9pbmQgYyA9XG4gICAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgICB8ICddJyAtPlxuICAgICAgICBhZGRfY2hhciBjO1xuICAgICAgICBzdHJfaW5kICsgMVxuICAgICAgfCAnLScgLT5cbiAgICAgICAgcGFyc2VfY2hhcl9zZXRfYWZ0ZXJfbWludXMgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGNcbiAgICAgIHwgKCclJyB8ICdAJykgYXMgYycgd2hlbiBjID0gJyUnIC0+XG4gICAgICAgIGFkZF9jaGFyIGMnO1xuICAgICAgICBwYXJzZV9jaGFyX3NldF9jb250ZW50IChzdHJfaW5kICsgMSkgZW5kX2luZFxuICAgICAgfCBjJyAtPlxuICAgICAgICBpZiBjID0gJyUnIHRoZW4gZmFpbF9zaW5nbGVfcGVyY2VudCBzdHJfaW5kO1xuICAgICAgICAoKiBub3RlIHRoYXQgJ0AnIGFsb25lIGlzIGFjY2VwdGVkLCBhcyBkb25lIGJ5IHRoZSBsZWdhY3lcbiAgICAgICAgICAgaW1wbGVtZW50YXRpb247IHRoZSBkb2N1bWVudGF0aW9uIHNwZWNpZmljYWxseSByZXF1aXJlcyAlQFxuICAgICAgICAgICBzbyB3ZSBjb3VsZCB3YXJuIG9uIHRoYXQgKilcbiAgICAgICAgYWRkX2NoYXIgYztcbiAgICAgICAgcGFyc2VfY2hhcl9zZXRfYWZ0ZXJfY2hhciAoc3RyX2luZCArIDEpIGVuZF9pbmQgYydcblxuICAgICgqIE1hbmFnZSByYW5nZSBpbiBjaGFyIHNldCAoZXhjZXB0IGlmIHRoZSAnLScgdGhlIGxhc3QgY2hhciBiZWZvcmUgJ10nKSAqKVxuICAgIGFuZCBwYXJzZV9jaGFyX3NldF9hZnRlcl9taW51cyBzdHJfaW5kIGVuZF9pbmQgYyA9XG4gICAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgICB8ICddJyAtPlxuICAgICAgICBhZGRfY2hhciBjO1xuICAgICAgICBhZGRfY2hhciAnLSc7XG4gICAgICAgIHN0cl9pbmQgKyAxXG4gICAgICB8ICclJyAtPlxuICAgICAgICBpZiBzdHJfaW5kICsgMSA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICAgICAgYmVnaW4gbWF0Y2ggc3RyLltzdHJfaW5kICsgMV0gd2l0aFxuICAgICAgICAgIHwgKCclJyB8ICdAJykgYXMgYycgLT5cbiAgICAgICAgICAgIGFkZF9yYW5nZSBjIGMnO1xuICAgICAgICAgICAgcGFyc2VfY2hhcl9zZXRfY29udGVudCAoc3RyX2luZCArIDIpIGVuZF9pbmRcbiAgICAgICAgICB8IF8gLT4gZmFpbF9zaW5nbGVfcGVyY2VudCBzdHJfaW5kXG4gICAgICAgIGVuZFxuICAgICAgfCBjJyAtPlxuICAgICAgICBhZGRfcmFuZ2UgYyBjJztcbiAgICAgICAgcGFyc2VfY2hhcl9zZXRfY29udGVudCAoc3RyX2luZCArIDEpIGVuZF9pbmRcbiAgICBpblxuICAgIGxldCBzdHJfaW5kLCByZXZlcnNlID1cbiAgICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICAgICAgfCAnXicgLT4gc3RyX2luZCArIDEsIHRydWVcbiAgICAgICAgfCBfIC0+IHN0cl9pbmQsIGZhbHNlIGluXG4gICAgbGV0IG5leHRfaW5kID0gcGFyc2VfY2hhcl9zZXRfc3RhcnQgc3RyX2luZCBlbmRfaW5kIGluXG4gICAgbGV0IGNoYXJfc2V0ID0gZnJlZXplX2NoYXJfc2V0IGNoYXJfc2V0IGluXG4gICAgbmV4dF9pbmQsIChpZiByZXZlcnNlIHRoZW4gcmV2X2NoYXJfc2V0IGNoYXJfc2V0IGVsc2UgY2hhcl9zZXQpXG5cbiAgKCogQ29uc3VtZSBhbGwgbmV4dCBzcGFjZXMsIHJhaXNlIGFuIEZhaWx1cmUgaWYgZW5kX2luZCBpcyByZWFjaGVkLiAqKVxuICBhbmQgcGFyc2Vfc3BhY2VzIHN0cl9pbmQgZW5kX2luZCA9XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICBpZiBzdHIuW3N0cl9pbmRdID0gJyAnIHRoZW4gcGFyc2Vfc3BhY2VzIChzdHJfaW5kICsgMSkgZW5kX2luZCBlbHNlIHN0cl9pbmRcblxuICAoKiBSZWFkIGEgcG9zaXRpdmUgaW50ZWdlciBmcm9tIHRoZSBzdHJpbmcsIHJhaXNlIGEgRmFpbHVyZSBpZiBlbmRfaW5kIGlzXG4gICAgIHJlYWNoZWQuICopXG4gIGFuZCBwYXJzZV9wb3NpdGl2ZSBzdHJfaW5kIGVuZF9pbmQgYWNjID1cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgIHwgJzAnIC4uICc5JyBhcyBjIC0+XG4gICAgICBsZXQgbmV3X2FjYyA9IGFjYyAqIDEwICsgKGludF9vZl9jaGFyIGMgLSBpbnRfb2ZfY2hhciAnMCcpIGluXG4gICAgICBpZiBuZXdfYWNjID4gU3lzLm1heF9zdHJpbmdfbGVuZ3RoIHRoZW5cbiAgICAgICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgICAgIFwiaW52YWxpZCBmb3JtYXQgJVM6IGludGVnZXIgJWQgaXMgZ3JlYXRlciB0aGFuIHRoZSBsaW1pdCAlZFwiXG4gICAgICAgICAgc3RyIG5ld19hY2MgU3lzLm1heF9zdHJpbmdfbGVuZ3RoXG4gICAgICBlbHNlXG4gICAgICAgIHBhcnNlX3Bvc2l0aXZlIChzdHJfaW5kICsgMSkgZW5kX2luZCBuZXdfYWNjXG4gICAgfCBfIC0+IHN0cl9pbmQsIGFjY1xuXG4gICgqIFJlYWQgYSBwb3NpdGl2ZSBvciBuZWdhdGl2ZSBpbnRlZ2VyIGZyb20gdGhlIHN0cmluZywgcmFpc2UgYSBGYWlsdXJlXG4gICAgIGlmIGVuZF9pbmQgaXMgcmVhY2hlZC4gKilcbiAgYW5kIHBhcnNlX2ludGVnZXIgc3RyX2luZCBlbmRfaW5kID1cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgIHwgJzAnIC4uICc5JyAtPiBwYXJzZV9wb3NpdGl2ZSBzdHJfaW5kIGVuZF9pbmQgMFxuICAgIHwgJy0nIC0+IChcbiAgICAgIGlmIHN0cl9pbmQgKyAxID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgbWF0Y2ggc3RyLltzdHJfaW5kICsgMV0gd2l0aFxuICAgICAgfCAnMCcgLi4gJzknIC0+XG4gICAgICAgIGxldCBuZXh0X2luZCwgbiA9IHBhcnNlX3Bvc2l0aXZlIChzdHJfaW5kICsgMSkgZW5kX2luZCAwIGluXG4gICAgICAgIG5leHRfaW5kLCAtblxuICAgICAgfCBjIC0+XG4gICAgICAgIGV4cGVjdGVkX2NoYXJhY3RlciAoc3RyX2luZCArIDEpIFwiZGlnaXRcIiBjXG4gICAgKVxuICAgIHwgXyAtPiBhc3NlcnQgZmFsc2VcblxuICAoKiBBZGQgYSBsaXRlcmFsIHRvIGEgZm9ybWF0IGZyb20gYSBsaXRlcmFsIGNoYXJhY3RlciBzdWItc2VxdWVuY2UuICopXG4gIGFuZCBhZGRfbGl0ZXJhbCA6IHR5cGUgYSBkIGUgZiAuXG4gICAgICBpbnQgLT4gaW50IC0+IChhLCBfLCBfLCBkLCBlLCBmKSBmbXQgLT5cbiAgICAgIChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIGxpdF9zdGFydCBzdHJfaW5kIGZtdCAtPiBtYXRjaCBzdHJfaW5kIC0gbGl0X3N0YXJ0IHdpdGhcbiAgICB8IDAgICAgLT4gRm10X0VCQiBmbXRcbiAgICB8IDEgICAgLT4gRm10X0VCQiAoQ2hhcl9saXRlcmFsIChzdHIuW2xpdF9zdGFydF0sIGZtdCkpXG4gICAgfCBzaXplIC0+IEZtdF9FQkIgKFN0cmluZ19saXRlcmFsIChTdHJpbmcuc3ViIHN0ciBsaXRfc3RhcnQgc2l6ZSwgZm10KSlcblxuICAoKiBTZWFyY2ggdGhlIGVuZCBvZiB0aGUgY3VycmVudCBzdWItZm9ybWF0XG4gICAgIChpLmUuIHRoZSBjb3JyZXNwb25kaW5nIFwiJX1cIiBvciBcIiUpXCIpICopXG4gIGFuZCBzZWFyY2hfc3ViZm9ybWF0X2VuZCBzdHJfaW5kIGVuZF9pbmQgYyA9XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlblxuICAgICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgICBcImludmFsaWQgZm9ybWF0ICVTOiB1bmNsb3NlZCBzdWItZm9ybWF0LCBcXFxuICAgICAgICAgZXhwZWN0ZWQgXFxcIiUlJWNcXFwiIGF0IGNoYXJhY3RlciBudW1iZXIgJWRcIiBzdHIgYyBlbmRfaW5kO1xuICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgIHwgJyUnIC0+XG4gICAgICBpZiBzdHJfaW5kICsgMSA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICAgIGlmIHN0ci5bc3RyX2luZCArIDFdID0gYyB0aGVuICgqIEVuZCBvZiBmb3JtYXQgZm91bmQgKikgc3RyX2luZCBlbHNlXG4gICAgICAgIGJlZ2luIG1hdGNoIHN0ci5bc3RyX2luZCArIDFdIHdpdGhcbiAgICAgICAgfCAnXycgLT5cbiAgICAgICAgICAoKiBTZWFyY2ggZm9yIFwiJV8oXCIgb3IgXCIlX3tcIi4gKilcbiAgICAgICAgICBpZiBzdHJfaW5kICsgMiA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICAgICAgICBiZWdpbiBtYXRjaCBzdHIuW3N0cl9pbmQgKyAyXSB3aXRoXG4gICAgICAgICAgfCAneycgLT5cbiAgICAgICAgICAgIGxldCBzdWJfZW5kID0gc2VhcmNoX3N1YmZvcm1hdF9lbmQgKHN0cl9pbmQgKyAzKSBlbmRfaW5kICd9JyBpblxuICAgICAgICAgICAgc2VhcmNoX3N1YmZvcm1hdF9lbmQgKHN1Yl9lbmQgKyAyKSBlbmRfaW5kIGNcbiAgICAgICAgICB8ICcoJyAtPlxuICAgICAgICAgICAgbGV0IHN1Yl9lbmQgPSBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3RyX2luZCArIDMpIGVuZF9pbmQgJyknIGluXG4gICAgICAgICAgICBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3ViX2VuZCArIDIpIGVuZF9pbmQgY1xuICAgICAgICAgIHwgXyAtPiBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3RyX2luZCArIDMpIGVuZF9pbmQgY1xuICAgICAgICAgIGVuZFxuICAgICAgICB8ICd7JyAtPlxuICAgICAgICAgICgqICV7Li4uJX0gc3ViLWZvcm1hdCBmb3VuZC4gKilcbiAgICAgICAgICBsZXQgc3ViX2VuZCA9IHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdHJfaW5kICsgMikgZW5kX2luZCAnfScgaW5cbiAgICAgICAgICBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3ViX2VuZCArIDIpIGVuZF9pbmQgY1xuICAgICAgICB8ICcoJyAtPlxuICAgICAgICAgICgqICUoLi4uJSkgc3ViLWZvcm1hdCBmb3VuZC4gKilcbiAgICAgICAgICBsZXQgc3ViX2VuZCA9IHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdHJfaW5kICsgMikgZW5kX2luZCAnKScgaW5cbiAgICAgICAgICBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3ViX2VuZCArIDIpIGVuZF9pbmQgY1xuICAgICAgICB8ICd9JyAtPlxuICAgICAgICAgICgqIEVycm9yOiAlKC4uLiV9LiAqKVxuICAgICAgICAgIGV4cGVjdGVkX2NoYXJhY3RlciAoc3RyX2luZCArIDEpIFwiY2hhcmFjdGVyICcpJ1wiICd9J1xuICAgICAgICB8ICcpJyAtPlxuICAgICAgICAgICgqIEVycm9yOiAley4uLiUpLiAqKVxuICAgICAgICAgIGV4cGVjdGVkX2NoYXJhY3RlciAoc3RyX2luZCArIDEpIFwiY2hhcmFjdGVyICd9J1wiICcpJ1xuICAgICAgICB8IF8gLT5cbiAgICAgICAgICBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3RyX2luZCArIDIpIGVuZF9pbmQgY1xuICAgICAgICBlbmRcbiAgICB8IF8gLT4gc2VhcmNoX3N1YmZvcm1hdF9lbmQgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGNcblxuICAoKiBDaGVjayBpZiBzeW1iIGlzIGEgdmFsaWQgaW50IGNvbnZlcnNpb24gYWZ0ZXIgXCIlbFwiLCBcIiVuXCIgb3IgXCIlTFwiICopXG4gIGFuZCBpc19pbnRfYmFzZSBzeW1iID0gbWF0Y2ggc3ltYiB3aXRoXG4gICAgfCAnZCcgfCAnaScgfCAneCcgfCAnWCcgfCAnbycgfCAndScgLT4gdHJ1ZVxuICAgIHwgXyAtPiBmYWxzZVxuXG4gICgqIENvbnZlcnQgYSBjaGFyIChsLCBuIG9yIEwpIHRvIGl0cyBhc3NvY2lhdGVkIGNvdW50ZXIuICopXG4gIGFuZCBjb3VudGVyX29mX2NoYXIgc3ltYiA9IG1hdGNoIHN5bWIgd2l0aFxuICAgIHwgJ2wnIC0+IExpbmVfY291bnRlciAgfCAnbicgLT4gQ2hhcl9jb3VudGVyXG4gICAgfCAnTCcgLT4gVG9rZW5fY291bnRlciB8IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiAgKCogQ29udmVydCAocGx1cywgc3ltYikgdG8gaXRzIGFzc29jaWF0ZWQgaW50X2NvbnYuICopXG4gIGFuZCBjb21wdXRlX2ludF9jb252IHBjdF9pbmQgc3RyX2luZCBwbHVzIGhhc2ggc3BhY2Ugc3ltYiA9XG4gICAgbWF0Y2ggcGx1cywgaGFzaCwgc3BhY2UsIHN5bWIgd2l0aFxuICAgIHwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgJ2QnIC0+IEludF9kICB8IGZhbHNlLCBmYWxzZSwgZmFsc2UsICdpJyAtPiBJbnRfaVxuICAgIHwgZmFsc2UsIGZhbHNlLCAgdHJ1ZSwgJ2QnIC0+IEludF9zZCB8IGZhbHNlLCBmYWxzZSwgIHRydWUsICdpJyAtPiBJbnRfc2lcbiAgICB8ICB0cnVlLCBmYWxzZSwgZmFsc2UsICdkJyAtPiBJbnRfcGQgfCAgdHJ1ZSwgZmFsc2UsIGZhbHNlLCAnaScgLT4gSW50X3BpXG4gICAgfCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAneCcgLT4gSW50X3ggIHwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgJ1gnIC0+IEludF9YXG4gICAgfCBmYWxzZSwgIHRydWUsIGZhbHNlLCAneCcgLT4gSW50X0N4IHwgZmFsc2UsICB0cnVlLCBmYWxzZSwgJ1gnIC0+IEludF9DWFxuICAgIHwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgJ28nIC0+IEludF9vXG4gICAgfCBmYWxzZSwgIHRydWUsIGZhbHNlLCAnbycgLT4gSW50X0NvXG4gICAgfCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAndScgLT4gSW50X3VcbiAgICB8IGZhbHNlLCAgdHJ1ZSwgZmFsc2UsICdkJyAtPiBJbnRfQ2RcbiAgICB8IGZhbHNlLCAgdHJ1ZSwgZmFsc2UsICdpJyAtPiBJbnRfQ2lcbiAgICB8IGZhbHNlLCAgdHJ1ZSwgZmFsc2UsICd1JyAtPiBJbnRfQ3VcbiAgICB8IF8sIHRydWUsIF8sICd4JyB3aGVuIGxlZ2FjeV9iZWhhdmlvciAtPiBJbnRfQ3hcbiAgICB8IF8sIHRydWUsIF8sICdYJyB3aGVuIGxlZ2FjeV9iZWhhdmlvciAtPiBJbnRfQ1hcbiAgICB8IF8sIHRydWUsIF8sICdvJyB3aGVuIGxlZ2FjeV9iZWhhdmlvciAtPiBJbnRfQ29cbiAgICB8IF8sIHRydWUsIF8sICgnZCcgfCAnaScgfCAndScpIC0+XG4gICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiAoKiBpZ25vcmUgKilcbiAgICAgICAgY29tcHV0ZV9pbnRfY29udiBwY3RfaW5kIHN0cl9pbmQgcGx1cyBmYWxzZSBzcGFjZSBzeW1iXG4gICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiJyMnXCJcbiAgICB8IHRydWUsIF8sIHRydWUsIF8gLT5cbiAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuXG4gICAgICAgICgqIHBsdXMgYW5kIHNwYWNlOiBsZWdhY3kgaW1wbGVtZW50YXRpb24gcHJlZmVycyBwbHVzICopXG4gICAgICAgIGNvbXB1dGVfaW50X2NvbnYgcGN0X2luZCBzdHJfaW5kIHBsdXMgaGFzaCBmYWxzZSBzeW1iXG4gICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCAnICcgXCInKydcIlxuICAgIHwgZmFsc2UsIF8sIHRydWUsIF8gICAgLT5cbiAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuICgqIGlnbm9yZSAqKVxuICAgICAgICBjb21wdXRlX2ludF9jb252IHBjdF9pbmQgc3RyX2luZCBwbHVzIGhhc2ggZmFsc2Ugc3ltYlxuICAgICAgZWxzZSBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgc3ltYiBcIicgJ1wiXG4gICAgfCB0cnVlLCBfLCBmYWxzZSwgXyAgICAtPlxuICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW4gKCogaWdub3JlICopXG4gICAgICAgIGNvbXB1dGVfaW50X2NvbnYgcGN0X2luZCBzdHJfaW5kIGZhbHNlIGhhc2ggc3BhY2Ugc3ltYlxuICAgICAgZWxzZSBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgc3ltYiBcIicrJ1wiXG4gICAgfCBmYWxzZSwgXywgZmFsc2UsIF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiAgKCogQ29udmVydCAocGx1cywgc3BhY2UsIHN5bWIpIHRvIGl0cyBhc3NvY2lhdGVkIGZsb2F0X2NvbnYuICopXG4gIGFuZCBjb21wdXRlX2Zsb2F0X2NvbnYgcGN0X2luZCBzdHJfaW5kIHBsdXMgaGFzaCBzcGFjZSBzeW1iID1cbiAgICBsZXQgZmxhZyA9IG1hdGNoIHBsdXMsIHNwYWNlIHdpdGhcbiAgICB8IGZhbHNlLCBmYWxzZSAtPiBGbG9hdF9mbGFnX1xuICAgIHwgZmFsc2UsICB0cnVlIC0+IEZsb2F0X2ZsYWdfc1xuICAgIHwgIHRydWUsIGZhbHNlIC0+IEZsb2F0X2ZsYWdfcFxuICAgIHwgIHRydWUsICB0cnVlIC0+XG4gICAgICAoKiBwbHVzIGFuZCBzcGFjZTogbGVnYWN5IGltcGxlbWVudGF0aW9uIHByZWZlcnMgcGx1cyAqKVxuICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW4gRmxvYXRfZmxhZ19wXG4gICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCAnICcgXCInKydcIiBpblxuICAgIGxldCBraW5kID0gbWF0Y2ggaGFzaCwgc3ltYiB3aXRoXG4gICAgfCBfLCAnZicgLT4gRmxvYXRfZlxuICAgIHwgXywgJ2UnIC0+IEZsb2F0X2VcbiAgICB8IF8sICdFJyAtPiBGbG9hdF9FXG4gICAgfCBfLCAnZycgLT4gRmxvYXRfZ1xuICAgIHwgXywgJ0cnIC0+IEZsb2F0X0dcbiAgICB8IF8sICdoJyAtPiBGbG9hdF9oXG4gICAgfCBfLCAnSCcgLT4gRmxvYXRfSFxuICAgIHwgZmFsc2UsICdGJyAtPiBGbG9hdF9GXG4gICAgfCB0cnVlLCAnRicgLT4gRmxvYXRfQ0ZcbiAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlIGluXG4gICAgZmxhZywga2luZFxuXG4gICgqIFJhaXNlIFtGYWlsdXJlXSB3aXRoIGEgZnJpZW5kbHkgZXJyb3IgbWVzc2FnZSBhYm91dCBpbmNvbXBhdGlibGUgb3B0aW9ucy4qKVxuICBhbmQgaW5jb21wYXRpYmxlX2ZsYWcgOiB0eXBlIGEgLiBpbnQgLT4gaW50IC0+IGNoYXIgLT4gc3RyaW5nIC0+IGEgPVxuICAgIGZ1biBwY3RfaW5kIHN0cl9pbmQgc3ltYiBvcHRpb24gLT5cbiAgICAgIGxldCBzdWJmbXQgPSBTdHJpbmcuc3ViIHN0ciBwY3RfaW5kIChzdHJfaW5kIC0gcGN0X2luZCkgaW5cbiAgICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgICAgXCJpbnZhbGlkIGZvcm1hdCAlUzogYXQgY2hhcmFjdGVyIG51bWJlciAlZCwgXFxcbiAgICAgICAgICVzIGlzIGluY29tcGF0aWJsZSB3aXRoICclYycgaW4gc3ViLWZvcm1hdCAlU1wiXG4gICAgICAgIHN0ciBwY3RfaW5kIG9wdGlvbiBzeW1iIHN1YmZtdFxuXG4gIGluIHBhcnNlIDAgKFN0cmluZy5sZW5ndGggc3RyKVxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgKCogR3VhcmRlZCBzdHJpbmcgdG8gZm9ybWF0IGNvbnZlcnNpb25zICopXG5cbigqIENvbnZlcnQgYSBzdHJpbmcgdG8gYSBmb3JtYXQgYWNjb3JkaW5nIHRvIGFuIGZtdHR5LiAqKVxuKCogUmFpc2UgW0ZhaWx1cmVdIHdpdGggYW4gZXJyb3IgbWVzc2FnZSBpbiBjYXNlIG9mIHR5cGUgbWlzbWF0Y2guICopXG5sZXQgZm9ybWF0X29mX3N0cmluZ19mbXR0eSBzdHIgZm10dHkgPVxuICBsZXQgRm10X0VCQiBmbXQgPSBmbXRfZWJiX29mX3N0cmluZyBzdHIgaW5cbiAgdHJ5IEZvcm1hdCAodHlwZV9mb3JtYXQgZm10IGZtdHR5LCBzdHIpXG4gIHdpdGggVHlwZV9taXNtYXRjaCAtPlxuICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgIFwiYmFkIGlucHV0OiBmb3JtYXQgdHlwZSBtaXNtYXRjaCBiZXR3ZWVuICVTIGFuZCAlU1wiXG4gICAgICBzdHIgKHN0cmluZ19vZl9mbXR0eSBmbXR0eSlcblxuKCogQ29udmVydCBhIHN0cmluZyB0byBhIGZvcm1hdCBjb21wYXRpYmxlIHdpdGggYW4gb3RoZXIgZm9ybWF0LiAqKVxuKCogUmFpc2UgW0ZhaWx1cmVdIHdpdGggYW4gZXJyb3IgbWVzc2FnZSBpbiBjYXNlIG9mIHR5cGUgbWlzbWF0Y2guICopXG5sZXQgZm9ybWF0X29mX3N0cmluZ19mb3JtYXQgc3RyIChGb3JtYXQgKGZtdCcsIHN0cicpKSA9XG4gIGxldCBGbXRfRUJCIGZtdCA9IGZtdF9lYmJfb2Zfc3RyaW5nIHN0ciBpblxuICB0cnkgRm9ybWF0ICh0eXBlX2Zvcm1hdCBmbXQgKGZtdHR5X29mX2ZtdCBmbXQnKSwgc3RyKVxuICB3aXRoIFR5cGVfbWlzbWF0Y2ggLT5cbiAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICBcImJhZCBpbnB1dDogZm9ybWF0IHR5cGUgbWlzbWF0Y2ggYmV0d2VlbiAlUyBhbmQgJVNcIiBzdHIgc3RyJ1xuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5vcGVuIFByaW50ZlxuXG50eXBlIHQgPSBleG4gPSAuLlxuXG5sZXQgcHJpbnRlcnMgPSBBdG9taWMubWFrZSBbXVxuXG5sZXQgbG9jZm10ID0gZm9ybWF0X29mX3N0cmluZyBcIkZpbGUgXFxcIiVzXFxcIiwgbGluZSAlZCwgY2hhcmFjdGVycyAlZC0lZDogJXNcIlxuXG5sZXQgZmllbGQgeCBpID1cbiAgbGV0IGYgPSBPYmouZmllbGQgeCBpIGluXG4gIGlmIG5vdCAoT2JqLmlzX2Jsb2NrIGYpIHRoZW5cbiAgICBzcHJpbnRmIFwiJWRcIiAoT2JqLm1hZ2ljIGYgOiBpbnQpICAgICAgICAgICAoKiBjYW4gYWxzbyBiZSBhIGNoYXIgKilcbiAgZWxzZSBpZiBPYmoudGFnIGYgPSBPYmouc3RyaW5nX3RhZyB0aGVuXG4gICAgc3ByaW50ZiBcIiVTXCIgKE9iai5tYWdpYyBmIDogc3RyaW5nKVxuICBlbHNlIGlmIE9iai50YWcgZiA9IE9iai5kb3VibGVfdGFnIHRoZW5cbiAgICBzdHJpbmdfb2ZfZmxvYXQgKE9iai5tYWdpYyBmIDogZmxvYXQpXG4gIGVsc2VcbiAgICBcIl9cIlxuXG5sZXQgcmVjIG90aGVyX2ZpZWxkcyB4IGkgPVxuICBpZiBpID49IE9iai5zaXplIHggdGhlbiBcIlwiXG4gIGVsc2Ugc3ByaW50ZiBcIiwgJXMlc1wiIChmaWVsZCB4IGkpIChvdGhlcl9maWVsZHMgeCAoaSsxKSlcblxubGV0IGZpZWxkcyB4ID1cbiAgbWF0Y2ggT2JqLnNpemUgeCB3aXRoXG4gIHwgMCAtPiBcIlwiXG4gIHwgMSAtPiBcIlwiXG4gIHwgMiAtPiBzcHJpbnRmIFwiKCVzKVwiIChmaWVsZCB4IDEpXG4gIHwgXyAtPiBzcHJpbnRmIFwiKCVzJXMpXCIgKGZpZWxkIHggMSkgKG90aGVyX2ZpZWxkcyB4IDIpXG5cbmxldCB1c2VfcHJpbnRlcnMgeCA9XG4gIGxldCByZWMgY29udiA9IGZ1bmN0aW9uXG4gICAgfCBoZCA6OiB0bCAtPlxuICAgICAgICAobWF0Y2ggaGQgeCB3aXRoXG4gICAgICAgICB8IE5vbmUgfCBleGNlcHRpb24gXyAtPiBjb252IHRsXG4gICAgICAgICB8IFNvbWUgcyAtPiBTb21lIHMpXG4gICAgfCBbXSAtPiBOb25lIGluXG4gIGNvbnYgKEF0b21pYy5nZXQgcHJpbnRlcnMpXG5cbmxldCB0b19zdHJpbmdfZGVmYXVsdCA9IGZ1bmN0aW9uXG4gIHwgT3V0X29mX21lbW9yeSAtPiBcIk91dCBvZiBtZW1vcnlcIlxuICB8IFN0YWNrX292ZXJmbG93IC0+IFwiU3RhY2sgb3ZlcmZsb3dcIlxuICB8IE1hdGNoX2ZhaWx1cmUoZmlsZSwgbGluZSwgY2hhcikgLT5cbiAgICAgIHNwcmludGYgbG9jZm10IGZpbGUgbGluZSBjaGFyIChjaGFyKzUpIFwiUGF0dGVybiBtYXRjaGluZyBmYWlsZWRcIlxuICB8IEFzc2VydF9mYWlsdXJlKGZpbGUsIGxpbmUsIGNoYXIpIC0+XG4gICAgICBzcHJpbnRmIGxvY2ZtdCBmaWxlIGxpbmUgY2hhciAoY2hhcis2KSBcIkFzc2VydGlvbiBmYWlsZWRcIlxuICB8IFVuZGVmaW5lZF9yZWN1cnNpdmVfbW9kdWxlKGZpbGUsIGxpbmUsIGNoYXIpIC0+XG4gICAgICBzcHJpbnRmIGxvY2ZtdCBmaWxlIGxpbmUgY2hhciAoY2hhcis2KSBcIlVuZGVmaW5lZCByZWN1cnNpdmUgbW9kdWxlXCJcbiAgfCB4IC0+XG4gICAgICBsZXQgeCA9IE9iai5yZXByIHggaW5cbiAgICAgIGlmIE9iai50YWcgeCA8PiAwIHRoZW5cbiAgICAgICAgKE9iai5tYWdpYyAoT2JqLmZpZWxkIHggMCkgOiBzdHJpbmcpXG4gICAgICBlbHNlXG4gICAgICAgIGxldCBjb25zdHJ1Y3RvciA9XG4gICAgICAgICAgKE9iai5tYWdpYyAoT2JqLmZpZWxkIChPYmouZmllbGQgeCAwKSAwKSA6IHN0cmluZykgaW5cbiAgICAgICAgY29uc3RydWN0b3IgXiAoZmllbGRzIHgpXG5cbmxldCB0b19zdHJpbmcgZSA9XG4gIG1hdGNoIHVzZV9wcmludGVycyBlIHdpdGhcbiAgfCBTb21lIHMgLT4gc1xuICB8IE5vbmUgLT4gdG9fc3RyaW5nX2RlZmF1bHQgZVxuXG5sZXQgcHJpbnQgZmN0IGFyZyA9XG4gIHRyeVxuICAgIGZjdCBhcmdcbiAgd2l0aCB4IC0+XG4gICAgZXByaW50ZiBcIlVuY2F1Z2h0IGV4Y2VwdGlvbjogJXNcXG5cIiAodG9fc3RyaW5nIHgpO1xuICAgIGZsdXNoIHN0ZGVycjtcbiAgICByYWlzZSB4XG5cbmxldCBjYXRjaCBmY3QgYXJnID1cbiAgdHJ5XG4gICAgZmN0IGFyZ1xuICB3aXRoIHggLT5cbiAgICBmbHVzaCBzdGRvdXQ7XG4gICAgZXByaW50ZiBcIlVuY2F1Z2h0IGV4Y2VwdGlvbjogJXNcXG5cIiAodG9fc3RyaW5nIHgpO1xuICAgIGV4aXQgMlxuXG50eXBlIHJhd19iYWNrdHJhY2Vfc2xvdFxudHlwZSByYXdfYmFja3RyYWNlX2VudHJ5ID0gcHJpdmF0ZSBpbnRcbnR5cGUgcmF3X2JhY2t0cmFjZSA9IHJhd19iYWNrdHJhY2VfZW50cnkgYXJyYXlcblxubGV0IHJhd19iYWNrdHJhY2VfZW50cmllcyBidCA9IGJ0XG5cbmV4dGVybmFsIGdldF9yYXdfYmFja3RyYWNlOlxuICB1bml0IC0+IHJhd19iYWNrdHJhY2UgPSBcImNhbWxfZ2V0X2V4Y2VwdGlvbl9yYXdfYmFja3RyYWNlXCJcblxuZXh0ZXJuYWwgcmFpc2Vfd2l0aF9iYWNrdHJhY2U6IGV4biAtPiByYXdfYmFja3RyYWNlIC0+ICdhXG4gID0gXCIlcmFpc2Vfd2l0aF9iYWNrdHJhY2VcIlxuXG50eXBlIGJhY2t0cmFjZV9zbG90ID1cbiAgfCBLbm93bl9sb2NhdGlvbiBvZiB7XG4gICAgICBpc19yYWlzZSAgICA6IGJvb2w7XG4gICAgICBmaWxlbmFtZSAgICA6IHN0cmluZztcbiAgICAgIGxpbmVfbnVtYmVyIDogaW50O1xuICAgICAgc3RhcnRfY2hhciAgOiBpbnQ7XG4gICAgICBlbmRfY2hhciAgICA6IGludDtcbiAgICAgIGlzX2lubGluZSAgIDogYm9vbDtcbiAgICAgIGRlZm5hbWUgICAgIDogc3RyaW5nO1xuICAgIH1cbiAgfCBVbmtub3duX2xvY2F0aW9uIG9mIHtcbiAgICAgIGlzX3JhaXNlIDogYm9vbFxuICAgIH1cblxuKCogdG8gYXZvaWQgd2FybmluZyAqKVxubGV0IF8gPSBbS25vd25fbG9jYXRpb24geyBpc19yYWlzZSA9IGZhbHNlOyBmaWxlbmFtZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVfbnVtYmVyID0gMDsgc3RhcnRfY2hhciA9IDA7IGVuZF9jaGFyID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaXNfaW5saW5lID0gZmFsc2U7IGRlZm5hbWUgPSBcIlwiIH07XG4gICAgICAgICBVbmtub3duX2xvY2F0aW9uIHsgaXNfcmFpc2UgPSBmYWxzZSB9XVxuXG5leHRlcm5hbCBjb252ZXJ0X3Jhd19iYWNrdHJhY2Vfc2xvdDpcbiAgcmF3X2JhY2t0cmFjZV9zbG90IC0+IGJhY2t0cmFjZV9zbG90ID0gXCJjYW1sX2NvbnZlcnRfcmF3X2JhY2t0cmFjZV9zbG90XCJcblxuZXh0ZXJuYWwgY29udmVydF9yYXdfYmFja3RyYWNlOlxuICByYXdfYmFja3RyYWNlIC0+IGJhY2t0cmFjZV9zbG90IGFycmF5ID0gXCJjYW1sX2NvbnZlcnRfcmF3X2JhY2t0cmFjZVwiXG5cbmxldCBjb252ZXJ0X3Jhd19iYWNrdHJhY2UgYnQgPVxuICB0cnkgU29tZSAoY29udmVydF9yYXdfYmFja3RyYWNlIGJ0KVxuICB3aXRoIEZhaWx1cmUgXyAtPiBOb25lXG5cbmxldCBmb3JtYXRfYmFja3RyYWNlX3Nsb3QgcG9zIHNsb3QgPVxuICBsZXQgaW5mbyBpc19yYWlzZSA9XG4gICAgaWYgaXNfcmFpc2UgdGhlblxuICAgICAgaWYgcG9zID0gMCB0aGVuIFwiUmFpc2VkIGF0XCIgZWxzZSBcIlJlLXJhaXNlZCBhdFwiXG4gICAgZWxzZVxuICAgICAgaWYgcG9zID0gMCB0aGVuIFwiUmFpc2VkIGJ5IHByaW1pdGl2ZSBvcGVyYXRpb24gYXRcIiBlbHNlIFwiQ2FsbGVkIGZyb21cIlxuICBpblxuICBtYXRjaCBzbG90IHdpdGhcbiAgfCBVbmtub3duX2xvY2F0aW9uIGwgLT5cbiAgICAgIGlmIGwuaXNfcmFpc2UgdGhlblxuICAgICAgICAoKiBjb21waWxlci1pbnNlcnRlZCByZS1yYWlzZSwgc2tpcHBlZCAqKSBOb25lXG4gICAgICBlbHNlXG4gICAgICAgIFNvbWUgKHNwcmludGYgXCIlcyB1bmtub3duIGxvY2F0aW9uXCIgKGluZm8gZmFsc2UpKVxuICB8IEtub3duX2xvY2F0aW9uIGwgLT5cbiAgICAgIFNvbWUgKHNwcmludGYgXCIlcyAlcyBpbiBmaWxlIFxcXCIlc1xcXCIlcywgbGluZSAlZCwgY2hhcmFjdGVycyAlZC0lZFwiXG4gICAgICAgICAgICAgIChpbmZvIGwuaXNfcmFpc2UpIGwuZGVmbmFtZSBsLmZpbGVuYW1lXG4gICAgICAgICAgICAgIChpZiBsLmlzX2lubGluZSB0aGVuIFwiIChpbmxpbmVkKVwiIGVsc2UgXCJcIilcbiAgICAgICAgICAgICAgbC5saW5lX251bWJlciBsLnN0YXJ0X2NoYXIgbC5lbmRfY2hhcilcblxubGV0IHByaW50X2V4Y2VwdGlvbl9iYWNrdHJhY2Ugb3V0Y2hhbiBiYWNrdHJhY2UgPVxuICBtYXRjaCBiYWNrdHJhY2Ugd2l0aFxuICB8IE5vbmUgLT5cbiAgICAgIGZwcmludGYgb3V0Y2hhblxuICAgICAgICBcIihQcm9ncmFtIG5vdCBsaW5rZWQgd2l0aCAtZywgY2Fubm90IHByaW50IHN0YWNrIGJhY2t0cmFjZSlcXG5cIlxuICB8IFNvbWUgYSAtPlxuICAgICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCBhIC0gMSBkb1xuICAgICAgICBtYXRjaCBmb3JtYXRfYmFja3RyYWNlX3Nsb3QgaSBhLihpKSB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+ICgpXG4gICAgICAgICAgfCBTb21lIHN0ciAtPiBmcHJpbnRmIG91dGNoYW4gXCIlc1xcblwiIHN0clxuICAgICAgZG9uZVxuXG5sZXQgcHJpbnRfcmF3X2JhY2t0cmFjZSBvdXRjaGFuIHJhd19iYWNrdHJhY2UgPVxuICBwcmludF9leGNlcHRpb25fYmFja3RyYWNlIG91dGNoYW4gKGNvbnZlcnRfcmF3X2JhY2t0cmFjZSByYXdfYmFja3RyYWNlKVxuXG4oKiBjb25mdXNpbmdseSBuYW1lZDogcHJpbnRzIHRoZSBnbG9iYWwgY3VycmVudCBiYWNrdHJhY2UgKilcbmxldCBwcmludF9iYWNrdHJhY2Ugb3V0Y2hhbiA9XG4gIHByaW50X3Jhd19iYWNrdHJhY2Ugb3V0Y2hhbiAoZ2V0X3Jhd19iYWNrdHJhY2UgKCkpXG5cbmxldCBiYWNrdHJhY2VfdG9fc3RyaW5nIGJhY2t0cmFjZSA9XG4gIG1hdGNoIGJhY2t0cmFjZSB3aXRoXG4gIHwgTm9uZSAtPlxuICAgICBcIihQcm9ncmFtIG5vdCBsaW5rZWQgd2l0aCAtZywgY2Fubm90IHByaW50IHN0YWNrIGJhY2t0cmFjZSlcXG5cIlxuICB8IFNvbWUgYSAtPlxuICAgICAgbGV0IGIgPSBCdWZmZXIuY3JlYXRlIDEwMjQgaW5cbiAgICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggYSAtIDEgZG9cbiAgICAgICAgbWF0Y2ggZm9ybWF0X2JhY2t0cmFjZV9zbG90IGkgYS4oaSkgd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPiAoKVxuICAgICAgICAgIHwgU29tZSBzdHIgLT4gYnByaW50ZiBiIFwiJXNcXG5cIiBzdHJcbiAgICAgIGRvbmU7XG4gICAgICBCdWZmZXIuY29udGVudHMgYlxuXG5sZXQgcmF3X2JhY2t0cmFjZV90b19zdHJpbmcgcmF3X2JhY2t0cmFjZSA9XG4gIGJhY2t0cmFjZV90b19zdHJpbmcgKGNvbnZlcnRfcmF3X2JhY2t0cmFjZSByYXdfYmFja3RyYWNlKVxuXG5sZXQgYmFja3RyYWNlX3Nsb3RfaXNfcmFpc2UgPSBmdW5jdGlvblxuICB8IEtub3duX2xvY2F0aW9uIGwgLT4gbC5pc19yYWlzZVxuICB8IFVua25vd25fbG9jYXRpb24gbCAtPiBsLmlzX3JhaXNlXG5cbmxldCBiYWNrdHJhY2Vfc2xvdF9pc19pbmxpbmUgPSBmdW5jdGlvblxuICB8IEtub3duX2xvY2F0aW9uIGwgLT4gbC5pc19pbmxpbmVcbiAgfCBVbmtub3duX2xvY2F0aW9uIF8gLT4gZmFsc2VcblxudHlwZSBsb2NhdGlvbiA9IHtcbiAgZmlsZW5hbWUgOiBzdHJpbmc7XG4gIGxpbmVfbnVtYmVyIDogaW50O1xuICBzdGFydF9jaGFyIDogaW50O1xuICBlbmRfY2hhciA6IGludDtcbn1cblxubGV0IGJhY2t0cmFjZV9zbG90X2xvY2F0aW9uID0gZnVuY3Rpb25cbiAgfCBVbmtub3duX2xvY2F0aW9uIF8gLT4gTm9uZVxuICB8IEtub3duX2xvY2F0aW9uIGwgLT5cbiAgICBTb21lIHtcbiAgICAgIGZpbGVuYW1lICAgID0gbC5maWxlbmFtZTtcbiAgICAgIGxpbmVfbnVtYmVyID0gbC5saW5lX251bWJlcjtcbiAgICAgIHN0YXJ0X2NoYXIgID0gbC5zdGFydF9jaGFyO1xuICAgICAgZW5kX2NoYXIgICAgPSBsLmVuZF9jaGFyO1xuICAgIH1cblxubGV0IGJhY2t0cmFjZV9zbG90X2RlZm5hbWUgPSBmdW5jdGlvblxuICB8IFVua25vd25fbG9jYXRpb24gX1xuICB8IEtub3duX2xvY2F0aW9uIHsgZGVmbmFtZSA9IFwiXCIgfSAtPiBOb25lXG4gIHwgS25vd25fbG9jYXRpb24gbCAtPiBTb21lIGwuZGVmbmFtZVxuXG5sZXQgYmFja3RyYWNlX3Nsb3RzIHJhd19iYWNrdHJhY2UgPVxuICAoKiBUaGUgZG9jdW1lbnRhdGlvbiBvZiB0aGlzIGZ1bmN0aW9uIGd1YXJhbnRlZXMgdGhhdCBTb21lIGlzXG4gICAgIHJldHVybmVkIG9ubHkgaWYgYSBwYXJ0IG9mIHRoZSB0cmFjZSBpcyB1c2FibGUuIFRoaXMgZ2l2ZXMgdXNcbiAgICAgYSBiaXQgbW9yZSB3b3JrIHRoYW4ganVzdCBjb252ZXJ0X3Jhd19iYWNrdHJhY2UsIGJ1dCBpdCBtYWtlcyB0aGVcbiAgICAgQVBJIG1vcmUgdXNlci1mcmllbmRseSAtLSBvdGhlcndpc2UgbW9zdCB1c2VycyB3b3VsZCBoYXZlIHRvXG4gICAgIHJlaW1wbGVtZW50IHRoZSBcIlByb2dyYW0gbm90IGxpbmtlZCB3aXRoIC1nLCBzb3JyeVwiIGxvZ2ljXG4gICAgIHRoZW1zZWx2ZXMuICopXG4gIG1hdGNoIGNvbnZlcnRfcmF3X2JhY2t0cmFjZSByYXdfYmFja3RyYWNlIHdpdGhcbiAgICB8IE5vbmUgLT4gTm9uZVxuICAgIHwgU29tZSBiYWNrdHJhY2UgLT5cbiAgICAgIGxldCB1c2FibGVfc2xvdCA9IGZ1bmN0aW9uXG4gICAgICAgIHwgVW5rbm93bl9sb2NhdGlvbiBfIC0+IGZhbHNlXG4gICAgICAgIHwgS25vd25fbG9jYXRpb24gXyAtPiB0cnVlIGluXG4gICAgICBsZXQgcmVjIGV4aXN0c191c2FibGUgPSBmdW5jdGlvblxuICAgICAgICB8ICgtMSkgLT4gZmFsc2VcbiAgICAgICAgfCBpIC0+IHVzYWJsZV9zbG90IGJhY2t0cmFjZS4oaSkgfHwgZXhpc3RzX3VzYWJsZSAoaSAtIDEpIGluXG4gICAgICBpZiBleGlzdHNfdXNhYmxlIChBcnJheS5sZW5ndGggYmFja3RyYWNlIC0gMSlcbiAgICAgIHRoZW4gU29tZSBiYWNrdHJhY2VcbiAgICAgIGVsc2UgTm9uZVxuXG5sZXQgYmFja3RyYWNlX3Nsb3RzX29mX3Jhd19lbnRyeSBlbnRyeSA9XG4gIGJhY2t0cmFjZV9zbG90cyBbfCBlbnRyeSB8XVxuXG5tb2R1bGUgU2xvdCA9IHN0cnVjdFxuICB0eXBlIHQgPSBiYWNrdHJhY2Vfc2xvdFxuICBsZXQgZm9ybWF0ID0gZm9ybWF0X2JhY2t0cmFjZV9zbG90XG4gIGxldCBpc19yYWlzZSA9IGJhY2t0cmFjZV9zbG90X2lzX3JhaXNlXG4gIGxldCBpc19pbmxpbmUgPSBiYWNrdHJhY2Vfc2xvdF9pc19pbmxpbmVcbiAgbGV0IGxvY2F0aW9uID0gYmFja3RyYWNlX3Nsb3RfbG9jYXRpb25cbiAgbGV0IG5hbWUgPSBiYWNrdHJhY2Vfc2xvdF9kZWZuYW1lXG5lbmRcblxubGV0IHJhd19iYWNrdHJhY2VfbGVuZ3RoIGJ0ID0gQXJyYXkubGVuZ3RoIGJ0XG5cbmV4dGVybmFsIGdldF9yYXdfYmFja3RyYWNlX3Nsb3QgOlxuICByYXdfYmFja3RyYWNlIC0+IGludCAtPiByYXdfYmFja3RyYWNlX3Nsb3QgPSBcImNhbWxfcmF3X2JhY2t0cmFjZV9zbG90XCJcblxuZXh0ZXJuYWwgZ2V0X3Jhd19iYWNrdHJhY2VfbmV4dF9zbG90IDpcbiAgcmF3X2JhY2t0cmFjZV9zbG90IC0+IHJhd19iYWNrdHJhY2Vfc2xvdCBvcHRpb25cbiAgPSBcImNhbWxfcmF3X2JhY2t0cmFjZV9uZXh0X3Nsb3RcIlxuXG4oKiBjb25mdXNpbmdseSBuYW1lZDpcbiAgIHJldHVybnMgdGhlICpzdHJpbmcqIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdsb2JhbCBjdXJyZW50IGJhY2t0cmFjZSAqKVxubGV0IGdldF9iYWNrdHJhY2UgKCkgPSByYXdfYmFja3RyYWNlX3RvX3N0cmluZyAoZ2V0X3Jhd19iYWNrdHJhY2UgKCkpXG5cbmV4dGVybmFsIHJlY29yZF9iYWNrdHJhY2U6IGJvb2wgLT4gdW5pdCA9IFwiY2FtbF9yZWNvcmRfYmFja3RyYWNlXCJcbmV4dGVybmFsIGJhY2t0cmFjZV9zdGF0dXM6IHVuaXQgLT4gYm9vbCA9IFwiY2FtbF9iYWNrdHJhY2Vfc3RhdHVzXCJcblxubGV0IHJlYyByZWdpc3Rlcl9wcmludGVyIGZuID1cbiAgbGV0IG9sZF9wcmludGVycyA9IEF0b21pYy5nZXQgcHJpbnRlcnMgaW5cbiAgbGV0IG5ld19wcmludGVycyA9IGZuIDo6IG9sZF9wcmludGVycyBpblxuICBsZXQgc3VjY2VzcyA9IEF0b21pYy5jb21wYXJlX2FuZF9zZXQgcHJpbnRlcnMgb2xkX3ByaW50ZXJzIG5ld19wcmludGVycyBpblxuICBpZiBub3Qgc3VjY2VzcyB0aGVuIHJlZ2lzdGVyX3ByaW50ZXIgZm5cblxuZXh0ZXJuYWwgZ2V0X2NhbGxzdGFjazogaW50IC0+IHJhd19iYWNrdHJhY2UgPSBcImNhbWxfZ2V0X2N1cnJlbnRfY2FsbHN0YWNrXCJcblxubGV0IGV4bl9zbG90IHggPVxuICBsZXQgeCA9IE9iai5yZXByIHggaW5cbiAgaWYgT2JqLnRhZyB4ID0gMCB0aGVuIE9iai5maWVsZCB4IDAgZWxzZSB4XG5cbmxldCBleG5fc2xvdF9pZCB4ID1cbiAgbGV0IHNsb3QgPSBleG5fc2xvdCB4IGluXG4gIChPYmoub2JqIChPYmouZmllbGQgc2xvdCAxKSA6IGludClcblxubGV0IGV4bl9zbG90X25hbWUgeCA9XG4gIGxldCBzbG90ID0gZXhuX3Nsb3QgeCBpblxuICAoT2JqLm9iaiAoT2JqLmZpZWxkIHNsb3QgMCkgOiBzdHJpbmcpXG5cbmV4dGVybmFsIGdldF9kZWJ1Z19pbmZvX3N0YXR1cyA6IHVuaXQgLT4gaW50ID0gXCJjYW1sX21sX2RlYnVnX2luZm9fc3RhdHVzXCJcblxuKCogRGVzY3JpcHRpb25zIGZvciBlcnJvcnMgaW4gc3RhcnR1cC5oLiBTZWUgYWxzbyBiYWNrdHJhY2UuYyAqKVxubGV0IGVycm9ycyA9IFt8IFwiXCI7XG4gICgqIEZJTEVfTk9UX0ZPVU5EICopXG4gIFwiKENhbm5vdCBwcmludCBsb2NhdGlvbnM6XFxuIFxcXG4gICAgICBieXRlY29kZSBleGVjdXRhYmxlIHByb2dyYW0gZmlsZSBub3QgZm91bmQpXCI7XG4gICgqIEJBRF9CWVRFQ09ERSAqKVxuICBcIihDYW5ub3QgcHJpbnQgbG9jYXRpb25zOlxcbiBcXFxuICAgICAgYnl0ZWNvZGUgZXhlY3V0YWJsZSBwcm9ncmFtIGZpbGUgYXBwZWFycyB0byBiZSBjb3JydXB0KVwiO1xuICAoKiBXUk9OR19NQUdJQyAqKVxuICBcIihDYW5ub3QgcHJpbnQgbG9jYXRpb25zOlxcbiBcXFxuICAgICAgYnl0ZWNvZGUgZXhlY3V0YWJsZSBwcm9ncmFtIGZpbGUgaGFzIHdyb25nIG1hZ2ljIG51bWJlcilcIjtcbiAgKCogTk9fRkRTICopXG4gIFwiKENhbm5vdCBwcmludCBsb2NhdGlvbnM6XFxuIFxcXG4gICAgICBieXRlY29kZSBleGVjdXRhYmxlIHByb2dyYW0gZmlsZSBjYW5ub3QgYmUgb3BlbmVkO1xcbiBcXFxuICAgICAgLS0gdG9vIG1hbnkgb3BlbiBmaWxlcy4gVHJ5IHJ1bm5pbmcgd2l0aCBPQ0FNTFJVTlBBUkFNPWI9MilcIlxufF1cblxubGV0IGRlZmF1bHRfdW5jYXVnaHRfZXhjZXB0aW9uX2hhbmRsZXIgZXhuIHJhd19iYWNrdHJhY2UgPVxuICBlcHJpbnRmIFwiRmF0YWwgZXJyb3I6IGV4Y2VwdGlvbiAlc1xcblwiICh0b19zdHJpbmcgZXhuKTtcbiAgcHJpbnRfcmF3X2JhY2t0cmFjZSBzdGRlcnIgcmF3X2JhY2t0cmFjZTtcbiAgbGV0IHN0YXR1cyA9IGdldF9kZWJ1Z19pbmZvX3N0YXR1cyAoKSBpblxuICBpZiBzdGF0dXMgPCAwIHRoZW5cbiAgICBwcmVycl9lbmRsaW5lIGVycm9ycy4oYWJzIHN0YXR1cyk7XG4gIGZsdXNoIHN0ZGVyclxuXG5sZXQgdW5jYXVnaHRfZXhjZXB0aW9uX2hhbmRsZXIgPSByZWYgZGVmYXVsdF91bmNhdWdodF9leGNlcHRpb25faGFuZGxlclxuXG5sZXQgc2V0X3VuY2F1Z2h0X2V4Y2VwdGlvbl9oYW5kbGVyIGZuID0gdW5jYXVnaHRfZXhjZXB0aW9uX2hhbmRsZXIgOj0gZm5cblxubGV0IGVtcHR5X2JhY2t0cmFjZSA6IHJhd19iYWNrdHJhY2UgPSBbfCB8XVxuXG5sZXQgdHJ5X2dldF9yYXdfYmFja3RyYWNlICgpID1cbiAgdHJ5XG4gICAgZ2V0X3Jhd19iYWNrdHJhY2UgKClcbiAgd2l0aCBfICgqIE91dF9vZl9tZW1vcnk/ICopIC0+XG4gICAgZW1wdHlfYmFja3RyYWNlXG5cbmxldCBoYW5kbGVfdW5jYXVnaHRfZXhjZXB0aW9uJyBleG4gZGVidWdnZXJfaW5fdXNlID1cbiAgdHJ5XG4gICAgKCogR2V0IHRoZSBiYWNrdHJhY2Ugbm93LCBpbiBjYXNlIG9uZSBvZiB0aGUgW2F0X2V4aXRdIGZ1bmN0aW9uXG4gICAgICAgZGVzdHJveXMgaXQuICopXG4gICAgbGV0IHJhd19iYWNrdHJhY2UgPVxuICAgICAgaWYgZGVidWdnZXJfaW5fdXNlICgqIFNhbWUgdGVzdCBhcyBpbiBbcnVudGltZS9wcmludGV4Yy5jXSAqKSB0aGVuXG4gICAgICAgIGVtcHR5X2JhY2t0cmFjZVxuICAgICAgZWxzZVxuICAgICAgICB0cnlfZ2V0X3Jhd19iYWNrdHJhY2UgKClcbiAgICBpblxuICAgICh0cnkgU3RkbGliLmRvX2F0X2V4aXQgKCkgd2l0aCBfIC0+ICgpKTtcbiAgICB0cnlcbiAgICAgICF1bmNhdWdodF9leGNlcHRpb25faGFuZGxlciBleG4gcmF3X2JhY2t0cmFjZVxuICAgIHdpdGggZXhuJyAtPlxuICAgICAgbGV0IHJhd19iYWNrdHJhY2UnID0gdHJ5X2dldF9yYXdfYmFja3RyYWNlICgpIGluXG4gICAgICBlcHJpbnRmIFwiRmF0YWwgZXJyb3I6IGV4Y2VwdGlvbiAlc1xcblwiICh0b19zdHJpbmcgZXhuKTtcbiAgICAgIHByaW50X3Jhd19iYWNrdHJhY2Ugc3RkZXJyIHJhd19iYWNrdHJhY2U7XG4gICAgICBlcHJpbnRmIFwiRmF0YWwgZXJyb3IgaW4gdW5jYXVnaHQgZXhjZXB0aW9uIGhhbmRsZXI6IGV4Y2VwdGlvbiAlc1xcblwiXG4gICAgICAgICh0b19zdHJpbmcgZXhuJyk7XG4gICAgICBwcmludF9yYXdfYmFja3RyYWNlIHN0ZGVyciByYXdfYmFja3RyYWNlJztcbiAgICAgIGZsdXNoIHN0ZGVyclxuICB3aXRoXG4gICAgfCBPdXRfb2ZfbWVtb3J5IC0+XG4gICAgICAgIHByZXJyX2VuZGxpbmVcbiAgICAgICAgICBcIkZhdGFsIGVycm9yOiBvdXQgb2YgbWVtb3J5IGluIHVuY2F1Z2h0IGV4Y2VwdGlvbiBoYW5kbGVyXCJcblxuKCogVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgYnkgW2NhbWxfZmF0YWxfdW5jYXVnaHRfZXhjZXB0aW9uXSBpblxuICAgW3J1bnRpbWUvcHJpbnRleGMuY10gd2hpY2ggZXhwZWN0cyBubyBleGNlcHRpb24gaXMgcmFpc2VkLiAqKVxubGV0IGhhbmRsZV91bmNhdWdodF9leGNlcHRpb24gZXhuIGRlYnVnZ2VyX2luX3VzZSA9XG4gIHRyeVxuICAgIGhhbmRsZV91bmNhdWdodF9leGNlcHRpb24nIGV4biBkZWJ1Z2dlcl9pbl91c2VcbiAgd2l0aCBfIC0+XG4gICAgKCogVGhlcmUgaXMgbm90IG11Y2ggd2UgY2FuIGRvIGF0IHRoaXMgcG9pbnQgKilcbiAgICAoKVxuXG5leHRlcm5hbCByZWdpc3Rlcl9uYW1lZF92YWx1ZSA6IHN0cmluZyAtPiAnYSAtPiB1bml0XG4gID0gXCJjYW1sX3JlZ2lzdGVyX25hbWVkX3ZhbHVlXCJcblxubGV0ICgpID1cbiAgcmVnaXN0ZXJfbmFtZWRfdmFsdWUgXCJQcmludGV4Yy5oYW5kbGVfdW5jYXVnaHRfZXhjZXB0aW9uXCJcbiAgICBoYW5kbGVfdW5jYXVnaHRfZXhjZXB0aW9uXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgWGF2aWVyIExlcm95IGFuZCBEYW1pZW4gRG9saWdleiwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbmxldCBnZW5lcmljX3F1b3RlIHF1b3RlcXVvdGUgcyA9XG4gIGxldCBsID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gIGxldCBiID0gQnVmZmVyLmNyZWF0ZSAobCArIDIwKSBpblxuICBCdWZmZXIuYWRkX2NoYXIgYiAnXFwnJztcbiAgZm9yIGkgPSAwIHRvIGwgLSAxIGRvXG4gICAgaWYgcy5baV0gPSAnXFwnJ1xuICAgIHRoZW4gQnVmZmVyLmFkZF9zdHJpbmcgYiBxdW90ZXF1b3RlXG4gICAgZWxzZSBCdWZmZXIuYWRkX2NoYXIgYiAgcy5baV1cbiAgZG9uZTtcbiAgQnVmZmVyLmFkZF9jaGFyIGIgJ1xcJyc7XG4gIEJ1ZmZlci5jb250ZW50cyBiXG5cbigqIFRoaXMgZnVuY3Rpb24gaW1wbGVtZW50cyB0aGUgT3BlbiBHcm91cCBzcGVjaWZpY2F0aW9uIGZvdW5kIGhlcmU6XG4gIFtbMV1dIGh0dHA6Ly9wdWJzLm9wZW5ncm91cC5vcmcvb25saW5lcHVicy85Njk5OTE5Nzk5L3V0aWxpdGllcy9iYXNlbmFtZS5odG1sXG4gIEluIHN0ZXAgMSBvZiBbWzFdXSwgd2UgY2hvb3NlIHRvIHJldHVybiBcIi5cIiBmb3IgZW1wdHkgaW5wdXQuXG4gICAgKGZvciBjb21wYXRpYmlsaXR5IHdpdGggcHJldmlvdXMgdmVyc2lvbnMgb2YgT0NhbWwpXG4gIEluIHN0ZXAgMiwgd2UgY2hvb3NlIHRvIHByb2Nlc3MgXCIvL1wiIG5vcm1hbGx5LlxuICBTdGVwIDYgaXMgbm90IGltcGxlbWVudGVkOiB3ZSBjb25zaWRlciB0aGF0IHRoZSBbc3VmZml4XSBvcGVyYW5kIGlzXG4gICAgYWx3YXlzIGFic2VudC4gIFN1ZmZpeGVzIGFyZSBoYW5kbGVkIGJ5IFtjaG9wX3N1ZmZpeF0gYW5kIFtjaG9wX2V4dGVuc2lvbl0uXG4qKVxubGV0IGdlbmVyaWNfYmFzZW5hbWUgaXNfZGlyX3NlcCBjdXJyZW50X2Rpcl9uYW1lIG5hbWUgPVxuICBsZXQgcmVjIGZpbmRfZW5kIG4gPVxuICAgIGlmIG4gPCAwIHRoZW4gU3RyaW5nLnN1YiBuYW1lIDAgMVxuICAgIGVsc2UgaWYgaXNfZGlyX3NlcCBuYW1lIG4gdGhlbiBmaW5kX2VuZCAobiAtIDEpXG4gICAgZWxzZSBmaW5kX2JlZyBuIChuICsgMSlcbiAgYW5kIGZpbmRfYmVnIG4gcCA9XG4gICAgaWYgbiA8IDAgdGhlbiBTdHJpbmcuc3ViIG5hbWUgMCBwXG4gICAgZWxzZSBpZiBpc19kaXJfc2VwIG5hbWUgbiB0aGVuIFN0cmluZy5zdWIgbmFtZSAobiArIDEpIChwIC0gbiAtIDEpXG4gICAgZWxzZSBmaW5kX2JlZyAobiAtIDEpIHBcbiAgaW5cbiAgaWYgbmFtZSA9IFwiXCJcbiAgdGhlbiBjdXJyZW50X2Rpcl9uYW1lXG4gIGVsc2UgZmluZF9lbmQgKFN0cmluZy5sZW5ndGggbmFtZSAtIDEpXG5cbigqIFRoaXMgZnVuY3Rpb24gaW1wbGVtZW50cyB0aGUgT3BlbiBHcm91cCBzcGVjaWZpY2F0aW9uIGZvdW5kIGhlcmU6XG4gIFtbMl1dIGh0dHA6Ly9wdWJzLm9wZW5ncm91cC5vcmcvb25saW5lcHVicy85Njk5OTE5Nzk5L3V0aWxpdGllcy9kaXJuYW1lLmh0bWxcbiAgSW4gc3RlcCA2IG9mIFtbMl1dLCB3ZSBjaG9vc2UgdG8gcHJvY2VzcyBcIi8vXCIgbm9ybWFsbHkuXG4qKVxubGV0IGdlbmVyaWNfZGlybmFtZSBpc19kaXJfc2VwIGN1cnJlbnRfZGlyX25hbWUgbmFtZSA9XG4gIGxldCByZWMgdHJhaWxpbmdfc2VwIG4gPVxuICAgIGlmIG4gPCAwIHRoZW4gU3RyaW5nLnN1YiBuYW1lIDAgMVxuICAgIGVsc2UgaWYgaXNfZGlyX3NlcCBuYW1lIG4gdGhlbiB0cmFpbGluZ19zZXAgKG4gLSAxKVxuICAgIGVsc2UgYmFzZSBuXG4gIGFuZCBiYXNlIG4gPVxuICAgIGlmIG4gPCAwIHRoZW4gY3VycmVudF9kaXJfbmFtZVxuICAgIGVsc2UgaWYgaXNfZGlyX3NlcCBuYW1lIG4gdGhlbiBpbnRlcm1lZGlhdGVfc2VwIG5cbiAgICBlbHNlIGJhc2UgKG4gLSAxKVxuICBhbmQgaW50ZXJtZWRpYXRlX3NlcCBuID1cbiAgICBpZiBuIDwgMCB0aGVuIFN0cmluZy5zdWIgbmFtZSAwIDFcbiAgICBlbHNlIGlmIGlzX2Rpcl9zZXAgbmFtZSBuIHRoZW4gaW50ZXJtZWRpYXRlX3NlcCAobiAtIDEpXG4gICAgZWxzZSBTdHJpbmcuc3ViIG5hbWUgMCAobiArIDEpXG4gIGluXG4gIGlmIG5hbWUgPSBcIlwiXG4gIHRoZW4gY3VycmVudF9kaXJfbmFtZVxuICBlbHNlIHRyYWlsaW5nX3NlcCAoU3RyaW5nLmxlbmd0aCBuYW1lIC0gMSlcblxubW9kdWxlIHR5cGUgU1lTREVQUyA9IHNpZ1xuICB2YWwgbnVsbCA6IHN0cmluZ1xuICB2YWwgY3VycmVudF9kaXJfbmFtZSA6IHN0cmluZ1xuICB2YWwgcGFyZW50X2Rpcl9uYW1lIDogc3RyaW5nXG4gIHZhbCBkaXJfc2VwIDogc3RyaW5nXG4gIHZhbCBpc19kaXJfc2VwIDogc3RyaW5nIC0+IGludCAtPiBib29sXG4gIHZhbCBpc19yZWxhdGl2ZSA6IHN0cmluZyAtPiBib29sXG4gIHZhbCBpc19pbXBsaWNpdCA6IHN0cmluZyAtPiBib29sXG4gIHZhbCBjaGVja19zdWZmaXggOiBzdHJpbmcgLT4gc3RyaW5nIC0+IGJvb2xcbiAgdmFsIGNob3Bfc3VmZml4X29wdCA6IHN1ZmZpeDpzdHJpbmcgLT4gc3RyaW5nIC0+IHN0cmluZyBvcHRpb25cbiAgdmFsIHRlbXBfZGlyX25hbWUgOiBzdHJpbmdcbiAgdmFsIHF1b3RlIDogc3RyaW5nIC0+IHN0cmluZ1xuICB2YWwgcXVvdGVfY29tbWFuZCA6XG4gICAgc3RyaW5nIC0+ID9zdGRpbjogc3RyaW5nIC0+ID9zdGRvdXQ6IHN0cmluZyAtPiA/c3RkZXJyOiBzdHJpbmdcbiAgICAgICAgICAgLT4gc3RyaW5nIGxpc3QgLT4gc3RyaW5nXG4gIHZhbCBiYXNlbmFtZSA6IHN0cmluZyAtPiBzdHJpbmdcbiAgdmFsIGRpcm5hbWUgOiBzdHJpbmcgLT4gc3RyaW5nXG5lbmRcblxubW9kdWxlIFVuaXggOiBTWVNERVBTID0gc3RydWN0XG4gIGxldCBudWxsID0gXCIvZGV2L251bGxcIlxuICBsZXQgY3VycmVudF9kaXJfbmFtZSA9IFwiLlwiXG4gIGxldCBwYXJlbnRfZGlyX25hbWUgPSBcIi4uXCJcbiAgbGV0IGRpcl9zZXAgPSBcIi9cIlxuICBsZXQgaXNfZGlyX3NlcCBzIGkgPSBzLltpXSA9ICcvJ1xuICBsZXQgaXNfcmVsYXRpdmUgbiA9IFN0cmluZy5sZW5ndGggbiA8IDEgfHwgbi5bMF0gPD4gJy8nXG4gIGxldCBpc19pbXBsaWNpdCBuID1cbiAgICBpc19yZWxhdGl2ZSBuXG4gICAgJiYgKFN0cmluZy5sZW5ndGggbiA8IDIgfHwgU3RyaW5nLnN1YiBuIDAgMiA8PiBcIi4vXCIpXG4gICAgJiYgKFN0cmluZy5sZW5ndGggbiA8IDMgfHwgU3RyaW5nLnN1YiBuIDAgMyA8PiBcIi4uL1wiKVxuICBsZXQgY2hlY2tfc3VmZml4IG5hbWUgc3VmZiA9XG4gICAgU3RyaW5nLmxlbmd0aCBuYW1lID49IFN0cmluZy5sZW5ndGggc3VmZiAmJlxuICAgIFN0cmluZy5zdWIgbmFtZSAoU3RyaW5nLmxlbmd0aCBuYW1lIC0gU3RyaW5nLmxlbmd0aCBzdWZmKVxuICAgICAgICAgICAgICAgICAgICAoU3RyaW5nLmxlbmd0aCBzdWZmKSA9IHN1ZmZcblxuICBsZXQgY2hvcF9zdWZmaXhfb3B0IH5zdWZmaXggZmlsZW5hbWUgPVxuICAgIGxldCBsZW5fcyA9IFN0cmluZy5sZW5ndGggc3VmZml4IGFuZCBsZW5fZiA9IFN0cmluZy5sZW5ndGggZmlsZW5hbWUgaW5cbiAgICBpZiBsZW5fZiA+PSBsZW5fcyB0aGVuXG4gICAgICBsZXQgciA9IFN0cmluZy5zdWIgZmlsZW5hbWUgKGxlbl9mIC0gbGVuX3MpIGxlbl9zIGluXG4gICAgICBpZiByID0gc3VmZml4IHRoZW5cbiAgICAgICAgU29tZSAoU3RyaW5nLnN1YiBmaWxlbmFtZSAwIChsZW5fZiAtIGxlbl9zKSlcbiAgICAgIGVsc2VcbiAgICAgICAgTm9uZVxuICAgIGVsc2VcbiAgICAgIE5vbmVcblxuICBsZXQgdGVtcF9kaXJfbmFtZSA9XG4gICAgdHJ5IFN5cy5nZXRlbnYgXCJUTVBESVJcIiB3aXRoIE5vdF9mb3VuZCAtPiBcIi90bXBcIlxuICBsZXQgcXVvdGUgPSBnZW5lcmljX3F1b3RlIFwiJ1xcXFwnJ1wiXG4gIGxldCBxdW90ZV9jb21tYW5kIGNtZCA/c3RkaW4gP3N0ZG91dCA/c3RkZXJyIGFyZ3MgPVxuICAgIFN0cmluZy5jb25jYXQgXCIgXCIgKExpc3QubWFwIHF1b3RlIChjbWQgOjogYXJncykpXG4gICAgXiAobWF0Y2ggc3RkaW4gIHdpdGggTm9uZSAtPiBcIlwiIHwgU29tZSBmIC0+IFwiIDxcIiBeIHF1b3RlIGYpXG4gICAgXiAobWF0Y2ggc3Rkb3V0IHdpdGggTm9uZSAtPiBcIlwiIHwgU29tZSBmIC0+IFwiID5cIiBeIHF1b3RlIGYpXG4gICAgXiAobWF0Y2ggc3RkZXJyIHdpdGggTm9uZSAtPiBcIlwiIHwgU29tZSBmIC0+IGlmIHN0ZGVyciA9IHN0ZG91dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlbiBcIiAyPiYxXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgXCIgMj5cIiBeIHF1b3RlIGYpXG4gIGxldCBiYXNlbmFtZSA9IGdlbmVyaWNfYmFzZW5hbWUgaXNfZGlyX3NlcCBjdXJyZW50X2Rpcl9uYW1lXG4gIGxldCBkaXJuYW1lID0gZ2VuZXJpY19kaXJuYW1lIGlzX2Rpcl9zZXAgY3VycmVudF9kaXJfbmFtZVxuZW5kXG5cbm1vZHVsZSBXaW4zMiA6IFNZU0RFUFMgPSBzdHJ1Y3RcbiAgbGV0IG51bGwgPSBcIk5VTFwiXG4gIGxldCBjdXJyZW50X2Rpcl9uYW1lID0gXCIuXCJcbiAgbGV0IHBhcmVudF9kaXJfbmFtZSA9IFwiLi5cIlxuICBsZXQgZGlyX3NlcCA9IFwiXFxcXFwiXG4gIGxldCBpc19kaXJfc2VwIHMgaSA9IGxldCBjID0gcy5baV0gaW4gYyA9ICcvJyB8fCBjID0gJ1xcXFwnIHx8IGMgPSAnOidcbiAgbGV0IGlzX3JlbGF0aXZlIG4gPVxuICAgIChTdHJpbmcubGVuZ3RoIG4gPCAxIHx8IG4uWzBdIDw+ICcvJylcbiAgICAmJiAoU3RyaW5nLmxlbmd0aCBuIDwgMSB8fCBuLlswXSA8PiAnXFxcXCcpXG4gICAgJiYgKFN0cmluZy5sZW5ndGggbiA8IDIgfHwgbi5bMV0gPD4gJzonKVxuICBsZXQgaXNfaW1wbGljaXQgbiA9XG4gICAgaXNfcmVsYXRpdmUgblxuICAgICYmIChTdHJpbmcubGVuZ3RoIG4gPCAyIHx8IFN0cmluZy5zdWIgbiAwIDIgPD4gXCIuL1wiKVxuICAgICYmIChTdHJpbmcubGVuZ3RoIG4gPCAyIHx8IFN0cmluZy5zdWIgbiAwIDIgPD4gXCIuXFxcXFwiKVxuICAgICYmIChTdHJpbmcubGVuZ3RoIG4gPCAzIHx8IFN0cmluZy5zdWIgbiAwIDMgPD4gXCIuLi9cIilcbiAgICAmJiAoU3RyaW5nLmxlbmd0aCBuIDwgMyB8fCBTdHJpbmcuc3ViIG4gMCAzIDw+IFwiLi5cXFxcXCIpXG4gIGxldCBjaGVja19zdWZmaXggbmFtZSBzdWZmID1cbiAgIFN0cmluZy5sZW5ndGggbmFtZSA+PSBTdHJpbmcubGVuZ3RoIHN1ZmYgJiZcbiAgIChsZXQgcyA9IFN0cmluZy5zdWIgbmFtZSAoU3RyaW5nLmxlbmd0aCBuYW1lIC0gU3RyaW5nLmxlbmd0aCBzdWZmKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChTdHJpbmcubGVuZ3RoIHN1ZmYpIGluXG4gICAgU3RyaW5nLmxvd2VyY2FzZV9hc2NpaSBzID0gU3RyaW5nLmxvd2VyY2FzZV9hc2NpaSBzdWZmKVxuXG4gIGxldCBjaG9wX3N1ZmZpeF9vcHQgfnN1ZmZpeCBmaWxlbmFtZSA9XG4gICAgbGV0IGxlbl9zID0gU3RyaW5nLmxlbmd0aCBzdWZmaXggYW5kIGxlbl9mID0gU3RyaW5nLmxlbmd0aCBmaWxlbmFtZSBpblxuICAgIGlmIGxlbl9mID49IGxlbl9zIHRoZW5cbiAgICAgIGxldCByID0gU3RyaW5nLnN1YiBmaWxlbmFtZSAobGVuX2YgLSBsZW5fcykgbGVuX3MgaW5cbiAgICAgIGlmIFN0cmluZy5sb3dlcmNhc2VfYXNjaWkgciA9IFN0cmluZy5sb3dlcmNhc2VfYXNjaWkgc3VmZml4IHRoZW5cbiAgICAgICAgU29tZSAoU3RyaW5nLnN1YiBmaWxlbmFtZSAwIChsZW5fZiAtIGxlbl9zKSlcbiAgICAgIGVsc2VcbiAgICAgICAgTm9uZVxuICAgIGVsc2VcbiAgICAgIE5vbmVcblxuXG4gIGxldCB0ZW1wX2Rpcl9uYW1lID1cbiAgICB0cnkgU3lzLmdldGVudiBcIlRFTVBcIiB3aXRoIE5vdF9mb3VuZCAtPiBcIi5cIlxuICBsZXQgcXVvdGUgcyA9XG4gICAgbGV0IGwgPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgICBsZXQgYiA9IEJ1ZmZlci5jcmVhdGUgKGwgKyAyMCkgaW5cbiAgICBCdWZmZXIuYWRkX2NoYXIgYiAnXFxcIic7XG4gICAgbGV0IHJlYyBsb29wIGkgPVxuICAgICAgaWYgaSA9IGwgdGhlbiBCdWZmZXIuYWRkX2NoYXIgYiAnXFxcIicgZWxzZVxuICAgICAgbWF0Y2ggcy5baV0gd2l0aFxuICAgICAgfCAnXFxcIicgLT4gbG9vcF9icyAwIGk7XG4gICAgICB8ICdcXFxcJyAtPiBsb29wX2JzIDAgaTtcbiAgICAgIHwgYyAgICAtPiBCdWZmZXIuYWRkX2NoYXIgYiBjOyBsb29wIChpKzEpO1xuICAgIGFuZCBsb29wX2JzIG4gaSA9XG4gICAgICBpZiBpID0gbCB0aGVuIGJlZ2luXG4gICAgICAgIEJ1ZmZlci5hZGRfY2hhciBiICdcXFwiJztcbiAgICAgICAgYWRkX2JzIG47XG4gICAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgICBtYXRjaCBzLltpXSB3aXRoXG4gICAgICAgIHwgJ1xcXCInIC0+IGFkZF9icyAoMipuKzEpOyBCdWZmZXIuYWRkX2NoYXIgYiAnXFxcIic7IGxvb3AgKGkrMSk7XG4gICAgICAgIHwgJ1xcXFwnIC0+IGxvb3BfYnMgKG4rMSkgKGkrMSk7XG4gICAgICAgIHwgXyAgICAtPiBhZGRfYnMgbjsgbG9vcCBpXG4gICAgICBlbmRcbiAgICBhbmQgYWRkX2JzIG4gPSBmb3IgX2ogPSAxIHRvIG4gZG8gQnVmZmVyLmFkZF9jaGFyIGIgJ1xcXFwnOyBkb25lXG4gICAgaW5cbiAgICBsb29wIDA7XG4gICAgQnVmZmVyLmNvbnRlbnRzIGJcbigqXG5RdW90aW5nIGNvbW1hbmRzIGZvciBleGVjdXRpb24gYnkgY21kLmV4ZSBpcyBkaWZmaWN1bHQuXG4xLSBFYWNoIGFyZ3VtZW50IGlzIGZpcnN0IHF1b3RlZCB1c2luZyB0aGUgXCJxdW90ZVwiIGZ1bmN0aW9uIGFib3ZlLCB0b1xuICAgcHJvdGVjdCBpdCBhZ2FpbnN0IHRoZSBwcm9jZXNzaW5nIHBlcmZvcm1lZCBieSB0aGUgQyBydW50aW1lIHN5c3RlbSxcbiAgIHRoZW4gY21kLmV4ZSdzIHNwZWNpYWwgY2hhcmFjdGVycyBhcmUgZXNjYXBlZCB3aXRoICdeJywgdXNpbmdcbiAgIHRoZSBcInF1b3RlX2NtZFwiIGZ1bmN0aW9uIGJlbG93LiAgRm9yIG1vcmUgZGV0YWlscywgc2VlXG4gICBodHRwczovL2Jsb2dzLm1zZG4ubWljcm9zb2Z0LmNvbS90d2lzdHlsaXR0bGVwYXNzYWdlc2FsbGFsaWtlLzIwMTEvMDQvMjNcbjItIFRoZSBjb21tYW5kIGFuZCB0aGUgcmVkaXJlY3Rpb24gZmlsZXMsIGlmIGFueSwgbXVzdCBiZSBkb3VibGUtcXVvdGVkXG4gICBpbiBjYXNlIHRoZXkgY29udGFpbiBzcGFjZXMuICBUaGlzIHF1b3RpbmcgaXMgaW50ZXJwcmV0ZWQgYnkgY21kLmV4ZSxcbiAgIG5vdCBieSB0aGUgQyBydW50aW1lIHN5c3RlbSwgaGVuY2UgdGhlIFwicXVvdGVcIiBmdW5jdGlvbiBhYm92ZVxuICAgY2Fubm90IGJlIHVzZWQuICBUaGUgdHdvIGNoYXJhY3RlcnMgd2UgZG9uJ3Qga25vdyBob3cgdG8gcXVvdGVcbiAgIGluc2lkZSBhIGRvdWJsZS1xdW90ZWQgY21kLmV4ZSBzdHJpbmcgYXJlIGRvdWJsZS1xdW90ZSBhbmQgcGVyY2VudC5cbiAgIFdlIGp1c3QgZmFpbCBpZiB0aGUgY29tbWFuZCBuYW1lIG9yIHRoZSByZWRpcmVjdGlvbiBmaWxlIG5hbWVzXG4gICBjb250YWluIGEgZG91YmxlIHF1b3RlIChub3QgYWxsb3dlZCBpbiBXaW5kb3dzIGZpbGUgbmFtZXMsIGFueXdheSlcbiAgIG9yIGEgcGVyY2VudC4gIFNlZSBmdW5jdGlvbiBcInF1b3RlX2NtZF9maWxlbmFtZVwiIGJlbG93LlxuMy0gVGhlIHdob2xlIHN0cmluZyBwYXNzZWQgdG8gU3lzLmNvbW1hbmQgaXMgdGhlbiBlbmNsb3NlZCBpbiBkb3VibGVcbiAgIHF1b3Rlcywgd2hpY2ggYXJlIGltbWVkaWF0ZWx5IHN0cmlwcGVkIGJ5IGNtZC5leGUuICBPdGhlcndpc2UsXG4gICBzb21lIG9mIHRoZSBkb3VibGUgcXVvdGVzIGZyb20gc3RlcCAyIGFib3ZlIGNhbiBiZSBtaXNwYXJzZWQuXG4gICBTZWUgZS5nLiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvOTk2NTE0MVxuKilcbiAgbGV0IHF1b3RlX2NtZCBzID1cbiAgICBsZXQgYiA9IEJ1ZmZlci5jcmVhdGUgKFN0cmluZy5sZW5ndGggcyArIDIwKSBpblxuICAgIFN0cmluZy5pdGVyXG4gICAgICAoZnVuIGMgLT5cbiAgICAgICAgbWF0Y2ggYyB3aXRoXG4gICAgICAgIHwgJygnIHwgJyknIHwgJyEnIHwgJ14nIHwgJyUnIHwgJ1xcXCInIHwgJzwnIHwgJz4nIHwgJyYnIHwgJ3wnIC0+XG4gICAgICAgICAgICBCdWZmZXIuYWRkX2NoYXIgYiAnXic7IEJ1ZmZlci5hZGRfY2hhciBiIGNcbiAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICBCdWZmZXIuYWRkX2NoYXIgYiBjKVxuICAgICAgcztcbiAgICBCdWZmZXIuY29udGVudHMgYlxuICBsZXQgcXVvdGVfY21kX2ZpbGVuYW1lIGYgPVxuICAgIGlmIFN0cmluZy5jb250YWlucyBmICdcXFwiJyB8fCBTdHJpbmcuY29udGFpbnMgZiAnJScgdGhlblxuICAgICAgZmFpbHdpdGggKFwiRmlsZW5hbWUucXVvdGVfY29tbWFuZDogYmFkIGZpbGUgbmFtZSBcIiBeIGYpXG4gICAgZWxzZSBpZiBTdHJpbmcuY29udGFpbnMgZiAnICcgdGhlblxuICAgICAgXCJcXFwiXCIgXiBmIF4gXCJcXFwiXCJcbiAgICBlbHNlXG4gICAgICBmXG4gICgqIFJlZGlyZWN0aW9ucyBpbiBjbWQuZXhlOiBzZWUgaHR0cHM6Ly9zczY0LmNvbS9udC9zeW50YXgtcmVkaXJlY3Rpb24uaHRtbFxuICAgICBhbmQgaHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vZW4tdXMvcHJldmlvdXMtdmVyc2lvbnMvd2luZG93cy9pdC1wcm8vd2luZG93cy14cC9iYjQ5MDk4Mih2PXRlY2huZXQuMTApXG4gICopXG4gIGxldCBxdW90ZV9jb21tYW5kIGNtZCA/c3RkaW4gP3N0ZG91dCA/c3RkZXJyIGFyZ3MgPVxuICAgIFN0cmluZy5jb25jYXQgXCJcIiBbXG4gICAgICBcIlxcXCJcIjtcbiAgICAgIHF1b3RlX2NtZF9maWxlbmFtZSBjbWQ7XG4gICAgICBcIiBcIjtcbiAgICAgIHF1b3RlX2NtZCAoU3RyaW5nLmNvbmNhdCBcIiBcIiAoTGlzdC5tYXAgcXVvdGUgYXJncykpO1xuICAgICAgKG1hdGNoIHN0ZGluICB3aXRoIE5vbmUgLT4gXCJcIiB8IFNvbWUgZiAtPiBcIiA8XCIgXiBxdW90ZV9jbWRfZmlsZW5hbWUgZik7XG4gICAgICAobWF0Y2ggc3Rkb3V0IHdpdGggTm9uZSAtPiBcIlwiIHwgU29tZSBmIC0+IFwiID5cIiBeIHF1b3RlX2NtZF9maWxlbmFtZSBmKTtcbiAgICAgIChtYXRjaCBzdGRlcnIgd2l0aCBOb25lIC0+IFwiXCIgfCBTb21lIGYgLT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiBzdGRlcnIgPSBzdGRvdXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGVuIFwiIDI+JjFcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgXCIgMj5cIiBeIHF1b3RlX2NtZF9maWxlbmFtZSBmKTtcbiAgICAgIFwiXFxcIlwiXG4gICAgXVxuICBsZXQgaGFzX2RyaXZlIHMgPVxuICAgIGxldCBpc19sZXR0ZXIgPSBmdW5jdGlvblxuICAgICAgfCAnQScgLi4gJ1onIHwgJ2EnIC4uICd6JyAtPiB0cnVlXG4gICAgICB8IF8gLT4gZmFsc2VcbiAgICBpblxuICAgIFN0cmluZy5sZW5ndGggcyA+PSAyICYmIGlzX2xldHRlciBzLlswXSAmJiBzLlsxXSA9ICc6J1xuICBsZXQgZHJpdmVfYW5kX3BhdGggcyA9XG4gICAgaWYgaGFzX2RyaXZlIHNcbiAgICB0aGVuIChTdHJpbmcuc3ViIHMgMCAyLCBTdHJpbmcuc3ViIHMgMiAoU3RyaW5nLmxlbmd0aCBzIC0gMikpXG4gICAgZWxzZSAoXCJcIiwgcylcbiAgbGV0IGRpcm5hbWUgcyA9XG4gICAgbGV0IChkcml2ZSwgcGF0aCkgPSBkcml2ZV9hbmRfcGF0aCBzIGluXG4gICAgbGV0IGRpciA9IGdlbmVyaWNfZGlybmFtZSBpc19kaXJfc2VwIGN1cnJlbnRfZGlyX25hbWUgcGF0aCBpblxuICAgIGRyaXZlIF4gZGlyXG4gIGxldCBiYXNlbmFtZSBzID1cbiAgICBsZXQgKF9kcml2ZSwgcGF0aCkgPSBkcml2ZV9hbmRfcGF0aCBzIGluXG4gICAgZ2VuZXJpY19iYXNlbmFtZSBpc19kaXJfc2VwIGN1cnJlbnRfZGlyX25hbWUgcGF0aFxuZW5kXG5cbm1vZHVsZSBDeWd3aW4gOiBTWVNERVBTID0gc3RydWN0XG4gIGxldCBudWxsID0gXCIvZGV2L251bGxcIlxuICBsZXQgY3VycmVudF9kaXJfbmFtZSA9IFwiLlwiXG4gIGxldCBwYXJlbnRfZGlyX25hbWUgPSBcIi4uXCJcbiAgbGV0IGRpcl9zZXAgPSBcIi9cIlxuICBsZXQgaXNfZGlyX3NlcCA9IFdpbjMyLmlzX2Rpcl9zZXBcbiAgbGV0IGlzX3JlbGF0aXZlID0gV2luMzIuaXNfcmVsYXRpdmVcbiAgbGV0IGlzX2ltcGxpY2l0ID0gV2luMzIuaXNfaW1wbGljaXRcbiAgbGV0IGNoZWNrX3N1ZmZpeCA9IFdpbjMyLmNoZWNrX3N1ZmZpeFxuICBsZXQgY2hvcF9zdWZmaXhfb3B0ID0gV2luMzIuY2hvcF9zdWZmaXhfb3B0XG4gIGxldCB0ZW1wX2Rpcl9uYW1lID0gVW5peC50ZW1wX2Rpcl9uYW1lXG4gIGxldCBxdW90ZSA9IFVuaXgucXVvdGVcbiAgbGV0IHF1b3RlX2NvbW1hbmQgPSBVbml4LnF1b3RlX2NvbW1hbmRcbiAgbGV0IGJhc2VuYW1lID0gZ2VuZXJpY19iYXNlbmFtZSBpc19kaXJfc2VwIGN1cnJlbnRfZGlyX25hbWVcbiAgbGV0IGRpcm5hbWUgPSBnZW5lcmljX2Rpcm5hbWUgaXNfZGlyX3NlcCBjdXJyZW50X2Rpcl9uYW1lXG5lbmRcblxubW9kdWxlIFN5c2RlcHMgPVxuICAodmFsIChtYXRjaCBTeXMub3NfdHlwZSB3aXRoXG4gICAgICAgfCBcIldpbjMyXCIgLT4gKG1vZHVsZSBXaW4zMjogU1lTREVQUylcbiAgICAgICB8IFwiQ3lnd2luXCIgLT4gKG1vZHVsZSBDeWd3aW46IFNZU0RFUFMpXG4gICAgICAgfCBfIC0+IChtb2R1bGUgVW5peDogU1lTREVQUykpKVxuXG5pbmNsdWRlIFN5c2RlcHNcblxubGV0IGNvbmNhdCBkaXJuYW1lIGZpbGVuYW1lID1cbiAgbGV0IGwgPSBTdHJpbmcubGVuZ3RoIGRpcm5hbWUgaW5cbiAgaWYgbCA9IDAgfHwgaXNfZGlyX3NlcCBkaXJuYW1lIChsLTEpXG4gIHRoZW4gZGlybmFtZSBeIGZpbGVuYW1lXG4gIGVsc2UgZGlybmFtZSBeIGRpcl9zZXAgXiBmaWxlbmFtZVxuXG5sZXQgY2hvcF9zdWZmaXggbmFtZSBzdWZmID1cbiAgbGV0IG4gPSBTdHJpbmcubGVuZ3RoIG5hbWUgLSBTdHJpbmcubGVuZ3RoIHN1ZmYgaW5cbiAgaWYgbiA8IDAgdGhlbiBpbnZhbGlkX2FyZyBcIkZpbGVuYW1lLmNob3Bfc3VmZml4XCIgZWxzZSBTdHJpbmcuc3ViIG5hbWUgMCBuXG5cbmxldCBleHRlbnNpb25fbGVuIG5hbWUgPVxuICBsZXQgcmVjIGNoZWNrIGkwIGkgPVxuICAgIGlmIGkgPCAwIHx8IGlzX2Rpcl9zZXAgbmFtZSBpIHRoZW4gMFxuICAgIGVsc2UgaWYgbmFtZS5baV0gPSAnLicgdGhlbiBjaGVjayBpMCAoaSAtIDEpXG4gICAgZWxzZSBTdHJpbmcubGVuZ3RoIG5hbWUgLSBpMFxuICBpblxuICBsZXQgcmVjIHNlYXJjaF9kb3QgaSA9XG4gICAgaWYgaSA8IDAgfHwgaXNfZGlyX3NlcCBuYW1lIGkgdGhlbiAwXG4gICAgZWxzZSBpZiBuYW1lLltpXSA9ICcuJyB0aGVuIGNoZWNrIGkgKGkgLSAxKVxuICAgIGVsc2Ugc2VhcmNoX2RvdCAoaSAtIDEpXG4gIGluXG4gIHNlYXJjaF9kb3QgKFN0cmluZy5sZW5ndGggbmFtZSAtIDEpXG5cbmxldCBleHRlbnNpb24gbmFtZSA9XG4gIGxldCBsID0gZXh0ZW5zaW9uX2xlbiBuYW1lIGluXG4gIGlmIGwgPSAwIHRoZW4gXCJcIiBlbHNlIFN0cmluZy5zdWIgbmFtZSAoU3RyaW5nLmxlbmd0aCBuYW1lIC0gbCkgbFxuXG5sZXQgY2hvcF9leHRlbnNpb24gbmFtZSA9XG4gIGxldCBsID0gZXh0ZW5zaW9uX2xlbiBuYW1lIGluXG4gIGlmIGwgPSAwIHRoZW4gaW52YWxpZF9hcmcgXCJGaWxlbmFtZS5jaG9wX2V4dGVuc2lvblwiXG4gIGVsc2UgU3RyaW5nLnN1YiBuYW1lIDAgKFN0cmluZy5sZW5ndGggbmFtZSAtIGwpXG5cbmxldCByZW1vdmVfZXh0ZW5zaW9uIG5hbWUgPVxuICBsZXQgbCA9IGV4dGVuc2lvbl9sZW4gbmFtZSBpblxuICBpZiBsID0gMCB0aGVuIG5hbWUgZWxzZSBTdHJpbmcuc3ViIG5hbWUgMCAoU3RyaW5nLmxlbmd0aCBuYW1lIC0gbClcblxuZXh0ZXJuYWwgb3Blbl9kZXNjOiBzdHJpbmcgLT4gb3Blbl9mbGFnIGxpc3QgLT4gaW50IC0+IGludCA9IFwiY2FtbF9zeXNfb3BlblwiXG5leHRlcm5hbCBjbG9zZV9kZXNjOiBpbnQgLT4gdW5pdCA9IFwiY2FtbF9zeXNfY2xvc2VcIlxuXG5sZXQgcHJuZyA9IGxhenkoUmFuZG9tLlN0YXRlLm1ha2Vfc2VsZl9pbml0ICgpKVxuXG5sZXQgdGVtcF9maWxlX25hbWUgdGVtcF9kaXIgcHJlZml4IHN1ZmZpeCA9XG4gIGxldCBybmQgPSAoUmFuZG9tLlN0YXRlLmJpdHMgKExhenkuZm9yY2UgcHJuZykpIGxhbmQgMHhGRkZGRkYgaW5cbiAgY29uY2F0IHRlbXBfZGlyIChQcmludGYuc3ByaW50ZiBcIiVzJTA2eCVzXCIgcHJlZml4IHJuZCBzdWZmaXgpXG5cblxubGV0IGN1cnJlbnRfdGVtcF9kaXJfbmFtZSA9IHJlZiB0ZW1wX2Rpcl9uYW1lXG5cbmxldCBzZXRfdGVtcF9kaXJfbmFtZSBzID0gY3VycmVudF90ZW1wX2Rpcl9uYW1lIDo9IHNcbmxldCBnZXRfdGVtcF9kaXJfbmFtZSAoKSA9ICFjdXJyZW50X3RlbXBfZGlyX25hbWVcblxubGV0IHRlbXBfZmlsZSA/KHRlbXBfZGlyID0gIWN1cnJlbnRfdGVtcF9kaXJfbmFtZSkgcHJlZml4IHN1ZmZpeCA9XG4gIGxldCByZWMgdHJ5X25hbWUgY291bnRlciA9XG4gICAgbGV0IG5hbWUgPSB0ZW1wX2ZpbGVfbmFtZSB0ZW1wX2RpciBwcmVmaXggc3VmZml4IGluXG4gICAgdHJ5XG4gICAgICBjbG9zZV9kZXNjKG9wZW5fZGVzYyBuYW1lIFtPcGVuX3dyb25seTsgT3Blbl9jcmVhdDsgT3Blbl9leGNsXSAwbzYwMCk7XG4gICAgICBuYW1lXG4gICAgd2l0aCBTeXNfZXJyb3IgXyBhcyBlIC0+XG4gICAgICBpZiBjb3VudGVyID49IDEwMDAgdGhlbiByYWlzZSBlIGVsc2UgdHJ5X25hbWUgKGNvdW50ZXIgKyAxKVxuICBpbiB0cnlfbmFtZSAwXG5cbmxldCBvcGVuX3RlbXBfZmlsZSA/KG1vZGUgPSBbT3Blbl90ZXh0XSkgPyhwZXJtcyA9IDBvNjAwKVxuICAgICAgICAgICAgICAgICAgID8odGVtcF9kaXIgPSAhY3VycmVudF90ZW1wX2Rpcl9uYW1lKSBwcmVmaXggc3VmZml4ID1cbiAgbGV0IHJlYyB0cnlfbmFtZSBjb3VudGVyID1cbiAgICBsZXQgbmFtZSA9IHRlbXBfZmlsZV9uYW1lIHRlbXBfZGlyIHByZWZpeCBzdWZmaXggaW5cbiAgICB0cnlcbiAgICAgIChuYW1lLFxuICAgICAgIG9wZW5fb3V0X2dlbiAoT3Blbl93cm9ubHk6Ok9wZW5fY3JlYXQ6Ok9wZW5fZXhjbDo6bW9kZSkgcGVybXMgbmFtZSlcbiAgICB3aXRoIFN5c19lcnJvciBfIGFzIGUgLT5cbiAgICAgIGlmIGNvdW50ZXIgPj0gMTAwMCB0aGVuIHJhaXNlIGUgZWxzZSB0cnlfbmFtZSAoY291bnRlciArIDEpXG4gIGluIHRyeV9uYW1lIDBcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMDIgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogQ29tcGxleCBudW1iZXJzICopXG5cbnR5cGUgdCA9IHsgcmU6IGZsb2F0OyBpbTogZmxvYXQgfVxuXG5sZXQgemVybyA9IHsgcmUgPSAwLjA7IGltID0gMC4wIH1cbmxldCBvbmUgPSB7IHJlID0gMS4wOyBpbSA9IDAuMCB9XG5sZXQgaSA9IHsgcmUgPSAwLjA7IGltID0gMS4wIH1cblxubGV0IGFkZCB4IHkgPSB7IHJlID0geC5yZSArLiB5LnJlOyBpbSA9IHguaW0gKy4geS5pbSB9XG5cbmxldCBzdWIgeCB5ID0geyByZSA9IHgucmUgLS4geS5yZTsgaW0gPSB4LmltIC0uIHkuaW0gfVxuXG5sZXQgbmVnIHggPSB7IHJlID0gLS4geC5yZTsgaW0gPSAtLiB4LmltIH1cblxubGV0IGNvbmogeCA9IHsgcmUgPSB4LnJlOyBpbSA9IC0uIHguaW0gfVxuXG5sZXQgbXVsIHggeSA9IHsgcmUgPSB4LnJlICouIHkucmUgLS4geC5pbSAqLiB5LmltO1xuICAgICAgICAgICAgICAgIGltID0geC5yZSAqLiB5LmltICsuIHguaW0gKi4geS5yZSB9XG5cbmxldCBkaXYgeCB5ID1cbiAgaWYgYWJzX2Zsb2F0IHkucmUgPj0gYWJzX2Zsb2F0IHkuaW0gdGhlblxuICAgIGxldCByID0geS5pbSAvLiB5LnJlIGluXG4gICAgbGV0IGQgPSB5LnJlICsuIHIgKi4geS5pbSBpblxuICAgIHsgcmUgPSAoeC5yZSArLiByICouIHguaW0pIC8uIGQ7XG4gICAgICBpbSA9ICh4LmltIC0uIHIgKi4geC5yZSkgLy4gZCB9XG4gIGVsc2VcbiAgICBsZXQgciA9IHkucmUgLy4geS5pbSBpblxuICAgIGxldCBkID0geS5pbSArLiByICouIHkucmUgaW5cbiAgICB7IHJlID0gKHIgKi4geC5yZSArLiB4LmltKSAvLiBkO1xuICAgICAgaW0gPSAociAqLiB4LmltIC0uIHgucmUpIC8uIGQgfVxuXG5sZXQgaW52IHggPSBkaXYgb25lIHhcblxubGV0IG5vcm0yIHggPSB4LnJlICouIHgucmUgKy4geC5pbSAqLiB4LmltXG5cbmxldCBub3JtIHggPVxuICAoKiBXYXRjaCBvdXQgZm9yIG92ZXJmbG93IGluIGNvbXB1dGluZyByZV4yICsgaW1eMiAqKVxuICBsZXQgciA9IGFic19mbG9hdCB4LnJlIGFuZCBpID0gYWJzX2Zsb2F0IHguaW0gaW5cbiAgaWYgciA9IDAuMCB0aGVuIGlcbiAgZWxzZSBpZiBpID0gMC4wIHRoZW4gclxuICBlbHNlIGlmIHIgPj0gaSB0aGVuXG4gICAgbGV0IHEgPSBpIC8uIHIgaW4gciAqLiBzcXJ0KDEuMCArLiBxICouIHEpXG4gIGVsc2VcbiAgICBsZXQgcSA9IHIgLy4gaSBpbiBpICouIHNxcnQoMS4wICsuIHEgKi4gcSlcblxubGV0IGFyZyB4ID0gYXRhbjIgeC5pbSB4LnJlXG5cbmxldCBwb2xhciBuIGEgPSB7IHJlID0gY29zIGEgKi4gbjsgaW0gPSBzaW4gYSAqLiBuIH1cblxubGV0IHNxcnQgeCA9XG4gIGlmIHgucmUgPSAwLjAgJiYgeC5pbSA9IDAuMCB0aGVuIHsgcmUgPSAwLjA7IGltID0gMC4wIH1cbiAgZWxzZSBiZWdpblxuICAgIGxldCByID0gYWJzX2Zsb2F0IHgucmUgYW5kIGkgPSBhYnNfZmxvYXQgeC5pbSBpblxuICAgIGxldCB3ID1cbiAgICAgIGlmIHIgPj0gaSB0aGVuIGJlZ2luXG4gICAgICAgIGxldCBxID0gaSAvLiByIGluXG4gICAgICAgIHNxcnQocikgKi4gc3FydCgwLjUgKi4gKDEuMCArLiBzcXJ0KDEuMCArLiBxICouIHEpKSlcbiAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgIGxldCBxID0gciAvLiBpIGluXG4gICAgICAgIHNxcnQoaSkgKi4gc3FydCgwLjUgKi4gKHEgKy4gc3FydCgxLjAgKy4gcSAqLiBxKSkpXG4gICAgICBlbmQgaW5cbiAgICBpZiB4LnJlID49IDAuMFxuICAgIHRoZW4geyByZSA9IHc7ICBpbSA9IDAuNSAqLiB4LmltIC8uIHcgfVxuICAgIGVsc2UgeyByZSA9IDAuNSAqLiBpIC8uIHc7ICBpbSA9IGlmIHguaW0gPj0gMC4wIHRoZW4gdyBlbHNlIC0uIHcgfVxuICBlbmRcblxubGV0IGV4cCB4ID1cbiAgbGV0IGUgPSBleHAgeC5yZSBpbiB7IHJlID0gZSAqLiBjb3MgeC5pbTsgaW0gPSBlICouIHNpbiB4LmltIH1cblxubGV0IGxvZyB4ID0geyByZSA9IGxvZyAobm9ybSB4KTsgaW0gPSBhdGFuMiB4LmltIHgucmUgfVxuXG5sZXQgcG93IHggeSA9IGV4cCAobXVsIHkgKGxvZyB4KSlcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICBCZW5vaXQgVmF1Z29uLCBFTlNUQSAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMTQgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogUGFkZGluZyBwb3NpdGlvbi4gKilcbnR5cGUgcGFkdHkgPVxuICB8IExlZnQgICAoKiBUZXh0IGlzIGxlZnQganVzdGlmaWVkICgnLScgb3B0aW9uKS4gICAgICAgICAgICAgICAqKVxuICB8IFJpZ2h0ICAoKiBUZXh0IGlzIHJpZ2h0IGp1c3RpZmllZCAobm8gJy0nIG9wdGlvbikuICAgICAgICAgICAqKVxuICB8IFplcm9zICAoKiBUZXh0IGlzIHJpZ2h0IGp1c3RpZmllZCBieSB6ZXJvcyAoc2VlICcwJyBvcHRpb24pLiAqKVxuXG4oKioqKVxuXG4oKiBJbnRlZ2VyIGNvbnZlcnNpb24uICopXG50eXBlIGludF9jb252ID1cbiAgfCBJbnRfZCB8IEludF9wZCB8IEludF9zZCAgICAgICAgKCogICVkIHwgJStkIHwgJSBkICAqKVxuICB8IEludF9pIHwgSW50X3BpIHwgSW50X3NpICAgICAgICAoKiAgJWkgfCAlK2kgfCAlIGkgICopXG4gIHwgSW50X3ggfCBJbnRfQ3ggICAgICAgICAgICAgICAgICgqICAleCB8ICUjeCAgICAgICAgKilcbiAgfCBJbnRfWCB8IEludF9DWCAgICAgICAgICAgICAgICAgKCogICVYIHwgJSNYICAgICAgICAqKVxuICB8IEludF9vIHwgSW50X0NvICAgICAgICAgICAgICAgICAoKiAgJW8gfCAlI28gICAgICAgICopXG4gIHwgSW50X3UgICAgICAgICAgICAgICAgICAgICAgICAgICgqICAldSAgICAgICAgICAgICAgKilcbiAgfCBJbnRfQ2QgfCBJbnRfQ2kgfCBJbnRfQ3UgICAgICAgKCogICUjZCB8ICUjaSB8ICUjdSAqKVxuXG4oKiBGbG9hdCBjb252ZXJzaW9uLiAqKVxudHlwZSBmbG9hdF9mbGFnX2NvbnYgPVxuICB8IEZsb2F0X2ZsYWdfICAgICAgICAgICAgICAgICAgICAoKiAlW2ZlRWdHRmhIXSAqKVxuICB8IEZsb2F0X2ZsYWdfcCAgICAgICAgICAgICAgICAgICAoKiAlK1tmZUVnR0ZoSF0gKilcbiAgfCBGbG9hdF9mbGFnX3MgICAgICAgICAgICAgICAgICAgKCogJSBbZmVFZ0dGaEhdICopXG50eXBlIGZsb2F0X2tpbmRfY29udiA9XG4gIHwgRmxvYXRfZiAgICAgICAgICAgICAgICAgICAgICAgICgqICAlZiB8ICUrZiB8ICUgZiAgKilcbiAgfCBGbG9hdF9lICAgICAgICAgICAgICAgICAgICAgICAgKCogICVlIHwgJStlIHwgJSBlICAqKVxuICB8IEZsb2F0X0UgICAgICAgICAgICAgICAgICAgICAgICAoKiAgJUUgfCAlK0UgfCAlIEUgICopXG4gIHwgRmxvYXRfZyAgICAgICAgICAgICAgICAgICAgICAgICgqICAlZyB8ICUrZyB8ICUgZyAgKilcbiAgfCBGbG9hdF9HICAgICAgICAgICAgICAgICAgICAgICAgKCogICVHIHwgJStHIHwgJSBHICAqKVxuICB8IEZsb2F0X0YgICAgICAgICAgICAgICAgICAgICAgICAoKiAgJUYgfCAlK0YgfCAlIEYgICopXG4gIHwgRmxvYXRfaCAgICAgICAgICAgICAgICAgICAgICAgICgqICAlaCB8ICUraCB8ICUgaCAgKilcbiAgfCBGbG9hdF9IICAgICAgICAgICAgICAgICAgICAgICAgKCogICVIIHwgJStIIHwgJSBIICAqKVxuICB8IEZsb2F0X0NGICAgICAgICAgICAgICAgICAgICAgICAoKiAgJSNGfCAlKyNGfCAlICNGICopXG50eXBlIGZsb2F0X2NvbnYgPSBmbG9hdF9mbGFnX2NvbnYgKiBmbG9hdF9raW5kX2NvbnZcblxuKCoqKilcblxuKCogQ2hhciBzZXRzIChzZWUgJVsuLi5dKSBhcmUgYml0bWFwcyBpbXBsZW1lbnRlZCBhcyAzMi1jaGFyIHN0cmluZ3MuICopXG50eXBlIGNoYXJfc2V0ID0gc3RyaW5nXG5cbigqKiopXG5cbigqIENvdW50ZXIgdXNlZCBpbiBTY2FuZi4gKilcbnR5cGUgY291bnRlciA9XG4gIHwgTGluZV9jb3VudGVyICAgICAoKiAgJWwgICAgICAqKVxuICB8IENoYXJfY291bnRlciAgICAgKCogICVuICAgICAgKilcbiAgfCBUb2tlbl9jb3VudGVyICAgICgqICAlTiwgJUwgICopXG5cbigqKiopXG5cbigqIFBhZGRpbmcgb2Ygc3RyaW5ncyBhbmQgbnVtYmVycy4gKilcbnR5cGUgKCdhLCAnYikgcGFkZGluZyA9XG4gICgqIE5vIHBhZGRpbmcgKGV4OiBcIiVkXCIpICopXG4gIHwgTm9fcGFkZGluZyAgOiAoJ2EsICdhKSBwYWRkaW5nXG4gICgqIExpdGVyYWwgcGFkZGluZyAoZXg6IFwiJThkXCIpICopXG4gIHwgTGl0X3BhZGRpbmcgOiBwYWR0eSAqIGludCAtPiAoJ2EsICdhKSBwYWRkaW5nXG4gICgqIFBhZGRpbmcgYXMgZXh0cmEgYXJndW1lbnQgKGV4OiBcIiUqZFwiKSAqKVxuICB8IEFyZ19wYWRkaW5nIDogcGFkdHkgLT4gKGludCAtPiAnYSwgJ2EpIHBhZGRpbmdcblxuKCogU29tZSBmb3JtYXRzLCBzdWNoIGFzICVfZCxcbiAgIG9ubHkgYWNjZXB0IGFuIG9wdGlvbmFsIG51bWJlciBhcyBwYWRkaW5nIG9wdGlvbiAobm8gZXh0cmEgYXJndW1lbnQpICopXG50eXBlIHBhZF9vcHRpb24gPSBpbnQgb3B0aW9uXG5cbigqIFByZWNpc2lvbiBvZiBmbG9hdHMgYW5kICcwJy1wYWRkaW5nIG9mIGludGVnZXJzLiAqKVxudHlwZSAoJ2EsICdiKSBwcmVjaXNpb24gPVxuICAoKiBObyBwcmVjaXNpb24gKGV4OiBcIiVmXCIpICopXG4gIHwgTm9fcHJlY2lzaW9uIDogKCdhLCAnYSkgcHJlY2lzaW9uXG4gICgqIExpdGVyYWwgcHJlY2lzaW9uIChleDogXCIlLjNmXCIpICopXG4gIHwgTGl0X3ByZWNpc2lvbiA6IGludCAtPiAoJ2EsICdhKSBwcmVjaXNpb25cbiAgKCogUHJlY2lzaW9uIGFzIGV4dHJhIGFyZ3VtZW50IChleDogXCIlLipmXCIpICopXG4gIHwgQXJnX3ByZWNpc2lvbiA6IChpbnQgLT4gJ2EsICdhKSBwcmVjaXNpb25cblxuKCogU29tZSBmb3JtYXRzLCBzdWNoIGFzICVfZixcbiAgIG9ubHkgYWNjZXB0IGFuIG9wdGlvbmFsIG51bWJlciBhcyBwcmVjaXNpb24gb3B0aW9uIChubyBleHRyYSBhcmd1bWVudCkgKilcbnR5cGUgcHJlY19vcHRpb24gPSBpbnQgb3B0aW9uXG5cbigqIHNlZSB0aGUgQ3VzdG9tIGZvcm1hdCBjb21iaW5hdG9yICopXG50eXBlICgnYSwgJ2IsICdjKSBjdXN0b21fYXJpdHkgPVxuICB8IEN1c3RvbV96ZXJvIDogKCdhLCBzdHJpbmcsICdhKSBjdXN0b21fYXJpdHlcbiAgfCBDdXN0b21fc3VjYyA6ICgnYSwgJ2IsICdjKSBjdXN0b21fYXJpdHkgLT5cbiAgICAoJ2EsICd4IC0+ICdiLCAneCAtPiAnYykgY3VzdG9tX2FyaXR5XG5cbigqKiopXG5cbigqICAgICAgICBSZWxhdGlvbmFsIGZvcm1hdCB0eXBlc1xuXG5JbiB0aGUgZmlyc3QgZm9ybWF0K2dhZHRzIGltcGxlbWVudGF0aW9uLCB0aGUgdHlwZSBmb3IgJSguLiUpIGluIHRoZVxuZm10IEdBRFQgd2FzIGFzIGZvbGxvd3M6XG5cbnwgRm9ybWF0X3N1YnN0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJSguLi4lKSAqKVxuICAgIHBhZF9vcHRpb24gKiAoJ2QxLCAncTEsICdkMiwgJ3EyKSByZWFkZXJfbmJfdW5pZmllciAqXG4gICAgKCd4LCAnYiwgJ2MsICdkMSwgJ3ExLCAndSkgZm10dHkgKlxuICAgICgndSwgJ2IsICdjLCAncTEsICdlMSwgJ2YpIGZtdCAtPlxuICAgICAgKCgneCwgJ2IsICdjLCAnZDIsICdxMiwgJ3UpIGZvcm1hdDYgLT4gJ3gsICdiLCAnYywgJ2QxLCAnZTEsICdmKSBmbXRcblxuTm90aWNlIHRoYXQgdGhlICd1IHBhcmFtZXRlciBpbiAnZiBwb3NpdGlvbiBpbiB0aGUgZm9ybWF0IGFyZ3VtZW50XG4oKCd4LCAuLiwgJ3UpIGZvcm1hdDYgLT4gLi4pIGlzIGVxdWFsIHRvIHRoZSAndSBwYXJhbWV0ZXIgaW4gJ2FcbnBvc2l0aW9uIGluIHRoZSBmb3JtYXQgdGFpbCAoKCd1LCAuLiwgJ2YpIGZtdCkuIFRoaXMgbWVhbnMgdGhhdCB0aGVcbnR5cGUgb2YgdGhlIGV4cGVjdGVkIGZvcm1hdCBwYXJhbWV0ZXIgZGVwZW5kcyBvZiB3aGVyZSB0aGUgJSguLi4lKVxuYXJlIGluIHRoZSBmb3JtYXQgc3RyaW5nOlxuXG4gICMgUHJpbnRmLnByaW50ZiBcIiUoJSlcIlxuICAtIDogKHVuaXQsIG91dF9jaGFubmVsLCB1bml0LCAnX2EsICdfYSwgdW5pdClcbiAgICAgIENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljcy5mb3JtYXQ2IC0+IHVuaXRcbiAgPSA8ZnVuPlxuICAjIFByaW50Zi5wcmludGYgXCIlKCUpJWRcIlxuICAtIDogKGludCAtPiB1bml0LCBvdXRfY2hhbm5lbCwgdW5pdCwgJ19hLCAnX2EsIGludCAtPiB1bml0KVxuICAgICAgQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzLmZvcm1hdDYgLT4gaW50IC0+IHVuaXRcbiAgPSA8ZnVuPlxuXG5PbiB0aGUgY29udHJhcnksIHRoZSBsZWdhY3kgdHlwZXIgZ2l2ZXMgYSBjbGV2ZXIgdHlwZSB0aGF0IGRvZXMgbm90XG5kZXBlbmQgb24gdGhlIHBvc2l0aW9uIG9mICUoLi4lKSBpbiB0aGUgZm9ybWF0IHN0cmluZy4gRm9yIGV4YW1wbGUsXG4lKCUpIHdpbGwgaGF2ZSB0aGUgcG9seW1vcnBoaWMgdHlwZSAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSk6IGl0IGNhblxuYmUgY29uY2F0ZW5hdGVkIHRvIGFueSBmb3JtYXQgdHlwZSwgYW5kIG9ubHkgZW5mb3JjZXMgdGhlIGNvbnN0cmFpbnRcbnRoYXQgaXRzICdhIGFuZCAnZiBwYXJhbWV0ZXJzIGFyZSBlcXVhbCAobm8gZm9ybWF0IGFyZ3VtZW50cykgYW5kICdkXG5hbmQgJ2UgYXJlIGVxdWFsIChubyByZWFkZXIgYXJndW1lbnQpLlxuXG5UaGUgd2Vha2VuaW5nIG9mIHRoaXMgcGFyYW1ldGVyIHR5cGUgaW4gdGhlIEdBRFQgdmVyc2lvbiBicm9rZSB1c2VyXG5jb2RlIChpbiBmYWN0IGl0IGVzc2VudGlhbGx5IG1hZGUgJSguLi4lKSB1bnVzYWJsZSBleGNlcHQgYXQgdGhlIGxhc3RcbnBvc2l0aW9uIG9mIGEgZm9ybWF0KS4gSW4gcGFydGljdWxhciwgdGhlIGZvbGxvd2luZyB3b3VsZCBub3Qgd29ya1xuYW55bW9yZTpcblxuICBmdW4gc2VwIC0+XG4gICAgRm9ybWF0LnByaW50ZiBcImZvbyUoJSliYXIlKCUpYmF6XCIgc2VwIHNlcFxuXG5BcyB0aGUgdHlwZS1jaGVja2VyIHdvdWxkIHJlcXVpcmUgdHdvICppbmNvbXBhdGlibGUqIHR5cGVzIGZvciB0aGUgJSglKVxuaW4gZGlmZmVyZW50IHBvc2l0aW9ucy5cblxuVGhlIHNvbHV0aW9uIHRvIHJlZ2FpbiBhIGdlbmVyYWwgdHlwZSBmb3IgJSguLiUpIGlzIHRvIGdlbmVyYWxpemUgdGhpc1xudGVjaG5pcXVlLCBub3Qgb25seSBvbiB0aGUgJ2QsICdlIHBhcmFtZXRlcnMsIGJ1dCBvbiBhbGwgc2l4XG5wYXJhbWV0ZXJzIG9mIGEgZm9ybWF0OiB3ZSBpbnRyb2R1Y2UgYSBcInJlbGF0aW9uYWxcIiB0eXBlXG4gICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG53aG9zZSB2YWx1ZXMgYXJlIHByb29mcyB0aGF0ICgnYTEsIC4uLCAnZjEpIGFuZCAoJ2EyLCAuLiwgJ2YyKSBtb3JhbGx5XG5jb3JyZXNwb25kIHRvIHRoZSBzYW1lIGZvcm1hdCB0eXBlOiAnYTEgaXMgb2J0YWluZWQgZnJvbSAnZjEsJ2IxLCdjMVxuaW4gdGhlIGV4YWN0IHNhbWUgd2F5IHRoYXQgJ2EyIGlzIG9idGFpbmVkIGZyb20gJ2YyLCdiMiwnYzIsIGV0Yy5cblxuRm9yIGV4YW1wbGUsIHRoZSByZWxhdGlvbiBiZXR3ZWVuIHR3byBmb3JtYXQgdHlwZXMgYmVnaW5uaW5nIHdpdGggYSBDaGFyXG5wYXJhbWV0ZXIgaXMgYXMgZm9sbG93czpcblxufCBDaGFyX3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJWMgICopXG4gICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgIChjaGFyIC0+ICdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgIGNoYXIgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG5cbkluIHRoZSBnZW5lcmFsIGNhc2UsIHRoZSB0ZXJtIHN0cnVjdHVyZSBvZiBmbXR0eV9yZWwgaXMgKGFsbW9zdFsxXSlcbmlzb21vcnBoaWMgdG8gdGhlIGZtdHR5IG9mIHRoZSBwcmV2aW91cyBpbXBsZW1lbnRhdGlvbjogZXZlcnlcbmNvbnN0cnVjdG9yIGlzIHJlLXJlYWQgd2l0aCBhIGJpbmFyeSwgcmVsYXRpb25hbCB0eXBlLCBpbnN0ZWFkIG9mIHRoZVxucHJldmlvdXMgdW5hcnkgdHlwaW5nLiBmbXR0eSBjYW4gdGhlbiBiZSByZS1kZWZpbmVkIGFzIHRoZSBkaWFnb25hbCBvZlxuZm10dHlfcmVsOlxuXG4gIHR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdHR5ID1cbiAgICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZixcbiAgICAgICAgJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHlfcmVsXG5cbk9uY2Ugd2UgaGF2ZSB0aGlzIGZtdHR5X3JlbCB0eXBlIGluIHBsYWNlLCB3ZSBjYW4gZ2l2ZSB0aGUgbW9yZVxuZ2VuZXJhbCB0eXBlIHRvICUoLi4uJSk6XG5cbnwgRm9ybWF0X3N1YnN0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJSguLi4lKSAqKVxuICAgIHBhZF9vcHRpb24gKlxuICAgICgnZywgJ2gsICdpLCAnaiwgJ2ssICdsLFxuICAgICAnZzIsICdiLCAnYywgJ2oyLCAnZCwgJ2EpIGZtdHR5X3JlbCAqXG4gICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICgoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm9ybWF0NiAtPiAnZzIsICdiLCAnYywgJ2oyLCAnZSwgJ2YpIGZtdFxuXG5XZSBhY2NlcHQgYW55IGZvcm1hdCAoKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZvcm1hdDYpICh0aGlzIGlzXG5jb21wbGV0ZWx5IHVucmVsYXRlZCB0byB0aGUgdHlwZSBvZiB0aGUgY3VycmVudCBmb3JtYXQpLCBidXQgYWxzb1xucmVxdWlyZSBhIHByb29mIHRoYXQgdGhpcyBmb3JtYXQgaXMgaW4gcmVsYXRpb24gdG8gYW5vdGhlciBmb3JtYXQgdGhhdFxuaXMgY29uY2F0ZW5hYmxlIHRvIHRoZSBmb3JtYXQgdGFpbC4gV2hlbiBleGVjdXRpbmcgYSAlKC4uLiUpIGZvcm1hdFxuKGluIGNhbWxpbnRlcm5hbEZvcm1hdC5tbDptYWtlX3ByaW50ZiBvciBzY2FuZi5tbDptYWtlX3NjYW5mKSwgd2VcbnRyYW5zdHlwZSB0aGUgZm9ybWF0IGFsb25nIHRoaXMgcmVsYXRpb24gdXNpbmcgdGhlICdyZWNhc3QnIGZ1bmN0aW9uXG50byB0cmFuc3Bvc2UgYmV0d2VlbiByZWxhdGVkIGZvcm1hdCB0eXBlcy5cblxuICB2YWwgcmVjYXN0IDpcbiAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEpIGZtdFxuICAtPiAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICAtPiAoJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10XG5cbk5PVEUgWzFdOiB0aGUgdHlwaW5nIG9mIEZvcm1hdF9zdWJzdF90eSByZXF1aXJlcyBub3Qgb25lIGZvcm1hdCB0eXBlLCBidXRcbnR3bywgb25lIHRvIGVzdGFibGlzaCB0aGUgbGluayBiZXR3ZWVuIHRoZSBmb3JtYXQgYXJndW1lbnQgYW5kIHRoZVxuZmlyc3Qgc2l4IHBhcmFtZXRlcnMsIGFuZCB0aGUgb3RoZXIgZm9yIHRoZSBsaW5rIGJldHdlZW4gdGhlIGZvcm1hdFxuYXJndW1lbnQgYW5kIHRoZSBsYXN0IHNpeCBwYXJhbWV0ZXJzLlxuXG58IEZvcm1hdF9zdWJzdF90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlKC4uLiUpICopXG4gICAgKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wsXG4gICAgICdnMSwgJ2IxLCAnYzEsICdqMSwgJ2QxLCAnYTEpIGZtdHR5X3JlbCAqXG4gICAgKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wsXG4gICAgICdnMiwgJ2IyLCAnYzIsICdqMiwgJ2QyLCAnYTIpIGZtdHR5X3JlbCAqXG4gICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICgoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm9ybWF0NiAtPiAnZzEsICdiMSwgJ2MxLCAnajEsICdlMSwgJ2YxLFxuICAgICAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm9ybWF0NiAtPiAnZzIsICdiMiwgJ2MyLCAnajIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcblxuV2hlbiB3ZSBnZW5lcmF0ZSBhIGZvcm1hdCBBU1QsIHdlIGdlbmVyYXRlIGV4YWN0bHkgdGhlIHNhbWUgd2l0bmVzc1xuZm9yIGJvdGggcmVsYXRpb25zLCBhbmQgdGhlIHdpdG5lc3MtY29udmVyc2lvbiBmdW5jdGlvbnMgaW5cbmNhbWxpbnRlcm5hbEZvcm1hdCBkbyByZWx5IG9uIHRoaXMgaW52YXJpYW50LiBGb3IgZXhhbXBsZSwgdGhlXG5mdW5jdGlvbiB0aGF0IHByb3ZlcyB0aGF0IHRoZSByZWxhdGlvbiBpcyB0cmFuc2l0aXZlXG5cbiAgdmFsIHRyYW5zIDpcbiAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgLT4gKCdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIsXG4gICAgICAnYTMsICdiMywgJ2MzLCAnZDMsICdlMywgJ2YzKSBmbXR0eV9yZWxcbiAgLT4gKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAnYTMsICdiMywgJ2MzLCAnZDMsICdlMywgJ2YzKSBmbXR0eV9yZWxcblxuZG9lcyBhc3N1bWUgdGhhdCB0aGUgdHdvIGlucHV0cyBoYXZlIGV4YWN0bHkgdGhlIHNhbWUgdGVybSBzdHJ1Y3R1cmVcbihhbmQgaXMgb25seSBldmVyeSB1c2VkIGZvciBhcmd1bWVudCB3aXRuZXNzZXMgb2YgdGhlXG5Gb3JtYXRfc3Vic3RfdHkgY29uc3RydWN0b3IpLlxuKilcblxuKCogVHlwZSBvZiBhIGJsb2NrIHVzZWQgYnkgdGhlIEZvcm1hdCBwcmV0dHktcHJpbnRlci4gKilcbnR5cGUgYmxvY2tfdHlwZSA9XG4gIHwgUHBfaGJveCAgICgqIEhvcml6b250YWwgYmxvY2sgbm8gbGluZSBicmVha2luZyAqKVxuICB8IFBwX3Zib3ggICAoKiBWZXJ0aWNhbCBibG9jayBlYWNoIGJyZWFrIGxlYWRzIHRvIGEgbmV3IGxpbmUgKilcbiAgfCBQcF9odmJveCAgKCogSG9yaXpvbnRhbC12ZXJ0aWNhbCBibG9jazogc2FtZSBhcyB2Ym94LCBleGNlcHQgaWYgdGhpcyBibG9ja1xuICAgICAgICAgICAgICAgICBpcyBzbWFsbCBlbm91Z2ggdG8gZml0IG9uIGEgc2luZ2xlIGxpbmUgKilcbiAgfCBQcF9ob3Zib3ggKCogSG9yaXpvbnRhbCBvciBWZXJ0aWNhbCBibG9jazogYnJlYWtzIGxlYWQgdG8gbmV3IGxpbmVcbiAgICAgICAgICAgICAgICAgb25seSB3aGVuIG5lY2Vzc2FyeSB0byBwcmludCB0aGUgY29udGVudCBvZiB0aGUgYmxvY2sgKilcbiAgfCBQcF9ib3ggICAgKCogSG9yaXpvbnRhbCBvciBJbmRlbnQgYmxvY2s6IGJyZWFrcyBsZWFkIHRvIG5ldyBsaW5lXG4gICAgICAgICAgICAgICAgIG9ubHkgd2hlbiBuZWNlc3NhcnkgdG8gcHJpbnQgdGhlIGNvbnRlbnQgb2YgdGhlIGJsb2NrLCBvclxuICAgICAgICAgICAgICAgICB3aGVuIGl0IGxlYWRzIHRvIGEgbmV3IGluZGVudGF0aW9uIG9mIHRoZSBjdXJyZW50IGxpbmUgKilcbiAgfCBQcF9maXRzICAgKCogSW50ZXJuYWwgdXNhZ2U6IHdoZW4gYSBibG9jayBmaXRzIG9uIGEgc2luZ2xlIGxpbmUgKilcblxuKCogRm9ybWF0dGluZyBlbGVtZW50IHVzZWQgYnkgdGhlIEZvcm1hdCBwcmV0dHktcHJpbnRlci4gKilcbnR5cGUgZm9ybWF0dGluZ19saXQgPVxuICB8IENsb3NlX2JveCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBAXSAgICopXG4gIHwgQ2xvc2VfdGFnICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEB9ICAgKilcbiAgfCBCcmVhayBvZiBzdHJpbmcgKiBpbnQgKiBpbnQgICAgICAgICAgKCogQCwgfCBAICB8IEA7IHwgQDs8PiAqKVxuICB8IEZGbHVzaCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBAPyAgICopXG4gIHwgRm9yY2VfbmV3bGluZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEBcXG4gICopXG4gIHwgRmx1c2hfbmV3bGluZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEAuICAgKilcbiAgfCBNYWdpY19zaXplIG9mIHN0cmluZyAqIGludCAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQDxuPiAqKVxuICB8IEVzY2FwZWRfYXQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBAQCAgICopXG4gIHwgRXNjYXBlZF9wZXJjZW50ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEAlJSAgKilcbiAgfCBTY2FuX2luZGljIG9mIGNoYXIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQFggICAqKVxuXG4oKiBGb3JtYXR0aW5nIGVsZW1lbnQgdXNlZCBieSB0aGUgRm9ybWF0IHByZXR0eS1wcmludGVyLiAqKVxudHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0dGluZ19nZW4gPVxuICB8IE9wZW5fdGFnIDogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgLT4gICAgICAoKiBAeyAgICopXG4gICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdHRpbmdfZ2VuXG4gIHwgT3Blbl9ib3ggOiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiAtPiAgICAgICgqIEBbICAgKilcbiAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0dGluZ19nZW5cblxuKCoqKilcblxuKCogTGlzdCBvZiBmb3JtYXQgdHlwZSBlbGVtZW50cy4gKilcbigqIEluIHBhcnRpY3VsYXIgdXNlZCB0byByZXByZXNlbnQgJSguLi4lKSBhbmQgJXsuLi4lfSBjb250ZW50cy4gKilcbmFuZCAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHkgPVxuICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZixcbiAgICAgICdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdHR5X3JlbFxuYW5kICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgPVxuICB8IENoYXJfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlYyAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKGNoYXIgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICBjaGFyIC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICB8IFN0cmluZ190eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlcyAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKHN0cmluZyAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgIHN0cmluZyAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgfCBJbnRfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJWQgICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgIChpbnQgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICBpbnQgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG4gIHwgSW50MzJfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVsZCAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoaW50MzIgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICBpbnQzMiAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgfCBOYXRpdmVpbnRfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJW5kICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgIChuYXRpdmVpbnQgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICBuYXRpdmVpbnQgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG4gIHwgSW50NjRfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVMZCAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoaW50NjQgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICBpbnQ2NCAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgfCBGbG9hdF90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJWYgICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgIChmbG9hdCAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgIGZsb2F0IC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICB8IEJvb2xfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlQiAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKGJvb2wgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICBib29sIC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuXG4gIHwgRm9ybWF0X2FyZ190eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICV7Li4uJX0gKilcbiAgICAgICgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmbXR0eSAqXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgICgoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm9ybWF0NiAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmb3JtYXQ2IC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpXG4gICAgICAgICAgIGZtdHR5X3JlbFxuICB8IEZvcm1hdF9zdWJzdF90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlKC4uLiUpICopXG4gICAgICAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCxcbiAgICAgICAnZzEsICdiMSwgJ2MxLCAnajEsICdkMSwgJ2ExKSBmbXR0eV9yZWwgKlxuICAgICAgKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wsXG4gICAgICAgJ2cyLCAnYjIsICdjMiwgJ2oyLCAnZDIsICdhMikgZm10dHlfcmVsICpcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKCgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmb3JtYXQ2IC0+ICdnMSwgJ2IxLCAnYzEsICdqMSwgJ2UxLCAnZjEsXG4gICAgICAgKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZvcm1hdDYgLT4gJ2cyLCAnYjIsICdjMiwgJ2oyLCAnZTIsICdmMilcbiAgICAgICAgICAgZm10dHlfcmVsXG5cbiAgKCogUHJpbnRmIGFuZCBGb3JtYXQgc3BlY2lmaWMgY29uc3RydWN0b3JzLiAqKVxuICB8IEFscGhhX3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlYSAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKCgnYjEgLT4gJ3ggLT4gJ2MxKSAtPiAneCAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICgnYjIgLT4gJ3ggLT4gJ2MyKSAtPiAneCAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgfCBUaGV0YV90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJXQgICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgICgoJ2IxIC0+ICdjMSkgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAoJ2IyIC0+ICdjMikgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG4gIHwgQW55X3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBVc2VkIGZvciBjdXN0b20gZm9ybWF0cyAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoJ3ggLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAneCAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcblxuICAoKiBTY2FuZiBzcGVjaWZpYyBjb25zdHJ1Y3Rvci4gKilcbiAgfCBSZWFkZXJfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJXIgICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgICgneCAtPiAnYTEsICdiMSwgJ2MxLCAoJ2IxIC0+ICd4KSAtPiAnZDEsICdlMSwgJ2YxLFxuICAgICAgICd4IC0+ICdhMiwgJ2IyLCAnYzIsICgnYjIgLT4gJ3gpIC0+ICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICB8IElnbm9yZWRfcmVhZGVyX3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX3IgICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgICgnYTEsICdiMSwgJ2MxLCAoJ2IxIC0+ICd4KSAtPiAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICgnYjIgLT4gJ3gpIC0+ICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuXG4gIHwgRW5kX29mX2ZtdHR5IDpcbiAgICAgICgnZjEsICdiMSwgJ2MxLCAnZDEsICdkMSwgJ2YxLFxuICAgICAgICdmMiwgJ2IyLCAnYzIsICdkMiwgJ2QyLCAnZjIpIGZtdHR5X3JlbFxuXG4oKioqKVxuXG4oKiBMaXN0IG9mIGZvcm1hdCBlbGVtZW50cy4gKilcbmFuZCAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10ID1cbiAgfCBDaGFyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlYyAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoY2hhciAtPiAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBDYW1sX2NoYXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlQyAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoY2hhciAtPiAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBTdHJpbmcgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlcyAqKVxuICAgICAgKCd4LCBzdHJpbmcgLT4gJ2EpIHBhZGRpbmcgKiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgneCwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBDYW1sX3N0cmluZyA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlUyAqKVxuICAgICAgKCd4LCBzdHJpbmcgLT4gJ2EpIHBhZGRpbmcgKiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgneCwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBJbnQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlW2RpeFh1b10gKilcbiAgICAgIGludF9jb252ICogKCd4LCAneSkgcGFkZGluZyAqICgneSwgaW50IC0+ICdhKSBwcmVjaXNpb24gKlxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ3gsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgSW50MzIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJWxbZGl4WHVvXSAqKVxuICAgICAgaW50X2NvbnYgKiAoJ3gsICd5KSBwYWRkaW5nICogKCd5LCBpbnQzMiAtPiAnYSkgcHJlY2lzaW9uICpcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCd4LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IE5hdGl2ZWludCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVuW2RpeFh1b10gKilcbiAgICAgIGludF9jb252ICogKCd4LCAneSkgcGFkZGluZyAqICgneSwgbmF0aXZlaW50IC0+ICdhKSBwcmVjaXNpb24gKlxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ3gsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgSW50NjQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJUxbZGl4WHVvXSAqKVxuICAgICAgaW50X2NvbnYgKiAoJ3gsICd5KSBwYWRkaW5nICogKCd5LCBpbnQ2NCAtPiAnYSkgcHJlY2lzaW9uICpcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCd4LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IEZsb2F0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVbZmVFZ0dGaEhdICopXG4gICAgICBmbG9hdF9jb252ICogKCd4LCAneSkgcGFkZGluZyAqICgneSwgZmxvYXQgLT4gJ2EpIHByZWNpc2lvbiAqXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgneCwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBCb29sIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlW2JCXSAqKVxuICAgICAgKCd4LCBib29sIC0+ICdhKSBwYWRkaW5nICogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ3gsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgRmx1c2ggOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJSEgKilcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuXG4gIHwgU3RyaW5nX2xpdGVyYWwgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogYWJjICopXG4gICAgICBzdHJpbmcgKiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBDaGFyX2xpdGVyYWwgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiB4ICopXG4gICAgICBjaGFyICogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG5cbiAgfCBGb3JtYXRfYXJnIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAley4uLiV9ICopXG4gICAgICBwYWRfb3B0aW9uICogKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZtdHR5ICpcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmb3JtYXQ2IC0+ICdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IEZvcm1hdF9zdWJzdCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICUoLi4uJSkgKilcbiAgICAgIHBhZF9vcHRpb24gKlxuICAgICAgKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wsXG4gICAgICAgJ2cyLCAnYiwgJ2MsICdqMiwgJ2QsICdhKSBmbXR0eV9yZWwgKlxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgKCgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmb3JtYXQ2IC0+ICdnMiwgJ2IsICdjLCAnajIsICdlLCAnZikgZm10XG5cbiAgKCogUHJpbnRmIGFuZCBGb3JtYXQgc3BlY2lmaWMgY29uc3RydWN0b3IuICopXG4gIHwgQWxwaGEgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJWEgKilcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCgnYiAtPiAneCAtPiAnYykgLT4gJ3ggLT4gJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgVGhldGEgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJXQgKilcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCgnYiAtPiAnYykgLT4gJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG5cbiAgKCogRm9ybWF0IHNwZWNpZmljIGNvbnN0cnVjdG9yOiAqKVxuICB8IEZvcm1hdHRpbmdfbGl0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEBfICopXG4gICAgICBmb3JtYXR0aW5nX2xpdCAqICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IEZvcm1hdHRpbmdfZ2VuIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBAXyAqKVxuICAgICAgKCdhMSwgJ2IsICdjLCAnZDEsICdlMSwgJ2YxKSBmb3JtYXR0aW5nX2dlbiAqXG4gICAgICAoJ2YxLCAnYiwgJ2MsICdlMSwgJ2UyLCAnZjIpIGZtdCAtPiAoJ2ExLCAnYiwgJ2MsICdkMSwgJ2UyLCAnZjIpIGZtdFxuXG4gICgqIFNjYW5mIHNwZWNpZmljIGNvbnN0cnVjdG9yczogKilcbiAgfCBSZWFkZXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlciAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ3ggLT4gJ2EsICdiLCAnYywgKCdiIC0+ICd4KSAtPiAnZCwgJ2UsICdmKSBmbXRcbiAgfCBTY2FuX2NoYXJfc2V0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlWy4uLl0gKilcbiAgICAgIHBhZF9vcHRpb24gKiBjaGFyX3NldCAqICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKHN0cmluZyAtPiAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBTY2FuX2dldF9jb3VudGVyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlW25sTkxdICopXG4gICAgICBjb3VudGVyICogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoaW50IC0+ICdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IFNjYW5fbmV4dF9jaGFyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICUwYyAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgKGNoYXIgLT4gJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgSWdub3JlZF9wYXJhbSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV8gKilcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ3ksICd4KSBpZ25vcmVkICogKCd4LCAnYiwgJ2MsICd5LCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG5cbiAgKCogQ3VzdG9tIHByaW50aW5nIGZvcm1hdCAoUFIjNjQ1MiwgR1BSIzE0MClcblxuICAgICBXZSBpbmNsdWRlIGEgdHlwZSBDdXN0b20gb2YgXCJjdXN0b20gY29udmVydGVyc1wiLCB3aGVyZSBhblxuICAgICBhcmJpdHJhcnkgZnVuY3Rpb24gY2FuIGJlIHVzZWQgdG8gY29udmVydCBvbmUgb3IgbW9yZVxuICAgICBhcmd1bWVudHMuIFRoZXJlIGlzIG5vIHN5bnRheCBmb3IgY3VzdG9tIGNvbnZlcnRlcnMsIGl0IGlzIG9ubHlcbiAgICAgaW50ZW5kZWQgZm9yIGN1c3RvbSBwcm9jZXNzb3JzIHRoYXQgd2lzaCB0byByZWx5IG9uIHRoZVxuICAgICBzdGRsaWItZGVmaW5lZCBmb3JtYXQgR0FEVHMuXG5cbiAgICAgRm9yIGluc3RhbmNlIGEgcHJlLXByb2Nlc3NvciBjb3VsZCBjaG9vc2UgdG8gaW50ZXJwcmV0IHN0cmluZ3NcbiAgICAgcHJlZml4ZWQgd2l0aCBbXCIhXCJdIGFzIGZvcm1hdCBzdHJpbmdzIHdoZXJlIFsle3sgLi4uIH19XSBpc1xuICAgICBhIHNwZWNpYWwgZm9ybSB0byBwYXNzIGEgdG9fc3RyaW5nIGZ1bmN0aW9uLCBzbyB0aGF0IG9uZSBjb3VsZFxuICAgICB3cml0ZTpcblxuICAgICB7W1xuICAgICAgIHR5cGUgdCA9IHsgeCA6IGludDsgeSA6IGludCB9XG5cbiAgICAgICBsZXQgc3RyaW5nX29mX3QgdCA9IFByaW50Zi5zcHJpbnRmIFwieyB4ID0gJWQ7IHkgPSAlZCB9XCIgdC54IHQueVxuXG4gICAgICAgUHJpbnRmLnByaW50ZiAhXCJ0ID0gJXt7c3RyaW5nX29mX3R9fVwiIHsgeCA9IDQyOyB5ID0gNDIgfVxuICAgICBdfVxuICAqKVxuICB8IEN1c3RvbSA6XG4gICAgICAoJ2EsICd4LCAneSkgY3VzdG9tX2FyaXR5ICogKHVuaXQgLT4gJ3gpICogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgKCd5LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuXG4gICgqIGVuZCBvZiBhIGZvcm1hdCBzcGVjaWZpY2F0aW9uICopXG4gIHwgRW5kX29mX2Zvcm1hdCA6XG4gICAgICAgICgnZiwgJ2IsICdjLCAnZSwgJ2UsICdmKSBmbXRcblxuKCoqKilcblxuKCogVHlwZSBmb3IgaWdub3JlZCBwYXJhbWV0ZXJzIChzZWUgXCIlX1wiKS4gKilcbmFuZCAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgaWdub3JlZCA9XG4gIHwgSWdub3JlZF9jaGFyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9jICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfY2FtbF9jaGFyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfQyAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX3N0cmluZyA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX3MgKilcbiAgICAgIHBhZF9vcHRpb24gLT4gKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX2NhbWxfc3RyaW5nIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX1MgKilcbiAgICAgIHBhZF9vcHRpb24gLT4gKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX2ludCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX2QgKilcbiAgICAgIGludF9jb252ICogcGFkX29wdGlvbiAtPiAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfaW50MzIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfbGQgKilcbiAgICAgIGludF9jb252ICogcGFkX29wdGlvbiAtPiAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfbmF0aXZlaW50IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfbmQgKilcbiAgICAgIGludF9jb252ICogcGFkX29wdGlvbiAtPiAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfaW50NjQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfTGQgKilcbiAgICAgIGludF9jb252ICogcGFkX29wdGlvbiAtPiAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfZmxvYXQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfZiAqKVxuICAgICAgcGFkX29wdGlvbiAqIHByZWNfb3B0aW9uIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9ib29sIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9CICopXG4gICAgICBwYWRfb3B0aW9uIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9mb3JtYXRfYXJnIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV97Li4uJX0gKilcbiAgICAgIHBhZF9vcHRpb24gKiAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm10dHkgLT5cbiAgICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX2Zvcm1hdF9zdWJzdCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlXyguLi4lKSAqKVxuICAgICAgcGFkX29wdGlvbiAqICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXR0eSAtPlxuICAgICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgaWdub3JlZFxuICB8IElnbm9yZWRfcmVhZGVyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfciAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICgnYiAtPiAneCkgLT4gJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfc2Nhbl9jaGFyX3NldCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfWy4uLl0gKilcbiAgICAgIHBhZF9vcHRpb24gKiBjaGFyX3NldCAtPiAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfc2Nhbl9nZXRfY291bnRlciA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfW25sTkxdICopXG4gICAgICBjb3VudGVyIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9zY2FuX25leHRfY2hhciA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV8wYyAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcblxuYW5kICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2ID1cbiAgRm9ybWF0IG9mICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgKiBzdHJpbmdcblxubGV0IHJlYyBlcmFzZV9yZWwgOiB0eXBlIGEgYiBjIGQgZSBmIGcgaCBpIGogayBsIC5cbiAgKGEsIGIsIGMsIGQsIGUsIGYsXG4gICBnLCBoLCBpLCBqLCBrLCBsKSBmbXR0eV9yZWwgLT4gKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5XG49IGZ1bmN0aW9uXG4gIHwgQ2hhcl90eSByZXN0IC0+XG4gICAgQ2hhcl90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgU3RyaW5nX3R5IHJlc3QgLT5cbiAgICBTdHJpbmdfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IEludF90eSByZXN0IC0+XG4gICAgSW50X3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBJbnQzMl90eSByZXN0IC0+XG4gICAgSW50MzJfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IEludDY0X3R5IHJlc3QgLT5cbiAgICBJbnQ2NF90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgTmF0aXZlaW50X3R5IHJlc3QgLT5cbiAgICBOYXRpdmVpbnRfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IEZsb2F0X3R5IHJlc3QgLT5cbiAgICBGbG9hdF90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgQm9vbF90eSByZXN0IC0+XG4gICAgQm9vbF90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgRm9ybWF0X2FyZ190eSAodHksIHJlc3QpIC0+XG4gICAgRm9ybWF0X2FyZ190eSAodHksIGVyYXNlX3JlbCByZXN0KVxuICB8IEZvcm1hdF9zdWJzdF90eSAodHkxLCBfdHkyLCByZXN0KSAtPlxuICAgIEZvcm1hdF9zdWJzdF90eSAodHkxLCB0eTEsIGVyYXNlX3JlbCByZXN0KVxuICB8IEFscGhhX3R5IHJlc3QgLT5cbiAgICBBbHBoYV90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgVGhldGFfdHkgcmVzdCAtPlxuICAgIFRoZXRhX3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBBbnlfdHkgcmVzdCAtPlxuICAgIEFueV90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgUmVhZGVyX3R5IHJlc3QgLT5cbiAgICBSZWFkZXJfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IElnbm9yZWRfcmVhZGVyX3R5IHJlc3QgLT5cbiAgICBJZ25vcmVkX3JlYWRlcl90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgRW5kX29mX2ZtdHR5IC0+IEVuZF9vZl9mbXR0eVxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICgqIEZvcm1hdCB0eXBlIGNvbmNhdGVuYXRpb24gKilcblxuKCogQ29uY2F0ZW5hdGUgdHdvIGZvcm1hdCB0eXBlcy4gKilcbigqIFVzZWQgYnk6XG4gICAqIHJlYWRlcl9uYl91bmlmaWVyX29mX2ZtdHR5IHRvIGNvdW50IHJlYWRlcnMgaW4gYW4gZm10dHksXG4gICAqIFNjYW5mLnRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgdG8gZXh0cmFjdCByZWFkZXJzIGluc2lkZSAlKC4uLiUpLFxuICAgKiBDYW1saW50ZXJuYWxGb3JtYXQuZm10dHlfb2ZfaWdub3JlZF9mb3JtYXQgdG8gZXh0cmFjdCBmb3JtYXQgdHlwZS4gKilcblxuKCpcbmxldCByZWMgY29uY2F0X2ZtdHR5IDogdHlwZSBhIGIgYyBkIGUgZiBnIGggLlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSAtPlxuICAgIChmLCBiLCBjLCBlLCBnLCBoKSBmbXR0eSAtPlxuICAgIChhLCBiLCBjLCBkLCBnLCBoKSBmbXR0eSA9XG4qKVxubGV0IHJlYyBjb25jYXRfZm10dHkgOlxuICB0eXBlIGExIGIxIGMxIGQxIGUxIGYxXG4gICAgICAgYTIgYjIgYzIgZDIgZTIgZjJcbiAgICAgICBnMSBqMSBnMiBqMlxuICAuXG4gICAgKGcxLCBiMSwgYzEsIGoxLCBkMSwgYTEsXG4gICAgIGcyLCBiMiwgYzIsIGoyLCBkMiwgYTIpIGZtdHR5X3JlbCAtPlxuICAgIChhMSwgYjEsIGMxLCBkMSwgZTEsIGYxLFxuICAgICBhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXR0eV9yZWwgLT5cbiAgICAoZzEsIGIxLCBjMSwgajEsIGUxLCBmMSxcbiAgICAgZzIsIGIyLCBjMiwgajIsIGUyLCBmMikgZm10dHlfcmVsID1cbmZ1biBmbXR0eTEgZm10dHkyIC0+IG1hdGNoIGZtdHR5MSB3aXRoXG4gIHwgQ2hhcl90eSByZXN0IC0+XG4gICAgQ2hhcl90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IFN0cmluZ190eSByZXN0IC0+XG4gICAgU3RyaW5nX3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgSW50X3R5IHJlc3QgLT5cbiAgICBJbnRfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBJbnQzMl90eSByZXN0IC0+XG4gICAgSW50MzJfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBOYXRpdmVpbnRfdHkgcmVzdCAtPlxuICAgIE5hdGl2ZWludF90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IEludDY0X3R5IHJlc3QgLT5cbiAgICBJbnQ2NF90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IEZsb2F0X3R5IHJlc3QgLT5cbiAgICBGbG9hdF90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IEJvb2xfdHkgcmVzdCAtPlxuICAgIEJvb2xfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBBbHBoYV90eSByZXN0IC0+XG4gICAgQWxwaGFfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBUaGV0YV90eSByZXN0IC0+XG4gICAgVGhldGFfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBBbnlfdHkgcmVzdCAtPlxuICAgIEFueV90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IFJlYWRlcl90eSByZXN0IC0+XG4gICAgUmVhZGVyX3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgcmVzdCAtPlxuICAgIElnbm9yZWRfcmVhZGVyX3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgRm9ybWF0X2FyZ190eSAodHksIHJlc3QpIC0+XG4gICAgRm9ybWF0X2FyZ190eSAodHksIGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBGb3JtYXRfc3Vic3RfdHkgKHR5MSwgdHkyLCByZXN0KSAtPlxuICAgIEZvcm1hdF9zdWJzdF90eSAodHkxLCB0eTIsIGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBFbmRfb2ZfZm10dHkgLT4gZm10dHkyXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBGb3JtYXQgY29uY2F0ZW5hdGlvbiAqKVxuXG4oKiBDb25jYXRlbmF0ZSB0d28gZm9ybWF0cy4gKilcbmxldCByZWMgY29uY2F0X2ZtdCA6IHR5cGUgYSBiIGMgZCBlIGYgZyBoIC5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+XG4gICAgKGYsIGIsIGMsIGUsIGcsIGgpIGZtdCAtPlxuICAgIChhLCBiLCBjLCBkLCBnLCBoKSBmbXQgPVxuZnVuIGZtdDEgZm10MiAtPiBtYXRjaCBmbXQxIHdpdGhcbiAgfCBTdHJpbmcgKHBhZCwgcmVzdCkgLT5cbiAgICBTdHJpbmcgKHBhZCwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgQ2FtbF9zdHJpbmcgKHBhZCwgcmVzdCkgLT5cbiAgICBDYW1sX3N0cmluZyAocGFkLCBjb25jYXRfZm10IHJlc3QgZm10MilcblxuICB8IEludCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBJbnQgKGljb252LCBwYWQsIHByZWMsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IEludDMyIChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIEludDMyIChpY29udiwgcGFkLCBwcmVjLCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBOYXRpdmVpbnQgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgTmF0aXZlaW50IChpY29udiwgcGFkLCBwcmVjLCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBJbnQ2NCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBJbnQ2NCAoaWNvbnYsIHBhZCwgcHJlYywgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgRmxvYXQgKGZjb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgRmxvYXQgKGZjb252LCBwYWQsIHByZWMsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuXG4gIHwgQ2hhciAocmVzdCkgLT5cbiAgICBDaGFyIChjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBDYW1sX2NoYXIgcmVzdCAtPlxuICAgIENhbWxfY2hhciAoY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgQm9vbCAocGFkLCByZXN0KSAtPlxuICAgIEJvb2wgKHBhZCwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgQWxwaGEgcmVzdCAtPlxuICAgIEFscGhhIChjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBUaGV0YSByZXN0IC0+XG4gICAgVGhldGEgKGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IEN1c3RvbSAoYXJpdHksIGYsIHJlc3QpIC0+XG4gICAgQ3VzdG9tIChhcml0eSwgZiwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgUmVhZGVyIHJlc3QgLT5cbiAgICBSZWFkZXIgKGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IEZsdXNoIHJlc3QgLT5cbiAgICBGbHVzaCAoY29uY2F0X2ZtdCByZXN0IGZtdDIpXG5cbiAgfCBTdHJpbmdfbGl0ZXJhbCAoc3RyLCByZXN0KSAtPlxuICAgIFN0cmluZ19saXRlcmFsIChzdHIsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IENoYXJfbGl0ZXJhbCAoY2hyLCByZXN0KSAtPlxuICAgIENoYXJfbGl0ZXJhbCAgIChjaHIsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuXG4gIHwgRm9ybWF0X2FyZyAocGFkLCBmbXR0eSwgcmVzdCkgLT5cbiAgICBGb3JtYXRfYXJnICAgKHBhZCwgZm10dHksIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IEZvcm1hdF9zdWJzdCAocGFkLCBmbXR0eSwgcmVzdCkgLT5cbiAgICBGb3JtYXRfc3Vic3QgKHBhZCwgZm10dHksIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuXG4gIHwgU2Nhbl9jaGFyX3NldCAod2lkdGhfb3B0LCBjaGFyX3NldCwgcmVzdCkgLT5cbiAgICBTY2FuX2NoYXJfc2V0ICh3aWR0aF9vcHQsIGNoYXJfc2V0LCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBTY2FuX2dldF9jb3VudGVyIChjb3VudGVyLCByZXN0KSAtPlxuICAgIFNjYW5fZ2V0X2NvdW50ZXIgKGNvdW50ZXIsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IFNjYW5fbmV4dF9jaGFyIChyZXN0KSAtPlxuICAgIFNjYW5fbmV4dF9jaGFyIChjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBJZ25vcmVkX3BhcmFtIChpZ24sIHJlc3QpIC0+XG4gICAgSWdub3JlZF9wYXJhbSAoaWduLCBjb25jYXRfZm10IHJlc3QgZm10MilcblxuICB8IEZvcm1hdHRpbmdfbGl0IChmbXRpbmdfbGl0LCByZXN0KSAtPlxuICAgIEZvcm1hdHRpbmdfbGl0IChmbXRpbmdfbGl0LCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBGb3JtYXR0aW5nX2dlbiAoZm10aW5nX2dlbiwgcmVzdCkgLT5cbiAgICBGb3JtYXR0aW5nX2dlbiAoZm10aW5nX2dlbiwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG5cbiAgfCBFbmRfb2ZfZm9ybWF0IC0+XG4gICAgZm10MlxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgR2FicmllbCBTY2hlcmVyLCBwcm9qZXQgUGFydG91dCwgSU5SSUEgUGFyaXMtU2FjbGF5ICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAyMCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBDYW1saW50ZXJuYWxBdG9taWMgaXMgYSBkZXBlbmRlbmN5IG9mIFN0ZGxpYiwgc28gaXQgaXMgY29tcGlsZWQgd2l0aFxuICAgLW5vcGVydmFzaXZlcy4gKilcbmV4dGVybmFsICggPT0gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVlcVwiXG5leHRlcm5hbCAoICsgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlYWRkaW50XCJcbmV4dGVybmFsIGlnbm9yZSA6ICdhIC0+IHVuaXQgPSBcIiVpZ25vcmVcIlxuXG4oKiBXZSBhcmUgbm90IHJldXNpbmcgKCdhIHJlZikgZGlyZWN0bHkgdG8gbWFrZSBpdCBlYXNpZXIgdG8gcmVhc29uXG4gICBhYm91dCBhdG9taWNpdHkgaWYgd2Ugd2lzaCB0bzogZXZlbiBpbiBhIHNlcXVlbnRpYWwgaW1wbGVtZW50YXRpb24sXG4gICBzaWduYWxzIGFuZCBvdGhlciBhc3luY2hyb25vdXMgY2FsbGJhY2tzIG1pZ2h0IGJyZWFrIGF0b21pY2l0eS4gKilcbnR5cGUgJ2EgdCA9IHttdXRhYmxlIHY6ICdhfVxuXG5sZXQgbWFrZSB2ID0ge3Z9XG5sZXQgZ2V0IHIgPSByLnZcbmxldCBzZXQgciB2ID0gci52IDwtIHZcblxuKCogVGhlIGZvbGxvd2luZyBmdW5jdGlvbnMgYXJlIHNldCB0byBuZXZlciBiZSBpbmxpbmVkOiBGbGFtYmRhIGlzXG4gICBhbGxvd2VkIHRvIG1vdmUgc3Vycm91bmRpbmcgY29kZSBpbnNpZGUgdGhlIGNyaXRpY2FsIHNlY3Rpb24sXG4gICBpbmNsdWRpbmcgYWxsb2NhdGlvbnMuICopXG5cbmxldFtAaW5saW5lIG5ldmVyXSBleGNoYW5nZSByIHYgPVxuICAoKiBCRUdJTiBBVE9NSUMgKilcbiAgbGV0IGN1ciA9IHIudiBpblxuICByLnYgPC0gdjtcbiAgKCogRU5EIEFUT01JQyAqKVxuICBjdXJcblxubGV0W0BpbmxpbmUgbmV2ZXJdIGNvbXBhcmVfYW5kX3NldCByIHNlZW4gdiA9XG4gICgqIEJFR0lOIEFUT01JQyAqKVxuICBsZXQgY3VyID0gci52IGluXG4gIGlmIGN1ciA9PSBzZWVuIHRoZW4gKFxuICAgIHIudiA8LSB2O1xuICAgICgqIEVORCBBVE9NSUMgKilcbiAgICB0cnVlXG4gICkgZWxzZVxuICAgIGZhbHNlXG5cbmxldFtAaW5saW5lIG5ldmVyXSBmZXRjaF9hbmRfYWRkIHIgbiA9XG4gICgqIEJFR0lOIEFUT01JQyAqKVxuICBsZXQgY3VyID0gci52IGluXG4gIHIudiA8LSAoY3VyICsgbik7XG4gICgqIEVORCBBVE9NSUMgKilcbiAgY3VyXG5cbmxldCBpbmNyIHIgPSBpZ25vcmUgKGZldGNoX2FuZF9hZGQgciAxKVxubGV0IGRlY3IgciA9IGlnbm9yZSAoZmV0Y2hfYW5kX2FkZCByICgtMSkpXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIEV4Y2VwdGlvbnMgKilcblxuZXh0ZXJuYWwgcmVnaXN0ZXJfbmFtZWRfdmFsdWUgOiBzdHJpbmcgLT4gJ2EgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfcmVnaXN0ZXJfbmFtZWRfdmFsdWVcIlxuXG5sZXQgKCkgPVxuICAoKiBmb3IgcnVudGltZS9mYWlsX25hdC5jICopXG4gIHJlZ2lzdGVyX25hbWVkX3ZhbHVlIFwiUGVydmFzaXZlcy5hcnJheV9ib3VuZF9lcnJvclwiXG4gICAgKEludmFsaWRfYXJndW1lbnQgXCJpbmRleCBvdXQgb2YgYm91bmRzXCIpXG5cbmV4dGVybmFsIHJhaXNlIDogZXhuIC0+ICdhID0gXCIlcmFpc2VcIlxuZXh0ZXJuYWwgcmFpc2Vfbm90cmFjZSA6IGV4biAtPiAnYSA9IFwiJXJhaXNlX25vdHJhY2VcIlxuXG5sZXQgZmFpbHdpdGggcyA9IHJhaXNlKEZhaWx1cmUgcylcbmxldCBpbnZhbGlkX2FyZyBzID0gcmFpc2UoSW52YWxpZF9hcmd1bWVudCBzKVxuXG5leGNlcHRpb24gRXhpdFxuZXhjZXB0aW9uIE1hdGNoX2ZhaWx1cmUgPSBNYXRjaF9mYWlsdXJlXG5leGNlcHRpb24gQXNzZXJ0X2ZhaWx1cmUgPSBBc3NlcnRfZmFpbHVyZVxuZXhjZXB0aW9uIEludmFsaWRfYXJndW1lbnQgPSBJbnZhbGlkX2FyZ3VtZW50XG5leGNlcHRpb24gRmFpbHVyZSA9IEZhaWx1cmVcbmV4Y2VwdGlvbiBOb3RfZm91bmQgPSBOb3RfZm91bmRcbmV4Y2VwdGlvbiBPdXRfb2ZfbWVtb3J5ID0gT3V0X29mX21lbW9yeVxuZXhjZXB0aW9uIFN0YWNrX292ZXJmbG93ID0gU3RhY2tfb3ZlcmZsb3dcbmV4Y2VwdGlvbiBTeXNfZXJyb3IgPSBTeXNfZXJyb3JcbmV4Y2VwdGlvbiBFbmRfb2ZfZmlsZSA9IEVuZF9vZl9maWxlXG5leGNlcHRpb24gRGl2aXNpb25fYnlfemVybyA9IERpdmlzaW9uX2J5X3plcm9cbmV4Y2VwdGlvbiBTeXNfYmxvY2tlZF9pbyA9IFN5c19ibG9ja2VkX2lvXG5leGNlcHRpb24gVW5kZWZpbmVkX3JlY3Vyc2l2ZV9tb2R1bGUgPSBVbmRlZmluZWRfcmVjdXJzaXZlX21vZHVsZVxuXG4oKiBDb21wb3NpdGlvbiBvcGVyYXRvcnMgKilcblxuZXh0ZXJuYWwgKCB8PiApIDogJ2EgLT4gKCdhIC0+ICdiKSAtPiAnYiA9IFwiJXJldmFwcGx5XCJcbmV4dGVybmFsICggQEAgKSA6ICgnYSAtPiAnYikgLT4gJ2EgLT4gJ2IgPSBcIiVhcHBseVwiXG5cbigqIERlYnVnZ2luZyAqKVxuXG5leHRlcm5hbCBfX0xPQ19fIDogc3RyaW5nID0gXCIlbG9jX0xPQ1wiXG5leHRlcm5hbCBfX0ZJTEVfXyA6IHN0cmluZyA9IFwiJWxvY19GSUxFXCJcbmV4dGVybmFsIF9fTElORV9fIDogaW50ID0gXCIlbG9jX0xJTkVcIlxuZXh0ZXJuYWwgX19NT0RVTEVfXyA6IHN0cmluZyA9IFwiJWxvY19NT0RVTEVcIlxuZXh0ZXJuYWwgX19QT1NfXyA6IHN0cmluZyAqIGludCAqIGludCAqIGludCA9IFwiJWxvY19QT1NcIlxuZXh0ZXJuYWwgX19GVU5DVElPTl9fIDogc3RyaW5nID0gXCIlbG9jX0ZVTkNUSU9OXCJcblxuZXh0ZXJuYWwgX19MT0NfT0ZfXyA6ICdhIC0+IHN0cmluZyAqICdhID0gXCIlbG9jX0xPQ1wiXG5leHRlcm5hbCBfX0xJTkVfT0ZfXyA6ICdhIC0+IGludCAqICdhID0gXCIlbG9jX0xJTkVcIlxuZXh0ZXJuYWwgX19QT1NfT0ZfXyA6ICdhIC0+IChzdHJpbmcgKiBpbnQgKiBpbnQgKiBpbnQpICogJ2EgPSBcIiVsb2NfUE9TXCJcblxuKCogQ29tcGFyaXNvbnMgKilcblxuZXh0ZXJuYWwgKCA9ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlZXF1YWxcIlxuZXh0ZXJuYWwgKCA8PiApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJW5vdGVxdWFsXCJcbmV4dGVybmFsICggPCApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWxlc3N0aGFuXCJcbmV4dGVybmFsICggPiApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWdyZWF0ZXJ0aGFuXCJcbmV4dGVybmFsICggPD0gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVsZXNzZXF1YWxcIlxuZXh0ZXJuYWwgKCA+PSApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWdyZWF0ZXJlcXVhbFwiXG5leHRlcm5hbCBjb21wYXJlIDogJ2EgLT4gJ2EgLT4gaW50ID0gXCIlY29tcGFyZVwiXG5cbmxldCBtaW4geCB5ID0gaWYgeCA8PSB5IHRoZW4geCBlbHNlIHlcbmxldCBtYXggeCB5ID0gaWYgeCA+PSB5IHRoZW4geCBlbHNlIHlcblxuZXh0ZXJuYWwgKCA9PSApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWVxXCJcbmV4dGVybmFsICggIT0gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVub3RlcVwiXG5cbigqIEJvb2xlYW4gb3BlcmF0aW9ucyAqKVxuXG5leHRlcm5hbCBub3QgOiBib29sIC0+IGJvb2wgPSBcIiVib29sbm90XCJcbmV4dGVybmFsICggJiApIDogYm9vbCAtPiBib29sIC0+IGJvb2wgPSBcIiVzZXF1YW5kXCJcbmV4dGVybmFsICggJiYgKSA6IGJvb2wgLT4gYm9vbCAtPiBib29sID0gXCIlc2VxdWFuZFwiXG5leHRlcm5hbCAoIG9yICkgOiBib29sIC0+IGJvb2wgLT4gYm9vbCA9IFwiJXNlcXVvclwiXG5leHRlcm5hbCAoIHx8ICkgOiBib29sIC0+IGJvb2wgLT4gYm9vbCA9IFwiJXNlcXVvclwiXG5cbigqIEludGVnZXIgb3BlcmF0aW9ucyAqKVxuXG5leHRlcm5hbCAoIH4tICkgOiBpbnQgLT4gaW50ID0gXCIlbmVnaW50XCJcbmV4dGVybmFsICggfisgKSA6IGludCAtPiBpbnQgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCBzdWNjIDogaW50IC0+IGludCA9IFwiJXN1Y2NpbnRcIlxuZXh0ZXJuYWwgcHJlZCA6IGludCAtPiBpbnQgPSBcIiVwcmVkaW50XCJcbmV4dGVybmFsICggKyApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVhZGRpbnRcIlxuZXh0ZXJuYWwgKCAtICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJXN1YmludFwiXG5leHRlcm5hbCAoICogKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlbXVsaW50XCJcbmV4dGVybmFsICggLyApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVkaXZpbnRcIlxuZXh0ZXJuYWwgKCBtb2QgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlbW9kaW50XCJcblxubGV0IGFicyB4ID0gaWYgeCA+PSAwIHRoZW4geCBlbHNlIC14XG5cbmV4dGVybmFsICggbGFuZCApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVhbmRpbnRcIlxuZXh0ZXJuYWwgKCBsb3IgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlb3JpbnRcIlxuZXh0ZXJuYWwgKCBseG9yICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJXhvcmludFwiXG5cbmxldCBsbm90IHggPSB4IGx4b3IgKC0xKVxuXG5leHRlcm5hbCAoIGxzbCApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVsc2xpbnRcIlxuZXh0ZXJuYWwgKCBsc3IgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlbHNyaW50XCJcbmV4dGVybmFsICggYXNyICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWFzcmludFwiXG5cbmxldCBtYXhfaW50ID0gKC0xKSBsc3IgMVxubGV0IG1pbl9pbnQgPSBtYXhfaW50ICsgMVxuXG4oKiBGbG9hdGluZy1wb2ludCBvcGVyYXRpb25zICopXG5cbmV4dGVybmFsICggfi0uICkgOiBmbG9hdCAtPiBmbG9hdCA9IFwiJW5lZ2Zsb2F0XCJcbmV4dGVybmFsICggfisuICkgOiBmbG9hdCAtPiBmbG9hdCA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsICggKy4gKSA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCIlYWRkZmxvYXRcIlxuZXh0ZXJuYWwgKCAtLiApIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcIiVzdWJmbG9hdFwiXG5leHRlcm5hbCAoICouICkgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiJW11bGZsb2F0XCJcbmV4dGVybmFsICggLy4gKSA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCIlZGl2ZmxvYXRcIlxuZXh0ZXJuYWwgKCAqKiApIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfcG93ZXJfZmxvYXRcIiBcInBvd1wiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBleHAgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9leHBfZmxvYXRcIiBcImV4cFwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBleHBtMSA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2V4cG0xX2Zsb2F0XCIgXCJjYW1sX2V4cG0xXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGFjb3MgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hY29zX2Zsb2F0XCIgXCJhY29zXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGFzaW4gOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hc2luX2Zsb2F0XCIgXCJhc2luXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGF0YW4gOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hdGFuX2Zsb2F0XCIgXCJhdGFuXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGF0YW4yIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYXRhbjJfZmxvYXRcIiBcImF0YW4yXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGh5cG90IDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXRcbiAgICAgICAgICAgICAgID0gXCJjYW1sX2h5cG90X2Zsb2F0XCIgXCJjYW1sX2h5cG90XCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGNvcyA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Nvc19mbG9hdFwiIFwiY29zXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGNvc2ggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9jb3NoX2Zsb2F0XCIgXCJjb3NoXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGxvZyA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2xvZ19mbG9hdFwiIFwibG9nXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGxvZzEwIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfbG9nMTBfZmxvYXRcIiBcImxvZzEwXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGxvZzFwIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfbG9nMXBfZmxvYXRcIiBcImNhbWxfbG9nMXBcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgc2luIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfc2luX2Zsb2F0XCIgXCJzaW5cIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgc2luaCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3NpbmhfZmxvYXRcIiBcInNpbmhcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgc3FydCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3NxcnRfZmxvYXRcIiBcInNxcnRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdGFuIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfdGFuX2Zsb2F0XCIgXCJ0YW5cIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdGFuaCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3RhbmhfZmxvYXRcIiBcInRhbmhcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgY2VpbCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2NlaWxfZmxvYXRcIiBcImNlaWxcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZmxvb3IgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9mbG9vcl9mbG9hdFwiIFwiZmxvb3JcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYWJzX2Zsb2F0IDogZmxvYXQgLT4gZmxvYXQgPSBcIiVhYnNmbG9hdFwiXG5leHRlcm5hbCBjb3B5c2lnbiA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0XG4gICAgICAgICAgICAgICAgICA9IFwiY2FtbF9jb3B5c2lnbl9mbG9hdFwiIFwiY2FtbF9jb3B5c2lnblwiXG4gICAgICAgICAgICAgICAgICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgbW9kX2Zsb2F0IDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfZm1vZF9mbG9hdFwiIFwiZm1vZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBmcmV4cCA6IGZsb2F0IC0+IGZsb2F0ICogaW50ID0gXCJjYW1sX2ZyZXhwX2Zsb2F0XCJcbmV4dGVybmFsIGxkZXhwIDogKGZsb2F0IFtAdW5ib3hlZF0pIC0+IChpbnQgW0B1bnRhZ2dlZF0pIC0+IChmbG9hdCBbQHVuYm94ZWRdKSA9XG4gIFwiY2FtbF9sZGV4cF9mbG9hdFwiIFwiY2FtbF9sZGV4cF9mbG9hdF91bmJveGVkXCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIG1vZGYgOiBmbG9hdCAtPiBmbG9hdCAqIGZsb2F0ID0gXCJjYW1sX21vZGZfZmxvYXRcIlxuZXh0ZXJuYWwgZmxvYXQgOiBpbnQgLT4gZmxvYXQgPSBcIiVmbG9hdG9maW50XCJcbmV4dGVybmFsIGZsb2F0X29mX2ludCA6IGludCAtPiBmbG9hdCA9IFwiJWZsb2F0b2ZpbnRcIlxuZXh0ZXJuYWwgdHJ1bmNhdGUgOiBmbG9hdCAtPiBpbnQgPSBcIiVpbnRvZmZsb2F0XCJcbmV4dGVybmFsIGludF9vZl9mbG9hdCA6IGZsb2F0IC0+IGludCA9IFwiJWludG9mZmxvYXRcIlxuZXh0ZXJuYWwgZmxvYXRfb2ZfYml0cyA6IGludDY0IC0+IGZsb2F0XG4gID0gXCJjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHNcIiBcImNhbWxfaW50NjRfZmxvYXRfb2ZfYml0c191bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmxldCBpbmZpbml0eSA9XG4gIGZsb2F0X29mX2JpdHMgMHg3Rl9GMF8wMF8wMF8wMF8wMF8wMF8wMExcbmxldCBuZWdfaW5maW5pdHkgPVxuICBmbG9hdF9vZl9iaXRzIDB4RkZfRjBfMDBfMDBfMDBfMDBfMDBfMDBMXG5sZXQgbmFuID1cbiAgZmxvYXRfb2ZfYml0cyAweDdGX0YwXzAwXzAwXzAwXzAwXzAwXzAxTFxubGV0IG1heF9mbG9hdCA9XG4gIGZsb2F0X29mX2JpdHMgMHg3Rl9FRl9GRl9GRl9GRl9GRl9GRl9GRkxcbmxldCBtaW5fZmxvYXQgPVxuICBmbG9hdF9vZl9iaXRzIDB4MDBfMTBfMDBfMDBfMDBfMDBfMDBfMDBMXG5sZXQgZXBzaWxvbl9mbG9hdCA9XG4gIGZsb2F0X29mX2JpdHMgMHgzQ19CMF8wMF8wMF8wMF8wMF8wMF8wMExcblxudHlwZSBmcGNsYXNzID1cbiAgICBGUF9ub3JtYWxcbiAgfCBGUF9zdWJub3JtYWxcbiAgfCBGUF96ZXJvXG4gIHwgRlBfaW5maW5pdGVcbiAgfCBGUF9uYW5cbmV4dGVybmFsIGNsYXNzaWZ5X2Zsb2F0IDogKGZsb2F0IFtAdW5ib3hlZF0pIC0+IGZwY2xhc3MgPVxuICBcImNhbWxfY2xhc3NpZnlfZmxvYXRcIiBcImNhbWxfY2xhc3NpZnlfZmxvYXRfdW5ib3hlZFwiIFtAQG5vYWxsb2NdXG5cbigqIFN0cmluZyBhbmQgYnl0ZSBzZXF1ZW5jZSBvcGVyYXRpb25zIC0tIG1vcmUgaW4gbW9kdWxlcyBTdHJpbmcgYW5kIEJ5dGVzICopXG5cbmV4dGVybmFsIHN0cmluZ19sZW5ndGggOiBzdHJpbmcgLT4gaW50ID0gXCIlc3RyaW5nX2xlbmd0aFwiXG5leHRlcm5hbCBieXRlc19sZW5ndGggOiBieXRlcyAtPiBpbnQgPSBcIiVieXRlc19sZW5ndGhcIlxuZXh0ZXJuYWwgYnl0ZXNfY3JlYXRlIDogaW50IC0+IGJ5dGVzID0gXCJjYW1sX2NyZWF0ZV9ieXRlc1wiXG5leHRlcm5hbCBzdHJpbmdfYmxpdCA6IHN0cmluZyAtPiBpbnQgLT4gYnl0ZXMgLT4gaW50IC0+IGludCAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9ibGl0X3N0cmluZ1wiIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBieXRlc19ibGl0IDogYnl0ZXMgLT4gaW50IC0+IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfYmxpdF9ieXRlc1wiIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBieXRlc191bnNhZmVfdG9fc3RyaW5nIDogYnl0ZXMgLT4gc3RyaW5nID0gXCIlYnl0ZXNfdG9fc3RyaW5nXCJcblxubGV0ICggXiApIHMxIHMyID1cbiAgbGV0IGwxID0gc3RyaW5nX2xlbmd0aCBzMSBhbmQgbDIgPSBzdHJpbmdfbGVuZ3RoIHMyIGluXG4gIGxldCBzID0gYnl0ZXNfY3JlYXRlIChsMSArIGwyKSBpblxuICBzdHJpbmdfYmxpdCBzMSAwIHMgMCBsMTtcbiAgc3RyaW5nX2JsaXQgczIgMCBzIGwxIGwyO1xuICBieXRlc191bnNhZmVfdG9fc3RyaW5nIHNcblxuKCogQ2hhcmFjdGVyIG9wZXJhdGlvbnMgLS0gbW9yZSBpbiBtb2R1bGUgQ2hhciAqKVxuXG5leHRlcm5hbCBpbnRfb2ZfY2hhciA6IGNoYXIgLT4gaW50ID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgdW5zYWZlX2NoYXJfb2ZfaW50IDogaW50IC0+IGNoYXIgPSBcIiVpZGVudGl0eVwiXG5sZXQgY2hhcl9vZl9pbnQgbiA9XG4gIGlmIG4gPCAwIHx8IG4gPiAyNTUgdGhlbiBpbnZhbGlkX2FyZyBcImNoYXJfb2ZfaW50XCIgZWxzZSB1bnNhZmVfY2hhcl9vZl9pbnQgblxuXG4oKiBVbml0IG9wZXJhdGlvbnMgKilcblxuZXh0ZXJuYWwgaWdub3JlIDogJ2EgLT4gdW5pdCA9IFwiJWlnbm9yZVwiXG5cbigqIFBhaXIgb3BlcmF0aW9ucyAqKVxuXG5leHRlcm5hbCBmc3QgOiAnYSAqICdiIC0+ICdhID0gXCIlZmllbGQwXCJcbmV4dGVybmFsIHNuZCA6ICdhICogJ2IgLT4gJ2IgPSBcIiVmaWVsZDFcIlxuXG4oKiBSZWZlcmVuY2VzICopXG5cbnR5cGUgJ2EgcmVmID0geyBtdXRhYmxlIGNvbnRlbnRzIDogJ2EgfVxuZXh0ZXJuYWwgcmVmIDogJ2EgLT4gJ2EgcmVmID0gXCIlbWFrZW11dGFibGVcIlxuZXh0ZXJuYWwgKCAhICkgOiAnYSByZWYgLT4gJ2EgPSBcIiVmaWVsZDBcIlxuZXh0ZXJuYWwgKCA6PSApIDogJ2EgcmVmIC0+ICdhIC0+IHVuaXQgPSBcIiVzZXRmaWVsZDBcIlxuZXh0ZXJuYWwgaW5jciA6IGludCByZWYgLT4gdW5pdCA9IFwiJWluY3JcIlxuZXh0ZXJuYWwgZGVjciA6IGludCByZWYgLT4gdW5pdCA9IFwiJWRlY3JcIlxuXG4oKiBSZXN1bHQgdHlwZSAqKVxuXG50eXBlICgnYSwnYikgcmVzdWx0ID0gT2sgb2YgJ2EgfCBFcnJvciBvZiAnYlxuXG4oKiBTdHJpbmcgY29udmVyc2lvbiBmdW5jdGlvbnMgKilcblxuZXh0ZXJuYWwgZm9ybWF0X2ludCA6IHN0cmluZyAtPiBpbnQgLT4gc3RyaW5nID0gXCJjYW1sX2Zvcm1hdF9pbnRcIlxuZXh0ZXJuYWwgZm9ybWF0X2Zsb2F0IDogc3RyaW5nIC0+IGZsb2F0IC0+IHN0cmluZyA9IFwiY2FtbF9mb3JtYXRfZmxvYXRcIlxuXG5sZXQgc3RyaW5nX29mX2Jvb2wgYiA9XG4gIGlmIGIgdGhlbiBcInRydWVcIiBlbHNlIFwiZmFsc2VcIlxubGV0IGJvb2xfb2Zfc3RyaW5nID0gZnVuY3Rpb25cbiAgfCBcInRydWVcIiAtPiB0cnVlXG4gIHwgXCJmYWxzZVwiIC0+IGZhbHNlXG4gIHwgXyAtPiBpbnZhbGlkX2FyZyBcImJvb2xfb2Zfc3RyaW5nXCJcblxubGV0IGJvb2xfb2Zfc3RyaW5nX29wdCA9IGZ1bmN0aW9uXG4gIHwgXCJ0cnVlXCIgLT4gU29tZSB0cnVlXG4gIHwgXCJmYWxzZVwiIC0+IFNvbWUgZmFsc2VcbiAgfCBfIC0+IE5vbmVcblxubGV0IHN0cmluZ19vZl9pbnQgbiA9XG4gIGZvcm1hdF9pbnQgXCIlZFwiIG5cblxuZXh0ZXJuYWwgaW50X29mX3N0cmluZyA6IHN0cmluZyAtPiBpbnQgPSBcImNhbWxfaW50X29mX3N0cmluZ1wiXG5cbmxldCBpbnRfb2Zfc3RyaW5nX29wdCBzID1cbiAgKCogVE9ETzogcHJvdmlkZSB0aGlzIGRpcmVjdGx5IGFzIGEgbm9uLXJhaXNpbmcgcHJpbWl0aXZlLiAqKVxuICB0cnkgU29tZSAoaW50X29mX3N0cmluZyBzKVxuICB3aXRoIEZhaWx1cmUgXyAtPiBOb25lXG5cbmV4dGVybmFsIHN0cmluZ19nZXQgOiBzdHJpbmcgLT4gaW50IC0+IGNoYXIgPSBcIiVzdHJpbmdfc2FmZV9nZXRcIlxuXG5sZXQgdmFsaWRfZmxvYXRfbGV4ZW0gcyA9XG4gIGxldCBsID0gc3RyaW5nX2xlbmd0aCBzIGluXG4gIGxldCByZWMgbG9vcCBpID1cbiAgICBpZiBpID49IGwgdGhlbiBzIF4gXCIuXCIgZWxzZVxuICAgIG1hdGNoIHN0cmluZ19nZXQgcyBpIHdpdGhcbiAgICB8ICcwJyAuLiAnOScgfCAnLScgLT4gbG9vcCAoaSArIDEpXG4gICAgfCBfIC0+IHNcbiAgaW5cbiAgbG9vcCAwXG5cbmxldCBzdHJpbmdfb2ZfZmxvYXQgZiA9IHZhbGlkX2Zsb2F0X2xleGVtIChmb3JtYXRfZmxvYXQgXCIlLjEyZ1wiIGYpXG5cbmV4dGVybmFsIGZsb2F0X29mX3N0cmluZyA6IHN0cmluZyAtPiBmbG9hdCA9IFwiY2FtbF9mbG9hdF9vZl9zdHJpbmdcIlxuXG5sZXQgZmxvYXRfb2Zfc3RyaW5nX29wdCBzID1cbiAgKCogVE9ETzogcHJvdmlkZSB0aGlzIGRpcmVjdGx5IGFzIGEgbm9uLXJhaXNpbmcgcHJpbWl0aXZlLiAqKVxuICB0cnkgU29tZSAoZmxvYXRfb2Zfc3RyaW5nIHMpXG4gIHdpdGggRmFpbHVyZSBfIC0+IE5vbmVcblxuKCogTGlzdCBvcGVyYXRpb25zIC0tIG1vcmUgaW4gbW9kdWxlIExpc3QgKilcblxubGV0IHJlYyAoIEAgKSBsMSBsMiA9XG4gIG1hdGNoIGwxIHdpdGhcbiAgICBbXSAtPiBsMlxuICB8IGhkIDo6IHRsIC0+IGhkIDo6ICh0bCBAIGwyKVxuXG4oKiBJL08gb3BlcmF0aW9ucyAqKVxuXG50eXBlIGluX2NoYW5uZWxcbnR5cGUgb3V0X2NoYW5uZWxcblxuZXh0ZXJuYWwgb3Blbl9kZXNjcmlwdG9yX291dCA6IGludCAtPiBvdXRfY2hhbm5lbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3Jfb3V0XCJcbmV4dGVybmFsIG9wZW5fZGVzY3JpcHRvcl9pbiA6IGludCAtPiBpbl9jaGFubmVsID0gXCJjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9pblwiXG5cbmxldCBzdGRpbiA9IG9wZW5fZGVzY3JpcHRvcl9pbiAwXG5sZXQgc3Rkb3V0ID0gb3Blbl9kZXNjcmlwdG9yX291dCAxXG5sZXQgc3RkZXJyID0gb3Blbl9kZXNjcmlwdG9yX291dCAyXG5cbigqIEdlbmVyYWwgb3V0cHV0IGZ1bmN0aW9ucyAqKVxuXG50eXBlIG9wZW5fZmxhZyA9XG4gICAgT3Blbl9yZG9ubHkgfCBPcGVuX3dyb25seSB8IE9wZW5fYXBwZW5kXG4gIHwgT3Blbl9jcmVhdCB8IE9wZW5fdHJ1bmMgfCBPcGVuX2V4Y2xcbiAgfCBPcGVuX2JpbmFyeSB8IE9wZW5fdGV4dCB8IE9wZW5fbm9uYmxvY2tcblxuZXh0ZXJuYWwgb3Blbl9kZXNjIDogc3RyaW5nIC0+IG9wZW5fZmxhZyBsaXN0IC0+IGludCAtPiBpbnQgPSBcImNhbWxfc3lzX29wZW5cIlxuXG5leHRlcm5hbCBzZXRfb3V0X2NoYW5uZWxfbmFtZTogb3V0X2NoYW5uZWwgLT4gc3RyaW5nIC0+IHVuaXQgPVxuICBcImNhbWxfbWxfc2V0X2NoYW5uZWxfbmFtZVwiXG5cbmxldCBvcGVuX291dF9nZW4gbW9kZSBwZXJtIG5hbWUgPVxuICBsZXQgYyA9IG9wZW5fZGVzY3JpcHRvcl9vdXQob3Blbl9kZXNjIG5hbWUgbW9kZSBwZXJtKSBpblxuICBzZXRfb3V0X2NoYW5uZWxfbmFtZSBjIG5hbWU7XG4gIGNcblxubGV0IG9wZW5fb3V0IG5hbWUgPVxuICBvcGVuX291dF9nZW4gW09wZW5fd3Jvbmx5OyBPcGVuX2NyZWF0OyBPcGVuX3RydW5jOyBPcGVuX3RleHRdIDBvNjY2IG5hbWVcblxubGV0IG9wZW5fb3V0X2JpbiBuYW1lID1cbiAgb3Blbl9vdXRfZ2VuIFtPcGVuX3dyb25seTsgT3Blbl9jcmVhdDsgT3Blbl90cnVuYzsgT3Blbl9iaW5hcnldIDBvNjY2IG5hbWVcblxuZXh0ZXJuYWwgZmx1c2ggOiBvdXRfY2hhbm5lbCAtPiB1bml0ID0gXCJjYW1sX21sX2ZsdXNoXCJcblxuZXh0ZXJuYWwgb3V0X2NoYW5uZWxzX2xpc3QgOiB1bml0IC0+IG91dF9jaGFubmVsIGxpc3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX21sX291dF9jaGFubmVsc19saXN0XCJcblxubGV0IGZsdXNoX2FsbCAoKSA9XG4gIGxldCByZWMgaXRlciA9IGZ1bmN0aW9uXG4gICAgICBbXSAtPiAoKVxuICAgIHwgYTo6bCAtPlxuICAgICAgICBiZWdpbiB0cnlcbiAgICAgICAgICAgIGZsdXNoIGFcbiAgICAgICAgd2l0aCBTeXNfZXJyb3IgXyAtPlxuICAgICAgICAgICgpICgqIGlnbm9yZSBjaGFubmVscyBjbG9zZWQgZHVyaW5nIGEgcHJlY2VkaW5nIGZsdXNoLiAqKVxuICAgICAgICBlbmQ7XG4gICAgICAgIGl0ZXIgbFxuICBpbiBpdGVyIChvdXRfY2hhbm5lbHNfbGlzdCAoKSlcblxuZXh0ZXJuYWwgdW5zYWZlX291dHB1dCA6IG91dF9jaGFubmVsIC0+IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9tbF9vdXRwdXRfYnl0ZXNcIlxuZXh0ZXJuYWwgdW5zYWZlX291dHB1dF9zdHJpbmcgOiBvdXRfY2hhbm5lbCAtPiBzdHJpbmcgLT4gaW50IC0+IGludCAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9tbF9vdXRwdXRcIlxuXG5leHRlcm5hbCBvdXRwdXRfY2hhciA6IG91dF9jaGFubmVsIC0+IGNoYXIgLT4gdW5pdCA9IFwiY2FtbF9tbF9vdXRwdXRfY2hhclwiXG5cbmxldCBvdXRwdXRfYnl0ZXMgb2MgcyA9XG4gIHVuc2FmZV9vdXRwdXQgb2MgcyAwIChieXRlc19sZW5ndGggcylcblxubGV0IG91dHB1dF9zdHJpbmcgb2MgcyA9XG4gIHVuc2FmZV9vdXRwdXRfc3RyaW5nIG9jIHMgMCAoc3RyaW5nX2xlbmd0aCBzKVxuXG5sZXQgb3V0cHV0IG9jIHMgb2ZzIGxlbiA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBieXRlc19sZW5ndGggcyAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwib3V0cHV0XCJcbiAgZWxzZSB1bnNhZmVfb3V0cHV0IG9jIHMgb2ZzIGxlblxuXG5sZXQgb3V0cHV0X3N1YnN0cmluZyBvYyBzIG9mcyBsZW4gPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gc3RyaW5nX2xlbmd0aCBzIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJvdXRwdXRfc3Vic3RyaW5nXCJcbiAgZWxzZSB1bnNhZmVfb3V0cHV0X3N0cmluZyBvYyBzIG9mcyBsZW5cblxuZXh0ZXJuYWwgb3V0cHV0X2J5dGUgOiBvdXRfY2hhbm5lbCAtPiBpbnQgLT4gdW5pdCA9IFwiY2FtbF9tbF9vdXRwdXRfY2hhclwiXG5leHRlcm5hbCBvdXRwdXRfYmluYXJ5X2ludCA6IG91dF9jaGFubmVsIC0+IGludCAtPiB1bml0ID0gXCJjYW1sX21sX291dHB1dF9pbnRcIlxuXG5leHRlcm5hbCBtYXJzaGFsX3RvX2NoYW5uZWwgOiBvdXRfY2hhbm5lbCAtPiAnYSAtPiB1bml0IGxpc3QgLT4gdW5pdFxuICAgICA9IFwiY2FtbF9vdXRwdXRfdmFsdWVcIlxubGV0IG91dHB1dF92YWx1ZSBjaGFuIHYgPSBtYXJzaGFsX3RvX2NoYW5uZWwgY2hhbiB2IFtdXG5cbmV4dGVybmFsIHNlZWtfb3V0IDogb3V0X2NoYW5uZWwgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfbWxfc2Vla19vdXRcIlxuZXh0ZXJuYWwgcG9zX291dCA6IG91dF9jaGFubmVsIC0+IGludCA9IFwiY2FtbF9tbF9wb3Nfb3V0XCJcbmV4dGVybmFsIG91dF9jaGFubmVsX2xlbmd0aCA6IG91dF9jaGFubmVsIC0+IGludCA9IFwiY2FtbF9tbF9jaGFubmVsX3NpemVcIlxuZXh0ZXJuYWwgY2xvc2Vfb3V0X2NoYW5uZWwgOiBvdXRfY2hhbm5lbCAtPiB1bml0ID0gXCJjYW1sX21sX2Nsb3NlX2NoYW5uZWxcIlxubGV0IGNsb3NlX291dCBvYyA9IGZsdXNoIG9jOyBjbG9zZV9vdXRfY2hhbm5lbCBvY1xubGV0IGNsb3NlX291dF9ub2VyciBvYyA9XG4gICh0cnkgZmx1c2ggb2Mgd2l0aCBfIC0+ICgpKTtcbiAgKHRyeSBjbG9zZV9vdXRfY2hhbm5lbCBvYyB3aXRoIF8gLT4gKCkpXG5leHRlcm5hbCBzZXRfYmluYXJ5X21vZGVfb3V0IDogb3V0X2NoYW5uZWwgLT4gYm9vbCAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX21sX3NldF9iaW5hcnlfbW9kZVwiXG5cbigqIEdlbmVyYWwgaW5wdXQgZnVuY3Rpb25zICopXG5cbmV4dGVybmFsIHNldF9pbl9jaGFubmVsX25hbWU6IGluX2NoYW5uZWwgLT4gc3RyaW5nIC0+IHVuaXQgPVxuICBcImNhbWxfbWxfc2V0X2NoYW5uZWxfbmFtZVwiXG5cbmxldCBvcGVuX2luX2dlbiBtb2RlIHBlcm0gbmFtZSA9XG4gIGxldCBjID0gb3Blbl9kZXNjcmlwdG9yX2luKG9wZW5fZGVzYyBuYW1lIG1vZGUgcGVybSkgaW5cbiAgc2V0X2luX2NoYW5uZWxfbmFtZSBjIG5hbWU7XG4gIGNcblxubGV0IG9wZW5faW4gbmFtZSA9XG4gIG9wZW5faW5fZ2VuIFtPcGVuX3Jkb25seTsgT3Blbl90ZXh0XSAwIG5hbWVcblxubGV0IG9wZW5faW5fYmluIG5hbWUgPVxuICBvcGVuX2luX2dlbiBbT3Blbl9yZG9ubHk7IE9wZW5fYmluYXJ5XSAwIG5hbWVcblxuZXh0ZXJuYWwgaW5wdXRfY2hhciA6IGluX2NoYW5uZWwgLT4gY2hhciA9IFwiY2FtbF9tbF9pbnB1dF9jaGFyXCJcblxuZXh0ZXJuYWwgdW5zYWZlX2lucHV0IDogaW5fY2hhbm5lbCAtPiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IGludFxuICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX21sX2lucHV0XCJcblxubGV0IGlucHV0IGljIHMgb2ZzIGxlbiA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBieXRlc19sZW5ndGggcyAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiaW5wdXRcIlxuICBlbHNlIHVuc2FmZV9pbnB1dCBpYyBzIG9mcyBsZW5cblxubGV0IHJlYyB1bnNhZmVfcmVhbGx5X2lucHV0IGljIHMgb2ZzIGxlbiA9XG4gIGlmIGxlbiA8PSAwIHRoZW4gKCkgZWxzZSBiZWdpblxuICAgIGxldCByID0gdW5zYWZlX2lucHV0IGljIHMgb2ZzIGxlbiBpblxuICAgIGlmIHIgPSAwXG4gICAgdGhlbiByYWlzZSBFbmRfb2ZfZmlsZVxuICAgIGVsc2UgdW5zYWZlX3JlYWxseV9pbnB1dCBpYyBzIChvZnMgKyByKSAobGVuIC0gcilcbiAgZW5kXG5cbmxldCByZWFsbHlfaW5wdXQgaWMgcyBvZnMgbGVuID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IGJ5dGVzX2xlbmd0aCBzIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJyZWFsbHlfaW5wdXRcIlxuICBlbHNlIHVuc2FmZV9yZWFsbHlfaW5wdXQgaWMgcyBvZnMgbGVuXG5cbmxldCByZWFsbHlfaW5wdXRfc3RyaW5nIGljIGxlbiA9XG4gIGxldCBzID0gYnl0ZXNfY3JlYXRlIGxlbiBpblxuICByZWFsbHlfaW5wdXQgaWMgcyAwIGxlbjtcbiAgYnl0ZXNfdW5zYWZlX3RvX3N0cmluZyBzXG5cbmV4dGVybmFsIGlucHV0X3NjYW5fbGluZSA6IGluX2NoYW5uZWwgLT4gaW50ID0gXCJjYW1sX21sX2lucHV0X3NjYW5fbGluZVwiXG5cbmxldCBpbnB1dF9saW5lIGNoYW4gPVxuICBsZXQgcmVjIGJ1aWxkX3Jlc3VsdCBidWYgcG9zID0gZnVuY3Rpb25cbiAgICBbXSAtPiBidWZcbiAgfCBoZCA6OiB0bCAtPlxuICAgICAgbGV0IGxlbiA9IGJ5dGVzX2xlbmd0aCBoZCBpblxuICAgICAgYnl0ZXNfYmxpdCBoZCAwIGJ1ZiAocG9zIC0gbGVuKSBsZW47XG4gICAgICBidWlsZF9yZXN1bHQgYnVmIChwb3MgLSBsZW4pIHRsIGluXG4gIGxldCByZWMgc2NhbiBhY2N1IGxlbiA9XG4gICAgbGV0IG4gPSBpbnB1dF9zY2FuX2xpbmUgY2hhbiBpblxuICAgIGlmIG4gPSAwIHRoZW4gYmVnaW4gICAgICAgICAgICAgICAgICAgKCogbiA9IDA6IHdlIGFyZSBhdCBFT0YgKilcbiAgICAgIG1hdGNoIGFjY3Ugd2l0aFxuICAgICAgICBbXSAtPiByYWlzZSBFbmRfb2ZfZmlsZVxuICAgICAgfCBfICAtPiBidWlsZF9yZXN1bHQgKGJ5dGVzX2NyZWF0ZSBsZW4pIGxlbiBhY2N1XG4gICAgZW5kIGVsc2UgaWYgbiA+IDAgdGhlbiBiZWdpbiAgICAgICAgICAoKiBuID4gMDogbmV3bGluZSBmb3VuZCBpbiBidWZmZXIgKilcbiAgICAgIGxldCByZXMgPSBieXRlc19jcmVhdGUgKG4gLSAxKSBpblxuICAgICAgaWdub3JlICh1bnNhZmVfaW5wdXQgY2hhbiByZXMgMCAobiAtIDEpKTtcbiAgICAgIGlnbm9yZSAoaW5wdXRfY2hhciBjaGFuKTsgICAgICAgICAgICgqIHNraXAgdGhlIG5ld2xpbmUgKilcbiAgICAgIG1hdGNoIGFjY3Ugd2l0aFxuICAgICAgICBbXSAtPiByZXNcbiAgICAgIHwgIF8gLT4gbGV0IGxlbiA9IGxlbiArIG4gLSAxIGluXG4gICAgICAgICAgICAgIGJ1aWxkX3Jlc3VsdCAoYnl0ZXNfY3JlYXRlIGxlbikgbGVuIChyZXMgOjogYWNjdSlcbiAgICBlbmQgZWxzZSBiZWdpbiAgICAgICAgICAgICAgICAgICAgICAgICgqIG4gPCAwOiBuZXdsaW5lIG5vdCBmb3VuZCAqKVxuICAgICAgbGV0IGJlZyA9IGJ5dGVzX2NyZWF0ZSAoLW4pIGluXG4gICAgICBpZ25vcmUodW5zYWZlX2lucHV0IGNoYW4gYmVnIDAgKC1uKSk7XG4gICAgICBzY2FuIChiZWcgOjogYWNjdSkgKGxlbiAtIG4pXG4gICAgZW5kXG4gIGluIGJ5dGVzX3Vuc2FmZV90b19zdHJpbmcgKHNjYW4gW10gMClcblxuZXh0ZXJuYWwgaW5wdXRfYnl0ZSA6IGluX2NoYW5uZWwgLT4gaW50ID0gXCJjYW1sX21sX2lucHV0X2NoYXJcIlxuZXh0ZXJuYWwgaW5wdXRfYmluYXJ5X2ludCA6IGluX2NoYW5uZWwgLT4gaW50ID0gXCJjYW1sX21sX2lucHV0X2ludFwiXG5leHRlcm5hbCBpbnB1dF92YWx1ZSA6IGluX2NoYW5uZWwgLT4gJ2EgPSBcImNhbWxfaW5wdXRfdmFsdWVcIlxuZXh0ZXJuYWwgc2Vla19pbiA6IGluX2NoYW5uZWwgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfbWxfc2Vla19pblwiXG5leHRlcm5hbCBwb3NfaW4gOiBpbl9jaGFubmVsIC0+IGludCA9IFwiY2FtbF9tbF9wb3NfaW5cIlxuZXh0ZXJuYWwgaW5fY2hhbm5lbF9sZW5ndGggOiBpbl9jaGFubmVsIC0+IGludCA9IFwiY2FtbF9tbF9jaGFubmVsX3NpemVcIlxuZXh0ZXJuYWwgY2xvc2VfaW4gOiBpbl9jaGFubmVsIC0+IHVuaXQgPSBcImNhbWxfbWxfY2xvc2VfY2hhbm5lbFwiXG5sZXQgY2xvc2VfaW5fbm9lcnIgaWMgPSAodHJ5IGNsb3NlX2luIGljIHdpdGggXyAtPiAoKSlcbmV4dGVybmFsIHNldF9iaW5hcnlfbW9kZV9pbiA6IGluX2NoYW5uZWwgLT4gYm9vbCAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfbWxfc2V0X2JpbmFyeV9tb2RlXCJcblxuKCogT3V0cHV0IGZ1bmN0aW9ucyBvbiBzdGFuZGFyZCBvdXRwdXQgKilcblxubGV0IHByaW50X2NoYXIgYyA9IG91dHB1dF9jaGFyIHN0ZG91dCBjXG5sZXQgcHJpbnRfc3RyaW5nIHMgPSBvdXRwdXRfc3RyaW5nIHN0ZG91dCBzXG5sZXQgcHJpbnRfYnl0ZXMgcyA9IG91dHB1dF9ieXRlcyBzdGRvdXQgc1xubGV0IHByaW50X2ludCBpID0gb3V0cHV0X3N0cmluZyBzdGRvdXQgKHN0cmluZ19vZl9pbnQgaSlcbmxldCBwcmludF9mbG9hdCBmID0gb3V0cHV0X3N0cmluZyBzdGRvdXQgKHN0cmluZ19vZl9mbG9hdCBmKVxubGV0IHByaW50X2VuZGxpbmUgcyA9XG4gIG91dHB1dF9zdHJpbmcgc3Rkb3V0IHM7IG91dHB1dF9jaGFyIHN0ZG91dCAnXFxuJzsgZmx1c2ggc3Rkb3V0XG5sZXQgcHJpbnRfbmV3bGluZSAoKSA9IG91dHB1dF9jaGFyIHN0ZG91dCAnXFxuJzsgZmx1c2ggc3Rkb3V0XG5cbigqIE91dHB1dCBmdW5jdGlvbnMgb24gc3RhbmRhcmQgZXJyb3IgKilcblxubGV0IHByZXJyX2NoYXIgYyA9IG91dHB1dF9jaGFyIHN0ZGVyciBjXG5sZXQgcHJlcnJfc3RyaW5nIHMgPSBvdXRwdXRfc3RyaW5nIHN0ZGVyciBzXG5sZXQgcHJlcnJfYnl0ZXMgcyA9IG91dHB1dF9ieXRlcyBzdGRlcnIgc1xubGV0IHByZXJyX2ludCBpID0gb3V0cHV0X3N0cmluZyBzdGRlcnIgKHN0cmluZ19vZl9pbnQgaSlcbmxldCBwcmVycl9mbG9hdCBmID0gb3V0cHV0X3N0cmluZyBzdGRlcnIgKHN0cmluZ19vZl9mbG9hdCBmKVxubGV0IHByZXJyX2VuZGxpbmUgcyA9XG4gIG91dHB1dF9zdHJpbmcgc3RkZXJyIHM7IG91dHB1dF9jaGFyIHN0ZGVyciAnXFxuJzsgZmx1c2ggc3RkZXJyXG5sZXQgcHJlcnJfbmV3bGluZSAoKSA9IG91dHB1dF9jaGFyIHN0ZGVyciAnXFxuJzsgZmx1c2ggc3RkZXJyXG5cbigqIElucHV0IGZ1bmN0aW9ucyBvbiBzdGFuZGFyZCBpbnB1dCAqKVxuXG5sZXQgcmVhZF9saW5lICgpID0gZmx1c2ggc3Rkb3V0OyBpbnB1dF9saW5lIHN0ZGluXG5sZXQgcmVhZF9pbnQgKCkgPSBpbnRfb2Zfc3RyaW5nKHJlYWRfbGluZSgpKVxubGV0IHJlYWRfaW50X29wdCAoKSA9IGludF9vZl9zdHJpbmdfb3B0KHJlYWRfbGluZSgpKVxubGV0IHJlYWRfZmxvYXQgKCkgPSBmbG9hdF9vZl9zdHJpbmcocmVhZF9saW5lKCkpXG5sZXQgcmVhZF9mbG9hdF9vcHQgKCkgPSBmbG9hdF9vZl9zdHJpbmdfb3B0KHJlYWRfbGluZSgpKVxuXG4oKiBPcGVyYXRpb25zIG9uIGxhcmdlIGZpbGVzICopXG5cbm1vZHVsZSBMYXJnZUZpbGUgPVxuICBzdHJ1Y3RcbiAgICBleHRlcm5hbCBzZWVrX291dCA6IG91dF9jaGFubmVsIC0+IGludDY0IC0+IHVuaXQgPSBcImNhbWxfbWxfc2Vla19vdXRfNjRcIlxuICAgIGV4dGVybmFsIHBvc19vdXQgOiBvdXRfY2hhbm5lbCAtPiBpbnQ2NCA9IFwiY2FtbF9tbF9wb3Nfb3V0XzY0XCJcbiAgICBleHRlcm5hbCBvdXRfY2hhbm5lbF9sZW5ndGggOiBvdXRfY2hhbm5lbCAtPiBpbnQ2NFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9tbF9jaGFubmVsX3NpemVfNjRcIlxuICAgIGV4dGVybmFsIHNlZWtfaW4gOiBpbl9jaGFubmVsIC0+IGludDY0IC0+IHVuaXQgPSBcImNhbWxfbWxfc2Vla19pbl82NFwiXG4gICAgZXh0ZXJuYWwgcG9zX2luIDogaW5fY2hhbm5lbCAtPiBpbnQ2NCA9IFwiY2FtbF9tbF9wb3NfaW5fNjRcIlxuICAgIGV4dGVybmFsIGluX2NoYW5uZWxfbGVuZ3RoIDogaW5fY2hhbm5lbCAtPiBpbnQ2NCA9IFwiY2FtbF9tbF9jaGFubmVsX3NpemVfNjRcIlxuICBlbmRcblxuKCogRm9ybWF0cyAqKVxuXG50eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2XG4gICA9ICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3MuZm9ybWF0NlxuICAgPSBGb3JtYXQgb2YgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljcy5mbXRcbiAgICAgICAgICAgICAgICogc3RyaW5nXG5cbnR5cGUgKCdhLCAnYiwgJ2MsICdkKSBmb3JtYXQ0ID0gKCdhLCAnYiwgJ2MsICdjLCAnYywgJ2QpIGZvcm1hdDZcblxudHlwZSAoJ2EsICdiLCAnYykgZm9ybWF0ID0gKCdhLCAnYiwgJ2MsICdjKSBmb3JtYXQ0XG5cbmxldCBzdHJpbmdfb2ZfZm9ybWF0IChGb3JtYXQgKF9mbXQsIHN0cikpID0gc3RyXG5cbmV4dGVybmFsIGZvcm1hdF9vZl9zdHJpbmcgOlxuICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2IC0+XG4gKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgPSBcIiVpZGVudGl0eVwiXG5cbmxldCAoIF5eICkgKEZvcm1hdCAoZm10MSwgc3RyMSkpIChGb3JtYXQgKGZtdDIsIHN0cjIpKSA9XG4gIEZvcm1hdCAoQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzLmNvbmNhdF9mbXQgZm10MSBmbXQyLFxuICAgICAgICAgIHN0cjEgXiBcIiUsXCIgXiBzdHIyKVxuXG4oKiBNaXNjZWxsYW5lb3VzICopXG5cbmV4dGVybmFsIHN5c19leGl0IDogaW50IC0+ICdhID0gXCJjYW1sX3N5c19leGl0XCJcblxubGV0IGV4aXRfZnVuY3Rpb24gPSBDYW1saW50ZXJuYWxBdG9taWMubWFrZSBmbHVzaF9hbGxcblxubGV0IHJlYyBhdF9leGl0IGYgPVxuICBsZXQgbW9kdWxlIEF0b21pYyA9IENhbWxpbnRlcm5hbEF0b21pYyBpblxuICAoKiBNUFIjNzI1MywgTVBSIzc3OTY6IG1ha2Ugc3VyZSBcImZcIiBpcyBleGVjdXRlZCBvbmx5IG9uY2UgKilcbiAgbGV0IGZfeWV0X3RvX3J1biA9IEF0b21pYy5tYWtlIHRydWUgaW5cbiAgbGV0IG9sZF9leGl0ID0gQXRvbWljLmdldCBleGl0X2Z1bmN0aW9uIGluXG4gIGxldCBuZXdfZXhpdCAoKSA9XG4gICAgaWYgQXRvbWljLmNvbXBhcmVfYW5kX3NldCBmX3lldF90b19ydW4gdHJ1ZSBmYWxzZSB0aGVuIGYgKCkgO1xuICAgIG9sZF9leGl0ICgpXG4gIGluXG4gIGxldCBzdWNjZXNzID0gQXRvbWljLmNvbXBhcmVfYW5kX3NldCBleGl0X2Z1bmN0aW9uIG9sZF9leGl0IG5ld19leGl0IGluXG4gIGlmIG5vdCBzdWNjZXNzIHRoZW4gYXRfZXhpdCBmXG5cbmxldCBkb19hdF9leGl0ICgpID0gKENhbWxpbnRlcm5hbEF0b21pYy5nZXQgZXhpdF9mdW5jdGlvbikgKClcblxubGV0IGV4aXQgcmV0Y29kZSA9XG4gIGRvX2F0X2V4aXQgKCk7XG4gIHN5c19leGl0IHJldGNvZGVcblxubGV0IF8gPSByZWdpc3Rlcl9uYW1lZF92YWx1ZSBcIlBlcnZhc2l2ZXMuZG9fYXRfZXhpdFwiIGRvX2F0X2V4aXRcblxuZXh0ZXJuYWwgbWFqb3IgOiB1bml0IC0+IHVuaXQgPSBcImNhbWxfZ2NfbWFqb3JcIlxuZXh0ZXJuYWwgbmFrZWRfcG9pbnRlcnNfY2hlY2tlZCA6IHVuaXQgLT4gYm9vbFxuICA9IFwiY2FtbF9zeXNfY29uc3RfbmFrZWRfcG9pbnRlcnNfY2hlY2tlZFwiXG5sZXQgKCkgPSBpZiBuYWtlZF9wb2ludGVyc19jaGVja2VkICgpIHRoZW4gYXRfZXhpdCBtYWpvclxuXG4oKk1PRFVMRV9BTElBU0VTKilcbm1vZHVsZSBBcmcgICAgICAgICAgPSBBcmdcbm1vZHVsZSBBcnJheSAgICAgICAgPSBBcnJheVxubW9kdWxlIEFycmF5TGFiZWxzICA9IEFycmF5TGFiZWxzXG5tb2R1bGUgQXRvbWljICAgICAgID0gQXRvbWljXG5tb2R1bGUgQmlnYXJyYXkgICAgID0gQmlnYXJyYXlcbm1vZHVsZSBCb29sICAgICAgICAgPSBCb29sXG5tb2R1bGUgQnVmZmVyICAgICAgID0gQnVmZmVyXG5tb2R1bGUgQnl0ZXMgICAgICAgID0gQnl0ZXNcbm1vZHVsZSBCeXRlc0xhYmVscyAgPSBCeXRlc0xhYmVsc1xubW9kdWxlIENhbGxiYWNrICAgICA9IENhbGxiYWNrXG5tb2R1bGUgQ2hhciAgICAgICAgID0gQ2hhclxubW9kdWxlIENvbXBsZXggICAgICA9IENvbXBsZXhcbm1vZHVsZSBEaWdlc3QgICAgICAgPSBEaWdlc3Rcbm1vZHVsZSBFaXRoZXIgICAgICAgPSBFaXRoZXJcbm1vZHVsZSBFcGhlbWVyb24gICAgPSBFcGhlbWVyb25cbm1vZHVsZSBGaWxlbmFtZSAgICAgPSBGaWxlbmFtZVxubW9kdWxlIEZsb2F0ICAgICAgICA9IEZsb2F0XG5tb2R1bGUgRm9ybWF0ICAgICAgID0gRm9ybWF0XG5tb2R1bGUgRnVuICAgICAgICAgID0gRnVuXG5tb2R1bGUgR2MgICAgICAgICAgID0gR2Ncbm1vZHVsZSBHZW5sZXggICAgICAgPSBHZW5sZXhcbm1vZHVsZSBIYXNodGJsICAgICAgPSBIYXNodGJsXG5tb2R1bGUgSW50ICAgICAgICAgID0gSW50XG5tb2R1bGUgSW50MzIgICAgICAgID0gSW50MzJcbm1vZHVsZSBJbnQ2NCAgICAgICAgPSBJbnQ2NFxubW9kdWxlIExhenkgICAgICAgICA9IExhenlcbm1vZHVsZSBMZXhpbmcgICAgICAgPSBMZXhpbmdcbm1vZHVsZSBMaXN0ICAgICAgICAgPSBMaXN0XG5tb2R1bGUgTGlzdExhYmVscyAgID0gTGlzdExhYmVsc1xubW9kdWxlIE1hcCAgICAgICAgICA9IE1hcFxubW9kdWxlIE1hcnNoYWwgICAgICA9IE1hcnNoYWxcbm1vZHVsZSBNb3JlTGFiZWxzICAgPSBNb3JlTGFiZWxzXG5tb2R1bGUgTmF0aXZlaW50ICAgID0gTmF0aXZlaW50XG5tb2R1bGUgT2JqICAgICAgICAgID0gT2JqXG5tb2R1bGUgT28gICAgICAgICAgID0gT29cbm1vZHVsZSBPcHRpb24gICAgICAgPSBPcHRpb25cbm1vZHVsZSBQYXJzaW5nICAgICAgPSBQYXJzaW5nXG5tb2R1bGUgUGVydmFzaXZlcyAgID0gUGVydmFzaXZlc1xubW9kdWxlIFByaW50ZXhjICAgICA9IFByaW50ZXhjXG5tb2R1bGUgUHJpbnRmICAgICAgID0gUHJpbnRmXG5tb2R1bGUgUXVldWUgICAgICAgID0gUXVldWVcbm1vZHVsZSBSYW5kb20gICAgICAgPSBSYW5kb21cbm1vZHVsZSBSZXN1bHQgICAgICAgPSBSZXN1bHRcbm1vZHVsZSBTY2FuZiAgICAgICAgPSBTY2FuZlxubW9kdWxlIFNlcSAgICAgICAgICA9IFNlcVxubW9kdWxlIFNldCAgICAgICAgICA9IFNldFxubW9kdWxlIFN0YWNrICAgICAgICA9IFN0YWNrXG5tb2R1bGUgU3RkTGFiZWxzICAgID0gU3RkTGFiZWxzXG5tb2R1bGUgU3RyZWFtICAgICAgID0gU3RyZWFtXG5tb2R1bGUgU3RyaW5nICAgICAgID0gU3RyaW5nXG5tb2R1bGUgU3RyaW5nTGFiZWxzID0gU3RyaW5nTGFiZWxzXG5tb2R1bGUgU3lzICAgICAgICAgID0gU3lzXG5tb2R1bGUgVWNoYXIgICAgICAgID0gVWNoYXJcbm1vZHVsZSBVbml0ICAgICAgICAgPSBVbml0XG5tb2R1bGUgV2VhayAgICAgICAgID0gV2Vha1xuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgSmVyZW1pZSBEaW1pbm8sIEphbmUgU3RyZWV0IEV1cm9wZSAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxNyBKYW5lIFN0cmVldCBHcm91cCBMTEMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiogQGRlcHJlY2F0ZWQgVXNlIHshU3RkbGlifSAqKVxuXG5leHRlcm5hbCByYWlzZSA6IGV4biAtPiAnYSA9IFwiJXJhaXNlXCJcbmV4dGVybmFsIHJhaXNlX25vdHJhY2UgOiBleG4gLT4gJ2EgPSBcIiVyYWlzZV9ub3RyYWNlXCJcbmxldCBpbnZhbGlkX2FyZyA9IGludmFsaWRfYXJnXG5sZXQgZmFpbHdpdGggPSBmYWlsd2l0aFxuZXhjZXB0aW9uIEV4aXRcbmV4dGVybmFsICggPSApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWVxdWFsXCJcbmV4dGVybmFsICggPD4gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVub3RlcXVhbFwiXG5leHRlcm5hbCAoIDwgKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVsZXNzdGhhblwiXG5leHRlcm5hbCAoID4gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVncmVhdGVydGhhblwiXG5leHRlcm5hbCAoIDw9ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlbGVzc2VxdWFsXCJcbmV4dGVybmFsICggPj0gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVncmVhdGVyZXF1YWxcIlxuZXh0ZXJuYWwgY29tcGFyZSA6ICdhIC0+ICdhIC0+IGludCA9IFwiJWNvbXBhcmVcIlxubGV0IG1pbiA9IG1pblxubGV0IG1heCA9IG1heFxuZXh0ZXJuYWwgKCA9PSApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWVxXCJcbmV4dGVybmFsICggIT0gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVub3RlcVwiXG5leHRlcm5hbCBub3QgOiBib29sIC0+IGJvb2wgPSBcIiVib29sbm90XCJcbmV4dGVybmFsICggJiYgKSA6IGJvb2wgLT4gYm9vbCAtPiBib29sID0gXCIlc2VxdWFuZFwiXG5leHRlcm5hbCAoICYgKSA6IGJvb2wgLT4gYm9vbCAtPiBib29sID0gXCIlc2VxdWFuZFwiXG4gIFtAQG9jYW1sLmRlcHJlY2F0ZWQgXCJVc2UgKCYmKSBpbnN0ZWFkLlwiXVxuZXh0ZXJuYWwgKCB8fCApIDogYm9vbCAtPiBib29sIC0+IGJvb2wgPSBcIiVzZXF1b3JcIlxuZXh0ZXJuYWwgKCBvciApIDogYm9vbCAtPiBib29sIC0+IGJvb2wgPSBcIiVzZXF1b3JcIlxuICBbQEBvY2FtbC5kZXByZWNhdGVkIFwiVXNlICh8fCkgaW5zdGVhZC5cIl1cbmV4dGVybmFsIF9fTE9DX18gOiBzdHJpbmcgPSBcIiVsb2NfTE9DXCJcbmV4dGVybmFsIF9fRklMRV9fIDogc3RyaW5nID0gXCIlbG9jX0ZJTEVcIlxuZXh0ZXJuYWwgX19MSU5FX18gOiBpbnQgPSBcIiVsb2NfTElORVwiXG5leHRlcm5hbCBfX01PRFVMRV9fIDogc3RyaW5nID0gXCIlbG9jX01PRFVMRVwiXG5leHRlcm5hbCBfX1BPU19fIDogc3RyaW5nICogaW50ICogaW50ICogaW50ID0gXCIlbG9jX1BPU1wiXG5leHRlcm5hbCBfX0xPQ19PRl9fIDogJ2EgLT4gc3RyaW5nICogJ2EgPSBcIiVsb2NfTE9DXCJcbmV4dGVybmFsIF9fTElORV9PRl9fIDogJ2EgLT4gaW50ICogJ2EgPSBcIiVsb2NfTElORVwiXG5leHRlcm5hbCBfX1BPU19PRl9fIDogJ2EgLT4gKHN0cmluZyAqIGludCAqIGludCAqIGludCkgKiAnYSA9IFwiJWxvY19QT1NcIlxuZXh0ZXJuYWwgKCB8PiApIDogJ2EgLT4gKCdhIC0+ICdiKSAtPiAnYiA9IFwiJXJldmFwcGx5XCJcbmV4dGVybmFsICggQEAgKSA6ICgnYSAtPiAnYikgLT4gJ2EgLT4gJ2IgPSBcIiVhcHBseVwiXG5leHRlcm5hbCAoIH4tICkgOiBpbnQgLT4gaW50ID0gXCIlbmVnaW50XCJcbmV4dGVybmFsICggfisgKSA6IGludCAtPiBpbnQgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCBzdWNjIDogaW50IC0+IGludCA9IFwiJXN1Y2NpbnRcIlxuZXh0ZXJuYWwgcHJlZCA6IGludCAtPiBpbnQgPSBcIiVwcmVkaW50XCJcbmV4dGVybmFsICggKyApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVhZGRpbnRcIlxuZXh0ZXJuYWwgKCAtICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJXN1YmludFwiXG5leHRlcm5hbCAoICogKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlbXVsaW50XCJcbmV4dGVybmFsICggLyApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVkaXZpbnRcIlxuZXh0ZXJuYWwgKCBtb2QgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlbW9kaW50XCJcbmxldCBhYnMgPSBhYnNcbmxldCBtYXhfaW50ID0gbWF4X2ludFxubGV0IG1pbl9pbnQgPSBtaW5faW50XG5leHRlcm5hbCAoIGxhbmQgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlYW5kaW50XCJcbmV4dGVybmFsICggbG9yICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJW9yaW50XCJcbmV4dGVybmFsICggbHhvciApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiV4b3JpbnRcIlxubGV0IGxub3QgPSBsbm90XG5leHRlcm5hbCAoIGxzbCApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVsc2xpbnRcIlxuZXh0ZXJuYWwgKCBsc3IgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlbHNyaW50XCJcbmV4dGVybmFsICggYXNyICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWFzcmludFwiXG5leHRlcm5hbCAoIH4tLiApIDogZmxvYXQgLT4gZmxvYXQgPSBcIiVuZWdmbG9hdFwiXG5leHRlcm5hbCAoIH4rLiApIDogZmxvYXQgLT4gZmxvYXQgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCAoICsuICkgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiJWFkZGZsb2F0XCJcbmV4dGVybmFsICggLS4gKSA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCIlc3ViZmxvYXRcIlxuZXh0ZXJuYWwgKCAqLiApIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcIiVtdWxmbG9hdFwiXG5leHRlcm5hbCAoIC8uICkgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiJWRpdmZsb2F0XCJcbmV4dGVybmFsICggKiogKSA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3Bvd2VyX2Zsb2F0XCIgXCJwb3dcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgc3FydCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3NxcnRfZmxvYXRcIiBcInNxcnRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZXhwIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfZXhwX2Zsb2F0XCIgXCJleHBcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgbG9nIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfbG9nX2Zsb2F0XCIgXCJsb2dcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgbG9nMTAgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9sb2cxMF9mbG9hdFwiIFwibG9nMTBcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZXhwbTEgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9leHBtMV9mbG9hdFwiIFwiY2FtbF9leHBtMVwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBsb2cxcCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2xvZzFwX2Zsb2F0XCIgXCJjYW1sX2xvZzFwXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGNvcyA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Nvc19mbG9hdFwiIFwiY29zXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHNpbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3Npbl9mbG9hdFwiIFwic2luXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHRhbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3Rhbl9mbG9hdFwiIFwidGFuXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGFjb3MgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hY29zX2Zsb2F0XCIgXCJhY29zXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGFzaW4gOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hc2luX2Zsb2F0XCIgXCJhc2luXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGF0YW4gOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hdGFuX2Zsb2F0XCIgXCJhdGFuXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGF0YW4yIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYXRhbjJfZmxvYXRcIiBcImF0YW4yXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGh5cG90IDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfaHlwb3RfZmxvYXRcIiBcImNhbWxfaHlwb3RcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgY29zaCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Nvc2hfZmxvYXRcIiBcImNvc2hcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgc2luaCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3NpbmhfZmxvYXRcIiBcInNpbmhcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdGFuaCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3RhbmhfZmxvYXRcIiBcInRhbmhcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgY2VpbCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2NlaWxfZmxvYXRcIiBcImNlaWxcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZmxvb3IgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9mbG9vcl9mbG9hdFwiIFwiZmxvb3JcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYWJzX2Zsb2F0IDogZmxvYXQgLT4gZmxvYXQgPSBcIiVhYnNmbG9hdFwiXG5leHRlcm5hbCBjb3B5c2lnbiA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0XG4gICAgICAgICAgICAgICAgICA9IFwiY2FtbF9jb3B5c2lnbl9mbG9hdFwiIFwiY2FtbF9jb3B5c2lnblwiXG4gICAgICAgICAgICAgICAgICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgbW9kX2Zsb2F0IDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfZm1vZF9mbG9hdFwiIFwiZm1vZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBmcmV4cCA6IGZsb2F0IC0+IGZsb2F0ICogaW50ID0gXCJjYW1sX2ZyZXhwX2Zsb2F0XCJcbmV4dGVybmFsIGxkZXhwIDogKGZsb2F0IFtAdW5ib3hlZF0pIC0+IChpbnQgW0B1bnRhZ2dlZF0pIC0+IChmbG9hdCBbQHVuYm94ZWRdKSA9XG4gIFwiY2FtbF9sZGV4cF9mbG9hdFwiIFwiY2FtbF9sZGV4cF9mbG9hdF91bmJveGVkXCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIG1vZGYgOiBmbG9hdCAtPiBmbG9hdCAqIGZsb2F0ID0gXCJjYW1sX21vZGZfZmxvYXRcIlxuZXh0ZXJuYWwgZmxvYXQgOiBpbnQgLT4gZmxvYXQgPSBcIiVmbG9hdG9maW50XCJcbmV4dGVybmFsIGZsb2F0X29mX2ludCA6IGludCAtPiBmbG9hdCA9IFwiJWZsb2F0b2ZpbnRcIlxuZXh0ZXJuYWwgdHJ1bmNhdGUgOiBmbG9hdCAtPiBpbnQgPSBcIiVpbnRvZmZsb2F0XCJcbmV4dGVybmFsIGludF9vZl9mbG9hdCA6IGZsb2F0IC0+IGludCA9IFwiJWludG9mZmxvYXRcIlxubGV0IGluZmluaXR5ID0gaW5maW5pdHlcbmxldCBuZWdfaW5maW5pdHkgPSBuZWdfaW5maW5pdHlcbmxldCBuYW4gPSBuYW5cbmxldCBtYXhfZmxvYXQgPSBtYXhfZmxvYXRcbmxldCBtaW5fZmxvYXQgPSBtaW5fZmxvYXRcbmxldCBlcHNpbG9uX2Zsb2F0ID0gZXBzaWxvbl9mbG9hdFxudHlwZSBub25yZWMgZnBjbGFzcyA9IGZwY2xhc3MgPVxuICAgIEZQX25vcm1hbFxuICB8IEZQX3N1Ym5vcm1hbFxuICB8IEZQX3plcm9cbiAgfCBGUF9pbmZpbml0ZVxuICB8IEZQX25hblxuZXh0ZXJuYWwgY2xhc3NpZnlfZmxvYXQgOiAoZmxvYXQgW0B1bmJveGVkXSkgLT4gZnBjbGFzcyA9XG4gIFwiY2FtbF9jbGFzc2lmeV9mbG9hdFwiIFwiY2FtbF9jbGFzc2lmeV9mbG9hdF91bmJveGVkXCIgW0BAbm9hbGxvY11cbmxldCAoIF4gKSA9ICggXiApXG5leHRlcm5hbCBpbnRfb2ZfY2hhciA6IGNoYXIgLT4gaW50ID0gXCIlaWRlbnRpdHlcIlxubGV0IGNoYXJfb2ZfaW50ID0gY2hhcl9vZl9pbnRcbmV4dGVybmFsIGlnbm9yZSA6ICdhIC0+IHVuaXQgPSBcIiVpZ25vcmVcIlxubGV0IHN0cmluZ19vZl9ib29sID0gc3RyaW5nX29mX2Jvb2xcbmxldCBib29sX29mX3N0cmluZyA9IGJvb2xfb2Zfc3RyaW5nXG5sZXQgYm9vbF9vZl9zdHJpbmdfb3B0ID0gYm9vbF9vZl9zdHJpbmdfb3B0XG5sZXQgc3RyaW5nX29mX2ludCA9IHN0cmluZ19vZl9pbnRcbmV4dGVybmFsIGludF9vZl9zdHJpbmcgOiBzdHJpbmcgLT4gaW50ID0gXCJjYW1sX2ludF9vZl9zdHJpbmdcIlxubGV0IGludF9vZl9zdHJpbmdfb3B0ID0gaW50X29mX3N0cmluZ19vcHRcbmxldCBzdHJpbmdfb2ZfZmxvYXQgPSBzdHJpbmdfb2ZfZmxvYXRcbmV4dGVybmFsIGZsb2F0X29mX3N0cmluZyA6IHN0cmluZyAtPiBmbG9hdCA9IFwiY2FtbF9mbG9hdF9vZl9zdHJpbmdcIlxubGV0IGZsb2F0X29mX3N0cmluZ19vcHQgPSBmbG9hdF9vZl9zdHJpbmdfb3B0XG5leHRlcm5hbCBmc3QgOiAnYSAqICdiIC0+ICdhID0gXCIlZmllbGQwXCJcbmV4dGVybmFsIHNuZCA6ICdhICogJ2IgLT4gJ2IgPSBcIiVmaWVsZDFcIlxubGV0ICggQCApICA9ICggQCApXG50eXBlIG5vbnJlYyBpbl9jaGFubmVsID0gaW5fY2hhbm5lbFxudHlwZSBub25yZWMgb3V0X2NoYW5uZWwgPSBvdXRfY2hhbm5lbFxubGV0IHN0ZGluID0gc3RkaW5cbmxldCBzdGRvdXQgPSBzdGRvdXRcbmxldCBzdGRlcnIgPSBzdGRlcnJcbmxldCBwcmludF9jaGFyID0gcHJpbnRfY2hhclxubGV0IHByaW50X3N0cmluZyA9IHByaW50X3N0cmluZ1xubGV0IHByaW50X2J5dGVzID0gcHJpbnRfYnl0ZXNcbmxldCBwcmludF9pbnQgPSBwcmludF9pbnRcbmxldCBwcmludF9mbG9hdCA9IHByaW50X2Zsb2F0XG5sZXQgcHJpbnRfZW5kbGluZSA9IHByaW50X2VuZGxpbmVcbmxldCBwcmludF9uZXdsaW5lID0gcHJpbnRfbmV3bGluZVxubGV0IHByZXJyX2NoYXIgPSBwcmVycl9jaGFyXG5sZXQgcHJlcnJfc3RyaW5nID0gcHJlcnJfc3RyaW5nXG5sZXQgcHJlcnJfYnl0ZXMgPSBwcmVycl9ieXRlc1xubGV0IHByZXJyX2ludCA9IHByZXJyX2ludFxubGV0IHByZXJyX2Zsb2F0ID0gcHJlcnJfZmxvYXRcbmxldCBwcmVycl9lbmRsaW5lID0gcHJlcnJfZW5kbGluZVxubGV0IHByZXJyX25ld2xpbmUgPSBwcmVycl9uZXdsaW5lXG5sZXQgcmVhZF9saW5lID0gcmVhZF9saW5lXG5sZXQgcmVhZF9pbnQgPSByZWFkX2ludFxubGV0IHJlYWRfaW50X29wdCA9IHJlYWRfaW50X29wdFxubGV0IHJlYWRfZmxvYXQgPSByZWFkX2Zsb2F0XG5sZXQgcmVhZF9mbG9hdF9vcHQgPSByZWFkX2Zsb2F0X29wdFxudHlwZSBub25yZWMgb3Blbl9mbGFnID0gb3Blbl9mbGFnID1cbiAgICBPcGVuX3Jkb25seVxuICB8IE9wZW5fd3Jvbmx5XG4gIHwgT3Blbl9hcHBlbmRcbiAgfCBPcGVuX2NyZWF0XG4gIHwgT3Blbl90cnVuY1xuICB8IE9wZW5fZXhjbFxuICB8IE9wZW5fYmluYXJ5XG4gIHwgT3Blbl90ZXh0XG4gIHwgT3Blbl9ub25ibG9ja1xubGV0IG9wZW5fb3V0ID0gb3Blbl9vdXRcbmxldCBvcGVuX291dF9iaW4gPSBvcGVuX291dF9iaW5cbmxldCBvcGVuX291dF9nZW4gPSBvcGVuX291dF9nZW5cbmxldCBmbHVzaCA9IGZsdXNoXG5sZXQgZmx1c2hfYWxsID0gZmx1c2hfYWxsXG5sZXQgb3V0cHV0X2NoYXIgPSBvdXRwdXRfY2hhclxubGV0IG91dHB1dF9zdHJpbmcgPSBvdXRwdXRfc3RyaW5nXG5sZXQgb3V0cHV0X2J5dGVzID0gb3V0cHV0X2J5dGVzXG5sZXQgb3V0cHV0ID0gb3V0cHV0XG5sZXQgb3V0cHV0X3N1YnN0cmluZyA9IG91dHB1dF9zdWJzdHJpbmdcbmxldCBvdXRwdXRfYnl0ZSA9IG91dHB1dF9ieXRlXG5sZXQgb3V0cHV0X2JpbmFyeV9pbnQgPSBvdXRwdXRfYmluYXJ5X2ludFxubGV0IG91dHB1dF92YWx1ZSA9IG91dHB1dF92YWx1ZVxubGV0IHNlZWtfb3V0ID0gc2Vla19vdXRcbmxldCBwb3Nfb3V0ID0gcG9zX291dFxubGV0IG91dF9jaGFubmVsX2xlbmd0aCA9IG91dF9jaGFubmVsX2xlbmd0aFxubGV0IGNsb3NlX291dCA9IGNsb3NlX291dFxubGV0IGNsb3NlX291dF9ub2VyciA9IGNsb3NlX291dF9ub2VyclxubGV0IHNldF9iaW5hcnlfbW9kZV9vdXQgPSBzZXRfYmluYXJ5X21vZGVfb3V0XG5sZXQgb3Blbl9pbiA9IG9wZW5faW5cbmxldCBvcGVuX2luX2JpbiA9IG9wZW5faW5fYmluXG5sZXQgb3Blbl9pbl9nZW4gPSBvcGVuX2luX2dlblxubGV0IGlucHV0X2NoYXIgPSBpbnB1dF9jaGFyXG5sZXQgaW5wdXRfbGluZSA9IGlucHV0X2xpbmVcbmxldCBpbnB1dCA9IGlucHV0XG5sZXQgcmVhbGx5X2lucHV0ID0gcmVhbGx5X2lucHV0XG5sZXQgcmVhbGx5X2lucHV0X3N0cmluZyA9IHJlYWxseV9pbnB1dF9zdHJpbmdcbmxldCBpbnB1dF9ieXRlID0gaW5wdXRfYnl0ZVxubGV0IGlucHV0X2JpbmFyeV9pbnQgPSBpbnB1dF9iaW5hcnlfaW50XG5sZXQgaW5wdXRfdmFsdWUgPSBpbnB1dF92YWx1ZVxubGV0IHNlZWtfaW4gPSBzZWVrX2luXG5sZXQgcG9zX2luID0gcG9zX2luXG5sZXQgaW5fY2hhbm5lbF9sZW5ndGggPSBpbl9jaGFubmVsX2xlbmd0aFxubGV0IGNsb3NlX2luID0gY2xvc2VfaW5cbmxldCBjbG9zZV9pbl9ub2VyciA9IGNsb3NlX2luX25vZXJyXG5sZXQgc2V0X2JpbmFyeV9tb2RlX2luID0gc2V0X2JpbmFyeV9tb2RlX2luXG5tb2R1bGUgTGFyZ2VGaWxlID0gTGFyZ2VGaWxlXG50eXBlIG5vbnJlYyAnYSByZWYgPSAnYSByZWYgPSB7IG11dGFibGUgY29udGVudHMgOiAnYSB9XG5leHRlcm5hbCByZWYgOiAnYSAtPiAnYSByZWYgPSBcIiVtYWtlbXV0YWJsZVwiXG5leHRlcm5hbCAoICEgKSA6ICdhIHJlZiAtPiAnYSA9IFwiJWZpZWxkMFwiXG5leHRlcm5hbCAoIDo9ICkgOiAnYSByZWYgLT4gJ2EgLT4gdW5pdCA9IFwiJXNldGZpZWxkMFwiXG5leHRlcm5hbCBpbmNyIDogaW50IHJlZiAtPiB1bml0ID0gXCIlaW5jclwiXG5leHRlcm5hbCBkZWNyIDogaW50IHJlZiAtPiB1bml0ID0gXCIlZGVjclwiXG50eXBlIG5vbnJlYyAoJ2EsJ2IpIHJlc3VsdCA9ICgnYSwnYikgcmVzdWx0ID0gT2sgb2YgJ2EgfCBFcnJvciBvZiAnYlxudHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiA9XG4gICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3MuZm9ybWF0NlxudHlwZSAoJ2EsICdiLCAnYywgJ2QpIGZvcm1hdDQgPSAoJ2EsICdiLCAnYywgJ2MsICdjLCAnZCkgZm9ybWF0NlxudHlwZSAoJ2EsICdiLCAnYykgZm9ybWF0ID0gKCdhLCAnYiwgJ2MsICdjKSBmb3JtYXQ0XG5sZXQgc3RyaW5nX29mX2Zvcm1hdCA9IHN0cmluZ19vZl9mb3JtYXRcbmV4dGVybmFsIGZvcm1hdF9vZl9zdHJpbmcgOlxuICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiAtPlxuICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiA9IFwiJWlkZW50aXR5XCJcbmxldCAoIF5eICkgPSAoIF5eIClcbmxldCBleGl0ID0gZXhpdFxubGV0IGF0X2V4aXQgPSBhdF9leGl0XG5sZXQgdmFsaWRfZmxvYXRfbGV4ZW0gPSB2YWxpZF9mbG9hdF9sZXhlbVxubGV0IGRvX2F0X2V4aXQgPSBkb19hdF9leGl0XG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgIE5pY29sYXMgT2plZGEgQmFyLCBMZXhpRmkgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE4IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbmV4dGVybmFsIG5lZyA6IGZsb2F0IC0+IGZsb2F0ID0gXCIlbmVnZmxvYXRcIlxuZXh0ZXJuYWwgYWRkIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcIiVhZGRmbG9hdFwiXG5leHRlcm5hbCBzdWIgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiJXN1YmZsb2F0XCJcbmV4dGVybmFsIG11bCA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCIlbXVsZmxvYXRcIlxuZXh0ZXJuYWwgZGl2IDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcIiVkaXZmbG9hdFwiXG5leHRlcm5hbCByZW0gOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9mbW9kX2Zsb2F0XCIgXCJmbW9kXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGZtYSA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2ZtYV9mbG9hdFwiIFwiY2FtbF9mbWFcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYWJzIDogZmxvYXQgLT4gZmxvYXQgPSBcIiVhYnNmbG9hdFwiXG5cbmxldCB6ZXJvID0gMC5cbmxldCBvbmUgPSAxLlxubGV0IG1pbnVzX29uZSA9IC0xLlxubGV0IGluZmluaXR5ID0gU3RkbGliLmluZmluaXR5XG5sZXQgbmVnX2luZmluaXR5ID0gU3RkbGliLm5lZ19pbmZpbml0eVxubGV0IG5hbiA9IFN0ZGxpYi5uYW5cbmxldCBpc19maW5pdGUgKHg6IGZsb2F0KSA9IHggLS4geCA9IDAuXG5sZXQgaXNfaW5maW5pdGUgKHg6IGZsb2F0KSA9IDEuIC8uIHggPSAwLlxubGV0IGlzX25hbiAoeDogZmxvYXQpID0geCA8PiB4XG5cbmxldCBwaSA9IDB4MS45MjFmYjU0NDQyZDE4cCsxXG5sZXQgbWF4X2Zsb2F0ID0gU3RkbGliLm1heF9mbG9hdFxubGV0IG1pbl9mbG9hdCA9IFN0ZGxpYi5taW5fZmxvYXRcbmxldCBlcHNpbG9uID0gU3RkbGliLmVwc2lsb25fZmxvYXRcbmV4dGVybmFsIG9mX2ludCA6IGludCAtPiBmbG9hdCA9IFwiJWZsb2F0b2ZpbnRcIlxuZXh0ZXJuYWwgdG9faW50IDogZmxvYXQgLT4gaW50ID0gXCIlaW50b2ZmbG9hdFwiXG5leHRlcm5hbCBvZl9zdHJpbmcgOiBzdHJpbmcgLT4gZmxvYXQgPSBcImNhbWxfZmxvYXRfb2Zfc3RyaW5nXCJcbmxldCBvZl9zdHJpbmdfb3B0ID0gU3RkbGliLmZsb2F0X29mX3N0cmluZ19vcHRcbmxldCB0b19zdHJpbmcgPSBTdGRsaWIuc3RyaW5nX29mX2Zsb2F0XG50eXBlIGZwY2xhc3MgPSBTdGRsaWIuZnBjbGFzcyA9XG4gICAgRlBfbm9ybWFsXG4gIHwgRlBfc3Vibm9ybWFsXG4gIHwgRlBfemVyb1xuICB8IEZQX2luZmluaXRlXG4gIHwgRlBfbmFuXG5leHRlcm5hbCBjbGFzc2lmeV9mbG9hdCA6IChmbG9hdCBbQHVuYm94ZWRdKSAtPiBmcGNsYXNzID1cbiAgXCJjYW1sX2NsYXNzaWZ5X2Zsb2F0XCIgXCJjYW1sX2NsYXNzaWZ5X2Zsb2F0X3VuYm94ZWRcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgcG93IDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfcG93ZXJfZmxvYXRcIiBcInBvd1wiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBzcXJ0IDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfc3FydF9mbG9hdFwiIFwic3FydFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBleHAgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9leHBfZmxvYXRcIiBcImV4cFwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBsb2cgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9sb2dfZmxvYXRcIiBcImxvZ1wiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBsb2cxMCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2xvZzEwX2Zsb2F0XCIgXCJsb2cxMFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBleHBtMSA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2V4cG0xX2Zsb2F0XCIgXCJjYW1sX2V4cG0xXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGxvZzFwIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfbG9nMXBfZmxvYXRcIiBcImNhbWxfbG9nMXBcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgY29zIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfY29zX2Zsb2F0XCIgXCJjb3NcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgc2luIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfc2luX2Zsb2F0XCIgXCJzaW5cIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdGFuIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfdGFuX2Zsb2F0XCIgXCJ0YW5cIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYWNvcyA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Fjb3NfZmxvYXRcIiBcImFjb3NcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYXNpbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2FzaW5fZmxvYXRcIiBcImFzaW5cIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYXRhbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2F0YW5fZmxvYXRcIiBcImF0YW5cIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYXRhbjIgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hdGFuMl9mbG9hdFwiIFwiYXRhbjJcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgaHlwb3QgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdFxuICAgICAgICAgICAgICAgPSBcImNhbWxfaHlwb3RfZmxvYXRcIiBcImNhbWxfaHlwb3RcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgY29zaCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Nvc2hfZmxvYXRcIiBcImNvc2hcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgc2luaCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3NpbmhfZmxvYXRcIiBcInNpbmhcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdGFuaCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3RhbmhfZmxvYXRcIiBcInRhbmhcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdHJ1bmMgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF90cnVuY19mbG9hdFwiIFwiY2FtbF90cnVuY1wiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCByb3VuZCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3JvdW5kX2Zsb2F0XCIgXCJjYW1sX3JvdW5kXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGNlaWwgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9jZWlsX2Zsb2F0XCIgXCJjZWlsXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGZsb29yIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfZmxvb3JfZmxvYXRcIiBcImZsb29yXCJcbltAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5cbmxldCBpc19pbnRlZ2VyIHggPSB4ID0gdHJ1bmMgeCAmJiBpc19maW5pdGUgeFxuXG5leHRlcm5hbCBuZXh0X2FmdGVyIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXRcbiAgPSBcImNhbWxfbmV4dGFmdGVyX2Zsb2F0XCIgXCJjYW1sX25leHRhZnRlclwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5cbmxldCBzdWNjIHggPSBuZXh0X2FmdGVyIHggaW5maW5pdHlcbmxldCBwcmVkIHggPSBuZXh0X2FmdGVyIHggbmVnX2luZmluaXR5XG5cbmV4dGVybmFsIGNvcHlfc2lnbiA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0XG4gICAgICAgICAgICAgICAgICA9IFwiY2FtbF9jb3B5c2lnbl9mbG9hdFwiIFwiY2FtbF9jb3B5c2lnblwiXG4gICAgICAgICAgICAgICAgICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgc2lnbl9iaXQgOiAoZmxvYXQgW0B1bmJveGVkXSkgLT4gYm9vbFxuICA9IFwiY2FtbF9zaWduYml0X2Zsb2F0XCIgXCJjYW1sX3NpZ25iaXRcIiBbQEBub2FsbG9jXVxuXG5leHRlcm5hbCBmcmV4cCA6IGZsb2F0IC0+IGZsb2F0ICogaW50ID0gXCJjYW1sX2ZyZXhwX2Zsb2F0XCJcbmV4dGVybmFsIGxkZXhwIDogKGZsb2F0IFtAdW5ib3hlZF0pIC0+IChpbnQgW0B1bnRhZ2dlZF0pIC0+IChmbG9hdCBbQHVuYm94ZWRdKSA9XG4gIFwiY2FtbF9sZGV4cF9mbG9hdFwiIFwiY2FtbF9sZGV4cF9mbG9hdF91bmJveGVkXCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIG1vZGYgOiBmbG9hdCAtPiBmbG9hdCAqIGZsb2F0ID0gXCJjYW1sX21vZGZfZmxvYXRcIlxudHlwZSB0ID0gZmxvYXRcbmV4dGVybmFsIGNvbXBhcmUgOiBmbG9hdCAtPiBmbG9hdCAtPiBpbnQgPSBcIiVjb21wYXJlXCJcbmxldCBlcXVhbCB4IHkgPSBjb21wYXJlIHggeSA9IDBcblxubGV0W0BpbmxpbmVdIG1pbiAoeDogZmxvYXQpICh5OiBmbG9hdCkgPVxuICBpZiB5ID4geCB8fCAobm90KHNpZ25fYml0IHkpICYmIHNpZ25fYml0IHgpIHRoZW5cbiAgICBpZiBpc19uYW4geSB0aGVuIHkgZWxzZSB4XG4gIGVsc2UgaWYgaXNfbmFuIHggdGhlbiB4IGVsc2UgeVxuXG5sZXRbQGlubGluZV0gbWF4ICh4OiBmbG9hdCkgKHk6IGZsb2F0KSA9XG4gIGlmIHkgPiB4IHx8IChub3Qoc2lnbl9iaXQgeSkgJiYgc2lnbl9iaXQgeCkgdGhlblxuICAgIGlmIGlzX25hbiB4IHRoZW4geCBlbHNlIHlcbiAgZWxzZSBpZiBpc19uYW4geSB0aGVuIHkgZWxzZSB4XG5cbmxldFtAaW5saW5lXSBtaW5fbWF4ICh4OiBmbG9hdCkgKHk6IGZsb2F0KSA9XG4gIGlmIGlzX25hbiB4IHx8IGlzX25hbiB5IHRoZW4gKG5hbiwgbmFuKVxuICBlbHNlIGlmIHkgPiB4IHx8IChub3Qoc2lnbl9iaXQgeSkgJiYgc2lnbl9iaXQgeCkgdGhlbiAoeCwgeSkgZWxzZSAoeSwgeClcblxubGV0W0BpbmxpbmVdIG1pbl9udW0gKHg6IGZsb2F0KSAoeTogZmxvYXQpID1cbiAgaWYgeSA+IHggfHwgKG5vdChzaWduX2JpdCB5KSAmJiBzaWduX2JpdCB4KSB0aGVuXG4gICAgaWYgaXNfbmFuIHggdGhlbiB5IGVsc2UgeFxuICBlbHNlIGlmIGlzX25hbiB5IHRoZW4geCBlbHNlIHlcblxubGV0W0BpbmxpbmVdIG1heF9udW0gKHg6IGZsb2F0KSAoeTogZmxvYXQpID1cbiAgaWYgeSA+IHggfHwgKG5vdChzaWduX2JpdCB5KSAmJiBzaWduX2JpdCB4KSB0aGVuXG4gICAgaWYgaXNfbmFuIHkgdGhlbiB4IGVsc2UgeVxuICBlbHNlIGlmIGlzX25hbiB4IHRoZW4geSBlbHNlIHhcblxubGV0W0BpbmxpbmVdIG1pbl9tYXhfbnVtICh4OiBmbG9hdCkgKHk6IGZsb2F0KSA9XG4gIGlmIGlzX25hbiB4IHRoZW4gKHkseSlcbiAgZWxzZSBpZiBpc19uYW4geSB0aGVuICh4LHgpXG4gIGVsc2UgaWYgeSA+IHggfHwgKG5vdChzaWduX2JpdCB5KSAmJiBzaWduX2JpdCB4KSB0aGVuICh4LHkpIGVsc2UgKHkseClcblxuZXh0ZXJuYWwgc2VlZGVkX2hhc2hfcGFyYW0gOiBpbnQgLT4gaW50IC0+IGludCAtPiBmbG9hdCAtPiBpbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX2hhc2hcIiBbQEBub2FsbG9jXVxubGV0IGhhc2ggeCA9IHNlZWRlZF9oYXNoX3BhcmFtIDEwIDEwMCAwIHhcblxubW9kdWxlIEFycmF5ID0gc3RydWN0XG5cbiAgdHlwZSB0ID0gZmxvYXRhcnJheVxuXG4gIGV4dGVybmFsIGxlbmd0aCA6IHQgLT4gaW50ID0gXCIlZmxvYXRhcnJheV9sZW5ndGhcIlxuICBleHRlcm5hbCBnZXQgOiB0IC0+IGludCAtPiBmbG9hdCA9IFwiJWZsb2F0YXJyYXlfc2FmZV9nZXRcIlxuICBleHRlcm5hbCBzZXQgOiB0IC0+IGludCAtPiBmbG9hdCAtPiB1bml0ID0gXCIlZmxvYXRhcnJheV9zYWZlX3NldFwiXG4gIGV4dGVybmFsIGNyZWF0ZSA6IGludCAtPiB0ID0gXCJjYW1sX2Zsb2F0YXJyYXlfY3JlYXRlXCJcbiAgZXh0ZXJuYWwgdW5zYWZlX2dldCA6IHQgLT4gaW50IC0+IGZsb2F0ID0gXCIlZmxvYXRhcnJheV91bnNhZmVfZ2V0XCJcbiAgZXh0ZXJuYWwgdW5zYWZlX3NldCA6IHQgLT4gaW50IC0+IGZsb2F0IC0+IHVuaXQgPSBcIiVmbG9hdGFycmF5X3Vuc2FmZV9zZXRcIlxuXG4gIGxldCB1bnNhZmVfZmlsbCBhIG9mcyBsZW4gdiA9XG4gICAgZm9yIGkgPSBvZnMgdG8gb2ZzICsgbGVuIC0gMSBkbyB1bnNhZmVfc2V0IGEgaSB2IGRvbmVcblxuICBleHRlcm5hbCB1bnNhZmVfYmxpdDogdCAtPiBpbnQgLT4gdCAtPiBpbnQgLT4gaW50IC0+IHVuaXQgPVxuICAgIFwiY2FtbF9mbG9hdGFycmF5X2JsaXRcIiBbQEBub2FsbG9jXVxuXG4gIGxldCBjaGVjayBhIG9mcyBsZW4gbXNnID1cbiAgICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzICsgbGVuIDwgMCB8fCBvZnMgKyBsZW4gPiBsZW5ndGggYSB0aGVuXG4gICAgICBpbnZhbGlkX2FyZyBtc2dcblxuICBsZXQgbWFrZSBuIHYgPVxuICAgIGxldCByZXN1bHQgPSBjcmVhdGUgbiBpblxuICAgIHVuc2FmZV9maWxsIHJlc3VsdCAwIG4gdjtcbiAgICByZXN1bHRcblxuICBsZXQgaW5pdCBsIGYgPVxuICAgIGlmIGwgPCAwIHRoZW4gaW52YWxpZF9hcmcgXCJGbG9hdC5BcnJheS5pbml0XCJcbiAgICBlbHNlXG4gICAgICBsZXQgcmVzID0gY3JlYXRlIGwgaW5cbiAgICAgIGZvciBpID0gMCB0byBsIC0gMSBkb1xuICAgICAgICB1bnNhZmVfc2V0IHJlcyBpIChmIGkpXG4gICAgICBkb25lO1xuICAgICAgcmVzXG5cbiAgbGV0IGFwcGVuZCBhMSBhMiA9XG4gICAgbGV0IGwxID0gbGVuZ3RoIGExIGluXG4gICAgbGV0IGwyID0gbGVuZ3RoIGEyIGluXG4gICAgbGV0IHJlc3VsdCA9IGNyZWF0ZSAobDEgKyBsMikgaW5cbiAgICB1bnNhZmVfYmxpdCBhMSAwIHJlc3VsdCAwIGwxO1xuICAgIHVuc2FmZV9ibGl0IGEyIDAgcmVzdWx0IGwxIGwyO1xuICAgIHJlc3VsdFxuXG4gICgqIG5leHQgMyBmdW5jdGlvbnM6IG1vZGlmaWVkIGNvcHkgb2YgY29kZSBmcm9tIHN0cmluZy5tbCAqKVxuICBsZXQgZW5zdXJlX2dlICh4OmludCkgeSA9XG4gICAgaWYgeCA+PSB5IHRoZW4geCBlbHNlIGludmFsaWRfYXJnIFwiRmxvYXQuQXJyYXkuY29uY2F0XCJcblxuICBsZXQgcmVjIHN1bV9sZW5ndGhzIGFjYyA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiBhY2NcbiAgICB8IGhkIDo6IHRsIC0+IHN1bV9sZW5ndGhzIChlbnN1cmVfZ2UgKGxlbmd0aCBoZCArIGFjYykgYWNjKSB0bFxuXG4gIGxldCBjb25jYXQgbCA9XG4gICAgbGV0IGxlbiA9IHN1bV9sZW5ndGhzIDAgbCBpblxuICAgIGxldCByZXN1bHQgPSBjcmVhdGUgbGVuIGluXG4gICAgbGV0IHJlYyBsb29wIGwgaSA9XG4gICAgICBtYXRjaCBsIHdpdGhcbiAgICAgIHwgW10gLT4gYXNzZXJ0IChpID0gbGVuKVxuICAgICAgfCBoZCA6OiB0bCAtPlxuICAgICAgICBsZXQgaGxlbiA9IGxlbmd0aCBoZCBpblxuICAgICAgICB1bnNhZmVfYmxpdCBoZCAwIHJlc3VsdCBpIGhsZW47XG4gICAgICAgIGxvb3AgdGwgKGkgKyBobGVuKVxuICAgIGluXG4gICAgbG9vcCBsIDA7XG4gICAgcmVzdWx0XG5cbiAgbGV0IHN1YiBhIG9mcyBsZW4gPVxuICAgIGNoZWNrIGEgb2ZzIGxlbiBcIkZsb2F0LkFycmF5LnN1YlwiO1xuICAgIGxldCByZXN1bHQgPSBjcmVhdGUgbGVuIGluXG4gICAgdW5zYWZlX2JsaXQgYSBvZnMgcmVzdWx0IDAgbGVuO1xuICAgIHJlc3VsdFxuXG4gIGxldCBjb3B5IGEgPVxuICAgIGxldCBsID0gbGVuZ3RoIGEgaW5cbiAgICBsZXQgcmVzdWx0ID0gY3JlYXRlIGwgaW5cbiAgICB1bnNhZmVfYmxpdCBhIDAgcmVzdWx0IDAgbDtcbiAgICByZXN1bHRcblxuICBsZXQgZmlsbCBhIG9mcyBsZW4gdiA9XG4gICAgY2hlY2sgYSBvZnMgbGVuIFwiRmxvYXQuQXJyYXkuZmlsbFwiO1xuICAgIHVuc2FmZV9maWxsIGEgb2ZzIGxlbiB2XG5cbiAgbGV0IGJsaXQgc3JjIHNvZnMgZHN0IGRvZnMgbGVuID1cbiAgICBjaGVjayBzcmMgc29mcyBsZW4gXCJGbG9hdC5hcnJheS5ibGl0XCI7XG4gICAgY2hlY2sgZHN0IGRvZnMgbGVuIFwiRmxvYXQuYXJyYXkuYmxpdFwiO1xuICAgIHVuc2FmZV9ibGl0IHNyYyBzb2ZzIGRzdCBkb2ZzIGxlblxuXG4gIGxldCB0b19saXN0IGEgPVxuICAgIExpc3QuaW5pdCAobGVuZ3RoIGEpICh1bnNhZmVfZ2V0IGEpXG5cbiAgbGV0IG9mX2xpc3QgbCA9XG4gICAgbGV0IHJlc3VsdCA9IGNyZWF0ZSAoTGlzdC5sZW5ndGggbCkgaW5cbiAgICBsZXQgcmVjIGZpbGwgaSBsID1cbiAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgfCBbXSAtPiByZXN1bHRcbiAgICAgIHwgaCA6OiB0IC0+IHVuc2FmZV9zZXQgcmVzdWx0IGkgaDsgZmlsbCAoaSArIDEpIHRcbiAgICBpblxuICAgIGZpbGwgMCBsXG5cbiAgKCogZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sICopXG4gIGxldCBpdGVyIGYgYSA9XG4gICAgZm9yIGkgPSAwIHRvIGxlbmd0aCBhIC0gMSBkbyBmICh1bnNhZmVfZ2V0IGEgaSkgZG9uZVxuXG4gICgqIGR1cGxpY2F0ZWQgZnJvbSBhcnJheS5tbCAqKVxuICBsZXQgaXRlcjIgZiBhIGIgPVxuICAgIGlmIGxlbmd0aCBhIDw+IGxlbmd0aCBiIHRoZW5cbiAgICAgIGludmFsaWRfYXJnIFwiRmxvYXQuQXJyYXkuaXRlcjI6IGFycmF5cyBtdXN0IGhhdmUgdGhlIHNhbWUgbGVuZ3RoXCJcbiAgICBlbHNlXG4gICAgICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvIGYgKHVuc2FmZV9nZXQgYSBpKSAodW5zYWZlX2dldCBiIGkpIGRvbmVcblxuICBsZXQgbWFwIGYgYSA9XG4gICAgbGV0IGwgPSBsZW5ndGggYSBpblxuICAgIGxldCByID0gY3JlYXRlIGwgaW5cbiAgICBmb3IgaSA9IDAgdG8gbCAtIDEgZG9cbiAgICAgIHVuc2FmZV9zZXQgciBpIChmICh1bnNhZmVfZ2V0IGEgaSkpXG4gICAgZG9uZTtcbiAgICByXG5cbiAgbGV0IG1hcDIgZiBhIGIgPVxuICAgIGxldCBsYSA9IGxlbmd0aCBhIGluXG4gICAgbGV0IGxiID0gbGVuZ3RoIGIgaW5cbiAgICBpZiBsYSA8PiBsYiB0aGVuXG4gICAgICBpbnZhbGlkX2FyZyBcIkZsb2F0LkFycmF5Lm1hcDI6IGFycmF5cyBtdXN0IGhhdmUgdGhlIHNhbWUgbGVuZ3RoXCJcbiAgICBlbHNlIGJlZ2luXG4gICAgICBsZXQgciA9IGNyZWF0ZSBsYSBpblxuICAgICAgZm9yIGkgPSAwIHRvIGxhIC0gMSBkb1xuICAgICAgICB1bnNhZmVfc2V0IHIgaSAoZiAodW5zYWZlX2dldCBhIGkpICh1bnNhZmVfZ2V0IGIgaSkpXG4gICAgICBkb25lO1xuICAgICAgclxuICAgIGVuZFxuXG4gICgqIGR1cGxpY2F0ZWQgZnJvbSBhcnJheS5tbCAqKVxuICBsZXQgaXRlcmkgZiBhID1cbiAgICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvIGYgaSAodW5zYWZlX2dldCBhIGkpIGRvbmVcblxuICBsZXQgbWFwaSBmIGEgPVxuICAgIGxldCBsID0gbGVuZ3RoIGEgaW5cbiAgICBsZXQgciA9IGNyZWF0ZSBsIGluXG4gICAgZm9yIGkgPSAwIHRvIGwgLSAxIGRvXG4gICAgICB1bnNhZmVfc2V0IHIgaSAoZiBpICh1bnNhZmVfZ2V0IGEgaSkpXG4gICAgZG9uZTtcbiAgICByXG5cbiAgKCogZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sICopXG4gIGxldCBmb2xkX2xlZnQgZiB4IGEgPVxuICAgIGxldCByID0gcmVmIHggaW5cbiAgICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvXG4gICAgICByIDo9IGYgIXIgKHVuc2FmZV9nZXQgYSBpKVxuICAgIGRvbmU7XG4gICAgIXJcblxuICAoKiBkdXBsaWNhdGVkIGZyb20gYXJyYXkubWwgKilcbiAgbGV0IGZvbGRfcmlnaHQgZiBhIHggPVxuICAgIGxldCByID0gcmVmIHggaW5cbiAgICBmb3IgaSA9IGxlbmd0aCBhIC0gMSBkb3dudG8gMCBkb1xuICAgICAgciA6PSBmICh1bnNhZmVfZ2V0IGEgaSkgIXJcbiAgICBkb25lO1xuICAgICFyXG5cbiAgKCogZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sICopXG4gIGxldCBleGlzdHMgcCBhID1cbiAgICBsZXQgbiA9IGxlbmd0aCBhIGluXG4gICAgbGV0IHJlYyBsb29wIGkgPVxuICAgICAgaWYgaSA9IG4gdGhlbiBmYWxzZVxuICAgICAgZWxzZSBpZiBwICh1bnNhZmVfZ2V0IGEgaSkgdGhlbiB0cnVlXG4gICAgICBlbHNlIGxvb3AgKGkgKyAxKSBpblxuICAgIGxvb3AgMFxuXG4gICgqIGR1cGxpY2F0ZWQgZnJvbSBhcnJheS5tbCAqKVxuICBsZXQgZm9yX2FsbCBwIGEgPVxuICAgIGxldCBuID0gbGVuZ3RoIGEgaW5cbiAgICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgICBpZiBpID0gbiB0aGVuIHRydWVcbiAgICAgIGVsc2UgaWYgcCAodW5zYWZlX2dldCBhIGkpIHRoZW4gbG9vcCAoaSArIDEpXG4gICAgICBlbHNlIGZhbHNlIGluXG4gICAgbG9vcCAwXG5cbiAgKCogZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sICopXG4gIGxldCBtZW0geCBhID1cbiAgICBsZXQgbiA9IGxlbmd0aCBhIGluXG4gICAgbGV0IHJlYyBsb29wIGkgPVxuICAgICAgaWYgaSA9IG4gdGhlbiBmYWxzZVxuICAgICAgZWxzZSBpZiBjb21wYXJlICh1bnNhZmVfZ2V0IGEgaSkgeCA9IDAgdGhlbiB0cnVlXG4gICAgICBlbHNlIGxvb3AgKGkgKyAxKVxuICAgIGluXG4gICAgbG9vcCAwXG5cbiAgKCogbW9zdGx5IGR1cGxpY2F0ZWQgZnJvbSBhcnJheS5tbCwgYnV0IHNsaWdodGx5IGRpZmZlcmVudCAqKVxuICBsZXQgbWVtX2llZWUgeCBhID1cbiAgICBsZXQgbiA9IGxlbmd0aCBhIGluXG4gICAgbGV0IHJlYyBsb29wIGkgPVxuICAgICAgaWYgaSA9IG4gdGhlbiBmYWxzZVxuICAgICAgZWxzZSBpZiB4ID0gKHVuc2FmZV9nZXQgYSBpKSB0aGVuIHRydWVcbiAgICAgIGVsc2UgbG9vcCAoaSArIDEpXG4gICAgaW5cbiAgICBsb29wIDBcblxuICAoKiBkdXBsaWNhdGVkIGZyb20gYXJyYXkubWwgKilcbiAgZXhjZXB0aW9uIEJvdHRvbSBvZiBpbnRcbiAgbGV0IHNvcnQgY21wIGEgPVxuICAgIGxldCBtYXhzb24gbCBpID1cbiAgICAgIGxldCBpMzEgPSBpK2kraSsxIGluXG4gICAgICBsZXQgeCA9IHJlZiBpMzEgaW5cbiAgICAgIGlmIGkzMSsyIDwgbCB0aGVuIGJlZ2luXG4gICAgICAgIGlmIGNtcCAoZ2V0IGEgaTMxKSAoZ2V0IGEgKGkzMSsxKSkgPCAwIHRoZW4geCA6PSBpMzErMTtcbiAgICAgICAgaWYgY21wIChnZXQgYSAheCkgKGdldCBhIChpMzErMikpIDwgMCB0aGVuIHggOj0gaTMxKzI7XG4gICAgICAgICF4XG4gICAgICBlbmQgZWxzZVxuICAgICAgICBpZiBpMzErMSA8IGwgJiYgY21wIChnZXQgYSBpMzEpIChnZXQgYSAoaTMxKzEpKSA8IDBcbiAgICAgICAgdGhlbiBpMzErMVxuICAgICAgICBlbHNlIGlmIGkzMSA8IGwgdGhlbiBpMzEgZWxzZSByYWlzZSAoQm90dG9tIGkpXG4gICAgaW5cbiAgICBsZXQgcmVjIHRyaWNrbGVkb3duIGwgaSBlID1cbiAgICAgIGxldCBqID0gbWF4c29uIGwgaSBpblxuICAgICAgaWYgY21wIChnZXQgYSBqKSBlID4gMCB0aGVuIGJlZ2luXG4gICAgICAgIHNldCBhIGkgKGdldCBhIGopO1xuICAgICAgICB0cmlja2xlZG93biBsIGogZTtcbiAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgIHNldCBhIGkgZTtcbiAgICAgIGVuZDtcbiAgICBpblxuICAgIGxldCB0cmlja2xlIGwgaSBlID0gdHJ5IHRyaWNrbGVkb3duIGwgaSBlIHdpdGggQm90dG9tIGkgLT4gc2V0IGEgaSBlIGluXG4gICAgbGV0IHJlYyBidWJibGVkb3duIGwgaSA9XG4gICAgICBsZXQgaiA9IG1heHNvbiBsIGkgaW5cbiAgICAgIHNldCBhIGkgKGdldCBhIGopO1xuICAgICAgYnViYmxlZG93biBsIGpcbiAgICBpblxuICAgIGxldCBidWJibGUgbCBpID0gdHJ5IGJ1YmJsZWRvd24gbCBpIHdpdGggQm90dG9tIGkgLT4gaSBpblxuICAgIGxldCByZWMgdHJpY2tsZXVwIGkgZSA9XG4gICAgICBsZXQgZmF0aGVyID0gKGkgLSAxKSAvIDMgaW5cbiAgICAgIGFzc2VydCAoaSA8PiBmYXRoZXIpO1xuICAgICAgaWYgY21wIChnZXQgYSBmYXRoZXIpIGUgPCAwIHRoZW4gYmVnaW5cbiAgICAgICAgc2V0IGEgaSAoZ2V0IGEgZmF0aGVyKTtcbiAgICAgICAgaWYgZmF0aGVyID4gMCB0aGVuIHRyaWNrbGV1cCBmYXRoZXIgZSBlbHNlIHNldCBhIDAgZTtcbiAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgIHNldCBhIGkgZTtcbiAgICAgIGVuZDtcbiAgICBpblxuICAgIGxldCBsID0gbGVuZ3RoIGEgaW5cbiAgICBmb3IgaSA9IChsICsgMSkgLyAzIC0gMSBkb3dudG8gMCBkbyB0cmlja2xlIGwgaSAoZ2V0IGEgaSk7IGRvbmU7XG4gICAgZm9yIGkgPSBsIC0gMSBkb3dudG8gMiBkb1xuICAgICAgbGV0IGUgPSAoZ2V0IGEgaSkgaW5cbiAgICAgIHNldCBhIGkgKGdldCBhIDApO1xuICAgICAgdHJpY2tsZXVwIChidWJibGUgaSAwKSBlO1xuICAgIGRvbmU7XG4gICAgaWYgbCA+IDEgdGhlbiAobGV0IGUgPSAoZ2V0IGEgMSkgaW4gc2V0IGEgMSAoZ2V0IGEgMCk7IHNldCBhIDAgZSlcblxuICAoKiBkdXBsaWNhdGVkIGZyb20gYXJyYXkubWwsIGV4Y2VwdCBmb3IgdGhlIGNhbGwgdG8gW2NyZWF0ZV0gKilcbiAgbGV0IGN1dG9mZiA9IDVcbiAgbGV0IHN0YWJsZV9zb3J0IGNtcCBhID1cbiAgICBsZXQgbWVyZ2Ugc3JjMW9mcyBzcmMxbGVuIHNyYzIgc3JjMm9mcyBzcmMybGVuIGRzdCBkc3RvZnMgPVxuICAgICAgbGV0IHNyYzFyID0gc3JjMW9mcyArIHNyYzFsZW4gYW5kIHNyYzJyID0gc3JjMm9mcyArIHNyYzJsZW4gaW5cbiAgICAgIGxldCByZWMgbG9vcCBpMSBzMSBpMiBzMiBkID1cbiAgICAgICAgaWYgY21wIHMxIHMyIDw9IDAgdGhlbiBiZWdpblxuICAgICAgICAgIHNldCBkc3QgZCBzMTtcbiAgICAgICAgICBsZXQgaTEgPSBpMSArIDEgaW5cbiAgICAgICAgICBpZiBpMSA8IHNyYzFyIHRoZW5cbiAgICAgICAgICAgIGxvb3AgaTEgKGdldCBhIGkxKSBpMiBzMiAoZCArIDEpXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgYmxpdCBzcmMyIGkyIGRzdCAoZCArIDEpIChzcmMyciAtIGkyKVxuICAgICAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgICAgIHNldCBkc3QgZCBzMjtcbiAgICAgICAgICBsZXQgaTIgPSBpMiArIDEgaW5cbiAgICAgICAgICBpZiBpMiA8IHNyYzJyIHRoZW5cbiAgICAgICAgICAgIGxvb3AgaTEgczEgaTIgKGdldCBzcmMyIGkyKSAoZCArIDEpXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgYmxpdCBhIGkxIGRzdCAoZCArIDEpIChzcmMxciAtIGkxKVxuICAgICAgICBlbmRcbiAgICAgIGluIGxvb3Agc3JjMW9mcyAoZ2V0IGEgc3JjMW9mcykgc3JjMm9mcyAoZ2V0IHNyYzIgc3JjMm9mcykgZHN0b2ZzO1xuICAgIGluXG4gICAgbGV0IGlzb3J0dG8gc3Jjb2ZzIGRzdCBkc3RvZnMgbGVuID1cbiAgICAgIGZvciBpID0gMCB0byBsZW4gLSAxIGRvXG4gICAgICAgIGxldCBlID0gKGdldCBhIChzcmNvZnMgKyBpKSkgaW5cbiAgICAgICAgbGV0IGogPSByZWYgKGRzdG9mcyArIGkgLSAxKSBpblxuICAgICAgICB3aGlsZSAoIWogPj0gZHN0b2ZzICYmIGNtcCAoZ2V0IGRzdCAhaikgZSA+IDApIGRvXG4gICAgICAgICAgc2V0IGRzdCAoIWogKyAxKSAoZ2V0IGRzdCAhaik7XG4gICAgICAgICAgZGVjciBqO1xuICAgICAgICBkb25lO1xuICAgICAgICBzZXQgZHN0ICghaiArIDEpIGU7XG4gICAgICBkb25lO1xuICAgIGluXG4gICAgbGV0IHJlYyBzb3J0dG8gc3Jjb2ZzIGRzdCBkc3RvZnMgbGVuID1cbiAgICAgIGlmIGxlbiA8PSBjdXRvZmYgdGhlbiBpc29ydHRvIHNyY29mcyBkc3QgZHN0b2ZzIGxlbiBlbHNlIGJlZ2luXG4gICAgICAgIGxldCBsMSA9IGxlbiAvIDIgaW5cbiAgICAgICAgbGV0IGwyID0gbGVuIC0gbDEgaW5cbiAgICAgICAgc29ydHRvIChzcmNvZnMgKyBsMSkgZHN0IChkc3RvZnMgKyBsMSkgbDI7XG4gICAgICAgIHNvcnR0byBzcmNvZnMgYSAoc3Jjb2ZzICsgbDIpIGwxO1xuICAgICAgICBtZXJnZSAoc3Jjb2ZzICsgbDIpIGwxIGRzdCAoZHN0b2ZzICsgbDEpIGwyIGRzdCBkc3RvZnM7XG4gICAgICBlbmQ7XG4gICAgaW5cbiAgICBsZXQgbCA9IGxlbmd0aCBhIGluXG4gICAgaWYgbCA8PSBjdXRvZmYgdGhlbiBpc29ydHRvIDAgYSAwIGwgZWxzZSBiZWdpblxuICAgICAgbGV0IGwxID0gbCAvIDIgaW5cbiAgICAgIGxldCBsMiA9IGwgLSBsMSBpblxuICAgICAgbGV0IHQgPSBjcmVhdGUgbDIgaW5cbiAgICAgIHNvcnR0byBsMSB0IDAgbDI7XG4gICAgICBzb3J0dG8gMCBhIGwyIGwxO1xuICAgICAgbWVyZ2UgbDIgbDEgdCAwIGwyIGEgMDtcbiAgICBlbmRcblxuICBsZXQgZmFzdF9zb3J0ID0gc3RhYmxlX3NvcnRcblxuICAoKiBkdXBsaWNhdGVkIGZyb20gYXJyYXkubWwgKilcbiAgbGV0IHRvX3NlcSBhID1cbiAgICBsZXQgcmVjIGF1eCBpICgpID1cbiAgICAgIGlmIGkgPCBsZW5ndGggYVxuICAgICAgdGhlblxuICAgICAgICBsZXQgeCA9IHVuc2FmZV9nZXQgYSBpIGluXG4gICAgICAgIFNlcS5Db25zICh4LCBhdXggKGkrMSkpXG4gICAgICBlbHNlIFNlcS5OaWxcbiAgICBpblxuICAgIGF1eCAwXG5cbiAgKCogZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sICopXG4gIGxldCB0b19zZXFpIGEgPVxuICAgIGxldCByZWMgYXV4IGkgKCkgPVxuICAgICAgaWYgaSA8IGxlbmd0aCBhXG4gICAgICB0aGVuXG4gICAgICAgIGxldCB4ID0gdW5zYWZlX2dldCBhIGkgaW5cbiAgICAgICAgU2VxLkNvbnMgKChpLHgpLCBhdXggKGkrMSkpXG4gICAgICBlbHNlIFNlcS5OaWxcbiAgICBpblxuICAgIGF1eCAwXG5cbiAgKCogbW9zdGx5IGR1cGxpY2F0ZWQgZnJvbSBhcnJheS5tbCAqKVxuICBsZXQgb2ZfcmV2X2xpc3QgbCA9XG4gICAgbGV0IGxlbiA9IExpc3QubGVuZ3RoIGwgaW5cbiAgICBsZXQgYSA9IGNyZWF0ZSBsZW4gaW5cbiAgICBsZXQgcmVjIGZpbGwgaSA9IGZ1bmN0aW9uXG4gICAgICAgIFtdIC0+IGFcbiAgICAgIHwgaGQ6OnRsIC0+IHVuc2FmZV9zZXQgYSBpIGhkOyBmaWxsIChpLTEpIHRsXG4gICAgaW5cbiAgICBmaWxsIChsZW4tMSkgbFxuXG4gICgqIGR1cGxpY2F0ZWQgZnJvbSBhcnJheS5tbCAqKVxuICBsZXQgb2Zfc2VxIGkgPVxuICAgIGxldCBsID0gU2VxLmZvbGRfbGVmdCAoZnVuIGFjYyB4IC0+IHg6OmFjYykgW10gaSBpblxuICAgIG9mX3Jldl9saXN0IGxcblxuXG4gIGxldCBtYXBfdG9fYXJyYXkgZiBhID1cbiAgICBsZXQgbCA9IGxlbmd0aCBhIGluXG4gICAgaWYgbCA9IDAgdGhlbiBbfCB8XSBlbHNlIGJlZ2luXG4gICAgICBsZXQgciA9IEFycmF5Lm1ha2UgbCAoZiAodW5zYWZlX2dldCBhIDApKSBpblxuICAgICAgZm9yIGkgPSAxIHRvIGwgLSAxIGRvXG4gICAgICAgIEFycmF5LnVuc2FmZV9zZXQgciBpIChmICh1bnNhZmVfZ2V0IGEgaSkpXG4gICAgICBkb25lO1xuICAgICAgclxuICAgIGVuZFxuXG4gIGxldCBtYXBfZnJvbV9hcnJheSBmIGEgPVxuICAgIGxldCBsID0gQXJyYXkubGVuZ3RoIGEgaW5cbiAgICBsZXQgciA9IGNyZWF0ZSBsIGluXG4gICAgZm9yIGkgPSAwIHRvIGwgLSAxIGRvXG4gICAgICB1bnNhZmVfc2V0IHIgaSAoZiAoQXJyYXkudW5zYWZlX2dldCBhIGkpKVxuICAgIGRvbmU7XG4gICAgclxuXG5lbmRcblxubW9kdWxlIEFycmF5TGFiZWxzID0gQXJyYXlcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogTW9kdWxlIFtOYXRpdmVpbnRdOiBwcm9jZXNzb3ItbmF0aXZlIGludGVnZXJzICopXG5cbmV4dGVybmFsIG5lZzogbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9uZWdcIlxuZXh0ZXJuYWwgYWRkOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9hZGRcIlxuZXh0ZXJuYWwgc3ViOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9zdWJcIlxuZXh0ZXJuYWwgbXVsOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9tdWxcIlxuZXh0ZXJuYWwgZGl2OiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9kaXZcIlxuZXh0ZXJuYWwgcmVtOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9tb2RcIlxuZXh0ZXJuYWwgbG9nYW5kOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9hbmRcIlxuZXh0ZXJuYWwgbG9nb3I6IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X29yXCJcbmV4dGVybmFsIGxvZ3hvcjogbmF0aXZlaW50IC0+IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfeG9yXCJcbmV4dGVybmFsIHNoaWZ0X2xlZnQ6IG5hdGl2ZWludCAtPiBpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X2xzbFwiXG5leHRlcm5hbCBzaGlmdF9yaWdodDogbmF0aXZlaW50IC0+IGludCAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfYXNyXCJcbmV4dGVybmFsIHNoaWZ0X3JpZ2h0X2xvZ2ljYWw6IG5hdGl2ZWludCAtPiBpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X2xzclwiXG5leHRlcm5hbCBvZl9pbnQ6IGludCAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfb2ZfaW50XCJcbmV4dGVybmFsIHRvX2ludDogbmF0aXZlaW50IC0+IGludCA9IFwiJW5hdGl2ZWludF90b19pbnRcIlxuZXh0ZXJuYWwgb2ZfZmxvYXQgOiBmbG9hdCAtPiBuYXRpdmVpbnRcbiAgPSBcImNhbWxfbmF0aXZlaW50X29mX2Zsb2F0XCIgXCJjYW1sX25hdGl2ZWludF9vZl9mbG9hdF91bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHRvX2Zsb2F0IDogbmF0aXZlaW50IC0+IGZsb2F0XG4gID0gXCJjYW1sX25hdGl2ZWludF90b19mbG9hdFwiIFwiY2FtbF9uYXRpdmVpbnRfdG9fZmxvYXRfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBvZl9pbnQzMjogaW50MzIgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X29mX2ludDMyXCJcbmV4dGVybmFsIHRvX2ludDMyOiBuYXRpdmVpbnQgLT4gaW50MzIgPSBcIiVuYXRpdmVpbnRfdG9faW50MzJcIlxuXG5sZXQgemVybyA9IDBuXG5sZXQgb25lID0gMW5cbmxldCBtaW51c19vbmUgPSAtMW5cbmxldCBzdWNjIG4gPSBhZGQgbiAxblxubGV0IHByZWQgbiA9IHN1YiBuIDFuXG5sZXQgYWJzIG4gPSBpZiBuID49IDBuIHRoZW4gbiBlbHNlIG5lZyBuXG5sZXQgc2l6ZSA9IFN5cy53b3JkX3NpemVcbmxldCBtaW5faW50ID0gc2hpZnRfbGVmdCAxbiAoc2l6ZSAtIDEpXG5sZXQgbWF4X2ludCA9IHN1YiBtaW5faW50IDFuXG5sZXQgbG9nbm90IG4gPSBsb2d4b3IgbiAoLTFuKVxuXG5sZXQgdW5zaWduZWRfdG9faW50ID1cbiAgbGV0IG1heF9pbnQgPSBvZl9pbnQgU3RkbGliLm1heF9pbnQgaW5cbiAgZnVuIG4gLT5cbiAgICBpZiBjb21wYXJlIHplcm8gbiA8PSAwICYmIGNvbXBhcmUgbiBtYXhfaW50IDw9IDAgdGhlblxuICAgICAgU29tZSAodG9faW50IG4pXG4gICAgZWxzZVxuICAgICAgTm9uZVxuXG5leHRlcm5hbCBmb3JtYXQgOiBzdHJpbmcgLT4gbmF0aXZlaW50IC0+IHN0cmluZyA9IFwiY2FtbF9uYXRpdmVpbnRfZm9ybWF0XCJcbmxldCB0b19zdHJpbmcgbiA9IGZvcm1hdCBcIiVkXCIgblxuXG5leHRlcm5hbCBvZl9zdHJpbmc6IHN0cmluZyAtPiBuYXRpdmVpbnQgPSBcImNhbWxfbmF0aXZlaW50X29mX3N0cmluZ1wiXG5cbmxldCBvZl9zdHJpbmdfb3B0IHMgPVxuICAoKiBUT0RPOiBleHBvc2UgYSBub24tcmFpc2luZyBwcmltaXRpdmUgZGlyZWN0bHkuICopXG4gIHRyeSBTb21lIChvZl9zdHJpbmcgcylcbiAgd2l0aCBGYWlsdXJlIF8gLT4gTm9uZVxuXG50eXBlIHQgPSBuYXRpdmVpbnRcblxubGV0IGNvbXBhcmUgKHg6IHQpICh5OiB0KSA9IFN0ZGxpYi5jb21wYXJlIHggeVxubGV0IGVxdWFsICh4OiB0KSAoeTogdCkgPSBjb21wYXJlIHggeSA9IDBcblxubGV0IHVuc2lnbmVkX2NvbXBhcmUgbiBtID1cbiAgY29tcGFyZSAoc3ViIG4gbWluX2ludCkgKHN1YiBtIG1pbl9pbnQpXG5cbigqIFVuc2lnbmVkIGRpdmlzaW9uIGZyb20gc2lnbmVkIGRpdmlzaW9uIG9mIHRoZSBzYW1lXG4gICBiaXRuZXNzLiBTZWUgV2FycmVuIEpyLiwgSGVucnkgUy4gKDIwMTMpLiBIYWNrZXIncyBEZWxpZ2h0ICgyIGVkLiksIFNlYyA5LTMuXG4qKVxubGV0IHVuc2lnbmVkX2RpdiBuIGQgPVxuICBpZiBkIDwgemVybyB0aGVuXG4gICAgaWYgdW5zaWduZWRfY29tcGFyZSBuIGQgPCAwIHRoZW4gemVybyBlbHNlIG9uZVxuICBlbHNlXG4gICAgbGV0IHEgPSBzaGlmdF9sZWZ0IChkaXYgKHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgbiAxKSBkKSAxIGluXG4gICAgbGV0IHIgPSBzdWIgbiAobXVsIHEgZCkgaW5cbiAgICBpZiB1bnNpZ25lZF9jb21wYXJlIHIgZCA+PSAwIHRoZW4gc3VjYyBxIGVsc2UgcVxuXG5sZXQgdW5zaWduZWRfcmVtIG4gZCA9XG4gIHN1YiBuIChtdWwgKHVuc2lnbmVkX2RpdiBuIGQpIGQpXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIEFuIGFsaWFzIGZvciB0aGUgdHlwZSBvZiBsaXN0cy4gKilcbnR5cGUgJ2EgdCA9ICdhIGxpc3QgPSBbXSB8ICg6Oikgb2YgJ2EgKiAnYSBsaXN0XG5cbigqIExpc3Qgb3BlcmF0aW9ucyAqKVxuXG5sZXQgcmVjIGxlbmd0aF9hdXggbGVuID0gZnVuY3Rpb25cbiAgICBbXSAtPiBsZW5cbiAgfCBfOjpsIC0+IGxlbmd0aF9hdXggKGxlbiArIDEpIGxcblxubGV0IGxlbmd0aCBsID0gbGVuZ3RoX2F1eCAwIGxcblxubGV0IGNvbnMgYSBsID0gYTo6bFxuXG5sZXQgaGQgPSBmdW5jdGlvblxuICAgIFtdIC0+IGZhaWx3aXRoIFwiaGRcIlxuICB8IGE6Ol8gLT4gYVxuXG5sZXQgdGwgPSBmdW5jdGlvblxuICAgIFtdIC0+IGZhaWx3aXRoIFwidGxcIlxuICB8IF86OmwgLT4gbFxuXG5sZXQgbnRoIGwgbiA9XG4gIGlmIG4gPCAwIHRoZW4gaW52YWxpZF9hcmcgXCJMaXN0Lm50aFwiIGVsc2VcbiAgbGV0IHJlYyBudGhfYXV4IGwgbiA9XG4gICAgbWF0Y2ggbCB3aXRoXG4gICAgfCBbXSAtPiBmYWlsd2l0aCBcIm50aFwiXG4gICAgfCBhOjpsIC0+IGlmIG4gPSAwIHRoZW4gYSBlbHNlIG50aF9hdXggbCAobi0xKVxuICBpbiBudGhfYXV4IGwgblxuXG5sZXQgbnRoX29wdCBsIG4gPVxuICBpZiBuIDwgMCB0aGVuIGludmFsaWRfYXJnIFwiTGlzdC5udGhcIiBlbHNlXG4gIGxldCByZWMgbnRoX2F1eCBsIG4gPVxuICAgIG1hdGNoIGwgd2l0aFxuICAgIHwgW10gLT4gTm9uZVxuICAgIHwgYTo6bCAtPiBpZiBuID0gMCB0aGVuIFNvbWUgYSBlbHNlIG50aF9hdXggbCAobi0xKVxuICBpbiBudGhfYXV4IGwgblxuXG5sZXQgYXBwZW5kID0gKEApXG5cbmxldCByZWMgcmV2X2FwcGVuZCBsMSBsMiA9XG4gIG1hdGNoIGwxIHdpdGhcbiAgICBbXSAtPiBsMlxuICB8IGEgOjogbCAtPiByZXZfYXBwZW5kIGwgKGEgOjogbDIpXG5cbmxldCByZXYgbCA9IHJldl9hcHBlbmQgbCBbXVxuXG5sZXQgcmVjIGluaXRfdGFpbHJlY19hdXggYWNjIGkgbiBmID1cbiAgaWYgaSA+PSBuIHRoZW4gYWNjXG4gIGVsc2UgaW5pdF90YWlscmVjX2F1eCAoZiBpIDo6IGFjYykgKGkrMSkgbiBmXG5cbmxldCByZWMgaW5pdF9hdXggaSBuIGYgPVxuICBpZiBpID49IG4gdGhlbiBbXVxuICBlbHNlXG4gICAgbGV0IHIgPSBmIGkgaW5cbiAgICByIDo6IGluaXRfYXV4IChpKzEpIG4gZlxuXG5sZXQgcmV2X2luaXRfdGhyZXNob2xkID1cbiAgbWF0Y2ggU3lzLmJhY2tlbmRfdHlwZSB3aXRoXG4gIHwgU3lzLk5hdGl2ZSB8IFN5cy5CeXRlY29kZSAtPiAxMF8wMDBcbiAgKCogV2UgZG9uJ3Qga25vdyB0aGUgc2l6ZSBvZiB0aGUgc3RhY2ssIGJldHRlciBiZSBzYWZlIGFuZCBhc3N1bWUgaXQnc1xuICAgICBzbWFsbC4gKilcbiAgfCBTeXMuT3RoZXIgXyAtPiA1MFxuXG5sZXQgaW5pdCBsZW4gZiA9XG4gIGlmIGxlbiA8IDAgdGhlbiBpbnZhbGlkX2FyZyBcIkxpc3QuaW5pdFwiIGVsc2VcbiAgaWYgbGVuID4gcmV2X2luaXRfdGhyZXNob2xkIHRoZW4gcmV2IChpbml0X3RhaWxyZWNfYXV4IFtdIDAgbGVuIGYpXG4gIGVsc2UgaW5pdF9hdXggMCBsZW4gZlxuXG5sZXQgcmVjIGZsYXR0ZW4gPSBmdW5jdGlvblxuICAgIFtdIC0+IFtdXG4gIHwgbDo6ciAtPiBsIEAgZmxhdHRlbiByXG5cbmxldCBjb25jYXQgPSBmbGF0dGVuXG5cbmxldCByZWMgbWFwIGYgPSBmdW5jdGlvblxuICAgIFtdIC0+IFtdXG4gIHwgYTo6bCAtPiBsZXQgciA9IGYgYSBpbiByIDo6IG1hcCBmIGxcblxubGV0IHJlYyBtYXBpIGkgZiA9IGZ1bmN0aW9uXG4gICAgW10gLT4gW11cbiAgfCBhOjpsIC0+IGxldCByID0gZiBpIGEgaW4gciA6OiBtYXBpIChpICsgMSkgZiBsXG5cbmxldCBtYXBpIGYgbCA9IG1hcGkgMCBmIGxcblxubGV0IHJldl9tYXAgZiBsID1cbiAgbGV0IHJlYyBybWFwX2YgYWNjdSA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiBhY2N1XG4gICAgfCBhOjpsIC0+IHJtYXBfZiAoZiBhIDo6IGFjY3UpIGxcbiAgaW5cbiAgcm1hcF9mIFtdIGxcblxuXG5sZXQgcmVjIGl0ZXIgZiA9IGZ1bmN0aW9uXG4gICAgW10gLT4gKClcbiAgfCBhOjpsIC0+IGYgYTsgaXRlciBmIGxcblxubGV0IHJlYyBpdGVyaSBpIGYgPSBmdW5jdGlvblxuICAgIFtdIC0+ICgpXG4gIHwgYTo6bCAtPiBmIGkgYTsgaXRlcmkgKGkgKyAxKSBmIGxcblxubGV0IGl0ZXJpIGYgbCA9IGl0ZXJpIDAgZiBsXG5cbmxldCByZWMgZm9sZF9sZWZ0IGYgYWNjdSBsID1cbiAgbWF0Y2ggbCB3aXRoXG4gICAgW10gLT4gYWNjdVxuICB8IGE6OmwgLT4gZm9sZF9sZWZ0IGYgKGYgYWNjdSBhKSBsXG5cbmxldCByZWMgZm9sZF9yaWdodCBmIGwgYWNjdSA9XG4gIG1hdGNoIGwgd2l0aFxuICAgIFtdIC0+IGFjY3VcbiAgfCBhOjpsIC0+IGYgYSAoZm9sZF9yaWdodCBmIGwgYWNjdSlcblxubGV0IHJlYyBtYXAyIGYgbDEgbDIgPVxuICBtYXRjaCAobDEsIGwyKSB3aXRoXG4gICAgKFtdLCBbXSkgLT4gW11cbiAgfCAoYTE6OmwxLCBhMjo6bDIpIC0+IGxldCByID0gZiBhMSBhMiBpbiByIDo6IG1hcDIgZiBsMSBsMlxuICB8IChfLCBfKSAtPiBpbnZhbGlkX2FyZyBcIkxpc3QubWFwMlwiXG5cbmxldCByZXZfbWFwMiBmIGwxIGwyID1cbiAgbGV0IHJlYyBybWFwMl9mIGFjY3UgbDEgbDIgPVxuICAgIG1hdGNoIChsMSwgbDIpIHdpdGhcbiAgICB8IChbXSwgW10pIC0+IGFjY3VcbiAgICB8IChhMTo6bDEsIGEyOjpsMikgLT4gcm1hcDJfZiAoZiBhMSBhMiA6OiBhY2N1KSBsMSBsMlxuICAgIHwgKF8sIF8pIC0+IGludmFsaWRfYXJnIFwiTGlzdC5yZXZfbWFwMlwiXG4gIGluXG4gIHJtYXAyX2YgW10gbDEgbDJcblxuXG5sZXQgcmVjIGl0ZXIyIGYgbDEgbDIgPVxuICBtYXRjaCAobDEsIGwyKSB3aXRoXG4gICAgKFtdLCBbXSkgLT4gKClcbiAgfCAoYTE6OmwxLCBhMjo6bDIpIC0+IGYgYTEgYTI7IGl0ZXIyIGYgbDEgbDJcbiAgfCAoXywgXykgLT4gaW52YWxpZF9hcmcgXCJMaXN0Lml0ZXIyXCJcblxubGV0IHJlYyBmb2xkX2xlZnQyIGYgYWNjdSBsMSBsMiA9XG4gIG1hdGNoIChsMSwgbDIpIHdpdGhcbiAgICAoW10sIFtdKSAtPiBhY2N1XG4gIHwgKGExOjpsMSwgYTI6OmwyKSAtPiBmb2xkX2xlZnQyIGYgKGYgYWNjdSBhMSBhMikgbDEgbDJcbiAgfCAoXywgXykgLT4gaW52YWxpZF9hcmcgXCJMaXN0LmZvbGRfbGVmdDJcIlxuXG5sZXQgcmVjIGZvbGRfcmlnaHQyIGYgbDEgbDIgYWNjdSA9XG4gIG1hdGNoIChsMSwgbDIpIHdpdGhcbiAgICAoW10sIFtdKSAtPiBhY2N1XG4gIHwgKGExOjpsMSwgYTI6OmwyKSAtPiBmIGExIGEyIChmb2xkX3JpZ2h0MiBmIGwxIGwyIGFjY3UpXG4gIHwgKF8sIF8pIC0+IGludmFsaWRfYXJnIFwiTGlzdC5mb2xkX3JpZ2h0MlwiXG5cbmxldCByZWMgZm9yX2FsbCBwID0gZnVuY3Rpb25cbiAgICBbXSAtPiB0cnVlXG4gIHwgYTo6bCAtPiBwIGEgJiYgZm9yX2FsbCBwIGxcblxubGV0IHJlYyBleGlzdHMgcCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gZmFsc2VcbiAgfCBhOjpsIC0+IHAgYSB8fCBleGlzdHMgcCBsXG5cbmxldCByZWMgZm9yX2FsbDIgcCBsMSBsMiA9XG4gIG1hdGNoIChsMSwgbDIpIHdpdGhcbiAgICAoW10sIFtdKSAtPiB0cnVlXG4gIHwgKGExOjpsMSwgYTI6OmwyKSAtPiBwIGExIGEyICYmIGZvcl9hbGwyIHAgbDEgbDJcbiAgfCAoXywgXykgLT4gaW52YWxpZF9hcmcgXCJMaXN0LmZvcl9hbGwyXCJcblxubGV0IHJlYyBleGlzdHMyIHAgbDEgbDIgPVxuICBtYXRjaCAobDEsIGwyKSB3aXRoXG4gICAgKFtdLCBbXSkgLT4gZmFsc2VcbiAgfCAoYTE6OmwxLCBhMjo6bDIpIC0+IHAgYTEgYTIgfHwgZXhpc3RzMiBwIGwxIGwyXG4gIHwgKF8sIF8pIC0+IGludmFsaWRfYXJnIFwiTGlzdC5leGlzdHMyXCJcblxubGV0IHJlYyBtZW0geCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gZmFsc2VcbiAgfCBhOjpsIC0+IGNvbXBhcmUgYSB4ID0gMCB8fCBtZW0geCBsXG5cbmxldCByZWMgbWVtcSB4ID0gZnVuY3Rpb25cbiAgICBbXSAtPiBmYWxzZVxuICB8IGE6OmwgLT4gYSA9PSB4IHx8IG1lbXEgeCBsXG5cbmxldCByZWMgYXNzb2MgeCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gcmFpc2UgTm90X2ZvdW5kXG4gIHwgKGEsYik6OmwgLT4gaWYgY29tcGFyZSBhIHggPSAwIHRoZW4gYiBlbHNlIGFzc29jIHggbFxuXG5sZXQgcmVjIGFzc29jX29wdCB4ID0gZnVuY3Rpb25cbiAgICBbXSAtPiBOb25lXG4gIHwgKGEsYik6OmwgLT4gaWYgY29tcGFyZSBhIHggPSAwIHRoZW4gU29tZSBiIGVsc2UgYXNzb2Nfb3B0IHggbFxuXG5sZXQgcmVjIGFzc3EgeCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gcmFpc2UgTm90X2ZvdW5kXG4gIHwgKGEsYik6OmwgLT4gaWYgYSA9PSB4IHRoZW4gYiBlbHNlIGFzc3EgeCBsXG5cbmxldCByZWMgYXNzcV9vcHQgeCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gTm9uZVxuICB8IChhLGIpOjpsIC0+IGlmIGEgPT0geCB0aGVuIFNvbWUgYiBlbHNlIGFzc3Ffb3B0IHggbFxuXG5sZXQgcmVjIG1lbV9hc3NvYyB4ID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBmYWxzZVxuICB8IChhLCBfKSA6OiBsIC0+IGNvbXBhcmUgYSB4ID0gMCB8fCBtZW1fYXNzb2MgeCBsXG5cbmxldCByZWMgbWVtX2Fzc3EgeCA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gZmFsc2VcbiAgfCAoYSwgXykgOjogbCAtPiBhID09IHggfHwgbWVtX2Fzc3EgeCBsXG5cbmxldCByZWMgcmVtb3ZlX2Fzc29jIHggPSBmdW5jdGlvblxuICB8IFtdIC0+IFtdXG4gIHwgKGEsIF8gYXMgcGFpcikgOjogbCAtPlxuICAgICAgaWYgY29tcGFyZSBhIHggPSAwIHRoZW4gbCBlbHNlIHBhaXIgOjogcmVtb3ZlX2Fzc29jIHggbFxuXG5sZXQgcmVjIHJlbW92ZV9hc3NxIHggPSBmdW5jdGlvblxuICB8IFtdIC0+IFtdXG4gIHwgKGEsIF8gYXMgcGFpcikgOjogbCAtPiBpZiBhID09IHggdGhlbiBsIGVsc2UgcGFpciA6OiByZW1vdmVfYXNzcSB4IGxcblxubGV0IHJlYyBmaW5kIHAgPSBmdW5jdGlvblxuICB8IFtdIC0+IHJhaXNlIE5vdF9mb3VuZFxuICB8IHggOjogbCAtPiBpZiBwIHggdGhlbiB4IGVsc2UgZmluZCBwIGxcblxubGV0IHJlYyBmaW5kX29wdCBwID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBOb25lXG4gIHwgeCA6OiBsIC0+IGlmIHAgeCB0aGVuIFNvbWUgeCBlbHNlIGZpbmRfb3B0IHAgbFxuXG5sZXQgcmVjIGZpbmRfbWFwIGYgPSBmdW5jdGlvblxuICB8IFtdIC0+IE5vbmVcbiAgfCB4IDo6IGwgLT5cbiAgICAgYmVnaW4gbWF0Y2ggZiB4IHdpdGhcbiAgICAgICB8IFNvbWUgXyBhcyByZXN1bHQgLT4gcmVzdWx0XG4gICAgICAgfCBOb25lIC0+IGZpbmRfbWFwIGYgbFxuICAgICBlbmRcblxubGV0IGZpbmRfYWxsIHAgPVxuICBsZXQgcmVjIGZpbmQgYWNjdSA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gcmV2IGFjY3VcbiAgfCB4IDo6IGwgLT4gaWYgcCB4IHRoZW4gZmluZCAoeCA6OiBhY2N1KSBsIGVsc2UgZmluZCBhY2N1IGwgaW5cbiAgZmluZCBbXVxuXG5sZXQgZmlsdGVyID0gZmluZF9hbGxcblxubGV0IGZpbHRlcmkgcCBsID1cbiAgbGV0IHJlYyBhdXggaSBhY2MgPSBmdW5jdGlvblxuICB8IFtdIC0+IHJldiBhY2NcbiAgfCB4OjpsIC0+IGF1eCAoaSArIDEpIChpZiBwIGkgeCB0aGVuIHg6OmFjYyBlbHNlIGFjYykgbFxuICBpblxuICBhdXggMCBbXSBsXG5cbmxldCBmaWx0ZXJfbWFwIGYgPVxuICBsZXQgcmVjIGF1eCBhY2N1ID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IHJldiBhY2N1XG4gICAgfCB4IDo6IGwgLT5cbiAgICAgICAgbWF0Y2ggZiB4IHdpdGhcbiAgICAgICAgfCBOb25lIC0+IGF1eCBhY2N1IGxcbiAgICAgICAgfCBTb21lIHYgLT4gYXV4ICh2IDo6IGFjY3UpIGxcbiAgaW5cbiAgYXV4IFtdXG5cbmxldCBjb25jYXRfbWFwIGYgbCA9XG4gIGxldCByZWMgYXV4IGYgYWNjID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IHJldiBhY2NcbiAgICB8IHggOjogbCAtPlxuICAgICAgIGxldCB4cyA9IGYgeCBpblxuICAgICAgIGF1eCBmIChyZXZfYXBwZW5kIHhzIGFjYykgbFxuICBpbiBhdXggZiBbXSBsXG5cbmxldCBmb2xkX2xlZnRfbWFwIGYgYWNjdSBsID1cbiAgbGV0IHJlYyBhdXggYWNjdSBsX2FjY3UgPSBmdW5jdGlvblxuICAgIHwgW10gLT4gYWNjdSwgcmV2IGxfYWNjdVxuICAgIHwgeCA6OiBsIC0+XG4gICAgICAgIGxldCBhY2N1LCB4ID0gZiBhY2N1IHggaW5cbiAgICAgICAgYXV4IGFjY3UgKHggOjogbF9hY2N1KSBsIGluXG4gIGF1eCBhY2N1IFtdIGxcblxubGV0IHBhcnRpdGlvbiBwIGwgPVxuICBsZXQgcmVjIHBhcnQgeWVzIG5vID0gZnVuY3Rpb25cbiAgfCBbXSAtPiAocmV2IHllcywgcmV2IG5vKVxuICB8IHggOjogbCAtPiBpZiBwIHggdGhlbiBwYXJ0ICh4IDo6IHllcykgbm8gbCBlbHNlIHBhcnQgeWVzICh4IDo6IG5vKSBsIGluXG4gIHBhcnQgW10gW10gbFxuXG5sZXQgcGFydGl0aW9uX21hcCBwIGwgPVxuICBsZXQgcmVjIHBhcnQgbGVmdCByaWdodCA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gKHJldiBsZWZ0LCByZXYgcmlnaHQpXG4gIHwgeCA6OiBsIC0+XG4gICAgIGJlZ2luIG1hdGNoIHAgeCB3aXRoXG4gICAgICAgfCBFaXRoZXIuTGVmdCB2IC0+IHBhcnQgKHYgOjogbGVmdCkgcmlnaHQgbFxuICAgICAgIHwgRWl0aGVyLlJpZ2h0IHYgLT4gcGFydCBsZWZ0ICh2IDo6IHJpZ2h0KSBsXG4gICAgIGVuZFxuICBpblxuICBwYXJ0IFtdIFtdIGxcblxubGV0IHJlYyBzcGxpdCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gKFtdLCBbXSlcbiAgfCAoeCx5KTo6bCAtPlxuICAgICAgbGV0IChyeCwgcnkpID0gc3BsaXQgbCBpbiAoeDo6cngsIHk6OnJ5KVxuXG5sZXQgcmVjIGNvbWJpbmUgbDEgbDIgPVxuICBtYXRjaCAobDEsIGwyKSB3aXRoXG4gICAgKFtdLCBbXSkgLT4gW11cbiAgfCAoYTE6OmwxLCBhMjo6bDIpIC0+IChhMSwgYTIpIDo6IGNvbWJpbmUgbDEgbDJcbiAgfCAoXywgXykgLT4gaW52YWxpZF9hcmcgXCJMaXN0LmNvbWJpbmVcIlxuXG4oKiogc29ydGluZyAqKVxuXG5sZXQgcmVjIG1lcmdlIGNtcCBsMSBsMiA9XG4gIG1hdGNoIGwxLCBsMiB3aXRoXG4gIHwgW10sIGwyIC0+IGwyXG4gIHwgbDEsIFtdIC0+IGwxXG4gIHwgaDEgOjogdDEsIGgyIDo6IHQyIC0+XG4gICAgICBpZiBjbXAgaDEgaDIgPD0gMFxuICAgICAgdGhlbiBoMSA6OiBtZXJnZSBjbXAgdDEgbDJcbiAgICAgIGVsc2UgaDIgOjogbWVyZ2UgY21wIGwxIHQyXG5cblxubGV0IHN0YWJsZV9zb3J0IGNtcCBsID1cbiAgbGV0IHJlYyByZXZfbWVyZ2UgbDEgbDIgYWNjdSA9XG4gICAgbWF0Y2ggbDEsIGwyIHdpdGhcbiAgICB8IFtdLCBsMiAtPiByZXZfYXBwZW5kIGwyIGFjY3VcbiAgICB8IGwxLCBbXSAtPiByZXZfYXBwZW5kIGwxIGFjY3VcbiAgICB8IGgxOjp0MSwgaDI6OnQyIC0+XG4gICAgICAgIGlmIGNtcCBoMSBoMiA8PSAwXG4gICAgICAgIHRoZW4gcmV2X21lcmdlIHQxIGwyIChoMTo6YWNjdSlcbiAgICAgICAgZWxzZSByZXZfbWVyZ2UgbDEgdDIgKGgyOjphY2N1KVxuICBpblxuICBsZXQgcmVjIHJldl9tZXJnZV9yZXYgbDEgbDIgYWNjdSA9XG4gICAgbWF0Y2ggbDEsIGwyIHdpdGhcbiAgICB8IFtdLCBsMiAtPiByZXZfYXBwZW5kIGwyIGFjY3VcbiAgICB8IGwxLCBbXSAtPiByZXZfYXBwZW5kIGwxIGFjY3VcbiAgICB8IGgxOjp0MSwgaDI6OnQyIC0+XG4gICAgICAgIGlmIGNtcCBoMSBoMiA+IDBcbiAgICAgICAgdGhlbiByZXZfbWVyZ2VfcmV2IHQxIGwyIChoMTo6YWNjdSlcbiAgICAgICAgZWxzZSByZXZfbWVyZ2VfcmV2IGwxIHQyIChoMjo6YWNjdSlcbiAgaW5cbiAgbGV0IHJlYyBzb3J0IG4gbCA9XG4gICAgbWF0Y2ggbiwgbCB3aXRoXG4gICAgfCAyLCB4MSA6OiB4MiA6OiB0bCAtPlxuICAgICAgICBsZXQgcyA9IGlmIGNtcCB4MSB4MiA8PSAwIHRoZW4gW3gxOyB4Ml0gZWxzZSBbeDI7IHgxXSBpblxuICAgICAgICAocywgdGwpXG4gICAgfCAzLCB4MSA6OiB4MiA6OiB4MyA6OiB0bCAtPlxuICAgICAgICBsZXQgcyA9XG4gICAgICAgICAgaWYgY21wIHgxIHgyIDw9IDAgdGhlblxuICAgICAgICAgICAgaWYgY21wIHgyIHgzIDw9IDAgdGhlbiBbeDE7IHgyOyB4M11cbiAgICAgICAgICAgIGVsc2UgaWYgY21wIHgxIHgzIDw9IDAgdGhlbiBbeDE7IHgzOyB4Ml1cbiAgICAgICAgICAgIGVsc2UgW3gzOyB4MTsgeDJdXG4gICAgICAgICAgZWxzZSBpZiBjbXAgeDEgeDMgPD0gMCB0aGVuIFt4MjsgeDE7IHgzXVxuICAgICAgICAgIGVsc2UgaWYgY21wIHgyIHgzIDw9IDAgdGhlbiBbeDI7IHgzOyB4MV1cbiAgICAgICAgICBlbHNlIFt4MzsgeDI7IHgxXVxuICAgICAgICBpblxuICAgICAgICAocywgdGwpXG4gICAgfCBuLCBsIC0+XG4gICAgICAgIGxldCBuMSA9IG4gYXNyIDEgaW5cbiAgICAgICAgbGV0IG4yID0gbiAtIG4xIGluXG4gICAgICAgIGxldCBzMSwgbDIgPSByZXZfc29ydCBuMSBsIGluXG4gICAgICAgIGxldCBzMiwgdGwgPSByZXZfc29ydCBuMiBsMiBpblxuICAgICAgICAocmV2X21lcmdlX3JldiBzMSBzMiBbXSwgdGwpXG4gIGFuZCByZXZfc29ydCBuIGwgPVxuICAgIG1hdGNoIG4sIGwgd2l0aFxuICAgIHwgMiwgeDEgOjogeDIgOjogdGwgLT5cbiAgICAgICAgbGV0IHMgPSBpZiBjbXAgeDEgeDIgPiAwIHRoZW4gW3gxOyB4Ml0gZWxzZSBbeDI7IHgxXSBpblxuICAgICAgICAocywgdGwpXG4gICAgfCAzLCB4MSA6OiB4MiA6OiB4MyA6OiB0bCAtPlxuICAgICAgICBsZXQgcyA9XG4gICAgICAgICAgaWYgY21wIHgxIHgyID4gMCB0aGVuXG4gICAgICAgICAgICBpZiBjbXAgeDIgeDMgPiAwIHRoZW4gW3gxOyB4MjsgeDNdXG4gICAgICAgICAgICBlbHNlIGlmIGNtcCB4MSB4MyA+IDAgdGhlbiBbeDE7IHgzOyB4Ml1cbiAgICAgICAgICAgIGVsc2UgW3gzOyB4MTsgeDJdXG4gICAgICAgICAgZWxzZSBpZiBjbXAgeDEgeDMgPiAwIHRoZW4gW3gyOyB4MTsgeDNdXG4gICAgICAgICAgZWxzZSBpZiBjbXAgeDIgeDMgPiAwIHRoZW4gW3gyOyB4MzsgeDFdXG4gICAgICAgICAgZWxzZSBbeDM7IHgyOyB4MV1cbiAgICAgICAgaW5cbiAgICAgICAgKHMsIHRsKVxuICAgIHwgbiwgbCAtPlxuICAgICAgICBsZXQgbjEgPSBuIGFzciAxIGluXG4gICAgICAgIGxldCBuMiA9IG4gLSBuMSBpblxuICAgICAgICBsZXQgczEsIGwyID0gc29ydCBuMSBsIGluXG4gICAgICAgIGxldCBzMiwgdGwgPSBzb3J0IG4yIGwyIGluXG4gICAgICAgIChyZXZfbWVyZ2UgczEgczIgW10sIHRsKVxuICBpblxuICBsZXQgbGVuID0gbGVuZ3RoIGwgaW5cbiAgaWYgbGVuIDwgMiB0aGVuIGwgZWxzZSBmc3QgKHNvcnQgbGVuIGwpXG5cblxubGV0IHNvcnQgPSBzdGFibGVfc29ydFxubGV0IGZhc3Rfc29ydCA9IHN0YWJsZV9zb3J0XG5cbigqIE5vdGU6IG9uIGEgbGlzdCBvZiBsZW5ndGggYmV0d2VlbiBhYm91dCAxMDAwMDAgKGRlcGVuZGluZyBvbiB0aGUgbWlub3JcbiAgIGhlYXAgc2l6ZSBhbmQgdGhlIHR5cGUgb2YgdGhlIGxpc3QpIGFuZCBTeXMubWF4X2FycmF5X3NpemUsIGl0IGlzXG4gICBhY3R1YWxseSBmYXN0ZXIgdG8gdXNlIHRoZSBmb2xsb3dpbmcsIGJ1dCBpdCBtaWdodCBhbHNvIHVzZSBtb3JlIG1lbW9yeVxuICAgYmVjYXVzZSB0aGUgYXJndW1lbnQgbGlzdCBjYW5ub3QgYmUgZGVhbGxvY2F0ZWQgaW5jcmVtZW50YWxseS5cblxuICAgQWxzbywgdGhlcmUgc2VlbXMgdG8gYmUgYSBidWcgaW4gdGhpcyBjb2RlIG9yIGluIHRoZVxuICAgaW1wbGVtZW50YXRpb24gb2Ygb2JqX3RydW5jYXRlLlxuXG5leHRlcm5hbCBvYmpfdHJ1bmNhdGUgOiAnYSBhcnJheSAtPiBpbnQgLT4gdW5pdCA9IFwiY2FtbF9vYmpfdHJ1bmNhdGVcIlxuXG5sZXQgYXJyYXlfdG9fbGlzdF9pbl9wbGFjZSBhID1cbiAgbGV0IGwgPSBBcnJheS5sZW5ndGggYSBpblxuICBsZXQgcmVjIGxvb3AgYWNjdSBuIHAgPVxuICAgIGlmIHAgPD0gMCB0aGVuIGFjY3UgZWxzZSBiZWdpblxuICAgICAgaWYgcCA9IG4gdGhlbiBiZWdpblxuICAgICAgICBvYmpfdHJ1bmNhdGUgYSBwO1xuICAgICAgICBsb29wIChhLihwLTEpIDo6IGFjY3UpIChuLTEwMDApIChwLTEpXG4gICAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgICBsb29wIChhLihwLTEpIDo6IGFjY3UpIG4gKHAtMSlcbiAgICAgIGVuZFxuICAgIGVuZFxuICBpblxuICBsb29wIFtdIChsLTEwMDApIGxcblxuXG5sZXQgc3RhYmxlX3NvcnQgY21wIGwgPVxuICBsZXQgYSA9IEFycmF5Lm9mX2xpc3QgbCBpblxuICBBcnJheS5zdGFibGVfc29ydCBjbXAgYTtcbiAgYXJyYXlfdG9fbGlzdF9pbl9wbGFjZSBhXG5cbiopXG5cblxuKCoqIHNvcnRpbmcgKyByZW1vdmluZyBkdXBsaWNhdGVzICopXG5cbmxldCBzb3J0X3VuaXEgY21wIGwgPVxuICBsZXQgcmVjIHJldl9tZXJnZSBsMSBsMiBhY2N1ID1cbiAgICBtYXRjaCBsMSwgbDIgd2l0aFxuICAgIHwgW10sIGwyIC0+IHJldl9hcHBlbmQgbDIgYWNjdVxuICAgIHwgbDEsIFtdIC0+IHJldl9hcHBlbmQgbDEgYWNjdVxuICAgIHwgaDE6OnQxLCBoMjo6dDIgLT5cbiAgICAgICAgbGV0IGMgPSBjbXAgaDEgaDIgaW5cbiAgICAgICAgaWYgYyA9IDAgdGhlbiByZXZfbWVyZ2UgdDEgdDIgKGgxOjphY2N1KVxuICAgICAgICBlbHNlIGlmIGMgPCAwXG4gICAgICAgIHRoZW4gcmV2X21lcmdlIHQxIGwyIChoMTo6YWNjdSlcbiAgICAgICAgZWxzZSByZXZfbWVyZ2UgbDEgdDIgKGgyOjphY2N1KVxuICBpblxuICBsZXQgcmVjIHJldl9tZXJnZV9yZXYgbDEgbDIgYWNjdSA9XG4gICAgbWF0Y2ggbDEsIGwyIHdpdGhcbiAgICB8IFtdLCBsMiAtPiByZXZfYXBwZW5kIGwyIGFjY3VcbiAgICB8IGwxLCBbXSAtPiByZXZfYXBwZW5kIGwxIGFjY3VcbiAgICB8IGgxOjp0MSwgaDI6OnQyIC0+XG4gICAgICAgIGxldCBjID0gY21wIGgxIGgyIGluXG4gICAgICAgIGlmIGMgPSAwIHRoZW4gcmV2X21lcmdlX3JldiB0MSB0MiAoaDE6OmFjY3UpXG4gICAgICAgIGVsc2UgaWYgYyA+IDBcbiAgICAgICAgdGhlbiByZXZfbWVyZ2VfcmV2IHQxIGwyIChoMTo6YWNjdSlcbiAgICAgICAgZWxzZSByZXZfbWVyZ2VfcmV2IGwxIHQyIChoMjo6YWNjdSlcbiAgaW5cbiAgbGV0IHJlYyBzb3J0IG4gbCA9XG4gICAgbWF0Y2ggbiwgbCB3aXRoXG4gICAgfCAyLCB4MSA6OiB4MiA6OiB0bCAtPlxuICAgICAgICBsZXQgcyA9XG4gICAgICAgICAgbGV0IGMgPSBjbXAgeDEgeDIgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuIFt4MV0gZWxzZSBpZiBjIDwgMCB0aGVuIFt4MTsgeDJdIGVsc2UgW3gyOyB4MV1cbiAgICAgICAgaW5cbiAgICAgICAgKHMsIHRsKVxuICAgIHwgMywgeDEgOjogeDIgOjogeDMgOjogdGwgLT5cbiAgICAgICAgbGV0IHMgPVxuICAgICAgICAgIGxldCBjID0gY21wIHgxIHgyIGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlblxuICAgICAgICAgICAgbGV0IGMgPSBjbXAgeDIgeDMgaW5cbiAgICAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gyXSBlbHNlIGlmIGMgPCAwIHRoZW4gW3gyOyB4M10gZWxzZSBbeDM7IHgyXVxuICAgICAgICAgIGVsc2UgaWYgYyA8IDAgdGhlblxuICAgICAgICAgICAgbGV0IGMgPSBjbXAgeDIgeDMgaW5cbiAgICAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gxOyB4Ml1cbiAgICAgICAgICAgIGVsc2UgaWYgYyA8IDAgdGhlbiBbeDE7IHgyOyB4M11cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgbGV0IGMgPSBjbXAgeDEgeDMgaW5cbiAgICAgICAgICAgICAgaWYgYyA9IDAgdGhlbiBbeDE7IHgyXVxuICAgICAgICAgICAgICBlbHNlIGlmIGMgPCAwIHRoZW4gW3gxOyB4MzsgeDJdXG4gICAgICAgICAgICAgIGVsc2UgW3gzOyB4MTsgeDJdXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbGV0IGMgPSBjbXAgeDEgeDMgaW5cbiAgICAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gyOyB4MV1cbiAgICAgICAgICAgIGVsc2UgaWYgYyA8IDAgdGhlbiBbeDI7IHgxOyB4M11cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgbGV0IGMgPSBjbXAgeDIgeDMgaW5cbiAgICAgICAgICAgICAgaWYgYyA9IDAgdGhlbiBbeDI7IHgxXVxuICAgICAgICAgICAgICBlbHNlIGlmIGMgPCAwIHRoZW4gW3gyOyB4MzsgeDFdXG4gICAgICAgICAgICAgIGVsc2UgW3gzOyB4MjsgeDFdXG4gICAgICAgIGluXG4gICAgICAgIChzLCB0bClcbiAgICB8IG4sIGwgLT5cbiAgICAgICAgbGV0IG4xID0gbiBhc3IgMSBpblxuICAgICAgICBsZXQgbjIgPSBuIC0gbjEgaW5cbiAgICAgICAgbGV0IHMxLCBsMiA9IHJldl9zb3J0IG4xIGwgaW5cbiAgICAgICAgbGV0IHMyLCB0bCA9IHJldl9zb3J0IG4yIGwyIGluXG4gICAgICAgIChyZXZfbWVyZ2VfcmV2IHMxIHMyIFtdLCB0bClcbiAgYW5kIHJldl9zb3J0IG4gbCA9XG4gICAgbWF0Y2ggbiwgbCB3aXRoXG4gICAgfCAyLCB4MSA6OiB4MiA6OiB0bCAtPlxuICAgICAgICBsZXQgcyA9XG4gICAgICAgICAgbGV0IGMgPSBjbXAgeDEgeDIgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuIFt4MV0gZWxzZSBpZiBjID4gMCB0aGVuIFt4MTsgeDJdIGVsc2UgW3gyOyB4MV1cbiAgICAgICAgaW5cbiAgICAgICAgKHMsIHRsKVxuICAgIHwgMywgeDEgOjogeDIgOjogeDMgOjogdGwgLT5cbiAgICAgICAgbGV0IHMgPVxuICAgICAgICAgIGxldCBjID0gY21wIHgxIHgyIGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlblxuICAgICAgICAgICAgbGV0IGMgPSBjbXAgeDIgeDMgaW5cbiAgICAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gyXSBlbHNlIGlmIGMgPiAwIHRoZW4gW3gyOyB4M10gZWxzZSBbeDM7IHgyXVxuICAgICAgICAgIGVsc2UgaWYgYyA+IDAgdGhlblxuICAgICAgICAgICAgbGV0IGMgPSBjbXAgeDIgeDMgaW5cbiAgICAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gxOyB4Ml1cbiAgICAgICAgICAgIGVsc2UgaWYgYyA+IDAgdGhlbiBbeDE7IHgyOyB4M11cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgbGV0IGMgPSBjbXAgeDEgeDMgaW5cbiAgICAgICAgICAgICAgaWYgYyA9IDAgdGhlbiBbeDE7IHgyXVxuICAgICAgICAgICAgICBlbHNlIGlmIGMgPiAwIHRoZW4gW3gxOyB4MzsgeDJdXG4gICAgICAgICAgICAgIGVsc2UgW3gzOyB4MTsgeDJdXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbGV0IGMgPSBjbXAgeDEgeDMgaW5cbiAgICAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gyOyB4MV1cbiAgICAgICAgICAgIGVsc2UgaWYgYyA+IDAgdGhlbiBbeDI7IHgxOyB4M11cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgbGV0IGMgPSBjbXAgeDIgeDMgaW5cbiAgICAgICAgICAgICAgaWYgYyA9IDAgdGhlbiBbeDI7IHgxXVxuICAgICAgICAgICAgICBlbHNlIGlmIGMgPiAwIHRoZW4gW3gyOyB4MzsgeDFdXG4gICAgICAgICAgICAgIGVsc2UgW3gzOyB4MjsgeDFdXG4gICAgICAgIGluXG4gICAgICAgIChzLCB0bClcbiAgICB8IG4sIGwgLT5cbiAgICAgICAgbGV0IG4xID0gbiBhc3IgMSBpblxuICAgICAgICBsZXQgbjIgPSBuIC0gbjEgaW5cbiAgICAgICAgbGV0IHMxLCBsMiA9IHNvcnQgbjEgbCBpblxuICAgICAgICBsZXQgczIsIHRsID0gc29ydCBuMiBsMiBpblxuICAgICAgICAocmV2X21lcmdlIHMxIHMyIFtdLCB0bClcbiAgaW5cbiAgbGV0IGxlbiA9IGxlbmd0aCBsIGluXG4gIGlmIGxlbiA8IDIgdGhlbiBsIGVsc2UgZnN0IChzb3J0IGxlbiBsKVxuXG5cbmxldCByZWMgY29tcGFyZV9sZW5ndGhzIGwxIGwyID1cbiAgbWF0Y2ggbDEsIGwyIHdpdGhcbiAgfCBbXSwgW10gLT4gMFxuICB8IFtdLCBfIC0+IC0xXG4gIHwgXywgW10gLT4gMVxuICB8IF8gOjogbDEsIF8gOjogbDIgLT4gY29tcGFyZV9sZW5ndGhzIGwxIGwyXG47O1xuXG5sZXQgcmVjIGNvbXBhcmVfbGVuZ3RoX3dpdGggbCBuID1cbiAgbWF0Y2ggbCB3aXRoXG4gIHwgW10gLT5cbiAgICBpZiBuID0gMCB0aGVuIDAgZWxzZVxuICAgICAgaWYgbiA+IDAgdGhlbiAtMSBlbHNlIDFcbiAgfCBfIDo6IGwgLT5cbiAgICBpZiBuIDw9IDAgdGhlbiAxIGVsc2VcbiAgICAgIGNvbXBhcmVfbGVuZ3RoX3dpdGggbCAobi0xKVxuOztcblxuKCoqIHsxIENvbXBhcmlzb259ICopXG5cbigqIE5vdGU6IHdlIGFyZSAqbm90KiBzaG9ydGN1dHRpbmcgdGhlIGxpc3QgYnkgdXNpbmdcbiAgIFtMaXN0LmNvbXBhcmVfbGVuZ3Roc10gZmlyc3Q7IHRoaXMgbWF5IGJlIHNsb3dlciBvbiBsb25nIGxpc3RzXG4gICBpbW1lZGlhdGVseSBzdGFydCB3aXRoIGRpc3RpbmN0IGVsZW1lbnRzLiBJdCBpcyBhbHNvIGluY29ycmVjdCBmb3JcbiAgIFtjb21wYXJlXSBiZWxvdywgYW5kIGl0IGlzIGJldHRlciAocHJpbmNpcGxlIG9mIGxlYXN0IHN1cnByaXNlKSB0b1xuICAgdXNlIHRoZSBzYW1lIGFwcHJvYWNoIGZvciBib3RoIGZ1bmN0aW9ucy4gKilcbmxldCByZWMgZXF1YWwgZXEgbDEgbDIgPVxuICBtYXRjaCBsMSwgbDIgd2l0aFxuICB8IFtdLCBbXSAtPiB0cnVlXG4gIHwgW10sIF86Ol8gfCBfOjpfLCBbXSAtPiBmYWxzZVxuICB8IGExOjpsMSwgYTI6OmwyIC0+IGVxIGExIGEyICYmIGVxdWFsIGVxIGwxIGwyXG5cbmxldCByZWMgY29tcGFyZSBjbXAgbDEgbDIgPVxuICBtYXRjaCBsMSwgbDIgd2l0aFxuICB8IFtdLCBbXSAtPiAwXG4gIHwgW10sIF86Ol8gLT4gLTFcbiAgfCBfOjpfLCBbXSAtPiAxXG4gIHwgYTE6OmwxLCBhMjo6bDIgLT5cbiAgICBsZXQgYyA9IGNtcCBhMSBhMiBpblxuICAgIGlmIGMgPD4gMCB0aGVuIGNcbiAgICBlbHNlIGNvbXBhcmUgY21wIGwxIGwyXG5cbigqKiB7MSBJdGVyYXRvcnN9ICopXG5cbmxldCB0b19zZXEgbCA9XG4gIGxldCByZWMgYXV4IGwgKCkgPSBtYXRjaCBsIHdpdGhcbiAgICB8IFtdIC0+IFNlcS5OaWxcbiAgICB8IHggOjogdGFpbCAtPiBTZXEuQ29ucyAoeCwgYXV4IHRhaWwpXG4gIGluXG4gIGF1eCBsXG5cbmxldCBvZl9zZXEgc2VxID1cbiAgbGV0IHJlYyBkaXJlY3QgZGVwdGggc2VxIDogXyBsaXN0ID1cbiAgICBpZiBkZXB0aD0wXG4gICAgdGhlblxuICAgICAgU2VxLmZvbGRfbGVmdCAoZnVuIGFjYyB4IC0+IHg6OmFjYykgW10gc2VxXG4gICAgICB8PiByZXYgKCogdGFpbHJlYyAqKVxuICAgIGVsc2UgbWF0Y2ggc2VxKCkgd2l0aFxuICAgICAgfCBTZXEuTmlsIC0+IFtdXG4gICAgICB8IFNlcS5Db25zICh4LCBuZXh0KSAtPiB4IDo6IGRpcmVjdCAoZGVwdGgtMSkgbmV4dFxuICBpblxuICBkaXJlY3QgNTAwIHNlcVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgIFNpbW9uIENydWFuZXMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxNyBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBNb2R1bGUgW1NlcV06IGZ1bmN0aW9uYWwgaXRlcmF0b3JzICopXG5cbnR5cGUgKydhIG5vZGUgPVxuICB8IE5pbFxuICB8IENvbnMgb2YgJ2EgKiAnYSB0XG5cbmFuZCAnYSB0ID0gdW5pdCAtPiAnYSBub2RlXG5cbmxldCBlbXB0eSAoKSA9IE5pbFxuXG5sZXQgcmV0dXJuIHggKCkgPSBDb25zICh4LCBlbXB0eSlcblxubGV0IGNvbnMgeCBuZXh0ICgpID0gQ29ucyAoeCwgbmV4dClcblxubGV0IHJlYyBhcHBlbmQgc2VxMSBzZXEyICgpID1cbiAgbWF0Y2ggc2VxMSgpIHdpdGhcbiAgfCBOaWwgLT4gc2VxMigpXG4gIHwgQ29ucyAoeCwgbmV4dCkgLT4gQ29ucyAoeCwgYXBwZW5kIG5leHQgc2VxMilcblxubGV0IHJlYyBtYXAgZiBzZXEgKCkgPSBtYXRjaCBzZXEoKSB3aXRoXG4gIHwgTmlsIC0+IE5pbFxuICB8IENvbnMgKHgsIG5leHQpIC0+IENvbnMgKGYgeCwgbWFwIGYgbmV4dClcblxubGV0IHJlYyBmaWx0ZXJfbWFwIGYgc2VxICgpID0gbWF0Y2ggc2VxKCkgd2l0aFxuICB8IE5pbCAtPiBOaWxcbiAgfCBDb25zICh4LCBuZXh0KSAtPlxuICAgICAgbWF0Y2ggZiB4IHdpdGhcbiAgICAgICAgfCBOb25lIC0+IGZpbHRlcl9tYXAgZiBuZXh0ICgpXG4gICAgICAgIHwgU29tZSB5IC0+IENvbnMgKHksIGZpbHRlcl9tYXAgZiBuZXh0KVxuXG5sZXQgcmVjIGZpbHRlciBmIHNlcSAoKSA9IG1hdGNoIHNlcSgpIHdpdGhcbiAgfCBOaWwgLT4gTmlsXG4gIHwgQ29ucyAoeCwgbmV4dCkgLT5cbiAgICAgIGlmIGYgeFxuICAgICAgdGhlbiBDb25zICh4LCBmaWx0ZXIgZiBuZXh0KVxuICAgICAgZWxzZSBmaWx0ZXIgZiBuZXh0ICgpXG5cbmxldCByZWMgZmxhdF9tYXAgZiBzZXEgKCkgPSBtYXRjaCBzZXEgKCkgd2l0aFxuICB8IE5pbCAtPiBOaWxcbiAgfCBDb25zICh4LCBuZXh0KSAtPlxuICAgIGZsYXRfbWFwX2FwcCBmIChmIHgpIG5leHQgKClcblxuKCogdGhpcyBpcyBbYXBwZW5kIHNlcSAoZmxhdF9tYXAgZiB0YWlsKV0gKilcbmFuZCBmbGF0X21hcF9hcHAgZiBzZXEgdGFpbCAoKSA9IG1hdGNoIHNlcSAoKSB3aXRoXG4gIHwgTmlsIC0+IGZsYXRfbWFwIGYgdGFpbCAoKVxuICB8IENvbnMgKHgsIG5leHQpIC0+XG4gICAgQ29ucyAoeCwgZmxhdF9tYXBfYXBwIGYgbmV4dCB0YWlsKVxuXG5sZXQgZm9sZF9sZWZ0IGYgYWNjIHNlcSA9XG4gIGxldCByZWMgYXV4IGYgYWNjIHNlcSA9IG1hdGNoIHNlcSAoKSB3aXRoXG4gICAgfCBOaWwgLT4gYWNjXG4gICAgfCBDb25zICh4LCBuZXh0KSAtPlxuICAgICAgICBsZXQgYWNjID0gZiBhY2MgeCBpblxuICAgICAgICBhdXggZiBhY2MgbmV4dFxuICBpblxuICBhdXggZiBhY2Mgc2VxXG5cbmxldCBpdGVyIGYgc2VxID1cbiAgbGV0IHJlYyBhdXggc2VxID0gbWF0Y2ggc2VxICgpIHdpdGhcbiAgICB8IE5pbCAtPiAoKVxuICAgIHwgQ29ucyAoeCwgbmV4dCkgLT5cbiAgICAgICAgZiB4O1xuICAgICAgICBhdXggbmV4dFxuICBpblxuICBhdXggc2VxXG5cbmxldCByZWMgdW5mb2xkIGYgdSAoKSA9XG4gIG1hdGNoIGYgdSB3aXRoXG4gIHwgTm9uZSAtPiBOaWxcbiAgfCBTb21lICh4LCB1JykgLT4gQ29ucyAoeCwgdW5mb2xkIGYgdScpXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgT0NhbWwgcHJvZ3JhbW1lcnMgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE4IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUgJ2EgdCA9ICdhIG9wdGlvbiA9IE5vbmUgfCBTb21lIG9mICdhXG5cbmxldCBub25lID0gTm9uZVxubGV0IHNvbWUgdiA9IFNvbWUgdlxubGV0IHZhbHVlIG8gfmRlZmF1bHQgPSBtYXRjaCBvIHdpdGggU29tZSB2IC0+IHYgfCBOb25lIC0+IGRlZmF1bHRcbmxldCBnZXQgPSBmdW5jdGlvbiBTb21lIHYgLT4gdiB8IE5vbmUgLT4gaW52YWxpZF9hcmcgXCJvcHRpb24gaXMgTm9uZVwiXG5sZXQgYmluZCBvIGYgPSBtYXRjaCBvIHdpdGggTm9uZSAtPiBOb25lIHwgU29tZSB2IC0+IGYgdlxubGV0IGpvaW4gPSBmdW5jdGlvbiBTb21lIG8gLT4gbyB8IE5vbmUgLT4gTm9uZVxubGV0IG1hcCBmIG8gPSBtYXRjaCBvIHdpdGggTm9uZSAtPiBOb25lIHwgU29tZSB2IC0+IFNvbWUgKGYgdilcbmxldCBmb2xkIH5ub25lIH5zb21lID0gZnVuY3Rpb24gU29tZSB2IC0+IHNvbWUgdiB8IE5vbmUgLT4gbm9uZVxubGV0IGl0ZXIgZiA9IGZ1bmN0aW9uIFNvbWUgdiAtPiBmIHYgfCBOb25lIC0+ICgpXG5sZXQgaXNfbm9uZSA9IGZ1bmN0aW9uIE5vbmUgLT4gdHJ1ZSB8IFNvbWUgXyAtPiBmYWxzZVxubGV0IGlzX3NvbWUgPSBmdW5jdGlvbiBOb25lIC0+IGZhbHNlIHwgU29tZSBfIC0+IHRydWVcblxubGV0IGVxdWFsIGVxIG8wIG8xID0gbWF0Y2ggbzAsIG8xIHdpdGhcbnwgU29tZSB2MCwgU29tZSB2MSAtPiBlcSB2MCB2MVxufCBOb25lLCBOb25lIC0+IHRydWVcbnwgXyAtPiBmYWxzZVxuXG5sZXQgY29tcGFyZSBjbXAgbzAgbzEgPSBtYXRjaCBvMCwgbzEgd2l0aFxufCBTb21lIHYwLCBTb21lIHYxIC0+IGNtcCB2MCB2MVxufCBOb25lLCBOb25lIC0+IDBcbnwgTm9uZSwgU29tZSBfIC0+IC0xXG58IFNvbWUgXywgTm9uZSAtPiAxXG5cbmxldCB0b19yZXN1bHQgfm5vbmUgPSBmdW5jdGlvbiBOb25lIC0+IEVycm9yIG5vbmUgfCBTb21lIHYgLT4gT2sgdlxubGV0IHRvX2xpc3QgPSBmdW5jdGlvbiBOb25lIC0+IFtdIHwgU29tZSB2IC0+IFt2XVxubGV0IHRvX3NlcSA9IGZ1bmN0aW9uIE5vbmUgLT4gU2VxLmVtcHR5IHwgU29tZSB2IC0+IFNlcS5yZXR1cm4gdlxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICBHYWJyaWVsIFNjaGVyZXIsIHByb2pldCBQYXJzaWZhbCwgSU5SSUEgU2FjbGF5ICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxOSBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlICgnYSwgJ2IpIHQgPSBMZWZ0IG9mICdhIHwgUmlnaHQgb2YgJ2JcblxubGV0IGxlZnQgdiA9IExlZnQgdlxubGV0IHJpZ2h0IHYgPSBSaWdodCB2XG5cbmxldCBpc19sZWZ0ID0gZnVuY3Rpb25cbnwgTGVmdCBfIC0+IHRydWVcbnwgUmlnaHQgXyAtPiBmYWxzZVxuXG5sZXQgaXNfcmlnaHQgPSBmdW5jdGlvblxufCBMZWZ0IF8gLT4gZmFsc2VcbnwgUmlnaHQgXyAtPiB0cnVlXG5cbmxldCBmaW5kX2xlZnQgPSBmdW5jdGlvblxufCBMZWZ0IHYgLT4gU29tZSB2XG58IFJpZ2h0IF8gLT4gTm9uZVxuXG5sZXQgZmluZF9yaWdodCA9IGZ1bmN0aW9uXG58IExlZnQgXyAtPiBOb25lXG58IFJpZ2h0IHYgLT4gU29tZSB2XG5cbmxldCBtYXBfbGVmdCBmID0gZnVuY3Rpb25cbnwgTGVmdCB2IC0+IExlZnQgKGYgdilcbnwgUmlnaHQgXyBhcyBlIC0+IGVcblxubGV0IG1hcF9yaWdodCBmID0gZnVuY3Rpb25cbnwgTGVmdCBfIGFzIGUgLT4gZVxufCBSaWdodCB2IC0+IFJpZ2h0IChmIHYpXG5cbmxldCBtYXAgfmxlZnQgfnJpZ2h0ID0gZnVuY3Rpb25cbnwgTGVmdCB2IC0+IExlZnQgKGxlZnQgdilcbnwgUmlnaHQgdiAtPiBSaWdodCAocmlnaHQgdilcblxubGV0IGZvbGQgfmxlZnQgfnJpZ2h0ID0gZnVuY3Rpb25cbnwgTGVmdCB2IC0+IGxlZnQgdlxufCBSaWdodCB2IC0+IHJpZ2h0IHZcblxubGV0IGl0ZXIgPSBmb2xkXG5cbmxldCBmb3JfYWxsID0gZm9sZFxuXG5sZXQgZXF1YWwgfmxlZnQgfnJpZ2h0IGUxIGUyID0gbWF0Y2ggZTEsIGUyIHdpdGhcbnwgTGVmdCB2MSwgTGVmdCB2MiAtPiBsZWZ0IHYxIHYyXG58IFJpZ2h0IHYxLCBSaWdodCB2MiAtPiByaWdodCB2MSB2MlxufCBMZWZ0IF8sIFJpZ2h0IF8gfCBSaWdodCBfLCBMZWZ0IF8gLT4gZmFsc2VcblxubGV0IGNvbXBhcmUgfmxlZnQgfnJpZ2h0IGUxIGUyID0gbWF0Y2ggZTEsIGUyIHdpdGhcbnwgTGVmdCB2MSwgTGVmdCB2MiAtPiBsZWZ0IHYxIHYyXG58IFJpZ2h0IHYxLCBSaWdodCB2MiAtPiByaWdodCB2MSB2MlxufCBMZWZ0IF8sIFJpZ2h0IF8gLT4gKC0xKVxufCBSaWdodCBfLCBMZWZ0IF8gLT4gMVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgVGhlIE9DYW1sIHByb2dyYW1tZXJzICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxOCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlICgnYSwgJ2UpIHQgPSAoJ2EsICdlKSByZXN1bHQgPSBPayBvZiAnYSB8IEVycm9yIG9mICdlXG5cbmxldCBvayB2ID0gT2sgdlxubGV0IGVycm9yIGUgPSBFcnJvciBlXG5sZXQgdmFsdWUgciB+ZGVmYXVsdCA9IG1hdGNoIHIgd2l0aCBPayB2IC0+IHYgfCBFcnJvciBfIC0+IGRlZmF1bHRcbmxldCBnZXRfb2sgPSBmdW5jdGlvbiBPayB2IC0+IHYgfCBFcnJvciBfIC0+IGludmFsaWRfYXJnIFwicmVzdWx0IGlzIEVycm9yIF9cIlxubGV0IGdldF9lcnJvciA9IGZ1bmN0aW9uIEVycm9yIGUgLT4gZSB8IE9rIF8gLT4gaW52YWxpZF9hcmcgXCJyZXN1bHQgaXMgT2sgX1wiXG5sZXQgYmluZCByIGYgPSBtYXRjaCByIHdpdGggT2sgdiAtPiBmIHYgfCBFcnJvciBfIGFzIGUgLT4gZVxubGV0IGpvaW4gPSBmdW5jdGlvbiBPayByIC0+IHIgfCBFcnJvciBfIGFzIGUgLT4gZVxubGV0IG1hcCBmID0gZnVuY3Rpb24gT2sgdiAtPiBPayAoZiB2KSB8IEVycm9yIF8gYXMgZSAtPiBlXG5sZXQgbWFwX2Vycm9yIGYgPSBmdW5jdGlvbiBFcnJvciBlIC0+IEVycm9yIChmIGUpIHwgT2sgXyBhcyB2IC0+IHZcbmxldCBmb2xkIH5vayB+ZXJyb3IgPSBmdW5jdGlvbiBPayB2IC0+IG9rIHYgfCBFcnJvciBlIC0+IGVycm9yIGVcbmxldCBpdGVyIGYgPSBmdW5jdGlvbiBPayB2IC0+IGYgdiB8IEVycm9yIF8gLT4gKClcbmxldCBpdGVyX2Vycm9yIGYgPSBmdW5jdGlvbiBFcnJvciBlIC0+IGYgZSB8IE9rIF8gLT4gKClcbmxldCBpc19vayA9IGZ1bmN0aW9uIE9rIF8gLT4gdHJ1ZSB8IEVycm9yIF8gLT4gZmFsc2VcbmxldCBpc19lcnJvciA9IGZ1bmN0aW9uIEVycm9yIF8gLT4gdHJ1ZSB8IE9rIF8gLT4gZmFsc2VcblxubGV0IGVxdWFsIH5vayB+ZXJyb3IgcjAgcjEgPSBtYXRjaCByMCwgcjEgd2l0aFxufCBPayB2MCwgT2sgdjEgLT4gb2sgdjAgdjFcbnwgRXJyb3IgZTAsIEVycm9yIGUxIC0+IGVycm9yIGUwIGUxXG58IF8sIF8gLT4gZmFsc2VcblxubGV0IGNvbXBhcmUgfm9rIH5lcnJvciByMCByMSA9IG1hdGNoIHIwLCByMSB3aXRoXG58IE9rIHYwLCBPayB2MSAtPiBvayB2MCB2MVxufCBFcnJvciBlMCwgRXJyb3IgZTEgLT4gZXJyb3IgZTAgZTFcbnwgT2sgXywgRXJyb3IgXyAtPiAtMVxufCBFcnJvciBfLCBPayBfIC0+IDFcblxubGV0IHRvX29wdGlvbiA9IGZ1bmN0aW9uIE9rIHYgLT4gU29tZSB2IHwgRXJyb3IgXyAtPiBOb25lXG5sZXQgdG9fbGlzdCA9IGZ1bmN0aW9uIE9rIHYgLT4gW3ZdIHwgRXJyb3IgXyAtPiBbXVxubGV0IHRvX3NlcSA9IGZ1bmN0aW9uIE9rIHYgLT4gU2VxLnJldHVybiB2IHwgRXJyb3IgXyAtPiBTZXEuZW1wdHlcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBPQ2FtbCBwcm9ncmFtbWVycyAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMTggSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxudHlwZSB0ID0gYm9vbCA9IGZhbHNlIHwgdHJ1ZVxuXG5leHRlcm5hbCBub3QgOiBib29sIC0+IGJvb2wgPSBcIiVib29sbm90XCJcbmV4dGVybmFsICggJiYgKSA6IGJvb2wgLT4gYm9vbCAtPiBib29sID0gXCIlc2VxdWFuZFwiXG5leHRlcm5hbCAoIHx8ICkgOiBib29sIC0+IGJvb2wgLT4gYm9vbCA9IFwiJXNlcXVvclwiXG5sZXQgZXF1YWwgOiBib29sIC0+IGJvb2wgLT4gYm9vbCA9ICggPSApXG5sZXQgY29tcGFyZSA6IGJvb2wgLT4gYm9vbCAtPiBpbnQgPSBTdGRsaWIuY29tcGFyZVxuZXh0ZXJuYWwgdG9faW50IDogYm9vbCAtPiBpbnQgPSBcIiVpZGVudGl0eVwiXG5sZXQgdG9fZmxvYXQgPSBmdW5jdGlvbiBmYWxzZSAtPiAwLiB8IHRydWUgLT4gMS5cblxuKCpcbmxldCBvZl9zdHJpbmcgPSBmdW5jdGlvblxufCBcImZhbHNlXCIgLT4gU29tZSBmYWxzZVxufCBcInRydWVcIiAtPiBTb21lIHRydWVcbnwgXyAtPiBOb25lXG4qKVxuXG5sZXQgdG9fc3RyaW5nID0gZnVuY3Rpb24gZmFsc2UgLT4gXCJmYWxzZVwiIHwgdHJ1ZSAtPiBcInRydWVcIlxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBDaGFyYWN0ZXIgb3BlcmF0aW9ucyAqKVxuXG5leHRlcm5hbCBjb2RlOiBjaGFyIC0+IGludCA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIHVuc2FmZV9jaHI6IGludCAtPiBjaGFyID0gXCIlaWRlbnRpdHlcIlxuXG5sZXQgY2hyIG4gPVxuICBpZiBuIDwgMCB8fCBuID4gMjU1IHRoZW4gaW52YWxpZF9hcmcgXCJDaGFyLmNoclwiIGVsc2UgdW5zYWZlX2NociBuXG5cbmV4dGVybmFsIGJ5dGVzX2NyZWF0ZTogaW50IC0+IGJ5dGVzID0gXCJjYW1sX2NyZWF0ZV9ieXRlc1wiXG5leHRlcm5hbCBieXRlc191bnNhZmVfc2V0IDogYnl0ZXMgLT4gaW50IC0+IGNoYXIgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcIiVieXRlc191bnNhZmVfc2V0XCJcbmV4dGVybmFsIHVuc2FmZV90b19zdHJpbmcgOiBieXRlcyAtPiBzdHJpbmcgPSBcIiVieXRlc190b19zdHJpbmdcIlxuXG5sZXQgZXNjYXBlZCA9IGZ1bmN0aW9uXG4gIHwgJ1xcJycgLT4gXCJcXFxcJ1wiXG4gIHwgJ1xcXFwnIC0+IFwiXFxcXFxcXFxcIlxuICB8ICdcXG4nIC0+IFwiXFxcXG5cIlxuICB8ICdcXHQnIC0+IFwiXFxcXHRcIlxuICB8ICdcXHInIC0+IFwiXFxcXHJcIlxuICB8ICdcXGInIC0+IFwiXFxcXGJcIlxuICB8ICcgJyAuLiAnficgYXMgYyAtPlxuICAgICAgbGV0IHMgPSBieXRlc19jcmVhdGUgMSBpblxuICAgICAgYnl0ZXNfdW5zYWZlX3NldCBzIDAgYztcbiAgICAgIHVuc2FmZV90b19zdHJpbmcgc1xuICB8IGMgLT5cbiAgICAgIGxldCBuID0gY29kZSBjIGluXG4gICAgICBsZXQgcyA9IGJ5dGVzX2NyZWF0ZSA0IGluXG4gICAgICBieXRlc191bnNhZmVfc2V0IHMgMCAnXFxcXCc7XG4gICAgICBieXRlc191bnNhZmVfc2V0IHMgMSAodW5zYWZlX2NociAoNDggKyBuIC8gMTAwKSk7XG4gICAgICBieXRlc191bnNhZmVfc2V0IHMgMiAodW5zYWZlX2NociAoNDggKyAobiAvIDEwKSBtb2QgMTApKTtcbiAgICAgIGJ5dGVzX3Vuc2FmZV9zZXQgcyAzICh1bnNhZmVfY2hyICg0OCArIG4gbW9kIDEwKSk7XG4gICAgICB1bnNhZmVfdG9fc3RyaW5nIHNcblxubGV0IGxvd2VyY2FzZSA9IGZ1bmN0aW9uXG4gIHwgJ0EnIC4uICdaJ1xuICB8ICdcXDE5MicgLi4gJ1xcMjE0J1xuICB8ICdcXDIxNicgLi4gJ1xcMjIyJyBhcyBjIC0+XG4gICAgdW5zYWZlX2Nocihjb2RlIGMgKyAzMilcbiAgfCBjIC0+IGNcblxubGV0IHVwcGVyY2FzZSA9IGZ1bmN0aW9uXG4gIHwgJ2EnIC4uICd6J1xuICB8ICdcXDIyNCcgLi4gJ1xcMjQ2J1xuICB8ICdcXDI0OCcgLi4gJ1xcMjU0JyBhcyBjIC0+XG4gICAgdW5zYWZlX2Nocihjb2RlIGMgLSAzMilcbiAgfCBjIC0+IGNcblxubGV0IGxvd2VyY2FzZV9hc2NpaSA9IGZ1bmN0aW9uXG4gIHwgJ0EnIC4uICdaJyBhcyBjIC0+IHVuc2FmZV9jaHIoY29kZSBjICsgMzIpXG4gIHwgYyAtPiBjXG5cbmxldCB1cHBlcmNhc2VfYXNjaWkgPSBmdW5jdGlvblxuICB8ICdhJyAuLiAneicgYXMgYyAtPiB1bnNhZmVfY2hyKGNvZGUgYyAtIDMyKVxuICB8IGMgLT4gY1xuXG50eXBlIHQgPSBjaGFyXG5cbmxldCBjb21wYXJlIGMxIGMyID0gY29kZSBjMSAtIGNvZGUgYzJcbmxldCBlcXVhbCAoYzE6IHQpIChjMjogdCkgPSBjb21wYXJlIGMxIGMyID0gMFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBCeXRlIHNlcXVlbmNlIG9wZXJhdGlvbnMgKilcblxuKCogV0FSTklORzogU29tZSBmdW5jdGlvbnMgaW4gdGhpcyBmaWxlIGFyZSBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCBmb3JcbiAgIGVmZmljaWVuY3kgcmVhc29ucy4gV2hlbiB5b3UgbW9kaWZ5IHRoZSBvbmUgaW4gdGhpcyBmaWxlIHlvdSBuZWVkIHRvXG4gICBtb2RpZnkgaXRzIGR1cGxpY2F0ZSBpbiBzdHJpbmcubWwuXG4gICBUaGVzZSBmdW5jdGlvbnMgaGF2ZSBhIFwiZHVwbGljYXRlZFwiIGNvbW1lbnQgYWJvdmUgdGhlaXIgZGVmaW5pdGlvbi5cbiopXG5cbmV4dGVybmFsIGxlbmd0aCA6IGJ5dGVzIC0+IGludCA9IFwiJWJ5dGVzX2xlbmd0aFwiXG5leHRlcm5hbCBzdHJpbmdfbGVuZ3RoIDogc3RyaW5nIC0+IGludCA9IFwiJXN0cmluZ19sZW5ndGhcIlxuZXh0ZXJuYWwgZ2V0IDogYnl0ZXMgLT4gaW50IC0+IGNoYXIgPSBcIiVieXRlc19zYWZlX2dldFwiXG5leHRlcm5hbCBzZXQgOiBieXRlcyAtPiBpbnQgLT4gY2hhciAtPiB1bml0ID0gXCIlYnl0ZXNfc2FmZV9zZXRcIlxuZXh0ZXJuYWwgY3JlYXRlIDogaW50IC0+IGJ5dGVzID0gXCJjYW1sX2NyZWF0ZV9ieXRlc1wiXG5leHRlcm5hbCB1bnNhZmVfZ2V0IDogYnl0ZXMgLT4gaW50IC0+IGNoYXIgPSBcIiVieXRlc191bnNhZmVfZ2V0XCJcbmV4dGVybmFsIHVuc2FmZV9zZXQgOiBieXRlcyAtPiBpbnQgLT4gY2hhciAtPiB1bml0ID0gXCIlYnl0ZXNfdW5zYWZlX3NldFwiXG5leHRlcm5hbCB1bnNhZmVfZmlsbCA6IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gY2hhciAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9maWxsX2J5dGVzXCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIHVuc2FmZV90b19zdHJpbmcgOiBieXRlcyAtPiBzdHJpbmcgPSBcIiVieXRlc190b19zdHJpbmdcIlxuZXh0ZXJuYWwgdW5zYWZlX29mX3N0cmluZyA6IHN0cmluZyAtPiBieXRlcyA9IFwiJWJ5dGVzX29mX3N0cmluZ1wiXG5cbmV4dGVybmFsIHVuc2FmZV9ibGl0IDogYnl0ZXMgLT4gaW50IC0+IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfYmxpdF9ieXRlc1wiIFtAQG5vYWxsb2NdXG5leHRlcm5hbCB1bnNhZmVfYmxpdF9zdHJpbmcgOiBzdHJpbmcgLT4gaW50IC0+IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfYmxpdF9zdHJpbmdcIiBbQEBub2FsbG9jXVxuXG5sZXQgbWFrZSBuIGMgPVxuICBsZXQgcyA9IGNyZWF0ZSBuIGluXG4gIHVuc2FmZV9maWxsIHMgMCBuIGM7XG4gIHNcblxubGV0IGluaXQgbiBmID1cbiAgbGV0IHMgPSBjcmVhdGUgbiBpblxuICBmb3IgaSA9IDAgdG8gbiAtIDEgZG9cbiAgICB1bnNhZmVfc2V0IHMgaSAoZiBpKVxuICBkb25lO1xuICBzXG5cbmxldCBlbXB0eSA9IGNyZWF0ZSAwXG5cbmxldCBjb3B5IHMgPVxuICBsZXQgbGVuID0gbGVuZ3RoIHMgaW5cbiAgbGV0IHIgPSBjcmVhdGUgbGVuIGluXG4gIHVuc2FmZV9ibGl0IHMgMCByIDAgbGVuO1xuICByXG5cbmxldCB0b19zdHJpbmcgYiA9IHVuc2FmZV90b19zdHJpbmcgKGNvcHkgYilcbmxldCBvZl9zdHJpbmcgcyA9IGNvcHkgKHVuc2FmZV9vZl9zdHJpbmcgcylcblxubGV0IHN1YiBzIG9mcyBsZW4gPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gbGVuZ3RoIHMgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIlN0cmluZy5zdWIgLyBCeXRlcy5zdWJcIlxuICBlbHNlIGJlZ2luXG4gICAgbGV0IHIgPSBjcmVhdGUgbGVuIGluXG4gICAgdW5zYWZlX2JsaXQgcyBvZnMgciAwIGxlbjtcbiAgICByXG4gIGVuZFxuXG5sZXQgc3ViX3N0cmluZyBiIG9mcyBsZW4gPSB1bnNhZmVfdG9fc3RyaW5nIChzdWIgYiBvZnMgbGVuKVxuXG4oKiBhZGRpdGlvbiB3aXRoIGFuIG92ZXJmbG93IGNoZWNrICopXG5sZXQgKCsrKSBhIGIgPVxuICBsZXQgYyA9IGEgKyBiIGluXG4gIG1hdGNoIGEgPCAwLCBiIDwgMCwgYyA8IDAgd2l0aFxuICB8IHRydWUgLCB0cnVlICwgZmFsc2VcbiAgfCBmYWxzZSwgZmFsc2UsIHRydWUgIC0+IGludmFsaWRfYXJnIFwiQnl0ZXMuZXh0ZW5kXCIgKCogb3ZlcmZsb3cgKilcbiAgfCBfIC0+IGNcblxubGV0IGV4dGVuZCBzIGxlZnQgcmlnaHQgPVxuICBsZXQgbGVuID0gbGVuZ3RoIHMgKysgbGVmdCArKyByaWdodCBpblxuICBsZXQgciA9IGNyZWF0ZSBsZW4gaW5cbiAgbGV0IChzcmNvZmYsIGRzdG9mZikgPSBpZiBsZWZ0IDwgMCB0aGVuIC1sZWZ0LCAwIGVsc2UgMCwgbGVmdCBpblxuICBsZXQgY3B5bGVuID0gbWluIChsZW5ndGggcyAtIHNyY29mZikgKGxlbiAtIGRzdG9mZikgaW5cbiAgaWYgY3B5bGVuID4gMCB0aGVuIHVuc2FmZV9ibGl0IHMgc3Jjb2ZmIHIgZHN0b2ZmIGNweWxlbjtcbiAgclxuXG5sZXQgZmlsbCBzIG9mcyBsZW4gYyA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBsZW5ndGggcyAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiU3RyaW5nLmZpbGwgLyBCeXRlcy5maWxsXCJcbiAgZWxzZSB1bnNhZmVfZmlsbCBzIG9mcyBsZW4gY1xuXG5sZXQgYmxpdCBzMSBvZnMxIHMyIG9mczIgbGVuID1cbiAgaWYgbGVuIDwgMCB8fCBvZnMxIDwgMCB8fCBvZnMxID4gbGVuZ3RoIHMxIC0gbGVuXG4gICAgICAgICAgICAgfHwgb2ZzMiA8IDAgfHwgb2ZzMiA+IGxlbmd0aCBzMiAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiQnl0ZXMuYmxpdFwiXG4gIGVsc2UgdW5zYWZlX2JsaXQgczEgb2ZzMSBzMiBvZnMyIGxlblxuXG5sZXQgYmxpdF9zdHJpbmcgczEgb2ZzMSBzMiBvZnMyIGxlbiA9XG4gIGlmIGxlbiA8IDAgfHwgb2ZzMSA8IDAgfHwgb2ZzMSA+IHN0cmluZ19sZW5ndGggczEgLSBsZW5cbiAgICAgICAgICAgICB8fCBvZnMyIDwgMCB8fCBvZnMyID4gbGVuZ3RoIHMyIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJTdHJpbmcuYmxpdCAvIEJ5dGVzLmJsaXRfc3RyaW5nXCJcbiAgZWxzZSB1bnNhZmVfYmxpdF9zdHJpbmcgczEgb2ZzMSBzMiBvZnMyIGxlblxuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IGl0ZXIgZiBhID1cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCBhIC0gMSBkbyBmKHVuc2FmZV9nZXQgYSBpKSBkb25lXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgaXRlcmkgZiBhID1cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCBhIC0gMSBkbyBmIGkgKHVuc2FmZV9nZXQgYSBpKSBkb25lXG5cbmxldCBlbnN1cmVfZ2UgKHg6aW50KSB5ID0gaWYgeCA+PSB5IHRoZW4geCBlbHNlIGludmFsaWRfYXJnIFwiQnl0ZXMuY29uY2F0XCJcblxubGV0IHJlYyBzdW1fbGVuZ3RocyBhY2Mgc2VwbGVuID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBhY2NcbiAgfCBoZCA6OiBbXSAtPiBsZW5ndGggaGQgKyBhY2NcbiAgfCBoZCA6OiB0bCAtPiBzdW1fbGVuZ3RocyAoZW5zdXJlX2dlIChsZW5ndGggaGQgKyBzZXBsZW4gKyBhY2MpIGFjYykgc2VwbGVuIHRsXG5cbmxldCByZWMgdW5zYWZlX2JsaXRzIGRzdCBwb3Mgc2VwIHNlcGxlbiA9IGZ1bmN0aW9uXG4gICAgW10gLT4gZHN0XG4gIHwgaGQgOjogW10gLT5cbiAgICB1bnNhZmVfYmxpdCBoZCAwIGRzdCBwb3MgKGxlbmd0aCBoZCk7IGRzdFxuICB8IGhkIDo6IHRsIC0+XG4gICAgdW5zYWZlX2JsaXQgaGQgMCBkc3QgcG9zIChsZW5ndGggaGQpO1xuICAgIHVuc2FmZV9ibGl0IHNlcCAwIGRzdCAocG9zICsgbGVuZ3RoIGhkKSBzZXBsZW47XG4gICAgdW5zYWZlX2JsaXRzIGRzdCAocG9zICsgbGVuZ3RoIGhkICsgc2VwbGVuKSBzZXAgc2VwbGVuIHRsXG5cbmxldCBjb25jYXQgc2VwID0gZnVuY3Rpb25cbiAgICBbXSAtPiBlbXB0eVxuICB8IGwgLT4gbGV0IHNlcGxlbiA9IGxlbmd0aCBzZXAgaW5cbiAgICAgICAgICB1bnNhZmVfYmxpdHNcbiAgICAgICAgICAgIChjcmVhdGUgKHN1bV9sZW5ndGhzIDAgc2VwbGVuIGwpKVxuICAgICAgICAgICAgMCBzZXAgc2VwbGVuIGxcblxubGV0IGNhdCBzMSBzMiA9XG4gIGxldCBsMSA9IGxlbmd0aCBzMSBpblxuICBsZXQgbDIgPSBsZW5ndGggczIgaW5cbiAgbGV0IHIgPSBjcmVhdGUgKGwxICsgbDIpIGluXG4gIHVuc2FmZV9ibGl0IHMxIDAgciAwIGwxO1xuICB1bnNhZmVfYmxpdCBzMiAwIHIgbDEgbDI7XG4gIHJcblxuXG5leHRlcm5hbCBjaGFyX2NvZGU6IGNoYXIgLT4gaW50ID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgY2hhcl9jaHI6IGludCAtPiBjaGFyID0gXCIlaWRlbnRpdHlcIlxuXG5sZXQgaXNfc3BhY2UgPSBmdW5jdGlvblxuICB8ICcgJyB8ICdcXDAxMicgfCAnXFxuJyB8ICdcXHInIHwgJ1xcdCcgLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2VcblxubGV0IHRyaW0gcyA9XG4gIGxldCBsZW4gPSBsZW5ndGggcyBpblxuICBsZXQgaSA9IHJlZiAwIGluXG4gIHdoaWxlICFpIDwgbGVuICYmIGlzX3NwYWNlICh1bnNhZmVfZ2V0IHMgIWkpIGRvXG4gICAgaW5jciBpXG4gIGRvbmU7XG4gIGxldCBqID0gcmVmIChsZW4gLSAxKSBpblxuICB3aGlsZSAhaiA+PSAhaSAmJiBpc19zcGFjZSAodW5zYWZlX2dldCBzICFqKSBkb1xuICAgIGRlY3IgalxuICBkb25lO1xuICBpZiAhaiA+PSAhaSB0aGVuXG4gICAgc3ViIHMgIWkgKCFqIC0gIWkgKyAxKVxuICBlbHNlXG4gICAgZW1wdHlcblxubGV0IGVzY2FwZWQgcyA9XG4gIGxldCBuID0gcmVmIDAgaW5cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCBzIC0gMSBkb1xuICAgIG4gOj0gIW4gK1xuICAgICAgKG1hdGNoIHVuc2FmZV9nZXQgcyBpIHdpdGhcbiAgICAgICB8ICdcXFwiJyB8ICdcXFxcJyB8ICdcXG4nIHwgJ1xcdCcgfCAnXFxyJyB8ICdcXGInIC0+IDJcbiAgICAgICB8ICcgJyAuLiAnficgLT4gMVxuICAgICAgIHwgXyAtPiA0KVxuICBkb25lO1xuICBpZiAhbiA9IGxlbmd0aCBzIHRoZW4gY29weSBzIGVsc2UgYmVnaW5cbiAgICBsZXQgcycgPSBjcmVhdGUgIW4gaW5cbiAgICBuIDo9IDA7XG4gICAgZm9yIGkgPSAwIHRvIGxlbmd0aCBzIC0gMSBkb1xuICAgICAgYmVnaW4gbWF0Y2ggdW5zYWZlX2dldCBzIGkgd2l0aFxuICAgICAgfCAoJ1xcXCInIHwgJ1xcXFwnKSBhcyBjIC0+XG4gICAgICAgICAgdW5zYWZlX3NldCBzJyAhbiAnXFxcXCc7IGluY3IgbjsgdW5zYWZlX3NldCBzJyAhbiBjXG4gICAgICB8ICdcXG4nIC0+XG4gICAgICAgICAgdW5zYWZlX3NldCBzJyAhbiAnXFxcXCc7IGluY3IgbjsgdW5zYWZlX3NldCBzJyAhbiAnbidcbiAgICAgIHwgJ1xcdCcgLT5cbiAgICAgICAgICB1bnNhZmVfc2V0IHMnICFuICdcXFxcJzsgaW5jciBuOyB1bnNhZmVfc2V0IHMnICFuICd0J1xuICAgICAgfCAnXFxyJyAtPlxuICAgICAgICAgIHVuc2FmZV9zZXQgcycgIW4gJ1xcXFwnOyBpbmNyIG47IHVuc2FmZV9zZXQgcycgIW4gJ3InXG4gICAgICB8ICdcXGInIC0+XG4gICAgICAgICAgdW5zYWZlX3NldCBzJyAhbiAnXFxcXCc7IGluY3IgbjsgdW5zYWZlX3NldCBzJyAhbiAnYidcbiAgICAgIHwgKCcgJyAuLiAnficpIGFzIGMgLT4gdW5zYWZlX3NldCBzJyAhbiBjXG4gICAgICB8IGMgLT5cbiAgICAgICAgICBsZXQgYSA9IGNoYXJfY29kZSBjIGluXG4gICAgICAgICAgdW5zYWZlX3NldCBzJyAhbiAnXFxcXCc7XG4gICAgICAgICAgaW5jciBuO1xuICAgICAgICAgIHVuc2FmZV9zZXQgcycgIW4gKGNoYXJfY2hyICg0OCArIGEgLyAxMDApKTtcbiAgICAgICAgICBpbmNyIG47XG4gICAgICAgICAgdW5zYWZlX3NldCBzJyAhbiAoY2hhcl9jaHIgKDQ4ICsgKGEgLyAxMCkgbW9kIDEwKSk7XG4gICAgICAgICAgaW5jciBuO1xuICAgICAgICAgIHVuc2FmZV9zZXQgcycgIW4gKGNoYXJfY2hyICg0OCArIGEgbW9kIDEwKSk7XG4gICAgICBlbmQ7XG4gICAgICBpbmNyIG5cbiAgICBkb25lO1xuICAgIHMnXG4gIGVuZFxuXG5sZXQgbWFwIGYgcyA9XG4gIGxldCBsID0gbGVuZ3RoIHMgaW5cbiAgaWYgbCA9IDAgdGhlbiBzIGVsc2UgYmVnaW5cbiAgICBsZXQgciA9IGNyZWF0ZSBsIGluXG4gICAgZm9yIGkgPSAwIHRvIGwgLSAxIGRvIHVuc2FmZV9zZXQgciBpIChmICh1bnNhZmVfZ2V0IHMgaSkpIGRvbmU7XG4gICAgclxuICBlbmRcblxubGV0IG1hcGkgZiBzID1cbiAgbGV0IGwgPSBsZW5ndGggcyBpblxuICBpZiBsID0gMCB0aGVuIHMgZWxzZSBiZWdpblxuICAgIGxldCByID0gY3JlYXRlIGwgaW5cbiAgICBmb3IgaSA9IDAgdG8gbCAtIDEgZG8gdW5zYWZlX3NldCByIGkgKGYgaSAodW5zYWZlX2dldCBzIGkpKSBkb25lO1xuICAgIHJcbiAgZW5kXG5cbmxldCB1cHBlcmNhc2VfYXNjaWkgcyA9IG1hcCBDaGFyLnVwcGVyY2FzZV9hc2NpaSBzXG5sZXQgbG93ZXJjYXNlX2FzY2lpIHMgPSBtYXAgQ2hhci5sb3dlcmNhc2VfYXNjaWkgc1xuXG5sZXQgYXBwbHkxIGYgcyA9XG4gIGlmIGxlbmd0aCBzID0gMCB0aGVuIHMgZWxzZSBiZWdpblxuICAgIGxldCByID0gY29weSBzIGluXG4gICAgdW5zYWZlX3NldCByIDAgKGYodW5zYWZlX2dldCBzIDApKTtcbiAgICByXG4gIGVuZFxuXG5sZXQgY2FwaXRhbGl6ZV9hc2NpaSBzID0gYXBwbHkxIENoYXIudXBwZXJjYXNlX2FzY2lpIHNcbmxldCB1bmNhcGl0YWxpemVfYXNjaWkgcyA9IGFwcGx5MSBDaGFyLmxvd2VyY2FzZV9hc2NpaSBzXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgcmVjIGluZGV4X3JlYyBzIGxpbSBpIGMgPVxuICBpZiBpID49IGxpbSB0aGVuIHJhaXNlIE5vdF9mb3VuZCBlbHNlXG4gIGlmIHVuc2FmZV9nZXQgcyBpID0gYyB0aGVuIGkgZWxzZSBpbmRleF9yZWMgcyBsaW0gKGkgKyAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgaW5kZXggcyBjID0gaW5kZXhfcmVjIHMgKGxlbmd0aCBzKSAwIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCByZWMgaW5kZXhfcmVjX29wdCBzIGxpbSBpIGMgPVxuICBpZiBpID49IGxpbSB0aGVuIE5vbmUgZWxzZVxuICBpZiB1bnNhZmVfZ2V0IHMgaSA9IGMgdGhlbiBTb21lIGkgZWxzZSBpbmRleF9yZWNfb3B0IHMgbGltIChpICsgMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IGluZGV4X29wdCBzIGMgPSBpbmRleF9yZWNfb3B0IHMgKGxlbmd0aCBzKSAwIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCBpbmRleF9mcm9tIHMgaSBjID1cbiAgbGV0IGwgPSBsZW5ndGggcyBpblxuICBpZiBpIDwgMCB8fCBpID4gbCB0aGVuIGludmFsaWRfYXJnIFwiU3RyaW5nLmluZGV4X2Zyb20gLyBCeXRlcy5pbmRleF9mcm9tXCIgZWxzZVxuICBpbmRleF9yZWMgcyBsIGkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IGluZGV4X2Zyb21fb3B0IHMgaSBjID1cbiAgbGV0IGwgPSBsZW5ndGggcyBpblxuICBpZiBpIDwgMCB8fCBpID4gbCB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJTdHJpbmcuaW5kZXhfZnJvbV9vcHQgLyBCeXRlcy5pbmRleF9mcm9tX29wdFwiXG4gIGVsc2VcbiAgICBpbmRleF9yZWNfb3B0IHMgbCBpIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCByZWMgcmluZGV4X3JlYyBzIGkgYyA9XG4gIGlmIGkgPCAwIHRoZW4gcmFpc2UgTm90X2ZvdW5kIGVsc2VcbiAgaWYgdW5zYWZlX2dldCBzIGkgPSBjIHRoZW4gaSBlbHNlIHJpbmRleF9yZWMgcyAoaSAtIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCByaW5kZXggcyBjID0gcmluZGV4X3JlYyBzIChsZW5ndGggcyAtIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCByaW5kZXhfZnJvbSBzIGkgYyA9XG4gIGlmIGkgPCAtMSB8fCBpID49IGxlbmd0aCBzIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIlN0cmluZy5yaW5kZXhfZnJvbSAvIEJ5dGVzLnJpbmRleF9mcm9tXCJcbiAgZWxzZVxuICAgIHJpbmRleF9yZWMgcyBpIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCByZWMgcmluZGV4X3JlY19vcHQgcyBpIGMgPVxuICBpZiBpIDwgMCB0aGVuIE5vbmUgZWxzZVxuICBpZiB1bnNhZmVfZ2V0IHMgaSA9IGMgdGhlbiBTb21lIGkgZWxzZSByaW5kZXhfcmVjX29wdCBzIChpIC0gMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IHJpbmRleF9vcHQgcyBjID0gcmluZGV4X3JlY19vcHQgcyAobGVuZ3RoIHMgLSAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgcmluZGV4X2Zyb21fb3B0IHMgaSBjID1cbiAgaWYgaSA8IC0xIHx8IGkgPj0gbGVuZ3RoIHMgdGhlblxuICAgIGludmFsaWRfYXJnIFwiU3RyaW5nLnJpbmRleF9mcm9tX29wdCAvIEJ5dGVzLnJpbmRleF9mcm9tX29wdFwiXG4gIGVsc2VcbiAgICByaW5kZXhfcmVjX29wdCBzIGkgY1xuXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgY29udGFpbnNfZnJvbSBzIGkgYyA9XG4gIGxldCBsID0gbGVuZ3RoIHMgaW5cbiAgaWYgaSA8IDAgfHwgaSA+IGwgdGhlblxuICAgIGludmFsaWRfYXJnIFwiU3RyaW5nLmNvbnRhaW5zX2Zyb20gLyBCeXRlcy5jb250YWluc19mcm9tXCJcbiAgZWxzZVxuICAgIHRyeSBpZ25vcmUgKGluZGV4X3JlYyBzIGwgaSBjKTsgdHJ1ZSB3aXRoIE5vdF9mb3VuZCAtPiBmYWxzZVxuXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgY29udGFpbnMgcyBjID0gY29udGFpbnNfZnJvbSBzIDAgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IHJjb250YWluc19mcm9tIHMgaSBjID1cbiAgaWYgaSA8IDAgfHwgaSA+PSBsZW5ndGggcyB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJTdHJpbmcucmNvbnRhaW5zX2Zyb20gLyBCeXRlcy5yY29udGFpbnNfZnJvbVwiXG4gIGVsc2VcbiAgICB0cnkgaWdub3JlIChyaW5kZXhfcmVjIHMgaSBjKTsgdHJ1ZSB3aXRoIE5vdF9mb3VuZCAtPiBmYWxzZVxuXG5cbnR5cGUgdCA9IGJ5dGVzXG5cbmxldCBjb21wYXJlICh4OiB0KSAoeTogdCkgPSBTdGRsaWIuY29tcGFyZSB4IHlcbmV4dGVybmFsIGVxdWFsIDogdCAtPiB0IC0+IGJvb2wgPSBcImNhbWxfYnl0ZXNfZXF1YWxcIiBbQEBub2FsbG9jXVxuXG4oKiBEZXByZWNhdGVkIGZ1bmN0aW9ucyBpbXBsZW1lbnRlZCB2aWEgb3RoZXIgZGVwcmVjYXRlZCBmdW5jdGlvbnMgKilcbltAQEBvY2FtbC53YXJuaW5nIFwiLTNcIl1cbmxldCB1cHBlcmNhc2UgcyA9IG1hcCBDaGFyLnVwcGVyY2FzZSBzXG5sZXQgbG93ZXJjYXNlIHMgPSBtYXAgQ2hhci5sb3dlcmNhc2Ugc1xuXG5sZXQgY2FwaXRhbGl6ZSBzID0gYXBwbHkxIENoYXIudXBwZXJjYXNlIHNcbmxldCB1bmNhcGl0YWxpemUgcyA9IGFwcGx5MSBDaGFyLmxvd2VyY2FzZSBzXG5cbigqKiB7MSBJdGVyYXRvcnN9ICopXG5cbmxldCB0b19zZXEgcyA9XG4gIGxldCByZWMgYXV4IGkgKCkgPVxuICAgIGlmIGkgPSBsZW5ndGggcyB0aGVuIFNlcS5OaWxcbiAgICBlbHNlXG4gICAgICBsZXQgeCA9IGdldCBzIGkgaW5cbiAgICAgIFNlcS5Db25zICh4LCBhdXggKGkrMSkpXG4gIGluXG4gIGF1eCAwXG5cbmxldCB0b19zZXFpIHMgPVxuICBsZXQgcmVjIGF1eCBpICgpID1cbiAgICBpZiBpID0gbGVuZ3RoIHMgdGhlbiBTZXEuTmlsXG4gICAgZWxzZVxuICAgICAgbGV0IHggPSBnZXQgcyBpIGluXG4gICAgICBTZXEuQ29ucyAoKGkseCksIGF1eCAoaSsxKSlcbiAgaW5cbiAgYXV4IDBcblxubGV0IG9mX3NlcSBpID1cbiAgbGV0IG4gPSByZWYgMCBpblxuICBsZXQgYnVmID0gcmVmIChtYWtlIDI1NiAnXFwwMDAnKSBpblxuICBsZXQgcmVzaXplICgpID1cbiAgICAoKiByZXNpemUgKilcbiAgICBsZXQgbmV3X2xlbiA9IG1pbiAoMiAqIGxlbmd0aCAhYnVmKSBTeXMubWF4X3N0cmluZ19sZW5ndGggaW5cbiAgICBpZiBsZW5ndGggIWJ1ZiA9IG5ld19sZW4gdGhlbiBmYWlsd2l0aCBcIkJ5dGVzLm9mX3NlcTogY2Fubm90IGdyb3cgYnl0ZXNcIjtcbiAgICBsZXQgbmV3X2J1ZiA9IG1ha2UgbmV3X2xlbiAnXFwwMDAnIGluXG4gICAgYmxpdCAhYnVmIDAgbmV3X2J1ZiAwICFuO1xuICAgIGJ1ZiA6PSBuZXdfYnVmXG4gIGluXG4gIFNlcS5pdGVyXG4gICAgKGZ1biBjIC0+XG4gICAgICAgaWYgIW4gPSBsZW5ndGggIWJ1ZiB0aGVuIHJlc2l6ZSgpO1xuICAgICAgIHNldCAhYnVmICFuIGM7XG4gICAgICAgaW5jciBuKVxuICAgIGk7XG4gIHN1YiAhYnVmIDAgIW5cblxuKCoqIHs2IEJpbmFyeSBlbmNvZGluZy9kZWNvZGluZyBvZiBpbnRlZ2Vyc30gKilcblxuZXh0ZXJuYWwgZ2V0X3VpbnQ4IDogYnl0ZXMgLT4gaW50IC0+IGludCA9IFwiJWJ5dGVzX3NhZmVfZ2V0XCJcbmV4dGVybmFsIGdldF91aW50MTZfbmUgOiBieXRlcyAtPiBpbnQgLT4gaW50ID0gXCIlY2FtbF9ieXRlc19nZXQxNlwiXG5leHRlcm5hbCBnZXRfaW50MzJfbmUgOiBieXRlcyAtPiBpbnQgLT4gaW50MzIgPSBcIiVjYW1sX2J5dGVzX2dldDMyXCJcbmV4dGVybmFsIGdldF9pbnQ2NF9uZSA6IGJ5dGVzIC0+IGludCAtPiBpbnQ2NCA9IFwiJWNhbWxfYnl0ZXNfZ2V0NjRcIlxuZXh0ZXJuYWwgc2V0X2ludDggOiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IHVuaXQgPSBcIiVieXRlc19zYWZlX3NldFwiXG5leHRlcm5hbCBzZXRfaW50MTZfbmUgOiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IHVuaXQgPSBcIiVjYW1sX2J5dGVzX3NldDE2XCJcbmV4dGVybmFsIHNldF9pbnQzMl9uZSA6IGJ5dGVzIC0+IGludCAtPiBpbnQzMiAtPiB1bml0ID0gXCIlY2FtbF9ieXRlc19zZXQzMlwiXG5leHRlcm5hbCBzZXRfaW50NjRfbmUgOiBieXRlcyAtPiBpbnQgLT4gaW50NjQgLT4gdW5pdCA9IFwiJWNhbWxfYnl0ZXNfc2V0NjRcIlxuZXh0ZXJuYWwgc3dhcDE2IDogaW50IC0+IGludCA9IFwiJWJzd2FwMTZcIlxuZXh0ZXJuYWwgc3dhcDMyIDogaW50MzIgLT4gaW50MzIgPSBcIiVic3dhcF9pbnQzMlwiXG5leHRlcm5hbCBzd2FwNjQgOiBpbnQ2NCAtPiBpbnQ2NCA9IFwiJWJzd2FwX2ludDY0XCJcblxubGV0IGdldF9pbnQ4IGIgaSA9XG4gICgoZ2V0X3VpbnQ4IGIgaSkgbHNsIChTeXMuaW50X3NpemUgLSA4KSkgYXNyIChTeXMuaW50X3NpemUgLSA4KVxuXG5sZXQgZ2V0X3VpbnQxNl9sZSBiIGkgPVxuICBpZiBTeXMuYmlnX2VuZGlhbiB0aGVuIHN3YXAxNiAoZ2V0X3VpbnQxNl9uZSBiIGkpXG4gIGVsc2UgZ2V0X3VpbnQxNl9uZSBiIGlcblxubGV0IGdldF91aW50MTZfYmUgYiBpID1cbiAgaWYgbm90IFN5cy5iaWdfZW5kaWFuIHRoZW4gc3dhcDE2IChnZXRfdWludDE2X25lIGIgaSlcbiAgZWxzZSBnZXRfdWludDE2X25lIGIgaVxuXG5sZXQgZ2V0X2ludDE2X25lIGIgaSA9XG4gICgoZ2V0X3VpbnQxNl9uZSBiIGkpIGxzbCAoU3lzLmludF9zaXplIC0gMTYpKSBhc3IgKFN5cy5pbnRfc2l6ZSAtIDE2KVxuXG5sZXQgZ2V0X2ludDE2X2xlIGIgaSA9XG4gICgoZ2V0X3VpbnQxNl9sZSBiIGkpIGxzbCAoU3lzLmludF9zaXplIC0gMTYpKSBhc3IgKFN5cy5pbnRfc2l6ZSAtIDE2KVxuXG5sZXQgZ2V0X2ludDE2X2JlIGIgaSA9XG4gICgoZ2V0X3VpbnQxNl9iZSBiIGkpIGxzbCAoU3lzLmludF9zaXplIC0gMTYpKSBhc3IgKFN5cy5pbnRfc2l6ZSAtIDE2KVxuXG5sZXQgZ2V0X2ludDMyX2xlIGIgaSA9XG4gIGlmIFN5cy5iaWdfZW5kaWFuIHRoZW4gc3dhcDMyIChnZXRfaW50MzJfbmUgYiBpKVxuICBlbHNlIGdldF9pbnQzMl9uZSBiIGlcblxubGV0IGdldF9pbnQzMl9iZSBiIGkgPVxuICBpZiBub3QgU3lzLmJpZ19lbmRpYW4gdGhlbiBzd2FwMzIgKGdldF9pbnQzMl9uZSBiIGkpXG4gIGVsc2UgZ2V0X2ludDMyX25lIGIgaVxuXG5sZXQgZ2V0X2ludDY0X2xlIGIgaSA9XG4gIGlmIFN5cy5iaWdfZW5kaWFuIHRoZW4gc3dhcDY0IChnZXRfaW50NjRfbmUgYiBpKVxuICBlbHNlIGdldF9pbnQ2NF9uZSBiIGlcblxubGV0IGdldF9pbnQ2NF9iZSBiIGkgPVxuICBpZiBub3QgU3lzLmJpZ19lbmRpYW4gdGhlbiBzd2FwNjQgKGdldF9pbnQ2NF9uZSBiIGkpXG4gIGVsc2UgZ2V0X2ludDY0X25lIGIgaVxuXG5sZXQgc2V0X2ludDE2X2xlIGIgaSB4ID1cbiAgaWYgU3lzLmJpZ19lbmRpYW4gdGhlbiBzZXRfaW50MTZfbmUgYiBpIChzd2FwMTYgeClcbiAgZWxzZSBzZXRfaW50MTZfbmUgYiBpIHhcblxubGV0IHNldF9pbnQxNl9iZSBiIGkgeCA9XG4gIGlmIG5vdCBTeXMuYmlnX2VuZGlhbiB0aGVuIHNldF9pbnQxNl9uZSBiIGkgKHN3YXAxNiB4KVxuICBlbHNlIHNldF9pbnQxNl9uZSBiIGkgeFxuXG5sZXQgc2V0X2ludDMyX2xlIGIgaSB4ID1cbiAgaWYgU3lzLmJpZ19lbmRpYW4gdGhlbiBzZXRfaW50MzJfbmUgYiBpIChzd2FwMzIgeClcbiAgZWxzZSBzZXRfaW50MzJfbmUgYiBpIHhcblxubGV0IHNldF9pbnQzMl9iZSBiIGkgeCA9XG4gIGlmIG5vdCBTeXMuYmlnX2VuZGlhbiB0aGVuIHNldF9pbnQzMl9uZSBiIGkgKHN3YXAzMiB4KVxuICBlbHNlIHNldF9pbnQzMl9uZSBiIGkgeFxuXG5sZXQgc2V0X2ludDY0X2xlIGIgaSB4ID1cbiAgaWYgU3lzLmJpZ19lbmRpYW4gdGhlbiBzZXRfaW50NjRfbmUgYiBpIChzd2FwNjQgeClcbiAgZWxzZSBzZXRfaW50NjRfbmUgYiBpIHhcblxubGV0IHNldF9pbnQ2NF9iZSBiIGkgeCA9XG4gIGlmIG5vdCBTeXMuYmlnX2VuZGlhbiB0aGVuIHNldF9pbnQ2NF9uZSBiIGkgKHN3YXA2NCB4KVxuICBlbHNlIHNldF9pbnQ2NF9uZSBiIGkgeFxuXG5sZXQgc2V0X3VpbnQ4ID0gc2V0X2ludDhcbmxldCBzZXRfdWludDE2X25lID0gc2V0X2ludDE2X25lXG5sZXQgc2V0X3VpbnQxNl9iZSA9IHNldF9pbnQxNl9iZVxubGV0IHNldF91aW50MTZfbGUgPSBzZXRfaW50MTZfbGVcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICBEYW1pZW4gRG9saWdleiwgcHJvamV0IEdhbGxpdW0sIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMTQgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogU3RyaW5nIG9wZXJhdGlvbnMsIGJhc2VkIG9uIGJ5dGUgc2VxdWVuY2Ugb3BlcmF0aW9ucyAqKVxuXG4oKiBXQVJOSU5HOiBTb21lIGZ1bmN0aW9ucyBpbiB0aGlzIGZpbGUgYXJlIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgZm9yXG4gICBlZmZpY2llbmN5IHJlYXNvbnMuIFdoZW4geW91IG1vZGlmeSB0aGUgb25lIGluIHRoaXMgZmlsZSB5b3UgbmVlZCB0b1xuICAgbW9kaWZ5IGl0cyBkdXBsaWNhdGUgaW4gYnl0ZXMubWwuXG4gICBUaGVzZSBmdW5jdGlvbnMgaGF2ZSBhIFwiZHVwbGljYXRlZFwiIGNvbW1lbnQgYWJvdmUgdGhlaXIgZGVmaW5pdGlvbi5cbiopXG5cbmV4dGVybmFsIGxlbmd0aCA6IHN0cmluZyAtPiBpbnQgPSBcIiVzdHJpbmdfbGVuZ3RoXCJcbmV4dGVybmFsIGdldCA6IHN0cmluZyAtPiBpbnQgLT4gY2hhciA9IFwiJXN0cmluZ19zYWZlX2dldFwiXG5leHRlcm5hbCBzZXQgOiBieXRlcyAtPiBpbnQgLT4gY2hhciAtPiB1bml0ID0gXCIlc3RyaW5nX3NhZmVfc2V0XCJcbmV4dGVybmFsIGNyZWF0ZSA6IGludCAtPiBieXRlcyA9IFwiY2FtbF9jcmVhdGVfc3RyaW5nXCJcbmV4dGVybmFsIHVuc2FmZV9nZXQgOiBzdHJpbmcgLT4gaW50IC0+IGNoYXIgPSBcIiVzdHJpbmdfdW5zYWZlX2dldFwiXG5leHRlcm5hbCB1bnNhZmVfc2V0IDogYnl0ZXMgLT4gaW50IC0+IGNoYXIgLT4gdW5pdCA9IFwiJXN0cmluZ191bnNhZmVfc2V0XCJcbmV4dGVybmFsIHVuc2FmZV9ibGl0IDogc3RyaW5nIC0+IGludCAtPiAgYnl0ZXMgLT4gaW50IC0+IGludCAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9ibGl0X3N0cmluZ1wiIFtAQG5vYWxsb2NdXG5leHRlcm5hbCB1bnNhZmVfZmlsbCA6IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gY2hhciAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9maWxsX3N0cmluZ1wiIFtAQG5vYWxsb2NdXG5cbm1vZHVsZSBCID0gQnl0ZXNcblxubGV0IGJ0cyA9IEIudW5zYWZlX3RvX3N0cmluZ1xubGV0IGJvcyA9IEIudW5zYWZlX29mX3N0cmluZ1xuXG5sZXQgbWFrZSBuIGMgPVxuICBCLm1ha2UgbiBjIHw+IGJ0c1xubGV0IGluaXQgbiBmID1cbiAgQi5pbml0IG4gZiB8PiBidHNcbmxldCBjb3B5IHMgPVxuICBCLmNvcHkgKGJvcyBzKSB8PiBidHNcbmxldCBzdWIgcyBvZnMgbGVuID1cbiAgQi5zdWIgKGJvcyBzKSBvZnMgbGVuIHw+IGJ0c1xubGV0IGZpbGwgPVxuICBCLmZpbGxcbmxldCBibGl0ID1cbiAgQi5ibGl0X3N0cmluZ1xuXG5sZXQgZW5zdXJlX2dlICh4OmludCkgeSA9IGlmIHggPj0geSB0aGVuIHggZWxzZSBpbnZhbGlkX2FyZyBcIlN0cmluZy5jb25jYXRcIlxuXG5sZXQgcmVjIHN1bV9sZW5ndGhzIGFjYyBzZXBsZW4gPSBmdW5jdGlvblxuICB8IFtdIC0+IGFjY1xuICB8IGhkIDo6IFtdIC0+IGxlbmd0aCBoZCArIGFjY1xuICB8IGhkIDo6IHRsIC0+IHN1bV9sZW5ndGhzIChlbnN1cmVfZ2UgKGxlbmd0aCBoZCArIHNlcGxlbiArIGFjYykgYWNjKSBzZXBsZW4gdGxcblxubGV0IHJlYyB1bnNhZmVfYmxpdHMgZHN0IHBvcyBzZXAgc2VwbGVuID0gZnVuY3Rpb25cbiAgICBbXSAtPiBkc3RcbiAgfCBoZCA6OiBbXSAtPlxuICAgIHVuc2FmZV9ibGl0IGhkIDAgZHN0IHBvcyAobGVuZ3RoIGhkKTsgZHN0XG4gIHwgaGQgOjogdGwgLT5cbiAgICB1bnNhZmVfYmxpdCBoZCAwIGRzdCBwb3MgKGxlbmd0aCBoZCk7XG4gICAgdW5zYWZlX2JsaXQgc2VwIDAgZHN0IChwb3MgKyBsZW5ndGggaGQpIHNlcGxlbjtcbiAgICB1bnNhZmVfYmxpdHMgZHN0IChwb3MgKyBsZW5ndGggaGQgKyBzZXBsZW4pIHNlcCBzZXBsZW4gdGxcblxubGV0IGNvbmNhdCBzZXAgPSBmdW5jdGlvblxuICAgIFtdIC0+IFwiXCJcbiAgfCBsIC0+IGxldCBzZXBsZW4gPSBsZW5ndGggc2VwIGluIGJ0cyBAQFxuICAgICAgICAgIHVuc2FmZV9ibGl0c1xuICAgICAgICAgICAgKEIuY3JlYXRlIChzdW1fbGVuZ3RocyAwIHNlcGxlbiBsKSlcbiAgICAgICAgICAgIDAgc2VwIHNlcGxlbiBsXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCBpdGVyIGYgcyA9XG4gIGZvciBpID0gMCB0byBsZW5ndGggcyAtIDEgZG8gZiAodW5zYWZlX2dldCBzIGkpIGRvbmVcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IGl0ZXJpIGYgcyA9XG4gIGZvciBpID0gMCB0byBsZW5ndGggcyAtIDEgZG8gZiBpICh1bnNhZmVfZ2V0IHMgaSkgZG9uZVxuXG5sZXQgbWFwIGYgcyA9XG4gIEIubWFwIGYgKGJvcyBzKSB8PiBidHNcbmxldCBtYXBpIGYgcyA9XG4gIEIubWFwaSBmIChib3MgcykgfD4gYnRzXG5cbigqIEJld2FyZTogd2UgY2Fubm90IHVzZSBCLnRyaW0gb3IgQi5lc2NhcGUgYmVjYXVzZSB0aGV5IGFsd2F5cyBtYWtlIGFcbiAgIGNvcHksIGJ1dCBTdHJpbmcubWxpIHNwZWxscyBvdXQgc29tZSBjYXNlcyB3aGVyZSB3ZSBhcmUgbm90IGFsbG93ZWRcbiAgIHRvIG1ha2UgYSBjb3B5LiAqKVxuXG5sZXQgaXNfc3BhY2UgPSBmdW5jdGlvblxuICB8ICcgJyB8ICdcXDAxMicgfCAnXFxuJyB8ICdcXHInIHwgJ1xcdCcgLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2VcblxubGV0IHRyaW0gcyA9XG4gIGlmIHMgPSBcIlwiIHRoZW4gc1xuICBlbHNlIGlmIGlzX3NwYWNlICh1bnNhZmVfZ2V0IHMgMCkgfHwgaXNfc3BhY2UgKHVuc2FmZV9nZXQgcyAobGVuZ3RoIHMgLSAxKSlcbiAgICB0aGVuIGJ0cyAoQi50cmltIChib3MgcykpXG4gIGVsc2Ugc1xuXG5sZXQgZXNjYXBlZCBzID1cbiAgbGV0IHJlYyBlc2NhcGVfaWZfbmVlZGVkIHMgbiBpID1cbiAgICBpZiBpID49IG4gdGhlbiBzIGVsc2VcbiAgICAgIG1hdGNoIHVuc2FmZV9nZXQgcyBpIHdpdGhcbiAgICAgIHwgJ1xcXCInIHwgJ1xcXFwnIHwgJ1xcMDAwJy4uJ1xcMDMxJyB8ICdcXDEyNycuLiAnXFwyNTUnIC0+XG4gICAgICAgICAgYnRzIChCLmVzY2FwZWQgKGJvcyBzKSlcbiAgICAgIHwgXyAtPiBlc2NhcGVfaWZfbmVlZGVkIHMgbiAoaSsxKVxuICBpblxuICBlc2NhcGVfaWZfbmVlZGVkIHMgKGxlbmd0aCBzKSAwXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCByZWMgaW5kZXhfcmVjIHMgbGltIGkgYyA9XG4gIGlmIGkgPj0gbGltIHRoZW4gcmFpc2UgTm90X2ZvdW5kIGVsc2VcbiAgaWYgdW5zYWZlX2dldCBzIGkgPSBjIHRoZW4gaSBlbHNlIGluZGV4X3JlYyBzIGxpbSAoaSArIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IGluZGV4IHMgYyA9IGluZGV4X3JlYyBzIChsZW5ndGggcykgMCBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCByZWMgaW5kZXhfcmVjX29wdCBzIGxpbSBpIGMgPVxuICBpZiBpID49IGxpbSB0aGVuIE5vbmUgZWxzZVxuICBpZiB1bnNhZmVfZ2V0IHMgaSA9IGMgdGhlbiBTb21lIGkgZWxzZSBpbmRleF9yZWNfb3B0IHMgbGltIChpICsgMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgaW5kZXhfb3B0IHMgYyA9IGluZGV4X3JlY19vcHQgcyAobGVuZ3RoIHMpIDAgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgaW5kZXhfZnJvbSBzIGkgYyA9XG4gIGxldCBsID0gbGVuZ3RoIHMgaW5cbiAgaWYgaSA8IDAgfHwgaSA+IGwgdGhlbiBpbnZhbGlkX2FyZyBcIlN0cmluZy5pbmRleF9mcm9tIC8gQnl0ZXMuaW5kZXhfZnJvbVwiIGVsc2VcbiAgICBpbmRleF9yZWMgcyBsIGkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgaW5kZXhfZnJvbV9vcHQgcyBpIGMgPVxuICBsZXQgbCA9IGxlbmd0aCBzIGluXG4gIGlmIGkgPCAwIHx8IGkgPiBsIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIlN0cmluZy5pbmRleF9mcm9tX29wdCAvIEJ5dGVzLmluZGV4X2Zyb21fb3B0XCJcbiAgZWxzZVxuICAgIGluZGV4X3JlY19vcHQgcyBsIGkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgcmVjIHJpbmRleF9yZWMgcyBpIGMgPVxuICBpZiBpIDwgMCB0aGVuIHJhaXNlIE5vdF9mb3VuZCBlbHNlXG4gIGlmIHVuc2FmZV9nZXQgcyBpID0gYyB0aGVuIGkgZWxzZSByaW5kZXhfcmVjIHMgKGkgLSAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCByaW5kZXggcyBjID0gcmluZGV4X3JlYyBzIChsZW5ndGggcyAtIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IHJpbmRleF9mcm9tIHMgaSBjID1cbiAgaWYgaSA8IC0xIHx8IGkgPj0gbGVuZ3RoIHMgdGhlblxuICAgIGludmFsaWRfYXJnIFwiU3RyaW5nLnJpbmRleF9mcm9tIC8gQnl0ZXMucmluZGV4X2Zyb21cIlxuICBlbHNlXG4gICAgcmluZGV4X3JlYyBzIGkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgcmVjIHJpbmRleF9yZWNfb3B0IHMgaSBjID1cbiAgaWYgaSA8IDAgdGhlbiBOb25lIGVsc2VcbiAgaWYgdW5zYWZlX2dldCBzIGkgPSBjIHRoZW4gU29tZSBpIGVsc2UgcmluZGV4X3JlY19vcHQgcyAoaSAtIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IHJpbmRleF9vcHQgcyBjID0gcmluZGV4X3JlY19vcHQgcyAobGVuZ3RoIHMgLSAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCByaW5kZXhfZnJvbV9vcHQgcyBpIGMgPVxuICBpZiBpIDwgLTEgfHwgaSA+PSBsZW5ndGggcyB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJTdHJpbmcucmluZGV4X2Zyb21fb3B0IC8gQnl0ZXMucmluZGV4X2Zyb21fb3B0XCJcbiAgZWxzZVxuICAgIHJpbmRleF9yZWNfb3B0IHMgaSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCBjb250YWluc19mcm9tIHMgaSBjID1cbiAgbGV0IGwgPSBsZW5ndGggcyBpblxuICBpZiBpIDwgMCB8fCBpID4gbCB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJTdHJpbmcuY29udGFpbnNfZnJvbSAvIEJ5dGVzLmNvbnRhaW5zX2Zyb21cIlxuICBlbHNlXG4gICAgdHJ5IGlnbm9yZSAoaW5kZXhfcmVjIHMgbCBpIGMpOyB0cnVlIHdpdGggTm90X2ZvdW5kIC0+IGZhbHNlXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCBjb250YWlucyBzIGMgPSBjb250YWluc19mcm9tIHMgMCBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCByY29udGFpbnNfZnJvbSBzIGkgYyA9XG4gIGlmIGkgPCAwIHx8IGkgPj0gbGVuZ3RoIHMgdGhlblxuICAgIGludmFsaWRfYXJnIFwiU3RyaW5nLnJjb250YWluc19mcm9tIC8gQnl0ZXMucmNvbnRhaW5zX2Zyb21cIlxuICBlbHNlXG4gICAgdHJ5IGlnbm9yZSAocmluZGV4X3JlYyBzIGkgYyk7IHRydWUgd2l0aCBOb3RfZm91bmQgLT4gZmFsc2VcblxubGV0IHVwcGVyY2FzZV9hc2NpaSBzID1cbiAgQi51cHBlcmNhc2VfYXNjaWkgKGJvcyBzKSB8PiBidHNcbmxldCBsb3dlcmNhc2VfYXNjaWkgcyA9XG4gIEIubG93ZXJjYXNlX2FzY2lpIChib3MgcykgfD4gYnRzXG5sZXQgY2FwaXRhbGl6ZV9hc2NpaSBzID1cbiAgQi5jYXBpdGFsaXplX2FzY2lpIChib3MgcykgfD4gYnRzXG5sZXQgdW5jYXBpdGFsaXplX2FzY2lpIHMgPVxuICBCLnVuY2FwaXRhbGl6ZV9hc2NpaSAoYm9zIHMpIHw+IGJ0c1xuXG5sZXQgc3BsaXRfb25fY2hhciBzZXAgcyA9XG4gIGxldCByID0gcmVmIFtdIGluXG4gIGxldCBqID0gcmVmIChsZW5ndGggcykgaW5cbiAgZm9yIGkgPSBsZW5ndGggcyAtIDEgZG93bnRvIDAgZG9cbiAgICBpZiB1bnNhZmVfZ2V0IHMgaSA9IHNlcCB0aGVuIGJlZ2luXG4gICAgICByIDo9IHN1YiBzIChpICsgMSkgKCFqIC0gaSAtIDEpIDo6ICFyO1xuICAgICAgaiA6PSBpXG4gICAgZW5kXG4gIGRvbmU7XG4gIHN1YiBzIDAgIWogOjogIXJcblxuKCogRGVwcmVjYXRlZCBmdW5jdGlvbnMgaW1wbGVtZW50ZWQgdmlhIG90aGVyIGRlcHJlY2F0ZWQgZnVuY3Rpb25zICopXG5bQEBAb2NhbWwud2FybmluZyBcIi0zXCJdXG5sZXQgdXBwZXJjYXNlIHMgPVxuICBCLnVwcGVyY2FzZSAoYm9zIHMpIHw+IGJ0c1xubGV0IGxvd2VyY2FzZSBzID1cbiAgQi5sb3dlcmNhc2UgKGJvcyBzKSB8PiBidHNcbmxldCBjYXBpdGFsaXplIHMgPVxuICBCLmNhcGl0YWxpemUgKGJvcyBzKSB8PiBidHNcbmxldCB1bmNhcGl0YWxpemUgcyA9XG4gIEIudW5jYXBpdGFsaXplIChib3MgcykgfD4gYnRzXG5cbnR5cGUgdCA9IHN0cmluZ1xuXG5sZXQgY29tcGFyZSAoeDogdCkgKHk6IHQpID0gU3RkbGliLmNvbXBhcmUgeCB5XG5leHRlcm5hbCBlcXVhbCA6IHN0cmluZyAtPiBzdHJpbmcgLT4gYm9vbCA9IFwiY2FtbF9zdHJpbmdfZXF1YWxcIiBbQEBub2FsbG9jXVxuXG4oKiogezEgSXRlcmF0b3JzfSAqKVxuXG5sZXQgdG9fc2VxIHMgPSBib3MgcyB8PiBCLnRvX3NlcVxuXG5sZXQgdG9fc2VxaSBzID0gYm9zIHMgfD4gQi50b19zZXFpXG5cbmxldCBvZl9zZXEgZyA9IEIub2Zfc2VxIGcgfD4gYnRzXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgT0NhbWwgcHJvZ3JhbW1lcnMgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE4IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUgdCA9IHVuaXQgPSAoKVxuXG5sZXQgZXF1YWwgKCkgKCkgPSB0cnVlXG5sZXQgY29tcGFyZSAoKSAoKSA9IDBcbmxldCB0b19zdHJpbmcgKCkgPSBcIigpXCJcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTcgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxudHlwZSBleHRlcm5fZmxhZ3MgPVxuICAgIE5vX3NoYXJpbmdcbiAgfCBDbG9zdXJlc1xuICB8IENvbXBhdF8zMlxuKCogbm90ZTogdGhpcyB0eXBlIGRlZmluaXRpb24gaXMgdXNlZCBpbiAncnVudGltZS9kZWJ1Z2dlci5jJyAqKVxuXG5leHRlcm5hbCB0b19jaGFubmVsOiBvdXRfY2hhbm5lbCAtPiAnYSAtPiBleHRlcm5fZmxhZ3MgbGlzdCAtPiB1bml0XG4gICAgPSBcImNhbWxfb3V0cHV0X3ZhbHVlXCJcbmV4dGVybmFsIHRvX2J5dGVzOiAnYSAtPiBleHRlcm5fZmxhZ3MgbGlzdCAtPiBieXRlc1xuICAgID0gXCJjYW1sX291dHB1dF92YWx1ZV90b19ieXRlc1wiXG5leHRlcm5hbCB0b19zdHJpbmc6ICdhIC0+IGV4dGVybl9mbGFncyBsaXN0IC0+IHN0cmluZ1xuICAgID0gXCJjYW1sX291dHB1dF92YWx1ZV90b19zdHJpbmdcIlxuZXh0ZXJuYWwgdG9fYnVmZmVyX3Vuc2FmZTpcbiAgICAgIGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gJ2EgLT4gZXh0ZXJuX2ZsYWdzIGxpc3QgLT4gaW50XG4gICAgPSBcImNhbWxfb3V0cHV0X3ZhbHVlX3RvX2J1ZmZlclwiXG5cbmxldCB0b19idWZmZXIgYnVmZiBvZnMgbGVuIHYgZmxhZ3MgPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gQnl0ZXMubGVuZ3RoIGJ1ZmYgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIk1hcnNoYWwudG9fYnVmZmVyOiBzdWJzdHJpbmcgb3V0IG9mIGJvdW5kc1wiXG4gIGVsc2UgdG9fYnVmZmVyX3Vuc2FmZSBidWZmIG9mcyBsZW4gdiBmbGFnc1xuXG4oKiBUaGUgZnVuY3Rpb25zIGJlbG93IHVzZSBieXRlIHNlcXVlbmNlcyBhcyBpbnB1dCwgbmV2ZXIgdXNpbmcgYW55XG4gICBtdXRhdGlvbi4gSXQgbWFrZXMgc2Vuc2UgdG8gdXNlIG5vbi1tdXRhdGVkIFtieXRlc10gcmF0aGVyIHRoYW5cbiAgIFtzdHJpbmddLCBiZWNhdXNlIHdlIHJlYWxseSB3b3JrIHdpdGggc2VxdWVuY2VzIG9mIGJ5dGVzLCBub3RcbiAgIGEgdGV4dCByZXByZXNlbnRhdGlvbi5cbiopXG5cbmV4dGVybmFsIGZyb21fY2hhbm5lbDogaW5fY2hhbm5lbCAtPiAnYSA9IFwiY2FtbF9pbnB1dF92YWx1ZVwiXG5leHRlcm5hbCBmcm9tX2J5dGVzX3Vuc2FmZTogYnl0ZXMgLT4gaW50IC0+ICdhID0gXCJjYW1sX2lucHV0X3ZhbHVlX2Zyb21fYnl0ZXNcIlxuZXh0ZXJuYWwgZGF0YV9zaXplX3Vuc2FmZTogYnl0ZXMgLT4gaW50IC0+IGludCA9IFwiY2FtbF9tYXJzaGFsX2RhdGFfc2l6ZVwiXG5cbmxldCBoZWFkZXJfc2l6ZSA9IDIwXG5sZXQgZGF0YV9zaXplIGJ1ZmYgb2ZzID1cbiAgaWYgb2ZzIDwgMCB8fCBvZnMgPiBCeXRlcy5sZW5ndGggYnVmZiAtIGhlYWRlcl9zaXplXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJNYXJzaGFsLmRhdGFfc2l6ZVwiXG4gIGVsc2UgZGF0YV9zaXplX3Vuc2FmZSBidWZmIG9mc1xubGV0IHRvdGFsX3NpemUgYnVmZiBvZnMgPSBoZWFkZXJfc2l6ZSArIGRhdGFfc2l6ZSBidWZmIG9mc1xuXG5sZXQgZnJvbV9ieXRlcyBidWZmIG9mcyA9XG4gIGlmIG9mcyA8IDAgfHwgb2ZzID4gQnl0ZXMubGVuZ3RoIGJ1ZmYgLSBoZWFkZXJfc2l6ZVxuICB0aGVuIGludmFsaWRfYXJnIFwiTWFyc2hhbC5mcm9tX2J5dGVzXCJcbiAgZWxzZSBiZWdpblxuICAgIGxldCBsZW4gPSBkYXRhX3NpemVfdW5zYWZlIGJ1ZmYgb2ZzIGluXG4gICAgaWYgb2ZzID4gQnl0ZXMubGVuZ3RoIGJ1ZmYgLSAoaGVhZGVyX3NpemUgKyBsZW4pXG4gICAgdGhlbiBpbnZhbGlkX2FyZyBcIk1hcnNoYWwuZnJvbV9ieXRlc1wiXG4gICAgZWxzZSBmcm9tX2J5dGVzX3Vuc2FmZSBidWZmIG9mc1xuICBlbmRcblxubGV0IGZyb21fc3RyaW5nIGJ1ZmYgb2ZzID1cbiAgKCogQnl0ZXMudW5zYWZlX29mX3N0cmluZyBpcyBzYWZlIGhlcmUsIGFzIHRoZSBwcm9kdWNlZCBieXRlXG4gICAgIHNlcXVlbmNlIGlzIG5ldmVyIG11dGF0ZWQgKilcbiAgZnJvbV9ieXRlcyAoQnl0ZXMudW5zYWZlX29mX3N0cmluZyBidWZmKSBvZnNcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogT3BlcmF0aW9ucyBvbiBpbnRlcm5hbCByZXByZXNlbnRhdGlvbnMgb2YgdmFsdWVzICopXG5cbnR5cGUgdFxuXG50eXBlIHJhd19kYXRhID0gbmF0aXZlaW50XG5cbmV4dGVybmFsIHJlcHIgOiAnYSAtPiB0ID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgb2JqIDogdCAtPiAnYSA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIG1hZ2ljIDogJ2EgLT4gJ2IgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCBpc19pbnQgOiB0IC0+IGJvb2wgPSBcIiVvYmpfaXNfaW50XCJcbmxldCBbQGlubGluZSBhbHdheXNdIGlzX2Jsb2NrIGEgPSBub3QgKGlzX2ludCBhKVxuZXh0ZXJuYWwgdGFnIDogdCAtPiBpbnQgPSBcImNhbWxfb2JqX3RhZ1wiIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBzZXRfdGFnIDogdCAtPiBpbnQgLT4gdW5pdCA9IFwiY2FtbF9vYmpfc2V0X3RhZ1wiXG5leHRlcm5hbCBzaXplIDogdCAtPiBpbnQgPSBcIiVvYmpfc2l6ZVwiXG5leHRlcm5hbCByZWFjaGFibGVfd29yZHMgOiB0IC0+IGludCA9IFwiY2FtbF9vYmpfcmVhY2hhYmxlX3dvcmRzXCJcbmV4dGVybmFsIGZpZWxkIDogdCAtPiBpbnQgLT4gdCA9IFwiJW9ial9maWVsZFwiXG5leHRlcm5hbCBzZXRfZmllbGQgOiB0IC0+IGludCAtPiB0IC0+IHVuaXQgPSBcIiVvYmpfc2V0X2ZpZWxkXCJcbmV4dGVybmFsIGZsb2F0YXJyYXlfZ2V0IDogZmxvYXRhcnJheSAtPiBpbnQgLT4gZmxvYXQgPSBcImNhbWxfZmxvYXRhcnJheV9nZXRcIlxuZXh0ZXJuYWwgZmxvYXRhcnJheV9zZXQgOlxuICAgIGZsb2F0YXJyYXkgLT4gaW50IC0+IGZsb2F0IC0+IHVuaXQgPSBcImNhbWxfZmxvYXRhcnJheV9zZXRcIlxubGV0IFtAaW5saW5lIGFsd2F5c10gZG91YmxlX2ZpZWxkIHggaSA9IGZsb2F0YXJyYXlfZ2V0IChvYmogeCA6IGZsb2F0YXJyYXkpIGlcbmxldCBbQGlubGluZSBhbHdheXNdIHNldF9kb3VibGVfZmllbGQgeCBpIHYgPVxuICBmbG9hdGFycmF5X3NldCAob2JqIHggOiBmbG9hdGFycmF5KSBpIHZcbmV4dGVybmFsIHJhd19maWVsZCA6IHQgLT4gaW50IC0+IHJhd19kYXRhID0gXCJjYW1sX29ial9yYXdfZmllbGRcIlxuZXh0ZXJuYWwgc2V0X3Jhd19maWVsZCA6IHQgLT4gaW50IC0+IHJhd19kYXRhIC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX29ial9zZXRfcmF3X2ZpZWxkXCJcblxuZXh0ZXJuYWwgbmV3X2Jsb2NrIDogaW50IC0+IGludCAtPiB0ID0gXCJjYW1sX29ial9ibG9ja1wiXG5leHRlcm5hbCBkdXAgOiB0IC0+IHQgPSBcImNhbWxfb2JqX2R1cFwiXG5leHRlcm5hbCB0cnVuY2F0ZSA6IHQgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfb2JqX3RydW5jYXRlXCJcbmV4dGVybmFsIGFkZF9vZmZzZXQgOiB0IC0+IEludDMyLnQgLT4gdCA9IFwiY2FtbF9vYmpfYWRkX29mZnNldFwiXG5leHRlcm5hbCB3aXRoX3RhZyA6IGludCAtPiB0IC0+IHQgPSBcImNhbWxfb2JqX3dpdGhfdGFnXCJcblxubGV0IG1hcnNoYWwgKG9iaiA6IHQpID1cbiAgTWFyc2hhbC50b19ieXRlcyBvYmogW11cbmxldCB1bm1hcnNoYWwgc3RyIHBvcyA9XG4gIChNYXJzaGFsLmZyb21fYnl0ZXMgc3RyIHBvcywgcG9zICsgTWFyc2hhbC50b3RhbF9zaXplIHN0ciBwb3MpXG5cbmxldCBmaXJzdF9ub25fY29uc3RhbnRfY29uc3RydWN0b3JfdGFnID0gMFxubGV0IGxhc3Rfbm9uX2NvbnN0YW50X2NvbnN0cnVjdG9yX3RhZyA9IDI0NVxuXG5sZXQgbGF6eV90YWcgPSAyNDZcbmxldCBjbG9zdXJlX3RhZyA9IDI0N1xubGV0IG9iamVjdF90YWcgPSAyNDhcbmxldCBpbmZpeF90YWcgPSAyNDlcbmxldCBmb3J3YXJkX3RhZyA9IDI1MFxuXG5sZXQgbm9fc2Nhbl90YWcgPSAyNTFcblxubGV0IGFic3RyYWN0X3RhZyA9IDI1MVxubGV0IHN0cmluZ190YWcgPSAyNTJcbmxldCBkb3VibGVfdGFnID0gMjUzXG5sZXQgZG91YmxlX2FycmF5X3RhZyA9IDI1NFxubGV0IGN1c3RvbV90YWcgPSAyNTVcbmxldCBmaW5hbF90YWcgPSBjdXN0b21fdGFnXG5cblxubGV0IGludF90YWcgPSAxMDAwXG5sZXQgb3V0X29mX2hlYXBfdGFnID0gMTAwMVxubGV0IHVuYWxpZ25lZF90YWcgPSAxMDAyXG5cbm1vZHVsZSBDbG9zdXJlID0gc3RydWN0XG4gIHR5cGUgaW5mbyA9IHtcbiAgICBhcml0eTogaW50O1xuICAgIHN0YXJ0X2VudjogaW50O1xuICB9XG5cbiAgbGV0IGluZm9fb2ZfcmF3IChpbmZvIDogbmF0aXZlaW50KSA9XG4gICAgbGV0IG9wZW4gTmF0aXZlaW50IGluXG4gICAgbGV0IGFyaXR5ID1cbiAgICAgICgqIHNpZ25lZDogbmVnYXRpdmUgZm9yIHR1cGxlZCBmdW5jdGlvbnMgKilcbiAgICAgIGlmIFN5cy53b3JkX3NpemUgPSA2NCB0aGVuXG4gICAgICAgIHRvX2ludCAoc2hpZnRfcmlnaHQgaW5mbyA1NilcbiAgICAgIGVsc2VcbiAgICAgICAgdG9faW50IChzaGlmdF9yaWdodCBpbmZvIDI0KVxuICAgIGluXG4gICAgbGV0IHN0YXJ0X2VudiA9XG4gICAgICAoKiBzdGFydF9lbnYgaXMgdW5zaWduZWQsIGJ1dCB3ZSBrbm93IGl0IGNhbiBhbHdheXMgZml0IGFuIE9DYW1sXG4gICAgICAgICBpbnRlZ2VyIHNvIHdlIHVzZSBbdG9faW50XSBpbnN0ZWFkIG9mIFt1bnNpZ25lZF90b19pbnRdLiAqKVxuICAgICAgdG9faW50IChzaGlmdF9yaWdodF9sb2dpY2FsIChzaGlmdF9sZWZ0IGluZm8gOCkgOSkgaW5cbiAgICB7IGFyaXR5OyBzdGFydF9lbnYgfVxuXG4gICgqIG5vdGU6IHdlIGV4cGVjdCBhIGNsb3N1cmUsIG5vdCBhbiBpbmZpeCBwb2ludGVyICopXG4gIGxldCBpbmZvIChvYmogOiB0KSA9XG4gICAgYXNzZXJ0ICh0YWcgb2JqID0gY2xvc3VyZV90YWcpO1xuICAgIGluZm9fb2ZfcmF3IChyYXdfZmllbGQgb2JqIDEpXG5lbmRcblxubW9kdWxlIEV4dGVuc2lvbl9jb25zdHJ1Y3RvciA9XG5zdHJ1Y3RcbiAgdHlwZSB0ID0gZXh0ZW5zaW9uX2NvbnN0cnVjdG9yXG4gIGxldCBvZl92YWwgeCA9XG4gICAgbGV0IHggPSByZXByIHggaW5cbiAgICBsZXQgc2xvdCA9XG4gICAgICBpZiAoaXNfYmxvY2sgeCkgJiYgKHRhZyB4KSA8PiBvYmplY3RfdGFnICYmIChzaXplIHgpID49IDEgdGhlbiBmaWVsZCB4IDBcbiAgICAgIGVsc2UgeFxuICAgIGluXG4gICAgbGV0IG5hbWUgPVxuICAgICAgaWYgKGlzX2Jsb2NrIHNsb3QpICYmICh0YWcgc2xvdCkgPSBvYmplY3RfdGFnIHRoZW4gZmllbGQgc2xvdCAwXG4gICAgICBlbHNlIGludmFsaWRfYXJnIFwiT2JqLmV4dGVuc2lvbl9jb25zdHJ1Y3RvclwiXG4gICAgaW5cbiAgICAgIGlmICh0YWcgbmFtZSkgPSBzdHJpbmdfdGFnIHRoZW4gKG9iaiBzbG90IDogdClcbiAgICAgIGVsc2UgaW52YWxpZF9hcmcgXCJPYmouZXh0ZW5zaW9uX2NvbnN0cnVjdG9yXCJcblxuICBsZXQgW0BpbmxpbmUgYWx3YXlzXSBuYW1lIChzbG90IDogdCkgPVxuICAgIChvYmogKGZpZWxkIChyZXByIHNsb3QpIDApIDogc3RyaW5nKVxuXG4gIGxldCBbQGlubGluZSBhbHdheXNdIGlkIChzbG90IDogdCkgPVxuICAgIChvYmogKGZpZWxkIChyZXByIHNsb3QpIDEpIDogaW50KVxuZW5kXG5cbmxldCBleHRlbnNpb25fY29uc3RydWN0b3IgPSBFeHRlbnNpb25fY29uc3RydWN0b3Iub2ZfdmFsXG5sZXQgZXh0ZW5zaW9uX25hbWUgPSBFeHRlbnNpb25fY29uc3RydWN0b3IubmFtZVxubGV0IGV4dGVuc2lvbl9pZCA9IEV4dGVuc2lvbl9jb25zdHJ1Y3Rvci5pZFxuXG5tb2R1bGUgRXBoZW1lcm9uID0gc3RydWN0XG4gIHR5cGUgb2JqX3QgPSB0XG5cbiAgdHlwZSB0ICgqKiBlcGhlbWVyb24gKilcblxuICAgKCoqIFRvIGNoYW5nZSBpbiBzeW5jIHdpdGggd2Vhay5oICopXG4gIGxldCBhZGRpdGlvbmFsX3ZhbHVlcyA9IDJcbiAgbGV0IG1heF9lcGhlX2xlbmd0aCA9IFN5cy5tYXhfYXJyYXlfbGVuZ3RoIC0gYWRkaXRpb25hbF92YWx1ZXNcblxuICBleHRlcm5hbCBjcmVhdGUgOiBpbnQgLT4gdCA9IFwiY2FtbF9lcGhlX2NyZWF0ZVwiOztcbiAgbGV0IGNyZWF0ZSBsID1cbiAgICBpZiBub3QgKDAgPD0gbCAmJiBsIDw9IG1heF9lcGhlX2xlbmd0aCkgdGhlblxuICAgICAgaW52YWxpZF9hcmcgXCJPYmouRXBoZW1lcm9uLmNyZWF0ZVwiO1xuICAgIGNyZWF0ZSBsXG5cbiAgbGV0IGxlbmd0aCB4ID0gc2l6ZShyZXByIHgpIC0gYWRkaXRpb25hbF92YWx1ZXNcblxuICBsZXQgcmFpc2VfaWZfaW52YWxpZF9vZmZzZXQgZSBvIG1zZyA9XG4gICAgaWYgbm90ICgwIDw9IG8gJiYgbyA8IGxlbmd0aCBlKSB0aGVuXG4gICAgICBpbnZhbGlkX2FyZyBtc2dcblxuICBleHRlcm5hbCBnZXRfa2V5OiB0IC0+IGludCAtPiBvYmpfdCBvcHRpb24gPSBcImNhbWxfZXBoZV9nZXRfa2V5XCJcbiAgbGV0IGdldF9rZXkgZSBvID1cbiAgICByYWlzZV9pZl9pbnZhbGlkX29mZnNldCBlIG8gXCJPYmouRXBoZW1lcm9uLmdldF9rZXlcIjtcbiAgICBnZXRfa2V5IGUgb1xuXG4gIGV4dGVybmFsIGdldF9rZXlfY29weTogdCAtPiBpbnQgLT4gb2JqX3Qgb3B0aW9uID0gXCJjYW1sX2VwaGVfZ2V0X2tleV9jb3B5XCJcbiAgbGV0IGdldF9rZXlfY29weSBlIG8gPVxuICAgIHJhaXNlX2lmX2ludmFsaWRfb2Zmc2V0IGUgbyBcIk9iai5FcGhlbWVyb24uZ2V0X2tleV9jb3B5XCI7XG4gICAgZ2V0X2tleV9jb3B5IGUgb1xuXG4gIGV4dGVybmFsIHNldF9rZXk6IHQgLT4gaW50IC0+IG9ial90IC0+IHVuaXQgPSBcImNhbWxfZXBoZV9zZXRfa2V5XCJcbiAgbGV0IHNldF9rZXkgZSBvIHggPVxuICAgIHJhaXNlX2lmX2ludmFsaWRfb2Zmc2V0IGUgbyBcIk9iai5FcGhlbWVyb24uc2V0X2tleVwiO1xuICAgIHNldF9rZXkgZSBvIHhcblxuICBleHRlcm5hbCB1bnNldF9rZXk6IHQgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfZXBoZV91bnNldF9rZXlcIlxuICBsZXQgdW5zZXRfa2V5IGUgbyA9XG4gICAgcmFpc2VfaWZfaW52YWxpZF9vZmZzZXQgZSBvIFwiT2JqLkVwaGVtZXJvbi51bnNldF9rZXlcIjtcbiAgICB1bnNldF9rZXkgZSBvXG5cbiAgZXh0ZXJuYWwgY2hlY2tfa2V5OiB0IC0+IGludCAtPiBib29sID0gXCJjYW1sX2VwaGVfY2hlY2tfa2V5XCJcbiAgbGV0IGNoZWNrX2tleSBlIG8gPVxuICAgIHJhaXNlX2lmX2ludmFsaWRfb2Zmc2V0IGUgbyBcIk9iai5FcGhlbWVyb24uY2hlY2tfa2V5XCI7XG4gICAgY2hlY2tfa2V5IGUgb1xuXG4gIGV4dGVybmFsIGJsaXRfa2V5IDogdCAtPiBpbnQgLT4gdCAtPiBpbnQgLT4gaW50IC0+IHVuaXRcbiAgICA9IFwiY2FtbF9lcGhlX2JsaXRfa2V5XCJcblxuICBsZXQgYmxpdF9rZXkgZTEgbzEgZTIgbzIgbCA9XG4gICAgaWYgbCA8IDAgfHwgbzEgPCAwIHx8IG8xID4gbGVuZ3RoIGUxIC0gbFxuICAgICAgIHx8IG8yIDwgMCB8fCBvMiA+IGxlbmd0aCBlMiAtIGxcbiAgICB0aGVuIGludmFsaWRfYXJnIFwiT2JqLkVwaGVtZXJvbi5ibGl0X2tleVwiXG4gICAgZWxzZSBpZiBsIDw+IDAgdGhlbiBibGl0X2tleSBlMSBvMSBlMiBvMiBsXG5cbiAgZXh0ZXJuYWwgZ2V0X2RhdGE6IHQgLT4gb2JqX3Qgb3B0aW9uID0gXCJjYW1sX2VwaGVfZ2V0X2RhdGFcIlxuICBleHRlcm5hbCBnZXRfZGF0YV9jb3B5OiB0IC0+IG9ial90IG9wdGlvbiA9IFwiY2FtbF9lcGhlX2dldF9kYXRhX2NvcHlcIlxuICBleHRlcm5hbCBzZXRfZGF0YTogdCAtPiBvYmpfdCAtPiB1bml0ID0gXCJjYW1sX2VwaGVfc2V0X2RhdGFcIlxuICBleHRlcm5hbCB1bnNldF9kYXRhOiB0IC0+IHVuaXQgPSBcImNhbWxfZXBoZV91bnNldF9kYXRhXCJcbiAgZXh0ZXJuYWwgY2hlY2tfZGF0YTogdCAtPiBib29sID0gXCJjYW1sX2VwaGVfY2hlY2tfZGF0YVwiXG4gIGV4dGVybmFsIGJsaXRfZGF0YSA6IHQgLT4gdCAtPiB1bml0ID0gXCJjYW1sX2VwaGVfYmxpdF9kYXRhXCJcblxuZW5kXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIEFuIGFsaWFzIGZvciB0aGUgdHlwZSBvZiBhcnJheXMuICopXG50eXBlICdhIHQgPSAnYSBhcnJheVxuXG4oKiBBcnJheSBvcGVyYXRpb25zICopXG5cbmV4dGVybmFsIGxlbmd0aCA6ICdhIGFycmF5IC0+IGludCA9IFwiJWFycmF5X2xlbmd0aFwiXG5leHRlcm5hbCBnZXQ6ICdhIGFycmF5IC0+IGludCAtPiAnYSA9IFwiJWFycmF5X3NhZmVfZ2V0XCJcbmV4dGVybmFsIHNldDogJ2EgYXJyYXkgLT4gaW50IC0+ICdhIC0+IHVuaXQgPSBcIiVhcnJheV9zYWZlX3NldFwiXG5leHRlcm5hbCB1bnNhZmVfZ2V0OiAnYSBhcnJheSAtPiBpbnQgLT4gJ2EgPSBcIiVhcnJheV91bnNhZmVfZ2V0XCJcbmV4dGVybmFsIHVuc2FmZV9zZXQ6ICdhIGFycmF5IC0+IGludCAtPiAnYSAtPiB1bml0ID0gXCIlYXJyYXlfdW5zYWZlX3NldFwiXG5leHRlcm5hbCBtYWtlOiBpbnQgLT4gJ2EgLT4gJ2EgYXJyYXkgPSBcImNhbWxfbWFrZV92ZWN0XCJcbmV4dGVybmFsIGNyZWF0ZTogaW50IC0+ICdhIC0+ICdhIGFycmF5ID0gXCJjYW1sX21ha2VfdmVjdFwiXG5leHRlcm5hbCB1bnNhZmVfc3ViIDogJ2EgYXJyYXkgLT4gaW50IC0+IGludCAtPiAnYSBhcnJheSA9IFwiY2FtbF9hcnJheV9zdWJcIlxuZXh0ZXJuYWwgYXBwZW5kX3ByaW0gOiAnYSBhcnJheSAtPiAnYSBhcnJheSAtPiAnYSBhcnJheSA9IFwiY2FtbF9hcnJheV9hcHBlbmRcIlxuZXh0ZXJuYWwgY29uY2F0IDogJ2EgYXJyYXkgbGlzdCAtPiAnYSBhcnJheSA9IFwiY2FtbF9hcnJheV9jb25jYXRcIlxuZXh0ZXJuYWwgdW5zYWZlX2JsaXQgOlxuICAnYSBhcnJheSAtPiBpbnQgLT4gJ2EgYXJyYXkgLT4gaW50IC0+IGludCAtPiB1bml0ID0gXCJjYW1sX2FycmF5X2JsaXRcIlxuZXh0ZXJuYWwgdW5zYWZlX2ZpbGwgOlxuICAnYSBhcnJheSAtPiBpbnQgLT4gaW50IC0+ICdhIC0+IHVuaXQgPSBcImNhbWxfYXJyYXlfZmlsbFwiXG5leHRlcm5hbCBjcmVhdGVfZmxvYXQ6IGludCAtPiBmbG9hdCBhcnJheSA9IFwiY2FtbF9tYWtlX2Zsb2F0X3ZlY3RcIlxubGV0IG1ha2VfZmxvYXQgPSBjcmVhdGVfZmxvYXRcblxubW9kdWxlIEZsb2F0YXJyYXkgPSBzdHJ1Y3RcbiAgZXh0ZXJuYWwgY3JlYXRlIDogaW50IC0+IGZsb2F0YXJyYXkgPSBcImNhbWxfZmxvYXRhcnJheV9jcmVhdGVcIlxuICBleHRlcm5hbCBsZW5ndGggOiBmbG9hdGFycmF5IC0+IGludCA9IFwiJWZsb2F0YXJyYXlfbGVuZ3RoXCJcbiAgZXh0ZXJuYWwgZ2V0IDogZmxvYXRhcnJheSAtPiBpbnQgLT4gZmxvYXQgPSBcIiVmbG9hdGFycmF5X3NhZmVfZ2V0XCJcbiAgZXh0ZXJuYWwgc2V0IDogZmxvYXRhcnJheSAtPiBpbnQgLT4gZmxvYXQgLT4gdW5pdCA9IFwiJWZsb2F0YXJyYXlfc2FmZV9zZXRcIlxuICBleHRlcm5hbCB1bnNhZmVfZ2V0IDogZmxvYXRhcnJheSAtPiBpbnQgLT4gZmxvYXQgPSBcIiVmbG9hdGFycmF5X3Vuc2FmZV9nZXRcIlxuICBleHRlcm5hbCB1bnNhZmVfc2V0IDogZmxvYXRhcnJheSAtPiBpbnQgLT4gZmxvYXQgLT4gdW5pdFxuICAgICAgPSBcIiVmbG9hdGFycmF5X3Vuc2FmZV9zZXRcIlxuZW5kXG5cbmxldCBpbml0IGwgZiA9XG4gIGlmIGwgPSAwIHRoZW4gW3x8XSBlbHNlXG4gIGlmIGwgPCAwIHRoZW4gaW52YWxpZF9hcmcgXCJBcnJheS5pbml0XCJcbiAgKCogU2VlICM2NTc1LiBXZSBjb3VsZCBhbHNvIGNoZWNrIGZvciBtYXhpbXVtIGFycmF5IHNpemUsIGJ1dCB0aGlzIGRlcGVuZHNcbiAgICAgb24gd2hldGhlciB3ZSBjcmVhdGUgYSBmbG9hdCBhcnJheSBvciBhIHJlZ3VsYXIgb25lLi4uICopXG4gIGVsc2VcbiAgIGxldCByZXMgPSBjcmVhdGUgbCAoZiAwKSBpblxuICAgZm9yIGkgPSAxIHRvIHByZWQgbCBkb1xuICAgICB1bnNhZmVfc2V0IHJlcyBpIChmIGkpXG4gICBkb25lO1xuICAgcmVzXG5cbmxldCBtYWtlX21hdHJpeCBzeCBzeSBpbml0ID1cbiAgbGV0IHJlcyA9IGNyZWF0ZSBzeCBbfHxdIGluXG4gIGZvciB4ID0gMCB0byBwcmVkIHN4IGRvXG4gICAgdW5zYWZlX3NldCByZXMgeCAoY3JlYXRlIHN5IGluaXQpXG4gIGRvbmU7XG4gIHJlc1xuXG5sZXQgY3JlYXRlX21hdHJpeCA9IG1ha2VfbWF0cml4XG5cbmxldCBjb3B5IGEgPVxuICBsZXQgbCA9IGxlbmd0aCBhIGluIGlmIGwgPSAwIHRoZW4gW3x8XSBlbHNlIHVuc2FmZV9zdWIgYSAwIGxcblxubGV0IGFwcGVuZCBhMSBhMiA9XG4gIGxldCBsMSA9IGxlbmd0aCBhMSBpblxuICBpZiBsMSA9IDAgdGhlbiBjb3B5IGEyXG4gIGVsc2UgaWYgbGVuZ3RoIGEyID0gMCB0aGVuIHVuc2FmZV9zdWIgYTEgMCBsMVxuICBlbHNlIGFwcGVuZF9wcmltIGExIGEyXG5cbmxldCBzdWIgYSBvZnMgbGVuID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IGxlbmd0aCBhIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJBcnJheS5zdWJcIlxuICBlbHNlIHVuc2FmZV9zdWIgYSBvZnMgbGVuXG5cbmxldCBmaWxsIGEgb2ZzIGxlbiB2ID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IGxlbmd0aCBhIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJBcnJheS5maWxsXCJcbiAgZWxzZSB1bnNhZmVfZmlsbCBhIG9mcyBsZW4gdlxuXG5sZXQgYmxpdCBhMSBvZnMxIGEyIG9mczIgbGVuID1cbiAgaWYgbGVuIDwgMCB8fCBvZnMxIDwgMCB8fCBvZnMxID4gbGVuZ3RoIGExIC0gbGVuXG4gICAgICAgICAgICAgfHwgb2ZzMiA8IDAgfHwgb2ZzMiA+IGxlbmd0aCBhMiAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiQXJyYXkuYmxpdFwiXG4gIGVsc2UgdW5zYWZlX2JsaXQgYTEgb2ZzMSBhMiBvZnMyIGxlblxuXG5sZXQgaXRlciBmIGEgPVxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvIGYodW5zYWZlX2dldCBhIGkpIGRvbmVcblxubGV0IGl0ZXIyIGYgYSBiID1cbiAgaWYgbGVuZ3RoIGEgPD4gbGVuZ3RoIGIgdGhlblxuICAgIGludmFsaWRfYXJnIFwiQXJyYXkuaXRlcjI6IGFycmF5cyBtdXN0IGhhdmUgdGhlIHNhbWUgbGVuZ3RoXCJcbiAgZWxzZVxuICAgIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG8gZiAodW5zYWZlX2dldCBhIGkpICh1bnNhZmVfZ2V0IGIgaSkgZG9uZVxuXG5sZXQgbWFwIGYgYSA9XG4gIGxldCBsID0gbGVuZ3RoIGEgaW5cbiAgaWYgbCA9IDAgdGhlbiBbfHxdIGVsc2UgYmVnaW5cbiAgICBsZXQgciA9IGNyZWF0ZSBsIChmKHVuc2FmZV9nZXQgYSAwKSkgaW5cbiAgICBmb3IgaSA9IDEgdG8gbCAtIDEgZG9cbiAgICAgIHVuc2FmZV9zZXQgciBpIChmKHVuc2FmZV9nZXQgYSBpKSlcbiAgICBkb25lO1xuICAgIHJcbiAgZW5kXG5cbmxldCBtYXAyIGYgYSBiID1cbiAgbGV0IGxhID0gbGVuZ3RoIGEgaW5cbiAgbGV0IGxiID0gbGVuZ3RoIGIgaW5cbiAgaWYgbGEgPD4gbGIgdGhlblxuICAgIGludmFsaWRfYXJnIFwiQXJyYXkubWFwMjogYXJyYXlzIG11c3QgaGF2ZSB0aGUgc2FtZSBsZW5ndGhcIlxuICBlbHNlIGJlZ2luXG4gICAgaWYgbGEgPSAwIHRoZW4gW3x8XSBlbHNlIGJlZ2luXG4gICAgICBsZXQgciA9IGNyZWF0ZSBsYSAoZiAodW5zYWZlX2dldCBhIDApICh1bnNhZmVfZ2V0IGIgMCkpIGluXG4gICAgICBmb3IgaSA9IDEgdG8gbGEgLSAxIGRvXG4gICAgICAgIHVuc2FmZV9zZXQgciBpIChmICh1bnNhZmVfZ2V0IGEgaSkgKHVuc2FmZV9nZXQgYiBpKSlcbiAgICAgIGRvbmU7XG4gICAgICByXG4gICAgZW5kXG4gIGVuZFxuXG5sZXQgaXRlcmkgZiBhID1cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCBhIC0gMSBkbyBmIGkgKHVuc2FmZV9nZXQgYSBpKSBkb25lXG5cbmxldCBtYXBpIGYgYSA9XG4gIGxldCBsID0gbGVuZ3RoIGEgaW5cbiAgaWYgbCA9IDAgdGhlbiBbfHxdIGVsc2UgYmVnaW5cbiAgICBsZXQgciA9IGNyZWF0ZSBsIChmIDAgKHVuc2FmZV9nZXQgYSAwKSkgaW5cbiAgICBmb3IgaSA9IDEgdG8gbCAtIDEgZG9cbiAgICAgIHVuc2FmZV9zZXQgciBpIChmIGkgKHVuc2FmZV9nZXQgYSBpKSlcbiAgICBkb25lO1xuICAgIHJcbiAgZW5kXG5cbmxldCB0b19saXN0IGEgPVxuICBsZXQgcmVjIHRvbGlzdCBpIHJlcyA9XG4gICAgaWYgaSA8IDAgdGhlbiByZXMgZWxzZSB0b2xpc3QgKGkgLSAxKSAodW5zYWZlX2dldCBhIGkgOjogcmVzKSBpblxuICB0b2xpc3QgKGxlbmd0aCBhIC0gMSkgW11cblxuKCogQ2Fubm90IHVzZSBMaXN0Lmxlbmd0aCBoZXJlIGJlY2F1c2UgdGhlIExpc3QgbW9kdWxlIGRlcGVuZHMgb24gQXJyYXkuICopXG5sZXQgcmVjIGxpc3RfbGVuZ3RoIGFjY3UgPSBmdW5jdGlvblxuICB8IFtdIC0+IGFjY3VcbiAgfCBfOjp0IC0+IGxpc3RfbGVuZ3RoIChzdWNjIGFjY3UpIHRcblxubGV0IG9mX2xpc3QgPSBmdW5jdGlvblxuICAgIFtdIC0+IFt8fF1cbiAgfCBoZDo6dGwgYXMgbCAtPlxuICAgICAgbGV0IGEgPSBjcmVhdGUgKGxpc3RfbGVuZ3RoIDAgbCkgaGQgaW5cbiAgICAgIGxldCByZWMgZmlsbCBpID0gZnVuY3Rpb25cbiAgICAgICAgICBbXSAtPiBhXG4gICAgICAgIHwgaGQ6OnRsIC0+IHVuc2FmZV9zZXQgYSBpIGhkOyBmaWxsIChpKzEpIHRsIGluXG4gICAgICBmaWxsIDEgdGxcblxubGV0IGZvbGRfbGVmdCBmIHggYSA9XG4gIGxldCByID0gcmVmIHggaW5cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCBhIC0gMSBkb1xuICAgIHIgOj0gZiAhciAodW5zYWZlX2dldCBhIGkpXG4gIGRvbmU7XG4gICFyXG5cbmxldCBmb2xkX3JpZ2h0IGYgYSB4ID1cbiAgbGV0IHIgPSByZWYgeCBpblxuICBmb3IgaSA9IGxlbmd0aCBhIC0gMSBkb3dudG8gMCBkb1xuICAgIHIgOj0gZiAodW5zYWZlX2dldCBhIGkpICFyXG4gIGRvbmU7XG4gICFyXG5cbmxldCBleGlzdHMgcCBhID1cbiAgbGV0IG4gPSBsZW5ndGggYSBpblxuICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgaWYgaSA9IG4gdGhlbiBmYWxzZVxuICAgIGVsc2UgaWYgcCAodW5zYWZlX2dldCBhIGkpIHRoZW4gdHJ1ZVxuICAgIGVsc2UgbG9vcCAoc3VjYyBpKSBpblxuICBsb29wIDBcblxubGV0IGZvcl9hbGwgcCBhID1cbiAgbGV0IG4gPSBsZW5ndGggYSBpblxuICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgaWYgaSA9IG4gdGhlbiB0cnVlXG4gICAgZWxzZSBpZiBwICh1bnNhZmVfZ2V0IGEgaSkgdGhlbiBsb29wIChzdWNjIGkpXG4gICAgZWxzZSBmYWxzZSBpblxuICBsb29wIDBcblxubGV0IGZvcl9hbGwyIHAgbDEgbDIgPVxuICBsZXQgbjEgPSBsZW5ndGggbDFcbiAgYW5kIG4yID0gbGVuZ3RoIGwyIGluXG4gIGlmIG4xIDw+IG4yIHRoZW4gaW52YWxpZF9hcmcgXCJBcnJheS5mb3JfYWxsMlwiXG4gIGVsc2UgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPSBuMSB0aGVuIHRydWVcbiAgICBlbHNlIGlmIHAgKHVuc2FmZV9nZXQgbDEgaSkgKHVuc2FmZV9nZXQgbDIgaSkgdGhlbiBsb29wIChzdWNjIGkpXG4gICAgZWxzZSBmYWxzZSBpblxuICBsb29wIDBcblxubGV0IGV4aXN0czIgcCBsMSBsMiA9XG4gIGxldCBuMSA9IGxlbmd0aCBsMVxuICBhbmQgbjIgPSBsZW5ndGggbDIgaW5cbiAgaWYgbjEgPD4gbjIgdGhlbiBpbnZhbGlkX2FyZyBcIkFycmF5LmV4aXN0czJcIlxuICBlbHNlIGxldCByZWMgbG9vcCBpID1cbiAgICBpZiBpID0gbjEgdGhlbiBmYWxzZVxuICAgIGVsc2UgaWYgcCAodW5zYWZlX2dldCBsMSBpKSAodW5zYWZlX2dldCBsMiBpKSB0aGVuIHRydWVcbiAgICBlbHNlIGxvb3AgKHN1Y2MgaSkgaW5cbiAgbG9vcCAwXG5cbmxldCBtZW0geCBhID1cbiAgbGV0IG4gPSBsZW5ndGggYSBpblxuICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgaWYgaSA9IG4gdGhlbiBmYWxzZVxuICAgIGVsc2UgaWYgY29tcGFyZSAodW5zYWZlX2dldCBhIGkpIHggPSAwIHRoZW4gdHJ1ZVxuICAgIGVsc2UgbG9vcCAoc3VjYyBpKSBpblxuICBsb29wIDBcblxubGV0IG1lbXEgeCBhID1cbiAgbGV0IG4gPSBsZW5ndGggYSBpblxuICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgaWYgaSA9IG4gdGhlbiBmYWxzZVxuICAgIGVsc2UgaWYgeCA9PSAodW5zYWZlX2dldCBhIGkpIHRoZW4gdHJ1ZVxuICAgIGVsc2UgbG9vcCAoc3VjYyBpKSBpblxuICBsb29wIDBcblxuZXhjZXB0aW9uIEJvdHRvbSBvZiBpbnRcbmxldCBzb3J0IGNtcCBhID1cbiAgbGV0IG1heHNvbiBsIGkgPVxuICAgIGxldCBpMzEgPSBpK2kraSsxIGluXG4gICAgbGV0IHggPSByZWYgaTMxIGluXG4gICAgaWYgaTMxKzIgPCBsIHRoZW4gYmVnaW5cbiAgICAgIGlmIGNtcCAoZ2V0IGEgaTMxKSAoZ2V0IGEgKGkzMSsxKSkgPCAwIHRoZW4geCA6PSBpMzErMTtcbiAgICAgIGlmIGNtcCAoZ2V0IGEgIXgpIChnZXQgYSAoaTMxKzIpKSA8IDAgdGhlbiB4IDo9IGkzMSsyO1xuICAgICAgIXhcbiAgICBlbmQgZWxzZVxuICAgICAgaWYgaTMxKzEgPCBsICYmIGNtcCAoZ2V0IGEgaTMxKSAoZ2V0IGEgKGkzMSsxKSkgPCAwXG4gICAgICB0aGVuIGkzMSsxXG4gICAgICBlbHNlIGlmIGkzMSA8IGwgdGhlbiBpMzEgZWxzZSByYWlzZSAoQm90dG9tIGkpXG4gIGluXG4gIGxldCByZWMgdHJpY2tsZWRvd24gbCBpIGUgPVxuICAgIGxldCBqID0gbWF4c29uIGwgaSBpblxuICAgIGlmIGNtcCAoZ2V0IGEgaikgZSA+IDAgdGhlbiBiZWdpblxuICAgICAgc2V0IGEgaSAoZ2V0IGEgaik7XG4gICAgICB0cmlja2xlZG93biBsIGogZTtcbiAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgc2V0IGEgaSBlO1xuICAgIGVuZDtcbiAgaW5cbiAgbGV0IHRyaWNrbGUgbCBpIGUgPSB0cnkgdHJpY2tsZWRvd24gbCBpIGUgd2l0aCBCb3R0b20gaSAtPiBzZXQgYSBpIGUgaW5cbiAgbGV0IHJlYyBidWJibGVkb3duIGwgaSA9XG4gICAgbGV0IGogPSBtYXhzb24gbCBpIGluXG4gICAgc2V0IGEgaSAoZ2V0IGEgaik7XG4gICAgYnViYmxlZG93biBsIGpcbiAgaW5cbiAgbGV0IGJ1YmJsZSBsIGkgPSB0cnkgYnViYmxlZG93biBsIGkgd2l0aCBCb3R0b20gaSAtPiBpIGluXG4gIGxldCByZWMgdHJpY2tsZXVwIGkgZSA9XG4gICAgbGV0IGZhdGhlciA9IChpIC0gMSkgLyAzIGluXG4gICAgYXNzZXJ0IChpIDw+IGZhdGhlcik7XG4gICAgaWYgY21wIChnZXQgYSBmYXRoZXIpIGUgPCAwIHRoZW4gYmVnaW5cbiAgICAgIHNldCBhIGkgKGdldCBhIGZhdGhlcik7XG4gICAgICBpZiBmYXRoZXIgPiAwIHRoZW4gdHJpY2tsZXVwIGZhdGhlciBlIGVsc2Ugc2V0IGEgMCBlO1xuICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICBzZXQgYSBpIGU7XG4gICAgZW5kO1xuICBpblxuICBsZXQgbCA9IGxlbmd0aCBhIGluXG4gIGZvciBpID0gKGwgKyAxKSAvIDMgLSAxIGRvd250byAwIGRvIHRyaWNrbGUgbCBpIChnZXQgYSBpKTsgZG9uZTtcbiAgZm9yIGkgPSBsIC0gMSBkb3dudG8gMiBkb1xuICAgIGxldCBlID0gKGdldCBhIGkpIGluXG4gICAgc2V0IGEgaSAoZ2V0IGEgMCk7XG4gICAgdHJpY2tsZXVwIChidWJibGUgaSAwKSBlO1xuICBkb25lO1xuICBpZiBsID4gMSB0aGVuIChsZXQgZSA9IChnZXQgYSAxKSBpbiBzZXQgYSAxIChnZXQgYSAwKTsgc2V0IGEgMCBlKVxuXG5cbmxldCBjdXRvZmYgPSA1XG5sZXQgc3RhYmxlX3NvcnQgY21wIGEgPVxuICBsZXQgbWVyZ2Ugc3JjMW9mcyBzcmMxbGVuIHNyYzIgc3JjMm9mcyBzcmMybGVuIGRzdCBkc3RvZnMgPVxuICAgIGxldCBzcmMxciA9IHNyYzFvZnMgKyBzcmMxbGVuIGFuZCBzcmMyciA9IHNyYzJvZnMgKyBzcmMybGVuIGluXG4gICAgbGV0IHJlYyBsb29wIGkxIHMxIGkyIHMyIGQgPVxuICAgICAgaWYgY21wIHMxIHMyIDw9IDAgdGhlbiBiZWdpblxuICAgICAgICBzZXQgZHN0IGQgczE7XG4gICAgICAgIGxldCBpMSA9IGkxICsgMSBpblxuICAgICAgICBpZiBpMSA8IHNyYzFyIHRoZW5cbiAgICAgICAgICBsb29wIGkxIChnZXQgYSBpMSkgaTIgczIgKGQgKyAxKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgYmxpdCBzcmMyIGkyIGRzdCAoZCArIDEpIChzcmMyciAtIGkyKVxuICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgc2V0IGRzdCBkIHMyO1xuICAgICAgICBsZXQgaTIgPSBpMiArIDEgaW5cbiAgICAgICAgaWYgaTIgPCBzcmMyciB0aGVuXG4gICAgICAgICAgbG9vcCBpMSBzMSBpMiAoZ2V0IHNyYzIgaTIpIChkICsgMSlcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGJsaXQgYSBpMSBkc3QgKGQgKyAxKSAoc3JjMXIgLSBpMSlcbiAgICAgIGVuZFxuICAgIGluIGxvb3Agc3JjMW9mcyAoZ2V0IGEgc3JjMW9mcykgc3JjMm9mcyAoZ2V0IHNyYzIgc3JjMm9mcykgZHN0b2ZzO1xuICBpblxuICBsZXQgaXNvcnR0byBzcmNvZnMgZHN0IGRzdG9mcyBsZW4gPVxuICAgIGZvciBpID0gMCB0byBsZW4gLSAxIGRvXG4gICAgICBsZXQgZSA9IChnZXQgYSAoc3Jjb2ZzICsgaSkpIGluXG4gICAgICBsZXQgaiA9IHJlZiAoZHN0b2ZzICsgaSAtIDEpIGluXG4gICAgICB3aGlsZSAoIWogPj0gZHN0b2ZzICYmIGNtcCAoZ2V0IGRzdCAhaikgZSA+IDApIGRvXG4gICAgICAgIHNldCBkc3QgKCFqICsgMSkgKGdldCBkc3QgIWopO1xuICAgICAgICBkZWNyIGo7XG4gICAgICBkb25lO1xuICAgICAgc2V0IGRzdCAoIWogKyAxKSBlO1xuICAgIGRvbmU7XG4gIGluXG4gIGxldCByZWMgc29ydHRvIHNyY29mcyBkc3QgZHN0b2ZzIGxlbiA9XG4gICAgaWYgbGVuIDw9IGN1dG9mZiB0aGVuIGlzb3J0dG8gc3Jjb2ZzIGRzdCBkc3RvZnMgbGVuIGVsc2UgYmVnaW5cbiAgICAgIGxldCBsMSA9IGxlbiAvIDIgaW5cbiAgICAgIGxldCBsMiA9IGxlbiAtIGwxIGluXG4gICAgICBzb3J0dG8gKHNyY29mcyArIGwxKSBkc3QgKGRzdG9mcyArIGwxKSBsMjtcbiAgICAgIHNvcnR0byBzcmNvZnMgYSAoc3Jjb2ZzICsgbDIpIGwxO1xuICAgICAgbWVyZ2UgKHNyY29mcyArIGwyKSBsMSBkc3QgKGRzdG9mcyArIGwxKSBsMiBkc3QgZHN0b2ZzO1xuICAgIGVuZDtcbiAgaW5cbiAgbGV0IGwgPSBsZW5ndGggYSBpblxuICBpZiBsIDw9IGN1dG9mZiB0aGVuIGlzb3J0dG8gMCBhIDAgbCBlbHNlIGJlZ2luXG4gICAgbGV0IGwxID0gbCAvIDIgaW5cbiAgICBsZXQgbDIgPSBsIC0gbDEgaW5cbiAgICBsZXQgdCA9IG1ha2UgbDIgKGdldCBhIDApIGluXG4gICAgc29ydHRvIGwxIHQgMCBsMjtcbiAgICBzb3J0dG8gMCBhIGwyIGwxO1xuICAgIG1lcmdlIGwyIGwxIHQgMCBsMiBhIDA7XG4gIGVuZFxuXG5cbmxldCBmYXN0X3NvcnQgPSBzdGFibGVfc29ydFxuXG4oKiogezEgSXRlcmF0b3JzfSAqKVxuXG5sZXQgdG9fc2VxIGEgPVxuICBsZXQgcmVjIGF1eCBpICgpID1cbiAgICBpZiBpIDwgbGVuZ3RoIGFcbiAgICB0aGVuXG4gICAgICBsZXQgeCA9IHVuc2FmZV9nZXQgYSBpIGluXG4gICAgICBTZXEuQ29ucyAoeCwgYXV4IChpKzEpKVxuICAgIGVsc2UgU2VxLk5pbFxuICBpblxuICBhdXggMFxuXG5sZXQgdG9fc2VxaSBhID1cbiAgbGV0IHJlYyBhdXggaSAoKSA9XG4gICAgaWYgaSA8IGxlbmd0aCBhXG4gICAgdGhlblxuICAgICAgbGV0IHggPSB1bnNhZmVfZ2V0IGEgaSBpblxuICAgICAgU2VxLkNvbnMgKChpLHgpLCBhdXggKGkrMSkpXG4gICAgZWxzZSBTZXEuTmlsXG4gIGluXG4gIGF1eCAwXG5cbmxldCBvZl9yZXZfbGlzdCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gW3x8XVxuICB8IGhkOjp0bCBhcyBsIC0+XG4gICAgICBsZXQgbGVuID0gbGlzdF9sZW5ndGggMCBsIGluXG4gICAgICBsZXQgYSA9IGNyZWF0ZSBsZW4gaGQgaW5cbiAgICAgIGxldCByZWMgZmlsbCBpID0gZnVuY3Rpb25cbiAgICAgICAgICBbXSAtPiBhXG4gICAgICAgIHwgaGQ6OnRsIC0+IHVuc2FmZV9zZXQgYSBpIGhkOyBmaWxsIChpLTEpIHRsXG4gICAgICBpblxuICAgICAgZmlsbCAobGVuLTIpIHRsXG5cbmxldCBvZl9zZXEgaSA9XG4gIGxldCBsID0gU2VxLmZvbGRfbGVmdCAoZnVuIGFjYyB4IC0+IHg6OmFjYykgW10gaSBpblxuICBvZl9yZXZfbGlzdCBsXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgT0NhbWwgcHJvZ3JhbW1lcnMgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE4IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUgdCA9IGludFxuXG5sZXQgemVybyA9IDBcbmxldCBvbmUgPSAxXG5sZXQgbWludXNfb25lID0gLTFcbmV4dGVybmFsIG5lZyA6IGludCAtPiBpbnQgPSBcIiVuZWdpbnRcIlxuZXh0ZXJuYWwgYWRkIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVhZGRpbnRcIlxuZXh0ZXJuYWwgc3ViIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVzdWJpbnRcIlxuZXh0ZXJuYWwgbXVsIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVtdWxpbnRcIlxuZXh0ZXJuYWwgZGl2IDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVkaXZpbnRcIlxuZXh0ZXJuYWwgcmVtIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVtb2RpbnRcIlxuZXh0ZXJuYWwgc3VjYyA6IGludCAtPiBpbnQgPSBcIiVzdWNjaW50XCJcbmV4dGVybmFsIHByZWQgOiBpbnQgLT4gaW50ID0gXCIlcHJlZGludFwiXG5sZXQgYWJzIHggPSBpZiB4ID49IDAgdGhlbiB4IGVsc2UgLXhcbmxldCBtYXhfaW50ID0gKC0xKSBsc3IgMVxubGV0IG1pbl9pbnQgPSBtYXhfaW50ICsgMVxuZXh0ZXJuYWwgbG9nYW5kIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVhbmRpbnRcIlxuZXh0ZXJuYWwgbG9nb3IgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJW9yaW50XCJcbmV4dGVybmFsIGxvZ3hvciA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIleG9yaW50XCJcbmxldCBsb2dub3QgeCA9IGxvZ3hvciB4ICgtMSlcbmV4dGVybmFsIHNoaWZ0X2xlZnQgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWxzbGludFwiXG5leHRlcm5hbCBzaGlmdF9yaWdodCA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlYXNyaW50XCJcbmV4dGVybmFsIHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWxzcmludFwiXG5sZXQgZXF1YWwgOiBpbnQgLT4gaW50IC0+IGJvb2wgPSAoID0gKVxubGV0IGNvbXBhcmUgOiBpbnQgLT4gaW50IC0+IGludCA9IFN0ZGxpYi5jb21wYXJlXG5leHRlcm5hbCB0b19mbG9hdCA6IGludCAtPiBmbG9hdCA9IFwiJWZsb2F0b2ZpbnRcIlxuZXh0ZXJuYWwgb2ZfZmxvYXQgOiBmbG9hdCAtPiBpbnQgPSBcIiVpbnRvZmZsb2F0XCJcblxuKCpcbmV4dGVybmFsIGludF9vZl9zdHJpbmcgOiBzdHJpbmcgLT4gaW50ID0gXCJjYW1sX2ludF9vZl9zdHJpbmdcIlxubGV0IG9mX3N0cmluZyBzID0gdHJ5IFNvbWUgKGludF9vZl9zdHJpbmcgcykgd2l0aCBGYWlsdXJlIF8gLT4gTm9uZVxuKilcblxuZXh0ZXJuYWwgZm9ybWF0X2ludCA6IHN0cmluZyAtPiBpbnQgLT4gc3RyaW5nID0gXCJjYW1sX2Zvcm1hdF9pbnRcIlxubGV0IHRvX3N0cmluZyB4ID0gZm9ybWF0X2ludCBcIiVkXCIgeFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBNb2R1bGUgW0ludDMyXTogMzItYml0IGludGVnZXJzICopXG5cbmV4dGVybmFsIG5lZyA6IGludDMyIC0+IGludDMyID0gXCIlaW50MzJfbmVnXCJcbmV4dGVybmFsIGFkZCA6IGludDMyIC0+IGludDMyIC0+IGludDMyID0gXCIlaW50MzJfYWRkXCJcbmV4dGVybmFsIHN1YiA6IGludDMyIC0+IGludDMyIC0+IGludDMyID0gXCIlaW50MzJfc3ViXCJcbmV4dGVybmFsIG11bCA6IGludDMyIC0+IGludDMyIC0+IGludDMyID0gXCIlaW50MzJfbXVsXCJcbmV4dGVybmFsIGRpdiA6IGludDMyIC0+IGludDMyIC0+IGludDMyID0gXCIlaW50MzJfZGl2XCJcbmV4dGVybmFsIHJlbSA6IGludDMyIC0+IGludDMyIC0+IGludDMyID0gXCIlaW50MzJfbW9kXCJcbmV4dGVybmFsIGxvZ2FuZCA6IGludDMyIC0+IGludDMyIC0+IGludDMyID0gXCIlaW50MzJfYW5kXCJcbmV4dGVybmFsIGxvZ29yIDogaW50MzIgLT4gaW50MzIgLT4gaW50MzIgPSBcIiVpbnQzMl9vclwiXG5leHRlcm5hbCBsb2d4b3IgOiBpbnQzMiAtPiBpbnQzMiAtPiBpbnQzMiA9IFwiJWludDMyX3hvclwiXG5leHRlcm5hbCBzaGlmdF9sZWZ0IDogaW50MzIgLT4gaW50IC0+IGludDMyID0gXCIlaW50MzJfbHNsXCJcbmV4dGVybmFsIHNoaWZ0X3JpZ2h0IDogaW50MzIgLT4gaW50IC0+IGludDMyID0gXCIlaW50MzJfYXNyXCJcbmV4dGVybmFsIHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgOiBpbnQzMiAtPiBpbnQgLT4gaW50MzIgPSBcIiVpbnQzMl9sc3JcIlxuZXh0ZXJuYWwgb2ZfaW50IDogaW50IC0+IGludDMyID0gXCIlaW50MzJfb2ZfaW50XCJcbmV4dGVybmFsIHRvX2ludCA6IGludDMyIC0+IGludCA9IFwiJWludDMyX3RvX2ludFwiXG5leHRlcm5hbCBvZl9mbG9hdCA6IGZsb2F0IC0+IGludDMyXG4gID0gXCJjYW1sX2ludDMyX29mX2Zsb2F0XCIgXCJjYW1sX2ludDMyX29mX2Zsb2F0X3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdG9fZmxvYXQgOiBpbnQzMiAtPiBmbG9hdFxuICA9IFwiY2FtbF9pbnQzMl90b19mbG9hdFwiIFwiY2FtbF9pbnQzMl90b19mbG9hdF91bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGJpdHNfb2ZfZmxvYXQgOiBmbG9hdCAtPiBpbnQzMlxuICA9IFwiY2FtbF9pbnQzMl9iaXRzX29mX2Zsb2F0XCIgXCJjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXRfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBmbG9hdF9vZl9iaXRzIDogaW50MzIgLT4gZmxvYXRcbiAgPSBcImNhbWxfaW50MzJfZmxvYXRfb2ZfYml0c1wiIFwiY2FtbF9pbnQzMl9mbG9hdF9vZl9iaXRzX3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuXG5sZXQgemVybyA9IDBsXG5sZXQgb25lID0gMWxcbmxldCBtaW51c19vbmUgPSAtMWxcbmxldCBzdWNjIG4gPSBhZGQgbiAxbFxubGV0IHByZWQgbiA9IHN1YiBuIDFsXG5sZXQgYWJzIG4gPSBpZiBuID49IDBsIHRoZW4gbiBlbHNlIG5lZyBuXG5sZXQgbWluX2ludCA9IDB4ODAwMDAwMDBsXG5sZXQgbWF4X2ludCA9IDB4N0ZGRkZGRkZsXG5sZXQgbG9nbm90IG4gPSBsb2d4b3IgbiAoLTFsKVxuXG5sZXQgdW5zaWduZWRfdG9faW50ID1cbiAgbWF0Y2ggU3lzLndvcmRfc2l6ZSB3aXRoXG4gIHwgMzIgLT5cbiAgICAgIGxldCBtYXhfaW50ID0gb2ZfaW50IFN0ZGxpYi5tYXhfaW50IGluXG4gICAgICBmdW4gbiAtPlxuICAgICAgICBpZiBjb21wYXJlIHplcm8gbiA8PSAwICYmIGNvbXBhcmUgbiBtYXhfaW50IDw9IDAgdGhlblxuICAgICAgICAgIFNvbWUgKHRvX2ludCBuKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgTm9uZVxuICB8IDY0IC0+XG4gICAgICAoKiBTbyB0aGF0IGl0IGNvbXBpbGVzIGluIDMyLWJpdCAqKVxuICAgICAgbGV0IG1vdmUgPSBpbnRfb2Zfc3RyaW5nIFwiMHgxXzAwMDBfMDAwMFwiIGluXG4gICAgICBmdW4gbiAtPiBsZXQgaSA9IHRvX2ludCBuIGluIFNvbWUgKGlmIGkgPCAwIHRoZW4gaSArIG1vdmUgZWxzZSBpKVxuICB8IF8gLT5cbiAgICAgIGFzc2VydCBmYWxzZVxuXG5leHRlcm5hbCBmb3JtYXQgOiBzdHJpbmcgLT4gaW50MzIgLT4gc3RyaW5nID0gXCJjYW1sX2ludDMyX2Zvcm1hdFwiXG5sZXQgdG9fc3RyaW5nIG4gPSBmb3JtYXQgXCIlZFwiIG5cblxuZXh0ZXJuYWwgb2Zfc3RyaW5nIDogc3RyaW5nIC0+IGludDMyID0gXCJjYW1sX2ludDMyX29mX3N0cmluZ1wiXG5cbmxldCBvZl9zdHJpbmdfb3B0IHMgPVxuICAoKiBUT0RPOiBleHBvc2UgYSBub24tcmFpc2luZyBwcmltaXRpdmUgZGlyZWN0bHkuICopXG4gIHRyeSBTb21lIChvZl9zdHJpbmcgcylcbiAgd2l0aCBGYWlsdXJlIF8gLT4gTm9uZVxuXG50eXBlIHQgPSBpbnQzMlxuXG5sZXQgY29tcGFyZSAoeDogdCkgKHk6IHQpID0gU3RkbGliLmNvbXBhcmUgeCB5XG5sZXQgZXF1YWwgKHg6IHQpICh5OiB0KSA9IGNvbXBhcmUgeCB5ID0gMFxuXG5sZXQgdW5zaWduZWRfY29tcGFyZSBuIG0gPVxuICBjb21wYXJlIChzdWIgbiBtaW5faW50KSAoc3ViIG0gbWluX2ludClcblxuKCogVW5zaWduZWQgZGl2aXNpb24gZnJvbSBzaWduZWQgZGl2aXNpb24gb2YgdGhlIHNhbWVcbiAgIGJpdG5lc3MuIFNlZSBXYXJyZW4gSnIuLCBIZW5yeSBTLiAoMjAxMykuIEhhY2tlcidzIERlbGlnaHQgKDIgZWQuKSwgU2VjIDktMy5cbiopXG5sZXQgdW5zaWduZWRfZGl2IG4gZCA9XG4gIGlmIGQgPCB6ZXJvIHRoZW5cbiAgICBpZiB1bnNpZ25lZF9jb21wYXJlIG4gZCA8IDAgdGhlbiB6ZXJvIGVsc2Ugb25lXG4gIGVsc2VcbiAgICBsZXQgcSA9IHNoaWZ0X2xlZnQgKGRpdiAoc2hpZnRfcmlnaHRfbG9naWNhbCBuIDEpIGQpIDEgaW5cbiAgICBsZXQgciA9IHN1YiBuIChtdWwgcSBkKSBpblxuICAgIGlmIHVuc2lnbmVkX2NvbXBhcmUgciBkID49IDAgdGhlbiBzdWNjIHEgZWxzZSBxXG5cbmxldCB1bnNpZ25lZF9yZW0gbiBkID1cbiAgc3ViIG4gKG11bCAodW5zaWduZWRfZGl2IG4gZCkgZClcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogVGhlIHBhcnNpbmcgZW5naW5lICopXG5cbm9wZW4gTGV4aW5nXG5cbigqIEludGVybmFsIGludGVyZmFjZSB0byB0aGUgcGFyc2luZyBlbmdpbmUgKilcblxudHlwZSBwYXJzZXJfZW52ID1cbiAgeyBtdXRhYmxlIHNfc3RhY2sgOiBpbnQgYXJyYXk7ICAgICAgICAoKiBTdGF0ZXMgKilcbiAgICBtdXRhYmxlIHZfc3RhY2sgOiBPYmoudCBhcnJheTsgICAgICAoKiBTZW1hbnRpYyBhdHRyaWJ1dGVzICopXG4gICAgbXV0YWJsZSBzeW1iX3N0YXJ0X3N0YWNrIDogcG9zaXRpb24gYXJyYXk7ICgqIFN0YXJ0IHBvc2l0aW9ucyAqKVxuICAgIG11dGFibGUgc3ltYl9lbmRfc3RhY2sgOiBwb3NpdGlvbiBhcnJheTsgICAoKiBFbmQgcG9zaXRpb25zICopXG4gICAgbXV0YWJsZSBzdGFja3NpemUgOiBpbnQ7ICAgICAgICAgICAgKCogU2l6ZSBvZiB0aGUgc3RhY2tzICopXG4gICAgbXV0YWJsZSBzdGFja2Jhc2UgOiBpbnQ7ICAgICAgICAgICAgKCogQmFzZSBzcCBmb3IgY3VycmVudCBwYXJzZSAqKVxuICAgIG11dGFibGUgY3Vycl9jaGFyIDogaW50OyAgICAgICAgICAgICgqIExhc3QgdG9rZW4gcmVhZCAqKVxuICAgIG11dGFibGUgbHZhbCA6IE9iai50OyAgICAgICAgICAgICAgICgqIEl0cyBzZW1hbnRpYyBhdHRyaWJ1dGUgKilcbiAgICBtdXRhYmxlIHN5bWJfc3RhcnQgOiBwb3NpdGlvbjsgICAgICAoKiBTdGFydCBwb3MuIG9mIHRoZSBjdXJyZW50IHN5bWJvbCopXG4gICAgbXV0YWJsZSBzeW1iX2VuZCA6IHBvc2l0aW9uOyAgICAgICAgKCogRW5kIHBvcy4gb2YgdGhlIGN1cnJlbnQgc3ltYm9sICopXG4gICAgbXV0YWJsZSBhc3AgOiBpbnQ7ICAgICAgICAgICAgICAgICAgKCogVGhlIHN0YWNrIHBvaW50ZXIgZm9yIGF0dHJpYnV0ZXMgKilcbiAgICBtdXRhYmxlIHJ1bGVfbGVuIDogaW50OyAgICAgICAgICAgICAoKiBOdW1iZXIgb2YgcmhzIGl0ZW1zIGluIHRoZSBydWxlICopXG4gICAgbXV0YWJsZSBydWxlX251bWJlciA6IGludDsgICAgICAgICAgKCogUnVsZSBudW1iZXIgdG8gcmVkdWNlIGJ5ICopXG4gICAgbXV0YWJsZSBzcCA6IGludDsgICAgICAgICAgICAgICAgICAgKCogU2F2ZWQgc3AgZm9yIHBhcnNlX2VuZ2luZSAqKVxuICAgIG11dGFibGUgc3RhdGUgOiBpbnQ7ICAgICAgICAgICAgICAgICgqIFNhdmVkIHN0YXRlIGZvciBwYXJzZV9lbmdpbmUgKilcbiAgICBtdXRhYmxlIGVycmZsYWcgOiBpbnQgfSAgICAgICAgICAgICAoKiBTYXZlZCBlcnJvciBmbGFnIGZvciBwYXJzZV9lbmdpbmUgKilcblxudHlwZSBwYXJzZV90YWJsZXMgPVxuICB7IGFjdGlvbnMgOiAocGFyc2VyX2VudiAtPiBPYmoudCkgYXJyYXk7XG4gICAgdHJhbnNsX2NvbnN0IDogaW50IGFycmF5O1xuICAgIHRyYW5zbF9ibG9jayA6IGludCBhcnJheTtcbiAgICBsaHMgOiBzdHJpbmc7XG4gICAgbGVuIDogc3RyaW5nO1xuICAgIGRlZnJlZCA6IHN0cmluZztcbiAgICBkZ290byA6IHN0cmluZztcbiAgICBzaW5kZXggOiBzdHJpbmc7XG4gICAgcmluZGV4IDogc3RyaW5nO1xuICAgIGdpbmRleCA6IHN0cmluZztcbiAgICB0YWJsZXNpemUgOiBpbnQ7XG4gICAgdGFibGUgOiBzdHJpbmc7XG4gICAgY2hlY2sgOiBzdHJpbmc7XG4gICAgZXJyb3JfZnVuY3Rpb24gOiBzdHJpbmcgLT4gdW5pdDtcbiAgICBuYW1lc19jb25zdCA6IHN0cmluZztcbiAgICBuYW1lc19ibG9jayA6IHN0cmluZyB9XG5cbmV4Y2VwdGlvbiBZWWV4aXQgb2YgT2JqLnRcbmV4Y2VwdGlvbiBQYXJzZV9lcnJvclxuXG50eXBlIHBhcnNlcl9pbnB1dCA9XG4gICAgU3RhcnRcbiAgfCBUb2tlbl9yZWFkXG4gIHwgU3RhY2tzX2dyb3duXzFcbiAgfCBTdGFja3NfZ3Jvd25fMlxuICB8IFNlbWFudGljX2FjdGlvbl9jb21wdXRlZFxuICB8IEVycm9yX2RldGVjdGVkXG5cbnR5cGUgcGFyc2VyX291dHB1dCA9XG4gICAgUmVhZF90b2tlblxuICB8IFJhaXNlX3BhcnNlX2Vycm9yXG4gIHwgR3Jvd19zdGFja3NfMVxuICB8IEdyb3dfc3RhY2tzXzJcbiAgfCBDb21wdXRlX3NlbWFudGljX2FjdGlvblxuICB8IENhbGxfZXJyb3JfZnVuY3Rpb25cblxuKCogdG8gYXZvaWQgd2FybmluZ3MgKilcbmxldCBfID0gW1JlYWRfdG9rZW47IFJhaXNlX3BhcnNlX2Vycm9yOyBHcm93X3N0YWNrc18xOyBHcm93X3N0YWNrc18yO1xuICAgICAgICAgQ29tcHV0ZV9zZW1hbnRpY19hY3Rpb247IENhbGxfZXJyb3JfZnVuY3Rpb25dXG5cbmV4dGVybmFsIHBhcnNlX2VuZ2luZSA6XG4gICAgcGFyc2VfdGFibGVzIC0+IHBhcnNlcl9lbnYgLT4gcGFyc2VyX2lucHV0IC0+IE9iai50IC0+IHBhcnNlcl9vdXRwdXRcbiAgICA9IFwiY2FtbF9wYXJzZV9lbmdpbmVcIlxuXG5leHRlcm5hbCBzZXRfdHJhY2U6IGJvb2wgLT4gYm9vbFxuICAgID0gXCJjYW1sX3NldF9wYXJzZXJfdHJhY2VcIlxuXG5sZXQgZW52ID1cbiAgeyBzX3N0YWNrID0gQXJyYXkubWFrZSAxMDAgMDtcbiAgICB2X3N0YWNrID0gQXJyYXkubWFrZSAxMDAgKE9iai5yZXByICgpKTtcbiAgICBzeW1iX3N0YXJ0X3N0YWNrID0gQXJyYXkubWFrZSAxMDAgZHVtbXlfcG9zO1xuICAgIHN5bWJfZW5kX3N0YWNrID0gQXJyYXkubWFrZSAxMDAgZHVtbXlfcG9zO1xuICAgIHN0YWNrc2l6ZSA9IDEwMDtcbiAgICBzdGFja2Jhc2UgPSAwO1xuICAgIGN1cnJfY2hhciA9IDA7XG4gICAgbHZhbCA9IE9iai5yZXByICgpO1xuICAgIHN5bWJfc3RhcnQgPSBkdW1teV9wb3M7XG4gICAgc3ltYl9lbmQgPSBkdW1teV9wb3M7XG4gICAgYXNwID0gMDtcbiAgICBydWxlX2xlbiA9IDA7XG4gICAgcnVsZV9udW1iZXIgPSAwO1xuICAgIHNwID0gMDtcbiAgICBzdGF0ZSA9IDA7XG4gICAgZXJyZmxhZyA9IDAgfVxuXG5sZXQgZ3Jvd19zdGFja3MoKSA9XG4gIGxldCBvbGRzaXplID0gZW52LnN0YWNrc2l6ZSBpblxuICBsZXQgbmV3c2l6ZSA9IG9sZHNpemUgKiAyIGluXG4gIGxldCBuZXdfcyA9IEFycmF5Lm1ha2UgbmV3c2l6ZSAwXG4gIGFuZCBuZXdfdiA9IEFycmF5Lm1ha2UgbmV3c2l6ZSAoT2JqLnJlcHIgKCkpXG4gIGFuZCBuZXdfc3RhcnQgPSBBcnJheS5tYWtlIG5ld3NpemUgZHVtbXlfcG9zXG4gIGFuZCBuZXdfZW5kID0gQXJyYXkubWFrZSBuZXdzaXplIGR1bW15X3BvcyBpblxuICAgIEFycmF5LmJsaXQgZW52LnNfc3RhY2sgMCBuZXdfcyAwIG9sZHNpemU7XG4gICAgZW52LnNfc3RhY2sgPC0gbmV3X3M7XG4gICAgQXJyYXkuYmxpdCBlbnYudl9zdGFjayAwIG5ld192IDAgb2xkc2l6ZTtcbiAgICBlbnYudl9zdGFjayA8LSBuZXdfdjtcbiAgICBBcnJheS5ibGl0IGVudi5zeW1iX3N0YXJ0X3N0YWNrIDAgbmV3X3N0YXJ0IDAgb2xkc2l6ZTtcbiAgICBlbnYuc3ltYl9zdGFydF9zdGFjayA8LSBuZXdfc3RhcnQ7XG4gICAgQXJyYXkuYmxpdCBlbnYuc3ltYl9lbmRfc3RhY2sgMCBuZXdfZW5kIDAgb2xkc2l6ZTtcbiAgICBlbnYuc3ltYl9lbmRfc3RhY2sgPC0gbmV3X2VuZDtcbiAgICBlbnYuc3RhY2tzaXplIDwtIG5ld3NpemVcblxubGV0IGNsZWFyX3BhcnNlcigpID1cbiAgQXJyYXkuZmlsbCBlbnYudl9zdGFjayAwIGVudi5zdGFja3NpemUgKE9iai5yZXByICgpKTtcbiAgZW52Lmx2YWwgPC0gT2JqLnJlcHIgKClcblxubGV0IGN1cnJlbnRfbG9va2FoZWFkX2Z1biA9IHJlZiAoZnVuIChfIDogT2JqLnQpIC0+IGZhbHNlKVxuXG5sZXQgeXlwYXJzZSB0YWJsZXMgc3RhcnQgbGV4ZXIgbGV4YnVmID1cbiAgbGV0IHJlYyBsb29wIGNtZCBhcmcgPVxuICAgIG1hdGNoIHBhcnNlX2VuZ2luZSB0YWJsZXMgZW52IGNtZCBhcmcgd2l0aFxuICAgICAgUmVhZF90b2tlbiAtPlxuICAgICAgICBsZXQgdCA9IE9iai5yZXByKGxleGVyIGxleGJ1ZikgaW5cbiAgICAgICAgZW52LnN5bWJfc3RhcnQgPC0gbGV4YnVmLmxleF9zdGFydF9wO1xuICAgICAgICBlbnYuc3ltYl9lbmQgPC0gbGV4YnVmLmxleF9jdXJyX3A7XG4gICAgICAgIGxvb3AgVG9rZW5fcmVhZCB0XG4gICAgfCBSYWlzZV9wYXJzZV9lcnJvciAtPlxuICAgICAgICByYWlzZSBQYXJzZV9lcnJvclxuICAgIHwgQ29tcHV0ZV9zZW1hbnRpY19hY3Rpb24gLT5cbiAgICAgICAgbGV0IChhY3Rpb24sIHZhbHVlKSA9XG4gICAgICAgICAgdHJ5XG4gICAgICAgICAgICAoU2VtYW50aWNfYWN0aW9uX2NvbXB1dGVkLCB0YWJsZXMuYWN0aW9ucy4oZW52LnJ1bGVfbnVtYmVyKSBlbnYpXG4gICAgICAgICAgd2l0aCBQYXJzZV9lcnJvciAtPlxuICAgICAgICAgICAgKEVycm9yX2RldGVjdGVkLCBPYmoucmVwciAoKSkgaW5cbiAgICAgICAgbG9vcCBhY3Rpb24gdmFsdWVcbiAgICB8IEdyb3dfc3RhY2tzXzEgLT5cbiAgICAgICAgZ3Jvd19zdGFja3MoKTsgbG9vcCBTdGFja3NfZ3Jvd25fMSAoT2JqLnJlcHIgKCkpXG4gICAgfCBHcm93X3N0YWNrc18yIC0+XG4gICAgICAgIGdyb3dfc3RhY2tzKCk7IGxvb3AgU3RhY2tzX2dyb3duXzIgKE9iai5yZXByICgpKVxuICAgIHwgQ2FsbF9lcnJvcl9mdW5jdGlvbiAtPlxuICAgICAgICB0YWJsZXMuZXJyb3JfZnVuY3Rpb24gXCJzeW50YXggZXJyb3JcIjtcbiAgICAgICAgbG9vcCBFcnJvcl9kZXRlY3RlZCAoT2JqLnJlcHIgKCkpIGluXG4gIGxldCBpbml0X2FzcCA9IGVudi5hc3BcbiAgYW5kIGluaXRfc3AgPSBlbnYuc3BcbiAgYW5kIGluaXRfc3RhY2tiYXNlID0gZW52LnN0YWNrYmFzZVxuICBhbmQgaW5pdF9zdGF0ZSA9IGVudi5zdGF0ZVxuICBhbmQgaW5pdF9jdXJyX2NoYXIgPSBlbnYuY3Vycl9jaGFyXG4gIGFuZCBpbml0X2x2YWwgPSBlbnYubHZhbFxuICBhbmQgaW5pdF9lcnJmbGFnID0gZW52LmVycmZsYWcgaW5cbiAgZW52LnN0YWNrYmFzZSA8LSBlbnYuc3AgKyAxO1xuICBlbnYuY3Vycl9jaGFyIDwtIHN0YXJ0O1xuICBlbnYuc3ltYl9lbmQgPC0gbGV4YnVmLmxleF9jdXJyX3A7XG4gIHRyeVxuICAgIGxvb3AgU3RhcnQgKE9iai5yZXByICgpKVxuICB3aXRoIGV4biAtPlxuICAgIGxldCBjdXJyX2NoYXIgPSBlbnYuY3Vycl9jaGFyIGluXG4gICAgZW52LmFzcCA8LSBpbml0X2FzcDtcbiAgICBlbnYuc3AgPC0gaW5pdF9zcDtcbiAgICBlbnYuc3RhY2tiYXNlIDwtIGluaXRfc3RhY2tiYXNlO1xuICAgIGVudi5zdGF0ZSA8LSBpbml0X3N0YXRlO1xuICAgIGVudi5jdXJyX2NoYXIgPC0gaW5pdF9jdXJyX2NoYXI7XG4gICAgZW52Lmx2YWwgPC0gaW5pdF9sdmFsO1xuICAgIGVudi5lcnJmbGFnIDwtIGluaXRfZXJyZmxhZztcbiAgICBtYXRjaCBleG4gd2l0aFxuICAgICAgWVlleGl0IHYgLT5cbiAgICAgICAgT2JqLm1hZ2ljIHZcbiAgICB8IF8gLT5cbiAgICAgICAgY3VycmVudF9sb29rYWhlYWRfZnVuIDo9XG4gICAgICAgICAgKGZ1biB0b2sgLT5cbiAgICAgICAgICAgIGlmIE9iai5pc19ibG9jayB0b2tcbiAgICAgICAgICAgIHRoZW4gdGFibGVzLnRyYW5zbF9ibG9jay4oT2JqLnRhZyB0b2spID0gY3Vycl9jaGFyXG4gICAgICAgICAgICBlbHNlIHRhYmxlcy50cmFuc2xfY29uc3QuKE9iai5tYWdpYyB0b2spID0gY3Vycl9jaGFyKTtcbiAgICAgICAgcmFpc2UgZXhuXG5cbmxldCBwZWVrX3ZhbCBlbnYgbiA9XG4gIE9iai5tYWdpYyBlbnYudl9zdGFjay4oZW52LmFzcCAtIG4pXG5cbmxldCBzeW1ib2xfc3RhcnRfcG9zICgpID1cbiAgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPD0gMCB0aGVuIGVudi5zeW1iX2VuZF9zdGFjay4oZW52LmFzcClcbiAgICBlbHNlIGJlZ2luXG4gICAgICBsZXQgc3QgPSBlbnYuc3ltYl9zdGFydF9zdGFjay4oZW52LmFzcCAtIGkgKyAxKSBpblxuICAgICAgbGV0IGVuID0gZW52LnN5bWJfZW5kX3N0YWNrLihlbnYuYXNwIC0gaSArIDEpIGluXG4gICAgICBpZiBzdCA8PiBlbiB0aGVuIHN0IGVsc2UgbG9vcCAoaSAtIDEpXG4gICAgZW5kXG4gIGluXG4gIGxvb3AgZW52LnJ1bGVfbGVuXG5cbmxldCBzeW1ib2xfZW5kX3BvcyAoKSA9IGVudi5zeW1iX2VuZF9zdGFjay4oZW52LmFzcClcbmxldCByaHNfc3RhcnRfcG9zIG4gPSBlbnYuc3ltYl9zdGFydF9zdGFjay4oZW52LmFzcCAtIChlbnYucnVsZV9sZW4gLSBuKSlcbmxldCByaHNfZW5kX3BvcyBuID0gZW52LnN5bWJfZW5kX3N0YWNrLihlbnYuYXNwIC0gKGVudi5ydWxlX2xlbiAtIG4pKVxuXG5sZXQgc3ltYm9sX3N0YXJ0ICgpID0gKHN5bWJvbF9zdGFydF9wb3MgKCkpLnBvc19jbnVtXG5sZXQgc3ltYm9sX2VuZCAoKSA9IChzeW1ib2xfZW5kX3BvcyAoKSkucG9zX2NudW1cbmxldCByaHNfc3RhcnQgbiA9IChyaHNfc3RhcnRfcG9zIG4pLnBvc19jbnVtXG5sZXQgcmhzX2VuZCBuID0gKHJoc19lbmRfcG9zIG4pLnBvc19jbnVtXG5cbmxldCBpc19jdXJyZW50X2xvb2thaGVhZCB0b2sgPVxuICAoIWN1cnJlbnRfbG9va2FoZWFkX2Z1bikoT2JqLnJlcHIgdG9rKVxuXG5sZXQgcGFyc2VfZXJyb3IgKF8gOiBzdHJpbmcpID0gKClcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogU2V0cyBvdmVyIG9yZGVyZWQgdHlwZXMgKilcblxubW9kdWxlIHR5cGUgT3JkZXJlZFR5cGUgPVxuICBzaWdcbiAgICB0eXBlIHRcbiAgICB2YWwgY29tcGFyZTogdCAtPiB0IC0+IGludFxuICBlbmRcblxubW9kdWxlIHR5cGUgUyA9XG4gIHNpZ1xuICAgIHR5cGUgZWx0XG4gICAgdHlwZSB0XG4gICAgdmFsIGVtcHR5OiB0XG4gICAgdmFsIGlzX2VtcHR5OiB0IC0+IGJvb2xcbiAgICB2YWwgbWVtOiBlbHQgLT4gdCAtPiBib29sXG4gICAgdmFsIGFkZDogZWx0IC0+IHQgLT4gdFxuICAgIHZhbCBzaW5nbGV0b246IGVsdCAtPiB0XG4gICAgdmFsIHJlbW92ZTogZWx0IC0+IHQgLT4gdFxuICAgIHZhbCB1bmlvbjogdCAtPiB0IC0+IHRcbiAgICB2YWwgaW50ZXI6IHQgLT4gdCAtPiB0XG4gICAgdmFsIGRpc2pvaW50OiB0IC0+IHQgLT4gYm9vbFxuICAgIHZhbCBkaWZmOiB0IC0+IHQgLT4gdFxuICAgIHZhbCBjb21wYXJlOiB0IC0+IHQgLT4gaW50XG4gICAgdmFsIGVxdWFsOiB0IC0+IHQgLT4gYm9vbFxuICAgIHZhbCBzdWJzZXQ6IHQgLT4gdCAtPiBib29sXG4gICAgdmFsIGl0ZXI6IChlbHQgLT4gdW5pdCkgLT4gdCAtPiB1bml0XG4gICAgdmFsIG1hcDogKGVsdCAtPiBlbHQpIC0+IHQgLT4gdFxuICAgIHZhbCBmb2xkOiAoZWx0IC0+ICdhIC0+ICdhKSAtPiB0IC0+ICdhIC0+ICdhXG4gICAgdmFsIGZvcl9hbGw6IChlbHQgLT4gYm9vbCkgLT4gdCAtPiBib29sXG4gICAgdmFsIGV4aXN0czogKGVsdCAtPiBib29sKSAtPiB0IC0+IGJvb2xcbiAgICB2YWwgZmlsdGVyOiAoZWx0IC0+IGJvb2wpIC0+IHQgLT4gdFxuICAgIHZhbCBmaWx0ZXJfbWFwOiAoZWx0IC0+IGVsdCBvcHRpb24pIC0+IHQgLT4gdFxuICAgIHZhbCBwYXJ0aXRpb246IChlbHQgLT4gYm9vbCkgLT4gdCAtPiB0ICogdFxuICAgIHZhbCBjYXJkaW5hbDogdCAtPiBpbnRcbiAgICB2YWwgZWxlbWVudHM6IHQgLT4gZWx0IGxpc3RcbiAgICB2YWwgbWluX2VsdDogdCAtPiBlbHRcbiAgICB2YWwgbWluX2VsdF9vcHQ6IHQgLT4gZWx0IG9wdGlvblxuICAgIHZhbCBtYXhfZWx0OiB0IC0+IGVsdFxuICAgIHZhbCBtYXhfZWx0X29wdDogdCAtPiBlbHQgb3B0aW9uXG4gICAgdmFsIGNob29zZTogdCAtPiBlbHRcbiAgICB2YWwgY2hvb3NlX29wdDogdCAtPiBlbHQgb3B0aW9uXG4gICAgdmFsIHNwbGl0OiBlbHQgLT4gdCAtPiB0ICogYm9vbCAqIHRcbiAgICB2YWwgZmluZDogZWx0IC0+IHQgLT4gZWx0XG4gICAgdmFsIGZpbmRfb3B0OiBlbHQgLT4gdCAtPiBlbHQgb3B0aW9uXG4gICAgdmFsIGZpbmRfZmlyc3Q6IChlbHQgLT4gYm9vbCkgLT4gdCAtPiBlbHRcbiAgICB2YWwgZmluZF9maXJzdF9vcHQ6IChlbHQgLT4gYm9vbCkgLT4gdCAtPiBlbHQgb3B0aW9uXG4gICAgdmFsIGZpbmRfbGFzdDogKGVsdCAtPiBib29sKSAtPiB0IC0+IGVsdFxuICAgIHZhbCBmaW5kX2xhc3Rfb3B0OiAoZWx0IC0+IGJvb2wpIC0+IHQgLT4gZWx0IG9wdGlvblxuICAgIHZhbCBvZl9saXN0OiBlbHQgbGlzdCAtPiB0XG4gICAgdmFsIHRvX3NlcV9mcm9tIDogZWx0IC0+IHQgLT4gZWx0IFNlcS50XG4gICAgdmFsIHRvX3NlcSA6IHQgLT4gZWx0IFNlcS50XG4gICAgdmFsIHRvX3Jldl9zZXEgOiB0IC0+IGVsdCBTZXEudFxuICAgIHZhbCBhZGRfc2VxIDogZWx0IFNlcS50IC0+IHQgLT4gdFxuICAgIHZhbCBvZl9zZXEgOiBlbHQgU2VxLnQgLT4gdFxuICBlbmRcblxubW9kdWxlIE1ha2UoT3JkOiBPcmRlcmVkVHlwZSkgPVxuICBzdHJ1Y3RcbiAgICB0eXBlIGVsdCA9IE9yZC50XG4gICAgdHlwZSB0ID0gRW1wdHkgfCBOb2RlIG9mIHtsOnQ7IHY6ZWx0OyByOnQ7IGg6aW50fVxuXG4gICAgKCogU2V0cyBhcmUgcmVwcmVzZW50ZWQgYnkgYmFsYW5jZWQgYmluYXJ5IHRyZWVzICh0aGUgaGVpZ2h0cyBvZiB0aGVcbiAgICAgICBjaGlsZHJlbiBkaWZmZXIgYnkgYXQgbW9zdCAyICopXG5cbiAgICBsZXQgaGVpZ2h0ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gMFxuICAgICAgfCBOb2RlIHtofSAtPiBoXG5cbiAgICAoKiBDcmVhdGVzIGEgbmV3IG5vZGUgd2l0aCBsZWZ0IHNvbiBsLCB2YWx1ZSB2IGFuZCByaWdodCBzb24gci5cbiAgICAgICBXZSBtdXN0IGhhdmUgYWxsIGVsZW1lbnRzIG9mIGwgPCB2IDwgYWxsIGVsZW1lbnRzIG9mIHIuXG4gICAgICAgbCBhbmQgciBtdXN0IGJlIGJhbGFuY2VkIGFuZCB8IGhlaWdodCBsIC0gaGVpZ2h0IHIgfCA8PSAyLlxuICAgICAgIElubGluZSBleHBhbnNpb24gb2YgaGVpZ2h0IGZvciBiZXR0ZXIgc3BlZWQuICopXG5cbiAgICBsZXQgY3JlYXRlIGwgdiByID1cbiAgICAgIGxldCBobCA9IG1hdGNoIGwgd2l0aCBFbXB0eSAtPiAwIHwgTm9kZSB7aH0gLT4gaCBpblxuICAgICAgbGV0IGhyID0gbWF0Y2ggciB3aXRoIEVtcHR5IC0+IDAgfCBOb2RlIHtofSAtPiBoIGluXG4gICAgICBOb2Rle2w7IHY7IHI7IGg9KGlmIGhsID49IGhyIHRoZW4gaGwgKyAxIGVsc2UgaHIgKyAxKX1cblxuICAgICgqIFNhbWUgYXMgY3JlYXRlLCBidXQgcGVyZm9ybXMgb25lIHN0ZXAgb2YgcmViYWxhbmNpbmcgaWYgbmVjZXNzYXJ5LlxuICAgICAgIEFzc3VtZXMgbCBhbmQgciBiYWxhbmNlZCBhbmQgfCBoZWlnaHQgbCAtIGhlaWdodCByIHwgPD0gMy5cbiAgICAgICBJbmxpbmUgZXhwYW5zaW9uIG9mIGNyZWF0ZSBmb3IgYmV0dGVyIHNwZWVkIGluIHRoZSBtb3N0IGZyZXF1ZW50IGNhc2VcbiAgICAgICB3aGVyZSBubyByZWJhbGFuY2luZyBpcyByZXF1aXJlZC4gKilcblxuICAgIGxldCBiYWwgbCB2IHIgPVxuICAgICAgbGV0IGhsID0gbWF0Y2ggbCB3aXRoIEVtcHR5IC0+IDAgfCBOb2RlIHtofSAtPiBoIGluXG4gICAgICBsZXQgaHIgPSBtYXRjaCByIHdpdGggRW1wdHkgLT4gMCB8IE5vZGUge2h9IC0+IGggaW5cbiAgICAgIGlmIGhsID4gaHIgKyAyIHRoZW4gYmVnaW5cbiAgICAgICAgbWF0Y2ggbCB3aXRoXG4gICAgICAgICAgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJTZXQuYmFsXCJcbiAgICAgICAgfCBOb2Rle2w9bGw7IHY9bHY7IHI9bHJ9IC0+XG4gICAgICAgICAgICBpZiBoZWlnaHQgbGwgPj0gaGVpZ2h0IGxyIHRoZW5cbiAgICAgICAgICAgICAgY3JlYXRlIGxsIGx2IChjcmVhdGUgbHIgdiByKVxuICAgICAgICAgICAgZWxzZSBiZWdpblxuICAgICAgICAgICAgICBtYXRjaCBsciB3aXRoXG4gICAgICAgICAgICAgICAgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJTZXQuYmFsXCJcbiAgICAgICAgICAgICAgfCBOb2Rle2w9bHJsOyB2PWxydjsgcj1scnJ9LT5cbiAgICAgICAgICAgICAgICAgIGNyZWF0ZSAoY3JlYXRlIGxsIGx2IGxybCkgbHJ2IChjcmVhdGUgbHJyIHYgcilcbiAgICAgICAgICAgIGVuZFxuICAgICAgZW5kIGVsc2UgaWYgaHIgPiBobCArIDIgdGhlbiBiZWdpblxuICAgICAgICBtYXRjaCByIHdpdGhcbiAgICAgICAgICBFbXB0eSAtPiBpbnZhbGlkX2FyZyBcIlNldC5iYWxcIlxuICAgICAgICB8IE5vZGV7bD1ybDsgdj1ydjsgcj1ycn0gLT5cbiAgICAgICAgICAgIGlmIGhlaWdodCByciA+PSBoZWlnaHQgcmwgdGhlblxuICAgICAgICAgICAgICBjcmVhdGUgKGNyZWF0ZSBsIHYgcmwpIHJ2IHJyXG4gICAgICAgICAgICBlbHNlIGJlZ2luXG4gICAgICAgICAgICAgIG1hdGNoIHJsIHdpdGhcbiAgICAgICAgICAgICAgICBFbXB0eSAtPiBpbnZhbGlkX2FyZyBcIlNldC5iYWxcIlxuICAgICAgICAgICAgICB8IE5vZGV7bD1ybGw7IHY9cmx2OyByPXJscn0gLT5cbiAgICAgICAgICAgICAgICAgIGNyZWF0ZSAoY3JlYXRlIGwgdiBybGwpIHJsdiAoY3JlYXRlIHJsciBydiBycilcbiAgICAgICAgICAgIGVuZFxuICAgICAgZW5kIGVsc2VcbiAgICAgICAgTm9kZXtsOyB2OyByOyBoPShpZiBobCA+PSBociB0aGVuIGhsICsgMSBlbHNlIGhyICsgMSl9XG5cbiAgICAoKiBJbnNlcnRpb24gb2Ygb25lIGVsZW1lbnQgKilcblxuICAgIGxldCByZWMgYWRkIHggPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBOb2Rle2w9RW1wdHk7IHY9eDsgcj1FbXB0eTsgaD0xfVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IGFzIHQgLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gdCBlbHNlXG4gICAgICAgICAgaWYgYyA8IDAgdGhlblxuICAgICAgICAgICAgbGV0IGxsID0gYWRkIHggbCBpblxuICAgICAgICAgICAgaWYgbCA9PSBsbCB0aGVuIHQgZWxzZSBiYWwgbGwgdiByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbGV0IHJyID0gYWRkIHggciBpblxuICAgICAgICAgICAgaWYgciA9PSByciB0aGVuIHQgZWxzZSBiYWwgbCB2IHJyXG5cbiAgICBsZXQgc2luZ2xldG9uIHggPSBOb2Rle2w9RW1wdHk7IHY9eDsgcj1FbXB0eTsgaD0xfVxuXG4gICAgKCogQmV3YXJlOiB0aG9zZSB0d28gZnVuY3Rpb25zIGFzc3VtZSB0aGF0IHRoZSBhZGRlZCB2IGlzICpzdHJpY3RseSpcbiAgICAgICBzbWFsbGVyIChvciBiaWdnZXIpIHRoYW4gYWxsIHRoZSBwcmVzZW50IGVsZW1lbnRzIGluIHRoZSB0cmVlOyBpdFxuICAgICAgIGRvZXMgbm90IHRlc3QgZm9yIGVxdWFsaXR5IHdpdGggdGhlIGN1cnJlbnQgbWluIChvciBtYXgpIGVsZW1lbnQuXG4gICAgICAgSW5kZWVkLCB0aGV5IGFyZSBvbmx5IHVzZWQgZHVyaW5nIHRoZSBcImpvaW5cIiBvcGVyYXRpb24gd2hpY2hcbiAgICAgICByZXNwZWN0cyB0aGlzIHByZWNvbmRpdGlvbi5cbiAgICAqKVxuXG4gICAgbGV0IHJlYyBhZGRfbWluX2VsZW1lbnQgeCA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+IHNpbmdsZXRvbiB4XG4gICAgICB8IE5vZGUge2w7IHY7IHJ9IC0+XG4gICAgICAgIGJhbCAoYWRkX21pbl9lbGVtZW50IHggbCkgdiByXG5cbiAgICBsZXQgcmVjIGFkZF9tYXhfZWxlbWVudCB4ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT4gc2luZ2xldG9uIHhcbiAgICAgIHwgTm9kZSB7bDsgdjsgcn0gLT5cbiAgICAgICAgYmFsIGwgdiAoYWRkX21heF9lbGVtZW50IHggcilcblxuICAgICgqIFNhbWUgYXMgY3JlYXRlIGFuZCBiYWwsIGJ1dCBubyBhc3N1bXB0aW9ucyBhcmUgbWFkZSBvbiB0aGVcbiAgICAgICByZWxhdGl2ZSBoZWlnaHRzIG9mIGwgYW5kIHIuICopXG5cbiAgICBsZXQgcmVjIGpvaW4gbCB2IHIgPVxuICAgICAgbWF0Y2ggKGwsIHIpIHdpdGhcbiAgICAgICAgKEVtcHR5LCBfKSAtPiBhZGRfbWluX2VsZW1lbnQgdiByXG4gICAgICB8IChfLCBFbXB0eSkgLT4gYWRkX21heF9lbGVtZW50IHYgbFxuICAgICAgfCAoTm9kZXtsPWxsOyB2PWx2OyByPWxyOyBoPWxofSwgTm9kZXtsPXJsOyB2PXJ2OyByPXJyOyBoPXJofSkgLT5cbiAgICAgICAgICBpZiBsaCA+IHJoICsgMiB0aGVuIGJhbCBsbCBsdiAoam9pbiBsciB2IHIpIGVsc2VcbiAgICAgICAgICBpZiByaCA+IGxoICsgMiB0aGVuIGJhbCAoam9pbiBsIHYgcmwpIHJ2IHJyIGVsc2VcbiAgICAgICAgICBjcmVhdGUgbCB2IHJcblxuICAgICgqIFNtYWxsZXN0IGFuZCBncmVhdGVzdCBlbGVtZW50IG9mIGEgc2V0ICopXG5cbiAgICBsZXQgcmVjIG1pbl9lbHQgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgTm9kZXtsPUVtcHR5OyB2fSAtPiB2XG4gICAgICB8IE5vZGV7bH0gLT4gbWluX2VsdCBsXG5cbiAgICBsZXQgcmVjIG1pbl9lbHRfb3B0ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gTm9uZVxuICAgICAgfCBOb2Rle2w9RW1wdHk7IHZ9IC0+IFNvbWUgdlxuICAgICAgfCBOb2Rle2x9IC0+IG1pbl9lbHRfb3B0IGxcblxuICAgIGxldCByZWMgbWF4X2VsdCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBOb2Rle3Y7IHI9RW1wdHl9IC0+IHZcbiAgICAgIHwgTm9kZXtyfSAtPiBtYXhfZWx0IHJcblxuICAgIGxldCByZWMgbWF4X2VsdF9vcHQgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBOb25lXG4gICAgICB8IE5vZGV7djsgcj1FbXB0eX0gLT4gU29tZSB2XG4gICAgICB8IE5vZGV7cn0gLT4gbWF4X2VsdF9vcHQgclxuXG4gICAgKCogUmVtb3ZlIHRoZSBzbWFsbGVzdCBlbGVtZW50IG9mIHRoZSBnaXZlbiBzZXQgKilcblxuICAgIGxldCByZWMgcmVtb3ZlX21pbl9lbHQgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBpbnZhbGlkX2FyZyBcIlNldC5yZW1vdmVfbWluX2VsdFwiXG4gICAgICB8IE5vZGV7bD1FbXB0eTsgcn0gLT4gclxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+IGJhbCAocmVtb3ZlX21pbl9lbHQgbCkgdiByXG5cbiAgICAoKiBNZXJnZSB0d28gdHJlZXMgbCBhbmQgciBpbnRvIG9uZS5cbiAgICAgICBBbGwgZWxlbWVudHMgb2YgbCBtdXN0IHByZWNlZGUgdGhlIGVsZW1lbnRzIG9mIHIuXG4gICAgICAgQXNzdW1lIHwgaGVpZ2h0IGwgLSBoZWlnaHQgciB8IDw9IDIuICopXG5cbiAgICBsZXQgbWVyZ2UgdDEgdDIgPVxuICAgICAgbWF0Y2ggKHQxLCB0Mikgd2l0aFxuICAgICAgICAoRW1wdHksIHQpIC0+IHRcbiAgICAgIHwgKHQsIEVtcHR5KSAtPiB0XG4gICAgICB8IChfLCBfKSAtPiBiYWwgdDEgKG1pbl9lbHQgdDIpIChyZW1vdmVfbWluX2VsdCB0MilcblxuICAgICgqIE1lcmdlIHR3byB0cmVlcyBsIGFuZCByIGludG8gb25lLlxuICAgICAgIEFsbCBlbGVtZW50cyBvZiBsIG11c3QgcHJlY2VkZSB0aGUgZWxlbWVudHMgb2Ygci5cbiAgICAgICBObyBhc3N1bXB0aW9uIG9uIHRoZSBoZWlnaHRzIG9mIGwgYW5kIHIuICopXG5cbiAgICBsZXQgY29uY2F0IHQxIHQyID1cbiAgICAgIG1hdGNoICh0MSwgdDIpIHdpdGhcbiAgICAgICAgKEVtcHR5LCB0KSAtPiB0XG4gICAgICB8ICh0LCBFbXB0eSkgLT4gdFxuICAgICAgfCAoXywgXykgLT4gam9pbiB0MSAobWluX2VsdCB0MikgKHJlbW92ZV9taW5fZWx0IHQyKVxuXG4gICAgKCogU3BsaXR0aW5nLiAgc3BsaXQgeCBzIHJldHVybnMgYSB0cmlwbGUgKGwsIHByZXNlbnQsIHIpIHdoZXJlXG4gICAgICAgIC0gbCBpcyB0aGUgc2V0IG9mIGVsZW1lbnRzIG9mIHMgdGhhdCBhcmUgPCB4XG4gICAgICAgIC0gciBpcyB0aGUgc2V0IG9mIGVsZW1lbnRzIG9mIHMgdGhhdCBhcmUgPiB4XG4gICAgICAgIC0gcHJlc2VudCBpcyBmYWxzZSBpZiBzIGNvbnRhaW5zIG5vIGVsZW1lbnQgZXF1YWwgdG8geCxcbiAgICAgICAgICBvciB0cnVlIGlmIHMgY29udGFpbnMgYW4gZWxlbWVudCBlcXVhbCB0byB4LiAqKVxuXG4gICAgbGV0IHJlYyBzcGxpdCB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICAoRW1wdHksIGZhbHNlLCBFbXB0eSlcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiAobCwgdHJ1ZSwgcilcbiAgICAgICAgICBlbHNlIGlmIGMgPCAwIHRoZW5cbiAgICAgICAgICAgIGxldCAobGwsIHByZXMsIHJsKSA9IHNwbGl0IHggbCBpbiAobGwsIHByZXMsIGpvaW4gcmwgdiByKVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxldCAobHIsIHByZXMsIHJyKSA9IHNwbGl0IHggciBpbiAoam9pbiBsIHYgbHIsIHByZXMsIHJyKVxuXG4gICAgKCogSW1wbGVtZW50YXRpb24gb2YgdGhlIHNldCBvcGVyYXRpb25zICopXG5cbiAgICBsZXQgZW1wdHkgPSBFbXB0eVxuXG4gICAgbGV0IGlzX2VtcHR5ID0gZnVuY3Rpb24gRW1wdHkgLT4gdHJ1ZSB8IF8gLT4gZmFsc2VcblxuICAgIGxldCByZWMgbWVtIHggPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBmYWxzZVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBjID0gMCB8fCBtZW0geCAoaWYgYyA8IDAgdGhlbiBsIGVsc2UgcilcblxuICAgIGxldCByZWMgcmVtb3ZlIHggPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBFbXB0eVxuICAgICAgfCAoTm9kZXtsOyB2OyByfSBhcyB0KSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiBtZXJnZSBsIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBpZiBjIDwgMCB0aGVuXG4gICAgICAgICAgICAgIGxldCBsbCA9IHJlbW92ZSB4IGwgaW5cbiAgICAgICAgICAgICAgaWYgbCA9PSBsbCB0aGVuIHRcbiAgICAgICAgICAgICAgZWxzZSBiYWwgbGwgdiByXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGxldCByciA9IHJlbW92ZSB4IHIgaW5cbiAgICAgICAgICAgICAgaWYgciA9PSByciB0aGVuIHRcbiAgICAgICAgICAgICAgZWxzZSBiYWwgbCB2IHJyXG5cbiAgICBsZXQgcmVjIHVuaW9uIHMxIHMyID1cbiAgICAgIG1hdGNoIChzMSwgczIpIHdpdGhcbiAgICAgICAgKEVtcHR5LCB0MikgLT4gdDJcbiAgICAgIHwgKHQxLCBFbXB0eSkgLT4gdDFcbiAgICAgIHwgKE5vZGV7bD1sMTsgdj12MTsgcj1yMTsgaD1oMX0sIE5vZGV7bD1sMjsgdj12Mjsgcj1yMjsgaD1oMn0pIC0+XG4gICAgICAgICAgaWYgaDEgPj0gaDIgdGhlblxuICAgICAgICAgICAgaWYgaDIgPSAxIHRoZW4gYWRkIHYyIHMxIGVsc2UgYmVnaW5cbiAgICAgICAgICAgICAgbGV0IChsMiwgXywgcjIpID0gc3BsaXQgdjEgczIgaW5cbiAgICAgICAgICAgICAgam9pbiAodW5pb24gbDEgbDIpIHYxICh1bmlvbiByMSByMilcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGlmIGgxID0gMSB0aGVuIGFkZCB2MSBzMiBlbHNlIGJlZ2luXG4gICAgICAgICAgICAgIGxldCAobDEsIF8sIHIxKSA9IHNwbGl0IHYyIHMxIGluXG4gICAgICAgICAgICAgIGpvaW4gKHVuaW9uIGwxIGwyKSB2MiAodW5pb24gcjEgcjIpXG4gICAgICAgICAgICBlbmRcblxuICAgIGxldCByZWMgaW50ZXIgczEgczIgPVxuICAgICAgbWF0Y2ggKHMxLCBzMikgd2l0aFxuICAgICAgICAoRW1wdHksIF8pIC0+IEVtcHR5XG4gICAgICB8IChfLCBFbXB0eSkgLT4gRW1wdHlcbiAgICAgIHwgKE5vZGV7bD1sMTsgdj12MTsgcj1yMX0sIHQyKSAtPlxuICAgICAgICAgIG1hdGNoIHNwbGl0IHYxIHQyIHdpdGhcbiAgICAgICAgICAgIChsMiwgZmFsc2UsIHIyKSAtPlxuICAgICAgICAgICAgICBjb25jYXQgKGludGVyIGwxIGwyKSAoaW50ZXIgcjEgcjIpXG4gICAgICAgICAgfCAobDIsIHRydWUsIHIyKSAtPlxuICAgICAgICAgICAgICBqb2luIChpbnRlciBsMSBsMikgdjEgKGludGVyIHIxIHIyKVxuXG4gICAgKCogU2FtZSBhcyBzcGxpdCwgYnV0IGNvbXB1dGUgdGhlIGxlZnQgYW5kIHJpZ2h0IHN1YnRyZWVzXG4gICAgICAgb25seSBpZiB0aGUgcGl2b3QgZWxlbWVudCBpcyBub3QgaW4gdGhlIHNldC4gIFRoZSByaWdodCBzdWJ0cmVlXG4gICAgICAgaXMgY29tcHV0ZWQgb24gZGVtYW5kLiAqKVxuXG4gICAgdHlwZSBzcGxpdF9iaXMgPVxuICAgICAgfCBGb3VuZFxuICAgICAgfCBOb3RGb3VuZCBvZiB0ICogKHVuaXQgLT4gdClcblxuICAgIGxldCByZWMgc3BsaXRfYmlzIHggPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIE5vdEZvdW5kIChFbXB0eSwgKGZ1biAoKSAtPiBFbXB0eSkpXG4gICAgICB8IE5vZGV7bDsgdjsgcjsgX30gLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gRm91bmRcbiAgICAgICAgICBlbHNlIGlmIGMgPCAwIHRoZW5cbiAgICAgICAgICAgIG1hdGNoIHNwbGl0X2JpcyB4IGwgd2l0aFxuICAgICAgICAgICAgfCBGb3VuZCAtPiBGb3VuZFxuICAgICAgICAgICAgfCBOb3RGb3VuZCAobGwsIHJsKSAtPiBOb3RGb3VuZCAobGwsIChmdW4gKCkgLT4gam9pbiAocmwgKCkpIHYgcikpXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbWF0Y2ggc3BsaXRfYmlzIHggciB3aXRoXG4gICAgICAgICAgICB8IEZvdW5kIC0+IEZvdW5kXG4gICAgICAgICAgICB8IE5vdEZvdW5kIChsciwgcnIpIC0+IE5vdEZvdW5kIChqb2luIGwgdiBsciwgcnIpXG5cbiAgICBsZXQgcmVjIGRpc2pvaW50IHMxIHMyID1cbiAgICAgIG1hdGNoIChzMSwgczIpIHdpdGhcbiAgICAgICAgKEVtcHR5LCBfKSB8IChfLCBFbXB0eSkgLT4gdHJ1ZVxuICAgICAgfCAoTm9kZXtsPWwxOyB2PXYxOyByPXIxfSwgdDIpIC0+XG4gICAgICAgICAgaWYgczEgPT0gczIgdGhlbiBmYWxzZVxuICAgICAgICAgIGVsc2UgbWF0Y2ggc3BsaXRfYmlzIHYxIHQyIHdpdGhcbiAgICAgICAgICAgICAgTm90Rm91bmQobDIsIHIyKSAtPiBkaXNqb2ludCBsMSBsMiAmJiBkaXNqb2ludCByMSAocjIgKCkpXG4gICAgICAgICAgICB8IEZvdW5kIC0+IGZhbHNlXG5cbiAgICBsZXQgcmVjIGRpZmYgczEgczIgPVxuICAgICAgbWF0Y2ggKHMxLCBzMikgd2l0aFxuICAgICAgICAoRW1wdHksIF8pIC0+IEVtcHR5XG4gICAgICB8ICh0MSwgRW1wdHkpIC0+IHQxXG4gICAgICB8IChOb2Rle2w9bDE7IHY9djE7IHI9cjF9LCB0MikgLT5cbiAgICAgICAgICBtYXRjaCBzcGxpdCB2MSB0MiB3aXRoXG4gICAgICAgICAgICAobDIsIGZhbHNlLCByMikgLT5cbiAgICAgICAgICAgICAgam9pbiAoZGlmZiBsMSBsMikgdjEgKGRpZmYgcjEgcjIpXG4gICAgICAgICAgfCAobDIsIHRydWUsIHIyKSAtPlxuICAgICAgICAgICAgICBjb25jYXQgKGRpZmYgbDEgbDIpIChkaWZmIHIxIHIyKVxuXG4gICAgdHlwZSBlbnVtZXJhdGlvbiA9IEVuZCB8IE1vcmUgb2YgZWx0ICogdCAqIGVudW1lcmF0aW9uXG5cbiAgICBsZXQgcmVjIGNvbnNfZW51bSBzIGUgPVxuICAgICAgbWF0Y2ggcyB3aXRoXG4gICAgICAgIEVtcHR5IC0+IGVcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPiBjb25zX2VudW0gbCAoTW9yZSh2LCByLCBlKSlcblxuICAgIGxldCByZWMgY29tcGFyZV9hdXggZTEgZTIgPVxuICAgICAgICBtYXRjaCAoZTEsIGUyKSB3aXRoXG4gICAgICAgIChFbmQsIEVuZCkgLT4gMFxuICAgICAgfCAoRW5kLCBfKSAgLT4gLTFcbiAgICAgIHwgKF8sIEVuZCkgLT4gMVxuICAgICAgfCAoTW9yZSh2MSwgcjEsIGUxKSwgTW9yZSh2MiwgcjIsIGUyKSkgLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHYxIHYyIGluXG4gICAgICAgICAgaWYgYyA8PiAwXG4gICAgICAgICAgdGhlbiBjXG4gICAgICAgICAgZWxzZSBjb21wYXJlX2F1eCAoY29uc19lbnVtIHIxIGUxKSAoY29uc19lbnVtIHIyIGUyKVxuXG4gICAgbGV0IGNvbXBhcmUgczEgczIgPVxuICAgICAgY29tcGFyZV9hdXggKGNvbnNfZW51bSBzMSBFbmQpIChjb25zX2VudW0gczIgRW5kKVxuXG4gICAgbGV0IGVxdWFsIHMxIHMyID1cbiAgICAgIGNvbXBhcmUgczEgczIgPSAwXG5cbiAgICBsZXQgcmVjIHN1YnNldCBzMSBzMiA9XG4gICAgICBtYXRjaCAoczEsIHMyKSB3aXRoXG4gICAgICAgIEVtcHR5LCBfIC0+XG4gICAgICAgICAgdHJ1ZVxuICAgICAgfCBfLCBFbXB0eSAtPlxuICAgICAgICAgIGZhbHNlXG4gICAgICB8IE5vZGUge2w9bDE7IHY9djE7IHI9cjF9LCAoTm9kZSB7bD1sMjsgdj12Mjsgcj1yMn0gYXMgdDIpIC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB2MSB2MiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW5cbiAgICAgICAgICAgIHN1YnNldCBsMSBsMiAmJiBzdWJzZXQgcjEgcjJcbiAgICAgICAgICBlbHNlIGlmIGMgPCAwIHRoZW5cbiAgICAgICAgICAgIHN1YnNldCAoTm9kZSB7bD1sMTsgdj12MTsgcj1FbXB0eTsgaD0wfSkgbDIgJiYgc3Vic2V0IHIxIHQyXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgc3Vic2V0IChOb2RlIHtsPUVtcHR5OyB2PXYxOyByPXIxOyBoPTB9KSByMiAmJiBzdWJzZXQgbDEgdDJcblxuICAgIGxldCByZWMgaXRlciBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gKClcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPiBpdGVyIGYgbDsgZiB2OyBpdGVyIGYgclxuXG4gICAgbGV0IHJlYyBmb2xkIGYgcyBhY2N1ID1cbiAgICAgIG1hdGNoIHMgd2l0aFxuICAgICAgICBFbXB0eSAtPiBhY2N1XG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT4gZm9sZCBmIHIgKGYgdiAoZm9sZCBmIGwgYWNjdSkpXG5cbiAgICBsZXQgcmVjIGZvcl9hbGwgcCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IHRydWVcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPiBwIHYgJiYgZm9yX2FsbCBwIGwgJiYgZm9yX2FsbCBwIHJcblxuICAgIGxldCByZWMgZXhpc3RzIHAgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBmYWxzZVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+IHAgdiB8fCBleGlzdHMgcCBsIHx8IGV4aXN0cyBwIHJcblxuICAgIGxldCByZWMgZmlsdGVyIHAgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBFbXB0eVxuICAgICAgfCAoTm9kZXtsOyB2OyByfSkgYXMgdCAtPlxuICAgICAgICAgICgqIGNhbGwgW3BdIGluIHRoZSBleHBlY3RlZCBsZWZ0LXRvLXJpZ2h0IG9yZGVyICopXG4gICAgICAgICAgbGV0IGwnID0gZmlsdGVyIHAgbCBpblxuICAgICAgICAgIGxldCBwdiA9IHAgdiBpblxuICAgICAgICAgIGxldCByJyA9IGZpbHRlciBwIHIgaW5cbiAgICAgICAgICBpZiBwdiB0aGVuXG4gICAgICAgICAgICBpZiBsPT1sJyAmJiByPT1yJyB0aGVuIHQgZWxzZSBqb2luIGwnIHYgcidcbiAgICAgICAgICBlbHNlIGNvbmNhdCBsJyByJ1xuXG4gICAgbGV0IHJlYyBwYXJ0aXRpb24gcCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IChFbXB0eSwgRW1wdHkpXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICAoKiBjYWxsIFtwXSBpbiB0aGUgZXhwZWN0ZWQgbGVmdC10by1yaWdodCBvcmRlciAqKVxuICAgICAgICAgIGxldCAobHQsIGxmKSA9IHBhcnRpdGlvbiBwIGwgaW5cbiAgICAgICAgICBsZXQgcHYgPSBwIHYgaW5cbiAgICAgICAgICBsZXQgKHJ0LCByZikgPSBwYXJ0aXRpb24gcCByIGluXG4gICAgICAgICAgaWYgcHZcbiAgICAgICAgICB0aGVuIChqb2luIGx0IHYgcnQsIGNvbmNhdCBsZiByZilcbiAgICAgICAgICBlbHNlIChjb25jYXQgbHQgcnQsIGpvaW4gbGYgdiByZilcblxuICAgIGxldCByZWMgY2FyZGluYWwgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiAwXG4gICAgICB8IE5vZGV7bDsgcn0gLT4gY2FyZGluYWwgbCArIDEgKyBjYXJkaW5hbCByXG5cbiAgICBsZXQgcmVjIGVsZW1lbnRzX2F1eCBhY2N1ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gYWNjdVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+IGVsZW1lbnRzX2F1eCAodiA6OiBlbGVtZW50c19hdXggYWNjdSByKSBsXG5cbiAgICBsZXQgZWxlbWVudHMgcyA9XG4gICAgICBlbGVtZW50c19hdXggW10gc1xuXG4gICAgbGV0IGNob29zZSA9IG1pbl9lbHRcblxuICAgIGxldCBjaG9vc2Vfb3B0ID0gbWluX2VsdF9vcHRcblxuICAgIGxldCByZWMgZmluZCB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gdlxuICAgICAgICAgIGVsc2UgZmluZCB4IChpZiBjIDwgMCB0aGVuIGwgZWxzZSByKVxuXG4gICAgbGV0IHJlYyBmaW5kX2ZpcnN0X2F1eCB2MCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICB2MFxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfZmlyc3RfYXV4IHYgZiBsXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9maXJzdF9hdXggdjAgZiByXG5cbiAgICBsZXQgcmVjIGZpbmRfZmlyc3QgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9maXJzdF9hdXggdiBmIGxcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2ZpcnN0IGYgclxuXG4gICAgbGV0IHJlYyBmaW5kX2ZpcnN0X29wdF9hdXggdjAgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgU29tZSB2MFxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfZmlyc3Rfb3B0X2F1eCB2IGYgbFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfZmlyc3Rfb3B0X2F1eCB2MCBmIHJcblxuICAgIGxldCByZWMgZmluZF9maXJzdF9vcHQgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgTm9uZVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfZmlyc3Rfb3B0X2F1eCB2IGYgbFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfZmlyc3Rfb3B0IGYgclxuXG4gICAgbGV0IHJlYyBmaW5kX2xhc3RfYXV4IHYwIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIHYwXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9sYXN0X2F1eCB2IGYgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfbGFzdF9hdXggdjAgZiBsXG5cbiAgICBsZXQgcmVjIGZpbmRfbGFzdCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2xhc3RfYXV4IHYgZiByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9sYXN0IGYgbFxuXG4gICAgbGV0IHJlYyBmaW5kX2xhc3Rfb3B0X2F1eCB2MCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBTb21lIHYwXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9sYXN0X29wdF9hdXggdiBmIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2xhc3Rfb3B0X2F1eCB2MCBmIGxcblxuICAgIGxldCByZWMgZmluZF9sYXN0X29wdCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBOb25lXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9sYXN0X29wdF9hdXggdiBmIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2xhc3Rfb3B0IGYgbFxuXG4gICAgbGV0IHJlYyBmaW5kX29wdCB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gTm9uZVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuIFNvbWUgdlxuICAgICAgICAgIGVsc2UgZmluZF9vcHQgeCAoaWYgYyA8IDAgdGhlbiBsIGVsc2UgcilcblxuICAgIGxldCB0cnlfam9pbiBsIHYgciA9XG4gICAgICAoKiBbam9pbiBsIHYgcl0gY2FuIG9ubHkgYmUgY2FsbGVkIHdoZW4gKGVsZW1lbnRzIG9mIGwgPCB2IDxcbiAgICAgICAgIGVsZW1lbnRzIG9mIHIpOyB1c2UgW3RyeV9qb2luIGwgdiByXSB3aGVuIHRoaXMgcHJvcGVydHkgbWF5XG4gICAgICAgICBub3QgaG9sZCwgYnV0IHlvdSBob3BlIGl0IGRvZXMgaG9sZCBpbiB0aGUgY29tbW9uIGNhc2UgKilcbiAgICAgIGlmIChsID0gRW1wdHkgfHwgT3JkLmNvbXBhcmUgKG1heF9lbHQgbCkgdiA8IDApXG4gICAgICAmJiAociA9IEVtcHR5IHx8IE9yZC5jb21wYXJlIHYgKG1pbl9lbHQgcikgPCAwKVxuICAgICAgdGhlbiBqb2luIGwgdiByXG4gICAgICBlbHNlIHVuaW9uIGwgKGFkZCB2IHIpXG5cbiAgICBsZXQgcmVjIG1hcCBmID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT4gRW1wdHlcbiAgICAgIHwgTm9kZXtsOyB2OyByfSBhcyB0IC0+XG4gICAgICAgICAoKiBlbmZvcmNlIGxlZnQtdG8tcmlnaHQgZXZhbHVhdGlvbiBvcmRlciAqKVxuICAgICAgICAgbGV0IGwnID0gbWFwIGYgbCBpblxuICAgICAgICAgbGV0IHYnID0gZiB2IGluXG4gICAgICAgICBsZXQgcicgPSBtYXAgZiByIGluXG4gICAgICAgICBpZiBsID09IGwnICYmIHYgPT0gdicgJiYgciA9PSByJyB0aGVuIHRcbiAgICAgICAgIGVsc2UgdHJ5X2pvaW4gbCcgdicgcidcblxuICAgIGxldCB0cnlfY29uY2F0IHQxIHQyID1cbiAgICAgIG1hdGNoICh0MSwgdDIpIHdpdGhcbiAgICAgICAgKEVtcHR5LCB0KSAtPiB0XG4gICAgICB8ICh0LCBFbXB0eSkgLT4gdFxuICAgICAgfCAoXywgXykgLT4gdHJ5X2pvaW4gdDEgKG1pbl9lbHQgdDIpIChyZW1vdmVfbWluX2VsdCB0MilcblxuICAgIGxldCByZWMgZmlsdGVyX21hcCBmID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT4gRW1wdHlcbiAgICAgIHwgTm9kZXtsOyB2OyByfSBhcyB0IC0+XG4gICAgICAgICAoKiBlbmZvcmNlIGxlZnQtdG8tcmlnaHQgZXZhbHVhdGlvbiBvcmRlciAqKVxuICAgICAgICAgbGV0IGwnID0gZmlsdGVyX21hcCBmIGwgaW5cbiAgICAgICAgIGxldCB2JyA9IGYgdiBpblxuICAgICAgICAgbGV0IHInID0gZmlsdGVyX21hcCBmIHIgaW5cbiAgICAgICAgIGJlZ2luIG1hdGNoIHYnIHdpdGhcbiAgICAgICAgICAgfCBTb21lIHYnIC0+XG4gICAgICAgICAgICAgIGlmIGwgPT0gbCcgJiYgdiA9PSB2JyAmJiByID09IHInIHRoZW4gdFxuICAgICAgICAgICAgICBlbHNlIHRyeV9qb2luIGwnIHYnIHInXG4gICAgICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgICAgICB0cnlfY29uY2F0IGwnIHInXG4gICAgICAgICBlbmRcblxuICAgIGxldCBvZl9zb3J0ZWRfbGlzdCBsID1cbiAgICAgIGxldCByZWMgc3ViIG4gbCA9XG4gICAgICAgIG1hdGNoIG4sIGwgd2l0aFxuICAgICAgICB8IDAsIGwgLT4gRW1wdHksIGxcbiAgICAgICAgfCAxLCB4MCA6OiBsIC0+IE5vZGUge2w9RW1wdHk7IHY9eDA7IHI9RW1wdHk7IGg9MX0sIGxcbiAgICAgICAgfCAyLCB4MCA6OiB4MSA6OiBsIC0+XG4gICAgICAgICAgICBOb2Rle2w9Tm9kZXtsPUVtcHR5OyB2PXgwOyByPUVtcHR5OyBoPTF9OyB2PXgxOyByPUVtcHR5OyBoPTJ9LCBsXG4gICAgICAgIHwgMywgeDAgOjogeDEgOjogeDIgOjogbCAtPlxuICAgICAgICAgICAgTm9kZXtsPU5vZGV7bD1FbXB0eTsgdj14MDsgcj1FbXB0eTsgaD0xfTsgdj14MTtcbiAgICAgICAgICAgICAgICAgcj1Ob2Rle2w9RW1wdHk7IHY9eDI7IHI9RW1wdHk7IGg9MX07IGg9Mn0sIGxcbiAgICAgICAgfCBuLCBsIC0+XG4gICAgICAgICAgbGV0IG5sID0gbiAvIDIgaW5cbiAgICAgICAgICBsZXQgbGVmdCwgbCA9IHN1YiBubCBsIGluXG4gICAgICAgICAgbWF0Y2ggbCB3aXRoXG4gICAgICAgICAgfCBbXSAtPiBhc3NlcnQgZmFsc2VcbiAgICAgICAgICB8IG1pZCA6OiBsIC0+XG4gICAgICAgICAgICBsZXQgcmlnaHQsIGwgPSBzdWIgKG4gLSBubCAtIDEpIGwgaW5cbiAgICAgICAgICAgIGNyZWF0ZSBsZWZ0IG1pZCByaWdodCwgbFxuICAgICAgaW5cbiAgICAgIGZzdCAoc3ViIChMaXN0Lmxlbmd0aCBsKSBsKVxuXG4gICAgbGV0IG9mX2xpc3QgbCA9XG4gICAgICBtYXRjaCBsIHdpdGhcbiAgICAgIHwgW10gLT4gZW1wdHlcbiAgICAgIHwgW3gwXSAtPiBzaW5nbGV0b24geDBcbiAgICAgIHwgW3gwOyB4MV0gLT4gYWRkIHgxIChzaW5nbGV0b24geDApXG4gICAgICB8IFt4MDsgeDE7IHgyXSAtPiBhZGQgeDIgKGFkZCB4MSAoc2luZ2xldG9uIHgwKSlcbiAgICAgIHwgW3gwOyB4MTsgeDI7IHgzXSAtPiBhZGQgeDMgKGFkZCB4MiAoYWRkIHgxIChzaW5nbGV0b24geDApKSlcbiAgICAgIHwgW3gwOyB4MTsgeDI7IHgzOyB4NF0gLT4gYWRkIHg0IChhZGQgeDMgKGFkZCB4MiAoYWRkIHgxIChzaW5nbGV0b24geDApKSkpXG4gICAgICB8IF8gLT4gb2Zfc29ydGVkX2xpc3QgKExpc3Quc29ydF91bmlxIE9yZC5jb21wYXJlIGwpXG5cbiAgICBsZXQgYWRkX3NlcSBpIG0gPVxuICAgICAgU2VxLmZvbGRfbGVmdCAoZnVuIHMgeCAtPiBhZGQgeCBzKSBtIGlcblxuICAgIGxldCBvZl9zZXEgaSA9IGFkZF9zZXEgaSBlbXB0eVxuXG4gICAgbGV0IHJlYyBzZXFfb2ZfZW51bV8gYyAoKSA9IG1hdGNoIGMgd2l0aFxuICAgICAgfCBFbmQgLT4gU2VxLk5pbFxuICAgICAgfCBNb3JlICh4LCB0LCByZXN0KSAtPiBTZXEuQ29ucyAoeCwgc2VxX29mX2VudW1fIChjb25zX2VudW0gdCByZXN0KSlcblxuICAgIGxldCB0b19zZXEgYyA9IHNlcV9vZl9lbnVtXyAoY29uc19lbnVtIGMgRW5kKVxuXG4gICAgbGV0IHJlYyBzbm9jX2VudW0gcyBlID1cbiAgICAgIG1hdGNoIHMgd2l0aFxuICAgICAgICBFbXB0eSAtPiBlXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT4gc25vY19lbnVtIHIgKE1vcmUodiwgbCwgZSkpXG5cbiAgICBsZXQgcmVjIHJldl9zZXFfb2ZfZW51bV8gYyAoKSA9IG1hdGNoIGMgd2l0aFxuICAgICAgfCBFbmQgLT4gU2VxLk5pbFxuICAgICAgfCBNb3JlICh4LCB0LCByZXN0KSAtPiBTZXEuQ29ucyAoeCwgcmV2X3NlcV9vZl9lbnVtXyAoc25vY19lbnVtIHQgcmVzdCkpXG5cbiAgICBsZXQgdG9fcmV2X3NlcSBjID0gcmV2X3NlcV9vZl9lbnVtXyAoc25vY19lbnVtIGMgRW5kKVxuXG4gICAgbGV0IHRvX3NlcV9mcm9tIGxvdyBzID1cbiAgICAgIGxldCByZWMgYXV4IGxvdyBzIGMgPSBtYXRjaCBzIHdpdGhcbiAgICAgICAgfCBFbXB0eSAtPiBjXG4gICAgICAgIHwgTm9kZSB7bDsgcjsgdjsgX30gLT5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIE9yZC5jb21wYXJlIHYgbG93IHdpdGhcbiAgICAgICAgICAgICAgfCAwIC0+IE1vcmUgKHYsIHIsIGMpXG4gICAgICAgICAgICAgIHwgbiB3aGVuIG48MCAtPiBhdXggbG93IHIgY1xuICAgICAgICAgICAgICB8IF8gLT4gYXV4IGxvdyBsIChNb3JlICh2LCByLCBjKSlcbiAgICAgICAgICAgIGVuZFxuICAgICAgaW5cbiAgICAgIHNlcV9vZl9lbnVtXyAoYXV4IGxvdyBzIEVuZClcbiAgZW5kXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbm1vZHVsZSB0eXBlIE9yZGVyZWRUeXBlID1cbiAgc2lnXG4gICAgdHlwZSB0XG4gICAgdmFsIGNvbXBhcmU6IHQgLT4gdCAtPiBpbnRcbiAgZW5kXG5cbm1vZHVsZSB0eXBlIFMgPVxuICBzaWdcbiAgICB0eXBlIGtleVxuICAgIHR5cGUgISsnYSB0XG4gICAgdmFsIGVtcHR5OiAnYSB0XG4gICAgdmFsIGlzX2VtcHR5OiAnYSB0IC0+IGJvb2xcbiAgICB2YWwgbWVtOiAga2V5IC0+ICdhIHQgLT4gYm9vbFxuICAgIHZhbCBhZGQ6IGtleSAtPiAnYSAtPiAnYSB0IC0+ICdhIHRcbiAgICB2YWwgdXBkYXRlOiBrZXkgLT4gKCdhIG9wdGlvbiAtPiAnYSBvcHRpb24pIC0+ICdhIHQgLT4gJ2EgdFxuICAgIHZhbCBzaW5nbGV0b246IGtleSAtPiAnYSAtPiAnYSB0XG4gICAgdmFsIHJlbW92ZToga2V5IC0+ICdhIHQgLT4gJ2EgdFxuICAgIHZhbCBtZXJnZTpcbiAgICAgICAgICAoa2V5IC0+ICdhIG9wdGlvbiAtPiAnYiBvcHRpb24gLT4gJ2Mgb3B0aW9uKSAtPiAnYSB0IC0+ICdiIHQgLT4gJ2MgdFxuICAgIHZhbCB1bmlvbjogKGtleSAtPiAnYSAtPiAnYSAtPiAnYSBvcHRpb24pIC0+ICdhIHQgLT4gJ2EgdCAtPiAnYSB0XG4gICAgdmFsIGNvbXBhcmU6ICgnYSAtPiAnYSAtPiBpbnQpIC0+ICdhIHQgLT4gJ2EgdCAtPiBpbnRcbiAgICB2YWwgZXF1YWw6ICgnYSAtPiAnYSAtPiBib29sKSAtPiAnYSB0IC0+ICdhIHQgLT4gYm9vbFxuICAgIHZhbCBpdGVyOiAoa2V5IC0+ICdhIC0+IHVuaXQpIC0+ICdhIHQgLT4gdW5pdFxuICAgIHZhbCBmb2xkOiAoa2V5IC0+ICdhIC0+ICdiIC0+ICdiKSAtPiAnYSB0IC0+ICdiIC0+ICdiXG4gICAgdmFsIGZvcl9hbGw6IChrZXkgLT4gJ2EgLT4gYm9vbCkgLT4gJ2EgdCAtPiBib29sXG4gICAgdmFsIGV4aXN0czogKGtleSAtPiAnYSAtPiBib29sKSAtPiAnYSB0IC0+IGJvb2xcbiAgICB2YWwgZmlsdGVyOiAoa2V5IC0+ICdhIC0+IGJvb2wpIC0+ICdhIHQgLT4gJ2EgdFxuICAgIHZhbCBmaWx0ZXJfbWFwOiAoa2V5IC0+ICdhIC0+ICdiIG9wdGlvbikgLT4gJ2EgdCAtPiAnYiB0XG4gICAgdmFsIHBhcnRpdGlvbjogKGtleSAtPiAnYSAtPiBib29sKSAtPiAnYSB0IC0+ICdhIHQgKiAnYSB0XG4gICAgdmFsIGNhcmRpbmFsOiAnYSB0IC0+IGludFxuICAgIHZhbCBiaW5kaW5nczogJ2EgdCAtPiAoa2V5ICogJ2EpIGxpc3RcbiAgICB2YWwgbWluX2JpbmRpbmc6ICdhIHQgLT4gKGtleSAqICdhKVxuICAgIHZhbCBtaW5fYmluZGluZ19vcHQ6ICdhIHQgLT4gKGtleSAqICdhKSBvcHRpb25cbiAgICB2YWwgbWF4X2JpbmRpbmc6ICdhIHQgLT4gKGtleSAqICdhKVxuICAgIHZhbCBtYXhfYmluZGluZ19vcHQ6ICdhIHQgLT4gKGtleSAqICdhKSBvcHRpb25cbiAgICB2YWwgY2hvb3NlOiAnYSB0IC0+IChrZXkgKiAnYSlcbiAgICB2YWwgY2hvb3NlX29wdDogJ2EgdCAtPiAoa2V5ICogJ2EpIG9wdGlvblxuICAgIHZhbCBzcGxpdDoga2V5IC0+ICdhIHQgLT4gJ2EgdCAqICdhIG9wdGlvbiAqICdhIHRcbiAgICB2YWwgZmluZDoga2V5IC0+ICdhIHQgLT4gJ2FcbiAgICB2YWwgZmluZF9vcHQ6IGtleSAtPiAnYSB0IC0+ICdhIG9wdGlvblxuICAgIHZhbCBmaW5kX2ZpcnN0OiAoa2V5IC0+IGJvb2wpIC0+ICdhIHQgLT4ga2V5ICogJ2FcbiAgICB2YWwgZmluZF9maXJzdF9vcHQ6IChrZXkgLT4gYm9vbCkgLT4gJ2EgdCAtPiAoa2V5ICogJ2EpIG9wdGlvblxuICAgIHZhbCBmaW5kX2xhc3Q6IChrZXkgLT4gYm9vbCkgLT4gJ2EgdCAtPiBrZXkgKiAnYVxuICAgIHZhbCBmaW5kX2xhc3Rfb3B0OiAoa2V5IC0+IGJvb2wpIC0+ICdhIHQgLT4gKGtleSAqICdhKSBvcHRpb25cbiAgICB2YWwgbWFwOiAoJ2EgLT4gJ2IpIC0+ICdhIHQgLT4gJ2IgdFxuICAgIHZhbCBtYXBpOiAoa2V5IC0+ICdhIC0+ICdiKSAtPiAnYSB0IC0+ICdiIHRcbiAgICB2YWwgdG9fc2VxIDogJ2EgdCAtPiAoa2V5ICogJ2EpIFNlcS50XG4gICAgdmFsIHRvX3Jldl9zZXEgOiAnYSB0IC0+IChrZXkgKiAnYSkgU2VxLnRcbiAgICB2YWwgdG9fc2VxX2Zyb20gOiBrZXkgLT4gJ2EgdCAtPiAoa2V5ICogJ2EpIFNlcS50XG4gICAgdmFsIGFkZF9zZXEgOiAoa2V5ICogJ2EpIFNlcS50IC0+ICdhIHQgLT4gJ2EgdFxuICAgIHZhbCBvZl9zZXEgOiAoa2V5ICogJ2EpIFNlcS50IC0+ICdhIHRcbiAgZW5kXG5cbm1vZHVsZSBNYWtlKE9yZDogT3JkZXJlZFR5cGUpID0gc3RydWN0XG5cbiAgICB0eXBlIGtleSA9IE9yZC50XG5cbiAgICB0eXBlICdhIHQgPVxuICAgICAgICBFbXB0eVxuICAgICAgfCBOb2RlIG9mIHtsOidhIHQ7IHY6a2V5OyBkOidhOyByOidhIHQ7IGg6aW50fVxuXG4gICAgbGV0IGhlaWdodCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IDBcbiAgICAgIHwgTm9kZSB7aH0gLT4gaFxuXG4gICAgbGV0IGNyZWF0ZSBsIHggZCByID1cbiAgICAgIGxldCBobCA9IGhlaWdodCBsIGFuZCBociA9IGhlaWdodCByIGluXG4gICAgICBOb2Rle2w7IHY9eDsgZDsgcjsgaD0oaWYgaGwgPj0gaHIgdGhlbiBobCArIDEgZWxzZSBociArIDEpfVxuXG4gICAgbGV0IHNpbmdsZXRvbiB4IGQgPSBOb2Rle2w9RW1wdHk7IHY9eDsgZDsgcj1FbXB0eTsgaD0xfVxuXG4gICAgbGV0IGJhbCBsIHggZCByID1cbiAgICAgIGxldCBobCA9IG1hdGNoIGwgd2l0aCBFbXB0eSAtPiAwIHwgTm9kZSB7aH0gLT4gaCBpblxuICAgICAgbGV0IGhyID0gbWF0Y2ggciB3aXRoIEVtcHR5IC0+IDAgfCBOb2RlIHtofSAtPiBoIGluXG4gICAgICBpZiBobCA+IGhyICsgMiB0aGVuIGJlZ2luXG4gICAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgICAgIEVtcHR5IC0+IGludmFsaWRfYXJnIFwiTWFwLmJhbFwiXG4gICAgICAgIHwgTm9kZXtsPWxsOyB2PWx2OyBkPWxkOyByPWxyfSAtPlxuICAgICAgICAgICAgaWYgaGVpZ2h0IGxsID49IGhlaWdodCBsciB0aGVuXG4gICAgICAgICAgICAgIGNyZWF0ZSBsbCBsdiBsZCAoY3JlYXRlIGxyIHggZCByKVxuICAgICAgICAgICAgZWxzZSBiZWdpblxuICAgICAgICAgICAgICBtYXRjaCBsciB3aXRoXG4gICAgICAgICAgICAgICAgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJNYXAuYmFsXCJcbiAgICAgICAgICAgICAgfCBOb2Rle2w9bHJsOyB2PWxydjsgZD1scmQ7IHI9bHJyfS0+XG4gICAgICAgICAgICAgICAgICBjcmVhdGUgKGNyZWF0ZSBsbCBsdiBsZCBscmwpIGxydiBscmQgKGNyZWF0ZSBscnIgeCBkIHIpXG4gICAgICAgICAgICBlbmRcbiAgICAgIGVuZCBlbHNlIGlmIGhyID4gaGwgKyAyIHRoZW4gYmVnaW5cbiAgICAgICAgbWF0Y2ggciB3aXRoXG4gICAgICAgICAgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJNYXAuYmFsXCJcbiAgICAgICAgfCBOb2Rle2w9cmw7IHY9cnY7IGQ9cmQ7IHI9cnJ9IC0+XG4gICAgICAgICAgICBpZiBoZWlnaHQgcnIgPj0gaGVpZ2h0IHJsIHRoZW5cbiAgICAgICAgICAgICAgY3JlYXRlIChjcmVhdGUgbCB4IGQgcmwpIHJ2IHJkIHJyXG4gICAgICAgICAgICBlbHNlIGJlZ2luXG4gICAgICAgICAgICAgIG1hdGNoIHJsIHdpdGhcbiAgICAgICAgICAgICAgICBFbXB0eSAtPiBpbnZhbGlkX2FyZyBcIk1hcC5iYWxcIlxuICAgICAgICAgICAgICB8IE5vZGV7bD1ybGw7IHY9cmx2OyBkPXJsZDsgcj1ybHJ9IC0+XG4gICAgICAgICAgICAgICAgICBjcmVhdGUgKGNyZWF0ZSBsIHggZCBybGwpIHJsdiBybGQgKGNyZWF0ZSBybHIgcnYgcmQgcnIpXG4gICAgICAgICAgICBlbmRcbiAgICAgIGVuZCBlbHNlXG4gICAgICAgIE5vZGV7bDsgdj14OyBkOyByOyBoPShpZiBobCA+PSBociB0aGVuIGhsICsgMSBlbHNlIGhyICsgMSl9XG5cbiAgICBsZXQgZW1wdHkgPSBFbXB0eVxuXG4gICAgbGV0IGlzX2VtcHR5ID0gZnVuY3Rpb24gRW1wdHkgLT4gdHJ1ZSB8IF8gLT4gZmFsc2VcblxuICAgIGxldCByZWMgYWRkIHggZGF0YSA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgTm9kZXtsPUVtcHR5OyB2PXg7IGQ9ZGF0YTsgcj1FbXB0eTsgaD0xfVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByOyBofSBhcyBtIC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuXG4gICAgICAgICAgICBpZiBkID09IGRhdGEgdGhlbiBtIGVsc2UgTm9kZXtsOyB2PXg7IGQ9ZGF0YTsgcjsgaH1cbiAgICAgICAgICBlbHNlIGlmIGMgPCAwIHRoZW5cbiAgICAgICAgICAgIGxldCBsbCA9IGFkZCB4IGRhdGEgbCBpblxuICAgICAgICAgICAgaWYgbCA9PSBsbCB0aGVuIG0gZWxzZSBiYWwgbGwgdiBkIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsZXQgcnIgPSBhZGQgeCBkYXRhIHIgaW5cbiAgICAgICAgICAgIGlmIHIgPT0gcnIgdGhlbiBtIGVsc2UgYmFsIGwgdiBkIHJyXG5cbiAgICBsZXQgcmVjIGZpbmQgeCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuIGRcbiAgICAgICAgICBlbHNlIGZpbmQgeCAoaWYgYyA8IDAgdGhlbiBsIGVsc2UgcilcblxuICAgIGxldCByZWMgZmluZF9maXJzdF9hdXggdjAgZDAgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgKHYwLCBkMClcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9maXJzdF9hdXggdiBkIGYgbFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfZmlyc3RfYXV4IHYwIGQwIGYgclxuXG4gICAgbGV0IHJlYyBmaW5kX2ZpcnN0IGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X2F1eCB2IGQgZiBsXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9maXJzdCBmIHJcblxuICAgIGxldCByZWMgZmluZF9maXJzdF9vcHRfYXV4IHYwIGQwIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIFNvbWUgKHYwLCBkMClcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9maXJzdF9vcHRfYXV4IHYgZCBmIGxcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X29wdF9hdXggdjAgZDAgZiByXG5cbiAgICBsZXQgcmVjIGZpbmRfZmlyc3Rfb3B0IGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIE5vbmVcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9maXJzdF9vcHRfYXV4IHYgZCBmIGxcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X29wdCBmIHJcblxuICAgIGxldCByZWMgZmluZF9sYXN0X2F1eCB2MCBkMCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICAodjAsIGQwKVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2xhc3RfYXV4IHYgZCBmIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2xhc3RfYXV4IHYwIGQwIGYgbFxuXG4gICAgbGV0IHJlYyBmaW5kX2xhc3QgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfbGFzdF9hdXggdiBkIGYgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfbGFzdCBmIGxcblxuICAgIGxldCByZWMgZmluZF9sYXN0X29wdF9hdXggdjAgZDAgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgU29tZSAodjAsIGQwKVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2xhc3Rfb3B0X2F1eCB2IGQgZiByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9sYXN0X29wdF9hdXggdjAgZDAgZiBsXG5cbiAgICBsZXQgcmVjIGZpbmRfbGFzdF9vcHQgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgTm9uZVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2xhc3Rfb3B0X2F1eCB2IGQgZiByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9sYXN0X29wdCBmIGxcblxuICAgIGxldCByZWMgZmluZF9vcHQgeCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgTm9uZVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiBTb21lIGRcbiAgICAgICAgICBlbHNlIGZpbmRfb3B0IHggKGlmIGMgPCAwIHRoZW4gbCBlbHNlIHIpXG5cbiAgICBsZXQgcmVjIG1lbSB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBmYWxzZVxuICAgICAgfCBOb2RlIHtsOyB2OyByfSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgYyA9IDAgfHwgbWVtIHggKGlmIGMgPCAwIHRoZW4gbCBlbHNlIHIpXG5cbiAgICBsZXQgcmVjIG1pbl9iaW5kaW5nID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IE5vZGUge2w9RW1wdHk7IHY7IGR9IC0+ICh2LCBkKVxuICAgICAgfCBOb2RlIHtsfSAtPiBtaW5fYmluZGluZyBsXG5cbiAgICBsZXQgcmVjIG1pbl9iaW5kaW5nX29wdCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IE5vbmVcbiAgICAgIHwgTm9kZSB7bD1FbXB0eTsgdjsgZH0gLT4gU29tZSAodiwgZClcbiAgICAgIHwgTm9kZSB7bH0tPiBtaW5fYmluZGluZ19vcHQgbFxuXG4gICAgbGV0IHJlYyBtYXhfYmluZGluZyA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBOb2RlIHt2OyBkOyByPUVtcHR5fSAtPiAodiwgZClcbiAgICAgIHwgTm9kZSB7cn0gLT4gbWF4X2JpbmRpbmcgclxuXG4gICAgbGV0IHJlYyBtYXhfYmluZGluZ19vcHQgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBOb25lXG4gICAgICB8IE5vZGUge3Y7IGQ7IHI9RW1wdHl9IC0+IFNvbWUgKHYsIGQpXG4gICAgICB8IE5vZGUge3J9IC0+IG1heF9iaW5kaW5nX29wdCByXG5cbiAgICBsZXQgcmVjIHJlbW92ZV9taW5fYmluZGluZyA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IGludmFsaWRfYXJnIFwiTWFwLnJlbW92ZV9taW5fZWx0XCJcbiAgICAgIHwgTm9kZSB7bD1FbXB0eTsgcn0gLT4gclxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPiBiYWwgKHJlbW92ZV9taW5fYmluZGluZyBsKSB2IGQgclxuXG4gICAgbGV0IG1lcmdlIHQxIHQyID1cbiAgICAgIG1hdGNoICh0MSwgdDIpIHdpdGhcbiAgICAgICAgKEVtcHR5LCB0KSAtPiB0XG4gICAgICB8ICh0LCBFbXB0eSkgLT4gdFxuICAgICAgfCAoXywgXykgLT5cbiAgICAgICAgICBsZXQgKHgsIGQpID0gbWluX2JpbmRpbmcgdDIgaW5cbiAgICAgICAgICBiYWwgdDEgeCBkIChyZW1vdmVfbWluX2JpbmRpbmcgdDIpXG5cbiAgICBsZXQgcmVjIHJlbW92ZSB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBFbXB0eVxuICAgICAgfCAoTm9kZSB7bDsgdjsgZDsgcn0gYXMgbSkgLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gbWVyZ2UgbCByXG4gICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuXG4gICAgICAgICAgICBsZXQgbGwgPSByZW1vdmUgeCBsIGluIGlmIGwgPT0gbGwgdGhlbiBtIGVsc2UgYmFsIGxsIHYgZCByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbGV0IHJyID0gcmVtb3ZlIHggciBpbiBpZiByID09IHJyIHRoZW4gbSBlbHNlIGJhbCBsIHYgZCByclxuXG4gICAgbGV0IHJlYyB1cGRhdGUgeCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBiZWdpbiBtYXRjaCBmIE5vbmUgd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPiBFbXB0eVxuICAgICAgICAgIHwgU29tZSBkYXRhIC0+IE5vZGV7bD1FbXB0eTsgdj14OyBkPWRhdGE7IHI9RW1wdHk7IGg9MX1cbiAgICAgICAgICBlbmRcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcjsgaH0gYXMgbSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiBiZWdpblxuICAgICAgICAgICAgbWF0Y2ggZiAoU29tZSBkKSB3aXRoXG4gICAgICAgICAgICB8IE5vbmUgLT4gbWVyZ2UgbCByXG4gICAgICAgICAgICB8IFNvbWUgZGF0YSAtPlxuICAgICAgICAgICAgICAgIGlmIGQgPT0gZGF0YSB0aGVuIG0gZWxzZSBOb2Rle2w7IHY9eDsgZD1kYXRhOyByOyBofVxuICAgICAgICAgIGVuZCBlbHNlIGlmIGMgPCAwIHRoZW5cbiAgICAgICAgICAgIGxldCBsbCA9IHVwZGF0ZSB4IGYgbCBpblxuICAgICAgICAgICAgaWYgbCA9PSBsbCB0aGVuIG0gZWxzZSBiYWwgbGwgdiBkIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsZXQgcnIgPSB1cGRhdGUgeCBmIHIgaW5cbiAgICAgICAgICAgIGlmIHIgPT0gcnIgdGhlbiBtIGVsc2UgYmFsIGwgdiBkIHJyXG5cbiAgICBsZXQgcmVjIGl0ZXIgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+ICgpXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgaXRlciBmIGw7IGYgdiBkOyBpdGVyIGYgclxuXG4gICAgbGV0IHJlYyBtYXAgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgRW1wdHlcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcjsgaH0gLT5cbiAgICAgICAgICBsZXQgbCcgPSBtYXAgZiBsIGluXG4gICAgICAgICAgbGV0IGQnID0gZiBkIGluXG4gICAgICAgICAgbGV0IHInID0gbWFwIGYgciBpblxuICAgICAgICAgIE5vZGV7bD1sJzsgdjsgZD1kJzsgcj1yJzsgaH1cblxuICAgIGxldCByZWMgbWFwaSBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBFbXB0eVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByOyBofSAtPlxuICAgICAgICAgIGxldCBsJyA9IG1hcGkgZiBsIGluXG4gICAgICAgICAgbGV0IGQnID0gZiB2IGQgaW5cbiAgICAgICAgICBsZXQgcicgPSBtYXBpIGYgciBpblxuICAgICAgICAgIE5vZGV7bD1sJzsgdjsgZD1kJzsgcj1yJzsgaH1cblxuICAgIGxldCByZWMgZm9sZCBmIG0gYWNjdSA9XG4gICAgICBtYXRjaCBtIHdpdGhcbiAgICAgICAgRW1wdHkgLT4gYWNjdVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGZvbGQgZiByIChmIHYgZCAoZm9sZCBmIGwgYWNjdSkpXG5cbiAgICBsZXQgcmVjIGZvcl9hbGwgcCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IHRydWVcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT4gcCB2IGQgJiYgZm9yX2FsbCBwIGwgJiYgZm9yX2FsbCBwIHJcblxuICAgIGxldCByZWMgZXhpc3RzIHAgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBmYWxzZVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPiBwIHYgZCB8fCBleGlzdHMgcCBsIHx8IGV4aXN0cyBwIHJcblxuICAgICgqIEJld2FyZTogdGhvc2UgdHdvIGZ1bmN0aW9ucyBhc3N1bWUgdGhhdCB0aGUgYWRkZWQgayBpcyAqc3RyaWN0bHkqXG4gICAgICAgc21hbGxlciAob3IgYmlnZ2VyKSB0aGFuIGFsbCB0aGUgcHJlc2VudCBrZXlzIGluIHRoZSB0cmVlOyBpdFxuICAgICAgIGRvZXMgbm90IHRlc3QgZm9yIGVxdWFsaXR5IHdpdGggdGhlIGN1cnJlbnQgbWluIChvciBtYXgpIGtleS5cblxuICAgICAgIEluZGVlZCwgdGhleSBhcmUgb25seSB1c2VkIGR1cmluZyB0aGUgXCJqb2luXCIgb3BlcmF0aW9uIHdoaWNoXG4gICAgICAgcmVzcGVjdHMgdGhpcyBwcmVjb25kaXRpb24uXG4gICAgKilcblxuICAgIGxldCByZWMgYWRkX21pbl9iaW5kaW5nIGsgeCA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+IHNpbmdsZXRvbiBrIHhcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgYmFsIChhZGRfbWluX2JpbmRpbmcgayB4IGwpIHYgZCByXG5cbiAgICBsZXQgcmVjIGFkZF9tYXhfYmluZGluZyBrIHggPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiBzaW5nbGV0b24gayB4XG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgIGJhbCBsIHYgZCAoYWRkX21heF9iaW5kaW5nIGsgeCByKVxuXG4gICAgKCogU2FtZSBhcyBjcmVhdGUgYW5kIGJhbCwgYnV0IG5vIGFzc3VtcHRpb25zIGFyZSBtYWRlIG9uIHRoZVxuICAgICAgIHJlbGF0aXZlIGhlaWdodHMgb2YgbCBhbmQgci4gKilcblxuICAgIGxldCByZWMgam9pbiBsIHYgZCByID1cbiAgICAgIG1hdGNoIChsLCByKSB3aXRoXG4gICAgICAgIChFbXB0eSwgXykgLT4gYWRkX21pbl9iaW5kaW5nIHYgZCByXG4gICAgICB8IChfLCBFbXB0eSkgLT4gYWRkX21heF9iaW5kaW5nIHYgZCBsXG4gICAgICB8IChOb2Rle2w9bGw7IHY9bHY7IGQ9bGQ7IHI9bHI7IGg9bGh9LFxuICAgICAgICAgTm9kZXtsPXJsOyB2PXJ2OyBkPXJkOyByPXJyOyBoPXJofSkgLT5cbiAgICAgICAgICBpZiBsaCA+IHJoICsgMiB0aGVuIGJhbCBsbCBsdiBsZCAoam9pbiBsciB2IGQgcikgZWxzZVxuICAgICAgICAgIGlmIHJoID4gbGggKyAyIHRoZW4gYmFsIChqb2luIGwgdiBkIHJsKSBydiByZCByciBlbHNlXG4gICAgICAgICAgY3JlYXRlIGwgdiBkIHJcblxuICAgICgqIE1lcmdlIHR3byB0cmVlcyBsIGFuZCByIGludG8gb25lLlxuICAgICAgIEFsbCBlbGVtZW50cyBvZiBsIG11c3QgcHJlY2VkZSB0aGUgZWxlbWVudHMgb2Ygci5cbiAgICAgICBObyBhc3N1bXB0aW9uIG9uIHRoZSBoZWlnaHRzIG9mIGwgYW5kIHIuICopXG5cbiAgICBsZXQgY29uY2F0IHQxIHQyID1cbiAgICAgIG1hdGNoICh0MSwgdDIpIHdpdGhcbiAgICAgICAgKEVtcHR5LCB0KSAtPiB0XG4gICAgICB8ICh0LCBFbXB0eSkgLT4gdFxuICAgICAgfCAoXywgXykgLT5cbiAgICAgICAgICBsZXQgKHgsIGQpID0gbWluX2JpbmRpbmcgdDIgaW5cbiAgICAgICAgICBqb2luIHQxIHggZCAocmVtb3ZlX21pbl9iaW5kaW5nIHQyKVxuXG4gICAgbGV0IGNvbmNhdF9vcl9qb2luIHQxIHYgZCB0MiA9XG4gICAgICBtYXRjaCBkIHdpdGhcbiAgICAgIHwgU29tZSBkIC0+IGpvaW4gdDEgdiBkIHQyXG4gICAgICB8IE5vbmUgLT4gY29uY2F0IHQxIHQyXG5cbiAgICBsZXQgcmVjIHNwbGl0IHggPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIChFbXB0eSwgTm9uZSwgRW1wdHkpXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuIChsLCBTb21lIGQsIHIpXG4gICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuXG4gICAgICAgICAgICBsZXQgKGxsLCBwcmVzLCBybCkgPSBzcGxpdCB4IGwgaW4gKGxsLCBwcmVzLCBqb2luIHJsIHYgZCByKVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxldCAobHIsIHByZXMsIHJyKSA9IHNwbGl0IHggciBpbiAoam9pbiBsIHYgZCBsciwgcHJlcywgcnIpXG5cbiAgICBsZXQgcmVjIG1lcmdlIGYgczEgczIgPVxuICAgICAgbWF0Y2ggKHMxLCBzMikgd2l0aFxuICAgICAgICAoRW1wdHksIEVtcHR5KSAtPiBFbXB0eVxuICAgICAgfCAoTm9kZSB7bD1sMTsgdj12MTsgZD1kMTsgcj1yMTsgaD1oMX0sIF8pIHdoZW4gaDEgPj0gaGVpZ2h0IHMyIC0+XG4gICAgICAgICAgbGV0IChsMiwgZDIsIHIyKSA9IHNwbGl0IHYxIHMyIGluXG4gICAgICAgICAgY29uY2F0X29yX2pvaW4gKG1lcmdlIGYgbDEgbDIpIHYxIChmIHYxIChTb21lIGQxKSBkMikgKG1lcmdlIGYgcjEgcjIpXG4gICAgICB8IChfLCBOb2RlIHtsPWwyOyB2PXYyOyBkPWQyOyByPXIyfSkgLT5cbiAgICAgICAgICBsZXQgKGwxLCBkMSwgcjEpID0gc3BsaXQgdjIgczEgaW5cbiAgICAgICAgICBjb25jYXRfb3Jfam9pbiAobWVyZ2UgZiBsMSBsMikgdjIgKGYgdjIgZDEgKFNvbWUgZDIpKSAobWVyZ2UgZiByMSByMilcbiAgICAgIHwgXyAtPlxuICAgICAgICAgIGFzc2VydCBmYWxzZVxuXG4gICAgbGV0IHJlYyB1bmlvbiBmIHMxIHMyID1cbiAgICAgIG1hdGNoIChzMSwgczIpIHdpdGhcbiAgICAgIHwgKEVtcHR5LCBzKSB8IChzLCBFbXB0eSkgLT4gc1xuICAgICAgfCAoTm9kZSB7bD1sMTsgdj12MTsgZD1kMTsgcj1yMTsgaD1oMX0sXG4gICAgICAgICBOb2RlIHtsPWwyOyB2PXYyOyBkPWQyOyByPXIyOyBoPWgyfSkgLT5cbiAgICAgICAgICBpZiBoMSA+PSBoMiB0aGVuXG4gICAgICAgICAgICBsZXQgKGwyLCBkMiwgcjIpID0gc3BsaXQgdjEgczIgaW5cbiAgICAgICAgICAgIGxldCBsID0gdW5pb24gZiBsMSBsMiBhbmQgciA9IHVuaW9uIGYgcjEgcjIgaW5cbiAgICAgICAgICAgIG1hdGNoIGQyIHdpdGhcbiAgICAgICAgICAgIHwgTm9uZSAtPiBqb2luIGwgdjEgZDEgclxuICAgICAgICAgICAgfCBTb21lIGQyIC0+IGNvbmNhdF9vcl9qb2luIGwgdjEgKGYgdjEgZDEgZDIpIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsZXQgKGwxLCBkMSwgcjEpID0gc3BsaXQgdjIgczEgaW5cbiAgICAgICAgICAgIGxldCBsID0gdW5pb24gZiBsMSBsMiBhbmQgciA9IHVuaW9uIGYgcjEgcjIgaW5cbiAgICAgICAgICAgIG1hdGNoIGQxIHdpdGhcbiAgICAgICAgICAgIHwgTm9uZSAtPiBqb2luIGwgdjIgZDIgclxuICAgICAgICAgICAgfCBTb21lIGQxIC0+IGNvbmNhdF9vcl9qb2luIGwgdjIgKGYgdjIgZDEgZDIpIHJcblxuICAgIGxldCByZWMgZmlsdGVyIHAgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBFbXB0eVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSBhcyBtIC0+XG4gICAgICAgICAgKCogY2FsbCBbcF0gaW4gdGhlIGV4cGVjdGVkIGxlZnQtdG8tcmlnaHQgb3JkZXIgKilcbiAgICAgICAgICBsZXQgbCcgPSBmaWx0ZXIgcCBsIGluXG4gICAgICAgICAgbGV0IHB2ZCA9IHAgdiBkIGluXG4gICAgICAgICAgbGV0IHInID0gZmlsdGVyIHAgciBpblxuICAgICAgICAgIGlmIHB2ZCB0aGVuIGlmIGw9PWwnICYmIHI9PXInIHRoZW4gbSBlbHNlIGpvaW4gbCcgdiBkIHInXG4gICAgICAgICAgZWxzZSBjb25jYXQgbCcgcidcblxuICAgIGxldCByZWMgZmlsdGVyX21hcCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gRW1wdHlcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICAoKiBjYWxsIFtmXSBpbiB0aGUgZXhwZWN0ZWQgbGVmdC10by1yaWdodCBvcmRlciAqKVxuICAgICAgICAgIGxldCBsJyA9IGZpbHRlcl9tYXAgZiBsIGluXG4gICAgICAgICAgbGV0IGZ2ZCA9IGYgdiBkIGluXG4gICAgICAgICAgbGV0IHInID0gZmlsdGVyX21hcCBmIHIgaW5cbiAgICAgICAgICBiZWdpbiBtYXRjaCBmdmQgd2l0aFxuICAgICAgICAgICAgfCBTb21lIGQnIC0+IGpvaW4gbCcgdiBkJyByJ1xuICAgICAgICAgICAgfCBOb25lIC0+IGNvbmNhdCBsJyByJ1xuICAgICAgICAgIGVuZFxuXG4gICAgbGV0IHJlYyBwYXJ0aXRpb24gcCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IChFbXB0eSwgRW1wdHkpXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgKCogY2FsbCBbcF0gaW4gdGhlIGV4cGVjdGVkIGxlZnQtdG8tcmlnaHQgb3JkZXIgKilcbiAgICAgICAgICBsZXQgKGx0LCBsZikgPSBwYXJ0aXRpb24gcCBsIGluXG4gICAgICAgICAgbGV0IHB2ZCA9IHAgdiBkIGluXG4gICAgICAgICAgbGV0IChydCwgcmYpID0gcGFydGl0aW9uIHAgciBpblxuICAgICAgICAgIGlmIHB2ZFxuICAgICAgICAgIHRoZW4gKGpvaW4gbHQgdiBkIHJ0LCBjb25jYXQgbGYgcmYpXG4gICAgICAgICAgZWxzZSAoY29uY2F0IGx0IHJ0LCBqb2luIGxmIHYgZCByZilcblxuICAgIHR5cGUgJ2EgZW51bWVyYXRpb24gPSBFbmQgfCBNb3JlIG9mIGtleSAqICdhICogJ2EgdCAqICdhIGVudW1lcmF0aW9uXG5cbiAgICBsZXQgcmVjIGNvbnNfZW51bSBtIGUgPVxuICAgICAgbWF0Y2ggbSB3aXRoXG4gICAgICAgIEVtcHR5IC0+IGVcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT4gY29uc19lbnVtIGwgKE1vcmUodiwgZCwgciwgZSkpXG5cbiAgICBsZXQgY29tcGFyZSBjbXAgbTEgbTIgPVxuICAgICAgbGV0IHJlYyBjb21wYXJlX2F1eCBlMSBlMiA9XG4gICAgICAgICAgbWF0Y2ggKGUxLCBlMikgd2l0aFxuICAgICAgICAgIChFbmQsIEVuZCkgLT4gMFxuICAgICAgICB8IChFbmQsIF8pICAtPiAtMVxuICAgICAgICB8IChfLCBFbmQpIC0+IDFcbiAgICAgICAgfCAoTW9yZSh2MSwgZDEsIHIxLCBlMSksIE1vcmUodjIsIGQyLCByMiwgZTIpKSAtPlxuICAgICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB2MSB2MiBpblxuICAgICAgICAgICAgaWYgYyA8PiAwIHRoZW4gYyBlbHNlXG4gICAgICAgICAgICBsZXQgYyA9IGNtcCBkMSBkMiBpblxuICAgICAgICAgICAgaWYgYyA8PiAwIHRoZW4gYyBlbHNlXG4gICAgICAgICAgICBjb21wYXJlX2F1eCAoY29uc19lbnVtIHIxIGUxKSAoY29uc19lbnVtIHIyIGUyKVxuICAgICAgaW4gY29tcGFyZV9hdXggKGNvbnNfZW51bSBtMSBFbmQpIChjb25zX2VudW0gbTIgRW5kKVxuXG4gICAgbGV0IGVxdWFsIGNtcCBtMSBtMiA9XG4gICAgICBsZXQgcmVjIGVxdWFsX2F1eCBlMSBlMiA9XG4gICAgICAgICAgbWF0Y2ggKGUxLCBlMikgd2l0aFxuICAgICAgICAgIChFbmQsIEVuZCkgLT4gdHJ1ZVxuICAgICAgICB8IChFbmQsIF8pICAtPiBmYWxzZVxuICAgICAgICB8IChfLCBFbmQpIC0+IGZhbHNlXG4gICAgICAgIHwgKE1vcmUodjEsIGQxLCByMSwgZTEpLCBNb3JlKHYyLCBkMiwgcjIsIGUyKSkgLT5cbiAgICAgICAgICAgIE9yZC5jb21wYXJlIHYxIHYyID0gMCAmJiBjbXAgZDEgZDIgJiZcbiAgICAgICAgICAgIGVxdWFsX2F1eCAoY29uc19lbnVtIHIxIGUxKSAoY29uc19lbnVtIHIyIGUyKVxuICAgICAgaW4gZXF1YWxfYXV4IChjb25zX2VudW0gbTEgRW5kKSAoY29uc19lbnVtIG0yIEVuZClcblxuICAgIGxldCByZWMgY2FyZGluYWwgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiAwXG4gICAgICB8IE5vZGUge2w7IHJ9IC0+IGNhcmRpbmFsIGwgKyAxICsgY2FyZGluYWwgclxuXG4gICAgbGV0IHJlYyBiaW5kaW5nc19hdXggYWNjdSA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IGFjY3VcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT4gYmluZGluZ3NfYXV4ICgodiwgZCkgOjogYmluZGluZ3NfYXV4IGFjY3UgcikgbFxuXG4gICAgbGV0IGJpbmRpbmdzIHMgPVxuICAgICAgYmluZGluZ3NfYXV4IFtdIHNcblxuICAgIGxldCBjaG9vc2UgPSBtaW5fYmluZGluZ1xuXG4gICAgbGV0IGNob29zZV9vcHQgPSBtaW5fYmluZGluZ19vcHRcblxuICAgIGxldCBhZGRfc2VxIGkgbSA9XG4gICAgICBTZXEuZm9sZF9sZWZ0IChmdW4gbSAoayx2KSAtPiBhZGQgayB2IG0pIG0gaVxuXG4gICAgbGV0IG9mX3NlcSBpID0gYWRkX3NlcSBpIGVtcHR5XG5cbiAgICBsZXQgcmVjIHNlcV9vZl9lbnVtXyBjICgpID0gbWF0Y2ggYyB3aXRoXG4gICAgICB8IEVuZCAtPiBTZXEuTmlsXG4gICAgICB8IE1vcmUgKGssdix0LHJlc3QpIC0+IFNlcS5Db25zICgoayx2KSwgc2VxX29mX2VudW1fIChjb25zX2VudW0gdCByZXN0KSlcblxuICAgIGxldCB0b19zZXEgbSA9XG4gICAgICBzZXFfb2ZfZW51bV8gKGNvbnNfZW51bSBtIEVuZClcblxuICAgIGxldCByZWMgc25vY19lbnVtIHMgZSA9XG4gICAgICBtYXRjaCBzIHdpdGhcbiAgICAgICAgRW1wdHkgLT4gZVxuICAgICAgfCBOb2Rle2w7IHY7IGQ7IHJ9IC0+IHNub2NfZW51bSByIChNb3JlKHYsIGQsIGwsIGUpKVxuXG4gICAgbGV0IHJlYyByZXZfc2VxX29mX2VudW1fIGMgKCkgPSBtYXRjaCBjIHdpdGhcbiAgICAgIHwgRW5kIC0+IFNlcS5OaWxcbiAgICAgIHwgTW9yZSAoayx2LHQscmVzdCkgLT5cbiAgICAgICAgICBTZXEuQ29ucyAoKGssdiksIHJldl9zZXFfb2ZfZW51bV8gKHNub2NfZW51bSB0IHJlc3QpKVxuXG4gICAgbGV0IHRvX3Jldl9zZXEgYyA9XG4gICAgICByZXZfc2VxX29mX2VudW1fIChzbm9jX2VudW0gYyBFbmQpXG5cbiAgICBsZXQgdG9fc2VxX2Zyb20gbG93IG0gPVxuICAgICAgbGV0IHJlYyBhdXggbG93IG0gYyA9IG1hdGNoIG0gd2l0aFxuICAgICAgICB8IEVtcHR5IC0+IGNcbiAgICAgICAgfCBOb2RlIHtsOyB2OyBkOyByOyBffSAtPlxuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggT3JkLmNvbXBhcmUgdiBsb3cgd2l0aFxuICAgICAgICAgICAgICB8IDAgLT4gTW9yZSAodiwgZCwgciwgYylcbiAgICAgICAgICAgICAgfCBuIHdoZW4gbjwwIC0+IGF1eCBsb3cgciBjXG4gICAgICAgICAgICAgIHwgXyAtPiBhdXggbG93IGwgKE1vcmUgKHYsIGQsIHIsIGMpKVxuICAgICAgICAgICAgZW5kXG4gICAgICBpblxuICAgICAgc2VxX29mX2VudW1fIChhdXggbG93IG0gRW5kKVxuZW5kXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUgJ2EgdCA9IHsgbXV0YWJsZSBjIDogJ2EgbGlzdDsgbXV0YWJsZSBsZW4gOiBpbnQ7IH1cblxuZXhjZXB0aW9uIEVtcHR5XG5cbmxldCBjcmVhdGUgKCkgPSB7IGMgPSBbXTsgbGVuID0gMDsgfVxuXG5sZXQgY2xlYXIgcyA9IHMuYyA8LSBbXTsgcy5sZW4gPC0gMFxuXG5sZXQgY29weSBzID0geyBjID0gcy5jOyBsZW4gPSBzLmxlbjsgfVxuXG5sZXQgcHVzaCB4IHMgPSBzLmMgPC0geCA6OiBzLmM7IHMubGVuIDwtIHMubGVuICsgMVxuXG5sZXQgcG9wIHMgPVxuICBtYXRjaCBzLmMgd2l0aFxuICB8IGhkOjp0bCAtPiBzLmMgPC0gdGw7IHMubGVuIDwtIHMubGVuIC0gMTsgaGRcbiAgfCBbXSAgICAgLT4gcmFpc2UgRW1wdHlcblxubGV0IHBvcF9vcHQgcyA9XG4gIG1hdGNoIHMuYyB3aXRoXG4gIHwgaGQ6OnRsIC0+IHMuYyA8LSB0bDsgcy5sZW4gPC0gcy5sZW4gLSAxOyBTb21lIGhkXG4gIHwgW10gICAgIC0+IE5vbmVcblxubGV0IHRvcCBzID1cbiAgbWF0Y2ggcy5jIHdpdGhcbiAgfCBoZDo6XyAtPiBoZFxuICB8IFtdICAgIC0+IHJhaXNlIEVtcHR5XG5cbmxldCB0b3Bfb3B0IHMgPVxuICBtYXRjaCBzLmMgd2l0aFxuICB8IGhkOjpfIC0+IFNvbWUgaGRcbiAgfCBbXSAgICAtPiBOb25lXG5cbmxldCBpc19lbXB0eSBzID0gKHMuYyA9IFtdKVxuXG5sZXQgbGVuZ3RoIHMgPSBzLmxlblxuXG5sZXQgaXRlciBmIHMgPSBMaXN0Lml0ZXIgZiBzLmNcblxubGV0IGZvbGQgZiBhY2MgcyA9IExpc3QuZm9sZF9sZWZ0IGYgYWNjIHMuY1xuXG4oKiogezEgSXRlcmF0b3JzfSAqKVxuXG5sZXQgdG9fc2VxIHMgPSBMaXN0LnRvX3NlcSBzLmNcblxubGV0IGFkZF9zZXEgcSBpID0gU2VxLml0ZXIgKGZ1biB4IC0+IHB1c2ggeCBxKSBpXG5cbmxldCBvZl9zZXEgZyA9XG4gIGxldCBzID0gY3JlYXRlKCkgaW5cbiAgYWRkX3NlcSBzIGc7XG4gIHNcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgRnJhbmNvaXMgUG90dGllciwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgSmVyZW1pZSBEaW1pbm8sIEphbmUgU3RyZWV0IEV1cm9wZSAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMDIgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuZXhjZXB0aW9uIEVtcHR5XG5cbnR5cGUgJ2EgY2VsbCA9XG4gIHwgTmlsXG4gIHwgQ29ucyBvZiB7IGNvbnRlbnQ6ICdhOyBtdXRhYmxlIG5leHQ6ICdhIGNlbGwgfVxuXG50eXBlICdhIHQgPSB7XG4gIG11dGFibGUgbGVuZ3RoOiBpbnQ7XG4gIG11dGFibGUgZmlyc3Q6ICdhIGNlbGw7XG4gIG11dGFibGUgbGFzdDogJ2EgY2VsbFxufVxuXG5sZXQgY3JlYXRlICgpID0ge1xuICBsZW5ndGggPSAwO1xuICBmaXJzdCA9IE5pbDtcbiAgbGFzdCA9IE5pbFxufVxuXG5sZXQgY2xlYXIgcSA9XG4gIHEubGVuZ3RoIDwtIDA7XG4gIHEuZmlyc3QgPC0gTmlsO1xuICBxLmxhc3QgPC0gTmlsXG5cbmxldCBhZGQgeCBxID1cbiAgbGV0IGNlbGwgPSBDb25zIHtcbiAgICBjb250ZW50ID0geDtcbiAgICBuZXh0ID0gTmlsXG4gIH0gaW5cbiAgbWF0Y2ggcS5sYXN0IHdpdGhcbiAgfCBOaWwgLT5cbiAgICBxLmxlbmd0aCA8LSAxO1xuICAgIHEuZmlyc3QgPC0gY2VsbDtcbiAgICBxLmxhc3QgPC0gY2VsbFxuICB8IENvbnMgbGFzdCAtPlxuICAgIHEubGVuZ3RoIDwtIHEubGVuZ3RoICsgMTtcbiAgICBsYXN0Lm5leHQgPC0gY2VsbDtcbiAgICBxLmxhc3QgPC0gY2VsbFxuXG5sZXQgcHVzaCA9XG4gIGFkZFxuXG5sZXQgcGVlayBxID1cbiAgbWF0Y2ggcS5maXJzdCB3aXRoXG4gIHwgTmlsIC0+IHJhaXNlIEVtcHR5XG4gIHwgQ29ucyB7IGNvbnRlbnQgfSAtPiBjb250ZW50XG5cbmxldCBwZWVrX29wdCBxID1cbiAgbWF0Y2ggcS5maXJzdCB3aXRoXG4gIHwgTmlsIC0+IE5vbmVcbiAgfCBDb25zIHsgY29udGVudCB9IC0+IFNvbWUgY29udGVudFxuXG5sZXQgdG9wID1cbiAgcGVla1xuXG5sZXQgdGFrZSBxID1cbiAgbWF0Y2ggcS5maXJzdCB3aXRoXG4gIHwgTmlsIC0+IHJhaXNlIEVtcHR5XG4gIHwgQ29ucyB7IGNvbnRlbnQ7IG5leHQgPSBOaWwgfSAtPlxuICAgIGNsZWFyIHE7XG4gICAgY29udGVudFxuICB8IENvbnMgeyBjb250ZW50OyBuZXh0IH0gLT5cbiAgICBxLmxlbmd0aCA8LSBxLmxlbmd0aCAtIDE7XG4gICAgcS5maXJzdCA8LSBuZXh0O1xuICAgIGNvbnRlbnRcblxubGV0IHRha2Vfb3B0IHEgPVxuICBtYXRjaCBxLmZpcnN0IHdpdGhcbiAgfCBOaWwgLT4gTm9uZVxuICB8IENvbnMgeyBjb250ZW50OyBuZXh0ID0gTmlsIH0gLT5cbiAgICBjbGVhciBxO1xuICAgIFNvbWUgY29udGVudFxuICB8IENvbnMgeyBjb250ZW50OyBuZXh0IH0gLT5cbiAgICBxLmxlbmd0aCA8LSBxLmxlbmd0aCAtIDE7XG4gICAgcS5maXJzdCA8LSBuZXh0O1xuICAgIFNvbWUgY29udGVudFxuXG5sZXQgcG9wID1cbiAgdGFrZVxuXG5sZXQgY29weSA9XG4gIGxldCByZWMgY29weSBxX3JlcyBwcmV2IGNlbGwgPVxuICAgIG1hdGNoIGNlbGwgd2l0aFxuICAgIHwgTmlsIC0+IHFfcmVzLmxhc3QgPC0gcHJldjsgcV9yZXNcbiAgICB8IENvbnMgeyBjb250ZW50OyBuZXh0IH0gLT5cbiAgICAgIGxldCByZXMgPSBDb25zIHsgY29udGVudDsgbmV4dCA9IE5pbCB9IGluXG4gICAgICBiZWdpbiBtYXRjaCBwcmV2IHdpdGhcbiAgICAgIHwgTmlsIC0+IHFfcmVzLmZpcnN0IDwtIHJlc1xuICAgICAgfCBDb25zIHAgLT4gcC5uZXh0IDwtIHJlc1xuICAgICAgZW5kO1xuICAgICAgY29weSBxX3JlcyByZXMgbmV4dFxuICBpblxuICBmdW4gcSAtPiBjb3B5IHsgbGVuZ3RoID0gcS5sZW5ndGg7IGZpcnN0ID0gTmlsOyBsYXN0ID0gTmlsIH0gTmlsIHEuZmlyc3RcblxubGV0IGlzX2VtcHR5IHEgPVxuICBxLmxlbmd0aCA9IDBcblxubGV0IGxlbmd0aCBxID1cbiAgcS5sZW5ndGhcblxubGV0IGl0ZXIgPVxuICBsZXQgcmVjIGl0ZXIgZiBjZWxsID1cbiAgICBtYXRjaCBjZWxsIHdpdGhcbiAgICB8IE5pbCAtPiAoKVxuICAgIHwgQ29ucyB7IGNvbnRlbnQ7IG5leHQgfSAtPlxuICAgICAgZiBjb250ZW50O1xuICAgICAgaXRlciBmIG5leHRcbiAgaW5cbiAgZnVuIGYgcSAtPiBpdGVyIGYgcS5maXJzdFxuXG5sZXQgZm9sZCA9XG4gIGxldCByZWMgZm9sZCBmIGFjY3UgY2VsbCA9XG4gICAgbWF0Y2ggY2VsbCB3aXRoXG4gICAgfCBOaWwgLT4gYWNjdVxuICAgIHwgQ29ucyB7IGNvbnRlbnQ7IG5leHQgfSAtPlxuICAgICAgbGV0IGFjY3UgPSBmIGFjY3UgY29udGVudCBpblxuICAgICAgZm9sZCBmIGFjY3UgbmV4dFxuICBpblxuICBmdW4gZiBhY2N1IHEgLT4gZm9sZCBmIGFjY3UgcS5maXJzdFxuXG5sZXQgdHJhbnNmZXIgcTEgcTIgPVxuICBpZiBxMS5sZW5ndGggPiAwIHRoZW5cbiAgICBtYXRjaCBxMi5sYXN0IHdpdGhcbiAgICB8IE5pbCAtPlxuICAgICAgcTIubGVuZ3RoIDwtIHExLmxlbmd0aDtcbiAgICAgIHEyLmZpcnN0IDwtIHExLmZpcnN0O1xuICAgICAgcTIubGFzdCA8LSBxMS5sYXN0O1xuICAgICAgY2xlYXIgcTFcbiAgICB8IENvbnMgbGFzdCAtPlxuICAgICAgcTIubGVuZ3RoIDwtIHEyLmxlbmd0aCArIHExLmxlbmd0aDtcbiAgICAgIGxhc3QubmV4dCA8LSBxMS5maXJzdDtcbiAgICAgIHEyLmxhc3QgPC0gcTEubGFzdDtcbiAgICAgIGNsZWFyIHExXG5cbigqKiB7MSBJdGVyYXRvcnN9ICopXG5cbmxldCB0b19zZXEgcSA9XG4gIGxldCByZWMgYXV4IGMgKCkgPSBtYXRjaCBjIHdpdGhcbiAgICB8IE5pbCAtPiBTZXEuTmlsXG4gICAgfCBDb25zIHsgY29udGVudD14OyBuZXh0OyB9IC0+IFNlcS5Db25zICh4LCBhdXggbmV4dClcbiAgaW5cbiAgYXV4IHEuZmlyc3RcblxubGV0IGFkZF9zZXEgcSBpID0gU2VxLml0ZXIgKGZ1biB4IC0+IHB1c2ggeCBxKSBpXG5cbmxldCBvZl9zZXEgZyA9XG4gIGxldCBxID0gY3JlYXRlKCkgaW5cbiAgYWRkX3NlcSBxIGc7XG4gIHFcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIERhbWllbiBEb2xpZ2V6LCBwcm9qZXQgUGFyYSwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTcgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogSW50ZXJuYWxzIG9mIGZvcmNpbmcgbGF6eSB2YWx1ZXMuICopXG5cbnR5cGUgJ2EgdCA9ICdhIGxhenlfdFxuXG5leGNlcHRpb24gVW5kZWZpbmVkXG5cbmxldCByYWlzZV91bmRlZmluZWQgPSBPYmoucmVwciAoZnVuICgpIC0+IHJhaXNlIFVuZGVmaW5lZClcblxuZXh0ZXJuYWwgbWFrZV9mb3J3YXJkIDogT2JqLnQgLT4gT2JqLnQgLT4gdW5pdCA9IFwiY2FtbF9vYmpfbWFrZV9mb3J3YXJkXCJcblxuKCogQXNzdW1lIFtibGtdIGlzIGEgYmxvY2sgd2l0aCB0YWcgbGF6eSAqKVxubGV0IGZvcmNlX2xhenlfYmxvY2sgKGJsayA6ICdhcmcgbGF6eV90KSA9XG4gIGxldCBjbG9zdXJlID0gKE9iai5vYmogKE9iai5maWVsZCAoT2JqLnJlcHIgYmxrKSAwKSA6IHVuaXQgLT4gJ2FyZykgaW5cbiAgT2JqLnNldF9maWVsZCAoT2JqLnJlcHIgYmxrKSAwIHJhaXNlX3VuZGVmaW5lZDtcbiAgdHJ5XG4gICAgbGV0IHJlc3VsdCA9IGNsb3N1cmUgKCkgaW5cbiAgICBtYWtlX2ZvcndhcmQgKE9iai5yZXByIGJsaykgKE9iai5yZXByIHJlc3VsdCk7XG4gICAgcmVzdWx0XG4gIHdpdGggZSAtPlxuICAgIE9iai5zZXRfZmllbGQgKE9iai5yZXByIGJsaykgMCAoT2JqLnJlcHIgKGZ1biAoKSAtPiByYWlzZSBlKSk7XG4gICAgcmFpc2UgZVxuXG5cbigqIEFzc3VtZSBbYmxrXSBpcyBhIGJsb2NrIHdpdGggdGFnIGxhenkgKilcbmxldCBmb3JjZV92YWxfbGF6eV9ibG9jayAoYmxrIDogJ2FyZyBsYXp5X3QpID1cbiAgbGV0IGNsb3N1cmUgPSAoT2JqLm9iaiAoT2JqLmZpZWxkIChPYmoucmVwciBibGspIDApIDogdW5pdCAtPiAnYXJnKSBpblxuICBPYmouc2V0X2ZpZWxkIChPYmoucmVwciBibGspIDAgcmFpc2VfdW5kZWZpbmVkO1xuICBsZXQgcmVzdWx0ID0gY2xvc3VyZSAoKSBpblxuICBtYWtlX2ZvcndhcmQgKE9iai5yZXByIGJsaykgKE9iai5yZXByIHJlc3VsdCk7XG4gIHJlc3VsdFxuXG5cbigqIFtmb3JjZV0gaXMgbm90IHVzZWQsIHNpbmNlIFtMYXp5LmZvcmNlXSBpcyBkZWNsYXJlZCBhcyBhIHByaW1pdGl2ZVxuICAgd2hvc2UgY29kZSBpbmxpbmVzIHRoZSB0YWcgdGVzdHMgb2YgaXRzIGFyZ3VtZW50LCBleGNlcHQgd2hlbiBhZmxcbiAgIGluc3RydW1lbnRhdGlvbiBpcyB0dXJuZWQgb24uICopXG5cbmxldCBmb3JjZSAobHp2IDogJ2FyZyBsYXp5X3QpID1cbiAgKCogVXNpbmcgW1N5cy5vcGFxdWVfaWRlbnRpdHldIHByZXZlbnRzIHR3byBwb3RlbnRpYWwgcHJvYmxlbXM6XG4gICAgIC0gSWYgdGhlIHZhbHVlIGlzIGtub3duIHRvIGhhdmUgRm9yd2FyZF90YWcsIHRoZW4gaXRzIHRhZyBjb3VsZCBoYXZlXG4gICAgICAgY2hhbmdlZCBkdXJpbmcgR0MsIHNvIHRoYXQgaW5mb3JtYXRpb24gbXVzdCBiZSBmb3Jnb3R0ZW4gKHNlZSBHUFIjNzEzXG4gICAgICAgYW5kIGlzc3VlICM3MzAxKVxuICAgICAtIElmIHRoZSB2YWx1ZSBpcyBrbm93biB0byBiZSBpbW11dGFibGUsIHRoZW4gaWYgdGhlIGNvbXBpbGVyXG4gICAgICAgY2Fubm90IHByb3ZlIHRoYXQgdGhlIGxhc3QgYnJhbmNoIGlzIG5vdCB0YWtlbiBpdCB3aWxsIGlzc3VlIGFcbiAgICAgICB3YXJuaW5nIDU5IChtb2RpZmljYXRpb24gb2YgYW4gaW1tdXRhYmxlIHZhbHVlKSAqKVxuICBsZXQgbHp2ID0gU3lzLm9wYXF1ZV9pZGVudGl0eSBsenYgaW5cbiAgbGV0IHggPSBPYmoucmVwciBsenYgaW5cbiAgbGV0IHQgPSBPYmoudGFnIHggaW5cbiAgaWYgdCA9IE9iai5mb3J3YXJkX3RhZyB0aGVuIChPYmoub2JqIChPYmouZmllbGQgeCAwKSA6ICdhcmcpIGVsc2VcbiAgaWYgdCA8PiBPYmoubGF6eV90YWcgdGhlbiAoT2JqLm9iaiB4IDogJ2FyZylcbiAgZWxzZSBmb3JjZV9sYXp5X2Jsb2NrIGx6dlxuXG5cbmxldCBmb3JjZV92YWwgKGx6diA6ICdhcmcgbGF6eV90KSA9XG4gIGxldCB4ID0gT2JqLnJlcHIgbHp2IGluXG4gIGxldCB0ID0gT2JqLnRhZyB4IGluXG4gIGlmIHQgPSBPYmouZm9yd2FyZF90YWcgdGhlbiAoT2JqLm9iaiAoT2JqLmZpZWxkIHggMCkgOiAnYXJnKSBlbHNlXG4gIGlmIHQgPD4gT2JqLmxhenlfdGFnIHRoZW4gKE9iai5vYmogeCA6ICdhcmcpXG4gIGVsc2UgZm9yY2VfdmFsX2xhenlfYmxvY2sgbHp2XG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBEYW1pZW4gRG9saWdleiwgcHJvamV0IFBhcmEsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk3IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIE1vZHVsZSBbTGF6eV06IGRlZmVycmVkIGNvbXB1dGF0aW9ucyAqKVxuXG5cbigqXG4gICBXQVJOSU5HOiBzb21lIHB1cnBsZSBtYWdpYyBpcyBnb2luZyBvbiBoZXJlLiAgRG8gbm90IHRha2UgdGhpcyBmaWxlXG4gICBhcyBhbiBleGFtcGxlIG9mIGhvdyB0byBwcm9ncmFtIGluIE9DYW1sLlxuKilcblxuXG4oKiBXZSBtYWtlIHVzZSBvZiB0d28gc3BlY2lhbCB0YWdzIHByb3ZpZGVkIGJ5IHRoZSBydW50aW1lOlxuICAgW2xhenlfdGFnXSBhbmQgW2ZvcndhcmRfdGFnXS5cblxuICAgQSB2YWx1ZSBvZiB0eXBlIFsnYSBMYXp5LnRdIGNhbiBiZSBvbmUgb2YgdGhyZWUgdGhpbmdzOlxuICAgMS4gQSBibG9jayBvZiBzaXplIDEgd2l0aCB0YWcgW2xhenlfdGFnXS4gIEl0cyBmaWVsZCBpcyBhIGNsb3N1cmUgb2ZcbiAgICAgIHR5cGUgW3VuaXQgLT4gJ2FdIHRoYXQgY29tcHV0ZXMgdGhlIHZhbHVlLlxuICAgMi4gQSBibG9jayBvZiBzaXplIDEgd2l0aCB0YWcgW2ZvcndhcmRfdGFnXS4gIEl0cyBmaWVsZCBpcyB0aGUgdmFsdWVcbiAgICAgIG9mIHR5cGUgWydhXSB0aGF0IHdhcyBjb21wdXRlZC5cbiAgIDMuIEFueXRoaW5nIGVsc2UgZXhjZXB0IGEgZmxvYXQuICBUaGlzIGhhcyB0eXBlIFsnYV0gYW5kIGlzIHRoZSB2YWx1ZVxuICAgICAgdGhhdCB3YXMgY29tcHV0ZWQuXG4gICBFeGNlcHRpb25zIGFyZSBzdG9yZWQgaW4gZm9ybWF0ICgxKS5cbiAgIFRoZSBHQyB3aWxsIG1hZ2ljYWxseSBjaGFuZ2UgdGhpbmdzIGZyb20gKDIpIHRvICgzKSBhY2NvcmRpbmcgdG8gaXRzXG4gICBmYW5jeS5cblxuICAgSWYgT0NhbWwgd2FzIGNvbmZpZ3VyZWQgd2l0aCB0aGUgLWZsYXQtZmxvYXQtYXJyYXkgb3B0aW9uICh3aGljaCBpc1xuICAgY3VycmVudGx5IHRoZSBkZWZhdWx0KSwgdGhlIGZvbGxvd2luZyBpcyBhbHNvIHRydWU6XG4gICBXZSBjYW5ub3QgdXNlIHJlcHJlc2VudGF0aW9uICgzKSBmb3IgYSBbZmxvYXQgTGF6eS50XSBiZWNhdXNlXG4gICBbY2FtbF9tYWtlX2FycmF5XSBhc3N1bWVzIHRoYXQgb25seSBhIFtmbG9hdF0gdmFsdWUgY2FuIGhhdmUgdGFnXG4gICBbRG91YmxlX3RhZ10uXG5cbiAgIFdlIGhhdmUgdG8gdXNlIHRoZSBidWlsdC1pbiB0eXBlIGNvbnN0cnVjdG9yIFtsYXp5X3RdIHRvXG4gICBsZXQgdGhlIGNvbXBpbGVyIGltcGxlbWVudCB0aGUgc3BlY2lhbCB0eXBpbmcgYW5kIGNvbXBpbGF0aW9uXG4gICBydWxlcyBmb3IgdGhlIFtsYXp5XSBrZXl3b3JkLlxuKilcblxudHlwZSAnYSB0ID0gJ2EgQ2FtbGludGVybmFsTGF6eS50XG5cbmV4Y2VwdGlvbiBVbmRlZmluZWQgPSBDYW1saW50ZXJuYWxMYXp5LlVuZGVmaW5lZFxuXG5leHRlcm5hbCBtYWtlX2ZvcndhcmQgOiAnYSAtPiAnYSBsYXp5X3QgPSBcImNhbWxfbGF6eV9tYWtlX2ZvcndhcmRcIlxuXG5leHRlcm5hbCBmb3JjZSA6ICdhIHQgLT4gJ2EgPSBcIiVsYXp5X2ZvcmNlXCJcblxuKCogbGV0IGZvcmNlID0gZm9yY2UgKilcblxubGV0IGZvcmNlX3ZhbCA9IENhbWxpbnRlcm5hbExhenkuZm9yY2VfdmFsXG5cbmxldCBmcm9tX2Z1biAoZiA6IHVuaXQgLT4gJ2FyZykgPVxuICBsZXQgeCA9IE9iai5uZXdfYmxvY2sgT2JqLmxhenlfdGFnIDEgaW5cbiAgT2JqLnNldF9maWVsZCB4IDAgKE9iai5yZXByIGYpO1xuICAoT2JqLm9iaiB4IDogJ2FyZyB0KVxuXG5cbmxldCBmcm9tX3ZhbCAodiA6ICdhcmcpID1cbiAgbGV0IHQgPSBPYmoudGFnIChPYmoucmVwciB2KSBpblxuICBpZiB0ID0gT2JqLmZvcndhcmRfdGFnIHx8IHQgPSBPYmoubGF6eV90YWcgfHwgdCA9IE9iai5kb3VibGVfdGFnIHRoZW4gYmVnaW5cbiAgICBtYWtlX2ZvcndhcmQgdlxuICBlbmQgZWxzZSBiZWdpblxuICAgIChPYmoubWFnaWMgdiA6ICdhcmcgdClcbiAgZW5kXG5cblxubGV0IGlzX3ZhbCAobCA6ICdhcmcgdCkgPSBPYmoudGFnIChPYmoucmVwciBsKSA8PiBPYmoubGF6eV90YWdcblxubGV0IGxhenlfZnJvbV9mdW4gPSBmcm9tX2Z1blxuXG5sZXQgbGF6eV9mcm9tX3ZhbCA9IGZyb21fdmFsXG5cbmxldCBsYXp5X2lzX3ZhbCA9IGlzX3ZhbFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICBEYW5pZWwgZGUgUmF1Z2xhdWRyZSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NyBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlICdhIHQgPSAnYSBjZWxsIG9wdGlvblxuYW5kICdhIGNlbGwgPSB7IG11dGFibGUgY291bnQgOiBpbnQ7IG11dGFibGUgZGF0YSA6ICdhIGRhdGEgfVxuYW5kICdhIGRhdGEgPVxuICAgIFNlbXB0eVxuICB8IFNjb25zIG9mICdhICogJ2EgZGF0YVxuICB8IFNhcHAgb2YgJ2EgZGF0YSAqICdhIGRhdGFcbiAgfCBTbGF6eSBvZiAnYSBkYXRhIExhenkudFxuICB8IFNnZW4gb2YgJ2EgZ2VuXG4gIHwgU2J1ZmZpbyA6IGJ1ZmZpbyAtPiBjaGFyIGRhdGFcbmFuZCAnYSBnZW4gPSB7IG11dGFibGUgY3VyciA6ICdhIG9wdGlvbiBvcHRpb247IGZ1bmMgOiBpbnQgLT4gJ2Egb3B0aW9uIH1cbmFuZCBidWZmaW8gPVxuICB7IGljIDogaW5fY2hhbm5lbDsgYnVmZiA6IGJ5dGVzOyBtdXRhYmxlIGxlbiA6IGludDsgbXV0YWJsZSBpbmQgOiBpbnQgfVxuXG5leGNlcHRpb24gRmFpbHVyZVxuZXhjZXB0aW9uIEVycm9yIG9mIHN0cmluZ1xuXG5sZXQgY291bnQgPSBmdW5jdGlvblxuICB8IE5vbmUgLT4gMFxuICB8IFNvbWUgeyBjb3VudCB9IC0+IGNvdW50XG5sZXQgZGF0YSA9IGZ1bmN0aW9uXG4gIHwgTm9uZSAtPiBTZW1wdHlcbiAgfCBTb21lIHsgZGF0YSB9IC0+IGRhdGFcblxubGV0IGZpbGxfYnVmZiBiID1cbiAgYi5sZW4gPC0gaW5wdXQgYi5pYyBiLmJ1ZmYgMCAoQnl0ZXMubGVuZ3RoIGIuYnVmZik7IGIuaW5kIDwtIDBcblxuXG5sZXQgcmVjIGdldF9kYXRhIDogdHlwZSB2LiBpbnQgLT4gdiBkYXRhIC0+IHYgZGF0YSA9IGZ1biBjb3VudCBkIC0+IG1hdGNoIGQgd2l0aFxuICgqIFJldHVybnMgZWl0aGVyIFNlbXB0eSBvciBTY29ucyhhLCBfKSBldmVuIHdoZW4gZCBpcyBhIGdlbmVyYXRvclxuICAgIG9yIGEgYnVmZmVyLiBJbiB0aG9zZSBjYXNlcywgdGhlIGl0ZW0gYSBpcyBzZWVuIGFzIGV4dHJhY3RlZCBmcm9tXG4gdGhlIGdlbmVyYXRvci9idWZmZXIuXG4gVGhlIGNvdW50IHBhcmFtZXRlciBpcyB1c2VkIGZvciBjYWxsaW5nIGBTZ2VuLWZ1bmN0aW9ucycuICAqKVxuICAgU2VtcHR5IHwgU2NvbnMgKF8sIF8pIC0+IGRcbiB8IFNhcHAgKGQxLCBkMikgLT5cbiAgICAgYmVnaW4gbWF0Y2ggZ2V0X2RhdGEgY291bnQgZDEgd2l0aFxuICAgICAgIFNjb25zIChhLCBkMTEpIC0+IFNjb25zIChhLCBTYXBwIChkMTEsIGQyKSlcbiAgICAgfCBTZW1wdHkgLT4gZ2V0X2RhdGEgY291bnQgZDJcbiAgICAgfCBfIC0+IGFzc2VydCBmYWxzZVxuICAgICBlbmRcbiB8IFNnZW4ge2N1cnIgPSBTb21lIE5vbmV9IC0+IFNlbXB0eVxuIHwgU2dlbiAoe2N1cnIgPSBTb21lKFNvbWUgYSl9IGFzIGcpIC0+XG4gICAgIGcuY3VyciA8LSBOb25lOyBTY29ucyhhLCBkKVxuIHwgU2dlbiBnIC0+XG4gICAgIGJlZ2luIG1hdGNoIGcuZnVuYyBjb3VudCB3aXRoXG4gICAgICAgTm9uZSAtPiBnLmN1cnIgPC0gU29tZShOb25lKTsgU2VtcHR5XG4gICAgIHwgU29tZSBhIC0+IFNjb25zKGEsIGQpXG4gICAgICAgICAoKiBXYXJuaW5nOiBhbnlvbmUgdXNpbmcgZyB0aGlua3MgdGhhdCBhbiBpdGVtIGhhcyBiZWVuIHJlYWQgKilcbiAgICAgZW5kXG4gfCBTYnVmZmlvIGIgLT5cbiAgICAgaWYgYi5pbmQgPj0gYi5sZW4gdGhlbiBmaWxsX2J1ZmYgYjtcbiAgICAgaWYgYi5sZW4gPT0gMCB0aGVuIFNlbXB0eSBlbHNlXG4gICAgICAgbGV0IHIgPSBCeXRlcy51bnNhZmVfZ2V0IGIuYnVmZiBiLmluZCBpblxuICAgICAgICgqIFdhcm5pbmc6IGFueW9uZSB1c2luZyBnIHRoaW5rcyB0aGF0IGFuIGl0ZW0gaGFzIGJlZW4gcmVhZCAqKVxuICAgICAgIGIuaW5kIDwtIHN1Y2MgYi5pbmQ7IFNjb25zKHIsIGQpXG4gfCBTbGF6eSBmIC0+IGdldF9kYXRhIGNvdW50IChMYXp5LmZvcmNlIGYpXG5cblxubGV0IHJlYyBwZWVrX2RhdGEgOiB0eXBlIHYuIHYgY2VsbCAtPiB2IG9wdGlvbiA9IGZ1biBzIC0+XG4gKCogY29uc3VsdCB0aGUgZmlyc3QgaXRlbSBvZiBzICopXG4gbWF0Y2ggcy5kYXRhIHdpdGhcbiAgIFNlbXB0eSAtPiBOb25lXG4gfCBTY29ucyAoYSwgXykgLT4gU29tZSBhXG4gfCBTYXBwIChfLCBfKSAtPlxuICAgICBiZWdpbiBtYXRjaCBnZXRfZGF0YSBzLmNvdW50IHMuZGF0YSB3aXRoXG4gICAgICAgU2NvbnMoYSwgXykgYXMgZCAtPiBzLmRhdGEgPC0gZDsgU29tZSBhXG4gICAgIHwgU2VtcHR5IC0+IE5vbmVcbiAgICAgfCBfIC0+IGFzc2VydCBmYWxzZVxuICAgICBlbmRcbiB8IFNsYXp5IGYgLT4gcy5kYXRhIDwtIChMYXp5LmZvcmNlIGYpOyBwZWVrX2RhdGEgc1xuIHwgU2dlbiB7Y3VyciA9IFNvbWUgYX0gLT4gYVxuIHwgU2dlbiBnIC0+IGxldCB4ID0gZy5mdW5jIHMuY291bnQgaW4gZy5jdXJyIDwtIFNvbWUgeDsgeFxuIHwgU2J1ZmZpbyBiIC0+XG4gICAgIGlmIGIuaW5kID49IGIubGVuIHRoZW4gZmlsbF9idWZmIGI7XG4gICAgIGlmIGIubGVuID09IDAgdGhlbiBiZWdpbiBzLmRhdGEgPC0gU2VtcHR5OyBOb25lIGVuZFxuICAgICBlbHNlIFNvbWUgKEJ5dGVzLnVuc2FmZV9nZXQgYi5idWZmIGIuaW5kKVxuXG5cbmxldCBwZWVrID0gZnVuY3Rpb25cbiAgfCBOb25lIC0+IE5vbmVcbiAgfCBTb21lIHMgLT4gcGVla19kYXRhIHNcblxuXG5sZXQgcmVjIGp1bmtfZGF0YSA6IHR5cGUgdi4gdiBjZWxsIC0+IHVuaXQgPSBmdW4gcyAtPlxuICBtYXRjaCBzLmRhdGEgd2l0aFxuICAgIFNjb25zIChfLCBkKSAtPiBzLmNvdW50IDwtIChzdWNjIHMuY291bnQpOyBzLmRhdGEgPC0gZFxuICB8IFNnZW4gKHtjdXJyID0gU29tZSBffSBhcyBnKSAtPiBzLmNvdW50IDwtIChzdWNjIHMuY291bnQpOyBnLmN1cnIgPC0gTm9uZVxuICB8IFNidWZmaW8gYiAtPlxuICAgICAgaWYgYi5pbmQgPj0gYi5sZW4gdGhlbiBmaWxsX2J1ZmYgYjtcbiAgICAgIGlmIGIubGVuID09IDAgdGhlbiBzLmRhdGEgPC0gU2VtcHR5XG4gICAgICBlbHNlIChzLmNvdW50IDwtIChzdWNjIHMuY291bnQpOyBiLmluZCA8LSBzdWNjIGIuaW5kKVxuICB8IF8gLT5cbiAgICAgIG1hdGNoIHBlZWtfZGF0YSBzIHdpdGhcbiAgICAgICAgTm9uZSAtPiAoKVxuICAgICAgfCBTb21lIF8gLT4ganVua19kYXRhIHNcblxuXG5sZXQganVuayA9IGZ1bmN0aW9uXG4gIHwgTm9uZSAtPiAoKVxuICB8IFNvbWUgZGF0YSAtPiBqdW5rX2RhdGEgZGF0YVxuXG5sZXQgcmVjIG5nZXRfZGF0YSBuIHMgPVxuICBpZiBuIDw9IDAgdGhlbiBbXSwgcy5kYXRhLCAwXG4gIGVsc2VcbiAgICBtYXRjaCBwZWVrX2RhdGEgcyB3aXRoXG4gICAgICBTb21lIGEgLT5cbiAgICAgICAganVua19kYXRhIHM7XG4gICAgICAgIGxldCAoYWwsIGQsIGspID0gbmdldF9kYXRhIChwcmVkIG4pIHMgaW4gYSA6OiBhbCwgU2NvbnMgKGEsIGQpLCBzdWNjIGtcbiAgICB8IE5vbmUgLT4gW10sIHMuZGF0YSwgMFxuXG5cbmxldCBucGVla19kYXRhIG4gcyA9XG4gIGxldCAoYWwsIGQsIGxlbikgPSBuZ2V0X2RhdGEgbiBzIGluXG4gIHMuY291bnQgPC0gKHMuY291bnQgLSBsZW4pO1xuICBzLmRhdGEgPC0gZDtcbiAgYWxcblxuXG5sZXQgbnBlZWsgbiA9IGZ1bmN0aW9uXG4gIHwgTm9uZSAtPiBbXVxuICB8IFNvbWUgZCAtPiBucGVla19kYXRhIG4gZFxuXG5sZXQgbmV4dCBzID1cbiAgbWF0Y2ggcGVlayBzIHdpdGhcbiAgICBTb21lIGEgLT4ganVuayBzOyBhXG4gIHwgTm9uZSAtPiByYWlzZSBGYWlsdXJlXG5cblxubGV0IGVtcHR5IHMgPVxuICBtYXRjaCBwZWVrIHMgd2l0aFxuICAgIFNvbWUgXyAtPiByYWlzZSBGYWlsdXJlXG4gIHwgTm9uZSAtPiAoKVxuXG5cbmxldCBpdGVyIGYgc3RybSA9XG4gIGxldCByZWMgZG9fcmVjICgpID1cbiAgICBtYXRjaCBwZWVrIHN0cm0gd2l0aFxuICAgICAgU29tZSBhIC0+IGp1bmsgc3RybTsgaWdub3JlKGYgYSk7IGRvX3JlYyAoKVxuICAgIHwgTm9uZSAtPiAoKVxuICBpblxuICBkb19yZWMgKClcblxuXG4oKiBTdHJlYW0gYnVpbGRpbmcgZnVuY3Rpb25zICopXG5cbmxldCBmcm9tIGYgPSBTb21lIHtjb3VudCA9IDA7IGRhdGEgPSBTZ2VuIHtjdXJyID0gTm9uZTsgZnVuYyA9IGZ9fVxuXG5sZXQgb2ZfbGlzdCBsID1cbiAgU29tZSB7Y291bnQgPSAwOyBkYXRhID0gTGlzdC5mb2xkX3JpZ2h0IChmdW4geCBsIC0+IFNjb25zICh4LCBsKSkgbCBTZW1wdHl9XG5cblxubGV0IG9mX3N0cmluZyBzID1cbiAgbGV0IGNvdW50ID0gcmVmIDAgaW5cbiAgZnJvbSAoZnVuIF8gLT5cbiAgICAoKiBXZSBjYW5ub3QgdXNlIHRoZSBpbmRleCBwYXNzZWQgYnkgdGhlIFtmcm9tXSBmdW5jdGlvbiBkaXJlY3RseVxuICAgICAgIGJlY2F1c2UgaXQgcmV0dXJucyB0aGUgY3VycmVudCBzdHJlYW0gY291bnQsIHdpdGggYWJzb2x1dGVseSBub1xuICAgICAgIGd1YXJhbnRlZSB0aGF0IGl0IHdpbGwgc3RhcnQgZnJvbSAwLiBGb3IgZXhhbXBsZSwgaW4gdGhlIGNhc2VcbiAgICAgICBvZiBbU3RyZWFtLmljb25zICdjJyAoU3RyZWFtLmZyb21fc3RyaW5nIFwiYWJcIildLCB0aGUgZmlyc3RcbiAgICAgICBhY2Nlc3MgdG8gdGhlIHN0cmluZyB3aWxsIGJlIG1hZGUgd2l0aCBjb3VudCBbMV0gYWxyZWFkeS5cbiAgICAqKVxuICAgIGxldCBjID0gIWNvdW50IGluXG4gICAgaWYgYyA8IFN0cmluZy5sZW5ndGggc1xuICAgIHRoZW4gKGluY3IgY291bnQ7IFNvbWUgcy5bY10pXG4gICAgZWxzZSBOb25lKVxuXG5cbmxldCBvZl9ieXRlcyBzID1cbiAgbGV0IGNvdW50ID0gcmVmIDAgaW5cbiAgZnJvbSAoZnVuIF8gLT5cbiAgICBsZXQgYyA9ICFjb3VudCBpblxuICAgIGlmIGMgPCBCeXRlcy5sZW5ndGggc1xuICAgIHRoZW4gKGluY3IgY291bnQ7IFNvbWUgKEJ5dGVzLmdldCBzIGMpKVxuICAgIGVsc2UgTm9uZSlcblxuXG5sZXQgb2ZfY2hhbm5lbCBpYyA9XG4gIFNvbWUge2NvdW50ID0gMDtcbiAgICAgICAgZGF0YSA9IFNidWZmaW8ge2ljID0gaWM7IGJ1ZmYgPSBCeXRlcy5jcmVhdGUgNDA5NjsgbGVuID0gMDsgaW5kID0gMH19XG5cblxuKCogU3RyZWFtIGV4cHJlc3Npb25zIGJ1aWxkZXJzICopXG5cbmxldCBpYXBwIGkgcyA9IFNvbWUge2NvdW50ID0gMDsgZGF0YSA9IFNhcHAgKGRhdGEgaSwgZGF0YSBzKX1cbmxldCBpY29ucyBpIHMgPSBTb21lIHtjb3VudCA9IDA7IGRhdGEgPSBTY29ucyAoaSwgZGF0YSBzKX1cbmxldCBpc2luZyBpID0gU29tZSB7Y291bnQgPSAwOyBkYXRhID0gU2NvbnMgKGksIFNlbXB0eSl9XG5cbmxldCBsYXBwIGYgcyA9XG4gIFNvbWUge2NvdW50ID0gMDsgZGF0YSA9IFNsYXp5IChsYXp5KFNhcHAgKGRhdGEgKGYgKCkpLCBkYXRhIHMpKSl9XG5cbmxldCBsY29ucyBmIHMgPSBTb21lIHtjb3VudCA9IDA7IGRhdGEgPSBTbGF6eSAobGF6eShTY29ucyAoZiAoKSwgZGF0YSBzKSkpfVxubGV0IGxzaW5nIGYgPSBTb21lIHtjb3VudCA9IDA7IGRhdGEgPSBTbGF6eSAobGF6eShTY29ucyAoZiAoKSwgU2VtcHR5KSkpfVxuXG5sZXQgc2VtcHR5ID0gTm9uZVxubGV0IHNsYXp5IGYgPSBTb21lIHtjb3VudCA9IDA7IGRhdGEgPSBTbGF6eSAobGF6eShkYXRhIChmICgpKSkpfVxuXG4oKiBGb3IgZGVidWdnaW5nIHVzZSAqKVxuXG5sZXQgcmVjIGR1bXAgOiB0eXBlIHYuICh2IC0+IHVuaXQpIC0+IHYgdCAtPiB1bml0ID0gZnVuIGYgcyAtPlxuICBwcmludF9zdHJpbmcgXCJ7Y291bnQgPSBcIjtcbiAgcHJpbnRfaW50IChjb3VudCBzKTtcbiAgcHJpbnRfc3RyaW5nIFwiOyBkYXRhID0gXCI7XG4gIGR1bXBfZGF0YSBmIChkYXRhIHMpO1xuICBwcmludF9zdHJpbmcgXCJ9XCI7XG4gIHByaW50X25ld2xpbmUgKClcbmFuZCBkdW1wX2RhdGEgOiB0eXBlIHYuICh2IC0+IHVuaXQpIC0+IHYgZGF0YSAtPiB1bml0ID0gZnVuIGYgLT5cbiAgZnVuY3Rpb25cbiAgICBTZW1wdHkgLT4gcHJpbnRfc3RyaW5nIFwiU2VtcHR5XCJcbiAgfCBTY29ucyAoYSwgZCkgLT5cbiAgICAgIHByaW50X3N0cmluZyBcIlNjb25zIChcIjtcbiAgICAgIGYgYTtcbiAgICAgIHByaW50X3N0cmluZyBcIiwgXCI7XG4gICAgICBkdW1wX2RhdGEgZiBkO1xuICAgICAgcHJpbnRfc3RyaW5nIFwiKVwiXG4gIHwgU2FwcCAoZDEsIGQyKSAtPlxuICAgICAgcHJpbnRfc3RyaW5nIFwiU2FwcCAoXCI7XG4gICAgICBkdW1wX2RhdGEgZiBkMTtcbiAgICAgIHByaW50X3N0cmluZyBcIiwgXCI7XG4gICAgICBkdW1wX2RhdGEgZiBkMjtcbiAgICAgIHByaW50X3N0cmluZyBcIilcIlxuICB8IFNsYXp5IF8gLT4gcHJpbnRfc3RyaW5nIFwiU2xhenlcIlxuICB8IFNnZW4gXyAtPiBwcmludF9zdHJpbmcgXCJTZ2VuXCJcbiAgfCBTYnVmZmlvIF8gLT4gcHJpbnRfc3RyaW5nIFwiU2J1ZmZpb1wiXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICBQaWVycmUgV2VpcyBhbmQgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk5IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIEV4dGVuc2libGUgYnVmZmVycyAqKVxuXG50eXBlIHQgPVxuIHttdXRhYmxlIGJ1ZmZlciA6IGJ5dGVzO1xuICBtdXRhYmxlIHBvc2l0aW9uIDogaW50O1xuICBtdXRhYmxlIGxlbmd0aCA6IGludDtcbiAgaW5pdGlhbF9idWZmZXIgOiBieXRlc31cbigqIEludmFyaWFudHM6IGFsbCBwYXJ0cyBvZiB0aGUgY29kZSBwcmVzZXJ2ZSB0aGUgaW52YXJpYW50cyB0aGF0OlxuICAgLSBbMCA8PSBiLnBvc2l0aW9uIDw9IGIubGVuZ3RoXVxuICAgLSBbYi5sZW5ndGggPSBCeXRlcy5sZW5ndGggYi5idWZmZXJdXG5cbiAgIE5vdGUgaW4gcGFydGljdWxhciB0aGF0IFtiLnBvc2l0aW9uID0gYi5sZW5ndGhdIGlzIGxlZ2FsLFxuICAgaXQgbWVhbnMgdGhhdCB0aGUgYnVmZmVyIGlzIGZ1bGwgYW5kIHdpbGwgaGF2ZSB0byBiZSBleHRlbmRlZFxuICAgYmVmb3JlIGFueSBmdXJ0aGVyIGFkZGl0aW9uLiAqKVxuXG5sZXQgY3JlYXRlIG4gPVxuIGxldCBuID0gaWYgbiA8IDEgdGhlbiAxIGVsc2UgbiBpblxuIGxldCBuID0gaWYgbiA+IFN5cy5tYXhfc3RyaW5nX2xlbmd0aCB0aGVuIFN5cy5tYXhfc3RyaW5nX2xlbmd0aCBlbHNlIG4gaW5cbiBsZXQgcyA9IEJ5dGVzLmNyZWF0ZSBuIGluXG4ge2J1ZmZlciA9IHM7IHBvc2l0aW9uID0gMDsgbGVuZ3RoID0gbjsgaW5pdGlhbF9idWZmZXIgPSBzfVxuXG5sZXQgY29udGVudHMgYiA9IEJ5dGVzLnN1Yl9zdHJpbmcgYi5idWZmZXIgMCBiLnBvc2l0aW9uXG5sZXQgdG9fYnl0ZXMgYiA9IEJ5dGVzLnN1YiBiLmJ1ZmZlciAwIGIucG9zaXRpb25cblxubGV0IHN1YiBiIG9mcyBsZW4gPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gYi5wb3NpdGlvbiAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiQnVmZmVyLnN1YlwiXG4gIGVsc2UgQnl0ZXMuc3ViX3N0cmluZyBiLmJ1ZmZlciBvZnMgbGVuXG5cblxubGV0IGJsaXQgc3JjIHNyY29mZiBkc3QgZHN0b2ZmIGxlbiA9XG4gIGlmIGxlbiA8IDAgfHwgc3Jjb2ZmIDwgMCB8fCBzcmNvZmYgPiBzcmMucG9zaXRpb24gLSBsZW5cbiAgICAgICAgICAgICB8fCBkc3RvZmYgPCAwIHx8IGRzdG9mZiA+IChCeXRlcy5sZW5ndGggZHN0KSAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiQnVmZmVyLmJsaXRcIlxuICBlbHNlXG4gICAgQnl0ZXMudW5zYWZlX2JsaXQgc3JjLmJ1ZmZlciBzcmNvZmYgZHN0IGRzdG9mZiBsZW5cblxuXG5sZXQgbnRoIGIgb2ZzID1cbiAgaWYgb2ZzIDwgMCB8fCBvZnMgPj0gYi5wb3NpdGlvbiB0aGVuXG4gICBpbnZhbGlkX2FyZyBcIkJ1ZmZlci5udGhcIlxuICBlbHNlIEJ5dGVzLnVuc2FmZV9nZXQgYi5idWZmZXIgb2ZzXG5cblxubGV0IGxlbmd0aCBiID0gYi5wb3NpdGlvblxuXG5sZXQgY2xlYXIgYiA9IGIucG9zaXRpb24gPC0gMFxuXG5sZXQgcmVzZXQgYiA9XG4gIGIucG9zaXRpb24gPC0gMDtcbiAgYi5idWZmZXIgPC0gYi5pbml0aWFsX2J1ZmZlcjtcbiAgYi5sZW5ndGggPC0gQnl0ZXMubGVuZ3RoIGIuYnVmZmVyXG5cbigqIFtyZXNpemUgYiBtb3JlXSBlbnN1cmVzIHRoYXQgW2IucG9zaXRpb24gKyBtb3JlIDw9IGIubGVuZ3RoXSBob2xkc1xuICAgYnkgZHluYW1pY2FsbHkgZXh0ZW5kaW5nIFtiLmJ1ZmZlcl0gaWYgbmVjZXNzYXJ5IC0tIGFuZCB0aHVzXG4gICBpbmNyZWFzaW5nIFtiLmxlbmd0aF0uXG5cbiAgIEluIHBhcnRpY3VsYXIsIGFmdGVyIFtyZXNpemUgYiBtb3JlXSBpcyBjYWxsZWQsIGEgZGlyZWN0IGFjY2VzcyBvZlxuICAgc2l6ZSBbbW9yZV0gYXQgW2IucG9zaXRpb25dIHdpbGwgYWx3YXlzIGJlIGluLWJvdW5kcywgc28gdGhhdFxuICAgKHVuc2FmZV97Z2V0LHNldH0pIG1heSBiZSB1c2VkIGZvciBwZXJmb3JtYW5jZS5cbiopXG5sZXQgcmVzaXplIGIgbW9yZSA9XG4gIGxldCBvbGRfcG9zID0gYi5wb3NpdGlvbiBpblxuICBsZXQgb2xkX2xlbiA9IGIubGVuZ3RoIGluXG4gIGxldCBuZXdfbGVuID0gcmVmIG9sZF9sZW4gaW5cbiAgd2hpbGUgb2xkX3BvcyArIG1vcmUgPiAhbmV3X2xlbiBkbyBuZXdfbGVuIDo9IDIgKiAhbmV3X2xlbiBkb25lO1xuICBpZiAhbmV3X2xlbiA+IFN5cy5tYXhfc3RyaW5nX2xlbmd0aCB0aGVuIGJlZ2luXG4gICAgaWYgb2xkX3BvcyArIG1vcmUgPD0gU3lzLm1heF9zdHJpbmdfbGVuZ3RoXG4gICAgdGhlbiBuZXdfbGVuIDo9IFN5cy5tYXhfc3RyaW5nX2xlbmd0aFxuICAgIGVsc2UgZmFpbHdpdGggXCJCdWZmZXIuYWRkOiBjYW5ub3QgZ3JvdyBidWZmZXJcIlxuICBlbmQ7XG4gIGxldCBuZXdfYnVmZmVyID0gQnl0ZXMuY3JlYXRlICFuZXdfbGVuIGluXG4gICgqIFBSIzYxNDg6IGxldCdzIGtlZXAgdXNpbmcgW2JsaXRdIHJhdGhlciB0aGFuIFt1bnNhZmVfYmxpdF0gaW5cbiAgICAgdGhpcyB0cmlja3kgZnVuY3Rpb24gdGhhdCBpcyBzbG93IGFueXdheS4gKilcbiAgQnl0ZXMuYmxpdCBiLmJ1ZmZlciAwIG5ld19idWZmZXIgMCBiLnBvc2l0aW9uO1xuICBiLmJ1ZmZlciA8LSBuZXdfYnVmZmVyO1xuICBiLmxlbmd0aCA8LSAhbmV3X2xlbjtcbiAgYXNzZXJ0IChiLnBvc2l0aW9uICsgbW9yZSA8PSBiLmxlbmd0aCk7XG4gIGFzc2VydCAob2xkX3BvcyArIG1vcmUgPD0gYi5sZW5ndGgpO1xuICAoKVxuICAoKiBOb3RlOiB0aGVyZSBhcmUgdmFyaW91cyBzaXR1YXRpb25zIChwcmVlbXB0aXZlIHRocmVhZHMsIHNpZ25hbHMgYW5kXG4gICAgIGdjIGZpbmFsaXplcnMpIHdoZXJlIE9DYW1sIGNvZGUgbWF5IGJlIHJ1biBhc3luY2hyb25vdXNseTsgaW5cbiAgICAgcGFydGljdWxhciwgdGhlcmUgbWF5IGJlIGEgcmFjZSB3aXRoIGFub3RoZXIgdXNlciBvZiBbYl0sIGNoYW5naW5nXG4gICAgIGl0cyBtdXRhYmxlIGZpZWxkcyBpbiB0aGUgbWlkZGxlIG9mIHRoZSBbcmVzaXplXSBjYWxsLiBUaGUgQnVmZmVyXG4gICAgIG1vZHVsZSBkb2VzIG5vdCBwcm92aWRlIGFueSBjb3JyZWN0bmVzcyBndWFyYW50ZWUgaWYgdGhhdCBoYXBwZW5zLFxuICAgICBidXQgd2UgbXVzdCBzdGlsbCBlbnN1cmUgdGhhdCB0aGUgZGF0YXN0cnVjdHVyZSBpbnZhcmlhbnRzIGhvbGQgZm9yXG4gICAgIG1lbW9yeS1zYWZldHkgLS0gYXMgd2UgcGxhbiB0byB1c2UgW3Vuc2FmZV97Z2V0LHNldH1dLlxuXG4gICAgIFRoZXJlIGFyZSB0d28gcG90ZW50aWFsIGFsbG9jYXRpb24gcG9pbnRzIGluIHRoaXMgZnVuY3Rpb24sXG4gICAgIFtyZWZdIGFuZCBbQnl0ZXMuY3JlYXRlXSwgYnV0IGFsbCByZWFkcyBhbmQgd3JpdGVzIHRvIHRoZSBmaWVsZHNcbiAgICAgb2YgW2JdIGhhcHBlbiBiZWZvcmUgYm90aCBvZiB0aGVtIG9yIGFmdGVyIGJvdGggb2YgdGhlbS5cblxuICAgICBXZSB0aGVyZWZvcmUgYXNzdW1lIHRoYXQgW2IucG9zaXRpb25dIG1heSBjaGFuZ2UgYXQgdGhlc2UgYWxsb2NhdGlvbnMsXG4gICAgIGFuZCBjaGVjayB0aGF0IHRoZSBbYi5wb3NpdGlvbiArIG1vcmUgPD0gYi5sZW5ndGhdIHBvc3Rjb25kaXRpb25cbiAgICAgaG9sZHMgZm9yIGJvdGggdmFsdWVzIG9mIFtiLnBvc2l0aW9uXSwgYmVmb3JlIG9yIGFmdGVyIHRoZSBmdW5jdGlvblxuICAgICBpcyBjYWxsZWQuIE1vcmUgcHJlY2lzZWx5LCB0aGUgZm9sbG93aW5nIGludmFyaWFudHMgbXVzdCBob2xkIGlmIHRoZVxuICAgICBmdW5jdGlvbiByZXR1cm5zIGNvcnJlY3RseSwgaW4gYWRkaXRpb24gdG8gdGhlIHVzdWFsIGJ1ZmZlciBpbnZhcmlhbnRzOlxuICAgICAtIFtvbGQoYi5wb3NpdGlvbikgKyBtb3JlIDw9IG5ldyhiLmxlbmd0aCldXG4gICAgIC0gW25ldyhiLnBvc2l0aW9uKSArIG1vcmUgPD0gbmV3KGIubGVuZ3RoKV1cbiAgICAgLSBbb2xkKGIubGVuZ3RoKSA8PSBuZXcoYi5sZW5ndGgpXVxuXG4gICAgIE5vdGU6IFtiLnBvc2l0aW9uICsgbW9yZSA8PSBvbGQoYi5sZW5ndGgpXSBkb2VzICpub3QqXG4gICAgIGhvbGQgaW4gZ2VuZXJhbCwgYXMgaXQgaXMgcHJlY2lzZWx5IHRoZSBjYXNlIHdoZXJlIHlvdSBuZWVkXG4gICAgIHRvIGNhbGwgW3Jlc2l6ZV0gdG8gaW5jcmVhc2UgW2IubGVuZ3RoXS5cblxuICAgICBOb3RlOiBbYXNzZXJ0XSBhYm92ZSBkb2VzIG5vdCBtZWFuIHRoYXQgd2Uga25vdyB0aGUgY29uZGl0aW9uc1xuICAgICBhbHdheXMgaG9sZCwgYnV0IHRoYXQgdGhlIGZ1bmN0aW9uIG1heSByZXR1cm4gY29ycmVjdGx5XG4gICAgIG9ubHkgaWYgdGhleSBob2xkLlxuXG4gICAgIE5vdGU6IHRoZSBvdGhlciBmdW5jdGlvbnMgaW4gdGhpcyBtb2R1bGUgZG9lcyBub3QgbmVlZFxuICAgICB0byBiZSBjaGVja2VkIHdpdGggdGhpcyBsZXZlbCBvZiBzY3J1dGlueSwgZ2l2ZW4gdGhhdCB0aGV5XG4gICAgIHJlYWQvd3JpdGUgdGhlIGJ1ZmZlciBpbW1lZGlhdGVseSBhZnRlciBjaGVja2luZyB0aGF0XG4gICAgIFtiLnBvc2l0aW9uICsgbW9yZSA8PSBiLmxlbmd0aF0gaG9sZCBvciBjYWxsaW5nIFtyZXNpemVdLlxuICAqKVxuXG5sZXQgYWRkX2NoYXIgYiBjID1cbiAgbGV0IHBvcyA9IGIucG9zaXRpb24gaW5cbiAgaWYgcG9zID49IGIubGVuZ3RoIHRoZW4gcmVzaXplIGIgMTtcbiAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciBwb3MgYztcbiAgYi5wb3NpdGlvbiA8LSBwb3MgKyAxXG5cbiBsZXQgYWRkX3V0Zl84X3VjaGFyIGIgdSA9IG1hdGNoIFVjaGFyLnRvX2ludCB1IHdpdGhcbiB8IHUgd2hlbiB1IDwgMCAtPiBhc3NlcnQgZmFsc2VcbiB8IHUgd2hlbiB1IDw9IDB4MDA3RiAtPlxuICAgICBhZGRfY2hhciBiIChDaGFyLnVuc2FmZV9jaHIgdSlcbiB8IHUgd2hlbiB1IDw9IDB4MDdGRiAtPlxuICAgICBsZXQgcG9zID0gYi5wb3NpdGlvbiBpblxuICAgICBpZiBwb3MgKyAyID4gYi5sZW5ndGggdGhlbiByZXNpemUgYiAyO1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgICAgKVxuICAgICAgIChDaGFyLnVuc2FmZV9jaHIgKDB4QzAgbG9yICh1IGxzciA2KSkpO1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgKyAxKVxuICAgICAgIChDaGFyLnVuc2FmZV9jaHIgKDB4ODAgbG9yICh1IGxhbmQgMHgzRikpKTtcbiAgICAgYi5wb3NpdGlvbiA8LSBwb3MgKyAyXG4gfCB1IHdoZW4gdSA8PSAweEZGRkYgLT5cbiAgICAgbGV0IHBvcyA9IGIucG9zaXRpb24gaW5cbiAgICAgaWYgcG9zICsgMyA+IGIubGVuZ3RoIHRoZW4gcmVzaXplIGIgMztcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICAgIClcbiAgICAgICAoQ2hhci51bnNhZmVfY2hyICgweEUwIGxvciAodSBsc3IgMTIpKSk7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyArIDEpXG4gICAgICAgKENoYXIudW5zYWZlX2NociAoMHg4MCBsb3IgKCh1IGxzciA2KSBsYW5kIDB4M0YpKSk7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyArIDIpXG4gICAgICAgKENoYXIudW5zYWZlX2NociAoMHg4MCBsb3IgKHUgbGFuZCAweDNGKSkpO1xuICAgICBiLnBvc2l0aW9uIDwtIHBvcyArIDNcbiB8IHUgd2hlbiB1IDw9IDB4MTBGRkZGIC0+XG4gICAgIGxldCBwb3MgPSBiLnBvc2l0aW9uIGluXG4gICAgIGlmIHBvcyArIDQgPiBiLmxlbmd0aCB0aGVuIHJlc2l6ZSBiIDQ7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyAgICApXG4gICAgICAgKENoYXIudW5zYWZlX2NociAoMHhGMCBsb3IgKHUgbHNyIDE4KSkpO1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgKyAxKVxuICAgICAgIChDaGFyLnVuc2FmZV9jaHIgKDB4ODAgbG9yICgodSBsc3IgMTIpIGxhbmQgMHgzRikpKTtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICsgMilcbiAgICAgICAoQ2hhci51bnNhZmVfY2hyICgweDgwIGxvciAoKHUgbHNyIDYpIGxhbmQgMHgzRikpKTtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICsgMylcbiAgICAgICAoQ2hhci51bnNhZmVfY2hyICgweDgwIGxvciAodSBsYW5kIDB4M0YpKSk7XG4gICAgIGIucG9zaXRpb24gPC0gcG9zICsgNFxuIHwgXyAtPiBhc3NlcnQgZmFsc2VcblxuIGxldCBhZGRfdXRmXzE2YmVfdWNoYXIgYiB1ID0gbWF0Y2ggVWNoYXIudG9faW50IHUgd2l0aFxuIHwgdSB3aGVuIHUgPCAwIC0+IGFzc2VydCBmYWxzZVxuIHwgdSB3aGVuIHUgPD0gMHhGRkZGIC0+XG4gICAgIGxldCBwb3MgPSBiLnBvc2l0aW9uIGluXG4gICAgIGlmIHBvcyArIDIgPiBiLmxlbmd0aCB0aGVuIHJlc2l6ZSBiIDI7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyAgICApIChDaGFyLnVuc2FmZV9jaHIgKHUgbHNyIDgpKTtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICsgMSkgKENoYXIudW5zYWZlX2NociAodSBsYW5kIDB4RkYpKTtcbiAgICAgYi5wb3NpdGlvbiA8LSBwb3MgKyAyXG4gfCB1IHdoZW4gdSA8PSAweDEwRkZGRiAtPlxuICAgICBsZXQgdScgPSB1IC0gMHgxMDAwMCBpblxuICAgICBsZXQgaGkgPSAweEQ4MDAgbG9yICh1JyBsc3IgMTApIGluXG4gICAgIGxldCBsbyA9IDB4REMwMCBsb3IgKHUnIGxhbmQgMHgzRkYpIGluXG4gICAgIGxldCBwb3MgPSBiLnBvc2l0aW9uIGluXG4gICAgIGlmIHBvcyArIDQgPiBiLmxlbmd0aCB0aGVuIHJlc2l6ZSBiIDQ7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyAgICApIChDaGFyLnVuc2FmZV9jaHIgKGhpIGxzciA4KSk7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyArIDEpIChDaGFyLnVuc2FmZV9jaHIgKGhpIGxhbmQgMHhGRikpO1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgKyAyKSAoQ2hhci51bnNhZmVfY2hyIChsbyBsc3IgOCkpO1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgKyAzKSAoQ2hhci51bnNhZmVfY2hyIChsbyBsYW5kIDB4RkYpKTtcbiAgICAgYi5wb3NpdGlvbiA8LSBwb3MgKyA0XG4gfCBfIC0+IGFzc2VydCBmYWxzZVxuXG4gbGV0IGFkZF91dGZfMTZsZV91Y2hhciBiIHUgPSBtYXRjaCBVY2hhci50b19pbnQgdSB3aXRoXG4gfCB1IHdoZW4gdSA8IDAgLT4gYXNzZXJ0IGZhbHNlXG4gfCB1IHdoZW4gdSA8PSAweEZGRkYgLT5cbiAgICAgbGV0IHBvcyA9IGIucG9zaXRpb24gaW5cbiAgICAgaWYgcG9zICsgMiA+IGIubGVuZ3RoIHRoZW4gcmVzaXplIGIgMjtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICAgICkgKENoYXIudW5zYWZlX2NociAodSBsYW5kIDB4RkYpKTtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICsgMSkgKENoYXIudW5zYWZlX2NociAodSBsc3IgOCkpO1xuICAgICBiLnBvc2l0aW9uIDwtIHBvcyArIDJcbiB8IHUgd2hlbiB1IDw9IDB4MTBGRkZGIC0+XG4gICAgIGxldCB1JyA9IHUgLSAweDEwMDAwIGluXG4gICAgIGxldCBoaSA9IDB4RDgwMCBsb3IgKHUnIGxzciAxMCkgaW5cbiAgICAgbGV0IGxvID0gMHhEQzAwIGxvciAodScgbGFuZCAweDNGRikgaW5cbiAgICAgbGV0IHBvcyA9IGIucG9zaXRpb24gaW5cbiAgICAgaWYgcG9zICsgNCA+IGIubGVuZ3RoIHRoZW4gcmVzaXplIGIgNDtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICAgICkgKENoYXIudW5zYWZlX2NociAoaGkgbGFuZCAweEZGKSk7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyArIDEpIChDaGFyLnVuc2FmZV9jaHIgKGhpIGxzciA4KSk7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyArIDIpIChDaGFyLnVuc2FmZV9jaHIgKGxvIGxhbmQgMHhGRikpO1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgKyAzKSAoQ2hhci51bnNhZmVfY2hyIChsbyBsc3IgOCkpO1xuICAgICBiLnBvc2l0aW9uIDwtIHBvcyArIDRcbiB8IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbmxldCBhZGRfc3Vic3RyaW5nIGIgcyBvZmZzZXQgbGVuID1cbiAgaWYgb2Zmc2V0IDwgMCB8fCBsZW4gPCAwIHx8IG9mZnNldCA+IFN0cmluZy5sZW5ndGggcyAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiQnVmZmVyLmFkZF9zdWJzdHJpbmcvYWRkX3N1YmJ5dGVzXCI7XG4gIGxldCBuZXdfcG9zaXRpb24gPSBiLnBvc2l0aW9uICsgbGVuIGluXG4gIGlmIG5ld19wb3NpdGlvbiA+IGIubGVuZ3RoIHRoZW4gcmVzaXplIGIgbGVuO1xuICBCeXRlcy51bnNhZmVfYmxpdF9zdHJpbmcgcyBvZmZzZXQgYi5idWZmZXIgYi5wb3NpdGlvbiBsZW47XG4gIGIucG9zaXRpb24gPC0gbmV3X3Bvc2l0aW9uXG5cbmxldCBhZGRfc3ViYnl0ZXMgYiBzIG9mZnNldCBsZW4gPVxuICBhZGRfc3Vic3RyaW5nIGIgKEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcykgb2Zmc2V0IGxlblxuXG5sZXQgYWRkX3N0cmluZyBiIHMgPVxuICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gIGxldCBuZXdfcG9zaXRpb24gPSBiLnBvc2l0aW9uICsgbGVuIGluXG4gIGlmIG5ld19wb3NpdGlvbiA+IGIubGVuZ3RoIHRoZW4gcmVzaXplIGIgbGVuO1xuICBCeXRlcy51bnNhZmVfYmxpdF9zdHJpbmcgcyAwIGIuYnVmZmVyIGIucG9zaXRpb24gbGVuO1xuICBiLnBvc2l0aW9uIDwtIG5ld19wb3NpdGlvblxuXG5sZXQgYWRkX2J5dGVzIGIgcyA9IGFkZF9zdHJpbmcgYiAoQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBzKVxuXG5sZXQgYWRkX2J1ZmZlciBiIGJzID1cbiAgYWRkX3N1YmJ5dGVzIGIgYnMuYnVmZmVyIDAgYnMucG9zaXRpb25cblxuKCogdGhpcyAocHJpdmF0ZSkgZnVuY3Rpb24gY291bGQgbW92ZSBpbnRvIHRoZSBzdGFuZGFyZCBsaWJyYXJ5ICopXG5sZXQgcmVhbGx5X2lucHV0X3VwX3RvIGljIGJ1ZiBvZnMgbGVuID1cbiAgbGV0IHJlYyBsb29wIGljIGJ1ZiB+YWxyZWFkeV9yZWFkIH5vZnMgfnRvX3JlYWQgPVxuICAgIGlmIHRvX3JlYWQgPSAwIHRoZW4gYWxyZWFkeV9yZWFkXG4gICAgZWxzZSBiZWdpblxuICAgICAgbGV0IHIgPSBpbnB1dCBpYyBidWYgb2ZzIHRvX3JlYWQgaW5cbiAgICAgIGlmIHIgPSAwIHRoZW4gYWxyZWFkeV9yZWFkXG4gICAgICBlbHNlIGJlZ2luXG4gICAgICAgIGxldCBhbHJlYWR5X3JlYWQgPSBhbHJlYWR5X3JlYWQgKyByIGluXG4gICAgICAgIGxldCBvZnMgPSBvZnMgKyByIGluXG4gICAgICAgIGxldCB0b19yZWFkID0gdG9fcmVhZCAtIHIgaW5cbiAgICAgICAgbG9vcCBpYyBidWYgfmFscmVhZHlfcmVhZCB+b2ZzIH50b19yZWFkXG4gICAgICBlbmRcbiAgICBlbmRcbiAgaW4gbG9vcCBpYyBidWYgfmFscmVhZHlfcmVhZDowIH5vZnMgfnRvX3JlYWQ6bGVuXG5cblxubGV0IHVuc2FmZV9hZGRfY2hhbm5lbF91cF90byBiIGljIGxlbiA9XG4gIGlmIGIucG9zaXRpb24gKyBsZW4gPiBiLmxlbmd0aCB0aGVuIHJlc2l6ZSBiIGxlbjtcbiAgbGV0IG4gPSByZWFsbHlfaW5wdXRfdXBfdG8gaWMgYi5idWZmZXIgYi5wb3NpdGlvbiBsZW4gaW5cbiAgKCogVGhlIGFzc2VydGlvbiBiZWxvdyBtYXkgZmFpbCBpbiB3ZWlyZCBzY2VuYXJpbyB3aGVyZVxuICAgICB0aHJlYWRlZC9maW5hbGl6ZXIgY29kZSwgcnVuIGFzeW5jaHJvbm91c2x5IGR1cmluZyB0aGVcbiAgICAgW3JlYWxseV9pbnB1dF91cF90b10gY2FsbCwgcmFjZXMgb24gdGhlIGJ1ZmZlcjsgd2UgZG9uJ3QgZW5zdXJlXG4gICAgIGNvcnJlY3RuZXNzIGluIHRoaXMgY2FzZSwgYnV0IG5lZWQgdG8gcHJlc2VydmUgdGhlIGludmFyaWFudHMgZm9yXG4gICAgIG1lbW9yeS1zYWZldHkgKHNlZSBkaXNjdXNzaW9uIG9mIFtyZXNpemVdKS4gKilcbiAgYXNzZXJ0IChiLnBvc2l0aW9uICsgbiA8PSBiLmxlbmd0aCk7XG4gIGIucG9zaXRpb24gPC0gYi5wb3NpdGlvbiArIG47XG4gIG5cblxubGV0IGFkZF9jaGFubmVsIGIgaWMgbGVuID1cbiAgaWYgbGVuIDwgMCB8fCBsZW4gPiBTeXMubWF4X3N0cmluZ19sZW5ndGggdGhlbiAgICgqIFBSIzUwMDQgKilcbiAgICBpbnZhbGlkX2FyZyBcIkJ1ZmZlci5hZGRfY2hhbm5lbFwiO1xuICBsZXQgbiA9IHVuc2FmZV9hZGRfY2hhbm5lbF91cF90byBiIGljIGxlbiBpblxuICAoKiBJdCBpcyBpbnRlbnRpb25hbCB0aGF0IGEgY29uc3VtZXIgY2F0Y2hpbmcgRW5kX29mX2ZpbGVcbiAgICAgd2lsbCBzZWUgdGhlIGRhdGEgd3JpdHRlbiAoc2VlICM2NzE5LCAjNzEzNikuICopXG4gIGlmIG4gPCBsZW4gdGhlbiByYWlzZSBFbmRfb2ZfZmlsZTtcbiAgKClcblxubGV0IG91dHB1dF9idWZmZXIgb2MgYiA9XG4gIG91dHB1dCBvYyBiLmJ1ZmZlciAwIGIucG9zaXRpb25cblxubGV0IGNsb3NpbmcgPSBmdW5jdGlvblxuICB8ICcoJyAtPiAnKSdcbiAgfCAneycgLT4gJ30nXG4gIHwgXyAtPiBhc3NlcnQgZmFsc2VcblxuKCogb3BlbmluZyBhbmQgY2xvc2luZzogb3BlbiBhbmQgY2xvc2UgY2hhcmFjdGVycywgdHlwaWNhbGx5ICggYW5kIClcbiAgIGs6IGJhbGFuY2Ugb2Ygb3BlbmluZyBhbmQgY2xvc2luZyBjaGFyc1xuICAgczogdGhlIHN0cmluZyB3aGVyZSB3ZSBhcmUgc2VhcmNoaW5nXG4gICBzdGFydDogdGhlIGluZGV4IHdoZXJlIHdlIHN0YXJ0IHRoZSBzZWFyY2guICopXG5sZXQgYWR2YW5jZV90b19jbG9zaW5nIG9wZW5pbmcgY2xvc2luZyBrIHMgc3RhcnQgPVxuICBsZXQgcmVjIGFkdmFuY2UgayBpIGxpbSA9XG4gICAgaWYgaSA+PSBsaW0gdGhlbiByYWlzZSBOb3RfZm91bmQgZWxzZVxuICAgIGlmIHMuW2ldID0gb3BlbmluZyB0aGVuIGFkdmFuY2UgKGsgKyAxKSAoaSArIDEpIGxpbSBlbHNlXG4gICAgaWYgcy5baV0gPSBjbG9zaW5nIHRoZW5cbiAgICAgIGlmIGsgPSAwIHRoZW4gaSBlbHNlIGFkdmFuY2UgKGsgLSAxKSAoaSArIDEpIGxpbVxuICAgIGVsc2UgYWR2YW5jZSBrIChpICsgMSkgbGltIGluXG4gIGFkdmFuY2UgayBzdGFydCAoU3RyaW5nLmxlbmd0aCBzKVxuXG5sZXQgYWR2YW5jZV90b19ub25fYWxwaGEgcyBzdGFydCA9XG4gIGxldCByZWMgYWR2YW5jZSBpIGxpbSA9XG4gICAgaWYgaSA+PSBsaW0gdGhlbiBsaW0gZWxzZVxuICAgIG1hdGNoIHMuW2ldIHdpdGhcbiAgICB8ICdhJyAuLiAneicgfCAnQScgLi4gJ1onIHwgJzAnIC4uICc5JyB8ICdfJyAtPiBhZHZhbmNlIChpICsgMSkgbGltXG4gICAgfCBfIC0+IGkgaW5cbiAgYWR2YW5jZSBzdGFydCAoU3RyaW5nLmxlbmd0aCBzKVxuXG4oKiBXZSBhcmUganVzdCBhdCB0aGUgYmVnaW5uaW5nIG9mIGFuIGlkZW50IGluIHMsIHN0YXJ0aW5nIGF0IHN0YXJ0LiAqKVxubGV0IGZpbmRfaWRlbnQgcyBzdGFydCBsaW0gPVxuICBpZiBzdGFydCA+PSBsaW0gdGhlbiByYWlzZSBOb3RfZm91bmQgZWxzZVxuICBtYXRjaCBzLltzdGFydF0gd2l0aFxuICAoKiBQYXJlbnRoZXNpemVkIGlkZW50ID8gKilcbiAgfCAnKCcgfCAneycgYXMgYyAtPlxuICAgICBsZXQgbmV3X3N0YXJ0ID0gc3RhcnQgKyAxIGluXG4gICAgIGxldCBzdG9wID0gYWR2YW5jZV90b19jbG9zaW5nIGMgKGNsb3NpbmcgYykgMCBzIG5ld19zdGFydCBpblxuICAgICBTdHJpbmcuc3ViIHMgbmV3X3N0YXJ0IChzdG9wIC0gc3RhcnQgLSAxKSwgc3RvcCArIDFcbiAgKCogUmVndWxhciBpZGVudCAqKVxuICB8IF8gLT5cbiAgICAgbGV0IHN0b3AgPSBhZHZhbmNlX3RvX25vbl9hbHBoYSBzIChzdGFydCArIDEpIGluXG4gICAgIFN0cmluZy5zdWIgcyBzdGFydCAoc3RvcCAtIHN0YXJ0KSwgc3RvcFxuXG4oKiBTdWJzdGl0dXRlICRpZGVudCwgJChpZGVudCksIG9yICR7aWRlbnR9IGluIHMsXG4gICAgYWNjb3JkaW5nIHRvIHRoZSBmdW5jdGlvbiBtYXBwaW5nIGYuICopXG5sZXQgYWRkX3N1YnN0aXR1dGUgYiBmIHMgPVxuICBsZXQgbGltID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gIGxldCByZWMgc3Vic3QgcHJldmlvdXMgaSA9XG4gICAgaWYgaSA8IGxpbSB0aGVuIGJlZ2luXG4gICAgICBtYXRjaCBzLltpXSB3aXRoXG4gICAgICB8ICckJyBhcyBjdXJyZW50IHdoZW4gcHJldmlvdXMgPSAnXFxcXCcgLT5cbiAgICAgICAgIGFkZF9jaGFyIGIgY3VycmVudDtcbiAgICAgICAgIHN1YnN0ICcgJyAoaSArIDEpXG4gICAgICB8ICckJyAtPlxuICAgICAgICAgbGV0IGogPSBpICsgMSBpblxuICAgICAgICAgbGV0IGlkZW50LCBuZXh0X2kgPSBmaW5kX2lkZW50IHMgaiBsaW0gaW5cbiAgICAgICAgIGFkZF9zdHJpbmcgYiAoZiBpZGVudCk7XG4gICAgICAgICBzdWJzdCAnICcgbmV4dF9pXG4gICAgICB8IGN1cnJlbnQgd2hlbiBwcmV2aW91cyA9PSAnXFxcXCcgLT5cbiAgICAgICAgIGFkZF9jaGFyIGIgJ1xcXFwnO1xuICAgICAgICAgYWRkX2NoYXIgYiBjdXJyZW50O1xuICAgICAgICAgc3Vic3QgJyAnIChpICsgMSlcbiAgICAgIHwgJ1xcXFwnIGFzIGN1cnJlbnQgLT5cbiAgICAgICAgIHN1YnN0IGN1cnJlbnQgKGkgKyAxKVxuICAgICAgfCBjdXJyZW50IC0+XG4gICAgICAgICBhZGRfY2hhciBiIGN1cnJlbnQ7XG4gICAgICAgICBzdWJzdCBjdXJyZW50IChpICsgMSlcbiAgICBlbmQgZWxzZVxuICAgIGlmIHByZXZpb3VzID0gJ1xcXFwnIHRoZW4gYWRkX2NoYXIgYiBwcmV2aW91cyBpblxuICBzdWJzdCAnICcgMFxuXG5sZXQgdHJ1bmNhdGUgYiBsZW4gPVxuICAgIGlmIGxlbiA8IDAgfHwgbGVuID4gbGVuZ3RoIGIgdGhlblxuICAgICAgaW52YWxpZF9hcmcgXCJCdWZmZXIudHJ1bmNhdGVcIlxuICAgIGVsc2VcbiAgICAgIGIucG9zaXRpb24gPC0gbGVuXG5cbigqKiB7MSBJdGVyYXRvcnN9ICopXG5cbmxldCB0b19zZXEgYiA9XG4gIGxldCByZWMgYXV4IGkgKCkgPVxuICAgICgqIE5vdGUgdGhhdCBiLnBvc2l0aW9uIGlzIG5vdCBhIGNvbnN0YW50IGFuZCBjYW5ub3QgYmUgbGlmdGVkIG91dCBvZiBhdXggKilcbiAgICBpZiBpID49IGIucG9zaXRpb24gdGhlbiBTZXEuTmlsXG4gICAgZWxzZVxuICAgICAgbGV0IHggPSBCeXRlcy51bnNhZmVfZ2V0IGIuYnVmZmVyIGkgaW5cbiAgICAgIFNlcS5Db25zICh4LCBhdXggKGkrMSkpXG4gIGluXG4gIGF1eCAwXG5cbmxldCB0b19zZXFpIGIgPVxuICBsZXQgcmVjIGF1eCBpICgpID1cbiAgICAoKiBOb3RlIHRoYXQgYi5wb3NpdGlvbiBpcyBub3QgYSBjb25zdGFudCBhbmQgY2Fubm90IGJlIGxpZnRlZCBvdXQgb2YgYXV4ICopXG4gICAgaWYgaSA+PSBiLnBvc2l0aW9uIHRoZW4gU2VxLk5pbFxuICAgIGVsc2VcbiAgICAgIGxldCB4ID0gQnl0ZXMudW5zYWZlX2dldCBiLmJ1ZmZlciBpIGluXG4gICAgICBTZXEuQ29ucyAoKGkseCksIGF1eCAoaSsxKSlcbiAgaW5cbiAgYXV4IDBcblxubGV0IGFkZF9zZXEgYiBzZXEgPSBTZXEuaXRlciAoYWRkX2NoYXIgYikgc2VxXG5cbmxldCBvZl9zZXEgaSA9XG4gIGxldCBiID0gY3JlYXRlIDMyIGluXG4gIGFkZF9zZXEgYiBpO1xuICBiXG5cbigqKiB7NiBCaW5hcnkgZW5jb2Rpbmcgb2YgaW50ZWdlcnN9ICopXG5cbmV4dGVybmFsIHVuc2FmZV9zZXRfaW50OCA6IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gdW5pdCA9IFwiJWJ5dGVzX3Vuc2FmZV9zZXRcIlxuZXh0ZXJuYWwgdW5zYWZlX3NldF9pbnQxNiA6IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gdW5pdCA9IFwiJWNhbWxfYnl0ZXNfc2V0MTZ1XCJcbmV4dGVybmFsIHVuc2FmZV9zZXRfaW50MzIgOiBieXRlcyAtPiBpbnQgLT4gaW50MzIgLT4gdW5pdCA9IFwiJWNhbWxfYnl0ZXNfc2V0MzJ1XCJcbmV4dGVybmFsIHVuc2FmZV9zZXRfaW50NjQgOiBieXRlcyAtPiBpbnQgLT4gaW50NjQgLT4gdW5pdCA9IFwiJWNhbWxfYnl0ZXNfc2V0NjR1XCJcbmV4dGVybmFsIHN3YXAxNiA6IGludCAtPiBpbnQgPSBcIiVic3dhcDE2XCJcbmV4dGVybmFsIHN3YXAzMiA6IGludDMyIC0+IGludDMyID0gXCIlYnN3YXBfaW50MzJcIlxuZXh0ZXJuYWwgc3dhcDY0IDogaW50NjQgLT4gaW50NjQgPSBcIiVic3dhcF9pbnQ2NFwiXG5cblxubGV0IGFkZF9pbnQ4IGIgeCA9XG4gIGxldCBuZXdfcG9zaXRpb24gPSBiLnBvc2l0aW9uICsgMSBpblxuICBpZiBuZXdfcG9zaXRpb24gPiBiLmxlbmd0aCB0aGVuIHJlc2l6ZSBiIDE7XG4gIHVuc2FmZV9zZXRfaW50OCBiLmJ1ZmZlciBiLnBvc2l0aW9uIHg7XG4gIGIucG9zaXRpb24gPC0gbmV3X3Bvc2l0aW9uXG5cbmxldCBhZGRfaW50MTZfbmUgYiB4ID1cbiAgbGV0IG5ld19wb3NpdGlvbiA9IGIucG9zaXRpb24gKyAyIGluXG4gIGlmIG5ld19wb3NpdGlvbiA+IGIubGVuZ3RoIHRoZW4gcmVzaXplIGIgMjtcbiAgdW5zYWZlX3NldF9pbnQxNiBiLmJ1ZmZlciBiLnBvc2l0aW9uIHg7XG4gIGIucG9zaXRpb24gPC0gbmV3X3Bvc2l0aW9uXG5cbmxldCBhZGRfaW50MzJfbmUgYiB4ID1cbiAgbGV0IG5ld19wb3NpdGlvbiA9IGIucG9zaXRpb24gKyA0IGluXG4gIGlmIG5ld19wb3NpdGlvbiA+IGIubGVuZ3RoIHRoZW4gcmVzaXplIGIgNDtcbiAgdW5zYWZlX3NldF9pbnQzMiBiLmJ1ZmZlciBiLnBvc2l0aW9uIHg7XG4gIGIucG9zaXRpb24gPC0gbmV3X3Bvc2l0aW9uXG5cbmxldCBhZGRfaW50NjRfbmUgYiB4ID1cbiAgbGV0IG5ld19wb3NpdGlvbiA9IGIucG9zaXRpb24gKyA4IGluXG4gIGlmIG5ld19wb3NpdGlvbiA+IGIubGVuZ3RoIHRoZW4gcmVzaXplIGIgODtcbiAgdW5zYWZlX3NldF9pbnQ2NCBiLmJ1ZmZlciBiLnBvc2l0aW9uIHg7XG4gIGIucG9zaXRpb24gPC0gbmV3X3Bvc2l0aW9uXG5cbmxldCBhZGRfaW50MTZfbGUgYiB4ID1cbiAgYWRkX2ludDE2X25lIGIgKGlmIFN5cy5iaWdfZW5kaWFuIHRoZW4gc3dhcDE2IHggZWxzZSB4KVxuXG5sZXQgYWRkX2ludDE2X2JlIGIgeCA9XG4gIGFkZF9pbnQxNl9uZSBiIChpZiBTeXMuYmlnX2VuZGlhbiB0aGVuIHggZWxzZSBzd2FwMTYgeClcblxubGV0IGFkZF9pbnQzMl9sZSBiIHggPVxuICBhZGRfaW50MzJfbmUgYiAoaWYgU3lzLmJpZ19lbmRpYW4gdGhlbiBzd2FwMzIgeCBlbHNlIHgpXG5cbmxldCBhZGRfaW50MzJfYmUgYiB4ID1cbiAgYWRkX2ludDMyX25lIGIgKGlmIFN5cy5iaWdfZW5kaWFuIHRoZW4geCBlbHNlIHN3YXAzMiB4KVxuXG5sZXQgYWRkX2ludDY0X2xlIGIgeCA9XG4gIGFkZF9pbnQ2NF9uZSBiIChpZiBTeXMuYmlnX2VuZGlhbiB0aGVuIHN3YXA2NCB4IGVsc2UgeClcblxubGV0IGFkZF9pbnQ2NF9iZSBiIHggPVxuICBhZGRfaW50NjRfbmUgYiAoaWYgU3lzLmJpZ19lbmRpYW4gdGhlbiB4IGVsc2Ugc3dhcDY0IHgpXG5cbmxldCBhZGRfdWludDggPSBhZGRfaW50OFxubGV0IGFkZF91aW50MTZfbmUgPSBhZGRfaW50MTZfbmVcbmxldCBhZGRfdWludDE2X2xlID0gYWRkX2ludDE2X2xlXG5sZXQgYWRkX3VpbnQxNl9iZSA9IGFkZF9pbnQxNl9iZVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBYYXZpZXIgTGVyb3kgYW5kIFBpZXJyZSBXZWlzLCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5vcGVuIENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljc1xub3BlbiBDYW1saW50ZXJuYWxGb3JtYXRcblxubGV0IGtmcHJpbnRmIGsgbyAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIG1ha2VfcHJpbnRmIChmdW4gYWNjIC0+IG91dHB1dF9hY2MgbyBhY2M7IGsgbykgRW5kX29mX2FjYyBmbXRcbmxldCBrYnByaW50ZiBrIGIgKEZvcm1hdCAoZm10LCBfKSkgPVxuICBtYWtlX3ByaW50ZiAoZnVuIGFjYyAtPiBidWZwdXRfYWNjIGIgYWNjOyBrIGIpIEVuZF9vZl9hY2MgZm10XG5sZXQgaWtmcHJpbnRmIGsgb2MgKEZvcm1hdCAoZm10LCBfKSkgPVxuICBtYWtlX2lwcmludGYgayBvYyBmbXRcbmxldCBpa2JwcmludGYgPSBpa2ZwcmludGZcblxubGV0IGZwcmludGYgb2MgZm10ID0ga2ZwcmludGYgaWdub3JlIG9jIGZtdFxubGV0IGJwcmludGYgYiBmbXQgPSBrYnByaW50ZiBpZ25vcmUgYiBmbXRcbmxldCBpZnByaW50ZiBvYyBmbXQgPSBpa2ZwcmludGYgaWdub3JlIG9jIGZtdFxubGV0IGlicHJpbnRmIGIgZm10ID0gaWticHJpbnRmIGlnbm9yZSBiIGZtdFxubGV0IHByaW50ZiBmbXQgPSBmcHJpbnRmIHN0ZG91dCBmbXRcbmxldCBlcHJpbnRmIGZtdCA9IGZwcmludGYgc3RkZXJyIGZtdFxuXG5sZXQga3NwcmludGYgayAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIGxldCBrJyBhY2MgPVxuICAgIGxldCBidWYgPSBCdWZmZXIuY3JlYXRlIDY0IGluXG4gICAgc3RycHV0X2FjYyBidWYgYWNjO1xuICAgIGsgKEJ1ZmZlci5jb250ZW50cyBidWYpIGluXG4gIG1ha2VfcHJpbnRmIGsnIEVuZF9vZl9hY2MgZm10XG5cbmxldCBzcHJpbnRmIGZtdCA9IGtzcHJpbnRmIChmdW4gcyAtPiBzKSBmbXRcblxubGV0IGtwcmludGYgPSBrc3ByaW50ZlxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgIERhbWllbiBEb2xpZ2V6LCBwcm9qZXQgUGFyYSwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlIGtleSA9IHN0cmluZ1xudHlwZSBkb2MgPSBzdHJpbmdcbnR5cGUgdXNhZ2VfbXNnID0gc3RyaW5nXG50eXBlIGFub25fZnVuID0gKHN0cmluZyAtPiB1bml0KVxuXG50eXBlIHNwZWMgPVxuICB8IFVuaXQgb2YgKHVuaXQgLT4gdW5pdCkgICAgICgqIENhbGwgdGhlIGZ1bmN0aW9uIHdpdGggdW5pdCBhcmd1bWVudCAqKVxuICB8IEJvb2wgb2YgKGJvb2wgLT4gdW5pdCkgICAgICgqIENhbGwgdGhlIGZ1bmN0aW9uIHdpdGggYSBib29sIGFyZ3VtZW50ICopXG4gIHwgU2V0IG9mIGJvb2wgcmVmICAgICAgICAgICAgKCogU2V0IHRoZSByZWZlcmVuY2UgdG8gdHJ1ZSAqKVxuICB8IENsZWFyIG9mIGJvb2wgcmVmICAgICAgICAgICgqIFNldCB0aGUgcmVmZXJlbmNlIHRvIGZhbHNlICopXG4gIHwgU3RyaW5nIG9mIChzdHJpbmcgLT4gdW5pdCkgKCogQ2FsbCB0aGUgZnVuY3Rpb24gd2l0aCBhIHN0cmluZyBhcmd1bWVudCAqKVxuICB8IFNldF9zdHJpbmcgb2Ygc3RyaW5nIHJlZiAgICgqIFNldCB0aGUgcmVmZXJlbmNlIHRvIHRoZSBzdHJpbmcgYXJndW1lbnQgKilcbiAgfCBJbnQgb2YgKGludCAtPiB1bml0KSAgICAgICAoKiBDYWxsIHRoZSBmdW5jdGlvbiB3aXRoIGFuIGludCBhcmd1bWVudCAqKVxuICB8IFNldF9pbnQgb2YgaW50IHJlZiAgICAgICAgICgqIFNldCB0aGUgcmVmZXJlbmNlIHRvIHRoZSBpbnQgYXJndW1lbnQgKilcbiAgfCBGbG9hdCBvZiAoZmxvYXQgLT4gdW5pdCkgICAoKiBDYWxsIHRoZSBmdW5jdGlvbiB3aXRoIGEgZmxvYXQgYXJndW1lbnQgKilcbiAgfCBTZXRfZmxvYXQgb2YgZmxvYXQgcmVmICAgICAoKiBTZXQgdGhlIHJlZmVyZW5jZSB0byB0aGUgZmxvYXQgYXJndW1lbnQgKilcbiAgfCBUdXBsZSBvZiBzcGVjIGxpc3QgICAgICAgICAoKiBUYWtlIHNldmVyYWwgYXJndW1lbnRzIGFjY29yZGluZyB0byB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGVjIGxpc3QgKilcbiAgfCBTeW1ib2wgb2Ygc3RyaW5nIGxpc3QgKiAoc3RyaW5nIC0+IHVuaXQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogVGFrZSBvbmUgb2YgdGhlIHN5bWJvbHMgYXMgYXJndW1lbnQgYW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbCB0aGUgZnVuY3Rpb24gd2l0aCB0aGUgc3ltYm9sLiAqKVxuICB8IFJlc3Qgb2YgKHN0cmluZyAtPiB1bml0KSAgICgqIFN0b3AgaW50ZXJwcmV0aW5nIGtleXdvcmRzIGFuZCBjYWxsIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHdpdGggZWFjaCByZW1haW5pbmcgYXJndW1lbnQgKilcbiAgfCBSZXN0X2FsbCBvZiAoc3RyaW5nIGxpc3QgLT4gdW5pdClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBTdG9wIGludGVycHJldGluZyBrZXl3b3JkcyBhbmQgY2FsbCB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiB3aXRoIGFsbCByZW1haW5pbmcgYXJndW1lbnRzLiAqKVxuICB8IEV4cGFuZCBvZiAoc3RyaW5nIC0+IHN0cmluZyBhcnJheSkgKCogSWYgdGhlIHJlbWFpbmluZyBhcmd1bWVudHMgdG8gcHJvY2Vzc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJlIG9mIHRoZSBmb3JtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbW1wiLWZvb1wiOyBcImFyZ1wiXSBAIHJlc3RdIHdoZXJlIFwiZm9vXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzIHJlZ2lzdGVyZWQgYXMgW0V4cGFuZCBmXSwgdGhlbiB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50cyBbZiBcImFyZ1wiIEAgcmVzdF0gYXJlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzZWQuIE9ubHkgYWxsb3dlZCBpblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3BhcnNlX2FuZF9leHBhbmRfYXJndl9keW5hbWljXS4gKilcblxuZXhjZXB0aW9uIEJhZCBvZiBzdHJpbmdcbmV4Y2VwdGlvbiBIZWxwIG9mIHN0cmluZ1xuXG50eXBlIGVycm9yID1cbiAgfCBVbmtub3duIG9mIHN0cmluZ1xuICB8IFdyb25nIG9mIHN0cmluZyAqIHN0cmluZyAqIHN0cmluZyAgKCogb3B0aW9uLCBhY3R1YWwsIGV4cGVjdGVkICopXG4gIHwgTWlzc2luZyBvZiBzdHJpbmdcbiAgfCBNZXNzYWdlIG9mIHN0cmluZ1xuXG5leGNlcHRpb24gU3RvcCBvZiBlcnJvciAoKiB1c2VkIGludGVybmFsbHkgKilcblxub3BlbiBQcmludGZcblxubGV0IHJlYyBhc3NvYzMgeCBsID1cbiAgbWF0Y2ggbCB3aXRoXG4gIHwgW10gLT4gcmFpc2UgTm90X2ZvdW5kXG4gIHwgKHkxLCB5MiwgXykgOjogXyB3aGVuIHkxID0geCAtPiB5MlxuICB8IF8gOjogdCAtPiBhc3NvYzMgeCB0XG5cblxubGV0IHNwbGl0IHMgPVxuICBsZXQgaSA9IFN0cmluZy5pbmRleCBzICc9JyBpblxuICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gIFN0cmluZy5zdWIgcyAwIGksIFN0cmluZy5zdWIgcyAoaSsxKSAobGVuLShpKzEpKVxuXG5cbmxldCBtYWtlX3N5bWxpc3QgcHJlZml4IHNlcCBzdWZmaXggbCA9XG4gIG1hdGNoIGwgd2l0aFxuICB8IFtdIC0+IFwiPG5vbmU+XCJcbiAgfCBoOjp0IC0+IChMaXN0LmZvbGRfbGVmdCAoZnVuIHggeSAtPiB4IF4gc2VwIF4geSkgKHByZWZpeCBeIGgpIHQpIF4gc3VmZml4XG5cblxubGV0IHByaW50X3NwZWMgYnVmIChrZXksIHNwZWMsIGRvYykgPVxuICBpZiBTdHJpbmcubGVuZ3RoIGRvYyA+IDAgdGhlblxuICAgIG1hdGNoIHNwZWMgd2l0aFxuICAgIHwgU3ltYm9sIChsLCBfKSAtPlxuICAgICAgICBicHJpbnRmIGJ1ZiBcIiAgJXMgJXMlc1xcblwiIGtleSAobWFrZV9zeW1saXN0IFwie1wiIFwifFwiIFwifVwiIGwpIGRvY1xuICAgIHwgXyAtPlxuICAgICAgICBicHJpbnRmIGJ1ZiBcIiAgJXMgJXNcXG5cIiBrZXkgZG9jXG5cblxubGV0IGhlbHBfYWN0aW9uICgpID0gcmFpc2UgKFN0b3AgKFVua25vd24gXCItaGVscFwiKSlcblxubGV0IGFkZF9oZWxwIHNwZWNsaXN0ID1cbiAgbGV0IGFkZDEgPVxuICAgIHRyeSBpZ25vcmUgKGFzc29jMyBcIi1oZWxwXCIgc3BlY2xpc3QpOyBbXVxuICAgIHdpdGggTm90X2ZvdW5kIC0+XG4gICAgICAgICAgICBbXCItaGVscFwiLCBVbml0IGhlbHBfYWN0aW9uLCBcIiBEaXNwbGF5IHRoaXMgbGlzdCBvZiBvcHRpb25zXCJdXG4gIGFuZCBhZGQyID1cbiAgICB0cnkgaWdub3JlIChhc3NvYzMgXCItLWhlbHBcIiBzcGVjbGlzdCk7IFtdXG4gICAgd2l0aCBOb3RfZm91bmQgLT5cbiAgICAgICAgICAgIFtcIi0taGVscFwiLCBVbml0IGhlbHBfYWN0aW9uLCBcIiBEaXNwbGF5IHRoaXMgbGlzdCBvZiBvcHRpb25zXCJdXG4gIGluXG4gIHNwZWNsaXN0IEAgKGFkZDEgQCBhZGQyKVxuXG5cbmxldCB1c2FnZV9iIGJ1ZiBzcGVjbGlzdCBlcnJtc2cgPVxuICBicHJpbnRmIGJ1ZiBcIiVzXFxuXCIgZXJybXNnO1xuICBMaXN0Lml0ZXIgKHByaW50X3NwZWMgYnVmKSAoYWRkX2hlbHAgc3BlY2xpc3QpXG5cblxubGV0IHVzYWdlX3N0cmluZyBzcGVjbGlzdCBlcnJtc2cgPVxuICBsZXQgYiA9IEJ1ZmZlci5jcmVhdGUgMjAwIGluXG4gIHVzYWdlX2IgYiBzcGVjbGlzdCBlcnJtc2c7XG4gIEJ1ZmZlci5jb250ZW50cyBiXG5cblxubGV0IHVzYWdlIHNwZWNsaXN0IGVycm1zZyA9XG4gIGVwcmludGYgXCIlc1wiICh1c2FnZV9zdHJpbmcgc3BlY2xpc3QgZXJybXNnKVxuXG5cbmxldCBjdXJyZW50ID0gcmVmIDBcblxubGV0IGJvb2xfb2Zfc3RyaW5nX29wdCB4ID1cbiAgdHJ5IFNvbWUgKGJvb2xfb2Zfc3RyaW5nIHgpXG4gIHdpdGggSW52YWxpZF9hcmd1bWVudCBfIC0+IE5vbmVcblxubGV0IGludF9vZl9zdHJpbmdfb3B0IHggPVxuICB0cnkgU29tZSAoaW50X29mX3N0cmluZyB4KVxuICB3aXRoIEZhaWx1cmUgXyAtPiBOb25lXG5cbmxldCBmbG9hdF9vZl9zdHJpbmdfb3B0IHggPVxuICB0cnkgU29tZSAoZmxvYXRfb2Zfc3RyaW5nIHgpXG4gIHdpdGggRmFpbHVyZSBfIC0+IE5vbmVcblxubGV0IHBhcnNlX2FuZF9leHBhbmRfYXJndl9keW5hbWljX2F1eCBhbGxvd19leHBhbmQgY3VycmVudCBhcmd2IHNwZWNsaXN0IGFub25mdW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJybXNnID1cbiAgbGV0IGluaXRwb3MgPSAhY3VycmVudCBpblxuICBsZXQgY29udmVydF9lcnJvciBlcnJvciA9XG4gICAgKCogY29udmVydCBhbiBpbnRlcm5hbCBlcnJvciB0byBhIEJhZC9IZWxwIGV4Y2VwdGlvblxuICAgICAgICpvciogYWRkIHRoZSBwcm9ncmFtIG5hbWUgYXMgYSBwcmVmaXggYW5kIHRoZSB1c2FnZSBtZXNzYWdlIGFzIGEgc3VmZml4XG4gICAgICAgdG8gYW4gdXNlci1yYWlzZWQgQmFkIGV4Y2VwdGlvbi5cbiAgICAqKVxuICAgIGxldCBiID0gQnVmZmVyLmNyZWF0ZSAyMDAgaW5cbiAgICBsZXQgcHJvZ25hbWUgPVxuICAgICAgaWYgaW5pdHBvcyA8IChBcnJheS5sZW5ndGggIWFyZ3YpIHRoZW4gIWFyZ3YuKGluaXRwb3MpIGVsc2UgXCIoPylcIiBpblxuICAgIGJlZ2luIG1hdGNoIGVycm9yIHdpdGhcbiAgICAgIHwgVW5rbm93biBcIi1oZWxwXCIgLT4gKClcbiAgICAgIHwgVW5rbm93biBcIi0taGVscFwiIC0+ICgpXG4gICAgICB8IFVua25vd24gcyAtPlxuICAgICAgICAgIGJwcmludGYgYiBcIiVzOiB1bmtub3duIG9wdGlvbiAnJXMnLlxcblwiIHByb2duYW1lIHNcbiAgICAgIHwgTWlzc2luZyBzIC0+XG4gICAgICAgICAgYnByaW50ZiBiIFwiJXM6IG9wdGlvbiAnJXMnIG5lZWRzIGFuIGFyZ3VtZW50LlxcblwiIHByb2duYW1lIHNcbiAgICAgIHwgV3JvbmcgKG9wdCwgYXJnLCBleHBlY3RlZCkgLT5cbiAgICAgICAgICBicHJpbnRmIGIgXCIlczogd3JvbmcgYXJndW1lbnQgJyVzJzsgb3B0aW9uICclcycgZXhwZWN0cyAlcy5cXG5cIlxuICAgICAgICAgICAgICAgICAgcHJvZ25hbWUgYXJnIG9wdCBleHBlY3RlZFxuICAgICAgfCBNZXNzYWdlIHMgLT4gKCogdXNlciBlcnJvciBtZXNzYWdlICopXG4gICAgICAgICAgYnByaW50ZiBiIFwiJXM6ICVzLlxcblwiIHByb2duYW1lIHNcbiAgICBlbmQ7XG4gICAgdXNhZ2VfYiBiICFzcGVjbGlzdCBlcnJtc2c7XG4gICAgaWYgZXJyb3IgPSBVbmtub3duIFwiLWhlbHBcIiB8fCBlcnJvciA9IFVua25vd24gXCItLWhlbHBcIlxuICAgIHRoZW4gSGVscCAoQnVmZmVyLmNvbnRlbnRzIGIpXG4gICAgZWxzZSBCYWQgKEJ1ZmZlci5jb250ZW50cyBiKVxuICBpblxuICBpbmNyIGN1cnJlbnQ7XG4gIHdoaWxlICFjdXJyZW50IDwgKEFycmF5Lmxlbmd0aCAhYXJndikgZG9cbiAgICBiZWdpbiB0cnlcbiAgICAgIGxldCBzID0gIWFyZ3YuKCFjdXJyZW50KSBpblxuICAgICAgaWYgU3RyaW5nLmxlbmd0aCBzID49IDEgJiYgcy5bMF0gPSAnLScgdGhlbiBiZWdpblxuICAgICAgICBsZXQgYWN0aW9uLCBmb2xsb3cgPVxuICAgICAgICAgIHRyeSBhc3NvYzMgcyAhc3BlY2xpc3QsIE5vbmVcbiAgICAgICAgICB3aXRoIE5vdF9mb3VuZCAtPlxuICAgICAgICAgIHRyeVxuICAgICAgICAgICAgbGV0IGtleXdvcmQsIGFyZyA9IHNwbGl0IHMgaW5cbiAgICAgICAgICAgIGFzc29jMyBrZXl3b3JkICFzcGVjbGlzdCwgU29tZSBhcmdcbiAgICAgICAgICB3aXRoIE5vdF9mb3VuZCAtPiByYWlzZSAoU3RvcCAoVW5rbm93biBzKSlcbiAgICAgICAgaW5cbiAgICAgICAgbGV0IG5vX2FyZyAoKSA9XG4gICAgICAgICAgbWF0Y2ggZm9sbG93IHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gKClcbiAgICAgICAgICB8IFNvbWUgYXJnIC0+IHJhaXNlIChTdG9wIChXcm9uZyAocywgYXJnLCBcIm5vIGFyZ3VtZW50XCIpKSkgaW5cbiAgICAgICAgbGV0IGdldF9hcmcgKCkgPVxuICAgICAgICAgIG1hdGNoIGZvbGxvdyB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgICAgIGlmICFjdXJyZW50ICsgMSA8IChBcnJheS5sZW5ndGggIWFyZ3YpIHRoZW4gIWFyZ3YuKCFjdXJyZW50ICsgMSlcbiAgICAgICAgICAgICAgZWxzZSByYWlzZSAoU3RvcCAoTWlzc2luZyBzKSlcbiAgICAgICAgICB8IFNvbWUgYXJnIC0+IGFyZ1xuICAgICAgICBpblxuICAgICAgICBsZXQgY29uc3VtZV9hcmcgKCkgPVxuICAgICAgICAgIG1hdGNoIGZvbGxvdyB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+IGluY3IgY3VycmVudFxuICAgICAgICAgIHwgU29tZSBfIC0+ICgpXG4gICAgICAgIGluXG4gICAgICAgIGxldCByZWMgdHJlYXRfYWN0aW9uID0gZnVuY3Rpb25cbiAgICAgICAgfCBVbml0IGYgLT4gbm9fYXJnICgpOyBmICgpO1xuICAgICAgICB8IEJvb2wgZiAtPlxuICAgICAgICAgICAgbGV0IGFyZyA9IGdldF9hcmcgKCkgaW5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIGJvb2xfb2Zfc3RyaW5nX29wdCBhcmcgd2l0aFxuICAgICAgICAgICAgfCBOb25lIC0+IHJhaXNlIChTdG9wIChXcm9uZyAocywgYXJnLCBcImEgYm9vbGVhblwiKSkpXG4gICAgICAgICAgICB8IFNvbWUgcyAtPiBmIHNcbiAgICAgICAgICAgIGVuZDtcbiAgICAgICAgICAgIGNvbnN1bWVfYXJnICgpO1xuICAgICAgICB8IFNldCByIC0+IG5vX2FyZyAoKTsgciA6PSB0cnVlO1xuICAgICAgICB8IENsZWFyIHIgLT4gbm9fYXJnICgpOyByIDo9IGZhbHNlO1xuICAgICAgICB8IFN0cmluZyBmIC0+XG4gICAgICAgICAgICBsZXQgYXJnID0gZ2V0X2FyZyAoKSBpblxuICAgICAgICAgICAgZiBhcmc7XG4gICAgICAgICAgICBjb25zdW1lX2FyZyAoKTtcbiAgICAgICAgfCBTeW1ib2wgKHN5bWIsIGYpIC0+XG4gICAgICAgICAgICBsZXQgYXJnID0gZ2V0X2FyZyAoKSBpblxuICAgICAgICAgICAgaWYgTGlzdC5tZW0gYXJnIHN5bWIgdGhlbiBiZWdpblxuICAgICAgICAgICAgICBmIGFyZztcbiAgICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgICAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgICAgICAgICByYWlzZSAoU3RvcCAoV3JvbmcgKHMsIGFyZywgXCJvbmUgb2Y6IFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBeIChtYWtlX3N5bWxpc3QgXCJcIiBcIiBcIiBcIlwiIHN5bWIpKSkpXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgfCBTZXRfc3RyaW5nIHIgLT5cbiAgICAgICAgICAgIHIgOj0gZ2V0X2FyZyAoKTtcbiAgICAgICAgICAgIGNvbnN1bWVfYXJnICgpO1xuICAgICAgICB8IEludCBmIC0+XG4gICAgICAgICAgICBsZXQgYXJnID0gZ2V0X2FyZyAoKSBpblxuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggaW50X29mX3N0cmluZ19vcHQgYXJnIHdpdGhcbiAgICAgICAgICAgIHwgTm9uZSAtPiByYWlzZSAoU3RvcCAoV3JvbmcgKHMsIGFyZywgXCJhbiBpbnRlZ2VyXCIpKSlcbiAgICAgICAgICAgIHwgU29tZSB4IC0+IGYgeFxuICAgICAgICAgICAgZW5kO1xuICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgIHwgU2V0X2ludCByIC0+XG4gICAgICAgICAgICBsZXQgYXJnID0gZ2V0X2FyZyAoKSBpblxuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggaW50X29mX3N0cmluZ19vcHQgYXJnIHdpdGhcbiAgICAgICAgICAgIHwgTm9uZSAtPiByYWlzZSAoU3RvcCAoV3JvbmcgKHMsIGFyZywgXCJhbiBpbnRlZ2VyXCIpKSlcbiAgICAgICAgICAgIHwgU29tZSB4IC0+IHIgOj0geFxuICAgICAgICAgICAgZW5kO1xuICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgIHwgRmxvYXQgZiAtPlxuICAgICAgICAgICAgbGV0IGFyZyA9IGdldF9hcmcgKCkgaW5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIGZsb2F0X29mX3N0cmluZ19vcHQgYXJnIHdpdGhcbiAgICAgICAgICAgIHwgTm9uZSAtPiByYWlzZSAoU3RvcCAoV3JvbmcgKHMsIGFyZywgXCJhIGZsb2F0XCIpKSlcbiAgICAgICAgICAgIHwgU29tZSB4IC0+IGYgeFxuICAgICAgICAgICAgZW5kO1xuICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgIHwgU2V0X2Zsb2F0IHIgLT5cbiAgICAgICAgICAgIGxldCBhcmcgPSBnZXRfYXJnICgpIGluXG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBmbG9hdF9vZl9zdHJpbmdfb3B0IGFyZyB3aXRoXG4gICAgICAgICAgICB8IE5vbmUgLT4gcmFpc2UgKFN0b3AgKFdyb25nIChzLCBhcmcsIFwiYSBmbG9hdFwiKSkpXG4gICAgICAgICAgICB8IFNvbWUgeCAtPiByIDo9IHhcbiAgICAgICAgICAgIGVuZDtcbiAgICAgICAgICAgIGNvbnN1bWVfYXJnICgpO1xuICAgICAgICB8IFR1cGxlIHNwZWNzIC0+XG4gICAgICAgICAgICBub19hcmcgKCk7XG4gICAgICAgICAgICBMaXN0Lml0ZXIgdHJlYXRfYWN0aW9uIHNwZWNzO1xuICAgICAgICB8IFJlc3QgZiAtPlxuICAgICAgICAgICAgbm9fYXJnICgpO1xuICAgICAgICAgICAgd2hpbGUgIWN1cnJlbnQgPCAoQXJyYXkubGVuZ3RoICFhcmd2KSAtIDEgZG9cbiAgICAgICAgICAgICAgZiAhYXJndi4oIWN1cnJlbnQgKyAxKTtcbiAgICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgICAgICBkb25lO1xuICAgICAgICB8IFJlc3RfYWxsIGYgLT5cbiAgICAgICAgICAgIG5vX2FyZyAoKTtcbiAgICAgICAgICAgIGxldCBhY2MgPSByZWYgW10gaW5cbiAgICAgICAgICAgIHdoaWxlICFjdXJyZW50IDwgQXJyYXkubGVuZ3RoICFhcmd2IC0gMSBkb1xuICAgICAgICAgICAgICBhY2MgOj0gIWFyZ3YuKCFjdXJyZW50ICsgMSkgOjogIWFjYztcbiAgICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgICAgICBkb25lO1xuICAgICAgICAgICAgZiAoTGlzdC5yZXYgIWFjYylcbiAgICAgICAgfCBFeHBhbmQgZiAtPlxuICAgICAgICAgICAgaWYgbm90IGFsbG93X2V4cGFuZCB0aGVuXG4gICAgICAgICAgICAgIHJhaXNlIChJbnZhbGlkX2FyZ3VtZW50IFwiQXJnLkV4cGFuZCBpcyBpcyBvbmx5IGFsbG93ZWQgd2l0aCBcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQXJnLnBhcnNlX2FuZF9leHBhbmRfYXJndl9keW5hbWljXCIpO1xuICAgICAgICAgICAgbGV0IGFyZyA9IGdldF9hcmcgKCkgaW5cbiAgICAgICAgICAgIGxldCBuZXdhcmcgPSBmIGFyZyBpblxuICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgICAgICBsZXQgYmVmb3JlID0gQXJyYXkuc3ViICFhcmd2IDAgKCFjdXJyZW50ICsgMSlcbiAgICAgICAgICAgIGFuZCBhZnRlciA9XG4gICAgICAgICAgICAgIEFycmF5LnN1YiAhYXJndiAoIWN1cnJlbnQgKyAxKVxuICAgICAgICAgICAgICAgICAgICAgICAgKChBcnJheS5sZW5ndGggIWFyZ3YpIC0gIWN1cnJlbnQgLSAxKSBpblxuICAgICAgICAgICAgYXJndjo9IEFycmF5LmNvbmNhdCBbYmVmb3JlO25ld2FyZzthZnRlcl07XG4gICAgICAgIGluXG4gICAgICAgIHRyZWF0X2FjdGlvbiBhY3Rpb24gZW5kXG4gICAgICBlbHNlIGFub25mdW4gc1xuICAgIHdpdGggfCBCYWQgbSAtPiByYWlzZSAoY29udmVydF9lcnJvciAoTWVzc2FnZSBtKSk7XG4gICAgICAgICB8IFN0b3AgZSAtPiByYWlzZSAoY29udmVydF9lcnJvciBlKTtcbiAgICBlbmQ7XG4gICAgaW5jciBjdXJyZW50XG4gIGRvbmVcblxubGV0IHBhcnNlX2FuZF9leHBhbmRfYXJndl9keW5hbWljIGN1cnJlbnQgYXJndiBzcGVjbGlzdCBhbm9uZnVuIGVycm1zZyA9XG4gIHBhcnNlX2FuZF9leHBhbmRfYXJndl9keW5hbWljX2F1eCB0cnVlIGN1cnJlbnQgYXJndiBzcGVjbGlzdCBhbm9uZnVuIGVycm1zZ1xuXG5sZXQgcGFyc2VfYXJndl9keW5hbWljID8oY3VycmVudD1jdXJyZW50KSBhcmd2IHNwZWNsaXN0IGFub25mdW4gZXJybXNnID1cbiAgcGFyc2VfYW5kX2V4cGFuZF9hcmd2X2R5bmFtaWNfYXV4IGZhbHNlIGN1cnJlbnQgKHJlZiBhcmd2KSBzcGVjbGlzdCBhbm9uZnVuXG4gICAgZXJybXNnXG5cblxubGV0IHBhcnNlX2FyZ3YgPyhjdXJyZW50PWN1cnJlbnQpIGFyZ3Ygc3BlY2xpc3QgYW5vbmZ1biBlcnJtc2cgPVxuICBwYXJzZV9hcmd2X2R5bmFtaWMgfmN1cnJlbnQ6Y3VycmVudCBhcmd2IChyZWYgc3BlY2xpc3QpIGFub25mdW4gZXJybXNnXG5cblxubGV0IHBhcnNlIGwgZiBtc2cgPVxuICB0cnlcbiAgICBwYXJzZV9hcmd2IFN5cy5hcmd2IGwgZiBtc2dcbiAgd2l0aFxuICB8IEJhZCBtc2cgLT4gZXByaW50ZiBcIiVzXCIgbXNnOyBleGl0IDJcbiAgfCBIZWxwIG1zZyAtPiBwcmludGYgXCIlc1wiIG1zZzsgZXhpdCAwXG5cblxubGV0IHBhcnNlX2R5bmFtaWMgbCBmIG1zZyA9XG4gIHRyeVxuICAgIHBhcnNlX2FyZ3ZfZHluYW1pYyBTeXMuYXJndiBsIGYgbXNnXG4gIHdpdGhcbiAgfCBCYWQgbXNnIC0+IGVwcmludGYgXCIlc1wiIG1zZzsgZXhpdCAyXG4gIHwgSGVscCBtc2cgLT4gcHJpbnRmIFwiJXNcIiBtc2c7IGV4aXQgMFxuXG5sZXQgcGFyc2VfZXhwYW5kIGwgZiBtc2cgPVxuICB0cnlcbiAgICBsZXQgYXJndiA9IHJlZiBTeXMuYXJndiBpblxuICAgIGxldCBzcGVjID0gcmVmIGwgaW5cbiAgICBsZXQgY3VycmVudCA9IHJlZiAoIWN1cnJlbnQpIGluXG4gICAgcGFyc2VfYW5kX2V4cGFuZF9hcmd2X2R5bmFtaWMgY3VycmVudCBhcmd2IHNwZWMgZiBtc2dcbiAgd2l0aFxuICB8IEJhZCBtc2cgLT4gZXByaW50ZiBcIiVzXCIgbXNnOyBleGl0IDJcbiAgfCBIZWxwIG1zZyAtPiBwcmludGYgXCIlc1wiIG1zZzsgZXhpdCAwXG5cblxubGV0IHNlY29uZF93b3JkIHMgPVxuICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gIGxldCByZWMgbG9vcCBuID1cbiAgICBpZiBuID49IGxlbiB0aGVuIGxlblxuICAgIGVsc2UgaWYgcy5bbl0gPSAnICcgdGhlbiBsb29wIChuKzEpXG4gICAgZWxzZSBuXG4gIGluXG4gIG1hdGNoIFN0cmluZy5pbmRleCBzICdcXHQnIHdpdGhcbiAgfCBuIC0+IGxvb3AgKG4rMSlcbiAgfCBleGNlcHRpb24gTm90X2ZvdW5kIC0+XG4gICAgICBiZWdpbiBtYXRjaCBTdHJpbmcuaW5kZXggcyAnICcgd2l0aFxuICAgICAgfCBuIC0+IGxvb3AgKG4rMSlcbiAgICAgIHwgZXhjZXB0aW9uIE5vdF9mb3VuZCAtPiBsZW5cbiAgICAgIGVuZFxuXG5cbmxldCBtYXhfYXJnX2xlbiBjdXIgKGt3ZCwgc3BlYywgZG9jKSA9XG4gIG1hdGNoIHNwZWMgd2l0aFxuICB8IFN5bWJvbCBfIC0+IG1heCBjdXIgKFN0cmluZy5sZW5ndGgga3dkKVxuICB8IF8gLT4gbWF4IGN1ciAoU3RyaW5nLmxlbmd0aCBrd2QgKyBzZWNvbmRfd29yZCBkb2MpXG5cblxubGV0IHJlcGxhY2VfbGVhZGluZ190YWIgcyA9XG4gIGxldCBzZWVuID0gcmVmIGZhbHNlIGluXG4gIFN0cmluZy5tYXAgKGZ1bmN0aW9uICdcXHQnIHdoZW4gbm90ICFzZWVuIC0+IHNlZW4gOj0gdHJ1ZTsgJyAnIHwgYyAtPiBjKSBzXG5cbmxldCBhZGRfcGFkZGluZyBsZW4ga3NkID1cbiAgbWF0Y2gga3NkIHdpdGhcbiAgfCAoXywgXywgXCJcIikgLT5cbiAgICAgICgqIERvIG5vdCBwYWQgdW5kb2N1bWVudGVkIG9wdGlvbnMsIHNvIHRoYXQgdGhleSBzdGlsbCBkb24ndCBzaG93IHVwIHdoZW5cbiAgICAgICAqIHJ1biB0aHJvdWdoIFt1c2FnZV0gb3IgW3BhcnNlXS4gKilcbiAgICAgIGtzZFxuICB8IChrd2QsIChTeW1ib2wgXyBhcyBzcGVjKSwgbXNnKSAtPlxuICAgICAgbGV0IGN1dGNvbCA9IHNlY29uZF93b3JkIG1zZyBpblxuICAgICAgbGV0IHNwYWNlcyA9IFN0cmluZy5tYWtlICgobWF4IDAgKGxlbiAtIGN1dGNvbCkpICsgMykgJyAnIGluXG4gICAgICAoa3dkLCBzcGVjLCBcIlxcblwiIF4gc3BhY2VzIF4gcmVwbGFjZV9sZWFkaW5nX3RhYiBtc2cpXG4gIHwgKGt3ZCwgc3BlYywgbXNnKSAtPlxuICAgICAgbGV0IGN1dGNvbCA9IHNlY29uZF93b3JkIG1zZyBpblxuICAgICAgbGV0IGt3ZF9sZW4gPSBTdHJpbmcubGVuZ3RoIGt3ZCBpblxuICAgICAgbGV0IGRpZmYgPSBsZW4gLSBrd2RfbGVuIC0gY3V0Y29sIGluXG4gICAgICBpZiBkaWZmIDw9IDAgdGhlblxuICAgICAgICAoa3dkLCBzcGVjLCByZXBsYWNlX2xlYWRpbmdfdGFiIG1zZylcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IHNwYWNlcyA9IFN0cmluZy5tYWtlIGRpZmYgJyAnIGluXG4gICAgICAgIGxldCBwcmVmaXggPSBTdHJpbmcuc3ViIChyZXBsYWNlX2xlYWRpbmdfdGFiIG1zZykgMCBjdXRjb2wgaW5cbiAgICAgICAgbGV0IHN1ZmZpeCA9IFN0cmluZy5zdWIgbXNnIGN1dGNvbCAoU3RyaW5nLmxlbmd0aCBtc2cgLSBjdXRjb2wpIGluXG4gICAgICAgIChrd2QsIHNwZWMsIHByZWZpeCBeIHNwYWNlcyBeIHN1ZmZpeClcblxuXG5sZXQgYWxpZ24gPyhsaW1pdD1tYXhfaW50KSBzcGVjbGlzdCA9XG4gIGxldCBjb21wbGV0ZWQgPSBhZGRfaGVscCBzcGVjbGlzdCBpblxuICBsZXQgbGVuID0gTGlzdC5mb2xkX2xlZnQgbWF4X2FyZ19sZW4gMCBjb21wbGV0ZWQgaW5cbiAgbGV0IGxlbiA9IG1pbiBsZW4gbGltaXQgaW5cbiAgTGlzdC5tYXAgKGFkZF9wYWRkaW5nIGxlbikgY29tcGxldGVkXG5cbmxldCB0cmltX2NyIHMgPVxuICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gIGlmIGxlbiA+IDAgJiYgU3RyaW5nLmdldCBzIChsZW4gLSAxKSA9ICdcXHInIHRoZW5cbiAgICBTdHJpbmcuc3ViIHMgMCAobGVuIC0gMSlcbiAgZWxzZVxuICAgIHNcblxubGV0IHJlYWRfYXV4IHRyaW0gc2VwIGZpbGUgPVxuICBsZXQgaWMgPSBvcGVuX2luX2JpbiBmaWxlIGluXG4gIGxldCBidWYgPSBCdWZmZXIuY3JlYXRlIDIwMCBpblxuICBsZXQgd29yZHMgPSByZWYgW10gaW5cbiAgbGV0IHN0YXNoICgpID1cbiAgICBsZXQgd29yZCA9IEJ1ZmZlci5jb250ZW50cyBidWYgaW5cbiAgICBsZXQgd29yZCA9IGlmIHRyaW0gdGhlbiB0cmltX2NyIHdvcmQgZWxzZSB3b3JkIGluXG4gICAgd29yZHMgOj0gd29yZCA6OiAhd29yZHM7XG4gICAgQnVmZmVyLmNsZWFyIGJ1ZlxuICBpblxuICBiZWdpblxuICAgIHRyeSB3aGlsZSB0cnVlIGRvXG4gICAgICAgIGxldCBjID0gaW5wdXRfY2hhciBpYyBpblxuICAgICAgICBpZiBjID0gc2VwIHRoZW4gc3Rhc2ggKCkgZWxzZSBCdWZmZXIuYWRkX2NoYXIgYnVmIGNcbiAgICAgIGRvbmVcbiAgICB3aXRoIEVuZF9vZl9maWxlIC0+ICgpXG4gIGVuZDtcbiAgaWYgQnVmZmVyLmxlbmd0aCBidWYgPiAwIHRoZW4gc3Rhc2ggKCk7XG4gIGNsb3NlX2luIGljO1xuICBBcnJheS5vZl9saXN0IChMaXN0LnJldiAhd29yZHMpXG5cbmxldCByZWFkX2FyZyA9IHJlYWRfYXV4IHRydWUgJ1xcbidcblxubGV0IHJlYWRfYXJnMCA9IHJlYWRfYXV4IGZhbHNlICdcXHgwMCdcblxubGV0IHdyaXRlX2F1eCBzZXAgZmlsZSBhcmdzID1cbiAgbGV0IG9jID0gb3Blbl9vdXRfYmluIGZpbGUgaW5cbiAgQXJyYXkuaXRlciAoZnVuIHMgLT4gZnByaW50ZiBvYyBcIiVzJWNcIiBzIHNlcCkgYXJncztcbiAgY2xvc2Vfb3V0IG9jXG5cbmxldCB3cml0ZV9hcmcgPSB3cml0ZV9hdXggJ1xcbidcblxubGV0IHdyaXRlX2FyZzAgPSB3cml0ZV9hdXggJ1xceDAwJ1xuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgVGhlIE9DYW1sIHByb2dyYW1tZXJzICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxOCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5leHRlcm5hbCBpZCA6ICdhIC0+ICdhID0gXCIlaWRlbnRpdHlcIlxubGV0IGNvbnN0IGMgXyA9IGNcbmxldCBmbGlwIGYgeCB5ID0gZiB5IHhcbmxldCBuZWdhdGUgcCB2ID0gbm90IChwIHYpXG5cbmV4Y2VwdGlvbiBGaW5hbGx5X3JhaXNlZCBvZiBleG5cblxubGV0ICgpID0gUHJpbnRleGMucmVnaXN0ZXJfcHJpbnRlciBAQCBmdW5jdGlvblxufCBGaW5hbGx5X3JhaXNlZCBleG4gLT4gU29tZSAoXCJGdW4uRmluYWxseV9yYWlzZWQ6IFwiIF4gUHJpbnRleGMudG9fc3RyaW5nIGV4bilcbnwgXyAtPiBOb25lXG5cbmxldCBwcm90ZWN0IH4oZmluYWxseSA6IHVuaXQgLT4gdW5pdCkgd29yayA9XG4gIGxldCBmaW5hbGx5X25vX2V4biAoKSA9XG4gICAgdHJ5IGZpbmFsbHkgKCkgd2l0aCBlIC0+XG4gICAgICBsZXQgYnQgPSBQcmludGV4Yy5nZXRfcmF3X2JhY2t0cmFjZSAoKSBpblxuICAgICAgUHJpbnRleGMucmFpc2Vfd2l0aF9iYWNrdHJhY2UgKEZpbmFsbHlfcmFpc2VkIGUpIGJ0XG4gIGluXG4gIG1hdGNoIHdvcmsgKCkgd2l0aFxuICB8IHJlc3VsdCAtPiBmaW5hbGx5X25vX2V4biAoKSA7IHJlc3VsdFxuICB8IGV4Y2VwdGlvbiB3b3JrX2V4biAtPlxuICAgICAgbGV0IHdvcmtfYnQgPSBQcmludGV4Yy5nZXRfcmF3X2JhY2t0cmFjZSAoKSBpblxuICAgICAgZmluYWxseV9ub19leG4gKCkgO1xuICAgICAgUHJpbnRleGMucmFpc2Vfd2l0aF9iYWNrdHJhY2Ugd29ya19leG4gd29ya19idFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICBEYW1pZW4gRG9saWdleiwgcHJvamV0IFBhcmEsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICBKYWNxdWVzLUhlbnJpIEpvdXJkYW4sIHByb2pldCBHYWxsaXVtLCBJTlJJQSBQYXJpcyAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5Ni0yMDE2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgICAqKVxuKCogICAgIGV0IGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlIHN0YXQgPSB7XG4gIG1pbm9yX3dvcmRzIDogZmxvYXQ7XG4gIHByb21vdGVkX3dvcmRzIDogZmxvYXQ7XG4gIG1ham9yX3dvcmRzIDogZmxvYXQ7XG4gIG1pbm9yX2NvbGxlY3Rpb25zIDogaW50O1xuICBtYWpvcl9jb2xsZWN0aW9ucyA6IGludDtcbiAgaGVhcF93b3JkcyA6IGludDtcbiAgaGVhcF9jaHVua3MgOiBpbnQ7XG4gIGxpdmVfd29yZHMgOiBpbnQ7XG4gIGxpdmVfYmxvY2tzIDogaW50O1xuICBmcmVlX3dvcmRzIDogaW50O1xuICBmcmVlX2Jsb2NrcyA6IGludDtcbiAgbGFyZ2VzdF9mcmVlIDogaW50O1xuICBmcmFnbWVudHMgOiBpbnQ7XG4gIGNvbXBhY3Rpb25zIDogaW50O1xuICB0b3BfaGVhcF93b3JkcyA6IGludDtcbiAgc3RhY2tfc2l6ZSA6IGludDtcbiAgZm9yY2VkX21ham9yX2NvbGxlY3Rpb25zOiBpbnQ7XG59XG5cbnR5cGUgY29udHJvbCA9IHtcbiAgbXV0YWJsZSBtaW5vcl9oZWFwX3NpemUgOiBpbnQ7XG4gIG11dGFibGUgbWFqb3JfaGVhcF9pbmNyZW1lbnQgOiBpbnQ7XG4gIG11dGFibGUgc3BhY2Vfb3ZlcmhlYWQgOiBpbnQ7XG4gIG11dGFibGUgdmVyYm9zZSA6IGludDtcbiAgbXV0YWJsZSBtYXhfb3ZlcmhlYWQgOiBpbnQ7XG4gIG11dGFibGUgc3RhY2tfbGltaXQgOiBpbnQ7XG4gIG11dGFibGUgYWxsb2NhdGlvbl9wb2xpY3kgOiBpbnQ7XG4gIHdpbmRvd19zaXplIDogaW50O1xuICBjdXN0b21fbWFqb3JfcmF0aW8gOiBpbnQ7XG4gIGN1c3RvbV9taW5vcl9yYXRpbyA6IGludDtcbiAgY3VzdG9tX21pbm9yX21heF9zaXplIDogaW50O1xufVxuXG5leHRlcm5hbCBzdGF0IDogdW5pdCAtPiBzdGF0ID0gXCJjYW1sX2djX3N0YXRcIlxuZXh0ZXJuYWwgcXVpY2tfc3RhdCA6IHVuaXQgLT4gc3RhdCA9IFwiY2FtbF9nY19xdWlja19zdGF0XCJcbmV4dGVybmFsIGNvdW50ZXJzIDogdW5pdCAtPiAoZmxvYXQgKiBmbG9hdCAqIGZsb2F0KSA9IFwiY2FtbF9nY19jb3VudGVyc1wiXG5leHRlcm5hbCBtaW5vcl93b3JkcyA6IHVuaXQgLT4gKGZsb2F0IFtAdW5ib3hlZF0pXG4gID0gXCJjYW1sX2djX21pbm9yX3dvcmRzXCIgXCJjYW1sX2djX21pbm9yX3dvcmRzX3VuYm94ZWRcIlxuZXh0ZXJuYWwgZ2V0IDogdW5pdCAtPiBjb250cm9sID0gXCJjYW1sX2djX2dldFwiXG5leHRlcm5hbCBzZXQgOiBjb250cm9sIC0+IHVuaXQgPSBcImNhbWxfZ2Nfc2V0XCJcbmV4dGVybmFsIG1pbm9yIDogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2djX21pbm9yXCJcbmV4dGVybmFsIG1ham9yX3NsaWNlIDogaW50IC0+IGludCA9IFwiY2FtbF9nY19tYWpvcl9zbGljZVwiXG5leHRlcm5hbCBtYWpvciA6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9nY19tYWpvclwiXG5leHRlcm5hbCBmdWxsX21ham9yIDogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2djX2Z1bGxfbWFqb3JcIlxuZXh0ZXJuYWwgY29tcGFjdCA6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9nY19jb21wYWN0aW9uXCJcbmV4dGVybmFsIGdldF9taW5vcl9mcmVlIDogdW5pdCAtPiBpbnQgPSBcImNhbWxfZ2V0X21pbm9yX2ZyZWVcIlxuZXh0ZXJuYWwgZ2V0X2J1Y2tldCA6IGludCAtPiBpbnQgPSBcImNhbWxfZ2V0X21ham9yX2J1Y2tldFwiIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBnZXRfY3JlZGl0IDogdW5pdCAtPiBpbnQgPSBcImNhbWxfZ2V0X21ham9yX2NyZWRpdFwiIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBodWdlX2ZhbGxiYWNrX2NvdW50IDogdW5pdCAtPiBpbnQgPSBcImNhbWxfZ2NfaHVnZV9mYWxsYmFja19jb3VudFwiXG5leHRlcm5hbCBldmVudGxvZ19wYXVzZSA6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9ldmVudGxvZ19wYXVzZVwiXG5leHRlcm5hbCBldmVudGxvZ19yZXN1bWUgOiB1bml0IC0+IHVuaXQgPSBcImNhbWxfZXZlbnRsb2dfcmVzdW1lXCJcblxub3BlbiBQcmludGZcblxubGV0IHByaW50X3N0YXQgYyA9XG4gIGxldCBzdCA9IHN0YXQgKCkgaW5cbiAgZnByaW50ZiBjIFwibWlub3JfY29sbGVjdGlvbnM6ICAgICAgJWRcXG5cIiBzdC5taW5vcl9jb2xsZWN0aW9ucztcbiAgZnByaW50ZiBjIFwibWFqb3JfY29sbGVjdGlvbnM6ICAgICAgJWRcXG5cIiBzdC5tYWpvcl9jb2xsZWN0aW9ucztcbiAgZnByaW50ZiBjIFwiY29tcGFjdGlvbnM6ICAgICAgICAgICAgJWRcXG5cIiBzdC5jb21wYWN0aW9ucztcbiAgZnByaW50ZiBjIFwiZm9yY2VkX21ham9yX2NvbGxlY3Rpb25zOiAlZFxcblwiIHN0LmZvcmNlZF9tYWpvcl9jb2xsZWN0aW9ucztcbiAgZnByaW50ZiBjIFwiXFxuXCI7XG4gIGxldCBsMSA9IFN0cmluZy5sZW5ndGggKHNwcmludGYgXCIlLjBmXCIgc3QubWlub3Jfd29yZHMpIGluXG4gIGZwcmludGYgYyBcIm1pbm9yX3dvcmRzOiAgICAlKi4wZlxcblwiIGwxIHN0Lm1pbm9yX3dvcmRzO1xuICBmcHJpbnRmIGMgXCJwcm9tb3RlZF93b3JkczogJSouMGZcXG5cIiBsMSBzdC5wcm9tb3RlZF93b3JkcztcbiAgZnByaW50ZiBjIFwibWFqb3Jfd29yZHM6ICAgICUqLjBmXFxuXCIgbDEgc3QubWFqb3Jfd29yZHM7XG4gIGZwcmludGYgYyBcIlxcblwiO1xuICBsZXQgbDIgPSBTdHJpbmcubGVuZ3RoIChzcHJpbnRmIFwiJWRcIiBzdC50b3BfaGVhcF93b3JkcykgaW5cbiAgZnByaW50ZiBjIFwidG9wX2hlYXBfd29yZHM6ICUqZFxcblwiIGwyIHN0LnRvcF9oZWFwX3dvcmRzO1xuICBmcHJpbnRmIGMgXCJoZWFwX3dvcmRzOiAgICAgJSpkXFxuXCIgbDIgc3QuaGVhcF93b3JkcztcbiAgZnByaW50ZiBjIFwibGl2ZV93b3JkczogICAgICUqZFxcblwiIGwyIHN0LmxpdmVfd29yZHM7XG4gIGZwcmludGYgYyBcImZyZWVfd29yZHM6ICAgICAlKmRcXG5cIiBsMiBzdC5mcmVlX3dvcmRzO1xuICBmcHJpbnRmIGMgXCJsYXJnZXN0X2ZyZWU6ICAgJSpkXFxuXCIgbDIgc3QubGFyZ2VzdF9mcmVlO1xuICBmcHJpbnRmIGMgXCJmcmFnbWVudHM6ICAgICAgJSpkXFxuXCIgbDIgc3QuZnJhZ21lbnRzO1xuICBmcHJpbnRmIGMgXCJcXG5cIjtcbiAgZnByaW50ZiBjIFwibGl2ZV9ibG9ja3M6ICVkXFxuXCIgc3QubGl2ZV9ibG9ja3M7XG4gIGZwcmludGYgYyBcImZyZWVfYmxvY2tzOiAlZFxcblwiIHN0LmZyZWVfYmxvY2tzO1xuICBmcHJpbnRmIGMgXCJoZWFwX2NodW5rczogJWRcXG5cIiBzdC5oZWFwX2NodW5rc1xuXG5cbmxldCBhbGxvY2F0ZWRfYnl0ZXMgKCkgPVxuICBsZXQgKG1pLCBwcm8sIG1hKSA9IGNvdW50ZXJzICgpIGluXG4gIChtaSArLiBtYSAtLiBwcm8pICouIGZsb2F0X29mX2ludCAoU3lzLndvcmRfc2l6ZSAvIDgpXG5cblxuZXh0ZXJuYWwgZmluYWxpc2UgOiAoJ2EgLT4gdW5pdCkgLT4gJ2EgLT4gdW5pdCA9IFwiY2FtbF9maW5hbF9yZWdpc3RlclwiXG5leHRlcm5hbCBmaW5hbGlzZV9sYXN0IDogKHVuaXQgLT4gdW5pdCkgLT4gJ2EgLT4gdW5pdCA9XG4gIFwiY2FtbF9maW5hbF9yZWdpc3Rlcl9jYWxsZWRfd2l0aG91dF92YWx1ZVwiXG5leHRlcm5hbCBmaW5hbGlzZV9yZWxlYXNlIDogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2ZpbmFsX3JlbGVhc2VcIlxuXG5cbnR5cGUgYWxhcm0gPSBib29sIHJlZlxudHlwZSBhbGFybV9yZWMgPSB7YWN0aXZlIDogYWxhcm07IGYgOiB1bml0IC0+IHVuaXR9XG5cbmxldCByZWMgY2FsbF9hbGFybSBhcmVjID1cbiAgaWYgIShhcmVjLmFjdGl2ZSkgdGhlbiBiZWdpblxuICAgIGZpbmFsaXNlIGNhbGxfYWxhcm0gYXJlYztcbiAgICBhcmVjLmYgKCk7XG4gIGVuZFxuXG5cbmxldCBjcmVhdGVfYWxhcm0gZiA9XG4gIGxldCBhcmVjID0geyBhY3RpdmUgPSByZWYgdHJ1ZTsgZiA9IGYgfSBpblxuICBmaW5hbGlzZSBjYWxsX2FsYXJtIGFyZWM7XG4gIGFyZWMuYWN0aXZlXG5cblxubGV0IGRlbGV0ZV9hbGFybSBhID0gYSA6PSBmYWxzZVxuXG5tb2R1bGUgTWVtcHJvZiA9XG4gIHN0cnVjdFxuICAgIHR5cGUgYWxsb2NhdGlvbl9zb3VyY2UgPSBOb3JtYWwgfCBNYXJzaGFsIHwgQ3VzdG9tXG4gICAgdHlwZSBhbGxvY2F0aW9uID1cbiAgICAgIHsgbl9zYW1wbGVzIDogaW50O1xuICAgICAgICBzaXplIDogaW50O1xuICAgICAgICBzb3VyY2UgOiBhbGxvY2F0aW9uX3NvdXJjZTtcbiAgICAgICAgY2FsbHN0YWNrIDogUHJpbnRleGMucmF3X2JhY2t0cmFjZSB9XG5cbiAgICB0eXBlICgnbWlub3IsICdtYWpvcikgdHJhY2tlciA9IHtcbiAgICAgIGFsbG9jX21pbm9yOiBhbGxvY2F0aW9uIC0+ICdtaW5vciBvcHRpb247XG4gICAgICBhbGxvY19tYWpvcjogYWxsb2NhdGlvbiAtPiAnbWFqb3Igb3B0aW9uO1xuICAgICAgcHJvbW90ZTogJ21pbm9yIC0+ICdtYWpvciBvcHRpb247XG4gICAgICBkZWFsbG9jX21pbm9yOiAnbWlub3IgLT4gdW5pdDtcbiAgICAgIGRlYWxsb2NfbWFqb3I6ICdtYWpvciAtPiB1bml0O1xuICAgIH1cblxuICAgIGxldCBudWxsX3RyYWNrZXIgPSB7XG4gICAgICBhbGxvY19taW5vciA9IChmdW4gXyAtPiBOb25lKTtcbiAgICAgIGFsbG9jX21ham9yID0gKGZ1biBfIC0+IE5vbmUpO1xuICAgICAgcHJvbW90ZSA9IChmdW4gXyAtPiBOb25lKTtcbiAgICAgIGRlYWxsb2NfbWlub3IgPSAoZnVuIF8gLT4gKCkpO1xuICAgICAgZGVhbGxvY19tYWpvciA9IChmdW4gXyAtPiAoKSk7XG4gICAgfVxuXG4gICAgZXh0ZXJuYWwgY19zdGFydCA6XG4gICAgICBmbG9hdCAtPiBpbnQgLT4gKCdtaW5vciwgJ21ham9yKSB0cmFja2VyIC0+IHVuaXRcbiAgICAgID0gXCJjYW1sX21lbXByb2Zfc3RhcnRcIlxuXG4gICAgbGV0IHN0YXJ0XG4gICAgICB+c2FtcGxpbmdfcmF0ZVxuICAgICAgPyhjYWxsc3RhY2tfc2l6ZSA9IG1heF9pbnQpXG4gICAgICB0cmFja2VyID1cbiAgICAgIGNfc3RhcnQgc2FtcGxpbmdfcmF0ZSBjYWxsc3RhY2tfc2l6ZSB0cmFja2VyXG5cbiAgICBleHRlcm5hbCBzdG9wIDogdW5pdCAtPiB1bml0ID0gXCJjYW1sX21lbXByb2Zfc3RvcFwiXG4gIGVuZFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBNZXNzYWdlIGRpZ2VzdCAoTUQ1KSAqKVxuXG50eXBlIHQgPSBzdHJpbmdcblxubGV0IGNvbXBhcmUgPSBTdHJpbmcuY29tcGFyZVxubGV0IGVxdWFsID0gU3RyaW5nLmVxdWFsXG5cbmV4dGVybmFsIHVuc2FmZV9zdHJpbmc6IHN0cmluZyAtPiBpbnQgLT4gaW50IC0+IHQgPSBcImNhbWxfbWQ1X3N0cmluZ1wiXG5leHRlcm5hbCBjaGFubmVsOiBpbl9jaGFubmVsIC0+IGludCAtPiB0ID0gXCJjYW1sX21kNV9jaGFuXCJcblxubGV0IHN0cmluZyBzdHIgPVxuICB1bnNhZmVfc3RyaW5nIHN0ciAwIChTdHJpbmcubGVuZ3RoIHN0cilcblxubGV0IGJ5dGVzIGIgPSBzdHJpbmcgKEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgYilcblxubGV0IHN1YnN0cmluZyBzdHIgb2ZzIGxlbiA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBTdHJpbmcubGVuZ3RoIHN0ciAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiRGlnZXN0LnN1YnN0cmluZ1wiXG4gIGVsc2UgdW5zYWZlX3N0cmluZyBzdHIgb2ZzIGxlblxuXG5sZXQgc3ViYnl0ZXMgYiBvZnMgbGVuID0gc3Vic3RyaW5nIChCeXRlcy51bnNhZmVfdG9fc3RyaW5nIGIpIG9mcyBsZW5cblxubGV0IGZpbGUgZmlsZW5hbWUgPVxuICBsZXQgaWMgPSBvcGVuX2luX2JpbiBmaWxlbmFtZSBpblxuICBtYXRjaCBjaGFubmVsIGljICgtMSkgd2l0aFxuICAgIHwgZCAtPiBjbG9zZV9pbiBpYzsgZFxuICAgIHwgZXhjZXB0aW9uIGUgLT4gY2xvc2VfaW4gaWM7IHJhaXNlIGVcblxubGV0IG91dHB1dCBjaGFuIGRpZ2VzdCA9XG4gIG91dHB1dF9zdHJpbmcgY2hhbiBkaWdlc3RcblxubGV0IGlucHV0IGNoYW4gPSByZWFsbHlfaW5wdXRfc3RyaW5nIGNoYW4gMTZcblxubGV0IGNoYXJfaGV4IG4gPVxuICBDaGFyLnVuc2FmZV9jaHIgKG4gKyBpZiBuIDwgMTAgdGhlbiBDaGFyLmNvZGUgJzAnIGVsc2UgKENoYXIuY29kZSAnYScgLSAxMCkpXG5cbmxldCB0b19oZXggZCA9XG4gIGlmIFN0cmluZy5sZW5ndGggZCA8PiAxNiB0aGVuIGludmFsaWRfYXJnIFwiRGlnZXN0LnRvX2hleFwiO1xuICBsZXQgcmVzdWx0ID0gQnl0ZXMuY3JlYXRlIDMyIGluXG4gIGZvciBpID0gMCB0byAxNSBkb1xuICAgIGxldCB4ID0gQ2hhci5jb2RlIGQuW2ldIGluXG4gICAgQnl0ZXMudW5zYWZlX3NldCByZXN1bHQgKGkqMikgKGNoYXJfaGV4ICh4IGxzciA0KSk7XG4gICAgQnl0ZXMudW5zYWZlX3NldCByZXN1bHQgKGkqMisxKSAoY2hhcl9oZXggKHggbGFuZCAweDBmKSk7XG4gIGRvbmU7XG4gIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcmVzdWx0XG5cbmxldCBmcm9tX2hleCBzID1cbiAgaWYgU3RyaW5nLmxlbmd0aCBzIDw+IDMyIHRoZW4gaW52YWxpZF9hcmcgXCJEaWdlc3QuZnJvbV9oZXhcIjtcbiAgbGV0IGRpZ2l0IGMgPVxuICAgIG1hdGNoIGMgd2l0aFxuICAgIHwgJzAnLi4nOScgLT4gQ2hhci5jb2RlIGMgLSBDaGFyLmNvZGUgJzAnXG4gICAgfCAnQScuLidGJyAtPiBDaGFyLmNvZGUgYyAtIENoYXIuY29kZSAnQScgKyAxMFxuICAgIHwgJ2EnLi4nZicgLT4gQ2hhci5jb2RlIGMgLSBDaGFyLmNvZGUgJ2EnICsgMTBcbiAgICB8IF8gLT4gcmFpc2UgKEludmFsaWRfYXJndW1lbnQgXCJEaWdlc3QuZnJvbV9oZXhcIilcbiAgaW5cbiAgbGV0IGJ5dGUgaSA9IGRpZ2l0IHMuW2ldIGxzbCA0ICsgZGlnaXQgcy5baSsxXSBpblxuICBsZXQgcmVzdWx0ID0gQnl0ZXMuY3JlYXRlIDE2IGluXG4gIGZvciBpID0gMCB0byAxNSBkb1xuICAgIEJ5dGVzLnNldCByZXN1bHQgaSAoQ2hhci5jaHIgKGJ5dGUgKDIgKiBpKSkpO1xuICBkb25lO1xuICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHJlc3VsdFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICBEYW1pZW4gRG9saWdleiwgcHJvamV0IFBhcmEsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBQc2V1ZG8tcmFuZG9tIG51bWJlciBnZW5lcmF0b3JcbiAgIFRoaXMgaXMgYSBsYWdnZWQtRmlib25hY2NpIEYoNTUsIDI0LCArKSB3aXRoIGEgbW9kaWZpZWQgYWRkaXRpb25cbiAgIGZ1bmN0aW9uIHRvIGVuaGFuY2UgdGhlIG1peGluZyBvZiBiaXRzLlxuICAgSWYgd2UgdXNlIG5vcm1hbCBhZGRpdGlvbiwgdGhlIGxvdy1vcmRlciBiaXQgZmFpbHMgdGVzdHMgMSBhbmQgN1xuICAgb2YgdGhlIERpZWhhcmQgdGVzdCBzdWl0ZSwgYW5kIGJpdHMgMSBhbmQgMiBhbHNvIGZhaWwgdGVzdCA3LlxuICAgSWYgd2UgdXNlIG11bHRpcGxpY2F0aW9uIGFzIHN1Z2dlc3RlZCBieSBNYXJzYWdsaWEsIGl0IGRvZXNuJ3QgZmFyZVxuICAgbXVjaCBiZXR0ZXIuXG4gICBCeSBtaXhpbmcgdGhlIGJpdHMgb2Ygb25lIG9mIHRoZSBudW1iZXJzIGJlZm9yZSBhZGRpdGlvbiAoWE9SIHRoZVxuICAgNSBoaWdoLW9yZGVyIGJpdHMgaW50byB0aGUgbG93LW9yZGVyIGJpdHMpLCB3ZSBnZXQgYSBnZW5lcmF0b3IgdGhhdFxuICAgcGFzc2VzIGFsbCB0aGUgRGllaGFyZCB0ZXN0cy5cbiopXG5cbmV4dGVybmFsIHJhbmRvbV9zZWVkOiB1bml0IC0+IGludCBhcnJheSA9IFwiY2FtbF9zeXNfcmFuZG9tX3NlZWRcIlxuXG5tb2R1bGUgU3RhdGUgPSBzdHJ1Y3RcblxuICB0eXBlIHQgPSB7IHN0IDogaW50IGFycmF5OyBtdXRhYmxlIGlkeCA6IGludCB9XG5cbiAgbGV0IG5ld19zdGF0ZSAoKSA9IHsgc3QgPSBBcnJheS5tYWtlIDU1IDA7IGlkeCA9IDAgfVxuICBsZXQgYXNzaWduIHN0MSBzdDIgPVxuICAgIEFycmF5LmJsaXQgc3QyLnN0IDAgc3QxLnN0IDAgNTU7XG4gICAgc3QxLmlkeCA8LSBzdDIuaWR4XG5cblxuICBsZXQgZnVsbF9pbml0IHMgc2VlZCA9XG4gICAgbGV0IGNvbWJpbmUgYWNjdSB4ID0gRGlnZXN0LnN0cmluZyAoYWNjdSBeIEludC50b19zdHJpbmcgeCkgaW5cbiAgICBsZXQgZXh0cmFjdCBkID1cbiAgICAgIENoYXIuY29kZSBkLlswXSArIChDaGFyLmNvZGUgZC5bMV0gbHNsIDgpICsgKENoYXIuY29kZSBkLlsyXSBsc2wgMTYpXG4gICAgICArIChDaGFyLmNvZGUgZC5bM10gbHNsIDI0KVxuICAgIGluXG4gICAgbGV0IHNlZWQgPSBpZiBBcnJheS5sZW5ndGggc2VlZCA9IDAgdGhlbiBbfCAwIHxdIGVsc2Ugc2VlZCBpblxuICAgIGxldCBsID0gQXJyYXkubGVuZ3RoIHNlZWQgaW5cbiAgICBmb3IgaSA9IDAgdG8gNTQgZG9cbiAgICAgIHMuc3QuKGkpIDwtIGk7XG4gICAgZG9uZTtcbiAgICBsZXQgYWNjdSA9IHJlZiBcInhcIiBpblxuICAgIGZvciBpID0gMCB0byA1NCArIG1heCA1NSBsIGRvXG4gICAgICBsZXQgaiA9IGkgbW9kIDU1IGluXG4gICAgICBsZXQgayA9IGkgbW9kIGwgaW5cbiAgICAgIGFjY3UgOj0gY29tYmluZSAhYWNjdSBzZWVkLihrKTtcbiAgICAgIHMuc3QuKGopIDwtIChzLnN0LihqKSBseG9yIGV4dHJhY3QgIWFjY3UpIGxhbmQgMHgzRkZGRkZGRjsgICgqIFBSIzU1NzUgKilcbiAgICBkb25lO1xuICAgIHMuaWR4IDwtIDBcblxuXG4gIGxldCBtYWtlIHNlZWQgPVxuICAgIGxldCByZXN1bHQgPSBuZXdfc3RhdGUgKCkgaW5cbiAgICBmdWxsX2luaXQgcmVzdWx0IHNlZWQ7XG4gICAgcmVzdWx0XG5cblxuICBsZXQgbWFrZV9zZWxmX2luaXQgKCkgPSBtYWtlIChyYW5kb21fc2VlZCAoKSlcblxuICBsZXQgY29weSBzID1cbiAgICBsZXQgcmVzdWx0ID0gbmV3X3N0YXRlICgpIGluXG4gICAgYXNzaWduIHJlc3VsdCBzO1xuICAgIHJlc3VsdFxuXG5cbiAgKCogUmV0dXJucyAzMCByYW5kb20gYml0cyBhcyBhbiBpbnRlZ2VyIDAgPD0geCA8IDEwNzM3NDE4MjQgKilcbiAgbGV0IGJpdHMgcyA9XG4gICAgcy5pZHggPC0gKHMuaWR4ICsgMSkgbW9kIDU1O1xuICAgIGxldCBjdXJ2YWwgPSBzLnN0LihzLmlkeCkgaW5cbiAgICBsZXQgbmV3dmFsID0gcy5zdC4oKHMuaWR4ICsgMjQpIG1vZCA1NSlcbiAgICAgICAgICAgICAgICAgKyAoY3VydmFsIGx4b3IgKChjdXJ2YWwgbHNyIDI1KSBsYW5kIDB4MUYpKSBpblxuICAgIGxldCBuZXd2YWwzMCA9IG5ld3ZhbCBsYW5kIDB4M0ZGRkZGRkYgaW4gICgqIFBSIzU1NzUgKilcbiAgICBzLnN0LihzLmlkeCkgPC0gbmV3dmFsMzA7XG4gICAgbmV3dmFsMzBcblxuXG4gIGxldCByZWMgaW50YXV4IHMgbiA9XG4gICAgbGV0IHIgPSBiaXRzIHMgaW5cbiAgICBsZXQgdiA9IHIgbW9kIG4gaW5cbiAgICBpZiByIC0gdiA+IDB4M0ZGRkZGRkYgLSBuICsgMSB0aGVuIGludGF1eCBzIG4gZWxzZSB2XG5cbiAgbGV0IGludCBzIGJvdW5kID1cbiAgICBpZiBib3VuZCA+IDB4M0ZGRkZGRkYgfHwgYm91bmQgPD0gMFxuICAgIHRoZW4gaW52YWxpZF9hcmcgXCJSYW5kb20uaW50XCJcbiAgICBlbHNlIGludGF1eCBzIGJvdW5kXG5cblxuICBsZXQgcmVjIGludDMyYXV4IHMgbiA9XG4gICAgbGV0IGIxID0gSW50MzIub2ZfaW50IChiaXRzIHMpIGluXG4gICAgbGV0IGIyID0gSW50MzIuc2hpZnRfbGVmdCAoSW50MzIub2ZfaW50IChiaXRzIHMgbGFuZCAxKSkgMzAgaW5cbiAgICBsZXQgciA9IEludDMyLmxvZ29yIGIxIGIyIGluXG4gICAgbGV0IHYgPSBJbnQzMi5yZW0gciBuIGluXG4gICAgaWYgSW50MzIuc3ViIHIgdiA+IEludDMyLmFkZCAoSW50MzIuc3ViIEludDMyLm1heF9pbnQgbikgMWxcbiAgICB0aGVuIGludDMyYXV4IHMgblxuICAgIGVsc2UgdlxuXG4gIGxldCBpbnQzMiBzIGJvdW5kID1cbiAgICBpZiBib3VuZCA8PSAwbFxuICAgIHRoZW4gaW52YWxpZF9hcmcgXCJSYW5kb20uaW50MzJcIlxuICAgIGVsc2UgaW50MzJhdXggcyBib3VuZFxuXG5cbiAgbGV0IHJlYyBpbnQ2NGF1eCBzIG4gPVxuICAgIGxldCBiMSA9IEludDY0Lm9mX2ludCAoYml0cyBzKSBpblxuICAgIGxldCBiMiA9IEludDY0LnNoaWZ0X2xlZnQgKEludDY0Lm9mX2ludCAoYml0cyBzKSkgMzAgaW5cbiAgICBsZXQgYjMgPSBJbnQ2NC5zaGlmdF9sZWZ0IChJbnQ2NC5vZl9pbnQgKGJpdHMgcyBsYW5kIDcpKSA2MCBpblxuICAgIGxldCByID0gSW50NjQubG9nb3IgYjEgKEludDY0LmxvZ29yIGIyIGIzKSBpblxuICAgIGxldCB2ID0gSW50NjQucmVtIHIgbiBpblxuICAgIGlmIEludDY0LnN1YiByIHYgPiBJbnQ2NC5hZGQgKEludDY0LnN1YiBJbnQ2NC5tYXhfaW50IG4pIDFMXG4gICAgdGhlbiBpbnQ2NGF1eCBzIG5cbiAgICBlbHNlIHZcblxuICBsZXQgaW50NjQgcyBib3VuZCA9XG4gICAgaWYgYm91bmQgPD0gMExcbiAgICB0aGVuIGludmFsaWRfYXJnIFwiUmFuZG9tLmludDY0XCJcbiAgICBlbHNlIGludDY0YXV4IHMgYm91bmRcblxuXG4gIGxldCBuYXRpdmVpbnQgPVxuICAgIGlmIE5hdGl2ZWludC5zaXplID0gMzJcbiAgICB0aGVuIGZ1biBzIGJvdW5kIC0+IE5hdGl2ZWludC5vZl9pbnQzMiAoaW50MzIgcyAoTmF0aXZlaW50LnRvX2ludDMyIGJvdW5kKSlcbiAgICBlbHNlIGZ1biBzIGJvdW5kIC0+IEludDY0LnRvX25hdGl2ZWludCAoaW50NjQgcyAoSW50NjQub2ZfbmF0aXZlaW50IGJvdW5kKSlcblxuXG4gICgqIFJldHVybnMgYSBmbG9hdCAwIDw9IHggPD0gMSB3aXRoIGF0IG1vc3QgNjAgYml0cyBvZiBwcmVjaXNpb24uICopXG4gIGxldCByYXdmbG9hdCBzID1cbiAgICBsZXQgc2NhbGUgPSAxMDczNzQxODI0LjAgICgqIDJeMzAgKilcbiAgICBhbmQgcjEgPSBTdGRsaWIuZmxvYXQgKGJpdHMgcylcbiAgICBhbmQgcjIgPSBTdGRsaWIuZmxvYXQgKGJpdHMgcylcbiAgICBpbiAocjEgLy4gc2NhbGUgKy4gcjIpIC8uIHNjYWxlXG5cblxuICBsZXQgZmxvYXQgcyBib3VuZCA9IHJhd2Zsb2F0IHMgKi4gYm91bmRcblxuICBsZXQgYm9vbCBzID0gKGJpdHMgcyBsYW5kIDEgPSAwKVxuXG5lbmRcblxuKCogVGhpcyBpcyB0aGUgc3RhdGUgeW91IGdldCB3aXRoIFtpbml0IDI3MTgyODE4XSBhbmQgdGhlbiBhcHBseWluZ1xuICAgdGhlIFwibGFuZCAweDNGRkZGRkZGXCIgZmlsdGVyIHRvIHRoZW0uICBTZWUgIzU1NzUsICM1NzkzLCAjNTk3Ny4gKilcbmxldCBkZWZhdWx0ID0ge1xuICBTdGF0ZS5zdCA9IFt8XG4gICAgICAweDNhZTI1MjJiOyAweDFkOGQ0NjM0OyAweDE1YjRmYWQwOyAweDE4YjE0YWNlOyAweDEyZjhhM2M0OyAweDNiMDg2YzQ3O1xuICAgICAgMHgxNmQ0NjdkNjsgMHgxMDFkOTFjNzsgMHgzMjFkZjE3NzsgMHgwMTc2YzE5MzsgMHgxZmY3MmJmMTsgMHgxZTg4OTEwOTtcbiAgICAgIDB4MGI0NjRiMTg7IDB4MmI4NmI5N2M7IDB4MDg5MWRhNDg7IDB4MDMxMzc0NjM7IDB4MDg1YWM1YTE7IDB4MTVkNjFmMmY7XG4gICAgICAweDNiY2VkMzU5OyAweDI5YzFjMTMyOyAweDNhODY3NjZlOyAweDM2NmQ4Yzg2OyAweDFmNWI2MjIyOyAweDNjZTFiNTlmO1xuICAgICAgMHgyZWJmNzhlMTsgMHgyN2NkMWI4NjsgMHgyNThmM2RjMzsgMHgzODlhODE5NDsgMHgwMmU0YzQ0YzsgMHgxOGM0M2Y3ZDtcbiAgICAgIDB4MGY2ZTUzNGY7IDB4MWU3ZGYzNTk7IDB4MDU1ZDBiN2U7IDB4MTBlODRlN2U7IDB4MTI2MTk4ZTQ7IDB4MGU3NzIyY2I7XG4gICAgICAweDFjYmVkZTI4OyAweDMzOTFiOTY0OyAweDNkNDBlOTJhOyAweDBjNTk5MzNkOyAweDBiOGNkMGI3OyAweDI0ZWZmZjFjO1xuICAgICAgMHgyODAzZmRhYTsgMHgwOGViYzcyZTsgMHgwZjUyMmUzMjsgMHgwNTM5OGVkYzsgMHgyMTQ0YTA0YzsgMHgwYWVmM2NiZDtcbiAgICAgIDB4MDFhZDQ3MTk7IDB4MzViOTNjZDY7IDB4MmE1NTlkNGY7IDB4MWU2ZmQ3Njg7IDB4MjZlMjdmMzY7IDB4MTg2ZjE4YzM7XG4gICAgICAweDJmYmY5NjdhO1xuICAgIHxdO1xuICBTdGF0ZS5pZHggPSAwO1xufVxuXG5sZXQgYml0cyAoKSA9IFN0YXRlLmJpdHMgZGVmYXVsdFxubGV0IGludCBib3VuZCA9IFN0YXRlLmludCBkZWZhdWx0IGJvdW5kXG5sZXQgaW50MzIgYm91bmQgPSBTdGF0ZS5pbnQzMiBkZWZhdWx0IGJvdW5kXG5sZXQgbmF0aXZlaW50IGJvdW5kID0gU3RhdGUubmF0aXZlaW50IGRlZmF1bHQgYm91bmRcbmxldCBpbnQ2NCBib3VuZCA9IFN0YXRlLmludDY0IGRlZmF1bHQgYm91bmRcbmxldCBmbG9hdCBzY2FsZSA9IFN0YXRlLmZsb2F0IGRlZmF1bHQgc2NhbGVcbmxldCBib29sICgpID0gU3RhdGUuYm9vbCBkZWZhdWx0XG5cbmxldCBmdWxsX2luaXQgc2VlZCA9IFN0YXRlLmZ1bGxfaW5pdCBkZWZhdWx0IHNlZWRcbmxldCBpbml0IHNlZWQgPSBTdGF0ZS5mdWxsX2luaXQgZGVmYXVsdCBbfCBzZWVkIHxdXG5sZXQgc2VsZl9pbml0ICgpID0gZnVsbF9pbml0IChyYW5kb21fc2VlZCgpKVxuXG4oKiBNYW5pcHVsYXRpbmcgdGhlIGN1cnJlbnQgc3RhdGUuICopXG5cbmxldCBnZXRfc3RhdGUgKCkgPSBTdGF0ZS5jb3B5IGRlZmF1bHRcbmxldCBzZXRfc3RhdGUgcyA9IFN0YXRlLmFzc2lnbiBkZWZhdWx0IHNcblxuKCoqKioqKioqKioqKioqKioqKioqXG5cbigqIFRlc3QgZnVuY3Rpb25zLiAgTm90IGluY2x1ZGVkIGluIHRoZSBsaWJyYXJ5LlxuICAgVGhlIFtjaGlzcXVhcmVdIGZ1bmN0aW9uIHNob3VsZCBiZSBjYWxsZWQgd2l0aCBuID4gMTByLlxuICAgSXQgcmV0dXJucyBhIHRyaXBsZSAobG93LCBhY3R1YWwsIGhpZ2gpLlxuICAgSWYgbG93IDw9IGFjdHVhbCA8PSBoaWdoLCB0aGUgW2ddIGZ1bmN0aW9uIHBhc3NlZCB0aGUgdGVzdCxcbiAgIG90aGVyd2lzZSBpdCBmYWlsZWQuXG5cbiAgU29tZSByZXN1bHRzOlxuXG5pbml0IDI3MTgyODE4OyBjaGlzcXVhcmUgaW50IDEwMDAwMCAxMDAwXG5pbml0IDI3MTgyODE4OyBjaGlzcXVhcmUgaW50IDEwMDAwMCAxMDBcbmluaXQgMjcxODI4MTg7IGNoaXNxdWFyZSBpbnQgMTAwMDAwIDUwMDBcbmluaXQgMjcxODI4MTg7IGNoaXNxdWFyZSBpbnQgMTAwMDAwMCAxMDAwXG5pbml0IDI3MTgyODE4OyBjaGlzcXVhcmUgaW50IDEwMDAwMCAxMDI0XG5pbml0IDI5OTc5MjY0MzsgY2hpc3F1YXJlIGludCAxMDAwMDAgMTAyNFxuaW5pdCAxNDE0MjEzNjsgY2hpc3F1YXJlIGludCAxMDAwMDAgMTAyNFxuaW5pdCAyNzE4MjgxODsgaW5pdF9kaWZmIDEwMjQ7IGNoaXNxdWFyZSBkaWZmIDEwMDAwMCAxMDI0XG5pbml0IDI3MTgyODE4OyBpbml0X2RpZmYgMTAwOyBjaGlzcXVhcmUgZGlmZiAxMDAwMDAgMTAwXG5pbml0IDI3MTgyODE4OyBpbml0X2RpZmYyIDEwMjQ7IGNoaXNxdWFyZSBkaWZmMiAxMDAwMDAgMTAyNFxuaW5pdCAyNzE4MjgxODsgaW5pdF9kaWZmMiAxMDA7IGNoaXNxdWFyZSBkaWZmMiAxMDAwMDAgMTAwXG5pbml0IDE0MTQyMTM2OyBpbml0X2RpZmYyIDEwMDsgY2hpc3F1YXJlIGRpZmYyIDEwMDAwMCAxMDBcbmluaXQgMjk5NzkyNjQzOyBpbml0X2RpZmYyIDEwMDsgY2hpc3F1YXJlIGRpZmYyIDEwMDAwMCAxMDBcbi0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPSAoOTM2Ljc1NDQ0Njc5NjYzMjQ2NSwgOTk3LjUsIDEwNjMuMjQ1NTUzMjAzMzY3NTQpXG4jIC0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPSAoODAuLCA4OS43NDAwMDAwMDAwMDUyMzg3LCAxMjAuKVxuIyAtIDogZmxvYXQgKiBmbG9hdCAqIGZsb2F0ID0gKDQ4NTguNTc4NjQzNzYyNjksIDUwNDUuNSwgNTE0MS40MjEzNTYyMzczMSlcbiMgLSA6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCA9XG4oOTM2Ljc1NDQ0Njc5NjYzMjQ2NSwgOTQ0LjgwNTk5OTk5OTk4MjMwNSwgMTA2My4yNDU1NTMyMDMzNjc1NClcbiMgLSA6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCA9ICg5NjAuLCAxMDE5LjE5NzQ0MDAwMDAwMzU1LCAxMDg4LilcbiMgLSA6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCA9ICg5NjAuLCAxMDU5LjMxNzc2MDAwMDAwNTM2LCAxMDg4LilcbiMgLSA6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCA9ICg5NjAuLCAxMDM5Ljk4NDYzOTk5OTk5NTEyLCAxMDg4LilcbiMgLSA6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCA9ICg5NjAuLCAxMDU0LjM4MjA3OTk5OTk5NTc3LCAxMDg4LilcbiMgLSA6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCA9ICg4MC4sIDkwLjA5NjAwMDAwMDAwNSwgMTIwLilcbiMgLSA6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCA9ICg5NjAuLCAxMDc2Ljc4NzIwMDAwMDAwNjEyLCAxMDg4LilcbiMgLSA6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCA9ICg4MC4sIDg1LjE3NjAwMDAwMDAwNjc1MjEsIDEyMC4pXG4jIC0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPSAoODAuLCA4NS4yMTYwMDAwMDAwMDAzNDkyLCAxMjAuKVxuIyAtIDogZmxvYXQgKiBmbG9hdCAqIGZsb2F0ID0gKDgwLiwgODAuNjIyMDAwMDAwMDAzMDI2OCwgMTIwLilcblxuKilcblxuKCogUmV0dXJuIHRoZSBzdW0gb2YgdGhlIHNxdWFyZXMgb2YgdltpMCxpMVsgKilcbmxldCByZWMgc3Vtc3EgdiBpMCBpMSA9XG4gIGlmIGkwID49IGkxIHRoZW4gMC4wXG4gIGVsc2UgaWYgaTEgPSBpMCArIDEgdGhlbiBTdGRsaWIuZmxvYXQgdi4oaTApICouIFN0ZGxpYi5mbG9hdCB2LihpMClcbiAgZWxzZSBzdW1zcSB2IGkwICgoaTAraTEpLzIpICsuIHN1bXNxIHYgKChpMCtpMSkvMikgaTFcblxuXG5sZXQgY2hpc3F1YXJlIGcgbiByID1cbiAgaWYgbiA8PSAxMCAqIHIgdGhlbiBpbnZhbGlkX2FyZyBcImNoaXNxdWFyZVwiO1xuICBsZXQgZiA9IEFycmF5Lm1ha2UgciAwIGluXG4gIGZvciBpID0gMSB0byBuIGRvXG4gICAgbGV0IHQgPSBnIHIgaW5cbiAgICBmLih0KSA8LSBmLih0KSArIDFcbiAgZG9uZTtcbiAgbGV0IHQgPSBzdW1zcSBmIDAgclxuICBhbmQgciA9IFN0ZGxpYi5mbG9hdCByXG4gIGFuZCBuID0gU3RkbGliLmZsb2F0IG4gaW5cbiAgbGV0IHNyID0gMi4wICouIHNxcnQgciBpblxuICAociAtLiBzciwgICAociAqLiB0IC8uIG4pIC0uIG4sICAgciArLiBzcilcblxuXG4oKiBUaGlzIGlzIHRvIHRlc3QgZm9yIGxpbmVhciBkZXBlbmRlbmNpZXMgYmV0d2VlbiBzdWNjZXNzaXZlIHJhbmRvbSBudW1iZXJzLlxuKilcbmxldCBzdCA9IHJlZiAwXG5sZXQgaW5pdF9kaWZmIHIgPSBzdCA6PSBpbnQgclxubGV0IGRpZmYgciA9XG4gIGxldCB4MSA9ICFzdFxuICBhbmQgeDIgPSBpbnQgclxuICBpblxuICBzdCA6PSB4MjtcbiAgaWYgeDEgPj0geDIgdGhlblxuICAgIHgxIC0geDJcbiAgZWxzZVxuICAgIHIgKyB4MSAtIHgyXG5cblxubGV0IHN0MSA9IHJlZiAwXG5hbmQgc3QyID0gcmVmIDBcblxuXG4oKiBUaGlzIGlzIHRvIHRlc3QgZm9yIHF1YWRyYXRpYyBkZXBlbmRlbmNpZXMgYmV0d2VlbiBzdWNjZXNzaXZlIHJhbmRvbVxuICAgbnVtYmVycy5cbiopXG5sZXQgaW5pdF9kaWZmMiByID0gc3QxIDo9IGludCByOyBzdDIgOj0gaW50IHJcbmxldCBkaWZmMiByID1cbiAgbGV0IHgxID0gIXN0MVxuICBhbmQgeDIgPSAhc3QyXG4gIGFuZCB4MyA9IGludCByXG4gIGluXG4gIHN0MSA6PSB4MjtcbiAgc3QyIDo9IHgzO1xuICAoeDMgLSB4MiAtIHgyICsgeDEgKyAyKnIpIG1vZCByXG5cblxuKioqKioqKioqKioqKioqKioqKiopXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIEhhc2ggdGFibGVzICopXG5cbigqIFdlIGRvIGR5bmFtaWMgaGFzaGluZywgYW5kIHJlc2l6ZSB0aGUgdGFibGUgYW5kIHJlaGFzaCB0aGUgZWxlbWVudHNcbiAgIHdoZW4gYnVja2V0cyBiZWNvbWUgdG9vIGxvbmcuICopXG5cbnR5cGUgKCdhLCAnYikgdCA9XG4gIHsgbXV0YWJsZSBzaXplOiBpbnQ7ICAgICAgICAgICAgICAgICAgICAgICAgKCogbnVtYmVyIG9mIGVudHJpZXMgKilcbiAgICBtdXRhYmxlIGRhdGE6ICgnYSwgJ2IpIGJ1Y2tldGxpc3QgYXJyYXk7ICAoKiB0aGUgYnVja2V0cyAqKVxuICAgIG11dGFibGUgc2VlZDogaW50OyAgICAgICAgICAgICAgICAgICAgICAgICgqIGZvciByYW5kb21pemF0aW9uICopXG4gICAgbXV0YWJsZSBpbml0aWFsX3NpemU6IGludDsgICAgICAgICAgICAgICAgKCogaW5pdGlhbCBhcnJheSBzaXplICopXG4gIH1cblxuYW5kICgnYSwgJ2IpIGJ1Y2tldGxpc3QgPVxuICAgIEVtcHR5XG4gIHwgQ29ucyBvZiB7IG11dGFibGUga2V5OiAnYTtcbiAgICAgICAgICAgICAgbXV0YWJsZSBkYXRhOiAnYjtcbiAgICAgICAgICAgICAgbXV0YWJsZSBuZXh0OiAoJ2EsICdiKSBidWNrZXRsaXN0IH1cblxuKCogVGhlIHNpZ24gb2YgaW5pdGlhbF9zaXplIGVuY29kZXMgdGhlIGZhY3QgdGhhdCBhIHRyYXZlcnNhbCBpc1xuICAgb25nb2luZyBvciBub3QuXG5cbiAgIFRoaXMgZGlzYWJsZXMgdGhlIGVmZmljaWVudCBpbiBwbGFjZSBpbXBsZW1lbnRhdGlvbiBvZiByZXNpemluZy5cbiopXG5cbmxldCBvbmdvaW5nX3RyYXZlcnNhbCBoID1cbiAgT2JqLnNpemUgKE9iai5yZXByIGgpIDwgNCAoKiBjb21wYXRpYmlsaXR5IHdpdGggb2xkIGhhc2ggdGFibGVzICopXG4gIHx8IGguaW5pdGlhbF9zaXplIDwgMFxuXG5sZXQgZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoID1cbiAgaC5pbml0aWFsX3NpemUgPC0gLSBoLmluaXRpYWxfc2l6ZVxuXG4oKiBUbyBwaWNrIHJhbmRvbSBzZWVkcyBpZiByZXF1ZXN0ZWQgKilcblxubGV0IHJhbmRvbWl6ZWRfZGVmYXVsdCA9XG4gIGxldCBwYXJhbXMgPVxuICAgIHRyeSBTeXMuZ2V0ZW52IFwiT0NBTUxSVU5QQVJBTVwiIHdpdGggTm90X2ZvdW5kIC0+XG4gICAgdHJ5IFN5cy5nZXRlbnYgXCJDQU1MUlVOUEFSQU1cIiB3aXRoIE5vdF9mb3VuZCAtPiBcIlwiIGluXG4gIFN0cmluZy5jb250YWlucyBwYXJhbXMgJ1InXG5cbmxldCByYW5kb21pemVkID0gcmVmIHJhbmRvbWl6ZWRfZGVmYXVsdFxuXG5sZXQgcmFuZG9taXplICgpID0gcmFuZG9taXplZCA6PSB0cnVlXG5sZXQgaXNfcmFuZG9taXplZCAoKSA9ICFyYW5kb21pemVkXG5cbmxldCBwcm5nID0gbGF6eSAoUmFuZG9tLlN0YXRlLm1ha2Vfc2VsZl9pbml0KCkpXG5cbigqIEZ1bmN0aW9ucyB3aGljaCBhcHBlYXIgYmVmb3JlIHRoZSBmdW5jdG9yaWFsIGludGVyZmFjZSBtdXN0IGVpdGhlciBiZVxuICAgaW5kZXBlbmRlbnQgb2YgdGhlIGhhc2ggZnVuY3Rpb24gb3IgdGFrZSBpdCBhcyBhIHBhcmFtZXRlciAoc2VlICMyMjAyIGFuZFxuICAgY29kZSBiZWxvdyB0aGUgZnVuY3RvciBkZWZpbml0aW9ucy4gKilcblxuKCogQ3JlYXRpbmcgYSBmcmVzaCwgZW1wdHkgdGFibGUgKilcblxubGV0IHJlYyBwb3dlcl8yX2Fib3ZlIHggbiA9XG4gIGlmIHggPj0gbiB0aGVuIHhcbiAgZWxzZSBpZiB4ICogMiA+IFN5cy5tYXhfYXJyYXlfbGVuZ3RoIHRoZW4geFxuICBlbHNlIHBvd2VyXzJfYWJvdmUgKHggKiAyKSBuXG5cbmxldCBjcmVhdGUgPyhyYW5kb20gPSAhcmFuZG9taXplZCkgaW5pdGlhbF9zaXplID1cbiAgbGV0IHMgPSBwb3dlcl8yX2Fib3ZlIDE2IGluaXRpYWxfc2l6ZSBpblxuICBsZXQgc2VlZCA9IGlmIHJhbmRvbSB0aGVuIFJhbmRvbS5TdGF0ZS5iaXRzIChMYXp5LmZvcmNlIHBybmcpIGVsc2UgMCBpblxuICB7IGluaXRpYWxfc2l6ZSA9IHM7IHNpemUgPSAwOyBzZWVkID0gc2VlZDsgZGF0YSA9IEFycmF5Lm1ha2UgcyBFbXB0eSB9XG5cbmxldCBjbGVhciBoID1cbiAgaWYgaC5zaXplID4gMCB0aGVuIGJlZ2luXG4gICAgaC5zaXplIDwtIDA7XG4gICAgQXJyYXkuZmlsbCBoLmRhdGEgMCAoQXJyYXkubGVuZ3RoIGguZGF0YSkgRW1wdHlcbiAgZW5kXG5cbmxldCByZXNldCBoID1cbiAgbGV0IGxlbiA9IEFycmF5Lmxlbmd0aCBoLmRhdGEgaW5cbiAgaWYgT2JqLnNpemUgKE9iai5yZXByIGgpIDwgNCAoKiBjb21wYXRpYmlsaXR5IHdpdGggb2xkIGhhc2ggdGFibGVzICopXG4gICAgfHwgbGVuID0gYWJzIGguaW5pdGlhbF9zaXplIHRoZW5cbiAgICBjbGVhciBoXG4gIGVsc2UgYmVnaW5cbiAgICBoLnNpemUgPC0gMDtcbiAgICBoLmRhdGEgPC0gQXJyYXkubWFrZSAoYWJzIGguaW5pdGlhbF9zaXplKSBFbXB0eVxuICBlbmRcblxubGV0IGNvcHlfYnVja2V0bGlzdCA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT4gRW1wdHlcbiAgfCBDb25zIHtrZXk7IGRhdGE7IG5leHR9IC0+XG4gICAgICBsZXQgcmVjIGxvb3AgcHJlYyA9IGZ1bmN0aW9uXG4gICAgICAgIHwgRW1wdHkgLT4gKClcbiAgICAgICAgfCBDb25zIHtrZXk7IGRhdGE7IG5leHR9IC0+XG4gICAgICAgICAgICBsZXQgciA9IENvbnMge2tleTsgZGF0YTsgbmV4dH0gaW5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIHByZWMgd2l0aFxuICAgICAgICAgICAgfCBFbXB0eSAtPiBhc3NlcnQgZmFsc2VcbiAgICAgICAgICAgIHwgQ29ucyBwcmVjIC0+ICBwcmVjLm5leHQgPC0gclxuICAgICAgICAgICAgZW5kO1xuICAgICAgICAgICAgbG9vcCByIG5leHRcbiAgICAgIGluXG4gICAgICBsZXQgciA9IENvbnMge2tleTsgZGF0YTsgbmV4dH0gaW5cbiAgICAgIGxvb3AgciBuZXh0O1xuICAgICAgclxuXG5sZXQgY29weSBoID0geyBoIHdpdGggZGF0YSA9IEFycmF5Lm1hcCBjb3B5X2J1Y2tldGxpc3QgaC5kYXRhIH1cblxubGV0IGxlbmd0aCBoID0gaC5zaXplXG5cbmxldCBpbnNlcnRfYWxsX2J1Y2tldHMgaW5kZXhmdW4gaW5wbGFjZSBvZGF0YSBuZGF0YSA9XG4gIGxldCBuc2l6ZSA9IEFycmF5Lmxlbmd0aCBuZGF0YSBpblxuICBsZXQgbmRhdGFfdGFpbCA9IEFycmF5Lm1ha2UgbnNpemUgRW1wdHkgaW5cbiAgbGV0IHJlYyBpbnNlcnRfYnVja2V0ID0gZnVuY3Rpb25cbiAgICB8IEVtcHR5IC0+ICgpXG4gICAgfCBDb25zIHtrZXk7IGRhdGE7IG5leHR9IGFzIGNlbGwgLT5cbiAgICAgICAgbGV0IGNlbGwgPVxuICAgICAgICAgIGlmIGlucGxhY2UgdGhlbiBjZWxsXG4gICAgICAgICAgZWxzZSBDb25zIHtrZXk7IGRhdGE7IG5leHQgPSBFbXB0eX1cbiAgICAgICAgaW5cbiAgICAgICAgbGV0IG5pZHggPSBpbmRleGZ1biBrZXkgaW5cbiAgICAgICAgYmVnaW4gbWF0Y2ggbmRhdGFfdGFpbC4obmlkeCkgd2l0aFxuICAgICAgICB8IEVtcHR5IC0+IG5kYXRhLihuaWR4KSA8LSBjZWxsO1xuICAgICAgICB8IENvbnMgdGFpbCAtPiB0YWlsLm5leHQgPC0gY2VsbDtcbiAgICAgICAgZW5kO1xuICAgICAgICBuZGF0YV90YWlsLihuaWR4KSA8LSBjZWxsO1xuICAgICAgICBpbnNlcnRfYnVja2V0IG5leHRcbiAgaW5cbiAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCBvZGF0YSAtIDEgZG9cbiAgICBpbnNlcnRfYnVja2V0IG9kYXRhLihpKVxuICBkb25lO1xuICBpZiBpbnBsYWNlIHRoZW5cbiAgICBmb3IgaSA9IDAgdG8gbnNpemUgLSAxIGRvXG4gICAgICBtYXRjaCBuZGF0YV90YWlsLihpKSB3aXRoXG4gICAgICB8IEVtcHR5IC0+ICgpXG4gICAgICB8IENvbnMgdGFpbCAtPiB0YWlsLm5leHQgPC0gRW1wdHlcbiAgICBkb25lXG5cbmxldCByZXNpemUgaW5kZXhmdW4gaCA9XG4gIGxldCBvZGF0YSA9IGguZGF0YSBpblxuICBsZXQgb3NpemUgPSBBcnJheS5sZW5ndGggb2RhdGEgaW5cbiAgbGV0IG5zaXplID0gb3NpemUgKiAyIGluXG4gIGlmIG5zaXplIDwgU3lzLm1heF9hcnJheV9sZW5ndGggdGhlbiBiZWdpblxuICAgIGxldCBuZGF0YSA9IEFycmF5Lm1ha2UgbnNpemUgRW1wdHkgaW5cbiAgICBsZXQgaW5wbGFjZSA9IG5vdCAob25nb2luZ190cmF2ZXJzYWwgaCkgaW5cbiAgICBoLmRhdGEgPC0gbmRhdGE7ICAgICAgICAgICgqIHNvIHRoYXQgaW5kZXhmdW4gc2VlcyB0aGUgbmV3IGJ1Y2tldCBjb3VudCAqKVxuICAgIGluc2VydF9hbGxfYnVja2V0cyAoaW5kZXhmdW4gaCkgaW5wbGFjZSBvZGF0YSBuZGF0YVxuICBlbmRcblxubGV0IGl0ZXIgZiBoID1cbiAgbGV0IHJlYyBkb19idWNrZXQgPSBmdW5jdGlvblxuICAgIHwgRW1wdHkgLT5cbiAgICAgICAgKClcbiAgICB8IENvbnN7a2V5OyBkYXRhOyBuZXh0fSAtPlxuICAgICAgICBmIGtleSBkYXRhOyBkb19idWNrZXQgbmV4dCBpblxuICBsZXQgb2xkX3RyYXYgPSBvbmdvaW5nX3RyYXZlcnNhbCBoIGluXG4gIGlmIG5vdCBvbGRfdHJhdiB0aGVuIGZsaXBfb25nb2luZ190cmF2ZXJzYWwgaDtcbiAgdHJ5XG4gICAgbGV0IGQgPSBoLmRhdGEgaW5cbiAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGQgLSAxIGRvXG4gICAgICBkb19idWNrZXQgZC4oaSlcbiAgICBkb25lO1xuICAgIGlmIG5vdCBvbGRfdHJhdiB0aGVuIGZsaXBfb25nb2luZ190cmF2ZXJzYWwgaDtcbiAgd2l0aCBleG4gd2hlbiBub3Qgb2xkX3RyYXYgLT5cbiAgICBmbGlwX29uZ29pbmdfdHJhdmVyc2FsIGg7XG4gICAgcmFpc2UgZXhuXG5cbmxldCByZWMgZmlsdGVyX21hcF9pbnBsYWNlX2J1Y2tldCBmIGggaSBwcmVjID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPlxuICAgICAgYmVnaW4gbWF0Y2ggcHJlYyB3aXRoXG4gICAgICB8IEVtcHR5IC0+IGguZGF0YS4oaSkgPC0gRW1wdHlcbiAgICAgIHwgQ29ucyBjIC0+IGMubmV4dCA8LSBFbXB0eVxuICAgICAgZW5kXG4gIHwgKENvbnMgKHtrZXk7IGRhdGE7IG5leHR9IGFzIGMpKSBhcyBzbG90IC0+XG4gICAgICBiZWdpbiBtYXRjaCBmIGtleSBkYXRhIHdpdGhcbiAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgIGguc2l6ZSA8LSBoLnNpemUgLSAxO1xuICAgICAgICAgIGZpbHRlcl9tYXBfaW5wbGFjZV9idWNrZXQgZiBoIGkgcHJlYyBuZXh0XG4gICAgICB8IFNvbWUgZGF0YSAtPlxuICAgICAgICAgIGJlZ2luIG1hdGNoIHByZWMgd2l0aFxuICAgICAgICAgIHwgRW1wdHkgLT4gaC5kYXRhLihpKSA8LSBzbG90XG4gICAgICAgICAgfCBDb25zIGMgLT4gYy5uZXh0IDwtIHNsb3RcbiAgICAgICAgICBlbmQ7XG4gICAgICAgICAgYy5kYXRhIDwtIGRhdGE7XG4gICAgICAgICAgZmlsdGVyX21hcF9pbnBsYWNlX2J1Y2tldCBmIGggaSBzbG90IG5leHRcbiAgICAgIGVuZFxuXG5sZXQgZmlsdGVyX21hcF9pbnBsYWNlIGYgaCA9XG4gIGxldCBkID0gaC5kYXRhIGluXG4gIGxldCBvbGRfdHJhdiA9IG9uZ29pbmdfdHJhdmVyc2FsIGggaW5cbiAgaWYgbm90IG9sZF90cmF2IHRoZW4gZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoO1xuICB0cnlcbiAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGQgLSAxIGRvXG4gICAgICBmaWx0ZXJfbWFwX2lucGxhY2VfYnVja2V0IGYgaCBpIEVtcHR5IGguZGF0YS4oaSlcbiAgICBkb25lO1xuICAgIGlmIG5vdCBvbGRfdHJhdiB0aGVuIGZsaXBfb25nb2luZ190cmF2ZXJzYWwgaFxuICB3aXRoIGV4biB3aGVuIG5vdCBvbGRfdHJhdiAtPlxuICAgIGZsaXBfb25nb2luZ190cmF2ZXJzYWwgaDtcbiAgICByYWlzZSBleG5cblxubGV0IGZvbGQgZiBoIGluaXQgPVxuICBsZXQgcmVjIGRvX2J1Y2tldCBiIGFjY3UgPVxuICAgIG1hdGNoIGIgd2l0aFxuICAgICAgRW1wdHkgLT5cbiAgICAgICAgYWNjdVxuICAgIHwgQ29uc3trZXk7IGRhdGE7IG5leHR9IC0+XG4gICAgICAgIGRvX2J1Y2tldCBuZXh0IChmIGtleSBkYXRhIGFjY3UpIGluXG4gIGxldCBvbGRfdHJhdiA9IG9uZ29pbmdfdHJhdmVyc2FsIGggaW5cbiAgaWYgbm90IG9sZF90cmF2IHRoZW4gZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoO1xuICB0cnlcbiAgICBsZXQgZCA9IGguZGF0YSBpblxuICAgIGxldCBhY2N1ID0gcmVmIGluaXQgaW5cbiAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGQgLSAxIGRvXG4gICAgICBhY2N1IDo9IGRvX2J1Y2tldCBkLihpKSAhYWNjdVxuICAgIGRvbmU7XG4gICAgaWYgbm90IG9sZF90cmF2IHRoZW4gZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoO1xuICAgICFhY2N1XG4gIHdpdGggZXhuIHdoZW4gbm90IG9sZF90cmF2IC0+XG4gICAgZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoO1xuICAgIHJhaXNlIGV4blxuXG50eXBlIHN0YXRpc3RpY3MgPSB7XG4gIG51bV9iaW5kaW5nczogaW50O1xuICBudW1fYnVja2V0czogaW50O1xuICBtYXhfYnVja2V0X2xlbmd0aDogaW50O1xuICBidWNrZXRfaGlzdG9ncmFtOiBpbnQgYXJyYXlcbn1cblxubGV0IHJlYyBidWNrZXRfbGVuZ3RoIGFjY3UgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+IGFjY3VcbiAgfCBDb25ze25leHR9IC0+IGJ1Y2tldF9sZW5ndGggKGFjY3UgKyAxKSBuZXh0XG5cbmxldCBzdGF0cyBoID1cbiAgbGV0IG1ibCA9XG4gICAgQXJyYXkuZm9sZF9sZWZ0IChmdW4gbSBiIC0+IG1heCBtIChidWNrZXRfbGVuZ3RoIDAgYikpIDAgaC5kYXRhIGluXG4gIGxldCBoaXN0byA9IEFycmF5Lm1ha2UgKG1ibCArIDEpIDAgaW5cbiAgQXJyYXkuaXRlclxuICAgIChmdW4gYiAtPlxuICAgICAgbGV0IGwgPSBidWNrZXRfbGVuZ3RoIDAgYiBpblxuICAgICAgaGlzdG8uKGwpIDwtIGhpc3RvLihsKSArIDEpXG4gICAgaC5kYXRhO1xuICB7IG51bV9iaW5kaW5ncyA9IGguc2l6ZTtcbiAgICBudW1fYnVja2V0cyA9IEFycmF5Lmxlbmd0aCBoLmRhdGE7XG4gICAgbWF4X2J1Y2tldF9sZW5ndGggPSBtYmw7XG4gICAgYnVja2V0X2hpc3RvZ3JhbSA9IGhpc3RvIH1cblxuKCoqIHsxIEl0ZXJhdG9yc30gKilcblxubGV0IHRvX3NlcSB0YmwgPVxuICAoKiBjYXB0dXJlIGN1cnJlbnQgYXJyYXksIHNvIHRoYXQgZXZlbiBpZiB0aGUgdGFibGUgaXMgcmVzaXplZCB3ZVxuICAgICBrZWVwIGl0ZXJhdGluZyBvbiB0aGUgc2FtZSBhcnJheSAqKVxuICBsZXQgdGJsX2RhdGEgPSB0YmwuZGF0YSBpblxuICAoKiBzdGF0ZTogaW5kZXggKiBuZXh0IGJ1Y2tldCB0byB0cmF2ZXJzZSAqKVxuICBsZXQgcmVjIGF1eCBpIGJ1Y2sgKCkgPSBtYXRjaCBidWNrIHdpdGhcbiAgICB8IEVtcHR5IC0+XG4gICAgICAgIGlmIGkgPSBBcnJheS5sZW5ndGggdGJsX2RhdGFcbiAgICAgICAgdGhlbiBTZXEuTmlsXG4gICAgICAgIGVsc2UgYXV4KGkrMSkgdGJsX2RhdGEuKGkpICgpXG4gICAgfCBDb25zIHtrZXk7IGRhdGE7IG5leHR9IC0+XG4gICAgICAgIFNlcS5Db25zICgoa2V5LCBkYXRhKSwgYXV4IGkgbmV4dClcbiAgaW5cbiAgYXV4IDAgRW1wdHlcblxubGV0IHRvX3NlcV9rZXlzIG0gPSBTZXEubWFwIGZzdCAodG9fc2VxIG0pXG5cbmxldCB0b19zZXFfdmFsdWVzIG0gPSBTZXEubWFwIHNuZCAodG9fc2VxIG0pXG5cbigqIEZ1bmN0b3JpYWwgaW50ZXJmYWNlICopXG5cbm1vZHVsZSB0eXBlIEhhc2hlZFR5cGUgPVxuICBzaWdcbiAgICB0eXBlIHRcbiAgICB2YWwgZXF1YWw6IHQgLT4gdCAtPiBib29sXG4gICAgdmFsIGhhc2g6IHQgLT4gaW50XG4gIGVuZFxuXG5tb2R1bGUgdHlwZSBTZWVkZWRIYXNoZWRUeXBlID1cbiAgc2lnXG4gICAgdHlwZSB0XG4gICAgdmFsIGVxdWFsOiB0IC0+IHQgLT4gYm9vbFxuICAgIHZhbCBoYXNoOiBpbnQgLT4gdCAtPiBpbnRcbiAgZW5kXG5cbm1vZHVsZSB0eXBlIFMgPVxuICBzaWdcbiAgICB0eXBlIGtleVxuICAgIHR5cGUgISdhIHRcbiAgICB2YWwgY3JlYXRlOiBpbnQgLT4gJ2EgdFxuICAgIHZhbCBjbGVhciA6ICdhIHQgLT4gdW5pdFxuICAgIHZhbCByZXNldCA6ICdhIHQgLT4gdW5pdFxuICAgIHZhbCBjb3B5OiAnYSB0IC0+ICdhIHRcbiAgICB2YWwgYWRkOiAnYSB0IC0+IGtleSAtPiAnYSAtPiB1bml0XG4gICAgdmFsIHJlbW92ZTogJ2EgdCAtPiBrZXkgLT4gdW5pdFxuICAgIHZhbCBmaW5kOiAnYSB0IC0+IGtleSAtPiAnYVxuICAgIHZhbCBmaW5kX29wdDogJ2EgdCAtPiBrZXkgLT4gJ2Egb3B0aW9uXG4gICAgdmFsIGZpbmRfYWxsOiAnYSB0IC0+IGtleSAtPiAnYSBsaXN0XG4gICAgdmFsIHJlcGxhY2UgOiAnYSB0IC0+IGtleSAtPiAnYSAtPiB1bml0XG4gICAgdmFsIG1lbSA6ICdhIHQgLT4ga2V5IC0+IGJvb2xcbiAgICB2YWwgaXRlcjogKGtleSAtPiAnYSAtPiB1bml0KSAtPiAnYSB0IC0+IHVuaXRcbiAgICB2YWwgZmlsdGVyX21hcF9pbnBsYWNlOiAoa2V5IC0+ICdhIC0+ICdhIG9wdGlvbikgLT4gJ2EgdCAtPiB1bml0XG4gICAgdmFsIGZvbGQ6IChrZXkgLT4gJ2EgLT4gJ2IgLT4gJ2IpIC0+ICdhIHQgLT4gJ2IgLT4gJ2JcbiAgICB2YWwgbGVuZ3RoOiAnYSB0IC0+IGludFxuICAgIHZhbCBzdGF0czogJ2EgdCAtPiBzdGF0aXN0aWNzXG4gICAgdmFsIHRvX3NlcSA6ICdhIHQgLT4gKGtleSAqICdhKSBTZXEudFxuICAgIHZhbCB0b19zZXFfa2V5cyA6IF8gdCAtPiBrZXkgU2VxLnRcbiAgICB2YWwgdG9fc2VxX3ZhbHVlcyA6ICdhIHQgLT4gJ2EgU2VxLnRcbiAgICB2YWwgYWRkX3NlcSA6ICdhIHQgLT4gKGtleSAqICdhKSBTZXEudCAtPiB1bml0XG4gICAgdmFsIHJlcGxhY2Vfc2VxIDogJ2EgdCAtPiAoa2V5ICogJ2EpIFNlcS50IC0+IHVuaXRcbiAgICB2YWwgb2Zfc2VxIDogKGtleSAqICdhKSBTZXEudCAtPiAnYSB0XG4gIGVuZFxuXG5tb2R1bGUgdHlwZSBTZWVkZWRTID1cbiAgc2lnXG4gICAgdHlwZSBrZXlcbiAgICB0eXBlICEnYSB0XG4gICAgdmFsIGNyZWF0ZSA6ID9yYW5kb206Ym9vbCAtPiBpbnQgLT4gJ2EgdFxuICAgIHZhbCBjbGVhciA6ICdhIHQgLT4gdW5pdFxuICAgIHZhbCByZXNldCA6ICdhIHQgLT4gdW5pdFxuICAgIHZhbCBjb3B5IDogJ2EgdCAtPiAnYSB0XG4gICAgdmFsIGFkZCA6ICdhIHQgLT4ga2V5IC0+ICdhIC0+IHVuaXRcbiAgICB2YWwgcmVtb3ZlIDogJ2EgdCAtPiBrZXkgLT4gdW5pdFxuICAgIHZhbCBmaW5kIDogJ2EgdCAtPiBrZXkgLT4gJ2FcbiAgICB2YWwgZmluZF9vcHQ6ICdhIHQgLT4ga2V5IC0+ICdhIG9wdGlvblxuICAgIHZhbCBmaW5kX2FsbCA6ICdhIHQgLT4ga2V5IC0+ICdhIGxpc3RcbiAgICB2YWwgcmVwbGFjZSA6ICdhIHQgLT4ga2V5IC0+ICdhIC0+IHVuaXRcbiAgICB2YWwgbWVtIDogJ2EgdCAtPiBrZXkgLT4gYm9vbFxuICAgIHZhbCBpdGVyIDogKGtleSAtPiAnYSAtPiB1bml0KSAtPiAnYSB0IC0+IHVuaXRcbiAgICB2YWwgZmlsdGVyX21hcF9pbnBsYWNlOiAoa2V5IC0+ICdhIC0+ICdhIG9wdGlvbikgLT4gJ2EgdCAtPiB1bml0XG4gICAgdmFsIGZvbGQgOiAoa2V5IC0+ICdhIC0+ICdiIC0+ICdiKSAtPiAnYSB0IC0+ICdiIC0+ICdiXG4gICAgdmFsIGxlbmd0aCA6ICdhIHQgLT4gaW50XG4gICAgdmFsIHN0YXRzOiAnYSB0IC0+IHN0YXRpc3RpY3NcbiAgICB2YWwgdG9fc2VxIDogJ2EgdCAtPiAoa2V5ICogJ2EpIFNlcS50XG4gICAgdmFsIHRvX3NlcV9rZXlzIDogXyB0IC0+IGtleSBTZXEudFxuICAgIHZhbCB0b19zZXFfdmFsdWVzIDogJ2EgdCAtPiAnYSBTZXEudFxuICAgIHZhbCBhZGRfc2VxIDogJ2EgdCAtPiAoa2V5ICogJ2EpIFNlcS50IC0+IHVuaXRcbiAgICB2YWwgcmVwbGFjZV9zZXEgOiAnYSB0IC0+IChrZXkgKiAnYSkgU2VxLnQgLT4gdW5pdFxuICAgIHZhbCBvZl9zZXEgOiAoa2V5ICogJ2EpIFNlcS50IC0+ICdhIHRcbiAgZW5kXG5cbm1vZHVsZSBNYWtlU2VlZGVkKEg6IFNlZWRlZEhhc2hlZFR5cGUpOiAoU2VlZGVkUyB3aXRoIHR5cGUga2V5ID0gSC50KSA9XG4gIHN0cnVjdFxuICAgIHR5cGUga2V5ID0gSC50XG4gICAgdHlwZSAnYSBoYXNodGJsID0gKGtleSwgJ2EpIHRcbiAgICB0eXBlICdhIHQgPSAnYSBoYXNodGJsXG4gICAgbGV0IGNyZWF0ZSA9IGNyZWF0ZVxuICAgIGxldCBjbGVhciA9IGNsZWFyXG4gICAgbGV0IHJlc2V0ID0gcmVzZXRcbiAgICBsZXQgY29weSA9IGNvcHlcblxuICAgIGxldCBrZXlfaW5kZXggaCBrZXkgPVxuICAgICAgKEguaGFzaCBoLnNlZWQga2V5KSBsYW5kIChBcnJheS5sZW5ndGggaC5kYXRhIC0gMSlcblxuICAgIGxldCBhZGQgaCBrZXkgZGF0YSA9XG4gICAgICBsZXQgaSA9IGtleV9pbmRleCBoIGtleSBpblxuICAgICAgbGV0IGJ1Y2tldCA9IENvbnN7a2V5OyBkYXRhOyBuZXh0PWguZGF0YS4oaSl9IGluXG4gICAgICBoLmRhdGEuKGkpIDwtIGJ1Y2tldDtcbiAgICAgIGguc2l6ZSA8LSBoLnNpemUgKyAxO1xuICAgICAgaWYgaC5zaXplID4gQXJyYXkubGVuZ3RoIGguZGF0YSBsc2wgMSB0aGVuIHJlc2l6ZSBrZXlfaW5kZXggaFxuXG4gICAgbGV0IHJlYyByZW1vdmVfYnVja2V0IGggaSBrZXkgcHJlYyA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgKClcbiAgICAgIHwgKENvbnMge2tleT1rOyBuZXh0fSkgYXMgYyAtPlxuICAgICAgICAgIGlmIEguZXF1YWwgayBrZXlcbiAgICAgICAgICB0aGVuIGJlZ2luXG4gICAgICAgICAgICBoLnNpemUgPC0gaC5zaXplIC0gMTtcbiAgICAgICAgICAgIG1hdGNoIHByZWMgd2l0aFxuICAgICAgICAgICAgfCBFbXB0eSAtPiBoLmRhdGEuKGkpIDwtIG5leHRcbiAgICAgICAgICAgIHwgQ29ucyBjIC0+IGMubmV4dCA8LSBuZXh0XG4gICAgICAgICAgZW5kXG4gICAgICAgICAgZWxzZSByZW1vdmVfYnVja2V0IGggaSBrZXkgYyBuZXh0XG5cbiAgICBsZXQgcmVtb3ZlIGgga2V5ID1cbiAgICAgIGxldCBpID0ga2V5X2luZGV4IGgga2V5IGluXG4gICAgICByZW1vdmVfYnVja2V0IGggaSBrZXkgRW1wdHkgaC5kYXRhLihpKVxuXG4gICAgbGV0IHJlYyBmaW5kX3JlYyBrZXkgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgIHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBDb25ze2tleT1rOyBkYXRhOyBuZXh0fSAtPlxuICAgICAgICAgIGlmIEguZXF1YWwga2V5IGsgdGhlbiBkYXRhIGVsc2UgZmluZF9yZWMga2V5IG5leHRcblxuICAgIGxldCBmaW5kIGgga2V5ID1cbiAgICAgIG1hdGNoIGguZGF0YS4oa2V5X2luZGV4IGgga2V5KSB3aXRoXG4gICAgICB8IEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBDb25ze2tleT1rMTsgZGF0YT1kMTsgbmV4dD1uZXh0MX0gLT5cbiAgICAgICAgICBpZiBILmVxdWFsIGtleSBrMSB0aGVuIGQxIGVsc2VcbiAgICAgICAgICBtYXRjaCBuZXh0MSB3aXRoXG4gICAgICAgICAgfCBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgICAgICB8IENvbnN7a2V5PWsyOyBkYXRhPWQyOyBuZXh0PW5leHQyfSAtPlxuICAgICAgICAgICAgICBpZiBILmVxdWFsIGtleSBrMiB0aGVuIGQyIGVsc2VcbiAgICAgICAgICAgICAgbWF0Y2ggbmV4dDIgd2l0aFxuICAgICAgICAgICAgICB8IEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgICAgICAgICB8IENvbnN7a2V5PWszOyBkYXRhPWQzOyBuZXh0PW5leHQzfSAtPlxuICAgICAgICAgICAgICAgICAgaWYgSC5lcXVhbCBrZXkgazMgdGhlbiBkMyBlbHNlIGZpbmRfcmVjIGtleSBuZXh0M1xuXG4gICAgbGV0IHJlYyBmaW5kX3JlY19vcHQga2V5ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICBOb25lXG4gICAgICB8IENvbnN7a2V5PWs7IGRhdGE7IG5leHR9IC0+XG4gICAgICAgICAgaWYgSC5lcXVhbCBrZXkgayB0aGVuIFNvbWUgZGF0YSBlbHNlIGZpbmRfcmVjX29wdCBrZXkgbmV4dFxuXG4gICAgbGV0IGZpbmRfb3B0IGgga2V5ID1cbiAgICAgIG1hdGNoIGguZGF0YS4oa2V5X2luZGV4IGgga2V5KSB3aXRoXG4gICAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICAgIHwgQ29uc3trZXk9azE7IGRhdGE9ZDE7IG5leHQ9bmV4dDF9IC0+XG4gICAgICAgICAgaWYgSC5lcXVhbCBrZXkgazEgdGhlbiBTb21lIGQxIGVsc2VcbiAgICAgICAgICBtYXRjaCBuZXh0MSB3aXRoXG4gICAgICAgICAgfCBFbXB0eSAtPiBOb25lXG4gICAgICAgICAgfCBDb25ze2tleT1rMjsgZGF0YT1kMjsgbmV4dD1uZXh0Mn0gLT5cbiAgICAgICAgICAgICAgaWYgSC5lcXVhbCBrZXkgazIgdGhlbiBTb21lIGQyIGVsc2VcbiAgICAgICAgICAgICAgbWF0Y2ggbmV4dDIgd2l0aFxuICAgICAgICAgICAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICAgICAgICAgICAgfCBDb25ze2tleT1rMzsgZGF0YT1kMzsgbmV4dD1uZXh0M30gLT5cbiAgICAgICAgICAgICAgICAgIGlmIEguZXF1YWwga2V5IGszIHRoZW4gU29tZSBkMyBlbHNlIGZpbmRfcmVjX29wdCBrZXkgbmV4dDNcblxuICAgIGxldCBmaW5kX2FsbCBoIGtleSA9XG4gICAgICBsZXQgcmVjIGZpbmRfaW5fYnVja2V0ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICBbXVxuICAgICAgfCBDb25ze2tleT1rOyBkYXRhPWQ7IG5leHR9IC0+XG4gICAgICAgICAgaWYgSC5lcXVhbCBrIGtleVxuICAgICAgICAgIHRoZW4gZCA6OiBmaW5kX2luX2J1Y2tldCBuZXh0XG4gICAgICAgICAgZWxzZSBmaW5kX2luX2J1Y2tldCBuZXh0IGluXG4gICAgICBmaW5kX2luX2J1Y2tldCBoLmRhdGEuKGtleV9pbmRleCBoIGtleSlcblxuICAgIGxldCByZWMgcmVwbGFjZV9idWNrZXQga2V5IGRhdGEgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgIHRydWVcbiAgICAgIHwgQ29ucyAoe2tleT1rOyBuZXh0fSBhcyBzbG90KSAtPlxuICAgICAgICAgIGlmIEguZXF1YWwgayBrZXlcbiAgICAgICAgICB0aGVuIChzbG90LmtleSA8LSBrZXk7IHNsb3QuZGF0YSA8LSBkYXRhOyBmYWxzZSlcbiAgICAgICAgICBlbHNlIHJlcGxhY2VfYnVja2V0IGtleSBkYXRhIG5leHRcblxuICAgIGxldCByZXBsYWNlIGgga2V5IGRhdGEgPVxuICAgICAgbGV0IGkgPSBrZXlfaW5kZXggaCBrZXkgaW5cbiAgICAgIGxldCBsID0gaC5kYXRhLihpKSBpblxuICAgICAgaWYgcmVwbGFjZV9idWNrZXQga2V5IGRhdGEgbCB0aGVuIGJlZ2luXG4gICAgICAgIGguZGF0YS4oaSkgPC0gQ29uc3trZXk7IGRhdGE7IG5leHQ9bH07XG4gICAgICAgIGguc2l6ZSA8LSBoLnNpemUgKyAxO1xuICAgICAgICBpZiBoLnNpemUgPiBBcnJheS5sZW5ndGggaC5kYXRhIGxzbCAxIHRoZW4gcmVzaXplIGtleV9pbmRleCBoXG4gICAgICBlbmRcblxuICAgIGxldCBtZW0gaCBrZXkgPVxuICAgICAgbGV0IHJlYyBtZW1faW5fYnVja2V0ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICBmYWxzZVxuICAgICAgfCBDb25ze2tleT1rOyBuZXh0fSAtPlxuICAgICAgICAgIEguZXF1YWwgayBrZXkgfHwgbWVtX2luX2J1Y2tldCBuZXh0IGluXG4gICAgICBtZW1faW5fYnVja2V0IGguZGF0YS4oa2V5X2luZGV4IGgga2V5KVxuXG4gICAgbGV0IGFkZF9zZXEgdGJsIGkgPVxuICAgICAgU2VxLml0ZXIgKGZ1biAoayx2KSAtPiBhZGQgdGJsIGsgdikgaVxuXG4gICAgbGV0IHJlcGxhY2Vfc2VxIHRibCBpID1cbiAgICAgIFNlcS5pdGVyIChmdW4gKGssdikgLT4gcmVwbGFjZSB0YmwgayB2KSBpXG5cbiAgICBsZXQgb2Zfc2VxIGkgPVxuICAgICAgbGV0IHRibCA9IGNyZWF0ZSAxNiBpblxuICAgICAgcmVwbGFjZV9zZXEgdGJsIGk7XG4gICAgICB0YmxcblxuICAgIGxldCBpdGVyID0gaXRlclxuICAgIGxldCBmaWx0ZXJfbWFwX2lucGxhY2UgPSBmaWx0ZXJfbWFwX2lucGxhY2VcbiAgICBsZXQgZm9sZCA9IGZvbGRcbiAgICBsZXQgbGVuZ3RoID0gbGVuZ3RoXG4gICAgbGV0IHN0YXRzID0gc3RhdHNcbiAgICBsZXQgdG9fc2VxID0gdG9fc2VxXG4gICAgbGV0IHRvX3NlcV9rZXlzID0gdG9fc2VxX2tleXNcbiAgICBsZXQgdG9fc2VxX3ZhbHVlcyA9IHRvX3NlcV92YWx1ZXNcbiAgZW5kXG5cbm1vZHVsZSBNYWtlKEg6IEhhc2hlZFR5cGUpOiAoUyB3aXRoIHR5cGUga2V5ID0gSC50KSA9XG4gIHN0cnVjdFxuICAgIGluY2x1ZGUgTWFrZVNlZWRlZChzdHJ1Y3RcbiAgICAgICAgdHlwZSB0ID0gSC50XG4gICAgICAgIGxldCBlcXVhbCA9IEguZXF1YWxcbiAgICAgICAgbGV0IGhhc2ggKF9zZWVkOiBpbnQpIHggPSBILmhhc2ggeFxuICAgICAgZW5kKVxuICAgIGxldCBjcmVhdGUgc3ogPSBjcmVhdGUgfnJhbmRvbTpmYWxzZSBzelxuICAgIGxldCBvZl9zZXEgaSA9XG4gICAgICBsZXQgdGJsID0gY3JlYXRlIDE2IGluXG4gICAgICByZXBsYWNlX3NlcSB0YmwgaTtcbiAgICAgIHRibFxuICBlbmRcblxuKCogUG9seW1vcnBoaWMgaGFzaCBmdW5jdGlvbi1iYXNlZCB0YWJsZXMgKilcbigqIENvZGUgaW5jbHVkZWQgYmVsb3cgdGhlIGZ1bmN0b3JpYWwgaW50ZXJmYWNlIHRvIGd1YXJkIGFnYWluc3QgYWNjaWRlbnRhbFxuICAgdXNlIC0gc2VlICMyMjAyICopXG5cbmV4dGVybmFsIHNlZWRlZF9oYXNoX3BhcmFtIDpcbiAgaW50IC0+IGludCAtPiBpbnQgLT4gJ2EgLT4gaW50ID0gXCJjYW1sX2hhc2hcIiBbQEBub2FsbG9jXVxuXG5sZXQgaGFzaCB4ID0gc2VlZGVkX2hhc2hfcGFyYW0gMTAgMTAwIDAgeFxubGV0IGhhc2hfcGFyYW0gbjEgbjIgeCA9IHNlZWRlZF9oYXNoX3BhcmFtIG4xIG4yIDAgeFxubGV0IHNlZWRlZF9oYXNoIHNlZWQgeCA9IHNlZWRlZF9oYXNoX3BhcmFtIDEwIDEwMCBzZWVkIHhcblxubGV0IGtleV9pbmRleCBoIGtleSA9XG4gIGlmIE9iai5zaXplIChPYmoucmVwciBoKSA+PSA0XG4gIHRoZW4gKHNlZWRlZF9oYXNoX3BhcmFtIDEwIDEwMCBoLnNlZWQga2V5KSBsYW5kIChBcnJheS5sZW5ndGggaC5kYXRhIC0gMSlcbiAgZWxzZSBpbnZhbGlkX2FyZyBcIkhhc2h0Ymw6IHVuc3VwcG9ydGVkIGhhc2ggdGFibGUgZm9ybWF0XCJcblxubGV0IGFkZCBoIGtleSBkYXRhID1cbiAgbGV0IGkgPSBrZXlfaW5kZXggaCBrZXkgaW5cbiAgbGV0IGJ1Y2tldCA9IENvbnN7a2V5OyBkYXRhOyBuZXh0PWguZGF0YS4oaSl9IGluXG4gIGguZGF0YS4oaSkgPC0gYnVja2V0O1xuICBoLnNpemUgPC0gaC5zaXplICsgMTtcbiAgaWYgaC5zaXplID4gQXJyYXkubGVuZ3RoIGguZGF0YSBsc2wgMSB0aGVuIHJlc2l6ZSBrZXlfaW5kZXggaFxuXG5sZXQgcmVjIHJlbW92ZV9idWNrZXQgaCBpIGtleSBwcmVjID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPlxuICAgICAgKClcbiAgfCAoQ29ucyB7a2V5PWs7IG5leHR9KSBhcyBjIC0+XG4gICAgICBpZiBjb21wYXJlIGsga2V5ID0gMFxuICAgICAgdGhlbiBiZWdpblxuICAgICAgICBoLnNpemUgPC0gaC5zaXplIC0gMTtcbiAgICAgICAgbWF0Y2ggcHJlYyB3aXRoXG4gICAgICAgIHwgRW1wdHkgLT4gaC5kYXRhLihpKSA8LSBuZXh0XG4gICAgICAgIHwgQ29ucyBjIC0+IGMubmV4dCA8LSBuZXh0XG4gICAgICBlbmRcbiAgICAgIGVsc2UgcmVtb3ZlX2J1Y2tldCBoIGkga2V5IGMgbmV4dFxuXG5sZXQgcmVtb3ZlIGgga2V5ID1cbiAgbGV0IGkgPSBrZXlfaW5kZXggaCBrZXkgaW5cbiAgcmVtb3ZlX2J1Y2tldCBoIGkga2V5IEVtcHR5IGguZGF0YS4oaSlcblxubGV0IHJlYyBmaW5kX3JlYyBrZXkgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+XG4gICAgICByYWlzZSBOb3RfZm91bmRcbiAgfCBDb25ze2tleT1rOyBkYXRhOyBuZXh0fSAtPlxuICAgICAgaWYgY29tcGFyZSBrZXkgayA9IDAgdGhlbiBkYXRhIGVsc2UgZmluZF9yZWMga2V5IG5leHRcblxubGV0IGZpbmQgaCBrZXkgPVxuICBtYXRjaCBoLmRhdGEuKGtleV9pbmRleCBoIGtleSkgd2l0aFxuICB8IEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICB8IENvbnN7a2V5PWsxOyBkYXRhPWQxOyBuZXh0PW5leHQxfSAtPlxuICAgICAgaWYgY29tcGFyZSBrZXkgazEgPSAwIHRoZW4gZDEgZWxzZVxuICAgICAgbWF0Y2ggbmV4dDEgd2l0aFxuICAgICAgfCBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgQ29uc3trZXk9azI7IGRhdGE9ZDI7IG5leHQ9bmV4dDJ9IC0+XG4gICAgICAgICAgaWYgY29tcGFyZSBrZXkgazIgPSAwIHRoZW4gZDIgZWxzZVxuICAgICAgICAgIG1hdGNoIG5leHQyIHdpdGhcbiAgICAgICAgICB8IEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgICAgIHwgQ29uc3trZXk9azM7IGRhdGE9ZDM7IG5leHQ9bmV4dDN9IC0+XG4gICAgICAgICAgICAgIGlmIGNvbXBhcmUga2V5IGszID0gMCB0aGVuIGQzIGVsc2UgZmluZF9yZWMga2V5IG5leHQzXG5cbmxldCByZWMgZmluZF9yZWNfb3B0IGtleSA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT5cbiAgICAgIE5vbmVcbiAgfCBDb25ze2tleT1rOyBkYXRhOyBuZXh0fSAtPlxuICAgICAgaWYgY29tcGFyZSBrZXkgayA9IDAgdGhlbiBTb21lIGRhdGEgZWxzZSBmaW5kX3JlY19vcHQga2V5IG5leHRcblxubGV0IGZpbmRfb3B0IGgga2V5ID1cbiAgbWF0Y2ggaC5kYXRhLihrZXlfaW5kZXggaCBrZXkpIHdpdGhcbiAgfCBFbXB0eSAtPiBOb25lXG4gIHwgQ29uc3trZXk9azE7IGRhdGE9ZDE7IG5leHQ9bmV4dDF9IC0+XG4gICAgICBpZiBjb21wYXJlIGtleSBrMSA9IDAgdGhlbiBTb21lIGQxIGVsc2VcbiAgICAgIG1hdGNoIG5leHQxIHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgICAgfCBDb25ze2tleT1rMjsgZGF0YT1kMjsgbmV4dD1uZXh0Mn0gLT5cbiAgICAgICAgICBpZiBjb21wYXJlIGtleSBrMiA9IDAgdGhlbiBTb21lIGQyIGVsc2VcbiAgICAgICAgICBtYXRjaCBuZXh0MiB3aXRoXG4gICAgICAgICAgfCBFbXB0eSAtPiBOb25lXG4gICAgICAgICAgfCBDb25ze2tleT1rMzsgZGF0YT1kMzsgbmV4dD1uZXh0M30gLT5cbiAgICAgICAgICAgICAgaWYgY29tcGFyZSBrZXkgazMgPSAwIHRoZW4gU29tZSBkMyBlbHNlIGZpbmRfcmVjX29wdCBrZXkgbmV4dDNcblxubGV0IGZpbmRfYWxsIGgga2V5ID1cbiAgbGV0IHJlYyBmaW5kX2luX2J1Y2tldCA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT5cbiAgICAgIFtdXG4gIHwgQ29uc3trZXk9azsgZGF0YTsgbmV4dH0gLT5cbiAgICAgIGlmIGNvbXBhcmUgayBrZXkgPSAwXG4gICAgICB0aGVuIGRhdGEgOjogZmluZF9pbl9idWNrZXQgbmV4dFxuICAgICAgZWxzZSBmaW5kX2luX2J1Y2tldCBuZXh0IGluXG4gIGZpbmRfaW5fYnVja2V0IGguZGF0YS4oa2V5X2luZGV4IGgga2V5KVxuXG5sZXQgcmVjIHJlcGxhY2VfYnVja2V0IGtleSBkYXRhID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPlxuICAgICAgdHJ1ZVxuICB8IENvbnMgKHtrZXk9azsgbmV4dH0gYXMgc2xvdCkgLT5cbiAgICAgIGlmIGNvbXBhcmUgayBrZXkgPSAwXG4gICAgICB0aGVuIChzbG90LmtleSA8LSBrZXk7IHNsb3QuZGF0YSA8LSBkYXRhOyBmYWxzZSlcbiAgICAgIGVsc2UgcmVwbGFjZV9idWNrZXQga2V5IGRhdGEgbmV4dFxuXG5sZXQgcmVwbGFjZSBoIGtleSBkYXRhID1cbiAgbGV0IGkgPSBrZXlfaW5kZXggaCBrZXkgaW5cbiAgbGV0IGwgPSBoLmRhdGEuKGkpIGluXG4gIGlmIHJlcGxhY2VfYnVja2V0IGtleSBkYXRhIGwgdGhlbiBiZWdpblxuICAgIGguZGF0YS4oaSkgPC0gQ29uc3trZXk7IGRhdGE7IG5leHQ9bH07XG4gICAgaC5zaXplIDwtIGguc2l6ZSArIDE7XG4gICAgaWYgaC5zaXplID4gQXJyYXkubGVuZ3RoIGguZGF0YSBsc2wgMSB0aGVuIHJlc2l6ZSBrZXlfaW5kZXggaFxuICBlbmRcblxubGV0IG1lbSBoIGtleSA9XG4gIGxldCByZWMgbWVtX2luX2J1Y2tldCA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT5cbiAgICAgIGZhbHNlXG4gIHwgQ29uc3trZXk9azsgbmV4dH0gLT5cbiAgICAgIGNvbXBhcmUgayBrZXkgPSAwIHx8IG1lbV9pbl9idWNrZXQgbmV4dCBpblxuICBtZW1faW5fYnVja2V0IGguZGF0YS4oa2V5X2luZGV4IGgga2V5KVxuXG5sZXQgYWRkX3NlcSB0YmwgaSA9XG4gIFNlcS5pdGVyIChmdW4gKGssdikgLT4gYWRkIHRibCBrIHYpIGlcblxubGV0IHJlcGxhY2Vfc2VxIHRibCBpID1cbiAgU2VxLml0ZXIgKGZ1biAoayx2KSAtPiByZXBsYWNlIHRibCBrIHYpIGlcblxubGV0IG9mX3NlcSBpID1cbiAgbGV0IHRibCA9IGNyZWF0ZSAxNiBpblxuICByZXBsYWNlX3NlcSB0YmwgaTtcbiAgdGJsXG5cbmxldCByZWJ1aWxkID8ocmFuZG9tID0gIXJhbmRvbWl6ZWQpIGggPVxuICBsZXQgcyA9IHBvd2VyXzJfYWJvdmUgMTYgKEFycmF5Lmxlbmd0aCBoLmRhdGEpIGluXG4gIGxldCBzZWVkID1cbiAgICBpZiByYW5kb20gdGhlbiBSYW5kb20uU3RhdGUuYml0cyAoTGF6eS5mb3JjZSBwcm5nKVxuICAgIGVsc2UgaWYgT2JqLnNpemUgKE9iai5yZXByIGgpID49IDQgdGhlbiBoLnNlZWRcbiAgICBlbHNlIDAgaW5cbiAgbGV0IGgnID0ge1xuICAgIHNpemUgPSBoLnNpemU7XG4gICAgZGF0YSA9IEFycmF5Lm1ha2UgcyBFbXB0eTtcbiAgICBzZWVkID0gc2VlZDtcbiAgICBpbml0aWFsX3NpemUgPSBpZiBPYmouc2l6ZSAoT2JqLnJlcHIgaCkgPj0gNCB0aGVuIGguaW5pdGlhbF9zaXplIGVsc2Ugc1xuICB9IGluXG4gIGluc2VydF9hbGxfYnVja2V0cyAoa2V5X2luZGV4IGgnKSBmYWxzZSBoLmRhdGEgaCcuZGF0YTtcbiAgaCdcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIERhbWllbiBEb2xpZ2V6LCBwcm9qZXQgUGFyYSwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTcgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCoqIFdlYWsgYXJyYXkgb3BlcmF0aW9ucyAqKVxuXG50eXBlICEnYSB0XG5cbmV4dGVybmFsIGNyZWF0ZSA6IGludCAtPiAnYSB0ID0gXCJjYW1sX3dlYWtfY3JlYXRlXCJcblxubGV0IGNyZWF0ZSBsID1cbiAgaWYgbm90ICgwIDw9IGwgJiYgbCA8PSBPYmouRXBoZW1lcm9uLm1heF9lcGhlX2xlbmd0aCkgdGhlblxuICAgIGludmFsaWRfYXJnKFwiV2Vhay5jcmVhdGVcIik7XG4gIGNyZWF0ZSBsXG5cbigqKiBudW1iZXIgb2YgYWRkaXRpb25hbCB2YWx1ZXMgaW4gYSB3ZWFrIHBvaW50ZXIgKilcbmxldCBhZGRpdGlvbmFsX3ZhbHVlcyA9IDJcblxubGV0IGxlbmd0aCB4ID0gT2JqLnNpemUoT2JqLnJlcHIgeCkgLSBhZGRpdGlvbmFsX3ZhbHVlc1xuXG5sZXQgcmFpc2VfaWZfaW52YWxpZF9vZmZzZXQgZSBvIG1zZyA9XG4gIGlmIG5vdCAoMCA8PSBvICYmIG8gPCBsZW5ndGggZSkgdGhlblxuICAgIGludmFsaWRfYXJnKG1zZylcblxuZXh0ZXJuYWwgc2V0JyA6ICdhIHQgLT4gaW50IC0+ICdhIC0+IHVuaXQgPSBcImNhbWxfZXBoZV9zZXRfa2V5XCJcbmV4dGVybmFsIHVuc2V0IDogJ2EgdCAtPiBpbnQgLT4gdW5pdCA9IFwiY2FtbF9lcGhlX3Vuc2V0X2tleVwiXG5sZXQgc2V0IGUgbyB4ID1cbiAgcmFpc2VfaWZfaW52YWxpZF9vZmZzZXQgZSBvIFwiV2Vhay5zZXRcIjtcbiAgbWF0Y2ggeCB3aXRoXG4gIHwgTm9uZSAtPiB1bnNldCBlIG9cbiAgfCBTb21lIHggLT4gc2V0JyBlIG8geFxuXG5leHRlcm5hbCBnZXQgOiAnYSB0IC0+IGludCAtPiAnYSBvcHRpb24gPSBcImNhbWxfd2Vha19nZXRcIlxubGV0IGdldCBlIG8gPVxuICByYWlzZV9pZl9pbnZhbGlkX29mZnNldCBlIG8gXCJXZWFrLmdldFwiO1xuICBnZXQgZSBvXG5cbmV4dGVybmFsIGdldF9jb3B5IDogJ2EgdCAtPiBpbnQgLT4gJ2Egb3B0aW9uID0gXCJjYW1sX3dlYWtfZ2V0X2NvcHlcIlxubGV0IGdldF9jb3B5IGUgbyA9XG4gIHJhaXNlX2lmX2ludmFsaWRfb2Zmc2V0IGUgbyBcIldlYWsuZ2V0X2NvcHlcIjtcbiAgZ2V0X2NvcHkgZSBvXG5cbmV4dGVybmFsIGNoZWNrIDogJ2EgdCAtPiBpbnQgLT4gYm9vbCA9IFwiY2FtbF93ZWFrX2NoZWNrXCJcbmxldCBjaGVjayBlIG8gPVxuICByYWlzZV9pZl9pbnZhbGlkX29mZnNldCBlIG8gXCJXZWFrLmNoZWNrXCI7XG4gIGNoZWNrIGUgb1xuXG5leHRlcm5hbCBibGl0IDogJ2EgdCAtPiBpbnQgLT4gJ2EgdCAtPiBpbnQgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfd2Vha19ibGl0XCJcblxuKCogYmxpdDogc3JjIHNyY29mZiBkc3QgZHN0b2ZmIGxlbiAqKVxubGV0IGJsaXQgZTEgbzEgZTIgbzIgbCA9XG4gIGlmIGwgPCAwIHx8IG8xIDwgMCB8fCBvMSA+IGxlbmd0aCBlMSAtIGxcbiAgICAgfHwgbzIgPCAwIHx8IG8yID4gbGVuZ3RoIGUyIC0gbFxuICB0aGVuIGludmFsaWRfYXJnIFwiV2Vhay5ibGl0XCJcbiAgZWxzZSBpZiBsIDw+IDAgdGhlbiBibGl0IGUxIG8xIGUyIG8yIGxcblxubGV0IGZpbGwgYXIgb2ZzIGxlbiB4ID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IGxlbmd0aCBhciAtIGxlblxuICB0aGVuIHJhaXNlIChJbnZhbGlkX2FyZ3VtZW50IFwiV2Vhay5maWxsXCIpXG4gIGVsc2UgYmVnaW5cbiAgICBmb3IgaSA9IG9mcyB0byAob2ZzICsgbGVuIC0gMSkgZG9cbiAgICAgIHNldCBhciBpIHhcbiAgICBkb25lXG4gIGVuZFxuXG5cbigqKiBXZWFrIGhhc2ggdGFibGVzICopXG5cbm1vZHVsZSB0eXBlIFMgPSBzaWdcbiAgdHlwZSBkYXRhXG4gIHR5cGUgdFxuICB2YWwgY3JlYXRlIDogaW50IC0+IHRcbiAgdmFsIGNsZWFyIDogdCAtPiB1bml0XG4gIHZhbCBtZXJnZSA6IHQgLT4gZGF0YSAtPiBkYXRhXG4gIHZhbCBhZGQgOiB0IC0+IGRhdGEgLT4gdW5pdFxuICB2YWwgcmVtb3ZlIDogdCAtPiBkYXRhIC0+IHVuaXRcbiAgdmFsIGZpbmQgOiB0IC0+IGRhdGEgLT4gZGF0YVxuICB2YWwgZmluZF9vcHQgOiB0IC0+IGRhdGEgLT4gZGF0YSBvcHRpb25cbiAgdmFsIGZpbmRfYWxsIDogdCAtPiBkYXRhIC0+IGRhdGEgbGlzdFxuICB2YWwgbWVtIDogdCAtPiBkYXRhIC0+IGJvb2xcbiAgdmFsIGl0ZXIgOiAoZGF0YSAtPiB1bml0KSAtPiB0IC0+IHVuaXRcbiAgdmFsIGZvbGQgOiAoZGF0YSAtPiAnYSAtPiAnYSkgLT4gdCAtPiAnYSAtPiAnYVxuICB2YWwgY291bnQgOiB0IC0+IGludFxuICB2YWwgc3RhdHMgOiB0IC0+IGludCAqIGludCAqIGludCAqIGludCAqIGludCAqIGludFxuZW5kXG5cbm1vZHVsZSBNYWtlIChIIDogSGFzaHRibC5IYXNoZWRUeXBlKSA6IChTIHdpdGggdHlwZSBkYXRhID0gSC50KSA9IHN0cnVjdFxuXG4gIHR5cGUgJ2Egd2Vha190ID0gJ2EgdFxuICBsZXQgd2Vha19jcmVhdGUgPSBjcmVhdGVcbiAgbGV0IGVtcHR5YnVja2V0ID0gd2Vha19jcmVhdGUgMFxuXG4gIHR5cGUgZGF0YSA9IEgudFxuXG4gIHR5cGUgdCA9IHtcbiAgICBtdXRhYmxlIHRhYmxlIDogZGF0YSB3ZWFrX3QgYXJyYXk7XG4gICAgbXV0YWJsZSBoYXNoZXMgOiBpbnQgYXJyYXkgYXJyYXk7XG4gICAgbXV0YWJsZSBsaW1pdCA6IGludDsgICAgICAgICAgICAgICAoKiBidWNrZXQgc2l6ZSBsaW1pdCAqKVxuICAgIG11dGFibGUgb3ZlcnNpemUgOiBpbnQ7ICAgICAgICAgICAgKCogbnVtYmVyIG9mIG92ZXJzaXplIGJ1Y2tldHMgKilcbiAgICBtdXRhYmxlIHJvdmVyIDogaW50OyAgICAgICAgICAgICAgICgqIGZvciBpbnRlcm5hbCBib29ra2VlcGluZyAqKVxuICB9XG5cbiAgbGV0IGdldF9pbmRleCB0IGggPSAoaCBsYW5kIG1heF9pbnQpIG1vZCAoQXJyYXkubGVuZ3RoIHQudGFibGUpXG5cbiAgbGV0IGxpbWl0ID0gN1xuICBsZXQgb3Zlcl9saW1pdCA9IDJcblxuICBsZXQgY3JlYXRlIHN6ID1cbiAgICBsZXQgc3ogPSBpZiBzeiA8IDcgdGhlbiA3IGVsc2Ugc3ogaW5cbiAgICBsZXQgc3ogPSBpZiBzeiA+IFN5cy5tYXhfYXJyYXlfbGVuZ3RoIHRoZW4gU3lzLm1heF9hcnJheV9sZW5ndGggZWxzZSBzeiBpblxuICAgIHtcbiAgICAgIHRhYmxlID0gQXJyYXkubWFrZSBzeiBlbXB0eWJ1Y2tldDtcbiAgICAgIGhhc2hlcyA9IEFycmF5Lm1ha2Ugc3ogW3wgfF07XG4gICAgICBsaW1pdCA9IGxpbWl0O1xuICAgICAgb3ZlcnNpemUgPSAwO1xuICAgICAgcm92ZXIgPSAwO1xuICAgIH1cblxuICBsZXQgY2xlYXIgdCA9XG4gICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCB0LnRhYmxlIC0gMSBkb1xuICAgICAgdC50YWJsZS4oaSkgPC0gZW1wdHlidWNrZXQ7XG4gICAgICB0Lmhhc2hlcy4oaSkgPC0gW3wgfF07XG4gICAgZG9uZTtcbiAgICB0LmxpbWl0IDwtIGxpbWl0O1xuICAgIHQub3ZlcnNpemUgPC0gMFxuXG5cbiAgbGV0IGZvbGQgZiB0IGluaXQgPVxuICAgIGxldCByZWMgZm9sZF9idWNrZXQgaSBiIGFjY3UgPVxuICAgICAgaWYgaSA+PSBsZW5ndGggYiB0aGVuIGFjY3UgZWxzZVxuICAgICAgbWF0Y2ggZ2V0IGIgaSB3aXRoXG4gICAgICB8IFNvbWUgdiAtPiBmb2xkX2J1Y2tldCAoaSsxKSBiIChmIHYgYWNjdSlcbiAgICAgIHwgTm9uZSAtPiBmb2xkX2J1Y2tldCAoaSsxKSBiIGFjY3VcbiAgICBpblxuICAgIEFycmF5LmZvbGRfcmlnaHQgKGZvbGRfYnVja2V0IDApIHQudGFibGUgaW5pdFxuXG5cbiAgbGV0IGl0ZXIgZiB0ID1cbiAgICBsZXQgcmVjIGl0ZXJfYnVja2V0IGkgYiA9XG4gICAgICBpZiBpID49IGxlbmd0aCBiIHRoZW4gKCkgZWxzZVxuICAgICAgbWF0Y2ggZ2V0IGIgaSB3aXRoXG4gICAgICB8IFNvbWUgdiAtPiBmIHY7IGl0ZXJfYnVja2V0IChpKzEpIGJcbiAgICAgIHwgTm9uZSAtPiBpdGVyX2J1Y2tldCAoaSsxKSBiXG4gICAgaW5cbiAgICBBcnJheS5pdGVyIChpdGVyX2J1Y2tldCAwKSB0LnRhYmxlXG5cblxuICBsZXQgaXRlcl93ZWFrIGYgdCA9XG4gICAgbGV0IHJlYyBpdGVyX2J1Y2tldCBpIGogYiA9XG4gICAgICBpZiBpID49IGxlbmd0aCBiIHRoZW4gKCkgZWxzZVxuICAgICAgbWF0Y2ggY2hlY2sgYiBpIHdpdGhcbiAgICAgIHwgdHJ1ZSAtPiBmIGIgdC5oYXNoZXMuKGopIGk7IGl0ZXJfYnVja2V0IChpKzEpIGogYlxuICAgICAgfCBmYWxzZSAtPiBpdGVyX2J1Y2tldCAoaSsxKSBqIGJcbiAgICBpblxuICAgIEFycmF5Lml0ZXJpIChpdGVyX2J1Y2tldCAwKSB0LnRhYmxlXG5cblxuICBsZXQgcmVjIGNvdW50X2J1Y2tldCBpIGIgYWNjdSA9XG4gICAgaWYgaSA+PSBsZW5ndGggYiB0aGVuIGFjY3UgZWxzZVxuICAgIGNvdW50X2J1Y2tldCAoaSsxKSBiIChhY2N1ICsgKGlmIGNoZWNrIGIgaSB0aGVuIDEgZWxzZSAwKSlcblxuXG4gIGxldCBjb3VudCB0ID1cbiAgICBBcnJheS5mb2xkX3JpZ2h0IChjb3VudF9idWNrZXQgMCkgdC50YWJsZSAwXG5cblxuICBsZXQgbmV4dF9zeiBuID0gbWluICgzICogbiAvIDIgKyAzKSBTeXMubWF4X2FycmF5X2xlbmd0aFxuICBsZXQgcHJldl9zeiBuID0gKChuIC0gMykgKiAyICsgMikgLyAzXG5cbiAgbGV0IHRlc3Rfc2hyaW5rX2J1Y2tldCB0ID1cbiAgICBsZXQgYnVja2V0ID0gdC50YWJsZS4odC5yb3ZlcikgaW5cbiAgICBsZXQgaGJ1Y2tldCA9IHQuaGFzaGVzLih0LnJvdmVyKSBpblxuICAgIGxldCBsZW4gPSBsZW5ndGggYnVja2V0IGluXG4gICAgbGV0IHByZXZfbGVuID0gcHJldl9zeiBsZW4gaW5cbiAgICBsZXQgbGl2ZSA9IGNvdW50X2J1Y2tldCAwIGJ1Y2tldCAwIGluXG4gICAgaWYgbGl2ZSA8PSBwcmV2X2xlbiB0aGVuIGJlZ2luXG4gICAgICBsZXQgcmVjIGxvb3AgaSBqID1cbiAgICAgICAgaWYgaiA+PSBwcmV2X2xlbiB0aGVuIGJlZ2luXG4gICAgICAgICAgaWYgY2hlY2sgYnVja2V0IGkgdGhlbiBsb29wIChpICsgMSkgalxuICAgICAgICAgIGVsc2UgaWYgY2hlY2sgYnVja2V0IGogdGhlbiBiZWdpblxuICAgICAgICAgICAgYmxpdCBidWNrZXQgaiBidWNrZXQgaSAxO1xuICAgICAgICAgICAgaGJ1Y2tldC4oaSkgPC0gaGJ1Y2tldC4oaik7XG4gICAgICAgICAgICBsb29wIChpICsgMSkgKGogLSAxKTtcbiAgICAgICAgICBlbmQgZWxzZSBsb29wIGkgKGogLSAxKTtcbiAgICAgICAgZW5kO1xuICAgICAgaW5cbiAgICAgIGxvb3AgMCAobGVuZ3RoIGJ1Y2tldCAtIDEpO1xuICAgICAgaWYgcHJldl9sZW4gPSAwIHRoZW4gYmVnaW5cbiAgICAgICAgdC50YWJsZS4odC5yb3ZlcikgPC0gZW1wdHlidWNrZXQ7XG4gICAgICAgIHQuaGFzaGVzLih0LnJvdmVyKSA8LSBbfCB8XTtcbiAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgIGxldCBuZXdidWNrZXQgPSB3ZWFrX2NyZWF0ZSBwcmV2X2xlbiBpblxuICAgICAgICBibGl0IGJ1Y2tldCAwIG5ld2J1Y2tldCAwIHByZXZfbGVuO1xuICAgICAgICB0LnRhYmxlLih0LnJvdmVyKSA8LSBuZXdidWNrZXQ7XG4gICAgICAgIHQuaGFzaGVzLih0LnJvdmVyKSA8LSBBcnJheS5zdWIgaGJ1Y2tldCAwIHByZXZfbGVuXG4gICAgICBlbmQ7XG4gICAgICBpZiBsZW4gPiB0LmxpbWl0ICYmIHByZXZfbGVuIDw9IHQubGltaXQgdGhlbiB0Lm92ZXJzaXplIDwtIHQub3ZlcnNpemUgLSAxO1xuICAgIGVuZDtcbiAgICB0LnJvdmVyIDwtICh0LnJvdmVyICsgMSkgbW9kIChBcnJheS5sZW5ndGggdC50YWJsZSlcblxuXG4gIGxldCByZWMgcmVzaXplIHQgPVxuICAgIGxldCBvbGRsZW4gPSBBcnJheS5sZW5ndGggdC50YWJsZSBpblxuICAgIGxldCBuZXdsZW4gPSBuZXh0X3N6IG9sZGxlbiBpblxuICAgIGlmIG5ld2xlbiA+IG9sZGxlbiB0aGVuIGJlZ2luXG4gICAgICBsZXQgbmV3dCA9IGNyZWF0ZSBuZXdsZW4gaW5cbiAgICAgIGxldCBhZGRfd2VhayBvYiBvaCBvaSA9XG4gICAgICAgIGxldCBzZXR0ZXIgbmIgbmkgXyA9IGJsaXQgb2Igb2kgbmIgbmkgMSBpblxuICAgICAgICBsZXQgaCA9IG9oLihvaSkgaW5cbiAgICAgICAgYWRkX2F1eCBuZXd0IHNldHRlciBOb25lIGggKGdldF9pbmRleCBuZXd0IGgpO1xuICAgICAgaW5cbiAgICAgIGl0ZXJfd2VhayBhZGRfd2VhayB0O1xuICAgICAgdC50YWJsZSA8LSBuZXd0LnRhYmxlO1xuICAgICAgdC5oYXNoZXMgPC0gbmV3dC5oYXNoZXM7XG4gICAgICB0LmxpbWl0IDwtIG5ld3QubGltaXQ7XG4gICAgICB0Lm92ZXJzaXplIDwtIG5ld3Qub3ZlcnNpemU7XG4gICAgICB0LnJvdmVyIDwtIHQucm92ZXIgbW9kIEFycmF5Lmxlbmd0aCBuZXd0LnRhYmxlO1xuICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICB0LmxpbWl0IDwtIG1heF9pbnQ7ICAgICAgICAgICAgICgqIG1heGltdW0gc2l6ZSBhbHJlYWR5IHJlYWNoZWQgKilcbiAgICAgIHQub3ZlcnNpemUgPC0gMDtcbiAgICBlbmRcblxuICBhbmQgYWRkX2F1eCB0IHNldHRlciBkIGggaW5kZXggPVxuICAgIGxldCBidWNrZXQgPSB0LnRhYmxlLihpbmRleCkgaW5cbiAgICBsZXQgaGFzaGVzID0gdC5oYXNoZXMuKGluZGV4KSBpblxuICAgIGxldCBzeiA9IGxlbmd0aCBidWNrZXQgaW5cbiAgICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgICBpZiBpID49IHN6IHRoZW4gYmVnaW5cbiAgICAgICAgbGV0IG5ld3N6ID1cbiAgICAgICAgICBtaW4gKDMgKiBzeiAvIDIgKyAzKSAoU3lzLm1heF9hcnJheV9sZW5ndGggLSBhZGRpdGlvbmFsX3ZhbHVlcylcbiAgICAgICAgaW5cbiAgICAgICAgaWYgbmV3c3ogPD0gc3ogdGhlbiBmYWlsd2l0aCBcIldlYWsuTWFrZTogaGFzaCBidWNrZXQgY2Fubm90IGdyb3cgbW9yZVwiO1xuICAgICAgICBsZXQgbmV3YnVja2V0ID0gd2Vha19jcmVhdGUgbmV3c3ogaW5cbiAgICAgICAgbGV0IG5ld2hhc2hlcyA9IEFycmF5Lm1ha2UgbmV3c3ogMCBpblxuICAgICAgICBibGl0IGJ1Y2tldCAwIG5ld2J1Y2tldCAwIHN6O1xuICAgICAgICBBcnJheS5ibGl0IGhhc2hlcyAwIG5ld2hhc2hlcyAwIHN6O1xuICAgICAgICBzZXR0ZXIgbmV3YnVja2V0IHN6IGQ7XG4gICAgICAgIG5ld2hhc2hlcy4oc3opIDwtIGg7XG4gICAgICAgIHQudGFibGUuKGluZGV4KSA8LSBuZXdidWNrZXQ7XG4gICAgICAgIHQuaGFzaGVzLihpbmRleCkgPC0gbmV3aGFzaGVzO1xuICAgICAgICBpZiBzeiA8PSB0LmxpbWl0ICYmIG5ld3N6ID4gdC5saW1pdCB0aGVuIGJlZ2luXG4gICAgICAgICAgdC5vdmVyc2l6ZSA8LSB0Lm92ZXJzaXplICsgMTtcbiAgICAgICAgICBmb3IgX2kgPSAwIHRvIG92ZXJfbGltaXQgZG8gdGVzdF9zaHJpbmtfYnVja2V0IHQgZG9uZTtcbiAgICAgICAgZW5kO1xuICAgICAgICBpZiB0Lm92ZXJzaXplID4gQXJyYXkubGVuZ3RoIHQudGFibGUgLyBvdmVyX2xpbWl0IHRoZW4gcmVzaXplIHQ7XG4gICAgICBlbmQgZWxzZSBpZiBjaGVjayBidWNrZXQgaSB0aGVuIGJlZ2luXG4gICAgICAgIGxvb3AgKGkgKyAxKVxuICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgc2V0dGVyIGJ1Y2tldCBpIGQ7XG4gICAgICAgIGhhc2hlcy4oaSkgPC0gaDtcbiAgICAgIGVuZDtcbiAgICBpblxuICAgIGxvb3AgMFxuXG5cbiAgbGV0IGFkZCB0IGQgPVxuICAgIGxldCBoID0gSC5oYXNoIGQgaW5cbiAgICBhZGRfYXV4IHQgc2V0IChTb21lIGQpIGggKGdldF9pbmRleCB0IGgpXG5cblxuICBsZXQgZmluZF9vciB0IGQgaWZub3Rmb3VuZCA9XG4gICAgbGV0IGggPSBILmhhc2ggZCBpblxuICAgIGxldCBpbmRleCA9IGdldF9pbmRleCB0IGggaW5cbiAgICBsZXQgYnVja2V0ID0gdC50YWJsZS4oaW5kZXgpIGluXG4gICAgbGV0IGhhc2hlcyA9IHQuaGFzaGVzLihpbmRleCkgaW5cbiAgICBsZXQgc3ogPSBsZW5ndGggYnVja2V0IGluXG4gICAgbGV0IHJlYyBsb29wIGkgPVxuICAgICAgaWYgaSA+PSBzeiB0aGVuIGlmbm90Zm91bmQgaCBpbmRleFxuICAgICAgZWxzZSBpZiBoID0gaGFzaGVzLihpKSB0aGVuIGJlZ2luXG4gICAgICAgIG1hdGNoIGdldF9jb3B5IGJ1Y2tldCBpIHdpdGhcbiAgICAgICAgfCBTb21lIHYgd2hlbiBILmVxdWFsIHYgZFxuICAgICAgICAgICAtPiBiZWdpbiBtYXRjaCBnZXQgYnVja2V0IGkgd2l0aFxuICAgICAgICAgICAgICB8IFNvbWUgdiAtPiB2XG4gICAgICAgICAgICAgIHwgTm9uZSAtPiBsb29wIChpICsgMSlcbiAgICAgICAgICAgICAgZW5kXG4gICAgICAgIHwgXyAtPiBsb29wIChpICsgMSlcbiAgICAgIGVuZCBlbHNlIGxvb3AgKGkgKyAxKVxuICAgIGluXG4gICAgbG9vcCAwXG5cblxuICBsZXQgbWVyZ2UgdCBkID1cbiAgICBmaW5kX29yIHQgZCAoZnVuIGggaW5kZXggLT4gYWRkX2F1eCB0IHNldCAoU29tZSBkKSBoIGluZGV4OyBkKVxuXG5cbiAgbGV0IGZpbmQgdCBkID0gZmluZF9vciB0IGQgKGZ1biBfaCBfaW5kZXggLT4gcmFpc2UgTm90X2ZvdW5kKVxuXG4gIGxldCBmaW5kX29wdCB0IGQgPVxuICAgIGxldCBoID0gSC5oYXNoIGQgaW5cbiAgICBsZXQgaW5kZXggPSBnZXRfaW5kZXggdCBoIGluXG4gICAgbGV0IGJ1Y2tldCA9IHQudGFibGUuKGluZGV4KSBpblxuICAgIGxldCBoYXNoZXMgPSB0Lmhhc2hlcy4oaW5kZXgpIGluXG4gICAgbGV0IHN6ID0gbGVuZ3RoIGJ1Y2tldCBpblxuICAgIGxldCByZWMgbG9vcCBpID1cbiAgICAgIGlmIGkgPj0gc3ogdGhlbiBOb25lXG4gICAgICBlbHNlIGlmIGggPSBoYXNoZXMuKGkpIHRoZW4gYmVnaW5cbiAgICAgICAgbWF0Y2ggZ2V0X2NvcHkgYnVja2V0IGkgd2l0aFxuICAgICAgICB8IFNvbWUgdiB3aGVuIEguZXF1YWwgdiBkXG4gICAgICAgICAgIC0+IGJlZ2luIG1hdGNoIGdldCBidWNrZXQgaSB3aXRoXG4gICAgICAgICAgICAgIHwgU29tZSBfIGFzIHYgLT4gdlxuICAgICAgICAgICAgICB8IE5vbmUgLT4gbG9vcCAoaSArIDEpXG4gICAgICAgICAgICAgIGVuZFxuICAgICAgICB8IF8gLT4gbG9vcCAoaSArIDEpXG4gICAgICBlbmQgZWxzZSBsb29wIChpICsgMSlcbiAgICBpblxuICAgIGxvb3AgMFxuXG5cbiAgbGV0IGZpbmRfc2hhZG93IHQgZCBpZmZvdW5kIGlmbm90Zm91bmQgPVxuICAgIGxldCBoID0gSC5oYXNoIGQgaW5cbiAgICBsZXQgaW5kZXggPSBnZXRfaW5kZXggdCBoIGluXG4gICAgbGV0IGJ1Y2tldCA9IHQudGFibGUuKGluZGV4KSBpblxuICAgIGxldCBoYXNoZXMgPSB0Lmhhc2hlcy4oaW5kZXgpIGluXG4gICAgbGV0IHN6ID0gbGVuZ3RoIGJ1Y2tldCBpblxuICAgIGxldCByZWMgbG9vcCBpID1cbiAgICAgIGlmIGkgPj0gc3ogdGhlbiBpZm5vdGZvdW5kXG4gICAgICBlbHNlIGlmIGggPSBoYXNoZXMuKGkpIHRoZW4gYmVnaW5cbiAgICAgICAgbWF0Y2ggZ2V0X2NvcHkgYnVja2V0IGkgd2l0aFxuICAgICAgICB8IFNvbWUgdiB3aGVuIEguZXF1YWwgdiBkIC0+IGlmZm91bmQgYnVja2V0IGlcbiAgICAgICAgfCBfIC0+IGxvb3AgKGkgKyAxKVxuICAgICAgZW5kIGVsc2UgbG9vcCAoaSArIDEpXG4gICAgaW5cbiAgICBsb29wIDBcblxuXG4gIGxldCByZW1vdmUgdCBkID0gZmluZF9zaGFkb3cgdCBkIChmdW4gdyBpIC0+IHNldCB3IGkgTm9uZSkgKClcblxuXG4gIGxldCBtZW0gdCBkID0gZmluZF9zaGFkb3cgdCBkIChmdW4gX3cgX2kgLT4gdHJ1ZSkgZmFsc2VcblxuXG4gIGxldCBmaW5kX2FsbCB0IGQgPVxuICAgIGxldCBoID0gSC5oYXNoIGQgaW5cbiAgICBsZXQgaW5kZXggPSBnZXRfaW5kZXggdCBoIGluXG4gICAgbGV0IGJ1Y2tldCA9IHQudGFibGUuKGluZGV4KSBpblxuICAgIGxldCBoYXNoZXMgPSB0Lmhhc2hlcy4oaW5kZXgpIGluXG4gICAgbGV0IHN6ID0gbGVuZ3RoIGJ1Y2tldCBpblxuICAgIGxldCByZWMgbG9vcCBpIGFjY3UgPVxuICAgICAgaWYgaSA+PSBzeiB0aGVuIGFjY3VcbiAgICAgIGVsc2UgaWYgaCA9IGhhc2hlcy4oaSkgdGhlbiBiZWdpblxuICAgICAgICBtYXRjaCBnZXRfY29weSBidWNrZXQgaSB3aXRoXG4gICAgICAgIHwgU29tZSB2IHdoZW4gSC5lcXVhbCB2IGRcbiAgICAgICAgICAgLT4gYmVnaW4gbWF0Y2ggZ2V0IGJ1Y2tldCBpIHdpdGhcbiAgICAgICAgICAgICAgfCBTb21lIHYgLT4gbG9vcCAoaSArIDEpICh2IDo6IGFjY3UpXG4gICAgICAgICAgICAgIHwgTm9uZSAtPiBsb29wIChpICsgMSkgYWNjdVxuICAgICAgICAgICAgICBlbmRcbiAgICAgICAgfCBfIC0+IGxvb3AgKGkgKyAxKSBhY2N1XG4gICAgICBlbmQgZWxzZSBsb29wIChpICsgMSkgYWNjdVxuICAgIGluXG4gICAgbG9vcCAwIFtdXG5cblxuICBsZXQgc3RhdHMgdCA9XG4gICAgbGV0IGxlbiA9IEFycmF5Lmxlbmd0aCB0LnRhYmxlIGluXG4gICAgbGV0IGxlbnMgPSBBcnJheS5tYXAgbGVuZ3RoIHQudGFibGUgaW5cbiAgICBBcnJheS5zb3J0IGNvbXBhcmUgbGVucztcbiAgICBsZXQgdG90bGVuID0gQXJyYXkuZm9sZF9sZWZ0ICggKyApIDAgbGVucyBpblxuICAgIChsZW4sIGNvdW50IHQsIHRvdGxlbiwgbGVucy4oMCksIGxlbnMuKGxlbi8yKSwgbGVucy4obGVuLTEpKVxuXG5cbmVuZFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgUGllcnJlIFdlaXMsIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBBIHByZXR0eS1wcmludGluZyBmYWNpbGl0eSBhbmQgZGVmaW5pdGlvbiBvZiBmb3JtYXR0ZXJzIGZvciAncGFyYWxsZWwnXG4gICAoaS5lLiB1bnJlbGF0ZWQgb3IgaW5kZXBlbmRlbnQpIHByZXR0eS1wcmludGluZyBvbiBtdWx0aXBsZSBvdXQgY2hhbm5lbHMuICopXG5cbigqXG4gICBUaGUgcHJldHR5LXByaW50aW5nIGVuZ2luZSBpbnRlcm5hbCBkYXRhIHN0cnVjdHVyZXMuXG4qKVxuXG5sZXQgaWQgeCA9IHhcblxuKCogQSBkZXZvdGVkIHR5cGUgZm9yIHNpemVzIHRvIGF2b2lkIGNvbmZ1c2lvblxuICAgYmV0d2VlbiBzaXplcyBhbmQgbWVyZSBpbnRlZ2Vycy4gKilcbm1vZHVsZSBTaXplIDogc2lnXG4gIHR5cGUgdFxuXG4gIHZhbCB0b19pbnQgOiB0IC0+IGludFxuICB2YWwgb2ZfaW50IDogaW50IC0+IHRcbiAgdmFsIHplcm8gOiB0XG4gIHZhbCB1bmtub3duIDogdFxuICB2YWwgaXNfa25vd24gOiB0IC0+IGJvb2xcbmVuZCAgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gaW50XG5cbiAgbGV0IHRvX2ludCA9IGlkXG4gIGxldCBvZl9pbnQgPSBpZFxuICBsZXQgemVybyA9IDBcbiAgbGV0IHVua25vd24gPSAtMVxuICBsZXQgaXNfa25vd24gbiA9IG4gPj0gMFxuZW5kXG5cblxuXG4oKiBUaGUgcHJldHR5LXByaW50aW5nIGJveGVzIGRlZmluaXRpb246XG4gICBhIHByZXR0eS1wcmludGluZyBib3ggaXMgZWl0aGVyXG4gICAtIGhib3g6IGhvcml6b250YWwgYm94IChubyBsaW5lIHNwbGl0dGluZylcbiAgIC0gdmJveDogdmVydGljYWwgYm94IChldmVyeSBicmVhayBoaW50IHNwbGl0cyB0aGUgbGluZSlcbiAgIC0gaHZib3g6IGhvcml6b250YWwvdmVydGljYWwgYm94XG4gICAgICh0aGUgYm94IGJlaGF2ZXMgYXMgYW4gaG9yaXpvbnRhbCBib3ggaWYgaXQgZml0cyBvblxuICAgICAgdGhlIGN1cnJlbnQgbGluZSwgb3RoZXJ3aXNlIHRoZSBib3ggYmVoYXZlcyBhcyBhIHZlcnRpY2FsIGJveClcbiAgIC0gaG92Ym94OiBob3Jpem9udGFsIG9yIHZlcnRpY2FsIGNvbXBhY3RpbmcgYm94XG4gICAgICh0aGUgYm94IGlzIGNvbXBhY3RpbmcgbWF0ZXJpYWwsIHByaW50aW5nIGFzIG11Y2ggbWF0ZXJpYWwgYXMgcG9zc2libGVcbiAgICAgIG9uIGV2ZXJ5IGxpbmVzKVxuICAgLSBib3g6IGhvcml6b250YWwgb3IgdmVydGljYWwgY29tcGFjdGluZyBib3ggd2l0aCBlbmhhbmNlZCBib3ggc3RydWN0dXJlXG4gICAgICh0aGUgYm94IGJlaGF2ZXMgYXMgYW4gaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbCBib3ggYnV0IGJyZWFrIGhpbnRzIHNwbGl0XG4gICAgICB0aGUgbGluZSBpZiBzcGxpdHRpbmcgd291bGQgbW92ZSB0byB0aGUgbGVmdClcbiopXG50eXBlIGJveF90eXBlID0gQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzLmJsb2NrX3R5cGUgPVxuICB8IFBwX2hib3ggfCBQcF92Ym94IHwgUHBfaHZib3ggfCBQcF9ob3Zib3ggfCBQcF9ib3ggfCBQcF9maXRzXG5cblxuKCogVGhlIHByZXR0eS1wcmludGluZyB0b2tlbnMgZGVmaW5pdGlvbjpcbiAgIGFyZSBlaXRoZXIgdGV4dCB0byBwcmludCBvciBwcmV0dHkgcHJpbnRpbmdcbiAgIGVsZW1lbnRzIHRoYXQgZHJpdmUgaW5kZW50YXRpb24gYW5kIGxpbmUgc3BsaXR0aW5nLiAqKVxudHlwZSBwcF90b2tlbiA9XG4gIHwgUHBfdGV4dCBvZiBzdHJpbmcgICAgICAgICAgKCogbm9ybWFsIHRleHQgKilcbiAgfCBQcF9icmVhayBvZiB7ICAgICAgICAgICAgICAoKiBjb21wbGV0ZSBicmVhayAqKVxuICAgICAgZml0czogc3RyaW5nICogaW50ICogc3RyaW5nOyAgICgqIGxpbmUgaXMgbm90IHNwbGl0ICopXG4gICAgICBicmVha3M6IHN0cmluZyAqIGludCAqIHN0cmluZzsgKCogbGluZSBpcyBzcGxpdCAqKVxuICAgIH1cbiAgfCBQcF90YnJlYWsgb2YgaW50ICogaW50ICAgICAoKiBnbyB0byBuZXh0IHRhYnVsYXRpb24gKilcbiAgfCBQcF9zdGFiICAgICAgICAgICAgICAgICAgICAoKiBzZXQgYSB0YWJ1bGF0aW9uICopXG4gIHwgUHBfYmVnaW4gb2YgaW50ICogYm94X3R5cGUgKCogYmVnaW5uaW5nIG9mIGEgYm94ICopXG4gIHwgUHBfZW5kICAgICAgICAgICAgICAgICAgICAgKCogZW5kIG9mIGEgYm94ICopXG4gIHwgUHBfdGJlZ2luIG9mIHRib3ggICAgICAgICAgKCogYmVnaW5uaW5nIG9mIGEgdGFidWxhdGlvbiBib3ggKilcbiAgfCBQcF90ZW5kICAgICAgICAgICAgICAgICAgICAoKiBlbmQgb2YgYSB0YWJ1bGF0aW9uIGJveCAqKVxuICB8IFBwX25ld2xpbmUgICAgICAgICAgICAgICAgICgqIHRvIGZvcmNlIGEgbmV3bGluZSBpbnNpZGUgYSBib3ggKilcbiAgfCBQcF9pZl9uZXdsaW5lICAgICAgICAgICAgICAoKiB0byBkbyBzb21ldGhpbmcgb25seSBpZiB0aGlzIHZlcnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lIGhhcyBiZWVuIGJyb2tlbiAqKVxuICB8IFBwX29wZW5fdGFnIG9mIHN0YWcgICAgICAgICAoKiBvcGVuaW5nIGEgdGFnIG5hbWUgKilcbiAgfCBQcF9jbG9zZV90YWcgICAgICAgICAgICAgICAoKiBjbG9zaW5nIHRoZSBtb3N0IHJlY2VudGx5IG9wZW4gdGFnICopXG5cbmFuZCBzdGFnID0gLi5cblxuYW5kIHRib3ggPSBQcF90Ym94IG9mIGludCBsaXN0IHJlZiAgKCogVGFidWxhdGlvbiBib3ggKilcblxudHlwZSB0YWcgPSBzdHJpbmdcbnR5cGUgc3RhZyArPSBTdHJpbmdfdGFnIG9mIHRhZ1xuXG5cbigqIFRoZSBwcmV0dHktcHJpbnRlciBxdWV1ZTpcbiAgIHByZXR0eS1wcmludGluZyBtYXRlcmlhbCBpcyBub3Qgd3JpdHRlbiBpbiB0aGUgb3V0cHV0IGFzIHNvb24gYXMgZW1pdHRlZDtcbiAgIGluc3RlYWQsIHRoZSBtYXRlcmlhbCBpcyBzaW1wbHkgcmVjb3JkZWQgaW4gdGhlIHByZXR0eS1wcmludGVyIHF1ZXVlLFxuICAgdW50aWwgdGhlIGVuY2xvc2luZyBib3ggaGFzIGEga25vd24gY29tcHV0ZWQgc2l6ZSBhbmQgcHJvcGVyIHNwbGl0dGluZ1xuICAgZGVjaXNpb25zIGNhbiBiZSBtYWRlLlxuXG4gICBUaGUgcHJldHR5LXByaW50ZXIgcXVldWUgY29udGFpbnMgZm9ybWF0dGluZyBlbGVtZW50cyB0byBiZSBwcmludGVkLlxuICAgRWFjaCBmb3JtYXR0aW5nIGVsZW1lbnQgaXMgYSB0dXBsZSAoc2l6ZSwgdG9rZW4sIGxlbmd0aCksIHdoZXJlXG4gICAtIGxlbmd0aCBpcyB0aGUgZGVjbGFyZWQgbGVuZ3RoIG9mIHRoZSB0b2tlbixcbiAgIC0gc2l6ZSBpcyBlZmZlY3RpdmUgc2l6ZSBvZiB0aGUgdG9rZW4gd2hlbiBpdCBpcyBwcmludGVkXG4gICAgIChzaXplIGlzIHNldCB3aGVuIHRoZSBzaXplIG9mIHRoZSBib3ggaXMga25vd24sIHNvIHRoYXQgc2l6ZSBvZiBicmVha1xuICAgICAgaGludHMgYXJlIGRlZmluaXRpdmUpLiAqKVxudHlwZSBwcF9xdWV1ZV9lbGVtID0ge1xuICBtdXRhYmxlIHNpemUgOiBTaXplLnQ7XG4gIHRva2VuIDogcHBfdG9rZW47XG4gIGxlbmd0aCA6IGludDtcbn1cblxuXG4oKiBUaGUgcHJldHR5LXByaW50ZXIgcXVldWUgZGVmaW5pdGlvbi4gKilcbnR5cGUgcHBfcXVldWUgPSBwcF9xdWV1ZV9lbGVtIFF1ZXVlLnRcblxuKCogVGhlIHByZXR0eS1wcmludGVyIHNjYW5uaW5nIHN0YWNrLiAqKVxuXG4oKiBUaGUgcHJldHR5LXByaW50ZXIgc2Nhbm5pbmcgc3RhY2s6IHNjYW5uaW5nIGVsZW1lbnQgZGVmaW5pdGlvbi4gKilcbnR5cGUgcHBfc2Nhbl9lbGVtID0ge1xuICBsZWZ0X3RvdGFsIDogaW50OyAoKiBWYWx1ZSBvZiBwcF9sZWZ0X3RvdGFsIHdoZW4gdGhlIGVsZW1lbnQgd2FzIGVucXVldWVkLiAqKVxuICBxdWV1ZV9lbGVtIDogcHBfcXVldWVfZWxlbVxufVxuXG4oKiBUaGUgcHJldHR5LXByaW50ZXIgZm9ybWF0dGluZyBzdGFjazpcbiAgIHRoZSBmb3JtYXR0aW5nIHN0YWNrIGNvbnRhaW5zIHRoZSBkZXNjcmlwdGlvbiBvZiBhbGwgdGhlIGN1cnJlbnRseSBhY3RpdmVcbiAgIGJveGVzOyB0aGUgcHJldHR5LXByaW50ZXIgZm9ybWF0dGluZyBzdGFjayBpcyB1c2VkIHRvIHNwbGl0IHRoZSBsaW5lc1xuICAgd2hpbGUgcHJpbnRpbmcgdG9rZW5zLiAqKVxuXG4oKiBUaGUgcHJldHR5LXByaW50ZXIgZm9ybWF0dGluZyBzdGFjazogZm9ybWF0dGluZyBzdGFjayBlbGVtZW50IGRlZmluaXRpb24uXG4gICBFYWNoIHN0YWNrIGVsZW1lbnQgZGVzY3JpYmVzIGEgcHJldHR5LXByaW50aW5nIGJveC4gKilcbnR5cGUgcHBfZm9ybWF0X2VsZW0gPSB7IGJveF90eXBlIDogYm94X3R5cGU7IHdpZHRoIDogaW50IH1cblxuKCogVGhlIGZvcm1hdHRlciBkZWZpbml0aW9uLlxuICAgRWFjaCBmb3JtYXR0ZXIgdmFsdWUgaXMgYSBwcmV0dHktcHJpbnRlciBpbnN0YW5jZSB3aXRoIGFsbCBpdHNcbiAgIG1hY2hpbmVyeS4gKilcbnR5cGUgZm9ybWF0dGVyID0ge1xuICAoKiBUaGUgcHJldHR5LXByaW50ZXIgc2Nhbm5pbmcgc3RhY2suICopXG4gIHBwX3NjYW5fc3RhY2sgOiBwcF9zY2FuX2VsZW0gU3RhY2sudDtcbiAgKCogVGhlIHByZXR0eS1wcmludGVyIGZvcm1hdHRpbmcgc3RhY2suICopXG4gIHBwX2Zvcm1hdF9zdGFjayA6IHBwX2Zvcm1hdF9lbGVtIFN0YWNrLnQ7XG4gIHBwX3Rib3hfc3RhY2sgOiB0Ym94IFN0YWNrLnQ7XG4gICgqIFRoZSBwcmV0dHktcHJpbnRlciBzZW1hbnRpY3MgdGFnIHN0YWNrLiAqKVxuICBwcF90YWdfc3RhY2sgOiBzdGFnIFN0YWNrLnQ7XG4gIHBwX21hcmtfc3RhY2sgOiBzdGFnIFN0YWNrLnQ7XG4gICgqIFZhbHVlIG9mIHJpZ2h0IG1hcmdpbi4gKilcbiAgbXV0YWJsZSBwcF9tYXJnaW4gOiBpbnQ7XG4gICgqIE1pbmltYWwgc3BhY2UgbGVmdCBiZWZvcmUgbWFyZ2luLCB3aGVuIG9wZW5pbmcgYSBib3guICopXG4gIG11dGFibGUgcHBfbWluX3NwYWNlX2xlZnQgOiBpbnQ7XG4gICgqIE1heGltdW0gdmFsdWUgb2YgaW5kZW50YXRpb246XG4gICAgIG5vIGJveCBjYW4gYmUgb3BlbmVkIGZ1cnRoZXIuICopXG4gIG11dGFibGUgcHBfbWF4X2luZGVudCA6IGludDtcbiAgKCogU3BhY2UgcmVtYWluaW5nIG9uIHRoZSBjdXJyZW50IGxpbmUuICopXG4gIG11dGFibGUgcHBfc3BhY2VfbGVmdCA6IGludDtcbiAgKCogQ3VycmVudCB2YWx1ZSBvZiBpbmRlbnRhdGlvbi4gKilcbiAgbXV0YWJsZSBwcF9jdXJyZW50X2luZGVudCA6IGludDtcbiAgKCogVHJ1ZSB3aGVuIHRoZSBsaW5lIGhhcyBiZWVuIGJyb2tlbiBieSB0aGUgcHJldHR5LXByaW50ZXIuICopXG4gIG11dGFibGUgcHBfaXNfbmV3X2xpbmUgOiBib29sO1xuICAoKiBUb3RhbCB3aWR0aCBvZiB0b2tlbnMgYWxyZWFkeSBwcmludGVkLiAqKVxuICBtdXRhYmxlIHBwX2xlZnRfdG90YWwgOiBpbnQ7XG4gICgqIFRvdGFsIHdpZHRoIG9mIHRva2VucyBldmVyIHB1dCBpbiBxdWV1ZS4gKilcbiAgbXV0YWJsZSBwcF9yaWdodF90b3RhbCA6IGludDtcbiAgKCogQ3VycmVudCBudW1iZXIgb2Ygb3BlbiBib3hlcy4gKilcbiAgbXV0YWJsZSBwcF9jdXJyX2RlcHRoIDogaW50O1xuICAoKiBNYXhpbXVtIG51bWJlciBvZiBib3hlcyB3aGljaCBjYW4gYmUgc2ltdWx0YW5lb3VzbHkgb3Blbi4gKilcbiAgbXV0YWJsZSBwcF9tYXhfYm94ZXMgOiBpbnQ7XG4gICgqIEVsbGlwc2lzIHN0cmluZy4gKilcbiAgbXV0YWJsZSBwcF9lbGxpcHNpcyA6IHN0cmluZztcbiAgKCogT3V0cHV0IGZ1bmN0aW9uLiAqKVxuICBtdXRhYmxlIHBwX291dF9zdHJpbmcgOiBzdHJpbmcgLT4gaW50IC0+IGludCAtPiB1bml0O1xuICAoKiBGbHVzaGluZyBmdW5jdGlvbi4gKilcbiAgbXV0YWJsZSBwcF9vdXRfZmx1c2ggOiB1bml0IC0+IHVuaXQ7XG4gICgqIE91dHB1dCBvZiBuZXcgbGluZXMuICopXG4gIG11dGFibGUgcHBfb3V0X25ld2xpbmUgOiB1bml0IC0+IHVuaXQ7XG4gICgqIE91dHB1dCBvZiBicmVhayBoaW50cyBzcGFjZXMuICopXG4gIG11dGFibGUgcHBfb3V0X3NwYWNlcyA6IGludCAtPiB1bml0O1xuICAoKiBPdXRwdXQgb2YgaW5kZW50YXRpb24gb2YgbmV3IGxpbmVzLiAqKVxuICBtdXRhYmxlIHBwX291dF9pbmRlbnQgOiBpbnQgLT4gdW5pdDtcbiAgKCogQXJlIHRhZ3MgcHJpbnRlZCA/ICopXG4gIG11dGFibGUgcHBfcHJpbnRfdGFncyA6IGJvb2w7XG4gICgqIEFyZSB0YWdzIG1hcmtlZCA/ICopXG4gIG11dGFibGUgcHBfbWFya190YWdzIDogYm9vbDtcbiAgKCogRmluZCBvcGVuaW5nIGFuZCBjbG9zaW5nIG1hcmtlcnMgb2YgdGFncy4gKilcbiAgbXV0YWJsZSBwcF9tYXJrX29wZW5fdGFnIDogc3RhZyAtPiBzdHJpbmc7XG4gIG11dGFibGUgcHBfbWFya19jbG9zZV90YWcgOiBzdGFnIC0+IHN0cmluZztcbiAgbXV0YWJsZSBwcF9wcmludF9vcGVuX3RhZyA6IHN0YWcgLT4gdW5pdDtcbiAgbXV0YWJsZSBwcF9wcmludF9jbG9zZV90YWcgOiBzdGFnIC0+IHVuaXQ7XG4gICgqIFRoZSBwcmV0dHktcHJpbnRlciBxdWV1ZS4gKilcbiAgcHBfcXVldWUgOiBwcF9xdWV1ZTtcbn1cblxuXG4oKiBUaGUgZm9ybWF0dGVyIHNwZWNpZmljIHRhZyBoYW5kbGluZyBmdW5jdGlvbnMuICopXG50eXBlIGZvcm1hdHRlcl9zdGFnX2Z1bmN0aW9ucyA9IHtcbiAgbWFya19vcGVuX3N0YWcgOiBzdGFnIC0+IHN0cmluZztcbiAgbWFya19jbG9zZV9zdGFnIDogc3RhZyAtPiBzdHJpbmc7XG4gIHByaW50X29wZW5fc3RhZyA6IHN0YWcgLT4gdW5pdDtcbiAgcHJpbnRfY2xvc2Vfc3RhZyA6IHN0YWcgLT4gdW5pdDtcbn1cblxuXG4oKiBUaGUgZm9ybWF0dGVyIGZ1bmN0aW9ucyB0byBvdXRwdXQgbWF0ZXJpYWwuICopXG50eXBlIGZvcm1hdHRlcl9vdXRfZnVuY3Rpb25zID0ge1xuICBvdXRfc3RyaW5nIDogc3RyaW5nIC0+IGludCAtPiBpbnQgLT4gdW5pdDtcbiAgb3V0X2ZsdXNoIDogdW5pdCAtPiB1bml0O1xuICBvdXRfbmV3bGluZSA6IHVuaXQgLT4gdW5pdDtcbiAgb3V0X3NwYWNlcyA6IGludCAtPiB1bml0O1xuICBvdXRfaW5kZW50IDogaW50IC0+IHVuaXQ7XG59XG5cblxuKCpcblxuICBBdXhpbGlhcmllcyBhbmQgYmFzaWMgZnVuY3Rpb25zLlxuXG4qKVxuXG4oKiBFbnRlciBhIHRva2VuIGluIHRoZSBwcmV0dHktcHJpbnRlciBxdWV1ZS4gKilcbmxldCBwcF9lbnF1ZXVlIHN0YXRlIHRva2VuID1cbiAgc3RhdGUucHBfcmlnaHRfdG90YWwgPC0gc3RhdGUucHBfcmlnaHRfdG90YWwgKyB0b2tlbi5sZW5ndGg7XG4gIFF1ZXVlLmFkZCB0b2tlbiBzdGF0ZS5wcF9xdWV1ZVxuXG5cbmxldCBwcF9jbGVhcl9xdWV1ZSBzdGF0ZSA9XG4gIHN0YXRlLnBwX2xlZnRfdG90YWwgPC0gMTsgc3RhdGUucHBfcmlnaHRfdG90YWwgPC0gMTtcbiAgUXVldWUuY2xlYXIgc3RhdGUucHBfcXVldWVcblxuXG4oKiBQcF9pbmZpbml0eTogbGFyZ2UgdmFsdWUgZm9yIGRlZmF1bHQgdG9rZW5zIHNpemUuXG5cbiAgIFBwX2luZmluaXR5IGlzIGRvY3VtZW50ZWQgYXMgYmVpbmcgZ3JlYXRlciB0aGFuIDFlMTA7IHRvIGF2b2lkXG4gICBjb25mdXNpb24gYWJvdXQgdGhlIHdvcmQgJ2dyZWF0ZXInLCB3ZSBjaG9vc2UgcHBfaW5maW5pdHkgZ3JlYXRlclxuICAgdGhhbiAxZTEwICsgMTsgZm9yIGNvcnJlY3QgaGFuZGxpbmcgb2YgdGVzdHMgaW4gdGhlIGFsZ29yaXRobSxcbiAgIHBwX2luZmluaXR5IG11c3QgYmUgZXZlbiBvbmUgbW9yZSB0aGFuIDFlMTAgKyAxOyBsZXQncyBzdGFuZCBvbiB0aGVcbiAgIHNhZmUgc2lkZSBieSBjaG9vc2luZyAxLmUxMCsxMC5cblxuICAgUHBfaW5maW5pdHkgY291bGQgcHJvYmFibHkgYmUgMTA3Mzc0MTgyMyB0aGF0IGlzIDJeMzAgLSAxLCB0aGF0IGlzXG4gICB0aGUgbWluaW1hbCB1cHBlciBib3VuZCBmb3IgaW50ZWdlcnM7IG5vdyB0aGF0IG1heF9pbnQgaXMgZGVmaW5lZCxcbiAgIHRoaXMgbGltaXQgY291bGQgYWxzbyBiZSBkZWZpbmVkIGFzIG1heF9pbnQgLSAxLlxuXG4gICBIb3dldmVyLCBiZWZvcmUgc2V0dGluZyBwcF9pbmZpbml0eSB0byBzb21ldGhpbmcgYXJvdW5kIG1heF9pbnQsIHdlXG4gICBtdXN0IGNhcmVmdWxseSBkb3VibGUtY2hlY2sgYWxsIHRoZSBpbnRlZ2VyIGFyaXRobWV0aWMgb3BlcmF0aW9uc1xuICAgdGhhdCBpbnZvbHZlIHBwX2luZmluaXR5LCBzaW5jZSBhbnkgb3ZlcmZsb3cgd291bGQgd3JlY2sgaGF2b2MgdGhlXG4gICBwcmV0dHktcHJpbnRpbmcgYWxnb3JpdGhtJ3MgaW52YXJpYW50cy4gR2l2ZW4gdGhhdCB0aGlzIGFyaXRobWV0aWNcbiAgIGNvcnJlY3RuZXNzIGNoZWNrIGlzIGRpZmZpY3VsdCBhbmQgZXJyb3IgcHJvbmUgYW5kIGdpdmVuIHRoYXQgMWUxMFxuICAgKyAxIGlzIGluIHByYWN0aWNlIGxhcmdlIGVub3VnaCwgdGhlcmUgaXMgbm8gbmVlZCB0byBhdHRlbXB0IHRvIHNldFxuICAgcHBfaW5maW5pdHkgdG8gdGhlIHRoZW9yZXRpY2FsbHkgbWF4aW11bSBsaW1pdC4gSXQgaXMgbm90IHdvcnRoIHRoZVxuICAgYnVyZGVuICEgKilcbmxldCBwcF9pbmZpbml0eSA9IDEwMDAwMDAwMTBcblxuKCogT3V0cHV0IGZ1bmN0aW9ucyBmb3IgdGhlIGZvcm1hdHRlci4gKilcbmxldCBwcF9vdXRwdXRfc3RyaW5nIHN0YXRlIHMgPSBzdGF0ZS5wcF9vdXRfc3RyaW5nIHMgMCAoU3RyaW5nLmxlbmd0aCBzKVxuYW5kIHBwX291dHB1dF9uZXdsaW5lIHN0YXRlID0gc3RhdGUucHBfb3V0X25ld2xpbmUgKClcbmFuZCBwcF9vdXRwdXRfc3BhY2VzIHN0YXRlIG4gPSBzdGF0ZS5wcF9vdXRfc3BhY2VzIG5cbmFuZCBwcF9vdXRwdXRfaW5kZW50IHN0YXRlIG4gPSBzdGF0ZS5wcF9vdXRfaW5kZW50IG5cblxuKCogRm9ybWF0IGEgdGV4dHVhbCB0b2tlbiAqKVxubGV0IGZvcm1hdF9wcF90ZXh0IHN0YXRlIHNpemUgdGV4dCA9XG4gIHN0YXRlLnBwX3NwYWNlX2xlZnQgPC0gc3RhdGUucHBfc3BhY2VfbGVmdCAtIHNpemU7XG4gIHBwX291dHB1dF9zdHJpbmcgc3RhdGUgdGV4dDtcbiAgc3RhdGUucHBfaXNfbmV3X2xpbmUgPC0gZmFsc2VcblxuKCogRm9ybWF0IGEgc3RyaW5nIGJ5IGl0cyBsZW5ndGgsIGlmIG5vdCBlbXB0eSAqKVxubGV0IGZvcm1hdF9zdHJpbmcgc3RhdGUgcyA9XG4gIGlmIHMgPD4gXCJcIiB0aGVuIGZvcm1hdF9wcF90ZXh0IHN0YXRlIChTdHJpbmcubGVuZ3RoIHMpIHNcblxuKCogVG8gZm9ybWF0IGEgYnJlYWssIGluZGVudGluZyBhIG5ldyBsaW5lLiAqKVxubGV0IGJyZWFrX25ld19saW5lIHN0YXRlIChiZWZvcmUsIG9mZnNldCwgYWZ0ZXIpIHdpZHRoID1cbiAgZm9ybWF0X3N0cmluZyBzdGF0ZSBiZWZvcmU7XG4gIHBwX291dHB1dF9uZXdsaW5lIHN0YXRlO1xuICBzdGF0ZS5wcF9pc19uZXdfbGluZSA8LSB0cnVlO1xuICBsZXQgaW5kZW50ID0gc3RhdGUucHBfbWFyZ2luIC0gd2lkdGggKyBvZmZzZXQgaW5cbiAgKCogRG9uJ3QgaW5kZW50IG1vcmUgdGhhbiBwcF9tYXhfaW5kZW50LiAqKVxuICBsZXQgcmVhbF9pbmRlbnQgPSBtaW4gc3RhdGUucHBfbWF4X2luZGVudCBpbmRlbnQgaW5cbiAgc3RhdGUucHBfY3VycmVudF9pbmRlbnQgPC0gcmVhbF9pbmRlbnQ7XG4gIHN0YXRlLnBwX3NwYWNlX2xlZnQgPC0gc3RhdGUucHBfbWFyZ2luIC0gc3RhdGUucHBfY3VycmVudF9pbmRlbnQ7XG4gIHBwX291dHB1dF9pbmRlbnQgc3RhdGUgc3RhdGUucHBfY3VycmVudF9pbmRlbnQ7XG4gIGZvcm1hdF9zdHJpbmcgc3RhdGUgYWZ0ZXJcblxuXG4oKiBUbyBmb3JjZSBhIGxpbmUgYnJlYWsgaW5zaWRlIGEgYm94OiBubyBvZmZzZXQgaXMgYWRkZWQuICopXG5sZXQgYnJlYWtfbGluZSBzdGF0ZSB3aWR0aCA9IGJyZWFrX25ld19saW5lIHN0YXRlIChcIlwiLCAwLCBcIlwiKSB3aWR0aFxuXG4oKiBUbyBmb3JtYXQgYSBicmVhayB0aGF0IGZpdHMgb24gdGhlIGN1cnJlbnQgbGluZS4gKilcbmxldCBicmVha19zYW1lX2xpbmUgc3RhdGUgKGJlZm9yZSwgd2lkdGgsIGFmdGVyKSA9XG4gIGZvcm1hdF9zdHJpbmcgc3RhdGUgYmVmb3JlO1xuICBzdGF0ZS5wcF9zcGFjZV9sZWZ0IDwtIHN0YXRlLnBwX3NwYWNlX2xlZnQgLSB3aWR0aDtcbiAgcHBfb3V0cHV0X3NwYWNlcyBzdGF0ZSB3aWR0aDtcbiAgZm9ybWF0X3N0cmluZyBzdGF0ZSBhZnRlclxuXG5cbigqIFRvIGluZGVudCBubyBtb3JlIHRoYW4gcHBfbWF4X2luZGVudCwgaWYgb25lIHRyaWVzIHRvIG9wZW4gYSBib3hcbiAgIGJleW9uZCBwcF9tYXhfaW5kZW50LCB0aGVuIHRoZSBib3ggaXMgcmVqZWN0ZWQgb24gdGhlIGxlZnRcbiAgIGJ5IHNpbXVsYXRpbmcgYSBicmVhay4gKilcbmxldCBwcF9mb3JjZV9icmVha19saW5lIHN0YXRlID1cbiAgbWF0Y2ggU3RhY2sudG9wX29wdCBzdGF0ZS5wcF9mb3JtYXRfc3RhY2sgd2l0aFxuICB8IE5vbmUgLT4gcHBfb3V0cHV0X25ld2xpbmUgc3RhdGVcbiAgfCBTb21lIHsgYm94X3R5cGU7IHdpZHRoIH0gLT5cbiAgICBpZiB3aWR0aCA+IHN0YXRlLnBwX3NwYWNlX2xlZnQgdGhlblxuICAgICAgbWF0Y2ggYm94X3R5cGUgd2l0aFxuICAgICAgfCBQcF9maXRzIHwgUHBfaGJveCAtPiAoKVxuICAgICAgfCBQcF92Ym94IHwgUHBfaHZib3ggfCBQcF9ob3Zib3ggfCBQcF9ib3ggLT4gYnJlYWtfbGluZSBzdGF0ZSB3aWR0aFxuXG5cbigqIFRvIHNraXAgYSB0b2tlbiwgaWYgdGhlIHByZXZpb3VzIGxpbmUgaGFzIGJlZW4gYnJva2VuLiAqKVxubGV0IHBwX3NraXBfdG9rZW4gc3RhdGUgPVxuICBtYXRjaCBRdWV1ZS50YWtlX29wdCBzdGF0ZS5wcF9xdWV1ZSB3aXRoXG4gIHwgTm9uZSAtPiAoKSAoKiBwcmludF9pZl9uZXdsaW5lIG11c3QgaGF2ZSBiZWVuIHRoZSBsYXN0IHByaW50aW5nIGNvbW1hbmQgKilcbiAgfCBTb21lIHsgc2l6ZTsgbGVuZ3RoOyBfIH0gLT5cbiAgICBzdGF0ZS5wcF9sZWZ0X3RvdGFsIDwtIHN0YXRlLnBwX2xlZnRfdG90YWwgLSBsZW5ndGg7XG4gICAgc3RhdGUucHBfc3BhY2VfbGVmdCA8LSBzdGF0ZS5wcF9zcGFjZV9sZWZ0ICsgU2l6ZS50b19pbnQgc2l6ZVxuXG5cbigqXG5cbiAgVGhlIG1haW4gcHJldHR5IHByaW50aW5nIGZ1bmN0aW9ucy5cblxuKilcblxuKCogRm9ybWF0dGluZyBhIHRva2VuIHdpdGggYSBnaXZlbiBzaXplLiAqKVxubGV0IGZvcm1hdF9wcF90b2tlbiBzdGF0ZSBzaXplID0gZnVuY3Rpb25cblxuICB8IFBwX3RleHQgcyAtPlxuICAgIGZvcm1hdF9wcF90ZXh0IHN0YXRlIHNpemUgc1xuXG4gIHwgUHBfYmVnaW4gKG9mZiwgdHkpIC0+XG4gICAgbGV0IGluc2VydGlvbl9wb2ludCA9IHN0YXRlLnBwX21hcmdpbiAtIHN0YXRlLnBwX3NwYWNlX2xlZnQgaW5cbiAgICBpZiBpbnNlcnRpb25fcG9pbnQgPiBzdGF0ZS5wcF9tYXhfaW5kZW50IHRoZW5cbiAgICAgICgqIGNhbiBub3Qgb3BlbiBhIGJveCByaWdodCB0aGVyZS4gKilcbiAgICAgIGJlZ2luIHBwX2ZvcmNlX2JyZWFrX2xpbmUgc3RhdGUgZW5kO1xuICAgIGxldCB3aWR0aCA9IHN0YXRlLnBwX3NwYWNlX2xlZnQgLSBvZmYgaW5cbiAgICBsZXQgYm94X3R5cGUgPVxuICAgICAgbWF0Y2ggdHkgd2l0aFxuICAgICAgfCBQcF92Ym94IC0+IFBwX3Zib3hcbiAgICAgIHwgUHBfaGJveCB8IFBwX2h2Ym94IHwgUHBfaG92Ym94IHwgUHBfYm94IHwgUHBfZml0cyAtPlxuICAgICAgICBpZiBzaXplID4gc3RhdGUucHBfc3BhY2VfbGVmdCB0aGVuIHR5IGVsc2UgUHBfZml0cyBpblxuICAgIFN0YWNrLnB1c2ggeyBib3hfdHlwZTsgd2lkdGggfSBzdGF0ZS5wcF9mb3JtYXRfc3RhY2tcblxuICB8IFBwX2VuZCAtPlxuICAgIFN0YWNrLnBvcF9vcHQgc3RhdGUucHBfZm9ybWF0X3N0YWNrIHw+IGlnbm9yZVxuXG4gIHwgUHBfdGJlZ2luIChQcF90Ym94IF8gYXMgdGJveCkgLT5cbiAgICBTdGFjay5wdXNoIHRib3ggc3RhdGUucHBfdGJveF9zdGFja1xuXG4gIHwgUHBfdGVuZCAtPlxuICAgIFN0YWNrLnBvcF9vcHQgc3RhdGUucHBfdGJveF9zdGFjayB8PiBpZ25vcmVcblxuICB8IFBwX3N0YWIgLT5cbiAgICBiZWdpbiBtYXRjaCBTdGFjay50b3Bfb3B0IHN0YXRlLnBwX3Rib3hfc3RhY2sgd2l0aFxuICAgIHwgTm9uZSAtPiAoKSAoKiBObyBvcGVuIHRhYnVsYXRpb24gYm94LiAqKVxuICAgIHwgU29tZSAoUHBfdGJveCB0YWJzKSAtPlxuICAgICAgbGV0IHJlYyBhZGRfdGFiIG4gPSBmdW5jdGlvblxuICAgICAgICB8IFtdIC0+IFtuXVxuICAgICAgICB8IHggOjogbCBhcyBscyAtPiBpZiBuIDwgeCB0aGVuIG4gOjogbHMgZWxzZSB4IDo6IGFkZF90YWIgbiBsIGluXG4gICAgICB0YWJzIDo9IGFkZF90YWIgKHN0YXRlLnBwX21hcmdpbiAtIHN0YXRlLnBwX3NwYWNlX2xlZnQpICF0YWJzXG4gICAgZW5kXG5cbiAgfCBQcF90YnJlYWsgKG4sIG9mZikgLT5cbiAgICBsZXQgaW5zZXJ0aW9uX3BvaW50ID0gc3RhdGUucHBfbWFyZ2luIC0gc3RhdGUucHBfc3BhY2VfbGVmdCBpblxuICAgIGJlZ2luIG1hdGNoIFN0YWNrLnRvcF9vcHQgc3RhdGUucHBfdGJveF9zdGFjayB3aXRoXG4gICAgfCBOb25lIC0+ICgpICgqIE5vIG9wZW4gdGFidWxhdGlvbiBib3guICopXG4gICAgfCBTb21lIChQcF90Ym94IHRhYnMpIC0+XG4gICAgICBsZXQgdGFiID1cbiAgICAgICAgbWF0Y2ggIXRhYnMgd2l0aFxuICAgICAgICB8IFtdIC0+IGluc2VydGlvbl9wb2ludFxuICAgICAgICB8IGZpcnN0IDo6IF8gLT5cbiAgICAgICAgICBsZXQgcmVjIGZpbmQgPSBmdW5jdGlvblxuICAgICAgICAgICAgfCBoZWFkIDo6IHRhaWwgLT5cbiAgICAgICAgICAgICAgaWYgaGVhZCA+PSBpbnNlcnRpb25fcG9pbnQgdGhlbiBoZWFkIGVsc2UgZmluZCB0YWlsXG4gICAgICAgICAgICB8IFtdIC0+IGZpcnN0IGluXG4gICAgICAgICAgZmluZCAhdGFicyBpblxuICAgICAgbGV0IG9mZnNldCA9IHRhYiAtIGluc2VydGlvbl9wb2ludCBpblxuICAgICAgaWYgb2Zmc2V0ID49IDBcbiAgICAgIHRoZW4gYnJlYWtfc2FtZV9saW5lIHN0YXRlIChcIlwiLCBvZmZzZXQgKyBuLCBcIlwiKVxuICAgICAgZWxzZSBicmVha19uZXdfbGluZSBzdGF0ZSAoXCJcIiwgdGFiICsgb2ZmLCBcIlwiKSBzdGF0ZS5wcF9tYXJnaW5cbiAgICBlbmRcblxuICB8IFBwX25ld2xpbmUgLT5cbiAgICBiZWdpbiBtYXRjaCBTdGFjay50b3Bfb3B0IHN0YXRlLnBwX2Zvcm1hdF9zdGFjayB3aXRoXG4gICAgfCBOb25lIC0+IHBwX291dHB1dF9uZXdsaW5lIHN0YXRlICgqIE5vIG9wZW4gYm94LiAqKVxuICAgIHwgU29tZSB7IHdpZHRoOyBffSAtPiBicmVha19saW5lIHN0YXRlIHdpZHRoXG4gICAgZW5kXG5cbiAgfCBQcF9pZl9uZXdsaW5lIC0+XG4gICAgaWYgc3RhdGUucHBfY3VycmVudF9pbmRlbnQgIT0gc3RhdGUucHBfbWFyZ2luIC0gc3RhdGUucHBfc3BhY2VfbGVmdFxuICAgIHRoZW4gcHBfc2tpcF90b2tlbiBzdGF0ZVxuXG4gIHwgUHBfYnJlYWsgeyBmaXRzOyBicmVha3MgfSAtPlxuICAgIGxldCBiZWZvcmUsIG9mZiwgXyA9IGJyZWFrcyBpblxuICAgIGJlZ2luIG1hdGNoIFN0YWNrLnRvcF9vcHQgc3RhdGUucHBfZm9ybWF0X3N0YWNrIHdpdGhcbiAgICB8IE5vbmUgLT4gKCkgKCogTm8gb3BlbiBib3guICopXG4gICAgfCBTb21lIHsgYm94X3R5cGU7IHdpZHRoIH0gLT5cbiAgICAgIGJlZ2luIG1hdGNoIGJveF90eXBlIHdpdGhcbiAgICAgIHwgUHBfaG92Ym94IC0+XG4gICAgICAgIGlmIHNpemUgKyBTdHJpbmcubGVuZ3RoIGJlZm9yZSA+IHN0YXRlLnBwX3NwYWNlX2xlZnRcbiAgICAgICAgdGhlbiBicmVha19uZXdfbGluZSBzdGF0ZSBicmVha3Mgd2lkdGhcbiAgICAgICAgZWxzZSBicmVha19zYW1lX2xpbmUgc3RhdGUgZml0c1xuICAgICAgfCBQcF9ib3ggLT5cbiAgICAgICAgKCogSGF2ZSB0aGUgbGluZSBqdXN0IGJlZW4gYnJva2VuIGhlcmUgPyAqKVxuICAgICAgICBpZiBzdGF0ZS5wcF9pc19uZXdfbGluZSB0aGVuIGJyZWFrX3NhbWVfbGluZSBzdGF0ZSBmaXRzIGVsc2VcbiAgICAgICAgaWYgc2l6ZSArIFN0cmluZy5sZW5ndGggYmVmb3JlID4gc3RhdGUucHBfc3BhY2VfbGVmdFxuICAgICAgICAgIHRoZW4gYnJlYWtfbmV3X2xpbmUgc3RhdGUgYnJlYWtzIHdpZHRoIGVsc2VcbiAgICAgICAgKCogYnJlYWsgdGhlIGxpbmUgaGVyZSBsZWFkcyB0byBuZXcgaW5kZW50YXRpb24gPyAqKVxuICAgICAgICBpZiBzdGF0ZS5wcF9jdXJyZW50X2luZGVudCA+IHN0YXRlLnBwX21hcmdpbiAtIHdpZHRoICsgb2ZmXG4gICAgICAgIHRoZW4gYnJlYWtfbmV3X2xpbmUgc3RhdGUgYnJlYWtzIHdpZHRoXG4gICAgICAgIGVsc2UgYnJlYWtfc2FtZV9saW5lIHN0YXRlIGZpdHNcbiAgICAgIHwgUHBfaHZib3ggLT4gYnJlYWtfbmV3X2xpbmUgc3RhdGUgYnJlYWtzIHdpZHRoXG4gICAgICB8IFBwX2ZpdHMgLT4gYnJlYWtfc2FtZV9saW5lIHN0YXRlIGZpdHNcbiAgICAgIHwgUHBfdmJveCAtPiBicmVha19uZXdfbGluZSBzdGF0ZSBicmVha3Mgd2lkdGhcbiAgICAgIHwgUHBfaGJveCAtPiBicmVha19zYW1lX2xpbmUgc3RhdGUgZml0c1xuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgIHwgUHBfb3Blbl90YWcgdGFnX25hbWUgLT5cbiAgICAgbGV0IG1hcmtlciA9IHN0YXRlLnBwX21hcmtfb3Blbl90YWcgdGFnX25hbWUgaW5cbiAgICAgcHBfb3V0cHV0X3N0cmluZyBzdGF0ZSBtYXJrZXI7XG4gICAgIFN0YWNrLnB1c2ggdGFnX25hbWUgc3RhdGUucHBfbWFya19zdGFja1xuXG4gICB8IFBwX2Nsb3NlX3RhZyAtPlxuICAgICBiZWdpbiBtYXRjaCBTdGFjay5wb3Bfb3B0IHN0YXRlLnBwX21hcmtfc3RhY2sgd2l0aFxuICAgICB8IE5vbmUgLT4gKCkgKCogTm8gbW9yZSB0YWcgdG8gY2xvc2UuICopXG4gICAgIHwgU29tZSB0YWdfbmFtZSAtPlxuICAgICAgIGxldCBtYXJrZXIgPSBzdGF0ZS5wcF9tYXJrX2Nsb3NlX3RhZyB0YWdfbmFtZSBpblxuICAgICAgIHBwX291dHB1dF9zdHJpbmcgc3RhdGUgbWFya2VyXG4gICAgIGVuZFxuXG5cbigqIFByaW50IGlmIHRva2VuIHNpemUgaXMga25vd24gZWxzZSBwcmludGluZyBpcyBkZWxheWVkLlxuICAgUHJpbnRpbmcgaXMgZGVsYXllZCB3aGVuIHRoZSB0ZXh0IHdhaXRpbmcgaW4gdGhlIHF1ZXVlIHJlcXVpcmVzXG4gICBtb3JlIHJvb20gdG8gZm9ybWF0IHRoYW4gZXhpc3RzIG9uIHRoZSBjdXJyZW50IGxpbmUuICopXG5sZXQgcmVjIGFkdmFuY2VfbGVmdCBzdGF0ZSA9XG4gIG1hdGNoIFF1ZXVlLnBlZWtfb3B0IHN0YXRlLnBwX3F1ZXVlIHdpdGhcbiAgfCBOb25lIC0+ICgpICgqIE5vIHRva2VucyB0byBwcmludCAqKVxuICB8IFNvbWUgeyBzaXplOyB0b2tlbjsgbGVuZ3RoIH0gLT5cbiAgICBsZXQgcGVuZGluZ19jb3VudCA9IHN0YXRlLnBwX3JpZ2h0X3RvdGFsIC0gc3RhdGUucHBfbGVmdF90b3RhbCBpblxuICAgIGlmIFNpemUuaXNfa25vd24gc2l6ZSB8fCBwZW5kaW5nX2NvdW50ID49IHN0YXRlLnBwX3NwYWNlX2xlZnQgdGhlbiBiZWdpblxuICAgICAgUXVldWUudGFrZSBzdGF0ZS5wcF9xdWV1ZSB8PiBpZ25vcmU7ICgqIE5vdCBlbXB0eTogd2UgcGVlayBpbnRvIGl0ICopXG4gICAgICBsZXQgc2l6ZSA9IGlmIFNpemUuaXNfa25vd24gc2l6ZSB0aGVuIFNpemUudG9faW50IHNpemUgZWxzZSBwcF9pbmZpbml0eSBpblxuICAgICAgZm9ybWF0X3BwX3Rva2VuIHN0YXRlIHNpemUgdG9rZW47XG4gICAgICBzdGF0ZS5wcF9sZWZ0X3RvdGFsIDwtIGxlbmd0aCArIHN0YXRlLnBwX2xlZnRfdG90YWw7XG4gICAgICAoYWR2YW5jZV9sZWZ0IFtAdGFpbGNhbGxdKSBzdGF0ZVxuICAgIGVuZFxuXG5cbigqIFRvIGVucXVldWUgYSB0b2tlbiA6IHRyeSB0byBhZHZhbmNlLiAqKVxubGV0IGVucXVldWVfYWR2YW5jZSBzdGF0ZSB0b2sgPSBwcF9lbnF1ZXVlIHN0YXRlIHRvazsgYWR2YW5jZV9sZWZ0IHN0YXRlXG5cblxuKCogVG8gZW5xdWV1ZSBzdHJpbmdzLiAqKVxubGV0IGVucXVldWVfc3RyaW5nX2FzIHN0YXRlIHNpemUgcyA9XG4gIGVucXVldWVfYWR2YW5jZSBzdGF0ZSB7IHNpemU7IHRva2VuID0gUHBfdGV4dCBzOyBsZW5ndGggPSBTaXplLnRvX2ludCBzaXplIH1cblxuXG5sZXQgZW5xdWV1ZV9zdHJpbmcgc3RhdGUgcyA9XG4gIGVucXVldWVfc3RyaW5nX2FzIHN0YXRlIChTaXplLm9mX2ludCAoU3RyaW5nLmxlbmd0aCBzKSkgc1xuXG5cbigqIFJvdXRpbmVzIGZvciBzY2FuIHN0YWNrXG4gICBkZXRlcm1pbmUgc2l6ZSBvZiBib3hlcy4gKilcblxuKCogVGhlIHNjYW5fc3RhY2sgaXMgbmV2ZXIgZW1wdHkuICopXG5sZXQgaW5pdGlhbGl6ZV9zY2FuX3N0YWNrIHN0YWNrID1cbiAgU3RhY2suY2xlYXIgc3RhY2s7XG4gIGxldCBxdWV1ZV9lbGVtID0geyBzaXplID0gU2l6ZS51bmtub3duOyB0b2tlbiA9IFBwX3RleHQgXCJcIjsgbGVuZ3RoID0gMCB9IGluXG4gIFN0YWNrLnB1c2ggeyBsZWZ0X3RvdGFsID0gLTE7IHF1ZXVlX2VsZW0gfSBzdGFja1xuXG4oKiBTZXR0aW5nIHRoZSBzaXplIG9mIGJveGVzIG9uIHNjYW4gc3RhY2s6XG4gICBpZiB0eSA9IHRydWUgdGhlbiBzaXplIG9mIGJyZWFrIGlzIHNldCBlbHNlIHNpemUgb2YgYm94IGlzIHNldDtcbiAgIGluIGVhY2ggY2FzZSBwcF9zY2FuX3N0YWNrIGlzIHBvcHBlZC5cblxuICAgTm90ZTpcbiAgIFBhdHRlcm4gbWF0Y2hpbmcgb24gc2NhbiBzdGFjayBpcyBleGhhdXN0aXZlLCBzaW5jZSBzY2FuX3N0YWNrIGlzIG5ldmVyXG4gICBlbXB0eS5cbiAgIFBhdHRlcm4gbWF0Y2hpbmcgb24gdG9rZW4gaW4gc2NhbiBzdGFjayBpcyBhbHNvIGV4aGF1c3RpdmUsXG4gICBzaW5jZSBzY2FuX3B1c2ggaXMgdXNlZCBvbiBicmVha3MgYW5kIG9wZW5pbmcgb2YgYm94ZXMuICopXG5sZXQgc2V0X3NpemUgc3RhdGUgdHkgPVxuICBtYXRjaCBTdGFjay50b3Bfb3B0IHN0YXRlLnBwX3NjYW5fc3RhY2sgd2l0aFxuICB8IE5vbmUgLT4gKCkgKCogc2Nhbl9zdGFjayBpcyBuZXZlciBlbXB0eS4gKilcbiAgfCBTb21lIHsgbGVmdF90b3RhbDsgcXVldWVfZWxlbSB9IC0+XG4gICAgbGV0IHNpemUgPSBTaXplLnRvX2ludCBxdWV1ZV9lbGVtLnNpemUgaW5cbiAgICAoKiB0ZXN0IGlmIHNjYW4gc3RhY2sgY29udGFpbnMgYW55IGRhdGEgdGhhdCBpcyBub3Qgb2Jzb2xldGUuICopXG4gICAgaWYgbGVmdF90b3RhbCA8IHN0YXRlLnBwX2xlZnRfdG90YWwgdGhlblxuICAgICAgaW5pdGlhbGl6ZV9zY2FuX3N0YWNrIHN0YXRlLnBwX3NjYW5fc3RhY2tcbiAgICBlbHNlXG4gICAgICBtYXRjaCBxdWV1ZV9lbGVtLnRva2VuIHdpdGhcbiAgICAgIHwgUHBfYnJlYWsgXyB8IFBwX3RicmVhayAoXywgXykgLT5cbiAgICAgICAgaWYgdHkgdGhlbiBiZWdpblxuICAgICAgICAgIHF1ZXVlX2VsZW0uc2l6ZSA8LSBTaXplLm9mX2ludCAoc3RhdGUucHBfcmlnaHRfdG90YWwgKyBzaXplKTtcbiAgICAgICAgICBTdGFjay5wb3Bfb3B0IHN0YXRlLnBwX3NjYW5fc3RhY2sgfD4gaWdub3JlXG4gICAgICAgIGVuZFxuICAgICAgfCBQcF9iZWdpbiAoXywgXykgLT5cbiAgICAgICAgaWYgbm90IHR5IHRoZW4gYmVnaW5cbiAgICAgICAgICBxdWV1ZV9lbGVtLnNpemUgPC0gU2l6ZS5vZl9pbnQgKHN0YXRlLnBwX3JpZ2h0X3RvdGFsICsgc2l6ZSk7XG4gICAgICAgICAgU3RhY2sucG9wX29wdCBzdGF0ZS5wcF9zY2FuX3N0YWNrIHw+IGlnbm9yZVxuICAgICAgICBlbmRcbiAgICAgIHwgUHBfdGV4dCBfIHwgUHBfc3RhYiB8IFBwX3RiZWdpbiBfIHwgUHBfdGVuZCB8IFBwX2VuZFxuICAgICAgfCBQcF9uZXdsaW5lIHwgUHBfaWZfbmV3bGluZSB8IFBwX29wZW5fdGFnIF8gfCBQcF9jbG9zZV90YWcgLT5cbiAgICAgICAgKCkgKCogc2Nhbl9wdXNoIGlzIG9ubHkgdXNlZCBmb3IgYnJlYWtzIGFuZCBib3hlcy4gKilcblxuXG4oKiBQdXNoIGEgdG9rZW4gb24gcHJldHR5LXByaW50ZXIgc2Nhbm5pbmcgc3RhY2suXG4gICBJZiBiIGlzIHRydWUgc2V0X3NpemUgaXMgY2FsbGVkLiAqKVxubGV0IHNjYW5fcHVzaCBzdGF0ZSBiIHRva2VuID1cbiAgcHBfZW5xdWV1ZSBzdGF0ZSB0b2tlbjtcbiAgaWYgYiB0aGVuIHNldF9zaXplIHN0YXRlIHRydWU7XG4gIGxldCBlbGVtID0geyBsZWZ0X3RvdGFsID0gc3RhdGUucHBfcmlnaHRfdG90YWw7IHF1ZXVlX2VsZW0gPSB0b2tlbiB9IGluXG4gIFN0YWNrLnB1c2ggZWxlbSBzdGF0ZS5wcF9zY2FuX3N0YWNrXG5cblxuKCogVG8gb3BlbiBhIG5ldyBib3ggOlxuICAgdGhlIHVzZXIgbWF5IHNldCB0aGUgZGVwdGggYm91bmQgcHBfbWF4X2JveGVzXG4gICBhbnkgdGV4dCBuZXN0ZWQgZGVlcGVyIGlzIHByaW50ZWQgYXMgdGhlIGVsbGlwc2lzIHN0cmluZy4gKilcbmxldCBwcF9vcGVuX2JveF9nZW4gc3RhdGUgaW5kZW50IGJyX3R5ID1cbiAgc3RhdGUucHBfY3Vycl9kZXB0aCA8LSBzdGF0ZS5wcF9jdXJyX2RlcHRoICsgMTtcbiAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA8IHN0YXRlLnBwX21heF9ib3hlcyB0aGVuXG4gICAgbGV0IHNpemUgPSBTaXplLm9mX2ludCAoLSBzdGF0ZS5wcF9yaWdodF90b3RhbCkgaW5cbiAgICBsZXQgZWxlbSA9IHsgc2l6ZTsgdG9rZW4gPSBQcF9iZWdpbiAoaW5kZW50LCBicl90eSk7IGxlbmd0aCA9IDAgfSBpblxuICAgIHNjYW5fcHVzaCBzdGF0ZSBmYWxzZSBlbGVtIGVsc2VcbiAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA9IHN0YXRlLnBwX21heF9ib3hlc1xuICB0aGVuIGVucXVldWVfc3RyaW5nIHN0YXRlIHN0YXRlLnBwX2VsbGlwc2lzXG5cblxuKCogVGhlIGJveCB3aGljaCBpcyBhbHdheXMgb3Blbi4gKilcbmxldCBwcF9vcGVuX3N5c19ib3ggc3RhdGUgPSBwcF9vcGVuX2JveF9nZW4gc3RhdGUgMCBQcF9ob3Zib3hcblxuKCogQ2xvc2UgYSBib3gsIHNldHRpbmcgc2l6ZXMgb2YgaXRzIHN1YiBib3hlcy4gKilcbmxldCBwcF9jbG9zZV9ib3ggc3RhdGUgKCkgPVxuICBpZiBzdGF0ZS5wcF9jdXJyX2RlcHRoID4gMSB0aGVuXG4gIGJlZ2luXG4gICAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA8IHN0YXRlLnBwX21heF9ib3hlcyB0aGVuXG4gICAgYmVnaW5cbiAgICAgIHBwX2VucXVldWUgc3RhdGUgeyBzaXplID0gU2l6ZS56ZXJvOyB0b2tlbiA9IFBwX2VuZDsgbGVuZ3RoID0gMCB9O1xuICAgICAgc2V0X3NpemUgc3RhdGUgdHJ1ZTsgc2V0X3NpemUgc3RhdGUgZmFsc2VcbiAgICBlbmQ7XG4gICAgc3RhdGUucHBfY3Vycl9kZXB0aCA8LSBzdGF0ZS5wcF9jdXJyX2RlcHRoIC0gMTtcbiAgZW5kXG5cblxuKCogT3BlbiBhIHRhZywgcHVzaGluZyBpdCBvbiB0aGUgdGFnIHN0YWNrLiAqKVxubGV0IHBwX29wZW5fc3RhZyBzdGF0ZSB0YWdfbmFtZSA9XG4gIGlmIHN0YXRlLnBwX3ByaW50X3RhZ3MgdGhlblxuICBiZWdpblxuICAgIFN0YWNrLnB1c2ggdGFnX25hbWUgc3RhdGUucHBfdGFnX3N0YWNrO1xuICAgIHN0YXRlLnBwX3ByaW50X29wZW5fdGFnIHRhZ19uYW1lXG4gIGVuZDtcbiAgaWYgc3RhdGUucHBfbWFya190YWdzIHRoZW5cbiAgICBsZXQgdG9rZW4gPSBQcF9vcGVuX3RhZyB0YWdfbmFtZSBpblxuICAgIHBwX2VucXVldWUgc3RhdGUgeyBzaXplID0gU2l6ZS56ZXJvOyB0b2tlbjsgbGVuZ3RoID0gMCB9XG5cblxuKCogQ2xvc2UgYSB0YWcsIHBvcHBpbmcgaXQgZnJvbSB0aGUgdGFnIHN0YWNrLiAqKVxubGV0IHBwX2Nsb3NlX3N0YWcgc3RhdGUgKCkgPVxuICBpZiBzdGF0ZS5wcF9tYXJrX3RhZ3MgdGhlblxuICAgIHBwX2VucXVldWUgc3RhdGUgeyBzaXplID0gU2l6ZS56ZXJvOyB0b2tlbiA9IFBwX2Nsb3NlX3RhZzsgbGVuZ3RoID0gMCB9O1xuICBpZiBzdGF0ZS5wcF9wcmludF90YWdzIHRoZW5cbiAgICBtYXRjaCBTdGFjay5wb3Bfb3B0IHN0YXRlLnBwX3RhZ19zdGFjayB3aXRoXG4gICAgfCBOb25lIC0+ICgpICgqIE5vIG1vcmUgdGFnIHRvIGNsb3NlLiAqKVxuICAgIHwgU29tZSB0YWdfbmFtZSAtPlxuICAgICAgc3RhdGUucHBfcHJpbnRfY2xvc2VfdGFnIHRhZ19uYW1lXG5cbmxldCBwcF9vcGVuX3RhZyBzdGF0ZSBzID0gcHBfb3Blbl9zdGFnIHN0YXRlIChTdHJpbmdfdGFnIHMpXG5sZXQgcHBfY2xvc2VfdGFnIHN0YXRlICgpID0gcHBfY2xvc2Vfc3RhZyBzdGF0ZSAoKVxuXG5sZXQgcHBfc2V0X3ByaW50X3RhZ3Mgc3RhdGUgYiA9IHN0YXRlLnBwX3ByaW50X3RhZ3MgPC0gYlxubGV0IHBwX3NldF9tYXJrX3RhZ3Mgc3RhdGUgYiA9IHN0YXRlLnBwX21hcmtfdGFncyA8LSBiXG5sZXQgcHBfZ2V0X3ByaW50X3RhZ3Mgc3RhdGUgKCkgPSBzdGF0ZS5wcF9wcmludF90YWdzXG5sZXQgcHBfZ2V0X21hcmtfdGFncyBzdGF0ZSAoKSA9IHN0YXRlLnBwX21hcmtfdGFnc1xubGV0IHBwX3NldF90YWdzIHN0YXRlIGIgPVxuICBwcF9zZXRfcHJpbnRfdGFncyBzdGF0ZSBiOyBwcF9zZXRfbWFya190YWdzIHN0YXRlIGJcblxuXG4oKiBIYW5kbGluZyB0YWcgaGFuZGxpbmcgZnVuY3Rpb25zOiBnZXQvc2V0IGZ1bmN0aW9ucy4gKilcbmxldCBwcF9nZXRfZm9ybWF0dGVyX3N0YWdfZnVuY3Rpb25zIHN0YXRlICgpID0ge1xuICBtYXJrX29wZW5fc3RhZyA9IHN0YXRlLnBwX21hcmtfb3Blbl90YWc7XG4gIG1hcmtfY2xvc2Vfc3RhZyA9IHN0YXRlLnBwX21hcmtfY2xvc2VfdGFnO1xuICBwcmludF9vcGVuX3N0YWcgPSBzdGF0ZS5wcF9wcmludF9vcGVuX3RhZztcbiAgcHJpbnRfY2xvc2Vfc3RhZyA9IHN0YXRlLnBwX3ByaW50X2Nsb3NlX3RhZztcbn1cblxuXG5sZXQgcHBfc2V0X2Zvcm1hdHRlcl9zdGFnX2Z1bmN0aW9ucyBzdGF0ZSB7XG4gICAgIG1hcmtfb3Blbl9zdGFnID0gbW90O1xuICAgICBtYXJrX2Nsb3NlX3N0YWcgPSBtY3Q7XG4gICAgIHByaW50X29wZW5fc3RhZyA9IHBvdDtcbiAgICAgcHJpbnRfY2xvc2Vfc3RhZyA9IHBjdDtcbiAgfSA9XG4gIHN0YXRlLnBwX21hcmtfb3Blbl90YWcgPC0gbW90O1xuICBzdGF0ZS5wcF9tYXJrX2Nsb3NlX3RhZyA8LSBtY3Q7XG4gIHN0YXRlLnBwX3ByaW50X29wZW5fdGFnIDwtIHBvdDtcbiAgc3RhdGUucHBfcHJpbnRfY2xvc2VfdGFnIDwtIHBjdFxuXG5cbigqIEluaXRpYWxpemUgcHJldHR5LXByaW50ZXIuICopXG5sZXQgcHBfcmluaXQgc3RhdGUgPVxuICBwcF9jbGVhcl9xdWV1ZSBzdGF0ZTtcbiAgaW5pdGlhbGl6ZV9zY2FuX3N0YWNrIHN0YXRlLnBwX3NjYW5fc3RhY2s7XG4gIFN0YWNrLmNsZWFyIHN0YXRlLnBwX2Zvcm1hdF9zdGFjaztcbiAgU3RhY2suY2xlYXIgc3RhdGUucHBfdGJveF9zdGFjaztcbiAgU3RhY2suY2xlYXIgc3RhdGUucHBfdGFnX3N0YWNrO1xuICBTdGFjay5jbGVhciBzdGF0ZS5wcF9tYXJrX3N0YWNrO1xuICBzdGF0ZS5wcF9jdXJyZW50X2luZGVudCA8LSAwO1xuICBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwtIDA7XG4gIHN0YXRlLnBwX3NwYWNlX2xlZnQgPC0gc3RhdGUucHBfbWFyZ2luO1xuICBwcF9vcGVuX3N5c19ib3ggc3RhdGVcblxubGV0IGNsZWFyX3RhZ19zdGFjayBzdGF0ZSA9XG4gIFN0YWNrLml0ZXIgKGZ1biBfIC0+IHBwX2Nsb3NlX3RhZyBzdGF0ZSAoKSkgc3RhdGUucHBfdGFnX3N0YWNrXG5cblxuKCogRmx1c2hpbmcgcHJldHR5LXByaW50ZXIgcXVldWUuICopXG5sZXQgcHBfZmx1c2hfcXVldWUgc3RhdGUgYiA9XG4gIGNsZWFyX3RhZ19zdGFjayBzdGF0ZTtcbiAgd2hpbGUgc3RhdGUucHBfY3Vycl9kZXB0aCA+IDEgZG9cbiAgICBwcF9jbG9zZV9ib3ggc3RhdGUgKClcbiAgZG9uZTtcbiAgc3RhdGUucHBfcmlnaHRfdG90YWwgPC0gcHBfaW5maW5pdHk7XG4gIGFkdmFuY2VfbGVmdCBzdGF0ZTtcbiAgaWYgYiB0aGVuIHBwX291dHB1dF9uZXdsaW5lIHN0YXRlO1xuICBwcF9yaW5pdCBzdGF0ZVxuXG4oKlxuXG4gIFByb2NlZHVyZXMgdG8gZm9ybWF0IHZhbHVlcyBhbmQgdXNlIGJveGVzLlxuXG4qKVxuXG4oKiBUbyBmb3JtYXQgYSBzdHJpbmcuICopXG5sZXQgcHBfcHJpbnRfYXNfc2l6ZSBzdGF0ZSBzaXplIHMgPVxuICBpZiBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwgc3RhdGUucHBfbWF4X2JveGVzXG4gIHRoZW4gZW5xdWV1ZV9zdHJpbmdfYXMgc3RhdGUgc2l6ZSBzXG5cblxubGV0IHBwX3ByaW50X2FzIHN0YXRlIGlzaXplIHMgPVxuICBwcF9wcmludF9hc19zaXplIHN0YXRlIChTaXplLm9mX2ludCBpc2l6ZSkgc1xuXG5cbmxldCBwcF9wcmludF9zdHJpbmcgc3RhdGUgcyA9XG4gIHBwX3ByaW50X2FzIHN0YXRlIChTdHJpbmcubGVuZ3RoIHMpIHNcblxuXG4oKiBUbyBmb3JtYXQgYW4gaW50ZWdlci4gKilcbmxldCBwcF9wcmludF9pbnQgc3RhdGUgaSA9IHBwX3ByaW50X3N0cmluZyBzdGF0ZSAoSW50LnRvX3N0cmluZyBpKVxuXG4oKiBUbyBmb3JtYXQgYSBmbG9hdC4gKilcbmxldCBwcF9wcmludF9mbG9hdCBzdGF0ZSBmID0gcHBfcHJpbnRfc3RyaW5nIHN0YXRlIChzdHJpbmdfb2ZfZmxvYXQgZilcblxuKCogVG8gZm9ybWF0IGEgYm9vbGVhbi4gKilcbmxldCBwcF9wcmludF9ib29sIHN0YXRlIGIgPSBwcF9wcmludF9zdHJpbmcgc3RhdGUgKHN0cmluZ19vZl9ib29sIGIpXG5cbigqIFRvIGZvcm1hdCBhIGNoYXIuICopXG5sZXQgcHBfcHJpbnRfY2hhciBzdGF0ZSBjID1cbiAgcHBfcHJpbnRfYXMgc3RhdGUgMSAoU3RyaW5nLm1ha2UgMSBjKVxuXG5cbigqIE9wZW5pbmcgYm94ZXMuICopXG5sZXQgcHBfb3Blbl9oYm94IHN0YXRlICgpID0gcHBfb3Blbl9ib3hfZ2VuIHN0YXRlIDAgUHBfaGJveFxuYW5kIHBwX29wZW5fdmJveCBzdGF0ZSBpbmRlbnQgPSBwcF9vcGVuX2JveF9nZW4gc3RhdGUgaW5kZW50IFBwX3Zib3hcblxuYW5kIHBwX29wZW5faHZib3ggc3RhdGUgaW5kZW50ID0gcHBfb3Blbl9ib3hfZ2VuIHN0YXRlIGluZGVudCBQcF9odmJveFxuYW5kIHBwX29wZW5faG92Ym94IHN0YXRlIGluZGVudCA9IHBwX29wZW5fYm94X2dlbiBzdGF0ZSBpbmRlbnQgUHBfaG92Ym94XG5hbmQgcHBfb3Blbl9ib3ggc3RhdGUgaW5kZW50ID0gcHBfb3Blbl9ib3hfZ2VuIHN0YXRlIGluZGVudCBQcF9ib3hcblxuXG4oKiBQcmludGluZyBxdWV1ZWQgdGV4dC5cblxuICAgW3BwX3ByaW50X2ZsdXNoXSBwcmludHMgYWxsIHBlbmRpbmcgaXRlbXMgaW4gdGhlIHByZXR0eS1wcmludGVyIHF1ZXVlIGFuZFxuICAgdGhlbiBmbHVzaGVzIHRoZSBsb3cgbGV2ZWwgb3V0cHV0IGRldmljZSBvZiB0aGUgZm9ybWF0dGVyIHRvIGFjdHVhbGx5XG4gICBkaXNwbGF5IHByaW50aW5nIG1hdGVyaWFsLlxuXG4gICBbcHBfcHJpbnRfbmV3bGluZV0gYmVoYXZlcyBhcyBbcHBfcHJpbnRfZmx1c2hdIGFmdGVyIHByaW50aW5nIGFuIGFkZGl0aW9uYWxcbiAgIG5ldyBsaW5lLiAqKVxubGV0IHBwX3ByaW50X25ld2xpbmUgc3RhdGUgKCkgPVxuICBwcF9mbHVzaF9xdWV1ZSBzdGF0ZSB0cnVlOyBzdGF0ZS5wcF9vdXRfZmx1c2ggKClcbmFuZCBwcF9wcmludF9mbHVzaCBzdGF0ZSAoKSA9XG4gIHBwX2ZsdXNoX3F1ZXVlIHN0YXRlIGZhbHNlOyBzdGF0ZS5wcF9vdXRfZmx1c2ggKClcblxuXG4oKiBUbyBnZXQgYSBuZXdsaW5lIHdoZW4gb25lIGRvZXMgbm90IHdhbnQgdG8gY2xvc2UgdGhlIGN1cnJlbnQgYm94LiAqKVxubGV0IHBwX2ZvcmNlX25ld2xpbmUgc3RhdGUgKCkgPVxuICBpZiBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwgc3RhdGUucHBfbWF4X2JveGVzIHRoZW5cbiAgICBlbnF1ZXVlX2FkdmFuY2Ugc3RhdGUgeyBzaXplID0gU2l6ZS56ZXJvOyB0b2tlbiA9IFBwX25ld2xpbmU7IGxlbmd0aCA9IDAgfVxuXG5cbigqIFRvIGZvcm1hdCBzb21ldGhpbmcsIG9ubHkgaW4gY2FzZSB0aGUgbGluZSBoYXMganVzdCBiZWVuIGJyb2tlbi4gKilcbmxldCBwcF9wcmludF9pZl9uZXdsaW5lIHN0YXRlICgpID1cbiAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA8IHN0YXRlLnBwX21heF9ib3hlcyB0aGVuXG4gICAgZW5xdWV1ZV9hZHZhbmNlIHN0YXRlXG4gICAgICB7IHNpemUgPSBTaXplLnplcm87IHRva2VuID0gUHBfaWZfbmV3bGluZTsgbGVuZ3RoID0gMCB9XG5cblxuKCogR2VuZXJhbGl6ZWQgYnJlYWsgaGludCB0aGF0IGFsbG93cyBwcmludGluZyBzdHJpbmdzIGJlZm9yZS9hZnRlclxuICAgc2FtZS1saW5lIG9mZnNldCAod2lkdGgpIG9yIG5ldy1saW5lIG9mZnNldCAqKVxubGV0IHBwX3ByaW50X2N1c3RvbV9icmVhayBzdGF0ZSB+Zml0cyB+YnJlYWtzID1cbiAgbGV0IGJlZm9yZSwgd2lkdGgsIGFmdGVyID0gZml0cyBpblxuICBpZiBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwgc3RhdGUucHBfbWF4X2JveGVzIHRoZW5cbiAgICBsZXQgc2l6ZSA9IFNpemUub2ZfaW50ICgtIHN0YXRlLnBwX3JpZ2h0X3RvdGFsKSBpblxuICAgIGxldCB0b2tlbiA9IFBwX2JyZWFrIHsgZml0czsgYnJlYWtzIH0gaW5cbiAgICBsZXQgbGVuZ3RoID0gU3RyaW5nLmxlbmd0aCBiZWZvcmUgKyB3aWR0aCArIFN0cmluZy5sZW5ndGggYWZ0ZXIgaW5cbiAgICBsZXQgZWxlbSA9IHsgc2l6ZTsgdG9rZW47IGxlbmd0aCB9IGluXG4gICAgc2Nhbl9wdXNoIHN0YXRlIHRydWUgZWxlbVxuXG4oKiBQcmludGluZyBicmVhayBoaW50czpcbiAgIEEgYnJlYWsgaGludCBpbmRpY2F0ZXMgd2hlcmUgYSBib3ggbWF5IGJlIGJyb2tlbi5cbiAgIElmIGxpbmUgaXMgYnJva2VuIHRoZW4gb2Zmc2V0IGlzIGFkZGVkIHRvIHRoZSBpbmRlbnRhdGlvbiBvZiB0aGUgY3VycmVudFxuICAgYm94IGVsc2UgKHRoZSB2YWx1ZSBvZikgd2lkdGggYmxhbmtzIGFyZSBwcmludGVkLiAqKVxubGV0IHBwX3ByaW50X2JyZWFrIHN0YXRlIHdpZHRoIG9mZnNldCA9XG4gIHBwX3ByaW50X2N1c3RvbV9icmVhayBzdGF0ZVxuICAgIH5maXRzOihcIlwiLCB3aWR0aCwgXCJcIikgfmJyZWFrczooXCJcIiwgb2Zmc2V0LCBcIlwiKVxuXG5cbigqIFByaW50IGEgc3BhY2UgOlxuICAgYSBzcGFjZSBpcyBhIGJyZWFrIGhpbnQgdGhhdCBwcmludHMgYSBzaW5nbGUgc3BhY2UgaWYgdGhlIGJyZWFrIGRvZXMgbm90XG4gICBzcGxpdCB0aGUgbGluZTtcbiAgIGEgY3V0IGlzIGEgYnJlYWsgaGludCB0aGF0IHByaW50cyBub3RoaW5nIGlmIHRoZSBicmVhayBkb2VzIG5vdCBzcGxpdCB0aGVcbiAgIGxpbmUuICopXG5sZXQgcHBfcHJpbnRfc3BhY2Ugc3RhdGUgKCkgPSBwcF9wcmludF9icmVhayBzdGF0ZSAxIDBcbmFuZCBwcF9wcmludF9jdXQgc3RhdGUgKCkgPSBwcF9wcmludF9icmVhayBzdGF0ZSAwIDBcblxuXG4oKiBUYWJ1bGF0aW9uIGJveGVzLiAqKVxubGV0IHBwX29wZW5fdGJveCBzdGF0ZSAoKSA9XG4gIHN0YXRlLnBwX2N1cnJfZGVwdGggPC0gc3RhdGUucHBfY3Vycl9kZXB0aCArIDE7XG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXMgdGhlblxuICAgIGxldCBzaXplID0gU2l6ZS56ZXJvIGluXG4gICAgbGV0IGVsZW0gPSB7IHNpemU7IHRva2VuID0gUHBfdGJlZ2luIChQcF90Ym94IChyZWYgW10pKTsgbGVuZ3RoID0gMCB9IGluXG4gICAgZW5xdWV1ZV9hZHZhbmNlIHN0YXRlIGVsZW1cblxuXG4oKiBDbG9zZSBhIHRhYnVsYXRpb24gYm94LiAqKVxubGV0IHBwX2Nsb3NlX3Rib3ggc3RhdGUgKCkgPVxuICBpZiBzdGF0ZS5wcF9jdXJyX2RlcHRoID4gMSB0aGVuXG4gIGJlZ2luXG4gICBpZiBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwgc3RhdGUucHBfbWF4X2JveGVzIHRoZW5cbiAgICAgbGV0IGVsZW0gPSB7IHNpemUgPSBTaXplLnplcm87IHRva2VuID0gUHBfdGVuZDsgbGVuZ3RoID0gMCB9IGluXG4gICAgIGVucXVldWVfYWR2YW5jZSBzdGF0ZSBlbGVtO1xuICAgICBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwtIHN0YXRlLnBwX2N1cnJfZGVwdGggLSAxXG4gIGVuZFxuXG5cbigqIFByaW50IGEgdGFidWxhdGlvbiBicmVhay4gKilcbmxldCBwcF9wcmludF90YnJlYWsgc3RhdGUgd2lkdGggb2Zmc2V0ID1cbiAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA8IHN0YXRlLnBwX21heF9ib3hlcyB0aGVuXG4gICAgbGV0IHNpemUgPSBTaXplLm9mX2ludCAoLSBzdGF0ZS5wcF9yaWdodF90b3RhbCkgaW5cbiAgICBsZXQgZWxlbSA9IHsgc2l6ZTsgdG9rZW4gPSBQcF90YnJlYWsgKHdpZHRoLCBvZmZzZXQpOyBsZW5ndGggPSB3aWR0aCB9IGluXG4gICAgc2Nhbl9wdXNoIHN0YXRlIHRydWUgZWxlbVxuXG5cbmxldCBwcF9wcmludF90YWIgc3RhdGUgKCkgPSBwcF9wcmludF90YnJlYWsgc3RhdGUgMCAwXG5cbmxldCBwcF9zZXRfdGFiIHN0YXRlICgpID1cbiAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA8IHN0YXRlLnBwX21heF9ib3hlcyB0aGVuXG4gICAgbGV0IGVsZW0gPSB7IHNpemUgPSBTaXplLnplcm87IHRva2VuID0gUHBfc3RhYjsgbGVuZ3RoID0gMCB9IGluXG4gICAgZW5xdWV1ZV9hZHZhbmNlIHN0YXRlIGVsZW1cblxuXG4oKlxuXG4gIFByb2NlZHVyZXMgdG8gY29udHJvbCB0aGUgcHJldHR5LXByaW50ZXJzXG5cbiopXG5cbigqIFNldF9tYXhfYm94ZXMuICopXG5sZXQgcHBfc2V0X21heF9ib3hlcyBzdGF0ZSBuID0gaWYgbiA+IDEgdGhlbiBzdGF0ZS5wcF9tYXhfYm94ZXMgPC0gblxuXG4oKiBUbyBrbm93IHRoZSBjdXJyZW50IG1heGltdW0gbnVtYmVyIG9mIGJveGVzIGFsbG93ZWQuICopXG5sZXQgcHBfZ2V0X21heF9ib3hlcyBzdGF0ZSAoKSA9IHN0YXRlLnBwX21heF9ib3hlc1xuXG5sZXQgcHBfb3Zlcl9tYXhfYm94ZXMgc3RhdGUgKCkgPSBzdGF0ZS5wcF9jdXJyX2RlcHRoID0gc3RhdGUucHBfbWF4X2JveGVzXG5cbigqIEVsbGlwc2lzLiAqKVxubGV0IHBwX3NldF9lbGxpcHNpc190ZXh0IHN0YXRlIHMgPSBzdGF0ZS5wcF9lbGxpcHNpcyA8LSBzXG5hbmQgcHBfZ2V0X2VsbGlwc2lzX3RleHQgc3RhdGUgKCkgPSBzdGF0ZS5wcF9lbGxpcHNpc1xuXG5cbigqIFRvIHNldCB0aGUgbWFyZ2luIG9mIHByZXR0eS1wcmludGVyLiAqKVxubGV0IHBwX2xpbWl0IG4gPVxuICBpZiBuIDwgcHBfaW5maW5pdHkgdGhlbiBuIGVsc2UgcHJlZCBwcF9pbmZpbml0eVxuXG5cbigqIEludGVybmFsIHByZXR0eS1wcmludGVyIGZ1bmN0aW9ucy4gKilcbmxldCBwcF9zZXRfbWluX3NwYWNlX2xlZnQgc3RhdGUgbiA9XG4gIGlmIG4gPj0gMSB0aGVuXG4gICAgbGV0IG4gPSBwcF9saW1pdCBuIGluXG4gICAgc3RhdGUucHBfbWluX3NwYWNlX2xlZnQgPC0gbjtcbiAgICBzdGF0ZS5wcF9tYXhfaW5kZW50IDwtIHN0YXRlLnBwX21hcmdpbiAtIHN0YXRlLnBwX21pbl9zcGFjZV9sZWZ0O1xuICAgIHBwX3Jpbml0IHN0YXRlXG5cblxuKCogSW5pdGlhbGx5LCB3ZSBoYXZlIDpcbiAgIHBwX21heF9pbmRlbnQgPSBwcF9tYXJnaW4gLSBwcF9taW5fc3BhY2VfbGVmdCwgYW5kXG4gICBwcF9zcGFjZV9sZWZ0ID0gcHBfbWFyZ2luLiAqKVxubGV0IHBwX3NldF9tYXhfaW5kZW50IHN0YXRlIG4gPVxuICBpZiBuID4gMSB0aGVuXG4gICAgcHBfc2V0X21pbl9zcGFjZV9sZWZ0IHN0YXRlIChzdGF0ZS5wcF9tYXJnaW4gLSBuKVxuXG5cbmxldCBwcF9nZXRfbWF4X2luZGVudCBzdGF0ZSAoKSA9IHN0YXRlLnBwX21heF9pbmRlbnRcblxubGV0IHBwX3NldF9tYXJnaW4gc3RhdGUgbiA9XG4gIGlmIG4gPj0gMSB0aGVuXG4gICAgbGV0IG4gPSBwcF9saW1pdCBuIGluXG4gICAgc3RhdGUucHBfbWFyZ2luIDwtIG47XG4gICAgbGV0IG5ld19tYXhfaW5kZW50ID1cbiAgICAgICgqIFRyeSB0byBtYWludGFpbiBtYXhfaW5kZW50IHRvIGl0cyBhY3R1YWwgdmFsdWUuICopXG4gICAgICBpZiBzdGF0ZS5wcF9tYXhfaW5kZW50IDw9IHN0YXRlLnBwX21hcmdpblxuICAgICAgdGhlbiBzdGF0ZS5wcF9tYXhfaW5kZW50IGVsc2VcbiAgICAgICgqIElmIHBvc3NpYmxlIG1haW50YWluIHBwX21pbl9zcGFjZV9sZWZ0IHRvIGl0cyBhY3R1YWwgdmFsdWUsXG4gICAgICAgICBpZiB0aGlzIGxlYWRzIHRvIGEgdG9vIHNtYWxsIG1heF9pbmRlbnQsIHRha2UgaGFsZiBvZiB0aGVcbiAgICAgICAgIG5ldyBtYXJnaW4sIGlmIGl0IGlzIGdyZWF0ZXIgdGhhbiAxLiAqKVxuICAgICAgIG1heCAobWF4IChzdGF0ZS5wcF9tYXJnaW4gLSBzdGF0ZS5wcF9taW5fc3BhY2VfbGVmdClcbiAgICAgICAgICAgICAgICAoc3RhdGUucHBfbWFyZ2luIC8gMikpIDEgaW5cbiAgICAoKiBSZWJ1aWxkIGludmFyaWFudHMuICopXG4gICAgcHBfc2V0X21heF9pbmRlbnQgc3RhdGUgbmV3X21heF9pbmRlbnRcblxuXG4oKiogR2VvbWV0cnkgZnVuY3Rpb25zIGFuZCB0eXBlcyAqKVxudHlwZSBnZW9tZXRyeSA9IHsgbWF4X2luZGVudDppbnQ7IG1hcmdpbjogaW50fVxuXG5sZXQgdmFsaWRhdGVfZ2VvbWV0cnkge21hcmdpbjsgbWF4X2luZGVudH0gPVxuICBpZiBtYXhfaW5kZW50IDwgMiB0aGVuXG4gICAgRXJyb3IgXCJtYXhfaW5kZW50IDwgMlwiXG4gIGVsc2UgaWYgbWFyZ2luIDw9IG1heF9pbmRlbnQgdGhlblxuICAgIEVycm9yIFwibWFyZ2luIDw9IG1heF9pbmRlbnRcIlxuICBlbHNlIE9rICgpXG5cbmxldCBjaGVja19nZW9tZXRyeSBnZW9tZXRyeSA9XG4gIG1hdGNoIHZhbGlkYXRlX2dlb21ldHJ5IGdlb21ldHJ5IHdpdGhcbiAgfCBPayAoKSAtPiB0cnVlXG4gIHwgRXJyb3IgXyAtPiBmYWxzZVxuXG5sZXQgcHBfZ2V0X21hcmdpbiBzdGF0ZSAoKSA9IHN0YXRlLnBwX21hcmdpblxuXG5sZXQgcHBfc2V0X2Z1bGxfZ2VvbWV0cnkgc3RhdGUge21hcmdpbjsgbWF4X2luZGVudH0gPVxuICBwcF9zZXRfbWFyZ2luIHN0YXRlIG1hcmdpbjtcbiAgcHBfc2V0X21heF9pbmRlbnQgc3RhdGUgbWF4X2luZGVudDtcbiAgKClcblxubGV0IHBwX3NldF9nZW9tZXRyeSBzdGF0ZSB+bWF4X2luZGVudCB+bWFyZ2luID1cbiAgbGV0IGdlb21ldHJ5ID0geyBtYXhfaW5kZW50OyBtYXJnaW4gfSBpblxuICBtYXRjaCB2YWxpZGF0ZV9nZW9tZXRyeSBnZW9tZXRyeSB3aXRoXG4gIHwgRXJyb3IgbXNnIC0+XG4gICAgcmFpc2UgKEludmFsaWRfYXJndW1lbnQgKFwiRm9ybWF0LnBwX3NldF9nZW9tZXRyeTogXCIgXiBtc2cpKVxuICB8IE9rICgpIC0+XG4gICAgcHBfc2V0X2Z1bGxfZ2VvbWV0cnkgc3RhdGUgZ2VvbWV0cnlcblxubGV0IHBwX3NhZmVfc2V0X2dlb21ldHJ5IHN0YXRlIH5tYXhfaW5kZW50IH5tYXJnaW4gPVxuICBsZXQgZ2VvbWV0cnkgPSB7IG1heF9pbmRlbnQ7IG1hcmdpbiB9IGluXG4gIG1hdGNoIHZhbGlkYXRlX2dlb21ldHJ5IGdlb21ldHJ5IHdpdGhcbiAgfCBFcnJvciBfbXNnIC0+XG4gICAgICgpXG4gIHwgT2sgKCkgLT5cbiAgICBwcF9zZXRfZnVsbF9nZW9tZXRyeSBzdGF0ZSBnZW9tZXRyeVxuXG5sZXQgcHBfZ2V0X2dlb21ldHJ5IHN0YXRlICgpID1cbiAgeyBtYXJnaW4gPSBwcF9nZXRfbWFyZ2luIHN0YXRlICgpOyBtYXhfaW5kZW50ID0gcHBfZ2V0X21heF9pbmRlbnQgc3RhdGUgKCkgfVxuXG5sZXQgcHBfdXBkYXRlX2dlb21ldHJ5IHN0YXRlIHVwZGF0ZSA9XG4gIGxldCBnZW9tZXRyeSA9IHBwX2dldF9nZW9tZXRyeSBzdGF0ZSAoKSBpblxuICBwcF9zZXRfZnVsbF9nZW9tZXRyeSBzdGF0ZSAodXBkYXRlIGdlb21ldHJ5KVxuXG4oKiBTZXR0aW5nIGEgZm9ybWF0dGVyIGJhc2ljIG91dHB1dCBmdW5jdGlvbnMuICopXG5sZXQgcHBfc2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zIHN0YXRlIHtcbiAgICAgIG91dF9zdHJpbmcgPSBmO1xuICAgICAgb3V0X2ZsdXNoID0gZztcbiAgICAgIG91dF9uZXdsaW5lID0gaDtcbiAgICAgIG91dF9zcGFjZXMgPSBpO1xuICAgICAgb3V0X2luZGVudCA9IGo7XG4gICAgfSA9XG4gIHN0YXRlLnBwX291dF9zdHJpbmcgPC0gZjtcbiAgc3RhdGUucHBfb3V0X2ZsdXNoIDwtIGc7XG4gIHN0YXRlLnBwX291dF9uZXdsaW5lIDwtIGg7XG4gIHN0YXRlLnBwX291dF9zcGFjZXMgPC0gaTtcbiAgc3RhdGUucHBfb3V0X2luZGVudCA8LSBqXG5cbmxldCBwcF9nZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgc3RhdGUgKCkgPSB7XG4gIG91dF9zdHJpbmcgPSBzdGF0ZS5wcF9vdXRfc3RyaW5nO1xuICBvdXRfZmx1c2ggPSBzdGF0ZS5wcF9vdXRfZmx1c2g7XG4gIG91dF9uZXdsaW5lID0gc3RhdGUucHBfb3V0X25ld2xpbmU7XG4gIG91dF9zcGFjZXMgPSBzdGF0ZS5wcF9vdXRfc3BhY2VzO1xuICBvdXRfaW5kZW50ID0gc3RhdGUucHBfb3V0X2luZGVudDtcbn1cblxuXG4oKiBTZXR0aW5nIGEgZm9ybWF0dGVyIGJhc2ljIHN0cmluZyBvdXRwdXQgYW5kIGZsdXNoIGZ1bmN0aW9ucy4gKilcbmxldCBwcF9zZXRfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgc3RhdGUgZiBnID1cbiAgc3RhdGUucHBfb3V0X3N0cmluZyA8LSBmOyBzdGF0ZS5wcF9vdXRfZmx1c2ggPC0gZ1xuXG5sZXQgcHBfZ2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIHN0YXRlICgpID1cbiAgKHN0YXRlLnBwX291dF9zdHJpbmcsIHN0YXRlLnBwX291dF9mbHVzaClcblxuXG4oKiBUaGUgZGVmYXVsdCBmdW5jdGlvbiB0byBvdXRwdXQgbmV3IGxpbmVzLiAqKVxubGV0IGRpc3BsYXlfbmV3bGluZSBzdGF0ZSAoKSA9IHN0YXRlLnBwX291dF9zdHJpbmcgXCJcXG5cIiAwICAxXG5cbigqIFRoZSBkZWZhdWx0IGZ1bmN0aW9uIHRvIG91dHB1dCBzcGFjZXMuICopXG5sZXQgYmxhbmtfbGluZSA9IFN0cmluZy5tYWtlIDgwICcgJ1xubGV0IHJlYyBkaXNwbGF5X2JsYW5rcyBzdGF0ZSBuID1cbiAgaWYgbiA+IDAgdGhlblxuICBpZiBuIDw9IDgwIHRoZW4gc3RhdGUucHBfb3V0X3N0cmluZyBibGFua19saW5lIDAgbiBlbHNlXG4gIGJlZ2luXG4gICAgc3RhdGUucHBfb3V0X3N0cmluZyBibGFua19saW5lIDAgODA7XG4gICAgZGlzcGxheV9ibGFua3Mgc3RhdGUgKG4gLSA4MClcbiAgZW5kXG5cblxuKCogVGhlIGRlZmF1bHQgZnVuY3Rpb24gdG8gb3V0cHV0IGluZGVudGF0aW9uIG9mIG5ldyBsaW5lcy4gKilcbmxldCBkaXNwbGF5X2luZGVudCA9IGRpc3BsYXlfYmxhbmtzXG5cbigqIFNldHRpbmcgYSBmb3JtYXR0ZXIgYmFzaWMgb3V0cHV0IGZ1bmN0aW9ucyBhcyBwcmludGluZyB0byBhIGdpdmVuXG4gICBbUGVydmFzaXZlLm91dF9jaGFubmVsXSB2YWx1ZS4gKilcbmxldCBwcF9zZXRfZm9ybWF0dGVyX291dF9jaGFubmVsIHN0YXRlIG9jID1cbiAgc3RhdGUucHBfb3V0X3N0cmluZyA8LSBvdXRwdXRfc3Vic3RyaW5nIG9jO1xuICBzdGF0ZS5wcF9vdXRfZmx1c2ggPC0gKGZ1biAoKSAtPiBmbHVzaCBvYyk7XG4gIHN0YXRlLnBwX291dF9uZXdsaW5lIDwtIGRpc3BsYXlfbmV3bGluZSBzdGF0ZTtcbiAgc3RhdGUucHBfb3V0X3NwYWNlcyA8LSBkaXNwbGF5X2JsYW5rcyBzdGF0ZTtcbiAgc3RhdGUucHBfb3V0X2luZGVudCA8LSBkaXNwbGF5X2luZGVudCBzdGF0ZVxuXG4oKlxuXG4gIERlZmluaW5nIHNwZWNpZmljIGZvcm1hdHRlcnNcblxuKilcblxubGV0IGRlZmF1bHRfcHBfbWFya19vcGVuX3RhZyA9IGZ1bmN0aW9uXG4gIHwgU3RyaW5nX3RhZyBzIC0+IFwiPFwiIF4gcyBeIFwiPlwiXG4gIHwgXyAtPiBcIlwiXG5sZXQgZGVmYXVsdF9wcF9tYXJrX2Nsb3NlX3RhZyA9IGZ1bmN0aW9uXG4gIHwgU3RyaW5nX3RhZyBzIC0+IFwiPC9cIiBeIHMgXiBcIj5cIlxuICB8IF8gLT4gXCJcIlxuXG5sZXQgZGVmYXVsdF9wcF9wcmludF9vcGVuX3RhZyA9IGlnbm9yZVxubGV0IGRlZmF1bHRfcHBfcHJpbnRfY2xvc2VfdGFnID0gaWdub3JlXG5cbigqIEJ1aWxkaW5nIGEgZm9ybWF0dGVyIGdpdmVuIGl0cyBiYXNpYyBvdXRwdXQgZnVuY3Rpb25zLlxuICAgT3RoZXIgZmllbGRzIGdldCByZWFzb25hYmxlIGRlZmF1bHQgdmFsdWVzLiAqKVxubGV0IHBwX21ha2VfZm9ybWF0dGVyIGYgZyBoIGkgaiA9XG4gICgqIFRoZSBpbml0aWFsIHN0YXRlIG9mIHRoZSBmb3JtYXR0ZXIgY29udGFpbnMgYSBkdW1teSBib3guICopXG4gIGxldCBwcF9xdWV1ZSA9IFF1ZXVlLmNyZWF0ZSAoKSBpblxuICBsZXQgc3lzX3RvayA9XG4gICAgeyBzaXplID0gU2l6ZS51bmtub3duOyB0b2tlbiA9IFBwX2JlZ2luICgwLCBQcF9ob3Zib3gpOyBsZW5ndGggPSAwIH0gaW5cbiAgUXVldWUuYWRkIHN5c190b2sgcHBfcXVldWU7XG4gIGxldCBzY2FuX3N0YWNrID0gU3RhY2suY3JlYXRlICgpIGluXG4gIGluaXRpYWxpemVfc2Nhbl9zdGFjayBzY2FuX3N0YWNrO1xuICBTdGFjay5wdXNoIHsgbGVmdF90b3RhbCA9IDE7IHF1ZXVlX2VsZW0gPSBzeXNfdG9rIH0gc2Nhbl9zdGFjaztcbiAgbGV0IHBwX21hcmdpbiA9IDc4XG4gIGFuZCBwcF9taW5fc3BhY2VfbGVmdCA9IDEwIGluXG4gIHtcbiAgICBwcF9zY2FuX3N0YWNrID0gc2Nhbl9zdGFjaztcbiAgICBwcF9mb3JtYXRfc3RhY2sgPSBTdGFjay5jcmVhdGUgKCk7XG4gICAgcHBfdGJveF9zdGFjayA9IFN0YWNrLmNyZWF0ZSAoKTtcbiAgICBwcF90YWdfc3RhY2sgPSBTdGFjay5jcmVhdGUgKCk7XG4gICAgcHBfbWFya19zdGFjayA9IFN0YWNrLmNyZWF0ZSAoKTtcbiAgICBwcF9tYXJnaW4gPSBwcF9tYXJnaW47XG4gICAgcHBfbWluX3NwYWNlX2xlZnQgPSBwcF9taW5fc3BhY2VfbGVmdDtcbiAgICBwcF9tYXhfaW5kZW50ID0gcHBfbWFyZ2luIC0gcHBfbWluX3NwYWNlX2xlZnQ7XG4gICAgcHBfc3BhY2VfbGVmdCA9IHBwX21hcmdpbjtcbiAgICBwcF9jdXJyZW50X2luZGVudCA9IDA7XG4gICAgcHBfaXNfbmV3X2xpbmUgPSB0cnVlO1xuICAgIHBwX2xlZnRfdG90YWwgPSAxO1xuICAgIHBwX3JpZ2h0X3RvdGFsID0gMTtcbiAgICBwcF9jdXJyX2RlcHRoID0gMTtcbiAgICBwcF9tYXhfYm94ZXMgPSBtYXhfaW50O1xuICAgIHBwX2VsbGlwc2lzID0gXCIuXCI7XG4gICAgcHBfb3V0X3N0cmluZyA9IGY7XG4gICAgcHBfb3V0X2ZsdXNoID0gZztcbiAgICBwcF9vdXRfbmV3bGluZSA9IGg7XG4gICAgcHBfb3V0X3NwYWNlcyA9IGk7XG4gICAgcHBfb3V0X2luZGVudCA9IGo7XG4gICAgcHBfcHJpbnRfdGFncyA9IGZhbHNlO1xuICAgIHBwX21hcmtfdGFncyA9IGZhbHNlO1xuICAgIHBwX21hcmtfb3Blbl90YWcgPSBkZWZhdWx0X3BwX21hcmtfb3Blbl90YWc7XG4gICAgcHBfbWFya19jbG9zZV90YWcgPSBkZWZhdWx0X3BwX21hcmtfY2xvc2VfdGFnO1xuICAgIHBwX3ByaW50X29wZW5fdGFnID0gZGVmYXVsdF9wcF9wcmludF9vcGVuX3RhZztcbiAgICBwcF9wcmludF9jbG9zZV90YWcgPSBkZWZhdWx0X3BwX3ByaW50X2Nsb3NlX3RhZztcbiAgICBwcF9xdWV1ZSA9IHBwX3F1ZXVlO1xuICB9XG5cblxuKCogQnVpbGQgYSBmb3JtYXR0ZXIgb3V0IG9mIGl0cyBvdXQgZnVuY3Rpb25zLiAqKVxubGV0IGZvcm1hdHRlcl9vZl9vdXRfZnVuY3Rpb25zIG91dF9mdW5zID1cbiAgcHBfbWFrZV9mb3JtYXR0ZXJcbiAgICBvdXRfZnVucy5vdXRfc3RyaW5nXG4gICAgb3V0X2Z1bnMub3V0X2ZsdXNoXG4gICAgb3V0X2Z1bnMub3V0X25ld2xpbmVcbiAgICBvdXRfZnVucy5vdXRfc3BhY2VzXG4gICAgb3V0X2Z1bnMub3V0X2luZGVudFxuXG5cbigqIE1ha2UgYSBmb3JtYXR0ZXIgd2l0aCBkZWZhdWx0IGZ1bmN0aW9ucyB0byBvdXRwdXQgc3BhY2VzLFxuICBpbmRlbnRhdGlvbiwgYW5kIG5ldyBsaW5lcy4gKilcbmxldCBtYWtlX2Zvcm1hdHRlciBvdXRwdXQgZmx1c2ggPVxuICBsZXQgcHBmID0gcHBfbWFrZV9mb3JtYXR0ZXIgb3V0cHV0IGZsdXNoIGlnbm9yZSBpZ25vcmUgaWdub3JlIGluXG4gIHBwZi5wcF9vdXRfbmV3bGluZSA8LSBkaXNwbGF5X25ld2xpbmUgcHBmO1xuICBwcGYucHBfb3V0X3NwYWNlcyA8LSBkaXNwbGF5X2JsYW5rcyBwcGY7XG4gIHBwZi5wcF9vdXRfaW5kZW50IDwtIGRpc3BsYXlfaW5kZW50IHBwZjtcbiAgcHBmXG5cblxuKCogTWFrZSBhIGZvcm1hdHRlciB3cml0aW5nIHRvIGEgZ2l2ZW4gW1BlcnZhc2l2ZS5vdXRfY2hhbm5lbF0gdmFsdWUuICopXG5sZXQgZm9ybWF0dGVyX29mX291dF9jaGFubmVsIG9jID1cbiAgbWFrZV9mb3JtYXR0ZXIgKG91dHB1dF9zdWJzdHJpbmcgb2MpIChmdW4gKCkgLT4gZmx1c2ggb2MpXG5cblxuKCogTWFrZSBhIGZvcm1hdHRlciB3cml0aW5nIHRvIGEgZ2l2ZW4gW0J1ZmZlci50XSB2YWx1ZS4gKilcbmxldCBmb3JtYXR0ZXJfb2ZfYnVmZmVyIGIgPVxuICBtYWtlX2Zvcm1hdHRlciAoQnVmZmVyLmFkZF9zdWJzdHJpbmcgYikgaWdub3JlXG5cblxuKCogQWxsb2NhdGluZyBidWZmZXIgZm9yIHByZXR0eS1wcmludGluZyBwdXJwb3Nlcy5cbiAgIERlZmF1bHQgYnVmZmVyIHNpemUgaXMgcHBfYnVmZmVyX3NpemUgb3IgNTEyLlxuKilcbmxldCBwcF9idWZmZXJfc2l6ZSA9IDUxMlxubGV0IHBwX21ha2VfYnVmZmVyICgpID0gQnVmZmVyLmNyZWF0ZSBwcF9idWZmZXJfc2l6ZVxuXG4oKiBUaGUgc3RhbmRhcmQgKHNoYXJlZCkgYnVmZmVyLiAqKVxubGV0IHN0ZGJ1ZiA9IHBwX21ha2VfYnVmZmVyICgpXG5cbigqIFByZWRlZmluZWQgZm9ybWF0dGVycyBzdGFuZGFyZCBmb3JtYXR0ZXIgdG8gcHJpbnRcbiAgIHRvIFtTdGRsaWIuc3Rkb3V0XSwgW1N0ZGxpYi5zdGRlcnJdLCBhbmQgeyFzdGRidWZ9LiAqKVxubGV0IHN0ZF9mb3JtYXR0ZXIgPSBmb3JtYXR0ZXJfb2Zfb3V0X2NoYW5uZWwgU3RkbGliLnN0ZG91dFxuYW5kIGVycl9mb3JtYXR0ZXIgPSBmb3JtYXR0ZXJfb2Zfb3V0X2NoYW5uZWwgU3RkbGliLnN0ZGVyclxuYW5kIHN0cl9mb3JtYXR0ZXIgPSBmb3JtYXR0ZXJfb2ZfYnVmZmVyIHN0ZGJ1ZlxuXG5cbigqIFtmbHVzaF9idWZmZXJfZm9ybWF0dGVyIGJ1ZiBwcGZdIGZsdXNoZXMgZm9ybWF0dGVyIFtwcGZdLFxuICAgdGhlbiByZXR1cm5zIHRoZSBjb250ZW50cyBvZiBidWZmZXIgW2J1Zl0gdGhhdCBpcyByZXNldC5cbiAgIEZvcm1hdHRlciBbcHBmXSBpcyBzdXBwb3NlZCB0byBwcmludCB0byBidWZmZXIgW2J1Zl0sIG90aGVyd2lzZSB0aGlzXG4gICBmdW5jdGlvbiBpcyBub3QgcmVhbGx5IHVzZWZ1bC4gKilcbmxldCBmbHVzaF9idWZmZXJfZm9ybWF0dGVyIGJ1ZiBwcGYgPVxuICBwcF9mbHVzaF9xdWV1ZSBwcGYgZmFsc2U7XG4gIGxldCBzID0gQnVmZmVyLmNvbnRlbnRzIGJ1ZiBpblxuICBCdWZmZXIucmVzZXQgYnVmO1xuICBzXG5cblxuKCogRmx1c2ggW3N0cl9mb3JtYXR0ZXJdIGFuZCBnZXQgdGhlIGNvbnRlbnRzIG9mIFtzdGRidWZdLiAqKVxubGV0IGZsdXNoX3N0cl9mb3JtYXR0ZXIgKCkgPSBmbHVzaF9idWZmZXJfZm9ybWF0dGVyIHN0ZGJ1ZiBzdHJfZm9ybWF0dGVyXG5cbigqXG4gIFN5bWJvbGljIHByZXR0eS1wcmludGluZ1xuKilcblxuKCpcbiAgU3ltYm9saWMgcHJldHR5LXByaW50aW5nIGlzIHByZXR0eS1wcmludGluZyB3aXRoIG5vIGxvdyBsZXZlbCBvdXRwdXQuXG5cbiAgV2hlbiB1c2luZyBhIHN5bWJvbGljIGZvcm1hdHRlciwgYWxsIHJlZ3VsYXIgcHJldHR5LXByaW50aW5nIGFjdGl2aXRpZXNcbiAgb2NjdXIgYnV0IG91dHB1dCBtYXRlcmlhbCBpcyBzeW1ib2xpYyBhbmQgc3RvcmVkIGluIGEgYnVmZmVyIG9mIG91dHB1dFxuICBpdGVtcy4gQXQgdGhlIGVuZCBvZiBwcmV0dHktcHJpbnRpbmcsIGZsdXNoaW5nIHRoZSBvdXRwdXQgYnVmZmVyIGFsbG93c1xuICBwb3N0LXByb2Nlc3Npbmcgb2Ygc3ltYm9saWMgb3V0cHV0IGJlZm9yZSBsb3cgbGV2ZWwgb3V0cHV0IG9wZXJhdGlvbnMuXG4qKVxuXG50eXBlIHN5bWJvbGljX291dHB1dF9pdGVtID1cbiAgfCBPdXRwdXRfZmx1c2hcbiAgfCBPdXRwdXRfbmV3bGluZVxuICB8IE91dHB1dF9zdHJpbmcgb2Ygc3RyaW5nXG4gIHwgT3V0cHV0X3NwYWNlcyBvZiBpbnRcbiAgfCBPdXRwdXRfaW5kZW50IG9mIGludFxuXG50eXBlIHN5bWJvbGljX291dHB1dF9idWZmZXIgPSB7XG4gIG11dGFibGUgc3ltYm9saWNfb3V0cHV0X2NvbnRlbnRzIDogc3ltYm9saWNfb3V0cHV0X2l0ZW0gbGlzdDtcbn1cblxubGV0IG1ha2Vfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciAoKSA9XG4gIHsgc3ltYm9saWNfb3V0cHV0X2NvbnRlbnRzID0gW10gfVxuXG5sZXQgY2xlYXJfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciBzb2IgPVxuICBzb2Iuc3ltYm9saWNfb3V0cHV0X2NvbnRlbnRzIDwtIFtdXG5cbmxldCBnZXRfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciBzb2IgPVxuICBMaXN0LnJldiBzb2Iuc3ltYm9saWNfb3V0cHV0X2NvbnRlbnRzXG5cbmxldCBmbHVzaF9zeW1ib2xpY19vdXRwdXRfYnVmZmVyIHNvYiA9XG4gIGxldCBpdGVtcyA9IGdldF9zeW1ib2xpY19vdXRwdXRfYnVmZmVyIHNvYiBpblxuICBjbGVhcl9zeW1ib2xpY19vdXRwdXRfYnVmZmVyIHNvYjtcbiAgaXRlbXNcblxubGV0IGFkZF9zeW1ib2xpY19vdXRwdXRfaXRlbSBzb2IgaXRlbSA9XG4gIHNvYi5zeW1ib2xpY19vdXRwdXRfY29udGVudHMgPC0gaXRlbSA6OiBzb2Iuc3ltYm9saWNfb3V0cHV0X2NvbnRlbnRzXG5cbmxldCBmb3JtYXR0ZXJfb2Zfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciBzb2IgPVxuICBsZXQgc3ltYm9saWNfZmx1c2ggc29iICgpID1cbiAgICBhZGRfc3ltYm9saWNfb3V0cHV0X2l0ZW0gc29iIE91dHB1dF9mbHVzaFxuICBhbmQgc3ltYm9saWNfbmV3bGluZSBzb2IgKCkgPVxuICAgIGFkZF9zeW1ib2xpY19vdXRwdXRfaXRlbSBzb2IgT3V0cHV0X25ld2xpbmVcbiAgYW5kIHN5bWJvbGljX3N0cmluZyBzb2IgcyBpIG4gPVxuICAgIGFkZF9zeW1ib2xpY19vdXRwdXRfaXRlbSBzb2IgKE91dHB1dF9zdHJpbmcgKFN0cmluZy5zdWIgcyBpIG4pKVxuICBhbmQgc3ltYm9saWNfc3BhY2VzIHNvYiBuID1cbiAgICBhZGRfc3ltYm9saWNfb3V0cHV0X2l0ZW0gc29iIChPdXRwdXRfc3BhY2VzIG4pXG4gIGFuZCBzeW1ib2xpY19pbmRlbnQgc29iIG4gPVxuICAgIGFkZF9zeW1ib2xpY19vdXRwdXRfaXRlbSBzb2IgKE91dHB1dF9pbmRlbnQgbikgaW5cblxuICBsZXQgZiA9IHN5bWJvbGljX3N0cmluZyBzb2JcbiAgYW5kIGcgPSBzeW1ib2xpY19mbHVzaCBzb2JcbiAgYW5kIGggPSBzeW1ib2xpY19uZXdsaW5lIHNvYlxuICBhbmQgaSA9IHN5bWJvbGljX3NwYWNlcyBzb2JcbiAgYW5kIGogPSBzeW1ib2xpY19pbmRlbnQgc29iIGluXG4gIHBwX21ha2VfZm9ybWF0dGVyIGYgZyBoIGkgalxuXG4oKlxuXG4gIEJhc2ljIGZ1bmN0aW9ucyBvbiB0aGUgJ3N0YW5kYXJkJyBmb3JtYXR0ZXJcbiAgKHRoZSBmb3JtYXR0ZXIgdGhhdCBwcmludHMgdG8gW1N0ZGxpYi5zdGRvdXRdKS5cblxuKilcblxubGV0IG9wZW5faGJveCA9IHBwX29wZW5faGJveCBzdGRfZm9ybWF0dGVyXG5hbmQgb3Blbl92Ym94ID0gcHBfb3Blbl92Ym94IHN0ZF9mb3JtYXR0ZXJcbmFuZCBvcGVuX2h2Ym94ID0gcHBfb3Blbl9odmJveCBzdGRfZm9ybWF0dGVyXG5hbmQgb3Blbl9ob3Zib3ggPSBwcF9vcGVuX2hvdmJveCBzdGRfZm9ybWF0dGVyXG5hbmQgb3Blbl9ib3ggPSBwcF9vcGVuX2JveCBzdGRfZm9ybWF0dGVyXG5hbmQgY2xvc2VfYm94ID0gcHBfY2xvc2VfYm94IHN0ZF9mb3JtYXR0ZXJcbmFuZCBvcGVuX3RhZyA9IHBwX29wZW5fdGFnIHN0ZF9mb3JtYXR0ZXJcbmFuZCBjbG9zZV90YWcgPSBwcF9jbG9zZV90YWcgc3RkX2Zvcm1hdHRlclxuYW5kIG9wZW5fc3RhZyA9IHBwX29wZW5fc3RhZyBzdGRfZm9ybWF0dGVyXG5hbmQgY2xvc2Vfc3RhZyA9IHBwX2Nsb3NlX3N0YWcgc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X2FzID0gcHBfcHJpbnRfYXMgc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X3N0cmluZyA9IHBwX3ByaW50X3N0cmluZyBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfaW50ID0gcHBfcHJpbnRfaW50IHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF9mbG9hdCA9IHBwX3ByaW50X2Zsb2F0IHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF9jaGFyID0gcHBfcHJpbnRfY2hhciBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfYm9vbCA9IHBwX3ByaW50X2Jvb2wgc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X2JyZWFrID0gcHBfcHJpbnRfYnJlYWsgc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X2N1dCA9IHBwX3ByaW50X2N1dCBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfc3BhY2UgPSBwcF9wcmludF9zcGFjZSBzdGRfZm9ybWF0dGVyXG5hbmQgZm9yY2VfbmV3bGluZSA9IHBwX2ZvcmNlX25ld2xpbmUgc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X2ZsdXNoID0gcHBfcHJpbnRfZmx1c2ggc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X25ld2xpbmUgPSBwcF9wcmludF9uZXdsaW5lIHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF9pZl9uZXdsaW5lID0gcHBfcHJpbnRfaWZfbmV3bGluZSBzdGRfZm9ybWF0dGVyXG5cbmFuZCBvcGVuX3Rib3ggPSBwcF9vcGVuX3Rib3ggc3RkX2Zvcm1hdHRlclxuYW5kIGNsb3NlX3Rib3ggPSBwcF9jbG9zZV90Ym94IHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF90YnJlYWsgPSBwcF9wcmludF90YnJlYWsgc3RkX2Zvcm1hdHRlclxuXG5hbmQgc2V0X3RhYiA9IHBwX3NldF90YWIgc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X3RhYiA9IHBwX3ByaW50X3RhYiBzdGRfZm9ybWF0dGVyXG5cbmFuZCBzZXRfbWFyZ2luID0gcHBfc2V0X21hcmdpbiBzdGRfZm9ybWF0dGVyXG5hbmQgZ2V0X21hcmdpbiA9IHBwX2dldF9tYXJnaW4gc3RkX2Zvcm1hdHRlclxuXG5hbmQgc2V0X21heF9pbmRlbnQgPSBwcF9zZXRfbWF4X2luZGVudCBzdGRfZm9ybWF0dGVyXG5hbmQgZ2V0X21heF9pbmRlbnQgPSBwcF9nZXRfbWF4X2luZGVudCBzdGRfZm9ybWF0dGVyXG5cbmFuZCBzZXRfZ2VvbWV0cnkgPSBwcF9zZXRfZ2VvbWV0cnkgc3RkX2Zvcm1hdHRlclxuYW5kIHNhZmVfc2V0X2dlb21ldHJ5ID0gcHBfc2FmZV9zZXRfZ2VvbWV0cnkgc3RkX2Zvcm1hdHRlclxuYW5kIGdldF9nZW9tZXRyeSA9IHBwX2dldF9nZW9tZXRyeSBzdGRfZm9ybWF0dGVyXG5hbmQgdXBkYXRlX2dlb21ldHJ5ID0gcHBfdXBkYXRlX2dlb21ldHJ5IHN0ZF9mb3JtYXR0ZXJcblxuYW5kIHNldF9tYXhfYm94ZXMgPSBwcF9zZXRfbWF4X2JveGVzIHN0ZF9mb3JtYXR0ZXJcbmFuZCBnZXRfbWF4X2JveGVzID0gcHBfZ2V0X21heF9ib3hlcyBzdGRfZm9ybWF0dGVyXG5hbmQgb3Zlcl9tYXhfYm94ZXMgPSBwcF9vdmVyX21heF9ib3hlcyBzdGRfZm9ybWF0dGVyXG5cbmFuZCBzZXRfZWxsaXBzaXNfdGV4dCA9IHBwX3NldF9lbGxpcHNpc190ZXh0IHN0ZF9mb3JtYXR0ZXJcbmFuZCBnZXRfZWxsaXBzaXNfdGV4dCA9IHBwX2dldF9lbGxpcHNpc190ZXh0IHN0ZF9mb3JtYXR0ZXJcblxuYW5kIHNldF9mb3JtYXR0ZXJfb3V0X2NoYW5uZWwgPVxuICBwcF9zZXRfZm9ybWF0dGVyX291dF9jaGFubmVsIHN0ZF9mb3JtYXR0ZXJcblxuYW5kIHNldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyA9XG4gIHBwX3NldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyBzdGRfZm9ybWF0dGVyXG5hbmQgZ2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zID1cbiAgcHBfZ2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zIHN0ZF9mb3JtYXR0ZXJcblxuYW5kIHNldF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyA9XG4gIHBwX3NldF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyBzdGRfZm9ybWF0dGVyXG5hbmQgZ2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zID1cbiAgcHBfZ2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIHN0ZF9mb3JtYXR0ZXJcblxuYW5kIHNldF9mb3JtYXR0ZXJfc3RhZ19mdW5jdGlvbnMgPVxuICBwcF9zZXRfZm9ybWF0dGVyX3N0YWdfZnVuY3Rpb25zIHN0ZF9mb3JtYXR0ZXJcbmFuZCBnZXRfZm9ybWF0dGVyX3N0YWdfZnVuY3Rpb25zID1cbiAgcHBfZ2V0X2Zvcm1hdHRlcl9zdGFnX2Z1bmN0aW9ucyBzdGRfZm9ybWF0dGVyXG5hbmQgc2V0X3ByaW50X3RhZ3MgPVxuICBwcF9zZXRfcHJpbnRfdGFncyBzdGRfZm9ybWF0dGVyXG5hbmQgZ2V0X3ByaW50X3RhZ3MgPVxuICBwcF9nZXRfcHJpbnRfdGFncyBzdGRfZm9ybWF0dGVyXG5hbmQgc2V0X21hcmtfdGFncyA9XG4gIHBwX3NldF9tYXJrX3RhZ3Mgc3RkX2Zvcm1hdHRlclxuYW5kIGdldF9tYXJrX3RhZ3MgPVxuICBwcF9nZXRfbWFya190YWdzIHN0ZF9mb3JtYXR0ZXJcbmFuZCBzZXRfdGFncyA9XG4gIHBwX3NldF90YWdzIHN0ZF9mb3JtYXR0ZXJcblxuXG4oKiBDb252ZW5pZW5jZSBmdW5jdGlvbnMgKilcblxuKCogVG8gZm9ybWF0IGEgbGlzdCAqKVxubGV0IHJlYyBwcF9wcmludF9saXN0ID8ocHBfc2VwID0gcHBfcHJpbnRfY3V0KSBwcF92IHBwZiA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gKClcbiAgfCBbdl0gLT4gcHBfdiBwcGYgdlxuICB8IHYgOjogdnMgLT5cbiAgICBwcF92IHBwZiB2O1xuICAgIHBwX3NlcCBwcGYgKCk7XG4gICAgcHBfcHJpbnRfbGlzdCB+cHBfc2VwIHBwX3YgcHBmIHZzXG5cbigqIFRvIGZvcm1hdCBhIHNlcXVlbmNlICopXG5sZXQgcmVjIHBwX3ByaW50X3NlcV9pbiB+cHBfc2VwIHBwX3YgcHBmIHNlcSA9XG4gIG1hdGNoIHNlcSAoKSB3aXRoXG4gIHwgU2VxLk5pbCAtPiAoKVxuICB8IFNlcS5Db25zICh2LCBzZXEpIC0+XG4gICAgcHBfc2VwIHBwZiAoKTtcbiAgICBwcF92IHBwZiB2O1xuICAgIHBwX3ByaW50X3NlcV9pbiB+cHBfc2VwIHBwX3YgcHBmIHNlcVxuXG5sZXQgcHBfcHJpbnRfc2VxID8ocHBfc2VwID0gcHBfcHJpbnRfY3V0KSBwcF92IHBwZiBzZXEgPVxuICBtYXRjaCBzZXEgKCkgd2l0aFxuICB8IFNlcS5OaWwgLT4gKClcbiAgfCBTZXEuQ29ucyAodiwgc2VxKSAtPlxuICAgIHBwX3YgcHBmIHY7XG4gICAgcHBfcHJpbnRfc2VxX2luIH5wcF9zZXAgcHBfdiBwcGYgc2VxXG5cbigqIFRvIGZvcm1hdCBmcmVlLWZsb3dpbmcgdGV4dCAqKVxubGV0IHBwX3ByaW50X3RleHQgcHBmIHMgPVxuICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gIGxldCBsZWZ0ID0gcmVmIDAgaW5cbiAgbGV0IHJpZ2h0ID0gcmVmIDAgaW5cbiAgbGV0IGZsdXNoICgpID1cbiAgICBwcF9wcmludF9zdHJpbmcgcHBmIChTdHJpbmcuc3ViIHMgIWxlZnQgKCFyaWdodCAtICFsZWZ0KSk7XG4gICAgaW5jciByaWdodDsgbGVmdCA6PSAhcmlnaHQ7XG4gIGluXG4gIHdoaWxlICghcmlnaHQgPD4gbGVuKSBkb1xuICAgIG1hdGNoIHMuWyFyaWdodF0gd2l0aFxuICAgICAgfCAnXFxuJyAtPlxuICAgICAgICBmbHVzaCAoKTtcbiAgICAgICAgcHBfZm9yY2VfbmV3bGluZSBwcGYgKClcbiAgICAgIHwgJyAnIC0+XG4gICAgICAgIGZsdXNoICgpOyBwcF9wcmludF9zcGFjZSBwcGYgKClcbiAgICAgICgqIHRoZXJlIGlzIG5vIHNwZWNpZmljIHN1cHBvcnQgZm9yICdcXHQnXG4gICAgICAgICBhcyBpdCBpcyB1bmNsZWFyIHdoYXQgYSByaWdodCBzZW1hbnRpY3Mgd291bGQgYmUgKilcbiAgICAgIHwgXyAtPiBpbmNyIHJpZ2h0XG4gIGRvbmU7XG4gIGlmICFsZWZ0IDw+IGxlbiB0aGVuIGZsdXNoICgpXG5cbmxldCBwcF9wcmludF9vcHRpb24gPyhub25lID0gZnVuIF8gKCkgLT4gKCkpIHBwX3YgcHBmID0gZnVuY3Rpb25cbnwgTm9uZSAtPiBub25lIHBwZiAoKVxufCBTb21lIHYgLT4gcHBfdiBwcGYgdlxuXG5sZXQgcHBfcHJpbnRfcmVzdWx0IH5vayB+ZXJyb3IgcHBmID0gZnVuY3Rpb25cbnwgT2sgdiAtPiBvayBwcGYgdlxufCBFcnJvciBlIC0+IGVycm9yIHBwZiBlXG5cbiAoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbmxldCBjb21wdXRlX3RhZyBvdXRwdXQgdGFnX2FjYyA9XG4gIGxldCBidWYgPSBCdWZmZXIuY3JlYXRlIDE2IGluXG4gIGxldCBwcGYgPSBmb3JtYXR0ZXJfb2ZfYnVmZmVyIGJ1ZiBpblxuICBvdXRwdXQgcHBmIHRhZ19hY2M7XG4gIHBwX3ByaW50X2ZsdXNoIHBwZiAoKTtcbiAgbGV0IGxlbiA9IEJ1ZmZlci5sZW5ndGggYnVmIGluXG4gIGlmIGxlbiA8IDIgdGhlbiBCdWZmZXIuY29udGVudHMgYnVmXG4gIGVsc2UgQnVmZmVyLnN1YiBidWYgMSAobGVuIC0gMilcblxuICgqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4gIERlZmluaW5nIGNvbnRpbnVhdGlvbnMgdG8gYmUgcGFzc2VkIGFzIGFyZ3VtZW50cyBvZlxuICBDYW1saW50ZXJuYWxGb3JtYXQubWFrZV9wcmludGYuXG5cbiAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbm9wZW4gQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzXG5vcGVuIENhbWxpbnRlcm5hbEZvcm1hdFxuXG4oKiBJbnRlcnByZXQgYSBmb3JtYXR0aW5nIGVudGl0eSBvbiBhIGZvcm1hdHRlci4gKilcbmxldCBvdXRwdXRfZm9ybWF0dGluZ19saXQgcHBmIGZtdGluZ19saXQgPSBtYXRjaCBmbXRpbmdfbGl0IHdpdGhcbiAgfCBDbG9zZV9ib3ggICAgICAgICAgICAgICAgIC0+IHBwX2Nsb3NlX2JveCBwcGYgKClcbiAgfCBDbG9zZV90YWcgICAgICAgICAgICAgICAgIC0+IHBwX2Nsb3NlX3RhZyBwcGYgKClcbiAgfCBCcmVhayAoXywgd2lkdGgsIG9mZnNldCkgIC0+IHBwX3ByaW50X2JyZWFrIHBwZiB3aWR0aCBvZmZzZXRcbiAgfCBGRmx1c2ggICAgICAgICAgICAgICAgICAgIC0+IHBwX3ByaW50X2ZsdXNoIHBwZiAoKVxuICB8IEZvcmNlX25ld2xpbmUgICAgICAgICAgICAgLT4gcHBfZm9yY2VfbmV3bGluZSBwcGYgKClcbiAgfCBGbHVzaF9uZXdsaW5lICAgICAgICAgICAgIC0+IHBwX3ByaW50X25ld2xpbmUgcHBmICgpXG4gIHwgTWFnaWNfc2l6ZSAoXywgXykgICAgICAgICAtPiAoKVxuICB8IEVzY2FwZWRfYXQgICAgICAgICAgICAgICAgLT4gcHBfcHJpbnRfY2hhciBwcGYgJ0AnXG4gIHwgRXNjYXBlZF9wZXJjZW50ICAgICAgICAgICAtPiBwcF9wcmludF9jaGFyIHBwZiAnJSdcbiAgfCBTY2FuX2luZGljIGMgICAgICAgICAgICAgIC0+IHBwX3ByaW50X2NoYXIgcHBmICdAJzsgcHBfcHJpbnRfY2hhciBwcGYgY1xuXG4oKiBSZWN1cnNpdmVseSBvdXRwdXQgYW4gXCJhY2N1bXVsYXRvclwiIGNvbnRhaW5pbmcgYSByZXZlcnNlZCBsaXN0IG9mXG4gICBwcmludGluZyBlbnRpdGllcyAoc3RyaW5nLCBjaGFyLCBmbHVzLCAuLi4pIGluIGFuIG91dHB1dF9zdHJlYW0uICopXG4oKiBEaWZmZXIgZnJvbSBQcmludGYub3V0cHV0X2FjYyBieSB0aGUgaW50ZXJwcmV0YXRpb24gb2YgZm9ybWF0dGluZy4gKilcbigqIFVzZWQgYXMgYSBjb250aW51YXRpb24gb2YgQ2FtbGludGVybmFsRm9ybWF0Lm1ha2VfcHJpbnRmLiAqKVxubGV0IHJlYyBvdXRwdXRfYWNjIHBwZiBhY2MgPSBtYXRjaCBhY2Mgd2l0aFxuICB8IEFjY19zdHJpbmdfbGl0ZXJhbCAoQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBNYWdpY19zaXplIChfLCBzaXplKSksIHMpXG4gIHwgQWNjX2RhdGFfc3RyaW5nIChBY2NfZm9ybWF0dGluZ19saXQgKHAsIE1hZ2ljX3NpemUgKF8sIHNpemUpKSwgcykgLT5cbiAgICBvdXRwdXRfYWNjIHBwZiBwO1xuICAgIHBwX3ByaW50X2FzX3NpemUgcHBmIChTaXplLm9mX2ludCBzaXplKSBzO1xuICB8IEFjY19jaGFyX2xpdGVyYWwgKEFjY19mb3JtYXR0aW5nX2xpdCAocCwgTWFnaWNfc2l6ZSAoXywgc2l6ZSkpLCBjKVxuICB8IEFjY19kYXRhX2NoYXIgKEFjY19mb3JtYXR0aW5nX2xpdCAocCwgTWFnaWNfc2l6ZSAoXywgc2l6ZSkpLCBjKSAtPlxuICAgIG91dHB1dF9hY2MgcHBmIHA7XG4gICAgcHBfcHJpbnRfYXNfc2l6ZSBwcGYgKFNpemUub2ZfaW50IHNpemUpIChTdHJpbmcubWFrZSAxIGMpO1xuICB8IEFjY19mb3JtYXR0aW5nX2xpdCAocCwgZikgLT5cbiAgICBvdXRwdXRfYWNjIHBwZiBwO1xuICAgIG91dHB1dF9mb3JtYXR0aW5nX2xpdCBwcGYgZjtcbiAgfCBBY2NfZm9ybWF0dGluZ19nZW4gKHAsIEFjY19vcGVuX3RhZyBhY2MnKSAtPlxuICAgIG91dHB1dF9hY2MgcHBmIHA7XG4gICAgcHBfb3Blbl9zdGFnIHBwZiAoU3RyaW5nX3RhZyAoY29tcHV0ZV90YWcgb3V0cHV0X2FjYyBhY2MnKSlcbiAgfCBBY2NfZm9ybWF0dGluZ19nZW4gKHAsIEFjY19vcGVuX2JveCBhY2MnKSAtPlxuICAgIG91dHB1dF9hY2MgcHBmIHA7XG4gICAgbGV0IChpbmRlbnQsIGJ0eSkgPSBvcGVuX2JveF9vZl9zdHJpbmcgKGNvbXB1dGVfdGFnIG91dHB1dF9hY2MgYWNjJykgaW5cbiAgICBwcF9vcGVuX2JveF9nZW4gcHBmIGluZGVudCBidHlcbiAgfCBBY2Nfc3RyaW5nX2xpdGVyYWwgKHAsIHMpXG4gIHwgQWNjX2RhdGFfc3RyaW5nIChwLCBzKSAgIC0+IG91dHB1dF9hY2MgcHBmIHA7IHBwX3ByaW50X3N0cmluZyBwcGYgcztcbiAgfCBBY2NfY2hhcl9saXRlcmFsIChwLCBjKVxuICB8IEFjY19kYXRhX2NoYXIgKHAsIGMpICAgICAtPiBvdXRwdXRfYWNjIHBwZiBwOyBwcF9wcmludF9jaGFyIHBwZiBjO1xuICB8IEFjY19kZWxheSAocCwgZikgICAgICAgICAtPiBvdXRwdXRfYWNjIHBwZiBwOyBmIHBwZjtcbiAgfCBBY2NfZmx1c2ggcCAgICAgICAgICAgICAgLT4gb3V0cHV0X2FjYyBwcGYgcDsgcHBfcHJpbnRfZmx1c2ggcHBmICgpO1xuICB8IEFjY19pbnZhbGlkX2FyZyAocCwgbXNnKSAtPiBvdXRwdXRfYWNjIHBwZiBwOyBpbnZhbGlkX2FyZyBtc2c7XG4gIHwgRW5kX29mX2FjYyAgICAgICAgICAgICAgIC0+ICgpXG5cbigqIFJlY3Vyc2l2ZWx5IG91dHB1dCBhbiBcImFjY3VtdWxhdG9yXCIgY29udGFpbmluZyBhIHJldmVyc2VkIGxpc3Qgb2ZcbiAgIHByaW50aW5nIGVudGl0aWVzIChzdHJpbmcsIGNoYXIsIGZsdXMsIC4uLikgaW4gYSBidWZmZXIuICopXG4oKiBEaWZmZXIgZnJvbSBQcmludGYuYnVmcHV0X2FjYyBieSB0aGUgaW50ZXJwcmV0YXRpb24gb2YgZm9ybWF0dGluZy4gKilcbigqIFVzZWQgYXMgYSBjb250aW51YXRpb24gb2YgQ2FtbGludGVybmFsRm9ybWF0Lm1ha2VfcHJpbnRmLiAqKVxubGV0IHJlYyBzdHJwdXRfYWNjIHBwZiBhY2MgPSBtYXRjaCBhY2Mgd2l0aFxuICB8IEFjY19zdHJpbmdfbGl0ZXJhbCAoQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBNYWdpY19zaXplIChfLCBzaXplKSksIHMpXG4gIHwgQWNjX2RhdGFfc3RyaW5nIChBY2NfZm9ybWF0dGluZ19saXQgKHAsIE1hZ2ljX3NpemUgKF8sIHNpemUpKSwgcykgLT5cbiAgICBzdHJwdXRfYWNjIHBwZiBwO1xuICAgIHBwX3ByaW50X2FzX3NpemUgcHBmIChTaXplLm9mX2ludCBzaXplKSBzO1xuICB8IEFjY19jaGFyX2xpdGVyYWwgKEFjY19mb3JtYXR0aW5nX2xpdCAocCwgTWFnaWNfc2l6ZSAoXywgc2l6ZSkpLCBjKVxuICB8IEFjY19kYXRhX2NoYXIgKEFjY19mb3JtYXR0aW5nX2xpdCAocCwgTWFnaWNfc2l6ZSAoXywgc2l6ZSkpLCBjKSAtPlxuICAgIHN0cnB1dF9hY2MgcHBmIHA7XG4gICAgcHBfcHJpbnRfYXNfc2l6ZSBwcGYgKFNpemUub2ZfaW50IHNpemUpIChTdHJpbmcubWFrZSAxIGMpO1xuICB8IEFjY19kZWxheSAoQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBNYWdpY19zaXplIChfLCBzaXplKSksIGYpIC0+XG4gICAgc3RycHV0X2FjYyBwcGYgcDtcbiAgICBwcF9wcmludF9hc19zaXplIHBwZiAoU2l6ZS5vZl9pbnQgc2l6ZSkgKGYgKCkpO1xuICB8IEFjY19mb3JtYXR0aW5nX2xpdCAocCwgZikgLT5cbiAgICBzdHJwdXRfYWNjIHBwZiBwO1xuICAgIG91dHB1dF9mb3JtYXR0aW5nX2xpdCBwcGYgZjtcbiAgfCBBY2NfZm9ybWF0dGluZ19nZW4gKHAsIEFjY19vcGVuX3RhZyBhY2MnKSAtPlxuICAgIHN0cnB1dF9hY2MgcHBmIHA7XG4gICAgcHBfb3Blbl9zdGFnIHBwZiAoU3RyaW5nX3RhZyAoY29tcHV0ZV90YWcgc3RycHV0X2FjYyBhY2MnKSlcbiAgfCBBY2NfZm9ybWF0dGluZ19nZW4gKHAsIEFjY19vcGVuX2JveCBhY2MnKSAtPlxuICAgIHN0cnB1dF9hY2MgcHBmIHA7XG4gICAgbGV0IChpbmRlbnQsIGJ0eSkgPSBvcGVuX2JveF9vZl9zdHJpbmcgKGNvbXB1dGVfdGFnIHN0cnB1dF9hY2MgYWNjJykgaW5cbiAgICBwcF9vcGVuX2JveF9nZW4gcHBmIGluZGVudCBidHlcbiAgfCBBY2Nfc3RyaW5nX2xpdGVyYWwgKHAsIHMpXG4gIHwgQWNjX2RhdGFfc3RyaW5nIChwLCBzKSAgIC0+IHN0cnB1dF9hY2MgcHBmIHA7IHBwX3ByaW50X3N0cmluZyBwcGYgcztcbiAgfCBBY2NfY2hhcl9saXRlcmFsIChwLCBjKVxuICB8IEFjY19kYXRhX2NoYXIgKHAsIGMpICAgICAtPiBzdHJwdXRfYWNjIHBwZiBwOyBwcF9wcmludF9jaGFyIHBwZiBjO1xuICB8IEFjY19kZWxheSAocCwgZikgICAgICAgICAtPiBzdHJwdXRfYWNjIHBwZiBwOyBwcF9wcmludF9zdHJpbmcgcHBmIChmICgpKTtcbiAgfCBBY2NfZmx1c2ggcCAgICAgICAgICAgICAgLT4gc3RycHV0X2FjYyBwcGYgcDsgcHBfcHJpbnRfZmx1c2ggcHBmICgpO1xuICB8IEFjY19pbnZhbGlkX2FyZyAocCwgbXNnKSAtPiBzdHJwdXRfYWNjIHBwZiBwOyBpbnZhbGlkX2FyZyBtc2c7XG4gIHwgRW5kX29mX2FjYyAgICAgICAgICAgICAgIC0+ICgpXG5cbigqXG5cbiAgRGVmaW5pbmcgW2ZwcmludGZdIGFuZCB2YXJpb3VzIGZsYXZvcnMgb2YgW2ZwcmludGZdLlxuXG4qKVxuXG5sZXQga2ZwcmludGYgayBwcGYgKEZvcm1hdCAoZm10LCBfKSkgPVxuICBtYWtlX3ByaW50ZlxuICAgIChmdW4gYWNjIC0+IG91dHB1dF9hY2MgcHBmIGFjYzsgayBwcGYpXG4gICAgRW5kX29mX2FjYyBmbXRcblxuYW5kIGlrZnByaW50ZiBrIHBwZiAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIG1ha2VfaXByaW50ZiBrIHBwZiBmbXRcblxubGV0IGlmcHJpbnRmIF9wcGYgKEZvcm1hdCAoZm10LCBfKSkgPVxuICBtYWtlX2lwcmludGYgaWdub3JlICgpIGZtdFxuXG5sZXQgZnByaW50ZiBwcGYgPSBrZnByaW50ZiBpZ25vcmUgcHBmXG5sZXQgcHJpbnRmIGZtdCA9IGZwcmludGYgc3RkX2Zvcm1hdHRlciBmbXRcbmxldCBlcHJpbnRmIGZtdCA9IGZwcmludGYgZXJyX2Zvcm1hdHRlciBmbXRcblxubGV0IGtkcHJpbnRmIGsgKEZvcm1hdCAoZm10LCBfKSkgPVxuICBtYWtlX3ByaW50ZlxuICAgIChmdW4gYWNjIC0+IGsgKGZ1biBwcGYgLT4gb3V0cHV0X2FjYyBwcGYgYWNjKSlcbiAgICBFbmRfb2ZfYWNjIGZtdFxuXG5sZXQgZHByaW50ZiBmbXQgPSBrZHByaW50ZiAoZnVuIGkgLT4gaSkgZm10XG5cbmxldCBrc3ByaW50ZiBrIChGb3JtYXQgKGZtdCwgXykpID1cbiAgbGV0IGIgPSBwcF9tYWtlX2J1ZmZlciAoKSBpblxuICBsZXQgcHBmID0gZm9ybWF0dGVyX29mX2J1ZmZlciBiIGluXG4gIGxldCBrIGFjYyA9XG4gICAgc3RycHV0X2FjYyBwcGYgYWNjO1xuICAgIGsgKGZsdXNoX2J1ZmZlcl9mb3JtYXR0ZXIgYiBwcGYpIGluXG4gIG1ha2VfcHJpbnRmIGsgRW5kX29mX2FjYyBmbXRcblxuXG5sZXQgc3ByaW50ZiBmbXQgPSBrc3ByaW50ZiBpZCBmbXRcblxubGV0IGthc3ByaW50ZiBrIChGb3JtYXQgKGZtdCwgXykpID1cbiAgbGV0IGIgPSBwcF9tYWtlX2J1ZmZlciAoKSBpblxuICBsZXQgcHBmID0gZm9ybWF0dGVyX29mX2J1ZmZlciBiIGluXG4gIGxldCBrIGFjYyA9XG4gICAgb3V0cHV0X2FjYyBwcGYgYWNjO1xuICAgIGsgKGZsdXNoX2J1ZmZlcl9mb3JtYXR0ZXIgYiBwcGYpIGluXG4gIG1ha2VfcHJpbnRmIGsgRW5kX29mX2FjYyBmbXRcblxuXG5sZXQgYXNwcmludGYgZm10ID0ga2FzcHJpbnRmIGlkIGZtdFxuXG4oKiBGbHVzaGluZyBzdGFuZGFyZCBmb3JtYXR0ZXJzIGF0IGVuZCBvZiBleGVjdXRpb24uICopXG5cbmxldCBmbHVzaF9zdGFuZGFyZF9mb3JtYXR0ZXJzICgpID1cbiAgcHBfcHJpbnRfZmx1c2ggc3RkX2Zvcm1hdHRlciAoKTtcbiAgcHBfcHJpbnRfZmx1c2ggZXJyX2Zvcm1hdHRlciAoKVxuXG5sZXQgKCkgPSBhdF9leGl0IGZsdXNoX3N0YW5kYXJkX2Zvcm1hdHRlcnNcblxuKCpcblxuICBEZXByZWNhdGVkIHN0dWZmLlxuXG4qKVxuXG4oKiBEZXByZWNhdGVkIDogc3Vic3VtZWQgYnkgcHBfc2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zICopXG5sZXQgcHBfc2V0X2FsbF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyBzdGF0ZVxuICAgIH5vdXQ6ZiB+Zmx1c2g6ZyB+bmV3bGluZTpoIH5zcGFjZXM6aSA9XG4gIHBwX3NldF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyBzdGF0ZSBmIGc7XG4gIHN0YXRlLnBwX291dF9uZXdsaW5lIDwtIGg7XG4gIHN0YXRlLnBwX291dF9zcGFjZXMgPC0gaVxuXG4oKiBEZXByZWNhdGVkIDogc3Vic3VtZWQgYnkgcHBfZ2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zICopXG5sZXQgcHBfZ2V0X2FsbF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyBzdGF0ZSAoKSA9XG4gIChzdGF0ZS5wcF9vdXRfc3RyaW5nLCBzdGF0ZS5wcF9vdXRfZmx1c2gsXG4gICBzdGF0ZS5wcF9vdXRfbmV3bGluZSwgc3RhdGUucHBfb3V0X3NwYWNlcylcblxuXG4oKiBEZXByZWNhdGVkIDogc3Vic3VtZWQgYnkgc2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zICopXG5sZXQgc2V0X2FsbF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyA9XG4gIHBwX3NldF9hbGxfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgc3RkX2Zvcm1hdHRlclxuXG5cbigqIERlcHJlY2F0ZWQgOiBzdWJzdW1lZCBieSBnZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgKilcbmxldCBnZXRfYWxsX2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zID1cbiAgcHBfZ2V0X2FsbF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyBzdGRfZm9ybWF0dGVyXG5cblxuKCogRGVwcmVjYXRlZCA6IGVycm9yIHByb25lIGZ1bmN0aW9uLCBkbyBub3QgdXNlIGl0LlxuICAgVGhpcyBmdW5jdGlvbiBpcyBuZWl0aGVyIGNvbXBvc2l0aW9uYWwgbm9yIGluY3JlbWVudGFsLCBzaW5jZSBpdCBmbHVzaGVzXG4gICB0aGUgcHJldHR5LXByaW50ZXIgcXVldWUgYXQgZWFjaCBjYWxsLlxuICAgVG8gZ2V0IHRoZSBzYW1lIGZ1bmN0aW9uYWxpdHksIGRlZmluZSBhIGZvcm1hdHRlciBvZiB5b3VyIG93biB3cml0aW5nIHRvXG4gICB0aGUgYnVmZmVyIGFyZ3VtZW50LCBhcyBpblxuICAgbGV0IHBwZiA9IGZvcm1hdHRlcl9vZl9idWZmZXIgYlxuICAgdGhlbiB1c2UgeyFmcHJpbnRmIHBwZn0gYXMgdXN1YWwuICopXG5sZXQgYnByaW50ZiBiIChGb3JtYXQgKGZtdCwgXykgOiAoJ2EsIGZvcm1hdHRlciwgdW5pdCkgZm9ybWF0KSA9XG4gIGxldCBwcGYgPSBmb3JtYXR0ZXJfb2ZfYnVmZmVyIGIgaW5cbiAgbGV0IGsgYWNjID0gb3V0cHV0X2FjYyBwcGYgYWNjOyBwcF9mbHVzaF9xdWV1ZSBwcGYgZmFsc2UgaW5cbiAgbWFrZV9wcmludGYgayBFbmRfb2ZfYWNjIGZtdFxuXG5cbigqIERlcHJlY2F0ZWQgOiBhbGlhcyBmb3Iga3NwcmludGYuICopXG5sZXQga3ByaW50ZiA9IGtzcHJpbnRmXG5cblxuXG4oKiBEZXByZWNhdGVkIHRhZyBmdW5jdGlvbnMgKilcblxudHlwZSBmb3JtYXR0ZXJfdGFnX2Z1bmN0aW9ucyA9IHtcbiAgbWFya19vcGVuX3RhZyA6IHRhZyAtPiBzdHJpbmc7XG4gIG1hcmtfY2xvc2VfdGFnIDogdGFnIC0+IHN0cmluZztcbiAgcHJpbnRfb3Blbl90YWcgOiB0YWcgLT4gdW5pdDtcbiAgcHJpbnRfY2xvc2VfdGFnIDogdGFnIC0+IHVuaXQ7XG59XG5cblxubGV0IHBwX3NldF9mb3JtYXR0ZXJfdGFnX2Z1bmN0aW9ucyBzdGF0ZSB7XG4gICAgIG1hcmtfb3Blbl90YWcgPSBtb3Q7XG4gICAgIG1hcmtfY2xvc2VfdGFnID0gbWN0O1xuICAgICBwcmludF9vcGVuX3RhZyA9IHBvdDtcbiAgICAgcHJpbnRfY2xvc2VfdGFnID0gcGN0O1xuICAgfSA9XG4gIGxldCBzdHJpbmdpZnkgZiBlID0gZnVuY3Rpb24gU3RyaW5nX3RhZyBzIC0+IGYgcyB8IF8gLT4gZSBpblxuICBzdGF0ZS5wcF9tYXJrX29wZW5fdGFnIDwtIHN0cmluZ2lmeSBtb3QgXCJcIjtcbiAgc3RhdGUucHBfbWFya19jbG9zZV90YWcgPC0gc3RyaW5naWZ5IG1jdCBcIlwiO1xuICBzdGF0ZS5wcF9wcmludF9vcGVuX3RhZyA8LSBzdHJpbmdpZnkgcG90ICgpO1xuICBzdGF0ZS5wcF9wcmludF9jbG9zZV90YWcgPC0gc3RyaW5naWZ5IHBjdCAoKVxuXG5sZXQgcHBfZ2V0X2Zvcm1hdHRlcl90YWdfZnVuY3Rpb25zIGZtdCAoKSA9XG4gIGxldCBmdW5zID0gcHBfZ2V0X2Zvcm1hdHRlcl9zdGFnX2Z1bmN0aW9ucyBmbXQgKCkgaW5cbiAgbGV0IG1hcmtfb3Blbl90YWcgcyA9IGZ1bnMubWFya19vcGVuX3N0YWcgKFN0cmluZ190YWcgcykgaW5cbiAgbGV0IG1hcmtfY2xvc2VfdGFnIHMgPSBmdW5zLm1hcmtfY2xvc2Vfc3RhZyAoU3RyaW5nX3RhZyBzKSBpblxuICBsZXQgcHJpbnRfb3Blbl90YWcgcyA9IGZ1bnMucHJpbnRfb3Blbl9zdGFnIChTdHJpbmdfdGFnIHMpIGluXG4gIGxldCBwcmludF9jbG9zZV90YWcgcyA9IGZ1bnMucHJpbnRfY2xvc2Vfc3RhZyAoU3RyaW5nX3RhZyBzKSBpblxuICB7bWFya19vcGVuX3RhZzsgbWFya19jbG9zZV90YWc7IHByaW50X29wZW5fdGFnOyBwcmludF9jbG9zZV90YWd9XG5cbmxldCBzZXRfZm9ybWF0dGVyX3RhZ19mdW5jdGlvbnMgPVxuICBwcF9zZXRfZm9ybWF0dGVyX3RhZ19mdW5jdGlvbnMgc3RkX2Zvcm1hdHRlclxuYW5kIGdldF9mb3JtYXR0ZXJfdGFnX2Z1bmN0aW9ucyA9XG4gIHBwX2dldF9mb3JtYXR0ZXJfdGFnX2Z1bmN0aW9ucyBzdGRfZm9ybWF0dGVyXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBQaWVycmUgV2VpcywgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDAyIEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbm9wZW4gQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzXG5vcGVuIENhbWxpbnRlcm5hbEZvcm1hdFxuXG4oKiBhbGlhcyB0byBhdm9pZCB3YXJuaW5nIGZvciBhbWJpZ3VpdHkgYmV0d2VlblxuICAgU3RkbGliLmZvcm1hdDZcbiAgIGFuZCBDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3MuZm9ybWF0NlxuXG4gICAodGhlIGZvcm1lciBpcyBpbiBmYWN0IGFuIGFsaWFzIGZvciB0aGUgbGF0dGVyLFxuICAgIGJ1dCB0aGUgYW1iaWd1aXR5IHdhcm5pbmcgZG9lc24ndCBjYXJlKVxuKilcbnR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgPVxuICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgU3RkbGliLmZvcm1hdDZcblxuXG4oKiBUaGUgcnVuLXRpbWUgbGlicmFyeSBmb3Igc2Nhbm5lcnMuICopXG5cbigqIFNjYW5uaW5nIGJ1ZmZlcnMuICopXG5tb2R1bGUgdHlwZSBTQ0FOTklORyA9IHNpZ1xuXG4gIHR5cGUgaW5fY2hhbm5lbFxuXG4gIHR5cGUgc2NhbmJ1ZiA9IGluX2NoYW5uZWxcblxuICB0eXBlIGZpbGVfbmFtZSA9IHN0cmluZ1xuXG4gIHZhbCBzdGRpbiA6IGluX2NoYW5uZWxcbiAgKCogVGhlIHNjYW5uaW5nIGJ1ZmZlciByZWFkaW5nIGZyb20gW1N0ZGxpYi5zdGRpbl0uXG4gICAgIFtzdGRpYl0gaXMgZXF1aXZhbGVudCB0byBbU2Nhbm5pbmcuZnJvbV9jaGFubmVsIFN0ZGxpYi5zdGRpbl0uICopXG5cbiAgdmFsIHN0ZGliIDogaW5fY2hhbm5lbFxuICAoKiBBbiBhbGlhcyBmb3IgW1NjYW5mLnN0ZGluXSwgdGhlIHNjYW5uaW5nIGJ1ZmZlciByZWFkaW5nIGZyb21cbiAgICAgW1N0ZGxpYi5zdGRpbl0uICopXG5cbiAgdmFsIG5leHRfY2hhciA6IHNjYW5idWYgLT4gY2hhclxuICAoKiBbU2Nhbm5pbmcubmV4dF9jaGFyIGliXSBhZHZhbmNlIHRoZSBzY2FubmluZyBidWZmZXIgZm9yXG4gICAgIG9uZSBjaGFyYWN0ZXIuXG4gICAgIElmIG5vIG1vcmUgY2hhcmFjdGVyIGNhbiBiZSByZWFkLCBzZXRzIGEgZW5kIG9mIGZpbGUgY29uZGl0aW9uIGFuZFxuICAgICByZXR1cm5zICdcXDAwMCcuICopXG5cbiAgdmFsIGludmFsaWRhdGVfY3VycmVudF9jaGFyIDogc2NhbmJ1ZiAtPiB1bml0XG4gICgqIFtTY2FubmluZy5pbnZhbGlkYXRlX2N1cnJlbnRfY2hhciBpYl0gbWFyayB0aGUgY3VycmVudF9jaGFyIGFzIGFscmVhZHlcbiAgICAgc2Nhbm5lZC4gKilcblxuICB2YWwgcGVla19jaGFyIDogc2NhbmJ1ZiAtPiBjaGFyXG4gICgqIFtTY2FubmluZy5wZWVrX2NoYXIgaWJdIHJldHVybnMgdGhlIGN1cnJlbnQgY2hhciBhdmFpbGFibGUgaW5cbiAgICAgdGhlIGJ1ZmZlciBvciByZWFkcyBvbmUgaWYgbmVjZXNzYXJ5ICh3aGVuIHRoZSBjdXJyZW50IGNoYXJhY3RlciBpc1xuICAgICBhbHJlYWR5IHNjYW5uZWQpLlxuICAgICBJZiBubyBjaGFyYWN0ZXIgY2FuIGJlIHJlYWQsIHNldHMgYW4gZW5kIG9mIGZpbGUgY29uZGl0aW9uIGFuZFxuICAgICByZXR1cm5zICdcXDAwMCcuICopXG5cbiAgdmFsIGNoZWNrZWRfcGVla19jaGFyIDogc2NhbmJ1ZiAtPiBjaGFyXG4gICgqIFNhbWUgYXMgW1NjYW5uaW5nLnBlZWtfY2hhcl0gYWJvdmUgYnV0IGFsd2F5cyByZXR1cm5zIGEgdmFsaWQgY2hhciBvclxuICAgICBmYWlsczogaW5zdGVhZCBvZiByZXR1cm5pbmcgYSBudWxsIGNoYXIgd2hlbiB0aGUgcmVhZGluZyBtZXRob2Qgb2YgdGhlXG4gICAgIGlucHV0IGJ1ZmZlciBoYXMgcmVhY2hlZCBhbiBlbmQgb2YgZmlsZSwgdGhlIGZ1bmN0aW9uIHJhaXNlcyBleGNlcHRpb25cbiAgICAgW0VuZF9vZl9maWxlXS4gKilcblxuICB2YWwgc3RvcmVfY2hhciA6IGludCAtPiBzY2FuYnVmIC0+IGNoYXIgLT4gaW50XG4gICgqIFtTY2FubmluZy5zdG9yZV9jaGFyIGxpbSBpYiBjXSBhZGRzIFtjXSB0byB0aGUgdG9rZW4gYnVmZmVyXG4gICAgIG9mIHRoZSBzY2FubmluZyBidWZmZXIgW2liXS4gSXQgYWxzbyBhZHZhbmNlcyB0aGUgc2Nhbm5pbmcgYnVmZmVyIGZvclxuICAgICBvbmUgY2hhcmFjdGVyIGFuZCByZXR1cm5zIFtsaW0gLSAxXSwgaW5kaWNhdGluZyB0aGUgbmV3IGxpbWl0IGZvciB0aGVcbiAgICAgbGVuZ3RoIG9mIHRoZSBjdXJyZW50IHRva2VuLiAqKVxuXG4gIHZhbCBza2lwX2NoYXIgOiBpbnQgLT4gc2NhbmJ1ZiAtPiBpbnRcbiAgKCogW1NjYW5uaW5nLnNraXBfY2hhciBsaW0gaWJdIGlnbm9yZXMgdGhlIGN1cnJlbnQgY2hhcmFjdGVyLiAqKVxuXG4gIHZhbCBpZ25vcmVfY2hhciA6IGludCAtPiBzY2FuYnVmIC0+IGludFxuICAoKiBbU2Nhbm5pbmcuaWdub3JlX2NoYXIgaWIgbGltXSBpZ25vcmVzIHRoZSBjdXJyZW50IGNoYXJhY3RlciBhbmRcbiAgICAgZGVjcmVtZW50cyB0aGUgbGltaXQuICopXG5cbiAgdmFsIHRva2VuIDogc2NhbmJ1ZiAtPiBzdHJpbmdcbiAgKCogW1NjYW5uaW5nLnRva2VuIGliXSByZXR1cm5zIHRoZSBzdHJpbmcgc3RvcmVkIGludG8gdGhlIHRva2VuXG4gICAgIGJ1ZmZlciBvZiB0aGUgc2Nhbm5pbmcgYnVmZmVyOiBpdCByZXR1cm5zIHRoZSB0b2tlbiBtYXRjaGVkIGJ5IHRoZVxuICAgICBmb3JtYXQuICopXG5cbiAgdmFsIHJlc2V0X3Rva2VuIDogc2NhbmJ1ZiAtPiB1bml0XG4gICgqIFtTY2FubmluZy5yZXNldF90b2tlbiBpYl0gcmVzZXRzIHRoZSB0b2tlbiBidWZmZXIgb2ZcbiAgICAgdGhlIGdpdmVuIHNjYW5uaW5nIGJ1ZmZlci4gKilcblxuICB2YWwgY2hhcl9jb3VudCA6IHNjYW5idWYgLT4gaW50XG4gICgqIFtTY2FubmluZy5jaGFyX2NvdW50IGliXSByZXR1cm5zIHRoZSBudW1iZXIgb2YgY2hhcmFjdGVyc1xuICAgICByZWFkIHNvIGZhciBmcm9tIHRoZSBnaXZlbiBidWZmZXIuICopXG5cbiAgdmFsIGxpbmVfY291bnQgOiBzY2FuYnVmIC0+IGludFxuICAoKiBbU2Nhbm5pbmcubGluZV9jb3VudCBpYl0gcmV0dXJucyB0aGUgbnVtYmVyIG9mIG5ldyBsaW5lXG4gICAgIGNoYXJhY3RlcnMgcmVhZCBzbyBmYXIgZnJvbSB0aGUgZ2l2ZW4gYnVmZmVyLiAqKVxuXG4gIHZhbCB0b2tlbl9jb3VudCA6IHNjYW5idWYgLT4gaW50XG4gICgqIFtTY2FubmluZy50b2tlbl9jb3VudCBpYl0gcmV0dXJucyB0aGUgbnVtYmVyIG9mIHRva2VucyByZWFkXG4gICAgIHNvIGZhciBmcm9tIFtpYl0uICopXG5cbiAgdmFsIGVvZiA6IHNjYW5idWYgLT4gYm9vbFxuICAoKiBbU2Nhbm5pbmcuZW9mIGliXSByZXR1cm5zIHRoZSBlbmQgb2YgaW5wdXQgY29uZGl0aW9uXG4gICAgIG9mIHRoZSBnaXZlbiBidWZmZXIuICopXG5cbiAgdmFsIGVuZF9vZl9pbnB1dCA6IHNjYW5idWYgLT4gYm9vbFxuICAoKiBbU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliXSB0ZXN0cyB0aGUgZW5kIG9mIGlucHV0IGNvbmRpdGlvblxuICAgICBvZiB0aGUgZ2l2ZW4gYnVmZmVyIChpZiBubyBjaGFyIGhhcyBldmVyIGJlZW4gcmVhZCwgYW4gYXR0ZW1wdCB0b1xuICAgICByZWFkIG9uZSBpcyBwZXJmb3JtZWQpLiAqKVxuXG4gIHZhbCBiZWdpbm5pbmdfb2ZfaW5wdXQgOiBzY2FuYnVmIC0+IGJvb2xcbiAgKCogW1NjYW5uaW5nLmJlZ2lubmluZ19vZl9pbnB1dCBpYl0gdGVzdHMgdGhlIGJlZ2lubmluZyBvZiBpbnB1dFxuICAgICBjb25kaXRpb24gb2YgdGhlIGdpdmVuIGJ1ZmZlci4gKilcblxuICB2YWwgbmFtZV9vZl9pbnB1dCA6IHNjYW5idWYgLT4gc3RyaW5nXG4gICgqIFtTY2FubmluZy5uYW1lX29mX2lucHV0IGliXSByZXR1cm5zIHRoZSBuYW1lIG9mIHRoZSBjaGFyYWN0ZXJcbiAgICAgc291cmNlIGZvciBpbnB1dCBidWZmZXIgW2liXS4gKilcblxuICB2YWwgb3Blbl9pbiA6IGZpbGVfbmFtZSAtPiBpbl9jaGFubmVsXG4gIHZhbCBvcGVuX2luX2JpbiA6IGZpbGVfbmFtZSAtPiBpbl9jaGFubmVsXG4gIHZhbCBmcm9tX2ZpbGUgOiBmaWxlX25hbWUgLT4gaW5fY2hhbm5lbFxuICB2YWwgZnJvbV9maWxlX2JpbiA6IGZpbGVfbmFtZSAtPiBpbl9jaGFubmVsXG4gIHZhbCBmcm9tX3N0cmluZyA6IHN0cmluZyAtPiBpbl9jaGFubmVsXG4gIHZhbCBmcm9tX2Z1bmN0aW9uIDogKHVuaXQgLT4gY2hhcikgLT4gaW5fY2hhbm5lbFxuICB2YWwgZnJvbV9jaGFubmVsIDogU3RkbGliLmluX2NoYW5uZWwgLT4gaW5fY2hhbm5lbFxuXG4gIHZhbCBjbG9zZV9pbiA6IGluX2NoYW5uZWwgLT4gdW5pdFxuXG4gIHZhbCBtZW1vX2Zyb21fY2hhbm5lbCA6IFN0ZGxpYi5pbl9jaGFubmVsIC0+IGluX2NoYW5uZWxcbiAgKCogT2Jzb2xldGUuICopXG5cbmVuZFxuXG5cbm1vZHVsZSBTY2FubmluZyA6IFNDQU5OSU5HID0gc3RydWN0XG5cbiAgKCogVGhlIHJ1bi10aW1lIGxpYnJhcnkgZm9yIHNjYW5mLiAqKVxuXG4gIHR5cGUgZmlsZV9uYW1lID0gc3RyaW5nXG5cbiAgdHlwZSBpbl9jaGFubmVsX25hbWUgPVxuICAgIHwgRnJvbV9jaGFubmVsIG9mIFN0ZGxpYi5pbl9jaGFubmVsXG4gICAgfCBGcm9tX2ZpbGUgb2YgZmlsZV9uYW1lICogU3RkbGliLmluX2NoYW5uZWxcbiAgICB8IEZyb21fZnVuY3Rpb25cbiAgICB8IEZyb21fc3RyaW5nXG5cblxuICB0eXBlIGluX2NoYW5uZWwgPSB7XG4gICAgbXV0YWJsZSBpY19lb2YgOiBib29sO1xuICAgIG11dGFibGUgaWNfY3VycmVudF9jaGFyIDogY2hhcjtcbiAgICBtdXRhYmxlIGljX2N1cnJlbnRfY2hhcl9pc192YWxpZCA6IGJvb2w7XG4gICAgbXV0YWJsZSBpY19jaGFyX2NvdW50IDogaW50O1xuICAgIG11dGFibGUgaWNfbGluZV9jb3VudCA6IGludDtcbiAgICBtdXRhYmxlIGljX3Rva2VuX2NvdW50IDogaW50O1xuICAgIG11dGFibGUgaWNfZ2V0X25leHRfY2hhciA6IHVuaXQgLT4gY2hhcjtcbiAgICBpY190b2tlbl9idWZmZXIgOiBCdWZmZXIudDtcbiAgICBpY19pbnB1dF9uYW1lIDogaW5fY2hhbm5lbF9uYW1lO1xuICB9XG5cblxuICB0eXBlIHNjYW5idWYgPSBpbl9jaGFubmVsXG5cbiAgbGV0IG51bGxfY2hhciA9ICdcXDAwMCdcblxuICAoKiBSZWFkcyBhIG5ldyBjaGFyYWN0ZXIgZnJvbSBpbnB1dCBidWZmZXIuXG4gICAgIE5leHRfY2hhciBuZXZlciBmYWlscywgZXZlbiBpbiBjYXNlIG9mIGVuZCBvZiBpbnB1dDpcbiAgICAgaXQgdGhlbiBzaW1wbHkgc2V0cyB0aGUgZW5kIG9mIGZpbGUgY29uZGl0aW9uLiAqKVxuICBsZXQgbmV4dF9jaGFyIGliID1cbiAgICB0cnlcbiAgICAgIGxldCBjID0gaWIuaWNfZ2V0X25leHRfY2hhciAoKSBpblxuICAgICAgaWIuaWNfY3VycmVudF9jaGFyIDwtIGM7XG4gICAgICBpYi5pY19jdXJyZW50X2NoYXJfaXNfdmFsaWQgPC0gdHJ1ZTtcbiAgICAgIGliLmljX2NoYXJfY291bnQgPC0gc3VjYyBpYi5pY19jaGFyX2NvdW50O1xuICAgICAgaWYgYyA9ICdcXG4nIHRoZW4gaWIuaWNfbGluZV9jb3VudCA8LSBzdWNjIGliLmljX2xpbmVfY291bnQ7XG4gICAgICBjIHdpdGhcbiAgICB8IEVuZF9vZl9maWxlIC0+XG4gICAgICBsZXQgYyA9IG51bGxfY2hhciBpblxuICAgICAgaWIuaWNfY3VycmVudF9jaGFyIDwtIGM7XG4gICAgICBpYi5pY19jdXJyZW50X2NoYXJfaXNfdmFsaWQgPC0gZmFsc2U7XG4gICAgICBpYi5pY19lb2YgPC0gdHJ1ZTtcbiAgICAgIGNcblxuXG4gIGxldCBwZWVrX2NoYXIgaWIgPVxuICAgIGlmIGliLmljX2N1cnJlbnRfY2hhcl9pc192YWxpZFxuICAgIHRoZW4gaWIuaWNfY3VycmVudF9jaGFyXG4gICAgZWxzZSBuZXh0X2NoYXIgaWJcblxuXG4gICgqIFJldHVybnMgYSB2YWxpZCBjdXJyZW50IGNoYXIgZm9yIHRoZSBpbnB1dCBidWZmZXIuIEluIHBhcnRpY3VsYXJcbiAgICAgbm8gaXJyZWxldmFudCBudWxsIGNoYXJhY3RlciAoYXMgc2V0IGJ5IFtuZXh0X2NoYXJdIGluIGNhc2Ugb2YgZW5kXG4gICAgIG9mIGlucHV0KSBpcyByZXR1cm5lZCwgc2luY2UgW0VuZF9vZl9maWxlXSBpcyByYWlzZWQgd2hlblxuICAgICBbbmV4dF9jaGFyXSBzZXRzIHRoZSBlbmQgb2YgZmlsZSBjb25kaXRpb24gd2hpbGUgdHJ5aW5nIHRvIHJlYWQgYVxuICAgICBuZXcgY2hhcmFjdGVyLiAqKVxuICBsZXQgY2hlY2tlZF9wZWVrX2NoYXIgaWIgPVxuICAgIGxldCBjID0gcGVla19jaGFyIGliIGluXG4gICAgaWYgaWIuaWNfZW9mIHRoZW4gcmFpc2UgRW5kX29mX2ZpbGU7XG4gICAgY1xuXG5cbiAgbGV0IGVuZF9vZl9pbnB1dCBpYiA9XG4gICAgaWdub3JlIChwZWVrX2NoYXIgaWIpO1xuICAgIGliLmljX2VvZlxuXG5cbiAgbGV0IGVvZiBpYiA9IGliLmljX2VvZlxuXG4gIGxldCBiZWdpbm5pbmdfb2ZfaW5wdXQgaWIgPSBpYi5pY19jaGFyX2NvdW50ID0gMFxuXG4gIGxldCBuYW1lX29mX2lucHV0IGliID1cbiAgICBtYXRjaCBpYi5pY19pbnB1dF9uYW1lIHdpdGhcbiAgICB8IEZyb21fY2hhbm5lbCBfaWMgLT4gXCJ1bm5hbWVkIFN0ZGxpYiBpbnB1dCBjaGFubmVsXCJcbiAgICB8IEZyb21fZmlsZSAoZm5hbWUsIF9pYykgLT4gZm5hbWVcbiAgICB8IEZyb21fZnVuY3Rpb24gLT4gXCJ1bm5hbWVkIGZ1bmN0aW9uXCJcbiAgICB8IEZyb21fc3RyaW5nIC0+IFwidW5uYW1lZCBjaGFyYWN0ZXIgc3RyaW5nXCJcblxuXG4gIGxldCBjaGFyX2NvdW50IGliID1cbiAgICBpZiBpYi5pY19jdXJyZW50X2NoYXJfaXNfdmFsaWRcbiAgICB0aGVuIGliLmljX2NoYXJfY291bnQgLSAxXG4gICAgZWxzZSBpYi5pY19jaGFyX2NvdW50XG5cblxuICBsZXQgbGluZV9jb3VudCBpYiA9IGliLmljX2xpbmVfY291bnRcblxuICBsZXQgcmVzZXRfdG9rZW4gaWIgPSBCdWZmZXIucmVzZXQgaWIuaWNfdG9rZW5fYnVmZmVyXG5cbiAgbGV0IGludmFsaWRhdGVfY3VycmVudF9jaGFyIGliID0gaWIuaWNfY3VycmVudF9jaGFyX2lzX3ZhbGlkIDwtIGZhbHNlXG5cbiAgbGV0IHRva2VuIGliID1cbiAgICBsZXQgdG9rZW5fYnVmZmVyID0gaWIuaWNfdG9rZW5fYnVmZmVyIGluXG4gICAgbGV0IHRvayA9IEJ1ZmZlci5jb250ZW50cyB0b2tlbl9idWZmZXIgaW5cbiAgICBCdWZmZXIuY2xlYXIgdG9rZW5fYnVmZmVyO1xuICAgIGliLmljX3Rva2VuX2NvdW50IDwtIHN1Y2MgaWIuaWNfdG9rZW5fY291bnQ7XG4gICAgdG9rXG5cblxuICBsZXQgdG9rZW5fY291bnQgaWIgPSBpYi5pY190b2tlbl9jb3VudFxuXG4gIGxldCBza2lwX2NoYXIgd2lkdGggaWIgPVxuICAgIGludmFsaWRhdGVfY3VycmVudF9jaGFyIGliO1xuICAgIHdpZHRoXG5cblxuICBsZXQgaWdub3JlX2NoYXIgd2lkdGggaWIgPSBza2lwX2NoYXIgKHdpZHRoIC0gMSkgaWJcblxuICBsZXQgc3RvcmVfY2hhciB3aWR0aCBpYiBjID1cbiAgICBCdWZmZXIuYWRkX2NoYXIgaWIuaWNfdG9rZW5fYnVmZmVyIGM7XG4gICAgaWdub3JlX2NoYXIgd2lkdGggaWJcblxuXG4gIGxldCBkZWZhdWx0X3Rva2VuX2J1ZmZlcl9zaXplID0gMTAyNFxuXG4gIGxldCBjcmVhdGUgaW5hbWUgbmV4dCA9IHtcbiAgICBpY19lb2YgPSBmYWxzZTtcbiAgICBpY19jdXJyZW50X2NoYXIgPSBudWxsX2NoYXI7XG4gICAgaWNfY3VycmVudF9jaGFyX2lzX3ZhbGlkID0gZmFsc2U7XG4gICAgaWNfY2hhcl9jb3VudCA9IDA7XG4gICAgaWNfbGluZV9jb3VudCA9IDA7XG4gICAgaWNfdG9rZW5fY291bnQgPSAwO1xuICAgIGljX2dldF9uZXh0X2NoYXIgPSBuZXh0O1xuICAgIGljX3Rva2VuX2J1ZmZlciA9IEJ1ZmZlci5jcmVhdGUgZGVmYXVsdF90b2tlbl9idWZmZXJfc2l6ZTtcbiAgICBpY19pbnB1dF9uYW1lID0gaW5hbWU7XG4gIH1cblxuXG4gIGxldCBmcm9tX3N0cmluZyBzID1cbiAgICBsZXQgaSA9IHJlZiAwIGluXG4gICAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggcyBpblxuICAgIGxldCBuZXh0ICgpID1cbiAgICAgIGlmICFpID49IGxlbiB0aGVuIHJhaXNlIEVuZF9vZl9maWxlIGVsc2VcbiAgICAgIGxldCBjID0gcy5bIWldIGluXG4gICAgICBpbmNyIGk7XG4gICAgICBjIGluXG4gICAgY3JlYXRlIEZyb21fc3RyaW5nIG5leHRcblxuXG4gIGxldCBmcm9tX2Z1bmN0aW9uID0gY3JlYXRlIEZyb21fZnVuY3Rpb25cblxuICAoKiBTY2FubmluZyBmcm9tIGFuIGlucHV0IGNoYW5uZWwuICopXG5cbiAgKCogUG9zaXRpb24gb2YgdGhlIHByb2JsZW06XG5cbiAgICAgV2UgY2Fubm90IHByZXZlbnQgdGhlIHNjYW5uaW5nIG1lY2hhbmlzbSB0byB1c2Ugb25lIGxvb2thaGVhZCBjaGFyYWN0ZXIsXG4gICAgIGlmIG5lZWRlZCBieSB0aGUgc2VtYW50aWNzIG9mIHRoZSBmb3JtYXQgc3RyaW5nIHNwZWNpZmljYXRpb25zIChlLmcuIGFcbiAgICAgdHJhaWxpbmcgJ3NraXAgc3BhY2UnIHNwZWNpZmljYXRpb24gaW4gdGhlIGZvcm1hdCBzdHJpbmcpOyBpbiB0aGlzIGNhc2UsXG4gICAgIHRoZSBtYW5kYXRvcnkgbG9va2FoZWFkIGNoYXJhY3RlciBpcyBpbmRlZWQgcmVhZCBmcm9tIHRoZSBpbnB1dCBhbmQgbm90XG4gICAgIHVzZWQgdG8gcmV0dXJuIHRoZSB0b2tlbiByZWFkLiBJdCBpcyB0aHVzIG1hbmRhdG9yeSB0byBiZSBhYmxlIHRvIHN0b3JlXG4gICAgIGFuIHVudXNlZCBsb29rYWhlYWQgY2hhcmFjdGVyIHNvbWV3aGVyZSB0byBnZXQgaXQgYXMgdGhlIGZpcnN0IGNoYXJhY3RlclxuICAgICBvZiB0aGUgbmV4dCBzY2FuLlxuXG4gICAgIFRvIGNpcmN1bXZlbnQgdGhpcyBwcm9ibGVtLCBhbGwgdGhlIHNjYW5uaW5nIGZ1bmN0aW9ucyBnZXQgYSBsb3cgbGV2ZWxcbiAgICAgaW5wdXQgYnVmZmVyIGFyZ3VtZW50IHdoZXJlIHRoZXkgc3RvcmUgdGhlIGxvb2thaGVhZCBjaGFyYWN0ZXIgd2hlblxuICAgICBuZWVkZWQ7IGFkZGl0aW9uYWxseSwgdGhlIGlucHV0IGJ1ZmZlciBpcyB0aGUgb25seSBzb3VyY2Ugb2YgY2hhcmFjdGVyIG9mXG4gICAgIGEgc2Nhbm5lci4gVGhlIFtzY2FuYnVmXSBpbnB1dCBidWZmZXJzIGFyZSBkZWZpbmVkIGluIG1vZHVsZSB7IVNjYW5uaW5nfS5cblxuICAgICBOb3cgd2UgdW5kZXJzdGFuZCB0aGF0IGl0IGlzIGV4dHJlbWVseSBpbXBvcnRhbnQgdGhhdCByZWxhdGVkIGFuZFxuICAgICBzdWNjZXNzaXZlIGNhbGxzIHRvIHNjYW5uZXJzIGluZGVlZCByZWFkIGZyb20gdGhlIHNhbWUgaW5wdXQgYnVmZmVyLlxuICAgICBJbiBlZmZlY3QsIGlmIGEgc2Nhbm5lciBbc2NhbjFdIGlzIHJlYWRpbmcgZnJvbSBbaWIxXSBhbmQgc3RvcmVzIGFuXG4gICAgIHVudXNlZCBsb29rYWhlYWQgY2hhcmFjdGVyIFtjMV0gaW50byBpdHMgaW5wdXQgYnVmZmVyIFtpYjFdLCB0aGVuXG4gICAgIGFub3RoZXIgc2Nhbm5lciBbc2NhbjJdIG5vdCByZWFkaW5nIGZyb20gdGhlIHNhbWUgYnVmZmVyIFtpYjFdIHdpbGwgbWlzc1xuICAgICB0aGUgY2hhcmFjdGVyIFtjMV0sIHNlZW1pbmdseSB2YW5pc2hlZCBpbiB0aGUgYWlyIGZyb20gdGhlIHBvaW50IG9mIHZpZXdcbiAgICAgb2YgW3NjYW4yXS5cblxuICAgICBUaGlzIG1lY2hhbmlzbSB3b3JrcyBwZXJmZWN0bHkgdG8gcmVhZCBmcm9tIHN0cmluZ3MsIGZyb20gZmlsZXMsIGFuZCBmcm9tXG4gICAgIGZ1bmN0aW9ucywgc2luY2UgaW4gdGhvc2UgY2FzZXMsIGFsbG9jYXRpbmcgdHdvIGJ1ZmZlcnMgcmVhZGluZyBmcm9tIHRoZVxuICAgICBzYW1lIHNvdXJjZSBpcyB1bm5hdHVyYWwuXG5cbiAgICAgU3RpbGwsIHRoZXJlIGlzIGEgZGlmZmljdWx0eSBpbiB0aGUgY2FzZSBvZiBzY2FubmluZyBmcm9tIGFuIGlucHV0XG4gICAgIGNoYW5uZWwuIEluIGVmZmVjdCwgd2hlbiBzY2FubmluZyBmcm9tIGFuIGlucHV0IGNoYW5uZWwgW2ljXSwgdGhpcyBjaGFubmVsXG4gICAgIG1heSBub3QgaGF2ZSBiZWVuIGFsbG9jYXRlZCBmcm9tIHdpdGhpbiB0aGlzIGxpYnJhcnkuIEhlbmNlLCBpdCBtYXkgYmVcbiAgICAgc2hhcmVkICh0d28gZnVuY3Rpb25zIG9mIHRoZSB1c2VyJ3MgcHJvZ3JhbSBtYXkgc3VjY2Vzc2l2ZWx5IHJlYWQgZnJvbVxuICAgICBbaWNdKS4gVGhpcyBpcyBoaWdobHkgZXJyb3IgcHJvbmUgc2luY2UsIG9uZSBvZiB0aGUgZnVuY3Rpb24gbWF5IHNlZWsgdGhlXG4gICAgIGlucHV0IGNoYW5uZWwsIHdoaWxlIHRoZSBvdGhlciBmdW5jdGlvbiBoYXMgc3RpbGwgYW4gdW51c2VkIGxvb2thaGVhZFxuICAgICBjaGFyYWN0ZXIgaW4gaXRzIGlucHV0IGJ1ZmZlci4gSW4gY29uY2x1c2lvbiwgeW91IHNob3VsZCBuZXZlciBtaXggZGlyZWN0XG4gICAgIGxvdyBsZXZlbCByZWFkaW5nIGFuZCBoaWdoIGxldmVsIHNjYW5uaW5nIGZyb20gdGhlIHNhbWUgaW5wdXQgY2hhbm5lbC5cblxuICAqKVxuXG4gICgqIFBlcmZvcm0gYnVmZmVyaXplZCBpbnB1dCB0byBpbXByb3ZlIGVmZmljaWVuY3kuICopXG4gIGxldCBmaWxlX2J1ZmZlcl9zaXplID0gcmVmIDEwMjRcblxuICAoKiBUaGUgc2Nhbm5lciBjbG9zZXMgdGhlIGlucHV0IGNoYW5uZWwgYXQgZW5kIG9mIGlucHV0LiAqKVxuICBsZXQgc2Nhbl9jbG9zZV9hdF9lbmQgaWMgPSBTdGRsaWIuY2xvc2VfaW4gaWM7IHJhaXNlIEVuZF9vZl9maWxlXG5cbiAgKCogVGhlIHNjYW5uZXIgZG9lcyBub3QgY2xvc2UgdGhlIGlucHV0IGNoYW5uZWwgYXQgZW5kIG9mIGlucHV0OlxuICAgICBpdCBqdXN0IHJhaXNlcyBbRW5kX29mX2ZpbGVdLiAqKVxuICBsZXQgc2Nhbl9yYWlzZV9hdF9lbmQgX2ljID0gcmFpc2UgRW5kX29mX2ZpbGVcblxuICBsZXQgZnJvbV9pYyBzY2FuX2Nsb3NlX2ljIGluYW1lIGljID1cbiAgICBsZXQgbGVuID0gIWZpbGVfYnVmZmVyX3NpemUgaW5cbiAgICBsZXQgYnVmID0gQnl0ZXMuY3JlYXRlIGxlbiBpblxuICAgIGxldCBpID0gcmVmIDAgaW5cbiAgICBsZXQgbGltID0gcmVmIDAgaW5cbiAgICBsZXQgZW9mID0gcmVmIGZhbHNlIGluXG4gICAgbGV0IG5leHQgKCkgPVxuICAgICAgaWYgIWkgPCAhbGltIHRoZW4gYmVnaW4gbGV0IGMgPSBCeXRlcy5nZXQgYnVmICFpIGluIGluY3IgaTsgYyBlbmQgZWxzZVxuICAgICAgaWYgIWVvZiB0aGVuIHJhaXNlIEVuZF9vZl9maWxlIGVsc2UgYmVnaW5cbiAgICAgICAgbGltIDo9IGlucHV0IGljIGJ1ZiAwIGxlbjtcbiAgICAgICAgaWYgIWxpbSA9IDAgdGhlbiBiZWdpbiBlb2YgOj0gdHJ1ZTsgc2Nhbl9jbG9zZV9pYyBpYyBlbmQgZWxzZSBiZWdpblxuICAgICAgICAgIGkgOj0gMTtcbiAgICAgICAgICBCeXRlcy5nZXQgYnVmIDBcbiAgICAgICAgZW5kXG4gICAgICBlbmQgaW5cbiAgICBjcmVhdGUgaW5hbWUgbmV4dFxuXG5cbiAgbGV0IGZyb21faWNfY2xvc2VfYXRfZW5kID0gZnJvbV9pYyBzY2FuX2Nsb3NlX2F0X2VuZFxuICBsZXQgZnJvbV9pY19yYWlzZV9hdF9lbmQgPSBmcm9tX2ljIHNjYW5fcmFpc2VfYXRfZW5kXG5cbiAgKCogVGhlIHNjYW5uaW5nIGJ1ZmZlciByZWFkaW5nIGZyb20gW1N0ZGxpYi5zdGRpbl0uXG4gICAgIE9uZSBjb3VsZCB0cnkgdG8gZGVmaW5lIFtzdGRpYl0gYXMgYSBzY2FubmluZyBidWZmZXIgcmVhZGluZyBhIGNoYXJhY3RlclxuICAgICBhdCBhIHRpbWUgKG5vIGJ1ZmZlcml6YXRpb24gYXQgYWxsKSwgYnV0IHVuZm9ydHVuYXRlbHkgdGhlIHRvcC1sZXZlbFxuICAgICBpbnRlcmFjdGlvbiB3b3VsZCBiZSB3cm9uZy4gVGhpcyBpcyBkdWUgdG8gc29tZSBraW5kIG9mXG4gICAgICdyYWNlIGNvbmRpdGlvbicgd2hlbiByZWFkaW5nIGZyb20gW1N0ZGxpYi5zdGRpbl0sXG4gICAgIHNpbmNlIHRoZSBpbnRlcmFjdGl2ZSBjb21waWxlciBhbmQgW1NjYW5mLnNjYW5mXSB3aWxsIHNpbXVsdGFuZW91c2x5XG4gICAgIHJlYWQgdGhlIG1hdGVyaWFsIHRoZXkgbmVlZCBmcm9tIFtTdGRsaWIuc3RkaW5dOyB0aGVuLCBjb25mdXNpb25cbiAgICAgd2lsbCByZXN1bHQgZnJvbSB3aGF0IHNob3VsZCBiZSByZWFkIGJ5IHRoZSB0b3AtbGV2ZWwgYW5kIHdoYXQgc2hvdWxkIGJlXG4gICAgIHJlYWQgYnkgW1NjYW5mLnNjYW5mXS5cbiAgICAgVGhpcyBpcyBldmVuIG1vcmUgY29tcGxpY2F0ZWQgYnkgdGhlIG9uZSBjaGFyYWN0ZXIgbG9va2FoZWFkIHRoYXRcbiAgICAgW1NjYW5mLnNjYW5mXSBpcyBzb21ldGltZXMgb2JsaWdlZCB0byBtYWludGFpbjogdGhlIGxvb2thaGVhZCBjaGFyYWN0ZXJcbiAgICAgd2lsbCBiZSBhdmFpbGFibGUgZm9yIHRoZSBuZXh0IFtTY2FuZi5zY2FuZl0gZW50cnksIHNlZW1pbmdseSBjb21pbmcgZnJvbVxuICAgICBub3doZXJlLlxuICAgICBBbHNvIG5vIFtFbmRfb2ZfZmlsZV0gaXMgcmFpc2VkIHdoZW4gcmVhZGluZyBmcm9tIHN0ZGluOiBpZiBub3QgZW5vdWdoXG4gICAgIGNoYXJhY3RlcnMgaGF2ZSBiZWVuIHJlYWQsIHdlIHNpbXBseSBhc2sgdG8gcmVhZCBtb3JlLiAqKVxuICBsZXQgc3RkaW4gPVxuICAgIGZyb21faWMgc2Nhbl9yYWlzZV9hdF9lbmRcbiAgICAgIChGcm9tX2ZpbGUgKFwiLVwiLCBTdGRsaWIuc3RkaW4pKSBTdGRsaWIuc3RkaW5cblxuXG4gIGxldCBzdGRpYiA9IHN0ZGluXG5cbiAgbGV0IG9wZW5faW5fZmlsZSBvcGVuX2luIGZuYW1lID1cbiAgICBtYXRjaCBmbmFtZSB3aXRoXG4gICAgfCBcIi1cIiAtPiBzdGRpblxuICAgIHwgZm5hbWUgLT5cbiAgICAgIGxldCBpYyA9IG9wZW5faW4gZm5hbWUgaW5cbiAgICAgIGZyb21faWNfY2xvc2VfYXRfZW5kIChGcm9tX2ZpbGUgKGZuYW1lLCBpYykpIGljXG5cblxuICBsZXQgb3Blbl9pbiA9IG9wZW5faW5fZmlsZSBTdGRsaWIub3Blbl9pblxuICBsZXQgb3Blbl9pbl9iaW4gPSBvcGVuX2luX2ZpbGUgU3RkbGliLm9wZW5faW5fYmluXG5cbiAgbGV0IGZyb21fZmlsZSA9IG9wZW5faW5cbiAgbGV0IGZyb21fZmlsZV9iaW4gPSBvcGVuX2luX2JpblxuXG4gIGxldCBmcm9tX2NoYW5uZWwgaWMgPVxuICAgIGZyb21faWNfcmFpc2VfYXRfZW5kIChGcm9tX2NoYW5uZWwgaWMpIGljXG5cblxuICBsZXQgY2xvc2VfaW4gaWIgPVxuICAgIG1hdGNoIGliLmljX2lucHV0X25hbWUgd2l0aFxuICAgIHwgRnJvbV9jaGFubmVsIGljIC0+XG4gICAgICBTdGRsaWIuY2xvc2VfaW4gaWNcbiAgICB8IEZyb21fZmlsZSAoX2ZuYW1lLCBpYykgLT4gU3RkbGliLmNsb3NlX2luIGljXG4gICAgfCBGcm9tX2Z1bmN0aW9uIHwgRnJvbV9zdHJpbmcgLT4gKClcblxuXG4gICgqXG4gICAgIE9ic29sZXRlOiBhIG1lbW8gW2Zyb21fY2hhbm5lbF0gdmVyc2lvbiB0byBidWlsZCBhIFtTY2FubmluZy5pbl9jaGFubmVsXVxuICAgICBzY2FubmluZyBidWZmZXIgb3V0IG9mIGEgW1N0ZGxpYi5pbl9jaGFubmVsXS5cbiAgICAgVGhpcyBmdW5jdGlvbiB3YXMgdXNlZCB0byB0cnkgdG8gcHJlc2VydmUgdGhlIHNjYW5uaW5nXG4gICAgIHNlbWFudGljcyBmb3IgdGhlIChub3cgb2Jzb2xldGUpIGZ1bmN0aW9uIFtmc2NhbmZdLlxuICAgICBHaXZlbiB0aGF0IGFsbCBzY2FubmVyIG11c3QgcmVhZCBmcm9tIGEgW1NjYW5uaW5nLmluX2NoYW5uZWxdIHNjYW5uaW5nXG4gICAgIGJ1ZmZlciwgW2ZzY2FuZl0gbXVzdCByZWFkIGZyb20gb25lIVxuICAgICBNb3JlIHByZWNpc2VseSwgZ2l2ZW4gW2ljXSwgYWxsIHN1Y2Nlc3NpdmUgY2FsbHMgW2ZzY2FuZiBpY10gbXVzdCByZWFkXG4gICAgIGZyb20gdGhlIHNhbWUgc2Nhbm5pbmcgYnVmZmVyLlxuICAgICBUaGlzIG9ibGlnZWQgdGhpcyBsaWJyYXJ5IHRvIGFsbG9jYXRlZCBzY2FubmluZyBidWZmZXJzIHRoYXQgd2VyZVxuICAgICBub3QgcHJvcGVybHkgZ2FyYmFnZSBjb2xsZWN0YWJsZSwgaGVuY2UgbGVhZGluZyB0byBtZW1vcnkgbGVha3MuXG4gICAgIElmIHlvdSBuZWVkIHRvIHJlYWQgZnJvbSBhIFtTdGRsaWIuaW5fY2hhbm5lbF0gaW5wdXQgY2hhbm5lbFxuICAgICBbaWNdLCBzaW1wbHkgZGVmaW5lIGEgW1NjYW5uaW5nLmluX2NoYW5uZWxdIGZvcm1hdHRlZCBpbnB1dCBjaGFubmVsIGFzIGluXG4gICAgIFtsZXQgaWIgPSBTY2FubmluZy5mcm9tX2NoYW5uZWwgaWNdLCB0aGVuIHVzZSBbU2NhbmYuYnNjYW5mIGliXSBhcyB1c3VhbC5cbiAgKilcbiAgbGV0IG1lbW9fZnJvbV9pYyA9XG4gICAgbGV0IG1lbW8gPSByZWYgW10gaW5cbiAgICAoZnVuIHNjYW5fY2xvc2VfaWMgaWMgLT5cbiAgICAgdHJ5IExpc3QuYXNzcSBpYyAhbWVtbyB3aXRoXG4gICAgIHwgTm90X2ZvdW5kIC0+XG4gICAgICAgbGV0IGliID1cbiAgICAgICAgIGZyb21faWMgc2Nhbl9jbG9zZV9pYyAoRnJvbV9jaGFubmVsIGljKSBpYyBpblxuICAgICAgIG1lbW8gOj0gKGljLCBpYikgOjogIW1lbW87XG4gICAgICAgaWIpXG5cblxuICAoKiBPYnNvbGV0ZTogc2VlIHshbWVtb19mcm9tX2ljfSBhYm92ZS4gKilcbiAgbGV0IG1lbW9fZnJvbV9jaGFubmVsID0gbWVtb19mcm9tX2ljIHNjYW5fcmFpc2VfYXRfZW5kXG5cbmVuZFxuXG5cbigqIEZvcm1hdHRlZCBpbnB1dCBmdW5jdGlvbnMuICopXG5cbnR5cGUgKCdhLCAnYiwgJ2MsICdkKSBzY2FubmVyID1cbiAgICAgKCdhLCBTY2FubmluZy5pbl9jaGFubmVsLCAnYiwgJ2MsICdhIC0+ICdkLCAnZCkgZm9ybWF0NiAtPiAnY1xuXG5cbigqIFJlcG9ydGluZyBlcnJvcnMuICopXG5leGNlcHRpb24gU2Nhbl9mYWlsdXJlIG9mIHN0cmluZ1xuXG5sZXQgYmFkX2lucHV0IHMgPSByYWlzZSAoU2Nhbl9mYWlsdXJlIHMpXG5cbmxldCBiYWRfaW5wdXRfZXNjYXBlIGMgPVxuICBiYWRfaW5wdXQgKFByaW50Zi5zcHJpbnRmIFwiaWxsZWdhbCBlc2NhcGUgY2hhcmFjdGVyICVDXCIgYylcblxuXG5sZXQgYmFkX3Rva2VuX2xlbmd0aCBtZXNzYWdlID1cbiAgYmFkX2lucHV0XG4gICAgKFByaW50Zi5zcHJpbnRmXG4gICAgICAgXCJzY2FubmluZyBvZiAlcyBmYWlsZWQ6IFxcXG4gICAgICAgIHRoZSBzcGVjaWZpZWQgbGVuZ3RoIHdhcyB0b28gc2hvcnQgZm9yIHRva2VuXCJcbiAgICAgICBtZXNzYWdlKVxuXG5cbmxldCBiYWRfZW5kX29mX2lucHV0IG1lc3NhZ2UgPVxuICBiYWRfaW5wdXRcbiAgICAoUHJpbnRmLnNwcmludGZcbiAgICAgICBcInNjYW5uaW5nIG9mICVzIGZhaWxlZDogXFxcbiAgICAgICAgcHJlbWF0dXJlIGVuZCBvZiBmaWxlIG9jY3VycmVkIGJlZm9yZSBlbmQgb2YgdG9rZW5cIlxuICAgICAgIG1lc3NhZ2UpXG5cblxubGV0IGJhZF9mbG9hdCAoKSA9XG4gIGJhZF9pbnB1dCBcIm5vIGRvdCBvciBleHBvbmVudCBwYXJ0IGZvdW5kIGluIGZsb2F0IHRva2VuXCJcblxuXG5sZXQgYmFkX2hleF9mbG9hdCAoKSA9XG4gIGJhZF9pbnB1dCBcIm5vdCBhIHZhbGlkIGZsb2F0IGluIGhleGFkZWNpbWFsIG5vdGF0aW9uXCJcblxuXG5sZXQgY2hhcmFjdGVyX21pc21hdGNoX2VyciBjIGNpID1cbiAgUHJpbnRmLnNwcmludGYgXCJsb29raW5nIGZvciAlQywgZm91bmQgJUNcIiBjIGNpXG5cblxubGV0IGNoYXJhY3Rlcl9taXNtYXRjaCBjIGNpID1cbiAgYmFkX2lucHV0IChjaGFyYWN0ZXJfbWlzbWF0Y2hfZXJyIGMgY2kpXG5cblxubGV0IHJlYyBza2lwX3doaXRlcyBpYiA9XG4gIGxldCBjID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gIGlmIG5vdCAoU2Nhbm5pbmcuZW9mIGliKSB0aGVuIGJlZ2luXG4gICAgbWF0Y2ggYyB3aXRoXG4gICAgfCAnICcgfCAnXFx0JyB8ICdcXG4nIHwgJ1xccicgLT5cbiAgICAgIFNjYW5uaW5nLmludmFsaWRhdGVfY3VycmVudF9jaGFyIGliOyBza2lwX3doaXRlcyBpYlxuICAgIHwgXyAtPiAoKVxuICBlbmRcblxuXG4oKiBDaGVja2luZyB0aGF0IFtjXSBpcyBpbmRlZWQgaW4gdGhlIGlucHV0LCB0aGVuIHNraXBzIGl0LlxuICAgSW4gdGhpcyBjYXNlLCB0aGUgY2hhcmFjdGVyIFtjXSBoYXMgYmVlbiBleHBsaWNpdGx5IHNwZWNpZmllZCBpbiB0aGVcbiAgIGZvcm1hdCBhcyBiZWluZyBtYW5kYXRvcnkgaW4gdGhlIGlucHV0OyBoZW5jZSB3ZSBzaG91bGQgZmFpbCB3aXRoXG4gICBbRW5kX29mX2ZpbGVdIGluIGNhc2Ugb2YgZW5kX29mX2lucHV0LlxuICAgKFJlbWVtYmVyIHRoYXQgW1NjYW5fZmFpbHVyZV0gaXMgcmFpc2VkIG9ubHkgd2hlbiAod2UgY2FuIHByb3ZlIGJ5XG4gICBldmlkZW5jZSkgdGhhdCB0aGUgaW5wdXQgZG9lcyBub3QgbWF0Y2ggdGhlIGZvcm1hdCBzdHJpbmcgZ2l2ZW4uIFdlIG11c3RcbiAgIHRodXMgZGlmZmVyZW50aWF0ZSBbRW5kX29mX2ZpbGVdIGFzIGFuIGVycm9yIGR1ZSB0byBsYWNrIG9mIGlucHV0LCBhbmRcbiAgIFtTY2FuX2ZhaWx1cmVdIHdoaWNoIGlzIGR1ZSB0byBwcm92YWJseSB3cm9uZyBpbnB1dC4gSSBhbSBub3Qgc3VyZSB0aGlzIGlzXG4gICB3b3J0aCB0aGUgYnVyZGVuOiBpdCBpcyBjb21wbGV4IGFuZCBzb21laG93IHN1YmxpbWluYWw7IHNob3VsZCBiZSBjbGVhcmVyXG4gICB0byBmYWlsIHdpdGggU2Nhbl9mYWlsdXJlIFwiTm90IGVub3VnaCBpbnB1dCB0byBjb21wbGV0ZSBzY2FubmluZ1wiISlcblxuICAgVGhhdCdzIHdoeSwgd2FpdGluZyBmb3IgYSBiZXR0ZXIgc29sdXRpb24sIHdlIHVzZSBjaGVja2VkX3BlZWtfY2hhciBoZXJlLlxuICAgV2UgYXJlIGFsc28gY2FyZWZ1bCB0byB0cmVhdCBcIlxcclxcblwiIGluIHRoZSBpbnB1dCBhcyBhbiBlbmQgb2YgbGluZSBtYXJrZXI6XG4gICBpdCBhbHdheXMgbWF0Y2hlcyBhICdcXG4nIHNwZWNpZmljYXRpb24gaW4gdGhlIGlucHV0IGZvcm1hdCBzdHJpbmcuICopXG5sZXQgcmVjIGNoZWNrX2NoYXIgaWIgYyA9XG4gIG1hdGNoIGMgd2l0aFxuICB8ICcgJyAtPiBza2lwX3doaXRlcyBpYlxuICB8ICdcXG4nIC0+IGNoZWNrX25ld2xpbmUgaWJcbiAgfCBjIC0+IGNoZWNrX3RoaXNfY2hhciBpYiBjXG5cbmFuZCBjaGVja190aGlzX2NoYXIgaWIgYyA9XG4gIGxldCBjaSA9IFNjYW5uaW5nLmNoZWNrZWRfcGVla19jaGFyIGliIGluXG4gIGlmIGNpID0gYyB0aGVuIFNjYW5uaW5nLmludmFsaWRhdGVfY3VycmVudF9jaGFyIGliIGVsc2VcbiAgY2hhcmFjdGVyX21pc21hdGNoIGMgY2lcblxuYW5kIGNoZWNrX25ld2xpbmUgaWIgPVxuICBsZXQgY2kgPSBTY2FubmluZy5jaGVja2VkX3BlZWtfY2hhciBpYiBpblxuICBtYXRjaCBjaSB3aXRoXG4gIHwgJ1xcbicgLT4gU2Nhbm5pbmcuaW52YWxpZGF0ZV9jdXJyZW50X2NoYXIgaWJcbiAgfCAnXFxyJyAtPiBTY2FubmluZy5pbnZhbGlkYXRlX2N1cnJlbnRfY2hhciBpYjsgY2hlY2tfdGhpc19jaGFyIGliICdcXG4nXG4gIHwgXyAtPiBjaGFyYWN0ZXJfbWlzbWF0Y2ggJ1xcbicgY2lcblxuXG4oKiBFeHRyYWN0aW5nIHRva2VucyBmcm9tIHRoZSBvdXRwdXQgdG9rZW4gYnVmZmVyLiAqKVxuXG5sZXQgdG9rZW5fY2hhciBpYiA9IChTY2FubmluZy50b2tlbiBpYikuWzBdXG5cbmxldCB0b2tlbl9zdHJpbmcgPSBTY2FubmluZy50b2tlblxuXG5sZXQgdG9rZW5fYm9vbCBpYiA9XG4gIG1hdGNoIFNjYW5uaW5nLnRva2VuIGliIHdpdGhcbiAgfCBcInRydWVcIiAtPiB0cnVlXG4gIHwgXCJmYWxzZVwiIC0+IGZhbHNlXG4gIHwgcyAtPiBiYWRfaW5wdXQgKFByaW50Zi5zcHJpbnRmIFwiaW52YWxpZCBib29sZWFuICclcydcIiBzKVxuXG5cbigqIFRoZSB0eXBlIG9mIGludGVnZXIgY29udmVyc2lvbnMuICopXG50eXBlIGludGVnZXJfY29udmVyc2lvbiA9XG4gIHwgQl9jb252ZXJzaW9uICgqIFVuc2lnbmVkIGJpbmFyeSBjb252ZXJzaW9uICopXG4gIHwgRF9jb252ZXJzaW9uICgqIFNpZ25lZCBkZWNpbWFsIGNvbnZlcnNpb24gKilcbiAgfCBJX2NvbnZlcnNpb24gKCogU2lnbmVkIGludGVnZXIgY29udmVyc2lvbiAqKVxuICB8IE9fY29udmVyc2lvbiAoKiBVbnNpZ25lZCBvY3RhbCBjb252ZXJzaW9uICopXG4gIHwgVV9jb252ZXJzaW9uICgqIFVuc2lnbmVkIGRlY2ltYWwgY29udmVyc2lvbiAqKVxuICB8IFhfY29udmVyc2lvbiAoKiBVbnNpZ25lZCBoZXhhZGVjaW1hbCBjb252ZXJzaW9uICopXG5cblxubGV0IGludGVnZXJfY29udmVyc2lvbl9vZl9jaGFyID0gZnVuY3Rpb25cbiAgfCAnYicgLT4gQl9jb252ZXJzaW9uXG4gIHwgJ2QnIC0+IERfY29udmVyc2lvblxuICB8ICdpJyAtPiBJX2NvbnZlcnNpb25cbiAgfCAnbycgLT4gT19jb252ZXJzaW9uXG4gIHwgJ3UnIC0+IFVfY29udmVyc2lvblxuICB8ICd4JyB8ICdYJyAtPiBYX2NvbnZlcnNpb25cbiAgfCBfIC0+IGFzc2VydCBmYWxzZVxuXG5cbigqIEV4dHJhY3QgYW4gaW50ZWdlciBsaXRlcmFsIHRva2VuLlxuICAgU2luY2UgdGhlIGZ1bmN0aW9ucyBTdGRsaWIuKmludCpfb2Zfc3RyaW5nIGRvIG5vdCBhY2NlcHQgYSBsZWFkaW5nICssXG4gICB3ZSBza2lwIGl0IGlmIG5lY2Vzc2FyeS4gKilcbmxldCB0b2tlbl9pbnRfbGl0ZXJhbCBjb252IGliID1cbiAgbGV0IHRvayA9XG4gICAgbWF0Y2ggY29udiB3aXRoXG4gICAgfCBEX2NvbnZlcnNpb24gfCBJX2NvbnZlcnNpb24gLT4gU2Nhbm5pbmcudG9rZW4gaWJcbiAgICB8IFVfY29udmVyc2lvbiAtPiBcIjB1XCIgXiBTY2FubmluZy50b2tlbiBpYlxuICAgIHwgT19jb252ZXJzaW9uIC0+IFwiMG9cIiBeIFNjYW5uaW5nLnRva2VuIGliXG4gICAgfCBYX2NvbnZlcnNpb24gLT4gXCIweFwiIF4gU2Nhbm5pbmcudG9rZW4gaWJcbiAgICB8IEJfY29udmVyc2lvbiAtPiBcIjBiXCIgXiBTY2FubmluZy50b2tlbiBpYiBpblxuICBsZXQgbCA9IFN0cmluZy5sZW5ndGggdG9rIGluXG4gIGlmIGwgPSAwIHx8IHRvay5bMF0gPD4gJysnIHRoZW4gdG9rIGVsc2UgU3RyaW5nLnN1YiB0b2sgMSAobCAtIDEpXG5cblxuKCogQWxsIHRoZSBmdW5jdGlvbnMgdGhhdCBjb252ZXJ0IGEgc3RyaW5nIHRvIGEgbnVtYmVyIHJhaXNlIHRoZSBleGNlcHRpb25cbiAgIEZhaWx1cmUgd2hlbiB0aGUgY29udmVyc2lvbiBpcyBub3QgcG9zc2libGUuXG4gICBUaGlzIGV4Y2VwdGlvbiBpcyB0aGVuIHRyYXBwZWQgaW4gW2tzY2FuZl0uICopXG5sZXQgdG9rZW5faW50IGNvbnYgaWIgPSBpbnRfb2Zfc3RyaW5nICh0b2tlbl9pbnRfbGl0ZXJhbCBjb252IGliKVxuXG5sZXQgdG9rZW5fZmxvYXQgaWIgPSBmbG9hdF9vZl9zdHJpbmcgKFNjYW5uaW5nLnRva2VuIGliKVxuXG4oKiBUbyBzY2FuIG5hdGl2ZSBpbnRzLCBpbnQzMiBhbmQgaW50NjQgaW50ZWdlcnMuXG4gICBXZSBjYW5ub3QgYWNjZXNzIHRvIGNvbnZlcnNpb25zIHRvL2Zyb20gc3RyaW5ncyBmb3IgdGhvc2UgdHlwZXMsXG4gICBOYXRpdmVpbnQub2Zfc3RyaW5nLCBJbnQzMi5vZl9zdHJpbmcsIGFuZCBJbnQ2NC5vZl9zdHJpbmcsXG4gICBzaW5jZSB0aG9zZSBtb2R1bGVzIGFyZSBub3QgYXZhaWxhYmxlIHRvIFtTY2FuZl0uXG4gICBIb3dldmVyLCB3ZSBjYW4gYmluZCBhbmQgdXNlIHRoZSBjb3JyZXNwb25kaW5nIHByaW1pdGl2ZXMgdGhhdCBhcmVcbiAgIGF2YWlsYWJsZSBpbiB0aGUgcnVudGltZS4gKilcbmV4dGVybmFsIG5hdGl2ZWludF9vZl9zdHJpbmcgOiBzdHJpbmcgLT4gbmF0aXZlaW50XG4gID0gXCJjYW1sX25hdGl2ZWludF9vZl9zdHJpbmdcIlxuXG5leHRlcm5hbCBpbnQzMl9vZl9zdHJpbmcgOiBzdHJpbmcgLT4gaW50MzJcbiAgPSBcImNhbWxfaW50MzJfb2Zfc3RyaW5nXCJcblxuZXh0ZXJuYWwgaW50NjRfb2Zfc3RyaW5nIDogc3RyaW5nIC0+IGludDY0XG4gID0gXCJjYW1sX2ludDY0X29mX3N0cmluZ1wiXG5cblxubGV0IHRva2VuX25hdGl2ZWludCBjb252IGliID0gbmF0aXZlaW50X29mX3N0cmluZyAodG9rZW5faW50X2xpdGVyYWwgY29udiBpYilcbmxldCB0b2tlbl9pbnQzMiBjb252IGliID0gaW50MzJfb2Zfc3RyaW5nICh0b2tlbl9pbnRfbGl0ZXJhbCBjb252IGliKVxubGV0IHRva2VuX2ludDY0IGNvbnYgaWIgPSBpbnQ2NF9vZl9zdHJpbmcgKHRva2VuX2ludF9saXRlcmFsIGNvbnYgaWIpXG5cbigqIFNjYW5uaW5nIG51bWJlcnMuICopXG5cbigqIERpZ2l0cyBzY2FubmluZyBmdW5jdGlvbnMgc3VwcG9zZSB0aGF0IG9uZSBjaGFyYWN0ZXIgaGFzIGJlZW4gY2hlY2tlZCBhbmRcbiAgIGlzIGF2YWlsYWJsZSwgc2luY2UgdGhleSByZXR1cm4gYXQgZW5kIG9mIGZpbGUgd2l0aCB0aGUgY3VycmVudGx5IGZvdW5kXG4gICB0b2tlbiBzZWxlY3RlZC5cblxuICAgUHV0IGl0IGluIGFub3RoZXIgd2F5LCB0aGUgZGlnaXRzIHNjYW5uaW5nIGZ1bmN0aW9ucyBzY2FuIGZvciBhIHBvc3NpYmx5XG4gICBlbXB0eSBzZXF1ZW5jZSBvZiBkaWdpdHMsIChoZW5jZSwgYSBzdWNjZXNzZnVsIHNjYW5uaW5nIGZyb20gb25lIG9mIHRob3NlXG4gICBmdW5jdGlvbnMgZG9lcyBub3QgaW1wbHkgdGhhdCB0aGUgdG9rZW4gaXMgYSB3ZWxsLWZvcm1lZCBudW1iZXI6IHRvIGdldCBhXG4gICB0cnVlIG51bWJlciwgaXQgaXMgbWFuZGF0b3J5IHRvIGNoZWNrIHRoYXQgYXQgbGVhc3Qgb25lIHZhbGlkIGRpZ2l0IGlzXG4gICBhdmFpbGFibGUgYmVmb3JlIGNhbGxpbmcgb25lIG9mIHRoZSBkaWdpdCBzY2FubmluZyBmdW5jdGlvbnMpLiAqKVxuXG4oKiBUaGUgZGVjaW1hbCBjYXNlIGlzIHRyZWF0ZWQgZXNwZWNpYWxseSBmb3Igb3B0aW1pemF0aW9uIHB1cnBvc2VzLiAqKVxubGV0IHJlYyBzY2FuX2RlY2ltYWxfZGlnaXRfc3RhciB3aWR0aCBpYiA9XG4gIGlmIHdpZHRoID0gMCB0aGVuIHdpZHRoIGVsc2VcbiAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgaWYgU2Nhbm5pbmcuZW9mIGliIHRoZW4gd2lkdGggZWxzZVxuICBtYXRjaCBjIHdpdGhcbiAgfCAnMCcgLi4gJzknIGFzIGMgLT5cbiAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICBzY2FuX2RlY2ltYWxfZGlnaXRfc3RhciB3aWR0aCBpYlxuICB8ICdfJyAtPlxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliIGluXG4gICAgc2Nhbl9kZWNpbWFsX2RpZ2l0X3N0YXIgd2lkdGggaWJcbiAgfCBfIC0+IHdpZHRoXG5cblxubGV0IHNjYW5fZGVjaW1hbF9kaWdpdF9wbHVzIHdpZHRoIGliID1cbiAgaWYgd2lkdGggPSAwIHRoZW4gYmFkX3Rva2VuX2xlbmd0aCBcImRlY2ltYWwgZGlnaXRzXCIgZWxzZVxuICBsZXQgYyA9IFNjYW5uaW5nLmNoZWNrZWRfcGVla19jaGFyIGliIGluXG4gIG1hdGNoIGMgd2l0aFxuICB8ICcwJyAuLiAnOScgLT5cbiAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICBzY2FuX2RlY2ltYWxfZGlnaXRfc3RhciB3aWR0aCBpYlxuICB8IGMgLT5cbiAgICBiYWRfaW5wdXQgKFByaW50Zi5zcHJpbnRmIFwiY2hhcmFjdGVyICVDIGlzIG5vdCBhIGRlY2ltYWwgZGlnaXRcIiBjKVxuXG5cbigqIFRvIHNjYW4gbnVtYmVycyBmcm9tIG90aGVyIGJhc2VzLCB3ZSB1c2UgYSBwcmVkaWNhdGUgYXJndW1lbnQgdG9cbiAgIHNjYW4gZGlnaXRzLiAqKVxubGV0IHNjYW5fZGlnaXRfc3RhciBkaWdpdHAgd2lkdGggaWIgPVxuICBsZXQgcmVjIHNjYW5fZGlnaXRzIHdpZHRoIGliID1cbiAgICBpZiB3aWR0aCA9IDAgdGhlbiB3aWR0aCBlbHNlXG4gICAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgICBpZiBTY2FubmluZy5lb2YgaWIgdGhlbiB3aWR0aCBlbHNlXG4gICAgbWF0Y2ggYyB3aXRoXG4gICAgfCBjIHdoZW4gZGlnaXRwIGMgLT5cbiAgICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgICAgc2Nhbl9kaWdpdHMgd2lkdGggaWJcbiAgICB8ICdfJyAtPlxuICAgICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuaWdub3JlX2NoYXIgd2lkdGggaWIgaW5cbiAgICAgIHNjYW5fZGlnaXRzIHdpZHRoIGliXG4gICAgfCBfIC0+IHdpZHRoIGluXG4gIHNjYW5fZGlnaXRzIHdpZHRoIGliXG5cblxubGV0IHNjYW5fZGlnaXRfcGx1cyBiYXNpcyBkaWdpdHAgd2lkdGggaWIgPVxuICAoKiBFbnN1cmUgd2UgaGF2ZSBnb3QgZW5vdWdoIHdpZHRoIGxlZnQsXG4gICAgIGFuZCByZWFkIGF0IGxlYXN0IG9uZSBkaWdpdC4gKilcbiAgaWYgd2lkdGggPSAwIHRoZW4gYmFkX3Rva2VuX2xlbmd0aCBcImRpZ2l0c1wiIGVsc2VcbiAgbGV0IGMgPSBTY2FubmluZy5jaGVja2VkX3BlZWtfY2hhciBpYiBpblxuICBpZiBkaWdpdHAgYyB0aGVuXG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgc2Nhbl9kaWdpdF9zdGFyIGRpZ2l0cCB3aWR0aCBpYlxuICBlbHNlXG4gICAgYmFkX2lucHV0IChQcmludGYuc3ByaW50ZiBcImNoYXJhY3RlciAlQyBpcyBub3QgYSB2YWxpZCAlcyBkaWdpdFwiIGMgYmFzaXMpXG5cblxubGV0IGlzX2JpbmFyeV9kaWdpdCA9IGZ1bmN0aW9uXG4gIHwgJzAnIC4uICcxJyAtPiB0cnVlXG4gIHwgXyAtPiBmYWxzZVxuXG5cbmxldCBzY2FuX2JpbmFyeV9pbnQgPSBzY2FuX2RpZ2l0X3BsdXMgXCJiaW5hcnlcIiBpc19iaW5hcnlfZGlnaXRcblxubGV0IGlzX29jdGFsX2RpZ2l0ID0gZnVuY3Rpb25cbiAgfCAnMCcgLi4gJzcnIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG5cblxubGV0IHNjYW5fb2N0YWxfaW50ID0gc2Nhbl9kaWdpdF9wbHVzIFwib2N0YWxcIiBpc19vY3RhbF9kaWdpdFxuXG5sZXQgaXNfaGV4YV9kaWdpdCA9IGZ1bmN0aW9uXG4gIHwgJzAnIC4uICc5JyB8ICdhJyAuLiAnZicgfCAnQScgLi4gJ0YnIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG5cblxubGV0IHNjYW5faGV4YWRlY2ltYWxfaW50ID0gc2Nhbl9kaWdpdF9wbHVzIFwiaGV4YWRlY2ltYWxcIiBpc19oZXhhX2RpZ2l0XG5cbigqIFNjYW4gYSBkZWNpbWFsIGludGVnZXIuICopXG5sZXQgc2Nhbl91bnNpZ25lZF9kZWNpbWFsX2ludCA9IHNjYW5fZGVjaW1hbF9kaWdpdF9wbHVzXG5cbmxldCBzY2FuX3NpZ24gd2lkdGggaWIgPVxuICBsZXQgYyA9IFNjYW5uaW5nLmNoZWNrZWRfcGVla19jaGFyIGliIGluXG4gIG1hdGNoIGMgd2l0aFxuICB8ICcrJyAtPiBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGNcbiAgfCAnLScgLT4gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjXG4gIHwgXyAtPiB3aWR0aFxuXG5cbmxldCBzY2FuX29wdGlvbmFsbHlfc2lnbmVkX2RlY2ltYWxfaW50IHdpZHRoIGliID1cbiAgbGV0IHdpZHRoID0gc2Nhbl9zaWduIHdpZHRoIGliIGluXG4gIHNjYW5fdW5zaWduZWRfZGVjaW1hbF9pbnQgd2lkdGggaWJcblxuXG4oKiBTY2FuIGFuIHVuc2lnbmVkIGludGVnZXIgdGhhdCBjb3VsZCBiZSBnaXZlbiBpbiBhbnkgKGNvbW1vbikgYmFzaXMuXG4gICBJZiBkaWdpdHMgYXJlIHByZWZpeGVkIGJ5IG9uZSBvZiAweCwgMFgsIDBvLCBvciAwYiwgdGhlIG51bWJlciBpc1xuICAgYXNzdW1lZCB0byBiZSB3cml0dGVuIHJlc3BlY3RpdmVseSBpbiBoZXhhZGVjaW1hbCwgaGV4YWRlY2ltYWwsXG4gICBvY3RhbCwgb3IgYmluYXJ5LiAqKVxubGV0IHNjYW5fdW5zaWduZWRfaW50IHdpZHRoIGliID1cbiAgbWF0Y2ggU2Nhbm5pbmcuY2hlY2tlZF9wZWVrX2NoYXIgaWIgd2l0aFxuICB8ICcwJyBhcyBjIC0+XG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgaWYgd2lkdGggPSAwIHRoZW4gd2lkdGggZWxzZVxuICAgIGxldCBjID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gICAgaWYgU2Nhbm5pbmcuZW9mIGliIHRoZW4gd2lkdGggZWxzZVxuICAgIGJlZ2luIG1hdGNoIGMgd2l0aFxuICAgIHwgJ3gnIHwgJ1gnIC0+IHNjYW5faGV4YWRlY2ltYWxfaW50IChTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMpIGliXG4gICAgfCAnbycgLT4gc2Nhbl9vY3RhbF9pbnQgKFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYykgaWJcbiAgICB8ICdiJyAtPiBzY2FuX2JpbmFyeV9pbnQgKFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYykgaWJcbiAgICB8IF8gLT4gc2Nhbl9kZWNpbWFsX2RpZ2l0X3N0YXIgd2lkdGggaWIgZW5kXG4gIHwgXyAtPiBzY2FuX3Vuc2lnbmVkX2RlY2ltYWxfaW50IHdpZHRoIGliXG5cblxubGV0IHNjYW5fb3B0aW9uYWxseV9zaWduZWRfaW50IHdpZHRoIGliID1cbiAgbGV0IHdpZHRoID0gc2Nhbl9zaWduIHdpZHRoIGliIGluXG4gIHNjYW5fdW5zaWduZWRfaW50IHdpZHRoIGliXG5cblxubGV0IHNjYW5faW50X2NvbnZlcnNpb24gY29udiB3aWR0aCBpYiA9XG4gIG1hdGNoIGNvbnYgd2l0aFxuICB8IEJfY29udmVyc2lvbiAtPiBzY2FuX2JpbmFyeV9pbnQgd2lkdGggaWJcbiAgfCBEX2NvbnZlcnNpb24gLT4gc2Nhbl9vcHRpb25hbGx5X3NpZ25lZF9kZWNpbWFsX2ludCB3aWR0aCBpYlxuICB8IElfY29udmVyc2lvbiAtPiBzY2FuX29wdGlvbmFsbHlfc2lnbmVkX2ludCB3aWR0aCBpYlxuICB8IE9fY29udmVyc2lvbiAtPiBzY2FuX29jdGFsX2ludCB3aWR0aCBpYlxuICB8IFVfY29udmVyc2lvbiAtPiBzY2FuX3Vuc2lnbmVkX2RlY2ltYWxfaW50IHdpZHRoIGliXG4gIHwgWF9jb252ZXJzaW9uIC0+IHNjYW5faGV4YWRlY2ltYWxfaW50IHdpZHRoIGliXG5cblxuKCogU2Nhbm5pbmcgZmxvYXRpbmcgcG9pbnQgbnVtYmVycy4gKilcblxuKCogRnJhY3Rpb25hbCBwYXJ0IGlzIG9wdGlvbmFsIGFuZCBjYW4gYmUgcmVkdWNlZCB0byAwIGRpZ2l0cy4gKilcbmxldCBzY2FuX2ZyYWN0aW9uYWxfcGFydCB3aWR0aCBpYiA9XG4gIGlmIHdpZHRoID0gMCB0aGVuIHdpZHRoIGVsc2VcbiAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgaWYgU2Nhbm5pbmcuZW9mIGliIHRoZW4gd2lkdGggZWxzZVxuICBtYXRjaCBjIHdpdGhcbiAgfCAnMCcgLi4gJzknIGFzIGMgLT5cbiAgICBzY2FuX2RlY2ltYWxfZGlnaXRfc3RhciAoU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjKSBpYlxuICB8IF8gLT4gd2lkdGhcblxuXG4oKiBFeHAgcGFydCBpcyBvcHRpb25hbCBhbmQgY2FuIGJlIHJlZHVjZWQgdG8gMCBkaWdpdHMuICopXG5sZXQgc2Nhbl9leHBvbmVudF9wYXJ0IHdpZHRoIGliID1cbiAgaWYgd2lkdGggPSAwIHRoZW4gd2lkdGggZWxzZVxuICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICBpZiBTY2FubmluZy5lb2YgaWIgdGhlbiB3aWR0aCBlbHNlXG4gIG1hdGNoIGMgd2l0aFxuICB8ICdlJyB8ICdFJyBhcyBjIC0+XG4gICAgc2Nhbl9vcHRpb25hbGx5X3NpZ25lZF9kZWNpbWFsX2ludCAoU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjKSBpYlxuICB8IF8gLT4gd2lkdGhcblxuXG4oKiBTY2FuIHRoZSBpbnRlZ2VyIHBhcnQgb2YgYSBmbG9hdGluZyBwb2ludCBudW1iZXIsIChub3QgdXNpbmcgdGhlXG4gICBPQ2FtbCBsZXhpY2FsIGNvbnZlbnRpb24gc2luY2UgdGhlIGludGVnZXIgcGFydCBjYW4gYmUgZW1wdHkpOlxuICAgYW4gb3B0aW9uYWwgc2lnbiwgZm9sbG93ZWQgYnkgYSBwb3NzaWJseSBlbXB0eSBzZXF1ZW5jZSBvZiBkZWNpbWFsXG4gICBkaWdpdHMgKGUuZy4gLS4xKS4gKilcbmxldCBzY2FuX2ludGVnZXJfcGFydCB3aWR0aCBpYiA9XG4gIGxldCB3aWR0aCA9IHNjYW5fc2lnbiB3aWR0aCBpYiBpblxuICBzY2FuX2RlY2ltYWxfZGlnaXRfc3RhciB3aWR0aCBpYlxuXG5cbigqXG4gICBGb3IgdGhlIHRpbWUgYmVpbmcgd2UgaGF2ZSAoYXMgZm91bmQgaW4gc2NhbmYubWxpKTpcbiAgIHRoZSBmaWVsZCB3aWR0aCBpcyBjb21wb3NlZCBvZiBhbiBvcHRpb25hbCBpbnRlZ2VyIGxpdGVyYWxcbiAgIGluZGljYXRpbmcgdGhlIG1heGltYWwgd2lkdGggb2YgdGhlIHRva2VuIHRvIHJlYWQuXG4gICBVbmZvcnR1bmF0ZWx5LCB0aGUgdHlwZS1jaGVja2VyIGxldCB0aGUgdXNlciB3cml0ZSBhbiBvcHRpb25hbCBwcmVjaXNpb24sXG4gICBzaW5jZSB0aGlzIGlzIHZhbGlkIGZvciBwcmludGYgZm9ybWF0IHN0cmluZ3MuXG5cbiAgIFRodXMsIHRoZSBuZXh0IHN0ZXAgZm9yIFNjYW5mIGlzIHRvIHN1cHBvcnQgYSBmdWxsIHdpZHRoIGFuZCBwcmVjaXNpb25cbiAgIGluZGljYXRpb24sIG1vcmUgb3IgbGVzcyBzaW1pbGFyIHRvIHRoZSBvbmUgZm9yIHByaW50ZiwgcG9zc2libHkgZXh0ZW5kZWRcbiAgIHRvIHRoZSBzcGVjaWZpY2F0aW9uIG9mIGEgW21heCwgbWluXSByYW5nZSBmb3IgdGhlIHdpZHRoIG9mIHRoZSB0b2tlbiByZWFkXG4gICBmb3Igc3RyaW5ncy4gU29tZXRoaW5nIGxpa2UgdGhlIGZvbGxvd2luZyBzcGVjIGZvciBzY2FuZi5tbGk6XG5cbiAgIFRoZSBvcHRpb25hbCBbd2lkdGhdIGlzIGFuIGludGVnZXIgaW5kaWNhdGluZyB0aGUgbWF4aW1hbFxuICAgd2lkdGggb2YgdGhlIHRva2VuIHJlYWQuIEZvciBpbnN0YW5jZSwgWyU2ZF0gcmVhZHMgYW4gaW50ZWdlcixcbiAgIGhhdmluZyBhdCBtb3N0IDYgY2hhcmFjdGVycy5cblxuICAgVGhlIG9wdGlvbmFsIFtwcmVjaXNpb25dIGlzIGEgZG90IFsuXSBmb2xsb3dlZCBieSBhbiBpbnRlZ2VyOlxuXG4gICAtIGluIHRoZSBmbG9hdGluZyBwb2ludCBudW1iZXIgY29udmVyc2lvbnMgKFslZl0sIFslZV0sIFslZ10sIFslRl0sIFslRV0sXG4gICBhbmQgWyVGXSBjb252ZXJzaW9ucywgdGhlIFtwcmVjaXNpb25dIGluZGljYXRlcyB0aGUgbWF4aW11bSBudW1iZXIgb2ZcbiAgIGRpZ2l0cyB0aGF0IG1heSBmb2xsb3cgdGhlIGRlY2ltYWwgcG9pbnQuIEZvciBpbnN0YW5jZSwgWyUuNGZdIHJlYWRzIGFcbiAgIFtmbG9hdF0gd2l0aCBhdCBtb3N0IDQgZnJhY3Rpb25hbCBkaWdpdHMsXG5cbiAgIC0gaW4gdGhlIHN0cmluZyBjb252ZXJzaW9ucyAoWyVzXSwgWyVTXSwgWyVcXFsgcmFuZ2UgXFxdXSksIGFuZCBpbiB0aGVcbiAgIGludGVnZXIgbnVtYmVyIGNvbnZlcnNpb25zIChbJWldLCBbJWRdLCBbJXVdLCBbJXhdLCBbJW9dLCBhbmQgdGhlaXJcbiAgIFtpbnQzMl0sIFtpbnQ2NF0sIGFuZCBbbmF0aXZlX2ludF0gY29ycmVzcG9uZGVudCksIHRoZSBbcHJlY2lzaW9uXVxuICAgaW5kaWNhdGVzIHRoZSByZXF1aXJlZCBtaW5pbXVtIHdpZHRoIG9mIHRoZSB0b2tlbiByZWFkLFxuXG4gICAtIG9uIGFsbCBvdGhlciBjb252ZXJzaW9ucywgdGhlIHdpZHRoIGFuZCBwcmVjaXNpb24gc3BlY2lmeSB0aGUgW21heCwgbWluXVxuICAgcmFuZ2UgZm9yIHRoZSB3aWR0aCBvZiB0aGUgdG9rZW4gcmVhZC5cbiopXG5sZXQgc2Nhbl9mbG9hdCB3aWR0aCBwcmVjaXNpb24gaWIgPVxuICBsZXQgd2lkdGggPSBzY2FuX2ludGVnZXJfcGFydCB3aWR0aCBpYiBpblxuICBpZiB3aWR0aCA9IDAgdGhlbiB3aWR0aCwgcHJlY2lzaW9uIGVsc2VcbiAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgaWYgU2Nhbm5pbmcuZW9mIGliIHRoZW4gd2lkdGgsIHByZWNpc2lvbiBlbHNlXG4gIG1hdGNoIGMgd2l0aFxuICB8ICcuJyAtPlxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgIGxldCBwcmVjaXNpb24gPSBtaW4gd2lkdGggcHJlY2lzaW9uIGluXG4gICAgbGV0IHdpZHRoID0gd2lkdGggLSAocHJlY2lzaW9uIC0gc2Nhbl9mcmFjdGlvbmFsX3BhcnQgcHJlY2lzaW9uIGliKSBpblxuICAgIHNjYW5fZXhwb25lbnRfcGFydCB3aWR0aCBpYiwgcHJlY2lzaW9uXG4gIHwgXyAtPlxuICAgIHNjYW5fZXhwb25lbnRfcGFydCB3aWR0aCBpYiwgcHJlY2lzaW9uXG5cblxubGV0IGNoZWNrX2Nhc2VfaW5zZW5zaXRpdmVfc3RyaW5nIHdpZHRoIGliIGVycm9yIHN0ciA9XG4gIGxldCBsb3dlcmNhc2UgYyA9XG4gICAgbWF0Y2ggYyB3aXRoXG4gICAgfCAnQScgLi4gJ1onIC0+XG4gICAgICBjaGFyX29mX2ludCAoaW50X29mX2NoYXIgYyAtIGludF9vZl9jaGFyICdBJyArIGludF9vZl9jaGFyICdhJylcbiAgICB8IF8gLT4gYyBpblxuICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzdHIgaW5cbiAgbGV0IHdpZHRoID0gcmVmIHdpZHRoIGluXG4gIGZvciBpID0gMCB0byBsZW4gLSAxIGRvXG4gICAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgICBpZiBsb3dlcmNhc2UgYyA8PiBsb3dlcmNhc2Ugc3RyLltpXSB0aGVuIGVycm9yICgpO1xuICAgIGlmICF3aWR0aCA9IDAgdGhlbiBlcnJvciAoKTtcbiAgICB3aWR0aCA6PSBTY2FubmluZy5zdG9yZV9jaGFyICF3aWR0aCBpYiBjO1xuICBkb25lO1xuICAhd2lkdGhcblxuXG5sZXQgc2Nhbl9oZXhfZmxvYXQgd2lkdGggcHJlY2lzaW9uIGliID1cbiAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9oZXhfZmxvYXQgKCk7XG4gIGxldCB3aWR0aCA9IHNjYW5fc2lnbiB3aWR0aCBpYiBpblxuICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2hleF9mbG9hdCAoKTtcbiAgbWF0Y2ggU2Nhbm5pbmcucGVla19jaGFyIGliIHdpdGhcbiAgfCAnMCcgYXMgYyAtPiAoXG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9oZXhfZmxvYXQgKCk7XG4gICAgbGV0IHdpZHRoID0gY2hlY2tfY2FzZV9pbnNlbnNpdGl2ZV9zdHJpbmcgd2lkdGggaWIgYmFkX2hleF9mbG9hdCBcInhcIiBpblxuICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiB3aWR0aCBlbHNlXG4gICAgICBsZXQgd2lkdGggPSBtYXRjaCBTY2FubmluZy5wZWVrX2NoYXIgaWIgd2l0aFxuICAgICAgICB8ICcuJyB8ICdwJyB8ICdQJyAtPiB3aWR0aFxuICAgICAgICB8IF8gLT4gc2Nhbl9oZXhhZGVjaW1hbF9pbnQgd2lkdGggaWIgaW5cbiAgICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiB3aWR0aCBlbHNlXG4gICAgICAgIGxldCB3aWR0aCA9IG1hdGNoIFNjYW5uaW5nLnBlZWtfY2hhciBpYiB3aXRoXG4gICAgICAgICAgfCAnLicgYXMgYyAtPiAoXG4gICAgICAgICAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICAgICAgICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiB3aWR0aCBlbHNlXG4gICAgICAgICAgICAgIG1hdGNoIFNjYW5uaW5nLnBlZWtfY2hhciBpYiB3aXRoXG4gICAgICAgICAgICAgIHwgJ3AnIHwgJ1AnIC0+IHdpZHRoXG4gICAgICAgICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgICAgIGxldCBwcmVjaXNpb24gPSBtaW4gd2lkdGggcHJlY2lzaW9uIGluXG4gICAgICAgICAgICAgICAgd2lkdGggLSAocHJlY2lzaW9uIC0gc2Nhbl9oZXhhZGVjaW1hbF9pbnQgcHJlY2lzaW9uIGliKVxuICAgICAgICAgIClcbiAgICAgICAgICB8IF8gLT4gd2lkdGggaW5cbiAgICAgICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgICAgICAgICBtYXRjaCBTY2FubmluZy5wZWVrX2NoYXIgaWIgd2l0aFxuICAgICAgICAgIHwgJ3AnIHwgJ1AnIGFzIGMgLT5cbiAgICAgICAgICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgICAgICAgICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9oZXhfZmxvYXQgKCk7XG4gICAgICAgICAgICBzY2FuX29wdGlvbmFsbHlfc2lnbmVkX2RlY2ltYWxfaW50IHdpZHRoIGliXG4gICAgICAgICAgfCBfIC0+IHdpZHRoXG4gIClcbiAgfCAnbicgfCAnTicgYXMgYyAtPlxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfaGV4X2Zsb2F0ICgpO1xuICAgIGNoZWNrX2Nhc2VfaW5zZW5zaXRpdmVfc3RyaW5nIHdpZHRoIGliIGJhZF9oZXhfZmxvYXQgXCJhblwiXG4gIHwgJ2knIHwgJ0knIGFzIGMgLT5cbiAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2hleF9mbG9hdCAoKTtcbiAgICBjaGVja19jYXNlX2luc2Vuc2l0aXZlX3N0cmluZyB3aWR0aCBpYiBiYWRfaGV4X2Zsb2F0IFwibmZpbml0eVwiXG4gIHwgXyAtPiBiYWRfaGV4X2Zsb2F0ICgpXG5cblxubGV0IHNjYW5fY2FtbF9mbG9hdF9yZXN0IHdpZHRoIHByZWNpc2lvbiBpYiA9XG4gIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfZmxvYXQgKCk7XG4gIGxldCB3aWR0aCA9IHNjYW5fZGVjaW1hbF9kaWdpdF9zdGFyIHdpZHRoIGliIGluXG4gIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfZmxvYXQgKCk7XG4gIGxldCBjID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gIG1hdGNoIGMgd2l0aFxuICB8ICcuJyAtPlxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgICgqIFRoZSBlZmZlY3RpdmUgd2lkdGggYXZhaWxhYmxlIGZvciBzY2FubmluZyB0aGUgZnJhY3Rpb25hbCBwYXJ0IGlzXG4gICAgICAgdGhlIG1pbmltdW0gb2YgZGVjbGFyZWQgcHJlY2lzaW9uIGFuZCB3aWR0aCBsZWZ0LiAqKVxuICAgIGxldCBwcmVjaXNpb24gPSBtaW4gd2lkdGggcHJlY2lzaW9uIGluXG4gICAgKCogQWZ0ZXIgc2Nhbm5pbmcgdGhlIGZyYWN0aW9uYWwgcGFydCB3aXRoIFtwcmVjaXNpb25dIHByb3Zpc2lvbmFsIHdpZHRoLFxuICAgICAgIFt3aWR0aF9wcmVjaXNpb25dIGlzIGxlZnQuICopXG4gICAgbGV0IHdpZHRoX3ByZWNpc2lvbiA9IHNjYW5fZnJhY3Rpb25hbF9wYXJ0IHByZWNpc2lvbiBpYiBpblxuICAgICgqIEhlbmNlLCBzY2FubmluZyB0aGUgZnJhY3Rpb25hbCBwYXJ0IHRvb2sgZXhhY3RseVxuICAgICAgIFtwcmVjaXNpb24gLSB3aWR0aF9wcmVjaXNpb25dIGNoYXJzLiAqKVxuICAgIGxldCBmcmFjX3dpZHRoID0gcHJlY2lzaW9uIC0gd2lkdGhfcHJlY2lzaW9uIGluXG4gICAgKCogQW5kIG5ldyBwcm92aXNpb25hbCB3aWR0aCBpcyBbd2lkdGggLSB3aWR0aF9wcmVjaXNpb24uICopXG4gICAgbGV0IHdpZHRoID0gd2lkdGggLSBmcmFjX3dpZHRoIGluXG4gICAgc2Nhbl9leHBvbmVudF9wYXJ0IHdpZHRoIGliXG4gIHwgJ2UnIHwgJ0UnIC0+XG4gICAgc2Nhbl9leHBvbmVudF9wYXJ0IHdpZHRoIGliXG4gIHwgXyAtPiBiYWRfZmxvYXQgKClcblxuXG5sZXQgc2Nhbl9jYW1sX2Zsb2F0IHdpZHRoIHByZWNpc2lvbiBpYiA9XG4gIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfZmxvYXQgKCk7XG4gIGxldCB3aWR0aCA9IHNjYW5fc2lnbiB3aWR0aCBpYiBpblxuICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2Zsb2F0ICgpO1xuICBtYXRjaCBTY2FubmluZy5wZWVrX2NoYXIgaWIgd2l0aFxuICB8ICcwJyBhcyBjIC0+IChcbiAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2Zsb2F0ICgpO1xuICAgIG1hdGNoIFNjYW5uaW5nLnBlZWtfY2hhciBpYiB3aXRoXG4gICAgfCAneCcgfCAnWCcgYXMgYyAtPiAoXG4gICAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfZmxvYXQgKCk7XG4gICAgICBsZXQgd2lkdGggPSBzY2FuX2hleGFkZWNpbWFsX2ludCB3aWR0aCBpYiBpblxuICAgICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9mbG9hdCAoKTtcbiAgICAgIGxldCB3aWR0aCA9IG1hdGNoIFNjYW5uaW5nLnBlZWtfY2hhciBpYiB3aXRoXG4gICAgICAgIHwgJy4nIGFzIGMgLT4gKFxuICAgICAgICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgICAgICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiB3aWR0aCBlbHNlXG4gICAgICAgICAgICBtYXRjaCBTY2FubmluZy5wZWVrX2NoYXIgaWIgd2l0aFxuICAgICAgICAgICAgfCAncCcgfCAnUCcgLT4gd2lkdGhcbiAgICAgICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgICBsZXQgcHJlY2lzaW9uID0gbWluIHdpZHRoIHByZWNpc2lvbiBpblxuICAgICAgICAgICAgICB3aWR0aCAtIChwcmVjaXNpb24gLSBzY2FuX2hleGFkZWNpbWFsX2ludCBwcmVjaXNpb24gaWIpXG4gICAgICAgIClcbiAgICAgICAgfCAncCcgfCAnUCcgLT4gd2lkdGhcbiAgICAgICAgfCBfIC0+IGJhZF9mbG9hdCAoKSBpblxuICAgICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgICAgICAgbWF0Y2ggU2Nhbm5pbmcucGVla19jaGFyIGliIHdpdGhcbiAgICAgICAgfCAncCcgfCAnUCcgYXMgYyAtPlxuICAgICAgICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgICAgICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfaGV4X2Zsb2F0ICgpO1xuICAgICAgICAgIHNjYW5fb3B0aW9uYWxseV9zaWduZWRfZGVjaW1hbF9pbnQgd2lkdGggaWJcbiAgICAgICAgfCBfIC0+IHdpZHRoXG4gICAgKVxuICAgIHwgXyAtPlxuICAgICAgc2Nhbl9jYW1sX2Zsb2F0X3Jlc3Qgd2lkdGggcHJlY2lzaW9uIGliXG4gIClcbiAgfCAnMScgLi4gJzknIGFzIGMgLT5cbiAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2Zsb2F0ICgpO1xuICAgIHNjYW5fY2FtbF9mbG9hdF9yZXN0IHdpZHRoIHByZWNpc2lvbiBpYlxuKCogU3BlY2lhbCBjYXNlIG9mIG5hbiBhbmQgaW5maW5pdHk6XG4gIHwgJ2knIC0+XG4gIHwgJ24nIC0+XG4qKVxuICB8IF8gLT4gYmFkX2Zsb2F0ICgpXG5cblxuKCogU2NhbiBhIHJlZ3VsYXIgc3RyaW5nOlxuICAgc3RvcHMgd2hlbiBlbmNvdW50ZXJpbmcgYSBzcGFjZSwgaWYgbm8gc2Nhbm5pbmcgaW5kaWNhdGlvbiBoYXMgYmVlbiBnaXZlbjtcbiAgIG90aGVyd2lzZSwgc3RvcHMgd2hlbiBlbmNvdW50ZXJpbmcgdGhlIGNoYXJhY3RlcnMgaW4gdGhlIHNjYW5uaW5nXG4gICBpbmRpY2F0aW9uIFtzdHBdLlxuICAgSXQgYWxzbyBzdG9wcyBhdCBlbmQgb2YgZmlsZSBvciB3aGVuIHRoZSBtYXhpbXVtIG51bWJlciBvZiBjaGFyYWN0ZXJzIGhhc1xuICAgYmVlbiByZWFkLiAqKVxubGV0IHNjYW5fc3RyaW5nIHN0cCB3aWR0aCBpYiA9XG4gIGxldCByZWMgbG9vcCB3aWR0aCA9XG4gICAgaWYgd2lkdGggPSAwIHRoZW4gd2lkdGggZWxzZVxuICAgIGxldCBjID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gICAgaWYgU2Nhbm5pbmcuZW9mIGliIHRoZW4gd2lkdGggZWxzZVxuICAgICAgbWF0Y2ggc3RwIHdpdGhcbiAgICAgIHwgU29tZSBjJyB3aGVuIGMgPSBjJyAtPiBTY2FubmluZy5za2lwX2NoYXIgd2lkdGggaWJcbiAgICAgIHwgU29tZSBfIC0+IGxvb3AgKFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYylcbiAgICAgIHwgTm9uZSAtPlxuICAgICAgICBtYXRjaCBjIHdpdGhcbiAgICAgICAgfCAnICcgfCAnXFx0JyB8ICdcXG4nIHwgJ1xccicgLT4gd2lkdGhcbiAgICAgICAgfCBfIC0+IGxvb3AgKFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYykgaW5cbiAgbG9vcCB3aWR0aFxuXG5cbigqIFNjYW4gYSBjaGFyOiBwZWVrIHN0cmljdGx5IG9uZSBjaGFyYWN0ZXIgaW4gdGhlIGlucHV0LCB3aGF0c29ldmVyLiAqKVxubGV0IHNjYW5fY2hhciB3aWR0aCBpYiA9XG4gICgqIFRoZSBjYXNlIHdpZHRoID0gMCBjb3VsZCBub3QgaGFwcGVuIGhlcmUsIHNpbmNlIGl0IGlzIHRlc3RlZCBiZWZvcmVcbiAgICAgY2FsbGluZyBzY2FuX2NoYXIsIGluIHRoZSBtYWluIHNjYW5uaW5nIGZ1bmN0aW9uLlxuICAgIGlmIHdpZHRoID0gMCB0aGVuIGJhZF90b2tlbl9sZW5ndGggXCJhIGNoYXJhY3RlclwiIGVsc2UgKilcbiAgU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiAoU2Nhbm5pbmcuY2hlY2tlZF9wZWVrX2NoYXIgaWIpXG5cblxubGV0IGNoYXJfZm9yX2JhY2tzbGFzaCA9IGZ1bmN0aW9uXG4gIHwgJ24nIC0+ICdcXDAxMCdcbiAgfCAncicgLT4gJ1xcMDEzJ1xuICB8ICdiJyAtPiAnXFwwMDgnXG4gIHwgJ3QnIC0+ICdcXDAwOSdcbiAgfCBjIC0+IGNcblxuXG4oKiBUaGUgaW50ZWdlciB2YWx1ZSBjb3JyZXNwb25kaW5nIHRvIHRoZSBmYWNpYWwgdmFsdWUgb2YgYSB2YWxpZFxuICAgZGVjaW1hbCBkaWdpdCBjaGFyYWN0ZXIuICopXG5sZXQgZGVjaW1hbF92YWx1ZV9vZl9jaGFyIGMgPSBpbnRfb2ZfY2hhciBjIC0gaW50X29mX2NoYXIgJzAnXG5cbmxldCBjaGFyX2Zvcl9kZWNpbWFsX2NvZGUgYzAgYzEgYzIgPVxuICBsZXQgYyA9XG4gICAgMTAwICogZGVjaW1hbF92YWx1ZV9vZl9jaGFyIGMwICtcbiAgICAgMTAgKiBkZWNpbWFsX3ZhbHVlX29mX2NoYXIgYzEgK1xuICAgICAgICAgIGRlY2ltYWxfdmFsdWVfb2ZfY2hhciBjMiBpblxuICBpZiBjIDwgMCB8fCBjID4gMjU1IHRoZW5cbiAgICBiYWRfaW5wdXRcbiAgICAgIChQcmludGYuc3ByaW50ZlxuICAgICAgICAgXCJiYWQgY2hhcmFjdGVyIGRlY2ltYWwgZW5jb2RpbmcgXFxcXCVjJWMlY1wiIGMwIGMxIGMyKSBlbHNlXG4gIGNoYXJfb2ZfaW50IGNcblxuXG4oKiBUaGUgaW50ZWdlciB2YWx1ZSBjb3JyZXNwb25kaW5nIHRvIHRoZSBmYWNpYWwgdmFsdWUgb2YgYSB2YWxpZFxuICAgaGV4YWRlY2ltYWwgZGlnaXQgY2hhcmFjdGVyLiAqKVxubGV0IGhleGFkZWNpbWFsX3ZhbHVlX29mX2NoYXIgYyA9XG4gIGxldCBkID0gaW50X29mX2NoYXIgYyBpblxuICAoKiBDb3VsZCBhbHNvIGJlOlxuICAgIGlmIGQgPD0gaW50X29mX2NoYXIgJzknIHRoZW4gZCAtIGludF9vZl9jaGFyICcwJyBlbHNlXG4gICAgaWYgZCA8PSBpbnRfb2ZfY2hhciAnRicgdGhlbiAxMCArIGQgLSBpbnRfb2ZfY2hhciAnQScgZWxzZVxuICAgIGlmIGQgPD0gaW50X29mX2NoYXIgJ2YnIHRoZW4gMTAgKyBkIC0gaW50X29mX2NoYXIgJ2EnIGVsc2UgYXNzZXJ0IGZhbHNlXG4gICopXG4gIGlmIGQgPj0gaW50X29mX2NoYXIgJ2EnIHRoZW5cbiAgICBkIC0gODcgKCogMTAgKyBpbnRfb2ZfY2hhciBjIC0gaW50X29mX2NoYXIgJ2EnICopIGVsc2VcbiAgaWYgZCA+PSBpbnRfb2ZfY2hhciAnQScgdGhlblxuICAgIGQgLSA1NSAgKCogMTAgKyBpbnRfb2ZfY2hhciBjIC0gaW50X29mX2NoYXIgJ0EnICopIGVsc2VcbiAgICBkIC0gaW50X29mX2NoYXIgJzAnXG5cblxubGV0IGNoYXJfZm9yX2hleGFkZWNpbWFsX2NvZGUgYzEgYzIgPVxuICBsZXQgYyA9XG4gICAgMTYgKiBoZXhhZGVjaW1hbF92YWx1ZV9vZl9jaGFyIGMxICtcbiAgICAgICAgIGhleGFkZWNpbWFsX3ZhbHVlX29mX2NoYXIgYzIgaW5cbiAgaWYgYyA8IDAgfHwgYyA+IDI1NSB0aGVuXG4gICAgYmFkX2lucHV0XG4gICAgICAoUHJpbnRmLnNwcmludGYgXCJiYWQgY2hhcmFjdGVyIGhleGFkZWNpbWFsIGVuY29kaW5nIFxcXFwlYyVjXCIgYzEgYzIpIGVsc2VcbiAgY2hhcl9vZl9pbnQgY1xuXG5cbigqIENhbGxlZCBpbiBwYXJ0aWN1bGFyIHdoZW4gZW5jb3VudGVyaW5nICdcXFxcJyBhcyBzdGFydGVyIG9mIGEgY2hhci5cbiAgIFN0b3BzIGJlZm9yZSB0aGUgY29ycmVzcG9uZGluZyAnXFwnJy4gKilcbmxldCBjaGVja19uZXh0X2NoYXIgbWVzc2FnZSB3aWR0aCBpYiA9XG4gIGlmIHdpZHRoID0gMCB0aGVuIGJhZF90b2tlbl9sZW5ndGggbWVzc2FnZSBlbHNlXG4gIGxldCBjID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gIGlmIFNjYW5uaW5nLmVvZiBpYiB0aGVuIGJhZF9lbmRfb2ZfaW5wdXQgbWVzc2FnZSBlbHNlXG4gIGNcblxuXG5sZXQgY2hlY2tfbmV4dF9jaGFyX2Zvcl9jaGFyID0gY2hlY2tfbmV4dF9jaGFyIFwiYSBDaGFyXCJcbmxldCBjaGVja19uZXh0X2NoYXJfZm9yX3N0cmluZyA9IGNoZWNrX25leHRfY2hhciBcImEgU3RyaW5nXCJcblxubGV0IHNjYW5fYmFja3NsYXNoX2NoYXIgd2lkdGggaWIgPVxuICBtYXRjaCBjaGVja19uZXh0X2NoYXJfZm9yX2NoYXIgd2lkdGggaWIgd2l0aFxuICB8ICdcXFxcJyB8ICdcXCcnIHwgJ1xcXCInIHwgJ24nIHwgJ3QnIHwgJ2InIHwgJ3InIGFzIGMgLT5cbiAgICBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIChjaGFyX2Zvcl9iYWNrc2xhc2ggYylcbiAgfCAnMCcgLi4gJzknIGFzIGMgLT5cbiAgICBsZXQgZ2V0X2RpZ2l0ICgpID1cbiAgICAgIGxldCBjID0gU2Nhbm5pbmcubmV4dF9jaGFyIGliIGluXG4gICAgICBtYXRjaCBjIHdpdGhcbiAgICAgIHwgJzAnIC4uICc5JyBhcyBjIC0+IGNcbiAgICAgIHwgYyAtPiBiYWRfaW5wdXRfZXNjYXBlIGMgaW5cbiAgICBsZXQgYzAgPSBjIGluXG4gICAgbGV0IGMxID0gZ2V0X2RpZ2l0ICgpIGluXG4gICAgbGV0IGMyID0gZ2V0X2RpZ2l0ICgpIGluXG4gICAgU2Nhbm5pbmcuc3RvcmVfY2hhciAod2lkdGggLSAyKSBpYiAoY2hhcl9mb3JfZGVjaW1hbF9jb2RlIGMwIGMxIGMyKVxuICB8ICd4JyAtPlxuICAgIGxldCBnZXRfZGlnaXQgKCkgPVxuICAgICAgbGV0IGMgPSBTY2FubmluZy5uZXh0X2NoYXIgaWIgaW5cbiAgICAgIG1hdGNoIGMgd2l0aFxuICAgICAgfCAnMCcgLi4gJzknIHwgJ0EnIC4uICdGJyB8ICdhJyAuLiAnZicgYXMgYyAtPiBjXG4gICAgICB8IGMgLT4gYmFkX2lucHV0X2VzY2FwZSBjIGluXG4gICAgbGV0IGMxID0gZ2V0X2RpZ2l0ICgpIGluXG4gICAgbGV0IGMyID0gZ2V0X2RpZ2l0ICgpIGluXG4gICAgU2Nhbm5pbmcuc3RvcmVfY2hhciAod2lkdGggLSAyKSBpYiAoY2hhcl9mb3JfaGV4YWRlY2ltYWxfY29kZSBjMSBjMilcbiAgfCBjIC0+XG4gICAgYmFkX2lucHV0X2VzY2FwZSBjXG5cblxuKCogU2NhbiBhIGNoYXJhY3RlciAoYW4gT0NhbWwgdG9rZW4pLiAqKVxubGV0IHNjYW5fY2FtbF9jaGFyIHdpZHRoIGliID1cblxuICBsZXQgcmVjIGZpbmRfc3RhcnQgd2lkdGggPVxuICAgIG1hdGNoIFNjYW5uaW5nLmNoZWNrZWRfcGVla19jaGFyIGliIHdpdGhcbiAgICB8ICdcXCcnIC0+IGZpbmRfY2hhciAoU2Nhbm5pbmcuaWdub3JlX2NoYXIgd2lkdGggaWIpXG4gICAgfCBjIC0+IGNoYXJhY3Rlcl9taXNtYXRjaCAnXFwnJyBjXG5cbiAgYW5kIGZpbmRfY2hhciB3aWR0aCA9XG4gICAgbWF0Y2ggY2hlY2tfbmV4dF9jaGFyX2Zvcl9jaGFyIHdpZHRoIGliIHdpdGhcbiAgICB8ICdcXFxcJyAtPlxuICAgICAgZmluZF9zdG9wIChzY2FuX2JhY2tzbGFzaF9jaGFyIChTY2FubmluZy5pZ25vcmVfY2hhciB3aWR0aCBpYikgaWIpXG4gICAgfCBjIC0+XG4gICAgICBmaW5kX3N0b3AgKFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYylcblxuICBhbmQgZmluZF9zdG9wIHdpZHRoID1cbiAgICBtYXRjaCBjaGVja19uZXh0X2NoYXJfZm9yX2NoYXIgd2lkdGggaWIgd2l0aFxuICAgIHwgJ1xcJycgLT4gU2Nhbm5pbmcuaWdub3JlX2NoYXIgd2lkdGggaWJcbiAgICB8IGMgLT4gY2hhcmFjdGVyX21pc21hdGNoICdcXCcnIGMgaW5cblxuICBmaW5kX3N0YXJ0IHdpZHRoXG5cblxuKCogU2NhbiBhIGRlbGltaXRlZCBzdHJpbmcgKGFuIE9DYW1sIHRva2VuKS4gKilcbmxldCBzY2FuX2NhbWxfc3RyaW5nIHdpZHRoIGliID1cblxuICBsZXQgcmVjIGZpbmRfc3RhcnQgd2lkdGggPVxuICAgIG1hdGNoIFNjYW5uaW5nLmNoZWNrZWRfcGVla19jaGFyIGliIHdpdGhcbiAgICB8ICdcXFwiJyAtPiBmaW5kX3N0b3AgKFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliKVxuICAgIHwgYyAtPiBjaGFyYWN0ZXJfbWlzbWF0Y2ggJ1xcXCInIGNcblxuICBhbmQgZmluZF9zdG9wIHdpZHRoID1cbiAgICBtYXRjaCBjaGVja19uZXh0X2NoYXJfZm9yX3N0cmluZyB3aWR0aCBpYiB3aXRoXG4gICAgfCAnXFxcIicgLT4gU2Nhbm5pbmcuaWdub3JlX2NoYXIgd2lkdGggaWJcbiAgICB8ICdcXFxcJyAtPiBzY2FuX2JhY2tzbGFzaCAoU2Nhbm5pbmcuaWdub3JlX2NoYXIgd2lkdGggaWIpXG4gICAgfCBjIC0+IGZpbmRfc3RvcCAoU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjKVxuXG4gIGFuZCBzY2FuX2JhY2tzbGFzaCB3aWR0aCA9XG4gICAgbWF0Y2ggY2hlY2tfbmV4dF9jaGFyX2Zvcl9zdHJpbmcgd2lkdGggaWIgd2l0aFxuICAgIHwgJ1xccicgLT4gc2tpcF9uZXdsaW5lIChTY2FubmluZy5pZ25vcmVfY2hhciB3aWR0aCBpYilcbiAgICB8ICdcXG4nIC0+IHNraXBfc3BhY2VzIChTY2FubmluZy5pZ25vcmVfY2hhciB3aWR0aCBpYilcbiAgICB8IF8gLT4gZmluZF9zdG9wIChzY2FuX2JhY2tzbGFzaF9jaGFyIHdpZHRoIGliKVxuXG4gIGFuZCBza2lwX25ld2xpbmUgd2lkdGggPVxuICAgIG1hdGNoIGNoZWNrX25leHRfY2hhcl9mb3Jfc3RyaW5nIHdpZHRoIGliIHdpdGhcbiAgICB8ICdcXG4nIC0+IHNraXBfc3BhY2VzIChTY2FubmluZy5pZ25vcmVfY2hhciB3aWR0aCBpYilcbiAgICB8IF8gLT4gZmluZF9zdG9wIChTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliICdcXHInKVxuXG4gIGFuZCBza2lwX3NwYWNlcyB3aWR0aCA9XG4gICAgbWF0Y2ggY2hlY2tfbmV4dF9jaGFyX2Zvcl9zdHJpbmcgd2lkdGggaWIgd2l0aFxuICAgIHwgJyAnIC0+IHNraXBfc3BhY2VzIChTY2FubmluZy5pZ25vcmVfY2hhciB3aWR0aCBpYilcbiAgICB8IF8gLT4gZmluZF9zdG9wIHdpZHRoIGluXG5cbiAgZmluZF9zdGFydCB3aWR0aFxuXG5cbigqIFNjYW4gYSBib29sZWFuIChhbiBPQ2FtbCB0b2tlbikuICopXG5sZXQgc2Nhbl9ib29sIGliID1cbiAgbGV0IGMgPSBTY2FubmluZy5jaGVja2VkX3BlZWtfY2hhciBpYiBpblxuICBsZXQgbSA9XG4gICAgbWF0Y2ggYyB3aXRoXG4gICAgfCAndCcgLT4gNFxuICAgIHwgJ2YnIC0+IDVcbiAgICB8IGMgLT5cbiAgICAgIGJhZF9pbnB1dFxuICAgICAgICAoUHJpbnRmLnNwcmludGYgXCJ0aGUgY2hhcmFjdGVyICVDIGNhbm5vdCBzdGFydCBhIGJvb2xlYW5cIiBjKSBpblxuICBzY2FuX3N0cmluZyBOb25lIG0gaWJcblxuXG4oKiBTY2FuIGEgc3RyaW5nIGNvbnRhaW5pbmcgZWxlbWVudHMgaW4gY2hhcl9zZXQgYW5kIHRlcm1pbmF0ZWQgYnkgc2Nhbl9pbmRpY1xuICAgaWYgcHJvdmlkZWQuICopXG5sZXQgc2Nhbl9jaGFyc19pbl9jaGFyX3NldCBjaGFyX3NldCBzY2FuX2luZGljIHdpZHRoIGliID1cbiAgbGV0IHJlYyBzY2FuX2NoYXJzIGkgc3RwID1cbiAgICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICAgIGlmIGkgPiAwICYmIG5vdCAoU2Nhbm5pbmcuZW9mIGliKSAmJlxuICAgICAgIGlzX2luX2NoYXJfc2V0IGNoYXJfc2V0IGMgJiZcbiAgICAgICBpbnRfb2ZfY2hhciBjIDw+IHN0cCB0aGVuXG4gICAgICBsZXQgXyA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgbWF4X2ludCBpYiBjIGluXG4gICAgICBzY2FuX2NoYXJzIChpIC0gMSkgc3RwIGluXG4gIG1hdGNoIHNjYW5faW5kaWMgd2l0aFxuICB8IE5vbmUgLT4gc2Nhbl9jaGFycyB3aWR0aCAoLTEpO1xuICB8IFNvbWUgYyAtPlxuICAgIHNjYW5fY2hhcnMgd2lkdGggKGludF9vZl9jaGFyIGMpO1xuICAgIGlmIG5vdCAoU2Nhbm5pbmcuZW9mIGliKSB0aGVuXG4gICAgICBsZXQgY2kgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgICAgIGlmIGMgPSBjaVxuICAgICAgdGhlbiBTY2FubmluZy5pbnZhbGlkYXRlX2N1cnJlbnRfY2hhciBpYlxuICAgICAgZWxzZSBjaGFyYWN0ZXJfbWlzbWF0Y2ggYyBjaVxuXG5cbigqIFRoZSBnbG9iYWwgZXJyb3IgcmVwb3J0IGZ1bmN0aW9uIGZvciBbU2NhbmZdLiAqKVxubGV0IHNjYW5mX2JhZF9pbnB1dCBpYiA9IGZ1bmN0aW9uXG4gIHwgU2Nhbl9mYWlsdXJlIHMgfCBGYWlsdXJlIHMgLT5cbiAgICBsZXQgaSA9IFNjYW5uaW5nLmNoYXJfY291bnQgaWIgaW5cbiAgICBiYWRfaW5wdXQgKFByaW50Zi5zcHJpbnRmIFwic2NhbmY6IGJhZCBpbnB1dCBhdCBjaGFyIG51bWJlciAlaTogJXNcIiBpIHMpXG4gIHwgeCAtPiByYWlzZSB4XG5cblxuKCogR2V0IHRoZSBjb250ZW50IG9mIGEgY291bnRlciBmcm9tIGFuIGlucHV0IGJ1ZmZlci4gKilcbmxldCBnZXRfY291bnRlciBpYiBjb3VudGVyID1cbiAgbWF0Y2ggY291bnRlciB3aXRoXG4gIHwgTGluZV9jb3VudGVyIC0+IFNjYW5uaW5nLmxpbmVfY291bnQgaWJcbiAgfCBDaGFyX2NvdW50ZXIgLT4gU2Nhbm5pbmcuY2hhcl9jb3VudCBpYlxuICB8IFRva2VuX2NvdW50ZXIgLT4gU2Nhbm5pbmcudG9rZW5fY291bnQgaWJcblxuXG4oKiBDb21wdXRlIHRoZSB3aWR0aCBvZiBhIHBhZGRpbmcgb3B0aW9uIChzZWUgXCIlNDJ7XCIgYW5kIFwiJTEyMyhcIikuICopXG5sZXQgd2lkdGhfb2ZfcGFkX29wdCBwYWRfb3B0ID0gbWF0Y2ggcGFkX29wdCB3aXRoXG4gIHwgTm9uZSAtPiBtYXhfaW50XG4gIHwgU29tZSB3aWR0aCAtPiB3aWR0aFxuXG5cbmxldCBzdG9wcGVyX29mX2Zvcm1hdHRpbmdfbGl0IGZtdGluZyA9XG4gIGlmIGZtdGluZyA9IEVzY2FwZWRfcGVyY2VudCB0aGVuICclJywgXCJcIiBlbHNlXG4gICAgbGV0IHN0ciA9IHN0cmluZ19vZl9mb3JtYXR0aW5nX2xpdCBmbXRpbmcgaW5cbiAgICBsZXQgc3RwID0gc3RyLlsxXSBpblxuICAgIGxldCBzdWJfc3RyID0gU3RyaW5nLnN1YiBzdHIgMiAoU3RyaW5nLmxlbmd0aCBzdHIgLSAyKSBpblxuICAgIHN0cCwgc3ViX3N0clxuXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBSZWFkZXIgbWFuYWdlbWVudCAqKVxuXG4oKiBBIGNhbGwgdG8gdGFrZV9mb3JtYXRfcmVhZGVycyBvbiBhIGZvcm1hdCBpcyBldmFsdWF0ZWQgaW50byBmdW5jdGlvbnNcbiAgIHRha2luZyByZWFkZXJzIGFzIGFyZ3VtZW50cyBhbmQgYWdncmVnYXRlIHRoZW0gaW50byBhbiBoZXRlcm9nZW5lb3VzIGxpc3QgKilcbigqIFdoZW4gYWxsIHJlYWRlcnMgYXJlIHRha2VuLCBmaW5hbGx5IHBhc3MgdGhlIGxpc3Qgb2YgdGhlIHJlYWRlcnMgdG8gdGhlXG4gICBjb250aW51YXRpb24gay4gKilcbmxldCByZWMgdGFrZV9mb3JtYXRfcmVhZGVycyA6IHR5cGUgYSBjIGQgZSBmIC5cbiAgICAoKGQsIGUpIGhldGVyX2xpc3QgLT4gZSkgLT4gKGEsIFNjYW5uaW5nLmluX2NoYW5uZWwsIGMsIGQsIGUsIGYpIGZtdCAtPlxuICAgIGQgPVxuZnVuIGsgZm10IC0+IG1hdGNoIGZtdCB3aXRoXG4gIHwgUmVhZGVyIGZtdF9yZXN0IC0+XG4gICAgZnVuIHJlYWRlciAtPlxuICAgICAgbGV0IG5ld19rIHJlYWRlcnNfcmVzdCA9IGsgKENvbnMgKHJlYWRlciwgcmVhZGVyc19yZXN0KSkgaW5cbiAgICAgIHRha2VfZm9ybWF0X3JlYWRlcnMgbmV3X2sgZm10X3Jlc3RcbiAgfCBDaGFyIHJlc3QgICAgICAgICAgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IENhbWxfY2hhciByZXN0ICAgICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgU3RyaW5nIChfLCByZXN0KSAgICAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBDYW1sX3N0cmluZyAoXywgcmVzdCkgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IEludCAoXywgXywgXywgcmVzdCkgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgSW50MzIgKF8sIF8sIF8sIHJlc3QpICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBOYXRpdmVpbnQgKF8sIF8sIF8sIHJlc3QpICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IEludDY0IChfLCBfLCBfLCByZXN0KSAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgRmxvYXQgKF8sIF8sIF8sIHJlc3QpICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBCb29sIChfLCByZXN0KSAgICAgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IEFscGhhIHJlc3QgICAgICAgICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgVGhldGEgcmVzdCAgICAgICAgICAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBGbHVzaCByZXN0ICAgICAgICAgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IFN0cmluZ19saXRlcmFsIChfLCByZXN0KSAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgQ2hhcl9saXRlcmFsIChfLCByZXN0KSAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBDdXN0b20gKF8sIF8sIHJlc3QpICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuXG4gIHwgU2Nhbl9jaGFyX3NldCAoXywgXywgcmVzdCkgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBTY2FuX2dldF9jb3VudGVyIChfLCByZXN0KSAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IFNjYW5fbmV4dF9jaGFyIHJlc3QgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG5cbiAgfCBGb3JtYXR0aW5nX2xpdCAoXywgcmVzdCkgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IEZvcm1hdHRpbmdfZ2VuIChPcGVuX3RhZyAoRm9ybWF0IChmbXQsIF8pKSwgcmVzdCkgLT5cbiAgICAgIHRha2VfZm9ybWF0X3JlYWRlcnMgayAoY29uY2F0X2ZtdCBmbXQgcmVzdClcbiAgfCBGb3JtYXR0aW5nX2dlbiAoT3Blbl9ib3ggKEZvcm1hdCAoZm10LCBfKSksIHJlc3QpIC0+XG4gICAgICB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgKGNvbmNhdF9mbXQgZm10IHJlc3QpXG5cbiAgfCBGb3JtYXRfYXJnIChfLCBfLCByZXN0KSAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IEZvcm1hdF9zdWJzdCAoXywgZm10dHksIHJlc3QpICAgIC0+XG4gICAgIHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayAoZXJhc2VfcmVsIChzeW1tIGZtdHR5KSkgcmVzdFxuICB8IElnbm9yZWRfcGFyYW0gKGlnbiwgcmVzdCkgICAgICAgIC0+IHRha2VfaWdub3JlZF9mb3JtYXRfcmVhZGVycyBrIGlnbiByZXN0XG5cbiAgfCBFbmRfb2ZfZm9ybWF0ICAgICAgICAgICAgICAgICAgICAtPiBrIE5pbFxuXG4oKiBUYWtlIHJlYWRlcnMgYXNzb2NpYXRlZCB0byBhbiBmbXR0eSBjb21pbmcgZnJvbSBhIEZvcm1hdF9zdWJzdCBcIiUoLi4uJSlcIi4gKilcbmFuZCB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIDogdHlwZSB4IHkgYSBjIGQgZSBmIC5cbiAgICAoKGQsIGUpIGhldGVyX2xpc3QgLT4gZSkgLT4gKGEsIFNjYW5uaW5nLmluX2NoYW5uZWwsIGMsIGQsIHgsIHkpIGZtdHR5IC0+XG4gICAgICAoeSwgU2Nhbm5pbmcuaW5fY2hhbm5lbCwgYywgeCwgZSwgZikgZm10IC0+IGQgPVxuZnVuIGsgZm10dHkgZm10IC0+IG1hdGNoIGZtdHR5IHdpdGhcbiAgfCBSZWFkZXJfdHkgZm10X3Jlc3QgLT5cbiAgICBmdW4gcmVhZGVyIC0+XG4gICAgICBsZXQgbmV3X2sgcmVhZGVyc19yZXN0ID0gayAoQ29ucyAocmVhZGVyLCByZWFkZXJzX3Jlc3QpKSBpblxuICAgICAgdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBuZXdfayBmbXRfcmVzdCBmbXRcbiAgfCBJZ25vcmVkX3JlYWRlcl90eSBmbXRfcmVzdCAtPlxuICAgIGZ1biByZWFkZXIgLT5cbiAgICAgIGxldCBuZXdfayByZWFkZXJzX3Jlc3QgPSBrIChDb25zIChyZWFkZXIsIHJlYWRlcnNfcmVzdCkpIGluXG4gICAgICB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIG5ld19rIGZtdF9yZXN0IGZtdFxuICB8IENoYXJfdHkgcmVzdCAgICAgICAgICAgICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBTdHJpbmdfdHkgcmVzdCAgICAgICAgICAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgSW50X3R5IHJlc3QgICAgICAgICAgICAgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IEludDMyX3R5IHJlc3QgICAgICAgICAgICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBOYXRpdmVpbnRfdHkgcmVzdCAgICAgICAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgSW50NjRfdHkgcmVzdCAgICAgICAgICAgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IEZsb2F0X3R5IHJlc3QgICAgICAgICAgICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBCb29sX3R5IHJlc3QgICAgICAgICAgICAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgQWxwaGFfdHkgcmVzdCAgICAgICAgICAgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IFRoZXRhX3R5IHJlc3QgICAgICAgICAgICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBBbnlfdHkgcmVzdCAgICAgICAgICAgICAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgRm9ybWF0X2FyZ190eSAoXywgcmVzdCkgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IEVuZF9vZl9mbXR0eSAgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgRm9ybWF0X3N1YnN0X3R5ICh0eTEsIHR5MiwgcmVzdCkgLT5cbiAgICBsZXQgdHkgPSB0cmFucyAoc3ltbSB0eTEpIHR5MiBpblxuICAgIHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayAoY29uY2F0X2ZtdHR5IHR5IHJlc3QpIGZtdFxuXG4oKiBUYWtlIHJlYWRlcnMgYXNzb2NpYXRlZCB0byBhbiBpZ25vcmVkIHBhcmFtZXRlci4gKilcbmFuZCB0YWtlX2lnbm9yZWRfZm9ybWF0X3JlYWRlcnMgOiB0eXBlIHggeSBhIGMgZCBlIGYgLlxuICAgICgoZCwgZSkgaGV0ZXJfbGlzdCAtPiBlKSAtPiAoYSwgU2Nhbm5pbmcuaW5fY2hhbm5lbCwgYywgZCwgeCwgeSkgaWdub3JlZCAtPlxuICAgICAgKHksIFNjYW5uaW5nLmluX2NoYW5uZWwsIGMsIHgsIGUsIGYpIGZtdCAtPiBkID1cbmZ1biBrIGlnbiBmbXQgLT4gbWF0Y2ggaWduIHdpdGhcbiAgfCBJZ25vcmVkX3JlYWRlciAtPlxuICAgIGZ1biByZWFkZXIgLT5cbiAgICAgIGxldCBuZXdfayByZWFkZXJzX3Jlc3QgPSBrIChDb25zIChyZWFkZXIsIHJlYWRlcnNfcmVzdCkpIGluXG4gICAgICB0YWtlX2Zvcm1hdF9yZWFkZXJzIG5ld19rIGZtdFxuICB8IElnbm9yZWRfY2hhciAgICAgICAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIGZtdFxuICB8IElnbm9yZWRfY2FtbF9jaGFyICAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIGZtdFxuICB8IElnbm9yZWRfc3RyaW5nIF8gICAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIGZtdFxuICB8IElnbm9yZWRfY2FtbF9zdHJpbmcgXyAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIGZtdFxuICB8IElnbm9yZWRfaW50IChfLCBfKSAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIGZtdFxuICB8IElnbm9yZWRfaW50MzIgKF8sIF8pICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIGZtdFxuICB8IElnbm9yZWRfbmF0aXZlaW50IChfLCBfKSAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIGZtdFxuICB8IElnbm9yZWRfaW50NjQgKF8sIF8pICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIGZtdFxuICB8IElnbm9yZWRfZmxvYXQgKF8sIF8pICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIGZtdFxuICB8IElnbm9yZWRfYm9vbCBfICAgICAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIGZtdFxuICB8IElnbm9yZWRfZm9ybWF0X2FyZyBfICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIGZtdFxuICB8IElnbm9yZWRfZm9ybWF0X3N1YnN0IChfLCBmbXR0eSkgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIGZtdHR5IGZtdFxuICB8IElnbm9yZWRfc2Nhbl9jaGFyX3NldCBfICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIGZtdFxuICB8IElnbm9yZWRfc2Nhbl9nZXRfY291bnRlciBfICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIGZtdFxuICB8IElnbm9yZWRfc2Nhbl9uZXh0X2NoYXIgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIGZtdFxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBHZW5lcmljIHNjYW5uaW5nICopXG5cbigqIE1ha2UgYSBnZW5lcmljIHNjYW5uaW5nIGZ1bmN0aW9uLiAqKVxuKCogU2NhbiBhIHN0cmVhbSBhY2NvcmRpbmcgdG8gYSBmb3JtYXQgYW5kIHJlYWRlcnMgb2J0YWluZWQgYnlcbiAgIHRha2VfZm9ybWF0X3JlYWRlcnMsIGFuZCBhZ2dyZWdhdGUgc2Nhbm5lZCB2YWx1ZXMgaW50byBhblxuICAgaGV0ZXJvZ2VuZW91cyBsaXN0LiAqKVxuKCogUmV0dXJuIHRoZSBoZXRlcm9nZW5lb3VzIGxpc3Qgb2Ygc2Nhbm5lZCB2YWx1ZXMuICopXG5sZXQgcmVjIG1ha2Vfc2NhbmYgOiB0eXBlIGEgYyBkIGUgZi5cbiAgICBTY2FubmluZy5pbl9jaGFubmVsIC0+IChhLCBTY2FubmluZy5pbl9jaGFubmVsLCBjLCBkLCBlLCBmKSBmbXQgLT5cbiAgICAgIChkLCBlKSBoZXRlcl9saXN0IC0+IChhLCBmKSBoZXRlcl9saXN0ID1cbmZ1biBpYiBmbXQgcmVhZGVycyAtPiBtYXRjaCBmbXQgd2l0aFxuICB8IENoYXIgcmVzdCAtPlxuICAgIGxldCBfID0gc2Nhbl9jaGFyIDAgaWIgaW5cbiAgICBsZXQgYyA9IHRva2VuX2NoYXIgaWIgaW5cbiAgICBDb25zIChjLCBtYWtlX3NjYW5mIGliIHJlc3QgcmVhZGVycylcbiAgfCBDYW1sX2NoYXIgcmVzdCAtPlxuICAgIGxldCBfID0gc2Nhbl9jYW1sX2NoYXIgMCBpYiBpblxuICAgIGxldCBjID0gdG9rZW5fY2hhciBpYiBpblxuICAgIENvbnMgKGMsIG1ha2Vfc2NhbmYgaWIgcmVzdCByZWFkZXJzKVxuXG4gIHwgU3RyaW5nIChwYWQsIEZvcm1hdHRpbmdfbGl0IChmbXRpbmdfbGl0LCByZXN0KSkgLT5cbiAgICBsZXQgc3RwLCBzdHIgPSBzdG9wcGVyX29mX2Zvcm1hdHRpbmdfbGl0IGZtdGluZ19saXQgaW5cbiAgICBsZXQgc2NhbiB3aWR0aCBfIGliID0gc2Nhbl9zdHJpbmcgKFNvbWUgc3RwKSB3aWR0aCBpYiBpblxuICAgIGxldCBzdHJfcmVzdCA9IFN0cmluZ19saXRlcmFsIChzdHIsIHJlc3QpIGluXG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgc3RyX3Jlc3QgcmVhZGVycyBwYWQgTm9fcHJlY2lzaW9uIHNjYW4gdG9rZW5fc3RyaW5nXG4gIHwgU3RyaW5nIChwYWQsIEZvcm1hdHRpbmdfZ2VuIChPcGVuX3RhZyAoRm9ybWF0IChmbXQnLCBfKSksIHJlc3QpKSAtPlxuICAgIGxldCBzY2FuIHdpZHRoIF8gaWIgPSBzY2FuX3N0cmluZyAoU29tZSAneycpIHdpZHRoIGliIGluXG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgKGNvbmNhdF9mbXQgZm10JyByZXN0KSByZWFkZXJzIHBhZCBOb19wcmVjaXNpb24gc2NhblxuICAgICAgICAgICAgICAgICAgIHRva2VuX3N0cmluZ1xuICB8IFN0cmluZyAocGFkLCBGb3JtYXR0aW5nX2dlbiAoT3Blbl9ib3ggKEZvcm1hdCAoZm10JywgXykpLCByZXN0KSkgLT5cbiAgICBsZXQgc2NhbiB3aWR0aCBfIGliID0gc2Nhbl9zdHJpbmcgKFNvbWUgJ1snKSB3aWR0aCBpYiBpblxuICAgIHBhZF9wcmVjX3NjYW5mIGliIChjb25jYXRfZm10IGZtdCcgcmVzdCkgcmVhZGVycyBwYWQgTm9fcHJlY2lzaW9uIHNjYW5cbiAgICAgICAgICAgICAgICAgICB0b2tlbl9zdHJpbmdcbiAgfCBTdHJpbmcgKHBhZCwgcmVzdCkgLT5cbiAgICBsZXQgc2NhbiB3aWR0aCBfIGliID0gc2Nhbl9zdHJpbmcgTm9uZSB3aWR0aCBpYiBpblxuICAgIHBhZF9wcmVjX3NjYW5mIGliIHJlc3QgcmVhZGVycyBwYWQgTm9fcHJlY2lzaW9uIHNjYW4gdG9rZW5fc3RyaW5nXG5cbiAgfCBDYW1sX3N0cmluZyAocGFkLCByZXN0KSAtPlxuICAgIGxldCBzY2FuIHdpZHRoIF8gaWIgPSBzY2FuX2NhbWxfc3RyaW5nIHdpZHRoIGliIGluXG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgcmVzdCByZWFkZXJzIHBhZCBOb19wcmVjaXNpb24gc2NhbiB0b2tlbl9zdHJpbmdcbiAgfCBJbnQgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbGV0IGMgPSBpbnRlZ2VyX2NvbnZlcnNpb25fb2ZfY2hhciAoY2hhcl9vZl9pY29udiBpY29udikgaW5cbiAgICBsZXQgc2NhbiB3aWR0aCBfIGliID0gc2Nhbl9pbnRfY29udmVyc2lvbiBjIHdpZHRoIGliIGluXG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgcmVzdCByZWFkZXJzIHBhZCBwcmVjIHNjYW4gKHRva2VuX2ludCBjKVxuICB8IEludDMyIChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIGxldCBjID0gaW50ZWdlcl9jb252ZXJzaW9uX29mX2NoYXIgKGNoYXJfb2ZfaWNvbnYgaWNvbnYpIGluXG4gICAgbGV0IHNjYW4gd2lkdGggXyBpYiA9IHNjYW5faW50X2NvbnZlcnNpb24gYyB3aWR0aCBpYiBpblxuICAgIHBhZF9wcmVjX3NjYW5mIGliIHJlc3QgcmVhZGVycyBwYWQgcHJlYyBzY2FuICh0b2tlbl9pbnQzMiBjKVxuICB8IE5hdGl2ZWludCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBsZXQgYyA9IGludGVnZXJfY29udmVyc2lvbl9vZl9jaGFyIChjaGFyX29mX2ljb252IGljb252KSBpblxuICAgIGxldCBzY2FuIHdpZHRoIF8gaWIgPSBzY2FuX2ludF9jb252ZXJzaW9uIGMgd2lkdGggaWIgaW5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiByZXN0IHJlYWRlcnMgcGFkIHByZWMgc2NhbiAodG9rZW5fbmF0aXZlaW50IGMpXG4gIHwgSW50NjQgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbGV0IGMgPSBpbnRlZ2VyX2NvbnZlcnNpb25fb2ZfY2hhciAoY2hhcl9vZl9pY29udiBpY29udikgaW5cbiAgICBsZXQgc2NhbiB3aWR0aCBfIGliID0gc2Nhbl9pbnRfY29udmVyc2lvbiBjIHdpZHRoIGliIGluXG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgcmVzdCByZWFkZXJzIHBhZCBwcmVjIHNjYW4gKHRva2VuX2ludDY0IGMpXG4gIHwgRmxvYXQgKChfLCAoRmxvYXRfRiB8IEZsb2F0X0NGKSksIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiByZXN0IHJlYWRlcnMgcGFkIHByZWMgc2Nhbl9jYW1sX2Zsb2F0IHRva2VuX2Zsb2F0XG4gIHwgRmxvYXQgKChfLCAoRmxvYXRfZiB8IEZsb2F0X2UgfCBGbG9hdF9FIHwgRmxvYXRfZyB8IEZsb2F0X0cpKSxcbiAgICAgICAgICAgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIHBhZF9wcmVjX3NjYW5mIGliIHJlc3QgcmVhZGVycyBwYWQgcHJlYyBzY2FuX2Zsb2F0IHRva2VuX2Zsb2F0XG4gIHwgRmxvYXQgKChfLCAoRmxvYXRfaCB8IEZsb2F0X0gpKSwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIHBhZF9wcmVjX3NjYW5mIGliIHJlc3QgcmVhZGVycyBwYWQgcHJlYyBzY2FuX2hleF9mbG9hdCB0b2tlbl9mbG9hdFxuICB8IEJvb2wgKHBhZCwgcmVzdCkgLT5cbiAgICBsZXQgc2NhbiBfIF8gaWIgPSBzY2FuX2Jvb2wgaWIgaW5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiByZXN0IHJlYWRlcnMgcGFkIE5vX3ByZWNpc2lvbiBzY2FuIHRva2VuX2Jvb2xcbiAgfCBBbHBoYSBfIC0+XG4gICAgaW52YWxpZF9hcmcgXCJzY2FuZjogYmFkIGNvbnZlcnNpb24gXFxcIiVhXFxcIlwiXG4gIHwgVGhldGEgXyAtPlxuICAgIGludmFsaWRfYXJnIFwic2NhbmY6IGJhZCBjb252ZXJzaW9uIFxcXCIldFxcXCJcIlxuICB8IEN1c3RvbSBfIC0+XG4gICAgaW52YWxpZF9hcmcgXCJzY2FuZjogYmFkIGNvbnZlcnNpb24gXFxcIiU/XFxcIiAoY3VzdG9tIGNvbnZlcnRlcilcIlxuICB8IFJlYWRlciBmbXRfcmVzdCAtPlxuICAgIGJlZ2luIG1hdGNoIHJlYWRlcnMgd2l0aFxuICAgIHwgQ29ucyAocmVhZGVyLCByZWFkZXJzX3Jlc3QpIC0+XG4gICAgICAgIGxldCB4ID0gcmVhZGVyIGliIGluXG4gICAgICAgIENvbnMgKHgsIG1ha2Vfc2NhbmYgaWIgZm10X3Jlc3QgcmVhZGVyc19yZXN0KVxuICAgIHwgTmlsIC0+XG4gICAgICAgIGludmFsaWRfYXJnIFwic2NhbmY6IG1pc3NpbmcgcmVhZGVyXCJcbiAgICBlbmRcbiAgfCBGbHVzaCByZXN0IC0+XG4gICAgaWYgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gbWFrZV9zY2FuZiBpYiByZXN0IHJlYWRlcnNcbiAgICBlbHNlIGJhZF9pbnB1dCBcImVuZCBvZiBpbnB1dCBub3QgZm91bmRcIlxuXG4gIHwgU3RyaW5nX2xpdGVyYWwgKHN0ciwgcmVzdCkgLT5cbiAgICBTdHJpbmcuaXRlciAoY2hlY2tfY2hhciBpYikgc3RyO1xuICAgIG1ha2Vfc2NhbmYgaWIgcmVzdCByZWFkZXJzXG4gIHwgQ2hhcl9saXRlcmFsIChjaHIsIHJlc3QpIC0+XG4gICAgY2hlY2tfY2hhciBpYiBjaHI7XG4gICAgbWFrZV9zY2FuZiBpYiByZXN0IHJlYWRlcnNcblxuICB8IEZvcm1hdF9hcmcgKHBhZF9vcHQsIGZtdHR5LCByZXN0KSAtPlxuICAgIGxldCBfID0gc2Nhbl9jYW1sX3N0cmluZyAod2lkdGhfb2ZfcGFkX29wdCBwYWRfb3B0KSBpYiBpblxuICAgIGxldCBzID0gdG9rZW5fc3RyaW5nIGliIGluXG4gICAgbGV0IGZtdCA9XG4gICAgICB0cnkgZm9ybWF0X29mX3N0cmluZ19mbXR0eSBzIGZtdHR5XG4gICAgICB3aXRoIEZhaWx1cmUgbXNnIC0+IGJhZF9pbnB1dCBtc2dcbiAgICBpblxuICAgIENvbnMgKGZtdCwgbWFrZV9zY2FuZiBpYiByZXN0IHJlYWRlcnMpXG4gIHwgRm9ybWF0X3N1YnN0IChwYWRfb3B0LCBmbXR0eSwgcmVzdCkgLT5cbiAgICBsZXQgXyA9IHNjYW5fY2FtbF9zdHJpbmcgKHdpZHRoX29mX3BhZF9vcHQgcGFkX29wdCkgaWIgaW5cbiAgICBsZXQgcyA9IHRva2VuX3N0cmluZyBpYiBpblxuICAgIGxldCBmbXQsIGZtdCcgPVxuICAgICAgdHJ5XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdCA9IGZtdF9lYmJfb2Zfc3RyaW5nIHMgaW5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10JyA9IGZtdF9lYmJfb2Zfc3RyaW5nIHMgaW5cbiAgICAgICAgKCogVE9ETzogZmluZCBhIHdheSB0byBhdm9pZCByZXBhcnNpbmcgdHdpY2UgKilcblxuICAgICAgICAoKiBUT0RPOiB0aGVzZSB0eXBlLWNoZWNrcyBiZWxvdyAqY2FuKiBmYWlsIGJlY2F1c2Ugb2YgdHlwZVxuICAgICAgICAgICBhbWJpZ3VpdHkgaW4gcHJlc2VuY2Ugb2YgaWdub3JlZC1yZWFkZXJzOiBcIiVfciVkXCIgYW5kIFwiJWQlX3JcIlxuICAgICAgICAgICBhcmUgdHlwZWQgaW4gdGhlIHNhbWUgd2F5LlxuXG4gICAgICAgICAgICMgU2NhbmYuc3NjYW5mIFwiXFxcIiVfciVkXFxcIjNcIiBcIiUoJWQlX3IlKVwiIGlnbm9yZVxuICAgICAgICAgICAgIChmdW4gZm10IG4gLT4gc3RyaW5nX29mX2Zvcm1hdCBmbXQsIG4pXG4gICAgICAgICAgIEV4Y2VwdGlvbjogQ2FtbGludGVybmFsRm9ybWF0LlR5cGVfbWlzbWF0Y2guXG5cbiAgICAgICAgICAgV2Ugc2hvdWxkIHByb3Blcmx5IGNhdGNoIHRoaXMgZXhjZXB0aW9uLlxuICAgICAgICAqKVxuICAgICAgICB0eXBlX2Zvcm1hdCBmbXQgKGVyYXNlX3JlbCBmbXR0eSksXG4gICAgICAgIHR5cGVfZm9ybWF0IGZtdCcgKGVyYXNlX3JlbCAoc3ltbSBmbXR0eSkpXG4gICAgICB3aXRoIEZhaWx1cmUgbXNnIC0+IGJhZF9pbnB1dCBtc2dcbiAgICBpblxuICAgIENvbnMgKEZvcm1hdCAoZm10LCBzKSxcbiAgICAgICAgICBtYWtlX3NjYW5mIGliIChjb25jYXRfZm10IGZtdCcgcmVzdCkgcmVhZGVycylcblxuICB8IFNjYW5fY2hhcl9zZXQgKHdpZHRoX29wdCwgY2hhcl9zZXQsIEZvcm1hdHRpbmdfbGl0IChmbXRpbmdfbGl0LCByZXN0KSkgLT5cbiAgICBsZXQgc3RwLCBzdHIgPSBzdG9wcGVyX29mX2Zvcm1hdHRpbmdfbGl0IGZtdGluZ19saXQgaW5cbiAgICBsZXQgd2lkdGggPSB3aWR0aF9vZl9wYWRfb3B0IHdpZHRoX29wdCBpblxuICAgIHNjYW5fY2hhcnNfaW5fY2hhcl9zZXQgY2hhcl9zZXQgKFNvbWUgc3RwKSB3aWR0aCBpYjtcbiAgICBsZXQgcyA9IHRva2VuX3N0cmluZyBpYiBpblxuICAgIGxldCBzdHJfcmVzdCA9IFN0cmluZ19saXRlcmFsIChzdHIsIHJlc3QpIGluXG4gICAgQ29ucyAocywgbWFrZV9zY2FuZiBpYiBzdHJfcmVzdCByZWFkZXJzKVxuICB8IFNjYW5fY2hhcl9zZXQgKHdpZHRoX29wdCwgY2hhcl9zZXQsIHJlc3QpIC0+XG4gICAgbGV0IHdpZHRoID0gd2lkdGhfb2ZfcGFkX29wdCB3aWR0aF9vcHQgaW5cbiAgICBzY2FuX2NoYXJzX2luX2NoYXJfc2V0IGNoYXJfc2V0IE5vbmUgd2lkdGggaWI7XG4gICAgbGV0IHMgPSB0b2tlbl9zdHJpbmcgaWIgaW5cbiAgICBDb25zIChzLCBtYWtlX3NjYW5mIGliIHJlc3QgcmVhZGVycylcbiAgfCBTY2FuX2dldF9jb3VudGVyIChjb3VudGVyLCByZXN0KSAtPlxuICAgIGxldCBjb3VudCA9IGdldF9jb3VudGVyIGliIGNvdW50ZXIgaW5cbiAgICBDb25zIChjb3VudCwgbWFrZV9zY2FuZiBpYiByZXN0IHJlYWRlcnMpXG4gIHwgU2Nhbl9uZXh0X2NoYXIgcmVzdCAtPlxuICAgIGxldCBjID0gU2Nhbm5pbmcuY2hlY2tlZF9wZWVrX2NoYXIgaWIgaW5cbiAgICBDb25zIChjLCBtYWtlX3NjYW5mIGliIHJlc3QgcmVhZGVycylcblxuICB8IEZvcm1hdHRpbmdfbGl0IChmb3JtYXR0aW5nX2xpdCwgcmVzdCkgLT5cbiAgICBTdHJpbmcuaXRlciAoY2hlY2tfY2hhciBpYikgKHN0cmluZ19vZl9mb3JtYXR0aW5nX2xpdCBmb3JtYXR0aW5nX2xpdCk7XG4gICAgbWFrZV9zY2FuZiBpYiByZXN0IHJlYWRlcnNcbiAgfCBGb3JtYXR0aW5nX2dlbiAoT3Blbl90YWcgKEZvcm1hdCAoZm10JywgXykpLCByZXN0KSAtPlxuICAgIGNoZWNrX2NoYXIgaWIgJ0AnOyBjaGVja19jaGFyIGliICd7JztcbiAgICBtYWtlX3NjYW5mIGliIChjb25jYXRfZm10IGZtdCcgcmVzdCkgcmVhZGVyc1xuICB8IEZvcm1hdHRpbmdfZ2VuIChPcGVuX2JveCAoRm9ybWF0IChmbXQnLCBfKSksIHJlc3QpIC0+XG4gICAgY2hlY2tfY2hhciBpYiAnQCc7IGNoZWNrX2NoYXIgaWIgJ1snO1xuICAgIG1ha2Vfc2NhbmYgaWIgKGNvbmNhdF9mbXQgZm10JyByZXN0KSByZWFkZXJzXG5cbiAgfCBJZ25vcmVkX3BhcmFtIChpZ24sIHJlc3QpIC0+XG4gICAgbGV0IFBhcmFtX2Zvcm1hdF9FQkIgZm10JyA9IHBhcmFtX2Zvcm1hdF9vZl9pZ25vcmVkX2Zvcm1hdCBpZ24gcmVzdCBpblxuICAgIGJlZ2luIG1hdGNoIG1ha2Vfc2NhbmYgaWIgZm10JyByZWFkZXJzIHdpdGhcbiAgICB8IENvbnMgKF8sIGFyZ19yZXN0KSAtPiBhcmdfcmVzdFxuICAgIHwgTmlsIC0+IGFzc2VydCBmYWxzZVxuICAgIGVuZFxuXG4gIHwgRW5kX29mX2Zvcm1hdCAtPlxuICAgIE5pbFxuXG4oKiBDYXNlIGFuYWx5c2lzIG9uIHBhZGRpbmcgYW5kIHByZWNpc2lvbi4gKilcbigqIFJlamVjdCBmb3JtYXRzIGNvbnRhaW5pbmcgXCIlKlwiIG9yIFwiJS4qXCIuICopXG4oKiBQYXNzIHBhZGRpbmcgYW5kIHByZWNpc2lvbiB0byB0aGUgZ2VuZXJpYyBzY2FubmVyIGBzY2FuJy4gKilcbmFuZCBwYWRfcHJlY19zY2FuZiA6IHR5cGUgYSBjIGQgZSBmIHggeSB6IHQgLlxuICAgIFNjYW5uaW5nLmluX2NoYW5uZWwgLT4gKGEsIFNjYW5uaW5nLmluX2NoYW5uZWwsIGMsIGQsIGUsIGYpIGZtdCAtPlxuICAgICAgKGQsIGUpIGhldGVyX2xpc3QgLT4gKHgsIHkpIHBhZGRpbmcgLT4gKHksIHogLT4gYSkgcHJlY2lzaW9uIC0+XG4gICAgICAoaW50IC0+IGludCAtPiBTY2FubmluZy5pbl9jaGFubmVsIC0+IHQpIC0+XG4gICAgICAoU2Nhbm5pbmcuaW5fY2hhbm5lbCAtPiB6KSAtPlxuICAgICAgKHgsIGYpIGhldGVyX2xpc3QgPVxuZnVuIGliIGZtdCByZWFkZXJzIHBhZCBwcmVjIHNjYW4gdG9rZW4gLT4gbWF0Y2ggcGFkLCBwcmVjIHdpdGhcbiAgfCBOb19wYWRkaW5nLCBOb19wcmVjaXNpb24gLT5cbiAgICBsZXQgXyA9IHNjYW4gbWF4X2ludCBtYXhfaW50IGliIGluXG4gICAgbGV0IHggPSB0b2tlbiBpYiBpblxuICAgIENvbnMgKHgsIG1ha2Vfc2NhbmYgaWIgZm10IHJlYWRlcnMpXG4gIHwgTm9fcGFkZGluZywgTGl0X3ByZWNpc2lvbiBwIC0+XG4gICAgbGV0IF8gPSBzY2FuIG1heF9pbnQgcCBpYiBpblxuICAgIGxldCB4ID0gdG9rZW4gaWIgaW5cbiAgICBDb25zICh4LCBtYWtlX3NjYW5mIGliIGZtdCByZWFkZXJzKVxuICB8IExpdF9wYWRkaW5nICgoUmlnaHQgfCBaZXJvcyksIHcpLCBOb19wcmVjaXNpb24gLT5cbiAgICBsZXQgXyA9IHNjYW4gdyBtYXhfaW50IGliIGluXG4gICAgbGV0IHggPSB0b2tlbiBpYiBpblxuICAgIENvbnMgKHgsIG1ha2Vfc2NhbmYgaWIgZm10IHJlYWRlcnMpXG4gIHwgTGl0X3BhZGRpbmcgKChSaWdodCB8IFplcm9zKSwgdyksIExpdF9wcmVjaXNpb24gcCAtPlxuICAgIGxldCBfID0gc2NhbiB3IHAgaWIgaW5cbiAgICBsZXQgeCA9IHRva2VuIGliIGluXG4gICAgQ29ucyAoeCwgbWFrZV9zY2FuZiBpYiBmbXQgcmVhZGVycylcbiAgfCBMaXRfcGFkZGluZyAoTGVmdCwgXyksIF8gLT5cbiAgICBpbnZhbGlkX2FyZyBcInNjYW5mOiBiYWQgY29udmVyc2lvbiBcXFwiJS1cXFwiXCJcbiAgfCBMaXRfcGFkZGluZyAoKFJpZ2h0IHwgWmVyb3MpLCBfKSwgQXJnX3ByZWNpc2lvbiAtPlxuICAgIGludmFsaWRfYXJnIFwic2NhbmY6IGJhZCBjb252ZXJzaW9uIFxcXCIlKlxcXCJcIlxuICB8IEFyZ19wYWRkaW5nIF8sIF8gLT5cbiAgICBpbnZhbGlkX2FyZyBcInNjYW5mOiBiYWQgY29udmVyc2lvbiBcXFwiJSpcXFwiXCJcbiAgfCBOb19wYWRkaW5nLCBBcmdfcHJlY2lzaW9uIC0+XG4gICAgaW52YWxpZF9hcmcgXCJzY2FuZjogYmFkIGNvbnZlcnNpb24gXFxcIiUqXFxcIlwiXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAoKiBEZWZpbmluZyBbc2NhbmZdIGFuZCB2YXJpb3VzIGZsYXZvcnMgb2YgW3NjYW5mXSAqKVxuXG50eXBlICdhIGtzY2FuZl9yZXN1bHQgPSBBcmdzIG9mICdhIHwgRXhjIG9mIGV4blxuXG5sZXQga3NjYW5mIGliIGVmIChGb3JtYXQgKGZtdCwgc3RyKSkgPVxuICBsZXQgcmVjIGFwcGx5IDogdHlwZSBhIGIgLiBhIC0+IChhLCBiKSBoZXRlcl9saXN0IC0+IGIgPVxuICAgIGZ1biBmIGFyZ3MgLT4gbWF0Y2ggYXJncyB3aXRoXG4gICAgfCBDb25zICh4LCByKSAtPiBhcHBseSAoZiB4KSByXG4gICAgfCBOaWwgLT4gZlxuICBpblxuICBsZXQgayByZWFkZXJzIGYgPVxuICAgIFNjYW5uaW5nLnJlc2V0X3Rva2VuIGliO1xuICAgIG1hdGNoIHRyeSBBcmdzIChtYWtlX3NjYW5mIGliIGZtdCByZWFkZXJzKSB3aXRoXG4gICAgICB8IChTY2FuX2ZhaWx1cmUgXyB8IEZhaWx1cmUgXyB8IEVuZF9vZl9maWxlKSBhcyBleGMgLT4gRXhjIGV4Y1xuICAgICAgfCBJbnZhbGlkX2FyZ3VtZW50IG1zZyAtPlxuICAgICAgICBpbnZhbGlkX2FyZyAobXNnIF4gXCIgaW4gZm9ybWF0IFxcXCJcIiBeIFN0cmluZy5lc2NhcGVkIHN0ciBeIFwiXFxcIlwiKVxuICAgIHdpdGhcbiAgICAgIHwgQXJncyBhcmdzIC0+IGFwcGx5IGYgYXJnc1xuICAgICAgfCBFeGMgZXhjIC0+IGVmIGliIGV4Y1xuICBpblxuICB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG5cbigqKiopXG5cbmxldCBrYnNjYW5mID0ga3NjYW5mXG5sZXQgYnNjYW5mIGliIGZtdCA9IGtic2NhbmYgaWIgc2NhbmZfYmFkX2lucHV0IGZtdFxuXG5sZXQga3NzY2FuZiBzIGVmIGZtdCA9IGtic2NhbmYgKFNjYW5uaW5nLmZyb21fc3RyaW5nIHMpIGVmIGZtdFxubGV0IHNzY2FuZiBzIGZtdCA9IGtic2NhbmYgKFNjYW5uaW5nLmZyb21fc3RyaW5nIHMpIHNjYW5mX2JhZF9pbnB1dCBmbXRcblxubGV0IHNjYW5mIGZtdCA9IGtzY2FuZiBTY2FubmluZy5zdGRpYiBzY2FuZl9iYWRfaW5wdXQgZm10XG5cbigqKiopXG5cbigqIFNjYW5uaW5nIGZvcm1hdCBzdHJpbmdzLiAqKVxubGV0IGJzY2FuZl9mb3JtYXQgOlxuICBTY2FubmluZy5pbl9jaGFubmVsIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2IC0+XG4gICgoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiAtPiAnZykgLT4gJ2cgPVxuICBmdW4gaWIgZm9ybWF0IGYgLT5cbiAgICBsZXQgXyA9IHNjYW5fY2FtbF9zdHJpbmcgbWF4X2ludCBpYiBpblxuICAgIGxldCBzdHIgPSB0b2tlbl9zdHJpbmcgaWIgaW5cbiAgICBsZXQgZm10JyA9XG4gICAgICB0cnkgZm9ybWF0X29mX3N0cmluZ19mb3JtYXQgc3RyIGZvcm1hdFxuICAgICAgd2l0aCBGYWlsdXJlIG1zZyAtPiBiYWRfaW5wdXQgbXNnIGluXG4gICAgZiBmbXQnXG5cblxubGV0IHNzY2FuZl9mb3JtYXQgOlxuICBzdHJpbmcgLT4gKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgLT5cbiAgKCgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2IC0+ICdnKSAtPiAnZyA9XG4gIGZ1biBzIGZvcm1hdCBmIC0+IGJzY2FuZl9mb3JtYXQgKFNjYW5uaW5nLmZyb21fc3RyaW5nIHMpIGZvcm1hdCBmXG5cblxubGV0IGZvcm1hdF9mcm9tX3N0cmluZyBzIGZtdCA9XG4gIHNzY2FuZl9mb3JtYXQgKFwiXFxcIlwiIF4gU3RyaW5nLmVzY2FwZWQgcyBeIFwiXFxcIlwiKSBmbXQgKGZ1biB4IC0+IHgpXG5cblxubGV0IHVuZXNjYXBlZCBzID1cbiAgc3NjYW5mIChcIlxcXCJcIiBeIHMgXiBcIlxcXCJcIikgXCIlUyUhXCIgKGZ1biB4IC0+IHgpXG5cblxuKCogRGVwcmVjYXRlZCAqKVxubGV0IGtmc2NhbmYgaWMgZWYgZm10ID0ga2JzY2FuZiAoU2Nhbm5pbmcubWVtb19mcm9tX2NoYW5uZWwgaWMpIGVmIGZtdFxubGV0IGZzY2FuZiBpYyBmbXQgPSBrc2NhbmYgKFNjYW5uaW5nLm1lbW9fZnJvbV9jaGFubmVsIGljKSBzY2FuZl9iYWRfaW5wdXQgZm10XG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIFJlZ2lzdGVyaW5nIE9DYW1sIHZhbHVlcyB3aXRoIHRoZSBDIHJ1bnRpbWUgZm9yIGxhdGVyIGNhbGxiYWNrcyAqKVxuXG5leHRlcm5hbCByZWdpc3Rlcl9uYW1lZF92YWx1ZSA6IHN0cmluZyAtPiBPYmoudCAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9yZWdpc3Rlcl9uYW1lZF92YWx1ZVwiXG5cbmxldCByZWdpc3RlciBuYW1lIHYgPVxuICByZWdpc3Rlcl9uYW1lZF92YWx1ZSBuYW1lIChPYmoucmVwciB2KVxuXG5sZXQgcmVnaXN0ZXJfZXhjZXB0aW9uIG5hbWUgKGV4biA6IGV4bikgPVxuICBsZXQgZXhuID0gT2JqLnJlcHIgZXhuIGluXG4gIGxldCBzbG90ID0gaWYgT2JqLnRhZyBleG4gPSBPYmoub2JqZWN0X3RhZyB0aGVuIGV4biBlbHNlIE9iai5maWVsZCBleG4gMCBpblxuICByZWdpc3Rlcl9uYW1lZF92YWx1ZSBuYW1lIHNsb3RcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgIEplcm9tZSBWb3VpbGxvbiwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMDIgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxub3BlbiBPYmpcblxuKCoqKiogT2JqZWN0IHJlcHJlc2VudGF0aW9uICoqKiopXG5cbmV4dGVybmFsIHNldF9pZDogJ2EgLT4gJ2EgPSBcImNhbWxfc2V0X29vX2lkXCIgW0BAbm9hbGxvY11cblxuKCoqKiogT2JqZWN0IGNvcHkgKioqKilcblxubGV0IGNvcHkgbyA9XG4gIGxldCBvID0gKE9iai5vYmogKE9iai5kdXAgKE9iai5yZXByIG8pKSkgaW5cbiAgc2V0X2lkIG9cblxuKCoqKiogQ29tcHJlc3Npb24gb3B0aW9ucyAqKioqKVxuKCogUGFyYW1ldGVycyAqKVxudHlwZSBwYXJhbXMgPSB7XG4gICAgbXV0YWJsZSBjb21wYWN0X3RhYmxlIDogYm9vbDtcbiAgICBtdXRhYmxlIGNvcHlfcGFyZW50IDogYm9vbDtcbiAgICBtdXRhYmxlIGNsZWFuX3doZW5fY29weWluZyA6IGJvb2w7XG4gICAgbXV0YWJsZSByZXRyeV9jb3VudCA6IGludDtcbiAgICBtdXRhYmxlIGJ1Y2tldF9zbWFsbF9zaXplIDogaW50XG4gIH1cblxubGV0IHBhcmFtcyA9IHtcbiAgY29tcGFjdF90YWJsZSA9IHRydWU7XG4gIGNvcHlfcGFyZW50ID0gdHJ1ZTtcbiAgY2xlYW5fd2hlbl9jb3B5aW5nID0gdHJ1ZTtcbiAgcmV0cnlfY291bnQgPSAzO1xuICBidWNrZXRfc21hbGxfc2l6ZSA9IDE2XG59XG5cbigqKioqIFBhcmFtZXRlcnMgKioqKilcblxubGV0IGluaXRpYWxfb2JqZWN0X3NpemUgPSAyXG5cbigqKioqIEl0ZW1zICoqKiopXG5cbnR5cGUgaXRlbSA9IER1bW15QSB8IER1bW15QiB8IER1bW15QyBvZiBpbnRcbmxldCBfID0gW0R1bW15QTsgRHVtbXlCOyBEdW1teUMgMF0gKCogdG8gYXZvaWQgd2FybmluZ3MgKilcblxubGV0IGR1bW15X2l0ZW0gPSAobWFnaWMgKCkgOiBpdGVtKVxuXG4oKioqKiBUeXBlcyAqKioqKVxuXG50eXBlIHRhZ1xudHlwZSBsYWJlbCA9IGludFxudHlwZSBjbG9zdXJlID0gaXRlbVxudHlwZSB0ID0gRHVtbXlBIHwgRHVtbXlCIHwgRHVtbXlDIG9mIGludFxubGV0IF8gPSBbRHVtbXlBOyBEdW1teUI7IER1bW15QyAwXSAoKiB0byBhdm9pZCB3YXJuaW5ncyAqKVxuXG50eXBlIG9iaiA9IHQgYXJyYXlcbmV4dGVybmFsIHJldCA6IChvYmogLT4gJ2EpIC0+IGNsb3N1cmUgPSBcIiVpZGVudGl0eVwiXG5cbigqKioqIExhYmVscyAqKioqKVxuXG5sZXQgcHVibGljX21ldGhvZF9sYWJlbCBzIDogdGFnID1cbiAgbGV0IGFjY3UgPSByZWYgMCBpblxuICBmb3IgaSA9IDAgdG8gU3RyaW5nLmxlbmd0aCBzIC0gMSBkb1xuICAgIGFjY3UgOj0gMjIzICogIWFjY3UgKyBDaGFyLmNvZGUgcy5baV1cbiAgZG9uZTtcbiAgKCogcmVkdWNlIHRvIDMxIGJpdHMgKilcbiAgYWNjdSA6PSAhYWNjdSBsYW5kICgxIGxzbCAzMSAtIDEpO1xuICAoKiBtYWtlIGl0IHNpZ25lZCBmb3IgNjQgYml0cyBhcmNoaXRlY3R1cmVzICopXG4gIGxldCB0YWcgPSBpZiAhYWNjdSA+IDB4M0ZGRkZGRkYgdGhlbiAhYWNjdSAtICgxIGxzbCAzMSkgZWxzZSAhYWNjdSBpblxuICAoKiBQcmludGYuZXByaW50ZiBcIiVzID0gJWRcXG5cIiBzIHRhZzsgZmx1c2ggc3RkZXJyOyAqKVxuICBtYWdpYyB0YWdcblxuKCoqKiogU3BhcnNlIGFycmF5ICoqKiopXG5cbm1vZHVsZSBWYXJzID1cbiAgTWFwLk1ha2Uoc3RydWN0IHR5cGUgdCA9IHN0cmluZyBsZXQgY29tcGFyZSAoeDp0KSB5ID0gY29tcGFyZSB4IHkgZW5kKVxudHlwZSB2YXJzID0gaW50IFZhcnMudFxuXG5tb2R1bGUgTWV0aHMgPVxuICBNYXAuTWFrZShzdHJ1Y3QgdHlwZSB0ID0gc3RyaW5nIGxldCBjb21wYXJlICh4OnQpIHkgPSBjb21wYXJlIHggeSBlbmQpXG50eXBlIG1ldGhzID0gbGFiZWwgTWV0aHMudFxubW9kdWxlIExhYnMgPVxuICBNYXAuTWFrZShzdHJ1Y3QgdHlwZSB0ID0gbGFiZWwgbGV0IGNvbXBhcmUgKHg6dCkgeSA9IGNvbXBhcmUgeCB5IGVuZClcbnR5cGUgbGFicyA9IGJvb2wgTGFicy50XG5cbigqIFRoZSBjb21waWxlciBhc3N1bWVzIHRoYXQgdGhlIGZpcnN0IGZpZWxkIG9mIHRoaXMgc3RydWN0dXJlIGlzIFtzaXplXS4gKilcbnR5cGUgdGFibGUgPVxuIHsgbXV0YWJsZSBzaXplOiBpbnQ7XG4gICBtdXRhYmxlIG1ldGhvZHM6IGNsb3N1cmUgYXJyYXk7XG4gICBtdXRhYmxlIG1ldGhvZHNfYnlfbmFtZTogbWV0aHM7XG4gICBtdXRhYmxlIG1ldGhvZHNfYnlfbGFiZWw6IGxhYnM7XG4gICBtdXRhYmxlIHByZXZpb3VzX3N0YXRlczpcbiAgICAgKG1ldGhzICogbGFicyAqIChsYWJlbCAqIGl0ZW0pIGxpc3QgKiB2YXJzICpcbiAgICAgIGxhYmVsIGxpc3QgKiBzdHJpbmcgbGlzdCkgbGlzdDtcbiAgIG11dGFibGUgaGlkZGVuX21ldGhzOiAobGFiZWwgKiBpdGVtKSBsaXN0O1xuICAgbXV0YWJsZSB2YXJzOiB2YXJzO1xuICAgbXV0YWJsZSBpbml0aWFsaXplcnM6IChvYmogLT4gdW5pdCkgbGlzdCB9XG5cbmxldCBkdW1teV90YWJsZSA9XG4gIHsgbWV0aG9kcyA9IFt8IGR1bW15X2l0ZW0gfF07XG4gICAgbWV0aG9kc19ieV9uYW1lID0gTWV0aHMuZW1wdHk7XG4gICAgbWV0aG9kc19ieV9sYWJlbCA9IExhYnMuZW1wdHk7XG4gICAgcHJldmlvdXNfc3RhdGVzID0gW107XG4gICAgaGlkZGVuX21ldGhzID0gW107XG4gICAgdmFycyA9IFZhcnMuZW1wdHk7XG4gICAgaW5pdGlhbGl6ZXJzID0gW107XG4gICAgc2l6ZSA9IDAgfVxuXG5sZXQgdGFibGVfY291bnQgPSByZWYgMFxuXG4oKiBkdW1teV9tZXQgc2hvdWxkIGJlIGEgcG9pbnRlciwgc28gdXNlIGFuIGF0b20gKilcbmxldCBkdW1teV9tZXQgOiBpdGVtID0gb2JqIChPYmoubmV3X2Jsb2NrIDAgMClcbigqIGlmIGRlYnVnZ2luZyBpcyBuZWVkZWQsIHRoaXMgY291bGQgYmUgYSBnb29kIGlkZWE6ICopXG4oKiBsZXQgZHVtbXlfbWV0ICgpID0gZmFpbHdpdGggXCJVbmRlZmluZWQgbWV0aG9kXCIgKilcblxubGV0IHJlYyBmaXRfc2l6ZSBuID1cbiAgaWYgbiA8PSAyIHRoZW4gbiBlbHNlXG4gIGZpdF9zaXplICgobisxKS8yKSAqIDJcblxubGV0IG5ld190YWJsZSBwdWJfbGFiZWxzID1cbiAgaW5jciB0YWJsZV9jb3VudDtcbiAgbGV0IGxlbiA9IEFycmF5Lmxlbmd0aCBwdWJfbGFiZWxzIGluXG4gIGxldCBtZXRob2RzID0gQXJyYXkubWFrZSAobGVuKjIrMikgZHVtbXlfbWV0IGluXG4gIG1ldGhvZHMuKDApIDwtIG1hZ2ljIGxlbjtcbiAgbWV0aG9kcy4oMSkgPC0gbWFnaWMgKGZpdF9zaXplIGxlbiAqIFN5cy53b3JkX3NpemUgLyA4IC0gMSk7XG4gIGZvciBpID0gMCB0byBsZW4gLSAxIGRvIG1ldGhvZHMuKGkqMiszKSA8LSBtYWdpYyBwdWJfbGFiZWxzLihpKSBkb25lO1xuICB7IG1ldGhvZHMgPSBtZXRob2RzO1xuICAgIG1ldGhvZHNfYnlfbmFtZSA9IE1ldGhzLmVtcHR5O1xuICAgIG1ldGhvZHNfYnlfbGFiZWwgPSBMYWJzLmVtcHR5O1xuICAgIHByZXZpb3VzX3N0YXRlcyA9IFtdO1xuICAgIGhpZGRlbl9tZXRocyA9IFtdO1xuICAgIHZhcnMgPSBWYXJzLmVtcHR5O1xuICAgIGluaXRpYWxpemVycyA9IFtdO1xuICAgIHNpemUgPSBpbml0aWFsX29iamVjdF9zaXplIH1cblxubGV0IHJlc2l6ZSBhcnJheSBuZXdfc2l6ZSA9XG4gIGxldCBvbGRfc2l6ZSA9IEFycmF5Lmxlbmd0aCBhcnJheS5tZXRob2RzIGluXG4gIGlmIG5ld19zaXplID4gb2xkX3NpemUgdGhlbiBiZWdpblxuICAgIGxldCBuZXdfYnVjayA9IEFycmF5Lm1ha2UgbmV3X3NpemUgZHVtbXlfbWV0IGluXG4gICAgQXJyYXkuYmxpdCBhcnJheS5tZXRob2RzIDAgbmV3X2J1Y2sgMCBvbGRfc2l6ZTtcbiAgICBhcnJheS5tZXRob2RzIDwtIG5ld19idWNrXG4gZW5kXG5cbmxldCBwdXQgYXJyYXkgbGFiZWwgZWxlbWVudCA9XG4gIHJlc2l6ZSBhcnJheSAobGFiZWwgKyAxKTtcbiAgYXJyYXkubWV0aG9kcy4obGFiZWwpIDwtIGVsZW1lbnRcblxuKCoqKiogQ2xhc3NlcyAqKioqKVxuXG5sZXQgbWV0aG9kX2NvdW50ID0gcmVmIDBcbmxldCBpbnN0X3Zhcl9jb3VudCA9IHJlZiAwXG5cbigqIHR5cGUgdCAqKVxudHlwZSBtZXRoID0gaXRlbVxuXG5sZXQgbmV3X21ldGhvZCB0YWJsZSA9XG4gIGxldCBpbmRleCA9IEFycmF5Lmxlbmd0aCB0YWJsZS5tZXRob2RzIGluXG4gIHJlc2l6ZSB0YWJsZSAoaW5kZXggKyAxKTtcbiAgaW5kZXhcblxubGV0IGdldF9tZXRob2RfbGFiZWwgdGFibGUgbmFtZSA9XG4gIHRyeVxuICAgIE1ldGhzLmZpbmQgbmFtZSB0YWJsZS5tZXRob2RzX2J5X25hbWVcbiAgd2l0aCBOb3RfZm91bmQgLT5cbiAgICBsZXQgbGFiZWwgPSBuZXdfbWV0aG9kIHRhYmxlIGluXG4gICAgdGFibGUubWV0aG9kc19ieV9uYW1lIDwtIE1ldGhzLmFkZCBuYW1lIGxhYmVsIHRhYmxlLm1ldGhvZHNfYnlfbmFtZTtcbiAgICB0YWJsZS5tZXRob2RzX2J5X2xhYmVsIDwtIExhYnMuYWRkIGxhYmVsIHRydWUgdGFibGUubWV0aG9kc19ieV9sYWJlbDtcbiAgICBsYWJlbFxuXG5sZXQgZ2V0X21ldGhvZF9sYWJlbHMgdGFibGUgbmFtZXMgPVxuICBBcnJheS5tYXAgKGdldF9tZXRob2RfbGFiZWwgdGFibGUpIG5hbWVzXG5cbmxldCBzZXRfbWV0aG9kIHRhYmxlIGxhYmVsIGVsZW1lbnQgPVxuICBpbmNyIG1ldGhvZF9jb3VudDtcbiAgaWYgTGFicy5maW5kIGxhYmVsIHRhYmxlLm1ldGhvZHNfYnlfbGFiZWwgdGhlblxuICAgIHB1dCB0YWJsZSBsYWJlbCBlbGVtZW50XG4gIGVsc2VcbiAgICB0YWJsZS5oaWRkZW5fbWV0aHMgPC0gKGxhYmVsLCBlbGVtZW50KSA6OiB0YWJsZS5oaWRkZW5fbWV0aHNcblxubGV0IGdldF9tZXRob2QgdGFibGUgbGFiZWwgPVxuICB0cnkgTGlzdC5hc3NvYyBsYWJlbCB0YWJsZS5oaWRkZW5fbWV0aHNcbiAgd2l0aCBOb3RfZm91bmQgLT4gdGFibGUubWV0aG9kcy4obGFiZWwpXG5cbmxldCB0b19saXN0IGFyciA9XG4gIGlmIGFyciA9PSBtYWdpYyAwIHRoZW4gW10gZWxzZSBBcnJheS50b19saXN0IGFyclxuXG5sZXQgbmFycm93IHRhYmxlIHZhcnMgdmlydF9tZXRocyBjb25jcl9tZXRocyA9XG4gIGxldCB2YXJzID0gdG9fbGlzdCB2YXJzXG4gIGFuZCB2aXJ0X21ldGhzID0gdG9fbGlzdCB2aXJ0X21ldGhzXG4gIGFuZCBjb25jcl9tZXRocyA9IHRvX2xpc3QgY29uY3JfbWV0aHMgaW5cbiAgbGV0IHZpcnRfbWV0aF9sYWJzID0gTGlzdC5tYXAgKGdldF9tZXRob2RfbGFiZWwgdGFibGUpIHZpcnRfbWV0aHMgaW5cbiAgbGV0IGNvbmNyX21ldGhfbGFicyA9IExpc3QubWFwIChnZXRfbWV0aG9kX2xhYmVsIHRhYmxlKSBjb25jcl9tZXRocyBpblxuICB0YWJsZS5wcmV2aW91c19zdGF0ZXMgPC1cbiAgICAgKHRhYmxlLm1ldGhvZHNfYnlfbmFtZSwgdGFibGUubWV0aG9kc19ieV9sYWJlbCwgdGFibGUuaGlkZGVuX21ldGhzLFxuICAgICAgdGFibGUudmFycywgdmlydF9tZXRoX2xhYnMsIHZhcnMpXG4gICAgIDo6IHRhYmxlLnByZXZpb3VzX3N0YXRlcztcbiAgdGFibGUudmFycyA8LVxuICAgIFZhcnMuZm9sZFxuICAgICAgKGZ1biBsYWIgaW5mbyB0dmFycyAtPlxuICAgICAgICBpZiBMaXN0Lm1lbSBsYWIgdmFycyB0aGVuIFZhcnMuYWRkIGxhYiBpbmZvIHR2YXJzIGVsc2UgdHZhcnMpXG4gICAgICB0YWJsZS52YXJzIFZhcnMuZW1wdHk7XG4gIGxldCBieV9uYW1lID0gcmVmIE1ldGhzLmVtcHR5IGluXG4gIGxldCBieV9sYWJlbCA9IHJlZiBMYWJzLmVtcHR5IGluXG4gIExpc3QuaXRlcjJcbiAgICAoZnVuIG1ldCBsYWJlbCAtPlxuICAgICAgIGJ5X25hbWUgOj0gTWV0aHMuYWRkIG1ldCBsYWJlbCAhYnlfbmFtZTtcbiAgICAgICBieV9sYWJlbCA6PVxuICAgICAgICAgIExhYnMuYWRkIGxhYmVsXG4gICAgICAgICAgICAodHJ5IExhYnMuZmluZCBsYWJlbCB0YWJsZS5tZXRob2RzX2J5X2xhYmVsIHdpdGggTm90X2ZvdW5kIC0+IHRydWUpXG4gICAgICAgICAgICAhYnlfbGFiZWwpXG4gICAgY29uY3JfbWV0aHMgY29uY3JfbWV0aF9sYWJzO1xuICBMaXN0Lml0ZXIyXG4gICAgKGZ1biBtZXQgbGFiZWwgLT5cbiAgICAgICBieV9uYW1lIDo9IE1ldGhzLmFkZCBtZXQgbGFiZWwgIWJ5X25hbWU7XG4gICAgICAgYnlfbGFiZWwgOj0gTGFicy5hZGQgbGFiZWwgZmFsc2UgIWJ5X2xhYmVsKVxuICAgIHZpcnRfbWV0aHMgdmlydF9tZXRoX2xhYnM7XG4gIHRhYmxlLm1ldGhvZHNfYnlfbmFtZSA8LSAhYnlfbmFtZTtcbiAgdGFibGUubWV0aG9kc19ieV9sYWJlbCA8LSAhYnlfbGFiZWw7XG4gIHRhYmxlLmhpZGRlbl9tZXRocyA8LVxuICAgICBMaXN0LmZvbGRfcmlnaHRcbiAgICAgICAoZnVuICgobGFiLCBfKSBhcyBtZXQpIGhtIC0+XG4gICAgICAgICAgaWYgTGlzdC5tZW0gbGFiIHZpcnRfbWV0aF9sYWJzIHRoZW4gaG0gZWxzZSBtZXQ6OmhtKVxuICAgICAgIHRhYmxlLmhpZGRlbl9tZXRoc1xuICAgICAgIFtdXG5cbmxldCB3aWRlbiB0YWJsZSA9XG4gIGxldCAoYnlfbmFtZSwgYnlfbGFiZWwsIHNhdmVkX2hpZGRlbl9tZXRocywgc2F2ZWRfdmFycywgdmlydF9tZXRocywgdmFycykgPVxuICAgIExpc3QuaGQgdGFibGUucHJldmlvdXNfc3RhdGVzXG4gIGluXG4gIHRhYmxlLnByZXZpb3VzX3N0YXRlcyA8LSBMaXN0LnRsIHRhYmxlLnByZXZpb3VzX3N0YXRlcztcbiAgdGFibGUudmFycyA8LVxuICAgICBMaXN0LmZvbGRfbGVmdFxuICAgICAgIChmdW4gcyB2IC0+IFZhcnMuYWRkIHYgKFZhcnMuZmluZCB2IHRhYmxlLnZhcnMpIHMpXG4gICAgICAgc2F2ZWRfdmFycyB2YXJzO1xuICB0YWJsZS5tZXRob2RzX2J5X25hbWUgPC0gYnlfbmFtZTtcbiAgdGFibGUubWV0aG9kc19ieV9sYWJlbCA8LSBieV9sYWJlbDtcbiAgdGFibGUuaGlkZGVuX21ldGhzIDwtXG4gICAgIExpc3QuZm9sZF9yaWdodFxuICAgICAgIChmdW4gKChsYWIsIF8pIGFzIG1ldCkgaG0gLT5cbiAgICAgICAgICBpZiBMaXN0Lm1lbSBsYWIgdmlydF9tZXRocyB0aGVuIGhtIGVsc2UgbWV0OjpobSlcbiAgICAgICB0YWJsZS5oaWRkZW5fbWV0aHNcbiAgICAgICBzYXZlZF9oaWRkZW5fbWV0aHNcblxubGV0IG5ld19zbG90IHRhYmxlID1cbiAgbGV0IGluZGV4ID0gdGFibGUuc2l6ZSBpblxuICB0YWJsZS5zaXplIDwtIGluZGV4ICsgMTtcbiAgaW5kZXhcblxubGV0IG5ld192YXJpYWJsZSB0YWJsZSBuYW1lID1cbiAgdHJ5IFZhcnMuZmluZCBuYW1lIHRhYmxlLnZhcnNcbiAgd2l0aCBOb3RfZm91bmQgLT5cbiAgICBsZXQgaW5kZXggPSBuZXdfc2xvdCB0YWJsZSBpblxuICAgIGlmIG5hbWUgPD4gXCJcIiB0aGVuIHRhYmxlLnZhcnMgPC0gVmFycy5hZGQgbmFtZSBpbmRleCB0YWJsZS52YXJzO1xuICAgIGluZGV4XG5cbmxldCB0b19hcnJheSBhcnIgPVxuICBpZiBhcnIgPSBPYmoubWFnaWMgMCB0aGVuIFt8fF0gZWxzZSBhcnJcblxubGV0IG5ld19tZXRob2RzX3ZhcmlhYmxlcyB0YWJsZSBtZXRocyB2YWxzID1cbiAgbGV0IG1ldGhzID0gdG9fYXJyYXkgbWV0aHMgaW5cbiAgbGV0IG5tZXRocyA9IEFycmF5Lmxlbmd0aCBtZXRocyBhbmQgbnZhbHMgPSBBcnJheS5sZW5ndGggdmFscyBpblxuICBsZXQgcmVzID0gQXJyYXkubWFrZSAobm1ldGhzICsgbnZhbHMpIDAgaW5cbiAgZm9yIGkgPSAwIHRvIG5tZXRocyAtIDEgZG9cbiAgICByZXMuKGkpIDwtIGdldF9tZXRob2RfbGFiZWwgdGFibGUgbWV0aHMuKGkpXG4gIGRvbmU7XG4gIGZvciBpID0gMCB0byBudmFscyAtIDEgZG9cbiAgICByZXMuKGkrbm1ldGhzKSA8LSBuZXdfdmFyaWFibGUgdGFibGUgdmFscy4oaSlcbiAgZG9uZTtcbiAgcmVzXG5cbmxldCBnZXRfdmFyaWFibGUgdGFibGUgbmFtZSA9XG4gIHRyeSBWYXJzLmZpbmQgbmFtZSB0YWJsZS52YXJzIHdpdGggTm90X2ZvdW5kIC0+IGFzc2VydCBmYWxzZVxuXG5sZXQgZ2V0X3ZhcmlhYmxlcyB0YWJsZSBuYW1lcyA9XG4gIEFycmF5Lm1hcCAoZ2V0X3ZhcmlhYmxlIHRhYmxlKSBuYW1lc1xuXG5sZXQgYWRkX2luaXRpYWxpemVyIHRhYmxlIGYgPVxuICB0YWJsZS5pbml0aWFsaXplcnMgPC0gZjo6dGFibGUuaW5pdGlhbGl6ZXJzXG5cbigqXG5tb2R1bGUgS2V5cyA9XG4gIE1hcC5NYWtlKHN0cnVjdCB0eXBlIHQgPSB0YWcgYXJyYXkgbGV0IGNvbXBhcmUgKHg6dCkgeSA9IGNvbXBhcmUgeCB5IGVuZClcbmxldCBrZXlfbWFwID0gcmVmIEtleXMuZW1wdHlcbmxldCBnZXRfa2V5IHRhZ3MgOiBpdGVtID1cbiAgdHJ5IG1hZ2ljIChLZXlzLmZpbmQgdGFncyAha2V5X21hcCA6IHRhZyBhcnJheSlcbiAgd2l0aCBOb3RfZm91bmQgLT5cbiAgICBrZXlfbWFwIDo9IEtleXMuYWRkIHRhZ3MgdGFncyAha2V5X21hcDtcbiAgICBtYWdpYyB0YWdzXG4qKVxuXG5sZXQgY3JlYXRlX3RhYmxlIHB1YmxpY19tZXRob2RzID1cbiAgaWYgcHVibGljX21ldGhvZHMgPT0gbWFnaWMgMCB0aGVuIG5ld190YWJsZSBbfHxdIGVsc2VcbiAgKCogW3B1YmxpY19tZXRob2RzXSBtdXN0IGJlIGluIGFzY2VuZGluZyBvcmRlciBmb3IgYnl0ZWNvZGUgKilcbiAgbGV0IHRhZ3MgPSBBcnJheS5tYXAgcHVibGljX21ldGhvZF9sYWJlbCBwdWJsaWNfbWV0aG9kcyBpblxuICBsZXQgdGFibGUgPSBuZXdfdGFibGUgdGFncyBpblxuICBBcnJheS5pdGVyaVxuICAgIChmdW4gaSBtZXQgLT5cbiAgICAgIGxldCBsYWIgPSBpKjIrMiBpblxuICAgICAgdGFibGUubWV0aG9kc19ieV9uYW1lICA8LSBNZXRocy5hZGQgbWV0IGxhYiB0YWJsZS5tZXRob2RzX2J5X25hbWU7XG4gICAgICB0YWJsZS5tZXRob2RzX2J5X2xhYmVsIDwtIExhYnMuYWRkIGxhYiB0cnVlIHRhYmxlLm1ldGhvZHNfYnlfbGFiZWwpXG4gICAgcHVibGljX21ldGhvZHM7XG4gIHRhYmxlXG5cbmxldCBpbml0X2NsYXNzIHRhYmxlID1cbiAgaW5zdF92YXJfY291bnQgOj0gIWluc3RfdmFyX2NvdW50ICsgdGFibGUuc2l6ZSAtIDE7XG4gIHRhYmxlLmluaXRpYWxpemVycyA8LSBMaXN0LnJldiB0YWJsZS5pbml0aWFsaXplcnM7XG4gIHJlc2l6ZSB0YWJsZSAoMyArIG1hZ2ljIHRhYmxlLm1ldGhvZHMuKDEpICogMTYgLyBTeXMud29yZF9zaXplKVxuXG5sZXQgaW5oZXJpdHMgY2xhIHZhbHMgdmlydF9tZXRocyBjb25jcl9tZXRocyAoXywgc3VwZXIsIF8sIGVudikgdG9wID1cbiAgbmFycm93IGNsYSB2YWxzIHZpcnRfbWV0aHMgY29uY3JfbWV0aHM7XG4gIGxldCBpbml0ID1cbiAgICBpZiB0b3AgdGhlbiBzdXBlciBjbGEgZW52IGVsc2UgT2JqLnJlcHIgKHN1cGVyIGNsYSkgaW5cbiAgd2lkZW4gY2xhO1xuICBBcnJheS5jb25jYXRcbiAgICBbW3wgcmVwciBpbml0IHxdO1xuICAgICBtYWdpYyAoQXJyYXkubWFwIChnZXRfdmFyaWFibGUgY2xhKSAodG9fYXJyYXkgdmFscykgOiBpbnQgYXJyYXkpO1xuICAgICBBcnJheS5tYXBcbiAgICAgICAoZnVuIG5tIC0+IHJlcHIgKGdldF9tZXRob2QgY2xhIChnZXRfbWV0aG9kX2xhYmVsIGNsYSBubSkgOiBjbG9zdXJlKSlcbiAgICAgICAodG9fYXJyYXkgY29uY3JfbWV0aHMpIF1cblxubGV0IG1ha2VfY2xhc3MgcHViX21ldGhzIGNsYXNzX2luaXQgPVxuICBsZXQgdGFibGUgPSBjcmVhdGVfdGFibGUgcHViX21ldGhzIGluXG4gIGxldCBlbnZfaW5pdCA9IGNsYXNzX2luaXQgdGFibGUgaW5cbiAgaW5pdF9jbGFzcyB0YWJsZTtcbiAgKGVudl9pbml0IChPYmoucmVwciAwKSwgY2xhc3NfaW5pdCwgZW52X2luaXQsIE9iai5yZXByIDApXG5cbnR5cGUgaW5pdF90YWJsZSA9IHsgbXV0YWJsZSBlbnZfaW5pdDogdDsgbXV0YWJsZSBjbGFzc19pbml0OiB0YWJsZSAtPiB0IH1cblxubGV0IG1ha2VfY2xhc3Nfc3RvcmUgcHViX21ldGhzIGNsYXNzX2luaXQgaW5pdF90YWJsZSA9XG4gIGxldCB0YWJsZSA9IGNyZWF0ZV90YWJsZSBwdWJfbWV0aHMgaW5cbiAgbGV0IGVudl9pbml0ID0gY2xhc3NfaW5pdCB0YWJsZSBpblxuICBpbml0X2NsYXNzIHRhYmxlO1xuICBpbml0X3RhYmxlLmNsYXNzX2luaXQgPC0gY2xhc3NfaW5pdDtcbiAgaW5pdF90YWJsZS5lbnZfaW5pdCA8LSBlbnZfaW5pdFxuXG5sZXQgZHVtbXlfY2xhc3MgbG9jID1cbiAgbGV0IHVuZGVmID0gZnVuIF8gLT4gcmFpc2UgKFVuZGVmaW5lZF9yZWN1cnNpdmVfbW9kdWxlIGxvYykgaW5cbiAgKE9iai5tYWdpYyB1bmRlZiwgdW5kZWYsIHVuZGVmLCBPYmoucmVwciAwKVxuXG4oKioqKiBPYmplY3RzICoqKiopXG5cbmxldCBjcmVhdGVfb2JqZWN0IHRhYmxlID1cbiAgKCogWFhYIEFwcGVsIGRlIFtvYmpfYmxvY2tdIHwgQ2FsbCB0byBbb2JqX2Jsb2NrXSAgKilcbiAgbGV0IG9iaiA9IE9iai5uZXdfYmxvY2sgT2JqLm9iamVjdF90YWcgdGFibGUuc2l6ZSBpblxuICAoKiBYWFggQXBwZWwgZGUgW2NhbWxfbW9kaWZ5XSB8IENhbGwgdG8gW2NhbWxfbW9kaWZ5XSAqKVxuICBPYmouc2V0X2ZpZWxkIG9iaiAwIChPYmoucmVwciB0YWJsZS5tZXRob2RzKTtcbiAgT2JqLm9iaiAoc2V0X2lkIG9iailcblxubGV0IGNyZWF0ZV9vYmplY3Rfb3B0IG9ial8wIHRhYmxlID1cbiAgaWYgKE9iai5tYWdpYyBvYmpfMCA6IGJvb2wpIHRoZW4gb2JqXzAgZWxzZSBiZWdpblxuICAgICgqIFhYWCBBcHBlbCBkZSBbb2JqX2Jsb2NrXSB8IENhbGwgdG8gW29ial9ibG9ja10gICopXG4gICAgbGV0IG9iaiA9IE9iai5uZXdfYmxvY2sgT2JqLm9iamVjdF90YWcgdGFibGUuc2l6ZSBpblxuICAgICgqIFhYWCBBcHBlbCBkZSBbY2FtbF9tb2RpZnldIHwgQ2FsbCB0byBbY2FtbF9tb2RpZnldICopXG4gICAgT2JqLnNldF9maWVsZCBvYmogMCAoT2JqLnJlcHIgdGFibGUubWV0aG9kcyk7XG4gICAgT2JqLm9iaiAoc2V0X2lkIG9iailcbiAgZW5kXG5cbmxldCByZWMgaXRlcl9mIG9iaiA9XG4gIGZ1bmN0aW9uXG4gICAgW10gICAtPiAoKVxuICB8IGY6OmwgLT4gZiBvYmo7IGl0ZXJfZiBvYmogbFxuXG5sZXQgcnVuX2luaXRpYWxpemVycyBvYmogdGFibGUgPVxuICBsZXQgaW5pdHMgPSB0YWJsZS5pbml0aWFsaXplcnMgaW5cbiAgaWYgaW5pdHMgPD4gW10gdGhlblxuICAgIGl0ZXJfZiBvYmogaW5pdHNcblxubGV0IHJ1bl9pbml0aWFsaXplcnNfb3B0IG9ial8wIG9iaiB0YWJsZSA9XG4gIGlmIChPYmoubWFnaWMgb2JqXzAgOiBib29sKSB0aGVuIG9iaiBlbHNlIGJlZ2luXG4gICAgbGV0IGluaXRzID0gdGFibGUuaW5pdGlhbGl6ZXJzIGluXG4gICAgaWYgaW5pdHMgPD4gW10gdGhlbiBpdGVyX2Ygb2JqIGluaXRzO1xuICAgIG9ialxuICBlbmRcblxubGV0IGNyZWF0ZV9vYmplY3RfYW5kX3J1bl9pbml0aWFsaXplcnMgb2JqXzAgdGFibGUgPVxuICBpZiAoT2JqLm1hZ2ljIG9ial8wIDogYm9vbCkgdGhlbiBvYmpfMCBlbHNlIGJlZ2luXG4gICAgbGV0IG9iaiA9IGNyZWF0ZV9vYmplY3QgdGFibGUgaW5cbiAgICBydW5faW5pdGlhbGl6ZXJzIG9iaiB0YWJsZTtcbiAgICBvYmpcbiAgZW5kXG5cbigqIEVxdWl2YWxlbnQgcHJpbWl0aXZlIGJlbG93XG5sZXQgc2VuZHNlbGYgb2JqIGxhYiA9XG4gIChtYWdpYyBvYmogOiAob2JqIC0+IHQpIGFycmF5IGFycmF5KS4oMCkuKGxhYikgb2JqXG4qKVxuZXh0ZXJuYWwgc2VuZCA6IG9iaiAtPiB0YWcgLT4gJ2EgPSBcIiVzZW5kXCJcbmV4dGVybmFsIHNlbmRjYWNoZSA6IG9iaiAtPiB0YWcgLT4gdCAtPiBpbnQgLT4gJ2EgPSBcIiVzZW5kY2FjaGVcIlxuZXh0ZXJuYWwgc2VuZHNlbGYgOiBvYmogLT4gbGFiZWwgLT4gJ2EgPSBcIiVzZW5kc2VsZlwiXG5leHRlcm5hbCBnZXRfcHVibGljX21ldGhvZCA6IG9iaiAtPiB0YWcgLT4gY2xvc3VyZVxuICAgID0gXCJjYW1sX2dldF9wdWJsaWNfbWV0aG9kXCIgW0BAbm9hbGxvY11cblxuKCoqKiogdGFibGUgY29sbGVjdGlvbiBhY2Nlc3MgKioqKilcblxudHlwZSB0YWJsZXMgPVxuICB8IEVtcHR5XG4gIHwgQ29ucyBvZiB7a2V5IDogY2xvc3VyZTsgbXV0YWJsZSBkYXRhOiB0YWJsZXM7IG11dGFibGUgbmV4dDogdGFibGVzfVxuXG5sZXQgc2V0X2RhdGEgdGFibGVzIHYgPSBtYXRjaCB0YWJsZXMgd2l0aFxuICB8IEVtcHR5IC0+IGFzc2VydCBmYWxzZVxuICB8IENvbnMgdGFibGVzIC0+IHRhYmxlcy5kYXRhIDwtIHZcbmxldCBzZXRfbmV4dCB0YWJsZXMgdiA9IG1hdGNoIHRhYmxlcyB3aXRoXG4gIHwgRW1wdHkgLT4gYXNzZXJ0IGZhbHNlXG4gIHwgQ29ucyB0YWJsZXMgLT4gdGFibGVzLm5leHQgPC0gdlxubGV0IGdldF9rZXkgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+IGFzc2VydCBmYWxzZVxuICB8IENvbnMgdGFibGVzIC0+IHRhYmxlcy5rZXlcbmxldCBnZXRfZGF0YSA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT4gYXNzZXJ0IGZhbHNlXG4gIHwgQ29ucyB0YWJsZXMgLT4gdGFibGVzLmRhdGFcbmxldCBnZXRfbmV4dCA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT4gYXNzZXJ0IGZhbHNlXG4gIHwgQ29ucyB0YWJsZXMgLT4gdGFibGVzLm5leHRcblxubGV0IGJ1aWxkX3BhdGggbiBrZXlzIHRhYmxlcyA9XG4gIGxldCByZXMgPSBDb25zIHtrZXkgPSBPYmoubWFnaWMgMDsgZGF0YSA9IEVtcHR5OyBuZXh0ID0gRW1wdHl9IGluXG4gIGxldCByID0gcmVmIHJlcyBpblxuICBmb3IgaSA9IDAgdG8gbiBkb1xuICAgIHIgOj0gQ29ucyB7a2V5ID0ga2V5cy4oaSk7IGRhdGEgPSAhcjsgbmV4dCA9IEVtcHR5fVxuICBkb25lO1xuICBzZXRfZGF0YSB0YWJsZXMgIXI7XG4gIHJlc1xuXG5sZXQgcmVjIGxvb2t1cF9rZXlzIGkga2V5cyB0YWJsZXMgPVxuICBpZiBpIDwgMCB0aGVuIHRhYmxlcyBlbHNlXG4gIGxldCBrZXkgPSBrZXlzLihpKSBpblxuICBsZXQgcmVjIGxvb2t1cF9rZXkgKHRhYmxlczp0YWJsZXMpID1cbiAgICBpZiBnZXRfa2V5IHRhYmxlcyA9PSBrZXkgdGhlblxuICAgICAgbWF0Y2ggZ2V0X2RhdGEgdGFibGVzIHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gYXNzZXJ0IGZhbHNlXG4gICAgICB8IENvbnMgXyBhcyB0YWJsZXNfZGF0YSAtPlxuICAgICAgICAgIGxvb2t1cF9rZXlzIChpLTEpIGtleXMgdGFibGVzX2RhdGFcbiAgICBlbHNlXG4gICAgICBtYXRjaCBnZXRfbmV4dCB0YWJsZXMgd2l0aFxuICAgICAgfCBDb25zIF8gYXMgbmV4dCAtPiBsb29rdXBfa2V5IG5leHRcbiAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICBsZXQgbmV4dCA6IHRhYmxlcyA9IENvbnMge2tleTsgZGF0YSA9IEVtcHR5OyBuZXh0ID0gRW1wdHl9IGluXG4gICAgICAgICAgc2V0X25leHQgdGFibGVzIG5leHQ7XG4gICAgICAgICAgYnVpbGRfcGF0aCAoaS0xKSBrZXlzIG5leHRcbiAgaW5cbiAgbG9va3VwX2tleSB0YWJsZXNcblxubGV0IGxvb2t1cF90YWJsZXMgcm9vdCBrZXlzID1cbiAgbWF0Y2ggZ2V0X2RhdGEgcm9vdCB3aXRoXG4gIHwgQ29ucyBfIGFzIHJvb3RfZGF0YSAtPlxuICAgIGxvb2t1cF9rZXlzIChBcnJheS5sZW5ndGgga2V5cyAtIDEpIGtleXMgcm9vdF9kYXRhXG4gIHwgRW1wdHkgLT5cbiAgICBidWlsZF9wYXRoIChBcnJheS5sZW5ndGgga2V5cyAtIDEpIGtleXMgcm9vdFxuXG4oKioqKiBidWlsdGluIG1ldGhvZHMgKioqKilcblxubGV0IGdldF9jb25zdCB4ID0gcmV0IChmdW4gX29iaiAtPiB4KVxubGV0IGdldF92YXIgbiAgID0gcmV0IChmdW4gb2JqIC0+IEFycmF5LnVuc2FmZV9nZXQgb2JqIG4pXG5sZXQgZ2V0X2VudiBlIG4gPVxuICByZXQgKGZ1biBvYmogLT5cbiAgICBBcnJheS51bnNhZmVfZ2V0IChPYmoubWFnaWMgKEFycmF5LnVuc2FmZV9nZXQgb2JqIGUpIDogb2JqKSBuKVxubGV0IGdldF9tZXRoIG4gID0gcmV0IChmdW4gb2JqIC0+IHNlbmRzZWxmIG9iaiBuKVxubGV0IHNldF92YXIgbiAgID0gcmV0IChmdW4gb2JqIHggLT4gQXJyYXkudW5zYWZlX3NldCBvYmogbiB4KVxubGV0IGFwcF9jb25zdCBmIHggPSByZXQgKGZ1biBfb2JqIC0+IGYgeClcbmxldCBhcHBfdmFyIGYgbiAgID0gcmV0IChmdW4gb2JqIC0+IGYgKEFycmF5LnVuc2FmZV9nZXQgb2JqIG4pKVxubGV0IGFwcF9lbnYgZiBlIG4gPVxuICByZXQgKGZ1biBvYmogLT5cbiAgICBmIChBcnJheS51bnNhZmVfZ2V0IChPYmoubWFnaWMgKEFycmF5LnVuc2FmZV9nZXQgb2JqIGUpIDogb2JqKSBuKSlcbmxldCBhcHBfbWV0aCBmIG4gID0gcmV0IChmdW4gb2JqIC0+IGYgKHNlbmRzZWxmIG9iaiBuKSlcbmxldCBhcHBfY29uc3RfY29uc3QgZiB4IHkgPSByZXQgKGZ1biBfb2JqIC0+IGYgeCB5KVxubGV0IGFwcF9jb25zdF92YXIgZiB4IG4gICA9IHJldCAoZnVuIG9iaiAtPiBmIHggKEFycmF5LnVuc2FmZV9nZXQgb2JqIG4pKVxubGV0IGFwcF9jb25zdF9tZXRoIGYgeCBuID0gcmV0IChmdW4gb2JqIC0+IGYgeCAoc2VuZHNlbGYgb2JqIG4pKVxubGV0IGFwcF92YXJfY29uc3QgZiBuIHggPSByZXQgKGZ1biBvYmogLT4gZiAoQXJyYXkudW5zYWZlX2dldCBvYmogbikgeClcbmxldCBhcHBfbWV0aF9jb25zdCBmIG4geCA9IHJldCAoZnVuIG9iaiAtPiBmIChzZW5kc2VsZiBvYmogbikgeClcbmxldCBhcHBfY29uc3RfZW52IGYgeCBlIG4gPVxuICByZXQgKGZ1biBvYmogLT5cbiAgICBmIHggKEFycmF5LnVuc2FmZV9nZXQgKE9iai5tYWdpYyAoQXJyYXkudW5zYWZlX2dldCBvYmogZSkgOiBvYmopIG4pKVxubGV0IGFwcF9lbnZfY29uc3QgZiBlIG4geCA9XG4gIHJldCAoZnVuIG9iaiAtPlxuICAgIGYgKEFycmF5LnVuc2FmZV9nZXQgKE9iai5tYWdpYyAoQXJyYXkudW5zYWZlX2dldCBvYmogZSkgOiBvYmopIG4pIHgpXG5sZXQgbWV0aF9hcHBfY29uc3QgbiB4ID0gcmV0IChmdW4gb2JqIC0+IChzZW5kc2VsZiBvYmogbiA6IF8gLT4gXykgeClcbmxldCBtZXRoX2FwcF92YXIgbiBtID1cbiAgcmV0IChmdW4gb2JqIC0+IChzZW5kc2VsZiBvYmogbiA6IF8gLT4gXykgKEFycmF5LnVuc2FmZV9nZXQgb2JqIG0pKVxubGV0IG1ldGhfYXBwX2VudiBuIGUgbSA9XG4gIHJldCAoZnVuIG9iaiAtPiAoc2VuZHNlbGYgb2JqIG4gOiBfIC0+IF8pXG4gICAgICAoQXJyYXkudW5zYWZlX2dldCAoT2JqLm1hZ2ljIChBcnJheS51bnNhZmVfZ2V0IG9iaiBlKSA6IG9iaikgbSkpXG5sZXQgbWV0aF9hcHBfbWV0aCBuIG0gPVxuICByZXQgKGZ1biBvYmogLT4gKHNlbmRzZWxmIG9iaiBuIDogXyAtPiBfKSAoc2VuZHNlbGYgb2JqIG0pKVxubGV0IHNlbmRfY29uc3QgbSB4IGMgPVxuICByZXQgKGZ1biBvYmogLT4gc2VuZGNhY2hlIHggbSAoQXJyYXkudW5zYWZlX2dldCBvYmogMCkgYylcbmxldCBzZW5kX3ZhciBtIG4gYyA9XG4gIHJldCAoZnVuIG9iaiAtPlxuICAgIHNlbmRjYWNoZSAoT2JqLm1hZ2ljIChBcnJheS51bnNhZmVfZ2V0IG9iaiBuKSA6IG9iaikgbVxuICAgICAgKEFycmF5LnVuc2FmZV9nZXQgb2JqIDApIGMpXG5sZXQgc2VuZF9lbnYgbSBlIG4gYyA9XG4gIHJldCAoZnVuIG9iaiAtPlxuICAgIHNlbmRjYWNoZVxuICAgICAgKE9iai5tYWdpYyAoQXJyYXkudW5zYWZlX2dldFxuICAgICAgICAgICAgICAgICAgICAoT2JqLm1hZ2ljIChBcnJheS51bnNhZmVfZ2V0IG9iaiBlKSA6IG9iaikgbikgOiBvYmopXG4gICAgICBtIChBcnJheS51bnNhZmVfZ2V0IG9iaiAwKSBjKVxubGV0IHNlbmRfbWV0aCBtIG4gYyA9XG4gIHJldCAoZnVuIG9iaiAtPlxuICAgIHNlbmRjYWNoZSAoc2VuZHNlbGYgb2JqIG4pIG0gKEFycmF5LnVuc2FmZV9nZXQgb2JqIDApIGMpXG5sZXQgbmV3X2NhY2hlIHRhYmxlID1cbiAgbGV0IG4gPSBuZXdfbWV0aG9kIHRhYmxlIGluXG4gIGxldCBuID1cbiAgICBpZiBuIG1vZCAyID0gMCB8fCBuID4gMiArIG1hZ2ljIHRhYmxlLm1ldGhvZHMuKDEpICogMTYgLyBTeXMud29yZF9zaXplXG4gICAgdGhlbiBuIGVsc2UgbmV3X21ldGhvZCB0YWJsZVxuICBpblxuICB0YWJsZS5tZXRob2RzLihuKSA8LSBPYmoubWFnaWMgMDtcbiAgblxuXG50eXBlIGltcGwgPVxuICAgIEdldENvbnN0XG4gIHwgR2V0VmFyXG4gIHwgR2V0RW52XG4gIHwgR2V0TWV0aFxuICB8IFNldFZhclxuICB8IEFwcENvbnN0XG4gIHwgQXBwVmFyXG4gIHwgQXBwRW52XG4gIHwgQXBwTWV0aFxuICB8IEFwcENvbnN0Q29uc3RcbiAgfCBBcHBDb25zdFZhclxuICB8IEFwcENvbnN0RW52XG4gIHwgQXBwQ29uc3RNZXRoXG4gIHwgQXBwVmFyQ29uc3RcbiAgfCBBcHBFbnZDb25zdFxuICB8IEFwcE1ldGhDb25zdFxuICB8IE1ldGhBcHBDb25zdFxuICB8IE1ldGhBcHBWYXJcbiAgfCBNZXRoQXBwRW52XG4gIHwgTWV0aEFwcE1ldGhcbiAgfCBTZW5kQ29uc3RcbiAgfCBTZW5kVmFyXG4gIHwgU2VuZEVudlxuICB8IFNlbmRNZXRoXG4gIHwgQ2xvc3VyZSBvZiBjbG9zdXJlXG5cbmxldCBtZXRob2RfaW1wbCB0YWJsZSBpIGFyciA9XG4gIGxldCBuZXh0ICgpID0gaW5jciBpOyBtYWdpYyBhcnIuKCFpKSBpblxuICBtYXRjaCBuZXh0KCkgd2l0aFxuICAgIEdldENvbnN0IC0+IGxldCB4IDogdCA9IG5leHQoKSBpbiBnZXRfY29uc3QgeFxuICB8IEdldFZhciAgIC0+IGxldCBuID0gbmV4dCgpIGluIGdldF92YXIgblxuICB8IEdldEVudiAgIC0+IGxldCBlID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCgpIGluIGdldF9lbnYgZSBuXG4gIHwgR2V0TWV0aCAgLT4gbGV0IG4gPSBuZXh0KCkgaW4gZ2V0X21ldGggblxuICB8IFNldFZhciAgIC0+IGxldCBuID0gbmV4dCgpIGluIHNldF92YXIgblxuICB8IEFwcENvbnN0IC0+IGxldCBmID0gbmV4dCgpIGluIGxldCB4ID0gbmV4dCgpIGluIGFwcF9jb25zdCBmIHhcbiAgfCBBcHBWYXIgICAtPiBsZXQgZiA9IG5leHQoKSBpbiBsZXQgbiA9IG5leHQgKCkgaW4gYXBwX3ZhciBmIG5cbiAgfCBBcHBFbnYgICAtPlxuICAgICAgbGV0IGYgPSBuZXh0KCkgaW4gIGxldCBlID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCgpIGluXG4gICAgICBhcHBfZW52IGYgZSBuXG4gIHwgQXBwTWV0aCAgLT4gbGV0IGYgPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0ICgpIGluIGFwcF9tZXRoIGYgblxuICB8IEFwcENvbnN0Q29uc3QgLT5cbiAgICAgIGxldCBmID0gbmV4dCgpIGluIGxldCB4ID0gbmV4dCgpIGluIGxldCB5ID0gbmV4dCgpIGluXG4gICAgICBhcHBfY29uc3RfY29uc3QgZiB4IHlcbiAgfCBBcHBDb25zdFZhciAtPlxuICAgICAgbGV0IGYgPSBuZXh0KCkgaW4gbGV0IHggPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0KCkgaW5cbiAgICAgIGFwcF9jb25zdF92YXIgZiB4IG5cbiAgfCBBcHBDb25zdEVudiAtPlxuICAgICAgbGV0IGYgPSBuZXh0KCkgaW4gbGV0IHggPSBuZXh0KCkgaW4gbGV0IGUgPSBuZXh0ICgpIGluIGxldCBuID0gbmV4dCgpIGluXG4gICAgICBhcHBfY29uc3RfZW52IGYgeCBlIG5cbiAgfCBBcHBDb25zdE1ldGggLT5cbiAgICAgIGxldCBmID0gbmV4dCgpIGluIGxldCB4ID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCgpIGluXG4gICAgICBhcHBfY29uc3RfbWV0aCBmIHggblxuICB8IEFwcFZhckNvbnN0IC0+XG4gICAgICBsZXQgZiA9IG5leHQoKSBpbiBsZXQgbiA9IG5leHQoKSBpbiBsZXQgeCA9IG5leHQoKSBpblxuICAgICAgYXBwX3Zhcl9jb25zdCBmIG4geFxuICB8IEFwcEVudkNvbnN0IC0+XG4gICAgICBsZXQgZiA9IG5leHQoKSBpbiBsZXQgZSA9IG5leHQgKCkgaW4gbGV0IG4gPSBuZXh0KCkgaW4gbGV0IHggPSBuZXh0KCkgaW5cbiAgICAgIGFwcF9lbnZfY29uc3QgZiBlIG4geFxuICB8IEFwcE1ldGhDb25zdCAtPlxuICAgICAgbGV0IGYgPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0KCkgaW4gbGV0IHggPSBuZXh0KCkgaW5cbiAgICAgIGFwcF9tZXRoX2NvbnN0IGYgbiB4XG4gIHwgTWV0aEFwcENvbnN0IC0+XG4gICAgICBsZXQgbiA9IG5leHQoKSBpbiBsZXQgeCA9IG5leHQoKSBpbiBtZXRoX2FwcF9jb25zdCBuIHhcbiAgfCBNZXRoQXBwVmFyIC0+XG4gICAgICBsZXQgbiA9IG5leHQoKSBpbiBsZXQgbSA9IG5leHQoKSBpbiBtZXRoX2FwcF92YXIgbiBtXG4gIHwgTWV0aEFwcEVudiAtPlxuICAgICAgbGV0IG4gPSBuZXh0KCkgaW4gbGV0IGUgPSBuZXh0KCkgaW4gbGV0IG0gPSBuZXh0KCkgaW5cbiAgICAgIG1ldGhfYXBwX2VudiBuIGUgbVxuICB8IE1ldGhBcHBNZXRoIC0+XG4gICAgICBsZXQgbiA9IG5leHQoKSBpbiBsZXQgbSA9IG5leHQoKSBpbiBtZXRoX2FwcF9tZXRoIG4gbVxuICB8IFNlbmRDb25zdCAtPlxuICAgICAgbGV0IG0gPSBuZXh0KCkgaW4gbGV0IHggPSBuZXh0KCkgaW4gc2VuZF9jb25zdCBtIHggKG5ld19jYWNoZSB0YWJsZSlcbiAgfCBTZW5kVmFyIC0+XG4gICAgICBsZXQgbSA9IG5leHQoKSBpbiBsZXQgbiA9IG5leHQgKCkgaW4gc2VuZF92YXIgbSBuIChuZXdfY2FjaGUgdGFibGUpXG4gIHwgU2VuZEVudiAtPlxuICAgICAgbGV0IG0gPSBuZXh0KCkgaW4gbGV0IGUgPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0KCkgaW5cbiAgICAgIHNlbmRfZW52IG0gZSBuIChuZXdfY2FjaGUgdGFibGUpXG4gIHwgU2VuZE1ldGggLT5cbiAgICAgIGxldCBtID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCAoKSBpbiBzZW5kX21ldGggbSBuIChuZXdfY2FjaGUgdGFibGUpXG4gIHwgQ2xvc3VyZSBfIGFzIGNsbyAtPiBtYWdpYyBjbG9cblxubGV0IHNldF9tZXRob2RzIHRhYmxlIG1ldGhvZHMgPVxuICBsZXQgbGVuID0gQXJyYXkubGVuZ3RoIG1ldGhvZHMgaW4gbGV0IGkgPSByZWYgMCBpblxuICB3aGlsZSAhaSA8IGxlbiBkb1xuICAgIGxldCBsYWJlbCA9IG1ldGhvZHMuKCFpKSBpbiBsZXQgY2xvID0gbWV0aG9kX2ltcGwgdGFibGUgaSBtZXRob2RzIGluXG4gICAgc2V0X21ldGhvZCB0YWJsZSBsYWJlbCBjbG87XG4gICAgaW5jciBpXG4gIGRvbmVcblxuKCoqKiogU3RhdGlzdGljcyAqKioqKVxuXG50eXBlIHN0YXRzID1cbiAgeyBjbGFzc2VzOiBpbnQ7IG1ldGhvZHM6IGludDsgaW5zdF92YXJzOiBpbnQ7IH1cblxubGV0IHN0YXRzICgpID1cbiAgeyBjbGFzc2VzID0gIXRhYmxlX2NvdW50O1xuICAgIG1ldGhvZHMgPSAhbWV0aG9kX2NvdW50OyBpbnN0X3ZhcnMgPSAhaW5zdF92YXJfY291bnQ7IH1cbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxudHlwZSB0b2tlbiA9XG4gICAgS3dkIG9mIHN0cmluZ1xuICB8IElkZW50IG9mIHN0cmluZ1xuICB8IEludCBvZiBpbnRcbiAgfCBGbG9hdCBvZiBmbG9hdFxuICB8IFN0cmluZyBvZiBzdHJpbmdcbiAgfCBDaGFyIG9mIGNoYXJcblxuKCogVGhlIHN0cmluZyBidWZmZXJpbmcgbWFjaGluZXJ5ICopXG5cbmxldCBpbml0aWFsX2J1ZmZlciA9IEJ5dGVzLmNyZWF0ZSAzMlxuXG5sZXQgYnVmZmVyID0gcmVmIGluaXRpYWxfYnVmZmVyXG5sZXQgYnVmcG9zID0gcmVmIDBcblxubGV0IHJlc2V0X2J1ZmZlciAoKSA9IGJ1ZmZlciA6PSBpbml0aWFsX2J1ZmZlcjsgYnVmcG9zIDo9IDBcblxubGV0IHN0b3JlIGMgPVxuICBpZiAhYnVmcG9zID49IEJ5dGVzLmxlbmd0aCAhYnVmZmVyIHRoZW4gYmVnaW5cbiAgICBsZXQgbmV3YnVmZmVyID0gQnl0ZXMuY3JlYXRlICgyICogIWJ1ZnBvcykgaW5cbiAgICBCeXRlcy5ibGl0ICFidWZmZXIgMCBuZXdidWZmZXIgMCAhYnVmcG9zO1xuICAgIGJ1ZmZlciA6PSBuZXdidWZmZXJcbiAgZW5kO1xuICBCeXRlcy5zZXQgIWJ1ZmZlciAhYnVmcG9zIGM7XG4gIGluY3IgYnVmcG9zXG5cbmxldCBnZXRfc3RyaW5nICgpID1cbiAgbGV0IHMgPSBCeXRlcy5zdWJfc3RyaW5nICFidWZmZXIgMCAhYnVmcG9zIGluIGJ1ZmZlciA6PSBpbml0aWFsX2J1ZmZlcjsgc1xuXG4oKiBUaGUgbGV4ZXIgKilcblxubGV0IG1ha2VfbGV4ZXIga2V5d29yZHMgPVxuICBsZXQga3dkX3RhYmxlID0gSGFzaHRibC5jcmVhdGUgMTcgaW5cbiAgTGlzdC5pdGVyIChmdW4gcyAtPiBIYXNodGJsLmFkZCBrd2RfdGFibGUgcyAoS3dkIHMpKSBrZXl3b3JkcztcbiAgbGV0IGlkZW50X29yX2tleXdvcmQgaWQgPVxuICAgIHRyeSBIYXNodGJsLmZpbmQga3dkX3RhYmxlIGlkIHdpdGhcbiAgICAgIE5vdF9mb3VuZCAtPiBJZGVudCBpZFxuICBhbmQga2V5d29yZF9vcl9lcnJvciBjID1cbiAgICBsZXQgcyA9IFN0cmluZy5tYWtlIDEgYyBpblxuICAgIHRyeSBIYXNodGJsLmZpbmQga3dkX3RhYmxlIHMgd2l0aFxuICAgICAgTm90X2ZvdW5kIC0+IHJhaXNlIChTdHJlYW0uRXJyb3IgKFwiSWxsZWdhbCBjaGFyYWN0ZXIgXCIgXiBzKSlcbiAgaW5cbiAgbGV0IHJlYyBuZXh0X3Rva2VuIChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWUgKCcgJyB8ICdcXDAxMCcgfCAnXFwwMTMnIHwgJ1xcMDA5JyB8ICdcXDAyNicgfCAnXFwwMTInKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187IG5leHRfdG9rZW4gc3RybV9fXG4gICAgfCBTb21lICgnQScuLidaJyB8ICdhJy4uJ3onIHwgJ18nIHwgJ1xcMTkyJy4uJ1xcMjU1JyBhcyBjKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187XG4gICAgICAgIGxldCBzID0gc3RybV9fIGluIHJlc2V0X2J1ZmZlciAoKTsgc3RvcmUgYzsgaWRlbnQgc1xuICAgIHwgU29tZVxuICAgICAgICAoJyEnIHwgJyUnIHwgJyYnIHwgJyQnIHwgJyMnIHwgJysnIHwgJy8nIHwgJzonIHwgJzwnIHwgJz0nIHwgJz4nIHxcbiAgICAgICAgICc/JyB8ICdAJyB8ICdcXFxcJyB8ICd+JyB8ICdeJyB8ICd8JyB8ICcqJyBhcyBjKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187XG4gICAgICAgIGxldCBzID0gc3RybV9fIGluIHJlc2V0X2J1ZmZlciAoKTsgc3RvcmUgYzsgaWRlbnQyIHNcbiAgICB8IFNvbWUgKCcwJy4uJzknIGFzIGMpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXztcbiAgICAgICAgbGV0IHMgPSBzdHJtX18gaW4gcmVzZXRfYnVmZmVyICgpOyBzdG9yZSBjOyBudW1iZXIgc1xuICAgIHwgU29tZSAnXFwnJyAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187XG4gICAgICAgIGxldCBjID1cbiAgICAgICAgICB0cnkgY2hhciBzdHJtX18gd2l0aFxuICAgICAgICAgICAgU3RyZWFtLkZhaWx1cmUgLT4gcmFpc2UgKFN0cmVhbS5FcnJvciBcIlwiKVxuICAgICAgICBpblxuICAgICAgICBiZWdpbiBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgICAgIFNvbWUgJ1xcJycgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBTb21lIChDaGFyIGMpXG4gICAgICAgIHwgXyAtPiByYWlzZSAoU3RyZWFtLkVycm9yIFwiXCIpXG4gICAgICAgIGVuZFxuICAgIHwgU29tZSAnXFxcIicgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fO1xuICAgICAgICBsZXQgcyA9IHN0cm1fXyBpbiByZXNldF9idWZmZXIgKCk7IFNvbWUgKFN0cmluZyAoc3RyaW5nIHMpKVxuICAgIHwgU29tZSAnLScgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBuZWdfbnVtYmVyIHN0cm1fX1xuICAgIHwgU29tZSAnKCcgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBtYXliZV9jb21tZW50IHN0cm1fX1xuICAgIHwgU29tZSBjIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgU29tZSAoa2V5d29yZF9vcl9lcnJvciBjKVxuICAgIHwgXyAtPiBOb25lXG4gIGFuZCBpZGVudCAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lXG4gICAgICAgICgnQScuLidaJyB8ICdhJy4uJ3onIHwgJ1xcMTkyJy4uJ1xcMjU1JyB8ICcwJy4uJzknIHwgJ18nIHwgJ1xcJycgYXMgYykgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fOyBsZXQgcyA9IHN0cm1fXyBpbiBzdG9yZSBjOyBpZGVudCBzXG4gICAgfCBfIC0+IFNvbWUgKGlkZW50X29yX2tleXdvcmQgKGdldF9zdHJpbmcgKCkpKVxuICBhbmQgaWRlbnQyIChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWVcbiAgICAgICAgKCchJyB8ICclJyB8ICcmJyB8ICckJyB8ICcjJyB8ICcrJyB8ICctJyB8ICcvJyB8ICc6JyB8ICc8JyB8ICc9JyB8XG4gICAgICAgICAnPicgfCAnPycgfCAnQCcgfCAnXFxcXCcgfCAnficgfCAnXicgfCAnfCcgfCAnKicgYXMgYykgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fOyBsZXQgcyA9IHN0cm1fXyBpbiBzdG9yZSBjOyBpZGVudDIgc1xuICAgIHwgXyAtPiBTb21lIChpZGVudF9vcl9rZXl3b3JkIChnZXRfc3RyaW5nICgpKSlcbiAgYW5kIG5lZ19udW1iZXIgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZSAoJzAnLi4nOScgYXMgYykgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fO1xuICAgICAgICBsZXQgcyA9IHN0cm1fXyBpbiByZXNldF9idWZmZXIgKCk7IHN0b3JlICctJzsgc3RvcmUgYzsgbnVtYmVyIHNcbiAgICB8IF8gLT4gbGV0IHMgPSBzdHJtX18gaW4gcmVzZXRfYnVmZmVyICgpOyBzdG9yZSAnLSc7IGlkZW50MiBzXG4gIGFuZCBudW1iZXIgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZSAoJzAnLi4nOScgYXMgYykgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fOyBsZXQgcyA9IHN0cm1fXyBpbiBzdG9yZSBjOyBudW1iZXIgc1xuICAgIHwgU29tZSAnLicgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fOyBsZXQgcyA9IHN0cm1fXyBpbiBzdG9yZSAnLic7IGRlY2ltYWxfcGFydCBzXG4gICAgfCBTb21lICgnZScgfCAnRScpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXzsgbGV0IHMgPSBzdHJtX18gaW4gc3RvcmUgJ0UnOyBleHBvbmVudF9wYXJ0IHNcbiAgICB8IF8gLT4gU29tZSAoSW50IChpbnRfb2Zfc3RyaW5nIChnZXRfc3RyaW5nICgpKSkpXG4gIGFuZCBkZWNpbWFsX3BhcnQgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZSAoJzAnLi4nOScgYXMgYykgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fOyBsZXQgcyA9IHN0cm1fXyBpbiBzdG9yZSBjOyBkZWNpbWFsX3BhcnQgc1xuICAgIHwgU29tZSAoJ2UnIHwgJ0UnKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187IGxldCBzID0gc3RybV9fIGluIHN0b3JlICdFJzsgZXhwb25lbnRfcGFydCBzXG4gICAgfCBfIC0+IFNvbWUgKEZsb2F0IChmbG9hdF9vZl9zdHJpbmcgKGdldF9zdHJpbmcgKCkpKSlcbiAgYW5kIGV4cG9uZW50X3BhcnQgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZSAoJysnIHwgJy0nIGFzIGMpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXzsgbGV0IHMgPSBzdHJtX18gaW4gc3RvcmUgYzsgZW5kX2V4cG9uZW50X3BhcnQgc1xuICAgIHwgXyAtPiBlbmRfZXhwb25lbnRfcGFydCBzdHJtX19cbiAgYW5kIGVuZF9leHBvbmVudF9wYXJ0IChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWUgKCcwJy4uJzknIGFzIGMpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXzsgbGV0IHMgPSBzdHJtX18gaW4gc3RvcmUgYzsgZW5kX2V4cG9uZW50X3BhcnQgc1xuICAgIHwgXyAtPiBTb21lIChGbG9hdCAoZmxvYXRfb2Zfc3RyaW5nIChnZXRfc3RyaW5nICgpKSkpXG4gIGFuZCBzdHJpbmcgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZSAnXFxcIicgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBnZXRfc3RyaW5nICgpXG4gICAgfCBTb21lICdcXFxcJyAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187XG4gICAgICAgIGxldCBjID1cbiAgICAgICAgICB0cnkgZXNjYXBlIHN0cm1fXyB3aXRoXG4gICAgICAgICAgICBTdHJlYW0uRmFpbHVyZSAtPiByYWlzZSAoU3RyZWFtLkVycm9yIFwiXCIpXG4gICAgICAgIGluXG4gICAgICAgIGxldCBzID0gc3RybV9fIGluIHN0b3JlIGM7IHN0cmluZyBzXG4gICAgfCBTb21lIGMgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBsZXQgcyA9IHN0cm1fXyBpbiBzdG9yZSBjOyBzdHJpbmcgc1xuICAgIHwgXyAtPiByYWlzZSBTdHJlYW0uRmFpbHVyZVxuICBhbmQgY2hhciAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICdcXFxcJyAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187XG4gICAgICAgIGJlZ2luIHRyeSBlc2NhcGUgc3RybV9fIHdpdGhcbiAgICAgICAgICBTdHJlYW0uRmFpbHVyZSAtPiByYWlzZSAoU3RyZWFtLkVycm9yIFwiXCIpXG4gICAgICAgIGVuZFxuICAgIHwgU29tZSBjIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgY1xuICAgIHwgXyAtPiByYWlzZSBTdHJlYW0uRmFpbHVyZVxuICBhbmQgZXNjYXBlIChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWUgJ24nIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgJ1xcbidcbiAgICB8IFNvbWUgJ3InIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgJ1xccidcbiAgICB8IFNvbWUgJ3QnIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgJ1xcdCdcbiAgICB8IFNvbWUgKCcwJy4uJzknIGFzIGMxKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187XG4gICAgICAgIGJlZ2luIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICAgICAgU29tZSAoJzAnLi4nOScgYXMgYzIpIC0+XG4gICAgICAgICAgICBTdHJlYW0uanVuayBzdHJtX187XG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgICAgICAgICBTb21lICgnMCcuLic5JyBhcyBjMykgLT5cbiAgICAgICAgICAgICAgICBTdHJlYW0uanVuayBzdHJtX187XG4gICAgICAgICAgICAgICAgQ2hhci5jaHJcbiAgICAgICAgICAgICAgICAgICgoQ2hhci5jb2RlIGMxIC0gNDgpICogMTAwICsgKENoYXIuY29kZSBjMiAtIDQ4KSAqIDEwICtcbiAgICAgICAgICAgICAgICAgICAgIChDaGFyLmNvZGUgYzMgLSA0OCkpXG4gICAgICAgICAgICB8IF8gLT4gcmFpc2UgKFN0cmVhbS5FcnJvciBcIlwiKVxuICAgICAgICAgICAgZW5kXG4gICAgICAgIHwgXyAtPiByYWlzZSAoU3RyZWFtLkVycm9yIFwiXCIpXG4gICAgICAgIGVuZFxuICAgIHwgU29tZSBjIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgY1xuICAgIHwgXyAtPiByYWlzZSBTdHJlYW0uRmFpbHVyZVxuICBhbmQgbWF5YmVfY29tbWVudCAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICcqJyAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187IGxldCBzID0gc3RybV9fIGluIGNvbW1lbnQgczsgbmV4dF90b2tlbiBzXG4gICAgfCBfIC0+IFNvbWUgKGtleXdvcmRfb3JfZXJyb3IgJygnKVxuICBhbmQgY29tbWVudCAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICcoJyAtPiBTdHJlYW0uanVuayBzdHJtX187IG1heWJlX25lc3RlZF9jb21tZW50IHN0cm1fX1xuICAgIHwgU29tZSAnKicgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBtYXliZV9lbmRfY29tbWVudCBzdHJtX19cbiAgICB8IFNvbWUgXyAtPiBTdHJlYW0uanVuayBzdHJtX187IGNvbW1lbnQgc3RybV9fXG4gICAgfCBfIC0+IHJhaXNlIFN0cmVhbS5GYWlsdXJlXG4gIGFuZCBtYXliZV9uZXN0ZWRfY29tbWVudCAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICcqJyAtPiBTdHJlYW0uanVuayBzdHJtX187IGxldCBzID0gc3RybV9fIGluIGNvbW1lbnQgczsgY29tbWVudCBzXG4gICAgfCBTb21lIF8gLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBjb21tZW50IHN0cm1fX1xuICAgIHwgXyAtPiByYWlzZSBTdHJlYW0uRmFpbHVyZVxuICBhbmQgbWF5YmVfZW5kX2NvbW1lbnQgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZSAnKScgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyAoKVxuICAgIHwgU29tZSAnKicgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBtYXliZV9lbmRfY29tbWVudCBzdHJtX19cbiAgICB8IFNvbWUgXyAtPiBTdHJlYW0uanVuayBzdHJtX187IGNvbW1lbnQgc3RybV9fXG4gICAgfCBfIC0+IHJhaXNlIFN0cmVhbS5GYWlsdXJlXG4gIGluXG4gIGZ1biBpbnB1dCAtPiBTdHJlYW0uZnJvbSAoZnVuIF9jb3VudCAtPiBuZXh0X3Rva2VuIGlucHV0KVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgRGFtaWVuIERvbGlnZXosIHByb2pldCBQYXJhLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NyBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5tb2R1bGUgdHlwZSBTZWVkZWRTID0gc2lnXG4gIGluY2x1ZGUgSGFzaHRibC5TZWVkZWRTXG4gIHZhbCBjbGVhbjogJ2EgdCAtPiB1bml0XG4gIHZhbCBzdGF0c19hbGl2ZTogJ2EgdCAtPiBIYXNodGJsLnN0YXRpc3RpY3NcbiAgICAoKiogc2FtZSBhcyB7IXN0YXRzfSBidXQgb25seSBjb3VudCB0aGUgYWxpdmUgYmluZGluZ3MgKilcbmVuZFxuXG5tb2R1bGUgdHlwZSBTID0gc2lnXG4gIGluY2x1ZGUgSGFzaHRibC5TXG4gIHZhbCBjbGVhbjogJ2EgdCAtPiB1bml0XG4gIHZhbCBzdGF0c19hbGl2ZTogJ2EgdCAtPiBIYXNodGJsLnN0YXRpc3RpY3NcbiAgICAoKiogc2FtZSBhcyB7IXN0YXRzfSBidXQgb25seSBjb3VudCB0aGUgYWxpdmUgYmluZGluZ3MgKilcbmVuZFxuXG5tb2R1bGUgR2VuSGFzaFRhYmxlID0gc3RydWN0XG5cbiAgdHlwZSBlcXVhbCA9XG4gIHwgRVRydWUgfCBFRmFsc2VcbiAgfCBFRGVhZCAoKiogdGhlIGdhcmJhZ2UgY29sbGVjdG9yIHJlY2xhaW1lZCB0aGUgZGF0YSAqKVxuXG4gIG1vZHVsZSBNYWtlU2VlZGVkKEg6IHNpZ1xuICAgIHR5cGUgdFxuICAgIHR5cGUgJ2EgY29udGFpbmVyXG4gICAgdmFsIGNyZWF0ZTogdCAtPiAnYSAtPiAnYSBjb250YWluZXJcbiAgICB2YWwgaGFzaDogaW50IC0+IHQgLT4gaW50XG4gICAgdmFsIGVxdWFsOiAnYSBjb250YWluZXIgLT4gdCAtPiBlcXVhbFxuICAgIHZhbCBnZXRfZGF0YTogJ2EgY29udGFpbmVyIC0+ICdhIG9wdGlvblxuICAgIHZhbCBnZXRfa2V5OiAnYSBjb250YWluZXIgLT4gdCBvcHRpb25cbiAgICB2YWwgc2V0X2tleV9kYXRhOiAnYSBjb250YWluZXIgLT4gdCAtPiAnYSAtPiB1bml0XG4gICAgdmFsIGNoZWNrX2tleTogJ2EgY29udGFpbmVyIC0+IGJvb2xcbiAgZW5kKSA6IFNlZWRlZFMgd2l0aCB0eXBlIGtleSA9IEgudFxuICA9IHN0cnVjdFxuXG4gICAgdHlwZSAnYSB0ID1cbiAgICAgIHsgbXV0YWJsZSBzaXplOiBpbnQ7ICAgICAgICAgICAgICAgICAgKCogbnVtYmVyIG9mIGVudHJpZXMgKilcbiAgICAgICAgbXV0YWJsZSBkYXRhOiAnYSBidWNrZXRsaXN0IGFycmF5OyAgKCogdGhlIGJ1Y2tldHMgKilcbiAgICAgICAgbXV0YWJsZSBzZWVkOiBpbnQ7ICAgICAgICAgICAgICAgICAgKCogZm9yIHJhbmRvbWl6YXRpb24gKilcbiAgICAgICAgaW5pdGlhbF9zaXplOiBpbnQ7ICAgICAgICAgICAgICAgICAgKCogaW5pdGlhbCBhcnJheSBzaXplICopXG4gICAgICB9XG5cbiAgICBhbmQgJ2EgYnVja2V0bGlzdCA9XG4gICAgfCBFbXB0eVxuICAgIHwgQ29ucyBvZiBpbnQgKCogaGFzaCBvZiB0aGUga2V5ICopICogJ2EgSC5jb250YWluZXIgKiAnYSBidWNrZXRsaXN0XG5cbiAgICAoKiogdGhlIGhhc2ggb2YgdGhlIGtleSBpcyBrZXB0IGluIG9yZGVyIHRvIHRlc3QgdGhlIGVxdWFsaXR5IG9mIHRoZSBoYXNoXG4gICAgICBiZWZvcmUgdGhlIGtleS4gU2FtZSByZWFzb24gYXMgZm9yIFdlYWsuTWFrZSAqKVxuXG4gICAgdHlwZSBrZXkgPSBILnRcblxuICAgIGxldCByZWMgcG93ZXJfMl9hYm92ZSB4IG4gPVxuICAgICAgaWYgeCA+PSBuIHRoZW4geFxuICAgICAgZWxzZSBpZiB4ICogMiA+IFN5cy5tYXhfYXJyYXlfbGVuZ3RoIHRoZW4geFxuICAgICAgZWxzZSBwb3dlcl8yX2Fib3ZlICh4ICogMikgblxuXG4gICAgbGV0IHBybmcgPSBsYXp5IChSYW5kb20uU3RhdGUubWFrZV9zZWxmX2luaXQoKSlcblxuICAgIGxldCBjcmVhdGUgPyhyYW5kb20gPSAoSGFzaHRibC5pc19yYW5kb21pemVkICgpKSkgaW5pdGlhbF9zaXplID1cbiAgICAgIGxldCBzID0gcG93ZXJfMl9hYm92ZSAxNiBpbml0aWFsX3NpemUgaW5cbiAgICAgIGxldCBzZWVkID0gaWYgcmFuZG9tIHRoZW4gUmFuZG9tLlN0YXRlLmJpdHMgKExhenkuZm9yY2UgcHJuZykgZWxzZSAwIGluXG4gICAgICB7IGluaXRpYWxfc2l6ZSA9IHM7IHNpemUgPSAwOyBzZWVkID0gc2VlZDsgZGF0YSA9IEFycmF5Lm1ha2UgcyBFbXB0eSB9XG5cbiAgICBsZXQgY2xlYXIgaCA9XG4gICAgICBoLnNpemUgPC0gMDtcbiAgICAgIGxldCBsZW4gPSBBcnJheS5sZW5ndGggaC5kYXRhIGluXG4gICAgICBmb3IgaSA9IDAgdG8gbGVuIC0gMSBkb1xuICAgICAgICBoLmRhdGEuKGkpIDwtIEVtcHR5XG4gICAgICBkb25lXG5cbiAgICBsZXQgcmVzZXQgaCA9XG4gICAgICBsZXQgbGVuID0gQXJyYXkubGVuZ3RoIGguZGF0YSBpblxuICAgICAgaWYgbGVuID0gaC5pbml0aWFsX3NpemUgdGhlblxuICAgICAgICBjbGVhciBoXG4gICAgICBlbHNlIGJlZ2luXG4gICAgICAgIGguc2l6ZSA8LSAwO1xuICAgICAgICBoLmRhdGEgPC0gQXJyYXkubWFrZSBoLmluaXRpYWxfc2l6ZSBFbXB0eVxuICAgICAgZW5kXG5cbiAgICBsZXQgY29weSBoID0geyBoIHdpdGggZGF0YSA9IEFycmF5LmNvcHkgaC5kYXRhIH1cblxuICAgIGxldCBrZXlfaW5kZXggaCBoa2V5ID1cbiAgICAgIGhrZXkgbGFuZCAoQXJyYXkubGVuZ3RoIGguZGF0YSAtIDEpXG5cbiAgICBsZXQgY2xlYW4gaCA9XG4gICAgICBsZXQgcmVjIGRvX2J1Y2tldCA9IGZ1bmN0aW9uXG4gICAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICAgIEVtcHR5XG4gICAgICAgIHwgQ29ucyhfLCBjLCByZXN0KSB3aGVuIG5vdCAoSC5jaGVja19rZXkgYykgLT5cbiAgICAgICAgICAgIGguc2l6ZSA8LSBoLnNpemUgLSAxO1xuICAgICAgICAgICAgZG9fYnVja2V0IHJlc3RcbiAgICAgICAgfCBDb25zKGhrZXksIGMsIHJlc3QpIC0+XG4gICAgICAgICAgICBDb25zKGhrZXksIGMsIGRvX2J1Y2tldCByZXN0KVxuICAgICAgaW5cbiAgICAgIGxldCBkID0gaC5kYXRhIGluXG4gICAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGQgLSAxIGRvXG4gICAgICAgIGQuKGkpIDwtIGRvX2J1Y2tldCBkLihpKVxuICAgICAgZG9uZVxuXG4gICAgKCoqIHJlc2l6ZSBpcyB0aGUgb25seSBmdW5jdGlvbiB0byBkbyB0aGUgYWN0dWFsIGNsZWFuaW5nIG9mIGRlYWQga2V5c1xuICAgICAgICAocmVtb3ZlIGRvZXMgaXQganVzdCBiZWNhdXNlIGl0IGNvdWxkKS5cblxuICAgICAgICBUaGUgZ29hbCBpcyB0bzpcblxuICAgICAgICAtIG5vdCByZXNpemUgaW5maW5pdGVseSB3aGVuIHRoZSBhY3R1YWwgbnVtYmVyIG9mIGFsaXZlIGtleXMgaXNcbiAgICAgICAgYm91bmRlZCBidXQga2V5cyBhcmUgY29udGludW91c2x5IGFkZGVkLiBUaGF0IHdvdWxkIGhhcHBlbiBpZlxuICAgICAgICB0aGlzIGZ1bmN0aW9uIGFsd2F5cyByZXNpemUuXG4gICAgICAgIC0gbm90IGNhbGwgdGhpcyBmdW5jdGlvbiBhZnRlciBlYWNoIGFkZGl0aW9uLCB0aGF0IHdvdWxkIGhhcHBlbiBpZiB0aGlzXG4gICAgICAgIGZ1bmN0aW9uIGRvbid0IHJlc2l6ZSBldmVuIHdoZW4gb25seSBvbmUga2V5IGlzIGRlYWQuXG5cbiAgICAgICAgU28gdGhlIGFsZ29yaXRobTpcbiAgICAgICAgLSBjbGVhbiB0aGUga2V5cyBiZWZvcmUgcmVzaXppbmdcbiAgICAgICAgLSBpZiB0aGUgbnVtYmVyIG9mIHJlbWFpbmluZyBrZXlzIGlzIGxlc3MgdGhhbiBoYWxmIHRoZSBzaXplIG9mIHRoZVxuICAgICAgICBhcnJheSwgZG9uJ3QgcmVzaXplLlxuICAgICAgICAtIGlmIGl0IGlzIG1vcmUsIHJlc2l6ZS5cblxuICAgICAgICBUaGUgc2Vjb25kIHByb2JsZW0gcmVtYWlucyBpZiB0aGUgdGFibGUgcmVhY2hlcyB7IVN5cy5tYXhfYXJyYXlfbGVuZ3RofS5cblxuICAgICopXG4gICAgbGV0IHJlc2l6ZSBoID1cbiAgICAgIGxldCBvZGF0YSA9IGguZGF0YSBpblxuICAgICAgbGV0IG9zaXplID0gQXJyYXkubGVuZ3RoIG9kYXRhIGluXG4gICAgICBsZXQgbnNpemUgPSBvc2l6ZSAqIDIgaW5cbiAgICAgIGNsZWFuIGg7XG4gICAgICBpZiBuc2l6ZSA8IFN5cy5tYXhfYXJyYXlfbGVuZ3RoICYmIGguc2l6ZSA+PSBvc2l6ZSBsc3IgMSB0aGVuIGJlZ2luXG4gICAgICAgIGxldCBuZGF0YSA9IEFycmF5Lm1ha2UgbnNpemUgRW1wdHkgaW5cbiAgICAgICAgaC5kYXRhIDwtIG5kYXRhOyAgICAgICAoKiBzbyB0aGF0IGtleV9pbmRleCBzZWVzIHRoZSBuZXcgYnVja2V0IGNvdW50ICopXG4gICAgICAgIGxldCByZWMgaW5zZXJ0X2J1Y2tldCA9IGZ1bmN0aW9uXG4gICAgICAgICAgICBFbXB0eSAtPiAoKVxuICAgICAgICAgIHwgQ29ucyhoa2V5LCBkYXRhLCByZXN0KSAtPlxuICAgICAgICAgICAgICBpbnNlcnRfYnVja2V0IHJlc3Q7ICgqIHByZXNlcnZlIG9yaWdpbmFsIG9yZGVyIG9mIGVsZW1lbnRzICopXG4gICAgICAgICAgICAgIGxldCBuaWR4ID0ga2V5X2luZGV4IGggaGtleSBpblxuICAgICAgICAgICAgICBuZGF0YS4obmlkeCkgPC0gQ29ucyhoa2V5LCBkYXRhLCBuZGF0YS4obmlkeCkpIGluXG4gICAgICAgIGZvciBpID0gMCB0byBvc2l6ZSAtIDEgZG9cbiAgICAgICAgICBpbnNlcnRfYnVja2V0IG9kYXRhLihpKVxuICAgICAgICBkb25lXG4gICAgICBlbmRcblxuICAgIGxldCBhZGQgaCBrZXkgaW5mbyA9XG4gICAgICBsZXQgaGtleSA9IEguaGFzaCBoLnNlZWQga2V5IGluXG4gICAgICBsZXQgaSA9IGtleV9pbmRleCBoIGhrZXkgaW5cbiAgICAgIGxldCBjb250YWluZXIgPSBILmNyZWF0ZSBrZXkgaW5mbyBpblxuICAgICAgbGV0IGJ1Y2tldCA9IENvbnMoaGtleSwgY29udGFpbmVyLCBoLmRhdGEuKGkpKSBpblxuICAgICAgaC5kYXRhLihpKSA8LSBidWNrZXQ7XG4gICAgICBoLnNpemUgPC0gaC5zaXplICsgMTtcbiAgICAgIGlmIGguc2l6ZSA+IEFycmF5Lmxlbmd0aCBoLmRhdGEgbHNsIDEgdGhlbiByZXNpemUgaFxuXG4gICAgbGV0IHJlbW92ZSBoIGtleSA9XG4gICAgICBsZXQgaGtleSA9IEguaGFzaCBoLnNlZWQga2V5IGluXG4gICAgICBsZXQgcmVjIHJlbW92ZV9idWNrZXQgPSBmdW5jdGlvblxuICAgICAgICB8IEVtcHR5IC0+IEVtcHR5XG4gICAgICAgIHwgQ29ucyhoaywgYywgbmV4dCkgd2hlbiBoa2V5ID0gaGsgLT5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIEguZXF1YWwgYyBrZXkgd2l0aFxuICAgICAgICAgICAgfCBFVHJ1ZSAtPiBoLnNpemUgPC0gaC5zaXplIC0gMTsgbmV4dFxuICAgICAgICAgICAgfCBFRmFsc2UgLT4gQ29ucyhoaywgYywgcmVtb3ZlX2J1Y2tldCBuZXh0KVxuICAgICAgICAgICAgfCBFRGVhZCAtPlxuICAgICAgICAgICAgICAgICgqIFRoZSBkZWFkIGtleSBpcyBhdXRvbWF0aWNhbGx5IHJlbW92ZWQuIEl0IGlzIGFjY2VwdGFibGVcbiAgICAgICAgICAgICAgICAgICAgZm9yIHRoaXMgZnVuY3Rpb24gc2luY2UgaXQgYWxyZWFkeSByZW1vdmVzIGEgYmluZGluZyAqKVxuICAgICAgICAgICAgICAgIGguc2l6ZSA8LSBoLnNpemUgLSAxO1xuICAgICAgICAgICAgICAgIHJlbW92ZV9idWNrZXQgbmV4dFxuICAgICAgICAgICAgZW5kXG4gICAgICAgIHwgQ29ucyhoayxjLG5leHQpIC0+IENvbnMoaGssIGMsIHJlbW92ZV9idWNrZXQgbmV4dCkgaW5cbiAgICAgIGxldCBpID0ga2V5X2luZGV4IGggaGtleSBpblxuICAgICAgaC5kYXRhLihpKSA8LSByZW1vdmVfYnVja2V0IGguZGF0YS4oaSlcblxuICAgICgqKiB7IWZpbmR9IGRvbid0IHJlbW92ZSBkZWFkIGtleXMgYmVjYXVzZSBpdCB3b3VsZCBiZSBzdXJwcmlzaW5nIGZvclxuICAgICAgICB0aGUgdXNlciB0aGF0IGEgcmVhZC1vbmx5IGZ1bmN0aW9uIG11dGF0ZXMgdGhlIHN0YXRlIChlZy4gY29uY3VycmVudFxuICAgICAgICBhY2Nlc3MpLiBTYW1lIGZvciB7IWl0ZXJ9LCB7IWZvbGR9LCB7IW1lbX0uXG4gICAgKilcbiAgICBsZXQgcmVjIGZpbmRfcmVjIGtleSBoa2V5ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgQ29ucyhoaywgYywgcmVzdCkgd2hlbiBoa2V5ID0gaGsgIC0+XG4gICAgICAgICAgYmVnaW4gbWF0Y2ggSC5lcXVhbCBjIGtleSB3aXRoXG4gICAgICAgICAgfCBFVHJ1ZSAtPlxuICAgICAgICAgICAgICBiZWdpbiBtYXRjaCBILmdldF9kYXRhIGMgd2l0aFxuICAgICAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgICAgICAgICgqIFRoaXMgY2FzZSBpcyBub3QgaW1wb3NzaWJsZSBiZWNhdXNlIHRoZSBnYyBjYW4gcnVuIGJldHdlZW5cbiAgICAgICAgICAgICAgICAgICAgICBILmVxdWFsIGFuZCBILmdldF9kYXRhICopXG4gICAgICAgICAgICAgICAgICBmaW5kX3JlYyBrZXkgaGtleSByZXN0XG4gICAgICAgICAgICAgIHwgU29tZSBkIC0+IGRcbiAgICAgICAgICAgICAgZW5kXG4gICAgICAgICAgfCBFRmFsc2UgLT4gZmluZF9yZWMga2V5IGhrZXkgcmVzdFxuICAgICAgICAgIHwgRURlYWQgLT5cbiAgICAgICAgICAgICAgZmluZF9yZWMga2V5IGhrZXkgcmVzdFxuICAgICAgICAgIGVuZFxuICAgICAgfCBDb25zKF8sIF8sIHJlc3QpIC0+XG4gICAgICAgICAgZmluZF9yZWMga2V5IGhrZXkgcmVzdFxuXG4gICAgbGV0IGZpbmQgaCBrZXkgPVxuICAgICAgbGV0IGhrZXkgPSBILmhhc2ggaC5zZWVkIGtleSBpblxuICAgICAgKCogVE9ETyBpbmxpbmUgMyBpdGVyYXRpb25zICopXG4gICAgICBmaW5kX3JlYyBrZXkgaGtleSAoaC5kYXRhLihrZXlfaW5kZXggaCBoa2V5KSlcblxuICAgIGxldCByZWMgZmluZF9yZWNfb3B0IGtleSBoa2V5ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICBOb25lXG4gICAgICB8IENvbnMoaGssIGMsIHJlc3QpIHdoZW4gaGtleSA9IGhrICAtPlxuICAgICAgICAgIGJlZ2luIG1hdGNoIEguZXF1YWwgYyBrZXkgd2l0aFxuICAgICAgICAgIHwgRVRydWUgLT5cbiAgICAgICAgICAgICAgYmVnaW4gbWF0Y2ggSC5nZXRfZGF0YSBjIHdpdGhcbiAgICAgICAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgICAgICAgICAoKiBUaGlzIGNhc2UgaXMgbm90IGltcG9zc2libGUgYmVjYXVzZSB0aGUgZ2MgY2FuIHJ1biBiZXR3ZWVuXG4gICAgICAgICAgICAgICAgICAgICAgSC5lcXVhbCBhbmQgSC5nZXRfZGF0YSAqKVxuICAgICAgICAgICAgICAgICAgZmluZF9yZWNfb3B0IGtleSBoa2V5IHJlc3RcbiAgICAgICAgICAgICAgfCBTb21lIF8gYXMgZCAtPiBkXG4gICAgICAgICAgICAgIGVuZFxuICAgICAgICAgIHwgRUZhbHNlIC0+IGZpbmRfcmVjX29wdCBrZXkgaGtleSByZXN0XG4gICAgICAgICAgfCBFRGVhZCAtPlxuICAgICAgICAgICAgICBmaW5kX3JlY19vcHQga2V5IGhrZXkgcmVzdFxuICAgICAgICAgIGVuZFxuICAgICAgfCBDb25zKF8sIF8sIHJlc3QpIC0+XG4gICAgICAgICAgZmluZF9yZWNfb3B0IGtleSBoa2V5IHJlc3RcblxuICAgIGxldCBmaW5kX29wdCBoIGtleSA9XG4gICAgICBsZXQgaGtleSA9IEguaGFzaCBoLnNlZWQga2V5IGluXG4gICAgICAoKiBUT0RPIGlubGluZSAzIGl0ZXJhdGlvbnMgKilcbiAgICAgIGZpbmRfcmVjX29wdCBrZXkgaGtleSAoaC5kYXRhLihrZXlfaW5kZXggaCBoa2V5KSlcblxuICAgIGxldCBmaW5kX2FsbCBoIGtleSA9XG4gICAgICBsZXQgaGtleSA9IEguaGFzaCBoLnNlZWQga2V5IGluXG4gICAgICBsZXQgcmVjIGZpbmRfaW5fYnVja2V0ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT4gW11cbiAgICAgIHwgQ29ucyhoaywgYywgcmVzdCkgd2hlbiBoa2V5ID0gaGsgIC0+XG4gICAgICAgICAgYmVnaW4gbWF0Y2ggSC5lcXVhbCBjIGtleSB3aXRoXG4gICAgICAgICAgfCBFVHJ1ZSAtPiBiZWdpbiBtYXRjaCBILmdldF9kYXRhIGMgd2l0aFxuICAgICAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgICAgICAgIGZpbmRfaW5fYnVja2V0IHJlc3RcbiAgICAgICAgICAgICAgfCBTb21lIGQgLT4gZDo6ZmluZF9pbl9idWNrZXQgcmVzdFxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgfCBFRmFsc2UgLT4gZmluZF9pbl9idWNrZXQgcmVzdFxuICAgICAgICAgIHwgRURlYWQgLT5cbiAgICAgICAgICAgICAgZmluZF9pbl9idWNrZXQgcmVzdFxuICAgICAgICAgIGVuZFxuICAgICAgfCBDb25zKF8sIF8sIHJlc3QpIC0+XG4gICAgICAgICAgZmluZF9pbl9idWNrZXQgcmVzdCBpblxuICAgICAgZmluZF9pbl9idWNrZXQgaC5kYXRhLihrZXlfaW5kZXggaCBoa2V5KVxuXG5cbiAgICBsZXQgcmVwbGFjZSBoIGtleSBpbmZvID1cbiAgICAgIGxldCBoa2V5ID0gSC5oYXNoIGguc2VlZCBrZXkgaW5cbiAgICAgIGxldCByZWMgcmVwbGFjZV9idWNrZXQgPSBmdW5jdGlvblxuICAgICAgICB8IEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgICB8IENvbnMoaGssIGMsIG5leHQpIHdoZW4gaGtleSA9IGhrIC0+XG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBILmVxdWFsIGMga2V5IHdpdGhcbiAgICAgICAgICAgIHwgRVRydWUgLT4gSC5zZXRfa2V5X2RhdGEgYyBrZXkgaW5mb1xuICAgICAgICAgICAgfCBFRmFsc2UgfCBFRGVhZCAtPiByZXBsYWNlX2J1Y2tldCBuZXh0XG4gICAgICAgICAgICBlbmRcbiAgICAgICAgfCBDb25zKF8sXyxuZXh0KSAtPiByZXBsYWNlX2J1Y2tldCBuZXh0XG4gICAgICBpblxuICAgICAgbGV0IGkgPSBrZXlfaW5kZXggaCBoa2V5IGluXG4gICAgICBsZXQgbCA9IGguZGF0YS4oaSkgaW5cbiAgICAgIHRyeVxuICAgICAgICByZXBsYWNlX2J1Y2tldCBsXG4gICAgICB3aXRoIE5vdF9mb3VuZCAtPlxuICAgICAgICBsZXQgY29udGFpbmVyID0gSC5jcmVhdGUga2V5IGluZm8gaW5cbiAgICAgICAgaC5kYXRhLihpKSA8LSBDb25zKGhrZXksIGNvbnRhaW5lciwgbCk7XG4gICAgICAgIGguc2l6ZSA8LSBoLnNpemUgKyAxO1xuICAgICAgICBpZiBoLnNpemUgPiBBcnJheS5sZW5ndGggaC5kYXRhIGxzbCAxIHRoZW4gcmVzaXplIGhcblxuICAgIGxldCBtZW0gaCBrZXkgPVxuICAgICAgbGV0IGhrZXkgPSBILmhhc2ggaC5zZWVkIGtleSBpblxuICAgICAgbGV0IHJlYyBtZW1faW5fYnVja2V0ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICBmYWxzZVxuICAgICAgfCBDb25zKGhrLCBjLCByZXN0KSB3aGVuIGhrID0gaGtleSAtPlxuICAgICAgICAgIGJlZ2luIG1hdGNoIEguZXF1YWwgYyBrZXkgd2l0aFxuICAgICAgICAgIHwgRVRydWUgLT4gdHJ1ZVxuICAgICAgICAgIHwgRUZhbHNlIHwgRURlYWQgLT4gbWVtX2luX2J1Y2tldCByZXN0XG4gICAgICAgICAgZW5kXG4gICAgICB8IENvbnMoX2hrLCBfYywgcmVzdCkgLT4gbWVtX2luX2J1Y2tldCByZXN0IGluXG4gICAgICBtZW1faW5fYnVja2V0IGguZGF0YS4oa2V5X2luZGV4IGggaGtleSlcblxuICAgIGxldCBpdGVyIGYgaCA9XG4gICAgICBsZXQgcmVjIGRvX2J1Y2tldCA9IGZ1bmN0aW9uXG4gICAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICAgICgpXG4gICAgICAgIHwgQ29ucyhfLCBjLCByZXN0KSAtPlxuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggSC5nZXRfa2V5IGMsIEguZ2V0X2RhdGEgYyB3aXRoXG4gICAgICAgICAgICB8IE5vbmUsIF8gfCBfLCBOb25lIC0+ICgpXG4gICAgICAgICAgICB8IFNvbWUgaywgU29tZSBkIC0+IGYgayBkXG4gICAgICAgICAgICBlbmQ7IGRvX2J1Y2tldCByZXN0IGluXG4gICAgICBsZXQgZCA9IGguZGF0YSBpblxuICAgICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCBkIC0gMSBkb1xuICAgICAgICBkb19idWNrZXQgZC4oaSlcbiAgICAgIGRvbmVcblxuICAgIGxldCBmb2xkIGYgaCBpbml0ID1cbiAgICAgIGxldCByZWMgZG9fYnVja2V0IGIgYWNjdSA9XG4gICAgICAgIG1hdGNoIGIgd2l0aFxuICAgICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgICBhY2N1XG4gICAgICAgIHwgQ29ucyhfLCBjLCByZXN0KSAtPlxuICAgICAgICAgICAgbGV0IGFjY3UgPSBiZWdpbiBtYXRjaCBILmdldF9rZXkgYywgSC5nZXRfZGF0YSBjIHdpdGhcbiAgICAgICAgICAgICAgfCBOb25lLCBfIHwgXywgTm9uZSAtPiBhY2N1XG4gICAgICAgICAgICAgIHwgU29tZSBrLCBTb21lIGQgLT4gZiBrIGQgYWNjdVxuICAgICAgICAgICAgZW5kIGluXG4gICAgICAgICAgICBkb19idWNrZXQgcmVzdCBhY2N1ICBpblxuICAgICAgbGV0IGQgPSBoLmRhdGEgaW5cbiAgICAgIGxldCBhY2N1ID0gcmVmIGluaXQgaW5cbiAgICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggZCAtIDEgZG9cbiAgICAgICAgYWNjdSA6PSBkb19idWNrZXQgZC4oaSkgIWFjY3VcbiAgICAgIGRvbmU7XG4gICAgICAhYWNjdVxuXG4gICAgbGV0IGZpbHRlcl9tYXBfaW5wbGFjZSBmIGggPVxuICAgICAgbGV0IHJlYyBkb19idWNrZXQgPSBmdW5jdGlvblxuICAgICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgICBFbXB0eVxuICAgICAgICB8IENvbnMoaGssIGMsIHJlc3QpIC0+XG4gICAgICAgICAgICBtYXRjaCBILmdldF9rZXkgYywgSC5nZXRfZGF0YSBjIHdpdGhcbiAgICAgICAgICAgIHwgTm9uZSwgXyB8IF8sIE5vbmUgLT5cbiAgICAgICAgICAgICAgICBkb19idWNrZXQgcmVzdFxuICAgICAgICAgICAgfCBTb21lIGssIFNvbWUgZCAtPlxuICAgICAgICAgICAgICAgIG1hdGNoIGYgayBkIHdpdGhcbiAgICAgICAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgICAgICAgICAgZG9fYnVja2V0IHJlc3RcbiAgICAgICAgICAgICAgICB8IFNvbWUgbmV3X2QgLT5cbiAgICAgICAgICAgICAgICAgICAgSC5zZXRfa2V5X2RhdGEgYyBrIG5ld19kO1xuICAgICAgICAgICAgICAgICAgICBDb25zKGhrLCBjLCBkb19idWNrZXQgcmVzdClcbiAgICAgIGluXG4gICAgICBsZXQgZCA9IGguZGF0YSBpblxuICAgICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCBkIC0gMSBkb1xuICAgICAgICBkLihpKSA8LSBkb19idWNrZXQgZC4oaSlcbiAgICAgIGRvbmVcblxuICAgIGxldCBsZW5ndGggaCA9IGguc2l6ZVxuXG4gICAgbGV0IHJlYyBidWNrZXRfbGVuZ3RoIGFjY3UgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiBhY2N1XG4gICAgICB8IENvbnMoXywgXywgcmVzdCkgLT4gYnVja2V0X2xlbmd0aCAoYWNjdSArIDEpIHJlc3RcblxuICAgIGxldCBzdGF0cyBoID1cbiAgICAgIGxldCBtYmwgPVxuICAgICAgICBBcnJheS5mb2xkX2xlZnQgKGZ1biBtIGIgLT4gbWF4IG0gKGJ1Y2tldF9sZW5ndGggMCBiKSkgMCBoLmRhdGEgaW5cbiAgICAgIGxldCBoaXN0byA9IEFycmF5Lm1ha2UgKG1ibCArIDEpIDAgaW5cbiAgICAgIEFycmF5Lml0ZXJcbiAgICAgICAgKGZ1biBiIC0+XG4gICAgICAgICAgIGxldCBsID0gYnVja2V0X2xlbmd0aCAwIGIgaW5cbiAgICAgICAgICAgaGlzdG8uKGwpIDwtIGhpc3RvLihsKSArIDEpXG4gICAgICAgIGguZGF0YTtcbiAgICAgIHsgSGFzaHRibC5udW1fYmluZGluZ3MgPSBoLnNpemU7XG4gICAgICAgIG51bV9idWNrZXRzID0gQXJyYXkubGVuZ3RoIGguZGF0YTtcbiAgICAgICAgbWF4X2J1Y2tldF9sZW5ndGggPSBtYmw7XG4gICAgICAgIGJ1Y2tldF9oaXN0b2dyYW0gPSBoaXN0byB9XG5cbiAgICBsZXQgcmVjIGJ1Y2tldF9sZW5ndGhfYWxpdmUgYWNjdSA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+IGFjY3VcbiAgICAgIHwgQ29ucyhfLCBjLCByZXN0KSB3aGVuIEguY2hlY2tfa2V5IGMgLT5cbiAgICAgICAgICBidWNrZXRfbGVuZ3RoX2FsaXZlIChhY2N1ICsgMSkgcmVzdFxuICAgICAgfCBDb25zKF8sIF8sIHJlc3QpIC0+IGJ1Y2tldF9sZW5ndGhfYWxpdmUgYWNjdSByZXN0XG5cbiAgICBsZXQgc3RhdHNfYWxpdmUgaCA9XG4gICAgICBsZXQgc2l6ZSA9IHJlZiAwIGluXG4gICAgICBsZXQgbWJsID1cbiAgICAgICAgQXJyYXkuZm9sZF9sZWZ0IChmdW4gbSBiIC0+IG1heCBtIChidWNrZXRfbGVuZ3RoX2FsaXZlIDAgYikpIDAgaC5kYXRhIGluXG4gICAgICBsZXQgaGlzdG8gPSBBcnJheS5tYWtlIChtYmwgKyAxKSAwIGluXG4gICAgICBBcnJheS5pdGVyXG4gICAgICAgIChmdW4gYiAtPlxuICAgICAgICAgICBsZXQgbCA9IGJ1Y2tldF9sZW5ndGhfYWxpdmUgMCBiIGluXG4gICAgICAgICAgIHNpemUgOj0gIXNpemUgKyBsO1xuICAgICAgICAgICBoaXN0by4obCkgPC0gaGlzdG8uKGwpICsgMSlcbiAgICAgICAgaC5kYXRhO1xuICAgICAgeyBIYXNodGJsLm51bV9iaW5kaW5ncyA9ICFzaXplO1xuICAgICAgICBudW1fYnVja2V0cyA9IEFycmF5Lmxlbmd0aCBoLmRhdGE7XG4gICAgICAgIG1heF9idWNrZXRfbGVuZ3RoID0gbWJsO1xuICAgICAgICBidWNrZXRfaGlzdG9ncmFtID0gaGlzdG8gfVxuXG4gICAgbGV0IHRvX3NlcSB0YmwgPVxuICAgICAgKCogY2FwdHVyZSBjdXJyZW50IGFycmF5LCBzbyB0aGF0IGV2ZW4gaWYgdGhlIHRhYmxlIGlzIHJlc2l6ZWQgd2VcbiAgICAgICAgIGtlZXAgaXRlcmF0aW5nIG9uIHRoZSBzYW1lIGFycmF5ICopXG4gICAgICBsZXQgdGJsX2RhdGEgPSB0YmwuZGF0YSBpblxuICAgICAgKCogc3RhdGU6IGluZGV4ICogbmV4dCBidWNrZXQgdG8gdHJhdmVyc2UgKilcbiAgICAgIGxldCByZWMgYXV4IGkgYnVjayAoKSA9IG1hdGNoIGJ1Y2sgd2l0aFxuICAgICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgICBpZiBpID0gQXJyYXkubGVuZ3RoIHRibF9kYXRhXG4gICAgICAgICAgICB0aGVuIFNlcS5OaWxcbiAgICAgICAgICAgIGVsc2UgYXV4KGkrMSkgdGJsX2RhdGEuKGkpICgpXG4gICAgICAgIHwgQ29ucyAoXywgYywgbmV4dCkgLT5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIEguZ2V0X2tleSBjLCBILmdldF9kYXRhIGMgd2l0aFxuICAgICAgICAgICAgICB8IE5vbmUsIF8gfCBfLCBOb25lIC0+IGF1eCBpIG5leHQgKClcbiAgICAgICAgICAgICAgfCBTb21lIGtleSwgU29tZSBkYXRhIC0+XG4gICAgICAgICAgICAgICAgICBTZXEuQ29ucyAoKGtleSwgZGF0YSksIGF1eCBpIG5leHQpXG4gICAgICAgICAgICBlbmRcbiAgICAgIGluXG4gICAgICBhdXggMCBFbXB0eVxuXG4gICAgbGV0IHRvX3NlcV9rZXlzIG0gPSBTZXEubWFwIGZzdCAodG9fc2VxIG0pXG5cbiAgICBsZXQgdG9fc2VxX3ZhbHVlcyBtID0gU2VxLm1hcCBzbmQgKHRvX3NlcSBtKVxuXG4gICAgbGV0IGFkZF9zZXEgdGJsIGkgPVxuICAgICAgU2VxLml0ZXIgKGZ1biAoayx2KSAtPiBhZGQgdGJsIGsgdikgaVxuXG4gICAgbGV0IHJlcGxhY2Vfc2VxIHRibCBpID1cbiAgICAgIFNlcS5pdGVyIChmdW4gKGssdikgLT4gcmVwbGFjZSB0YmwgayB2KSBpXG5cbiAgICBsZXQgb2Zfc2VxIGkgPVxuICAgICAgbGV0IHRibCA9IGNyZWF0ZSAxNiBpblxuICAgICAgcmVwbGFjZV9zZXEgdGJsIGk7XG4gICAgICB0YmxcblxuICBlbmRcbmVuZFxuXG5tb2R1bGUgT2JqRXBoID0gT2JqLkVwaGVtZXJvblxuXG5sZXQgX29ial9vcHQgOiBPYmoudCBvcHRpb24gLT4gJ2Egb3B0aW9uID0gZnVuIHggLT5cbiAgbWF0Y2ggeCB3aXRoXG4gIHwgTm9uZSAtPiB4XG4gIHwgU29tZSB2IC0+IFNvbWUgKE9iai5vYmogdilcblxuKCoqIFRoZSBwcmV2aW91cyBmdW5jdGlvbiBpcyB0eXBlZCBzbyB0aGlzIG9uZSBpcyBhbHNvIGNvcnJlY3QgKilcbmxldCBvYmpfb3B0IDogT2JqLnQgb3B0aW9uIC0+ICdhIG9wdGlvbiA9IGZ1biB4IC0+IE9iai5tYWdpYyB4XG5cblxubW9kdWxlIEsxID0gc3RydWN0XG4gIHR5cGUgKCdrLCdkKSB0ID0gT2JqRXBoLnRcblxuICBsZXQgY3JlYXRlICgpIDogKCdrLCdkKSB0ID0gT2JqRXBoLmNyZWF0ZSAxXG5cbiAgbGV0IGdldF9rZXkgKHQ6KCdrLCdkKSB0KSA6ICdrIG9wdGlvbiA9IG9ial9vcHQgKE9iakVwaC5nZXRfa2V5IHQgMClcbiAgbGV0IGdldF9rZXlfY29weSAodDooJ2ssJ2QpIHQpIDogJ2sgb3B0aW9uID0gb2JqX29wdCAoT2JqRXBoLmdldF9rZXlfY29weSB0IDApXG4gIGxldCBzZXRfa2V5ICh0OignaywnZCkgdCkgKGs6J2spIDogdW5pdCA9IE9iakVwaC5zZXRfa2V5IHQgMCAoT2JqLnJlcHIgaylcbiAgbGV0IHVuc2V0X2tleSAodDooJ2ssJ2QpIHQpIDogdW5pdCA9IE9iakVwaC51bnNldF9rZXkgdCAwXG4gIGxldCBjaGVja19rZXkgKHQ6KCdrLCdkKSB0KSA6IGJvb2wgPSBPYmpFcGguY2hlY2tfa2V5IHQgMFxuXG4gIGxldCBibGl0X2tleSAodDE6KCdrLCdkKSB0KSAodDI6KCdrLCdkKSB0KTogdW5pdCA9XG4gICAgT2JqRXBoLmJsaXRfa2V5IHQxIDAgdDIgMCAxXG5cbiAgbGV0IGdldF9kYXRhICh0OignaywnZCkgdCkgOiAnZCBvcHRpb24gPSBvYmpfb3B0IChPYmpFcGguZ2V0X2RhdGEgdClcbiAgbGV0IGdldF9kYXRhX2NvcHkgKHQ6KCdrLCdkKSB0KSA6ICdkIG9wdGlvbiA9IG9ial9vcHQgKE9iakVwaC5nZXRfZGF0YV9jb3B5IHQpXG4gIGxldCBzZXRfZGF0YSAodDooJ2ssJ2QpIHQpIChkOidkKSA6IHVuaXQgPSBPYmpFcGguc2V0X2RhdGEgdCAoT2JqLnJlcHIgZClcbiAgbGV0IHVuc2V0X2RhdGEgKHQ6KCdrLCdkKSB0KSA6IHVuaXQgPSBPYmpFcGgudW5zZXRfZGF0YSB0XG4gIGxldCBjaGVja19kYXRhICh0OignaywnZCkgdCkgOiBib29sID0gT2JqRXBoLmNoZWNrX2RhdGEgdFxuICBsZXQgYmxpdF9kYXRhICh0MTooXywnZCkgdCkgKHQyOihfLCdkKSB0KSA6IHVuaXQgPSBPYmpFcGguYmxpdF9kYXRhIHQxIHQyXG5cbiAgbW9kdWxlIE1ha2VTZWVkZWQgKEg6SGFzaHRibC5TZWVkZWRIYXNoZWRUeXBlKSA9XG4gICAgR2VuSGFzaFRhYmxlLk1ha2VTZWVkZWQoc3RydWN0XG4gICAgICB0eXBlICdhIGNvbnRhaW5lciA9IChILnQsJ2EpIHRcbiAgICAgIHR5cGUgdCA9IEgudFxuICAgICAgbGV0IGNyZWF0ZSBrIGQgPVxuICAgICAgICBsZXQgYyA9IGNyZWF0ZSAoKSBpblxuICAgICAgICBzZXRfZGF0YSBjIGQ7XG4gICAgICAgIHNldF9rZXkgYyBrO1xuICAgICAgICBjXG4gICAgICBsZXQgaGFzaCA9IEguaGFzaFxuICAgICAgbGV0IGVxdWFsIGMgayA9XG4gICAgICAgICgqIHshZ2V0X2tleV9jb3B5fSBpcyBub3QgdXNlZCBiZWNhdXNlIHRoZSBlcXVhbGl0eSBvZiB0aGUgdXNlciBjYW4gYmVcbiAgICAgICAgICAgIHRoZSBwaHlzaWNhbCBlcXVhbGl0eSAqKVxuICAgICAgICBtYXRjaCBnZXRfa2V5IGMgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gR2VuSGFzaFRhYmxlLkVEZWFkXG4gICAgICAgIHwgU29tZSBrJyAtPlxuICAgICAgICAgICAgaWYgSC5lcXVhbCBrIGsnIHRoZW4gR2VuSGFzaFRhYmxlLkVUcnVlIGVsc2UgR2VuSGFzaFRhYmxlLkVGYWxzZVxuICAgICAgbGV0IGdldF9kYXRhID0gZ2V0X2RhdGFcbiAgICAgIGxldCBnZXRfa2V5ID0gZ2V0X2tleVxuICAgICAgbGV0IHNldF9rZXlfZGF0YSBjIGsgZCA9XG4gICAgICAgIHVuc2V0X2RhdGEgYztcbiAgICAgICAgc2V0X2tleSBjIGs7XG4gICAgICAgIHNldF9kYXRhIGMgZFxuICAgICAgbGV0IGNoZWNrX2tleSA9IGNoZWNrX2tleVxuICAgIGVuZClcblxuICBtb2R1bGUgTWFrZShIOiBIYXNodGJsLkhhc2hlZFR5cGUpOiAoUyB3aXRoIHR5cGUga2V5ID0gSC50KSA9XG4gIHN0cnVjdFxuICAgIGluY2x1ZGUgTWFrZVNlZWRlZChzdHJ1Y3RcbiAgICAgICAgdHlwZSB0ID0gSC50XG4gICAgICAgIGxldCBlcXVhbCA9IEguZXF1YWxcbiAgICAgICAgbGV0IGhhc2ggKF9zZWVkOiBpbnQpIHggPSBILmhhc2ggeFxuICAgICAgZW5kKVxuICAgIGxldCBjcmVhdGUgc3ogPSBjcmVhdGUgfnJhbmRvbTpmYWxzZSBzelxuICAgIGxldCBvZl9zZXEgaSA9XG4gICAgICBsZXQgdGJsID0gY3JlYXRlIDE2IGluXG4gICAgICByZXBsYWNlX3NlcSB0YmwgaTtcbiAgICAgIHRibFxuICBlbmRcblxuZW5kXG5cbm1vZHVsZSBLMiA9IHN0cnVjdFxuICB0eXBlICgnazEsICdrMiwgJ2QpIHQgPSBPYmpFcGgudFxuXG4gIGxldCBjcmVhdGUgKCkgOiAoJ2sxLCdrMiwnZCkgdCA9IE9iakVwaC5jcmVhdGUgMlxuXG4gIGxldCBnZXRfa2V5MSAodDooJ2sxLCdrMiwnZCkgdCkgOiAnazEgb3B0aW9uID0gb2JqX29wdCAoT2JqRXBoLmdldF9rZXkgdCAwKVxuICBsZXQgZ2V0X2tleTFfY29weSAodDooJ2sxLCdrMiwnZCkgdCkgOiAnazEgb3B0aW9uID1cbiAgICBvYmpfb3B0IChPYmpFcGguZ2V0X2tleV9jb3B5IHQgMClcbiAgbGV0IHNldF9rZXkxICh0OignazEsJ2syLCdkKSB0KSAoazonazEpIDogdW5pdCA9XG4gICAgT2JqRXBoLnNldF9rZXkgdCAwIChPYmoucmVwciBrKVxuICBsZXQgdW5zZXRfa2V5MSAodDooJ2sxLCdrMiwnZCkgdCkgOiB1bml0ID0gT2JqRXBoLnVuc2V0X2tleSB0IDBcbiAgbGV0IGNoZWNrX2tleTEgKHQ6KCdrMSwnazIsJ2QpIHQpIDogYm9vbCA9IE9iakVwaC5jaGVja19rZXkgdCAwXG5cbiAgbGV0IGdldF9rZXkyICh0OignazEsJ2syLCdkKSB0KSA6ICdrMiBvcHRpb24gPSBvYmpfb3B0IChPYmpFcGguZ2V0X2tleSB0IDEpXG4gIGxldCBnZXRfa2V5Ml9jb3B5ICh0OignazEsJ2syLCdkKSB0KSA6ICdrMiBvcHRpb24gPVxuICAgIG9ial9vcHQgKE9iakVwaC5nZXRfa2V5X2NvcHkgdCAxKVxuICBsZXQgc2V0X2tleTIgKHQ6KCdrMSwnazIsJ2QpIHQpIChrOidrMikgOiB1bml0ID1cbiAgICBPYmpFcGguc2V0X2tleSB0IDEgKE9iai5yZXByIGspXG4gIGxldCB1bnNldF9rZXkyICh0OignazEsJ2syLCdkKSB0KSA6IHVuaXQgPSBPYmpFcGgudW5zZXRfa2V5IHQgMVxuICBsZXQgY2hlY2tfa2V5MiAodDooJ2sxLCdrMiwnZCkgdCkgOiBib29sID0gT2JqRXBoLmNoZWNrX2tleSB0IDFcblxuXG4gIGxldCBibGl0X2tleTEgKHQxOignazEsXyxfKSB0KSAodDI6KCdrMSxfLF8pIHQpIDogdW5pdCA9XG4gICAgT2JqRXBoLmJsaXRfa2V5IHQxIDAgdDIgMCAxXG4gIGxldCBibGl0X2tleTIgKHQxOihfLCdrMixfKSB0KSAodDI6KF8sJ2syLF8pIHQpIDogdW5pdCA9XG4gICAgT2JqRXBoLmJsaXRfa2V5IHQxIDEgdDIgMSAxXG4gIGxldCBibGl0X2tleTEyICh0MTooJ2sxLCdrMixfKSB0KSAodDI6KCdrMSwnazIsXykgdCkgOiB1bml0ID1cbiAgICBPYmpFcGguYmxpdF9rZXkgdDEgMCB0MiAwIDJcblxuICBsZXQgZ2V0X2RhdGEgKHQ6KCdrMSwnazIsJ2QpIHQpIDogJ2Qgb3B0aW9uID0gb2JqX29wdCAoT2JqRXBoLmdldF9kYXRhIHQpXG4gIGxldCBnZXRfZGF0YV9jb3B5ICh0OignazEsJ2syLCdkKSB0KSA6ICdkIG9wdGlvbiA9XG4gICAgb2JqX29wdCAoT2JqRXBoLmdldF9kYXRhX2NvcHkgdClcbiAgbGV0IHNldF9kYXRhICh0OignazEsJ2syLCdkKSB0KSAoZDonZCkgOiB1bml0ID1cbiAgICBPYmpFcGguc2V0X2RhdGEgdCAoT2JqLnJlcHIgZClcbiAgbGV0IHVuc2V0X2RhdGEgKHQ6KCdrMSwnazIsJ2QpIHQpIDogdW5pdCA9IE9iakVwaC51bnNldF9kYXRhIHRcbiAgbGV0IGNoZWNrX2RhdGEgKHQ6KCdrMSwnazIsJ2QpIHQpIDogYm9vbCA9IE9iakVwaC5jaGVja19kYXRhIHRcbiAgbGV0IGJsaXRfZGF0YSAodDE6KF8sXywnZCkgdCkgKHQyOihfLF8sJ2QpIHQpIDogdW5pdCA9IE9iakVwaC5ibGl0X2RhdGEgdDEgdDJcblxuICBtb2R1bGUgTWFrZVNlZWRlZFxuICAgICAgKEgxOkhhc2h0YmwuU2VlZGVkSGFzaGVkVHlwZSlcbiAgICAgIChIMjpIYXNodGJsLlNlZWRlZEhhc2hlZFR5cGUpID1cbiAgICBHZW5IYXNoVGFibGUuTWFrZVNlZWRlZChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgY29udGFpbmVyID0gKEgxLnQsSDIudCwnYSkgdFxuICAgICAgdHlwZSB0ID0gSDEudCAqIEgyLnRcbiAgICAgIGxldCBjcmVhdGUgKGsxLGsyKSBkID1cbiAgICAgICAgbGV0IGMgPSBjcmVhdGUgKCkgaW5cbiAgICAgICAgc2V0X2RhdGEgYyBkO1xuICAgICAgICBzZXRfa2V5MSBjIGsxOyBzZXRfa2V5MiBjIGsyO1xuICAgICAgICBjXG4gICAgICBsZXQgaGFzaCBzZWVkIChrMSxrMikgPVxuICAgICAgICBIMS5oYXNoIHNlZWQgazEgKyBIMi5oYXNoIHNlZWQgazIgKiA2NTU5OVxuICAgICAgbGV0IGVxdWFsIGMgKGsxLGsyKSA9XG4gICAgICAgIG1hdGNoIGdldF9rZXkxIGMsIGdldF9rZXkyIGMgd2l0aFxuICAgICAgICB8IE5vbmUsIF8gfCBfICwgTm9uZSAtPiBHZW5IYXNoVGFibGUuRURlYWRcbiAgICAgICAgfCBTb21lIGsxJywgU29tZSBrMicgLT5cbiAgICAgICAgICAgIGlmIEgxLmVxdWFsIGsxIGsxJyAmJiBIMi5lcXVhbCBrMiBrMidcbiAgICAgICAgICAgIHRoZW4gR2VuSGFzaFRhYmxlLkVUcnVlIGVsc2UgR2VuSGFzaFRhYmxlLkVGYWxzZVxuICAgICAgbGV0IGdldF9kYXRhID0gZ2V0X2RhdGFcbiAgICAgIGxldCBnZXRfa2V5IGMgPVxuICAgICAgICBtYXRjaCBnZXRfa2V5MSBjLCBnZXRfa2V5MiBjIHdpdGhcbiAgICAgICAgfCBOb25lLCBfIHwgXyAsIE5vbmUgLT4gTm9uZVxuICAgICAgICB8IFNvbWUgazEnLCBTb21lIGsyJyAtPiBTb21lIChrMScsIGsyJylcbiAgICAgIGxldCBzZXRfa2V5X2RhdGEgYyAoazEsazIpIGQgPVxuICAgICAgICB1bnNldF9kYXRhIGM7XG4gICAgICAgIHNldF9rZXkxIGMgazE7IHNldF9rZXkyIGMgazI7XG4gICAgICAgIHNldF9kYXRhIGMgZFxuICAgICAgbGV0IGNoZWNrX2tleSBjID0gY2hlY2tfa2V5MSBjICYmIGNoZWNrX2tleTIgY1xuICAgIGVuZClcblxuICBtb2R1bGUgTWFrZShIMTogSGFzaHRibC5IYXNoZWRUeXBlKShIMjogSGFzaHRibC5IYXNoZWRUeXBlKTpcbiAgICAoUyB3aXRoIHR5cGUga2V5ID0gSDEudCAqIEgyLnQpID1cbiAgc3RydWN0XG4gICAgaW5jbHVkZSBNYWtlU2VlZGVkXG4gICAgICAgIChzdHJ1Y3RcbiAgICAgICAgICB0eXBlIHQgPSBIMS50XG4gICAgICAgICAgbGV0IGVxdWFsID0gSDEuZXF1YWxcbiAgICAgICAgICBsZXQgaGFzaCAoX3NlZWQ6IGludCkgeCA9IEgxLmhhc2ggeFxuICAgICAgICBlbmQpXG4gICAgICAgIChzdHJ1Y3RcbiAgICAgICAgICB0eXBlIHQgPSBIMi50XG4gICAgICAgICAgbGV0IGVxdWFsID0gSDIuZXF1YWxcbiAgICAgICAgICBsZXQgaGFzaCAoX3NlZWQ6IGludCkgeCA9IEgyLmhhc2ggeFxuICAgICAgICBlbmQpXG4gICAgbGV0IGNyZWF0ZSBzeiA9IGNyZWF0ZSB+cmFuZG9tOmZhbHNlIHN6XG4gICAgbGV0IG9mX3NlcSBpID1cbiAgICAgIGxldCB0YmwgPSBjcmVhdGUgMTYgaW5cbiAgICAgIHJlcGxhY2Vfc2VxIHRibCBpO1xuICAgICAgdGJsXG4gIGVuZFxuXG5lbmRcblxubW9kdWxlIEtuID0gc3RydWN0XG4gIHR5cGUgKCdrLCdkKSB0ID0gT2JqRXBoLnRcblxuICBsZXQgY3JlYXRlIG4gOiAoJ2ssJ2QpIHQgPSBPYmpFcGguY3JlYXRlIG5cbiAgbGV0IGxlbmd0aCAoazooJ2ssJ2QpIHQpIDogaW50ID0gT2JqRXBoLmxlbmd0aCBrXG5cbiAgbGV0IGdldF9rZXkgKHQ6KCdrLCdkKSB0KSAobjppbnQpIDogJ2sgb3B0aW9uID0gb2JqX29wdCAoT2JqRXBoLmdldF9rZXkgdCBuKVxuICBsZXQgZ2V0X2tleV9jb3B5ICh0OignaywnZCkgdCkgKG46aW50KSA6ICdrIG9wdGlvbiA9XG4gICAgb2JqX29wdCAoT2JqRXBoLmdldF9rZXlfY29weSB0IG4pXG4gIGxldCBzZXRfa2V5ICh0OignaywnZCkgdCkgKG46aW50KSAoazonaykgOiB1bml0ID1cbiAgICBPYmpFcGguc2V0X2tleSB0IG4gKE9iai5yZXByIGspXG4gIGxldCB1bnNldF9rZXkgKHQ6KCdrLCdkKSB0KSAobjppbnQpIDogdW5pdCA9IE9iakVwaC51bnNldF9rZXkgdCBuXG4gIGxldCBjaGVja19rZXkgKHQ6KCdrLCdkKSB0KSAobjppbnQpIDogYm9vbCA9IE9iakVwaC5jaGVja19rZXkgdCBuXG5cbiAgbGV0IGJsaXRfa2V5ICh0MTooJ2ssJ2QpIHQpIChvMTppbnQpICh0MjooJ2ssJ2QpIHQpIChvMjppbnQpIChsOmludCkgOiB1bml0ID1cbiAgICBPYmpFcGguYmxpdF9rZXkgdDEgbzEgdDIgbzIgbFxuXG4gIGxldCBnZXRfZGF0YSAodDooJ2ssJ2QpIHQpIDogJ2Qgb3B0aW9uID0gb2JqX29wdCAoT2JqRXBoLmdldF9kYXRhIHQpXG4gIGxldCBnZXRfZGF0YV9jb3B5ICh0OignaywnZCkgdCkgOiAnZCBvcHRpb24gPSBvYmpfb3B0IChPYmpFcGguZ2V0X2RhdGFfY29weSB0KVxuICBsZXQgc2V0X2RhdGEgKHQ6KCdrLCdkKSB0KSAoZDonZCkgOiB1bml0ID0gT2JqRXBoLnNldF9kYXRhIHQgKE9iai5yZXByIGQpXG4gIGxldCB1bnNldF9kYXRhICh0OignaywnZCkgdCkgOiB1bml0ID0gT2JqRXBoLnVuc2V0X2RhdGEgdFxuICBsZXQgY2hlY2tfZGF0YSAodDooJ2ssJ2QpIHQpIDogYm9vbCA9IE9iakVwaC5jaGVja19kYXRhIHRcbiAgbGV0IGJsaXRfZGF0YSAodDE6KF8sJ2QpIHQpICh0MjooXywnZCkgdCkgOiB1bml0ID0gT2JqRXBoLmJsaXRfZGF0YSB0MSB0MlxuXG4gIG1vZHVsZSBNYWtlU2VlZGVkIChIOkhhc2h0YmwuU2VlZGVkSGFzaGVkVHlwZSkgPVxuICAgIEdlbkhhc2hUYWJsZS5NYWtlU2VlZGVkKHN0cnVjdFxuICAgICAgdHlwZSAnYSBjb250YWluZXIgPSAoSC50LCdhKSB0XG4gICAgICB0eXBlIHQgPSBILnQgYXJyYXlcbiAgICAgIGxldCBjcmVhdGUgayBkID1cbiAgICAgICAgbGV0IGMgPSBjcmVhdGUgKEFycmF5Lmxlbmd0aCBrKSBpblxuICAgICAgICBzZXRfZGF0YSBjIGQ7XG4gICAgICAgIGZvciBpPTAgdG8gQXJyYXkubGVuZ3RoIGsgLTEgZG9cbiAgICAgICAgICBzZXRfa2V5IGMgaSBrLihpKTtcbiAgICAgICAgZG9uZTtcbiAgICAgICAgY1xuICAgICAgbGV0IGhhc2ggc2VlZCBrID1cbiAgICAgICAgbGV0IGggPSByZWYgMCBpblxuICAgICAgICBmb3IgaT0wIHRvIEFycmF5Lmxlbmd0aCBrIC0xIGRvXG4gICAgICAgICAgaCA6PSBILmhhc2ggc2VlZCBrLihpKSAqIDY1NTk5ICsgIWg7XG4gICAgICAgIGRvbmU7XG4gICAgICAgICFoXG4gICAgICBsZXQgZXF1YWwgYyBrID1cbiAgICAgICAgbGV0IGxlbiAgPSBBcnJheS5sZW5ndGggayBpblxuICAgICAgICBsZXQgbGVuJyA9IGxlbmd0aCBjIGluXG4gICAgICAgIGlmIGxlbiAhPSBsZW4nIHRoZW4gR2VuSGFzaFRhYmxlLkVGYWxzZVxuICAgICAgICBlbHNlXG4gICAgICAgICAgbGV0IHJlYyBlcXVhbF9hcnJheSBrIGMgaSA9XG4gICAgICAgICAgICBpZiBpIDwgMCB0aGVuIEdlbkhhc2hUYWJsZS5FVHJ1ZVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBtYXRjaCBnZXRfa2V5IGMgaSB3aXRoXG4gICAgICAgICAgICAgIHwgTm9uZSAtPiBHZW5IYXNoVGFibGUuRURlYWRcbiAgICAgICAgICAgICAgfCBTb21lIGtpIC0+XG4gICAgICAgICAgICAgICAgICBpZiBILmVxdWFsIGsuKGkpIGtpXG4gICAgICAgICAgICAgICAgICB0aGVuIGVxdWFsX2FycmF5IGsgYyAoaS0xKVxuICAgICAgICAgICAgICAgICAgZWxzZSBHZW5IYXNoVGFibGUuRUZhbHNlXG4gICAgICAgICAgaW5cbiAgICAgICAgICBlcXVhbF9hcnJheSBrIGMgKGxlbi0xKVxuICAgICAgbGV0IGdldF9kYXRhID0gZ2V0X2RhdGFcbiAgICAgIGxldCBnZXRfa2V5IGMgPVxuICAgICAgICBsZXQgbGVuID0gbGVuZ3RoIGMgaW5cbiAgICAgICAgaWYgbGVuID0gMCB0aGVuIFNvbWUgW3x8XVxuICAgICAgICBlbHNlXG4gICAgICAgICAgbWF0Y2ggZ2V0X2tleSBjIDAgd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPiBOb25lXG4gICAgICAgICAgfCBTb21lIGswIC0+XG4gICAgICAgICAgICAgIGxldCByZWMgZmlsbCBhIGkgPVxuICAgICAgICAgICAgICAgIGlmIGkgPCAxIHRoZW4gU29tZSBhXG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgbWF0Y2ggZ2V0X2tleSBjIGkgd2l0aFxuICAgICAgICAgICAgICAgICAgfCBOb25lIC0+IE5vbmVcbiAgICAgICAgICAgICAgICAgIHwgU29tZSBraSAtPlxuICAgICAgICAgICAgICAgICAgICAgIGEuKGkpIDwtIGtpO1xuICAgICAgICAgICAgICAgICAgICAgIGZpbGwgYSAoaS0xKVxuICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICBsZXQgYSA9IEFycmF5Lm1ha2UgbGVuIGswIGluXG4gICAgICAgICAgICAgIGZpbGwgYSAobGVuLTEpXG4gICAgICBsZXQgc2V0X2tleV9kYXRhIGMgayBkID1cbiAgICAgICAgdW5zZXRfZGF0YSBjO1xuICAgICAgICBmb3IgaT0wIHRvIEFycmF5Lmxlbmd0aCBrIC0xIGRvXG4gICAgICAgICAgc2V0X2tleSBjIGkgay4oaSk7XG4gICAgICAgIGRvbmU7XG4gICAgICAgIHNldF9kYXRhIGMgZFxuICAgICAgbGV0IGNoZWNrX2tleSBjID1cbiAgICAgICAgbGV0IHJlYyBjaGVjayBjIGkgPVxuICAgICAgICAgIGkgPCAwIHx8IChjaGVja19rZXkgYyBpICYmIGNoZWNrIGMgKGktMSkpIGluXG4gICAgICAgIGNoZWNrIGMgKGxlbmd0aCBjIC0gMSlcbiAgICBlbmQpXG5cbiAgbW9kdWxlIE1ha2UoSDogSGFzaHRibC5IYXNoZWRUeXBlKTogKFMgd2l0aCB0eXBlIGtleSA9IEgudCBhcnJheSkgPVxuICBzdHJ1Y3RcbiAgICBpbmNsdWRlIE1ha2VTZWVkZWQoc3RydWN0XG4gICAgICAgIHR5cGUgdCA9IEgudFxuICAgICAgICBsZXQgZXF1YWwgPSBILmVxdWFsXG4gICAgICAgIGxldCBoYXNoIChfc2VlZDogaW50KSB4ID0gSC5oYXNoIHhcbiAgICAgIGVuZClcbiAgICBsZXQgY3JlYXRlIHN6ID0gY3JlYXRlIH5yYW5kb206ZmFsc2Ugc3pcbiAgICBsZXQgb2Zfc2VxIGkgPVxuICAgICAgbGV0IHRibCA9IGNyZWF0ZSAxNiBpblxuICAgICAgcmVwbGFjZV9zZXEgdGJsIGk7XG4gICAgICB0YmxcbiAgZW5kXG5lbmRcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICBNYW51ZWwgU2VycmFubyBldCBYYXZpZXIgTGVyb3ksIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMDAgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogTW9kdWxlIFtCaWdhcnJheV06IGxhcmdlLCBtdWx0aS1kaW1lbnNpb25hbCwgbnVtZXJpY2FsIGFycmF5cyAqKVxuXG4oKiBUaGVzZSB0eXBlcyBpbiBtdXN0IGJlIGtlcHQgaW4gc3luYyB3aXRoIHRoZSB0YWJsZXMgaW5cbiAgIC4uL3R5cGluZy90eXBlb3B0Lm1sICopXG5cbnR5cGUgZmxvYXQzMl9lbHQgPSBGbG9hdDMyX2VsdFxudHlwZSBmbG9hdDY0X2VsdCA9IEZsb2F0NjRfZWx0XG50eXBlIGludDhfc2lnbmVkX2VsdCA9IEludDhfc2lnbmVkX2VsdFxudHlwZSBpbnQ4X3Vuc2lnbmVkX2VsdCA9IEludDhfdW5zaWduZWRfZWx0XG50eXBlIGludDE2X3NpZ25lZF9lbHQgPSBJbnQxNl9zaWduZWRfZWx0XG50eXBlIGludDE2X3Vuc2lnbmVkX2VsdCA9IEludDE2X3Vuc2lnbmVkX2VsdFxudHlwZSBpbnQzMl9lbHQgPSBJbnQzMl9lbHRcbnR5cGUgaW50NjRfZWx0ID0gSW50NjRfZWx0XG50eXBlIGludF9lbHQgPSBJbnRfZWx0XG50eXBlIG5hdGl2ZWludF9lbHQgPSBOYXRpdmVpbnRfZWx0XG50eXBlIGNvbXBsZXgzMl9lbHQgPSBDb21wbGV4MzJfZWx0XG50eXBlIGNvbXBsZXg2NF9lbHQgPSBDb21wbGV4NjRfZWx0XG5cbnR5cGUgKCdhLCAnYikga2luZCA9XG4gICAgRmxvYXQzMiA6IChmbG9hdCwgZmxvYXQzMl9lbHQpIGtpbmRcbiAgfCBGbG9hdDY0IDogKGZsb2F0LCBmbG9hdDY0X2VsdCkga2luZFxuICB8IEludDhfc2lnbmVkIDogKGludCwgaW50OF9zaWduZWRfZWx0KSBraW5kXG4gIHwgSW50OF91bnNpZ25lZCA6IChpbnQsIGludDhfdW5zaWduZWRfZWx0KSBraW5kXG4gIHwgSW50MTZfc2lnbmVkIDogKGludCwgaW50MTZfc2lnbmVkX2VsdCkga2luZFxuICB8IEludDE2X3Vuc2lnbmVkIDogKGludCwgaW50MTZfdW5zaWduZWRfZWx0KSBraW5kXG4gIHwgSW50MzIgOiAoaW50MzIsIGludDMyX2VsdCkga2luZFxuICB8IEludDY0IDogKGludDY0LCBpbnQ2NF9lbHQpIGtpbmRcbiAgfCBJbnQgOiAoaW50LCBpbnRfZWx0KSBraW5kXG4gIHwgTmF0aXZlaW50IDogKG5hdGl2ZWludCwgbmF0aXZlaW50X2VsdCkga2luZFxuICB8IENvbXBsZXgzMiA6IChDb21wbGV4LnQsIGNvbXBsZXgzMl9lbHQpIGtpbmRcbiAgfCBDb21wbGV4NjQgOiAoQ29tcGxleC50LCBjb21wbGV4NjRfZWx0KSBraW5kXG4gIHwgQ2hhciA6IChjaGFyLCBpbnQ4X3Vuc2lnbmVkX2VsdCkga2luZFxuXG50eXBlIGNfbGF5b3V0ID0gQ19sYXlvdXRfdHlwXG50eXBlIGZvcnRyYW5fbGF5b3V0ID0gRm9ydHJhbl9sYXlvdXRfdHlwICgqKilcblxudHlwZSAnYSBsYXlvdXQgPVxuICAgIENfbGF5b3V0OiBjX2xheW91dCBsYXlvdXRcbiAgfCBGb3J0cmFuX2xheW91dDogZm9ydHJhbl9sYXlvdXQgbGF5b3V0XG5cbigqIEtlZXAgdGhvc2UgY29uc3RhbnRzIGluIHN5bmMgd2l0aCB0aGUgY2FtbF9iYV9raW5kIGVudW1lcmF0aW9uXG4gICBpbiBiaWdhcnJheS5oICopXG5cbmxldCBmbG9hdDMyID0gRmxvYXQzMlxubGV0IGZsb2F0NjQgPSBGbG9hdDY0XG5sZXQgaW50OF9zaWduZWQgPSBJbnQ4X3NpZ25lZFxubGV0IGludDhfdW5zaWduZWQgPSBJbnQ4X3Vuc2lnbmVkXG5sZXQgaW50MTZfc2lnbmVkID0gSW50MTZfc2lnbmVkXG5sZXQgaW50MTZfdW5zaWduZWQgPSBJbnQxNl91bnNpZ25lZFxubGV0IGludDMyID0gSW50MzJcbmxldCBpbnQ2NCA9IEludDY0XG5sZXQgaW50ID0gSW50XG5sZXQgbmF0aXZlaW50ID0gTmF0aXZlaW50XG5sZXQgY29tcGxleDMyID0gQ29tcGxleDMyXG5sZXQgY29tcGxleDY0ID0gQ29tcGxleDY0XG5sZXQgY2hhciA9IENoYXJcblxubGV0IGtpbmRfc2l6ZV9pbl9ieXRlcyA6IHR5cGUgYSBiLiAoYSwgYikga2luZCAtPiBpbnQgPSBmdW5jdGlvblxuICB8IEZsb2F0MzIgLT4gNFxuICB8IEZsb2F0NjQgLT4gOFxuICB8IEludDhfc2lnbmVkIC0+IDFcbiAgfCBJbnQ4X3Vuc2lnbmVkIC0+IDFcbiAgfCBJbnQxNl9zaWduZWQgLT4gMlxuICB8IEludDE2X3Vuc2lnbmVkIC0+IDJcbiAgfCBJbnQzMiAtPiA0XG4gIHwgSW50NjQgLT4gOFxuICB8IEludCAtPiBTeXMud29yZF9zaXplIC8gOFxuICB8IE5hdGl2ZWludCAtPiBTeXMud29yZF9zaXplIC8gOFxuICB8IENvbXBsZXgzMiAtPiA4XG4gIHwgQ29tcGxleDY0IC0+IDE2XG4gIHwgQ2hhciAtPiAxXG5cbigqIEtlZXAgdGhvc2UgY29uc3RhbnRzIGluIHN5bmMgd2l0aCB0aGUgY2FtbF9iYV9sYXlvdXQgZW51bWVyYXRpb25cbiAgIGluIGJpZ2FycmF5LmggKilcblxubGV0IGNfbGF5b3V0ID0gQ19sYXlvdXRcbmxldCBmb3J0cmFuX2xheW91dCA9IEZvcnRyYW5fbGF5b3V0XG5cbm1vZHVsZSBHZW5hcnJheSA9IHN0cnVjdFxuICB0eXBlICghJ2EsICEnYiwgISdjKSB0XG4gIGV4dGVybmFsIGNyZWF0ZTogKCdhLCAnYikga2luZCAtPiAnYyBsYXlvdXQgLT4gaW50IGFycmF5IC0+ICgnYSwgJ2IsICdjKSB0XG4gICAgID0gXCJjYW1sX2JhX2NyZWF0ZVwiXG4gIGV4dGVybmFsIGdldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IGFycmF5IC0+ICdhXG4gICAgID0gXCJjYW1sX2JhX2dldF9nZW5lcmljXCJcbiAgZXh0ZXJuYWwgc2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgYXJyYXkgLT4gJ2EgLT4gdW5pdFxuICAgICA9IFwiY2FtbF9iYV9zZXRfZ2VuZXJpY1wiXG5cbiAgbGV0IHJlYyBjbG9vcCBhcnIgaWR4IGYgY29sIG1heCA9XG4gICAgaWYgY29sID0gQXJyYXkubGVuZ3RoIGlkeCB0aGVuIHNldCBhcnIgaWR4IChmIGlkeClcbiAgICBlbHNlIGZvciBqID0gMCB0byBwcmVkIG1heC4oY29sKSBkb1xuICAgICAgICAgICBpZHguKGNvbCkgPC0gajtcbiAgICAgICAgICAgY2xvb3AgYXJyIGlkeCBmIChzdWNjIGNvbCkgbWF4XG4gICAgICAgICBkb25lXG4gIGxldCByZWMgZmxvb3AgYXJyIGlkeCBmIGNvbCBtYXggPVxuICAgIGlmIGNvbCA8IDAgdGhlbiBzZXQgYXJyIGlkeCAoZiBpZHgpXG4gICAgZWxzZSBmb3IgaiA9IDEgdG8gbWF4Lihjb2wpIGRvXG4gICAgICAgICAgIGlkeC4oY29sKSA8LSBqO1xuICAgICAgICAgICBmbG9vcCBhcnIgaWR4IGYgKHByZWQgY29sKSBtYXhcbiAgICAgICAgIGRvbmVcbiAgbGV0IGluaXQgKHR5cGUgdCkga2luZCAobGF5b3V0IDogdCBsYXlvdXQpIGRpbXMgZiA9XG4gICAgbGV0IGFyciA9IGNyZWF0ZSBraW5kIGxheW91dCBkaW1zIGluXG4gICAgbWF0Y2ggQXJyYXkubGVuZ3RoIGRpbXMsIGxheW91dCB3aXRoXG4gICAgfCAwLCBfIC0+IGFyclxuICAgIHwgZGxlbiwgQ19sYXlvdXQgLT4gY2xvb3AgYXJyIChBcnJheS5tYWtlIGRsZW4gMCkgZiAwIGRpbXM7IGFyclxuICAgIHwgZGxlbiwgRm9ydHJhbl9sYXlvdXQgLT4gZmxvb3AgYXJyIChBcnJheS5tYWtlIGRsZW4gMSkgZiAocHJlZCBkbGVuKSBkaW1zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyXG5cbiAgZXh0ZXJuYWwgbnVtX2RpbXM6ICgnYSwgJ2IsICdjKSB0IC0+IGludCA9IFwiY2FtbF9iYV9udW1fZGltc1wiXG4gIGV4dGVybmFsIG50aF9kaW06ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiBpbnQgPSBcImNhbWxfYmFfZGltXCJcbiAgbGV0IGRpbXMgYSA9XG4gICAgbGV0IG4gPSBudW1fZGltcyBhIGluXG4gICAgbGV0IGQgPSBBcnJheS5tYWtlIG4gMCBpblxuICAgIGZvciBpID0gMCB0byBuLTEgZG8gZC4oaSkgPC0gbnRoX2RpbSBhIGkgZG9uZTtcbiAgICBkXG5cbiAgZXh0ZXJuYWwga2luZDogKCdhLCAnYiwgJ2MpIHQgLT4gKCdhLCAnYikga2luZCA9IFwiY2FtbF9iYV9raW5kXCJcbiAgZXh0ZXJuYWwgbGF5b3V0OiAoJ2EsICdiLCAnYykgdCAtPiAnYyBsYXlvdXQgPSBcImNhbWxfYmFfbGF5b3V0XCJcbiAgZXh0ZXJuYWwgY2hhbmdlX2xheW91dDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2QgbGF5b3V0IC0+ICgnYSwgJ2IsICdkKSB0XG4gICAgID0gXCJjYW1sX2JhX2NoYW5nZV9sYXlvdXRcIlxuXG4gIGxldCBzaXplX2luX2J5dGVzIGFyciA9XG4gICAgKGtpbmRfc2l6ZV9pbl9ieXRlcyAoa2luZCBhcnIpKSAqIChBcnJheS5mb2xkX2xlZnQgKCAqICkgMSAoZGltcyBhcnIpKVxuXG4gIGV4dGVybmFsIHN1Yl9sZWZ0OiAoJ2EsICdiLCBjX2xheW91dCkgdCAtPiBpbnQgLT4gaW50IC0+ICgnYSwgJ2IsIGNfbGF5b3V0KSB0XG4gICAgID0gXCJjYW1sX2JhX3N1YlwiXG4gIGV4dGVybmFsIHN1Yl9yaWdodDogKCdhLCAnYiwgZm9ydHJhbl9sYXlvdXQpIHQgLT4gaW50IC0+IGludCAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAoJ2EsICdiLCBmb3J0cmFuX2xheW91dCkgdFxuICAgICA9IFwiY2FtbF9iYV9zdWJcIlxuICBleHRlcm5hbCBzbGljZV9sZWZ0OiAoJ2EsICdiLCBjX2xheW91dCkgdCAtPiBpbnQgYXJyYXkgLT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgKCdhLCAnYiwgY19sYXlvdXQpIHRcbiAgICAgPSBcImNhbWxfYmFfc2xpY2VcIlxuICBleHRlcm5hbCBzbGljZV9yaWdodDogKCdhLCAnYiwgZm9ydHJhbl9sYXlvdXQpIHQgLT4gaW50IGFycmF5IC0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICgnYSwgJ2IsIGZvcnRyYW5fbGF5b3V0KSB0XG4gICAgID0gXCJjYW1sX2JhX3NsaWNlXCJcbiAgZXh0ZXJuYWwgYmxpdDogKCdhLCAnYiwgJ2MpIHQgLT4gKCdhLCAnYiwgJ2MpIHQgLT4gdW5pdFxuICAgICA9IFwiY2FtbF9iYV9ibGl0XCJcbiAgZXh0ZXJuYWwgZmlsbDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2EgLT4gdW5pdCA9IFwiY2FtbF9iYV9maWxsXCJcbmVuZFxuXG5tb2R1bGUgQXJyYXkwID0gc3RydWN0XG4gIHR5cGUgKCEnYSwgISdiLCAhJ2MpIHQgPSAoJ2EsICdiLCAnYykgR2VuYXJyYXkudFxuICBsZXQgY3JlYXRlIGtpbmQgbGF5b3V0ID1cbiAgICBHZW5hcnJheS5jcmVhdGUga2luZCBsYXlvdXQgW3x8XVxuICBsZXQgZ2V0IGFyciA9IEdlbmFycmF5LmdldCBhcnIgW3x8XVxuICBsZXQgc2V0IGFyciA9IEdlbmFycmF5LnNldCBhcnIgW3x8XVxuICBleHRlcm5hbCBraW5kOiAoJ2EsICdiLCAnYykgdCAtPiAoJ2EsICdiKSBraW5kID0gXCJjYW1sX2JhX2tpbmRcIlxuICBleHRlcm5hbCBsYXlvdXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICdjIGxheW91dCA9IFwiY2FtbF9iYV9sYXlvdXRcIlxuXG4gIGV4dGVybmFsIGNoYW5nZV9sYXlvdXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICdkIGxheW91dCAtPiAoJ2EsICdiLCAnZCkgdFxuICAgID0gXCJjYW1sX2JhX2NoYW5nZV9sYXlvdXRcIlxuXG4gIGxldCBzaXplX2luX2J5dGVzIGFyciA9IGtpbmRfc2l6ZV9pbl9ieXRlcyAoa2luZCBhcnIpXG5cbiAgZXh0ZXJuYWwgYmxpdDogKCdhLCAnYiwgJ2MpIHQgLT4gKCdhLCAnYiwgJ2MpIHQgLT4gdW5pdCA9IFwiY2FtbF9iYV9ibGl0XCJcbiAgZXh0ZXJuYWwgZmlsbDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2EgLT4gdW5pdCA9IFwiY2FtbF9iYV9maWxsXCJcblxuICBsZXQgb2ZfdmFsdWUga2luZCBsYXlvdXQgdiA9XG4gICAgbGV0IGEgPSBjcmVhdGUga2luZCBsYXlvdXQgaW5cbiAgICBzZXQgYSB2O1xuICAgIGFcbiAgbGV0IGluaXQgPSBvZl92YWx1ZVxuZW5kXG5cbm1vZHVsZSBBcnJheTEgPSBzdHJ1Y3RcbiAgdHlwZSAoISdhLCAhJ2IsICEnYykgdCA9ICgnYSwgJ2IsICdjKSBHZW5hcnJheS50XG4gIGxldCBjcmVhdGUga2luZCBsYXlvdXQgZGltID1cbiAgICBHZW5hcnJheS5jcmVhdGUga2luZCBsYXlvdXQgW3xkaW18XVxuICBleHRlcm5hbCBnZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiAnYSA9IFwiJWNhbWxfYmFfcmVmXzFcIlxuICBleHRlcm5hbCBzZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiAnYSAtPiB1bml0ID0gXCIlY2FtbF9iYV9zZXRfMVwiXG4gIGV4dGVybmFsIHVuc2FmZV9nZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiAnYSA9IFwiJWNhbWxfYmFfdW5zYWZlX3JlZl8xXCJcbiAgZXh0ZXJuYWwgdW5zYWZlX3NldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+ICdhIC0+IHVuaXRcbiAgICAgPSBcIiVjYW1sX2JhX3Vuc2FmZV9zZXRfMVwiXG4gIGV4dGVybmFsIGRpbTogKCdhLCAnYiwgJ2MpIHQgLT4gaW50ID0gXCIlY2FtbF9iYV9kaW1fMVwiXG4gIGV4dGVybmFsIGtpbmQ6ICgnYSwgJ2IsICdjKSB0IC0+ICgnYSwgJ2IpIGtpbmQgPSBcImNhbWxfYmFfa2luZFwiXG4gIGV4dGVybmFsIGxheW91dDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2MgbGF5b3V0ID0gXCJjYW1sX2JhX2xheW91dFwiXG5cbiAgZXh0ZXJuYWwgY2hhbmdlX2xheW91dDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2QgbGF5b3V0IC0+ICgnYSwgJ2IsICdkKSB0XG4gICAgPSBcImNhbWxfYmFfY2hhbmdlX2xheW91dFwiXG5cbiAgbGV0IHNpemVfaW5fYnl0ZXMgYXJyID1cbiAgICAoa2luZF9zaXplX2luX2J5dGVzIChraW5kIGFycikpICogKGRpbSBhcnIpXG5cbiAgZXh0ZXJuYWwgc3ViOiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gaW50IC0+ICgnYSwgJ2IsICdjKSB0ID0gXCJjYW1sX2JhX3N1YlwiXG4gIGxldCBzbGljZSAodHlwZSB0KSAoYSA6IChfLCBfLCB0KSBHZW5hcnJheS50KSBuID1cbiAgICBtYXRjaCBsYXlvdXQgYSB3aXRoXG4gICAgfCBDX2xheW91dCAtPiAoR2VuYXJyYXkuc2xpY2VfbGVmdCBhIFt8bnxdIDogKF8sIF8sIHQpIEdlbmFycmF5LnQpXG4gICAgfCBGb3J0cmFuX2xheW91dCAtPiAoR2VuYXJyYXkuc2xpY2VfcmlnaHQgYSBbfG58XTogKF8sIF8sIHQpIEdlbmFycmF5LnQpXG4gIGV4dGVybmFsIGJsaXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICgnYSwgJ2IsICdjKSB0IC0+IHVuaXQgPSBcImNhbWxfYmFfYmxpdFwiXG4gIGV4dGVybmFsIGZpbGw6ICgnYSwgJ2IsICdjKSB0IC0+ICdhIC0+IHVuaXQgPSBcImNhbWxfYmFfZmlsbFwiXG4gIGxldCBjX2luaXQgYXJyIGRpbSBmID1cbiAgICBmb3IgaSA9IDAgdG8gcHJlZCBkaW0gZG8gdW5zYWZlX3NldCBhcnIgaSAoZiBpKSBkb25lXG4gIGxldCBmb3J0cmFuX2luaXQgYXJyIGRpbSBmID1cbiAgICBmb3IgaSA9IDEgdG8gZGltIGRvIHVuc2FmZV9zZXQgYXJyIGkgKGYgaSkgZG9uZVxuICBsZXQgaW5pdCAodHlwZSB0KSBraW5kIChsYXlvdXQgOiB0IGxheW91dCkgZGltIGYgPVxuICAgIGxldCBhcnIgPSBjcmVhdGUga2luZCBsYXlvdXQgZGltIGluXG4gICAgbWF0Y2ggbGF5b3V0IHdpdGhcbiAgICB8IENfbGF5b3V0IC0+IGNfaW5pdCBhcnIgZGltIGY7IGFyclxuICAgIHwgRm9ydHJhbl9sYXlvdXQgLT4gZm9ydHJhbl9pbml0IGFyciBkaW0gZjsgYXJyXG4gIGxldCBvZl9hcnJheSAodHlwZSB0KSBraW5kIChsYXlvdXQ6IHQgbGF5b3V0KSBkYXRhID1cbiAgICBsZXQgYmEgPSBjcmVhdGUga2luZCBsYXlvdXQgKEFycmF5Lmxlbmd0aCBkYXRhKSBpblxuICAgIGxldCBvZnMgPVxuICAgICAgbWF0Y2ggbGF5b3V0IHdpdGhcbiAgICAgICAgQ19sYXlvdXQgLT4gMFxuICAgICAgfCBGb3J0cmFuX2xheW91dCAtPiAxXG4gICAgaW5cbiAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGRhdGEgLSAxIGRvIHVuc2FmZV9zZXQgYmEgKGkgKyBvZnMpIGRhdGEuKGkpIGRvbmU7XG4gICAgYmFcbmVuZFxuXG5tb2R1bGUgQXJyYXkyID0gc3RydWN0XG4gIHR5cGUgKCEnYSwgISdiLCAhJ2MpIHQgPSAoJ2EsICdiLCAnYykgR2VuYXJyYXkudFxuICBsZXQgY3JlYXRlIGtpbmQgbGF5b3V0IGRpbTEgZGltMiA9XG4gICAgR2VuYXJyYXkuY3JlYXRlIGtpbmQgbGF5b3V0IFt8ZGltMTsgZGltMnxdXG4gIGV4dGVybmFsIGdldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+IGludCAtPiAnYSA9IFwiJWNhbWxfYmFfcmVmXzJcIlxuICBleHRlcm5hbCBzZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiBpbnQgLT4gJ2EgLT4gdW5pdCA9IFwiJWNhbWxfYmFfc2V0XzJcIlxuICBleHRlcm5hbCB1bnNhZmVfZ2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gaW50IC0+ICdhXG4gICAgID0gXCIlY2FtbF9iYV91bnNhZmVfcmVmXzJcIlxuICBleHRlcm5hbCB1bnNhZmVfc2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gaW50IC0+ICdhIC0+IHVuaXRcbiAgICAgPSBcIiVjYW1sX2JhX3Vuc2FmZV9zZXRfMlwiXG4gIGV4dGVybmFsIGRpbTE6ICgnYSwgJ2IsICdjKSB0IC0+IGludCA9IFwiJWNhbWxfYmFfZGltXzFcIlxuICBleHRlcm5hbCBkaW0yOiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgPSBcIiVjYW1sX2JhX2RpbV8yXCJcbiAgZXh0ZXJuYWwga2luZDogKCdhLCAnYiwgJ2MpIHQgLT4gKCdhLCAnYikga2luZCA9IFwiY2FtbF9iYV9raW5kXCJcbiAgZXh0ZXJuYWwgbGF5b3V0OiAoJ2EsICdiLCAnYykgdCAtPiAnYyBsYXlvdXQgPSBcImNhbWxfYmFfbGF5b3V0XCJcblxuICBleHRlcm5hbCBjaGFuZ2VfbGF5b3V0OiAoJ2EsICdiLCAnYykgdCAtPiAnZCBsYXlvdXQgLT4gKCdhLCAnYiwgJ2QpIHRcbiAgICA9IFwiY2FtbF9iYV9jaGFuZ2VfbGF5b3V0XCJcblxuICBsZXQgc2l6ZV9pbl9ieXRlcyBhcnIgPVxuICAgIChraW5kX3NpemVfaW5fYnl0ZXMgKGtpbmQgYXJyKSkgKiAoZGltMSBhcnIpICogKGRpbTIgYXJyKVxuXG4gIGV4dGVybmFsIHN1Yl9sZWZ0OiAoJ2EsICdiLCBjX2xheW91dCkgdCAtPiBpbnQgLT4gaW50IC0+ICgnYSwgJ2IsIGNfbGF5b3V0KSB0XG4gICAgID0gXCJjYW1sX2JhX3N1YlwiXG4gIGV4dGVybmFsIHN1Yl9yaWdodDpcbiAgICAoJ2EsICdiLCBmb3J0cmFuX2xheW91dCkgdCAtPiBpbnQgLT4gaW50IC0+ICgnYSwgJ2IsIGZvcnRyYW5fbGF5b3V0KSB0XG4gICAgID0gXCJjYW1sX2JhX3N1YlwiXG4gIGxldCBzbGljZV9sZWZ0IGEgbiA9IEdlbmFycmF5LnNsaWNlX2xlZnQgYSBbfG58XVxuICBsZXQgc2xpY2VfcmlnaHQgYSBuID0gR2VuYXJyYXkuc2xpY2VfcmlnaHQgYSBbfG58XVxuICBleHRlcm5hbCBibGl0OiAoJ2EsICdiLCAnYykgdCAtPiAoJ2EsICdiLCAnYykgdCAtPiB1bml0ID0gXCJjYW1sX2JhX2JsaXRcIlxuICBleHRlcm5hbCBmaWxsOiAoJ2EsICdiLCAnYykgdCAtPiAnYSAtPiB1bml0ID0gXCJjYW1sX2JhX2ZpbGxcIlxuICBsZXQgY19pbml0IGFyciBkaW0xIGRpbTIgZiA9XG4gICAgZm9yIGkgPSAwIHRvIHByZWQgZGltMSBkb1xuICAgICAgZm9yIGogPSAwIHRvIHByZWQgZGltMiBkb1xuICAgICAgICB1bnNhZmVfc2V0IGFyciBpIGogKGYgaSBqKVxuICAgICAgZG9uZVxuICAgIGRvbmVcbiAgbGV0IGZvcnRyYW5faW5pdCBhcnIgZGltMSBkaW0yIGYgPVxuICAgIGZvciBqID0gMSB0byBkaW0yIGRvXG4gICAgICBmb3IgaSA9IDEgdG8gZGltMSBkb1xuICAgICAgICB1bnNhZmVfc2V0IGFyciBpIGogKGYgaSBqKVxuICAgICAgZG9uZVxuICAgIGRvbmVcbiAgbGV0IGluaXQgKHR5cGUgdCkga2luZCAobGF5b3V0IDogdCBsYXlvdXQpIGRpbTEgZGltMiBmID1cbiAgICBsZXQgYXJyID0gY3JlYXRlIGtpbmQgbGF5b3V0IGRpbTEgZGltMiBpblxuICAgIG1hdGNoIGxheW91dCB3aXRoXG4gICAgfCBDX2xheW91dCAtPiBjX2luaXQgYXJyIGRpbTEgZGltMiBmOyBhcnJcbiAgICB8IEZvcnRyYW5fbGF5b3V0IC0+IGZvcnRyYW5faW5pdCBhcnIgZGltMSBkaW0yIGY7IGFyclxuICBsZXQgb2ZfYXJyYXkgKHR5cGUgdCkga2luZCAobGF5b3V0OiB0IGxheW91dCkgZGF0YSA9XG4gICAgbGV0IGRpbTEgPSBBcnJheS5sZW5ndGggZGF0YSBpblxuICAgIGxldCBkaW0yID0gaWYgZGltMSA9IDAgdGhlbiAwIGVsc2UgQXJyYXkubGVuZ3RoIGRhdGEuKDApIGluXG4gICAgbGV0IGJhID0gY3JlYXRlIGtpbmQgbGF5b3V0IGRpbTEgZGltMiBpblxuICAgIGxldCBvZnMgPVxuICAgICAgbWF0Y2ggbGF5b3V0IHdpdGhcbiAgICAgICAgQ19sYXlvdXQgLT4gMFxuICAgICAgfCBGb3J0cmFuX2xheW91dCAtPiAxXG4gICAgaW5cbiAgICBmb3IgaSA9IDAgdG8gZGltMSAtIDEgZG9cbiAgICAgIGxldCByb3cgPSBkYXRhLihpKSBpblxuICAgICAgaWYgQXJyYXkubGVuZ3RoIHJvdyA8PiBkaW0yIHRoZW5cbiAgICAgICAgaW52YWxpZF9hcmcoXCJCaWdhcnJheS5BcnJheTIub2ZfYXJyYXk6IG5vbi1yZWN0YW5ndWxhciBkYXRhXCIpO1xuICAgICAgZm9yIGogPSAwIHRvIGRpbTIgLSAxIGRvXG4gICAgICAgIHVuc2FmZV9zZXQgYmEgKGkgKyBvZnMpIChqICsgb2ZzKSByb3cuKGopXG4gICAgICBkb25lXG4gICAgZG9uZTtcbiAgICBiYVxuZW5kXG5cbm1vZHVsZSBBcnJheTMgPSBzdHJ1Y3RcbiAgdHlwZSAoISdhLCAhJ2IsICEnYykgdCA9ICgnYSwgJ2IsICdjKSBHZW5hcnJheS50XG4gIGxldCBjcmVhdGUga2luZCBsYXlvdXQgZGltMSBkaW0yIGRpbTMgPVxuICAgIEdlbmFycmF5LmNyZWF0ZSBraW5kIGxheW91dCBbfGRpbTE7IGRpbTI7IGRpbTN8XVxuICBleHRlcm5hbCBnZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiBpbnQgLT4gaW50IC0+ICdhID0gXCIlY2FtbF9iYV9yZWZfM1wiXG4gIGV4dGVybmFsIHNldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+IGludCAtPiBpbnQgLT4gJ2EgLT4gdW5pdFxuICAgICA9IFwiJWNhbWxfYmFfc2V0XzNcIlxuICBleHRlcm5hbCB1bnNhZmVfZ2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gaW50IC0+IGludCAtPiAnYVxuICAgICA9IFwiJWNhbWxfYmFfdW5zYWZlX3JlZl8zXCJcbiAgZXh0ZXJuYWwgdW5zYWZlX3NldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+IGludCAtPiBpbnQgLT4gJ2EgLT4gdW5pdFxuICAgICA9IFwiJWNhbWxfYmFfdW5zYWZlX3NldF8zXCJcbiAgZXh0ZXJuYWwgZGltMTogKCdhLCAnYiwgJ2MpIHQgLT4gaW50ID0gXCIlY2FtbF9iYV9kaW1fMVwiXG4gIGV4dGVybmFsIGRpbTI6ICgnYSwgJ2IsICdjKSB0IC0+IGludCA9IFwiJWNhbWxfYmFfZGltXzJcIlxuICBleHRlcm5hbCBkaW0zOiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgPSBcIiVjYW1sX2JhX2RpbV8zXCJcbiAgZXh0ZXJuYWwga2luZDogKCdhLCAnYiwgJ2MpIHQgLT4gKCdhLCAnYikga2luZCA9IFwiY2FtbF9iYV9raW5kXCJcbiAgZXh0ZXJuYWwgbGF5b3V0OiAoJ2EsICdiLCAnYykgdCAtPiAnYyBsYXlvdXQgPSBcImNhbWxfYmFfbGF5b3V0XCJcblxuICBleHRlcm5hbCBjaGFuZ2VfbGF5b3V0OiAoJ2EsICdiLCAnYykgdCAtPiAnZCBsYXlvdXQgLT4gKCdhLCAnYiwgJ2QpIHRcbiAgICA9IFwiY2FtbF9iYV9jaGFuZ2VfbGF5b3V0XCJcblxuICBsZXQgc2l6ZV9pbl9ieXRlcyBhcnIgPVxuICAgIChraW5kX3NpemVfaW5fYnl0ZXMgKGtpbmQgYXJyKSkgKiAoZGltMSBhcnIpICogKGRpbTIgYXJyKSAqIChkaW0zIGFycilcblxuICBleHRlcm5hbCBzdWJfbGVmdDogKCdhLCAnYiwgY19sYXlvdXQpIHQgLT4gaW50IC0+IGludCAtPiAoJ2EsICdiLCBjX2xheW91dCkgdFxuICAgICA9IFwiY2FtbF9iYV9zdWJcIlxuICBleHRlcm5hbCBzdWJfcmlnaHQ6XG4gICAgICgnYSwgJ2IsIGZvcnRyYW5fbGF5b3V0KSB0IC0+IGludCAtPiBpbnQgLT4gKCdhLCAnYiwgZm9ydHJhbl9sYXlvdXQpIHRcbiAgICAgPSBcImNhbWxfYmFfc3ViXCJcbiAgbGV0IHNsaWNlX2xlZnRfMSBhIG4gbSA9IEdlbmFycmF5LnNsaWNlX2xlZnQgYSBbfG47IG18XVxuICBsZXQgc2xpY2VfcmlnaHRfMSBhIG4gbSA9IEdlbmFycmF5LnNsaWNlX3JpZ2h0IGEgW3xuOyBtfF1cbiAgbGV0IHNsaWNlX2xlZnRfMiBhIG4gPSBHZW5hcnJheS5zbGljZV9sZWZ0IGEgW3xufF1cbiAgbGV0IHNsaWNlX3JpZ2h0XzIgYSBuID0gR2VuYXJyYXkuc2xpY2VfcmlnaHQgYSBbfG58XVxuICBleHRlcm5hbCBibGl0OiAoJ2EsICdiLCAnYykgdCAtPiAoJ2EsICdiLCAnYykgdCAtPiB1bml0ID0gXCJjYW1sX2JhX2JsaXRcIlxuICBleHRlcm5hbCBmaWxsOiAoJ2EsICdiLCAnYykgdCAtPiAnYSAtPiB1bml0ID0gXCJjYW1sX2JhX2ZpbGxcIlxuICBsZXQgY19pbml0IGFyciBkaW0xIGRpbTIgZGltMyBmID1cbiAgICBmb3IgaSA9IDAgdG8gcHJlZCBkaW0xIGRvXG4gICAgICBmb3IgaiA9IDAgdG8gcHJlZCBkaW0yIGRvXG4gICAgICAgIGZvciBrID0gMCB0byBwcmVkIGRpbTMgZG9cbiAgICAgICAgICB1bnNhZmVfc2V0IGFyciBpIGogayAoZiBpIGogaylcbiAgICAgICAgZG9uZVxuICAgICAgZG9uZVxuICAgIGRvbmVcbiAgbGV0IGZvcnRyYW5faW5pdCBhcnIgZGltMSBkaW0yIGRpbTMgZiA9XG4gICAgZm9yIGsgPSAxIHRvIGRpbTMgZG9cbiAgICAgIGZvciBqID0gMSB0byBkaW0yIGRvXG4gICAgICAgIGZvciBpID0gMSB0byBkaW0xIGRvXG4gICAgICAgICAgdW5zYWZlX3NldCBhcnIgaSBqIGsgKGYgaSBqIGspXG4gICAgICAgIGRvbmVcbiAgICAgIGRvbmVcbiAgICBkb25lXG4gIGxldCBpbml0ICh0eXBlIHQpIGtpbmQgKGxheW91dCA6IHQgbGF5b3V0KSBkaW0xIGRpbTIgZGltMyBmID1cbiAgICBsZXQgYXJyID0gY3JlYXRlIGtpbmQgbGF5b3V0IGRpbTEgZGltMiBkaW0zIGluXG4gICAgbWF0Y2ggbGF5b3V0IHdpdGhcbiAgICB8IENfbGF5b3V0IC0+IGNfaW5pdCBhcnIgZGltMSBkaW0yIGRpbTMgZjsgYXJyXG4gICAgfCBGb3J0cmFuX2xheW91dCAtPiBmb3J0cmFuX2luaXQgYXJyIGRpbTEgZGltMiBkaW0zIGY7IGFyclxuICBsZXQgb2ZfYXJyYXkgKHR5cGUgdCkga2luZCAobGF5b3V0OiB0IGxheW91dCkgZGF0YSA9XG4gICAgbGV0IGRpbTEgPSBBcnJheS5sZW5ndGggZGF0YSBpblxuICAgIGxldCBkaW0yID0gaWYgZGltMSA9IDAgdGhlbiAwIGVsc2UgQXJyYXkubGVuZ3RoIGRhdGEuKDApIGluXG4gICAgbGV0IGRpbTMgPSBpZiBkaW0yID0gMCB0aGVuIDAgZWxzZSBBcnJheS5sZW5ndGggZGF0YS4oMCkuKDApIGluXG4gICAgbGV0IGJhID0gY3JlYXRlIGtpbmQgbGF5b3V0IGRpbTEgZGltMiBkaW0zIGluXG4gICAgbGV0IG9mcyA9XG4gICAgICBtYXRjaCBsYXlvdXQgd2l0aFxuICAgICAgICBDX2xheW91dCAtPiAwXG4gICAgICB8IEZvcnRyYW5fbGF5b3V0IC0+IDFcbiAgICBpblxuICAgIGZvciBpID0gMCB0byBkaW0xIC0gMSBkb1xuICAgICAgbGV0IHJvdyA9IGRhdGEuKGkpIGluXG4gICAgICBpZiBBcnJheS5sZW5ndGggcm93IDw+IGRpbTIgdGhlblxuICAgICAgICBpbnZhbGlkX2FyZyhcIkJpZ2FycmF5LkFycmF5My5vZl9hcnJheTogbm9uLWN1YmljIGRhdGFcIik7XG4gICAgICBmb3IgaiA9IDAgdG8gZGltMiAtIDEgZG9cbiAgICAgICAgbGV0IGNvbCA9IHJvdy4oaikgaW5cbiAgICAgICAgaWYgQXJyYXkubGVuZ3RoIGNvbCA8PiBkaW0zIHRoZW5cbiAgICAgICAgICBpbnZhbGlkX2FyZyhcIkJpZ2FycmF5LkFycmF5My5vZl9hcnJheTogbm9uLWN1YmljIGRhdGFcIik7XG4gICAgICAgIGZvciBrID0gMCB0byBkaW0zIC0gMSBkb1xuICAgICAgICAgIHVuc2FmZV9zZXQgYmEgKGkgKyBvZnMpIChqICsgb2ZzKSAoayArIG9mcykgY29sLihrKVxuICAgICAgICBkb25lXG4gICAgICBkb25lXG4gICAgZG9uZTtcbiAgICBiYVxuZW5kXG5cbmV4dGVybmFsIGdlbmFycmF5X29mX2FycmF5MDogKCdhLCAnYiwgJ2MpIEFycmF5MC50IC0+ICgnYSwgJ2IsICdjKSBHZW5hcnJheS50XG4gICA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIGdlbmFycmF5X29mX2FycmF5MTogKCdhLCAnYiwgJ2MpIEFycmF5MS50IC0+ICgnYSwgJ2IsICdjKSBHZW5hcnJheS50XG4gICA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIGdlbmFycmF5X29mX2FycmF5MjogKCdhLCAnYiwgJ2MpIEFycmF5Mi50IC0+ICgnYSwgJ2IsICdjKSBHZW5hcnJheS50XG4gICA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIGdlbmFycmF5X29mX2FycmF5MzogKCdhLCAnYiwgJ2MpIEFycmF5My50IC0+ICgnYSwgJ2IsICdjKSBHZW5hcnJheS50XG4gICA9IFwiJWlkZW50aXR5XCJcbmxldCBhcnJheTBfb2ZfZ2VuYXJyYXkgYSA9XG4gIGlmIEdlbmFycmF5Lm51bV9kaW1zIGEgPSAwIHRoZW4gYVxuICBlbHNlIGludmFsaWRfYXJnIFwiQmlnYXJyYXkuYXJyYXkwX29mX2dlbmFycmF5XCJcbmxldCBhcnJheTFfb2ZfZ2VuYXJyYXkgYSA9XG4gIGlmIEdlbmFycmF5Lm51bV9kaW1zIGEgPSAxIHRoZW4gYVxuICBlbHNlIGludmFsaWRfYXJnIFwiQmlnYXJyYXkuYXJyYXkxX29mX2dlbmFycmF5XCJcbmxldCBhcnJheTJfb2ZfZ2VuYXJyYXkgYSA9XG4gIGlmIEdlbmFycmF5Lm51bV9kaW1zIGEgPSAyIHRoZW4gYVxuICBlbHNlIGludmFsaWRfYXJnIFwiQmlnYXJyYXkuYXJyYXkyX29mX2dlbmFycmF5XCJcbmxldCBhcnJheTNfb2ZfZ2VuYXJyYXkgYSA9XG4gIGlmIEdlbmFycmF5Lm51bV9kaW1zIGEgPSAzIHRoZW4gYVxuICBlbHNlIGludmFsaWRfYXJnIFwiQmlnYXJyYXkuYXJyYXkzX29mX2dlbmFycmF5XCJcblxuZXh0ZXJuYWwgcmVzaGFwZTpcbiAgICgnYSwgJ2IsICdjKSBHZW5hcnJheS50IC0+IGludCBhcnJheSAtPiAoJ2EsICdiLCAnYykgR2VuYXJyYXkudFxuICAgPSBcImNhbWxfYmFfcmVzaGFwZVwiXG5sZXQgcmVzaGFwZV8wIGEgPSByZXNoYXBlIGEgW3x8XVxubGV0IHJlc2hhcGVfMSBhIGRpbTEgPSByZXNoYXBlIGEgW3xkaW0xfF1cbmxldCByZXNoYXBlXzIgYSBkaW0xIGRpbTIgPSByZXNoYXBlIGEgW3xkaW0xO2RpbTJ8XVxubGV0IHJlc2hhcGVfMyBhIGRpbTEgZGltMiBkaW0zID0gcmVzaGFwZSBhIFt8ZGltMTtkaW0yO2RpbTN8XVxuXG4oKiBGb3JjZSBjYW1sX2JhX2dldF97MSwyLDMsTn0gdG8gYmUgbGlua2VkIGluLCBzaW5jZSB3ZSBkb24ndCByZWZlclxuICAgdG8gdGhvc2UgcHJpbWl0aXZlcyBkaXJlY3RseSBpbiB0aGlzIGZpbGUgKilcblxubGV0IF8gPVxuICBsZXQgXyA9IEdlbmFycmF5LmdldCBpblxuICBsZXQgXyA9IEFycmF5MS5nZXQgaW5cbiAgbGV0IF8gPSBBcnJheTIuZ2V0IGluXG4gIGxldCBfID0gQXJyYXkzLmdldCBpblxuICAoKVxuXG5bQEBAb2NhbWwud2FybmluZyBcIi0zMlwiXVxuZXh0ZXJuYWwgZ2V0MTogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2JhX2dldF8xXCJcbmV4dGVybmFsIGdldDI6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9iYV9nZXRfMlwiXG5leHRlcm5hbCBnZXQzOiB1bml0IC0+IHVuaXQgPSBcImNhbWxfYmFfZ2V0XzNcIlxuZXh0ZXJuYWwgc2V0MTogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2JhX3NldF8xXCJcbmV4dGVybmFsIHNldDI6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9iYV9zZXRfMlwiXG5leHRlcm5hbCBzZXQzOiB1bml0IC0+IHVuaXQgPSBcImNhbWxfYmFfc2V0XzNcIlxuIiwiXG50eXBlIHBrbW5fY2hhciA9IFVudXNlZCB8IFVucmVhZGFibGUgb2Ygc3RyaW5nXG4gICAgICAgICAgICAgICB8IFVuYXZhaWxhYmxlIG9mIHN0cmluZyB8IEF2YWlsYWJsZSBvZiBzdHJpbmdcblxubGV0IGNoYXJzZXRfZW5nID1cbiAgW3xcbiAgKCogMHgwLiAqKVxuICBBdmFpbGFibGUgICBcIl9cIiA7IFVuYXZhaWxhYmxlIFwiw4BcIiA7IFVuYXZhaWxhYmxlIFwiw4FcIiA7IFVuYXZhaWxhYmxlIFwiw4JcIiA7XG4gIFVuYXZhaWxhYmxlIFwiw4dcIiA7IFVuYXZhaWxhYmxlIFwiw4hcIiA7IFVuYXZhaWxhYmxlIFwiw4lcIiA7IFVuYXZhaWxhYmxlIFwiw4pcIiA7XG4gIFVuYXZhaWxhYmxlIFwiw4tcIiA7IFVuYXZhaWxhYmxlIFwiw4xcIiA7IFVudXNlZCAgICAgICAgICA7IFVuYXZhaWxhYmxlIFwiw45cIiA7XG4gIFVuYXZhaWxhYmxlIFwiw49cIiA7IFVuYXZhaWxhYmxlIFwiw5JcIiA7IFVuYXZhaWxhYmxlIFwiw5NcIiA7IFVuYXZhaWxhYmxlIFwiw5RcIiA7XG4gICgqIDB4MS4gKilcbiAgVW5hdmFpbGFibGUgXCLFklwiIDsgVW5hdmFpbGFibGUgXCLDmVwiIDsgVW5hdmFpbGFibGUgXCLDmlwiIDsgVW5hdmFpbGFibGUgXCLDm1wiIDtcbiAgVW5hdmFpbGFibGUgXCLDkVwiIDsgVW5hdmFpbGFibGUgXCLDn1wiIDsgVW5hdmFpbGFibGUgXCLDoFwiIDsgVW5hdmFpbGFibGUgXCLDoVwiIDtcbiAgVW51c2VkICAgICAgICAgIDsgVW5hdmFpbGFibGUgXCLDp1wiIDsgVW5hdmFpbGFibGUgXCLDqFwiIDsgVW5hdmFpbGFibGUgXCLDqVwiIDtcbiAgVW5hdmFpbGFibGUgXCLDqlwiIDsgVW5hdmFpbGFibGUgXCLDq1wiIDsgVW5hdmFpbGFibGUgXCLDrFwiIDsgVW51c2VkICAgICAgICAgIDtcbiAgKCogMHgyLiAqKVxuICBVbmF2YWlsYWJsZSBcIsOuXCIgIDsgVW5hdmFpbGFibGUgXCLDr1wiIDsgVW5hdmFpbGFibGUgXCLDslwiIDsgVW5hdmFpbGFibGUgXCLDs1wiIDtcbiAgVW5hdmFpbGFibGUgXCLDtFwiICA7IFVuYXZhaWxhYmxlIFwixZNcIiA7IFVuYXZhaWxhYmxlIFwiw7lcIiA7IFVuYXZhaWxhYmxlIFwiw7pcIiA7XG4gIFVuYXZhaWxhYmxlIFwiw7tcIiAgOyBVbmF2YWlsYWJsZSBcIsOxXCIgOyBVbmF2YWlsYWJsZSBcIsK6XCIgOyBVbmF2YWlsYWJsZSBcIsKqXCIgO1xuICBVbmF2YWlsYWJsZSBcIuG1icqzXCIgOyBVbmF2YWlsYWJsZSBcIiZcIiA7IFVuYXZhaWxhYmxlIFwiK1wiIDsgVW51c2VkICAgICAgICAgIDtcbiAgKCogMHgzLiAqKVxuICBVbnVzZWQgICAgICAgICAgIDsgVW51c2VkICAgICAgICAgIDsgVW51c2VkICAgICAgICAgIDsgVW51c2VkICAgICAgICAgIDtcbiAgVW5hdmFpbGFibGUgXCJMdlwiIDsgVW5hdmFpbGFibGUgXCI9XCIgOyBVbmF2YWlsYWJsZSBcIjtcIiA7IFVudXNlZCAgICAgICAgICA7XG4gIFVudXNlZCAgICAgICAgICAgOyBVbnVzZWQgICAgICAgICAgOyBVbnVzZWQgICAgICAgICAgOyBVbnVzZWQgICAgICAgICAgO1xuICBVbnVzZWQgICAgICAgICAgIDsgVW51c2VkICAgICAgICAgIDsgVW51c2VkICAgICAgICAgIDsgVW51c2VkICAgICAgICAgIDtcbiAgKCogMHg0LiAqKVxuICBVbnVzZWQgICAgICAgICAgOyBVbnVzZWQgICAgICAgICAgOyBVbnVzZWQgICAgICAgICAgOyBVbnVzZWQgICAgICAgICAgO1xuICBVbnVzZWQgICAgICAgICAgOyBVbnVzZWQgICAgICAgICAgOyBVbnVzZWQgICAgICAgICAgOyBVbnVzZWQgICAgICAgICAgO1xuICBVbnVzZWQgICAgICAgICAgOyBVbnVzZWQgICAgICAgICAgOyBVbnVzZWQgICAgICAgICAgOyBVbnVzZWQgICAgICAgICAgO1xuICBVbnVzZWQgICAgICAgICAgOyBVbnVzZWQgICAgICAgICAgOyBVbnVzZWQgICAgICAgICAgOyBVbnVzZWQgICAgICAgICAgO1xuICAoKiAweDUuICopXG4gIFVuYXZhaWxhYmxlIFwi4pavXCIgICA7IFVuYXZhaWxhYmxlIFwiwr9cIiAgICA7IFVuYXZhaWxhYmxlIFwiwqFcIiAgOyBVbmF2YWlsYWJsZSBcIlBLXCIgICA7XG4gIFVuYXZhaWxhYmxlIFwiTU5cIiAgIDsgVW5hdmFpbGFibGUgXCJQT1wiICAgOyBVbmF2YWlsYWJsZSBcIkvDqVwiIDsgVW5yZWFkYWJsZSBcIjB4NTdcIiAgO1xuICBVbnJlYWRhYmxlICBcIjB4NThcIiA7IFVucmVhZGFibGUgXCIweDU5XCIgIDsgVW5hdmFpbGFibGUgXCLDjVwiICA7IFVuYXZhaWxhYmxlIFwiJVwiICAgIDtcbiAgVW5hdmFpbGFibGUgXCIoXCIgICAgOyBVbmF2YWlsYWJsZSBcIilcIiAgICA7IFVudXNlZCAgICAgICAgICAgOyBVbnVzZWQgICAgICAgICAgICAgO1xuICAoKiAweDYuICopXG4gIFVudXNlZCAgICAgICAgICA7IFVudXNlZCAgICAgICAgICA7IFVudXNlZCAgICAgICAgICA7IFVudXNlZCAgICAgICAgICA7XG4gIFVudXNlZCAgICAgICAgICA7IFVudXNlZCAgICAgICAgICA7IFVudXNlZCAgICAgICAgICA7IFVudXNlZCAgICAgICAgICA7XG4gIFVuYXZhaWxhYmxlIFwiw6JcIiA7IFVudXNlZCAgICAgICAgICA7IFVudXNlZCAgICAgICAgICA7IFVudXNlZCAgICAgICAgICA7XG4gIFVudXNlZCAgICAgICAgICA7IFVudXNlZCAgICAgICAgICA7IFVudXNlZCAgICAgICAgICA7IFVuYXZhaWxhYmxlIFwiw61cIiA7XG4gICgqIDB4Ny4gKilcbiAgVW51c2VkICAgICAgICAgIDsgVW51c2VkICAgICAgICAgIDsgVW51c2VkICAgICAgICAgIDsgVW51c2VkICAgICAgICAgIDtcbiAgVW51c2VkICAgICAgICAgIDsgVW51c2VkICAgICAgICAgIDsgVW51c2VkICAgICAgICAgIDsgVW51c2VkICAgICAgICAgIDtcbiAgVW51c2VkICAgICAgICAgIDsgVW5hdmFpbGFibGUgXCLirIZcIiA7IFVuYXZhaWxhYmxlIFwi4qyHXCIgOyBVbmF2YWlsYWJsZSBcIuKshVwiIDtcbiAgVW5hdmFpbGFibGUgXCLinqFcIiA7IFVuYXZhaWxhYmxlIFwiKlwiIDsgVW5hdmFpbGFibGUgXCIqXCIgOyBVbmF2YWlsYWJsZSBcIipcIiA7XG4gICgqIDB4OC4gKilcbiAgVW5hdmFpbGFibGUgXCIqXCIgOyBVbmF2YWlsYWJsZSBcIipcIiA7IFVuYXZhaWxhYmxlIFwiKlwiIDsgVW5hdmFpbGFibGUgXCIqXCIgO1xuICBVbmF2YWlsYWJsZSBcIuG1iVwiIDsgVW5hdmFpbGFibGUgXCI8XCIgOyBVbmF2YWlsYWJsZSBcIj5cIiA7IFVudXNlZCAgICAgICAgICA7XG4gIFVudXNlZCAgICAgICAgICA7IFVudXNlZCAgICAgICAgICA7IFVudXNlZCAgICAgICAgICA7IFVudXNlZCAgICAgICAgICA7XG4gIFVudXNlZCAgICAgICAgICA7IFVudXNlZCAgICAgICAgICA7IFVudXNlZCAgICAgICAgICA7IFVudXNlZCAgICAgICAgICA7XG4gICgqIDB4OS4gKilcbiAgVW51c2VkICAgICAgICAgIDsgVW51c2VkICAgICAgICAgIDsgVW51c2VkICAgICAgICAgIDsgVW51c2VkICAgICAgICAgIDtcbiAgVW51c2VkICAgICAgICAgIDsgVW51c2VkICAgICAgICAgIDsgVW51c2VkICAgICAgICAgIDsgVW51c2VkICAgICAgICAgIDtcbiAgVW51c2VkICAgICAgICAgIDsgVW51c2VkICAgICAgICAgIDsgVW51c2VkICAgICAgICAgIDsgVW51c2VkICAgICAgICAgIDtcbiAgVW51c2VkICAgICAgICAgIDsgVW51c2VkICAgICAgICAgIDsgVW51c2VkICAgICAgICAgIDsgVW51c2VkICAgICAgICAgIDtcbiAgKCogMHhBLiAqKVxuICBVbmF2YWlsYWJsZSBcIsqz4bWJXCIgOyBBdmFpbGFibGUgXCIwXCIgICA7IEF2YWlsYWJsZSBcIjFcIiA7IEF2YWlsYWJsZSBcIjJcIiAgICA7XG4gIEF2YWlsYWJsZSBcIjNcIiAgICA7IEF2YWlsYWJsZSBcIjRcIiAgIDsgQXZhaWxhYmxlIFwiNVwiIDsgQXZhaWxhYmxlIFwiNlwiICAgIDtcbiAgQXZhaWxhYmxlIFwiN1wiICAgIDsgQXZhaWxhYmxlIFwiOFwiICAgOyBBdmFpbGFibGUgXCI5XCIgOyBBdmFpbGFibGUgXCIhXCIgICAgO1xuICBBdmFpbGFibGUgXCI/XCIgICAgOyBBdmFpbGFibGUgXCIuXCIgICA7IEF2YWlsYWJsZSBcIuKAk1wiIDsgVW5hdmFpbGFibGUgXCLjg7tcIiA7XG4gICgqIDB4Qi4gKilcbiAgQXZhaWxhYmxlIFwi4oCmXCIgICAgOyBBdmFpbGFibGUgXCLigJxcIiAgIDsgQXZhaWxhYmxlIFwi4oCdXCIgOyBBdmFpbGFibGUgXCLigJhcIiAgICAgO1xuICBBdmFpbGFibGUgXCLigJlcIiAgICA7IEF2YWlsYWJsZSBcIuKZglwiICAgOyBBdmFpbGFibGUgXCLimYBcIiA7IFVuYXZhaWxhYmxlIFwiUGskXCIgO1xuICBBdmFpbGFibGUgXCIsXCIgICAgOyBVbmF2YWlsYWJsZSBcIsOXXCIgOyBBdmFpbGFibGUgXCIvXCIgOyBBdmFpbGFibGUgXCJBXCIgICAgIDtcbiAgQXZhaWxhYmxlIFwiQlwiICAgIDsgQXZhaWxhYmxlIFwiQ1wiICAgOyBBdmFpbGFibGUgXCJEXCIgOyBBdmFpbGFibGUgXCJFXCIgICAgIDtcbiAgKCogMHhDLiAqKVxuICBBdmFpbGFibGUgXCJGXCIgICAgOyBBdmFpbGFibGUgXCJHXCIgICA7IEF2YWlsYWJsZSBcIkhcIiA7IEF2YWlsYWJsZSBcIklcIiAgICAgO1xuICBBdmFpbGFibGUgXCJKXCIgICAgOyBBdmFpbGFibGUgXCJLXCIgICA7IEF2YWlsYWJsZSBcIkxcIiA7IEF2YWlsYWJsZSBcIk1cIiAgICAgO1xuICBBdmFpbGFibGUgXCJOXCIgICAgOyBBdmFpbGFibGUgXCJPXCIgICA7IEF2YWlsYWJsZSBcIlBcIiA7IEF2YWlsYWJsZSBcIlFcIiAgICAgO1xuICBBdmFpbGFibGUgXCJSXCIgICAgOyBBdmFpbGFibGUgXCJTXCIgICA7IEF2YWlsYWJsZSBcIlRcIiA7IEF2YWlsYWJsZSBcIlVcIiAgICAgO1xuICAoKiAweEQuICopXG4gIEF2YWlsYWJsZSBcIlZcIiAgICA7IEF2YWlsYWJsZSBcIldcIiAgIDsgQXZhaWxhYmxlIFwiWFwiIDsgQXZhaWxhYmxlIFwiWVwiICAgICA7XG4gIEF2YWlsYWJsZSBcIlpcIiAgICA7IEF2YWlsYWJsZSBcImFcIiAgIDsgQXZhaWxhYmxlIFwiYlwiIDsgQXZhaWxhYmxlIFwiY1wiICAgICA7XG4gIEF2YWlsYWJsZSBcImRcIiAgICA7IEF2YWlsYWJsZSBcImVcIiAgIDsgQXZhaWxhYmxlIFwiZlwiIDsgQXZhaWxhYmxlIFwiZ1wiICAgICA7XG4gIEF2YWlsYWJsZSBcImhcIiAgICA7IEF2YWlsYWJsZSBcImlcIiAgIDsgQXZhaWxhYmxlIFwialwiIDsgQXZhaWxhYmxlIFwia1wiICAgICA7XG4gICgqIDB4RS4gKilcbiAgQXZhaWxhYmxlIFwibFwiICAgIDsgQXZhaWxhYmxlIFwibVwiICAgOyBBdmFpbGFibGUgXCJuXCIgOyBBdmFpbGFibGUgXCJvXCIgICAgIDtcbiAgQXZhaWxhYmxlIFwicFwiICAgIDsgQXZhaWxhYmxlIFwicVwiICAgOyBBdmFpbGFibGUgXCJyXCIgOyBBdmFpbGFibGUgXCJzXCIgICAgIDtcbiAgQXZhaWxhYmxlIFwidFwiICAgIDsgQXZhaWxhYmxlIFwidVwiICAgOyBBdmFpbGFibGUgXCJ2XCIgOyBBdmFpbGFibGUgXCJ3XCIgICAgIDtcbiAgQXZhaWxhYmxlIFwieFwiICAgIDsgQXZhaWxhYmxlIFwieVwiICAgOyBBdmFpbGFibGUgXCJ6XCIgOyBVbmF2YWlsYWJsZSBcIuKWtlwiICA7XG4gICgqIDB4Ri4gKilcbiAgVW5hdmFpbGFibGUgXCI6XCIgICA7IFVuYXZhaWxhYmxlIFwiw4RcIiAgIDsgVW5hdmFpbGFibGUgXCLDllwiICAgOyBVbmF2YWlsYWJsZSBcIsOcXCIgICA7XG4gIFVuYXZhaWxhYmxlIFwiw6RcIiAgIDsgVW5hdmFpbGFibGUgXCLDtlwiICAgOyBVbmF2YWlsYWJsZSBcIsO8XCIgICA7IFVudXNlZCAgICAgICAgICAgIDtcbiAgVW51c2VkICAgICAgICAgICAgOyBVbnVzZWQgICAgICAgICAgICA7IFVucmVhZGFibGUgXCIweEZBXCIgOyBVbnJlYWRhYmxlIFwiMHhGQlwiIDtcbiAgVW5yZWFkYWJsZSBcIjB4RkNcIiA7IFVucmVhZGFibGUgXCIweEZEXCIgOyBVbnJlYWRhYmxlIFwiMHhGRVwiIDsgVW5yZWFkYWJsZSBcIjB4RkZcIiA7XG4gIHxdXG5cbmxldCBjaGFyc2V0X2l0YSA9IEFycmF5LmNvcHkgY2hhcnNldF9lbmdcbmxldCBjaGFyc2V0X3NwYSA9IEFycmF5LmNvcHkgY2hhcnNldF9lbmdcbmxldCBjaGFyc2V0X2dlciA9XG4gIGxldCBjcyA9IEFycmF5LmNvcHkgY2hhcnNldF9lbmcgaW5cbiAgY3MuKDB4QjEpIDwtIEF2YWlsYWJsZSBcIuKAnlwiIDtcbiAgY3MuKDB4QjIpIDwtIEF2YWlsYWJsZSBcIuKAnFwiIDtcbiAgY3NcbmxldCBjaGFyc2V0X2ZyYSA9XG4gIGxldCBjcyA9IEFycmF5LmNvcHkgY2hhcnNldF9lbmcgaW5cbiAgY3MuKDB4QjEpIDwtIEF2YWlsYWJsZSBcIsKrXCIgO1xuICBjcy4oMHhCMikgPC0gQXZhaWxhYmxlIFwiwrtcIiA7XG4gIGNzXG5cbmxldCBjaGFyc2V0X2phcCA9XG4gIFt8XG4gICgqIDB4MC4gKilcbiAgQXZhaWxhYmxlIFwiX1wiICA7IEF2YWlsYWJsZSBcIuOBglwiIDsgQXZhaWxhYmxlIFwi44GEXCIgOyBBdmFpbGFibGUgXCLjgYZcIiA7XG4gIEF2YWlsYWJsZSBcIuOBiFwiIDsgQXZhaWxhYmxlIFwi44GKXCIgOyBBdmFpbGFibGUgXCLjgYtcIiA7IEF2YWlsYWJsZSBcIuOBjVwiIDtcbiAgQXZhaWxhYmxlIFwi44GPXCIgOyBBdmFpbGFibGUgXCLjgZFcIiA7IEF2YWlsYWJsZSBcIuOBk1wiIDsgQXZhaWxhYmxlIFwi44GVXCIgO1xuICBBdmFpbGFibGUgXCLjgZdcIiA7IEF2YWlsYWJsZSBcIuOBmVwiIDsgQXZhaWxhYmxlIFwi44GbXCIgOyBBdmFpbGFibGUgXCLjgZ1cIiA7XG4gICgqIDB4MS4gKilcbiAgQXZhaWxhYmxlIFwi44GfXCIgOyBBdmFpbGFibGUgXCLjgaFcIiA7IEF2YWlsYWJsZSBcIuOBpFwiIDsgQXZhaWxhYmxlIFwi44GmXCIgO1xuICBBdmFpbGFibGUgXCLjgahcIiA7IEF2YWlsYWJsZSBcIuOBqlwiIDsgQXZhaWxhYmxlIFwi44GrXCIgOyBBdmFpbGFibGUgXCLjgaxcIiA7XG4gIEF2YWlsYWJsZSBcIuOBrVwiIDsgQXZhaWxhYmxlIFwi44GuXCIgOyBBdmFpbGFibGUgXCLjga9cIiA7IEF2YWlsYWJsZSBcIuOBslwiIDtcbiAgQXZhaWxhYmxlIFwi44G1XCIgOyBBdmFpbGFibGUgXCLjgbhcIiA7IEF2YWlsYWJsZSBcIuOBu1wiIDsgQXZhaWxhYmxlIFwi44G+XCIgO1xuICAoKiAweDIuICopXG4gIEF2YWlsYWJsZSBcIuOBv1wiIDsgQXZhaWxhYmxlIFwi44KAXCIgOyBBdmFpbGFibGUgXCLjgoFcIiA7IEF2YWlsYWJsZSBcIuOCglwiIDtcbiAgQXZhaWxhYmxlIFwi44KEXCIgOyBBdmFpbGFibGUgXCLjgoZcIiA7IEF2YWlsYWJsZSBcIuOCiFwiIDsgQXZhaWxhYmxlIFwi44KJXCIgO1xuICBBdmFpbGFibGUgXCLjgopcIiA7IEF2YWlsYWJsZSBcIuOCi1wiIDsgQXZhaWxhYmxlIFwi44KMXCIgOyBBdmFpbGFibGUgXCLjgo1cIiA7XG4gIEF2YWlsYWJsZSBcIuOCj1wiIDsgQXZhaWxhYmxlIFwi44KSXCIgOyBBdmFpbGFibGUgXCLjgpNcIiA7IEF2YWlsYWJsZSBcIuOBgVwiIDtcbiAgKCogMHgzLiAqKVxuICBBdmFpbGFibGUgXCLjgYNcIiA7IEF2YWlsYWJsZSBcIuOBhVwiIDsgQXZhaWxhYmxlIFwi44GHXCIgOyBBdmFpbGFibGUgXCLjgYlcIiA7XG4gIEF2YWlsYWJsZSBcIuOCg1wiIDsgQXZhaWxhYmxlIFwi44KFXCIgOyBBdmFpbGFibGUgXCLjgodcIiA7IEF2YWlsYWJsZSBcIuOBjFwiIDtcbiAgQXZhaWxhYmxlIFwi44GOXCIgOyBBdmFpbGFibGUgXCLjgZBcIiA7IEF2YWlsYWJsZSBcIuOBklwiIDsgQXZhaWxhYmxlIFwi44GUXCIgO1xuICBBdmFpbGFibGUgXCLjgZZcIiA7IEF2YWlsYWJsZSBcIuOBmFwiIDsgQXZhaWxhYmxlIFwi44GaXCIgOyBBdmFpbGFibGUgXCLjgZxcIiA7XG4gICgqIDB4NC4gKilcbiAgQXZhaWxhYmxlIFwi44GeXCIgOyBBdmFpbGFibGUgXCLjgaBcIiA7IEF2YWlsYWJsZSBcIuOBolwiIDsgQXZhaWxhYmxlIFwi44GlXCIgO1xuICBBdmFpbGFibGUgXCLjgadcIiA7IEF2YWlsYWJsZSBcIuOBqVwiIDsgQXZhaWxhYmxlIFwi44GwXCIgOyBBdmFpbGFibGUgXCLjgbNcIiA7XG4gIEF2YWlsYWJsZSBcIuOBtlwiIDsgQXZhaWxhYmxlIFwi44G5XCIgOyBBdmFpbGFibGUgXCLjgbxcIiA7IEF2YWlsYWJsZSBcIuOBsVwiIDtcbiAgQXZhaWxhYmxlIFwi44G0XCIgOyBBdmFpbGFibGUgXCLjgbdcIiA7IEF2YWlsYWJsZSBcIuOBulwiIDsgQXZhaWxhYmxlIFwi44G9XCIgO1xuICAoKiAweDUuICopXG4gIEF2YWlsYWJsZSBcIuOBo1wiIDsgQXZhaWxhYmxlIFwi44KiXCIgOyBBdmFpbGFibGUgXCLjgqRcIiA7IEF2YWlsYWJsZSBcIuOCplwiIDtcbiAgQXZhaWxhYmxlIFwi44KoXCIgOyBBdmFpbGFibGUgXCLjgqpcIiA7IEF2YWlsYWJsZSBcIuOCq1wiIDsgQXZhaWxhYmxlIFwi44KtXCIgO1xuICBBdmFpbGFibGUgXCLjgq9cIiA7IEF2YWlsYWJsZSBcIuOCsVwiIDsgQXZhaWxhYmxlIFwi44KzXCIgOyBBdmFpbGFibGUgXCLjgrVcIiA7XG4gIEF2YWlsYWJsZSBcIuOCt1wiIDsgQXZhaWxhYmxlIFwi44K5XCIgOyBBdmFpbGFibGUgXCLjgrtcIiA7IEF2YWlsYWJsZSBcIuOCvVwiIDtcbiAgKCogMHg2LiAqKVxuICBBdmFpbGFibGUgXCLjgr9cIiA7IEF2YWlsYWJsZSBcIuODgVwiIDsgQXZhaWxhYmxlIFwi44OEXCIgOyBBdmFpbGFibGUgXCLjg4ZcIiA7XG4gIEF2YWlsYWJsZSBcIuODiFwiIDsgQXZhaWxhYmxlIFwi44OKXCIgOyBBdmFpbGFibGUgXCLjg4tcIiA7IEF2YWlsYWJsZSBcIuODjFwiIDtcbiAgQXZhaWxhYmxlIFwi44ONXCIgOyBBdmFpbGFibGUgXCLjg45cIiA7IEF2YWlsYWJsZSBcIuODj1wiIDsgQXZhaWxhYmxlIFwi44OSXCIgO1xuICBBdmFpbGFibGUgXCLjg5VcIiA7IEF2YWlsYWJsZSBcIuODmFwiIDsgQXZhaWxhYmxlIFwi44ObXCIgOyBBdmFpbGFibGUgXCLjg55cIiA7XG4gICgqIDB4Ny4gKilcbiAgQXZhaWxhYmxlIFwi44OfXCIgOyBBdmFpbGFibGUgXCLjg6BcIiA7IEF2YWlsYWJsZSBcIuODoVwiIDsgQXZhaWxhYmxlIFwi44OiXCIgO1xuICBBdmFpbGFibGUgXCLjg6RcIiA7IEF2YWlsYWJsZSBcIuODplwiIDsgQXZhaWxhYmxlIFwi44OoXCIgOyBBdmFpbGFibGUgXCLjg6lcIiA7XG4gIEF2YWlsYWJsZSBcIuODqlwiIDsgQXZhaWxhYmxlIFwi44OrXCIgOyBBdmFpbGFibGUgXCLjg6xcIiA7IEF2YWlsYWJsZSBcIuODrVwiIDtcbiAgQXZhaWxhYmxlIFwi44OvXCIgOyBBdmFpbGFibGUgXCLjg7JcIiA7IEF2YWlsYWJsZSBcIuODs1wiIDsgQXZhaWxhYmxlIFwi44KhXCIgO1xuICAoKiAweDguICopXG4gIEF2YWlsYWJsZSBcIuOCo1wiIDsgQXZhaWxhYmxlIFwi44KlXCIgOyBBdmFpbGFibGUgXCLjgqdcIiA7IEF2YWlsYWJsZSBcIuOCqVwiIDtcbiAgQXZhaWxhYmxlIFwi44OjXCIgOyBBdmFpbGFibGUgXCLjg6VcIiA7IEF2YWlsYWJsZSBcIuODp1wiIDsgQXZhaWxhYmxlIFwi44KsXCIgO1xuICBBdmFpbGFibGUgXCLjgq5cIiA7IEF2YWlsYWJsZSBcIuOCsFwiIDsgQXZhaWxhYmxlIFwi44KyXCIgOyBBdmFpbGFibGUgXCLjgrRcIiA7XG4gIEF2YWlsYWJsZSBcIuOCtlwiIDsgQXZhaWxhYmxlIFwi44K4XCIgOyBBdmFpbGFibGUgXCLjgrpcIiA7IEF2YWlsYWJsZSBcIuOCvFwiIDtcbiAgKCogMHg5LiAqKVxuICBBdmFpbGFibGUgXCLjgr5cIiA7IEF2YWlsYWJsZSBcIuODgFwiIDsgQXZhaWxhYmxlIFwi44OCXCIgOyBBdmFpbGFibGUgXCLjg4VcIiA7XG4gIEF2YWlsYWJsZSBcIuODh1wiIDsgQXZhaWxhYmxlIFwi44OJXCIgOyBBdmFpbGFibGUgXCLjg5BcIiA7IEF2YWlsYWJsZSBcIuODk1wiIDtcbiAgQXZhaWxhYmxlIFwi44OWXCIgOyBBdmFpbGFibGUgXCLjg5lcIiA7IEF2YWlsYWJsZSBcIuODnFwiIDsgQXZhaWxhYmxlIFwi44ORXCIgO1xuICBBdmFpbGFibGUgXCLjg5RcIiA7IEF2YWlsYWJsZSBcIuODl1wiIDsgQXZhaWxhYmxlIFwi44OaXCIgOyBBdmFpbGFibGUgXCLjg51cIiA7XG4gICgqIDB4QS4gKilcbiAgQXZhaWxhYmxlIFwi44ODXCIgICA7IEF2YWlsYWJsZSBcIjBcIiAgIDsgQXZhaWxhYmxlIFwiMVwiIDsgQXZhaWxhYmxlIFwiMlwiICAgIDtcbiAgQXZhaWxhYmxlIFwiM1wiICAgIDsgQXZhaWxhYmxlIFwiNFwiICAgOyBBdmFpbGFibGUgXCI1XCIgOyBBdmFpbGFibGUgXCI2XCIgICAgO1xuICBBdmFpbGFibGUgXCI3XCIgICAgOyBBdmFpbGFibGUgXCI4XCIgICA7IEF2YWlsYWJsZSBcIjlcIiA7IEF2YWlsYWJsZSBcIu+8gVwiICAgO1xuICBBdmFpbGFibGUgXCLvvJ9cIiAgIDsgQXZhaWxhYmxlIFwi44CCXCIgIDsgQXZhaWxhYmxlIFwi44O8XCI7IEF2YWlsYWJsZSBcIuODu1wiICAgIDtcbiAgKCogMHhCLiAqKVxuICBBdmFpbGFibGUgXCLigKVcIiAgICA7IEF2YWlsYWJsZSBcIuOAjlwiICA7IEF2YWlsYWJsZSBcIuOAj1wiOyBBdmFpbGFibGUgXCLjgIxcIiAgICA7XG4gIEF2YWlsYWJsZSBcIuOAjVwiICAgOyBBdmFpbGFibGUgXCLimYJcIiAgIDsgQXZhaWxhYmxlIFwi4pmAXCIgOyBVbmF2YWlsYWJsZSBcIuWGhlwiICA7XG4gIFVuYXZhaWxhYmxlIFwiLlwiICA7IFVuYXZhaWxhYmxlIFwiw5dcIiA7IEF2YWlsYWJsZSBcIi9cIiA7IEF2YWlsYWJsZSBcIkFcIiAgICAgO1xuICBBdmFpbGFibGUgXCJCXCIgICAgOyBBdmFpbGFibGUgXCJDXCIgICA7IEF2YWlsYWJsZSBcIkRcIiA7IEF2YWlsYWJsZSBcIkVcIiAgICAgO1xuICAoKiAweEMuICopXG4gIEF2YWlsYWJsZSBcIkZcIiAgICA7IEF2YWlsYWJsZSBcIkdcIiAgIDsgQXZhaWxhYmxlIFwiSFwiIDsgQXZhaWxhYmxlIFwiSVwiICAgICA7XG4gIEF2YWlsYWJsZSBcIkpcIiAgICA7IEF2YWlsYWJsZSBcIktcIiAgIDsgQXZhaWxhYmxlIFwiTFwiIDsgQXZhaWxhYmxlIFwiTVwiICAgICA7XG4gIEF2YWlsYWJsZSBcIk5cIiAgICA7IEF2YWlsYWJsZSBcIk9cIiAgIDsgQXZhaWxhYmxlIFwiUFwiIDsgQXZhaWxhYmxlIFwiUVwiICAgICA7XG4gIEF2YWlsYWJsZSBcIlJcIiAgICA7IEF2YWlsYWJsZSBcIlNcIiAgIDsgQXZhaWxhYmxlIFwiVFwiIDsgQXZhaWxhYmxlIFwiVVwiICAgICA7XG4gICgqIDB4RC4gKilcbiAgQXZhaWxhYmxlIFwiVlwiICAgIDsgQXZhaWxhYmxlIFwiV1wiICAgOyBBdmFpbGFibGUgXCJYXCIgOyBBdmFpbGFibGUgXCJZXCIgICAgIDtcbiAgQXZhaWxhYmxlIFwiWlwiICAgIDsgQXZhaWxhYmxlIFwiYVwiICAgOyBBdmFpbGFibGUgXCJiXCIgOyBBdmFpbGFibGUgXCJjXCIgICAgIDtcbiAgQXZhaWxhYmxlIFwiZFwiICAgIDsgQXZhaWxhYmxlIFwiZVwiICAgOyBBdmFpbGFibGUgXCJmXCIgOyBBdmFpbGFibGUgXCJnXCIgICAgIDtcbiAgQXZhaWxhYmxlIFwiaFwiICAgIDsgQXZhaWxhYmxlIFwiaVwiICAgOyBBdmFpbGFibGUgXCJqXCIgOyBBdmFpbGFibGUgXCJrXCIgICAgIDtcbiAgKCogMHhFLiAqKVxuICBBdmFpbGFibGUgXCJsXCIgICAgOyBBdmFpbGFibGUgXCJtXCIgICA7IEF2YWlsYWJsZSBcIm5cIiA7IEF2YWlsYWJsZSBcIm9cIiAgICAgO1xuICBBdmFpbGFibGUgXCJwXCIgICAgOyBBdmFpbGFibGUgXCJxXCIgICA7IEF2YWlsYWJsZSBcInJcIiA7IEF2YWlsYWJsZSBcInNcIiAgICAgO1xuICBBdmFpbGFibGUgXCJ0XCIgICAgOyBBdmFpbGFibGUgXCJ1XCIgICA7IEF2YWlsYWJsZSBcInZcIiA7IEF2YWlsYWJsZSBcIndcIiAgICAgO1xuICBBdmFpbGFibGUgXCJ4XCIgICAgOyBBdmFpbGFibGUgXCJ5XCIgICA7IEF2YWlsYWJsZSBcInpcIiA7IFVuYXZhaWxhYmxlIFwi4pa2XCIgIDtcbiAgKCogMHhGLiAqKVxuICBVbmF2YWlsYWJsZSBcIjpcIiAgIDsgVW5hdmFpbGFibGUgXCLDhFwiICAgOyBVbmF2YWlsYWJsZSBcIsOWXCIgICA7IFVuYXZhaWxhYmxlIFwiw5xcIiAgIDtcbiAgVW5hdmFpbGFibGUgXCLDpFwiICAgOyBVbmF2YWlsYWJsZSBcIsO2XCIgICA7IFVuYXZhaWxhYmxlIFwiw7xcIiAgIDsgVW51c2VkICAgICAgICAgICAgO1xuICBVbnVzZWQgICAgICAgICAgICA7IFVudXNlZCAgICAgICAgICAgIDsgVW5yZWFkYWJsZSBcIjB4RkFcIiA7IFVucmVhZGFibGUgXCIweEZCXCIgO1xuICBVbnJlYWRhYmxlIFwiMHhGQ1wiIDsgVW5yZWFkYWJsZSBcIjB4RkRcIiA7IFVucmVhZGFibGUgXCIweEZFXCIgOyBVbnJlYWRhYmxlIFwiMHhGRlwiIDtcbiAgfF1cblxubGV0IGNoYXJzZXQgKCkgPVxuICBtYXRjaCAhU2V0dGluZ3MubGFuZyB3aXRoXG4gIHwgRU5HIC0+IGNoYXJzZXRfZW5nXG4gIHwgRlJBIC0+IGNoYXJzZXRfZnJhXG4gIHwgSVRBIC0+IGNoYXJzZXRfaXRhXG4gIHwgU1BBIC0+IGNoYXJzZXRfc3BhXG4gIHwgR0VSIC0+IGNoYXJzZXRfZ2VyXG4gIHwgSkFQIC0+IGNoYXJzZXRfamFwXG5cbmxldCBpc19jb2RlX2F2YWlsYWJsZSBjb2RlID1cbiAgbWF0Y2ggKGNoYXJzZXQgKCkpLihjb2RlKSB3aXRoXG4gIHwgQXZhaWxhYmxlIF8gLT4gdHJ1ZVxuICB8IFVuYXZhaWxhYmxlIF8gfCBVbnJlYWRhYmxlIF8gfCBVbnVzZWQgLT4gZmFsc2VcblxubGV0IGlzX2NvZGVfcmVhZGFibGUgY29kZSA9XG4gIG1hdGNoIChjaGFyc2V0ICgpKS4oY29kZSkgd2l0aFxuICB8IEF2YWlsYWJsZSBfIHwgVW5hdmFpbGFibGUgXyAtPiB0cnVlXG4gIHwgVW5yZWFkYWJsZSBfIHwgVW51c2VkIC0+IGZhbHNlXG5cbmxldCBpc19jb2RlX3VzZWQgY29kZSA9XG4gIG1hdGNoIChjaGFyc2V0ICgpKS4oY29kZSkgd2l0aFxuICB8IEF2YWlsYWJsZSBfIHwgVW5hdmFpbGFibGUgXyB8IFVucmVhZGFibGUgXyAtPiB0cnVlXG4gIHwgVW51c2VkIC0+IGZhbHNlXG5cbmxldCBzcGFjaW5nX2NoYXIgPSBcIl9cIlxubGV0IGludmFsaWRfY2hhciA9IFwi4pyWXCJcblxubGV0IGNoYXJfYXQgY29kZSA9XG4gIG1hdGNoIChjaGFyc2V0ICgpKS4oY29kZSkgd2l0aFxuICB8IEF2YWlsYWJsZSBzdHIgfCBVbmF2YWlsYWJsZSBzdHIgfCBVbnJlYWRhYmxlIHN0ciAtPiBzdHJcbiAgfCBVbnVzZWQgLT4gaW52YWxpZF9jaGFyXG5cbmxldCByZWFkYWJsZV9jaGFyX2F0IGNvZGUgPVxuICBtYXRjaCAoY2hhcnNldCAoKSkuKGNvZGUpIHdpdGhcbiAgfCBBdmFpbGFibGUgc3RyIHwgVW5hdmFpbGFibGUgc3RyIC0+IHN0clxuICB8IFVucmVhZGFibGUgXyB8IFVudXNlZCAtPiBpbnZhbGlkX2NoYXJcblxubGV0IHdyaXRhYmxlX2NoYXJfYXQgY29kZSA9XG4gIG1hdGNoIChjaGFyc2V0ICgpKS4oY29kZSkgd2l0aFxuICB8IEF2YWlsYWJsZSBzdHIgLT4gc3RyXG4gIHwgVW5hdmFpbGFibGUgXyB8IFVucmVhZGFibGUgXyB8IFVudXNlZCAtPiBpbnZhbGlkX2NoYXJcblxubGV0IGFsbF93cml0YWJsZV9jaGFycyA9XG4gIGxldCByZWMgYXV4IGFjYyBpID1cbiAgICBpZiBpIDwgMCB0aGVuIGFjY1xuICAgIGVsc2VcbiAgICAgIG1hdGNoIChjaGFyc2V0ICgpKS4oaSkgd2l0aFxuICAgICAgfCBBdmFpbGFibGUgc3RyIC0+IGF1eCAoc3RyOjphY2MpIChpLTEpXG4gICAgICB8IFVuYXZhaWxhYmxlIF8gfCBVbnJlYWRhYmxlIF8gfCBVbnVzZWQgLT4gYXV4IGFjYyAoaS0xKVxuICBpblxuICBhdXggW10gMHhGRlxuXG5sZXQgZW5jb2RlX3dyaXRhYmxlX2NoYXIgc3RyID1cbiAgbGV0IHJlYyBhdXggaSA9XG4gICAgaWYgaSA8IDAgdGhlbiByYWlzZSBOb3RfZm91bmRcbiAgICBlbHNlXG4gICAgICBtYXRjaCAoY2hhcnNldCAoKSkuKGkpIHdpdGhcbiAgICAgIHwgQXZhaWxhYmxlIHN0cicgd2hlbiBTdHJpbmcuZXF1YWwgc3RyIHN0cicgLT4gaVxuICAgICAgfCBBdmFpbGFibGUgXyB8IFVuYXZhaWxhYmxlIF8gfCBVbnJlYWRhYmxlIF8gfCBVbnVzZWQgLT4gYXV4IChpLTEpXG4gIGluXG4gIGF1eCAweEZGXG4iLCJvcGVuIEFybVxuXG50eXBlIHVucHJvY2Vzc2VkX2ludDMyID0gQ29uc3RJbnQzMiBvZiBpbnQzMiB8IE1ldGFFeHByIG9mIFByZXByb2Nlc3MubWV0YV9leHByXG5cbnR5cGUgb2Zmc2V0ID1cbiAgfCBPSW1tZWRpYXRlIG9mIEFybS5zaWduICogdW5wcm9jZXNzZWRfaW50MzJcbiAgfCBPUmVnaXN0ZXIgb2YgQXJtLnNpZ24gKiBzdHJpbmdcblxudHlwZSBhcmdzID1cbiAgfCBSZWdpc3RlciBvZiBzdHJpbmdcbiAgfCBJbW1lZGlhdGUgb2YgdW5wcm9jZXNzZWRfaW50MzJcbiAgfCBPZmZzZXQgb2Ygc3RyaW5nICgqIHJlZ2lzdGVyICopICogb2Zmc2V0ICogQXJtLmFkZHJlc3NpbmdfdHlwZVxuXG50eXBlIGNvbW1hbmQgPVxuICB8IEFTTSBvZiBMZXhpbmcucG9zaXRpb24gKiBzdHJpbmcgKiBhcmdzIGxpc3QgKiBPcHRpbWl6ZXIudHdlYWtpbmdfc2V0dGluZ3NcbiAgfCBCSU4gb2YgTGV4aW5nLnBvc2l0aW9uICogdW5wcm9jZXNzZWRfaW50MzJcblxudHlwZSBhc3QgPSBjb21tYW5kIGxpc3RcblxuZXhjZXB0aW9uIENvbW1hbmRFcnJvciBvZiBMZXhpbmcucG9zaXRpb25cblxuZXhjZXB0aW9uIFN0cnVjdEVycm9yXG5cbmxldCBwcmVwcm9jZXNzIGVudiB1aSA9XG4gIG1hdGNoIHVpIHdpdGhcbiAgfCBDb25zdEludDMyIGkgLT4gaVxuICB8IE1ldGFFeHByIGUgLT4gUHJlcHJvY2Vzcy5ldmFsX21ldGFfZXhwciBlbnYgZVxuXG5sZXQgcmVjb2duaXplX2NvbmRpdGlvbiBzdHIgaSA9XG4gIGxldCBuID0gU3RyaW5nLmxlbmd0aCBzdHIgaW5cbiAgbGV0IHN0ciA9IFN0cmluZy5zdWIgc3RyIGkgKG1pbiAyIChuLWkpKSBpblxuICBtYXRjaCBzdHIgd2l0aFxuICB8IFwiRVFcIiAtPiAoU29tZSBFUSwgaSsyKVxuICB8IFwiTkVcIiAtPiAoU29tZSBORSwgaSsyKVxuICB8IFwiQ1NcIiAtPiAoU29tZSBDUywgaSsyKVxuICB8IFwiSFNcIiAtPiAoU29tZSBIUywgaSsyKVxuICB8IFwiQ0NcIiAtPiAoU29tZSBDQywgaSsyKVxuICB8IFwiTE9cIiAtPiAoU29tZSBMTywgaSsyKVxuICB8IFwiTUlcIiAtPiAoU29tZSBNSSwgaSsyKVxuICB8IFwiUExcIiAtPiAoU29tZSBQTCwgaSsyKVxuICB8IFwiVlNcIiAtPiAoU29tZSBWUywgaSsyKVxuICB8IFwiVkNcIiAtPiAoU29tZSBWQywgaSsyKVxuICB8IFwiSElcIiAtPiAoU29tZSBISSwgaSsyKVxuICB8IFwiTFNcIiAtPiAoU29tZSBMUywgaSsyKVxuICB8IFwiR0VcIiAtPiAoU29tZSBHRSwgaSsyKVxuICB8IFwiTFRcIiAtPiAoU29tZSBMVCwgaSsyKVxuICB8IFwiR1RcIiAtPiAoU29tZSBHVCwgaSsyKVxuICB8IFwiTEVcIiAtPiAoU29tZSBMRSwgaSsyKVxuICB8IFwiQUxcIiAtPiAoU29tZSBBTCwgaSsyKVxuICB8IF8gLT4gKE5vbmUsIGkpXG5cbmxldCByZWNvZ25pemVfbGRyX3N0cl90eXBlIHN0ciBpID1cbiAgbGV0IG4gPSBTdHJpbmcubGVuZ3RoIHN0ciBpblxuICBsZXQgc3RyID0gU3RyaW5nLnN1YiBzdHIgaSAobWluIDIgKG4taSkpIGluXG4gIG1hdGNoIHN0ciB3aXRoXG4gIHwgXCJTQlwiIC0+IChTb21lIFNCLCBpKzIpXG4gIHwgXCJTSFwiIC0+IChTb21lIFNILCBpKzIpXG4gIHwgXCJCVFwiIC0+IChTb21lIEJULCBpKzIpXG4gIHwgXyAtPlxuICBiZWdpblxuICAgIGxldCBzdHIgPSBTdHJpbmcuc3ViIHN0ciAwIChtaW4gMSAobi1pKSkgaW5cbiAgICBtYXRjaCBzdHIgd2l0aFxuICAgIHwgXCJCXCIgLT4gKFNvbWUgQiwgaSsxKVxuICAgIHwgXCJIXCIgLT4gKFNvbWUgSCwgaSsxKVxuICAgIHwgXCJXXCIgLT4gKFNvbWUgVywgaSsxKVxuICAgIHwgXCJUXCIgLT4gKFNvbWUgVCwgaSsxKVxuICAgIHwgXyAtPiAoTm9uZSwgaSlcbiAgZW5kXG5cbmxldCByZWNvZ25pemVfMSBzdHIgaSA9XG4gIGxldCBuID0gU3RyaW5nLmxlbmd0aCBzdHIgaW5cbiAgbGV0IHN0ciA9IFN0cmluZy5zdWIgc3RyIGkgKG1pbiAxIChuLWkpKSBpblxuICBtYXRjaCBzdHIgd2l0aFxuICB8IFwiU1wiIC0+IChTb21lIFwiU1wiLCBpKzEpXG4gIHwgXCJMXCIgLT4gKFNvbWUgXCJMXCIsIGkrMSlcbiAgfCBfIC0+IChOb25lLCBpKVxuXG5sZXQgY29tYmluZV9vcHQgbzEgbzIgPVxuICBtYXRjaCBvMSwgbzIgd2l0aFxuICB8IE5vbmUsIE5vbmUgLT4gTm9uZVxuICB8IFNvbWUgcywgTm9uZSB8IE5vbmUsIFNvbWUgcyAtPiBTb21lIHNcbiAgfCBTb21lIF8sIFNvbWUgXyAtPiByYWlzZSBTdHJ1Y3RFcnJvclxuXG5sZXQgY29tYmluZV9ib29sIGIxIGIyID1cbiAgbWF0Y2ggYjEsIGIyIHdpdGhcbiAgfCBmYWxzZSwgZmFsc2UgLT4gZmFsc2VcbiAgfCB0cnVlLCBmYWxzZSB8IGZhbHNlLCB0cnVlIC0+IHRydWVcbiAgfCB0cnVlLCB0cnVlIC0+IHJhaXNlIFN0cnVjdEVycm9yXG5cbmxldCBjb21iaW5lX21vZGlmaWVycyAoY29uZCwgbHN0LCBzLCBsKSAoY29uZCcsIGxzdCcsIHMnLCBsJykgPVxuICBsZXQgY29uZCA9IGNvbWJpbmVfb3B0IGNvbmQgY29uZCcgaW5cbiAgbGV0IGxzdCA9IGNvbWJpbmVfb3B0IGxzdCBsc3QnIGluXG4gIGxldCBzID0gY29tYmluZV9ib29sIHMgcycgaW5cbiAgbGV0IGwgPSBjb21iaW5lX2Jvb2wgbCBsJyBpblxuICAoY29uZCwgbHN0LCBzLCBsKVxuXG5sZXQgcmVjb2duaXplX21vZGlmaWVycyBzdHIgaSA9XG4gIGxldCBuID0gU3RyaW5nLmxlbmd0aCBzdHIgaW5cbiAgbGV0IHJlYyBhdXggbW9kcyBpID1cbiAgICBpZiBpID49IG4gdGhlbiBtb2RzXG4gICAgZWxzZVxuICAgICAgbGV0IChubW9kcywgaSkgPVxuICAgICAgICBtYXRjaCByZWNvZ25pemVfY29uZGl0aW9uIHN0ciBpIHdpdGhcbiAgICAgICAgfCAoU29tZSBjLCBpKSAtPiAoKFNvbWUgYywgTm9uZSwgZmFsc2UsIGZhbHNlKSwgaSlcbiAgICAgICAgfCAoTm9uZSwgaSkgLT5cbiAgICAgICAgICBtYXRjaCByZWNvZ25pemVfbGRyX3N0cl90eXBlIHN0ciBpIHdpdGhcbiAgICAgICAgICB8IChTb21lIGxzdCwgaSkgLT4gKChOb25lLCBTb21lIGxzdCwgZmFsc2UsIGZhbHNlKSwgaSlcbiAgICAgICAgICB8IChOb25lLCBpKSAtPlxuICAgICAgICAgICAgbWF0Y2ggcmVjb2duaXplXzEgc3RyIGkgd2l0aFxuICAgICAgICAgICAgfCAoU29tZSBcIlNcIiwgaSkgLT4gKChOb25lLCBOb25lLCB0cnVlLCBmYWxzZSksIGkpXG4gICAgICAgICAgICB8IChTb21lIFwiTFwiLCBpKSAtPiAoKE5vbmUsIE5vbmUsIGZhbHNlLCB0cnVlKSwgaSlcbiAgICAgICAgICAgIHwgXyAtPiByYWlzZSBTdHJ1Y3RFcnJvclxuICAgICAgaW5cbiAgICAgIGxldCBtb2RzID0gY29tYmluZV9tb2RpZmllcnMgbW9kcyBubW9kcyBpblxuICAgICAgYXV4IG1vZHMgaVxuICBpblxuICBhdXggKE5vbmUsIE5vbmUsIGZhbHNlLCBmYWxzZSkgaVxuXG5sZXQgcmVnaXN0ZXJfb2Zfc3RyIHN0ciA9XG4gIGxldCBzdHIgPSBTdHJpbmcubG93ZXJjYXNlX2FzY2lpIHN0ciBpblxuICBtYXRjaCBzdHIgd2l0aFxuICB8IFwicjBcIiAtPiAwICAgfCBcInIxXCIgLT4gMSAgIHwgXCJyMlwiIC0+IDIgICB8IFwicjNcIiAtPiAzICAgfCBcInI0XCIgLT4gNFxuICB8IFwicjVcIiAtPiA1ICAgfCBcInI2XCIgLT4gNiAgIHwgXCJyN1wiIC0+IDcgICB8IFwicjhcIiAtPiA4ICAgfCBcInI5XCIgLT4gOSBcbiAgfCBcInIxMFwiIC0+IDEwIHwgXCJyMTFcIiAtPiAxMSB8IFwicjEyXCIgLT4gMTIgfCBcInIxM1wiIC0+IDEzIHwgXCJyMTRcIiAtPiAxNCBcbiAgfCBcInIxNVwiIC0+IDE1IHwgXCJzYlwiIC0+IHNiICB8IFwic2xcIiAtPiBzbCAgfCBcImZwXCIgLT4gZnAgIHwgXCJpcFwiIC0+IGlwXG4gIHwgXCJzcFwiIC0+IHNwICB8IFwibHJcIiAtPiBsciAgfCBcInBjXCIgLT4gcGMgIHwgXyAtPiByYWlzZSBTdHJ1Y3RFcnJvclxuXG5sZXQgZ2V0X3JlZ2lzdGVyIGFyZyA9XG4gIG1hdGNoIGFyZyB3aXRoXG4gIHwgUmVnaXN0ZXIgc3RyIC0+IHJlZ2lzdGVyX29mX3N0ciBzdHJcbiAgfCBfIC0+IHJhaXNlIFN0cnVjdEVycm9yXG5cbmxldCBnZXRfcmQgYXJncyA9IGdldF9yZWdpc3RlciAoTGlzdC5oZCBhcmdzKVxuXG5sZXQgZ2V0X3JuIGFyZ3MgPVxuICBsZXQgbiA9IExpc3QubGVuZ3RoIGFyZ3MgaW5cbiAgZ2V0X3JlZ2lzdGVyIChMaXN0Lm50aCBhcmdzIChuLTIpKVxuXG5sZXQgZ2V0X2ltbWVkaWF0ZSBlbnYgYXJnID1cbiAgbWF0Y2ggYXJnIHdpdGhcbiAgfCBJbW1lZGlhdGUgaSAtPiBwcmVwcm9jZXNzIGVudiBpXG4gIHwgXyAtPiByYWlzZSBTdHJ1Y3RFcnJvclxuXG5sZXQgZ2V0X29wZXJhbmQgZW52IGFyZyA9XG4gIG1hdGNoIGFyZyB3aXRoXG4gIHwgSW1tZWRpYXRlIGkgLT4gQXJtLkltbWVkaWF0ZSAocHJlcHJvY2VzcyBlbnYgaSlcbiAgfCBSZWdpc3RlciBzdHIgLT4gQXJtLlJlZ2lzdGVyIChyZWdpc3Rlcl9vZl9zdHIgc3RyKVxuICB8IF8gLT4gcmFpc2UgU3RydWN0RXJyb3JcblxubGV0IGdldF9vcDIgZW52IGFyZ3MgPVxuICBsZXQgbiA9IExpc3QubGVuZ3RoIGFyZ3MgaW5cbiAgZ2V0X29wZXJhbmQgZW52IChMaXN0Lm50aCBhcmdzIChuLTEpKVxuXG5sZXQgZ2V0X3JzID0gZ2V0X29wMlxuXG5sZXQgZ2V0X3JvIGVudiBhcmdzID1cbiAgbGV0IG4gPSBMaXN0Lmxlbmd0aCBhcmdzIGluXG4gIG1hdGNoIExpc3QubnRoIGFyZ3MgKG4tMSkgd2l0aFxuICB8IE9mZnNldCAoc3RyLCBvZmZzZXQsIGFkZHJfdHlwKSAtPiBiZWdpblxuICAgIGxldCByID0gcmVnaXN0ZXJfb2Zfc3RyIHN0ciBpblxuICAgIGxldCBybyA9IG1hdGNoIG9mZnNldCB3aXRoXG4gICAgfCBPSW1tZWRpYXRlIChzaWduLCBpKSAtPiBBcm0uT0ltbWVkaWF0ZSAociwgc2lnbiwgcHJlcHJvY2VzcyBlbnYgaSlcbiAgICB8IE9SZWdpc3RlciAoc2lnbiwgc3RyKSAtPiBBcm0uT1JlZ2lzdGVyIChyLCBzaWduLCByZWdpc3Rlcl9vZl9zdHIgc3RyKVxuICAgIGluXG4gICAgKHJvLCBhZGRyX3R5cClcbiAgICBlbmRcbiAgfCBfIC0+IHJhaXNlIFN0cnVjdEVycm9yXG5cbmxldCBnZXRfdGFyZ2V0IGVudiBhcmdzID1cbiAgZ2V0X2ltbWVkaWF0ZSBlbnYgKExpc3QuaGQgYXJncylcblxubGV0IGFzbV9jbWQzX3RvX2FybSBlbnYgY21kIGFyZ3MgPVxuICBpZiBTdHJpbmcubGVuZ3RoIGNtZCA8IDMgdGhlbiByYWlzZSBTdHJ1Y3RFcnJvciA7XG4gIGxldCBjbWQgPSBTdHJpbmcudXBwZXJjYXNlX2FzY2lpIGNtZCBpblxuICBsZXQgKGNvbmQsIHR5cCwgcywgXykgPSByZWNvZ25pemVfbW9kaWZpZXJzIGNtZCAzIGluXG4gIGxldCBjb25kID0gbWF0Y2ggY29uZCB3aXRoIE5vbmUgLT4gQUwgfCBTb21lIGMgLT4gYyBpblxuICBsZXQgdHlwID0gbWF0Y2ggdHlwIHdpdGggTm9uZSAtPiBXIHwgU29tZSB0eXAgLT4gdHlwIGluXG5cbiAgdHJ5IG1hdGNoIFN0cmluZy5zdWIgY21kIDAgMyB3aXRoXG4gIHwgXCJMRFJcIiAtPiBMRFIgeyB0eXAgOyBjb25kIDsgcmQ9Z2V0X3JkIGFyZ3MgOyBybz1nZXRfcm8gZW52IGFyZ3MgfVxuICB8IFwiU1RSXCIgLT4gU1RSIHsgdHlwIDsgY29uZCA7IHJkPWdldF9yZCBhcmdzIDsgcm89Z2V0X3JvIGVudiBhcmdzIH1cbiAgfCBcIk1PVlwiIC0+IE1PViB7IHMgOyBjb25kIDsgcmQ9Z2V0X3JkIGFyZ3MgOyBycz1nZXRfcnMgZW52IGFyZ3MgfVxuICB8IFwiTVZOXCIgLT4gTVZOIHsgcyA7IGNvbmQgOyByZD1nZXRfcmQgYXJncyA7IHJzPWdldF9ycyBlbnYgYXJncyB9XG4gIHwgXCJBRENcIiAtPiBBREMgeyBzIDsgY29uZCA7IHJkPWdldF9yZCBhcmdzIDsgcm49Z2V0X3JuIGFyZ3MgOyBvcDI9Z2V0X29wMiBlbnYgYXJncyB9XG4gIHwgXCJTQkNcIiAtPiBTQkMgeyBzIDsgY29uZCA7IHJkPWdldF9yZCBhcmdzIDsgcm49Z2V0X3JuIGFyZ3MgOyBvcDI9Z2V0X29wMiBlbnYgYXJncyB9XG4gIHwgXCJCSUNcIiAtPiBCSUMgeyBzIDsgY29uZCA7IHJkPWdldF9yZCBhcmdzIDsgcm49Z2V0X3JuIGFyZ3MgOyBvcDI9Z2V0X29wMiBlbnYgYXJncyB9XG4gIHwgXCJBTkRcIiAtPiBBTkQgeyBzIDsgY29uZCA7IHJkPWdldF9yZCBhcmdzIDsgcm49Z2V0X3JuIGFyZ3MgOyBvcDI9Z2V0X29wMiBlbnYgYXJncyB9XG4gIHwgXyAtPiByYWlzZSBTdHJ1Y3RFcnJvclxuICB3aXRoIEZhaWx1cmUgXyB8IEludmFsaWRfYXJndW1lbnQgXyAtPiByYWlzZSBTdHJ1Y3RFcnJvclxuXG5sZXQgYXNtX2NtZDFfdG9fYXJtIGVudiBjbWQgYXJncyA9XG4gIGlmIFN0cmluZy5sZW5ndGggY21kIDwgMSB0aGVuIHJhaXNlIFN0cnVjdEVycm9yIDtcbiAgbGV0IGNtZCA9IFN0cmluZy51cHBlcmNhc2VfYXNjaWkgY21kIGluXG4gIGxldCAoY29uZCwgXywgXywgbCkgPSByZWNvZ25pemVfbW9kaWZpZXJzIGNtZCAxIGluXG4gIGxldCBjb25kID0gbWF0Y2ggY29uZCB3aXRoIE5vbmUgLT4gQUwgfCBTb21lIGMgLT4gYyBpblxuXG4gIHRyeSBtYXRjaCBTdHJpbmcuc3ViIGNtZCAwIDEgd2l0aFxuICB8IFwiQlwiIC0+IEJyYW5jaCB7IGwgOyBjb25kIDsgdGFyZ2V0PWdldF90YXJnZXQgZW52IGFyZ3MgfVxuICB8IF8gLT4gcmFpc2UgU3RydWN0RXJyb3JcbiAgd2l0aCBGYWlsdXJlIF8gfCBJbnZhbGlkX2FyZ3VtZW50IF8gLT4gcmFpc2UgU3RydWN0RXJyb3JcblxubGV0IGFzbV9jbWRfdG9fYXJtIGVudiBjbWQgYXJncyA9XG4gIHRyeSAoYXNtX2NtZDNfdG9fYXJtIGVudiBjbWQgYXJncylcbiAgd2l0aCBTdHJ1Y3RFcnJvciAtPiAoYXNtX2NtZDFfdG9fYXJtIGVudiBjbWQgYXJncylcblxubGV0IGNtZF90b19hcm0gZW52IGNtZCA9XG4gIG1hdGNoIGNtZCB3aXRoXG4gIHwgQVNNIChwb3MsIGNtZCwgYXJncywgb3B0aW1pemUpIC0+XG4gICAgYmVnaW4gdHJ5IChhc21fY21kX3RvX2FybSBlbnYgY21kIGFyZ3MsIG9wdGltaXplKVxuICAgIHdpdGggU3RydWN0RXJyb3IgLT4gcmFpc2UgKENvbW1hbmRFcnJvciBwb3MpIGVuZFxuICB8IEJJTiAoXywgaSkgLT4gKEN1c3RvbSAocHJlcHJvY2VzcyBlbnYgaSksIE9wdGltaXplci5Ob1R3ZWFraW5nKVxuXG5sZXQgdG9fYXJtIGVudiBhc3QgPSBMaXN0Lm1hcCAoY21kX3RvX2FybSBlbnYpIGFzdFxuIiwiIyAxIFwiSU8vbGV4ZXIubWxsXCJcbiBcbm9wZW4gTGV4aW5nXG5vcGVuIFBhcnNlclxuXG5leGNlcHRpb24gU3ludGF4RXJyb3Igb2Ygc3RyaW5nXG5cbmxldCBuZXh0X2xpbmUgbGV4YnVmID1cbiAgbGV0IHBvcyA9IGxleGJ1Zi5sZXhfY3Vycl9wIGluXG4gIGxleGJ1Zi5sZXhfY3Vycl9wIDwtXG4gICAgeyBwb3Mgd2l0aCBwb3NfYm9sID0gbGV4YnVmLmxleF9jdXJyX3BvcztcbiAgICAgICAgICAgICAgIHBvc19sbnVtID0gcG9zLnBvc19sbnVtICsgMVxuICAgIH1cblxubGV0IGVvZl9yZWFjaGVkIGxleGJ1ZiA9XG4gIGxleGJ1Zi5sZXhfZW9mX3JlYWNoZWQgPC0gdHJ1ZVxuXG4jIDE5IFwiSU8vbGV4ZXIubWxcIlxubGV0IF9fb2NhbWxfbGV4X3RhYmxlcyA9IHtcbiAgTGV4aW5nLmxleF9iYXNlID1cbiAgIFwiXFwwMDBcXDAwMFxcMjE1XFwyNTVcXDIxNlxcMjU1XFwyMTdcXDI1NVxcMjE4XFwyNTVcXDIyM1xcMjU1XFwyMjRcXDI1NVxcMjI1XFwyNTVcXFxuICAgIFxcMjI2XFwyNTVcXDIyN1xcMjU1XFwyMjhcXDI1NVxcMjI5XFwyNTVcXDIzMVxcMjU1XFwyMzJcXDI1NVxcMjMzXFwyNTVcXDIzNFxcMjU1XFxcbiAgICBcXDIzNVxcMjU1XFwyMzZcXDI1NVxcMjM4XFwyNTVcXDA3OVxcMDAwXFwxNTRcXDAwMFxcMTY0XFwwMDBcXDI0MVxcMjU1XFwwMDFcXDAwMFxcXG4gICAgXFwwMDJcXDAwMFxcMDA3XFwwMDBcXDA0OVxcMDAwXFwyNDRcXDI1NVxcMDA5XFwwMDBcXDA5OVxcMDAwXFwwMTRcXDAwMFxcMDc4XFwwMDBcXFxuICAgIFxcMDc4XFwwMDBcXDA4MVxcMDAwXFwyMzdcXDAwMFxcMDU2XFwwMDFcXDEzMVxcMDAxXFwwNzhcXDAwMFxcMDgyXFwwMDBcXDEwOVxcMDAwXFxcbiAgICBcXDExMFxcMDAwXFwxMTFcXDAwMFxcMTEyXFwwMDBcXDI1NFxcMjU1XFwyMDZcXDAwMVxcMDI1XFwwMDJcXDEwMFxcMDAyXFwxNzVcXDAwMlxcXG4gICAgXFwyNTBcXDAwMlxcMDY5XFwwMDNcXDE0NFxcMDAzXFwyMTlcXDAwM1xcMDM4XFwwMDRcXDExM1xcMDA0XFwyNTBcXDI1NVxcMjQ5XFwyNTVcXFxuICAgIFxcMjQ3XFwyNTVcXDI0NlxcMjU1XFwyNDVcXDI1NVxcMjQyXFwyNTVcXDAwNFxcMDAwXFwxNzRcXDAwMFxcMTgzXFwwMDBcXDE4OFxcMDA0XFxcbiAgICBcXDE4NVxcMDAwXFwyMTFcXDAwNFxcMTk2XFwwMDBcXDIxNVxcMDAwXFwyMzZcXDAwNFxcMjQ1XFwyNTVcXDI0NlxcMjU1XFwwMDdcXDAwMFxcXG4gICAgXFwyMzdcXDAwNFxcMjA0XFwwMDRcXDI1NVxcMjU1XFwyNDhcXDI1NVxcMjQ5XFwyNTVcXDI1MFxcMjU1XFwyNTFcXDI1NVxcMjUyXFwyNTVcXFxuICAgIFxcMjUzXFwyNTVcXDI1NFxcMjU1XFwwMTVcXDAwMFxcMjUzXFwyNTVcXDI1NFxcMjU1XFwyNTVcXDI1NVxcMDA4XFwwMDBcIjtcbiAgTGV4aW5nLmxleF9iYWNrdHJrID1cbiAgIFwiXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDAxNlxcMDAwXFwwMTVcXDAwMFxcMDE1XFwwMDBcXDI1NVxcMjU1XFwwMTRcXDAwMFxcXG4gICAgXFwwNDBcXDAwMFxcMDEyXFwwMDBcXDAzM1xcMDAwXFwyNTVcXDI1NVxcMDM0XFwwMDBcXDAzNVxcMDAwXFwwMzZcXDAwMFxcMDI1XFwwMDBcXFxuICAgIFxcMDQwXFwwMDBcXDA0MFxcMDAwXFwwMTZcXDAwMFxcMDE2XFwwMDBcXDAxNlxcMDAwXFwwMTFcXDAwMFxcMDE4XFwwMDBcXDAwN1xcMDAwXFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDAwXFwwMDBcXDI1NVxcMjU1XFwwMTZcXDAwMFxcMDE2XFwwMDBcXDAwMlxcMDAwXFwwMTZcXDAwMFxcXG4gICAgXFwwMTZcXDAwMFxcMDAzXFwwMDBcXDAxNlxcMDAwXFwwMTZcXDAwMFxcMDE2XFwwMDBcXDAwNFxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDAxM1xcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwwMTVcXDAwMFxcMDE1XFwwMDBcXDAxNVxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMDlcXDAwMFxcXG4gICAgXFwwMDhcXDAwMFxcMDExXFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDAwXFwwMDBcIjtcbiAgTGV4aW5nLmxleF9kZWZhdWx0ID1cbiAgIFwiXFwwMDFcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDAwMFxcMDAwXFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMDBcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDAwMFxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwNzJcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwyNTVcXDI1NVxcXG4gICAgXFwwNzJcXDAwMFxcMjU1XFwyNTVcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwODNcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMjU1XFwyNTVcIjtcbiAgTGV4aW5nLmxleF90cmFucyA9XG4gICBcIlxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMjVcXDAwMFxcMDIyXFwwMDBcXDAyMlxcMDAwXFwwNTlcXDAwMFxcMDIzXFwwMDBcXDA1OVxcMDAwXFwwNjBcXDAwMFxcXG4gICAgXFwwMjVcXDAwMFxcMDcwXFwwMDBcXDA4NVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDA4NVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDA4NlxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAyNVxcMDAwXFwwMzFcXDAwMFxcMDE4XFwwMDBcXDAxN1xcMDAwXFwwMDBcXDAwMFxcMDI4XFwwMDBcXDAyOVxcMDAwXFwwMjVcXDAwMFxcXG4gICAgXFwwMDlcXDAwMFxcMDA4XFwwMDBcXDAwNVxcMDAwXFwwMDdcXDAwMFxcMDEyXFwwMDBcXDAwNlxcMDAwXFwwMjdcXDAwMFxcMDI2XFwwMDBcXFxuICAgIFxcMDIxXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFxcbiAgICBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDEwXFwwMDBcXDAyN1xcMDAwXFwwMzNcXDAwMFxcMDM4XFwwMDBcXDAzMlxcMDAwXFwwMTFcXDAwMFxcXG4gICAgXFwwMzdcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTZcXDAwMFxcMDI0XFwwMDBcXDAxNVxcMDAwXFwwMDRcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDI3XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDM0XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAzNlxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDM1XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE0XFwwMDBcXDAzMFxcMDAwXFwwMTNcXDAwMFxcMDAzXFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDU4XFwwMDBcXDA1N1xcMDAwXFwwNTZcXDAwMFxcMDU1XFwwMDBcXDA1NFxcMDAwXFwwNDNcXDAwMFxcMDM5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwNDBcXDAwMFxcMDQxXFwwMDBcXDA0MlxcMDAwXFwwNDJcXDAwMFxcMDE5XFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcXG4gICAgXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXFxuICAgIFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDY3XFwwMDBcXDA2N1xcMDAwXFxcbiAgICBcXDA2N1xcMDAwXFwwNjdcXDAwMFxcMDY3XFwwMDBcXDA2N1xcMDAwXFwwNjdcXDAwMFxcMDY3XFwwMDBcXDA2MlxcMDAwXFwwNjZcXDAwMFxcXG4gICAgXFwwNjZcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXFxuICAgIFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDYxXFwwMDBcXDA2NlxcMDAwXFwwNjZcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwNjRcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwNjNcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDJcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwNjJcXDAwMFxcMDY3XFwwMDBcXFxuICAgIFxcMDY3XFwwMDBcXDA2N1xcMDAwXFwwNjdcXDAwMFxcMDY3XFwwMDBcXDA2N1xcMDAwXFwwNjdcXDAwMFxcMDY3XFwwMDBcXDA4NFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDA2MVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDY0XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDYzXFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDE5XFwwMDBcXDAwMFxcMDAwXFwwNTBcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDA0N1xcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMTlcXDAwMFxcMDAwXFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDQ0XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMTlcXDAwMFxcMDAwXFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDA0NVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMDBcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDA0NlxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAxOVxcMDAwXFwwMDBcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAxOVxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwNDhcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDE5XFwwMDBcXDAwMFxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDQ5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDE5XFwwMDBcXDAwMFxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwNTFcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMTlcXDAwMFxcMDAwXFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwNTJcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMTlcXDAwMFxcMDAwXFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDA1M1xcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMDBcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwNjVcXDAwMFxcMDY1XFwwMDBcXDA2NVxcMDAwXFwwNjVcXDAwMFxcXG4gICAgXFwwNjVcXDAwMFxcMDY1XFwwMDBcXDA2NVxcMDAwXFwwNjVcXDAwMFxcMDY1XFwwMDBcXDA2NVxcMDAwXFwwNzBcXDAwMFxcMjU1XFwyNTVcXFxuICAgIFxcMDAwXFwwMDBcXDA3MVxcMDAwXFwyNTVcXDI1NVxcMDgxXFwwMDBcXDAwMFxcMDAwXFwwNjVcXDAwMFxcMDY1XFwwMDBcXDA2NVxcMDAwXFxcbiAgICBcXDA2NVxcMDAwXFwwNjVcXDAwMFxcMDY1XFwwMDBcXDA2NVxcMDAwXFwwNjVcXDAwMFxcMDY1XFwwMDBcXDA2NVxcMDAwXFwwNjVcXDAwMFxcXG4gICAgXFwwNjVcXDAwMFxcMDY1XFwwMDBcXDA2NVxcMDAwXFwwNjVcXDAwMFxcMDY1XFwwMDBcXDAwMFxcMDAwXFwwNzRcXDAwMFxcMjU1XFwyNTVcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDA2NVxcMDAwXFwwNjVcXDAwMFxcMDY1XFwwMDBcXDA2NVxcMDAwXFxcbiAgICBcXDA2NVxcMDAwXFwwNjVcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDY1XFwwMDBcXDA2NVxcMDAwXFwwNjVcXDAwMFxcXG4gICAgXFwwNjVcXDAwMFxcMDY1XFwwMDBcXDA2NVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDgwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDc5XFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDc4XFwwMDBcXDAwMFxcMDAwXFwwNjVcXDAwMFxcMDY1XFwwMDBcXDA2NVxcMDAwXFwwNjVcXDAwMFxcXG4gICAgXFwwNjVcXDAwMFxcMDY1XFwwMDBcXDA3N1xcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwNzZcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDc1XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDA3M1xcMDAwXFwyNTVcXDI1NVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDA2OVxcMDAwXFwyNTVcXDI1NVwiO1xuICBMZXhpbmcubGV4X2NoZWNrID1cbiAgIFwiXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDIzXFwwMDBcXDAyNFxcMDAwXFwwMDBcXDAwMFxcMDYwXFwwMDBcXDAyNFxcMDAwXFxcbiAgICBcXDAyNVxcMDAwXFwwNzFcXDAwMFxcMDg2XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMDgyXFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDgyXFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDI1NVxcMjU1XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAyNVxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAyOFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMjZcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMjlcXDAwMFxcMDMwXFwwMDBcXDAzMVxcMDAwXFwwMzJcXDAwMFxcMDMzXFwwMDBcXDAzN1xcMDAwXFwwMzhcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAzOVxcMDAwXFwwNDBcXDAwMFxcMDQxXFwwMDBcXDA0MlxcMDAwXFwwMTlcXDAwMFxcMjU1XFwyNTVcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFxcbiAgICBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjFcXDAwMFxcMDIxXFwwMDBcXDAyMVxcMDAwXFwwMjFcXDAwMFxcXG4gICAgXFwwMjFcXDAwMFxcMDIxXFwwMDBcXDAyMVxcMDAwXFwwMjFcXDAwMFxcMDIxXFwwMDBcXDAyMVxcMDAwXFwwNjFcXDAwMFxcMDYxXFwwMDBcXFxuICAgIFxcMDYxXFwwMDBcXDA2MVxcMDAwXFwwNjFcXDAwMFxcMDYxXFwwMDBcXDA2MVxcMDAwXFwwNjFcXDAwMFxcMDIxXFwwMDBcXDA2MlxcMDAwXFxcbiAgICBcXDA2MlxcMDAwXFwwNjRcXDAwMFxcMDY0XFwwMDBcXDA2NFxcMDAwXFwwNjRcXDAwMFxcMDY0XFwwMDBcXDA2NFxcMDAwXFwwNjRcXDAwMFxcXG4gICAgXFwwNjRcXDAwMFxcMDY0XFwwMDBcXDA2NFxcMDAwXFwwMjFcXDAwMFxcMDY2XFwwMDBcXDA2NlxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDAyMVxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDAyMVxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDAwMFxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDAyMVxcMDAwXFwwNjdcXDAwMFxcXG4gICAgXFwwNjdcXDAwMFxcMDY3XFwwMDBcXDA2N1xcMDAwXFwwNjdcXDAwMFxcMDY3XFwwMDBcXDA2N1xcMDAwXFwwNjdcXDAwMFxcMDgyXFwwMDBcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDIxXFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwwMjFcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMjFcXDAwMFxcMDM0XFwwMDBcXDAzNFxcMDAwXFwwMzRcXDAwMFxcXG4gICAgXFwwMzRcXDAwMFxcMDM0XFwwMDBcXDAzNFxcMDAwXFwwMzRcXDAwMFxcMDM0XFwwMDBcXDAzNFxcMDAwXFwwMzRcXDAwMFxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDM0XFwwMDBcXDAzNFxcMDAwXFxcbiAgICBcXDAzNFxcMDAwXFwwMzRcXDAwMFxcMDM0XFwwMDBcXDAzNFxcMDAwXFwwMzRcXDAwMFxcMDM0XFwwMDBcXDAzNFxcMDAwXFwwMzRcXDAwMFxcXG4gICAgXFwwMzRcXDAwMFxcMDM0XFwwMDBcXDAzNFxcMDAwXFwwMzRcXDAwMFxcMDM0XFwwMDBcXDAzNFxcMDAwXFwwMzRcXDAwMFxcMDM0XFwwMDBcXFxuICAgIFxcMDM0XFwwMDBcXDAzNFxcMDAwXFwwMzRcXDAwMFxcMDM0XFwwMDBcXDAzNFxcMDAwXFwwMzRcXDAwMFxcMDM0XFwwMDBcXDAzNFxcMDAwXFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMzRcXDAwMFxcMjU1XFwyNTVcXDAzNFxcMDAwXFwwMzRcXDAwMFxcXG4gICAgXFwwMzRcXDAwMFxcMDM0XFwwMDBcXDAzNFxcMDAwXFwwMzRcXDAwMFxcMDM0XFwwMDBcXDAzNFxcMDAwXFwwMzRcXDAwMFxcMDM0XFwwMDBcXFxuICAgIFxcMDM0XFwwMDBcXDAzNFxcMDAwXFwwMzRcXDAwMFxcMDM0XFwwMDBcXDAzNFxcMDAwXFwwMzRcXDAwMFxcMDM0XFwwMDBcXDAzNFxcMDAwXFxcbiAgICBcXDAzNFxcMDAwXFwwMzRcXDAwMFxcMDM0XFwwMDBcXDAzNFxcMDAwXFwwMzRcXDAwMFxcMDM0XFwwMDBcXDAzNFxcMDAwXFwwMzRcXDAwMFxcXG4gICAgXFwwMzVcXDAwMFxcMDM1XFwwMDBcXDAzNVxcMDAwXFwwMzVcXDAwMFxcMDM1XFwwMDBcXDAzNVxcMDAwXFwwMzVcXDAwMFxcMDM1XFwwMDBcXFxuICAgIFxcMDM1XFwwMDBcXDAzNVxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwwMzVcXDAwMFxcMDM1XFwwMDBcXDAzNVxcMDAwXFwwMzVcXDAwMFxcMDM1XFwwMDBcXDAzNVxcMDAwXFwwMzVcXDAwMFxcXG4gICAgXFwwMzVcXDAwMFxcMDM1XFwwMDBcXDAzNVxcMDAwXFwwMzVcXDAwMFxcMDM1XFwwMDBcXDAzNVxcMDAwXFwwMzVcXDAwMFxcMDM1XFwwMDBcXFxuICAgIFxcMDM1XFwwMDBcXDAzNVxcMDAwXFwwMzVcXDAwMFxcMDM1XFwwMDBcXDAzNVxcMDAwXFwwMzVcXDAwMFxcMDM1XFwwMDBcXDAzNVxcMDAwXFxcbiAgICBcXDAzNVxcMDAwXFwwMzVcXDAwMFxcMDM1XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMzVcXDAwMFxcXG4gICAgXFwyNTVcXDI1NVxcMDM1XFwwMDBcXDAzNVxcMDAwXFwwMzVcXDAwMFxcMDM1XFwwMDBcXDAzNVxcMDAwXFwwMzVcXDAwMFxcMDM1XFwwMDBcXFxuICAgIFxcMDM1XFwwMDBcXDAzNVxcMDAwXFwwMzVcXDAwMFxcMDM1XFwwMDBcXDAzNVxcMDAwXFwwMzVcXDAwMFxcMDM1XFwwMDBcXDAzNVxcMDAwXFxcbiAgICBcXDAzNVxcMDAwXFwwMzVcXDAwMFxcMDM1XFwwMDBcXDAzNVxcMDAwXFwwMzVcXDAwMFxcMDM1XFwwMDBcXDAzNVxcMDAwXFwwMzVcXDAwMFxcXG4gICAgXFwwMzVcXDAwMFxcMDM1XFwwMDBcXDAzNVxcMDAwXFwwMzZcXDAwMFxcMDM2XFwwMDBcXDAzNlxcMDAwXFwwMzZcXDAwMFxcMDM2XFwwMDBcXFxuICAgIFxcMDM2XFwwMDBcXDAzNlxcMDAwXFwwMzZcXDAwMFxcMDM2XFwwMDBcXDAzNlxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMzZcXDAwMFxcMDM2XFwwMDBcXDAzNlxcMDAwXFwwMzZcXDAwMFxcXG4gICAgXFwwMzZcXDAwMFxcMDM2XFwwMDBcXDAzNlxcMDAwXFwwMzZcXDAwMFxcMDM2XFwwMDBcXDAzNlxcMDAwXFwwMzZcXDAwMFxcMDM2XFwwMDBcXFxuICAgIFxcMDM2XFwwMDBcXDAzNlxcMDAwXFwwMzZcXDAwMFxcMDM2XFwwMDBcXDAzNlxcMDAwXFwwMzZcXDAwMFxcMDM2XFwwMDBcXDAzNlxcMDAwXFxcbiAgICBcXDAzNlxcMDAwXFwwMzZcXDAwMFxcMDM2XFwwMDBcXDAzNlxcMDAwXFwwMzZcXDAwMFxcMDM2XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDAzNlxcMDAwXFwyNTVcXDI1NVxcMDM2XFwwMDBcXDAzNlxcMDAwXFwwMzZcXDAwMFxcMDM2XFwwMDBcXFxuICAgIFxcMDM2XFwwMDBcXDAzNlxcMDAwXFwwMzZcXDAwMFxcMDM2XFwwMDBcXDAzNlxcMDAwXFwwMzZcXDAwMFxcMDM2XFwwMDBcXDAzNlxcMDAwXFxcbiAgICBcXDAzNlxcMDAwXFwwMzZcXDAwMFxcMDM2XFwwMDBcXDAzNlxcMDAwXFwwMzZcXDAwMFxcMDM2XFwwMDBcXDAzNlxcMDAwXFwwMzZcXDAwMFxcXG4gICAgXFwwMzZcXDAwMFxcMDM2XFwwMDBcXDAzNlxcMDAwXFwwMzZcXDAwMFxcMDM2XFwwMDBcXDAzNlxcMDAwXFwwNDRcXDAwMFxcMDQ0XFwwMDBcXFxuICAgIFxcMDQ0XFwwMDBcXDA0NFxcMDAwXFwwNDRcXDAwMFxcMDQ0XFwwMDBcXDA0NFxcMDAwXFwwNDRcXDAwMFxcMDQ0XFwwMDBcXDA0NFxcMDAwXFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwNDRcXDAwMFxcXG4gICAgXFwwNDRcXDAwMFxcMDQ0XFwwMDBcXDA0NFxcMDAwXFwwNDRcXDAwMFxcMDQ0XFwwMDBcXDA0NFxcMDAwXFwwNDRcXDAwMFxcMDQ0XFwwMDBcXFxuICAgIFxcMDQ0XFwwMDBcXDA0NFxcMDAwXFwwNDRcXDAwMFxcMDQ0XFwwMDBcXDA0NFxcMDAwXFwwNDRcXDAwMFxcMDQ0XFwwMDBcXDA0NFxcMDAwXFxcbiAgICBcXDA0NFxcMDAwXFwwNDRcXDAwMFxcMDQ0XFwwMDBcXDA0NFxcMDAwXFwwNDRcXDAwMFxcMDQ0XFwwMDBcXDA0NFxcMDAwXFwwNDRcXDAwMFxcXG4gICAgXFwwNDRcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDA0NFxcMDAwXFwyNTVcXDI1NVxcMDQ0XFwwMDBcXFxuICAgIFxcMDQ0XFwwMDBcXDA0NFxcMDAwXFwwNDRcXDAwMFxcMDQ0XFwwMDBcXDA0NFxcMDAwXFwwNDRcXDAwMFxcMDQ0XFwwMDBcXDA0NFxcMDAwXFxcbiAgICBcXDA0NFxcMDAwXFwwNDRcXDAwMFxcMDQ0XFwwMDBcXDA0NFxcMDAwXFwwNDRcXDAwMFxcMDQ0XFwwMDBcXDA0NFxcMDAwXFwwNDRcXDAwMFxcXG4gICAgXFwwNDRcXDAwMFxcMDQ0XFwwMDBcXDA0NFxcMDAwXFwwNDRcXDAwMFxcMDQ0XFwwMDBcXDA0NFxcMDAwXFwwNDRcXDAwMFxcMDQ0XFwwMDBcXFxuICAgIFxcMDQ0XFwwMDBcXDA0NVxcMDAwXFwwNDVcXDAwMFxcMDQ1XFwwMDBcXDA0NVxcMDAwXFwwNDVcXDAwMFxcMDQ1XFwwMDBcXDA0NVxcMDAwXFxcbiAgICBcXDA0NVxcMDAwXFwwNDVcXDAwMFxcMDQ1XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDA0NVxcMDAwXFwwNDVcXDAwMFxcMDQ1XFwwMDBcXDA0NVxcMDAwXFwwNDVcXDAwMFxcMDQ1XFwwMDBcXFxuICAgIFxcMDQ1XFwwMDBcXDA0NVxcMDAwXFwwNDVcXDAwMFxcMDQ1XFwwMDBcXDA0NVxcMDAwXFwwNDVcXDAwMFxcMDQ1XFwwMDBcXDA0NVxcMDAwXFxcbiAgICBcXDA0NVxcMDAwXFwwNDVcXDAwMFxcMDQ1XFwwMDBcXDA0NVxcMDAwXFwwNDVcXDAwMFxcMDQ1XFwwMDBcXDA0NVxcMDAwXFwwNDVcXDAwMFxcXG4gICAgXFwwNDVcXDAwMFxcMDQ1XFwwMDBcXDA0NVxcMDAwXFwwNDVcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMDQ1XFwwMDBcXDI1NVxcMjU1XFwwNDVcXDAwMFxcMDQ1XFwwMDBcXDA0NVxcMDAwXFwwNDVcXDAwMFxcMDQ1XFwwMDBcXDA0NVxcMDAwXFxcbiAgICBcXDA0NVxcMDAwXFwwNDVcXDAwMFxcMDQ1XFwwMDBcXDA0NVxcMDAwXFwwNDVcXDAwMFxcMDQ1XFwwMDBcXDA0NVxcMDAwXFwwNDVcXDAwMFxcXG4gICAgXFwwNDVcXDAwMFxcMDQ1XFwwMDBcXDA0NVxcMDAwXFwwNDVcXDAwMFxcMDQ1XFwwMDBcXDA0NVxcMDAwXFwwNDVcXDAwMFxcMDQ1XFwwMDBcXFxuICAgIFxcMDQ1XFwwMDBcXDA0NVxcMDAwXFwwNDVcXDAwMFxcMDQ1XFwwMDBcXDA0NlxcMDAwXFwwNDZcXDAwMFxcMDQ2XFwwMDBcXDA0NlxcMDAwXFxcbiAgICBcXDA0NlxcMDAwXFwwNDZcXDAwMFxcMDQ2XFwwMDBcXDA0NlxcMDAwXFwwNDZcXDAwMFxcMDQ2XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDA0NlxcMDAwXFwwNDZcXDAwMFxcMDQ2XFwwMDBcXFxuICAgIFxcMDQ2XFwwMDBcXDA0NlxcMDAwXFwwNDZcXDAwMFxcMDQ2XFwwMDBcXDA0NlxcMDAwXFwwNDZcXDAwMFxcMDQ2XFwwMDBcXDA0NlxcMDAwXFxcbiAgICBcXDA0NlxcMDAwXFwwNDZcXDAwMFxcMDQ2XFwwMDBcXDA0NlxcMDAwXFwwNDZcXDAwMFxcMDQ2XFwwMDBcXDA0NlxcMDAwXFwwNDZcXDAwMFxcXG4gICAgXFwwNDZcXDAwMFxcMDQ2XFwwMDBcXDA0NlxcMDAwXFwwNDZcXDAwMFxcMDQ2XFwwMDBcXDA0NlxcMDAwXFwwNDZcXDAwMFxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDQ2XFwwMDBcXDI1NVxcMjU1XFwwNDZcXDAwMFxcMDQ2XFwwMDBcXDA0NlxcMDAwXFxcbiAgICBcXDA0NlxcMDAwXFwwNDZcXDAwMFxcMDQ2XFwwMDBcXDA0NlxcMDAwXFwwNDZcXDAwMFxcMDQ2XFwwMDBcXDA0NlxcMDAwXFwwNDZcXDAwMFxcXG4gICAgXFwwNDZcXDAwMFxcMDQ2XFwwMDBcXDA0NlxcMDAwXFwwNDZcXDAwMFxcMDQ2XFwwMDBcXDA0NlxcMDAwXFwwNDZcXDAwMFxcMDQ2XFwwMDBcXFxuICAgIFxcMDQ2XFwwMDBcXDA0NlxcMDAwXFwwNDZcXDAwMFxcMDQ2XFwwMDBcXDA0NlxcMDAwXFwwNDZcXDAwMFxcMDQ2XFwwMDBcXDA0N1xcMDAwXFxcbiAgICBcXDA0N1xcMDAwXFwwNDdcXDAwMFxcMDQ3XFwwMDBcXDA0N1xcMDAwXFwwNDdcXDAwMFxcMDQ3XFwwMDBcXDA0N1xcMDAwXFwwNDdcXDAwMFxcXG4gICAgXFwwNDdcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMDQ3XFwwMDBcXDA0N1xcMDAwXFwwNDdcXDAwMFxcMDQ3XFwwMDBcXDA0N1xcMDAwXFwwNDdcXDAwMFxcMDQ3XFwwMDBcXDA0N1xcMDAwXFxcbiAgICBcXDA0N1xcMDAwXFwwNDdcXDAwMFxcMDQ3XFwwMDBcXDA0N1xcMDAwXFwwNDdcXDAwMFxcMDQ3XFwwMDBcXDA0N1xcMDAwXFwwNDdcXDAwMFxcXG4gICAgXFwwNDdcXDAwMFxcMDQ3XFwwMDBcXDA0N1xcMDAwXFwwNDdcXDAwMFxcMDQ3XFwwMDBcXDA0N1xcMDAwXFwwNDdcXDAwMFxcMDQ3XFwwMDBcXFxuICAgIFxcMDQ3XFwwMDBcXDA0N1xcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDQ3XFwwMDBcXDI1NVxcMjU1XFxcbiAgICBcXDA0N1xcMDAwXFwwNDdcXDAwMFxcMDQ3XFwwMDBcXDA0N1xcMDAwXFwwNDdcXDAwMFxcMDQ3XFwwMDBcXDA0N1xcMDAwXFwwNDdcXDAwMFxcXG4gICAgXFwwNDdcXDAwMFxcMDQ3XFwwMDBcXDA0N1xcMDAwXFwwNDdcXDAwMFxcMDQ3XFwwMDBcXDA0N1xcMDAwXFwwNDdcXDAwMFxcMDQ3XFwwMDBcXFxuICAgIFxcMDQ3XFwwMDBcXDA0N1xcMDAwXFwwNDdcXDAwMFxcMDQ3XFwwMDBcXDA0N1xcMDAwXFwwNDdcXDAwMFxcMDQ3XFwwMDBcXDA0N1xcMDAwXFxcbiAgICBcXDA0N1xcMDAwXFwwNDdcXDAwMFxcMDQ4XFwwMDBcXDA0OFxcMDAwXFwwNDhcXDAwMFxcMDQ4XFwwMDBcXDA0OFxcMDAwXFwwNDhcXDAwMFxcXG4gICAgXFwwNDhcXDAwMFxcMDQ4XFwwMDBcXDA0OFxcMDAwXFwwNDhcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDQ4XFwwMDBcXDA0OFxcMDAwXFwwNDhcXDAwMFxcMDQ4XFwwMDBcXDA0OFxcMDAwXFxcbiAgICBcXDA0OFxcMDAwXFwwNDhcXDAwMFxcMDQ4XFwwMDBcXDA0OFxcMDAwXFwwNDhcXDAwMFxcMDQ4XFwwMDBcXDA0OFxcMDAwXFwwNDhcXDAwMFxcXG4gICAgXFwwNDhcXDAwMFxcMDQ4XFwwMDBcXDA0OFxcMDAwXFwwNDhcXDAwMFxcMDQ4XFwwMDBcXDA0OFxcMDAwXFwwNDhcXDAwMFxcMDQ4XFwwMDBcXFxuICAgIFxcMDQ4XFwwMDBcXDA0OFxcMDAwXFwwNDhcXDAwMFxcMDQ4XFwwMDBcXDA0OFxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwwNDhcXDAwMFxcMjU1XFwyNTVcXDA0OFxcMDAwXFwwNDhcXDAwMFxcMDQ4XFwwMDBcXDA0OFxcMDAwXFwwNDhcXDAwMFxcXG4gICAgXFwwNDhcXDAwMFxcMDQ4XFwwMDBcXDA0OFxcMDAwXFwwNDhcXDAwMFxcMDQ4XFwwMDBcXDA0OFxcMDAwXFwwNDhcXDAwMFxcMDQ4XFwwMDBcXFxuICAgIFxcMDQ4XFwwMDBcXDA0OFxcMDAwXFwwNDhcXDAwMFxcMDQ4XFwwMDBcXDA0OFxcMDAwXFwwNDhcXDAwMFxcMDQ4XFwwMDBcXDA0OFxcMDAwXFxcbiAgICBcXDA0OFxcMDAwXFwwNDhcXDAwMFxcMDQ4XFwwMDBcXDA0OFxcMDAwXFwwNDhcXDAwMFxcMDQ5XFwwMDBcXDA0OVxcMDAwXFwwNDlcXDAwMFxcXG4gICAgXFwwNDlcXDAwMFxcMDQ5XFwwMDBcXDA0OVxcMDAwXFwwNDlcXDAwMFxcMDQ5XFwwMDBcXDA0OVxcMDAwXFwwNDlcXDAwMFxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDQ5XFwwMDBcXDA0OVxcMDAwXFxcbiAgICBcXDA0OVxcMDAwXFwwNDlcXDAwMFxcMDQ5XFwwMDBcXDA0OVxcMDAwXFwwNDlcXDAwMFxcMDQ5XFwwMDBcXDA0OVxcMDAwXFwwNDlcXDAwMFxcXG4gICAgXFwwNDlcXDAwMFxcMDQ5XFwwMDBcXDA0OVxcMDAwXFwwNDlcXDAwMFxcMDQ5XFwwMDBcXDA0OVxcMDAwXFwwNDlcXDAwMFxcMDQ5XFwwMDBcXFxuICAgIFxcMDQ5XFwwMDBcXDA0OVxcMDAwXFwwNDlcXDAwMFxcMDQ5XFwwMDBcXDA0OVxcMDAwXFwwNDlcXDAwMFxcMDQ5XFwwMDBcXDA0OVxcMDAwXFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwNDlcXDAwMFxcMjU1XFwyNTVcXDA0OVxcMDAwXFwwNDlcXDAwMFxcXG4gICAgXFwwNDlcXDAwMFxcMDQ5XFwwMDBcXDA0OVxcMDAwXFwwNDlcXDAwMFxcMDQ5XFwwMDBcXDA0OVxcMDAwXFwwNDlcXDAwMFxcMDQ5XFwwMDBcXFxuICAgIFxcMDQ5XFwwMDBcXDA0OVxcMDAwXFwwNDlcXDAwMFxcMDQ5XFwwMDBcXDA0OVxcMDAwXFwwNDlcXDAwMFxcMDQ5XFwwMDBcXDA0OVxcMDAwXFxcbiAgICBcXDA0OVxcMDAwXFwwNDlcXDAwMFxcMDQ5XFwwMDBcXDA0OVxcMDAwXFwwNDlcXDAwMFxcMDQ5XFwwMDBcXDA0OVxcMDAwXFwwNDlcXDAwMFxcXG4gICAgXFwwNTBcXDAwMFxcMDUwXFwwMDBcXDA1MFxcMDAwXFwwNTBcXDAwMFxcMDUwXFwwMDBcXDA1MFxcMDAwXFwwNTBcXDAwMFxcMDUwXFwwMDBcXFxuICAgIFxcMDUwXFwwMDBcXDA1MFxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwwNTBcXDAwMFxcMDUwXFwwMDBcXDA1MFxcMDAwXFwwNTBcXDAwMFxcMDUwXFwwMDBcXDA1MFxcMDAwXFwwNTBcXDAwMFxcXG4gICAgXFwwNTBcXDAwMFxcMDUwXFwwMDBcXDA1MFxcMDAwXFwwNTBcXDAwMFxcMDUwXFwwMDBcXDA1MFxcMDAwXFwwNTBcXDAwMFxcMDUwXFwwMDBcXFxuICAgIFxcMDUwXFwwMDBcXDA1MFxcMDAwXFwwNTBcXDAwMFxcMDUwXFwwMDBcXDA1MFxcMDAwXFwwNTBcXDAwMFxcMDUwXFwwMDBcXDA1MFxcMDAwXFxcbiAgICBcXDA1MFxcMDAwXFwwNTBcXDAwMFxcMDUwXFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwNTBcXDAwMFxcXG4gICAgXFwyNTVcXDI1NVxcMDUwXFwwMDBcXDA1MFxcMDAwXFwwNTBcXDAwMFxcMDUwXFwwMDBcXDA1MFxcMDAwXFwwNTBcXDAwMFxcMDUwXFwwMDBcXFxuICAgIFxcMDUwXFwwMDBcXDA1MFxcMDAwXFwwNTBcXDAwMFxcMDUwXFwwMDBcXDA1MFxcMDAwXFwwNTBcXDAwMFxcMDUwXFwwMDBcXDA1MFxcMDAwXFxcbiAgICBcXDA1MFxcMDAwXFwwNTBcXDAwMFxcMDUwXFwwMDBcXDA1MFxcMDAwXFwwNTBcXDAwMFxcMDUwXFwwMDBcXDA1MFxcMDAwXFwwNTBcXDAwMFxcXG4gICAgXFwwNTBcXDAwMFxcMDUwXFwwMDBcXDA1MFxcMDAwXFwwNTFcXDAwMFxcMDUxXFwwMDBcXDA1MVxcMDAwXFwwNTFcXDAwMFxcMDUxXFwwMDBcXFxuICAgIFxcMDUxXFwwMDBcXDA1MVxcMDAwXFwwNTFcXDAwMFxcMDUxXFwwMDBcXDA1MVxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwNTFcXDAwMFxcMDUxXFwwMDBcXDA1MVxcMDAwXFwwNTFcXDAwMFxcXG4gICAgXFwwNTFcXDAwMFxcMDUxXFwwMDBcXDA1MVxcMDAwXFwwNTFcXDAwMFxcMDUxXFwwMDBcXDA1MVxcMDAwXFwwNTFcXDAwMFxcMDUxXFwwMDBcXFxuICAgIFxcMDUxXFwwMDBcXDA1MVxcMDAwXFwwNTFcXDAwMFxcMDUxXFwwMDBcXDA1MVxcMDAwXFwwNTFcXDAwMFxcMDUxXFwwMDBcXDA1MVxcMDAwXFxcbiAgICBcXDA1MVxcMDAwXFwwNTFcXDAwMFxcMDUxXFwwMDBcXDA1MVxcMDAwXFwwNTFcXDAwMFxcMDUxXFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDA1MVxcMDAwXFwyNTVcXDI1NVxcMDUxXFwwMDBcXDA1MVxcMDAwXFwwNTFcXDAwMFxcMDUxXFwwMDBcXFxuICAgIFxcMDUxXFwwMDBcXDA1MVxcMDAwXFwwNTFcXDAwMFxcMDUxXFwwMDBcXDA1MVxcMDAwXFwwNTFcXDAwMFxcMDUxXFwwMDBcXDA1MVxcMDAwXFxcbiAgICBcXDA1MVxcMDAwXFwwNTFcXDAwMFxcMDUxXFwwMDBcXDA1MVxcMDAwXFwwNTFcXDAwMFxcMDUxXFwwMDBcXDA1MVxcMDAwXFwwNTFcXDAwMFxcXG4gICAgXFwwNTFcXDAwMFxcMDUxXFwwMDBcXDA1MVxcMDAwXFwwNTFcXDAwMFxcMDUxXFwwMDBcXDA1MVxcMDAwXFwwNTJcXDAwMFxcMDUyXFwwMDBcXFxuICAgIFxcMDUyXFwwMDBcXDA1MlxcMDAwXFwwNTJcXDAwMFxcMDUyXFwwMDBcXDA1MlxcMDAwXFwwNTJcXDAwMFxcMDUyXFwwMDBcXDA1MlxcMDAwXFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwNTJcXDAwMFxcXG4gICAgXFwwNTJcXDAwMFxcMDUyXFwwMDBcXDA1MlxcMDAwXFwwNTJcXDAwMFxcMDUyXFwwMDBcXDA1MlxcMDAwXFwwNTJcXDAwMFxcMDUyXFwwMDBcXFxuICAgIFxcMDUyXFwwMDBcXDA1MlxcMDAwXFwwNTJcXDAwMFxcMDUyXFwwMDBcXDA1MlxcMDAwXFwwNTJcXDAwMFxcMDUyXFwwMDBcXDA1MlxcMDAwXFxcbiAgICBcXDA1MlxcMDAwXFwwNTJcXDAwMFxcMDUyXFwwMDBcXDA1MlxcMDAwXFwwNTJcXDAwMFxcMDUyXFwwMDBcXDA1MlxcMDAwXFwwNTJcXDAwMFxcXG4gICAgXFwwNTJcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDA1MlxcMDAwXFwyNTVcXDI1NVxcMDUyXFwwMDBcXFxuICAgIFxcMDUyXFwwMDBcXDA1MlxcMDAwXFwwNTJcXDAwMFxcMDUyXFwwMDBcXDA1MlxcMDAwXFwwNTJcXDAwMFxcMDUyXFwwMDBcXDA1MlxcMDAwXFxcbiAgICBcXDA1MlxcMDAwXFwwNTJcXDAwMFxcMDUyXFwwMDBcXDA1MlxcMDAwXFwwNTJcXDAwMFxcMDUyXFwwMDBcXDA1MlxcMDAwXFwwNTJcXDAwMFxcXG4gICAgXFwwNTJcXDAwMFxcMDUyXFwwMDBcXDA1MlxcMDAwXFwwNTJcXDAwMFxcMDUyXFwwMDBcXDA1MlxcMDAwXFwwNTJcXDAwMFxcMDUyXFwwMDBcXFxuICAgIFxcMDUyXFwwMDBcXDA1M1xcMDAwXFwwNTNcXDAwMFxcMDUzXFwwMDBcXDA1M1xcMDAwXFwwNTNcXDAwMFxcMDUzXFwwMDBcXDA1M1xcMDAwXFxcbiAgICBcXDA1M1xcMDAwXFwwNTNcXDAwMFxcMDUzXFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDA1M1xcMDAwXFwwNTNcXDAwMFxcMDUzXFwwMDBcXDA1M1xcMDAwXFwwNTNcXDAwMFxcMDUzXFwwMDBcXFxuICAgIFxcMDUzXFwwMDBcXDA1M1xcMDAwXFwwNTNcXDAwMFxcMDUzXFwwMDBcXDA1M1xcMDAwXFwwNTNcXDAwMFxcMDUzXFwwMDBcXDA1M1xcMDAwXFxcbiAgICBcXDA1M1xcMDAwXFwwNTNcXDAwMFxcMDUzXFwwMDBcXDA1M1xcMDAwXFwwNTNcXDAwMFxcMDUzXFwwMDBcXDA1M1xcMDAwXFwwNTNcXDAwMFxcXG4gICAgXFwwNTNcXDAwMFxcMDUzXFwwMDBcXDA1M1xcMDAwXFwwNTNcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMDUzXFwwMDBcXDI1NVxcMjU1XFwwNTNcXDAwMFxcMDUzXFwwMDBcXDA1M1xcMDAwXFwwNTNcXDAwMFxcMDUzXFwwMDBcXDA1M1xcMDAwXFxcbiAgICBcXDA1M1xcMDAwXFwwNTNcXDAwMFxcMDUzXFwwMDBcXDA1M1xcMDAwXFwwNTNcXDAwMFxcMDUzXFwwMDBcXDA1M1xcMDAwXFwwNTNcXDAwMFxcXG4gICAgXFwwNTNcXDAwMFxcMDUzXFwwMDBcXDA1M1xcMDAwXFwwNTNcXDAwMFxcMDUzXFwwMDBcXDA1M1xcMDAwXFwwNTNcXDAwMFxcMDUzXFwwMDBcXFxuICAgIFxcMDUzXFwwMDBcXDA1M1xcMDAwXFwwNTNcXDAwMFxcMDUzXFwwMDBcXDA2M1xcMDAwXFwwNjNcXDAwMFxcMDYzXFwwMDBcXDA2M1xcMDAwXFxcbiAgICBcXDA2M1xcMDAwXFwwNjNcXDAwMFxcMDYzXFwwMDBcXDA2M1xcMDAwXFwwNjNcXDAwMFxcMDYzXFwwMDBcXDA2OFxcMDAwXFwwNzJcXDAwMFxcXG4gICAgXFwyNTVcXDI1NVxcMDY4XFwwMDBcXDA3MlxcMDAwXFwwNzNcXDAwMFxcMjU1XFwyNTVcXDA2M1xcMDAwXFwwNjNcXDAwMFxcMDYzXFwwMDBcXFxuICAgIFxcMDYzXFwwMDBcXDA2M1xcMDAwXFwwNjNcXDAwMFxcMDY1XFwwMDBcXDA2NVxcMDAwXFwwNjVcXDAwMFxcMDY1XFwwMDBcXDA2NVxcMDAwXFxcbiAgICBcXDA2NVxcMDAwXFwwNjVcXDAwMFxcMDY1XFwwMDBcXDA2NVxcMDAwXFwwNjVcXDAwMFxcMjU1XFwyNTVcXDA2OFxcMDAwXFwwNzJcXDAwMFxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDY1XFwwMDBcXDA2NVxcMDAwXFwwNjVcXDAwMFxcMDY1XFwwMDBcXFxuICAgIFxcMDY1XFwwMDBcXDA2NVxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwNjNcXDAwMFxcMDYzXFwwMDBcXDA2M1xcMDAwXFxcbiAgICBcXDA2M1xcMDAwXFwwNjNcXDAwMFxcMDYzXFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwwNzNcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwNzNcXDAwMFxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwNzNcXDAwMFxcMjU1XFwyNTVcXDA2NVxcMDAwXFwwNjVcXDAwMFxcMDY1XFwwMDBcXDA2NVxcMDAwXFxcbiAgICBcXDA2NVxcMDAwXFwwNjVcXDAwMFxcMDczXFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDA3M1xcMDAwXFwyNTVcXDI1NVxcXG4gICAgXFwwNzNcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMDY4XFwwMDBcXDA3MlxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDY4XFwwMDBcXDA3MlxcMDAwXCI7XG4gIExleGluZy5sZXhfYmFzZV9jb2RlID1cbiAgIFwiXCI7XG4gIExleGluZy5sZXhfYmFja3Rya19jb2RlID1cbiAgIFwiXCI7XG4gIExleGluZy5sZXhfZGVmYXVsdF9jb2RlID1cbiAgIFwiXCI7XG4gIExleGluZy5sZXhfdHJhbnNfY29kZSA9XG4gICBcIlwiO1xuICBMZXhpbmcubGV4X2NoZWNrX2NvZGUgPVxuICAgXCJcIjtcbiAgTGV4aW5nLmxleF9jb2RlID1cbiAgIFwiXCI7XG59XG5cbmxldCByZWMgcmVhZCBsZXhidWYgPVxuICAgX19vY2FtbF9sZXhfcmVhZF9yZWMgbGV4YnVmIDBcbmFuZCBfX29jYW1sX2xleF9yZWFkX3JlYyBsZXhidWYgX19vY2FtbF9sZXhfc3RhdGUgPVxuICBtYXRjaCBMZXhpbmcuZW5naW5lIF9fb2NhbWxfbGV4X3RhYmxlcyBfX29jYW1sX2xleF9zdGF0ZSBsZXhidWYgd2l0aFxuICAgICAgfCAwIC0+XG4jIDQ0IFwiSU8vbGV4ZXIubWxsXCJcbiAgICAgICAgICAgICAgICAgICAoIEVPRiApXG4jIDQ2MCBcIklPL2xleGVyLm1sXCJcblxuICB8IDEgLT5cbiMgNDUgXCJJTy9sZXhlci5tbGxcIlxuICAgICAgICAgICAgICAoIEhFQURFUiApXG4jIDQ2NSBcIklPL2xleGVyLm1sXCJcblxuICB8IDIgLT5cbiMgNDYgXCJJTy9sZXhlci5tbGxcIlxuICAgICAgICAgICAgICAoIE5VTEwgKVxuIyA0NzAgXCJJTy9sZXhlci5tbFwiXG5cbiAgfCAzIC0+XG4jIDQ3IFwiSU8vbGV4ZXIubWxsXCJcbiAgICAgICAgICAgICAgKCBCT09MIHRydWUgKVxuIyA0NzUgXCJJTy9sZXhlci5tbFwiXG5cbiAgfCA0IC0+XG4jIDQ4IFwiSU8vbGV4ZXIubWxsXCJcbiAgICAgICAgICAgICAgKCBCT09MIGZhbHNlIClcbiMgNDgwIFwiSU8vbGV4ZXIubWxcIlxuXG4gIHwgNSAtPlxuIyA0OSBcIklPL2xleGVyLm1sbFwiXG4gICAgICAgICAgICAgICggTFNISUZUIClcbiMgNDg1IFwiSU8vbGV4ZXIubWxcIlxuXG4gIHwgNiAtPlxuIyA1MCBcIklPL2xleGVyLm1sbFwiXG4gICAgICAgICAgICAgICggUlNISUZUIClcbiMgNDkwIFwiSU8vbGV4ZXIubWxcIlxuXG4gIHwgNyAtPlxuIyA1MSBcIklPL2xleGVyLm1sbFwiXG4gICAgICAgICAgICAgICggRVEgKVxuIyA0OTUgXCJJTy9sZXhlci5tbFwiXG5cbiAgfCA4IC0+XG4jIDUyIFwiSU8vbGV4ZXIubWxsXCJcbiAgICAgICAgICAgICAgKCBORVEgKVxuIyA1MDAgXCJJTy9sZXhlci5tbFwiXG5cbiAgfCA5IC0+XG4jIDUzIFwiSU8vbGV4ZXIubWxsXCJcbiAgICAgICAgICAgICAgKCBCT1IgKVxuIyA1MDUgXCJJTy9sZXhlci5tbFwiXG5cbiAgfCAxMCAtPlxuIyA1NCBcIklPL2xleGVyLm1sbFwiXG4gICAgICAgICAgICAgICggQkFORCApXG4jIDUxMCBcIklPL2xleGVyLm1sXCJcblxuICB8IDExIC0+XG4jIDU1IFwiSU8vbGV4ZXIubWxsXCJcbiAgICAgICAgICAgICAgKCByZWFkX2NvbW1lbnQgbGV4YnVmIClcbiMgNTE1IFwiSU8vbGV4ZXIubWxcIlxuXG4gIHwgMTIgLT5cbiMgNTYgXCJJTy9sZXhlci5tbGxcIlxuICAgICAgICAgICAgICAoIHJlYWQgbGV4YnVmIClcbiMgNTIwIFwiSU8vbGV4ZXIubWxcIlxuXG4gIHwgMTMgLT5cbiMgNTcgXCJJTy9sZXhlci5tbGxcIlxuICAgICAgICAgICAgICAgICAoIG5leHRfbGluZSBsZXhidWYgOyByZWFkIGxleGJ1ZiApXG4jIDUyNSBcIklPL2xleGVyLm1sXCJcblxuICB8IDE0IC0+XG4jIDU4IFwiSU8vbGV4ZXIubWxsXCJcbiAgICAgICAgICAgICAgKCBuZXh0X2xpbmUgbGV4YnVmIDsgRU9MIClcbiMgNTMwIFwiSU8vbGV4ZXIubWxcIlxuXG4gIHwgMTUgLT5cbiMgNTkgXCJJTy9sZXhlci5tbGxcIlxuICAgICAgICAgICAgICAoIE5VTUJFUiAoVXRpbHMudWludDMyX29mX3N0ciAoTGV4aW5nLmxleGVtZSBsZXhidWYpKSApXG4jIDUzNSBcIklPL2xleGVyLm1sXCJcblxuICB8IDE2IC0+XG4jIDYwIFwiSU8vbGV4ZXIubWxsXCJcbiAgICAgICAgICAgICAgKCBJRCAoTGV4aW5nLmxleGVtZSBsZXhidWYpIClcbiMgNTQwIFwiSU8vbGV4ZXIubWxcIlxuXG4gIHwgMTcgLT5cbiMgNjEgXCJJTy9sZXhlci5tbGxcIlxuICAgICAgICAgICAgICAoIHJlYWRfc3RyaW5nIChCdWZmZXIuY3JlYXRlIDE3KSBsZXhidWYgKVxuIyA1NDUgXCJJTy9sZXhlci5tbFwiXG5cbiAgfCAxOCAtPlxuIyA2MiBcIklPL2xleGVyLm1sbFwiXG4gICAgICAgICAgICAgICggRVFVQUwgKVxuIyA1NTAgXCJJTy9sZXhlci5tbFwiXG5cbiAgfCAxOSAtPlxuIyA2MyBcIklPL2xleGVyLm1sbFwiXG4gICAgICAgICAgICAgICggSEFTSCApXG4jIDU1NSBcIklPL2xleGVyLm1sXCJcblxuICB8IDIwIC0+XG4jIDY0IFwiSU8vbGV4ZXIubWxsXCJcbiAgICAgICAgICAgICAgKCBMRUZUX0JSQUNLIClcbiMgNTYwIFwiSU8vbGV4ZXIubWxcIlxuXG4gIHwgMjEgLT5cbiMgNjUgXCJJTy9sZXhlci5tbGxcIlxuICAgICAgICAgICAgICAoIFJJR0hUX0JSQUNLIClcbiMgNTY1IFwiSU8vbGV4ZXIubWxcIlxuXG4gIHwgMjIgLT5cbiMgNjYgXCJJTy9sZXhlci5tbGxcIlxuICAgICAgICAgICAgICAoIExFRlRfQlJBQ0UgKVxuIyA1NzAgXCJJTy9sZXhlci5tbFwiXG5cbiAgfCAyMyAtPlxuIyA2NyBcIklPL2xleGVyLm1sbFwiXG4gICAgICAgICAgICAgICggUklHSFRfQlJBQ0UgKVxuIyA1NzUgXCJJTy9sZXhlci5tbFwiXG5cbiAgfCAyNCAtPlxuIyA2OCBcIklPL2xleGVyLm1sbFwiXG4gICAgICAgICAgICAgICggQ09NTUEgKVxuIyA1ODAgXCJJTy9sZXhlci5tbFwiXG5cbiAgfCAyNSAtPlxuIyA2OSBcIklPL2xleGVyLm1sbFwiXG4gICAgICAgICAgICAgICggRVhDTEFNX01BUksgKVxuIyA1ODUgXCJJTy9sZXhlci5tbFwiXG5cbiAgfCAyNiAtPlxuIyA3MCBcIklPL2xleGVyLm1sbFwiXG4gICAgICAgICAgICAgICggSU5URVJST0dfTUFSSyApXG4jIDU5MCBcIklPL2xleGVyLm1sXCJcblxuICB8IDI3IC0+XG4jIDcxIFwiSU8vbGV4ZXIubWxsXCJcbiAgICAgICAgICAgICAgKCBDT0xPTiApXG4jIDU5NSBcIklPL2xleGVyLm1sXCJcblxuICB8IDI4IC0+XG4jIDcyIFwiSU8vbGV4ZXIubWxsXCJcbiAgICAgICAgICAgICAgKCBMUEFSRU4gKVxuIyA2MDAgXCJJTy9sZXhlci5tbFwiXG5cbiAgfCAyOSAtPlxuIyA3MyBcIklPL2xleGVyLm1sbFwiXG4gICAgICAgICAgICAgICggUlBBUkVOIClcbiMgNjA1IFwiSU8vbGV4ZXIubWxcIlxuXG4gIHwgMzAgLT5cbiMgNzQgXCJJTy9sZXhlci5tbGxcIlxuICAgICAgICAgICAgICAoIFBMVVMgKVxuIyA2MTAgXCJJTy9sZXhlci5tbFwiXG5cbiAgfCAzMSAtPlxuIyA3NSBcIklPL2xleGVyLm1sbFwiXG4gICAgICAgICAgICAgICggTUlOVVMgKVxuIyA2MTUgXCJJTy9sZXhlci5tbFwiXG5cbiAgfCAzMiAtPlxuIyA3NiBcIklPL2xleGVyLm1sbFwiXG4gICAgICAgICAgICAgICggVElNRVMgKVxuIyA2MjAgXCJJTy9sZXhlci5tbFwiXG5cbiAgfCAzMyAtPlxuIyA3NyBcIklPL2xleGVyLm1sbFwiXG4gICAgICAgICAgICAgICggRElWIClcbiMgNjI1IFwiSU8vbGV4ZXIubWxcIlxuXG4gIHwgMzQgLT5cbiMgNzggXCJJTy9sZXhlci5tbGxcIlxuICAgICAgICAgICAgICAoIE1PRCApXG4jIDYzMCBcIklPL2xleGVyLm1sXCJcblxuICB8IDM1IC0+XG4jIDc5IFwiSU8vbGV4ZXIubWxsXCJcbiAgICAgICAgICAgICAgKCBBTkQgKVxuIyA2MzUgXCJJTy9sZXhlci5tbFwiXG5cbiAgfCAzNiAtPlxuIyA4MCBcIklPL2xleGVyLm1sbFwiXG4gICAgICAgICAgICAgICggT1IgKVxuIyA2NDAgXCJJTy9sZXhlci5tbFwiXG5cbiAgfCAzNyAtPlxuIyA4MSBcIklPL2xleGVyLm1sbFwiXG4gICAgICAgICAgICAgICggWE9SIClcbiMgNjQ1IFwiSU8vbGV4ZXIubWxcIlxuXG4gIHwgMzggLT5cbiMgODIgXCJJTy9sZXhlci5tbGxcIlxuICAgICAgICAgICAgICAoIE5PVCApXG4jIDY1MCBcIklPL2xleGVyLm1sXCJcblxuICB8IDM5IC0+XG4jIDgzIFwiSU8vbGV4ZXIubWxsXCJcbiAgICAgICAgICAgICAgKCBlb2ZfcmVhY2hlZCBsZXhidWYgOyBFT0YgKVxuIyA2NTUgXCJJTy9sZXhlci5tbFwiXG5cbiAgfCA0MCAtPlxuIyA4NCBcIklPL2xleGVyLm1sbFwiXG4gICAgICAoIHJhaXNlIChTeW50YXhFcnJvciAoXCJVbmV4cGVjdGVkIGNoYXI6IFwiIF4gTGV4aW5nLmxleGVtZSBsZXhidWYpKSApXG4jIDY2MCBcIklPL2xleGVyLm1sXCJcblxuICB8IF9fb2NhbWxfbGV4X3N0YXRlIC0+IGxleGJ1Zi5MZXhpbmcucmVmaWxsX2J1ZmYgbGV4YnVmO1xuICAgICAgX19vY2FtbF9sZXhfcmVhZF9yZWMgbGV4YnVmIF9fb2NhbWxfbGV4X3N0YXRlXG5cbmFuZCByZWFkX3N0cmluZyBidWYgbGV4YnVmID1cbiAgIF9fb2NhbWxfbGV4X3JlYWRfc3RyaW5nX3JlYyBidWYgbGV4YnVmIDY4XG5hbmQgX19vY2FtbF9sZXhfcmVhZF9zdHJpbmdfcmVjIGJ1ZiBsZXhidWYgX19vY2FtbF9sZXhfc3RhdGUgPVxuICBtYXRjaCBMZXhpbmcuZW5naW5lIF9fb2NhbWxfbGV4X3RhYmxlcyBfX29jYW1sX2xleF9zdGF0ZSBsZXhidWYgd2l0aFxuICAgICAgfCAwIC0+XG4jIDg3IFwiSU8vbGV4ZXIubWxsXCJcbiAgICAgICAgICAgICAgKCBTVFJJTkcgKEJ1ZmZlci5jb250ZW50cyBidWYpIClcbiMgNjcyIFwiSU8vbGV4ZXIubWxcIlxuXG4gIHwgMSAtPlxuIyA4OCBcIklPL2xleGVyLm1sbFwiXG4gICAgICAgICAgICAgICggQnVmZmVyLmFkZF9jaGFyIGJ1ZiAnLyc7IHJlYWRfc3RyaW5nIGJ1ZiBsZXhidWYgKVxuIyA2NzcgXCJJTy9sZXhlci5tbFwiXG5cbiAgfCAyIC0+XG4jIDg5IFwiSU8vbGV4ZXIubWxsXCJcbiAgICAgICAgICAgICAgKCBCdWZmZXIuYWRkX2NoYXIgYnVmICdcXFxcJzsgcmVhZF9zdHJpbmcgYnVmIGxleGJ1ZiApXG4jIDY4MiBcIklPL2xleGVyLm1sXCJcblxuICB8IDMgLT5cbiMgOTAgXCJJTy9sZXhlci5tbGxcIlxuICAgICAgICAgICAgICAoIEJ1ZmZlci5hZGRfY2hhciBidWYgJ1xcYic7IHJlYWRfc3RyaW5nIGJ1ZiBsZXhidWYgKVxuIyA2ODcgXCJJTy9sZXhlci5tbFwiXG5cbiAgfCA0IC0+XG4jIDkxIFwiSU8vbGV4ZXIubWxsXCJcbiAgICAgICAgICAgICAgKCBCdWZmZXIuYWRkX2NoYXIgYnVmICdcXDAxMic7IHJlYWRfc3RyaW5nIGJ1ZiBsZXhidWYgKVxuIyA2OTIgXCJJTy9sZXhlci5tbFwiXG5cbiAgfCA1IC0+XG4jIDkyIFwiSU8vbGV4ZXIubWxsXCJcbiAgICAgICAgICAgICAgKCBCdWZmZXIuYWRkX2NoYXIgYnVmICdcXG4nOyByZWFkX3N0cmluZyBidWYgbGV4YnVmIClcbiMgNjk3IFwiSU8vbGV4ZXIubWxcIlxuXG4gIHwgNiAtPlxuIyA5MyBcIklPL2xleGVyLm1sbFwiXG4gICAgICAgICAgICAgICggQnVmZmVyLmFkZF9jaGFyIGJ1ZiAnXFxyJzsgcmVhZF9zdHJpbmcgYnVmIGxleGJ1ZiApXG4jIDcwMiBcIklPL2xleGVyLm1sXCJcblxuICB8IDcgLT5cbiMgOTQgXCJJTy9sZXhlci5tbGxcIlxuICAgICAgICAgICAgICAoIEJ1ZmZlci5hZGRfY2hhciBidWYgJ1xcdCc7IHJlYWRfc3RyaW5nIGJ1ZiBsZXhidWYgKVxuIyA3MDcgXCJJTy9sZXhlci5tbFwiXG5cbiAgfCA4IC0+XG4jIDk2IFwiSU8vbGV4ZXIubWxsXCJcbiAgICAoIEJ1ZmZlci5hZGRfc3RyaW5nIGJ1ZiAoTGV4aW5nLmxleGVtZSBsZXhidWYpO1xuICAgICAgcmVhZF9zdHJpbmcgYnVmIGxleGJ1ZlxuICAgIClcbiMgNzE0IFwiSU8vbGV4ZXIubWxcIlxuXG4gIHwgOSAtPlxuIyA5OSBcIklPL2xleGVyLm1sbFwiXG4gICAgICAgICAgICAoIHJhaXNlIChTeW50YXhFcnJvciAoXCJTdHJpbmcgY2Fubm90IGJlIG11bHRpbGluZVwiKSkgKVxuIyA3MTkgXCJJTy9sZXhlci5tbFwiXG5cbiAgfCAxMCAtPlxuIyAxMDAgXCJJTy9sZXhlci5tbGxcIlxuICAgICAgICAoIHJhaXNlIChTeW50YXhFcnJvciAoXCJTdHJpbmcgaXMgbm90IHRlcm1pbmF0ZWRcIikpIClcbiMgNzI0IFwiSU8vbGV4ZXIubWxcIlxuXG4gIHwgMTEgLT5cbiMgMTAxIFwiSU8vbGV4ZXIubWxsXCJcbiAgICAgICggcmFpc2UgKFN5bnRheEVycm9yIChcIklsbGVnYWwgc3RyaW5nIGNoYXJhY3RlcjogXCIgXiBMZXhpbmcubGV4ZW1lIGxleGJ1ZikpIClcbiMgNzI5IFwiSU8vbGV4ZXIubWxcIlxuXG4gIHwgX19vY2FtbF9sZXhfc3RhdGUgLT4gbGV4YnVmLkxleGluZy5yZWZpbGxfYnVmZiBsZXhidWY7XG4gICAgICBfX29jYW1sX2xleF9yZWFkX3N0cmluZ19yZWMgYnVmIGxleGJ1ZiBfX29jYW1sX2xleF9zdGF0ZVxuXG5hbmQgcmVhZF9jb21tZW50IGxleGJ1ZiA9XG4gICBfX29jYW1sX2xleF9yZWFkX2NvbW1lbnRfcmVjIGxleGJ1ZiA4MlxuYW5kIF9fb2NhbWxfbGV4X3JlYWRfY29tbWVudF9yZWMgbGV4YnVmIF9fb2NhbWxfbGV4X3N0YXRlID1cbiAgbWF0Y2ggTGV4aW5nLmVuZ2luZSBfX29jYW1sX2xleF90YWJsZXMgX19vY2FtbF9sZXhfc3RhdGUgbGV4YnVmIHdpdGhcbiAgICAgIHwgMCAtPlxuIyAxMDQgXCJJTy9sZXhlci5tbGxcIlxuICAgICAgICAgICAgKCBuZXh0X2xpbmUgbGV4YnVmIDsgRU9MIClcbiMgNzQxIFwiSU8vbGV4ZXIubWxcIlxuXG4gIHwgMSAtPlxuIyAxMDUgXCJJTy9sZXhlci5tbGxcIlxuICAgICAgICAoIGVvZl9yZWFjaGVkIGxleGJ1ZiA7IEVPRiApXG4jIDc0NiBcIklPL2xleGVyLm1sXCJcblxuICB8IDIgLT5cbiMgMTA2IFwiSU8vbGV4ZXIubWxsXCJcbiAgICAgICggcmVhZF9jb21tZW50IGxleGJ1ZiApXG4jIDc1MSBcIklPL2xleGVyLm1sXCJcblxuICB8IF9fb2NhbWxfbGV4X3N0YXRlIC0+IGxleGJ1Zi5MZXhpbmcucmVmaWxsX2J1ZmYgbGV4YnVmO1xuICAgICAgX19vY2FtbF9sZXhfcmVhZF9jb21tZW50X3JlYyBsZXhidWYgX19vY2FtbF9sZXhfc3RhdGVcblxuOztcblxuIiwiXG5leGNlcHRpb24gQm94Rml0dGluZ0Vycm9yIG9mIHN0cmluZ1xuXG5sZXQgZGVmYXVsdF9maWxsZXJzID1cbiAgW3xcbiAgICBbMHhGRiA7IDB4MDAgOyAweDAwIDsgMHgwMF0oKiAwMDAwMDBGRiAqKSA7XG4gICAgWzB4MDAgOyAweEZGIDsgMHgwMCA7IDB4MDBdKCogMDAwMEZGMDAgKikgO1xuICAgIFsweDAwIDsgMHgwMCA7IDB4RkYgOyAweDAwXSgqIDAwRkYwMDAwICopIDtcbiAgICBbMHgwMCA7IDB4MDAgOyAweDAwIDsgMHhGRl0oKiBGRjAwMDAwMCAqKSA7XG4gIHxdXG5cbmxldCBub3BfY29kZSA9IFsweDAwIDsgMHgwMCA7IDB4MDAgOyAweDAwXSAoKiAwMDAwMDAwMCA6IGFuZGVxIHIwLCByMCwgcjAgKilcbmxldCBub3BfY29kZTIgPSBbMHgwMCA7IDB4MDAgOyAweDAwIDsgMHhCMF0gKCogQjAwMDAwMDAgOiBhbmRsdCByMCwgcjAsIHIwICopXG5cbmxldCBuYW1lX3NpemUgPSA4XG5sZXQgbmJfYm94ZXMgPSAxNFxuXG5sZXQgZW9mID0gTmFtZS5lb2ZcblxubGV0IG5vX2VvZiBjb2RlcyA9XG4gIExpc3QuZm9yX2FsbCAoZnVuIGMgLT4gYyA8PiBlb2YpIGNvZGVzXG5cbmxldCByZWMgb25seV9jb25zZWN1dGl2ZV9lb2YgY29kZXMgPVxuICBtYXRjaCBjb2RlcyB3aXRoXG4gIHwgW10gLT4gdHJ1ZVxuICB8IGM6OmNvZGVzIHdoZW4gYyA8PiBlb2YgLT4gb25seV9jb25zZWN1dGl2ZV9lb2YgY29kZXNcbiAgfCBfOjpjJzo6Y29kZXMgd2hlbiBjJyA9IGVvZiAtPiBvbmx5X2NvbnNlY3V0aXZlX2VvZiAoYyc6OmNvZGVzKVxuICB8IF86OmNvZGVzIC0+IG5vX2VvZiBjb2Rlc1xuXG5sZXQgbGFzdF9lb2ZfaW5kZXggY29kZXMgPVxuICBsZXQgbiA9IExpc3QubGVuZ3RoIGNvZGVzIGluXG4gIGxldCBjb2RlcyA9IExpc3QucmV2IGNvZGVzIGluXG4gIGxldCByZWMgYXV4IGFjYyBjb2RlcyA9XG4gICAgbWF0Y2ggY29kZXMgd2l0aFxuICAgIHwgW10gLT4gYXNzZXJ0IGZhbHNlXG4gICAgfCBjOjpfIHdoZW4gYyA9IGVvZiAtPiBhY2NcbiAgICB8IF86OmNvZGVzIC0+IGF1eCAoYWNjKzEpIGNvZGVzXG4gIGluXG4gIG4gLSAxIC0gKGF1eCAwIGNvZGVzKVxuXG5sZXQgZmlyc3Rfbm9uX2VvZl9pbmRleCBjb2RlcyA9XG4gIGxldCByZWMgYXV4IGFjYyBjb2RlcyA9XG4gICAgbWF0Y2ggY29kZXMgd2l0aFxuICAgIHwgYzo6Y29kZXMgd2hlbiBjID0gZW9mIC0+IGF1eCAoYWNjKzEpIGNvZGVzXG4gICAgfCBfIC0+IGFjY1xuICBpblxuICBhdXggMCBjb2Rlc1xuXG5sZXQgcGFkIGZpbGxlcnMgcG9zID1cbiAgbGV0IHBvcyA9IHBvcyBtb2QgKG5hbWVfc2l6ZSsxKSBpblxuICBsZXQgbiA9IExpc3QubGVuZ3RoIG5vcF9jb2RlIGluXG4gIGlmIHBvcyArIG4gPD0gbmFtZV9zaXplXG4gIHRoZW4gbm9wX2NvZGVcbiAgZWxzZSBmaWxsZXJzLihuYW1lX3NpemUtcG9zKVxuXG5sZXQgcmVjIHBhZF9uYiBmaWxsZXJzIHBvcyBuYiA9XG4gIGlmIG5iIDwgMCB0aGVuIGZhaWx3aXRoIFwiSW52YWxpZCBzdGFydGluZyBwb3NpdGlvbi5cIlxuICBlbHNlIGlmIG5iID0gMCB0aGVuIFtdXG4gIGVsc2VcbiAgICBsZXQgY29kZSA9IHBhZCBmaWxsZXJzIHBvcyBpblxuICAgIGxldCBtID0gTGlzdC5sZW5ndGggY29kZSBpblxuICAgIGNvZGVAKHBhZF9uYiBmaWxsZXJzIChwb3MgKyBtKSAobmIgLSBtKSlcblxubGV0IHJlYyBmaXRfY29kZV9hdF9wb3MgPyhuZXh0PVNvbWUgW10pIGZpbGxlcnMgcG9zIGNvZGVzID1cbiAgbGV0IHBvcyA9IHBvcyBtb2QgKG5hbWVfc2l6ZSsxKSBpblxuICBsZXQgbiA9IExpc3QubGVuZ3RoIGNvZGVzIGluXG4gIGxldCBpc19va19oZXJlID1cbiAgICBpZiBub19lb2YgY29kZXNcbiAgICB0aGVuIHBvcyArIG4gPD0gbmFtZV9zaXplXG4gICAgZWxzZSBpZiBvbmx5X2NvbnNlY3V0aXZlX2VvZiBjb2Rlc1xuICAgIHRoZW5cbiAgICAgIGxldCBpID0gbGFzdF9lb2ZfaW5kZXggY29kZXMgaW5cbiAgICAgIGxldCBqID0gbWF0Y2ggbmV4dCB3aXRoIFNvbWUgbmV4dCAtPiBmaXJzdF9ub25fZW9mX2luZGV4IG5leHQgfCBOb25lIC0+IDAgaW5cbiAgICAgIChwb3MraSA9IG5hbWVfc2l6ZSkgfHxcbiAgICAgIChpID0gbi0xICYmIHBvcytpKzEgPSBuYW1lX3NpemUpIHx8ICgqIEZvbGxvd2VkIGJ5IGZpbGxlciBjb2RlICopXG4gICAgICAoaSA9IG4tMSAmJiBwb3MraStqID0gbmFtZV9zaXplKSB8fCAoKiBGb2xsb3dlZCBieSBuZXh0IGNvZGUgKilcbiAgICAgIChuZXh0ID0gTm9uZSAmJiBpID0gbi0xICYmIHBvcytpIDw9IG5hbWVfc2l6ZSkgKCogTm90aGluZyBhZnRlciAqKVxuICAgIGVsc2UgcmFpc2UgKEJveEZpdHRpbmdFcnJvclxuICAgIFwiU29tZSBjb2RlcyBjYW5ub3QgYmUgcG9zaXRpb25uZWQgZHVlIHRvIG5vbi1jb25zZWN1dGl2ZSAweEZGIGJ5dGVzLlwiKVxuICBpblxuICBpZiBpc19va19oZXJlIHRoZW4gY29kZXNcbiAgZWxzZSBiZWdpblxuICAgIGxldCBub3BfY29kZSA9XG4gICAgICBpZiBwb3MgKyBuIDw9IG5hbWVfc2l6ZSB0aGVuIG5vcF9jb2RlXG4gICAgICBlbHNlIGZpbGxlcnMuKG5hbWVfc2l6ZS1wb3MpXG4gICAgaW5cbiAgICBsZXQgbSA9IExpc3QubGVuZ3RoIG5vcF9jb2RlIGluXG4gICAgbm9wX2NvZGVAKGZpdF9jb2RlX2F0X3BvcyB+bmV4dCBmaWxsZXJzIChwb3MgKyBtKSBjb2RlcylcbiAgZW5kXG5cbmxldCBhZGRfY29kZXNfYWZ0ZXIgPyhmaW5hbD1mYWxzZSkgZmlsbGVycyByZXMgY29kZXMgPVxuICBsZXQgcmVjIGF1eCBhY2MgY29kZXMgPVxuICAgIG1hdGNoIGNvZGVzIHdpdGhcbiAgICB8IFtdIC0+IGFjY1xuICAgIHwgW2NvZGVzXSAtPlxuICAgICAgbGV0IG5leHQgPSBpZiBmaW5hbCB0aGVuIE5vbmUgZWxzZSBTb21lIFtdIGluXG4gICAgICBhY2NAKGZpdF9jb2RlX2F0X3BvcyB+bmV4dCBmaWxsZXJzIChMaXN0Lmxlbmd0aCBhY2MpIGNvZGVzKVxuICAgIHwgYzE6OmMyOjpjb2RlcyAtPlxuICAgICAgbGV0IG5jID0gZml0X2NvZGVfYXRfcG9zIH5uZXh0OihTb21lIGMyKSBmaWxsZXJzIChMaXN0Lmxlbmd0aCBhY2MpIGMxIGluXG4gICAgICBhdXggKGFjY0BuYykgKGMyOjpjb2RlcylcbiAgaW5cbiAgYXV4IHJlcyBjb2Rlc1xuXG5sZXQgbW9kdWxvIHggeSA9XG4gIGxldCByZXN1bHQgPSB4IG1vZCB5IGluXG4gIGlmIHJlc3VsdCA+PSAwIHRoZW4gcmVzdWx0XG4gIGVsc2UgcmVzdWx0ICsgeVxuXG5sZXQgc3BsaXRfcmF3X2ludG9fYm94ZXMgPyhmaWxsX2xhc3Q9ZmFsc2UpIHJhdyA9XG4gIGxldCByZWMgc3BsaXQgZmluaXNoZWQgY3VycmVudCBjb2RlcyBpID1cbiAgICBtYXRjaCBjb2RlcyB3aXRoXG4gICAgfCBbXSAtPlxuICAgICAgaWYgaSA8PiAwXG4gICAgICB0aGVuIGJlZ2luXG4gICAgICAgIGxldCBjdXJyZW50ID1cbiAgICAgICAgICBsZXQgbiA9IExpc3QubGVuZ3RoIGN1cnJlbnQgaW5cbiAgICAgICAgICBpZiBmaWxsX2xhc3QgJiYgbiA9IGkgKCogSWYgY3VycmVudCBib3ggZG9lcyBub3QgZW5kIGJ5IDB4RkYgKilcbiAgICAgICAgICB0aGVuIChMaXN0LmluaXQgKG5hbWVfc2l6ZS1uKSAoZnVuIF8gLT4gTmFtZS5zcGFjZSkpQGN1cnJlbnRcbiAgICAgICAgICBlbHNlIGN1cnJlbnRcbiAgICAgICAgaW5cbiAgICAgICAgY3VycmVudDo6ZmluaXNoZWRcbiAgICAgIGVuZCBlbHNlIGZpbmlzaGVkXG4gICAgfCBjOjpjb2RlcyB3aGVuIGkgPSBuYW1lX3NpemUgLT5cbiAgICAgIGlmIGMgPD4gZW9mXG4gICAgICB0aGVuIHJhaXNlIChCb3hGaXR0aW5nRXJyb3JcbiAgICAgIFwiUmVzdWx0IGlzIGluY29uc2lzdGVudC4gUGxlYXNlIGNoZWNrIHRoZSBmaWxsZXJzLlwiKSA7XG4gICAgICBzcGxpdCAoY3VycmVudDo6ZmluaXNoZWQpIFtdIGNvZGVzIDBcbiAgICB8IGM6OmNvZGVzIHdoZW4gYyA9IGVvZiAtPlxuICAgICAgc3BsaXQgZmluaXNoZWQgY3VycmVudCBjb2RlcyAoaSsxKVxuICAgIHwgYzo6Y29kZXMgLT5cbiAgICAgIGlmIExpc3QubGVuZ3RoIGN1cnJlbnQgPD4gaVxuICAgICAgdGhlbiByYWlzZSAoQm94Rml0dGluZ0Vycm9yXG4gICAgICBcIlJlc3VsdCBpcyBpbmNvbnNpc3RlbnQuIFBsZWFzZSBjaGVjayB0aGUgZmlsbGVycy5cIikgO1xuICAgICAgc3BsaXQgZmluaXNoZWQgKGM6OmN1cnJlbnQpIGNvZGVzIChpKzEpXG4gIGluXG4gIHNwbGl0IFtdIFtdIHJhdyAwIHw+XG4gIExpc3QubWFwIExpc3QucmV2IHw+XG4gIExpc3QucmV2XG5cbmxldCBmaXRfY29kZXNfaW50b19ib3hlcyA/KGZpbGxfbGFzdD10cnVlKSA/KGZpbGxlcnM9ZGVmYXVsdF9maWxsZXJzKSA/KHN0YXJ0PTApID8oZXhpdD1Ob25lKSBjb2RlcyA9XG4gICgqIE1haW4gY29kZSAqKVxuICBsZXQgcGFkZGluZyA9IHBhZF9uYiBmaWxsZXJzIDAgc3RhcnQgaW5cbiAgbGV0IHJlcyA9XG4gICAgYWRkX2NvZGVzX2FmdGVyIH5maW5hbDooZXhpdCA9IE5vbmUpIGZpbGxlcnMgcGFkZGluZyBjb2RlcyBpblxuICAoKiBBZGQgZXhpdCBjb2RlICopXG4gIGxldCByZXMgPVxuICAgIG1hdGNoIGV4aXQgd2l0aFxuICAgIHwgTm9uZSAtPiByZXNcbiAgICB8IFNvbWUgZXhpdCAtPlxuICAgICAgbGV0IGkgPSBMaXN0Lmxlbmd0aCByZXMgaW5cbiAgICAgIGxldCAoaixlY29kZSkgPSBFeGl0LmdldF9wcmVmZXJyZWQgZXhpdCBpIGluXG4gICAgICBsZXQgcGFkZGluZyA9IHBhZF9uYiBmaWxsZXJzIGkgKGotaSkgaW5cbiAgICAgIGxldCByZXMgPSByZXNAcGFkZGluZyBpblxuICAgICAgYWRkX2NvZGVzX2FmdGVyIH5maW5hbDp0cnVlIGZpbGxlcnMgcmVzIGVjb2RlXG4gIGluXG4gICgqIFNwbGl0IGJ5IGJveCAqKVxuICBsZXQgcmVzID0gc3BsaXRfcmF3X2ludG9fYm94ZXMgfmZpbGxfbGFzdCByZXMgaW5cbiAgKCogSWYgYSBib3ggaXMgZnVsbCBvZiBzcGFjZXMuLi4gKilcbiAgcmVzIHw+IExpc3QubWFwaSAoZnVuIGkgbHN0IC0+XG4gICAgaWYgTmFtZS5pc19mdWxsX29mX3NwYWNlcyBsc3RcbiAgICB0aGVuXG4gICAgICBsZXQgbSA9IExpc3QubGVuZ3RoIG5vcF9jb2RlMiBpblxuICAgICAgbGV0IHBvcyA9IG1vZHVsbyAoLWkqKG5hbWVfc2l6ZSsxKSkgbSBpblxuICAgICAgbGV0IHByZWZpeCA9IExpc3QuaW5pdCBwb3MgKGZ1biBfIC0+IE5hbWUuc3BhY2UpIGluXG4gICAgICBsZXQgc3VmZml4X2xlbiA9IChMaXN0Lmxlbmd0aCBsc3QpLXBvcy1tIGluXG4gICAgICBpZiBzdWZmaXhfbGVuIDwgMCB0aGVuIGxzdFxuICAgICAgZWxzZVxuICAgICAgICBsZXQgc3VmZml4ID0gTGlzdC5pbml0IHN1ZmZpeF9sZW4gKGZ1biBfIC0+IE5hbWUuc3BhY2UpIGluXG4gICAgICAgIExpc3QuY29uY2F0IFtwcmVmaXggOyBub3BfY29kZTIgOyBzdWZmaXhdXG4gICAgZWxzZSBsc3RcbiAgKVxuXG5sZXQgcHBfYm94ZXNfbmFtZXMgZm10IGxzdCA9XG4gIGxldCBwcF9ib3ggaSBjb2RlcyA9XG4gICAgbGV0IGNoYXJzID0gTmFtZS5jb2Rlc190b19jaGFycyBjb2RlcyBpblxuICAgIEZvcm1hdC5mcHJpbnRmIGZtdCBcIkJveCAlMmk6ICVhXFx0WyVhXUAuXCIgKGkrMSlcbiAgICAgIE5hbWUucHBfY2hhcnMgY2hhcnMgTmFtZS5wcF9jaGFyc19yYXcgY2hhcnNcbiAgaW5cbiAgTGlzdC5pdGVyaSBwcF9ib3ggbHN0XG5cbmxldCBwcF9ib3hfcmF3IGZtdCBsc3QgPVxuICBsZXQgcGFkID1cbiAgICBMaXN0LmluaXQgKG5hbWVfc2l6ZSsxLShMaXN0Lmxlbmd0aCBsc3QpKSAoZnVuIF8gLT4gZW9mKSBpblxuICBsc3RAcGFkIHw+IExpc3QuaXRlciAoRm9ybWF0LmZwcmludGYgZm10IFwiJTAyWCBAP1wiKVxuIiwiXG5sZXQgZW51bWVyYXRlX2ZpbGVzIGRpcm5hbWUgZXh0ID1cbiAgU3lzLnJlYWRkaXIgZGlybmFtZVxuICB8PiBBcnJheS50b19saXN0XG4gIHw+IExpc3QuZmlsdGVyIChmdW4geCAtPiBGaWxlbmFtZS5leHRlbnNpb24geCA9IGV4dClcblxubGV0IHVpbnQzMl9vZl9zdHIgc3RyID1cbiAgbGV0IHN0ciA9IFN0cmluZy5sb3dlcmNhc2VfYXNjaWkgc3RyIGluXG4gICgqIElzc3VlIHdpdGgganNfb2Zfb2NhbWwuLi4gKilcbiAgKCpcbiAgaWYgU3RyLnN0cmluZ19tYXRjaCAoU3RyLnJlZ2V4cCBcIlswLTldKyRcIikgc3RyIDBcbiAgdGhlbiBJbnQzMi5vZl9zdHJpbmcgKFwiMHVcIl5zdHIpXG4gIGVsc2UgSW50MzIub2Zfc3RyaW5nIHN0clxuICAqKVxuICBsZXQgaTY0ID0gSW50NjQub2Zfc3RyaW5nIHN0ciBpblxuICBpZiBJbnQ2NC5sb2dhbmQgMHhGRkZGRkZGRjAwMDAwMDAwTCBpNjQgfD4gSW50NjQuZXF1YWwgSW50NjQuemVyb1xuICB0aGVuIEludDY0LnRvX2ludDMyIGk2NFxuICBlbHNlIHJhaXNlIChGYWlsdXJlIFwiTm90IGEgdmFsaWQgaW50MzIuXCIpXG5cbmxldCB1aW50MzJfdG9faW50IHYgPVxuICBtYXRjaCBJbnQzMi51bnNpZ25lZF90b19pbnQgdiB3aXRoIE5vbmUgLT4gYXNzZXJ0IGZhbHNlIHwgU29tZSBpIC0+IGlcblxubGV0IGludDY0X29mX3VpbnQzMiB4ID1cbiAgSW50NjQub2ZfaW50MzIgeCB8PiBJbnQ2NC5sb2dhbmQgMHhGRkZGRkZGRkxcblxubGV0IGR1bW15X2ZtdCA9XG4gIEZvcm1hdC5tYWtlX2Zvcm1hdHRlciAoZnVuIF8gXyBfIC0+ICgpKSAoZnVuIF8gLT4gKCkpXG5cbmxldCBjb25jYXRfc3RyaW5ncyBsc3QgPVxuICBsZXQgcHAgZm10IGxzdCA9XG4gICAgbHN0IHw+IExpc3QuaXRlciAoZnVuIHN0ciAtPiBGb3JtYXQuZnByaW50ZiBmbXQgXCIlc1wiIHN0cilcbiAgaW5cbiAgRm9ybWF0LmFzcHJpbnRmIFwiJWFcIiBwcCBsc3QiLCJvcGVuIEludDMyXG5cbnR5cGUgcG9rZW1vbiA9IHsgcGlkOmludDMyIDsgb3RpZDppbnQzMiB9XG5cbmxldCBpbnQzMl9mcm9tX2xvd19oaWdoIGwgaCA9XG4gIGxvZ29yIGwgKHNoaWZ0X2xlZnQgaCAxNilcblxubGV0IG1hc2sxNiA9IDB4RkZGRiB8PiBvZl9pbnRcbmxldCBpbnQzMl90b19sb3dfaGlnaCBpID1cbiAgbGV0IGwgPSBsb2dhbmQgbWFzazE2IGkgaW5cbiAgbGV0IGggPSBzaGlmdF9yaWdodF9sb2dpY2FsIGkgMTYgaW5cbiAgKGwsIGgpXG5cbmxldCBkYXRhX29mZnNldCA9IDMyXG5sZXQgc3Vic3RydWN0dXJlX3NpemUgPSAxMlxubGV0IGRhdGFfc2l6ZSA9IHN1YnN0cnVjdHVyZV9zaXplICogNFxubGV0IHBpZF9vZmZzZXQgPSAwXG5sZXQgb3RpZF9vZmZzZXQgPSA0XG5sZXQgY2hlY2tzdW1fb2Zmc2V0ID0gMjhcblxubGV0IGRlY3J5cHRpb25fa2V5IHsgcGlkIDsgb3RpZCA7IF8gfSA9IGxvZ3hvciBwaWQgb3RpZFxuXG5sZXQgc3Vic3RydWN0dXJlc19vcmRlciA9IFt8XG4gIFwiR0FFTVwiIDsgXCJHQU1FXCIgOyBcIkdFQU1cIiA7IFwiR0VNQVwiIDsgXCJHTUFFXCIgOyBcIkdNRUFcIiA7XG4gIFwiQUdFTVwiIDsgXCJBR01FXCIgOyBcIkFFR01cIiA7IFwiQUVNR1wiIDsgXCJBTUdFXCIgOyBcIkFNRUdcIiA7XG4gIFwiRUdBTVwiIDsgXCJFR01BXCIgOyBcIkVBR01cIiA7IFwiRUFNR1wiIDsgXCJFTUdBXCIgOyBcIkVNQUdcIiA7XG4gIFwiTUdBRVwiIDsgXCJNR0VBXCIgOyBcIk1BR0VcIiA7IFwiTUFFR1wiIDsgXCJNRUdBXCIgOyBcIk1FQUdcIiA7XG58XVxuXG5sZXQgcGttbl9mcm9tX2J5dGVzIGJ1ZiA9XG4gIGxldCBwaWQgPSBCeXRlcy5nZXRfaW50MzJfbGUgYnVmIHBpZF9vZmZzZXQgaW5cbiAgbGV0IG90aWQgPSBCeXRlcy5nZXRfaW50MzJfbGUgYnVmIG90aWRfb2Zmc2V0IGluXG4gIHsgcGlkIDsgb3RpZCB9XG5cbmxldCBzdWJzdHJ1Y3R1cmVfcG9zaXRpb24geyBwaWQgOyBfIH0gc3MgPVxuICBsZXQgaSA9IHVuc2lnbmVkX3JlbSBwaWQgKG9mX2ludCAyNCkgfD4gVXRpbHMudWludDMyX3RvX2ludCBpblxuICBsZXQgb3JkZXIgPSBzdWJzdHJ1Y3R1cmVzX29yZGVyLihpKSBpblxuICBsZXQgcmVjIGF1eCBpID1cbiAgICBpZiBvcmRlci5baV0gPSBzcyB0aGVuIGkgZWxzZSBhdXggKGkrMSlcbiAgaW5cbiAgYXV4IDBcblxubGV0IHN1YnN0cnVjdHVyZV9vZmZzZXQgcGttbiBzcyA9XG4gIGxldCBwID0gc3Vic3RydWN0dXJlX3Bvc2l0aW9uIHBrbW4gc3MgaW5cbiAgZGF0YV9vZmZzZXQgKyBzdWJzdHJ1Y3R1cmVfc2l6ZSpwXG5cbigqIExvY2FsIG9wZXJhdGlvbnMgKilcblxubGV0IGRlY3J5cHRfYWxpZ25lZF9pbnQzMiBwa21uIGkgPVxuICBsZXQga2V5ID0gZGVjcnlwdGlvbl9rZXkgcGttbiBpblxuICBsb2d4b3IgaSBrZXlcblxubGV0IGVuY3J5cHRfYWxpZ25lZF9pbnQzMiA9IGRlY3J5cHRfYWxpZ25lZF9pbnQzMlxuXG5sZXQgY2hlY2tzdW1fZGlmZl9mb3JfYWxpZ25lZF9pbnQzMiBvIG4gPVxuICBsZXQgKGxvLCBobykgPSBpbnQzMl90b19sb3dfaGlnaCBvIGluXG4gIGxldCAobG4sIGhuKSA9IGludDMyX3RvX2xvd19oaWdoIG4gaW5cbiAgbGV0IGRpZmYgPSBhZGQgKHN1YiBsbiBsbykgKHN1YiBobiBobykgaW5cbiAgbG9nYW5kIGRpZmYgbWFzazE2XG5cbigqIEdsb2JhbCBvcGVyYXRpb25zICopXG5cbmxldCBlbmNfZGVjIHBrbW4gYnVmIHN0YXJ0IGxlbiA9XG4gIGxldCByZWMgZW5jX2RlY19mcm9tIG9mZnNldCA9IFxuICAgIGlmIG9mZnNldCA+PSBzdGFydCArIGxlbiB0aGVuICgpXG4gICAgZWxzZSAoXG4gICAgICBsZXQgaSA9IEJ5dGVzLmdldF9pbnQzMl9sZSBidWYgb2Zmc2V0IGluXG4gICAgICBsZXQgaSA9IGVuY3J5cHRfYWxpZ25lZF9pbnQzMiBwa21uIGkgaW5cbiAgICAgIEJ5dGVzLnNldF9pbnQzMl9sZSBidWYgb2Zmc2V0IGkgO1xuICAgICAgZW5jX2RlY19mcm9tIChvZmZzZXQgKyA0KVxuICAgIClcbiAgaW5cbiAgZW5jX2RlY19mcm9tIHN0YXJ0XG5cbmxldCBleHRyYWN0X2RhdGEgYnVmID1cbiAgbGV0IHBrbW4gPSBwa21uX2Zyb21fYnl0ZXMgYnVmIGluXG4gIGxldCByZXMgPSBCeXRlcy5zdWIgYnVmIGRhdGFfb2Zmc2V0IGRhdGFfc2l6ZSBpblxuICBlbmNfZGVjIHBrbW4gcmVzIDAgZGF0YV9zaXplIDtcbiAgcmVzXG5cbmxldCBjb21wdXRlX2NoZWNrc3VtIGJ1ZiBzdGFydCBsZW4gPVxuICBsZXQgcmVjIGF1eCBhY2MgaSA9XG4gICAgaWYgaSA+PSBzdGFydCtsZW5cbiAgICB0aGVuIGFjY1xuICAgIGVsc2VcbiAgICAgIGxldCBuYiA9IEJ5dGVzLmdldF91aW50MTZfbGUgYnVmIGkgfD4gSW50MzIub2ZfaW50IGluXG4gICAgICBhdXggKEludDMyLmFkZCBhY2MgbmIpIChpKzIpXG4gIGluXG4gIGxldCBzdW0gPSBhdXggSW50MzIuemVybyBzdGFydCBpblxuICBsZXQgbG93ID0gSW50MzIubG9nYW5kIHN1bSBtYXNrMTYgaW5cbiAgbG93IHw+IFV0aWxzLnVpbnQzMl90b19pbnRcblxubGV0IHVwZGF0ZV93aXRoX2RhdGEgYnVmIGRhdGEgPVxuICBsZXQgcGttbiA9IHBrbW5fZnJvbV9ieXRlcyBidWYgaW5cbiAgbGV0IGNoZWNrc3VtID0gY29tcHV0ZV9jaGVja3N1bSBkYXRhIDAgZGF0YV9zaXplIGluXG4gIEJ5dGVzLmJsaXQgZGF0YSAwIGJ1ZiBkYXRhX29mZnNldCBkYXRhX3NpemUgO1xuICBlbmNfZGVjIHBrbW4gYnVmIGRhdGFfb2Zmc2V0IGRhdGFfc2l6ZSA7XG4gIEJ5dGVzLnNldF91aW50MTZfbGUgYnVmIGNoZWNrc3VtX29mZnNldCBjaGVja3N1bVxuXG4oKiBTcGVjaWVzICopXG5cbmxldCBzcGVjaWVzX29mZnNldCBwa21uID1cbiAgKHN1YnN0cnVjdHVyZV9vZmZzZXQgcGttbiAnRycpXG5cbmxldCBzcGVjaWVzX29mZnNldF9yZWxhdGl2ZV90b19kYXRhIHBrbW4gPVxuICAoc3Vic3RydWN0dXJlX29mZnNldCBwa21uICdHJykgLSBkYXRhX29mZnNldFxuXG4oKiBJVnMgKilcblxubGV0IGl2ZWFfb2Zmc2V0IHBrbW4gPVxuICAoc3Vic3RydWN0dXJlX29mZnNldCBwa21uICdNJykgKyA0XG5cbmxldCBtYXNrNSA9IDBiMTExMTEgfD4gb2ZfaW50XG5cbmxldCBpdmVhX2RhdGFfdG9faXZzIGRhdGEgPVxuICBsZXQgaHAgPSBsb2dhbmQgbWFzazUgZGF0YSBpblxuICBsZXQgZGF0YSA9IHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgZGF0YSA1IGluXG4gIGxldCBhdGsgPSBsb2dhbmQgbWFzazUgZGF0YSBpblxuICBsZXQgZGF0YSA9IHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgZGF0YSA1IGluXG4gIGxldCBkZWYgPSBsb2dhbmQgbWFzazUgZGF0YSBpblxuICBsZXQgZGF0YSA9IHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgZGF0YSA1IGluXG4gIGxldCBzcGVlZCA9IGxvZ2FuZCBtYXNrNSBkYXRhIGluXG4gIGxldCBkYXRhID0gc2hpZnRfcmlnaHRfbG9naWNhbCBkYXRhIDUgaW5cbiAgbGV0IHNwX2F0ayA9IGxvZ2FuZCBtYXNrNSBkYXRhIGluXG4gIGxldCBkYXRhID0gc2hpZnRfcmlnaHRfbG9naWNhbCBkYXRhIDUgaW5cbiAgbGV0IHNwX2RlZiA9IGxvZ2FuZCBtYXNrNSBkYXRhIGluXG4gIGxldCBkYXRhID0gc2hpZnRfcmlnaHRfbG9naWNhbCBkYXRhIDUgaW5cbiAgKGhwLGF0ayxkZWYsc3BlZWQsc3BfYXRrLHNwX2RlZixkYXRhKVxuXG5sZXQgaXZzX3RvX2l2ZWFfZGF0YSAoaHAsYXRrLGRlZixzcGVlZCxzcF9hdGssc3BfZGVmLGRhdGEpID1cbiAgbGV0IGRhdGEgPSBzaGlmdF9sZWZ0IGRhdGEgNSBpblxuICBsZXQgZGF0YSA9IGxvZ29yIGRhdGEgc3BfZGVmIGluXG4gIGxldCBkYXRhID0gc2hpZnRfbGVmdCBkYXRhIDUgaW5cbiAgbGV0IGRhdGEgPSBsb2dvciBkYXRhIHNwX2F0ayBpblxuICBsZXQgZGF0YSA9IHNoaWZ0X2xlZnQgZGF0YSA1IGluXG4gIGxldCBkYXRhID0gbG9nb3IgZGF0YSBzcGVlZCBpblxuICBsZXQgZGF0YSA9IHNoaWZ0X2xlZnQgZGF0YSA1IGluXG4gIGxldCBkYXRhID0gbG9nb3IgZGF0YSBkZWYgaW5cbiAgbGV0IGRhdGEgPSBzaGlmdF9sZWZ0IGRhdGEgNSBpblxuICBsZXQgZGF0YSA9IGxvZ29yIGRhdGEgYXRrIGluXG4gIGxldCBkYXRhID0gc2hpZnRfbGVmdCBkYXRhIDUgaW5cbiAgbGV0IGRhdGEgPSBsb2dvciBkYXRhIGhwIGluXG4gIGRhdGFcbiIsIlxudHlwZSBsYW5ndWFnZXMgPSBFTkcgfCBGUkEgfCBJVEEgfCBTUEEgfCBHRVIgfCBKQVBcbmxldCBsYW5nID0gcmVmIEVOR1xuXG50eXBlIHR3ZWFrZXJfbW9kZXMgPSBTdHJpY3QgfCBGbGV4aWJsZVxubGV0IHR3ZWFrZXJfbW9kZSA9IHJlZiBGbGV4aWJsZVxuKCogVE9ETzogVGFrZSB0aGlzIHNldHRpbmcgaW50byBhY2NvdW50OlxuXG4gIGxldCBzdHJpY3QgPVxuICAgIG1hdGNoICFTZXR0aW5ncy50d2Vha2VyX21vZGUgd2l0aFxuICAgIHwgU2V0dGluZ3MuRmxleGlibGUgLT4gZmFsc2UgfCBTZXR0aW5ncy5TdHJpY3QgLT4gdHJ1ZVxuICBpblxuICAuLi5cbiAgXG4gIFdoZW4gc3RyaWN0LCB0aGUgUyBmbGFnIG11c3QgYmUgc2V0IHRvIGZhbHNlIGV4Y2VwdCBmb3IgdGhlIGxhc3QgY29tbWFuZCBnZW5lcmF0ZWRcbiAgZm9yIHdoaWNoIGl0IHNob3VsZCBtYXRjaCB0aGUgUyBmbGFnIG9mIHRoZSBpbml0YWwgY29tbWFuZC5cbiAgTW9yZW92ZXIsIHRoZSBBREQgYW5kIFNVQiBjb21tYW5kcyBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkIG9mIEFEQyBhbmQgU0JDLlxuKilcblxubGV0IGNvbmZpZ3VyZSBsYW5ndWFnZSA9XG4gIHR3ZWFrZXJfbW9kZSA6PSBGbGV4aWJsZSA7XG4gIG1hdGNoIGxhbmd1YWdlIHdpdGhcbiAgfCBcImVuZ1wiIC0+IGxhbmcgOj0gRU5HXG4gIHwgXCJzcGFcIiAtPiBsYW5nIDo9IFNQQVxuICB8IFwiZnJhXCIgLT4gbGFuZyA6PSBGUkFcbiAgfCBcIml0YVwiIC0+IGxhbmcgOj0gSVRBXG4gIHwgXCJnZXJcIiAtPiBsYW5nIDo9IEdFUlxuICB8IFwiamFwXCIgLT4gbGFuZyA6PSBKQVAgOyB0d2Vha2VyX21vZGUgOj0gU3RyaWN0XG4gIHwgXyAtPiBsYW5nIDo9IEVOR1xuIiwib3BlbiBVdGlsc1xyXG5vcGVuIEJpZ19pbnRcclxuXHJcbmxldCBtdWx0X21vZCB4IHkgbSA9XHJcbiAgbW9kX2JpZ19pbnQgKG11bHRfYmlnX2ludCB4IHkpIG1cclxuXHJcbmxldCBwcmVkID0gcHJlZF9iaWdfaW50XHJcbmxldCBzdWNjID0gc3VjY19iaWdfaW50XHJcbmxldCBpbnRfbXVsID0gbXVsdF9pbnRfYmlnX2ludFxyXG5sZXQgbG9nYW5kID0gYW5kX2JpZ19pbnRcclxubGV0IHNoaWZ0X2xlZnQgPSBzaGlmdF9sZWZ0X2JpZ19pbnRcclxubGV0IHNoaWZ0X3JpZ2h0ID0gc2hpZnRfcmlnaHRfYmlnX2ludFxyXG5sZXQgdHdvX2JpZ19pbnQgPSBiaWdfaW50X29mX2ludCAyXHJcbmxldCB0aHJlZV9iaWdfaW50ID0gYmlnX2ludF9vZl9pbnQgM1xyXG5sZXQgZm91cl9iaWdfaW50ID0gYmlnX2ludF9vZl9pbnQgNFxyXG5cclxubGV0IGEgPSAweDQxYzY0ZTZkTCB8PiBiaWdfaW50X29mX2ludDY0XHJcbmxldCBiID0gMHg2MDczTCB8PiBiaWdfaW50X29mX2ludDY0XHJcbmxldCBhX2ludiA9IDB4RUVCOUVCNjVMIHw+IGJpZ19pbnRfb2ZfaW50NjRcclxubGV0IGJfaW52ID0gMHgwQTM1NjFBMUwgfD4gYmlnX2ludF9vZl9pbnQ2NFxyXG5sZXQgbSA9IDB4MV8wMF8wMF8wMF8wMEwgfD4gYmlnX2ludF9vZl9pbnQ2NFxyXG5sZXQgYl8xID0gMHgzNDFiOTQ0YmJMIHw+IGJpZ19pbnRfb2ZfaW50NjQgKCogSW52ZXJzZSBvZiBiIG1vZCAyKiozNCAqKVxyXG5sZXQgY3ljbGVfcGFydF9wcm9kdWN0ID1cclxuICBtdWx0X21vZCAocHJlZCBhKSBiXzEgKGludF9tdWwgNCBtKVxyXG5cclxubGV0IG1hc2szMiA9IGJpZ19pbnRfb2ZfaW50NjQgMHhGRkZGRkZGRkxcclxuXHJcbmxldCBldmVuIG4gPSBsb2dhbmQgbiB1bml0X2JpZ19pbnQgfD4gZXFfYmlnX2ludCB6ZXJvX2JpZ19pbnRcclxubGV0IG9kZCBuID0gZXZlbiBuIHw+IG5vdFxyXG5cclxubGV0IHJlYyBtcG93IGJhc2UgZXhwIG4gPVxyXG4gIGxldCBiYXNlID0gbW9kX2JpZ19pbnQgYmFzZSBuIGluXHJcbiAgaWYgZXFfYmlnX2ludCBleHAgemVyb19iaWdfaW50XHJcbiAgdGhlbiB1bml0X2JpZ19pbnRcclxuICBlbHNlIGlmIGVxX2JpZ19pbnQgZXhwIHVuaXRfYmlnX2ludFxyXG4gIHRoZW4gYmFzZVxyXG4gIGVsc2UgaWYgZXZlbiBleHBcclxuICB0aGVuIG1wb3cgKG11bHRfYmlnX2ludCBiYXNlIGJhc2UpIChkaXZfYmlnX2ludCBleHAgdHdvX2JpZ19pbnQpIG5cclxuICBlbHNlIG11bHRfbW9kIGJhc2UgKG1wb3cgYmFzZSAocHJlZCBleHApIG4pIG5cclxuXHJcbmxldCByZWMgcG93IGJhc2UgZXhwID1cclxuICBpZiBlcV9iaWdfaW50IGV4cCB6ZXJvX2JpZ19pbnRcclxuICB0aGVuIHVuaXRfYmlnX2ludFxyXG4gIGVsc2UgaWYgZXFfYmlnX2ludCBleHAgdW5pdF9iaWdfaW50XHJcbiAgdGhlbiBiYXNlXHJcbiAgZWxzZSBpZiBldmVuIGV4cFxyXG4gIHRoZW4gcG93IChtdWx0X2JpZ19pbnQgYmFzZSBiYXNlKSAoZGl2X2JpZ19pbnQgZXhwIHR3b19iaWdfaW50KVxyXG4gIGVsc2UgbXVsdF9iaWdfaW50IGJhc2UgKHBvdyBiYXNlIChwcmVkIGV4cCkpXHJcblxyXG5sZXQgYWRkX2lmX25lZ2F0aXZlIHggeSA9XHJcbiAgaWYgZ2VfYmlnX2ludCB4IHplcm9fYmlnX2ludCB0aGVuIHggZWxzZSBhZGRfYmlnX2ludCB4IHlcclxubGV0IHN1Yl9pZl9nZXEgeCB5ID1cclxuICBpZiBnZV9iaWdfaW50IHggeSB0aGVuIHN1Yl9iaWdfaW50IHggeSBlbHNlIHhcclxuXHJcbmxldCBzZWVkX2F0IGN5Y2xlID1cclxuICBsZXQgcmVzID0gbXVsdF9iaWdfaW50IChwcmVkIGEpIG0gaW5cclxuICBsZXQgb3AxID0gYWRkX2lmX25lZ2F0aXZlIChtcG93IGEgY3ljbGUgcmVzIHw+IHByZWQpIHJlcyBpblxyXG4gIGxldCBhdXggPSBkaXZfYmlnX2ludCBvcDEgKHByZWQgYSkgaW5cclxuICBtdWx0X21vZCBhdXggYiBtXHJcblxyXG5leGNlcHRpb24gRG9lc05vdEV4aXN0XHJcblxyXG5sZXQgZGlzY3JldGVfbG9nIGJhc2UgcG93ZXIgbiBjaGVja19leGlzdHMgPVxyXG4gIGxldCAoYSxjLG0pID0gKGJhc2UsIHBvd2VyLCBwb3cgdHdvX2JpZ19pbnQgKGJpZ19pbnRfb2ZfaW50IG4pKSBpblxyXG4gIGFzc2VydCAobiA+PSAzKSA7XHJcbiAgYXNzZXJ0IChvZGQgYSAmJiBvZGQgYykgO1xyXG4gIGlmIGNoZWNrX2V4aXN0c1xyXG4gIHRoZW4gYmVnaW5cclxuICAgIGxldCBtb2Rfc3dpdGNoID0gZXFfYmlnX2ludCAobW9kX2JpZ19pbnQgYSBmb3VyX2JpZ19pbnQpIHRocmVlX2JpZ19pbnQgaW5cclxuICAgIGxldCByZWMgYXV4IGsgbTEgPVxyXG4gICAgICBpZiBrID49IDIgdGhlbiBiZWdpblxyXG4gICAgICAgIGxldCB4ID0gaWYgbW9kX3N3aXRjaCB0aGVuIG11bHRfbW9kIGEgYSBtMSBlbHNlIG1vZF9iaWdfaW50IGEgbTEgaW5cclxuICAgICAgICBpZiBlcV9iaWdfaW50IHggdW5pdF9iaWdfaW50IHRoZW4gYmVnaW5cclxuICAgICAgICAgIGxldCB4ID0gbW9kX2JpZ19pbnQgYyBtMSBpblxyXG4gICAgICAgICAgaWYgKChlcV9iaWdfaW50IHggdW5pdF9iaWdfaW50KSB8fCAobW9kX3N3aXRjaCAmJiBlcV9iaWdfaW50IHggYSkpIHw+IG5vdFxyXG4gICAgICAgICAgdGhlbiByYWlzZSBEb2VzTm90RXhpc3RcclxuICAgICAgICBlbmQgZWxzZSBhdXggKGstMSkgKHNoaWZ0X3JpZ2h0IG0xIDEpXHJcbiAgICAgIGVuZFxyXG4gICAgaW5cclxuICAgIGF1eCAobi0xKSAoc2hpZnRfcmlnaHQgbSAxKVxyXG4gIGVuZCA7XHJcbiAgbGV0IGsgPSBuLTIgaW5cclxuICBsZXQgYml0bWFzayA9IHBvdyB0d29fYmlnX2ludCAoay0xIHw+IGJpZ19pbnRfb2ZfaW50KSB8PiBwcmVkIGluXHJcbiAgbGV0IGxzID0gQXJyYXkubWFrZSBrIGMgaW5cclxuICBsZXQgcmVjIGF1eCBpIGwgPVxyXG4gICAgaWYgaSA8IGtcclxuICAgIHRoZW4gYmVnaW5cclxuICAgICAgbGV0IGwgPSBtdWx0X21vZCBsIGwgbSBpblxyXG4gICAgICAgIGxzLihpKSA8LSBsIDsgYXV4IChpKzEpIGxcclxuICAgIGVuZFxyXG4gIGluXHJcbiAgYXV4IDEgYyA7XHJcbiAgbGV0IHJlYyBhdXggaSBiIGJpdCA9XHJcbiAgICBpZiBpID49IDBcclxuICAgIHRoZW4gYmVnaW5cclxuICAgICAgbGV0IGIgPVxyXG4gICAgICAgIGlmIGVxX2JpZ19pbnQgbHMuKGkpIChtcG93IGEgKHNoaWZ0X2xlZnQgYiBpIHw+IGxvZ2FuZCBiaXRtYXNrKSBtKSB8PiBub3RcclxuICAgICAgICB0aGVuIGFkZF9iaWdfaW50IGIgYml0XHJcbiAgICAgICAgZWxzZSBiXHJcbiAgICAgIGluXHJcbiAgICAgIGF1eCAoaS0xKSBiIChzaGlmdF9sZWZ0IGJpdCAxKVxyXG4gICAgZW5kIGVsc2UgYlxyXG4gIGluXHJcbiAgYXV4IChrLTEpIHplcm9fYmlnX2ludCB1bml0X2JpZ19pbnRcclxuXHJcbmxldCBjeWNsZV90byBzZWVkID1cclxuICBsZXQgbW9kdWxvID0gaW50X211bCA0IG0gaW5cclxuICBsZXQgcG93ZXIgPSBzdWJfaWZfZ2VxIChtdWx0X21vZCBzZWVkIGN5Y2xlX3BhcnRfcHJvZHVjdCBtb2R1bG8gfD4gc3VjYykgbW9kdWxvIGluXHJcbiAgZGlzY3JldGVfbG9nIGEgcG93ZXIgKDMyKzIpIGZhbHNlXHJcblxyXG5sZXQgbmV4dF9zZWVkIHNlZWQgPVxyXG4gIG11bHRfYmlnX2ludCBzZWVkIGEgfD4gYWRkX2JpZ19pbnQgYiB8PiBsb2dhbmQgbWFzazMyXHJcblxyXG5sZXQgcHJldl9zZWVkIHNlZWQgPVxyXG4gIG11bHRfYmlnX2ludCBzZWVkIGFfaW52IHw+IGFkZF9iaWdfaW50IGJfaW52IHw+IGxvZ2FuZCBtYXNrMzJcclxuXHJcbmxldCBiaWdfaW50X29mX3VpbnQzMiBpMzIgPVxyXG4gIGludDY0X29mX3VpbnQzMiBpMzJcclxuICB8PiBiaWdfaW50X29mX2ludDY0XHJcblxyXG5sZXQgdWludDMyX29mX2JpZ2ludCBiaSA9XHJcbiAgbGV0IG1heGludDMyID0gSW50MzIubWF4X2ludCB8PiBiaWdfaW50X29mX2ludDMyIGluXHJcbiAgbGV0IG1pbmludDMyID0gSW50MzIubWluX2ludCB8PiBiaWdfaW50X29mX2ludDMyIGluXHJcbiAgbGV0IHRvdGFsID0gc3ViX2JpZ19pbnQgbWF4aW50MzIgbWluaW50MzIgfD4gc3VjY19iaWdfaW50IGluXHJcbiAgbGV0IGJpID0gaWYgZ3RfYmlnX2ludCBiaSBtYXhpbnQzMlxyXG4gICAgdGhlbiBzdWJfYmlnX2ludCBiaSB0b3RhbFxyXG4gICAgZWxzZSBiaVxyXG4gIGluXHJcbiAgaW50MzJfb2ZfYmlnX2ludCBiaVxyXG5cclxuKCogRmlzaGluZyAoZnJvbSBTaGFvKSAqKVxyXG5cclxubGV0IHJuZ19vZiBzZWVkID0gc2hpZnRfcmlnaHQgc2VlZCAxNiB8PiBpbnRfb2ZfYmlnX2ludFxyXG5cclxubGV0IG9sZF9yb2QgPSAwXHJcbmxldCBnb29kX3JvZCA9IDFcclxubGV0IHN1cGVyX3JvZCA9IDJcclxubGV0IGFQcmVzc2VzID0gW3wxOzM7NnxdXHJcbmxldCBtb3JlQVByZXNzZXMgPSBbfDA7MTA7MzB8XVxyXG5sZXQgZmlzaGluZ19hdHRlbXB0IHJvdXRlMTE5IGZlZWJhcyBzdGFydGluZ19zZWVkIHJvZCBpbml0aWFsQWR2YW5jZXMgPVxyXG4gIGxldCBzZWVkID0gcmVmIHN0YXJ0aW5nX3NlZWQgaW5cclxuICBmb3IgXz0xIHRvIGluaXRpYWxBZHZhbmNlcyBkb1xyXG4gICAgc2VlZCA6PSBuZXh0X3NlZWQgIXNlZWRcclxuICBkb25lIDtcclxuICBsZXQgbWluUm91bmRzID0gKChybmdfb2YgIXNlZWQpIG1vZCAoYVByZXNzZXMuKHJvZCkpKSArIDEgaW5cclxuICBzZWVkIDo9IG5leHRfc2VlZCAhc2VlZCA7ICgqIE9uZSBjYWxsIHRvIGRldGVybWluZSBudW1iZXIgb2YgZG90cyBvbiBmaXJzdCBjYXN0ICopXHJcbiAgc2VlZCA6PSBuZXh0X3NlZWQgIXNlZWQgOyAoKiBjYWxsIHRoYXQgZGV0ZXJtaW5lcyBpZiBmaXNoIGlzIG9uIGxpbmUgKilcclxuXHJcbiAgbGV0IGJpdGVSb2xsID0gKHJuZ19vZiAhc2VlZCkgbW9kIDEwMCBpblxyXG4gIGxldCBiaXRlUmVzdWx0ID1cclxuICAgIGlmIGJpdGVSb2xsIGxhbmQgMSA9IDAgdGhlbiAwICgqIEEgZmlzaCB3aWxsIGJlIGdlbmVyYXRlZCByZWdhcmRsZXNzIG9mIGxlYWQgKilcclxuICAgIGVsc2UgaWYgYml0ZVJvbGwgPiAxNCB0aGVuIDEgKCogQSBTdWN0aW9uIEN1cHMgb3IgU3RpY2t5IEhvbGQgbGVhZCBpcyBuZWNlc3NhcnkgdG8gZ2V0IGEgZmlzaCAqKVxyXG4gICAgZWxzZSAyXHJcbiAgaW5cclxuXHJcbiAgZm9yIF89MSB0byBtaW5Sb3VuZHMtMSBkb1xyXG4gICAgc2VlZCA6PSBuZXh0X3NlZWQgIXNlZWQgKCogTW9yZSBjYWxscyB0byBkZXRlcm1pbmUgZG90IG51bWJlcnMgKilcclxuICBkb25lIDtcclxuXHJcbiAgbGV0IGFkdmFuY2VtZW50ID0gcmVmIChpbml0aWFsQWR2YW5jZXMgKyBtaW5Sb3VuZHMpIGluXHJcbiAgaWYgbWluUm91bmRzID0gMSB0aGVuIGJlZ2luXHJcbiAgICBzZWVkIDo9IG5leHRfc2VlZCAhc2VlZCA7ICgqIERlY2lkZSB3aGV0aGVyIG9yIG5vdCB0byBtYWtlIHRoZSBwbGF5ZXIgcmVlbCBhZ2FpbiAqKVxyXG4gICAgYWR2YW5jZW1lbnQgOj0gIWFkdmFuY2VtZW50ICsgMSA7XHJcbiAgICBsZXQgYml0ZVJvbGwgPSAocm5nX29mICFzZWVkKSBtb2QgMTAwIGluXHJcbiAgICBpZiBiaXRlUm9sbCA8IG1vcmVBUHJlc3Nlcy4ocm9kKVxyXG4gICAgdGhlbiAoc2VlZCA6PSBuZXh0X3NlZWQgIXNlZWQgOyAgYWR2YW5jZW1lbnQgOj0gIWFkdmFuY2VtZW50ICsgMSlcclxuICBlbmQgO1xyXG4gIHNlZWQgOj0gbmV4dF9zZWVkICFzZWVkIDtcclxuICBsZXQgZmVlYmFzUmVzdWx0ID0gKHJuZ19vZiAhc2VlZCkgbW9kIDEwMCA8IDUwIGluXHJcbiAgaWYgcm91dGUxMTkgJiYgbm90IGZlZWJhcyB0aGVuIGFkdmFuY2VtZW50IDo9ICFhZHZhbmNlbWVudCArIDEgO1xyXG4gIChiaXRlUmVzdWx0LCBmZWViYXNSZXN1bHQsICFhZHZhbmNlbWVudClcclxuXHJcbmxldCBiZXN0X3NlZWRfZm9yX3JvZCByb3V0ZTExOSBmZWViYXMgdGFyZ2V0X3NlZWQgcm9kID1cclxuICBsZXQgbWF4QWRkaXRpb25hbE9mZnNldHMgPSBbfDA7MTs0fF0gaW5cclxuICBsZXQgc3RhcnQgPSA3IGluXHJcbiAgbGV0IGJlc3RSZXN1bHRzID0gcmVmIE5vbmUgaW5cclxuXHJcbiAgbGV0IHN0YXJ0aW5nX3NlZWQgPSByZWYgKHByZXZfc2VlZCB0YXJnZXRfc2VlZCkgaW5cclxuICBmb3IgXz0xIHRvIHN0YXJ0ICsgMSBkb1xyXG4gICAgc3RhcnRpbmdfc2VlZCA6PSBwcmV2X3NlZWQgIXN0YXJ0aW5nX3NlZWRcclxuICBkb25lIDtcclxuXHJcbiAgbGV0IG9mZnNldDExOSA9XHJcbiAgICBpZiByb3V0ZTExOSAmJiBub3QgZmVlYmFzXHJcbiAgICB0aGVuIChzdGFydGluZ19zZWVkIDo9IHByZXZfc2VlZCAhc3RhcnRpbmdfc2VlZCA7IDEpXHJcbiAgICBlbHNlIDBcclxuICBpblxyXG5cclxuICBmb3IgYWRkaXRpb25hbE9mZnNldD0wIHRvIG1heEFkZGl0aW9uYWxPZmZzZXRzLihyb2QpIGRvXHJcbiAgICBsZXQgKGJpdGVSZXN1bHQsIGZlZWJhc1Jlc3VsdCwgYWR2YW5jZW1lbnQpID1cclxuICAgICAgZmlzaGluZ19hdHRlbXB0IHJvdXRlMTE5IGZlZWJhcyAhc3RhcnRpbmdfc2VlZCByb2Qgc3RhcnQgaW5cclxuICAgIHN0YXJ0aW5nX3NlZWQgOj0gcHJldl9zZWVkICFzdGFydGluZ19zZWVkIDtcclxuICAgIGlmIGJpdGVSZXN1bHQgPCAyICYmIChub3QgZmVlYmFzIHx8IGZlZWJhc1Jlc3VsdClcclxuICAgICAgJiYgc3RhcnQgKyAyICsgYWRkaXRpb25hbE9mZnNldCArIG9mZnNldDExOSA9IGFkdmFuY2VtZW50XHJcbiAgICB0aGVuIGJlZ2luXHJcbiAgICAgIGJlc3RSZXN1bHRzIDo9XHJcbiAgICAgICAgbWF0Y2ggIWJlc3RSZXN1bHRzIHdpdGhcclxuICAgICAgICB8IE5vbmUgLT4gU29tZSAoYml0ZVJlc3VsdCwgYWR2YW5jZW1lbnQsIG5leHRfc2VlZCAhc3RhcnRpbmdfc2VlZClcclxuICAgICAgICB8IFNvbWUgKGJyLCBhZHYsIHMpIHdoZW4gYnIgPSAwICYmIGJpdGVSZXN1bHQgPSAxIC0+IFNvbWUgKGJyLCBhZHYsIHMpXHJcbiAgICAgICAgfCBTb21lIChiciwgYWR2LCBzKSB3aGVuIGJyID0gYml0ZVJlc3VsdCAmJiBhZHYgPCBhZHZhbmNlbWVudCAtPiBTb21lIChiciwgYWR2LCBzKVxyXG4gICAgICAgIHwgXyAtPiBTb21lIChiaXRlUmVzdWx0LCBhZHZhbmNlbWVudCwgbmV4dF9zZWVkICFzdGFydGluZ19zZWVkKVxyXG4gICAgZW5kXHJcbiAgZG9uZSA7XHJcbiAgIWJlc3RSZXN1bHRzXHJcblxyXG4oKiBJbnRlcmZhY2UgKilcclxuXHJcbmxldCBuZXh0X3NlZWQgc2VlZCA9XHJcbiAgbmV4dF9zZWVkIChiaWdfaW50X29mX3VpbnQzMiBzZWVkKSB8PiB1aW50MzJfb2ZfYmlnaW50XHJcblxyXG5sZXQgcHJldl9zZWVkIHNlZWQgPVxyXG4gIHByZXZfc2VlZCAoYmlnX2ludF9vZl91aW50MzIgc2VlZCkgfD4gdWludDMyX29mX2JpZ2ludFxyXG5cclxubGV0IGN5Y2xlX3RvIHNlZWQgPVxyXG4gIGN5Y2xlX3RvIChiaWdfaW50X29mX3VpbnQzMiBzZWVkKSB8PiB1aW50MzJfb2ZfYmlnaW50XHJcblxyXG5sZXQgc2VlZF9hdCBjeWNsZSA9XHJcbiAgc2VlZF9hdCAoYmlnX2ludF9vZl91aW50MzIgY3ljbGUpIHw+IHVpbnQzMl9vZl9iaWdpbnRcclxuXHJcbmxldCBiZXN0X3NlZWRfZm9yX3JvZCByb3V0ZTExOSBmZWViYXMgdGFyZ2V0X3NlZWQgcm9kID1cclxuICBtYXRjaCBiZXN0X3NlZWRfZm9yX3JvZCByb3V0ZTExOSBmZWViYXMgKGJpZ19pbnRfb2ZfdWludDMyIHRhcmdldF9zZWVkKSByb2Qgd2l0aFxyXG4gIHwgTm9uZSAtPiBOb25lXHJcbiAgfCBTb21lIChiLGkscykgLT4gU29tZSAoYj0xLGksdWludDMyX29mX2JpZ2ludCBzKVxyXG4iLCJvcGVuIFNlZWRcblxudHlwZSByZXN1bHQgPSBcbiAgfCBDb250IG9mIChGb3JtYXQuZm9ybWF0dGVyIC0+IHN0cmluZyAtPiByZXN1bHQpXG4gIHwgTm9Db250XG5cbmxldCByZWMgbWFpbiBmbXQgPVxuICBGb3JtYXQuZnByaW50ZiBmbXQgXCJQbGVhc2UgZW50ZXIgeW91ciBzZWVkICh1c2UgMHggcHJlZml4IGlmIGhleGFkZWNpbWFsKTogQD9cIiA7XG4gIENvbnQgbWFpbl8xXG5cbmFuZCBtYWluXzEgZm10IHN0ciA9XG4gIGxldCBzZWVkID0gVXRpbHMudWludDMyX29mX3N0ciBzdHIgaW5cbiAgRm9ybWF0LmZwcmludGYgZm10IFwiRG8geW91IHdhbnQgdG8gb2J0YWluIHRoaXMgc2VlZCB1c2luZyB0aGUgZnJlZXplIFBSTkcgQUNFIGNvZGUgP0AuXCIgO1xuICBGb3JtYXQuZnByaW50ZiBmbXQgXCIxLiBZZXMsIGZvciBtZXRob2QgSDEgKHdpbGQgcG9rZW1vbikgdXNpbmcgc3dlZXQgc2NlbnQuQC5cIiA7XG4gIEZvcm1hdC5mcHJpbnRmIGZtdCBcIjIuIFllcywgZm9yIG1hc3Mgb3V0YnJlYWtzIChtZXRob2QgSDEsIHVzaW5nIHN3ZWV0IHNjZW50KS5ALlwiIDtcbiAgRm9ybWF0LmZwcmludGYgZm10IFwiMy4gWWVzLCBmb3IgbWV0aG9kIEgxICh3aWxkIHBva2Vtb24pIHVzaW5nIGEgcm9kLkAuXCIgO1xuICBGb3JtYXQuZnByaW50ZiBmbXQgXCI0LiBZZXMsIGZvciBtZXRob2QgMSAoc3RhdGlvbm5hcnkgcG9rZW1vbikuQC5cIiA7XG4gIEZvcm1hdC5mcHJpbnRmIGZtdCBcIjUuIE5vLCBidXQgcGxlYXNlIHNob3cgbWUgdGhlIHNlZWRzIGluIHRoZSB2aWNpbml0eS5ALlwiIDtcbiAgRm9ybWF0LmZwcmludGYgZm10IFwiNi4gTm8gKHF1aXQpLkAuXCIgO1xuICBDb250IChtYWluXzIgc2VlZClcblxuYW5kIHNob3dfdmljaW5pdHkgZm10IHByaW50X2N5Y2xlIHNlZWQgc3RhcnQgc3RvcCA9XG4gIGxldCBjeWNsZSA9IGN5Y2xlX3RvIHNlZWQgaW5cbiAgaWYgcHJpbnRfY3ljbGUgdGhlbiBGb3JtYXQuZnByaW50ZiBmbXQgXCJDeWNsZSBmcm9tIHNlZWQgMDogJWx1QC5cIiBjeWNsZSA7XG4gIGxldCBzdGFydF9zZWVkID0gcmVmIChzZWVkX2F0IChJbnQzMi5hZGQgY3ljbGUgKEludDMyLm9mX2ludCBzdGFydCkpKSBpblxuICBmb3IgaSA9IHN0YXJ0IHRvIHN0b3AgZG9cbiAgICBGb3JtYXQuZnByaW50ZiBmbXQgXCIlaTogJWx1ICglI2x4KUAuXCIgaSAoIXN0YXJ0X3NlZWQpICghc3RhcnRfc2VlZCkgO1xuICAgIHN0YXJ0X3NlZWQgOj0gbmV4dF9zZWVkICghc3RhcnRfc2VlZClcbiAgZG9uZVxuXG5hbmQgbWFpbl8yIHNlZWQgZm10IHN0ciA9XG4gIG1hdGNoIHN0ciB3aXRoXG4gIHwgXCIxXCIgLT5cbiAgICBGb3JtYXQuZnByaW50ZiBmbXQgXCJZb3Ugc2hvdWxkIHVzZSB0aGUgc2VlZCAlI2x4ICgyIGN5Y2xlcyBiZWZvcmUgeW91ciB0YXJnZXQpLkAuXCJcbiAgICAgIChwcmV2X3NlZWQgKHByZXZfc2VlZCBzZWVkKSkgO1xuICAgIEZvcm1hdC5mcHJpbnRmIGZtdCBcIllvdSBzaG91bGQgdXNlIHN3ZWV0IHNjZW50IGRpcmVjdGx5IGFmdGVyIHRyaWdnZXJpbmcgdGhlIEFDRSxcIiA7XG4gICAgRm9ybWF0LmZwcmludGYgZm10IFwiIHdpdGhvdXQgY2xvc2luZyB0aGUgcG9rZW1vbiBtZW51LkAuXCIgO1xuICAgIE5vQ29udFxuICB8IFwiMlwiIC0+XG4gICAgRm9ybWF0LmZwcmludGYgZm10IFwiWW91IHNob3VsZCB1c2UgdGhlIHNlZWQgJSNseCAoMSBjeWNsZSBiZWZvcmUgeW91ciB0YXJnZXQpLkAuXCJcbiAgICAgIChwcmV2X3NlZWQgc2VlZCkgO1xuICAgIEZvcm1hdC5mcHJpbnRmIGZtdCBcIllvdSBzaG91bGQgdXNlIHN3ZWV0IHNjZW50IGRpcmVjdGx5IGFmdGVyIHRyaWdnZXJpbmcgdGhlIEFDRSxcIiA7XG4gICAgRm9ybWF0LmZwcmludGYgZm10IFwiIHdpdGhvdXQgY2xvc2luZyB0aGUgcG9rZW1vbiBtZW51LkAuXCIgO1xuICAgIE5vQ29udFxuICB8IFwiM1wiIC0+XG4gICAgRm9ybWF0LmZwcmludGYgZm10IFwiUGxlYXNlIHNlbGVjdCB5b3VyIGNvbmZpZ3VyYXRpb246QC5cIiA7XG4gICAgRm9ybWF0LmZwcmludGYgZm10IFwiMS4gSSB3aWxsIG5vdCBiZSBmaXNoaW5nIG9uIHJvdXRlIDExOS5ALlwiIDtcbiAgICBGb3JtYXQuZnByaW50ZiBmbXQgXCIyLiBJIHdpbGwgYmUgZmlzaGluZyBvbiByb3V0ZSAxMTksIGJ1dCBub3QgZm9yIGEgZmVlYmFzLkAuXCIgO1xuICAgIEZvcm1hdC5mcHJpbnRmIGZtdCBcIjMuIEkgd2lsbCBiZSBmaXNoaW5nIGZvciBmZWViYXMgb24gYSBmZWViYXMgdGlsZS5ALlwiIDtcbiAgICBDb250IChtYWluXzMgc2VlZClcbiAgfCBcIjRcIiAtPlxuICAgIEZvcm1hdC5mcHJpbnRmIGZtdCBcIkZvciBtb3N0IGxlZ2VuZGFyaWVzLCB5b3Ugc2hvdWxkIHVzZSB0aGUgc2VlZCBhdCBjeWNsZSAtMy5ALlwiIDtcbiAgICBGb3JtYXQuZnByaW50ZiBmbXQgXCJQbGVhc2UgcmVmZXIgdG8gdGhlIGluc3RydWN0aW9ucyBvbiB0aGUgZnJlZXplIFBSTkcgQUNFIGNvZGUgZm9yIG90aGVyIHN0YXRpb25uYXJ5IHBva2Vtb25zLkAuXCIgO1xuICAgIEZvcm1hdC5mcHJpbnRmIGZtdCBcIllvdSBzaG91bGQgc3RhcnQgdGhlIGJhdHRsZSBhcyBzb29uIGFzIHlvdSBjYW5cIiA7XG4gICAgRm9ybWF0LmZwcmludGYgZm10IFwiIChqdXN0IGFmdGVyIGhhdmluZyBleGVjdXRlZCB0aGUgQUNFIGFuZCBjbG9zZWQgdGhlIG1lbnUpLkAuXCIgO1xuICAgIHNob3dfdmljaW5pdHkgZm10IGZhbHNlIHNlZWQgKC0xMCkgMCA7XG4gICAgTm9Db250XG4gIHwgXCI1XCIgLT5cbiAgICBGb3JtYXQuZnByaW50ZiBmbXQgXCJQbGVhc2UgZW50ZXIgdGhlIHJhbmdlIChleGFtcGxlOiAtMjUgNSk6QC5cIiA7XG4gICAgQ29udCAobWFpbl92aWNpbml0eSBzZWVkKVxuICB8IF8gLT4gTm9Db250XG5cbmFuZCBtYWluX3ZpY2luaXR5IHNlZWQgZm10IHN0ciA9XG4gIGxldCAoc3RhcnQsIHN0b3ApID0gU2NhbmYuc3NjYW5mIHN0ciBcIiAlaSAlaVwiIChmdW4gaSBqIC0+IChpLCBqKSkgaW5cbiAgc2hvd192aWNpbml0eSBmbXQgdHJ1ZSBzZWVkIHN0YXJ0IHN0b3AgO1xuICBOb0NvbnRcblxuYW5kIG1haW5fMyBzZWVkIGZtdCBzdHIgPVxuICBsZXQgKHJvdXRlMTE5LCBmZWViYXMpID1cbiAgICBtYXRjaCBzdHIgd2l0aFxuICAgIHwgXCIxXCIgLT4gKGZhbHNlLCBmYWxzZSlcbiAgICB8IFwiMlwiIC0+ICh0cnVlLCBmYWxzZSlcbiAgICB8IFwiM1wiIC0+ICh0cnVlLCB0cnVlKVxuICAgIHwgXyAtPiBmYWlsd2l0aCBcIlVua25vd24gYW5zd2VyLlwiXG4gIGluXG4gIGZvciByb2QgPSBvbGRfcm9kIHRvIHN1cGVyX3JvZCBkb1xuICAgIGxldCByb2RuYW1lID1cbiAgICAgIG1hdGNoIHJvZCB3aXRoXG4gICAgICB8IHIgd2hlbiByPW9sZF9yb2QgLT4gXCJPbGQgcm9kXCJcbiAgICAgIHwgciB3aGVuIHI9Z29vZF9yb2QgLT4gXCJHb29kIHJvZFwiXG4gICAgICB8IHIgd2hlbiByPXN1cGVyX3JvZCAtPiBcIlN1cGVyIHJvZFwiXG4gICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG4gICAgaW5cbiAgICBGb3JtYXQuZnByaW50ZiBmbXQgXCIlczpALlwiIHJvZG5hbWUgO1xuICAgIG1hdGNoIGJlc3Rfc2VlZF9mb3Jfcm9kIHJvdXRlMTE5IGZlZWJhcyBzZWVkIHJvZCB3aXRoXG4gICAgfCBOb25lIC0+IEZvcm1hdC5mcHJpbnRmIGZtdCBcIlxcdE5vIG1hdGNoZXMgZm91bmRALlwiXG4gICAgfCBTb21lIChmYWxzZSwgYWR2LCBzZWVkKSAtPlxuICAgICAgRm9ybWF0LmZwcmludGYgZm10IFwiXFx0V2l0aCBsZWFkOiBObyBsZWFkIG5lY2Vzc2FyeUAuXCIgO1xuICAgICAgRm9ybWF0LmZwcmludGYgZm10IFwiXFx0VXNlIHNlZWQgJSNseCB0byBnZW5lcmF0ZSB0YXJnZXQgb24gYWR2YW5jZW1lbnQgJWlALlwiIHNlZWQgYWR2XG4gICAgfCBTb21lICh0cnVlLCBhZHYsIHNlZWQpIC0+XG4gICAgICBGb3JtYXQuZnByaW50ZiBmbXQgXCJcXHRXaXRoIGxlYWQ6IE11c3QgaGF2ZSBTdWN0aW9uIEN1cCBvciBTdGlja3kgSG9sZCBsZWFkQC5cIiA7XG4gICAgICBGb3JtYXQuZnByaW50ZiBmbXQgXCJcXHRVc2Ugc2VlZCAlI2x4IHRvIGdlbmVyYXRlIHRhcmdldCBvbiBhZHZhbmNlbWVudCAlaUAuXCIgc2VlZCBhZHZcbiAgZG9uZSA7XG4gIEZvcm1hdC5mcHJpbnRmIGZtdCBcIllvdSBzaG91bGQgdXNlIHRoZSByb2QgZGlyZWN0bHkgYWZ0ZXIgdHJpZ2dlcmluZyB0aGUgQUNFXCIgO1xuICBGb3JtYXQuZnByaW50ZiBmbXQgXCIgKGxlYXZlIHRoZSBwb2tlbW9uIG1lbnUgYW5kIGVudGVyIHRoZSBiYWcpLkAuXCIgO1xuICBGb3JtYXQuZnByaW50ZiBmbXQgXCJUaGFua3MgdG8gU2hhbyBmb3IgdGhpcyBzY3JpcHQuQC5cIiA7XG4gIE5vQ29udCIsIlxuZXhjZXB0aW9uIEludmFsaWRTYXZlXG5cbmxldCBnYW1lX3NhdmVfQSA9IDB4MDAwMFxubGV0IGdhbWVfc2F2ZV9CID0gMHhFMDAwXG5cbmxldCBzZWN0aW9uX3NpemUgPSAweDEwMDBcbmxldCBuYl9zZWN0aW9ucyA9IDE0XG5sZXQgc2VjdGlvbl9pZF9vZmZzZXQgPSAweEZGNFxubGV0IGNoZWNrc3VtX29mZnNldCA9IDB4RkY2XG5sZXQgc2F2ZV9pbmRleF9vZmZzZXQgPSAweEZGQ1xuXG5sZXQgcGNfYnVmZmVyc19kYXRhX3NpemUgPSAzOTY4XG5sZXQgYm94X25hbWVzX3NlY3Rpb25faWQgPSAxMyAoKiBQQyBidWZmZXIgSSAqKVxubGV0IGJveF9uYW1lc19zZWN0aW9uX2RhdGFfbGVuZ3RoID0gMjAwMFxubGV0IGJveF9uYW1lc19vZmZzZXQgPSAweDgzNDQgLSA4KnBjX2J1ZmZlcnNfZGF0YV9zaXplXG5sZXQgYm94X25hbWVzX2xlbmd0aCA9IDEyNlxuXG5sZXQgdGVhbV9pdGVtc19zZWN0aW9uX2lkID0gMVxubGV0IHRlYW1faXRlbXNfc2VjdGlvbl9kYXRhX2xlbmd0aCA9IDM5NjhcbmxldCB0ZWFtX3NpemVfb2Zmc2V0ID0gMHgyMzRcbmxldCB0ZWFtX2RhdGFfb2Zmc2V0ID0gMHgyMzhcbmxldCBwa21uX2RhdGFfc2l6ZSA9IDEwMFxuXG5sZXQgYWRkcl9vZl9zZWN0aW9uIGluYyBpZCA9XG4gIGxldCByYnVmID0gQnl0ZXMuY3JlYXRlIHNlY3Rpb25fc2l6ZSBpblxuICBsZXQgcmVjIGF1eCBiYXNlIGkgPVxuICAgIGlmIGkgPj0gbmJfc2VjdGlvbnNcbiAgICB0aGVuIHJhaXNlIEludmFsaWRTYXZlXG4gICAgZWxzZVxuICAgICAgbGV0IGFkZHIgPSBiYXNlICsgaSpzZWN0aW9uX3NpemUgaW5cbiAgICAgIHNlZWtfaW4gaW5jIGFkZHIgOyByZWFsbHlfaW5wdXQgaW5jIHJidWYgMCBzZWN0aW9uX3NpemUgO1xuICAgICAgbGV0IGlkJyA9IEJ5dGVzLmdldF91aW50MTZfbGUgcmJ1ZiBzZWN0aW9uX2lkX29mZnNldCBpblxuICAgICAgbGV0IGluZGV4ID0gQnl0ZXMuZ2V0X2ludDMyX2xlIHJidWYgc2F2ZV9pbmRleF9vZmZzZXQgaW5cbiAgICAgIGlmIGlkJyA9IGlkXG4gICAgICB0aGVuIChhZGRyLCBpbmRleClcbiAgICAgIGVsc2UgYXV4IGJhc2UgKGkrMSlcbiAgaW5cbiAgbGV0IChhZGRyYSwgaW5kZXhhKSA9IGF1eCBnYW1lX3NhdmVfQSAwIGluXG4gIGxldCAoYWRkcmIsIGluZGV4YikgPSBhdXggZ2FtZV9zYXZlX0IgMCBpblxuICBpZiBJbnQzMi51bnNpZ25lZF9jb21wYXJlIGluZGV4YSBpbmRleGIgPCAwXG4gIHRoZW4gYWRkcmIgZWxzZSBhZGRyYVxuXG5sZXQgcmVhZF9zZWN0aW9uIGluYyBzZWN0aW9uX2lkID1cbiAgbGV0IGFkZHIgPSBhZGRyX29mX3NlY3Rpb24gaW5jIHNlY3Rpb25faWQgaW5cbiAgbGV0IHJlcyA9IEJ5dGVzLmNyZWF0ZSBzZWN0aW9uX3NpemUgaW5cbiAgc2Vla19pbiBpbmMgYWRkciA7IHJlYWxseV9pbnB1dCBpbmMgcmVzIDAgc2VjdGlvbl9zaXplIDtcbiAgKGFkZHIsIHJlcylcblxubGV0IHdyaXRlX3NlY3Rpb24gb2MgYWRkciBidWYgPVxuICBzZWVrX291dCBvYyBhZGRyIDsgb3V0cHV0X2J5dGVzIG9jIGJ1ZiA7IGZsdXNoIG9jXG5cbmxldCBtYXNrMTYgPSBJbnQzMi5vZl9pbnQgMHhGRkZGXG5cbmxldCBjb21wdXRlX2NoZWNrc3VtIGJ1ZiBzdGFydCBsZW4gPVxuICBsZXQgcmVjIGF1eCBhY2MgaSA9XG4gICAgaWYgaSA+PSBzdGFydCtsZW5cbiAgICB0aGVuIGFjY1xuICAgIGVsc2VcbiAgICAgIGxldCBuYiA9IEJ5dGVzLmdldF9pbnQzMl9sZSBidWYgaSBpblxuICAgICAgYXV4IChJbnQzMi5hZGQgYWNjIG5iKSAoaSs0KVxuICBpblxuICBsZXQgc3VtID0gYXV4IEludDMyLnplcm8gc3RhcnQgaW5cbiAgbGV0IGhpZ2ggPSBJbnQzMi5zaGlmdF9yaWdodF9sb2dpY2FsIHN1bSAxNiBpblxuICBsZXQgbG93ID0gSW50MzIubG9nYW5kIHN1bSBtYXNrMTYgaW5cbiAgbGV0IHJlcyA9IEludDMyLmFkZCBoaWdoIGxvdyBpblxuICBJbnQzMi5sb2dhbmQgcmVzIG1hc2sxNiB8PiBVdGlscy51aW50MzJfdG9faW50XG5cbigqIC0tLS0tIEJPWCBOQU1FUyAtLS0tLSAqKVxuXG5sZXQgZXh0cmFjdF9ib3hfbmFtZXNfZnJvbV9zZWN0aW9uIGJ1ZiA9XG4gIEJ5dGVzLnN1YiBidWYgYm94X25hbWVzX29mZnNldCBib3hfbmFtZXNfbGVuZ3RoXG5cbmxldCB1cGRhdGVfYm94X25hbWVzIGJ1ZiBib3hfbmFtZXMgPVxuICBsZXQgbGVuID0gQnl0ZXMubGVuZ3RoIGJveF9uYW1lcyBpblxuICBCeXRlcy5ibGl0IGJveF9uYW1lcyAwIGJ1ZiBib3hfbmFtZXNfb2Zmc2V0IGxlbiA7XG4gIGxldCBjaGVja3N1bSA9IGNvbXB1dGVfY2hlY2tzdW0gYnVmIDAgYm94X25hbWVzX3NlY3Rpb25fZGF0YV9sZW5ndGggaW5cbiAgQnl0ZXMuc2V0X3VpbnQxNl9sZSBidWYgY2hlY2tzdW1fb2Zmc2V0IGNoZWNrc3VtXG5cbigqIC0tLS0tIFRFQU0gLS0tLS0gKilcblxubGV0IGVtcHR5X3BrbW4gKCkgPVxuICBCeXRlcy5jcmVhdGUgcGttbl9kYXRhX3NpemVcblxubGV0IGV4dHJhY3RfdGVhbV9mcm9tX3NlY3Rpb24gYnVmID1cbiAgKCpsZXQgbmIgPSBCeXRlcy5nZXRfaW50MzJfbGUgYnVmIHRlYW1fc2l6ZV9vZmZzZXQgfD4gVXRpbHMudWludDMyX3RvX2ludCBpblxuICBsZXQgbmIgPSBpZiBuYiA+IDYgdGhlbiA2IGVsc2UgbmIgaW4qKVxuICBsZXQgbmIgPSA2IGluXG4gIGxldCByZWMgZXh0cmFjdF9wa21ucyBhY2MgaSA9XG4gICAgaWYgaSA8IDAgdGhlbiBhY2NcbiAgICBlbHNlIChcbiAgICAgIGxldCBhZGRyID0gdGVhbV9kYXRhX29mZnNldCArIHBrbW5fZGF0YV9zaXplKmkgaW5cbiAgICAgIGxldCBwa21uID0gQnl0ZXMuc3ViIGJ1ZiBhZGRyIHBrbW5fZGF0YV9zaXplIGluXG4gICAgICBleHRyYWN0X3BrbW5zIChwa21uOjphY2MpIChpLTEpXG4gICAgKVxuICBpblxuICBleHRyYWN0X3BrbW5zIFtdIChuYi0xKVxuXG5sZXQgdXBkYXRlX3RlYW0gYnVmIHBrbW5zID1cbiAgbGV0IGxlbiA9IExpc3QubGVuZ3RoIHBrbW5zIHw+IEludDMyLm9mX2ludCBpblxuICBCeXRlcy5zZXRfaW50MzJfbGUgYnVmIHRlYW1fc2l6ZV9vZmZzZXQgbGVuIDtcbiAgbGV0IHVwZGF0ZV9wa21uIGkgcGttbiA9XG4gICAgbGV0IGFkZHIgPSB0ZWFtX2RhdGFfb2Zmc2V0ICsgcGttbl9kYXRhX3NpemUqaSBpblxuICAgIEJ5dGVzLmJsaXQgcGttbiAwIGJ1ZiBhZGRyIHBrbW5fZGF0YV9zaXplXG4gIGluXG4gIExpc3QuaXRlcmkgdXBkYXRlX3BrbW4gcGttbnMgO1xuICBsZXQgY2hlY2tzdW0gPSBjb21wdXRlX2NoZWNrc3VtIGJ1ZiAwIHRlYW1faXRlbXNfc2VjdGlvbl9kYXRhX2xlbmd0aCBpblxuICBCeXRlcy5zZXRfdWludDE2X2xlIGJ1ZiBjaGVja3N1bV9vZmZzZXQgY2hlY2tzdW1cbiIsIlxudHlwZSB1bm9wID0gT0lkIHwgT05lZyB8IE9Ob3QgfCBPQk5vdFxudHlwZSBiaW5vcCA9IE9BZGQgfCBPU3ViIHwgT011bCB8IE9EaXYgfCBPTW9kXG4gICAgICAgICAgIHwgT0FuZCB8IE9Yb3IgfCBPT3IgfCBPTFNoaWZ0IHwgT1JTaGlmdFxuICAgICAgICAgICB8IE9FcSB8IE9OZXEgfCBPQk9yIHwgT0JBbmRcblxudHlwZSBtZXRhX2V4cHIgPVxuICB8IE1Db25zdCBvZiBpbnQzMlxuICB8IE1CaW5hcnkgb2YgYmlub3AgKiBtZXRhX2V4cHIgKiBtZXRhX2V4cHJcbiAgfCBNVW5hcnkgb2YgdW5vcCAqIG1ldGFfZXhwclxuICB8IE1WYXIgb2Ygc3RyaW5nXG4gIHwgTUNvbmQgb2YgbWV0YV9leHByICogbWV0YV9leHByICogbWV0YV9leHByXG5cbnR5cGUgZGVmX3ZhbCA9IEhOb25lIHwgSFN0cmluZyBvZiBzdHJpbmcgfCBISW50IG9mIGludDMyIHwgSEJvb2wgb2YgYm9vbFxudHlwZSBkZWZpbml0aW9uID0gUGFyYW0gb2Ygc3RyaW5nICogZGVmX3ZhbCB8IFZhckRlZiBvZiBzdHJpbmcgKiBib29sICogbWV0YV9leHByXG50eXBlIGhlYWRlcnMgPSBkZWZpbml0aW9uIGxpc3RcblxubW9kdWxlIFN0ck1hcCA9IE1hcC5NYWtlKFN0cmluZylcbnR5cGUgZW52ID0gaW50MzIgU3RyTWFwLnRcbmV4Y2VwdGlvbiBWYXJOb3RGb3VuZCBvZiBzdHJpbmdcblxubGV0IGdldF9wYXJhbSBoZWFkZXJzIG5hbWUgPVxuICBsZXQgcmVjIGF1eCBsc3QgPVxuICAgIG1hdGNoIGxzdCB3aXRoXG4gICAgfCBbXSAtPiBITm9uZVxuICAgIHwgKFZhckRlZiBfKTo6bHN0IC0+IGF1eCBsc3RcbiAgICB8IChQYXJhbSAobix2KSk6Ol8gd2hlbiBTdHJpbmcuZXF1YWwgbiBuYW1lIC0+IHZcbiAgICB8IChQYXJhbSBfKTo6bHN0IC0+IGF1eCBsc3RcbiAgaW5cbiAgYXV4IGhlYWRlcnNcblxubGV0IGV2YWxfdW5hcnkgb3AgaSA9XG4gIG1hdGNoIG9wIHdpdGhcbiAgfCBPSWQgLT4gaVxuICB8IE9OZWcgLT4gSW50MzIubmVnIGlcbiAgfCBPTm90IC0+IEludDMyLmxvZ25vdCBpXG4gIHwgT0JOb3QgLT4gaWYgSW50MzIuZXF1YWwgaSBJbnQzMi56ZXJvIHRoZW4gSW50MzIub25lIGVsc2UgSW50MzIuemVyb1xuXG5sZXQgZXZhbF9iaW5hcnkgb3AgaTEgaTIgPVxuICBtYXRjaCBvcCB3aXRoXG4gIHwgT0FkZCAtPiBJbnQzMi5hZGQgaTEgaTJcbiAgfCBPU3ViIC0+IEludDMyLnN1YiBpMSBpMlxuICB8IE9NdWwgLT4gSW50MzIubXVsIGkxIGkyXG4gIHwgT0RpdiAtPiBJbnQzMi51bnNpZ25lZF9kaXYgaTEgaTJcbiAgfCBPTW9kIC0+IEludDMyLnVuc2lnbmVkX3JlbSBpMSBpMlxuICB8IE9BbmQgLT4gSW50MzIubG9nYW5kIGkxIGkyXG4gIHwgT1hvciAtPiBJbnQzMi5sb2d4b3IgaTEgaTJcbiAgfCBPT3IgLT4gSW50MzIubG9nb3IgaTEgaTJcbiAgfCBPTFNoaWZ0IC0+IEludDMyLnNoaWZ0X2xlZnQgaTEgKFV0aWxzLnVpbnQzMl90b19pbnQgaTIpXG4gIHwgT1JTaGlmdCAtPiBJbnQzMi5zaGlmdF9yaWdodF9sb2dpY2FsIGkxIChVdGlscy51aW50MzJfdG9faW50IGkyKVxuICB8IE9FcSAtPiBpZiBJbnQzMi5lcXVhbCBpMSBpMiB0aGVuIEludDMyLm9uZSBlbHNlIEludDMyLnplcm9cbiAgfCBPTmVxIC0+IGlmIEludDMyLmVxdWFsIGkxIGkyIHRoZW4gSW50MzIuemVybyBlbHNlIEludDMyLm9uZVxuICB8IE9CT3IgLT5cbiAgICBpZiBJbnQzMi5lcXVhbCBpMSBJbnQzMi56ZXJvICYmIEludDMyLmVxdWFsIGkyIEludDMyLnplcm9cbiAgICB0aGVuIEludDMyLnplcm8gZWxzZSBJbnQzMi5vbmVcbiAgfCBPQkFuZCAtPlxuICAgIGlmIEludDMyLmVxdWFsIGkxIEludDMyLnplcm8gfHwgSW50MzIuZXF1YWwgaTIgSW50MzIuemVyb1xuICAgIHRoZW4gSW50MzIuemVybyBlbHNlIEludDMyLm9uZVxuXG5sZXQgZXZhbF9tZXRhX2V4cHIgZW52IGUgPVxuICBsZXQgcmVjIGF1eCBlID1cbiAgICBtYXRjaCBlIHdpdGhcbiAgICB8IE1Db25zdCBpIC0+IGlcbiAgICB8IE1WYXIgc3RyIC0+XG4gICAgICBpZiBTdHJNYXAubWVtIHN0ciBlbnZcbiAgICAgIHRoZW4gU3RyTWFwLmZpbmQgc3RyIGVudlxuICAgICAgZWxzZSByYWlzZSAoVmFyTm90Rm91bmQgc3RyKVxuICAgIHwgTVVuYXJ5IChvcCwgZSkgLT5cbiAgICAgIGxldCBpID0gYXV4IGUgaW5cbiAgICAgIGV2YWxfdW5hcnkgb3AgaVxuICAgIHwgTUJpbmFyeSAob3AsIGUxLCBlMikgLT5cbiAgICAgIGxldCBpMSA9IGF1eCBlMSBhbmQgaTIgPSBhdXggZTIgaW5cbiAgICAgIGV2YWxfYmluYXJ5IG9wIGkxIGkyXG4gICAgfCBNQ29uZCAoZTAsIGUxLCBlMikgLT5cbiAgICAgIGxldCBpMCA9IGF1eCBlMCBpblxuICAgICAgaWYgSW50MzIuZXF1YWwgaTAgSW50MzIuemVybyB0aGVuIGF1eCBlMiBlbHNlIGF1eCBlMVxuICBpblxuICBhdXggZVxuXG5sZXQgZW1wdHlfZW52ID0gU3RyTWFwLmVtcHR5XG5cbmxldCBlbnZfZnJvbV9oZWFkZXJzIGZtdCBoZWFkZXJzID1cbiAgbGV0IHRyZWF0X2RlZiAocHJpbnRlZCwgYWNjKSBkZWYgPVxuICAgIG1hdGNoIGRlZiB3aXRoXG4gICAgfCBQYXJhbSBfIC0+IChwcmludGVkLCBhY2MpXG4gICAgfCBWYXJEZWYgKHN0ciwgcHJpbnQsIGV4cHIpIC0+XG4gICAgICBsZXQgaSA9IGV2YWxfbWV0YV9leHByIGFjYyBleHByIGluXG4gICAgICBpZiBwcmludCB0aGVuIEZvcm1hdC5mcHJpbnRmIGZtdCBcIiVzID0gJWxpICglI2x4KUAuXCIgc3RyIGkgaSA7XG4gICAgICAocHJpbnRlZCB8fCBwcmludCwgU3RyTWFwLmFkZCBzdHIgaSBhY2MpXG4gIGluXG4gIGxldCAocHJpbnRlZCwgcmVzKSA9XG4gICAgTGlzdC5mb2xkX2xlZnQgdHJlYXRfZGVmIChmYWxzZSwgU3RyTWFwLmVtcHR5KSBoZWFkZXJzIGluXG4gIGlmIHByaW50ZWQgdGhlbiBGb3JtYXQuZnByaW50ZiBmbXQgXCJALlwiIDsgcmVzXG5cbmxldCBjb25jYXRfZW52IGVudjEgZW52MiA9XG4gIFN0ck1hcC5mb2xkIChmdW4gayB2IGFjYyAtPiBTdHJNYXAuYWRkIGsgdiBhY2MpIGVudjIgZW52MVxuIiwiXG50eXBlIHJlc3VsdCA9IFxuICB8IENvbnQgb2YgKEZvcm1hdC5mb3JtYXR0ZXIgLT4gc3RyaW5nIC0+IHJlc3VsdClcbiAgfCBOb0NvbnRcblxubGV0IHJlYyBtYWluIGZtdCA9XG4gIEZvcm1hdC5mcHJpbnRmIGZtdCBcIlBsZWFzZSBlbnRlciBsb3ctUElEOiBAP1wiIDtcbiAgQ29udCBtYWluXzFcblxuYW5kIG1haW5fMSBmbXQgc3RyID1cbiAgbGV0IGxwaWQgPSBTY2FuZi5zc2NhbmYgc3RyIFwiICVsaVwiIChmdW4gaSAtPiBpKSBpblxuICBGb3JtYXQuZnByaW50ZiBmbXQgXCJQbGVhc2UgZW50ZXIgaGlnaC1QSUQ6IEA/XCIgO1xuICBDb250IChtYWluXzIgbHBpZClcblxuYW5kIG1haW5fMiBscGlkIGZtdCBzdHIgPVxuICBsZXQgaHBpZCA9IFNjYW5mLnNzY2FuZiBzdHIgXCIgJWxpXCIgKGZ1biBpIC0+IGkpIGluXG4gIGxldCBwaWQgPSBTdHJ1Y3R1cmUuaW50MzJfZnJvbV9sb3dfaGlnaCBscGlkIGhwaWQgaW5cblxuICBGb3JtYXQuZnByaW50ZiBmbXQgXCJQbGVhc2UgZW50ZXIgb3JpZ2luYWwgdHJhaW5lciB2aXNpYmxlIFRJRDogQD9cIiA7XG4gIENvbnQgKG1haW5fMyBwaWQpXG5cbmFuZCBtYWluXzMgcGlkIGZtdCBzdHIgPVxuICBsZXQgdmlkID0gU2NhbmYuc3NjYW5mIHN0ciBcIiAlbGlcIiAoZnVuIGkgLT4gaSkgaW5cbiAgRm9ybWF0LmZwcmludGYgZm10IFwiUGxlYXNlIGVudGVyIG9yaWdpbmFsIHRyYWluZXIgc2VjcmV0IFRJRDogQD9cIiA7XG4gIENvbnQgKG1haW5fNCBwaWQgdmlkKVxuXG5hbmQgbWFpbl80IHBpZCB2aWQgZm10IHN0ciA9XG4gIGxldCBzaWQgPSBTY2FuZi5zc2NhbmYgc3RyIFwiICVsaVwiIChmdW4gaSAtPiBpKSBpblxuICBsZXQgdGlkID0gU3RydWN0dXJlLmludDMyX2Zyb21fbG93X2hpZ2ggdmlkIHNpZCBpblxuXG4gIGxldCBwa21uID0geyBTdHJ1Y3R1cmUucGlkPXBpZCA7IFN0cnVjdHVyZS5vdGlkPXRpZCB9IGluXG4gIGxldCBtaXNjX3BvcyA9IFN0cnVjdHVyZS5zdWJzdHJ1Y3R1cmVfcG9zaXRpb24gcGttbiAnTScgaW5cbiAgbGV0IGl2ZWFfb2Zmc2V0ID0gU3RydWN0dXJlLml2ZWFfb2Zmc2V0IHBrbW4gaW5cbiAgRm9ybWF0LmZwcmludGYgZm10IFwiTWlzYyBzdWJzdHJ1Y3R1cmUgcG9zaXRpb246ICVkQC5cIiAobWlzY19wb3MrMSkgO1xuICBGb3JtYXQuZnByaW50ZiBmbXQgXCJJVkVBIG9mZnNldDogJSN4QC5cIiBpdmVhX29mZnNldCA7XG5cbiAgRm9ybWF0LmZwcmludGYgZm10IFwiUGxlYXNlIGVudGVyIGxvdy1JVkVBOiBAP1wiIDtcbiAgQ29udCAobWFpbl81IHBrbW4pXG5cbmFuZCBtYWluXzUgcGttbiBmbXQgc3RyID1cbiAgbGV0IGxpdmVhID0gU2NhbmYuc3NjYW5mIHN0ciBcIiAlbGlcIiAoZnVuIGkgLT4gaSkgaW5cbiAgRm9ybWF0LmZwcmludGYgZm10IFwiUGxlYXNlIGVudGVyIGhpZ2gtSVZFQTogQD9cIiA7XG4gIENvbnQgKG1haW5fNiBwa21uIGxpdmVhKVxuXG5hbmQgbWFpbl82IHBrbW4gbGl2ZWEgZm10IHN0ciA9XG4gIGxldCBoaXZlYSA9IFNjYW5mLnNzY2FuZiBzdHIgXCIgJWxpXCIgKGZ1biBpIC0+IGkpIGluXG4gIGxldCBpdmVhID0gU3RydWN0dXJlLmludDMyX2Zyb21fbG93X2hpZ2ggbGl2ZWEgaGl2ZWEgaW5cbiAgbGV0IHVpdmVhID0gU3RydWN0dXJlLmRlY3J5cHRfYWxpZ25lZF9pbnQzMiBwa21uIGl2ZWEgaW5cbiAgRm9ybWF0LmZwcmludGYgZm10IFwiVW5lbmNyeXB0ZWQgSVZFQSBkYXRhOiAlI2x4QC5cIiB1aXZlYSA7XG4gIGxldCAoaHAsIGF0aywgZGVmLCBzcGVlZCwgc3BfYXRrLCBzcF9kZWYsIGRhdGEpID0gU3RydWN0dXJlLml2ZWFfZGF0YV90b19pdnMgdWl2ZWEgaW5cbiAgRm9ybWF0LmZwcmludGYgZm10IFwiUG9rZW1vbiBJVnMgKGhwIGF0ayBkZWYgc3BlZWQgc3BfYXRrIHNwX2RlZik6ICVsZCAlbGQgJWxkICVsZCAlbGQgJWxkQC5cIlxuICAgIGhwIGF0ayBkZWYgc3BlZWQgc3BfYXRrIHNwX2RlZiA7XG5cbiAgRm9ybWF0LmZwcmludGYgZm10IFwiTWF4aW5nIElWcy4uLkAuXCIgO1xuICBsZXQgaXYgPSBJbnQzMi5vZl9pbnQgMzEgaW5cbiAgbGV0IHVpdmVhJyA9IFN0cnVjdHVyZS5pdnNfdG9faXZlYV9kYXRhIChpdiwgaXYsIGl2LCBpdiwgaXYsIGl2LCBkYXRhKSBpblxuICBGb3JtYXQuZnByaW50ZiBmbXQgXCJOZXcgdW5lbmNyeXB0ZWQgSVZFQSBkYXRhOiAlI2x4QC5cIiB1aXZlYScgO1xuICBsZXQgaXZlYSA9IFN0cnVjdHVyZS5lbmNyeXB0X2FsaWduZWRfaW50MzIgcGttbiB1aXZlYScgaW5cbiAgbGV0IChsaXZlYSwgaGl2ZWEpID0gU3RydWN0dXJlLmludDMyX3RvX2xvd19oaWdoIGl2ZWEgaW5cbiAgRm9ybWF0LmZwcmludGYgZm10IFwiTmV3IGxvdy1JVkVBOiAlI2x4QC5cIiBsaXZlYSA7XG4gIEZvcm1hdC5mcHJpbnRmIGZtdCBcIk5ldyBoaWdoLUlWRUE6ICUjbHhALlwiIGhpdmVhIDtcbiAgbGV0IGNoZWNrc3VtX2RpZmYgPSBTdHJ1Y3R1cmUuY2hlY2tzdW1fZGlmZl9mb3JfYWxpZ25lZF9pbnQzMiB1aXZlYSB1aXZlYScgaW5cbiAgRm9ybWF0LmZwcmludGYgZm10IFwiQ2hlY2tzdW0gZGlmZjogJSNseEAuXCIgY2hlY2tzdW1fZGlmZiA7XG4gIE5vQ29udFxuIiwiXG50eXBlIHNpZ24gPSBpbnRcblxudHlwZSByZWdpc3RlciA9IGludFxuXG50eXBlIGNvbmRpdGlvbmFsID0gRVEgfCBORSB8IENTIHwgSFMgfCBDQyB8IExPIHwgTUkgfCBQTCBcbiAgICAgICAgICAgICAgICAgfCBWUyB8IFZDIHwgSEkgfCBMUyB8IEdFIHwgTFQgfCBHVCB8IExFIHwgQUxcbnR5cGUgbGRyX3N0cl90eXBlID0gQiB8IFNCIHwgSCB8IFNIIHwgVyB8IFQgfCBCVFxudHlwZSBhZGRyZXNzaW5nX3R5cGUgPSBPZmZzZXQgfCBQcmVJbmRleGVkIHwgUG9zdEluZGV4ZWRcblxudHlwZSBzY2FsZV90eXBlID0gTFNMIG9mIGludCB8IExTUiBvZiBpbnQgfCBBU1Igb2YgaW50IHwgUk9SIG9mIGludCB8IFJSWFxudHlwZSBvcGVyYW5kID0gSW1tZWRpYXRlIG9mIGludDMyIHwgUmVnaXN0ZXIgb2YgcmVnaXN0ZXIgfCBTY2FsZWRSZWdpc3RlciBvZiByZWdpc3RlciAqIHNjYWxlX3R5cGVcbnR5cGUgcmVnaXN0ZXJfb2Zmc2V0ID0gT0ltbWVkaWF0ZSBvZiByZWdpc3RlciAqIHNpZ24gKiBpbnQzMiB8IE9SZWdpc3RlciBvZiByZWdpc3RlciAqIHNpZ24gKiByZWdpc3RlciB8IE9TY2FsZWRSZWdpc3RlciBvZiByZWdpc3RlciAqIHNpZ24gKiByZWdpc3RlciAqIHNjYWxlX3R5cGVcblxudHlwZSBhcm0gPVxuICB8IEN1c3RvbSBvZiBpbnQzMlxuXG4gIHwgTERSIG9mIHsgdHlwOiBsZHJfc3RyX3R5cGUgOyBjb25kOiBjb25kaXRpb25hbCA7IHJkOiByZWdpc3RlciA7IHJvOiByZWdpc3Rlcl9vZmZzZXQgKiBhZGRyZXNzaW5nX3R5cGUgfVxuICB8IFNUUiBvZiB7IHR5cDogbGRyX3N0cl90eXBlIDsgY29uZDogY29uZGl0aW9uYWwgOyByZDogcmVnaXN0ZXIgOyBybzogcmVnaXN0ZXJfb2Zmc2V0ICogYWRkcmVzc2luZ190eXBlIH1cblxuICB8IE1PViBvZiB7IHM6Ym9vbCA7IGNvbmQ6IGNvbmRpdGlvbmFsIDsgcmQ6IHJlZ2lzdGVyIDsgcnM6IG9wZXJhbmQgfVxuICB8IE1WTiBvZiB7IHM6Ym9vbCA7IGNvbmQ6IGNvbmRpdGlvbmFsIDsgcmQ6IHJlZ2lzdGVyIDsgcnM6IG9wZXJhbmQgfVxuXG4gIHwgQURDIG9mIHsgczpib29sIDsgY29uZDogY29uZGl0aW9uYWwgOyByZDogcmVnaXN0ZXIgOyBybjogcmVnaXN0ZXIgOyBvcDI6IG9wZXJhbmQgfVxuICB8IFNCQyBvZiB7IHM6Ym9vbCA7IGNvbmQ6IGNvbmRpdGlvbmFsIDsgcmQ6IHJlZ2lzdGVyIDsgcm46IHJlZ2lzdGVyIDsgb3AyOiBvcGVyYW5kIH1cbiAgfCBCSUMgb2YgeyBzOmJvb2wgOyBjb25kOiBjb25kaXRpb25hbCA7IHJkOiByZWdpc3RlciA7IHJuOiByZWdpc3RlciA7IG9wMjogb3BlcmFuZCB9XG4gIHwgQU5EIG9mIHsgczpib29sIDsgY29uZDogY29uZGl0aW9uYWwgOyByZDogcmVnaXN0ZXIgOyBybjogcmVnaXN0ZXIgOyBvcDI6IG9wZXJhbmQgfVxuXG4gIHwgQnJhbmNoIG9mIHsgbDpib29sIDsgY29uZDogY29uZGl0aW9uYWwgOyB0YXJnZXQ6IGludDMyIH1cblxub3BlbiBJbnQzMlxuXG5leGNlcHRpb24gSW52YWxpZENvbW1hbmRcblxubGV0IGExID0gMFxubGV0IGEyID0gMVxubGV0IGEzID0gMlxubGV0IGE0ID0gM1xubGV0IHYxID0gNFxubGV0IHYyID0gNVxubGV0IHYzID0gNlxubGV0IHY0ID0gN1xubGV0IHY1ID0gOFxubGV0IHY2ID0gOVxubGV0IHY3ID0gMTBcbmxldCB2OCA9IDExXG5sZXQgc2IgPSA5XG5sZXQgc2wgPSAxMFxubGV0IGZwID0gMTFcbmxldCBpcCA9IDEyXG5sZXQgc3AgPSAxM1xubGV0IGxyID0gMTRcbmxldCBwYyA9IDE1XG5cbmxldCBzaWduX3BsdXMgPSAxXG5sZXQgc2lnbl9taW51cyA9IDBcblxubGV0IGludDEgPSAwYjFcbmxldCBtYXNrMSA9IGludDEgfD4gb2ZfaW50XG5sZXQgaW50MiA9IDBiMTFcbmxldCBtYXNrMiA9IGludDIgfD4gb2ZfaW50XG5sZXQgaW50NCA9IDBiMTExMVxubGV0IG1hc2s0ID0gaW50NCB8PiBvZl9pbnRcbmxldCBpbnQ4ID0gMGIxMTExMTExMVxubGV0IG1hc2s4ID0gaW50OCB8PiBvZl9pbnRcbmxldCBpbnQ5ID0gMGIxMTExMTExMTFcbmxldCBtYXNrOSA9IGludDkgfD4gb2ZfaW50XG5sZXQgaW50MTIgPSAwYjExMTExMTExMTExMVxubGV0IG1hc2sxMiA9IGludDEyIHw+IG9mX2ludFxubGV0IGludDI0ID0gMGIxMTExMTExMTExMTFfMTExMTExMTExMTExXG5sZXQgbWFzazI0ID0gaW50MjQgfD4gb2ZfaW50XG5cbmxldCBjb25kaXRpb25fY29kZSBjID1cbiAgYmVnaW4gbWF0Y2ggYyB3aXRoXG4gIHwgRVEgLT4gMGIwMDAwIHwgTkUgLT4gMGIwMDAxIHwgQ1MgfCBIUyAtPiAwYjAwMTAgfCBDQyB8IExPIC0+IDBiMDAxMVxuICB8IE1JIC0+IDBiMDEwMCB8IFBMIC0+IDBiMDEwMSB8IFZTIC0+IDBiMDExMCB8IFZDIC0+IDBiMDExMVxuICB8IEhJIC0+IDBiMTAwMCB8IExTIC0+IDBiMTAwMSB8IEdFIC0+IDBiMTAxMCB8IExUIC0+IDBiMTAxMSB8IEdUIC0+IDBiMTEwMCB8IExFIC0+IDBiMTEwMSB8IEFMIC0+IDBiMTExMFxuICBlbmRcbiAgfD4gb2ZfaW50XG5cbmxldCBhZGRfY29uZGl0aW9uX2NvZGUgYyB2ID1cbiAgc2hpZnRfbGVmdCAoY29uZGl0aW9uX2NvZGUgYykgMjhcbiAgfD4gbG9nb3IgdlxuXG5sZXQgYWRkX3JuX2NvZGUgcm4gdiA9XG4gIHNoaWZ0X2xlZnQgKG9mX2ludCBybikgMTZcbiAgfD4gbG9nb3IgdlxuXG5sZXQgYWRkX3JkX2NvZGUgcmQgdiA9XG4gIHNoaWZ0X2xlZnQgKG9mX2ludCByZCkgMTJcbiAgfD4gbG9nb3IgdlxuXG5sZXQgcmVnaXN0ZXJfb2ZfcmVnaXN0ZXJfb2Zmc2V0IHJvID1cbiAgbWF0Y2ggcm8gd2l0aFxuICB8IE9JbW1lZGlhdGUgKHIsIF8sIF8pIHwgT1JlZ2lzdGVyIChyLCBfLCBfKSB8IE9TY2FsZWRSZWdpc3RlciAociwgXywgXywgXykgLT4gclxuXG5sZXQgcm90YXRlX3JpZ2h0IHYgPVxuICBsZXQgbGIgPSBsb2dhbmQgdiBtYXNrMSBpblxuICBsZXQgdiA9IHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgdiAxIGluXG4gIGxvZ29yIHYgKHNoaWZ0X2xlZnQgbGIgMzEpXG5cbmxldCByb3RhdGVfbGVmdCB2ID1cbiAgbGV0IGhiID0gbG9nYW5kIHYgKHNoaWZ0X2xlZnQgbWFzazEgMzEpIGluXG4gIGxldCB2ID0gc2hpZnRfbGVmdCB2IDEgaW5cbiAgbG9nb3IgdiAoc2hpZnRfcmlnaHRfbG9naWNhbCBoYiAzMSlcblxubGV0IGRlY29tcG9zZV9pbW1lZGlhdGUgaW1tID1cbiAgbGV0IHJlYyBhdXggbiBpbW0gPVxuICAgIGlmIG4gPiBpbnQ0IHRoZW4gW11cbiAgICBlbHNlXG4gICAgICBsZXQgb3RoZXJzID0gYXV4IChuKzEpIChyb3RhdGVfbGVmdCAocm90YXRlX2xlZnQgaW1tKSkgaW5cbiAgICAgIGxldCBpbW04ID0gbG9nYW5kIGltbSBtYXNrOCBpblxuICAgICAgaWYgZXF1YWwgaW1tOCBpbW0gdGhlbiAobiwgaW1tOCk6Om90aGVycyBlbHNlIG90aGVyc1xuICBpblxuICBsZXQgcmVzID0gYXV4IDAgaW1tIGluXG4gIGlmIHJlcyA9IFtdIHRoZW4gcmFpc2UgSW52YWxpZENvbW1hbmQgZWxzZSByZXNcblxubGV0IGFkZHJfbW9kZV8xIHJzID1cbiAgbGV0IHBvc3NpYmlsaXRpZXMgPVxuICAgIG1hdGNoIHJzIHdpdGhcbiAgICB8IEltbWVkaWF0ZSBpIC0+XG4gICAgICBkZWNvbXBvc2VfaW1tZWRpYXRlIGlcbiAgICAgIHw+IExpc3QubWFwIChmdW4gKHJyLCBpbW04KSAtPlxuICAgICAgICAoMSwgbG9nb3IgaW1tOCAoc2hpZnRfbGVmdCAob2ZfaW50IHJyKSA4KSlcbiAgICAgIClcbiAgICB8IFJlZ2lzdGVyIChybSkgLT5cbiAgICAgIFsoMCwgb2ZfaW50IHJtKV1cbiAgICB8IFNjYWxlZFJlZ2lzdGVyIF8gLT4gZmFpbHdpdGggXCJOb3QgaW1wbGVtZW50ZWRcIlxuICBpblxuICBwb3NzaWJpbGl0aWVzIHw+XG4gIExpc3QubWFwIChmdW4gKGltbSwgdikgLT5cbiAgICBsZXQgaSA9IHNoaWZ0X2xlZnQgKG9mX2ludCBpbW0pIDI1IGluXG4gICAgbG9nb3IgdiBpXG4gIClcblxubGV0IHBfYW5kX3cgYWRkcl90eXAgPVxuICBtYXRjaCBhZGRyX3R5cCB3aXRoXG4gIHwgT2Zmc2V0IC0+ICgxLDApXG4gIHwgUHJlSW5kZXhlZCAtPiAoMSwxKVxuICB8IFBvc3RJbmRleGVkIC0+ICgwLDApXG5cbmxldCBhZGRyX21vZGVfMiBybyBhZGRyX3R5cCA9ICgqIExvYWQgYW5kIHN0b3JlIG9mIHdvcmQgYW5kIHVieXRlICopXG4gIGxldCAoc2lnbiwgcmVnLCB2KSA9XG4gICAgbWF0Y2ggcm8gd2l0aFxuICAgIHwgT0ltbWVkaWF0ZSAoXywgc2lnbiwgdikgLT5cbiAgICAgIGlmIHVuc2lnbmVkX2NvbXBhcmUgdiBtYXNrMTIgPiAwIHRoZW4gcmFpc2UgSW52YWxpZENvbW1hbmQgO1xuICAgICAgKHNpZ24sIDAsIHYpXG4gICAgfCBPUmVnaXN0ZXIgKF8sIHNpZ24sIHJtKSAtPlxuICAgICAgKHNpZ24sIDEsIG9mX2ludCBybSlcbiAgICB8IE9TY2FsZWRSZWdpc3RlciBfIC0+IGZhaWx3aXRoIFwiTm90IGltcGxlbWVudGVkXCJcbiAgaW5cbiAgbGV0IChwLCB3KSA9IHBfYW5kX3cgYWRkcl90eXAgaW5cbiAgbGV0IGkgPSBzaGlmdF9sZWZ0IChvZl9pbnQgcmVnKSAyNSBpblxuICBsZXQgdSA9IHNoaWZ0X2xlZnQgKG9mX2ludCBzaWduKSAyMyBpblxuICBsZXQgcCA9IHNoaWZ0X2xlZnQgKG9mX2ludCBwKSAyNCBpblxuICBsZXQgdyA9IHNoaWZ0X2xlZnQgKG9mX2ludCB3KSAyMSBpblxuICBsb2dvciB2IHUgfD4gbG9nb3IgcCB8PiBsb2dvciB3IHw+IGxvZ29yIGlcblxubGV0IGFkZHJfbW9kZV8zIHJvIGFkZHJfdHlwID0gKCogT3RoZXIgbG9hZCBhbmQgc3RvcmUgKilcbiAgbGV0IChzaWduLCBpbW0sIHYpID1cbiAgICBtYXRjaCBybyB3aXRoXG4gICAgfCBPSW1tZWRpYXRlIChfLCBzaWduLCB2KSAtPlxuICAgICAgaWYgdW5zaWduZWRfY29tcGFyZSB2IG1hc2s4ID4gMCB0aGVuIHJhaXNlIEludmFsaWRDb21tYW5kIDtcbiAgICAgIGxldCBpbW1lZEwgPSBsb2dhbmQgbWFzazQgdiBpblxuICAgICAgbGV0IGltbWVkSCA9IGxvZ2FuZCBtYXNrNCAoc2hpZnRfcmlnaHRfbG9naWNhbCB2IDQpIGluXG4gICAgICAoc2lnbiwgMSwgbG9nb3IgaW1tZWRMIChzaGlmdF9sZWZ0IGltbWVkSCA4KSlcbiAgICB8IE9SZWdpc3RlciAoXywgc2lnbiwgcm0pIC0+XG4gICAgICAoc2lnbiwgMCwgb2ZfaW50IHJtKVxuICAgIHwgT1NjYWxlZFJlZ2lzdGVyIF8gLT4gcmFpc2UgSW52YWxpZENvbW1hbmRcbiAgaW5cbiAgbGV0IChwLCB3KSA9IHBfYW5kX3cgYWRkcl90eXAgaW5cbiAgbGV0IGkgPSBzaGlmdF9sZWZ0IChvZl9pbnQgaW1tKSAyMiBpblxuICBsZXQgdSA9IHNoaWZ0X2xlZnQgKG9mX2ludCBzaWduKSAyMyBpblxuICBsZXQgcCA9IHNoaWZ0X2xlZnQgKG9mX2ludCBwKSAyNCBpblxuICBsZXQgdyA9IHNoaWZ0X2xlZnQgKG9mX2ludCB3KSAyMSBpblxuICBsb2dvciB2IHUgfD4gbG9nb3IgcCB8PiBsb2dvciB3IHw+IGxvZ29yIGlcblxubGV0IHNpZ25lZF9pbW1lZDI0IGkgPVxuICBpZiBlcXVhbCAobG9nYW5kIGkgbWFzazIpIHplcm9cbiAgdGhlblxuICAgIGxldCBpID0gc2hpZnRfcmlnaHQgaSAyIGluXG4gICAgbGV0IG1zOSA9IHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgaSAyMyBpblxuICAgIGlmIGVxdWFsIG1zOSBtYXNrOSB8fCBlcXVhbCBtczkgemVyb1xuICAgIHRoZW4gbG9nYW5kIGkgbWFzazI0XG4gICAgZWxzZSByYWlzZSBJbnZhbGlkQ29tbWFuZFxuICBlbHNlIHJhaXNlIEludmFsaWRDb21tYW5kXG5cbmxldCBsZHJfc3RyX3RvX2JpbmFyeSBpc19sZHIgdHlwIGNvbmQgcmQgKHJuLCBhZGRyX3R5cCkgPVxuICBsZXQgY2hlY2tfcG9zdF9hZGRyICgpID1cbiAgICBtYXRjaCBhZGRyX3R5cCB3aXRoXG4gICAgfCBQb3N0SW5kZXhlZCAtPiAoKVxuICAgIHwgXyAtPiByYWlzZSBJbnZhbGlkQ29tbWFuZFxuICBpblxuICBsZXQgb3Bjb2RlID0gbWF0Y2ggaXNfbGRyLCB0eXAgd2l0aFxuICB8IHRydWUsIEIgIC0+IDBiMDEwMF8wMTAxXzAwMDBfMDAwMF8wMDAwXzAwMDBfMDAwMFxuICB8IHRydWUsIFNCIC0+IDBiMDAwMF8wMDAxXzAwMDBfMDAwMF8wMDAwXzExMDFfMDAwMFxuICB8IHRydWUsIEggIC0+IDBiMDAwMF8wMDAxXzAwMDBfMDAwMF8wMDAwXzEwMTFfMDAwMFxuICB8IHRydWUsIFNIIC0+IDBiMDAwMF8wMDAxXzAwMDBfMDAwMF8wMDAwXzExMTFfMDAwMFxuICB8IHRydWUsIFcgIC0+IDBiMDEwMF8wMDAxXzAwMDBfMDAwMF8wMDAwXzAwMDBfMDAwMFxuICB8IHRydWUsIFQgIC0+IGNoZWNrX3Bvc3RfYWRkciAoKSA7IDBiMDEwMF8wMDExXzAwMDBfMDAwMF8wMDAwXzAwMDBfMDAwMFxuICB8IHRydWUsIEJUIC0+IGNoZWNrX3Bvc3RfYWRkciAoKSA7IDBiMDEwMF8wMTExXzAwMDBfMDAwMF8wMDAwXzAwMDBfMDAwMFxuICB8IGZhbHNlLCBCICAtPiAwYjAxMDBfMDEwMF8wMDAwXzAwMDBfMDAwMF8wMDAwXzAwMDBcbiAgfCBmYWxzZSwgU0IgLT4gcmFpc2UgSW52YWxpZENvbW1hbmRcbiAgfCBmYWxzZSwgSCAgLT4gMGIwMDAwXzAwMDBfMDAwMF8wMDAwXzAwMDBfMTAxMV8wMDAwXG4gIHwgZmFsc2UsIFNIIC0+IHJhaXNlIEludmFsaWRDb21tYW5kXG4gIHwgZmFsc2UsIFcgIC0+IDBiMDEwMF8wMDAwXzAwMDBfMDAwMF8wMDAwXzAwMDBfMDAwMFxuICB8IGZhbHNlLCBUICAtPiBjaGVja19wb3N0X2FkZHIgKCkgOyAwYjAxMDBfMDAxMF8wMDAwXzAwMDBfMDAwMF8wMDAwXzAwMDBcbiAgfCBmYWxzZSwgQlQgLT4gY2hlY2tfcG9zdF9hZGRyICgpIDsgMGIwMTAwXzAxMTBfMDAwMF8wMDAwXzAwMDBfMDAwMF8wMDAwXG4gIGluXG4gIGxldCB2ID0gb2ZfaW50IG9wY29kZSB8PlxuICAgIGFkZF9jb25kaXRpb25fY29kZSBjb25kIHw+XG4gICAgYWRkX3JuX2NvZGUgKHJlZ2lzdGVyX29mX3JlZ2lzdGVyX29mZnNldCBybikgfD5cbiAgICBhZGRfcmRfY29kZSByZCBpblxuICBsZXQgYWRkcl9tb2RlID1cbiAgICBtYXRjaCB0eXAgd2l0aFxuICAgIHwgQiB8IFcgfCBUIHwgQlQgLT4gYWRkcl9tb2RlXzIgcm4gYWRkcl90eXBcbiAgICB8IEggfCBTSCB8IFNCIC0+IGFkZHJfbW9kZV8zIHJuIGFkZHJfdHlwXG4gIGluXG4gIFtsb2dvciB2IGFkZHJfbW9kZV1cblxubGV0IG1vdl9tdm5fdG9fYmluYXJ5IGlzX21vdiBzIGNvbmQgcmQgcnMgPVxuICBsZXQgb3Bjb2RlID0gaWYgaXNfbW92XG4gIHRoZW4gMGIwMDAxXzEwMTBfMDAwMF8wMDAwXzAwMDBfMDAwMF8wMDAwXG4gIGVsc2UgMGIwMDAxXzExMTBfMDAwMF8wMDAwXzAwMDBfMDAwMF8wMDAwIGluXG4gIGxldCBzY29kZSA9IGlmIHMgdGhlbiAxIGVsc2UgMCBpblxuICBsZXQgc2NvZGUgPSBzaGlmdF9sZWZ0IChvZl9pbnQgc2NvZGUpIDIwIGluXG4gIGxldCB2ID0gb2ZfaW50IG9wY29kZSB8PlxuICAgIGFkZF9jb25kaXRpb25fY29kZSBjb25kIHw+XG4gICAgYWRkX3JkX2NvZGUgcmQgfD5cbiAgICBsb2dvciBzY29kZSBpblxuICBhZGRyX21vZGVfMSBycyB8PlxuICBMaXN0Lm1hcCAoZnVuIGFkZHJfbW9kZSAtPiBsb2dvciB2IGFkZHJfbW9kZSlcblxubGV0IGNhbGN1bGF0aW9uX3RvX2JpbmFyeSB0eXAgcyBjb25kIHJkIHJuIG9wMiA9XG4gIGxldCBvcGNvZGUgPSBtYXRjaCB0eXAgd2l0aFxuICB8IFwiYWRjXCIgLT4gMGIwMDAwXzEwMTBfMDAwMF8wMDAwXzAwMDBfMDAwMF8wMDAwXG4gIHwgXCJzYmNcIiAtPiAwYjAwMDBfMTEwMF8wMDAwXzAwMDBfMDAwMF8wMDAwXzAwMDBcbiAgfCBcImJpY1wiIC0+IDBiMDAwMV8xMTAwXzAwMDBfMDAwMF8wMDAwXzAwMDBfMDAwMFxuICB8IFwiYW5kXCIgLT4gMGIwMDAwXzAwMDBfMDAwMF8wMDAwXzAwMDBfMDAwMF8wMDAwXG4gIHwgXyAtPiBhc3NlcnQgZmFsc2VcbiAgaW5cbiAgbGV0IHNjb2RlID0gaWYgcyB0aGVuIDEgZWxzZSAwIGluXG4gIGxldCBzY29kZSA9IHNoaWZ0X2xlZnQgKG9mX2ludCBzY29kZSkgMjAgaW5cbiAgbGV0IHYgPSBvZl9pbnQgb3Bjb2RlIHw+XG4gICAgYWRkX2NvbmRpdGlvbl9jb2RlIGNvbmQgfD5cbiAgICBhZGRfcmRfY29kZSByZCB8PlxuICAgIGFkZF9ybl9jb2RlIHJuIHw+XG4gICAgbG9nb3Igc2NvZGUgaW5cbiAgYWRkcl9tb2RlXzEgb3AyIHw+XG4gIExpc3QubWFwIChmdW4gYWRkcl9tb2RlIC0+IGxvZ29yIHYgYWRkcl9tb2RlKVxuXG5sZXQgYnJhbmNoX3RvX2JpbmFyeSBsIGNvbmQgdGFyZ2V0ID1cbiAgbGV0IG9wY29kZSA9XG4gICAgaWYgbFxuICAgIHRoZW4gMGIxMDExXzAwMDBfMDAwMF8wMDAwXzAwMDBfMDAwMF8wMDAwXG4gICAgZWxzZSAwYjEwMTBfMDAwMF8wMDAwXzAwMDBfMDAwMF8wMDAwXzAwMDBcbiAgaW5cbiAgbGV0IHYgPSBvZl9pbnQgb3Bjb2RlIHw+XG4gICAgYWRkX2NvbmRpdGlvbl9jb2RlIGNvbmQgaW5cbiAgbGV0IGltbSA9IHNpZ25lZF9pbW1lZDI0IChzdWIgdGFyZ2V0IDhsKSBpblxuICBbbG9nb3IgdiBpbW1dXG5cbmxldCBhcm1fdG9fYmluYXJ5IGFybSA9XG4gIG1hdGNoIGFybSB3aXRoXG4gIHwgQ3VzdG9tIGkgLT4gW2ldXG4gIHwgTERSIHt0eXA7Y29uZDtyZDtyb30gLT4gbGRyX3N0cl90b19iaW5hcnkgdHJ1ZSB0eXAgY29uZCByZCByb1xuICB8IFNUUiB7dHlwO2NvbmQ7cmQ7cm99IC0+IGxkcl9zdHJfdG9fYmluYXJ5IGZhbHNlIHR5cCBjb25kIHJkIHJvXG4gIHwgTU9WIHtzO2NvbmQ7cmQ7cnN9ICAgLT4gbW92X212bl90b19iaW5hcnkgdHJ1ZSBzIGNvbmQgcmQgcnNcbiAgfCBNVk4ge3M7Y29uZDtyZDtyc30gICAtPiBtb3ZfbXZuX3RvX2JpbmFyeSBmYWxzZSBzIGNvbmQgcmQgcnNcbiAgfCBBREMge3M7Y29uZDtyZDtybjtvcDJ9IC0+IGNhbGN1bGF0aW9uX3RvX2JpbmFyeSBcImFkY1wiIHMgY29uZCByZCBybiBvcDJcbiAgfCBTQkMge3M7Y29uZDtyZDtybjtvcDJ9IC0+IGNhbGN1bGF0aW9uX3RvX2JpbmFyeSBcInNiY1wiIHMgY29uZCByZCBybiBvcDJcbiAgfCBCSUMge3M7Y29uZDtyZDtybjtvcDJ9IC0+IGNhbGN1bGF0aW9uX3RvX2JpbmFyeSBcImJpY1wiIHMgY29uZCByZCBybiBvcDJcbiAgfCBBTkQge3M7Y29uZDtyZDtybjtvcDJ9IC0+IGNhbGN1bGF0aW9uX3RvX2JpbmFyeSBcImFuZFwiIHMgY29uZCByZCBybiBvcDJcbiAgfCBCcmFuY2gge2w7Y29uZDt0YXJnZXR9IC0+IGJyYW5jaF90b19iaW5hcnkgbCBjb25kIHRhcmdldFxuXG5sZXQgcmV2ZXJzZV9lbmRpYW5uZXNzIHYgPVxuICBsZXQgdjEgPSBzaGlmdF9sZWZ0IChsb2dhbmQgbWFzazggdikgKDMqOCkgaW5cbiAgbGV0IHYgPSBzaGlmdF9yaWdodF9sb2dpY2FsIHYgOCBpblxuICBsZXQgdjIgPSBzaGlmdF9sZWZ0IChsb2dhbmQgbWFzazggdikgKDIqOCkgaW5cbiAgbGV0IHYgPSBzaGlmdF9yaWdodF9sb2dpY2FsIHYgOCBpblxuICBsZXQgdjMgPSBzaGlmdF9sZWZ0IChsb2dhbmQgbWFzazggdikgKDEqOCkgaW5cbiAgbGV0IHYgPSBzaGlmdF9yaWdodF9sb2dpY2FsIHYgOCBpblxuICBsZXQgdjQgPSBsb2dhbmQgbWFzazggdiBpblxuICBsb2dvciB2MSB2MiB8PiBsb2dvciB2MyB8PiBsb2dvciB2NFxuIiwib3BlbiBJbnQzMlxub3BlbiBDaGFyc2V0XG5vcGVuIFV0aWxzXG5cbmxldCBlb2YgPSAweEZGXG5sZXQgc3BhY2UgPSAweDAwXG5cbmxldCBpbnQ4ID0gMGIxMTExMTExMVxubGV0IG1hc2s4ID0gaW50OCB8PiBvZl9pbnRcblxubGV0IGNvZGVzX2Zvcl9jb21tYW5kIHYgPVxuICBsZXQgdjEgPSBsb2dhbmQgbWFzazggdiBpblxuICBsZXQgdiA9IHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgdiA4IGluXG4gIGxldCB2MiA9IGxvZ2FuZCBtYXNrOCB2IGluXG4gIGxldCB2ID0gc2hpZnRfcmlnaHRfbG9naWNhbCB2IDggaW5cbiAgbGV0IHYzID0gbG9nYW5kIG1hc2s4IHYgaW5cbiAgbGV0IHYgPSBzaGlmdF9yaWdodF9sb2dpY2FsIHYgOCBpblxuICBsZXQgdjQgPSBsb2dhbmQgbWFzazggdiBpblxuICBbIHVpbnQzMl90b19pbnQgdjEgOyB1aW50MzJfdG9faW50IHYyIDsgdWludDMyX3RvX2ludCB2MyA7IHVpbnQzMl90b19pbnQgdjQgXVxuXG5sZXQgY29tbWFuZF9mb3JfY29kZXMgY29kZXMgPVxuICBtYXRjaCBjb2RlcyB3aXRoXG4gIHwgW2MxO2MyO2MzO2M0XSAtPlxuICAgIGxldCB2MSA9IGMxIHw+IG9mX2ludCBpblxuICAgIGxldCB2MiA9IGMyIHw+IG9mX2ludCBpblxuICAgIGxldCB2MyA9IGMzIHw+IG9mX2ludCBpblxuICAgIGxldCB2NCA9IGM0IHw+IG9mX2ludCBpblxuICAgIGxldCB2ID0gc2hpZnRfbGVmdCB2NCA4IGluXG4gICAgbGV0IHYgPSBsb2dvciB2IHYzIGluXG4gICAgbGV0IHYgPSBzaGlmdF9sZWZ0IHYgOCBpblxuICAgIGxldCB2ID0gbG9nb3IgdiB2MiBpblxuICAgIGxldCB2ID0gc2hpZnRfbGVmdCB2IDggaW5cbiAgICBsb2dvciB2IHYxXG4gIHwgXyAtPiBhc3NlcnQgZmFsc2VcblxubGV0IGNvZGVzX3RvX2NoYXJzIGMgPVxuICBMaXN0Lm1hcCB3cml0YWJsZV9jaGFyX2F0IGNcblxubGV0IGNoYXJzX2Zvcl9jb21tYW5kIHYgPVxuICBjb2Rlc19mb3JfY29tbWFuZCB2IHw+IGNvZGVzX3RvX2NoYXJzXG5cbmxldCBwcF9jaGFycyBmbXQgbHN0ID1cbiAgbHN0IHw+IExpc3QuaXRlcmkgKGZ1biBpIHN0ciAtPlxuICAgIEZvcm1hdC5mcHJpbnRmIGZtdCBcIiVzJXNcIiAoaWYgaSA9IDAgdGhlbiBcIlwiIGVsc2UgXCIgXCIpIHN0clxuICApXG5cbmxldCBwcF9jaGFyc19yYXcgZm10IGxzdCA9XG4gIGxzdCB8PiBMaXN0Lml0ZXIgKGZ1biBzdHIgLT5cbiAgICBsZXQgc3RyID0gaWYgc3RyID0gc3BhY2luZ19jaGFyIHRoZW4gXCIgXCIgZWxzZSBzdHIgaW5cbiAgICBGb3JtYXQuZnByaW50ZiBmbXQgXCIlc1wiIHN0clxuICApXG5cbmxldCBpc19jb2RlX3dyaXRhYmxlIGNvZGVzID1cbiAgTGlzdC5mb3JfYWxsIGlzX2NvZGVfYXZhaWxhYmxlIGNvZGVzXG5cbmxldCByZWMgZmlyc3RfY29kZSBmIGNvZGVzID1cbiAgbWF0Y2ggY29kZXMgd2l0aFxuICB8IFtdIC0+IHJhaXNlIE5vdF9mb3VuZFxuICB8IGNvZGU6OmNvZGVzIC0+XG4gICAgaWYgZiBjb2RlIHRoZW4gY29kZVxuICAgIGVsc2UgZmlyc3RfY29kZSBmIGNvZGVzXG5cbmxldCBmaXJzdF93cml0YWJsZV9jb2RlIGNvZGVzID1cbiAgZmlyc3RfY29kZSBpc19jb2RlX3dyaXRhYmxlIGNvZGVzXG5cbmxldCBpc19jb2RlX3dyaXRhYmxlX29yX29uZV9lb2YgY29kZSA9XG4gIChMaXN0LmZpbHRlciAoZnVuIGMgLT4gYyA8PiBlb2YpIGNvZGUgfD4gaXNfY29kZV93cml0YWJsZSkgJiZcbiAgKExpc3QuZm9sZF9sZWZ0IChmdW4gbmIgYyAtPiBpZiBjID0gZW9mIHRoZW4gbmIrMSBlbHNlIG5iKSAwIGNvZGUpIDw9IDFcblxubGV0IHByZWZlcnJlZF9jb2RlIGNvZGVzID1cbiAgdHJ5IGZpcnN0X3dyaXRhYmxlX2NvZGUgY29kZXNcbiAgd2l0aCBOb3RfZm91bmQgLT4gYmVnaW5cbiAgICB0cnkgZmlyc3RfY29kZSBpc19jb2RlX3dyaXRhYmxlX29yX29uZV9lb2YgY29kZXNcbiAgICB3aXRoIE5vdF9mb3VuZCAtPiBMaXN0LmhkIGNvZGVzXG4gIGVuZFxuXG5sZXQgaXNfZnVsbF9vZl9zcGFjZXMgY29kZXMgPVxuICBMaXN0LmZvcl9hbGwgKGZ1biBjIC0+IGMgPSBzcGFjZSkgY29kZXNcbiIsIm9wZW4gSW50MzJcbm9wZW4gVXRpbHNcbm9wZW4gQXJtXG5cbmV4Y2VwdGlvbiBDYW5ub3RPcHRpbWl6ZVxuXG50eXBlIHR3ZWFraW5nX3NldHRpbmdzID1cbiAgfCBOb1R3ZWFraW5nXG4gIHwgVHdlYWtGaXhlZExlbmd0aCBvZiBpbnRcbiAgfCBUd2Vha01pbkxlbmd0aFxuXG5tb2R1bGUgVUludDMyID0gc3RydWN0XG4gIHR5cGUgdCA9IGludDMyXG4gICgqbGV0IGVxdWFsID0gZXF1YWwqKVxuICBsZXQgY29tcGFyZSA9IHVuc2lnbmVkX2NvbXBhcmVcbmVuZFxuXG5tb2R1bGUgVUludDMyU2V0ID0gU2V0Lk1ha2UoVUludDMyKVxuXG5sZXQgcGFkZGluZ19jb2RlID0gQ3VzdG9tIHplcm9cblxubGV0IGNhcnJ5X291dCBpID0gY29tcGFyZSBpIHplcm8gPCAwXG5cbmxldCBjb21wdXRlX2FsbF9jb25zdGFudHMgXyA9XG4gIGxldCByZWMgYWxsX2ltbWVkOCBtYXggYWNjIGkgPVxuICAgIGlmIGVxdWFsIGkgbWF4IHRoZW4gaTo6YWNjXG4gICAgZWxzZSBhbGxfaW1tZWQ4IG1heCAoaTo6YWNjKSAoc3VjYyBpKVxuICBpblxuICBsZXQgaW1tZWQ4ID0gYWxsX2ltbWVkOCAob2ZfaW50IDI1NSkgW10gemVybyBpblxuICBsZXQgaW1tZWQ4ID0gaW1tZWQ4IHw+IExpc3QuZmlsdGVyIChmdW4gaSAtPlxuICAgIE5hbWUuaXNfY29kZV93cml0YWJsZSBbVXRpbHMudWludDMyX3RvX2ludCBpXVxuICApIGluXG4gIGxldCByZWMgYWxsX3JvdGF0aW9ucyBpbml0aWFsIGFjYyBpID1cbiAgICBsZXQgaSA9IEFybS5yb3RhdGVfcmlnaHQgaSB8PiBBcm0ucm90YXRlX3JpZ2h0IGluXG4gICAgaWYgZXF1YWwgaSBpbml0aWFsIHRoZW4gYWNjXG4gICAgZWxzZSBhbGxfcm90YXRpb25zIGluaXRpYWwgKGk6OmFjYykgaVxuICBpblxuICBpbW1lZDggfD4gTGlzdC5tYXAgKGZ1biBpIC0+XG4gICAgYWxsX3JvdGF0aW9ucyBpIFtpXSBpXG4gICkgfD4gTGlzdC5mbGF0dGVuIHw+IFVJbnQzMlNldC5vZl9saXN0XG5cbmxldCBjb25zdGFudHNfc2V0ID0gY29tcHV0ZV9hbGxfY29uc3RhbnRzICgpXG5sZXQgY29uc3RhbnRzX3NldF9ub19jYXJyeSA9XG4gIGNvbnN0YW50c19zZXQgfD4gVUludDMyU2V0LmZpbHRlciAoZnVuIGkgLT4gY2Fycnlfb3V0IGkgfD4gbm90KVxuICB8PiBVSW50MzJTZXQucmVtb3ZlIEludDMyLnplcm8gKCogV2UgdHJ5IHRvIGF2b2lkIHNldHRpbmcgdGhlIHplcm8gZmxhZyAqKVxuXG5sZXQgY29uc3RhbnRzID0gY29uc3RhbnRzX3NldCB8PiBVSW50MzJTZXQuZWxlbWVudHNcbmxldCByZXZfY29uc3RhbnRzID0gTGlzdC5yZXYgY29uc3RhbnRzXG5cbmxldCBjb25zdGFudHNfbW92X212biA9XG4gIGxldCBuc2V0ID0gVUludDMyU2V0Lm1hcCBsb2dub3QgY29uc3RhbnRzX3NldCBpblxuICBVSW50MzJTZXQudW5pb24gY29uc3RhbnRzX3NldF9ub19jYXJyeSBuc2V0IHw+IFVJbnQzMlNldC5lbGVtZW50c1xuXG5sZXQgcmV2X2NvbnN0YW50c19tb3ZfbXZuID0gTGlzdC5yZXYgY29uc3RhbnRzX21vdl9tdm5cblxubGV0IHRyaWVzX2F0X2RlcHRoXzAgPSBbfCAweDEwMDAwIDsgMHgxMDAwMCA7IDB4MTAwMDAgOyAweDIwMCA7IDB4NDAgOyAweDggOyAweDEgfF1cblxubGV0IHJlYyByZW1vdmVfd2hpbGUgZiBsc3QgPVxuICBtYXRjaCBsc3Qgd2l0aFxuICB8IFtdIC0+IFtdXG4gIHwgaSc6OmxzdCB3aGVuIGYgaScgLT4gcmVtb3ZlX3doaWxlIGYgbHN0XG4gIHwgbHN0IC0+IGxzdFxuXG5sZXQgc3ludGhlc2lzIH5tb3ZfbXZuIH5hZGRpdGl2ZSB+aW5jciBtYXhfY2FyZCBpIGlzX3ZhbGlkX2ZzdCBpc192YWxpZCA9XG4gIGxldCB0YWQwID0gdHJpZXNfYXRfZGVwdGhfMCBpblxuICBsZXQgdGFkMF9sZW4gPSBBcnJheS5sZW5ndGggdGFkMCBpblxuICBsZXQgdGFkMCA9IGlmIHRhZDBfbGVuIDwgbWF4X2NhcmQgdGhlbiB0YWQwLih0YWQwX2xlbi0xKSBlbHNlIHRhZDAuKG1heF9jYXJkLTEpIGluXG5cbiAgbGV0IHJlbW92ZSA9IChmdW4gaSAtPiByZW1vdmVfd2hpbGUgKGZ1biBqIC0+IHVuc2lnbmVkX2NvbXBhcmUgaSBqIDwgMCkpIGluXG4gIGxldCByZWMgbmV4dCBhY2MgcmMgaSA9XG4gICAgbGV0IHJlYyBhdXggdHJ5X25iIHJjID1cbiAgICAgIGlmIGVxdWFsIGkgemVybyB0aGVuIFNvbWUgYWNjXG4gICAgICBlbHNlXG4gICAgICAgIGxldCBkZXB0aCA9IExpc3QubGVuZ3RoIGFjYyBpblxuICAgICAgICBpZiBkZXB0aCA+PSBtYXhfY2FyZCB0aGVuIE5vbmVcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGxldCByZW1fZGVwdGggPSBtYXhfY2FyZCAtIGRlcHRoIHw+IEludDY0Lm9mX2ludCBpblxuICAgICAgICAgIGxldCBpNjQgPSBpbnQ2NF9vZl91aW50MzIgaSBpblxuICAgICAgICAgIGxldCBpaSA9IGlmIGluY3IgdGhlbiBwcmVkIGkgZWxzZSBpIGluXG4gICAgICAgICAgbWF0Y2ggcmVtb3ZlIGlpIHJjIHdpdGhcbiAgICAgICAgICB8IFtdIC0+IE5vbmVcbiAgICAgICAgICB8IGZzdDo6XyB3aGVuIEludDY0LnVuc2lnbmVkX2NvbXBhcmUgKCogT3B0aW1pc2F0aW9uICopXG4gICAgICAgICAgICAgICAgICAgICAgICAgIChJbnQ2NC5tdWwgKChpZiBpbmNyIHRoZW4gc3VjYyBmc3QgZWxzZSBmc3QpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHw+IGludDY0X29mX3VpbnQzMikgcmVtX2RlcHRoKSBpNjQgPCAwIC0+IE5vbmVcbiAgICAgICAgICB8IGZzdDo6cmMgLT5cbiAgICAgICAgICAgIGxldCByZW1haW5kZXIgPSBzdWIgaWkgZnN0IGluXG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBuZXh0IChmc3Q6OmFjYykgKGZzdDo6cmMpIHJlbWFpbmRlciB3aXRoXG4gICAgICAgICAgICB8IE5vbmUgLT4gYXV4ICh0cnlfbmIrMSkgcmNcbiAgICAgICAgICAgIHwgU29tZSByZXMgLT4gU29tZSByZXNcbiAgICAgICAgICAgIGVuZFxuICAgIGluXG4gICAgYXV4IDAgcmNcbiAgaW5cblxuICBsZXQgZmlsdGVyZWRfcmV2X2NvbnN0YW50cyA9IExpc3QuZmlsdGVyIGlzX3ZhbGlkIHJldl9jb25zdGFudHMgaW5cbiAgbGV0IHJlbW92ZV9pbml0ID1cbiAgICBpZiBhZGRpdGl2ZSB0aGVuIHJlbW92ZVxuICAgIGVsc2UgKGZ1biBpIC0+IHJlbW92ZV93aGlsZSAoZnVuIGogLT4gdW5zaWduZWRfY29tcGFyZSBpIGogPiAwKSlcbiAgaW5cbiAgbGV0IG9wX2luaXQgPSBpZiBhZGRpdGl2ZSB0aGVuIHN1YiBlbHNlIChmdW4geCB5IC0+IHN1YiB5IHgpIGluXG4gIGxldCByZWMgaW5pdCB0cnlfbmIgcmMgPVxuICAgIGlmIHRyeV9uYiA+PSB0YWQwIHRoZW4gTm9uZVxuICAgIGVsc2UgbWF0Y2ggcmVtb3ZlX2luaXQgaSByYyB3aXRoXG4gICAgfCBbXSAtPiBOb25lXG4gICAgfCBmc3Q6OnJjIC0+XG4gICAgICBsZXQgcmVtYWluZGVyID0gb3BfaW5pdCBpIGZzdCBpblxuICAgICAgYmVnaW4gbWF0Y2ggbmV4dCBbZnN0XSBmaWx0ZXJlZF9yZXZfY29uc3RhbnRzIHJlbWFpbmRlciB3aXRoXG4gICAgICB8IE5vbmUgLT4gaW5pdCAodHJ5X25iKzEpIHJjXG4gICAgICB8IFNvbWUgcmVzIC0+IFNvbWUgcmVzXG4gICAgICBlbmRcbiAgaW5cblxuICBsZXQgaW5pdF9yYyA9XG4gICAgaWYgYWRkaXRpdmVcbiAgICB0aGVuIChpZiBtb3ZfbXZuIHRoZW4gcmV2X2NvbnN0YW50c19tb3ZfbXZuIGVsc2UgcmV2X2NvbnN0YW50cylcbiAgICBlbHNlIChpZiBtb3ZfbXZuIHRoZW4gY29uc3RhbnRzX21vdl9tdm4gZWxzZSBjb25zdGFudHMpXG4gIGluXG4gIGxldCBpbml0X3JjID0gTGlzdC5maWx0ZXIgaXNfdmFsaWRfZnN0IGluaXRfcmMgaW5cbiAgaW5pdCAwIGluaXRfcmMgfD5cbiAgKGZ1bmN0aW9uIE5vbmUgLT4gTm9uZSB8IFNvbWUgbHN0IC0+IFNvbWUgKExpc3QucmV2IGxzdCkpXG5cbmxldCBzeW50aGVzaXNfb3B0aW1hbCB+bW92X212biB+aW52IG1heF9jYXJkIGkgaXNfdmFsaWRfZnN0IGlzX3ZhbGlkID1cbiAgbGV0IHJlYyBhdXggY2FyZCA9XG4gICAgKCpGb3JtYXQucHJpbnRmIFwiVHJ5aW5nIHdpdGggY2FyZD0laUAuXCIgY2FyZCA7KilcbiAgICBpZiBjYXJkID4gbWF4X2NhcmQgdGhlbiBOb25lXG4gICAgZWxzZVxuICAgICAgbWF0Y2ggc3ludGhlc2lzIH5tb3ZfbXZuIH5hZGRpdGl2ZTp0cnVlIH5pbmNyOmludlxuICAgICAgICAgICAgICAgICAgY2FyZCBpIGlzX3ZhbGlkX2ZzdCAoaXNfdmFsaWQgdHJ1ZSkgd2l0aFxuICAgICAgfCBTb21lIGxzdCAtPiBTb21lIChsc3QsIHRydWUpXG4gICAgICB8IE5vbmUgLT5cbiAgICAgICAgYmVnaW4gbWF0Y2ggc3ludGhlc2lzIH5tb3ZfbXZuIH5hZGRpdGl2ZTpmYWxzZSB+aW5jcjoobm90IGludilcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhcmQgaSBpc192YWxpZF9mc3QgKGlzX3ZhbGlkIGZhbHNlKSB3aXRoXG4gICAgICAgIHwgU29tZSBsc3QgLT4gU29tZSAobHN0LCBmYWxzZSlcbiAgICAgICAgfCBOb25lIC0+IGF1eCAoY2FyZCsxKVxuICAgICAgICBlbmRcbiAgaW5cbiAgYXV4IDFcblxubGV0IHN5bnRoZXNpc190ZXN0IG1heF9jYXJkIGkgPVxuICBzeW50aGVzaXNfb3B0aW1hbCB+bW92X212bjp0cnVlIH5pbnY6ZmFsc2VcbiAgICBtYXhfY2FyZCBpIChmdW4gXyAtPiB0cnVlKSAoZnVuIF8gXyAtPiB0cnVlKVxuXG5sZXQgaXNfY29tbWFuZF92YWxpZCBhcm0gPVxuICB0cnkgKFxuICAgIGFybV90b19iaW5hcnkgYXJtIHw+XG4gICAgTGlzdC5leGlzdHMgKGZ1biBpIC0+IE5hbWUuY29kZXNfZm9yX2NvbW1hbmQgaSB8PiBOYW1lLmlzX2NvZGVfd3JpdGFibGUpXG4gICkgd2l0aCBJbnZhbGlkQ29tbWFuZCAtPiBmYWxzZVxuXG5sZXQgdHdlYWtfbW92X29yX212biBpc19tb3YgcyBjb25kIHJkIHJzIG1heF9jYXJkID1cbiAgbGV0IGNtZCA9IGlmIGlzX21vdiB0aGVuIE1PViB7cztjb25kO3JkO3JzfSBlbHNlIE1WTiB7cztjb25kO3JkO3JzfSBpblxuICBtYXRjaCBycyB3aXRoXG4gIHwgUmVnaXN0ZXIgXyAtPiBbY21kXVxuICB8IFNjYWxlZFJlZ2lzdGVyIF8gLT4gZmFpbHdpdGggXCJOb3QgaW1wbGVtZW50ZWRcIlxuICB8IEltbWVkaWF0ZSBpIC0+XG4gICAgbGV0IG1rX2NtZF9maXJzdCBmc3QgPVxuICAgICAgbGV0IG5mc3QgPSBsb2dub3QgZnN0IGluXG4gICAgICBsZXQgaXNfbW92ID1cbiAgICAgICAgKGlzX21vdiAmJiBVSW50MzJTZXQubWVtIGZzdCBjb25zdGFudHNfc2V0X25vX2NhcnJ5KVxuICAgICAgICB8fCAoVUludDMyU2V0Lm1lbSBuZnN0IGNvbnN0YW50c19zZXQgfD4gbm90KVxuICAgICAgaW5cbiAgICAgIGlmIGlzX21vdlxuICAgICAgdGhlbiBNT1Yge3M9dHJ1ZTtjb25kO3JkO3JzPUltbWVkaWF0ZSBmc3R9XG4gICAgICBlbHNlIE1WTiB7cz1mYWxzZTtjb25kO3JkO3JzPUltbWVkaWF0ZSBuZnN0fVxuICAgIGluXG4gICAgbGV0IG1rX2NtZCBhZGRpdGl2ZSBpID1cbiAgICAgIGlmIGFkZGl0aXZlXG4gICAgICB0aGVuIEFEQyB7cz0ocmQ9MTUgfHwgcmQ9MCk7Y29uZDtyZDtybj1yZDtvcDI9SW1tZWRpYXRlIGl9XG4gICAgICBlbHNlIFNCQyB7cz1mYWxzZTtjb25kO3JkO3JuPXJkO29wMj1JbW1lZGlhdGUgaX1cbiAgICBpblxuICAgIGxldCBpID0gaWYgaXNfbW92IHRoZW4gaSBlbHNlIGxvZ25vdCBpIGluXG4gICAgYmVnaW4gbWF0Y2ggc3ludGhlc2lzX29wdGltYWwgfm1vdl9tdm46dHJ1ZSB+aW52OmZhbHNlIG1heF9jYXJkIGlcbiAgICAgICAgICAgICAgICAgIChmdW4gaSAtPiBta19jbWRfZmlyc3QgaSB8PiBpc19jb21tYW5kX3ZhbGlkKVxuICAgICAgICAgICAgICAgICAgKGZ1biBhZGQgaSAtPiBta19jbWQgYWRkIGkgfD4gaXNfY29tbWFuZF92YWxpZCkgd2l0aFxuICAgIHwgTm9uZSAtPiBbY21kXVxuICAgIHwgU29tZSAoZnN0Ojpsc3QsIGFkZGl0aXZlKSAtPlxuICAgICAgKG1rX2NtZF9maXJzdCBmc3QpOjooTGlzdC5tYXAgKG1rX2NtZCBhZGRpdGl2ZSkgbHN0KVxuICAgIHwgXyAtPiBhc3NlcnQgZmFsc2VcbiAgICBlbmRcblxubGV0IHR3ZWFrX2FkY19vcl9zYmMgaXNfYWRjIHMgY29uZCByZCBybiBvcDIgbWF4X2NhcmQgPVxuICBsZXQgY21kID0gaWYgaXNfYWRjIHRoZW4gQURDIHtzO2NvbmQ7cmQ7cm47b3AyfSBlbHNlIFNCQyB7cztjb25kO3JkO3JuO29wMn0gaW5cbiAgbWF0Y2ggb3AyIHdpdGhcbiAgfCBSZWdpc3RlciBfIC0+IFtjbWRdXG4gIHwgU2NhbGVkUmVnaXN0ZXIgXyAtPiBmYWlsd2l0aCBcIk5vdCBpbXBsZW1lbnRlZFwiXG4gIHwgSW1tZWRpYXRlIGkgLT5cbiAgICBsZXQgbWtfY21kX2ZpcnN0IGZzdCA9XG4gICAgICBpZiBpc19hZGNcbiAgICAgIHRoZW4gQURDIHtzPShybj0xNSB8fCBybj0wKTtjb25kO3JkO3JuO29wMj1JbW1lZGlhdGUgZnN0fVxuICAgICAgZWxzZSBTQkMge3M9ZmFsc2U7Y29uZDtyZDtybjtvcDI9SW1tZWRpYXRlIGZzdH1cbiAgICBpblxuICAgIGxldCBta19jbWQgYWRkaXRpdmUgaSA9XG4gICAgICBpZiAoYWRkaXRpdmUgJiYgaXNfYWRjKSB8fCAobm90IGFkZGl0aXZlICYmIG5vdCBpc19hZGMpXG4gICAgICB0aGVuIEFEQyB7cz0ocmQ9MTUgfHwgcmQ9MCk7Y29uZDtyZDtybj1yZDtvcDI9SW1tZWRpYXRlIGl9XG4gICAgICBlbHNlIFNCQyB7cz1mYWxzZTtjb25kO3JkO3JuPXJkO29wMj1JbW1lZGlhdGUgaX1cbiAgICBpblxuICAgIGJlZ2luIG1hdGNoIHN5bnRoZXNpc19vcHRpbWFsIH5tb3ZfbXZuOmZhbHNlIH5pbnY6KG5vdCBpc19hZGMpIG1heF9jYXJkIGlcbiAgICAgICAgICAgICAgICAgIChmdW4gaSAtPiBta19jbWRfZmlyc3QgaSB8PiBpc19jb21tYW5kX3ZhbGlkKVxuICAgICAgICAgICAgICAgICAgKGZ1biBhZGQgaSAtPiBta19jbWQgYWRkIGkgfD4gaXNfY29tbWFuZF92YWxpZCkgd2l0aFxuICAgIHwgTm9uZSAtPiBbY21kXVxuICAgIHwgU29tZSAoZnN0Ojpsc3QsIGFkZGl0aXZlKSAtPlxuICAgICAgKG1rX2NtZF9maXJzdCBmc3QpOjooTGlzdC5tYXAgKG1rX2NtZCBhZGRpdGl2ZSkgbHN0KVxuICAgIHwgXyAtPiBhc3NlcnQgZmFsc2VcbiAgICBlbmRcblxubGV0IHR3ZWFrX2NvbW1hbmQgKGFybSwgb3B0aW1pemUpID1cbiAgbGV0IG9wdGltaXplX3dpdGhfY2FyZCBhcm0gbiBwYWQgPVxuICAgIGxldCByZXMgPVxuICAgICAgbWF0Y2ggYXJtIHdpdGhcbiAgICAgIHwgTU9WIHtzO2NvbmQ7cmQ7cnN9IC0+IHR3ZWFrX21vdl9vcl9tdm4gdHJ1ZSBzIGNvbmQgcmQgcnMgblxuICAgICAgfCBNVk4ge3M7Y29uZDtyZDtyc30gLT4gdHdlYWtfbW92X29yX212biBmYWxzZSBzIGNvbmQgcmQgcnMgblxuICAgICAgfCBBREMge3M7Y29uZDtyZDtybjtvcDJ9IC0+IHR3ZWFrX2FkY19vcl9zYmMgdHJ1ZSBzIGNvbmQgcmQgcm4gb3AyIG5cbiAgICAgIHwgU0JDIHtzO2NvbmQ7cmQ7cm47b3AyfSAtPiB0d2Vha19hZGNfb3Jfc2JjIGZhbHNlIHMgY29uZCByZCBybiBvcDIgblxuICAgICAgfCBfIC0+IFthcm1dXG4gICAgaW5cbiAgICBpZiBwYWRcbiAgICB0aGVuXG4gICAgICBsZXQgcGFkZGluZyA9IExpc3QuaW5pdCAobiAtIChMaXN0Lmxlbmd0aCByZXMpKSAoZnVuIF8gLT4gcGFkZGluZ19jb2RlKSBpblxuICAgICAgcmVzQHBhZGRpbmdcbiAgICBlbHNlIHJlc1xuICBpblxuICBtYXRjaCBvcHRpbWl6ZSB3aXRoXG4gIHwgTm9Ud2Vha2luZyAtPiBbYXJtXVxuICB8IFR3ZWFrTWluTGVuZ3RoIC0+IG9wdGltaXplX3dpdGhfY2FyZCBhcm0gNSBmYWxzZVxuICB8IFR3ZWFrRml4ZWRMZW5ndGggY2FyZCAtPiBvcHRpbWl6ZV93aXRoX2NhcmQgYXJtIGNhcmQgdHJ1ZVxuXG5sZXQgdHdlYWtfYXJtIGxzdCA9XG4gIGxzdCB8PiBMaXN0Lm1hcCB0d2Vha19jb21tYW5kIHw+IExpc3QuZmxhdHRlblxuXG5sZXQgZG9fbm90X3R3ZWFrX2FybSBsc3QgPVxuICBsc3QgfD4gTGlzdC5tYXAgKGZ1biAoYXJtLCBvcHRpbWl6ZSkgLT5cbiAgICBpZiBvcHRpbWl6ZSA8PiBOb1R3ZWFraW5nIHRoZW4gcmFpc2UgQ2Fubm90T3B0aW1pemUgZWxzZSBhcm1cbiAgKVxuIiwiXG5tb2R1bGUgTWVuaGlyQmFzaWNzID0gc3RydWN0XG4gIFxuICBleGNlcHRpb24gRXJyb3JcbiAgXG4gIHR5cGUgdG9rZW4gPSBcbiAgICB8IFhPUlxuICAgIHwgVElNRVNcbiAgICB8IFNUUklORyBvZiAoXG4jIDcgXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAoc3RyaW5nKVxuIyAxMyBcIklPL3BhcnNlci5tbFwiXG4gIClcbiAgICB8IFJTSElGVFxuICAgIHwgUlBBUkVOXG4gICAgfCBSSUdIVF9CUkFDS1xuICAgIHwgUklHSFRfQlJBQ0VcbiAgICB8IFBMVVNcbiAgICB8IE9SXG4gICAgfCBOVU1CRVIgb2YgKFxuIyA4IFwiSU8vcGFyc2VyLm1seVwiXG4gICAgICAgKGludDMyKVxuIyAyNCBcIklPL3BhcnNlci5tbFwiXG4gIClcbiAgICB8IE5VTExcbiAgICB8IE5PVFxuICAgIHwgTkVRXG4gICAgfCBNT0RcbiAgICB8IE1JTlVTXG4gICAgfCBMU0hJRlRcbiAgICB8IExQQVJFTlxuICAgIHwgTEVGVF9CUkFDS1xuICAgIHwgTEVGVF9CUkFDRVxuICAgIHwgSU5URVJST0dfTUFSS1xuICAgIHwgSUQgb2YgKFxuIyAxMCBcIklPL3BhcnNlci5tbHlcIlxuICAgICAgIChzdHJpbmcpXG4jIDM5IFwiSU8vcGFyc2VyLm1sXCJcbiAgKVxuICAgIHwgSEVBREVSXG4gICAgfCBIQVNIXG4gICAgfCBFWENMQU1fTUFSS1xuICAgIHwgRVFVQUxcbiAgICB8IEVRXG4gICAgfCBFT0xcbiAgICB8IEVPRlxuICAgIHwgRElWXG4gICAgfCBDT01NQVxuICAgIHwgQ09MT05cbiAgICB8IEJPUlxuICAgIHwgQk9PTCBvZiAoXG4jIDkgXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAoYm9vbClcbiMgNTUgXCJJTy9wYXJzZXIubWxcIlxuICApXG4gICAgfCBCQU5EXG4gICAgfCBBTkRcbiAgXG5lbmRcblxuaW5jbHVkZSBNZW5oaXJCYXNpY3NcblxubGV0IF9lUlIgPVxuICBNZW5oaXJCYXNpY3MuRXJyb3JcblxudHlwZSBfbWVuaGlyX2VudiA9IHtcbiAgX21lbmhpcl9sZXhlcjogTGV4aW5nLmxleGJ1ZiAtPiB0b2tlbjtcbiAgX21lbmhpcl9sZXhidWY6IExleGluZy5sZXhidWY7XG4gIF9tZW5oaXJfdG9rZW46IHRva2VuO1xuICBtdXRhYmxlIF9tZW5oaXJfZXJyb3I6IGJvb2xcbn1cblxuYW5kIF9tZW5oaXJfc3RhdGUgPSBcbiAgfCBNZW5oaXJTdGF0ZTExNFxuICB8IE1lbmhpclN0YXRlMTAyXG4gIHwgTWVuaGlyU3RhdGUxMDBcbiAgfCBNZW5oaXJTdGF0ZTk2XG4gIHwgTWVuaGlyU3RhdGU5MlxuICB8IE1lbmhpclN0YXRlODdcbiAgfCBNZW5oaXJTdGF0ZTc5XG4gIHwgTWVuaGlyU3RhdGU3NFxuICB8IE1lbmhpclN0YXRlNjlcbiAgfCBNZW5oaXJTdGF0ZTY3XG4gIHwgTWVuaGlyU3RhdGU2NlxuICB8IE1lbmhpclN0YXRlNjJcbiAgfCBNZW5oaXJTdGF0ZTU5XG4gIHwgTWVuaGlyU3RhdGU1OFxuICB8IE1lbmhpclN0YXRlNTNcbiAgfCBNZW5oaXJTdGF0ZTQ2XG4gIHwgTWVuaGlyU3RhdGU0NFxuICB8IE1lbmhpclN0YXRlNDJcbiAgfCBNZW5oaXJTdGF0ZTQwXG4gIHwgTWVuaGlyU3RhdGUzOFxuICB8IE1lbmhpclN0YXRlMzVcbiAgfCBNZW5oaXJTdGF0ZTMzXG4gIHwgTWVuaGlyU3RhdGUzMVxuICB8IE1lbmhpclN0YXRlMjlcbiAgfCBNZW5oaXJTdGF0ZTI3XG4gIHwgTWVuaGlyU3RhdGUyNVxuICB8IE1lbmhpclN0YXRlMjNcbiAgfCBNZW5oaXJTdGF0ZTIxXG4gIHwgTWVuaGlyU3RhdGUxOVxuICB8IE1lbmhpclN0YXRlMTdcbiAgfCBNZW5oaXJTdGF0ZTE1XG4gIHwgTWVuaGlyU3RhdGUxMlxuICB8IE1lbmhpclN0YXRlMTBcbiAgfCBNZW5oaXJTdGF0ZTlcbiAgfCBNZW5oaXJTdGF0ZThcbiAgfCBNZW5oaXJTdGF0ZTZcbiAgfCBNZW5oaXJTdGF0ZTVcbiAgfCBNZW5oaXJTdGF0ZTNcbiAgfCBNZW5oaXJTdGF0ZTFcbiAgfCBNZW5oaXJTdGF0ZTBcblxuIyAxIFwiSU8vcGFyc2VyLm1seVwiXG4gICBvcGVuIFBhcnNlcl9hc3QgXG4jIDExOCBcIklPL3BhcnNlci5tbFwiXG5cbiMgMiBcIklPL3BhcnNlci5tbHlcIlxuICAgb3BlbiBQcmVwcm9jZXNzIFxuIyAxMjIgXCJJTy9wYXJzZXIubWxcIlxuXG5sZXQgcmVjIF9tZW5oaXJfcnVuMTUgOiBfbWVuaGlyX2VudiAtPiAndHR2X3RhaWwgKiBfbWVuaGlyX3N0YXRlICogKFByZXByb2Nlc3MubWV0YV9leHByKSAtPiAndHR2X3JldHVybiA9XG4gIGZ1biBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIC0+XG4gICAgbGV0IF9tZW5oaXJfZW52ID0gX21lbmhpcl9kaXNjYXJkIF9tZW5oaXJfZW52IGluXG4gICAgbGV0IF90b2sgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX3Rva2VuIGluXG4gICAgbWF0Y2ggX3RvayB3aXRoXG4gICAgfCBFWENMQU1fTUFSSyAtPlxuICAgICAgICBfbWVuaGlyX3J1bjEyIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUxNVxuICAgIHwgSUQgX3YgLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMTUgX3YgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgfCBMUEFSRU4gLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMCBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMTVcbiAgICB8IE1JTlVTIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuOSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMTVcbiAgICB8IE5PVCAtPlxuICAgICAgICBfbWVuaGlyX3J1bjggX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTE1XG4gICAgfCBOVU1CRVIgX3YgLT5cbiAgICAgICAgX21lbmhpcl9ydW43IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUxNSBfdiBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BcbiAgICB8IFBMVVMgLT5cbiAgICAgICAgX21lbmhpcl9ydW42IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUxNVxuICAgIHwgXyAtPlxuICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMTVcblxuYW5kIF9tZW5oaXJfcnVuMTcgOiBfbWVuaGlyX2VudiAtPiAndHR2X3RhaWwgKiBfbWVuaGlyX3N0YXRlICogKFByZXByb2Nlc3MubWV0YV9leHByKSAtPiAndHR2X3JldHVybiA9XG4gIGZ1biBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIC0+XG4gICAgbGV0IF9tZW5oaXJfZW52ID0gX21lbmhpcl9kaXNjYXJkIF9tZW5oaXJfZW52IGluXG4gICAgbGV0IF90b2sgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX3Rva2VuIGluXG4gICAgbWF0Y2ggX3RvayB3aXRoXG4gICAgfCBFWENMQU1fTUFSSyAtPlxuICAgICAgICBfbWVuaGlyX3J1bjEyIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUxN1xuICAgIHwgSUQgX3YgLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMTcgX3YgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgfCBMUEFSRU4gLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMCBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMTdcbiAgICB8IE1JTlVTIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuOSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMTdcbiAgICB8IE5PVCAtPlxuICAgICAgICBfbWVuaGlyX3J1bjggX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTE3XG4gICAgfCBOVU1CRVIgX3YgLT5cbiAgICAgICAgX21lbmhpcl9ydW43IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUxNyBfdiBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BcbiAgICB8IFBMVVMgLT5cbiAgICAgICAgX21lbmhpcl9ydW42IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUxN1xuICAgIHwgXyAtPlxuICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMTdcblxuYW5kIF9tZW5oaXJfcnVuMTkgOiBfbWVuaGlyX2VudiAtPiAndHR2X3RhaWwgKiBfbWVuaGlyX3N0YXRlICogKFByZXByb2Nlc3MubWV0YV9leHByKSAtPiAndHR2X3JldHVybiA9XG4gIGZ1biBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIC0+XG4gICAgbGV0IF9tZW5oaXJfZW52ID0gX21lbmhpcl9kaXNjYXJkIF9tZW5oaXJfZW52IGluXG4gICAgbGV0IF90b2sgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX3Rva2VuIGluXG4gICAgbWF0Y2ggX3RvayB3aXRoXG4gICAgfCBFWENMQU1fTUFSSyAtPlxuICAgICAgICBfbWVuaGlyX3J1bjEyIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUxOVxuICAgIHwgSUQgX3YgLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMTkgX3YgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgfCBMUEFSRU4gLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMCBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMTlcbiAgICB8IE1JTlVTIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuOSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMTlcbiAgICB8IE5PVCAtPlxuICAgICAgICBfbWVuaGlyX3J1bjggX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTE5XG4gICAgfCBOVU1CRVIgX3YgLT5cbiAgICAgICAgX21lbmhpcl9ydW43IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUxOSBfdiBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BcbiAgICB8IFBMVVMgLT5cbiAgICAgICAgX21lbmhpcl9ydW42IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUxOVxuICAgIHwgXyAtPlxuICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMTlcblxuYW5kIF9tZW5oaXJfcnVuMjEgOiBfbWVuaGlyX2VudiAtPiAndHR2X3RhaWwgKiBfbWVuaGlyX3N0YXRlICogKFByZXByb2Nlc3MubWV0YV9leHByKSAtPiAndHR2X3JldHVybiA9XG4gIGZ1biBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIC0+XG4gICAgbGV0IF9tZW5oaXJfZW52ID0gX21lbmhpcl9kaXNjYXJkIF9tZW5oaXJfZW52IGluXG4gICAgbGV0IF90b2sgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX3Rva2VuIGluXG4gICAgbWF0Y2ggX3RvayB3aXRoXG4gICAgfCBFWENMQU1fTUFSSyAtPlxuICAgICAgICBfbWVuaGlyX3J1bjEyIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUyMVxuICAgIHwgSUQgX3YgLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMjEgX3YgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgfCBMUEFSRU4gLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMCBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMjFcbiAgICB8IE1JTlVTIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuOSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMjFcbiAgICB8IE5PVCAtPlxuICAgICAgICBfbWVuaGlyX3J1bjggX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTIxXG4gICAgfCBOVU1CRVIgX3YgLT5cbiAgICAgICAgX21lbmhpcl9ydW43IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUyMSBfdiBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BcbiAgICB8IFBMVVMgLT5cbiAgICAgICAgX21lbmhpcl9ydW42IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUyMVxuICAgIHwgXyAtPlxuICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMjFcblxuYW5kIF9tZW5oaXJfcnVuMzggOiBfbWVuaGlyX2VudiAtPiAndHR2X3RhaWwgKiBfbWVuaGlyX3N0YXRlICogKFByZXByb2Nlc3MubWV0YV9leHByKSAtPiAndHR2X3JldHVybiA9XG4gIGZ1biBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIC0+XG4gICAgbGV0IF9tZW5oaXJfZW52ID0gX21lbmhpcl9kaXNjYXJkIF9tZW5oaXJfZW52IGluXG4gICAgbGV0IF90b2sgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX3Rva2VuIGluXG4gICAgbWF0Y2ggX3RvayB3aXRoXG4gICAgfCBFWENMQU1fTUFSSyAtPlxuICAgICAgICBfbWVuaGlyX3J1bjEyIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUzOFxuICAgIHwgSUQgX3YgLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMzggX3YgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgfCBMUEFSRU4gLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMCBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMzhcbiAgICB8IE1JTlVTIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuOSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMzhcbiAgICB8IE5PVCAtPlxuICAgICAgICBfbWVuaGlyX3J1bjggX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTM4XG4gICAgfCBOVU1CRVIgX3YgLT5cbiAgICAgICAgX21lbmhpcl9ydW43IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUzOCBfdiBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BcbiAgICB8IFBMVVMgLT5cbiAgICAgICAgX21lbmhpcl9ydW42IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUzOFxuICAgIHwgXyAtPlxuICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMzhcblxuYW5kIF9tZW5oaXJfcnVuMjkgOiBfbWVuaGlyX2VudiAtPiAndHR2X3RhaWwgKiBfbWVuaGlyX3N0YXRlICogKFByZXByb2Nlc3MubWV0YV9leHByKSAtPiAndHR2X3JldHVybiA9XG4gIGZ1biBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIC0+XG4gICAgbGV0IF9tZW5oaXJfZW52ID0gX21lbmhpcl9kaXNjYXJkIF9tZW5oaXJfZW52IGluXG4gICAgbGV0IF90b2sgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX3Rva2VuIGluXG4gICAgbWF0Y2ggX3RvayB3aXRoXG4gICAgfCBFWENMQU1fTUFSSyAtPlxuICAgICAgICBfbWVuaGlyX3J1bjEyIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUyOVxuICAgIHwgSUQgX3YgLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMjkgX3YgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgfCBMUEFSRU4gLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMCBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMjlcbiAgICB8IE1JTlVTIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuOSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMjlcbiAgICB8IE5PVCAtPlxuICAgICAgICBfbWVuaGlyX3J1bjggX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTI5XG4gICAgfCBOVU1CRVIgX3YgLT5cbiAgICAgICAgX21lbmhpcl9ydW43IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUyOSBfdiBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BcbiAgICB8IFBMVVMgLT5cbiAgICAgICAgX21lbmhpcl9ydW42IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUyOVxuICAgIHwgXyAtPlxuICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMjlcblxuYW5kIF9tZW5oaXJfcnVuMjMgOiBfbWVuaGlyX2VudiAtPiAndHR2X3RhaWwgKiBfbWVuaGlyX3N0YXRlICogKFByZXByb2Nlc3MubWV0YV9leHByKSAtPiAndHR2X3JldHVybiA9XG4gIGZ1biBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIC0+XG4gICAgbGV0IF9tZW5oaXJfZW52ID0gX21lbmhpcl9kaXNjYXJkIF9tZW5oaXJfZW52IGluXG4gICAgbGV0IF90b2sgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX3Rva2VuIGluXG4gICAgbWF0Y2ggX3RvayB3aXRoXG4gICAgfCBFWENMQU1fTUFSSyAtPlxuICAgICAgICBfbWVuaGlyX3J1bjEyIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUyM1xuICAgIHwgSUQgX3YgLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMjMgX3YgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgfCBMUEFSRU4gLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMCBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMjNcbiAgICB8IE1JTlVTIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuOSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMjNcbiAgICB8IE5PVCAtPlxuICAgICAgICBfbWVuaGlyX3J1bjggX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTIzXG4gICAgfCBOVU1CRVIgX3YgLT5cbiAgICAgICAgX21lbmhpcl9ydW43IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUyMyBfdiBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BcbiAgICB8IFBMVVMgLT5cbiAgICAgICAgX21lbmhpcl9ydW42IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUyM1xuICAgIHwgXyAtPlxuICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMjNcblxuYW5kIF9tZW5oaXJfcnVuMjcgOiBfbWVuaGlyX2VudiAtPiAndHR2X3RhaWwgKiBfbWVuaGlyX3N0YXRlICogKFByZXByb2Nlc3MubWV0YV9leHByKSAtPiAndHR2X3JldHVybiA9XG4gIGZ1biBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIC0+XG4gICAgbGV0IF9tZW5oaXJfZW52ID0gX21lbmhpcl9kaXNjYXJkIF9tZW5oaXJfZW52IGluXG4gICAgbGV0IF90b2sgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX3Rva2VuIGluXG4gICAgbWF0Y2ggX3RvayB3aXRoXG4gICAgfCBFWENMQU1fTUFSSyAtPlxuICAgICAgICBfbWVuaGlyX3J1bjEyIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUyN1xuICAgIHwgSUQgX3YgLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMjcgX3YgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgfCBMUEFSRU4gLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMCBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMjdcbiAgICB8IE1JTlVTIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuOSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMjdcbiAgICB8IE5PVCAtPlxuICAgICAgICBfbWVuaGlyX3J1bjggX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTI3XG4gICAgfCBOVU1CRVIgX3YgLT5cbiAgICAgICAgX21lbmhpcl9ydW43IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUyNyBfdiBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BcbiAgICB8IFBMVVMgLT5cbiAgICAgICAgX21lbmhpcl9ydW42IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUyN1xuICAgIHwgXyAtPlxuICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMjdcblxuYW5kIF9tZW5oaXJfcnVuMzEgOiBfbWVuaGlyX2VudiAtPiAndHR2X3RhaWwgKiBfbWVuaGlyX3N0YXRlICogKFByZXByb2Nlc3MubWV0YV9leHByKSAtPiAndHR2X3JldHVybiA9XG4gIGZ1biBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIC0+XG4gICAgbGV0IF9tZW5oaXJfZW52ID0gX21lbmhpcl9kaXNjYXJkIF9tZW5oaXJfZW52IGluXG4gICAgbGV0IF90b2sgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX3Rva2VuIGluXG4gICAgbWF0Y2ggX3RvayB3aXRoXG4gICAgfCBFWENMQU1fTUFSSyAtPlxuICAgICAgICBfbWVuaGlyX3J1bjEyIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUzMVxuICAgIHwgSUQgX3YgLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMzEgX3YgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgfCBMUEFSRU4gLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMCBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMzFcbiAgICB8IE1JTlVTIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuOSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMzFcbiAgICB8IE5PVCAtPlxuICAgICAgICBfbWVuaGlyX3J1bjggX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTMxXG4gICAgfCBOVU1CRVIgX3YgLT5cbiAgICAgICAgX21lbmhpcl9ydW43IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUzMSBfdiBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BcbiAgICB8IFBMVVMgLT5cbiAgICAgICAgX21lbmhpcl9ydW42IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUzMVxuICAgIHwgXyAtPlxuICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMzFcblxuYW5kIF9tZW5oaXJfcnVuNDAgOiBfbWVuaGlyX2VudiAtPiAndHR2X3RhaWwgKiBfbWVuaGlyX3N0YXRlICogKFByZXByb2Nlc3MubWV0YV9leHByKSAtPiAndHR2X3JldHVybiA9XG4gIGZ1biBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIC0+XG4gICAgbGV0IF9tZW5oaXJfZW52ID0gX21lbmhpcl9kaXNjYXJkIF9tZW5oaXJfZW52IGluXG4gICAgbGV0IF90b2sgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX3Rva2VuIGluXG4gICAgbWF0Y2ggX3RvayB3aXRoXG4gICAgfCBFWENMQU1fTUFSSyAtPlxuICAgICAgICBfbWVuaGlyX3J1bjEyIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU0MFxuICAgIHwgSUQgX3YgLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNDAgX3YgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgfCBMUEFSRU4gLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMCBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNDBcbiAgICB8IE1JTlVTIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuOSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNDBcbiAgICB8IE5PVCAtPlxuICAgICAgICBfbWVuaGlyX3J1bjggX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTQwXG4gICAgfCBOVU1CRVIgX3YgLT5cbiAgICAgICAgX21lbmhpcl9ydW43IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU0MCBfdiBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BcbiAgICB8IFBMVVMgLT5cbiAgICAgICAgX21lbmhpcl9ydW42IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU0MFxuICAgIHwgXyAtPlxuICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNDBcblxuYW5kIF9tZW5oaXJfcnVuMzMgOiBfbWVuaGlyX2VudiAtPiAndHR2X3RhaWwgKiBfbWVuaGlyX3N0YXRlICogKFByZXByb2Nlc3MubWV0YV9leHByKSAtPiAndHR2X3JldHVybiA9XG4gIGZ1biBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIC0+XG4gICAgbGV0IF9tZW5oaXJfZW52ID0gX21lbmhpcl9kaXNjYXJkIF9tZW5oaXJfZW52IGluXG4gICAgbGV0IF90b2sgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX3Rva2VuIGluXG4gICAgbWF0Y2ggX3RvayB3aXRoXG4gICAgfCBFWENMQU1fTUFSSyAtPlxuICAgICAgICBfbWVuaGlyX3J1bjEyIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUzM1xuICAgIHwgSUQgX3YgLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMzMgX3YgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgfCBMUEFSRU4gLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMCBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMzNcbiAgICB8IE1JTlVTIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuOSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMzNcbiAgICB8IE5PVCAtPlxuICAgICAgICBfbWVuaGlyX3J1bjggX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTMzXG4gICAgfCBOVU1CRVIgX3YgLT5cbiAgICAgICAgX21lbmhpcl9ydW43IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUzMyBfdiBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BcbiAgICB8IFBMVVMgLT5cbiAgICAgICAgX21lbmhpcl9ydW42IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUzM1xuICAgIHwgXyAtPlxuICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMzNcblxuYW5kIF9tZW5oaXJfcnVuMjUgOiBfbWVuaGlyX2VudiAtPiAndHR2X3RhaWwgKiBfbWVuaGlyX3N0YXRlICogKFByZXByb2Nlc3MubWV0YV9leHByKSAtPiAndHR2X3JldHVybiA9XG4gIGZ1biBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIC0+XG4gICAgbGV0IF9tZW5oaXJfZW52ID0gX21lbmhpcl9kaXNjYXJkIF9tZW5oaXJfZW52IGluXG4gICAgbGV0IF90b2sgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX3Rva2VuIGluXG4gICAgbWF0Y2ggX3RvayB3aXRoXG4gICAgfCBFWENMQU1fTUFSSyAtPlxuICAgICAgICBfbWVuaGlyX3J1bjEyIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUyNVxuICAgIHwgSUQgX3YgLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMjUgX3YgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgfCBMUEFSRU4gLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMCBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMjVcbiAgICB8IE1JTlVTIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuOSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMjVcbiAgICB8IE5PVCAtPlxuICAgICAgICBfbWVuaGlyX3J1bjggX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTI1XG4gICAgfCBOVU1CRVIgX3YgLT5cbiAgICAgICAgX21lbmhpcl9ydW43IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUyNSBfdiBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BcbiAgICB8IFBMVVMgLT5cbiAgICAgICAgX21lbmhpcl9ydW42IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUyNVxuICAgIHwgXyAtPlxuICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMjVcblxuYW5kIF9tZW5oaXJfcnVuNDQgOiBfbWVuaGlyX2VudiAtPiAndHR2X3RhaWwgKiBfbWVuaGlyX3N0YXRlICogKFByZXByb2Nlc3MubWV0YV9leHByKSAtPiAndHR2X3JldHVybiA9XG4gIGZ1biBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIC0+XG4gICAgbGV0IF9tZW5oaXJfZW52ID0gX21lbmhpcl9kaXNjYXJkIF9tZW5oaXJfZW52IGluXG4gICAgbGV0IF90b2sgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX3Rva2VuIGluXG4gICAgbWF0Y2ggX3RvayB3aXRoXG4gICAgfCBFWENMQU1fTUFSSyAtPlxuICAgICAgICBfbWVuaGlyX3J1bjEyIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU0NFxuICAgIHwgSUQgX3YgLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNDQgX3YgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgfCBMUEFSRU4gLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMCBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNDRcbiAgICB8IE1JTlVTIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuOSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNDRcbiAgICB8IE5PVCAtPlxuICAgICAgICBfbWVuaGlyX3J1bjggX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTQ0XG4gICAgfCBOVU1CRVIgX3YgLT5cbiAgICAgICAgX21lbmhpcl9ydW43IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU0NCBfdiBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BcbiAgICB8IFBMVVMgLT5cbiAgICAgICAgX21lbmhpcl9ydW42IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU0NFxuICAgIHwgXyAtPlxuICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNDRcblxuYW5kIF9tZW5oaXJfcnVuNDYgOiBfbWVuaGlyX2VudiAtPiAndHR2X3RhaWwgKiBfbWVuaGlyX3N0YXRlICogKFByZXByb2Nlc3MubWV0YV9leHByKSAtPiAndHR2X3JldHVybiA9XG4gIGZ1biBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIC0+XG4gICAgbGV0IF9tZW5oaXJfZW52ID0gX21lbmhpcl9kaXNjYXJkIF9tZW5oaXJfZW52IGluXG4gICAgbGV0IF90b2sgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX3Rva2VuIGluXG4gICAgbWF0Y2ggX3RvayB3aXRoXG4gICAgfCBFWENMQU1fTUFSSyAtPlxuICAgICAgICBfbWVuaGlyX3J1bjEyIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU0NlxuICAgIHwgSUQgX3YgLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNDYgX3YgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgfCBMUEFSRU4gLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMCBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNDZcbiAgICB8IE1JTlVTIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuOSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNDZcbiAgICB8IE5PVCAtPlxuICAgICAgICBfbWVuaGlyX3J1bjggX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTQ2XG4gICAgfCBOVU1CRVIgX3YgLT5cbiAgICAgICAgX21lbmhpcl9ydW43IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU0NiBfdiBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BcbiAgICB8IFBMVVMgLT5cbiAgICAgICAgX21lbmhpcl9ydW42IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU0NlxuICAgIHwgXyAtPlxuICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNDZcblxuYW5kIF9tZW5oaXJfcnVuMzUgOiBfbWVuaGlyX2VudiAtPiAndHR2X3RhaWwgKiBfbWVuaGlyX3N0YXRlICogKFByZXByb2Nlc3MubWV0YV9leHByKSAtPiAndHR2X3JldHVybiA9XG4gIGZ1biBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIC0+XG4gICAgbGV0IF9tZW5oaXJfZW52ID0gX21lbmhpcl9kaXNjYXJkIF9tZW5oaXJfZW52IGluXG4gICAgbGV0IF90b2sgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX3Rva2VuIGluXG4gICAgbWF0Y2ggX3RvayB3aXRoXG4gICAgfCBFWENMQU1fTUFSSyAtPlxuICAgICAgICBfbWVuaGlyX3J1bjEyIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUzNVxuICAgIHwgSUQgX3YgLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMzUgX3YgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgfCBMUEFSRU4gLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMCBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMzVcbiAgICB8IE1JTlVTIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuOSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMzVcbiAgICB8IE5PVCAtPlxuICAgICAgICBfbWVuaGlyX3J1bjggX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTM1XG4gICAgfCBOVU1CRVIgX3YgLT5cbiAgICAgICAgX21lbmhpcl9ydW43IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUzNSBfdiBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BcbiAgICB8IFBMVVMgLT5cbiAgICAgICAgX21lbmhpcl9ydW42IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUzNVxuICAgIHwgXyAtPlxuICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMzVcblxuYW5kIF9tZW5oaXJfZ290b19vZmZzZXQgOiBfbWVuaGlyX2VudiAtPiAndHR2X3RhaWwgLT4gX21lbmhpcl9zdGF0ZSAtPiAoUGFyc2VyX2FzdC5vZmZzZXQpIC0+ICd0dHZfcmV0dXJuID1cbiAgZnVuIF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX21lbmhpcl9zIF92IC0+XG4gICAgbGV0IF9tZW5oaXJfc3RhY2sgPSAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zLCBfdikgaW5cbiAgICBtYXRjaCBfbWVuaGlyX3Mgd2l0aFxuICAgIHwgTWVuaGlyU3RhdGU1OCAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0ICgoKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcyksIChpZCA6IChcbiMgMTAgXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAoc3RyaW5nKVxuIyA0OTQgXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICApKSwgX3N0YXJ0cG9zX2lkXyksIF8sIChvIDogKFBhcnNlcl9hc3Qub2Zmc2V0KSkpID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgX3YgOiAoUGFyc2VyX2FzdC5hcmdzKSA9IFxuIyAxMjEgXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggT2Zmc2V0IChpZCwgbywgQXJtLlBvc3RJbmRleGVkKSApXG4jIDQ5OSBcIklPL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICBfbWVuaGlyX2dvdG9fYXJnIF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX21lbmhpcl9zIF92XG4gICAgfCBNZW5oaXJTdGF0ZTc0IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgIGxldCBfdG9rID0gX21lbmhpcl9lbnYuX21lbmhpcl90b2tlbiBpblxuICAgICAgICAobWF0Y2ggX3RvayB3aXRoXG4gICAgICAgIHwgUklHSFRfQlJBQ0sgLT5cbiAgICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgIGxldCBfbWVuaGlyX2VudiA9IF9tZW5oaXJfZGlzY2FyZCBfbWVuaGlyX2VudiBpblxuICAgICAgICAgICAgbGV0IF90b2sgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX3Rva2VuIGluXG4gICAgICAgICAgICAobWF0Y2ggX3RvayB3aXRoXG4gICAgICAgICAgICB8IEVYQ0xBTV9NQVJLIC0+XG4gICAgICAgICAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgICAgIGxldCBfbWVuaGlyX2VudiA9IF9tZW5oaXJfZGlzY2FyZCBfbWVuaGlyX2VudiBpblxuICAgICAgICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgICAgICBsZXQgKCgoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zKSwgKGlkIDogKFxuIyAxMCBcIklPL3BhcnNlci5tbHlcIlxuICAgICAgIChzdHJpbmcpXG4jIDUxOSBcIklPL3BhcnNlci5tbFwiXG4gICAgICAgICAgICAgICAgKSksIF9zdGFydHBvc19pZF8pLCBfLCAobyA6IChQYXJzZXJfYXN0Lm9mZnNldCkpKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgICAgICBsZXQgX3YgOiAoUGFyc2VyX2FzdC5hcmdzKSA9IFxuIyAxMTggXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBPZmZzZXQgKGlkLCBvLCBBcm0uUHJlSW5kZXhlZCkgKVxuIyA1MjQgXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgIF9tZW5oaXJfZ290b19hcmcgX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgX3ZcbiAgICAgICAgICAgIHwgQ09NTUEgfCBFT0YgfCBFT0wgfCBJTlRFUlJPR19NQVJLIC0+XG4gICAgICAgICAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgICAgIGxldCAoKChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MpLCAoaWQgOiAoXG4jIDEwIFwiSU8vcGFyc2VyLm1seVwiXG4gICAgICAgKHN0cmluZylcbiMgNTMyIFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgICAgICAgICApKSwgX3N0YXJ0cG9zX2lkXyksIF8sIChvIDogKFBhcnNlcl9hc3Qub2Zmc2V0KSkpID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgICAgIGxldCBfdiA6IChQYXJzZXJfYXN0LmFyZ3MpID0gXG4jIDExNSBcIklPL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBPZmZzZXQgKGlkLCBvLCBBcm0uT2Zmc2V0KSApXG4jIDUzNyBcIklPL3BhcnNlci5tbFwiXG4gICAgICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgICAgX21lbmhpcl9nb3RvX2FyZyBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyBfdlxuICAgICAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgICAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgICAgICBsZXQgKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgXykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBfbWVuaGlyX3MpXG4gICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgICAgICBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yIDwtIHRydWU7XG4gICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBsZXQgKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgXykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIF9tZW5oaXJfcylcbiAgICB8IF8gLT5cbiAgICAgICAgX21lbmhpcl9mYWlsICgpXG5cbmFuZCBfbWVuaGlyX2dvdG9fc2VwYXJhdGVkX25vbmVtcHR5X2xpc3RfQ09NTUFfYXJnXyA6IF9tZW5oaXJfZW52IC0+ICd0dHZfdGFpbCAtPiBfbWVuaGlyX3N0YXRlIC0+IChQYXJzZXJfYXN0LmFyZ3MgbGlzdCkgLT4gJ3R0dl9yZXR1cm4gPVxuICBmdW4gX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgX3YgLT5cbiAgICBtYXRjaCBfbWVuaGlyX3Mgd2l0aFxuICAgIHwgTWVuaGlyU3RhdGU1MyAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0ICh4IDogKFBhcnNlcl9hc3QuYXJncyBsaXN0KSkgPSBfdiBpblxuICAgICAgICBsZXQgX3YgOiAoUGFyc2VyX2FzdC5hcmdzIGxpc3QpID0gXG4jIDE0NCBcIjxzdGFuZGFyZC5tbHk+XCJcbiAgICAoIHggKVxuIyA1NjUgXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAgX21lbmhpcl9nb3RvX2xvcHRpb25fc2VwYXJhdGVkX25vbmVtcHR5X2xpc3RfQ09NTUFfYXJnX18gX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgX3ZcbiAgICB8IE1lbmhpclN0YXRlODcgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCAoeHMgOiAoUGFyc2VyX2FzdC5hcmdzIGxpc3QpKSA9IF92IGluXG4gICAgICAgIGxldCAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zLCAoeCA6IChQYXJzZXJfYXN0LmFyZ3MpKSkgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBfdiA6IChQYXJzZXJfYXN0LmFyZ3MgbGlzdCkgPSBcbiMgMjQzIFwiPHN0YW5kYXJkLm1seT5cIlxuICAgICggeCA6OiB4cyApXG4jIDU3NiBcIklPL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICBfbWVuaGlyX2dvdG9fc2VwYXJhdGVkX25vbmVtcHR5X2xpc3RfQ09NTUFfYXJnXyBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyBfdlxuICAgIHwgXyAtPlxuICAgICAgICBfbWVuaGlyX2ZhaWwgKClcblxuYW5kIF9tZW5oaXJfZ290b19tZXRhX2V4cHIgOiBfbWVuaGlyX2VudiAtPiAndHR2X3RhaWwgLT4gX21lbmhpcl9zdGF0ZSAtPiAoUHJlcHJvY2Vzcy5tZXRhX2V4cHIpIC0+ICd0dHZfcmV0dXJuID1cbiAgZnVuIF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX21lbmhpcl9zIF92IC0+XG4gICAgbGV0IF9tZW5oaXJfc3RhY2sgPSAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zLCBfdikgaW5cbiAgICBtYXRjaCBfbWVuaGlyX3Mgd2l0aFxuICAgIHwgTWVuaGlyU3RhdGUxMiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0ICgoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zKSwgXywgKGUgOiAoUHJlcHJvY2Vzcy5tZXRhX2V4cHIpKSkgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBfdiA6IChQcmVwcm9jZXNzLm1ldGFfZXhwcikgPSBcbiMgODAgXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggTVVuYXJ5IChPQk5vdCwgZSkgKVxuIyA1OTMgXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAgX21lbmhpcl9nb3RvX21ldGFfZXhwciBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyBfdlxuICAgIHwgTWVuaGlyU3RhdGUxMCAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGFzc2VydCAobm90IF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IpO1xuICAgICAgICBsZXQgX3RvayA9IF9tZW5oaXJfZW52Ll9tZW5oaXJfdG9rZW4gaW5cbiAgICAgICAgKG1hdGNoIF90b2sgd2l0aFxuICAgICAgICB8IEFORCAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4zNSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgQkFORCAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW40NiBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgQk9SIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjQ0IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBESVYgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMjUgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IEVRIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjMzIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBJTlRFUlJPR19NQVJLIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjQwIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBMU0hJRlQgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMzEgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IE1JTlVTIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjI3IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBNT0QgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMjMgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IE5FUSAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4yOSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgT1IgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMzggX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IFBMVVMgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMjEgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IFJQQVJFTiAtPlxuICAgICAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgbGV0IF9tZW5oaXJfZW52ID0gX21lbmhpcl9kaXNjYXJkIF9tZW5oaXJfZW52IGluXG4gICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBsZXQgKChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MpLCBfLCAoZSA6IChQcmVwcm9jZXNzLm1ldGFfZXhwcikpKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgIGxldCBfdiA6IChQcmVwcm9jZXNzLm1ldGFfZXhwcikgPSBcbiMgNjIgXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBlIClcbiMgNjMzIFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgICAgICBpblxuICAgICAgICAgICAgX21lbmhpcl9nb3RvX21ldGFfZXhwciBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyBfdlxuICAgICAgICB8IFJTSElGVCAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4xOSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgVElNRVMgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMTcgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IFhPUiAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4xNSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgICAgICBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yIDwtIHRydWU7XG4gICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBsZXQgKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgXykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIF9tZW5oaXJfcylcbiAgICB8IE1lbmhpclN0YXRlMTUgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgbGV0IF90b2sgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX3Rva2VuIGluXG4gICAgICAgIChtYXRjaCBfdG9rIHdpdGhcbiAgICAgICAgfCBBTkQgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMzUgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IERJViAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4yNSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgRVEgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMzMgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IExTSElGVCAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4zMSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgTUlOVVMgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMjcgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IE1PRCAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4yMyBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgTkVRIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjI5IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBQTFVTIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjIxIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBSU0hJRlQgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMTkgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IFRJTUVTIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjE3IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBCQU5EIHwgQk9SIHwgQ09MT04gfCBFT0wgfCBJTlRFUlJPR19NQVJLIHwgT1IgfCBSSUdIVF9CUkFDRSB8IFJQQVJFTiB8IFhPUiAtPlxuICAgICAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgbGV0ICgoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zLCAoZTEgOiAoUHJlcHJvY2Vzcy5tZXRhX2V4cHIpKSksIF8sIChlMiA6IChQcmVwcm9jZXNzLm1ldGFfZXhwcikpKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgIGxldCBfdiA6IChQcmVwcm9jZXNzLm1ldGFfZXhwcikgPSBcbiMgNjkgXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBNQmluYXJ5IChPWG9yLCBlMSwgZTIpIClcbiMgNjc5IFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgICAgICBpblxuICAgICAgICAgICAgX21lbmhpcl9nb3RvX21ldGFfZXhwciBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyBfdlxuICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgIGFzc2VydCAobm90IF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IpO1xuICAgICAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgbGV0IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIF8pID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBfbWVuaGlyX3MpXG4gICAgfCBNZW5oaXJTdGF0ZTE3IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgKChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIChlMSA6IChQcmVwcm9jZXNzLm1ldGFfZXhwcikpKSwgXywgKGUyIDogKFByZXByb2Nlc3MubWV0YV9leHByKSkpID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgX3YgOiAoUHJlcHJvY2Vzcy5tZXRhX2V4cHIpID0gXG4jIDY1IFwiSU8vcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBNQmluYXJ5IChPTXVsLCBlMSwgZTIpIClcbiMgNjk1IFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIF9tZW5oaXJfZ290b19tZXRhX2V4cHIgX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgX3ZcbiAgICB8IE1lbmhpclN0YXRlMTkgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgbGV0IF90b2sgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX3Rva2VuIGluXG4gICAgICAgIChtYXRjaCBfdG9rIHdpdGhcbiAgICAgICAgfCBESVYgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMjUgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IE1JTlVTIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjI3IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBNT0QgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMjMgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IFBMVVMgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMjEgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IFRJTUVTIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjE3IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBBTkQgfCBCQU5EIHwgQk9SIHwgQ09MT04gfCBFT0wgfCBFUSB8IElOVEVSUk9HX01BUksgfCBMU0hJRlQgfCBORVEgfCBPUiB8IFJJR0hUX0JSQUNFIHwgUlBBUkVOIHwgUlNISUZUIHwgWE9SIC0+XG4gICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBsZXQgKChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIChlMSA6IChQcmVwcm9jZXNzLm1ldGFfZXhwcikpKSwgXywgKGUyIDogKFByZXByb2Nlc3MubWV0YV9leHByKSkpID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgbGV0IF92IDogKFByZXByb2Nlc3MubWV0YV9leHByKSA9IFxuIyA3NiBcIklPL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIE1CaW5hcnkgKE9SU2hpZnQsIGUxLCBlMikgKVxuIyA3MTkgXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICAgICAgIGluXG4gICAgICAgICAgICBfbWVuaGlyX2dvdG9fbWV0YV9leHByIF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX21lbmhpcl9zIF92XG4gICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgICAgICBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yIDwtIHRydWU7XG4gICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBsZXQgKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgXykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIF9tZW5oaXJfcylcbiAgICB8IE1lbmhpclN0YXRlMjEgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgbGV0IF90b2sgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX3Rva2VuIGluXG4gICAgICAgIChtYXRjaCBfdG9rIHdpdGhcbiAgICAgICAgfCBESVYgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMjUgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IE1PRCAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4yMyBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgVElNRVMgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMTcgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IEFORCB8IEJBTkQgfCBCT1IgfCBDT0xPTiB8IEVPTCB8IEVRIHwgSU5URVJST0dfTUFSSyB8IExTSElGVCB8IE1JTlVTIHwgTkVRIHwgT1IgfCBQTFVTIHwgUklHSFRfQlJBQ0UgfCBSUEFSRU4gfCBSU0hJRlQgfCBYT1IgLT5cbiAgICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgIGxldCAoKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgKGUxIDogKFByZXByb2Nlc3MubWV0YV9leHByKSkpLCBfLCAoZTIgOiAoUHJlcHJvY2Vzcy5tZXRhX2V4cHIpKSkgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBsZXQgX3YgOiAoUHJlcHJvY2Vzcy5tZXRhX2V4cHIpID0gXG4jIDYzIFwiSU8vcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIE1CaW5hcnkgKE9BZGQsIGUxLCBlMikgKVxuIyA3NDUgXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICAgICAgIGluXG4gICAgICAgICAgICBfbWVuaGlyX2dvdG9fbWV0YV9leHByIF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX21lbmhpcl9zIF92XG4gICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgICAgICBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yIDwtIHRydWU7XG4gICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBsZXQgKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgXykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIF9tZW5oaXJfcylcbiAgICB8IE1lbmhpclN0YXRlMjMgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCAoKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgKGUxIDogKFByZXByb2Nlc3MubWV0YV9leHByKSkpLCBfLCAoZTIgOiAoUHJlcHJvY2Vzcy5tZXRhX2V4cHIpKSkgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBfdiA6IChQcmVwcm9jZXNzLm1ldGFfZXhwcikgPSBcbiMgNjcgXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBNQmluYXJ5IChPTW9kLCBlMSwgZTIpIClcbiMgNzYxIFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIF9tZW5oaXJfZ290b19tZXRhX2V4cHIgX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgX3ZcbiAgICB8IE1lbmhpclN0YXRlMjUgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCAoKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgKGUxIDogKFByZXByb2Nlc3MubWV0YV9leHByKSkpLCBfLCAoZTIgOiAoUHJlcHJvY2Vzcy5tZXRhX2V4cHIpKSkgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBfdiA6IChQcmVwcm9jZXNzLm1ldGFfZXhwcikgPSBcbiMgNjYgXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBNQmluYXJ5IChPRGl2LCBlMSwgZTIpIClcbiMgNzcxIFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIF9tZW5oaXJfZ290b19tZXRhX2V4cHIgX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgX3ZcbiAgICB8IE1lbmhpclN0YXRlMjcgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgbGV0IF90b2sgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX3Rva2VuIGluXG4gICAgICAgIChtYXRjaCBfdG9rIHdpdGhcbiAgICAgICAgfCBESVYgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMjUgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IE1PRCAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4yMyBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgVElNRVMgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMTcgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IEFORCB8IEJBTkQgfCBCT1IgfCBDT0xPTiB8IEVPTCB8IEVRIHwgSU5URVJST0dfTUFSSyB8IExTSElGVCB8IE1JTlVTIHwgTkVRIHwgT1IgfCBQTFVTIHwgUklHSFRfQlJBQ0UgfCBSUEFSRU4gfCBSU0hJRlQgfCBYT1IgLT5cbiAgICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgIGxldCAoKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgKGUxIDogKFByZXByb2Nlc3MubWV0YV9leHByKSkpLCBfLCAoZTIgOiAoUHJlcHJvY2Vzcy5tZXRhX2V4cHIpKSkgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBsZXQgX3YgOiAoUHJlcHJvY2Vzcy5tZXRhX2V4cHIpID0gXG4jIDY0IFwiSU8vcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBNQmluYXJ5IChPU3ViLCBlMSwgZTIpIClcbiMgNzkxIFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgICAgICBpblxuICAgICAgICAgICAgX21lbmhpcl9nb3RvX21ldGFfZXhwciBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyBfdlxuICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgIGFzc2VydCAobm90IF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IpO1xuICAgICAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgbGV0IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIF8pID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBfbWVuaGlyX3MpXG4gICAgfCBNZW5oaXJTdGF0ZTI5IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgIGxldCBfdG9rID0gX21lbmhpcl9lbnYuX21lbmhpcl90b2tlbiBpblxuICAgICAgICAobWF0Y2ggX3RvayB3aXRoXG4gICAgICAgIHwgRElWIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjI1IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBMU0hJRlQgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMzEgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IE1JTlVTIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjI3IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBNT0QgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMjMgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IFBMVVMgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMjEgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IFJTSElGVCAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4xOSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgVElNRVMgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMTcgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IEFORCB8IEJBTkQgfCBCT1IgfCBDT0xPTiB8IEVPTCB8IEVRIHwgSU5URVJST0dfTUFSSyB8IE5FUSB8IE9SIHwgUklHSFRfQlJBQ0UgfCBSUEFSRU4gfCBYT1IgLT5cbiAgICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgIGxldCAoKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgKGUxIDogKFByZXByb2Nlc3MubWV0YV9leHByKSkpLCBfLCAoZTIgOiAoUHJlcHJvY2Vzcy5tZXRhX2V4cHIpKSkgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBsZXQgX3YgOiAoUHJlcHJvY2Vzcy5tZXRhX2V4cHIpID0gXG4jIDc0IFwiSU8vcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggTUJpbmFyeSAoT05lcSwgZTEsIGUyKSApXG4jIDgyNSBcIklPL3BhcnNlci5tbFwiXG4gICAgICAgICAgICAgaW5cbiAgICAgICAgICAgIF9tZW5oaXJfZ290b19tZXRhX2V4cHIgX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgX3ZcbiAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgICAgIF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IgPC0gdHJ1ZTtcbiAgICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgIGxldCAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zLCBfKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgX21lbmhpcl9zKVxuICAgIHwgTWVuaGlyU3RhdGUzMSAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGFzc2VydCAobm90IF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IpO1xuICAgICAgICBsZXQgX3RvayA9IF9tZW5oaXJfZW52Ll9tZW5oaXJfdG9rZW4gaW5cbiAgICAgICAgKG1hdGNoIF90b2sgd2l0aFxuICAgICAgICB8IERJViAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4yNSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgTUlOVVMgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMjcgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IE1PRCAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4yMyBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgUExVUyAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4yMSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgVElNRVMgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMTcgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IEFORCB8IEJBTkQgfCBCT1IgfCBDT0xPTiB8IEVPTCB8IEVRIHwgSU5URVJST0dfTUFSSyB8IExTSElGVCB8IE5FUSB8IE9SIHwgUklHSFRfQlJBQ0UgfCBSUEFSRU4gfCBSU0hJRlQgfCBYT1IgLT5cbiAgICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgIGxldCAoKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgKGUxIDogKFByZXByb2Nlc3MubWV0YV9leHByKSkpLCBfLCAoZTIgOiAoUHJlcHJvY2Vzcy5tZXRhX2V4cHIpKSkgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBsZXQgX3YgOiAoUHJlcHJvY2Vzcy5tZXRhX2V4cHIpID0gXG4jIDc1IFwiSU8vcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggTUJpbmFyeSAoT0xTaGlmdCwgZTEsIGUyKSApXG4jIDg1NSBcIklPL3BhcnNlci5tbFwiXG4gICAgICAgICAgICAgaW5cbiAgICAgICAgICAgIF9tZW5oaXJfZ290b19tZXRhX2V4cHIgX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgX3ZcbiAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgICAgIF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IgPC0gdHJ1ZTtcbiAgICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgIGxldCAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zLCBfKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgX21lbmhpcl9zKVxuICAgIHwgTWVuaGlyU3RhdGUzMyAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGFzc2VydCAobm90IF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IpO1xuICAgICAgICBsZXQgX3RvayA9IF9tZW5oaXJfZW52Ll9tZW5oaXJfdG9rZW4gaW5cbiAgICAgICAgKG1hdGNoIF90b2sgd2l0aFxuICAgICAgICB8IERJViAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4yNSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgTFNISUZUIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjMxIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBNSU5VUyAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4yNyBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgTU9EIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjIzIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBQTFVTIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjIxIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBSU0hJRlQgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMTkgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IFRJTUVTIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjE3IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBBTkQgfCBCQU5EIHwgQk9SIHwgQ09MT04gfCBFT0wgfCBFUSB8IElOVEVSUk9HX01BUksgfCBORVEgfCBPUiB8IFJJR0hUX0JSQUNFIHwgUlBBUkVOIHwgWE9SIC0+XG4gICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBsZXQgKChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIChlMSA6IChQcmVwcm9jZXNzLm1ldGFfZXhwcikpKSwgXywgKGUyIDogKFByZXByb2Nlc3MubWV0YV9leHByKSkpID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgbGV0IF92IDogKFByZXByb2Nlc3MubWV0YV9leHByKSA9IFxuIyA3MyBcIklPL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggTUJpbmFyeSAoT0VxLCBlMSwgZTIpIClcbiMgODg5IFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgICAgICBpblxuICAgICAgICAgICAgX21lbmhpcl9nb3RvX21ldGFfZXhwciBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyBfdlxuICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgIGFzc2VydCAobm90IF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IpO1xuICAgICAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgbGV0IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIF8pID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBfbWVuaGlyX3MpXG4gICAgfCBNZW5oaXJTdGF0ZTM1IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgIGxldCBfdG9rID0gX21lbmhpcl9lbnYuX21lbmhpcl90b2tlbiBpblxuICAgICAgICAobWF0Y2ggX3RvayB3aXRoXG4gICAgICAgIHwgRElWIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjI1IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBFUSAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4zMyBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgTFNISUZUIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjMxIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBNSU5VUyAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4yNyBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgTU9EIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjIzIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBORVEgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMjkgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IFBMVVMgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMjEgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IFJTSElGVCAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4xOSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgVElNRVMgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMTcgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IEFORCB8IEJBTkQgfCBCT1IgfCBDT0xPTiB8IEVPTCB8IElOVEVSUk9HX01BUksgfCBPUiB8IFJJR0hUX0JSQUNFIHwgUlBBUkVOIHwgWE9SIC0+XG4gICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBsZXQgKChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIChlMSA6IChQcmVwcm9jZXNzLm1ldGFfZXhwcikpKSwgXywgKGUyIDogKFByZXByb2Nlc3MubWV0YV9leHByKSkpID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgbGV0IF92IDogKFByZXByb2Nlc3MubWV0YV9leHByKSA9IFxuIyA2OCBcIklPL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIE1CaW5hcnkgKE9BbmQsIGUxLCBlMikgKVxuIyA5MjcgXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICAgICAgIGluXG4gICAgICAgICAgICBfbWVuaGlyX2dvdG9fbWV0YV9leHByIF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX21lbmhpcl9zIF92XG4gICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgICAgICBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yIDwtIHRydWU7XG4gICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBsZXQgKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgXykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIF9tZW5oaXJfcylcbiAgICB8IE1lbmhpclN0YXRlMzggLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgbGV0IF90b2sgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX3Rva2VuIGluXG4gICAgICAgIChtYXRjaCBfdG9rIHdpdGhcbiAgICAgICAgfCBBTkQgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMzUgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IERJViAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4yNSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgRVEgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMzMgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IExTSElGVCAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4zMSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgTUlOVVMgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMjcgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IE1PRCAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4yMyBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgTkVRIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjI5IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBQTFVTIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjIxIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBSU0hJRlQgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMTkgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IFRJTUVTIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjE3IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBYT1IgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMTUgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IEJBTkQgfCBCT1IgfCBDT0xPTiB8IEVPTCB8IElOVEVSUk9HX01BUksgfCBPUiB8IFJJR0hUX0JSQUNFIHwgUlBBUkVOIC0+XG4gICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBsZXQgKChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIChlMSA6IChQcmVwcm9jZXNzLm1ldGFfZXhwcikpKSwgXywgKGUyIDogKFByZXByb2Nlc3MubWV0YV9leHByKSkpID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgbGV0IF92IDogKFByZXByb2Nlc3MubWV0YV9leHByKSA9IFxuIyA3MCBcIklPL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggTUJpbmFyeSAoT09yLCBlMSwgZTIpIClcbiMgOTY5IFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgICAgICBpblxuICAgICAgICAgICAgX21lbmhpcl9nb3RvX21ldGFfZXhwciBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyBfdlxuICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgIGFzc2VydCAobm90IF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IpO1xuICAgICAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgbGV0IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIF8pID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBfbWVuaGlyX3MpXG4gICAgfCBNZW5oaXJTdGF0ZTQwIC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgIGxldCBfdG9rID0gX21lbmhpcl9lbnYuX21lbmhpcl90b2tlbiBpblxuICAgICAgICAobWF0Y2ggX3RvayB3aXRoXG4gICAgICAgIHwgQU5EIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjM1IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBCQU5EIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjQ2IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBCT1IgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuNDQgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IENPTE9OIC0+XG4gICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBsZXQgX21lbmhpcl9lbnYgPSBfbWVuaGlyX2Rpc2NhcmQgX21lbmhpcl9lbnYgaW5cbiAgICAgICAgICAgIGxldCBfdG9rID0gX21lbmhpcl9lbnYuX21lbmhpcl90b2tlbiBpblxuICAgICAgICAgICAgKG1hdGNoIF90b2sgd2l0aFxuICAgICAgICAgICAgfCBFWENMQU1fTUFSSyAtPlxuICAgICAgICAgICAgICAgIF9tZW5oaXJfcnVuMTIgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTQyXG4gICAgICAgICAgICB8IElEIF92IC0+XG4gICAgICAgICAgICAgICAgX21lbmhpcl9ydW4xMSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNDIgX3YgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgICAgICAgICB8IExQQVJFTiAtPlxuICAgICAgICAgICAgICAgIF9tZW5oaXJfcnVuMTAgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTQyXG4gICAgICAgICAgICB8IE1JTlVTIC0+XG4gICAgICAgICAgICAgICAgX21lbmhpcl9ydW45IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU0MlxuICAgICAgICAgICAgfCBOT1QgLT5cbiAgICAgICAgICAgICAgICBfbWVuaGlyX3J1bjggX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTQyXG4gICAgICAgICAgICB8IE5VTUJFUiBfdiAtPlxuICAgICAgICAgICAgICAgIF9tZW5oaXJfcnVuNyBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNDIgX3YgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgICAgICAgICB8IFBMVVMgLT5cbiAgICAgICAgICAgICAgICBfbWVuaGlyX3J1bjYgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTQyXG4gICAgICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgICAgICAgICBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yIDwtIHRydWU7XG4gICAgICAgICAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTQyKVxuICAgICAgICB8IERJViAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4yNSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgRVEgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMzMgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IElOVEVSUk9HX01BUksgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuNDAgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IExTSElGVCAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4zMSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgTUlOVVMgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMjcgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IE1PRCAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4yMyBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgTkVRIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjI5IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBPUiAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4zOCBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgUExVUyAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4yMSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgUlNISUZUIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjE5IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBUSU1FUyAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4xNyBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgWE9SIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjE1IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgICAgIF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IgPC0gdHJ1ZTtcbiAgICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgIGxldCAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zLCBfKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgX21lbmhpcl9zKVxuICAgIHwgTWVuaGlyU3RhdGU0MiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGFzc2VydCAobm90IF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IpO1xuICAgICAgICBsZXQgX3RvayA9IF9tZW5oaXJfZW52Ll9tZW5oaXJfdG9rZW4gaW5cbiAgICAgICAgKG1hdGNoIF90b2sgd2l0aFxuICAgICAgICB8IEFORCAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4zNSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgQkFORCAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW40NiBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgQk9SIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjQ0IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBESVYgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMjUgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IEVRIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjMzIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBJTlRFUlJPR19NQVJLIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjQwIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBMU0hJRlQgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMzEgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IE1JTlVTIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjI3IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBNT0QgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMjMgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IE5FUSAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4yOSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgT1IgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMzggX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IFBMVVMgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMjEgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IFJTSElGVCAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4xOSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgVElNRVMgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMTcgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IFhPUiAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4xNSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgQ09MT04gfCBFT0wgfCBSSUdIVF9CUkFDRSB8IFJQQVJFTiAtPlxuICAgICAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgbGV0ICgoKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgKGUwIDogKFByZXByb2Nlc3MubWV0YV9leHByKSkpLCBfLCAoZTEgOiAoUHJlcHJvY2Vzcy5tZXRhX2V4cHIpKSksIF8sIChlMiA6IChQcmVwcm9jZXNzLm1ldGFfZXhwcikpKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgIGxldCBfdiA6IChQcmVwcm9jZXNzLm1ldGFfZXhwcikgPSBcbiMgODIgXCJJTy9wYXJzZXIubWx5XCJcbiAgKCBNQ29uZCAoZTAsIGUxLCBlMikgKVxuIyAxMDgzIFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgICAgICBpblxuICAgICAgICAgICAgX21lbmhpcl9nb3RvX21ldGFfZXhwciBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyBfdlxuICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgIGFzc2VydCAobm90IF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IpO1xuICAgICAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgbGV0IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIF8pID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBfbWVuaGlyX3MpXG4gICAgfCBNZW5oaXJTdGF0ZTQ0IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgIGxldCBfdG9rID0gX21lbmhpcl9lbnYuX21lbmhpcl90b2tlbiBpblxuICAgICAgICAobWF0Y2ggX3RvayB3aXRoXG4gICAgICAgIHwgQU5EIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjM1IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBCQU5EIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjQ2IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBESVYgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMjUgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IEVRIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjMzIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBMU0hJRlQgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMzEgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IE1JTlVTIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjI3IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBNT0QgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMjMgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IE5FUSAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4yOSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgT1IgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMzggX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IFBMVVMgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMjEgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IFJTSElGVCAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4xOSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgVElNRVMgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMTcgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IFhPUiAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4xNSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgQk9SIHwgQ09MT04gfCBFT0wgfCBJTlRFUlJPR19NQVJLIHwgUklHSFRfQlJBQ0UgfCBSUEFSRU4gLT5cbiAgICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgIGxldCAoKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgKGUxIDogKFByZXByb2Nlc3MubWV0YV9leHByKSkpLCBfLCAoZTIgOiAoUHJlcHJvY2Vzcy5tZXRhX2V4cHIpKSkgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBsZXQgX3YgOiAoUHJlcHJvY2Vzcy5tZXRhX2V4cHIpID0gXG4jIDcxIFwiSU8vcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggTUJpbmFyeSAoT0JPciwgZTEsIGUyKSApXG4jIDExMjkgXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICAgICAgIGluXG4gICAgICAgICAgICBfbWVuaGlyX2dvdG9fbWV0YV9leHByIF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX21lbmhpcl9zIF92XG4gICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgICAgICBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yIDwtIHRydWU7XG4gICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBsZXQgKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgXykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIF9tZW5oaXJfcylcbiAgICB8IE1lbmhpclN0YXRlNDYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgbGV0IF90b2sgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX3Rva2VuIGluXG4gICAgICAgIChtYXRjaCBfdG9rIHdpdGhcbiAgICAgICAgfCBBTkQgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMzUgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IERJViAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4yNSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgRVEgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMzMgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IExTSElGVCAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4zMSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgTUlOVVMgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMjcgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IE1PRCAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4yMyBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgTkVRIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjI5IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBPUiAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4zOCBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgUExVUyAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4yMSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgUlNISUZUIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjE5IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBUSU1FUyAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4xNyBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgWE9SIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjE1IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBCQU5EIHwgQk9SIHwgQ09MT04gfCBFT0wgfCBJTlRFUlJPR19NQVJLIHwgUklHSFRfQlJBQ0UgfCBSUEFSRU4gLT5cbiAgICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgIGxldCAoKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgKGUxIDogKFByZXByb2Nlc3MubWV0YV9leHByKSkpLCBfLCAoZTIgOiAoUHJlcHJvY2Vzcy5tZXRhX2V4cHIpKSkgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBsZXQgX3YgOiAoUHJlcHJvY2Vzcy5tZXRhX2V4cHIpID0gXG4jIDcyIFwiSU8vcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIE1CaW5hcnkgKE9CQW5kLCBlMSwgZTIpIClcbiMgMTE3MyBcIklPL3BhcnNlci5tbFwiXG4gICAgICAgICAgICAgaW5cbiAgICAgICAgICAgIF9tZW5oaXJfZ290b19tZXRhX2V4cHIgX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgX3ZcbiAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgICAgIF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IgPC0gdHJ1ZTtcbiAgICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgIGxldCAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zLCBfKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgX21lbmhpcl9zKVxuICAgIHwgTWVuaGlyU3RhdGU5IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgKChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MpLCBfLCAoZSA6IChQcmVwcm9jZXNzLm1ldGFfZXhwcikpKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF92IDogKFByZXByb2Nlc3MubWV0YV9leHByKSA9IFxuIyA3OCBcIklPL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggTVVuYXJ5IChPTmVnLCBlKSApXG4jIDExODkgXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAgX21lbmhpcl9nb3RvX21ldGFfZXhwciBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyBfdlxuICAgIHwgTWVuaGlyU3RhdGU4IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgKChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MpLCBfLCAoZSA6IChQcmVwcm9jZXNzLm1ldGFfZXhwcikpKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF92IDogKFByZXByb2Nlc3MubWV0YV9leHByKSA9IFxuIyA3OSBcIklPL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICggTVVuYXJ5IChPTm90LCBlKSApXG4jIDExOTkgXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAgX21lbmhpcl9nb3RvX21ldGFfZXhwciBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyBfdlxuICAgIHwgTWVuaGlyU3RhdGU2IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgKChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MpLCBfLCAoZSA6IChQcmVwcm9jZXNzLm1ldGFfZXhwcikpKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF92IDogKFByZXByb2Nlc3MubWV0YV9leHByKSA9IFxuIyA3NyBcIklPL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIE1VbmFyeSAoT0lkLCBlKSApXG4jIDEyMDkgXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAgX21lbmhpcl9nb3RvX21ldGFfZXhwciBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyBfdlxuICAgIHwgTWVuaGlyU3RhdGU1IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgIGxldCBfdG9rID0gX21lbmhpcl9lbnYuX21lbmhpcl90b2tlbiBpblxuICAgICAgICAobWF0Y2ggX3RvayB3aXRoXG4gICAgICAgIHwgQU5EIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjM1IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBCQU5EIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjQ2IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBCT1IgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuNDQgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IERJViAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4yNSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgRVEgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMzMgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IElOVEVSUk9HX01BUksgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuNDAgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IExTSElGVCAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4zMSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgTUlOVVMgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMjcgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IE1PRCAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4yMyBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgTkVRIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjI5IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBPUiAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4zOCBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgUExVUyAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4yMSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgUklHSFRfQlJBQ0UgLT5cbiAgICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgIGxldCBfbWVuaGlyX2VudiA9IF9tZW5oaXJfZGlzY2FyZCBfbWVuaGlyX2VudiBpblxuICAgICAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgbGV0ICgoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zLCBfc3RhcnRwb3NfXzFfKSwgXywgKGUgOiAoUHJlcHJvY2Vzcy5tZXRhX2V4cHIpKSkgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX18xXyBpblxuICAgICAgICAgICAgbGV0IF92IDogKFBhcnNlcl9hc3QudW5wcm9jZXNzZWRfaW50MzIpID0gXG4jIDEzNCBcIklPL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggTWV0YUV4cHIgZSApXG4jIDEyNTAgXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICAgICAgIGluXG4gICAgICAgICAgICBfbWVuaGlyX2dvdG9fbnVtYmVyIF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX21lbmhpcl9zIF92IF9zdGFydHBvc1xuICAgICAgICB8IFJTSElGVCAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4xOSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgVElNRVMgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMTcgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IFhPUiAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4xNSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgICAgICBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yIDwtIHRydWU7XG4gICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBsZXQgKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgXykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIF9tZW5oaXJfcylcbiAgICB8IE1lbmhpclN0YXRlMTAwIC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgIGxldCBfdG9rID0gX21lbmhpcl9lbnYuX21lbmhpcl90b2tlbiBpblxuICAgICAgICAobWF0Y2ggX3RvayB3aXRoXG4gICAgICAgIHwgQU5EIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjM1IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBCQU5EIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjQ2IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBCT1IgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuNDQgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IERJViAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4yNSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgRVEgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMzMgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IElOVEVSUk9HX01BUksgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuNDAgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IExTSElGVCAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4zMSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgTUlOVVMgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMjcgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IE1PRCAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4yMyBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgTkVRIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjI5IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBPUiAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4zOCBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgUExVUyAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4yMSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgUlNISUZUIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjE5IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBUSU1FUyAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4xNyBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgWE9SIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjE1IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBFT0wgLT5cbiAgICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgIGxldCAoKF9tZW5oaXJfc3RhY2ssIChpZCA6IChcbiMgMTAgXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAoc3RyaW5nKVxuIyAxMzA1IFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgICAgICkpLCBfc3RhcnRwb3NfaWRfKSwgXywgKGUgOiAoUHJlcHJvY2Vzcy5tZXRhX2V4cHIpKSkgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBsZXQgX3YgOiAoUHJlcHJvY2Vzcy5kZWZpbml0aW9uKSA9IFxuIyA5MCBcIklPL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggVmFyRGVmIChpZCwgdHJ1ZSwgZSkgKVxuIyAxMzEwIFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgICAgICBpblxuICAgICAgICAgICAgX21lbmhpcl9nb3RvX2RlZmluaXRpb24gX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfdlxuICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgIGFzc2VydCAobm90IF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IpO1xuICAgICAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgbGV0IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIF8pID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBfbWVuaGlyX3MpXG4gICAgfCBNZW5oaXJTdGF0ZTEwMiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGFzc2VydCAobm90IF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IpO1xuICAgICAgICBsZXQgX3RvayA9IF9tZW5oaXJfZW52Ll9tZW5oaXJfdG9rZW4gaW5cbiAgICAgICAgKG1hdGNoIF90b2sgd2l0aFxuICAgICAgICB8IEFORCAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4zNSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgQkFORCAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW40NiBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgQk9SIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjQ0IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBESVYgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMjUgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IEVRIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjMzIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBJTlRFUlJPR19NQVJLIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjQwIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBMU0hJRlQgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMzEgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IE1JTlVTIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjI3IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBNT0QgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMjMgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IE5FUSAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4yOSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgT1IgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMzggX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IFBMVVMgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMjEgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IFJTSElGVCAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4xOSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgVElNRVMgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMTcgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IFhPUiAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4xNSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgRU9MIC0+XG4gICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBsZXQgKChfbWVuaGlyX3N0YWNrLCAoaWQgOiAoXG4jIDEwIFwiSU8vcGFyc2VyLm1seVwiXG4gICAgICAgKHN0cmluZylcbiMgMTM1OSBcIklPL3BhcnNlci5tbFwiXG4gICAgICAgICAgICApKSwgX3N0YXJ0cG9zX2lkXyksIF8sIChlIDogKFByZXByb2Nlc3MubWV0YV9leHByKSkpID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgbGV0IF92IDogKFByZXByb2Nlc3MuZGVmaW5pdGlvbikgPSBcbiMgODkgXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggVmFyRGVmIChpZCwgZmFsc2UsIGUpIClcbiMgMTM2NCBcIklPL3BhcnNlci5tbFwiXG4gICAgICAgICAgICAgaW5cbiAgICAgICAgICAgIF9tZW5oaXJfZ290b19kZWZpbml0aW9uIF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX3ZcbiAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgICAgIF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IgPC0gdHJ1ZTtcbiAgICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgIGxldCAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zLCBfKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgX21lbmhpcl9zKVxuICAgIHwgXyAtPlxuICAgICAgICBfbWVuaGlyX2ZhaWwgKClcblxuYW5kIF9tZW5oaXJfZ290b19jb21tYW5kIDogX21lbmhpcl9lbnYgLT4gJ3R0dl90YWlsIC0+IF9tZW5oaXJfc3RhdGUgLT4gKFBhcnNlcl9hc3QuY29tbWFuZCkgLT4gJ3R0dl9yZXR1cm4gPVxuICBmdW4gX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgX3YgLT5cbiAgICBsZXQgX21lbmhpcl9zdGFjayA9IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIF92KSBpblxuICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICBsZXQgX3RvayA9IF9tZW5oaXJfZW52Ll9tZW5oaXJfdG9rZW4gaW5cbiAgICBtYXRjaCBfdG9rIHdpdGhcbiAgICB8IEVPRiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0ICgoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zLCBfKSwgXywgKGNtZCA6IChQYXJzZXJfYXN0LmNvbW1hbmQpKSkgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBfdiA6IChQYXJzZXJfYXN0LmFzdCkgPSBcbiMgMTAxIFwiSU8vcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBbY21kXSApXG4jIDEzOTAgXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAgX21lbmhpcl9nb3RvX2FzdCBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyBfdlxuICAgIHwgRU9MIC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF9tZW5oaXJfZW52ID0gX21lbmhpcl9kaXNjYXJkIF9tZW5oaXJfZW52IGluXG4gICAgICAgIGxldCBfdG9rID0gX21lbmhpcl9lbnYuX21lbmhpcl90b2tlbiBpblxuICAgICAgICAobWF0Y2ggX3RvayB3aXRoXG4gICAgICAgIHwgRU9MIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjEgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTkyXG4gICAgICAgIHwgRU9GIHwgSUQgXyB8IExFRlRfQlJBQ0UgfCBOVU1CRVIgXyAtPlxuICAgICAgICAgICAgX21lbmhpcl9yZWR1Y2UyNiBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlOTJcbiAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgICAgIF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IgPC0gdHJ1ZTtcbiAgICAgICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU5MilcbiAgICB8IF8gLT5cbiAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgIF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IgPC0gdHJ1ZTtcbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgXykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgX21lbmhpcl9zXG5cbmFuZCBfbWVuaGlyX2dvdG9fbnVtYmVyIDogX21lbmhpcl9lbnYgLT4gJ3R0dl90YWlsIC0+IF9tZW5oaXJfc3RhdGUgLT4gKFBhcnNlcl9hc3QudW5wcm9jZXNzZWRfaW50MzIpIC0+IExleGluZy5wb3NpdGlvbiAtPiAndHR2X3JldHVybiA9XG4gIGZ1biBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyBfdiBfc3RhcnRwb3MgLT5cbiAgICBtYXRjaCBfbWVuaGlyX3Mgd2l0aFxuICAgIHwgTWVuaGlyU3RhdGU1OSAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IChpIDogKFBhcnNlcl9hc3QudW5wcm9jZXNzZWRfaW50MzIpKSA9IF92IGluXG4gICAgICAgIGxldCBfc3RhcnRwb3NfaV8gPSBfc3RhcnRwb3MgaW5cbiAgICAgICAgbGV0IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MpID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgX3YgOiAoUGFyc2VyX2FzdC5vZmZzZXQpID0gXG4jIDEyNiBcIklPL3BhcnNlci5tbHlcIlxuICAoIE9JbW1lZGlhdGUgKEFybS5zaWduX3BsdXMsIGkpIClcbiMgMTQyNSBcIklPL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICBfbWVuaGlyX2dvdG9fb2Zmc2V0IF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX21lbmhpcl9zIF92XG4gICAgfCBNZW5oaXJTdGF0ZTYyIC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgKGkgOiAoUGFyc2VyX2FzdC51bnByb2Nlc3NlZF9pbnQzMikpID0gX3YgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvc19pXyA9IF9zdGFydHBvcyBpblxuICAgICAgICBsZXQgKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBfdiA6IChQYXJzZXJfYXN0Lm9mZnNldCkgPSBcbiMgMTI3IFwiSU8vcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIE9JbW1lZGlhdGUgKEFybS5zaWduX21pbnVzLCBpKSApXG4jIDE0MzcgXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAgX21lbmhpcl9nb3RvX29mZnNldCBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyBfdlxuICAgIHwgTWVuaGlyU3RhdGU2NyAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IChpIDogKFBhcnNlcl9hc3QudW5wcm9jZXNzZWRfaW50MzIpKSA9IF92IGluXG4gICAgICAgIGxldCBfc3RhcnRwb3NfaV8gPSBfc3RhcnRwb3MgaW5cbiAgICAgICAgbGV0ICgoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zKSwgXykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBfdiA6IChQYXJzZXJfYXN0Lm9mZnNldCkgPSBcbiMgMTI2IFwiSU8vcGFyc2VyLm1seVwiXG4gICggT0ltbWVkaWF0ZSAoQXJtLnNpZ25fcGx1cywgaSkgKVxuIyAxNDQ5IFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIF9tZW5oaXJfZ290b19vZmZzZXQgX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgX3ZcbiAgICB8IE1lbmhpclN0YXRlNjkgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCAoaSA6IChQYXJzZXJfYXN0LnVucHJvY2Vzc2VkX2ludDMyKSkgPSBfdiBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zX2lfID0gX3N0YXJ0cG9zIGluXG4gICAgICAgIGxldCAoKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcyksIF8pID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgX3YgOiAoUGFyc2VyX2FzdC5vZmZzZXQpID0gXG4jIDEyNyBcIklPL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBPSW1tZWRpYXRlIChBcm0uc2lnbl9taW51cywgaSkgKVxuIyAxNDYxIFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIF9tZW5oaXJfZ290b19vZmZzZXQgX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgX3ZcbiAgICB8IE1lbmhpclN0YXRlNjYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCAoaSA6IChQYXJzZXJfYXN0LnVucHJvY2Vzc2VkX2ludDMyKSkgPSBfdiBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zX2lfID0gX3N0YXJ0cG9zIGluXG4gICAgICAgIGxldCAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF92IDogKFBhcnNlcl9hc3Qub2Zmc2V0KSA9IFxuIyAxMjYgXCJJTy9wYXJzZXIubWx5XCJcbiAgKCBPSW1tZWRpYXRlIChBcm0uc2lnbl9wbHVzLCBpKSApXG4jIDE0NzMgXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAgX21lbmhpcl9nb3RvX29mZnNldCBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyBfdlxuICAgIHwgTWVuaGlyU3RhdGU3NCB8IE1lbmhpclN0YXRlNTggLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCAoaSA6IChQYXJzZXJfYXN0LnVucHJvY2Vzc2VkX2ludDMyKSkgPSBfdiBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zX2lfID0gX3N0YXJ0cG9zIGluXG4gICAgICAgIGxldCBfdiA6IChQYXJzZXJfYXN0Lm9mZnNldCkgPSBcbiMgMTI2IFwiSU8vcGFyc2VyLm1seVwiXG4gICggT0ltbWVkaWF0ZSAoQXJtLnNpZ25fcGx1cywgaSkgKVxuIyAxNDg0IFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIF9tZW5oaXJfZ290b19vZmZzZXQgX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgX3ZcbiAgICB8IE1lbmhpclN0YXRlNzkgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCAoaSA6IChQYXJzZXJfYXN0LnVucHJvY2Vzc2VkX2ludDMyKSkgPSBfdiBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zX2lfID0gX3N0YXJ0cG9zIGluXG4gICAgICAgIGxldCAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF92IDogKFBhcnNlcl9hc3QuYXJncykgPSBcbiMgMTE0IFwiSU8vcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggSW1tZWRpYXRlIGkgKVxuIyAxNDk2IFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIF9tZW5oaXJfZ290b19hcmcgX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgX3ZcbiAgICB8IE1lbmhpclN0YXRlODcgfCBNZW5oaXJTdGF0ZTUzIC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgKGkgOiAoUGFyc2VyX2FzdC51bnByb2Nlc3NlZF9pbnQzMikpID0gX3YgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvc19pXyA9IF9zdGFydHBvcyBpblxuICAgICAgICBsZXQgX3YgOiAoUGFyc2VyX2FzdC5hcmdzKSA9IFxuIyAxMTQgXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBJbW1lZGlhdGUgaSApXG4jIDE1MDcgXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAgX21lbmhpcl9nb3RvX2FyZyBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyBfdlxuICAgIHwgTWVuaGlyU3RhdGUzIC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgKG5iIDogKFBhcnNlcl9hc3QudW5wcm9jZXNzZWRfaW50MzIpKSA9IF92IGluXG4gICAgICAgIGxldCBfc3RhcnRwb3NfbmJfID0gX3N0YXJ0cG9zIGluXG4gICAgICAgIGxldCBfdiA6IChQYXJzZXJfYXN0LmNvbW1hbmQpID0gbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19uYl8gaW5cbiAgICAgICAgXG4jIDEwOSBcIklPL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICggQklOIChfc3RhcnRwb3MsIG5iKSApXG4jIDE1MTkgXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAgX21lbmhpcl9nb3RvX2NvbW1hbmQgX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgX3ZcbiAgICB8IF8gLT5cbiAgICAgICAgX21lbmhpcl9mYWlsICgpXG5cbmFuZCBfbWVuaGlyX3J1bjU5IDogX21lbmhpcl9lbnYgLT4gJ3R0dl90YWlsIC0+IF9tZW5oaXJfc3RhdGUgLT4gJ3R0dl9yZXR1cm4gPVxuICBmdW4gX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgLT5cbiAgICBsZXQgX21lbmhpcl9zdGFjayA9IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MpIGluXG4gICAgbGV0IF9tZW5oaXJfZW52ID0gX21lbmhpcl9kaXNjYXJkIF9tZW5oaXJfZW52IGluXG4gICAgbGV0IF90b2sgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX3Rva2VuIGluXG4gICAgbWF0Y2ggX3RvayB3aXRoXG4gICAgfCBJRCBfdiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBfbWVuaGlyX3MgPSBNZW5oaXJTdGF0ZTU5IGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3AgaW5cbiAgICAgICAgbGV0IF9tZW5oaXJfZW52ID0gX21lbmhpcl9kaXNjYXJkIF9tZW5oaXJfZW52IGluXG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IChpZCA6IChcbiMgMTAgXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAoc3RyaW5nKVxuIyAxNTQwIFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgKSkgPSBfdiBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zX2lkXyA9IF9zdGFydHBvcyBpblxuICAgICAgICBsZXQgKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBfdiA6IChQYXJzZXJfYXN0Lm9mZnNldCkgPSBcbiMgMTI4IFwiSU8vcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICggT1JlZ2lzdGVyIChBcm0uc2lnbl9wbHVzLCBpZCkgKVxuIyAxNTQ3IFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIF9tZW5oaXJfZ290b19vZmZzZXQgX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgX3ZcbiAgICB8IExFRlRfQlJBQ0UgLT5cbiAgICAgICAgX21lbmhpcl9ydW41IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU1OSBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BcbiAgICB8IE5VTUJFUiBfdiAtPlxuICAgICAgICBfbWVuaGlyX3J1bjQgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTU5IF92IF9tZW5oaXJfZW52Ll9tZW5oaXJfbGV4YnVmLkxleGluZy5sZXhfc3RhcnRfcFxuICAgIHwgXyAtPlxuICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNTlcblxuYW5kIF9tZW5oaXJfcnVuNjIgOiBfbWVuaGlyX2VudiAtPiAndHR2X3RhaWwgLT4gX21lbmhpcl9zdGF0ZSAtPiAndHR2X3JldHVybiA9XG4gIGZ1biBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyAtPlxuICAgIGxldCBfbWVuaGlyX3N0YWNrID0gKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcykgaW5cbiAgICBsZXQgX21lbmhpcl9lbnYgPSBfbWVuaGlyX2Rpc2NhcmQgX21lbmhpcl9lbnYgaW5cbiAgICBsZXQgX3RvayA9IF9tZW5oaXJfZW52Ll9tZW5oaXJfdG9rZW4gaW5cbiAgICBtYXRjaCBfdG9rIHdpdGhcbiAgICB8IElEIF92IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF9tZW5oaXJfcyA9IE1lbmhpclN0YXRlNjIgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9tZW5oaXJfZW52Ll9tZW5oaXJfbGV4YnVmLkxleGluZy5sZXhfc3RhcnRfcCBpblxuICAgICAgICBsZXQgX21lbmhpcl9lbnYgPSBfbWVuaGlyX2Rpc2NhcmQgX21lbmhpcl9lbnYgaW5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgKGlkIDogKFxuIyAxMCBcIklPL3BhcnNlci5tbHlcIlxuICAgICAgIChzdHJpbmcpXG4jIDE1NzQgXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICApKSA9IF92IGluXG4gICAgICAgIGxldCBfc3RhcnRwb3NfaWRfID0gX3N0YXJ0cG9zIGluXG4gICAgICAgIGxldCAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF92IDogKFBhcnNlcl9hc3Qub2Zmc2V0KSA9IFxuIyAxMjkgXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgKCBPUmVnaXN0ZXIgKEFybS5zaWduX21pbnVzLCBpZCkgKVxuIyAxNTgxIFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIF9tZW5oaXJfZ290b19vZmZzZXQgX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgX3ZcbiAgICB8IExFRlRfQlJBQ0UgLT5cbiAgICAgICAgX21lbmhpcl9ydW41IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU2MiBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BcbiAgICB8IE5VTUJFUiBfdiAtPlxuICAgICAgICBfbWVuaGlyX3J1bjQgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTYyIF92IF9tZW5oaXJfZW52Ll9tZW5oaXJfbGV4YnVmLkxleGluZy5sZXhfc3RhcnRfcFxuICAgIHwgXyAtPlxuICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNjJcblxuYW5kIF9tZW5oaXJfcnVuNjUgOiBfbWVuaGlyX2VudiAtPiAndHR2X3RhaWwgLT4gX21lbmhpcl9zdGF0ZSAtPiAoXG4jIDEwIFwiSU8vcGFyc2VyLm1seVwiXG4gICAgICAgKHN0cmluZylcbiMgMTU5NiBcIklPL3BhcnNlci5tbFwiXG4pIC0+IExleGluZy5wb3NpdGlvbiAtPiAndHR2X3JldHVybiA9XG4gIGZ1biBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyBfdiBfc3RhcnRwb3MgLT5cbiAgICBsZXQgX21lbmhpcl9lbnYgPSBfbWVuaGlyX2Rpc2NhcmQgX21lbmhpcl9lbnYgaW5cbiAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgbGV0IChpZCA6IChcbiMgMTAgXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAoc3RyaW5nKVxuIyAxNjA0IFwiSU8vcGFyc2VyLm1sXCJcbiAgICApKSA9IF92IGluXG4gICAgbGV0IF9zdGFydHBvc19pZF8gPSBfc3RhcnRwb3MgaW5cbiAgICBsZXQgX3YgOiAoUGFyc2VyX2FzdC5vZmZzZXQpID0gXG4jIDEyOCBcIklPL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIE9SZWdpc3RlciAoQXJtLnNpZ25fcGx1cywgaWQpIClcbiMgMTYxMCBcIklPL3BhcnNlci5tbFwiXG4gICAgIGluXG4gICAgX21lbmhpcl9nb3RvX29mZnNldCBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyBfdlxuXG5hbmQgX21lbmhpcl9ydW42NiA6IF9tZW5oaXJfZW52IC0+ICd0dHZfdGFpbCAtPiBfbWVuaGlyX3N0YXRlIC0+ICd0dHZfcmV0dXJuID1cbiAgZnVuIF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX21lbmhpcl9zIC0+XG4gICAgbGV0IF9tZW5oaXJfc3RhY2sgPSAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zKSBpblxuICAgIGxldCBfbWVuaGlyX2VudiA9IF9tZW5oaXJfZGlzY2FyZCBfbWVuaGlyX2VudiBpblxuICAgIGxldCBfdG9rID0gX21lbmhpcl9lbnYuX21lbmhpcl90b2tlbiBpblxuICAgIG1hdGNoIF90b2sgd2l0aFxuICAgIHwgTEVGVF9CUkFDRSAtPlxuICAgICAgICBfbWVuaGlyX3J1bjUgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTY2IF9tZW5oaXJfZW52Ll9tZW5oaXJfbGV4YnVmLkxleGluZy5sZXhfc3RhcnRfcFxuICAgIHwgTUlOVVMgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgX21lbmhpcl9zID0gTWVuaGlyU3RhdGU2NiBpblxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MpIGluXG4gICAgICAgIGxldCBfbWVuaGlyX2VudiA9IF9tZW5oaXJfZGlzY2FyZCBfbWVuaGlyX2VudiBpblxuICAgICAgICBsZXQgX3RvayA9IF9tZW5oaXJfZW52Ll9tZW5oaXJfdG9rZW4gaW5cbiAgICAgICAgKG1hdGNoIF90b2sgd2l0aFxuICAgICAgICB8IExFRlRfQlJBQ0UgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuNSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNjkgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgICAgIHwgTlVNQkVSIF92IC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjQgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTY5IF92IF9tZW5oaXJfZW52Ll9tZW5oaXJfbGV4YnVmLkxleGluZy5sZXhfc3RhcnRfcFxuICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgIGFzc2VydCAobm90IF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IpO1xuICAgICAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTY5KVxuICAgIHwgTlVNQkVSIF92IC0+XG4gICAgICAgIF9tZW5oaXJfcnVuNCBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNjYgX3YgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgfCBQTFVTIC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF9tZW5oaXJfcyA9IE1lbmhpclN0YXRlNjYgaW5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zKSBpblxuICAgICAgICBsZXQgX21lbmhpcl9lbnYgPSBfbWVuaGlyX2Rpc2NhcmQgX21lbmhpcl9lbnYgaW5cbiAgICAgICAgbGV0IF90b2sgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX3Rva2VuIGluXG4gICAgICAgIChtYXRjaCBfdG9rIHdpdGhcbiAgICAgICAgfCBMRUZUX0JSQUNFIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjUgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTY3IF9tZW5oaXJfZW52Ll9tZW5oaXJfbGV4YnVmLkxleGluZy5sZXhfc3RhcnRfcFxuICAgICAgICB8IE5VTUJFUiBfdiAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW40IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU2NyBfdiBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BcbiAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgICAgIF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IgPC0gdHJ1ZTtcbiAgICAgICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU2NylcbiAgICB8IF8gLT5cbiAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgIF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IgPC0gdHJ1ZTtcbiAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTY2XG5cbmFuZCBfbWVuaGlyX2dvdG9fYXJnIDogX21lbmhpcl9lbnYgLT4gJ3R0dl90YWlsIC0+IF9tZW5oaXJfc3RhdGUgLT4gKFBhcnNlcl9hc3QuYXJncykgLT4gJ3R0dl9yZXR1cm4gPVxuICBmdW4gX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgX3YgLT5cbiAgICBsZXQgX21lbmhpcl9zdGFjayA9IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIF92KSBpblxuICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICBsZXQgX3RvayA9IF9tZW5oaXJfZW52Ll9tZW5oaXJfdG9rZW4gaW5cbiAgICBtYXRjaCBfdG9rIHdpdGhcbiAgICB8IENPTU1BIC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF9tZW5oaXJfZW52ID0gX21lbmhpcl9kaXNjYXJkIF9tZW5oaXJfZW52IGluXG4gICAgICAgIGxldCBfdG9rID0gX21lbmhpcl9lbnYuX21lbmhpcl90b2tlbiBpblxuICAgICAgICAobWF0Y2ggX3RvayB3aXRoXG4gICAgICAgIHwgSEFTSCAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW43OSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlODdcbiAgICAgICAgfCBJRCBfdiAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW43OCBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlODcgX3YgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgICAgIHwgTEVGVF9CUkFDRSAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW41IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU4NyBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BcbiAgICAgICAgfCBMRUZUX0JSQUNLIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjU0IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU4N1xuICAgICAgICB8IE5VTUJFUiBfdiAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW40IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU4NyBfdiBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BcbiAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgICAgIF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IgPC0gdHJ1ZTtcbiAgICAgICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU4NylcbiAgICB8IEVPRiB8IEVPTCB8IElOVEVSUk9HX01BUksgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgKHggOiAoUGFyc2VyX2FzdC5hcmdzKSkpID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgX3YgOiAoUGFyc2VyX2FzdC5hcmdzIGxpc3QpID0gXG4jIDI0MSBcIjxzdGFuZGFyZC5tbHk+XCJcbiAgICAoIFsgeCBdIClcbiMgMTY5MSBcIklPL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICBfbWVuaGlyX2dvdG9fc2VwYXJhdGVkX25vbmVtcHR5X2xpc3RfQ09NTUFfYXJnXyBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyBfdlxuICAgIHwgXyAtPlxuICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zLCBfKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBfbWVuaGlyX3NcblxuYW5kIF9tZW5oaXJfZmFpbCA6IHVuaXQgLT4gJ2EgPVxuICBmdW4gKCkgLT5cbiAgICBQcmludGYuZnByaW50ZiBzdGRlcnIgXCJJbnRlcm5hbCBmYWlsdXJlIC0tIHBsZWFzZSBjb250YWN0IHRoZSBwYXJzZXIgZ2VuZXJhdG9yJ3MgZGV2ZWxvcGVycy5cXG4lIVwiO1xuICAgIGFzc2VydCBmYWxzZVxuXG5hbmQgX21lbmhpcl9ydW42IDogX21lbmhpcl9lbnYgLT4gJ3R0dl90YWlsIC0+IF9tZW5oaXJfc3RhdGUgLT4gJ3R0dl9yZXR1cm4gPVxuICBmdW4gX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgLT5cbiAgICBsZXQgX21lbmhpcl9zdGFjayA9IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MpIGluXG4gICAgbGV0IF9tZW5oaXJfZW52ID0gX21lbmhpcl9kaXNjYXJkIF9tZW5oaXJfZW52IGluXG4gICAgbGV0IF90b2sgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX3Rva2VuIGluXG4gICAgbWF0Y2ggX3RvayB3aXRoXG4gICAgfCBFWENMQU1fTUFSSyAtPlxuICAgICAgICBfbWVuaGlyX3J1bjEyIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU2XG4gICAgfCBJRCBfdiAtPlxuICAgICAgICBfbWVuaGlyX3J1bjExIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU2IF92IF9tZW5oaXJfZW52Ll9tZW5oaXJfbGV4YnVmLkxleGluZy5sZXhfc3RhcnRfcFxuICAgIHwgTFBBUkVOIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuMTAgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTZcbiAgICB8IE1JTlVTIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuOSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNlxuICAgIHwgTk9UIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuOCBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNlxuICAgIHwgTlVNQkVSIF92IC0+XG4gICAgICAgIF9tZW5oaXJfcnVuNyBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNiBfdiBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BcbiAgICB8IFBMVVMgLT5cbiAgICAgICAgX21lbmhpcl9ydW42IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU2XG4gICAgfCBfIC0+XG4gICAgICAgIGFzc2VydCAobm90IF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IpO1xuICAgICAgICBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yIDwtIHRydWU7XG4gICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU2XG5cbmFuZCBfbWVuaGlyX3J1bjcgOiBfbWVuaGlyX2VudiAtPiAndHR2X3RhaWwgLT4gX21lbmhpcl9zdGF0ZSAtPiAoXG4jIDggXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAoaW50MzIpXG4jIDE3MzQgXCJJTy9wYXJzZXIubWxcIlxuKSAtPiBMZXhpbmcucG9zaXRpb24gLT4gJ3R0dl9yZXR1cm4gPVxuICBmdW4gX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgX3YgX3N0YXJ0cG9zIC0+XG4gICAgbGV0IF9tZW5oaXJfZW52ID0gX21lbmhpcl9kaXNjYXJkIF9tZW5oaXJfZW52IGluXG4gICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgIGxldCAoaSA6IChcbiMgOCBcIklPL3BhcnNlci5tbHlcIlxuICAgICAgIChpbnQzMilcbiMgMTc0MiBcIklPL3BhcnNlci5tbFwiXG4gICAgKSkgPSBfdiBpblxuICAgIGxldCBfc3RhcnRwb3NfaV8gPSBfc3RhcnRwb3MgaW5cbiAgICBsZXQgX3YgOiAoUHJlcHJvY2Vzcy5tZXRhX2V4cHIpID0gXG4jIDYwIFwiSU8vcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAoIE1Db25zdCBpIClcbiMgMTc0OCBcIklPL3BhcnNlci5tbFwiXG4gICAgIGluXG4gICAgX21lbmhpcl9nb3RvX21ldGFfZXhwciBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyBfdlxuXG5hbmQgX21lbmhpcl9ydW44IDogX21lbmhpcl9lbnYgLT4gJ3R0dl90YWlsIC0+IF9tZW5oaXJfc3RhdGUgLT4gJ3R0dl9yZXR1cm4gPVxuICBmdW4gX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgLT5cbiAgICBsZXQgX21lbmhpcl9zdGFjayA9IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MpIGluXG4gICAgbGV0IF9tZW5oaXJfZW52ID0gX21lbmhpcl9kaXNjYXJkIF9tZW5oaXJfZW52IGluXG4gICAgbGV0IF90b2sgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX3Rva2VuIGluXG4gICAgbWF0Y2ggX3RvayB3aXRoXG4gICAgfCBFWENMQU1fTUFSSyAtPlxuICAgICAgICBfbWVuaGlyX3J1bjEyIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU4XG4gICAgfCBJRCBfdiAtPlxuICAgICAgICBfbWVuaGlyX3J1bjExIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU4IF92IF9tZW5oaXJfZW52Ll9tZW5oaXJfbGV4YnVmLkxleGluZy5sZXhfc3RhcnRfcFxuICAgIHwgTFBBUkVOIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuMTAgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZThcbiAgICB8IE1JTlVTIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuOSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlOFxuICAgIHwgTk9UIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuOCBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlOFxuICAgIHwgTlVNQkVSIF92IC0+XG4gICAgICAgIF9tZW5oaXJfcnVuNyBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlOCBfdiBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BcbiAgICB8IFBMVVMgLT5cbiAgICAgICAgX21lbmhpcl9ydW42IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU4XG4gICAgfCBfIC0+XG4gICAgICAgIGFzc2VydCAobm90IF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IpO1xuICAgICAgICBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yIDwtIHRydWU7XG4gICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU4XG5cbmFuZCBfbWVuaGlyX3J1bjkgOiBfbWVuaGlyX2VudiAtPiAndHR2X3RhaWwgLT4gX21lbmhpcl9zdGF0ZSAtPiAndHR2X3JldHVybiA9XG4gIGZ1biBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyAtPlxuICAgIGxldCBfbWVuaGlyX3N0YWNrID0gKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcykgaW5cbiAgICBsZXQgX21lbmhpcl9lbnYgPSBfbWVuaGlyX2Rpc2NhcmQgX21lbmhpcl9lbnYgaW5cbiAgICBsZXQgX3RvayA9IF9tZW5oaXJfZW52Ll9tZW5oaXJfdG9rZW4gaW5cbiAgICBtYXRjaCBfdG9rIHdpdGhcbiAgICB8IEVYQ0xBTV9NQVJLIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuMTIgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTlcbiAgICB8IElEIF92IC0+XG4gICAgICAgIF9tZW5oaXJfcnVuMTEgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTkgX3YgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgfCBMUEFSRU4gLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMCBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlOVxuICAgIHwgTUlOVVMgLT5cbiAgICAgICAgX21lbmhpcl9ydW45IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU5XG4gICAgfCBOT1QgLT5cbiAgICAgICAgX21lbmhpcl9ydW44IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU5XG4gICAgfCBOVU1CRVIgX3YgLT5cbiAgICAgICAgX21lbmhpcl9ydW43IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU5IF92IF9tZW5oaXJfZW52Ll9tZW5oaXJfbGV4YnVmLkxleGluZy5sZXhfc3RhcnRfcFxuICAgIHwgUExVUyAtPlxuICAgICAgICBfbWVuaGlyX3J1bjYgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTlcbiAgICB8IF8gLT5cbiAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgIF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IgPC0gdHJ1ZTtcbiAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTlcblxuYW5kIF9tZW5oaXJfcnVuMTAgOiBfbWVuaGlyX2VudiAtPiAndHR2X3RhaWwgLT4gX21lbmhpcl9zdGF0ZSAtPiAndHR2X3JldHVybiA9XG4gIGZ1biBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyAtPlxuICAgIGxldCBfbWVuaGlyX3N0YWNrID0gKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcykgaW5cbiAgICBsZXQgX21lbmhpcl9lbnYgPSBfbWVuaGlyX2Rpc2NhcmQgX21lbmhpcl9lbnYgaW5cbiAgICBsZXQgX3RvayA9IF9tZW5oaXJfZW52Ll9tZW5oaXJfdG9rZW4gaW5cbiAgICBtYXRjaCBfdG9rIHdpdGhcbiAgICB8IEVYQ0xBTV9NQVJLIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuMTIgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTEwXG4gICAgfCBJRCBfdiAtPlxuICAgICAgICBfbWVuaGlyX3J1bjExIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUxMCBfdiBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BcbiAgICB8IExQQVJFTiAtPlxuICAgICAgICBfbWVuaGlyX3J1bjEwIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUxMFxuICAgIHwgTUlOVVMgLT5cbiAgICAgICAgX21lbmhpcl9ydW45IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUxMFxuICAgIHwgTk9UIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuOCBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMTBcbiAgICB8IE5VTUJFUiBfdiAtPlxuICAgICAgICBfbWVuaGlyX3J1bjcgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTEwIF92IF9tZW5oaXJfZW52Ll9tZW5oaXJfbGV4YnVmLkxleGluZy5sZXhfc3RhcnRfcFxuICAgIHwgUExVUyAtPlxuICAgICAgICBfbWVuaGlyX3J1bjYgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTEwXG4gICAgfCBfIC0+XG4gICAgICAgIGFzc2VydCAobm90IF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IpO1xuICAgICAgICBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yIDwtIHRydWU7XG4gICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUxMFxuXG5hbmQgX21lbmhpcl9ydW4xMSA6IF9tZW5oaXJfZW52IC0+ICd0dHZfdGFpbCAtPiBfbWVuaGlyX3N0YXRlIC0+IChcbiMgMTAgXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAoc3RyaW5nKVxuIyAxODMwIFwiSU8vcGFyc2VyLm1sXCJcbikgLT4gTGV4aW5nLnBvc2l0aW9uIC0+ICd0dHZfcmV0dXJuID1cbiAgZnVuIF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX21lbmhpcl9zIF92IF9zdGFydHBvcyAtPlxuICAgIGxldCBfbWVuaGlyX2VudiA9IF9tZW5oaXJfZGlzY2FyZCBfbWVuaGlyX2VudiBpblxuICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICBsZXQgKHYgOiAoXG4jIDEwIFwiSU8vcGFyc2VyLm1seVwiXG4gICAgICAgKHN0cmluZylcbiMgMTgzOCBcIklPL3BhcnNlci5tbFwiXG4gICAgKSkgPSBfdiBpblxuICAgIGxldCBfc3RhcnRwb3Nfdl8gPSBfc3RhcnRwb3MgaW5cbiAgICBsZXQgX3YgOiAoUHJlcHJvY2Vzcy5tZXRhX2V4cHIpID0gXG4jIDYxIFwiSU8vcGFyc2VyLm1seVwiXG4gICAgICAgICAgICggTVZhciB2IClcbiMgMTg0NCBcIklPL3BhcnNlci5tbFwiXG4gICAgIGluXG4gICAgX21lbmhpcl9nb3RvX21ldGFfZXhwciBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyBfdlxuXG5hbmQgX21lbmhpcl9ydW4xMiA6IF9tZW5oaXJfZW52IC0+ICd0dHZfdGFpbCAtPiBfbWVuaGlyX3N0YXRlIC0+ICd0dHZfcmV0dXJuID1cbiAgZnVuIF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX21lbmhpcl9zIC0+XG4gICAgbGV0IF9tZW5oaXJfc3RhY2sgPSAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zKSBpblxuICAgIGxldCBfbWVuaGlyX2VudiA9IF9tZW5oaXJfZGlzY2FyZCBfbWVuaGlyX2VudiBpblxuICAgIGxldCBfdG9rID0gX21lbmhpcl9lbnYuX21lbmhpcl90b2tlbiBpblxuICAgIG1hdGNoIF90b2sgd2l0aFxuICAgIHwgRVhDTEFNX01BUksgLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMiBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMTJcbiAgICB8IElEIF92IC0+XG4gICAgICAgIF9tZW5oaXJfcnVuMTEgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTEyIF92IF9tZW5oaXJfZW52Ll9tZW5oaXJfbGV4YnVmLkxleGluZy5sZXhfc3RhcnRfcFxuICAgIHwgTFBBUkVOIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuMTAgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTEyXG4gICAgfCBNSU5VUyAtPlxuICAgICAgICBfbWVuaGlyX3J1bjkgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTEyXG4gICAgfCBOT1QgLT5cbiAgICAgICAgX21lbmhpcl9ydW44IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUxMlxuICAgIHwgTlVNQkVSIF92IC0+XG4gICAgICAgIF9tZW5oaXJfcnVuNyBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMTIgX3YgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgfCBQTFVTIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuNiBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMTJcbiAgICB8IF8gLT5cbiAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgIF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IgPC0gdHJ1ZTtcbiAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTEyXG5cbmFuZCBfbWVuaGlyX2dvdG9fZGVmaW5pdGlvbiA6IF9tZW5oaXJfZW52IC0+ICd0dHZfdGFpbCAtPiAoUHJlcHJvY2Vzcy5kZWZpbml0aW9uKSAtPiAndHR2X3JldHVybiA9XG4gIGZ1biBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF92IC0+XG4gICAgbGV0IF9tZW5oaXJfc3RhY2sgPSAoX21lbmhpcl9zdGFjaywgX3YpIGluXG4gICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgIGFzc2VydCAobm90IF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IpO1xuICAgIGxldCBfdG9rID0gX21lbmhpcl9lbnYuX21lbmhpcl90b2tlbiBpblxuICAgIG1hdGNoIF90b2sgd2l0aFxuICAgIHwgRU9MIC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF9tZW5oaXJfZW52ID0gX21lbmhpcl9kaXNjYXJkIF9tZW5oaXJfZW52IGluXG4gICAgICAgIGxldCBfdG9rID0gX21lbmhpcl9lbnYuX21lbmhpcl90b2tlbiBpblxuICAgICAgICAobWF0Y2ggX3RvayB3aXRoXG4gICAgICAgIHwgRU9MIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjEgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTExNFxuICAgICAgICB8IEhFQURFUiB8IElEIF8gLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcmVkdWNlMjYgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTExNFxuICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgIGFzc2VydCAobm90IF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IpO1xuICAgICAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTExNClcbiAgICB8IF8gLT5cbiAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgIF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IgPC0gdHJ1ZTtcbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgKChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIF8pLCBfKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBfbWVuaGlyX3NcblxuYW5kIF9tZW5oaXJfZ290b19oZWFkZXJzIDogX21lbmhpcl9lbnYgLT4gJ3R0dl90YWlsIC0+IF9tZW5oaXJfc3RhdGUgLT4gKFByZXByb2Nlc3MuaGVhZGVycykgLT4gJ3R0dl9yZXR1cm4gPVxuICBmdW4gX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgX3YgLT5cbiAgICBtYXRjaCBfbWVuaGlyX3Mgd2l0aFxuICAgIHwgTWVuaGlyU3RhdGUxMTQgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCAoZHMgOiAoUHJlcHJvY2Vzcy5oZWFkZXJzKSkgPSBfdiBpblxuICAgICAgICBsZXQgKChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIF8pLCAoZCA6IChQcmVwcm9jZXNzLmRlZmluaXRpb24pKSkgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBfdiA6IChQcmVwcm9jZXNzLmhlYWRlcnMpID0gXG4jIDk1IFwiSU8vcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggZDo6ZHMgKVxuIyAxOTExIFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIF9tZW5oaXJfZ290b19oZWFkZXJzIF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX21lbmhpcl9zIF92XG4gICAgfCBNZW5oaXJTdGF0ZTk2IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgKF8xIDogKFByZXByb2Nlc3MuaGVhZGVycykpID0gX3YgaW5cbiAgICAgICAgT2JqLm1hZ2ljIF8xXG4gICAgfCBfIC0+XG4gICAgICAgIF9tZW5oaXJfZmFpbCAoKVxuXG5hbmQgX21lbmhpcl9nb3RvX2xvcHRpb25fc2VwYXJhdGVkX25vbmVtcHR5X2xpc3RfQ09NTUFfYXJnX18gOiBfbWVuaGlyX2VudiAtPiAndHR2X3RhaWwgLT4gX21lbmhpcl9zdGF0ZSAtPiAoUGFyc2VyX2FzdC5hcmdzIGxpc3QpIC0+ICd0dHZfcmV0dXJuID1cbiAgZnVuIF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX21lbmhpcl9zIF92IC0+XG4gICAgbGV0IF9tZW5oaXJfc3RhY2sgPSAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zLCBfdikgaW5cbiAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgbGV0IF90b2sgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX3Rva2VuIGluXG4gICAgbWF0Y2ggX3RvayB3aXRoXG4gICAgfCBJTlRFUlJPR19NQVJLIC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF9tZW5oaXJfZW52ID0gX21lbmhpcl9kaXNjYXJkIF9tZW5oaXJfZW52IGluXG4gICAgICAgIGxldCBfdG9rID0gX21lbmhpcl9lbnYuX21lbmhpcl90b2tlbiBpblxuICAgICAgICAobWF0Y2ggX3RvayB3aXRoXG4gICAgICAgIHwgTlVNQkVSIF92IC0+XG4gICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wIGluXG4gICAgICAgICAgICBsZXQgX21lbmhpcl9lbnYgPSBfbWVuaGlyX2Rpc2NhcmQgX21lbmhpcl9lbnYgaW5cbiAgICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgIGxldCAoaSA6IChcbiMgOCBcIklPL3BhcnNlci5tbHlcIlxuICAgICAgIChpbnQzMilcbiMgMTk0MiBcIklPL3BhcnNlci5tbFwiXG4gICAgICAgICAgICApKSA9IF92IGluXG4gICAgICAgICAgICBsZXQgX3N0YXJ0cG9zX2lfID0gX3N0YXJ0cG9zIGluXG4gICAgICAgICAgICBsZXQgKChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIChpZCA6IChcbiMgMTAgXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAoc3RyaW5nKVxuIyAxOTQ4IFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgICAgICkpLCBfc3RhcnRwb3NfaWRfKSwgXywgKHhzIDogKFBhcnNlcl9hc3QuYXJncyBsaXN0KSkpID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgbGV0IF92IDogKFBhcnNlcl9hc3QuY29tbWFuZCkgPSBsZXQgYXJncyA9IFxuIyAyMzIgXCI8c3RhbmRhcmQubWx5PlwiXG4gICAgKCB4cyApXG4jIDE5NTMgXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICAgICAgIGluXG4gICAgICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX2lkXyBpblxuICAgICAgICAgICAgXG4jIDEwOCBcIklPL3BhcnNlci5tbHlcIlxuICAoIEFTTSAoX3N0YXJ0cG9zLCBpZCwgYXJncywgT3B0aW1pemVyLlR3ZWFrRml4ZWRMZW5ndGggKFV0aWxzLnVpbnQzMl90b19pbnQgaSkpIClcbiMgMTk1OSBcIklPL3BhcnNlci5tbFwiXG4gICAgICAgICAgICAgaW5cbiAgICAgICAgICAgIF9tZW5oaXJfZ290b19jb21tYW5kIF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX21lbmhpcl9zIF92XG4gICAgICAgIHwgRU9GIHwgRU9MIC0+XG4gICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBsZXQgKChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIChpZCA6IChcbiMgMTAgXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAoc3RyaW5nKVxuIyAxOTY3IFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgICAgICkpLCBfc3RhcnRwb3NfaWRfKSwgXywgKHhzIDogKFBhcnNlcl9hc3QuYXJncyBsaXN0KSkpID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgbGV0IF92IDogKFBhcnNlcl9hc3QuY29tbWFuZCkgPSBsZXQgYXJncyA9IFxuIyAyMzIgXCI8c3RhbmRhcmQubWx5PlwiXG4gICAgKCB4cyApXG4jIDE5NzIgXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICAgICAgIGluXG4gICAgICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX2lkXyBpblxuICAgICAgICAgICAgXG4jIDEwNiBcIklPL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggQVNNIChfc3RhcnRwb3MsIGlkLCBhcmdzLCBPcHRpbWl6ZXIuVHdlYWtNaW5MZW5ndGgpIClcbiMgMTk3OCBcIklPL3BhcnNlci5tbFwiXG4gICAgICAgICAgICAgaW5cbiAgICAgICAgICAgIF9tZW5oaXJfZ290b19jb21tYW5kIF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX21lbmhpcl9zIF92XG4gICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgICAgICBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yIDwtIHRydWU7XG4gICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBsZXQgKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgXykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIF9tZW5oaXJfcylcbiAgICB8IEVPRiB8IEVPTCAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCAoKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgKGlkIDogKFxuIyAxMCBcIklPL3BhcnNlci5tbHlcIlxuICAgICAgIChzdHJpbmcpXG4jIDE5OTIgXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICApKSwgX3N0YXJ0cG9zX2lkXyksIF8sICh4cyA6IChQYXJzZXJfYXN0LmFyZ3MgbGlzdCkpKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF92IDogKFBhcnNlcl9hc3QuY29tbWFuZCkgPSBsZXQgYXJncyA9IFxuIyAyMzIgXCI8c3RhbmRhcmQubWx5PlwiXG4gICAgKCB4cyApXG4jIDE5OTcgXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19pZF8gaW5cbiAgICAgICAgXG4jIDEwNSBcIklPL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBBU00gKF9zdGFydHBvcywgaWQsIGFyZ3MsIE9wdGltaXplci5Ob1R3ZWFraW5nKSApXG4jIDIwMDMgXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAgX21lbmhpcl9nb3RvX2NvbW1hbmQgX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgX3ZcbiAgICB8IF8gLT5cbiAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgIF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IgPC0gdHJ1ZTtcbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgXykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgX21lbmhpcl9zXG5cbmFuZCBfbWVuaGlyX3J1bjQgOiBfbWVuaGlyX2VudiAtPiAndHR2X3RhaWwgLT4gX21lbmhpcl9zdGF0ZSAtPiAoXG4jIDggXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAoaW50MzIpXG4jIDIwMTYgXCJJTy9wYXJzZXIubWxcIlxuKSAtPiBMZXhpbmcucG9zaXRpb24gLT4gJ3R0dl9yZXR1cm4gPVxuICBmdW4gX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgX3YgX3N0YXJ0cG9zIC0+XG4gICAgbGV0IF9tZW5oaXJfZW52ID0gX21lbmhpcl9kaXNjYXJkIF9tZW5oaXJfZW52IGluXG4gICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgIGxldCAoaSA6IChcbiMgOCBcIklPL3BhcnNlci5tbHlcIlxuICAgICAgIChpbnQzMilcbiMgMjAyNCBcIklPL3BhcnNlci5tbFwiXG4gICAgKSkgPSBfdiBpblxuICAgIGxldCBfc3RhcnRwb3NfaV8gPSBfc3RhcnRwb3MgaW5cbiAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX2lfIGluXG4gICAgbGV0IF92IDogKFBhcnNlcl9hc3QudW5wcm9jZXNzZWRfaW50MzIpID0gXG4jIDEzMyBcIklPL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgKCBDb25zdEludDMyIGkgKVxuIyAyMDMxIFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgaW5cbiAgICBfbWVuaGlyX2dvdG9fbnVtYmVyIF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX21lbmhpcl9zIF92IF9zdGFydHBvc1xuXG5hbmQgX21lbmhpcl9ydW41NCA6IF9tZW5oaXJfZW52IC0+ICd0dHZfdGFpbCAtPiBfbWVuaGlyX3N0YXRlIC0+ICd0dHZfcmV0dXJuID1cbiAgZnVuIF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX21lbmhpcl9zIC0+XG4gICAgbGV0IF9tZW5oaXJfc3RhY2sgPSAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zKSBpblxuICAgIGxldCBfbWVuaGlyX2VudiA9IF9tZW5oaXJfZGlzY2FyZCBfbWVuaGlyX2VudiBpblxuICAgIGxldCBfdG9rID0gX21lbmhpcl9lbnYuX21lbmhpcl90b2tlbiBpblxuICAgIG1hdGNoIF90b2sgd2l0aFxuICAgIHwgSUQgX3YgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wIGluXG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gKF9tZW5oaXJfc3RhY2ssIF92LCBfc3RhcnRwb3MpIGluXG4gICAgICAgIGxldCBfbWVuaGlyX2VudiA9IF9tZW5oaXJfZGlzY2FyZCBfbWVuaGlyX2VudiBpblxuICAgICAgICBsZXQgX3RvayA9IF9tZW5oaXJfZW52Ll9tZW5oaXJfdG9rZW4gaW5cbiAgICAgICAgKG1hdGNoIF90b2sgd2l0aFxuICAgICAgICB8IENPTU1BIC0+XG4gICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBsZXQgX21lbmhpcl9lbnYgPSBfbWVuaGlyX2Rpc2NhcmQgX21lbmhpcl9lbnYgaW5cbiAgICAgICAgICAgIGxldCBfdG9rID0gX21lbmhpcl9lbnYuX21lbmhpcl90b2tlbiBpblxuICAgICAgICAgICAgKG1hdGNoIF90b2sgd2l0aFxuICAgICAgICAgICAgfCBIQVNIIC0+XG4gICAgICAgICAgICAgICAgX21lbmhpcl9ydW42NiBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNzRcbiAgICAgICAgICAgIHwgSUQgX3YgLT5cbiAgICAgICAgICAgICAgICBfbWVuaGlyX3J1bjY1IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU3NCBfdiBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BcbiAgICAgICAgICAgIHwgTEVGVF9CUkFDRSAtPlxuICAgICAgICAgICAgICAgIF9tZW5oaXJfcnVuNSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNzQgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgICAgICAgICB8IE1JTlVTIC0+XG4gICAgICAgICAgICAgICAgX21lbmhpcl9ydW42MiBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNzRcbiAgICAgICAgICAgIHwgTlVNQkVSIF92IC0+XG4gICAgICAgICAgICAgICAgX21lbmhpcl9ydW40IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU3NCBfdiBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BcbiAgICAgICAgICAgIHwgUExVUyAtPlxuICAgICAgICAgICAgICAgIF9tZW5oaXJfcnVuNTkgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTc0XG4gICAgICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgICAgICAgICBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yIDwtIHRydWU7XG4gICAgICAgICAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTc0KVxuICAgICAgICB8IFJJR0hUX0JSQUNLIC0+XG4gICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBsZXQgX21lbmhpcl9lbnYgPSBfbWVuaGlyX2Rpc2NhcmQgX21lbmhpcl9lbnYgaW5cbiAgICAgICAgICAgIGxldCBfdG9rID0gX21lbmhpcl9lbnYuX21lbmhpcl90b2tlbiBpblxuICAgICAgICAgICAgKG1hdGNoIF90b2sgd2l0aFxuICAgICAgICAgICAgfCBDT01NQSAtPlxuICAgICAgICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgICAgICBsZXQgX21lbmhpcl9lbnYgPSBfbWVuaGlyX2Rpc2NhcmQgX21lbmhpcl9lbnYgaW5cbiAgICAgICAgICAgICAgICBsZXQgX3RvayA9IF9tZW5oaXJfZW52Ll9tZW5oaXJfdG9rZW4gaW5cbiAgICAgICAgICAgICAgICAobWF0Y2ggX3RvayB3aXRoXG4gICAgICAgICAgICAgICAgfCBIQVNIIC0+XG4gICAgICAgICAgICAgICAgICAgIF9tZW5oaXJfcnVuNjYgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTU4XG4gICAgICAgICAgICAgICAgfCBJRCBfdiAtPlxuICAgICAgICAgICAgICAgICAgICBfbWVuaGlyX3J1bjY1IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU1OCBfdiBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BcbiAgICAgICAgICAgICAgICB8IExFRlRfQlJBQ0UgLT5cbiAgICAgICAgICAgICAgICAgICAgX21lbmhpcl9ydW41IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU1OCBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BcbiAgICAgICAgICAgICAgICB8IE1JTlVTIC0+XG4gICAgICAgICAgICAgICAgICAgIF9tZW5oaXJfcnVuNjIgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTU4XG4gICAgICAgICAgICAgICAgfCBOVU1CRVIgX3YgLT5cbiAgICAgICAgICAgICAgICAgICAgX21lbmhpcl9ydW40IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU1OCBfdiBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BcbiAgICAgICAgICAgICAgICB8IFBMVVMgLT5cbiAgICAgICAgICAgICAgICAgICAgX21lbmhpcl9ydW41OSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNThcbiAgICAgICAgICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IgPC0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTU4KVxuICAgICAgICAgICAgfCBFWENMQU1fTUFSSyAtPlxuICAgICAgICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgICAgICBsZXQgX21lbmhpcl9lbnYgPSBfbWVuaGlyX2Rpc2NhcmQgX21lbmhpcl9lbnYgaW5cbiAgICAgICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICAgICAgbGV0ICgoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zKSwgKGlkIDogKFxuIyAxMCBcIklPL3BhcnNlci5tbHlcIlxuICAgICAgIChzdHJpbmcpXG4jIDIxMDIgXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICAgICAgICAgICkpLCBfc3RhcnRwb3NfaWRfKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgICAgICBsZXQgX3YgOiAoUGFyc2VyX2FzdC5hcmdzKSA9IFxuIyAxMjAgXCJJTy9wYXJzZXIubWx5XCJcbiAgKCBPZmZzZXQgKGlkLCBPSW1tZWRpYXRlIChBcm0uc2lnbl9wbHVzLCBDb25zdEludDMyIEludDMyLnplcm8pLCBBcm0uUHJlSW5kZXhlZCkgKVxuIyAyMTA3IFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgICBfbWVuaGlyX2dvdG9fYXJnIF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX21lbmhpcl9zIF92XG4gICAgICAgICAgICB8IEVPRiB8IEVPTCB8IElOVEVSUk9HX01BUksgLT5cbiAgICAgICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICAgICAgbGV0ICgoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zKSwgKGlkIDogKFxuIyAxMCBcIklPL3BhcnNlci5tbHlcIlxuICAgICAgIChzdHJpbmcpXG4jIDIxMTUgXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICAgICAgICAgICkpLCBfc3RhcnRwb3NfaWRfKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgICAgICBsZXQgX3YgOiAoUGFyc2VyX2FzdC5hcmdzKSA9IFxuIyAxMTcgXCJJTy9wYXJzZXIubWx5XCJcbiAgKCBPZmZzZXQgKGlkLCBPSW1tZWRpYXRlIChBcm0uc2lnbl9wbHVzLCBDb25zdEludDMyIEludDMyLnplcm8pLCBBcm0uT2Zmc2V0KSApXG4jIDIxMjAgXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgIF9tZW5oaXJfZ290b19hcmcgX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgX3ZcbiAgICAgICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgICAgIGFzc2VydCAobm90IF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IpO1xuICAgICAgICAgICAgICAgIF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IgPC0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICAgICAgbGV0ICgoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zKSwgXywgXykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBfbWVuaGlyX3MpXG4gICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgICAgICBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yIDwtIHRydWU7XG4gICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBsZXQgKChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MpLCBfLCBfKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgX21lbmhpcl9zKVxuICAgIHwgXyAtPlxuICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBfbWVuaGlyX3NcblxuYW5kIF9tZW5oaXJfcnVuNSA6IF9tZW5oaXJfZW52IC0+ICd0dHZfdGFpbCAtPiBfbWVuaGlyX3N0YXRlIC0+IExleGluZy5wb3NpdGlvbiAtPiAndHR2X3JldHVybiA9XG4gIGZ1biBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyBfc3RhcnRwb3MgLT5cbiAgICBsZXQgX21lbmhpcl9zdGFjayA9IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIF9zdGFydHBvcykgaW5cbiAgICBsZXQgX21lbmhpcl9lbnYgPSBfbWVuaGlyX2Rpc2NhcmQgX21lbmhpcl9lbnYgaW5cbiAgICBsZXQgX3RvayA9IF9tZW5oaXJfZW52Ll9tZW5oaXJfdG9rZW4gaW5cbiAgICBtYXRjaCBfdG9rIHdpdGhcbiAgICB8IEVYQ0xBTV9NQVJLIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuMTIgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTVcbiAgICB8IElEIF92IC0+XG4gICAgICAgIF9tZW5oaXJfcnVuMTEgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTUgX3YgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgfCBMUEFSRU4gLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMCBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNVxuICAgIHwgTUlOVVMgLT5cbiAgICAgICAgX21lbmhpcl9ydW45IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU1XG4gICAgfCBOT1QgLT5cbiAgICAgICAgX21lbmhpcl9ydW44IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU1XG4gICAgfCBOVU1CRVIgX3YgLT5cbiAgICAgICAgX21lbmhpcl9ydW43IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU1IF92IF9tZW5oaXJfZW52Ll9tZW5oaXJfbGV4YnVmLkxleGluZy5sZXhfc3RhcnRfcFxuICAgIHwgUExVUyAtPlxuICAgICAgICBfbWVuaGlyX3J1bjYgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTVcbiAgICB8IF8gLT5cbiAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgIF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IgPC0gdHJ1ZTtcbiAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTVcblxuYW5kIF9tZW5oaXJfcnVuNzggOiBfbWVuaGlyX2VudiAtPiAndHR2X3RhaWwgLT4gX21lbmhpcl9zdGF0ZSAtPiAoXG4jIDEwIFwiSU8vcGFyc2VyLm1seVwiXG4gICAgICAgKHN0cmluZylcbiMgMjE3MCBcIklPL3BhcnNlci5tbFwiXG4pIC0+IExleGluZy5wb3NpdGlvbiAtPiAndHR2X3JldHVybiA9XG4gIGZ1biBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyBfdiBfc3RhcnRwb3MgLT5cbiAgICBsZXQgX21lbmhpcl9lbnYgPSBfbWVuaGlyX2Rpc2NhcmQgX21lbmhpcl9lbnYgaW5cbiAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgbGV0IChpZCA6IChcbiMgMTAgXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAoc3RyaW5nKVxuIyAyMTc4IFwiSU8vcGFyc2VyLm1sXCJcbiAgICApKSA9IF92IGluXG4gICAgbGV0IF9zdGFydHBvc19pZF8gPSBfc3RhcnRwb3MgaW5cbiAgICBsZXQgX3YgOiAoUGFyc2VyX2FzdC5hcmdzKSA9IFxuIyAxMTMgXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICggUmVnaXN0ZXIgaWQgKVxuIyAyMTg0IFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgaW5cbiAgICBfbWVuaGlyX2dvdG9fYXJnIF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX21lbmhpcl9zIF92XG5cbmFuZCBfbWVuaGlyX3J1bjc5IDogX21lbmhpcl9lbnYgLT4gJ3R0dl90YWlsIC0+IF9tZW5oaXJfc3RhdGUgLT4gJ3R0dl9yZXR1cm4gPVxuICBmdW4gX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgLT5cbiAgICBsZXQgX21lbmhpcl9zdGFjayA9IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MpIGluXG4gICAgbGV0IF9tZW5oaXJfZW52ID0gX21lbmhpcl9kaXNjYXJkIF9tZW5oaXJfZW52IGluXG4gICAgbGV0IF90b2sgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX3Rva2VuIGluXG4gICAgbWF0Y2ggX3RvayB3aXRoXG4gICAgfCBMRUZUX0JSQUNFIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuNSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNzkgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgfCBOVU1CRVIgX3YgLT5cbiAgICAgICAgX21lbmhpcl9ydW40IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU3OSBfdiBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BcbiAgICB8IF8gLT5cbiAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgIF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IgPC0gdHJ1ZTtcbiAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTc5XG5cbmFuZCBfbWVuaGlyX2dvdG9fYXN0IDogX21lbmhpcl9lbnYgLT4gJ3R0dl90YWlsIC0+IF9tZW5oaXJfc3RhdGUgLT4gKFBhcnNlcl9hc3QuYXN0KSAtPiAndHR2X3JldHVybiA9XG4gIGZ1biBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyBfdiAtPlxuICAgIG1hdGNoIF9tZW5oaXJfcyB3aXRoXG4gICAgfCBNZW5oaXJTdGF0ZTkyIC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgKGNtZHMgOiAoUGFyc2VyX2FzdC5hc3QpKSA9IF92IGluXG4gICAgICAgIGxldCAoKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgXyksIF8sIChjbWQgOiAoUGFyc2VyX2FzdC5jb21tYW5kKSkpID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgX3YgOiAoUGFyc2VyX2FzdC5hc3QpID0gXG4jIDEwMCBcIklPL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIGNtZDo6Y21kcyApXG4jIDIyMTQgXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAgX21lbmhpcl9nb3RvX2FzdCBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyBfdlxuICAgIHwgTWVuaGlyU3RhdGUwIC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgKF8xIDogKFBhcnNlcl9hc3QuYXN0KSkgPSBfdiBpblxuICAgICAgICBPYmoubWFnaWMgXzFcbiAgICB8IF8gLT5cbiAgICAgICAgX21lbmhpcl9mYWlsICgpXG5cbmFuZCBfbWVuaGlyX2dvdG9fbGlzdF9FT0xfIDogX21lbmhpcl9lbnYgLT4gJ3R0dl90YWlsIC0+IF9tZW5oaXJfc3RhdGUgLT4gKHVuaXQgbGlzdCkgLT4gJ3R0dl9yZXR1cm4gPVxuICBmdW4gX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgX3YgLT5cbiAgICBsZXQgX21lbmhpcl9zdGFjayA9IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIF92KSBpblxuICAgIG1hdGNoIF9tZW5oaXJfcyB3aXRoXG4gICAgfCBNZW5oaXJTdGF0ZTEgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCAoKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcyksIF8sICh4cyA6ICh1bml0IGxpc3QpKSkgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCB4ID0gKCkgaW5cbiAgICAgICAgbGV0IF92IDogKHVuaXQgbGlzdCkgPSBcbiMgMjEzIFwiPHN0YW5kYXJkLm1seT5cIlxuICAgICggeCA6OiB4cyApXG4jIDIyMzcgXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAgX21lbmhpcl9nb3RvX2xpc3RfRU9MXyBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyBfdlxuICAgIHwgTWVuaGlyU3RhdGU5MiB8IE1lbmhpclN0YXRlMCAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGFzc2VydCAobm90IF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IpO1xuICAgICAgICBsZXQgX3RvayA9IF9tZW5oaXJfZW52Ll9tZW5oaXJfdG9rZW4gaW5cbiAgICAgICAgKG1hdGNoIF90b2sgd2l0aFxuICAgICAgICB8IEVPRiAtPlxuICAgICAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgbGV0IF9tZW5oaXJfcyA9IE1lbmhpclN0YXRlMyBpblxuICAgICAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgbGV0IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIF8pID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgbGV0IF92IDogKFBhcnNlcl9hc3QuYXN0KSA9IFxuIyA5OSBcIklPL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgKCBbXSApXG4jIDIyNTMgXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICAgICAgIGluXG4gICAgICAgICAgICBfbWVuaGlyX2dvdG9fYXN0IF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX21lbmhpcl9zIF92XG4gICAgICAgIHwgSUQgX3YgLT5cbiAgICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgIGxldCBfbWVuaGlyX3MgPSBNZW5oaXJTdGF0ZTMgaW5cbiAgICAgICAgICAgIGxldCBfc3RhcnRwb3MgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3AgaW5cbiAgICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgX3YsIF9zdGFydHBvcykgaW5cbiAgICAgICAgICAgIGxldCBfbWVuaGlyX2VudiA9IF9tZW5oaXJfZGlzY2FyZCBfbWVuaGlyX2VudiBpblxuICAgICAgICAgICAgbGV0IF90b2sgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX3Rva2VuIGluXG4gICAgICAgICAgICAobWF0Y2ggX3RvayB3aXRoXG4gICAgICAgICAgICB8IEhBU0ggLT5cbiAgICAgICAgICAgICAgICBfbWVuaGlyX3J1bjc5IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU1M1xuICAgICAgICAgICAgfCBJRCBfdiAtPlxuICAgICAgICAgICAgICAgIF9tZW5oaXJfcnVuNzggX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTUzIF92IF9tZW5oaXJfZW52Ll9tZW5oaXJfbGV4YnVmLkxleGluZy5sZXhfc3RhcnRfcFxuICAgICAgICAgICAgfCBMRUZUX0JSQUNFIC0+XG4gICAgICAgICAgICAgICAgX21lbmhpcl9ydW41IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU1MyBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BcbiAgICAgICAgICAgIHwgTEVGVF9CUkFDSyAtPlxuICAgICAgICAgICAgICAgIF9tZW5oaXJfcnVuNTQgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTUzXG4gICAgICAgICAgICB8IE5VTUJFUiBfdiAtPlxuICAgICAgICAgICAgICAgIF9tZW5oaXJfcnVuNCBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNTMgX3YgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgICAgICAgICB8IEVPRiB8IEVPTCB8IElOVEVSUk9HX01BUksgLT5cbiAgICAgICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICAgICAgbGV0IF9tZW5oaXJfcyA9IE1lbmhpclN0YXRlNTMgaW5cbiAgICAgICAgICAgICAgICBsZXQgX3YgOiAoUGFyc2VyX2FzdC5hcmdzIGxpc3QpID0gXG4jIDE0MiBcIjxzdGFuZGFyZC5tbHk+XCJcbiAgICAoIFtdIClcbiMgMjI4MCBcIklPL3BhcnNlci5tbFwiXG4gICAgICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgICAgX21lbmhpcl9nb3RvX2xvcHRpb25fc2VwYXJhdGVkX25vbmVtcHR5X2xpc3RfQ09NTUFfYXJnX18gX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgX3ZcbiAgICAgICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgICAgIGFzc2VydCAobm90IF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IpO1xuICAgICAgICAgICAgICAgIF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IgPC0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNTMpXG4gICAgICAgIHwgTEVGVF9CUkFDRSAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW41IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUzIF9tZW5oaXJfZW52Ll9tZW5oaXJfbGV4YnVmLkxleGluZy5sZXhfc3RhcnRfcFxuICAgICAgICB8IE5VTUJFUiBfdiAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW40IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUzIF92IF9tZW5oaXJfZW52Ll9tZW5oaXJfbGV4YnVmLkxleGluZy5sZXhfc3RhcnRfcFxuICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgIGFzc2VydCAobm90IF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IpO1xuICAgICAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTMpXG4gICAgfCBNZW5oaXJTdGF0ZTExNCB8IE1lbmhpclN0YXRlOTYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgbGV0IF90b2sgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX3Rva2VuIGluXG4gICAgICAgIChtYXRjaCBfdG9rIHdpdGhcbiAgICAgICAgfCBIRUFERVIgLT5cbiAgICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgIGxldCBfbWVuaGlyX2VudiA9IF9tZW5oaXJfZGlzY2FyZCBfbWVuaGlyX2VudiBpblxuICAgICAgICAgICAgbGV0IF90b2sgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX3Rva2VuIGluXG4gICAgICAgICAgICAobWF0Y2ggX3RvayB3aXRoXG4gICAgICAgICAgICB8IEVPRiAtPlxuICAgICAgICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICAgICAgbGV0IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIF8pID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgICAgIGxldCBfdiA6IChQcmVwcm9jZXNzLmhlYWRlcnMpID0gXG4jIDk0IFwiSU8vcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBbXSApXG4jIDIzMTIgXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgIF9tZW5oaXJfZ290b19oZWFkZXJzIF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX21lbmhpcl9zIF92XG4gICAgICAgICAgICB8IEVPTCAtPlxuICAgICAgICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICAgICAgbGV0IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIF8pID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgICAgIGxldCBfdiA6IChQcmVwcm9jZXNzLmhlYWRlcnMpID0gXG4jIDk0IFwiSU8vcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBbXSApXG4jIDIzMjIgXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgIF9tZW5oaXJfZ290b19oZWFkZXJzIF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX21lbmhpcl9zIF92XG4gICAgICAgICAgICB8IElEIF92IC0+XG4gICAgICAgICAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgICAgIGxldCBfc3RhcnRwb3MgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3AgaW5cbiAgICAgICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IChfbWVuaGlyX3N0YWNrLCBfdiwgX3N0YXJ0cG9zKSBpblxuICAgICAgICAgICAgICAgIGxldCBfbWVuaGlyX2VudiA9IF9tZW5oaXJfZGlzY2FyZCBfbWVuaGlyX2VudiBpblxuICAgICAgICAgICAgICAgIGxldCBfdG9rID0gX21lbmhpcl9lbnYuX21lbmhpcl90b2tlbiBpblxuICAgICAgICAgICAgICAgIChtYXRjaCBfdG9rIHdpdGhcbiAgICAgICAgICAgICAgICB8IEVRVUFMIC0+XG4gICAgICAgICAgICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgICAgICAgICAgbGV0IF9tZW5oaXJfZW52ID0gX21lbmhpcl9kaXNjYXJkIF9tZW5oaXJfZW52IGluXG4gICAgICAgICAgICAgICAgICAgIGxldCBfdG9rID0gX21lbmhpcl9lbnYuX21lbmhpcl90b2tlbiBpblxuICAgICAgICAgICAgICAgICAgICAobWF0Y2ggX3RvayB3aXRoXG4gICAgICAgICAgICAgICAgICAgIHwgQk9PTCBfdiAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IF9tZW5oaXJfZW52ID0gX21lbmhpcl9kaXNjYXJkIF9tZW5oaXJfZW52IGluXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgKGIgOiAoXG4jIDkgXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAoYm9vbClcbiMgMjM0NCBcIklPL3BhcnNlci5tbFwiXG4gICAgICAgICAgICAgICAgICAgICAgICApKSA9IF92IGluXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgKF9tZW5oaXJfc3RhY2ssIChpZCA6IChcbiMgMTAgXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAoc3RyaW5nKVxuIyAyMzQ5IFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICkpLCBfc3RhcnRwb3NfaWRfKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBfdiA6IChQcmVwcm9jZXNzLmRlZmluaXRpb24pID0gXG4jIDg3IFwiSU8vcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBQYXJhbSAoaWQsIEhCb29sIGIpIClcbiMgMjM1NCBcIklPL3BhcnNlci5tbFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgICAgICAgICAgIF9tZW5oaXJfZ290b19kZWZpbml0aW9uIF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX3ZcbiAgICAgICAgICAgICAgICAgICAgfCBOVUxMIC0+XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgX21lbmhpcl9lbnYgPSBfbWVuaGlyX2Rpc2NhcmQgX21lbmhpcl9lbnYgaW5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCAoX21lbmhpcl9zdGFjaywgKGlkIDogKFxuIyAxMCBcIklPL3BhcnNlci5tbHlcIlxuICAgICAgIChzdHJpbmcpXG4jIDIzNjQgXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgKSksIF9zdGFydHBvc19pZF8pID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IF92IDogKFByZXByb2Nlc3MuZGVmaW5pdGlvbikgPSBcbiMgODggXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggUGFyYW0gKGlkLCBITm9uZSkgKVxuIyAyMzY5IFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgICAgICAgICAgX21lbmhpcl9nb3RvX2RlZmluaXRpb24gX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfdlxuICAgICAgICAgICAgICAgICAgICB8IE5VTUJFUiBfdiAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9tZW5oaXJfZW52Ll9tZW5oaXJfbGV4YnVmLkxleGluZy5sZXhfc3RhcnRfcCBpblxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IF9tZW5oaXJfZW52ID0gX21lbmhpcl9kaXNjYXJkIF9tZW5oaXJfZW52IGluXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgKG5iIDogKFxuIyA4IFwiSU8vcGFyc2VyLm1seVwiXG4gICAgICAgKGludDMyKVxuIyAyMzgwIFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICkpID0gX3YgaW5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBfc3RhcnRwb3NfbmJfID0gX3N0YXJ0cG9zIGluXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgKF9tZW5oaXJfc3RhY2ssIChpZCA6IChcbiMgMTAgXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAoc3RyaW5nKVxuIyAyMzg2IFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICkpLCBfc3RhcnRwb3NfaWRfKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBfdiA6IChQcmVwcm9jZXNzLmRlZmluaXRpb24pID0gXG4jIDg2IFwiSU8vcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBQYXJhbSAoaWQsIEhJbnQgbmIpIClcbiMgMjM5MSBcIklPL3BhcnNlci5tbFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgICAgICAgICAgIF9tZW5oaXJfZ290b19kZWZpbml0aW9uIF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX3ZcbiAgICAgICAgICAgICAgICAgICAgfCBTVFJJTkcgX3YgLT5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBfbWVuaGlyX2VudiA9IF9tZW5oaXJfZGlzY2FyZCBfbWVuaGlyX2VudiBpblxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IChzdHIgOiAoXG4jIDcgXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAoc3RyaW5nKVxuIyAyNDAxIFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICkpID0gX3YgaW5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCAoX21lbmhpcl9zdGFjaywgKGlkIDogKFxuIyAxMCBcIklPL3BhcnNlci5tbHlcIlxuICAgICAgIChzdHJpbmcpXG4jIDI0MDYgXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgKSksIF9zdGFydHBvc19pZF8pID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IF92IDogKFByZXByb2Nlc3MuZGVmaW5pdGlvbikgPSBcbiMgODUgXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBQYXJhbSAoaWQsIEhTdHJpbmcgc3RyKSApXG4jIDI0MTEgXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgICAgICAgICAgICBfbWVuaGlyX2dvdG9fZGVmaW5pdGlvbiBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF92XG4gICAgICAgICAgICAgICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yIDwtIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICAgICAgICAgICAgICByYWlzZSBfZVJSKVxuICAgICAgICAgICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICAgICAgICAgIHJhaXNlIF9lUlIpXG4gICAgICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgICAgICAgICBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yIDwtIHRydWU7XG4gICAgICAgICAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgICAgIGxldCAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zLCBfKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIF9tZW5oaXJfcylcbiAgICAgICAgfCBJRCBfdiAtPlxuICAgICAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9tZW5oaXJfZW52Ll9tZW5oaXJfbGV4YnVmLkxleGluZy5sZXhfc3RhcnRfcCBpblxuICAgICAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSAoX21lbmhpcl9zdGFjaywgX3YsIF9zdGFydHBvcykgaW5cbiAgICAgICAgICAgIGxldCBfbWVuaGlyX2VudiA9IF9tZW5oaXJfZGlzY2FyZCBfbWVuaGlyX2VudiBpblxuICAgICAgICAgICAgbGV0IF90b2sgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX3Rva2VuIGluXG4gICAgICAgICAgICAobWF0Y2ggX3RvayB3aXRoXG4gICAgICAgICAgICB8IEVRVUFMIC0+XG4gICAgICAgICAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgICAgIGxldCBfbWVuaGlyX2VudiA9IF9tZW5oaXJfZGlzY2FyZCBfbWVuaGlyX2VudiBpblxuICAgICAgICAgICAgICAgIGxldCBfdG9rID0gX21lbmhpcl9lbnYuX21lbmhpcl90b2tlbiBpblxuICAgICAgICAgICAgICAgIChtYXRjaCBfdG9rIHdpdGhcbiAgICAgICAgICAgICAgICB8IEVYQ0xBTV9NQVJLIC0+XG4gICAgICAgICAgICAgICAgICAgIF9tZW5oaXJfcnVuMTIgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTEwMlxuICAgICAgICAgICAgICAgIHwgSUQgX3YgLT5cbiAgICAgICAgICAgICAgICAgICAgX21lbmhpcl9ydW4xMSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMTAyIF92IF9tZW5oaXJfZW52Ll9tZW5oaXJfbGV4YnVmLkxleGluZy5sZXhfc3RhcnRfcFxuICAgICAgICAgICAgICAgIHwgTFBBUkVOIC0+XG4gICAgICAgICAgICAgICAgICAgIF9tZW5oaXJfcnVuMTAgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTEwMlxuICAgICAgICAgICAgICAgIHwgTUlOVVMgLT5cbiAgICAgICAgICAgICAgICAgICAgX21lbmhpcl9ydW45IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUxMDJcbiAgICAgICAgICAgICAgICB8IE5PVCAtPlxuICAgICAgICAgICAgICAgICAgICBfbWVuaGlyX3J1bjggX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTEwMlxuICAgICAgICAgICAgICAgIHwgTlVNQkVSIF92IC0+XG4gICAgICAgICAgICAgICAgICAgIF9tZW5oaXJfcnVuNyBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMTAyIF92IF9tZW5oaXJfZW52Ll9tZW5oaXJfbGV4YnVmLkxleGluZy5sZXhfc3RhcnRfcFxuICAgICAgICAgICAgICAgIHwgUExVUyAtPlxuICAgICAgICAgICAgICAgICAgICBfbWVuaGlyX3J1bjYgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTEwMlxuICAgICAgICAgICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMTAyKVxuICAgICAgICAgICAgfCBJTlRFUlJPR19NQVJLIC0+XG4gICAgICAgICAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgICAgIGxldCBfbWVuaGlyX2VudiA9IF9tZW5oaXJfZGlzY2FyZCBfbWVuaGlyX2VudiBpblxuICAgICAgICAgICAgICAgIGxldCBfdG9rID0gX21lbmhpcl9lbnYuX21lbmhpcl90b2tlbiBpblxuICAgICAgICAgICAgICAgIChtYXRjaCBfdG9rIHdpdGhcbiAgICAgICAgICAgICAgICB8IEVRVUFMIC0+XG4gICAgICAgICAgICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgICAgICAgICAgbGV0IF9tZW5oaXJfZW52ID0gX21lbmhpcl9kaXNjYXJkIF9tZW5oaXJfZW52IGluXG4gICAgICAgICAgICAgICAgICAgIGxldCBfdG9rID0gX21lbmhpcl9lbnYuX21lbmhpcl90b2tlbiBpblxuICAgICAgICAgICAgICAgICAgICAobWF0Y2ggX3RvayB3aXRoXG4gICAgICAgICAgICAgICAgICAgIHwgRVhDTEFNX01BUksgLT5cbiAgICAgICAgICAgICAgICAgICAgICAgIF9tZW5oaXJfcnVuMTIgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTEwMFxuICAgICAgICAgICAgICAgICAgICB8IElEIF92IC0+XG4gICAgICAgICAgICAgICAgICAgICAgICBfbWVuaGlyX3J1bjExIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUxMDAgX3YgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgICAgICAgICAgICAgICAgIHwgTFBBUkVOIC0+XG4gICAgICAgICAgICAgICAgICAgICAgICBfbWVuaGlyX3J1bjEwIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUxMDBcbiAgICAgICAgICAgICAgICAgICAgfCBNSU5VUyAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgX21lbmhpcl9ydW45IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUxMDBcbiAgICAgICAgICAgICAgICAgICAgfCBOT1QgLT5cbiAgICAgICAgICAgICAgICAgICAgICAgIF9tZW5oaXJfcnVuOCBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMTAwXG4gICAgICAgICAgICAgICAgICAgIHwgTlVNQkVSIF92IC0+XG4gICAgICAgICAgICAgICAgICAgICAgICBfbWVuaGlyX3J1bjcgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTEwMCBfdiBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BcbiAgICAgICAgICAgICAgICAgICAgfCBQTFVTIC0+XG4gICAgICAgICAgICAgICAgICAgICAgICBfbWVuaGlyX3J1bjYgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTEwMFxuICAgICAgICAgICAgICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydCAobm90IF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTEwMClcbiAgICAgICAgICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IgPC0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgICAgICAgICByYWlzZSBfZVJSKVxuICAgICAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgICAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgICAgICByYWlzZSBfZVJSKVxuICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgIGFzc2VydCAobm90IF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IpO1xuICAgICAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgbGV0IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIF8pID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBfbWVuaGlyX3MpXG4gICAgfCBfIC0+XG4gICAgICAgIF9tZW5oaXJfZmFpbCAoKVxuXG5hbmQgX21lbmhpcl9lcnJvcmNhc2UgOiBfbWVuaGlyX2VudiAtPiAndHR2X3RhaWwgLT4gX21lbmhpcl9zdGF0ZSAtPiAndHR2X3JldHVybiA9XG4gIGZ1biBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyAtPlxuICAgIG1hdGNoIF9tZW5oaXJfcyB3aXRoXG4gICAgfCBNZW5oaXJTdGF0ZTExNCAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCAoKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgXyksIF8pID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIF9tZW5oaXJfc1xuICAgIHwgTWVuaGlyU3RhdGUxMDIgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICByYWlzZSBfZVJSXG4gICAgfCBNZW5oaXJTdGF0ZTEwMCAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIHJhaXNlIF9lUlJcbiAgICB8IE1lbmhpclN0YXRlOTYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICByYWlzZSBfZVJSXG4gICAgfCBNZW5oaXJTdGF0ZTkyIC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIF8pID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIF9tZW5oaXJfc1xuICAgIHwgTWVuaGlyU3RhdGU4NyAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zLCBfKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBfbWVuaGlyX3NcbiAgICB8IE1lbmhpclN0YXRlNzkgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgX21lbmhpcl9zXG4gICAgfCBNZW5oaXJTdGF0ZTc0IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0ICgoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zKSwgXywgXykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgX21lbmhpcl9zXG4gICAgfCBNZW5oaXJTdGF0ZTY5IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MpID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIF9tZW5oaXJfc1xuICAgIHwgTWVuaGlyU3RhdGU2NyAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBfbWVuaGlyX3NcbiAgICB8IE1lbmhpclN0YXRlNjYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgX21lbmhpcl9zXG4gICAgfCBNZW5oaXJTdGF0ZTYyIC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MpID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIF9tZW5oaXJfc1xuICAgIHwgTWVuaGlyU3RhdGU1OSAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBfbWVuaGlyX3NcbiAgICB8IE1lbmhpclN0YXRlNTggLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgKChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MpLCBfLCBfKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBfbWVuaGlyX3NcbiAgICB8IE1lbmhpclN0YXRlNTMgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgXywgXykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgX21lbmhpcl9zXG4gICAgfCBNZW5oaXJTdGF0ZTQ2IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIF8pID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIF9tZW5oaXJfc1xuICAgIHwgTWVuaGlyU3RhdGU0NCAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zLCBfKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBfbWVuaGlyX3NcbiAgICB8IE1lbmhpclN0YXRlNDIgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgXykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgX21lbmhpcl9zXG4gICAgfCBNZW5oaXJTdGF0ZTQwIC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIF8pID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIF9tZW5oaXJfc1xuICAgIHwgTWVuaGlyU3RhdGUzOCAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zLCBfKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBfbWVuaGlyX3NcbiAgICB8IE1lbmhpclN0YXRlMzUgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgXykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgX21lbmhpcl9zXG4gICAgfCBNZW5oaXJTdGF0ZTMzIC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIF8pID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIF9tZW5oaXJfc1xuICAgIHwgTWVuaGlyU3RhdGUzMSAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zLCBfKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBfbWVuaGlyX3NcbiAgICB8IE1lbmhpclN0YXRlMjkgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgXykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgX21lbmhpcl9zXG4gICAgfCBNZW5oaXJTdGF0ZTI3IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIF8pID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIF9tZW5oaXJfc1xuICAgIHwgTWVuaGlyU3RhdGUyNSAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zLCBfKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBfbWVuaGlyX3NcbiAgICB8IE1lbmhpclN0YXRlMjMgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgXykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgX21lbmhpcl9zXG4gICAgfCBNZW5oaXJTdGF0ZTIxIC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIF8pID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIF9tZW5oaXJfc1xuICAgIHwgTWVuaGlyU3RhdGUxOSAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zLCBfKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBfbWVuaGlyX3NcbiAgICB8IE1lbmhpclN0YXRlMTcgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgXykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgX21lbmhpcl9zXG4gICAgfCBNZW5oaXJTdGF0ZTE1IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIF8pID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIF9tZW5oaXJfc1xuICAgIHwgTWVuaGlyU3RhdGUxMiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBfbWVuaGlyX3NcbiAgICB8IE1lbmhpclN0YXRlMTAgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgX21lbmhpcl9zXG4gICAgfCBNZW5oaXJTdGF0ZTkgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgX21lbmhpcl9zXG4gICAgfCBNZW5oaXJTdGF0ZTggLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgX21lbmhpcl9zXG4gICAgfCBNZW5oaXJTdGF0ZTYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgX21lbmhpcl9zXG4gICAgfCBNZW5oaXJTdGF0ZTUgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgXykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgX21lbmhpcl9zXG4gICAgfCBNZW5oaXJTdGF0ZTMgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgXykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgX21lbmhpcl9zXG4gICAgfCBNZW5oaXJTdGF0ZTEgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgX21lbmhpcl9zXG4gICAgfCBNZW5oaXJTdGF0ZTAgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICByYWlzZSBfZVJSXG5cbmFuZCBfbWVuaGlyX3JlZHVjZTI2IDogX21lbmhpcl9lbnYgLT4gJ3R0dl90YWlsIC0+IF9tZW5oaXJfc3RhdGUgLT4gJ3R0dl9yZXR1cm4gPVxuICBmdW4gX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgLT5cbiAgICBsZXQgX3YgOiAodW5pdCBsaXN0KSA9IFxuIyAyMTEgXCI8c3RhbmRhcmQubWx5PlwiXG4gICAgKCBbXSApXG4jIDI2NzIgXCJJTy9wYXJzZXIubWxcIlxuICAgICBpblxuICAgIF9tZW5oaXJfZ290b19saXN0X0VPTF8gX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgX3ZcblxuYW5kIF9tZW5oaXJfcnVuMSA6IF9tZW5oaXJfZW52IC0+ICd0dHZfdGFpbCAtPiBfbWVuaGlyX3N0YXRlIC0+ICd0dHZfcmV0dXJuID1cbiAgZnVuIF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX21lbmhpcl9zIC0+XG4gICAgbGV0IF9tZW5oaXJfc3RhY2sgPSAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zKSBpblxuICAgIGxldCBfbWVuaGlyX2VudiA9IF9tZW5oaXJfZGlzY2FyZCBfbWVuaGlyX2VudiBpblxuICAgIGxldCBfdG9rID0gX21lbmhpcl9lbnYuX21lbmhpcl90b2tlbiBpblxuICAgIG1hdGNoIF90b2sgd2l0aFxuICAgIHwgRU9MIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuMSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMVxuICAgIHwgRU9GIHwgSEVBREVSIHwgSUQgXyB8IExFRlRfQlJBQ0UgfCBOVU1CRVIgXyAtPlxuICAgICAgICBfbWVuaGlyX3JlZHVjZTI2IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUxXG4gICAgfCBfIC0+XG4gICAgICAgIGFzc2VydCAobm90IF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IpO1xuICAgICAgICBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yIDwtIHRydWU7XG4gICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUxXG5cbmFuZCBfbWVuaGlyX2Rpc2NhcmQgOiBfbWVuaGlyX2VudiAtPiBfbWVuaGlyX2VudiA9XG4gIGZ1biBfbWVuaGlyX2VudiAtPlxuICAgIGxldCBsZXhlciA9IF9tZW5oaXJfZW52Ll9tZW5oaXJfbGV4ZXIgaW5cbiAgICBsZXQgbGV4YnVmID0gX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYgaW5cbiAgICBsZXQgX3RvayA9IGxleGVyIGxleGJ1ZiBpblxuICAgIHtcbiAgICAgIF9tZW5oaXJfbGV4ZXIgPSBsZXhlcjtcbiAgICAgIF9tZW5oaXJfbGV4YnVmID0gbGV4YnVmO1xuICAgICAgX21lbmhpcl90b2tlbiA9IF90b2s7XG4gICAgICBfbWVuaGlyX2Vycm9yID0gZmFsc2U7XG4gICAgfVxuXG5hbmQgYXN0IDogKExleGluZy5sZXhidWYgLT4gdG9rZW4pIC0+IExleGluZy5sZXhidWYgLT4gKFBhcnNlcl9hc3QuYXN0KSA9XG4gIGZ1biBsZXhlciBsZXhidWYgLT5cbiAgICBsZXQgX21lbmhpcl9lbnYgPSB7XG4gICAgICBfbWVuaGlyX2xleGVyID0gbGV4ZXI7XG4gICAgICBfbWVuaGlyX2xleGJ1ZiA9IGxleGJ1ZjtcbiAgICAgIF9tZW5oaXJfdG9rZW4gPSBPYmoubWFnaWMgKCk7XG4gICAgICBfbWVuaGlyX2Vycm9yID0gZmFsc2U7XG4gICAgfSBpblxuICAgIE9iai5tYWdpYyAobGV0IF9tZW5oaXJfc3RhY2sgPSAoKCksIF9tZW5oaXJfZW52Ll9tZW5oaXJfbGV4YnVmLkxleGluZy5sZXhfY3Vycl9wKSBpblxuICAgIGxldCBfbWVuaGlyX2VudiA9IF9tZW5oaXJfZGlzY2FyZCBfbWVuaGlyX2VudiBpblxuICAgIGxldCBfdG9rID0gX21lbmhpcl9lbnYuX21lbmhpcl90b2tlbiBpblxuICAgIG1hdGNoIF90b2sgd2l0aFxuICAgIHwgRU9MIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuMSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMFxuICAgIHwgRU9GIHwgSUQgXyB8IExFRlRfQlJBQ0UgfCBOVU1CRVIgXyAtPlxuICAgICAgICBfbWVuaGlyX3JlZHVjZTI2IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUwXG4gICAgfCBfIC0+XG4gICAgICAgIGFzc2VydCAobm90IF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IpO1xuICAgICAgICBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yIDwtIHRydWU7XG4gICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUwKVxuXG5hbmQgaGVhZGVycyA6IChMZXhpbmcubGV4YnVmIC0+IHRva2VuKSAtPiBMZXhpbmcubGV4YnVmIC0+IChQcmVwcm9jZXNzLmhlYWRlcnMpID1cbiAgZnVuIGxleGVyIGxleGJ1ZiAtPlxuICAgIGxldCBfbWVuaGlyX2VudiA9IHtcbiAgICAgIF9tZW5oaXJfbGV4ZXIgPSBsZXhlcjtcbiAgICAgIF9tZW5oaXJfbGV4YnVmID0gbGV4YnVmO1xuICAgICAgX21lbmhpcl90b2tlbiA9IE9iai5tYWdpYyAoKTtcbiAgICAgIF9tZW5oaXJfZXJyb3IgPSBmYWxzZTtcbiAgICB9IGluXG4gICAgT2JqLm1hZ2ljIChsZXQgX21lbmhpcl9zdGFjayA9ICgoKSwgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9jdXJyX3ApIGluXG4gICAgbGV0IF9tZW5oaXJfZW52ID0gX21lbmhpcl9kaXNjYXJkIF9tZW5oaXJfZW52IGluXG4gICAgbGV0IF90b2sgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX3Rva2VuIGluXG4gICAgbWF0Y2ggX3RvayB3aXRoXG4gICAgfCBFT0wgLT5cbiAgICAgICAgX21lbmhpcl9ydW4xIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU5NlxuICAgIHwgSEVBREVSIHwgSUQgXyAtPlxuICAgICAgICBfbWVuaGlyX3JlZHVjZTI2IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU5NlxuICAgIHwgXyAtPlxuICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlOTYpXG5cbiMgMjY5IFwiPHN0YW5kYXJkLm1seT5cIlxuICBcblxuIyAyNzQ4IFwiSU8vcGFyc2VyLm1sXCJcbiIsIiV7IG9wZW4gUGFyc2VyX2FzdCAlfVxuJXsgb3BlbiBQcmVwcm9jZXNzICV9XG5cbiV0b2tlbiBIRUFERVJcbiV0b2tlbiBOVUxMXG4ldG9rZW4gRVFVQUxcbiV0b2tlbiA8c3RyaW5nPiBTVFJJTkdcbiV0b2tlbiA8aW50MzI+IE5VTUJFUlxuJXRva2VuIDxib29sPiBCT09MXG4ldG9rZW4gPHN0cmluZz4gSURcbiV0b2tlbiBIQVNIXG4ldG9rZW4gTEVGVF9CUkFDS1xuJXRva2VuIFJJR0hUX0JSQUNLXG4ldG9rZW4gTEVGVF9CUkFDRVxuJXRva2VuIFJJR0hUX0JSQUNFXG4ldG9rZW4gTFBBUkVOXG4ldG9rZW4gUlBBUkVOXG4ldG9rZW4gTFNISUZUXG4ldG9rZW4gUlNISUZUXG4ldG9rZW4gQ09NTUFcbiV0b2tlbiBFWENMQU1fTUFSS1xuJXRva2VuIElOVEVSUk9HX01BUktcbiV0b2tlbiBDT0xPTlxuJXRva2VuIFRJTUVTXG4ldG9rZW4gRElWXG4ldG9rZW4gTU9EXG4ldG9rZW4gUExVU1xuJXRva2VuIE1JTlVTXG4ldG9rZW4gQU5EXG4ldG9rZW4gT1JcbiV0b2tlbiBYT1JcbiV0b2tlbiBOT1RcbiV0b2tlbiBFUVxuJXRva2VuIE5FUVxuJXRva2VuIEJPUlxuJXRva2VuIEJBTkRcbiV0b2tlbiBFT0xcbiV0b2tlbiBFT0ZcblxuJW5vbmFzc29jIEFSR1xuJW5vbmFzc29jIENPTU1BXG5cbiVyaWdodCBJTlRFUlJPR19NQVJLIENPTE9OXG4lbGVmdCBCT1JcbiVsZWZ0IEJBTkRcbiVsZWZ0IE9SXG4lbGVmdCBYT1JcbiVsZWZ0IEFORFxuJWxlZnQgRVEgTkVRXG4lbGVmdCBMU0hJRlQgUlNISUZUXG4lbGVmdCBQTFVTIE1JTlVTXG4lbGVmdCBUSU1FUyBESVYgTU9EXG4lbm9uYXNzb2MgRVhDTEFNX01BUksgTk9UIFVQTFVTIFVNSU5VU1xuXG4lc3RhcnQgPFBhcnNlcl9hc3QuYXN0PiBhc3RcbiVzdGFydCA8UHJlcHJvY2Vzcy5oZWFkZXJzPiBoZWFkZXJzXG4lJVxuXG5tZXRhX2V4cHI6XG4gIHwgaSA9IE5VTUJFUiB7IE1Db25zdCBpIH1cbiAgfCB2ID0gSUQgeyBNVmFyIHYgfVxuICB8IExQQVJFTiBlID0gbWV0YV9leHByIFJQQVJFTiB7IGUgfVxuICB8IGUxID0gbWV0YV9leHByIFBMVVMgZTIgPSBtZXRhX2V4cHIgeyBNQmluYXJ5IChPQWRkLCBlMSwgZTIpIH1cbiAgfCBlMSA9IG1ldGFfZXhwciBNSU5VUyBlMiA9IG1ldGFfZXhwciB7IE1CaW5hcnkgKE9TdWIsIGUxLCBlMikgfVxuICB8IGUxID0gbWV0YV9leHByIFRJTUVTIGUyID0gbWV0YV9leHByIHsgTUJpbmFyeSAoT011bCwgZTEsIGUyKSB9XG4gIHwgZTEgPSBtZXRhX2V4cHIgRElWIGUyID0gbWV0YV9leHByIHsgTUJpbmFyeSAoT0RpdiwgZTEsIGUyKSB9XG4gIHwgZTEgPSBtZXRhX2V4cHIgTU9EIGUyID0gbWV0YV9leHByIHsgTUJpbmFyeSAoT01vZCwgZTEsIGUyKSB9XG4gIHwgZTEgPSBtZXRhX2V4cHIgQU5EIGUyID0gbWV0YV9leHByIHsgTUJpbmFyeSAoT0FuZCwgZTEsIGUyKSB9XG4gIHwgZTEgPSBtZXRhX2V4cHIgWE9SIGUyID0gbWV0YV9leHByIHsgTUJpbmFyeSAoT1hvciwgZTEsIGUyKSB9XG4gIHwgZTEgPSBtZXRhX2V4cHIgT1IgZTIgPSBtZXRhX2V4cHIgeyBNQmluYXJ5IChPT3IsIGUxLCBlMikgfVxuICB8IGUxID0gbWV0YV9leHByIEJPUiBlMiA9IG1ldGFfZXhwciB7IE1CaW5hcnkgKE9CT3IsIGUxLCBlMikgfVxuICB8IGUxID0gbWV0YV9leHByIEJBTkQgZTIgPSBtZXRhX2V4cHIgeyBNQmluYXJ5IChPQkFuZCwgZTEsIGUyKSB9XG4gIHwgZTEgPSBtZXRhX2V4cHIgRVEgZTIgPSBtZXRhX2V4cHIgeyBNQmluYXJ5IChPRXEsIGUxLCBlMikgfVxuICB8IGUxID0gbWV0YV9leHByIE5FUSBlMiA9IG1ldGFfZXhwciB7IE1CaW5hcnkgKE9OZXEsIGUxLCBlMikgfVxuICB8IGUxID0gbWV0YV9leHByIExTSElGVCBlMiA9IG1ldGFfZXhwciB7IE1CaW5hcnkgKE9MU2hpZnQsIGUxLCBlMikgfVxuICB8IGUxID0gbWV0YV9leHByIFJTSElGVCBlMiA9IG1ldGFfZXhwciB7IE1CaW5hcnkgKE9SU2hpZnQsIGUxLCBlMikgfVxuICB8IFBMVVMgZSA9IG1ldGFfZXhwciAlcHJlYyBVUExVUyB7IE1VbmFyeSAoT0lkLCBlKSB9XG4gIHwgTUlOVVMgZSA9IG1ldGFfZXhwciAlcHJlYyBVTUlOVVMgeyBNVW5hcnkgKE9OZWcsIGUpIH1cbiAgfCBOT1QgZSA9IG1ldGFfZXhwciB7IE1VbmFyeSAoT05vdCwgZSkgfVxuICB8IEVYQ0xBTV9NQVJLIGUgPSBtZXRhX2V4cHIgeyBNVW5hcnkgKE9CTm90LCBlKSB9XG4gIHwgZTAgPSBtZXRhX2V4cHIgSU5URVJST0dfTUFSSyBlMSA9IG1ldGFfZXhwciBDT0xPTiBlMiA9IG1ldGFfZXhwclxuICB7IE1Db25kIChlMCwgZTEsIGUyKSB9XG5cbmRlZmluaXRpb246XG4gIHwgSEVBREVSIDsgaWQgPSBJRCA7IEVRVUFMIDsgc3RyID0gU1RSSU5HIHsgUGFyYW0gKGlkLCBIU3RyaW5nIHN0cikgfVxuICB8IEhFQURFUiA7IGlkID0gSUQgOyBFUVVBTCA7IG5iID0gTlVNQkVSIHsgUGFyYW0gKGlkLCBISW50IG5iKSB9XG4gIHwgSEVBREVSIDsgaWQgPSBJRCA7IEVRVUFMIDsgYiA9IEJPT0wgeyBQYXJhbSAoaWQsIEhCb29sIGIpIH1cbiAgfCBIRUFERVIgOyBpZCA9IElEIDsgRVFVQUwgOyBOVUxMIHsgUGFyYW0gKGlkLCBITm9uZSkgfVxuICB8IGlkID0gSUQgOyBFUVVBTCA7IGUgPSBtZXRhX2V4cHIgeyBWYXJEZWYgKGlkLCBmYWxzZSwgZSkgfVxuICB8IGlkID0gSUQgOyBJTlRFUlJPR19NQVJLIDsgRVFVQUwgOyBlID0gbWV0YV9leHByIHsgVmFyRGVmIChpZCwgdHJ1ZSwgZSkgfVxuICA7XG5cbmhlYWRlcnM6XG4gIHwgbGlzdCAoRU9MKSA7IEhFQURFUiA7IEVPTCB8IGxpc3QgKEVPTCkgOyBIRUFERVIgOyBFT0YgeyBbXSB9XG4gIHwgbGlzdCAoRU9MKSA7IGQgPSBkZWZpbml0aW9uIDsgRU9MIDsgZHMgPSBoZWFkZXJzIHsgZDo6ZHMgfVxuICA7XG5cbmFzdDpcbiAgfCBsaXN0IChFT0wpIDsgRU9GIHsgW10gfVxuICB8IGxpc3QgKEVPTCkgOyBjbWQgPSBjb21tYW5kIDsgRU9MIDsgY21kcyA9IGFzdCB7IGNtZDo6Y21kcyB9XG4gIHwgbGlzdCAoRU9MKSA7IGNtZCA9IGNvbW1hbmQgOyBFT0YgeyBbY21kXSB9XG4gIDtcblxuY29tbWFuZDpcbiAgfCBpZCA9IElEIDsgYXJncyA9IHNlcGFyYXRlZF9saXN0KENPTU1BLCBhcmcpIHsgQVNNICgkc3RhcnRwb3MsIGlkLCBhcmdzLCBPcHRpbWl6ZXIuTm9Ud2Vha2luZykgfVxuICB8IGlkID0gSUQgOyBhcmdzID0gc2VwYXJhdGVkX2xpc3QoQ09NTUEsIGFyZykgOyBJTlRFUlJPR19NQVJLIHsgQVNNICgkc3RhcnRwb3MsIGlkLCBhcmdzLCBPcHRpbWl6ZXIuVHdlYWtNaW5MZW5ndGgpIH1cbiAgfCBpZCA9IElEIDsgYXJncyA9IHNlcGFyYXRlZF9saXN0KENPTU1BLCBhcmcpIDsgSU5URVJST0dfTUFSSyA7IGkgPSBOVU1CRVJcbiAgeyBBU00gKCRzdGFydHBvcywgaWQsIGFyZ3MsIE9wdGltaXplci5Ud2Vha0ZpeGVkTGVuZ3RoIChVdGlscy51aW50MzJfdG9faW50IGkpKSB9XG4gIHwgbmIgPSBudW1iZXIgeyBCSU4gKCRzdGFydHBvcywgbmIpIH1cbiAgO1xuXG5hcmc6XG4gIHwgaWQgPSBJRCB7IFJlZ2lzdGVyIGlkIH1cbiAgfCBIQVNIIDsgaSA9IG51bWJlciB8IGkgPSBudW1iZXIgeyBJbW1lZGlhdGUgaSB9XG4gIHwgTEVGVF9CUkFDSyA7IGlkID0gSUQgOyBDT01NQSA7IG8gPSBvZmZzZXQgOyBSSUdIVF9CUkFDSyB7IE9mZnNldCAoaWQsIG8sIEFybS5PZmZzZXQpIH1cbiAgfCBMRUZUX0JSQUNLIDsgaWQgPSBJRCA7IFJJR0hUX0JSQUNLICVwcmVjIEFSR1xuICB7IE9mZnNldCAoaWQsIE9JbW1lZGlhdGUgKEFybS5zaWduX3BsdXMsIENvbnN0SW50MzIgSW50MzIuemVybyksIEFybS5PZmZzZXQpIH1cbiAgfCBMRUZUX0JSQUNLIDsgaWQgPSBJRCA7IENPTU1BIDsgbyA9IG9mZnNldCA7IFJJR0hUX0JSQUNLIDsgRVhDTEFNX01BUksgeyBPZmZzZXQgKGlkLCBvLCBBcm0uUHJlSW5kZXhlZCkgfVxuICB8IExFRlRfQlJBQ0sgOyBpZCA9IElEIDsgUklHSFRfQlJBQ0sgOyBFWENMQU1fTUFSS1xuICB7IE9mZnNldCAoaWQsIE9JbW1lZGlhdGUgKEFybS5zaWduX3BsdXMsIENvbnN0SW50MzIgSW50MzIuemVybyksIEFybS5QcmVJbmRleGVkKSB9XG4gIHwgTEVGVF9CUkFDSyA7IGlkID0gSUQgOyBSSUdIVF9CUkFDSyA7IENPTU1BIDsgbyA9IG9mZnNldCB7IE9mZnNldCAoaWQsIG8sIEFybS5Qb3N0SW5kZXhlZCkgfVxuICA7XG5cbm9mZnNldDpcbiAgfCBIQVNIIDsgaSA9IG51bWJlciB8IEhBU0ggOyBQTFVTIDsgaSA9IG51bWJlciB8IGkgPSBudW1iZXIgfCBQTFVTIDsgaSA9IG51bWJlclxuICB7IE9JbW1lZGlhdGUgKEFybS5zaWduX3BsdXMsIGkpIH1cbiAgfCBIQVNIIDsgTUlOVVMgOyBpID0gbnVtYmVyIHwgTUlOVVMgOyBpID0gbnVtYmVyIHsgT0ltbWVkaWF0ZSAoQXJtLnNpZ25fbWludXMsIGkpIH1cbiAgfCBpZCA9IElEIHwgUExVUyA7IGlkID0gSUQgeyBPUmVnaXN0ZXIgKEFybS5zaWduX3BsdXMsIGlkKSB9XG4gIHwgTUlOVVMgOyBpZCA9IElEIHsgT1JlZ2lzdGVyIChBcm0uc2lnbl9taW51cywgaWQpIH1cbiAgO1xuXG5udW1iZXI6XG4gIHwgaSA9IE5VTUJFUiB7IENvbnN0SW50MzIgaSB9XG4gIHwgTEVGVF9CUkFDRSA7IGU9bWV0YV9leHByIDsgUklHSFRfQlJBQ0UgeyBNZXRhRXhwciBlIH1cbiAgOyIsIntcbm9wZW4gTGV4aW5nXG5vcGVuIFBhcnNlclxuXG5leGNlcHRpb24gU3ludGF4RXJyb3Igb2Ygc3RyaW5nXG5cbmxldCBuZXh0X2xpbmUgbGV4YnVmID1cbiAgbGV0IHBvcyA9IGxleGJ1Zi5sZXhfY3Vycl9wIGluXG4gIGxleGJ1Zi5sZXhfY3Vycl9wIDwtXG4gICAgeyBwb3Mgd2l0aCBwb3NfYm9sID0gbGV4YnVmLmxleF9jdXJyX3BvcztcbiAgICAgICAgICAgICAgIHBvc19sbnVtID0gcG9zLnBvc19sbnVtICsgMVxuICAgIH1cblxubGV0IGVvZl9yZWFjaGVkIGxleGJ1ZiA9XG4gIGxleGJ1Zi5sZXhfZW9mX3JlYWNoZWQgPC0gdHJ1ZVxufVxuXG5sZXQgZGRpZ2l0ID0gWycwJy0nOSddXG5sZXQgaGRpZ2l0ID0gWycwJy0nOScgJ2EnLSdmJyAnQSctJ0YnXVxubGV0IGJkaWdpdCA9IFsnMCctJzEnXVxubGV0IG9kaWdpdCA9IFsnMCctJzcnXVxuXG5sZXQgZHByZWZpeCA9IFwiMHVcIiB8IFwiMFVcIlxubGV0IGhwcmVmaXggPSBcIjB4XCIgfCBcIjBYXCJcbmxldCBicHJlZml4ID0gXCIwYlwiIHwgXCIwQlwiXG5sZXQgb3ByZWZpeCA9IFwiMG9cIiB8IFwiME9cIlxuXG5sZXQgZG51bWJlciA9IGRwcmVmaXg/IGRkaWdpdCtcbmxldCBobnVtYmVyID0gaHByZWZpeCBoZGlnaXQrXG5sZXQgYm51bWJlciA9IGJwcmVmaXggYmRpZ2l0K1xubGV0IG9udW1iZXIgPSBvcHJlZml4IG9kaWdpdCtcblxubGV0IG51bWJlciA9IGRudW1iZXIgfCBobnVtYmVyIHwgYm51bWJlciB8IG9udW1iZXJcblxubGV0IGNvbW1lbnQgPSBcIkBcIiB8IFwiJSVcIiB8IFwiO1wiIHwgXCIvL1wiXG5cbmxldCB3aGl0ZSA9IFsnICcgJ1xcdCddK1xubGV0IG5ld2xpbmUgPSAnXFxyJyB8ICdcXG4nIHwgXCJcXHJcXG5cIlxubGV0IGlkID0gWydhJy0neicgJ0EnLSdaJyAnXyddIFsnYSctJ3onICdBJy0nWicgJzAnLSc5JyAnXyddKlxuXG5sZXQgZmlsZV9zZXBhcmF0b3IgPSBcIj09PT09XCIgJz0nKlxuXG5ydWxlIHJlYWQgPSBwYXJzZVxuICB8IGZpbGVfc2VwYXJhdG9yIHsgRU9GIH1cbiAgfCBcIkBAXCIgICAgICB7IEhFQURFUiB9XG4gIHwgXCJudWxsXCIgICAgeyBOVUxMIH1cbiAgfCBcInRydWVcIiAgICB7IEJPT0wgdHJ1ZSB9XG4gIHwgXCJmYWxzZVwiICAgeyBCT09MIGZhbHNlIH1cbiAgfCBcIjw8XCIgICAgICB7IExTSElGVCB9XG4gIHwgXCI+PlwiICAgICAgeyBSU0hJRlQgfVxuICB8IFwiPT1cIiAgICAgIHsgRVEgfVxuICB8IFwiIT1cIiAgICAgIHsgTkVRIH1cbiAgfCBcInx8XCIgICAgICB7IEJPUiB9XG4gIHwgXCImJlwiICAgICAgeyBCQU5EIH1cbiAgfCBjb21tZW50ICAgeyByZWFkX2NvbW1lbnQgbGV4YnVmIH1cbiAgfCB3aGl0ZSAgICAgeyByZWFkIGxleGJ1ZiB9XG4gIHwgJ1xcXFwnIG5ld2xpbmUgeyBuZXh0X2xpbmUgbGV4YnVmIDsgcmVhZCBsZXhidWYgfVxuICB8IG5ld2xpbmUgICB7IG5leHRfbGluZSBsZXhidWYgOyBFT0wgfVxuICB8IG51bWJlciAgICB7IE5VTUJFUiAoVXRpbHMudWludDMyX29mX3N0ciAoTGV4aW5nLmxleGVtZSBsZXhidWYpKSB9XG4gIHwgaWQgICAgICAgIHsgSUQgKExleGluZy5sZXhlbWUgbGV4YnVmKSB9XG4gIHwgJ1wiJyAgICAgICB7IHJlYWRfc3RyaW5nIChCdWZmZXIuY3JlYXRlIDE3KSBsZXhidWYgfVxuICB8ICc9JyAgICAgICB7IEVRVUFMIH1cbiAgfCAnIycgICAgICAgeyBIQVNIIH1cbiAgfCAnWycgICAgICAgeyBMRUZUX0JSQUNLIH1cbiAgfCAnXScgICAgICAgeyBSSUdIVF9CUkFDSyB9XG4gIHwgJ3snICAgICAgIHsgTEVGVF9CUkFDRSB9XG4gIHwgJ30nICAgICAgIHsgUklHSFRfQlJBQ0UgfVxuICB8ICcsJyAgICAgICB7IENPTU1BIH1cbiAgfCAnIScgICAgICAgeyBFWENMQU1fTUFSSyB9XG4gIHwgJz8nICAgICAgIHsgSU5URVJST0dfTUFSSyB9XG4gIHwgJzonICAgICAgIHsgQ09MT04gfVxuICB8ICcoJyAgICAgICB7IExQQVJFTiB9XG4gIHwgJyknICAgICAgIHsgUlBBUkVOIH1cbiAgfCAnKycgICAgICAgeyBQTFVTIH1cbiAgfCAnLScgICAgICAgeyBNSU5VUyB9XG4gIHwgJyonICAgICAgIHsgVElNRVMgfVxuICB8ICcvJyAgICAgICB7IERJViB9XG4gIHwgJyUnICAgICAgIHsgTU9EIH1cbiAgfCAnJicgICAgICAgeyBBTkQgfVxuICB8ICd8JyAgICAgICB7IE9SIH1cbiAgfCAnXicgICAgICAgeyBYT1IgfVxuICB8ICd+JyAgICAgICB7IE5PVCB9XG4gIHwgZW9mICAgICAgIHsgZW9mX3JlYWNoZWQgbGV4YnVmIDsgRU9GIH1cbiAgfCBfIHsgcmFpc2UgKFN5bnRheEVycm9yIChcIlVuZXhwZWN0ZWQgY2hhcjogXCIgXiBMZXhpbmcubGV4ZW1lIGxleGJ1ZikpIH1cblxuYW5kIHJlYWRfc3RyaW5nIGJ1ZiA9IHBhcnNlXG4gIHwgJ1wiJyAgICAgICB7IFNUUklORyAoQnVmZmVyLmNvbnRlbnRzIGJ1ZikgfVxuICB8ICdcXFxcJyAnLycgIHsgQnVmZmVyLmFkZF9jaGFyIGJ1ZiAnLyc7IHJlYWRfc3RyaW5nIGJ1ZiBsZXhidWYgfVxuICB8ICdcXFxcJyAnXFxcXCcgeyBCdWZmZXIuYWRkX2NoYXIgYnVmICdcXFxcJzsgcmVhZF9zdHJpbmcgYnVmIGxleGJ1ZiB9XG4gIHwgJ1xcXFwnICdiJyAgeyBCdWZmZXIuYWRkX2NoYXIgYnVmICdcXGInOyByZWFkX3N0cmluZyBidWYgbGV4YnVmIH1cbiAgfCAnXFxcXCcgJ2YnICB7IEJ1ZmZlci5hZGRfY2hhciBidWYgJ1xcMDEyJzsgcmVhZF9zdHJpbmcgYnVmIGxleGJ1ZiB9XG4gIHwgJ1xcXFwnICduJyAgeyBCdWZmZXIuYWRkX2NoYXIgYnVmICdcXG4nOyByZWFkX3N0cmluZyBidWYgbGV4YnVmIH1cbiAgfCAnXFxcXCcgJ3InICB7IEJ1ZmZlci5hZGRfY2hhciBidWYgJ1xccic7IHJlYWRfc3RyaW5nIGJ1ZiBsZXhidWYgfVxuICB8ICdcXFxcJyAndCcgIHsgQnVmZmVyLmFkZF9jaGFyIGJ1ZiAnXFx0JzsgcmVhZF9zdHJpbmcgYnVmIGxleGJ1ZiB9XG4gIHwgW14gJ1wiJyAnXFxcXCcgJ1xccicgJ1xcbiddK1xuICAgIHsgQnVmZmVyLmFkZF9zdHJpbmcgYnVmIChMZXhpbmcubGV4ZW1lIGxleGJ1Zik7XG4gICAgICByZWFkX3N0cmluZyBidWYgbGV4YnVmXG4gICAgfVxuICB8IG5ld2xpbmUgeyByYWlzZSAoU3ludGF4RXJyb3IgKFwiU3RyaW5nIGNhbm5vdCBiZSBtdWx0aWxpbmVcIikpIH1cbiAgfCBlb2YgeyByYWlzZSAoU3ludGF4RXJyb3IgKFwiU3RyaW5nIGlzIG5vdCB0ZXJtaW5hdGVkXCIpKSB9XG4gIHwgXyB7IHJhaXNlIChTeW50YXhFcnJvciAoXCJJbGxlZ2FsIHN0cmluZyBjaGFyYWN0ZXI6IFwiIF4gTGV4aW5nLmxleGVtZSBsZXhidWYpKSB9XG5cbmFuZCByZWFkX2NvbW1lbnQgPSBwYXJzZVxuICB8IG5ld2xpbmUgeyBuZXh0X2xpbmUgbGV4YnVmIDsgRU9MIH1cbiAgfCBlb2YgeyBlb2ZfcmVhY2hlZCBsZXhidWYgOyBFT0YgfVxuICB8IF8geyByZWFkX2NvbW1lbnQgbGV4YnVmIH0iLCJvcGVuIExleGVyXG5vcGVuIExleGluZ1xuXG5leGNlcHRpb24gSW52YWxpZENvbnRlbnQgb2Ygc3RyaW5nXG5cbnR5cGUgcGFyc2VkX2NvbnRlbnQgPVxuICBQcmVwcm9jZXNzLmhlYWRlcnMgKiBQYXJzZXJfYXN0LmFzdFxuXG5sZXQgcHJpbnRfcG9zaXRpb24gZm10IHBvcyA9XG4gIEZvcm1hdC5mcHJpbnRmIGZtdCBcIiVzOiVkOiVkXCIgcG9zLnBvc19mbmFtZVxuICAgIHBvcy5wb3NfbG51bSAocG9zLnBvc19jbnVtIC0gcG9zLnBvc19ib2wgKyAxKVxuXG5sZXQgcHJpbnRfbGV4YnVmX3BvcyBmbXQgbGV4YnVmID1cbiAgcHJpbnRfcG9zaXRpb24gZm10IGxleGJ1Zi5sZXhfY3Vycl9wXG5cbmxldCBwYXJzZV93aXRoX2Vycm9yIGYgbGV4YnVmID1cbiAgdHJ5IGYgbGV4YnVmIHdpdGhcbiAgfCBTeW50YXhFcnJvciBtc2cgLT5cbiAgICByYWlzZSAoSW52YWxpZENvbnRlbnRcbiAgICAgIChGb3JtYXQuYXNwcmludGYgXCIlYTogJXNcXG5cIiBwcmludF9sZXhidWZfcG9zIGxleGJ1ZiBtc2cpKVxuICB8IFBhcnNlci5FcnJvciAtPlxuICAgIHJhaXNlIChJbnZhbGlkQ29udGVudFxuICAgICAgKEZvcm1hdC5hc3ByaW50ZiBcIiVhOiBwYXJzZXIgZXJyb3JcXG5cIiBwcmludF9sZXhidWZfcG9zIGxleGJ1ZikpXG5cbmxldCBmcm9tX2xleGJ1ZiB+aGVhZGVycyBsZXhidWYgPVxuICBsZXQgaGVhZGVycyA9XG4gICAgaWYgaGVhZGVyc1xuICAgIHRoZW4gcGFyc2Vfd2l0aF9lcnJvciAoUGFyc2VyLmhlYWRlcnMgTGV4ZXIucmVhZCkgbGV4YnVmXG4gICAgZWxzZSBbXVxuICBpblxuICBsZXQgYXN0ID0gcGFyc2Vfd2l0aF9lcnJvciAoUGFyc2VyLmFzdCBMZXhlci5yZWFkKSBsZXhidWYgaW5cbiAgKGhlYWRlcnMsIGFzdClcblxubGV0IGZyb21fZmlsZW5hbWUgfmhlYWRlcnMgZmlsZW5hbWUgPVxuICBsZXQgY2hhbm5lbCA9IG9wZW5faW4gZmlsZW5hbWUgaW5cbiAgbGV0IGxleGJ1ZiA9IExleGluZy5mcm9tX2NoYW5uZWwgY2hhbm5lbCBpblxuICBsZXhidWYubGV4X2N1cnJfcCA8LSB7IGxleGJ1Zi5sZXhfY3Vycl9wIHdpdGggcG9zX2ZuYW1lID0gZmlsZW5hbWUgfTtcbiAgbGV0IHJlcyA9IGZyb21fbGV4YnVmIH5oZWFkZXJzIGxleGJ1ZiBpblxuICBjbG9zZV9pbiBjaGFubmVsIDsgcmVzXG5cbmxldCBmcm9tX3N0ciB+aGVhZGVycyBzdHIgPVxuICBMZXhpbmcuZnJvbV9zdHJpbmcgc3RyIHw+IGZyb21fbGV4YnVmIH5oZWFkZXJzXG5cbmxldCBwYXJzZWRfYXN0X3RvX2FybSB+b3B0aW1pemUgZW52IGxzdCA9XG4gIHRyeVxuICAgIFBhcnNlcl9hc3QudG9fYXJtIGVudiBsc3QgfD5cbiAgICBpZiBvcHRpbWl6ZSB0aGVuIE9wdGltaXplci50d2Vha19hcm0gZWxzZSBPcHRpbWl6ZXIuZG9fbm90X3R3ZWFrX2FybVxuICB3aXRoIFBhcnNlcl9hc3QuQ29tbWFuZEVycm9yIHBvcyAtPlxuICAgIHJhaXNlIChJbnZhbGlkQ29udGVudFxuICAgICAgKEZvcm1hdC5hc3ByaW50ZiBcIiVhOiBjb21tYW5kIGVycm9yXFxuXCIgcHJpbnRfcG9zaXRpb24gcG9zKVxuICAgIClcblxubGV0IHBhcnNlZF9jb250ZW50X3RvX2FybSBmbXQgfm9wdGltaXplIGVudiAoaGVhZGVycywgbHN0KSA9XG4gIGxldCBlbnYgPVxuICAgIFByZXByb2Nlc3MuZW52X2Zyb21faGVhZGVycyBmbXQgaGVhZGVycyB8PlxuICAgIFByZXByb2Nlc3MuY29uY2F0X2VudiBlbnYgaW5cbiAgcGFyc2VkX2FzdF90b19hcm0gfm9wdGltaXplIGVudiBsc3RcbiIsIlxubW9kdWxlIFN0ck1hcCA9IE1hcC5NYWtlKFN0cmluZylcblxudHlwZSB0ID0gUGFyc2UucGFyc2VkX2NvbnRlbnQgKiAoUGFyc2UucGFyc2VkX2NvbnRlbnQgU3RyTWFwLnQpXG5cbmxldCByZWMgYWRkX2ZpbGVzIGxleGJ1ZiBhY2MgPVxuICBpZiBsZXhidWYuTGV4aW5nLmxleF9lb2ZfcmVhY2hlZCB0aGVuIGFjY1xuICBlbHNlIChcbiAgICBsZXQgKGhlYWRlcnMsIGFybSkgPSBQYXJzZS5mcm9tX2xleGJ1ZiB+aGVhZGVyczp0cnVlIGxleGJ1ZiBpblxuICAgIGxldCBmbiA9XG4gICAgICBtYXRjaCBQcmVwcm9jZXNzLmdldF9wYXJhbSBoZWFkZXJzIFwiZmlsZW5hbWVcIiB3aXRoXG4gICAgICB8IEhOb25lIC0+IGZhaWx3aXRoIFwiUGxlYXNlIHNwZWNpZnkgdGhlICdmaWxlbmFtZScgaGVhZGVyIGV2ZXJ5d2hlcmUuXCJcbiAgICAgIHwgSFN0cmluZyBmbiAtPiBmblxuICAgICAgfCBfIC0+IGZhaWx3aXRoIFwiSW52YWxpZCBoZWFkZXJzLlwiXG4gICAgaW5cbiAgICBTdHJNYXAuYWRkIGZuIChoZWFkZXJzLCBhcm0pIGFjYyB8PiBhZGRfZmlsZXMgbGV4YnVmXG4gIClcblxubGV0IHBhcnNlIGxleGJ1ZiA9XG4gIGxleGJ1Zi5MZXhpbmcubGV4X2VvZl9yZWFjaGVkIDwtIGZhbHNlIDtcbiAgbGV0IG1haW5fZmlsZSA9IFBhcnNlLmZyb21fbGV4YnVmIH5oZWFkZXJzOnRydWUgbGV4YnVmIGluXG4gIGxldCBmaWxlcyA9IGFkZF9maWxlcyBsZXhidWYgU3RyTWFwLmVtcHR5IGluXG4gIChtYWluX2ZpbGUsIGZpbGVzKVxuXG5sZXQgZnJvbV9maWxlbmFtZSBmaWxlbmFtZSA9XG4gIGxldCBjaGFubmVsID0gb3Blbl9pbiBmaWxlbmFtZSBpblxuICBsZXQgbGV4YnVmID0gTGV4aW5nLmZyb21fY2hhbm5lbCBjaGFubmVsIGluXG4gIGxleGJ1Zi5sZXhfY3Vycl9wIDwtIHsgbGV4YnVmLmxleF9jdXJyX3Agd2l0aCBwb3NfZm5hbWUgPSBmaWxlbmFtZSB9O1xuICBsZXQgcmVzID0gcGFyc2UgbGV4YnVmIGluXG4gIGNsb3NlX2luIGNoYW5uZWwgOyByZXNcblxubGV0IGZyb21fc3RyIHN0ciA9XG4gIExleGluZy5mcm9tX3N0cmluZyBzdHIgfD4gcGFyc2VcblxubGV0IG1haW5fZmlsZSAobWYsIF8pID0gbWZcblxubGV0IGdldF9maWxlIG5hbWUgKF8sIGZpbGVzKSA9XG4gIFN0ck1hcC5maW5kIG5hbWUgZmlsZXNcbiIsIlxudHlwZSB0ID0gKChpbnQgKiAoKGludCBsaXN0KSBsaXN0KSkgbGlzdCkgKiAoKChpbnQgbGlzdCkgbGlzdCkgb3B0aW9uKVxuXG5sZXQgbG9hZF9mcm9tX2RpciBlbnYgZGlybmFtZSA9XG4gIHRyeSAoXG4gICAgVXRpbHMuZW51bWVyYXRlX2ZpbGVzIGRpcm5hbWUgXCIudHh0XCJcbiAgICB8PiBMaXN0Lm1hcCAoZnVuIHggLT5cbiAgICAgIGxldCBwYXRoID0gRmlsZW5hbWUuY29uY2F0IGRpcm5hbWUgeCBpblxuICAgICAgbGV0IHN0ciA9IEZpbGVuYW1lLmJhc2VuYW1lIHggfD4gRmlsZW5hbWUucmVtb3ZlX2V4dGVuc2lvbiBpblxuICAgICAgbGV0IGkgPSBpbnRfb2Zfc3RyaW5nIHN0ciBpblxuICAgICAgbGV0IGFybSA9IFBhcnNlLmZyb21fZmlsZW5hbWUgfmhlYWRlcnM6ZmFsc2UgcGF0aCB8PlxuICAgICAgICBQYXJzZS5wYXJzZWRfY29udGVudF90b19hcm0gVXRpbHMuZHVtbXlfZm10IH5vcHRpbWl6ZTpmYWxzZSBlbnYgaW5cbiAgICAgIGxldCBjb2RlcyA9IGFybSB8PlxuICAgICAgICBMaXN0Lm1hcCAoZnVuIGFybSAtPlxuICAgICAgICAgIEFybS5hcm1fdG9fYmluYXJ5IGFybSB8PlxuICAgICAgICAgIExpc3QubWFwIE5hbWUuY29kZXNfZm9yX2NvbW1hbmQgfD5cbiAgICAgICAgICBOYW1lLnByZWZlcnJlZF9jb2RlXG4gICAgICAgIClcbiAgICAgIGluXG4gICAgICAoaSwgY29kZXMpXG4gICAgKVxuICAgIHw+IExpc3Quc29ydCAoZnVuIChpLF8pIChqLF8pIC0+IGNvbXBhcmUgaSBqKVxuICAgIHw+IChmdW4geCAtPiAoeCwgTm9uZSkpXG4gIClcbiAgd2l0aCBPcHRpbWl6ZXIuQ2Fubm90T3B0aW1pemUgLT5cbiAgICBmYWlsd2l0aCBcIkV4aXQgY29kZXMgY2Fubm90IGJlIHR3ZWFrZWQgKHBsZWFzZSByZW1vdmUgaW50ZXJyb2dhdGlvbiBtYXJrcykuXCJcblxubGV0IGxvYWRfZnJvbV9wYXJzZWRfZmlsZSBmbXQgZW52IChoLCBhcm0pID1cbiAgbGV0IGNvZGVzID0gKGgsIGFybSkgfD5cbiAgICBQYXJzZS5wYXJzZWRfY29udGVudF90b19hcm0gZm10IH5vcHRpbWl6ZTp0cnVlIGVudiB8PlxuICAgIExpc3QubWFwIChmdW4gYXJtIC0+XG4gICAgICBBcm0uYXJtX3RvX2JpbmFyeSBhcm0gfD5cbiAgICAgIExpc3QubWFwIE5hbWUuY29kZXNfZm9yX2NvbW1hbmQgfD5cbiAgICAgIE5hbWUucHJlZmVycmVkX2NvZGVcbiAgICApXG4gIGluXG4gIG1hdGNoIFByZXByb2Nlc3MuZ2V0X3BhcmFtIGggXCJzdGFydFwiIHdpdGhcbiAgfCBISW50IGkgLT4gKFsoVXRpbHMudWludDMyX3RvX2ludCBpLCBjb2RlcyldLCBOb25lKVxuICB8IEhOb25lIC0+IChbXSwgU29tZSBjb2RlcylcbiAgfCBfIC0+IGZhaWx3aXRoIFwiRXhpdCBjb2RlIGhhcyBpbnZhbGlkIGhlYWRlcnMuXCJcblxubGV0IGxvYWRfZnJvbV9maWxlIGZtdCBlbnYgZmlsZW5hbWUgPVxuICBsZXQgKGhlYWRlcnMsYXN0KSA9IFBhcnNlLmZyb21fZmlsZW5hbWUgfmhlYWRlcnM6dHJ1ZSBmaWxlbmFtZSBpblxuICAoaGVhZGVycywgbG9hZF9mcm9tX3BhcnNlZF9maWxlIGZtdCBlbnYgKGhlYWRlcnMsIGFzdCkpXG5cbmV4Y2VwdGlvbiBOb0V4aXRDb2RlXG5cbmxldCBnZXRfcHJlZmVycmVkIChsc3QsIGRlZmF1bHQpIGkgPVxuICB0cnkgKFxuICAgIGxldCByZWMgYXV4IGxzdCA9XG4gICAgICBtYXRjaCBsc3Qgd2l0aFxuICAgICAgfCBbXSAtPiByYWlzZSBOb0V4aXRDb2RlXG4gICAgICB8IChqLCBjKTo6XyB3aGVuIGkgPD0gaiAtPiAoaiwgYylcbiAgICAgIHwgXzo6bHN0IC0+IGF1eCBsc3RcbiAgICBpblxuICAgIGF1eCBsc3RcbiAgKSB3aXRoIE5vRXhpdENvZGUgLT4gKFxuICAgIG1hdGNoIGRlZmF1bHQgd2l0aFxuICAgIHwgTm9uZSAtPiByYWlzZSBOb0V4aXRDb2RlXG4gICAgfCBTb21lIGMgLT4gKGksIGMpXG4gIClcblxuIiwiXG5tb2R1bGUgVVN0cmluZyA9IFV1dGYuU3RyaW5nXG5tb2R1bGUgVUJ1ZmZlciA9IFV1dGYuQnVmZmVyXG5cbmxldCBzdHJpbmdfb2ZfdWNoYXIgdWNoYXIgPVxuICBsZXQgYnVmZmVyID0gQnVmZmVyLmNyZWF0ZSA0IGluXG4gIFVCdWZmZXIuYWRkX3V0Zl84IGJ1ZmZlciB1Y2hhciA7XG4gIEJ1ZmZlci5jb250ZW50cyBidWZmZXJcblxubGV0IGRlY29tcG9zZV9pbnRvX3VjaGFycyBzdHIgPVxuICBVU3RyaW5nLmZvbGRfdXRmXzggKGZ1biBhY2MgXyB1YyAtPiBtYXRjaCB1YyB3aXRoXG4gIHwgYE1hbGZvcm1lZCBfIC0+IHJhaXNlIE5vdF9mb3VuZFxuICB8IGBVY2hhciB1YyAtPiB1Yzo6YWNjKSBbXSBzdHJcbiAgfD4gTGlzdC5yZXZcblxudHlwZSByZXN1bHQgPSBcbiAgfCBDb250IG9mIChGb3JtYXQuZm9ybWF0dGVyIC0+IHN0cmluZyAtPiByZXN1bHQpXG4gIHwgTm9Db250XG5cbmxldCByZWMgbWFpbiBmbXQgPVxuICBGb3JtYXQuZnByaW50ZiBmbXQgXCJBdmFpbGFibGUgY2hhcmFjdGVyczogQC5cIiA7XG4gIENoYXJzZXQuYWxsX3dyaXRhYmxlX2NoYXJzIHw+XG4gIExpc3QuaXRlciAoRm9ybWF0LmZwcmludGYgZm10IFwiJXNcIikgO1xuICBGb3JtYXQuZnByaW50ZiBmbXQgXCJALlBsZWFzZSBlbnRlciB0ZXh0IHRvIGVuY29kZTogQD9cIiA7XG4gIENvbnQgbWFpbl8xXG5cbmFuZCBtYWluXzEgZm10IHN0ciA9XG4gIGxldCByZWMgYXV4MiBsc3QgPVxuICAgIG1hdGNoIGxzdCB3aXRoXG4gICAgfCBbXSAtPiAoKVxuICAgIHwgYTo6Yjo6bHN0IC0+XG4gICAgICBGb3JtYXQuZnByaW50ZiBmbXQgXCIlMDJYJTAyWCBcIiBiIGEgO1xuICAgICAgYXV4MiBsc3RcbiAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG4gIGluXG4gIGxldCByZWMgYXV4NCBsc3QgPVxuICAgIG1hdGNoIGxzdCB3aXRoXG4gICAgfCBbXSAtPiAoKVxuICAgIHwgYTo6Yjo6Yzo6ZDo6bHN0IC0+XG4gICAgICBGb3JtYXQuZnByaW50ZiBmbXQgXCIlMDJYJTAyWCUwMlglMDJYIFwiIGQgYyBiIGEgO1xuICAgICAgYXV4NCBsc3RcbiAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG4gIGluXG4gIGJlZ2luIHRyeVxuICAgIGxldCBlbmNvZGluZyA9XG4gICAgICBkZWNvbXBvc2VfaW50b191Y2hhcnMgc3RyIHw+XG4gICAgICBMaXN0Lm1hcCBzdHJpbmdfb2ZfdWNoYXIgfD5cbiAgICAgIExpc3QubWFwIENoYXJzZXQuZW5jb2RlX3dyaXRhYmxlX2NoYXIgaW5cbiAgICBsZXQgZW5jb2RpbmcgPSBlbmNvZGluZ0BbTmFtZS5lb2ZdIGluXG5cbiAgICBGb3JtYXQuZnByaW50ZiBmbXQgXCJFbmNvZGVkIGRhdGEgKDEtYnl0ZSk6IEAuXCIgO1xuICAgIExpc3QuaXRlciAoRm9ybWF0LmZwcmludGYgZm10IFwiJTAyWCBcIikgZW5jb2RpbmcgO1xuXG4gICAgbGV0IG4gPSBMaXN0Lmxlbmd0aCBlbmNvZGluZyBpblxuICAgIGxldCBlbmNvZGluZyA9IGlmIG4gbW9kIDIgPD4gMCB0aGVuIGVuY29kaW5nQFswXSBlbHNlIGVuY29kaW5nIGluXG4gICAgRm9ybWF0LmZwcmludGYgZm10IFwiQC5FbmNvZGVkIGRhdGEgKDItYnl0ZXMpOiBALlwiIDtcbiAgICBhdXgyIGVuY29kaW5nIDtcblxuICAgIGxldCBuID0gTGlzdC5sZW5ndGggZW5jb2RpbmcgaW5cbiAgICBsZXQgZW5jb2RpbmcgPSBpZiBuIG1vZCA0IDw+IDAgdGhlbiBlbmNvZGluZ0BbMDswXSBlbHNlIGVuY29kaW5nIGluXG4gICAgRm9ybWF0LmZwcmludGYgZm10IFwiQC5FbmNvZGVkIGRhdGEgKDQtYnl0ZXMpOiBALlwiIDtcbiAgICBhdXg0IGVuY29kaW5nIDtcbiAgICBGb3JtYXQuZnByaW50ZiBmbXQgXCJALlwiXG4gIHdpdGggTm90X2ZvdW5kIC0+XG4gICAgRm9ybWF0LmZwcmludGYgZm10IFwiQW4gZXJyb3Igb2NjdXJlZC4gUGxlYXNlIGNoZWNrIHlvdSBvbmx5IHVzZSBhdmFpbGFibGUgY2hhcmFjdGVycy5cIlxuICBlbmQgO1xuICBOb0NvbnRcbiIsIm9wZW4gQXJtXG5cbmxldCBwcF9oZXggZm10IGkgPVxuICBGb3JtYXQuZnByaW50ZiBmbXQgXCIlMDhsWFwiIGlcblxubGV0IGNvbmRfdG9fc3RyIGMgPVxuICBtYXRjaCBjIHdpdGhcbiAgfCBFUSAtPiBcIkVRXCIgfCBORSAtPiBcIk5FXCIgfCBDUyAtPiBcIkNTXCIgfCBIUyAtPiBcIkhTXCJcbiAgfCBDQyAtPiBcIkNDXCIgfCBMTyAtPiBcIkxPXCIgfCBNSSAtPiBcIk1JXCIgfCBQTCAtPiBcIlBMXCIgXG4gIHwgVlMgLT4gXCJWU1wiIHwgVkMgLT4gXCJWQ1wiIHwgSEkgLT4gXCJISVwiIHwgTFMgLT4gXCJMU1wiXG4gIHwgR0UgLT4gXCJHRVwiIHwgTFQgLT4gXCJMVFwiIHwgR1QgLT4gXCJHVFwiIHwgTEUgLT4gXCJMRVwiXG4gIHwgQUwgLT4gXCJcIlxuXG5sZXQgbGRyX3N0cl90eXBlX3RvX3N0ciB0ID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgQiAtPiBcIkJcIiB8IFNCIC0+IFwiU0JcIiB8IEggLT4gXCJIXCIgfCBTSCAtPiBcIlNIXCIgfCBXIC0+IFwiXCJcbiAgfCBUIC0+IFwiVFwiIHwgQlQgLT4gXCJCVFwiXG5cbmxldCBzaWduX3RvX3N0ciBzaWduID1cbiAgaWYgc2lnbiA9IHNpZ25fbWludXMgdGhlbiBcIi1cIiBlbHNlIFwiXCJcblxubGV0IHNfdG9fc3RyIHMgPVxuICBpZiBzIHRoZW4gXCJTXCIgZWxzZSBcIlwiXG5cbmxldCBsX3RvX3N0ciBsID1cbiAgaWYgbCB0aGVuIFwiTFwiIGVsc2UgXCJcIlxuXG5sZXQgcHJpbnRfcmVnaXN0ZXIgZm10IHIgPVxuICBGb3JtYXQuZnByaW50ZiBmbXQgXCJyJWRcIiByXG5cbmxldCBwcmludF9pbW1lZGlhdGUgZm10IGkgPVxuICBGb3JtYXQuZnByaW50ZiBmbXQgXCIjJSNseFwiIGlcblxubGV0IHByaW50X29wZXJhbmQgZm10IG9wID1cbiAgbWF0Y2ggb3Agd2l0aFxuICB8IEltbWVkaWF0ZSBpIC0+IHByaW50X2ltbWVkaWF0ZSBmbXQgaVxuICB8IFJlZ2lzdGVyIHIgLT4gRm9ybWF0LmZwcmludGYgZm10IFwiJWFcIiBwcmludF9yZWdpc3RlciByXG4gIHwgU2NhbGVkUmVnaXN0ZXIgXyAtPiBmYWlsd2l0aCBcIk5vdCBpbXBsZW1lbnRlZFwiXG5cbmxldCBwcmludF9pbW1lZGlhdGVfb2Zmc2V0IGZtdCAocywgaSkgPVxuICBGb3JtYXQuZnByaW50ZiBmbXQgXCIjJXMlI2x4XCIgKHNpZ25fdG9fc3RyIHMpIGlcblxubGV0IHByaW50X3JlZ2lzdGVyX29mZnNldCBmbXQgKHJvLCBhZGRyX3R5cCkgPVxuICBsZXQgc3RyID0gaWYgYWRkcl90eXAgPSBQcmVJbmRleGVkIHRoZW4gXCIhXCIgZWxzZSBcIlwiIGluXG4gIG1hdGNoIHJvLCBhZGRyX3R5cCB3aXRoXG4gIHwgT0ltbWVkaWF0ZSAocixzLGkpLCBQb3N0SW5kZXhlZCAtPiBGb3JtYXQuZnByaW50ZiBmbXQgXCJbJWFdLCAlYVwiXG4gICAgcHJpbnRfcmVnaXN0ZXIgciBwcmludF9pbW1lZGlhdGVfb2Zmc2V0IChzLCBpKVxuICB8IE9SZWdpc3RlciAocixzLHJvKSwgUG9zdEluZGV4ZWQgLT4gRm9ybWF0LmZwcmludGYgZm10IFwiWyVhXSwgJXMlYVwiXG4gICAgcHJpbnRfcmVnaXN0ZXIgciAoc2lnbl90b19zdHIgcykgcHJpbnRfcmVnaXN0ZXIgcm9cbiAgfCBPSW1tZWRpYXRlIChyLHMsaSksIF8gLT4gRm9ybWF0LmZwcmludGYgZm10IFwiWyVhLCAlYV0lc1wiXG4gICAgcHJpbnRfcmVnaXN0ZXIgciBwcmludF9pbW1lZGlhdGVfb2Zmc2V0IChzLCBpKSBzdHJcbiAgfCBPUmVnaXN0ZXIgKHIscyxybyksIF8gLT4gRm9ybWF0LmZwcmludGYgZm10IFwiWyVhLCAlcyVhXSVzXCJcbiAgICBwcmludF9yZWdpc3RlciByIChzaWduX3RvX3N0ciBzKSBwcmludF9yZWdpc3RlciBybyBzdHJcbiAgfCBPU2NhbGVkUmVnaXN0ZXIgXywgXyAtPiBmYWlsd2l0aCBcIk5vdCBpbXBsZW1lbnRlZFwiXG5cbmxldCBwcF9hcm0gZm10IGFybSA9XG4gIG1hdGNoIGFybSB3aXRoXG4gIHwgQ3VzdG9tIGkgLT4gcHBfaGV4IGZtdCBpXG4gIHwgTERSIHt0eXA7Y29uZDtyZDtyb30gLT4gRm9ybWF0LmZwcmludGYgZm10IFwiTERSJXMlcyAlYSwgJWFcIlxuICAgIChjb25kX3RvX3N0ciBjb25kKSAobGRyX3N0cl90eXBlX3RvX3N0ciB0eXApXG4gICAgcHJpbnRfcmVnaXN0ZXIgcmQgcHJpbnRfcmVnaXN0ZXJfb2Zmc2V0IHJvXG4gIHwgU1RSIHt0eXA7Y29uZDtyZDtyb30gLT4gRm9ybWF0LmZwcmludGYgZm10IFwiU1RSJXMlcyAlYSwgJWFcIlxuICAgIChjb25kX3RvX3N0ciBjb25kKSAobGRyX3N0cl90eXBlX3RvX3N0ciB0eXApXG4gICAgcHJpbnRfcmVnaXN0ZXIgcmQgcHJpbnRfcmVnaXN0ZXJfb2Zmc2V0IHJvXG4gIHwgTU9WIHtzO2NvbmQ7cmQ7cnN9ICAgLT4gRm9ybWF0LmZwcmludGYgZm10IFwiTU9WJXMlcyAlYSwgJWFcIlxuICAgIChjb25kX3RvX3N0ciBjb25kKSAoc190b19zdHIgcykgcHJpbnRfcmVnaXN0ZXIgcmQgcHJpbnRfb3BlcmFuZCByc1xuICB8IE1WTiB7cztjb25kO3JkO3JzfSAgIC0+IEZvcm1hdC5mcHJpbnRmIGZtdCBcIk1WTiVzJXMgJWEsICVhXCJcbiAgICAoY29uZF90b19zdHIgY29uZCkgKHNfdG9fc3RyIHMpIHByaW50X3JlZ2lzdGVyIHJkIHByaW50X29wZXJhbmQgcnNcbiAgfCBBREMge3M7Y29uZDtyZDtybjtvcDJ9IC0+IEZvcm1hdC5mcHJpbnRmIGZtdCBcIkFEQyVzJXMgJWEsICVhLCAlYVwiXG4gICAgKGNvbmRfdG9fc3RyIGNvbmQpIChzX3RvX3N0ciBzKVxuICAgIHByaW50X3JlZ2lzdGVyIHJkIHByaW50X3JlZ2lzdGVyIHJuIHByaW50X29wZXJhbmQgb3AyXG4gIHwgU0JDIHtzO2NvbmQ7cmQ7cm47b3AyfSAtPiBGb3JtYXQuZnByaW50ZiBmbXQgXCJTQkMlcyVzICVhLCAlYSwgJWFcIlxuICAgIChjb25kX3RvX3N0ciBjb25kKSAoc190b19zdHIgcylcbiAgICBwcmludF9yZWdpc3RlciByZCBwcmludF9yZWdpc3RlciBybiBwcmludF9vcGVyYW5kIG9wMlxuICB8IEJJQyB7cztjb25kO3JkO3JuO29wMn0gLT4gRm9ybWF0LmZwcmludGYgZm10IFwiQklDJXMlcyAlYSwgJWEsICVhXCJcbiAgICAoY29uZF90b19zdHIgY29uZCkgKHNfdG9fc3RyIHMpXG4gICAgcHJpbnRfcmVnaXN0ZXIgcmQgcHJpbnRfcmVnaXN0ZXIgcm4gcHJpbnRfb3BlcmFuZCBvcDJcbiAgfCBBTkQge3M7Y29uZDtyZDtybjtvcDJ9IC0+IEZvcm1hdC5mcHJpbnRmIGZtdCBcIkFORCVzJXMgJWEsICVhLCAlYVwiXG4gICAgKGNvbmRfdG9fc3RyIGNvbmQpIChzX3RvX3N0ciBzKVxuICAgIHByaW50X3JlZ2lzdGVyIHJkIHByaW50X3JlZ2lzdGVyIHJuIHByaW50X29wZXJhbmQgb3AyXG4gIHwgQnJhbmNoIHtsO2NvbmQ7dGFyZ2V0fSAtPiBGb3JtYXQuZnByaW50ZiBmbXQgXCJCJXMlcyAlYVwiXG4gICAgKGxfdG9fc3RyIGwpIChjb25kX3RvX3N0ciBjb25kKSBwcmludF9pbW1lZGlhdGUgdGFyZ2V0XG4iLCJvcGVuIEFybVxuXG5sZXQgdHJlYXRfY29tbWFuZCBmbXQgYXJtID1cbiAgbGV0IGhleHMgPSBhcm1fdG9fYmluYXJ5IGFybSBpblxuICBsZXQgY29kZXMgPSBMaXN0Lm1hcCBOYW1lLmNvZGVzX2Zvcl9jb21tYW5kIGhleHMgaW5cbiAgbGV0IGNvZGUgPSBOYW1lLnByZWZlcnJlZF9jb2RlIGNvZGVzIGluXG4gIGxldCBoZXggPSBOYW1lLmNvbW1hbmRfZm9yX2NvZGVzIGNvZGUgaW5cbiAgbGV0IGNoYXJzID0gTmFtZS5jb2Rlc190b19jaGFycyBjb2RlIGluXG4gIEZvcm1hdC5mcHJpbnRmIGZtdCBcIiVhIFxcdCVhXFx0JWFALlwiXG4gICAgTmFtZS5wcF9jaGFycyBjaGFyc1xuICAgIEFybV9wcmludGVyLnBwX2hleCBoZXhcbiAgICBBcm1fcHJpbnRlci5wcF9hcm0gYXJtIDtcbiAgY29kZVxuXG5sZXQgbWFpbiBmbXQgZW52IChoZWFkZXJzLGhlYWRlcnMyKSBwYXJzZWQgZXhpdCA9XG4gIGxldCBvbmx5cmF3ID1cbiAgICBtYXRjaCBQcmVwcm9jZXNzLmdldF9wYXJhbSBoZWFkZXJzIFwib25seXJhd1wiIHdpdGhcbiAgICB8IEhOb25lIC0+IGZhbHNlXG4gICAgfCBIQm9vbCBiIC0+IGJcbiAgICB8IF8gLT4gZmFpbHdpdGggXCJJbnZhbGlkIGhlYWRlcnMuXCJcbiAgaW5cbiAgaWYgb25seXJhdyAmJiBleGl0IDw+IE5vbmVcbiAgdGhlbiBmYWlsd2l0aCBcIk9ubHktcmF3IG1vZGUgZG9lcyBub3Qgc3VwcG9ydCBleGl0IGNvZGVzLlwiIDtcbiAgbGV0IHN0YXJ0ID1cbiAgICBtYXRjaCBQcmVwcm9jZXNzLmdldF9wYXJhbSBoZWFkZXJzIFwic3RhcnRcIiB3aXRoXG4gICAgfCBITm9uZSAtPiAwXG4gICAgfCBISW50IGkgLT4gVXRpbHMudWludDMyX3RvX2ludCBpXG4gICAgfCBfIC0+IGZhaWx3aXRoIFwiSW52YWxpZCBoZWFkZXJzLlwiXG4gIGluXG4gIGxldCBmaWxsZXJzID1cbiAgICBBcnJheS5pbml0IDQgKGZ1biBuIC0+XG4gICAgICBsZXQgaGVhZGVyX25hbWUgPSBGb3JtYXQuc3ByaW50ZiBcImZpbGxlciVuXCIgKG4rMSkgaW5cbiAgICAgIG1hdGNoIFByZXByb2Nlc3MuZ2V0X3BhcmFtIGhlYWRlcnMgaGVhZGVyX25hbWUgd2l0aFxuICAgICAgfCBITm9uZSAtPiBCb3hlcy5kZWZhdWx0X2ZpbGxlcnMuKG4pXG4gICAgICB8IEhJbnQgaSAtPlxuICAgICAgICBsZXQgY29kZXMgPSBOYW1lLmNvZGVzX2Zvcl9jb21tYW5kIGkgaW5cbiAgICAgICAgaWYgTGlzdC5udGggY29kZXMgbiA8PiBOYW1lLmVvZiB0aGVuIGZhaWx3aXRoIFwiSW52YWxpZCBmaWxsZXIuXCIgO1xuICAgICAgICBjb2Rlc1xuICAgICAgfCBfIC0+IGZhaWx3aXRoIFwiSW52YWxpZCBoZWFkZXJzLlwiXG4gICAgKVxuICBpblxuICBsZXQgZmlsbF9sYXN0ID1cbiAgICBtYXRjaCBQcmVwcm9jZXNzLmdldF9wYXJhbSBoZWFkZXJzIFwiZmlsbFwiLFxuICAgICAgICAgIFByZXByb2Nlc3MuZ2V0X3BhcmFtIGhlYWRlcnMyIFwiZmlsbFwiIHdpdGhcbiAgICB8IEhOb25lLCBITm9uZSAtPiB0cnVlXG4gICAgfCBITm9uZSwgSEJvb2wgYiB8IEhCb29sIGIsIEhOb25lIC0+IGJcbiAgICB8IEhCb29sIGIxLCBIQm9vbCBiMiB3aGVuIGIxPWIyIC0+IGIxXG4gICAgfCBIQm9vbCBfLCBIQm9vbCBfIC0+XG4gICAgICBmYWlsd2l0aCBcIlRoZSAnZmlsbCcgaGVhZGVyIGhhcyBhIGRpZmZlcmVudCB2YWx1ZSBpbiB0aGUgbWFpbiBjb2RlIGFuZCBpbiB0aGUgZXhpdCBjb2RlLlwiXG4gICAgfCBfIC0+IGZhaWx3aXRoIFwiSW52YWxpZCBoZWFkZXJzLlwiXG4gIGluXG4gIGxldCByZXMgPVxuICAgIFBhcnNlLnBhcnNlZF9hc3RfdG9fYXJtIH5vcHRpbWl6ZTp0cnVlIGVudiBwYXJzZWQgfD5cbiAgICBMaXN0Lm1hcCAodHJlYXRfY29tbWFuZCBmbXQpIGluXG4gIGlmIG9ubHlyYXdcbiAgdGhlbiBiZWdpblxuICAgIGxldCBzdGFydCA9IExpc3QuaW5pdCBzdGFydCAoZnVuIF8gLT4gMCkgaW5cbiAgICBsZXQgcmVzID0gTGlzdC5jb25jYXQgKHN0YXJ0OjpyZXMpIGluXG4gICAgRm9ybWF0LmZwcmludGYgZm10IFwiQC5SYXcgZGF0YSAoaW4gaGV4YWRlY2ltYWwpOkAuXCIgO1xuICAgIExpc3QuaXRlciAoRm9ybWF0LmZwcmludGYgZm10IFwiJTAyWCBAP1wiKSByZXMgO1xuICAgIEZvcm1hdC5mcHJpbnRmIGZtdCBcIkAuXCIgOyBOb25lXG4gIGVuZCBlbHNlXG4gICAgdHJ5XG4gICAgICBsZXQgYm94ZXNfY29kZXMgPVxuICAgICAgICBCb3hlcy5maXRfY29kZXNfaW50b19ib3hlcyB+ZmlsbF9sYXN0IH5maWxsZXJzIH5zdGFydCB+ZXhpdCByZXMgaW5cbiAgICAgIEZvcm1hdC5mcHJpbnRmIGZtdCBcIkAuJWFALlwiIEJveGVzLnBwX2JveGVzX25hbWVzIGJveGVzX2NvZGVzIDtcbiAgICAgIGxldCBzaXplID0gTGlzdC5sZW5ndGggYm94ZXNfY29kZXMgaW5cbiAgICAgIGJlZ2luXG4gICAgICAgIGlmIHNpemUgPiBCb3hlcy5uYl9ib3hlc1xuICAgICAgICB0aGVuXG4gICAgICAgICAgRm9ybWF0LmZwcmludGYgZm10IFwiV2FybmluZzogTm90IGVub3VnaCBzcGFjZS4uLiBOZWVkICVuLyVuIGJveGVzLkAuXCJcbiAgICAgICAgICBzaXplIEJveGVzLm5iX2JveGVzXG4gICAgICBlbmQgO1xuICAgICAgYmVnaW5cbiAgICAgICAgaWYgTGlzdC5leGlzdHMgKGZ1biBjIC0+IE5hbWUuaXNfY29kZV93cml0YWJsZSBjIHw+IG5vdCkgYm94ZXNfY29kZXNcbiAgICAgICAgdGhlbiBGb3JtYXQuZnByaW50ZiBmbXQgXCJXYXJuaW5nOiBDb250YWlucyB1bndyaXRhYmxlIGNoYXJhY3RlcnMuLi5ALlwiXG4gICAgICAgIGVsc2UgaWYgTGlzdC5leGlzdHMgTmFtZS5pc19mdWxsX29mX3NwYWNlcyBib3hlc19jb2Rlc1xuICAgICAgICB0aGVuIEZvcm1hdC5mcHJpbnRmIGZtdCBcIldhcm5pbmc6IEEgYm94IG5hbWUgY2Fubm90IGJlIHdyaXR0ZW4gKG9ubHkgY29udGFpbnMgc3BhY2VzKS4uLkAuXCJcbiAgICAgIGVuZCA7XG4gICAgICBGb3JtYXQuZnByaW50ZiBmbXQgXCJSYXcgZGF0YSAoaW4gaGV4YWRlY2ltYWwpOkAuXCIgO1xuICAgICAgYm94ZXNfY29kZXMgfD4gTGlzdC5pdGVyIChGb3JtYXQuZnByaW50ZiBmbXQgXCIlYVwiIEJveGVzLnBwX2JveF9yYXcpIDtcbiAgICAgIEZvcm1hdC5mcHJpbnRmIGZtdCBcIkAuXCIgO1xuICAgICAgU29tZSAoTGlzdC5tYXAgKGZ1biBjIC0+IE5hbWUuY29kZXNfdG9fY2hhcnMgYyB8PiBVdGlscy5jb25jYXRfc3RyaW5ncykgYm94ZXNfY29kZXMpXG4gICAgd2l0aCBFeGl0Lk5vRXhpdENvZGUgLT5cbiAgICAgIGZhaWx3aXRoIFwiVGhlIGV4aXQgY29kZSBvdmVybGFwcyB0aGlzIGNvZGUgKHRvbyBsb25nPykuQC5cIlxuIixudWxsLCJvcGVuIEFjZV9jb21tb25cbm9wZW4gSnNfb2Zfb2NhbWxcblxubW9kdWxlIEh0bWwgPSBEb21faHRtbFxuXG5sZXQgdHJlYXRfaW5wdXQgbGFuZyBzdHIgPVxuICBTZXR0aW5ncy5jb25maWd1cmUgbGFuZyA7XG4gIGxldCBidWZmZXIgPSBCdWZmZXIuY3JlYXRlIDEwMDAgaW5cbiAgbGV0IGZtdCA9IEZvcm1hdC5mb3JtYXR0ZXJfb2ZfYnVmZmVyIGJ1ZmZlciBpblxuICBiZWdpbiB0cnkgKFxuICAgIGxldCBmcyA9IEZzLmZyb21fc3RyIHN0ciBpblxuICAgIGxldCAoaGVhZGVycywgcHJvZ3JhbSkgPSBGcy5tYWluX2ZpbGUgZnMgaW5cbiAgICBsZXQgZW52ID0gUHJlcHJvY2Vzcy5lbnZfZnJvbV9oZWFkZXJzIGZtdCBoZWFkZXJzIGluXG4gICAgbGV0IChleGl0LCBoZWFkZXJzMikgPVxuICAgICAgbWF0Y2ggUHJlcHJvY2Vzcy5nZXRfcGFyYW0gaGVhZGVycyBcImV4aXRcIiB3aXRoXG4gICAgICB8IEhOb25lIC0+IChOb25lLCBbXSlcbiAgICAgIHwgSFN0cmluZyBmbiAtPlxuICAgICAgICBsZXQgKGhlYWRlcnMsIGFzdCkgPSBGcy5nZXRfZmlsZSBmbiBmcyBpblxuICAgICAgICBsZXQgZXhpdCA9IEV4aXQubG9hZF9mcm9tX3BhcnNlZF9maWxlIGZtdCBlbnYgKGhlYWRlcnMsIGFzdCkgaW5cbiAgICAgICAgKFNvbWUgZXhpdCwgaGVhZGVycylcbiAgICAgIHwgXyAtPiBmYWlsd2l0aCBcIkludmFsaWQgaGVhZGVycy5cIlxuICAgIGluXG4gICAgbWFpbiBmbXQgZW52IChoZWFkZXJzLCBoZWFkZXJzMikgcHJvZ3JhbSBleGl0IHw+IGlnbm9yZVxuICApIHdpdGggZSAtPiBCdWZmZXIuYWRkX3N0cmluZyBidWZmZXIgKFByaW50ZXhjLnRvX3N0cmluZyBlKSBlbmQgO1xuICBGb3JtYXQucHBfcHJpbnRfZmx1c2ggZm10ICgpIDtcbiAgQnVmZmVyLmNvbnRlbnRzIGJ1ZmZlclxuXG5sZXQgaXNfYmxhbmtfc3RyIHMgPSAgXG4gIGxldCByZWMgZW1wdHkgaSA9XG4gICAgaWYgaSA8IDAgdGhlbiB0cnVlXG4gICAgZWxzZVxuICAgICAgbGV0IGMgPSBTdHJpbmcuZ2V0IHMgaSBpblxuICAgICAgaWYgYyA9ICcgJyB8fCBjID0gJ1xcdCcgfHwgYyA9ICdcXG4nIHx8IGMgPSAnXFxyJyB0aGVuIGVtcHR5IChpLTEpXG4gICAgICBlbHNlIGZhbHNlXG4gIGluXG4gIGVtcHR5ICgoU3RyaW5nLmxlbmd0aCBzKS0xKVxuXG5sZXQgY29tcHV0ZSBfID1cbiAgbGV0IG1haW5faW5wdXQgPVxuICAgIE9wdGlvbi5nZXRcbiAgICAgIChIdG1sLmdldEVsZW1lbnRCeUlkX2NvZXJjZSBcIm1haW5cIiBIdG1sLkNvZXJjZVRvLnRleHRhcmVhKVxuICBpblxuICBsZXQgc2Vjb25kYXJ5X2lucHV0ID1cbiAgICBPcHRpb24uZ2V0XG4gICAgICAoSHRtbC5nZXRFbGVtZW50QnlJZF9jb2VyY2UgXCJzZWNvbmRhcnlcIiBIdG1sLkNvZXJjZVRvLnRleHRhcmVhKVxuICBpblxuICBsZXQgb3V0cHV0ID1cbiAgICBPcHRpb24uZ2V0XG4gICAgICAoSHRtbC5nZXRFbGVtZW50QnlJZF9jb2VyY2UgXCJvdXRwdXRcIiBIdG1sLkNvZXJjZVRvLnRleHRhcmVhKVxuICBpblxuICBsZXQgbGFuZyA9XG4gICAgT3B0aW9uLmdldFxuICAgICAgKEh0bWwuZ2V0RWxlbWVudEJ5SWRfY29lcmNlIFwibGFuZ1wiIEh0bWwuQ29lcmNlVG8uc2VsZWN0KVxuICBpblxuICBsZXQgbWFpbl9pbnB1dCA9IEpzLnRvX3N0cmluZyBtYWluX2lucHV0IyMudmFsdWUgaW5cbiAgbGV0IHNlY29uZGFyeV9pbnB1dCA9IEpzLnRvX3N0cmluZyBzZWNvbmRhcnlfaW5wdXQjIy52YWx1ZSBpblxuICBsZXQgaW5wdXQgPSBtYWluX2lucHV0XihcbiAgICBpZiBpc19ibGFua19zdHIgc2Vjb25kYXJ5X2lucHV0XG4gICAgdGhlbiBcIlwiIGVsc2UgXCJcXG49PT09PVxcblwiXnNlY29uZGFyeV9pbnB1dFxuICApIGluXG4gIGxldCBsYW5nID0gSnMudG9fc3RyaW5nIGxhbmcjIy52YWx1ZSBpblxuICBsZXQgcmVzID0gdHJlYXRfaW5wdXQgbGFuZyBpbnB1dCBpblxuICBvdXRwdXQjIy52YWx1ZSA6PSBKcy5zdHJpbmcgcmVzO1xuICBKcy5fdHJ1ZVxuXG5sZXQgaW5pdCBfID1cbiAgbGV0IGNvbXB1dGVfYnV0dG9uID1cbiAgICBPcHRpb24uZ2V0XG4gICAgICAoSHRtbC5nZXRFbGVtZW50QnlJZF9jb2VyY2UgXCJjb21wdXRlXCIgSHRtbC5Db2VyY2VUby5idXR0b24pXG4gIGluXG4gIEh0bWwuYWRkRXZlbnRMaXN0ZW5lciBjb21wdXRlX2J1dHRvblxuICAgIChIdG1sLkV2ZW50Lm1ha2UgXCJjbGlja1wiKSAoSHRtbC5oYW5kbGVyIGNvbXB1dGUpIChKcy5ib29sIGZhbHNlKVxuICB8PiBpZ25vcmUgO1xuICBKcy5fZmFsc2VcblxubGV0IF8gPSBIdG1sLmFkZEV2ZW50TGlzdGVuZXIgSHRtbC53aW5kb3dcbiAgKEh0bWwuRXZlbnQubWFrZSBcImxvYWRcIikgKEh0bWwuaGFuZGxlciBpbml0KSAoSnMuYm9vbCBmYWxzZSlcbiAgfD4gaWdub3JlXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIEVuc3VyZSB0aGF0IFthdF9leGl0XSBmdW5jdGlvbnMgYXJlIGNhbGxlZCBhdCB0aGUgZW5kIG9mIGV2ZXJ5IHByb2dyYW0gKilcblxubGV0IF8gPSBkb19hdF9leGl0KClcbiJdfQ==