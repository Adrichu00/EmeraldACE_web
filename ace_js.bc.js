//# 1 "ace_js.bc.runtime.js"
// Generated by js_of_ocaml 3.9.1
(function(joo_global_object)
   {"use strict";
    function caml_int64_is_zero(x){return + x.isZero()}
    function caml_str_repeat(n,s)
     {if(n == 0)return "";
      if(s.repeat)return s.repeat(n);
      var r="",l=0;
      for(;;)
       {if(n & 1)r += s;
        n >>= 1;
        if(n == 0)return r;
        s += s;
        l++;
        if(l == 9)s.slice(0,1)}}
    var caml_int64_offset=Math.pow(2,- 24);
    function caml_raise_constant(tag){throw tag}
    var caml_global_data=[0];
    function caml_raise_zero_divide()
     {caml_raise_constant(caml_global_data.Division_by_zero)}
    function MlInt64(lo,mi,hi)
     {this.lo = lo & 0xffffff;this.mi = mi & 0xffffff;this.hi = hi & 0xffff}
    MlInt64.prototype.caml_custom = "_j";
    MlInt64.prototype.copy
    =
    function(){return new MlInt64(this.lo,this.mi,this.hi)};
    MlInt64.prototype.ucompare
    =
    function(x)
     {if(this.hi > x.hi)return 1;
      if(this.hi < x.hi)return - 1;
      if(this.mi > x.mi)return 1;
      if(this.mi < x.mi)return - 1;
      if(this.lo > x.lo)return 1;
      if(this.lo < x.lo)return - 1;
      return 0};
    MlInt64.prototype.compare
    =
    function(x)
     {var hi=this.hi << 16,xhi=x.hi << 16;
      if(hi > xhi)return 1;
      if(hi < xhi)return - 1;
      if(this.mi > x.mi)return 1;
      if(this.mi < x.mi)return - 1;
      if(this.lo > x.lo)return 1;
      if(this.lo < x.lo)return - 1;
      return 0};
    MlInt64.prototype.neg
    =
    function()
     {var lo=- this.lo,mi=- this.mi + (lo >> 24),hi=- this.hi + (mi >> 24);
      return new MlInt64(lo,mi,hi)};
    MlInt64.prototype.add
    =
    function(x)
     {var
       lo=this.lo + x.lo,
       mi=this.mi + x.mi + (lo >> 24),
       hi=this.hi + x.hi + (mi >> 24);
      return new MlInt64(lo,mi,hi)};
    MlInt64.prototype.sub
    =
    function(x)
     {var
       lo=this.lo - x.lo,
       mi=this.mi - x.mi + (lo >> 24),
       hi=this.hi - x.hi + (mi >> 24);
      return new MlInt64(lo,mi,hi)};
    MlInt64.prototype.mul
    =
    function(x)
     {var
       lo=this.lo * x.lo,
       mi=(lo * caml_int64_offset | 0) + this.mi * x.lo + this.lo * x.mi,
       hi=
        (mi * caml_int64_offset | 0)
        +
        this.hi
        *
        x.lo
        +
        this.mi
        *
        x.mi
        +
        this.lo
        *
        x.hi;
      return new MlInt64(lo,mi,hi)};
    MlInt64.prototype.isZero
    =
    function(){return (this.lo | this.mi | this.hi) == 0};
    MlInt64.prototype.isNeg = function(){return this.hi << 16 < 0};
    MlInt64.prototype.and
    =
    function(x)
     {return new MlInt64(this.lo & x.lo,this.mi & x.mi,this.hi & x.hi)};
    MlInt64.prototype.or
    =
    function(x)
     {return new MlInt64(this.lo | x.lo,this.mi | x.mi,this.hi | x.hi)};
    MlInt64.prototype.xor
    =
    function(x)
     {return new MlInt64(this.lo ^ x.lo,this.mi ^ x.mi,this.hi ^ x.hi)};
    MlInt64.prototype.shift_left
    =
    function(s)
     {s = s & 63;
      if(s == 0)return this;
      if(s < 24)
       return new
               MlInt64
               (this.lo << s,
                this.mi << s | this.lo >> 24 - s,
                this.hi << s | this.mi >> 24 - s);
      if(s < 48)
       return new
               MlInt64
               (0,this.lo << s - 24,this.mi << s - 24 | this.lo >> 48 - s);
      return new MlInt64(0,0,this.lo << s - 48)};
    MlInt64.prototype.shift_right_unsigned
    =
    function(s)
     {s = s & 63;
      if(s == 0)return this;
      if(s < 24)
       return new
               MlInt64
               (this.lo >> s | this.mi << 24 - s,
                this.mi >> s | this.hi << 24 - s,
                this.hi >> s);
      if(s < 48)
       return new
               MlInt64
               (this.mi >> s - 24 | this.hi << 48 - s,this.hi >> s - 24,0);
      return new MlInt64(this.hi >> s - 48,0,0)};
    MlInt64.prototype.shift_right
    =
    function(s)
     {s = s & 63;
      if(s == 0)return this;
      var h=this.hi << 16 >> 16;
      if(s < 24)
       return new
               MlInt64
               (this.lo >> s | this.mi << 24 - s,
                this.mi >> s | h << 24 - s,
                this.hi << 16 >> s >>> 16);
      var sign=this.hi << 16 >> 31;
      if(s < 48)
       return new
               MlInt64
               (this.mi >> s - 24 | this.hi << 48 - s,
                this.hi << 16 >> s - 24 >> 16,
                sign & 0xffff);
      return new MlInt64(this.hi << 16 >> s - 32,sign,sign)};
    MlInt64.prototype.lsl1
    =
    function()
     {this.hi = this.hi << 1 | this.mi >> 23;
      this.mi = (this.mi << 1 | this.lo >> 23) & 0xffffff;
      this.lo = this.lo << 1 & 0xffffff};
    MlInt64.prototype.lsr1
    =
    function()
     {this.lo = (this.lo >>> 1 | this.mi << 23) & 0xffffff;
      this.mi = (this.mi >>> 1 | this.hi << 23) & 0xffffff;
      this.hi = this.hi >>> 1};
    MlInt64.prototype.udivmod
    =
    function(x)
     {var
       offset=0,
       modulus=this.copy(),
       divisor=x.copy(),
       quotient=new MlInt64(0,0,0);
      while(modulus.ucompare(divisor) > 0){offset++;divisor.lsl1()}
      while(offset >= 0)
       {offset--;
        quotient.lsl1();
        if(modulus.ucompare(divisor) >= 0)
         {quotient.lo++;modulus = modulus.sub(divisor)}
        divisor.lsr1()}
      return {quotient:quotient,modulus:modulus}};
    MlInt64.prototype.div
    =
    function(y)
     {var x=this;
      if(y.isZero())caml_raise_zero_divide();
      var sign=x.hi ^ y.hi;
      if(x.hi & 0x8000)x = x.neg();
      if(y.hi & 0x8000)y = y.neg();
      var q=x.udivmod(y).quotient;
      if(sign & 0x8000)q = q.neg();
      return q};
    MlInt64.prototype.mod
    =
    function(y)
     {var x=this;
      if(y.isZero())caml_raise_zero_divide();
      var sign=x.hi;
      if(x.hi & 0x8000)x = x.neg();
      if(y.hi & 0x8000)y = y.neg();
      var r=x.udivmod(y).modulus;
      if(sign & 0x8000)r = r.neg();
      return r};
    MlInt64.prototype.toInt = function(){return this.lo | this.mi << 24};
    MlInt64.prototype.toFloat
    =
    function()
     {return (this.hi << 16)
             *
             Math.pow(2,32)
             +
             this.mi
             *
             Math.pow(2,24)
             +
             this.lo};
    MlInt64.prototype.toArray
    =
    function()
     {return [this.hi >> 8,
              this.hi & 0xff,
              this.mi >> 16,
              this.mi >> 8 & 0xff,
              this.mi & 0xff,
              this.lo >> 16,
              this.lo >> 8 & 0xff,
              this.lo & 0xff]};
    MlInt64.prototype.lo32
    =
    function(){return this.lo | (this.mi & 0xff) << 24};
    MlInt64.prototype.hi32
    =
    function(){return this.mi >>> 8 & 0xffff | this.hi << 16};
    function caml_int64_of_int32(x)
     {return new MlInt64(x & 0xffffff,x >> 24 & 0xffffff,x >> 31 & 0xffff)}
    function caml_int64_to_int32(x){return x.toInt()}
    function caml_int64_is_negative(x){return + x.isNeg()}
    function caml_int64_neg(x){return x.neg()}
    function caml_subarray_to_jsbytes(a,i,len)
     {var f=String.fromCharCode;
      if(i == 0 && len <= 4096 && len == a.length)return f.apply(null,a);
      var s="";
      for(;0 < len;i += 1024,len -= 1024)
       s += f.apply(null,a.slice(i,i + Math.min(len,1024)));
      return s}
    function caml_convert_string_to_bytes(s)
     {if(s.t == 2)
       s.c += caml_str_repeat(s.l - s.c.length,"\0");
      else
       s.c = caml_subarray_to_jsbytes(s.c,0,s.c.length);
      s.t = 0}
    function caml_jsbytes_of_string(s)
     {if((s.t & 6) != 0)caml_convert_string_to_bytes(s);return s.c}
    function caml_raise_with_arg(tag,arg){throw [0,tag,arg]}
    function jsoo_is_ascii(s)
     {if(s.length < 24)
       {for(var i=0;i < s.length;i++)if(s.charCodeAt(i) > 127)return false;
        return true}
      else
       return ! /[^\x00-\x7f]/.test(s)}
    function caml_utf16_of_utf8(s)
     {for(var b="",t="",c,c1,c2,v,i=0,l=s.length;i < l;i++)
       {c1 = s.charCodeAt(i);
        if(c1 < 0x80)
         {for(var j=i + 1;j < l && (c1 = s.charCodeAt(j)) < 0x80;j++);
          if(j - i > 512)
           {t.substr(0,1);b += t;t = "";b += s.slice(i,j)}
          else
           t += s.slice(i,j);
          if(j == l)break;
          i = j}
        v = 1;
        if(++i < l && ((c2 = s.charCodeAt(i)) & - 64) == 128)
         {c = c2 + (c1 << 6);
          if(c1 < 0xe0)
           {v = c - 0x3080;if(v < 0x80)v = 1}
          else
           {v = 2;
            if(++i < l && ((c2 = s.charCodeAt(i)) & - 64) == 128)
             {c = c2 + (c << 6);
              if(c1 < 0xf0)
               {v = c - 0xe2080;
                if(v < 0x800 || v >= 0xd7ff && v < 0xe000)v = 2}
              else
               {v = 3;
                if
                 (++i
                  <
                  l
                  &&
                  ((c2 = s.charCodeAt(i)) & - 64)
                  ==
                  128
                  &&
                  c1
                  <
                  0xf5)
                 {v = c2 - 0x3c82080 + (c << 6);
                  if(v < 0x10000 || v > 0x10ffff)v = 3}}}}}
        if(v < 4)
         {i -= v;t += "\ufffd"}
        else
         if(v > 0xffff)
          t += String.fromCharCode(0xd7c0 + (v >> 10),0xdc00 + (v & 0x3FF));
         else
          t += String.fromCharCode(v);
        if(t.length > 1024){t.substr(0,1);b += t;t = ""}}
      return b + t}
    function MlBytes(tag,contents,length)
     {this.t = tag;this.c = contents;this.l = length}
    MlBytes.prototype.toString
    =
    function()
     {switch(this.t)
       {case 9:return this.c;
        default:caml_convert_string_to_bytes(this);case 0:
         if(jsoo_is_ascii(this.c)){this.t = 9;return this.c}this.t = 8;
        case 8:return this.c
        }};
    MlBytes.prototype.toUtf16
    =
    function()
     {var r=this.toString();
      if(this.t == 9)return r;
      return caml_utf16_of_utf8(r)};
    MlBytes.prototype.slice
    =
    function()
     {var content=this.t == 4?this.c.slice():this.c;
      return new MlBytes(this.t,content,this.l)};
    function caml_bytes_of_jsbytes(s){return new MlBytes(0,s,s.length)}
    function caml_string_of_jsbytes(s){return caml_bytes_of_jsbytes(s)}
    function caml_raise_with_string(tag,msg)
     {caml_raise_with_arg(tag,caml_string_of_jsbytes(msg))}
    function caml_invalid_argument(msg)
     {caml_raise_with_string(caml_global_data.Invalid_argument,msg)}
    function caml_parse_format(fmt)
     {fmt = caml_jsbytes_of_string(fmt);
      var len=fmt.length;
      if(len > 31)caml_invalid_argument("format_int: format too long");
      var
       f=
        {justify:"+",
         signstyle:"-",
         filler:" ",
         alternate:false,
         base:0,
         signedconv:false,
         width:0,
         uppercase:false,
         sign:1,
         prec:- 1,
         conv:"f"};
      for(var i=0;i < len;i++)
       {var c=fmt.charAt(i);
        switch(c)
         {case "-":f.justify = "-";break;
          case "+":
          case " ":f.signstyle = c;break;
          case "0":f.filler = "0";break;
          case "#":f.alternate = true;break;
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9":
           f.width = 0;
           while(c = fmt.charCodeAt(i) - 48,c >= 0 && c <= 9)
            {f.width = f.width * 10 + c;i++}
           i--;
           break;
          case ".":
           f.prec = 0;
           i++;
           while(c = fmt.charCodeAt(i) - 48,c >= 0 && c <= 9)
            {f.prec = f.prec * 10 + c;i++}
           i--;
          case "d":
          case "i":f.signedconv = true;
          case "u":f.base = 10;break;
          case "x":f.base = 16;break;
          case "X":f.base = 16;f.uppercase = true;break;
          case "o":f.base = 8;break;
          case "e":
          case "f":
          case "g":f.signedconv = true;f.conv = c;break;
          case "E":
          case "F":
          case "G":
           f.signedconv = true;
           f.uppercase = true;
           f.conv = c.toLowerCase();
           break
          }}
      return f}
    function caml_finish_formatting(f,rawbuffer)
     {if(f.uppercase)rawbuffer = rawbuffer.toUpperCase();
      var len=rawbuffer.length;
      if(f.signedconv && (f.sign < 0 || f.signstyle != "-"))len++;
      if(f.alternate){if(f.base == 8)len += 1;if(f.base == 16)len += 2}
      var buffer="";
      if(f.justify == "+" && f.filler == " ")
       for(var i=len;i < f.width;i++)buffer += " ";
      if(f.signedconv)
       if(f.sign < 0)
        buffer += "-";
       else
        if(f.signstyle != "-")buffer += f.signstyle;
      if(f.alternate && f.base == 8)buffer += "0";
      if(f.alternate && f.base == 16)buffer += "0x";
      if(f.justify == "+" && f.filler == "0")
       for(var i=len;i < f.width;i++)buffer += "0";
      buffer += rawbuffer;
      if(f.justify == "-")for(var i=len;i < f.width;i++)buffer += " ";
      return caml_string_of_jsbytes(buffer)}
    function caml_int64_format(fmt,x)
     {var f=caml_parse_format(fmt);
      if(f.signedconv && caml_int64_is_negative(x))
       {f.sign = - 1;x = caml_int64_neg(x)}
      var
       buffer="",
       wbase=caml_int64_of_int32(f.base),
       cvtbl="0123456789abcdef";
      do
       {var p=x.udivmod(wbase);
        x = p.quotient;
        buffer = cvtbl.charAt(caml_int64_to_int32(p.modulus)) + buffer}
      while
       (! caml_int64_is_zero(x));
      if(f.prec >= 0)
       {f.filler = " ";
        var n=f.prec - buffer.length;
        if(n > 0)buffer = caml_str_repeat(n,"0") + buffer}
      return caml_finish_formatting(f,buffer)}
    function caml_expm1_float(x)
     {var y=Math.exp(x),z=y - 1;
      return Math.abs(x) > 1?z:z == 0?x:x * z / Math.log(y)}
    function caml_jsstring_of_string(s){return s.toUtf16()}
    if(joo_global_object.process && joo_global_object.process.cwd)
     var caml_current_dir=joo_global_object.process.cwd().replace(/\\/g,"/");
    else
     var caml_current_dir="/static";
    if(caml_current_dir.slice(- 1) !== "/")caml_current_dir += "/";
    function caml_make_path(name)
     {name = caml_jsstring_of_string(name);
      if(name.charCodeAt(0) != 47)name = caml_current_dir + name;
      var comp=name.split("/"),ncomp=[];
      for(var i=0;i < comp.length;i++)
       switch(comp[i])
        {case "..":if(ncomp.length > 1)ncomp.pop();break;
         case ".":break;
         case "":if(ncomp.length == 0)ncomp.push("");break;
         default:ncomp.push(comp[i]);break}
      ncomp.orig = name;
      return ncomp}
    function caml_is_ml_bytes(s){return s instanceof MlBytes}
    function caml_is_ml_string(s){return caml_is_ml_bytes(s)}
    function caml_bytes_of_array(a){return new MlBytes(4,a,a.length)}
    function caml_bytes_of_string(s){return s}
    function caml_utf8_of_utf16(s)
     {for(var b="",t=b,c,d,i=0,l=s.length;i < l;i++)
       {c = s.charCodeAt(i);
        if(c < 0x80)
         {for(var j=i + 1;j < l && (c = s.charCodeAt(j)) < 0x80;j++);
          if(j - i > 512)
           {t.substr(0,1);b += t;t = "";b += s.slice(i,j)}
          else
           t += s.slice(i,j);
          if(j == l)break;
          i = j}
        if(c < 0x800)
         {t += String.fromCharCode(0xc0 | c >> 6);
          t += String.fromCharCode(0x80 | c & 0x3f)}
        else
         if(c < 0xd800 || c >= 0xdfff)
          t
          +=
          String.fromCharCode
           (0xe0 | c >> 12,0x80 | c >> 6 & 0x3f,0x80 | c & 0x3f);
         else
          if
           (c
            >=
            0xdbff
            ||
            i
            +
            1
            ==
            l
            ||
            (d = s.charCodeAt(i + 1))
            <
            0xdc00
            ||
            d
            >
            0xdfff)
           t += "\xef\xbf\xbd";
          else
           {i++;
            c = (c << 10) + d - 0x35fdc00;
            t
            +=
            String.fromCharCode
             (0xf0 | c >> 18,
              0x80 | c >> 12 & 0x3f,
              0x80 | c >> 6 & 0x3f,
              0x80 | c & 0x3f)}
        if(t.length > 1024){t.substr(0,1);b += t;t = ""}}
      return b + t}
    function caml_bytes_of_utf16_jsstring(s)
     {var tag=9;
      if(! jsoo_is_ascii(s))tag = 8,s = caml_utf8_of_utf16(s);
      return new MlBytes(tag,s,s.length)}
    function caml_string_of_jsstring(s)
     {return caml_bytes_of_utf16_jsstring(s)}
    function caml_raise_sys_error(msg)
     {caml_raise_with_string(caml_global_data.Sys_error,msg)}
    function caml_raise_no_such_file(name)
     {name = caml_jsbytes_of_string(name);
      caml_raise_sys_error(name + ": No such file or directory")}
    function caml_bytes_bound_error()
     {caml_invalid_argument("index out of bounds")}
    function caml_bytes_unsafe_get(s,i)
     {switch(s.t & 6)
       {default:if(i >= s.c.length)return 0;case 0:return s.c.charCodeAt(i);
        case 4:return s.c[i]
        }}
    function caml_bytes_get(s,i)
     {if(i >>> 0 >= s.l)caml_bytes_bound_error();
      return caml_bytes_unsafe_get(s,i)}
    function caml_create_bytes(len)
     {if(len < 0)caml_invalid_argument("Bytes.create");
      return new MlBytes(len?2:9,"",len)}
    function caml_ml_bytes_length(s){return s.l}
    function caml_convert_bytes_to_array(s)
     {if(joo_global_object.Uint8Array)
       var a=new (joo_global_object.Uint8Array)(s.l);
      else
       var a=new Array(s.l);
      var b=s.c,l=b.length,i=0;
      for(;i < l;i++)a[i] = b.charCodeAt(i);
      for(l = s.l;i < l;i++)a[i] = 0;
      s.c = a;
      s.t = 4;
      return a}
    function caml_blit_bytes(s1,i1,s2,i2,len)
     {if(len == 0)return 0;
      if(i2 == 0 && (len >= s2.l || s2.t == 2 && len >= s2.c.length))
       {s2.c
        =
        s1.t == 4
         ?caml_subarray_to_jsbytes(s1.c,i1,len)
         :i1 == 0 && s1.c.length == len?s1.c:s1.c.substr(i1,len);
        s2.t = s2.c.length == s2.l?0:2}
      else
       if(s2.t == 2 && i2 == s2.c.length)
        {s2.c
         +=
         s1.t == 4
          ?caml_subarray_to_jsbytes(s1.c,i1,len)
          :i1 == 0 && s1.c.length == len?s1.c:s1.c.substr(i1,len);
         s2.t = s2.c.length == s2.l?0:2}
       else
        {if(s2.t != 4)caml_convert_bytes_to_array(s2);
         var c1=s1.c,c2=s2.c;
         if(s1.t == 4)
          if(i2 <= i1)
           for(var i=0;i < len;i++)c2[i2 + i] = c1[i1 + i];
          else
           for(var i=len - 1;i >= 0;i--)c2[i2 + i] = c1[i1 + i];
         else
          {var l=Math.min(len,c1.length - i1);
           for(var i=0;i < l;i++)c2[i2 + i] = c1.charCodeAt(i1 + i);
           for(;i < len;i++)c2[i2 + i] = 0}}
      return 0}
    function caml_blit_string(a,b,c,d,e)
     {caml_blit_bytes(caml_bytes_of_string(a),b,c,d,e);return 0}
    function MlFile(){}
    function MlFakeFile(content){this.data = content}
    MlFakeFile.prototype = new MlFile();
    MlFakeFile.prototype.truncate
    =
    function(len)
     {var old=this.data;
      this.data = caml_create_bytes(len | 0);
      caml_blit_bytes(old,0,this.data,0,len)};
    MlFakeFile.prototype.length
    =
    function(){return caml_ml_bytes_length(this.data)};
    MlFakeFile.prototype.write
    =
    function(offset,buf,pos,len)
     {var clen=this.length();
      if(offset + len >= clen)
       {var new_str=caml_create_bytes(offset + len),old_data=this.data;
        this.data = new_str;
        caml_blit_bytes(old_data,0,this.data,0,clen)}
      caml_blit_string(buf,pos,this.data,offset,len);
      return 0};
    MlFakeFile.prototype.read
    =
    function(offset,buf,pos,len)
     {var clen=this.length();
      caml_blit_bytes(this.data,offset,buf,pos,len);
      return 0};
    MlFakeFile.prototype.read_one
    =
    function(offset){return caml_bytes_get(this.data,offset)};
    MlFakeFile.prototype.close = function(){};
    MlFakeFile.prototype.constructor = MlFakeFile;
    function MlFakeDevice(root,f)
     {this.content = {};this.root = root;this.lookupFun = f}
    MlFakeDevice.prototype.nm = function(name){return this.root + name};
    MlFakeDevice.prototype.lookup
    =
    function(name)
     {if(! this.content[name] && this.lookupFun)
       {var
         res=
          this.lookupFun
           (caml_string_of_jsbytes(this.root),caml_string_of_jsbytes(name));
        if(res !== 0)
         this.content[name] = new MlFakeFile(caml_bytes_of_string(res[1]))}};
    MlFakeDevice.prototype.exists
    =
    function(name)
     {if(name == "")return 1;
      var name_slash=name + "/",r=new RegExp("^" + name_slash);
      for(var n in this.content)if(n.match(r))return 1;
      this.lookup(name);
      return this.content[name]?1:0};
    MlFakeDevice.prototype.readdir
    =
    function(name)
     {var
       name_slash=name == ""?"":name + "/",
       r=new RegExp("^" + name_slash + "([^/]*)"),
       seen={},
       a=[];
      for(var n in this.content)
       {var m=n.match(r);
        if(m && ! seen[m[1]]){seen[m[1]] = true;a.push(m[1])}}
      return a};
    MlFakeDevice.prototype.is_dir
    =
    function(name)
     {var
       name_slash=name == ""?"":name + "/",
       r=new RegExp("^" + name_slash + "([^/]*)"),
       a=[];
      for(var n in this.content){var m=n.match(r);if(m)return 1}
      return 0};
    MlFakeDevice.prototype.unlink
    =
    function(name)
     {var ok=this.content[name]?true:false;
      delete this.content[name];
      return ok};
    MlFakeDevice.prototype.open
    =
    function(name,f)
     {if(f.rdonly && f.wronly)
       caml_raise_sys_error
        (this.nm(name)
         +
         " : flags Open_rdonly and Open_wronly are not compatible");
      if(f.text && f.binary)
       caml_raise_sys_error
        (this.nm(name)
         +
         " : flags Open_text and Open_binary are not compatible");
      this.lookup(name);
      if(this.content[name])
       {if(this.is_dir(name))
         caml_raise_sys_error(this.nm(name) + " : is a directory");
        if(f.create && f.excl)
         caml_raise_sys_error(this.nm(name) + " : file already exists");
        var file=this.content[name];
        if(f.truncate)file.truncate();
        return file}
      else
       if(f.create)
        {this.content[name] = new MlFakeFile(caml_create_bytes(0));
         return this.content[name]}
       else
        caml_raise_no_such_file(this.nm(name))};
    MlFakeDevice.prototype.register
    =
    function(name,content)
     {if(this.content[name])
       caml_raise_sys_error(this.nm(name) + " : file already exists");
      if(caml_is_ml_bytes(content))
       this.content[name] = new MlFakeFile(content);
      if(caml_is_ml_string(content))
       this.content[name] = new MlFakeFile(caml_bytes_of_string(content));
      else
       if(content instanceof Array)
        this.content[name] = new MlFakeFile(caml_bytes_of_array(content));
       else
        if(typeof content === "string")
         this.content[name] = new MlFakeFile(caml_bytes_of_jsbytes(content));
        else
         if(content.toString)
          {var
            bytes=
             caml_bytes_of_string(caml_string_of_jsstring(content.toString()));
           this.content[name] = new MlFakeFile(bytes)}
         else
          caml_raise_sys_error
           (this.nm(name) + " : registering file with invalid content type")};
    MlFakeDevice.prototype.constructor = MlFakeDevice;
    function caml_ml_string_length(s){return caml_ml_bytes_length(s)}
    function caml_string_unsafe_get(s,i){return caml_bytes_unsafe_get(s,i)}
    function caml_array_of_string(s)
     {var l=caml_ml_string_length(s),a=new Array(l),i=0;
      for(;i < l;i++)a[i] = caml_string_unsafe_get(s,i);
      return a}
    function caml_array_of_bytes(s)
     {if(s.t != 4)caml_convert_bytes_to_array(s);return s.c}
    function caml_bytes_unsafe_set(s,i,c)
     {c &= 0xff;
      if(s.t != 4)
       {if(i == s.c.length)
         {s.c += String.fromCharCode(c);if(i + 1 == s.l)s.t = 0;return 0}
        caml_convert_bytes_to_array(s)}
      s.c[i] = c;
      return 0}
    function caml_bytes_set(s,i,c)
     {if(i >>> 0 >= s.l)caml_bytes_bound_error();
      return caml_bytes_unsafe_set(s,i,c)}
    function MlNodeFile(fd){this.fs = require("fs");this.fd = fd}
    MlNodeFile.prototype = new MlFile();
    MlNodeFile.prototype.truncate
    =
    function(len)
     {try
       {this.fs.ftruncateSync(this.fd,len | 0)}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeFile.prototype.length
    =
    function()
     {try
       {return this.fs.fstatSync(this.fd).size}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeFile.prototype.write
    =
    function(offset,buf,buf_offset,len)
     {var a=caml_array_of_string(buf);
      if(! (a instanceof joo_global_object.Uint8Array))
       a = new (joo_global_object.Uint8Array)(a);
      var buffer=joo_global_object.Buffer.from(a);
      try
       {this.fs.writeSync(this.fd,buffer,buf_offset,len,offset)}
      catch(err){caml_raise_sys_error(err.toString())}
      return 0};
    MlNodeFile.prototype.read
    =
    function(offset,buf,buf_offset,len)
     {var a=caml_array_of_bytes(buf);
      if(! (a instanceof joo_global_object.Uint8Array))
       a = new (joo_global_object.Uint8Array)(a);
      var buffer=joo_global_object.Buffer.from(a);
      try
       {this.fs.readSync(this.fd,buffer,buf_offset,len,offset)}
      catch(err){caml_raise_sys_error(err.toString())}
      for(var i=0;i < len;i++)
       caml_bytes_set(buf,buf_offset + i,buffer[buf_offset + i]);
      return 0};
    MlNodeFile.prototype.read_one
    =
    function(offset)
     {var
       a=new (joo_global_object.Uint8Array)(1),
       buffer=joo_global_object.Buffer.from(a);
      try
       {this.fs.readSync(this.fd,buffer,0,1,offset)}
      catch(err){caml_raise_sys_error(err.toString())}
      return buffer[0]};
    MlNodeFile.prototype.close
    =
    function()
     {try
       {this.fs.closeSync(this.fd)}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeFile.prototype.constructor = MlNodeFile;
    function MlNodeDevice(root){this.fs = require("fs");this.root = root}
    MlNodeDevice.prototype.nm = function(name){return this.root + name};
    MlNodeDevice.prototype.exists
    =
    function(name)
     {try
       {return this.fs.existsSync(this.nm(name))?1:0}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeDevice.prototype.readdir
    =
    function(name)
     {try
       {return this.fs.readdirSync(this.nm(name))}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeDevice.prototype.is_dir
    =
    function(name)
     {try
       {return this.fs.statSync(this.nm(name)).isDirectory()?1:0}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeDevice.prototype.unlink
    =
    function(name)
     {try
       {var b=this.fs.existsSync(this.nm(name))?1:0;
        this.fs.unlinkSync(this.nm(name))}
      catch(err){caml_raise_sys_error(err.toString())}
      return b};
    MlNodeDevice.prototype.open
    =
    function(name,f)
     {var consts=require("constants"),res=0;
      for(var key in f)
       switch(key)
        {case "rdonly":res |= consts.O_RDONLY;break;
         case "wronly":res |= consts.O_WRONLY;break;
         case "append":res |= consts.O_WRONLY | consts.O_APPEND;break;
         case "create":res |= consts.O_CREAT;break;
         case "truncate":res |= consts.O_TRUNC;break;
         case "excl":res |= consts.O_EXCL;break;
         case "binary":res |= consts.O_BINARY;break;
         case "text":res |= consts.O_TEXT;break;
         case "nonblock":res |= consts.O_NONBLOCK;break
         }
      try
       {var fd=this.fs.openSync(this.nm(name),res);return new MlNodeFile(fd)}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeDevice.prototype.rename
    =
    function(o,n)
     {try
       {this.fs.renameSync(this.nm(o),this.nm(n))}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeDevice.prototype.constructor = MlNodeDevice;
    var caml_root=caml_current_dir.match(/[^\/]*\//)[0];
    function fs_node_supported()
     {return typeof joo_global_object.process
             !==
             "undefined"
             &&
             typeof joo_global_object.process.versions
             !==
             "undefined"
             &&
             typeof joo_global_object.process.versions.node
             !==
             "undefined"
             &&
             joo_global_object.process.platform
             !==
             "browser"}
    var jsoo_mount_point=[];
    if(fs_node_supported())
     jsoo_mount_point.push
      ({path:caml_root,device:new MlNodeDevice(caml_root)});
    else
     jsoo_mount_point.push
      ({path:caml_root,device:new MlFakeDevice(caml_root)});
    jsoo_mount_point.push
     ({path:caml_root + "static/",
       device:new MlFakeDevice(caml_root + "static/")});
    function resolve_fs_device(name)
     {var
       path=caml_make_path(name),
       name=path.join("/"),
       name_slash=name + "/",
       res;
      for(var i=0;i < jsoo_mount_point.length;i++)
       {var m=jsoo_mount_point[i];
        if
         (name_slash.search(m.path)
          ==
          0
          &&
          (! res || res.path.length < m.path.length))
         res
         =
         {path:m.path,
          device:m.device,
          rest:name.substring(m.path.length,name.length)}}
      return res}
    function caml_sys_is_directory(name)
     {var root=resolve_fs_device(name),a=root.device.is_dir(root.rest);
      return a?1:0}
    function caml_raise_not_found()
     {caml_raise_constant(caml_global_data.Not_found)}
    function caml_sys_getenv(name)
     {var g=joo_global_object,n=caml_jsstring_of_string(name);
      if(g.process && g.process.env && g.process.env[n] != undefined)
       return caml_string_of_jsstring(g.process.env[n]);
      if
       (joo_global_object.jsoo_static_env
        &&
        joo_global_object.jsoo_static_env[n])
       return caml_string_of_jsstring(joo_global_object.jsoo_static_env[n]);
      caml_raise_not_found()}
    function shift_right_nat(nat1,ofs1,len1,nat2,ofs2,nbits)
     {if(nbits == 0){nat2.data[ofs2] = 0;return 0}
      var wrap=0;
      for(var i=len1 - 1;i >= 0;i--)
       {var a=nat1.data[ofs1 + i] >>> 0;
        nat1.data[ofs1 + i] = a >>> nbits | wrap;
        wrap = a << 32 - nbits}
      nat2.data[ofs2] = wrap;
      return 0}
    var caml_named_values={};
    function caml_named_value(nm){return caml_named_values[nm]}
    var caml_gr_state;
    function caml_gr_state_get()
     {if(caml_gr_state)return caml_gr_state;
      throw [0,
             caml_named_value("Graphics.Graphic_failure"),
             caml_string_of_jsbytes("Not initialized")]}
    function caml_gr_point_color(x,y)
     {var
       s=caml_gr_state_get(),
       im=s.context.getImageData(x,s.height - y,1,1),
       d=im.data;
      return (d[0] << 16) + (d[1] << 8) + d[2]}
    var MlObjectTable;
    if(typeof joo_global_object.WeakMap === "undefined")
     MlObjectTable
     =
     function()
       {function NaiveLookup(objs){this.objs = objs}
        NaiveLookup.prototype.get
        =
        function(v)
         {for(var i=0;i < this.objs.length;i++)if(this.objs[i] === v)return i};
        NaiveLookup.prototype.set = function(){};
        return function()
         {this.objs = [];this.lookup = new NaiveLookup(this.objs)}}
      ();
    else
     MlObjectTable
     =
     function()
      {this.objs = [];this.lookup = new (joo_global_object.WeakMap)()};
    MlObjectTable.prototype.store
    =
    function(v){this.lookup.set(v,this.objs.length);this.objs.push(v)};
    MlObjectTable.prototype.recall
    =
    function(v)
     {var i=this.lookup.get(v);
      return i === undefined?undefined:this.objs.length - i};
    function caml_failwith(msg)
     {caml_raise_with_string(caml_global_data.Failure,msg)}
    function caml_sys_rename(o,n)
     {var o_root=resolve_fs_device(o),n_root=resolve_fs_device(n);
      if(o_root.device != n_root.device)
       caml_failwith
        ("caml_sys_rename: cannot move file between two filesystem");
      if(! o_root.device.rename)
       caml_failwith("caml_sys_rename: no implemented");
      o_root.device.rename(o_root.rest,n_root.rest)}
    function caml_log10_float(x){return Math.LOG10E * Math.log(x)}
    var caml_runtime_warnings=0;
    function caml_ml_enable_runtime_warnings(bool)
     {caml_runtime_warnings = bool;return 0}
    function caml_classify_float(x)
     {if(isFinite(x))
       {if(Math.abs(x) >= 2.2250738585072014e-308)return 0;
        if(x != 0)return 1;
        return 2}
      return isNaN(x)?4:3}
    function caml_ml_refill_input(chan)
     {var str=chan.refill(),str_len=caml_ml_string_length(str);
      if(str_len == 0)chan.refill = null;
      chan.file.write(chan.file.length(),str,0,str_len);
      return str_len}
    var caml_ml_channels=new Array();
    function caml_ml_may_refill_input(chanid)
     {var chan=caml_ml_channels[chanid];
      if(chan.refill == null)return;
      if(chan.file.length() != chan.offset)return;
      caml_ml_refill_input(chan)}
    function caml_array_bound_error()
     {caml_invalid_argument("index out of bounds")}
    function caml_ml_input_scan_line(chanid)
     {var chan=caml_ml_channels[chanid];
      caml_ml_may_refill_input(chanid);
      var p=chan.offset,len=chan.file.length();
      if(p >= len)return 0;
      while(true)
       {if(p >= len)return - (p - chan.offset);
        if(chan.file.read_one(p) == 10)return p - chan.offset + 1;
        p++}}
    function caml_gc_minor(){return 0}
    function caml_int64_of_bytes(a)
     {return new
              MlInt64
              (a[7] << 0 | a[6] << 8 | a[5] << 16,
               a[4] << 0 | a[3] << 8 | a[2] << 16,
               a[1] << 0 | a[0] << 8)}
    function caml_ba_uint8_get64(ba,i0)
     {var ofs=ba.offset(i0);
      if(ofs + 7 >= ba.data.length)caml_array_bound_error();
      var
       b1=ba.get(ofs + 0),
       b2=ba.get(ofs + 1),
       b3=ba.get(ofs + 2),
       b4=ba.get(ofs + 3),
       b5=ba.get(ofs + 4),
       b6=ba.get(ofs + 5),
       b7=ba.get(ofs + 6),
       b8=ba.get(ofs + 7);
      return caml_int64_of_bytes([b8,b7,b6,b5,b4,b3,b2,b1])}
    function caml_int64_to_bytes(x){return x.toArray()}
    function caml_int64_marshal(writer,v,sizes)
     {var b=caml_int64_to_bytes(v);
      for(var i=0;i < 8;i++)writer.write(8,b[i]);
      sizes[0] = 8;
      sizes[1] = 8}
    function caml_ba_num_dims(ba){return ba.dims.length}
    function caml_return_exn_constant(tag){return tag}
    function caml_wrap_exception(e)
     {if(e instanceof Array)return e;
      if
       (joo_global_object.RangeError
        &&
        e instanceof joo_global_object.RangeError
        &&
        e.message
        &&
        e.message.match(/maximum call stack/i))
       return caml_return_exn_constant(caml_global_data.Stack_overflow);
      if
       (joo_global_object.InternalError
        &&
        e instanceof joo_global_object.InternalError
        &&
        e.message
        &&
        e.message.match(/too much recursion/i))
       return caml_return_exn_constant(caml_global_data.Stack_overflow);
      if(e instanceof joo_global_object.Error && caml_named_value("jsError"))
       return [0,caml_named_value("jsError"),e];
      return [0,caml_global_data.Failure,caml_string_of_jsstring(String(e))]}
    function caml_create_file(name,content)
     {var
       name=typeof name == "string"?caml_string_of_jsbytes(name):name,
       content=
        typeof content == "string"?caml_string_of_jsbytes(content):content,
       root=resolve_fs_device(name);
      if(! root.device.register)caml_failwith("cannot register file");
      root.device.register(root.rest,content);
      return 0}
    function caml_fs_init()
     {var tmp=joo_global_object.caml_fs_tmp;
      if(tmp)
       for(var i=0;i < tmp.length;i++)
        caml_create_file(tmp[i].name,tmp[i].content);
      joo_global_object.caml_create_file = caml_create_file;
      joo_global_object.caml_fs_tmp = [];
      return 0}
    function caml_set_parser_trace(){return 0}
    function caml_list_of_js_array(a)
     {var l=0;
      for(var i=a.length - 1;i >= 0;i--){var e=a[i];l = [0,e,l]}
      return l}
    function unix_gettimeofday(){return new Date().getTime() / 1000}
    function caml_mul(a,b){return Math.imul(a,b)}
    function caml_hash_mix_int(h,d)
     {d = caml_mul(d,0xcc9e2d51 | 0);
      d = d << 15 | d >>> 32 - 15;
      d = caml_mul(d,0x1b873593);
      h ^= d;
      h = h << 13 | h >>> 32 - 13;
      return (h + (h << 2) | 0) + (0xe6546b64 | 0) | 0}
    function num_digits_nat(nat,ofs,len)
     {for(var i=len - 1;i >= 0;i--)if(nat.data[ofs + i] != 0)return i + 1;
      return 1}
    function caml_hash_nat(x)
     {var len=num_digits_nat(x,0,x.data.length),h=0;
      for(var i=0;i < len;i++)h = caml_hash_mix_int(h,x.data[i]);
      return h}
    function caml_call_gen(f,args)
     {if(f.fun)return caml_call_gen(f.fun,args);
      if(typeof f !== "function")return f;
      var n=f.length | 0;
      if(n === 0)return f.apply(null,args);
      var argsLen=args.length | 0,d=n - argsLen | 0;
      if(d == 0)
       return f.apply(null,args);
      else
       if(d < 0)
        return caml_call_gen(f.apply(null,args.slice(0,n)),args.slice(n));
       else
        return function()
         {var
           extra_args=arguments.length == 0?1:arguments.length,
           nargs=new Array(args.length + extra_args);
          for(var i=0;i < args.length;i++)nargs[i] = args[i];
          for(var i=0;i < arguments.length;i++)
           nargs[args.length + i] = arguments[i];
          return caml_call_gen(f,nargs)}}
    function caml_js_wrap_callback_arguments(f)
     {return function()
       {var len=arguments.length,args=new Array(len);
        for(var i=0;i < len;i++)args[i] = arguments[i];
        return caml_call_gen(f,[args])}}
    function caml_sys_chdir(dir)
     {var root=resolve_fs_device(dir);
      if(root.device.exists(root.rest))
       {if(root.rest)
         caml_current_dir = root.path + root.rest + "/";
        else
         caml_current_dir = root.path;
        return 0}
      else
       caml_raise_no_such_file(dir)}
    function caml_gc_counters(){return [254,0,0,0]}
    function caml_gr_synchronize()
     {caml_failwith("caml_gr_synchronize not Implemented")}
    var log2_ok=Math.log2 && Math.log2(1.1235582092889474E+307) == 1020;
    function jsoo_floor_log2(x)
     {if(log2_ok)return Math.floor(Math.log2(x));
      var i=0;
      if(x == 0)return - Infinity;
      if(x >= 1)while(x >= 2){x /= 2;i++}else while(x < 1){x *= 2;i--}
      return i}
    function caml_int32_bits_of_float(x)
     {var float32a=new (joo_global_object.Float32Array)(1);
      float32a[0] = x;
      var int32a=new (joo_global_object.Int32Array)(float32a.buffer);
      return int32a[0] | 0}
    function caml_int64_create_lo_mi_hi(lo,mi,hi)
     {return new MlInt64(lo,mi,hi)}
    function caml_int64_bits_of_float(x)
     {if(! isFinite(x))
       {if(isNaN(x))return caml_int64_create_lo_mi_hi(1,0,0x7ff0);
        return x > 0
                ?caml_int64_create_lo_mi_hi(0,0,0x7ff0)
                :caml_int64_create_lo_mi_hi(0,0,0xfff0)}
      var sign=x == 0 && 1 / x == - Infinity?0x8000:x >= 0?0:0x8000;
      if(sign)x = - x;
      var exp=jsoo_floor_log2(x) + 1023;
      if(exp <= 0)
       {exp = 0;x /= Math.pow(2,- 1026)}
      else
       {x /= Math.pow(2,exp - 1027);
        if(x < 16){x *= 2;exp -= 1}
        if(exp == 0)x /= 2}
      var k=Math.pow(2,24),r3=x | 0;
      x = (x - r3) * k;
      var r2=x | 0;
      x = (x - r2) * k;
      var r1=x | 0;
      r3 = r3 & 0xf | sign | exp << 4;
      return caml_int64_create_lo_mi_hi(r1,r2,r3)}
    function caml_ba_serialize(writer,ba,sz)
     {writer.write(32,ba.dims.length);
      writer.write(32,ba.kind | ba.layout << 8);
      if(ba.caml_custom == "_bigarr02")
       for(var i=0;i < ba.dims.length;i++)
        if(ba.dims[i] < 0xffff)
         writer.write(16,ba.dims[i]);
        else
         {writer.write(16,0xffff);
          writer.write(32,0);
          writer.write(32,ba.dims[i])}
      else
       for(var i=0;i < ba.dims.length;i++)writer.write(32,ba.dims[i]);
      switch(ba.kind)
       {case 2:
        case 3:
        case 12:
         for(var i=0;i < ba.data.length;i++)writer.write(8,ba.data[i]);break;
        case 4:
        case 5:
         for(var i=0;i < ba.data.length;i++)writer.write(16,ba.data[i]);break;
        case 6:
         for(var i=0;i < ba.data.length;i++)writer.write(32,ba.data[i]);break;
        case 8:
        case 9:
         writer.write(8,0);
         for(var i=0;i < ba.data.length;i++)writer.write(32,ba.data[i]);
         break;
        case 7:
         for(var i=0;i < ba.data.length / 2;i++)
          {var b=caml_int64_to_bytes(ba.get(i));
           for(var j=0;j < 8;j++)writer.write(8,b[j])}
         break;
        case 1:
         for(var i=0;i < ba.data.length;i++)
          {var b=caml_int64_to_bytes(caml_int64_bits_of_float(ba.get(i)));
           for(var j=0;j < 8;j++)writer.write(8,b[j])}
         break;
        case 0:
         for(var i=0;i < ba.data.length;i++)
          {var b=caml_int32_bits_of_float(ba.get(i));writer.write(32,b)}
         break;
        case 10:
         for(var i=0;i < ba.data.length / 2;i++)
          {var j=ba.get(i);
           writer.write(32,caml_int32_bits_of_float(j[1]));
           writer.write(32,caml_int32_bits_of_float(j[2]))}
         break;
        case 11:
         for(var i=0;i < ba.data.length / 2;i++)
          {var
            complex=ba.get(i),
            b=caml_int64_to_bytes(caml_int64_bits_of_float(complex[1]));
           for(var j=0;j < 8;j++)writer.write(8,b[j]);
           var b=caml_int64_to_bytes(caml_int64_bits_of_float(complex[2]));
           for(var j=0;j < 8;j++)writer.write(8,b[j])}
         break
        }
      sz[0] = (4 + ba.dims.length) * 4;
      sz[1] = (4 + ba.dims.length) * 8}
    function caml_ba_get_size_per_element(kind)
     {switch(kind){case 7:case 10:case 11:return 2;default:return 1}}
    function caml_ba_create_buffer(kind,size)
     {var g=joo_global_object,view;
      switch(kind)
       {case 0:view = g.Float32Array;break;
        case 1:view = g.Float64Array;break;
        case 2:view = g.Int8Array;break;
        case 3:view = g.Uint8Array;break;
        case 4:view = g.Int16Array;break;
        case 5:view = g.Uint16Array;break;
        case 6:view = g.Int32Array;break;
        case 7:view = g.Int32Array;break;
        case 8:view = g.Int32Array;break;
        case 9:view = g.Int32Array;break;
        case 10:view = g.Float32Array;break;
        case 11:view = g.Float64Array;break;
        case 12:view = g.Uint8Array;break
        }
      if(! view)caml_invalid_argument("Bigarray.create: unsupported kind");
      var data=new view(size * caml_ba_get_size_per_element(kind));
      return data}
    function caml_int32_float_of_bits(x)
     {var int32a=new (joo_global_object.Int32Array)(1);
      int32a[0] = x;
      var float32a=new (joo_global_object.Float32Array)(int32a.buffer);
      return float32a[0]}
    function caml_int64_float_of_bits(x)
     {var lo=x.lo,mi=x.mi,hi=x.hi,exp=(hi & 0x7fff) >> 4;
      if(exp == 2047)
       return (lo | mi | hi & 0xf) == 0?hi & 0x8000?- Infinity:Infinity:NaN;
      var k=Math.pow(2,- 24),res=(lo * k + mi) * k + (hi & 0xf);
      if(exp > 0)
       {res += 16;res *= Math.pow(2,exp - 1027)}
      else
       res *= Math.pow(2,- 1026);
      if(hi & 0x8000)res = - res;
      return res}
    function caml_ba_get_size(dims)
     {var n_dims=dims.length,size=1;
      for(var i=0;i < n_dims;i++)
       {if(dims[i] < 0)
         caml_invalid_argument("Bigarray.create: negative dimension");
        size = size * dims[i]}
      return size}
    function caml_int64_create_lo_hi(lo,hi)
     {return new
              MlInt64
              (lo & 0xffffff,
               lo >>> 24 & 0xff | (hi & 0xffff) << 8,
               hi >>> 16 & 0xffff)}
    function caml_int64_hi32(v){return v.hi32()}
    function caml_int64_lo32(v){return v.lo32()}
    var caml_ba_custom_name="_bigarr02";
    function Ml_Bigarray(kind,layout,dims,buffer)
     {this.kind = kind;
      this.layout = layout;
      this.dims = dims;
      this.data = buffer}
    Ml_Bigarray.prototype.caml_custom = caml_ba_custom_name;
    Ml_Bigarray.prototype.offset
    =
    function(arg)
     {var ofs=0;
      if(typeof arg === "number")arg = [arg];
      if(! (arg instanceof Array))
       caml_invalid_argument("bigarray.js: invalid offset");
      if(this.dims.length != arg.length)
       caml_invalid_argument("Bigarray.get/set: bad number of dimensions");
      if(this.layout == 0)
       for(var i=0;i < this.dims.length;i++)
        {if(arg[i] < 0 || arg[i] >= this.dims[i])caml_array_bound_error();
         ofs = ofs * this.dims[i] + arg[i]}
      else
       for(var i=this.dims.length - 1;i >= 0;i--)
        {if(arg[i] < 1 || arg[i] > this.dims[i])caml_array_bound_error();
         ofs = ofs * this.dims[i] + (arg[i] - 1)}
      return ofs};
    Ml_Bigarray.prototype.get
    =
    function(ofs)
     {switch(this.kind)
       {case 7:
         var l=this.data[ofs * 2 + 0],h=this.data[ofs * 2 + 1];
         return caml_int64_create_lo_hi(l,h);
        case 10:
        case 11:
         var r=this.data[ofs * 2 + 0],i=this.data[ofs * 2 + 1];
         return [254,r,i];
        default:return this.data[ofs]}};
    Ml_Bigarray.prototype.set
    =
    function(ofs,v)
     {switch(this.kind)
       {case 7:
         this.data[ofs * 2 + 0] = caml_int64_lo32(v);
         this.data[ofs * 2 + 1] = caml_int64_hi32(v);
         break;
        case 10:
        case 11:
         this.data[ofs * 2 + 0] = v[1];this.data[ofs * 2 + 1] = v[2];break;
        default:this.data[ofs] = v;break}
      return 0};
    Ml_Bigarray.prototype.fill
    =
    function(v)
     {switch(this.kind)
       {case 7:
         var a=caml_int64_lo32(v),b=caml_int64_hi32(v);
         if(a == b)
          this.data.fill(a);
         else
          for(var i=0;i < this.data.length;i++)this.data[i] = i % 2 == 0?a:b;
         break;
        case 10:
        case 11:
         var im=v[1],re=v[2];
         if(im == re)
          this.data.fill(im);
         else
          for(var i=0;i < this.data.length;i++)
           this.data[i] = i % 2 == 0?im:re;
         break;
        default:this.data.fill(v);break}};
    Ml_Bigarray.prototype.compare
    =
    function(b,total)
     {if(this.layout != b.layout || this.kind != b.kind)
       {var k1=this.kind | this.layout << 8,k2=b.kind | b.layout << 8;
        return k2 - k1}
      if(this.dims.length != b.dims.length)
       return b.dims.length - this.dims.length;
      for(var i=0;i < this.dims.length;i++)
       if(this.dims[i] != b.dims[i])return this.dims[i] < b.dims[i]?- 1:1;
      switch(this.kind)
       {case 0:
        case 1:
        case 10:
        case 11:
         var x,y;
         for(var i=0;i < this.data.length;i++)
          {x = this.data[i];
           y = b.data[i];
           if(x < y)return - 1;
           if(x > y)return 1;
           if(x != y)
            {if(! total)return NaN;if(x == x)return 1;if(y == y)return - 1}}
         break;
        case 7:
         for(var i=0;i < this.data.length;i += 2)
          {if(this.data[i + 1] < b.data[i + 1])return - 1;
           if(this.data[i + 1] > b.data[i + 1])return 1;
           if(this.data[i] >>> 0 < b.data[i] >>> 0)return - 1;
           if(this.data[i] >>> 0 > b.data[i] >>> 0)return 1}
         break;
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 8:
        case 9:
        case 12:
         for(var i=0;i < this.data.length;i++)
          {if(this.data[i] < b.data[i])return - 1;
           if(this.data[i] > b.data[i])return 1}
         break
        }
      return 0};
    function Ml_Bigarray_c_1_1(kind,layout,dims,buffer)
     {this.kind = kind;
      this.layout = layout;
      this.dims = dims;
      this.data = buffer}
    Ml_Bigarray_c_1_1.prototype = new Ml_Bigarray();
    Ml_Bigarray_c_1_1.prototype.offset
    =
    function(arg)
     {if(typeof arg !== "number")
       if(arg instanceof Array && arg.length == 1)
        arg = arg[0];
       else
        caml_invalid_argument("Ml_Bigarray_c_1_1.offset");
      if(arg < 0 || arg >= this.dims[0])caml_array_bound_error();
      return arg};
    Ml_Bigarray_c_1_1.prototype.get = function(ofs){return this.data[ofs]};
    Ml_Bigarray_c_1_1.prototype.set
    =
    function(ofs,v){this.data[ofs] = v;return 0};
    Ml_Bigarray_c_1_1.prototype.fill
    =
    function(v){this.data.fill(v);return 0};
    function caml_ba_create_unsafe(kind,layout,dims,data)
     {var size_per_element=caml_ba_get_size_per_element(kind);
      if(caml_ba_get_size(dims) * size_per_element != data.length)
       caml_invalid_argument("length doesn't match dims");
      if(layout == 0 && dims.length == 1 && size_per_element == 1)
       return new Ml_Bigarray_c_1_1(kind,layout,dims,data);
      return new Ml_Bigarray(kind,layout,dims,data)}
    function caml_ba_deserialize(reader,sz,name)
     {var num_dims=reader.read32s();
      if(num_dims < 0 || num_dims > 16)
       caml_failwith("input_value: wrong number of bigarray dimensions");
      var tag=reader.read32s(),kind=tag & 0xff,layout=tag >> 8 & 1,dims=[];
      if(name == "_bigarr02")
       for(var i=0;i < num_dims;i++)
        {var size_dim=reader.read16u();
         if(size_dim == 0xffff)
          {var size_dim_hi=reader.read32u(),size_dim_lo=reader.read32u();
           if(size_dim_hi != 0)
            caml_failwith("input_value: bigarray dimension overflow in 32bit");
           size_dim = size_dim_lo}
         dims.push(size_dim)}
      else
       for(var i=0;i < num_dims;i++)dims.push(reader.read32u());
      var
       size=caml_ba_get_size(dims),
       data=caml_ba_create_buffer(kind,size),
       ba=caml_ba_create_unsafe(kind,layout,dims,data);
      switch(kind)
       {case 2:for(var i=0;i < size;i++)data[i] = reader.read8s();break;
        case 3:
        case 12:for(var i=0;i < size;i++)data[i] = reader.read8u();break;
        case 4:for(var i=0;i < size;i++)data[i] = reader.read16s();break;
        case 5:for(var i=0;i < size;i++)data[i] = reader.read16u();break;
        case 6:for(var i=0;i < size;i++)data[i] = reader.read32s();break;
        case 8:
        case 9:
         var sixty=reader.read8u();
         if(sixty)
          caml_failwith
           ("input_value: cannot read bigarray with 64-bit OCaml ints");
         for(var i=0;i < size;i++)data[i] = reader.read32s();
         break;
        case 7:
         var t=new Array(8);
         for(var i=0;i < size;i++)
          {for(var j=0;j < 8;j++)t[j] = reader.read8u();
           var int64=caml_int64_of_bytes(t);
           ba.set(i,int64)}
         break;
        case 1:
         var t=new Array(8);
         for(var i=0;i < size;i++)
          {for(var j=0;j < 8;j++)t[j] = reader.read8u();
           var f=caml_int64_float_of_bits(caml_int64_of_bytes(t));
           ba.set(i,f)}
         break;
        case 0:
         for(var i=0;i < size;i++)
          {var f=caml_int32_float_of_bits(reader.read32s());ba.set(i,f)}
         break;
        case 10:
         for(var i=0;i < size;i++)
          {var
            re=caml_int32_float_of_bits(reader.read32s()),
            im=caml_int32_float_of_bits(reader.read32s());
           ba.set(i,[254,re,im])}
         break;
        case 11:
         var t=new Array(8);
         for(var i=0;i < size;i++)
          {for(var j=0;j < 8;j++)t[j] = reader.read8u();
           var re=caml_int64_float_of_bits(caml_int64_of_bytes(t));
           for(var j=0;j < 8;j++)t[j] = reader.read8u();
           var im=caml_int64_float_of_bits(caml_int64_of_bytes(t));
           ba.set(i,[254,re,im])}
         break
        }
      sz[0] = (4 + num_dims) * 4;
      return caml_ba_create_unsafe(kind,layout,dims,data)}
    function caml_ba_compare(a,b,total){return a.compare(b,total)}
    function caml_hash_mix_int64(h,v)
     {h = caml_hash_mix_int(h,caml_int64_lo32(v));
      h = caml_hash_mix_int(h,caml_int64_hi32(v));
      return h}
    function caml_hash_mix_float(h,v0)
     {return caml_hash_mix_int64(h,caml_int64_bits_of_float(v0))}
    function caml_ba_hash(ba)
     {var num_elts=caml_ba_get_size(ba.dims),h=0;
      switch(ba.kind)
       {case 2:
        case 3:
        case 12:
         if(num_elts > 256)num_elts = 256;
         var w=0,i=0;
         for(i = 0;i + 4 <= ba.data.length;i += 4)
          {w
           =
           ba.data[i + 0]
           |
           ba.data[i + 1]
           <<
           8
           |
           ba.data[i + 2]
           <<
           16
           |
           ba.data[i + 3]
           <<
           24;
           h = caml_hash_mix_int(h,w)}
         w = 0;
         switch(num_elts & 3)
          {case 3:w = ba.data[i + 2] << 16;
           case 2:w |= ba.data[i + 1] << 8;
           case 1:w |= ba.data[i + 0];h = caml_hash_mix_int(h,w)
           }
         break;
        case 4:
        case 5:
         if(num_elts > 128)num_elts = 128;
         var w=0,i=0;
         for(i = 0;i + 2 <= ba.data.length;i += 2)
          {w = ba.data[i + 0] | ba.data[i + 1] << 16;
           h = caml_hash_mix_int(h,w)}
         if((num_elts & 1) != 0)h = caml_hash_mix_int(h,ba.data[i]);
         break;
        case 6:
         if(num_elts > 64)num_elts = 64;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_int(h,ba.data[i]);
         break;
        case 8:
        case 9:
         if(num_elts > 64)num_elts = 64;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_int(h,ba.data[i]);
         break;
        case 7:
         if(num_elts > 32)num_elts = 32;
         num_elts *= 2;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_int(h,ba.data[i]);
         break;
        case 10:num_elts *= 2;
        case 0:
         if(num_elts > 64)num_elts = 64;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_float(h,ba.data[i]);
         break;
        case 11:num_elts *= 2;
        case 1:
         if(num_elts > 32)num_elts = 32;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_float(h,ba.data[i]);
         break
        }
      return h}
    function caml_int32_unmarshal(reader,size)
     {size[0] = 4;return reader.read32s()}
    function caml_nativeint_unmarshal(reader,size)
     {switch(reader.read8u())
       {case 1:size[0] = 4;return reader.read32s();
        case 2:caml_failwith("input_value: native integer value too large");
        default:caml_failwith("input_value: ill-formed native integer")}}
    function caml_int64_unmarshal(reader,size)
     {var t=new Array(8);
      for(var j=0;j < 8;j++)t[j] = reader.read8u();
      size[0] = 8;
      return caml_int64_of_bytes(t)}
    function caml_int64_compare(x,y,total){return x.compare(y)}
    function caml_int64_hash(v){return v.lo32() ^ v.hi32()}
    var
     caml_custom_ops=
      {"_j":
       {deserialize:caml_int64_unmarshal,
        serialize:caml_int64_marshal,
        fixed_length:8,
        compare:caml_int64_compare,
        hash:caml_int64_hash},
       "_i":{deserialize:caml_int32_unmarshal,fixed_length:4},
       "_n":{deserialize:caml_nativeint_unmarshal,fixed_length:4},
       "_bigarray":
       {deserialize:
        function(reader,sz){return caml_ba_deserialize(reader,sz,"_bigarray")},
        serialize:caml_ba_serialize,
        compare:caml_ba_compare,
        hash:caml_ba_hash},
       "_bigarr02":
       {deserialize:
        function(reader,sz){return caml_ba_deserialize(reader,sz,"_bigarr02")},
        serialize:caml_ba_serialize,
        compare:caml_ba_compare,
        hash:caml_ba_hash}};
    function caml_compare_val_get_custom(a)
     {return caml_custom_ops[a.caml_custom]
             &&
             caml_custom_ops[a.caml_custom].compare}
    function caml_compare_val_number_custom(num,custom,swap,total)
     {var comp=caml_compare_val_get_custom(custom);
      if(comp)
       {var x=swap > 0?comp(custom,num,total):comp(num,custom,total);
        if(total && x != x)return swap;
        if(+ x != + x)return + x;
        if((x | 0) != 0)return x | 0}
      return swap}
    function caml_compare_val_tag(a)
     {if(typeof a === "number")
       return 1000;
      else
       if(caml_is_ml_bytes(a))
        return 252;
       else
        if(caml_is_ml_string(a))
         return 1252;
        else
         if(a instanceof Array && a[0] === a[0] >>> 0 && a[0] <= 255)
          {var tag=a[0] | 0;return tag == 254?0:tag}
         else
          if(a instanceof String)
           return 12520;
          else
           if(typeof a == "string")
            return 12520;
           else
            if(a instanceof Number)
             return 1000;
            else
             if(a && a.caml_custom)
              return 1255;
             else
              if(a && a.compare)
               return 1256;
              else
               if(typeof a == "function")
                return 1247;
               else
                if(typeof a == "symbol")return 1251;
      return 1001}
    function caml_int_compare(a,b)
     {if(a < b)return - 1;if(a == b)return 0;return 1}
    function caml_bytes_compare(s1,s2)
     {s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c < s2.c?- 1:s1.c > s2.c?1:0}
    function caml_string_compare(s1,s2){return caml_bytes_compare(s1,s2)}
    function caml_compare_val(a,b,total)
     {var stack=[];
      for(;;)
       {if(! (total && a === b))
         {var tag_a=caml_compare_val_tag(a);
          if(tag_a == 250){a = a[1];continue}
          var tag_b=caml_compare_val_tag(b);
          if(tag_b == 250){b = b[1];continue}
          if(tag_a !== tag_b)
           {if(tag_a == 1000)
             {if(tag_b == 1255)
               return caml_compare_val_number_custom(a,b,- 1,total);
              return - 1}
            if(tag_b == 1000)
             {if(tag_a == 1255)
               return caml_compare_val_number_custom(b,a,1,total);
              return 1}
            return tag_a < tag_b?- 1:1}
          switch(tag_a)
           {case 247:caml_invalid_argument("compare: functional value");break;
            case 248:
             var x=caml_int_compare(a[2],b[2]);if(x != 0)return x | 0;break;
            case 249:caml_invalid_argument("compare: functional value");break;
            case 250:
             caml_invalid_argument
              ("equal: got Forward_tag, should not happen");
             break;
            case 251:caml_invalid_argument("equal: abstract value");break;
            case 252:
             if(a !== b){var x=caml_bytes_compare(a,b);if(x != 0)return x | 0}
             break;
            case 253:
             caml_invalid_argument("equal: got Double_tag, should not happen");
             break;
            case 254:
             caml_invalid_argument
              ("equal: got Double_array_tag, should not happen");
             break;
            case 255:
             caml_invalid_argument("equal: got Custom_tag, should not happen");
             break;
            case 1247:
             caml_invalid_argument("compare: functional value");break;
            case 1255:
             var comp=caml_compare_val_get_custom(a);
             if(comp != caml_compare_val_get_custom(b))
              return a.caml_custom < b.caml_custom?- 1:1;
             if(! comp)caml_invalid_argument("compare: abstract value");
             var x=comp(a,b,total);
             if(x != x)return total?- 1:x;
             if(x !== (x | 0))return - 1;
             if(x != 0)return x | 0;
             break;
            case 1256:
             var x=a.compare(b,total);
             if(x != x)return total?- 1:x;
             if(x !== (x | 0))return - 1;
             if(x != 0)return x | 0;
             break;
            case 1000:
             a = + a;
             b = + b;
             if(a < b)return - 1;
             if(a > b)return 1;
             if(a != b)
              {if(! total)return NaN;if(a == a)return 1;if(b == b)return - 1}
             break;
            case 1001:
             if(a < b)return - 1;
             if(a > b)return 1;
             if(a != b)
              {if(! total)return NaN;if(a == a)return 1;if(b == b)return - 1}
             break;
            case 1251:if(a !== b){if(! total)return NaN;return 1}break;
            case 1252:
             var a=caml_jsbytes_of_string(a),b=caml_jsbytes_of_string(b);
             if(a !== b){if(a < b)return - 1;if(a > b)return 1}
             break;
            case 12520:
             var a=a.toString(),b=b.toString();
             if(a !== b){if(a < b)return - 1;if(a > b)return 1}
             break;
            case 246:
            case 254:
            default:
             if(a.length != b.length)return a.length < b.length?- 1:1;
             if(a.length > 1)stack.push(a,b,1);
             break}}
        if(stack.length == 0)return 0;
        var i=stack.pop();
        b = stack.pop();
        a = stack.pop();
        if(i + 1 < a.length)stack.push(a,b,i + 1);
        a = a[i];
        b = b[i]}}
    function caml_greaterthan(x,y){return + (caml_compare_val(x,y,false) > 0)}
    function div_helper(a,b,c)
     {var
       x=a * 65536 + (b >>> 16),
       y=Math.floor(x / c) * 65536,
       z=x % c * 65536,
       w=z + (b & 0x0000FFFF);
      return [y + Math.floor(w / c),w % c]}
    function div_digit_nat(natq,ofsq,natr,ofsr,nat1,ofs1,len,nat2,ofs2)
     {var rem=nat1.data[ofs1 + len - 1] >>> 0;
      for(var i=len - 2;i >= 0;i--)
       {var x=div_helper(rem,nat1.data[ofs1 + i] >>> 0,nat2.data[ofs2] >>> 0);
        natq.data[ofsq + i] = x[0];
        rem = x[1]}
      natr.data[ofsr] = rem;
      return 0}
    function num_leading_zero_bits_in_digit(nat,ofs)
     {var a=nat.data[ofs],b=0;
      if(a & 0xFFFF0000){b += 16;a >>>= 16}
      if(a & 0xFF00){b += 8;a >>>= 8}
      if(a & 0xF0){b += 4;a >>>= 4}
      if(a & 12){b += 2;a >>>= 2}
      if(a & 2){b += 1;a >>>= 1}
      if(a & 1)b += 1;
      return 32 - b}
    function shift_left_nat(nat1,ofs1,len1,nat2,ofs2,nbits)
     {if(nbits == 0){nat2.data[ofs2] = 0;return 0}
      var wrap=0;
      for(var i=0;i < len1;i++)
       {var a=nat1.data[ofs1 + i] >>> 0;
        nat1.data[ofs1 + i] = a << nbits | wrap;
        wrap = a >>> 32 - nbits}
      nat2.data[ofs2] = wrap;
      return 0}
    function MlNat(x)
     {this.data = new (joo_global_object.Int32Array)(x);
      this.length = this.data.length + 2}
    MlNat.prototype.caml_custom = "_nat";
    function create_nat(size)
     {var arr=new MlNat(size);
      for(var i=0;i < size;i++)arr.data[i] = - 1;
      return arr}
    function set_to_zero_nat(nat,ofs,len)
     {for(var i=0;i < len;i++)nat.data[ofs + i] = 0;return 0}
    function incr_nat(nat,ofs,len,carry_in)
     {var carry=carry_in;
      for(var i=0;i < len;i++)
       {var x=(nat.data[ofs + i] >>> 0) + carry;
        nat.data[ofs + i] = x | 0;
        if(x == x >>> 0){carry = 0;break}else carry = 1}
      return carry}
    function add_nat(nat1,ofs1,len1,nat2,ofs2,len2,carry_in)
     {var carry=carry_in;
      for(var i=0;i < len2;i++)
       {var
         x=
          (nat1.data[ofs1 + i] >>> 0) + (nat2.data[ofs2 + i] >>> 0) + carry;
        nat1.data[ofs1 + i] = x;
        if(x == x >>> 0)carry = 0;else carry = 1}
      return incr_nat(nat1,ofs1 + len2,len1 - len2,carry)}
    function nat_of_array(l){return new MlNat(l)}
    function mult_digit_nat(nat1,ofs1,len1,nat2,ofs2,len2,nat3,ofs3)
     {var carry=0,a=nat3.data[ofs3] >>> 0;
      for(var i=0;i < len2;i++)
       {var
         x1=
          (nat1.data[ofs1 + i] >>> 0)
          +
          (nat2.data[ofs2 + i] >>> 0)
          *
          (a & 0x0000FFFF)
          +
          carry,
         x2=(nat2.data[ofs2 + i] >>> 0) * (a >>> 16);
        carry = Math.floor(x2 / 65536);
        var x3=x1 + x2 % 65536 * 65536;
        nat1.data[ofs1 + i] = x3;
        carry += Math.floor(x3 / 4294967296)}
      return len2 < len1 && carry
              ?add_nat
                (nat1,ofs1 + len2,len1 - len2,nat_of_array([carry]),0,1,0)
              :carry}
    function decr_nat(nat,ofs,len,carry_in)
     {var borrow=carry_in == 1?0:1;
      for(var i=0;i < len;i++)
       {var x=(nat.data[ofs + i] >>> 0) - borrow;
        nat.data[ofs + i] = x;
        if(x >= 0){borrow = 0;break}else borrow = 1}
      return borrow == 1?0:1}
    function sub_nat(nat1,ofs1,len1,nat2,ofs2,len2,carry_in)
     {var borrow=carry_in == 1?0:1;
      for(var i=0;i < len2;i++)
       {var
         x=
          (nat1.data[ofs1 + i] >>> 0) - (nat2.data[ofs2 + i] >>> 0) - borrow;
        nat1.data[ofs1 + i] = x;
        if(x >= 0)borrow = 0;else borrow = 1}
      return decr_nat(nat1,ofs1 + len2,len1 - len2,borrow == 1?0:1)}
    function compare_nat(nat1,ofs1,len1,nat2,ofs2,len2)
     {var a=num_digits_nat(nat1,ofs1,len1),b=num_digits_nat(nat2,ofs2,len2);
      if(a > b)return 1;
      if(a < b)return - 1;
      for(var i=len1 - 1;i >= 0;i--)
       {if(nat1.data[ofs1 + i] >>> 0 > nat2.data[ofs2 + i] >>> 0)return 1;
        if(nat1.data[ofs1 + i] >>> 0 < nat2.data[ofs2 + i] >>> 0)return - 1}
      return 0}
    function div_nat(nat1,ofs1,len1,nat2,ofs2,len2)
     {if(len2 == 1)
       {div_digit_nat(nat1,ofs1 + 1,nat1,ofs1,nat1,ofs1,len1,nat2,ofs2);
        return 0}
      var s=num_leading_zero_bits_in_digit(nat2,ofs2 + len2 - 1);
      shift_left_nat(nat2,ofs2,len2,nat_of_array([0]),0,s);
      shift_left_nat(nat1,ofs1,len1,nat_of_array([0]),0,s);
      var d=(nat2.data[ofs2 + len2 - 1] >>> 0) + 1,a=create_nat(len2 + 1);
      for(var i=len1 - 1;i >= len2;i--)
       {var
         quo=
          d == 4294967296
           ?nat1.data[ofs1 + i] >>> 0
           :div_helper
              (nat1.data[ofs1 + i] >>> 0,nat1.data[ofs1 + i - 1] >>> 0,d)
             [0];
        set_to_zero_nat(a,0,len2 + 1);
        mult_digit_nat(a,0,len2 + 1,nat2,ofs2,len2,nat_of_array([quo]),0);
        sub_nat(nat1,ofs1 + i - len2,len2 + 1,a,0,len2 + 1,1);
        while
         (nat1.data[ofs1 + i]
          !=
          0
          ||
          compare_nat(nat1,ofs1 + i - len2,len2,nat2,ofs2,len2)
          >=
          0)
         {quo = quo + 1;
          sub_nat(nat1,ofs1 + i - len2,len2 + 1,nat2,ofs2,len2,1)}
        nat1.data[ofs1 + i] = quo}
      shift_right_nat(nat1,ofs1,len2,nat_of_array([0]),0,s);
      shift_right_nat(nat2,ofs2,len2,nat_of_array([0]),0,s);
      return 0}
    function caml_ba_blit(src,dst)
     {if(dst.dims.length != src.dims.length)
       caml_invalid_argument("Bigarray.blit: dimension mismatch");
      for(var i=0;i < dst.dims.length;i++)
       if(dst.dims[i] != src.dims[i])
        caml_invalid_argument("Bigarray.blit: dimension mismatch");
      dst.data.set(src.data);
      return 0}
    function is_digit_int(nat,ofs){if(nat.data[ofs] >= 0)return 1;return 0}
    function caml_int64_div(x,y){return x.div(y)}
    function caml_js_html_entities(s)
     {var entity=/^&#?[0-9a-zA-Z]+;$/;
      if(s.match(entity))
       {var str,temp=document.createElement("p");
        temp.innerHTML = s;
        str = temp.textContent || temp.innerText;
        temp = null;
        return str}
      else
       caml_failwith("Invalid entity " + s)}
    function caml_string_unsafe_set(s,i,c)
     {return caml_bytes_unsafe_set(s,i,c)}
    function caml_int64_of_float(x)
     {if(x < 0)x = Math.ceil(x);
      return new
              MlInt64
              (x & 0xffffff,
               Math.floor(x * caml_int64_offset) & 0xffffff,
               Math.floor(x * caml_int64_offset * caml_int64_offset) & 0xffff)}
    function caml_ml_channel_size_64(chanid)
     {var chan=caml_ml_channels[chanid];
      return caml_int64_of_float(chan.file.length())}
    function caml_ba_set_2(ba,i0,i1,v){ba.set(ba.offset([i0,i1]),v);return 0}
    var
     caml_argv=
      function()
        {var g=joo_global_object,main="a.out",args=[];
         if(g.process && g.process.argv && g.process.argv.length > 1)
          {var argv=g.process.argv;main = argv[1];args = argv.slice(2)}
         var p=caml_string_of_jsstring(main),args2=[0,p];
         for(var i=0;i < args.length;i++)
          args2.push(caml_string_of_jsstring(args[i]));
         return args2}
       (),
     caml_executable_name=caml_argv[1];
    function caml_js_eval_string(s){return eval(caml_jsstring_of_string(s))}
    function caml_CamlinternalMod_init_mod(loc,shape)
     {function undef_module(_x)
       {caml_raise_with_arg(caml_global_data.Undefined_recursive_module,loc)}
      function loop(shape,struct,idx)
       {if(typeof shape === "number")
         switch(shape)
          {case 0:struct[idx] = {fun:undef_module};break;
           case 1:struct[idx] = [246,undef_module];break;
           default:struct[idx] = []}
        else
         switch(shape[0])
          {case 0:
            struct[idx] = [0];
            for(var i=1;i < shape[1].length;i++)
             loop(shape[1][i],struct[idx],i);
            break;
           default:struct[idx] = shape[1]}}
      var res=[];
      loop(shape,res,0);
      return res[0]}
    function serialize_nat(writer,nat,sz)
     {var len=nat.data.length;
      writer.write(32,len);
      for(var i=0;i < len;i++)writer.write(32,nat.data[i]);
      sz[0] = len * 4;
      sz[1] = len * 8}
    function caml_memprof_set(_control){return 0}
    function caml_sys_exit(code)
     {var g=joo_global_object;
      if(g.quit)g.quit(code);
      if(g.process && g.process.exit)g.process.exit(code);
      caml_invalid_argument("Function 'exit' not implemented")}
    function caml_channel_descriptor(chanid)
     {var chan=caml_ml_channels[chanid];return chan.fd}
    function caml_js_from_array(a){return a.slice(1)}
    function caml_ba_reshape(ba,vind)
     {vind = caml_js_from_array(vind);
      var new_dim=[],num_dims=vind.length;
      if(num_dims < 0 || num_dims > 16)
       caml_invalid_argument("Bigarray.reshape: bad number of dimensions");
      var num_elts=1;
      for(var i=0;i < num_dims;i++)
       {new_dim[i] = vind[i];
        if(new_dim[i] < 0)
         caml_invalid_argument("Bigarray.reshape: negative dimension");
        num_elts = num_elts * new_dim[i]}
      var size=caml_ba_get_size(ba.dims);
      if(num_elts != size)
       caml_invalid_argument("Bigarray.reshape: size mismatch");
      return caml_ba_create_unsafe(ba.kind,ba.layout,new_dim,ba.data)}
    var caml_oo_last_id=0;
    function caml_set_oo_id(b){b[2] = caml_oo_last_id++;return b}
    function caml_gr_fill_rect(x,y,w,h)
     {var s=caml_gr_state_get();
      s.context.fillRect(x,s.height - y,w,- h);
      return 0}
    function caml_bigstring_blit_string_to_ba(str1,pos1,ba2,pos2,len)
     {if(12 != ba2.kind)
       caml_invalid_argument
        ("caml_bigstring_blit_string_to_ba: kind mismatch");
      if(len == 0)return 0;
      var ofs2=ba2.offset(pos2);
      if(pos1 + len > caml_ml_string_length(str1))caml_array_bound_error();
      if(ofs2 + len > ba2.data.length)caml_array_bound_error();
      var slice=caml_array_of_string(str1).slice(pos1,pos1 + len);
      ba2.data.set(slice,ofs2);
      return 0}
    function caml_gr_set_window_title(name)
     {var s=caml_gr_state_get();
      s.title = name;
      var jsname=caml_jsstring_of_string(name);
      if(s.set_title)s.set_title(jsname);
      return 0}
    function caml_get_global_data(){return caml_global_data}
    function caml_int64_shift_right_unsigned(x,s)
     {return x.shift_right_unsigned(s)}
    function caml_ba_uint8_get16(ba,i0)
     {var ofs=ba.offset(i0);
      if(ofs + 1 >= ba.data.length)caml_array_bound_error();
      var b1=ba.get(ofs),b2=ba.get(ofs + 1);
      return b1 | b2 << 8}
    function caml_compare(a,b){return caml_compare_val(a,b,true)}
    function caml_fresh_oo_id(){return caml_oo_last_id++}
    function caml_int64_to_float(x){return x.toFloat()}
    function caml_ba_get_1(ba,i0){return ba.get(ba.offset(i0))}
    function caml_bigstring_memcmp(s1,pos1,s2,pos2,len)
     {for(var i=0;i < len;i++)
       {var a=caml_ba_get_1(s1,pos1 + i),b=caml_ba_get_1(s2,pos2 + i);
        if(a < b)return - 1;
        if(a > b)return 1}
      return 0}
    function caml_new_string(s){return caml_string_of_jsbytes(s)}
    function caml_ba_uint8_get32(ba,i0)
     {var ofs=ba.offset(i0);
      if(ofs + 3 >= ba.data.length)caml_array_bound_error();
      var
       b1=ba.get(ofs + 0),
       b2=ba.get(ofs + 1),
       b3=ba.get(ofs + 2),
       b4=ba.get(ofs + 3);
      return b1 << 0 | b2 << 8 | b3 << 16 | b4 << 24}
    function caml_raw_backtrace_length(){return 0}
    function caml_obj_block(tag,size)
     {var o=new Array(size + 1);
      o[0] = tag;
      for(var i=1;i <= size;i++)o[i] = 0;
      return o}
    function caml_gr_clear_graph()
     {var s=caml_gr_state_get();
      s.canvas.width = s.width;
      s.canvas.height = s.height;
      return 0}
    function bigstring_to_array_buffer(bs){return bs.data.buffer}
    function caml_sys_const_naked_pointers_checked(_unit){return 0}
    function lxor_digit_nat(nat1,ofs1,nat2,ofs2)
     {nat1.data[ofs1] ^= nat2.data[ofs2];return 0}
    function caml_final_release(){return 0}
    function caml_js_to_array(a)
     {var len=a.length,b=new Array(len + 1);
      b[0] = 0;
      for(var i=0;i < len;i++)b[i + 1] = a[i];
      return b}
    function caml_gr_plot(x,y)
     {var
       s=caml_gr_state_get(),
       im=s.context.createImageData(1,1),
       d=im.data,
       color=s.color;
      d[0] = color >> 16 & 0xff;
      d[1] = color >> 8 & 0xff,d[2] = color >> 0 & 0xff;
      d[3] = 0xFF;
      s.x = x;
      s.y = y;
      s.context.putImageData(im,x,s.height - y);
      return 0}
    function caml_bytes_set64(s,i,i64)
     {if(i >>> 0 >= s.l - 7)caml_bytes_bound_error();
      var a=caml_int64_to_bytes(i64);
      for(var j=0;j < 8;j++)caml_bytes_unsafe_set(s,i + 7 - j,a[j]);
      return 0}
    function caml_bytes_set16(s,i,i16)
     {if(i >>> 0 >= s.l - 1)caml_bytes_bound_error();
      var b2=0xFF & i16 >> 8,b1=0xFF & i16;
      caml_bytes_unsafe_set(s,i + 0,b1);
      caml_bytes_unsafe_set(s,i + 1,b2);
      return 0}
    function caml_string_set16(s,i,i16){return caml_bytes_set16(s,i,i16)}
    function caml_int64_bswap(x)
     {var y=caml_int64_to_bytes(x);
      return caml_int64_of_bytes([y[7],y[6],y[5],y[4],y[3],y[2],y[1],y[0]])}
    function caml_fill_bytes(s,i,l,c)
     {if(l > 0)
       if(i == 0 && (l >= s.l || s.t == 2 && l >= s.c.length))
        if(c == 0)
         {s.c = "";s.t = 2}
        else
         {s.c = caml_str_repeat(l,String.fromCharCode(c));s.t = l == s.l?0:2}
       else
        {if(s.t != 4)caml_convert_bytes_to_array(s);
         for(l += i;i < l;i++)s.c[i] = c}
      return 0}
    var caml_fill_string=caml_fill_bytes;
    function caml_gc_major(){return 0}
    function caml_lex_array(s)
     {s = caml_jsbytes_of_string(s);
      var l=s.length / 2,a=new Array(l);
      for(var i=0;i < l;i++)
       a[i]
       =
       (s.charCodeAt(2 * i) | s.charCodeAt(2 * i + 1) << 8)
       <<
       16
       >>
       16;
      return a}
    function caml_lex_engine(tbl,start_state,lexbuf)
     {var
       lex_buffer=2,
       lex_buffer_len=3,
       lex_start_pos=5,
       lex_curr_pos=6,
       lex_last_pos=7,
       lex_last_action=8,
       lex_eof_reached=9,
       lex_base=1,
       lex_backtrk=2,
       lex_default=3,
       lex_trans=4,
       lex_check=5;
      if(! tbl.lex_default)
       {tbl.lex_base = caml_lex_array(tbl[lex_base]);
        tbl.lex_backtrk = caml_lex_array(tbl[lex_backtrk]);
        tbl.lex_check = caml_lex_array(tbl[lex_check]);
        tbl.lex_trans = caml_lex_array(tbl[lex_trans]);
        tbl.lex_default = caml_lex_array(tbl[lex_default])}
      var c,state=start_state,buffer=caml_array_of_bytes(lexbuf[lex_buffer]);
      if(state >= 0)
       {lexbuf[lex_last_pos] = lexbuf[lex_start_pos] = lexbuf[lex_curr_pos];
        lexbuf[lex_last_action] = - 1}
      else
       state = - state - 1;
      for(;;)
       {var base=tbl.lex_base[state];
        if(base < 0)return - base - 1;
        var backtrk=tbl.lex_backtrk[state];
        if(backtrk >= 0)
         {lexbuf[lex_last_pos] = lexbuf[lex_curr_pos];
          lexbuf[lex_last_action] = backtrk}
        if(lexbuf[lex_curr_pos] >= lexbuf[lex_buffer_len])
         if(lexbuf[lex_eof_reached] == 0)return - state - 1;else c = 256;
        else
         {c = buffer[lexbuf[lex_curr_pos]];lexbuf[lex_curr_pos]++}
        if(tbl.lex_check[base + c] == state)
         state = tbl.lex_trans[base + c];
        else
         state = tbl.lex_default[state];
        if(state < 0)
         {lexbuf[lex_curr_pos] = lexbuf[lex_last_pos];
          if(lexbuf[lex_last_action] == - 1)
           caml_failwith("lexing: empty token");
          else
           return lexbuf[lex_last_action]}
        else
         if(c == 256)lexbuf[lex_eof_reached] = 0}}
    function caml_sys_file_exists(name)
     {var root=resolve_fs_device(name);return root.device.exists(root.rest)}
    function caml_convert_raw_backtrace_slot()
     {caml_failwith("caml_convert_raw_backtrace_slot")}
    function caml_array_sub(a,i,len)
     {var a2=new Array(len + 1);
      a2[0] = 0;
      for(var i2=1,i1=i + 1;i2 <= len;i2++,i1++)a2[i2] = a[i1];
      return a2}
    function caml_bytes_equal(s1,s2)
     {if(s1 === s2)return 1;
      s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c == s2.c?1:0}
    function caml_gr_size_x(){var s=caml_gr_state_get();return s.width}
    function caml_ml_debug_info_status(){return 0}
    function caml_sys_const_ostype_cygwin(){return 0}
    function caml_cosh_float(x){return (Math.exp(x) + Math.exp(- x)) / 2}
    var caml_ephe_key_offset=3;
    function caml_weak_check(x,i)
     {return x[caml_ephe_key_offset + i]
              !==
              undefined
              &&
              x[caml_ephe_key_offset + i]
              !==
              0
              ?1
              :0}
    var caml_ephe_check_key=caml_weak_check;
    function caml_hash_mix_final(h)
     {h ^= h >>> 16;
      h = caml_mul(h,0x85ebca6b | 0);
      h ^= h >>> 13;
      h = caml_mul(h,0xc2b2ae35 | 0);
      h ^= h >>> 16;
      return h}
    function caml_gr_text_size(txt)
     {var
       s=caml_gr_state_get(),
       w=s.context.measureText(caml_jsstring_of_string(txt)).width;
      return [0,w,s.text_size]}
    function caml_lex_run_mem(s,i,mem,curr_pos)
     {for(;;)
       {var dst=s.charCodeAt(i);
        i++;
        if(dst == 0xff)return;
        var src=s.charCodeAt(i);
        i++;
        if(src == 0xff)
         mem[dst + 1] = curr_pos;
        else
         mem[dst + 1] = mem[src + 1]}}
    function caml_lex_run_tag(s,i,mem)
     {for(;;)
       {var dst=s.charCodeAt(i);
        i++;
        if(dst == 0xff)return;
        var src=s.charCodeAt(i);
        i++;
        if(src == 0xff)mem[dst + 1] = - 1;else mem[dst + 1] = mem[src + 1]}}
    function caml_new_lex_engine(tbl,start_state,lexbuf)
     {var
       lex_buffer=2,
       lex_buffer_len=3,
       lex_start_pos=5,
       lex_curr_pos=6,
       lex_last_pos=7,
       lex_last_action=8,
       lex_eof_reached=9,
       lex_mem=10,
       lex_base=1,
       lex_backtrk=2,
       lex_default=3,
       lex_trans=4,
       lex_check=5,
       lex_base_code=6,
       lex_backtrk_code=7,
       lex_default_code=8,
       lex_trans_code=9,
       lex_check_code=10,
       lex_code=11;
      if(! tbl.lex_default)
       {tbl.lex_base = caml_lex_array(tbl[lex_base]);
        tbl.lex_backtrk = caml_lex_array(tbl[lex_backtrk]);
        tbl.lex_check = caml_lex_array(tbl[lex_check]);
        tbl.lex_trans = caml_lex_array(tbl[lex_trans]);
        tbl.lex_default = caml_lex_array(tbl[lex_default])}
      if(! tbl.lex_default_code)
       {tbl.lex_base_code = caml_lex_array(tbl[lex_base_code]);
        tbl.lex_backtrk_code = caml_lex_array(tbl[lex_backtrk_code]);
        tbl.lex_check_code = caml_lex_array(tbl[lex_check_code]);
        tbl.lex_trans_code = caml_lex_array(tbl[lex_trans_code]);
        tbl.lex_default_code = caml_lex_array(tbl[lex_default_code])}
      if(tbl.lex_code == null)
       tbl.lex_code = caml_jsbytes_of_string(tbl[lex_code]);
      var c,state=start_state,buffer=caml_array_of_bytes(lexbuf[lex_buffer]);
      if(state >= 0)
       {lexbuf[lex_last_pos] = lexbuf[lex_start_pos] = lexbuf[lex_curr_pos];
        lexbuf[lex_last_action] = - 1}
      else
       state = - state - 1;
      for(;;)
       {var base=tbl.lex_base[state];
        if(base < 0)
         {var pc_off=tbl.lex_base_code[state];
          caml_lex_run_tag(tbl.lex_code,pc_off,lexbuf[lex_mem]);
          return - base - 1}
        var backtrk=tbl.lex_backtrk[state];
        if(backtrk >= 0)
         {var pc_off=tbl.lex_backtrk_code[state];
          caml_lex_run_tag(tbl.lex_code,pc_off,lexbuf[lex_mem]);
          lexbuf[lex_last_pos] = lexbuf[lex_curr_pos];
          lexbuf[lex_last_action] = backtrk}
        if(lexbuf[lex_curr_pos] >= lexbuf[lex_buffer_len])
         if(lexbuf[lex_eof_reached] == 0)return - state - 1;else c = 256;
        else
         {c = buffer[lexbuf[lex_curr_pos]];lexbuf[lex_curr_pos]++}
        var pstate=state;
        if(tbl.lex_check[base + c] == state)
         state = tbl.lex_trans[base + c];
        else
         state = tbl.lex_default[state];
        if(state < 0)
         {lexbuf[lex_curr_pos] = lexbuf[lex_last_pos];
          if(lexbuf[lex_last_action] == - 1)
           caml_failwith("lexing: empty token");
          else
           return lexbuf[lex_last_action]}
        else
         {var base_code=tbl.lex_base_code[pstate],pc_off;
          if(tbl.lex_check_code[base_code + c] == pstate)
           pc_off = tbl.lex_trans_code[base_code + c];
          else
           pc_off = tbl.lex_default_code[pstate];
          if(pc_off > 0)
           caml_lex_run_mem
            (tbl.lex_code,pc_off,lexbuf[lex_mem],lexbuf[lex_curr_pos]);
          if(c == 256)lexbuf[lex_eof_reached] = 0}}}
    function caml_ba_uint8_set64(ba,i0,v)
     {var ofs=ba.offset(i0);
      if(ofs + 7 >= ba.data.length)caml_array_bound_error();
      var v=caml_int64_to_bytes(v);
      for(var i=0;i < 8;i++)ba.set(ofs + i,v[7 - i]);
      return 0}
    function caml_sys_executable_name(a){return caml_executable_name}
    function caml_lessequal(x,y){return + (caml_compare_val(x,y,false) <= 0)}
    function caml_ml_flush(chanid)
     {var chan=caml_ml_channels[chanid];
      if(! chan.opened)caml_raise_sys_error("Cannot flush a closed channel");
      if(! chan.buffer || chan.buffer == "")return 0;
      if
       (chan.fd
        &&
        caml_global_data.fds[chan.fd]
        &&
        caml_global_data.fds[chan.fd].output)
       {var output=caml_global_data.fds[chan.fd].output;
        switch(output.length)
         {case 2:output(chanid,chan.buffer);break;default:output(chan.buffer)}}
      chan.buffer = "";
      return 0}
    function caml_ml_seek_out_64(chanid,pos)
     {caml_ml_flush(chanid);
      caml_ml_channels[chanid].offset = caml_int64_to_float(pos);
      return 0}
    function compare_nat_real(nat1,nat2)
     {return compare_nat(nat1,0,nat1.data.length,nat2,0,nat2.data.length)}
    function caml_gc_set(_control){return 0}
    function caml_js_get(o,f){return o[f]}
    function caml_gc_compaction(){return 0}
    function caml_weak_get(x,i)
     {if(i < 0 || caml_ephe_key_offset + i >= x.length)
       caml_invalid_argument("Weak.get_key");
      return x[caml_ephe_key_offset + i] === undefined
              ?0
              :x[caml_ephe_key_offset + i]}
    var caml_ephe_get_key=caml_weak_get;
    function caml_bigstring_blit_bytes_to_ba(str1,pos1,ba2,pos2,len)
     {if(12 != ba2.kind)
       caml_invalid_argument
        ("caml_bigstring_blit_string_to_ba: kind mismatch");
      if(len == 0)return 0;
      var ofs2=ba2.offset(pos2);
      if(pos1 + len > caml_ml_bytes_length(str1))caml_array_bound_error();
      if(ofs2 + len > ba2.data.length)caml_array_bound_error();
      var slice=caml_array_of_bytes(str1).slice(pos1,pos1 + len);
      ba2.data.set(slice,ofs2);
      return 0}
    function win_cleanup(){}
    function caml_sys_close(fd){delete caml_global_data.fds[fd];return 0}
    function caml_ml_close_channel(chanid)
     {var chan=caml_ml_channels[chanid];
      caml_ml_flush(chanid);
      chan.opened = false;
      chan.file.close();
      caml_sys_close(chan.fd);
      return 0}
    function caml_exn_with_js_backtrace(exn,force)
     {if(! exn.js_error || force || exn[0] == 248)
       exn.js_error
       =
       new (joo_global_object.Error)("Js exception containing backtrace");
      return exn}
    function caml_sys_isatty(_chan){return 0}
    function is_digit_zero(nat,ofs){if(nat.data[ofs] == 0)return 1;return 0}
    function unix_inet_addr_of_string(){return 0}
    function caml_js_set(o,f,v){o[f] = v;return 0}
    function caml_array_get(array,index)
     {if(index < 0 || index >= array.length - 1)caml_array_bound_error();
      return array[index + 1]}
    function caml_spacetime_only_works_for_native_code()
     {caml_failwith("Spacetime profiling only works for native code")}
    function caml_int64_sub(x,y){return x.sub(y)}
    function caml_ml_seek_in_64(chanid,pos)
     {var chan=caml_ml_channels[chanid];
      if(chan.refill != null)caml_raise_sys_error("Illegal seek");
      chan.offset = caml_int64_to_float(pos);
      return 0}
    function caml_int64_shift_left(x,s){return x.shift_left(s)}
    function caml_notequal(x,y){return + (caml_compare_val(x,y,false) != 0)}
    function caml_sys_const_int_size(){return 32}
    function caml_js_wrap_meth_callback(f)
     {return function()
       {var len=arguments.length,args=new Array(len + 1);
        args[0] = this;
        for(var i=0;i < len;i++)args[i + 1] = arguments[i];
        return caml_call_gen(f,args)}}
    function caml_is_js(){return 1}
    function caml_ba_dim(ba,i)
     {if(i < 0 || i >= ba.dims.length)caml_invalid_argument("Bigarray.dim");
      return ba.dims[i]}
    function caml_ba_dim_1(ba){return caml_ba_dim(ba,0)}
    function unix_localtime(t)
     {var
       d=new Date(t * 1000),
       d_num=d.getTime(),
       januaryfirst=new Date(d.getFullYear(),0,1).getTime(),
       doy=Math.floor((d_num - januaryfirst) / 86400000),
       jan=new Date(d.getFullYear(),0,1),
       jul=new Date(d.getFullYear(),6,1),
       stdTimezoneOffset=
        Math.max(jan.getTimezoneOffset(),jul.getTimezoneOffset());
      return [0,
              d.getSeconds(),
              d.getMinutes(),
              d.getHours(),
              d.getDate(),
              d.getMonth(),
              d.getFullYear() - 1900,
              d.getDay(),
              doy,
              d.getTimezoneOffset() < stdTimezoneOffset | 0]}
    function caml_js_meth_call(o,f,args)
     {return o[caml_jsstring_of_string(f)].apply(o,caml_js_from_array(args))}
    function caml_weak_create(n)
     {if(n < 0)caml_invalid_argument("Weak.create");
      var x=[251,"caml_ephe_list_head"];
      x.length = caml_ephe_key_offset + n;
      return x}
    var caml_ephe_create=caml_weak_create;
    function caml_js_to_byte_string(s){return caml_string_of_jsbytes(s)}
    function unix_mktime(tm)
     {var
       d=new Date(tm[6] + 1900,tm[5],tm[4],tm[3],tm[2],tm[1]).getTime(),
       t=Math.floor(d / 1000),
       tm2=unix_localtime(t);
      return [0,t,tm2]}
    function caml_trampoline(res)
     {var c=1;
      while(res && res.joo_tramp)
       {res = res.joo_tramp.apply(null,res.joo_args);c++}
      return res}
    function caml_bytes_get64(s,i)
     {if(i >>> 0 >= s.l - 7)caml_bytes_bound_error();
      var a=new Array(8);
      for(var j=0;j < 8;j++)a[7 - j] = caml_bytes_unsafe_get(s,i + j);
      return caml_int64_of_bytes(a)}
    function caml_weak_set(x,i,v)
     {if(i < 0 || caml_ephe_key_offset + i >= x.length)
       caml_invalid_argument("Weak.set");
      x[caml_ephe_key_offset + i] = v;
      return 0}
    function caml_sys_remove(name)
     {var root=resolve_fs_device(name),ok=root.device.unlink(root.rest);
      if(ok == 0)caml_raise_no_such_file(name);
      return 0}
    function caml_string_bound_error()
     {caml_invalid_argument("index out of bounds")}
    function caml_string_get32(s,i)
     {if(i >>> 0 >= caml_ml_string_length(s) - 3)caml_string_bound_error();
      var
       b1=caml_string_unsafe_get(s,i),
       b2=caml_string_unsafe_get(s,i + 1),
       b3=caml_string_unsafe_get(s,i + 2),
       b4=caml_string_unsafe_get(s,i + 3);
      return b4 << 24 | b3 << 16 | b2 << 8 | b1}
    function caml_hypot_float(x,y)
     {var
       x=Math.abs(x),
       y=Math.abs(y),
       a=Math.max(x,y),
       b=Math.min(x,y) / (a?a:1);
      return a * Math.sqrt(1 + b * b)}
    function caml_js_call(f,o,args)
     {return f.apply(o,caml_js_from_array(args))}
    function caml_sys_const_max_wosize(){return 0x7FFFFFFF / 4 | 0}
    function caml_ephe_unset_key(x,i){return caml_weak_set(x,i,0)}
    function caml_hash_mix_bytes_arr(h,s)
     {var len=s.length,i,w;
      for(i = 0;i + 4 <= len;i += 4)
       {w = s[i] | s[i + 1] << 8 | s[i + 2] << 16 | s[i + 3] << 24;
        h = caml_hash_mix_int(h,w)}
      w = 0;
      switch(len & 3)
       {case 3:w = s[i + 2] << 16;
        case 2:w |= s[i + 1] << 8;
        case 1:w |= s[i];h = caml_hash_mix_int(h,w)
        }
      h ^= len;
      return h}
    function caml_hash_mix_jsbytes(h,s)
     {var len=s.length,i,w;
      for(i = 0;i + 4 <= len;i += 4)
       {w
        =
        s.charCodeAt(i)
        |
        s.charCodeAt(i + 1)
        <<
        8
        |
        s.charCodeAt(i + 2)
        <<
        16
        |
        s.charCodeAt(i + 3)
        <<
        24;
        h = caml_hash_mix_int(h,w)}
      w = 0;
      switch(len & 3)
       {case 3:w = s.charCodeAt(i + 2) << 16;
        case 2:w |= s.charCodeAt(i + 1) << 8;
        case 1:w |= s.charCodeAt(i);h = caml_hash_mix_int(h,w)
        }
      h ^= len;
      return h}
    function caml_hash_mix_bytes(h,v)
     {switch(v.t & 6)
       {default:caml_convert_string_to_bytes(v);case 0:
         h = caml_hash_mix_jsbytes(h,v.c);break;
        case 2:h = caml_hash_mix_bytes_arr(h,v.c)
        }
      return h}
    function caml_bytes_lessthan(s1,s2)
     {s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c < s2.c?1:0}
    function caml_gr_fill_poly(ar)
     {var s=caml_gr_state_get();
      s.context.beginPath();
      s.context.moveTo(ar[1][1],s.height - ar[1][2]);
      for(var i=2;i < ar.length;i++)
       s.context.lineTo(ar[i][1],s.height - ar[i][2]);
      s.context.lineTo(ar[1][1],s.height - ar[1][2]);
      s.context.fill();
      return 0}
    function caml_gc_quick_stat(){return [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]}
    function caml_raise_end_of_file()
     {caml_raise_constant(caml_global_data.End_of_file)}
    function caml_ml_input_int(chanid)
     {var chan=caml_ml_channels[chanid],file=chan.file;
      while(chan.offset + 3 >= file.length())
       {var l=caml_ml_refill_input(chan);if(l == 0)caml_raise_end_of_file()}
      var
       o=chan.offset,
       r=
        file.read_one(o)
        <<
        24
        |
        file.read_one(o + 1)
        <<
        16
        |
        file.read_one(o + 2)
        <<
        8
        |
        file.read_one(o + 3);
      chan.offset += 4;
      return r}
    function caml_gr_display_mode()
     {caml_failwith("caml_gr_display_mode not Implemented")}
    function nth_digit_nat(nat,ofs){return nat.data[ofs]}
    function caml_array_blit(a1,i1,a2,i2,len)
     {if(i2 <= i1)
       for(var j=1;j <= len;j++)a2[i2 + j] = a1[i1 + j];
      else
       for(var j=len;j >= 1;j--)a2[i2 + j] = a1[i1 + j];
      return 0}
    function caml_float_of_string(s)
     {var res;
      s = caml_jsbytes_of_string(s);
      res = + s;
      if(s.length > 0 && res === res)return res;
      s = s.replace(/_/g,"");
      res = + s;
      if(s.length > 0 && res === res || /^[+-]?nan$/i.test(s))return res;
      var m=/^ *([+-]?)0x([0-9a-f]+)\.?([0-9a-f]*)p([+-]?[0-9]+)/i.exec(s);
      if(m)
       {var
         m3=m[3].replace(/0+$/,""),
         mantissa=parseInt(m[1] + m[2] + m3,16),
         exponent=(m[4] | 0) - 4 * m3.length;
        res = mantissa * Math.pow(2,exponent);
        return res}
      if(/^\+?inf(inity)?$/i.test(s))return Infinity;
      if(/^-inf(inity)?$/i.test(s))return - Infinity;
      caml_failwith("float_of_string")}
    function caml_sys_getcwd()
     {return caml_string_of_jsbytes(caml_current_dir)}
    function caml_sys_const_big_endian(){return 0}
    function caml_list_to_js_array(l)
     {var a=[];for(;l !== 0;l = l[2])a.push(l[1]);return a}
    var
     caml_legacy_custom_code=false,
     caml_output_val=
      function()
        {function Writer(){this.chunk = []}
         Writer.prototype
         =
         {chunk_idx:20,
          block_len:0,
          obj_counter:0,
          size_32:0,
          size_64:0,
          write:
          function(size,value)
           {for(var i=size - 8;i >= 0;i -= 8)
             this.chunk[this.chunk_idx++] = value >> i & 0xFF},
          write_at:
          function(pos,size,value)
           {var pos=pos;
            for(var i=size - 8;i >= 0;i -= 8)
             this.chunk[pos++] = value >> i & 0xFF},
          write_code:
          function(size,code,value)
           {this.chunk[this.chunk_idx++] = code;
            for(var i=size - 8;i >= 0;i -= 8)
             this.chunk[this.chunk_idx++] = value >> i & 0xFF},
          write_shared:
          function(offset)
           {if(offset < 1 << 8)
             this.write_code(8,0x04,offset);
            else
             if(offset < 1 << 16)
              this.write_code(16,0x05,offset);
             else
              this.write_code(32,0x06,offset)},
          pos:function(){return this.chunk_idx},
          finalize:
          function()
           {this.block_len = this.chunk_idx - 20;
            this.chunk_idx = 0;
            this.write(32,0x8495A6BE);
            this.write(32,this.block_len);
            this.write(32,this.obj_counter);
            this.write(32,this.size_32);
            this.write(32,this.size_64);
            return this.chunk}};
         return function(v,flags)
          {flags = caml_list_to_js_array(flags);
           var
            no_sharing=flags.indexOf(0) !== - 1,
            closures=flags.indexOf(1) !== - 1;
           if(closures)
            joo_global_object.console.warn
             ("in caml_output_val: flag Marshal.Closures is not supported.");
           var
            writer=new Writer(),
            stack=[],
            intern_obj_table=no_sharing?null:new MlObjectTable();
           function memo(v)
            {if(no_sharing)return false;
             var existing_offset=intern_obj_table.recall(v);
             if(existing_offset)
              {writer.write_shared(existing_offset);return true}
             else
              {intern_obj_table.store(v);return false}}
           function extern_rec(v)
            {if(v.caml_custom)
              {if(memo(v))return;
               var
                name=v.caml_custom,
                ops=caml_custom_ops[name],
                sz_32_64=[0,0];
               if(! ops.serialize)
                caml_invalid_argument("output_value: abstract value (Custom)");
               if(caml_legacy_custom_code)
                {writer.write(8,0x12);
                 for(var i=0;i < name.length;i++)
                  writer.write(8,name.charCodeAt(i));
                 writer.write(8,0);
                 ops.serialize(writer,v,sz_32_64)}
               else
                if(ops.fixed_length == undefined)
                 {writer.write(8,0x18);
                  for(var i=0;i < name.length;i++)
                   writer.write(8,name.charCodeAt(i));
                  writer.write(8,0);
                  var header_pos=writer.pos();
                  for(var i=0;i < 12;i++)writer.write(8,0);
                  ops.serialize(writer,v,sz_32_64);
                  writer.write_at(header_pos,32,sz_32_64[0]);
                  writer.write_at(header_pos + 4,32,0);
                  writer.write_at(header_pos + 8,32,sz_32_64[1])}
                else
                 {writer.write(8,0x19);
                  for(var i=0;i < name.length;i++)
                   writer.write(8,name.charCodeAt(i));
                  writer.write(8,0);
                  var old_pos=writer.pos();
                  ops.serialize(writer,v,sz_32_64);
                  if(ops.fixed_length != writer.pos() - old_pos)
                   caml_failwith
                    ("output_value: incorrect fixed sizes specified by " + name)}
               writer.size_32 += 2 + (sz_32_64[0] + 3 >> 2);
               writer.size_64 += 2 + (sz_32_64[1] + 7 >> 3)}
             else
              if(v instanceof Array && v[0] === (v[0] | 0))
               {if(v[0] == 251)
                 caml_failwith("output_value: abstract value (Abstract)");
                if(v.length > 1 && memo(v))return;
                if(v[0] < 16 && v.length - 1 < 8)
                 writer.write(8,0x80 + v[0] + (v.length - 1 << 4));
                else
                 writer.write_code(32,0x08,v.length - 1 << 10 | v[0]);
                writer.size_32 += v.length;
                writer.size_64 += v.length;
                if(v.length > 1)stack.push(v,1)}
              else
               if(caml_is_ml_bytes(v))
                {if(! caml_is_ml_bytes(caml_string_of_jsbytes("")))
                  caml_failwith
                   ("output_value: [Bytes.t] cannot safely be marshaled with [--enable use-js-string]");
                 if(memo(v))return;
                 var len=caml_ml_bytes_length(v);
                 if(len < 0x20)
                  writer.write(8,0x20 + len);
                 else
                  if(len < 0x100)
                   writer.write_code(8,0x09,len);
                  else
                   writer.write_code(32,0x0A,len);
                 for(var i=0;i < len;i++)
                  writer.write(8,caml_bytes_unsafe_get(v,i));
                 writer.size_32 += 1 + ((len + 4) / 4 | 0);
                 writer.size_64 += 1 + ((len + 8) / 8 | 0)}
               else
                if(caml_is_ml_string(v))
                 {var len=caml_ml_string_length(v);
                  if(len < 0x20)
                   writer.write(8,0x20 + len);
                  else
                   if(len < 0x100)
                    writer.write_code(8,0x09,len);
                   else
                    writer.write_code(32,0x0A,len);
                  for(var i=0;i < len;i++)
                   writer.write(8,caml_string_unsafe_get(v,i));
                  writer.size_32 += 1 + ((len + 4) / 4 | 0);
                  writer.size_64 += 1 + ((len + 8) / 8 | 0)}
                else
                 if(v != (v | 0))
                  {var type_of_v=typeof v;
                   caml_failwith
                    ("output_value: abstract value (" + type_of_v + ")")}
                 else
                  if(v >= 0 && v < 0x40)
                   writer.write(8,0X40 + v);
                  else
                   if(v >= - (1 << 7) && v < 1 << 7)
                    writer.write_code(8,0x00,v);
                   else
                    if(v >= - (1 << 15) && v < 1 << 15)
                     writer.write_code(16,0x01,v);
                    else
                     writer.write_code(32,0x02,v)}
           extern_rec(v);
           while(stack.length > 0)
            {var i=stack.pop(),v=stack.pop();
             if(i + 1 < v.length)stack.push(v,i + 1);
             extern_rec(v[i])}
           if(intern_obj_table)
            writer.obj_counter = intern_obj_table.objs.length;
           writer.finalize();
           return writer.chunk}}
       ();
    function caml_string_of_array(a)
     {return caml_string_of_jsbytes(caml_subarray_to_jsbytes(a,0,a.length))}
    function caml_output_value_to_string(v,flags)
     {return caml_string_of_array(caml_output_val(v,flags))}
    function caml_raise_not_a_dir(name)
     {name = caml_jsbytes_of_string(name);
      caml_raise_sys_error(name + ": Not a directory")}
    function caml_sys_system_command(cmd)
     {var cmd=caml_jsstring_of_string(cmd);
      if
       (typeof require
        !=
        "undefined"
        &&
        require("child_process")
        &&
        require("child_process").execSync)
       try
        {require("child_process").execSync(cmd,{stdio:"inherit"});return 0}
       catch(e){return 1}
      else
       return 127}
    function unix_isatty(fileDescriptor)
     {if(fs_node_supported())
       {var tty=require("tty");return tty.isatty(fileDescriptor)}
      else
       return false}
    function caml_js_error_of_exception(exn)
     {if(exn.js_error)return exn.js_error;return null}
    function deserialize_nat(reader,sz)
     {var len=reader.read32s(),nat=new MlNat(len);
      for(var i=0;i < len;i++)nat.data[i] = reader.read32s();
      sz[0] = len * 4;
      return nat}
    function initialize_nat()
     {caml_custom_ops["_nat"]
      =
      {deserialize:deserialize_nat,serialize:serialize_nat,hash:caml_hash_nat}}
    function caml_gr_open_subwindow(a,b,c,d)
     {caml_failwith("caml_gr_open_subwindow not Implemented")}
    function js_print_stdout(s)
     {var s=caml_utf16_of_utf8(s),g=joo_global_object;
      if(g.process && g.process.stdout && g.process.stdout.write)
       g.process.stdout.write(s);
      else
       {if(s.charCodeAt(s.length - 1) == 10)s = s.substr(0,s.length - 1);
        var v=g.console;
        v && v.log && v.log(s)}}
    function caml_copysign_float(x,y)
     {if(y == 0)y = 1 / y;x = Math.abs(x);return y < 0?- x:x}
    function caml_gr_set_text_size(size)
     {var s=caml_gr_state_get();
      s.text_size = size;
      s.context.font = s.text_size + "px " + caml_jsstring_of_string(s.font);
      return 0}
    var
     caml_md5_bytes=
      function()
        {function add(x,y){return x + y | 0}
         function xx(q,a,b,x,s,t)
          {a = add(add(a,q),add(x,t));return add(a << s | a >>> 32 - s,b)}
         function ff(a,b,c,d,x,s,t){return xx(b & c | ~ b & d,a,b,x,s,t)}
         function gg(a,b,c,d,x,s,t){return xx(b & d | c & ~ d,a,b,x,s,t)}
         function hh(a,b,c,d,x,s,t){return xx(b ^ c ^ d,a,b,x,s,t)}
         function ii(a,b,c,d,x,s,t){return xx(c ^ (b | ~ d),a,b,x,s,t)}
         function md5(buffer,length)
          {var i=length;
           buffer[i >> 2] |= 0x80 << 8 * (i & 3);
           for(i = (i & ~ 0x3) + 8;(i & 0x3F) < 60;i += 4)
            buffer[(i >> 2) - 1] = 0;
           buffer[(i >> 2) - 1] = length << 3;
           buffer[i >> 2] = length >> 29 & 0x1FFFFFFF;
           var w=[0x67452301,0xEFCDAB89,0x98BADCFE,0x10325476];
           for(i = 0;i < buffer.length;i += 16)
            {var a=w[0],b=w[1],c=w[2],d=w[3];
             a = ff(a,b,c,d,buffer[i + 0],7,0xD76AA478);
             d = ff(d,a,b,c,buffer[i + 1],12,0xE8C7B756);
             c = ff(c,d,a,b,buffer[i + 2],17,0x242070DB);
             b = ff(b,c,d,a,buffer[i + 3],22,0xC1BDCEEE);
             a = ff(a,b,c,d,buffer[i + 4],7,0xF57C0FAF);
             d = ff(d,a,b,c,buffer[i + 5],12,0x4787C62A);
             c = ff(c,d,a,b,buffer[i + 6],17,0xA8304613);
             b = ff(b,c,d,a,buffer[i + 7],22,0xFD469501);
             a = ff(a,b,c,d,buffer[i + 8],7,0x698098D8);
             d = ff(d,a,b,c,buffer[i + 9],12,0x8B44F7AF);
             c = ff(c,d,a,b,buffer[i + 10],17,0xFFFF5BB1);
             b = ff(b,c,d,a,buffer[i + 11],22,0x895CD7BE);
             a = ff(a,b,c,d,buffer[i + 12],7,0x6B901122);
             d = ff(d,a,b,c,buffer[i + 13],12,0xFD987193);
             c = ff(c,d,a,b,buffer[i + 14],17,0xA679438E);
             b = ff(b,c,d,a,buffer[i + 15],22,0x49B40821);
             a = gg(a,b,c,d,buffer[i + 1],5,0xF61E2562);
             d = gg(d,a,b,c,buffer[i + 6],9,0xC040B340);
             c = gg(c,d,a,b,buffer[i + 11],14,0x265E5A51);
             b = gg(b,c,d,a,buffer[i + 0],20,0xE9B6C7AA);
             a = gg(a,b,c,d,buffer[i + 5],5,0xD62F105D);
             d = gg(d,a,b,c,buffer[i + 10],9,0x02441453);
             c = gg(c,d,a,b,buffer[i + 15],14,0xD8A1E681);
             b = gg(b,c,d,a,buffer[i + 4],20,0xE7D3FBC8);
             a = gg(a,b,c,d,buffer[i + 9],5,0x21E1CDE6);
             d = gg(d,a,b,c,buffer[i + 14],9,0xC33707D6);
             c = gg(c,d,a,b,buffer[i + 3],14,0xF4D50D87);
             b = gg(b,c,d,a,buffer[i + 8],20,0x455A14ED);
             a = gg(a,b,c,d,buffer[i + 13],5,0xA9E3E905);
             d = gg(d,a,b,c,buffer[i + 2],9,0xFCEFA3F8);
             c = gg(c,d,a,b,buffer[i + 7],14,0x676F02D9);
             b = gg(b,c,d,a,buffer[i + 12],20,0x8D2A4C8A);
             a = hh(a,b,c,d,buffer[i + 5],4,0xFFFA3942);
             d = hh(d,a,b,c,buffer[i + 8],11,0x8771F681);
             c = hh(c,d,a,b,buffer[i + 11],16,0x6D9D6122);
             b = hh(b,c,d,a,buffer[i + 14],23,0xFDE5380C);
             a = hh(a,b,c,d,buffer[i + 1],4,0xA4BEEA44);
             d = hh(d,a,b,c,buffer[i + 4],11,0x4BDECFA9);
             c = hh(c,d,a,b,buffer[i + 7],16,0xF6BB4B60);
             b = hh(b,c,d,a,buffer[i + 10],23,0xBEBFBC70);
             a = hh(a,b,c,d,buffer[i + 13],4,0x289B7EC6);
             d = hh(d,a,b,c,buffer[i + 0],11,0xEAA127FA);
             c = hh(c,d,a,b,buffer[i + 3],16,0xD4EF3085);
             b = hh(b,c,d,a,buffer[i + 6],23,0x04881D05);
             a = hh(a,b,c,d,buffer[i + 9],4,0xD9D4D039);
             d = hh(d,a,b,c,buffer[i + 12],11,0xE6DB99E5);
             c = hh(c,d,a,b,buffer[i + 15],16,0x1FA27CF8);
             b = hh(b,c,d,a,buffer[i + 2],23,0xC4AC5665);
             a = ii(a,b,c,d,buffer[i + 0],6,0xF4292244);
             d = ii(d,a,b,c,buffer[i + 7],10,0x432AFF97);
             c = ii(c,d,a,b,buffer[i + 14],15,0xAB9423A7);
             b = ii(b,c,d,a,buffer[i + 5],21,0xFC93A039);
             a = ii(a,b,c,d,buffer[i + 12],6,0x655B59C3);
             d = ii(d,a,b,c,buffer[i + 3],10,0x8F0CCC92);
             c = ii(c,d,a,b,buffer[i + 10],15,0xFFEFF47D);
             b = ii(b,c,d,a,buffer[i + 1],21,0x85845DD1);
             a = ii(a,b,c,d,buffer[i + 8],6,0x6FA87E4F);
             d = ii(d,a,b,c,buffer[i + 15],10,0xFE2CE6E0);
             c = ii(c,d,a,b,buffer[i + 6],15,0xA3014314);
             b = ii(b,c,d,a,buffer[i + 13],21,0x4E0811A1);
             a = ii(a,b,c,d,buffer[i + 4],6,0xF7537E82);
             d = ii(d,a,b,c,buffer[i + 11],10,0xBD3AF235);
             c = ii(c,d,a,b,buffer[i + 2],15,0x2AD7D2BB);
             b = ii(b,c,d,a,buffer[i + 9],21,0xEB86D391);
             w[0] = add(a,w[0]);
             w[1] = add(b,w[1]);
             w[2] = add(c,w[2]);
             w[3] = add(d,w[3])}
           var t=new Array(16);
           for(var i=0;i < 4;i++)
            for(var j=0;j < 4;j++)t[i * 4 + j] = w[i] >> 8 * j & 0xFF;
           return t}
         return function(s,ofs,len)
          {var buf=[];
           switch(s.t & 6)
            {default:caml_convert_string_to_bytes(s);case 0:
              var b=s.c;
              for(var i=0;i < len;i += 4)
               {var j=i + ofs;
                buf[i >> 2]
                =
                b.charCodeAt(j)
                |
                b.charCodeAt(j + 1)
                <<
                8
                |
                b.charCodeAt(j + 2)
                <<
                16
                |
                b.charCodeAt(j + 3)
                <<
                24}
              for(;i < len;i++)
               buf[i >> 2] |= b.charCodeAt(i + ofs) << 8 * (i & 3);
              break;
             case 4:
              var a=s.c;
              for(var i=0;i < len;i += 4)
               {var j=i + ofs;
                buf[i >> 2]
                =
                a[j]
                |
                a[j + 1]
                <<
                8
                |
                a[j + 2]
                <<
                16
                |
                a[j + 3]
                <<
                24}
              for(;i < len;i++)buf[i >> 2] |= a[i + ofs] << 8 * (i & 3)
             }
           return caml_string_of_array(md5(buf,len))}}
       ();
    function caml_ba_set_generic(ba,i,v)
     {ba.set(ba.offset(caml_js_from_array(i)),v);return 0}
    function caml_ephe_set_key(x,i,v){return caml_weak_set(x,i,[0,v])}
    function caml_bytes_lessequal(s1,s2)
     {s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c <= s2.c?1:0}
    function caml_string_lessequal(s1,s2){return caml_bytes_lessequal(s1,s2)}
    function caml_string_greaterequal(s1,s2)
     {return caml_string_lessequal(s2,s1)}
    function caml_int64_add(x,y){return x.add(y)}
    function caml_nextafter_float(x,y)
     {if(isNaN(x) || isNaN(y))return NaN;
      if(x == y)return y;
      if(x == 0)return y < 0?- Math.pow(2,- 1074):Math.pow(2,- 1074);
      var bits=caml_int64_bits_of_float(x),one=caml_int64_of_int32(1);
      if(x < y == x > 0)
       bits = caml_int64_add(bits,one);
      else
       bits = caml_int64_sub(bits,one);
      return caml_int64_float_of_bits(bits)}
    function caml_gr_size_y(){var s=caml_gr_state_get();return s.height}
    function caml_ml_pos_in(chanid){return caml_ml_channels[chanid].offset}
    function caml_int64_and(x,y){return x.and(y)}
    function caml_sys_const_word_size(){return 32}
    function caml_std_output(chanid,s)
     {var
       chan=caml_ml_channels[chanid],
       str=caml_string_of_jsbytes(s),
       slen=caml_ml_string_length(str);
      chan.file.write(chan.offset,str,0,slen);
      chan.offset += slen;
      return 0}
    function js_print_stderr(s)
     {var s=caml_utf16_of_utf8(s),g=joo_global_object;
      if(g.process && g.process.stdout && g.process.stdout.write)
       g.process.stderr.write(s);
      else
       {if(s.charCodeAt(s.length - 1) == 10)s = s.substr(0,s.length - 1);
        var v=g.console;
        v && v.error && v.error(s)}}
    function caml_sys_open_internal(idx,output,file,flags)
     {if(caml_global_data.fds === undefined)
       caml_global_data.fds = new Array();
      flags = flags?flags:{};
      var info={};
      info.file = file;
      info.offset = flags.append?file.length():0;
      info.flags = flags;
      info.output = output;
      caml_global_data.fds[idx] = info;
      if(! caml_global_data.fd_last_idx || idx > caml_global_data.fd_last_idx)
       caml_global_data.fd_last_idx = idx;
      return idx}
    function caml_sys_open(name,flags,_perms)
     {var f={};
      while(flags)
       {switch(flags[1])
         {case 0:f.rdonly = 1;break;
          case 1:f.wronly = 1;break;
          case 2:f.append = 1;break;
          case 3:f.create = 1;break;
          case 4:f.truncate = 1;break;
          case 5:f.excl = 1;break;
          case 6:f.binary = 1;break;
          case 7:f.text = 1;break;
          case 8:f.nonblock = 1;break
          }
        flags = flags[2]}
      if(f.rdonly && f.wronly)
       caml_raise_sys_error
        (caml_jsbytes_of_string(name)
         +
         " : flags Open_rdonly and Open_wronly are not compatible");
      if(f.text && f.binary)
       caml_raise_sys_error
        (caml_jsbytes_of_string(name)
         +
         " : flags Open_text and Open_binary are not compatible");
      var
       root=resolve_fs_device(name),
       file=root.device.open(root.rest,f),
       idx=caml_global_data.fd_last_idx?caml_global_data.fd_last_idx:0;
      return caml_sys_open_internal(idx + 1,caml_std_output,file,f)}
    caml_sys_open_internal
     (0,caml_std_output,new MlFakeFile(caml_create_bytes(0)));
    caml_sys_open_internal
     (1,js_print_stdout,new MlFakeFile(caml_create_bytes(0)));
    caml_sys_open_internal
     (2,js_print_stderr,new MlFakeFile(caml_create_bytes(0)));
    function MlStringReader(s,i)
     {this.s = caml_jsbytes_of_string(s);this.i = i}
    MlStringReader.prototype
    =
    {read8u:function(){return this.s.charCodeAt(this.i++)},
     read8s:function(){return this.s.charCodeAt(this.i++) << 24 >> 24},
     read16u:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 2;
       return s.charCodeAt(i) << 8 | s.charCodeAt(i + 1)},
     read16s:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 2;
       return s.charCodeAt(i) << 24 >> 16 | s.charCodeAt(i + 1)},
     read32u:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 4;
       return (s.charCodeAt(i)
               <<
               24
               |
               s.charCodeAt(i + 1)
               <<
               16
               |
               s.charCodeAt(i + 2)
               <<
               8
               |
               s.charCodeAt(i + 3))
              >>>
              0},
     read32s:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 4;
       return s.charCodeAt(i)
              <<
              24
              |
              s.charCodeAt(i + 1)
              <<
              16
              |
              s.charCodeAt(i + 2)
              <<
              8
              |
              s.charCodeAt(i + 3)},
     readstr:
     function(len)
      {var i=this.i;
       this.i = i + len;
       return caml_string_of_jsbytes(this.s.substring(i,i + len))}};
    function caml_float_of_bytes(a)
     {return caml_int64_float_of_bits(caml_int64_of_bytes(a))}
    function caml_input_value_from_reader(reader,ofs)
     {var
       _magic=reader.read32u(),
       _block_len=reader.read32u(),
       num_objects=reader.read32u(),
       _size_32=reader.read32u(),
       _size_64=reader.read32u(),
       stack=[],
       intern_obj_table=num_objects > 0?[]:null,
       obj_counter=0;
      function intern_rec()
       {var code=reader.read8u();
        if(code >= 0x40)
         if(code >= 0x80)
          {var tag=code & 0xF,size=code >> 4 & 0x7,v=[tag];
           if(size == 0)return v;
           if(intern_obj_table)intern_obj_table[obj_counter++] = v;
           stack.push(v,size);
           return v}
         else
          return code & 0x3F;
        else
         if(code >= 0x20)
          {var len=code & 0x1F,v=reader.readstr(len);
           if(intern_obj_table)intern_obj_table[obj_counter++] = v;
           return v}
         else
          switch(code)
           {case 0x00:return reader.read8s();
            case 0x01:return reader.read16s();
            case 0x02:return reader.read32s();
            case 0x03:caml_failwith("input_value: integer too large");break;
            case 0x04:
             var offset=reader.read8u();
             return intern_obj_table[obj_counter - offset];
            case 0x05:
             var offset=reader.read16u();
             return intern_obj_table[obj_counter - offset];
            case 0x06:
             var offset=reader.read32u();
             return intern_obj_table[obj_counter - offset];
            case 0x08:
             var
              header=reader.read32u(),
              tag=header & 0xFF,
              size=header >> 10,
              v=[tag];
             if(size == 0)return v;
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             stack.push(v,size);
             return v;
            case 0x13:
             caml_failwith("input_value: data block too large");break;
            case 0x09:
             var len=reader.read8u(),v=reader.readstr(len);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            case 0x0A:
             var len=reader.read32u(),v=reader.readstr(len);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            case 0x0C:
             var t=new Array(8);
             for(var i=0;i < 8;i++)t[7 - i] = reader.read8u();
             var v=caml_float_of_bytes(t);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            case 0x0B:
             var t=new Array(8);
             for(var i=0;i < 8;i++)t[i] = reader.read8u();
             var v=caml_float_of_bytes(t);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            case 0x0E:
             var len=reader.read8u(),v=new Array(len + 1);
             v[0] = 254;
             var t=new Array(8);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             for(var i=1;i <= len;i++)
              {for(var j=0;j < 8;j++)t[7 - j] = reader.read8u();
               v[i] = caml_float_of_bytes(t)}
             return v;
            case 0x0D:
             var len=reader.read8u(),v=new Array(len + 1);
             v[0] = 254;
             var t=new Array(8);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             for(var i=1;i <= len;i++)
              {for(var j=0;j < 8;j++)t[j] = reader.read8u();
               v[i] = caml_float_of_bytes(t)}
             return v;
            case 0x07:
             var len=reader.read32u(),v=new Array(len + 1);
             v[0] = 254;
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             var t=new Array(8);
             for(var i=1;i <= len;i++)
              {for(var j=0;j < 8;j++)t[7 - j] = reader.read8u();
               v[i] = caml_float_of_bytes(t)}
             return v;
            case 0x0F:
             var len=reader.read32u(),v=new Array(len + 1);
             v[0] = 254;
             var t=new Array(8);
             for(var i=1;i <= len;i++)
              {for(var j=0;j < 8;j++)t[j] = reader.read8u();
               v[i] = caml_float_of_bytes(t)}
             return v;
            case 0x10:
            case 0x11:caml_failwith("input_value: code pointer");break;
            case 0x12:
            case 0x18:
            case 0x19:
             var c,s="";
             while((c = reader.read8u()) != 0)s += String.fromCharCode(c);
             var ops=caml_custom_ops[s],expected_size;
             if(! ops)
              caml_failwith("input_value: unknown custom block identifier");
             switch(code)
              {case 0x12:break;
               case 0x19:
                if(! ops.fixed_length)
                 caml_failwith
                  ("input_value: expected a fixed-size custom block");
                expected_size = ops.fixed_length;
                break;
               case 0x18:
                expected_size = reader.read32u();
                reader.read32s();
                reader.read32s();
                break
               }
             var old_pos=reader.i,size=[0],v=ops.deserialize(reader,size);
             if(expected_size != undefined)
              if(expected_size != size[0])
               caml_failwith
                ("input_value: incorrect length of serialized custom block");
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            default:caml_failwith("input_value: ill-formed message")}}
      var res=intern_rec();
      while(stack.length > 0)
       {var size=stack.pop(),v=stack.pop(),d=v.length;
        if(d < size)stack.push(v,size);
        v[d] = intern_rec()}
      if(typeof ofs != "number")ofs[0] = reader.i;
      return res}
    function caml_string_of_bytes(s){return s}
    function caml_input_value_from_bytes(s,ofs)
     {var
       reader=
        new
         MlStringReader
         (caml_string_of_bytes(s),typeof ofs == "number"?ofs:ofs[0]);
      return caml_input_value_from_reader(reader,ofs)}
    function caml_string_get(s,i)
     {if(i >>> 0 >= caml_ml_string_length(s))caml_string_bound_error();
      return caml_string_unsafe_get(s,i)}
    var
     re_match=
      function()
        {var
          re_word_letters=
           [0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0xFF,
            0x03,
            0xFE,
            0xFF,
            0xFF,
            0x87,
            0xFE,
            0xFF,
            0xFF,
            0x07,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0xFF,
            0xFF,
            0x7F,
            0xFF,
            0xFF,
            0xFF,
            0x7F,
            0xFF],
          opcodes=
           {CHAR:0,
            CHARNORM:1,
            STRING:2,
            STRINGNORM:3,
            CHARCLASS:4,
            BOL:5,
            EOL:6,
            WORDBOUNDARY:7,
            BEGGROUP:8,
            ENDGROUP:9,
            REFGROUP:10,
            ACCEPT:11,
            SIMPLEOPT:12,
            SIMPLESTAR:13,
            SIMPLEPLUS:14,
            GOTO:15,
            PUSHBACK:16,
            SETMARK:17,
            CHECKPROGRESS:18};
         function is_word_letter(c)
          {return re_word_letters[c >> 3] >> (c & 7) & 1}
         function in_bitset(s,i)
          {return caml_string_get(s,i >> 3) >> (i & 7) & 1}
         function re_match_impl(re,s,pos,partial)
          {var
            prog=caml_js_from_array(re[1]),
            cpool=caml_js_from_array(re[2]),
            normtable=caml_jsbytes_of_string(re[3]),
            numgroups=re[4] | 0,
            numregisters=re[5] | 0,
            startchars=re[6] | 0,
            s=caml_array_of_string(s),
            pc=0,
            quit=false,
            stack=[],
            groups=new Array(numgroups),
            re_register=new Array(numregisters);
           for(var i=0;i < groups.length;i++)groups[i] = {start:- 1,end:- 1};
           groups[0].start = pos;
           function backtrack()
            {while(stack.length)
              {var item=stack.pop();
               if(item.undo)
                item.undo.obj[item.undo.prop] = item.undo.value;
               else
                if(item.pos){pc = item.pos.pc;pos = item.pos.txt;return}}
             quit = true}
           function push(item){stack.push(item)}
           function accept()
            {groups[0].end = pos;
             var result=new Array(1 + groups.length * 2);
             result[0] = 0;
             for(var i=0;i < groups.length;i++)
              {var g=groups[i];
               if(g.start < 0 || g.end < 0)g.start = g.end = - 1;
               result[2 * i + 1] = g.start;
               result[2 * i + 1 + 1] = g.end}
             return result}
           function prefix_match()
            {if(partial)return accept();else backtrack()}
           while(! quit)
            {var
              op=prog[pc] & 0xff,
              sarg=prog[pc] >> 8,
              uarg=sarg & 0xff,
              c=s[pos],
              group;
             pc++;
             switch(op)
              {case opcodes.CHAR:
                if(pos === s.length){prefix_match();break}
                if(c === uarg)pos++;else backtrack();
                break;
               case opcodes.CHARNORM:
                if(pos === s.length){prefix_match();break}
                if(normtable.charCodeAt(c) === uarg)pos++;else backtrack();
                break;
               case opcodes.STRING:
                for
                 (var arg=caml_jsbytes_of_string(cpool[uarg]),i=0;
                  i
                  <
                  arg.length;
                  i++)
                 {if(pos === s.length){prefix_match();break}
                  if(c === arg.charCodeAt(i))
                   c = s[++pos];
                  else
                   {backtrack();break}}
                break;
               case opcodes.STRINGNORM:
                for
                 (var arg=caml_jsbytes_of_string(cpool[uarg]),i=0;
                  i
                  <
                  arg.length;
                  i++)
                 {if(pos === s.length){prefix_match();break}
                  if(normtable.charCodeAt(c) === arg.charCodeAt(i))
                   c = s[++pos];
                  else
                   {backtrack();break}}
                break;
               case opcodes.CHARCLASS:
                if(pos === s.length){prefix_match();break}
                if(in_bitset(cpool[uarg],c))pos++;else backtrack();
                break;
               case opcodes.BOL:
                if(pos > 0 && s[pos - 1] != 10)backtrack();break;
               case opcodes.EOL:
                if(pos < s.length && s[pos] != 10)backtrack();break;
               case opcodes.WORDBOUNDARY:
                if(pos == 0)
                 {if(pos === s.length){prefix_match();break}
                  if(is_word_letter(s[0]))break;
                  backtrack()}
                else
                 if(pos === s.length)
                  {if(is_word_letter(s[pos - 1]))break;backtrack()}
                 else
                  {if(is_word_letter(s[pos - 1]) != is_word_letter(s[pos]))
                    break;
                   backtrack()}
                break;
               case opcodes.BEGGROUP:
                group = groups[uarg];
                push({undo:{obj:group,prop:"start",value:group.start}});
                group.start = pos;
                break;
               case opcodes.ENDGROUP:
                group = groups[uarg];
                push({undo:{obj:group,prop:"end",value:group.end}});
                group.end = pos;
                break;
               case opcodes.REFGROUP:
                group = groups[uarg];
                if(group.start < 0 || group.end < 0){backtrack();break}
                for(var i=group.start;i < group.end;i++)
                 {if(pos === s.length){prefix_match();break}
                  if(s[i] != s[pos]){backtrack();break}
                  pos++}
                break;
               case opcodes.SIMPLEOPT:if(in_bitset(cpool[uarg],c))pos++;break;
               case opcodes.SIMPLESTAR:
                while(in_bitset(cpool[uarg],c))c = s[++pos];break;
               case opcodes.SIMPLEPLUS:
                if(pos === s.length){prefix_match();break}
                if(in_bitset(cpool[uarg],c))
                 do c = s[++pos];while(in_bitset(cpool[uarg],c));
                else
                 backtrack();
                break;
               case opcodes.ACCEPT:return accept();
               case opcodes.GOTO:pc = pc + sarg;break;
               case opcodes.PUSHBACK:push({pos:{pc:pc + sarg,txt:pos}});break;
               case opcodes.SETMARK:
                push
                 ({undo:{obj:re_register,prop:uarg,value:re_register[uarg]}});
                re_register[uarg] = pos;
                break;
               case opcodes.CHECKPROGRESS:
                if(re_register[uarg] === pos)backtrack();break;
               default:throw new Error("Invalid bytecode")}}
           return 0}
         return re_match_impl}
       ();
    function re_search_backward(re,s,pos)
     {if(pos < 0 || pos > caml_ml_string_length(s))
       caml_invalid_argument("Str.search_backward");
      while(pos >= 0){var res=re_match(re,s,pos,0);if(res)return res;pos--}
      return [0]}
    function caml_js_from_string(s){return caml_jsstring_of_string(s)}
    function caml_ba_sub(ba,ofs,len)
     {var changed_dim,mul=1;
      if(ba.layout == 0)
       {for(var i=1;i < ba.dims.length;i++)mul = mul * ba.dims[i];
        changed_dim = 0}
      else
       {for(var i=0;i < ba.dims.length - 1;i++)mul = mul * ba.dims[i];
        changed_dim = ba.dims.length - 1;
        ofs = ofs - 1}
      if(ofs < 0 || len < 0 || ofs + len > ba.dims[changed_dim])
       caml_invalid_argument("Bigarray.sub: bad sub-array");
      var new_dims=[];
      for(var i=0;i < ba.dims.length;i++)new_dims[i] = ba.dims[i];
      new_dims[changed_dim] = len;
      mul *= caml_ba_get_size_per_element(ba.kind);
      var new_data=ba.data.subarray(ofs * mul,(ofs + len) * mul);
      return caml_ba_create_unsafe(ba.kind,ba.layout,new_dims,new_data)}
    function caml_gc_full_major(){return 0}
    function caml_bytes_set32(s,i,i32)
     {if(i >>> 0 >= s.l - 3)caml_bytes_bound_error();
      var
       b4=0xFF & i32 >> 24,
       b3=0xFF & i32 >> 16,
       b2=0xFF & i32 >> 8,
       b1=0xFF & i32;
      caml_bytes_unsafe_set(s,i + 0,b1);
      caml_bytes_unsafe_set(s,i + 1,b2);
      caml_bytes_unsafe_set(s,i + 2,b3);
      caml_bytes_unsafe_set(s,i + 3,b4);
      return 0}
    function caml_gr_sigio_signal(){return 0}
    function caml_ba_uint8_set32(ba,i0,v)
     {var ofs=ba.offset(i0);
      if(ofs + 3 >= ba.data.length)caml_array_bound_error();
      ba.set(ofs + 0,v & 0xff);
      ba.set(ofs + 1,v >>> 8 & 0xff);
      ba.set(ofs + 2,v >>> 16 & 0xff);
      ba.set(ofs + 3,v >>> 24 & 0xff);
      return 0}
    function caml_sys_const_ostype_unix(){return 1}
    function caml_signbit_float(x){if(x == 0)x = 1 / x;return x < 0?1:0}
    function caml_gr_current_x(){var s=caml_gr_state_get();return s.x}
    function caml_gr_set_line_width(w)
     {var s=caml_gr_state_get();
      s.line_width = w;
      s.context.lineWidth = w;
      return 0}
    function caml_gr_set_font(f)
     {var s=caml_gr_state_get();
      s.font = f;
      s.context.font = s.text_size + "px " + caml_jsstring_of_string(s.font);
      return 0}
    function caml_gr_set_color(color)
     {var s=caml_gr_state_get();
      function convert(number)
       {var str="" + number.toString(16);
        while(str.length < 2)str = "0" + str;
        return str}
      var r=color >> 16 & 0xff,g=color >> 8 & 0xff,b=color >> 0 & 0xff;
      s.color = color;
      var c_str="#" + convert(r) + convert(g) + convert(b);
      s.context.fillStyle = c_str;
      s.context.strokeStyle = c_str;
      return 0}
    function caml_gr_moveto(x,y)
     {var s=caml_gr_state_get();s.x = x;s.y = y;return 0}
    function caml_gr_resize_window(w,h)
     {var s=caml_gr_state_get();
      s.width = w;
      s.height = h;
      s.canvas.width = w;
      s.canvas.height = h;
      return 0}
    function caml_gr_state_init()
     {caml_gr_moveto(caml_gr_state.x,caml_gr_state.y);
      caml_gr_resize_window(caml_gr_state.width,caml_gr_state.height);
      caml_gr_set_line_width(caml_gr_state.line_width);
      caml_gr_set_text_size(caml_gr_state.text_size);
      caml_gr_set_font(caml_gr_state.font);
      caml_gr_set_color(caml_gr_state.color);
      caml_gr_set_window_title(caml_gr_state.title);
      caml_gr_state.context.textBaseline = "bottom"}
    function caml_ba_kind_of_typed_array(ta)
     {var g=joo_global_object,kind;
      if(ta instanceof g.Float32Array)
       kind = 0;
      else
       if(ta instanceof g.Float64Array)
        kind = 1;
       else
        if(ta instanceof g.Int8Array)
         kind = 2;
        else
         if(ta instanceof g.Uint8Array)
          kind = 3;
         else
          if(ta instanceof g.Int16Array)
           kind = 4;
          else
           if(ta instanceof g.Uint16Array)
            kind = 5;
           else
            if(ta instanceof g.Int32Array)
             kind = 6;
            else
             if(ta instanceof g.Uint32Array)
              kind = 6;
             else
              caml_invalid_argument
               ("caml_ba_kind_of_typed_array: unsupported kind");
      return kind}
    function caml_ba_from_typed_array(ta)
     {var kind=caml_ba_kind_of_typed_array(ta);
      return caml_ba_create_unsafe(kind,0,[ta.length],ta)}
    function caml_ml_seek_out(chanid,pos)
     {caml_ml_flush(chanid);caml_ml_channels[chanid].offset = pos;return 0}
    function caml_js_typeof(o){return typeof o}
    function caml_restore_raw_backtrace(exn,bt){return 0}
    function caml_gr_lineto(x,y)
     {var s=caml_gr_state_get();
      s.context.beginPath();
      s.context.moveTo(s.x,s.height - s.y);
      s.context.lineTo(x,s.height - y);
      s.context.stroke();
      s.x = x;
      s.y = y;
      return 0}
    function caml_js_wrap_meth_callback_unsafe(f)
     {return function()
       {var len=arguments.length,args=new Array(len + 1);
        args[0] = this;
        for(var i=0;i < len;i++)args[i + 1] = arguments[i];
        return f.apply(null,args)}}
    function caml_ba_dim_3(ba){return caml_ba_dim(ba,2)}
    var caml_ephe_data_offset=2;
    function caml_ephe_check_data(x)
     {return x[caml_ephe_data_offset] === undefined?0:1}
    function caml_bytes_get16(s,i)
     {if(i >>> 0 >= s.l - 1)caml_bytes_bound_error();
      var b1=caml_bytes_unsafe_get(s,i),b2=caml_bytes_unsafe_get(s,i + 1);
      return b2 << 8 | b1}
    function caml_obj_make_forward(b,v){b[0] = 250;b[1] = v;return 0}
    function caml_js_from_bool(x){return ! ! x}
    function caml_ml_set_channel_name(){return 0}
    function caml_gr_close_graph()
     {var s=caml_gr_state_get();
      s.canvas.width = 0;
      s.canvas.height = 0;
      return 0}
    function caml_create_string(len)
     {if(len < 0)caml_invalid_argument("String.create");
      return new MlBytes(len?2:9,"",len)}
    function caml_md5_string(s,ofs,len)
     {return caml_md5_bytes(caml_bytes_of_string(s),ofs,len)}
    function caml_md5_chan(chanid,len)
     {var chan=caml_ml_channels[chanid],chan_len=chan.file.length();
      if(len < 0)len = chan_len - chan.offset;
      if(chan.offset + len > chan_len)caml_raise_end_of_file();
      var buf=caml_create_bytes(len);
      chan.file.read(chan.offset,buf,0,len);
      return caml_md5_string(caml_string_of_bytes(buf),0,len)}
    function caml_obj_dup(x)
     {var l=x.length,a=new Array(l);
      for(var i=0;i < l;i++)a[i] = x[i];
      return a}
    function caml_weak_get_copy(x,i)
     {if(i < 0 || caml_ephe_key_offset + i >= x.length)
       caml_invalid_argument("Weak.get_copy");
      var y=caml_weak_get(x,i);
      if(y === 0)return y;
      var z=y[1];
      if(z instanceof Array)return [0,caml_obj_dup(z)];
      return y}
    function caml_ml_output_bytes(chanid,buffer,offset,len)
     {var chan=caml_ml_channels[chanid];
      if(! chan.opened)
       caml_raise_sys_error("Cannot output to a closed channel");
      var bytes;
      if(offset == 0 && caml_ml_bytes_length(buffer) == len)
       bytes = buffer;
      else
       {bytes = caml_create_bytes(len);
        caml_blit_bytes(buffer,offset,bytes,0,len)}
      var
       string=caml_string_of_bytes(bytes),
       jsstring=caml_jsbytes_of_string(string),
       id=jsstring.lastIndexOf("\n");
      if(id < 0)
       chan.buffer += jsstring;
      else
       {chan.buffer += jsstring.substr(0,id + 1);
        caml_ml_flush(chanid);
        chan.buffer += jsstring.substr(id + 1)}
      return 0}
    function caml_ml_output(chanid,buffer,offset,len)
     {return caml_ml_output_bytes
              (chanid,caml_bytes_of_string(buffer),offset,len)}
    function caml_ephe_get_data(x)
     {return x[caml_ephe_data_offset] === undefined
              ?0
              :[0,x[caml_ephe_data_offset]]}
    function caml_xmlhttprequest_create(unit)
     {var g=joo_global_object;
      if(typeof g.XMLHttpRequest !== "undefined")
       try {return new (g.XMLHttpRequest)()}catch(e){}
      if(typeof g.activeXObject !== "undefined")
       {try {return new (g.activeXObject)("Msxml2.XMLHTTP")}catch(e){}
        try {return new (g.activeXObject)("Msxml3.XMLHTTP")}catch(e){}
        try {return new (g.activeXObject)("Microsoft.XMLHTTP")}catch(e){}}
      caml_failwith("Cannot create a XMLHttpRequest")}
    function caml_trampoline_return(f,args)
     {return {joo_tramp:f,joo_args:args}}
    function caml_array_append(a1,a2)
     {var l1=a1.length,l2=a2.length,l=l1 + l2 - 1,a=new Array(l);
      a[0] = 0;
      var i=1,j=1;
      for(;i < l1;i++)a[i] = a1[i];
      for(;i < l;i++,j++)a[i] = a2[j];
      return a}
    function caml_ml_set_channel_refill(chanid,f)
     {caml_ml_channels[chanid].refill = f;return 0}
    function caml_js_expr(s)
     {js_print_stderr("caml_js_expr: fallback to runtime evaluation\n");
      return eval(caml_jsstring_of_string(s))}
    function caml_int64_mul(x,y){return x.mul(y)}
    function caml_ml_runtime_warnings_enabled(_unit)
     {return caml_runtime_warnings}
    function caml_output_value_to_bytes(v,flags)
     {return caml_bytes_of_array(caml_output_val(v,flags))}
    function caml_hash_univ_param(count,limit,obj)
     {var hash_accu=0;
      function hash_aux(obj)
       {limit--;
        if(count < 0 || limit < 0)return;
        if(obj instanceof Array && obj[0] === (obj[0] | 0))
         switch(obj[0])
          {case 248:count--;hash_accu = hash_accu * 65599 + obj[2] | 0;break;
           case 250:limit++;hash_aux(obj);break;
           default:
            count--;
            hash_accu = hash_accu * 19 + obj[0] | 0;
            for(var i=obj.length - 1;i > 0;i--)hash_aux(obj[i])}
        else
         if(caml_is_ml_bytes(obj))
          {count--;
           switch(obj.t & 6)
            {default:caml_convert_string_to_bytes(obj);case 0:
              for(var b=obj.c,l=caml_ml_bytes_length(obj),i=0;i < l;i++)
               hash_accu = hash_accu * 19 + b.charCodeAt(i) | 0;
              break;
             case 2:
              for(var a=obj.c,l=caml_ml_bytes_length(obj),i=0;i < l;i++)
               hash_accu = hash_accu * 19 + a[i] | 0
             }}
         else
          if(caml_is_ml_string(obj))
           {var jsbytes=caml_jsbytes_of_string(obj);
            for(var b=jsbytes,l=jsbytes.length,i=0;i < l;i++)
             hash_accu = hash_accu * 19 + b.charCodeAt(i) | 0}
          else
           if(typeof obj === "string")
            for(var b=obj,l=obj.length,i=0;i < l;i++)
             hash_accu = hash_accu * 19 + b.charCodeAt(i) | 0;
           else
            if(obj === (obj | 0))
             {count--;hash_accu = hash_accu * 65599 + obj | 0}
            else
             if(obj === + obj)
              {count--;
               var p=caml_int64_to_bytes(caml_int64_bits_of_float(obj));
               for(var i=7;i >= 0;i--)hash_accu = hash_accu * 19 + p[i] | 0}
             else
              if(obj && obj.caml_custom)
               if
                (caml_custom_ops[obj.caml_custom]
                 &&
                 caml_custom_ops[obj.caml_custom].hash)
                {var h=caml_custom_ops[obj.caml_custom].hash(obj) | 0;
                 hash_accu = hash_accu * 65599 + h | 0}}
      hash_aux(obj);
      return hash_accu & 0x3FFFFFFF}
    function caml_string_equal(s1,s2){return caml_bytes_equal(s1,s2)}
    function caml_output_value_to_buffer(s,ofs,len,v,flags)
     {var t=caml_output_val(v,flags);
      if(t.length > len)caml_failwith("Marshal.to_buffer: buffer overflow");
      caml_blit_bytes(t,0,s,ofs,t.length);
      return 0}
    function re_replacement_text(repl,groups,orig)
     {var
       repl=caml_jsbytes_of_string(repl),
       len=repl.length,
       orig=caml_jsbytes_of_string(orig),
       res="",
       n=0,
       cur,
       start,
       end,
       c;
      while(n < len)
       {cur = repl.charAt(n++);
        if(cur != "\\")
         res += cur;
        else
         {if(n == len)
           caml_failwith("Str.replace: illegal backslash sequence");
          cur = repl.charAt(n++);
          switch(cur)
           {case "\\":res += cur;break;
            case "0":
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7":
            case "8":
            case "9":
             c = + cur;
             if(c * 2 >= groups.length - 1)
              caml_failwith("Str.replace: reference to unmatched group");
             start = caml_array_get(groups,c * 2);
             end = caml_array_get(groups,c * 2 + 1);
             if(start == - 1)
              caml_failwith("Str.replace: reference to unmatched group");
             res += orig.slice(start,end);
             break;
            default:res += "\\" + cur}}}
      return caml_string_of_jsbytes(res)}
    function caml_pure_js_expr(s)
     {js_print_stderr("caml_pure_js_expr: fallback to runtime evaluation\n");
      return eval(caml_jsstring_of_string(s))}
    function blit_nat(nat1,ofs1,nat2,ofs2,len)
     {for(var i=0;i < len;i++)nat1.data[ofs1 + i] = nat2.data[ofs2 + i];
      return 0}
    function caml_int64_ult(x,y){return x.ucompare(y) < 0}
    function caml_int64_xor(x,y){return x.xor(y)}
    function caml_bigstring_blit_ba_to_bytes(ba1,pos1,bytes2,pos2,len)
     {if(12 != ba1.kind)
       caml_invalid_argument
        ("caml_bigstring_blit_string_to_ba: kind mismatch");
      if(len == 0)return 0;
      var ofs1=ba1.offset(pos1);
      if(ofs1 + len > ba1.data.length)caml_array_bound_error();
      if(pos2 + len > caml_ml_bytes_length(bytes2))caml_array_bound_error();
      var slice=ba1.data.slice(ofs1,ofs1 + len);
      caml_blit_bytes(caml_bytes_of_array(slice),0,bytes2,pos2,len);
      return 0}
    function caml_register_named_value(nm,v)
     {caml_named_values[caml_jsbytes_of_string(nm)] = v;return 0}
    function caml_to_js_string(s){return caml_jsstring_of_string(s)}
    function caml_parse_sign_and_base(s)
     {var i=0,len=caml_ml_string_length(s),base=10,sign=1;
      if(len > 0)
       switch(caml_string_unsafe_get(s,i))
        {case 45:i++;sign = - 1;break;case 43:i++;sign = 1;break}
      if(i + 1 < len && caml_string_unsafe_get(s,i) == 48)
       switch(caml_string_unsafe_get(s,i + 1))
        {case 120:
         case 88:base = 16;i += 2;break;
         case 111:
         case 79:base = 8;i += 2;break;
         case 98:
         case 66:base = 2;i += 2;break;
         case 117:
         case 85:i += 2;break
         }
      return [i,sign,base]}
    function caml_parse_digit(c)
     {if(c >= 48 && c <= 57)return c - 48;
      if(c >= 65 && c <= 90)return c - 55;
      if(c >= 97 && c <= 122)return c - 87;
      return - 1}
    function caml_int64_of_string(s)
     {var
       r=caml_parse_sign_and_base(s),
       i=r[0],
       sign=r[1],
       base=r[2],
       base64=caml_int64_of_int32(base),
       threshold=
        new MlInt64(0xffffff,0xfffffff,0xffff).udivmod(base64).quotient,
       c=caml_string_unsafe_get(s,i),
       d=caml_parse_digit(c);
      if(d < 0 || d >= base)caml_failwith("int_of_string");
      var res=caml_int64_of_int32(d);
      for(;;)
       {i++;
        c = caml_string_unsafe_get(s,i);
        if(c == 95)continue;
        d = caml_parse_digit(c);
        if(d < 0 || d >= base)break;
        if(caml_int64_ult(threshold,res))caml_failwith("int_of_string");
        d = caml_int64_of_int32(d);
        res = caml_int64_add(caml_int64_mul(base64,res),d);
        if(caml_int64_ult(res,d))caml_failwith("int_of_string")}
      if(i != caml_ml_string_length(s))caml_failwith("int_of_string");
      if(base == 10 && caml_int64_ult(new MlInt64(0,0,0x8000),res))
       caml_failwith("int_of_string");
      if(sign < 0)res = caml_int64_neg(res);
      return res}
    function re_search_forward(re,s,pos)
     {if(pos < 0 || pos > caml_ml_string_length(s))
       caml_invalid_argument("Str.search_forward");
      while(pos <= caml_ml_string_length(s))
       {var res=re_match(re,s,pos,0);if(res)return res;pos++}
      return [0]}
    var caml_blit_string_to_bigstring=caml_bigstring_blit_string_to_ba;
    function caml_make_vect(len,init)
     {if(len < 0)caml_array_bound_error();
      var len=len + 1 | 0,b=new Array(len);
      b[0] = 0;
      for(var i=1;i < len;i++)b[i] = init;
      return b}
    function caml_ml_seek_in(chanid,pos)
     {var chan=caml_ml_channels[chanid];
      if(chan.refill != null)caml_raise_sys_error("Illegal seek");
      chan.offset = pos;
      return 0}
    function caml_sys_read_directory(name)
     {var
       root=resolve_fs_device(name),
       a=root.device.readdir(root.rest),
       l=new Array(a.length + 1);
      l[0] = 0;
      for(var i=0;i < a.length;i++)l[i + 1] = caml_string_of_jsbytes(a[i]);
      return l}
    function caml_ml_output_char(chanid,c)
     {var s=caml_string_of_jsbytes(String.fromCharCode(c));
      caml_ml_output(chanid,s,0,1);
      return 0}
    function caml_sys_const_ostype_win32(){return 0}
    function caml_obj_is_block(x){return + (x instanceof Array)}
    function caml_ml_input_char(chanid)
     {var chan=caml_ml_channels[chanid];
      caml_ml_may_refill_input(chanid);
      if(chan.offset >= chan.file.length())caml_raise_end_of_file();
      var res=chan.file.read_one(chan.offset);
      chan.offset++;
      return res}
    function caml_obj_set_raw_field(o,i,v){return o[i + 1] = v}
    function caml_js_var(x)
     {var x=caml_jsstring_of_string(x);
      if(! x.match(/^[a-zA-Z_$][a-zA-Z_$0-9]*(\.[a-zA-Z_$][a-zA-Z_$0-9]*)*$/))
       js_print_stderr
        ('caml_js_var: "'
         +
         x
         +
         '" is not a valid JavaScript variable. continuing ..');
      return eval(x)}
    function caml_trunc_float(x){return Math.trunc(x)}
    function caml_ephe_blit_data(src,dst)
     {dst[caml_ephe_data_offset] = src[caml_ephe_data_offset];return 0}
    function caml_is_printable(c){return + (c > 31 && c < 127)}
    function caml_equal(x,y){return + (caml_compare_val(x,y,false) == 0)}
    function re_partial_match(re,s,pos)
     {if(pos < 0 || pos > caml_ml_string_length(s))
       caml_invalid_argument("Str.partial_match");
      var res=re_match(re,s,pos,1);
      return res?res:[0]}
    function caml_sys_random_seed()
     {var now=new Date().getTime(),x=now ^ 0xffffffff * Math.random();
      return [0,x]}
    function caml_final_register_called_without_value(){return 0}
    function caml_ba_get_2(ba,i0,i1){return ba.get(ba.offset([i0,i1]))}
    function win_handle_fd(x){return x}
    function caml_ba_uint8_set16(ba,i0,v)
     {var ofs=ba.offset(i0);
      if(ofs + 1 >= ba.data.length)caml_array_bound_error();
      ba.set(ofs + 0,v & 0xff);
      ba.set(ofs + 1,v >>> 8 & 0xff);
      return 0}
    function caml_js_delete(o,f){delete o[f];return 0}
    function caml_int_of_string(s)
     {var
       r=caml_parse_sign_and_base(s),
       i=r[0],
       sign=r[1],
       base=r[2],
       len=caml_ml_string_length(s),
       threshold=- 1 >>> 0,
       c=i < len?caml_string_unsafe_get(s,i):0,
       d=caml_parse_digit(c);
      if(d < 0 || d >= base)caml_failwith("int_of_string");
      var res=d;
      for(i++;i < len;i++)
       {c = caml_string_unsafe_get(s,i);
        if(c == 95)continue;
        d = caml_parse_digit(c);
        if(d < 0 || d >= base)break;
        res = base * res + d;
        if(res > threshold)caml_failwith("int_of_string")}
      if(i != len)caml_failwith("int_of_string");
      res = sign * res;
      if(base == 10 && (res | 0) != res)caml_failwith("int_of_string");
      return res | 0}
    function caml_list_mount_point()
     {var prev=0;
      for(var i=0;i < jsoo_mount_point.length;i++)
       {var old=prev;
        prev = [0,caml_string_of_jsbytes(jsoo_mount_point[i].path),old]}
      return prev}
    var
     caml_marshal_constants=
      {PREFIX_SMALL_BLOCK:0x80,
       PREFIX_SMALL_INT:0x40,
       PREFIX_SMALL_STRING:0x20,
       CODE_INT8:0x00,
       CODE_INT16:0x01,
       CODE_INT32:0x02,
       CODE_INT64:0x03,
       CODE_SHARED8:0x04,
       CODE_SHARED16:0x05,
       CODE_SHARED32:0x06,
       CODE_BLOCK32:0x08,
       CODE_BLOCK64:0x13,
       CODE_STRING8:0x09,
       CODE_STRING32:0x0A,
       CODE_DOUBLE_BIG:0x0B,
       CODE_DOUBLE_LITTLE:0x0C,
       CODE_DOUBLE_ARRAY8_BIG:0x0D,
       CODE_DOUBLE_ARRAY8_LITTLE:0x0E,
       CODE_DOUBLE_ARRAY32_BIG:0x0F,
       CODE_DOUBLE_ARRAY32_LITTLE:0x07,
       CODE_CODEPOINTER:0x10,
       CODE_INFIXPOINTER:0x11,
       CODE_CUSTOM:0x12,
       CODE_CUSTOM_LEN:0x18,
       CODE_CUSTOM_FIXED:0x19};
    function caml_obj_raw_field(o,i){return o[i + 1]}
    function caml_js_equals(x,y){return + (x == y)}
    function bigstring_to_typed_array(bs){return bs.data}
    function caml_gr_arc_aux(ctx,cx,cy,ry,rx,a1,a2)
     {while(a1 > a2)a2 += 360;
      a1 /= 180;
      a2 /= 180;
      var
       rot=0,
       xPos,
       yPos,
       xPos_prev,
       yPos_prev,
       space=2,
       num=(a2 - a1) * Math.PI * ((rx + ry) / 2) / space | 0,
       delta=(a2 - a1) * Math.PI / num,
       i=a1 * Math.PI;
      for(var j=0;j <= num;j++)
       {xPos
        =
        cx
        -
        rx
        *
        Math.sin(i)
        *
        Math.sin(rot * Math.PI)
        +
        ry
        *
        Math.cos(i)
        *
        Math.cos(rot * Math.PI);
        xPos = xPos.toFixed(2);
        yPos
        =
        cy
        +
        ry
        *
        Math.cos(i)
        *
        Math.sin(rot * Math.PI)
        +
        rx
        *
        Math.sin(i)
        *
        Math.cos(rot * Math.PI);
        yPos = yPos.toFixed(2);
        if(j == 0)
         ctx.moveTo(xPos,yPos);
        else
         if(xPos_prev != xPos || yPos_prev != yPos)ctx.lineTo(xPos,yPos);
        xPos_prev = xPos;
        yPos_prev = yPos;
        i -= delta}
      return 0}
    function caml_gr_fill_arc(x,y,rx,ry,a1,a2)
     {var s=caml_gr_state_get();
      s.context.beginPath();
      caml_gr_arc_aux(s.context,x,s.height - y,rx,ry,a1,a2);
      s.context.fill();
      return 0}
    function caml_ba_slice(ba,vind)
     {vind = caml_js_from_array(vind);
      var num_inds=vind.length,index=[],sub_dims=[],ofs;
      if(num_inds > ba.dims.length)
       caml_invalid_argument("Bigarray.slice: too many indices");
      if(ba.layout == 0)
       {for(var i=0;i < num_inds;i++)index[i] = vind[i];
        for(;i < ba.dims.length;i++)index[i] = 0;
        sub_dims = ba.dims.slice(num_inds)}
      else
       {for(var i=0;i < num_inds;i++)
         index[ba.dims.length - num_inds + i] = vind[i];
        for(var i=0;i < ba.dims.length - num_inds;i++)index[i] = 1;
        sub_dims = ba.dims.slice(0,ba.dims.length - num_inds)}
      ofs = ba.offset(index);
      var
       size=caml_ba_get_size(sub_dims),
       size_per_element=caml_ba_get_size_per_element(ba.kind),
       new_data=
        ba.data.subarray
         (ofs * size_per_element,(ofs + size) * size_per_element);
      return caml_ba_create_unsafe(ba.kind,ba.layout,sub_dims,new_data)}
    function caml_marshal_data_size(s,ofs)
     {function get32(s,i)
       {return caml_bytes_unsafe_get(s,i)
               <<
               24
               |
               caml_bytes_unsafe_get(s,i + 1)
               <<
               16
               |
               caml_bytes_unsafe_get(s,i + 2)
               <<
               8
               |
               caml_bytes_unsafe_get(s,i + 3)}
      if(get32(s,ofs) != (0x8495A6BE | 0))
       caml_failwith("Marshal.data_size: bad object");
      return get32(s,ofs + 4)}
    function caml_input_value(chanid)
     {var chan=caml_ml_channels[chanid],buf=caml_create_bytes(8);
      chan.file.read(chan.offset,buf,0,8);
      var len=caml_marshal_data_size(buf,0) + 20,buf=caml_create_bytes(len);
      chan.file.read(chan.offset,buf,0,len);
      var offset=[0],res=caml_input_value_from_bytes(buf,offset);
      chan.offset = chan.offset + offset[0];
      return res}
    function caml_ba_kind(ba){return ba.kind}
    function caml_js_fun_call(f,a)
     {switch(a.length)
       {case 1:return f();
        case 2:return f(a[1]);
        case 3:return f(a[1],a[2]);
        case 4:return f(a[1],a[2],a[3]);
        case 5:return f(a[1],a[2],a[3],a[4]);
        case 6:return f(a[1],a[2],a[3],a[4],a[5]);
        case 7:return f(a[1],a[2],a[3],a[4],a[5],a[6]);
        case 8:return f(a[1],a[2],a[3],a[4],a[5],a[6],a[7])
        }
      return f.apply(null,caml_js_from_array(a))}
    function caml_js_pure_expr(f){return f()}
    function compare_digits_nat(nat1,ofs1,nat2,ofs2)
     {if(nat1.data[ofs1] > nat2.data[ofs2])return 1;
      if(nat1.data[ofs1] < nat2.data[ofs2])return - 1;
      return 0}
    function caml_ml_input(chanid,s,i,l)
     {var chan=caml_ml_channels[chanid],l2=chan.file.length() - chan.offset;
      if(l2 == 0 && chan.refill != null)l2 = caml_ml_refill_input(chan);
      if(l2 < l)l = l2;
      chan.file.read(chan.offset,s,i,l);
      chan.offset += l;
      return l}
    function caml_gr_wait_event(_evl)
     {caml_failwith
       ("caml_gr_wait_event not Implemented: use Graphics_js instead")}
    function caml_gr_sigio_handler(){return 0}
    function caml_hash_mix_bigstring(h,bs)
     {return caml_hash_mix_bytes_arr(h,bs.data)}
    function caml_record_backtrace(){return 0}
    function unix_gmtime(t)
     {var
       d=new Date(t * 1000),
       d_num=d.getTime(),
       januaryfirst=new Date(Date.UTC(d.getUTCFullYear(),0,1)).getTime(),
       doy=Math.floor((d_num - januaryfirst) / 86400000);
      return [0,
              d.getUTCSeconds(),
              d.getUTCMinutes(),
              d.getUTCHours(),
              d.getUTCDate(),
              d.getUTCMonth(),
              d.getUTCFullYear() - 1900,
              d.getUTCDay(),
              doy,
              false | 0]}
    function caml_sys_get_config()
     {return [0,caml_string_of_jsbytes("Unix"),32,0]}
    function caml_sys_const_backend_type()
     {return [0,caml_string_of_jsbytes("js_of_ocaml")]}
    function unix_time(){return Math.floor(unix_gettimeofday())}
    function caml_ml_out_channels_list()
     {var l=0;
      for(var c=0;c < caml_ml_channels.length;c++)
       if
        (caml_ml_channels[c]
         &&
         caml_ml_channels[c].opened
         &&
         caml_ml_channels[c].out)
        l = [0,caml_ml_channels[c].fd,l];
      return l}
    function bigstring_of_array_buffer(ab)
     {var ta=new (joo_global_object.Uint8Array)(ab);
      return caml_ba_create_unsafe(12,0,[ta.length],ta)}
    function caml_mod(x,y){if(y == 0)caml_raise_zero_divide();return x % y}
    function caml_ba_init(){return 0}
    function re_string_match(re,s,pos)
     {if(pos < 0 || pos > caml_ml_string_length(s))
       caml_invalid_argument("Str.string_match");
      var res=re_match(re,s,pos,0);
      return res?res:[0]}
    function BigStringReader(bs,i){this.s = bs;this.i = i}
    BigStringReader.prototype
    =
    {read8u:function(){return caml_ba_get_1(this.s,this.i++)},
     read8s:function(){return caml_ba_get_1(this.s,this.i++) << 24 >> 24},
     read16u:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 2;
       return caml_ba_get_1(s,i) << 8 | caml_ba_get_1(s,i + 1)},
     read16s:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 2;
       return caml_ba_get_1(s,i) << 24 >> 16 | caml_ba_get_1(s,i + 1)},
     read32u:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 4;
       return (caml_ba_get_1(s,i)
               <<
               24
               |
               caml_ba_get_1(s,i + 1)
               <<
               16
               |
               caml_ba_get_1(s,i + 2)
               <<
               8
               |
               caml_ba_get_1(s,i + 3))
              >>>
              0},
     read32s:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 4;
       return caml_ba_get_1(s,i)
              <<
              24
              |
              caml_ba_get_1(s,i + 1)
              <<
              16
              |
              caml_ba_get_1(s,i + 2)
              <<
              8
              |
              caml_ba_get_1(s,i + 3)},
     readstr:
     function(len)
      {var i=this.i,arr=new Array(len);
       for(var j=0;j < len;j++)arr[j] = caml_ba_get_1(this.s,i + j);
       this.i = i + len;
       return caml_string_of_array(arr)}};
    function caml_gr_dump_image(im)
     {var data=[0];
      for(var i=0;i < im.height;i++)
       {data[i + 1] = [0];
        for(var j=0;j < im.width;j++)
         {var
           o=i * (im.width * 4) + j * 4,
           r=im.data[o + 0],
           g=im.data[o + 1],
           b=im.data[o + 2];
          data[i + 1][j + 1] = (r << 16) + (g << 8) + b}}
      return data}
    function caml_ba_get_generic(ba,i)
     {var ofs=ba.offset(caml_js_from_array(i));return ba.get(ofs)}
    function caml_get_exception_backtrace(){return 0}
    function caml_format_float(fmt,x)
     {function toFixed(x,dp)
       {if(Math.abs(x) < 1.0)
         return x.toFixed(dp);
        else
         {var e=parseInt(x.toString().split("+")[1]);
          if(e > 20)
           {e -= 20;
            x /= Math.pow(10,e);
            x += new Array(e + 1).join("0");
            if(dp > 0)x = x + "." + new Array(dp + 1).join("0");
            return x}
          else
           return x.toFixed(dp)}}
      var s,f=caml_parse_format(fmt),prec=f.prec < 0?6:f.prec;
      if(x < 0 || x == 0 && 1 / x == - Infinity){f.sign = - 1;x = - x}
      if(isNaN(x))
       {s = "nan";f.filler = " "}
      else
       if(! isFinite(x))
        {s = "inf";f.filler = " "}
       else
        switch(f.conv)
         {case "e":
           var s=x.toExponential(prec),i=s.length;
           if(s.charAt(i - 3) == "e")
            s = s.slice(0,i - 1) + "0" + s.slice(i - 1);
           break;
          case "f":s = toFixed(x,prec);break;
          case "g":
           prec = prec?prec:1;
           s = x.toExponential(prec - 1);
           var j=s.indexOf("e"),exp=+ s.slice(j + 1);
           if(exp < - 4 || x >= 1e21 || x.toFixed(0).length > prec)
            {var i=j - 1;
             while(s.charAt(i) == "0")i--;
             if(s.charAt(i) == ".")i--;
             s = s.slice(0,i + 1) + s.slice(j);
             i = s.length;
             if(s.charAt(i - 3) == "e")
              s = s.slice(0,i - 1) + "0" + s.slice(i - 1);
             break}
           else
            {var p=prec;
             if(exp < 0)
              {p -= exp + 1;s = x.toFixed(p)}
             else
              while(s = x.toFixed(p),s.length > prec + 1)p--;
             if(p)
              {var i=s.length - 1;
               while(s.charAt(i) == "0")i--;
               if(s.charAt(i) == ".")i--;
               s = s.slice(0,i + 1)}}
           break
          }
      return caml_finish_formatting(f,s)}
    function caml_mount_autoload(name,f)
     {var path=caml_make_path(name),name=path.join("/") + "/";
      jsoo_mount_point.push({path:name,device:new MlFakeDevice(name,f)});
      return 0}
    function caml_bigstring_blit_ba_to_ba(ba1,pos1,ba2,pos2,len)
     {if(12 != ba1.kind)
       caml_invalid_argument("caml_bigstring_blit_ba_to_ba: kind mismatch");
      if(12 != ba2.kind)
       caml_invalid_argument("caml_bigstring_blit_ba_to_ba: kind mismatch");
      if(len == 0)return 0;
      var ofs1=ba1.offset(pos1),ofs2=ba2.offset(pos2);
      if(ofs1 + len > ba1.data.length)caml_array_bound_error();
      if(ofs2 + len > ba2.data.length)caml_array_bound_error();
      var slice=ba1.data.subarray(ofs1,ofs1 + len);
      ba2.data.set(slice,pos2);
      return 0}
    var caml_blit_bigstring_to_bigstring=caml_bigstring_blit_ba_to_ba;
    function caml_string_lessthan(s1,s2){return caml_bytes_lessthan(s1,s2)}
    function caml_string_greaterthan(s1,s2)
     {return caml_string_lessthan(s2,s1)}
    function caml_div(x,y)
     {if(y == 0)caml_raise_zero_divide();return x / y | 0}
    function caml_ephe_get_data_copy(x)
     {return x[caml_ephe_data_offset] === undefined
              ?0
              :[0,caml_obj_dup(x[caml_ephe_data_offset])]}
    function caml_memprof_start(rate,stack_size,tracker){return 0}
    function caml_sys_get_argv(a){return [0,caml_argv[1],caml_argv]}
    function caml_js_to_bool(x){return + x}
    function caml_gr_create_image(x,y)
     {var s=caml_gr_state_get();return s.context.createImageData(x,y)}
    var caml_ephe_get_key_copy=caml_weak_get_copy;
    function caml_lessthan(x,y){return + (caml_compare_val(x,y,false) < 0)}
    function caml_raw_backtrace_next_slot(){return 0}
    function caml_register_global(n,v,name_opt)
     {if(name_opt && joo_global_object.toplevelReloc)
       n = joo_global_object.toplevelReloc(name_opt);
      caml_global_data[n + 1] = v;
      if(name_opt)caml_global_data[name_opt] = v}
    function mult_nat(nat1,ofs1,len1,nat2,ofs2,len2,nat3,ofs3,len3)
     {var carry=0;
      for(var i=0;i < len3;i++)
       carry
       +=
       mult_digit_nat(nat1,ofs1 + i,len1 - i,nat2,ofs2,len2,nat3,ofs3 + i);
      return carry}
    function square_nat(nat1,ofs1,len1,nat2,ofs2,len2)
     {var carry=0;
      carry += add_nat(nat1,ofs1,len1,nat1,ofs1,len1,0);
      carry += mult_nat(nat1,ofs1,len1,nat2,ofs2,len2,nat2,ofs2,len2);
      return carry}
    function caml_js_from_float(x){return x}
    function caml_floatarray_create(len)
     {if(len < 0)caml_array_bound_error();
      var len=len + 1 | 0,b=new Array(len);
      b[0] = 254;
      for(var i=1;i < len;i++)b[i] = 0;
      return b}
    function caml_gc_stat(){return [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]}
    function caml_sys_modify_argv(arg){caml_argv = arg;return 0}
    var caml_method_cache=[];
    function caml_get_public_method(obj,tag,cacheid)
     {var meths=obj[1],ofs=caml_method_cache[cacheid];
      if(ofs === undefined)
       for(var i=caml_method_cache.length;i < cacheid;i++)
        caml_method_cache[i] = 0;
      else
       if(meths[ofs] === tag)return meths[ofs - 1];
      var li=3,hi=meths[1] * 2 + 1,mi;
      while(li < hi)
       {mi = li + hi >> 1 | 1;if(tag < meths[mi + 1])hi = mi - 2;else li = mi}
      caml_method_cache[cacheid] = li + 1;
      return tag == meths[li + 1]?meths[li]:0}
    function caml_js_get_console()
     {var
       c=joo_global_object.console?joo_global_object.console:{},
       m=
        ["log",
         "debug",
         "info",
         "warn",
         "error",
         "assert",
         "dir",
         "dirxml",
         "trace",
         "group",
         "groupCollapsed",
         "groupEnd",
         "time",
         "timeEnd"];
      function f(){}
      for(var i=0;i < m.length;i++)if(! c[m[i]])c[m[i]] = f;
      return c}
    function caml_sys_unsafe_getenv(name){return caml_sys_getenv(name)}
    function caml_ml_open_descriptor_in(fd)
     {var data=caml_global_data.fds[fd];
      if(data.flags.wronly)caml_raise_sys_error("fd " + fd + " is writeonly");
      var
       channel=
        {file:data.file,
         offset:data.offset,
         fd:fd,
         opened:true,
         out:false,
         refill:null};
      caml_ml_channels[channel.fd] = channel;
      return channel.fd}
    function bigstring_of_typed_array(ba)
     {var
       ta=
        new
         (joo_global_object.Uint8Array)
         (ba.buffer,ba.byteOffset,ba.length * ba.BYTES_PER_ELEMENT);
      return caml_ba_create_unsafe(12,0,[ta.length],ta)}
    function caml_round_float(x){return Math.round(x)}
    function caml_ojs_new_arr(c,a)
     {switch(a.length)
       {case 0:return new c();
        case 1:return new c(a[0]);
        case 2:return new c(a[0],a[1]);
        case 3:return new c(a[0],a[1],a[2]);
        case 4:return new c(a[0],a[1],a[2],a[3]);
        case 5:return new c(a[0],a[1],a[2],a[3],a[4]);
        case 6:return new c(a[0],a[1],a[2],a[3],a[4],a[5]);
        case 7:return new c(a[0],a[1],a[2],a[3],a[4],a[5],a[6])
        }
      function F(){return c.apply(this,a)}
      F.prototype = c.prototype;
      return new F()}
    function complement_nat(nat,ofs,len)
     {for(var i=0;i < len;i++)
       nat.data[ofs + i] = (- 1 >>> 0) - (nat.data[ofs + i] >>> 0)}
    var caml_js_regexps={amp:/&/g,lt:/</g,quot:/\"/g,all:/[&<\"]/};
    function caml_js_html_escape(s)
     {if(! caml_js_regexps.all.test(s))return s;
      return s.replace(caml_js_regexps.amp,"&amp;").replace
               (caml_js_regexps.lt,"&lt;").replace
              (caml_js_regexps.quot,"&quot;")}
    function caml_ba_dim_2(ba){return caml_ba_dim(ba,1)}
    function caml_js_wrap_meth_callback_arguments(f)
     {return function()
       {var len=arguments.length,args=new Array(len);
        for(var i=0;i < len;i++)args[i] = arguments[i];
        return caml_call_gen(f,[this,args])}}
    function caml_sinh_float(x){return (Math.exp(x) - Math.exp(- x)) / 2}
    function caml_ldexp_float(x,exp)
     {exp |= 0;
      if(exp > 1023)
       {exp -= 1023;
        x *= Math.pow(2,1023);
        if(exp > 1023){exp -= 1023;x *= Math.pow(2,1023)}}
      if(exp < - 1023){exp += 1023;x *= Math.pow(2,- 1023)}
      x *= Math.pow(2,exp);
      return x}
    function caml_gr_state_set(ctx)
     {caml_gr_state = ctx;caml_gr_state_init();return 0}
    function caml_js_wrap_callback_strict(arity,f)
     {return function()
       {var n=arguments.length;
        if(n == arity && f.length == arity)return f.apply(null,arguments);
        var args=new Array(arity),len=Math.min(arguments.length,arity);
        for(var i=0;i < len;i++)args[i] = arguments[i];
        return caml_call_gen(f,args)}}
    function caml_ba_set_1(ba,i0,v){ba.set(ba.offset(i0),v);return 0}
    function caml_get_current_callstack(){return [0]}
    function land_digit_nat(nat1,ofs1,nat2,ofs2)
     {nat1.data[ofs1] &= nat2.data[ofs2];return 0}
    function caml_int64_mod(x,y){return x.mod(y)}
    function caml_obj_set_tag(x,tag){x[0] = tag;return 0}
    function caml_create_file_extern(name,content)
     {if(joo_global_object.caml_create_file)
       joo_global_object.caml_create_file(name,content);
      else
       {if(! joo_global_object.caml_fs_tmp)joo_global_object.caml_fs_tmp = [];
        joo_global_object.caml_fs_tmp.push({name:name,content:content})}
      return 0}
    function caml_int32_bswap(x)
     {return (x & 0x000000FF)
             <<
             24
             |
             (x & 0x0000FF00)
             <<
             8
             |
             (x & 0x00FF0000)
             >>>
             8
             |
             (x & 0xFF000000)
             >>>
             24}
    function win_startup(){}
    function caml_ba_set_3(ba,i0,i1,i2,v)
     {ba.set(ba.offset([i0,i1,i2]),v);return 0}
    function caml_js_instanceof(o,c){return o instanceof c}
    var caml_blit_bigstring_to_string=caml_bigstring_blit_ba_to_bytes;
    function nth_digit_nat_native(nat,ofs){return nat.data[ofs]}
    function set_digit_nat_native(nat,ofs,digit)
     {nat.data[ofs] = digit;return 0}
    function caml_string_set64(s,i,i64){return caml_bytes_set64(s,i,i64)}
    function caml_gr_state_create(canvas,w,h)
     {var context=canvas.getContext("2d");
      return {context:context,
              canvas:canvas,
              x:0,
              y:0,
              width:w,
              height:h,
              line_width:1,
              font:caml_string_of_jsbytes("fixed"),
              text_size:26,
              color:0x000000,
              title:caml_string_of_jsbytes("")}}
    function caml_js_wrap_callback(f)
     {return function()
       {var len=arguments.length;
        if(len > 0)
         {var args=new Array(len);
          for(var i=0;i < len;i++)args[i] = arguments[i];
          return caml_call_gen(f,args)}
        else
         return caml_call_gen(f,[undefined])}}
    function caml_gr_draw_arc(x,y,rx,ry,a1,a2)
     {var s=caml_gr_state_get();
      s.context.beginPath();
      caml_gr_arc_aux(s.context,x,s.height - y,rx,ry,a1,a2);
      s.context.stroke();
      return 0}
    function caml_ba_map_file(vfd,kind,layout,shared,dims,pos)
     {caml_failwith("caml_ba_map_file not implemented")}
    function caml_ba_map_file_bytecode(argv,argn)
     {return caml_ba_map_file(argv[0],argv[1],argv[2],argv[3],argv[4],argv[5])}
    function caml_ba_create_from(data1,data2,jstyp,kind,layout,dims)
     {if(data2 || caml_ba_get_size_per_element(kind) == 2)
       caml_invalid_argument
        ("caml_ba_create_from: use return caml_ba_create_unsafe");
      return caml_ba_create_unsafe(kind,layout,dims,data1)}
    function caml_tanh_float(x)
     {var y=Math.exp(x),z=Math.exp(- x);return (y - z) / (y + z)}
    function caml_gr_draw_str(str)
     {var s=caml_gr_state_get(),m=s.context.measureText(str),dx=m.width;
      s.context.fillText(str,s.x,s.height - s.y);
      s.x += dx | 0;
      return 0}
    function caml_gr_draw_string(str)
     {caml_gr_draw_str(caml_jsstring_of_string(str));return 0}
    function caml_gr_draw_char(c)
     {caml_gr_draw_str(String.fromCharCode(c));return 0}
    function caml_unmount(name)
     {var path=caml_make_path(name),name=path.join("/") + "/",idx=- 1;
      for(var i=0;i < jsoo_mount_point.length;i++)
       if(jsoo_mount_point[i].path == name)idx = i;
      if(idx > - 1)jsoo_mount_point.splice(idx,1);
      return 0}
    function caml_input_value_from_string(s,ofs)
     {var reader=new MlStringReader(s,typeof ofs == "number"?ofs:ofs[0]);
      return caml_input_value_from_reader(reader,ofs)}
    function caml_ml_pos_in_64(chanid)
     {return caml_int64_of_float(caml_ml_channels[chanid].offset)}
    function caml_gr_draw_image(im,x,y)
     {var s=caml_gr_state_get();
      if(! im.image)
       {var canvas=document.createElement("canvas");
        canvas.width = s.width;
        canvas.height = s.height;
        canvas.getContext("2d").putImageData(im,0,0);
        var image=new (joo_global_object.Image)();
        image.onload
        =
        function()
         {s.context.drawImage(image,x,s.height - im.height - y);
          im.image = image};
        image.src = canvas.toDataURL("image/png")}
      else
       s.context.drawImage(im.image,x,s.height - im.height - y);
      return 0}
    function caml_register_channel_for_spacetime(_channel){return 0}
    function caml_string_set(s,i,c)
     {if(i >>> 0 >= s.l)caml_string_bound_error();
      return caml_string_unsafe_set(s,i,c)}
    function caml_ml_pos_out(chanid)
     {caml_ml_flush(chanid);return caml_ml_channels[chanid].offset}
    function caml_spacetime_enabled(_unit){return 0}
    function caml_bytes_notequal(s1,s2){return 1 - caml_string_equal(s1,s2)}
    function caml_runtime_parameters(_unit){return caml_string_of_jsbytes("")}
    function caml_js_object(a)
     {var o={};
      for(var i=1;i < a.length;i++)
       {var p=a[i];o[caml_jsstring_of_string(p[1])] = p[2]}
      return o}
    function caml_ba_create(kind,layout,dims_ml)
     {var
       dims=caml_js_from_array(dims_ml),
       data=caml_ba_create_buffer(kind,caml_ba_get_size(dims));
      return caml_ba_create_unsafe(kind,layout,dims,data)}
    function caml_weak_blit(a1,i1,a2,i2,len)
     {caml_array_blit
       (a1,caml_ephe_key_offset + i1 - 1,a2,caml_ephe_key_offset + i2 - 1,len);
      return 0}
    function caml_gr_remember_mode()
     {caml_failwith("caml_gr_remember_mode not Implemented")}
    function caml_bswap16(x){return (x & 0x00FF) << 8 | (x & 0xFF00) >> 8}
    function caml_ml_set_binary_mode(chanid,mode)
     {var chan=caml_ml_channels[chanid],data=caml_global_data.fds[chan.fd];
      data.flags.text = ! mode;
      data.flags.binary = mode;
      return 0}
    function caml_final_register(){return 0}
    function caml_gr_draw_rect(x,y,w,h)
     {var s=caml_gr_state_get();
      s.context.strokeRect(x,s.height - y,w,- h);
      return 0}
    function caml_string_get16(s,i)
     {if(i >>> 0 >= caml_ml_string_length(s) - 1)caml_string_bound_error();
      var b1=caml_string_unsafe_get(s,i),b2=caml_string_unsafe_get(s,i + 1);
      return b2 << 8 | b1}
    function caml_ephe_unset_data(x,data)
     {x[caml_ephe_data_offset] = undefined;return 0}
    function caml_output_value(chanid,v,flags)
     {var s=caml_output_value_to_string(v,flags);
      caml_ml_output(chanid,s,0,caml_ml_string_length(s));
      return 0}
    function caml_ba_get_3(ba,i0,i1,i2){return ba.get(ba.offset([i0,i1,i2]))}
    var
     caml_ephe_blit_key=caml_weak_blit,
     caml_initial_time=new Date().getTime() * 0.001;
    function caml_sys_time()
     {var now=new Date().getTime();return now * 0.001 - caml_initial_time}
    function caml_sys_time_include_children(b){return caml_sys_time()}
    function caml_check_bound(array,index)
     {if(index >>> 0 >= array.length - 1)caml_array_bound_error();
      return array}
    function caml_hash_mix_string(h,v)
     {return caml_hash_mix_jsbytes(h,caml_jsbytes_of_string(v))}
    function caml_hash(count,limit,seed,obj)
     {var queue,rd,wr,sz,num,h,v,i,len;
      sz = limit;
      if(sz < 0 || sz > 256)sz = 256;
      num = count;
      h = seed;
      queue = [obj];
      rd = 0;
      wr = 1;
      while(rd < wr && num > 0)
       {v = queue[rd++];
        if(v && v.caml_custom)
         {if
           (caml_custom_ops[v.caml_custom]
            &&
            caml_custom_ops[v.caml_custom].hash)
           {var hh=caml_custom_ops[v.caml_custom].hash(v);
            h = caml_hash_mix_int(h,hh);
            num--}}
        else
         if(v instanceof Array && v[0] === (v[0] | 0))
          switch(v[0])
           {case 248:h = caml_hash_mix_int(h,v[2]);num--;break;
            case 250:queue[--rd] = v[1];break;
            default:
             var tag=v.length - 1 << 10 | v[0];
             h = caml_hash_mix_int(h,tag);
             for(i = 1,len = v.length;i < len;i++)
              {if(wr >= sz)break;queue[wr++] = v[i]}
             break}
         else
          if(caml_is_ml_bytes(v))
           {h = caml_hash_mix_bytes(h,v);num--}
          else
           if(caml_is_ml_string(v))
            {h = caml_hash_mix_string(h,v);num--}
           else
            if(typeof v === "string")
             {h = caml_hash_mix_jsbytes(h,v);num--}
            else
             if(v === (v | 0))
              {h = caml_hash_mix_int(h,v + v + 1);num--}
             else
              if(v === + v){h = caml_hash_mix_float(h,v);num--}}
      h = caml_hash_mix_final(h);
      return h & 0x3FFFFFFF}
    function caml_obj_tag(x)
     {if(x instanceof Array && x[0] == x[0] >>> 0)
       return x[0];
      else
       if(caml_is_ml_bytes(x))
        return 252;
       else
        if(caml_is_ml_string(x))
         return 252;
        else
         if(x instanceof Function || typeof x == "function")
          return 247;
         else
          if(x && x.caml_custom)return 255;else return 1000}
    function caml_ba_to_typed_array(ba){return ba.data}
    function caml_js_export_var()
     {return typeof module !== "undefined" && module && module.exports
              ?module.exports
              :joo_global_object}
    function caml_bytes_get32(s,i)
     {if(i >>> 0 >= s.l - 3)caml_bytes_bound_error();
      var
       b1=caml_bytes_unsafe_get(s,i),
       b2=caml_bytes_unsafe_get(s,i + 1),
       b3=caml_bytes_unsafe_get(s,i + 2),
       b4=caml_bytes_unsafe_get(s,i + 3);
      return b4 << 24 | b3 << 16 | b2 << 8 | b1}
    function caml_frexp_float(x)
     {if(x == 0 || ! isFinite(x))return [0,x,0];
      var neg=x < 0;
      if(neg)x = - x;
      var exp=Math.max(- 1023,jsoo_floor_log2(x) + 1);
      x *= Math.pow(2,- exp);
      while(x < 0.5){x *= 2;exp--}
      while(x >= 1){x *= 0.5;exp++}
      if(neg)x = - x;
      return [0,x,exp]}
    function caml_string_get64(s,i)
     {if(i >>> 0 >= caml_ml_string_length(s) - 7)caml_string_bound_error();
      var a=new Array(8);
      for(var j=0;j < 8;j++)a[7 - j] = caml_string_unsafe_get(s,i + j);
      return caml_int64_of_bytes(a)}
    function caml_ml_pos_out_64(chanid)
     {caml_ml_flush(chanid);
      return caml_int64_of_float(caml_ml_channels[chanid].offset)}
    function caml_gr_close_subwindow(a)
     {caml_failwith("caml_gr_close_subwindow not Implemented")}
    function caml_floatarray_blit(a1,i1,a2,i2,len)
     {if(i2 <= i1)
       for(var j=1;j <= len;j++)a2[i2 + j] = a1[i1 + j];
      else
       for(var j=len;j >= 1;j--)a2[i2 + j] = a1[i1 + j];
      return 0}
    function caml_set_static_env(k,v)
     {if(! joo_global_object.jsoo_static_env)
       joo_global_object.jsoo_static_env = {};
      joo_global_object.jsoo_static_env[k] = v;
      return 0}
    function caml_ba_change_layout(ba,layout)
     {if(ba.layout == layout)return ba;
      var new_dims=[];
      for(var i=0;i < ba.dims.length;i++)
       new_dims[i] = ba.dims[ba.dims.length - i - 1];
      return caml_ba_create_unsafe(ba.kind,layout,new_dims,ba.data)}
    function caml_js_new(c,a)
     {switch(a.length)
       {case 1:return new c();
        case 2:return new c(a[1]);
        case 3:return new c(a[1],a[2]);
        case 4:return new c(a[1],a[2],a[3]);
        case 5:return new c(a[1],a[2],a[3],a[4]);
        case 6:return new c(a[1],a[2],a[3],a[4],a[5]);
        case 7:return new c(a[1],a[2],a[3],a[4],a[5],a[6]);
        case 8:return new c(a[1],a[2],a[3],a[4],a[5],a[6],a[7])
        }
      function F(){return c.apply(this,caml_js_from_array(a))}
      F.prototype = c.prototype;
      return new F()}
    function caml_gr_current_y(){var s=caml_gr_state_get();return s.y}
    function caml_format_int(fmt,i)
     {if(caml_jsbytes_of_string(fmt) == "%d")
       return caml_string_of_jsbytes("" + i);
      var f=caml_parse_format(fmt);
      if(i < 0)if(f.signedconv){f.sign = - 1;i = - i}else i >>>= 0;
      var s=i.toString(f.base);
      if(f.prec >= 0)
       {f.filler = " ";
        var n=f.prec - s.length;
        if(n > 0)s = caml_str_repeat(n,"0") + s}
      return caml_finish_formatting(f,s)}
    function caml_obj_truncate(x,s)
     {if(s <= 0 || s + 1 > x.length)caml_invalid_argument("Obj.truncate");
      if(x.length != s + 1)x.length = s + 1;
      return 0}
    function caml_js_to_string(s){return caml_string_of_jsstring(s)}
    function is_digit_odd(nat,ofs){if(nat.data[ofs] & 1)return 1;return 0}
    function caml_runtime_variant(_unit){return caml_string_of_jsbytes("")}
    function caml_ml_open_descriptor_out(fd)
     {var data=caml_global_data.fds[fd];
      if(data.flags.rdonly)caml_raise_sys_error("fd " + fd + " is readonly");
      var
       channel=
        {file:data.file,
         offset:data.offset,
         fd:fd,
         opened:true,
         out:true,
         buffer:""};
      caml_ml_channels[channel.fd] = channel;
      return channel.fd}
    function caml_array_concat(l)
     {var a=[0];
      while(l !== 0)
       {var b=l[1];for(var i=1;i < b.length;i++)a.push(b[i]);l = l[2]}
      return a}
    function caml_gr_open_graph(info)
     {var g=joo_global_object,info=caml_jsstring_of_string(info);
      function get(name)
       {var res=info.match("(^|,) *" + name + " *= *([a-zA-Z0-9_]+) *(,|$)");
        if(res)return res[2]}
      var specs=[];
      if(! (info == ""))specs.push(info);
      var target=get("target");
      if(! target)target = "";
      var status=get("status");
      if(! status)specs.push("status=1");
      var w=get("width");
      w = w?parseInt(w):200;
      specs.push("width=" + w);
      var h=get("height");
      h = h?parseInt(h):200;
      specs.push("height=" + h);
      var win=g.open("about:blank",target,specs.join(","));
      if(! win)caml_failwith("Graphics.open_graph: cannot open the window");
      var doc=win.document,canvas=doc.createElement("canvas");
      canvas.width = w;
      canvas.height = h;
      var ctx=caml_gr_state_create(canvas,w,h);
      ctx.set_title = function(title){doc.title = title};
      caml_gr_state_set(ctx);
      var body=doc.body;
      body.style.margin = "0px";
      body.appendChild(canvas);
      return 0}
    function caml_ephe_set_data(x,data)
     {x[caml_ephe_data_offset] = data;return 0}
    function caml_make_float_vect(len)
     {if(len < 0)caml_array_bound_error();
      var len=len + 1 | 0,b=new Array(len);
      b[0] = 254;
      for(var i=1;i < len;i++)b[i] = 0;
      return b}
    function caml_memprof_stop(unit){return 0}
    function caml_greaterequal(x,y)
     {return + (caml_compare_val(x,y,false) >= 0)}
    function caml_get_exception_raw_backtrace(){return [0]}
    function caml_log1p_float(x)
     {var y=1 + x,z=y - 1;return z == 0?x:x * Math.log(y) / z}
    function caml_int64_or(x,y){return x.or(y)}
    function caml_lazy_make_forward(v){return [250,v]}
    function lor_digit_nat(nat1,ofs1,nat2,ofs2)
     {nat1.data[ofs1] |= nat2.data[ofs2];return 0}
    function caml_gr_blit_image(im,x,y)
     {var
       s=caml_gr_state_get(),
       im2=
        s.context.getImageData(x,s.height - im.height - y,im.width,im.height);
      for(var i=0;i < im2.data.length;i += 4)
       {im.data[i] = im2.data[i];
        im.data[i + 1] = im2.data[i + 1];
        im.data[i + 2] = im2.data[i + 2];
        im.data[i + 3] = im2.data[i + 3]}
      return 0}
    function caml_gr_window_id(a)
     {caml_failwith("caml_gr_window_id not Implemented")}
    function caml_js_on_ie()
     {var
       ua=
        joo_global_object.navigator?joo_global_object.navigator.userAgent:"";
      return ua.indexOf("MSIE") != - 1 && ua.indexOf("Opera") != 0}
    function caml_int64_shift_right(x,s){return x.shift_right(s)}
    function caml_ba_layout(ba){return ba.layout}
    function caml_convert_raw_backtrace(){return [0]}
    function caml_array_set(array,index,newval)
     {if(index < 0 || index >= array.length - 1)caml_array_bound_error();
      array[index + 1] = newval;
      return 0}
    function caml_bytes_greaterequal(s1,s2)
     {return caml_bytes_lessequal(s2,s1)}
    function set_digit_nat(nat,ofs,digit){nat.data[ofs] = digit;return 0}
    function caml_update_dummy(x,y)
     {if(typeof y === "function"){x.fun = y;return 0}
      if(y.fun){x.fun = y.fun;return 0}
      var i=y.length;
      while(i--)x[i] = y[i];
      return 0}
    function caml_CamlinternalMod_update_mod(shape,real,x)
     {if(typeof shape === "number")
       switch(shape){case 0:case 1:case 2:default:caml_update_dummy(real,x)}
      else
       switch(shape[0])
        {case 0:
          for(var i=1;i < shape[1].length;i++)
           caml_CamlinternalMod_update_mod(shape[1][i],real[i],x[i]);
          break
         }
      return 0}
    function caml_gr_doc_of_state(state)
     {if(state.canvas.ownerDocument)return state.canvas.ownerDocument}
    function caml_ml_output_int(chanid,i)
     {var
       arr=[i >> 24 & 0xFF,i >> 16 & 0xFF,i >> 8 & 0xFF,i & 0xFF],
       s=caml_string_of_array(arr);
      caml_ml_output(chanid,s,0,4);
      return 0}
    function caml_obj_with_tag(tag,x)
     {var l=x.length,a=new Array(l);
      a[0] = tag;
      for(var i=1;i < l;i++)a[i] = x[i];
      return a}
    function caml_ml_channel_size(chanid)
     {var chan=caml_ml_channels[chanid];return chan.file.length()}
    function caml_raw_backtrace_slot()
     {caml_invalid_argument
       ("Printexc.get_raw_backtrace_slot: index out of bounds")}
    function caml_hexstring_of_float(x,prec,style)
     {if(! isFinite(x))
       {if(isNaN(x))return caml_string_of_jsstring("nan");
        return caml_string_of_jsstring(x > 0?"infinity":"-infinity")}
      var sign=x == 0 && 1 / x == - Infinity?1:x >= 0?0:1;
      if(sign)x = - x;
      var exp=0;
      if(x == 0)
       ;
      else
       if(x < 1)
        while(x < 1 && exp > - 1022){x *= 2;exp--}
       else
        while(x >= 2){x /= 2;exp++}
      var exp_sign=exp < 0?"":"+",sign_str="";
      if(sign)
       sign_str = "-";
      else
       switch(style)
        {case 43:sign_str = "+";break;
         case 32:sign_str = " ";break;
         default:break}
      if(prec >= 0 && prec < 13)
       {var cst=Math.pow(2,prec * 4);x = Math.round(x * cst) / cst}
      var x_str=x.toString(16);
      if(prec >= 0)
       {var idx=x_str.indexOf(".");
        if(idx < 0)
         x_str += "." + caml_str_repeat(prec,"0");
        else
         {var size=idx + 1 + prec;
          if(x_str.length < size)
           x_str += caml_str_repeat(size - x_str.length,"0");
          else
           x_str = x_str.substr(0,size)}}
      return caml_string_of_jsstring
              (sign_str + "0x" + x_str + "p" + exp_sign + exp.toString(10))}
    function caml_js_wrap_meth_callback_strict(arity,f)
     {return function()
       {var args=new Array(arity + 1),len=Math.min(arguments.length,arity);
        args[0] = this;
        for(var i=0;i < len;i++)args[i + 1] = arguments[i];
        return caml_call_gen(f,args)}}
    function caml_backtrace_status(){return 0}
    function caml_install_signal_handler(){return 0}
    function caml_sys_argv(a){return caml_argv}
    function caml_ba_fill(ba,v){ba.fill(v);return 0}
    function caml_modf_float(x)
     {if(isFinite(x))
       {var neg=1 / x < 0;
        x = Math.abs(x);
        var i=Math.floor(x),f=x - i;
        if(neg){i = - i;f = - f}
        return [0,f,i]}
      if(isNaN(x))return [0,NaN,NaN];
      return [0,1 / x,x]}
    function caml_gc_get(){return [0,0,0,0,0,0,0,0,0]}
    function caml_float_compare(x,y)
     {if(x === y)return 0;
      if(x < y)return - 1;
      if(x > y)return 1;
      if(x === x)return 1;
      if(y === y)return - 1;
      return 0}
    function caml_string_set32(s,i,i32){return caml_bytes_set32(s,i,i32)}
    function caml_parse_engine(tables,env,cmd,arg)
     {var
       ERRCODE=256,
       loop=6,
       testshift=7,
       shift=8,
       shift_recover=9,
       reduce=10,
       READ_TOKEN=0,
       RAISE_PARSE_ERROR=1,
       GROW_STACKS_1=2,
       GROW_STACKS_2=3,
       COMPUTE_SEMANTIC_ACTION=4,
       CALL_ERROR_FUNCTION=5,
       env_s_stack=1,
       env_v_stack=2,
       env_symb_start_stack=3,
       env_symb_end_stack=4,
       env_stacksize=5,
       env_stackbase=6,
       env_curr_char=7,
       env_lval=8,
       env_symb_start=9,
       env_symb_end=10,
       env_asp=11,
       env_rule_len=12,
       env_rule_number=13,
       env_sp=14,
       env_state=15,
       env_errflag=16,
       tbl_transl_const=2,
       tbl_transl_block=3,
       tbl_lhs=4,
       tbl_len=5,
       tbl_defred=6,
       tbl_dgoto=7,
       tbl_sindex=8,
       tbl_rindex=9,
       tbl_gindex=10,
       tbl_tablesize=11,
       tbl_table=12,
       tbl_check=13;
      if(! tables.dgoto)
       {tables.defred = caml_lex_array(tables[tbl_defred]);
        tables.sindex = caml_lex_array(tables[tbl_sindex]);
        tables.check = caml_lex_array(tables[tbl_check]);
        tables.rindex = caml_lex_array(tables[tbl_rindex]);
        tables.table = caml_lex_array(tables[tbl_table]);
        tables.len = caml_lex_array(tables[tbl_len]);
        tables.lhs = caml_lex_array(tables[tbl_lhs]);
        tables.gindex = caml_lex_array(tables[tbl_gindex]);
        tables.dgoto = caml_lex_array(tables[tbl_dgoto])}
      var
       res=0,
       n,
       n1,
       n2,
       state1,
       sp=env[env_sp],
       state=env[env_state],
       errflag=env[env_errflag];
      exit:
      for(;;)
       switch(cmd)
        {case 0:state = 0;errflag = 0;
         case 6:
          n = tables.defred[state];
          if(n != 0){cmd = reduce;break}
          if(env[env_curr_char] >= 0){cmd = testshift;break}
          res = READ_TOKEN;
          break exit;
         case 1:
          if(arg instanceof Array)
           {env[env_curr_char] = tables[tbl_transl_block][arg[0] + 1];
            env[env_lval] = arg[1]}
          else
           {env[env_curr_char] = tables[tbl_transl_const][arg + 1];
            env[env_lval] = 0}
         case 7:
          n1 = tables.sindex[state];
          n2 = n1 + env[env_curr_char];
          if
           (n1
            !=
            0
            &&
            n2
            >=
            0
            &&
            n2
            <=
            tables[tbl_tablesize]
            &&
            tables.check[n2]
            ==
            env[env_curr_char])
           {cmd = shift;break}
          n1 = tables.rindex[state];
          n2 = n1 + env[env_curr_char];
          if
           (n1
            !=
            0
            &&
            n2
            >=
            0
            &&
            n2
            <=
            tables[tbl_tablesize]
            &&
            tables.check[n2]
            ==
            env[env_curr_char])
           {n = tables.table[n2];cmd = reduce;break}
          if(errflag <= 0){res = CALL_ERROR_FUNCTION;break exit}
         case 5:
          if(errflag < 3)
           {errflag = 3;
            for(;;)
             {state1 = env[env_s_stack][sp + 1];
              n1 = tables.sindex[state1];
              n2 = n1 + ERRCODE;
              if
               (n1
                !=
                0
                &&
                n2
                >=
                0
                &&
                n2
                <=
                tables[tbl_tablesize]
                &&
                tables.check[n2]
                ==
                ERRCODE)
               {cmd = shift_recover;break}
              else
               {if(sp <= env[env_stackbase])return RAISE_PARSE_ERROR;sp--}}}
          else
           {if(env[env_curr_char] == 0)return RAISE_PARSE_ERROR;
            env[env_curr_char] = - 1;
            cmd = loop;
            break}
         case 8:env[env_curr_char] = - 1;if(errflag > 0)errflag--;
         case 9:
          state = tables.table[n2];
          sp++;
          if(sp >= env[env_stacksize]){res = GROW_STACKS_1;break exit}
         case 2:
          env[env_s_stack][sp + 1] = state;
          env[env_v_stack][sp + 1] = env[env_lval];
          env[env_symb_start_stack][sp + 1] = env[env_symb_start];
          env[env_symb_end_stack][sp + 1] = env[env_symb_end];
          cmd = loop;
          break;
         case 10:
          var m=tables.len[n];
          env[env_asp] = sp;
          env[env_rule_number] = n;
          env[env_rule_len] = m;
          sp = sp - m + 1;
          m = tables.lhs[n];
          state1 = env[env_s_stack][sp];
          n1 = tables.gindex[m];
          n2 = n1 + state1;
          if
           (n1
            !=
            0
            &&
            n2
            >=
            0
            &&
            n2
            <=
            tables[tbl_tablesize]
            &&
            tables.check[n2]
            ==
            state1)
           state = tables.table[n2];
          else
           state = tables.dgoto[m];
          if(sp >= env[env_stacksize]){res = GROW_STACKS_2;break exit}
         case 3:res = COMPUTE_SEMANTIC_ACTION;break exit;
         case 4:
          env[env_s_stack][sp + 1] = state;
          env[env_v_stack][sp + 1] = arg;
          var asp=env[env_asp];
          env[env_symb_end_stack][sp + 1] = env[env_symb_end_stack][asp + 1];
          if(sp > asp)
           env[env_symb_start_stack][sp + 1]
           =
           env[env_symb_end_stack][asp + 1];
          cmd = loop;
          break;
         default:return RAISE_PARSE_ERROR}
      env[env_sp] = sp;
      env[env_state] = state;
      env[env_errflag] = errflag;
      return res}
    function caml_array_fill(array,ofs,len,v)
     {for(var i=0;i < len;i++)array[ofs + i + 1] = v;return 0}
    function caml_string_notequal(s1,s2){return 1 - caml_string_equal(s1,s2)}
    function caml_bytes_greaterthan(s1,s2){return caml_bytes_lessthan(s2,s1)}
    function caml_gr_make_image(arr)
     {var
       s=caml_gr_state_get(),
       h=arr.length - 1,
       w=arr[1].length - 1,
       im=s.context.createImageData(w,h);
      for(var i=0;i < h;i++)
       for(var j=0;j < w;j++)
        {var c=arr[i + 1][j + 1],o=i * (w * 4) + j * 4;
         if(c == - 1)
          {im.data[o + 0] = 0;
           im.data[o + 1] = 0;
           im.data[o + 2] = 0;
           im.data[o + 3] = 0}
         else
          {im.data[o + 0] = c >> 16 & 0xff;
           im.data[o + 1] = c >> 8 & 0xff;
           im.data[o + 2] = c >> 0 & 0Xff;
           im.data[o + 3] = 0xff}}
      return im}
    function caml_ml_set_channel_output(chanid,f)
     {var chan=caml_ml_channels[chanid];
      caml_global_data.fds[chan.fd].output = f;
      return 0}
    function caml_read_file_content(name)
     {var
       name=typeof name == "string"?caml_string_of_jsbytes(name):name,
       root=resolve_fs_device(name);
      if(root.device.exists(root.rest))
       {var
         file=root.device.open(root.rest,{rdonly:1}),
         len=file.length(),
         buf=caml_create_bytes(len);
        file.read(0,buf,0,len);
        return caml_string_of_bytes(buf)}
      caml_raise_no_such_file(name)}
    function caml_js_to_float(x){return x}
    joo_global_object.jsoo_runtime
    =
    {caml_ephe_check_data:caml_ephe_check_data,
     caml_ephe_unset_data:caml_ephe_unset_data,
     caml_ephe_set_data:caml_ephe_set_data,
     caml_ephe_get_data_copy:caml_ephe_get_data_copy,
     caml_ephe_get_data:caml_ephe_get_data,
     caml_ephe_blit_data:caml_ephe_blit_data,
     caml_ephe_unset_key:caml_ephe_unset_key,
     caml_ephe_set_key:caml_ephe_set_key,
     caml_ephe_check_key:caml_ephe_check_key,
     caml_ephe_get_key_copy:caml_ephe_get_key_copy,
     caml_ephe_get_key:caml_ephe_get_key,
     caml_ephe_blit_key:caml_ephe_blit_key,
     caml_ephe_create:caml_ephe_create,
     caml_weak_blit:caml_weak_blit,
     caml_weak_check:caml_weak_check,
     caml_weak_get_copy:caml_weak_get_copy,
     caml_weak_get:caml_weak_get,
     caml_weak_set:caml_weak_set,
     caml_weak_create:caml_weak_create,
     caml_ephe_data_offset:caml_ephe_data_offset,
     caml_ephe_key_offset:caml_ephe_key_offset,
     unix_isatty:unix_isatty,
     win_handle_fd:win_handle_fd,
     win_cleanup:win_cleanup,
     win_startup:win_startup,
     unix_mktime:unix_mktime,
     unix_localtime:unix_localtime,
     unix_gmtime:unix_gmtime,
     unix_time:unix_time,
     unix_gettimeofday:unix_gettimeofday,
     re_replacement_text:re_replacement_text,
     re_partial_match:re_partial_match,
     re_string_match:re_string_match,
     re_search_backward:re_search_backward,
     re_search_forward:re_search_forward,
     re_match:re_match,
     caml_spacetime_only_works_for_native_code:
     caml_spacetime_only_works_for_native_code,
     caml_register_channel_for_spacetime:caml_register_channel_for_spacetime,
     caml_sys_const_naked_pointers_checked:
     caml_sys_const_naked_pointers_checked,
     caml_spacetime_enabled:caml_spacetime_enabled,
     caml_ml_runtime_warnings_enabled:caml_ml_runtime_warnings_enabled,
     caml_ml_enable_runtime_warnings:caml_ml_enable_runtime_warnings,
     caml_runtime_warnings:caml_runtime_warnings,
     unix_inet_addr_of_string:unix_inet_addr_of_string,
     caml_install_signal_handler:caml_install_signal_handler,
     caml_runtime_parameters:caml_runtime_parameters,
     caml_runtime_variant:caml_runtime_variant,
     caml_sys_isatty:caml_sys_isatty,
     caml_sys_get_config:caml_sys_get_config,
     caml_sys_const_backend_type:caml_sys_const_backend_type,
     caml_sys_const_ostype_cygwin:caml_sys_const_ostype_cygwin,
     caml_sys_const_ostype_win32:caml_sys_const_ostype_win32,
     caml_sys_const_ostype_unix:caml_sys_const_ostype_unix,
     caml_sys_const_max_wosize:caml_sys_const_max_wosize,
     caml_sys_const_int_size:caml_sys_const_int_size,
     caml_sys_const_word_size:caml_sys_const_word_size,
     caml_sys_const_big_endian:caml_sys_const_big_endian,
     caml_sys_random_seed:caml_sys_random_seed,
     caml_sys_time_include_children:caml_sys_time_include_children,
     caml_sys_time:caml_sys_time,
     caml_sys_system_command:caml_sys_system_command,
     caml_sys_executable_name:caml_sys_executable_name,
     caml_sys_modify_argv:caml_sys_modify_argv,
     caml_sys_argv:caml_sys_argv,
     caml_sys_get_argv:caml_sys_get_argv,
     caml_executable_name:caml_executable_name,
     caml_argv:caml_argv,
     caml_sys_unsafe_getenv:caml_sys_unsafe_getenv,
     caml_sys_getenv:caml_sys_getenv,
     caml_set_static_env:caml_set_static_env,
     caml_sys_exit:caml_sys_exit,
     caml_raise_sys_error:caml_raise_sys_error,
     caml_is_printable:caml_is_printable,
     caml_get_global_data:caml_get_global_data,
     caml_register_global:caml_register_global,
     caml_global_data:caml_global_data,
     caml_named_value:caml_named_value,
     caml_register_named_value:caml_register_named_value,
     caml_named_values:caml_named_values,
     caml_call_gen:caml_call_gen,
     caml_set_parser_trace:caml_set_parser_trace,
     caml_parse_engine:caml_parse_engine,
     caml_obj_set_raw_field:caml_obj_set_raw_field,
     caml_obj_raw_field:caml_obj_raw_field,
     caml_fresh_oo_id:caml_fresh_oo_id,
     caml_set_oo_id:caml_set_oo_id,
     caml_oo_last_id:caml_oo_last_id,
     caml_get_public_method:caml_get_public_method,
     caml_lazy_make_forward:caml_lazy_make_forward,
     caml_obj_make_forward:caml_obj_make_forward,
     caml_obj_truncate:caml_obj_truncate,
     caml_obj_dup:caml_obj_dup,
     caml_obj_with_tag:caml_obj_with_tag,
     caml_obj_block:caml_obj_block,
     caml_obj_set_tag:caml_obj_set_tag,
     caml_obj_tag:caml_obj_tag,
     caml_obj_is_block:caml_obj_is_block,
     caml_update_dummy:caml_update_dummy,
     deserialize_nat:deserialize_nat,
     serialize_nat:serialize_nat,
     lxor_digit_nat:lxor_digit_nat,
     lor_digit_nat:lor_digit_nat,
     land_digit_nat:land_digit_nat,
     compare_nat_real:compare_nat_real,
     compare_nat:compare_nat,
     compare_digits_nat:compare_digits_nat,
     shift_right_nat:shift_right_nat,
     div_nat:div_nat,
     div_digit_nat:div_digit_nat,
     div_helper:div_helper,
     shift_left_nat:shift_left_nat,
     square_nat:square_nat,
     mult_nat:mult_nat,
     mult_digit_nat:mult_digit_nat,
     sub_nat:sub_nat,
     decr_nat:decr_nat,
     complement_nat:complement_nat,
     add_nat:add_nat,
     incr_nat:incr_nat,
     is_digit_odd:is_digit_odd,
     is_digit_zero:is_digit_zero,
     is_digit_int:is_digit_int,
     num_leading_zero_bits_in_digit:num_leading_zero_bits_in_digit,
     num_digits_nat:num_digits_nat,
     nth_digit_nat_native:nth_digit_nat_native,
     set_digit_nat_native:set_digit_nat_native,
     nth_digit_nat:nth_digit_nat,
     set_digit_nat:set_digit_nat,
     blit_nat:blit_nat,
     set_to_zero_nat:set_to_zero_nat,
     create_nat:create_nat,
     nat_of_array:nat_of_array,
     caml_hash_nat:caml_hash_nat,
     MlNat:MlNat,
     initialize_nat:initialize_nat,
     caml_js_to_string:caml_js_to_string,
     caml_to_js_string:caml_to_js_string,
     caml_js_from_string:caml_js_from_string,
     caml_new_string:caml_new_string,
     caml_js_to_byte_string:caml_js_to_byte_string,
     caml_is_ml_string:caml_is_ml_string,
     caml_is_ml_bytes:caml_is_ml_bytes,
     caml_string_of_jsstring:caml_string_of_jsstring,
     caml_jsstring_of_string:caml_jsstring_of_string,
     caml_jsbytes_of_string:caml_jsbytes_of_string,
     caml_string_of_jsbytes:caml_string_of_jsbytes,
     caml_bytes_of_string:caml_bytes_of_string,
     caml_string_of_bytes:caml_string_of_bytes,
     caml_string_lessthan:caml_string_lessthan,
     caml_string_lessequal:caml_string_lessequal,
     caml_string_equal:caml_string_equal,
     caml_string_compare:caml_string_compare,
     caml_ml_string_length:caml_ml_string_length,
     caml_string_unsafe_set:caml_string_unsafe_set,
     caml_string_unsafe_get:caml_string_unsafe_get,
     caml_bytes_of_jsbytes:caml_bytes_of_jsbytes,
     caml_ml_bytes_length:caml_ml_bytes_length,
     caml_blit_string:caml_blit_string,
     caml_blit_bytes:caml_blit_bytes,
     caml_fill_string:caml_fill_string,
     caml_fill_bytes:caml_fill_bytes,
     caml_bytes_greaterthan:caml_bytes_greaterthan,
     caml_string_greaterthan:caml_string_greaterthan,
     caml_bytes_greaterequal:caml_bytes_greaterequal,
     caml_string_greaterequal:caml_string_greaterequal,
     caml_bytes_lessthan:caml_bytes_lessthan,
     caml_bytes_lessequal:caml_bytes_lessequal,
     caml_bytes_notequal:caml_bytes_notequal,
     caml_string_notequal:caml_string_notequal,
     caml_bytes_equal:caml_bytes_equal,
     caml_bytes_compare:caml_bytes_compare,
     caml_bytes_of_array:caml_bytes_of_array,
     caml_string_of_array:caml_string_of_array,
     caml_create_bytes:caml_create_bytes,
     caml_create_string:caml_create_string,
     caml_array_of_string:caml_array_of_string,
     caml_array_of_bytes:caml_array_of_bytes,
     caml_convert_bytes_to_array:caml_convert_bytes_to_array,
     caml_convert_string_to_bytes:caml_convert_string_to_bytes,
     MlBytes:MlBytes,
     caml_bytes_of_utf16_jsstring:caml_bytes_of_utf16_jsstring,
     caml_bytes_set:caml_bytes_set,
     caml_string_set64:caml_string_set64,
     caml_bytes_set64:caml_bytes_set64,
     caml_string_set32:caml_string_set32,
     caml_bytes_set32:caml_bytes_set32,
     caml_string_set16:caml_string_set16,
     caml_bytes_set16:caml_bytes_set16,
     caml_string_set:caml_string_set,
     caml_bytes_get:caml_bytes_get,
     caml_bytes_get64:caml_bytes_get64,
     caml_string_get64:caml_string_get64,
     caml_bytes_get32:caml_bytes_get32,
     caml_string_get32:caml_string_get32,
     caml_bytes_get16:caml_bytes_get16,
     caml_string_get16:caml_string_get16,
     caml_string_get:caml_string_get,
     caml_bytes_bound_error:caml_bytes_bound_error,
     caml_string_bound_error:caml_string_bound_error,
     caml_bytes_unsafe_set:caml_bytes_unsafe_set,
     caml_bytes_unsafe_get:caml_bytes_unsafe_get,
     jsoo_is_ascii:jsoo_is_ascii,
     caml_utf16_of_utf8:caml_utf16_of_utf8,
     caml_utf8_of_utf16:caml_utf8_of_utf16,
     caml_subarray_to_jsbytes:caml_subarray_to_jsbytes,
     caml_str_repeat:caml_str_repeat,
     caml_md5_bytes:caml_md5_bytes,
     caml_md5_string:caml_md5_string,
     caml_md5_chan:caml_md5_chan,
     caml_output_value_to_buffer:caml_output_value_to_buffer,
     caml_output_value_to_bytes:caml_output_value_to_bytes,
     caml_output_value_to_string:caml_output_value_to_string,
     caml_output_val:caml_output_val,
     caml_legacy_custom_code:caml_legacy_custom_code,
     MlObjectTable:MlObjectTable,
     caml_marshal_data_size:caml_marshal_data_size,
     caml_input_value_from_reader:caml_input_value_from_reader,
     caml_custom_ops:caml_custom_ops,
     caml_nativeint_unmarshal:caml_nativeint_unmarshal,
     caml_int32_unmarshal:caml_int32_unmarshal,
     caml_int64_marshal:caml_int64_marshal,
     caml_int64_unmarshal:caml_int64_unmarshal,
     caml_input_value_from_bytes:caml_input_value_from_bytes,
     caml_input_value_from_string:caml_input_value_from_string,
     caml_float_of_bytes:caml_float_of_bytes,
     BigStringReader:BigStringReader,
     MlStringReader:MlStringReader,
     caml_marshal_constants:caml_marshal_constants,
     caml_new_lex_engine:caml_new_lex_engine,
     caml_lex_engine:caml_lex_engine,
     caml_lex_array:caml_lex_array,
     caml_xmlhttprequest_create:caml_xmlhttprequest_create,
     caml_js_export_var:caml_js_export_var,
     caml_js_object:caml_js_object,
     caml_pure_js_expr:caml_pure_js_expr,
     caml_js_expr:caml_js_expr,
     caml_js_eval_string:caml_js_eval_string,
     caml_js_equals:caml_js_equals,
     caml_js_wrap_meth_callback_unsafe:caml_js_wrap_meth_callback_unsafe,
     caml_js_wrap_meth_callback_strict:caml_js_wrap_meth_callback_strict,
     caml_js_wrap_meth_callback_arguments:caml_js_wrap_meth_callback_arguments,
     caml_js_wrap_meth_callback:caml_js_wrap_meth_callback,
     caml_js_wrap_callback_strict:caml_js_wrap_callback_strict,
     caml_js_wrap_callback_arguments:caml_js_wrap_callback_arguments,
     caml_js_wrap_callback:caml_js_wrap_callback,
     caml_ojs_new_arr:caml_ojs_new_arr,
     caml_js_new:caml_js_new,
     caml_js_meth_call:caml_js_meth_call,
     caml_js_fun_call:caml_js_fun_call,
     caml_js_call:caml_js_call,
     caml_js_var:caml_js_var,
     caml_list_to_js_array:caml_list_to_js_array,
     caml_list_of_js_array:caml_list_of_js_array,
     caml_js_to_array:caml_js_to_array,
     caml_js_from_array:caml_js_from_array,
     caml_js_to_float:caml_js_to_float,
     caml_js_from_float:caml_js_from_float,
     caml_js_to_bool:caml_js_to_bool,
     caml_js_from_bool:caml_js_from_bool,
     caml_js_error_of_exception:caml_js_error_of_exception,
     caml_exn_with_js_backtrace:caml_exn_with_js_backtrace,
     caml_wrap_exception:caml_wrap_exception,
     caml_is_js:caml_is_js,
     js_print_stderr:js_print_stderr,
     js_print_stdout:js_print_stdout,
     caml_trampoline_return:caml_trampoline_return,
     caml_trampoline:caml_trampoline,
     caml_js_get_console:caml_js_get_console,
     caml_js_html_entities:caml_js_html_entities,
     caml_js_html_escape:caml_js_html_escape,
     caml_js_on_ie:caml_js_on_ie,
     caml_js_typeof:caml_js_typeof,
     caml_js_instanceof:caml_js_instanceof,
     caml_js_delete:caml_js_delete,
     caml_js_get:caml_js_get,
     caml_js_set:caml_js_set,
     caml_js_pure_expr:caml_js_pure_expr,
     caml_ml_output_int:caml_ml_output_int,
     caml_ml_pos_out_64:caml_ml_pos_out_64,
     caml_ml_pos_out:caml_ml_pos_out,
     caml_ml_seek_out_64:caml_ml_seek_out_64,
     caml_ml_seek_out:caml_ml_seek_out,
     caml_output_value:caml_output_value,
     caml_ml_output_char:caml_ml_output_char,
     caml_ml_output:caml_ml_output,
     caml_ml_output_bytes:caml_ml_output_bytes,
     caml_ml_flush:caml_ml_flush,
     caml_ml_input_scan_line:caml_ml_input_scan_line,
     caml_ml_pos_in_64:caml_ml_pos_in_64,
     caml_ml_pos_in:caml_ml_pos_in,
     caml_ml_seek_in_64:caml_ml_seek_in_64,
     caml_ml_seek_in:caml_ml_seek_in,
     caml_ml_input_int:caml_ml_input_int,
     caml_ml_input_char:caml_ml_input_char,
     caml_input_value:caml_input_value,
     caml_ml_input:caml_ml_input,
     caml_ml_may_refill_input:caml_ml_may_refill_input,
     caml_ml_refill_input:caml_ml_refill_input,
     caml_ml_set_channel_refill:caml_ml_set_channel_refill,
     caml_ml_set_channel_output:caml_ml_set_channel_output,
     caml_ml_channel_size_64:caml_ml_channel_size_64,
     caml_ml_channel_size:caml_ml_channel_size,
     caml_ml_close_channel:caml_ml_close_channel,
     caml_ml_set_binary_mode:caml_ml_set_binary_mode,
     caml_channel_descriptor:caml_channel_descriptor,
     caml_ml_open_descriptor_in:caml_ml_open_descriptor_in,
     caml_ml_open_descriptor_out:caml_ml_open_descriptor_out,
     caml_ml_out_channels_list:caml_ml_out_channels_list,
     caml_ml_channels:caml_ml_channels,
     caml_ml_set_channel_name:caml_ml_set_channel_name,
     caml_sys_open:caml_sys_open,
     caml_std_output:caml_std_output,
     caml_sys_close:caml_sys_close,
     caml_int64_bswap:caml_int64_bswap,
     caml_int32_bswap:caml_int32_bswap,
     caml_bswap16:caml_bswap16,
     caml_mod:caml_mod,
     caml_div:caml_div,
     caml_mul:caml_mul,
     caml_int_of_string:caml_int_of_string,
     caml_parse_digit:caml_parse_digit,
     caml_parse_sign_and_base:caml_parse_sign_and_base,
     caml_format_int:caml_format_int,
     caml_CamlinternalMod_update_mod:caml_CamlinternalMod_update_mod,
     caml_CamlinternalMod_init_mod:caml_CamlinternalMod_init_mod,
     caml_int64_hash:caml_int64_hash,
     caml_int64_to_bytes:caml_int64_to_bytes,
     caml_int64_of_bytes:caml_int64_of_bytes,
     caml_int64_hi32:caml_int64_hi32,
     caml_int64_lo32:caml_int64_lo32,
     caml_int64_create_lo_hi:caml_int64_create_lo_hi,
     caml_int64_create_lo_mi_hi:caml_int64_create_lo_mi_hi,
     caml_int64_of_string:caml_int64_of_string,
     caml_int64_format:caml_int64_format,
     caml_int64_of_float:caml_int64_of_float,
     caml_int64_to_float:caml_int64_to_float,
     caml_int64_to_int32:caml_int64_to_int32,
     caml_int64_of_int32:caml_int64_of_int32,
     caml_int64_mod:caml_int64_mod,
     caml_int64_div:caml_int64_div,
     caml_int64_shift_right:caml_int64_shift_right,
     caml_int64_shift_right_unsigned:caml_int64_shift_right_unsigned,
     caml_int64_shift_left:caml_int64_shift_left,
     caml_int64_xor:caml_int64_xor,
     caml_int64_or:caml_int64_or,
     caml_int64_and:caml_int64_and,
     caml_int64_is_negative:caml_int64_is_negative,
     caml_int64_is_zero:caml_int64_is_zero,
     caml_int64_mul:caml_int64_mul,
     caml_int64_sub:caml_int64_sub,
     caml_int64_add:caml_int64_add,
     caml_int64_neg:caml_int64_neg,
     caml_int64_compare:caml_int64_compare,
     caml_int64_ult:caml_int64_ult,
     MlInt64:MlInt64,
     caml_int64_offset:caml_int64_offset,
     caml_float_of_string:caml_float_of_string,
     caml_format_float:caml_format_float,
     caml_round_float:caml_round_float,
     caml_tanh_float:caml_tanh_float,
     caml_sinh_float:caml_sinh_float,
     caml_cosh_float:caml_cosh_float,
     caml_log10_float:caml_log10_float,
     caml_hypot_float:caml_hypot_float,
     caml_log1p_float:caml_log1p_float,
     caml_expm1_float:caml_expm1_float,
     caml_signbit_float:caml_signbit_float,
     caml_copysign_float:caml_copysign_float,
     caml_float_compare:caml_float_compare,
     caml_frexp_float:caml_frexp_float,
     caml_ldexp_float:caml_ldexp_float,
     caml_modf_float:caml_modf_float,
     caml_classify_float:caml_classify_float,
     caml_int32_float_of_bits:caml_int32_float_of_bits,
     caml_trunc_float:caml_trunc_float,
     caml_nextafter_float:caml_nextafter_float,
     caml_int64_float_of_bits:caml_int64_float_of_bits,
     caml_hexstring_of_float:caml_hexstring_of_float,
     caml_int32_bits_of_float:caml_int32_bits_of_float,
     caml_int64_bits_of_float:caml_int64_bits_of_float,
     jsoo_floor_log2:jsoo_floor_log2,
     caml_hash:caml_hash,
     caml_hash_mix_string:caml_hash_mix_string,
     caml_hash_mix_bytes:caml_hash_mix_bytes,
     caml_hash_mix_bytes_arr:caml_hash_mix_bytes_arr,
     caml_hash_mix_jsbytes:caml_hash_mix_jsbytes,
     caml_hash_mix_int64:caml_hash_mix_int64,
     caml_hash_mix_float:caml_hash_mix_float,
     caml_hash_mix_final:caml_hash_mix_final,
     caml_hash_mix_int:caml_hash_mix_int,
     caml_hash_univ_param:caml_hash_univ_param,
     caml_gr_close_subwindow:caml_gr_close_subwindow,
     caml_gr_open_subwindow:caml_gr_open_subwindow,
     caml_gr_window_id:caml_gr_window_id,
     caml_gr_display_mode:caml_gr_display_mode,
     caml_gr_remember_mode:caml_gr_remember_mode,
     caml_gr_synchronize:caml_gr_synchronize,
     caml_gr_wait_event:caml_gr_wait_event,
     caml_gr_sigio_signal:caml_gr_sigio_signal,
     caml_gr_sigio_handler:caml_gr_sigio_handler,
     caml_gr_blit_image:caml_gr_blit_image,
     caml_gr_create_image:caml_gr_create_image,
     caml_gr_draw_image:caml_gr_draw_image,
     caml_gr_dump_image:caml_gr_dump_image,
     caml_gr_make_image:caml_gr_make_image,
     caml_gr_text_size:caml_gr_text_size,
     caml_gr_set_text_size:caml_gr_set_text_size,
     caml_gr_set_font:caml_gr_set_font,
     caml_gr_draw_string:caml_gr_draw_string,
     caml_gr_draw_char:caml_gr_draw_char,
     caml_gr_draw_str:caml_gr_draw_str,
     caml_gr_fill_arc:caml_gr_fill_arc,
     caml_gr_fill_poly:caml_gr_fill_poly,
     caml_gr_fill_rect:caml_gr_fill_rect,
     caml_gr_set_line_width:caml_gr_set_line_width,
     caml_gr_draw_arc:caml_gr_draw_arc,
     caml_gr_arc_aux:caml_gr_arc_aux,
     caml_gr_draw_rect:caml_gr_draw_rect,
     caml_gr_lineto:caml_gr_lineto,
     caml_gr_current_y:caml_gr_current_y,
     caml_gr_current_x:caml_gr_current_x,
     caml_gr_moveto:caml_gr_moveto,
     caml_gr_point_color:caml_gr_point_color,
     caml_gr_plot:caml_gr_plot,
     caml_gr_set_color:caml_gr_set_color,
     caml_gr_size_y:caml_gr_size_y,
     caml_gr_size_x:caml_gr_size_x,
     caml_gr_clear_graph:caml_gr_clear_graph,
     caml_gr_resize_window:caml_gr_resize_window,
     caml_gr_set_window_title:caml_gr_set_window_title,
     caml_gr_close_graph:caml_gr_close_graph,
     caml_gr_doc_of_state:caml_gr_doc_of_state,
     caml_gr_state_create:caml_gr_state_create,
     caml_gr_state_init:caml_gr_state_init,
     caml_gr_open_graph:caml_gr_open_graph,
     caml_gr_state_set:caml_gr_state_set,
     caml_gr_state_get:caml_gr_state_get,
     caml_gr_state:caml_gr_state,
     caml_memprof_stop:caml_memprof_stop,
     caml_memprof_start:caml_memprof_start,
     caml_final_release:caml_final_release,
     caml_final_register_called_without_value:
     caml_final_register_called_without_value,
     caml_final_register:caml_final_register,
     caml_memprof_set:caml_memprof_set,
     caml_gc_get:caml_gc_get,
     caml_gc_set:caml_gc_set,
     caml_gc_stat:caml_gc_stat,
     caml_gc_quick_stat:caml_gc_quick_stat,
     caml_gc_counters:caml_gc_counters,
     caml_gc_compaction:caml_gc_compaction,
     caml_gc_full_major:caml_gc_full_major,
     caml_gc_major:caml_gc_major,
     caml_gc_minor:caml_gc_minor,
     MlNodeFile:MlNodeFile,
     MlNodeDevice:MlNodeDevice,
     fs_node_supported:fs_node_supported,
     MlFakeFile:MlFakeFile,
     MlFakeDevice:MlFakeDevice,
     caml_read_file_content:caml_read_file_content,
     caml_create_file:caml_create_file,
     caml_fs_init:caml_fs_init,
     caml_create_file_extern:caml_create_file_extern,
     caml_ba_map_file_bytecode:caml_ba_map_file_bytecode,
     caml_ba_map_file:caml_ba_map_file,
     caml_sys_rename:caml_sys_rename,
     caml_sys_is_directory:caml_sys_is_directory,
     caml_sys_remove:caml_sys_remove,
     caml_sys_read_directory:caml_sys_read_directory,
     caml_sys_file_exists:caml_sys_file_exists,
     caml_raise_not_a_dir:caml_raise_not_a_dir,
     caml_raise_no_such_file:caml_raise_no_such_file,
     caml_sys_chdir:caml_sys_chdir,
     caml_sys_getcwd:caml_sys_getcwd,
     caml_unmount:caml_unmount,
     caml_mount_autoload:caml_mount_autoload,
     resolve_fs_device:resolve_fs_device,
     caml_list_mount_point:caml_list_mount_point,
     jsoo_mount_point:jsoo_mount_point,
     caml_make_path:caml_make_path,
     MlFile:MlFile,
     caml_root:caml_root,
     caml_current_dir:caml_current_dir,
     caml_finish_formatting:caml_finish_formatting,
     caml_parse_format:caml_parse_format,
     caml_array_bound_error:caml_array_bound_error,
     caml_raise_not_found:caml_raise_not_found,
     caml_raise_zero_divide:caml_raise_zero_divide,
     caml_raise_end_of_file:caml_raise_end_of_file,
     caml_invalid_argument:caml_invalid_argument,
     caml_failwith:caml_failwith,
     caml_raise_with_string:caml_raise_with_string,
     caml_raise_with_arg:caml_raise_with_arg,
     caml_return_exn_constant:caml_return_exn_constant,
     caml_raise_constant:caml_raise_constant,
     caml_lessthan:caml_lessthan,
     caml_lessequal:caml_lessequal,
     caml_greaterthan:caml_greaterthan,
     caml_greaterequal:caml_greaterequal,
     caml_notequal:caml_notequal,
     caml_equal:caml_equal,
     caml_int_compare:caml_int_compare,
     caml_compare:caml_compare,
     caml_compare_val:caml_compare_val,
     caml_compare_val_number_custom:caml_compare_val_number_custom,
     caml_compare_val_get_custom:caml_compare_val_get_custom,
     caml_compare_val_tag:caml_compare_val_tag,
     caml_blit_string_to_bigstring:caml_blit_string_to_bigstring,
     caml_blit_bigstring_to_string:caml_blit_bigstring_to_string,
     caml_blit_bigstring_to_bigstring:caml_blit_bigstring_to_bigstring,
     caml_bigstring_blit_ba_to_bytes:caml_bigstring_blit_ba_to_bytes,
     caml_bigstring_blit_bytes_to_ba:caml_bigstring_blit_bytes_to_ba,
     caml_bigstring_blit_string_to_ba:caml_bigstring_blit_string_to_ba,
     caml_bigstring_blit_ba_to_ba:caml_bigstring_blit_ba_to_ba,
     caml_bigstring_memcmp:caml_bigstring_memcmp,
     bigstring_of_typed_array:bigstring_of_typed_array,
     bigstring_of_array_buffer:bigstring_of_array_buffer,
     bigstring_to_typed_array:bigstring_to_typed_array,
     bigstring_to_array_buffer:bigstring_to_array_buffer,
     caml_hash_mix_bigstring:caml_hash_mix_bigstring,
     caml_ba_from_typed_array:caml_ba_from_typed_array,
     caml_ba_kind_of_typed_array:caml_ba_kind_of_typed_array,
     caml_ba_to_typed_array:caml_ba_to_typed_array,
     caml_ba_hash:caml_ba_hash,
     caml_ba_create_from:caml_ba_create_from,
     caml_ba_deserialize:caml_ba_deserialize,
     caml_ba_serialize:caml_ba_serialize,
     caml_ba_reshape:caml_ba_reshape,
     caml_ba_slice:caml_ba_slice,
     caml_ba_sub:caml_ba_sub,
     caml_ba_blit:caml_ba_blit,
     caml_ba_fill:caml_ba_fill,
     caml_ba_set_3:caml_ba_set_3,
     caml_ba_set_2:caml_ba_set_2,
     caml_ba_set_1:caml_ba_set_1,
     caml_ba_uint8_set64:caml_ba_uint8_set64,
     caml_ba_uint8_set32:caml_ba_uint8_set32,
     caml_ba_uint8_set16:caml_ba_uint8_set16,
     caml_ba_set_generic:caml_ba_set_generic,
     caml_ba_get_3:caml_ba_get_3,
     caml_ba_get_2:caml_ba_get_2,
     caml_ba_get_1:caml_ba_get_1,
     caml_ba_uint8_get64:caml_ba_uint8_get64,
     caml_ba_uint8_get32:caml_ba_uint8_get32,
     caml_ba_uint8_get16:caml_ba_uint8_get16,
     caml_ba_get_generic:caml_ba_get_generic,
     caml_ba_dim_3:caml_ba_dim_3,
     caml_ba_dim_2:caml_ba_dim_2,
     caml_ba_dim_1:caml_ba_dim_1,
     caml_ba_dim:caml_ba_dim,
     caml_ba_num_dims:caml_ba_num_dims,
     caml_ba_layout:caml_ba_layout,
     caml_ba_kind:caml_ba_kind,
     caml_ba_change_layout:caml_ba_change_layout,
     caml_ba_create:caml_ba_create,
     caml_ba_create_unsafe:caml_ba_create_unsafe,
     caml_ba_compare:caml_ba_compare,
     Ml_Bigarray_c_1_1:Ml_Bigarray_c_1_1,
     Ml_Bigarray:Ml_Bigarray,
     caml_ba_custom_name:caml_ba_custom_name,
     caml_ba_create_buffer:caml_ba_create_buffer,
     caml_ba_get_size_per_element:caml_ba_get_size_per_element,
     caml_ba_get_size:caml_ba_get_size,
     caml_ba_init:caml_ba_init,
     caml_convert_raw_backtrace_slot:caml_convert_raw_backtrace_slot,
     caml_get_current_callstack:caml_get_current_callstack,
     caml_restore_raw_backtrace:caml_restore_raw_backtrace,
     caml_raw_backtrace_slot:caml_raw_backtrace_slot,
     caml_raw_backtrace_next_slot:caml_raw_backtrace_next_slot,
     caml_raw_backtrace_length:caml_raw_backtrace_length,
     caml_convert_raw_backtrace:caml_convert_raw_backtrace,
     caml_record_backtrace:caml_record_backtrace,
     caml_get_exception_raw_backtrace:caml_get_exception_raw_backtrace,
     caml_get_exception_backtrace:caml_get_exception_backtrace,
     caml_backtrace_status:caml_backtrace_status,
     caml_ml_debug_info_status:caml_ml_debug_info_status,
     caml_floatarray_create:caml_floatarray_create,
     caml_make_float_vect:caml_make_float_vect,
     caml_make_vect:caml_make_vect,
     caml_check_bound:caml_check_bound,
     caml_array_fill:caml_array_fill,
     caml_array_get:caml_array_get,
     caml_array_set:caml_array_set,
     caml_floatarray_blit:caml_floatarray_blit,
     caml_array_blit:caml_array_blit,
     caml_array_concat:caml_array_concat,
     caml_array_append:caml_array_append,
     caml_array_sub:caml_array_sub};
    caml_fs_init();
    caml_register_global
     (0,[248,caml_string_of_jsbytes("Out_of_memory"),0],"Out_of_memory");
    caml_register_global
     (1,[248,caml_string_of_jsbytes("Sys_error"),-1],"Sys_error");
    caml_register_global
     (2,[248,caml_string_of_jsbytes("Failure"),-2],"Failure");
    caml_register_global
     (3,
      [248,caml_string_of_jsbytes("Invalid_argument"),-3],
      "Invalid_argument");
    caml_register_global
     (4,[248,caml_string_of_jsbytes("End_of_file"),-4],"End_of_file");
    caml_register_global
     (5,
      [248,caml_string_of_jsbytes("Division_by_zero"),-5],
      "Division_by_zero");
    caml_register_global
     (6,[248,caml_string_of_jsbytes("Not_found"),-6],"Not_found");
    caml_register_global
     (7,[248,caml_string_of_jsbytes("Match_failure"),-7],"Match_failure");
    caml_register_global
     (8,[248,caml_string_of_jsbytes("Stack_overflow"),-8],"Stack_overflow");
    caml_register_global
     (9,[248,caml_string_of_jsbytes("Sys_blocked_io"),-9],"Sys_blocked_io");
    caml_register_global
     (10,[248,caml_string_of_jsbytes("Assert_failure"),-10],"Assert_failure");
    caml_register_global
     (11,
      [248,caml_string_of_jsbytes("Undefined_recursive_module"),-11],
      "Undefined_recursive_module");
    return}
  (function(){return this}()));


//# 1 ".js/stdlib/stdlib.cma.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_array_concat=runtime.caml_array_concat,
     caml_array_get=runtime.caml_array_get,
     caml_array_set=runtime.caml_array_set,
     caml_array_sub=runtime.caml_array_sub,
     caml_ba_change_layout=runtime.caml_ba_change_layout,
     caml_ba_create=runtime.caml_ba_create,
     caml_ba_dim_1=runtime.caml_ba_dim_1,
     caml_ba_dim_2=runtime.caml_ba_dim_2,
     caml_ba_kind=runtime.caml_ba_kind,
     caml_ba_num_dims=runtime.caml_ba_num_dims,
     caml_ba_reshape=runtime.caml_ba_reshape,
     caml_ba_set_1=runtime.caml_ba_set_1,
     caml_ba_set_2=runtime.caml_ba_set_2,
     caml_ba_set_3=runtime.caml_ba_set_3,
     caml_ba_set_generic=runtime.caml_ba_set_generic,
     caml_ba_slice=runtime.caml_ba_slice,
     caml_blit_bytes=runtime.caml_blit_bytes,
     caml_blit_string=runtime.caml_blit_string,
     caml_bswap16=runtime.caml_bswap16,
     caml_bytes_get=runtime.caml_bytes_get,
     caml_bytes_get16=runtime.caml_bytes_get16,
     caml_bytes_get32=runtime.caml_bytes_get32,
     caml_bytes_get64=runtime.caml_bytes_get64,
     caml_bytes_of_string=runtime.caml_bytes_of_string,
     caml_bytes_set=runtime.caml_bytes_set,
     caml_bytes_set16=runtime.caml_bytes_set16,
     caml_bytes_set32=runtime.caml_bytes_set32,
     caml_bytes_set64=runtime.caml_bytes_set64,
     caml_bytes_unsafe_get=runtime.caml_bytes_unsafe_get,
     caml_bytes_unsafe_set=runtime.caml_bytes_unsafe_set,
     caml_check_bound=runtime.caml_check_bound,
     caml_compare=runtime.caml_compare,
     caml_create_bytes=runtime.caml_create_bytes,
     caml_div=runtime.caml_div,
     caml_ephe_set_key=runtime.caml_ephe_set_key,
     caml_ephe_unset_key=runtime.caml_ephe_unset_key,
     caml_equal=runtime.caml_equal,
     caml_fill_bytes=runtime.caml_fill_bytes,
     caml_float_compare=runtime.caml_float_compare,
     caml_float_of_string=runtime.caml_float_of_string,
     caml_floatarray_blit=runtime.caml_floatarray_blit,
     caml_floatarray_create=runtime.caml_floatarray_create,
     caml_format_float=runtime.caml_format_float,
     caml_format_int=runtime.caml_format_int,
     caml_fresh_oo_id=runtime.caml_fresh_oo_id,
     caml_get_exception_raw_backtra=runtime.caml_get_exception_raw_backtrace,
     caml_get_public_method=runtime.caml_get_public_method,
     caml_greaterequal=runtime.caml_greaterequal,
     caml_greaterthan=runtime.caml_greaterthan,
     caml_hash=runtime.caml_hash,
     caml_input_value=runtime.caml_input_value,
     caml_int32_bswap=runtime.caml_int32_bswap,
     caml_int64_add=runtime.caml_int64_add,
     caml_int64_bswap=runtime.caml_int64_bswap,
     caml_int64_compare=runtime.caml_int64_compare,
     caml_int64_float_of_bits=runtime.caml_int64_float_of_bits,
     caml_int64_format=runtime.caml_int64_format,
     caml_int64_mul=runtime.caml_int64_mul,
     caml_int64_of_int32=runtime.caml_int64_of_int32,
     caml_int64_of_string=runtime.caml_int64_of_string,
     caml_int64_or=runtime.caml_int64_or,
     caml_int64_shift_left=runtime.caml_int64_shift_left,
     caml_int64_sub=runtime.caml_int64_sub,
     caml_int_compare=runtime.caml_int_compare,
     caml_int_of_string=runtime.caml_int_of_string,
     caml_lessequal=runtime.caml_lessequal,
     caml_lessthan=runtime.caml_lessthan,
     caml_make_vect=runtime.caml_make_vect,
     caml_marshal_data_size=runtime.caml_marshal_data_size,
     caml_md5_string=runtime.caml_md5_string,
     caml_ml_bytes_length=runtime.caml_ml_bytes_length,
     caml_ml_channel_size=runtime.caml_ml_channel_size,
     caml_ml_channel_size_64=runtime.caml_ml_channel_size_64,
     caml_ml_close_channel=runtime.caml_ml_close_channel,
     caml_ml_flush=runtime.caml_ml_flush,
     caml_ml_input=runtime.caml_ml_input,
     caml_ml_input_char=runtime.caml_ml_input_char,
     caml_ml_open_descriptor_in=runtime.caml_ml_open_descriptor_in,
     caml_ml_open_descriptor_out=runtime.caml_ml_open_descriptor_out,
     caml_ml_output=runtime.caml_ml_output,
     caml_ml_output_bytes=runtime.caml_ml_output_bytes,
     caml_ml_output_char=runtime.caml_ml_output_char,
     caml_ml_set_binary_mode=runtime.caml_ml_set_binary_mode,
     caml_ml_set_channel_name=runtime.caml_ml_set_channel_name,
     caml_ml_string_length=runtime.caml_ml_string_length,
     caml_mod=runtime.caml_mod,
     caml_mul=runtime.caml_mul,
     caml_nextafter_float=runtime.caml_nextafter_float,
     caml_notequal=runtime.caml_notequal,
     caml_obj_block=runtime.caml_obj_block,
     caml_obj_make_forward=runtime.caml_obj_make_forward,
     caml_obj_tag=runtime.caml_obj_tag,
     caml_output_value=runtime.caml_output_value,
     caml_register_global=runtime.caml_register_global,
     caml_register_named_value=runtime.caml_register_named_value,
     caml_restore_raw_backtrace=runtime.caml_restore_raw_backtrace,
     caml_set_oo_id=runtime.caml_set_oo_id,
     caml_signbit_float=runtime.caml_signbit_float,
     caml_string_compare=runtime.caml_string_compare,
     caml_string_equal=runtime.caml_string_equal,
     caml_string_get=runtime.caml_string_get,
     caml_string_notequal=runtime.caml_string_notequal,
     caml_string_of_bytes=runtime.caml_string_of_bytes,
     caml_string_of_jsbytes=runtime.caml_string_of_jsbytes,
     caml_string_unsafe_get=runtime.caml_string_unsafe_get,
     caml_sys_argv=runtime.caml_sys_argv,
     caml_sys_getenv=runtime.caml_sys_getenv,
     caml_sys_open=runtime.caml_sys_open,
     caml_sys_random_seed=runtime.caml_sys_random_seed,
     caml_trampoline=runtime.caml_trampoline,
     caml_trampoline_return=runtime.caml_trampoline_return,
     caml_wrap_exception=runtime.caml_wrap_exception;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5
              ?f(a0,a1,a2,a3,a4)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4])}
    function caml_call7(f,a0,a1,a2,a3,a4,a5,a6)
     {return f.length == 7
              ?f(a0,a1,a2,a3,a4,a5,a6)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5,a6])}
    var
     global_data=runtime.caml_get_global_data(),
     cst$0=caml_string_of_jsbytes("%,"),
     cst_really_input=caml_string_of_jsbytes("really_input"),
     cst_input=caml_string_of_jsbytes("input"),
     cst_output_substring=caml_string_of_jsbytes("output_substring"),
     cst_output=caml_string_of_jsbytes("output"),
     cst_12g=caml_string_of_jsbytes("%.12g"),
     cst=caml_string_of_jsbytes("."),
     cst_false$1=caml_string_of_jsbytes("false"),
     cst_true$1=caml_string_of_jsbytes("true"),
     cst_false$0=caml_string_of_jsbytes("false"),
     cst_true$0=caml_string_of_jsbytes("true"),
     cst_bool_of_string=caml_string_of_jsbytes("bool_of_string"),
     cst_true=caml_string_of_jsbytes("true"),
     cst_false=caml_string_of_jsbytes("false"),
     cst_char_of_int=caml_string_of_jsbytes("char_of_int"),
     cst_Stdlib_Exit=caml_string_of_jsbytes("Stdlib.Exit"),
     cst_Stdlib_Pervasives_Exit=
      caml_string_of_jsbytes("Stdlib.Pervasives.Exit"),
     cst_option_is_None=caml_string_of_jsbytes("option is None"),
     cst_result_is_Ok=caml_string_of_jsbytes("result is Ok _"),
     cst_result_is_Error=caml_string_of_jsbytes("result is Error _"),
     cst_true$2=caml_string_of_jsbytes("true"),
     cst_false$2=caml_string_of_jsbytes("false"),
     cst$1=caml_string_of_jsbytes("\\\\"),
     cst$2=caml_string_of_jsbytes("\\'"),
     cst_b=caml_string_of_jsbytes("\\b"),
     cst_t=caml_string_of_jsbytes("\\t"),
     cst_n=caml_string_of_jsbytes("\\n"),
     cst_r=caml_string_of_jsbytes("\\r"),
     cst_Char_chr=caml_string_of_jsbytes("Char.chr"),
     cst_is_not_a_latin1_character=
      caml_string_of_jsbytes(" is not a latin1 character"),
     cst_04X=caml_string_of_jsbytes("%04X"),
     cst_U=caml_string_of_jsbytes("U+"),
     cst_is_not_an_Unicode_scalar_v=
      caml_string_of_jsbytes(" is not an Unicode scalar value"),
     cst_X=caml_string_of_jsbytes("%X"),
     err_no_pred=caml_string_of_jsbytes("U+0000 has no predecessor"),
     err_no_succ=caml_string_of_jsbytes("U+10FFFF has no successor"),
     cst_Stdlib_Sys_Break=caml_string_of_jsbytes("Stdlib.Sys.Break"),
     ocaml_version=caml_string_of_jsbytes("4.12.0"),
     cst_List_map2=caml_string_of_jsbytes("List.map2"),
     cst_List_iter2=caml_string_of_jsbytes("List.iter2"),
     cst_List_fold_left2=caml_string_of_jsbytes("List.fold_left2"),
     cst_List_fold_right2=caml_string_of_jsbytes("List.fold_right2"),
     cst_List_for_all2=caml_string_of_jsbytes("List.for_all2"),
     cst_List_exists2=caml_string_of_jsbytes("List.exists2"),
     cst_List_combine=caml_string_of_jsbytes("List.combine"),
     cst_List_rev_map2=caml_string_of_jsbytes("List.rev_map2"),
     cst_List_init=caml_string_of_jsbytes("List.init"),
     cst_List_nth$0=caml_string_of_jsbytes("List.nth"),
     cst_nth=caml_string_of_jsbytes("nth"),
     cst_List_nth=caml_string_of_jsbytes("List.nth"),
     cst_tl=caml_string_of_jsbytes("tl"),
     cst_hd=caml_string_of_jsbytes("hd"),
     cst_Bytes_of_seq_cannot_grow_b=
      caml_string_of_jsbytes("Bytes.of_seq: cannot grow bytes"),
     cst_String_rcontains_from_Byte=
      caml_string_of_jsbytes("String.rcontains_from / Bytes.rcontains_from"),
     cst_String_contains_from_Bytes=
      caml_string_of_jsbytes("String.contains_from / Bytes.contains_from"),
     cst_String_rindex_from_opt_Byt=
      caml_string_of_jsbytes("String.rindex_from_opt / Bytes.rindex_from_opt"),
     cst_String_rindex_from_Bytes_r=
      caml_string_of_jsbytes("String.rindex_from / Bytes.rindex_from"),
     cst_String_index_from_opt_Byte=
      caml_string_of_jsbytes("String.index_from_opt / Bytes.index_from_opt"),
     cst_String_index_from_Bytes_in=
      caml_string_of_jsbytes("String.index_from / Bytes.index_from"),
     cst_Bytes_concat=caml_string_of_jsbytes("Bytes.concat"),
     cst_String_blit_Bytes_blit_str=
      caml_string_of_jsbytes("String.blit / Bytes.blit_string"),
     cst_Bytes_blit=caml_string_of_jsbytes("Bytes.blit"),
     cst_String_fill_Bytes_fill=
      caml_string_of_jsbytes("String.fill / Bytes.fill"),
     cst_Bytes_extend=caml_string_of_jsbytes("Bytes.extend"),
     cst_String_sub_Bytes_sub=caml_string_of_jsbytes("String.sub / Bytes.sub"),
     cst_String_rcontains_from_Byte$0=
      caml_string_of_jsbytes("String.rcontains_from / Bytes.rcontains_from"),
     cst_String_contains_from_Bytes$0=
      caml_string_of_jsbytes("String.contains_from / Bytes.contains_from"),
     cst_String_rindex_from_opt_Byt$0=
      caml_string_of_jsbytes("String.rindex_from_opt / Bytes.rindex_from_opt"),
     cst_String_rindex_from_Bytes_r$0=
      caml_string_of_jsbytes("String.rindex_from / Bytes.rindex_from"),
     cst_String_index_from_opt_Byte$0=
      caml_string_of_jsbytes("String.index_from_opt / Bytes.index_from_opt"),
     cst_String_index_from_Bytes_in$0=
      caml_string_of_jsbytes("String.index_from / Bytes.index_from"),
     cst$4=caml_string_of_jsbytes(""),
     cst$3=caml_string_of_jsbytes(""),
     cst_String_concat=caml_string_of_jsbytes("String.concat"),
     cst$5=caml_string_of_jsbytes("()"),
     cst_Marshal_from_bytes=caml_string_of_jsbytes("Marshal.from_bytes"),
     cst_Marshal_from_bytes$0=caml_string_of_jsbytes("Marshal.from_bytes"),
     cst_Marshal_data_size=caml_string_of_jsbytes("Marshal.data_size"),
     cst_Marshal_to_buffer_substrin=
      caml_string_of_jsbytes("Marshal.to_buffer: substring out of bounds"),
     cst_Obj_Ephemeron_blit_key=
      caml_string_of_jsbytes("Obj.Ephemeron.blit_key"),
     cst_Obj_Ephemeron_check_key=
      caml_string_of_jsbytes("Obj.Ephemeron.check_key"),
     cst_Obj_Ephemeron_unset_key=
      caml_string_of_jsbytes("Obj.Ephemeron.unset_key"),
     cst_Obj_Ephemeron_set_key=caml_string_of_jsbytes("Obj.Ephemeron.set_key"),
     cst_Obj_Ephemeron_get_key_copy=
      caml_string_of_jsbytes("Obj.Ephemeron.get_key_copy"),
     cst_Obj_Ephemeron_get_key=caml_string_of_jsbytes("Obj.Ephemeron.get_key"),
     cst_Obj_Ephemeron_create=caml_string_of_jsbytes("Obj.Ephemeron.create"),
     cst_Obj_extension_constructor$0=
      caml_string_of_jsbytes("Obj.extension_constructor"),
     cst_Obj_extension_constructor=
      caml_string_of_jsbytes("Obj.extension_constructor"),
     cst_Array_exists2=caml_string_of_jsbytes("Array.exists2"),
     cst_Array_for_all2=caml_string_of_jsbytes("Array.for_all2"),
     cst_Array_map2_arrays_must_hav=
      caml_string_of_jsbytes("Array.map2: arrays must have the same length"),
     cst_Array_iter2_arrays_must_ha=
      caml_string_of_jsbytes("Array.iter2: arrays must have the same length"),
     cst_Array_blit=caml_string_of_jsbytes("Array.blit"),
     cst_Array_fill=caml_string_of_jsbytes("Array.fill"),
     cst_Array_sub=caml_string_of_jsbytes("Array.sub"),
     cst_Array_init=caml_string_of_jsbytes("Array.init"),
     cst_Stdlib_Array_Bottom=caml_string_of_jsbytes("Stdlib.Array.Bottom"),
     cst_Float_Array_map2_arrays_mu=
      caml_string_of_jsbytes
       ("Float.Array.map2: arrays must have the same length"),
     cst_Float_Array_iter2_arrays_m=
      caml_string_of_jsbytes
       ("Float.Array.iter2: arrays must have the same length"),
     cst_Float_array_blit=caml_string_of_jsbytes("Float.array.blit"),
     cst_Float_array_blit$0=caml_string_of_jsbytes("Float.array.blit"),
     cst_Float_Array_fill=caml_string_of_jsbytes("Float.Array.fill"),
     cst_Float_Array_sub=caml_string_of_jsbytes("Float.Array.sub"),
     cst_Float_Array_concat=caml_string_of_jsbytes("Float.Array.concat"),
     cst_Float_Array_init=caml_string_of_jsbytes("Float.Array.init"),
     cst_Stdlib_Float_Array_Bottom=
      caml_string_of_jsbytes("Stdlib.Float.Array.Bottom"),
     cst_d=caml_string_of_jsbytes("%d"),
     cst_d$0=caml_string_of_jsbytes("%d"),
     zero$2=runtime.caml_int64_create_lo_mi_hi(0,0,0),
     one$2=runtime.caml_int64_create_lo_mi_hi(1,0,0),
     minus_one$2=runtime.caml_int64_create_lo_mi_hi(16777215,16777215,65535),
     min_int$2=runtime.caml_int64_create_lo_mi_hi(0,0,32768),
     max_int$2=runtime.caml_int64_create_lo_mi_hi(16777215,16777215,32767),
     cst_d$1=caml_string_of_jsbytes("%d"),
     cst_Lexing_lex_refill_cannot_g=
      caml_string_of_jsbytes("Lexing.lex_refill: cannot grow buffer"),
     dummy_pos=[0,caml_string_of_jsbytes(""),0,0,-1],
     zero_pos=[0,caml_string_of_jsbytes(""),1,0,0],
     cst_syntax_error=caml_string_of_jsbytes("syntax error"),
     cst_Stdlib_Parsing_YYexit=caml_string_of_jsbytes("Stdlib.Parsing.YYexit"),
     cst_Stdlib_Parsing_Parse_error=
      caml_string_of_jsbytes("Stdlib.Parsing.Parse_error"),
     cst_Set_remove_min_elt=caml_string_of_jsbytes("Set.remove_min_elt"),
     cst_Set_bal=caml_string_of_jsbytes("Set.bal"),
     cst_Set_bal$0=caml_string_of_jsbytes("Set.bal"),
     cst_Set_bal$1=caml_string_of_jsbytes("Set.bal"),
     cst_Set_bal$2=caml_string_of_jsbytes("Set.bal"),
     cst_Map_remove_min_elt=caml_string_of_jsbytes("Map.remove_min_elt"),
     cst_Map_bal=caml_string_of_jsbytes("Map.bal"),
     cst_Map_bal$0=caml_string_of_jsbytes("Map.bal"),
     cst_Map_bal$1=caml_string_of_jsbytes("Map.bal"),
     cst_Map_bal$2=caml_string_of_jsbytes("Map.bal"),
     cst_Stdlib_Stack_Empty=caml_string_of_jsbytes("Stdlib.Stack.Empty"),
     cst_Stdlib_Queue_Empty=caml_string_of_jsbytes("Stdlib.Queue.Empty"),
     cst_CamlinternalLazy_Undefined=
      caml_string_of_jsbytes("CamlinternalLazy.Undefined"),
     cst_count=caml_string_of_jsbytes("{count = "),
     cst_data=caml_string_of_jsbytes("; data = "),
     cst$6=caml_string_of_jsbytes("}"),
     cst_Sempty=caml_string_of_jsbytes("Sempty"),
     cst_Scons=caml_string_of_jsbytes("Scons ("),
     cst$7=caml_string_of_jsbytes(", "),
     cst$8=caml_string_of_jsbytes(")"),
     cst_Sapp=caml_string_of_jsbytes("Sapp ("),
     cst$9=caml_string_of_jsbytes(", "),
     cst$10=caml_string_of_jsbytes(")"),
     cst_Slazy=caml_string_of_jsbytes("Slazy"),
     cst_Sgen=caml_string_of_jsbytes("Sgen"),
     cst_Sbuffio=caml_string_of_jsbytes("Sbuffio"),
     cst_Stdlib_Stream_Failure=caml_string_of_jsbytes("Stdlib.Stream.Failure"),
     cst_Stdlib_Stream_Error=caml_string_of_jsbytes("Stdlib.Stream.Error"),
     cst_Buffer_truncate=caml_string_of_jsbytes("Buffer.truncate"),
     cst_Buffer_add_channel=caml_string_of_jsbytes("Buffer.add_channel"),
     cst_Buffer_add_substring_add_s=
      caml_string_of_jsbytes("Buffer.add_substring/add_subbytes"),
     cst_Buffer_add_cannot_grow_buf=
      caml_string_of_jsbytes("Buffer.add: cannot grow buffer"),
     cst_Buffer_nth=caml_string_of_jsbytes("Buffer.nth"),
     cst_Buffer_blit=caml_string_of_jsbytes("Buffer.blit"),
     cst_Buffer_sub=caml_string_of_jsbytes("Buffer.sub"),
     cst_c=caml_string_of_jsbytes("%c"),
     cst_s=caml_string_of_jsbytes("%s"),
     cst_i=caml_string_of_jsbytes("%i"),
     cst_li=caml_string_of_jsbytes("%li"),
     cst_ni=caml_string_of_jsbytes("%ni"),
     cst_Li=caml_string_of_jsbytes("%Li"),
     cst_f=caml_string_of_jsbytes("%f"),
     cst_B=caml_string_of_jsbytes("%B"),
     cst$21=caml_string_of_jsbytes("%{"),
     cst$22=caml_string_of_jsbytes("%}"),
     cst$23=caml_string_of_jsbytes("%("),
     cst$24=caml_string_of_jsbytes("%)"),
     cst_a=caml_string_of_jsbytes("%a"),
     cst_t$0=caml_string_of_jsbytes("%t"),
     cst$25=caml_string_of_jsbytes("%?"),
     cst_r$0=caml_string_of_jsbytes("%r"),
     cst_r$1=caml_string_of_jsbytes("%_r"),
     cst_u$0=caml_string_of_jsbytes("%u"),
     cst_Printf_bad_conversion=
      caml_string_of_jsbytes("Printf: bad conversion %["),
     cst_Printf_bad_conversion$0=
      caml_string_of_jsbytes("Printf: bad conversion %_"),
     cst$30=caml_string_of_jsbytes("@{"),
     cst$31=caml_string_of_jsbytes("@["),
     cst$32=caml_string_of_jsbytes("@{"),
     cst$33=caml_string_of_jsbytes("@["),
     cst$34=caml_string_of_jsbytes("@{"),
     cst$35=caml_string_of_jsbytes("@["),
     cst_0=caml_string_of_jsbytes("0"),
     cst_padding=caml_string_of_jsbytes("padding"),
     cst_precision=caml_string_of_jsbytes("precision"),
     cst$40=caml_string_of_jsbytes("'*'"),
     cst$38=caml_string_of_jsbytes("'-'"),
     cst_0$2=caml_string_of_jsbytes("'0'"),
     cst$39=caml_string_of_jsbytes("'*'"),
     cst_0$0=caml_string_of_jsbytes("0"),
     cst_0$1=caml_string_of_jsbytes("0"),
     cst_precision$0=caml_string_of_jsbytes("precision"),
     cst_precision$1=caml_string_of_jsbytes("precision"),
     cst$41=caml_string_of_jsbytes("'+'"),
     cst$42=caml_string_of_jsbytes("'#'"),
     cst$43=caml_string_of_jsbytes("' '"),
     cst_padding$0=caml_string_of_jsbytes("`padding'"),
     cst_precision$2=caml_string_of_jsbytes("`precision'"),
     cst$44=caml_string_of_jsbytes("'+'"),
     cst$45=caml_string_of_jsbytes("'_'"),
     sub_format=[0,0,caml_string_of_jsbytes("")],
     formatting_lit=[0,caml_string_of_jsbytes("@;"),1,0],
     cst_digit=caml_string_of_jsbytes("digit"),
     cst_character=caml_string_of_jsbytes("character ')'"),
     cst_character$0=caml_string_of_jsbytes("character '}'"),
     cst$49=caml_string_of_jsbytes("'#'"),
     cst$46=caml_string_of_jsbytes("'+'"),
     cst$47=caml_string_of_jsbytes("'+'"),
     cst$48=caml_string_of_jsbytes("' '"),
     cst$50=caml_string_of_jsbytes("'+'"),
     cst_non_zero_widths_are_unsupp=
      caml_string_of_jsbytes
       ("non-zero widths are unsupported for %c conversions"),
     cst_unexpected_end_of_format=
      caml_string_of_jsbytes("unexpected end of format"),
     cst$36=caml_string_of_jsbytes(""),
     cst$37=caml_string_of_jsbytes(""),
     cst_b$0=caml_string_of_jsbytes("b"),
     cst_h=caml_string_of_jsbytes("h"),
     cst_hov=caml_string_of_jsbytes("hov"),
     cst_hv=caml_string_of_jsbytes("hv"),
     cst_v=caml_string_of_jsbytes("v"),
     cst_nan=caml_string_of_jsbytes("nan"),
     cst_neg_infinity=caml_string_of_jsbytes("neg_infinity"),
     cst_infinity=caml_string_of_jsbytes("infinity"),
     cst$29=caml_string_of_jsbytes("."),
     cst_nd$0=caml_string_of_jsbytes("%+nd"),
     cst_nd$1=caml_string_of_jsbytes("% nd"),
     cst_ni$1=caml_string_of_jsbytes("%+ni"),
     cst_ni$2=caml_string_of_jsbytes("% ni"),
     cst_nx=caml_string_of_jsbytes("%nx"),
     cst_nx$0=caml_string_of_jsbytes("%#nx"),
     cst_nX=caml_string_of_jsbytes("%nX"),
     cst_nX$0=caml_string_of_jsbytes("%#nX"),
     cst_no=caml_string_of_jsbytes("%no"),
     cst_no$0=caml_string_of_jsbytes("%#no"),
     cst_nd=caml_string_of_jsbytes("%nd"),
     cst_ni$0=caml_string_of_jsbytes("%ni"),
     cst_nu=caml_string_of_jsbytes("%nu"),
     cst_ld$0=caml_string_of_jsbytes("%+ld"),
     cst_ld$1=caml_string_of_jsbytes("% ld"),
     cst_li$1=caml_string_of_jsbytes("%+li"),
     cst_li$2=caml_string_of_jsbytes("% li"),
     cst_lx=caml_string_of_jsbytes("%lx"),
     cst_lx$0=caml_string_of_jsbytes("%#lx"),
     cst_lX=caml_string_of_jsbytes("%lX"),
     cst_lX$0=caml_string_of_jsbytes("%#lX"),
     cst_lo=caml_string_of_jsbytes("%lo"),
     cst_lo$0=caml_string_of_jsbytes("%#lo"),
     cst_ld=caml_string_of_jsbytes("%ld"),
     cst_li$0=caml_string_of_jsbytes("%li"),
     cst_lu=caml_string_of_jsbytes("%lu"),
     cst_Ld$0=caml_string_of_jsbytes("%+Ld"),
     cst_Ld$1=caml_string_of_jsbytes("% Ld"),
     cst_Li$1=caml_string_of_jsbytes("%+Li"),
     cst_Li$2=caml_string_of_jsbytes("% Li"),
     cst_Lx=caml_string_of_jsbytes("%Lx"),
     cst_Lx$0=caml_string_of_jsbytes("%#Lx"),
     cst_LX=caml_string_of_jsbytes("%LX"),
     cst_LX$0=caml_string_of_jsbytes("%#LX"),
     cst_Lo=caml_string_of_jsbytes("%Lo"),
     cst_Lo$0=caml_string_of_jsbytes("%#Lo"),
     cst_Ld=caml_string_of_jsbytes("%Ld"),
     cst_Li$0=caml_string_of_jsbytes("%Li"),
     cst_Lu=caml_string_of_jsbytes("%Lu"),
     cst_d$3=caml_string_of_jsbytes("%+d"),
     cst_d$4=caml_string_of_jsbytes("% d"),
     cst_i$1=caml_string_of_jsbytes("%+i"),
     cst_i$2=caml_string_of_jsbytes("% i"),
     cst_x=caml_string_of_jsbytes("%x"),
     cst_x$0=caml_string_of_jsbytes("%#x"),
     cst_X$0=caml_string_of_jsbytes("%X"),
     cst_X$1=caml_string_of_jsbytes("%#X"),
     cst_o=caml_string_of_jsbytes("%o"),
     cst_o$0=caml_string_of_jsbytes("%#o"),
     cst_d$2=caml_string_of_jsbytes("%d"),
     cst_i$0=caml_string_of_jsbytes("%i"),
     cst_u=caml_string_of_jsbytes("%u"),
     cst$26=caml_string_of_jsbytes("%!"),
     cst$27=caml_string_of_jsbytes("@{"),
     cst$28=caml_string_of_jsbytes("@["),
     cst_0c=caml_string_of_jsbytes("0c"),
     cst$20=caml_string_of_jsbytes("%%"),
     cst$12=caml_string_of_jsbytes("@]"),
     cst$13=caml_string_of_jsbytes("@}"),
     cst$14=caml_string_of_jsbytes("@?"),
     cst$15=caml_string_of_jsbytes("@\n"),
     cst$16=caml_string_of_jsbytes("@."),
     cst$17=caml_string_of_jsbytes("@@"),
     cst$18=caml_string_of_jsbytes("@%"),
     cst$19=caml_string_of_jsbytes("@"),
     cst$11=caml_string_of_jsbytes(".*"),
     cst_CamlinternalFormat_Type_mi=
      caml_string_of_jsbytes("CamlinternalFormat.Type_mismatch"),
     cst$58=caml_string_of_jsbytes(""),
     cst$59=caml_string_of_jsbytes("\n"),
     cst_a_boolean=caml_string_of_jsbytes("a boolean"),
     cst_an_integer=caml_string_of_jsbytes("an integer"),
     cst_an_integer$0=caml_string_of_jsbytes("an integer"),
     cst_a_float=caml_string_of_jsbytes("a float"),
     cst_a_float$0=caml_string_of_jsbytes("a float"),
     cst$55=caml_string_of_jsbytes(""),
     cst$56=caml_string_of_jsbytes(" "),
     cst$57=caml_string_of_jsbytes(""),
     cst_one_of=caml_string_of_jsbytes("one of: "),
     cst_Arg_Expand_is_is_only_allo=
      caml_string_of_jsbytes
       ("Arg.Expand is is only allowed with Arg.parse_and_expand_argv_dynamic"),
     cst_no_argument=caml_string_of_jsbytes("no argument"),
     cst$54=caml_string_of_jsbytes("(?)"),
     cst_help$3=caml_string_of_jsbytes("--help"),
     cst_help$4=caml_string_of_jsbytes("-help"),
     cst_help$2=caml_string_of_jsbytes("-help"),
     cst_Display_this_list_of_optio=
      caml_string_of_jsbytes(" Display this list of options"),
     cst_help=caml_string_of_jsbytes("-help"),
     cst_help$1=caml_string_of_jsbytes("--help"),
     cst_Display_this_list_of_optio$0=
      caml_string_of_jsbytes(" Display this list of options"),
     cst_help$0=caml_string_of_jsbytes("--help"),
     cst$51=caml_string_of_jsbytes("}"),
     cst$52=caml_string_of_jsbytes("|"),
     cst$53=caml_string_of_jsbytes("{"),
     cst_none=caml_string_of_jsbytes("<none>"),
     cst_Stdlib_Arg_Bad=caml_string_of_jsbytes("Stdlib.Arg.Bad"),
     cst_Stdlib_Arg_Help=caml_string_of_jsbytes("Stdlib.Arg.Help"),
     cst_Stdlib_Arg_Stop=caml_string_of_jsbytes("Stdlib.Arg.Stop"),
     cst$61=caml_string_of_jsbytes(""),
     cst$65=caml_string_of_jsbytes(""),
     cst_Program_not_linked_with_g_=
      caml_string_of_jsbytes
       ("(Program not linked with -g, cannot print stack backtrace)\n"),
     cst_Raised_at=caml_string_of_jsbytes("Raised at"),
     cst_Re_raised_at=caml_string_of_jsbytes("Re-raised at"),
     cst_Raised_by_primitive_operat=
      caml_string_of_jsbytes("Raised by primitive operation at"),
     cst_Called_from=caml_string_of_jsbytes("Called from"),
     cst_inlined=caml_string_of_jsbytes(" (inlined)"),
     cst$64=caml_string_of_jsbytes(""),
     partial=[4,0,0,0,[12,45,[4,0,0,0,0]]],
     cst_Out_of_memory=caml_string_of_jsbytes("Out of memory"),
     cst_Stack_overflow=caml_string_of_jsbytes("Stack overflow"),
     cst_Pattern_matching_failed=
      caml_string_of_jsbytes("Pattern matching failed"),
     cst_Assertion_failed=caml_string_of_jsbytes("Assertion failed"),
     cst_Undefined_recursive_module=
      caml_string_of_jsbytes("Undefined recursive module"),
     cst$62=caml_string_of_jsbytes(""),
     cst$63=caml_string_of_jsbytes(""),
     cst$60=caml_string_of_jsbytes("_"),
     locfmt=
      [0,
       [11,
        caml_string_of_jsbytes('File "'),
        [2,
         0,
         [11,
          caml_string_of_jsbytes('", line '),
          [4,
           0,
           0,
           0,
           [11,
            caml_string_of_jsbytes(", characters "),
            [4,
             0,
             0,
             0,
             [12,45,[4,0,0,0,[11,caml_string_of_jsbytes(": "),[2,0,0]]]]]]]]]],
       caml_string_of_jsbytes('File "%s", line %d, characters %d-%d: %s')],
     cst_Fun_Finally_raised=caml_string_of_jsbytes("Fun.Finally_raised: "),
     cst_Stdlib_Fun_Finally_raised=
      caml_string_of_jsbytes("Stdlib.Fun.Finally_raised"),
     cst_Digest_from_hex$0=caml_string_of_jsbytes("Digest.from_hex"),
     cst_Digest_from_hex=caml_string_of_jsbytes("Digest.from_hex"),
     cst_Digest_to_hex=caml_string_of_jsbytes("Digest.to_hex"),
     cst_Digest_substring=caml_string_of_jsbytes("Digest.substring"),
     cst_Random_int64=caml_string_of_jsbytes("Random.int64"),
     cst_Random_int32=caml_string_of_jsbytes("Random.int32"),
     cst_Random_int=caml_string_of_jsbytes("Random.int"),
     cst_x$1=caml_string_of_jsbytes("x"),
     cst_Hashtbl_unsupported_hash_t=
      caml_string_of_jsbytes("Hashtbl: unsupported hash table format"),
     cst_OCAMLRUNPARAM=caml_string_of_jsbytes("OCAMLRUNPARAM"),
     cst_CAMLRUNPARAM=caml_string_of_jsbytes("CAMLRUNPARAM"),
     cst$66=caml_string_of_jsbytes(""),
     cst_Weak_Make_hash_bucket_cann=
      caml_string_of_jsbytes("Weak.Make: hash bucket cannot grow more"),
     cst_Weak_fill=caml_string_of_jsbytes("Weak.fill"),
     cst_Weak_blit=caml_string_of_jsbytes("Weak.blit"),
     cst_Weak_check=caml_string_of_jsbytes("Weak.check"),
     cst_Weak_get_copy=caml_string_of_jsbytes("Weak.get_copy"),
     cst_Weak_get=caml_string_of_jsbytes("Weak.get"),
     cst_Weak_set=caml_string_of_jsbytes("Weak.set"),
     cst_Weak_create=caml_string_of_jsbytes("Weak.create"),
     cst$84=caml_string_of_jsbytes(""),
     cst$85=caml_string_of_jsbytes(""),
     cst$83=caml_string_of_jsbytes("."),
     cst$80=caml_string_of_jsbytes(">"),
     cst$81=caml_string_of_jsbytes("<\/"),
     cst$82=caml_string_of_jsbytes(""),
     cst$77=caml_string_of_jsbytes(">"),
     cst$78=caml_string_of_jsbytes("<"),
     cst$79=caml_string_of_jsbytes(""),
     cst$76=caml_string_of_jsbytes("\n"),
     cst_Format_pp_set_geometry=
      caml_string_of_jsbytes("Format.pp_set_geometry: "),
     cst$72=caml_string_of_jsbytes(""),
     cst$73=caml_string_of_jsbytes(""),
     cst$74=caml_string_of_jsbytes(""),
     cst$75=caml_string_of_jsbytes(""),
     cst$68=caml_string_of_jsbytes(""),
     cst$69=caml_string_of_jsbytes(""),
     cst$70=caml_string_of_jsbytes(""),
     cst$71=caml_string_of_jsbytes(""),
     cst$67=caml_string_of_jsbytes(""),
     cst_Stdlib_Format_String_tag=
      caml_string_of_jsbytes("Stdlib.Format.String_tag"),
     cst_end_of_input_not_found=
      caml_string_of_jsbytes("end of input not found"),
     cst_scanf_bad_conversion_a=
      caml_string_of_jsbytes('scanf: bad conversion "%a"'),
     cst_scanf_bad_conversion_t=
      caml_string_of_jsbytes('scanf: bad conversion "%t"'),
     cst_scanf_missing_reader=caml_string_of_jsbytes("scanf: missing reader"),
     cst_scanf_bad_conversion_custo=
      caml_string_of_jsbytes('scanf: bad conversion "%?" (custom converter)'),
     cst_scanf_bad_conversion=
      caml_string_of_jsbytes('scanf: bad conversion "%*"'),
     cst_scanf_bad_conversion$0=
      caml_string_of_jsbytes('scanf: bad conversion "%*"'),
     cst_scanf_bad_conversion$1=
      caml_string_of_jsbytes('scanf: bad conversion "%-"'),
     cst_scanf_bad_conversion$2=
      caml_string_of_jsbytes('scanf: bad conversion "%*"'),
     cst$91=caml_string_of_jsbytes('"'),
     cst$92=caml_string_of_jsbytes('"'),
     cst$89=caml_string_of_jsbytes('"'),
     cst$90=caml_string_of_jsbytes('"'),
     cst$88=caml_string_of_jsbytes('"'),
     cst_in_format=caml_string_of_jsbytes(' in format "'),
     cst_an=caml_string_of_jsbytes("an"),
     cst_x$2=caml_string_of_jsbytes("x"),
     cst_nfinity=caml_string_of_jsbytes("nfinity"),
     cst_digits=caml_string_of_jsbytes("digits"),
     cst_decimal_digits=caml_string_of_jsbytes("decimal digits"),
     cst_0b=caml_string_of_jsbytes("0b"),
     cst_0o=caml_string_of_jsbytes("0o"),
     cst_0u=caml_string_of_jsbytes("0u"),
     cst_0x=caml_string_of_jsbytes("0x"),
     cst_false$3=caml_string_of_jsbytes("false"),
     cst_true$3=caml_string_of_jsbytes("true"),
     cst_not_a_valid_float_in_hexad=
      caml_string_of_jsbytes("not a valid float in hexadecimal notation"),
     cst_no_dot_or_exponent_part_fo=
      caml_string_of_jsbytes("no dot or exponent part found in float token"),
     cst$87=caml_string_of_jsbytes("-"),
     cst_unnamed_function=caml_string_of_jsbytes("unnamed function"),
     cst_unnamed_character_string=
      caml_string_of_jsbytes("unnamed character string"),
     cst_unnamed_Stdlib_input_chann=
      caml_string_of_jsbytes("unnamed Stdlib input channel"),
     cst$86=caml_string_of_jsbytes("-"),
     cst_Stdlib_Scanf_Scan_failure=
      caml_string_of_jsbytes("Stdlib.Scanf.Scan_failure"),
     cst_binary=caml_string_of_jsbytes("binary"),
     cst_octal=caml_string_of_jsbytes("octal"),
     cst_hexadecimal=caml_string_of_jsbytes("hexadecimal"),
     cst_a_Char=caml_string_of_jsbytes("a Char"),
     cst_a_String=caml_string_of_jsbytes("a String"),
     cst$93=caml_string_of_jsbytes(""),
     cst$94=caml_string_of_jsbytes(""),
     cst$95=caml_string_of_jsbytes(""),
     cst$96=caml_string_of_jsbytes(""),
     cst$97=caml_string_of_jsbytes(""),
     cst$99=caml_string_of_jsbytes(""),
     cst$98=caml_string_of_jsbytes(""),
     cst_Illegal_character=caml_string_of_jsbytes("Illegal character "),
     cst_Filename_chop_extension=
      caml_string_of_jsbytes("Filename.chop_extension"),
     cst$127=caml_string_of_jsbytes(""),
     cst_Filename_chop_suffix=caml_string_of_jsbytes("Filename.chop_suffix"),
     cst$126=caml_string_of_jsbytes(""),
     cst_2_1$0=caml_string_of_jsbytes(" 2>&1"),
     cst_2$0=caml_string_of_jsbytes(" 2>"),
     cst$125=caml_string_of_jsbytes(""),
     cst$117=caml_string_of_jsbytes(" >"),
     cst$124=caml_string_of_jsbytes(""),
     cst$118=caml_string_of_jsbytes(" <"),
     cst$123=caml_string_of_jsbytes(""),
     cst$119=caml_string_of_jsbytes(" "),
     cst$120=caml_string_of_jsbytes(" "),
     cst$121=caml_string_of_jsbytes('"'),
     cst$122=caml_string_of_jsbytes(""),
     cst_Filename_quote_command_bad=
      caml_string_of_jsbytes("Filename.quote_command: bad file name "),
     cst$115=caml_string_of_jsbytes('"'),
     cst$116=caml_string_of_jsbytes('"'),
     cst$113=caml_string_of_jsbytes("./"),
     cst$112=caml_string_of_jsbytes(".\\"),
     cst$111=caml_string_of_jsbytes("../"),
     cst$110=caml_string_of_jsbytes("..\\"),
     cst_2_1=caml_string_of_jsbytes(" 2>&1"),
     cst_2=caml_string_of_jsbytes(" 2>"),
     cst$109=caml_string_of_jsbytes(""),
     cst$104=caml_string_of_jsbytes(" >"),
     cst$108=caml_string_of_jsbytes(""),
     cst$105=caml_string_of_jsbytes(" <"),
     cst$107=caml_string_of_jsbytes(""),
     cst$106=caml_string_of_jsbytes(" "),
     cst$103=caml_string_of_jsbytes("./"),
     cst$102=caml_string_of_jsbytes("../"),
     cst$101=caml_string_of_jsbytes(""),
     cst$100=caml_string_of_jsbytes(""),
     null$0=caml_string_of_jsbytes("/dev/null"),
     current_dir_name=caml_string_of_jsbytes("."),
     parent_dir_name=caml_string_of_jsbytes(".."),
     dir_sep=caml_string_of_jsbytes("/"),
     cst_TMPDIR=caml_string_of_jsbytes("TMPDIR"),
     cst_tmp=caml_string_of_jsbytes("/tmp"),
     quotequote=caml_string_of_jsbytes("'\\''"),
     null$1=caml_string_of_jsbytes("NUL"),
     current_dir_name$0=caml_string_of_jsbytes("."),
     parent_dir_name$0=caml_string_of_jsbytes(".."),
     dir_sep$0=caml_string_of_jsbytes("\\"),
     cst_TEMP=caml_string_of_jsbytes("TEMP"),
     cst$114=caml_string_of_jsbytes("."),
     null$2=caml_string_of_jsbytes("/dev/null"),
     current_dir_name$1=caml_string_of_jsbytes("."),
     parent_dir_name$1=caml_string_of_jsbytes(".."),
     dir_sep$1=caml_string_of_jsbytes("/"),
     cst_Cygwin=caml_string_of_jsbytes("Cygwin"),
     cst_Win32=caml_string_of_jsbytes("Win32"),
     zero$4=[254,0.,0.],
     one$4=[254,1.,0.],
     i=[254,0.,1.],
     cst_Bigarray_array3_of_genarra=
      caml_string_of_jsbytes("Bigarray.array3_of_genarray"),
     cst_Bigarray_array2_of_genarra=
      caml_string_of_jsbytes("Bigarray.array2_of_genarray"),
     cst_Bigarray_array1_of_genarra=
      caml_string_of_jsbytes("Bigarray.array1_of_genarray"),
     cst_Bigarray_array0_of_genarra=
      caml_string_of_jsbytes("Bigarray.array0_of_genarray"),
     cst_Bigarray_Array3_of_array_n=
      caml_string_of_jsbytes("Bigarray.Array3.of_array: non-cubic data"),
     cst_Bigarray_Array3_of_array_n$0=
      caml_string_of_jsbytes("Bigarray.Array3.of_array: non-cubic data"),
     cst_Bigarray_Array2_of_array_n=
      caml_string_of_jsbytes("Bigarray.Array2.of_array: non-rectangular data"),
     Invalid_argument=global_data.Invalid_argument,
     Failure=global_data.Failure,
     Match_failure=global_data.Match_failure,
     Assert_failure=global_data.Assert_failure,
     Not_found=global_data.Not_found,
     Out_of_memory=global_data.Out_of_memory,
     Stack_overflow=global_data.Stack_overflow,
     Sys_error=global_data.Sys_error,
     End_of_file=global_data.End_of_file,
     Division_by_zero=global_data.Division_by_zero,
     Sys_blocked_io=global_data.Sys_blocked_io,
     Undefined_recursive_module=global_data.Undefined_recursive_module,
     _l_=[0,0,[0,6,0]],
     _k_=[0,0,[0,7,0]],
     _j_=[0,1,[0,3,[0,4,[0,6,0]]]],
     _i_=[0,1,[0,3,[0,4,[0,7,0]]]],
     _g_=[0,1],
     _h_=[0,0],
     _a_=runtime.caml_int64_create_lo_mi_hi(0,0,32752),
     _b_=runtime.caml_int64_create_lo_mi_hi(0,0,65520),
     _c_=runtime.caml_int64_create_lo_mi_hi(1,0,32752),
     _d_=runtime.caml_int64_create_lo_mi_hi(16777215,16777215,32751),
     _e_=runtime.caml_int64_create_lo_mi_hi(0,0,16),
     _f_=runtime.caml_int64_create_lo_mi_hi(0,0,15536),
     _p_=[0,0,0],
     _q_=[0,caml_string_of_jsbytes("obj.ml"),100,4],
     _u_=[0,caml_string_of_jsbytes("array.ml"),258,4],
     _w_=[0,caml_string_of_jsbytes("float.ml"),379,6],
     _v_=[0,caml_string_of_jsbytes("float.ml"),206,14],
     _H_=runtime.caml_int64_create_lo_mi_hi(16777215,16777215,65535),
     _G_=runtime.caml_int64_create_lo_mi_hi(0,0,0),
     _F_=runtime.caml_int64_create_lo_mi_hi(1,0,0),
     _E_=runtime.caml_int64_create_lo_mi_hi(1,0,0),
     _I_=[0,0,0,0],
     _J_=[0,0,0],
     _K_=[0,caml_string_of_jsbytes("set.ml"),570,18],
     _L_=[0,0,0,0],
     _M_=[0,caml_string_of_jsbytes("map.ml"),400,10],
     _N_=[0,0,0],
     _O_=[0,caml_string_of_jsbytes("stream.ml"),53,12],
     _P_=[0,0],
     _Q_=[0,caml_string_of_jsbytes("stream.ml"),82,12],
     ___=[0,caml_string_of_jsbytes("buffer.ml"),282,9],
     _Z_=[0,caml_string_of_jsbytes("buffer.ml"),263,2],
     _Y_=[0,caml_string_of_jsbytes("buffer.ml"),195,19],
     _X_=[0,caml_string_of_jsbytes("buffer.ml"),213,8],
     _W_=[0,caml_string_of_jsbytes("buffer.ml"),174,19],
     _V_=[0,caml_string_of_jsbytes("buffer.ml"),192,8],
     _U_=[0,caml_string_of_jsbytes("buffer.ml"),138,19],
     _T_=[0,caml_string_of_jsbytes("buffer.ml"),171,8],
     _S_=[0,caml_string_of_jsbytes("buffer.ml"),93,2],
     _R_=[0,caml_string_of_jsbytes("buffer.ml"),94,2],
     _aa_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),850,23],
     _al_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),814,21],
     _ad_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),815,21],
     _am_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),818,21],
     _ae_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),819,21],
     _an_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),822,19],
     _af_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),823,19],
     _ao_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),826,22],
     _ag_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),827,22],
     _ap_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),831,30],
     _ah_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),832,30],
     _aj_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),836,26],
     _ab_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),837,26],
     _ak_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),846,28],
     _ac_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),847,28],
     _ai_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),851,23],
     _ar_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),1558,4],
     _as_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),1626,39],
     _at_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),1649,31],
     _au_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),1650,31],
     _av_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),1830,8],
     _aZ_=
      [0,
       [11,
        caml_string_of_jsbytes("bad input: format type mismatch between "),
        [3,0,[11,caml_string_of_jsbytes(" and "),[3,0,0]]]],
       caml_string_of_jsbytes
        ("bad input: format type mismatch between %S and %S")],
     _aY_=
      [0,
       [11,
        caml_string_of_jsbytes("bad input: format type mismatch between "),
        [3,0,[11,caml_string_of_jsbytes(" and "),[3,0,0]]]],
       caml_string_of_jsbytes
        ("bad input: format type mismatch between %S and %S")],
     _aB_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(": at character number "),
          [4,0,0,0,[11,caml_string_of_jsbytes(", duplicate flag "),[1,0]]]]]],
       caml_string_of_jsbytes
        ("invalid format %S: at character number %d, duplicate flag %C")],
     _aC_=[0,1,0],
     _aD_=[0,0],
     _aE_=[1,0],
     _aF_=[1,1],
     _aH_=[1,1],
     _aG_=[1,1],
     _aL_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(": at character number "),
          [4,
           0,
           0,
           0,
           [11,
            caml_string_of_jsbytes(", flag "),
            [1,
             [11,
              caml_string_of_jsbytes(" is only allowed after the '"),
              [12,
               37,
               [11,
                caml_string_of_jsbytes("', before padding and precision"),
                0]]]]]]]]],
       caml_string_of_jsbytes
        ("invalid format %S: at character number %d, flag %C is only allowed after the '%%', before padding and precision")],
     _aI_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(": at character number "),
          [4,
           0,
           0,
           0,
           [11,
            caml_string_of_jsbytes(', invalid conversion "'),
            [12,37,[0,[12,34,0]]]]]]]],
       caml_string_of_jsbytes
        ('invalid format %S: at character number %d, invalid conversion "%%%c"')],
     _aJ_=[0,0],
     _aK_=[0,0],
     _aM_=[0,[12,64,0]],
     _aN_=[0,caml_string_of_jsbytes("@ "),1,0],
     _aO_=[0,caml_string_of_jsbytes("@,"),0,0],
     _aP_=[2,60],
     _aQ_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(": '"),
          [12,
           37,
           [11,
            caml_string_of_jsbytes
             ("' alone is not accepted in character sets, use "),
            [12,
             37,
             [12,
              37,
              [11,
               caml_string_of_jsbytes(" instead at position "),
               [4,0,0,0,[12,46,0]]]]]]]]]],
       caml_string_of_jsbytes
        ("invalid format %S: '%%' alone is not accepted in character sets, use %%%% instead at position %d.")],
     _aR_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(": integer "),
          [4,
           0,
           0,
           0,
           [11,
            caml_string_of_jsbytes(" is greater than the limit "),
            [4,0,0,0,0]]]]]],
       caml_string_of_jsbytes
        ("invalid format %S: integer %d is greater than the limit %d")],
     _aS_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),2837,11],
     _aT_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(': unclosed sub-format, expected "'),
          [12,
           37,
           [0,
            [11,caml_string_of_jsbytes('" at character number '),[4,0,0,0,0]]]]]]],
       caml_string_of_jsbytes
        ('invalid format %S: unclosed sub-format, expected "%%%c" at character number %d')],
     _aU_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),2899,34],
     _aV_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),2935,28],
     _aW_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),2957,11],
     _aX_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(": at character number "),
          [4,
           0,
           0,
           0,
           [11,
            caml_string_of_jsbytes(", "),
            [2,
             0,
             [11,
              caml_string_of_jsbytes(" is incompatible with '"),
              [0,[11,caml_string_of_jsbytes("' in sub-format "),[3,0,0]]]]]]]]]],
       caml_string_of_jsbytes
        ("invalid format %S: at character number %d, %s is incompatible with '%c' in sub-format %S")],
     _aA_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(": at character number "),
          [4,
           0,
           0,
           0,
           [11,
            caml_string_of_jsbytes(", "),
            [2,0,[11,caml_string_of_jsbytes(" expected, read "),[1,0]]]]]]]],
       caml_string_of_jsbytes
        ("invalid format %S: at character number %d, %s expected, read %C")],
     _az_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(": at character number "),
          [4,
           0,
           0,
           0,
           [11,
            caml_string_of_jsbytes(", '"),
            [0,[11,caml_string_of_jsbytes("' without "),[2,0,0]]]]]]]],
       caml_string_of_jsbytes
        ("invalid format %S: at character number %d, '%c' without %s")],
     _ay_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(": at character number "),
          [4,0,0,0,[11,caml_string_of_jsbytes(", "),[2,0,0]]]]]],
       caml_string_of_jsbytes("invalid format %S: at character number %d, %s")],
     _ax_=
      [0,
       [11,caml_string_of_jsbytes("invalid box description "),[3,0,0]],
       caml_string_of_jsbytes("invalid box description %S")],
     _aw_=[0,0,4],
     _aq_=[0,103],
     _$_=[0,0,0],
     _bj_=[0,[2,0,[0,0]],caml_string_of_jsbytes("%s%c")],
     _bd_=[0,[2,0,0],caml_string_of_jsbytes("%s")],
     _be_=[0,[2,0,0],caml_string_of_jsbytes("%s")],
     _bb_=[0,[2,0,0],caml_string_of_jsbytes("%s")],
     _bc_=[0,[2,0,0],caml_string_of_jsbytes("%s")],
     _a$_=[0,[2,0,0],caml_string_of_jsbytes("%s")],
     _ba_=[0,[2,0,0],caml_string_of_jsbytes("%s")],
     _a5_=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes(": unknown option '"),
         [2,0,[11,caml_string_of_jsbytes("'.\n"),0]]]],
       caml_string_of_jsbytes("%s: unknown option '%s'.\n")],
     _a8_=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes(": wrong argument '"),
         [2,
          0,
          [11,
           caml_string_of_jsbytes("'; option '"),
           [2,
            0,
            [11,
             caml_string_of_jsbytes("' expects "),
             [2,0,[11,caml_string_of_jsbytes(".\n"),0]]]]]]]],
       caml_string_of_jsbytes
        ("%s: wrong argument '%s'; option '%s' expects %s.\n")],
     _a9_=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes(": option '"),
         [2,0,[11,caml_string_of_jsbytes("' needs an argument.\n"),0]]]],
       caml_string_of_jsbytes("%s: option '%s' needs an argument.\n")],
     _a__=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes(": "),
         [2,0,[11,caml_string_of_jsbytes(".\n"),0]]]],
       caml_string_of_jsbytes("%s: %s.\n")],
     _a6_=[0,caml_string_of_jsbytes("-help")],
     _a7_=[0,caml_string_of_jsbytes("--help")],
     _a4_=[0,[2,0,0],caml_string_of_jsbytes("%s")],
     _a3_=[0,[2,0,[12,10,0]],caml_string_of_jsbytes("%s\n")],
     _a2_=[0,caml_string_of_jsbytes("-help")],
     _a0_=
      [0,
       [11,caml_string_of_jsbytes("  "),[2,0,[12,32,[2,0,[12,10,0]]]]],
       caml_string_of_jsbytes("  %s %s\n")],
     _a1_=
      [0,
       [11,caml_string_of_jsbytes("  "),[2,0,[12,32,[2,0,[2,0,[12,10,0]]]]]],
       caml_string_of_jsbytes("  %s %s%s\n")],
     _bo_=
      [0,
       [11,caml_string_of_jsbytes(", "),[2,0,[2,0,0]]],
       caml_string_of_jsbytes(", %s%s")],
     _bz_=
      [0,
       [11,caml_string_of_jsbytes("Fatal error: exception "),[2,0,[12,10,0]]],
       caml_string_of_jsbytes("Fatal error: exception %s\n")],
     _bx_=[0,[2,0,[12,10,0]],caml_string_of_jsbytes("%s\n")],
     _bv_=[0,[2,0,[12,10,0]],caml_string_of_jsbytes("%s\n")],
     _bw_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("(Program not linked with -g, cannot print stack backtrace)\n"),
        0],
       caml_string_of_jsbytes
        ("(Program not linked with -g, cannot print stack backtrace)\n")],
     _bt_=
      [0,
       [2,
        0,
        [12,
         32,
         [2,
          0,
          [11,
           caml_string_of_jsbytes(' in file "'),
           [2,
            0,
            [12,
             34,
             [2,
              0,
              [11,
               caml_string_of_jsbytes(", line "),
               [4,0,0,0,[11,caml_string_of_jsbytes(", characters "),partial]]]]]]]]]],
       caml_string_of_jsbytes
        ('%s %s in file "%s"%s, line %d, characters %d-%d')],
     _bu_=
      [0,
       [2,0,[11,caml_string_of_jsbytes(" unknown location"),0]],
       caml_string_of_jsbytes("%s unknown location")],
     _bs_=
      [0,
       [11,caml_string_of_jsbytes("Uncaught exception: "),[2,0,[12,10,0]]],
       caml_string_of_jsbytes("Uncaught exception: %s\n")],
     _br_=
      [0,
       [11,caml_string_of_jsbytes("Uncaught exception: "),[2,0,[12,10,0]]],
       caml_string_of_jsbytes("Uncaught exception: %s\n")],
     _bp_=[0,[12,40,[2,0,[2,0,[12,41,0]]]],caml_string_of_jsbytes("(%s%s)")],
     _bq_=[0,[12,40,[2,0,[12,41,0]]],caml_string_of_jsbytes("(%s)")],
     _bn_=[0,[4,0,0,0,0],caml_string_of_jsbytes("%d")],
     _bm_=[0,[3,0,0],caml_string_of_jsbytes("%S")],
     _by_=
      [0,
       caml_string_of_jsbytes(""),
       caml_string_of_jsbytes
        ("(Cannot print locations:\n bytecode executable program file not found)"),
       caml_string_of_jsbytes
        ("(Cannot print locations:\n bytecode executable program file appears to be corrupt)"),
       caml_string_of_jsbytes
        ("(Cannot print locations:\n bytecode executable program file has wrong magic number)"),
       caml_string_of_jsbytes
        ("(Cannot print locations:\n bytecode executable program file cannot be opened;\n -- too many open files. Try running with OCAMLRUNPARAM=b=2)")],
     _bG_=
      [0,
       [11,
        caml_string_of_jsbytes("minor_collections:      "),
        [4,0,0,0,[12,10,0]]],
       caml_string_of_jsbytes("minor_collections:      %d\n")],
     _bH_=
      [0,
       [11,
        caml_string_of_jsbytes("major_collections:      "),
        [4,0,0,0,[12,10,0]]],
       caml_string_of_jsbytes("major_collections:      %d\n")],
     _bI_=
      [0,
       [11,
        caml_string_of_jsbytes("compactions:            "),
        [4,0,0,0,[12,10,0]]],
       caml_string_of_jsbytes("compactions:            %d\n")],
     _bJ_=
      [0,
       [11,
        caml_string_of_jsbytes("forced_major_collections: "),
        [4,0,0,0,[12,10,0]]],
       caml_string_of_jsbytes("forced_major_collections: %d\n")],
     _bK_=[0,[12,10,0],caml_string_of_jsbytes("\n")],
     _bL_=[0,[8,[0,0,0],0,[0,0],0],caml_string_of_jsbytes("%.0f")],
     _bM_=
      [0,
       [11,
        caml_string_of_jsbytes("minor_words:    "),
        [8,[0,0,0],[1,1],[0,0],[12,10,0]]],
       caml_string_of_jsbytes("minor_words:    %*.0f\n")],
     _bN_=
      [0,
       [11,
        caml_string_of_jsbytes("promoted_words: "),
        [8,[0,0,0],[1,1],[0,0],[12,10,0]]],
       caml_string_of_jsbytes("promoted_words: %*.0f\n")],
     _bO_=
      [0,
       [11,
        caml_string_of_jsbytes("major_words:    "),
        [8,[0,0,0],[1,1],[0,0],[12,10,0]]],
       caml_string_of_jsbytes("major_words:    %*.0f\n")],
     _bP_=[0,[12,10,0],caml_string_of_jsbytes("\n")],
     _bQ_=[0,[4,0,0,0,0],caml_string_of_jsbytes("%d")],
     _bR_=
      [0,
       [11,caml_string_of_jsbytes("top_heap_words: "),[4,0,[1,1],0,[12,10,0]]],
       caml_string_of_jsbytes("top_heap_words: %*d\n")],
     _bS_=
      [0,
       [11,caml_string_of_jsbytes("heap_words:     "),[4,0,[1,1],0,[12,10,0]]],
       caml_string_of_jsbytes("heap_words:     %*d\n")],
     _bT_=
      [0,
       [11,caml_string_of_jsbytes("live_words:     "),[4,0,[1,1],0,[12,10,0]]],
       caml_string_of_jsbytes("live_words:     %*d\n")],
     _bU_=
      [0,
       [11,caml_string_of_jsbytes("free_words:     "),[4,0,[1,1],0,[12,10,0]]],
       caml_string_of_jsbytes("free_words:     %*d\n")],
     _bV_=
      [0,
       [11,caml_string_of_jsbytes("largest_free:   "),[4,0,[1,1],0,[12,10,0]]],
       caml_string_of_jsbytes("largest_free:   %*d\n")],
     _bW_=
      [0,
       [11,caml_string_of_jsbytes("fragments:      "),[4,0,[1,1],0,[12,10,0]]],
       caml_string_of_jsbytes("fragments:      %*d\n")],
     _bX_=[0,[12,10,0],caml_string_of_jsbytes("\n")],
     _bY_=
      [0,
       [11,caml_string_of_jsbytes("live_blocks: "),[4,0,0,0,[12,10,0]]],
       caml_string_of_jsbytes("live_blocks: %d\n")],
     _bZ_=
      [0,
       [11,caml_string_of_jsbytes("free_blocks: "),[4,0,0,0,[12,10,0]]],
       caml_string_of_jsbytes("free_blocks: %d\n")],
     _b0_=
      [0,
       [11,caml_string_of_jsbytes("heap_chunks: "),[4,0,0,0,[12,10,0]]],
       caml_string_of_jsbytes("heap_chunks: %d\n")],
     _b8_=runtime.caml_int64_create_lo_mi_hi(1,0,0),
     _b9_=runtime.caml_int64_create_lo_mi_hi(0,0,0),
     _b__=
      [0,
       987910699,
       495797812,
       364182224,
       414272206,
       318284740,
       990407751,
       383018966,
       270373319,
       840823159,
       24560019,
       536292337,
       512266505,
       189156120,
       730249596,
       143776328,
       51606627,
       140166561,
       366354223,
       1003410265,
       700563762,
       981890670,
       913149062,
       526082594,
       1021425055,
       784300257,
       667753350,
       630144451,
       949649812,
       48546892,
       415514493,
       258888527,
       511570777,
       89983870,
       283659902,
       308386020,
       242688715,
       482270760,
       865188196,
       1027664170,
       207196989,
       193777847,
       619708188,
       671350186,
       149669678,
       257044018,
       87658204,
       558145612,
       183450813,
       28133145,
       901332182,
       710253903,
       510646120,
       652377910,
       409934019,
       801085050],
     _cc_=[0,0],
     _cb_=[0,caml_string_of_jsbytes("hashtbl.ml"),102,23],
     _ci_=[3,0,3],
     _ch_=[1,caml_string_of_jsbytes("max_indent < 2")],
     _cf_=[1,caml_string_of_jsbytes("margin <= max_indent")],
     _cg_=[0,0],
     _ce_=[0,caml_string_of_jsbytes("")],
     _cd_=[0,caml_string_of_jsbytes(""),0,caml_string_of_jsbytes("")],
     _cy_=[0,91],
     _cx_=[0,123],
     _cz_=[0,caml_string_of_jsbytes("scanf.ml"),1453,13],
     _cA_=[0,[3,0,[10,0]],caml_string_of_jsbytes("%S%!")],
     _cw_=[0,37,caml_string_of_jsbytes("")],
     _cv_=
      [0,
       [11,
        caml_string_of_jsbytes("scanf: bad input at char number "),
        [4,3,0,0,[11,caml_string_of_jsbytes(": "),[2,0,0]]]],
       caml_string_of_jsbytes("scanf: bad input at char number %i: %s")],
     _cu_=
      [0,
       [11,
        caml_string_of_jsbytes("the character "),
        [1,[11,caml_string_of_jsbytes(" cannot start a boolean"),0]]],
       caml_string_of_jsbytes("the character %C cannot start a boolean")],
     _ct_=
      [0,
       [11,
        caml_string_of_jsbytes("bad character hexadecimal encoding \\"),
        [0,[0,0]]],
       caml_string_of_jsbytes("bad character hexadecimal encoding \\%c%c")],
     _cs_=
      [0,
       [11,
        caml_string_of_jsbytes("bad character decimal encoding \\"),
        [0,[0,[0,0]]]],
       caml_string_of_jsbytes("bad character decimal encoding \\%c%c%c")],
     _cr_=
      [0,
       [11,
        caml_string_of_jsbytes("character "),
        [1,
         [11,
          caml_string_of_jsbytes(" is not a valid "),
          [2,0,[11,caml_string_of_jsbytes(" digit"),0]]]]],
       caml_string_of_jsbytes("character %C is not a valid %s digit")],
     _cq_=
      [0,
       [11,
        caml_string_of_jsbytes("character "),
        [1,[11,caml_string_of_jsbytes(" is not a decimal digit"),0]]],
       caml_string_of_jsbytes("character %C is not a decimal digit")],
     _cp_=[0,caml_string_of_jsbytes("scanf.ml"),555,9],
     _co_=
      [0,
       [11,caml_string_of_jsbytes("invalid boolean '"),[2,0,[12,39,0]]],
       caml_string_of_jsbytes("invalid boolean '%s'")],
     _cn_=
      [0,
       [11,
        caml_string_of_jsbytes("looking for "),
        [1,[11,caml_string_of_jsbytes(", found "),[1,0]]]],
       caml_string_of_jsbytes("looking for %C, found %C")],
     _cm_=
      [0,
       [11,
        caml_string_of_jsbytes("scanning of "),
        [2,
         0,
         [11,
          caml_string_of_jsbytes
           (" failed: premature end of file occurred before end of token"),
          0]]],
       caml_string_of_jsbytes
        ("scanning of %s failed: premature end of file occurred before end of token")],
     _cl_=
      [0,
       [11,
        caml_string_of_jsbytes("scanning of "),
        [2,
         0,
         [11,
          caml_string_of_jsbytes
           (" failed: the specified length was too short for token"),
          0]]],
       caml_string_of_jsbytes
        ("scanning of %s failed: the specified length was too short for token")],
     _ck_=
      [0,
       [11,caml_string_of_jsbytes("illegal escape character "),[1,0]],
       caml_string_of_jsbytes("illegal escape character %C")],
     _cH_=[0,caml_string_of_jsbytes("camlinternalOO.ml"),438,17],
     _cG_=[0,caml_string_of_jsbytes("camlinternalOO.ml"),420,13],
     _cF_=[0,caml_string_of_jsbytes("camlinternalOO.ml"),417,13],
     _cE_=[0,caml_string_of_jsbytes("camlinternalOO.ml"),414,13],
     _cD_=[0,caml_string_of_jsbytes("camlinternalOO.ml"),411,13],
     _cC_=[0,caml_string_of_jsbytes("camlinternalOO.ml"),408,13],
     _cB_=[0,caml_string_of_jsbytes("camlinternalOO.ml"),281,50],
     _cK_=[0,0],
     _cJ_=[0,0],
     _cI_=[0,0],
     _cP_=[0,7,0],
     _cO_=[0,1,[0,3,[0,5,0]]],
     _cN_=[0,[2,0,[4,6,[0,2,6],0,[2,0,0]]],caml_string_of_jsbytes("%s%06x%s")],
     _cM_=[0,caml_string_of_jsbytes('"'),0],
     _cQ_=[254,0.,0.];
    function erase_rel(param)
     {if(typeof param === "number")
       return 0;
      else
       switch(param[0])
        {case 0:var rest=param[1];return [0,erase_rel(rest)];
         case 1:var rest$0=param[1];return [1,erase_rel(rest$0)];
         case 2:var rest$1=param[1];return [2,erase_rel(rest$1)];
         case 3:var rest$2=param[1];return [3,erase_rel(rest$2)];
         case 4:var rest$3=param[1];return [4,erase_rel(rest$3)];
         case 5:var rest$4=param[1];return [5,erase_rel(rest$4)];
         case 6:var rest$5=param[1];return [6,erase_rel(rest$5)];
         case 7:var rest$6=param[1];return [7,erase_rel(rest$6)];
         case 8:
          var rest$7=param[2],ty=param[1];return [8,ty,erase_rel(rest$7)];
         case 9:
          var rest$8=param[3],ty1=param[1];
          return [9,ty1,ty1,erase_rel(rest$8)];
         case 10:var rest$9=param[1];return [10,erase_rel(rest$9)];
         case 11:var rest$10=param[1];return [11,erase_rel(rest$10)];
         case 12:var rest$11=param[1];return [12,erase_rel(rest$11)];
         case 13:var rest$12=param[1];return [13,erase_rel(rest$12)];
         default:var rest$13=param[1];return [14,erase_rel(rest$13)]}}
    function concat_fmtty(fmtty1,fmtty2)
     {if(typeof fmtty1 === "number")
       return fmtty2;
      else
       switch(fmtty1[0])
        {case 0:var rest=fmtty1[1];return [0,concat_fmtty(rest,fmtty2)];
         case 1:var rest$0=fmtty1[1];return [1,concat_fmtty(rest$0,fmtty2)];
         case 2:var rest$1=fmtty1[1];return [2,concat_fmtty(rest$1,fmtty2)];
         case 3:var rest$2=fmtty1[1];return [3,concat_fmtty(rest$2,fmtty2)];
         case 4:var rest$3=fmtty1[1];return [4,concat_fmtty(rest$3,fmtty2)];
         case 5:var rest$4=fmtty1[1];return [5,concat_fmtty(rest$4,fmtty2)];
         case 6:var rest$5=fmtty1[1];return [6,concat_fmtty(rest$5,fmtty2)];
         case 7:var rest$6=fmtty1[1];return [7,concat_fmtty(rest$6,fmtty2)];
         case 8:
          var rest$7=fmtty1[2],ty=fmtty1[1];
          return [8,ty,concat_fmtty(rest$7,fmtty2)];
         case 9:
          var rest$8=fmtty1[3],ty2=fmtty1[2],ty1=fmtty1[1];
          return [9,ty1,ty2,concat_fmtty(rest$8,fmtty2)];
         case 10:var rest$9=fmtty1[1];return [10,concat_fmtty(rest$9,fmtty2)];
         case 11:
          var rest$10=fmtty1[1];return [11,concat_fmtty(rest$10,fmtty2)];
         case 12:
          var rest$11=fmtty1[1];return [12,concat_fmtty(rest$11,fmtty2)];
         case 13:
          var rest$12=fmtty1[1];return [13,concat_fmtty(rest$12,fmtty2)];
         default:
          var rest$13=fmtty1[1];return [14,concat_fmtty(rest$13,fmtty2)]}}
    function concat_fmt(fmt1,fmt2)
     {if(typeof fmt1 === "number")
       return fmt2;
      else
       switch(fmt1[0])
        {case 0:var rest=fmt1[1];return [0,concat_fmt(rest,fmt2)];
         case 1:var rest$0=fmt1[1];return [1,concat_fmt(rest$0,fmt2)];
         case 2:
          var rest$1=fmt1[2],pad=fmt1[1];
          return [2,pad,concat_fmt(rest$1,fmt2)];
         case 3:
          var rest$2=fmt1[2],pad$0=fmt1[1];
          return [3,pad$0,concat_fmt(rest$2,fmt2)];
         case 4:
          var rest$3=fmt1[4],prec=fmt1[3],pad$1=fmt1[2],iconv=fmt1[1];
          return [4,iconv,pad$1,prec,concat_fmt(rest$3,fmt2)];
         case 5:
          var rest$4=fmt1[4],prec$0=fmt1[3],pad$2=fmt1[2],iconv$0=fmt1[1];
          return [5,iconv$0,pad$2,prec$0,concat_fmt(rest$4,fmt2)];
         case 6:
          var rest$5=fmt1[4],prec$1=fmt1[3],pad$3=fmt1[2],iconv$1=fmt1[1];
          return [6,iconv$1,pad$3,prec$1,concat_fmt(rest$5,fmt2)];
         case 7:
          var rest$6=fmt1[4],prec$2=fmt1[3],pad$4=fmt1[2],iconv$2=fmt1[1];
          return [7,iconv$2,pad$4,prec$2,concat_fmt(rest$6,fmt2)];
         case 8:
          var rest$7=fmt1[4],prec$3=fmt1[3],pad$5=fmt1[2],fconv=fmt1[1];
          return [8,fconv,pad$5,prec$3,concat_fmt(rest$7,fmt2)];
         case 9:
          var rest$8=fmt1[2],pad$6=fmt1[1];
          return [9,pad$6,concat_fmt(rest$8,fmt2)];
         case 10:var rest$9=fmt1[1];return [10,concat_fmt(rest$9,fmt2)];
         case 11:
          var rest$10=fmt1[2],str=fmt1[1];
          return [11,str,concat_fmt(rest$10,fmt2)];
         case 12:
          var rest$11=fmt1[2],chr=fmt1[1];
          return [12,chr,concat_fmt(rest$11,fmt2)];
         case 13:
          var rest$12=fmt1[3],fmtty=fmt1[2],pad$7=fmt1[1];
          return [13,pad$7,fmtty,concat_fmt(rest$12,fmt2)];
         case 14:
          var rest$13=fmt1[3],fmtty$0=fmt1[2],pad$8=fmt1[1];
          return [14,pad$8,fmtty$0,concat_fmt(rest$13,fmt2)];
         case 15:var rest$14=fmt1[1];return [15,concat_fmt(rest$14,fmt2)];
         case 16:var rest$15=fmt1[1];return [16,concat_fmt(rest$15,fmt2)];
         case 17:
          var rest$16=fmt1[2],fmting_lit=fmt1[1];
          return [17,fmting_lit,concat_fmt(rest$16,fmt2)];
         case 18:
          var rest$17=fmt1[2],fmting_gen=fmt1[1];
          return [18,fmting_gen,concat_fmt(rest$17,fmt2)];
         case 19:var rest$18=fmt1[1];return [19,concat_fmt(rest$18,fmt2)];
         case 20:
          var rest$19=fmt1[3],char_set=fmt1[2],width_opt=fmt1[1];
          return [20,width_opt,char_set,concat_fmt(rest$19,fmt2)];
         case 21:
          var rest$20=fmt1[2],counter=fmt1[1];
          return [21,counter,concat_fmt(rest$20,fmt2)];
         case 22:var rest$21=fmt1[1];return [22,concat_fmt(rest$21,fmt2)];
         case 23:
          var rest$22=fmt1[2],ign=fmt1[1];
          return [23,ign,concat_fmt(rest$22,fmt2)];
         default:
          var rest$23=fmt1[3],f=fmt1[2],arity=fmt1[1];
          return [24,arity,f,concat_fmt(rest$23,fmt2)]}}
    var CamlinternalFormatBasics=[0,concat_fmtty,erase_rel,concat_fmt];
    caml_register_global
     (744,CamlinternalFormatBasics,"CamlinternalFormatBasics");
    function make(v){return [0,v]}
    function get(r){return r[1]}
    function set(r,v){r[1] = v;return 0}
    function exchange(r,v){var cur=r[1];r[1] = v;return cur}
    function compare_and_set(r,seen,v)
     {var cur=r[1];return cur === seen?(r[1] = v,1):0}
    function fetch_and_add(r,n){var cur=r[1];r[1] = cur + n | 0;return cur}
    function incr(r){fetch_and_add(r,1);return 0}
    function decr(r){fetch_and_add(r,-1);return 0}
    var
     include=
      [0,make,get,set,exchange,compare_and_set,fetch_and_add,incr,decr];
    caml_register_global(745,include,"CamlinternalAtomic");
    function failwith(s){throw [0,Failure,s]}
    function invalid_arg(s){throw [0,Invalid_argument,s]}
    var Exit=[248,cst_Stdlib_Exit,caml_fresh_oo_id(0)];
    function min(x,y){return caml_lessequal(x,y)?x:y}
    function max(x,y){return caml_greaterequal(x,y)?x:y}
    function abs(x){return 0 <= x?x:- x | 0}
    function lnot(x){return x ^ -1}
    var
     infinity=caml_int64_float_of_bits(_a_),
     neg_infinity=caml_int64_float_of_bits(_b_),
     nan=caml_int64_float_of_bits(_c_),
     max_float=caml_int64_float_of_bits(_d_),
     min_float=caml_int64_float_of_bits(_e_),
     epsilon=caml_int64_float_of_bits(_f_),
     max_int=2147483647,
     min_int=-2147483648;
    function symbol(s1,s2)
     {var
       l1=caml_ml_string_length(s1),
       l2=caml_ml_string_length(s2),
       s=caml_create_bytes(l1 + l2 | 0);
      caml_blit_string(s1,0,s,0,l1);
      caml_blit_string(s2,0,s,l1,l2);
      return caml_string_of_bytes(s)}
    function char_of_int(n)
     {if(0 <= n && ! (255 < n))return n;return invalid_arg(cst_char_of_int)}
    function string_of_bool(b){return b?cst_true:cst_false}
    function bool_of_string(param)
     {return caml_string_notequal(param,cst_false$0)
              ?caml_string_notequal(param,cst_true$0)
                ?invalid_arg(cst_bool_of_string)
                :1
              :0}
    function bool_of_string_opt(param)
     {return caml_string_notequal(param,cst_false$1)
              ?caml_string_notequal(param,cst_true$1)?0:_g_
              :_h_}
    function string_of_int(n){return caml_string_of_jsbytes("" + n)}
    function int_of_string_opt(s)
     {try
       {var _BP_=[0,caml_int_of_string(s)];return _BP_}
      catch(_BQ_)
       {_BQ_ = caml_wrap_exception(_BQ_);
        if(_BQ_[1] === Failure)return 0;
        throw _BQ_}}
    function valid_float_lexem(s)
     {var l=caml_ml_string_length(s),i=0;
      for(;;)
       {if(l <= i)return symbol(s,cst);
        var match=caml_string_get(s,i),switch$0=0;
        if(48 <= match)
         {if(! (58 <= match))switch$0 = 1}
        else
         if(45 === match)switch$0 = 1;
        if(switch$0){var i$0=i + 1 | 0,i=i$0;continue}
        return s}}
    function to_string(f)
     {return valid_float_lexem(caml_format_float(cst_12g,f))}
    function of_string_opt(s)
     {try
       {var _BN_=[0,caml_float_of_string(s)];return _BN_}
      catch(_BO_)
       {_BO_ = caml_wrap_exception(_BO_);
        if(_BO_[1] === Failure)return 0;
        throw _BO_}}
    function append(l1,l2)
     {if(l1){var tl=l1[2],hd=l1[1];return [0,hd,append(tl,l2)]}return l2}
    var
     stdin=caml_ml_open_descriptor_in(0),
     stdout=caml_ml_open_descriptor_out(1),
     stderr=caml_ml_open_descriptor_out(2);
    function open_out_gen(mode,perm,name)
     {var c=caml_ml_open_descriptor_out(caml_sys_open(name,mode,perm));
      caml_ml_set_channel_name(c,name);
      return c}
    function open_out(name){return open_out_gen(_i_,438,name)}
    function open_out_bin(name){return open_out_gen(_j_,438,name)}
    function flush_all(param)
     {function iter(param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var l=param$0[2],a=param$0[1];
            try
             {caml_ml_flush(a)}
            catch(_BM_)
             {_BM_ = caml_wrap_exception(_BM_);
              if(_BM_[1] !== Sys_error)throw _BM_;
              var _BL_=_BM_}
            var param$0=l;
            continue}
          return 0}}
      return iter(runtime.caml_ml_out_channels_list(0))}
    function output_bytes(oc,s)
     {return caml_ml_output_bytes(oc,s,0,caml_ml_bytes_length(s))}
    function output_string(oc,s)
     {return caml_ml_output(oc,s,0,caml_ml_string_length(s))}
    function output(oc,s,ofs,len)
     {if
       (0 <= ofs && 0 <= len && ! ((caml_ml_bytes_length(s) - len | 0) < ofs))
       return caml_ml_output_bytes(oc,s,ofs,len);
      return invalid_arg(cst_output)}
    function output_substring(oc,s,ofs,len)
     {if
       (0
        <=
        ofs
        &&
        0
        <=
        len
        &&
        !
        ((caml_ml_string_length(s) - len | 0) < ofs))
       return caml_ml_output(oc,s,ofs,len);
      return invalid_arg(cst_output_substring)}
    function output_value(chan,v){return caml_output_value(chan,v,0)}
    function close_out(oc){caml_ml_flush(oc);return caml_ml_close_channel(oc)}
    function close_out_noerr(oc)
     {try {caml_ml_flush(oc)}catch(_BK_){}
      try
       {var _BI_=caml_ml_close_channel(oc);return _BI_}
      catch(_BJ_){return 0}}
    function open_in_gen(mode,perm,name)
     {var c=caml_ml_open_descriptor_in(caml_sys_open(name,mode,perm));
      caml_ml_set_channel_name(c,name);
      return c}
    function open_in(name){return open_in_gen(_k_,0,name)}
    function open_in_bin(name){return open_in_gen(_l_,0,name)}
    function input(ic,s,ofs,len)
     {if
       (0 <= ofs && 0 <= len && ! ((caml_ml_bytes_length(s) - len | 0) < ofs))
       return caml_ml_input(ic,s,ofs,len);
      return invalid_arg(cst_input)}
    function unsafe_really_input(ic,s,ofs,len)
     {var ofs$0=ofs,len$0=len;
      for(;;)
       {if(0 < len$0)
         {var r=caml_ml_input(ic,s,ofs$0,len$0);
          if(0 === r)throw End_of_file;
          var len$1=len$0 - r | 0,ofs$1=ofs$0 + r | 0,ofs$0=ofs$1,len$0=len$1;
          continue}
        return 0}}
    function really_input(ic,s,ofs,len)
     {if
       (0 <= ofs && 0 <= len && ! ((caml_ml_bytes_length(s) - len | 0) < ofs))
       return unsafe_really_input(ic,s,ofs,len);
      return invalid_arg(cst_really_input)}
    function really_input_string(ic,len)
     {var s=caml_create_bytes(len);
      really_input(ic,s,0,len);
      return caml_string_of_bytes(s)}
    function input_line(chan)
     {function build_result(buf,pos,param)
       {var pos$0=pos,param$0=param;
        for(;;)
         {if(param$0)
           {var tl=param$0[2],hd=param$0[1],len=caml_ml_bytes_length(hd);
            caml_blit_bytes(hd,0,buf,pos$0 - len | 0,len);
            var pos$1=pos$0 - len | 0,pos$0=pos$1,param$0=tl;
            continue}
          return buf}}
      var accu=0,len=0;
      for(;;)
       {var n=runtime.caml_ml_input_scan_line(chan);
        if(0 === n)
         {if(! accu)throw End_of_file;
          var _BH_=build_result(caml_create_bytes(len),len,accu)}
        else
         {if(! (0 < n))
           {var beg=caml_create_bytes(- n | 0);
            caml_ml_input(chan,beg,0,- n | 0);
            var len$1=len - n | 0,accu$0=[0,beg,accu],accu=accu$0,len=len$1;
            continue}
          var res=caml_create_bytes(n - 1 | 0);
          caml_ml_input(chan,res,0,n - 1 | 0);
          caml_ml_input_char(chan);
          if(accu)
           var
            len$0=(len + n | 0) - 1 | 0,
            _BH_=build_result(caml_create_bytes(len$0),len$0,[0,res,accu]);
          else
           var _BH_=res}
        return caml_string_of_bytes(_BH_)}}
    function close_in_noerr(ic)
     {try
       {var _BF_=caml_ml_close_channel(ic);return _BF_}
      catch(_BG_){return 0}}
    function print_char(c){return caml_ml_output_char(stdout,c)}
    function print_string(s){return output_string(stdout,s)}
    function print_bytes(s){return output_bytes(stdout,s)}
    function print_int(i)
     {return output_string(stdout,caml_string_of_jsbytes("" + i))}
    function print_float(f){return output_string(stdout,to_string(f))}
    function print_endline(s)
     {output_string(stdout,s);
      caml_ml_output_char(stdout,10);
      return caml_ml_flush(stdout)}
    function print_newline(param)
     {caml_ml_output_char(stdout,10);return caml_ml_flush(stdout)}
    function prerr_char(c){return caml_ml_output_char(stderr,c)}
    function prerr_string(s){return output_string(stderr,s)}
    function prerr_bytes(s){return output_bytes(stderr,s)}
    function prerr_int(i)
     {return output_string(stderr,caml_string_of_jsbytes("" + i))}
    function prerr_float(f){return output_string(stderr,to_string(f))}
    function prerr_endline(s)
     {output_string(stderr,s);
      caml_ml_output_char(stderr,10);
      return caml_ml_flush(stderr)}
    function prerr_newline(param)
     {caml_ml_output_char(stderr,10);return caml_ml_flush(stderr)}
    function read_line(param){caml_ml_flush(stdout);return input_line(stdin)}
    function read_int(param){return caml_int_of_string(read_line(0))}
    function read_int_opt(param){return int_of_string_opt(read_line(0))}
    function read_float(param){return caml_float_of_string(read_line(0))}
    function read_float_opt(param){return of_string_opt(read_line(0))}
    function string_of_format(param){var str=param[2];return str}
    function symbol$0(param,_BD_)
     {var
       str2=_BD_[2],
       fmt2=_BD_[1],
       str1=param[2],
       fmt1=param[1],
       _BE_=symbol(str1,symbol(cst$0,str2));
      return [0,concat_fmt(fmt1,fmt2),_BE_]}
    var exit_function=[0,flush_all];
    function at_exit(f)
     {for(;;)
       {var
         f_yet_to_run=[0,1],
         old_exit=exit_function[1],
         new_exit$0=
          function(f_yet_to_run,old_exit)
           {function new_exit(param)
             {if(compare_and_set(f_yet_to_run,1,0))caml_call1(f,0);
              return caml_call1(old_exit,0)}
            return new_exit},
         new_exit=new_exit$0(f_yet_to_run,old_exit),
         success=compare_and_set(exit_function,old_exit,new_exit),
         _BC_=1 - success;
        if(_BC_)continue;
        return _BC_}}
    function do_at_exit(param){return caml_call1(exit_function[1],0)}
    function exit(retcode)
     {do_at_exit(0);return runtime.caml_sys_exit(retcode)}
    if(runtime.caml_sys_const_naked_pointers_checked(0))
     at_exit(function(_BB_){return runtime.caml_gc_major(_BB_)});
    var
     set_binary_mode_in=caml_ml_set_binary_mode,
     close_in=caml_ml_close_channel,
     in_channel_length=caml_ml_channel_size,
     pos_in=runtime.caml_ml_pos_in,
     seek_in=runtime.caml_ml_seek_in,
     input_value=caml_input_value,
     input_binary_int=runtime.caml_ml_input_int,
     input_byte=caml_ml_input_char,
     input_char=caml_ml_input_char,
     set_binary_mode_out=caml_ml_set_binary_mode,
     out_channel_length=caml_ml_channel_size,
     pos_out=runtime.caml_ml_pos_out,
     seek_out=runtime.caml_ml_seek_out,
     output_binary_int=runtime.caml_ml_output_int,
     output_byte=caml_ml_output_char,
     output_char=caml_ml_output_char,
     flush=caml_ml_flush,
     Stdlib=
      [0,
       invalid_arg,
       failwith,
       Exit,
       Match_failure,
       Assert_failure,
       Invalid_argument,
       Failure,
       Not_found,
       Out_of_memory,
       Stack_overflow,
       Sys_error,
       End_of_file,
       Division_by_zero,
       Sys_blocked_io,
       Undefined_recursive_module,
       min,
       max,
       abs,
       max_int,
       min_int,
       lnot,
       infinity,
       neg_infinity,
       nan,
       max_float,
       min_float,
       epsilon,
       symbol,
       char_of_int,
       string_of_bool,
       bool_of_string_opt,
       bool_of_string,
       string_of_int,
       int_of_string_opt,
       to_string,
       of_string_opt,
       append,
       stdin,
       stdout,
       stderr,
       print_char,
       print_string,
       print_bytes,
       print_int,
       print_float,
       print_endline,
       print_newline,
       prerr_char,
       prerr_string,
       prerr_bytes,
       prerr_int,
       prerr_float,
       prerr_endline,
       prerr_newline,
       read_line,
       read_int_opt,
       read_int,
       read_float_opt,
       read_float,
       open_out,
       open_out_bin,
       open_out_gen,
       flush,
       flush_all,
       output_char,
       output_string,
       output_bytes,
       output,
       output_substring,
       output_byte,
       output_binary_int,
       output_value,
       seek_out,
       pos_out,
       out_channel_length,
       close_out,
       close_out_noerr,
       set_binary_mode_out,
       open_in,
       open_in_bin,
       open_in_gen,
       input_char,
       input_line,
       input,
       really_input,
       really_input_string,
       input_byte,
       input_binary_int,
       input_value,
       seek_in,
       pos_in,
       in_channel_length,
       close_in,
       close_in_noerr,
       set_binary_mode_in,
       [0,
        runtime.caml_ml_seek_out_64,
        runtime.caml_ml_pos_out_64,
        caml_ml_channel_size_64,
        runtime.caml_ml_seek_in_64,
        runtime.caml_ml_pos_in_64,
        caml_ml_channel_size_64],
       string_of_format,
       symbol$0,
       exit,
       at_exit,
       valid_float_lexem,
       unsafe_really_input,
       do_at_exit];
    caml_register_global(758,Stdlib,"Stdlib");
    var
     Exit$0=[248,cst_Stdlib_Pervasives_Exit,caml_fresh_oo_id(0)],
     Stdlib_pervasives=
      [0,
       invalid_arg,
       failwith,
       Exit$0,
       min,
       max,
       abs,
       max_int,
       min_int,
       lnot,
       infinity,
       neg_infinity,
       nan,
       max_float,
       min_float,
       epsilon,
       symbol,
       char_of_int,
       string_of_bool,
       bool_of_string,
       bool_of_string_opt,
       string_of_int,
       int_of_string_opt,
       to_string,
       of_string_opt,
       append,
       stdin,
       stdout,
       stderr,
       print_char,
       print_string,
       print_bytes,
       print_int,
       print_float,
       print_endline,
       print_newline,
       prerr_char,
       prerr_string,
       prerr_bytes,
       prerr_int,
       prerr_float,
       prerr_endline,
       prerr_newline,
       read_line,
       read_int,
       read_int_opt,
       read_float,
       read_float_opt,
       open_out,
       open_out_bin,
       open_out_gen,
       flush,
       flush_all,
       output_char,
       output_string,
       output_bytes,
       output,
       output_substring,
       output_byte,
       output_binary_int,
       output_value,
       seek_out,
       pos_out,
       out_channel_length,
       close_out,
       close_out_noerr,
       set_binary_mode_out,
       open_in,
       open_in_bin,
       open_in_gen,
       input_char,
       input_line,
       input,
       really_input,
       really_input_string,
       input_byte,
       input_binary_int,
       input_value,
       seek_in,
       pos_in,
       in_channel_length,
       close_in,
       close_in_noerr,
       set_binary_mode_in,
       string_of_format,
       symbol$0,
       exit,
       at_exit,
       valid_float_lexem,
       do_at_exit];
    caml_register_global(759,Stdlib_pervasives,"Stdlib__pervasives");
    function empty(param){return 0}
    function return$0(x,param){return [0,x,empty]}
    function cons(x,next,param){return [0,x,next]}
    function append$0(seq1,seq2,param)
     {var match=caml_call1(seq1,0);
      if(match)
       {var next=match[2],x=match[1];
        return [0,x,function(_BA_){return append$0(next,seq2,_BA_)}]}
      return caml_call1(seq2,0)}
    function map(f,seq,param)
     {var match=caml_call1(seq,0);
      if(match)
       {var
         next=match[2],
         x=match[1],
         _By_=function(_Bz_){return map(f,next,_Bz_)};
        return [0,caml_call1(f,x),_By_]}
      return 0}
    function filter_map(f,seq,param)
     {var seq$0=seq;
      for(;;)
       {var match=caml_call1(seq$0,0);
        if(match)
         {var next=match[2],x=match[1],match$0=caml_call1(f,x);
          if(match$0)
           {var y=match$0[1];
            return [0,y,function(_Bx_){return filter_map(f,next,_Bx_)}]}
          var seq$0=next;
          continue}
        return 0}}
    function filter(f,seq,param)
     {var seq$0=seq;
      for(;;)
       {var match=caml_call1(seq$0,0);
        if(match)
         {var next=match[2],x=match[1];
          if(caml_call1(f,x))
           return [0,x,function(_Bw_){return filter(f,next,_Bw_)}];
          var seq$0=next;
          continue}
        return 0}}
    function flat_map$0(counter,f,seq,param)
     {var match=caml_call1(seq,0);
      if(match)
       {var next=match[2],x=match[1],_Bv_=caml_call1(f,x),_Bu_=0;
        if(counter < 50)
         {var counter$0=counter + 1 | 0;
          return flat_map_app$0(counter$0,f,_Bv_,next,_Bu_)}
        return caml_trampoline_return(flat_map_app$0,[0,f,_Bv_,next,_Bu_])}
      return 0}
    function flat_map_app$0(counter,f,seq,tail,param)
     {var match=caml_call1(seq,0);
      if(match)
       {var next=match[2],x=match[1];
        return [0,x,function(_Bt_){return flat_map_app(f,next,tail,_Bt_)}]}
      var _Bs_=0;
      if(counter < 50)
       {var counter$0=counter + 1 | 0;
        return flat_map$0(counter$0,f,tail,_Bs_)}
      return caml_trampoline_return(flat_map$0,[0,f,tail,_Bs_])}
    function flat_map(f,seq,param)
     {return caml_trampoline(flat_map$0(0,f,seq,param))}
    function flat_map_app(f,seq,tail,param)
     {return caml_trampoline(flat_map_app$0(0,f,seq,tail,param))}
    function fold_left(f,acc,seq)
     {var acc$0=acc,seq$0=seq;
      for(;;)
       {var match=caml_call1(seq$0,0);
        if(match)
         {var
           next=match[2],
           x=match[1],
           acc$1=caml_call2(f,acc$0,x),
           acc$0=acc$1,
           seq$0=next;
          continue}
        return acc$0}}
    function iter(f,seq)
     {var seq$0=seq;
      for(;;)
       {var match=caml_call1(seq$0,0);
        if(match)
         {var next=match[2],x=match[1];
          caml_call1(f,x);
          var seq$0=next;
          continue}
        return 0}}
    function unfold(f,u,param)
     {var match=caml_call1(f,u);
      if(match)
       {var match$0=match[1],u$0=match$0[2],x=match$0[1];
        return [0,x,function(_Br_){return unfold(f,u$0,_Br_)}]}
      return 0}
    var
     Stdlib_seq=
      [0,
       empty,
       return$0,
       cons,
       append$0,
       map,
       filter,
       filter_map,
       flat_map,
       fold_left,
       iter,
       unfold];
    caml_register_global(760,Stdlib_seq,"Stdlib__seq");
    var none=0;
    function some(v){return [0,v]}
    function value(o,default$0){if(o){var v=o[1];return v}return default$0}
    function get$0(param)
     {if(param){var v=param[1];return v}
      return invalid_arg(cst_option_is_None)}
    function bind(o,f){if(o){var v=o[1];return caml_call1(f,v)}return 0}
    function join(param){if(param){var o=param[1];return o}return 0}
    function map$0(f,o){if(o){var v=o[1];return [0,caml_call1(f,v)]}return 0}
    function fold(none,some,param)
     {if(param){var v=param[1];return caml_call1(some,v)}return none}
    function iter$0(f,param)
     {if(param){var v=param[1];return caml_call1(f,v)}return 0}
    function is_none(param){return param?0:1}
    function is_some(param){return param?1:0}
    function equal(eq,o0,o1)
     {if(o0)
       {if(o1){var v1=o1[1],v0=o0[1];return caml_call2(eq,v0,v1)}}
      else
       if(! o1)return 1;
      return 0}
    function compare(cmp,o0,o1)
     {if(o0)
       {var _Bq_=o0[1];
        if(o1){var v1=o1[1];return caml_call2(cmp,_Bq_,v1)}
        return 1}
      return o1?-1:0}
    function to_result(none,param)
     {if(param){var v=param[1];return [0,v]}return [1,none]}
    function to_list(param){if(param){var v=param[1];return [0,v,0]}return 0}
    function to_seq(param)
     {if(param){var v=param[1];return function(_Bp_){return return$0(v,_Bp_)}}
      return empty}
    var
     Stdlib_option=
      [0,
       none,
       some,
       value,
       get$0,
       bind,
       join,
       map$0,
       fold,
       iter$0,
       is_none,
       is_some,
       equal,
       compare,
       to_result,
       to_list,
       to_seq];
    caml_register_global(761,Stdlib_option,"Stdlib__option");
    function left(v){return [0,v]}
    function right(v){return [1,v]}
    function is_left(param){return 0 === param[0]?1:0}
    function is_right(param){return 0 === param[0]?0:1}
    function find_left(param)
     {if(0 === param[0]){var v=param[1];return [0,v]}return 0}
    function find_right(param)
     {if(0 === param[0])return 0;var v=param[1];return [0,v]}
    function map_left(f,e)
     {if(0 === e[0]){var v=e[1];return [0,caml_call1(f,v)]}return e}
    function map_right(f,e)
     {if(0 === e[0])return e;var v=e[1];return [1,caml_call1(f,v)]}
    function map$1(left,right,param)
     {if(0 === param[0]){var v=param[1];return [0,caml_call1(left,v)]}
      var v$0=param[1];
      return [1,caml_call1(right,v$0)]}
    function fold$0(left,right,param)
     {if(0 === param[0]){var v=param[1];return caml_call1(left,v)}
      var v$0=param[1];
      return caml_call1(right,v$0)}
    function equal$0(left,right,e1,match)
     {if(0 === e1[0])
       {var _Bn_=e1[1];
        if(0 === match[0]){var v2=match[1];return caml_call2(left,_Bn_,v2)}}
      else
       {var _Bo_=e1[1];
        if(0 !== match[0])
         {var v2$0=match[1];return caml_call2(right,_Bo_,v2$0)}}
      return 0}
    function compare$0(left,right,e1,match)
     {if(0 === e1[0])
       {var _Bl_=e1[1];
        if(0 === match[0]){var v2=match[1];return caml_call2(left,_Bl_,v2)}
        return -1}
      var _Bm_=e1[1];
      if(0 === match[0])return 1;
      var v2$0=match[1];
      return caml_call2(right,_Bm_,v2$0)}
    var
     Stdlib_either=
      [0,
       left,
       right,
       is_left,
       is_right,
       find_left,
       find_right,
       map_left,
       map_right,
       map$1,
       fold$0,
       fold$0,
       fold$0,
       equal$0,
       compare$0];
    caml_register_global(762,Stdlib_either,"Stdlib__either");
    function ok(v){return [0,v]}
    function error(e){return [1,e]}
    function value$0(r,default$0)
     {if(0 === r[0]){var v=r[1];return v}return default$0}
    function get_ok(param)
     {if(0 === param[0]){var v=param[1];return v}
      return invalid_arg(cst_result_is_Error)}
    function get_error(param)
     {if(0 === param[0])return invalid_arg(cst_result_is_Ok);
      var e=param[1];
      return e}
    function bind$0(r,f)
     {if(0 === r[0]){var v=r[1];return caml_call1(f,v)}return r}
    function join$0(e){if(0 === e[0]){var r=e[1];return r}return e}
    function map$2(f,e)
     {if(0 === e[0]){var v=e[1];return [0,caml_call1(f,v)]}return e}
    function map_error(f,v)
     {if(0 === v[0])return v;var e=v[1];return [1,caml_call1(f,e)]}
    function fold$1(ok,error,param)
     {if(0 === param[0]){var v=param[1];return caml_call1(ok,v)}
      var e=param[1];
      return caml_call1(error,e)}
    function iter$1(f,param)
     {if(0 === param[0]){var v=param[1];return caml_call1(f,v)}return 0}
    function iter_error(f,param)
     {if(0 === param[0])return 0;var e=param[1];return caml_call1(f,e)}
    function is_ok(param){return 0 === param[0]?1:0}
    function is_error(param){return 0 === param[0]?0:1}
    function equal$1(ok,error,r0,match)
     {if(0 === r0[0])
       {var _Bj_=r0[1];
        if(0 === match[0]){var v1=match[1];return caml_call2(ok,_Bj_,v1)}}
      else
       {var _Bk_=r0[1];
        if(0 !== match[0]){var e1=match[1];return caml_call2(error,_Bk_,e1)}}
      return 0}
    function compare$1(ok,error,r0,match)
     {if(0 === r0[0])
       {var _Bh_=r0[1];
        if(0 === match[0]){var v1=match[1];return caml_call2(ok,_Bh_,v1)}
        return -1}
      var _Bi_=r0[1];
      if(0 === match[0])return 1;
      var e1=match[1];
      return caml_call2(error,_Bi_,e1)}
    function to_option(param)
     {if(0 === param[0]){var v=param[1];return [0,v]}return 0}
    function to_list$0(param)
     {if(0 === param[0]){var v=param[1];return [0,v,0]}return 0}
    function to_seq$0(param)
     {if(0 === param[0])
       {var v=param[1];return function(_Bg_){return return$0(v,_Bg_)}}
      return empty}
    var
     Stdlib_result=
      [0,
       ok,
       error,
       value$0,
       get_ok,
       get_error,
       bind$0,
       join$0,
       map$2,
       map_error,
       fold$1,
       iter$1,
       iter_error,
       is_ok,
       is_error,
       equal$1,
       compare$1,
       to_option,
       to_list$0,
       to_seq$0];
    caml_register_global(763,Stdlib_result,"Stdlib__result");
    function equal$2(_Bf_,_Be_){return _Bf_ === _Be_?1:0}
    var compare$2=caml_int_compare;
    function to_float(param){return param?1.:0.}
    function to_string$0(param){return param?cst_true$2:cst_false$2}
    function _m_(_Bd_){return _Bd_}
    var
     Stdlib_bool=
      [0,
       function(_Bc_){return 1 - _Bc_},
       equal$2,
       compare$2,
       _m_,
       to_float,
       to_string$0];
    caml_register_global(764,Stdlib_bool,"Stdlib__bool");
    function chr(n)
     {if(0 <= n && ! (255 < n))return n;return invalid_arg(cst_Char_chr)}
    function escaped(c)
     {var switch$0=0;
      if(40 <= c)
       {if(92 === c)return cst$1;if(! (127 <= c))switch$0 = 1}
      else
       if(32 <= c)
        {if(39 <= c)return cst$2;switch$0 = 1}
       else
        if(! (14 <= c))
         switch(c)
          {case 8:return cst_b;
           case 9:return cst_t;
           case 10:return cst_n;
           case 13:return cst_r
           }
      if(switch$0)
       {var s$0=caml_create_bytes(1);
        caml_bytes_unsafe_set(s$0,0,c);
        return caml_string_of_bytes(s$0)}
      var s=caml_create_bytes(4);
      caml_bytes_unsafe_set(s,0,92);
      caml_bytes_unsafe_set(s,1,48 + (c / 100 | 0) | 0);
      caml_bytes_unsafe_set(s,2,48 + ((c / 10 | 0) % 10 | 0) | 0);
      caml_bytes_unsafe_set(s,3,48 + (c % 10 | 0) | 0);
      return caml_string_of_bytes(s)}
    function lowercase(c)
     {var _Bb_=c - 192 | 0,switch$0=0;
      if(30 < _Bb_ >>> 0)
       {if(! (25 < (_Bb_ + 127 | 0) >>> 0))switch$0 = 1}
      else
       if(23 !== _Bb_)switch$0 = 1;
      return switch$0?c + 32 | 0:c}
    function uppercase(c)
     {var _Ba_=c - 224 | 0,switch$0=0;
      if(30 < _Ba_ >>> 0)
       {if(! (25 < (_Ba_ + 127 | 0) >>> 0))switch$0 = 1}
      else
       if(23 !== _Ba_)switch$0 = 1;
      return switch$0?c - 32 | 0:c}
    function lowercase_ascii(c)
     {var switcher=c - 65 | 0;return 25 < switcher >>> 0?c:c + 32 | 0}
    function uppercase_ascii(c)
     {var switcher=c - 97 | 0;return 25 < switcher >>> 0?c:c - 32 | 0}
    function compare$3(c1,c2){return c1 - c2 | 0}
    function equal$3(c1,c2){return 0 === (c1 - c2 | 0)?1:0}
    var
     Stdlib_char=
      [0,
       chr,
       escaped,
       lowercase,
       uppercase,
       lowercase_ascii,
       uppercase_ascii,
       compare$3,
       equal$3];
    caml_register_global(765,Stdlib_char,"Stdlib__char");
    var
     min$0=0,
     max$0=1114111,
     lo_bound=55295,
     hi_bound=57344,
     bom=65279,
     rep=65533;
    function succ(u)
     {return u === 55295
              ?hi_bound
              :u === 1114111?invalid_arg(err_no_succ):u + 1 | 0}
    function pred(u)
     {return u === 57344?lo_bound:u === 0?invalid_arg(err_no_pred):u - 1 | 0}
    function is_valid(i)
     {var _A8_=0 <= i?1:0,_A9_=_A8_?i <= 55295?1:0:_A8_;
      if(_A9_)
       var _A__=_A9_;
      else
       var _A$_=57344 <= i?1:0,_A__=_A$_?i <= 1114111?1:0:_A$_;
      return _A__}
    function of_int(i)
     {return is_valid(i)
              ?i
              :invalid_arg
                (symbol
                  (caml_format_int(cst_X,i),cst_is_not_an_Unicode_scalar_v))}
    function is_char(u){return u < 256?1:0}
    function of_char(c){return c}
    function to_char(u)
     {return 255 < u
              ?invalid_arg
                (symbol
                  (cst_U,
                   symbol
                    (caml_format_int(cst_04X,u),cst_is_not_a_latin1_character)))
              :u}
    function unsafe_to_char(_A7_){return _A7_}
    function equal$4(_A6_,_A5_){return _A6_ === _A5_?1:0}
    var compare$4=caml_int_compare;
    function hash(_A4_){return _A4_}
    function _n_(_A3_){return _A3_}
    var
     Stdlib_uchar=
      [0,
       min$0,
       max$0,
       bom,
       rep,
       succ,
       pred,
       is_valid,
       of_int,
       function(_A2_){return _A2_},
       _n_,
       is_char,
       of_char,
       to_char,
       unsafe_to_char,
       equal$4,
       compare$4,
       hash];
    caml_register_global(766,Stdlib_uchar,"Stdlib__uchar");
    var
     executable_name=runtime.caml_sys_executable_name(0),
     match=runtime.caml_sys_get_config(0),
     os_type=match[1],
     match$0=runtime.caml_sys_const_backend_type(0),
     unix=runtime.caml_sys_const_ostype_unix(0),
     win32=runtime.caml_sys_const_ostype_win32(0),
     cygwin=runtime.caml_sys_const_ostype_cygwin(0),
     max_array_length=runtime.caml_sys_const_max_wosize(0),
     max_floatarray_length=max_array_length / 2 | 0,
     max_string_length=(4 * max_array_length | 0) - 1 | 0,
     big_endian=0,
     match$1=32,
     int_size=32;
    function getenv_opt(s)
     {try
       {var _A0_=[0,caml_sys_getenv(s)];return _A0_}
      catch(_A1_)
       {_A1_ = caml_wrap_exception(_A1_);
        if(_A1_ === Not_found)return 0;
        throw _A1_}}
    var interactive=[0,0];
    function set_signal(sig_num,sig_beh){return 0}
    var
     Break=[248,cst_Stdlib_Sys_Break,caml_fresh_oo_id(0)],
     sigabrt=-1,
     sigalrm=-2,
     sigfpe=-3,
     sighup=-4,
     sigill=-5,
     sigint=-6,
     sigkill=-7,
     sigpipe=-8,
     sigquit=-9,
     sigsegv=-10,
     sigterm=-11,
     sigusr1=-12,
     sigusr2=-13,
     sigchld=-14,
     sigcont=-15,
     sigstop=-16,
     sigtstp=-17,
     sigttin=-18,
     sigttou=-19,
     sigvtalrm=-20,
     sigprof=-21,
     sigbus=-22,
     sigpoll=-23,
     sigsys=-24,
     sigtrap=-25,
     sigurg=-26,
     sigxcpu=-27,
     sigxfsz=-28;
    function catch_break(on){return on?0:0}
    function Make(_AZ_,_AY_){return [0,1]}
    var
     Immediate64=[0,Make],
     Stdlib_sys=
      [0,
       executable_name,
       getenv_opt,
       interactive,
       os_type,
       match$0,
       unix,
       win32,
       cygwin,
       match$1,
       int_size,
       big_endian,
       max_string_length,
       max_array_length,
       max_floatarray_length,
       set_signal,
       sigabrt,
       sigalrm,
       sigfpe,
       sighup,
       sigill,
       sigint,
       sigkill,
       sigpipe,
       sigquit,
       sigsegv,
       sigterm,
       sigusr1,
       sigusr2,
       sigchld,
       sigcont,
       sigstop,
       sigtstp,
       sigttin,
       sigttou,
       sigvtalrm,
       sigprof,
       sigbus,
       sigpoll,
       sigsys,
       sigtrap,
       sigurg,
       sigxcpu,
       sigxfsz,
       Break,
       catch_break,
       ocaml_version,
       runtime.caml_ml_enable_runtime_warnings,
       runtime.caml_ml_runtime_warnings_enabled,
       Immediate64];
    caml_register_global(767,Stdlib_sys,"Stdlib__sys");
    function length(l)
     {var len=0,param=l;
      for(;;)
       {if(param)
         {var param$0=param[2],len$0=len + 1 | 0,len=len$0,param=param$0;
          continue}
        return len}}
    function cons$0(a,l){return [0,a,l]}
    function hd(param)
     {if(param){var a=param[1];return a}return failwith(cst_hd)}
    function tl(param)
     {if(param){var l=param[2];return l}return failwith(cst_tl)}
    function nth(l,n)
     {if(0 <= n)
       {var l$0=l,n$0=n;
        for(;;)
         {if(l$0)
           {var l$1=l$0[2],a=l$0[1];
            if(0 === n$0)return a;
            var n$1=n$0 - 1 | 0,l$0=l$1,n$0=n$1;
            continue}
          return failwith(cst_nth)}}
      return invalid_arg(cst_List_nth)}
    function nth_opt(l,n)
     {if(0 <= n)
       {var l$0=l,n$0=n;
        for(;;)
         {if(l$0)
           {var l$1=l$0[2],a=l$0[1];
            if(0 === n$0)return [0,a];
            var n$1=n$0 - 1 | 0,l$0=l$1,n$0=n$1;
            continue}
          return 0}}
      return invalid_arg(cst_List_nth$0)}
    function rev_append(l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {var l1$1=l1$0[2],a=l1$0[1],l2$1=[0,a,l2$0],l1$0=l1$1,l2$0=l2$1;
          continue}
        return l2$0}}
    function rev(l){return rev_append(l,0)}
    function init_aux(i,n,f)
     {if(n <= i)return 0;
      var r=caml_call1(f,i);
      return [0,r,init_aux(i + 1 | 0,n,f)]}
    var rev_init_threshold=typeof match$0 === "number"?10000:50;
    function init(len,f)
     {if(0 <= len)
       {if(rev_init_threshold < len)
         {var acc=0,i=0;
          for(;;)
           {if(len <= i)return rev(acc);
            var i$0=i + 1 | 0,acc$0=[0,caml_call1(f,i),acc],acc=acc$0,i=i$0;
            continue}}
        return init_aux(0,len,f)}
      return invalid_arg(cst_List_init)}
    function flatten(param)
     {if(param){var r=param[2],l=param[1];return append(l,flatten(r))}
      return 0}
    function map$3(f,param)
     {if(param)
       {var l=param[2],a=param[1],r=caml_call1(f,a);return [0,r,map$3(f,l)]}
      return 0}
    function _o_(i,f,param)
     {if(param)
       {var l=param[2],a=param[1],r=caml_call2(f,i,a);
        return [0,r,_o_(i + 1 | 0,f,l)]}
      return 0}
    function mapi(f,l){return _o_(0,f,l)}
    function rev_map(f,param)
     {var accu=0,param$0=param;
      for(;;)
       {if(param$0)
         {var
           l=param$0[2],
           a=param$0[1],
           accu$0=[0,caml_call1(f,a),accu],
           accu=accu$0,
           param$0=l;
          continue}
        return accu}}
    function iter$2(f,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],a=param$0[1];
          caml_call1(f,a);
          var param$0=l;
          continue}
        return 0}}
    function iteri(f,l$0)
     {var i=0,param=l$0;
      for(;;)
       {if(param)
         {var l=param[2],a=param[1];
          caml_call2(f,i,a);
          var i$0=i + 1 | 0,i=i$0,param=l;
          continue}
        return 0}}
    function fold_left$0(f,accu,l)
     {var accu$0=accu,l$0=l;
      for(;;)
       {if(l$0)
         {var
           l$1=l$0[2],
           a=l$0[1],
           accu$1=caml_call2(f,accu$0,a),
           accu$0=accu$1,
           l$0=l$1;
          continue}
        return accu$0}}
    function fold_right(f,l,accu)
     {if(l){var l$0=l[2],a=l[1];return caml_call2(f,a,fold_right(f,l$0,accu))}
      return accu}
    function map2(f,l1,l2)
     {if(l1)
       {if(l2)
         {var l2$0=l2[2],a2=l2[1],l1$0=l1[2],a1=l1[1],r=caml_call2(f,a1,a2);
          return [0,r,map2(f,l1$0,l2$0)]}}
      else
       if(! l2)return 0;
      return invalid_arg(cst_List_map2)}
    function rev_map2(f,l1,l2)
     {var accu=0,l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var
             l2$1=l2$0[2],
             a2=l2$0[1],
             l1$1=l1$0[2],
             a1=l1$0[1],
             accu$0=[0,caml_call2(f,a1,a2),accu],
             accu=accu$0,
             l1$0=l1$1,
             l2$0=l2$1;
            continue}}
        else
         if(! l2$0)return accu;
        return invalid_arg(cst_List_rev_map2)}}
    function iter2(f,l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var l2$1=l2$0[2],a2=l2$0[1],l1$1=l1$0[2],a1=l1$0[1];
            caml_call2(f,a1,a2);
            var l1$0=l1$1,l2$0=l2$1;
            continue}}
        else
         if(! l2$0)return 0;
        return invalid_arg(cst_List_iter2)}}
    function fold_left2(f,accu,l1,l2)
     {var accu$0=accu,l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var
             l2$1=l2$0[2],
             a2=l2$0[1],
             l1$1=l1$0[2],
             a1=l1$0[1],
             accu$1=caml_call3(f,accu$0,a1,a2),
             accu$0=accu$1,
             l1$0=l1$1,
             l2$0=l2$1;
            continue}}
        else
         if(! l2$0)return accu$0;
        return invalid_arg(cst_List_fold_left2)}}
    function fold_right2(f,l1,l2,accu)
     {if(l1)
       {if(l2)
         {var l2$0=l2[2],a2=l2[1],l1$0=l1[2],a1=l1[1];
          return caml_call3(f,a1,a2,fold_right2(f,l1$0,l2$0,accu))}}
      else
       if(! l2)return accu;
      return invalid_arg(cst_List_fold_right2)}
    function for_all(p,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],a=param$0[1],_AX_=caml_call1(p,a);
          if(_AX_){var param$0=l;continue}
          return _AX_}
        return 1}}
    function exists(p,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],a=param$0[1],_AW_=caml_call1(p,a);
          if(_AW_)return _AW_;
          var param$0=l;
          continue}
        return 0}}
    function for_all2(p,l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var
             l2$1=l2$0[2],
             a2=l2$0[1],
             l1$1=l1$0[2],
             a1=l1$0[1],
             _AV_=caml_call2(p,a1,a2);
            if(_AV_){var l1$0=l1$1,l2$0=l2$1;continue}
            return _AV_}}
        else
         if(! l2$0)return 1;
        return invalid_arg(cst_List_for_all2)}}
    function exists2(p,l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var
             l2$1=l2$0[2],
             a2=l2$0[1],
             l1$1=l1$0[2],
             a1=l1$0[1],
             _AU_=caml_call2(p,a1,a2);
            if(_AU_)return _AU_;
            var l1$0=l1$1,l2$0=l2$1;
            continue}}
        else
         if(! l2$0)return 0;
        return invalid_arg(cst_List_exists2)}}
    function mem(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],a=param$0[1],_AT_=0 === caml_compare(a,x)?1:0;
          if(_AT_)return _AT_;
          var param$0=l;
          continue}
        return 0}}
    function memq(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],a=param$0[1],_AS_=a === x?1:0;
          if(_AS_)return _AS_;
          var param$0=l;
          continue}
        return 0}}
    function assoc(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],match=param$0[1],b=match[2],a=match[1];
          if(0 === caml_compare(a,x))return b;
          var param$0=l;
          continue}
        throw Not_found}}
    function assoc_opt(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],match=param$0[1],b=match[2],a=match[1];
          if(0 === caml_compare(a,x))return [0,b];
          var param$0=l;
          continue}
        return 0}}
    function assq(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],match=param$0[1],b=match[2],a=match[1];
          if(a === x)return b;
          var param$0=l;
          continue}
        throw Not_found}}
    function assq_opt(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],match=param$0[1],b=match[2],a=match[1];
          if(a === x)return [0,b];
          var param$0=l;
          continue}
        return 0}}
    function mem_assoc(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var
           l=param$0[2],
           match=param$0[1],
           a=match[1],
           _AR_=0 === caml_compare(a,x)?1:0;
          if(_AR_)return _AR_;
          var param$0=l;
          continue}
        return 0}}
    function mem_assq(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],match=param$0[1],a=match[1],_AQ_=a === x?1:0;
          if(_AQ_)return _AQ_;
          var param$0=l;
          continue}
        return 0}}
    function remove_assoc(x,param)
     {if(param)
       {var l=param[2],pair=param[1],a=pair[1];
        return 0 === caml_compare(a,x)?l:[0,pair,remove_assoc(x,l)]}
      return 0}
    function remove_assq(x,param)
     {if(param)
       {var l=param[2],pair=param[1],a=pair[1];
        return a === x?l:[0,pair,remove_assq(x,l)]}
      return 0}
    function find(p,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],x=param$0[1];
          if(caml_call1(p,x))return x;
          var param$0=l;
          continue}
        throw Not_found}}
    function find_opt(p,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],x=param$0[1];
          if(caml_call1(p,x))return [0,x];
          var param$0=l;
          continue}
        return 0}}
    function find_map(f,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],x=param$0[1],result=caml_call1(f,x);
          if(result)return result;
          var param$0=l;
          continue}
        return 0}}
    function find_all(p)
     {var accu=0;
      return function(param$0)
       {var accu$0=accu,param=param$0;
        for(;;)
         {if(param)
           {var l=param[2],x=param[1];
            if(caml_call1(p,x))
             {var accu$1=[0,x,accu$0],accu$0=accu$1,param=l;continue}
            var param=l;
            continue}
          return rev(accu$0)}}}
    function filteri(p,param)
     {var i=0,acc=0,param$0=param;
      for(;;)
       {if(param$0)
         {var
           l=param$0[2],
           x=param$0[1],
           acc$0=caml_call2(p,i,x)?[0,x,acc]:acc,
           i$0=i + 1 | 0,
           i=i$0,
           acc=acc$0,
           param$0=l;
          continue}
        return rev(acc)}}
    function filter_map$0(f)
     {var accu=0;
      return function(param$0)
       {var accu$0=accu,param=param$0;
        for(;;)
         {if(param)
           {var l=param[2],x=param[1],match=caml_call1(f,x);
            if(match)
             {var v=match[1],accu$1=[0,v,accu$0],accu$0=accu$1,param=l;
              continue}
            var param=l;
            continue}
          return rev(accu$0)}}}
    function concat_map(f,param)
     {var acc=0,param$0=param;
      for(;;)
       {if(param$0)
         {var
           l=param$0[2],
           x=param$0[1],
           xs=caml_call1(f,x),
           acc$0=rev_append(xs,acc),
           acc=acc$0,
           param$0=l;
          continue}
        return rev(acc)}}
    function fold_left_map(f,accu,param)
     {var accu$0=accu,l_accu=0,param$0=param;
      for(;;)
       {if(param$0)
         {var
           l=param$0[2],
           x=param$0[1],
           match=caml_call2(f,accu$0,x),
           x$0=match[2],
           accu$1=match[1],
           l_accu$0=[0,x$0,l_accu],
           accu$0=accu$1,
           l_accu=l_accu$0,
           param$0=l;
          continue}
        return [0,accu$0,rev(l_accu)]}}
    function partition(p,param)
     {var yes=0,no=0,param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],x=param$0[1];
          if(caml_call1(p,x))
           {var yes$0=[0,x,yes],yes=yes$0,param$0=l;continue}
          var no$0=[0,x,no],no=no$0,param$0=l;
          continue}
        var _AP_=rev(no);
        return [0,rev(yes),_AP_]}}
    function partition_map(p,param)
     {var left=0,right=0,param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],x=param$0[1],match=caml_call1(p,x);
          if(0 === match[0])
           {var v=match[1],left$0=[0,v,left],left=left$0,param$0=l;continue}
          var v$0=match[1],right$0=[0,v$0,right],right=right$0,param$0=l;
          continue}
        var _AO_=rev(right);
        return [0,rev(left),_AO_]}}
    function split(param)
     {if(param)
       {var
         l=param[2],
         match=param[1],
         y=match[2],
         x=match[1],
         match$0=split(l),
         ry=match$0[2],
         rx=match$0[1];
        return [0,[0,x,rx],[0,y,ry]]}
      return _p_}
    function combine(l1,l2)
     {if(l1)
       {if(l2)
         {var l2$0=l2[2],a2=l2[1],l1$0=l1[2],a1=l1[1];
          return [0,[0,a1,a2],combine(l1$0,l2$0)]}}
      else
       if(! l2)return 0;
      return invalid_arg(cst_List_combine)}
    function merge(cmp,l1,match)
     {if(l1)
       {if(match)
         {var t2=match[2],h2=match[1],t1=l1[2],h1=l1[1];
          return 0 < caml_call2(cmp,h1,h2)
                  ?[0,h2,merge(cmp,l1,t2)]
                  :[0,h1,merge(cmp,t1,match)]}
        return l1}
      return match}
    function fast_sort(cmp,l)
     {function rev_sort(n,l)
       {if(2 === n)
         {if(l)
           {var _AK_=l[2];
            if(_AK_)
             {var
               tl=_AK_[2],
               x2=_AK_[1],
               x1=l[1],
               s=0 < caml_call2(cmp,x1,x2)?[0,x1,[0,x2,0]]:[0,x2,[0,x1,0]];
              return [0,s,tl]}}}
        else
         if(3 === n && l)
          {var _AM_=l[2];
           if(_AM_)
            {var _AN_=_AM_[2];
             if(_AN_)
              {var
                tl$1=_AN_[2],
                x3=_AN_[1],
                x2$0=_AM_[1],
                x1$0=l[1],
                s$0=
                 0 < caml_call2(cmp,x1$0,x2$0)
                  ?0 < caml_call2(cmp,x2$0,x3)
                    ?[0,x1$0,[0,x2$0,[0,x3,0]]]
                    :0 < caml_call2(cmp,x1$0,x3)
                      ?[0,x1$0,[0,x3,[0,x2$0,0]]]
                      :[0,x3,[0,x1$0,[0,x2$0,0]]]
                  :0 < caml_call2(cmp,x1$0,x3)
                    ?[0,x2$0,[0,x1$0,[0,x3,0]]]
                    :0 < caml_call2(cmp,x2$0,x3)
                      ?[0,x2$0,[0,x3,[0,x1$0,0]]]
                      :[0,x3,[0,x2$0,[0,x1$0,0]]];
               return [0,s$0,tl$1]}}}
        var
         n1=n >> 1,
         n2=n - n1 | 0,
         match=sort(n1,l),
         l2$0=match[2],
         s1=match[1],
         match$0=sort(n2,l2$0),
         tl$0=match$0[2],
         s2=match$0[1],
         l1=s1,
         l2=s2,
         accu=0;
        for(;;)
         {if(l1)
           {if(l2)
             {var t2=l2[2],h2=l2[1],t1=l1[2],h1=l1[1];
              if(0 < caml_call2(cmp,h1,h2))
               {var accu$0=[0,h2,accu],l2=t2,accu=accu$0;continue}
              var accu$1=[0,h1,accu],l1=t1,accu=accu$1;
              continue}
            var _AL_=rev_append(l1,accu)}
          else
           var _AL_=rev_append(l2,accu);
          return [0,_AL_,tl$0]}}
      function sort(n,l)
       {if(2 === n)
         {if(l)
           {var _AG_=l[2];
            if(_AG_)
             {var
               tl=_AG_[2],
               x2=_AG_[1],
               x1=l[1],
               s=0 < caml_call2(cmp,x1,x2)?[0,x2,[0,x1,0]]:[0,x1,[0,x2,0]];
              return [0,s,tl]}}}
        else
         if(3 === n && l)
          {var _AI_=l[2];
           if(_AI_)
            {var _AJ_=_AI_[2];
             if(_AJ_)
              {var
                tl$1=_AJ_[2],
                x3=_AJ_[1],
                x2$0=_AI_[1],
                x1$0=l[1],
                s$0=
                 0 < caml_call2(cmp,x1$0,x2$0)
                  ?0 < caml_call2(cmp,x1$0,x3)
                    ?0 < caml_call2(cmp,x2$0,x3)
                      ?[0,x3,[0,x2$0,[0,x1$0,0]]]
                      :[0,x2$0,[0,x3,[0,x1$0,0]]]
                    :[0,x2$0,[0,x1$0,[0,x3,0]]]
                  :0 < caml_call2(cmp,x2$0,x3)
                    ?0 < caml_call2(cmp,x1$0,x3)
                      ?[0,x3,[0,x1$0,[0,x2$0,0]]]
                      :[0,x1$0,[0,x3,[0,x2$0,0]]]
                    :[0,x1$0,[0,x2$0,[0,x3,0]]];
               return [0,s$0,tl$1]}}}
        var
         n1=n >> 1,
         n2=n - n1 | 0,
         match=rev_sort(n1,l),
         l2$0=match[2],
         s1=match[1],
         match$0=rev_sort(n2,l2$0),
         tl$0=match$0[2],
         s2=match$0[1],
         l1=s1,
         l2=s2,
         accu=0;
        for(;;)
         {if(l1)
           {if(l2)
             {var t2=l2[2],h2=l2[1],t1=l1[2],h1=l1[1];
              if(0 < caml_call2(cmp,h1,h2))
               {var accu$0=[0,h1,accu],l1=t1,accu=accu$0;continue}
              var accu$1=[0,h2,accu],l2=t2,accu=accu$1;
              continue}
            var _AH_=rev_append(l1,accu)}
          else
           var _AH_=rev_append(l2,accu);
          return [0,_AH_,tl$0]}}
      var len=length(l);
      return 2 <= len?sort(len,l)[1]:l}
    function sort_uniq(cmp,l)
     {function rev_sort(n,l)
       {if(2 === n)
         {if(l)
           {var _Ax_=l[2];
            if(_Ax_)
             {var
               tl=_Ax_[2],
               x2=_Ax_[1],
               x1=l[1],
               c$0=caml_call2(cmp,x1,x2),
               s=0 === c$0?[0,x1,0]:0 < c$0?[0,x1,[0,x2,0]]:[0,x2,[0,x1,0]];
              return [0,s,tl]}}}
        else
         if(3 === n && l)
          {var _Az_=l[2];
           if(_Az_)
            {var _AA_=_Az_[2];
             if(_AA_)
              {var
                tl$1=_AA_[2],
                x3=_AA_[1],
                x2$0=_Az_[1],
                x1$0=l[1],
                c$1=caml_call2(cmp,x1$0,x2$0);
               if(0 === c$1)
                var
                 c$2=caml_call2(cmp,x2$0,x3),
                 _AB_=
                  0 === c$2
                   ?[0,x2$0,0]
                   :0 < c$2?[0,x2$0,[0,x3,0]]:[0,x3,[0,x2$0,0]],
                 s$0=_AB_;
               else
                if(0 < c$1)
                 {var c$3=caml_call2(cmp,x2$0,x3);
                  if(0 === c$3)
                   var _AC_=[0,x1$0,[0,x2$0,0]];
                  else
                   if(0 < c$3)
                    var _AC_=[0,x1$0,[0,x2$0,[0,x3,0]]];
                   else
                    var
                     c$4=caml_call2(cmp,x1$0,x3),
                     _AD_=
                      0 === c$4
                       ?[0,x1$0,[0,x2$0,0]]
                       :0 < c$4
                         ?[0,x1$0,[0,x3,[0,x2$0,0]]]
                         :[0,x3,[0,x1$0,[0,x2$0,0]]],
                     _AC_=_AD_;
                  var s$0=_AC_}
                else
                 {var c$5=caml_call2(cmp,x1$0,x3);
                  if(0 === c$5)
                   var _AE_=[0,x2$0,[0,x1$0,0]];
                  else
                   if(0 < c$5)
                    var _AE_=[0,x2$0,[0,x1$0,[0,x3,0]]];
                   else
                    var
                     c$6=caml_call2(cmp,x2$0,x3),
                     _AF_=
                      0 === c$6
                       ?[0,x2$0,[0,x1$0,0]]
                       :0 < c$6
                         ?[0,x2$0,[0,x3,[0,x1$0,0]]]
                         :[0,x3,[0,x2$0,[0,x1$0,0]]],
                     _AE_=_AF_;
                  var s$0=_AE_}
               return [0,s$0,tl$1]}}}
        var
         n1=n >> 1,
         n2=n - n1 | 0,
         match=sort(n1,l),
         l2$0=match[2],
         s1=match[1],
         match$0=sort(n2,l2$0),
         tl$0=match$0[2],
         s2=match$0[1],
         l1=s1,
         l2=s2,
         accu=0;
        for(;;)
         {if(l1)
           {if(l2)
             {var t2=l2[2],h2=l2[1],t1=l1[2],h1=l1[1],c=caml_call2(cmp,h1,h2);
              if(0 === c)
               {var accu$0=[0,h1,accu],l1=t1,l2=t2,accu=accu$0;continue}
              if(0 <= c){var accu$1=[0,h2,accu],l2=t2,accu=accu$1;continue}
              var accu$2=[0,h1,accu],l1=t1,accu=accu$2;
              continue}
            var _Ay_=rev_append(l1,accu)}
          else
           var _Ay_=rev_append(l2,accu);
          return [0,_Ay_,tl$0]}}
      function sort(n,l)
       {if(2 === n)
         {if(l)
           {var _Ao_=l[2];
            if(_Ao_)
             {var
               tl=_Ao_[2],
               x2=_Ao_[1],
               x1=l[1],
               c$0=caml_call2(cmp,x1,x2),
               s=0 === c$0?[0,x1,0]:0 <= c$0?[0,x2,[0,x1,0]]:[0,x1,[0,x2,0]];
              return [0,s,tl]}}}
        else
         if(3 === n && l)
          {var _Aq_=l[2];
           if(_Aq_)
            {var _Ar_=_Aq_[2];
             if(_Ar_)
              {var
                tl$1=_Ar_[2],
                x3=_Ar_[1],
                x2$0=_Aq_[1],
                x1$0=l[1],
                c$1=caml_call2(cmp,x1$0,x2$0);
               if(0 === c$1)
                var
                 c$2=caml_call2(cmp,x2$0,x3),
                 _As_=
                  0 === c$2
                   ?[0,x2$0,0]
                   :0 <= c$2?[0,x3,[0,x2$0,0]]:[0,x2$0,[0,x3,0]],
                 s$0=_As_;
               else
                if(0 <= c$1)
                 {var c$3=caml_call2(cmp,x1$0,x3);
                  if(0 === c$3)
                   var _At_=[0,x2$0,[0,x1$0,0]];
                  else
                   if(0 <= c$3)
                    var
                     c$4=caml_call2(cmp,x2$0,x3),
                     _Au_=
                      0 === c$4
                       ?[0,x2$0,[0,x1$0,0]]
                       :0 <= c$4
                         ?[0,x3,[0,x2$0,[0,x1$0,0]]]
                         :[0,x2$0,[0,x3,[0,x1$0,0]]],
                     _At_=_Au_;
                   else
                    var _At_=[0,x2$0,[0,x1$0,[0,x3,0]]];
                  var s$0=_At_}
                else
                 {var c$5=caml_call2(cmp,x2$0,x3);
                  if(0 === c$5)
                   var _Av_=[0,x1$0,[0,x2$0,0]];
                  else
                   if(0 <= c$5)
                    var
                     c$6=caml_call2(cmp,x1$0,x3),
                     _Aw_=
                      0 === c$6
                       ?[0,x1$0,[0,x2$0,0]]
                       :0 <= c$6
                         ?[0,x3,[0,x1$0,[0,x2$0,0]]]
                         :[0,x1$0,[0,x3,[0,x2$0,0]]],
                     _Av_=_Aw_;
                   else
                    var _Av_=[0,x1$0,[0,x2$0,[0,x3,0]]];
                  var s$0=_Av_}
               return [0,s$0,tl$1]}}}
        var
         n1=n >> 1,
         n2=n - n1 | 0,
         match=rev_sort(n1,l),
         l2$0=match[2],
         s1=match[1],
         match$0=rev_sort(n2,l2$0),
         tl$0=match$0[2],
         s2=match$0[1],
         l1=s1,
         l2=s2,
         accu=0;
        for(;;)
         {if(l1)
           {if(l2)
             {var t2=l2[2],h2=l2[1],t1=l1[2],h1=l1[1],c=caml_call2(cmp,h1,h2);
              if(0 === c)
               {var accu$0=[0,h1,accu],l1=t1,l2=t2,accu=accu$0;continue}
              if(0 < c){var accu$1=[0,h1,accu],l1=t1,accu=accu$1;continue}
              var accu$2=[0,h2,accu],l2=t2,accu=accu$2;
              continue}
            var _Ap_=rev_append(l1,accu)}
          else
           var _Ap_=rev_append(l2,accu);
          return [0,_Ap_,tl$0]}}
      var len=length(l);
      return 2 <= len?sort(len,l)[1]:l}
    function compare_lengths(l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0){var l2$1=l2$0[2],l1$1=l1$0[2],l1$0=l1$1,l2$0=l2$1;continue}
          return 1}
        return l2$0?-1:0}}
    function compare_length_with(l,n)
     {var l$0=l,n$0=n;
      for(;;)
       {if(l$0)
         {var l$1=l$0[2];
          if(0 < n$0){var n$1=n$0 - 1 | 0,l$0=l$1,n$0=n$1;continue}
          return 1}
        return 0 === n$0?0:0 < n$0?-1:1}}
    function equal$5(eq,l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var
             l2$1=l2$0[2],
             a2=l2$0[1],
             l1$1=l1$0[2],
             a1=l1$0[1],
             _An_=caml_call2(eq,a1,a2);
            if(_An_){var l1$0=l1$1,l2$0=l2$1;continue}
            return _An_}}
        else
         if(! l2$0)return 1;
        return 0}}
    function compare$5(cmp,l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {var _Al_=l1$0[2],_Am_=l1$0[1];
          if(l2$0)
           {var l2$1=l2$0[2],a2=l2$0[1],c=caml_call2(cmp,_Am_,a2);
            if(0 === c){var l1$0=_Al_,l2$0=l2$1;continue}
            return c}
          return 1}
        return l2$0?-1:0}}
    function to_seq$1(l)
     {function aux(l,param)
       {if(l)
         {var tail=l[2],x=l[1];
          return [0,x,function(_Ak_){return aux(tail,_Ak_)}]}
        return 0}
      return function(_Aj_){return aux(l,_Aj_)}}
    function of_seq(seq)
     {function direct(depth,seq)
       {if(0 === depth)
         {var _Ai_=0;
          return rev(fold_left(function(acc,x){return [0,x,acc]},_Ai_,seq))}
        var match=caml_call1(seq,0);
        if(match)
         {var next=match[2],x=match[1];
          return [0,x,direct(depth - 1 | 0,next)]}
        return 0}
      return direct(500,seq)}
    var
     include$0=
      [0,
       length,
       compare_lengths,
       compare_length_with,
       cons$0,
       hd,
       tl,
       nth,
       nth_opt,
       rev,
       init,
       append,
       rev_append,
       flatten,
       flatten,
       equal$5,
       compare$5,
       iter$2,
       iteri,
       map$3,
       mapi,
       rev_map,
       filter_map$0,
       concat_map,
       fold_left_map,
       fold_left$0,
       fold_right,
       iter2,
       map2,
       rev_map2,
       fold_left2,
       fold_right2,
       for_all,
       exists,
       for_all2,
       exists2,
       mem,
       memq,
       find,
       find_opt,
       find_map,
       find_all,
       find_all,
       filteri,
       partition,
       partition_map,
       assoc,
       assoc_opt,
       assq,
       assq_opt,
       mem_assoc,
       mem_assq,
       remove_assoc,
       remove_assq,
       split,
       combine,
       fast_sort,
       fast_sort,
       fast_sort,
       sort_uniq,
       merge,
       to_seq$1,
       of_seq];
    caml_register_global(768,include$0,"Stdlib__list");
    function make$0(n,c)
     {var s=caml_create_bytes(n);caml_fill_bytes(s,0,n,c);return s}
    function init$0(n,f)
     {var s=caml_create_bytes(n),_Ag_=n - 1 | 0,_Af_=0;
      if(! (_Ag_ < 0))
       {var i=_Af_;
        for(;;)
         {caml_bytes_unsafe_set(s,i,caml_call1(f,i));
          var _Ah_=i + 1 | 0;
          if(_Ag_ !== i){var i=_Ah_;continue}
          break}}
      return s}
    var empty$0=caml_create_bytes(0);
    function copy(s)
     {var len=caml_ml_bytes_length(s),r=caml_create_bytes(len);
      caml_blit_bytes(s,0,r,0,len);
      return r}
    function to_string$1(b){return caml_string_of_bytes(copy(b))}
    function of_string(s){return copy(caml_bytes_of_string(s))}
    function sub(s,ofs,len)
     {if
       (0 <= ofs && 0 <= len && ! ((caml_ml_bytes_length(s) - len | 0) < ofs))
       {var r=caml_create_bytes(len);caml_blit_bytes(s,ofs,r,0,len);return r}
      return invalid_arg(cst_String_sub_Bytes_sub)}
    function sub_string(b,ofs,len)
     {return caml_string_of_bytes(sub(b,ofs,len))}
    function symbol$1(a,b)
     {var c=a + b | 0,_Ae_=b < 0?1:0,match=c < 0?1:0,switch$0=0;
      if(a < 0)
       {if(_Ae_ && ! match)switch$0 = 1}
      else
       if(! _Ae_ && match)switch$0 = 1;
      return switch$0?invalid_arg(cst_Bytes_extend):c}
    function extend(s,left,right)
     {var
       len=symbol$1(symbol$1(caml_ml_bytes_length(s),left),right),
       r=caml_create_bytes(len);
      if(0 <= left)
       var dstoff=left,srcoff=0;
      else
       var dstoff=0,srcoff=- left | 0;
      var cpylen=min(caml_ml_bytes_length(s) - srcoff | 0,len - dstoff | 0);
      if(0 < cpylen)caml_blit_bytes(s,srcoff,r,dstoff,cpylen);
      return r}
    function fill(s,ofs,len,c)
     {if
       (0 <= ofs && 0 <= len && ! ((caml_ml_bytes_length(s) - len | 0) < ofs))
       return caml_fill_bytes(s,ofs,len,c);
      return invalid_arg(cst_String_fill_Bytes_fill)}
    function blit(s1,ofs1,s2,ofs2,len)
     {if
       (0
        <=
        len
        &&
        0
        <=
        ofs1
        &&
        !
        ((caml_ml_bytes_length(s1) - len | 0) < ofs1)
        &&
        0
        <=
        ofs2
        &&
        !
        ((caml_ml_bytes_length(s2) - len | 0) < ofs2))
       return caml_blit_bytes(s1,ofs1,s2,ofs2,len);
      return invalid_arg(cst_Bytes_blit)}
    function blit$0(s1,ofs1,s2,ofs2,len)
     {if
       (0
        <=
        len
        &&
        0
        <=
        ofs1
        &&
        !
        ((caml_ml_string_length(s1) - len | 0) < ofs1)
        &&
        0
        <=
        ofs2
        &&
        !
        ((caml_ml_bytes_length(s2) - len | 0) < ofs2))
       return caml_blit_string(s1,ofs1,s2,ofs2,len);
      return invalid_arg(cst_String_blit_Bytes_blit_str)}
    function iter$3(f,a)
     {var _Ac_=caml_ml_bytes_length(a) - 1 | 0,_Ab_=0;
      if(! (_Ac_ < 0))
       {var i=_Ab_;
        for(;;)
         {caml_call1(f,caml_bytes_unsafe_get(a,i));
          var _Ad_=i + 1 | 0;
          if(_Ac_ !== i){var i=_Ad_;continue}
          break}}
      return 0}
    function iteri$0(f,a)
     {var _z$_=caml_ml_bytes_length(a) - 1 | 0,_z__=0;
      if(! (_z$_ < 0))
       {var i=_z__;
        for(;;)
         {caml_call2(f,i,caml_bytes_unsafe_get(a,i));
          var _Aa_=i + 1 | 0;
          if(_z$_ !== i){var i=_Aa_;continue}
          break}}
      return 0}
    function concat(sep,l)
     {if(l)
       {var seplen=caml_ml_bytes_length(sep),acc=0,param=l,pos$1=0;
        for(;;)
         {if(param)
           {var _z7_=param[1];
            if(param[2])
             {var
               tl=param[2],
               x=(caml_ml_bytes_length(_z7_) + seplen | 0) + acc | 0,
               acc$0=acc <= x?x:invalid_arg(cst_Bytes_concat),
               acc=acc$0,
               param=tl;
              continue}
            var _z9_=caml_ml_bytes_length(_z7_) + acc | 0}
          else
           var _z9_=acc;
          var dst=caml_create_bytes(_z9_),pos=pos$1,param$0=l;
          for(;;)
           {if(param$0)
             {var _z8_=param$0[1];
              if(param$0[2])
               {var tl$0=param$0[2];
                caml_blit_bytes(_z8_,0,dst,pos,caml_ml_bytes_length(_z8_));
                caml_blit_bytes
                 (sep,0,dst,pos + caml_ml_bytes_length(_z8_) | 0,seplen);
                var
                 pos$0=(pos + caml_ml_bytes_length(_z8_) | 0) + seplen | 0,
                 pos=pos$0,
                 param$0=tl$0;
                continue}
              caml_blit_bytes(_z8_,0,dst,pos,caml_ml_bytes_length(_z8_));
              return dst}
            return dst}}}
      return empty$0}
    function cat(s1,s2)
     {var
       l1=caml_ml_bytes_length(s1),
       l2=caml_ml_bytes_length(s2),
       r=caml_create_bytes(l1 + l2 | 0);
      caml_blit_bytes(s1,0,r,0,l1);
      caml_blit_bytes(s2,0,r,l1,l2);
      return r}
    function is_space(param)
     {var _z6_=param - 9 | 0,switch$0=0;
      if(4 < _z6_ >>> 0)
       {if(23 === _z6_)switch$0 = 1}
      else
       if(2 !== _z6_)switch$0 = 1;
      return switch$0?1:0}
    function trim(s)
     {var len=caml_ml_bytes_length(s),i=[0,0];
      for(;;)
       {if(i[1] < len && is_space(caml_bytes_unsafe_get(s,i[1])))
         {i[1]++;continue}
        var j=[0,len - 1 | 0];
        for(;;)
         {if(i[1] <= j[1] && is_space(caml_bytes_unsafe_get(s,j[1])))
           {j[1] += -1;continue}
          return i[1] <= j[1]?sub(s,i[1],(j[1] - i[1] | 0) + 1 | 0):empty$0}}}
    function escaped$0(s)
     {var n=[0,0],_zZ_=caml_ml_bytes_length(s) - 1 | 0,_zY_=0;
      if(! (_zZ_ < 0))
       {var i$0=_zY_;
        for(;;)
         {var match=caml_bytes_unsafe_get(s,i$0),switch$0=0;
          if(32 <= match)
           {var _z3_=match - 34 | 0,switch$1=0;
            if(58 < _z3_ >>> 0)
             {if(93 <= _z3_)switch$1 = 1}
            else
             if(56 < (_z3_ - 1 | 0) >>> 0){switch$0 = 1;switch$1 = 1}
            if(! switch$1){var _z4_=1;switch$0 = 2}}
          else
           if(11 <= match)
            {if(13 === match)switch$0 = 1}
           else
            if(8 <= match)switch$0 = 1;
          switch(switch$0){case 0:var _z4_=4;break;case 1:var _z4_=2;break}
          n[1] = n[1] + _z4_ | 0;
          var _z5_=i$0 + 1 | 0;
          if(_zZ_ !== i$0){var i$0=_z5_;continue}
          break}}
      if(n[1] === caml_ml_bytes_length(s))return copy(s);
      var s$0=caml_create_bytes(n[1]);
      n[1] = 0;
      var _z1_=caml_ml_bytes_length(s) - 1 | 0,_z0_=0;
      if(! (_z1_ < 0))
       {var i=_z0_;
        for(;;)
         {var c=caml_bytes_unsafe_get(s,i),switch$2=0;
          if(35 <= c)
           if(92 === c)
            switch$2 = 2;
           else
            if(127 <= c)switch$2 = 1;else switch$2 = 3;
          else
           if(32 <= c)
            if(34 <= c)switch$2 = 2;else switch$2 = 3;
           else
            if(14 <= c)
             switch$2 = 1;
            else
             switch(c)
              {case 8:
                caml_bytes_unsafe_set(s$0,n[1],92);
                n[1]++;
                caml_bytes_unsafe_set(s$0,n[1],98);
                break;
               case 9:
                caml_bytes_unsafe_set(s$0,n[1],92);
                n[1]++;
                caml_bytes_unsafe_set(s$0,n[1],116);
                break;
               case 10:
                caml_bytes_unsafe_set(s$0,n[1],92);
                n[1]++;
                caml_bytes_unsafe_set(s$0,n[1],110);
                break;
               case 13:
                caml_bytes_unsafe_set(s$0,n[1],92);
                n[1]++;
                caml_bytes_unsafe_set(s$0,n[1],114);
                break;
               default:switch$2 = 1}
          switch(switch$2)
           {case 1:
             caml_bytes_unsafe_set(s$0,n[1],92);
             n[1]++;
             caml_bytes_unsafe_set(s$0,n[1],48 + (c / 100 | 0) | 0);
             n[1]++;
             caml_bytes_unsafe_set(s$0,n[1],48 + ((c / 10 | 0) % 10 | 0) | 0);
             n[1]++;
             caml_bytes_unsafe_set(s$0,n[1],48 + (c % 10 | 0) | 0);
             break;
            case 2:
             caml_bytes_unsafe_set(s$0,n[1],92);
             n[1]++;
             caml_bytes_unsafe_set(s$0,n[1],c);
             break;
            case 3:caml_bytes_unsafe_set(s$0,n[1],c);break
            }
          n[1]++;
          var _z2_=i + 1 | 0;
          if(_z1_ !== i){var i=_z2_;continue}
          break}}
      return s$0}
    function map$4(f,s)
     {var l=caml_ml_bytes_length(s);
      if(0 === l)return s;
      var r=caml_create_bytes(l),_zW_=l - 1 | 0,_zV_=0;
      if(! (_zW_ < 0))
       {var i=_zV_;
        for(;;)
         {caml_bytes_unsafe_set(r,i,caml_call1(f,caml_bytes_unsafe_get(s,i)));
          var _zX_=i + 1 | 0;
          if(_zW_ !== i){var i=_zX_;continue}
          break}}
      return r}
    function mapi$0(f,s)
     {var l=caml_ml_bytes_length(s);
      if(0 === l)return s;
      var r=caml_create_bytes(l),_zT_=l - 1 | 0,_zS_=0;
      if(! (_zT_ < 0))
       {var i=_zS_;
        for(;;)
         {caml_bytes_unsafe_set
           (r,i,caml_call2(f,i,caml_bytes_unsafe_get(s,i)));
          var _zU_=i + 1 | 0;
          if(_zT_ !== i){var i=_zU_;continue}
          break}}
      return r}
    function uppercase_ascii$0(s){return map$4(uppercase_ascii,s)}
    function lowercase_ascii$0(s){return map$4(lowercase_ascii,s)}
    function apply1(f,s)
     {if(0 === caml_ml_bytes_length(s))return s;
      var r=copy(s);
      caml_bytes_unsafe_set(r,0,caml_call1(f,caml_bytes_unsafe_get(s,0)));
      return r}
    function capitalize_ascii(s){return apply1(uppercase_ascii,s)}
    function uncapitalize_ascii(s){return apply1(lowercase_ascii,s)}
    function index_rec(s,lim,i,c)
     {var i$0=i;
      for(;;)
       {if(lim <= i$0)throw Not_found;
        if(caml_bytes_unsafe_get(s,i$0) === c)return i$0;
        var i$1=i$0 + 1 | 0,i$0=i$1;
        continue}}
    function index(s,c){return index_rec(s,caml_ml_bytes_length(s),0,c)}
    function index_rec_opt(s,lim,i,c)
     {var i$0=i;
      for(;;)
       {if(lim <= i$0)return 0;
        if(caml_bytes_unsafe_get(s,i$0) === c)return [0,i$0];
        var i$1=i$0 + 1 | 0,i$0=i$1;
        continue}}
    function index_opt(s,c)
     {return index_rec_opt(s,caml_ml_bytes_length(s),0,c)}
    function index_from(s,i,c)
     {var l=caml_ml_bytes_length(s);
      if(0 <= i && ! (l < i))return index_rec(s,l,i,c);
      return invalid_arg(cst_String_index_from_Bytes_in)}
    function index_from_opt(s,i,c)
     {var l=caml_ml_bytes_length(s);
      if(0 <= i && ! (l < i))return index_rec_opt(s,l,i,c);
      return invalid_arg(cst_String_index_from_opt_Byte)}
    function rindex_rec(s,i,c)
     {var i$0=i;
      for(;;)
       {if(0 <= i$0)
         {if(caml_bytes_unsafe_get(s,i$0) === c)return i$0;
          var i$1=i$0 - 1 | 0,i$0=i$1;
          continue}
        throw Not_found}}
    function rindex(s,c)
     {return rindex_rec(s,caml_ml_bytes_length(s) - 1 | 0,c)}
    function rindex_from(s,i,c)
     {if(-1 <= i && ! (caml_ml_bytes_length(s) <= i))return rindex_rec(s,i,c);
      return invalid_arg(cst_String_rindex_from_Bytes_r)}
    function rindex_rec_opt(s,i,c)
     {var i$0=i;
      for(;;)
       {if(0 <= i$0)
         {if(caml_bytes_unsafe_get(s,i$0) === c)return [0,i$0];
          var i$1=i$0 - 1 | 0,i$0=i$1;
          continue}
        return 0}}
    function rindex_opt(s,c)
     {return rindex_rec_opt(s,caml_ml_bytes_length(s) - 1 | 0,c)}
    function rindex_from_opt(s,i,c)
     {if(-1 <= i && ! (caml_ml_bytes_length(s) <= i))
       return rindex_rec_opt(s,i,c);
      return invalid_arg(cst_String_rindex_from_opt_Byt)}
    function contains_from(s,i,c)
     {var l=caml_ml_bytes_length(s);
      if(0 <= i && ! (l < i))
       try
        {index_rec(s,l,i,c);var _zQ_=1;return _zQ_}
       catch(_zR_)
        {_zR_ = caml_wrap_exception(_zR_);
         if(_zR_ === Not_found)return 0;
         throw _zR_}
      return invalid_arg(cst_String_contains_from_Bytes)}
    function contains(s,c){return contains_from(s,0,c)}
    function rcontains_from(s,i,c)
     {if(0 <= i && ! (caml_ml_bytes_length(s) <= i))
       try
        {rindex_rec(s,i,c);var _zO_=1;return _zO_}
       catch(_zP_)
        {_zP_ = caml_wrap_exception(_zP_);
         if(_zP_ === Not_found)return 0;
         throw _zP_}
      return invalid_arg(cst_String_rcontains_from_Byte)}
    function compare$6(x,y){return runtime.caml_bytes_compare(x,y)}
    function uppercase$0(s){return map$4(uppercase,s)}
    function lowercase$0(s){return map$4(lowercase,s)}
    function capitalize(s){return apply1(uppercase,s)}
    function uncapitalize(s){return apply1(lowercase,s)}
    function to_seq$2(s)
     {function aux(i,param)
       {if(i === caml_ml_bytes_length(s))return 0;
        var x=caml_bytes_get(s,i),_zM_=i + 1 | 0;
        return [0,x,function(_zN_){return aux(_zM_,_zN_)}]}
      var _zK_=0;
      return function(_zL_){return aux(_zK_,_zL_)}}
    function to_seqi(s)
     {function aux(i,param)
       {if(i === caml_ml_bytes_length(s))return 0;
        var x=caml_bytes_get(s,i),_zI_=i + 1 | 0;
        return [0,[0,i,x],function(_zJ_){return aux(_zI_,_zJ_)}]}
      var _zG_=0;
      return function(_zH_){return aux(_zG_,_zH_)}}
    function of_seq$0(i)
     {var n=[0,0],buf=[0,make$0(256,0)];
      iter
       (function(c)
         {if(n[1] === caml_ml_bytes_length(buf[1]))
           {var
             new_len=
              min(2 * caml_ml_bytes_length(buf[1]) | 0,max_string_length);
            if(caml_ml_bytes_length(buf[1]) === new_len)
             failwith(cst_Bytes_of_seq_cannot_grow_b);
            var new_buf=make$0(new_len,0);
            blit(buf[1],0,new_buf,0,n[1]);
            buf[1] = new_buf}
          caml_bytes_set(buf[1],n[1],c);
          n[1]++;
          return 0},
        i);
      return sub(buf[1],0,n[1])}
    function get_int8(b,i){return caml_bytes_get(b,i) << 24 >> 24}
    function get_uint16_le(b,i){return caml_bytes_get16(b,i)}
    function get_uint16_be(b,i){return caml_bswap16(caml_bytes_get16(b,i))}
    function get_int16_ne(b,i){return caml_bytes_get16(b,i) << 16 >> 16}
    function get_int16_le(b,i){return caml_bytes_get16(b,i) << 16 >> 16}
    function get_int16_be(b,i){return get_uint16_be(b,i) << 16 >> 16}
    function get_int32_le(b,i){return caml_bytes_get32(b,i)}
    function get_int32_be(b,i){return caml_int32_bswap(caml_bytes_get32(b,i))}
    function get_int64_le(b,i){return caml_bytes_get64(b,i)}
    function get_int64_be(b,i){return caml_int64_bswap(caml_bytes_get64(b,i))}
    function set_int16_le(b,i,x){return caml_bytes_set16(b,i,x)}
    function set_int16_be(b,i,x){return caml_bytes_set16(b,i,caml_bswap16(x))}
    function set_int32_le(b,i,x){return caml_bytes_set32(b,i,x)}
    function set_int32_be(b,i,x)
     {return caml_bytes_set32(b,i,caml_int32_bswap(x))}
    function set_int64_le(b,i,x){return caml_bytes_set64(b,i,x)}
    function set_int64_be(b,i,x)
     {return caml_bytes_set64(b,i,caml_int64_bswap(x))}
    var
     set_uint8=caml_bytes_set,
     set_uint16_ne=caml_bytes_set16,
     set_int64_ne=caml_bytes_set64,
     set_int32_ne=caml_bytes_set32,
     set_int16_ne=caml_bytes_set16,
     set_int8=caml_bytes_set,
     get_int64_ne=caml_bytes_get64,
     get_int32_ne=caml_bytes_get32,
     get_uint16_ne=caml_bytes_get16,
     get_uint8=caml_bytes_get,
     unsafe_of_string=caml_bytes_of_string,
     unsafe_to_string=caml_string_of_bytes,
     equal$6=runtime.caml_bytes_equal,
     include$1=
      [0,
       make$0,
       init$0,
       empty$0,
       copy,
       of_string,
       to_string$1,
       sub,
       sub_string,
       extend,
       fill,
       blit,
       blit$0,
       concat,
       cat,
       iter$3,
       iteri$0,
       map$4,
       mapi$0,
       trim,
       escaped$0,
       index,
       index_opt,
       rindex,
       rindex_opt,
       index_from,
       index_from_opt,
       rindex_from,
       rindex_from_opt,
       contains,
       contains_from,
       rcontains_from,
       uppercase$0,
       lowercase$0,
       capitalize,
       uncapitalize,
       uppercase_ascii$0,
       lowercase_ascii$0,
       capitalize_ascii,
       uncapitalize_ascii,
       compare$6,
       equal$6,
       unsafe_to_string,
       unsafe_of_string,
       to_seq$2,
       to_seqi,
       of_seq$0,
       get_uint8,
       get_int8,
       get_uint16_ne,
       get_uint16_be,
       get_uint16_le,
       get_int16_ne,
       get_int16_be,
       get_int16_le,
       get_int32_ne,
       get_int32_be,
       get_int32_le,
       get_int64_ne,
       get_int64_be,
       get_int64_le,
       set_uint8,
       set_int8,
       set_uint16_ne,
       set_int16_be,
       set_int16_le,
       set_int16_ne,
       set_int16_be,
       set_int16_le,
       set_int32_ne,
       set_int32_be,
       set_int32_le,
       set_int64_ne,
       set_int64_be,
       set_int64_le];
    caml_register_global(769,include$1,"Stdlib__bytes");
    function make$1(n,c){return caml_string_of_bytes(make$0(n,c))}
    function init$1(n,f){return caml_string_of_bytes(init$0(n,f))}
    function copy$0(s)
     {return caml_string_of_bytes(copy(caml_bytes_of_string(s)))}
    function sub$0(s,ofs,len)
     {return caml_string_of_bytes(sub(caml_bytes_of_string(s),ofs,len))}
    function concat$0(sep,l)
     {if(l)
       {var seplen=caml_ml_string_length(sep),acc=0,param=l,pos$1=0;
        for(;;)
         {if(param)
           {var _zD_=param[1];
            if(param[2])
             {var
               tl=param[2],
               x=(caml_ml_string_length(_zD_) + seplen | 0) + acc | 0,
               acc$0=acc <= x?x:invalid_arg(cst_String_concat),
               acc=acc$0,
               param=tl;
              continue}
            var _zF_=caml_ml_string_length(_zD_) + acc | 0}
          else
           var _zF_=acc;
          var dst=caml_create_bytes(_zF_),pos=pos$1,param$0=l;
          for(;;)
           {if(param$0)
             {var _zE_=param$0[1];
              if(param$0[2])
               {var tl$0=param$0[2];
                caml_blit_string(_zE_,0,dst,pos,caml_ml_string_length(_zE_));
                caml_blit_string
                 (sep,0,dst,pos + caml_ml_string_length(_zE_) | 0,seplen);
                var
                 pos$0=(pos + caml_ml_string_length(_zE_) | 0) + seplen | 0,
                 pos=pos$0,
                 param$0=tl$0;
                continue}
              caml_blit_string(_zE_,0,dst,pos,caml_ml_string_length(_zE_))}
            return caml_string_of_bytes(dst)}}}
      return cst$3}
    function iter$4(f,s)
     {var _zB_=caml_ml_string_length(s) - 1 | 0,_zA_=0;
      if(! (_zB_ < 0))
       {var i=_zA_;
        for(;;)
         {caml_call1(f,caml_string_unsafe_get(s,i));
          var _zC_=i + 1 | 0;
          if(_zB_ !== i){var i=_zC_;continue}
          break}}
      return 0}
    function iteri$1(f,s)
     {var _zy_=caml_ml_string_length(s) - 1 | 0,_zx_=0;
      if(! (_zy_ < 0))
       {var i=_zx_;
        for(;;)
         {caml_call2(f,i,caml_string_unsafe_get(s,i));
          var _zz_=i + 1 | 0;
          if(_zy_ !== i){var i=_zz_;continue}
          break}}
      return 0}
    function map$5(f,s)
     {return caml_string_of_bytes(map$4(f,caml_bytes_of_string(s)))}
    function mapi$1(f,s)
     {return caml_string_of_bytes(mapi$0(f,caml_bytes_of_string(s)))}
    function is_space$0(param)
     {var _zw_=param - 9 | 0,switch$0=0;
      if(4 < _zw_ >>> 0)
       {if(23 === _zw_)switch$0 = 1}
      else
       if(2 !== _zw_)switch$0 = 1;
      return switch$0?1:0}
    function trim$0(s)
     {if(caml_string_equal(s,cst$4))return s;
      if
       (!
        is_space$0(caml_string_unsafe_get(s,0))
        &&
        !
        is_space$0(caml_string_unsafe_get(s,caml_ml_string_length(s) - 1 | 0)))
       return s;
      return caml_string_of_bytes(trim(caml_bytes_of_string(s)))}
    function escaped$1(s)
     {var n=caml_ml_string_length(s),i=0;
      for(;;)
       {if(n <= i)return s;
        var match=caml_string_unsafe_get(s,i),_zv_=match - 32 | 0,switch$0=0;
        if(59 < _zv_ >>> 0)
         {if(33 < (_zv_ - 61 | 0) >>> 0)switch$0 = 1}
        else
         if(2 === _zv_)switch$0 = 1;
        if(switch$0)
         return caml_string_of_bytes(escaped$0(caml_bytes_of_string(s)));
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    function index_rec$0(s,lim,i,c)
     {var i$0=i;
      for(;;)
       {if(lim <= i$0)throw Not_found;
        if(caml_string_unsafe_get(s,i$0) === c)return i$0;
        var i$1=i$0 + 1 | 0,i$0=i$1;
        continue}}
    function index$0(s,c){return index_rec$0(s,caml_ml_string_length(s),0,c)}
    function index_rec_opt$0(s,lim,i,c)
     {var i$0=i;
      for(;;)
       {if(lim <= i$0)return 0;
        if(caml_string_unsafe_get(s,i$0) === c)return [0,i$0];
        var i$1=i$0 + 1 | 0,i$0=i$1;
        continue}}
    function index_opt$0(s,c)
     {return index_rec_opt$0(s,caml_ml_string_length(s),0,c)}
    function index_from$0(s,i,c)
     {var l=caml_ml_string_length(s);
      if(0 <= i && ! (l < i))return index_rec$0(s,l,i,c);
      return invalid_arg(cst_String_index_from_Bytes_in$0)}
    function index_from_opt$0(s,i,c)
     {var l=caml_ml_string_length(s);
      if(0 <= i && ! (l < i))return index_rec_opt$0(s,l,i,c);
      return invalid_arg(cst_String_index_from_opt_Byte$0)}
    function rindex_rec$0(s,i,c)
     {var i$0=i;
      for(;;)
       {if(0 <= i$0)
         {if(caml_string_unsafe_get(s,i$0) === c)return i$0;
          var i$1=i$0 - 1 | 0,i$0=i$1;
          continue}
        throw Not_found}}
    function rindex$0(s,c)
     {return rindex_rec$0(s,caml_ml_string_length(s) - 1 | 0,c)}
    function rindex_from$0(s,i,c)
     {if(-1 <= i && ! (caml_ml_string_length(s) <= i))
       return rindex_rec$0(s,i,c);
      return invalid_arg(cst_String_rindex_from_Bytes_r$0)}
    function rindex_rec_opt$0(s,i,c)
     {var i$0=i;
      for(;;)
       {if(0 <= i$0)
         {if(caml_string_unsafe_get(s,i$0) === c)return [0,i$0];
          var i$1=i$0 - 1 | 0,i$0=i$1;
          continue}
        return 0}}
    function rindex_opt$0(s,c)
     {return rindex_rec_opt$0(s,caml_ml_string_length(s) - 1 | 0,c)}
    function rindex_from_opt$0(s,i,c)
     {if(-1 <= i && ! (caml_ml_string_length(s) <= i))
       return rindex_rec_opt$0(s,i,c);
      return invalid_arg(cst_String_rindex_from_opt_Byt$0)}
    function contains_from$0(s,i,c)
     {var l=caml_ml_string_length(s);
      if(0 <= i && ! (l < i))
       try
        {index_rec$0(s,l,i,c);var _zt_=1;return _zt_}
       catch(_zu_)
        {_zu_ = caml_wrap_exception(_zu_);
         if(_zu_ === Not_found)return 0;
         throw _zu_}
      return invalid_arg(cst_String_contains_from_Bytes$0)}
    function contains$0(s,c){return contains_from$0(s,0,c)}
    function rcontains_from$0(s,i,c)
     {if(0 <= i && ! (caml_ml_string_length(s) <= i))
       try
        {rindex_rec$0(s,i,c);var _zr_=1;return _zr_}
       catch(_zs_)
        {_zs_ = caml_wrap_exception(_zs_);
         if(_zs_ === Not_found)return 0;
         throw _zs_}
      return invalid_arg(cst_String_rcontains_from_Byte$0)}
    function uppercase_ascii$1(s)
     {return caml_string_of_bytes(uppercase_ascii$0(caml_bytes_of_string(s)))}
    function lowercase_ascii$1(s)
     {return caml_string_of_bytes(lowercase_ascii$0(caml_bytes_of_string(s)))}
    function capitalize_ascii$0(s)
     {return caml_string_of_bytes(capitalize_ascii(caml_bytes_of_string(s)))}
    function uncapitalize_ascii$0(s)
     {return caml_string_of_bytes(uncapitalize_ascii(caml_bytes_of_string(s)))}
    function split_on_char(sep,s)
     {var
       r=[0,0],
       j=[0,caml_ml_string_length(s)],
       _zn_=caml_ml_string_length(s) - 1 | 0;
      if(! (_zn_ < 0))
       {var i=_zn_;
        for(;;)
         {if(caml_string_unsafe_get(s,i) === sep)
           {var _zp_=r[1];
            r[1] = [0,sub$0(s,i + 1 | 0,(j[1] - i | 0) - 1 | 0),_zp_];
            j[1] = i}
          var _zq_=i - 1 | 0;
          if(0 !== i){var i=_zq_;continue}
          break}}
      var _zo_=r[1];
      return [0,sub$0(s,0,j[1]),_zo_]}
    function uppercase$1(s)
     {return caml_string_of_bytes(uppercase$0(caml_bytes_of_string(s)))}
    function lowercase$1(s)
     {return caml_string_of_bytes(lowercase$0(caml_bytes_of_string(s)))}
    function capitalize$0(s)
     {return caml_string_of_bytes(capitalize(caml_bytes_of_string(s)))}
    function uncapitalize$0(s)
     {return caml_string_of_bytes(uncapitalize(caml_bytes_of_string(s)))}
    function compare$7(x,y){return caml_string_compare(x,y)}
    function to_seq$3(s){return to_seq$2(caml_bytes_of_string(s))}
    function to_seqi$0(s){return to_seqi(caml_bytes_of_string(s))}
    function of_seq$1(g){return caml_string_of_bytes(of_seq$0(g))}
    var
     equal$7=caml_string_equal,
     include$2=
      [0,
       make$1,
       init$1,
       concat$0,
       equal$7,
       compare$7,
       contains_from$0,
       rcontains_from$0,
       contains$0,
       sub$0,
       split_on_char,
       map$5,
       mapi$1,
       trim$0,
       escaped$1,
       uppercase_ascii$1,
       lowercase_ascii$1,
       capitalize_ascii$0,
       uncapitalize_ascii$0,
       iter$4,
       iteri$1,
       index_from$0,
       index_from_opt$0,
       rindex_from$0,
       rindex_from_opt$0,
       index$0,
       index_opt$0,
       rindex$0,
       rindex_opt$0,
       to_seq$3,
       to_seqi$0,
       of_seq$1,
       blit$0,
       copy$0,
       fill,
       uppercase$1,
       lowercase$1,
       capitalize$0,
       uncapitalize$0];
    caml_register_global(770,include$2,"Stdlib__string");
    function equal$8(param,_zm_){return 1}
    function compare$8(param,_zl_){return 0}
    function to_string$2(param){return cst$5}
    var Stdlib_unit=[0,equal$8,compare$8,to_string$2];
    caml_register_global(771,Stdlib_unit,"Stdlib__unit");
    function to_buffer(buff,ofs,len,v,flags)
     {if
       (0
        <=
        ofs
        &&
        0
        <=
        len
        &&
        !
        ((caml_ml_bytes_length(buff) - len | 0) < ofs))
       return runtime.caml_output_value_to_buffer(buff,ofs,len,v,flags);
      return invalid_arg(cst_Marshal_to_buffer_substrin)}
    var header_size=20;
    function data_size(buff,ofs)
     {if(0 <= ofs && ! ((caml_ml_bytes_length(buff) - 20 | 0) < ofs))
       return caml_marshal_data_size(buff,ofs);
      return invalid_arg(cst_Marshal_data_size)}
    function total_size(buff,ofs){return 20 + data_size(buff,ofs) | 0}
    function from_bytes(buff,ofs)
     {if(0 <= ofs && ! ((caml_ml_bytes_length(buff) - 20 | 0) < ofs))
       {var len=caml_marshal_data_size(buff,ofs);
        return (caml_ml_bytes_length(buff) - (20 + len | 0) | 0) < ofs
                ?invalid_arg(cst_Marshal_from_bytes$0)
                :runtime.caml_input_value_from_bytes(buff,ofs)}
      return invalid_arg(cst_Marshal_from_bytes)}
    function from_string(buff,ofs)
     {return from_bytes(caml_bytes_of_string(buff),ofs)}
    var
     Stdlib_marshal=
      [0,
       caml_output_value,
       to_buffer,
       caml_input_value,
       from_bytes,
       from_string,
       header_size,
       data_size,
       total_size];
    caml_register_global(772,Stdlib_marshal,"Stdlib__marshal");
    function is_block(a){return 1 - (typeof a === "number"?1:0)}
    function double_field(x,i){return caml_array_get(x,i)}
    function set_double_field(x,i,v){return caml_array_set(x,i,v)}
    function marshal(obj){return runtime.caml_output_value_to_bytes(obj,0)}
    function unmarshal(str,pos)
     {var _zk_=pos + total_size(str,pos) | 0;
      return [0,from_bytes(str,pos),_zk_]}
    var
     first_non_constant_constructor=0,
     last_non_constant_constructor_=245,
     lazy_tag=246,
     closure_tag=247,
     object_tag=248,
     infix_tag=249,
     forward_tag=250,
     no_scan_tag=251,
     abstract_tag=251,
     string_tag=252,
     double_tag=253,
     double_array_tag=254,
     custom_tag=255,
     int_tag=1000,
     out_of_heap_tag=1001,
     unaligned_tag=1002;
    function info(obj)
     {if(caml_obj_tag(obj) === 247)
       {var
         info=runtime.caml_obj_raw_field(obj,1),
         arity=info >> 24,
         start_env=info << 8 >>> 9 | 0;
        return [0,arity,start_env]}
      throw [0,Assert_failure,_q_]}
    function of_val(x)
     {var switch$0=0;
      if(is_block(x) && caml_obj_tag(x) !== 248 && 1 <= x.length - 1)
       {var slot=x[1];switch$0 = 1}
      if(! switch$0)var slot=x;
      var switch$1=0;
      if(is_block(slot) && caml_obj_tag(slot) === 248)
       {var name=slot[1];switch$1 = 1}
      if(! switch$1)var name=invalid_arg(cst_Obj_extension_constructor$0);
      return caml_obj_tag(name) === 252
              ?slot
              :invalid_arg(cst_Obj_extension_constructor)}
    function name(slot){return slot[1]}
    function id(slot){return slot[2]}
    var
     Extension_constructor=[0,of_val,name,id],
     extension_constructor=Extension_constructor[1],
     extension_name=Extension_constructor[2],
     extension_id=Extension_constructor[3],
     max_ephe_length=max_array_length - 2 | 0;
    function create(l)
     {var _zi_=0 <= l?1:0,_zj_=_zi_?l <= max_ephe_length?1:0:_zi_;
      if(1 - _zj_)invalid_arg(cst_Obj_Ephemeron_create);
      return runtime.caml_ephe_create(l)}
    function length$0(x){return x.length - 1 - 2 | 0}
    function raise_if_invalid_offset(e,o,msg)
     {var _zf_=0 <= o?1:0,_zg_=_zf_?o < length$0(e)?1:0:_zf_,_zh_=1 - _zg_;
      return _zh_?invalid_arg(msg):_zh_}
    function get_key(e,o)
     {raise_if_invalid_offset(e,o,cst_Obj_Ephemeron_get_key);
      return runtime.caml_ephe_get_key(e,o)}
    function get_key_copy(e,o)
     {raise_if_invalid_offset(e,o,cst_Obj_Ephemeron_get_key_copy);
      return runtime.caml_ephe_get_key_copy(e,o)}
    function set_key(e,o,x)
     {raise_if_invalid_offset(e,o,cst_Obj_Ephemeron_set_key);
      return caml_ephe_set_key(e,o,x)}
    function unset_key(e,o)
     {raise_if_invalid_offset(e,o,cst_Obj_Ephemeron_unset_key);
      return caml_ephe_unset_key(e,o)}
    function check_key(e,o)
     {raise_if_invalid_offset(e,o,cst_Obj_Ephemeron_check_key);
      return runtime.caml_ephe_check_key(e,o)}
    function blit_key(e1,o1,e2,o2,l)
     {if
       (0
        <=
        l
        &&
        0
        <=
        o1
        &&
        !
        ((length$0(e1) - l | 0) < o1)
        &&
        0
        <=
        o2
        &&
        !
        ((length$0(e2) - l | 0) < o2))
       {var
         _zd_=0 !== l?1:0,
         _ze_=_zd_?runtime.caml_ephe_blit_key(e1,o1,e2,o2,l):_zd_;
        return _ze_}
      return invalid_arg(cst_Obj_Ephemeron_blit_key)}
    var
     _r_=runtime.caml_ephe_blit_data,
     _s_=runtime.caml_ephe_check_data,
     _t_=
      [0,
       create,
       length$0,
       get_key,
       get_key_copy,
       set_key,
       unset_key,
       check_key,
       blit_key,
       runtime.caml_ephe_get_data,
       runtime.caml_ephe_get_data_copy,
       runtime.caml_ephe_set_data,
       function(_zc_){return runtime.caml_ephe_unset_data(_zc_)},
       _s_,
       _r_,
       max_ephe_length],
     Stdlib_obj=
      [0,
       is_block,
       double_field,
       set_double_field,
       first_non_constant_constructor,
       last_non_constant_constructor_,
       lazy_tag,
       closure_tag,
       object_tag,
       infix_tag,
       forward_tag,
       no_scan_tag,
       abstract_tag,
       string_tag,
       double_tag,
       double_array_tag,
       custom_tag,
       custom_tag,
       int_tag,
       out_of_heap_tag,
       unaligned_tag,
       [0,info],
       Extension_constructor,
       extension_constructor,
       extension_name,
       extension_id,
       marshal,
       unmarshal,
       _t_];
    caml_register_global(773,Stdlib_obj,"Stdlib__obj");
    var make_float=runtime.caml_make_float_vect,Floatarray=[0];
    function init$2(l,f)
     {if(0 === l)return [0];
      if(0 <= l)
       {var res=caml_make_vect(l,caml_call1(f,0)),_za_=l - 1 | 0,_y$_=1;
        if(! (_za_ < 1))
         {var i=_y$_;
          for(;;)
           {res[1 + i] = caml_call1(f,i);
            var _zb_=i + 1 | 0;
            if(_za_ !== i){var i=_zb_;continue}
            break}}
        return res}
      return invalid_arg(cst_Array_init)}
    function create_matrix(sx,sy,init)
     {var res=caml_make_vect(sx,[0]),_y9_=sx - 1 | 0,_y8_=0;
      if(! (_y9_ < 0))
       {var x=_y8_;
        for(;;)
         {res[1 + x] = caml_make_vect(sy,init);
          var _y__=x + 1 | 0;
          if(_y9_ !== x){var x=_y__;continue}
          break}}
      return res}
    function copy$1(a)
     {var l=a.length - 1;return 0 === l?[0]:caml_array_sub(a,0,l)}
    function append$1(a1,a2)
     {var l1=a1.length - 1;
      return 0 === l1
              ?copy$1(a2)
              :0 === a2.length - 1
                ?caml_array_sub(a1,0,l1)
                :runtime.caml_array_append(a1,a2)}
    function sub$1(a,ofs,len)
     {if(0 <= ofs && 0 <= len && ! ((a.length - 1 - len | 0) < ofs))
       return caml_array_sub(a,ofs,len);
      return invalid_arg(cst_Array_sub)}
    function fill$0(a,ofs,len,v)
     {if(0 <= ofs && 0 <= len && ! ((a.length - 1 - len | 0) < ofs))
       return runtime.caml_array_fill(a,ofs,len,v);
      return invalid_arg(cst_Array_fill)}
    function blit$1(a1,ofs1,a2,ofs2,len)
     {if
       (0
        <=
        len
        &&
        0
        <=
        ofs1
        &&
        !
        ((a1.length - 1 - len | 0) < ofs1)
        &&
        0
        <=
        ofs2
        &&
        !
        ((a2.length - 1 - len | 0) < ofs2))
       return runtime.caml_array_blit(a1,ofs1,a2,ofs2,len);
      return invalid_arg(cst_Array_blit)}
    function iter$5(f,a)
     {var _y6_=a.length - 1 - 1 | 0,_y5_=0;
      if(! (_y6_ < 0))
       {var i=_y5_;
        for(;;)
         {caml_call1(f,a[1 + i]);
          var _y7_=i + 1 | 0;
          if(_y6_ !== i){var i=_y7_;continue}
          break}}
      return 0}
    function iter2$0(f,a,b)
     {if(a.length - 1 !== b.length - 1)
       return invalid_arg(cst_Array_iter2_arrays_must_ha);
      var _y3_=a.length - 1 - 1 | 0,_y2_=0;
      if(! (_y3_ < 0))
       {var i=_y2_;
        for(;;)
         {caml_call2(f,a[1 + i],b[1 + i]);
          var _y4_=i + 1 | 0;
          if(_y3_ !== i){var i=_y4_;continue}
          break}}
      return 0}
    function map$6(f,a)
     {var l=a.length - 1;
      if(0 === l)return [0];
      var r=caml_make_vect(l,caml_call1(f,a[1])),_y0_=l - 1 | 0,_yZ_=1;
      if(! (_y0_ < 1))
       {var i=_yZ_;
        for(;;)
         {r[1 + i] = caml_call1(f,a[1 + i]);
          var _y1_=i + 1 | 0;
          if(_y0_ !== i){var i=_y1_;continue}
          break}}
      return r}
    function map2$0(f,a,b)
     {var la=a.length - 1,lb=b.length - 1;
      if(la !== lb)return invalid_arg(cst_Array_map2_arrays_must_hav);
      if(0 === la)return [0];
      var r=caml_make_vect(la,caml_call2(f,a[1],b[1])),_yX_=la - 1 | 0,_yW_=1;
      if(! (_yX_ < 1))
       {var i=_yW_;
        for(;;)
         {r[1 + i] = caml_call2(f,a[1 + i],b[1 + i]);
          var _yY_=i + 1 | 0;
          if(_yX_ !== i){var i=_yY_;continue}
          break}}
      return r}
    function iteri$2(f,a)
     {var _yU_=a.length - 1 - 1 | 0,_yT_=0;
      if(! (_yU_ < 0))
       {var i=_yT_;
        for(;;)
         {caml_call2(f,i,a[1 + i]);
          var _yV_=i + 1 | 0;
          if(_yU_ !== i){var i=_yV_;continue}
          break}}
      return 0}
    function mapi$2(f,a)
     {var l=a.length - 1;
      if(0 === l)return [0];
      var r=caml_make_vect(l,caml_call2(f,0,a[1])),_yR_=l - 1 | 0,_yQ_=1;
      if(! (_yR_ < 1))
       {var i=_yQ_;
        for(;;)
         {r[1 + i] = caml_call2(f,i,a[1 + i]);
          var _yS_=i + 1 | 0;
          if(_yR_ !== i){var i=_yS_;continue}
          break}}
      return r}
    function to_list$1(a)
     {var i$1=a.length - 1 - 1 | 0,i=i$1,res=0;
      for(;;)
       {if(0 <= i)
         {var res$0=[0,a[1 + i],res],i$0=i - 1 | 0,i=i$0,res=res$0;continue}
        return res}}
    function list_length(accu,param)
     {var accu$0=accu,param$0=param;
      for(;;)
       {if(param$0)
         {var
           param$1=param$0[2],
           accu$1=accu$0 + 1 | 0,
           accu$0=accu$1,
           param$0=param$1;
          continue}
        return accu$0}}
    function of_list(l)
     {if(l)
       {var
         tl=l[2],
         hd=l[1],
         a=caml_make_vect(list_length(0,l),hd),
         i=1,
         param=tl;
        for(;;)
         {if(param)
           {var tl$0=param[2],hd$0=param[1];
            a[1 + i] = hd$0;
            var i$0=i + 1 | 0,i=i$0,param=tl$0;
            continue}
          return a}}
      return [0]}
    function fold_left$1(f,x,a)
     {var r=[0,x],_yO_=a.length - 1 - 1 | 0,_yN_=0;
      if(! (_yO_ < 0))
       {var i=_yN_;
        for(;;)
         {r[1] = caml_call2(f,r[1],a[1 + i]);
          var _yP_=i + 1 | 0;
          if(_yO_ !== i){var i=_yP_;continue}
          break}}
      return r[1]}
    function fold_right$0(f,a,x)
     {var r=[0,x],_yL_=a.length - 1 - 1 | 0;
      if(! (_yL_ < 0))
       {var i=_yL_;
        for(;;)
         {r[1] = caml_call2(f,a[1 + i],r[1]);
          var _yM_=i - 1 | 0;
          if(0 !== i){var i=_yM_;continue}
          break}}
      return r[1]}
    function exists$0(p,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 0;
        if(caml_call1(p,a[1 + i]))return 1;
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    function for_all$0(p,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 1;
        if(caml_call1(p,a[1 + i])){var i$0=i + 1 | 0,i=i$0;continue}
        return 0}}
    function for_all2$0(p,l1,l2)
     {var n1=l1.length - 1,n2=l2.length - 1;
      if(n1 !== n2)return invalid_arg(cst_Array_for_all2);
      var i=0;
      for(;;)
       {if(i === n1)return 1;
        if(caml_call2(p,l1[1 + i],l2[1 + i]))
         {var i$0=i + 1 | 0,i=i$0;continue}
        return 0}}
    function exists2$0(p,l1,l2)
     {var n1=l1.length - 1,n2=l2.length - 1;
      if(n1 !== n2)return invalid_arg(cst_Array_exists2);
      var i=0;
      for(;;)
       {if(i === n1)return 0;
        if(caml_call2(p,l1[1 + i],l2[1 + i]))return 1;
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    function mem$0(x,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 0;
        if(0 === caml_compare(a[1 + i],x))return 1;
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    function memq$0(x,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 0;
        if(x === a[1 + i])return 1;
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    var Bottom=[248,cst_Stdlib_Array_Bottom,caml_fresh_oo_id(0)];
    function sort(cmp,a)
     {function maxson(l,i)
       {var i31=((i + i | 0) + i | 0) + 1 | 0,x=[0,i31];
        if((i31 + 2 | 0) < l)
         {var _yE_=i31 + 1 | 0,_yF_=caml_check_bound(a,_yE_)[1 + _yE_];
          if(caml_call2(cmp,caml_check_bound(a,i31)[1 + i31],_yF_) < 0)
           x[1] = i31 + 1 | 0;
          var
           _yG_=i31 + 2 | 0,
           _yH_=caml_check_bound(a,_yG_)[1 + _yG_],
           _yI_=x[1];
          if(caml_call2(cmp,caml_check_bound(a,_yI_)[1 + _yI_],_yH_) < 0)
           x[1] = i31 + 2 | 0;
          return x[1]}
        if((i31 + 1 | 0) < l)
         {var _yJ_=i31 + 1 | 0,_yK_=caml_check_bound(a,_yJ_)[1 + _yJ_];
          if(! (0 <= caml_call2(cmp,caml_check_bound(a,i31)[1 + i31],_yK_)))
           return i31 + 1 | 0}
        if(i31 < l)return i31;
        throw [0,Bottom,i]}
      function trickledown(l,i,e)
       {var i$0=i;
        for(;;)
         {var j=maxson(l,i$0);
          if(0 < caml_call2(cmp,caml_check_bound(a,j)[1 + j],e))
           {var _yD_=caml_check_bound(a,j)[1 + j];
            caml_check_bound(a,i$0)[1 + i$0] = _yD_;
            var i$0=j;
            continue}
          caml_check_bound(a,i$0)[1 + i$0] = e;
          return 0}}
      function trickle(l,i,e)
       {try
         {var _yC_=trickledown(l,i,e);return _yC_}
        catch(exn)
         {exn = caml_wrap_exception(exn);
          if(exn[1] === Bottom)
           {var i$0=exn[2];caml_check_bound(a,i$0)[1 + i$0] = e;return 0}
          throw exn}}
      function bubbledown(l,i)
       {var i$0=i;
        for(;;)
         {var i$1=maxson(l,i$0),_yB_=caml_check_bound(a,i$1)[1 + i$1];
          caml_check_bound(a,i$0)[1 + i$0] = _yB_;
          var i$0=i$1;
          continue}}
      function bubble(l,i)
       {try
         {var _yA_=bubbledown(l,i);return _yA_}
        catch(exn)
         {exn = caml_wrap_exception(exn);
          if(exn[1] === Bottom){var i$0=exn[2];return i$0}
          throw exn}}
      var l=a.length - 1,_ys_=((l + 1 | 0) / 3 | 0) - 1 | 0;
      if(! (_ys_ < 0))
       {var i$2=_ys_;
        for(;;)
         {trickle(l,i$2,caml_check_bound(a,i$2)[1 + i$2]);
          var _yz_=i$2 - 1 | 0;
          if(0 !== i$2){var i$2=_yz_;continue}
          break}}
      var _yt_=l - 1 | 0;
      if(! (_yt_ < 2))
       {var i$0=_yt_;
        a:
        for(;;)
         {var
           e$0=caml_check_bound(a,i$0)[1 + i$0],
           _yx_=caml_check_bound(a,0)[1];
          caml_check_bound(a,i$0)[1 + i$0] = _yx_;
          var i$1=bubble(i$0,0),i=i$1;
          for(;;)
           {var father=(i - 1 | 0) / 3 | 0;
            if(i === father)throw [0,Assert_failure,_u_];
            if
             (0 <= caml_call2(cmp,caml_check_bound(a,father)[1 + father],e$0))
             caml_check_bound(a,i)[1 + i] = e$0;
            else
             {var _yr_=caml_check_bound(a,father)[1 + father];
              caml_check_bound(a,i)[1 + i] = _yr_;
              if(0 < father){var i=father;continue}
              caml_check_bound(a,0)[1] = e$0}
            var _yy_=i$0 - 1 | 0;
            if(2 !== i$0){var i$0=_yy_;continue a}
            break}
          break}}
      var _yu_=1 < l?1:0;
      if(_yu_)
       {var e=caml_check_bound(a,1)[2],_yv_=caml_check_bound(a,0)[1];
        caml_check_bound(a,1)[2] = _yv_;
        caml_check_bound(a,0)[1] = e;
        var _yw_=0}
      else
       var _yw_=_yu_;
      return _yw_}
    function fast_sort$0(cmp,a)
     {function merge(src1ofs,src1len,src2,src2ofs,src2len,dst,dstofs)
       {var
         src1r=src1ofs + src1len | 0,
         src2r=src2ofs + src2len | 0,
         s2$1=caml_check_bound(src2,src2ofs)[1 + src2ofs],
         s1$1=caml_check_bound(a,src1ofs)[1 + src1ofs],
         i1=src1ofs,
         s1=s1$1,
         i2=src2ofs,
         s2=s2$1,
         d=dstofs;
        for(;;)
         {if(0 < caml_call2(cmp,s1,s2))
           {caml_check_bound(dst,d)[1 + d] = s2;
            var i2$0=i2 + 1 | 0;
            if(i2$0 < src2r)
             {var
               d$0=d + 1 | 0,
               s2$0=caml_check_bound(src2,i2$0)[1 + i2$0],
               i2=i2$0,
               s2=s2$0,
               d=d$0;
              continue}
            return blit$1(a,i1,dst,d + 1 | 0,src1r - i1 | 0)}
          caml_check_bound(dst,d)[1 + d] = s1;
          var i1$0=i1 + 1 | 0;
          if(i1$0 < src1r)
           {var
             d$1=d + 1 | 0,
             s1$0=caml_check_bound(a,i1$0)[1 + i1$0],
             i1=i1$0,
             s1=s1$0,
             d=d$1;
            continue}
          return blit$1(src2,i2,dst,d + 1 | 0,src2r - i2 | 0)}}
      function isortto(srcofs,dst,dstofs,len)
       {var _yj_=len - 1 | 0,_yi_=0;
        if(! (_yj_ < 0))
         {var i=_yi_;
          a:
          for(;;)
           {var
             _yk_=srcofs + i | 0,
             e=caml_check_bound(a,_yk_)[1 + _yk_],
             j=[0,(dstofs + i | 0) - 1 | 0];
            for(;;)
             {if(dstofs <= j[1])
               {var _yl_=j[1];
                if(0 < caml_call2(cmp,caml_check_bound(dst,_yl_)[1 + _yl_],e))
                 {var
                   _ym_=j[1],
                   _yn_=caml_check_bound(dst,_ym_)[1 + _ym_],
                   _yo_=j[1] + 1 | 0;
                  caml_check_bound(dst,_yo_)[1 + _yo_] = _yn_;
                  j[1] += -1;
                  continue}}
              var _yp_=j[1] + 1 | 0;
              caml_check_bound(dst,_yp_)[1 + _yp_] = e;
              var _yq_=i + 1 | 0;
              if(_yj_ !== i){var i=_yq_;continue a}
              break}
            break}}
        return 0}
      function sortto(srcofs,dst,dstofs,len)
       {if(len <= 5)return isortto(srcofs,dst,dstofs,len);
        var l1=len / 2 | 0,l2=len - l1 | 0;
        sortto(srcofs + l1 | 0,dst,dstofs + l1 | 0,l2);
        sortto(srcofs,a,srcofs + l2 | 0,l1);
        return merge(srcofs + l2 | 0,l1,dst,dstofs + l1 | 0,l2,dst,dstofs)}
      var l=a.length - 1;
      if(l <= 5)return isortto(0,a,0,l);
      var
       l1=l / 2 | 0,
       l2=l - l1 | 0,
       t=caml_make_vect(l2,caml_check_bound(a,0)[1]);
      sortto(l1,t,0,l2);
      sortto(0,a,l2,l1);
      return merge(l2,l1,t,0,l2,a,0)}
    function to_seq$4(a)
     {function aux(i,param)
       {if(i < a.length - 1)
         {var x=a[1 + i],_yg_=i + 1 | 0;
          return [0,x,function(_yh_){return aux(_yg_,_yh_)}]}
        return 0}
      var _ye_=0;
      return function(_yf_){return aux(_ye_,_yf_)}}
    function to_seqi$1(a)
     {function aux(i,param)
       {if(i < a.length - 1)
         {var x=a[1 + i],_yc_=i + 1 | 0;
          return [0,[0,i,x],function(_yd_){return aux(_yc_,_yd_)}]}
        return 0}
      var _ya_=0;
      return function(_yb_){return aux(_ya_,_yb_)}}
    function of_seq$2(i$2)
     {var _x$_=0,l=fold_left(function(acc,x){return [0,x,acc]},_x$_,i$2);
      if(l)
       {var
         tl=l[2],
         hd=l[1],
         len=list_length(0,l),
         a=caml_make_vect(len,hd),
         i$1=len - 2 | 0,
         i=i$1,
         param=tl;
        for(;;)
         {if(param)
           {var tl$0=param[2],hd$0=param[1];
            a[1 + i] = hd$0;
            var i$0=i - 1 | 0,i=i$0,param=tl$0;
            continue}
          return a}}
      return [0]}
    var
     concat$1=caml_array_concat,
     include$3=
      [0,
       make_float,
       init$2,
       create_matrix,
       create_matrix,
       append$1,
       concat$1,
       sub$1,
       copy$1,
       fill$0,
       blit$1,
       to_list$1,
       of_list,
       iter$5,
       iteri$2,
       map$6,
       mapi$2,
       fold_left$1,
       fold_right$0,
       iter2$0,
       map2$0,
       for_all$0,
       exists$0,
       for_all2$0,
       exists2$0,
       mem$0,
       memq$0,
       sort,
       fast_sort$0,
       fast_sort$0,
       to_seq$4,
       to_seqi$1,
       of_seq$2,
       Floatarray];
    caml_register_global(774,include$3,"Stdlib__array");
    var zero=0.,one=1.,minus_one=-1.;
    function is_finite(x){return x - x == 0.?1:0}
    function is_infinite(x){return 1. / x == 0.?1:0}
    function is_nan(x){return x != x?1:0}
    var pi=3.14159265358979312;
    function is_integer(x)
     {var _x__=x == runtime.caml_trunc_float(x)?1:0;
      return _x__?is_finite(x):_x__}
    function succ$0(x){return caml_nextafter_float(x,infinity)}
    function pred$0(x){return caml_nextafter_float(x,neg_infinity)}
    function equal$9(x,y){return 0 === caml_float_compare(x,y)?1:0}
    function min$1(x,y)
     {if(! (x < y))
       {var switch$0=0;
        if(caml_signbit_float(y) || ! caml_signbit_float(x))switch$0 = 1;
        if(switch$0)return x != x?x:y}
      return y != y?y:x}
    function max$1(x,y)
     {if(! (x < y))
       {var switch$0=0;
        if(caml_signbit_float(y) || ! caml_signbit_float(x))switch$0 = 1;
        if(switch$0)return y != y?y:x}
      return x != x?x:y}
    function min_max(x,y)
     {if(x == x && y == y)
       {if(! (x < y))
         {var switch$0=0;
          if(caml_signbit_float(y) || ! caml_signbit_float(x))switch$0 = 1;
          if(switch$0)return [0,y,x]}
        return [0,x,y]}
      return [0,nan,nan]}
    function min_num(x,y)
     {if(! (x < y))
       {var switch$0=0;
        if(caml_signbit_float(y) || ! caml_signbit_float(x))switch$0 = 1;
        if(switch$0)return y != y?x:y}
      return x != x?y:x}
    function max_num(x,y)
     {if(! (x < y))
       {var switch$0=0;
        if(caml_signbit_float(y) || ! caml_signbit_float(x))switch$0 = 1;
        if(switch$0)return x != x?y:x}
      return y != y?x:y}
    function min_max_num(x,y)
     {if(x != x)return [0,y,y];
      if(y != y)return [0,x,x];
      if(! (x < y))
       {var switch$0=0;
        if(caml_signbit_float(y) || ! caml_signbit_float(x))switch$0 = 1;
        if(switch$0)return [0,y,x]}
      return [0,x,y]}
    function hash$0(x){return caml_hash(10,100,0,x)}
    function unsafe_fill(a,ofs,len,v)
     {var _x8_=(ofs + len | 0) - 1 | 0;
      if(! (_x8_ < ofs))
       {var i=ofs;
        for(;;)
         {a[1 + i] = v;
          var _x9_=i + 1 | 0;
          if(_x8_ !== i){var i=_x9_;continue}
          break}}
      return 0}
    function check(a,ofs,len,msg)
     {var _x4_=ofs < 0?1:0;
      if(_x4_)
       var _x5_=_x4_;
      else
       {var _x6_=len < 0?1:0;
        if(_x6_)
         var _x5_=_x6_;
        else
         var
          _x7_=(ofs + len | 0) < 0?1:0,
          _x5_=_x7_ || (a.length - 1 < (ofs + len | 0)?1:0)}
      return _x5_?invalid_arg(msg):_x5_}
    function make$2(n,v)
     {var result=caml_floatarray_create(n);
      unsafe_fill(result,0,n,v);
      return result}
    function init$3(l,f)
     {if(0 <= l)
       {var res=caml_floatarray_create(l),_x2_=l - 1 | 0,_x1_=0;
        if(! (_x2_ < 0))
         {var i=_x1_;
          for(;;)
           {res[1 + i] = caml_call1(f,i);
            var _x3_=i + 1 | 0;
            if(_x2_ !== i){var i=_x3_;continue}
            break}}
        return res}
      return invalid_arg(cst_Float_Array_init)}
    function append$2(a1,a2)
     {var
       l1=a1.length - 1,
       l2=a2.length - 1,
       result=caml_floatarray_create(l1 + l2 | 0);
      caml_floatarray_blit(a1,0,result,0,l1);
      caml_floatarray_blit(a2,0,result,l1,l2);
      return result}
    function concat$2(l)
     {var acc=0,param=l;
      for(;;)
       {if(param)
         {var
           tl=param[2],
           hd=param[1],
           x=hd.length - 1 + acc | 0,
           acc$0=acc <= x?x:invalid_arg(cst_Float_Array_concat),
           acc=acc$0,
           param=tl;
          continue}
        var result=caml_floatarray_create(acc),l$0=l,i=0;
        for(;;)
         {if(l$0)
           {var tl$0=l$0[2],hd$0=l$0[1],hlen=hd$0.length - 1;
            caml_floatarray_blit(hd$0,0,result,i,hlen);
            var i$0=i + hlen | 0,l$0=tl$0,i=i$0;
            continue}
          if(i === acc)return result;
          throw [0,Assert_failure,_v_]}}}
    function sub$2(a,ofs,len)
     {check(a,ofs,len,cst_Float_Array_sub);
      var result=caml_floatarray_create(len);
      caml_floatarray_blit(a,ofs,result,0,len);
      return result}
    function copy$2(a)
     {var l=a.length - 1,result=caml_floatarray_create(l);
      caml_floatarray_blit(a,0,result,0,l);
      return result}
    function fill$1(a,ofs,len,v)
     {check(a,ofs,len,cst_Float_Array_fill);return unsafe_fill(a,ofs,len,v)}
    function blit$2(src,sofs,dst,dofs,len)
     {check(src,sofs,len,cst_Float_array_blit);
      check(dst,dofs,len,cst_Float_array_blit$0);
      return caml_floatarray_blit(src,sofs,dst,dofs,len)}
    function to_list$2(a)
     {return init(a.length - 1,function(_x0_){return a[1 + _x0_]})}
    function of_list$0(l)
     {var result=caml_floatarray_create(length(l)),i=0,l$0=l;
      for(;;)
       {if(l$0)
         {var t=l$0[2],h=l$0[1];
          result[1 + i] = h;
          var i$0=i + 1 | 0,i=i$0,l$0=t;
          continue}
        return result}}
    function iter$6(f,a)
     {var _xY_=a.length - 1 - 1 | 0,_xX_=0;
      if(! (_xY_ < 0))
       {var i=_xX_;
        for(;;)
         {caml_call1(f,a[1 + i]);
          var _xZ_=i + 1 | 0;
          if(_xY_ !== i){var i=_xZ_;continue}
          break}}
      return 0}
    function iter2$1(f,a,b)
     {if(a.length - 1 !== b.length - 1)
       return invalid_arg(cst_Float_Array_iter2_arrays_m);
      var _xV_=a.length - 1 - 1 | 0,_xU_=0;
      if(! (_xV_ < 0))
       {var i=_xU_;
        for(;;)
         {caml_call2(f,a[1 + i],b[1 + i]);
          var _xW_=i + 1 | 0;
          if(_xV_ !== i){var i=_xW_;continue}
          break}}
      return 0}
    function map$7(f,a)
     {var l=a.length - 1,r=caml_floatarray_create(l),_xS_=l - 1 | 0,_xR_=0;
      if(! (_xS_ < 0))
       {var i=_xR_;
        for(;;)
         {r[1 + i] = caml_call1(f,a[1 + i]);
          var _xT_=i + 1 | 0;
          if(_xS_ !== i){var i=_xT_;continue}
          break}}
      return r}
    function map2$1(f,a,b)
     {var la=a.length - 1,lb=b.length - 1;
      if(la !== lb)return invalid_arg(cst_Float_Array_map2_arrays_mu);
      var r=caml_floatarray_create(la),_xP_=la - 1 | 0,_xO_=0;
      if(! (_xP_ < 0))
       {var i=_xO_;
        for(;;)
         {r[1 + i] = caml_call2(f,a[1 + i],b[1 + i]);
          var _xQ_=i + 1 | 0;
          if(_xP_ !== i){var i=_xQ_;continue}
          break}}
      return r}
    function iteri$3(f,a)
     {var _xM_=a.length - 1 - 1 | 0,_xL_=0;
      if(! (_xM_ < 0))
       {var i=_xL_;
        for(;;)
         {caml_call2(f,i,a[1 + i]);
          var _xN_=i + 1 | 0;
          if(_xM_ !== i){var i=_xN_;continue}
          break}}
      return 0}
    function mapi$3(f,a)
     {var l=a.length - 1,r=caml_floatarray_create(l),_xJ_=l - 1 | 0,_xI_=0;
      if(! (_xJ_ < 0))
       {var i=_xI_;
        for(;;)
         {r[1 + i] = caml_call2(f,i,a[1 + i]);
          var _xK_=i + 1 | 0;
          if(_xJ_ !== i){var i=_xK_;continue}
          break}}
      return r}
    function fold_left$2(f,x,a)
     {var r=[0,x],_xG_=a.length - 1 - 1 | 0,_xF_=0;
      if(! (_xG_ < 0))
       {var i=_xF_;
        for(;;)
         {r[1] = caml_call2(f,r[1],a[1 + i]);
          var _xH_=i + 1 | 0;
          if(_xG_ !== i){var i=_xH_;continue}
          break}}
      return r[1]}
    function fold_right$1(f,a,x)
     {var r=[0,x],_xD_=a.length - 1 - 1 | 0;
      if(! (_xD_ < 0))
       {var i=_xD_;
        for(;;)
         {r[1] = caml_call2(f,a[1 + i],r[1]);
          var _xE_=i - 1 | 0;
          if(0 !== i){var i=_xE_;continue}
          break}}
      return r[1]}
    function exists$1(p,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 0;
        if(caml_call1(p,a[1 + i]))return 1;
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    function for_all$1(p,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 1;
        if(caml_call1(p,a[1 + i])){var i$0=i + 1 | 0,i=i$0;continue}
        return 0}}
    function mem$1(x,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 0;
        if(0 === caml_float_compare(a[1 + i],x))return 1;
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    function mem_ieee(x,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 0;
        if(x == a[1 + i])return 1;
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    var Bottom$0=[248,cst_Stdlib_Float_Array_Bottom,caml_fresh_oo_id(0)];
    function sort$0(cmp,a)
     {function maxson(l,i)
       {var i31=((i + i | 0) + i | 0) + 1 | 0,x=[0,i31];
        if((i31 + 2 | 0) < l)
         {if
           (caml_call2
             (cmp,caml_array_get(a,i31),caml_array_get(a,i31 + 1 | 0))
            <
            0)
           x[1] = i31 + 1 | 0;
          if
           (caml_call2
             (cmp,caml_array_get(a,x[1]),caml_array_get(a,i31 + 2 | 0))
            <
            0)
           x[1] = i31 + 2 | 0;
          return x[1]}
        if
         ((i31 + 1 | 0)
          <
          l
          &&
          !
          (0
           <=
           caml_call2(cmp,caml_array_get(a,i31),caml_array_get(a,i31 + 1 | 0))))
         return i31 + 1 | 0;
        if(i31 < l)return i31;
        throw [0,Bottom$0,i]}
      function trickledown(l,i,e)
       {var i$0=i;
        for(;;)
         {var j=maxson(l,i$0);
          if(0 < caml_call2(cmp,caml_array_get(a,j),e))
           {caml_array_set(a,i$0,caml_array_get(a,j));var i$0=j;continue}
          return caml_array_set(a,i$0,e)}}
      function trickle(l,i,e)
       {try
         {var _xC_=trickledown(l,i,e);return _xC_}
        catch(exn)
         {exn = caml_wrap_exception(exn);
          if(exn[1] === Bottom$0)
           {var i$0=exn[2];return caml_array_set(a,i$0,e)}
          throw exn}}
      function bubbledown(l,i)
       {var i$0=i;
        for(;;)
         {var i$1=maxson(l,i$0);
          caml_array_set(a,i$0,caml_array_get(a,i$1));
          var i$0=i$1;
          continue}}
      function bubble(l,i)
       {try
         {var _xB_=bubbledown(l,i);return _xB_}
        catch(exn)
         {exn = caml_wrap_exception(exn);
          if(exn[1] === Bottom$0){var i$0=exn[2];return i$0}
          throw exn}}
      var l=a.length - 1,_xv_=((l + 1 | 0) / 3 | 0) - 1 | 0;
      if(! (_xv_ < 0))
       {var i$2=_xv_;
        for(;;)
         {trickle(l,i$2,caml_array_get(a,i$2));
          var _xA_=i$2 - 1 | 0;
          if(0 !== i$2){var i$2=_xA_;continue}
          break}}
      var _xw_=l - 1 | 0;
      if(! (_xw_ < 2))
       {var i$0=_xw_;
        a:
        for(;;)
         {var e$0=caml_array_get(a,i$0);
          caml_array_set(a,i$0,caml_array_get(a,0));
          var i$1=bubble(i$0,0),i=i$1;
          for(;;)
           {var father=(i - 1 | 0) / 3 | 0;
            if(i === father)throw [0,Assert_failure,_w_];
            if(0 <= caml_call2(cmp,caml_array_get(a,father),e$0))
             caml_array_set(a,i,e$0);
            else
             {caml_array_set(a,i,caml_array_get(a,father));
              if(0 < father){var i=father;continue}
              caml_array_set(a,0,e$0)}
            var _xz_=i$0 - 1 | 0;
            if(2 !== i$0){var i$0=_xz_;continue a}
            break}
          break}}
      var _xx_=1 < l?1:0;
      if(_xx_)
       {var e=caml_array_get(a,1);
        caml_array_set(a,1,caml_array_get(a,0));
        var _xy_=caml_array_set(a,0,e)}
      else
       var _xy_=_xx_;
      return _xy_}
    function stable_sort(cmp,a)
     {function merge(src1ofs,src1len,src2,src2ofs,src2len,dst,dstofs)
       {var
         src1r=src1ofs + src1len | 0,
         src2r=src2ofs + src2len | 0,
         s2$1=caml_array_get(src2,src2ofs),
         s1$1=caml_array_get(a,src1ofs),
         i1=src1ofs,
         s1=s1$1,
         i2=src2ofs,
         s2=s2$1,
         d=dstofs;
        for(;;)
         {if(0 < caml_call2(cmp,s1,s2))
           {caml_array_set(dst,d,s2);
            var i2$0=i2 + 1 | 0;
            if(i2$0 < src2r)
             {var
               d$0=d + 1 | 0,
               s2$0=caml_array_get(src2,i2$0),
               i2=i2$0,
               s2=s2$0,
               d=d$0;
              continue}
            return blit$2(a,i1,dst,d + 1 | 0,src1r - i1 | 0)}
          caml_array_set(dst,d,s1);
          var i1$0=i1 + 1 | 0;
          if(i1$0 < src1r)
           {var
             d$1=d + 1 | 0,
             s1$0=caml_array_get(a,i1$0),
             i1=i1$0,
             s1=s1$0,
             d=d$1;
            continue}
          return blit$2(src2,i2,dst,d + 1 | 0,src2r - i2 | 0)}}
      function isortto(srcofs,dst,dstofs,len)
       {var _xt_=len - 1 | 0,_xs_=0;
        if(! (_xt_ < 0))
         {var i=_xs_;
          a:
          for(;;)
           {var
             e=caml_array_get(a,srcofs + i | 0),
             j=[0,(dstofs + i | 0) - 1 | 0];
            for(;;)
             {if
               (dstofs
                <=
                j[1]
                &&
                0
                <
                caml_call2(cmp,caml_array_get(dst,j[1]),e))
               {caml_array_set(dst,j[1] + 1 | 0,caml_array_get(dst,j[1]));
                j[1] += -1;
                continue}
              caml_array_set(dst,j[1] + 1 | 0,e);
              var _xu_=i + 1 | 0;
              if(_xt_ !== i){var i=_xu_;continue a}
              break}
            break}}
        return 0}
      function sortto(srcofs,dst,dstofs,len)
       {if(len <= 5)return isortto(srcofs,dst,dstofs,len);
        var l1=len / 2 | 0,l2=len - l1 | 0;
        sortto(srcofs + l1 | 0,dst,dstofs + l1 | 0,l2);
        sortto(srcofs,a,srcofs + l2 | 0,l1);
        return merge(srcofs + l2 | 0,l1,dst,dstofs + l1 | 0,l2,dst,dstofs)}
      var l=a.length - 1;
      if(l <= 5)return isortto(0,a,0,l);
      var l1=l / 2 | 0,l2=l - l1 | 0,t=caml_floatarray_create(l2);
      sortto(l1,t,0,l2);
      sortto(0,a,l2,l1);
      return merge(l2,l1,t,0,l2,a,0)}
    function to_seq$5(a)
     {function aux(i,param)
       {if(i < a.length - 1)
         {var x=a[1 + i],_xq_=i + 1 | 0;
          return [0,x,function(_xr_){return aux(_xq_,_xr_)}]}
        return 0}
      var _xo_=0;
      return function(_xp_){return aux(_xo_,_xp_)}}
    function to_seqi$2(a)
     {function aux(i,param)
       {if(i < a.length - 1)
         {var x=a[1 + i],_xm_=i + 1 | 0;
          return [0,[0,i,x],function(_xn_){return aux(_xm_,_xn_)}]}
        return 0}
      var _xk_=0;
      return function(_xl_){return aux(_xk_,_xl_)}}
    function of_seq$3(i$2)
     {var
       _xj_=0,
       param$0=fold_left(function(acc,x){return [0,x,acc]},_xj_,i$2),
       len=length(param$0),
       a=caml_floatarray_create(len),
       i$1=len - 1 | 0,
       i=i$1,
       param=param$0;
      for(;;)
       {if(param)
         {var tl=param[2],hd=param[1];
          a[1 + i] = hd;
          var i$0=i - 1 | 0,i=i$0,param=tl;
          continue}
        return a}}
    function map_to_array(f,a)
     {var l=a.length - 1;
      if(0 === l)return [0];
      var r=caml_make_vect(l,caml_call1(f,a[1])),_xh_=l - 1 | 0,_xg_=1;
      if(! (_xh_ < 1))
       {var i=_xg_;
        for(;;)
         {r[1 + i] = caml_call1(f,a[1 + i]);
          var _xi_=i + 1 | 0;
          if(_xh_ !== i){var i=_xi_;continue}
          break}}
      return r}
    function map_from_array(f,a)
     {var l=a.length - 1,r=caml_floatarray_create(l),_xe_=l - 1 | 0,_xd_=0;
      if(! (_xe_ < 0))
       {var i=_xd_;
        for(;;)
         {r[1 + i] = caml_call1(f,a[1 + i]);
          var _xf_=i + 1 | 0;
          if(_xe_ !== i){var i=_xf_;continue}
          break}}
      return r}
    var
     _x_=caml_floatarray_create,
     _y_=caml_array_set,
     _z_=caml_array_get,
     _A_=
      [0,
       function(_xc_){return _xc_.length - 1},
       _z_,
       _y_,
       make$2,
       _x_,
       init$3,
       append$2,
       concat$2,
       sub$2,
       copy$2,
       fill$1,
       blit$2,
       to_list$2,
       of_list$0,
       iter$6,
       iteri$3,
       map$7,
       mapi$3,
       fold_left$2,
       fold_right$1,
       iter2$1,
       map2$1,
       for_all$1,
       exists$1,
       mem$1,
       mem_ieee,
       sort$0,
       stable_sort,
       stable_sort,
       to_seq$5,
       to_seqi$2,
       of_seq$3,
       map_to_array,
       map_from_array],
     _B_=caml_floatarray_create,
     _C_=caml_array_set,
     _D_=caml_array_get,
     Stdlib_float=
      [0,
       zero,
       one,
       minus_one,
       succ$0,
       pred$0,
       infinity,
       neg_infinity,
       nan,
       pi,
       max_float,
       min_float,
       epsilon,
       is_finite,
       is_infinite,
       is_nan,
       is_integer,
       of_string_opt,
       to_string,
       caml_float_compare,
       equal$9,
       min$1,
       max$1,
       min_max,
       min_num,
       max_num,
       min_max_num,
       hash$0,
       [0,
        function(_xb_){return _xb_.length - 1},
        _D_,
        _C_,
        make$2,
        _B_,
        init$3,
        append$2,
        concat$2,
        sub$2,
        copy$2,
        fill$1,
        blit$2,
        to_list$2,
        of_list$0,
        iter$6,
        iteri$3,
        map$7,
        mapi$3,
        fold_left$2,
        fold_right$1,
        iter2$1,
        map2$1,
        for_all$1,
        exists$1,
        mem$1,
        mem_ieee,
        sort$0,
        stable_sort,
        stable_sort,
        to_seq$5,
        to_seqi$2,
        of_seq$3,
        map_to_array,
        map_from_array],
       _A_];
    caml_register_global(775,Stdlib_float,"Stdlib__float");
    var zero$0=0,one$0=1,minus_one$0=-1;
    function abs$0(x){return 0 <= x?x:- x | 0}
    var max_int$0=2147483647,min_int$0=-2147483648;
    function lognot(x){return x ^ -1}
    function equal$10(_xa_,_w$_){return _xa_ === _w$_?1:0}
    var compare$9=caml_int_compare;
    function to_string$3(x){return caml_string_of_jsbytes("" + x)}
    var
     Stdlib_int=
      [0,
       zero$0,
       one$0,
       minus_one$0,
       abs$0,
       max_int$0,
       min_int$0,
       lognot,
       equal$10,
       compare$9,
       to_string$3];
    caml_register_global(776,Stdlib_int,"Stdlib__int");
    var zero$1=0,one$1=1,minus_one$1=-1;
    function succ$1(n){return n + 1 | 0}
    function pred$1(n){return n - 1 | 0}
    function abs$1(n){return caml_greaterequal(n,0)?n:- n | 0}
    var min_int$1=-2147483648,max_int$1=2147483647;
    function lognot$0(n){return n ^ -1}
    function unsigned_to_int(n)
     {if
       (!
        (0 < caml_int_compare(0,n))
        &&
        !
        (0 < caml_int_compare(n,2147483647)))
       return [0,n];
      return 0}
    function to_string$4(n){return caml_format_int(cst_d,n)}
    function of_string_opt$0(s)
     {try
       {var _w9_=[0,caml_int_of_string(s)];return _w9_}
      catch(_w__)
       {_w__ = caml_wrap_exception(_w__);
        if(_w__[1] === Failure)return 0;
        throw _w__}}
    function compare$10(x,y){return caml_int_compare(x,y)}
    function equal$11(x,y){return 0 === caml_int_compare(x,y)?1:0}
    function unsigned_compare(n,m)
     {return caml_int_compare(n + 2147483648 | 0,m + 2147483648 | 0)}
    function unsigned_div(n,d)
     {if(caml_lessthan(d,0))return 0 <= unsigned_compare(n,d)?one$1:zero$1;
      var q=caml_div(n >>> 1 | 0,d) << 1,r=n - caml_mul(q,d) | 0;
      return 0 <= unsigned_compare(r,d)?q + 1 | 0:q}
    function unsigned_rem(n,d){return n - caml_mul(unsigned_div(n,d),d) | 0}
    var
     Stdlib_int32=
      [0,
       zero$1,
       one$1,
       minus_one$1,
       unsigned_div,
       unsigned_rem,
       succ$1,
       pred$1,
       abs$1,
       max_int$1,
       min_int$1,
       lognot$0,
       unsigned_to_int,
       of_string_opt$0,
       to_string$4,
       compare$10,
       unsigned_compare,
       equal$11];
    caml_register_global(777,Stdlib_int32,"Stdlib__int32");
    function succ$2(n){return caml_int64_add(n,_E_)}
    function pred$2(n){return caml_int64_sub(n,_F_)}
    function abs$2(n)
     {return caml_greaterequal(n,_G_)?n:runtime.caml_int64_neg(n)}
    function lognot$1(n){return runtime.caml_int64_xor(n,_H_)}
    var max_int$3=caml_int64_of_int32(2147483647);
    function unsigned_to_int$0(n)
     {if
       (!
        (0 < caml_int64_compare(zero$2,n))
        &&
        !
        (0 < caml_int64_compare(n,max_int$3)))
       return [0,runtime.caml_int64_to_int32(n)];
      return 0}
    function to_string$5(n){return caml_int64_format(cst_d$0,n)}
    function of_string_opt$1(s)
     {try
       {var _w7_=[0,caml_int64_of_string(s)];return _w7_}
      catch(_w8_)
       {_w8_ = caml_wrap_exception(_w8_);
        if(_w8_[1] === Failure)return 0;
        throw _w8_}}
    function compare$11(x,y){return caml_int64_compare(x,y)}
    function equal$12(x,y){return 0 === caml_int64_compare(x,y)?1:0}
    function unsigned_compare$0(n,m)
     {return caml_int64_compare
              (caml_int64_sub(n,min_int$2),caml_int64_sub(m,min_int$2))}
    function unsigned_div$0(n,d)
     {if(caml_lessthan(d,zero$2))
       return 0 <= unsigned_compare$0(n,d)?one$2:zero$2;
      var
       q=
        caml_int64_shift_left
         (runtime.caml_int64_div
           (runtime.caml_int64_shift_right_unsigned(n,1),d),
          1),
       r=caml_int64_sub(n,caml_int64_mul(q,d));
      return 0 <= unsigned_compare$0(r,d)?succ$2(q):q}
    function unsigned_rem$0(n,d)
     {return caml_int64_sub(n,caml_int64_mul(unsigned_div$0(n,d),d))}
    var
     Stdlib_int64=
      [0,
       zero$2,
       one$2,
       minus_one$2,
       unsigned_div$0,
       unsigned_rem$0,
       succ$2,
       pred$2,
       abs$2,
       max_int$2,
       min_int$2,
       lognot$1,
       unsigned_to_int$0,
       of_string_opt$1,
       to_string$5,
       compare$11,
       unsigned_compare$0,
       equal$12];
    caml_register_global(778,Stdlib_int64,"Stdlib__int64");
    var zero$3=0,one$3=1,minus_one$3=-1;
    function succ$3(n){return n + 1 | 0}
    function pred$3(n){return n - 1 | 0}
    function abs$3(n){return caml_greaterequal(n,0)?n:- n | 0}
    var min_int$3=-2147483648,max_int$4=2147483647;
    function lognot$2(n){return n ^ -1}
    function unsigned_to_int$1(n)
     {if
       (!
        (0 < caml_int_compare(0,n))
        &&
        !
        (0 < caml_int_compare(n,2147483647)))
       return [0,n];
      return 0}
    function to_string$6(n){return caml_format_int(cst_d$1,n)}
    function of_string_opt$2(s)
     {try
       {var _w5_=[0,caml_int_of_string(s)];return _w5_}
      catch(_w6_)
       {_w6_ = caml_wrap_exception(_w6_);
        if(_w6_[1] === Failure)return 0;
        throw _w6_}}
    function compare$12(x,y){return caml_int_compare(x,y)}
    function equal$13(x,y){return 0 === caml_int_compare(x,y)?1:0}
    function unsigned_compare$1(n,m)
     {return caml_int_compare(n + 2147483648 | 0,m + 2147483648 | 0)}
    function unsigned_div$1(n,d)
     {if(caml_lessthan(d,0))return 0 <= unsigned_compare$1(n,d)?one$3:zero$3;
      var q=caml_div(n >>> 1 | 0,d) << 1,r=n - caml_mul(q,d) | 0;
      return 0 <= unsigned_compare$1(r,d)?q + 1 | 0:q}
    function unsigned_rem$1(n,d)
     {return n - caml_mul(unsigned_div$1(n,d),d) | 0}
    var
     Stdlib_nativeint=
      [0,
       zero$3,
       one$3,
       minus_one$3,
       unsigned_div$1,
       unsigned_rem$1,
       succ$3,
       pred$3,
       abs$3,
       match$1,
       max_int$4,
       min_int$3,
       lognot$2,
       unsigned_to_int$1,
       of_string_opt$2,
       to_string$6,
       compare$12,
       unsigned_compare$1,
       equal$13];
    caml_register_global(779,Stdlib_nativeint,"Stdlib__nativeint");
    function engine(tbl,state,buf)
     {var
       result=runtime.caml_lex_engine(tbl,state,buf),
       _w2_=0 <= result?1:0,
       _w3_=_w2_?buf[12] !== dummy_pos?1:0:_w2_;
      if(_w3_)
       {buf[11] = buf[12];
        var _w4_=buf[12];
        buf[12] = [0,_w4_[1],_w4_[2],_w4_[3],buf[4] + buf[6] | 0]}
      return result}
    function new_engine(tbl,state,buf)
     {var
       result=runtime.caml_new_lex_engine(tbl,state,buf),
       _wZ_=0 <= result?1:0,
       _w0_=_wZ_?buf[12] !== dummy_pos?1:0:_wZ_;
      if(_w0_)
       {buf[11] = buf[12];
        var _w1_=buf[12];
        buf[12] = [0,_w1_[1],_w1_[2],_w1_[3],buf[4] + buf[6] | 0]}
      return result}
    function from_function(opt,f)
     {if(opt)var sth=opt[1],with_positions=sth;else var with_positions=1;
      var
       _wL_=with_positions?zero_pos:dummy_pos,
       _wM_=with_positions?zero_pos:dummy_pos,
       aux_buffer=caml_create_bytes(512),
       _wN_=[0],
       _wO_=0,
       _wP_=0,
       _wQ_=0,
       _wR_=0,
       _wS_=0,
       _wT_=0,
       _wU_=0,
       _wV_=caml_create_bytes(1024);
      return [0,
              function(lexbuf)
               {var
                 read=
                  caml_call2(f,aux_buffer,caml_ml_bytes_length(aux_buffer)),
                 n=0 < read?read:(lexbuf[9] = 1,0);
                if(caml_ml_bytes_length(lexbuf[2]) < (lexbuf[3] + n | 0))
                 {if
                   (((lexbuf[3] - lexbuf[5] | 0) + n | 0)
                    <=
                    caml_ml_bytes_length(lexbuf[2]))
                   blit
                    (lexbuf[2],lexbuf[5],lexbuf[2],0,lexbuf[3] - lexbuf[5] | 0);
                  else
                   {var
                     newlen=
                      min
                       (2 * caml_ml_bytes_length(lexbuf[2]) | 0,max_string_length);
                    if(newlen < ((lexbuf[3] - lexbuf[5] | 0) + n | 0))
                     failwith(cst_Lexing_lex_refill_cannot_g);
                    var newbuf=caml_create_bytes(newlen);
                    blit(lexbuf[2],lexbuf[5],newbuf,0,lexbuf[3] - lexbuf[5] | 0);
                    lexbuf[2] = newbuf}
                  var s=lexbuf[5];
                  lexbuf[4] = lexbuf[4] + s | 0;
                  lexbuf[6] = lexbuf[6] - s | 0;
                  lexbuf[5] = 0;
                  lexbuf[7] = lexbuf[7] - s | 0;
                  lexbuf[3] = lexbuf[3] - s | 0;
                  var t=lexbuf[10],_wX_=t.length - 1 - 1 | 0,_wW_=0;
                  if(! (_wX_ < 0))
                   {var i=_wW_;
                    for(;;)
                     {var v=caml_check_bound(t,i)[1 + i];
                      if(0 <= v)caml_check_bound(t,i)[1 + i] = v - s | 0;
                      var _wY_=i + 1 | 0;
                      if(_wX_ !== i){var i=_wY_;continue}
                      break}}}
                blit(aux_buffer,0,lexbuf[2],lexbuf[3],n);
                lexbuf[3] = lexbuf[3] + n | 0;
                return 0},
              _wV_,
              _wU_,
              _wT_,
              _wS_,
              _wR_,
              _wQ_,
              _wP_,
              _wO_,
              _wN_,
              _wM_,
              _wL_]}
    function from_channel(with_positions,ic)
     {return from_function
              (with_positions,function(buf,n){return input(ic,buf,0,n)})}
    function from_string$0(opt,s)
     {if(opt)var sth=opt[1],with_positions=sth;else var with_positions=1;
      var
       _wA_=with_positions?zero_pos:dummy_pos,
       _wB_=with_positions?zero_pos:dummy_pos,
       _wC_=[0],
       _wD_=1,
       _wE_=0,
       _wF_=0,
       _wG_=0,
       _wH_=0,
       _wI_=0,
       _wJ_=caml_ml_string_length(s),
       _wK_=of_string(s);
      return [0,
              function(lexbuf){lexbuf[9] = 1;return 0},
              _wK_,
              _wJ_,
              _wI_,
              _wH_,
              _wG_,
              _wF_,
              _wE_,
              _wD_,
              _wC_,
              _wB_,
              _wA_]}
    function set_position(lexbuf,position)
     {lexbuf[12] = [0,lexbuf[12][1],position[2],position[3],position[4]];
      lexbuf[4] = position[4];
      return 0}
    function set_filename(lexbuf,fname)
     {var _wz_=lexbuf[12];
      lexbuf[12] = [0,fname,_wz_[2],_wz_[3],_wz_[4]];
      return 0}
    function with_positions(lexbuf){return lexbuf[12] !== dummy_pos?1:0}
    function lexeme(lexbuf)
     {var len=lexbuf[6] - lexbuf[5] | 0;
      return sub_string(lexbuf[2],lexbuf[5],len)}
    function sub_lexeme(lexbuf,i1,i2)
     {var len=i2 - i1 | 0;return sub_string(lexbuf[2],i1,len)}
    function sub_lexeme_opt(lexbuf,i1,i2)
     {if(0 <= i1){var len=i2 - i1 | 0;return [0,sub_string(lexbuf[2],i1,len)]}
      return 0}
    function sub_lexeme_char(lexbuf,i){return caml_bytes_get(lexbuf[2],i)}
    function sub_lexeme_char_opt(lexbuf,i)
     {return 0 <= i?[0,caml_bytes_get(lexbuf[2],i)]:0}
    function lexeme_char(lexbuf,i)
     {return caml_bytes_get(lexbuf[2],lexbuf[5] + i | 0)}
    function lexeme_start(lexbuf){return lexbuf[11][4]}
    function lexeme_end(lexbuf){return lexbuf[12][4]}
    function lexeme_start_p(lexbuf){return lexbuf[11]}
    function lexeme_end_p(lexbuf){return lexbuf[12]}
    function new_line(lexbuf)
     {var
       lcp=lexbuf[12],
       _wx_=lcp !== dummy_pos?1:0,
       _wy_=_wx_?(lexbuf[12] = [0,lcp[1],lcp[2] + 1 | 0,lcp[4],lcp[4]],0):_wx_;
      return _wy_}
    function flush_input(lb)
     {lb[6] = 0;
      lb[4] = 0;
      var lcp=lb[12];
      if(lcp !== dummy_pos)
       lb[12] = [0,lcp[1],zero_pos[2],zero_pos[3],zero_pos[4]];
      lb[3] = 0;
      return 0}
    var
     Stdlib_lexing=
      [0,
       dummy_pos,
       from_channel,
       from_string$0,
       from_function,
       set_position,
       set_filename,
       with_positions,
       lexeme,
       lexeme_char,
       lexeme_start,
       lexeme_end,
       lexeme_start_p,
       lexeme_end_p,
       new_line,
       flush_input,
       sub_lexeme,
       sub_lexeme_opt,
       sub_lexeme_char,
       sub_lexeme_char_opt,
       engine,
       new_engine];
    caml_register_global(780,Stdlib_lexing,"Stdlib__lexing");
    var
     YYexit=[248,cst_Stdlib_Parsing_YYexit,caml_fresh_oo_id(0)],
     Parse_error=[248,cst_Stdlib_Parsing_Parse_error,caml_fresh_oo_id(0)],
     env=
      [0,
       caml_make_vect(100,0),
       caml_make_vect(100,0),
       caml_make_vect(100,dummy_pos),
       caml_make_vect(100,dummy_pos),
       100,
       0,
       0,
       0,
       dummy_pos,
       dummy_pos,
       0,
       0,
       0,
       0,
       0,
       0];
    function grow_stacks(param)
     {var
       oldsize=env[5],
       newsize=oldsize * 2 | 0,
       new_s=caml_make_vect(newsize,0),
       new_v=caml_make_vect(newsize,0),
       new_start=caml_make_vect(newsize,dummy_pos),
       new_end=caml_make_vect(newsize,dummy_pos);
      blit$1(env[1],0,new_s,0,oldsize);
      env[1] = new_s;
      blit$1(env[2],0,new_v,0,oldsize);
      env[2] = new_v;
      blit$1(env[3],0,new_start,0,oldsize);
      env[3] = new_start;
      blit$1(env[4],0,new_end,0,oldsize);
      env[4] = new_end;
      env[5] = newsize;
      return 0}
    function clear_parser(param)
     {fill$0(env[2],0,env[5],0);env[8] = 0;return 0}
    var current_lookahead_fun=[0,function(param){return 0}];
    function yyparse(tables,start,lexer,lexbuf)
     {var
       init_asp=env[11],
       init_sp=env[14],
       init_stackbase=env[6],
       init_state=env[15],
       init_curr_char=env[7],
       init_lval=env[8],
       init_errflag=env[16];
      env[6] = env[14] + 1 | 0;
      env[7] = start;
      env[10] = lexbuf[12];
      try
       {var cmd=0,arg=0;
        for(;;)
         {var match=runtime.caml_parse_engine(tables,env,cmd,arg);
          switch(match)
           {case 0:
             var arg$0=caml_call1(lexer,lexbuf);
             env[9] = lexbuf[11];
             env[10] = lexbuf[12];
             var cmd=1,arg=arg$0;
             continue;
            case 1:throw Parse_error;
            case 2:grow_stacks(0);var cmd=2,arg=0;continue;
            case 3:grow_stacks(0);var cmd=3,arg=0;continue;
            case 4:
             try
              {var
                _wr_=env[13],
                _ws_=
                 caml_call1(caml_check_bound(tables[1],_wr_)[1 + _wr_],env),
                _wt_=4,
                arg$1=_ws_,
                cmd$0=_wt_}
             catch(_ww_)
              {_ww_ = caml_wrap_exception(_ww_);
               if(_ww_ !== Parse_error)throw _ww_;
               var arg$1=0,cmd$0=5,_wu_=_ww_}
             var cmd=cmd$0,arg=arg$1;
             continue;
            default:
             caml_call1(tables[14],cst_syntax_error);var cmd=5,arg=0;continue}}}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        var curr_char=env[7];
        env[11] = init_asp;
        env[14] = init_sp;
        env[6] = init_stackbase;
        env[15] = init_state;
        env[7] = init_curr_char;
        env[8] = init_lval;
        env[16] = init_errflag;
        if(exn[1] === YYexit){var v=exn[2];return v}
        current_lookahead_fun[1]
        =
        function(tok)
         {if(is_block(tok))
           {var _wv_=caml_obj_tag(tok);
            return caml_check_bound(tables[3],_wv_)[1 + _wv_] === curr_char
                    ?1
                    :0}
          return caml_check_bound(tables[2],tok)[1 + tok] === curr_char?1:0};
        throw exn}}
    function peek_val(env,n)
     {var _wq_=env[11] - n | 0;return caml_check_bound(env[2],_wq_)[1 + _wq_]}
    function symbol_start_pos(param)
     {var i=env[12];
      for(;;)
       {if(0 < i)
         {var
           _wn_=(env[11] - i | 0) + 1 | 0,
           st=caml_check_bound(env[3],_wn_)[1 + _wn_],
           _wo_=(env[11] - i | 0) + 1 | 0,
           en=caml_check_bound(env[4],_wo_)[1 + _wo_];
          if(caml_notequal(st,en))return st;
          var i$0=i - 1 | 0,i=i$0;
          continue}
        var _wp_=env[11];
        return caml_check_bound(env[4],_wp_)[1 + _wp_]}}
    function symbol_end_pos(param)
     {var _wm_=env[11];return caml_check_bound(env[4],_wm_)[1 + _wm_]}
    function rhs_start_pos(n)
     {var _wl_=env[11] - (env[12] - n | 0) | 0;
      return caml_check_bound(env[3],_wl_)[1 + _wl_]}
    function rhs_end_pos(n)
     {var _wk_=env[11] - (env[12] - n | 0) | 0;
      return caml_check_bound(env[4],_wk_)[1 + _wk_]}
    function symbol_start(param){return symbol_start_pos(0)[4]}
    function symbol_end(param){return symbol_end_pos(0)[4]}
    function rhs_start(n){return rhs_start_pos(n)[4]}
    function rhs_end(n){return rhs_end_pos(n)[4]}
    function is_current_lookahead(tok)
     {return caml_call1(current_lookahead_fun[1],tok)}
    function parse_error(param){return 0}
    var
     Stdlib_parsing=
      [0,
       symbol_start,
       symbol_end,
       rhs_start,
       rhs_end,
       symbol_start_pos,
       symbol_end_pos,
       rhs_start_pos,
       rhs_end_pos,
       clear_parser,
       Parse_error,
       function(_wj_){return runtime.caml_set_parser_trace(_wj_)},
       YYexit,
       yyparse,
       peek_val,
       is_current_lookahead,
       parse_error];
    caml_register_global(781,Stdlib_parsing,"Stdlib__parsing");
    var
     Stdlib_set=
      [0,
       function(Ord)
        {function height(param){if(param){var h=param[4];return h}return 0}
         function create(l,v,r)
          {if(l)var h=l[4],hl=h;else var hl=0;
           if(r)var h$0=r[4],hr=h$0;else var hr=0;
           var _wi_=hr <= hl?hl + 1 | 0:hr + 1 | 0;
           return [0,l,v,r,_wi_]}
         function bal(l,v,r)
          {if(l)var h=l[4],hl=h;else var hl=0;
           if(r)var h$0=r[4],hr=h$0;else var hr=0;
           if((hr + 2 | 0) < hl)
            {if(l)
              {var lr=l[3],lv=l[2],ll=l[1],_wd_=height(lr);
               if(_wd_ <= height(ll))return create(ll,lv,create(lr,v,r));
               if(lr)
                {var lrr=lr[3],lrv=lr[2],lrl=lr[1],_we_=create(lrr,v,r);
                 return create(create(ll,lv,lrl),lrv,_we_)}
               return invalid_arg(cst_Set_bal)}
             return invalid_arg(cst_Set_bal$0)}
           if((hl + 2 | 0) < hr)
            {if(r)
              {var rr=r[3],rv=r[2],rl=r[1],_wf_=height(rl);
               if(_wf_ <= height(rr))return create(create(l,v,rl),rv,rr);
               if(rl)
                {var rlr=rl[3],rlv=rl[2],rll=rl[1],_wg_=create(rlr,rv,rr);
                 return create(create(l,v,rll),rlv,_wg_)}
               return invalid_arg(cst_Set_bal$1)}
             return invalid_arg(cst_Set_bal$2)}
           var _wh_=hr <= hl?hl + 1 | 0:hr + 1 | 0;
           return [0,l,v,r,_wh_]}
         function add(x,t)
          {if(t)
            {var r=t[3],v=t[2],l=t[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)return t;
             if(0 <= c){var rr=add(x,r);return r === rr?t:bal(l,v,rr)}
             var ll=add(x,l);
             return l === ll?t:bal(ll,v,r)}
           return [0,0,x,0,1]}
         function singleton(x){return [0,0,x,0,1]}
         function add_min_element(x,param)
          {if(param)
            {var r=param[3],v=param[2],l=param[1];
             return bal(add_min_element(x,l),v,r)}
           return singleton(x)}
         function add_max_element(x,param)
          {if(param)
            {var r=param[3],v=param[2],l=param[1];
             return bal(l,v,add_max_element(x,r))}
           return singleton(x)}
         function join(l,v,r)
          {if(l)
            {if(r)
              {var
                rh=r[4],
                rr=r[3],
                rv=r[2],
                rl=r[1],
                lh=l[4],
                lr=l[3],
                lv=l[2],
                ll=l[1];
               return (rh + 2 | 0) < lh
                       ?bal(ll,lv,join(lr,v,r))
                       :(lh + 2 | 0) < rh?bal(join(l,v,rl),rv,rr):create(l,v,r)}
             return add_max_element(v,l)}
           return add_min_element(v,r)}
         function min_elt(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var _wc_=param$0[1];
               if(_wc_){var param$0=_wc_;continue}
               var v=param$0[2];
               return v}
             throw Not_found}}
         function min_elt_opt(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var _wb_=param$0[1];
               if(_wb_){var param$0=_wb_;continue}
               var v=param$0[2];
               return [0,v]}
             return 0}}
         function max_elt(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {if(param$0[3]){var param$1=param$0[3],param$0=param$1;continue}
               var v=param$0[2];
               return v}
             throw Not_found}}
         function max_elt_opt(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {if(param$0[3]){var param$1=param$0[3],param$0=param$1;continue}
               var v=param$0[2];
               return [0,v]}
             return 0}}
         function remove_min_elt(param)
          {if(param)
            {var _wa_=param[1];
             if(_wa_)
              {var r=param[3],v=param[2];return bal(remove_min_elt(_wa_),v,r)}
             var r$0=param[3];
             return r$0}
           return invalid_arg(cst_Set_remove_min_elt)}
         function concat(t,match)
          {if(t)
            {if(match)
              {var _v$_=remove_min_elt(match);
               return join(t,min_elt(match),_v$_)}
             return t}
           return match}
         function split(x,param)
          {if(param)
            {var r=param[3],v=param[2],l=param[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)return [0,l,1,r];
             if(0 <= c)
              {var match=split(x,r),rr=match[3],pres=match[2],lr=match[1];
               return [0,join(l,v,lr),pres,rr]}
             var
              match$0=split(x,l),
              rl=match$0[3],
              pres$0=match$0[2],
              ll=match$0[1];
             return [0,ll,pres$0,join(rl,v,r)]}
           return _I_}
         var empty=0;
         function is_empty(param){return param?0:1}
         function mem(x,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[3],
                v=param$0[2],
                l=param$0[1],
                c=caml_call2(Ord[1],x,v),
                _v__=0 === c?1:0;
               if(_v__)return _v__;
               var param$1=0 <= c?r:l,param$0=param$1;
               continue}
             return 0}}
         function remove(x,t)
          {if(t)
            {var r=t[3],v=t[2],l=t[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)
              {if(l)
                {if(r)
                  {var _v9_=remove_min_elt(r);return bal(l,min_elt(r),_v9_)}
                 return l}
               return r}
             if(0 <= c){var rr=remove(x,r);return r === rr?t:bal(l,v,rr)}
             var ll=remove(x,l);
             return l === ll?t:bal(ll,v,r)}
           return 0}
         function union(t1,match)
          {if(t1)
            {if(match)
              {var
                h2=match[4],
                r2=match[3],
                v2=match[2],
                l2=match[1],
                h1=t1[4],
                r1=t1[3],
                v1=t1[2],
                l1=t1[1];
               if(h2 <= h1)
                {if(1 === h2)return add(v2,t1);
                 var
                  match$0=split(v1,match),
                  r2$0=match$0[3],
                  l2$0=match$0[1],
                  _v7_=union(r1,r2$0);
                 return join(union(l1,l2$0),v1,_v7_)}
               if(1 === h1)return add(v1,match);
               var
                match$1=split(v2,t1),
                r1$0=match$1[3],
                l1$0=match$1[1],
                _v8_=union(r1$0,r2);
               return join(union(l1$0,l2),v2,_v8_)}
             return t1}
           return match}
         function inter(s1,match)
          {if(s1)
            {if(match)
              {var
                r1=s1[3],
                v1=s1[2],
                l1=s1[1],
                _v3_=split(v1,match),
                _v4_=_v3_[1];
               if(_v3_[2])
                {var r2=_v3_[3],_v5_=inter(r1,r2);
                 return join(inter(l1,_v4_),v1,_v5_)}
               var r2$0=_v3_[3],_v6_=inter(r1,r2$0);
               return concat(inter(l1,_v4_),_v6_)}
             return 0}
           return 0}
         function split_bis(x,param)
          {if(param)
            {var r=param[3],v=param[2],l=param[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)return 0;
             if(0 <= c)
              {var match=split_bis(x,r);
               if(match)
                {var rr=match[2],lr=match[1];return [0,join(l,v,lr),rr]}
               return 0}
             var match$0=split_bis(x,l);
             if(match$0)
              {var rl=match$0[2],ll=match$0[1];
               return [0,
                       ll,
                       function(param){return join(caml_call1(rl,0),v,r)}]}
             return 0}
           return [0,0,function(param){return 0}]}
         function disjoint(s1,s2)
          {var s1$0=s1,s2$0=s2;
           for(;;)
            {if(s1$0 && s2$0)
              {var r1=s1$0[3],v1=s1$0[2],l1=s1$0[1];
               if(s1$0 === s2$0)return 0;
               var match=split_bis(v1,s2$0);
               if(match)
                {var r2=match[2],l2=match[1],_v2_=disjoint(l1,l2);
                 if(_v2_)
                  {var s2$1=caml_call1(r2,0),s1$0=r1,s2$0=s2$1;continue}
                 return _v2_}
               return 0}
             return 1}}
         function diff(t1,match)
          {if(t1)
            {if(match)
              {var
                r1=t1[3],
                v1=t1[2],
                l1=t1[1],
                _vY_=split(v1,match),
                _vZ_=_vY_[1];
               if(_vY_[2])
                {var r2=_vY_[3],_v0_=diff(r1,r2);
                 return concat(diff(l1,_vZ_),_v0_)}
               var r2$0=_vY_[3],_v1_=diff(r1,r2$0);
               return join(diff(l1,_vZ_),v1,_v1_)}
             return t1}
           return 0}
         function cons_enum(s,e)
          {var s$0=s,e$0=e;
           for(;;)
            {if(s$0)
              {var
                r=s$0[3],
                v=s$0[2],
                s$1=s$0[1],
                e$1=[0,v,r,e$0],
                s$0=s$1,
                e$0=e$1;
               continue}
             return e$0}}
         function compare(s1,s2)
          {var e2$2=cons_enum(s2,0),e1$2=cons_enum(s1,0),e1=e1$2,e2=e2$2;
           for(;;)
            {if(e1)
              {if(e2)
                {var
                  e2$0=e2[3],
                  r2=e2[2],
                  v2=e2[1],
                  e1$0=e1[3],
                  r1=e1[2],
                  v1=e1[1],
                  c=caml_call2(Ord[1],v1,v2);
                 if(0 === c)
                  {var
                    e2$1=cons_enum(r2,e2$0),
                    e1$1=cons_enum(r1,e1$0),
                    e1=e1$1,
                    e2=e2$1;
                   continue}
                 return c}
               return 1}
             return e2?-1:0}}
         function equal(s1,s2){return 0 === compare(s1,s2)?1:0}
         function subset(s1,s2)
          {var s1$0=s1,s2$0=s2;
           for(;;)
            {if(s1$0)
              {if(s2$0)
                {var
                  r2=s2$0[3],
                  v2=s2$0[2],
                  l2=s2$0[1],
                  r1=s1$0[3],
                  v1=s1$0[2],
                  l1=s1$0[1],
                  c=caml_call2(Ord[1],v1,v2);
                 if(0 === c)
                  {var _vV_=subset(l1,l2);
                   if(_vV_){var s1$0=r1,s2$0=r2;continue}
                   return _vV_}
                 if(0 <= c)
                  {var _vW_=subset([0,0,v1,r1,0],r2);
                   if(_vW_){var s1$0=l1;continue}
                   return _vW_}
                 var _vX_=subset([0,l1,v1,0,0],l2);
                 if(_vX_){var s1$0=r1;continue}
                 return _vX_}
               return 0}
             return 1}}
         function iter(f,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var r=param$0[3],v=param$0[2],l=param$0[1];
               iter(f,l);
               caml_call1(f,v);
               var param$0=r;
               continue}
             return 0}}
         function fold(f,s,accu)
          {var s$0=s,accu$0=accu;
           for(;;)
            {if(s$0)
              {var
                r=s$0[3],
                v=s$0[2],
                l=s$0[1],
                accu$1=caml_call2(f,v,fold(f,l,accu$0)),
                s$0=r,
                accu$0=accu$1;
               continue}
             return accu$0}}
         function for_all(p,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[3],
                v=param$0[2],
                l=param$0[1],
                _vS_=caml_call1(p,v);
               if(_vS_)
                {var _vT_=for_all(p,l);
                 if(_vT_){var param$0=r;continue}
                 var _vU_=_vT_}
               else
                var _vU_=_vS_;
               return _vU_}
             return 1}}
         function exists(p,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[3],
                v=param$0[2],
                l=param$0[1],
                _vP_=caml_call1(p,v);
               if(_vP_)
                var _vQ_=_vP_;
               else
                {var _vR_=exists(p,l);
                 if(! _vR_){var param$0=r;continue}
                 var _vQ_=_vR_}
               return _vQ_}
             return 0}}
         function filter(p,t)
          {if(t)
            {var
              r=t[3],
              v=t[2],
              l=t[1],
              l$0=filter(p,l),
              pv=caml_call1(p,v),
              r$0=filter(p,r);
             if(pv){if(l === l$0 && r === r$0)return t;return join(l$0,v,r$0)}
             return concat(l$0,r$0)}
           return 0}
         function partition(p,param)
          {if(param)
            {var
              r=param[3],
              v=param[2],
              l=param[1],
              match=partition(p,l),
              lf=match[2],
              lt=match[1],
              pv=caml_call1(p,v),
              match$0=partition(p,r),
              rf=match$0[2],
              rt=match$0[1];
             if(pv){var _vN_=concat(lf,rf);return [0,join(lt,v,rt),_vN_]}
             var _vO_=join(lf,v,rf);
             return [0,concat(lt,rt),_vO_]}
           return _J_}
         function cardinal(param)
          {if(param)
            {var r=param[3],l=param[1],_vM_=cardinal(r);
             return (cardinal(l) + 1 | 0) + _vM_ | 0}
           return 0}
         function elements_aux(accu,param)
          {var accu$0=accu,param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[3],
                v=param$0[2],
                l=param$0[1],
                accu$1=[0,v,elements_aux(accu$0,r)],
                accu$0=accu$1,
                param$0=l;
               continue}
             return accu$0}}
         function elements(s){return elements_aux(0,s)}
         function find(x,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[3],
                v=param$0[2],
                l=param$0[1],
                c=caml_call2(Ord[1],x,v);
               if(0 === c)return v;
               var param$1=0 <= c?r:l,param$0=param$1;
               continue}
             throw Not_found}}
         function find_first(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var r$0=param$1[3],v$0=param$1[2],l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,param=l$0;
                 for(;;)
                  {if(param)
                    {var r=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,param=l;continue}
                     var param=r;
                     continue}
                   return v0}}
               var param$1=r$0;
               continue}
             throw Not_found}}
         function find_first_opt(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var r$0=param$1[3],v$0=param$1[2],l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,param=l$0;
                 for(;;)
                  {if(param)
                    {var r=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,param=l;continue}
                     var param=r;
                     continue}
                   return [0,v0]}}
               var param$1=r$0;
               continue}
             return 0}}
         function find_last(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var r$0=param$1[3],v$0=param$1[2],l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,param=r$0;
                 for(;;)
                  {if(param)
                    {var r=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,param=r;continue}
                     var param=l;
                     continue}
                   return v0}}
               var param$1=l$0;
               continue}
             throw Not_found}}
         function find_last_opt(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var r$0=param$1[3],v$0=param$1[2],l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,param=r$0;
                 for(;;)
                  {if(param)
                    {var r=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,param=r;continue}
                     var param=l;
                     continue}
                   return [0,v0]}}
               var param$1=l$0;
               continue}
             return 0}}
         function find_opt(x,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[3],
                v=param$0[2],
                l=param$0[1],
                c=caml_call2(Ord[1],x,v);
               if(0 === c)return [0,v];
               var param$1=0 <= c?r:l,param$0=param$1;
               continue}
             return 0}}
         function try_join(l,v,r)
          {var switch$0=0;
           if(0 !== l)
            {var _vL_=max_elt(l);
             if(0 <= caml_call2(Ord[1],_vL_,v))switch$0 = 1}
           if(! switch$0)
            {var switch$1=0;
             if(0 !== r)
              {var _vK_=min_elt(r);
               if(0 <= caml_call2(Ord[1],v,_vK_))switch$1 = 1}
             if(! switch$1)return join(l,v,r)}
           return union(l,add(v,r))}
         function map(f,t)
          {if(t)
            {var
              r=t[3],
              v=t[2],
              l=t[1],
              l$0=map(f,l),
              v$0=caml_call1(f,v),
              r$0=map(f,r);
             if(l === l$0 && v === v$0 && r === r$0)return t;
             return try_join(l$0,v$0,r$0)}
           return 0}
         function filter_map(f,t)
          {if(t)
            {var
              r=t[3],
              v=t[2],
              l=t[1],
              t$0=filter_map(f,l),
              v$0=caml_call1(f,v),
              match=filter_map(f,r);
             if(v$0)
              {var v$1=v$0[1];
               if(l === t$0 && v === v$1 && r === match)return t;
               return try_join(t$0,v$1,match)}
             if(t$0)
              {if(match)
                {var _vJ_=remove_min_elt(match);
                 return try_join(t$0,min_elt(match),_vJ_)}
               return t$0}
             return match}
           return 0}
         function of_list(l)
          {if(l)
            {var _vy_=l[2],_vz_=l[1];
             if(_vy_)
              {var _vA_=_vy_[2],_vB_=_vy_[1];
               if(_vA_)
                {var _vC_=_vA_[2],_vD_=_vA_[1];
                 if(_vC_)
                  {var _vE_=_vC_[2],_vF_=_vC_[1];
                   if(_vE_)
                    {if(_vE_[2])
                      {var
                        l$0=sort_uniq(Ord[1],l),
                        sub=
                         function(n,l)
                          {if(! (3 < n >>> 0))
                            switch(n)
                             {case 0:return [0,0,l];
                              case 1:
                               if(l){var l$3=l[2],x0=l[1];return [0,[0,0,x0,0,1],l$3]}
                               break;
                              case 2:
                               if(l)
                                {var _vG_=l[2];
                                 if(_vG_)
                                  {var l$4=_vG_[2],x1=_vG_[1],x0$0=l[1];
                                   return [0,[0,[0,0,x0$0,0,1],x1,0,2],l$4]}}
                               break;
                              default:
                               if(l)
                                {var _vH_=l[2];
                                 if(_vH_)
                                  {var _vI_=_vH_[2];
                                   if(_vI_)
                                    {var l$5=_vI_[2],x2=_vI_[1],x1$0=_vH_[1],x0$1=l[1];
                                     return [0,[0,[0,0,x0$1,0,1],x1$0,[0,0,x2,0,1],2],l$5]}}}}
                           var nl=n / 2 | 0,match=sub(nl,l),l$0=match[2],left=match[1];
                           if(l$0)
                            {var
                              l$1=l$0[2],
                              mid=l$0[1],
                              match$0=sub((n - nl | 0) - 1 | 0,l$1),
                              l$2=match$0[2],
                              right=match$0[1];
                             return [0,create(left,mid,right),l$2]}
                           throw [0,Assert_failure,_K_]};
                       return sub(length(l$0),l$0)[1]}
                     var x4=_vE_[1];
                     return add(x4,add(_vF_,add(_vD_,add(_vB_,singleton(_vz_)))))}
                   return add(_vF_,add(_vD_,add(_vB_,singleton(_vz_))))}
                 return add(_vD_,add(_vB_,singleton(_vz_)))}
               return add(_vB_,singleton(_vz_))}
             return singleton(_vz_)}
           return empty}
         function add_seq(i,m)
          {return fold_left(function(s,x){return add(x,s)},m,i)}
         function of_seq(i){return add_seq(i,empty)}
         function seq_of_enum(c,param)
          {if(c)
            {var rest=c[3],t=c[2],x=c[1],_vw_=cons_enum(t,rest);
             return [0,x,function(_vx_){return seq_of_enum(_vw_,_vx_)}]}
           return 0}
         function to_seq(c)
          {var _vu_=cons_enum(c,0);
           return function(_vv_){return seq_of_enum(_vu_,_vv_)}}
         function snoc_enum(s,e)
          {var s$0=s,e$0=e;
           for(;;)
            {if(s$0)
              {var
                s$1=s$0[3],
                v=s$0[2],
                l=s$0[1],
                e$1=[0,v,l,e$0],
                s$0=s$1,
                e$0=e$1;
               continue}
             return e$0}}
         function rev_seq_of_enum(c,param)
          {if(c)
            {var rest=c[3],t=c[2],x=c[1],_vs_=snoc_enum(t,rest);
             return [0,x,function(_vt_){return rev_seq_of_enum(_vs_,_vt_)}]}
           return 0}
         function to_rev_seq(c)
          {var _vq_=snoc_enum(c,0);
           return function(_vr_){return rev_seq_of_enum(_vq_,_vr_)}}
         function to_seq_from(low,s)
          {var s$0=s,c=0;
           for(;;)
            {if(s$0)
              {var r=s$0[3],v=s$0[2],l=s$0[1],n=caml_call2(Ord[1],v,low);
               if(0 !== n)
                {if(0 <= n){var c$0=[0,v,r,c],s$0=l,c=c$0;continue}
                 var s$0=r;
                 continue}
               var _vo_=[0,v,r,c]}
             else
              var _vo_=c;
             return function(_vp_){return seq_of_enum(_vo_,_vp_)}}}
         return [0,
                 empty,
                 is_empty,
                 mem,
                 add,
                 singleton,
                 remove,
                 union,
                 inter,
                 disjoint,
                 diff,
                 compare,
                 equal,
                 subset,
                 iter,
                 map,
                 fold,
                 for_all,
                 exists,
                 filter,
                 filter_map,
                 partition,
                 cardinal,
                 elements,
                 min_elt,
                 min_elt_opt,
                 max_elt,
                 max_elt_opt,
                 min_elt,
                 min_elt_opt,
                 split,
                 find,
                 find_opt,
                 find_first,
                 find_first_opt,
                 find_last,
                 find_last_opt,
                 of_list,
                 to_seq_from,
                 to_seq,
                 to_rev_seq,
                 add_seq,
                 of_seq]}];
    caml_register_global(782,Stdlib_set,"Stdlib__set");
    var
     Stdlib_map=
      [0,
       function(Ord)
        {function height(param){if(param){var h=param[5];return h}return 0}
         function create(l,x,d,r)
          {var hl=height(l),hr=height(r),_vn_=hr <= hl?hl + 1 | 0:hr + 1 | 0;
           return [0,l,x,d,r,_vn_]}
         function singleton(x,d){return [0,0,x,d,0,1]}
         function bal(l,x,d,r)
          {if(l)var h=l[5],hl=h;else var hl=0;
           if(r)var h$0=r[5],hr=h$0;else var hr=0;
           if((hr + 2 | 0) < hl)
            {if(l)
              {var lr=l[4],ld=l[3],lv=l[2],ll=l[1],_vi_=height(lr);
               if(_vi_ <= height(ll))return create(ll,lv,ld,create(lr,x,d,r));
               if(lr)
                {var
                  lrr=lr[4],
                  lrd=lr[3],
                  lrv=lr[2],
                  lrl=lr[1],
                  _vj_=create(lrr,x,d,r);
                 return create(create(ll,lv,ld,lrl),lrv,lrd,_vj_)}
               return invalid_arg(cst_Map_bal)}
             return invalid_arg(cst_Map_bal$0)}
           if((hl + 2 | 0) < hr)
            {if(r)
              {var rr=r[4],rd=r[3],rv=r[2],rl=r[1],_vk_=height(rl);
               if(_vk_ <= height(rr))return create(create(l,x,d,rl),rv,rd,rr);
               if(rl)
                {var
                  rlr=rl[4],
                  rld=rl[3],
                  rlv=rl[2],
                  rll=rl[1],
                  _vl_=create(rlr,rv,rd,rr);
                 return create(create(l,x,d,rll),rlv,rld,_vl_)}
               return invalid_arg(cst_Map_bal$1)}
             return invalid_arg(cst_Map_bal$2)}
           var _vm_=hr <= hl?hl + 1 | 0:hr + 1 | 0;
           return [0,l,x,d,r,_vm_]}
         var empty=0;
         function is_empty(param){return param?0:1}
         function add(x,data,m)
          {if(m)
            {var h=m[5],r=m[4],d=m[3],v=m[2],l=m[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)return d === data?m:[0,l,x,data,r,h];
             if(0 <= c){var rr=add(x,data,r);return r === rr?m:bal(l,v,d,rr)}
             var ll=add(x,data,l);
             return l === ll?m:bal(ll,v,d,r)}
           return [0,0,x,data,0,1]}
         function find(x,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[4],
                d=param$0[3],
                v=param$0[2],
                l=param$0[1],
                c=caml_call2(Ord[1],x,v);
               if(0 === c)return d;
               var param$1=0 <= c?r:l,param$0=param$1;
               continue}
             throw Not_found}}
         function find_first(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var
                r$0=param$1[4],
                d$0=param$1[3],
                v$0=param$1[2],
                l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,d0=d$0,param=l$0;
                 for(;;)
                  {if(param)
                    {var r=param[4],d=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,d0=d,param=l;continue}
                     var param=r;
                     continue}
                   return [0,v0,d0]}}
               var param$1=r$0;
               continue}
             throw Not_found}}
         function find_first_opt(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var
                r$0=param$1[4],
                d$0=param$1[3],
                v$0=param$1[2],
                l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,d0=d$0,param=l$0;
                 for(;;)
                  {if(param)
                    {var r=param[4],d=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,d0=d,param=l;continue}
                     var param=r;
                     continue}
                   return [0,[0,v0,d0]]}}
               var param$1=r$0;
               continue}
             return 0}}
         function find_last(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var
                r$0=param$1[4],
                d$0=param$1[3],
                v$0=param$1[2],
                l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,d0=d$0,param=r$0;
                 for(;;)
                  {if(param)
                    {var r=param[4],d=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,d0=d,param=r;continue}
                     var param=l;
                     continue}
                   return [0,v0,d0]}}
               var param$1=l$0;
               continue}
             throw Not_found}}
         function find_last_opt(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var
                r$0=param$1[4],
                d$0=param$1[3],
                v$0=param$1[2],
                l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,d0=d$0,param=r$0;
                 for(;;)
                  {if(param)
                    {var r=param[4],d=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,d0=d,param=r;continue}
                     var param=l;
                     continue}
                   return [0,[0,v0,d0]]}}
               var param$1=l$0;
               continue}
             return 0}}
         function find_opt(x,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[4],
                d=param$0[3],
                v=param$0[2],
                l=param$0[1],
                c=caml_call2(Ord[1],x,v);
               if(0 === c)return [0,d];
               var param$1=0 <= c?r:l,param$0=param$1;
               continue}
             return 0}}
         function mem(x,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[4],
                v=param$0[2],
                l=param$0[1],
                c=caml_call2(Ord[1],x,v),
                _vh_=0 === c?1:0;
               if(_vh_)return _vh_;
               var param$1=0 <= c?r:l,param$0=param$1;
               continue}
             return 0}}
         function min_binding(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var _vg_=param$0[1];
               if(_vg_){var param$0=_vg_;continue}
               var d=param$0[3],v=param$0[2];
               return [0,v,d]}
             throw Not_found}}
         function min_binding_opt(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var _vf_=param$0[1];
               if(_vf_){var param$0=_vf_;continue}
               var d=param$0[3],v=param$0[2];
               return [0,[0,v,d]]}
             return 0}}
         function max_binding(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {if(param$0[4]){var param$1=param$0[4],param$0=param$1;continue}
               var d=param$0[3],v=param$0[2];
               return [0,v,d]}
             throw Not_found}}
         function max_binding_opt(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {if(param$0[4]){var param$1=param$0[4],param$0=param$1;continue}
               var d=param$0[3],v=param$0[2];
               return [0,[0,v,d]]}
             return 0}}
         function remove_min_binding(param)
          {if(param)
            {var _ve_=param[1];
             if(_ve_)
              {var r=param[4],d=param[3],v=param[2];
               return bal(remove_min_binding(_ve_),v,d,r)}
             var r$0=param[4];
             return r$0}
           return invalid_arg(cst_Map_remove_min_elt)}
         function _uP_(t,match)
          {if(t)
            {if(match)
              {var match$0=min_binding(match),d=match$0[2],x=match$0[1];
               return bal(t,x,d,remove_min_binding(match))}
             return t}
           return match}
         function remove(x,m)
          {if(m)
            {var r=m[4],d=m[3],v=m[2],l=m[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)return _uP_(l,r);
             if(0 <= c){var rr=remove(x,r);return r === rr?m:bal(l,v,d,rr)}
             var ll=remove(x,l);
             return l === ll?m:bal(ll,v,d,r)}
           return 0}
         function update(x,f,m)
          {if(m)
            {var h=m[5],r=m[4],d=m[3],v=m[2],l=m[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)
              {var match=caml_call1(f,[0,d]);
               if(match)
                {var data=match[1];return d === data?m:[0,l,x,data,r,h]}
               return _uP_(l,r)}
             if(0 <= c){var rr=update(x,f,r);return r === rr?m:bal(l,v,d,rr)}
             var ll=update(x,f,l);
             return l === ll?m:bal(ll,v,d,r)}
           var match$0=caml_call1(f,0);
           if(match$0){var data$0=match$0[1];return [0,0,x,data$0,0,1]}
           return 0}
         function iter(f,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var r=param$0[4],d=param$0[3],v=param$0[2],l=param$0[1];
               iter(f,l);
               caml_call2(f,v,d);
               var param$0=r;
               continue}
             return 0}}
         function map(f,param)
          {if(param)
            {var
              h=param[5],
              r=param[4],
              d=param[3],
              v=param[2],
              l=param[1],
              l$0=map(f,l),
              d$0=caml_call1(f,d),
              r$0=map(f,r);
             return [0,l$0,v,d$0,r$0,h]}
           return 0}
         function mapi(f,param)
          {if(param)
            {var
              h=param[5],
              r=param[4],
              d=param[3],
              v=param[2],
              l=param[1],
              l$0=mapi(f,l),
              d$0=caml_call2(f,v,d),
              r$0=mapi(f,r);
             return [0,l$0,v,d$0,r$0,h]}
           return 0}
         function fold(f,m,accu)
          {var m$0=m,accu$0=accu;
           for(;;)
            {if(m$0)
              {var
                r=m$0[4],
                d=m$0[3],
                v=m$0[2],
                l=m$0[1],
                accu$1=caml_call3(f,v,d,fold(f,l,accu$0)),
                m$0=r,
                accu$0=accu$1;
               continue}
             return accu$0}}
         function for_all(p,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[4],
                d=param$0[3],
                v=param$0[2],
                l=param$0[1],
                _vb_=caml_call2(p,v,d);
               if(_vb_)
                {var _vc_=for_all(p,l);
                 if(_vc_){var param$0=r;continue}
                 var _vd_=_vc_}
               else
                var _vd_=_vb_;
               return _vd_}
             return 1}}
         function exists(p,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[4],
                d=param$0[3],
                v=param$0[2],
                l=param$0[1],
                _u__=caml_call2(p,v,d);
               if(_u__)
                var _u$_=_u__;
               else
                {var _va_=exists(p,l);
                 if(! _va_){var param$0=r;continue}
                 var _u$_=_va_}
               return _u$_}
             return 0}}
         function add_min_binding(k,x,param)
          {if(param)
            {var r=param[4],d=param[3],v=param[2],l=param[1];
             return bal(add_min_binding(k,x,l),v,d,r)}
           return singleton(k,x)}
         function add_max_binding(k,x,param)
          {if(param)
            {var r=param[4],d=param[3],v=param[2],l=param[1];
             return bal(l,v,d,add_max_binding(k,x,r))}
           return singleton(k,x)}
         function join(l,v,d,r)
          {if(l)
            {if(r)
              {var
                rh=r[5],
                rr=r[4],
                rd=r[3],
                rv=r[2],
                rl=r[1],
                lh=l[5],
                lr=l[4],
                ld=l[3],
                lv=l[2],
                ll=l[1];
               return (rh + 2 | 0) < lh
                       ?bal(ll,lv,ld,join(lr,v,d,r))
                       :(lh + 2 | 0) < rh
                         ?bal(join(l,v,d,rl),rv,rd,rr)
                         :create(l,v,d,r)}
             return add_max_binding(v,d,l)}
           return add_min_binding(v,d,r)}
         function concat(t,match)
          {if(t)
            {if(match)
              {var match$0=min_binding(match),d=match$0[2],x=match$0[1];
               return join(t,x,d,remove_min_binding(match))}
             return t}
           return match}
         function concat_or_join(t1,v,d,t2)
          {if(d){var d$0=d[1];return join(t1,v,d$0,t2)}return concat(t1,t2)}
         function split(x,param)
          {if(param)
            {var
              r=param[4],
              d=param[3],
              v=param[2],
              l=param[1],
              c=caml_call2(Ord[1],x,v);
             if(0 === c)return [0,l,[0,d],r];
             if(0 <= c)
              {var match=split(x,r),rr=match[3],pres=match[2],lr=match[1];
               return [0,join(l,v,d,lr),pres,rr]}
             var
              match$0=split(x,l),
              rl=match$0[3],
              pres$0=match$0[2],
              ll=match$0[1];
             return [0,ll,pres$0,join(rl,v,d,r)]}
           return _L_}
         function merge(f,s1,s2)
          {if(s1)
            {var h1=s1[5],r1=s1[4],d1=s1[3],v1=s1[2],l1=s1[1];
             if(height(s2) <= h1)
              {var
                match=split(v1,s2),
                r2=match[3],
                d2=match[2],
                l2=match[1],
                _u6_=merge(f,r1,r2),
                _u7_=caml_call3(f,v1,[0,d1],d2);
               return concat_or_join(merge(f,l1,l2),v1,_u7_,_u6_)}}
           else
            if(! s2)return 0;
           if(s2)
            {var
              r2$0=s2[4],
              d2$0=s2[3],
              v2=s2[2],
              l2$0=s2[1],
              match$0=split(v2,s1),
              r1$0=match$0[3],
              d1$0=match$0[2],
              l1$0=match$0[1],
              _u8_=merge(f,r1$0,r2$0),
              _u9_=caml_call3(f,v2,d1$0,[0,d2$0]);
             return concat_or_join(merge(f,l1$0,l2$0),v2,_u9_,_u8_)}
           throw [0,Assert_failure,_M_]}
         function union(f,s1,s2)
          {if(s1)
            {if(s2)
              {var
                h2=s2[5],
                r2=s2[4],
                d2=s2[3],
                v2=s2[2],
                l2=s2[1],
                h1=s1[5],
                r1=s1[4],
                d1=s1[3],
                v1=s1[2],
                l1=s1[1];
               if(h2 <= h1)
                {var
                  match=split(v1,s2),
                  r2$0=match[3],
                  d2$0=match[2],
                  l2$0=match[1],
                  l=union(f,l1,l2$0),
                  r=union(f,r1,r2$0);
                 if(d2$0)
                  {var d2$1=d2$0[1];
                   return concat_or_join(l,v1,caml_call3(f,v1,d1,d2$1),r)}
                 return join(l,v1,d1,r)}
               var
                match$0=split(v2,s1),
                r1$0=match$0[3],
                d1$0=match$0[2],
                l1$0=match$0[1],
                l$0=union(f,l1$0,l2),
                r$0=union(f,r1$0,r2);
               if(d1$0)
                {var d1$1=d1$0[1];
                 return concat_or_join(l$0,v2,caml_call3(f,v2,d1$1,d2),r$0)}
               return join(l$0,v2,d2,r$0)}
             var s=s1}
           else
            var s=s2;
           return s}
         function filter(p,m)
          {if(m)
            {var
              r=m[4],
              d=m[3],
              v=m[2],
              l=m[1],
              l$0=filter(p,l),
              pvd=caml_call2(p,v,d),
              r$0=filter(p,r);
             if(pvd)
              {if(l === l$0 && r === r$0)return m;return join(l$0,v,d,r$0)}
             return concat(l$0,r$0)}
           return 0}
         function filter_map(f,param)
          {if(param)
            {var
              r=param[4],
              d=param[3],
              v=param[2],
              l=param[1],
              l$0=filter_map(f,l),
              fvd=caml_call2(f,v,d),
              r$0=filter_map(f,r);
             if(fvd){var d$0=fvd[1];return join(l$0,v,d$0,r$0)}
             return concat(l$0,r$0)}
           return 0}
         function partition(p,param)
          {if(param)
            {var
              r=param[4],
              d=param[3],
              v=param[2],
              l=param[1],
              match=partition(p,l),
              lf=match[2],
              lt=match[1],
              pvd=caml_call2(p,v,d),
              match$0=partition(p,r),
              rf=match$0[2],
              rt=match$0[1];
             if(pvd){var _u4_=concat(lf,rf);return [0,join(lt,v,d,rt),_u4_]}
             var _u5_=join(lf,v,d,rf);
             return [0,concat(lt,rt),_u5_]}
           return _N_}
         function cons_enum(m,e)
          {var m$0=m,e$0=e;
           for(;;)
            {if(m$0)
              {var
                r=m$0[4],
                d=m$0[3],
                v=m$0[2],
                m$1=m$0[1],
                e$1=[0,v,d,r,e$0],
                m$0=m$1,
                e$0=e$1;
               continue}
             return e$0}}
         function compare(cmp,m1,m2)
          {var e2$2=cons_enum(m2,0),e1$2=cons_enum(m1,0),e1=e1$2,e2=e2$2;
           for(;;)
            {if(e1)
              {if(e2)
                {var
                  e2$0=e2[4],
                  r2=e2[3],
                  d2=e2[2],
                  v2=e2[1],
                  e1$0=e1[4],
                  r1=e1[3],
                  d1=e1[2],
                  v1=e1[1],
                  c=caml_call2(Ord[1],v1,v2);
                 if(0 === c)
                  {var c$0=caml_call2(cmp,d1,d2);
                   if(0 === c$0)
                    {var
                      e2$1=cons_enum(r2,e2$0),
                      e1$1=cons_enum(r1,e1$0),
                      e1=e1$1,
                      e2=e2$1;
                     continue}
                   return c$0}
                 return c}
               return 1}
             return e2?-1:0}}
         function equal(cmp,m1,m2)
          {var e2$2=cons_enum(m2,0),e1$2=cons_enum(m1,0),e1=e1$2,e2=e2$2;
           for(;;)
            {if(e1)
              {if(e2)
                {var
                  e2$0=e2[4],
                  r2=e2[3],
                  d2=e2[2],
                  v2=e2[1],
                  e1$0=e1[4],
                  r1=e1[3],
                  d1=e1[2],
                  v1=e1[1],
                  _u1_=0 === caml_call2(Ord[1],v1,v2)?1:0;
                 if(_u1_)
                  {var _u2_=caml_call2(cmp,d1,d2);
                   if(_u2_)
                    {var
                      e2$1=cons_enum(r2,e2$0),
                      e1$1=cons_enum(r1,e1$0),
                      e1=e1$1,
                      e2=e2$1;
                     continue}
                   var _u3_=_u2_}
                 else
                  var _u3_=_u1_;
                 return _u3_}
               return 0}
             return e2?0:1}}
         function cardinal(param)
          {if(param)
            {var r=param[4],l=param[1],_u0_=cardinal(r);
             return (cardinal(l) + 1 | 0) + _u0_ | 0}
           return 0}
         function bindings_aux(accu,param)
          {var accu$0=accu,param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[4],
                d=param$0[3],
                v=param$0[2],
                l=param$0[1],
                accu$1=[0,[0,v,d],bindings_aux(accu$0,r)],
                accu$0=accu$1,
                param$0=l;
               continue}
             return accu$0}}
         function bindings(s){return bindings_aux(0,s)}
         function add_seq(i,m)
          {return fold_left
                   (function(m,param)
                     {var v=param[2],k=param[1];return add(k,v,m)},
                    m,
                    i)}
         function of_seq(i){return add_seq(i,empty)}
         function seq_of_enum(c,param)
          {if(c)
            {var rest=c[4],t=c[3],v=c[2],k=c[1],_uY_=cons_enum(t,rest);
             return [0,[0,k,v],function(_uZ_){return seq_of_enum(_uY_,_uZ_)}]}
           return 0}
         function to_seq(m)
          {var _uW_=cons_enum(m,0);
           return function(_uX_){return seq_of_enum(_uW_,_uX_)}}
         function snoc_enum(s,e)
          {var s$0=s,e$0=e;
           for(;;)
            {if(s$0)
              {var
                s$1=s$0[4],
                d=s$0[3],
                v=s$0[2],
                l=s$0[1],
                e$1=[0,v,d,l,e$0],
                s$0=s$1,
                e$0=e$1;
               continue}
             return e$0}}
         function rev_seq_of_enum(c,param)
          {if(c)
            {var rest=c[4],t=c[3],v=c[2],k=c[1],_uU_=snoc_enum(t,rest);
             return [0,
                     [0,k,v],
                     function(_uV_){return rev_seq_of_enum(_uU_,_uV_)}]}
           return 0}
         function to_rev_seq(c)
          {var _uS_=snoc_enum(c,0);
           return function(_uT_){return rev_seq_of_enum(_uS_,_uT_)}}
         function to_seq_from(low,m)
          {var m$0=m,c=0;
           for(;;)
            {if(m$0)
              {var
                r=m$0[4],
                d=m$0[3],
                v=m$0[2],
                l=m$0[1],
                n=caml_call2(Ord[1],v,low);
               if(0 !== n)
                {if(0 <= n){var c$0=[0,v,d,r,c],m$0=l,c=c$0;continue}
                 var m$0=r;
                 continue}
               var _uQ_=[0,v,d,r,c]}
             else
              var _uQ_=c;
             return function(_uR_){return seq_of_enum(_uQ_,_uR_)}}}
         return [0,
                 empty,
                 is_empty,
                 mem,
                 add,
                 update,
                 singleton,
                 remove,
                 merge,
                 union,
                 compare,
                 equal,
                 iter,
                 fold,
                 for_all,
                 exists,
                 filter,
                 filter_map,
                 partition,
                 cardinal,
                 bindings,
                 min_binding,
                 min_binding_opt,
                 max_binding,
                 max_binding_opt,
                 min_binding,
                 min_binding_opt,
                 split,
                 find,
                 find_opt,
                 find_first,
                 find_first_opt,
                 find_last,
                 find_last_opt,
                 map,
                 mapi,
                 to_seq,
                 to_rev_seq,
                 to_seq_from,
                 add_seq,
                 of_seq]}];
    caml_register_global(783,Stdlib_map,"Stdlib__map");
    var Empty=[248,cst_Stdlib_Stack_Empty,caml_fresh_oo_id(0)];
    function create$0(param){return [0,0,0]}
    function clear(s){s[1] = 0;s[2] = 0;return 0}
    function copy$3(s){return [0,s[1],s[2]]}
    function push(x,s){s[1] = [0,x,s[1]];s[2] = s[2] + 1 | 0;return 0}
    function pop(s)
     {var _uO_=s[1];
      if(_uO_)
       {var tl=_uO_[2],hd=_uO_[1];s[1] = tl;s[2] = s[2] - 1 | 0;return hd}
      throw Empty}
    function pop_opt(s)
     {var _uN_=s[1];
      if(_uN_)
       {var tl=_uN_[2],hd=_uN_[1];s[1] = tl;s[2] = s[2] - 1 | 0;return [0,hd]}
      return 0}
    function top(s)
     {var _uM_=s[1];if(_uM_){var hd=_uM_[1];return hd}throw Empty}
    function top_opt(s)
     {var _uL_=s[1];if(_uL_){var hd=_uL_[1];return [0,hd]}return 0}
    function is_empty(s){return 0 === s[1]?1:0}
    function length$1(s){return s[2]}
    function iter$7(f,s){return iter$2(f,s[1])}
    function fold$2(f,acc,s){return fold_left$0(f,acc,s[1])}
    function to_seq$6(s){return to_seq$1(s[1])}
    function add_seq(q,i){return iter(function(x){return push(x,q)},i)}
    function of_seq$4(g){var s=create$0(0);add_seq(s,g);return s}
    var
     Stdlib_stack=
      [0,
       Empty,
       create$0,
       push,
       pop,
       pop_opt,
       top,
       top_opt,
       clear,
       copy$3,
       is_empty,
       length$1,
       iter$7,
       fold$2,
       to_seq$6,
       add_seq,
       of_seq$4];
    caml_register_global(784,Stdlib_stack,"Stdlib__stack");
    var Empty$0=[248,cst_Stdlib_Queue_Empty,caml_fresh_oo_id(0)];
    function create$1(param){return [0,0,0,0]}
    function clear$0(q){q[1] = 0;q[2] = 0;q[3] = 0;return 0}
    function add(x,q)
     {var cell=[0,x,0],_uK_=q[3];
      return _uK_
              ?(q[1] = q[1] + 1 | 0,_uK_[2] = cell,q[3] = cell,0)
              :(q[1] = 1,q[2] = cell,q[3] = cell,0)}
    function peek(q)
     {var _uJ_=q[2];if(_uJ_){var content=_uJ_[1];return content}throw Empty$0}
    function peek_opt(q)
     {var _uI_=q[2];if(_uI_){var content=_uI_[1];return [0,content]}return 0}
    function take(q)
     {var _uG_=q[2];
      if(_uG_)
       {var _uH_=_uG_[1];
        if(_uG_[2])
         {var next=_uG_[2];q[1] = q[1] - 1 | 0;q[2] = next;return _uH_}
        clear$0(q);
        return _uH_}
      throw Empty$0}
    function take_opt(q)
     {var _uE_=q[2];
      if(_uE_)
       {var _uF_=_uE_[1];
        if(_uE_[2])
         {var next=_uE_[2];q[1] = q[1] - 1 | 0;q[2] = next;return [0,_uF_]}
        clear$0(q);
        return [0,_uF_]}
      return 0}
    function copy$4(q)
     {var q_res=[0,q[1],0,0],prev=0,cell=q[2];
      for(;;)
       {if(cell)
         {var content=cell[1],next=cell[2],res=[0,content,0];
          if(prev)prev[2] = res;else q_res[2] = res;
          var prev=res,cell=next;
          continue}
        q_res[3] = prev;
        return q_res}}
    function is_empty$0(q){return 0 === q[1]?1:0}
    function length$2(q){return q[1]}
    function iter$8(f,q)
     {var cell=q[2];
      for(;;)
       {if(cell)
         {var content=cell[1],next=cell[2];
          caml_call1(f,content);
          var cell=next;
          continue}
        return 0}}
    function fold$3(f,accu$1,q)
     {var accu=accu$1,cell=q[2];
      for(;;)
       {if(cell)
         {var
           content=cell[1],
           next=cell[2],
           accu$0=caml_call2(f,accu,content),
           accu=accu$0,
           cell=next;
          continue}
        return accu}}
    function transfer(q1,q2)
     {var _uC_=0 < q1[1]?1:0;
      if(_uC_)
       {var _uD_=q2[3];
        return _uD_
                ?(q2[1]
                  =
                  q2[1]
                  +
                  q1[1]
                  |
                  0,
                  _uD_[2]
                  =
                  q1[2],
                  q2[3]
                  =
                  q1[3],
                  clear$0(q1))
                :(q2[1] = q1[1],q2[2] = q1[2],q2[3] = q1[3],clear$0(q1))}
      return _uC_}
    function to_seq$7(q)
     {function aux(c,param)
       {if(c)
         {var x=c[1],next=c[2];
          return [0,x,function(_uB_){return aux(next,_uB_)}]}
        return 0}
      var _uz_=q[2];
      return function(_uA_){return aux(_uz_,_uA_)}}
    function add_seq$0(q,i){return iter(function(x){return add(x,q)},i)}
    function of_seq$5(g){var q=create$1(0);add_seq$0(q,g);return q}
    var
     Stdlib_queue=
      [0,
       Empty$0,
       create$1,
       add,
       add,
       take,
       take_opt,
       take,
       peek,
       peek_opt,
       peek,
       clear$0,
       copy$4,
       is_empty$0,
       length$2,
       iter$8,
       fold$3,
       transfer,
       to_seq$7,
       add_seq$0,
       of_seq$5];
    caml_register_global(785,Stdlib_queue,"Stdlib__queue");
    var Undefined=[248,cst_CamlinternalLazy_Undefined,caml_fresh_oo_id(0)];
    function raise_undefined(param){throw Undefined}
    function force_lazy_block(blk)
     {var closure=blk[1];
      blk[1] = raise_undefined;
      try
       {var result=caml_call1(closure,0);
        caml_obj_make_forward(blk,result);
        return result}
      catch(e)
       {e = caml_wrap_exception(e);blk[1] = function(param){throw e};throw e}}
    function force_val_lazy_block(blk)
     {var closure=blk[1];
      blk[1] = raise_undefined;
      var result=caml_call1(closure,0);
      caml_obj_make_forward(blk,result);
      return result}
    function force(lzv)
     {var t=caml_obj_tag(lzv);
      return t === 250?lzv[1]:t !== 246?lzv:force_lazy_block(lzv)}
    function force_val(lzv)
     {var t=caml_obj_tag(lzv);
      return t === 250?lzv[1]:t !== 246?lzv:force_val_lazy_block(lzv)}
    var
     CamlinternalLazy=
      [0,Undefined,force_lazy_block,force_val_lazy_block,force,force_val];
    caml_register_global(786,CamlinternalLazy,"CamlinternalLazy");
    function from_fun(f){var x=caml_obj_block(246,1);x[1] = f;return x}
    function from_val(v)
     {var t=caml_obj_tag(v);
      if(t !== 250 && t !== 246 && t !== 253)return v;
      return runtime.caml_lazy_make_forward(v)}
    function is_val(l){return caml_obj_tag(l) !== 246?1:0}
    var
     Stdlib_lazy=
      [0,
       Undefined,
       force_val,
       from_fun,
       from_val,
       is_val,
       from_fun,
       from_val,
       is_val];
    caml_register_global(787,Stdlib_lazy,"Stdlib__lazy");
    var
     Failure$0=[248,cst_Stdlib_Stream_Failure,caml_fresh_oo_id(0)],
     Error=[248,cst_Stdlib_Stream_Error,caml_fresh_oo_id(0)];
    function count(param)
     {if(param){var match=param[1],count=match[1];return count}return 0}
    function data(param)
     {if(param){var match=param[1],data=match[2];return data}return 0}
    function fill_buff(b)
     {b[3] = input(b[1],b[2],0,caml_ml_bytes_length(b[2]));b[4] = 0;return 0}
    function get_data(count,d)
     {var d$0=d;
      for(;;)
       {if(typeof d$0 !== "number")
         switch(d$0[0])
          {case 1:
            var d2=d$0[2],d1=d$0[1],match=get_data(count,d1);
            if(typeof match === "number")
             {var d$0=d2;continue}
            else
             {if(0 === match[0])
               {var d11=match[2],a=match[1];return [0,a,[1,d11,d2]]}
              throw [0,Assert_failure,_O_]}
           case 2:
            var
             f=d$0[1],
             _uv_=caml_obj_tag(f),
             d$1=250 === _uv_?f[1]:246 === _uv_?force_lazy_block(f):f,
             d$0=d$1;
            continue;
           case 3:
            var _uw_=d$0[1],_ux_=_uw_[1];
            if(_ux_)
             {var _uy_=_ux_[1];
              if(_uy_){var a$0=_uy_[1];_uw_[1] = 0;return [0,a$0,d$0]}
              return 0}
            var match$0=caml_call1(_uw_[2],count);
            if(match$0){var a$1=match$0[1];return [0,a$1,d$0]}
            _uw_[1] = _P_;
            return 0;
           case 4:
            var b=d$0[1];
            if(b[3] <= b[4])fill_buff(b);
            if(0 === b[3])return 0;
            var r=caml_bytes_unsafe_get(b[2],b[4]);
            b[4] = b[4] + 1 | 0;
            return [0,r,d$0]
           }
        return d$0}}
    function peek_data(s)
     {for(;;)
       {var _uq_=s[2];
        if(typeof _uq_ === "number")
         return 0;
        else
         switch(_uq_[0])
          {case 0:var a=_uq_[1];return [0,a];
           case 1:
            var d=get_data(s[1],s[2]);
            if(typeof d === "number")
             return 0;
            else
             {if(0 === d[0]){var a$0=d[1];s[2] = d;return [0,a$0]}
              throw [0,Assert_failure,_Q_]}
           case 2:
            var
             f=_uq_[1],
             _ur_=caml_obj_tag(f),
             _us_=250 === _ur_?f[1]:246 === _ur_?force_lazy_block(f):f;
            s[2] = _us_;
            continue;
           case 3:
            var _ut_=_uq_[1],_uu_=_ut_[1];
            if(_uu_){var a$1=_uu_[1];return a$1}
            var x=caml_call1(_ut_[2],s[1]);
            _ut_[1] = [0,x];
            return x;
           default:
            var b=_uq_[1];
            if(b[3] <= b[4])fill_buff(b);
            return 0 === b[3]
                    ?(s[2] = 0,0)
                    :[0,caml_bytes_unsafe_get(b[2],b[4])]}}}
    function peek$0(param)
     {if(param){var s=param[1];return peek_data(s)}return 0}
    function junk_data(s)
     {for(;;)
       {var _uo_=s[2];
        if(typeof _uo_ !== "number")
         switch(_uo_[0])
          {case 0:var d=_uo_[2];s[1] = s[1] + 1 | 0;s[2] = d;return 0;
           case 3:
            var _up_=_uo_[1];
            if(_up_[1]){s[1] = s[1] + 1 | 0;_up_[1] = 0;return 0}
            break;
           case 4:
            var b=_uo_[1];
            if(b[3] <= b[4])fill_buff(b);
            return 0 === b[3]
                    ?(s[2] = 0,0)
                    :(s[1] = s[1] + 1 | 0,b[4] = b[4] + 1 | 0,0)
           }
        var match=peek_data(s);
        if(match)continue;
        return 0}}
    function junk(param)
     {if(param){var data=param[1];return junk_data(data)}return 0}
    function nget_data(n,s)
     {if(0 < n)
       {var match=peek_data(s);
        if(match)
         {var a=match[1];
          junk_data(s);
          var
           match$0=nget_data(n - 1 | 0,s),
           k=match$0[3],
           d=match$0[2],
           al=match$0[1];
          return [0,[0,a,al],[0,a,d],k + 1 | 0]}
        return [0,0,s[2],0]}
      return [0,0,s[2],0]}
    function npeek(n,param)
     {if(param)
       {var
         d$0=param[1],
         match=nget_data(n,d$0),
         len=match[3],
         d=match[2],
         al=match[1];
        d$0[1] = d$0[1] - len | 0;
        d$0[2] = d;
        return al}
      return 0}
    function next(s)
     {var match=peek$0(s);
      if(match){var a=match[1];junk(s);return a}
      throw Failure$0}
    function empty$1(s){var match=peek$0(s);if(match)throw Failure$0;return 0}
    function iter$9(f,strm)
     {for(;;)
       {var match=peek$0(strm);
        if(match){var a=match[1];junk(strm);caml_call1(f,a);continue}
        return 0}}
    function from(f){return [0,[0,0,[3,[0,0,f]]]]}
    function of_list$1(l)
     {var _un_=0;
      return [0,[0,0,fold_right(function(x,l){return [0,x,l]},l,_un_)]]}
    function of_string$0(s)
     {var count=[0,0];
      return from
              (function(param)
                {var c=count[1];
                 return c < caml_ml_string_length(s)
                         ?(count[1]++,[0,caml_string_get(s,c)])
                         :0})}
    function of_bytes(s)
     {var count=[0,0];
      return from
              (function(param)
                {var c=count[1];
                 return c < caml_ml_bytes_length(s)
                         ?(count[1]++,[0,caml_bytes_get(s,c)])
                         :0})}
    function of_channel(ic)
     {return [0,[0,0,[4,[0,ic,caml_create_bytes(4096),0,0]]]]}
    function iapp(i,s){var _um_=data(s);return [0,[0,0,[1,data(i),_um_]]]}
    function icons(i,s){return [0,[0,0,[0,i,data(s)]]]}
    function ising(i){return [0,[0,0,[0,i,0]]]}
    function lapp(f,s)
     {return [0,
              [0,
               0,
               [2,
                [246,
                 function(_uk_)
                  {var _ul_=data(s);return [1,data(caml_call1(f,0)),_ul_]}]]]]}
    function lcons(f,s)
     {return [0,
              [0,
               0,
               [2,
                [246,
                 function(_ui_)
                  {var _uj_=data(s);return [0,caml_call1(f,0),_uj_]}]]]]}
    function lsing(f)
     {return [0,[0,0,[2,[246,function(_uh_){return [0,caml_call1(f,0),0]}]]]]}
    var sempty=0;
    function slazy(f)
     {return [0,[0,0,[2,[246,function(_ug_){return data(caml_call1(f,0))}]]]]}
    function dump_data(f,param)
     {if(typeof param === "number")
       return print_string(cst_Sempty);
      else
       switch(param[0])
        {case 0:
          var d=param[2],a=param[1];
          print_string(cst_Scons);
          caml_call1(f,a);
          print_string(cst$7);
          dump_data(f,d);
          return print_string(cst$8);
         case 1:
          var d2=param[2],d1=param[1];
          print_string(cst_Sapp);
          dump_data(f,d1);
          print_string(cst$9);
          dump_data(f,d2);
          return print_string(cst$10);
         case 2:return print_string(cst_Slazy);
         case 3:return print_string(cst_Sgen);
         default:return print_string(cst_Sbuffio)}}
    function dump(f,s)
     {print_string(cst_count);
      print_int(count(s));
      print_string(cst_data);
      dump_data(f,data(s));
      print_string(cst$6);
      return print_newline(0)}
    var
     Stdlib_stream=
      [0,
       Failure$0,
       Error,
       from,
       of_list$1,
       of_string$0,
       of_bytes,
       of_channel,
       iter$9,
       next,
       empty$1,
       peek$0,
       junk,
       count,
       npeek,
       iapp,
       icons,
       ising,
       lapp,
       lcons,
       lsing,
       sempty,
       slazy,
       dump];
    caml_register_global(788,Stdlib_stream,"Stdlib__stream");
    function create$2(n)
     {var
       n$0=1 <= n?n:1,
       n$1=max_string_length < n$0?max_string_length:n$0,
       s=caml_create_bytes(n$1);
      return [0,s,0,n$1,s]}
    function contents(b){return sub_string(b[1],0,b[2])}
    function to_bytes(b){return sub(b[1],0,b[2])}
    function sub$3(b,ofs,len)
     {if(0 <= ofs && 0 <= len && ! ((b[2] - len | 0) < ofs))
       return sub_string(b[1],ofs,len);
      return invalid_arg(cst_Buffer_sub)}
    function blit$3(src,srcoff,dst,dstoff,len)
     {if
       (0
        <=
        len
        &&
        0
        <=
        srcoff
        &&
        !
        ((src[2] - len | 0) < srcoff)
        &&
        0
        <=
        dstoff
        &&
        !
        ((caml_ml_bytes_length(dst) - len | 0) < dstoff))
       return caml_blit_bytes(src[1],srcoff,dst,dstoff,len);
      return invalid_arg(cst_Buffer_blit)}
    function nth$0(b,ofs)
     {if(0 <= ofs && ! (b[2] <= ofs))return caml_bytes_unsafe_get(b[1],ofs);
      return invalid_arg(cst_Buffer_nth)}
    function length$3(b){return b[2]}
    function clear$1(b){b[2] = 0;return 0}
    function reset(b)
     {b[2] = 0;b[1] = b[4];b[3] = caml_ml_bytes_length(b[1]);return 0}
    function resize(b,more)
     {var old_pos=b[2],old_len=b[3],new_len=[0,old_len];
      for(;;)
       {if(new_len[1] < (old_pos + more | 0))
         {new_len[1] = 2 * new_len[1] | 0;continue}
        if(max_string_length < new_len[1])
         if((old_pos + more | 0) <= max_string_length)
          new_len[1] = max_string_length;
         else
          failwith(cst_Buffer_add_cannot_grow_buf);
        var new_buffer=caml_create_bytes(new_len[1]);
        blit(b[1],0,new_buffer,0,b[2]);
        b[1] = new_buffer;
        b[3] = new_len[1];
        if((b[2] + more | 0) <= b[3])
         {if((old_pos + more | 0) <= b[3])return 0;
          throw [0,Assert_failure,_R_]}
        throw [0,Assert_failure,_S_]}}
    function add_char(b,c)
     {var pos=b[2];
      if(b[3] <= pos)resize(b,1);
      caml_bytes_unsafe_set(b[1],pos,c);
      b[2] = pos + 1 | 0;
      return 0}
    function add_utf_8_uchar(b,u)
     {if(0 <= u)
       {if(127 < u)
         {if(2047 < u)
           {if(65535 < u)
             {if(1114111 < u)throw [0,Assert_failure,_T_];
              var pos=b[2];
              if(b[3] < (pos + 4 | 0))resize(b,4);
              caml_bytes_unsafe_set(b[1],pos,240 | u >>> 18 | 0);
              caml_bytes_unsafe_set
               (b[1],pos + 1 | 0,128 | (u >>> 12 | 0) & 63);
              caml_bytes_unsafe_set(b[1],pos + 2 | 0,128 | (u >>> 6 | 0) & 63);
              caml_bytes_unsafe_set(b[1],pos + 3 | 0,128 | u & 63);
              b[2] = pos + 4 | 0;
              return 0}
            var pos$0=b[2];
            if(b[3] < (pos$0 + 3 | 0))resize(b,3);
            caml_bytes_unsafe_set(b[1],pos$0,224 | u >>> 12 | 0);
            caml_bytes_unsafe_set(b[1],pos$0 + 1 | 0,128 | (u >>> 6 | 0) & 63);
            caml_bytes_unsafe_set(b[1],pos$0 + 2 | 0,128 | u & 63);
            b[2] = pos$0 + 3 | 0;
            return 0}
          var pos$1=b[2];
          if(b[3] < (pos$1 + 2 | 0))resize(b,2);
          caml_bytes_unsafe_set(b[1],pos$1,192 | u >>> 6 | 0);
          caml_bytes_unsafe_set(b[1],pos$1 + 1 | 0,128 | u & 63);
          b[2] = pos$1 + 2 | 0;
          return 0}
        return add_char(b,u)}
      throw [0,Assert_failure,_U_]}
    function add_utf_16be_uchar(b,u)
     {if(0 <= u)
       {if(65535 < u)
         {if(1114111 < u)throw [0,Assert_failure,_V_];
          var
           u$0=u - 65536 | 0,
           hi=55296 | u$0 >>> 10 | 0,
           lo=56320 | u$0 & 1023,
           pos=b[2];
          if(b[3] < (pos + 4 | 0))resize(b,4);
          caml_bytes_unsafe_set(b[1],pos,hi >>> 8 | 0);
          caml_bytes_unsafe_set(b[1],pos + 1 | 0,hi & 255);
          caml_bytes_unsafe_set(b[1],pos + 2 | 0,lo >>> 8 | 0);
          caml_bytes_unsafe_set(b[1],pos + 3 | 0,lo & 255);
          b[2] = pos + 4 | 0;
          return 0}
        var pos$0=b[2];
        if(b[3] < (pos$0 + 2 | 0))resize(b,2);
        caml_bytes_unsafe_set(b[1],pos$0,u >>> 8 | 0);
        caml_bytes_unsafe_set(b[1],pos$0 + 1 | 0,u & 255);
        b[2] = pos$0 + 2 | 0;
        return 0}
      throw [0,Assert_failure,_W_]}
    function add_utf_16le_uchar(b,u)
     {if(0 <= u)
       {if(65535 < u)
         {if(1114111 < u)throw [0,Assert_failure,_X_];
          var
           u$0=u - 65536 | 0,
           hi=55296 | u$0 >>> 10 | 0,
           lo=56320 | u$0 & 1023,
           pos=b[2];
          if(b[3] < (pos + 4 | 0))resize(b,4);
          caml_bytes_unsafe_set(b[1],pos,hi & 255);
          caml_bytes_unsafe_set(b[1],pos + 1 | 0,hi >>> 8 | 0);
          caml_bytes_unsafe_set(b[1],pos + 2 | 0,lo & 255);
          caml_bytes_unsafe_set(b[1],pos + 3 | 0,lo >>> 8 | 0);
          b[2] = pos + 4 | 0;
          return 0}
        var pos$0=b[2];
        if(b[3] < (pos$0 + 2 | 0))resize(b,2);
        caml_bytes_unsafe_set(b[1],pos$0,u & 255);
        caml_bytes_unsafe_set(b[1],pos$0 + 1 | 0,u >>> 8 | 0);
        b[2] = pos$0 + 2 | 0;
        return 0}
      throw [0,Assert_failure,_Y_]}
    function add_substring(b,s,offset,len)
     {var _ud_=offset < 0?1:0;
      if(_ud_)
       var _ue_=_ud_;
      else
       var
        _uf_=len < 0?1:0,
        _ue_=_uf_ || ((caml_ml_string_length(s) - len | 0) < offset?1:0);
      if(_ue_)invalid_arg(cst_Buffer_add_substring_add_s);
      var new_position=b[2] + len | 0;
      if(b[3] < new_position)resize(b,len);
      caml_blit_string(s,offset,b[1],b[2],len);
      b[2] = new_position;
      return 0}
    function add_subbytes(b,s,offset,len)
     {return add_substring(b,caml_string_of_bytes(s),offset,len)}
    function add_string(b,s)
     {var len=caml_ml_string_length(s),new_position=b[2] + len | 0;
      if(b[3] < new_position)resize(b,len);
      caml_blit_string(s,0,b[1],b[2],len);
      b[2] = new_position;
      return 0}
    function add_bytes(b,s){return add_string(b,caml_string_of_bytes(s))}
    function add_buffer(b,bs){return add_subbytes(b,bs[1],0,bs[2])}
    function add_channel(b,ic,len)
     {var _ub_=len < 0?1:0,_uc_=_ub_ || (max_string_length < len?1:0);
      if(_uc_)invalid_arg(cst_Buffer_add_channel);
      if(b[3] < (b[2] + len | 0))resize(b,len);
      var already_read=0,ofs=b[2],to_read=len,_ua_=b[1];
      for(;;)
       {if(0 !== to_read)
         {var r=input(ic,_ua_,ofs,to_read);
          if(0 !== r)
           {var
             already_read$0=already_read + r | 0,
             ofs$0=ofs + r | 0,
             to_read$0=to_read - r | 0,
             already_read=already_read$0,
             ofs=ofs$0,
             to_read=to_read$0;
            continue}}
        if((b[2] + already_read | 0) <= b[3])
         {b[2] = b[2] + already_read | 0;
          if(already_read < len)throw End_of_file;
          return 0}
        throw [0,Assert_failure,_Z_]}}
    function output_buffer(oc,b){return output(oc,b[1],0,b[2])}
    function add_substitute(b,f,s)
     {var lim$1=caml_ml_string_length(s),previous=32,i$7=0;
      for(;;)
       {if(i$7 < lim$1)
         {var current=caml_string_get(s,i$7);
          if(36 === current)
           {if(92 === previous)
             {add_char(b,current);
              var i$8=i$7 + 1 | 0,previous=32,i$7=i$8;
              continue}
            var start=i$7 + 1 | 0;
            if(lim$1 <= start)throw Not_found;
            var opening=caml_string_get(s,start),switch$0=0;
            if(40 !== opening && 123 !== opening)
             {var i$6=start + 1 | 0,lim$0=caml_ml_string_length(s),i$3=i$6;
              for(;;)
               {if(lim$0 <= i$3)
                 var stop=lim$0;
                else
                 {var match=caml_string_get(s,i$3),switch$1=0;
                  if(91 <= match)
                   {if(97 <= match)
                     {if(! (123 <= match))switch$1 = 1}
                    else
                     if(95 === match)switch$1 = 1}
                  else
                   if(58 <= match)
                    {if(65 <= match)switch$1 = 1}
                   else
                    if(48 <= match)switch$1 = 1;
                  if(switch$1){var i$4=i$3 + 1 | 0,i$3=i$4;continue}
                  var stop=i$3}
                var match$0=[0,sub$0(s,start,stop - start | 0),stop];
                switch$0 = 1;
                break}}
            if(! switch$0)
             {var i$5=start + 1 | 0,k$2=0;
              if(40 === opening)
               var _t__=41;
              else
               {if(123 !== opening)throw [0,Assert_failure,___];var _t__=125}
              var lim=caml_ml_string_length(s),k=k$2,i=i$5;
              for(;;)
               {if(lim <= i)throw Not_found;
                if(caml_string_get(s,i) === opening)
                 {var i$0=i + 1 | 0,k$0=k + 1 | 0,k=k$0,i=i$0;continue}
                if(caml_string_get(s,i) !== _t__)
                 {var i$2=i + 1 | 0,i=i$2;continue}
                if(0 !== k)
                 {var i$1=i + 1 | 0,k$1=k - 1 | 0,k=k$1,i=i$1;continue}
                var
                 match$0=
                  [0,sub$0(s,i$5,(i - start | 0) - 1 | 0),i + 1 | 0];
                break}}
            var next_i=match$0[2],ident=match$0[1];
            add_string(b,caml_call1(f,ident));
            var previous=32,i$7=next_i;
            continue}
          if(92 === previous)
           {add_char(b,92);
            add_char(b,current);
            var i$9=i$7 + 1 | 0,previous=32,i$7=i$9;
            continue}
          if(92 === current)
           {var i$10=i$7 + 1 | 0,previous=current,i$7=i$10;continue}
          add_char(b,current);
          var i$11=i$7 + 1 | 0,previous=current,i$7=i$11;
          continue}
        var _t$_=92 === previous?1:0;
        return _t$_?add_char(b,previous):_t$_}}
    function truncate(b,len)
     {if(0 <= len && ! (b[2] < len)){b[2] = len;return 0}
      return invalid_arg(cst_Buffer_truncate)}
    function to_seq$8(b)
     {function aux(i,param)
       {if(b[2] <= i)return 0;
        var x=caml_bytes_unsafe_get(b[1],i),_t8_=i + 1 | 0;
        return [0,x,function(_t9_){return aux(_t8_,_t9_)}]}
      var _t6_=0;
      return function(_t7_){return aux(_t6_,_t7_)}}
    function to_seqi$3(b)
     {function aux(i,param)
       {if(b[2] <= i)return 0;
        var x=caml_bytes_unsafe_get(b[1],i),_t4_=i + 1 | 0;
        return [0,[0,i,x],function(_t5_){return aux(_t4_,_t5_)}]}
      var _t2_=0;
      return function(_t3_){return aux(_t2_,_t3_)}}
    function add_seq$1(b,seq)
     {return iter(function(_t1_){return add_char(b,_t1_)},seq)}
    function of_seq$6(i){var b=create$2(32);add_seq$1(b,i);return b}
    function add_int8(b,x)
     {var new_position=b[2] + 1 | 0;
      if(b[3] < new_position)resize(b,1);
      caml_bytes_unsafe_set(b[1],b[2],x);
      b[2] = new_position;
      return 0}
    function add_int16_ne(b,x)
     {var new_position=b[2] + 2 | 0;
      if(b[3] < new_position)resize(b,2);
      caml_bytes_set16(b[1],b[2],x);
      b[2] = new_position;
      return 0}
    function add_int32_ne(b,x)
     {var new_position=b[2] + 4 | 0;
      if(b[3] < new_position)resize(b,4);
      caml_bytes_set32(b[1],b[2],x);
      b[2] = new_position;
      return 0}
    function add_int64_ne(b,x)
     {var new_position=b[2] + 8 | 0;
      if(b[3] < new_position)resize(b,8);
      caml_bytes_set64(b[1],b[2],x);
      b[2] = new_position;
      return 0}
    function add_int16_le(b,x){return add_int16_ne(b,x)}
    function add_int16_be(b,x)
     {var x$0=caml_bswap16(x);return add_int16_ne(b,x$0)}
    function add_int32_le(b,x){return add_int32_ne(b,x)}
    function add_int32_be(b,x)
     {var x$0=caml_int32_bswap(x);return add_int32_ne(b,x$0)}
    function add_int64_le(b,x){return add_int64_ne(b,x)}
    function add_int64_be(b,x)
     {var x$0=caml_int64_bswap(x);return add_int64_ne(b,x$0)}
    var
     Stdlib_buffer=
      [0,
       create$2,
       contents,
       to_bytes,
       sub$3,
       blit$3,
       nth$0,
       length$3,
       clear$1,
       reset,
       add_char,
       add_utf_8_uchar,
       add_utf_16le_uchar,
       add_utf_16be_uchar,
       add_string,
       add_bytes,
       add_substring,
       add_subbytes,
       add_substitute,
       add_buffer,
       add_channel,
       output_buffer,
       truncate,
       to_seq$8,
       to_seqi$3,
       add_seq$1,
       of_seq$6,
       add_int8,
       add_int8,
       add_int16_ne,
       add_int16_be,
       add_int16_le,
       add_int16_ne,
       add_int16_be,
       add_int16_le,
       add_int32_ne,
       add_int32_be,
       add_int32_le,
       add_int64_ne,
       add_int64_be,
       add_int64_le];
    caml_register_global(789,Stdlib_buffer,"Stdlib__buffer");
    function create_char_set(param){return make$0(32,0)}
    function add_in_char_set(char_set,c)
     {var str_ind=c >>> 3 | 0,mask=1 << (c & 7);
      return caml_bytes_set
              (char_set,
               str_ind,
               char_of_int(caml_bytes_get(char_set,str_ind) | mask))}
    function freeze_char_set(char_set){return to_string$1(char_set)}
    function rev_char_set(char_set)
     {var char_set$0=create_char_set(0),i=0;
      for(;;)
       {caml_bytes_set
         (char_set$0,i,char_of_int(caml_string_get(char_set,i) ^ 255));
        var _t0_=i + 1 | 0;
        if(31 !== i){var i=_t0_;continue}
        return caml_string_of_bytes(char_set$0)}}
    function is_in_char_set(char_set,c)
     {var str_ind=c >>> 3 | 0,mask=1 << (c & 7);
      return 0 !== (caml_string_get(char_set,str_ind) & mask)?1:0}
    function pad_of_pad_opt(pad_opt)
     {if(pad_opt){var width=pad_opt[1];return [0,1,width]}return 0}
    function param_format_of_ignored_format(ign,fmt)
     {if(typeof ign === "number")
       switch(ign)
        {case 0:return [0,[0,fmt]];
         case 1:return [0,[1,fmt]];
         case 2:return [0,[19,fmt]];
         default:return [0,[22,fmt]]}
      else
       switch(ign[0])
        {case 0:var pad_opt=ign[1];return [0,[2,pad_of_pad_opt(pad_opt),fmt]];
         case 1:
          var pad_opt$0=ign[1];return [0,[3,pad_of_pad_opt(pad_opt$0),fmt]];
         case 2:
          var pad_opt$1=ign[2],iconv=ign[1];
          return [0,[4,iconv,pad_of_pad_opt(pad_opt$1),0,fmt]];
         case 3:
          var pad_opt$2=ign[2],iconv$0=ign[1];
          return [0,[5,iconv$0,pad_of_pad_opt(pad_opt$2),0,fmt]];
         case 4:
          var pad_opt$3=ign[2],iconv$1=ign[1];
          return [0,[6,iconv$1,pad_of_pad_opt(pad_opt$3),0,fmt]];
         case 5:
          var pad_opt$4=ign[2],iconv$2=ign[1];
          return [0,[7,iconv$2,pad_of_pad_opt(pad_opt$4),0,fmt]];
         case 6:
          var prec_opt=ign[2],pad_opt$5=ign[1];
          if(prec_opt)var ndec=prec_opt[1],_tZ_=[0,ndec];else var _tZ_=0;
          return [0,[8,_$_,pad_of_pad_opt(pad_opt$5),_tZ_,fmt]];
         case 7:
          var pad_opt$6=ign[1];return [0,[9,pad_of_pad_opt(pad_opt$6),fmt]];
         case 8:
          var fmtty=ign[2],pad_opt$7=ign[1];
          return [0,[13,pad_opt$7,fmtty,fmt]];
         case 9:
          var fmtty$0=ign[2],pad_opt$8=ign[1];
          return [0,[14,pad_opt$8,fmtty$0,fmt]];
         case 10:
          var char_set=ign[2],width_opt=ign[1];
          return [0,[20,width_opt,char_set,fmt]];
         default:var counter=ign[1];return [0,[21,counter,fmt]]}}
    function default_float_precision(fconv){return 5 === fconv[2]?12:-6}
    function buffer_create(init_size)
     {return [0,0,caml_create_bytes(init_size)]}
    function buffer_check_size(buf,overhead)
     {var
       len=caml_ml_bytes_length(buf[2]),
       min_len=buf[1] + overhead | 0,
       _tX_=len < min_len?1:0;
      if(_tX_)
       {var
         new_len=max(len * 2 | 0,min_len),
         new_str=caml_create_bytes(new_len);
        blit(buf[2],0,new_str,0,len);
        buf[2] = new_str;
        var _tY_=0}
      else
       var _tY_=_tX_;
      return _tY_}
    function buffer_add_char(buf,c)
     {buffer_check_size(buf,1);
      caml_bytes_set(buf[2],buf[1],c);
      buf[1] = buf[1] + 1 | 0;
      return 0}
    function buffer_add_string(buf,s)
     {var str_len=caml_ml_string_length(s);
      buffer_check_size(buf,str_len);
      blit$0(s,0,buf[2],buf[1],str_len);
      buf[1] = buf[1] + str_len | 0;
      return 0}
    function buffer_contents(buf){return sub_string(buf[2],0,buf[1])}
    function char_of_iconv(iconv)
     {switch(iconv)
       {case 6:
        case 7:return 120;
        case 8:
        case 9:return 88;
        case 10:
        case 11:return 111;
        case 12:
        case 15:return 117;
        case 0:
        case 1:
        case 2:
        case 13:return 100;
        default:return 105}}
    function char_of_fconv(opt,fconv)
     {if(opt)var sth=opt[1],cF=sth;else var cF=70;
      switch(fconv[2])
       {case 0:return 102;
        case 1:return 101;
        case 2:return 69;
        case 3:return 103;
        case 4:return 71;
        case 5:return cF;
        case 6:return 104;
        case 7:return 72;
        default:return 70}}
    function bprint_padty(buf,padty)
     {switch(padty)
       {case 0:return buffer_add_char(buf,45);
        case 1:return 0;
        default:return buffer_add_char(buf,48)}}
    function bprint_ignored_flag(buf,ign_flag)
     {return ign_flag?buffer_add_char(buf,95):ign_flag}
    function bprint_pad_opt(buf,pad_opt)
     {if(pad_opt)
       {var width=pad_opt[1];
        return buffer_add_string(buf,caml_string_of_jsbytes("" + width))}
      return 0}
    function bprint_padding(buf,pad)
     {if(typeof pad === "number")
       return 0;
      else
       {if(0 === pad[0])
         {var n=pad[2],padty=pad[1];
          bprint_padty(buf,padty);
          return buffer_add_string(buf,caml_string_of_jsbytes("" + n))}
        var padty$0=pad[1];
        bprint_padty(buf,padty$0);
        return buffer_add_char(buf,42)}}
    function bprint_precision(buf,prec)
     {if(typeof prec === "number")return prec?buffer_add_string(buf,cst$11):0;
      var n=prec[1];
      buffer_add_char(buf,46);
      return buffer_add_string(buf,caml_string_of_jsbytes("" + n))}
    function bprint_iconv_flag(buf,iconv)
     {switch(iconv)
       {case 1:
        case 4:return buffer_add_char(buf,43);
        case 2:
        case 5:return buffer_add_char(buf,32);
        case 7:
        case 9:
        case 11:
        case 13:
        case 14:
        case 15:return buffer_add_char(buf,35);
        default:return 0}}
    function bprint_altint_fmt(buf,ign_flag,iconv,pad,prec,c)
     {buffer_add_char(buf,37);
      bprint_ignored_flag(buf,ign_flag);
      bprint_iconv_flag(buf,iconv);
      bprint_padding(buf,pad);
      bprint_precision(buf,prec);
      buffer_add_char(buf,c);
      return buffer_add_char(buf,char_of_iconv(iconv))}
    function bprint_fconv_flag(buf,fconv)
     {switch(fconv[1])
       {case 0:break;
        case 1:buffer_add_char(buf,43);break;
        default:buffer_add_char(buf,32)}
      return 8 <= fconv[2]?buffer_add_char(buf,35):0}
    function string_of_formatting_lit(formatting_lit)
     {if(typeof formatting_lit === "number")
       switch(formatting_lit)
        {case 0:return cst$12;
         case 1:return cst$13;
         case 2:return cst$14;
         case 3:return cst$15;
         case 4:return cst$16;
         case 5:return cst$17;
         default:return cst$18}
      else
       switch(formatting_lit[0])
        {case 0:var str=formatting_lit[1];return str;
         case 1:var str$0=formatting_lit[1];return str$0;
         default:var c=formatting_lit[1];return symbol(cst$19,make$1(1,c))}}
    function bprint_char_literal(buf,chr)
     {return 37 === chr?buffer_add_string(buf,cst$20):buffer_add_char(buf,chr)}
    function bprint_string_literal(buf,str)
     {var _tV_=caml_ml_string_length(str) - 1 | 0,_tU_=0;
      if(! (_tV_ < 0))
       {var i=_tU_;
        for(;;)
         {bprint_char_literal(buf,caml_string_get(str,i));
          var _tW_=i + 1 | 0;
          if(_tV_ !== i){var i=_tW_;continue}
          break}}
      return 0}
    function bprint_fmtty(buf,fmtty)
     {var fmtty$0=fmtty;
      for(;;)
       if(typeof fmtty$0 === "number")
        return 0;
       else
        switch(fmtty$0[0])
         {case 0:
           var rest=fmtty$0[1];
           buffer_add_string(buf,cst_c);
           var fmtty$0=rest;
           continue;
          case 1:
           var rest$0=fmtty$0[1];
           buffer_add_string(buf,cst_s);
           var fmtty$0=rest$0;
           continue;
          case 2:
           var rest$1=fmtty$0[1];
           buffer_add_string(buf,cst_i);
           var fmtty$0=rest$1;
           continue;
          case 3:
           var rest$2=fmtty$0[1];
           buffer_add_string(buf,cst_li);
           var fmtty$0=rest$2;
           continue;
          case 4:
           var rest$3=fmtty$0[1];
           buffer_add_string(buf,cst_ni);
           var fmtty$0=rest$3;
           continue;
          case 5:
           var rest$4=fmtty$0[1];
           buffer_add_string(buf,cst_Li);
           var fmtty$0=rest$4;
           continue;
          case 6:
           var rest$5=fmtty$0[1];
           buffer_add_string(buf,cst_f);
           var fmtty$0=rest$5;
           continue;
          case 7:
           var rest$6=fmtty$0[1];
           buffer_add_string(buf,cst_B);
           var fmtty$0=rest$6;
           continue;
          case 8:
           var rest$7=fmtty$0[2],sub_fmtty=fmtty$0[1];
           buffer_add_string(buf,cst$21);
           bprint_fmtty(buf,sub_fmtty);
           buffer_add_string(buf,cst$22);
           var fmtty$0=rest$7;
           continue;
          case 9:
           var rest$8=fmtty$0[3],sub_fmtty$0=fmtty$0[1];
           buffer_add_string(buf,cst$23);
           bprint_fmtty(buf,sub_fmtty$0);
           buffer_add_string(buf,cst$24);
           var fmtty$0=rest$8;
           continue;
          case 10:
           var rest$9=fmtty$0[1];
           buffer_add_string(buf,cst_a);
           var fmtty$0=rest$9;
           continue;
          case 11:
           var rest$10=fmtty$0[1];
           buffer_add_string(buf,cst_t$0);
           var fmtty$0=rest$10;
           continue;
          case 12:
           var rest$11=fmtty$0[1];
           buffer_add_string(buf,cst$25);
           var fmtty$0=rest$11;
           continue;
          case 13:
           var rest$12=fmtty$0[1];
           buffer_add_string(buf,cst_r$0);
           var fmtty$0=rest$12;
           continue;
          default:
           var rest$13=fmtty$0[1];
           buffer_add_string(buf,cst_r$1);
           var fmtty$0=rest$13;
           continue}}
    function int_of_custom_arity(param)
     {if(param){var x=param[1];return 1 + int_of_custom_arity(x) | 0}return 0}
    function string_of_fmt(fmt$1)
     {var buf=buffer_create(16),fmt=fmt$1,ign_flag=0;
      a:
      for(;;)
       if(typeof fmt === "number")
        return buffer_contents(buf);
       else
        switch(fmt[0])
         {case 0:
           var rest=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           buffer_add_char(buf,99);
           var fmt=rest,ign_flag=0;
           continue;
          case 1:
           var rest$0=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           buffer_add_char(buf,67);
           var fmt=rest$0,ign_flag=0;
           continue;
          case 2:
           var rest$1=fmt[2],pad=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_padding(buf,pad);
           buffer_add_char(buf,115);
           var fmt=rest$1,ign_flag=0;
           continue;
          case 3:
           var rest$2=fmt[2],pad$0=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_padding(buf,pad$0);
           buffer_add_char(buf,83);
           var fmt=rest$2,ign_flag=0;
           continue;
          case 4:
           var rest$3=fmt[4],prec=fmt[3],pad$1=fmt[2],iconv=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_iconv_flag(buf,iconv);
           bprint_padding(buf,pad$1);
           bprint_precision(buf,prec);
           buffer_add_char(buf,char_of_iconv(iconv));
           var fmt=rest$3,ign_flag=0;
           continue;
          case 5:
           var rest$4=fmt[4],prec$0=fmt[3],pad$2=fmt[2],iconv$0=fmt[1];
           bprint_altint_fmt(buf,ign_flag,iconv$0,pad$2,prec$0,108);
           var fmt=rest$4,ign_flag=0;
           continue;
          case 6:
           var rest$5=fmt[4],prec$1=fmt[3],pad$3=fmt[2],iconv$1=fmt[1];
           bprint_altint_fmt(buf,ign_flag,iconv$1,pad$3,prec$1,110);
           var fmt=rest$5,ign_flag=0;
           continue;
          case 7:
           var rest$6=fmt[4],prec$2=fmt[3],pad$4=fmt[2],iconv$2=fmt[1];
           bprint_altint_fmt(buf,ign_flag,iconv$2,pad$4,prec$2,76);
           var fmt=rest$6,ign_flag=0;
           continue;
          case 8:
           var rest$7=fmt[4],prec$3=fmt[3],pad$5=fmt[2],fconv=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_fconv_flag(buf,fconv);
           bprint_padding(buf,pad$5);
           bprint_precision(buf,prec$3);
           buffer_add_char(buf,char_of_fconv(0,fconv));
           var fmt=rest$7,ign_flag=0;
           continue;
          case 9:
           var rest$8=fmt[2],pad$6=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_padding(buf,pad$6);
           buffer_add_char(buf,66);
           var fmt=rest$8,ign_flag=0;
           continue;
          case 10:
           var rest$9=fmt[1];
           buffer_add_string(buf,cst$26);
           var fmt=rest$9;
           continue;
          case 11:
           var rest$10=fmt[2],str=fmt[1];
           bprint_string_literal(buf,str);
           var fmt=rest$10;
           continue;
          case 12:
           var rest$11=fmt[2],chr$0=fmt[1];
           bprint_char_literal(buf,chr$0);
           var fmt=rest$11;
           continue;
          case 13:
           var rest$12=fmt[3],fmtty=fmt[2],pad_opt=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_pad_opt(buf,pad_opt);
           buffer_add_char(buf,123);
           bprint_fmtty(buf,fmtty);
           buffer_add_char(buf,37);
           buffer_add_char(buf,125);
           var fmt=rest$12,ign_flag=0;
           continue;
          case 14:
           var rest$13=fmt[3],fmtty$0=fmt[2],pad_opt$0=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_pad_opt(buf,pad_opt$0);
           buffer_add_char(buf,40);
           bprint_fmtty(buf,fmtty$0);
           buffer_add_char(buf,37);
           buffer_add_char(buf,41);
           var fmt=rest$13,ign_flag=0;
           continue;
          case 15:
           var rest$14=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           buffer_add_char(buf,97);
           var fmt=rest$14,ign_flag=0;
           continue;
          case 16:
           var rest$15=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           buffer_add_char(buf,116);
           var fmt=rest$15,ign_flag=0;
           continue;
          case 17:
           var rest$16=fmt[2],fmting_lit=fmt[1];
           bprint_string_literal(buf,string_of_formatting_lit(fmting_lit));
           var fmt=rest$16;
           continue;
          case 18:
           var rest$17=fmt[2],fmting_gen=fmt[1];
           if(0 === fmting_gen[0])
            {var match$1=fmting_gen[1],str$0=match$1[2];
             buffer_add_string(buf,cst$27);
             buffer_add_string(buf,str$0)}
           else
            {var match$2=fmting_gen[1],str$1=match$2[2];
             buffer_add_string(buf,cst$28);
             buffer_add_string(buf,str$1)}
           var fmt=rest$17;
           continue;
          case 19:
           var rest$18=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           buffer_add_char(buf,114);
           var fmt=rest$18,ign_flag=0;
           continue;
          case 20:
           var rest$19=fmt[3],char_set=fmt[2],width_opt=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_pad_opt(buf,width_opt);
           var
            print_char=
             function(buf,i)
              {var c=char_of_int(i);
               return 37 === c
                       ?(buffer_add_char(buf,37),buffer_add_char(buf,37))
                       :64 === c
                         ?(buffer_add_char(buf,37),buffer_add_char(buf,64))
                         :buffer_add_char(buf,c)};
           buffer_add_char(buf,91);
           var
            _tK_=
             is_in_char_set(char_set,0)
              ?(buffer_add_char(buf,94),rev_char_set(char_set))
              :char_set,
            is_alone$0=
             function(_tP_)
              {function is_alone(c)
                {var
                  after=chr(c + 1 | 0),
                  before=chr(c - 1 | 0),
                  _tQ_=is_in_char_set(_tP_,c);
                 if(_tQ_)
                  var
                   _tR_=is_in_char_set(_tP_,before),
                   _tS_=_tR_?is_in_char_set(_tP_,after):_tR_,
                   _tT_=1 - _tS_;
                 else
                  var _tT_=_tQ_;
                 return _tT_}
               return is_alone},
            is_alone=is_alone$0(_tK_);
           if(is_alone(93))buffer_add_char(buf,93);
           var i=1;
           b:
           for(;;)
            {if(i < 256)
              {if(! is_in_char_set(_tK_,char_of_int(i)))
                {var i$0=i + 1 | 0,i=i$0;continue}
               var match=char_of_int(i),switcher=match - 45 | 0,switch$0=0;
               if(48 < switcher >>> 0)
                if(210 <= switcher)print_char(buf,255);else switch$0 = 1;
               else
                {var switcher$0=switcher - 1 | 0;
                 if(46 < switcher$0 >>> 0){var i$2=i + 1 | 0,i=i$2;continue}
                 switch$0 = 1}
               if(switch$0)
                {var i$1=i + 1 | 0;
                 if(! is_in_char_set(_tK_,char_of_int(i$1)))
                  {print_char(buf,i$1 - 1 | 0);
                   var i$6=i$1 + 1 | 0,i=i$6;
                   continue}
                 var
                  match$0=char_of_int(i$1),
                  switcher$1=match$0 - 45 | 0,
                  switch$1=0;
                 if(48 < switcher$1 >>> 0)
                  if(210 <= switcher$1)
                   {print_char(buf,254);print_char(buf,255)}
                  else
                   switch$1 = 1;
                 else
                  {var switcher$2=switcher$1 - 1 | 0;
                   if(46 < switcher$2 >>> 0)
                    {if(! is_in_char_set(_tK_,char_of_int(i$1 + 1 | 0)))
                      {print_char(buf,i$1 - 1 | 0);
                       var i$5=i$1 + 1 | 0,i=i$5;
                       continue}
                     switch$1 = 1}
                   else
                    switch$1 = 1}
                 if(switch$1)
                  {if(! is_in_char_set(_tK_,char_of_int(i$1 + 1 | 0)))
                    {print_char(buf,i$1 - 1 | 0);
                     print_char(buf,i$1);
                     var i$4=i$1 + 2 | 0,i=i$4;
                     continue}
                   var j=i$1 + 2 | 0,i$3=i$1 - 1 | 0,j$0=j;
                   for(;;)
                    {if(256 !== j$0 && is_in_char_set(_tK_,char_of_int(j$0)))
                      {var j$1=j$0 + 1 | 0,j$0=j$1;continue}
                     print_char(buf,i$3);
                     print_char(buf,45);
                     print_char(buf,j$0 - 1 | 0);
                     if(j$0 < 256){var i$7=j$0 + 1 | 0,i=i$7;continue b}
                     break}}}}
             if(is_alone(45))buffer_add_char(buf,45);
             buffer_add_char(buf,93);
             var fmt=rest$19,ign_flag=0;
             continue a}
          case 21:
           var rest$20=fmt[2],counter=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           switch(counter)
            {case 0:var _tL_=108;break;
             case 1:var _tL_=110;break;
             default:var _tL_=78}
           buffer_add_char(buf,_tL_);
           var fmt=rest$20,ign_flag=0;
           continue;
          case 22:
           var rest$21=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_string_literal(buf,cst_0c);
           var fmt=rest$21,ign_flag=0;
           continue;
          case 23:
           var
            rest$22=fmt[2],
            ign=fmt[1],
            match$3=param_format_of_ignored_format(ign,rest$22),
            fmt$0=match$3[1],
            fmt=fmt$0,
            ign_flag=1;
           continue;
          default:
           var
            rest$23=fmt[3],
            arity=fmt[1],
            _tN_=int_of_custom_arity(arity),
            _tM_=1;
           if(! (_tN_ < 1))
            {var i$8=_tM_;
             for(;;)
              {buffer_add_char(buf,37);
               bprint_ignored_flag(buf,ign_flag);
               buffer_add_char(buf,63);
               var _tO_=i$8 + 1 | 0;
               if(_tN_ !== i$8){var i$8=_tO_;continue}
               break}}
           var fmt=rest$23,ign_flag=0;
           continue}}
    function symm(param)
     {if(typeof param === "number")
       return 0;
      else
       switch(param[0])
        {case 0:var rest=param[1];return [0,symm(rest)];
         case 1:var rest$0=param[1];return [1,symm(rest$0)];
         case 2:var rest$1=param[1];return [2,symm(rest$1)];
         case 3:var rest$2=param[1];return [3,symm(rest$2)];
         case 4:var rest$3=param[1];return [4,symm(rest$3)];
         case 5:var rest$4=param[1];return [5,symm(rest$4)];
         case 6:var rest$5=param[1];return [6,symm(rest$5)];
         case 7:var rest$6=param[1];return [7,symm(rest$6)];
         case 8:var rest$7=param[2],ty=param[1];return [8,ty,symm(rest$7)];
         case 9:
          var rest$8=param[3],ty2=param[2],ty1=param[1];
          return [9,ty2,ty1,symm(rest$8)];
         case 10:var rest$9=param[1];return [10,symm(rest$9)];
         case 11:var rest$10=param[1];return [11,symm(rest$10)];
         case 12:var rest$11=param[1];return [12,symm(rest$11)];
         case 13:var rest$12=param[1];return [13,symm(rest$12)];
         default:var rest$13=param[1];return [14,symm(rest$13)]}}
    function trans(ty1,match)
     {var switch$0=0;
      if(typeof ty1 === "number")
       if(typeof match === "number")
        return 0;
       else
        switch(match[0])
         {case 10:break;
          case 11:switch$0 = 1;break;
          case 12:switch$0 = 2;break;
          case 13:switch$0 = 3;break;
          case 14:switch$0 = 4;break;
          case 8:switch$0 = 5;break;
          case 9:switch$0 = 6;break;
          default:throw [0,Assert_failure,_aa_]}
      else
       switch(ty1[0])
        {case 0:
          var switch$1=0,_tr_=ty1[1];
          if(typeof match !== "number")
           switch(match[0])
            {case 0:var rest2=match[1];return [0,trans(_tr_,rest2)];
             case 8:switch$0 = 5;switch$1 = 1;break;
             case 9:switch$0 = 6;switch$1 = 1;break;
             case 10:switch$1 = 1;break;
             case 11:switch$0 = 1;switch$1 = 1;break;
             case 12:switch$0 = 2;switch$1 = 1;break;
             case 13:switch$0 = 3;switch$1 = 1;break;
             case 14:switch$0 = 4;switch$1 = 1;break
             }
          if(! switch$1)switch$0 = 7;
          break;
         case 1:
          var switch$2=0,_ts_=ty1[1];
          if(typeof match !== "number")
           switch(match[0])
            {case 1:var rest2$0=match[1];return [1,trans(_ts_,rest2$0)];
             case 8:switch$0 = 5;switch$2 = 1;break;
             case 9:switch$0 = 6;switch$2 = 1;break;
             case 10:switch$2 = 1;break;
             case 11:switch$0 = 1;switch$2 = 1;break;
             case 12:switch$0 = 2;switch$2 = 1;break;
             case 13:switch$0 = 3;switch$2 = 1;break;
             case 14:switch$0 = 4;switch$2 = 1;break
             }
          if(! switch$2)switch$0 = 7;
          break;
         case 2:
          var switch$3=0,_tt_=ty1[1];
          if(typeof match === "number")
           switch$3 = 1;
          else
           switch(match[0])
            {case 2:var rest2$1=match[1];return [2,trans(_tt_,rest2$1)];
             case 8:switch$0 = 5;break;
             case 9:switch$0 = 6;break;
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$3 = 1}
          if(switch$3)switch$0 = 7;
          break;
         case 3:
          var switch$4=0,_tu_=ty1[1];
          if(typeof match === "number")
           switch$4 = 1;
          else
           switch(match[0])
            {case 3:var rest2$2=match[1];return [3,trans(_tu_,rest2$2)];
             case 8:switch$0 = 5;break;
             case 9:switch$0 = 6;break;
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$4 = 1}
          if(switch$4)switch$0 = 7;
          break;
         case 4:
          var switch$5=0,_tv_=ty1[1];
          if(typeof match === "number")
           switch$5 = 1;
          else
           switch(match[0])
            {case 4:var rest2$3=match[1];return [4,trans(_tv_,rest2$3)];
             case 8:switch$0 = 5;break;
             case 9:switch$0 = 6;break;
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$5 = 1}
          if(switch$5)switch$0 = 7;
          break;
         case 5:
          var switch$6=0,_tw_=ty1[1];
          if(typeof match === "number")
           switch$6 = 1;
          else
           switch(match[0])
            {case 5:var rest2$4=match[1];return [5,trans(_tw_,rest2$4)];
             case 8:switch$0 = 5;break;
             case 9:switch$0 = 6;break;
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$6 = 1}
          if(switch$6)switch$0 = 7;
          break;
         case 6:
          var switch$7=0,_tx_=ty1[1];
          if(typeof match === "number")
           switch$7 = 1;
          else
           switch(match[0])
            {case 6:var rest2$5=match[1];return [6,trans(_tx_,rest2$5)];
             case 8:switch$0 = 5;break;
             case 9:switch$0 = 6;break;
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$7 = 1}
          if(switch$7)switch$0 = 7;
          break;
         case 7:
          var switch$8=0,_ty_=ty1[1];
          if(typeof match === "number")
           switch$8 = 1;
          else
           switch(match[0])
            {case 7:var rest2$6=match[1];return [7,trans(_ty_,rest2$6)];
             case 8:switch$0 = 5;break;
             case 9:switch$0 = 6;break;
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$8 = 1}
          if(switch$8)switch$0 = 7;
          break;
         case 8:
          var switch$9=0,_tz_=ty1[2],_tA_=ty1[1];
          if(typeof match === "number")
           switch$9 = 1;
          else
           switch(match[0])
            {case 8:
              var rest2$7=match[2],ty2=match[1],_tB_=trans(_tz_,rest2$7);
              return [8,trans(_tA_,ty2),_tB_];
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$9 = 1}
          if(switch$9)throw [0,Assert_failure,_aj_];
          break;
         case 9:
          var switch$10=0,_tC_=ty1[3],_tD_=ty1[2],_tE_=ty1[1];
          if(typeof match === "number")
           switch$10 = 1;
          else
           switch(match[0])
            {case 8:switch$0 = 5;break;
             case 9:
              var
               rest2$8=match[3],
               ty22=match[2],
               ty21=match[1],
               ty=trans(symm(_tD_),ty21),
               match$0=fmtty_rel_det(ty),
               f4=match$0[4],
               f2=match$0[2];
              caml_call1(f2,0);
              caml_call1(f4,0);
              return [9,_tE_,ty22,trans(_tC_,rest2$8)];
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$10 = 1}
          if(switch$10)throw [0,Assert_failure,_ak_];
          break;
         case 10:
          var _tF_=ty1[1];
          if(typeof match !== "number" && 10 === match[0])
           {var rest2$9=match[1];return [10,trans(_tF_,rest2$9)]}
          throw [0,Assert_failure,_al_];
         case 11:
          var switch$11=0,_tG_=ty1[1];
          if(typeof match === "number")
           switch$11 = 1;
          else
           switch(match[0])
            {case 10:break;
             case 11:var rest2$10=match[1];return [11,trans(_tG_,rest2$10)];
             default:switch$11 = 1}
          if(switch$11)throw [0,Assert_failure,_am_];
          break;
         case 12:
          var switch$12=0,_tH_=ty1[1];
          if(typeof match === "number")
           switch$12 = 1;
          else
           switch(match[0])
            {case 10:break;
             case 11:switch$0 = 1;break;
             case 12:var rest2$11=match[1];return [12,trans(_tH_,rest2$11)];
             default:switch$12 = 1}
          if(switch$12)throw [0,Assert_failure,_an_];
          break;
         case 13:
          var switch$13=0,_tI_=ty1[1];
          if(typeof match === "number")
           switch$13 = 1;
          else
           switch(match[0])
            {case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:var rest2$12=match[1];return [13,trans(_tI_,rest2$12)];
             default:switch$13 = 1}
          if(switch$13)throw [0,Assert_failure,_ao_];
          break;
         default:
          var switch$14=0,_tJ_=ty1[1];
          if(typeof match === "number")
           switch$14 = 1;
          else
           switch(match[0])
            {case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:var rest2$13=match[1];return [14,trans(_tJ_,rest2$13)];
             default:switch$14 = 1}
          if(switch$14)throw [0,Assert_failure,_ap_]}
      switch(switch$0)
       {case 0:throw [0,Assert_failure,_ad_];
        case 1:throw [0,Assert_failure,_ae_];
        case 2:throw [0,Assert_failure,_af_];
        case 3:throw [0,Assert_failure,_ag_];
        case 4:throw [0,Assert_failure,_ah_];
        case 5:throw [0,Assert_failure,_ab_];
        case 6:throw [0,Assert_failure,_ac_];
        default:throw [0,Assert_failure,_ai_]}}
    function fmtty_rel_det(param)
     {if(typeof param === "number")
       {var
         _s5_=function(param){return 0},
         _s6_=function(param){return 0},
         _s7_=function(param){return 0};
        return [0,function(param){return 0},_s7_,_s6_,_s5_]}
      else
       switch(param[0])
        {case 0:
          var
           rest=param[1],
           match=fmtty_rel_det(rest),
           de=match[4],
           ed=match[3],
           af=match[2],
           fa=match[1],
           _s8_=function(param){caml_call1(af,0);return 0};
          return [0,function(param){caml_call1(fa,0);return 0},_s8_,ed,de];
         case 1:
          var
           rest$0=param[1],
           match$0=fmtty_rel_det(rest$0),
           de$0=match$0[4],
           ed$0=match$0[3],
           af$0=match$0[2],
           fa$0=match$0[1],
           _s9_=function(param){caml_call1(af$0,0);return 0};
          return [0,
                  function(param){caml_call1(fa$0,0);return 0},
                  _s9_,
                  ed$0,
                  de$0];
         case 2:
          var
           rest$1=param[1],
           match$1=fmtty_rel_det(rest$1),
           de$1=match$1[4],
           ed$1=match$1[3],
           af$1=match$1[2],
           fa$1=match$1[1],
           _s__=function(param){caml_call1(af$1,0);return 0};
          return [0,
                  function(param){caml_call1(fa$1,0);return 0},
                  _s__,
                  ed$1,
                  de$1];
         case 3:
          var
           rest$2=param[1],
           match$2=fmtty_rel_det(rest$2),
           de$2=match$2[4],
           ed$2=match$2[3],
           af$2=match$2[2],
           fa$2=match$2[1],
           _s$_=function(param){caml_call1(af$2,0);return 0};
          return [0,
                  function(param){caml_call1(fa$2,0);return 0},
                  _s$_,
                  ed$2,
                  de$2];
         case 4:
          var
           rest$3=param[1],
           match$3=fmtty_rel_det(rest$3),
           de$3=match$3[4],
           ed$3=match$3[3],
           af$3=match$3[2],
           fa$3=match$3[1],
           _ta_=function(param){caml_call1(af$3,0);return 0};
          return [0,
                  function(param){caml_call1(fa$3,0);return 0},
                  _ta_,
                  ed$3,
                  de$3];
         case 5:
          var
           rest$4=param[1],
           match$4=fmtty_rel_det(rest$4),
           de$4=match$4[4],
           ed$4=match$4[3],
           af$4=match$4[2],
           fa$4=match$4[1],
           _tb_=function(param){caml_call1(af$4,0);return 0};
          return [0,
                  function(param){caml_call1(fa$4,0);return 0},
                  _tb_,
                  ed$4,
                  de$4];
         case 6:
          var
           rest$5=param[1],
           match$5=fmtty_rel_det(rest$5),
           de$5=match$5[4],
           ed$5=match$5[3],
           af$5=match$5[2],
           fa$5=match$5[1],
           _tc_=function(param){caml_call1(af$5,0);return 0};
          return [0,
                  function(param){caml_call1(fa$5,0);return 0},
                  _tc_,
                  ed$5,
                  de$5];
         case 7:
          var
           rest$6=param[1],
           match$6=fmtty_rel_det(rest$6),
           de$6=match$6[4],
           ed$6=match$6[3],
           af$6=match$6[2],
           fa$6=match$6[1],
           _td_=function(param){caml_call1(af$6,0);return 0};
          return [0,
                  function(param){caml_call1(fa$6,0);return 0},
                  _td_,
                  ed$6,
                  de$6];
         case 8:
          var
           rest$7=param[2],
           match$7=fmtty_rel_det(rest$7),
           de$7=match$7[4],
           ed$7=match$7[3],
           af$7=match$7[2],
           fa$7=match$7[1],
           _te_=function(param){caml_call1(af$7,0);return 0};
          return [0,
                  function(param){caml_call1(fa$7,0);return 0},
                  _te_,
                  ed$7,
                  de$7];
         case 9:
          var
           rest$8=param[3],
           ty2=param[2],
           ty1=param[1],
           match$8=fmtty_rel_det(rest$8),
           de$8=match$8[4],
           ed$8=match$8[3],
           af$8=match$8[2],
           fa$8=match$8[1],
           ty=trans(symm(ty1),ty2),
           match$9=fmtty_rel_det(ty),
           jd=match$9[4],
           dj=match$9[3],
           ga=match$9[2],
           ag=match$9[1],
           _tf_=function(param){caml_call1(jd,0);caml_call1(de$8,0);return 0},
           _tg_=function(param){caml_call1(ed$8,0);caml_call1(dj,0);return 0},
           _th_=function(param){caml_call1(ga,0);caml_call1(af$8,0);return 0};
          return [0,
                  function(param)
                   {caml_call1(fa$8,0);caml_call1(ag,0);return 0},
                  _th_,
                  _tg_,
                  _tf_];
         case 10:
          var
           rest$9=param[1],
           match$10=fmtty_rel_det(rest$9),
           de$9=match$10[4],
           ed$9=match$10[3],
           af$9=match$10[2],
           fa$9=match$10[1],
           _ti_=function(param){caml_call1(af$9,0);return 0};
          return [0,
                  function(param){caml_call1(fa$9,0);return 0},
                  _ti_,
                  ed$9,
                  de$9];
         case 11:
          var
           rest$10=param[1],
           match$11=fmtty_rel_det(rest$10),
           de$10=match$11[4],
           ed$10=match$11[3],
           af$10=match$11[2],
           fa$10=match$11[1],
           _tj_=function(param){caml_call1(af$10,0);return 0};
          return [0,
                  function(param){caml_call1(fa$10,0);return 0},
                  _tj_,
                  ed$10,
                  de$10];
         case 12:
          var
           rest$11=param[1],
           match$12=fmtty_rel_det(rest$11),
           de$11=match$12[4],
           ed$11=match$12[3],
           af$11=match$12[2],
           fa$11=match$12[1],
           _tk_=function(param){caml_call1(af$11,0);return 0};
          return [0,
                  function(param){caml_call1(fa$11,0);return 0},
                  _tk_,
                  ed$11,
                  de$11];
         case 13:
          var
           rest$12=param[1],
           match$13=fmtty_rel_det(rest$12),
           de$12=match$13[4],
           ed$12=match$13[3],
           af$12=match$13[2],
           fa$12=match$13[1],
           _tl_=function(param){caml_call1(de$12,0);return 0},
           _tm_=function(param){caml_call1(ed$12,0);return 0},
           _tn_=function(param){caml_call1(af$12,0);return 0};
          return [0,
                  function(param){caml_call1(fa$12,0);return 0},
                  _tn_,
                  _tm_,
                  _tl_];
         default:
          var
           rest$13=param[1],
           match$14=fmtty_rel_det(rest$13),
           de$13=match$14[4],
           ed$13=match$14[3],
           af$13=match$14[2],
           fa$13=match$14[1],
           _to_=function(param){caml_call1(de$13,0);return 0},
           _tp_=function(param){caml_call1(ed$13,0);return 0},
           _tq_=function(param){caml_call1(af$13,0);return 0};
          return [0,
                  function(param){caml_call1(fa$13,0);return 0},
                  _tq_,
                  _tp_,
                  _to_]}}
    function fmtty_of_precision_fmtty(prec,fmtty)
     {return typeof prec === "number"?prec?[2,fmtty]:fmtty:fmtty}
    function fmtty_of_padding_fmtty(pad,fmtty)
     {return typeof pad === "number"?fmtty:0 === pad[0]?fmtty:[2,fmtty]}
    function fmtty_of_custom(arity,fmtty)
     {if(arity)
       {var arity$0=arity[1];return [12,fmtty_of_custom(arity$0,fmtty)]}
      return fmtty}
    function fmtty_of_fmt(fmtty)
     {var fmtty$0=fmtty;
      for(;;)
       if(typeof fmtty$0 === "number")
        return 0;
       else
        switch(fmtty$0[0])
         {case 0:var rest=fmtty$0[1];return [0,fmtty_of_fmt(rest)];
          case 1:var rest$0=fmtty$0[1];return [0,fmtty_of_fmt(rest$0)];
          case 2:
           var rest$1=fmtty$0[2],pad=fmtty$0[1];
           return fmtty_of_padding_fmtty(pad,[1,fmtty_of_fmt(rest$1)]);
          case 3:
           var rest$2=fmtty$0[2],pad$0=fmtty$0[1];
           return fmtty_of_padding_fmtty(pad$0,[1,fmtty_of_fmt(rest$2)]);
          case 4:
           var
            rest$3=fmtty$0[4],
            prec=fmtty$0[3],
            pad$1=fmtty$0[2],
            ty_rest=fmtty_of_fmt(rest$3),
            prec_ty=fmtty_of_precision_fmtty(prec,[2,ty_rest]);
           return fmtty_of_padding_fmtty(pad$1,prec_ty);
          case 5:
           var
            rest$4=fmtty$0[4],
            prec$0=fmtty$0[3],
            pad$2=fmtty$0[2],
            ty_rest$0=fmtty_of_fmt(rest$4),
            prec_ty$0=fmtty_of_precision_fmtty(prec$0,[3,ty_rest$0]);
           return fmtty_of_padding_fmtty(pad$2,prec_ty$0);
          case 6:
           var
            rest$5=fmtty$0[4],
            prec$1=fmtty$0[3],
            pad$3=fmtty$0[2],
            ty_rest$1=fmtty_of_fmt(rest$5),
            prec_ty$1=fmtty_of_precision_fmtty(prec$1,[4,ty_rest$1]);
           return fmtty_of_padding_fmtty(pad$3,prec_ty$1);
          case 7:
           var
            rest$6=fmtty$0[4],
            prec$2=fmtty$0[3],
            pad$4=fmtty$0[2],
            ty_rest$2=fmtty_of_fmt(rest$6),
            prec_ty$2=fmtty_of_precision_fmtty(prec$2,[5,ty_rest$2]);
           return fmtty_of_padding_fmtty(pad$4,prec_ty$2);
          case 8:
           var
            rest$7=fmtty$0[4],
            prec$3=fmtty$0[3],
            pad$5=fmtty$0[2],
            ty_rest$3=fmtty_of_fmt(rest$7),
            prec_ty$3=fmtty_of_precision_fmtty(prec$3,[6,ty_rest$3]);
           return fmtty_of_padding_fmtty(pad$5,prec_ty$3);
          case 9:
           var rest$8=fmtty$0[2],pad$6=fmtty$0[1];
           return fmtty_of_padding_fmtty(pad$6,[7,fmtty_of_fmt(rest$8)]);
          case 10:var fmtty$1=fmtty$0[1],fmtty$0=fmtty$1;continue;
          case 11:var fmtty$2=fmtty$0[2],fmtty$0=fmtty$2;continue;
          case 12:var fmtty$3=fmtty$0[2],fmtty$0=fmtty$3;continue;
          case 13:
           var rest$9=fmtty$0[3],ty=fmtty$0[2];
           return [8,ty,fmtty_of_fmt(rest$9)];
          case 14:
           var rest$10=fmtty$0[3],ty$0=fmtty$0[2];
           return [9,ty$0,ty$0,fmtty_of_fmt(rest$10)];
          case 15:var rest$11=fmtty$0[1];return [10,fmtty_of_fmt(rest$11)];
          case 16:var rest$12=fmtty$0[1];return [11,fmtty_of_fmt(rest$12)];
          case 17:var fmtty$4=fmtty$0[2],fmtty$0=fmtty$4;continue;
          case 18:
           var
            rest$13=fmtty$0[2],
            fmting_gen=fmtty$0[1],
            _s3_=fmtty_of_fmt(rest$13);
           if(0 === fmting_gen[0])
            var match=fmting_gen[1],fmt=match[1],_s4_=fmtty_of_fmt(fmt);
           else
            var
             match$0=fmting_gen[1],
             fmt$0=match$0[1],
             _s4_=fmtty_of_fmt(fmt$0);
           return concat_fmtty(_s4_,_s3_);
          case 19:var rest$14=fmtty$0[1];return [13,fmtty_of_fmt(rest$14)];
          case 20:var rest$15=fmtty$0[3];return [1,fmtty_of_fmt(rest$15)];
          case 21:var rest$16=fmtty$0[2];return [2,fmtty_of_fmt(rest$16)];
          case 22:var rest$17=fmtty$0[1];return [0,fmtty_of_fmt(rest$17)];
          case 23:
           var rest$18=fmtty$0[2],ign=fmtty$0[1];
           if(typeof ign === "number")
            switch(ign)
             {case 0:var fmtty$0=rest$18;continue;
              case 1:var fmtty$0=rest$18;continue;
              case 2:return [14,fmtty_of_fmt(rest$18)];
              default:var fmtty$0=rest$18;continue}
           else
            switch(ign[0])
             {case 0:var fmtty$0=rest$18;continue;
              case 1:var fmtty$0=rest$18;continue;
              case 2:var fmtty$0=rest$18;continue;
              case 3:var fmtty$0=rest$18;continue;
              case 4:var fmtty$0=rest$18;continue;
              case 5:var fmtty$0=rest$18;continue;
              case 6:var fmtty$0=rest$18;continue;
              case 7:var fmtty$0=rest$18;continue;
              case 8:var fmtty$0=rest$18;continue;
              case 9:
               var fmtty$5=ign[2];
               return concat_fmtty(fmtty$5,fmtty_of_fmt(rest$18));
              case 10:var fmtty$0=rest$18;continue;
              default:var fmtty$0=rest$18;continue}
          default:
           var rest$19=fmtty$0[3],arity=fmtty$0[1];
           return fmtty_of_custom(arity,fmtty_of_fmt(rest$19))}}
    var
     Type_mismatch=
      [248,cst_CamlinternalFormat_Type_mi,caml_fresh_oo_id(0)];
    function type_padding(pad,match)
     {if(typeof pad === "number")
       return [0,0,match];
      else
       {if(0 === pad[0])
         {var w=pad[2],padty=pad[1];return [0,[0,padty,w],match]}
        if(typeof match !== "number" && 2 === match[0])
         {var rest=match[1],padty$0=pad[1];return [0,[1,padty$0],rest]}
        throw Type_mismatch}}
    function type_padprec(pad,prec,fmtty)
     {var match=type_padding(pad,fmtty);
      if(typeof prec === "number")
       {if(prec)
         {var _s2_=match[2];
          if(typeof _s2_ !== "number" && 2 === _s2_[0])
           {var rest=_s2_[1],pad$0=match[1];return [0,pad$0,1,rest]}
          throw Type_mismatch}
        var rest$0=match[2],pad$1=match[1];
        return [0,pad$1,0,rest$0]}
      var rest$1=match[2],pad$2=match[1],p=prec[1];
      return [0,pad$2,[0,p],rest$1]}
    function type_ignored_format_substituti(sub_fmtty,fmt,match)
     {if(typeof sub_fmtty === "number")
       return [0,0,type_format_gen(fmt,match)];
      else
       switch(sub_fmtty[0])
        {case 0:
          if(typeof match !== "number" && 0 === match[0])
           {var
             fmtty_rest=match[1],
             sub_fmtty_rest=sub_fmtty[1],
             match$0=
              type_ignored_format_substituti(sub_fmtty_rest,fmt,fmtty_rest),
             fmt$0=match$0[2],
             sub_fmtty_rest$0=match$0[1];
            return [0,[0,sub_fmtty_rest$0],fmt$0]}
          break;
         case 1:
          if(typeof match !== "number" && 1 === match[0])
           {var
             fmtty_rest$0=match[1],
             sub_fmtty_rest$1=sub_fmtty[1],
             match$1=
              type_ignored_format_substituti
               (sub_fmtty_rest$1,fmt,fmtty_rest$0),
             fmt$1=match$1[2],
             sub_fmtty_rest$2=match$1[1];
            return [0,[1,sub_fmtty_rest$2],fmt$1]}
          break;
         case 2:
          if(typeof match !== "number" && 2 === match[0])
           {var
             fmtty_rest$1=match[1],
             sub_fmtty_rest$3=sub_fmtty[1],
             match$2=
              type_ignored_format_substituti
               (sub_fmtty_rest$3,fmt,fmtty_rest$1),
             fmt$2=match$2[2],
             sub_fmtty_rest$4=match$2[1];
            return [0,[2,sub_fmtty_rest$4],fmt$2]}
          break;
         case 3:
          if(typeof match !== "number" && 3 === match[0])
           {var
             fmtty_rest$2=match[1],
             sub_fmtty_rest$5=sub_fmtty[1],
             match$3=
              type_ignored_format_substituti
               (sub_fmtty_rest$5,fmt,fmtty_rest$2),
             fmt$3=match$3[2],
             sub_fmtty_rest$6=match$3[1];
            return [0,[3,sub_fmtty_rest$6],fmt$3]}
          break;
         case 4:
          if(typeof match !== "number" && 4 === match[0])
           {var
             fmtty_rest$3=match[1],
             sub_fmtty_rest$7=sub_fmtty[1],
             match$4=
              type_ignored_format_substituti
               (sub_fmtty_rest$7,fmt,fmtty_rest$3),
             fmt$4=match$4[2],
             sub_fmtty_rest$8=match$4[1];
            return [0,[4,sub_fmtty_rest$8],fmt$4]}
          break;
         case 5:
          if(typeof match !== "number" && 5 === match[0])
           {var
             fmtty_rest$4=match[1],
             sub_fmtty_rest$9=sub_fmtty[1],
             match$5=
              type_ignored_format_substituti
               (sub_fmtty_rest$9,fmt,fmtty_rest$4),
             fmt$5=match$5[2],
             sub_fmtty_rest$10=match$5[1];
            return [0,[5,sub_fmtty_rest$10],fmt$5]}
          break;
         case 6:
          if(typeof match !== "number" && 6 === match[0])
           {var
             fmtty_rest$5=match[1],
             sub_fmtty_rest$11=sub_fmtty[1],
             match$6=
              type_ignored_format_substituti
               (sub_fmtty_rest$11,fmt,fmtty_rest$5),
             fmt$6=match$6[2],
             sub_fmtty_rest$12=match$6[1];
            return [0,[6,sub_fmtty_rest$12],fmt$6]}
          break;
         case 7:
          if(typeof match !== "number" && 7 === match[0])
           {var
             fmtty_rest$6=match[1],
             sub_fmtty_rest$13=sub_fmtty[1],
             match$7=
              type_ignored_format_substituti
               (sub_fmtty_rest$13,fmt,fmtty_rest$6),
             fmt$7=match$7[2],
             sub_fmtty_rest$14=match$7[1];
            return [0,[7,sub_fmtty_rest$14],fmt$7]}
          break;
         case 8:
          if(typeof match !== "number" && 8 === match[0])
           {var
             fmtty_rest$7=match[2],
             sub2_fmtty=match[1],
             sub_fmtty_rest$15=sub_fmtty[2],
             sub2_fmtty$0=sub_fmtty[1];
            if(caml_notequal([0,sub2_fmtty$0],[0,sub2_fmtty]))
             throw Type_mismatch;
            var
             match$8=
              type_ignored_format_substituti
               (sub_fmtty_rest$15,fmt,fmtty_rest$7),
             fmt$8=match$8[2],
             sub_fmtty_rest$16=match$8[1];
            return [0,[8,sub2_fmtty,sub_fmtty_rest$16],fmt$8]}
          break;
         case 9:
          if(typeof match !== "number" && 9 === match[0])
           {var
             fmtty_rest$8=match[3],
             sub2_fmtty$1=match[2],
             sub1_fmtty=match[1],
             sub_fmtty_rest$17=sub_fmtty[3],
             sub2_fmtty$2=sub_fmtty[2],
             sub1_fmtty$0=sub_fmtty[1],
             _s0_=[0,erase_rel(sub1_fmtty)];
            if(caml_notequal([0,erase_rel(sub1_fmtty$0)],_s0_))
             throw Type_mismatch;
            var _s1_=[0,erase_rel(sub2_fmtty$1)];
            if(caml_notequal([0,erase_rel(sub2_fmtty$2)],_s1_))
             throw Type_mismatch;
            var
             sub_fmtty$0=trans(symm(sub1_fmtty),sub2_fmtty$1),
             match$9=fmtty_rel_det(sub_fmtty$0),
             f4=match$9[4],
             f2=match$9[2];
            caml_call1(f2,0);
            caml_call1(f4,0);
            var
             match$10=
              type_ignored_format_substituti
               (erase_rel(sub_fmtty_rest$17),fmt,fmtty_rest$8),
             fmt$9=match$10[2],
             sub_fmtty_rest$18=match$10[1];
            return [0,
                    [9,sub1_fmtty,sub2_fmtty$1,symm(sub_fmtty_rest$18)],
                    fmt$9]}
          break;
         case 10:
          if(typeof match !== "number" && 10 === match[0])
           {var
             fmtty_rest$9=match[1],
             sub_fmtty_rest$19=sub_fmtty[1],
             match$11=
              type_ignored_format_substituti
               (sub_fmtty_rest$19,fmt,fmtty_rest$9),
             fmt$10=match$11[2],
             sub_fmtty_rest$20=match$11[1];
            return [0,[10,sub_fmtty_rest$20],fmt$10]}
          break;
         case 11:
          if(typeof match !== "number" && 11 === match[0])
           {var
             fmtty_rest$10=match[1],
             sub_fmtty_rest$21=sub_fmtty[1],
             match$12=
              type_ignored_format_substituti
               (sub_fmtty_rest$21,fmt,fmtty_rest$10),
             fmt$11=match$12[2],
             sub_fmtty_rest$22=match$12[1];
            return [0,[11,sub_fmtty_rest$22],fmt$11]}
          break;
         case 13:
          if(typeof match !== "number" && 13 === match[0])
           {var
             fmtty_rest$11=match[1],
             sub_fmtty_rest$23=sub_fmtty[1],
             match$13=
              type_ignored_format_substituti
               (sub_fmtty_rest$23,fmt,fmtty_rest$11),
             fmt$12=match$13[2],
             sub_fmtty_rest$24=match$13[1];
            return [0,[13,sub_fmtty_rest$24],fmt$12]}
          break;
         case 14:
          if(typeof match !== "number" && 14 === match[0])
           {var
             fmtty_rest$12=match[1],
             sub_fmtty_rest$25=sub_fmtty[1],
             match$14=
              type_ignored_format_substituti
               (sub_fmtty_rest$25,fmt,fmtty_rest$12),
             fmt$13=match$14[2],
             sub_fmtty_rest$26=match$14[1];
            return [0,[14,sub_fmtty_rest$26],fmt$13]}
          break
         }
      throw Type_mismatch}
    function type_format_gen(fmt,fmtty)
     {if(typeof fmt === "number")
       return [0,0,fmtty];
      else
       switch(fmt[0])
        {case 0:
          if(typeof fmtty !== "number" && 0 === fmtty[0])
           {var
             fmtty_rest=fmtty[1],
             fmt_rest=fmt[1],
             match=type_format_gen(fmt_rest,fmtty_rest),
             fmtty$0=match[2],
             fmt$0=match[1];
            return [0,[0,fmt$0],fmtty$0]}
          break;
         case 1:
          if(typeof fmtty !== "number" && 0 === fmtty[0])
           {var
             fmtty_rest$0=fmtty[1],
             fmt_rest$0=fmt[1],
             match$0=type_format_gen(fmt_rest$0,fmtty_rest$0),
             fmtty$1=match$0[2],
             fmt$1=match$0[1];
            return [0,[1,fmt$1],fmtty$1]}
          break;
         case 2:
          var
           fmt_rest$1=fmt[2],
           pad=fmt[1],
           match$1=type_padding(pad,fmtty),
           _sJ_=match$1[2],
           _sI_=match$1[1];
          if(typeof _sJ_ !== "number" && 1 === _sJ_[0])
           {var
             fmtty_rest$1=_sJ_[1],
             match$2=type_format_gen(fmt_rest$1,fmtty_rest$1),
             fmtty$2=match$2[2],
             fmt$2=match$2[1];
            return [0,[2,_sI_,fmt$2],fmtty$2]}
          throw Type_mismatch;
         case 3:
          var
           fmt_rest$2=fmt[2],
           pad$0=fmt[1],
           match$3=type_padding(pad$0,fmtty),
           _sL_=match$3[2],
           _sK_=match$3[1];
          if(typeof _sL_ !== "number" && 1 === _sL_[0])
           {var
             fmtty_rest$2=_sL_[1],
             match$4=type_format_gen(fmt_rest$2,fmtty_rest$2),
             fmtty$3=match$4[2],
             fmt$3=match$4[1];
            return [0,[3,_sK_,fmt$3],fmtty$3]}
          throw Type_mismatch;
         case 4:
          var
           fmt_rest$3=fmt[4],
           prec=fmt[3],
           pad$1=fmt[2],
           iconv=fmt[1],
           match$5=type_padprec(pad$1,prec,fmtty),
           _sN_=match$5[3],
           _sM_=match$5[1];
          if(typeof _sN_ !== "number" && 2 === _sN_[0])
           {var
             fmtty_rest$3=_sN_[1],
             prec$0=match$5[2],
             match$6=type_format_gen(fmt_rest$3,fmtty_rest$3),
             fmtty$4=match$6[2],
             fmt$4=match$6[1];
            return [0,[4,iconv,_sM_,prec$0,fmt$4],fmtty$4]}
          throw Type_mismatch;
         case 5:
          var
           fmt_rest$4=fmt[4],
           prec$1=fmt[3],
           pad$2=fmt[2],
           iconv$0=fmt[1],
           match$7=type_padprec(pad$2,prec$1,fmtty),
           _sP_=match$7[3],
           _sO_=match$7[1];
          if(typeof _sP_ !== "number" && 3 === _sP_[0])
           {var
             fmtty_rest$4=_sP_[1],
             prec$2=match$7[2],
             match$8=type_format_gen(fmt_rest$4,fmtty_rest$4),
             fmtty$5=match$8[2],
             fmt$5=match$8[1];
            return [0,[5,iconv$0,_sO_,prec$2,fmt$5],fmtty$5]}
          throw Type_mismatch;
         case 6:
          var
           fmt_rest$5=fmt[4],
           prec$3=fmt[3],
           pad$3=fmt[2],
           iconv$1=fmt[1],
           match$9=type_padprec(pad$3,prec$3,fmtty),
           _sR_=match$9[3],
           _sQ_=match$9[1];
          if(typeof _sR_ !== "number" && 4 === _sR_[0])
           {var
             fmtty_rest$5=_sR_[1],
             prec$4=match$9[2],
             match$10=type_format_gen(fmt_rest$5,fmtty_rest$5),
             fmtty$6=match$10[2],
             fmt$6=match$10[1];
            return [0,[6,iconv$1,_sQ_,prec$4,fmt$6],fmtty$6]}
          throw Type_mismatch;
         case 7:
          var
           fmt_rest$6=fmt[4],
           prec$5=fmt[3],
           pad$4=fmt[2],
           iconv$2=fmt[1],
           match$11=type_padprec(pad$4,prec$5,fmtty),
           _sT_=match$11[3],
           _sS_=match$11[1];
          if(typeof _sT_ !== "number" && 5 === _sT_[0])
           {var
             fmtty_rest$6=_sT_[1],
             prec$6=match$11[2],
             match$12=type_format_gen(fmt_rest$6,fmtty_rest$6),
             fmtty$7=match$12[2],
             fmt$7=match$12[1];
            return [0,[7,iconv$2,_sS_,prec$6,fmt$7],fmtty$7]}
          throw Type_mismatch;
         case 8:
          var
           fmt_rest$7=fmt[4],
           prec$7=fmt[3],
           pad$5=fmt[2],
           fconv=fmt[1],
           match$13=type_padprec(pad$5,prec$7,fmtty),
           _sV_=match$13[3],
           _sU_=match$13[1];
          if(typeof _sV_ !== "number" && 6 === _sV_[0])
           {var
             fmtty_rest$7=_sV_[1],
             prec$8=match$13[2],
             match$14=type_format_gen(fmt_rest$7,fmtty_rest$7),
             fmtty$8=match$14[2],
             fmt$8=match$14[1];
            return [0,[8,fconv,_sU_,prec$8,fmt$8],fmtty$8]}
          throw Type_mismatch;
         case 9:
          var
           fmt_rest$8=fmt[2],
           pad$6=fmt[1],
           match$15=type_padding(pad$6,fmtty),
           _sX_=match$15[2],
           _sW_=match$15[1];
          if(typeof _sX_ !== "number" && 7 === _sX_[0])
           {var
             fmtty_rest$8=_sX_[1],
             match$16=type_format_gen(fmt_rest$8,fmtty_rest$8),
             fmtty$9=match$16[2],
             fmt$9=match$16[1];
            return [0,[9,_sW_,fmt$9],fmtty$9]}
          throw Type_mismatch;
         case 10:
          var
           fmt_rest$9=fmt[1],
           match$17=type_format_gen(fmt_rest$9,fmtty),
           fmtty$10=match$17[2],
           fmt$10=match$17[1];
          return [0,[10,fmt$10],fmtty$10];
         case 11:
          var
           fmt_rest$10=fmt[2],
           str=fmt[1],
           match$18=type_format_gen(fmt_rest$10,fmtty),
           fmtty$11=match$18[2],
           fmt$11=match$18[1];
          return [0,[11,str,fmt$11],fmtty$11];
         case 12:
          var
           fmt_rest$11=fmt[2],
           chr=fmt[1],
           match$19=type_format_gen(fmt_rest$11,fmtty),
           fmtty$12=match$19[2],
           fmt$12=match$19[1];
          return [0,[12,chr,fmt$12],fmtty$12];
         case 13:
          if(typeof fmtty !== "number" && 8 === fmtty[0])
           {var
             fmtty_rest$9=fmtty[2],
             sub_fmtty=fmtty[1],
             fmt_rest$12=fmt[3],
             sub_fmtty$0=fmt[2],
             pad_opt=fmt[1];
            if(caml_notequal([0,sub_fmtty$0],[0,sub_fmtty]))
             throw Type_mismatch;
            var
             match$20=type_format_gen(fmt_rest$12,fmtty_rest$9),
             fmtty$13=match$20[2],
             fmt$13=match$20[1];
            return [0,[13,pad_opt,sub_fmtty,fmt$13],fmtty$13]}
          break;
         case 14:
          if(typeof fmtty !== "number" && 9 === fmtty[0])
           {var
             fmtty_rest$10=fmtty[3],
             sub_fmtty1=fmtty[1],
             fmt_rest$13=fmt[3],
             sub_fmtty$1=fmt[2],
             pad_opt$0=fmt[1],
             _sY_=[0,erase_rel(sub_fmtty1)];
            if(caml_notequal([0,erase_rel(sub_fmtty$1)],_sY_))
             throw Type_mismatch;
            var
             match$21=type_format_gen(fmt_rest$13,erase_rel(fmtty_rest$10)),
             fmtty$14=match$21[2],
             fmt$14=match$21[1];
            return [0,[14,pad_opt$0,sub_fmtty1,fmt$14],fmtty$14]}
          break;
         case 15:
          if(typeof fmtty !== "number" && 10 === fmtty[0])
           {var
             fmtty_rest$11=fmtty[1],
             fmt_rest$14=fmt[1],
             match$22=type_format_gen(fmt_rest$14,fmtty_rest$11),
             fmtty$15=match$22[2],
             fmt$15=match$22[1];
            return [0,[15,fmt$15],fmtty$15]}
          break;
         case 16:
          if(typeof fmtty !== "number" && 11 === fmtty[0])
           {var
             fmtty_rest$12=fmtty[1],
             fmt_rest$15=fmt[1],
             match$23=type_format_gen(fmt_rest$15,fmtty_rest$12),
             fmtty$16=match$23[2],
             fmt$16=match$23[1];
            return [0,[16,fmt$16],fmtty$16]}
          break;
         case 17:
          var
           fmt_rest$16=fmt[2],
           formatting_lit=fmt[1],
           match$24=type_format_gen(fmt_rest$16,fmtty),
           fmtty$17=match$24[2],
           fmt$17=match$24[1];
          return [0,[17,formatting_lit,fmt$17],fmtty$17];
         case 18:
          var fmt_rest$17=fmt[2],formatting_gen=fmt[1];
          if(0 === formatting_gen[0])
           {var
             match$28=formatting_gen[1],
             str$0=match$28[2],
             fmt1=match$28[1],
             match$29=type_format_gen(fmt1,fmtty),
             fmtty2=match$29[2],
             fmt2=match$29[1],
             match$30=type_format_gen(fmt_rest$17,fmtty2),
             fmtty3=match$30[2],
             fmt3=match$30[1];
            return [0,[18,[0,[0,fmt2,str$0]],fmt3],fmtty3]}
          var
           match$31=formatting_gen[1],
           str$1=match$31[2],
           fmt1$0=match$31[1],
           match$32=type_format_gen(fmt1$0,fmtty),
           fmtty2$0=match$32[2],
           fmt2$0=match$32[1],
           match$33=type_format_gen(fmt_rest$17,fmtty2$0),
           fmtty3$0=match$33[2],
           fmt3$0=match$33[1];
          return [0,[18,[1,[0,fmt2$0,str$1]],fmt3$0],fmtty3$0];
         case 19:
          if(typeof fmtty !== "number" && 13 === fmtty[0])
           {var
             fmtty_rest$13=fmtty[1],
             fmt_rest$18=fmt[1],
             match$25=type_format_gen(fmt_rest$18,fmtty_rest$13),
             fmtty$18=match$25[2],
             fmt$18=match$25[1];
            return [0,[19,fmt$18],fmtty$18]}
          break;
         case 20:
          if(typeof fmtty !== "number" && 1 === fmtty[0])
           {var
             fmtty_rest$14=fmtty[1],
             fmt_rest$19=fmt[3],
             char_set=fmt[2],
             width_opt=fmt[1],
             match$26=type_format_gen(fmt_rest$19,fmtty_rest$14),
             fmtty$19=match$26[2],
             fmt$19=match$26[1];
            return [0,[20,width_opt,char_set,fmt$19],fmtty$19]}
          break;
         case 21:
          if(typeof fmtty !== "number" && 2 === fmtty[0])
           {var
             fmtty_rest$15=fmtty[1],
             fmt_rest$20=fmt[2],
             counter=fmt[1],
             match$27=type_format_gen(fmt_rest$20,fmtty_rest$15),
             fmtty$20=match$27[2],
             fmt$20=match$27[1];
            return [0,[21,counter,fmt$20],fmtty$20]}
          break;
         case 23:
          var rest=fmt[2],ign=fmt[1];
          if(typeof ign === "number")
           switch(ign)
            {case 0:return type_ignored_param_one(ign,rest,fmtty);
             case 1:return type_ignored_param_one(ign,rest,fmtty);
             case 2:
              if(typeof fmtty !== "number" && 14 === fmtty[0])
               {var
                 fmtty_rest$16=fmtty[1],
                 match$34=type_format_gen(rest,fmtty_rest$16),
                 fmtty$21=match$34[2],
                 fmt$21=match$34[1];
                return [0,[23,2,fmt$21],fmtty$21]}
              throw Type_mismatch;
             default:return type_ignored_param_one(ign,rest,fmtty)}
          else
           switch(ign[0])
            {case 0:return type_ignored_param_one(ign,rest,fmtty);
             case 1:return type_ignored_param_one(ign,rest,fmtty);
             case 2:return type_ignored_param_one(ign,rest,fmtty);
             case 3:return type_ignored_param_one(ign,rest,fmtty);
             case 4:return type_ignored_param_one(ign,rest,fmtty);
             case 5:return type_ignored_param_one(ign,rest,fmtty);
             case 6:return type_ignored_param_one(ign,rest,fmtty);
             case 7:return type_ignored_param_one(ign,rest,fmtty);
             case 8:
              var sub_fmtty$2=ign[2],pad_opt$1=ign[1];
              return type_ignored_param_one
                      ([8,pad_opt$1,sub_fmtty$2],rest,fmtty);
             case 9:
              var
               sub_fmtty$3=ign[2],
               pad_opt$2=ign[1],
               _sZ_=type_ignored_format_substituti(sub_fmtty$3,rest,fmtty),
               match$35=_sZ_[2],
               fmtty$22=match$35[2],
               fmt$22=match$35[1],
               sub_fmtty$4=_sZ_[1];
              return [0,[23,[9,pad_opt$2,sub_fmtty$4],fmt$22],fmtty$22];
             case 10:return type_ignored_param_one(ign,rest,fmtty);
             default:return type_ignored_param_one(ign,rest,fmtty)}
         }
      throw Type_mismatch}
    function type_ignored_param_one(ign,fmt,fmtty)
     {var match=type_format_gen(fmt,fmtty),fmtty$0=match[2],fmt$0=match[1];
      return [0,[23,ign,fmt$0],fmtty$0]}
    function type_format(fmt,fmtty)
     {var _sH_=type_format_gen(fmt,fmtty);
      if(typeof _sH_[2] === "number"){var fmt$0=_sH_[1];return fmt$0}
      throw Type_mismatch}
    function recast(fmt,fmtty){return type_format(fmt,erase_rel(symm(fmtty)))}
    function fix_padding(padty,width,str)
     {var
       len=caml_ml_string_length(str),
       padty$0=0 <= width?padty:0,
       width$0=abs(width);
      if(width$0 <= len)return str;
      var _sG_=2 === padty$0?48:32,res=make$0(width$0,_sG_);
      switch(padty$0)
       {case 0:blit$0(str,0,res,0,len);break;
        case 1:blit$0(str,0,res,width$0 - len | 0,len);break;
        default:
         var switch$0=0;
         if(0 < len)
          {var switch$1=0;
           if
            (43
             !==
             caml_string_get(str,0)
             &&
             45
             !==
             caml_string_get(str,0)
             &&
             32
             !==
             caml_string_get(str,0))
            {switch$0 = 1;switch$1 = 1}
           if(! switch$1)
            {caml_bytes_set(res,0,caml_string_get(str,0));
             blit$0(str,1,res,(width$0 - len | 0) + 1 | 0,len - 1 | 0)}}
         else
          switch$0 = 1;
         if(switch$0)
          {var switch$2=0;
           if(1 < len && 48 === caml_string_get(str,0))
            {var switch$3=0;
             if
              (120
               !==
               caml_string_get(str,1)
               &&
               88
               !==
               caml_string_get(str,1))
              {switch$2 = 1;switch$3 = 1}
             if(! switch$3)
              {caml_bytes_set(res,1,caml_string_get(str,1));
               blit$0(str,2,res,(width$0 - len | 0) + 2 | 0,len - 2 | 0)}}
           else
            switch$2 = 1;
           if(switch$2)blit$0(str,0,res,width$0 - len | 0,len)}}
      return caml_string_of_bytes(res)}
    function fix_int_precision(prec,str)
     {var
       prec$0=abs(prec),
       len=caml_ml_string_length(str),
       c=caml_string_get(str,0),
       switch$0=0;
      if(58 <= c)
       {if(71 <= c)
         {if(! (5 < (c - 97 | 0) >>> 0))switch$0 = 1}
        else
         if(65 <= c)switch$0 = 1}
      else
       {var switch$1=0;
        if(32 !== c)
         if(43 <= c)
          {var switcher=c - 43 | 0;
           switch(switcher)
            {case 5:
              if(len < (prec$0 + 2 | 0) && 1 < len)
               {var switch$2=0;
                if
                 (120
                  ===
                  caml_string_get(str,1)
                  ||
                  88
                  ===
                  caml_string_get(str,1))
                 switch$2 = 1;
                if(switch$2)
                 {var res$1=make$0(prec$0 + 2 | 0,48);
                  caml_bytes_set(res$1,1,caml_string_get(str,1));
                  blit$0(str,2,res$1,(prec$0 - len | 0) + 4 | 0,len - 2 | 0);
                  return caml_string_of_bytes(res$1)}}
              switch$0 = 1;
              switch$1 = 1;
              break;
             case 0:
             case 2:break;
             case 1:
             case 3:
             case 4:switch$1 = 1;break;
             default:switch$0 = 1;switch$1 = 1}}
         else
          switch$1 = 1;
        if(! switch$1 && len < (prec$0 + 1 | 0))
         {var res$0=make$0(prec$0 + 1 | 0,48);
          caml_bytes_set(res$0,0,c);
          blit$0(str,1,res$0,(prec$0 - len | 0) + 2 | 0,len - 1 | 0);
          return caml_string_of_bytes(res$0)}}
      if(switch$0 && len < prec$0)
       {var res=make$0(prec$0,48);
        blit$0(str,0,res,prec$0 - len | 0,len);
        return caml_string_of_bytes(res)}
      return str}
    function string_to_caml_string(str)
     {var
       str$0=escaped$1(str),
       l=caml_ml_string_length(str$0),
       res=make$0(l + 2 | 0,34);
      caml_blit_string(str$0,0,res,1,l);
      return caml_string_of_bytes(res)}
    function format_of_fconv(fconv,prec)
     {var
       prec$0=abs(prec),
       symb=char_of_fconv(_aq_,fconv),
       buf=buffer_create(16);
      buffer_add_char(buf,37);
      bprint_fconv_flag(buf,fconv);
      buffer_add_char(buf,46);
      buffer_add_string(buf,caml_string_of_jsbytes("" + prec$0));
      buffer_add_char(buf,symb);
      return buffer_contents(buf)}
    function transform_int_alt(iconv,s)
     {if(13 <= iconv)
       {var n=[0,0],_sB_=caml_ml_string_length(s) - 1 | 0,_sA_=0;
        if(! (_sB_ < 0))
         {var i$0=_sA_;
          for(;;)
           {var match=caml_string_unsafe_get(s,i$0),switcher$0=match - 48 | 0;
            if(! (9 < switcher$0 >>> 0))n[1]++;
            var _sF_=i$0 + 1 | 0;
            if(_sB_ !== i$0){var i$0=_sF_;continue}
            break}}
        var
         digits=n[1],
         buf=
          caml_create_bytes
           (caml_ml_string_length(s) + ((digits - 1 | 0) / 3 | 0) | 0),
         pos=[0,0],
         put=function(c){caml_bytes_set(buf,pos[1],c);pos[1]++;return 0},
         left=[0,((digits - 1 | 0) % 3 | 0) + 1 | 0],
         _sD_=caml_ml_string_length(s) - 1 | 0,
         _sC_=0;
        if(! (_sD_ < 0))
         {var i=_sC_;
          for(;;)
           {var c=caml_string_unsafe_get(s,i),switcher=c - 48 | 0;
            if(9 < switcher >>> 0)
             put(c);
            else
             {if(0 === left[1]){put(95);left[1] = 3}left[1] += -1;put(c)}
            var _sE_=i + 1 | 0;
            if(_sD_ !== i){var i=_sE_;continue}
            break}}
        return caml_string_of_bytes(buf)}
      return s}
    function convert_int(iconv,n)
     {switch(iconv)
       {case 1:var _sz_=cst_d$3;break;
        case 2:var _sz_=cst_d$4;break;
        case 4:var _sz_=cst_i$1;break;
        case 5:var _sz_=cst_i$2;break;
        case 6:var _sz_=cst_x;break;
        case 7:var _sz_=cst_x$0;break;
        case 8:var _sz_=cst_X$0;break;
        case 9:var _sz_=cst_X$1;break;
        case 10:var _sz_=cst_o;break;
        case 11:var _sz_=cst_o$0;break;
        case 0:
        case 13:var _sz_=cst_d$2;break;
        case 3:
        case 14:var _sz_=cst_i$0;break;
        default:var _sz_=cst_u}
      return transform_int_alt(iconv,caml_format_int(_sz_,n))}
    function convert_int32(iconv,n)
     {switch(iconv)
       {case 1:var _sy_=cst_ld$0;break;
        case 2:var _sy_=cst_ld$1;break;
        case 4:var _sy_=cst_li$1;break;
        case 5:var _sy_=cst_li$2;break;
        case 6:var _sy_=cst_lx;break;
        case 7:var _sy_=cst_lx$0;break;
        case 8:var _sy_=cst_lX;break;
        case 9:var _sy_=cst_lX$0;break;
        case 10:var _sy_=cst_lo;break;
        case 11:var _sy_=cst_lo$0;break;
        case 0:
        case 13:var _sy_=cst_ld;break;
        case 3:
        case 14:var _sy_=cst_li$0;break;
        default:var _sy_=cst_lu}
      return transform_int_alt(iconv,caml_format_int(_sy_,n))}
    function convert_nativeint(iconv,n)
     {switch(iconv)
       {case 1:var _sx_=cst_nd$0;break;
        case 2:var _sx_=cst_nd$1;break;
        case 4:var _sx_=cst_ni$1;break;
        case 5:var _sx_=cst_ni$2;break;
        case 6:var _sx_=cst_nx;break;
        case 7:var _sx_=cst_nx$0;break;
        case 8:var _sx_=cst_nX;break;
        case 9:var _sx_=cst_nX$0;break;
        case 10:var _sx_=cst_no;break;
        case 11:var _sx_=cst_no$0;break;
        case 0:
        case 13:var _sx_=cst_nd;break;
        case 3:
        case 14:var _sx_=cst_ni$0;break;
        default:var _sx_=cst_nu}
      return transform_int_alt(iconv,caml_format_int(_sx_,n))}
    function convert_int64(iconv,n)
     {switch(iconv)
       {case 1:var _sw_=cst_Ld$0;break;
        case 2:var _sw_=cst_Ld$1;break;
        case 4:var _sw_=cst_Li$1;break;
        case 5:var _sw_=cst_Li$2;break;
        case 6:var _sw_=cst_Lx;break;
        case 7:var _sw_=cst_Lx$0;break;
        case 8:var _sw_=cst_LX;break;
        case 9:var _sw_=cst_LX$0;break;
        case 10:var _sw_=cst_Lo;break;
        case 11:var _sw_=cst_Lo$0;break;
        case 0:
        case 13:var _sw_=cst_Ld;break;
        case 3:
        case 14:var _sw_=cst_Li$0;break;
        default:var _sw_=cst_Lu}
      return transform_int_alt(iconv,caml_int64_format(_sw_,n))}
    function convert_float(fconv,prec,x)
     {function hex(param)
       {switch(fconv[1])
         {case 0:var sign=45;break;
          case 1:var sign=43;break;
          default:var sign=32}
        return runtime.caml_hexstring_of_float(x,prec,sign)}
      function caml_special_val(str)
       {var match=runtime.caml_classify_float(x);
        return 3 === match
                ?x < 0.?cst_neg_infinity:cst_infinity
                :4 <= match?cst_nan:str}
      switch(fconv[2])
       {case 5:
         var
          str=caml_format_float(format_of_fconv(fconv,prec),x),
          len=caml_ml_string_length(str),
          i=0;
         for(;;)
          {if(i === len)
            var _su_=0;
           else
            {var match=caml_string_get(str,i),_st_=match - 46 | 0,switch$0=0;
             if(23 < _st_ >>> 0)
              {if(55 === _st_)switch$0 = 1}
             else
              if(21 < (_st_ - 1 | 0) >>> 0)switch$0 = 1;
             if(! switch$0){var i$0=i + 1 | 0,i=i$0;continue}
             var _su_=1}
           var _sv_=_su_?str:symbol(str,cst$29);
           return caml_special_val(_sv_)}
        case 6:return hex(0);
        case 7:return uppercase_ascii$1(hex(0));
        case 8:return caml_special_val(hex(0));
        default:return caml_format_float(format_of_fconv(fconv,prec),x)}}
    function string_of_fmtty(fmtty)
     {var buf=buffer_create(16);
      bprint_fmtty(buf,fmtty);
      return buffer_contents(buf)}
    function make_printf$0(counter,k,acc,fmt)
     {var k$0=k,acc$0=acc,fmt$0=fmt;
      for(;;)
       if(typeof fmt$0 === "number")
        return caml_call1(k$0,acc$0);
       else
        switch(fmt$0[0])
         {case 0:
           var rest=fmt$0[1];
           return function(c)
            {var new_acc=[5,acc$0,c];return make_printf(k$0,new_acc,rest)};
          case 1:
           var rest$0=fmt$0[1];
           return function(c)
            {var
              str=escaped(c),
              l=caml_ml_string_length(str),
              res=make$0(l + 2 | 0,39);
             caml_blit_string(str,0,res,1,l);
             var new_acc=[4,acc$0,caml_string_of_bytes(res)];
             return make_printf(k$0,new_acc,rest$0)};
          case 2:
           var rest$1=fmt$0[2],pad=fmt$0[1];
           return make_padding(k$0,acc$0,rest$1,pad,function(str){return str});
          case 3:
           var rest$2=fmt$0[2],pad$0=fmt$0[1];
           return make_padding(k$0,acc$0,rest$2,pad$0,string_to_caml_string);
          case 4:
           var rest$3=fmt$0[4],prec=fmt$0[3],pad$1=fmt$0[2],iconv=fmt$0[1];
           return make_int_padding_precision
                   (k$0,acc$0,rest$3,pad$1,prec,convert_int,iconv);
          case 5:
           var
            rest$4=fmt$0[4],
            prec$0=fmt$0[3],
            pad$2=fmt$0[2],
            iconv$0=fmt$0[1];
           return make_int_padding_precision
                   (k$0,acc$0,rest$4,pad$2,prec$0,convert_int32,iconv$0);
          case 6:
           var
            rest$5=fmt$0[4],
            prec$1=fmt$0[3],
            pad$3=fmt$0[2],
            iconv$1=fmt$0[1];
           return make_int_padding_precision
                   (k$0,acc$0,rest$5,pad$3,prec$1,convert_nativeint,iconv$1);
          case 7:
           var
            rest$6=fmt$0[4],
            prec$2=fmt$0[3],
            pad$4=fmt$0[2],
            iconv$2=fmt$0[1];
           return make_int_padding_precision
                   (k$0,acc$0,rest$6,pad$4,prec$2,convert_int64,iconv$2);
          case 8:
           var rest$7=fmt$0[4],prec$3=fmt$0[3],pad$5=fmt$0[2],fconv=fmt$0[1];
           if(typeof pad$5 === "number")
            {if(typeof prec$3 === "number")
              return prec$3
                      ?function(p,x)
                        {var str=convert_float(fconv,p,x);
                         return make_printf(k$0,[4,acc$0,str],rest$7)}
                      :function(x)
                        {var
                          str=
                           convert_float(fconv,default_float_precision(fconv),x);
                         return make_printf(k$0,[4,acc$0,str],rest$7)};
             var p=prec$3[1];
             return function(x)
              {var str=convert_float(fconv,p,x);
               return make_printf(k$0,[4,acc$0,str],rest$7)}}
           else
            {if(0 === pad$5[0])
              {var _sq_=pad$5[2],_sr_=pad$5[1];
               if(typeof prec$3 === "number")
                return prec$3
                        ?function(p,x)
                          {var str=fix_padding(_sr_,_sq_,convert_float(fconv,p,x));
                           return make_printf(k$0,[4,acc$0,str],rest$7)}
                        :function(x)
                          {var
                            str=convert_float(fconv,default_float_precision(fconv),x),
                            str$0=fix_padding(_sr_,_sq_,str);
                           return make_printf(k$0,[4,acc$0,str$0],rest$7)};
               var p$0=prec$3[1];
               return function(x)
                {var str=fix_padding(_sr_,_sq_,convert_float(fconv,p$0,x));
                 return make_printf(k$0,[4,acc$0,str],rest$7)}}
             var _ss_=pad$5[1];
             if(typeof prec$3 === "number")
              return prec$3
                      ?function(w,p,x)
                        {var str=fix_padding(_ss_,w,convert_float(fconv,p,x));
                         return make_printf(k$0,[4,acc$0,str],rest$7)}
                      :function(w,x)
                        {var
                          str=convert_float(fconv,default_float_precision(fconv),x),
                          str$0=fix_padding(_ss_,w,str);
                         return make_printf(k$0,[4,acc$0,str$0],rest$7)};
             var p$1=prec$3[1];
             return function(w,x)
              {var str=fix_padding(_ss_,w,convert_float(fconv,p$1,x));
               return make_printf(k$0,[4,acc$0,str],rest$7)}}
          case 9:
           var rest$8=fmt$0[2],pad$6=fmt$0[1];
           return make_padding(k$0,acc$0,rest$8,pad$6,string_of_bool);
          case 10:
           var fmt$1=fmt$0[1],acc$1=[7,acc$0],acc$0=acc$1,fmt$0=fmt$1;
           continue;
          case 11:
           var
            fmt$2=fmt$0[2],
            str=fmt$0[1],
            acc$2=[2,acc$0,str],
            acc$0=acc$2,
            fmt$0=fmt$2;
           continue;
          case 12:
           var
            fmt$3=fmt$0[2],
            chr=fmt$0[1],
            acc$3=[3,acc$0,chr],
            acc$0=acc$3,
            fmt$0=fmt$3;
           continue;
          case 13:
           var
            rest$9=fmt$0[3],
            sub_fmtty=fmt$0[2],
            ty=string_of_fmtty(sub_fmtty);
           return function(str){return make_printf(k$0,[4,acc$0,ty],rest$9)};
          case 14:
           var rest$10=fmt$0[3],fmtty=fmt$0[2];
           return function(param)
            {var fmt=param[1];
             return make_printf
                     (k$0,acc$0,concat_fmt(recast(fmt,fmtty),rest$10))};
          case 15:
           var rest$11=fmt$0[1];
           return function(f,x)
            {return make_printf
                     (k$0,
                      [6,acc$0,function(o){return caml_call2(f,o,x)}],
                      rest$11)};
          case 16:
           var rest$12=fmt$0[1];
           return function(f){return make_printf(k$0,[6,acc$0,f],rest$12)};
          case 17:
           var
            fmt$4=fmt$0[2],
            fmting_lit=fmt$0[1],
            acc$4=[0,acc$0,fmting_lit],
            acc$0=acc$4,
            fmt$0=fmt$4;
           continue;
          case 18:
           var _so_=fmt$0[1];
           if(0 === _so_[0])
            {var
              rest$13=fmt$0[2],
              match=_so_[1],
              fmt$5=match[1],
              k$3=
               function(acc,k,rest)
                {function k$0(kacc)
                  {return make_printf(k,[1,acc,[0,kacc]],rest)}
                 return k$0},
              k$1=k$3(acc$0,k$0,rest$13),
              k$0=k$1,
              acc$0=0,
              fmt$0=fmt$5;
             continue}
           var
            rest$14=fmt$0[2],
            match$0=_so_[1],
            fmt$6=match$0[1],
            k$4=
             function(acc,k,rest)
              {function k$0(kacc){return make_printf(k,[1,acc,[1,kacc]],rest)}
               return k$0},
            k$2=k$4(acc$0,k$0,rest$14),
            k$0=k$2,
            acc$0=0,
            fmt$0=fmt$6;
           continue;
          case 19:throw [0,Assert_failure,_ar_];
          case 20:
           var rest$15=fmt$0[3],new_acc=[8,acc$0,cst_Printf_bad_conversion];
           return function(param){return make_printf(k$0,new_acc,rest$15)};
          case 21:
           var rest$16=fmt$0[2];
           return function(n)
            {var new_acc=[4,acc$0,caml_format_int(cst_u$0,n)];
             return make_printf(k$0,new_acc,rest$16)};
          case 22:
           var rest$17=fmt$0[1];
           return function(c)
            {var new_acc=[5,acc$0,c];return make_printf(k$0,new_acc,rest$17)};
          case 23:
           var rest$18=fmt$0[2],ign=fmt$0[1];
           if(counter < 50)
            {var counter$1=counter + 1 | 0;
             return make_ignored_param$0(counter$1,k$0,acc$0,ign,rest$18)}
           return caml_trampoline_return
                   (make_ignored_param$0,[0,k$0,acc$0,ign,rest$18]);
          default:
           var
            rest$19=fmt$0[3],
            f=fmt$0[2],
            arity=fmt$0[1],
            _sp_=caml_call1(f,0);
           if(counter < 50)
            {var counter$0=counter + 1 | 0;
             return make_custom$0(counter$0,k$0,acc$0,rest$19,arity,_sp_)}
           return caml_trampoline_return
                   (make_custom$0,[0,k$0,acc$0,rest$19,arity,_sp_])}}
    function make_ignored_param$0(counter,k,acc,ign,fmt)
     {if(typeof ign === "number")
       switch(ign)
        {case 0:
          if(counter < 50)
           {var counter$0=counter + 1 | 0;
            return make_invalid_arg(counter$0,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 1:
          if(counter < 50)
           {var counter$1=counter + 1 | 0;
            return make_invalid_arg(counter$1,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 2:throw [0,Assert_failure,_as_];
         default:
          if(counter < 50)
           {var counter$2=counter + 1 | 0;
            return make_invalid_arg(counter$2,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt])}
      else
       switch(ign[0])
        {case 0:
          if(counter < 50)
           {var counter$3=counter + 1 | 0;
            return make_invalid_arg(counter$3,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 1:
          if(counter < 50)
           {var counter$4=counter + 1 | 0;
            return make_invalid_arg(counter$4,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 2:
          if(counter < 50)
           {var counter$5=counter + 1 | 0;
            return make_invalid_arg(counter$5,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 3:
          if(counter < 50)
           {var counter$6=counter + 1 | 0;
            return make_invalid_arg(counter$6,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 4:
          if(counter < 50)
           {var counter$7=counter + 1 | 0;
            return make_invalid_arg(counter$7,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 5:
          if(counter < 50)
           {var counter$8=counter + 1 | 0;
            return make_invalid_arg(counter$8,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 6:
          if(counter < 50)
           {var counter$9=counter + 1 | 0;
            return make_invalid_arg(counter$9,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 7:
          if(counter < 50)
           {var counter$10=counter + 1 | 0;
            return make_invalid_arg(counter$10,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 8:
          if(counter < 50)
           {var counter$11=counter + 1 | 0;
            return make_invalid_arg(counter$11,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 9:
          var fmtty=ign[2];
          if(counter < 50)
           {var counter$14=counter + 1 | 0;
            return make_from_fmtty$0(counter$14,k,acc,fmtty,fmt)}
          return caml_trampoline_return(make_from_fmtty$0,[0,k,acc,fmtty,fmt]);
         case 10:
          if(counter < 50)
           {var counter$12=counter + 1 | 0;
            return make_invalid_arg(counter$12,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         default:
          if(counter < 50)
           {var counter$13=counter + 1 | 0;
            return make_invalid_arg(counter$13,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt])}}
    function make_from_fmtty$0(counter,k,acc,fmtty,fmt)
     {if(typeof fmtty === "number")
       {if(counter < 50)
         {var counter$0=counter + 1 | 0;
          return make_invalid_arg(counter$0,k,acc,fmt)}
        return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt])}
      else
       switch(fmtty[0])
        {case 0:
          var rest=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest,fmt)};
         case 1:
          var rest$0=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$0,fmt)};
         case 2:
          var rest$1=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$1,fmt)};
         case 3:
          var rest$2=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$2,fmt)};
         case 4:
          var rest$3=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$3,fmt)};
         case 5:
          var rest$4=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$4,fmt)};
         case 6:
          var rest$5=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$5,fmt)};
         case 7:
          var rest$6=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$6,fmt)};
         case 8:
          var rest$7=fmtty[2];
          return function(param){return make_from_fmtty(k,acc,rest$7,fmt)};
         case 9:
          var
           rest$8=fmtty[3],
           ty2=fmtty[2],
           ty1=fmtty[1],
           ty=trans(symm(ty1),ty2);
          return function(param)
           {return make_from_fmtty(k,acc,concat_fmtty(ty,rest$8),fmt)};
         case 10:
          var rest$9=fmtty[1];
          return function(param,_sn_)
           {return make_from_fmtty(k,acc,rest$9,fmt)};
         case 11:
          var rest$10=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$10,fmt)};
         case 12:
          var rest$11=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$11,fmt)};
         case 13:throw [0,Assert_failure,_at_];
         default:throw [0,Assert_failure,_au_]}}
    function make_invalid_arg(counter,k,acc,fmt)
     {var _sm_=[8,acc,cst_Printf_bad_conversion$0];
      if(counter < 50)
       {var counter$0=counter + 1 | 0;
        return make_printf$0(counter$0,k,_sm_,fmt)}
      return caml_trampoline_return(make_printf$0,[0,k,_sm_,fmt])}
    function make_custom$0(counter,k,acc,rest,arity,f)
     {if(arity)
       {var arity$0=arity[1];
        return function(x)
         {return make_custom(k,acc,rest,arity$0,caml_call1(f,x))}}
      var _sl_=[4,acc,f];
      if(counter < 50)
       {var counter$0=counter + 1 | 0;
        return make_printf$0(counter$0,k,_sl_,rest)}
      return caml_trampoline_return(make_printf$0,[0,k,_sl_,rest])}
    function make_printf(k,acc,fmt)
     {return caml_trampoline(make_printf$0(0,k,acc,fmt))}
    function make_ignored_param(k,acc,ign,fmt)
     {return caml_trampoline(make_ignored_param$0(0,k,acc,ign,fmt))}
    function make_from_fmtty(k,acc,fmtty,fmt)
     {return caml_trampoline(make_from_fmtty$0(0,k,acc,fmtty,fmt))}
    function make_custom(k,acc,rest,arity,f)
     {return caml_trampoline(make_custom$0(0,k,acc,rest,arity,f))}
    function make_padding(k,acc,fmt,pad,trans)
     {if(typeof pad === "number")
       return function(x)
        {var new_acc=[4,acc,caml_call1(trans,x)];
         return make_printf(k,new_acc,fmt)};
      else
       {if(0 === pad[0])
         {var width=pad[2],padty=pad[1];
          return function(x)
           {var new_acc=[4,acc,fix_padding(padty,width,caml_call1(trans,x))];
            return make_printf(k,new_acc,fmt)}}
        var padty$0=pad[1];
        return function(w,x)
         {var new_acc=[4,acc,fix_padding(padty$0,w,caml_call1(trans,x))];
          return make_printf(k,new_acc,fmt)}}}
    function make_int_padding_precision(k,acc,fmt,pad,match,trans,iconv)
     {if(typeof pad === "number")
       {if(typeof match === "number")
         return match
                 ?function(p,x)
                   {var str=fix_int_precision(p,caml_call2(trans,iconv,x));
                    return make_printf(k,[4,acc,str],fmt)}
                 :function(x)
                   {var str=caml_call2(trans,iconv,x);
                    return make_printf(k,[4,acc,str],fmt)};
        var p=match[1];
        return function(x)
         {var str=fix_int_precision(p,caml_call2(trans,iconv,x));
          return make_printf(k,[4,acc,str],fmt)}}
      else
       {if(0 === pad[0])
         {var _si_=pad[2],_sj_=pad[1];
          if(typeof match === "number")
           return match
                   ?function(p,x)
                     {var
                       str=
                        fix_padding
                         (_sj_,_si_,fix_int_precision(p,caml_call2(trans,iconv,x)));
                      return make_printf(k,[4,acc,str],fmt)}
                   :function(x)
                     {var str=fix_padding(_sj_,_si_,caml_call2(trans,iconv,x));
                      return make_printf(k,[4,acc,str],fmt)};
          var p$0=match[1];
          return function(x)
           {var
             str=
              fix_padding
               (_sj_,_si_,fix_int_precision(p$0,caml_call2(trans,iconv,x)));
            return make_printf(k,[4,acc,str],fmt)}}
        var _sk_=pad[1];
        if(typeof match === "number")
         return match
                 ?function(w,p,x)
                   {var
                     str=
                      fix_padding
                       (_sk_,w,fix_int_precision(p,caml_call2(trans,iconv,x)));
                    return make_printf(k,[4,acc,str],fmt)}
                 :function(w,x)
                   {var str=fix_padding(_sk_,w,caml_call2(trans,iconv,x));
                    return make_printf(k,[4,acc,str],fmt)};
        var p$1=match[1];
        return function(w,x)
         {var
           str=
            fix_padding
             (_sk_,w,fix_int_precision(p$1,caml_call2(trans,iconv,x)));
          return make_printf(k,[4,acc,str],fmt)}}}
    function make_iprintf$0(counter,k,o,fmt)
     {var k$0=k,fmt$0=fmt;
      for(;;)
       if(typeof fmt$0 === "number")
        return caml_call1(k$0,o);
       else
        switch(fmt$0[0])
         {case 0:
           var rest=fmt$0[1],_rz_=make_iprintf(k$0,o,rest);
           return function(_sh_){return _rz_};
          case 1:
           var rest$0=fmt$0[1],_rA_=make_iprintf(k$0,o,rest$0);
           return function(_sg_){return _rA_};
          case 2:
           var _rB_=fmt$0[1];
           if(typeof _rB_ === "number")
            {var rest$1=fmt$0[2],_rC_=make_iprintf(k$0,o,rest$1);
             return function(_sc_){return _rC_}}
           else
            {if(0 === _rB_[0])
              {var rest$2=fmt$0[2],_rD_=make_iprintf(k$0,o,rest$2);
               return function(_sf_){return _rD_}}
             var
              rest$3=fmt$0[2],
              _rE_=make_iprintf(k$0,o,rest$3),
              _rF_=function(_se_){return _rE_};
             return function(_sd_){return _rF_}}
          case 3:
           var _rG_=fmt$0[1];
           if(typeof _rG_ === "number")
            {var rest$4=fmt$0[2],_rH_=make_iprintf(k$0,o,rest$4);
             return function(_r__){return _rH_}}
           else
            {if(0 === _rG_[0])
              {var rest$5=fmt$0[2],_rI_=make_iprintf(k$0,o,rest$5);
               return function(_sb_){return _rI_}}
             var
              rest$6=fmt$0[2],
              _rJ_=make_iprintf(k$0,o,rest$6),
              _rK_=function(_sa_){return _rJ_};
             return function(_r$_){return _rK_}}
          case 4:
           var rest$7=fmt$0[4],prec=fmt$0[3],pad=fmt$0[2];
           return fn_of_padding_precision(k$0,o,rest$7,pad,prec);
          case 5:
           var rest$8=fmt$0[4],prec$0=fmt$0[3],pad$0=fmt$0[2];
           return fn_of_padding_precision(k$0,o,rest$8,pad$0,prec$0);
          case 6:
           var rest$9=fmt$0[4],prec$1=fmt$0[3],pad$1=fmt$0[2];
           return fn_of_padding_precision(k$0,o,rest$9,pad$1,prec$1);
          case 7:
           var rest$10=fmt$0[4],prec$2=fmt$0[3],pad$2=fmt$0[2];
           return fn_of_padding_precision(k$0,o,rest$10,pad$2,prec$2);
          case 8:
           var rest$11=fmt$0[4],prec$3=fmt$0[3],pad$3=fmt$0[2];
           return fn_of_padding_precision(k$0,o,rest$11,pad$3,prec$3);
          case 9:
           var _rL_=fmt$0[1];
           if(typeof _rL_ === "number")
            {var rest$12=fmt$0[2],_rM_=make_iprintf(k$0,o,rest$12);
             return function(_r6_){return _rM_}}
           else
            {if(0 === _rL_[0])
              {var rest$13=fmt$0[2],_rN_=make_iprintf(k$0,o,rest$13);
               return function(_r9_){return _rN_}}
             var
              rest$14=fmt$0[2],
              _rO_=make_iprintf(k$0,o,rest$14),
              _rP_=function(_r8_){return _rO_};
             return function(_r7_){return _rP_}}
          case 10:var fmt$1=fmt$0[1],fmt$0=fmt$1;continue;
          case 11:var fmt$2=fmt$0[2],fmt$0=fmt$2;continue;
          case 12:var fmt$3=fmt$0[2],fmt$0=fmt$3;continue;
          case 13:
           var rest$15=fmt$0[3],_rQ_=make_iprintf(k$0,o,rest$15);
           return function(_r5_){return _rQ_};
          case 14:
           var rest$16=fmt$0[3],fmtty=fmt$0[2];
           return function(param)
            {var fmt=param[1];
             return make_iprintf(k$0,o,concat_fmt(recast(fmt,fmtty),rest$16))};
          case 15:
           var
            rest$17=fmt$0[1],
            _rR_=make_iprintf(k$0,o,rest$17),
            _rS_=function(_r4_){return _rR_};
           return function(_r3_){return _rS_};
          case 16:
           var rest$18=fmt$0[1],_rT_=make_iprintf(k$0,o,rest$18);
           return function(_r2_){return _rT_};
          case 17:var fmt$4=fmt$0[2],fmt$0=fmt$4;continue;
          case 18:
           var _rU_=fmt$0[1];
           if(0 === _rU_[0])
            {var
              rest$19=fmt$0[2],
              match=_rU_[1],
              fmt$5=match[1],
              k$3=
               function(k,rest)
                {function k$0(koc){return make_iprintf(k,koc,rest)}return k$0},
              k$1=k$3(k$0,rest$19),
              k$0=k$1,
              fmt$0=fmt$5;
             continue}
           var
            rest$20=fmt$0[2],
            match$0=_rU_[1],
            fmt$6=match$0[1],
            k$4=
             function(k,rest)
              {function k$0(koc){return make_iprintf(k,koc,rest)}return k$0},
            k$2=k$4(k$0,rest$20),
            k$0=k$2,
            fmt$0=fmt$6;
           continue;
          case 19:throw [0,Assert_failure,_av_];
          case 20:
           var rest$21=fmt$0[3],_rV_=make_iprintf(k$0,o,rest$21);
           return function(_r1_){return _rV_};
          case 21:
           var rest$22=fmt$0[2],_rW_=make_iprintf(k$0,o,rest$22);
           return function(_r0_){return _rW_};
          case 22:
           var rest$23=fmt$0[1],_rX_=make_iprintf(k$0,o,rest$23);
           return function(_rZ_){return _rX_};
          case 23:
           var rest$24=fmt$0[2],ign=fmt$0[1],_rY_=0;
           return make_ignored_param
                   (function(param){return caml_call1(k$0,o)},_rY_,ign,rest$24);
          default:
           var rest$25=fmt$0[3],arity=fmt$0[1];
           if(counter < 50)
            {var counter$0=counter + 1 | 0;
             return fn_of_custom_arity$0(counter$0,k$0,o,rest$25,arity)}
           return caml_trampoline_return
                   (fn_of_custom_arity$0,[0,k$0,o,rest$25,arity])}}
    function fn_of_custom_arity$0(counter,k,o,fmt,param)
     {if(param)
       {var arity=param[1],_rx_=fn_of_custom_arity(k,o,fmt,arity);
        return function(_ry_){return _rx_}}
      if(counter < 50)
       {var counter$0=counter + 1 | 0;
        return make_iprintf$0(counter$0,k,o,fmt)}
      return caml_trampoline_return(make_iprintf$0,[0,k,o,fmt])}
    function make_iprintf(k,o,fmt)
     {return caml_trampoline(make_iprintf$0(0,k,o,fmt))}
    function fn_of_custom_arity(k,o,fmt,param)
     {return caml_trampoline(fn_of_custom_arity$0(0,k,o,fmt,param))}
    function fn_of_padding_precision(k,o,fmt,pad,prec)
     {if(typeof pad === "number")
       {if(typeof prec === "number")
         {if(prec)
           {var _q5_=make_iprintf(k,o,fmt),_q6_=function(_rl_){return _q5_};
            return function(_rk_){return _q6_}}
          var _q7_=make_iprintf(k,o,fmt);
          return function(_rj_){return _q7_}}
        var _q8_=make_iprintf(k,o,fmt);
        return function(_ri_){return _q8_}}
      else
       {if(0 === pad[0])
         {if(typeof prec === "number")
           {if(prec)
             {var _q9_=make_iprintf(k,o,fmt),_q__=function(_rw_){return _q9_};
              return function(_rv_){return _q__}}
            var _q$_=make_iprintf(k,o,fmt);
            return function(_ru_){return _q$_}}
          var _ra_=make_iprintf(k,o,fmt);
          return function(_rt_){return _ra_}}
        if(typeof prec === "number")
         {if(prec)
           {var
             _rb_=make_iprintf(k,o,fmt),
             _rc_=function(_rs_){return _rb_},
             _rd_=function(_rr_){return _rc_};
            return function(_rq_){return _rd_}}
          var _re_=make_iprintf(k,o,fmt),_rf_=function(_rp_){return _re_};
          return function(_ro_){return _rf_}}
        var _rg_=make_iprintf(k,o,fmt),_rh_=function(_rn_){return _rg_};
        return function(_rm_){return _rh_}}}
    function output_acc(o,acc)
     {var acc$0=acc;
      for(;;)
       if(typeof acc$0 === "number")
        return 0;
       else
        switch(acc$0[0])
         {case 0:
           var
            fmting_lit=acc$0[2],
            p=acc$0[1],
            s=string_of_formatting_lit(fmting_lit);
           output_acc(o,p);
           return output_string(o,s);
          case 1:
           var _q3_=acc$0[2],_q4_=acc$0[1];
           if(0 === _q3_[0])
            {var acc$1=_q3_[1];
             output_acc(o,_q4_);
             output_string(o,cst$30);
             var acc$0=acc$1;
             continue}
           var acc$2=_q3_[1];
           output_acc(o,_q4_);
           output_string(o,cst$31);
           var acc$0=acc$2;
           continue;
          case 6:
           var f=acc$0[2],p$2=acc$0[1];
           output_acc(o,p$2);
           return caml_call1(f,o);
          case 7:var p$3=acc$0[1];output_acc(o,p$3);return caml_ml_flush(o);
          case 8:
           var msg=acc$0[2],p$4=acc$0[1];
           output_acc(o,p$4);
           return invalid_arg(msg);
          case 2:
          case 4:
           var s$0=acc$0[2],p$0=acc$0[1];
           output_acc(o,p$0);
           return output_string(o,s$0);
          default:
           var c=acc$0[2],p$1=acc$0[1];
           output_acc(o,p$1);
           return caml_ml_output_char(o,c)}}
    function bufput_acc(b,acc)
     {var acc$0=acc;
      for(;;)
       if(typeof acc$0 === "number")
        return 0;
       else
        switch(acc$0[0])
         {case 0:
           var
            fmting_lit=acc$0[2],
            p=acc$0[1],
            s=string_of_formatting_lit(fmting_lit);
           bufput_acc(b,p);
           return add_string(b,s);
          case 1:
           var _q1_=acc$0[2],_q2_=acc$0[1];
           if(0 === _q1_[0])
            {var acc$1=_q1_[1];
             bufput_acc(b,_q2_);
             add_string(b,cst$32);
             var acc$0=acc$1;
             continue}
           var acc$2=_q1_[1];
           bufput_acc(b,_q2_);
           add_string(b,cst$33);
           var acc$0=acc$2;
           continue;
          case 6:
           var f=acc$0[2],p$2=acc$0[1];
           bufput_acc(b,p$2);
           return caml_call1(f,b);
          case 7:var acc$3=acc$0[1],acc$0=acc$3;continue;
          case 8:
           var msg=acc$0[2],p$3=acc$0[1];
           bufput_acc(b,p$3);
           return invalid_arg(msg);
          case 2:
          case 4:
           var s$0=acc$0[2],p$0=acc$0[1];
           bufput_acc(b,p$0);
           return add_string(b,s$0);
          default:
           var c=acc$0[2],p$1=acc$0[1];bufput_acc(b,p$1);return add_char(b,c)}}
    function strput_acc(b,acc)
     {var acc$0=acc;
      for(;;)
       if(typeof acc$0 === "number")
        return 0;
       else
        switch(acc$0[0])
         {case 0:
           var
            fmting_lit=acc$0[2],
            p=acc$0[1],
            s=string_of_formatting_lit(fmting_lit);
           strput_acc(b,p);
           return add_string(b,s);
          case 1:
           var _qZ_=acc$0[2],_q0_=acc$0[1];
           if(0 === _qZ_[0])
            {var acc$1=_qZ_[1];
             strput_acc(b,_q0_);
             add_string(b,cst$34);
             var acc$0=acc$1;
             continue}
           var acc$2=_qZ_[1];
           strput_acc(b,_q0_);
           add_string(b,cst$35);
           var acc$0=acc$2;
           continue;
          case 6:
           var f=acc$0[2],p$2=acc$0[1];
           strput_acc(b,p$2);
           return add_string(b,caml_call1(f,0));
          case 7:var acc$3=acc$0[1],acc$0=acc$3;continue;
          case 8:
           var msg=acc$0[2],p$3=acc$0[1];
           strput_acc(b,p$3);
           return invalid_arg(msg);
          case 2:
          case 4:
           var s$0=acc$0[2],p$0=acc$0[1];
           strput_acc(b,p$0);
           return add_string(b,s$0);
          default:
           var c=acc$0[2],p$1=acc$0[1];strput_acc(b,p$1);return add_char(b,c)}}
    function failwith_message(param)
     {var fmt=param[1],buf=create$2(256);
      function k(acc){strput_acc(buf,acc);return failwith(contents(buf))}
      return make_printf(k,0,fmt)}
    function open_box_of_string(str)
     {if(caml_string_equal(str,cst$36))return _aw_;
      var len=caml_ml_string_length(str);
      function invalid_box(param)
       {return caml_call1(failwith_message(_ax_),str)}
      function parse_spaces(i)
       {var i$0=i;
        for(;;)
         {if(i$0 === len)return i$0;
          var match=caml_string_get(str,i$0);
          if(9 !== match && 32 !== match)return i$0;
          var i$1=i$0 + 1 | 0,i$0=i$1;
          continue}}
      function parse_lword(i,j)
       {var j$0=j;
        for(;;)
         {if(j$0 === len)return j$0;
          var match=caml_string_get(str,j$0),switcher=match - 97 | 0;
          if(25 < switcher >>> 0)return j$0;
          var j$1=j$0 + 1 | 0,j$0=j$1;
          continue}}
      function parse_int(i,j)
       {var j$0=j;
        for(;;)
         {if(j$0 === len)return j$0;
          var match=caml_string_get(str,j$0),switch$0=0;
          if(48 <= match)
           {if(! (58 <= match))switch$0 = 1}
          else
           if(45 === match)switch$0 = 1;
          if(switch$0){var j$1=j$0 + 1 | 0,j$0=j$1;continue}
          return j$0}}
      var
       wstart=parse_spaces(0),
       wend=parse_lword(wstart,wstart),
       box_name=sub$0(str,wstart,wend - wstart | 0),
       nstart=parse_spaces(wend),
       nend=parse_int(nstart,nstart);
      if(nstart === nend)
       var indent=0;
      else
       try
        {var
          _qX_=caml_int_of_string(sub$0(str,nstart,nend - nstart | 0)),
          indent=_qX_}
       catch(_qY_)
        {_qY_ = caml_wrap_exception(_qY_);
         if(_qY_[1] !== Failure)throw _qY_;
         var indent=invalid_box(0)}
      var exp_end=parse_spaces(nend);
      if(exp_end !== len)invalid_box(0);
      var switch$0=0;
      if
       (caml_string_notequal(box_name,cst$37)
        &&
        caml_string_notequal(box_name,cst_b$0))
       var
        box_type=
         caml_string_notequal(box_name,cst_h)
          ?caml_string_notequal(box_name,cst_hov)
            ?caml_string_notequal(box_name,cst_hv)
              ?caml_string_notequal(box_name,cst_v)?invalid_box(0):1
              :2
            :3
          :0;
      else
       switch$0 = 1;
      if(switch$0)var box_type=4;
      return [0,indent,box_type]}
    function make_padding_fmt_ebb(pad,fmt)
     {if(typeof pad === "number")
       return [0,0,fmt];
      else
       {if(0 === pad[0]){var w=pad[2],s=pad[1];return [0,[0,s,w],fmt]}
        var s$0=pad[1];
        return [0,[1,s$0],fmt]}}
    function make_padprec_fmt_ebb(pad,prec,fmt)
     {if(typeof prec === "number")
       var match=prec?[0,1,fmt]:[0,0,fmt];
      else
       var p=prec[1],match=[0,[0,p],fmt];
      var prec$0=match[1];
      if(typeof pad === "number")
       return [0,0,prec$0,fmt];
      else
       {if(0 === pad[0]){var w=pad[2],s=pad[1];return [0,[0,s,w],prec$0,fmt]}
        var s$0=pad[1];
        return [0,[1,s$0],prec$0,fmt]}}
    function fmt_ebb_of_string(legacy_behavior,str)
     {if(legacy_behavior)
       var flag=legacy_behavior[1],legacy_behavior$0=flag;
      else
       var legacy_behavior$0=1;
      function invalid_format_message(str_ind,msg)
       {return caml_call3(failwith_message(_ay_),str,str_ind,msg)}
      function unexpected_end_of_format(end_ind)
       {return invalid_format_message(end_ind,cst_unexpected_end_of_format)}
      function invalid_format_without(str_ind,c,s)
       {return caml_call4(failwith_message(_az_),str,str_ind,c,s)}
      function expected_character(str_ind,expected,read)
       {return caml_call4(failwith_message(_aA_),str,str_ind,expected,read)}
      function add_literal(lit_start,str_ind,fmt)
       {var size=str_ind - lit_start | 0;
        return 0 === size
                ?[0,fmt]
                :1 === size
                  ?[0,[12,caml_string_get(str,lit_start),fmt]]
                  :[0,[11,sub$0(str,lit_start,size),fmt]]}
      function parse_positive(str_ind,end_ind,acc)
       {var str_ind$0=str_ind,acc$0=acc;
        for(;;)
         {if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
          var c=caml_string_get(str,str_ind$0),switcher=c - 48 | 0;
          if(9 < switcher >>> 0)return [0,str_ind$0,acc$0];
          var acc$1=(acc$0 * 10 | 0) + (c - 48 | 0) | 0;
          if(max_string_length < acc$1)
           return caml_call3
                   (failwith_message(_aR_),str,acc$1,max_string_length);
          var str_ind$1=str_ind$0 + 1 | 0,str_ind$0=str_ind$1,acc$0=acc$1;
          continue}}
      function parse_integer(str_ind,end_ind)
       {if(str_ind === end_ind)unexpected_end_of_format(end_ind);
        var match=caml_string_get(str,str_ind);
        if(48 <= match)
         {if(! (58 <= match))return parse_positive(str_ind,end_ind,0)}
        else
         if(45 === match)
          {if((str_ind + 1 | 0) === end_ind)unexpected_end_of_format(end_ind);
           var c=caml_string_get(str,str_ind + 1 | 0),switcher=c - 48 | 0;
           if(9 < switcher >>> 0)
            return expected_character(str_ind + 1 | 0,cst_digit,c);
           var
            match$0=parse_positive(str_ind + 1 | 0,end_ind,0),
            n=match$0[2],
            next_ind=match$0[1];
           return [0,next_ind,- n | 0]}
        throw [0,Assert_failure,_aS_]}
      function parse_spaces(str_ind,end_ind)
       {var str_ind$0=str_ind;
        for(;;)
         {if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
          if(32 === caml_string_get(str,str_ind$0))
           {var str_ind$1=str_ind$0 + 1 | 0,str_ind$0=str_ind$1;continue}
          return str_ind$0}}
      function incompatible_flag(pct_ind,str_ind,symb,option)
       {var subfmt=sub$0(str,pct_ind,str_ind - pct_ind | 0);
        return caml_call5
                (failwith_message(_aX_),str,pct_ind,option,symb,subfmt)}
      function compute_int_conv(pct_ind,str_ind,plus,hash,space,symb)
       {var plus$0=plus,hash$0=hash,space$0=space;
        for(;;)
         {var switch$0=0;
          if(plus$0)
           {if(hash$0)
             switch$0 = 1;
            else
             if(! space$0){if(100 === symb)return 1;if(105 === symb)return 4}}
          else
           if(hash$0)
            if(space$0)
             switch$0 = 1;
            else
             {var switcher$0=symb - 88 | 0;
              if(32 < switcher$0 >>> 0)
               switch$0 = 1;
              else
               switch(switcher$0)
                {case 0:return 9;
                 case 12:return 13;
                 case 17:return 14;
                 case 23:return 11;
                 case 29:return 15;
                 case 32:return 7;
                 default:switch$0 = 1}}
           else
            if(space$0)
             {if(100 === symb)return 2;if(105 === symb)return 5}
            else
             {var switcher$1=symb - 88 | 0;
              if(! (32 < switcher$1 >>> 0))
               switch(switcher$1)
                {case 0:return 8;
                 case 12:return 0;
                 case 17:return 3;
                 case 23:return 10;
                 case 29:return 12;
                 case 32:return 6
                 }}
          if(switch$0)
           {var switcher=symb - 88 | 0;
            if(! (32 < switcher >>> 0))
             switch(switcher)
              {case 0:if(legacy_behavior$0)return 9;break;
               case 23:if(legacy_behavior$0)return 11;break;
               case 32:if(legacy_behavior$0)return 7;break;
               case 12:
               case 17:
               case 29:
                if(legacy_behavior$0){var hash$0=0;continue}
                return incompatible_flag(pct_ind,str_ind,symb,cst$49)
               }}
          if(plus$0)
           {if(space$0)
             {if(legacy_behavior$0){var space$0=0;continue}
              return incompatible_flag(pct_ind,str_ind,32,cst$46)}
            if(legacy_behavior$0){var plus$0=0;continue}
            return incompatible_flag(pct_ind,str_ind,symb,cst$47)}
          if(space$0)
           {if(legacy_behavior$0){var space$0=0;continue}
            return incompatible_flag(pct_ind,str_ind,symb,cst$48)}
          throw [0,Assert_failure,_aV_]}}
      function search_subformat_end(str_ind,end_ind,c)
       {var str_ind$0=str_ind;
        for(;;)
         {if(str_ind$0 === end_ind)
           caml_call3(failwith_message(_aT_),str,c,end_ind);
          var match=caml_string_get(str,str_ind$0);
          if(37 === match)
           {if((str_ind$0 + 1 | 0) === end_ind)
             unexpected_end_of_format(end_ind);
            if(caml_string_get(str,str_ind$0 + 1 | 0) === c)return str_ind$0;
            var match$0=caml_string_get(str,str_ind$0 + 1 | 0);
            if(95 <= match$0)
             {if(123 <= match$0)
               {if(! (126 <= match$0))
                 {var switcher=match$0 - 123 | 0;
                  switch(switcher)
                   {case 0:
                     var
                      sub_end=search_subformat_end(str_ind$0 + 2 | 0,end_ind,125),
                      str_ind$2=sub_end + 2 | 0,
                      str_ind$0=str_ind$2;
                     continue;
                    case 1:break;
                    default:
                     return expected_character
                             (str_ind$0 + 1 | 0,cst_character,125)}}}
              else
               if(! (96 <= match$0))
                {if((str_ind$0 + 2 | 0) === end_ind)
                  unexpected_end_of_format(end_ind);
                 var match$1=caml_string_get(str,str_ind$0 + 2 | 0);
                 if(40 === match$1)
                  {var
                    sub_end$0=search_subformat_end(str_ind$0 + 3 | 0,end_ind,41),
                    str_ind$3=sub_end$0 + 2 | 0,
                    str_ind$0=str_ind$3;
                   continue}
                 if(123 === match$1)
                  {var
                    sub_end$1=
                     search_subformat_end(str_ind$0 + 3 | 0,end_ind,125),
                    str_ind$4=sub_end$1 + 2 | 0,
                    str_ind$0=str_ind$4;
                   continue}
                 var str_ind$5=str_ind$0 + 3 | 0,str_ind$0=str_ind$5;
                 continue}}
            else
             {if(40 === match$0)
               {var
                 sub_end$2=search_subformat_end(str_ind$0 + 2 | 0,end_ind,41),
                 str_ind$6=sub_end$2 + 2 | 0,
                 str_ind$0=str_ind$6;
                continue}
              if(41 === match$0)
               return expected_character(str_ind$0 + 1 | 0,cst_character$0,41)}
            var str_ind$1=str_ind$0 + 2 | 0,str_ind$0=str_ind$1;
            continue}
          var str_ind$7=str_ind$0 + 1 | 0,str_ind$0=str_ind$7;
          continue}}
      function parse_magic_size(str_ind,end_ind)
       {try
         {var
           str_ind_1=parse_spaces(str_ind,end_ind),
           match$2=caml_string_get(str,str_ind_1),
           switch$0=0;
          if(48 <= match$2)
           {if(! (58 <= match$2))switch$0 = 1}
          else
           if(45 === match$2)switch$0 = 1;
          if(switch$0)
           {var
             match$3=parse_integer(str_ind_1,end_ind),
             size=match$3[2],
             str_ind_2=match$3[1],
             str_ind_3=parse_spaces(str_ind_2,end_ind);
            if(62 !== caml_string_get(str,str_ind_3))throw Not_found;
            var
             s=sub$0(str,str_ind - 2 | 0,(str_ind_3 - str_ind | 0) + 3 | 0),
             _qV_=[0,[0,str_ind_3 + 1 | 0,[1,s,size]]]}
          else
           var _qV_=0;
          var _qU_=_qV_}
        catch(_qW_)
         {_qW_ = caml_wrap_exception(_qW_);
          if(_qW_ !== Not_found && _qW_[1] !== Failure)throw _qW_;
          var _qU_=0}
        if(_qU_)
         {var
           match=_qU_[1],
           formatting_lit=match[2],
           next_ind=match[1],
           match$0=parse(next_ind,end_ind),
           fmt_rest=match$0[1];
          return [0,[17,formatting_lit,fmt_rest]]}
        var match$1=parse(str_ind,end_ind),fmt_rest$0=match$1[1];
        return [0,[17,_aP_,fmt_rest$0]]}
      function parse_good_break(str_ind,end_ind)
       {try
         {var
           _qN_=str_ind === end_ind?1:0,
           _qO_=_qN_ || (60 !== caml_string_get(str,str_ind)?1:0);
          if(_qO_)throw Not_found;
          var
           str_ind_1=parse_spaces(str_ind + 1 | 0,end_ind),
           match$0=caml_string_get(str,str_ind_1),
           switch$0=0;
          if(48 <= match$0)
           {if(! (58 <= match$0))switch$0 = 1}
          else
           if(45 === match$0)switch$0 = 1;
          if(! switch$0)throw Not_found;
          var
           match$1=parse_integer(str_ind_1,end_ind),
           width=match$1[2],
           str_ind_2=match$1[1],
           str_ind_3=parse_spaces(str_ind_2,end_ind),
           match$2=caml_string_get(str,str_ind_3),
           switcher=match$2 - 45 | 0,
           switch$1=0;
          if(12 < switcher >>> 0)
           if(17 === switcher)
            var
             s=sub$0(str,str_ind - 2 | 0,(str_ind_3 - str_ind | 0) + 3 | 0),
             _qP_=[0,s,width,0],
             _qQ_=str_ind_3 + 1 | 0,
             formatting_lit$0=_qP_,
             next_ind=_qQ_;
           else
            switch$1 = 1;
          else
           {var switcher$0=switcher - 1 | 0;
            if(1 < switcher$0 >>> 0)
             {var
               match$3=parse_integer(str_ind_3,end_ind),
               offset=match$3[2],
               str_ind_4=match$3[1],
               str_ind_5=parse_spaces(str_ind_4,end_ind);
              if(62 !== caml_string_get(str,str_ind_5))throw Not_found;
              var
               s$0=
                sub$0(str,str_ind - 2 | 0,(str_ind_5 - str_ind | 0) + 3 | 0),
               _qR_=[0,s$0,width,offset],
               _qS_=str_ind_5 + 1 | 0,
               formatting_lit$0=_qR_,
               next_ind=_qS_}
            else
             switch$1 = 1}
          if(switch$1)throw Not_found}
        catch(_qT_)
         {_qT_ = caml_wrap_exception(_qT_);
          if(_qT_ !== Not_found && _qT_[1] !== Failure)throw _qT_;
          var formatting_lit$0=formatting_lit,next_ind=str_ind}
        var match=parse(next_ind,end_ind),fmt_rest=match[1];
        return [0,[17,formatting_lit$0,fmt_rest]]}
      function parse_tag(is_open_tag,str_ind,end_ind)
       {try
         {if(str_ind === end_ind)throw Not_found;
          var match$0=caml_string_get(str,str_ind);
          if(60 === match$0)
           {var ind=index_from$0(str,str_ind + 1 | 0,62);
            if(end_ind <= ind)throw Not_found;
            var
             sub_str=sub$0(str,str_ind,(ind - str_ind | 0) + 1 | 0),
             match$1=parse(ind + 1 | 0,end_ind),
             fmt_rest$0=match$1[1],
             match$2=parse(str_ind,ind + 1 | 0),
             sub_fmt=match$2[1],
             sub_format$0=[0,sub_fmt,sub_str],
             formatting$0=is_open_tag?[0,sub_format$0]:[1,sub_format$0],
             _qL_=[0,[18,formatting$0,fmt_rest$0]];
            return _qL_}
          throw Not_found}
        catch(_qM_)
         {_qM_ = caml_wrap_exception(_qM_);
          if(_qM_ === Not_found)
           {var
             match=parse(str_ind,end_ind),
             fmt_rest=match[1],
             formatting=is_open_tag?[0,sub_format]:[1,sub_format];
            return [0,[18,formatting,fmt_rest]]}
          throw _qM_}}
      function parse_flags(pct_ind,str_ind,end_ind,ign)
       {var zero=[0,0],minus=[0,0],plus=[0,0],space=[0,0],hash=[0,0];
        function set_flag(str_ind,flag)
         {var _qI_=flag[1],_qJ_=_qI_?1 - legacy_behavior$0:_qI_;
          if(_qJ_)
           {var _qK_=caml_string_get(str,str_ind);
            caml_call3(failwith_message(_aB_),str,str_ind,_qK_)}
          flag[1] = 1;
          return 0}
        var str_ind$0=str_ind;
        for(;;)
         {if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
          var match=caml_string_get(str,str_ind$0),switcher=match - 32 | 0;
          if(! (16 < switcher >>> 0))
           switch(switcher)
            {case 0:
              set_flag(str_ind$0,space);
              var str_ind$1=str_ind$0 + 1 | 0,str_ind$0=str_ind$1;
              continue;
             case 3:
              set_flag(str_ind$0,hash);
              var str_ind$2=str_ind$0 + 1 | 0,str_ind$0=str_ind$2;
              continue;
             case 11:
              set_flag(str_ind$0,plus);
              var str_ind$3=str_ind$0 + 1 | 0,str_ind$0=str_ind$3;
              continue;
             case 13:
              set_flag(str_ind$0,minus);
              var str_ind$4=str_ind$0 + 1 | 0,str_ind$0=str_ind$4;
              continue;
             case 16:
              set_flag(str_ind$0,zero);
              var str_ind$5=str_ind$0 + 1 | 0,str_ind$0=str_ind$5;
              continue
             }
          var
           _qD_=space[1],
           _qE_=hash[1],
           _qF_=plus[1],
           _qG_=minus[1],
           _qH_=zero[1];
          if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
          var
           padty=
            _qH_
             ?_qG_
               ?legacy_behavior$0
                 ?0
                 :incompatible_flag(pct_ind,str_ind$0,45,cst_0)
               :2
             :_qG_?0:1,
           match$0=caml_string_get(str,str_ind$0);
          if(48 <= match$0)
           {if(! (58 <= match$0))
             {var
               match$1=parse_positive(str_ind$0,end_ind,0),
               width=match$1[2],
               new_ind=match$1[1];
              return parse_after_padding
                      (pct_ind,
                       new_ind,
                       end_ind,
                       _qG_,
                       _qF_,
                       _qE_,
                       _qD_,
                       ign,
                       [0,padty,width])}}
          else
           if(42 === match$0)
            return parse_after_padding
                    (pct_ind,
                     str_ind$0 + 1 | 0,
                     end_ind,
                     _qG_,
                     _qF_,
                     _qE_,
                     _qD_,
                     ign,
                     [1,padty]);
          switch(padty)
           {case 0:
             if(1 - legacy_behavior$0)
              invalid_format_without(str_ind$0 - 1 | 0,45,cst_padding);
             return parse_after_padding
                     (pct_ind,str_ind$0,end_ind,_qG_,_qF_,_qE_,_qD_,ign,0);
            case 1:
             return parse_after_padding
                     (pct_ind,str_ind$0,end_ind,_qG_,_qF_,_qE_,_qD_,ign,0);
            default:
             return parse_after_padding
                     (pct_ind,str_ind$0,end_ind,_qG_,_qF_,_qE_,_qD_,ign,_aC_)}}}
      function parse_after_padding
       (pct_ind,str_ind,end_ind,minus,plus,hash,space,ign,pad)
       {if(str_ind === end_ind)unexpected_end_of_format(end_ind);
        var symb=caml_string_get(str,str_ind);
        if(46 === symb)
         {var str_ind$0=str_ind + 1 | 0;
          if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
          var
           parse_literal=
            function(minus,str_ind)
             {var
               match=parse_positive(str_ind,end_ind,0),
               prec=match[2],
               new_ind=match[1];
              return parse_after_precision
                      (pct_ind,
                       new_ind,
                       end_ind,
                       minus,
                       plus,
                       hash,
                       space,
                       ign,
                       pad,
                       [0,prec])},
           symb$0=caml_string_get(str,str_ind$0);
          if(48 <= symb$0)
           {if(! (58 <= symb$0))return parse_literal(minus,str_ind$0)}
          else
           if(42 <= symb$0)
            {var switcher=symb$0 - 42 | 0;
             switch(switcher)
              {case 0:
                return parse_after_precision
                        (pct_ind,
                         str_ind$0 + 1 | 0,
                         end_ind,
                         minus,
                         plus,
                         hash,
                         space,
                         ign,
                         pad,
                         1);
               case 1:
               case 3:
                if(legacy_behavior$0)
                 {var
                   _qC_=str_ind$0 + 1 | 0,
                   minus$0=minus || (45 === symb$0?1:0);
                  return parse_literal(minus$0,_qC_)}
                break
               }}
          return legacy_behavior$0
                  ?parse_after_precision
                    (pct_ind,
                     str_ind$0,
                     end_ind,
                     minus,
                     plus,
                     hash,
                     space,
                     ign,
                     pad,
                     _aD_)
                  :invalid_format_without(str_ind$0 - 1 | 0,46,cst_precision)}
        return parse_conversion
                (pct_ind,
                 str_ind + 1 | 0,
                 end_ind,
                 plus,
                 hash,
                 space,
                 ign,
                 pad,
                 0,
                 pad,
                 symb)}
      function parse_after_precision
       (pct_ind,str_ind,end_ind,minus,plus,hash,space,ign,pad,match)
       {if(str_ind === end_ind)unexpected_end_of_format(end_ind);
        function parse_conv(padprec)
         {return parse_conversion
                  (pct_ind,
                   str_ind + 1 | 0,
                   end_ind,
                   plus,
                   hash,
                   space,
                   ign,
                   pad,
                   match,
                   padprec,
                   caml_string_get(str,str_ind))}
        if(typeof pad === "number")
         {if(typeof match === "number" && ! match)return parse_conv(0);
          if(minus)
           {if(typeof match === "number")return parse_conv(_aE_);
            var n=match[1];
            return parse_conv([0,0,n])}
          if(typeof match === "number")return parse_conv(_aF_);
          var n$0=match[1];
          return parse_conv([0,1,n$0])}
        return parse_conv(pad)}
      function parse_conversion
       (pct_ind,str_ind,end_ind,plus,hash,space,ign,pad,prec,padprec,symb)
       {var
         plus_used=[0,0],
         hash_used=[0,0],
         space_used=[0,0],
         ign_used=[0,0],
         pad_used=[0,0],
         prec_used=[0,0];
        function get_plus(param){plus_used[1] = 1;return plus}
        function get_hash(param){hash_used[1] = 1;return hash}
        function get_space(param){space_used[1] = 1;return space}
        function get_ign(param){ign_used[1] = 1;return ign}
        function get_pad(param){pad_used[1] = 1;return pad}
        function get_prec(param){prec_used[1] = 1;return prec}
        function get_padprec(param){pad_used[1] = 1;return padprec}
        function get_int_pad(param)
         {var pad=get_pad(0),match=get_prec(0);
          if(typeof match === "number" && ! match)return pad;
          if(typeof pad === "number")
           return 0;
          else
           {if(0 === pad[0])
             {if(2 <= pad[1])
               {var n=pad[2];
                return legacy_behavior$0
                        ?[0,1,n]
                        :incompatible_flag(pct_ind,str_ind,48,cst_precision$0)}
              return pad}
            return 2 <= pad[1]
                    ?legacy_behavior$0
                      ?_aG_
                      :incompatible_flag(pct_ind,str_ind,48,cst_precision$1)
                    :pad}}
        function check_no_0(symb,pad)
         {if(typeof pad === "number")
           return pad;
          else
           {if(0 === pad[0])
             {if(2 <= pad[1])
               {var width=pad[2];
                return legacy_behavior$0
                        ?[0,1,width]
                        :incompatible_flag(pct_ind,str_ind,symb,cst_0$0)}
              return pad}
            return 2 <= pad[1]
                    ?legacy_behavior$0
                      ?_aH_
                      :incompatible_flag(pct_ind,str_ind,symb,cst_0$1)
                    :pad}}
        function opt_of_pad(c,pad)
         {if(typeof pad === "number")
           return 0;
          else
           {if(0 === pad[0])
             switch(pad[1])
              {case 0:
                var width=pad[2];
                return legacy_behavior$0
                        ?[0,width]
                        :incompatible_flag(pct_ind,str_ind,c,cst$38);
               case 1:var width$0=pad[2];return [0,width$0];
               default:
                var width$1=pad[2];
                return legacy_behavior$0
                        ?[0,width$1]
                        :incompatible_flag(pct_ind,str_ind,c,cst_0$2)}
            return incompatible_flag(pct_ind,str_ind,c,cst$39)}}
        function get_pad_opt(c){return opt_of_pad(c,get_pad(0))}
        function get_padprec_opt(c){return opt_of_pad(c,get_padprec(0))}
        var switch$0=0;
        if(124 <= symb)
         switch$0 = 1;
        else
         switch(symb)
          {case 33:
            var
             match$6=parse(str_ind,end_ind),
             fmt_rest$5=match$6[1],
             fmt_result=[0,[10,fmt_rest$5]];
            break;
           case 40:
            var
             sub_end=search_subformat_end(str_ind,end_ind,41),
             match$8=parse(sub_end + 2 | 0,end_ind),
             fmt_rest$7=match$8[1],
             match$9=parse(str_ind,sub_end),
             sub_fmt=match$9[1],
             sub_fmtty=fmtty_of_fmt(sub_fmt);
            if(get_ign(0))
             var
              ignored$2=[9,get_pad_opt(95),sub_fmtty],
              _p$_=[0,[23,ignored$2,fmt_rest$7]];
            else
             var _p$_=[0,[14,get_pad_opt(40),sub_fmtty,fmt_rest$7]];
            var fmt_result=_p$_;
            break;
           case 44:var fmt_result=parse(str_ind,end_ind);break;
           case 67:
            var
             match$12=parse(str_ind,end_ind),
             fmt_rest$10=match$12[1],
             _qb_=get_ign(0)?[0,[23,1,fmt_rest$10]]:[0,[1,fmt_rest$10]],
             fmt_result=_qb_;
            break;
           case 78:
            var
             match$16=parse(str_ind,end_ind),
             fmt_rest$14=match$16[1],
             counter$0=2;
            if(get_ign(0))
             var ignored$6=[11,counter$0],_qh_=[0,[23,ignored$6,fmt_rest$14]];
            else
             var _qh_=[0,[21,counter$0,fmt_rest$14]];
            var fmt_result=_qh_;
            break;
           case 83:
            var
             pad$6=check_no_0(symb,get_padprec(0)),
             match$17=parse(str_ind,end_ind),
             fmt_rest$15=match$17[1];
            if(get_ign(0))
             var
              ignored$7=[1,get_padprec_opt(95)],
              _qi_=[0,[23,ignored$7,fmt_rest$15]];
            else
             var
              match$18=make_padding_fmt_ebb(pad$6,fmt_rest$15),
              fmt_rest$16=match$18[2],
              pad$7=match$18[1],
              _qi_=[0,[3,pad$7,fmt_rest$16]];
            var fmt_result=_qi_;
            break;
           case 91:
            if(str_ind === end_ind)unexpected_end_of_format(end_ind);
            var
             char_set=create_char_set(0),
             add_char=function(c){return add_in_char_set(char_set,c)},
             add_range=
              function(c$0,c)
               {if(! (c < c$0))
                 {var i=c$0;
                  for(;;)
                   {add_in_char_set(char_set,char_of_int(i));
                    var _qB_=i + 1 | 0;
                    if(c !== i){var i=_qB_;continue}
                    break}}
                return 0},
             fail_single_percent=
              function(str_ind)
               {return caml_call2(failwith_message(_aQ_),str,str_ind)},
             parse_char_set_content=
              function(counter,str_ind,end_ind)
               {var str_ind$0=str_ind;
                for(;;)
                 {if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
                  var c=caml_string_get(str,str_ind$0);
                  if(45 === c)
                   {add_char(45);
                    var str_ind$1=str_ind$0 + 1 | 0,str_ind$0=str_ind$1;
                    continue}
                  if(93 === c)return str_ind$0 + 1 | 0;
                  var _qA_=str_ind$0 + 1 | 0;
                  if(counter < 50)
                   {var counter$0=counter + 1 | 0;
                    return parse_char_set_after_char$0(counter$0,_qA_,end_ind,c)}
                  return caml_trampoline_return
                          (parse_char_set_after_char$0,[0,_qA_,end_ind,c])}},
             parse_char_set_after_char$0=
              function(counter,str_ind,end_ind,c)
               {var str_ind$0=str_ind,c$0=c;
                for(;;)
                 {if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
                  var c$1=caml_string_get(str,str_ind$0),switch$0=0;
                  if(46 <= c$1)
                   {if(64 === c$1)
                     switch$0 = 1;
                    else
                     if(93 === c$1){add_char(c$0);return str_ind$0 + 1 | 0}}
                  else
                   if(37 === c$1)
                    switch$0 = 1;
                   else
                    if(45 <= c$1)
                     {var str_ind$2=str_ind$0 + 1 | 0;
                      if(str_ind$2 === end_ind)unexpected_end_of_format(end_ind);
                      var c$2=caml_string_get(str,str_ind$2);
                      if(37 === c$2)
                       {if((str_ind$2 + 1 | 0) === end_ind)
                         unexpected_end_of_format(end_ind);
                        var c$3=caml_string_get(str,str_ind$2 + 1 | 0);
                        if(37 !== c$3 && 64 !== c$3)
                         return fail_single_percent(str_ind$2);
                        add_range(c$0,c$3);
                        var _qy_=str_ind$2 + 2 | 0;
                        if(counter < 50)
                         {var counter$2=counter + 1 | 0;
                          return parse_char_set_content(counter$2,_qy_,end_ind)}
                        return caml_trampoline_return
                                (parse_char_set_content,[0,_qy_,end_ind])}
                      if(93 === c$2)
                       {add_char(c$0);add_char(45);return str_ind$2 + 1 | 0}
                      add_range(c$0,c$2);
                      var _qz_=str_ind$2 + 1 | 0;
                      if(counter < 50)
                       {var counter$1=counter + 1 | 0;
                        return parse_char_set_content(counter$1,_qz_,end_ind)}
                      return caml_trampoline_return
                              (parse_char_set_content,[0,_qz_,end_ind])}
                  if(switch$0 && 37 === c$0)
                   {add_char(c$1);
                    var _qx_=str_ind$0 + 1 | 0;
                    if(counter < 50)
                     {var counter$0=counter + 1 | 0;
                      return parse_char_set_content(counter$0,_qx_,end_ind)}
                    return caml_trampoline_return
                            (parse_char_set_content,[0,_qx_,end_ind])}
                  if(37 === c$0)fail_single_percent(str_ind$0);
                  add_char(c$0);
                  var str_ind$1=str_ind$0 + 1 | 0,str_ind$0=str_ind$1,c$0=c$1;
                  continue}},
             parse_char_set_after_char=
              function(str_ind,end_ind,c)
               {return caml_trampoline
                        (parse_char_set_after_char$0(0,str_ind,end_ind,c))};
            if(str_ind === end_ind)unexpected_end_of_format(end_ind);
            var match$31=caml_string_get(str,str_ind);
            if(94 === match$31)
             var str_ind$0=str_ind + 1 | 0,reverse=1,str_ind$1=str_ind$0;
            else
             var reverse=0,str_ind$1=str_ind;
            if(str_ind$1 === end_ind)unexpected_end_of_format(end_ind);
            var
             c=caml_string_get(str,str_ind$1),
             next_ind=parse_char_set_after_char(str_ind$1 + 1 | 0,end_ind,c),
             char_set$0=freeze_char_set(char_set),
             char_set$1=reverse?rev_char_set(char_set$0):char_set$0,
             match$21=parse(next_ind,end_ind),
             fmt_rest$19=match$21[1];
            if(get_ign(0))
             var
              ignored$9=[10,get_pad_opt(95),char_set$1],
              _qn_=[0,[23,ignored$9,fmt_rest$19]];
            else
             var _qn_=[0,[20,get_pad_opt(91),char_set$1,fmt_rest$19]];
            var fmt_result=_qn_;
            break;
           case 97:
            var
             match$22=parse(str_ind,end_ind),
             fmt_rest$20=match$22[1],
             fmt_result=[0,[15,fmt_rest$20]];
            break;
           case 99:
            var
             char_format=
              function(fmt_rest)
               {return get_ign(0)?[0,[23,0,fmt_rest]]:[0,[0,fmt_rest]]},
             match$23=parse(str_ind,end_ind),
             fmt_rest$21=match$23[1],
             match$24=get_pad_opt(99);
            if(match$24)
             {if(0 === match$24[1])
               var
                _qo_=get_ign(0)?[0,[23,3,fmt_rest$21]]:[0,[22,fmt_rest$21]],
                _qp_=_qo_;
              else
               var
                _qp_=
                 legacy_behavior$0
                  ?char_format(fmt_rest$21)
                  :invalid_format_message
                    (str_ind,cst_non_zero_widths_are_unsupp);
              var _qq_=_qp_}
            else
             var _qq_=char_format(fmt_rest$21);
            var fmt_result=_qq_;
            break;
           case 114:
            var
             match$25=parse(str_ind,end_ind),
             fmt_rest$22=match$25[1],
             _qr_=get_ign(0)?[0,[23,2,fmt_rest$22]]:[0,[19,fmt_rest$22]],
             fmt_result=_qr_;
            break;
           case 115:
            var
             pad$9=check_no_0(symb,get_padprec(0)),
             match$26=parse(str_ind,end_ind),
             fmt_rest$23=match$26[1];
            if(get_ign(0))
             var
              ignored$10=[0,get_padprec_opt(95)],
              _qs_=[0,[23,ignored$10,fmt_rest$23]];
            else
             var
              match$27=make_padding_fmt_ebb(pad$9,fmt_rest$23),
              fmt_rest$24=match$27[2],
              pad$10=match$27[1],
              _qs_=[0,[2,pad$10,fmt_rest$24]];
            var fmt_result=_qs_;
            break;
           case 116:
            var
             match$28=parse(str_ind,end_ind),
             fmt_rest$25=match$28[1],
             fmt_result=[0,[16,fmt_rest$25]];
            break;
           case 123:
            var
             sub_end$0=search_subformat_end(str_ind,end_ind,125),
             match$29=parse(str_ind,sub_end$0),
             sub_fmt$0=match$29[1],
             match$30=parse(sub_end$0 + 2 | 0,end_ind),
             fmt_rest$26=match$30[1],
             sub_fmtty$0=fmtty_of_fmt(sub_fmt$0);
            if(get_ign(0))
             var
              ignored$11=[8,get_pad_opt(95),sub_fmtty$0],
              _qt_=[0,[23,ignored$11,fmt_rest$26]];
            else
             var _qt_=[0,[13,get_pad_opt(123),sub_fmtty$0,fmt_rest$26]];
            var fmt_result=_qt_;
            break;
           case 66:
           case 98:
            var
             pad$3=check_no_0(symb,get_padprec(0)),
             match$10=parse(str_ind,end_ind),
             fmt_rest$8=match$10[1];
            if(get_ign(0))
             var
              ignored$3=[7,get_padprec_opt(95)],
              _qa_=[0,[23,ignored$3,fmt_rest$8]];
            else
             var
              match$11=make_padding_fmt_ebb(pad$3,fmt_rest$8),
              fmt_rest$9=match$11[2],
              pad$4=match$11[1],
              _qa_=[0,[9,pad$4,fmt_rest$9]];
            var fmt_result=_qa_;
            break;
           case 37:
           case 64:
            var
             match$7=parse(str_ind,end_ind),
             fmt_rest$6=match$7[1],
             fmt_result=[0,[12,symb,fmt_rest$6]];
            break;
           case 76:
           case 108:
           case 110:
            var switch$1=0;
            if(str_ind !== end_ind)
             {var
               symb$0=caml_string_get(str,str_ind),
               _qu_=symb$0 - 88 | 0,
               switch$2=0;
              if(! (32 < _qu_ >>> 0))
               switch(_qu_)
                {case 0:
                 case 12:
                 case 17:
                 case 23:
                 case 29:
                 case 32:var _qg_=1;switch$2 = 1;break
                 }
              if(! switch$2)var _qg_=0;
              if(_qg_){switch$0 = 1;switch$1 = 1}}
            if(! switch$1)
             {var
               match$15=parse(str_ind,end_ind),
               fmt_rest$13=match$15[1],
               switch$3=0;
              if(108 <= symb)
               {if(! (111 <= symb))
                 {var switcher$0=symb - 108 | 0;
                  switch(switcher$0)
                   {case 0:var counter=0;switch$3 = 1;break;
                    case 1:break;
                    default:var counter=1;switch$3 = 1}}}
              else
               if(76 === symb){var counter=2;switch$3 = 1}
              if(! switch$3)throw [0,Assert_failure,_aU_];
              if(get_ign(0))
               var ignored$5=[11,counter],_qf_=[0,[23,ignored$5,fmt_rest$13]];
              else
               var _qf_=[0,[21,counter,fmt_rest$13]];
              var fmt_result=_qf_}
            break;
           case 32:
           case 35:
           case 43:
           case 45:
           case 95:
            var
             fmt_result=
              caml_call3(failwith_message(_aL_),str,pct_ind,symb);
            break;
           case 88:
           case 100:
           case 105:
           case 111:
           case 117:
           case 120:
            var
             _qj_=get_space(0),
             _qk_=get_hash(0),
             iconv$2=
              compute_int_conv(pct_ind,str_ind,get_plus(0),_qk_,_qj_,symb),
             match$19=parse(str_ind,end_ind),
             fmt_rest$17=match$19[1];
            if(get_ign(0))
             var
              ignored$8=[2,iconv$2,get_pad_opt(95)],
              _ql_=[0,[23,ignored$8,fmt_rest$17]];
            else
             var
              _qm_=get_prec(0),
              match$20=make_padprec_fmt_ebb(get_int_pad(0),_qm_,fmt_rest$17),
              fmt_rest$18=match$20[3],
              prec$4=match$20[2],
              pad$8=match$20[1],
              _ql_=[0,[4,iconv$2,pad$8,prec$4,fmt_rest$18]];
            var fmt_result=_ql_;
            break;
           case 69:
           case 70:
           case 71:
           case 72:
           case 101:
           case 102:
           case 103:
           case 104:
            var
             space$1=get_space(0),
             hash$1=get_hash(0),
             plus$2=get_plus(0),
             flag=
              plus$2
               ?space$1
                 ?legacy_behavior$0
                   ?1
                   :incompatible_flag(pct_ind,str_ind,32,cst$50)
                 :1
               :space$1?2:0,
             switch$4=0;
            if(73 <= symb)
             {var switcher$1=symb - 101 | 0;
              if(3 < switcher$1 >>> 0)
               switch$4 = 1;
              else
               {switch(switcher$1)
                 {case 0:var _qv_=1;break;
                  case 1:var _qv_=0;break;
                  case 2:var _qv_=3;break;
                  default:var _qv_=6}
                var kind=_qv_}}
            else
             if(69 <= symb)
              {var switcher$2=symb - 69 | 0,switch$5=0;
               switch(switcher$2)
                {case 0:var _qw_=2;break;
                 case 1:switch$4 = 1;switch$5 = 1;break;
                 case 2:var _qw_=4;break;
                 default:var _qw_=7}
               if(! switch$5)var kind=_qw_}
             else
              switch$4 = 1;
            if(switch$4)
             {var switch$6=0;
              if(hash$1)
               if(70 === symb)var kind=8;else switch$6 = 1;
              else
               if(70 === symb)var kind=5;else switch$6 = 1;
              if(switch$6)throw [0,Assert_failure,_aW_]}
            var
             fconv=[0,flag,kind],
             match$13=parse(str_ind,end_ind),
             fmt_rest$11=match$13[1];
            if(get_ign(0))
             {var match=get_prec(0);
              if(typeof match === "number")
               var _qc_=match?incompatible_flag(pct_ind,str_ind,95,cst$40):0;
              else
               var ndec=match[1],_qc_=[0,ndec];
              var
               ignored$4=[6,get_pad_opt(95),_qc_],
               _qd_=[0,[23,ignored$4,fmt_rest$11]]}
            else
             var
              _qe_=get_prec(0),
              match$14=make_padprec_fmt_ebb(get_pad(0),_qe_,fmt_rest$11),
              fmt_rest$12=match$14[3],
              prec$3=match$14[2],
              pad$5=match$14[1],
              _qd_=[0,[8,fconv,pad$5,prec$3,fmt_rest$12]];
            var fmt_result=_qd_;
            break;
           default:switch$0 = 1}
        if(switch$0)
         {var switch$7=0;
          if(108 <= symb)
           if(111 <= symb)
            switch$7 = 1;
           else
            {var switcher=symb - 108 | 0,switch$8=0;
             switch(switcher)
              {case 0:
                var
                 _pV_=caml_string_get(str,str_ind),
                 _pW_=get_space(0),
                 _pX_=get_hash(0),
                 iconv=
                  compute_int_conv
                   (pct_ind,str_ind + 1 | 0,get_plus(0),_pX_,_pW_,_pV_),
                 match$0=parse(str_ind + 1 | 0,end_ind),
                 fmt_rest=match$0[1];
                if(get_ign(0))
                 var
                  ignored=[3,iconv,get_pad_opt(95)],
                  _pY_=[0,[23,ignored,fmt_rest]];
                else
                 var
                  _p0_=get_prec(0),
                  match$1=make_padprec_fmt_ebb(get_int_pad(0),_p0_,fmt_rest),
                  fmt_rest$0=match$1[3],
                  prec$0=match$1[2],
                  pad$0=match$1[1],
                  _pY_=[0,[5,iconv,pad$0,prec$0,fmt_rest$0]];
                var _pZ_=_pY_;
                break;
               case 1:switch$7 = 1;switch$8 = 1;break;
               default:
                var
                 _p1_=caml_string_get(str,str_ind),
                 _p2_=get_space(0),
                 _p3_=get_hash(0),
                 iconv$0=
                  compute_int_conv
                   (pct_ind,str_ind + 1 | 0,get_plus(0),_p3_,_p2_,_p1_),
                 match$2=parse(str_ind + 1 | 0,end_ind),
                 fmt_rest$1=match$2[1];
                if(get_ign(0))
                 var
                  ignored$0=[4,iconv$0,get_pad_opt(95)],
                  _p4_=[0,[23,ignored$0,fmt_rest$1]];
                else
                 var
                  _p5_=get_prec(0),
                  match$3=make_padprec_fmt_ebb(get_int_pad(0),_p5_,fmt_rest$1),
                  fmt_rest$2=match$3[3],
                  prec$1=match$3[2],
                  pad$1=match$3[1],
                  _p4_=[0,[6,iconv$0,pad$1,prec$1,fmt_rest$2]];
                var _pZ_=_p4_}
             if(! switch$8)var fmt_result=_pZ_}
          else
           if(76 === symb)
            {var
              _p6_=caml_string_get(str,str_ind),
              _p7_=get_space(0),
              _p8_=get_hash(0),
              iconv$1=
               compute_int_conv
                (pct_ind,str_ind + 1 | 0,get_plus(0),_p8_,_p7_,_p6_),
              match$4=parse(str_ind + 1 | 0,end_ind),
              fmt_rest$3=match$4[1];
             if(get_ign(0))
              var
               ignored$1=[5,iconv$1,get_pad_opt(95)],
               _p9_=[0,[23,ignored$1,fmt_rest$3]];
             else
              var
               _p__=get_prec(0),
               match$5=make_padprec_fmt_ebb(get_int_pad(0),_p__,fmt_rest$3),
               fmt_rest$4=match$5[3],
               prec$2=match$5[2],
               pad$2=match$5[1],
               _p9_=[0,[7,iconv$1,pad$2,prec$2,fmt_rest$4]];
             var fmt_result=_p9_}
           else
            switch$7 = 1;
          if(switch$7)
           var
            fmt_result=
             caml_call3(failwith_message(_aI_),str,str_ind - 1 | 0,symb)}
        if(1 - legacy_behavior$0)
         {var _pM_=1 - plus_used[1],plus$0=_pM_?plus:_pM_;
          if(plus$0)incompatible_flag(pct_ind,str_ind,symb,cst$41);
          var _pN_=1 - hash_used[1],hash$0=_pN_?hash:_pN_;
          if(hash$0)incompatible_flag(pct_ind,str_ind,symb,cst$42);
          var _pO_=1 - space_used[1],space$0=_pO_?space:_pO_;
          if(space$0)incompatible_flag(pct_ind,str_ind,symb,cst$43);
          var _pP_=1 - pad_used[1],_pQ_=_pP_?caml_notequal([0,pad],_aJ_):_pP_;
          if(_pQ_)incompatible_flag(pct_ind,str_ind,symb,cst_padding$0);
          var
           _pR_=1 - prec_used[1],
           _pS_=_pR_?caml_notequal([0,prec],_aK_):_pR_;
          if(_pS_)
           {var _pT_=ign?95:symb;
            incompatible_flag(pct_ind,str_ind,_pT_,cst_precision$2)}
          var plus$1=ign?plus:ign;
          if(plus$1)incompatible_flag(pct_ind,str_ind,95,cst$44)}
        var _pU_=1 - ign_used[1],ign$0=_pU_?ign:_pU_;
        if(ign$0)
         {var switch$9=0;
          if(38 <= symb)
           {if(44 !== symb && 64 !== symb)switch$9 = 1}
          else
           if(33 !== symb && ! (37 <= symb))switch$9 = 1;
          var switch$10=0;
          if(switch$9 || ! legacy_behavior$0)switch$10 = 1;
          if(switch$10)incompatible_flag(pct_ind,str_ind,symb,cst$45)}
        return fmt_result}
      function parse(lit_start,end_ind)
       {var str_ind=lit_start;
        for(;;)
         {if(str_ind === end_ind)return add_literal(lit_start,str_ind,0);
          var match=caml_string_get(str,str_ind);
          if(37 === match)
           {var str_ind$2=str_ind + 1 | 0;
            if(str_ind$2 === end_ind)unexpected_end_of_format(end_ind);
            var
             match$1=caml_string_get(str,str_ind$2),
             _pL_=
              95 === match$1
               ?parse_flags(str_ind,str_ind$2 + 1 | 0,end_ind,1)
               :parse_flags(str_ind,str_ind$2,end_ind,0),
             fmt_rest=_pL_[1];
            return add_literal(lit_start,str_ind,fmt_rest)}
          if(64 === match)
           {var str_ind$0=str_ind + 1 | 0;
            if(str_ind$0 === end_ind)
             var match$0=_aM_;
            else
             {var c=caml_string_get(str,str_ind$0),switch$0=0;
              if(65 <= c)
               if(94 <= c)
                {var switcher=c - 123 | 0;
                 if(2 < switcher >>> 0)
                  switch$0 = 1;
                 else
                  switch(switcher)
                   {case 0:
                     var match$0=parse_tag(1,str_ind$0 + 1 | 0,end_ind);break;
                    case 1:switch$0 = 1;break;
                    default:
                     var
                      match$3=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$2=match$3[1],
                      match$0=[0,[17,1,fmt_rest$2]]}}
               else
                if(91 <= c)
                 {var switcher$0=c - 91 | 0;
                  switch(switcher$0)
                   {case 0:
                     var match$0=parse_tag(0,str_ind$0 + 1 | 0,end_ind);break;
                    case 1:switch$0 = 1;break;
                    default:
                     var
                      match$4=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$3=match$4[1],
                      match$0=[0,[17,0,fmt_rest$3]]}}
                else
                 switch$0 = 1;
              else
               if(10 === c)
                var
                 match$5=parse(str_ind$0 + 1 | 0,end_ind),
                 fmt_rest$4=match$5[1],
                 match$0=[0,[17,3,fmt_rest$4]];
               else
                if(32 <= c)
                 {var switcher$1=c - 32 | 0;
                  switch(switcher$1)
                   {case 0:
                     var
                      match$6=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$5=match$6[1],
                      match$0=[0,[17,_aN_,fmt_rest$5]];
                     break;
                    case 5:
                     var switch$1=0;
                     if
                      ((str_ind$0 + 1 | 0)
                       <
                       end_ind
                       &&
                       37
                       ===
                       caml_string_get(str,str_ind$0 + 1 | 0))
                      {var
                        match$7=parse(str_ind$0 + 2 | 0,end_ind),
                        fmt_rest$6=match$7[1],
                        match$0=[0,[17,6,fmt_rest$6]];
                       switch$1 = 1}
                     if(! switch$1)
                      var
                       match$8=parse(str_ind$0,end_ind),
                       fmt_rest$7=match$8[1],
                       match$0=[0,[12,64,fmt_rest$7]];
                     break;
                    case 12:
                     var
                      match$9=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$8=match$9[1],
                      match$0=[0,[17,_aO_,fmt_rest$8]];
                     break;
                    case 14:
                     var
                      match$10=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$9=match$10[1],
                      match$0=[0,[17,4,fmt_rest$9]];
                     break;
                    case 27:
                     var match$0=parse_good_break(str_ind$0 + 1 | 0,end_ind);
                     break;
                    case 28:
                     var match$0=parse_magic_size(str_ind$0 + 1 | 0,end_ind);
                     break;
                    case 31:
                     var
                      match$11=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$10=match$11[1],
                      match$0=[0,[17,2,fmt_rest$10]];
                     break;
                    case 32:
                     var
                      match$12=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$11=match$12[1],
                      match$0=[0,[17,5,fmt_rest$11]];
                     break;
                    default:switch$0 = 1}}
                else
                 switch$0 = 1;
              if(switch$0)
               var
                match$2=parse(str_ind$0 + 1 | 0,end_ind),
                fmt_rest$1=match$2[1],
                match$0=[0,[17,[2,c],fmt_rest$1]]}
            var fmt_rest$0=match$0[1];
            return add_literal(lit_start,str_ind,fmt_rest$0)}
          var str_ind$1=str_ind + 1 | 0,str_ind=str_ind$1;
          continue}}
      return parse(0,caml_ml_string_length(str))}
    function format_of_string_fmtty(str,fmtty)
     {var match=fmt_ebb_of_string(0,str),fmt=match[1];
      try
       {var _pJ_=[0,type_format(fmt,fmtty),str];return _pJ_}
      catch(_pK_)
       {_pK_ = caml_wrap_exception(_pK_);
        if(_pK_ === Type_mismatch)
         {var _pI_=string_of_fmtty(fmtty);
          return caml_call2(failwith_message(_aY_),str,_pI_)}
        throw _pK_}}
    function format_of_string_format(str,param)
     {var
       str$0=param[2],
       fmt=param[1],
       match=fmt_ebb_of_string(0,str),
       fmt$0=match[1];
      try
       {var _pG_=[0,type_format(fmt$0,fmtty_of_fmt(fmt)),str];return _pG_}
      catch(_pH_)
       {_pH_ = caml_wrap_exception(_pH_);
        if(_pH_ === Type_mismatch)
         return caml_call2(failwith_message(_aZ_),str,str$0);
        throw _pH_}}
    var
     CamlinternalFormat=
      [0,
       is_in_char_set,
       rev_char_set,
       create_char_set,
       add_in_char_set,
       freeze_char_set,
       param_format_of_ignored_format,
       make_printf,
       make_iprintf,
       output_acc,
       bufput_acc,
       strput_acc,
       type_format,
       fmt_ebb_of_string,
       format_of_string_fmtty,
       format_of_string_format,
       char_of_iconv,
       string_of_formatting_lit,
       string_of_fmtty,
       string_of_fmt,
       open_box_of_string,
       symm,
       trans,
       recast];
    caml_register_global(790,CamlinternalFormat,"CamlinternalFormat");
    function kfprintf(k,o,param)
     {var fmt=param[1],_pF_=0;
      return make_printf
              (function(acc){output_acc(o,acc);return caml_call1(k,o)},
               _pF_,
               fmt)}
    function kbprintf(k,b,param)
     {var fmt=param[1],_pE_=0;
      return make_printf
              (function(acc){bufput_acc(b,acc);return caml_call1(k,b)},
               _pE_,
               fmt)}
    function ikfprintf(k,oc,param)
     {var fmt=param[1];return make_iprintf(k,oc,fmt)}
    function fprintf(oc,fmt){return kfprintf(function(_pD_){return 0},oc,fmt)}
    function bprintf(b,fmt){return kbprintf(function(_pC_){return 0},b,fmt)}
    function ifprintf(oc,fmt)
     {return ikfprintf(function(_pB_){return 0},oc,fmt)}
    function ibprintf(b,fmt){return ikfprintf(function(_pA_){return 0},b,fmt)}
    function printf(fmt){return fprintf(stdout,fmt)}
    function eprintf(fmt){return fprintf(stderr,fmt)}
    function ksprintf(k,param)
     {var fmt=param[1];
      function k$0(acc)
       {var buf=create$2(64);
        strput_acc(buf,acc);
        return caml_call1(k,contents(buf))}
      return make_printf(k$0,0,fmt)}
    function sprintf(fmt){return ksprintf(function(s){return s},fmt)}
    var
     Stdlib_printf=
      [0,
       fprintf,
       printf,
       eprintf,
       sprintf,
       bprintf,
       ifprintf,
       ibprintf,
       kfprintf,
       ikfprintf,
       ksprintf,
       kbprintf,
       ikfprintf,
       ksprintf];
    caml_register_global(791,Stdlib_printf,"Stdlib__printf");
    var
     Bad=[248,cst_Stdlib_Arg_Bad,caml_fresh_oo_id(0)],
     Help=[248,cst_Stdlib_Arg_Help,caml_fresh_oo_id(0)],
     Stop=[248,cst_Stdlib_Arg_Stop,caml_fresh_oo_id(0)];
    function assoc3(x,l)
     {var l$0=l;
      for(;;)
       {if(l$0)
         {var match=l$0[1],y2=match[2],y1=match[1];
          if(caml_equal(y1,x))return y2;
          var l$1=l$0[2],l$0=l$1;
          continue}
        throw Not_found}}
    function split$0(s)
     {var
       i=index$0(s,61),
       len=caml_ml_string_length(s),
       _pz_=sub$0(s,i + 1 | 0,len - (i + 1 | 0) | 0);
      return [0,sub$0(s,0,i),_pz_]}
    function make_symlist(prefix,sep,suffix,l)
     {if(l)
       {var t=l[2],h=l[1],_py_=symbol(prefix,h);
        return symbol
                (fold_left$0
                  (function(x,y){return symbol(x,symbol(sep,y))},_py_,t),
                 suffix)}
      return cst_none}
    function help_action(param){throw [0,Stop,_a2_]}
    function add_help(speclist)
     {try
       {assoc3(cst_help$2,speclist);var _pv_=0,_pt_=_pv_}
      catch(_px_)
       {_px_ = caml_wrap_exception(_px_);
        if(_px_ !== Not_found)throw _px_;
        var
         _pt_=
          [0,[0,cst_help,[0,help_action],cst_Display_this_list_of_optio],0]}
      try
       {assoc3(cst_help$1,speclist);var _pu_=0,add2=_pu_}
      catch(_pw_)
       {_pw_ = caml_wrap_exception(_pw_);
        if(_pw_ !== Not_found)throw _pw_;
        var
         add2=
          [0,
           [0,cst_help$0,[0,help_action],cst_Display_this_list_of_optio$0],
           0]}
      return append(speclist,append(_pt_,add2))}
    function usage_b(buf,speclist,errmsg)
     {caml_call1(bprintf(buf,_a3_),errmsg);
      var _pq_=add_help(speclist);
      return iter$2
              (function(param)
                {var
                  doc=param[3],
                  spec=param[2],
                  key=param[1],
                  _pr_=0 < caml_ml_string_length(doc)?1:0;
                 if(_pr_)
                  {if(11 === spec[0])
                    {var l=spec[1],_ps_=make_symlist(cst$53,cst$52,cst$51,l);
                     return caml_call3(bprintf(buf,_a1_),key,_ps_,doc)}
                   return caml_call2(bprintf(buf,_a0_),key,doc)}
                 return _pr_},
               _pq_)}
    function usage_string(speclist,errmsg)
     {var b=create$2(200);usage_b(b,speclist,errmsg);return contents(b)}
    function usage(speclist,errmsg)
     {var _pp_=usage_string(speclist,errmsg);
      return caml_call1(eprintf(_a4_),_pp_)}
    var current=[0,0];
    function bool_of_string_opt$0(x)
     {try
       {var _pn_=[0,bool_of_string(x)];return _pn_}
      catch(_po_)
       {_po_ = caml_wrap_exception(_po_);
        if(_po_[1] === Invalid_argument)return 0;
        throw _po_}}
    function int_of_string_opt$0(x)
     {try
       {var _pl_=[0,caml_int_of_string(x)];return _pl_}
      catch(_pm_)
       {_pm_ = caml_wrap_exception(_pm_);
        if(_pm_[1] === Failure)return 0;
        throw _pm_}}
    function float_of_string_opt(x)
     {try
       {var _pj_=[0,caml_float_of_string(x)];return _pj_}
      catch(_pk_)
       {_pk_ = caml_wrap_exception(_pk_);
        if(_pk_[1] === Failure)return 0;
        throw _pk_}}
    function parse_and_expand_argv_dynamic_
     (allow_expand,current,argv,speclist,anonfun,errmsg)
     {var initpos=current[1];
      function convert_error(error)
       {var
         b=create$2(200),
         progname=
          initpos < argv[1].length - 1
           ?caml_check_bound(argv[1],initpos)[1 + initpos]
           :cst$54;
        switch(error[0])
         {case 0:
           var _pi_=error[1];
           if
            (caml_string_notequal(_pi_,cst_help$3)
             &&
             caml_string_notequal(_pi_,cst_help$4))
            caml_call2(bprintf(b,_a5_),progname,_pi_);
           break;
          case 1:
           var expected=error[3],arg=error[2],opt=error[1];
           caml_call4(bprintf(b,_a8_),progname,arg,opt,expected);
           break;
          case 2:var s=error[1];caml_call2(bprintf(b,_a9_),progname,s);break;
          default:var s$0=error[1];caml_call2(bprintf(b,_a__),progname,s$0)}
        usage_b(b,speclist[1],errmsg);
        if(! caml_equal(error,_a6_) && ! caml_equal(error,_a7_))
         return [0,Bad,contents(b)];
        return [0,Help,contents(b)]}
      current[1]++;
      for(;;)
       {if(current[1] < argv[1].length - 1)
         {try
           {var
             _o9_=current[1],
             s=caml_check_bound(argv[1],_o9_)[1 + _o9_],
             switch$0=0;
            if(1 <= caml_ml_string_length(s) && 45 === caml_string_get(s,0))
             {try
               {var
                 follow$1=0,
                 _o$_=assoc3(s,speclist[1]),
                 follow$0=follow$1,
                 action=_o$_}
              catch(_pg_)
               {_pg_ = caml_wrap_exception(_pg_);
                if(_pg_ !== Not_found)throw _pg_;
                try
                 {var
                   match=split$0(s),
                   arg=match[2],
                   keyword=match[1],
                   follow=[0,arg],
                   _o__=assoc3(keyword,speclist[1])}
                catch(_ph_)
                 {_ph_ = caml_wrap_exception(_ph_);
                  if(_ph_ === Not_found)throw [0,Stop,[0,s]];
                  throw _ph_;
                  var _pa_=_ph_}
                var follow$0=follow,action=_o__,_pb_=_pg_}
              var
               no_arg$0=
                function(s,follow)
                 {function no_arg(param)
                   {if(follow)
                     {var arg=follow[1];throw [0,Stop,[1,s,arg,cst_no_argument]]}
                    return 0}
                  return no_arg},
               no_arg=no_arg$0(s,follow$0),
               get_arg$0=
                function(s,follow)
                 {function get_arg(param)
                   {if(follow){var arg=follow[1];return arg}
                    if((current[1] + 1 | 0) < argv[1].length - 1)
                     {var _pf_=current[1] + 1 | 0;
                      return caml_check_bound(argv[1],_pf_)[1 + _pf_]}
                    throw [0,Stop,[2,s]]}
                  return get_arg},
               get_arg=get_arg$0(s,follow$0),
               consume_arg$0=
                function(follow)
                 {function consume_arg(param)
                   {return follow?0:(current[1]++,0)}
                  return consume_arg},
               consume_arg=consume_arg$0(follow$0),
               treat_action$0=
                function(s,no_arg,get_arg,consume_arg)
                 {function treat_action(param)
                   {switch(param[0])
                     {case 0:var f=param[1];no_arg(0);return caml_call1(f,0);
                      case 1:
                       var
                        f$0=param[1],
                        arg=get_arg(0),
                        match=bool_of_string_opt$0(arg);
                       if(match)
                        {var s$0=match[1];caml_call1(f$0,s$0);return consume_arg(0)}
                       throw [0,Stop,[1,s,arg,cst_a_boolean]];
                      case 2:var r=param[1];no_arg(0);r[1] = 1;return 0;
                      case 3:var r$0=param[1];no_arg(0);r$0[1] = 0;return 0;
                      case 4:
                       var f$1=param[1],arg$0=get_arg(0);
                       caml_call1(f$1,arg$0);
                       return consume_arg(0);
                      case 5:
                       var r$1=param[1];r$1[1] = get_arg(0);return consume_arg(0);
                      case 6:
                       var
                        f$2=param[1],
                        arg$1=get_arg(0),
                        match$0=int_of_string_opt$0(arg$1);
                       if(match$0)
                        {var x=match$0[1];caml_call1(f$2,x);return consume_arg(0)}
                       throw [0,Stop,[1,s,arg$1,cst_an_integer]];
                      case 7:
                       var
                        r$2=param[1],
                        arg$2=get_arg(0),
                        match$1=int_of_string_opt$0(arg$2);
                       if(match$1)
                        {var x$0=match$1[1];r$2[1] = x$0;return consume_arg(0)}
                       throw [0,Stop,[1,s,arg$2,cst_an_integer$0]];
                      case 8:
                       var
                        f$3=param[1],
                        arg$3=get_arg(0),
                        match$2=float_of_string_opt(arg$3);
                       if(match$2)
                        {var x$1=match$2[1];
                         caml_call1(f$3,x$1);
                         return consume_arg(0)}
                       throw [0,Stop,[1,s,arg$3,cst_a_float]];
                      case 9:
                       var
                        r$3=param[1],
                        arg$4=get_arg(0),
                        match$3=float_of_string_opt(arg$4);
                       if(match$3)
                        {var x$2=match$3[1];r$3[1] = x$2;return consume_arg(0)}
                       throw [0,Stop,[1,s,arg$4,cst_a_float$0]];
                      case 10:
                       var specs=param[1];
                       no_arg(0);
                       return iter$2(treat_action,specs);
                      case 11:
                       var f$4=param[2],symb=param[1],arg$5=get_arg(0);
                       if(mem(arg$5,symb))
                        {caml_call1(f$4,arg$5);return consume_arg(0)}
                       throw [0,
                              Stop,
                              [1,
                               s,
                               arg$5,
                               symbol(cst_one_of,make_symlist(cst$57,cst$56,cst$55,symb))]];
                      case 12:
                       var f$5=param[1];
                       no_arg(0);
                       for(;;)
                        {if(current[1] < (argv[1].length - 1 - 1 | 0))
                          {var _pc_=current[1] + 1 | 0;
                           caml_call1(f$5,caml_check_bound(argv[1],_pc_)[1 + _pc_]);
                           consume_arg(0);
                           continue}
                         return 0}
                      case 13:
                       var f$6=param[1];
                       no_arg(0);
                       var acc=[0,0];
                       for(;;)
                        {if(current[1] < (argv[1].length - 1 - 1 | 0))
                          {var _pe_=current[1] + 1 | 0,_pd_=acc[1];
                           acc[1] = [0,caml_check_bound(argv[1],_pe_)[1 + _pe_],_pd_];
                           consume_arg(0);
                           continue}
                         return caml_call1(f$6,rev(acc[1]))}
                      default:
                       var f$7=param[1];
                       if(1 - allow_expand)
                        throw [0,Invalid_argument,cst_Arg_Expand_is_is_only_allo];
                       var arg$6=get_arg(0),newarg=caml_call1(f$7,arg$6);
                       consume_arg(0);
                       var
                        before=sub$1(argv[1],0,current[1] + 1 | 0),
                        after=
                         sub$1
                          (argv[1],
                           current[1] + 1 | 0,
                           (argv[1].length - 1 - current[1] | 0) - 1 | 0);
                       argv[1]
                       =
                       caml_array_concat([0,before,[0,newarg,[0,after,0]]]);
                       return 0}}
                  return treat_action},
               treat_action=treat_action$0(s,no_arg,get_arg,consume_arg);
              treat_action(action);
              switch$0 = 1}
            if(! switch$0)caml_call1(anonfun,s)}
          catch(exn$0)
           {exn$0 = caml_wrap_exception(exn$0);
            if(exn$0[1] === Bad){var m=exn$0[2];throw convert_error([3,m])}
            if(exn$0[1] === Stop){var e=exn$0[2];throw convert_error(e)}
            throw exn$0;
            var exn=exn$0}
          current[1]++;
          continue}
        return 0}}
    function parse_and_expand_argv_dynamic
     (current,argv,speclist,anonfun,errmsg)
     {return parse_and_expand_argv_dynamic_
              (1,current,argv,speclist,anonfun,errmsg)}
    function parse_argv_dynamic(opt,argv,speclist,anonfun,errmsg)
     {if(opt)var sth=opt[1],current$0=sth;else var current$0=current;
      return parse_and_expand_argv_dynamic_
              (0,current$0,[0,argv],speclist,anonfun,errmsg)}
    function parse_argv(opt,argv,speclist,anonfun,errmsg)
     {if(opt)var sth=opt[1],current$0=sth;else var current$0=current;
      return parse_argv_dynamic
              ([0,current$0],argv,[0,speclist],anonfun,errmsg)}
    function parse(l,f,msg)
     {try
       {var _o8_=parse_argv(0,caml_sys_argv(0),l,f,msg);return _o8_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] === Bad)
         {var msg$0=exn[2];caml_call1(eprintf(_a$_),msg$0);return exit(2)}
        if(exn[1] === Help)
         {var msg$1=exn[2];caml_call1(printf(_ba_),msg$1);return exit(0)}
        throw exn}}
    function parse_dynamic(l,f,msg)
     {try
       {var _o7_=parse_argv_dynamic(0,caml_sys_argv(0),l,f,msg);return _o7_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] === Bad)
         {var msg$0=exn[2];caml_call1(eprintf(_bb_),msg$0);return exit(2)}
        if(exn[1] === Help)
         {var msg$1=exn[2];caml_call1(printf(_bc_),msg$1);return exit(0)}
        throw exn}}
    function parse_expand(l,f,msg)
     {try
       {var
         argv=[0,caml_sys_argv(0)],
         spec=[0,l],
         current$0=[0,current[1]],
         _o6_=parse_and_expand_argv_dynamic(current$0,argv,spec,f,msg);
        return _o6_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] === Bad)
         {var msg$0=exn[2];caml_call1(eprintf(_bd_),msg$0);return exit(2)}
        if(exn[1] === Help)
         {var msg$1=exn[2];caml_call1(printf(_be_),msg$1);return exit(0)}
        throw exn}}
    function second_word(s)
     {var len=caml_ml_string_length(s);
      function loop(n)
       {var n$0=n;
        for(;;)
         {if(len <= n$0)return len;
          if(32 === caml_string_get(s,n$0))
           {var n$1=n$0 + 1 | 0,n$0=n$1;continue}
          return n$0}}
      try
       {var n$0=index$0(s,9)}
      catch(_o4_)
       {_o4_ = caml_wrap_exception(_o4_);
        if(_o4_ === Not_found)
         {try
           {var n=index$0(s,32)}
          catch(_o5_)
           {_o5_ = caml_wrap_exception(_o5_);
            if(_o5_ === Not_found)return len;
            throw _o5_}
          return loop(n + 1 | 0)}
        throw _o4_}
      return loop(n$0 + 1 | 0)}
    function max_arg_len(cur,param)
     {var doc=param[3],spec=param[2],kwd=param[1];
      return 11 === spec[0]
              ?max(cur,caml_ml_string_length(kwd))
              :max(cur,caml_ml_string_length(kwd) + second_word(doc) | 0)}
    function replace_leading_tab(s)
     {var seen=[0,0];
      return map$5
              (function(c)
                {if(9 === c && ! seen[1]){seen[1] = 1;return 32}return c},
               s)}
    function align(opt,speclist)
     {if(opt)var sth=opt[1],limit=sth;else var limit=max_int;
      var
       completed=add_help(speclist),
       len=fold_left$0(max_arg_len,0,completed),
       len$0=min(len,limit);
      return map$3
              (function(ksd)
                {var _o2_=ksd[1],_o3_=ksd[2];
                 if(caml_string_notequal(ksd[3],cst$58))
                  {if(11 === _o3_[0])
                    {var
                      msg$0=ksd[3],
                      cutcol$0=second_word(msg$0),
                      spaces$0=make$1(max(0,len$0 - cutcol$0 | 0) + 3 | 0,32);
                     return [0,
                             _o2_,
                             _o3_,
                             symbol(cst$59,symbol(spaces$0,replace_leading_tab(msg$0)))]}
                   var
                    msg=ksd[3],
                    spec=ksd[2],
                    cutcol=second_word(msg),
                    kwd_len=caml_ml_string_length(_o2_),
                    diff=(len$0 - kwd_len | 0) - cutcol | 0;
                   if(0 < diff)
                    {var
                      spaces=make$1(diff,32),
                      prefix=sub$0(replace_leading_tab(msg),0,cutcol),
                      suffix=
                       sub$0(msg,cutcol,caml_ml_string_length(msg) - cutcol | 0);
                     return [0,_o2_,spec,symbol(prefix,symbol(spaces,suffix))]}
                   return [0,_o2_,spec,replace_leading_tab(msg)]}
                 return ksd},
               completed)}
    function read_aux(trim,sep,file)
     {var ic=open_in_bin(file),buf=create$2(200),words=[0,0];
      function stash(param)
       {var s=contents(buf);
        if(trim)
         {var len=caml_ml_string_length(s),switch$0=0;
          if(0 < len && 13 === caml_string_get(s,len - 1 | 0))
           {var _o1_=sub$0(s,0,len - 1 | 0);switch$0 = 1}
          if(! switch$0)var _o1_=s;
          var word=_o1_}
        else
         var word=s;
        words[1] = [0,word,words[1]];
        return clear$1(buf)}
      try
       {for(;;)
         {var c=caml_ml_input_char(ic);
          if(c === sep)stash(0);else add_char(buf,c);
          continue}}
      catch(_o0_)
       {_o0_ = caml_wrap_exception(_o0_);
        if(_o0_ === End_of_file)
         {if(0 < buf[2])stash(0);
          caml_ml_close_channel(ic);
          return of_list(rev(words[1]))}
        throw _o0_}}
    var _bf_=10,_bg_=1;
    function read_arg(_oZ_){return read_aux(_bg_,_bf_,_oZ_)}
    var _bh_=0,_bi_=0;
    function read_arg0(_oY_){return read_aux(_bi_,_bh_,_oY_)}
    function write_aux(sep,file,args)
     {var oc=open_out_bin(file);
      iter$5(function(s){return caml_call2(fprintf(oc,_bj_),s,sep)},args);
      return close_out(oc)}
    var _bk_=10;
    function write_arg(_oW_,_oX_){return write_aux(_bk_,_oW_,_oX_)}
    var _bl_=0;
    function write_arg0(_oU_,_oV_){return write_aux(_bl_,_oU_,_oV_)}
    var
     Stdlib_arg=
      [0,
       parse,
       parse_dynamic,
       parse_argv,
       parse_argv_dynamic,
       parse_and_expand_argv_dynamic,
       parse_expand,
       Help,
       Bad,
       usage,
       usage_string,
       align,
       current,
       read_arg,
       read_arg0,
       write_arg,
       write_arg0];
    caml_register_global(792,Stdlib_arg,"Stdlib__arg");
    var
     Stdlib_atomic=
      [0,make,get,set,exchange,compare_and_set,fetch_and_add,incr,decr];
    caml_register_global(793,Stdlib_atomic,"Stdlib__atomic");
    var printers=[0,0];
    function field(x,i)
     {var f=x[1 + i];
      return is_block(f)
              ?caml_obj_tag(f) === 252
                ?caml_call1(sprintf(_bm_),f)
                :caml_obj_tag(f) === 253?to_string(f):cst$60
              :caml_call1(sprintf(_bn_),f)}
    function other_fields(x,i)
     {if(x.length - 1 <= i)return cst$61;
      var _oS_=other_fields(x,i + 1 | 0),_oT_=field(x,i);
      return caml_call2(sprintf(_bo_),_oT_,_oS_)}
    function use_printers(x)
     {function conv(param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var tl=param$0[2],hd=param$0[1];
            try
             {var switch$0=0,val=caml_call1(hd,x);switch$0 = 1}
            catch(_oR_){}
            if(switch$0 && val){var s=val[1];return [0,s]}
            var param$0=tl;
            continue}
          return 0}}
      return conv(printers[1])}
    function to_string_default(x)
     {if(x === Out_of_memory)return cst_Out_of_memory;
      if(x === Stack_overflow)return cst_Stack_overflow;
      if(x[1] === Match_failure)
       {var match$0=x[2],char$0=match$0[3],line=match$0[2],file=match$0[1];
        return caml_call5
                (sprintf(locfmt),
                 file,
                 line,
                 char$0,
                 char$0 + 5 | 0,
                 cst_Pattern_matching_failed)}
      if(x[1] === Assert_failure)
       {var
         match$1=x[2],
         char$1=match$1[3],
         line$0=match$1[2],
         file$0=match$1[1];
        return caml_call5
                (sprintf(locfmt),
                 file$0,
                 line$0,
                 char$1,
                 char$1 + 6 | 0,
                 cst_Assertion_failed)}
      if(x[1] === Undefined_recursive_module)
       {var
         match$2=x[2],
         char$2=match$2[3],
         line$1=match$2[2],
         file$1=match$2[1];
        return caml_call5
                (sprintf(locfmt),
                 file$1,
                 line$1,
                 char$2,
                 char$2 + 6 | 0,
                 cst_Undefined_recursive_module)}
      if(0 === caml_obj_tag(x))
       {var constructor=x[1][1],match=x.length - 1;
        if(2 < match >>> 0)
         var
          _oN_=other_fields(x,2),
          _oO_=field(x,1),
          _oQ_=caml_call2(sprintf(_bp_),_oO_,_oN_);
        else
         switch(match)
          {case 0:var _oQ_=cst$62;break;
           case 1:var _oQ_=cst$63;break;
           default:var _oP_=field(x,1),_oQ_=caml_call1(sprintf(_bq_),_oP_)}
        return symbol(constructor,_oQ_)}
      return x[1]}
    function to_string$7(e)
     {var match=use_printers(e);
      if(match){var s=match[1];return s}
      return to_string_default(e)}
    function print(fct,arg)
     {try
       {var _oM_=caml_call1(fct,arg);return _oM_}
      catch(x)
       {x = caml_wrap_exception(x);
        var _oL_=to_string$7(x);
        caml_call1(eprintf(_br_),_oL_);
        caml_ml_flush(stderr);
        throw x}}
    function catch$0(fct,arg)
     {try
       {var _oK_=caml_call1(fct,arg);return _oK_}
      catch(x)
       {x = caml_wrap_exception(x);
        caml_ml_flush(stdout);
        var _oJ_=to_string$7(x);
        caml_call1(eprintf(_bs_),_oJ_);
        return exit(2)}}
    function raw_backtrace_entries(bt){return bt}
    function convert_raw_backtrace(bt)
     {return [0,runtime.caml_convert_raw_backtrace(bt)]}
    function format_backtrace_slot(pos,slot)
     {function info(is_raise)
       {return is_raise
                ?0 === pos?cst_Raised_at:cst_Re_raised_at
                :0 === pos?cst_Raised_by_primitive_operat:cst_Called_from}
      if(0 === slot[0])
       {var
         _oB_=slot[5],
         _oC_=slot[4],
         _oD_=slot[3],
         _oE_=slot[6]?cst_inlined:cst$64,
         _oF_=slot[2],
         _oG_=slot[7],
         _oH_=info(slot[1]);
        return [0,
                caml_call7(sprintf(_bt_),_oH_,_oG_,_oF_,_oE_,_oD_,_oC_,_oB_)]}
      if(slot[1])return 0;
      var _oI_=info(0);
      return [0,caml_call1(sprintf(_bu_),_oI_)]}
    function print_raw_backtrace(outchan,raw_backtrace)
     {var backtrace=convert_raw_backtrace(raw_backtrace);
      if(backtrace)
       {var a=backtrace[1],_oz_=a.length - 1 - 1 | 0,_oy_=0;
        if(! (_oz_ < 0))
         {var i=_oy_;
          for(;;)
           {var match=format_backtrace_slot(i,caml_check_bound(a,i)[1 + i]);
            if(match){var str=match[1];caml_call1(fprintf(outchan,_bv_),str)}
            var _oA_=i + 1 | 0;
            if(_oz_ !== i){var i=_oA_;continue}
            break}}
        return 0}
      return fprintf(outchan,_bw_)}
    function print_backtrace(outchan)
     {return print_raw_backtrace(outchan,caml_get_exception_raw_backtra(0))}
    function raw_backtrace_to_string(raw_backtrace)
     {var backtrace=convert_raw_backtrace(raw_backtrace);
      if(backtrace)
       {var a=backtrace[1],b=create$2(1024),_ow_=a.length - 1 - 1 | 0,_ov_=0;
        if(! (_ow_ < 0))
         {var i=_ov_;
          for(;;)
           {var match=format_backtrace_slot(i,caml_check_bound(a,i)[1 + i]);
            if(match){var str=match[1];caml_call1(bprintf(b,_bx_),str)}
            var _ox_=i + 1 | 0;
            if(_ow_ !== i){var i=_ox_;continue}
            break}}
        return contents(b)}
      return cst_Program_not_linked_with_g_}
    function backtrace_slot_is_raise(param)
     {return 0 === param[0]?param[1]:param[1]}
    function backtrace_slot_is_inline(param){return 0 === param[0]?param[6]:0}
    function backtrace_slot_location(param)
     {return 0 === param[0]?[0,[0,param[2],param[3],param[4],param[5]]]:0}
    function backtrace_slot_defname(param)
     {if(0 === param[0] && caml_string_notequal(param[7],cst$65))
       return [0,param[7]];
      return 0}
    function backtrace_slots(raw_backtrace)
     {var match=convert_raw_backtrace(raw_backtrace);
      if(match)
       {var backtrace=match[1],i$1=backtrace.length - 1 - 1 | 0,i=i$1;
        for(;;)
         {if(-1 === i)
           var _ou_=0;
          else
           {var
             param=caml_check_bound(backtrace,i)[1 + i],
             _ot_=0 === param[0]?1:0;
            if(! _ot_){var i$0=i - 1 | 0,i=i$0;continue}
            var _ou_=_ot_}
          return _ou_?[0,backtrace]:0}}
      return 0}
    function backtrace_slots_of_raw_entry(entry)
     {return backtrace_slots([0,entry])}
    function raw_backtrace_length(bt){return bt.length - 1}
    function get_backtrace(param)
     {return raw_backtrace_to_string(caml_get_exception_raw_backtra(0))}
    function register_printer(fn)
     {for(;;)
       {var
         old_printers=printers[1],
         new_printers=[0,fn,old_printers],
         success=compare_and_set(printers,old_printers,new_printers),
         _os_=1 - success;
        if(_os_)continue;
        return _os_}}
    function exn_slot(x){return 0 === caml_obj_tag(x)?x[1]:x}
    function exn_slot_id(x){var slot=exn_slot(x);return slot[2]}
    function exn_slot_name(x){var slot=exn_slot(x);return slot[1]}
    var errors=_by_.slice();
    function default_uncaught_exception_han(exn,raw_backtrace)
     {var _oq_=to_string$7(exn);
      caml_call1(eprintf(_bz_),_oq_);
      print_raw_backtrace(stderr,raw_backtrace);
      var status=runtime.caml_ml_debug_info_status(0);
      if(status < 0)
       {var _or_=abs(status);
        prerr_endline(caml_check_bound(errors,_or_)[1 + _or_])}
      return caml_ml_flush(stderr)}
    var uncaught_exception_handler=[0,default_uncaught_exception_han];
    function set_uncaught_exception_handler(fn)
     {uncaught_exception_handler[1] = fn;return 0}
    function _bA_(_op_){return runtime.caml_raw_backtrace_next_slot(_op_)}
    function _bB_(_oo_){return runtime.caml_convert_raw_backtrace_slot(_oo_)}
    function _bC_(_on_,_om_)
     {return runtime.caml_raw_backtrace_slot(_on_,_om_)}
    var
     _bD_=
      [0,
       backtrace_slot_is_raise,
       backtrace_slot_is_inline,
       backtrace_slot_location,
       backtrace_slot_defname,
       format_backtrace_slot];
    function _bE_(_ol_){return caml_get_exception_raw_backtra(_ol_)}
    function _bF_(_ok_){return runtime.caml_backtrace_status(_ok_)}
    var
     Stdlib_printexc=
      [0,
       to_string$7,
       to_string_default,
       print,
       catch$0,
       print_backtrace,
       get_backtrace,
       function(_oj_){return runtime.caml_record_backtrace(_oj_)},
       _bF_,
       register_printer,
       use_printers,
       raw_backtrace_entries,
       _bE_,
       print_raw_backtrace,
       raw_backtrace_to_string,
       default_uncaught_exception_han,
       set_uncaught_exception_handler,
       backtrace_slots,
       backtrace_slots_of_raw_entry,
       _bD_,
       raw_backtrace_length,
       _bC_,
       _bB_,
       _bA_,
       exn_slot_id,
       exn_slot_name];
    caml_register_global(794,Stdlib_printexc,"Stdlib__printexc");
    function const$0(c,param){return c}
    function flip(f,x,y){return caml_call2(f,y,x)}
    function negate(p,v){return 1 - caml_call1(p,v)}
    var
     Finally_raised=
      [248,cst_Stdlib_Fun_Finally_raised,caml_fresh_oo_id(0)];
    register_printer
     (function(param)
       {if(param[1] === Finally_raised)
         {var exn=param[2];
          return [0,symbol(cst_Fun_Finally_raised,to_string$7(exn))]}
        return 0});
    function protect(finally$0,work)
     {function finally_no_exn(param)
       {try
         {var _oi_=caml_call1(finally$0,0);return _oi_}
        catch(e)
         {e = caml_wrap_exception(e);
          var bt=caml_get_exception_raw_backtra(0),exn=[0,Finally_raised,e];
          caml_restore_raw_backtrace(exn,bt);
          throw exn}}
      try
       {var result=caml_call1(work,0)}
      catch(work_exn)
       {work_exn = caml_wrap_exception(work_exn);
        var work_bt=caml_get_exception_raw_backtra(0);
        finally_no_exn(0);
        caml_restore_raw_backtrace(work_exn,work_bt);
        throw work_exn}
      finally_no_exn(0);
      return result}
    var Stdlib_fun=[0,const$0,flip,negate,protect,Finally_raised];
    caml_register_global(795,Stdlib_fun,"Stdlib__fun");
    function print_stat(c)
     {var st=runtime.caml_gc_stat(0),_n2_=st[4];
      caml_call1(fprintf(c,_bG_),_n2_);
      var _n3_=st[5];
      caml_call1(fprintf(c,_bH_),_n3_);
      var _n4_=st[14];
      caml_call1(fprintf(c,_bI_),_n4_);
      var _n5_=st[17];
      caml_call1(fprintf(c,_bJ_),_n5_);
      fprintf(c,_bK_);
      var
       _n6_=st[1],
       l1=caml_ml_string_length(caml_call1(sprintf(_bL_),_n6_)),
       _n7_=st[1];
      caml_call2(fprintf(c,_bM_),l1,_n7_);
      var _n8_=st[2];
      caml_call2(fprintf(c,_bN_),l1,_n8_);
      var _n9_=st[3];
      caml_call2(fprintf(c,_bO_),l1,_n9_);
      fprintf(c,_bP_);
      var
       _n__=st[15],
       l2=caml_ml_string_length(caml_call1(sprintf(_bQ_),_n__)),
       _n$_=st[15];
      caml_call2(fprintf(c,_bR_),l2,_n$_);
      var _oa_=st[6];
      caml_call2(fprintf(c,_bS_),l2,_oa_);
      var _ob_=st[8];
      caml_call2(fprintf(c,_bT_),l2,_ob_);
      var _oc_=st[10];
      caml_call2(fprintf(c,_bU_),l2,_oc_);
      var _od_=st[12];
      caml_call2(fprintf(c,_bV_),l2,_od_);
      var _oe_=st[13];
      caml_call2(fprintf(c,_bW_),l2,_oe_);
      fprintf(c,_bX_);
      var _of_=st[9];
      caml_call1(fprintf(c,_bY_),_of_);
      var _og_=st[11];
      caml_call1(fprintf(c,_bZ_),_og_);
      var _oh_=st[7];
      return caml_call1(fprintf(c,_b0_),_oh_)}
    function allocated_bytes(param)
     {var
       match=runtime.caml_gc_counters(0),
       ma=match[3],
       pro=match[2],
       mi=match[1];
      return (mi + ma - pro) * 4}
    function create_alarm(f){return [0,1]}
    function delete_alarm(a){a[1] = 0;return 0}
    function _b1_(param){return 0}
    function _b2_(param){return 0}
    function _b3_(param){return 0}
    function _b4_(param){return 0}
    var null_tracker=[0,function(param){return 0},_b4_,_b3_,_b2_,_b1_];
    function start(sampling_rate,opt,tracker)
     {if(opt)
       var sth=opt[1],callstack_size=sth;
      else
       var callstack_size=max_int;
      return runtime.caml_memprof_start(sampling_rate,callstack_size,tracker)}
    var _b5_=[0,null_tracker,start,runtime.caml_memprof_stop];
    function _b6_(_n1_){return runtime.caml_final_release(_n1_)}
    function _b7_(_n0_,_nZ_)
     {return runtime.caml_final_register_called_without_value(_n0_,_nZ_)}
    var
     Stdlib_gc=
      [0,
       print_stat,
       allocated_bytes,
       function(_nY_,_nX_){return runtime.caml_final_register(_nY_,_nX_)},
       _b7_,
       _b6_,
       create_alarm,
       delete_alarm,
       _b5_];
    caml_register_global(796,Stdlib_gc,"Stdlib__gc");
    function string(str)
     {return caml_md5_string(str,0,caml_ml_string_length(str))}
    function bytes(b){return string(caml_string_of_bytes(b))}
    function substring(str,ofs,len)
     {if
       (0
        <=
        ofs
        &&
        0
        <=
        len
        &&
        !
        ((caml_ml_string_length(str) - len | 0) < ofs))
       return caml_md5_string(str,ofs,len);
      return invalid_arg(cst_Digest_substring)}
    function subbytes(b,ofs,len)
     {return substring(caml_string_of_bytes(b),ofs,len)}
    function file(filename)
     {var ic=open_in_bin(filename);
      try
       {var d=runtime.caml_md5_chan(ic,-1)}
      catch(e){e = caml_wrap_exception(e);caml_ml_close_channel(ic);throw e}
      caml_ml_close_channel(ic);
      return d}
    function output$0(chan,digest){return output_string(chan,digest)}
    function input$0(chan){return really_input_string(chan,16)}
    function char_hex(n){var _nW_=10 <= n?87:48;return n + _nW_ | 0}
    function to_hex(d)
     {if(16 !== caml_ml_string_length(d))invalid_arg(cst_Digest_to_hex);
      var result=caml_create_bytes(32),i=0;
      for(;;)
       {var x=caml_string_get(d,i);
        caml_bytes_unsafe_set(result,i * 2 | 0,char_hex(x >>> 4 | 0));
        caml_bytes_unsafe_set(result,(i * 2 | 0) + 1 | 0,char_hex(x & 15));
        var _nV_=i + 1 | 0;
        if(15 !== i){var i=_nV_;continue}
        return caml_string_of_bytes(result)}}
    function from_hex(s)
     {if(32 !== caml_ml_string_length(s))invalid_arg(cst_Digest_from_hex);
      function digit(c)
       {if(65 <= c)
         {if(97 <= c)
           {if(! (103 <= c))return (c - 97 | 0) + 10 | 0}
          else
           if(! (71 <= c))return (c - 65 | 0) + 10 | 0}
        else
         {var switcher=c - 48 | 0;if(! (9 < switcher >>> 0))return c - 48 | 0}
        throw [0,Invalid_argument,cst_Digest_from_hex$0]}
      var result=caml_create_bytes(16),i=0;
      for(;;)
       {var i$0=2 * i | 0,_nT_=digit(caml_string_get(s,i$0 + 1 | 0));
        caml_bytes_set
         (result,i,chr((digit(caml_string_get(s,i$0)) << 4) + _nT_ | 0));
        var _nU_=i + 1 | 0;
        if(15 !== i){var i=_nU_;continue}
        return caml_string_of_bytes(result)}}
    var
     Stdlib_digest=
      [0,
       compare$7,
       equal$7,
       string,
       bytes,
       substring,
       subbytes,
       file,
       output$0,
       input$0,
       to_hex,
       from_hex];
    caml_register_global(797,Stdlib_digest,"Stdlib__digest");
    function new_state(param){return [0,caml_make_vect(55,0),0]}
    function assign(st1,st2)
     {blit$1(st2[1],0,st1[1],0,55);st1[2] = st2[2];return 0}
    function full_init(s,seed)
     {var seed$0=0 === seed.length - 1?[0,0]:seed,l=seed$0.length - 1,i$0=0;
      for(;;)
       {caml_check_bound(s[1],i$0)[1 + i$0] = i$0;
        var _nS_=i$0 + 1 | 0;
        if(54 !== i$0){var i$0=_nS_;continue}
        var accu=[0,cst_x$1],_nO_=54 + max(55,l) | 0,_nN_=0;
        if(! (_nO_ < 0))
         {var i=_nN_;
          for(;;)
           {var
             j=i % 55 | 0,
             k=caml_mod(i,l),
             x=caml_check_bound(seed$0,k)[1 + k];
            accu[1] = string(symbol(accu[1],caml_string_of_jsbytes("" + x)));
            var
             _nP_=accu[1],
             _nJ_=caml_string_get(_nP_,3) << 24,
             _nK_=caml_string_get(_nP_,2) << 16,
             _nL_=caml_string_get(_nP_,1) << 8,
             _nM_=((caml_string_get(_nP_,0) + _nL_ | 0) + _nK_ | 0) + _nJ_ | 0,
             _nQ_=(caml_check_bound(s[1],j)[1 + j] ^ _nM_) & 1073741823;
            caml_check_bound(s[1],j)[1 + j] = _nQ_;
            var _nR_=i + 1 | 0;
            if(_nO_ !== i){var i=_nR_;continue}
            break}}
        s[2] = 0;
        return 0}}
    function make$3(seed)
     {var result=new_state(0);full_init(result,seed);return result}
    function make_self_init(param){return make$3(caml_sys_random_seed(0))}
    function copy$5(s){var result=new_state(0);assign(result,s);return result}
    function bits(s)
     {s[2] = (s[2] + 1 | 0) % 55 | 0;
      var
       _nG_=s[2],
       curval=caml_check_bound(s[1],_nG_)[1 + _nG_],
       _nH_=(s[2] + 24 | 0) % 55 | 0,
       newval=
        caml_check_bound(s[1],_nH_)[1 + _nH_]
        +
        (curval ^ (curval >>> 25 | 0) & 31)
        |
        0,
       newval30=newval & 1073741823,
       _nI_=s[2];
      caml_check_bound(s[1],_nI_)[1 + _nI_] = newval30;
      return newval30}
    function int$0(s,bound)
     {if(! (1073741823 < bound) && 0 < bound)
       for(;;)
        {var r=bits(s),v=caml_mod(r,bound);
         if(((1073741823 - bound | 0) + 1 | 0) < (r - v | 0))continue;
         return v}
      return invalid_arg(cst_Random_int)}
    function int32(s,bound)
     {if(caml_lessequal(bound,0))return invalid_arg(cst_Random_int32);
      for(;;)
       {var b1=bits(s),b2=(bits(s) & 1) << 30,r=b1 | b2,v=caml_mod(r,bound);
        if(caml_greaterthan(r - v | 0,(2147483647 - bound | 0) + 1 | 0))
         continue;
        return v}}
    function int64(s,bound)
     {if(caml_lessequal(bound,_b9_))return invalid_arg(cst_Random_int64);
      for(;;)
       {var
         b1=caml_int64_of_int32(bits(s)),
         b2=caml_int64_shift_left(caml_int64_of_int32(bits(s)),30),
         b3=caml_int64_shift_left(caml_int64_of_int32(bits(s) & 7),60),
         r=caml_int64_or(b1,caml_int64_or(b2,b3)),
         v=runtime.caml_int64_mod(r,bound);
        if
         (caml_greaterthan
           (caml_int64_sub(r,v),
            caml_int64_add(caml_int64_sub(max_int$2,bound),_b8_)))
         continue;
        return v}}
    function nativeint(s,bound){return int32(s,bound)}
    function float$0(s,bound)
     {var r1=bits(s),r2=bits(s);
      return (r1 / 1073741824. + r2) / 1073741824. * bound}
    function bool(s){return 0 === (bits(s) & 1)?1:0}
    var default$0=[0,_b__.slice(),0];
    function bits$0(param){return bits(default$0)}
    function int$1(bound){return int$0(default$0,bound)}
    function int32$0(bound){return int32(default$0,bound)}
    function nativeint$0(bound){return nativeint(default$0,bound)}
    function int64$0(bound){return int64(default$0,bound)}
    function float$1(scale){return float$0(default$0,scale)}
    function bool$0(param){return bool(default$0)}
    function full_init$0(seed){return full_init(default$0,seed)}
    function init$4(seed){return full_init(default$0,[0,seed])}
    function self_init(param){return full_init$0(caml_sys_random_seed(0))}
    function get_state(param){return copy$5(default$0)}
    function set_state(s){return assign(default$0,s)}
    var
     _b$_=
      [0,
       make$3,
       make_self_init,
       copy$5,
       bits,
       int$0,
       int32,
       nativeint,
       int64,
       float$0,
       bool],
     Stdlib_random=
      [0,
       init$4,
       full_init$0,
       self_init,
       bits$0,
       int$1,
       int32$0,
       nativeint$0,
       int64$0,
       float$1,
       bool$0,
       _b$_,
       get_state,
       set_state];
    caml_register_global(798,Stdlib_random,"Stdlib__random");
    function ongoing_traversal(h)
     {var _nE_=h.length - 1 < 4?1:0,_nF_=_nE_ || (h[4] < 0?1:0);return _nF_}
    function flip_ongoing_traversal(h){h[4] = - h[4] | 0;return 0}
    try
     {var _cU_=caml_sys_getenv(cst_OCAMLRUNPARAM),params=_cU_}
    catch(_nC_)
     {_nC_ = caml_wrap_exception(_nC_);
      if(_nC_ !== Not_found)throw _nC_;
      try
       {var _cT_=caml_sys_getenv(cst_CAMLRUNPARAM),_ca_=_cT_}
      catch(_nD_)
       {_nD_ = caml_wrap_exception(_nD_);
        if(_nD_ !== Not_found)throw _nD_;
        var _ca_=cst$66}
      var params=_ca_}
    var
     randomized_default=contains$0(params,82),
     randomized=[0,randomized_default];
    function randomize(param){randomized[1] = 1;return 0}
    function is_randomized(param){return randomized[1]}
    var prng=[246,function(_nB_){return caml_call1(_b$_[2],0)}];
    function power_2_above(x,n)
     {var x$0=x;
      for(;;)
       {if(n <= x$0)return x$0;
        if(max_array_length < (x$0 * 2 | 0))return x$0;
        var x$1=x$0 * 2 | 0,x$0=x$1;
        continue}}
    function create$3(opt,initial_size)
     {if(opt)var sth=opt[1],random=sth;else var random=randomized[1];
      var s=power_2_above(16,initial_size);
      if(random)
       var
        _nz_=caml_obj_tag(prng),
        _nA_=250 === _nz_?prng[1]:246 === _nz_?force_lazy_block(prng):prng,
        seed=caml_call1(_b$_[4],_nA_);
      else
       var seed=0;
      return [0,0,caml_make_vect(s,0),seed,s]}
    function clear$2(h)
     {var _ny_=0 < h[1]?1:0;
      return _ny_?(h[1] = 0,fill$0(h[2],0,h[2].length - 1,0)):_ny_}
    function reset$0(h)
     {var len=h[2].length - 1;
      if(4 <= h.length - 1 && len !== abs(h[4]))
       {h[1] = 0;h[2] = caml_make_vect(abs(h[4]),0);return 0}
      return clear$2(h)}
    function copy_bucketlist(param)
     {if(param)
       {var
         key=param[1],
         data=param[2],
         next=param[3],
         prec$0=[0,key,data,next],
         prec=prec$0,
         param$0=next;
        for(;;)
         {if(param$0)
           {var
             key$0=param$0[1],
             data$0=param$0[2],
             next$0=param$0[3],
             r=[0,key$0,data$0,next$0];
            if(prec){prec[3] = r;var prec=r,param$0=next$0;continue}
            throw [0,Assert_failure,_cb_]}
          return prec$0}}
      return 0}
    function copy$6(init)
     {var _nv_=init[4],_nw_=init[3],_nx_=map$6(copy_bucketlist,init[2]);
      return [0,init[1],_nx_,_nw_,_nv_]}
    function length$4(h){return h[1]}
    function insert_all_buckets(indexfun,inplace,odata,ndata)
     {var
       nsize=ndata.length - 1,
       ndata_tail=caml_make_vect(nsize,0),
       _np_=odata.length - 1 - 1 | 0,
       _no_=0;
      if(! (_np_ < 0))
       {var i$0=_no_;
        a:
        for(;;)
         {var cell$1=caml_check_bound(odata,i$0)[1 + i$0],cell=cell$1;
          for(;;)
           {if(cell)
             {var
               key=cell[1],
               data=cell[2],
               next=cell[3],
               cell$0=inplace?cell:[0,key,data,0],
               nidx=caml_call1(indexfun,key),
               match=caml_check_bound(ndata_tail,nidx)[1 + nidx];
              if(match)
               match[3] = cell$0;
              else
               caml_check_bound(ndata,nidx)[1 + nidx] = cell$0;
              caml_check_bound(ndata_tail,nidx)[1 + nidx] = cell$0;
              var cell=next;
              continue}
            var _nu_=i$0 + 1 | 0;
            if(_np_ !== i$0){var i$0=_nu_;continue a}
            break}
          break}}
      if(inplace)
       {var _nr_=nsize - 1 | 0,_nq_=0;
        if(! (_nr_ < 0))
         {var i=_nq_;
          for(;;)
           {var match$0=caml_check_bound(ndata_tail,i)[1 + i];
            if(match$0)match$0[3] = 0;
            var _nt_=i + 1 | 0;
            if(_nr_ !== i){var i=_nt_;continue}
            break}}
        var _ns_=0}
      else
       var _ns_=inplace;
      return _ns_}
    function resize$0(indexfun,h)
     {var
       odata=h[2],
       osize=odata.length - 1,
       nsize=osize * 2 | 0,
       _nn_=nsize < max_array_length?1:0;
      if(_nn_)
       {var ndata=caml_make_vect(nsize,0),inplace=1 - ongoing_traversal(h);
        h[2] = ndata;
        return insert_all_buckets(caml_call1(indexfun,h),inplace,odata,ndata)}
      return _nn_}
    function iter$10(f,h)
     {function do_bucket(param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var key=param$0[1],data=param$0[2],next=param$0[3];
            caml_call2(f,key,data);
            var param$0=next;
            continue}
          return 0}}
      var old_trav=ongoing_traversal(h);
      if(1 - old_trav)flip_ongoing_traversal(h);
      try
       {var d=h[2],_nj_=d.length - 1 - 1 | 0,_ni_=0;
        if(! (_nj_ < 0))
         {var i=_ni_;
          for(;;)
           {do_bucket(caml_check_bound(d,i)[1 + i]);
            var _nm_=i + 1 | 0;
            if(_nj_ !== i){var i=_nm_;continue}
            break}}
        var _nk_=1 - old_trav,_nl_=_nk_?flip_ongoing_traversal(h):_nk_;
        return _nl_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(old_trav)throw exn;
        flip_ongoing_traversal(h);
        throw exn}}
    function filter_map_inplace_bucket(f,h,i,prec,slot)
     {var prec$0=prec,slot$0=slot;
      for(;;)
       {if(slot$0)
         {var
           key=slot$0[1],
           data=slot$0[2],
           next=slot$0[3],
           match=caml_call2(f,key,data);
          if(match)
           {var data$0=match[1];
            if(prec$0)
             prec$0[3] = slot$0;
            else
             caml_check_bound(h[2],i)[1 + i] = slot$0;
            slot$0[2] = data$0;
            var prec$0=slot$0,slot$0=next;
            continue}
          h[1] = h[1] - 1 | 0;
          var slot$0=next;
          continue}
        return prec$0
                ?(prec$0[3] = 0,0)
                :(caml_check_bound(h[2],i)[1 + i] = 0,0)}}
    function filter_map_inplace(f,h)
     {var d=h[2],old_trav=ongoing_traversal(h);
      if(1 - old_trav)flip_ongoing_traversal(h);
      try
       {var _ne_=d.length - 1 - 1 | 0,_nd_=0;
        if(! (_ne_ < 0))
         {var i=_nd_;
          for(;;)
           {filter_map_inplace_bucket(f,h,i,0,caml_check_bound(h[2],i)[1 + i]);
            var _nh_=i + 1 | 0;
            if(_ne_ !== i){var i=_nh_;continue}
            break}}
        var _nf_=1 - old_trav,_ng_=_nf_?flip_ongoing_traversal(h):_nf_;
        return _ng_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(old_trav)throw exn;
        flip_ongoing_traversal(h);
        throw exn}}
    function fold$4(f,h,init)
     {function do_bucket(b,accu)
       {var b$0=b,accu$0=accu;
        for(;;)
         {if(b$0)
           {var
             key=b$0[1],
             data=b$0[2],
             next=b$0[3],
             accu$1=caml_call3(f,key,data,accu$0),
             b$0=next,
             accu$0=accu$1;
            continue}
          return accu$0}}
      var old_trav=ongoing_traversal(h);
      if(1 - old_trav)flip_ongoing_traversal(h);
      try
       {var d=h[2],accu=[0,init],_m$_=d.length - 1 - 1 | 0,_m__=0;
        if(! (_m$_ < 0))
         {var i=_m__;
          for(;;)
           {var _nb_=accu[1];
            accu[1] = do_bucket(caml_check_bound(d,i)[1 + i],_nb_);
            var _nc_=i + 1 | 0;
            if(_m$_ !== i){var i=_nc_;continue}
            break}}
        if(1 - old_trav)flip_ongoing_traversal(h);
        var _na_=accu[1];
        return _na_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(old_trav)throw exn;
        flip_ongoing_traversal(h);
        throw exn}}
    function bucket_length(accu,param)
     {var accu$0=accu,param$0=param;
      for(;;)
       {if(param$0)
         {var
           param$1=param$0[3],
           accu$1=accu$0 + 1 | 0,
           accu$0=accu$1,
           param$0=param$1;
          continue}
        return accu$0}}
    function stats(h)
     {var
       _m6_=h[2],
       _m7_=0,
       mbl=
        fold_left$1(function(m,b){return max(m,bucket_length(0,b))},_m7_,_m6_),
       histo=caml_make_vect(mbl + 1 | 0,0),
       _m8_=h[2];
      iter$5
       (function(b)
         {var
           l=bucket_length(0,b),
           _m9_=caml_check_bound(histo,l)[1 + l] + 1 | 0;
          caml_check_bound(histo,l)[1 + l] = _m9_;
          return 0},
        _m8_);
      return [0,h[1],h[2].length - 1,mbl,histo]}
    function to_seq$9(tbl)
     {var tbl_data=tbl[2];
      function aux(i,buck,param)
       {var i$0=i,buck$0=buck;
        for(;;)
         {if(buck$0)
           {var key=buck$0[1],data=buck$0[2],next=buck$0[3];
            return [0,[0,key,data],function(_m5_){return aux(i$0,next,_m5_)}]}
          if(i$0 === tbl_data.length - 1)return 0;
          var
           buck$1=caml_check_bound(tbl_data,i$0)[1 + i$0],
           i$1=i$0 + 1 | 0,
           i$0=i$1,
           buck$0=buck$1;
          continue}}
      var _m2_=0,_m3_=0;
      return function(_m4_){return aux(_m3_,_m2_,_m4_)}}
    function to_seq_keys(m)
     {var _mY_=to_seq$9(m);
      function _mZ_(_m1_){return _m1_[1]}
      return function(_m0_){return map(_mZ_,_mY_,_m0_)}}
    function to_seq_values(m)
     {var _mU_=to_seq$9(m);
      function _mV_(_mX_){return _mX_[2]}
      return function(_mW_){return map(_mV_,_mU_,_mW_)}}
    function MakeSeeded(H)
     {function key_index(h,key)
       {var _mT_=h[2].length - 1 - 1 | 0;
        return caml_call2(H[2],h[3],key) & _mT_}
      function add(h,key,data)
       {var
         i=key_index(h,key),
         bucket=[0,key,data,caml_check_bound(h[2],i)[1 + i]];
        caml_check_bound(h[2],i)[1 + i] = bucket;
        h[1] = h[1] + 1 | 0;
        var _mS_=h[2].length - 1 << 1 < h[1]?1:0;
        return _mS_?resize$0(key_index,h):_mS_}
      function remove(h,key)
       {var
         i=key_index(h,key),
         c$0=caml_check_bound(h[2],i)[1 + i],
         prec=0,
         c=c$0;
        for(;;)
         {if(c)
           {var k=c[1],next=c[3];
            if(caml_call2(H[1],k,key))
             {h[1] = h[1] - 1 | 0;
              return prec
                      ?(prec[3] = next,0)
                      :(caml_check_bound(h[2],i)[1 + i] = next,0)}
            var prec=c,c=next;
            continue}
          return 0}}
      function find(h,key)
       {var _mR_=key_index(h,key),match=caml_check_bound(h[2],_mR_)[1 + _mR_];
        if(match)
         {var k1=match[1],d1=match[2],next1=match[3];
          if(caml_call2(H[1],key,k1))return d1;
          if(next1)
           {var k2=next1[1],d2=next1[2],next2=next1[3];
            if(caml_call2(H[1],key,k2))return d2;
            if(next2)
             {var k3=next2[1],d3=next2[2],next3=next2[3];
              if(caml_call2(H[1],key,k3))return d3;
              var param=next3;
              for(;;)
               {if(param)
                 {var k=param[1],data=param[2],next=param[3];
                  if(caml_call2(H[1],key,k))return data;
                  var param=next;
                  continue}
                throw Not_found}}
            throw Not_found}
          throw Not_found}
        throw Not_found}
      function find_opt(h,key)
       {var _mQ_=key_index(h,key),match=caml_check_bound(h[2],_mQ_)[1 + _mQ_];
        if(match)
         {var k1=match[1],d1=match[2],next1=match[3];
          if(caml_call2(H[1],key,k1))return [0,d1];
          if(next1)
           {var k2=next1[1],d2=next1[2],next2=next1[3];
            if(caml_call2(H[1],key,k2))return [0,d2];
            if(next2)
             {var k3=next2[1],d3=next2[2],next3=next2[3];
              if(caml_call2(H[1],key,k3))return [0,d3];
              var param=next3;
              for(;;)
               {if(param)
                 {var k=param[1],data=param[2],next=param[3];
                  if(caml_call2(H[1],key,k))return [0,data];
                  var param=next;
                  continue}
                return 0}}
            return 0}
          return 0}
        return 0}
      function find_all(h,key)
       {function find_in_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var k=param$0[1],d=param$0[2],next=param$0[3];
              if(caml_call2(H[1],k,key))return [0,d,find_in_bucket(next)];
              var param$0=next;
              continue}
            return 0}}
        var _mP_=key_index(h,key);
        return find_in_bucket(caml_check_bound(h[2],_mP_)[1 + _mP_])}
      function replace(h,key,data)
       {var
         i=key_index(h,key),
         param$0=caml_check_bound(h[2],i)[1 + i],
         param=param$0;
        for(;;)
         {if(param)
           {var k=param[1],next=param[3];
            if(! caml_call2(H[1],k,key)){var param=next;continue}
            param[1] = key;
            param[2] = data;
            var _mM_=0}
          else
           var _mM_=1;
          if(_mM_)
           {caml_check_bound(h[2],i)[1 + i] = [0,key,data,param$0];
            h[1] = h[1] + 1 | 0;
            var _mN_=h[2].length - 1 << 1 < h[1]?1:0;
            if(_mN_)return resize$0(key_index,h);
            var _mO_=_mN_}
          else
           var _mO_=_mM_;
          return _mO_}}
      function mem(h,key)
       {var
         _mL_=key_index(h,key),
         param$0=caml_check_bound(h[2],_mL_)[1 + _mL_],
         param=param$0;
        for(;;)
         {if(param)
           {var k=param[1],next=param[3],_mK_=caml_call2(H[1],k,key);
            if(_mK_)return _mK_;
            var param=next;
            continue}
          return 0}}
      function add_seq(tbl,i)
       {return iter
                (function(param)
                  {var v=param[2],k=param[1];return add(tbl,k,v)},
                 i)}
      function replace_seq(tbl,i)
       {return iter
                (function(param)
                  {var v=param[2],k=param[1];return replace(tbl,k,v)},
                 i)}
      function of_seq(i){var tbl=create$3(0,16);replace_seq(tbl,i);return tbl}
      return [0,
              create$3,
              clear$2,
              reset$0,
              copy$6,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter$10,
              filter_map_inplace,
              fold$4,
              length$4,
              stats,
              to_seq$9,
              to_seq_keys,
              to_seq_values,
              add_seq,
              replace_seq,
              of_seq]}
    function Make$0(H)
     {var equal=H[1];
      function hash(seed,x){return caml_call1(H[2],x)}
      var
       include=MakeSeeded([0,equal,hash]),
       clear=include[2],
       reset=include[3],
       copy=include[4],
       add=include[5],
       remove=include[6],
       find=include[7],
       find_opt=include[8],
       find_all=include[9],
       replace=include[10],
       mem=include[11],
       iter=include[12],
       filter_map_inplace=include[13],
       fold=include[14],
       length=include[15],
       stats=include[16],
       to_seq=include[17],
       to_seq_keys=include[18],
       to_seq_values=include[19],
       add_seq=include[20],
       replace_seq=include[21],
       _mJ_=include[1];
      function create(sz){return caml_call2(_mJ_,_cc_,sz)}
      function of_seq(i)
       {var tbl=create(16);caml_call2(replace_seq,tbl,i);return tbl}
      return [0,
              create,
              clear,
              reset,
              copy,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter,
              filter_map_inplace,
              fold,
              length,
              stats,
              to_seq,
              to_seq_keys,
              to_seq_values,
              add_seq,
              replace_seq,
              of_seq]}
    function hash$1(x){return caml_hash(10,100,0,x)}
    function hash_param(n1,n2,x){return caml_hash(n1,n2,0,x)}
    function seeded_hash(seed,x){return caml_hash(10,100,seed,x)}
    function key_index(h,key)
     {return 4 <= h.length - 1
              ?caml_hash(10,100,h[3],key) & (h[2].length - 1 - 1 | 0)
              :invalid_arg(cst_Hashtbl_unsupported_hash_t)}
    function add$0(h,key,data)
     {var
       i=key_index(h,key),
       bucket=[0,key,data,caml_check_bound(h[2],i)[1 + i]];
      caml_check_bound(h[2],i)[1 + i] = bucket;
      h[1] = h[1] + 1 | 0;
      var _mI_=h[2].length - 1 << 1 < h[1]?1:0;
      return _mI_?resize$0(key_index,h):_mI_}
    function remove(h,key)
     {var i=key_index(h,key),c$0=caml_check_bound(h[2],i)[1 + i],prec=0,c=c$0;
      for(;;)
       {if(c)
         {var k=c[1],next=c[3];
          if(0 === caml_compare(k,key))
           {h[1] = h[1] - 1 | 0;
            return prec
                    ?(prec[3] = next,0)
                    :(caml_check_bound(h[2],i)[1 + i] = next,0)}
          var prec=c,c=next;
          continue}
        return 0}}
    function find$0(h,key)
     {var _mH_=key_index(h,key),match=caml_check_bound(h[2],_mH_)[1 + _mH_];
      if(match)
       {var k1=match[1],d1=match[2],next1=match[3];
        if(0 === caml_compare(key,k1))return d1;
        if(next1)
         {var k2=next1[1],d2=next1[2],next2=next1[3];
          if(0 === caml_compare(key,k2))return d2;
          if(next2)
           {var k3=next2[1],d3=next2[2],next3=next2[3];
            if(0 === caml_compare(key,k3))return d3;
            var param=next3;
            for(;;)
             {if(param)
               {var k=param[1],data=param[2],next=param[3];
                if(0 === caml_compare(key,k))return data;
                var param=next;
                continue}
              throw Not_found}}
          throw Not_found}
        throw Not_found}
      throw Not_found}
    function find_opt$0(h,key)
     {var _mG_=key_index(h,key),match=caml_check_bound(h[2],_mG_)[1 + _mG_];
      if(match)
       {var k1=match[1],d1=match[2],next1=match[3];
        if(0 === caml_compare(key,k1))return [0,d1];
        if(next1)
         {var k2=next1[1],d2=next1[2],next2=next1[3];
          if(0 === caml_compare(key,k2))return [0,d2];
          if(next2)
           {var k3=next2[1],d3=next2[2],next3=next2[3];
            if(0 === caml_compare(key,k3))return [0,d3];
            var param=next3;
            for(;;)
             {if(param)
               {var k=param[1],data=param[2],next=param[3];
                if(0 === caml_compare(key,k))return [0,data];
                var param=next;
                continue}
              return 0}}
          return 0}
        return 0}
      return 0}
    function find_all$0(h,key)
     {function find_in_bucket(param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var k=param$0[1],data=param$0[2],next=param$0[3];
            if(0 === caml_compare(k,key))return [0,data,find_in_bucket(next)];
            var param$0=next;
            continue}
          return 0}}
      var _mF_=key_index(h,key);
      return find_in_bucket(caml_check_bound(h[2],_mF_)[1 + _mF_])}
    function replace(h,key,data)
     {var
       i=key_index(h,key),
       param$0=caml_check_bound(h[2],i)[1 + i],
       param=param$0;
      for(;;)
       {if(param)
         {var k=param[1],next=param[3];
          if(0 !== caml_compare(k,key)){var param=next;continue}
          param[1] = key;
          param[2] = data;
          var _mC_=0}
        else
         var _mC_=1;
        if(_mC_)
         {caml_check_bound(h[2],i)[1 + i] = [0,key,data,param$0];
          h[1] = h[1] + 1 | 0;
          var _mD_=h[2].length - 1 << 1 < h[1]?1:0;
          if(_mD_)return resize$0(key_index,h);
          var _mE_=_mD_}
        else
         var _mE_=_mC_;
        return _mE_}}
    function mem$2(h,key)
     {var
       _mB_=key_index(h,key),
       param$0=caml_check_bound(h[2],_mB_)[1 + _mB_],
       param=param$0;
      for(;;)
       {if(param)
         {var k=param[1],next=param[3],_mA_=0 === caml_compare(k,key)?1:0;
          if(_mA_)return _mA_;
          var param=next;
          continue}
        return 0}}
    function add_seq$2(tbl,i)
     {return iter
              (function(param)
                {var v=param[2],k=param[1];return add$0(tbl,k,v)},
               i)}
    function replace_seq(tbl,i)
     {return iter
              (function(param)
                {var v=param[2],k=param[1];return replace(tbl,k,v)},
               i)}
    function of_seq$7(i){var tbl=create$3(0,16);replace_seq(tbl,i);return tbl}
    function rebuild(opt,h)
     {if(opt)var sth=opt[1],random=sth;else var random=randomized[1];
      var s=power_2_above(16,h[2].length - 1);
      if(random)
       var
        _mt_=caml_obj_tag(prng),
        _mu_=250 === _mt_?prng[1]:246 === _mt_?force_lazy_block(prng):prng,
        seed=caml_call1(_b$_[4],_mu_);
      else
       var seed=4 <= h.length - 1?h[3]:0;
      var
       _mv_=4 <= h.length - 1?h[4]:s,
       h$0=[0,h[1],caml_make_vect(s,0),seed,_mv_],
       _mw_=h$0[2],
       _mx_=h[2],
       _my_=0;
      insert_all_buckets
       (function(_mz_){return key_index(h$0,_mz_)},_my_,_mx_,_mw_);
      return h$0}
    var
     Stdlib_hashtbl=
      [0,
       create$3,
       clear$2,
       reset$0,
       copy$6,
       add$0,
       find$0,
       find_opt$0,
       find_all$0,
       mem$2,
       remove,
       replace,
       iter$10,
       filter_map_inplace,
       fold$4,
       length$4,
       randomize,
       is_randomized,
       rebuild,
       stats,
       to_seq$9,
       to_seq_keys,
       to_seq_values,
       add_seq$2,
       replace_seq,
       of_seq$7,
       Make$0,
       MakeSeeded,
       hash$1,
       seeded_hash,
       hash_param,
       caml_hash];
    caml_register_global(799,Stdlib_hashtbl,"Stdlib__hashtbl");
    function weak_create(l)
     {var _mr_=0 <= l?1:0,_ms_=_mr_?l <= _t_[15]?1:0:_mr_;
      if(1 - _ms_)invalid_arg(cst_Weak_create);
      return runtime.caml_weak_create(l)}
    function length$5(x){return x.length - 1 - 2 | 0}
    function raise_if_invalid_offset$0(e,o,msg)
     {var _mo_=0 <= o?1:0,_mp_=_mo_?o < length$5(e)?1:0:_mo_,_mq_=1 - _mp_;
      return _mq_?invalid_arg(msg):_mq_}
    function set$0(e,o,x)
     {raise_if_invalid_offset$0(e,o,cst_Weak_set);
      if(x){var x$0=x[1];return caml_ephe_set_key(e,o,x$0)}
      return caml_ephe_unset_key(e,o)}
    function get$1(e,o)
     {raise_if_invalid_offset$0(e,o,cst_Weak_get);
      return runtime.caml_weak_get(e,o)}
    function get_copy(e,o)
     {raise_if_invalid_offset$0(e,o,cst_Weak_get_copy);
      return runtime.caml_weak_get_copy(e,o)}
    function check$0(e,o)
     {raise_if_invalid_offset$0(e,o,cst_Weak_check);
      return runtime.caml_weak_check(e,o)}
    function blit$4(e1,o1,e2,o2,l)
     {if
       (0
        <=
        l
        &&
        0
        <=
        o1
        &&
        !
        ((length$5(e1) - l | 0) < o1)
        &&
        0
        <=
        o2
        &&
        !
        ((length$5(e2) - l | 0) < o2))
       {var
         _mm_=0 !== l?1:0,
         _mn_=_mm_?runtime.caml_weak_blit(e1,o1,e2,o2,l):_mm_;
        return _mn_}
      return invalid_arg(cst_Weak_blit)}
    function fill$2(ar,ofs,len,x)
     {if(0 <= ofs && 0 <= len && ! ((length$5(ar) - len | 0) < ofs))
       {var _mk_=(ofs + len | 0) - 1 | 0;
        if(! (_mk_ < ofs))
         {var i=ofs;
          for(;;)
           {set$0(ar,i,x);
            var _ml_=i + 1 | 0;
            if(_mk_ !== i){var i=_ml_;continue}
            break}}
        return 0}
      throw [0,Invalid_argument,cst_Weak_fill]}
    function Make$1(H)
     {var emptybucket=weak_create(0);
      function get_index(t,h){return caml_mod(h & 2147483647,t[1].length - 1)}
      var limit=7;
      function create(sz)
       {var
         sz$0=7 <= sz?sz:7,
         sz$1=max_array_length < sz$0?max_array_length:sz$0;
        return [0,
                caml_make_vect(sz$1,emptybucket),
                caml_make_vect(sz$1,[0]),
                limit,
                0,
                0]}
      function clear(t)
       {var _mi_=t[1].length - 1 - 1 | 0,_mh_=0;
        if(! (_mi_ < 0))
         {var i=_mh_;
          for(;;)
           {caml_check_bound(t[1],i)[1 + i] = emptybucket;
            caml_check_bound(t[2],i)[1 + i] = [0];
            var _mj_=i + 1 | 0;
            if(_mi_ !== i){var i=_mj_;continue}
            break}}
        t[3] = limit;
        t[4] = 0;
        return 0}
      function fold(f,t,init)
       {var _mg_=t[1],i=0;
        return fold_right$0
                (function(b,accu$1)
                  {var i$0=i,accu=accu$1;
                   for(;;)
                    {if(length$5(b) <= i$0)return accu;
                     var match=get$1(b,i$0);
                     if(match)
                      {var
                        v=match[1],
                        accu$0=caml_call2(f,v,accu),
                        i$1=i$0 + 1 | 0,
                        i$0=i$1,
                        accu=accu$0;
                       continue}
                     var i$2=i$0 + 1 | 0,i$0=i$2;
                     continue}},
                 _mg_,
                 init)}
      function iter(f,t)
       {var _mf_=t[1],i=0;
        return iter$5
                (function(b)
                  {var i$0=i;
                   for(;;)
                    {if(length$5(b) <= i$0)return 0;
                     var match=get$1(b,i$0);
                     if(match)
                      {var v=match[1];
                       caml_call1(f,v);
                       var i$1=i$0 + 1 | 0,i$0=i$1;
                       continue}
                     var i$2=i$0 + 1 | 0,i$0=i$2;
                     continue}},
                 _mf_)}
      function count_bucket(i,b,accu)
       {var i$0=i,accu$0=accu;
        for(;;)
         {if(length$5(b) <= i$0)return accu$0;
          var
           _me_=check$0(b,i$0)?1:0,
           accu$1=accu$0 + _me_ | 0,
           i$1=i$0 + 1 | 0,
           i$0=i$1,
           accu$0=accu$1;
          continue}}
      function count(t)
       {var _l$_=0,_ma_=t[1],_mb_=0;
        return fold_right$0
                (function(_mc_,_md_){return count_bucket(_mb_,_mc_,_md_)},
                 _ma_,
                 _l$_)}
      function add_aux(t,setter,d,h,index)
       {var
         bucket$0=caml_check_bound(t[1],index)[1 + index],
         hashes=caml_check_bound(t[2],index)[1 + index],
         sz=length$5(bucket$0),
         i$3=0;
        for(;;)
         {if(sz <= i$3)
           {var
             newsz=
              min(((3 * sz | 0) / 2 | 0) + 3 | 0,max_array_length - 2 | 0);
            if(newsz <= sz)failwith(cst_Weak_Make_hash_bucket_cann);
            var
             newbucket$0=weak_create(newsz),
             newhashes=caml_make_vect(newsz,0);
            blit$4(bucket$0,0,newbucket$0,0,sz);
            blit$1(hashes,0,newhashes,0,sz);
            caml_call3(setter,newbucket$0,sz,d);
            caml_check_bound(newhashes,sz)[1 + sz] = h;
            caml_check_bound(t[1],index)[1 + index] = newbucket$0;
            caml_check_bound(t[2],index)[1 + index] = newhashes;
            var _l7_=sz <= t[3]?1:0,_l8_=_l7_?t[3] < newsz?1:0:_l7_;
            if(_l8_)
             {t[4] = t[4] + 1 | 0;
              var i$4=0;
              for(;;)
               {var
                 _lX_=t[5],
                 bucket=caml_check_bound(t[1],_lX_)[1 + _lX_],
                 _lY_=t[5],
                 hbucket=caml_check_bound(t[2],_lY_)[1 + _lY_],
                 n=length$5(bucket),
                 prev_len=(((n - 3 | 0) * 2 | 0) + 2 | 0) / 3 | 0,
                 live=count_bucket(0,bucket,0);
                if(live <= prev_len)
                 {var j$2=length$5(bucket) - 1 | 0,i$0=0,j=j$2;
                  for(;;)
                   {if(prev_len <= j)
                     {if(check$0(bucket,i$0))
                       {var i$1=i$0 + 1 | 0,i$0=i$1;continue}
                      if(check$0(bucket,j))
                       {blit$4(bucket,j,bucket,i$0,1);
                        var _lZ_=caml_check_bound(hbucket,j)[1 + j];
                        caml_check_bound(hbucket,i$0)[1 + i$0] = _lZ_;
                        var j$0=j - 1 | 0,i$2=i$0 + 1 | 0,i$0=i$2,j=j$0;
                        continue}
                      var j$1=j - 1 | 0,j=j$1;
                      continue}
                    if(0 === prev_len)
                     {var _l0_=t[5];
                      caml_check_bound(t[1],_l0_)[1 + _l0_] = emptybucket;
                      var _l1_=t[5];
                      caml_check_bound(t[2],_l1_)[1 + _l1_] = [0]}
                    else
                     {var newbucket=weak_create(prev_len);
                      blit$4(bucket,0,newbucket,0,prev_len);
                      var _l4_=t[5];
                      caml_check_bound(t[1],_l4_)[1 + _l4_] = newbucket;
                      var _l5_=sub$1(hbucket,0,prev_len),_l6_=t[5];
                      caml_check_bound(t[2],_l6_)[1 + _l6_] = _l5_}
                    var _l2_=t[3] < n?1:0,_l3_=_l2_?prev_len <= t[3]?1:0:_l2_;
                    if(_l3_)t[4] = t[4] - 1 | 0;
                    break}}
                t[5] = caml_mod(t[5] + 1 | 0,t[1].length - 1);
                var _l__=i$4 + 1 | 0;
                if(2 !== i$4){var i$4=_l__;continue}
                break}}
            var _l9_=((t[1].length - 1) / 2 | 0) < t[4]?1:0;
            if(_l9_)
             {var
               n$0=t[1].length - 1,
               newlen=min(((3 * n$0 | 0) / 2 | 0) + 3 | 0,max_array_length);
              if(n$0 < newlen)
               {var newt=create(newlen),_lW_=t[1],i=0;
                iteri$2
                 (function(j,ob)
                   {var i$0=i;
                    for(;;)
                     {if(length$5(ob) <= i$0)return 0;
                      var match=check$0(ob,i$0);
                      if(match)
                       {var
                         oh=caml_check_bound(t[2],j)[1 + j],
                         setter$0=
                          function(i)
                           {function setter(nb,ni,param){return blit$4(ob,i,nb,ni,1)}
                            return setter},
                         setter=setter$0(i$0),
                         h=caml_check_bound(oh,i$0)[1 + i$0];
                        add_aux(newt,setter,0,h,get_index(newt,h));
                        var i$1=i$0 + 1 | 0,i$0=i$1;
                        continue}
                      var i$2=i$0 + 1 | 0,i$0=i$2;
                      continue}},
                  _lW_);
                t[1] = newt[1];
                t[2] = newt[2];
                t[3] = newt[3];
                t[4] = newt[4];
                t[5] = caml_mod(t[5],newt[1].length - 1);
                return 0}
              t[3] = max_int;
              t[4] = 0;
              return 0}
            return _l9_}
          if(check$0(bucket$0,i$3)){var i$5=i$3 + 1 | 0,i$3=i$5;continue}
          caml_call3(setter,bucket$0,i$3,d);
          caml_check_bound(hashes,i$3)[1 + i$3] = h;
          return 0}}
      function add(t,d)
       {var h=caml_call1(H[2],d);
        return add_aux(t,set$0,[0,d],h,get_index(t,h))}
      function find_or(t,d,ifnotfound)
       {var
         h=caml_call1(H[2],d),
         index=get_index(t,h),
         bucket=caml_check_bound(t[1],index)[1 + index],
         hashes=caml_check_bound(t[2],index)[1 + index],
         sz=length$5(bucket),
         i=0;
        for(;;)
         {if(sz <= i)return caml_call2(ifnotfound,h,index);
          if(h === caml_check_bound(hashes,i)[1 + i])
           {var match=get_copy(bucket,i);
            if(match)
             {var v=match[1];
              if(caml_call2(H[1],v,d))
               {var match$0=get$1(bucket,i);
                if(match$0){var v$0=match$0[1];return v$0}
                var i$0=i + 1 | 0,i=i$0;
                continue}}
            var i$1=i + 1 | 0,i=i$1;
            continue}
          var i$2=i + 1 | 0,i=i$2;
          continue}}
      function merge(t,d)
       {return find_or
                (t,
                 d,
                 function(h,index){add_aux(t,set$0,[0,d],h,index);return d})}
      function find(t,d)
       {return find_or(t,d,function(h,index){throw Not_found})}
      function find_opt(t,d)
       {var
         h=caml_call1(H[2],d),
         index=get_index(t,h),
         bucket=caml_check_bound(t[1],index)[1 + index],
         hashes=caml_check_bound(t[2],index)[1 + index],
         sz=length$5(bucket),
         i=0;
        for(;;)
         {if(sz <= i)return 0;
          if(h === caml_check_bound(hashes,i)[1 + i])
           {var match=get_copy(bucket,i);
            if(match)
             {var v=match[1];
              if(caml_call2(H[1],v,d))
               {var v$0=get$1(bucket,i);
                if(v$0)return v$0;
                var i$0=i + 1 | 0,i=i$0;
                continue}}
            var i$1=i + 1 | 0,i=i$1;
            continue}
          var i$2=i + 1 | 0,i=i$2;
          continue}}
      function find_shadow(t,d,iffound,ifnotfound)
       {var
         h=caml_call1(H[2],d),
         index=get_index(t,h),
         bucket=caml_check_bound(t[1],index)[1 + index],
         hashes=caml_check_bound(t[2],index)[1 + index],
         sz=length$5(bucket),
         i=0;
        for(;;)
         {if(sz <= i)return ifnotfound;
          if(h === caml_check_bound(hashes,i)[1 + i])
           {var match=get_copy(bucket,i);
            if(match)
             {var v=match[1];
              if(caml_call2(H[1],v,d))return caml_call2(iffound,bucket,i)}
            var i$0=i + 1 | 0,i=i$0;
            continue}
          var i$1=i + 1 | 0,i=i$1;
          continue}}
      function remove(t,d)
       {var _lV_=0;
        return find_shadow(t,d,function(w,i){return set$0(w,i,0)},_lV_)}
      function mem(t,d)
       {var _lU_=0;return find_shadow(t,d,function(w,i){return 1},_lU_)}
      function find_all(t,d)
       {var
         h=caml_call1(H[2],d),
         index=get_index(t,h),
         bucket=caml_check_bound(t[1],index)[1 + index],
         hashes=caml_check_bound(t[2],index)[1 + index],
         sz=length$5(bucket),
         i=0,
         accu=0;
        for(;;)
         {if(sz <= i)return accu;
          if(h === caml_check_bound(hashes,i)[1 + i])
           {var match=get_copy(bucket,i);
            if(match)
             {var v=match[1];
              if(caml_call2(H[1],v,d))
               {var match$0=get$1(bucket,i);
                if(match$0)
                 {var
                   v$0=match$0[1],
                   accu$0=[0,v$0,accu],
                   i$0=i + 1 | 0,
                   i=i$0,
                   accu=accu$0;
                  continue}
                var i$1=i + 1 | 0,i=i$1;
                continue}}
            var i$2=i + 1 | 0,i=i$2;
            continue}
          var i$3=i + 1 | 0,i=i$3;
          continue}}
      function stats(t)
       {var len=t[1].length - 1,lens=map$6(length$5,t[1]);
        sort(caml_int_compare,lens);
        var
         _lM_=0,
         totlen=
          fold_left$1(function(_lT_,_lS_){return _lT_ + _lS_ | 0},_lM_,lens),
         _lN_=len - 1 | 0,
         _lP_=len / 2 | 0,
         _lO_=caml_check_bound(lens,_lN_)[1 + _lN_],
         _lQ_=caml_check_bound(lens,_lP_)[1 + _lP_],
         _lR_=caml_check_bound(lens,0)[1];
        return [0,len,count(t),totlen,_lR_,_lQ_,_lO_]}
      return [0,
              create,
              clear,
              merge,
              add,
              remove,
              find,
              find_opt,
              find_all,
              mem,
              iter,
              fold,
              count,
              stats]}
    var
     Stdlib_weak=
      [0,
       weak_create,
       length$5,
       set$0,
       get$1,
       get_copy,
       check$0,
       fill$2,
       blit$4,
       Make$1];
    caml_register_global(800,Stdlib_weak,"Stdlib__weak");
    function id$0(x){return x}
    var
     String_tag=[248,cst_Stdlib_Format_String_tag,caml_fresh_oo_id(0)],
     size=0,
     unknown=-1;
    function pp_enqueue(state,token)
     {state[13] = state[13] + token[3] | 0;return add(token,state[28])}
    var pp_infinity=1000000010;
    function pp_output_string(state,s)
     {return caml_call3(state[17],s,0,caml_ml_string_length(s))}
    function pp_output_newline(state){return caml_call1(state[19],0)}
    function format_pp_text(state,size,text)
     {state[9] = state[9] - size | 0;
      pp_output_string(state,text);
      state[11] = 0;
      return 0}
    function format_string(state,s)
     {var _lL_=caml_string_notequal(s,cst$67);
      return _lL_?format_pp_text(state,caml_ml_string_length(s),s):_lL_}
    function break_new_line(state,param,width)
     {var after=param[3],offset=param[2],before=param[1];
      format_string(state,before);
      pp_output_newline(state);
      state[11] = 1;
      var
       indent=(state[6] - width | 0) + offset | 0,
       real_indent=min(state[8],indent);
      state[10] = real_indent;
      state[9] = state[6] - state[10] | 0;
      caml_call1(state[21],state[10]);
      return format_string(state,after)}
    function break_line(state,width){return break_new_line(state,_cd_,width)}
    function break_same_line(state,param)
     {var after=param[3],width=param[2],before=param[1];
      format_string(state,before);
      state[9] = state[9] - width | 0;
      caml_call1(state[20],width);
      return format_string(state,after)}
    function advance_left(state)
     {for(;;)
       {var match$12=peek_opt(state[28]);
        if(match$12)
         {var
           match$13=match$12[1],
           size$0=match$13[1],
           length$0=match$13[3],
           token=match$13[2],
           pending_count=state[13] - state[12] | 0,
           _lJ_=0 <= size$0?1:0,
           _lK_=_lJ_ || (state[9] <= pending_count?1:0);
          if(_lK_)
           {take(state[28]);
            var size$1=0 <= size$0?size$0:pp_infinity;
            if(typeof token === "number")
             switch(token)
              {case 0:
                var match$3=top_opt(state[3]);
                if(match$3)
                 {var
                   match$4=match$3[1],
                   tabs=match$4[1],
                   add_tab=
                    function(n,ls)
                     {if(ls)
                       {var l=ls[2],x=ls[1];
                        return caml_lessthan(n,x)?[0,n,ls]:[0,x,add_tab(n,l)]}
                      return [0,n,0]};
                  tabs[1] = add_tab(state[6] - state[9] | 0,tabs[1])}
                break;
               case 1:pop_opt(state[2]);break;
               case 2:pop_opt(state[3]);break;
               case 3:
                var match$5=top_opt(state[2]);
                if(match$5)
                 {var match$6=match$5[1],width$0=match$6[2];
                  break_line(state,width$0)}
                else
                 pp_output_newline(state);
                break;
               case 4:
                if(state[10] !== (state[6] - state[9] | 0))
                 {var match$1=take_opt(state[28]);
                  if(match$1)
                   {var match$2=match$1[1],size=match$2[1],length=match$2[3];
                    state[12] = state[12] - length | 0;
                    state[9] = state[9] + size | 0}}
                break;
               default:
                var match$7=pop_opt(state[5]);
                if(match$7)
                 {var
                   tag_name=match$7[1],
                   marker=caml_call1(state[25],tag_name);
                  pp_output_string(state,marker)}}
            else
             switch(token[0])
              {case 0:var s=token[1];format_pp_text(state,size$1,s);break;
               case 1:
                var
                 breaks=token[2],
                 fits=token[1],
                 off=breaks[2],
                 before=breaks[1],
                 match$8=top_opt(state[2]);
                if(match$8)
                 {var
                   match$9=match$8[1],
                   width$1=match$9[2],
                   box_type$0=match$9[1];
                  switch(box_type$0)
                   {case 0:break_same_line(state,fits);break;
                    case 1:break_new_line(state,breaks,width$1);break;
                    case 2:break_new_line(state,breaks,width$1);break;
                    case 3:
                     if(state[9] < (size$1 + caml_ml_string_length(before) | 0))
                      break_new_line(state,breaks,width$1);
                     else
                      break_same_line(state,fits);
                     break;
                    case 4:
                     if(state[11])
                      break_same_line(state,fits);
                     else
                      if(state[9] < (size$1 + caml_ml_string_length(before) | 0))
                       break_new_line(state,breaks,width$1);
                      else
                       if(((state[6] - width$1 | 0) + off | 0) < state[10])
                        break_new_line(state,breaks,width$1);
                       else
                        break_same_line(state,fits);
                     break;
                    default:break_same_line(state,fits)}}
                break;
               case 2:
                var
                 off$0=token[2],
                 n=token[1],
                 insertion_point=state[6] - state[9] | 0,
                 match$10=top_opt(state[3]);
                if(match$10)
                 {var match$11=match$10[1],tabs$0=match$11[1],_lH_=tabs$0[1];
                  if(_lH_)
                   {var first=_lH_[1],param=tabs$0[1];
                    for(;;)
                     {if(param)
                       {var tail=param[2],head=param[1];
                        if(! (insertion_point <= head)){var param=tail;continue}
                        var _lI_=head}
                      else
                       var _lI_=first;
                      var tab=_lI_;
                      break}}
                  else
                   var tab=insertion_point;
                  var offset=tab - insertion_point | 0;
                  if(0 <= offset)
                   break_same_line(state,[0,cst$69,offset + n | 0,cst$68]);
                  else
                   break_new_line
                    (state,[0,cst$71,tab + off$0 | 0,cst$70],state[6])}
                break;
               case 3:
                var
                 ty=token[2],
                 off$1=token[1],
                 insertion_point$0=state[6] - state[9] | 0;
                if(state[8] < insertion_point$0)
                 {var match=top_opt(state[2]);
                  if(match)
                   {var match$0=match[1],width=match$0[2],box_type=match$0[1];
                    if(state[9] < width)
                     {var switcher=box_type - 1 | 0;
                      if(! (3 < switcher >>> 0))break_line(state,width)}}
                  else
                   pp_output_newline(state)}
                var
                 width$2=state[9] - off$1 | 0,
                 box_type$1=1 === ty?1:state[9] < size$1?ty:5;
                push([0,box_type$1,width$2],state[2]);
                break;
               case 4:var tbox=token[1];push(tbox,state[3]);break;
               default:
                var
                 tag_name$0=token[1],
                 marker$0=caml_call1(state[24],tag_name$0);
                pp_output_string(state,marker$0);
                push(tag_name$0,state[5])}
            state[12] = length$0 + state[12] | 0;
            continue}
          return _lK_}
        return 0}}
    function enqueue_advance(state,tok)
     {pp_enqueue(state,tok);return advance_left(state)}
    function enqueue_string_as(state,size,s)
     {return enqueue_advance(state,[0,size,[0,s],size])}
    function initialize_scan_stack(stack)
     {clear(stack);
      var queue_elem=[0,unknown,_ce_,0];
      return push([0,-1,queue_elem],stack)}
    function set_size(state,ty)
     {var match=top_opt(state[1]);
      if(match)
       {var
         match$0=match[1],
         queue_elem=match$0[2],
         left_total=match$0[1],
         _lE_=queue_elem[1];
        if(left_total < state[12])return initialize_scan_stack(state[1]);
        var _lF_=queue_elem[2];
        if(typeof _lF_ !== "number")
         switch(_lF_[0])
          {case 3:
            var _lG_=1 - ty;
            return _lG_
                    ?(queue_elem[1] = state[13] + _lE_ | 0,pop_opt(state[1]),0)
                    :_lG_;
           case 1:
           case 2:
            return ty
                    ?(queue_elem[1] = state[13] + _lE_ | 0,pop_opt(state[1]),0)
                    :ty
           }
        return 0}
      return 0}
    function scan_push(state,b,token)
     {pp_enqueue(state,token);
      if(b)set_size(state,1);
      var elem=[0,state[13],token];
      return push(elem,state[1])}
    function pp_open_box_gen(state,indent,br_ty)
     {state[14] = state[14] + 1 | 0;
      if(state[14] < state[15])
       {var size=- state[13] | 0,elem=[0,size,[3,indent,br_ty],0];
        return scan_push(state,0,elem)}
      var _lC_=state[14] === state[15]?1:0;
      if(_lC_)
       {var _lD_=state[16];
        return enqueue_string_as(state,caml_ml_string_length(_lD_),_lD_)}
      return _lC_}
    function pp_close_box(state,param)
     {var _lA_=1 < state[14]?1:0;
      if(_lA_)
       {if(state[14] < state[15])
         {pp_enqueue(state,[0,size,1,0]);set_size(state,1);set_size(state,0)}
        state[14] = state[14] - 1 | 0;
        var _lB_=0}
      else
       var _lB_=_lA_;
      return _lB_}
    function pp_open_stag(state,tag_name)
     {if(state[22]){push(tag_name,state[4]);caml_call1(state[26],tag_name)}
      var _lz_=state[23];
      if(_lz_)
       {var token=[5,tag_name];return pp_enqueue(state,[0,size,token,0])}
      return _lz_}
    function pp_close_stag(state,param)
     {if(state[23])pp_enqueue(state,[0,size,5,0]);
      var _lx_=state[22];
      if(_lx_)
       {var match=pop_opt(state[4]);
        if(match){var tag_name=match[1];return caml_call1(state[27],tag_name)}
        var _ly_=0}
      else
       var _ly_=_lx_;
      return _ly_}
    function pp_open_tag(state,s){return pp_open_stag(state,[0,String_tag,s])}
    function pp_close_tag(state,param){return pp_close_stag(state,0)}
    function pp_set_print_tags(state,b){state[22] = b;return 0}
    function pp_set_mark_tags(state,b){state[23] = b;return 0}
    function pp_get_print_tags(state,param){return state[22]}
    function pp_get_mark_tags(state,param){return state[23]}
    function pp_set_tags(state,b)
     {pp_set_print_tags(state,b);return pp_set_mark_tags(state,b)}
    function pp_get_formatter_stag_function(state,param)
     {return [0,state[24],state[25],state[26],state[27]]}
    function pp_set_formatter_stag_function(state,param)
     {var pct=param[4],pot=param[3],mct=param[2],mot=param[1];
      state[24] = mot;
      state[25] = mct;
      state[26] = pot;
      state[27] = pct;
      return 0}
    function pp_rinit(state)
     {state[12] = 1;
      state[13] = 1;
      clear$0(state[28]);
      initialize_scan_stack(state[1]);
      clear(state[2]);
      clear(state[3]);
      clear(state[4]);
      clear(state[5]);
      state[10] = 0;
      state[14] = 0;
      state[9] = state[6];
      return pp_open_box_gen(state,0,3)}
    function pp_flush_queue(state,b)
     {var _lw_=state[4];
      iter$7(function(param){return pp_close_tag(state,0)},_lw_);
      for(;;)
       {if(1 < state[14]){pp_close_box(state,0);continue}
        state[13] = pp_infinity;
        advance_left(state);
        if(b)pp_output_newline(state);
        return pp_rinit(state)}}
    function pp_print_as_size(state,size,s)
     {var _lv_=state[14] < state[15]?1:0;
      return _lv_?enqueue_string_as(state,size,s):_lv_}
    function pp_print_as(state,isize,s)
     {return pp_print_as_size(state,isize,s)}
    function pp_print_string(state,s)
     {return pp_print_as(state,caml_ml_string_length(s),s)}
    function pp_print_int(state,i)
     {return pp_print_string(state,caml_string_of_jsbytes("" + i))}
    function pp_print_float(state,f)
     {return pp_print_string(state,to_string(f))}
    function pp_print_bool(state,b)
     {return pp_print_string(state,string_of_bool(b))}
    function pp_print_char(state,c){return pp_print_as(state,1,make$1(1,c))}
    function pp_open_hbox(state,param){return pp_open_box_gen(state,0,0)}
    function pp_open_vbox(state,indent)
     {return pp_open_box_gen(state,indent,1)}
    function pp_open_hvbox(state,indent)
     {return pp_open_box_gen(state,indent,2)}
    function pp_open_hovbox(state,indent)
     {return pp_open_box_gen(state,indent,3)}
    function pp_open_box(state,indent){return pp_open_box_gen(state,indent,4)}
    function pp_print_newline(state,param)
     {pp_flush_queue(state,1);return caml_call1(state[18],0)}
    function pp_print_flush(state,param)
     {pp_flush_queue(state,0);return caml_call1(state[18],0)}
    function pp_force_newline(state,param)
     {var _lu_=state[14] < state[15]?1:0;
      return _lu_?enqueue_advance(state,[0,size,3,0]):_lu_}
    function pp_print_if_newline(state,param)
     {var _lt_=state[14] < state[15]?1:0;
      return _lt_?enqueue_advance(state,[0,size,4,0]):_lt_}
    function pp_print_custom_break(state,fits,breaks)
     {var
       after=fits[3],
       width=fits[2],
       before=fits[1],
       _ls_=state[14] < state[15]?1:0;
      if(_ls_)
       {var
         size=- state[13] | 0,
         token=[1,fits,breaks],
         length=
          (caml_ml_string_length(before) + width | 0)
          +
          caml_ml_string_length(after)
          |
          0,
         elem=[0,size,token,length];
        return scan_push(state,1,elem)}
      return _ls_}
    function pp_print_break(state,width,offset)
     {return pp_print_custom_break
              (state,[0,cst$75,width,cst$74],[0,cst$73,offset,cst$72])}
    function pp_print_space(state,param){return pp_print_break(state,1,0)}
    function pp_print_cut(state,param){return pp_print_break(state,0,0)}
    function pp_open_tbox(state,param)
     {state[14] = state[14] + 1 | 0;
      var _lr_=state[14] < state[15]?1:0;
      if(_lr_)
       {var elem=[0,size,[4,[0,[0,0]]],0];return enqueue_advance(state,elem)}
      return _lr_}
    function pp_close_tbox(state,param)
     {var _lo_=1 < state[14]?1:0;
      if(_lo_)
       {var _lp_=state[14] < state[15]?1:0;
        if(_lp_)
         {var elem=[0,size,2,0];
          enqueue_advance(state,elem);
          state[14] = state[14] - 1 | 0;
          var _lq_=0}
        else
         var _lq_=_lp_}
      else
       var _lq_=_lo_;
      return _lq_}
    function pp_print_tbreak(state,width,offset)
     {var _ln_=state[14] < state[15]?1:0;
      if(_ln_)
       {var size=- state[13] | 0,elem=[0,size,[2,width,offset],width];
        return scan_push(state,1,elem)}
      return _ln_}
    function pp_print_tab(state,param){return pp_print_tbreak(state,0,0)}
    function pp_set_tab(state,param)
     {var _lm_=state[14] < state[15]?1:0;
      if(_lm_){var elem=[0,size,0,0];return enqueue_advance(state,elem)}
      return _lm_}
    function pp_set_max_boxes(state,n)
     {var _lk_=1 < n?1:0,_ll_=_lk_?(state[15] = n,0):_lk_;return _ll_}
    function pp_get_max_boxes(state,param){return state[15]}
    function pp_over_max_boxes(state,param)
     {return state[14] === state[15]?1:0}
    function pp_set_ellipsis_text(state,s){state[16] = s;return 0}
    function pp_get_ellipsis_text(state,param){return state[16]}
    function pp_limit(n){return n < 1000000010?n:1000000009}
    function pp_set_max_indent(state,n$0)
     {var _lj_=1 < n$0?1:0;
      if(_lj_)
       {var n$1=state[6] - n$0 | 0,_li_=1 <= n$1?1:0;
        if(_li_)
         {var n=pp_limit(n$1);
          state[7] = n;
          state[8] = state[6] - state[7] | 0;
          return pp_rinit(state)}
        return _li_}
      return _lj_}
    function pp_get_max_indent(state,param){return state[8]}
    function pp_set_margin(state,n)
     {var _lh_=1 <= n?1:0;
      if(_lh_)
       {var n$0=pp_limit(n);
        state[6] = n$0;
        var
         new_max_indent=
          state[8] <= state[6]
           ?state[8]
           :max(max(state[6] - state[7] | 0,state[6] / 2 | 0),1);
        return pp_set_max_indent(state,new_max_indent)}
      return _lh_}
    function validate_geometry(param)
     {var margin=param[2],max_indent=param[1];
      return 2 <= max_indent?margin <= max_indent?_cf_:_cg_:_ch_}
    function check_geometry(geometry)
     {var match=validate_geometry(geometry);return 0 === match[0]?1:0}
    function pp_get_margin(state,param){return state[6]}
    function pp_set_full_geometry(state,param)
     {var margin=param[2],max_indent=param[1];
      pp_set_margin(state,margin);
      pp_set_max_indent(state,max_indent);
      return 0}
    function pp_set_geometry(state,max_indent,margin)
     {var geometry=[0,max_indent,margin],match=validate_geometry(geometry);
      if(0 === match[0])return pp_set_full_geometry(state,geometry);
      var msg=match[1];
      throw [0,Invalid_argument,symbol(cst_Format_pp_set_geometry,msg)]}
    function pp_safe_set_geometry(state,max_indent,margin)
     {var geometry=[0,max_indent,margin],match=validate_geometry(geometry);
      return 0 === match[0]?pp_set_full_geometry(state,geometry):0}
    function pp_get_geometry(state,param){return [0,state[8],state[6]]}
    function pp_update_geometry(state,update)
     {var geometry=pp_get_geometry(state,0);
      return pp_set_full_geometry(state,caml_call1(update,geometry))}
    function pp_set_formatter_out_functions(state,param)
     {var j=param[5],i=param[4],h=param[3],g=param[2],f=param[1];
      state[17] = f;
      state[18] = g;
      state[19] = h;
      state[20] = i;
      state[21] = j;
      return 0}
    function pp_get_formatter_out_functions(state,param)
     {return [0,state[17],state[18],state[19],state[20],state[21]]}
    function pp_set_formatter_output_functi(state,f,g)
     {state[17] = f;state[18] = g;return 0}
    function pp_get_formatter_output_functi(state,param)
     {return [0,state[17],state[18]]}
    function display_newline(state,param)
     {return caml_call3(state[17],cst$76,0,1)}
    var blank_line=make$1(80,32);
    function display_indent(state,n)
     {var n$0=n;
      for(;;)
       {var _lg_=0 < n$0?1:0;
        if(_lg_)
         {if(80 < n$0)
           {caml_call3(state[17],blank_line,0,80);
            var n$1=n$0 - 80 | 0,n$0=n$1;
            continue}
          return caml_call3(state[17],blank_line,0,n$0)}
        return _lg_}}
    function pp_set_formatter_out_channel(state,oc)
     {state[17]
      =
      function(_ld_,_le_,_lf_){return output_substring(oc,_ld_,_le_,_lf_)};
      state[18] = function(param){return caml_ml_flush(oc)};
      state[19] = function(_lc_){return display_newline(state,_lc_)};
      state[20] = function(_lb_){return display_indent(state,_lb_)};
      state[21] = function(_la_){return display_indent(state,_la_)};
      return 0}
    function default_pp_mark_open_tag(param)
     {if(param[1] === String_tag)
       {var s=param[2];return symbol(cst$78,symbol(s,cst$77))}
      return cst$79}
    function default_pp_mark_close_tag(param)
     {if(param[1] === String_tag)
       {var s=param[2];return symbol(cst$81,symbol(s,cst$80))}
      return cst$82}
    function default_pp_print_open_tag(_k$_){return 0}
    function default_pp_print_close_tag(_k__){return 0}
    function pp_make_formatter(f,g,h,i,j)
     {var pp_queue=create$1(0),sys_tok=[0,unknown,_ci_,0];
      add(sys_tok,pp_queue);
      var scan_stack=create$0(0);
      initialize_scan_stack(scan_stack);
      push([0,1,sys_tok],scan_stack);
      var _k7_=create$0(0),_k8_=create$0(0),_k9_=create$0(0);
      return [0,
              scan_stack,
              create$0(0),
              _k9_,
              _k8_,
              _k7_,
              78,
              10,
              68,
              78,
              0,
              1,
              1,
              1,
              1,
              max_int,
              cst$83,
              f,
              g,
              h,
              i,
              j,
              0,
              0,
              default_pp_mark_open_tag,
              default_pp_mark_close_tag,
              default_pp_print_open_tag,
              default_pp_print_close_tag,
              pp_queue]}
    function formatter_of_out_functions(out_funs)
     {return pp_make_formatter
              (out_funs[1],out_funs[2],out_funs[3],out_funs[4],out_funs[5])}
    function make_formatter(output,flush)
     {function _kZ_(_k6_){return 0}
      function _k0_(_k5_){return 0}
      var
       ppf=
        pp_make_formatter(output,flush,function(_k4_){return 0},_k0_,_kZ_);
      ppf[19] = function(_k3_){return display_newline(ppf,_k3_)};
      ppf[20] = function(_k2_){return display_indent(ppf,_k2_)};
      ppf[21] = function(_k1_){return display_indent(ppf,_k1_)};
      return ppf}
    function formatter_of_out_channel(oc)
     {function _kV_(param){return caml_ml_flush(oc)}
      return make_formatter
              (function(_kW_,_kX_,_kY_)
                {return output_substring(oc,_kW_,_kX_,_kY_)},
               _kV_)}
    function formatter_of_buffer(b)
     {function _kQ_(_kU_){return 0}
      return make_formatter
              (function(_kR_,_kS_,_kT_)
                {return add_substring(b,_kR_,_kS_,_kT_)},
               _kQ_)}
    var pp_buffer_size=512;
    function pp_make_buffer(param){return create$2(pp_buffer_size)}
    var
     stdbuf=pp_make_buffer(0),
     std_formatter=formatter_of_out_channel(stdout),
     err_formatter=formatter_of_out_channel(stderr),
     str_formatter=formatter_of_buffer(stdbuf);
    function flush_buffer_formatter(buf,ppf)
     {pp_flush_queue(ppf,0);var s=contents(buf);reset(buf);return s}
    function flush_str_formatter(param)
     {return flush_buffer_formatter(stdbuf,str_formatter)}
    function make_symbolic_output_buffer(param){return [0,0]}
    function clear_symbolic_output_buffer(sob){sob[1] = 0;return 0}
    function get_symbolic_output_buffer(sob){return rev(sob[1])}
    function flush_symbolic_output_buffer(sob)
     {var items=get_symbolic_output_buffer(sob);
      clear_symbolic_output_buffer(sob);
      return items}
    function add_symbolic_output_item(sob,item)
     {sob[1] = [0,item,sob[1]];return 0}
    function formatter_of_symbolic_output_b(sob)
     {function f(s,i,n){return add_symbolic_output_item(sob,[0,sub$0(s,i,n)])}
      function g(_kP_){return add_symbolic_output_item(sob,0)}
      function h(_kO_){return add_symbolic_output_item(sob,1)}
      function i(n){return add_symbolic_output_item(sob,[1,n])}
      function j(n){return add_symbolic_output_item(sob,[2,n])}
      return pp_make_formatter(f,g,h,i,j)}
    function open_hbox(_kN_){return pp_open_hbox(std_formatter,_kN_)}
    function open_vbox(_kM_){return pp_open_vbox(std_formatter,_kM_)}
    function open_hvbox(_kL_){return pp_open_hvbox(std_formatter,_kL_)}
    function open_hovbox(_kK_){return pp_open_hovbox(std_formatter,_kK_)}
    function open_box(_kJ_){return pp_open_box(std_formatter,_kJ_)}
    function close_box(_kI_){return pp_close_box(std_formatter,_kI_)}
    function open_tag(_kH_){return pp_open_tag(std_formatter,_kH_)}
    function close_tag(_kG_){return pp_close_tag(std_formatter,_kG_)}
    function open_stag(_kF_){return pp_open_stag(std_formatter,_kF_)}
    function close_stag(_kE_){return pp_close_stag(std_formatter,_kE_)}
    function print_as(_kC_,_kD_){return pp_print_as(std_formatter,_kC_,_kD_)}
    function print_string$0(_kB_){return pp_print_string(std_formatter,_kB_)}
    function print_int$0(_kA_){return pp_print_int(std_formatter,_kA_)}
    function print_float$0(_kz_){return pp_print_float(std_formatter,_kz_)}
    function print_char$0(_ky_){return pp_print_char(std_formatter,_ky_)}
    function print_bool(_kx_){return pp_print_bool(std_formatter,_kx_)}
    function print_break(_kv_,_kw_)
     {return pp_print_break(std_formatter,_kv_,_kw_)}
    function print_cut(_ku_){return pp_print_cut(std_formatter,_ku_)}
    function print_space(_kt_){return pp_print_space(std_formatter,_kt_)}
    function force_newline(_ks_){return pp_force_newline(std_formatter,_ks_)}
    function print_flush(_kr_){return pp_print_flush(std_formatter,_kr_)}
    function print_newline$0(_kq_)
     {return pp_print_newline(std_formatter,_kq_)}
    function print_if_newline(_kp_)
     {return pp_print_if_newline(std_formatter,_kp_)}
    function open_tbox(_ko_){return pp_open_tbox(std_formatter,_ko_)}
    function close_tbox(_kn_){return pp_close_tbox(std_formatter,_kn_)}
    function print_tbreak(_kl_,_km_)
     {return pp_print_tbreak(std_formatter,_kl_,_km_)}
    function set_tab(_kk_){return pp_set_tab(std_formatter,_kk_)}
    function print_tab(_kj_){return pp_print_tab(std_formatter,_kj_)}
    function set_margin(_ki_){return pp_set_margin(std_formatter,_ki_)}
    function get_margin(_kh_){return std_formatter[6]}
    function set_max_indent(_kg_)
     {return pp_set_max_indent(std_formatter,_kg_)}
    function get_max_indent(_kf_){return std_formatter[8]}
    function set_geometry(_kd_,_ke_)
     {return pp_set_geometry(std_formatter,_kd_,_ke_)}
    function safe_set_geometry(_kb_,_kc_)
     {return pp_safe_set_geometry(std_formatter,_kb_,_kc_)}
    function get_geometry(_ka_){return pp_get_geometry(std_formatter,_ka_)}
    function update_geometry(_j$_)
     {return pp_update_geometry(std_formatter,_j$_)}
    function set_max_boxes(_j__){return pp_set_max_boxes(std_formatter,_j__)}
    function get_max_boxes(_j9_){return std_formatter[15]}
    function over_max_boxes(_j8_)
     {return pp_over_max_boxes(std_formatter,_j8_)}
    function set_ellipsis_text(_j7_)
     {return pp_set_ellipsis_text(std_formatter,_j7_)}
    function get_ellipsis_text(_j6_){return std_formatter[16]}
    function set_formatter_out_channel(_j5_)
     {return pp_set_formatter_out_channel(std_formatter,_j5_)}
    function set_formatter_out_functions(_j4_)
     {return pp_set_formatter_out_functions(std_formatter,_j4_)}
    function get_formatter_out_functions(_j3_)
     {return pp_get_formatter_out_functions(std_formatter,_j3_)}
    function set_formatter_output_functions(_j1_,_j2_)
     {return pp_set_formatter_output_functi(std_formatter,_j1_,_j2_)}
    function get_formatter_output_functions(_j0_)
     {return pp_get_formatter_output_functi(std_formatter,_j0_)}
    function set_formatter_stag_functions(_jZ_)
     {return pp_set_formatter_stag_function(std_formatter,_jZ_)}
    function get_formatter_stag_functions(_jY_)
     {return pp_get_formatter_stag_function(std_formatter,_jY_)}
    function set_print_tags(_jX_)
     {return pp_set_print_tags(std_formatter,_jX_)}
    function get_print_tags(_jW_){return std_formatter[22]}
    function set_mark_tags(_jV_){return pp_set_mark_tags(std_formatter,_jV_)}
    function get_mark_tags(_jU_){return std_formatter[23]}
    function set_tags(_jT_){return pp_set_tags(std_formatter,_jT_)}
    function pp_print_list(opt,pp_v,ppf,param)
     {var opt$0=opt,param$0=param;
      for(;;)
       {if(opt$0)var sth=opt$0[1],pp_sep=sth;else var pp_sep=pp_print_cut;
        if(param$0)
         {var _jS_=param$0[1];
          if(param$0[2])
           {var vs=param$0[2];
            caml_call2(pp_v,ppf,_jS_);
            caml_call2(pp_sep,ppf,0);
            var opt$1=[0,pp_sep],opt$0=opt$1,param$0=vs;
            continue}
          return caml_call2(pp_v,ppf,_jS_)}
        return 0}}
    function pp_print_seq(opt,pp_v,ppf,seq$1)
     {if(opt)var sth=opt[1],pp_sep=sth;else var pp_sep=pp_print_cut;
      var match$0=caml_call1(seq$1,0);
      if(match$0)
       {var seq$2=match$0[2],v$0=match$0[1];
        caml_call2(pp_v,ppf,v$0);
        var seq=seq$2;
        for(;;)
         {var match=caml_call1(seq,0);
          if(match)
           {var seq$0=match[2],v=match[1];
            caml_call2(pp_sep,ppf,0);
            caml_call2(pp_v,ppf,v);
            var seq=seq$0;
            continue}
          return 0}}
      return 0}
    function pp_print_text(ppf,s)
     {var len=caml_ml_string_length(s),left=[0,0],right=[0,0];
      function flush(param)
       {pp_print_string(ppf,sub$0(s,left[1],right[1] - left[1] | 0));
        right[1]++;
        left[1] = right[1];
        return 0}
      for(;;)
       {if(right[1] !== len)
         {var match=caml_string_get(s,right[1]);
          if(10 === match)
           {flush(0);pp_force_newline(ppf,0)}
          else
           if(32 === match){flush(0);pp_print_space(ppf,0)}else right[1]++;
          continue}
        var _jR_=left[1] !== len?1:0;
        return _jR_?flush(0):_jR_}}
    function pp_print_option(opt,pp_v,ppf,param)
     {if(opt)
       var sth=opt[1],none=sth;
      else
       var none=function(param,_jQ_){return 0};
      if(param){var v=param[1];return caml_call2(pp_v,ppf,v)}
      return caml_call2(none,ppf,0)}
    function pp_print_result(ok,error,ppf,param)
     {if(0 === param[0]){var v=param[1];return caml_call2(ok,ppf,v)}
      var e=param[1];
      return caml_call2(error,ppf,e)}
    function compute_tag(output,tag_acc)
     {var buf=create$2(16),ppf=formatter_of_buffer(buf);
      caml_call2(output,ppf,tag_acc);
      pp_print_flush(ppf,0);
      var len=buf[2];
      return 2 <= len?sub$3(buf,1,len - 2 | 0):contents(buf)}
    function output_formatting_lit(ppf,fmting_lit)
     {if(typeof fmting_lit === "number")
       switch(fmting_lit)
        {case 0:return pp_close_box(ppf,0);
         case 1:return pp_close_tag(ppf,0);
         case 2:return pp_print_flush(ppf,0);
         case 3:return pp_force_newline(ppf,0);
         case 4:return pp_print_newline(ppf,0);
         case 5:return pp_print_char(ppf,64);
         default:return pp_print_char(ppf,37)}
      else
       switch(fmting_lit[0])
        {case 0:
          var offset=fmting_lit[3],width=fmting_lit[2];
          return pp_print_break(ppf,width,offset);
         case 1:return 0;
         default:
          var c=fmting_lit[1];
          pp_print_char(ppf,64);
          return pp_print_char(ppf,c)}}
    function output_acc$0(ppf,acc)
     {var switch$0=0;
      if(typeof acc === "number")
       return 0;
      else
       switch(acc[0])
        {case 0:
          var f=acc[2],p=acc[1];
          output_acc$0(ppf,p);
          return output_formatting_lit(ppf,f);
         case 1:
          var _jG_=acc[2],_jH_=acc[1];
          if(0 === _jG_[0])
           {var acc$0=_jG_[1];
            output_acc$0(ppf,_jH_);
            return pp_open_stag
                    (ppf,[0,String_tag,compute_tag(output_acc$0,acc$0)])}
          var acc$1=_jG_[1];
          output_acc$0(ppf,_jH_);
          var
           match=open_box_of_string(compute_tag(output_acc$0,acc$1)),
           bty=match[2],
           indent=match[1];
          return pp_open_box_gen(ppf,indent,bty);
         case 2:
          var _jI_=acc[1],switch$1=0;
          if(typeof _jI_ !== "number" && 0 === _jI_[0])
           {var _jJ_=_jI_[2],switch$2=0;
            if(typeof _jJ_ !== "number" && 1 === _jJ_[0])
             {var s$0=acc[2],size=_jJ_[2],p$1=_jI_[1];
              switch$1 = 1;
              switch$2 = 1}}
          if(! switch$1){var s=acc[2],p$0=_jI_;switch$0 = 2}
          break;
         case 3:
          var _jK_=acc[1],switch$3=0;
          if(typeof _jK_ !== "number" && 0 === _jK_[0])
           {var _jL_=_jK_[2],switch$4=0;
            if(typeof _jL_ !== "number" && 1 === _jL_[0])
             {var c$0=acc[2],size$0=_jL_[2],p$3=_jK_[1];
              switch$0 = 1;
              switch$3 = 1;
              switch$4 = 1}}
          if(! switch$3){var c=acc[2],p$2=_jK_;switch$0 = 3}
          break;
         case 4:
          var _jM_=acc[1],switch$5=0;
          if(typeof _jM_ !== "number" && 0 === _jM_[0])
           {var _jN_=_jM_[2],switch$6=0;
            if(typeof _jN_ !== "number" && 1 === _jN_[0])
             {var s$0=acc[2],size=_jN_[2],p$1=_jM_[1];
              switch$5 = 1;
              switch$6 = 1}}
          if(! switch$5){var s=acc[2],p$0=_jM_;switch$0 = 2}
          break;
         case 5:
          var _jO_=acc[1],switch$7=0;
          if(typeof _jO_ === "number" || ! (0 === _jO_[0]))
           switch$7 = 1;
          else
           {var _jP_=_jO_[2],switch$8=0;
            if(typeof _jP_ !== "number" && 1 === _jP_[0])
             {var c$0=acc[2],size$0=_jP_[2],p$3=_jO_[1];
              switch$0 = 1;
              switch$8 = 1}
            if(! switch$8)switch$7 = 1}
          if(switch$7){var c=acc[2],p$2=_jO_;switch$0 = 3}
          break;
         case 6:
          var f$0=acc[2],p$4=acc[1];
          output_acc$0(ppf,p$4);
          return caml_call1(f$0,ppf);
         case 7:
          var p$5=acc[1];output_acc$0(ppf,p$5);return pp_print_flush(ppf,0);
         default:
          var msg=acc[2],p$6=acc[1];
          output_acc$0(ppf,p$6);
          return invalid_arg(msg)}
      switch(switch$0)
       {case 0:output_acc$0(ppf,p$1);return pp_print_as_size(ppf,size,s$0);
        case 1:
         output_acc$0(ppf,p$3);
         return pp_print_as_size(ppf,size$0,make$1(1,c$0));
        case 2:output_acc$0(ppf,p$0);return pp_print_string(ppf,s);
        default:output_acc$0(ppf,p$2);return pp_print_char(ppf,c)}}
    function strput_acc$0(ppf,acc)
     {var switch$0=0;
      if(typeof acc === "number")
       return 0;
      else
       switch(acc[0])
        {case 0:
          var f=acc[2],p=acc[1];
          strput_acc$0(ppf,p);
          return output_formatting_lit(ppf,f);
         case 1:
          var _ju_=acc[2],_jv_=acc[1];
          if(0 === _ju_[0])
           {var acc$0=_ju_[1];
            strput_acc$0(ppf,_jv_);
            return pp_open_stag
                    (ppf,[0,String_tag,compute_tag(strput_acc$0,acc$0)])}
          var acc$1=_ju_[1];
          strput_acc$0(ppf,_jv_);
          var
           match=open_box_of_string(compute_tag(strput_acc$0,acc$1)),
           bty=match[2],
           indent=match[1];
          return pp_open_box_gen(ppf,indent,bty);
         case 2:
          var _jw_=acc[1],switch$1=0;
          if(typeof _jw_ !== "number" && 0 === _jw_[0])
           {var _jx_=_jw_[2],switch$2=0;
            if(typeof _jx_ !== "number" && 1 === _jx_[0])
             {var s$0=acc[2],size=_jx_[2],p$1=_jw_[1];
              switch$1 = 1;
              switch$2 = 1}}
          if(! switch$1){var s=acc[2],p$0=_jw_;switch$0 = 2}
          break;
         case 3:
          var _jy_=acc[1],switch$3=0;
          if(typeof _jy_ !== "number" && 0 === _jy_[0])
           {var _jz_=_jy_[2],switch$4=0;
            if(typeof _jz_ !== "number" && 1 === _jz_[0])
             {var c$0=acc[2],size$0=_jz_[2],p$3=_jy_[1];
              switch$0 = 1;
              switch$3 = 1;
              switch$4 = 1}}
          if(! switch$3){var c=acc[2],p$2=_jy_;switch$0 = 3}
          break;
         case 4:
          var _jA_=acc[1],switch$5=0;
          if(typeof _jA_ !== "number" && 0 === _jA_[0])
           {var _jB_=_jA_[2],switch$6=0;
            if(typeof _jB_ !== "number" && 1 === _jB_[0])
             {var s$0=acc[2],size=_jB_[2],p$1=_jA_[1];
              switch$5 = 1;
              switch$6 = 1}}
          if(! switch$5){var s=acc[2],p$0=_jA_;switch$0 = 2}
          break;
         case 5:
          var _jC_=acc[1],switch$7=0;
          if(typeof _jC_ === "number" || ! (0 === _jC_[0]))
           switch$7 = 1;
          else
           {var _jD_=_jC_[2],switch$8=0;
            if(typeof _jD_ !== "number" && 1 === _jD_[0])
             {var c$0=acc[2],size$0=_jD_[2],p$3=_jC_[1];
              switch$0 = 1;
              switch$8 = 1}
            if(! switch$8)switch$7 = 1}
          if(switch$7){var c=acc[2],p$2=_jC_;switch$0 = 3}
          break;
         case 6:
          var _jE_=acc[1];
          if(typeof _jE_ !== "number" && 0 === _jE_[0])
           {var _jF_=_jE_[2];
            if(typeof _jF_ !== "number" && 1 === _jF_[0])
             {var f$1=acc[2],size$1=_jF_[2],p$4=_jE_[1];
              strput_acc$0(ppf,p$4);
              return pp_print_as_size(ppf,size$1,caml_call1(f$1,0))}}
          var f$0=acc[2];
          strput_acc$0(ppf,_jE_);
          return pp_print_string(ppf,caml_call1(f$0,0));
         case 7:
          var p$5=acc[1];strput_acc$0(ppf,p$5);return pp_print_flush(ppf,0);
         default:
          var msg=acc[2],p$6=acc[1];
          strput_acc$0(ppf,p$6);
          return invalid_arg(msg)}
      switch(switch$0)
       {case 0:strput_acc$0(ppf,p$1);return pp_print_as_size(ppf,size,s$0);
        case 1:
         strput_acc$0(ppf,p$3);
         return pp_print_as_size(ppf,size$0,make$1(1,c$0));
        case 2:strput_acc$0(ppf,p$0);return pp_print_string(ppf,s);
        default:strput_acc$0(ppf,p$2);return pp_print_char(ppf,c)}}
    function kfprintf$0(k,ppf,param)
     {var fmt=param[1],_jt_=0;
      return make_printf
              (function(acc){output_acc$0(ppf,acc);return caml_call1(k,ppf)},
               _jt_,
               fmt)}
    function ikfprintf$0(k,ppf,param)
     {var fmt=param[1];return make_iprintf(k,ppf,fmt)}
    function ifprintf$0(ppf,param)
     {var fmt=param[1],_jr_=0;
      return make_iprintf(function(_js_){return 0},_jr_,fmt)}
    function fprintf$0(ppf)
     {function _jo_(_jq_){return 0}
      return function(_jp_){return kfprintf$0(_jo_,ppf,_jp_)}}
    function printf$0(fmt){return caml_call1(fprintf$0(std_formatter),fmt)}
    function eprintf$0(fmt){return caml_call1(fprintf$0(err_formatter),fmt)}
    function kdprintf(k,param)
     {var fmt=param[1],_jn_=0;
      return make_printf
              (function(acc)
                {return caml_call1
                         (k,function(ppf){return output_acc$0(ppf,acc)})},
               _jn_,
               fmt)}
    function dprintf(fmt){return kdprintf(function(i){return i},fmt)}
    function kprintf(k,param)
     {var fmt=param[1],b=pp_make_buffer(0),ppf=formatter_of_buffer(b);
      function k$0(acc)
       {strput_acc$0(ppf,acc);
        return caml_call1(k,flush_buffer_formatter(b,ppf))}
      return make_printf(k$0,0,fmt)}
    function sprintf$0(fmt){return kprintf(id$0,fmt)}
    function kasprintf(k,param)
     {var fmt=param[1],b=pp_make_buffer(0),ppf=formatter_of_buffer(b);
      function k$0(acc)
       {output_acc$0(ppf,acc);
        return caml_call1(k,flush_buffer_formatter(b,ppf))}
      return make_printf(k$0,0,fmt)}
    function asprintf(fmt){return kasprintf(id$0,fmt)}
    function flush_standard_formatters(param)
     {pp_print_flush(std_formatter,0);return pp_print_flush(err_formatter,0)}
    at_exit(flush_standard_formatters);
    function pp_set_all_formatter_output_fu(state,f,g,h,i)
     {pp_set_formatter_output_functi(state,f,g);
      state[19] = h;
      state[20] = i;
      return 0}
    function pp_get_all_formatter_output_fu(state,param)
     {return [0,state[17],state[18],state[19],state[20]]}
    function set_all_formatter_output_funct(_jj_,_jk_,_jl_,_jm_)
     {return pp_set_all_formatter_output_fu(std_formatter,_jj_,_jk_,_jl_,_jm_)}
    function get_all_formatter_output_funct(_ji_)
     {return pp_get_all_formatter_output_fu(std_formatter,_ji_)}
    function bprintf$0(b,param)
     {var fmt=param[1],ppf=formatter_of_buffer(b);
      function k(acc){output_acc$0(ppf,acc);return pp_flush_queue(ppf,0)}
      return make_printf(k,0,fmt)}
    function pp_set_formatter_tag_functions(state,param)
     {var pct=param[4],pot=param[3],mct=param[2],mot=param[1];
      function stringify(f,e,param)
       {if(param[1] === String_tag){var s=param[2];return caml_call1(f,s)}
        return e}
      state[24] = function(_jh_){return stringify(mot,cst$84,_jh_)};
      state[25] = function(_jg_){return stringify(mct,cst$85,_jg_)};
      var _jc_=0;
      state[26] = function(_jf_){return stringify(pot,_jc_,_jf_)};
      var _jd_=0;
      state[27] = function(_je_){return stringify(pct,_jd_,_je_)};
      return 0}
    function pp_get_formatter_tag_functions(fmt,param)
     {var funs=pp_get_formatter_stag_function(fmt,0);
      function mark_open_tag(s){return caml_call1(funs[1],[0,String_tag,s])}
      function mark_close_tag(s){return caml_call1(funs[2],[0,String_tag,s])}
      function print_open_tag(s){return caml_call1(funs[3],[0,String_tag,s])}
      function print_close_tag(s){return caml_call1(funs[4],[0,String_tag,s])}
      return [0,mark_open_tag,mark_close_tag,print_open_tag,print_close_tag]}
    function set_formatter_tag_functions(_jb_)
     {return pp_set_formatter_tag_functions(std_formatter,_jb_)}
    function get_formatter_tag_functions(_ja_)
     {return pp_get_formatter_tag_functions(std_formatter,_ja_)}
    var
     Stdlib_format=
      [0,
       pp_open_box,
       open_box,
       pp_close_box,
       close_box,
       pp_open_hbox,
       open_hbox,
       pp_open_vbox,
       open_vbox,
       pp_open_hvbox,
       open_hvbox,
       pp_open_hovbox,
       open_hovbox,
       pp_print_string,
       print_string$0,
       pp_print_as,
       print_as,
       pp_print_int,
       print_int$0,
       pp_print_float,
       print_float$0,
       pp_print_char,
       print_char$0,
       pp_print_bool,
       print_bool,
       pp_print_space,
       print_space,
       pp_print_cut,
       print_cut,
       pp_print_break,
       print_break,
       pp_print_custom_break,
       pp_force_newline,
       force_newline,
       pp_print_if_newline,
       print_if_newline,
       pp_print_flush,
       print_flush,
       pp_print_newline,
       print_newline$0,
       pp_set_margin,
       set_margin,
       pp_get_margin,
       get_margin,
       pp_set_max_indent,
       set_max_indent,
       pp_get_max_indent,
       get_max_indent,
       check_geometry,
       pp_set_geometry,
       set_geometry,
       pp_safe_set_geometry,
       safe_set_geometry,
       pp_update_geometry,
       update_geometry,
       pp_get_geometry,
       get_geometry,
       pp_set_max_boxes,
       set_max_boxes,
       pp_get_max_boxes,
       get_max_boxes,
       pp_over_max_boxes,
       over_max_boxes,
       pp_open_tbox,
       open_tbox,
       pp_close_tbox,
       close_tbox,
       pp_set_tab,
       set_tab,
       pp_print_tab,
       print_tab,
       pp_print_tbreak,
       print_tbreak,
       pp_set_ellipsis_text,
       set_ellipsis_text,
       pp_get_ellipsis_text,
       get_ellipsis_text,
       String_tag,
       pp_open_stag,
       open_stag,
       pp_close_stag,
       close_stag,
       pp_set_tags,
       set_tags,
       pp_set_print_tags,
       set_print_tags,
       pp_set_mark_tags,
       set_mark_tags,
       pp_get_print_tags,
       get_print_tags,
       pp_get_mark_tags,
       get_mark_tags,
       pp_set_formatter_out_channel,
       set_formatter_out_channel,
       pp_set_formatter_output_functi,
       set_formatter_output_functions,
       pp_get_formatter_output_functi,
       get_formatter_output_functions,
       pp_set_formatter_out_functions,
       set_formatter_out_functions,
       pp_get_formatter_out_functions,
       get_formatter_out_functions,
       pp_set_formatter_stag_function,
       set_formatter_stag_functions,
       pp_get_formatter_stag_function,
       get_formatter_stag_functions,
       formatter_of_out_channel,
       std_formatter,
       err_formatter,
       formatter_of_buffer,
       stdbuf,
       str_formatter,
       flush_str_formatter,
       make_formatter,
       formatter_of_out_functions,
       make_symbolic_output_buffer,
       clear_symbolic_output_buffer,
       get_symbolic_output_buffer,
       flush_symbolic_output_buffer,
       add_symbolic_output_item,
       formatter_of_symbolic_output_b,
       pp_print_list,
       pp_print_seq,
       pp_print_text,
       pp_print_option,
       pp_print_result,
       fprintf$0,
       printf$0,
       eprintf$0,
       sprintf$0,
       asprintf,
       dprintf,
       ifprintf$0,
       kfprintf$0,
       kdprintf,
       ikfprintf$0,
       kprintf,
       kasprintf,
       bprintf$0,
       kprintf,
       set_all_formatter_output_funct,
       get_all_formatter_output_funct,
       pp_set_all_formatter_output_fu,
       pp_get_all_formatter_output_fu,
       pp_open_tag,
       open_tag,
       pp_close_tag,
       close_tag,
       pp_set_formatter_tag_functions,
       set_formatter_tag_functions,
       pp_get_formatter_tag_functions,
       get_formatter_tag_functions];
    caml_register_global(801,Stdlib_format,"Stdlib__format");
    var null_char=0;
    function next_char(ib)
     {try
       {var c=caml_call1(ib[7],0);
        ib[2] = c;
        ib[3] = 1;
        ib[4] = ib[4] + 1 | 0;
        if(10 === c)ib[5] = ib[5] + 1 | 0;
        return c}
      catch(_i$_)
       {_i$_ = caml_wrap_exception(_i$_);
        if(_i$_ === End_of_file)
         {ib[2] = null_char;ib[3] = 0;ib[1] = 1;return null_char}
        throw _i$_}}
    function peek_char(ib){return ib[3]?ib[2]:next_char(ib)}
    function checked_peek_char(ib)
     {var c=peek_char(ib);if(ib[1])throw End_of_file;return c}
    function end_of_input(ib){peek_char(ib);return ib[1]}
    function beginning_of_input(ib){return 0 === ib[4]?1:0}
    function name_of_input(ib)
     {var _i__=ib[9];
      if(typeof _i__ === "number")
       return 0 === _i__?cst_unnamed_function:cst_unnamed_character_string;
      else
       {if(0 === _i__[0])return cst_unnamed_Stdlib_input_chann;
        var fname=_i__[1];
        return fname}}
    function char_count(ib){return ib[3]?ib[4] - 1 | 0:ib[4]}
    function reset_token(ib){return reset(ib[8])}
    function invalidate_current_char(ib){ib[3] = 0;return 0}
    function token_string(ib)
     {var token_buffer=ib[8],tok=contents(token_buffer);
      clear$1(token_buffer);
      ib[6] = ib[6] + 1 | 0;
      return tok}
    function skip_char(width,ib){invalidate_current_char(ib);return width}
    function ignore_char(width,ib){return skip_char(width - 1 | 0,ib)}
    function store_char(width,ib,c)
     {add_char(ib[8],c);return ignore_char(width,ib)}
    var default_token_buffer_size=1024;
    function create$4(iname,next)
     {return [0,
              0,
              null_char,
              0,
              0,
              0,
              0,
              next,
              create$2(default_token_buffer_size),
              iname]}
    function from_string$1(s)
     {var i=[0,0],len=caml_ml_string_length(s);
      function next(param)
       {if(len <= i[1])throw End_of_file;
        var c=caml_string_get(s,i[1]);
        i[1]++;
        return c}
      return create$4(1,next)}
    var _cj_=0;
    function from_function$0(_i9_){return create$4(_cj_,_i9_)}
    var len=1024;
    function scan_close_at_end(ic)
     {caml_ml_close_channel(ic);throw End_of_file}
    function scan_raise_at_end(ic){throw End_of_file}
    function from_ic(scan_close_ic,iname,ic)
     {var buf=caml_create_bytes(1024),i=[0,0],lim=[0,0],eof=[0,0];
      function next(param)
       {if(i[1] < lim[1]){var c=caml_bytes_get(buf,i[1]);i[1]++;return c}
        if(eof[1])throw End_of_file;
        lim[1] = input(ic,buf,0,len);
        return 0 === lim[1]
                ?(eof[1] = 1,caml_call1(scan_close_ic,ic))
                :(i[1] = 1,caml_bytes_get(buf,0))}
      return create$4(iname,next)}
    var stdib=from_ic(scan_raise_at_end,[1,cst$86,stdin],stdin);
    function open_in_file(open_in,fname)
     {if(caml_string_notequal(fname,cst$87))
       {var ic=caml_call1(open_in,fname);
        return from_ic(scan_close_at_end,[1,fname,ic],ic)}
      return stdib}
    function from_file(_i8_){return open_in_file(open_in,_i8_)}
    function from_file_bin(_i7_){return open_in_file(open_in_bin,_i7_)}
    function from_channel$0(ic){return from_ic(scan_raise_at_end,[0,ic],ic)}
    function close_in$0(ib)
     {var _i6_=ib[9];
      if(typeof _i6_ === "number")
       return 0;
      else
       {if(0 === _i6_[0]){var ic=_i6_[1];return caml_ml_close_channel(ic)}
        var ic$0=_i6_[2];
        return caml_ml_close_channel(ic$0)}}
    var memo=[0,0];
    function memo_from_ic(scan_close_ic,ic)
     {try
       {var _i4_=assq(ic,memo[1]);return _i4_}
      catch(_i5_)
       {_i5_ = caml_wrap_exception(_i5_);
        if(_i5_ === Not_found)
         {var ib=from_ic(scan_close_ic,[0,ic],ic);
          memo[1] = [0,[0,ic,ib],memo[1]];
          return ib}
        throw _i5_}}
    function memo_from_channel(_i3_)
     {return memo_from_ic(scan_raise_at_end,_i3_)}
    var Scan_failure=[248,cst_Stdlib_Scanf_Scan_failure,caml_fresh_oo_id(0)];
    function bad_input(s){throw [0,Scan_failure,s]}
    function bad_input_escape(c)
     {return bad_input(caml_call1(sprintf(_ck_),c))}
    function bad_token_length(message)
     {return bad_input(caml_call1(sprintf(_cl_),message))}
    function bad_float(param)
     {return bad_input(cst_no_dot_or_exponent_part_fo)}
    function bad_hex_float(param)
     {return bad_input(cst_not_a_valid_float_in_hexad)}
    function character_mismatch(c,ci)
     {return bad_input(caml_call2(sprintf(_cn_),c,ci))}
    function check_this_char(ib,c)
     {var ci=checked_peek_char(ib);
      return ci === c?invalidate_current_char(ib):character_mismatch(c,ci)}
    function check_char(ib,c$0)
     {if(10 === c$0)
       {var ci=checked_peek_char(ib);
        return 10 === ci
                ?invalidate_current_char(ib)
                :13 === ci
                  ?(invalidate_current_char(ib),check_this_char(ib,10))
                  :character_mismatch(10,ci)}
      if(32 === c$0)
       for(;;)
        {var c=peek_char(ib),_i1_=1 - ib[1];
         if(_i1_)
          {var _i2_=c - 9 | 0,switch$0=0;
           if(4 < _i2_ >>> 0)
            {if(23 === _i2_)switch$0 = 1}
           else
            if(1 < (_i2_ - 2 | 0) >>> 0)switch$0 = 1;
           if(switch$0){invalidate_current_char(ib);continue}
           return 0}
         return _i1_}
      return check_this_char(ib,c$0)}
    function token_char(ib){return caml_string_get(token_string(ib),0)}
    function token_bool(ib)
     {var s=token_string(ib);
      return caml_string_notequal(s,cst_false$3)
              ?caml_string_notequal(s,cst_true$3)
                ?bad_input(caml_call1(sprintf(_co_),s))
                :1
              :0}
    function integer_conversion_of_char(param)
     {var switcher=param - 88 | 0;
      if(! (32 < switcher >>> 0))
       switch(switcher)
        {case 10:return 0;
         case 12:return 1;
         case 17:return 2;
         case 23:return 3;
         case 29:return 4;
         case 0:
         case 32:return 5
         }
      throw [0,Assert_failure,_cp_]}
    function token_int_literal(conv,ib)
     {switch(conv)
       {case 0:var tok=symbol(cst_0b,token_string(ib));break;
        case 3:var tok=symbol(cst_0o,token_string(ib));break;
        case 4:var tok=symbol(cst_0u,token_string(ib));break;
        case 5:var tok=symbol(cst_0x,token_string(ib));break;
        default:var tok=token_string(ib)}
      var l=caml_ml_string_length(tok);
      if(0 !== l && 43 === caml_string_get(tok,0))
       return sub$0(tok,1,l - 1 | 0);
      return tok}
    function token_float(ib){return caml_float_of_string(token_string(ib))}
    function scan_decimal_digit_star(width,ib)
     {var width$0=width;
      for(;;)
       {if(0 === width$0)return width$0;
        var c=peek_char(ib);
        if(ib[1])return width$0;
        if(58 <= c)
         {if(95 === c)
           {var width$1=ignore_char(width$0,ib),width$0=width$1;continue}}
        else
         if(48 <= c)
          {var width$2=store_char(width$0,ib,c),width$0=width$2;continue}
        return width$0}}
    function scan_unsigned_decimal_int(width,ib)
     {if(0 === width)return bad_token_length(cst_decimal_digits);
      var c=checked_peek_char(ib),switcher=c - 48 | 0;
      if(9 < switcher >>> 0)return bad_input(caml_call1(sprintf(_cq_),c));
      var width$0=store_char(width,ib,c);
      return scan_decimal_digit_star(width$0,ib)}
    function scan_digit_plus(basis,digitp,width$2,ib)
     {if(0 === width$2)return bad_token_length(cst_digits);
      var c$0=checked_peek_char(ib);
      if(caml_call1(digitp,c$0))
       {var width$3=store_char(width$2,ib,c$0),width=width$3;
        for(;;)
         {if(0 === width)return width;
          var c=peek_char(ib);
          if(ib[1])return width;
          if(caml_call1(digitp,c))
           {var width$0=store_char(width,ib,c),width=width$0;continue}
          if(95 === c)
           {var width$1=ignore_char(width,ib),width=width$1;continue}
          return width}}
      return bad_input(caml_call2(sprintf(_cr_),c$0,basis))}
    function is_binary_digit(param)
     {var switcher=param - 48 | 0;return 1 < switcher >>> 0?0:1}
    function scan_binary_int(_iZ_,_i0_)
     {return scan_digit_plus(cst_binary,is_binary_digit,_iZ_,_i0_)}
    function is_octal_digit(param)
     {var switcher=param - 48 | 0;return 7 < switcher >>> 0?0:1}
    function scan_octal_int(_iX_,_iY_)
     {return scan_digit_plus(cst_octal,is_octal_digit,_iX_,_iY_)}
    function is_hexa_digit(param)
     {var _iW_=param - 48 | 0,switch$0=0;
      if(22 < _iW_ >>> 0)
       {if(! (5 < (_iW_ - 49 | 0) >>> 0))switch$0 = 1}
      else
       if(6 < (_iW_ - 10 | 0) >>> 0)switch$0 = 1;
      return switch$0?1:0}
    function scan_hexadecimal_int(_iU_,_iV_)
     {return scan_digit_plus(cst_hexadecimal,is_hexa_digit,_iU_,_iV_)}
    function scan_sign(width,ib)
     {var c=checked_peek_char(ib),switcher=c - 43 | 0;
      if(! (2 < switcher >>> 0))
       switch(switcher)
        {case 0:return store_char(width,ib,c);
         case 1:break;
         default:return store_char(width,ib,c)}
      return width}
    function scan_optionally_signed_decimal(width,ib)
     {var width$0=scan_sign(width,ib);
      return scan_unsigned_decimal_int(width$0,ib)}
    function scan_int_conversion(conv,width$1,ib)
     {switch(conv)
       {case 0:return scan_binary_int(width$1,ib);
        case 1:return scan_optionally_signed_decimal(width$1,ib);
        case 2:
         var width$0=scan_sign(width$1,ib),c=checked_peek_char(ib);
         if(48 === c)
          {var width=store_char(width$0,ib,c);
           if(0 === width)return width;
           var c$0=peek_char(ib);
           if(ib[1])return width;
           var switch$0=0;
           if(99 <= c$0)
            {if(111 === c$0)
              return scan_octal_int(store_char(width,ib,c$0),ib);
             if(120 === c$0)switch$0 = 1}
           else
            if(88 === c$0)
             switch$0 = 1;
            else
             if(98 <= c$0)return scan_binary_int(store_char(width,ib,c$0),ib);
           return switch$0
                   ?scan_hexadecimal_int(store_char(width,ib,c$0),ib)
                   :scan_decimal_digit_star(width,ib)}
         return scan_unsigned_decimal_int(width$0,ib);
        case 3:return scan_octal_int(width$1,ib);
        case 4:return scan_unsigned_decimal_int(width$1,ib);
        default:return scan_hexadecimal_int(width$1,ib)}}
    function scan_fractional_part(width,ib)
     {if(0 === width)return width;
      var c=peek_char(ib);
      if(ib[1])return width;
      var switcher=c - 48 | 0;
      return 9 < switcher >>> 0
              ?width
              :scan_decimal_digit_star(store_char(width,ib,c),ib)}
    function scan_exponent_part(width,ib)
     {if(0 === width)return width;
      var c=peek_char(ib);
      if(ib[1])return width;
      if(69 !== c && 101 !== c)return width;
      return scan_optionally_signed_decimal(store_char(width,ib,c),ib)}
    function scan_float(width$1,precision,ib)
     {var
       width=scan_sign(width$1,ib),
       width$0=scan_decimal_digit_star(width,ib);
      if(0 === width$0)return [0,width$0,precision];
      var c=peek_char(ib);
      if(ib[1])return [0,width$0,precision];
      if(46 === c)
       {var
         width$2=store_char(width$0,ib,c),
         precision$0=min(width$2,precision),
         width$3=
          width$2
          -
          (precision$0 - scan_fractional_part(precision$0,ib) | 0)
          |
          0;
        return [0,scan_exponent_part(width$3,ib),precision$0]}
      return [0,scan_exponent_part(width$0,ib),precision]}
    function check_case_insensitive_string(width,ib,error,str)
     {function lowercase(c)
       {var switcher=c - 65 | 0;
        return 25 < switcher >>> 0?c:char_of_int((c - 65 | 0) + 97 | 0)}
      var
       len=caml_ml_string_length(str),
       width$0=[0,width],
       _iR_=len - 1 | 0,
       _iQ_=0;
      if(! (_iR_ < 0))
       {var i=_iQ_;
        for(;;)
         {var c=peek_char(ib),_iS_=lowercase(caml_string_get(str,i));
          if(lowercase(c) !== _iS_)caml_call1(error,0);
          if(0 === width$0[1])caml_call1(error,0);
          width$0[1] = store_char(width$0[1],ib,c);
          var _iT_=i + 1 | 0;
          if(_iR_ !== i){var i=_iT_;continue}
          break}}
      return width$0[1]}
    function scan_hex_float(width,precision,ib)
     {var _iD_=0 === width?1:0,_iE_=_iD_ || end_of_input(ib);
      if(_iE_)bad_hex_float(0);
      var
       width$0=scan_sign(width,ib),
       _iF_=0 === width$0?1:0,
       _iG_=_iF_ || end_of_input(ib);
      if(_iG_)bad_hex_float(0);
      var c=peek_char(ib),switch$0=0;
      if(78 <= c)
       {var switcher=c - 79 | 0;
        if(30 < switcher >>> 0)
         {if(! (32 <= switcher))
           {var
             width$1=store_char(width$0,ib,c),
             _iH_=0 === width$1?1:0,
             _iI_=_iH_ || end_of_input(ib);
            if(_iI_)bad_hex_float(0);
            return check_case_insensitive_string
                    (width$1,ib,bad_hex_float,cst_an)}}
        else
         if(26 === switcher)switch$0 = 1}
      else
       {if(48 === c)
         {var
           width$3=store_char(width$0,ib,c),
           _iL_=0 === width$3?1:0,
           _iM_=_iL_ || end_of_input(ib);
          if(_iM_)bad_hex_float(0);
          var
           width$4=
            check_case_insensitive_string(width$3,ib,bad_hex_float,cst_x$2);
          if(0 !== width$4 && ! end_of_input(ib))
           {var match=peek_char(ib),_iN_=match - 46 | 0,switch$1=0;
            if(34 < _iN_ >>> 0)
             {if(66 === _iN_)switch$1 = 1}
            else
             if(32 < (_iN_ - 1 | 0) >>> 0)switch$1 = 1;
            var width$5=switch$1?width$4:scan_hexadecimal_int(width$4,ib);
            if(0 !== width$5 && ! end_of_input(ib))
             {var c$0=peek_char(ib);
              if(46 === c$0)
               {var width$6=store_char(width$5,ib,c$0),switch$2=0;
                if(0 !== width$6 && ! end_of_input(ib))
                 {var match$0=peek_char(ib),switch$3=0;
                  if(80 !== match$0 && 112 !== match$0)
                   {var
                     precision$0=min(width$6,precision),
                     width$10=
                      width$6
                      -
                      (precision$0 - scan_hexadecimal_int(precision$0,ib) | 0)
                      |
                      0;
                    switch$3 = 1}
                  if(! switch$3)var width$10=width$6;
                  var width$7=width$10;
                  switch$2 = 1}
                if(! switch$2)var width$7=width$6;
                var width$8=width$7}
              else
               var width$8=width$5;
              if(0 !== width$8 && ! end_of_input(ib))
               {var c$1=peek_char(ib);
                if(80 !== c$1 && 112 !== c$1)return width$8;
                var
                 width$9=store_char(width$8,ib,c$1),
                 _iO_=0 === width$9?1:0,
                 _iP_=_iO_ || end_of_input(ib);
                if(_iP_)bad_hex_float(0);
                return scan_optionally_signed_decimal(width$9,ib)}
              return width$8}
            return width$5}
          return width$4}
        if(73 === c)switch$0 = 1}
      if(switch$0)
       {var
         width$2=store_char(width$0,ib,c),
         _iJ_=0 === width$2?1:0,
         _iK_=_iJ_ || end_of_input(ib);
        if(_iK_)bad_hex_float(0);
        return check_case_insensitive_string
                (width$2,ib,bad_hex_float,cst_nfinity)}
      return bad_hex_float(0)}
    function scan_caml_float_rest(width,precision,ib)
     {var _iz_=0 === width?1:0,_iA_=_iz_ || end_of_input(ib);
      if(_iA_)bad_float(0);
      var
       width$0=scan_decimal_digit_star(width,ib),
       _iB_=0 === width$0?1:0,
       _iC_=_iB_ || end_of_input(ib);
      if(_iC_)bad_float(0);
      var c=peek_char(ib),switcher=c - 69 | 0;
      if(32 < switcher >>> 0)
       {if(-23 === switcher)
         {var
           width$1=store_char(width$0,ib,c),
           precision$0=min(width$1,precision),
           width_precision=scan_fractional_part(precision$0,ib),
           frac_width=precision$0 - width_precision | 0,
           width$2=width$1 - frac_width | 0;
          return scan_exponent_part(width$2,ib)}}
      else
       {var switcher$0=switcher - 1 | 0;
        if(30 < switcher$0 >>> 0)return scan_exponent_part(width$0,ib)}
      return bad_float(0)}
    function scan_caml_float(width,precision,ib)
     {var _il_=0 === width?1:0,_im_=_il_ || end_of_input(ib);
      if(_im_)bad_float(0);
      var
       width$0=scan_sign(width,ib),
       _in_=0 === width$0?1:0,
       _io_=_in_ || end_of_input(ib);
      if(_io_)bad_float(0);
      var c=peek_char(ib);
      if(49 <= c)
       {if(! (58 <= c))
         {var
           width$1=store_char(width$0,ib,c),
           _ip_=0 === width$1?1:0,
           _iq_=_ip_ || end_of_input(ib);
          if(_iq_)bad_float(0);
          return scan_caml_float_rest(width$1,precision,ib)}}
      else
       if(48 <= c)
        {var
          width$2=store_char(width$0,ib,c),
          _ir_=0 === width$2?1:0,
          _is_=_ir_ || end_of_input(ib);
         if(_is_)bad_float(0);
         var c$0=peek_char(ib);
         if(88 !== c$0 && 120 !== c$0)
          return scan_caml_float_rest(width$2,precision,ib);
         var
          width$3=store_char(width$2,ib,c$0),
          _it_=0 === width$3?1:0,
          _iu_=_it_ || end_of_input(ib);
         if(_iu_)bad_float(0);
         var
          width$4=scan_hexadecimal_int(width$3,ib),
          _iv_=0 === width$4?1:0,
          _iw_=_iv_ || end_of_input(ib);
         if(_iw_)bad_float(0);
         var c$1=peek_char(ib),switcher=c$1 - 80 | 0,switch$0=0;
         if(32 < switcher >>> 0)
          if(-34 === switcher)
           {var width$5=store_char(width$4,ib,c$1),switch$1=0;
            if(0 !== width$5 && ! end_of_input(ib))
             {var match=peek_char(ib),switch$2=0;
              if(80 !== match && 112 !== match)
               {var
                 precision$0=min(width$5,precision),
                 width$10=
                  width$5
                  -
                  (precision$0 - scan_hexadecimal_int(precision$0,ib) | 0)
                  |
                  0;
                switch$2 = 1}
              if(! switch$2)var width$10=width$5;
              var width$6=width$10;
              switch$1 = 1}
            if(! switch$1)var width$6=width$5;
            var width$7=width$6}
          else
           switch$0 = 1;
         else
          {var switcher$0=switcher - 1 | 0;
           if(30 < switcher$0 >>> 0)var width$7=width$4;else switch$0 = 1}
         var width$8=switch$0?bad_float(0):width$7;
         if(0 !== width$8 && ! end_of_input(ib))
          {var c$2=peek_char(ib);
           if(80 !== c$2 && 112 !== c$2)return width$8;
           var
            width$9=store_char(width$8,ib,c$2),
            _ix_=0 === width$9?1:0,
            _iy_=_ix_ || end_of_input(ib);
           if(_iy_)bad_hex_float(0);
           return scan_optionally_signed_decimal(width$9,ib)}
         return width$8}
      return bad_float(0)}
    function scan_string(stp,width,ib)
     {var width$0=width;
      for(;;)
       {if(0 === width$0)return width$0;
        var c=peek_char(ib);
        if(ib[1])return width$0;
        if(stp)
         {var c$0=stp[1];
          if(c === c$0)return skip_char(width$0,ib);
          var width$1=store_char(width$0,ib,c),width$0=width$1;
          continue}
        var _ik_=c - 9 | 0,switch$0=0;
        if(4 < _ik_ >>> 0)
         {if(23 === _ik_)switch$0 = 1}
        else
         if(1 < (_ik_ - 2 | 0) >>> 0)switch$0 = 1;
        if(switch$0)return width$0;
        var width$2=store_char(width$0,ib,c),width$0=width$2;
        continue}}
    function scan_char(width,ib)
     {return store_char(width,ib,checked_peek_char(ib))}
    function hexadecimal_value_of_char(d)
     {return 97 <= d?d - 87 | 0:65 <= d?d - 55 | 0:d - 48 | 0}
    function check_next_char(message,width,ib)
     {if(0 === width)return bad_token_length(message);
      var c=peek_char(ib);
      return ib[1]?bad_input(caml_call1(sprintf(_cm_),message)):c}
    function check_next_char_for_char(_ii_,_ij_)
     {return check_next_char(cst_a_Char,_ii_,_ij_)}
    function check_next_char_for_string(_ig_,_ih_)
     {return check_next_char(cst_a_String,_ig_,_ih_)}
    function scan_backslash_char(width,ib)
     {var c0=check_next_char_for_char(width,ib),switch$0=0;
      if(40 <= c0)
       {if(58 <= c0)
         {var switcher$0=c0 - 92 | 0;
          if(! (28 < switcher$0 >>> 0))
           switch(switcher$0)
            {case 28:
              var
               get_digit=
                function(param)
                 {var c=next_char(ib),_if_=c - 48 | 0,switch$0=0;
                  if(22 < _if_ >>> 0)
                   {if(! (5 < (_if_ - 49 | 0) >>> 0))switch$0 = 1}
                  else
                   if(6 < (_if_ - 10 | 0) >>> 0)switch$0 = 1;
                  return switch$0?c:bad_input_escape(c)},
               c1=get_digit(0),
               c2=get_digit(0),
               _ib_=hexadecimal_value_of_char(c2),
               c$0=(16 * hexadecimal_value_of_char(c1) | 0) + _ib_ | 0,
               switch$1=0;
              if(0 <= c$0 && ! (255 < c$0))
               {var _id_=char_of_int(c$0);switch$1 = 1}
              if(! switch$1)
               var _id_=bad_input(caml_call2(sprintf(_ct_),c1,c2));
              return store_char(width - 2 | 0,ib,_id_);
             case 0:
             case 6:
             case 18:
             case 22:
             case 24:switch$0 = 1;break
             }}
        else
         if(48 <= c0)
          {var
            get_digit$0=
             function(param)
              {var c=next_char(ib),switcher=c - 48 | 0;
               return 9 < switcher >>> 0?bad_input_escape(c):c},
            c1$0=get_digit$0(0),
            c2$0=get_digit$0(0),
            c=
             ((100 * (c0 - 48 | 0) | 0) + (10 * (c1$0 - 48 | 0) | 0) | 0)
             +
             (c2$0 - 48 | 0)
             |
             0,
            switch$2=0;
           if(0 <= c && ! (255 < c)){var _ie_=char_of_int(c);switch$2 = 1}
           if(! switch$2)
            var _ie_=bad_input(caml_call3(sprintf(_cs_),c0,c1$0,c2$0));
           return store_char(width - 2 | 0,ib,_ie_)}}
      else
       if(34 === c0 || 39 <= c0)switch$0 = 1;
      if(switch$0)
       {var switch$3=0;
        if(110 <= c0)
         if(117 <= c0)
          switch$3 = 1;
         else
          {var switcher=c0 - 110 | 0;
           switch(switcher)
            {case 0:var _ic_=10;break;
             case 4:var _ic_=13;break;
             case 6:var _ic_=9;break;
             default:switch$3 = 1}}
        else
         if(98 === c0)var _ic_=8;else switch$3 = 1;
        if(switch$3)var _ic_=c0;
        return store_char(width,ib,_ic_)}
      return bad_input_escape(c0)}
    function scan_caml_char(width,ib)
     {function find_stop(width)
       {var c=check_next_char_for_char(width,ib);
        return 39 === c?ignore_char(width,ib):character_mismatch(39,c)}
      var c=checked_peek_char(ib);
      if(39 === c)
       {var
         width$0=ignore_char(width,ib),
         c$0=check_next_char_for_char(width$0,ib);
        return 92 === c$0
                ?find_stop(scan_backslash_char(ignore_char(width$0,ib),ib))
                :find_stop(store_char(width$0,ib,c$0))}
      return character_mismatch(39,c)}
    function scan_caml_string(width,ib)
     {function find_stop$0(counter,width)
       {var width$0=width;
        for(;;)
         {var c=check_next_char_for_string(width$0,ib);
          if(34 === c)return ignore_char(width$0,ib);
          if(92 === c)
           {var
             width$1=ignore_char(width$0,ib),
             match=check_next_char_for_string(width$1,ib);
            if(10 === match)
             {var _h$_=ignore_char(width$1,ib);
              if(counter < 50)
               {var counter$0=counter + 1 | 0;
                return skip_spaces(counter$0,_h$_)}
              return caml_trampoline_return(skip_spaces,[0,_h$_])}
            if(13 === match)
             {var
               width$3=ignore_char(width$1,ib),
               match$0=check_next_char_for_string(width$3,ib);
              if(10 === match$0)
               {var _ia_=ignore_char(width$3,ib);
                if(counter < 50)
                 {var counter$1=counter + 1 | 0;
                  return skip_spaces(counter$1,_ia_)}
                return caml_trampoline_return(skip_spaces,[0,_ia_])}
              var width$5=store_char(width$3,ib,13),width$0=width$5;
              continue}
            var width$4=scan_backslash_char(width$1,ib),width$0=width$4;
            continue}
          var width$2=store_char(width$0,ib,c),width$0=width$2;
          continue}}
      function skip_spaces(counter,width)
       {var width$0=width;
        for(;;)
         {var match=check_next_char_for_string(width$0,ib);
          if(32 === match)
           {var width$1=ignore_char(width$0,ib),width$0=width$1;continue}
          if(counter < 50)
           {var counter$0=counter + 1 | 0;
            return find_stop$0(counter$0,width$0)}
          return caml_trampoline_return(find_stop$0,[0,width$0])}}
      function find_stop(width){return caml_trampoline(find_stop$0(0,width))}
      var c=checked_peek_char(ib);
      return 34 === c
              ?find_stop(ignore_char(width,ib))
              :character_mismatch(34,c)}
    function scan_chars_in_char_set(char_set,scan_indic,width,ib)
     {function scan_chars(i,stp)
       {var i$0=i;
        for(;;)
         {var c=peek_char(ib),_h7_=0 < i$0?1:0;
          if(_h7_)
           {var _h8_=1 - ib[1];
            if(_h8_)
             var _h9_=is_in_char_set(char_set,c),_h__=_h9_?c !== stp?1:0:_h9_;
            else
             var _h__=_h8_}
          else
           var _h__=_h7_;
          if(_h__)
           {store_char(max_int,ib,c);var i$1=i$0 - 1 | 0,i$0=i$1;continue}
          return _h__}}
      if(scan_indic)
       {var c=scan_indic[1];
        scan_chars(width,c);
        var _h6_=1 - ib[1];
        if(_h6_)
         {var ci=peek_char(ib);
          return c === ci?invalidate_current_char(ib):character_mismatch(c,ci)}
        return _h6_}
      return scan_chars(width,-1)}
    function scanf_bad_input(ib,x)
     {if(x[1] === Scan_failure)
       var s=x[2];
      else
       {if(x[1] !== Failure)throw x;var s=x[2]}
      var i=char_count(ib);
      return bad_input(caml_call2(sprintf(_cv_),i,s))}
    function get_counter(ib,counter)
     {switch(counter)
       {case 0:return ib[5];case 1:return char_count(ib);default:return ib[6]}}
    function width_of_pad_opt(pad_opt)
     {if(pad_opt){var width=pad_opt[1];return width}return max_int}
    function stopper_of_formatting_lit(fmting)
     {if(6 === fmting)return _cw_;
      var
       str=string_of_formatting_lit(fmting),
       stp=caml_string_get(str,1),
       sub_str=sub$0(str,2,caml_ml_string_length(str) - 2 | 0);
      return [0,stp,sub_str]}
    function take_format_readers$0(counter,k,fmt)
     {var fmt$0=fmt;
      for(;;)
       if(typeof fmt$0 === "number")
        return caml_call1(k,0);
       else
        switch(fmt$0[0])
         {case 0:var fmt$1=fmt$0[1],fmt$0=fmt$1;continue;
          case 1:var fmt$2=fmt$0[1],fmt$0=fmt$2;continue;
          case 2:var fmt$3=fmt$0[2],fmt$0=fmt$3;continue;
          case 3:var fmt$4=fmt$0[2],fmt$0=fmt$4;continue;
          case 4:var fmt$5=fmt$0[4],fmt$0=fmt$5;continue;
          case 5:var fmt$6=fmt$0[4],fmt$0=fmt$6;continue;
          case 6:var fmt$7=fmt$0[4],fmt$0=fmt$7;continue;
          case 7:var fmt$8=fmt$0[4],fmt$0=fmt$8;continue;
          case 8:var fmt$9=fmt$0[4],fmt$0=fmt$9;continue;
          case 9:var fmt$10=fmt$0[2],fmt$0=fmt$10;continue;
          case 10:var fmt$11=fmt$0[1],fmt$0=fmt$11;continue;
          case 11:var fmt$12=fmt$0[2],fmt$0=fmt$12;continue;
          case 12:var fmt$13=fmt$0[2],fmt$0=fmt$13;continue;
          case 13:var fmt$14=fmt$0[3],fmt$0=fmt$14;continue;
          case 14:
           var rest=fmt$0[3],fmtty=fmt$0[2],_h4_=erase_rel(symm(fmtty));
           if(counter < 50)
            {var counter$0=counter + 1 | 0;
             return take_fmtty_format_readers$0(counter$0,k,_h4_,rest)}
           return caml_trampoline_return
                   (take_fmtty_format_readers$0,[0,k,_h4_,rest]);
          case 15:var fmt$15=fmt$0[1],fmt$0=fmt$15;continue;
          case 16:var fmt$16=fmt$0[1],fmt$0=fmt$16;continue;
          case 17:var fmt$17=fmt$0[2],fmt$0=fmt$17;continue;
          case 18:
           var _h5_=fmt$0[1];
           if(0 === _h5_[0])
            {var
              rest$0=fmt$0[2],
              match=_h5_[1],
              fmt$18=match[1],
              fmt$19=concat_fmt(fmt$18,rest$0),
              fmt$0=fmt$19;
             continue}
           var
            rest$1=fmt$0[2],
            match$0=_h5_[1],
            fmt$20=match$0[1],
            fmt$21=concat_fmt(fmt$20,rest$1),
            fmt$0=fmt$21;
           continue;
          case 19:
           var fmt_rest=fmt$0[1];
           return function(reader)
            {function new_k(readers_rest)
              {return caml_call1(k,[0,reader,readers_rest])}
             return take_format_readers(new_k,fmt_rest)};
          case 20:var fmt$22=fmt$0[3],fmt$0=fmt$22;continue;
          case 21:var fmt$23=fmt$0[2],fmt$0=fmt$23;continue;
          case 22:var fmt$24=fmt$0[1],fmt$0=fmt$24;continue;
          case 23:
           var rest$2=fmt$0[2],ign=fmt$0[1];
           if(typeof ign === "number")
            switch(ign)
             {case 0:var fmt$0=rest$2;continue;
              case 1:var fmt$0=rest$2;continue;
              case 2:
               return function(reader)
                {function new_k(readers_rest)
                  {return caml_call1(k,[0,reader,readers_rest])}
                 return take_format_readers(new_k,rest$2)};
              default:var fmt$0=rest$2;continue}
           else
            switch(ign[0])
             {case 0:var fmt$0=rest$2;continue;
              case 1:var fmt$0=rest$2;continue;
              case 2:var fmt$0=rest$2;continue;
              case 3:var fmt$0=rest$2;continue;
              case 4:var fmt$0=rest$2;continue;
              case 5:var fmt$0=rest$2;continue;
              case 6:var fmt$0=rest$2;continue;
              case 7:var fmt$0=rest$2;continue;
              case 8:var fmt$0=rest$2;continue;
              case 9:
               var fmtty$0=ign[2];
               if(counter < 50)
                {var counter$1=counter + 1 | 0;
                 return take_fmtty_format_readers$0
                         (counter$1,k,fmtty$0,rest$2)}
               return caml_trampoline_return
                       (take_fmtty_format_readers$0,[0,k,fmtty$0,rest$2]);
              case 10:var fmt$0=rest$2;continue;
              default:var fmt$0=rest$2;continue}
          default:var fmt$25=fmt$0[3],fmt$0=fmt$25;continue}}
    function take_fmtty_format_readers$0(counter,k,fmtty,fmt)
     {var fmtty$0=fmtty;
      for(;;)
       if(typeof fmtty$0 === "number")
        {if(counter < 50)
          {var counter$0=counter + 1 | 0;
           return take_format_readers$0(counter$0,k,fmt)}
         return caml_trampoline_return(take_format_readers$0,[0,k,fmt])}
       else
        switch(fmtty$0[0])
         {case 0:var fmtty$1=fmtty$0[1],fmtty$0=fmtty$1;continue;
          case 1:var fmtty$2=fmtty$0[1],fmtty$0=fmtty$2;continue;
          case 2:var fmtty$3=fmtty$0[1],fmtty$0=fmtty$3;continue;
          case 3:var fmtty$4=fmtty$0[1],fmtty$0=fmtty$4;continue;
          case 4:var fmtty$5=fmtty$0[1],fmtty$0=fmtty$5;continue;
          case 5:var fmtty$6=fmtty$0[1],fmtty$0=fmtty$6;continue;
          case 6:var fmtty$7=fmtty$0[1],fmtty$0=fmtty$7;continue;
          case 7:var fmtty$8=fmtty$0[1],fmtty$0=fmtty$8;continue;
          case 8:var fmtty$9=fmtty$0[2],fmtty$0=fmtty$9;continue;
          case 9:
           var
            rest=fmtty$0[3],
            ty2=fmtty$0[2],
            ty1=fmtty$0[1],
            ty=trans(symm(ty1),ty2),
            fmtty$10=concat_fmtty(ty,rest),
            fmtty$0=fmtty$10;
           continue;
          case 10:var fmtty$11=fmtty$0[1],fmtty$0=fmtty$11;continue;
          case 11:var fmtty$12=fmtty$0[1],fmtty$0=fmtty$12;continue;
          case 12:var fmtty$13=fmtty$0[1],fmtty$0=fmtty$13;continue;
          case 13:
           var fmt_rest=fmtty$0[1];
           return function(reader)
            {function new_k(readers_rest)
              {return caml_call1(k,[0,reader,readers_rest])}
             return take_fmtty_format_readers(new_k,fmt_rest,fmt)};
          default:
           var fmt_rest$0=fmtty$0[1];
           return function(reader)
            {function new_k(readers_rest)
              {return caml_call1(k,[0,reader,readers_rest])}
             return take_fmtty_format_readers(new_k,fmt_rest$0,fmt)}}}
    function take_format_readers(k,fmt)
     {return caml_trampoline(take_format_readers$0(0,k,fmt))}
    function take_fmtty_format_readers(k,fmtty,fmt)
     {return caml_trampoline(take_fmtty_format_readers$0(0,k,fmtty,fmt))}
    function make_scanf(ib,fmt,readers)
     {var fmt$0=fmt;
      for(;;)
       if(typeof fmt$0 === "number")
        return 0;
       else
        switch(fmt$0[0])
         {case 0:
           var rest=fmt$0[1];
           scan_char(0,ib);
           var c=token_char(ib);
           return [0,c,make_scanf(ib,rest,readers)];
          case 1:
           var rest$0=fmt$0[1];
           scan_caml_char(0,ib);
           var c$0=token_char(ib);
           return [0,c$0,make_scanf(ib,rest$0,readers)];
          case 2:
           var _hR_=fmt$0[1],_hS_=fmt$0[2];
           if(typeof _hS_ !== "number")
            switch(_hS_[0])
             {case 17:
               var
                rest$2=_hS_[2],
                fmting_lit=_hS_[1],
                match=stopper_of_formatting_lit(fmting_lit),
                str=match[2],
                stp=match[1],
                scan$0=
                 function(width,param,ib)
                  {return scan_string([0,stp],width,ib)},
                str_rest=[11,str,rest$2];
               return pad_prec_scanf
                       (ib,str_rest,readers,_hR_,0,scan$0,token_string);
              case 18:
               var _hT_=_hS_[1];
               if(0 === _hT_[0])
                {var
                  rest$3=_hS_[2],
                  match$0=_hT_[1],
                  fmt$1=match$0[1],
                  scan$1=
                   function(width,param,ib){return scan_string(_cx_,width,ib)};
                 return pad_prec_scanf
                         (ib,
                          concat_fmt(fmt$1,rest$3),
                          readers,
                          _hR_,
                          0,
                          scan$1,
                          token_string)}
               var
                rest$4=_hS_[2],
                match$1=_hT_[1],
                fmt$2=match$1[1],
                scan$2=
                 function(width,param,ib){return scan_string(_cy_,width,ib)};
               return pad_prec_scanf
                       (ib,
                        concat_fmt(fmt$2,rest$4),
                        readers,
                        _hR_,
                        0,
                        scan$2,
                        token_string)
              }
           var
            rest$1=fmt$0[2],
            scan=function(width,param,ib){return scan_string(0,width,ib)};
           return pad_prec_scanf(ib,rest$1,readers,_hR_,0,scan,token_string);
          case 3:
           var
            rest$5=fmt$0[2],
            pad=fmt$0[1],
            scan$3=function(width,param,ib){return scan_caml_string(width,ib)};
           return pad_prec_scanf(ib,rest$5,readers,pad,0,scan$3,token_string);
          case 4:
           var
            rest$6=fmt$0[4],
            prec=fmt$0[3],
            pad$0=fmt$0[2],
            iconv=fmt$0[1],
            conv=integer_conversion_of_char(char_of_iconv(iconv)),
            scan$4=
             function(width,param,ib)
              {return scan_int_conversion(conv,width,ib)};
           return pad_prec_scanf
                   (ib,
                    rest$6,
                    readers,
                    pad$0,
                    prec,
                    scan$4,
                    function(ib)
                     {return caml_int_of_string(token_int_literal(conv,ib))});
          case 5:
           var
            rest$7=fmt$0[4],
            prec$0=fmt$0[3],
            pad$1=fmt$0[2],
            iconv$0=fmt$0[1],
            conv$0=integer_conversion_of_char(char_of_iconv(iconv$0)),
            scan$5=
             function(width,param,ib)
              {return scan_int_conversion(conv$0,width,ib)};
           return pad_prec_scanf
                   (ib,
                    rest$7,
                    readers,
                    pad$1,
                    prec$0,
                    scan$5,
                    function(ib)
                     {return caml_int_of_string(token_int_literal(conv$0,ib))});
          case 6:
           var
            rest$8=fmt$0[4],
            prec$1=fmt$0[3],
            pad$2=fmt$0[2],
            iconv$1=fmt$0[1],
            conv$1=integer_conversion_of_char(char_of_iconv(iconv$1)),
            scan$6=
             function(width,param,ib)
              {return scan_int_conversion(conv$1,width,ib)};
           return pad_prec_scanf
                   (ib,
                    rest$8,
                    readers,
                    pad$2,
                    prec$1,
                    scan$6,
                    function(ib)
                     {return caml_int_of_string(token_int_literal(conv$1,ib))});
          case 7:
           var
            rest$9=fmt$0[4],
            prec$2=fmt$0[3],
            pad$3=fmt$0[2],
            iconv$2=fmt$0[1],
            conv$2=integer_conversion_of_char(char_of_iconv(iconv$2)),
            scan$7=
             function(width,param,ib)
              {return scan_int_conversion(conv$2,width,ib)};
           return pad_prec_scanf
                   (ib,
                    rest$9,
                    readers,
                    pad$3,
                    prec$2,
                    scan$7,
                    function(ib)
                     {return caml_int64_of_string(token_int_literal(conv$2,ib))});
          case 8:
           switch(fmt$0[1][2])
            {case 5:
             case 8:
              var rest$11=fmt$0[4],prec$4=fmt$0[3],pad$5=fmt$0[2];
              return pad_prec_scanf
                      (ib,
                       rest$11,
                       readers,
                       pad$5,
                       prec$4,
                       scan_caml_float,
                       token_float);
             case 6:
             case 7:
              var rest$12=fmt$0[4],prec$5=fmt$0[3],pad$6=fmt$0[2];
              return pad_prec_scanf
                      (ib,rest$12,readers,pad$6,prec$5,scan_hex_float,token_float);
             default:
              var rest$10=fmt$0[4],prec$3=fmt$0[3],pad$4=fmt$0[2];
              return pad_prec_scanf
                      (ib,rest$10,readers,pad$4,prec$3,scan_float,token_float)}
          case 9:
           var
            rest$13=fmt$0[2],
            pad$7=fmt$0[1],
            scan$8=
             function(param,_h3_,ib)
              {var
                c=checked_peek_char(ib),
                m=
                 102 === c
                  ?5
                  :116 === c?4:bad_input(caml_call1(sprintf(_cu_),c));
               return scan_string(0,m,ib)};
           return pad_prec_scanf(ib,rest$13,readers,pad$7,0,scan$8,token_bool);
          case 10:
           var rest$14=fmt$0[1];
           if(end_of_input(ib)){var fmt$0=rest$14;continue}
           return bad_input(cst_end_of_input_not_found);
          case 11:
           var rest$15=fmt$0[2],str$0=fmt$0[1];
           iter$4(function(_h2_){return check_char(ib,_h2_)},str$0);
           var fmt$0=rest$15;
           continue;
          case 12:
           var rest$16=fmt$0[2],chr=fmt$0[1];
           check_char(ib,chr);
           var fmt$0=rest$16;
           continue;
          case 13:
           var rest$17=fmt$0[3],fmtty=fmt$0[2],pad_opt=fmt$0[1];
           scan_caml_string(width_of_pad_opt(pad_opt),ib);
           var s=token_string(ib);
           try
            {var _hU_=format_of_string_fmtty(s,fmtty),fmt$3=_hU_}
           catch(exn)
            {exn = caml_wrap_exception(exn);
             if(exn[1] !== Failure)throw exn;
             var msg=exn[2],fmt$3=bad_input(msg)}
           return [0,fmt$3,make_scanf(ib,rest$17,readers)];
          case 14:
           var rest$18=fmt$0[3],fmtty$0=fmt$0[2],pad_opt$0=fmt$0[1];
           scan_caml_string(width_of_pad_opt(pad_opt$0),ib);
           var s$0=token_string(ib);
           try
            {var
              match$2=fmt_ebb_of_string(0,s$0),
              fmt$6=match$2[1],
              match$3=fmt_ebb_of_string(0,s$0),
              fmt$7=match$3[1],
              fmt$8=type_format(fmt$7,erase_rel(symm(fmtty$0))),
              _hW_=type_format(fmt$6,erase_rel(fmtty$0)),
              fmt$5=fmt$8,
              fmt$4=_hW_}
           catch(exn)
            {exn = caml_wrap_exception(exn);
             if(exn[1] !== Failure)throw exn;
             var
              msg$0=exn[2],
              _hV_=bad_input(msg$0),
              fmt$5=_hV_[2],
              fmt$4=_hV_[1]}
           return [0,
                   [0,fmt$4,s$0],
                   make_scanf(ib,concat_fmt(fmt$5,rest$18),readers)];
          case 15:return invalid_arg(cst_scanf_bad_conversion_a);
          case 16:return invalid_arg(cst_scanf_bad_conversion_t);
          case 17:
           var
            rest$19=fmt$0[2],
            formatting_lit=fmt$0[1],
            _hX_=string_of_formatting_lit(formatting_lit);
           iter$4(function(_h1_){return check_char(ib,_h1_)},_hX_);
           var fmt$0=rest$19;
           continue;
          case 18:
           var _hY_=fmt$0[1];
           if(0 === _hY_[0])
            {var rest$20=fmt$0[2],match$4=_hY_[1],fmt$9=match$4[1];
             check_char(ib,64);
             check_char(ib,123);
             var fmt$10=concat_fmt(fmt$9,rest$20),fmt$0=fmt$10;
             continue}
           var rest$21=fmt$0[2],match$5=_hY_[1],fmt$11=match$5[1];
           check_char(ib,64);
           check_char(ib,91);
           var fmt$12=concat_fmt(fmt$11,rest$21),fmt$0=fmt$12;
           continue;
          case 19:
           var fmt_rest=fmt$0[1];
           if(readers)
            {var
              readers_rest=readers[2],
              reader=readers[1],
              x=caml_call1(reader,ib);
             return [0,x,make_scanf(ib,fmt_rest,readers_rest)]}
           return invalid_arg(cst_scanf_missing_reader);
          case 20:
           var _hZ_=fmt$0[1],_h0_=fmt$0[3];
           if(typeof _h0_ !== "number" && 17 === _h0_[0])
            {var
              rest$23=_h0_[2],
              fmting_lit$0=_h0_[1],
              char_set$0=fmt$0[2],
              match$6=stopper_of_formatting_lit(fmting_lit$0),
              str$1=match$6[2],
              stp$0=match$6[1],
              width$0=width_of_pad_opt(_hZ_);
             scan_chars_in_char_set(char_set$0,[0,stp$0],width$0,ib);
             var s$2=token_string(ib),str_rest$0=[11,str$1,rest$23];
             return [0,s$2,make_scanf(ib,str_rest$0,readers)]}
           var
            rest$22=fmt$0[3],
            char_set=fmt$0[2],
            width=width_of_pad_opt(_hZ_);
           scan_chars_in_char_set(char_set,0,width,ib);
           var s$1=token_string(ib);
           return [0,s$1,make_scanf(ib,rest$22,readers)];
          case 21:
           var
            rest$24=fmt$0[2],
            counter=fmt$0[1],
            count=get_counter(ib,counter);
           return [0,count,make_scanf(ib,rest$24,readers)];
          case 22:
           var rest$25=fmt$0[1],c$1=checked_peek_char(ib);
           return [0,c$1,make_scanf(ib,rest$25,readers)];
          case 23:
           var
            rest$26=fmt$0[2],
            ign=fmt$0[1],
            match$7=param_format_of_ignored_format(ign,rest$26),
            fmt$13=match$7[1],
            match$8=make_scanf(ib,fmt$13,readers);
           if(match$8){var arg_rest=match$8[2];return arg_rest}
           throw [0,Assert_failure,_cz_];
          default:return invalid_arg(cst_scanf_bad_conversion_custo)}}
    function pad_prec_scanf(ib,fmt,readers,pad,prec,scan,token)
     {if(typeof pad === "number")
       {if(typeof prec === "number")
         {if(prec)return invalid_arg(cst_scanf_bad_conversion);
          caml_call3(scan,max_int,max_int,ib);
          var x=caml_call1(token,ib);
          return [0,x,make_scanf(ib,fmt,readers)]}
        var p=prec[1];
        caml_call3(scan,max_int,p,ib);
        var x$0=caml_call1(token,ib);
        return [0,x$0,make_scanf(ib,fmt,readers)]}
      else
       {if(0 === pad[0])
         {if(pad[1])
           {var _hQ_=pad[2];
            if(typeof prec === "number")
             {if(prec)return invalid_arg(cst_scanf_bad_conversion$0);
              caml_call3(scan,_hQ_,max_int,ib);
              var x$1=caml_call1(token,ib);
              return [0,x$1,make_scanf(ib,fmt,readers)]}
            var p$0=prec[1];
            caml_call3(scan,_hQ_,p$0,ib);
            var x$2=caml_call1(token,ib);
            return [0,x$2,make_scanf(ib,fmt,readers)]}
          return invalid_arg(cst_scanf_bad_conversion$1)}
        return invalid_arg(cst_scanf_bad_conversion$2)}}
    function kscanf(ib,ef,param)
     {var str=param[2],fmt=param[1];
      function apply(f,args)
       {var f$0=f,args$0=args;
        for(;;)
         {if(args$0)
           {var
             r=args$0[2],
             x=args$0[1],
             f$1=caml_call1(f$0,x),
             f$0=f$1,
             args$0=r;
            continue}
          return f$0}}
      function k(readers,f)
       {reset_token(ib);
        try
         {var _hP_=[0,make_scanf(ib,fmt,readers)],_hO_=_hP_}
        catch(exc)
         {exc = caml_wrap_exception(exc);
          var switch$0=0;
          if
           (exc[1]
            !==
            Scan_failure
            &&
            exc[1]
            !==
            Failure
            &&
            exc
            !==
            End_of_file)
           {if(exc[1] !== Invalid_argument)throw exc;
            var
             msg=exc[2],
             _hN_=
              invalid_arg
               (symbol
                 (msg,symbol(cst_in_format,symbol(escaped$1(str),cst$88))));
            switch$0 = 1}
          if(! switch$0)var _hN_=[1,exc];
          var _hO_=_hN_}
        if(0 === _hO_[0]){var args=_hO_[1];return apply(f,args)}
        var exc=_hO_[1];
        return caml_call2(ef,ib,exc)}
      return take_format_readers(k,fmt)}
    function bscanf(ib,fmt){return kscanf(ib,scanf_bad_input,fmt)}
    function ksscanf(s,ef,fmt){return kscanf(from_string$1(s),ef,fmt)}
    function sscanf(s,fmt)
     {return kscanf(from_string$1(s),scanf_bad_input,fmt)}
    function scanf(fmt){return kscanf(stdib,scanf_bad_input,fmt)}
    function bscanf_format(ib,format,f)
     {scan_caml_string(max_int,ib);
      var str=token_string(ib);
      try
       {var _hM_=format_of_string_format(str,format),fmt=_hM_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] !== Failure)throw exn;
        var msg=exn[2],fmt=bad_input(msg)}
      return caml_call1(f,fmt)}
    function sscanf_format(s,format,f)
     {return bscanf_format(from_string$1(s),format,f)}
    function format_from_string(s,fmt)
     {function _hL_(x){return x}
      return sscanf_format
              (symbol(cst$90,symbol(escaped$1(s),cst$89)),fmt,_hL_)}
    function unescaped(s)
     {function _hK_(x){return x}
      return caml_call1(sscanf(symbol(cst$92,symbol(s,cst$91)),_cA_),_hK_)}
    function kfscanf(ic,ef,fmt){return kscanf(memo_from_channel(ic),ef,fmt)}
    function fscanf(ic,fmt)
     {return kscanf(memo_from_channel(ic),scanf_bad_input,fmt)}
    var
     Stdlib_scanf=
      [0,
       [0,
        stdib,
        from_file,
        from_file_bin,
        close_in$0,
        from_file,
        from_file_bin,
        from_string$1,
        from_function$0,
        from_channel$0,
        end_of_input,
        beginning_of_input,
        name_of_input,
        stdib],
       Scan_failure,
       bscanf,
       sscanf,
       scanf,
       kscanf,
       ksscanf,
       bscanf_format,
       sscanf_format,
       format_from_string,
       unescaped,
       fscanf,
       kfscanf];
    caml_register_global(802,Stdlib_scanf,"Stdlib__scanf");
    function register(name,v){return caml_register_named_value(name,v)}
    function register_exception(name,exn)
     {var slot=caml_obj_tag(exn) === 248?exn:exn[1];
      return caml_register_named_value(name,slot)}
    var Stdlib_callback=[0,register,register_exception];
    caml_register_global(803,Stdlib_callback,"Stdlib__callback");
    function copy$7(o){var o$0=o.slice();return caml_set_oo_id(o$0)}
    var params$0=[0,1,1,1,3,16],initial_object_size=2,dummy_item=0;
    function public_method_label(s)
     {var accu=[0,0],_hH_=caml_ml_string_length(s) - 1 | 0,_hG_=0;
      if(! (_hH_ < 0))
       {var i=_hG_;
        for(;;)
         {var _hI_=caml_string_get(s,i);
          accu[1] = (223 * accu[1] | 0) + _hI_ | 0;
          var _hJ_=i + 1 | 0;
          if(_hH_ !== i){var i=_hJ_;continue}
          break}}
      accu[1] = accu[1] & 2147483647;
      var tag=1073741823 < accu[1]?accu[1] + 2147483648 | 0:accu[1];
      return tag}
    function compare$13(x,y){return caml_string_compare(x,y)}
    var Vars=caml_call1(Stdlib_map[1],[0,compare$13]);
    function compare$14(x,y){return caml_string_compare(x,y)}
    var
     Meths=caml_call1(Stdlib_map[1],[0,compare$14]),
     compare$15=caml_int_compare,
     Labs=caml_call1(Stdlib_map[1],[0,compare$15]),
     dummy_table=[0,0,[0,dummy_item],Meths[1],Labs[1],0,0,Vars[1],0],
     table_count=[0,0],
     dummy_met=caml_obj_block(0,0);
    function fit_size(n){return 2 < n?fit_size((n + 1 | 0) / 2 | 0) * 2 | 0:n}
    function new_table(pub_labels)
     {table_count[1]++;
      var
       len=pub_labels.length - 1,
       methods=caml_make_vect((len * 2 | 0) + 2 | 0,dummy_met);
      caml_check_bound(methods,0)[1] = len;
      var _hA_=((fit_size(len) * 32 | 0) / 8 | 0) - 1 | 0;
      caml_check_bound(methods,1)[2] = _hA_;
      var _hC_=len - 1 | 0,_hB_=0;
      if(! (_hC_ < 0))
       {var i=_hB_;
        for(;;)
         {var
           _hE_=(i * 2 | 0) + 3 | 0,
           _hD_=caml_check_bound(pub_labels,i)[1 + i];
          caml_check_bound(methods,_hE_)[1 + _hE_] = _hD_;
          var _hF_=i + 1 | 0;
          if(_hC_ !== i){var i=_hF_;continue}
          break}}
      return [0,initial_object_size,methods,Meths[1],Labs[1],0,0,Vars[1],0]}
    function resize$1(array,new_size)
     {var old_size=array[2].length - 1,_hy_=old_size < new_size?1:0;
      if(_hy_)
       {var new_buck=caml_make_vect(new_size,dummy_met);
        blit$1(array[2],0,new_buck,0,old_size);
        array[2] = new_buck;
        var _hz_=0}
      else
       var _hz_=_hy_;
      return _hz_}
    var method_count=[0,0],inst_var_count=[0,0];
    function new_method(table)
     {var index=table[2].length - 1;
      resize$1(table,index + 1 | 0);
      return index}
    function get_method_label(table,name)
     {try
       {var _hw_=caml_call2(Meths[28],name,table[3]);return _hw_}
      catch(_hx_)
       {_hx_ = caml_wrap_exception(_hx_);
        if(_hx_ === Not_found)
         {var label=new_method(table);
          table[3] = caml_call3(Meths[4],name,label,table[3]);
          table[4] = caml_call3(Labs[4],label,1,table[4]);
          return label}
        throw _hx_}}
    function get_method_labels(table,names)
     {return map$6(function(_hv_){return get_method_label(table,_hv_)},names)}
    function set_method(table,label,element)
     {method_count[1]++;
      return caml_call2(Labs[28],label,table[4])
              ?(resize$1(table,label + 1 | 0),
                caml_check_bound(table[2],label)[1 + label]
                =
                element,
                0)
              :(table[6] = [0,[0,label,element],table[6]],0)}
    function get_method(table,label)
     {try
       {var _ht_=assoc(label,table[6]);return _ht_}
      catch(_hu_)
       {_hu_ = caml_wrap_exception(_hu_);
        if(_hu_ === Not_found)
         return caml_check_bound(table[2],label)[1 + label];
        throw _hu_}}
    function to_list$3(arr){return 0 === arr?0:to_list$1(arr)}
    function narrow(table,vars,virt_meths,concr_meths)
     {var
       vars$0=to_list$3(vars),
       virt_meths$0=to_list$3(virt_meths),
       concr_meths$0=to_list$3(concr_meths),
       virt_meth_labs=
        map$3
         (function(_hs_){return get_method_label(table,_hs_)},virt_meths$0),
       concr_meth_labs=
        map$3
         (function(_hr_){return get_method_label(table,_hr_)},concr_meths$0);
      table[5]
      =
      [0,
       [0,table[3],table[4],table[6],table[7],virt_meth_labs,vars$0],
       table[5]];
      var _hi_=Vars[1],_hj_=table[7];
      function _hk_(lab,info,tvars)
       {return mem(lab,vars$0)?caml_call3(Vars[4],lab,info,tvars):tvars}
      table[7] = caml_call3(Vars[13],_hk_,_hj_,_hi_);
      var by_name=[0,Meths[1]],by_label=[0,Labs[1]];
      iter2
       (function(met,label)
         {by_name[1] = caml_call3(Meths[4],met,label,by_name[1]);
          var _hn_=by_label[1];
          try
           {var _hp_=caml_call2(Labs[28],label,table[4]),_ho_=_hp_}
          catch(_hq_)
           {_hq_ = caml_wrap_exception(_hq_);
            if(_hq_ !== Not_found)throw _hq_;
            var _ho_=1}
          by_label[1] = caml_call3(Labs[4],label,_ho_,_hn_);
          return 0},
        concr_meths$0,
        concr_meth_labs);
      iter2
       (function(met,label)
         {by_name[1] = caml_call3(Meths[4],met,label,by_name[1]);
          by_label[1] = caml_call3(Labs[4],label,0,by_label[1]);
          return 0},
        virt_meths$0,
        virt_meth_labs);
      table[3] = by_name[1];
      table[4] = by_label[1];
      var _hl_=0,_hm_=table[6];
      table[6]
      =
      fold_right
       (function(met,hm)
         {var lab=met[1];return mem(lab,virt_meth_labs)?hm:[0,met,hm]},
        _hm_,
        _hl_);
      return 0}
    function widen(table)
     {var
       match=hd(table[5]),
       vars=match[6],
       virt_meths=match[5],
       saved_vars=match[4],
       saved_hidden_meths=match[3],
       by_label=match[2],
       by_name=match[1];
      table[5] = tl(table[5]);
      table[7]
      =
      fold_left$0
       (function(s,v)
         {var _hh_=caml_call2(Vars[28],v,table[7]);
          return caml_call3(Vars[4],v,_hh_,s)},
        saved_vars,
        vars);
      table[3] = by_name;
      table[4] = by_label;
      var _hg_=table[6];
      table[6]
      =
      fold_right
       (function(met,hm)
         {var lab=met[1];return mem(lab,virt_meths)?hm:[0,met,hm]},
        _hg_,
        saved_hidden_meths);
      return 0}
    function new_slot(table)
     {var index=table[1];table[1] = index + 1 | 0;return index}
    function new_variable(table,name)
     {try
       {var _he_=caml_call2(Vars[28],name,table[7]);return _he_}
      catch(_hf_)
       {_hf_ = caml_wrap_exception(_hf_);
        if(_hf_ === Not_found)
         {var index=new_slot(table);
          if(caml_string_notequal(name,cst$93))
           table[7] = caml_call3(Vars[4],name,index,table[7]);
          return index}
        throw _hf_}}
    function to_array(arr){return caml_equal(arr,0)?[0]:arr}
    function new_methods_variables(table,meths,vals)
     {var
       meths$0=to_array(meths),
       nmeths=meths$0.length - 1,
       nvals=vals.length - 1,
       res=caml_make_vect(nmeths + nvals | 0,0),
       _g8_=nmeths - 1 | 0,
       _g7_=0;
      if(! (_g8_ < 0))
       {var i$0=_g7_;
        for(;;)
         {var
           _hc_=
            get_method_label(table,caml_check_bound(meths$0,i$0)[1 + i$0]);
          caml_check_bound(res,i$0)[1 + i$0] = _hc_;
          var _hd_=i$0 + 1 | 0;
          if(_g8_ !== i$0){var i$0=_hd_;continue}
          break}}
      var _g__=nvals - 1 | 0,_g9_=0;
      if(! (_g__ < 0))
       {var i=_g9_;
        for(;;)
         {var
           _ha_=i + nmeths | 0,
           _g$_=new_variable(table,caml_check_bound(vals,i)[1 + i]);
          caml_check_bound(res,_ha_)[1 + _ha_] = _g$_;
          var _hb_=i + 1 | 0;
          if(_g__ !== i){var i=_hb_;continue}
          break}}
      return res}
    function get_variable(table,name)
     {try
       {var _g5_=caml_call2(Vars[28],name,table[7]);return _g5_}
      catch(_g6_)
       {_g6_ = caml_wrap_exception(_g6_);
        if(_g6_ === Not_found)throw [0,Assert_failure,_cB_];
        throw _g6_}}
    function get_variables(table,names)
     {return map$6(function(_g4_){return get_variable(table,_g4_)},names)}
    function add_initializer(table,f){table[8] = [0,f,table[8]];return 0}
    function create_table(public_methods)
     {if(0 === public_methods)return new_table([0]);
      var
       tags=map$6(public_method_label,public_methods),
       table=new_table(tags);
      iteri$2
       (function(i,met)
         {var lab=(i * 2 | 0) + 2 | 0;
          table[3] = caml_call3(Meths[4],met,lab,table[3]);
          table[4] = caml_call3(Labs[4],lab,1,table[4]);
          return 0},
        public_methods);
      return table}
    function init_class(table)
     {inst_var_count[1] = (inst_var_count[1] + table[1] | 0) - 1 | 0;
      table[8] = rev(table[8]);
      return resize$1
              (table,
               3 + ((caml_check_bound(table[2],1)[2] * 16 | 0) / 32 | 0) | 0)}
    function inherits(cla,vals,virt_meths,concr_meths,param,top)
     {var env=param[4],super$0=param[2];
      narrow(cla,vals,virt_meths,concr_meths);
      var init=top?caml_call2(super$0,cla,env):caml_call1(super$0,cla);
      widen(cla);
      var
       _gZ_=0,
       _g0_=to_array(concr_meths),
       _g1_=
        [0,
         map$6
          (function(nm){return get_method(cla,get_method_label(cla,nm))},_g0_),
         _gZ_],
       _g2_=to_array(vals);
      return caml_array_concat
              ([0,
                [0,init],
                [0,
                 map$6(function(_g3_){return get_variable(cla,_g3_)},_g2_),
                 _g1_]])}
    function make_class(pub_meths,class_init)
     {var table=create_table(pub_meths),env_init=caml_call1(class_init,table);
      init_class(table);
      return [0,caml_call1(env_init,0),class_init,env_init,0]}
    function make_class_store(pub_meths,class_init,init_table)
     {var table=create_table(pub_meths),env_init=caml_call1(class_init,table);
      init_class(table);
      init_table[2] = class_init;
      init_table[1] = env_init;
      return 0}
    function dummy_class(loc)
     {function undef(param){throw [0,Undefined_recursive_module,loc]}
      return [0,undef,undef,undef,0]}
    function create_object(table)
     {var obj=caml_obj_block(248,table[1]);
      obj[1] = table[2];
      return caml_set_oo_id(obj)}
    function create_object_opt(obj_0,table)
     {if(obj_0)return obj_0;
      var obj=caml_obj_block(248,table[1]);
      obj[1] = table[2];
      return caml_set_oo_id(obj)}
    function iter_f(obj,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],f=param$0[1];
          caml_call1(f,obj);
          var param$0=l;
          continue}
        return 0}}
    function run_initializers(obj,table)
     {var inits=table[8],_gY_=0 !== inits?1:0;
      return _gY_?iter_f(obj,inits):_gY_}
    function run_initializers_opt(obj_0,obj,table)
     {if(obj_0)return obj;
      var inits=table[8];
      if(0 !== inits)iter_f(obj,inits);
      return obj}
    function create_object_and_run_initiali(obj_0,table)
     {if(obj_0)return obj_0;
      var obj=create_object(table);
      run_initializers(obj,table);
      return obj}
    function get_data$0(param)
     {if(param)return param[2];throw [0,Assert_failure,_cF_]}
    function build_path(n,keys,tables)
     {var res=[0,0,0,0],r=[0,res],_gU_=0;
      if(! (n < 0))
       {var i=_gU_;
        for(;;)
         {var _gW_=r[1];
          r[1] = [0,caml_check_bound(keys,i)[1 + i],_gW_,0];
          var _gX_=i + 1 | 0;
          if(n !== i){var i=_gX_;continue}
          break}}
      var _gV_=r[1];
      if(tables){tables[2] = _gV_;return res}
      throw [0,Assert_failure,_cC_]}
    function lookup_tables(root,keys)
     {var tables$2=get_data$0(root);
      if(tables$2)
       {var i$1=keys.length - 1 - 1 | 0,i=i$1,tables=tables$2;
        a:
        for(;;)
         {if(0 <= i)
           {var key=caml_check_bound(keys,i)[1 + i],tables$0=tables;
            for(;;)
             {if(tables$0)
               {if(tables$0[1] === key)
                 {var tables$1=get_data$0(tables$0);
                  if(tables$1)
                   {var i$0=i - 1 | 0,i=i$0,tables=tables$1;continue a}
                  throw [0,Assert_failure,_cH_]}
                if(tables$0)
                 {var _gT_=tables$0[3];
                  if(_gT_){var tables$0=_gT_;continue}
                  var v=[0,key,0,0];
                  if(tables$0)
                   {tables$0[3] = v;return build_path(i - 1 | 0,keys,v)}
                  throw [0,Assert_failure,_cD_]}
                throw [0,Assert_failure,_cG_]}
              throw [0,Assert_failure,_cE_]}}
          return tables}}
      return build_path(keys.length - 1 - 1 | 0,keys,root)}
    function new_cache(table)
     {var n=new_method(table),switch$0=0;
      if
       (0
        !==
        (n % 2 | 0)
        &&
        !
        ((2 + ((caml_check_bound(table[2],1)[2] * 16 | 0) / 32 | 0) | 0) < n))
       {var n$0=new_method(table);switch$0 = 1}
      if(! switch$0)var n$0=n;
      caml_check_bound(table[2],n$0)[1 + n$0] = 0;
      return n$0}
    function set_methods(table,methods)
     {var len=methods.length - 1,i=[0,0];
      for(;;)
       {if(i[1] < len)
         {var
           _gN_=i[1],
           label=caml_check_bound(methods,_gN_)[1 + _gN_],
           next=
            function(param)
             {i[1]++;
              var _gS_=i[1];
              return caml_check_bound(methods,_gS_)[1 + _gS_]},
           clo=next(0);
          if(typeof clo === "number")
           switch(clo)
            {case 0:
              var
               x=next(0),
               clo$0=function(x){return function(obj){return x}}(x);
              break;
             case 1:
              var
               n=next(0),
               clo$0=function(n){return function(obj){return obj[1 + n]}}(n);
              break;
             case 2:
              var
               e=next(0),
               n$0=next(0),
               clo$0=
                function(e,n){return function(obj){return obj[1 + e][1 + n]}}
                 (e,n$0);
              break;
             case 3:
              var
               n$1=next(0),
               clo$0=
                function(n)
                  {return function(obj){return caml_call1(obj[1][1 + n],obj)}}
                 (n$1);
              break;
             case 4:
              var
               n$2=next(0),
               clo$0=
                function(n){return function(obj,x){obj[1 + n] = x;return 0}}
                 (n$2);
              break;
             case 5:
              var
               f=next(0),
               x$0=next(0),
               clo$0=
                function(f,x){return function(obj){return caml_call1(f,x)}}
                 (f,x$0);
              break;
             case 6:
              var
               f$0=next(0),
               n$3=next(0),
               clo$0=
                function(f,n)
                  {return function(obj){return caml_call1(f,obj[1 + n])}}
                 (f$0,n$3);
              break;
             case 7:
              var
               f$1=next(0),
               e$0=next(0),
               n$4=next(0),
               clo$0=
                function(f,e,n)
                  {return function(obj)
                    {return caml_call1(f,obj[1 + e][1 + n])}}
                 (f$1,e$0,n$4);
              break;
             case 8:
              var
               f$2=next(0),
               n$5=next(0),
               clo$0=
                function(f,n)
                  {return function(obj)
                    {return caml_call1(f,caml_call1(obj[1][1 + n],obj))}}
                 (f$2,n$5);
              break;
             case 9:
              var
               f$3=next(0),
               x$1=next(0),
               y=next(0),
               clo$0=
                function(f,x,y)
                  {return function(obj){return caml_call2(f,x,y)}}
                 (f$3,x$1,y);
              break;
             case 10:
              var
               f$4=next(0),
               x$2=next(0),
               n$6=next(0),
               clo$0=
                function(f,x,n)
                  {return function(obj){return caml_call2(f,x,obj[1 + n])}}
                 (f$4,x$2,n$6);
              break;
             case 11:
              var
               f$5=next(0),
               x$3=next(0),
               e$1=next(0),
               n$7=next(0),
               clo$0=
                function(f,x,e,n)
                  {return function(obj)
                    {return caml_call2(f,x,obj[1 + e][1 + n])}}
                 (f$5,x$3,e$1,n$7);
              break;
             case 12:
              var
               f$6=next(0),
               x$4=next(0),
               n$8=next(0),
               clo$0=
                function(f,x,n)
                  {return function(obj)
                    {return caml_call2(f,x,caml_call1(obj[1][1 + n],obj))}}
                 (f$6,x$4,n$8);
              break;
             case 13:
              var
               f$7=next(0),
               n$9=next(0),
               x$5=next(0),
               clo$0=
                function(f,n,x)
                  {return function(obj){return caml_call2(f,obj[1 + n],x)}}
                 (f$7,n$9,x$5);
              break;
             case 14:
              var
               f$8=next(0),
               e$2=next(0),
               n$10=next(0),
               x$6=next(0),
               clo$0=
                function(f,e,n,x)
                  {return function(obj)
                    {return caml_call2(f,obj[1 + e][1 + n],x)}}
                 (f$8,e$2,n$10,x$6);
              break;
             case 15:
              var
               f$9=next(0),
               n$11=next(0),
               x$7=next(0),
               clo$0=
                function(f,n,x)
                  {return function(obj)
                    {return caml_call2(f,caml_call1(obj[1][1 + n],obj),x)}}
                 (f$9,n$11,x$7);
              break;
             case 16:
              var
               n$12=next(0),
               x$8=next(0),
               clo$0=
                function(n,x)
                  {return function(obj)
                    {return caml_call2(obj[1][1 + n],obj,x)}}
                 (n$12,x$8);
              break;
             case 17:
              var
               n$13=next(0),
               m=next(0),
               clo$0=
                function(n,m)
                  {return function(obj)
                    {return caml_call2(obj[1][1 + n],obj,obj[1 + m])}}
                 (n$13,m);
              break;
             case 18:
              var
               n$14=next(0),
               e$3=next(0),
               m$0=next(0),
               clo$0=
                function(n,e,m)
                  {return function(obj)
                    {return caml_call2(obj[1][1 + n],obj,obj[1 + e][1 + m])}}
                 (n$14,e$3,m$0);
              break;
             case 19:
              var
               n$15=next(0),
               m$1=next(0),
               clo$0=
                function(n,m)
                  {return function(obj)
                    {var _gQ_=caml_call1(obj[1][1 + m],obj);
                     return caml_call2(obj[1][1 + n],obj,_gQ_)}}
                 (n$15,m$1);
              break;
             case 20:
              var
               m$2=next(0),
               x$9=next(0),
               c=new_cache(table),
               clo$0=
                function(m,x,c)
                  {return function(obj)
                    {return caml_call2(caml_get_public_method(x,m,0),x,c)}}
                 (m$2,x$9,c);
              break;
             case 21:
              var
               m$3=next(0),
               n$16=next(0),
               c$0=new_cache(table),
               clo$0=
                function(m,n,c)
                  {return function(obj)
                    {var _gP_=obj[1 + n];
                     return caml_call2(caml_get_public_method(_gP_,m,0),_gP_,c)}}
                 (m$3,n$16,c$0);
              break;
             case 22:
              var
               m$4=next(0),
               e$4=next(0),
               n$17=next(0),
               c$1=new_cache(table),
               clo$0=
                function(m,e,n,c)
                  {return function(obj)
                    {var _gO_=obj[1 + e][1 + n];
                     return caml_call2(caml_get_public_method(_gO_,m,0),_gO_,c)}}
                 (m$4,e$4,n$17,c$1);
              break;
             default:
              var
               m$5=next(0),
               n$18=next(0),
               c$2=new_cache(table),
               clo$0=
                function(m,n,c)
                  {return function(obj)
                    {var _gR_=caml_call1(obj[1][1 + n],obj);
                     return caml_call2(caml_get_public_method(_gR_,m,0),_gR_,c)}}
                 (m$5,n$18,c$2)}
          else
           var clo$0=clo;
          set_method(table,label,clo$0);
          i[1]++;
          continue}
        return 0}}
    function stats$0(param)
     {return [0,table_count[1],method_count[1],inst_var_count[1]]}
    var
     CamlinternalOO=
      [0,
       public_method_label,
       new_method,
       new_variable,
       new_methods_variables,
       get_variable,
       get_variables,
       get_method_label,
       get_method_labels,
       get_method,
       set_method,
       set_methods,
       narrow,
       widen,
       add_initializer,
       dummy_table,
       create_table,
       init_class,
       inherits,
       make_class,
       make_class_store,
       dummy_class,
       copy$7,
       create_object,
       create_object_opt,
       run_initializers,
       run_initializers_opt,
       create_object_and_run_initiali,
       lookup_tables,
       params$0,
       stats$0];
    caml_register_global(804,CamlinternalOO,"CamlinternalOO");
    var Stdlib_oo=[0,copy$7,public_method_label,public_method_label];
    caml_register_global(805,Stdlib_oo,"Stdlib__oo");
    var
     update_mod=runtime.caml_CamlinternalMod_update_mod,
     init_mod=runtime.caml_CamlinternalMod_init_mod,
     CamlinternalMod=[0,init_mod,update_mod];
    caml_register_global(806,CamlinternalMod,"CamlinternalMod");
    var
     initial_buffer=caml_create_bytes(32),
     buffer=[0,initial_buffer],
     bufpos=[0,0];
    function reset_buffer(param)
     {buffer[1] = initial_buffer;bufpos[1] = 0;return 0}
    function store(c)
     {if(caml_ml_bytes_length(buffer[1]) <= bufpos[1])
       {var newbuffer=caml_create_bytes(2 * bufpos[1] | 0);
        blit(buffer[1],0,newbuffer,0,bufpos[1]);
        buffer[1] = newbuffer}
      caml_bytes_set(buffer[1],bufpos[1],c);
      bufpos[1]++;
      return 0}
    function get_string(param)
     {var s=sub_string(buffer[1],0,bufpos[1]);
      buffer[1] = initial_buffer;
      return s}
    function make_lexer(keywords)
     {var kwd_table=caml_call2(Stdlib_hashtbl[1],0,17);
      iter$2
       (function(s){return caml_call3(Stdlib_hashtbl[5],kwd_table,s,[0,s])},
        keywords);
      function ident_or_keyword(id)
       {try
         {var _gL_=caml_call2(Stdlib_hashtbl[6],kwd_table,id);return _gL_}
        catch(_gM_)
         {_gM_ = caml_wrap_exception(_gM_);
          if(_gM_ === Not_found)return [1,id];
          throw _gM_}}
      function keyword_or_error(c)
       {var s=make$1(1,c);
        try
         {var _gJ_=caml_call2(Stdlib_hashtbl[6],kwd_table,s);return _gJ_}
        catch(_gK_)
         {_gK_ = caml_wrap_exception(_gK_);
          if(_gK_ === Not_found)
           throw [0,Error,symbol(cst_Illegal_character,s)];
          throw _gK_}}
      function comment(strm)
       {a:
        for(;;)
         {var match=peek$0(strm);
          if(match)
           {var switcher=match[1] - 40 | 0;
            if(! (2 < switcher >>> 0))
             switch(switcher)
              {case 0:
                junk(strm);
                var match$0=peek$0(strm);
                if(match$0)
                 {if(42 === match$0[1]){junk(strm);comment(strm);continue}
                  junk(strm);
                  continue}
                throw Failure$0;
               case 1:break;
               default:
                junk(strm);
                for(;;)
                 {var match$1=peek$0(strm);
                  if(match$1)
                   {var _gI_=match$1[1];
                    if(41 === _gI_){junk(strm);return 0}
                    if(42 === _gI_){junk(strm);continue}
                    junk(strm);
                    continue a}
                  throw Failure$0}}
            junk(strm);
            continue}
          throw Failure$0}}
      function escape(strm)
       {var match=peek$0(strm);
        if(match)
         {var _gF_=match[1];
          if(58 <= _gF_)
           {var switcher=_gF_ - 110 | 0;
            if(! (6 < switcher >>> 0))
             switch(switcher)
              {case 0:junk(strm);return 10;
               case 4:junk(strm);return 13;
               case 6:junk(strm);return 9
               }}
          else
           if(48 <= _gF_)
            {junk(strm);
             var match$0=peek$0(strm);
             if(match$0)
              {var _gG_=match$0[1],switcher$0=_gG_ - 48 | 0;
               if(! (9 < switcher$0 >>> 0))
                {junk(strm);
                 var match$1=peek$0(strm);
                 if(match$1)
                  {var _gH_=match$1[1],switcher$1=_gH_ - 48 | 0;
                   if(! (9 < switcher$1 >>> 0))
                    {junk(strm);
                     return chr
                             ((((_gF_ - 48 | 0) * 100 | 0)
                               +
                               ((_gG_ - 48 | 0) * 10 | 0)
                               |
                               0)
                              +
                              (_gH_ - 48 | 0)
                              |
                              0)}}
                 throw [0,Error,cst$99]}}
             throw [0,Error,cst$98]}
          junk(strm);
          return _gF_}
        throw Failure$0}
      function end_exponent_part(strm)
       {for(;;)
         {var match=peek$0(strm);
          if(match)
           {var _gE_=match[1],switcher=_gE_ - 48 | 0;
            if(! (9 < switcher >>> 0)){junk(strm);store(_gE_);continue}}
          return [0,[3,caml_float_of_string(get_string(0))]]}}
      function exponent_part(strm)
       {var match=peek$0(strm);
        if(match)
         {var _gD_=match[1],switch$0=0;
          if(43 !== _gD_ && 45 !== _gD_)switch$0 = 1;
          if(! switch$0)
           {junk(strm);store(_gD_);return end_exponent_part(strm)}}
        return end_exponent_part(strm)}
      function number(s)
       {for(;;)
         {var match=peek$0(s);
          if(match)
           {var _gA_=match[1];
            if(58 <= _gA_)
             {var switch$0=0;
              if(69 === _gA_ || 101 === _gA_)switch$0 = 1;
              if(switch$0){junk(s);store(69);return exponent_part(s)}}
            else
             {if(46 === _gA_)
               {junk(s);
                store(46);
                for(;;)
                 {var match$0=peek$0(s);
                  if(match$0)
                   {var _gB_=match$0[1],_gC_=_gB_ - 69 | 0;
                    if(32 < _gC_ >>> 0)
                     {var switcher=_gC_ + 21 | 0;
                      if(! (9 < switcher >>> 0)){junk(s);store(_gB_);continue}}
                    else
                     {var switcher$0=_gC_ - 1 | 0;
                      if(30 < switcher$0 >>> 0)
                       {junk(s);store(69);return exponent_part(s)}}}
                  return [0,[3,caml_float_of_string(get_string(0))]]}}
              if(48 <= _gA_){junk(s);store(_gA_);continue}}}
          return [0,[2,caml_int_of_string(get_string(0))]]}}
      function ident2(strm)
       {for(;;)
         {var match=peek$0(strm);
          if(match)
           {var _gy_=match[1],switch$0=0;
            if(94 <= _gy_)
             {var _gz_=_gy_ - 95 | 0;
              if(30 < _gz_ >>> 0)
               {if(! (32 <= _gz_))switch$0 = 1}
              else
               if(29 === _gz_)switch$0 = 1}
            else
             if(65 <= _gy_)
              {if(92 === _gy_)switch$0 = 1}
             else
              if(33 <= _gy_)
               switch(_gy_ - 33 | 0)
                {case 0:
                 case 2:
                 case 3:
                 case 4:
                 case 5:
                 case 9:
                 case 10:
                 case 12:
                 case 14:
                 case 25:
                 case 27:
                 case 28:
                 case 29:
                 case 30:
                 case 31:switch$0 = 1;break
                 }
            if(switch$0){junk(strm);store(_gy_);continue}}
          return [0,ident_or_keyword(get_string(0))]}}
      function neg_number(s)
       {var match=peek$0(s);
        if(match)
         {var _gx_=match[1],switcher=_gx_ - 48 | 0;
          if(! (9 < switcher >>> 0))
           {junk(s);reset_buffer(0);store(45);store(_gx_);return number(s)}}
        reset_buffer(0);
        store(45);
        return ident2(s)}
      function ident(strm)
       {for(;;)
         {var match=peek$0(strm);
          if(match)
           {var _gv_=match[1],switch$0=0;
            if(91 <= _gv_)
             {var _gw_=_gv_ - 95 | 0;
              if(27 < _gw_ >>> 0)
               {if(97 <= _gw_)switch$0 = 1}
              else
               if(1 !== _gw_)switch$0 = 1}
            else
             if(48 <= _gv_)
              {if(6 < (_gv_ - 58 | 0) >>> 0)switch$0 = 1}
             else
              if(39 === _gv_)switch$0 = 1;
            if(switch$0){junk(strm);store(_gv_);continue}}
          return [0,ident_or_keyword(get_string(0))]}}
      function next_token$0(counter,strm)
       {for(;;)
         {var match=peek$0(strm);
          if(match)
           {var _gl_=match[1],switch$0=0;
            if(124 <= _gl_)
             {if(127 <= _gl_)
               {if(192 <= _gl_)switch$0 = 1}
              else
               if(125 !== _gl_)switch$0 = 2}
            else
             {var _gm_=_gl_ - 65 | 0;
              if(57 < _gm_ >>> 0)
               {if(! (58 <= _gm_))
                 {var switcher=_gm_ + 65 | 0;
                  switch(switcher)
                   {case 34:
                     junk(strm);
                     reset_buffer(0);
                     for(;;)
                      {var match$1=peek$0(strm);
                       if(match$1)
                        {var _go_=match$1[1];
                         if(34 === _go_){junk(strm);return [0,[4,get_string(0)]]}
                         if(92 === _go_)
                          {junk(strm);
                           try
                            {var c$0=escape(strm)}
                           catch(_gu_)
                            {_gu_ = caml_wrap_exception(_gu_);
                             if(_gu_ === Failure$0)throw [0,Error,cst$96];
                             throw _gu_;
                             var _gr_=_gu_}
                           store(c$0);
                           continue}
                         junk(strm);
                         store(_go_);
                         continue}
                       throw Failure$0}
                    case 39:
                     junk(strm);
                     try
                      {var match$2=peek$0(strm);
                       if(! match$2)throw Failure$0;
                       var _gp_=match$2[1];
                       if(92 === _gp_)
                        {junk(strm);
                         try
                          {var _gq_=escape(strm)}
                         catch(_gt_)
                          {_gt_ = caml_wrap_exception(_gt_);
                           if(_gt_ === Failure$0)throw [0,Error,cst$97];
                           throw _gt_}
                         var c=_gq_}
                       else
                        {junk(strm);var c=_gp_}}
                     catch(_gs_)
                      {_gs_ = caml_wrap_exception(_gs_);
                       if(_gs_ === Failure$0)throw [0,Error,cst$94];
                       throw _gs_}
                     var match$0=peek$0(strm);
                     if(match$0 && 39 === match$0[1])
                      {junk(strm);return [0,[5,c]]}
                     throw [0,Error,cst$95];
                    case 40:
                     junk(strm);
                     if(counter < 50)
                      {var counter$0=counter + 1 | 0;
                       return maybe_comment(counter$0,strm)}
                     return caml_trampoline_return(maybe_comment,[0,strm]);
                    case 45:junk(strm);return neg_number(strm);
                    case 9:
                    case 10:
                    case 12:
                    case 13:
                    case 26:
                    case 32:junk(strm);continue;
                    case 48:
                    case 49:
                    case 50:
                    case 51:
                    case 52:
                    case 53:
                    case 54:
                    case 55:
                    case 56:
                    case 57:
                     junk(strm);reset_buffer(0);store(_gl_);return number(strm);
                    case 33:
                    case 35:
                    case 36:
                    case 37:
                    case 38:
                    case 42:
                    case 43:
                    case 47:
                    case 58:
                    case 60:
                    case 61:
                    case 62:
                    case 63:
                    case 64:switch$0 = 2;break
                    }}}
              else
               {var _gn_=_gm_ - 26 | 0;
                if(5 < _gn_ >>> 0)
                 switch$0 = 1;
                else
                 switch(_gn_)
                  {case 4:switch$0 = 1;break;case 1:case 3:switch$0 = 2;break}}}
            switch(switch$0)
             {case 0:junk(strm);return [0,keyword_or_error(_gl_)];
              case 1:
               junk(strm);reset_buffer(0);store(_gl_);return ident(strm);
              default:
               junk(strm);reset_buffer(0);store(_gl_);return ident2(strm)}}
          return 0}}
      function maybe_comment(counter,strm)
       {var match=peek$0(strm);
        if(match && 42 === match[1])
         {junk(strm);
          comment(strm);
          if(counter < 50)
           {var counter$0=counter + 1 | 0;return next_token$0(counter$0,strm)}
          return caml_trampoline_return(next_token$0,[0,strm])}
        return [0,keyword_or_error(40)]}
      function next_token(strm){return caml_trampoline(next_token$0(0,strm))}
      return function(input)
       {return from(function(count){return next_token(input)})}}
    var Stdlib_genlex=[0,make_lexer];
    caml_register_global(807,Stdlib_genlex,"Stdlib__genlex");
    function MakeSeeded$0(H)
     {var prng=[246,function(_gk_){return caml_call1(_b$_[2],0)}];
      function create(opt,initial_size)
       {if(opt)
         var sth=opt[1],random=sth;
        else
         var random=caml_call1(Stdlib_hashtbl[17],0);
        var x=16;
        for(;;)
         {if(! (initial_size <= x) && ! (max_array_length < (x * 2 | 0)))
           {var x$0=x * 2 | 0,x=x$0;continue}
          if(random)
           var
            _gi_=caml_obj_tag(prng),
            _gj_=250 === _gi_?prng[1]:246 === _gi_?force_lazy_block(prng):prng,
            seed=caml_call1(_b$_[4],_gj_);
          else
           var seed=0;
          return [0,0,caml_make_vect(x,0),seed,x]}}
      function clear(h)
       {h[1] = 0;
        var len=h[2].length - 1,_gg_=len - 1 | 0,_gf_=0;
        if(! (_gg_ < 0))
         {var i=_gf_;
          for(;;)
           {caml_check_bound(h[2],i)[1 + i] = 0;
            var _gh_=i + 1 | 0;
            if(_gg_ !== i){var i=_gh_;continue}
            break}}
        return 0}
      function reset(h)
       {var len=h[2].length - 1;
        return len === h[4]
                ?clear(h)
                :(h[1] = 0,h[2] = caml_make_vect(h[4],0),0)}
      function copy(init)
       {var _gc_=init[4],_gd_=init[3],_ge_=copy$1(init[2]);
        return [0,init[1],_ge_,_gd_,_gc_]}
      function key_index(h,hkey){return hkey & (h[2].length - 1 - 1 | 0)}
      function clean(h)
       {function do_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var hkey=param$0[1],rest=param$0[3],c=param$0[2];
              if(caml_call1(H[7],c))
               {var rest$0=param$0[3],c$0=param$0[2];
                return [0,hkey,c$0,do_bucket(rest$0)]}
              h[1] = h[1] - 1 | 0;
              var param$0=rest;
              continue}
            return 0}}
        var d=h[2],_f$_=d.length - 1 - 1 | 0,_f__=0;
        if(! (_f$_ < 0))
         {var i=_f__;
          for(;;)
           {var _ga_=do_bucket(caml_check_bound(d,i)[1 + i]);
            caml_check_bound(d,i)[1 + i] = _ga_;
            var _gb_=i + 1 | 0;
            if(_f$_ !== i){var i=_gb_;continue}
            break}}
        return 0}
      function resize(h)
       {var odata=h[2],osize=odata.length - 1,nsize=osize * 2 | 0;
        clean(h);
        var
         _f3_=nsize < max_array_length?1:0,
         _f4_=_f3_?(osize >>> 1 | 0) <= h[1]?1:0:_f3_;
        if(_f4_)
         {var ndata=caml_make_vect(nsize,0);
          h[2] = ndata;
          var
           insert_bucket=
            function(param)
             {if(param)
               {var rest=param[3],data=param[2],hkey=param[1];
                insert_bucket(rest);
                var
                 nidx=key_index(h,hkey),
                 _f9_=[0,hkey,data,caml_check_bound(ndata,nidx)[1 + nidx]];
                caml_check_bound(ndata,nidx)[1 + nidx] = _f9_;
                return 0}
              return 0},
           _f6_=osize - 1 | 0,
           _f5_=0;
          if(! (_f6_ < 0))
           {var i=_f5_;
            for(;;)
             {insert_bucket(caml_check_bound(odata,i)[1 + i]);
              var _f8_=i + 1 | 0;
              if(_f6_ !== i){var i=_f8_;continue}
              break}}
          var _f7_=0}
        else
         var _f7_=_f4_;
        return _f7_}
      function add(h,key,info)
       {var
         hkey=caml_call2(H[2],h[3],key),
         i=key_index(h,hkey),
         container=caml_call2(H[1],key,info),
         bucket=[0,hkey,container,caml_check_bound(h[2],i)[1 + i]];
        caml_check_bound(h[2],i)[1 + i] = bucket;
        h[1] = h[1] + 1 | 0;
        var _f2_=h[2].length - 1 << 1 < h[1]?1:0;
        return _f2_?resize(h):_f2_}
      function remove(h,key)
       {var hkey=caml_call2(H[2],h[3],key);
        function remove_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var hk=param$0[1],next=param$0[3],c=param$0[2];
              if(hkey === hk)
               {var match=caml_call2(H[3],c,key);
                switch(match)
                 {case 0:h[1] = h[1] - 1 | 0;return next;
                  case 1:return [0,hk,c,remove_bucket(next)];
                  default:h[1] = h[1] - 1 | 0;var param$0=next;continue}}
              var next$0=param$0[3],c$0=param$0[2];
              return [0,hk,c$0,remove_bucket(next$0)]}
            return 0}}
        var
         i=key_index(h,hkey),
         _f1_=remove_bucket(caml_check_bound(h[2],i)[1 + i]);
        caml_check_bound(h[2],i)[1 + i] = _f1_;
        return 0}
      function find(h,key)
       {var
         hkey=caml_call2(H[2],h[3],key),
         _f0_=key_index(h,hkey),
         param$1=caml_check_bound(h[2],_f0_)[1 + _f0_],
         param=param$1;
        for(;;)
         {if(param)
           {var hk=param[1],rest=param[3],c=param[2];
            if(hkey === hk)
             {var match=caml_call2(H[3],c,key);
              switch(match)
               {case 0:
                 var match$0=caml_call1(H[4],c);
                 if(match$0){var d=match$0[1];return d}
                 var param=rest;
                 continue;
                case 1:var param=rest;continue;
                default:var param=rest;continue}}
            var param$0=param[3],param=param$0;
            continue}
          throw Not_found}}
      function find_opt(h,key)
       {var
         hkey=caml_call2(H[2],h[3],key),
         _fZ_=key_index(h,hkey),
         param$1=caml_check_bound(h[2],_fZ_)[1 + _fZ_],
         param=param$1;
        for(;;)
         {if(param)
           {var hk=param[1],rest=param[3],c=param[2];
            if(hkey === hk)
             {var match=caml_call2(H[3],c,key);
              switch(match)
               {case 0:
                 var d=caml_call1(H[4],c);
                 if(d)return d;
                 var param=rest;
                 continue;
                case 1:var param=rest;continue;
                default:var param=rest;continue}}
            var param$0=param[3],param=param$0;
            continue}
          return 0}}
      function find_all(h,key)
       {var hkey=caml_call2(H[2],h[3],key);
        function find_in_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var hk=param$0[1],rest=param$0[3],c=param$0[2];
              if(hkey === hk)
               {var match=caml_call2(H[3],c,key);
                switch(match)
                 {case 0:
                   var match$0=caml_call1(H[4],c);
                   if(match$0)
                    {var d=match$0[1];return [0,d,find_in_bucket(rest)]}
                   var param$0=rest;
                   continue;
                  case 1:var param$0=rest;continue;
                  default:var param$0=rest;continue}}
              var param$1=param$0[3],param$0=param$1;
              continue}
            return 0}}
        var _fY_=key_index(h,hkey);
        return find_in_bucket(caml_check_bound(h[2],_fY_)[1 + _fY_])}
      function replace(h,key,info)
       {var hkey=caml_call2(H[2],h[3],key);
        function replace_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var hk=param$0[1],next=param$0[3],c=param$0[2];
              if(hkey === hk)
               {var match=caml_call2(H[3],c,key);
                if(match){var param$0=next;continue}
                return caml_call3(H[6],c,key,info)}
              var param$1=param$0[3],param$0=param$1;
              continue}
            throw Not_found}}
        var i=key_index(h,hkey),l=caml_check_bound(h[2],i)[1 + i];
        try
         {var _fW_=replace_bucket(l);return _fW_}
        catch(_fX_)
         {_fX_ = caml_wrap_exception(_fX_);
          if(_fX_ === Not_found)
           {var container=caml_call2(H[1],key,info);
            caml_check_bound(h[2],i)[1 + i] = [0,hkey,container,l];
            h[1] = h[1] + 1 | 0;
            var _fV_=h[2].length - 1 << 1 < h[1]?1:0;
            return _fV_?resize(h):_fV_}
          throw _fX_}}
      function mem(h,key)
       {var
         hkey=caml_call2(H[2],h[3],key),
         _fU_=key_index(h,hkey),
         param$1=caml_check_bound(h[2],_fU_)[1 + _fU_],
         param=param$1;
        for(;;)
         {if(param)
           {var hk=param[1],rest=param[3],c=param[2];
            if(hk === hkey)
             {var match=caml_call2(H[3],c,key);
              if(match){var param=rest;continue}
              return 1}
            var param$0=param[3],param=param$0;
            continue}
          return 0}}
      function iter$0(f,h)
       {var d$0=h[2],_fS_=d$0.length - 1 - 1 | 0,_fR_=0;
        if(! (_fS_ < 0))
         {var i=_fR_;
          a:
          for(;;)
           {var param$0=caml_check_bound(d$0,i)[1 + i],param=param$0;
            for(;;)
             {if(param)
               {var
                 rest=param[3],
                 c=param[2],
                 match=caml_call1(H[5],c),
                 match$0=caml_call1(H[4],c),
                 switch$0=0;
                if(match && match$0)
                 {var d=match$0[1],k=match[1];caml_call2(f,k,d);switch$0 = 1}
                var param=rest;
                continue}
              var _fT_=i + 1 | 0;
              if(_fS_ !== i){var i=_fT_;continue a}
              break}
            break}}
        return 0}
      function fold(f,h,init)
       {var d$0=h[2],accu$1=[0,init],_fO_=d$0.length - 1 - 1 | 0,_fN_=0;
        if(! (_fO_ < 0))
         {var i=_fN_;
          a:
          for(;;)
           {var
             _fP_=accu$1[1],
             b$0=caml_check_bound(d$0,i)[1 + i],
             b=b$0,
             accu=_fP_;
            for(;;)
             {if(b)
               {var
                 rest=b[3],
                 c=b[2],
                 match=caml_call1(H[5],c),
                 match$0=caml_call1(H[4],c),
                 switch$0=0;
                if(match && match$0)
                 {var d=match$0[1],k=match[1],accu$0=caml_call3(f,k,d,accu);
                  switch$0 = 1}
                if(! switch$0)var accu$0=accu;
                var b=rest,accu=accu$0;
                continue}
              accu$1[1] = accu;
              var _fQ_=i + 1 | 0;
              if(_fO_ !== i){var i=_fQ_;continue a}
              break}
            break}}
        return accu$1[1]}
      function filter_map_inplace(f,h)
       {function do_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var
               rest=param$0[3],
               c=param$0[2],
               hk=param$0[1],
               match=caml_call1(H[5],c),
               match$0=caml_call1(H[4],c);
              if(match && match$0)
               {var d=match$0[1],k=match[1],match$1=caml_call2(f,k,d);
                if(match$1)
                 {var new_d=match$1[1];
                  caml_call3(H[6],c,k,new_d);
                  return [0,hk,c,do_bucket(rest)]}
                var param$0=rest;
                continue}
              var param$0=rest;
              continue}
            return 0}}
        var d=h[2],_fK_=d.length - 1 - 1 | 0,_fJ_=0;
        if(! (_fK_ < 0))
         {var i=_fJ_;
          for(;;)
           {var _fL_=do_bucket(caml_check_bound(d,i)[1 + i]);
            caml_check_bound(d,i)[1 + i] = _fL_;
            var _fM_=i + 1 | 0;
            if(_fK_ !== i){var i=_fM_;continue}
            break}}
        return 0}
      function length(h){return h[1]}
      function bucket_length(accu,param)
       {var accu$0=accu,param$0=param;
        for(;;)
         {if(param$0)
           {var
             param$1=param$0[3],
             accu$1=accu$0 + 1 | 0,
             accu$0=accu$1,
             param$0=param$1;
            continue}
          return accu$0}}
      function stats(h)
       {var
         _fF_=h[2],
         _fG_=0,
         mbl=
          fold_left$1
           (function(m,b){return max(m,bucket_length(0,b))},_fG_,_fF_),
         histo=caml_make_vect(mbl + 1 | 0,0),
         _fH_=h[2];
        iter$5
         (function(b)
           {var
             l=bucket_length(0,b),
             _fI_=caml_check_bound(histo,l)[1 + l] + 1 | 0;
            caml_check_bound(histo,l)[1 + l] = _fI_;
            return 0},
          _fH_);
        return [0,h[1],h[2].length - 1,mbl,histo]}
      function bucket_length_alive(accu,param)
       {var accu$0=accu,param$0=param;
        for(;;)
         {if(param$0)
           {var rest=param$0[3],c=param$0[2];
            if(caml_call1(H[7],c))
             {var accu$1=accu$0 + 1 | 0,accu$0=accu$1,param$0=rest;continue}
            var param$1=param$0[3],param$0=param$1;
            continue}
          return accu$0}}
      function stats_alive(h)
       {var
         size=[0,0],
         _fB_=h[2],
         _fC_=0,
         mbl=
          fold_left$1
           (function(m,b){return max(m,bucket_length_alive(0,b))},_fC_,_fB_),
         histo=caml_make_vect(mbl + 1 | 0,0),
         _fD_=h[2];
        iter$5
         (function(b)
           {var l=bucket_length_alive(0,b);
            size[1] = size[1] + l | 0;
            var _fE_=caml_check_bound(histo,l)[1 + l] + 1 | 0;
            caml_check_bound(histo,l)[1 + l] = _fE_;
            return 0},
          _fD_);
        return [0,size[1],h[2].length - 1,mbl,histo]}
      function to_seq(tbl)
       {var tbl_data=tbl[2];
        function aux(i,buck,param)
         {var i$0=i,buck$0=buck;
          for(;;)
           {if(buck$0)
             {var
               next=buck$0[3],
               c=buck$0[2],
               match=caml_call1(H[5],c),
               match$0=caml_call1(H[4],c);
              if(match && match$0)
               {var data=match$0[1],key=match[1];
                return [0,
                        [0,key,data],
                        function(_fA_){return aux(i$0,next,_fA_)}]}
              var buck$0=next;
              continue}
            if(i$0 === tbl_data.length - 1)return 0;
            var
             buck$1=caml_check_bound(tbl_data,i$0)[1 + i$0],
             i$1=i$0 + 1 | 0,
             i$0=i$1,
             buck$0=buck$1;
            continue}}
        var _fx_=0,_fy_=0;
        return function(_fz_){return aux(_fy_,_fx_,_fz_)}}
      function to_seq_keys(m)
       {var _ft_=to_seq(m);
        function _fu_(_fw_){return _fw_[1]}
        return function(_fv_){return map(_fu_,_ft_,_fv_)}}
      function to_seq_values(m)
       {var _fp_=to_seq(m);
        function _fq_(_fs_){return _fs_[2]}
        return function(_fr_){return map(_fq_,_fp_,_fr_)}}
      function add_seq(tbl,i)
       {return iter
                (function(param)
                  {var v=param[2],k=param[1];return add(tbl,k,v)},
                 i)}
      function replace_seq(tbl,i)
       {return iter
                (function(param)
                  {var v=param[2],k=param[1];return replace(tbl,k,v)},
                 i)}
      function of_seq(i){var tbl=create(0,16);replace_seq(tbl,i);return tbl}
      return [0,
              create,
              clear,
              reset,
              copy,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter$0,
              filter_map_inplace,
              fold,
              length,
              stats,
              to_seq,
              to_seq_keys,
              to_seq_values,
              add_seq,
              replace_seq,
              of_seq,
              clean,
              stats_alive]}
    function create$5(param){return caml_call1(_t_[1],1)}
    function get_key$0(t){return caml_call2(_t_[3],t,0)}
    function get_key_copy$0(t){return caml_call2(_t_[4],t,0)}
    function set_key$0(t,k){return caml_call3(_t_[5],t,0,k)}
    function unset_key$0(t){return caml_call2(_t_[6],t,0)}
    function check_key$0(t){return caml_call2(_t_[7],t,0)}
    function blit_key$0(t1,t2){return caml_call5(_t_[8],t1,0,t2,0,1)}
    function get_data$1(t){return caml_call1(_t_[9],t)}
    function get_data_copy(t){return caml_call1(_t_[10],t)}
    function set_data(t,d){return caml_call2(_t_[11],t,d)}
    function unset_data(t){return caml_call1(_t_[12],t)}
    function check_data(t){return caml_call1(_t_[13],t)}
    function blit_data(t1,t2){return caml_call2(_t_[14],t1,t2)}
    function MakeSeeded$1(H)
     {function create(k,d)
       {var c=create$5(0);set_data(c,d);set_key$0(c,k);return c}
      var hash=H[2];
      function equal(c,k)
       {var match=get_key$0(c);
        if(match){var k$0=match[1];return caml_call2(H[1],k,k$0)?0:1}
        return 2}
      function set_key_data(c,k,d)
       {unset_data(c);set_key$0(c,k);return set_data(c,d)}
      return MakeSeeded$0
              ([0,
                create,
                hash,
                equal,
                get_data$1,
                get_key$0,
                set_key_data,
                check_key$0])}
    function Make$2(H)
     {var equal=H[1];
      function hash(seed,x){return caml_call1(H[2],x)}
      var
       include=MakeSeeded$1([0,equal,hash]),
       clear=include[2],
       reset=include[3],
       copy=include[4],
       add=include[5],
       remove=include[6],
       find=include[7],
       find_opt=include[8],
       find_all=include[9],
       replace=include[10],
       mem=include[11],
       iter=include[12],
       filter_map_inplace=include[13],
       fold=include[14],
       length=include[15],
       stats=include[16],
       to_seq=include[17],
       to_seq_keys=include[18],
       to_seq_values=include[19],
       add_seq=include[20],
       replace_seq=include[21],
       clean=include[23],
       stats_alive=include[24],
       _fo_=include[1];
      function create(sz){return caml_call2(_fo_,_cI_,sz)}
      function of_seq(i)
       {var tbl=create(16);caml_call2(replace_seq,tbl,i);return tbl}
      return [0,
              create,
              clear,
              reset,
              copy,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter,
              filter_map_inplace,
              fold,
              length,
              stats,
              to_seq,
              to_seq_keys,
              to_seq_values,
              add_seq,
              replace_seq,
              of_seq,
              clean,
              stats_alive]}
    function create$6(param){return caml_call1(_t_[1],2)}
    function get_key1(t){return caml_call2(_t_[3],t,0)}
    function get_key1_copy(t){return caml_call2(_t_[4],t,0)}
    function set_key1(t,k){return caml_call3(_t_[5],t,0,k)}
    function unset_key1(t){return caml_call2(_t_[6],t,0)}
    function check_key1(t){return caml_call2(_t_[7],t,0)}
    function get_key2(t){return caml_call2(_t_[3],t,1)}
    function get_key2_copy(t){return caml_call2(_t_[4],t,1)}
    function set_key2(t,k){return caml_call3(_t_[5],t,1,k)}
    function unset_key2(t){return caml_call2(_t_[6],t,1)}
    function check_key2(t){return caml_call2(_t_[7],t,1)}
    function blit_key1(t1,t2){return caml_call5(_t_[8],t1,0,t2,0,1)}
    function blit_key2(t1,t2){return caml_call5(_t_[8],t1,1,t2,1,1)}
    function blit_key12(t1,t2){return caml_call5(_t_[8],t1,0,t2,0,2)}
    function get_data$2(t){return caml_call1(_t_[9],t)}
    function get_data_copy$0(t){return caml_call1(_t_[10],t)}
    function set_data$0(t,d){return caml_call2(_t_[11],t,d)}
    function unset_data$0(t){return caml_call1(_t_[12],t)}
    function check_data$0(t){return caml_call1(_t_[13],t)}
    function blit_data$0(t1,t2){return caml_call2(_t_[14],t1,t2)}
    function MakeSeeded$2(H1,H2)
     {function create(param,d)
       {var k2=param[2],k1=param[1],c=create$6(0);
        set_data$0(c,d);
        set_key1(c,k1);
        set_key2(c,k2);
        return c}
      function hash(seed,param)
       {var
         k2=param[2],
         k1=param[1],
         _fn_=caml_call2(H2[2],seed,k2) * 65599 | 0;
        return caml_call2(H1[2],seed,k1) + _fn_ | 0}
      function equal(c,param)
       {var k2=param[2],k1=param[1],match=get_key1(c),match$0=get_key2(c);
        if(match && match$0)
         {var k2$0=match$0[1],k1$0=match[1];
          if(caml_call2(H1[1],k1,k1$0) && caml_call2(H2[1],k2,k2$0))return 0;
          return 1}
        return 2}
      function get_key(c)
       {var match=get_key1(c),match$0=get_key2(c);
        if(match && match$0)
         {var k2=match$0[1],k1=match[1];return [0,[0,k1,k2]]}
        return 0}
      function set_key_data(c,param,d)
       {var k2=param[2],k1=param[1];
        unset_data$0(c);
        set_key1(c,k1);
        set_key2(c,k2);
        return set_data$0(c,d)}
      function check_key(c)
       {var _fm_=check_key1(c);return _fm_?check_key2(c):_fm_}
      return MakeSeeded$0
              ([0,create,hash,equal,get_data$2,get_key,set_key_data,check_key])}
    function Make$3(H1,H2)
     {var equal=H2[1];
      function hash(seed,x){return caml_call1(H2[2],x)}
      var equal$0=H1[1],_fk_=[0,equal,hash];
      function hash$0(seed,x){return caml_call1(H1[2],x)}
      var
       include=MakeSeeded$2([0,equal$0,hash$0],_fk_),
       clear=include[2],
       reset=include[3],
       copy=include[4],
       add=include[5],
       remove=include[6],
       find=include[7],
       find_opt=include[8],
       find_all=include[9],
       replace=include[10],
       mem=include[11],
       iter=include[12],
       filter_map_inplace=include[13],
       fold=include[14],
       length=include[15],
       stats=include[16],
       to_seq=include[17],
       to_seq_keys=include[18],
       to_seq_values=include[19],
       add_seq=include[20],
       replace_seq=include[21],
       clean=include[23],
       stats_alive=include[24],
       _fl_=include[1];
      function create(sz){return caml_call2(_fl_,_cJ_,sz)}
      function of_seq(i)
       {var tbl=create(16);caml_call2(replace_seq,tbl,i);return tbl}
      return [0,
              create,
              clear,
              reset,
              copy,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter,
              filter_map_inplace,
              fold,
              length,
              stats,
              to_seq,
              to_seq_keys,
              to_seq_values,
              add_seq,
              replace_seq,
              of_seq,
              clean,
              stats_alive]}
    function create$7(n){return caml_call1(_t_[1],n)}
    function length$6(k){return caml_call1(_t_[2],k)}
    function get_key$1(t,n){return caml_call2(_t_[3],t,n)}
    function get_key_copy$1(t,n){return caml_call2(_t_[4],t,n)}
    function set_key$1(t,n,k){return caml_call3(_t_[5],t,n,k)}
    function unset_key$1(t,n){return caml_call2(_t_[6],t,n)}
    function check_key$1(t,n){return caml_call2(_t_[7],t,n)}
    function blit_key$1(t1,o1,t2,o2,l)
     {return caml_call5(_t_[8],t1,o1,t2,o2,l)}
    function get_data$3(t){return caml_call1(_t_[9],t)}
    function get_data_copy$1(t){return caml_call1(_t_[10],t)}
    function set_data$1(t,d){return caml_call2(_t_[11],t,d)}
    function unset_data$1(t){return caml_call1(_t_[12],t)}
    function check_data$1(t){return caml_call1(_t_[13],t)}
    function blit_data$1(t1,t2){return caml_call2(_t_[14],t1,t2)}
    function MakeSeeded$3(H)
     {function create(k,d)
       {var c=create$7(k.length - 1);
        set_data$1(c,d);
        var _fi_=k.length - 1 - 1 | 0,_fh_=0;
        if(! (_fi_ < 0))
         {var i=_fh_;
          for(;;)
           {set_key$1(c,i,caml_check_bound(k,i)[1 + i]);
            var _fj_=i + 1 | 0;
            if(_fi_ !== i){var i=_fj_;continue}
            break}}
        return c}
      function hash(seed,k)
       {var h=[0,0],_fd_=k.length - 1 - 1 | 0,_fc_=0;
        if(! (_fd_ < 0))
         {var i=_fc_;
          for(;;)
           {var _fe_=h[1],_ff_=caml_check_bound(k,i)[1 + i];
            h[1] = (caml_call2(H[2],seed,_ff_) * 65599 | 0) + _fe_ | 0;
            var _fg_=i + 1 | 0;
            if(_fd_ !== i){var i=_fg_;continue}
            break}}
        return h[1]}
      function equal(c,k)
       {var len=k.length - 1,len$0=length$6(c);
        if(len !== len$0)return 1;
        var i$1=len - 1 | 0,i=i$1;
        for(;;)
         {if(0 <= i)
           {var match=get_key$1(c,i);
            if(match)
             {var ki=match[1],_fb_=caml_check_bound(k,i)[1 + i];
              if(caml_call2(H[1],_fb_,ki)){var i$0=i - 1 | 0,i=i$0;continue}
              return 1}
            return 2}
          return 0}}
      function get_key(c)
       {var len=length$6(c);
        if(0 === len)return [0,[0]];
        var match=get_key$1(c,0);
        if(match)
         {var k0=match[1],a=caml_make_vect(len,k0),i$1=len - 1 | 0,i=i$1;
          for(;;)
           {if(1 <= i)
             {var match$0=get_key$1(c,i);
              if(match$0)
               {var ki=match$0[1];
                caml_check_bound(a,i)[1 + i] = ki;
                var i$0=i - 1 | 0,i=i$0;
                continue}
              return 0}
            return [0,a]}}
        return 0}
      function set_key_data(c,k,d)
       {unset_data$1(c);
        var _e$_=k.length - 1 - 1 | 0,_e__=0;
        if(! (_e$_ < 0))
         {var i=_e__;
          for(;;)
           {set_key$1(c,i,caml_check_bound(k,i)[1 + i]);
            var _fa_=i + 1 | 0;
            if(_e$_ !== i){var i=_fa_;continue}
            break}}
        return set_data$1(c,d)}
      function check_key(c)
       {var i$1=length$6(c) - 1 | 0,i=i$1;
        for(;;)
         {var _e7_=i < 0?1:0;
          if(_e7_)
           var _e8_=_e7_;
          else
           {var _e9_=check_key$1(c,i);
            if(_e9_){var i$0=i - 1 | 0,i=i$0;continue}
            var _e8_=_e9_}
          return _e8_}}
      return MakeSeeded$0
              ([0,create,hash,equal,get_data$3,get_key,set_key_data,check_key])}
    function Make$4(H)
     {var equal=H[1];
      function hash(seed,x){return caml_call1(H[2],x)}
      var
       include=MakeSeeded$3([0,equal,hash]),
       clear=include[2],
       reset=include[3],
       copy=include[4],
       add=include[5],
       remove=include[6],
       find=include[7],
       find_opt=include[8],
       find_all=include[9],
       replace=include[10],
       mem=include[11],
       iter=include[12],
       filter_map_inplace=include[13],
       fold=include[14],
       length=include[15],
       stats=include[16],
       to_seq=include[17],
       to_seq_keys=include[18],
       to_seq_values=include[19],
       add_seq=include[20],
       replace_seq=include[21],
       clean=include[23],
       stats_alive=include[24],
       _e6_=include[1];
      function create(sz){return caml_call2(_e6_,_cK_,sz)}
      function of_seq(i)
       {var tbl=create(16);caml_call2(replace_seq,tbl,i);return tbl}
      return [0,
              create,
              clear,
              reset,
              copy,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter,
              filter_map_inplace,
              fold,
              length,
              stats,
              to_seq,
              to_seq_keys,
              to_seq_values,
              add_seq,
              replace_seq,
              of_seq,
              clean,
              stats_alive]}
    var
     Stdlib_ephemeron=
      [0,
       [0,
        create$5,
        get_key$0,
        get_key_copy$0,
        set_key$0,
        unset_key$0,
        check_key$0,
        blit_key$0,
        get_data$1,
        get_data_copy,
        set_data,
        unset_data,
        check_data,
        blit_data,
        Make$2,
        MakeSeeded$1],
       [0,
        create$6,
        get_key1,
        get_key1_copy,
        set_key1,
        unset_key1,
        check_key1,
        get_key2,
        get_key2_copy,
        set_key2,
        unset_key2,
        check_key2,
        blit_key1,
        blit_key2,
        blit_key12,
        get_data$2,
        get_data_copy$0,
        set_data$0,
        unset_data$0,
        check_data$0,
        blit_data$0,
        Make$3,
        MakeSeeded$2],
       [0,
        create$7,
        get_key$1,
        get_key_copy$1,
        set_key$1,
        unset_key$1,
        check_key$1,
        blit_key$1,
        get_data$3,
        get_data_copy$1,
        set_data$1,
        unset_data$1,
        check_data$1,
        blit_data$1,
        Make$4,
        MakeSeeded$3],
       [0,
        function(_e5_)
         {return MakeSeeded$0
                  ([0,_e5_[3],_e5_[1],_e5_[2],_e5_[5],_e5_[4],_e5_[6],_e5_[7]])}]];
    caml_register_global(808,Stdlib_ephemeron,"Stdlib__ephemeron");
    function generic_basename(is_dir_sep,current_dir_name,name)
     {if(caml_string_equal(name,cst$100))return current_dir_name;
      var n$3=caml_ml_string_length(name) - 1 | 0,n=n$3;
      for(;;)
       {if(0 <= n)
         {if(caml_call2(is_dir_sep,name,n)){var n$0=n - 1 | 0,n=n$0;continue}
          var p=n + 1 | 0,n$1=n;
          for(;;)
           {if(0 <= n$1)
             {if(caml_call2(is_dir_sep,name,n$1))
               return sub$0(name,n$1 + 1 | 0,(p - n$1 | 0) - 1 | 0);
              var n$2=n$1 - 1 | 0,n$1=n$2;
              continue}
            return sub$0(name,0,p)}}
        return sub$0(name,0,1)}}
    function generic_dirname(is_dir_sep,current_dir_name,name)
     {if(caml_string_equal(name,cst$101))return current_dir_name;
      var n$5=caml_ml_string_length(name) - 1 | 0,n=n$5;
      for(;;)
       {if(0 <= n)
         {if(caml_call2(is_dir_sep,name,n)){var n$0=n - 1 | 0,n=n$0;continue}
          var n$1=n;
          for(;;)
           {if(0 <= n$1)
             {if(caml_call2(is_dir_sep,name,n$1))
               {var n$3=n$1;
                for(;;)
                 {if(0 <= n$3)
                   {if(caml_call2(is_dir_sep,name,n$3))
                     {var n$4=n$3 - 1 | 0,n$3=n$4;continue}
                    return sub$0(name,0,n$3 + 1 | 0)}
                  return sub$0(name,0,1)}}
              var n$2=n$1 - 1 | 0,n$1=n$2;
              continue}
            return current_dir_name}}
        return sub$0(name,0,1)}}
    function is_dir_sep(s,i){return 47 === caml_string_get(s,i)?1:0}
    function is_relative(n)
     {var
       _e3_=caml_ml_string_length(n) < 1?1:0,
       _e4_=_e3_ || (47 !== caml_string_get(n,0)?1:0);
      return _e4_}
    function is_implicit(n)
     {var _eY_=is_relative(n);
      if(_eY_)
       {var
         _eZ_=caml_ml_string_length(n) < 2?1:0,
         _e0_=_eZ_ || caml_string_notequal(sub$0(n,0,2),cst$103);
        if(_e0_)
         var
          _e1_=caml_ml_string_length(n) < 3?1:0,
          _e2_=_e1_ || caml_string_notequal(sub$0(n,0,3),cst$102);
        else
         var _e2_=_e0_}
      else
       var _e2_=_eY_;
      return _e2_}
    function check_suffix(name,suff)
     {var
       _eW_=caml_ml_string_length(suff) <= caml_ml_string_length(name)?1:0,
       _eX_=
        _eW_
         ?caml_string_equal
           (sub$0
             (name,
              caml_ml_string_length(name) - caml_ml_string_length(suff) | 0,
              caml_ml_string_length(suff)),
            suff)
         :_eW_;
      return _eX_}
    function chop_suffix_opt(suffix,filename)
     {var
       len_s=caml_ml_string_length(suffix),
       len_f=caml_ml_string_length(filename);
      if(len_s <= len_f)
       {var r=sub$0(filename,len_f - len_s | 0,len_s);
        return caml_string_equal(r,suffix)
                ?[0,sub$0(filename,0,len_f - len_s | 0)]
                :0}
      return 0}
    try
     {var _cS_=caml_sys_getenv(cst_TMPDIR),_cL_=_cS_}
    catch(_eV_)
     {_eV_ = caml_wrap_exception(_eV_);
      if(_eV_ !== Not_found)throw _eV_;
      var _cL_=cst_tmp}
    function quote(s)
     {var l=caml_ml_string_length(s),b=create$2(l + 20 | 0);
      add_char(b,39);
      var _eT_=l - 1 | 0,_eS_=0;
      if(! (_eT_ < 0))
       {var i=_eS_;
        for(;;)
         {if(39 === caml_string_get(s,i))
           add_string(b,quotequote);
          else
           add_char(b,caml_string_get(s,i));
          var _eU_=i + 1 | 0;
          if(_eT_ !== i){var i=_eU_;continue}
          break}}
      add_char(b,39);
      return contents(b)}
    function quote_command(cmd,stdin,stdout,stderr,args)
     {if(stderr)
       var
        f=stderr[1],
        _eM_=caml_equal(stderr,stdout)?cst_2_1:symbol(cst_2,quote(f)),
        _eN_=_eM_;
      else
       var _eN_=cst$109;
      if(stdout)
       var f$0=stdout[1],_eO_=symbol(cst$104,quote(f$0));
      else
       var _eO_=cst$108;
      var _eP_=symbol(_eO_,_eN_);
      if(stdin)
       var f$1=stdin[1],_eQ_=symbol(cst$105,quote(f$1));
      else
       var _eQ_=cst$107;
      var _eR_=symbol(_eQ_,_eP_);
      return symbol(concat$0(cst$106,map$3(quote,[0,cmd,args])),_eR_)}
    function basename(_eL_)
     {return generic_basename(is_dir_sep,current_dir_name,_eL_)}
    function dirname(_eK_)
     {return generic_dirname(is_dir_sep,current_dir_name,_eK_)}
    var
     Unix=
      [0,
       null$0,
       current_dir_name,
       parent_dir_name,
       dir_sep,
       is_dir_sep,
       is_relative,
       is_implicit,
       check_suffix,
       chop_suffix_opt,
       _cL_,
       quote,
       quote_command,
       basename,
       dirname];
    function is_dir_sep$0(s,i)
     {var c=caml_string_get(s,i),_eH_=47 === c?1:0;
      if(_eH_)
       var _eI_=_eH_;
      else
       var _eJ_=92 === c?1:0,_eI_=_eJ_ || (58 === c?1:0);
      return _eI_}
    function is_relative$0(n)
     {var
       _eB_=caml_ml_string_length(n) < 1?1:0,
       _eC_=_eB_ || (47 !== caml_string_get(n,0)?1:0);
      if(_eC_)
       {var
         _eD_=caml_ml_string_length(n) < 1?1:0,
         _eE_=_eD_ || (92 !== caml_string_get(n,0)?1:0);
        if(_eE_)
         var
          _eF_=caml_ml_string_length(n) < 2?1:0,
          _eG_=_eF_ || (58 !== caml_string_get(n,1)?1:0);
        else
         var _eG_=_eE_}
      else
       var _eG_=_eC_;
      return _eG_}
    function is_implicit$0(n)
     {var _es_=is_relative$0(n);
      if(_es_)
       {var
         _et_=caml_ml_string_length(n) < 2?1:0,
         _eu_=_et_ || caml_string_notequal(sub$0(n,0,2),cst$113);
        if(_eu_)
         {var
           _ev_=caml_ml_string_length(n) < 2?1:0,
           _ew_=_ev_ || caml_string_notequal(sub$0(n,0,2),cst$112);
          if(_ew_)
           {var
             _ex_=caml_ml_string_length(n) < 3?1:0,
             _ey_=_ex_ || caml_string_notequal(sub$0(n,0,3),cst$111);
            if(_ey_)
             var
              _ez_=caml_ml_string_length(n) < 3?1:0,
              _eA_=_ez_ || caml_string_notequal(sub$0(n,0,3),cst$110);
            else
             var _eA_=_ey_}
          else
           var _eA_=_ew_}
        else
         var _eA_=_eu_}
      else
       var _eA_=_es_;
      return _eA_}
    function check_suffix$0(name,suff)
     {var _ep_=caml_ml_string_length(suff) <= caml_ml_string_length(name)?1:0;
      if(_ep_)
       var
        s=
         sub$0
          (name,
           caml_ml_string_length(name) - caml_ml_string_length(suff) | 0,
           caml_ml_string_length(suff)),
        _eq_=lowercase_ascii$1(suff),
        _er_=caml_string_equal(lowercase_ascii$1(s),_eq_);
      else
       var _er_=_ep_;
      return _er_}
    function chop_suffix_opt$0(suffix,filename)
     {var
       len_s=caml_ml_string_length(suffix),
       len_f=caml_ml_string_length(filename);
      if(len_s <= len_f)
       {var
         r=sub$0(filename,len_f - len_s | 0,len_s),
         _eo_=lowercase_ascii$1(suffix);
        return caml_string_equal(lowercase_ascii$1(r),_eo_)
                ?[0,sub$0(filename,0,len_f - len_s | 0)]
                :0}
      return 0}
    try
     {var _cR_=caml_sys_getenv(cst_TEMP),temp_dir_name=_cR_}
    catch(_en_)
     {_en_ = caml_wrap_exception(_en_);
      if(_en_ !== Not_found)throw _en_;
      var temp_dir_name=cst$114}
    function quote$0(s)
     {var l=caml_ml_string_length(s),b=create$2(l + 20 | 0);
      add_char(b,34);
      function add_bs(n)
       {var _el_=1;
        if(! (n < 1))
         {var j=_el_;
          for(;;)
           {add_char(b,92);
            var _em_=j + 1 | 0;
            if(n !== j){var j=_em_;continue}
            break}}
        return 0}
      function loop$0(counter,i)
       {var i$0=i;
        for(;;)
         {if(i$0 === l)return add_char(b,34);
          var c=caml_string_get(s,i$0);
          if(34 === c)
           {var _ej_=0;
            if(counter < 50)
             {var counter$1=counter + 1 | 0;
              return loop_bs(counter$1,_ej_,i$0)}
            return caml_trampoline_return(loop_bs,[0,_ej_,i$0])}
          if(92 === c)
           {var _ek_=0;
            if(counter < 50)
             {var counter$0=counter + 1 | 0;
              return loop_bs(counter$0,_ek_,i$0)}
            return caml_trampoline_return(loop_bs,[0,_ek_,i$0])}
          add_char(b,c);
          var i$1=i$0 + 1 | 0,i$0=i$1;
          continue}}
      function loop_bs(counter,n,i)
       {var n$0=n,i$0=i;
        for(;;)
         {if(i$0 === l){add_char(b,34);return add_bs(n$0)}
          var match=caml_string_get(s,i$0);
          if(34 === match)
           {add_bs((2 * n$0 | 0) + 1 | 0);
            add_char(b,34);
            var _ei_=i$0 + 1 | 0;
            if(counter < 50)
             {var counter$1=counter + 1 | 0;return loop$0(counter$1,_ei_)}
            return caml_trampoline_return(loop$0,[0,_ei_])}
          if(92 === match)
           {var i$1=i$0 + 1 | 0,n$1=n$0 + 1 | 0,n$0=n$1,i$0=i$1;continue}
          add_bs(n$0);
          if(counter < 50)
           {var counter$0=counter + 1 | 0;return loop$0(counter$0,i$0)}
          return caml_trampoline_return(loop$0,[0,i$0])}}
      function loop(i){return caml_trampoline(loop$0(0,i))}
      loop(0);
      return contents(b)}
    function quote_cmd_filename(f)
     {if(! contains$0(f,34) && ! contains$0(f,37))
       return contains$0(f,32)?symbol(cst$116,symbol(f,cst$115)):f;
      return failwith(symbol(cst_Filename_quote_command_bad,f))}
    function quote_command$0(cmd,stdin,stdout,stderr,args)
     {if(stderr)
       var
        f=stderr[1],
        _d$_=
         caml_equal(stderr,stdout)
          ?cst_2_1$0
          :symbol(cst_2$0,quote_cmd_filename(f)),
        _ea_=_d$_;
      else
       var _ea_=cst$125;
      var _eb_=[0,_ea_,_cM_];
      if(stdout)
       var f$0=stdout[1],_ec_=symbol(cst$117,quote_cmd_filename(f$0));
      else
       var _ec_=cst$124;
      var _ed_=[0,_ec_,_eb_];
      if(stdin)
       var f$1=stdin[1],_ee_=symbol(cst$118,quote_cmd_filename(f$1));
      else
       var _ee_=cst$123;
      var
       s=concat$0(cst$119,map$3(quote$0,args)),
       b=create$2(caml_ml_string_length(s) + 20 | 0),
       _ef_=[0,_ee_,_ed_];
      iter$4
       (function(c)
         {var switch$0=0;
          if(62 <= c)
           {var _eh_=c - 63 | 0;
            if(60 < _eh_ >>> 0)
             {if(! (62 <= _eh_))switch$0 = 1}
            else
             if(31 === _eh_)switch$0 = 1}
          else
           if(42 <= c)
            {if(60 === c)switch$0 = 1}
           else
            if(33 <= c)
             switch(c - 33 | 0)
              {case 2:case 3:case 6:break;default:switch$0 = 1}
          return switch$0?(add_char(b,94),add_char(b,c)):add_char(b,c)},
        s);
      var _eg_=[0,cst$120,[0,contents(b),_ef_]];
      return concat$0(cst$122,[0,cst$121,[0,quote_cmd_filename(cmd),_eg_]])}
    function drive_and_path(s)
     {var _d7_=2 <= caml_ml_string_length(s)?1:0;
      if(_d7_)
       {var param=caml_string_get(s,0),switch$0=0;
        if(91 <= param)
         {if(! (25 < (param - 97 | 0) >>> 0))switch$0 = 1}
        else
         if(65 <= param)switch$0 = 1;
        var _d8_=switch$0?1:0,_d9_=_d8_?58 === caml_string_get(s,1)?1:0:_d8_}
      else
       var _d9_=_d7_;
      if(_d9_)
       {var _d__=sub$0(s,2,caml_ml_string_length(s) - 2 | 0);
        return [0,sub$0(s,0,2),_d__]}
      return [0,cst$126,s]}
    function dirname$0(s)
     {var
       match=drive_and_path(s),
       path=match[2],
       drive=match[1],
       dir=generic_dirname(is_dir_sep$0,current_dir_name$0,path);
      return symbol(drive,dir)}
    function basename$0(s)
     {var match=drive_and_path(s),path=match[2];
      return generic_basename(is_dir_sep$0,current_dir_name$0,path)}
    var
     Win32=
      [0,
       null$1,
       current_dir_name$0,
       parent_dir_name$0,
       dir_sep$0,
       is_dir_sep$0,
       is_relative$0,
       is_implicit$0,
       check_suffix$0,
       chop_suffix_opt$0,
       temp_dir_name,
       quote$0,
       quote_command$0,
       basename$0,
       dirname$0];
    function basename$1(_d6_)
     {return generic_basename(is_dir_sep$0,current_dir_name$1,_d6_)}
    function dirname$1(_d5_)
     {return generic_dirname(is_dir_sep$0,current_dir_name$1,_d5_)}
    var
     Cygwin=
      [0,
       null$2,
       current_dir_name$1,
       parent_dir_name$1,
       dir_sep$1,
       is_dir_sep$0,
       is_relative$0,
       is_implicit$0,
       check_suffix$0,
       chop_suffix_opt$0,
       _cL_,
       quote,
       quote_command,
       basename$1,
       dirname$1],
     Sysdeps=
      caml_string_notequal(os_type,cst_Cygwin)
       ?caml_string_notequal(os_type,cst_Win32)?Unix:Win32
       :Cygwin,
     null$3=Sysdeps[1],
     current_dir_name$2=Sysdeps[2],
     parent_dir_name$2=Sysdeps[3],
     dir_sep$2=Sysdeps[4],
     is_dir_sep$1=Sysdeps[5],
     is_relative$1=Sysdeps[6],
     is_implicit$1=Sysdeps[7],
     check_suffix$1=Sysdeps[8],
     chop_suffix_opt$1=Sysdeps[9],
     temp_dir_name$0=Sysdeps[10],
     quote$1=Sysdeps[11],
     quote_command$1=Sysdeps[12],
     basename$2=Sysdeps[13],
     dirname$2=Sysdeps[14];
    function concat$3(dirname,filename)
     {var l=caml_ml_string_length(dirname);
      if(0 !== l && ! is_dir_sep$1(dirname,l - 1 | 0))
       return symbol(dirname,symbol(dir_sep$2,filename));
      return symbol(dirname,filename)}
    function chop_suffix(name,suff)
     {var n=caml_ml_string_length(name) - caml_ml_string_length(suff) | 0;
      return 0 <= n?sub$0(name,0,n):invalid_arg(cst_Filename_chop_suffix)}
    function extension_len(name)
     {var i$4=caml_ml_string_length(name) - 1 | 0,i$1=i$4;
      for(;;)
       {if(0 <= i$1 && ! is_dir_sep$1(name,i$1))
         {if(46 === caml_string_get(name,i$1))
           {var i$2=i$1 - 1 | 0,i=i$2;
            for(;;)
             {if(0 <= i && ! is_dir_sep$1(name,i))
               {if(46 === caml_string_get(name,i))
                 {var i$0=i - 1 | 0,i=i$0;continue}
                return caml_ml_string_length(name) - i$1 | 0}
              return 0}}
          var i$3=i$1 - 1 | 0,i$1=i$3;
          continue}
        return 0}}
    function extension(name)
     {var l=extension_len(name);
      return 0 === l?cst$127:sub$0(name,caml_ml_string_length(name) - l | 0,l)}
    function chop_extension(name)
     {var l=extension_len(name);
      return 0 === l
              ?invalid_arg(cst_Filename_chop_extension)
              :sub$0(name,0,caml_ml_string_length(name) - l | 0)}
    function remove_extension(name)
     {var l=extension_len(name);
      return 0 === l?name:sub$0(name,0,caml_ml_string_length(name) - l | 0)}
    var prng$0=[246,function(_d4_){return caml_call1(_b$_[2],0)}];
    function temp_file_name(temp_dir,prefix,suffix)
     {var
       _d2_=caml_obj_tag(prng$0),
       _d3_=
        250 === _d2_?prng$0[1]:246 === _d2_?force_lazy_block(prng$0):prng$0,
       rnd=caml_call1(_b$_[4],_d3_) & 16777215;
      return concat$3(temp_dir,caml_call3(sprintf(_cN_),prefix,rnd,suffix))}
    var current_temp_dir_name=[0,temp_dir_name$0];
    function set_temp_dir_name(s){current_temp_dir_name[1] = s;return 0}
    function get_temp_dir_name(param){return current_temp_dir_name[1]}
    function temp_file(opt,prefix,suffix)
     {if(opt)
       var sth=opt[1],temp_dir=sth;
      else
       var temp_dir=current_temp_dir_name[1];
      function try_name(counter)
       {var counter$0=counter;
        for(;;)
         {var name=temp_file_name(temp_dir,prefix,suffix);
          try
           {runtime.caml_sys_close(caml_sys_open(name,_cO_,384));return name}
          catch(e)
           {e = caml_wrap_exception(e);
            if(e[1] === Sys_error)
             {if(1000 <= counter$0)throw e;
              var counter$1=counter$0 + 1 | 0,counter$0=counter$1;
              continue}
            throw e}}}
      return try_name(0)}
    function open_temp_file(opt,_d0_,_dZ_,prefix,suffix)
     {if(opt)var sth=opt[1],mode=sth;else var mode=_cP_;
      if(_d0_)var sth$0=_d0_[1],perms=sth$0;else var perms=384;
      if(_dZ_)
       var sth$1=_dZ_[1],temp_dir=sth$1;
      else
       var temp_dir=current_temp_dir_name[1];
      function try_name(counter)
       {var counter$0=counter;
        for(;;)
         {var name=temp_file_name(temp_dir,prefix,suffix);
          try
           {var _d1_=[0,name,open_out_gen([0,1,[0,3,[0,5,mode]]],perms,name)];
            return _d1_}
          catch(e)
           {e = caml_wrap_exception(e);
            if(e[1] === Sys_error)
             {if(1000 <= counter$0)throw e;
              var counter$1=counter$0 + 1 | 0,counter$0=counter$1;
              continue}
            throw e}}}
      return try_name(0)}
    var
     Stdlib_filename=
      [0,
       current_dir_name$2,
       parent_dir_name$2,
       dir_sep$2,
       concat$3,
       is_relative$1,
       is_implicit$1,
       check_suffix$1,
       chop_suffix,
       chop_suffix_opt$1,
       extension,
       remove_extension,
       chop_extension,
       basename$2,
       dirname$2,
       null$3,
       temp_file,
       open_temp_file,
       get_temp_dir_name,
       set_temp_dir_name,
       temp_dir_name$0,
       quote$1,
       quote_command$1];
    caml_register_global(809,Stdlib_filename,"Stdlib__filename");
    function add$1(x,y){return [254,x[1] + y[1],x[2] + y[2]]}
    function sub$4(x,y){return [254,x[1] - y[1],x[2] - y[2]]}
    function neg(x){return [254,- x[1],- x[2]]}
    function conj(x){return [254,x[1],- x[2]]}
    function mul(x,y)
     {return [254,x[1] * y[1] - x[2] * y[2],x[1] * y[2] + x[2] * y[1]]}
    function div(x,y)
     {if(Math.abs(y[2]) <= Math.abs(y[1]))
       {var r=y[2] / y[1],d=y[1] + r * y[2];
        return [254,(x[1] + r * x[2]) / d,(x[2] - r * x[1]) / d]}
      var r$0=y[1] / y[2],d$0=y[2] + r$0 * y[1];
      return [254,(r$0 * x[1] + x[2]) / d$0,(r$0 * x[2] - x[1]) / d$0]}
    function inv(x){return div(one$4,x)}
    function norm2(x){return x[1] * x[1] + x[2] * x[2]}
    function norm(x)
     {var r=Math.abs(x[1]),i=Math.abs(x[2]);
      if(r == 0.)return i;
      if(i == 0.)return r;
      if(i <= r){var q=i / r;return r * Math.sqrt(1. + q * q)}
      var q$0=r / i;
      return i * Math.sqrt(1. + q$0 * q$0)}
    function arg(x){return Math.atan2(x[2],x[1])}
    function polar(n,a){return [254,Math.cos(a) * n,Math.sin(a) * n]}
    function sqrt(x)
     {if(x[1] == 0. && x[2] == 0.)return _cQ_;
      var r=Math.abs(x[1]),i=Math.abs(x[2]);
      if(i <= r)
       var
        q=i / r,
        w=Math.sqrt(r) * Math.sqrt(0.5 * (1. + Math.sqrt(1. + q * q)));
      else
       var
        q$0=r / i,
        w=Math.sqrt(i) * Math.sqrt(0.5 * (q$0 + Math.sqrt(1. + q$0 * q$0)));
      if(0. <= x[1])return [254,w,0.5 * x[2] / w];
      var w$0=0. <= x[2]?w:- w;
      return [254,0.5 * i / w,w$0]}
    function exp(x)
     {var e=Math.exp(x[1]);return [254,e * Math.cos(x[2]),e * Math.sin(x[2])]}
    function log(x)
     {var _dY_=Math.atan2(x[2],x[1]);return [254,Math.log(norm(x)),_dY_]}
    function pow(x,y){return exp(mul(y,log(x)))}
    var
     Stdlib_complex=
      [0,
       zero$4,
       one$4,
       i,
       neg,
       conj,
       add$1,
       sub$4,
       mul,
       inv,
       div,
       sqrt,
       norm2,
       norm,
       arg,
       polar,
       exp,
       log,
       pow];
    caml_register_global(810,Stdlib_complex,"Stdlib__complex");
    var
     Stdlib_arrayLabels=
      [0,
       make_float,
       init$2,
       create_matrix,
       create_matrix,
       append$1,
       concat$1,
       sub$1,
       copy$1,
       fill$0,
       blit$1,
       to_list$1,
       of_list,
       iter$5,
       iteri$2,
       map$6,
       mapi$2,
       fold_left$1,
       fold_right$0,
       iter2$0,
       map2$0,
       for_all$0,
       exists$0,
       for_all2$0,
       exists2$0,
       mem$0,
       memq$0,
       sort,
       fast_sort$0,
       fast_sort$0,
       to_seq$4,
       to_seqi$1,
       of_seq$2,
       Floatarray];
    caml_register_global(811,Stdlib_arrayLabels,"Stdlib__arrayLabels");
    var
     Stdlib_listLabels=
      [0,
       length,
       compare_lengths,
       compare_length_with,
       cons$0,
       hd,
       tl,
       nth,
       nth_opt,
       rev,
       init,
       append,
       rev_append,
       flatten,
       flatten,
       equal$5,
       compare$5,
       iter$2,
       iteri,
       map$3,
       mapi,
       rev_map,
       filter_map$0,
       concat_map,
       fold_left_map,
       fold_left$0,
       fold_right,
       iter2,
       map2,
       rev_map2,
       fold_left2,
       fold_right2,
       for_all,
       exists,
       for_all2,
       exists2,
       mem,
       memq,
       find,
       find_opt,
       find_map,
       find_all,
       find_all,
       filteri,
       partition,
       partition_map,
       assoc,
       assoc_opt,
       assq,
       assq_opt,
       mem_assoc,
       mem_assq,
       remove_assoc,
       remove_assq,
       split,
       combine,
       fast_sort,
       fast_sort,
       fast_sort,
       sort_uniq,
       merge,
       to_seq$1,
       of_seq];
    caml_register_global(812,Stdlib_listLabels,"Stdlib__listLabels");
    var
     Stdlib_bytesLabels=
      [0,
       make$0,
       init$0,
       empty$0,
       copy,
       of_string,
       to_string$1,
       sub,
       sub_string,
       extend,
       fill,
       blit,
       blit$0,
       concat,
       cat,
       iter$3,
       iteri$0,
       map$4,
       mapi$0,
       trim,
       escaped$0,
       index,
       index_opt,
       rindex,
       rindex_opt,
       index_from,
       index_from_opt,
       rindex_from,
       rindex_from_opt,
       contains,
       contains_from,
       rcontains_from,
       uppercase$0,
       lowercase$0,
       capitalize,
       uncapitalize,
       uppercase_ascii$0,
       lowercase_ascii$0,
       capitalize_ascii,
       uncapitalize_ascii,
       compare$6,
       equal$6,
       unsafe_to_string,
       unsafe_of_string,
       to_seq$2,
       to_seqi,
       of_seq$0,
       get_uint8,
       get_int8,
       get_uint16_ne,
       get_uint16_be,
       get_uint16_le,
       get_int16_ne,
       get_int16_be,
       get_int16_le,
       get_int32_ne,
       get_int32_be,
       get_int32_le,
       get_int64_ne,
       get_int64_be,
       get_int64_le,
       set_uint8,
       set_int8,
       set_uint16_ne,
       set_int16_be,
       set_int16_le,
       set_int16_ne,
       set_int16_be,
       set_int16_le,
       set_int32_ne,
       set_int32_be,
       set_int32_le,
       set_int64_ne,
       set_int64_be,
       set_int64_le];
    caml_register_global(813,Stdlib_bytesLabels,"Stdlib__bytesLabels");
    var
     Stdlib_stringLabels=
      [0,
       make$1,
       init$1,
       concat$0,
       equal$7,
       compare$7,
       contains_from$0,
       rcontains_from$0,
       contains$0,
       sub$0,
       split_on_char,
       map$5,
       mapi$1,
       trim$0,
       escaped$1,
       uppercase_ascii$1,
       lowercase_ascii$1,
       capitalize_ascii$0,
       uncapitalize_ascii$0,
       iter$4,
       iteri$1,
       index_from$0,
       index_from_opt$0,
       rindex_from$0,
       rindex_from_opt$0,
       index$0,
       index_opt$0,
       rindex$0,
       rindex_opt$0,
       to_seq$3,
       to_seqi$0,
       of_seq$1,
       blit$0,
       copy$0,
       fill,
       uppercase$1,
       lowercase$1,
       capitalize$0,
       uncapitalize$0];
    caml_register_global(814,Stdlib_stringLabels,"Stdlib__stringLabels");
    var Stdlib_moreLabels=[0,Stdlib_hashtbl,Stdlib_map,Stdlib_set];
    caml_register_global(815,Stdlib_moreLabels,"Stdlib__moreLabels");
    var Stdlib_stdLabels=[0];
    caml_register_global(816,Stdlib_stdLabels,"Stdlib__stdLabels");
    var
     float32=0,
     float64=1,
     int8_signed=2,
     int8_unsigned=3,
     int16_signed=4,
     int16_unsigned=5,
     int32$1=6,
     int64$1=7,
     int$2=8,
     nativeint$1=9,
     complex32=10,
     complex64=11,
     char$0=12;
    function kind_size_in_bytes(param)
     {switch(param)
       {case 0:return 4;
        case 1:return 8;
        case 2:return 1;
        case 3:return 1;
        case 4:return 2;
        case 5:return 2;
        case 6:return 4;
        case 7:return 8;
        case 8:return 4;
        case 9:return 4;
        case 10:return 8;
        case 11:return 16;
        default:return 1}}
    var c_layout=0,fortran_layout=1;
    function cloop(arr,idx,f,col,max)
     {if(col === idx.length - 1)
       return caml_ba_set_generic(arr,idx,caml_call1(f,idx));
      var _dW_=caml_check_bound(max,col)[1 + col] - 1 | 0,_dV_=0;
      if(! (_dW_ < 0))
       {var j=_dV_;
        for(;;)
         {caml_check_bound(idx,col)[1 + col] = j;
          cloop(arr,idx,f,col + 1 | 0,max);
          var _dX_=j + 1 | 0;
          if(_dW_ !== j){var j=_dX_;continue}
          break}}
      return 0}
    function floop(arr,idx,f,col,max)
     {if(0 <= col)
       {var _dT_=caml_check_bound(max,col)[1 + col],_dS_=1;
        if(! (_dT_ < 1))
         {var j=_dS_;
          for(;;)
           {caml_check_bound(idx,col)[1 + col] = j;
            floop(arr,idx,f,col - 1 | 0,max);
            var _dU_=j + 1 | 0;
            if(_dT_ !== j){var j=_dU_;continue}
            break}}
        return 0}
      return caml_ba_set_generic(arr,idx,caml_call1(f,idx))}
    function init$5(kind,layout,dims,f)
     {var arr=caml_ba_create(kind,layout,dims),dlen=dims.length - 1;
      return 0 === dlen
              ?arr
              :layout
                ?(floop(arr,caml_make_vect(dlen,1),f,dlen - 1 | 0,dims),arr)
                :(cloop(arr,caml_make_vect(dlen,0),f,0,dims),arr)}
    function dims(a)
     {var n=caml_ba_num_dims(a),d=caml_make_vect(n,0),_dP_=n - 1 | 0,_dO_=0;
      if(! (_dP_ < 0))
       {var i=_dO_;
        for(;;)
         {var _dQ_=runtime.caml_ba_dim(a,i);
          caml_check_bound(d,i)[1 + i] = _dQ_;
          var _dR_=i + 1 | 0;
          if(_dP_ !== i){var i=_dR_;continue}
          break}}
      return d}
    function size_in_bytes(arr)
     {var _dN_=fold_left$1(caml_mul,1,dims(arr));
      return caml_mul(kind_size_in_bytes(caml_ba_kind(arr)),_dN_)}
    function create$8(kind,layout){return caml_ba_create(kind,layout,[0])}
    function get$2(arr){return runtime.caml_ba_get_generic(arr,[0])}
    function set$1(arr)
     {var _dL_=[0];
      return function(_dM_){return caml_ba_set_generic(arr,_dL_,_dM_)}}
    function size_in_bytes$0(arr)
     {return kind_size_in_bytes(caml_ba_kind(arr))}
    function of_value(kind,layout,v)
     {var a=create$8(kind,layout);caml_call1(set$1(a),v);return a}
    function create$9(kind,layout,dim)
     {return caml_ba_create(kind,layout,[0,dim])}
    function size_in_bytes$1(arr)
     {var _dK_=caml_ba_dim_1(arr);
      return caml_mul(kind_size_in_bytes(caml_ba_kind(arr)),_dK_)}
    function slice(a,n)
     {var match=runtime.caml_ba_layout(a);
      return match?caml_ba_slice(a,[0,n]):caml_ba_slice(a,[0,n])}
    function init$6(kind,layout,dim,f)
     {var arr=create$9(kind,layout,dim);
      if(layout)
       {var _dI_=1;
        if(! (dim < 1))
         {var i$0=_dI_;
          for(;;)
           {caml_ba_set_1(arr,i$0,caml_call1(f,i$0));
            var _dJ_=i$0 + 1 | 0;
            if(dim !== i$0){var i$0=_dJ_;continue}
            break}}
        return arr}
      var _dG_=dim - 1 | 0,_dF_=0;
      if(! (_dG_ < 0))
       {var i=_dF_;
        for(;;)
         {caml_ba_set_1(arr,i,caml_call1(f,i));
          var _dH_=i + 1 | 0;
          if(_dG_ !== i){var i=_dH_;continue}
          break}}
      return arr}
    function of_array(kind,layout,data)
     {var
       ba=create$9(kind,layout,data.length - 1),
       ofs=layout?1:0,
       _dD_=data.length - 1 - 1 | 0,
       _dC_=0;
      if(! (_dD_ < 0))
       {var i=_dC_;
        for(;;)
         {caml_ba_set_1(ba,i + ofs | 0,caml_check_bound(data,i)[1 + i]);
          var _dE_=i + 1 | 0;
          if(_dD_ !== i){var i=_dE_;continue}
          break}}
      return ba}
    function create$10(kind,layout,dim1,dim2)
     {return caml_ba_create(kind,layout,[0,dim1,dim2])}
    function size_in_bytes$2(arr)
     {var _dA_=caml_ba_dim_2(arr),_dB_=caml_ba_dim_1(arr);
      return caml_mul
              (caml_mul(kind_size_in_bytes(caml_ba_kind(arr)),_dB_),_dA_)}
    function slice_left(a,n){return caml_ba_slice(a,[0,n])}
    function slice_right(a,n){return caml_ba_slice(a,[0,n])}
    function init$7(kind,layout,dim1,dim2,f)
     {var arr=create$10(kind,layout,dim1,dim2);
      if(layout)
       {var _dw_=1;
        if(! (dim2 < 1))
         {var j$0=_dw_;
          for(;;)
           {var _dx_=1;
            if(! (dim1 < 1))
             {var i$0=_dx_;
              for(;;)
               {caml_ba_set_2(arr,i$0,j$0,caml_call2(f,i$0,j$0));
                var _dz_=i$0 + 1 | 0;
                if(dim1 !== i$0){var i$0=_dz_;continue}
                break}}
            var _dy_=j$0 + 1 | 0;
            if(dim2 !== j$0){var j$0=_dy_;continue}
            break}}
        return arr}
      var _dr_=dim1 - 1 | 0,_dq_=0;
      if(! (_dr_ < 0))
       {var i=_dq_;
        for(;;)
         {var _dt_=dim2 - 1 | 0,_ds_=0;
          if(! (_dt_ < 0))
           {var j=_ds_;
            for(;;)
             {caml_ba_set_2(arr,i,j,caml_call2(f,i,j));
              var _dv_=j + 1 | 0;
              if(_dt_ !== j){var j=_dv_;continue}
              break}}
          var _du_=i + 1 | 0;
          if(_dr_ !== i){var i=_du_;continue}
          break}}
      return arr}
    function of_array$0(kind,layout,data)
     {var
       dim1=data.length - 1,
       dim2=0 === dim1?0:caml_check_bound(data,0)[1].length - 1,
       ba=create$10(kind,layout,dim1,dim2),
       ofs=layout?1:0,
       _dl_=dim1 - 1 | 0,
       _dk_=0;
      if(! (_dl_ < 0))
       {var i=_dk_;
        for(;;)
         {var row=caml_check_bound(data,i)[1 + i];
          if(row.length - 1 !== dim2)
           invalid_arg(cst_Bigarray_Array2_of_array_n);
          var _dn_=dim2 - 1 | 0,_dm_=0;
          if(! (_dn_ < 0))
           {var j=_dm_;
            for(;;)
             {caml_ba_set_2
               (ba,i + ofs | 0,j + ofs | 0,caml_check_bound(row,j)[1 + j]);
              var _dp_=j + 1 | 0;
              if(_dn_ !== j){var j=_dp_;continue}
              break}}
          var _do_=i + 1 | 0;
          if(_dl_ !== i){var i=_do_;continue}
          break}}
      return ba}
    function create$11(kind,layout,dim1,dim2,dim3)
     {return caml_ba_create(kind,layout,[0,dim1,dim2,dim3])}
    function size_in_bytes$3(arr)
     {var
       _dh_=runtime.caml_ba_dim_3(arr),
       _di_=caml_ba_dim_2(arr),
       _dj_=caml_ba_dim_1(arr);
      return caml_mul
              (caml_mul
                (caml_mul(kind_size_in_bytes(caml_ba_kind(arr)),_dj_),_di_),
               _dh_)}
    function slice_left_1(a,n,m){return caml_ba_slice(a,[0,n,m])}
    function slice_right_1(a,n,m){return caml_ba_slice(a,[0,n,m])}
    function slice_left_2(a,n){return caml_ba_slice(a,[0,n])}
    function slice_right_2(a,n){return caml_ba_slice(a,[0,n])}
    function init$8(kind,layout,dim1,dim2,dim3,f)
     {var arr=create$11(kind,layout,dim1,dim2,dim3);
      if(layout)
       {var _db_=1;
        if(! (dim3 < 1))
         {var k$0=_db_;
          for(;;)
           {var _dc_=1;
            if(! (dim2 < 1))
             {var j$0=_dc_;
              for(;;)
               {var _de_=1;
                if(! (dim1 < 1))
                 {var i$0=_de_;
                  for(;;)
                   {caml_ba_set_3(arr,i$0,j$0,k$0,caml_call3(f,i$0,j$0,k$0));
                    var _dg_=i$0 + 1 | 0;
                    if(dim1 !== i$0){var i$0=_dg_;continue}
                    break}}
                var _df_=j$0 + 1 | 0;
                if(dim2 !== j$0){var j$0=_df_;continue}
                break}}
            var _dd_=k$0 + 1 | 0;
            if(dim3 !== k$0){var k$0=_dd_;continue}
            break}}
        return arr}
      var _c5_=dim1 - 1 | 0,_c4_=0;
      if(! (_c5_ < 0))
       {var i=_c4_;
        for(;;)
         {var _c7_=dim2 - 1 | 0,_c6_=0;
          if(! (_c7_ < 0))
           {var j=_c6_;
            for(;;)
             {var _c__=dim3 - 1 | 0,_c9_=0;
              if(! (_c__ < 0))
               {var k=_c9_;
                for(;;)
                 {caml_ba_set_3(arr,i,j,k,caml_call3(f,i,j,k));
                  var _da_=k + 1 | 0;
                  if(_c__ !== k){var k=_da_;continue}
                  break}}
              var _c$_=j + 1 | 0;
              if(_c7_ !== j){var j=_c$_;continue}
              break}}
          var _c8_=i + 1 | 0;
          if(_c5_ !== i){var i=_c8_;continue}
          break}}
      return arr}
    function of_array$1(kind,layout,data)
     {var
       dim1=data.length - 1,
       dim2=0 === dim1?0:caml_check_bound(data,0)[1].length - 1,
       dim3=
        0 === dim2
         ?0
         :caml_check_bound(caml_check_bound(data,0)[1],0)[1].length - 1,
       ba=create$11(kind,layout,dim1,dim2,dim3),
       ofs=layout?1:0,
       _cW_=dim1 - 1 | 0,
       _cV_=0;
      if(! (_cW_ < 0))
       {var i=_cV_;
        for(;;)
         {var row=caml_check_bound(data,i)[1 + i];
          if(row.length - 1 !== dim2)
           invalid_arg(cst_Bigarray_Array3_of_array_n);
          var _cY_=dim2 - 1 | 0,_cX_=0;
          if(! (_cY_ < 0))
           {var j=_cX_;
            for(;;)
             {var col=caml_check_bound(row,j)[1 + j];
              if(col.length - 1 !== dim3)
               invalid_arg(cst_Bigarray_Array3_of_array_n$0);
              var _c1_=dim3 - 1 | 0,_c0_=0;
              if(! (_c1_ < 0))
               {var k=_c0_;
                for(;;)
                 {caml_ba_set_3
                   (ba,
                    i + ofs | 0,
                    j + ofs | 0,
                    k + ofs | 0,
                    caml_check_bound(col,k)[1 + k]);
                  var _c3_=k + 1 | 0;
                  if(_c1_ !== k){var k=_c3_;continue}
                  break}}
              var _c2_=j + 1 | 0;
              if(_cY_ !== j){var j=_c2_;continue}
              break}}
          var _cZ_=i + 1 | 0;
          if(_cW_ !== i){var i=_cZ_;continue}
          break}}
      return ba}
    function array0_of_genarray(a)
     {return 0 === caml_ba_num_dims(a)
              ?a
              :invalid_arg(cst_Bigarray_array0_of_genarra)}
    function array1_of_genarray(a)
     {return 1 === caml_ba_num_dims(a)
              ?a
              :invalid_arg(cst_Bigarray_array1_of_genarra)}
    function array2_of_genarray(a)
     {return 2 === caml_ba_num_dims(a)
              ?a
              :invalid_arg(cst_Bigarray_array2_of_genarra)}
    function array3_of_genarray(a)
     {return 3 === caml_ba_num_dims(a)
              ?a
              :invalid_arg(cst_Bigarray_array3_of_genarra)}
    function reshape_0(a){return caml_ba_reshape(a,[0])}
    function reshape_1(a,dim1){return caml_ba_reshape(a,[0,dim1])}
    function reshape_2(a,dim1,dim2){return caml_ba_reshape(a,[0,dim1,dim2])}
    function reshape_3(a,dim1,dim2,dim3)
     {return caml_ba_reshape(a,[0,dim1,dim2,dim3])}
    var
     Stdlib_bigarray=
      [0,
       float32,
       float64,
       complex32,
       complex64,
       int8_signed,
       int8_unsigned,
       int16_signed,
       int16_unsigned,
       int$2,
       int32$1,
       int64$1,
       nativeint$1,
       char$0,
       kind_size_in_bytes,
       c_layout,
       fortran_layout,
       [0,init$5,dims,size_in_bytes],
       [0,
        create$8,
        of_value,
        caml_ba_change_layout,
        size_in_bytes$0,
        get$2,
        set$1,
        of_value],
       [0,
        create$9,
        init$6,
        caml_ba_change_layout,
        size_in_bytes$1,
        slice,
        of_array],
       [0,
        create$10,
        init$7,
        caml_ba_change_layout,
        size_in_bytes$2,
        slice_left,
        slice_right,
        of_array$0],
       [0,
        create$11,
        init$8,
        caml_ba_change_layout,
        size_in_bytes$3,
        slice_left_1,
        slice_right_1,
        slice_left_2,
        slice_right_2,
        of_array$1],
       array0_of_genarray,
       array1_of_genarray,
       array2_of_genarray,
       array3_of_genarray,
       caml_ba_reshape,
       reshape_0,
       reshape_1,
       reshape_2,
       reshape_3];
    caml_register_global(817,Stdlib_bigarray,"Stdlib__bigarray");
    return}
  (function(){return this}()));


//# 1 ".js/num.core/nums.cma.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     add_nat=runtime.add_nat,
     blit_nat=runtime.blit_nat,
     caml_bytes_get=runtime.caml_bytes_get,
     caml_bytes_set=runtime.caml_bytes_set,
     caml_div=runtime.caml_div,
     caml_equal=runtime.caml_equal,
     caml_greaterequal=runtime.caml_greaterequal,
     caml_greaterthan=runtime.caml_greaterthan,
     caml_int64_and=runtime.caml_int64_and,
     caml_int64_neg=runtime.caml_int64_neg,
     caml_int64_of_int32=runtime.caml_int64_of_int32,
     caml_int64_or=runtime.caml_int64_or,
     caml_int64_to_float=runtime.caml_int64_to_float,
     caml_int64_to_int32=runtime.caml_int64_to_int32,
     caml_ldexp_float=runtime.caml_ldexp_float,
     caml_ml_bytes_length=runtime.caml_ml_bytes_length,
     caml_ml_string_length=runtime.caml_ml_string_length,
     caml_mod=runtime.caml_mod,
     caml_mul=runtime.caml_mul,
     caml_register_global=runtime.caml_register_global,
     caml_string_get=runtime.caml_string_get,
     caml_string_of_jsbytes=runtime.caml_string_of_jsbytes,
     caml_wrap_exception=runtime.caml_wrap_exception,
     compare_nat=runtime.compare_nat,
     complement_nat=runtime.complement_nat,
     create_nat=runtime.create_nat,
     decr_nat=runtime.decr_nat,
     div_digit_nat=runtime.div_digit_nat,
     div_nat=runtime.div_nat,
     incr_nat=runtime.incr_nat,
     is_digit_int=runtime.is_digit_int,
     is_digit_zero=runtime.is_digit_zero,
     land_digit_nat=runtime.land_digit_nat,
     mult_digit_nat=runtime.mult_digit_nat,
     mult_nat=runtime.mult_nat,
     nth_digit_nat=runtime.nth_digit_nat,
     nth_digit_nat_native=runtime.nth_digit_nat_native,
     num_digits_nat=runtime.num_digits_nat,
     num_leading_zero_bits_in_digit=runtime.num_leading_zero_bits_in_digit,
     set_digit_nat=runtime.set_digit_nat,
     set_digit_nat_native=runtime.set_digit_nat_native,
     set_to_zero_nat=runtime.set_to_zero_nat,
     shift_right_nat=runtime.shift_right_nat,
     square_nat=runtime.square_nat,
     sub_nat=runtime.sub_nat;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5
              ?f(a0,a1,a2,a3,a4)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4])}
    var
     global_data=runtime.caml_get_global_data(),
     cst_invalid_digit=caml_string_of_jsbytes("invalid digit"),
     cst_number_too_long=caml_string_of_jsbytes("number too long"),
     cst_power_base_int=caml_string_of_jsbytes("power_base_int"),
     cst_nat_of_int=caml_string_of_jsbytes("nat_of_int"),
     cst_int_of_nat=caml_string_of_jsbytes("int_of_nat"),
     cst_make_nat=caml_string_of_jsbytes("make_nat"),
     cst_xor_big_int=caml_string_of_jsbytes("xor_big_int"),
     cst_or_big_int=caml_string_of_jsbytes("or_big_int"),
     cst_and_big_int=caml_string_of_jsbytes("and_big_int"),
     cst_extract_big_int=caml_string_of_jsbytes("extract_big_int"),
     cst_shift_right_big_int=caml_string_of_jsbytes("shift_right_big_int"),
     cst_two_power_m1_big_int=caml_string_of_jsbytes("two_power_m1_big_int"),
     cst_shift_right_towards_zero_b=
      caml_string_of_jsbytes("shift_right_towards_zero_big_int"),
     cst_shift_left_big_int=caml_string_of_jsbytes("shift_left_big_int"),
     cst_100000000=caml_string_of_jsbytes("100000000"),
     cst_963295986=caml_string_of_jsbytes("963295986"),
     cst$0=caml_string_of_jsbytes("-"),
     sign=caml_string_of_jsbytes(""),
     cst_e=caml_string_of_jsbytes("e"),
     cst_1=caml_string_of_jsbytes("1."),
     cst_e$0=caml_string_of_jsbytes("e"),
     cst$1=caml_string_of_jsbytes("."),
     cst_sqrt_big_int=caml_string_of_jsbytes("sqrt_big_int"),
     cst_base_power_big_int=caml_string_of_jsbytes("base_power_big_int"),
     cst_base_power_big_int$0=caml_string_of_jsbytes("base_power_big_int"),
     cst_base_power_big_int$1=caml_string_of_jsbytes("base_power_big_int"),
     cst_power_big_int_positive_big=
      caml_string_of_jsbytes("power_big_int_positive_big_int"),
     cst_power_int_positive_big_int=
      caml_string_of_jsbytes("power_int_positive_big_int"),
     cst_power_big_int_positive_int=
      caml_string_of_jsbytes("power_big_int_positive_int"),
     cst_power_int_positive_int=
      caml_string_of_jsbytes("power_int_positive_int"),
     cst_sys_big_int_of_string$1=
      caml_string_of_jsbytes("sys_big_int_of_string"),
     cst_sys_big_int_of_string$0=
      caml_string_of_jsbytes("sys_big_int_of_string"),
     cst_sys_big_int_of_string=caml_string_of_jsbytes("sys_big_int_of_string"),
     cst=caml_string_of_jsbytes("-"),
     cst_nat_of_big_int=caml_string_of_jsbytes("nat_of_big_int"),
     cst_int64_of_big_int$1=caml_string_of_jsbytes("int64_of_big_int"),
     cst_int64_of_big_int=caml_string_of_jsbytes("int64_of_big_int"),
     cst_int64_of_big_int$0=caml_string_of_jsbytes("int64_of_big_int"),
     cst_int32_of_big_int=caml_string_of_jsbytes("int32_of_big_int"),
     cst_nativeint_of_big_int=caml_string_of_jsbytes("nativeint_of_big_int"),
     cst_nativeint_of_big_int$0=caml_string_of_jsbytes("nativeint_of_big_int"),
     cst_nativeint_of_big_int$1=caml_string_of_jsbytes("nativeint_of_big_int"),
     cst_int_of_big_int=caml_string_of_jsbytes("int_of_big_int"),
     cst_create_big_int=caml_string_of_jsbytes("create_big_int"),
     cst$5=caml_string_of_jsbytes("/"),
     cst_approx_ratio_exp=caml_string_of_jsbytes("approx_ratio_exp"),
     cst_approx_ratio_exp$0=caml_string_of_jsbytes("approx_ratio_exp"),
     cst_0$0=caml_string_of_jsbytes("+0."),
     cst$4=caml_string_of_jsbytes(""),
     cst_1$1=caml_string_of_jsbytes("-1."),
     cst_1$2=caml_string_of_jsbytes("+1."),
     cst_0$1=caml_string_of_jsbytes("-0."),
     cst_0$2=caml_string_of_jsbytes("+0."),
     cst_approx_ratio_fix=caml_string_of_jsbytes("approx_ratio_fix"),
     cst_0=caml_string_of_jsbytes("+0"),
     cst_1$0=caml_string_of_jsbytes("1"),
     cst_msd_ratio=caml_string_of_jsbytes("msd_ratio"),
     cst_big_int_of_ratio=caml_string_of_jsbytes("big_int_of_ratio"),
     cst_nat_of_ratio$0=caml_string_of_jsbytes("nat_of_ratio"),
     cst_nat_of_ratio=caml_string_of_jsbytes("nat_of_ratio"),
     cst_integer_argument_required=
      caml_string_of_jsbytes("integer argument required"),
     cst_integer_ratio=caml_string_of_jsbytes("integer_ratio"),
     cst_inverse_ratio=caml_string_of_jsbytes("inverse_ratio"),
     cst_create_normalized_ratio=
      caml_string_of_jsbytes("create_normalized_ratio"),
     cst_create_ratio=caml_string_of_jsbytes("create_ratio"),
     cst$3=caml_string_of_jsbytes(""),
     s=caml_string_of_jsbytes("infinite or undefined rational number"),
     cst$2=caml_string_of_jsbytes(" "),
     cst_num_of_string=caml_string_of_jsbytes("num_of_string"),
     cst_power_num=caml_string_of_jsbytes("power_num"),
     cst_Normalization_during_compu=
      caml_string_of_jsbytes("Normalization during computation"),
     cst_returned_by_get_normalize_=
      caml_string_of_jsbytes("     (returned by get_normalize_ratio ())"),
     cst_modifiable_with_set_normal=
      caml_string_of_jsbytes
       ("     (modifiable with set_normalize_ratio <your choice>)"),
     cst_Normalization_when_printin=
      caml_string_of_jsbytes("Normalization when printing"),
     cst_returned_by_get_normalize_$0=
      caml_string_of_jsbytes
       ("     (returned by get_normalize_ratio_when_printing ())"),
     cst_modifiable_with_set_normal$0=
      caml_string_of_jsbytes
       ("     (modifiable with set_normalize_ratio_when_printing <your choice>)"),
     cst_Floating_point_approximati=
      caml_string_of_jsbytes
       ("Floating point approximation when printing rational numbers"),
     cst_returned_by_get_approx_pri=
      caml_string_of_jsbytes("     (returned by get_approx_printing ())"),
     cst_modifiable_with_set_approx=
      caml_string_of_jsbytes
       ("     (modifiable with set_approx_printing <your choice>)"),
     cst_Default_precision=caml_string_of_jsbytes("  Default precision = "),
     cst_returned_by_get_floating_p=
      caml_string_of_jsbytes("     (returned by get_floating_precision ())"),
     cst_modifiable_with_set_floati=
      caml_string_of_jsbytes
       ("     (modifiable with set_floating_precision <your choice>)"),
     cst_Error_when_a_rational_deno=
      caml_string_of_jsbytes("Error when a rational denominator is null"),
     cst_returned_by_get_error_when=
      caml_string_of_jsbytes
       ("     (returned by get_error_when_null_denominator ())"),
     cst_modifiable_with_set_error_=
      caml_string_of_jsbytes
       ("     (modifiable with set_error_when_null_denominator <your choice>)"),
     cst_ON=caml_string_of_jsbytes("ON"),
     cst_OFF=caml_string_of_jsbytes("OFF"),
     cst$6=caml_string_of_jsbytes(" --> "),
     Stdlib=global_data.Stdlib,
     Stdlib_sys=global_data.Stdlib__sys,
     Stdlib_string=global_data.Stdlib__string,
     Stdlib_bytes=global_data.Stdlib__bytes,
     Stdlib_char=global_data.Stdlib__char,
     Assert_failure=global_data.Assert_failure,
     Stdlib_int64=global_data.Stdlib__int64,
     Stdlib_nativeint=global_data.Stdlib__nativeint,
     _z_=[0,caml_string_of_jsbytes("nat.ml"),273,9],
     _y_=runtime.caml_int64_create_lo_mi_hi(6553600,11973543,3552),
     _x_=[0,caml_string_of_jsbytes("nat.ml"),280,9],
     _w_=[0,caml_string_of_jsbytes("nat.ml"),287,9],
     _v_=[0,caml_string_of_jsbytes("nat.ml"),293,9],
     _u_=runtime.caml_int64_create_lo_mi_hi(6553600,11973543,3552),
     _l_=[0,caml_string_of_jsbytes("big_int.ml"),879,2],
     _k_=runtime.caml_int64_create_lo_mi_hi(1,0,0),
     _j_=runtime.caml_int64_create_lo_mi_hi(16777215,255,0),
     _g_=runtime.caml_int64_create_lo_mi_hi(16777215,255,0),
     _h_=runtime.caml_int64_create_lo_mi_hi(0,0,0),
     _i_=runtime.caml_int64_create_lo_mi_hi(0,0,0),
     _d_=runtime.caml_int64_create_lo_mi_hi(0,0,0),
     _e_=runtime.caml_int64_create_lo_mi_hi(0,0,0),
     _f_=runtime.caml_int64_create_lo_mi_hi(0,0,0),
     _n_=[0,caml_string_of_jsbytes("ratio.ml"),575,11],
     _m_=[0,caml_string_of_jsbytes("e0"),0],
     _r_=[0,1],
     _s_=[0,1],
     _t_=[0,1],
     _o_=[0,1],
     _p_=[0,1],
     _q_=[0,1];
    function gcd_int(i1,i2)
     {var i1$0=i1,i2$0=i2;
      for(;;)
       {if(0 === i2$0)return caml_call1(Stdlib[18],i1$0);
        var i2$1=caml_mod(i1$0,i2$0),i1$0=i2$0,i2$0=i2$1;
        continue}}
    function num_bits_int_aux(n)
     {return 0 === n?0:num_bits_int_aux(n >>> 1 | 0) + 1 | 0}
    function num_bits_int(n)
     {return num_bits_int_aux(caml_call1(Stdlib[18],n))}
    function sign_int(i){return 0 === i?0:0 < i?1:-1}
    var
     length_of_int=Stdlib_sys[10] - 1 | 0,
     monster_int=1 << length_of_int,
     biggest_int=monster_int - 1 | 0,
     least_int=- biggest_int | 0;
    function compare_int(n1,n2)
     {return n1 === n2?0:caml_greaterthan(n1,n2)?1:-1}
    var
     Int_misc=
      [0,
       gcd_int,
       num_bits_int,
       compare_int,
       sign_int,
       length_of_int,
       biggest_int,
       least_int,
       monster_int];
    caml_register_global(122,Int_misc,"Int_misc");
    runtime.initialize_nat(0);
    function length_nat(n){return n.length - 1 - 1 | 0}
    var _a_=Stdlib_sys[9];
    function make_nat(len)
     {if(0 <= len)
       {var res=create_nat(len);set_to_zero_nat(res,0,len);return res}
      return caml_call1(Stdlib[1],cst_make_nat)}
    var a_2=make_nat(2),a_1=make_nat(1),b_2=make_nat(2);
    function copy_nat(nat,off_set,length)
     {var res=create_nat(length);
      blit_nat(res,0,nat,off_set,length);
      return res}
    function is_zero_nat(n,off,len)
     {var _dl_=num_digits_nat(n,off,len);
      return 0 === compare_nat(make_nat(1),0,1,n,off,_dl_)?1:0}
    function is_nat_int(nat,off,len)
     {var
       _dj_=1 === num_digits_nat(nat,off,len)?1:0,
       _dk_=_dj_?is_digit_int(nat,off):_dj_;
      return _dk_}
    function int_of_nat(nat)
     {var len=length_nat(nat);
      return is_nat_int(nat,0,len)
              ?nth_digit_nat(nat,0)
              :caml_call1(Stdlib[2],cst_int_of_nat)}
    function nat_of_int(i)
     {if(0 <= i)
       {var res=make_nat(1);return 0 === i?res:(set_digit_nat(res,0,i),res)}
      return caml_call1(Stdlib[1],cst_nat_of_int)}
    function eq_nat(nat1,off1,len1,nat2,off2,len2)
     {var _di_=num_digits_nat(nat2,off2,len2);
      return 0
              ===
              compare_nat
               (nat1,off1,num_digits_nat(nat1,off1,len1),nat2,off2,_di_)
              ?1
              :0}
    function le_nat(nat1,off1,len1,nat2,off2,len2)
     {var _dh_=num_digits_nat(nat2,off2,len2);
      return compare_nat
               (nat1,off1,num_digits_nat(nat1,off1,len1),nat2,off2,_dh_)
              <=
              0
              ?1
              :0}
    function lt_nat(nat1,off1,len1,nat2,off2,len2)
     {var _dg_=num_digits_nat(nat2,off2,len2);
      return compare_nat
               (nat1,off1,num_digits_nat(nat1,off1,len1),nat2,off2,_dg_)
              <
              0
              ?1
              :0}
    function ge_nat(nat1,off1,len1,nat2,off2,len2)
     {var _df_=num_digits_nat(nat2,off2,len2);
      return 0
              <=
              compare_nat
               (nat1,off1,num_digits_nat(nat1,off1,len1),nat2,off2,_df_)
              ?1
              :0}
    function gt_nat(nat1,off1,len1,nat2,off2,len2)
     {var _de_=num_digits_nat(nat2,off2,len2);
      return 0
              <
              compare_nat
               (nat1,off1,num_digits_nat(nat1,off1,len1),nat2,off2,_de_)
              ?1
              :0}
    function exchange(r1,r2)
     {var old1=r1[1];r1[1] = r2[1];r2[1] = old1;return 0}
    function gcd_nat(nat1,off1,len1,nat2,off2,len2)
     {if(is_zero_nat(nat1,off1,len1))
       {blit_nat(nat1,off1,nat2,off2,len2);return len2}
      var
       copy1=[0,create_nat(len1 + 1 | 0)],
       copy2=[0,create_nat(len2 + 1 | 0)];
      blit_nat(copy1[1],0,nat1,off1,len1);
      blit_nat(copy2[1],0,nat2,off2,len2);
      set_digit_nat(copy1[1],len1,0);
      set_digit_nat(copy2[1],len2,0);
      if(lt_nat(copy1[1],0,len1,copy2[1],0,len2))exchange(copy1,copy2);
      var
       _dc_=length_nat(copy1[1]),
       real_len1=[0,num_digits_nat(copy1[1],0,_dc_)],
       _dd_=length_nat(copy2[1]),
       real_len2=[0,num_digits_nat(copy2[1],0,_dd_)];
      for(;;)
       {if(is_zero_nat(copy2[1],0,real_len2[1]))
         {blit_nat(nat1,off1,copy1[1],0,real_len1[1]);return real_len1[1]}
        set_digit_nat(copy1[1],real_len1[1],0);
        div_nat(copy1[1],0,real_len1[1] + 1 | 0,copy2[1],0,real_len2[1]);
        exchange(copy1,copy2);
        real_len1[1] = real_len2[1];
        real_len2[1] = num_digits_nat(copy2[1],0,real_len2[1]);
        continue}}
    function sqrt_nat(rad,off,len)
     {var
       len$0=num_digits_nat(rad,off,len),
       len_parity=len$0 % 2 | 0,
       rad_len=(len$0 + 1 | 0) + len_parity | 0,
       rad$0=create_nat(rad_len);
      blit_nat(rad$0,0,rad,off,len$0);
      set_digit_nat(rad$0,len$0,0);
      set_digit_nat(rad$0,rad_len - 1 | 0,0);
      var
       cand_len=(len$0 + 1 | 0) / 2 | 0,
       cand_rest=rad_len - cand_len | 0,
       cand=make_nat(cand_len),
       shift_cand=
        (num_leading_zero_bits_in_digit(rad$0,len$0 - 1 | 0)
         +
         caml_mul(_a_,len_parity)
         |
         0)
        /
        2
        |
        0;
      if(shift_cand === _a_)return cand;
      complement_nat(cand,0,cand_len);
      shift_right_nat(cand,0,1,a_1,0,shift_cand);
      var next_cand=create_nat(rad_len);
      for(;;)
       {blit_nat(next_cand,0,rad$0,0,rad_len);
        div_nat(next_cand,0,rad_len,cand,0,cand_len);
        add_nat(next_cand,cand_len,cand_rest,cand,0,cand_len,0);
        shift_right_nat(next_cand,cand_len,cand_rest,a_1,0,1);
        if(lt_nat(next_cand,cand_len,cand_rest,cand,0,cand_len))
         {blit_nat(cand,0,next_cand,cand_len,cand_len);continue}
        return cand}}
    var power_base_max=make_nat(2);
    if(32 === _a_)
     set_digit_nat(power_base_max,0,1000000000);
    else
     {if(64 !== _a_)throw [0,Assert_failure,_z_];
      set_digit_nat(power_base_max,0,caml_int64_to_int32(_y_));
      mult_digit_nat(power_base_max,0,2,power_base_max,0,1,nat_of_int(9),0)}
    if(32 === _a_)
     var _b_=9;
    else
     {if(64 !== _a_)throw [0,Assert_failure,_x_];var _b_=19}
    if(32 === _a_)
     var _c_=9;
    else
     {if(64 !== _a_)throw [0,Assert_failure,_w_];var _c_=18}
    if(32 === _a_)
     var max_power_10_power_in_int=nat_of_int(1000000000);
    else
     {if(64 !== _a_)throw [0,Assert_failure,_v_];
      var max_power_10_power_in_int=nat_of_int(caml_int64_to_int32(_u_))}
    function raw_string_of_digit(nat,off)
     {if(is_nat_int(nat,off,1))
       {var _c$_=nth_digit_nat(nat,off);return caml_call1(Stdlib[33],_c$_)}
      blit_nat(b_2,0,nat,off,1);
      div_digit_nat(a_2,0,a_1,0,b_2,0,2,max_power_10_power_in_int,0);
      var
       leading_digits=nth_digit_nat(a_2,0),
       _da_=nth_digit_nat(a_1,0),
       s1=caml_call1(Stdlib[33],_da_),
       len=caml_ml_string_length(s1);
      if(10 <= leading_digits)
       {var
         result=caml_call2(Stdlib_bytes[1],_c_ + 2 | 0,48),
         _db_=caml_call1(Stdlib[33],leading_digits);
        caml_call5(Stdlib_string[32],_db_,0,result,0,2);
        caml_call5
         (Stdlib_string[32],
          s1,
          0,
          result,
          caml_ml_bytes_length(result) - len | 0,
          len);
        return caml_call1(Stdlib_bytes[6],result)}
      var result$0=caml_call2(Stdlib_bytes[1],_c_ + 1 | 0,48);
      caml_bytes_set
       (result$0,0,caml_call1(Stdlib_char[1],48 + leading_digits | 0));
      caml_call5
       (Stdlib_string[32],
        s1,
        0,
        result$0,
        caml_ml_bytes_length(result$0) - len | 0,
        len);
      return caml_call1(Stdlib_bytes[6],result$0)}
    function make_power_base(base,power_base)
     {var i=[0,0],j=[0,0];
      set_digit_nat(power_base,0,base);
      for(;;)
       {i[1]++;
        if(is_digit_zero(power_base,i[1]))
         {mult_digit_nat
           (power_base,i[1],2,power_base,i[1] - 1 | 0,1,power_base,0);
          continue}
        for(;;)
         {if(j[1] < (i[1] - 1 | 0) && is_digit_int(power_base,j[1]))
           {j[1]++;continue}
          return [0,i[1] - 2 | 0,j[1]]}}}
    function power_base_int(base,i)
     {if(0 !== i && 1 !== base)
       {if(0 === base)return nat_of_int(0);
        if(0 <= i)
         {var
           power_base=make_nat(_a_ + 1 | 0),
           match=make_power_base(base,power_base),
           pmax=match[1],
           n=caml_div(i,pmax + 1 | 0),
           rem=caml_mod(i,pmax + 1 | 0);
          if(0 < n)
           {var
             newn=i === biggest_int?n:n + 1 | 0,
             res=make_nat(newn),
             res2=make_nat(newn),
             l=num_bits_int(n) - 2 | 0;
            blit_nat(res,0,power_base,pmax,1);
            if(! (l < 0))
             {var i$0=l;
              for(;;)
               {var
                 len=num_digits_nat(res,0,newn),
                 len2=caml_call2(Stdlib[16],n,2 * len | 0),
                 succ_len2=len2 + 1 | 0;
                square_nat(res2,0,len2,res,0,len);
                if(0 < (n & 1 << i$0))
                 {set_to_zero_nat(res,0,len);
                  mult_digit_nat(res,0,succ_len2,res2,0,len2,power_base,pmax)}
                else
                 blit_nat(res,0,res2,0,len2);
                set_to_zero_nat(res2,0,len2);
                var _c__=i$0 - 1 | 0;
                if(0 !== i$0){var i$0=_c__;continue}
                break}}
            return 0 < rem
                    ?(mult_digit_nat(res2,0,newn,res,0,n,power_base,rem - 1 | 0),
                      res2)
                    :res}
          return copy_nat(power_base,rem - 1 | 0,1)}
        return caml_call1(Stdlib[1],cst_power_base_int)}
      return nat_of_int(1)}
    function unadjusted_string_of_nat(nat,off,len_nat)
     {var len=num_digits_nat(nat,off,len_nat);
      if(1 === len)return raw_string_of_digit(nat,off);
      var
       len_copy=[0,len + 1 | 0],
       copy1=create_nat(len_copy[1]),
       copy2=make_nat(len_copy[1]),
       rest_digit=make_nat(2);
      if(caml_div(biggest_int,_b_ + 1 | 0) < len)
       return caml_call1(Stdlib[2],cst_number_too_long);
      var
       len_s=caml_mul(_b_ + 1 | 0,len),
       s=caml_call2(Stdlib_bytes[1],len_s,48),
       pos_ref=[0,len_s];
      len_copy[1] = len_copy[1] - 1 | 0;
      blit_nat(copy1,0,nat,off,len);
      set_digit_nat(copy1,len,0);
      for(;;)
       {if(is_zero_nat(copy1,0,len_copy[1]))
         return caml_call1(Stdlib_bytes[42],s);
        div_digit_nat
         (copy2,0,rest_digit,0,copy1,0,len_copy[1] + 1 | 0,power_base_max,0);
        var str=raw_string_of_digit(rest_digit,0);
        caml_call5
         (Stdlib_string[32],
          str,
          0,
          s,
          pos_ref[1] - caml_ml_string_length(str) | 0,
          caml_ml_string_length(str));
        pos_ref[1] = pos_ref[1] - _b_ | 0;
        len_copy[1] = num_digits_nat(copy2,0,len_copy[1]);
        blit_nat(copy1,0,copy2,0,len_copy[1]);
        set_digit_nat(copy1,len_copy[1],0);
        continue}}
    function string_of_nat(nat)
     {var s=unadjusted_string_of_nat(nat,0,length_nat(nat)),index=[0,0];
      try
       {var _c7_=caml_ml_string_length(s) - 2 | 0,_c6_=0;
        if(! (_c7_ < 0))
         {var i=_c6_;
          for(;;)
           {if(48 !== caml_string_get(s,i)){index[1] = i;throw Stdlib[3]}
            var _c8_=i + 1 | 0;
            if(_c7_ !== i){var i=_c8_;continue}
            break}}}
      catch(_c9_)
       {_c9_ = caml_wrap_exception(_c9_);if(_c9_ !== Stdlib[3])throw _c9_}
      return caml_call3
              (Stdlib_string[9],
               s,
               index[1],
               caml_ml_string_length(s) - index[1] | 0)}
    function sys_nat_of_string(base,s,off,len)
     {var
       power_base=make_nat(_a_ + 1 | 0),
       match=make_power_base(base,power_base),
       pint=match[2],
       pmax=match[1],
       _cY_=1 + caml_div(len,pmax + 1 | 0) | 0,
       current_len=[0,1],
       possible_len=[0,caml_call2(Stdlib[16],2,_cY_)],
       nat1=make_nat(_cY_),
       nat2=make_nat(_cY_),
       digits_read=[0,0],
       bound=(off + len | 0) - 1 | 0,
       int$0=[0,0];
      if(! (bound < off))
       {var i=off;
        for(;;)
         {var n=caml_string_get(s,i),switch$0=0;
          if(32 <= n)
           {if(93 <= n)
             {if(95 === n && off < i)switch$0 = 2}
            else
             if(58 < (n - 33 | 0) >>> 0)switch$0 = 1}
          else
           if(11 <= n){if(13 === n)switch$0 = 1}else if(9 <= n)switch$0 = 1;
          switch(switch$0)
           {case 0:
             var switch$1=0;
             if(48 <= n && n <= (47 + caml_call2(Stdlib[16],base,10) | 0))
              var _c5_=n - 48 | 0;
             else
              switch$1 = 1;
             if(switch$1)
              {var switch$2=0;
               if(65 <= n && n <= ((65 + base | 0) - 11 | 0))
                var _c5_=n - 55 | 0;
               else
                switch$2 = 1;
               if(switch$2)
                {var switch$3=0;
                 if(97 <= n && n <= ((97 + base | 0) - 11 | 0))
                  var _c5_=n - 87 | 0;
                 else
                  switch$3 = 1;
                 if(switch$3)var _c5_=caml_call1(Stdlib[2],cst_invalid_digit)}}
             int$0[1] = caml_mul(int$0[1],base) + _c5_ | 0;
             digits_read[1]++;
             break;
            case 1:break
            }
          var
           _cZ_=digits_read[1] === pint?1:0,
           _c0_=_cZ_ || (i === bound?1:0),
           _c1_=_c0_?1 - (0 === digits_read[1]?1:0):_c0_;
          if(_c1_)
           {set_digit_nat(nat1,0,int$0[1]);
            var
             erase_len=
              _cY_ === current_len[1]?current_len[1] - 1 | 0:current_len[1],
             _c2_=1;
            if(! (erase_len < 1))
             {var j=_c2_;
              for(;;)
               {set_digit_nat(nat1,j,0);
                var _c4_=j + 1 | 0;
                if(erase_len !== j){var j=_c4_;continue}
                break}}
            mult_digit_nat
             (nat1,
              0,
              possible_len[1],
              nat2,
              0,
              current_len[1],
              power_base,
              digits_read[1] - 1 | 0);
            blit_nat(nat2,0,nat1,0,possible_len[1]);
            current_len[1] = num_digits_nat(nat1,0,possible_len[1]);
            possible_len[1]
            =
            caml_call2(Stdlib[16],_cY_,current_len[1] + 1 | 0);
            int$0[1] = 0;
            digits_read[1] = 0}
          var _c3_=i + 1 | 0;
          if(bound !== i){var i=_c3_;continue}
          break}}
      var nat=create_nat(current_len[1]);
      blit_nat(nat,0,nat1,0,current_len[1]);
      return nat}
    function nat_of_string(s)
     {return sys_nat_of_string(10,s,0,caml_ml_string_length(s))}
    function float_of_nat(nat)
     {return runtime.caml_float_of_string(string_of_nat(nat))}
    var
     Nat=
      [0,
       make_nat,
       copy_nat,
       length_nat,
       is_zero_nat,
       is_nat_int,
       int_of_nat,
       nat_of_int,
       eq_nat,
       le_nat,
       lt_nat,
       ge_nat,
       gt_nat,
       gcd_nat,
       sqrt_nat,
       string_of_nat,
       nat_of_string,
       sys_nat_of_string,
       float_of_nat,
       make_power_base,
       power_base_int,
       _a_];
    caml_register_global(127,Nat,"Nat");
    function sign_big_int(bi){return bi[1]}
    var zero_big_int=[0,0,make_nat(1)],unit_big_int=[0,1,nat_of_int(1)];
    function num_digits_big_int(bi)
     {var _cX_=length_nat(bi[2]);return num_digits_nat(bi[2],0,_cX_)}
    function num_bits_big_int(bi)
     {var
       _cW_=length_nat(bi[2]),
       nd=num_digits_nat(bi[2],0,_cW_),
       lz=num_leading_zero_bits_in_digit(bi[2],nd - 1 | 0);
      return caml_mul(nd,_a_) - lz | 0}
    function minus_big_int(bi)
     {var _cU_=num_digits_big_int(bi),_cV_=copy_nat(bi[2],0,_cU_);
      return [0,- bi[1] | 0,_cV_]}
    function abs_big_int(bi)
     {var
       _cR_=num_digits_big_int(bi),
       _cS_=copy_nat(bi[2],0,_cR_),
       _cT_=0 === bi[1]?0:1;
      return [0,_cT_,_cS_]}
    function compare_big_int(bi1,bi2)
     {if(0 === bi1[1] && 0 === bi2[1])return 0;
      if(bi1[1] < bi2[1])return -1;
      if(bi2[1] < bi1[1])return 1;
      if(1 === bi1[1])
       {var
         _cL_=num_digits_big_int(bi2),
         _cM_=bi2[2],
         _cN_=num_digits_big_int(bi1);
        return compare_nat(bi1[2],0,_cN_,_cM_,0,_cL_)}
      var
       _cO_=num_digits_big_int(bi1),
       _cP_=bi1[2],
       _cQ_=num_digits_big_int(bi2);
      return compare_nat(bi2[2],0,_cQ_,_cP_,0,_cO_)}
    function eq_big_int(bi1,bi2){return 0 === compare_big_int(bi1,bi2)?1:0}
    function le_big_int(bi1,bi2){return compare_big_int(bi1,bi2) <= 0?1:0}
    function ge_big_int(bi1,bi2){return 0 <= compare_big_int(bi1,bi2)?1:0}
    function lt_big_int(bi1,bi2){return compare_big_int(bi1,bi2) < 0?1:0}
    function gt_big_int(bi1,bi2){return 0 < compare_big_int(bi1,bi2)?1:0}
    function max_big_int(bi1,bi2){return lt_big_int(bi1,bi2)?bi2:bi1}
    function min_big_int(bi1,bi2){return gt_big_int(bi1,bi2)?bi2:bi1}
    function pred_big_int(bi)
     {var _cJ_=bi[1];
      if(0 === _cJ_)return [0,-1,nat_of_int(1)];
      if(1 === _cJ_)
       {var size_bi=num_digits_big_int(bi),copy_bi=copy_nat(bi[2],0,size_bi);
        decr_nat(copy_bi,0,size_bi,0);
        var _cK_=is_zero_nat(copy_bi,0,size_bi)?0:1;
        return [0,_cK_,copy_bi]}
      var
       size_bi$0=num_digits_big_int(bi),
       size_res=size_bi$0 + 1 | 0,
       copy_bi$0=create_nat(size_res);
      blit_nat(copy_bi$0,0,bi[2],0,size_bi$0);
      set_digit_nat(copy_bi$0,size_bi$0,0);
      incr_nat(copy_bi$0,0,size_res,1);
      return [0,-1,copy_bi$0]}
    function succ_big_int(bi)
     {var _cH_=bi[1];
      if(-1 === _cH_)
       {var size_bi=num_digits_big_int(bi),copy_bi=copy_nat(bi[2],0,size_bi);
        decr_nat(copy_bi,0,size_bi,0);
        var _cI_=is_zero_nat(copy_bi,0,size_bi)?0:-1;
        return [0,_cI_,copy_bi]}
      if(0 === _cH_)return [0,1,nat_of_int(1)];
      var
       size_bi$0=num_digits_big_int(bi),
       size_res=size_bi$0 + 1 | 0,
       copy_bi$0=create_nat(size_res);
      blit_nat(copy_bi$0,0,bi[2],0,size_bi$0);
      set_digit_nat(copy_bi$0,size_bi$0,0);
      incr_nat(copy_bi$0,0,size_res,1);
      return [0,1,copy_bi$0]}
    function add_big_int(bi1,bi2)
     {var size_bi1=num_digits_big_int(bi1),size_bi2=num_digits_big_int(bi2);
      if(bi1[1] === bi2[1])
       {var match=compare_nat(bi1[2],0,size_bi1,bi2[2],0,size_bi2);
        if(-1 === match)
         {var res=create_nat(size_bi2 + 1 | 0);
          blit_nat(res,0,bi2[2],0,size_bi2);
          set_digit_nat(res,size_bi2,0);
          add_nat(res,0,size_bi2 + 1 | 0,bi1[2],0,size_bi1,0);
          var res$0=res}
        else
         {var res$1=create_nat(size_bi1 + 1 | 0);
          blit_nat(res$1,0,bi1[2],0,size_bi1);
          set_digit_nat(res$1,size_bi1,0);
          add_nat(res$1,0,size_bi1 + 1 | 0,bi2[2],0,size_bi2,0);
          var res$0=res$1}
        return [0,bi1[1],res$0]}
      var match$0=compare_nat(bi1[2],0,size_bi1,bi2[2],0,size_bi2);
      if(0 === match$0)return zero_big_int;
      if(1 === match$0)
       {var res$2=copy_nat(bi1[2],0,size_bi1);
        sub_nat(res$2,0,size_bi1,bi2[2],0,size_bi2,1);
        return [0,bi1[1],res$2]}
      var res$3=copy_nat(bi2[2],0,size_bi2);
      sub_nat(res$3,0,size_bi2,bi1[2],0,size_bi1,1);
      return [0,bi2[1],res$3]}
    function big_int_of_int(i)
     {var res=create_nat(1);
      if(i === monster_int)
       {set_digit_nat(res,0,biggest_int);incr_nat(res,0,1,1)}
      else
       set_digit_nat(res,0,caml_call1(Stdlib[18],i));
      return [0,sign_int(i),res]}
    function add_int_big_int(i,bi){return add_big_int(big_int_of_int(i),bi)}
    function sub_big_int(bi1,bi2){return add_big_int(bi1,minus_big_int(bi2))}
    function mult_int_big_int(i,bi)
     {var size_bi=num_digits_big_int(bi),size_res=size_bi + 1 | 0;
      if(i === monster_int)
       {var res=create_nat(size_res);
        blit_nat(res,0,bi[2],0,size_bi);
        set_digit_nat(res,size_bi,0);
        var _cE_=nat_of_int(biggest_int);
        mult_digit_nat(res,0,size_res,bi[2],0,size_bi,_cE_,0);
        return [0,- bi[1] | 0,res]}
      var res$0=make_nat(size_res),_cF_=nat_of_int(caml_call1(Stdlib[18],i));
      mult_digit_nat(res$0,0,size_res,bi[2],0,size_bi,_cF_,0);
      var _cG_=bi[1];
      return [0,caml_mul(sign_int(i),_cG_),res$0]}
    function mult_big_int(bi1,bi2)
     {var
       size_bi1=num_digits_big_int(bi1),
       size_bi2=num_digits_big_int(bi2),
       size_res=size_bi1 + size_bi2 | 0,
       res=make_nat(size_res);
      if(size_bi1 < size_bi2)
       mult_nat(res,0,size_res,bi2[2],0,size_bi2,bi1[2],0,size_bi1);
      else
       mult_nat(res,0,size_res,bi1[2],0,size_bi1,bi2[2],0,size_bi2);
      return [0,caml_mul(bi1[1],bi2[1]),res]}
    function quomod_big_int(bi1,bi2)
     {if(0 === bi2[1])throw Stdlib[13];
      var
       size_bi1=num_digits_big_int(bi1),
       size_bi2=num_digits_big_int(bi2),
       match=compare_nat(bi1[2],0,size_bi1,bi2[2],0,size_bi2);
      if(-1 === match)
       {if(0 <= bi1[1])return [0,big_int_of_int(0),bi1];
        if(0 <= bi2[1])
         {var _cx_=add_big_int(bi2,bi1);return [0,big_int_of_int(-1),_cx_]}
        var _cy_=sub_big_int(bi1,bi2);
        return [0,big_int_of_int(1),_cy_]}
      if(0 === match)
       return [0,big_int_of_int(caml_mul(bi1[1],bi2[1])),zero_big_int];
      var
       bi1_negatif=-1 === bi1[1]?1:0,
       _cz_=
        bi1_negatif
         ?caml_call2(Stdlib[17],(size_bi1 - size_bi2 | 0) + 1 | 0,1) + 1 | 0
         :caml_call2(Stdlib[17],(size_bi1 - size_bi2 | 0) + 1 | 0,1),
       size_r=caml_call2(Stdlib[17],size_bi1,size_bi2) + 1 | 0,
       q=create_nat(_cz_),
       r=create_nat(size_r);
      blit_nat(r,0,bi1[2],0,size_bi1);
      set_to_zero_nat(r,size_bi1,size_r - size_bi1 | 0);
      div_nat(r,0,size_r,bi2[2],0,size_bi2);
      blit_nat(q,0,r,size_bi2,size_r - size_bi2 | 0);
      var not_null_mod=1 - is_zero_nat(r,0,size_bi2);
      if(bi1_negatif && not_null_mod)
       {var new_r=copy_nat(bi2[2],0,size_bi2);
        sub_nat(new_r,0,size_bi2,r,0,size_bi2,1);
        set_digit_nat(q,_cz_ - 1 | 0,0);
        incr_nat(q,0,_cz_,1);
        return [0,[0,- bi2[1] | 0,q],[0,1,new_r]]}
      if(bi1_negatif)set_digit_nat(q,_cz_ - 1 | 0,0);
      var
       _cA_=copy_nat(r,0,size_bi2),
       _cB_=not_null_mod?1:0,
       _cC_=[0,_cB_,_cA_],
       _cD_=is_zero_nat(q,0,_cz_)?0:caml_mul(bi1[1],bi2[1]);
      return [0,[0,_cD_,q],_cC_]}
    function div_big_int(bi1,bi2){return quomod_big_int(bi1,bi2)[1]}
    function mod_big_int(bi1,bi2){return quomod_big_int(bi1,bi2)[2]}
    function gcd_big_int(bi1,bi2)
     {var size_bi1=num_digits_big_int(bi1),size_bi2=num_digits_big_int(bi2);
      if(is_zero_nat(bi1[2],0,size_bi1))return abs_big_int(bi2);
      if(is_zero_nat(bi2[2],0,size_bi2))return [0,1,bi1[2]];
      var match=compare_nat(bi1[2],0,size_bi1,bi2[2],0,size_bi2);
      if(0 === match)
       var _cw_=bi1[2];
      else
       if(1 === match)
        var
         res=copy_nat(bi1[2],0,size_bi1),
         len=gcd_nat(res,0,size_bi1,bi2[2],0,size_bi2),
         _cw_=copy_nat(res,0,len);
       else
        var
         res$0=copy_nat(bi2[2],0,size_bi2),
         len$0=gcd_nat(res$0,0,size_bi2,bi1[2],0,size_bi1),
         _cw_=copy_nat(res$0,0,len$0);
      return [0,1,_cw_]}
    var
     monster_big_int=big_int_of_int(monster_int),
     monster_nat=monster_big_int[2];
    function is_int_big_int(bi)
     {var _cu_=1 === num_digits_big_int(bi)?1:0;
      if(_cu_)
       {var match=compare_nat(bi[2],0,1,monster_nat,0,1);
        if(-1 !== match)return 0 === match?-1 === bi[1]?1:0:0;
        var _cv_=1}
      else
       var _cv_=_cu_;
      return _cv_}
    function int_of_big_int(bi)
     {try
       {var n=int_of_nat(bi[2]),_cs_=-1 === bi[1]?- n | 0:n;return _cs_}
      catch(_ct_)
       {_ct_ = caml_wrap_exception(_ct_);
        if(_ct_[1] === Stdlib[7])
         return eq_big_int(bi,monster_big_int)
                 ?monster_int
                 :caml_call1(Stdlib[2],cst_int_of_big_int);
        throw _ct_}}
    function int_of_big_int_opt(bi)
     {try
       {var _cq_=[0,int_of_big_int(bi)];return _cq_}
      catch(_cr_)
       {_cr_ = caml_wrap_exception(_cr_);
        if(_cr_[1] === Stdlib[7])return 0;
        throw _cr_}}
    function big_int_of_nativeint(i)
     {if(caml_equal(i,0))return zero_big_int;
      if(caml_greaterthan(i,0))
       {var res=create_nat(1);set_digit_nat_native(res,0,i);return [0,1,res]}
      var res$0=create_nat(1);
      set_digit_nat_native(res$0,0,- i | 0);
      return [0,-1,res$0]}
    function nativeint_of_big_int(bi)
     {if(1 < num_digits_big_int(bi))
       caml_call1(Stdlib[2],cst_nativeint_of_big_int);
      var i=nth_digit_nat_native(bi[2],0);
      if(0 <= bi[1])
       return caml_greaterequal(i,0)
               ?i
               :caml_call1(Stdlib[2],cst_nativeint_of_big_int$0);
      if(! caml_greaterequal(i,0) && ! caml_equal(i,Stdlib_nativeint[11]))
       return caml_call1(Stdlib[2],cst_nativeint_of_big_int$1);
      return - i | 0}
    function nativeint_of_big_int_opt(bi)
     {try
       {var _co_=[0,nativeint_of_big_int(bi)];return _co_}
      catch(_cp_)
       {_cp_ = caml_wrap_exception(_cp_);
        if(_cp_[1] === Stdlib[7])return 0;
        throw _cp_}}
    function big_int_of_int32(i){return big_int_of_nativeint(i)}
    function int32_of_big_int(bi)
     {var i=nativeint_of_big_int(bi);
      if
       (runtime.caml_lessequal(i,2147483647)
        &&
        caml_greaterequal(i,-2147483648))
       return i;
      return caml_call1(Stdlib[2],cst_int32_of_big_int)}
    function int32_of_big_int_opt(bi)
     {try
       {var _cm_=[0,int32_of_big_int(bi)];return _cm_}
      catch(_cn_)
       {_cn_ = caml_wrap_exception(_cn_);
        if(_cn_[1] === Stdlib[7])return 0;
        throw _cn_}}
    function big_int_of_int64(i)
     {if(64 === Stdlib_sys[9])
       return big_int_of_nativeint(caml_int64_to_int32(i));
      if(caml_equal(i,_d_))
       var absi=_e_,sg=0;
      else
       if(caml_greaterthan(i,_f_))
        var absi=i,sg=1;
       else
        var absi$0=caml_int64_neg(i),absi=absi$0,sg=-1;
      var res=create_nat(2);
      set_digit_nat_native(res,0,caml_int64_to_int32(absi));
      set_digit_nat_native
       (res,1,caml_int64_to_int32(runtime.caml_int64_shift_right(absi,32)));
      return [0,sg,res]}
    function int64_of_big_int(bi)
     {if(64 === Stdlib_sys[9])
       return caml_int64_of_int32(nativeint_of_big_int(bi));
      var match=num_digits_big_int(bi);
      if(1 === match)
       var
        i=
         caml_int64_and
          (caml_int64_of_int32(nth_digit_nat_native(bi[2],0)),_g_);
      else
       if(2 === match)
        var
         _cl_=
          runtime.caml_int64_shift_left
           (caml_int64_of_int32(nth_digit_nat_native(bi[2],1)),32),
         i=
          caml_int64_or
           (caml_int64_and
             (caml_int64_of_int32(nth_digit_nat_native(bi[2],0)),_j_),
            _cl_);
       else
        var i=caml_call1(Stdlib[2],cst_int64_of_big_int$1);
      if(0 <= bi[1])
       return caml_greaterequal(i,_h_)
               ?i
               :caml_call1(Stdlib[2],cst_int64_of_big_int);
      if(! caml_greaterequal(i,_i_) && ! caml_equal(i,Stdlib_int64[10]))
       return caml_call1(Stdlib[2],cst_int64_of_big_int$0);
      return caml_int64_neg(i)}
    function int64_of_big_int_opt(bi)
     {try
       {var _cj_=[0,int64_of_big_int(bi)];return _cj_}
      catch(_ck_)
       {_ck_ = caml_wrap_exception(_ck_);
        if(_ck_[1] === Stdlib[7])return 0;
        throw _ck_}}
    function nat_of_big_int(bi)
     {if(-1 === bi[1])return caml_call1(Stdlib[2],cst_nat_of_big_int);
      var _ci_=num_digits_big_int(bi);
      return copy_nat(bi[2],0,_ci_)}
    function sys_big_int_of_nat(nat,off,len)
     {var
       length=num_digits_nat(nat,off,len),
       _cg_=copy_nat(nat,off,length),
       _ch_=is_zero_nat(nat,off,length)?0:1;
      return [0,_ch_,_cg_]}
    function big_int_of_nat(nat)
     {return sys_big_int_of_nat(nat,0,length_nat(nat))}
    function string_of_big_int(bi)
     {if(-1 === bi[1])
       {var _cf_=string_of_nat(bi[2]);return caml_call2(Stdlib[28],cst,_cf_)}
      return string_of_nat(bi[2])}
    function sys_big_int_of_string_aux(s,ofs,len,sgn,base)
     {if(len < 1)caml_call1(Stdlib[2],cst_sys_big_int_of_string);
      var n=sys_nat_of_string(base,s,ofs,len);
      return is_zero_nat(n,0,length_nat(n))?zero_big_int:[0,sgn,n]}
    function sys_big_int_of_string_base(s,ofs,len,sgn)
     {if(len < 1)caml_call1(Stdlib[2],cst_sys_big_int_of_string$0);
      if(2 <= len)
       {var
         match=caml_string_get(s,ofs),
         match$0=caml_string_get(s,ofs + 1 | 0);
        if(48 === match)
         {var switch$0=0;
          if(89 <= match$0)
           {if(98 === match$0)
             switch$0 = 3;
            else
             if(111 === match$0)
              switch$0 = 2;
             else
              if(120 === match$0)switch$0 = 1}
          else
           if(66 === match$0)
            switch$0 = 3;
           else
            if(79 === match$0)switch$0 = 2;else if(88 <= match$0)switch$0 = 1;
          switch(switch$0)
           {case 0:break;
            case 1:
             return sys_big_int_of_string_aux
                     (s,ofs + 2 | 0,len - 2 | 0,sgn,16);
            case 2:
             return sys_big_int_of_string_aux(s,ofs + 2 | 0,len - 2 | 0,sgn,8);
            default:
             return sys_big_int_of_string_aux(s,ofs + 2 | 0,len - 2 | 0,sgn,2)}}
        return sys_big_int_of_string_aux(s,ofs,len,sgn,10)}
      return sys_big_int_of_string_aux(s,ofs,len,sgn,10)}
    function sys_big_int_of_string(s,ofs,len)
     {if(len < 1)caml_call1(Stdlib[2],cst_sys_big_int_of_string$1);
      var match=caml_string_get(s,ofs),switcher=match - 43 | 0;
      if(! (2 < switcher >>> 0))
       switch(switcher)
        {case 0:
          return sys_big_int_of_string_base(s,ofs + 1 | 0,len - 1 | 0,1);
         case 1:break;
         default:
          return sys_big_int_of_string_base(s,ofs + 1 | 0,len - 1 | 0,-1)}
      return sys_big_int_of_string_base(s,ofs,len,1)}
    function big_int_of_string(s)
     {return sys_big_int_of_string(s,0,caml_ml_string_length(s))}
    function big_int_of_string_opt(s)
     {try
       {var _cd_=[0,big_int_of_string(s)];return _cd_}
      catch(_ce_)
       {_ce_ = caml_wrap_exception(_ce_);
        if(_ce_[1] === Stdlib[7])return 0;
        throw _ce_}}
    function power_int_positive_int(i,n)
     {var match=sign_int(n);
      if(-1 === match)return caml_call1(Stdlib[1],cst_power_int_positive_int);
      if(0 === match)return unit_big_int;
      var
       nat=power_base_int(caml_call1(Stdlib[18],i),n),
       _cc_=0 <= i?sign_int(i):0 === (n & 1)?1:-1;
      return [0,_cc_,nat]}
    function power_big_int_positive_int(bi,n)
     {var match=sign_int(n);
      if(-1 === match)
       return caml_call1(Stdlib[1],cst_power_big_int_positive_int);
      if(0 === match)return unit_big_int;
      var
       bi_len=num_digits_big_int(bi),
       res_len=caml_mul(bi_len,n),
       res=make_nat(res_len),
       res2=make_nat(res_len),
       l=num_bits_int(n) - 2 | 0;
      blit_nat(res,0,bi[2],0,bi_len);
      if(! (l < 0))
       {var i=l;
        for(;;)
         {var
           len=num_digits_nat(res,0,res_len),
           len2=caml_call2(Stdlib[16],res_len,2 * len | 0);
          set_to_zero_nat(res2,0,len2);
          square_nat(res2,0,len2,res,0,len);
          if(0 < (n & 1 << i))
           {var lenp=caml_call2(Stdlib[16],res_len,len2 + bi_len | 0);
            set_to_zero_nat(res,0,lenp);
            mult_nat(res,0,lenp,res2,0,len2,bi[2],0,bi_len)}
          else
           blit_nat(res,0,res2,0,len2);
          var _cb_=i - 1 | 0;
          if(0 !== i){var i=_cb_;continue}
          break}}
      var _ca_=0 <= bi[1]?bi[1]:0 === (n & 1)?1:-1;
      return [0,_ca_,res]}
    function power_int_positive_big_int(i$0,bi)
     {var match$1=bi[1];
      if(-1 === match$1)
       return caml_call1(Stdlib[1],cst_power_int_positive_big_int);
      if(0 === match$1)return unit_big_int;
      var
       len$0=num_digits_big_int(bi),
       _b__=bi[2],
       base=caml_call1(Stdlib[18],i$0),
       off=0;
      if(0 === base)
       var nat=nat_of_int(0);
      else
       {var switch$0=0;
        if(is_zero_nat(_b__,off,len$0) || 1 === base)
         switch$0 = 1;
        else
         {var
           power_base=make_nat(_a_ + 1 | 0),
           match=make_power_base(base,power_base),
           pmax=match[1],
           _b8_=big_int_of_int(pmax + 1 | 0),
           match$0=quomod_big_int(sys_big_int_of_nat(_b__,off,len$0),_b8_),
           y=match$0[2],
           x=match$0[1],
           rem=int_of_big_int(y),
           n=int_of_big_int(x);
          if(0 === n)
           var nat=copy_nat(power_base,rem - 1 | 0,1);
          else
           {var
             res=make_nat(n),
             res2=make_nat(n + 1 | 0),
             l=num_bits_int(n) - 2 | 0;
            blit_nat(res,0,power_base,pmax,1);
            if(! (l < 0))
             {var i=l;
              for(;;)
               {var
                 len=num_digits_nat(res,0,n),
                 len2=caml_call2(Stdlib[16],n,2 * len | 0),
                 succ_len2=len2 + 1 | 0;
                square_nat(res2,0,len2,res,0,len);
                if(0 < (n & 1 << i))
                 {set_to_zero_nat(res,0,len);
                  mult_digit_nat(res,0,succ_len2,res2,0,len2,power_base,pmax)}
                else
                 blit_nat(res,0,res2,0,len2);
                set_to_zero_nat(res2,0,len2);
                var _b9_=i - 1 | 0;
                if(0 !== i){var i=_b9_;continue}
                break}}
            var
             nat=
              0 < rem
               ?(mult_digit_nat
                  (res2,0,n + 1 | 0,res,0,n,power_base,rem - 1 | 0),
                 res2)
               :res}}
        if(switch$0)var nat=nat_of_int(1)}
      var _b$_=0 <= i$0?sign_int(i$0):runtime.is_digit_odd(bi[2],0)?-1:1;
      return [0,_b$_,nat]}
    function power_big_int_positive_big_int(bi1,bi2)
     {var match=bi2[1];
      if(-1 === match)
       return caml_call1(Stdlib[1],cst_power_big_int_positive_big);
      if(0 === match)return unit_big_int;
      try
       {var _b5_=power_big_int_positive_int(bi1,int_of_big_int(bi2));
        return _b5_}
      catch(_b6_)
       {_b6_ = caml_wrap_exception(_b6_);
        if(_b6_[1] === Stdlib[7])
         try
          {var _b4_=power_int_positive_big_int(int_of_big_int(bi1),bi2);
           return _b4_}
         catch(_b7_)
          {_b7_ = caml_wrap_exception(_b7_);
           if(_b7_[1] === Stdlib[7])throw Stdlib[9];
           throw _b7_}
        throw _b6_}}
    function base_power_big_int(base,n,bi)
     {var match=sign_int(n);
      if(-1 === match)
       {var
         nat=power_base_int(base,- n | 0),
         len_nat=num_digits_nat(nat,0,length_nat(nat)),
         len_bi=num_digits_big_int(bi);
        if(len_bi < len_nat)
         return caml_call1(Stdlib[1],cst_base_power_big_int);
        if
         (len_bi
          ===
          len_nat
          &&
          -1
          ===
          runtime.compare_digits_nat(bi[2],len_bi,nat,len_nat))
         return caml_call1(Stdlib[1],cst_base_power_big_int$0);
        var copy=create_nat(len_bi + 1 | 0);
        blit_nat(copy,0,bi[2],0,len_bi);
        set_digit_nat(copy,len_bi,0);
        div_nat(copy,0,len_bi + 1 | 0,nat,0,len_nat);
        if(is_zero_nat(copy,0,len_nat))
         {var _b2_=copy_nat(copy,len_nat,1);return [0,bi[1],_b2_]}
        return caml_call1(Stdlib[1],cst_base_power_big_int$1)}
      if(0 === match)return bi;
      var
       nat$0=power_base_int(base,n),
       len_nat$0=num_digits_nat(nat$0,0,length_nat(nat$0)),
       len_bi$0=num_digits_big_int(bi),
       new_len=len_bi$0 + len_nat$0 | 0,
       nat$1=make_nat(new_len);
      if(len_nat$0 < len_bi$0)
       mult_nat(nat$1,0,new_len,bi[2],0,len_bi$0,nat$0,0,len_nat$0);
      else
       mult_nat(nat$1,0,new_len,nat$0,0,len_nat$0,bi[2],0,len_bi$0);
      if(is_zero_nat(nat$1,0,new_len))return zero_big_int;
      var _b3_=bi[1];
      if(1 !== _b3_ && -1 !== _b3_)
       {var switch$0=0;
        if
         (0
          !==
          _b3_
          ||
          !
          is_zero_nat(nat$1,0,num_digits_nat(nat$1,0,length_nat(nat$1))))
         switch$0 = 1;
        if(switch$0)return caml_call1(Stdlib[1],cst_create_big_int)}
      return [0,_b3_,nat$1]}
    function sqrt_big_int(bi)
     {var _b0_=bi[1];
      if(-1 === _b0_)return caml_call1(Stdlib[1],cst_sqrt_big_int);
      if(0 === _b0_)return zero_big_int;
      var _b1_=num_digits_big_int(bi);
      return [0,1,sqrt_nat(bi[2],0,_b1_)]}
    function square_big_int(bi)
     {if(0 === bi[1])return zero_big_int;
      var
       len_bi=num_digits_big_int(bi),
       len_res=2 * len_bi | 0,
       res=make_nat(len_res);
      square_nat(res,0,len_res,bi[2],0,len_bi);
      return [0,1,res]}
    function round_futur_last_digit(s,off_set,length)
     {var l=(length + off_set | 0) - 1 | 0;
      if(53 <= caml_bytes_get(s,l))
       {var l$2=l - 1 | 0,l$0=l$2;
        for(;;)
         {if(l$0 < off_set)return 1;
          var current_char=caml_bytes_get(s,l$0);
          if(57 === current_char)
           {caml_bytes_set(s,l$0,48);var l$1=l$0 - 1 | 0,l$0=l$1;continue}
          caml_bytes_set
           (s,l$0,caml_call1(Stdlib_char[1],current_char + 1 | 0));
          return 0}}
      return 0}
    function approx_big_int(prec,bi)
     {var
       len_bi=num_digits_big_int(bi),
       _bK_=big_int_of_string(cst_100000000),
       _bL_=big_int_of_string(cst_963295986),
       _bM_=
        int_of_big_int
         (add_int_big_int
           (- prec | 0,
            div_big_int
             (mult_big_int(big_int_of_int(len_bi - 1 | 0),_bL_),_bK_))),
       n=caml_call2(Stdlib[17],0,_bM_),
       _bN_=string_of_big_int(div_big_int(bi,power_int_positive_int(10,n))),
       s=caml_call1(Stdlib_bytes[5],_bN_);
      if(45 === caml_bytes_get(s,0))
       var off=1,sign$0=cst$0;
      else
       var off=0,sign$0=sign;
      if(round_futur_last_digit(s,off,prec + 1 | 0))
       {var
         _bO_=
          caml_call1
           (Stdlib[33],((n + 1 | 0) - off | 0) + caml_ml_bytes_length(s) | 0),
         _bP_=caml_call2(Stdlib[28],cst_e,_bO_),
         _bQ_=caml_call2(Stdlib_string[1],prec,48),
         _bR_=caml_call2(Stdlib[28],_bQ_,_bP_),
         _bS_=caml_call2(Stdlib[28],cst_1,_bR_);
        return caml_call2(Stdlib[28],sign$0,_bS_)}
      var
       _bT_=
        caml_call1
         (Stdlib[33],(n - (off + 1 | 0) | 0) + caml_ml_bytes_length(s) | 0),
       _bU_=caml_call2(Stdlib[28],cst_e$0,_bT_),
       _bV_=caml_call3(Stdlib_bytes[8],s,off + 1 | 0,prec - 1 | 0),
       _bW_=caml_call2(Stdlib[28],_bV_,_bU_),
       _bX_=caml_call2(Stdlib[28],cst$1,_bW_),
       _bY_=caml_call3(Stdlib_bytes[8],s,off,1),
       _bZ_=caml_call2(Stdlib[28],_bY_,_bX_);
      return caml_call2(Stdlib[28],sign$0,_bZ_)}
    function shift_left_big_int(bi,n)
     {if(0 <= n)
       {if(0 === n)return bi;
        if(0 === bi[1])return bi;
        var
         size_bi=num_digits_big_int(bi),
         size_res=size_bi + caml_div((n + _a_ | 0) - 1 | 0,_a_) | 0,
         res=create_nat(size_res),
         ndigits=caml_div(n,_a_);
        set_to_zero_nat(res,0,ndigits);
        blit_nat(res,ndigits,bi[2],0,size_bi);
        var nbits=caml_mod(n,_a_);
        if(0 < nbits)
         runtime.shift_left_nat
          (res,ndigits,size_bi,res,ndigits + size_bi | 0,nbits);
        return [0,bi[1],res]}
      return caml_call1(Stdlib[1],cst_shift_left_big_int)}
    function shift_right_towards_zero_big_i(bi,n)
     {if(0 <= n)
       {if(0 === n)return bi;
        if(0 === bi[1])return bi;
        var
         size_bi=num_digits_big_int(bi),
         ndigits=caml_div(n,_a_),
         nbits=caml_mod(n,_a_);
        if(size_bi <= ndigits)return zero_big_int;
        var size_res=size_bi - ndigits | 0,res=create_nat(size_res);
        blit_nat(res,0,bi[2],ndigits,size_res);
        if(0 < nbits)
         {var tmp=create_nat(1);shift_right_nat(res,0,size_res,tmp,0,nbits)}
        return is_zero_nat(res,0,size_res)?zero_big_int:[0,bi[1],res]}
      return caml_call1(Stdlib[1],cst_shift_right_towards_zero_b)}
    function shift_right_big_int(bi,n)
     {if(0 <= n)
       {if(0 <= bi[1])return shift_right_towards_zero_big_i(bi,n);
        if(0 <= n)
         if(0 === n)
          var _bJ_=zero_big_int;
         else
          {var
            idx=caml_div(n,_a_),
            size_res=idx + 1 | 0,
            res=make_nat(size_res);
           set_digit_nat_native(res,idx,1 << caml_mod(n,_a_));
           decr_nat(res,0,size_res,0);
           var _bJ_=[0,1,res]}
        else
         var _bJ_=caml_call1(Stdlib[1],cst_two_power_m1_big_int);
        return shift_right_towards_zero_big_i(sub_big_int(bi,_bJ_),n)}
      return caml_call1(Stdlib[1],cst_shift_right_big_int)}
    function extract_big_int(bi,ofs,n)
     {if(0 <= ofs && 0 <= n)
       {if(0 === bi[1])return bi;
        var
         size_bi=num_digits_big_int(bi),
         size_res=caml_div((n + _a_ | 0) - 1 | 0,_a_),
         ndigits=caml_div(ofs,_a_),
         nbits=caml_mod(ofs,_a_),
         res=make_nat(size_res);
        if(ndigits < size_bi)
         {var _bE_=caml_call2(Stdlib[16],size_res,size_bi - ndigits | 0);
          blit_nat(res,0,bi[2],ndigits,_bE_)}
        if(bi[1] < 0)
         {complement_nat(res,0,size_res);
          var i=0;
          for(;;)
           {var _bF_=ndigits <= i?1:0;
            if(_bF_)
             var _bG_=_bF_;
            else
             {var _bH_=size_bi <= i?1:0;
              if(_bH_)
               var _bG_=_bH_;
              else
               {var _bI_=is_digit_zero(bi[2],i);
                if(_bI_){var i$0=i + 1 | 0,i=i$0;continue}
                var _bG_=_bI_}}
            if(_bG_)incr_nat(res,0,size_res,1);
            break}}
        if(0 < nbits)
         {var tmp=create_nat(1);shift_right_nat(res,0,size_res,tmp,0,nbits)}
        var n$0=caml_mod(n,_a_);
        if(0 < n$0)
         {var tmp$0=create_nat(1);
          set_digit_nat_native(tmp$0,0,-1 >>> (_a_ - n$0 | 0) | 0);
          land_digit_nat(res,size_res - 1 | 0,tmp$0,0)}
        return is_zero_nat(res,0,size_res)?zero_big_int:[0,1,res]}
      return caml_call1(Stdlib[1],cst_extract_big_int)}
    function and_big_int(a,b)
     {if(0 <= a[1] && 0 <= b[1])
       {if(0 !== a[1] && 0 !== b[1])
         {var
           size_a=num_digits_big_int(a),
           size_b=num_digits_big_int(b),
           size_res=caml_call2(Stdlib[16],size_a,size_b),
           res=create_nat(size_res);
          blit_nat(res,0,a[2],0,size_res);
          var _bC_=size_res - 1 | 0,_bB_=0;
          if(! (_bC_ < 0))
           {var i=_bB_;
            for(;;)
             {land_digit_nat(res,i,b[2],i);
              var _bD_=i + 1 | 0;
              if(_bC_ !== i){var i=_bD_;continue}
              break}}
          return is_zero_nat(res,0,size_res)?zero_big_int:[0,1,res]}
        return zero_big_int}
      return caml_call1(Stdlib[1],cst_and_big_int)}
    function or_big_int(a,b)
     {if(0 <= a[1] && 0 <= b[1])
       {if(0 === a[1])return b;
        if(0 === b[1])return a;
        var
         size_a=num_digits_big_int(a),
         size_b=num_digits_big_int(b),
         size_res=caml_call2(Stdlib[17],size_a,size_b),
         res=create_nat(size_res),
         or_aux=
          function(a,b,size_b)
           {blit_nat(res,0,a[2],0,size_res);
            var _bz_=size_b - 1 | 0,_by_=0;
            if(! (_bz_ < 0))
             {var i=_by_;
              for(;;)
               {runtime.lor_digit_nat(res,i,b[2],i);
                var _bA_=i + 1 | 0;
                if(_bz_ !== i){var i=_bA_;continue}
                break}}
            return 0};
        if(size_b <= size_a)or_aux(a,b,size_b);else or_aux(b,a,size_a);
        return is_zero_nat(res,0,size_res)?zero_big_int:[0,1,res]}
      return caml_call1(Stdlib[1],cst_or_big_int)}
    function xor_big_int(a,b)
     {if(0 <= a[1] && 0 <= b[1])
       {if(0 === a[1])return b;
        if(0 === b[1])return a;
        var
         size_a=num_digits_big_int(a),
         size_b=num_digits_big_int(b),
         size_res=caml_call2(Stdlib[17],size_a,size_b),
         res=create_nat(size_res),
         xor_aux=
          function(a,b,size_b)
           {blit_nat(res,0,a[2],0,size_res);
            var _bw_=size_b - 1 | 0,_bv_=0;
            if(! (_bw_ < 0))
             {var i=_bv_;
              for(;;)
               {runtime.lxor_digit_nat(res,i,b[2],i);
                var _bx_=i + 1 | 0;
                if(_bw_ !== i){var i=_bx_;continue}
                break}}
            return 0};
        if(size_b <= size_a)xor_aux(a,b,size_b);else xor_aux(b,a,size_a);
        return is_zero_nat(res,0,size_res)?zero_big_int:[0,1,res]}
      return caml_call1(Stdlib[1],cst_xor_big_int)}
    function round_big_int_to_float(x,exact)
     {var n=num_bits_big_int(x),_bt_=55 <= n?1:0,_bu_=_bt_?n <= 63?1:0:_bt_;
      if(_bu_)
       {var m=int64_of_big_int(x),m$0=exact?m:caml_int64_or(m,_k_);
        return caml_int64_to_float(m$0)}
      throw [0,Assert_failure,_l_]}
    function float_of_big_int(x)
     {var n=num_bits_big_int(x);
      if(63 < n)
       {var
         n$0=n - 55 | 0,
         top=shift_right_big_int(x,n$0),
         exact=eq_big_int(x,shift_left_big_int(top,n$0));
        return caml_ldexp_float(round_big_int_to_float(top,exact),n$0)}
      return caml_int64_to_float(int64_of_big_int(x))}
    var
     Big_int=
      [0,
       zero_big_int,
       unit_big_int,
       minus_big_int,
       abs_big_int,
       add_big_int,
       succ_big_int,
       add_int_big_int,
       sub_big_int,
       pred_big_int,
       mult_big_int,
       mult_int_big_int,
       square_big_int,
       sqrt_big_int,
       quomod_big_int,
       div_big_int,
       mod_big_int,
       gcd_big_int,
       power_int_positive_int,
       power_big_int_positive_int,
       power_int_positive_big_int,
       power_big_int_positive_big_int,
       sign_big_int,
       compare_big_int,
       eq_big_int,
       le_big_int,
       ge_big_int,
       lt_big_int,
       gt_big_int,
       max_big_int,
       min_big_int,
       num_digits_big_int,
       num_bits_big_int,
       string_of_big_int,
       big_int_of_string,
       big_int_of_string_opt,
       big_int_of_int,
       is_int_big_int,
       int_of_big_int,
       int_of_big_int_opt,
       big_int_of_int32,
       big_int_of_nativeint,
       big_int_of_int64,
       int32_of_big_int,
       int32_of_big_int_opt,
       nativeint_of_big_int,
       nativeint_of_big_int_opt,
       int64_of_big_int,
       int64_of_big_int_opt,
       float_of_big_int,
       and_big_int,
       or_big_int,
       xor_big_int,
       shift_left_big_int,
       shift_right_big_int,
       shift_right_towards_zero_big_i,
       extract_big_int,
       nat_of_big_int,
       big_int_of_nat,
       base_power_big_int,
       sys_big_int_of_string,
       round_futur_last_digit,
       approx_big_int,
       round_big_int_to_float];
    caml_register_global(130,Big_int,"Big_int");
    var
     error_when_null_denominator_fl=[0,1],
     normalize_ratio_flag=[0,0],
     normalize_ratio_when_printing_=[0,1],
     floating_precision=[0,12],
     approx_printing_flag=[0,0],
     Arith_flags=
      [0,
       error_when_null_denominator_fl,
       normalize_ratio_flag,
       normalize_ratio_when_printing_,
       floating_precision,
       approx_printing_flag];
    caml_register_global(131,Arith_flags,"Arith_flags");
    function failwith_zero(name)
     {if(0 === caml_ml_string_length(name))
       var s$0=s;
      else
       var
        _bs_=caml_call2(Stdlib[28],cst$2,s),
        s$0=caml_call2(Stdlib[28],name,_bs_);
      return caml_call1(Stdlib[2],s$0)}
    function numerator_ratio(r){return r[1]}
    function denominator_ratio(r){return r[2]}
    function null_denominator(r){return 0 === r[2][1]?1:0}
    function verify_null_denominator(r)
     {return 0 === r[2][1]
              ?error_when_null_denominator_fl[1]?failwith_zero(cst$3):1
              :0}
    function sign_ratio(r){return r[1][1]}
    function normalize_ratio(r)
     {if(r[3])return r;
      if(verify_null_denominator(r))
       {r[1] = big_int_of_int(r[1][1]);r[3] = 1;return r}
      var p=gcd_big_int(r[1],r[2]);
      return eq_big_int(p,unit_big_int)
              ?(r[3] = 1,r)
              :(r[1]
                =
                div_big_int(r[1],p),
                r[2]
                =
                div_big_int(r[2],p),
                r[3]
                =
                1,
                r)}
    function cautious_normalize_ratio(r)
     {return normalize_ratio_flag[1]?normalize_ratio(r):r}
    function cautious_normalize_ratio_when_(r)
     {return normalize_ratio_when_printing_[1]?normalize_ratio(r):r}
    function create_ratio(bi1,bi2)
     {var match=bi2[1];
      if(-1 === match)
       {var _br_=minus_big_int(bi2);
        return cautious_normalize_ratio([0,minus_big_int(bi1),_br_,0])}
      return 0 === match
              ?error_when_null_denominator_fl[1]
                ?failwith_zero(cst_create_ratio)
                :cautious_normalize_ratio([0,bi1,bi2,0])
              :cautious_normalize_ratio([0,bi1,bi2,0])}
    function create_normalized_ratio(bi1,bi2)
     {var match=bi2[1];
      if(-1 === match)
       {var _bq_=minus_big_int(bi2);return [0,minus_big_int(bi1),_bq_,1]}
      return 0 === match
              ?error_when_null_denominator_fl[1]
                ?failwith_zero(cst_create_normalized_ratio)
                :[0,bi1,bi2,1]
              :[0,bi1,bi2,1]}
    function is_normalized_ratio(r){return r[3]}
    function report_sign_ratio(r,bi)
     {return -1 === sign_ratio(r)?minus_big_int(bi):bi}
    function abs_ratio(r)
     {var _bo_=r[3],_bp_=r[2];return [0,abs_big_int(r[1]),_bp_,_bo_]}
    function is_integer_ratio(r)
     {return eq_big_int(normalize_ratio(r)[2],unit_big_int)}
    function add_ratio(r1,r2)
     {if(normalize_ratio_flag[1])
       {var
         _bh_=normalize_ratio(r2)[2],
         p=gcd_big_int(normalize_ratio(r1)[2],_bh_);
        if(eq_big_int(p,unit_big_int))
         {var _bi_=mult_big_int(r1[2],r2[2]),_bj_=mult_big_int(r2[1],r1[2]);
          return [0,add_big_int(mult_big_int(r1[1],r2[2]),_bj_),_bi_,1]}
        var
         d1=div_big_int(r1[2],p),
         d2=div_big_int(r2[2],p),
         _bk_=mult_big_int(d1,r2[1]),
         n=add_big_int(mult_big_int(r1[1],d2),_bk_),
         p$0=gcd_big_int(n,p),
         _bl_=mult_big_int(d1,div_big_int(r2[2],p$0));
        return [0,div_big_int(n,p$0),_bl_,1]}
      var _bm_=mult_big_int(r1[2],r2[2]),_bn_=mult_big_int(r1[2],r2[1]);
      return [0,add_big_int(mult_big_int(r1[1],r2[2]),_bn_),_bm_,0]}
    function minus_ratio(r)
     {var _bf_=r[3],_bg_=r[2];return [0,minus_big_int(r[1]),_bg_,_bf_]}
    function add_int_ratio(i,r)
     {cautious_normalize_ratio(r);
      var _bc_=r[3],_bd_=r[2],_be_=r[1];
      return [0,add_big_int(mult_int_big_int(i,r[2]),_be_),_bd_,_bc_]}
    function add_big_int_ratio(bi,r)
     {cautious_normalize_ratio(r);
      var _a$_=r[3],_ba_=r[2],_bb_=r[1];
      return [0,add_big_int(mult_big_int(bi,r[2]),_bb_),_ba_,_a$_]}
    function sub_ratio(r1,r2){return add_ratio(r1,minus_ratio(r2))}
    function mult_ratio(r1,r2)
     {if(normalize_ratio_flag[1])
       {var
         _a6_=normalize_ratio(r2)[2],
         p1=gcd_big_int(normalize_ratio(r1)[1],_a6_),
         p2=gcd_big_int(r2[1],r1[2]);
        if(eq_big_int(p1,unit_big_int))
         var _a8_=r2[2],_a7_=r1[1];
        else
         var d2=div_big_int(r2[2],p1),_a8_=d2,_a7_=div_big_int(r1[1],p1);
        if(eq_big_int(p2,unit_big_int))
         var d1=r1[2],n2=r2[1];
        else
         var
          d1$0=div_big_int(r1[2],p2),
          n2$0=div_big_int(r2[1],p2),
          d1=d1$0,
          n2=n2$0;
        var _a9_=mult_big_int(d1,_a8_);
        return [0,mult_big_int(_a7_,n2),_a9_,1]}
      var _a__=mult_big_int(r1[2],r2[2]);
      return [0,mult_big_int(r1[1],r2[1]),_a__,0]}
    function mult_int_ratio(i,r)
     {if(normalize_ratio_flag[1])
       {var _a0_=big_int_of_int(i),p=gcd_big_int(normalize_ratio(r)[2],_a0_);
        if(eq_big_int(p,unit_big_int))
         {var _a1_=r[2],_a2_=r[1];
          return [0,mult_big_int(big_int_of_int(i),_a2_),_a1_,1]}
        var _a3_=div_big_int(r[2],p),_a4_=r[1];
        return [0,mult_big_int(div_big_int(big_int_of_int(i),p),_a4_),_a3_,1]}
      var _a5_=r[2];
      return [0,mult_int_big_int(i,r[1]),_a5_,0]}
    function mult_big_int_ratio(bi,r)
     {if(normalize_ratio_flag[1])
       {var p=gcd_big_int(normalize_ratio(r)[2],bi);
        if(eq_big_int(p,unit_big_int))
         {var _aW_=r[2];return [0,mult_big_int(bi,r[1]),_aW_,1]}
        var _aX_=div_big_int(r[2],p),_aY_=r[1];
        return [0,mult_big_int(div_big_int(bi,p),_aY_),_aX_,1]}
      var _aZ_=r[2];
      return [0,mult_big_int(bi,r[1]),_aZ_,0]}
    function square_ratio(r)
     {cautious_normalize_ratio(r);
      var _aU_=r[3],_aV_=square_big_int(r[2]);
      return [0,square_big_int(r[1]),_aV_,_aU_]}
    function inverse_ratio(r)
     {if(error_when_null_denominator_fl[1] && 0 === r[1][1])
       return failwith_zero(cst_inverse_ratio);
      var _aS_=r[3],_aT_=abs_big_int(r[1]);
      return [0,report_sign_ratio(r,r[2]),_aT_,_aS_]}
    function div_ratio(r1,r2){return mult_ratio(r1,inverse_ratio(r2))}
    function integer_ratio(r)
     {if(null_denominator(r))return failwith_zero(cst_integer_ratio);
      if(0 === sign_ratio(r))return zero_big_int;
      var _aR_=abs_big_int(r[2]);
      return report_sign_ratio(r,div_big_int(abs_big_int(r[1]),_aR_))}
    function floor_ratio(r)
     {verify_null_denominator(r);return div_big_int(r[1],r[2])}
    function round_ratio(r)
     {verify_null_denominator(r);
      var
       abs_num=abs_big_int(r[1]),
       bi=div_big_int(abs_num,r[2]),
       _aQ_=r[2],
       bi$0=
        -1
         ===
         sub_big_int
           (mult_int_big_int(2,sub_big_int(abs_num,mult_big_int(r[2],bi))),
            _aQ_)
          [1]
         ?bi
         :succ_big_int(bi);
      return report_sign_ratio(r,bi$0)}
    function ceiling_ratio(r)
     {return is_integer_ratio(r)?r[1]:succ_big_int(floor_ratio(r))}
    function eq_ratio(r1,r2)
     {normalize_ratio(r1);
      normalize_ratio(r2);
      var _aP_=eq_big_int(r1[1],r2[1]);
      return _aP_?eq_big_int(r1[2],r2[2]):_aP_}
    function compare_ratio(r1,r2)
     {if(verify_null_denominator(r1))
       {var sign_num_r1=r1[1][1];
        if(verify_null_denominator(r2))
         {var sign_num_r2=r2[1][1];
          if(1 === sign_num_r1 && -1 === sign_num_r2)return 1;
          if(-1 === sign_num_r1 && 1 === sign_num_r2)return -1;
          return 0}
        return sign_num_r1}
      if(verify_null_denominator(r2))return - r2[1][1] | 0;
      var match=compare_int(r1[1][1],r2[1][1]),switcher=match + 1 | 0;
      if(! (2 < switcher >>> 0))
       switch(switcher){case 0:return -1;case 1:break;default:return 1}
      if(eq_big_int(r1[2],r2[2]))return compare_big_int(r1[1],r2[1]);
      var _aO_=mult_big_int(r1[2],r2[1]);
      return compare_big_int(mult_big_int(r1[1],r2[2]),_aO_)}
    function lt_ratio(r1,r2){return compare_ratio(r1,r2) < 0?1:0}
    function le_ratio(r1,r2){return compare_ratio(r1,r2) <= 0?1:0}
    function gt_ratio(r1,r2){return 0 < compare_ratio(r1,r2)?1:0}
    function ge_ratio(r1,r2){return 0 <= compare_ratio(r1,r2)?1:0}
    function max_ratio(r1,r2){return lt_ratio(r1,r2)?r2:r1}
    function min_ratio(r1,r2){return gt_ratio(r1,r2)?r2:r1}
    function eq_big_int_ratio(bi,r)
     {var _aN_=is_integer_ratio(r);return _aN_?eq_big_int(bi,r[1]):_aN_}
    function compare_big_int_ratio(bi,r)
     {normalize_ratio(r);
      if(verify_null_denominator(r))return - r[1][1] | 0;
      var _aM_=r[1];
      return compare_big_int(mult_big_int(bi,r[2]),_aM_)}
    function lt_big_int_ratio(bi,r)
     {return compare_big_int_ratio(bi,r) < 0?1:0}
    function le_big_int_ratio(bi,r)
     {return compare_big_int_ratio(bi,r) <= 0?1:0}
    function gt_big_int_ratio(bi,r)
     {return 0 < compare_big_int_ratio(bi,r)?1:0}
    function ge_big_int_ratio(bi,r)
     {return 0 <= compare_big_int_ratio(bi,r)?1:0}
    function int_of_ratio(r)
     {if(is_integer_ratio(r) && is_int_big_int(r[1]))
       return int_of_big_int(r[1]);
      return caml_call1(Stdlib[2],cst_integer_argument_required)}
    function ratio_of_int(i){return [0,big_int_of_int(i),unit_big_int,1]}
    function ratio_of_nat(nat){return [0,big_int_of_nat(nat),unit_big_int,1]}
    function nat_of_ratio(r)
     {normalize_ratio(r);
      return is_integer_ratio(r)
              ?-1 < r[1][1]
                ?nat_of_big_int(r[1])
                :caml_call1(Stdlib[2],cst_nat_of_ratio)
              :caml_call1(Stdlib[2],cst_nat_of_ratio$0)}
    function ratio_of_big_int(bi){return [0,bi,unit_big_int,1]}
    function big_int_of_ratio(r)
     {normalize_ratio(r);
      return is_integer_ratio(r)
              ?r[1]
              :caml_call1(Stdlib[2],cst_big_int_of_ratio)}
    function div_int_ratio(i,r)
     {verify_null_denominator(r);return mult_int_ratio(i,inverse_ratio(r))}
    function div_ratio_int(r,i){return div_ratio(r,ratio_of_int(i))}
    function div_big_int_ratio(bi,r)
     {verify_null_denominator(r);
      return mult_big_int_ratio(bi,inverse_ratio(r))}
    function div_ratio_big_int(r,bi){return div_ratio(r,ratio_of_big_int(bi))}
    function approx_ratio_fix(n,r)
     {if(null_denominator(r))return failwith_zero(cst_approx_ratio_fix);
      var sign_r=sign_ratio(r);
      if(0 === sign_r)return cst_0;
      if(0 <= n)
       {var
         _aG_=r[2],
         s1=
          string_of_nat
           (nat_of_big_int
             (div_big_int
               (base_power_big_int(10,n + 1 | 0,abs_big_int(r[1])),_aG_))),
         s1$0=caml_call1(Stdlib_bytes[5],s1);
        if(round_futur_last_digit(s1$0,0,caml_ml_bytes_length(s1$0)))
         var
          _aH_=caml_call1(Stdlib_bytes[5],cst_1$0),
          s2=caml_call2(Stdlib_bytes[14],_aH_,s1$0);
        else
         var s2=s1$0;
        var l2=caml_ml_bytes_length(s2) - 1 | 0;
        if(n < l2)
         {var
           s=caml_call2(Stdlib_bytes[1],l2 + 2 | 0,48),
           _aI_=-1 === sign_r?45:43;
          caml_bytes_set(s,0,_aI_);
          caml_call5(Stdlib_bytes[11],s2,0,s,1,l2 - n | 0);
          caml_bytes_set(s,(l2 - n | 0) + 1 | 0,46);
          caml_call5(Stdlib_bytes[11],s2,l2 - n | 0,s,(l2 - n | 0) + 2 | 0,n);
          return caml_call1(Stdlib_bytes[42],s)}
        var
         s$0=caml_call2(Stdlib_bytes[1],n + 3 | 0,48),
         _aJ_=-1 === sign_r?45:43;
        caml_bytes_set(s$0,0,_aJ_);
        caml_bytes_set(s$0,2,46);
        caml_call5(Stdlib_bytes[11],s2,0,s$0,(n + 3 | 0) - l2 | 0,l2);
        return caml_call1(Stdlib_bytes[42],s$0)}
      var
       _aK_=base_power_big_int(10,- n | 0,r[2]),
       s$1=string_of_big_int(div_big_int(abs_big_int(r[1]),_aK_)),
       len=caml_ml_string_length(s$1) + 1 | 0,
       s$2=caml_call2(Stdlib_bytes[1],len,48),
       _aL_=-1 === sign_r?45:43;
      caml_bytes_set(s$2,0,_aL_);
      caml_call5(Stdlib_string[32],s$1,0,s$2,1,len - 1 | 0);
      return caml_call1(Stdlib_bytes[42],s$2)}
    function num_decimal_digits_int(n)
     {return caml_ml_string_length(caml_call1(Stdlib[33],n))}
    function approx_ratio_exp(n,r)
     {if(null_denominator(r))return failwith_zero(cst_approx_ratio_exp);
      if(0 < n)
       {var sign_r=sign_ratio(r),i$4=[0,n + 3 | 0];
        if(0 === sign_r)
         {var _ar_=[0,cst_0$0,[0,caml_call2(Stdlib_string[1],n,48),_m_]];
          return caml_call2(Stdlib_string[3],cst$4,_ar_)}
        var r$0=abs_ratio(r);
        cautious_normalize_ratio(r$0);
        if(null_denominator(r$0))
         var msd=failwith_zero(cst_msd_ratio);
        else
         if(0 === r$0[1][1])
          var msd=0;
         else
          {var
            s1=string_of_big_int(r$0[1]),
            s=string_of_big_int(r$0[2]),
            size_num=caml_ml_string_length(s1),
            lim=caml_ml_string_length(s),
            i$3=caml_call2(Stdlib[16],size_num,lim),
            m=size_num - lim | 0,
            i=0;
           for(;;)
            {if(i$3 <= i)
              var cmp=0;
             else
              {var
                c1=caml_string_get(s1,i),
                c2=caml_string_get(s,i),
                c=compare_int(c1,c2);
               if(0 === c){var i$0=i + 1 | 0,i=i$0;continue}
               var cmp=c}
             var switcher=cmp + 1 | 0,switch$0=0;
             if(2 < switcher >>> 0)
              switch$0 = 1;
             else
              switch(switcher)
               {case 0:var msd=m - 1 | 0;break;
                case 1:switch$0 = 1;break;
                default:var msd=m}
             if(switch$0)
              if(0 <= m)
               var msd=m;
              else
               {var i$1=i$3;
                for(;;)
                 {var _ao_=lim <= i$1?1:0;
                  if(_ao_)
                   var _ap_=_ao_;
                  else
                   {var _aq_=48 === caml_string_get(s,i$1)?1:0;
                    if(_aq_){var i$2=i$1 + 1 | 0,i$1=i$2;continue}
                    var _ap_=_aq_}
                  var msd=_ap_?m:m - 1 | 0;
                  break}}
             break}}
        var k=n - msd | 0;
        if(0 <= k)
         var
          _as_=r[2],
          _at_=div_big_int(base_power_big_int(10,k,abs_big_int(r[1])),_as_);
        else
         var
          _aF_=base_power_big_int(10,- k | 0,r[2]),
          _at_=div_big_int(abs_big_int(r[1]),_aF_);
        var
         nat=nat_of_big_int(_at_),
         s$0=string_of_nat(nat),
         s$1=caml_call1(Stdlib_bytes[5],s$0);
        if(round_futur_last_digit(s$1,0,caml_ml_bytes_length(s$1)))
         {var
           m$0=num_decimal_digits_int(msd + 1 | 0),
           str=caml_call2(Stdlib_bytes[1],(n + m$0 | 0) + 4 | 0,48),
           _au_=3,
           _av_=0,
           _aw_=0,
           _ax_=-1 === sign_r?cst_1$1:cst_1$2;
          caml_call5(Stdlib_string[32],_ax_,_aw_,str,_av_,_au_);
          caml_bytes_set(str,i$4[1],101);
          i$4[1]++;
          if(0 === m$0)
           caml_bytes_set(str,i$4[1],48);
          else
           {var _ay_=i$4[1],_az_=caml_call1(Stdlib[33],msd + 1 | 0);
            caml_call5(Stdlib_string[32],_az_,0,str,_ay_,m$0)}
          return caml_call1(Stdlib_bytes[42],str)}
        var
         m$1=num_decimal_digits_int(msd + 1 | 0),
         p=n + 3 | 0,
         str$0=caml_call2(Stdlib_bytes[1],(m$1 + p | 0) + 1 | 0,48),
         _aA_=3,
         _aB_=0,
         _aC_=0,
         _aD_=-1 === sign_r?cst_0$1:cst_0$2;
        caml_call5(Stdlib_string[32],_aD_,_aC_,str$0,_aB_,_aA_);
        caml_call5(Stdlib_bytes[11],s$1,0,str$0,3,n);
        caml_bytes_set(str$0,p,101);
        if(0 === m$1)
         caml_bytes_set(str$0,p + 1 | 0,48);
        else
         {var _aE_=caml_call1(Stdlib[33],msd + 1 | 0);
          caml_call5(Stdlib_string[32],_aE_,0,str$0,p + 1 | 0,m$1)}
        return caml_call1(Stdlib_bytes[42],str$0)}
      return caml_call1(Stdlib[1],cst_approx_ratio_exp$0)}
    function float_of_rational_string(r)
     {var s=approx_ratio_exp(floating_precision[1],r);
      return 43 === caml_string_get(s,0)
              ?caml_call3
                (Stdlib_string[9],s,1,caml_ml_string_length(s) - 1 | 0)
              :s}
    function string_of_ratio(r)
     {cautious_normalize_ratio_when_(r);
      if(approx_printing_flag[1])return float_of_rational_string(r);
      var
       _al_=string_of_big_int(r[2]),
       _am_=caml_call2(Stdlib[28],cst$5,_al_),
       _an_=string_of_big_int(r[1]);
      return caml_call2(Stdlib[28],_an_,_am_)}
    function ratio_of_string(s)
     {try
       {var
         n=caml_call2(Stdlib_string[25],s,47),
         _ai_=
          sys_big_int_of_string
           (s,n + 1 | 0,(caml_ml_string_length(s) - n | 0) - 1 | 0),
         _aj_=create_ratio(sys_big_int_of_string(s,0,n),_ai_);
        return _aj_}
      catch(_ak_)
       {_ak_ = caml_wrap_exception(_ak_);
        if(_ak_ === Stdlib[8])return [0,big_int_of_string(s),unit_big_int,1];
        throw _ak_}}
    function float_of_ratio(r)
     {var p=r[1],q=r[2];
      if(0 === q[1])
       {var match=p[1],switcher=match + 1 | 0;
        if(2 < switcher >>> 0)throw [0,Assert_failure,_n_];
        switch(switcher)
         {case 0:return Stdlib[23];
          case 1:return Stdlib[24];
          default:return Stdlib[22]}}
      if(0 === p[1])return 0.;
      var np=num_bits_big_int(p),nq=num_bits_big_int(q);
      if(! (53 < np) && ! (53 < nq))
       {var _ah_=caml_int64_to_float(int64_of_big_int(q));
        return caml_int64_to_float(int64_of_big_int(p)) / _ah_}
      var ap=abs_big_int(p),n=55 - (np - nq | 0) | 0;
      if(0 <= n)
       var q$0=q,p$0=shift_left_big_int(ap,n);
      else
       var q$1=shift_left_big_int(q,- n | 0),q$0=q$1,p$0=ap;
      var
       match$0=quomod_big_int(p$0,q$0),
       rem=match$0[2],
       quo=match$0[1],
       f=round_big_int_to_float(quo,0 === rem[1]?1:0),
       f$0=caml_ldexp_float(f,- n | 0);
      return 0 <= p[1]?f$0:- f$0}
    function power_ratio_positive_int(r,n)
     {var _ag_=power_big_int_positive_int(r[2],n);
      return create_ratio(power_big_int_positive_int(r[1],n),_ag_)}
    function power_ratio_positive_big_int(r,bi)
     {var _af_=power_big_int_positive_big_int(r[2],bi);
      return create_ratio(power_big_int_positive_big_int(r[1],bi),_af_)}
    var
     Ratio=
      [0,
       null_denominator,
       numerator_ratio,
       denominator_ratio,
       sign_ratio,
       normalize_ratio,
       cautious_normalize_ratio,
       cautious_normalize_ratio_when_,
       create_ratio,
       create_normalized_ratio,
       is_normalized_ratio,
       report_sign_ratio,
       abs_ratio,
       is_integer_ratio,
       add_ratio,
       minus_ratio,
       add_int_ratio,
       add_big_int_ratio,
       sub_ratio,
       mult_ratio,
       mult_int_ratio,
       mult_big_int_ratio,
       square_ratio,
       inverse_ratio,
       div_ratio,
       integer_ratio,
       floor_ratio,
       round_ratio,
       ceiling_ratio,
       eq_ratio,
       compare_ratio,
       lt_ratio,
       le_ratio,
       gt_ratio,
       ge_ratio,
       max_ratio,
       min_ratio,
       eq_big_int_ratio,
       compare_big_int_ratio,
       lt_big_int_ratio,
       le_big_int_ratio,
       gt_big_int_ratio,
       ge_big_int_ratio,
       int_of_ratio,
       ratio_of_int,
       ratio_of_nat,
       nat_of_ratio,
       ratio_of_big_int,
       big_int_of_ratio,
       div_int_ratio,
       div_ratio_int,
       div_big_int_ratio,
       div_ratio_big_int,
       approx_ratio_fix,
       approx_ratio_exp,
       float_of_rational_string,
       string_of_ratio,
       ratio_of_string,
       float_of_ratio,
       power_ratio_positive_int,
       power_ratio_positive_big_int];
    caml_register_global(132,Ratio,"Ratio");
    var
     biggest_INT=big_int_of_int(biggest_int),
     least_INT=big_int_of_int(least_int);
    function num_of_big_int(bi)
     {if(le_big_int(bi,biggest_INT) && ge_big_int(bi,least_INT))
       return [0,int_of_big_int(bi)];
      return [1,bi]}
    function num_of_ratio(r)
     {normalize_ratio(r);
      return is_integer_ratio(r)
              ?is_int_big_int(r[1])?[0,int_of_big_int(r[1])]:[1,r[1]]
              :[2,r]}
    function add_num(a,match)
     {switch(a[0])
       {case 0:
         var _ab_=a[1];
         switch(match[0])
          {case 0:
            var int2=match[1],r=_ab_ + int2 | 0;
            if(0 <= (_ab_ ^ int2 | _ab_ ^ r ^ -1))
             {var _ac_=big_int_of_int(int2);
              return [1,add_big_int(big_int_of_int(_ab_),_ac_)]}
            return [0,r];
           case 1:
            var bi=match[1];return num_of_big_int(add_int_big_int(_ab_,bi));
           default:var r$0=match[1];return [2,add_int_ratio(_ab_,r$0)]}
        case 1:
         var _ad_=a[1];
         switch(match[0])
          {case 0:
            var i=match[1];return num_of_big_int(add_int_big_int(i,_ad_));
           case 1:
            var bi2=match[1];return num_of_big_int(add_big_int(_ad_,bi2));
           default:var r$1=match[1];return [2,add_big_int_ratio(_ad_,r$1)]}
        default:
         var _ae_=a[1];
         switch(match[0])
          {case 0:var i$0=match[1];return [2,add_int_ratio(i$0,_ae_)];
           case 1:var bi$0=match[1];return [2,add_big_int_ratio(bi$0,_ae_)];
           default:var r2=match[1];return num_of_ratio(add_ratio(_ae_,r2))}}}
    function minus_num(param)
     {switch(param[0])
       {case 0:
         var i=param[1];
         return i === monster_int
                 ?[1,minus_big_int(big_int_of_int(i))]
                 :[0,- i | 0];
        case 1:var bi=param[1];return [1,minus_big_int(bi)];
        default:var r=param[1];return [2,minus_ratio(r)]}}
    function sub_num(n1,n2){return add_num(n1,minus_num(n2))}
    function mult_num(a,match)
     {switch(a[0])
       {case 0:
         var _Y_=a[1];
         switch(match[0])
          {case 0:
            var int2=match[1],_Z_=num_bits_int(int2);
            if((num_bits_int(_Y_) + _Z_ | 0) < length_of_int)
             return [0,caml_mul(_Y_,int2)];
            var ___=big_int_of_int(int2);
            return num_of_big_int(mult_big_int(big_int_of_int(_Y_),___));
           case 1:
            var bi=match[1];return num_of_big_int(mult_int_big_int(_Y_,bi));
           default:var r=match[1];return num_of_ratio(mult_int_ratio(_Y_,r))}
        case 1:
         var _$_=a[1];
         switch(match[0])
          {case 0:
            var i=match[1];return num_of_big_int(mult_int_big_int(i,_$_));
           case 1:
            var bi2=match[1];return num_of_big_int(mult_big_int(_$_,bi2));
           default:
            var r$0=match[1];return num_of_ratio(mult_big_int_ratio(_$_,r$0))}
        default:
         var _aa_=a[1];
         switch(match[0])
          {case 0:
            var i$0=match[1];return num_of_ratio(mult_int_ratio(i$0,_aa_));
           case 1:
            var bi$0=match[1];
            return num_of_ratio(mult_big_int_ratio(bi$0,_aa_));
           default:var r2=match[1];return num_of_ratio(mult_ratio(_aa_,r2))}}}
    function square_num(param)
     {switch(param[0])
       {case 0:
         var i=param[1];
         return (2 * num_bits_int(i) | 0) < length_of_int
                 ?[0,caml_mul(i,i)]
                 :num_of_big_int(square_big_int(big_int_of_int(i)));
        case 1:var bi=param[1];return [1,square_big_int(bi)];
        default:var r=param[1];return [2,square_ratio(r)]}}
    function div_num(n1,n2)
     {switch(n1[0])
       {case 0:
         var i1=n1[1];
         switch(n2[0])
          {case 0:
            var i2=n2[1],_X_=big_int_of_int(i2);
            return num_of_ratio(create_ratio(big_int_of_int(i1),_X_));
           case 1:
            var bi2=n2[1];
            return num_of_ratio(create_ratio(big_int_of_int(i1),bi2));
           default:var r2=n2[1];return num_of_ratio(div_int_ratio(i1,r2))}
        case 1:
         var bi1=n1[1];
         switch(n2[0])
          {case 0:
            var i2$0=n2[1];
            return num_of_ratio(create_ratio(bi1,big_int_of_int(i2$0)));
           case 1:
            var bi2$0=n2[1];return num_of_ratio(create_ratio(bi1,bi2$0));
           default:
            var r2$0=n2[1];return num_of_ratio(div_big_int_ratio(bi1,r2$0))}
        default:
         var r1=n1[1];
         switch(n2[0])
          {case 0:var i2$1=n2[1];return num_of_ratio(div_ratio_int(r1,i2$1));
           case 1:
            var bi2$1=n2[1];return num_of_ratio(div_ratio_big_int(r1,bi2$1));
           default:var r2$1=n2[1];return num_of_ratio(div_ratio(r1,r2$1))}}}
    function floor_num(n)
     {switch(n[0])
       {case 0:return n;
        case 1:return n;
        default:var r=n[1];return num_of_big_int(floor_ratio(r))}}
    function ratio_of_num(param)
     {switch(param[0])
       {case 0:var i=param[1];return ratio_of_int(i);
        case 1:var bi=param[1];return ratio_of_big_int(bi);
        default:var r=param[1];return r}}
    function quo_num(n1,n2)
     {switch(n1[0])
       {case 0:
         var _V_=n1[1];
         switch(n2[0])
          {case 0:
            var
             i2=n2[1],
             q=caml_div(_V_,i2),
             r=caml_mod(_V_,i2),
             q$0=0 <= r?q:0 < i2?q - 1 | 0:q + 1 | 0;
            return [0,q$0];
           case 1:
            var bi2=n2[1];
            return num_of_big_int(div_big_int(big_int_of_int(_V_),bi2));
           default:
            var r2=n2[1];
            return num_of_big_int
                    (report_sign_ratio
                      (r2,floor_ratio(div_int_ratio(_V_,abs_ratio(r2)))))}
        case 1:
         var _W_=n1[1];
         switch(n2[0])
          {case 0:
            var i2$0=n2[1];
            return num_of_big_int(div_big_int(_W_,big_int_of_int(i2$0)));
           case 1:
            var bi2$0=n2[1];return num_of_big_int(div_big_int(_W_,bi2$0));
           default:
            var r2$0=n2[1];
            return num_of_big_int
                    (report_sign_ratio
                      (r2$0,floor_ratio(div_big_int_ratio(_W_,abs_ratio(r2$0)))))}
        default:
         var r1=n1[1],r2$1=ratio_of_num(n2);
         return num_of_big_int
                 (report_sign_ratio
                   (r2$1,floor_ratio(div_ratio(r1,abs_ratio(r2$1)))))}}
    function mod_num(n1,n2)
     {switch(n1[0])
       {case 0:
         var _T_=n1[1];
         switch(n2[0])
          {case 0:
            var
             i2=n2[1],
             r=caml_mod(_T_,i2),
             r$0=0 <= r?r:0 < i2?r + i2 | 0:r - i2 | 0;
            return [0,r$0];
           case 1:
            var bi2=n2[1];
            return num_of_big_int(mod_big_int(big_int_of_int(_T_),bi2))
           }
         break;
        case 1:
         var _U_=n1[1];
         switch(n2[0])
          {case 0:
            var i2$0=n2[1];
            return num_of_big_int(mod_big_int(_U_,big_int_of_int(i2$0)));
           case 1:
            var bi2$0=n2[1];return num_of_big_int(mod_big_int(_U_,bi2$0))
           }
         break
        }
      return sub_num(n1,mult_num(n2,quo_num(n1,n2)))}
    function power_num(n,match$5)
     {switch(match$5[0])
       {case 0:
         var i$1=match$5[1];
         switch(n[0])
          {case 0:
            var i=n[1],match=sign_int(i$1);
            return 0 === match
                    ?_o_
                    :1 === match
                      ?num_of_big_int(power_int_positive_int(i,i$1))
                      :[2,
                        create_normalized_ratio
                         (unit_big_int,power_int_positive_int(i,- i$1 | 0))];
           case 1:
            var bi=n[1],match$0=sign_int(i$1);
            return 0 === match$0
                    ?_p_
                    :1 === match$0
                      ?num_of_big_int(power_big_int_positive_int(bi,i$1))
                      :[2,
                        create_normalized_ratio
                         (unit_big_int,power_big_int_positive_int(bi,- i$1 | 0))];
           default:
            var r=n[1],match$1=sign_int(i$1);
            return 0 === match$1
                    ?_q_
                    :1 === match$1
                      ?[2,power_ratio_positive_int(r,i$1)]
                      :[2,power_ratio_positive_int(inverse_ratio(r),- i$1 | 0)]}
        case 1:
         var bi$1=match$5[1];
         switch(n[0])
          {case 0:
            var i$0=n[1],match$2=bi$1[1];
            return 0 === match$2
                    ?_r_
                    :1 === match$2
                      ?num_of_big_int(power_int_positive_big_int(i$0,bi$1))
                      :[2,
                        create_normalized_ratio
                         (unit_big_int,
                          power_int_positive_big_int(i$0,minus_big_int(bi$1)))];
           case 1:
            var bi$0=n[1],match$3=bi$1[1];
            return 0 === match$3
                    ?_s_
                    :1 === match$3
                      ?num_of_big_int(power_big_int_positive_big_int(bi$0,bi$1))
                      :[2,
                        create_normalized_ratio
                         (unit_big_int,
                          power_big_int_positive_big_int(bi$0,minus_big_int(bi$1)))];
           default:
            var r$0=n[1],match$4=bi$1[1];
            if(0 === match$4)return _t_;
            if(1 === match$4)
             return [2,power_ratio_positive_big_int(r$0,bi$1)];
            var _S_=minus_big_int(bi$1);
            return [2,power_ratio_positive_big_int(inverse_ratio(r$0),_S_)]}
        default:return caml_call1(Stdlib[1],cst_power_num)}}
    function is_integer_num(param)
     {switch(param[0])
       {case 0:return 1;
        case 1:return 1;
        default:var r=param[1];return is_integer_ratio(r)}}
    function integer_num(n)
     {switch(n[0])
       {case 0:return n;
        case 1:return n;
        default:var r=n[1];return num_of_big_int(integer_ratio(r))}}
    function round_num(n)
     {switch(n[0])
       {case 0:return n;
        case 1:return n;
        default:var r=n[1];return num_of_big_int(round_ratio(r))}}
    function ceiling_num(n)
     {switch(n[0])
       {case 0:return n;
        case 1:return n;
        default:var r=n[1];return num_of_big_int(ceiling_ratio(r))}}
    function sign_num(param)
     {switch(param[0])
       {case 0:var i=param[1];return sign_int(i);
        case 1:var bi=param[1];return bi[1];
        default:var r=param[1];return sign_ratio(r)}}
    function eq_num(a,match)
     {switch(a[0])
       {case 0:
         var _P_=a[1];
         switch(match[0])
          {case 0:var int2=match[1];return _P_ === int2?1:0;
           case 1:var bi=match[1];return eq_big_int(big_int_of_int(_P_),bi);
           default:
            var r=match[1];return eq_big_int_ratio(big_int_of_int(_P_),r)}
        case 1:
         var _Q_=a[1];
         switch(match[0])
          {case 0:var i=match[1];return eq_big_int(big_int_of_int(i),_Q_);
           case 1:var bi2=match[1];return eq_big_int(_Q_,bi2);
           default:var r$0=match[1];return eq_big_int_ratio(_Q_,r$0)}
        default:
         var _R_=a[1];
         switch(match[0])
          {case 0:
            var i$0=match[1];return eq_big_int_ratio(big_int_of_int(i$0),_R_);
           case 1:var bi$0=match[1];return eq_big_int_ratio(bi$0,_R_);
           default:var r2=match[1];return eq_ratio(_R_,r2)}}}
    function symbol(a,b){return 1 - eq_num(a,b)}
    function compare_num(a,match)
     {switch(a[0])
       {case 0:
         var _M_=a[1];
         switch(match[0])
          {case 0:var int2=match[1];return compare_int(_M_,int2);
           case 1:
            var bi=match[1];return compare_big_int(big_int_of_int(_M_),bi);
           default:
            var r=match[1];return compare_big_int_ratio(big_int_of_int(_M_),r)}
        case 1:
         var _N_=a[1];
         switch(match[0])
          {case 0:
            var i=match[1];return compare_big_int(_N_,big_int_of_int(i));
           case 1:var bi2=match[1];return compare_big_int(_N_,bi2);
           default:var r$0=match[1];return compare_big_int_ratio(_N_,r$0)}
        default:
         var _O_=a[1];
         switch(match[0])
          {case 0:
            var i$0=match[1];
            return - compare_big_int_ratio(big_int_of_int(i$0),_O_) | 0;
           case 1:
            var bi$0=match[1];return - compare_big_int_ratio(bi$0,_O_) | 0;
           default:var r2=match[1];return compare_ratio(_O_,r2)}}}
    function lt_num(num1,num2){return compare_num(num1,num2) < 0?1:0}
    function le_num(num1,num2){return compare_num(num1,num2) <= 0?1:0}
    function gt_num(num1,num2){return 0 < compare_num(num1,num2)?1:0}
    function ge_num(num1,num2){return 0 <= compare_num(num1,num2)?1:0}
    function max_num(num1,num2){return lt_num(num1,num2)?num2:num1}
    function min_num(num1,num2){return gt_num(num1,num2)?num2:num1}
    function int_of_num(param)
     {switch(param[0])
       {case 0:var i=param[1];return i;
        case 1:var bi=param[1];return int_of_big_int(bi);
        default:var r=param[1];return int_of_ratio(r)}}
    function int_of_num_opt(param)
     {switch(param[0])
       {case 0:var i=param[1];return [0,i];
        case 1:var bi=param[1];return int_of_big_int_opt(bi);
        default:
         var r=param[1];
         try
          {var _K_=[0,int_of_ratio(r)];return _K_}
         catch(_L_)
          {_L_ = caml_wrap_exception(_L_);
           if(_L_[1] === Stdlib[7])return 0;
           throw _L_}}}
    function num_of_int(i)
     {return i === monster_int?[1,big_int_of_int(i)]:[0,i]}
    function nat_of_num(param)
     {switch(param[0])
       {case 0:var i=param[1];return nat_of_int(i);
        case 1:var bi=param[1];return nat_of_big_int(bi);
        default:var r=param[1];return nat_of_ratio(r)}}
    function num_of_nat(nat)
     {return is_nat_int(nat,0,length_nat(nat))
              ?[0,nth_digit_nat(nat,0)]
              :[1,big_int_of_nat(nat)]}
    function nat_of_num_opt(x)
     {try
       {var _I_=[0,nat_of_num(x)];return _I_}
      catch(_J_)
       {_J_ = caml_wrap_exception(_J_);
        if(_J_[1] === Stdlib[7])return 0;
        throw _J_}}
    function big_int_of_num(param)
     {switch(param[0])
       {case 0:var i=param[1];return big_int_of_int(i);
        case 1:var bi=param[1];return bi;
        default:var r=param[1];return big_int_of_ratio(r)}}
    function big_int_of_num_opt(x)
     {try
       {var _G_=[0,big_int_of_num(x)];return _G_}
      catch(_H_)
       {_H_ = caml_wrap_exception(_H_);
        if(_H_[1] === Stdlib[7])return 0;
        throw _H_}}
    function string_of_num(n)
     {if(normalize_ratio_when_printing_[1])
       switch(n[0])
        {case 0:var i=n[1],_F_=[0,i];break;
         case 1:var bi=n[1],_F_=num_of_big_int(bi);break;
         default:var r=n[1],_F_=is_integer_ratio(r)?num_of_big_int(r[1]):[2,r]}
      else
       var _F_=n;
      switch(_F_[0])
       {case 0:var i$0=_F_[1];return caml_call1(Stdlib[33],i$0);
        case 1:
         var bi$0=_F_[1];
         return approx_printing_flag[1]
                 ?approx_big_int(floating_precision[1],bi$0)
                 :string_of_big_int(bi$0);
        default:var r$0=_F_[1];return string_of_ratio(r$0)}}
    function num_of_string(s)
     {try
       {var flag=normalize_ratio_flag[1];
        normalize_ratio_flag[1] = 1;
        var r=ratio_of_string(s);
        normalize_ratio_flag[1] = flag;
        var _D_=eq_big_int(r[2],unit_big_int)?num_of_big_int(r[1]):[2,r];
        return _D_}
      catch(_E_)
       {_E_ = caml_wrap_exception(_E_);
        if(_E_[1] === Stdlib[7])
         return caml_call1(Stdlib[2],cst_num_of_string);
        throw _E_}}
    function num_of_string_opt(s)
     {try
       {var _B_=[0,num_of_string(s)];return _B_}
      catch(_C_)
       {_C_ = caml_wrap_exception(_C_);
        if(_C_[1] === Stdlib[7])return 0;
        throw _C_}}
    function float_of_num(param)
     {switch(param[0])
       {case 0:var i=param[1];return i;
        case 1:var bi=param[1];return float_of_big_int(bi);
        default:var r=param[1];return float_of_ratio(r)}}
    function succ_num(param)
     {switch(param[0])
       {case 0:
         var i=param[1];
         return i === biggest_int
                 ?[1,succ_big_int(big_int_of_int(i))]
                 :[0,i + 1 | 0];
        case 1:var bi=param[1];return num_of_big_int(succ_big_int(bi));
        default:var r=param[1];return [2,add_int_ratio(1,r)]}}
    function pred_num(param)
     {switch(param[0])
       {case 0:
         var i=param[1];
         return i === monster_int
                 ?[1,pred_big_int(big_int_of_int(i))]
                 :[0,i - 1 | 0];
        case 1:var bi=param[1];return num_of_big_int(pred_big_int(bi));
        default:var r=param[1];return [2,add_int_ratio(-1,r)]}}
    function abs_num(param)
     {switch(param[0])
       {case 0:
         var i=param[1];
         return i === monster_int
                 ?[1,minus_big_int(big_int_of_int(i))]
                 :[0,caml_call1(Stdlib[18],i)];
        case 1:var bi=param[1];return [1,abs_big_int(bi)];
        default:var r=param[1];return [2,abs_ratio(r)]}}
    function approx_num_fix(n,num)
     {return approx_ratio_fix(n,ratio_of_num(num))}
    function approx_num_exp(n,num)
     {return approx_ratio_exp(n,ratio_of_num(num))}
    function incr_num(r){r[1] = succ_num(r[1]);return 0}
    function decr_num(r){r[1] = pred_num(r[1]);return 0}
    var
     Num=
      [0,
       add_num,
       add_num,
       minus_num,
       sub_num,
       sub_num,
       mult_num,
       mult_num,
       square_num,
       div_num,
       div_num,
       quo_num,
       mod_num,
       power_num,
       power_num,
       abs_num,
       succ_num,
       pred_num,
       incr_num,
       decr_num,
       is_integer_num,
       integer_num,
       floor_num,
       round_num,
       ceiling_num,
       sign_num,
       eq_num,
       lt_num,
       gt_num,
       le_num,
       ge_num,
       symbol,
       eq_num,
       lt_num,
       le_num,
       gt_num,
       ge_num,
       compare_num,
       max_num,
       min_num,
       string_of_num,
       approx_num_fix,
       approx_num_exp,
       num_of_string,
       num_of_string_opt,
       int_of_num,
       int_of_num_opt,
       num_of_int,
       nat_of_num,
       nat_of_num_opt,
       num_of_nat,
       num_of_big_int,
       big_int_of_num,
       big_int_of_num_opt,
       ratio_of_num,
       num_of_ratio,
       float_of_num];
    caml_register_global(133,Num,"Num");
    function get_error_when_null_denominato(param)
     {return error_when_null_denominator_fl[1]}
    function set_error_when_null_denominato(choice)
     {error_when_null_denominator_fl[1] = choice;return 0}
    function get_normalize_ratio(param){return normalize_ratio_flag[1]}
    function set_normalize_ratio(choice)
     {normalize_ratio_flag[1] = choice;return 0}
    function get_normalize_ratio_when_print(param)
     {return normalize_ratio_when_printing_[1]}
    function set_normalize_ratio_when_print(choice)
     {normalize_ratio_when_printing_[1] = choice;return 0}
    function get_floating_precision(param){return floating_precision[1]}
    function set_floating_precision(i){floating_precision[1] = i;return 0}
    function get_approx_printing(param){return approx_printing_flag[1]}
    function set_approx_printing(b){approx_printing_flag[1] = b;return 0}
    function arith_print_string(s)
     {caml_call1(Stdlib[42],s);return caml_call1(Stdlib[42],cst$6)}
    function arith_print_bool(param)
     {return param
              ?caml_call1(Stdlib[42],cst_ON)
              :caml_call1(Stdlib[42],cst_OFF)}
    function arith_status(param)
     {caml_call1(Stdlib[47],0);
      arith_print_string(cst_Normalization_during_compu);
      arith_print_bool(get_normalize_ratio(0));
      caml_call1(Stdlib[47],0);
      caml_call1(Stdlib[42],cst_returned_by_get_normalize_);
      caml_call1(Stdlib[47],0);
      caml_call1(Stdlib[42],cst_modifiable_with_set_normal);
      caml_call1(Stdlib[47],0);
      caml_call1(Stdlib[47],0);
      arith_print_string(cst_Normalization_when_printin);
      arith_print_bool(get_normalize_ratio_when_print(0));
      caml_call1(Stdlib[47],0);
      caml_call1(Stdlib[42],cst_returned_by_get_normalize_$0);
      caml_call1(Stdlib[47],0);
      caml_call1(Stdlib[42],cst_modifiable_with_set_normal$0);
      caml_call1(Stdlib[47],0);
      caml_call1(Stdlib[47],0);
      arith_print_string(cst_Floating_point_approximati);
      arith_print_bool(get_approx_printing(0));
      caml_call1(Stdlib[47],0);
      caml_call1(Stdlib[42],cst_returned_by_get_approx_pri);
      caml_call1(Stdlib[47],0);
      caml_call1(Stdlib[42],cst_modifiable_with_set_approx);
      caml_call1(Stdlib[47],0);
      if(get_approx_printing(0))
       {caml_call1(Stdlib[42],cst_Default_precision);
        var _A_=get_floating_precision(0);
        caml_call1(Stdlib[44],_A_);
        caml_call1(Stdlib[47],0);
        caml_call1(Stdlib[42],cst_returned_by_get_floating_p);
        caml_call1(Stdlib[47],0);
        caml_call1(Stdlib[42],cst_modifiable_with_set_floati);
        caml_call1(Stdlib[47],0);
        caml_call1(Stdlib[47],0)}
      else
       caml_call1(Stdlib[47],0);
      arith_print_string(cst_Error_when_a_rational_deno);
      arith_print_bool(get_error_when_null_denominato(0));
      caml_call1(Stdlib[47],0);
      caml_call1(Stdlib[42],cst_returned_by_get_error_when);
      caml_call1(Stdlib[47],0);
      caml_call1(Stdlib[42],cst_modifiable_with_set_error_);
      return caml_call1(Stdlib[47],0)}
    var
     Arith_status=
      [0,
       arith_status,
       get_error_when_null_denominato,
       set_error_when_null_denominato,
       get_normalize_ratio,
       set_normalize_ratio,
       get_normalize_ratio_when_print,
       set_normalize_ratio_when_print,
       get_approx_printing,
       set_approx_printing,
       get_floating_precision,
       set_floating_precision];
    caml_register_global(134,Arith_status,"Arith_status");
    return}
  (function(){return this}()));


//# 1 ".js/str/str.cma.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_bytes_get=runtime.caml_bytes_get,
     caml_bytes_set=runtime.caml_bytes_set,
     caml_check_bound=runtime.caml_check_bound,
     caml_create_bytes=runtime.caml_create_bytes,
     caml_make_vect=runtime.caml_make_vect,
     caml_ml_string_length=runtime.caml_ml_string_length,
     caml_string_equal=runtime.caml_string_equal,
     caml_string_get=runtime.caml_string_get,
     caml_string_of_jsbytes=runtime.caml_string_of_jsbytes,
     caml_trampoline=runtime.caml_trampoline,
     caml_trampoline_return=runtime.caml_trampoline_return,
     caml_wrap_exception=runtime.caml_wrap_exception;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5
              ?f(a0,a1,a2,a3,a4)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4])}
    var
     global_data=runtime.caml_get_global_data(),
     cst=caml_string_of_jsbytes(""),
     cst$0=caml_string_of_jsbytes(""),
     cst$5=caml_string_of_jsbytes(""),
     cst$4=caml_string_of_jsbytes(""),
     cst$3=caml_string_of_jsbytes(""),
     cst_Str_matched_group=caml_string_of_jsbytes("Str.matched_group"),
     cst_Str_group_end=caml_string_of_jsbytes("Str.group_end"),
     cst_Str_group_beginning=caml_string_of_jsbytes("Str.group_beginning"),
     cst_group_not_closed_by=
      caml_string_of_jsbytes("\\( group not closed by \\)"),
     cst_class_not_closed_by=caml_string_of_jsbytes("[ class not closed by ]"),
     cst_spurious_in_regular_expres=
      caml_string_of_jsbytes("spurious \\) in regular expression"),
     cst_too_many_r_or_r_where_r_is=
      caml_string_of_jsbytes("too many r* or r+ where r is nullable"),
     cst$1=caml_string_of_jsbytes(""),
     cst$2=caml_string_of_jsbytes(""),
     Stdlib_list=global_data.Stdlib__list,
     Stdlib_string=global_data.Stdlib__string,
     Stdlib=global_data.Stdlib,
     Stdlib_bytes=global_data.Stdlib__bytes,
     Assert_failure=global_data.Assert_failure,
     Stdlib_buffer=global_data.Stdlib__buffer,
     Stdlib_char=global_data.Stdlib__char,
     Stdlib_array=global_data.Stdlib__array,
     Stdlib_map=global_data.Stdlib__map,
     _b_=[0,92],
     _c_=[0,caml_string_of_jsbytes("str.ml"),520,10],
     _a_=[0,caml_string_of_jsbytes("str.ml"),213,11];
    function string_before(s,n){return caml_call3(Stdlib_string[9],s,0,n)}
    function string_after(s,n)
     {return caml_call3(Stdlib_string[9],s,n,caml_ml_string_length(s) - n | 0)}
    function first_chars(s,n){return caml_call3(Stdlib_string[9],s,0,n)}
    function last_chars(s,n)
     {return caml_call3(Stdlib_string[9],s,caml_ml_string_length(s) - n | 0,n)}
    var full=caml_call2(Stdlib_bytes[1],32,255);
    function make_empty(param){return caml_call2(Stdlib_bytes[1],32,0)}
    function add(s,i)
     {var _ao_=caml_bytes_get(s,i >>> 3 | 0) | 1 << (i & 7);
      return caml_bytes_set(s,i >>> 3 | 0,caml_call1(Stdlib_char[1],_ao_))}
    function singleton(c){var s=make_empty(0);add(s,c);return s}
    function complement(s)
     {var r=caml_create_bytes(32),i=0;
      for(;;)
       {var _am_=caml_bytes_get(s,i) ^ 255;
        caml_bytes_set(r,i,caml_call1(Stdlib_char[1],_am_));
        var _an_=i + 1 | 0;
        if(31 !== i){var i=_an_;continue}
        return r}}
    function union(s1,s2)
     {var r=caml_create_bytes(32),i=0;
      for(;;)
       {var _aj_=caml_bytes_get(s2,i),_ak_=caml_bytes_get(s1,i) | _aj_;
        caml_bytes_set(r,i,caml_call1(Stdlib_char[1],_ak_));
        var _al_=i + 1 | 0;
        if(31 !== i){var i=_al_;continue}
        return r}}
    function disjoint(s1,s2)
     {try
       {var i=0;
        for(;;)
         {var _ag_=caml_bytes_get(s2,i);
          if(0 !== (caml_bytes_get(s1,i) & _ag_))throw Stdlib[3];
          var _ah_=i + 1 | 0;
          if(31 !== i){var i=_ah_;continue}
          var _af_=1;
          return _af_}}
      catch(_ai_)
       {_ai_ = caml_wrap_exception(_ai_);
        if(_ai_ === Stdlib[3])return 0;
        throw _ai_}}
    function iter(fn,s)
     {var i=0;
      for(;;)
       {var c=caml_bytes_get(s,i);
        if(0 !== c)
         {var j=0;
          for(;;)
           {if(0 !== (c & 1 << j))
             caml_call1(fn,caml_call1(Stdlib_char[1],(i << 3) + j | 0));
            var _ae_=j + 1 | 0;
            if(7 !== j){var j=_ae_;continue}
            break}}
        var _ad_=i + 1 | 0;
        if(31 !== i){var i=_ad_;continue}
        return 0}}
    function fold_case(s)
     {var r=make_empty(0);
      iter
       (function(c)
         {add(r,caml_call1(Stdlib_char[3],c));
          return add(r,caml_call1(Stdlib_char[4],c))},
        s);
      return r}
    var
     op_CHAR=0,
     op_CHARNORM=1,
     op_STRING=2,
     op_STRINGNORM=3,
     op_CHARCLASS=4,
     op_BOL=5,
     op_EOL=6,
     op_WORDBOUNDARY=7,
     op_BEGGROUP=8,
     op_ENDGROUP=9,
     op_REFGROUP=10,
     op_ACCEPT=11,
     op_SIMPLEOPT=12,
     op_SIMPLESTAR=13,
     op_SIMPLEPLUS=14,
     op_GOTO=15,
     op_PUSHBACK=16,
     op_SETMARK=17,
     op_CHECKPROGRESS=18;
    function instr(opc,arg){return opc | arg << 8}
    function displ(dest,from){return (dest - from | 0) - 1 | 0}
    function is_nullable(param)
     {var param$0=param;
      for(;;)
       if(typeof param$0 === "number")
        switch(param$0){case 0:return 1;case 1:return 1;default:return 1}
       else
        switch(param$0[0])
         {case 0:return 0;
          case 1:var s=param$0[1];return caml_string_equal(s,cst);
          case 2:return 0;
          case 3:
           var rl=param$0[1];
           return caml_call2(Stdlib_list[32],is_nullable,rl);
          case 4:
           var r2=param$0[2],r1=param$0[1],_ac_=is_nullable(r1);
           if(_ac_)return _ac_;
           var param$0=r2;
           continue;
          case 5:return 1;
          case 6:var param$1=param$0[1],param$0=param$1;continue;
          case 7:return 1;
          case 8:var param$2=param$0[2],param$0=param$2;continue;
          default:return 1}}
    function first$0(counter,param)
     {var param$0=param;
      for(;;)
       if(typeof param$0 === "number")
        switch(param$0)
         {case 0:return full;case 1:return full;default:return full}
       else
        switch(param$0[0])
         {case 0:var c=param$0[1];return singleton(c);
          case 1:
           var s=param$0[1];
           return caml_string_equal(s,cst$0)
                   ?full
                   :singleton(caml_string_get(s,0));
          case 2:
           var cmpl=param$0[2],cl=param$0[1];return cmpl?complement(cl):cl;
          case 3:
           var rl=param$0[1];
           if(counter < 50)
            {var counter$0=counter + 1 | 0;return first_seq$0(counter$0,rl)}
           return caml_trampoline_return(first_seq$0,[0,rl]);
          case 4:
           var r2=param$0[2],r1=param$0[1],_ab_=first(r2);
           return union(first(r1),_ab_);
          case 5:return full;
          case 6:var param$1=param$0[1],param$0=param$1;continue;
          case 7:return full;
          case 8:var param$2=param$0[2],param$0=param$2;continue;
          default:return full}}
    function first_seq$0(counter,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var ___=param$0[1];
          if(typeof ___ === "number")
           {var param$1=param$0[2],param$0=param$1;continue}
          else
           switch(___[0])
            {case 5:
              var rl=param$0[2],r=___[1],_$_=first_seq(rl);
              return union(first(r),_$_);
             case 7:
              var rl$0=param$0[2],r$0=___[1],_aa_=first_seq(rl$0);
              return union(first(r$0),_aa_);
             default:
              if(counter < 50)
               {var counter$0=counter + 1 | 0;return first$0(counter$0,___)}
              return caml_trampoline_return(first$0,[0,___])}}
        return full}}
    function first(param){return caml_trampoline(first$0(0,param))}
    function first_seq(param){return caml_trampoline(first_seq$0(0,param))}
    function charclass_of_regexp(fold_case$0,re)
     {var switch$0=0;
      if(typeof re !== "number")
       switch(re[0])
        {case 0:var c=re[1],compl=0,cl1=singleton(c);switch$0 = 1;break;
         case 2:
          var compl$0=re[2],cl=re[1],compl=compl$0,cl1=cl;switch$0 = 1;break
         }
      if(switch$0)
       {var cl2=fold_case$0?fold_case(cl1):cl1,_Z_=compl?complement(cl2):cl2;
        return caml_call1(Stdlib_bytes[6],_Z_)}
      throw [0,Assert_failure,_a_]}
    var t=caml_create_bytes(256),i=0;
    for(;;)
     {var _d_=caml_call1(Stdlib_char[1],i);
      caml_bytes_set(t,i,caml_call1(Stdlib_char[3],_d_));
      var _e_=i + 1 | 0;
      if(255 !== i){var i=_e_;continue}
      var
       fold_case_table=caml_call1(Stdlib_bytes[6],t),
       compare=function(x,y){return runtime.caml_string_compare(x,y)},
       StringMap=caml_call1(Stdlib_map[1],[0,compare]),
       compile=
        function(fold_case$0,re)
         {var
           prog=[0,caml_make_vect(32,0)],
           progpos=[0,0],
           cpool=[0,StringMap[1]],
           cpoolpos=[0,0],
           numgroups=[0,1],
           numregs=[0,0];
          function emit_instr(opc,arg)
           {if(prog[1].length - 1 <= progpos[1])
             {var newlen=[0,prog[1].length - 1];
              for(;;)
               {if(newlen[1] <= progpos[1])
                 {newlen[1] = newlen[1] * 2 | 0;continue}
                var nprog=caml_make_vect(newlen[1],0);
                caml_call5
                 (Stdlib_array[10],prog[1],0,nprog,0,prog[1].length - 1);
                prog[1] = nprog;
                break}}
            var _X_=instr(opc,arg),_Y_=progpos[1];
            caml_check_bound(prog[1],_Y_)[1 + _Y_] = _X_;
            progpos[1]++;
            return 0}
          function emit_hole(param)
           {var p=progpos[1];emit_instr(op_CHAR,0);return p}
          function patch_instr(pos,opc,dest)
           {var _W_=instr(opc,displ(dest,pos));
            caml_check_bound(prog[1],pos)[1 + pos] = _W_;
            return 0}
          function cpool_index(s)
           {try
             {var _U_=caml_call2(StringMap[28],s,cpool[1]);return _U_}
            catch(_V_)
             {_V_ = caml_wrap_exception(_V_);
              if(_V_ === Stdlib[8])
               {var p=cpoolpos[1];
                cpool[1] = caml_call3(StringMap[4],s,p,cpool[1]);
                cpoolpos[1]++;
                return p}
              throw _V_}}
          function allocate_register_if_nullable(r)
           {if(is_nullable(r))
             {var n=numregs[1];
              if(64 <= n)caml_call1(Stdlib[2],cst_too_many_r_or_r_where_r_is);
              numregs[1]++;
              return n}
            return -1}
          function disjoint_modulo_case(c1,c2)
           {if(fold_case$0)
             {var _T_=fold_case(c2);return disjoint(fold_case(c1),_T_)}
            return disjoint(c1,c2)}
          function emit_code(param)
           {if(typeof param === "number")
             switch(param)
              {case 0:return emit_instr(op_BOL,0);
               case 1:return emit_instr(op_EOL,0);
               default:return emit_instr(op_WORDBOUNDARY,0)}
            else
             switch(param[0])
              {case 0:
                var c=param[1];
                return fold_case$0
                        ?emit_instr(op_CHARNORM,caml_call1(Stdlib_char[3],c))
                        :emit_instr(op_CHAR,c);
               case 1:
                var s=param[1],match=caml_ml_string_length(s);
                if(0 === match)return 0;
                if(1 === match)
                 {if(fold_case$0)
                   {var _Q_=caml_string_get(s,0);
                    return emit_instr
                            (op_CHARNORM,caml_call1(Stdlib_char[3],_Q_))}
                  return emit_instr(op_CHAR,caml_string_get(s,0))}
                try
                 {var i=caml_call2(Stdlib_string[25],s,0);
                  emit_code([1,string_before(s,i)]);
                  emit_instr(op_CHAR,0);
                  var _R_=emit_code([1,string_after(s,i + 1 | 0)]);
                  return _R_}
                catch(_S_)
                 {_S_ = caml_wrap_exception(_S_);
                  if(_S_ === Stdlib[8])
                   return fold_case$0
                           ?emit_instr
                             (op_STRINGNORM,cpool_index(caml_call1(Stdlib_string[36],s)))
                           :emit_instr(op_STRING,cpool_index(s));
                  throw _S_}
               case 2:
                var
                 compl=param[2],
                 cl=param[1],
                 cl1=fold_case$0?fold_case(cl):cl,
                 cl2=compl?complement(cl1):cl1;
                return emit_instr
                        (op_CHARCLASS,cpool_index(caml_call1(Stdlib_bytes[6],cl2)));
               case 3:var rl=param[1];return emit_seq_code(rl);
               case 4:
                var r2=param[2],r1=param[1],pos_pushback=emit_hole(0);
                emit_code(r1);
                var pos_goto_end=emit_hole(0),lbl1=progpos[1];
                emit_code(r2);
                var lbl2=progpos[1];
                patch_instr(pos_pushback,op_PUSHBACK,lbl1);
                return patch_instr(pos_goto_end,op_GOTO,lbl2);
               case 5:
                var
                 r=param[1],
                 regno=allocate_register_if_nullable(r),
                 lbl1$0=emit_hole(0);
                if(0 <= regno)emit_instr(op_SETMARK,regno);
                emit_code(r);
                if(0 <= regno)emit_instr(op_CHECKPROGRESS,regno);
                emit_instr(op_GOTO,displ(lbl1$0,progpos[1]));
                var lbl2$0=progpos[1];
                return patch_instr(lbl1$0,op_PUSHBACK,lbl2$0);
               case 6:
                var
                 r$0=param[1],
                 regno$0=allocate_register_if_nullable(r$0),
                 lbl1$1=progpos[1];
                emit_code(r$0);
                if(0 <= regno$0)emit_instr(op_CHECKPROGRESS,regno$0);
                var pos_pushback$0=emit_hole(0);
                if(0 <= regno$0)emit_instr(op_SETMARK,regno$0);
                emit_instr(op_GOTO,displ(lbl1$1,progpos[1]));
                var lbl2$1=progpos[1];
                return patch_instr(pos_pushback$0,op_PUSHBACK,lbl2$1);
               case 7:
                var r$1=param[1],pos_pushback$1=emit_hole(0);
                emit_code(r$1);
                var lbl=progpos[1];
                return patch_instr(pos_pushback$1,op_PUSHBACK,lbl);
               case 8:
                var r$2=param[2],n=param[1];
                emit_instr(op_BEGGROUP,n);
                emit_code(r$2);
                emit_instr(op_ENDGROUP,n);
                numgroups[1] = caml_call2(Stdlib[17],numgroups[1],n + 1 | 0);
                return 0;
               default:
                var n$0=param[1];
                emit_instr(op_REFGROUP,n$0);
                numgroups[1]
                =
                caml_call2(Stdlib[17],numgroups[1],n$0 + 1 | 0);
                return 0}}
          function emit_seq_code(param)
           {var param$0=param;
            for(;;)
             {if(param$0)
               {var _J_=param$0[1];
                if(typeof _J_ !== "number")
                 switch(_J_[0])
                  {case 5:
                    var _K_=_J_[1],switch$0=0;
                    if(typeof _K_ === "number")
                     switch$0 = 1;
                    else
                     switch(_K_[0])
                      {case 0:
                       case 2:
                        var rl$0=param$0[2],_L_=first_seq(rl$0);
                        if(disjoint_modulo_case(first(_K_),_L_))
                         {emit_instr
                           (op_SIMPLESTAR,
                            cpool_index(charclass_of_regexp(fold_case$0,_K_)));
                          var param$0=rl$0;
                          continue}
                        break;
                       default:switch$0 = 1}
                    break;
                   case 6:
                    var _M_=_J_[1],switch$1=0;
                    if(typeof _M_ === "number")
                     switch$1 = 1;
                    else
                     switch(_M_[0])
                      {case 0:
                       case 2:
                        var rl$1=param$0[2],_N_=first_seq(rl$1);
                        if(disjoint_modulo_case(first(_M_),_N_))
                         {emit_instr
                           (op_SIMPLEPLUS,
                            cpool_index(charclass_of_regexp(fold_case$0,_M_)));
                          var param$0=rl$1;
                          continue}
                        break;
                       default:switch$1 = 1}
                    break;
                   case 7:
                    var _O_=_J_[1],switch$2=0;
                    if(typeof _O_ === "number")
                     switch$2 = 1;
                    else
                     switch(_O_[0])
                      {case 0:
                       case 2:
                        var rl$2=param$0[2],_P_=first_seq(rl$2);
                        if(disjoint_modulo_case(first(_O_),_P_))
                         {emit_instr
                           (op_SIMPLEOPT,
                            cpool_index(charclass_of_regexp(fold_case$0,_O_)));
                          var param$0=rl$2;
                          continue}
                        break;
                       default:switch$2 = 1}
                    break
                   }
                var rl=param$0[2];
                emit_code(_J_);
                var param$0=rl;
                continue}
              return 0}}
          emit_code(re);
          emit_instr(op_ACCEPT,0);
          var start=first(re),start$0=fold_case$0?fold_case(start):start;
          if(runtime.caml_bytes_equal(start,full))
           var start_pos=-1;
          else
           {var r=caml_call2(Stdlib_bytes[1],256,0);
            iter(function(c){return caml_bytes_set(r,c,1)},start$0);
            var start_pos=cpool_index(caml_call1(Stdlib_bytes[6],r))}
          var constantpool=caml_make_vect(cpoolpos[1],cst$1),_F_=cpool[1];
          function _G_(str,idx)
           {caml_check_bound(constantpool,idx)[1 + idx] = str;return 0}
          caml_call2(StringMap[12],_G_,_F_);
          var
           _H_=numregs[1],
           _I_=numgroups[1],
           fold_case_table$0=fold_case$0?fold_case_table:cst$2;
          return [0,
                  caml_call3(Stdlib_array[7],prog[1],0,progpos[1]),
                  constantpool,
                  fold_case_table$0,
                  _I_,
                  _H_,
                  start_pos]},
       flush=
        function(buf)
         {var s=caml_call1(Stdlib_buffer[2],buf[1]);
          caml_call1(Stdlib_buffer[8],buf[1]);
          var match=caml_ml_string_length(s);
          if(0 === match)return 0;
          if(1 === match)
           {var _E_=buf[2];buf[2] = [0,[0,caml_string_get(s,0)],_E_];return 0}
          buf[2] = [0,[1,s],buf[2]];
          return 0},
       dotclass=complement(singleton(10)),
       parse=
        function(s)
         {var len=caml_ml_string_length(s),group_counter=[0,1];
          function regexpclass1(start)
           {var c=make_empty(0),i$0=start;
            for(;;)
             {if(len <= i$0)caml_call1(Stdlib[2],cst_class_not_closed_by);
              if(93 === caml_string_get(s,i$0) && start < i$0)
               {var j=i$0 + 1 | 0;return [0,c,j]}
              var c1=caml_string_get(s,i$0);
              if
               ((i$0 + 2 | 0)
                <
                len
                &&
                45
                ===
                caml_string_get(s,i$0 + 1 | 0)
                &&
                93
                !==
                caml_string_get(s,i$0 + 2 | 0))
               {var c2=caml_string_get(s,i$0 + 2 | 0);
                if(! (c2 < c1))
                 {var i=c1;
                  for(;;)
                   {add(c,caml_call1(Stdlib_char[1],i));
                    var _D_=i + 1 | 0;
                    if(c2 !== i){var i=_D_;continue}
                    break}}
                var i$2=i$0 + 3 | 0,i$0=i$2;
                continue}
              add(c,c1);
              var i$1=i$0 + 1 | 0,i$0=i$1;
              continue}}
          function regexp1(i)
           {var sb=[0,caml_call1(Stdlib_buffer[1],16),0],i$0=i;
            a:
            for(;;)
             {if(! (len <= i$0))
               {var switch$0=0;
                if((i$0 + 2 | 0) <= len && 92 === caml_string_get(s,i$0))
                 {var
                   c$0=caml_string_get(s,i$0 + 1 | 0),
                   _A_=124 === c$0?1:0,
                   _B_=_A_ || (41 === c$0?1:0);
                  if(_B_)switch$0 = 1}
                if(! switch$0)
                 {var c$1=caml_string_get(s,i$0);
                  if(36 === c$1)
                   var match=[0,1,i$0 + 1 | 0];
                  else
                   {var switch$1=0;
                    if(91 <= c$1)
                     if(95 <= c$1)
                      switch$1 = 1;
                     else
                      {var switcher$0=c$1 - 91 | 0;
                       switch(switcher$0)
                        {case 0:
                          var i$4=i$0 + 1 | 0,switch$2=0;
                          if(i$4 < len && 94 === caml_string_get(s,i$4))
                           {var
                             match$3=regexpclass1(i$4 + 1 | 0),
                             j$3=match$3[2],
                             c$4=match$3[1],
                             match$1=[0,c$4,1,j$3];
                            switch$2 = 1}
                          if(! switch$2)
                           var
                            match$4=regexpclass1(i$4),
                            j$4=match$4[2],
                            c$5=match$4[1],
                            match$1=[0,c$5,0,j$4];
                          var
                           j$1=match$1[3],
                           compl=match$1[2],
                           c$2=match$1[1],
                           match=[0,[2,c$2,compl],j$1];
                          break;
                         case 1:
                          var i$5=i$0 + 1 | 0;
                          if(len <= i$5)
                           var _C_=[0,_b_,i$5];
                          else
                           {var c$3=caml_string_get(s,i$5),switch$3=0;
                            if(58 <= c$3)
                             if(98 === c$3)
                              var _C_=[0,2,i$5 + 1 | 0];
                             else
                              if(124 === c$3)switch$3 = 2;else switch$3 = 1;
                            else
                             {var switcher$1=c$3 - 40 | 0;
                              if(1 < switcher$1 >>> 0)
                               if(9 <= switcher$1)
                                var _C_=[0,[9,c$3 - 48 | 0],i$5 + 1 | 0];
                               else
                                switch$3 = 1;
                              else
                               if(switcher$1)
                                switch$3 = 2;
                               else
                                {var group_no=group_counter[1];
                                 group_counter[1]++;
                                 var
                                  match$2=regexp0(i$5 + 1 | 0),
                                  j$2=match$2[2],
                                  r$4=match$2[1],
                                  switch$4=0;
                                 if
                                  ((j$2 + 1 | 0)
                                   <
                                   len
                                   &&
                                   92
                                   ===
                                   caml_string_get(s,j$2)
                                   &&
                                   41
                                   ===
                                   caml_string_get(s,j$2 + 1 | 0))
                                  {var _C_=[0,[8,group_no,r$4],j$2 + 2 | 0];switch$4 = 1}
                                 if(! switch$4)
                                  var _C_=caml_call1(Stdlib[2],cst_group_not_closed_by)}}
                            switch(switch$3)
                             {case 1:var _C_=[0,[0,c$3],i$5 + 1 | 0];break;
                              case 2:throw [0,Assert_failure,_c_]
                              }}
                          var match=_C_;
                          break;
                         case 2:switch$1 = 1;break;
                         default:var match=[0,0,i$0 + 1 | 0]}}
                    else
                     if(46 === c$1)
                      var match=[0,[2,dotclass,0],i$0 + 1 | 0];
                     else
                      switch$1 = 1;
                    if(switch$1)var match=[0,[0,c$1],i$0 + 1 | 0]}
                  var j=match[2],r=match[1],r$0=r,j$0=j;
                  for(;;)
                   {if(! (len <= j$0))
                     {var
                       match$0=caml_string_get(s,j$0),
                       switcher=match$0 - 42 | 0;
                      if(! (1 < switcher >>> 0))
                       {if(switcher)
                         {var i$2=j$0 + 1 | 0,r$2=[6,r$0],r$0=r$2,j$0=i$2;continue}
                        var i$3=j$0 + 1 | 0,r$3=[5,r$0],r$0=r$3,j$0=i$3;
                        continue}
                      if(21 === switcher)
                       {var i$1=j$0 + 1 | 0,r$1=[7,r$0],r$0=r$1,j$0=i$1;continue}}
                    var switch$5=0;
                    if(typeof r$0 !== "number" && 0 === r$0[0])
                     {var c=r$0[1];
                      caml_call2(Stdlib_buffer[10],sb[1],c);
                      switch$5 = 1}
                    if(! switch$5){flush(sb);sb[2] = [0,r$0,sb[2]]}
                    var i$0=j$0;
                    continue a}}}
              flush(sb);
              return [0,[3,caml_call1(Stdlib_list[9],sb[2])],i$0]}}
          function regexp0(i)
           {var match=regexp1(i),j=match[2],r=match[1],r1=r,i$0=j;
            for(;;)
             {if
               ((i$0 + 2 | 0)
                <=
                len
                &&
                92
                ===
                caml_string_get(s,i$0)
                &&
                124
                ===
                caml_string_get(s,i$0 + 1 | 0))
               {var
                 match$0=regexp1(i$0 + 2 | 0),
                 i$1=match$0[2],
                 r2=match$0[1],
                 r1$0=[4,r1,r2],
                 r1=r1$0,
                 i$0=i$1;
                continue}
              return [0,r1,i$0]}}
          var match=regexp0(0),j=match[2],r=match[1];
          return j === len
                  ?r
                  :caml_call1(Stdlib[2],cst_spurious_in_regular_expres)},
       regexp=function(e){return compile(0,parse(e))},
       regexp_case_fold=function(e){return compile(1,parse(e))},
       quote=
        function(s)
         {var
           len=caml_ml_string_length(s),
           buf=caml_create_bytes(2 * len | 0),
           pos=[0,0],
           _w_=len - 1 | 0,
           _v_=0;
          if(! (_w_ < 0))
           {var i=_v_;
            for(;;)
             {var c=caml_string_get(s,i),_x_=c - 63 | 0,switch$0=0;
              if(31 < _x_ >>> 0)
               {var _y_=_x_ + 27 | 0;
                if(! (10 < _y_ >>> 0))
                 switch(_y_){case 0:case 6:case 7:case 10:switch$0 = 1;break}}
              else
               if(26 < (_x_ - 1 | 0) >>> 0)switch$0 = 1;
              if(switch$0)
               {caml_bytes_set(buf,pos[1],92);
                caml_bytes_set(buf,pos[1] + 1 | 0,c);
                pos[1] = pos[1] + 2 | 0}
              else
               {caml_bytes_set(buf,pos[1],c);pos[1] = pos[1] + 1 | 0}
              var _z_=i + 1 | 0;
              if(_w_ !== i){var i=_z_;continue}
              break}}
          return caml_call3(Stdlib_bytes[8],buf,0,pos[1])},
       regexp_string=function(s){return compile(0,[1,s])},
       regexp_string_case_fold=function(s){return compile(1,[1,s])},
       last_search_result=[0,[0]],
       string_match=
        function(re,s,pos)
         {var res=runtime.re_string_match(re,s,pos);
          last_search_result[1] = res;
          return 0 < res.length - 1?1:0},
       string_partial_match=
        function(re,s,pos)
         {var res=runtime.re_partial_match(re,s,pos);
          last_search_result[1] = res;
          return 0 < res.length - 1?1:0},
       search_forward=
        function(re,s,pos)
         {var res=runtime.re_search_forward(re,s,pos);
          last_search_result[1] = res;
          if(0 === res.length - 1)throw Stdlib[8];
          return caml_check_bound(res,0)[1]},
       search_backward=
        function(re,s,pos)
         {var res=runtime.re_search_backward(re,s,pos);
          last_search_result[1] = res;
          if(0 === res.length - 1)throw Stdlib[8];
          return caml_check_bound(res,0)[1]},
       group_beginning=
        function(n)
         {var n2=n + n | 0;
          if(0 <= n && ! (last_search_result[1].length - 1 <= n2))
           {var pos=caml_check_bound(last_search_result[1],n2)[1 + n2];
            if(-1 === pos)throw Stdlib[8];
            return pos}
          return caml_call1(Stdlib[1],cst_Str_group_beginning)},
       group_end=
        function(n)
         {var n2=n + n | 0;
          if(0 <= n && ! (last_search_result[1].length - 1 <= n2))
           {var
             _u_=n2 + 1 | 0,
             pos=caml_check_bound(last_search_result[1],_u_)[1 + _u_];
            if(-1 === pos)throw Stdlib[8];
            return pos}
          return caml_call1(Stdlib[1],cst_Str_group_end)},
       matched_group=
        function(n,txt)
         {var n2=n + n | 0;
          if(0 <= n && ! (last_search_result[1].length - 1 <= n2))
           {var
             b=caml_check_bound(last_search_result[1],n2)[1 + n2],
             _t_=n2 + 1 | 0,
             e=caml_check_bound(last_search_result[1],_t_)[1 + _t_];
            if(-1 === b)throw Stdlib[8];
            return caml_call3(Stdlib_string[9],txt,b,e - b | 0)}
          return caml_call1(Stdlib[1],cst_Str_matched_group)},
       match_beginning=function(param){return group_beginning(0)},
       match_end=function(param){return group_end(0)},
       matched_string=function(txt){return matched_group(0,txt)},
       replace_matched=
        function(repl,matched)
         {return runtime.re_replacement_text
                  (repl,last_search_result[1],matched)},
       substitute_first=
        function(expr,repl_fun,text)
         {try
           {var
             pos=search_forward(expr,text,0),
             _o_=[0,string_after(text,match_end(0)),0],
             _p_=[0,caml_call1(repl_fun,text),_o_],
             _q_=[0,string_before(text,pos),_p_],
             _r_=caml_call2(Stdlib_string[3],cst$3,_q_);
            return _r_}
          catch(_s_)
           {_s_ = caml_wrap_exception(_s_);
            if(_s_ === Stdlib[8])return text;
            throw _s_}},
       opt_search_forward=
        function(re,s,pos)
         {try
           {var _m_=[0,search_forward(re,s,pos)];return _m_}
          catch(_n_)
           {_n_ = caml_wrap_exception(_n_);
            if(_n_ === Stdlib[8])return 0;
            throw _n_}},
       global_substitute=
        function(expr,repl_fun,text)
         {var accu=0,start=0,last_was_empty=0;
          for(;;)
           {var startpos=last_was_empty?start + 1 | 0:start;
            if(caml_ml_string_length(text) < startpos)
             var _k_=[0,string_after(text,start),accu];
            else
             {var match=opt_search_forward(expr,text,startpos);
              if(match)
               {var
                 pos=match[1],
                 start$0=match_end(0),
                 repl_text=caml_call1(repl_fun,text),
                 last_was_empty$0=start$0 === pos?1:0,
                 accu$0=
                  [0,
                   repl_text,
                   [0,
                    caml_call3(Stdlib_string[9],text,start,pos - start | 0),
                    accu]],
                 accu=accu$0,
                 start=start$0,
                 last_was_empty=last_was_empty$0;
                continue}
              var _k_=[0,string_after(text,start),accu]}
            var _l_=caml_call1(Stdlib_list[9],_k_);
            return caml_call2(Stdlib_string[3],cst$4,_l_)}},
       global_replace=
        function(expr,repl,text)
         {return global_substitute
                  (expr,function(_j_){return replace_matched(repl,_j_)},text)},
       replace_first=
        function(expr,repl,text)
         {return substitute_first
                  (expr,function(_i_){return replace_matched(repl,_i_)},text)},
       opt_search_forward_progress=
        function(expr,text,start)
         {var match=opt_search_forward(expr,text,start);
          if(match)
           {var pos=match[1];
            return start < match_end(0)
                    ?[0,pos]
                    :start < caml_ml_string_length(text)
                      ?opt_search_forward(expr,text,start + 1 | 0)
                      :0}
          return 0},
       bounded_split=
        function(expr,text,num)
         {var
           start=string_match(expr,text,0)?match_end(0):0,
           accu=0,
           start$0=start,
           n=num;
          for(;;)
           {if(caml_ml_string_length(text) <= start$0)
             var _h_=accu;
            else
             if(1 === n)
              var _h_=[0,string_after(text,start$0),accu];
             else
              {var match=opt_search_forward_progress(expr,text,start$0);
               if(match)
                {var
                  pos=match[1],
                  n$0=n - 1 | 0,
                  start$1=match_end(0),
                  accu$0=
                   [0,
                    caml_call3(Stdlib_string[9],text,start$0,pos - start$0 | 0),
                    accu],
                  accu=accu$0,
                  start$0=start$1,
                  n=n$0;
                 continue}
               var _h_=[0,string_after(text,start$0),accu]}
            return caml_call1(Stdlib_list[9],_h_)}},
       split=function(expr,text){return bounded_split(expr,text,0)},
       bounded_split_delim=
        function(expr,text,num)
         {if(caml_string_equal(text,cst$5))return 0;
          var accu=0,start=0,n=num;
          for(;;)
           {if(caml_ml_string_length(text) < start)
             var _g_=accu;
            else
             if(1 === n)
              var _g_=[0,string_after(text,start),accu];
             else
              {var match=opt_search_forward_progress(expr,text,start);
               if(match)
                {var
                  pos=match[1],
                  n$0=n - 1 | 0,
                  start$0=match_end(0),
                  accu$0=
                   [0,
                    caml_call3(Stdlib_string[9],text,start,pos - start | 0),
                    accu],
                  accu=accu$0,
                  start=start$0,
                  n=n$0;
                 continue}
               var _g_=[0,string_after(text,start),accu]}
            return caml_call1(Stdlib_list[9],_g_)}},
       split_delim=
        function(expr,text){return bounded_split_delim(expr,text,0)},
       bounded_full_split=
        function(expr,text,num)
         {var accu=0,start=0,n=num;
          for(;;)
           {if(caml_ml_string_length(text) <= start)
             var _f_=accu;
            else
             if(1 === n)
              var _f_=[0,[0,string_after(text,start)],accu];
             else
              {var match=opt_search_forward_progress(expr,text,start);
               if(match)
                {var pos=match[1],s=matched_string(text);
                 if(start < pos)
                  {var
                    n$0=n - 1 | 0,
                    start$0=match_end(0),
                    accu$0=
                     [0,
                      [1,s],
                      [0,
                       [0,caml_call3(Stdlib_string[9],text,start,pos - start | 0)],
                       accu]],
                    accu=accu$0,
                    start=start$0,
                    n=n$0;
                   continue}
                 var
                  n$1=n - 1 | 0,
                  start$1=match_end(0),
                  accu$1=[0,[1,s],accu],
                  accu=accu$1,
                  start=start$1,
                  n=n$1;
                 continue}
               var _f_=[0,[0,string_after(text,start)],accu]}
            return caml_call1(Stdlib_list[9],_f_)}},
       full_split=function(expr,text){return bounded_full_split(expr,text,0)},
       Str=
        [0,
         regexp,
         regexp_case_fold,
         quote,
         regexp_string,
         regexp_string_case_fold,
         string_match,
         search_forward,
         search_backward,
         string_partial_match,
         matched_string,
         match_beginning,
         match_end,
         matched_group,
         group_beginning,
         group_end,
         global_replace,
         replace_first,
         global_substitute,
         substitute_first,
         replace_matched,
         split,
         bounded_split,
         split_delim,
         bounded_split_delim,
         full_split,
         bounded_full_split,
         string_before,
         string_after,
         first_chars,
         last_chars];
      runtime.caml_register_global(26,Str,"Str");
      return}}
  (function(){return this}()));


//# 1 ".js/uutf/uutf.cma.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_blit_bytes=runtime.caml_blit_bytes,
     caml_bytes_unsafe_get=runtime.caml_bytes_unsafe_get,
     caml_check_bound=runtime.caml_check_bound,
     caml_create_bytes=runtime.caml_create_bytes,
     caml_ml_bytes_length=runtime.caml_ml_bytes_length,
     caml_ml_string_length=runtime.caml_ml_string_length,
     caml_string_compare=runtime.caml_string_compare,
     caml_string_get=runtime.caml_string_get,
     caml_string_notequal=runtime.caml_string_notequal,
     caml_string_of_jsbytes=runtime.caml_string_of_jsbytes;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    var
     global_data=runtime.caml_get_global_data(),
     cst_UTF_8$0=caml_string_of_jsbytes("UTF-8"),
     cst_US_ASCII$0=caml_string_of_jsbytes("US-ASCII"),
     cst_ISO_8859_1$1=caml_string_of_jsbytes("ISO-8859-1"),
     cst_UTF_16$0=caml_string_of_jsbytes("UTF-16"),
     cst_UTF_16LE$0=caml_string_of_jsbytes("UTF-16LE"),
     cst_UTF_16BE$0=caml_string_of_jsbytes("UTF-16BE"),
     cst_ISO646_US=caml_string_of_jsbytes("ISO646-US"),
     cst_CSISOLATIN1=caml_string_of_jsbytes("CSISOLATIN1"),
     cst_ANSI_X3_4_1968=caml_string_of_jsbytes("ANSI_X3.4-1968"),
     cst_ANSI_X3_4_1986=caml_string_of_jsbytes("ANSI_X3.4-1986"),
     cst_ASCII=caml_string_of_jsbytes("ASCII"),
     cst_CP367=caml_string_of_jsbytes("CP367"),
     cst_CP819=caml_string_of_jsbytes("CP819"),
     cst_CSASCII=caml_string_of_jsbytes("CSASCII"),
     cst_IBM367=caml_string_of_jsbytes("IBM367"),
     cst_IBM819=caml_string_of_jsbytes("IBM819"),
     cst_ISO_8859_1$0=caml_string_of_jsbytes("ISO-8859-1"),
     cst_ISO_IR_100=caml_string_of_jsbytes("ISO-IR-100"),
     cst_ISO_IR_6=caml_string_of_jsbytes("ISO-IR-6"),
     cst_US=caml_string_of_jsbytes("US"),
     cst_ISO_646_IRV_1991=caml_string_of_jsbytes("ISO_646.IRV:1991"),
     cst_ISO_8859_1=caml_string_of_jsbytes("ISO_8859-1"),
     cst_ISO_8859_1_1987=caml_string_of_jsbytes("ISO_8859-1:1987"),
     cst_L1=caml_string_of_jsbytes("L1"),
     cst_LATIN1=caml_string_of_jsbytes("LATIN1"),
     cst_US_ASCII=caml_string_of_jsbytes("US-ASCII"),
     cst_UTF_16=caml_string_of_jsbytes("UTF-16"),
     cst_UTF_16BE=caml_string_of_jsbytes("UTF-16BE"),
     cst_UTF_16LE=caml_string_of_jsbytes("UTF-16LE"),
     cst_UTF_8=caml_string_of_jsbytes("UTF-8"),
     cst_expected_Await_encode=
      caml_string_of_jsbytes("expected `Await encode"),
     Stdlib_uchar=global_data.Stdlib__uchar,
     Stdlib_buffer=global_data.Stdlib__buffer,
     Stdlib_bytes=global_data.Stdlib__bytes,
     Stdlib=global_data.Stdlib,
     Assert_failure=global_data.Assert_failure,
     Stdlib_string=global_data.Stdlib__string,
     Stdlib_printf=global_data.Stdlib__printf,
     Stdlib_format=global_data.Stdlib__format,
     _a_=Stdlib_format[126],
     _B_=[0,caml_string_of_jsbytes("src/uutf.ml"),364,9],
     _u_=
      [0,
       [11,caml_string_of_jsbytes("`Await"),0],
       caml_string_of_jsbytes("`Await")],
     _v_=
      [0,[11,caml_string_of_jsbytes("`End"),0],caml_string_of_jsbytes("`End")],
     _w_=
      [0,
       [18,
        [1,[0,0,caml_string_of_jsbytes("")]],
        [11,caml_string_of_jsbytes("`Uchar U+"),[4,8,[0,2,4],0,[17,0,0]]]],
       caml_string_of_jsbytes("@[`Uchar U+%04X@]")],
     _x_=
      [0,
       [18,
        [1,[0,0,caml_string_of_jsbytes("")]],
        [11,caml_string_of_jsbytes("`Malformed ("),0]],
       caml_string_of_jsbytes("@[`Malformed (")],
     _y_=[0,[4,8,[0,2,2],0,0],caml_string_of_jsbytes("%02X")],
     _A_=[0,[12,32,[4,8,[0,2,2],0,0]],caml_string_of_jsbytes(" %02X")],
     _z_=[0,[12,41,[17,0,0]],caml_string_of_jsbytes(")@]")],
     _p_=[0,-211555818,3299808],
     _k_=[0,-211558048,3299808],
     _q_=[0,684370880,3299808],
     _o_=[0,684370880,427938126],
     _l_=[0,-211558048,427938126],
     _m_=[0,caml_string_of_jsbytes("src/uutf.ml"),154,55],
     _n_=[0,684370880,427938126],
     _r_=[0,caml_string_of_jsbytes("src/uutf.ml"),153,55],
     _s_=[0,caml_string_of_jsbytes("src/uutf.ml"),155,55],
     _t_=[0,684370880,3455931],
     _j_=[0,caml_string_of_jsbytes("src/uutf.ml"),121,9],
     _c_=[0,684370880],
     _d_=[0,-211555818],
     _e_=[0,-211558048],
     _f_=[0,143365725],
     _g_=[0,423112016],
     _h_=[0,338302576],
     _b_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid bounds (index "),
        [4,0,0,0,[11,caml_string_of_jsbytes(", length "),[4,0,0,0,[12,41,0]]]]],
       caml_string_of_jsbytes("invalid bounds (index %d, length %d)")],
     _i_=
      [0,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       3,
       3,
       3,
       3,
       3,
       3,
       3,
       3,
       3,
       3,
       3,
       3,
       3,
       3,
       3,
       3,
       4,
       4,
       4,
       4,
       4,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0];
    function invalid_bounds(j,l)
     {var _aF_=caml_call3(Stdlib_printf[4],_b_,j,l);
      return caml_call1(Stdlib[1],_aF_)}
    function unsafe_set_byte(s,j,byte$0)
     {runtime.caml_bytes_unsafe_set(s,j,byte$0);return 0}
    var
     u_bom=caml_call1(Stdlib_uchar[9],65279),
     u_rep=caml_call1(Stdlib_uchar[9],65533);
    function encoding_of_string(s)
     {var
       match=caml_call1(Stdlib_string[35],s),
       _aD_=caml_string_compare(match,cst_ISO646_US),
       switch$1=0;
      if(0 <= _aD_)
       {if(0 < _aD_)
         {var switch$0=caml_string_compare(match,cst_US);
          if(0 <= switch$0)
           {if(0 < switch$0 && caml_string_notequal(match,cst_US_ASCII))
             {if(! caml_string_notequal(match,cst_UTF_16))return _f_;
              if(! caml_string_notequal(match,cst_UTF_16BE))return _e_;
              if(! caml_string_notequal(match,cst_UTF_16LE))return _d_;
              if(! caml_string_notequal(match,cst_UTF_8))return _c_;
              switch$1 = 2}}
          else
           if(caml_string_notequal(match,cst_ISO_646_IRV_1991))
            if
             (caml_string_notequal(match,cst_ISO_8859_1)
              &&
              caml_string_notequal(match,cst_ISO_8859_1_1987)
              &&
              caml_string_notequal(match,cst_L1)
              &&
              caml_string_notequal(match,cst_LATIN1))
             switch$1 = 2;
            else
             switch$1 = 1}}
      else
       {var _aE_=caml_string_compare(match,cst_CSISOLATIN1);
        if(0 <= _aE_)
         if(0 < _aE_)
          {if(caml_string_notequal(match,cst_IBM367))
            if
             (caml_string_notequal(match,cst_IBM819)
              &&
              caml_string_notequal(match,cst_ISO_8859_1$0)
              &&
              caml_string_notequal(match,cst_ISO_IR_100))
             {if(caml_string_notequal(match,cst_ISO_IR_6))switch$1 = 2}
            else
             switch$1 = 1}
         else
          switch$1 = 1;
        else
         if
          (caml_string_notequal(match,cst_ANSI_X3_4_1968)
           &&
           caml_string_notequal(match,cst_ANSI_X3_4_1986)
           &&
           caml_string_notequal(match,cst_ASCII)
           &&
           caml_string_notequal(match,cst_CP367))
          if(caml_string_notequal(match,cst_CP819))
           {if(caml_string_notequal(match,cst_CSASCII))switch$1 = 2}
          else
           switch$1 = 1}
      switch(switch$1){case 2:return 0;case 0:return _g_;default:return _h_}}
    function encoding_to_string(param)
     {return 143365725 <= param
              ?423112016 <= param
                ?684370880 <= param?cst_UTF_8$0:cst_US_ASCII$0
                :338302576 <= param?cst_ISO_8859_1$1:cst_UTF_16$0
              :-211555818 <= param?cst_UTF_16LE$0:cst_UTF_16BE$0}
    function malformed(s,j,l)
     {return [0,659980059,caml_call3(Stdlib_bytes[8],s,j,l)]}
    function malformed_pair(be,hi,s,j,l)
     {var bs1=caml_call3(Stdlib_bytes[7],s,j,l),bs0=caml_create_bytes(2);
      if(be)var j1=1,j0=0;else var j1=0,j0=1;
      unsafe_set_byte(bs0,j0,hi >>> 8 | 0);
      unsafe_set_byte(bs0,j1,hi & 255);
      var _aC_=caml_call2(Stdlib_bytes[14],bs0,bs1);
      return [0,659980059,caml_call1(Stdlib_bytes[42],_aC_)]}
    var utf_8_len=_i_.slice();
    function r_utf_8(s,j,l)
     {function uchar(c){return [0,852405675,caml_call1(Stdlib_uchar[9],c)]}
      var switcher=l - 1 | 0;
      if(3 < switcher >>> 0)throw [0,Assert_failure,_j_];
      switch(switcher)
       {case 0:return uchar(caml_bytes_unsafe_get(s,j));
        case 1:
         var
          b0=caml_bytes_unsafe_get(s,j),
          b1=caml_bytes_unsafe_get(s,j + 1 | 0);
         return 2 === (b1 >>> 6 | 0)
                 ?uchar((b0 & 31) << 6 | b1 & 63)
                 :malformed(s,j,l);
        case 2:
         var
          b0$0=caml_bytes_unsafe_get(s,j),
          b1$0=caml_bytes_unsafe_get(s,j + 1 | 0),
          b2=caml_bytes_unsafe_get(s,j + 2 | 0),
          c=(b0$0 & 15) << 12 | (b1$0 & 63) << 6 | b2 & 63;
         if(2 === (b2 >>> 6 | 0))
          {if(224 === b0$0)
            {if(160 <= b1$0 && ! (191 < b1$0))return uchar(c);
             return malformed(s,j,l)}
           if(237 === b0$0)
            {if(128 <= b1$0 && ! (159 < b1$0))return uchar(c);
             return malformed(s,j,l)}
           return 2 === (b1$0 >>> 6 | 0)?uchar(c):malformed(s,j,l)}
         return malformed(s,j,l);
        default:
         var
          b0$1=caml_bytes_unsafe_get(s,j),
          b1$1=caml_bytes_unsafe_get(s,j + 1 | 0),
          b2$0=caml_bytes_unsafe_get(s,j + 2 | 0),
          b3=caml_bytes_unsafe_get(s,j + 3 | 0),
          c$0=
           (b0$1 & 7)
           <<
           18
           |
           (b1$1 & 63)
           <<
           12
           |
           (b2$0 & 63)
           <<
           6
           |
           b3
           &
           63;
         if(2 === (b3 >>> 6 | 0) && 2 === (b2$0 >>> 6 | 0))
          {if(240 === b0$1)
            {if(144 <= b1$1 && ! (191 < b1$1))return uchar(c$0);
             return malformed(s,j,l)}
           if(244 === b0$1)
            {if(128 <= b1$1 && ! (143 < b1$1))return uchar(c$0);
             return malformed(s,j,l)}
           return 2 === (b1$1 >>> 6 | 0)?uchar(c$0):malformed(s,j,l)}
         return malformed(s,j,l)}}
    function r_utf_16(s,j0,j1)
     {var
       b0=caml_bytes_unsafe_get(s,j0),
       b1=caml_bytes_unsafe_get(s,j1),
       u=b0 << 8 | b1;
      if(55296 <= u && ! (57343 < u))
       return 56319 < u
               ?malformed(s,caml_call2(Stdlib[16],j0,j1),2)
               :[0,16161,u];
      return [0,852405675,caml_call1(Stdlib_uchar[9],u)]}
    function r_utf_16_lo(hi,s,j0,j1)
     {var
       b0=caml_bytes_unsafe_get(s,j0),
       b1=caml_bytes_unsafe_get(s,j1),
       lo=b0 << 8 | b1;
      if(56320 <= lo && ! (57343 < lo))
       return [0,
               852405675,
               caml_call1
                (Stdlib_uchar[9],((hi & 1023) << 10 | lo & 1023) + 65536 | 0)];
      return malformed_pair(j0 < j1?1:0,hi,s,caml_call2(Stdlib[16],j0,j1),2)}
    function r_encoding(s,j,l)
     {function some(i){return i < l?[0,caml_bytes_unsafe_get(s,j + i | 0)]:0}
      var match=some(0),match$0=some(1),match$1=some(2);
      if(match)
       {var _aB_=match[1],switch$0=0;
        if(240 <= _aB_)
         if(254 === _aB_)
          {if(match$0){if(255 === match$0[1])return _k_;switch$0 = 1}}
         else
          if(255 === _aB_)
           {if(match$0){if(254 === match$0[1])return _p_;switch$0 = 1}}
          else
           switch$0 = 1;
        else
         if(0 === _aB_)
          {if(match$0)
            {var p=match$0[1];
             if(0 < p)return [0,-211558048,[0,605782321,p]];
             switch$0 = 1}}
         else
          if(239 <= _aB_)
           {if(match$0)
             if(187 === match$0[1])
              {if(match$1 && 191 === match$1[1])return _q_}
             else
              switch$0 = 1}
          else
           switch$0 = 1;
        if(switch$0 && match$0 && 0 === match$0[1] && 0 < _aB_)
         return [0,-211555818,[0,605782321,_aB_]];
        if(0 === caml_check_bound(utf_8_len,_aB_)[1 + _aB_])
         {if(match$0)return _l_;
          if(match$1)throw [0,Assert_failure,_m_];
          return _n_}
        return _o_}
      if(match$0)throw [0,Assert_failure,_r_];
      if(match$1)throw [0,Assert_failure,_s_];
      return _t_}
    function pp_decode(ppf,param)
     {if(typeof param === "number")
       return 1006505782 <= param
               ?caml_call2(_a_,ppf,_u_)
               :caml_call2(_a_,ppf,_v_);
      if(852405675 <= param[1])
       {var u=param[2];
        return caml_call3(_a_,ppf,_w_,caml_call1(Stdlib_uchar[10],u))}
      var bs=param[2],l=caml_ml_string_length(bs);
      caml_call2(_a_,ppf,_x_);
      if(0 < l)caml_call3(_a_,ppf,_y_,caml_string_get(bs,0));
      var _az_=l - 1 | 0,_ay_=1;
      if(! (_az_ < 1))
       {var i=_ay_;
        for(;;)
         {caml_call3(_a_,ppf,_A_,caml_string_get(bs,i));
          var _aA_=i + 1 | 0;
          if(_az_ !== i){var i=_aA_;continue}
          break}}
      return caml_call2(_a_,ppf,_z_)}
    function i_rem(d){return (d[7] - d[6] | 0) + 1 | 0}
    function eoi(d)
     {d[5] = Stdlib_bytes[3];d[6] = 0;d[7] = Stdlib[20];return 0}
    function src(d,s,j,l)
     {if(0 <= j && 0 <= l && ! (caml_ml_bytes_length(s) < (j + l | 0)))
       return 0 === l?eoi(d):(d[5] = s,d[6] = j,d[7] = (j + l | 0) - 1 | 0,0);
      return invalid_bounds(j,l)}
    function refill(k,d)
     {var _ax_=d[1];
      if(typeof _ax_ === "number"){d[18] = k;return 1006505782}
      if(438511779 <= _ax_[1])
       {var
         ic=_ax_[2],
         rc=caml_call4(Stdlib[84],ic,d[5],0,caml_ml_bytes_length(d[5]));
        src(d,d[5],0,rc);
        return caml_call1(k,d)}
      eoi(d);
      return caml_call1(k,d)}
    function t_need(d,need){d[9] = 0;d[10] = need;return 0}
    function t_fill(k,d)
     {function blit(d,l)
       {caml_blit_bytes(d[5],d[6],d[8],d[9],l);
        d[6] = d[6] + l | 0;
        d[9] = d[9] + l | 0;
        return 0}
      var rem=i_rem(d);
      if(0 <= rem)
       {var need=d[10] - d[9] | 0;
        return rem < need
                ?(blit(d,rem),refill(function(_aw_){return t_fill(k,_aw_)},d))
                :(blit(d,need),caml_call1(k,d))}
      return caml_call1(k,d)}
    function ret(k,v,byte_count,d)
     {d[18] = k;d[15] = d[15] + byte_count | 0;return caml_call2(d[17],d,v)}
    function decode_us_ascii(d)
     {var rem=i_rem(d);
      if(0 < rem)
       {var j=d[6];
        d[6] = d[6] + 1 | 0;
        var
         _au_=d[5],
         b0=caml_bytes_unsafe_get(_au_,j),
         _at_=1,
         _av_=
          127 < b0
           ?malformed(_au_,j,1)
           :[0,852405675,caml_call1(Stdlib_uchar[9],b0)];
        return ret(decode_us_ascii,_av_,_at_,d)}
      return 0 <= rem?refill(decode_us_ascii,d):3455931}
    function decode_iso_8859_1(d)
     {var rem=i_rem(d);
      if(0 < rem)
       {var j=d[6];
        d[6] = d[6] + 1 | 0;
        return ret
                (decode_iso_8859_1,
                 [0,
                  852405675,
                  caml_call1(Stdlib_uchar[9],caml_bytes_unsafe_get(d[5],j))],
                 1,
                 d)}
      return 0 <= rem?refill(decode_iso_8859_1,d):3455931}
    function t_decode_utf_8(d)
     {if(d[9] < d[10])
       {var _ar_=d[9];return ret(decode_utf_8,malformed(d[8],0,d[9]),_ar_,d)}
      var _as_=d[9];
      return ret(decode_utf_8,r_utf_8(d[8],0,d[9]),_as_,d)}
    function decode_utf_8(d)
     {var rem=i_rem(d);
      if(0 < rem)
       {var need=utf_8_len[1 + caml_bytes_unsafe_get(d[5],d[6])];
        if(rem < need){t_need(d,need);return t_fill(t_decode_utf_8,d)}
        var j=d[6];
        return 0 === need
                ?(d[6]
                  =
                  d[6]
                  +
                  1
                  |
                  0,
                  ret(decode_utf_8,malformed(d[5],j,1),1,d))
                :(d[6]
                  =
                  d[6]
                  +
                  need
                  |
                  0,
                  ret(decode_utf_8,r_utf_8(d[5],j,need),need,d))}
      return 0 <= rem?refill(decode_utf_8,d):3455931}
    function t_decode_utf_16be_lo(hi,d)
     {var bcount=d[9] + 2 | 0;
      return d[9] < d[10]
              ?ret(decode_utf_16be,malformed_pair(1,hi,d[8],0,d[9]),bcount,d)
              :ret(decode_utf_16be,r_utf_16_lo(hi,d[8],0,1),bcount,d)}
    function decode_utf_16be_lo(v,d)
     {if(659980059 <= v[1])return ret(decode_utf_16be,v,2,d);
      var hi=v[2],rem=i_rem(d);
      if(2 <= rem)
       {var j=d[6];
        d[6] = d[6] + 2 | 0;
        return ret(decode_utf_16be,r_utf_16_lo(hi,d[5],j,j + 1 | 0),4,d)}
      t_need(d,2);
      return t_fill(function(_aq_){return t_decode_utf_16be_lo(hi,_aq_)},d)}
    function t_decode_utf_16be(d)
     {if(d[9] < d[10])
       {var _ap_=d[9];
        return ret(decode_utf_16be,malformed(d[8],0,d[9]),_ap_,d)}
      return decode_utf_16be_lo(r_utf_16(d[8],0,1),d)}
    function decode_utf_16be(d)
     {var rem=i_rem(d);
      if(0 < rem)
       {if(2 <= rem)
         {var j=d[6];
          d[6] = d[6] + 2 | 0;
          return decode_utf_16be_lo(r_utf_16(d[5],j,j + 1 | 0),d)}
        t_need(d,2);
        return t_fill(t_decode_utf_16be,d)}
      return 0 <= rem?refill(decode_utf_16be,d):3455931}
    function t_decode_utf_16_lo(hi,d)
     {var bcount=d[9] + 2 | 0;
      return d[9] < d[10]
              ?ret(decode_utf_16,malformed_pair(0,hi,d[8],0,d[9]),bcount,d)
              :ret(decode_utf_16,r_utf_16_lo(hi,d[8],1,0),bcount,d)}
    function decode_utf_16le_lo(v,d)
     {if(659980059 <= v[1])return ret(decode_utf_16,v,2,d);
      var hi=v[2],rem=i_rem(d);
      if(2 <= rem)
       {var j=d[6];
        d[6] = d[6] + 2 | 0;
        return ret(decode_utf_16,r_utf_16_lo(hi,d[5],j + 1 | 0,j),4,d)}
      t_need(d,2);
      return t_fill(function(_ao_){return t_decode_utf_16_lo(hi,_ao_)},d)}
    function t_decode_utf_16(d)
     {if(d[9] < d[10])
       {var _an_=d[9];return ret(decode_utf_16,malformed(d[8],0,d[9]),_an_,d)}
      return decode_utf_16le_lo(r_utf_16(d[8],1,0),d)}
    function decode_utf_16(d)
     {var rem=i_rem(d);
      if(0 < rem)
       {if(2 <= rem)
         {var j=d[6];
          d[6] = d[6] + 2 | 0;
          return decode_utf_16le_lo(r_utf_16(d[5],j + 1 | 0,j),d)}
        t_need(d,2);
        return t_fill(t_decode_utf_16,d)}
      return 0 <= rem?refill(decode_utf_16,d):3455931}
    function guessed_utf_16(d,be,v)
     {if(be)
       var
        j1=1,
        j0=0,
        t_decode_utf_16_lo$0=t_decode_utf_16be_lo,
        t_decode_utf_16$0=t_decode_utf_16be,
        decode_utf_16$0=decode_utf_16be;
      else
       var
        j1=0,
        j0=1,
        t_decode_utf_16_lo$0=t_decode_utf_16_lo,
        t_decode_utf_16$0=t_decode_utf_16,
        decode_utf_16$0=decode_utf_16;
      function b3(k,d)
       {return 3 <= d[9]
                ?(d[10]
                  =
                  2,
                  d[9]
                  =
                  1,
                  unsafe_set_byte(d[8],0,caml_bytes_unsafe_get(d[8],2)),
                  t_fill(k,d))
                :decode_utf_16$0(d)}
      if(typeof v === "number")
       {if(427938126 <= v)
         {var v$0=r_utf_16(d[8],j0,j1);
          if(659980059 <= v$0[1])
           {var _ad_=2;
            return ret
                    (function(_am_){return b3(t_decode_utf_16$0,_am_)},
                     v$0,
                     _ad_,
                     d)}
          var hi=v$0[2];
          if(3 <= d[9])
           return b3(function(_al_){return t_decode_utf_16_lo$0(hi,_al_)},d);
          var _ae_=d[9];
          return ret
                  (decode_utf_16$0,
                   malformed_pair(be,hi,Stdlib_bytes[3],0,0),
                   _ae_,
                   d)}
        var _af_=2,_ag_=[0,852405675,u_bom];
        return ret
                (function(_ak_){return b3(t_decode_utf_16$0,_ak_)},
                 _ag_,
                 _af_,
                 d)}
      var u=v[2],_ah_=2,_ai_=[0,852405675,caml_call1(Stdlib_uchar[9],u)];
      return ret
              (function(_aj_){return b3(t_decode_utf_16$0,_aj_)},_ai_,_ah_,d)}
    function k(d)
     {function setup(d)
       {var match=r_encoding(d[8],0,d[9]),_ac_=match[1];
        if(-211555818 === _ac_)
         {var r=match[2];
          d[2] = -211555818;
          d[18] = decode_utf_16;
          return guessed_utf_16(d,0,r)}
        if(684370880 <= _ac_)
         {var r$0=match[2];
          d[2] = 684370880;
          d[18] = decode_utf_8;
          if(3455931 === r$0)return 3455931;
          if(427938126 <= r$0)
           {var
             b3=
              function(d)
               {var
                 b3=caml_bytes_unsafe_get(d[8],2),
                 n=caml_check_bound(utf_8_len,b3)[1 + b3];
                return 0 === n
                        ?ret(decode_utf_8,malformed(d[8],2,1),1,d)
                        :(d[10]
                          =
                          n,
                          d[9]
                          =
                          1,
                          unsafe_set_byte(d[8],0,b3),
                          t_fill(t_decode_utf_8,d))},
             b2=
              function(d)
               {var
                 b2=caml_bytes_unsafe_get(d[8],1),
                 b3$0=2 < d[9]?b3:decode_utf_8,
                 n=caml_check_bound(utf_8_len,b2)[1 + b2];
                if(0 === n)return ret(b3$0,malformed(d[8],1,1),1,d);
                if(1 === n)return ret(b3$0,r_utf_8(d[8],1,1),1,d);
                d[10] = n;
                unsafe_set_byte(d[8],0,b2);
                if(3 <= d[9])
                 {d[9] = 2;
                  unsafe_set_byte(d[8],1,caml_bytes_unsafe_get(d[8],2))}
                else
                 d[9] = 1;
                return t_fill(t_decode_utf_8,d)},
             b1=caml_bytes_unsafe_get(d[8],0),
             b2$0=1 < d[9]?b2:decode_utf_8,
             n=caml_check_bound(utf_8_len,b1)[1 + b1];
            if(4 < n >>> 0)throw [0,Assert_failure,_B_];
            switch(n)
             {case 0:return ret(b2$0,malformed(d[8],0,1),1,d);
              case 1:return ret(b2$0,r_utf_8(d[8],0,1),1,d);
              case 2:
               return 2 <= d[9]
                       ?3 <= d[9]
                         ?ret(b3,r_utf_8(d[8],0,2),2,d)
                         :ret(decode_utf_8,r_utf_8(d[8],0,2),2,d)
                       :ret(decode_utf_8,malformed(d[8],0,1),1,d);
              case 3:
               if(3 <= d[9])return ret(decode_utf_8,r_utf_8(d[8],0,3),3,d);
               var _aa_=d[9];
               return ret(decode_utf_8,malformed(d[8],0,d[9]),_aa_,d);
              default:
               if(3 <= d[9]){d[10] = 4;return t_fill(t_decode_utf_8,d)}
               var _ab_=d[9];
               return ret(decode_utf_8,malformed(d[8],0,d[9]),_ab_,d)}}
          return ret(decode_utf_8,[0,852405675,u_bom],3,d)}
        var r$1=match[2];
        d[2] = -211558048;
        d[18] = decode_utf_16be;
        return guessed_utf_16(d,1,r$1)}
      t_need(d,3);
      return t_fill(setup,d)}
    function nline(d){d[14] = 0;d[13] = d[13] + 1 | 0;return 0}
    function ncol(d){d[14] = d[14] + 1 | 0;return 0}
    function ncount(d){d[16] = d[16] + 1 | 0;return 0}
    function cr(d,b){d[12] = b;return 0}
    function pp(d,v)
     {if(852405675 <= v[1])
       {var
         u=v[2],
         match=caml_call1(Stdlib_uchar[10],u),
         _$_=match - 133 | 0,
         switch$0=0;
        if(8100 < _$_ >>> 0)
         {var switcher=_$_ + 123 | 0;
          if(! (3 < switcher >>> 0))
           switch(switcher)
            {case 0:
              var last_cr=d[12];
              cr(d,0);
              ncount(d);
              return last_cr?v:(nline(d),v);
             case 1:break;
             case 2:switch$0 = 1;break;
             default:cr(d,1);ncount(d);nline(d);return v}}
        else
         if(8097 < (_$_ - 1 | 0) >>> 0)switch$0 = 1;
        return switch$0
                ?(cr(d,0),ncount(d),nline(d),v)
                :(cr(d,0),ncount(d),ncol(d),v)}
      cr(d,0);
      ncount(d);
      ncol(d);
      return v}
    function pp_nln_readline(d,v)
     {if(852405675 <= v[1])
       {var
         u=v[2],
         match=caml_call1(Stdlib_uchar[10],u),
         ___=match - 133 | 0,
         switch$0=0;
        if(8100 < ___ >>> 0)
         {var switcher=___ + 123 | 0;
          if(! (3 < switcher >>> 0))
           switch(switcher)
            {case 0:
              var last_cr=d[12];
              cr(d,0);
              return last_cr
                      ?caml_call1(d[18],d)
                      :(ncount(d),nline(d),[0,852405675,d[4]]);
             case 1:break;
             case 2:switch$0 = 1;break;
             default:cr(d,1);ncount(d);nline(d);return [0,852405675,d[4]]}}
        else
         if(8097 < (___ - 1 | 0) >>> 0)switch$0 = 1;
        return switch$0
                ?(cr(d,0),ncount(d),nline(d),[0,852405675,d[4]])
                :(cr(d,0),ncount(d),ncol(d),v)}
      cr(d,0);
      ncount(d);
      ncol(d);
      return v}
    function pp_nln_nlf(d,v)
     {if(852405675 <= v[1])
       {var u=v[2],match=caml_call1(Stdlib_uchar[10],u),switch$0=0;
        if(14 <= match)
         {if(8232 <= match)
           {if(! (8234 <= match))switch$0 = 1}
          else
           if(133 === match)
            {cr(d,0);ncount(d);nline(d);return [0,852405675,d[4]]}}
        else
         if(10 <= match)
          {var switcher=match - 10 | 0;
           switch(switcher)
            {case 0:
              var last_cr=d[12];
              cr(d,0);
              return last_cr
                      ?caml_call1(d[18],d)
                      :(ncount(d),nline(d),[0,852405675,d[4]]);
             case 1:break;
             case 2:switch$0 = 1;break;
             default:cr(d,1);ncount(d);nline(d);return [0,852405675,d[4]]}}
        return switch$0
                ?(cr(d,0),ncount(d),nline(d),v)
                :(cr(d,0),ncount(d),ncol(d),v)}
      cr(d,0);
      ncount(d);
      ncol(d);
      return v}
    function pp_nln_ascii(d,v)
     {if(852405675 <= v[1])
       {var
         u=v[2],
         match=caml_call1(Stdlib_uchar[10],u),
         _Z_=match - 133 | 0,
         switch$0=0;
        if(8100 < _Z_ >>> 0)
         {var switcher=_Z_ + 123 | 0;
          if(! (3 < switcher >>> 0))
           switch(switcher)
            {case 0:
              var last_cr=d[12];
              cr(d,0);
              return last_cr
                      ?caml_call1(d[18],d)
                      :(ncount(d),nline(d),[0,852405675,d[4]]);
             case 1:break;
             case 2:switch$0 = 1;break;
             default:cr(d,1);ncount(d);nline(d);return [0,852405675,d[4]]}}
        else
         if(8097 < (_Z_ - 1 | 0) >>> 0)switch$0 = 1;
        return switch$0
                ?(cr(d,0),ncount(d),nline(d),v)
                :(cr(d,0),ncount(d),ncol(d),v)}
      cr(d,0);
      ncount(d);
      ncol(d);
      return v}
    function decode_fun(param)
     {return 143365725 <= param
              ?423112016 <= param
                ?684370880 <= param?decode_utf_8:decode_us_ascii
                :338302576 <= param?decode_iso_8859_1:decode_utf_16be
              :-211555818 <= param?decode_utf_16:decode_utf_16be}
    function decoder(nln,encoding,src)
     {if(nln)
       {var _X_=nln[1],_Y_=_X_[1];
        if(3895880 === _Y_)
         var nl=_X_[2],nl$0=nl,pp$0=pp_nln_nlf;
        else
         if(605782321 <= _Y_)
          var nl$1=_X_[2],nl$0=nl$1,pp$0=pp_nln_ascii;
         else
          var nl$2=_X_[2],nl$0=nl$2,pp$0=pp_nln_readline}
      else
       var nl$3=caml_call1(Stdlib_uchar[9],10),nl$0=nl$3,pp$0=pp;
      if(encoding)
       var e=encoding[1],k$0=decode_fun(e),encoding$0=e;
      else
       var k$0=k,encoding$0=684370880;
      if(typeof src === "number")
       var i_max=0,i_pos=1,i=Stdlib_bytes[3];
      else
       if(438511779 <= src[1])
        var i_max=0,i_pos=1,i=caml_create_bytes(65536);
       else
        var
         s=src[2],
         i_max$0=caml_ml_string_length(s) - 1 | 0,
         i$0=caml_call1(Stdlib_bytes[43],s),
         i_max=i_max$0,
         i_pos=0,
         i=i$0;
      var utf16=143365725 === encoding$0?1:0;
      return [0,
              src,
              encoding$0,
              nln,
              nl$0,
              i,
              i_pos,
              i_max,
              caml_create_bytes(4),
              0,
              0,
              0,
              0,
              1,
              0,
              0,
              0,
              function(d,v)
               {if(852405675 <= v[1])
                 {var u=v[2],match=caml_call1(Stdlib_uchar[10],u);
                  if(65279 === match)
                   {if(utf16){d[2] = -211558048;d[18] = decode_utf_16be}
                    d[11] = 1;
                    d[17] = pp$0;
                    return caml_call1(d[18],d)}
                  if(65534 === match && utf16)
                   {d[2] = -211555818;
                    d[18] = decode_utf_16;
                    d[11] = 1;
                    d[17] = pp$0;
                    return caml_call1(d[18],d)}
                  d[11] = 0;
                  d[17] = pp$0;
                  return caml_call2(d[17],d,v)}
                d[11] = 0;
                d[17] = pp$0;
                return caml_call2(d[17],d,v)},
              k$0]}
    function decode(d){return caml_call1(d[18],d)}
    function decoder_line(d){return d[13]}
    function decoder_col(d){return d[14]}
    function decoder_byte_count(d){return d[15]}
    function decoder_count(d){return d[16]}
    function decoder_removed_bom(d){return d[11]}
    function decoder_src(d){return d[1]}
    function decoder_nln(d){return d[3]}
    function decoder_encoding(d){return d[2]}
    function set_decoder_encoding(d,e)
     {d[2] = e;d[18] = decode_fun(e);return 0}
    function o_rem(e){return (e[5] - e[4] | 0) + 1 | 0}
    function dst(e,s,j,l)
     {var _U_=j < 0?1:0;
      if(_U_)
       var _V_=_U_;
      else
       var
        _W_=l < 0?1:0,
        _V_=_W_ || (caml_ml_bytes_length(s) < (j + l | 0)?1:0);
      if(_V_)invalid_bounds(j,l);
      e[3] = s;
      e[4] = j;
      e[5] = (j + l | 0) - 1 | 0;
      return 0}
    function flush(k,e)
     {var _T_=e[1];
      if(typeof _T_ === "number")
       {e[9]
        =
        function(e,param)
         {if(typeof param === "number" && 1006505782 <= param)
           return caml_call1(k,e);
          return caml_call1(Stdlib[1],cst_expected_Await_encode)};
        return 939392865}
      if(438511779 <= _T_[1])
       {var oc=_T_[2];
        caml_call4(Stdlib[68],oc,e[3],0,e[4]);
        e[4] = 0;
        return caml_call1(k,e)}
      var b=_T_[2],o=caml_call1(Stdlib_bytes[42],e[3]);
      caml_call4(Stdlib_buffer[16],b,o,0,e[4]);
      e[4] = 0;
      return caml_call1(k,e)}
    function t_range(e,max){e[7] = 0;e[8] = max;return 0}
    function t_flush(k,e)
     {function blit(e,l)
       {caml_blit_bytes(e[6],e[7],e[3],e[4],l);
        e[4] = e[4] + l | 0;
        e[7] = e[7] + l | 0;
        return 0}
      var rem=o_rem(e),len=(e[8] - e[7] | 0) + 1 | 0;
      return rem < len
              ?(blit(e,rem),flush(function(_S_){return t_flush(k,_S_)},e))
              :(blit(e,len),caml_call1(k,e))}
    function encode_utf_8(e,v)
     {function k(e){e[9] = encode_utf_8;return 17724}
      if(typeof v === "number")return 1006505782 <= v?k(e):flush(k,e);
      var u=v[2],u$0=caml_call1(Stdlib_uchar[10],u),rem=o_rem(e);
      if(127 < u$0)
       {if(2047 < u$0)
         {if(65535 < u$0)
           {if(4 <= rem)
             {var j=e[4];e[4] = e[4] + 4 | 0;var k$0=k,j$0=j,s=e[3]}
            else
             {t_range(e,3);
              var
               _M_=function(_R_){return t_flush(k,_R_)},
               k$0=_M_,
               j$0=0,
               s=e[6]}
            unsafe_set_byte(s,j$0,240 | u$0 >>> 18 | 0);
            unsafe_set_byte(s,j$0 + 1 | 0,128 | (u$0 >>> 12 | 0) & 63);
            unsafe_set_byte(s,j$0 + 2 | 0,128 | (u$0 >>> 6 | 0) & 63);
            unsafe_set_byte(s,j$0 + 3 | 0,128 | u$0 & 63);
            return k$0(e)}
          if(3 <= rem)
           {var j$1=e[4];e[4] = e[4] + 3 | 0;var k$1=k,j$2=j$1,s$0=e[3]}
          else
           {t_range(e,2);
            var
             _N_=function(_Q_){return t_flush(k,_Q_)},
             k$1=_N_,
             j$2=0,
             s$0=e[6]}
          unsafe_set_byte(s$0,j$2,224 | u$0 >>> 12 | 0);
          unsafe_set_byte(s$0,j$2 + 1 | 0,128 | (u$0 >>> 6 | 0) & 63);
          unsafe_set_byte(s$0,j$2 + 2 | 0,128 | u$0 & 63);
          return k$1(e)}
        if(2 <= rem)
         {var j$3=e[4];e[4] = e[4] + 2 | 0;var k$2=k,j$4=j$3,s$1=e[3]}
        else
         {t_range(e,1);
          var _O_=function(_P_){return t_flush(k,_P_)},k$2=_O_,j$4=0,s$1=e[6]}
        unsafe_set_byte(s$1,j$4,192 | u$0 >>> 6 | 0);
        unsafe_set_byte(s$1,j$4 + 1 | 0,128 | u$0 & 63);
        return k$2(e)}
      return 1 <= rem
              ?(unsafe_set_byte(e[3],e[4],u$0),e[4] = e[4] + 1 | 0,k(e))
              :flush(function(e){return encode_utf_8(e,v)},e)}
    function encode_utf_16be(e,v)
     {function k(e){e[9] = encode_utf_16be;return 17724}
      if(typeof v === "number")return 1006505782 <= v?k(e):flush(k,e);
      var u=v[2],u$0=caml_call1(Stdlib_uchar[10],u),rem=o_rem(e);
      if(65536 <= u$0)
       {if(4 <= rem)
         {var j=e[4];e[4] = e[4] + 4 | 0;var k$0=k,j$0=j,s=e[3]}
        else
         {t_range(e,3);
          var _I_=function(_L_){return t_flush(k,_L_)},k$0=_I_,j$0=0,s=e[6]}
        var
         u$1=u$0 - 65536 | 0,
         hi=55296 | u$1 >>> 10 | 0,
         lo=56320 | u$1 & 1023;
        unsafe_set_byte(s,j$0,hi >>> 8 | 0);
        unsafe_set_byte(s,j$0 + 1 | 0,hi & 255);
        unsafe_set_byte(s,j$0 + 2 | 0,lo >>> 8 | 0);
        unsafe_set_byte(s,j$0 + 3 | 0,lo & 255);
        return k$0(e)}
      if(2 <= rem)
       {var j$1=e[4];e[4] = e[4] + 2 | 0;var k$1=k,j$2=j$1,s$0=e[3]}
      else
       {t_range(e,1);
        var _J_=function(_K_){return t_flush(k,_K_)},k$1=_J_,j$2=0,s$0=e[6]}
      unsafe_set_byte(s$0,j$2,u$0 >>> 8 | 0);
      unsafe_set_byte(s$0,j$2 + 1 | 0,u$0 & 255);
      return k$1(e)}
    function encode_utf_16le(e,v)
     {function k(e){e[9] = encode_utf_16le;return 17724}
      if(typeof v === "number")return 1006505782 <= v?k(e):flush(k,e);
      var u=v[2],u$0=caml_call1(Stdlib_uchar[10],u),rem=o_rem(e);
      if(65536 <= u$0)
       {if(4 <= rem)
         {var j=e[4];e[4] = e[4] + 4 | 0;var k$0=k,j$0=j,s=e[3]}
        else
         {t_range(e,3);
          var _E_=function(_H_){return t_flush(k,_H_)},k$0=_E_,j$0=0,s=e[6]}
        var
         u$1=u$0 - 65536 | 0,
         hi=55296 | u$1 >>> 10 | 0,
         lo=56320 | u$1 & 1023;
        unsafe_set_byte(s,j$0,hi & 255);
        unsafe_set_byte(s,j$0 + 1 | 0,hi >>> 8 | 0);
        unsafe_set_byte(s,j$0 + 2 | 0,lo & 255);
        unsafe_set_byte(s,j$0 + 3 | 0,lo >>> 8 | 0);
        return k$0(e)}
      if(2 <= rem)
       {var j$1=e[4];e[4] = e[4] + 2 | 0;var k$1=k,j$2=j$1,s$0=e[3]}
      else
       {t_range(e,1);
        var _F_=function(_G_){return t_flush(k,_G_)},k$1=_F_,j$2=0,s$0=e[6]}
      unsafe_set_byte(s$0,j$2,u$0 & 255);
      unsafe_set_byte(s$0,j$2 + 1 | 0,u$0 >>> 8 | 0);
      return k$1(e)}
    function encoder(encoding,dst)
     {if(typeof dst === "number")
       var o_max=0,o_pos=1,o=Stdlib_bytes[3];
      else
       var o$0=caml_create_bytes(65536),o_max=65535,o_pos=0,o=o$0;
      var
       _D_=
        143365725 <= encoding
         ?684370880 <= encoding?encode_utf_8:encode_utf_16be
         :-211555818 <= encoding?encode_utf_16le:encode_utf_16be;
      return [0,dst,encoding,o,o_pos,o_max,caml_create_bytes(4),1,0,_D_]}
    function encode(e,v){return caml_call2(e[9],e,v)}
    function encoder_encoding(e){return e[2]}
    function encoder_dst(e){return e[1]}
    var Manual=[0,src,dst,o_rem];
    function encoding_guess(s)
     {var
       s$0=caml_call1(Stdlib_bytes[43],s),
       match=
        r_encoding(s$0,0,caml_call2(Stdlib[17],caml_ml_bytes_length(s$0),3)),
       _C_=match[1];
      if(-211555818 === _C_)
       {var d=match[2];return [0,-211555818,3299808 === d?1:0]}
      if(684370880 <= _C_)
       {var d$0=match[2];return [0,684370880,3299808 === d$0?1:0]}
      var d$1=match[2];
      return [0,-211558048,3299808 === d$1?1:0]}
    function fold_utf_8(opt,len,f,acc,s)
     {if(opt)var sth=opt[1],pos=sth;else var pos=0;
      if(len)
       var l=len[1],len$0=l;
      else
       var len$0=caml_ml_string_length(s) - pos | 0;
      var
       last=(pos + len$0 | 0) - 1 | 0,
       s$0=caml_call1(Stdlib_bytes[43],s),
       acc$0=acc,
       i=pos;
      for(;;)
       {if(last < i)return acc$0;
        var need=utf_8_len[1 + caml_bytes_unsafe_get(s$0,i)];
        if(0 === need)
         {var
           i$0=i + 1 | 0,
           acc$1=caml_call3(f,acc$0,i,malformed(s$0,i,1)),
           acc$0=acc$1,
           i=i$0;
          continue}
        var rem=(last - i | 0) + 1 | 0;
        if(rem < need)return caml_call3(f,acc$0,i,malformed(s$0,i,rem));
        var
         i$1=i + need | 0,
         acc$2=caml_call3(f,acc$0,i,r_utf_8(s$0,i,need)),
         acc$0=acc$2,
         i=i$1;
        continue}}
    function fold_utf_16be(opt,len,f,acc,s)
     {if(opt)var sth=opt[1],pos=sth;else var pos=0;
      if(len)
       var l=len[1],len$0=l;
      else
       var len$0=caml_ml_string_length(s) - pos | 0;
      var
       last=(pos + len$0 | 0) - 1 | 0,
       s$0=caml_call1(Stdlib_bytes[43],s),
       acc$0=acc,
       i=pos;
      for(;;)
       {if(last < i)return acc$0;
        var rem=(last - i | 0) + 1 | 0;
        if(2 <= rem)
         {var v=r_utf_16(s$0,i,i + 1 | 0);
          if(659980059 <= v[1])
           {var i$0=i + 2 | 0,acc$1=caml_call3(f,acc$0,i,v),acc$0=acc$1,i=i$0;
            continue}
          var hi=v[2];
          if(4 <= rem)
           {var
             i$1=i + 4 | 0,
             acc$2=
              caml_call3(f,acc$0,i,r_utf_16_lo(hi,s$0,i + 2 | 0,i + 3 | 0)),
             acc$0=acc$2,
             i=i$1;
            continue}
          return caml_call3(f,acc$0,i,malformed(s$0,i,rem))}
        return caml_call3(f,acc$0,i,malformed(s$0,i,1))}}
    function fold_utf_16le(opt,len,f,acc,s)
     {if(opt)var sth=opt[1],pos=sth;else var pos=0;
      if(len)
       var l=len[1],len$0=l;
      else
       var len$0=caml_ml_string_length(s) - pos | 0;
      var
       last=(pos + len$0 | 0) - 1 | 0,
       s$0=caml_call1(Stdlib_bytes[43],s),
       acc$0=acc,
       i=pos;
      for(;;)
       {if(last < i)return acc$0;
        var rem=(last - i | 0) + 1 | 0;
        if(2 <= rem)
         {var v=r_utf_16(s$0,i + 1 | 0,i);
          if(659980059 <= v[1])
           {var i$0=i + 2 | 0,acc$1=caml_call3(f,acc$0,i,v),acc$0=acc$1,i=i$0;
            continue}
          var hi=v[2];
          if(4 <= rem)
           {var
             i$1=i + 4 | 0,
             acc$2=
              caml_call3(f,acc$0,i,r_utf_16_lo(hi,s$0,i + 3 | 0,i + 2 | 0)),
             acc$0=acc$2,
             i=i$1;
            continue}
          return caml_call3(f,acc$0,i,malformed(s$0,i,rem))}
        return caml_call3(f,acc$0,i,malformed(s$0,i,1))}}
    var String=[0,encoding_guess,fold_utf_8,fold_utf_16be,fold_utf_16le];
    function add_utf_8(b,u)
     {var u$0=caml_call1(Stdlib_uchar[10],u);
      function w(byte$0){return caml_call2(Stdlib_buffer[10],b,byte$0)}
      return 127 < u$0
              ?2047 < u$0
                ?65535 < u$0
                  ?(w(240 | u$0 >>> 18 | 0),
                    w(128 | (u$0 >>> 12 | 0) & 63),
                    w(128 | (u$0 >>> 6 | 0) & 63),
                    w(128 | u$0 & 63))
                  :(w(224 | u$0 >>> 12 | 0),
                    w(128 | (u$0 >>> 6 | 0) & 63),
                    w(128 | u$0 & 63))
                :(w(192 | u$0 >>> 6 | 0),w(128 | u$0 & 63))
              :w(u$0)}
    function add_utf_16be(b,u)
     {var u$0=caml_call1(Stdlib_uchar[10],u);
      function w(byte$0){return caml_call2(Stdlib_buffer[10],b,byte$0)}
      if(65536 <= u$0)
       {var
         u$1=u$0 - 65536 | 0,
         hi=55296 | u$1 >>> 10 | 0,
         lo=56320 | u$1 & 1023;
        w(hi >>> 8 | 0);
        w(hi & 255);
        w(lo >>> 8 | 0);
        return w(lo & 255)}
      w(u$0 >>> 8 | 0);
      return w(u$0 & 255)}
    function add_utf_16le(b,u)
     {var u$0=caml_call1(Stdlib_uchar[10],u);
      function w(byte$0){return caml_call2(Stdlib_buffer[10],b,byte$0)}
      if(65536 <= u$0)
       {var
         u$1=u$0 - 65536 | 0,
         hi=55296 | u$1 >>> 10 | 0,
         lo=56320 | u$1 & 1023;
        w(hi & 255);
        w(hi >>> 8 | 0);
        w(lo & 255);
        return w(lo >>> 8 | 0)}
      w(u$0 & 255);
      return w(u$0 >>> 8 | 0)}
    var
     Buffer=[0,add_utf_8,add_utf_16be,add_utf_16le],
     Uutf=
      [0,
       u_bom,
       u_rep,
       encoding_of_string,
       encoding_to_string,
       decoder,
       decode,
       decoder_encoding,
       set_decoder_encoding,
       decoder_line,
       decoder_col,
       decoder_byte_count,
       decoder_count,
       decoder_removed_bom,
       decoder_src,
       decoder_nln,
       pp_decode,
       encoder,
       encode,
       encoder_encoding,
       encoder_dst,
       Manual,
       String,
       Buffer];
    runtime.caml_register_global(66,Uutf,"Uutf");
    return}
  (function(){return this}()));


//# 1 ".ace_common.objs/ace_common.cma.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_check_bound=runtime.caml_check_bound,
     caml_create_bytes=runtime.caml_create_bytes,
     caml_fresh_oo_id=runtime.caml_fresh_oo_id,
     caml_int64_and=runtime.caml_int64_and,
     caml_int64_of_int32=runtime.caml_int64_of_int32,
     caml_ml_string_length=runtime.caml_ml_string_length,
     caml_mod=runtime.caml_mod,
     caml_register_global=runtime.caml_register_global,
     caml_string_compare=runtime.caml_string_compare,
     caml_string_equal=runtime.caml_string_equal,
     caml_string_notequal=runtime.caml_string_notequal,
     caml_string_of_jsbytes=runtime.caml_string_of_jsbytes,
     caml_trampoline=runtime.caml_trampoline,
     caml_trampoline_return=runtime.caml_trampoline_return,
     caml_wrap_exception=runtime.caml_wrap_exception;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5
              ?f(a0,a1,a2,a3,a4)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4])}
    function caml_call6(f,a0,a1,a2,a3,a4,a5)
     {return f.length == 6
              ?f(a0,a1,a2,a3,a4,a5)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5])}
    function caml_call7(f,a0,a1,a2,a3,a4,a5,a6)
     {return f.length == 7
              ?f(a0,a1,a2,a3,a4,a5,a6)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5,a6])}
    function caml_call8(f,a0,a1,a2,a3,a4,a5,a6,a7)
     {return f.length == 8
              ?f(a0,a1,a2,a3,a4,a5,a6,a7)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5,a6,a7])}
    function caml_call9(f,a0,a1,a2,a3,a4,a5,a6,a7,a8)
     {return f.length == 9
              ?f(a0,a1,a2,a3,a4,a5,a6,a7,a8)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5,a6,a7,a8])}
    function caml_call11(f,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10)
     {return f.length == 11
              ?f(a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10])}
    var
     global_data=runtime.caml_get_global_data(),
     cst_Not_a_valid_int32=caml_string_of_jsbytes("Not a valid int32."),
     cst_eng=caml_string_of_jsbytes("eng"),
     cst_fra=caml_string_of_jsbytes("fra"),
     cst_ger=caml_string_of_jsbytes("ger"),
     cst_ita=caml_string_of_jsbytes("ita"),
     cst_jap=caml_string_of_jsbytes("jap"),
     cst_spa=caml_string_of_jsbytes("spa"),
     cst_1=caml_string_of_jsbytes("1"),
     cst_2=caml_string_of_jsbytes("2"),
     cst_3=caml_string_of_jsbytes("3"),
     cst_4=caml_string_of_jsbytes("4"),
     cst_5=caml_string_of_jsbytes("5"),
     cst_1$0=caml_string_of_jsbytes("1"),
     cst_2$0=caml_string_of_jsbytes("2"),
     cst_3$0=caml_string_of_jsbytes("3"),
     cst_Unknown_answer=caml_string_of_jsbytes("Unknown answer."),
     cst_Old_rod=caml_string_of_jsbytes("Old rod"),
     cst_Good_rod=caml_string_of_jsbytes("Good rod"),
     cst_Super_rod=caml_string_of_jsbytes("Super rod"),
     cst_Save_InvalidSave=caml_string_of_jsbytes("Save.InvalidSave"),
     cst_Preprocess_VarNotFound=
      caml_string_of_jsbytes("Preprocess.VarNotFound"),
     partial=[12,32,[5,0,0,0,[17,4,0]]],
     cst_Not_implemented$0=caml_string_of_jsbytes("Not implemented"),
     cst_Not_implemented=caml_string_of_jsbytes("Not implemented"),
     cst_Arm_InvalidCommand=caml_string_of_jsbytes("Arm.InvalidCommand"),
     spacing_char=caml_string_of_jsbytes("_"),
     invalid_char=caml_string_of_jsbytes("\xe2\x9c\x96"),
     cst$1=caml_string_of_jsbytes(" "),
     cst=caml_string_of_jsbytes(""),
     cst$0=caml_string_of_jsbytes(" "),
     cst_Not_implemented$2=caml_string_of_jsbytes("Not implemented"),
     cst_Not_implemented$1=caml_string_of_jsbytes("Not implemented"),
     cst_Optimizer_CannotOptimize=
      caml_string_of_jsbytes("Optimizer.CannotOptimize"),
     cst_B$0=caml_string_of_jsbytes("B"),
     cst_MOV=caml_string_of_jsbytes("MOV"),
     cst_ADC=caml_string_of_jsbytes("ADC"),
     cst_ADD=caml_string_of_jsbytes("ADD"),
     cst_AND=caml_string_of_jsbytes("AND"),
     cst_BIC=caml_string_of_jsbytes("BIC"),
     cst_EOR=caml_string_of_jsbytes("EOR"),
     cst_LDR=caml_string_of_jsbytes("LDR"),
     cst_MVN=caml_string_of_jsbytes("MVN"),
     cst_ORR=caml_string_of_jsbytes("ORR"),
     cst_SBC=caml_string_of_jsbytes("SBC"),
     cst_STR=caml_string_of_jsbytes("STR"),
     cst_SUB=caml_string_of_jsbytes("SUB"),
     cst_r15=caml_string_of_jsbytes("r15"),
     cst_r1=caml_string_of_jsbytes("r1"),
     cst_fp=caml_string_of_jsbytes("fp"),
     cst_ip=caml_string_of_jsbytes("ip"),
     cst_lr=caml_string_of_jsbytes("lr"),
     cst_pc=caml_string_of_jsbytes("pc"),
     cst_r0=caml_string_of_jsbytes("r0"),
     cst_r10=caml_string_of_jsbytes("r10"),
     cst_r11=caml_string_of_jsbytes("r11"),
     cst_r12=caml_string_of_jsbytes("r12"),
     cst_r13=caml_string_of_jsbytes("r13"),
     cst_r14=caml_string_of_jsbytes("r14"),
     cst_r7=caml_string_of_jsbytes("r7"),
     cst_r2=caml_string_of_jsbytes("r2"),
     cst_r3=caml_string_of_jsbytes("r3"),
     cst_r4=caml_string_of_jsbytes("r4"),
     cst_r5=caml_string_of_jsbytes("r5"),
     cst_r6=caml_string_of_jsbytes("r6"),
     cst_r8=caml_string_of_jsbytes("r8"),
     cst_r9=caml_string_of_jsbytes("r9"),
     cst_sb=caml_string_of_jsbytes("sb"),
     cst_sl=caml_string_of_jsbytes("sl"),
     cst_sp=caml_string_of_jsbytes("sp"),
     cst_L$0=caml_string_of_jsbytes("L"),
     cst_S$0=caml_string_of_jsbytes("S"),
     cst_X$0=caml_string_of_jsbytes("X"),
     mods=[0,0,0,0,0,0],
     cst_L=caml_string_of_jsbytes("L"),
     cst_S=caml_string_of_jsbytes("S"),
     cst_X=caml_string_of_jsbytes("X"),
     cst_BT=caml_string_of_jsbytes("BT"),
     cst_SB=caml_string_of_jsbytes("SB"),
     cst_SH=caml_string_of_jsbytes("SH"),
     cst_B=caml_string_of_jsbytes("B"),
     cst_H=caml_string_of_jsbytes("H"),
     cst_T=caml_string_of_jsbytes("T"),
     cst_W=caml_string_of_jsbytes("W"),
     cst_LE=caml_string_of_jsbytes("LE"),
     cst_AL=caml_string_of_jsbytes("AL"),
     cst_CC=caml_string_of_jsbytes("CC"),
     cst_CS=caml_string_of_jsbytes("CS"),
     cst_EQ=caml_string_of_jsbytes("EQ"),
     cst_GE=caml_string_of_jsbytes("GE"),
     cst_GT=caml_string_of_jsbytes("GT"),
     cst_HI=caml_string_of_jsbytes("HI"),
     cst_HS=caml_string_of_jsbytes("HS"),
     cst_LO=caml_string_of_jsbytes("LO"),
     cst_LS=caml_string_of_jsbytes("LS"),
     cst_LT=caml_string_of_jsbytes("LT"),
     cst_MI=caml_string_of_jsbytes("MI"),
     cst_NE=caml_string_of_jsbytes("NE"),
     cst_PL=caml_string_of_jsbytes("PL"),
     cst_VC=caml_string_of_jsbytes("VC"),
     cst_VS=caml_string_of_jsbytes("VS"),
     cst_Parser_ast_CommandError=
      caml_string_of_jsbytes("Parser_ast.CommandError"),
     cst_Parser_ast_StructError=
      caml_string_of_jsbytes("Parser_ast.StructError"),
     cst_Parser_MenhirBasics_Error=
      caml_string_of_jsbytes("Parser.MenhirBasics.Error"),
     cst_Unexpected_char=caml_string_of_jsbytes("Unexpected char: "),
     cst_String_cannot_be_multiline=
      caml_string_of_jsbytes("String cannot be multiline"),
     cst_String_is_not_terminated=
      caml_string_of_jsbytes("String is not terminated"),
     cst_Illegal_string_character=
      caml_string_of_jsbytes("Illegal string character: "),
     cst_Lexer_SyntaxError=caml_string_of_jsbytes("Lexer.SyntaxError"),
     ocaml_lex_tables=
      [0,
       caml_string_of_jsbytes
        ("\0\0\xd7\xff\xd8\xff\xd9\xff\xda\xff\xdf\xff\xe0\xff\xe1\xff\xe2\xff\xe3\xff\xe4\xff\xe5\xff\xe7\xff\xe8\xff\xe9\xff\xea\xff\xeb\xff\xec\xff\xee\xffO\0\x9a\0\xa4\0\xf1\xff\x01\0\x02\0\x07\x001\0\xf4\xff\t\0c\0\x0e\0N\0N\0Q\0\xed\x008\x01\x83\x01N\0R\0m\0n\0o\0p\0\xfe\xff\xce\x01\x19\x02d\x02\xaf\x02\xfa\x02E\x03\x90\x03\xdb\x03&\x04q\x04\xfa\xff\xf9\xff\xf7\xff\xf6\xff\xf5\xff\xf2\xff\x04\0\xae\0\xb7\0\xbc\x04\xb9\0\xd3\x04\xc4\0\xd7\0\xec\x04\xf5\xff\xf6\xff\x07\0\xed\x04\xcc\x04\xff\xff\xf8\xff\xf9\xff\xfa\xff\xfb\xff\xfc\xff\xfd\xff\xfe\xff\x0f\0\xfd\xff\xfe\xff\xff\xff\b\0"),
       caml_string_of_jsbytes
        ('\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x10\0\x0f\0\x0f\0\xff\xff\x0e\0(\0\f\0!\0\xff\xff"\0#\0$\0\x19\0(\0(\0\x10\0\x10\0\x10\0\x0b\0\x12\0\x07\0\xff\xff\xff\xff\0\0\xff\xff\x10\0\x10\0\x02\0\x10\0\x10\0\x03\0\x10\0\x10\0\x10\0\x04\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\r\0\xff\xff\xff\xff\xff\xff\xff\xff\x0f\0\x0f\0\x0f\0\xff\xff\xff\xff\xff\xff\t\0\b\0\x0b\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0'),
       caml_string_of_jsbytes
        ("\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\0\0\0\0\0\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffH\0\0\0\0\0\xff\xffH\0\xff\xff\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0S\0\0\0\0\0\0\0\xff\xff"),
       caml_string_of_jsbytes
        ("\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x19\0\x16\0\x16\0;\0\x17\0;\0<\0\x19\0F\0U\0\0\0\0\0\0\0\0\0\0\0\0\0U\0\0\0\0\0V\0\0\0\0\0\0\0\x19\0\x1f\0\x12\0\x11\0\0\0\x1c\0\x1d\0\x19\0\t\0\b\0\x05\0\x07\0\f\0\x06\0\x1b\0\x1a\0\x15\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\n\0\x1b\0!\0&\0 \0\x0b\0%\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x10\0\x18\0\x0f\0\x04\0\x13\0\x1b\0\x13\0\x13\0\x13\0\x13\0\x13\0\"\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0$\0\x13\0\x13\0\x13\0\x13\0\x13\0#\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x0e\0\x1e\0\r\0\x03\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0:\x009\x008\x007\x006\0+\0'\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0(\0)\0*\0*\0\x13\0\0\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0C\0C\0C\0C\0C\0C\0C\0C\0>\0B\0B\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0=\0B\0B\0\0\0\0\0\0\0@\0\0\0\0\0?\0\0\0\0\0\0\0\x02\0\0\0\0\0\0\0\0\0\0\0>\0C\0C\0C\0C\0C\0C\0C\0C\0T\0\0\0\0\0\0\0=\0\0\0\0\0\0\0\0\0\0\0@\0\0\0\0\0?\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\0\0\0\0\0\0\0\0\x13\0\0\x002\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\0\0\0\0\0\0\0\0\x13\0\0\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0/\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\0\0\0\0\0\0\0\0\x13\0\0\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0,\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\0\0\0\0\0\0\0\0\x13\0\0\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0-\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\0\0\0\0\0\0\0\0\x13\0\0\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0.\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\0\0\0\0\0\0\0\0\x13\0\0\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\0\0\0\0\0\0\0\0\x13\0\0\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\x000\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\0\0\0\0\0\0\0\0\x13\0\0\0\x13\0\x13\0\x13\0\x13\x001\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\0\0\0\0\0\0\0\0\x13\0\0\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\0\0\0\0\0\0\0\0\x13\0\0\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\x003\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\0\0\0\0\0\0\0\0\x13\0\0\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\x004\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\0\0\0\0\0\0\0\0\x13\0\0\0\x13\0\x13\0\x13\0\x13\x005\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\0\0\0\0\0\0\0\0\x13\0\0\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0F\0\xff\xff\0\0G\0\xff\xffQ\0\0\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0\0\0J\0\xff\xff\0\0\0\0\0\0\0\0A\0A\0A\0A\0A\0A\0\0\0\0\0\0\0A\0A\0A\0A\0A\0A\0\0\0\0\0\0\0\0\0\0\0P\0\0\0\0\0\0\0\0\0\0\0O\0\0\0\0\0\0\0N\0\0\0A\0A\0A\0A\0A\0A\0M\0\0\0\0\0\0\0L\0\0\0K\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0I\0\xff\xff\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0E\0\xff\xff"),
       caml_string_of_jsbytes
        ('\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\x17\0\x18\0\0\0<\0\x18\0\x19\0G\0V\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\0\xff\xff\xff\xffR\0\xff\xff\xff\xff\xff\xff\0\0\0\0\0\0\0\0\xff\xff\0\0\0\0\x19\0\0\0\0\0\0\0\0\0\0\0\0\0\x1c\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x1a\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x1d\0\x1e\0\x1f\0 \0!\0%\0&\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\'\0(\0)\0*\0\x13\0\xff\xff\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x15\0\x15\0\x15\0\x15\0\x15\0\x15\0\x15\0\x15\0\x15\0\x15\0=\0=\0=\0=\0=\0=\0=\0=\0\x15\0>\0>\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0\x15\0B\0B\0\xff\xff\xff\xff\xff\xff\x15\0\xff\xff\xff\xff\x15\0\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x15\0C\0C\0C\0C\0C\0C\0C\0C\0R\0\xff\xff\xff\xff\xff\xff\x15\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x15\0\xff\xff\xff\xff\x15\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0\xff\xff\xff\xff\xff\xff\xff\xff"\0\xff\xff"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0\xff\xff\xff\xff\xff\xff\xff\xff#\0\xff\xff#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0\xff\xff\xff\xff\xff\xff\xff\xff$\0\xff\xff$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0\xff\xff\xff\xff\xff\xff\xff\xff,\0\xff\xff,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0\xff\xff\xff\xff\xff\xff\xff\xff-\0\xff\xff-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0\xff\xff\xff\xff\xff\xff\xff\xff.\0\xff\xff.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0\xff\xff\xff\xff\xff\xff\xff\xff/\0\xff\xff/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff0\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\0\xff\xff\xff\xff\xff\xff\xff\xff0\0\xff\xff0\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\0\xff\xff\xff\xff\xff\xff\xff\xff1\0\xff\xff1\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff2\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\0\xff\xff\xff\xff\xff\xff\xff\xff2\0\xff\xff2\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff3\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\0\xff\xff\xff\xff\xff\xff\xff\xff3\0\xff\xff3\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff4\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\0\xff\xff\xff\xff\xff\xff\xff\xff4\0\xff\xff4\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff5\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\0\xff\xff\xff\xff\xff\xff\xff\xff5\0\xff\xff5\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\0?\0?\0?\0?\0?\0?\0?\0?\0?\0?\0D\0H\0\xff\xffD\0H\0I\0\xff\xff?\0?\0?\0?\0?\0?\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0\xff\xffD\0H\0\xff\xff\xff\xff\xff\xff\xff\xffA\0A\0A\0A\0A\0A\0\xff\xff\xff\xff\xff\xff?\0?\0?\0?\0?\0?\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffI\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffI\0\xff\xff\xff\xff\xff\xffI\0\xff\xffA\0A\0A\0A\0A\0A\0I\0\xff\xff\xff\xff\xff\xffI\0\xff\xffI\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffD\0H\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffD\0H\0'),
       caml_string_of_jsbytes(""),
       caml_string_of_jsbytes(""),
       caml_string_of_jsbytes(""),
       caml_string_of_jsbytes(""),
       caml_string_of_jsbytes(""),
       caml_string_of_jsbytes("")],
     cst_Parse_InvalidContent=caml_string_of_jsbytes("Parse.InvalidContent"),
     cst_filename=caml_string_of_jsbytes("filename"),
     cst_Please_specify_the_filenam=
      caml_string_of_jsbytes
       ("Please specify the 'filename' header everywhere."),
     cst_Invalid_headers=caml_string_of_jsbytes("Invalid headers."),
     cst_start=caml_string_of_jsbytes("start"),
     cst_Exit_code_has_invalid_head=
      caml_string_of_jsbytes("Exit code has invalid headers."),
     cst_txt=caml_string_of_jsbytes(".txt"),
     cst_Exit_codes_cannot_be_tweak=
      caml_string_of_jsbytes
       ("Exit codes cannot be tweaked (please remove interrogation marks)."),
     cst_Exit_NoExitCode=caml_string_of_jsbytes("Exit.NoExitCode"),
     cst_Invalid_starting_position=
      caml_string_of_jsbytes("Invalid starting position."),
     cst_Some_codes_cannot_be_posit=
      caml_string_of_jsbytes
       ("Some codes cannot be positionned due to non-consecutive 0xFF bytes."),
     cst_Result_is_inconsistent_Ple=
      caml_string_of_jsbytes
       ("Result is inconsistent. Please check the fillers."),
     cst_Result_is_inconsistent_Ple$0=
      caml_string_of_jsbytes
       ("Result is inconsistent. Please check the fillers."),
     cst_Boxes_BoxFittingError=caml_string_of_jsbytes("Boxes.BoxFittingError"),
     nop_code=[0,0,[0,0,[0,0,[0,0,0]]]],
     nop_code2=[0,0,[0,0,[0,0,[0,176,0]]]],
     cst_ADC$0=caml_string_of_jsbytes("ADC"),
     cst_SBC$0=caml_string_of_jsbytes("SBC"),
     cst_BIC$0=caml_string_of_jsbytes("BIC"),
     cst_AND$0=caml_string_of_jsbytes("AND"),
     cst_ADD$0=caml_string_of_jsbytes("ADD"),
     cst_SUB$0=caml_string_of_jsbytes("SUB"),
     cst_ORR$0=caml_string_of_jsbytes("ORR"),
     cst_EOR$0=caml_string_of_jsbytes("EOR"),
     cst_MVN$0=caml_string_of_jsbytes("MVN"),
     cst_MOV$0=caml_string_of_jsbytes("MOV"),
     cst_STR$0=caml_string_of_jsbytes("STR"),
     cst_LDR$0=caml_string_of_jsbytes("LDR"),
     cst$8=caml_string_of_jsbytes("!"),
     cst$9=caml_string_of_jsbytes(""),
     cst_Not_implemented$4=caml_string_of_jsbytes("Not implemented"),
     cst_Not_implemented$3=caml_string_of_jsbytes("Not implemented"),
     cst_L$1=caml_string_of_jsbytes("L"),
     cst$7=caml_string_of_jsbytes(""),
     cst_S$1=caml_string_of_jsbytes("S"),
     cst$6=caml_string_of_jsbytes(""),
     cst$4=caml_string_of_jsbytes("-"),
     cst$5=caml_string_of_jsbytes(""),
     cst_B$1=caml_string_of_jsbytes("B"),
     cst_SB$0=caml_string_of_jsbytes("SB"),
     cst_H$0=caml_string_of_jsbytes("H"),
     cst_SH$0=caml_string_of_jsbytes("SH"),
     cst$3=caml_string_of_jsbytes(""),
     cst_T$0=caml_string_of_jsbytes("T"),
     cst_BT$0=caml_string_of_jsbytes("BT"),
     cst_EQ$0=caml_string_of_jsbytes("EQ"),
     cst_NE$0=caml_string_of_jsbytes("NE"),
     cst_CS$0=caml_string_of_jsbytes("CS"),
     cst_HS$0=caml_string_of_jsbytes("HS"),
     cst_CC$0=caml_string_of_jsbytes("CC"),
     cst_LO$0=caml_string_of_jsbytes("LO"),
     cst_MI$0=caml_string_of_jsbytes("MI"),
     cst_PL$0=caml_string_of_jsbytes("PL"),
     cst_VS$0=caml_string_of_jsbytes("VS"),
     cst_VC$0=caml_string_of_jsbytes("VC"),
     cst_HI$0=caml_string_of_jsbytes("HI"),
     cst_LS$0=caml_string_of_jsbytes("LS"),
     cst_GE$0=caml_string_of_jsbytes("GE"),
     cst_LT$0=caml_string_of_jsbytes("LT"),
     cst_GT$0=caml_string_of_jsbytes("GT"),
     cst_LE$0=caml_string_of_jsbytes("LE"),
     cst$2=caml_string_of_jsbytes(""),
     cst_Invalid_filler=caml_string_of_jsbytes("Invalid filler."),
     cst_Invalid_headers$0=caml_string_of_jsbytes("Invalid headers."),
     cst_onlyraw=caml_string_of_jsbytes("onlyraw"),
     cst_Invalid_headers$3=caml_string_of_jsbytes("Invalid headers."),
     cst_Only_raw_mode_does_not_sup=
      caml_string_of_jsbytes("Only-raw mode does not support exit codes."),
     cst_start$0=caml_string_of_jsbytes("start"),
     cst_Invalid_headers$2=caml_string_of_jsbytes("Invalid headers."),
     cst_fill=caml_string_of_jsbytes("fill"),
     cst_fill$0=caml_string_of_jsbytes("fill"),
     cst_The_fill_header_has_a_diff=
      caml_string_of_jsbytes
       ("The 'fill' header has a different value in the main code and in the exit code."),
     cst_Invalid_headers$1=caml_string_of_jsbytes("Invalid headers."),
     cst_The_exit_code_overlaps_thi=
      caml_string_of_jsbytes
       ("The exit code overlaps this code (too long?).@."),
     Stdlib_format=global_data.Stdlib__format,
     Stdlib_list=global_data.Stdlib__list,
     Stdlib_int32=global_data.Stdlib__int32,
     Assert_failure=global_data.Assert_failure,
     Stdlib_string=global_data.Stdlib__string,
     Stdlib_int64=global_data.Stdlib__int64,
     Stdlib=global_data.Stdlib,
     Stdlib_filename=global_data.Stdlib__filename,
     Stdlib_array=global_data.Stdlib__array,
     Stdlib_bytes=global_data.Stdlib__bytes,
     Big_int=global_data.Big_int,
     Stdlib_scanf=global_data.Stdlib__scanf,
     Stdlib_map=global_data.Stdlib__map,
     Stdlib_set=global_data.Stdlib__set,
     Stdlib_printf=global_data.Stdlib__printf,
     Stdlib_lexing=global_data.Stdlib__lexing,
     Stdlib_buffer=global_data.Stdlib__buffer,
     Uutf=global_data.Uutf,
     _f_=[0,[2,0,0],caml_string_of_jsbytes("%s")],
     _g_=[0,[15,0],caml_string_of_jsbytes("%a")],
     _c_=runtime.caml_int64_create_lo_mi_hi(16777215,255,0),
     _b_=[0,caml_string_of_jsbytes("IO/utils.ml"),21,45],
     _a_=runtime.caml_int64_create_lo_mi_hi(0,16776960,65535),
     _h_=
      [0,
       caml_string_of_jsbytes("GAEM"),
       caml_string_of_jsbytes("GAME"),
       caml_string_of_jsbytes("GEAM"),
       caml_string_of_jsbytes("GEMA"),
       caml_string_of_jsbytes("GMAE"),
       caml_string_of_jsbytes("GMEA"),
       caml_string_of_jsbytes("AGEM"),
       caml_string_of_jsbytes("AGME"),
       caml_string_of_jsbytes("AEGM"),
       caml_string_of_jsbytes("AEMG"),
       caml_string_of_jsbytes("AMGE"),
       caml_string_of_jsbytes("AMEG"),
       caml_string_of_jsbytes("EGAM"),
       caml_string_of_jsbytes("EGMA"),
       caml_string_of_jsbytes("EAGM"),
       caml_string_of_jsbytes("EAMG"),
       caml_string_of_jsbytes("EMGA"),
       caml_string_of_jsbytes("EMAG"),
       caml_string_of_jsbytes("MGAE"),
       caml_string_of_jsbytes("MGEA"),
       caml_string_of_jsbytes("MAGE"),
       caml_string_of_jsbytes("MAEG"),
       caml_string_of_jsbytes("MEGA"),
       caml_string_of_jsbytes("MEAG")],
     _w_=[0,caml_string_of_jsbytes("Pokemon/seed.ml"),66,2],
     _o_=runtime.caml_int64_create_lo_mi_hi(12996205,65,0),
     _p_=runtime.caml_int64_create_lo_mi_hi(24691,0,0),
     _q_=runtime.caml_int64_create_lo_mi_hi(12184421,238,0),
     _r_=runtime.caml_int64_create_lo_mi_hi(3498401,10,0),
     _s_=runtime.caml_int64_create_lo_mi_hi(0,256,0),
     _t_=runtime.caml_int64_create_lo_mi_hi(12141755,833,0),
     _v_=runtime.caml_int64_create_lo_mi_hi(16777215,255,0),
     _z_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("Please enter your seed (use 0x prefix if hexadecimal): "),
        [17,2,0]],
       caml_string_of_jsbytes
        ("Please enter your seed (use 0x prefix if hexadecimal): @?")],
     _A_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("Do you want to obtain this seed using the freeze PRNG ACE code ?"),
        [17,4,0]],
       caml_string_of_jsbytes
        ("Do you want to obtain this seed using the freeze PRNG ACE code ?@.")],
     _B_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("1. Yes, for method H1 (wild pokemon) using sweet scent."),
        [17,4,0]],
       caml_string_of_jsbytes
        ("1. Yes, for method H1 (wild pokemon) using sweet scent.@.")],
     _C_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("2. Yes, for mass outbreaks (method H1, using sweet scent)."),
        [17,4,0]],
       caml_string_of_jsbytes
        ("2. Yes, for mass outbreaks (method H1, using sweet scent).@.")],
     _D_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("3. Yes, for method H1 (wild pokemon) using a rod."),
        [17,4,0]],
       caml_string_of_jsbytes
        ("3. Yes, for method H1 (wild pokemon) using a rod.@.")],
     _E_=
      [0,
       [11,
        caml_string_of_jsbytes("4. Yes, for method 1 (stationnary pokemon)."),
        [17,4,0]],
       caml_string_of_jsbytes("4. Yes, for method 1 (stationnary pokemon).@.")],
     _F_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("5. No, but please show me the seeds in the vicinity."),
        [17,4,0]],
       caml_string_of_jsbytes
        ("5. No, but please show me the seeds in the vicinity.@.")],
     _G_=
      [0,
       [11,caml_string_of_jsbytes("6. No (quit)."),[17,4,0]],
       caml_string_of_jsbytes("6. No (quit).@.")],
     _H_=
      [0,
       [11,caml_string_of_jsbytes("Cycle from seed 0: "),[5,12,0,0,[17,4,0]]],
       caml_string_of_jsbytes("Cycle from seed 0: %lu@.")],
     _I_=
      [0,
       [4,
        3,
        0,
        0,
        [11,
         caml_string_of_jsbytes(": "),
         [5,
          12,
          0,
          0,
          [11,caml_string_of_jsbytes(" ("),[5,7,0,0,[12,41,[17,4,0]]]]]]],
       caml_string_of_jsbytes("%i: %lu (%#lx)@.")],
     _J_=
      [0,
       [11,
        caml_string_of_jsbytes("Please enter the range (example: -25 5):"),
        [17,4,0]],
       caml_string_of_jsbytes("Please enter the range (example: -25 5):@.")],
     _K_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("For most legendaries, you should use the seed at cycle -3."),
        [17,4,0]],
       caml_string_of_jsbytes
        ("For most legendaries, you should use the seed at cycle -3.@.")],
     _L_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("Please refer to the instructions on the freeze PRNG ACE code for other stationnary pokemons."),
        [17,4,0]],
       caml_string_of_jsbytes
        ("Please refer to the instructions on the freeze PRNG ACE code for other stationnary pokemons.@.")],
     _M_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("You should start the battle as soon as you can"),
        0],
       caml_string_of_jsbytes
        ("You should start the battle as soon as you can")],
     _N_=
      [0,
       [11,
        caml_string_of_jsbytes
         (" (just after having executed the ACE and closed the menu)."),
        [17,4,0]],
       caml_string_of_jsbytes
        (" (just after having executed the ACE and closed the menu).@.")],
     _O_=
      [0,
       [11,
        caml_string_of_jsbytes("Please select your configuration:"),
        [17,4,0]],
       caml_string_of_jsbytes("Please select your configuration:@.")],
     _P_=
      [0,
       [11,
        caml_string_of_jsbytes("1. I will not be fishing on route 119."),
        [17,4,0]],
       caml_string_of_jsbytes("1. I will not be fishing on route 119.@.")],
     _Q_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("2. I will be fishing on route 119, but not for a feebas."),
        [17,4,0]],
       caml_string_of_jsbytes
        ("2. I will be fishing on route 119, but not for a feebas.@.")],
     _R_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("3. I will be fishing for feebas on a feebas tile."),
        [17,4,0]],
       caml_string_of_jsbytes
        ("3. I will be fishing for feebas on a feebas tile.@.")],
     _S_=
      [0,
       [11,
        caml_string_of_jsbytes("You should use the seed "),
        [5,
         7,
         0,
         0,
         [11,
          caml_string_of_jsbytes(" (1 cycle before your target)."),
          [17,4,0]]]],
       caml_string_of_jsbytes
        ("You should use the seed %#lx (1 cycle before your target).@.")],
     _T_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("You should use sweet scent directly after triggering the ACE,"),
        0],
       caml_string_of_jsbytes
        ("You should use sweet scent directly after triggering the ACE,")],
     _U_=
      [0,
       [11,
        caml_string_of_jsbytes(" without closing the pokemon menu."),
        [17,4,0]],
       caml_string_of_jsbytes(" without closing the pokemon menu.@.")],
     _V_=
      [0,
       [11,
        caml_string_of_jsbytes("You should use the seed "),
        [5,
         7,
         0,
         0,
         [11,
          caml_string_of_jsbytes(" (2 cycles before your target)."),
          [17,4,0]]]],
       caml_string_of_jsbytes
        ("You should use the seed %#lx (2 cycles before your target).@.")],
     _W_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("You should use sweet scent directly after triggering the ACE,"),
        0],
       caml_string_of_jsbytes
        ("You should use sweet scent directly after triggering the ACE,")],
     _X_=
      [0,
       [11,
        caml_string_of_jsbytes(" without closing the pokemon menu."),
        [17,4,0]],
       caml_string_of_jsbytes(" without closing the pokemon menu.@.")],
     _Y_=
      [0,
       [12,32,[4,3,0,0,[12,32,[4,3,0,0,0]]]],
       caml_string_of_jsbytes(" %i %i")],
     _ag_=[0,caml_string_of_jsbytes("Main/seed_tools_common.ml"),82,13],
     _aa_=[0,[2,0,[12,58,[17,4,0]]],caml_string_of_jsbytes("%s:@.")],
     _ab_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("\tWith lead: Must have Suction Cup or Sticky Hold lead"),
        [17,4,0]],
       caml_string_of_jsbytes
        ("\tWith lead: Must have Suction Cup or Sticky Hold lead@.")],
     _ac_=
      [0,
       [11,
        caml_string_of_jsbytes("\tUse seed "),
        [5,
         7,
         0,
         0,
         [11,
          caml_string_of_jsbytes(" to generate target on advancement "),
          [4,3,0,0,[17,4,0]]]]],
       caml_string_of_jsbytes
        ("\tUse seed %#lx to generate target on advancement %i@.")],
     _ad_=
      [0,
       [11,caml_string_of_jsbytes("\tWith lead: No lead necessary"),[17,4,0]],
       caml_string_of_jsbytes("\tWith lead: No lead necessary@.")],
     _ae_=
      [0,
       [11,
        caml_string_of_jsbytes("\tUse seed "),
        [5,
         7,
         0,
         0,
         [11,
          caml_string_of_jsbytes(" to generate target on advancement "),
          [4,3,0,0,[17,4,0]]]]],
       caml_string_of_jsbytes
        ("\tUse seed %#lx to generate target on advancement %i@.")],
     _af_=
      [0,
       [11,caml_string_of_jsbytes("\tNo matches found"),[17,4,0]],
       caml_string_of_jsbytes("\tNo matches found@.")],
     _Z_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("You should use the rod directly after triggering the ACE"),
        0],
       caml_string_of_jsbytes
        ("You should use the rod directly after triggering the ACE")],
     ___=
      [0,
       [11,
        caml_string_of_jsbytes(" (leave the pokemon menu and enter the bag)."),
        [17,4,0]],
       caml_string_of_jsbytes
        (" (leave the pokemon menu and enter the bag).@.")],
     _$_=
      [0,
       [11,caml_string_of_jsbytes("Thanks to Shao for this script."),[17,4,0]],
       caml_string_of_jsbytes("Thanks to Shao for this script.@.")],
     _ah_=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes(" = "),
         [5,
          3,
          0,
          0,
          [11,caml_string_of_jsbytes(" ("),[5,7,0,0,[12,41,[17,4,0]]]]]]],
       caml_string_of_jsbytes("%s = %li (%#lx)@.")],
     _ai_=[0,[17,4,0],caml_string_of_jsbytes("@.")],
     _aj_=
      [0,
       [11,caml_string_of_jsbytes("Please enter low-PID: "),[17,2,0]],
       caml_string_of_jsbytes("Please enter low-PID: @?")],
     _ak_=[0,[12,32,[5,3,0,0,0]],caml_string_of_jsbytes(" %li")],
     _al_=
      [0,
       [11,caml_string_of_jsbytes("Please enter high-PID: "),[17,2,0]],
       caml_string_of_jsbytes("Please enter high-PID: @?")],
     _am_=[0,[12,32,[5,3,0,0,0]],caml_string_of_jsbytes(" %li")],
     _an_=
      [0,
       [11,
        caml_string_of_jsbytes("Please enter original trainer visible TID: "),
        [17,2,0]],
       caml_string_of_jsbytes("Please enter original trainer visible TID: @?")],
     _ao_=[0,[12,32,[5,3,0,0,0]],caml_string_of_jsbytes(" %li")],
     _ap_=
      [0,
       [11,
        caml_string_of_jsbytes("Please enter original trainer secret TID: "),
        [17,2,0]],
       caml_string_of_jsbytes("Please enter original trainer secret TID: @?")],
     _aq_=[0,[12,32,[5,3,0,0,0]],caml_string_of_jsbytes(" %li")],
     _ar_=
      [0,
       [11,
        caml_string_of_jsbytes("Misc substructure position: "),
        [4,0,0,0,[17,4,0]]],
       caml_string_of_jsbytes("Misc substructure position: %d@.")],
     _as_=
      [0,
       [11,caml_string_of_jsbytes("IVEA offset: "),[4,7,0,0,[17,4,0]]],
       caml_string_of_jsbytes("IVEA offset: %#x@.")],
     _at_=
      [0,
       [11,caml_string_of_jsbytes("Please enter low-IVEA: "),[17,2,0]],
       caml_string_of_jsbytes("Please enter low-IVEA: @?")],
     _au_=[0,[12,32,[5,3,0,0,0]],caml_string_of_jsbytes(" %li")],
     _av_=
      [0,
       [11,caml_string_of_jsbytes("Please enter high-IVEA: "),[17,2,0]],
       caml_string_of_jsbytes("Please enter high-IVEA: @?")],
     _aw_=[0,[12,32,[5,3,0,0,0]],caml_string_of_jsbytes(" %li")],
     _ax_=
      [0,
       [11,
        caml_string_of_jsbytes("Unencrypted IVEA data: "),
        [5,7,0,0,[17,4,0]]],
       caml_string_of_jsbytes("Unencrypted IVEA data: %#lx@.")],
     _ay_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("Pokemon IVs (hp atk def speed sp_atk sp_def): "),
        [5,
         0,
         0,
         0,
         [12,
          32,
          [5,
           0,
           0,
           0,
           [12,32,[5,0,0,0,[12,32,[5,0,0,0,[12,32,[5,0,0,0,partial]]]]]]]]]],
       caml_string_of_jsbytes
        ("Pokemon IVs (hp atk def speed sp_atk sp_def): %ld %ld %ld %ld %ld %ld@.")],
     _az_=
      [0,
       [11,caml_string_of_jsbytes("Maxing IVs..."),[17,4,0]],
       caml_string_of_jsbytes("Maxing IVs...@.")],
     _aA_=
      [0,
       [11,
        caml_string_of_jsbytes("New unencrypted IVEA data: "),
        [5,7,0,0,[17,4,0]]],
       caml_string_of_jsbytes("New unencrypted IVEA data: %#lx@.")],
     _aB_=
      [0,
       [11,caml_string_of_jsbytes("New low-IVEA: "),[5,7,0,0,[17,4,0]]],
       caml_string_of_jsbytes("New low-IVEA: %#lx@.")],
     _aC_=
      [0,
       [11,caml_string_of_jsbytes("New high-IVEA: "),[5,7,0,0,[17,4,0]]],
       caml_string_of_jsbytes("New high-IVEA: %#lx@.")],
     _aD_=
      [0,
       [11,caml_string_of_jsbytes("Checksum diff: "),[5,7,0,0,[17,4,0]]],
       caml_string_of_jsbytes("Checksum diff: %#lx@.")],
     _aE_=[0,1,0],
     _aF_=[0,1,1],
     _aG_=[0,0,0],
     _aH_=
      [0,
       [2,caml_string_of_jsbytes("_")],
       [1,caml_string_of_jsbytes("\xc3\x80")],
       [1,caml_string_of_jsbytes("\xc3\x81")],
       [1,caml_string_of_jsbytes("\xc3\x82")],
       [1,caml_string_of_jsbytes("\xc3\x87")],
       [1,caml_string_of_jsbytes("\xc3\x88")],
       [1,caml_string_of_jsbytes("\xc3\x89")],
       [1,caml_string_of_jsbytes("\xc3\x8a")],
       [1,caml_string_of_jsbytes("\xc3\x8b")],
       [1,caml_string_of_jsbytes("\xc3\x8c")],
       0,
       [1,caml_string_of_jsbytes("\xc3\x8e")],
       [1,caml_string_of_jsbytes("\xc3\x8f")],
       [1,caml_string_of_jsbytes("\xc3\x92")],
       [1,caml_string_of_jsbytes("\xc3\x93")],
       [1,caml_string_of_jsbytes("\xc3\x94")],
       [1,caml_string_of_jsbytes("\xc5\x92")],
       [1,caml_string_of_jsbytes("\xc3\x99")],
       [1,caml_string_of_jsbytes("\xc3\x9a")],
       [1,caml_string_of_jsbytes("\xc3\x9b")],
       [1,caml_string_of_jsbytes("\xc3\x91")],
       [1,caml_string_of_jsbytes("\xc3\x9f")],
       [1,caml_string_of_jsbytes("\xc3\xa0")],
       [1,caml_string_of_jsbytes("\xc3\xa1")],
       0,
       [1,caml_string_of_jsbytes("\xc3\xa7")],
       [1,caml_string_of_jsbytes("\xc3\xa8")],
       [1,caml_string_of_jsbytes("\xc3\xa9")],
       [1,caml_string_of_jsbytes("\xc3\xaa")],
       [1,caml_string_of_jsbytes("\xc3\xab")],
       [1,caml_string_of_jsbytes("\xc3\xac")],
       0,
       [1,caml_string_of_jsbytes("\xc3\xae")],
       [1,caml_string_of_jsbytes("\xc3\xaf")],
       [1,caml_string_of_jsbytes("\xc3\xb2")],
       [1,caml_string_of_jsbytes("\xc3\xb3")],
       [1,caml_string_of_jsbytes("\xc3\xb4")],
       [1,caml_string_of_jsbytes("\xc5\x93")],
       [1,caml_string_of_jsbytes("\xc3\xb9")],
       [1,caml_string_of_jsbytes("\xc3\xba")],
       [1,caml_string_of_jsbytes("\xc3\xbb")],
       [1,caml_string_of_jsbytes("\xc3\xb1")],
       [1,caml_string_of_jsbytes("\xc2\xba")],
       [1,caml_string_of_jsbytes("\xc2\xaa")],
       [1,caml_string_of_jsbytes("\xe1\xb5\x89\xca\xb3")],
       [1,caml_string_of_jsbytes("&")],
       [1,caml_string_of_jsbytes("+")],
       0,
       0,
       0,
       0,
       0,
       [1,caml_string_of_jsbytes("Lv")],
       [1,caml_string_of_jsbytes("=")],
       [1,caml_string_of_jsbytes(";")],
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       [1,caml_string_of_jsbytes("\xe2\x96\xaf")],
       [1,caml_string_of_jsbytes("\xc2\xbf")],
       [1,caml_string_of_jsbytes("\xc2\xa1")],
       [1,caml_string_of_jsbytes("PK")],
       [1,caml_string_of_jsbytes("MN")],
       [1,caml_string_of_jsbytes("PO")],
       [1,caml_string_of_jsbytes("K\xc3\xa9")],
       [0,caml_string_of_jsbytes("0x57")],
       [0,caml_string_of_jsbytes("0x58")],
       [0,caml_string_of_jsbytes("0x59")],
       [1,caml_string_of_jsbytes("\xc3\x8d")],
       [1,caml_string_of_jsbytes("%")],
       [1,caml_string_of_jsbytes("(")],
       [1,caml_string_of_jsbytes(")")],
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       [1,caml_string_of_jsbytes("\xc3\xa2")],
       0,
       0,
       0,
       0,
       0,
       0,
       [1,caml_string_of_jsbytes("\xc3\xad")],
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       [1,caml_string_of_jsbytes("\xe2\xac\x86")],
       [1,caml_string_of_jsbytes("\xe2\xac\x87")],
       [1,caml_string_of_jsbytes("\xe2\xac\x85")],
       [1,caml_string_of_jsbytes("\xe2\x9e\xa1")],
       [1,caml_string_of_jsbytes("*")],
       [1,caml_string_of_jsbytes("*")],
       [1,caml_string_of_jsbytes("*")],
       [1,caml_string_of_jsbytes("*")],
       [1,caml_string_of_jsbytes("*")],
       [1,caml_string_of_jsbytes("*")],
       [1,caml_string_of_jsbytes("*")],
       [1,caml_string_of_jsbytes("\xe1\xb5\x89")],
       [1,caml_string_of_jsbytes("<")],
       [1,caml_string_of_jsbytes(">")],
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       [1,caml_string_of_jsbytes("\xca\xb3\xe1\xb5\x89")],
       [2,caml_string_of_jsbytes("0")],
       [2,caml_string_of_jsbytes("1")],
       [2,caml_string_of_jsbytes("2")],
       [2,caml_string_of_jsbytes("3")],
       [2,caml_string_of_jsbytes("4")],
       [2,caml_string_of_jsbytes("5")],
       [2,caml_string_of_jsbytes("6")],
       [2,caml_string_of_jsbytes("7")],
       [2,caml_string_of_jsbytes("8")],
       [2,caml_string_of_jsbytes("9")],
       [2,caml_string_of_jsbytes("!")],
       [2,caml_string_of_jsbytes("?")],
       [2,caml_string_of_jsbytes(".")],
       [2,caml_string_of_jsbytes("\xe2\x80\x93")],
       [1,caml_string_of_jsbytes("\xe3\x83\xbb")],
       [2,caml_string_of_jsbytes("\xe2\x80\xa6")],
       [2,caml_string_of_jsbytes("\xe2\x80\x9c")],
       [2,caml_string_of_jsbytes("\xe2\x80\x9d")],
       [2,caml_string_of_jsbytes("\xe2\x80\x98")],
       [2,caml_string_of_jsbytes("\xe2\x80\x99")],
       [2,caml_string_of_jsbytes("\xe2\x99\x82")],
       [2,caml_string_of_jsbytes("\xe2\x99\x80")],
       [1,caml_string_of_jsbytes("Pk$")],
       [2,caml_string_of_jsbytes(",")],
       [1,caml_string_of_jsbytes("\xc3\x97")],
       [2,caml_string_of_jsbytes("/")],
       [2,caml_string_of_jsbytes("A")],
       [2,caml_string_of_jsbytes("B")],
       [2,caml_string_of_jsbytes("C")],
       [2,caml_string_of_jsbytes("D")],
       [2,caml_string_of_jsbytes("E")],
       [2,caml_string_of_jsbytes("F")],
       [2,caml_string_of_jsbytes("G")],
       [2,caml_string_of_jsbytes("H")],
       [2,caml_string_of_jsbytes("I")],
       [2,caml_string_of_jsbytes("J")],
       [2,caml_string_of_jsbytes("K")],
       [2,caml_string_of_jsbytes("L")],
       [2,caml_string_of_jsbytes("M")],
       [2,caml_string_of_jsbytes("N")],
       [2,caml_string_of_jsbytes("O")],
       [2,caml_string_of_jsbytes("P")],
       [2,caml_string_of_jsbytes("Q")],
       [2,caml_string_of_jsbytes("R")],
       [2,caml_string_of_jsbytes("S")],
       [2,caml_string_of_jsbytes("T")],
       [2,caml_string_of_jsbytes("U")],
       [2,caml_string_of_jsbytes("V")],
       [2,caml_string_of_jsbytes("W")],
       [2,caml_string_of_jsbytes("X")],
       [2,caml_string_of_jsbytes("Y")],
       [2,caml_string_of_jsbytes("Z")],
       [2,caml_string_of_jsbytes("a")],
       [2,caml_string_of_jsbytes("b")],
       [2,caml_string_of_jsbytes("c")],
       [2,caml_string_of_jsbytes("d")],
       [2,caml_string_of_jsbytes("e")],
       [2,caml_string_of_jsbytes("f")],
       [2,caml_string_of_jsbytes("g")],
       [2,caml_string_of_jsbytes("h")],
       [2,caml_string_of_jsbytes("i")],
       [2,caml_string_of_jsbytes("j")],
       [2,caml_string_of_jsbytes("k")],
       [2,caml_string_of_jsbytes("l")],
       [2,caml_string_of_jsbytes("m")],
       [2,caml_string_of_jsbytes("n")],
       [2,caml_string_of_jsbytes("o")],
       [2,caml_string_of_jsbytes("p")],
       [2,caml_string_of_jsbytes("q")],
       [2,caml_string_of_jsbytes("r")],
       [2,caml_string_of_jsbytes("s")],
       [2,caml_string_of_jsbytes("t")],
       [2,caml_string_of_jsbytes("u")],
       [2,caml_string_of_jsbytes("v")],
       [2,caml_string_of_jsbytes("w")],
       [2,caml_string_of_jsbytes("x")],
       [2,caml_string_of_jsbytes("y")],
       [2,caml_string_of_jsbytes("z")],
       [1,caml_string_of_jsbytes("\xe2\x96\xb6")],
       [1,caml_string_of_jsbytes(":")],
       [1,caml_string_of_jsbytes("\xc3\x84")],
       [1,caml_string_of_jsbytes("\xc3\x96")],
       [1,caml_string_of_jsbytes("\xc3\x9c")],
       [1,caml_string_of_jsbytes("\xc3\xa4")],
       [1,caml_string_of_jsbytes("\xc3\xb6")],
       [1,caml_string_of_jsbytes("\xc3\xbc")],
       0,
       0,
       0,
       [0,caml_string_of_jsbytes("0xFA")],
       [0,caml_string_of_jsbytes("0xFB")],
       [0,caml_string_of_jsbytes("0xFC")],
       [0,caml_string_of_jsbytes("0xFD")],
       [0,caml_string_of_jsbytes("0xFE")],
       [0,caml_string_of_jsbytes("0xFF")]],
     _aI_=[2,caml_string_of_jsbytes("\xe2\x80\x9e")],
     _aJ_=[2,caml_string_of_jsbytes("\xe2\x80\x9c")],
     _dW_=[0,caml_string_of_jsbytes("Boxes/charset.ml"),98,13],
     _aK_=[2,caml_string_of_jsbytes("\xc2\xab")],
     _aL_=[2,caml_string_of_jsbytes("\xc2\xbb")],
     _aM_=
      [0,
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("\xe3\x81\x82")],
       [2,caml_string_of_jsbytes("\xe3\x81\x84")],
       [2,caml_string_of_jsbytes("\xe3\x81\x86")],
       [2,caml_string_of_jsbytes("\xe3\x81\x88")],
       [2,caml_string_of_jsbytes("\xe3\x81\x8a")],
       [2,caml_string_of_jsbytes("\xe3\x81\x8b")],
       [2,caml_string_of_jsbytes("\xe3\x81\x8d")],
       [2,caml_string_of_jsbytes("\xe3\x81\x8f")],
       [2,caml_string_of_jsbytes("\xe3\x81\x91")],
       [2,caml_string_of_jsbytes("\xe3\x81\x93")],
       [2,caml_string_of_jsbytes("\xe3\x81\x95")],
       [2,caml_string_of_jsbytes("\xe3\x81\x97")],
       [2,caml_string_of_jsbytes("\xe3\x81\x99")],
       [2,caml_string_of_jsbytes("\xe3\x81\x9b")],
       [2,caml_string_of_jsbytes("\xe3\x81\x9d")],
       [2,caml_string_of_jsbytes("\xe3\x81\x9f")],
       [2,caml_string_of_jsbytes("\xe3\x81\xa1")],
       [2,caml_string_of_jsbytes("\xe3\x81\xa4")],
       [2,caml_string_of_jsbytes("\xe3\x81\xa6")],
       [2,caml_string_of_jsbytes("\xe3\x81\xa8")],
       [2,caml_string_of_jsbytes("\xe3\x81\xaa")],
       [2,caml_string_of_jsbytes("\xe3\x81\xab")],
       [2,caml_string_of_jsbytes("\xe3\x81\xac")],
       [2,caml_string_of_jsbytes("\xe3\x81\xad")],
       [2,caml_string_of_jsbytes("\xe3\x81\xae")],
       [2,caml_string_of_jsbytes("\xe3\x81\xaf")],
       [2,caml_string_of_jsbytes("\xe3\x81\xb2")],
       [2,caml_string_of_jsbytes("\xe3\x81\xb5")],
       [2,caml_string_of_jsbytes("\xe3\x81\xb8")],
       [2,caml_string_of_jsbytes("\xe3\x81\xbb")],
       [2,caml_string_of_jsbytes("\xe3\x81\xbe")],
       [2,caml_string_of_jsbytes("\xe3\x81\xbf")],
       [2,caml_string_of_jsbytes("\xe3\x82\x80")],
       [2,caml_string_of_jsbytes("\xe3\x82\x81")],
       [2,caml_string_of_jsbytes("\xe3\x82\x82")],
       [2,caml_string_of_jsbytes("\xe3\x82\x84")],
       [2,caml_string_of_jsbytes("\xe3\x82\x86")],
       [2,caml_string_of_jsbytes("\xe3\x82\x88")],
       [2,caml_string_of_jsbytes("\xe3\x82\x89")],
       [2,caml_string_of_jsbytes("\xe3\x82\x8a")],
       [2,caml_string_of_jsbytes("\xe3\x82\x8b")],
       [2,caml_string_of_jsbytes("\xe3\x82\x8c")],
       [2,caml_string_of_jsbytes("\xe3\x82\x8d")],
       [2,caml_string_of_jsbytes("\xe3\x82\x8f")],
       [2,caml_string_of_jsbytes("\xe3\x82\x92")],
       [2,caml_string_of_jsbytes("\xe3\x82\x93")],
       [2,caml_string_of_jsbytes("\xe3\x81\x81")],
       [2,caml_string_of_jsbytes("\xe3\x81\x83")],
       [2,caml_string_of_jsbytes("\xe3\x81\x85")],
       [2,caml_string_of_jsbytes("\xe3\x81\x87")],
       [2,caml_string_of_jsbytes("\xe3\x81\x89")],
       [2,caml_string_of_jsbytes("\xe3\x82\x83")],
       [2,caml_string_of_jsbytes("\xe3\x82\x85")],
       [2,caml_string_of_jsbytes("\xe3\x82\x87")],
       [2,caml_string_of_jsbytes("\xe3\x81\x8c")],
       [2,caml_string_of_jsbytes("\xe3\x81\x8e")],
       [2,caml_string_of_jsbytes("\xe3\x81\x90")],
       [2,caml_string_of_jsbytes("\xe3\x81\x92")],
       [2,caml_string_of_jsbytes("\xe3\x81\x94")],
       [2,caml_string_of_jsbytes("\xe3\x81\x96")],
       [2,caml_string_of_jsbytes("\xe3\x81\x98")],
       [2,caml_string_of_jsbytes("\xe3\x81\x9a")],
       [2,caml_string_of_jsbytes("\xe3\x81\x9c")],
       [2,caml_string_of_jsbytes("\xe3\x81\x9e")],
       [2,caml_string_of_jsbytes("\xe3\x81\xa0")],
       [2,caml_string_of_jsbytes("\xe3\x81\xa2")],
       [2,caml_string_of_jsbytes("\xe3\x81\xa5")],
       [2,caml_string_of_jsbytes("\xe3\x81\xa7")],
       [2,caml_string_of_jsbytes("\xe3\x81\xa9")],
       [2,caml_string_of_jsbytes("\xe3\x81\xb0")],
       [2,caml_string_of_jsbytes("\xe3\x81\xb3")],
       [2,caml_string_of_jsbytes("\xe3\x81\xb6")],
       [2,caml_string_of_jsbytes("\xe3\x81\xb9")],
       [2,caml_string_of_jsbytes("\xe3\x81\xbc")],
       [2,caml_string_of_jsbytes("\xe3\x81\xb1")],
       [2,caml_string_of_jsbytes("\xe3\x81\xb4")],
       [2,caml_string_of_jsbytes("\xe3\x81\xb7")],
       [2,caml_string_of_jsbytes("\xe3\x81\xba")],
       [2,caml_string_of_jsbytes("\xe3\x81\xbd")],
       [2,caml_string_of_jsbytes("\xe3\x81\xa3")],
       [2,caml_string_of_jsbytes("\xe3\x82\xa2")],
       [2,caml_string_of_jsbytes("\xe3\x82\xa4")],
       [2,caml_string_of_jsbytes("\xe3\x82\xa6")],
       [2,caml_string_of_jsbytes("\xe3\x82\xa8")],
       [2,caml_string_of_jsbytes("\xe3\x82\xaa")],
       [2,caml_string_of_jsbytes("\xe3\x82\xab")],
       [2,caml_string_of_jsbytes("\xe3\x82\xad")],
       [2,caml_string_of_jsbytes("\xe3\x82\xaf")],
       [2,caml_string_of_jsbytes("\xe3\x82\xb1")],
       [2,caml_string_of_jsbytes("\xe3\x82\xb3")],
       [2,caml_string_of_jsbytes("\xe3\x82\xb5")],
       [2,caml_string_of_jsbytes("\xe3\x82\xb7")],
       [2,caml_string_of_jsbytes("\xe3\x82\xb9")],
       [2,caml_string_of_jsbytes("\xe3\x82\xbb")],
       [2,caml_string_of_jsbytes("\xe3\x82\xbd")],
       [2,caml_string_of_jsbytes("\xe3\x82\xbf")],
       [2,caml_string_of_jsbytes("\xe3\x83\x81")],
       [2,caml_string_of_jsbytes("\xe3\x83\x84")],
       [2,caml_string_of_jsbytes("\xe3\x83\x86")],
       [2,caml_string_of_jsbytes("\xe3\x83\x88")],
       [2,caml_string_of_jsbytes("\xe3\x83\x8a")],
       [2,caml_string_of_jsbytes("\xe3\x83\x8b")],
       [2,caml_string_of_jsbytes("\xe3\x83\x8c")],
       [2,caml_string_of_jsbytes("\xe3\x83\x8d")],
       [2,caml_string_of_jsbytes("\xe3\x83\x8e")],
       [2,caml_string_of_jsbytes("\xe3\x83\x8f")],
       [2,caml_string_of_jsbytes("\xe3\x83\x92")],
       [2,caml_string_of_jsbytes("\xe3\x83\x95")],
       [2,caml_string_of_jsbytes("\xe3\x83\x98")],
       [2,caml_string_of_jsbytes("\xe3\x83\x9b")],
       [2,caml_string_of_jsbytes("\xe3\x83\x9e")],
       [2,caml_string_of_jsbytes("\xe3\x83\x9f")],
       [2,caml_string_of_jsbytes("\xe3\x83\xa0")],
       [2,caml_string_of_jsbytes("\xe3\x83\xa1")],
       [2,caml_string_of_jsbytes("\xe3\x83\xa2")],
       [2,caml_string_of_jsbytes("\xe3\x83\xa4")],
       [2,caml_string_of_jsbytes("\xe3\x83\xa6")],
       [2,caml_string_of_jsbytes("\xe3\x83\xa8")],
       [2,caml_string_of_jsbytes("\xe3\x83\xa9")],
       [2,caml_string_of_jsbytes("\xe3\x83\xaa")],
       [2,caml_string_of_jsbytes("\xe3\x83\xab")],
       [2,caml_string_of_jsbytes("\xe3\x83\xac")],
       [2,caml_string_of_jsbytes("\xe3\x83\xad")],
       [2,caml_string_of_jsbytes("\xe3\x83\xaf")],
       [2,caml_string_of_jsbytes("\xe3\x83\xb2")],
       [2,caml_string_of_jsbytes("\xe3\x83\xb3")],
       [2,caml_string_of_jsbytes("\xe3\x82\xa1")],
       [2,caml_string_of_jsbytes("\xe3\x82\xa3")],
       [2,caml_string_of_jsbytes("\xe3\x82\xa5")],
       [2,caml_string_of_jsbytes("\xe3\x82\xa7")],
       [2,caml_string_of_jsbytes("\xe3\x82\xa9")],
       [2,caml_string_of_jsbytes("\xe3\x83\xa3")],
       [2,caml_string_of_jsbytes("\xe3\x83\xa5")],
       [2,caml_string_of_jsbytes("\xe3\x83\xa7")],
       [2,caml_string_of_jsbytes("\xe3\x82\xac")],
       [2,caml_string_of_jsbytes("\xe3\x82\xae")],
       [2,caml_string_of_jsbytes("\xe3\x82\xb0")],
       [2,caml_string_of_jsbytes("\xe3\x82\xb2")],
       [2,caml_string_of_jsbytes("\xe3\x82\xb4")],
       [2,caml_string_of_jsbytes("\xe3\x82\xb6")],
       [2,caml_string_of_jsbytes("\xe3\x82\xb8")],
       [2,caml_string_of_jsbytes("\xe3\x82\xba")],
       [2,caml_string_of_jsbytes("\xe3\x82\xbc")],
       [2,caml_string_of_jsbytes("\xe3\x82\xbe")],
       [2,caml_string_of_jsbytes("\xe3\x83\x80")],
       [2,caml_string_of_jsbytes("\xe3\x83\x82")],
       [2,caml_string_of_jsbytes("\xe3\x83\x85")],
       [2,caml_string_of_jsbytes("\xe3\x83\x87")],
       [2,caml_string_of_jsbytes("\xe3\x83\x89")],
       [2,caml_string_of_jsbytes("\xe3\x83\x90")],
       [2,caml_string_of_jsbytes("\xe3\x83\x93")],
       [2,caml_string_of_jsbytes("\xe3\x83\x96")],
       [2,caml_string_of_jsbytes("\xe3\x83\x99")],
       [2,caml_string_of_jsbytes("\xe3\x83\x9c")],
       [2,caml_string_of_jsbytes("\xe3\x83\x91")],
       [2,caml_string_of_jsbytes("\xe3\x83\x94")],
       [2,caml_string_of_jsbytes("\xe3\x83\x97")],
       [2,caml_string_of_jsbytes("\xe3\x83\x9a")],
       [2,caml_string_of_jsbytes("\xe3\x83\x9d")],
       [2,caml_string_of_jsbytes("\xe3\x83\x83")],
       [2,caml_string_of_jsbytes("0")],
       [2,caml_string_of_jsbytes("1")],
       [2,caml_string_of_jsbytes("2")],
       [2,caml_string_of_jsbytes("3")],
       [2,caml_string_of_jsbytes("4")],
       [2,caml_string_of_jsbytes("5")],
       [2,caml_string_of_jsbytes("6")],
       [2,caml_string_of_jsbytes("7")],
       [2,caml_string_of_jsbytes("8")],
       [2,caml_string_of_jsbytes("9")],
       [2,caml_string_of_jsbytes("\xef\xbc\x81")],
       [2,caml_string_of_jsbytes("\xef\xbc\x9f")],
       [2,caml_string_of_jsbytes("\xe3\x80\x82")],
       [2,caml_string_of_jsbytes("\xe3\x83\xbc")],
       [2,caml_string_of_jsbytes("\xe3\x83\xbb")],
       [2,caml_string_of_jsbytes("\xe2\x80\xa5")],
       [2,caml_string_of_jsbytes("\xe3\x80\x8e")],
       [2,caml_string_of_jsbytes("\xe3\x80\x8f")],
       [2,caml_string_of_jsbytes("\xe3\x80\x8c")],
       [2,caml_string_of_jsbytes("\xe3\x80\x8d")],
       [2,caml_string_of_jsbytes("\xe2\x99\x82")],
       [2,caml_string_of_jsbytes("\xe2\x99\x80")],
       [1,caml_string_of_jsbytes("\xe5\x86\x86")],
       [1,caml_string_of_jsbytes(".")],
       [1,caml_string_of_jsbytes("\xc3\x97")],
       [2,caml_string_of_jsbytes("/")],
       [2,caml_string_of_jsbytes("A")],
       [2,caml_string_of_jsbytes("B")],
       [2,caml_string_of_jsbytes("C")],
       [2,caml_string_of_jsbytes("D")],
       [2,caml_string_of_jsbytes("E")],
       [2,caml_string_of_jsbytes("F")],
       [2,caml_string_of_jsbytes("G")],
       [2,caml_string_of_jsbytes("H")],
       [2,caml_string_of_jsbytes("I")],
       [2,caml_string_of_jsbytes("J")],
       [2,caml_string_of_jsbytes("K")],
       [2,caml_string_of_jsbytes("L")],
       [2,caml_string_of_jsbytes("M")],
       [2,caml_string_of_jsbytes("N")],
       [2,caml_string_of_jsbytes("O")],
       [2,caml_string_of_jsbytes("P")],
       [2,caml_string_of_jsbytes("Q")],
       [2,caml_string_of_jsbytes("R")],
       [2,caml_string_of_jsbytes("S")],
       [2,caml_string_of_jsbytes("T")],
       [2,caml_string_of_jsbytes("U")],
       [2,caml_string_of_jsbytes("V")],
       [2,caml_string_of_jsbytes("W")],
       [2,caml_string_of_jsbytes("X")],
       [2,caml_string_of_jsbytes("Y")],
       [2,caml_string_of_jsbytes("Z")],
       [2,caml_string_of_jsbytes("a")],
       [2,caml_string_of_jsbytes("b")],
       [2,caml_string_of_jsbytes("c")],
       [2,caml_string_of_jsbytes("d")],
       [2,caml_string_of_jsbytes("e")],
       [2,caml_string_of_jsbytes("f")],
       [2,caml_string_of_jsbytes("g")],
       [2,caml_string_of_jsbytes("h")],
       [2,caml_string_of_jsbytes("i")],
       [2,caml_string_of_jsbytes("j")],
       [2,caml_string_of_jsbytes("k")],
       [2,caml_string_of_jsbytes("l")],
       [2,caml_string_of_jsbytes("m")],
       [2,caml_string_of_jsbytes("n")],
       [2,caml_string_of_jsbytes("o")],
       [2,caml_string_of_jsbytes("p")],
       [2,caml_string_of_jsbytes("q")],
       [2,caml_string_of_jsbytes("r")],
       [2,caml_string_of_jsbytes("s")],
       [2,caml_string_of_jsbytes("t")],
       [2,caml_string_of_jsbytes("u")],
       [2,caml_string_of_jsbytes("v")],
       [2,caml_string_of_jsbytes("w")],
       [2,caml_string_of_jsbytes("x")],
       [2,caml_string_of_jsbytes("y")],
       [2,caml_string_of_jsbytes("z")],
       [1,caml_string_of_jsbytes("\xe2\x96\xb6")],
       [1,caml_string_of_jsbytes(":")],
       [1,caml_string_of_jsbytes("\xc3\x84")],
       [1,caml_string_of_jsbytes("\xc3\x96")],
       [1,caml_string_of_jsbytes("\xc3\x9c")],
       [1,caml_string_of_jsbytes("\xc3\xa4")],
       [1,caml_string_of_jsbytes("\xc3\xb6")],
       [1,caml_string_of_jsbytes("\xc3\xbc")],
       0,
       0,
       0,
       [0,caml_string_of_jsbytes("0xFA")],
       [0,caml_string_of_jsbytes("0xFB")],
       [0,caml_string_of_jsbytes("0xFC")],
       [0,caml_string_of_jsbytes("0xFD")],
       [0,caml_string_of_jsbytes("0xFE")],
       [0,caml_string_of_jsbytes("0xFF")]],
     _aP_=[0,[2,0,0],caml_string_of_jsbytes("%s")],
     _aO_=[0,[2,0,[2,0,0]],caml_string_of_jsbytes("%s%s")],
     _aN_=[0,caml_string_of_jsbytes("Boxes/name.ml"),34,9],
     _a1_=[0,caml_string_of_jsbytes("ARM/optimizer.ml"),199,2],
     _a0_=[0,caml_string_of_jsbytes("ARM/optimizer.ml"),228,11],
     _aZ_=[0,caml_string_of_jsbytes("ARM/optimizer.ml"),195,11],
     _aY_=[0,65536,65536,65536,512,64,8,1],
     _br_=[0,0,0,0,0,1],
     _bs_=[0,0,0,1,0,0],
     _bt_=[0,0,0,0,1,0],
     _bo_=[0,caml_string_of_jsbytes("X")],
     _bp_=[0,caml_string_of_jsbytes("S")],
     _bq_=[0,caml_string_of_jsbytes("L")],
     _bl_=[0,3],
     _bm_=[0,1],
     _bn_=[0,6],
     _bh_=[0,4],
     _bi_=[0,5],
     _bj_=[0,2],
     _bk_=[0,0],
     _a$_=[0,3],
     _ba_=[0,10],
     _bb_=[0,14],
     _bc_=[0,12],
     _bd_=[0,0],
     _be_=[0,2],
     _bf_=[0,4],
     _bg_=[0,16],
     _a2_=[0,8],
     _a3_=[0,9],
     _a4_=[0,7],
     _a5_=[0,1],
     _a6_=[0,6],
     _a7_=[0,13],
     _a8_=[0,11],
     _a9_=[0,5],
     _a__=[0,15],
     _bu_=[0,caml_string_of_jsbytes("IO/parser.ml"),143,8],
     _bv_=[0,caml_string_of_jsbytes("IO/parser.ml"),167,8],
     _bw_=[0,caml_string_of_jsbytes("IO/parser.ml"),191,8],
     _bx_=[0,caml_string_of_jsbytes("IO/parser.ml"),215,8],
     _by_=[0,caml_string_of_jsbytes("IO/parser.ml"),239,8],
     _bz_=[0,caml_string_of_jsbytes("IO/parser.ml"),263,8],
     _bA_=[0,caml_string_of_jsbytes("IO/parser.ml"),287,8],
     _bB_=[0,caml_string_of_jsbytes("IO/parser.ml"),311,8],
     _bC_=[0,caml_string_of_jsbytes("IO/parser.ml"),335,8],
     _bD_=[0,caml_string_of_jsbytes("IO/parser.ml"),359,8],
     _bE_=[0,caml_string_of_jsbytes("IO/parser.ml"),383,8],
     _bF_=[0,caml_string_of_jsbytes("IO/parser.ml"),407,8],
     _bG_=[0,caml_string_of_jsbytes("IO/parser.ml"),431,8],
     _bH_=[0,caml_string_of_jsbytes("IO/parser.ml"),455,8],
     _bI_=[0,caml_string_of_jsbytes("IO/parser.ml"),479,8],
     _bJ_=[0,caml_string_of_jsbytes("IO/parser.ml"),503,8],
     _bK_=[0,caml_string_of_jsbytes("IO/parser.ml"),540,16],
     _bL_=[0,caml_string_of_jsbytes("IO/parser.ml"),546,12],
     _bM_=[0,caml_string_of_jsbytes("IO/parser.ml"),1320,8],
     _bN_=[0,caml_string_of_jsbytes("IO/parser.ml"),1367,12],
     _bO_=[0,caml_string_of_jsbytes("IO/parser.ml"),1266,8],
     _bP_=[0,caml_string_of_jsbytes("IO/parser.ml"),1313,12],
     _bQ_=[0,caml_string_of_jsbytes("IO/parser.ml"),1139,8],
     _bR_=[0,caml_string_of_jsbytes("IO/parser.ml"),1176,12],
     _bS_=[0,caml_string_of_jsbytes("IO/parser.ml"),1093,8],
     _bT_=[0,caml_string_of_jsbytes("IO/parser.ml"),1132,12],
     _bU_=[0,caml_string_of_jsbytes("IO/parser.ml"),1043,8],
     _bV_=[0,caml_string_of_jsbytes("IO/parser.ml"),1086,12],
     _bW_=[0,caml_string_of_jsbytes("IO/parser.ml"),979,8],
     _bY_=[0,caml_string_of_jsbytes("IO/parser.ml"),1008,16],
     _bX_=[0,caml_string_of_jsbytes("IO/parser.ml"),1036,12],
     _bZ_=[0,caml_string_of_jsbytes("IO/parser.ml"),937,8],
     _b0_=[0,caml_string_of_jsbytes("IO/parser.ml"),972,12],
     _b1_=[0,caml_string_of_jsbytes("IO/parser.ml"),899,8],
     _b2_=[0,caml_string_of_jsbytes("IO/parser.ml"),930,12],
     _b3_=[0,caml_string_of_jsbytes("IO/parser.ml"),865,8],
     _b4_=[0,caml_string_of_jsbytes("IO/parser.ml"),892,12],
     _b5_=[0,caml_string_of_jsbytes("IO/parser.ml"),835,8],
     _b6_=[0,caml_string_of_jsbytes("IO/parser.ml"),858,12],
     _b7_=[0,caml_string_of_jsbytes("IO/parser.ml"),801,8],
     _b8_=[0,caml_string_of_jsbytes("IO/parser.ml"),828,12],
     _b9_=[0,caml_string_of_jsbytes("IO/parser.ml"),775,8],
     _b__=[0,caml_string_of_jsbytes("IO/parser.ml"),794,12],
     _b$_=[0,caml_string_of_jsbytes("IO/parser.ml"),729,8],
     _ca_=[0,caml_string_of_jsbytes("IO/parser.ml"),748,12],
     _cb_=[0,caml_string_of_jsbytes("IO/parser.ml"),699,8],
     _cc_=[0,caml_string_of_jsbytes("IO/parser.ml"),722,12],
     _cd_=[0,caml_string_of_jsbytes("IO/parser.ml"),649,8],
     _ce_=[0,caml_string_of_jsbytes("IO/parser.ml"),682,12],
     _cf_=[0,caml_string_of_jsbytes("IO/parser.ml"),597,8],
     _cg_=[0,caml_string_of_jsbytes("IO/parser.ml"),642,12],
     _ch_=[0,caml_string_of_jsbytes("IO/parser.ml"),1213,8],
     _ci_=[0,caml_string_of_jsbytes("IO/parser.ml"),1259,12],
     _cj_=[0,caml_string_of_jsbytes("IO/parser.ml"),1379,4],
     _ck_=[0,caml_string_of_jsbytes("IO/parser.ml"),1402,12],
     _cl_=[0,caml_string_of_jsbytes("IO/parser.ml"),1406,8],
     _cm_=[0,caml_string_of_jsbytes("IO/parser.ml"),1554,8],
     _cn_=[0,caml_string_of_jsbytes("IO/parser.ml"),1588,8],
     _cp_=[0,caml_string_of_jsbytes("IO/parser.ml"),1650,12],
     _cq_=[0,caml_string_of_jsbytes("IO/parser.ml"),1633,12],
     _co_=[0,caml_string_of_jsbytes("IO/parser.ml"),1654,8],
     _cr_=[0,caml_string_of_jsbytes("IO/parser.ml"),1662,4],
     _ct_=[0,caml_string_of_jsbytes("IO/parser.ml"),1681,12],
     _cs_=[0,caml_string_of_jsbytes("IO/parser.ml"),1694,8],
     _cu_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("Internal failure -- please contact the parser generator's developers.\n"),
        [10,0]],
       caml_string_of_jsbytes
        ("Internal failure -- please contact the parser generator's developers.\n%!")],
     _cv_=[0,caml_string_of_jsbytes("IO/parser.ml"),1703,4],
     _cw_=[0,caml_string_of_jsbytes("IO/parser.ml"),1726,8],
     _cx_=[0,caml_string_of_jsbytes("IO/parser.ml"),1772,8],
     _cy_=[0,caml_string_of_jsbytes("IO/parser.ml"),1797,8],
     _cz_=[0,caml_string_of_jsbytes("IO/parser.ml"),1822,8],
     _cA_=[0,caml_string_of_jsbytes("IO/parser.ml"),1868,8],
     _cB_=[0,caml_string_of_jsbytes("IO/parser.ml"),1876,4],
     _cC_=[0,caml_string_of_jsbytes("IO/parser.ml"),1889,12],
     _cD_=[0,caml_string_of_jsbytes("IO/parser.ml"),1893,8],
     _cE_=[0,caml_string_of_jsbytes("IO/parser.ml"),1925,4],
     _cG_=[0,caml_string_of_jsbytes("IO/parser.ml"),1981,12],
     _cF_=[0,caml_string_of_jsbytes("IO/parser.ml"),2006,8],
     _cK_=[0,caml_string_of_jsbytes("IO/parser.ml"),2065,16],
     _cJ_=[0,caml_string_of_jsbytes("IO/parser.ml"),2091,20],
     _cI_=[0,caml_string_of_jsbytes("IO/parser.ml"),2123,16],
     _cL_=[0,caml_string_of_jsbytes("IO/parser.ml"),2129,12],
     _cH_=[0,caml_string_of_jsbytes("IO/parser.ml"),2135,8],
     _cM_=[0,caml_string_of_jsbytes("IO/parser.ml"),2162,8],
     _cN_=[0,caml_string_of_jsbytes("IO/parser.ml"),2198,8],
     _cO_=[0,caml_string_of_jsbytes("IO/parser.ml"),2241,8],
     _cQ_=[0,caml_string_of_jsbytes("IO/parser.ml"),2283,16],
     _cP_=[0,caml_string_of_jsbytes("IO/parser.ml"),2291,12],
     _cR_=[0,caml_string_of_jsbytes("IO/parser.ml"),2296,8],
     _cU_=[0,caml_string_of_jsbytes("IO/parser.ml"),2414,24],
     _cV_=[0,caml_string_of_jsbytes("IO/parser.ml"),2419,20],
     _cT_=[0,caml_string_of_jsbytes("IO/parser.ml"),2424,16],
     _cY_=[0,caml_string_of_jsbytes("IO/parser.ml"),2456,20],
     _cW_=[0,caml_string_of_jsbytes("IO/parser.ml"),2484,24],
     _cX_=[0,caml_string_of_jsbytes("IO/parser.ml"),2488,20],
     _cZ_=[0,caml_string_of_jsbytes("IO/parser.ml"),2493,16],
     _cS_=[0,caml_string_of_jsbytes("IO/parser.ml"),2498,12],
     _c0_=[0,caml_string_of_jsbytes("IO/parser.ml"),2686,8],
     _c1_=[0,caml_string_of_jsbytes("IO/parser.ml"),2719,8],
     _c2_=[0,caml_string_of_jsbytes("IO/parser.ml"),2740,8],
     _c3_=[3,1],
     _c4_=[3,0],
     _c8_=
      [0,
       [15,[11,caml_string_of_jsbytes(": command error\n"),0]],
       caml_string_of_jsbytes("%a: command error\n")],
     _c6_=
      [0,
       [15,[11,caml_string_of_jsbytes(": "),[2,0,[12,10,0]]]],
       caml_string_of_jsbytes("%a: %s\n")],
     _c7_=
      [0,
       [15,[11,caml_string_of_jsbytes(": parser error\n"),0]],
       caml_string_of_jsbytes("%a: parser error\n")],
     _c5_=
      [0,
       [2,0,[12,58,[4,0,0,0,[12,58,[4,0,0,0,0]]]]],
       caml_string_of_jsbytes("%s:%d:%d")],
     _c9_=
      [0,
       [11,caml_string_of_jsbytes("Available characters: "),[17,4,0]],
       caml_string_of_jsbytes("Available characters: @.")],
     _c__=[0,[2,0,0],caml_string_of_jsbytes("%s")],
     _c$_=
      [0,
       [17,
        4,
        [11,caml_string_of_jsbytes("Please enter text to encode: "),[17,2,0]]],
       caml_string_of_jsbytes("@.Please enter text to encode: @?")],
     _da_=
      [0,
       [4,8,[0,2,2],0,[4,8,[0,2,2],0,[12,32,0]]],
       caml_string_of_jsbytes("%02X%02X ")],
     _db_=[0,caml_string_of_jsbytes("Main/encoder_common.ml"),34,11],
     _dc_=
      [0,
       [4,
        8,
        [0,2,2],
        0,
        [4,8,[0,2,2],0,[4,8,[0,2,2],0,[4,8,[0,2,2],0,[12,32,0]]]]],
       caml_string_of_jsbytes("%02X%02X%02X%02X ")],
     _dd_=[0,caml_string_of_jsbytes("Main/encoder_common.ml"),42,11],
     _df_=
      [0,
       [11,caml_string_of_jsbytes("Encoded data (1-byte): "),[17,4,0]],
       caml_string_of_jsbytes("Encoded data (1-byte): @.")],
     _dg_=[0,[4,8,[0,2,2],0,[12,32,0]],caml_string_of_jsbytes("%02X ")],
     _dl_=[0,0,0],
     _dh_=
      [0,
       [17,4,[11,caml_string_of_jsbytes("Encoded data (2-bytes): "),[17,4,0]]],
       caml_string_of_jsbytes("@.Encoded data (2-bytes): @.")],
     _dk_=[0,0,[0,0,0]],
     _di_=
      [0,
       [17,4,[11,caml_string_of_jsbytes("Encoded data (4-bytes): "),[17,4,0]]],
       caml_string_of_jsbytes("@.Encoded data (4-bytes): @.")],
     _dj_=[0,[17,4,0],caml_string_of_jsbytes("@.")],
     _de_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("An error occured. Please check you only use available characters."),
        0],
       caml_string_of_jsbytes
        ("An error occured. Please check you only use available characters.")],
     _dr_=[0,0],
     _dv_=
      [0,[4,8,[0,2,2],0,[12,32,[17,2,0]]],caml_string_of_jsbytes("%02X @?")],
     _du_=
      [0,
       [11,
        caml_string_of_jsbytes("Box "),
        [4,
         3,
         [0,1,2],
         0,
         [11,
          caml_string_of_jsbytes(": "),
          [15,[11,caml_string_of_jsbytes("\t["),[15,[12,93,[17,4,0]]]]]]]],
       caml_string_of_jsbytes("Box %2i: %a\t[%a]@.")],
     _dt_=[0,1],
     _ds_=[0,0],
     _dq_=[0,caml_string_of_jsbytes("Boxes/boxes.ml"),35,12],
     _dm_=[0,0,[0,0,[0,0,[0,255,0]]]],
     _dn_=[0,0,[0,0,[0,255,[0,0,0]]]],
     _do_=[0,0,[0,255,[0,0,[0,0,0]]]],
     _dp_=[0,255,[0,0,[0,0,[0,0,0]]]],
     _dF_=
      [0,
       [2,0,[2,0,[2,0,[12,32,[15,[11,caml_string_of_jsbytes(", "),[15,0]]]]]]],
       caml_string_of_jsbytes("%s%s%s %a, %a")],
     _dG_=
      [0,
       [2,0,[2,0,[2,0,[12,32,[15,[11,caml_string_of_jsbytes(", "),[15,0]]]]]]],
       caml_string_of_jsbytes("%s%s%s %a, %a")],
     _dH_=
      [0,
       [2,
        0,
        [2,
         0,
         [2,
          0,
          [12,
           32,
           [15,
            [11,
             caml_string_of_jsbytes(", "),
             [15,[11,caml_string_of_jsbytes(", "),[15,0]]]]]]]]],
       caml_string_of_jsbytes("%s%s%s %a, %a, %a")],
     _dI_=
      [0,
       [12,66,[2,0,[2,0,[12,32,[15,0]]]]],
       caml_string_of_jsbytes("B%s%s %a")],
     _dJ_=
      [0,
       [12,66,[2,0,[12,88,[2,0,[12,32,[15,0]]]]]],
       caml_string_of_jsbytes("B%sX%s %a")],
     _dB_=
      [0,
       [12,91,[15,[11,caml_string_of_jsbytes("], "),[15,0]]]],
       caml_string_of_jsbytes("[%a], %a")],
     _dC_=
      [0,
       [12,91,[15,[11,caml_string_of_jsbytes(", "),[15,[12,93,[2,0,0]]]]]],
       caml_string_of_jsbytes("[%a, %a]%s")],
     _dD_=
      [0,
       [12,91,[15,[11,caml_string_of_jsbytes("], "),[2,0,[15,0]]]]],
       caml_string_of_jsbytes("[%a], %s%a")],
     _dE_=
      [0,
       [12,
        91,
        [15,[11,caml_string_of_jsbytes(", "),[2,0,[15,[12,93,[2,0,0]]]]]]],
       caml_string_of_jsbytes("[%a, %s%a]%s")],
     _dA_=[0,[12,35,[2,0,[5,7,0,0,0]]],caml_string_of_jsbytes("#%s%#lx")],
     _dz_=[0,[15,0],caml_string_of_jsbytes("%a")],
     _dy_=[0,[12,35,[5,7,0,0,0]],caml_string_of_jsbytes("#%#lx")],
     _dx_=[0,[12,114,[4,0,0,0,0]],caml_string_of_jsbytes("r%d")],
     _dw_=[0,[5,8,[0,2,8],0,0],caml_string_of_jsbytes("%08lX")],
     _dL_=
      [0,
       [11,caml_string_of_jsbytes("filler"),[21,1,0]],
       caml_string_of_jsbytes("filler%n")],
     _dM_=
      [0,
       [17,
        4,
        [11,caml_string_of_jsbytes("Raw data (in hexadecimal):"),[17,4,0]]],
       caml_string_of_jsbytes("@.Raw data (in hexadecimal):@.")],
     _dN_=
      [0,[4,8,[0,2,2],0,[12,32,[17,2,0]]],caml_string_of_jsbytes("%02X @?")],
     _dO_=[0,[17,4,0],caml_string_of_jsbytes("@.")],
     _dP_=[0,[17,4,[15,[17,4,0]]],caml_string_of_jsbytes("@.%a@.")],
     _dQ_=
      [0,
       [11,
        caml_string_of_jsbytes("Warning: Not enough space... Need "),
        [21,1,[12,47,[21,1,[11,caml_string_of_jsbytes(" boxes."),[17,4,0]]]]]],
       caml_string_of_jsbytes
        ("Warning: Not enough space... Need %n/%n boxes.@.")],
     _dR_=
      [0,
       [11,
        caml_string_of_jsbytes("Warning: Contains unwritable characters..."),
        [17,4,0]],
       caml_string_of_jsbytes("Warning: Contains unwritable characters...@.")],
     _dV_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("Warning: A box name cannot be written (only contains spaces)..."),
        [17,4,0]],
       caml_string_of_jsbytes
        ("Warning: A box name cannot be written (only contains spaces)...@.")],
     _dS_=
      [0,
       [11,caml_string_of_jsbytes("Raw data (in hexadecimal):"),[17,4,0]],
       caml_string_of_jsbytes("Raw data (in hexadecimal):@.")],
     _dT_=[0,[15,0],caml_string_of_jsbytes("%a")],
     _dU_=[0,[17,4,0],caml_string_of_jsbytes("@.")],
     _dK_=
      [0,
       [15,[11,caml_string_of_jsbytes(" \t"),[15,[12,9,[15,[17,4,0]]]]]],
       caml_string_of_jsbytes("%a \t%a\t%a@.")];
    function enumerate_files(dirname,ext)
     {var
       _mX_=runtime.caml_sys_read_directory(dirname),
       _mY_=caml_call1(Stdlib_array[11],_mX_);
      function _mZ_(x)
       {return caml_string_equal(caml_call1(Stdlib_filename[10],x),ext)}
      return caml_call2(Stdlib_list[41],_mZ_,_mY_)}
    function uint32_of_str(str)
     {var
       str$0=caml_call1(Stdlib_string[16],str),
       i64=runtime.caml_int64_of_string(str$0);
      if(caml_call2(Stdlib_int64[17],Stdlib_int64[1],caml_int64_and(_a_,i64)))
       return runtime.caml_int64_to_int32(i64);
      throw [0,Stdlib[7],cst_Not_a_valid_int32]}
    function uint32_to_int(v)
     {var match=caml_call1(Stdlib_int32[12],v);
      if(match){var i=match[1];return i}
      throw [0,Assert_failure,_b_]}
    function int64_of_uint32(x)
     {return caml_int64_and(_c_,caml_int64_of_int32(x))}
    function _d_(param){return 0}
    function _e_(param,_mW_,_mV_){return 0}
    var dummy_fmt=caml_call2(Stdlib_format[113],_e_,_d_);
    function concat_strings(lst)
     {function pp(fmt,lst)
       {function _mU_(str){return caml_call3(Stdlib_format[126],fmt,_f_,str)}
        return caml_call2(Stdlib_list[17],_mU_,lst)}
      return caml_call3(Stdlib_format[130],_g_,pp,lst)}
    var
     Utils=
      [0,
       enumerate_files,
       uint32_of_str,
       uint32_to_int,
       int64_of_uint32,
       dummy_fmt,
       concat_strings];
    caml_register_global(470,Utils,"Utils");
    function int32_from_low_high(l,h){return l | h << 16}
    function int32_to_low_high(i)
     {var l=65535 & i,h=i >>> 16 | 0;return [0,l,h]}
    var
     substructures_order=_h_.slice(),
     data_offset=32,
     len=48,
     pid_offset=0,
     otid_offset=4,
     checksum_offset=28;
    function pkmn_from_bytes(buf)
     {var
       pid=caml_call2(Stdlib_bytes[57],buf,pid_offset),
       otid=caml_call2(Stdlib_bytes[57],buf,otid_offset);
      return [0,pid,otid]}
    function substructure_position(param,ss)
     {var
       pid=param[1],
       i=uint32_to_int(caml_call2(Stdlib_int32[5],pid,24)),
       order=caml_check_bound(substructures_order,i)[1 + i],
       i$0=0;
      for(;;)
       {if(runtime.caml_string_get(order,i$0) === ss)return i$0;
        var i$1=i$0 + 1 | 0,i$0=i$1;
        continue}}
    function substructure_offset(pkmn,ss)
     {var p=substructure_position(pkmn,ss);return 32 + (12 * p | 0) | 0}
    function encrypt_aligned_int32(pkmn,i)
     {var otid=pkmn[2],pid=pkmn[1],key=pid ^ otid;return i ^ key}
    function checksum_diff_for_aligned_int3(o,n)
     {var
       match=int32_to_low_high(o),
       ho=match[2],
       lo=match[1],
       match$0=int32_to_low_high(n),
       hn=match$0[2],
       ln=match$0[1],
       diff=(ln - lo | 0) + (hn - ho | 0) | 0;
      return diff & 65535}
    function enc_dec(pkmn,buf,offset,len)
     {var offset$0=offset;
      for(;;)
       {if((offset + len | 0) <= offset$0)return 0;
        var
         i=caml_call2(Stdlib_bytes[57],buf,offset$0),
         i$0=encrypt_aligned_int32(pkmn,i);
        caml_call3(Stdlib_bytes[71],buf,offset$0,i$0);
        var offset$1=offset$0 + 4 | 0,offset$0=offset$1;
        continue}}
    function extract_data(buf)
     {var
       pkmn=pkmn_from_bytes(buf),
       res=caml_call3(Stdlib_bytes[7],buf,data_offset,len);
      enc_dec(pkmn,res,0,len);
      return res}
    function update_with_data(buf,data)
     {var pkmn=pkmn_from_bytes(buf),acc=Stdlib_int32[1],i=0;
      for(;;)
       {if(48 <= i)
         {var low=acc & 65535,checksum=uint32_to_int(low);
          caml_call5(Stdlib_bytes[11],data,0,buf,data_offset,len);
          enc_dec(pkmn,buf,data_offset,len);
          return caml_call3(Stdlib_bytes[65],buf,checksum_offset,checksum)}
        var
         nb=caml_call2(Stdlib_bytes[51],data,i),
         i$0=i + 2 | 0,
         acc$0=acc + nb | 0,
         acc=acc$0,
         i=i$0;
        continue}}
    function species_offset(pkmn){return substructure_offset(pkmn,71)}
    function species_offset_relative_to_dat(pkmn)
     {return substructure_offset(pkmn,71) - 32 | 0}
    function ivea_offset(pkmn){return substructure_offset(pkmn,77) + 4 | 0}
    function ivea_data_to_ivs(data)
     {var
       hp=31 & data,
       data$0=data >>> 5 | 0,
       atk=31 & data$0,
       data$1=data$0 >>> 5 | 0,
       def=31 & data$1,
       data$2=data$1 >>> 5 | 0,
       speed=31 & data$2,
       data$3=data$2 >>> 5 | 0,
       sp_atk=31 & data$3,
       data$4=data$3 >>> 5 | 0,
       sp_def=31 & data$4,
       data$5=data$4 >>> 5 | 0;
      return [0,hp,atk,def,speed,sp_atk,sp_def,data$5]}
    function ivs_to_ivea_data(param)
     {var
       data=param[7],
       sp_def=param[6],
       sp_atk=param[5],
       speed=param[4],
       def=param[3],
       atk=param[2],
       hp=param[1],
       data$0=data << 5,
       data$1=data$0 | sp_def,
       data$2=data$1 << 5,
       data$3=data$2 | sp_atk,
       data$4=data$3 << 5,
       data$5=data$4 | speed,
       data$6=data$5 << 5,
       data$7=data$6 | def,
       data$8=data$7 << 5,
       data$9=data$8 | atk,
       data$10=data$9 << 5,
       data$11=data$10 | hp;
      return data$11}
    var
     Structure=
      [0,
       int32_from_low_high,
       int32_to_low_high,
       pkmn_from_bytes,
       substructure_position,
       substructure_offset,
       extract_data,
       update_with_data,
       encrypt_aligned_int32,
       encrypt_aligned_int32,
       checksum_diff_for_aligned_int3,
       species_offset,
       species_offset_relative_to_dat,
       ivea_offset,
       ivea_data_to_ivs,
       ivs_to_ivea_data];
    caml_register_global(472,Structure,"Structure");
    var lang=[0,0],tweaker_mode=[0,1];
    function configure(language)
     {tweaker_mode[1] = 1;
      return caml_string_notequal(language,cst_eng)
              ?caml_string_notequal(language,cst_fra)
                ?caml_string_notequal(language,cst_ger)
                  ?caml_string_notequal(language,cst_ita)
                    ?caml_string_notequal(language,cst_jap)
                      ?caml_string_notequal(language,cst_spa)
                        ?(lang[1] = 0,0)
                        :(lang[1] = 3,0)
                      :(lang[1] = 5,tweaker_mode[1] = 0,0)
                    :(lang[1] = 2,0)
                  :(lang[1] = 4,0)
                :(lang[1] = 1,0)
              :(lang[1] = 0,0)}
    var Settings=[0,lang,tweaker_mode,configure];
    caml_register_global(473,Settings,"Settings");
    function mult_mod(x,y,m)
     {var _mT_=caml_call2(Big_int[10],x,y);
      return caml_call2(Big_int[16],_mT_,m)}
    var
     _i_=Big_int[9],
     _k_=Big_int[11],
     _l_=Big_int[50],
     _m_=Big_int[53],
     _j_=Big_int[6],
     _n_=Big_int[54],
     two_big_int=caml_call1(Big_int[36],2);
    caml_call1(Big_int[36],3);
    caml_call1(Big_int[36],4);
    var
     a=caml_call1(Big_int[42],_o_),
     b=caml_call1(Big_int[42],_p_),
     a_inv=caml_call1(Big_int[42],_q_),
     b_inv=caml_call1(Big_int[42],_r_),
     m=caml_call1(Big_int[42],_s_),
     b_1=caml_call1(Big_int[42],_t_),
     _u_=caml_call2(_k_,4,m),
     cycle_part_product=mult_mod(caml_call1(_i_,a),b_1,_u_),
     mask32=caml_call1(Big_int[42],_v_);
    function even(n)
     {var _mS_=caml_call2(_l_,n,Big_int[2]);
      return caml_call2(Big_int[24],Big_int[1],_mS_)}
    function odd(n){return 1 - even(n)}
    function mpow(base,exp,n)
     {var base$0=base,exp$0=exp;
      for(;;)
       {var base$1=caml_call2(Big_int[16],base$0,n);
        if(caml_call2(Big_int[24],exp$0,Big_int[1]))return Big_int[2];
        if(caml_call2(Big_int[24],exp$0,Big_int[2]))return base$1;
        if(even(exp$0))
         {var
           exp$1=caml_call2(Big_int[15],exp$0,two_big_int),
           base$2=caml_call2(Big_int[10],base$1,base$1),
           base$0=base$2,
           exp$0=exp$1;
          continue}
        return mult_mod(base$1,mpow(base$1,caml_call1(_i_,exp$0),n),n)}}
    function pow(base,exp)
     {var base$0=base,exp$0=exp;
      for(;;)
       {if(caml_call2(Big_int[24],exp$0,Big_int[1]))return Big_int[2];
        if(caml_call2(Big_int[24],exp$0,Big_int[2]))return base$0;
        if(even(exp$0))
         {var
           exp$1=caml_call2(Big_int[15],exp$0,two_big_int),
           base$1=caml_call2(Big_int[10],base$0,base$0),
           base$0=base$1,
           exp$0=exp$1;
          continue}
        var _mR_=pow(base$0,caml_call1(_i_,exp$0));
        return caml_call2(Big_int[10],base$0,_mR_)}}
    caml_fresh_oo_id(0);
    function _x_(seed)
     {var _mQ_=caml_call2(Big_int[10],seed,a);
      return caml_call2(_l_,mask32,caml_call2(Big_int[5],b,_mQ_))}
    function _y_(seed)
     {var _mP_=caml_call2(Big_int[10],seed,a_inv);
      return caml_call2(_l_,mask32,caml_call2(Big_int[5],b_inv,_mP_))}
    function big_int_of_uint32(i32)
     {var _mO_=int64_of_uint32(i32);return caml_call1(Big_int[42],_mO_)}
    function uint32_of_bigint(bi)
     {var
       maxint32=caml_call1(Big_int[40],Stdlib_int32[9]),
       minint32=caml_call1(Big_int[40],Stdlib_int32[10]),
       _mN_=caml_call2(Big_int[8],maxint32,minint32),
       total=caml_call1(Big_int[6],_mN_),
       bi$0=
        caml_call2(Big_int[28],bi,maxint32)?caml_call2(Big_int[8],bi,total):bi;
      return caml_call1(Big_int[43],bi$0)}
    function rng_of(seed)
     {var _mM_=caml_call2(_n_,seed,16);return caml_call1(Big_int[38],_mM_)}
    var
     aPresses=[0,1,3,6],
     moreAPresses=[0,0,10,30],
     old_rod=0,
     good_rod=1,
     super_rod=2;
    function next_seed(seed)
     {return uint32_of_bigint(_x_(big_int_of_uint32(seed)))}
    function prev_seed(seed)
     {return uint32_of_bigint(_y_(big_int_of_uint32(seed)))}
    function cycle_to(seed)
     {var
       seed$0=big_int_of_uint32(seed),
       y=caml_call2(_k_,4,m),
       x=caml_call1(_j_,mult_mod(seed$0,cycle_part_product,y)),
       power=caml_call2(Big_int[26],x,y)?caml_call2(Big_int[8],x,y):x,
       m$0=pow(two_big_int,caml_call1(Big_int[36],34));
      if(odd(a) && odd(power))
       {var
         bitmask=caml_call1(_i_,pow(two_big_int,caml_call1(Big_int[36],31))),
         ls=runtime.caml_make_vect(32,power),
         i=1,
         l=power;
        for(;;)
         {if(i < 32)
           {var l$0=mult_mod(l,l,m$0);
            caml_check_bound(ls,i)[1 + i] = l$0;
            var i$0=i + 1 | 0,i=i$0,l=l$0;
            continue}
          var i$1=31,b=Big_int[1],bit=Big_int[2];
          for(;;)
           {if(0 <= i$1)
             {var
               _mK_=mpow(a,caml_call2(_l_,bitmask,caml_call2(_m_,b,i$1)),m$0),
               _mL_=caml_check_bound(ls,i$1)[1 + i$1],
               b$0=
                1 - caml_call2(Big_int[24],_mL_,_mK_)
                 ?caml_call2(Big_int[5],b,bit)
                 :b,
               bit$0=caml_call2(_m_,bit,1),
               i$2=i$1 - 1 | 0,
               i$1=i$2,
               b=b$0,
               bit=bit$0;
              continue}
            return uint32_of_bigint(b)}}}
      throw [0,Assert_failure,_w_]}
    function seed_at(cycle)
     {var
       cycle$0=big_int_of_uint32(cycle),
       _mI_=caml_call1(_i_,a),
       y=caml_call2(Big_int[10],_mI_,m),
       x=caml_call1(_i_,mpow(a,cycle$0,y)),
       op1=caml_call2(Big_int[26],x,Big_int[1])?x:caml_call2(Big_int[5],x,y),
       _mJ_=caml_call1(_i_,a),
       aux=caml_call2(Big_int[15],op1,_mJ_);
      return uint32_of_bigint(mult_mod(aux,b,m))}
    function best_seed_for_rod(route119,feebas,target_seed,rod)
     {var
       target_seed$0=big_int_of_uint32(target_seed),
       maxAdditionalOffsets=[0,0,1,4],
       bestResults=[0,0],
       starting_seed=[0,_y_(target_seed$0)],
       for$2=1;
      for(;;)
       {starting_seed[1] = _y_(starting_seed[1]);
        var _mH_=for$2 + 1 | 0;
        if(8 !== for$2){var for$2=_mH_;continue}
        var switch$0=0;
        if(route119 && ! feebas)
         {starting_seed[1] = _y_(starting_seed[1]);
          var offset119=1;
          switch$0 = 1}
        if(! switch$0)var offset119=0;
        var _mw_=caml_check_bound(maxAdditionalOffsets,rod)[1 + rod],_mv_=0;
        if(! (_mw_ < 0))
         {var additionalOffset=_mv_;
          a:
          for(;;)
           {var seed=[0,starting_seed[1]],for$1=1;
            for(;;)
             {seed[1] = _x_(seed[1]);
              var _mu_=for$1 + 1 | 0;
              if(7 !== for$1){var for$1=_mu_;continue}
              var
               _mp_=caml_check_bound(aPresses,rod)[1 + rod],
               minRounds=caml_mod(rng_of(seed[1]),_mp_) + 1 | 0;
              seed[1] = _x_(seed[1]);
              seed[1] = _x_(seed[1]);
              var
               biteRoll=rng_of(seed[1]) % 100 | 0,
               biteResult=0 === (biteRoll & 1)?0:14 < biteRoll?1:2,
               _mr_=minRounds - 1 | 0,
               _mq_=1;
              if(! (_mr_ < 1))
               {var for$0=_mq_;
                for(;;)
                 {seed[1] = _x_(seed[1]);
                  var _mt_=for$0 + 1 | 0;
                  if(_mr_ !== for$0){var for$0=_mt_;continue}
                  break}}
              var advancement=[0,7 + minRounds | 0];
              if(1 === minRounds)
               {seed[1] = _x_(seed[1]);
                advancement[1] = advancement[1] + 1 | 0;
                var biteRoll$0=rng_of(seed[1]) % 100 | 0;
                if(biteRoll$0 < caml_check_bound(moreAPresses,rod)[1 + rod])
                 {seed[1] = _x_(seed[1]);
                  advancement[1] = advancement[1] + 1 | 0}}
              seed[1] = _x_(seed[1]);
              var
               feebasResult=(rng_of(seed[1]) % 100 | 0) < 50?1:0,
               _ms_=route119?1 - feebas:route119;
              if(_ms_)advancement[1] = advancement[1] + 1 | 0;
              var advancement$0=advancement[1];
              starting_seed[1] = _y_(starting_seed[1]);
              var _my_=biteResult < 2?1:0;
              if(_my_)
               var
                _mz_=1 - feebas,
                _mA_=_mz_ || feebasResult,
                _mB_=
                 _mA_
                  ?((9 + additionalOffset | 0) + offset119 | 0)
                    ===
                    advancement$0
                    ?1
                    :0
                  :_mA_;
              else
               var _mB_=_my_;
              if(_mB_)
               {var _mC_=bestResults[1];
                if(_mC_)
                 {var
                   match=_mC_[1],
                   br=match[1],
                   s=match[3],
                   adv=match[2],
                   switch$1=0;
                  if(0 === br && 1 === biteResult)
                   {var _mD_=[0,[0,br,adv,s]];switch$1 = 1}
                  if(! switch$1)
                   {var s$0=match[3],adv$0=match[2],switch$2=0;
                    if(br === biteResult && adv$0 < advancement$0)
                     {var _mG_=[0,[0,br,adv$0,s$0]];switch$2 = 1}
                    if(! switch$2)
                     var
                      _mG_=
                       [0,[0,biteResult,advancement$0,_x_(starting_seed[1])]];
                    var _mD_=_mG_}
                  var _mE_=_mD_}
                else
                 var
                  _mE_=
                   [0,[0,biteResult,advancement$0,_x_(starting_seed[1])]];
                bestResults[1] = _mE_}
              var _mF_=additionalOffset + 1 | 0;
              if(_mw_ !== additionalOffset)
               {var additionalOffset=_mF_;continue a}
              break}
            break}}
        var _mx_=bestResults[1];
        if(_mx_)
         {var match$0=_mx_[1],s$1=match$0[3],i=match$0[2],b=match$0[1];
          return [0,[0,1 === b?1:0,i,uint32_of_bigint(s$1)]]}
        return 0}}
    var
     Seed=
      [0,
       prev_seed,
       next_seed,
       cycle_to,
       seed_at,
       old_rod,
       good_rod,
       super_rod,
       best_seed_for_rod];
    caml_register_global(475,Seed,"Seed");
    function main(fmt)
     {caml_call2(Stdlib_format[126],fmt,_z_);return [0,main_1]}
    function main_3(seed,fmt,str)
     {if(caml_string_notequal(str,cst_1$0))
       if(caml_string_notequal(str,cst_2$0))
        if(caml_string_notequal(str,cst_3$0))
         var
          _ml_=caml_call1(Stdlib[2],cst_Unknown_answer),
          feebas=_ml_[2],
          route119=_ml_[1];
        else
         var feebas=1,route119=1;
       else
        var feebas=0,route119=1;
      else
       var feebas=0,route119=0;
      var rod=old_rod;
      for(;;)
       {if(rod === 0)
         var rodname=cst_Old_rod;
        else
         {if(rod === 1)
           var _mo_=cst_Good_rod;
          else
           {if(rod !== 2)throw [0,Assert_failure,_ag_];var _mo_=cst_Super_rod}
          var rodname=_mo_}
        caml_call3(Stdlib_format[126],fmt,_aa_,rodname);
        var match=best_seed_for_rod(route119,feebas,seed,rod);
        if(match)
         {var _mm_=match[1];
          if(_mm_[1])
           {var seed$0=_mm_[3],adv=_mm_[2];
            caml_call2(Stdlib_format[126],fmt,_ab_);
            caml_call4(Stdlib_format[126],fmt,_ac_,seed$0,adv)}
          else
           {var seed$1=_mm_[3],adv$0=_mm_[2];
            caml_call2(Stdlib_format[126],fmt,_ad_);
            caml_call4(Stdlib_format[126],fmt,_ae_,seed$1,adv$0)}}
        else
         caml_call2(Stdlib_format[126],fmt,_af_);
        var _mn_=rod + 1 | 0;
        if(2 !== rod){var rod=_mn_;continue}
        caml_call2(Stdlib_format[126],fmt,_Z_);
        caml_call2(Stdlib_format[126],fmt,___);
        caml_call2(Stdlib_format[126],fmt,_$_);
        return 0}}
    function show_vicinity(fmt,print_cycle,seed,start,stop)
     {var cycle=cycle_to(seed);
      if(print_cycle)caml_call3(Stdlib_format[126],fmt,_H_,cycle);
      var start_seed=[0,seed_at(cycle + start | 0)];
      if(! (stop < start))
       {var i=start;
        for(;;)
         {caml_call5(Stdlib_format[126],fmt,_I_,i,start_seed[1],start_seed[1]);
          start_seed[1] = next_seed(start_seed[1]);
          var _mk_=i + 1 | 0;
          if(stop !== i){var i=_mk_;continue}
          break}}
      return 0}
    function main_vicinity(seed,fmt,str)
     {function _mj_(i,j){return [0,i,j]}
      var
       match=caml_call3(Stdlib_scanf[4],str,_Y_,_mj_),
       stop=match[2],
       start=match[1];
      show_vicinity(fmt,1,seed,start,stop);
      return 0}
    function main_2(seed,fmt,str)
     {if(caml_string_notequal(str,cst_1))
       {if(caml_string_notequal(str,cst_2))
         return caml_string_notequal(str,cst_3)
                 ?caml_string_notequal(str,cst_4)
                   ?caml_string_notequal(str,cst_5)
                     ?0
                     :(caml_call2(Stdlib_format[126],fmt,_J_),
                       [0,
                        function(_mf_,_mg_){return main_vicinity(seed,_mf_,_mg_)}])
                   :(caml_call2(Stdlib_format[126],fmt,_K_),
                     caml_call2(Stdlib_format[126],fmt,_L_),
                     caml_call2(Stdlib_format[126],fmt,_M_),
                     caml_call2(Stdlib_format[126],fmt,_N_),
                     show_vicinity(fmt,0,seed,-10,0),
                     0)
                 :(caml_call2(Stdlib_format[126],fmt,_O_),
                   caml_call2(Stdlib_format[126],fmt,_P_),
                   caml_call2(Stdlib_format[126],fmt,_Q_),
                   caml_call2(Stdlib_format[126],fmt,_R_),
                   [0,function(_mh_,_mi_){return main_3(seed,_mh_,_mi_)}]);
        var _md_=prev_seed(seed);
        caml_call3(Stdlib_format[126],fmt,_S_,_md_);
        caml_call2(Stdlib_format[126],fmt,_T_);
        caml_call2(Stdlib_format[126],fmt,_U_);
        return 0}
      var _me_=prev_seed(prev_seed(seed));
      caml_call3(Stdlib_format[126],fmt,_V_,_me_);
      caml_call2(Stdlib_format[126],fmt,_W_);
      caml_call2(Stdlib_format[126],fmt,_X_);
      return 0}
    function main_1(fmt,str)
     {var seed=uint32_of_str(str);
      caml_call2(Stdlib_format[126],fmt,_A_);
      caml_call2(Stdlib_format[126],fmt,_B_);
      caml_call2(Stdlib_format[126],fmt,_C_);
      caml_call2(Stdlib_format[126],fmt,_D_);
      caml_call2(Stdlib_format[126],fmt,_E_);
      caml_call2(Stdlib_format[126],fmt,_F_);
      caml_call2(Stdlib_format[126],fmt,_G_);
      return [0,function(_mb_,_mc_){return main_2(seed,_mb_,_mc_)}]}
    var
     Seed_tools_common=
      [0,main,main_1,show_vicinity,main_2,main_vicinity,main_3];
    caml_register_global(477,Seed_tools_common,"Seed_tools_common");
    var
     InvalidSave=[248,cst_Save_InvalidSave,caml_fresh_oo_id(0)],
     game_save_A=0,
     game_save_B=57344,
     section_size=4096,
     section_id_offset=4084,
     checksum_offset$0=4086,
     save_index_offset=4092,
     box_names_section_id=13,
     box_names_section_data_length=2000,
     box_names_offset=1860,
     box_names_length=126,
     team_items_section_id=1,
     team_items_section_data_length=3968,
     team_size_offset=564,
     pkmn_data_size=100;
    function read_section(inc,section_id)
     {var rbuf=caml_create_bytes(4096);
      function aux(base,i)
       {var i$0=i;
        for(;;)
         {if(14 <= i$0)throw InvalidSave;
          var addr=base + (i$0 * 4096 | 0) | 0;
          caml_call2(Stdlib[90],inc,addr);
          caml_call4(Stdlib[85],inc,rbuf,0,section_size);
          var
           id=caml_call2(Stdlib_bytes[51],rbuf,section_id_offset),
           index=caml_call2(Stdlib_bytes[57],rbuf,save_index_offset);
          if(id === section_id)return [0,addr,index];
          var i$1=i$0 + 1 | 0,i$0=i$1;
          continue}}
      var
       match=aux(game_save_A,0),
       indexa=match[2],
       addra=match[1],
       match$0=aux(game_save_B,0),
       indexb=match$0[2],
       addrb=match$0[1],
       addr=0 <= caml_call2(Stdlib_int32[16],indexa,indexb)?addra:addrb,
       res=caml_create_bytes(4096);
      caml_call2(Stdlib[90],inc,addr);
      caml_call4(Stdlib[85],inc,res,0,section_size);
      return [0,addr,res]}
    function write_section(oc,addr,buf)
     {caml_call2(Stdlib[73],oc,addr);
      caml_call2(Stdlib[67],oc,buf);
      return caml_call1(Stdlib[63],oc)}
    function compute_checksum(buf,start,len)
     {var acc=Stdlib_int32[1],i=start;
      for(;;)
       {if((start + len | 0) <= i)
         {var high=acc >>> 16 | 0,low=acc & 65535,res=high + low | 0;
          return uint32_to_int(res & 65535)}
        var
         nb=caml_call2(Stdlib_bytes[57],buf,i),
         i$0=i + 4 | 0,
         acc$0=acc + nb | 0,
         acc=acc$0,
         i=i$0;
        continue}}
    function extract_box_names_from_section(buf)
     {return caml_call3(Stdlib_bytes[7],buf,box_names_offset,box_names_length)}
    function update_box_names(buf,box_names)
     {var len=runtime.caml_ml_bytes_length(box_names);
      caml_call5(Stdlib_bytes[11],box_names,0,buf,box_names_offset,len);
      var checksum=compute_checksum(buf,0,box_names_section_data_length);
      return caml_call3(Stdlib_bytes[65],buf,checksum_offset$0,checksum)}
    function empty_pkmn(param){return caml_create_bytes(100)}
    function extract_team_from_section(buf)
     {var acc=0,i=5;
      for(;;)
       {if(0 <= i)
         {var
           addr=568 + (100 * i | 0) | 0,
           pkmn=caml_call3(Stdlib_bytes[7],buf,addr,pkmn_data_size),
           i$0=i - 1 | 0,
           acc$0=[0,pkmn,acc],
           acc=acc$0,
           i=i$0;
          continue}
        return acc}}
    function update_team(buf,pkmns)
     {var len=caml_call1(Stdlib_list[1],pkmns);
      caml_call3(Stdlib_bytes[71],buf,team_size_offset,len);
      function update_pkmn(i,pkmn)
       {var addr=568 + (100 * i | 0) | 0;
        return caml_call5(Stdlib_bytes[11],pkmn,0,buf,addr,pkmn_data_size)}
      caml_call2(Stdlib_list[18],update_pkmn,pkmns);
      var checksum=compute_checksum(buf,0,team_items_section_data_length);
      return caml_call3(Stdlib_bytes[65],buf,checksum_offset$0,checksum)}
    var
     Save=
      [0,
       InvalidSave,
       box_names_section_id,
       team_items_section_id,
       extract_box_names_from_section,
       update_box_names,
       empty_pkmn,
       extract_team_from_section,
       update_team,
       write_section,
       read_section];
    caml_register_global(478,Save,"Save");
    var
     StrMap=caml_call1(Stdlib_map[1],[0,Stdlib_string[5]]),
     VarNotFound=[248,cst_Preprocess_VarNotFound,caml_fresh_oo_id(0)];
    function get_param(lst,name)
     {var lst$0=lst;
      for(;;)
       {if(lst$0)
         {var _ma_=lst$0[1];
          if(0 === _ma_[0])
           {var n=_ma_[1],v=_ma_[2];
            if(caml_call2(Stdlib_string[4],n,name))return v;
            var lst$1=lst$0[2],lst$0=lst$1;
            continue}
          var lst$2=lst$0[2],lst$0=lst$2;
          continue}
        return 0}}
    function eval_meta_expr(env,e)
     {function aux(e)
       {var e$0=e;
        for(;;)
         switch(e$0[0])
          {case 0:var i=e$0[1];return i;
           case 1:
            var e2=e$0[3],e1=e$0[2],op=e$0[1],i1=aux(e1),i2=aux(e2);
            switch(op)
             {case 0:return i1 + i2 | 0;
              case 1:return i1 - i2 | 0;
              case 2:return runtime.caml_mul(i1,i2);
              case 3:return caml_call2(Stdlib_int32[4],i1,i2);
              case 4:return caml_call2(Stdlib_int32[5],i1,i2);
              case 5:return i1 & i2;
              case 6:return i1 ^ i2;
              case 7:return i1 | i2;
              case 8:return i1 << uint32_to_int(i2);
              case 9:return i1 >>> uint32_to_int(i2) | 0;
              case 10:
               return caml_call2(Stdlib_int32[17],i1,i2)
                       ?Stdlib_int32[2]
                       :Stdlib_int32[1];
              case 11:
               return caml_call2(Stdlib_int32[17],i1,i2)
                       ?Stdlib_int32[1]
                       :Stdlib_int32[2];
              case 12:
               if
                (caml_call2(Stdlib_int32[17],i1,Stdlib_int32[1])
                 &&
                 caml_call2(Stdlib_int32[17],i2,Stdlib_int32[1]))
                return Stdlib_int32[1];
               return Stdlib_int32[2];
              default:
               if
                (!
                 caml_call2(Stdlib_int32[17],i1,Stdlib_int32[1])
                 &&
                 !
                 caml_call2(Stdlib_int32[17],i2,Stdlib_int32[1]))
                return Stdlib_int32[2];
               return Stdlib_int32[1]}
           case 2:
            var e$1=e$0[2],op$0=e$0[1],i$0=aux(e$1);
            switch(op$0)
             {case 0:return i$0;
              case 1:return - i$0 | 0;
              case 2:return caml_call1(Stdlib_int32[11],i$0);
              default:
               return caml_call2(Stdlib_int32[17],i$0,Stdlib_int32[1])
                       ?Stdlib_int32[2]
                       :Stdlib_int32[1]}
           case 3:
            var str=e$0[1];
            if(caml_call2(StrMap[3],str,env))
             return caml_call2(StrMap[28],str,env);
            throw [0,VarNotFound,str];
           default:
            var e2$0=e$0[3],e1$0=e$0[2],e0=e$0[1],i0=aux(e0);
            if(caml_call2(Stdlib_int32[17],i0,Stdlib_int32[1]))
             {var e$0=e2$0;continue}
            var e$0=e1$0;
            continue}}
      return aux(e)}
    var empty_env=StrMap[1];
    function env_from_headers(fmt,headers)
     {function treat_def(param,def)
       {var acc=param[2],printed=param[1];
        if(0 === def[0])return [0,printed,acc];
        var expr=def[3],print=def[2],str=def[1],i=eval_meta_expr(acc,expr);
        if(print)caml_call5(Stdlib_format[126],fmt,_ah_,str,i,i);
        var _l$_=caml_call3(StrMap[4],str,i,acc),printed$0=printed || print;
        return [0,printed$0,_l$_]}
      var
       match=caml_call3(Stdlib_list[25],treat_def,[0,0,StrMap[1]],headers),
       res=match[2],
       printed=match[1];
      if(printed)caml_call2(Stdlib_format[126],fmt,_ai_);
      return res}
    function concat_env(env1,env2)
     {function _l__(k,v,acc){return caml_call3(StrMap[4],k,v,acc)}
      return caml_call3(StrMap[13],_l__,env2,env1)}
    var
     Preprocess=
      [0,
       VarNotFound,
       get_param,
       eval_meta_expr,
       empty_env,
       env_from_headers,
       concat_env];
    caml_register_global(480,Preprocess,"Preprocess");
    function main$0(fmt)
     {caml_call2(Stdlib_format[126],fmt,_aj_);return [0,main_1$0]}
    function main_6(pkmn,livea,fmt,str)
     {function _l9_(i){return i}
      var
       hivea=caml_call3(Stdlib_scanf[4],str,_aw_,_l9_),
       ivea=int32_from_low_high(livea,hivea),
       uivea=encrypt_aligned_int32(pkmn,ivea);
      caml_call3(Stdlib_format[126],fmt,_ax_,uivea);
      var
       match=ivea_data_to_ivs(uivea),
       data=match[7],
       sp_def=match[6],
       sp_atk=match[5],
       speed=match[4],
       def=match[3],
       atk=match[2],
       hp=match[1];
      caml_call8(Stdlib_format[126],fmt,_ay_,hp,atk,def,speed,sp_atk,sp_def);
      caml_call2(Stdlib_format[126],fmt,_az_);
      var uivea$0=ivs_to_ivea_data([0,31,31,31,31,31,31,data]);
      caml_call3(Stdlib_format[126],fmt,_aA_,uivea$0);
      var
       ivea$0=encrypt_aligned_int32(pkmn,uivea$0),
       match$0=int32_to_low_high(ivea$0),
       hivea$0=match$0[2],
       livea$0=match$0[1];
      caml_call3(Stdlib_format[126],fmt,_aB_,livea$0);
      caml_call3(Stdlib_format[126],fmt,_aC_,hivea$0);
      var checksum_diff=checksum_diff_for_aligned_int3(uivea,uivea$0);
      caml_call3(Stdlib_format[126],fmt,_aD_,checksum_diff);
      return 0}
    function main_5(pkmn,fmt,str)
     {function _l6_(i){return i}
      var livea=caml_call3(Stdlib_scanf[4],str,_au_,_l6_);
      caml_call2(Stdlib_format[126],fmt,_av_);
      return [0,function(_l7_,_l8_){return main_6(pkmn,livea,_l7_,_l8_)}]}
    function main_4(pid,vid,fmt,str)
     {function _l3_(i){return i}
      var
       sid=caml_call3(Stdlib_scanf[4],str,_aq_,_l3_),
       tid=int32_from_low_high(vid,sid),
       pkmn=[0,pid,tid],
       misc_pos=substructure_position(pkmn,77),
       ivea_offset$0=ivea_offset(pkmn);
      caml_call3(Stdlib_format[126],fmt,_ar_,misc_pos + 1 | 0);
      caml_call3(Stdlib_format[126],fmt,_as_,ivea_offset$0);
      caml_call2(Stdlib_format[126],fmt,_at_);
      return [0,function(_l4_,_l5_){return main_5(pkmn,_l4_,_l5_)}]}
    function main_3$0(pid,fmt,str)
     {function _l0_(i){return i}
      var vid=caml_call3(Stdlib_scanf[4],str,_ao_,_l0_);
      caml_call2(Stdlib_format[126],fmt,_ap_);
      return [0,function(_l1_,_l2_){return main_4(pid,vid,_l1_,_l2_)}]}
    function main_2$0(lpid,fmt,str)
     {function _lX_(i){return i}
      var
       hpid=caml_call3(Stdlib_scanf[4],str,_am_,_lX_),
       pid=int32_from_low_high(lpid,hpid);
      caml_call2(Stdlib_format[126],fmt,_an_);
      return [0,function(_lY_,_lZ_){return main_3$0(pid,_lY_,_lZ_)}]}
    function main_1$0(fmt,str)
     {function _lU_(i){return i}
      var lpid=caml_call3(Stdlib_scanf[4],str,_ak_,_lU_);
      caml_call2(Stdlib_format[126],fmt,_al_);
      return [0,function(_lV_,_lW_){return main_2$0(lpid,_lV_,_lW_)}]}
    var
     Pkmn_data_common=
      [0,main$0,main_1$0,main_2$0,main_3$0,main_4,main_5,main_6];
    caml_register_global(481,Pkmn_data_common,"Pkmn_data_common");
    var
     InvalidCommand=[248,cst_Arm_InvalidCommand,caml_fresh_oo_id(0)],
     a1=0,
     a2=1,
     a3=2,
     a4=3,
     v1=4,
     v2=5,
     v3=6,
     v4=7,
     v5=8,
     v6=9,
     v7=10,
     v8=11,
     sb=9,
     sl=10,
     fp=11,
     ip=12,
     sp=13,
     lr=14,
     pc=15,
     sign_plus=1,
     sign_minus=0,
     mask8=255,
     mask9=511,
     mask12=4095;
    function add_condition_code(c,v)
     {switch(c)
       {case 0:var _lT_=0;break;
        case 1:var _lT_=1;break;
        case 6:var _lT_=4;break;
        case 7:var _lT_=5;break;
        case 8:var _lT_=6;break;
        case 9:var _lT_=7;break;
        case 10:var _lT_=8;break;
        case 11:var _lT_=9;break;
        case 12:var _lT_=10;break;
        case 13:var _lT_=11;break;
        case 14:var _lT_=12;break;
        case 15:var _lT_=13;break;
        case 16:var _lT_=14;break;
        case 2:
        case 3:var _lT_=2;break;
        default:var _lT_=3}
      return v | _lT_ << 28}
    function add_rn_code(rn,v){return v | rn << 16}
    function add_rd_code(rd,v){return v | rd << 12}
    function rotate_right(v)
     {var lb=v & 1,v$0=v >>> 1 | 0;return v$0 | lb << 31}
    function rotate_left(v)
     {var hb=v & -2147483648,v$0=v << 1;return v$0 | hb >>> 31 | 0}
    function addr_mode_1(rs)
     {switch(rs[0])
       {case 0:
         var
          i=rs[1],
          aux=
           function(n,imm)
            {if(15 < n)return 0;
             var
              others=aux(n + 1 | 0,rotate_left(rotate_left(imm))),
              imm8=imm & 255;
             return caml_call2(Stdlib_int32[17],imm8,imm)
                     ?[0,[0,n,imm8],others]
                     :others},
          res=aux(0,i);
         if(0 === res)throw InvalidCommand;
         var
          _lR_=
           function(param)
            {var imm8=param[2],rr=param[1];return [0,1,imm8 | rr << 8]},
          possibilities=caml_call2(Stdlib_list[19],_lR_,res);
         break;
        case 1:var rm=rs[1],possibilities=[0,[0,0,rm],0];break;
        default:var possibilities=caml_call1(Stdlib[2],cst_Not_implemented)}
      function _lS_(param)
       {var v=param[2],imm=param[1],i=imm << 25;return v | i}
      return caml_call2(Stdlib_list[19],_lS_,possibilities)}
    function p_and_w(addr_typ)
     {switch(addr_typ)
       {case 0:return _aE_;case 1:return _aF_;default:return _aG_}}
    function arm_to_binary(arm)
     {switch(arm[0])
       {case 0:var i$3=arm[1];return [0,i$3,0];
        case 1:
         var
          ro=arm[5],
          rd=arm[4],
          cond=arm[3],
          typ=arm[2],
          instr=arm[1],
          addr_typ=ro[2],
          rn=ro[1],
          check_post_addr=
           function(param){if(2 <= addr_typ)return 0;throw InvalidCommand};
         if(instr)
          switch(typ)
           {case 0:var opcode=71303168;break;
            case 1:throw InvalidCommand;
            case 2:var opcode=176;break;
            case 3:throw InvalidCommand;
            case 4:var opcode=67108864;break;
            case 5:check_post_addr(0);var opcode=69206016;break;
            default:check_post_addr(0);var opcode=73400320}
         else
          switch(typ)
           {case 0:var opcode=72351744;break;
            case 1:var opcode=1048784;break;
            case 2:var opcode=1048752;break;
            case 3:var opcode=1048816;break;
            case 4:var opcode=68157440;break;
            case 5:check_post_addr(0);var opcode=70254592;break;
            default:check_post_addr(0);var opcode=74448896}
         var
          _lM_=add_condition_code(cond,opcode),
          v$3=add_rd_code(rd,add_rn_code(rn[1],_lM_)),
          switcher=typ - 1 | 0;
         if(2 < switcher >>> 0)
          {switch(rn[0])
            {case 0:
              var v=rn[3],sign=rn[2];
              if(0 < caml_call2(Stdlib_int32[16],v,mask12))
               throw InvalidCommand;
              var v$0=v,reg=0,sign$0=sign;
              break;
             case 1:
              var rm=rn[3],sign$1=rn[2],v$0=rm,reg=1,sign$0=sign$1;break;
             default:
              var
               _lL_=caml_call1(Stdlib[2],cst_Not_implemented$0),
               v$0=_lL_[3],
               reg=_lL_[2],
               sign$0=_lL_[1]}
           var
            match=p_and_w(addr_typ),
            w=match[2],
            p=match[1],
            i=reg << 25,
            u=sign$0 << 23,
            p$0=p << 24,
            w$0=w << 21,
            addr_mode=i | w$0 | p$0 | v$0 | u}
         else
          {switch(rn[0])
            {case 0:
              var v$1=rn[3],sign$2=rn[2];
              if(0 < caml_call2(Stdlib_int32[16],v$1,mask8))
               throw InvalidCommand;
              var
               immedL=15 & v$1,
               immedH=15 & (v$1 >>> 4 | 0),
               v$2=immedL | immedH << 8,
               imm=1,
               sign$3=sign$2;
              break;
             case 1:
              var rm$0=rn[3],sign$4=rn[2],v$2=rm$0,imm=0,sign$3=sign$4;break;
             default:throw InvalidCommand}
           var
            match$0=p_and_w(addr_typ),
            w$1=match$0[2],
            p$1=match$0[1],
            i$0=imm << 22,
            u$0=sign$3 << 23,
            p$2=p$1 << 24,
            w$2=w$1 << 21,
            addr_mode=i$0 | w$2 | p$2 | v$2 | u$0}
         return [0,v$3 | addr_mode,0];
        case 2:
         var
          rs=arm[5],
          rd$0=arm[4],
          cond$0=arm[3],
          s=arm[2],
          instr$0=arm[1],
          opcode$0=instr$0?31457280:27262976,
          scode=s?1:0,
          scode$0=scode << 20,
          v$4=scode$0 | add_rd_code(rd$0,add_condition_code(cond$0,opcode$0)),
          _lN_=addr_mode_1(rs),
          _lO_=function(addr_mode){return v$4 | addr_mode};
         return caml_call2(Stdlib_list[19],_lO_,_lN_);
        case 3:
         var
          op2=arm[6],
          rn$0=arm[5],
          rd$1=arm[4],
          cond$1=arm[3],
          s$0=arm[2],
          instr$1=arm[1];
         switch(instr$1)
          {case 0:var opcode$1=10485760;break;
           case 1:var opcode$1=12582912;break;
           case 2:var opcode$1=29360128;break;
           case 3:var opcode$1=0;break;
           case 4:var opcode$1=8388608;break;
           case 5:var opcode$1=4194304;break;
           case 6:var opcode$1=25165824;break;
           default:var opcode$1=2097152}
         var
          scode$1=s$0?1:0,
          scode$2=scode$1 << 20,
          v$5=
           scode$2
           |
           add_rn_code
            (rn$0,add_rd_code(rd$1,add_condition_code(cond$1,opcode$1))),
          _lP_=addr_mode_1(op2),
          _lQ_=function(addr_mode){return v$5 | addr_mode};
         return caml_call2(Stdlib_list[19],_lQ_,_lP_);
        case 4:
         var
          target=arm[3],
          cond$2=arm[2],
          l=arm[1],
          opcode$2=l?184549376:167772160,
          v$6=add_condition_code(cond$2,opcode$2),
          i$2=target - 8 | 0;
         if(caml_call2(Stdlib_int32[17],i$2 & 3,Stdlib_int32[1]))
          {var i$1=i$2 >> 2,ms9=i$1 >>> 23 | 0;
           if
            (!
             caml_call2(Stdlib_int32[17],ms9,mask9)
             &&
             !
             caml_call2(Stdlib_int32[17],ms9,Stdlib_int32[1]))
            throw InvalidCommand;
           var imm$0=i$1 & 16777215;
           return [0,v$6 | imm$0,0]}
         throw InvalidCommand;
        default:
         var
          rm$1=arm[3],
          cond$3=arm[2],
          l$0=arm[1],
          opcode$3=l$0?19922736:19922704,
          v$7=add_condition_code(cond$3,opcode$3);
         return [0,v$7 | rm$1,0]}}
    function reverse_endianness(v)
     {var
       v1=(255 & v) << 24,
       v$0=v >>> 8 | 0,
       v2=(255 & v$0) << 16,
       v$1=v$0 >>> 8 | 0,
       v3=(255 & v$1) << 8,
       v$2=v$1 >>> 8 | 0,
       v4=255 & v$2;
      return v4 | v3 | v1 | v2}
    var
     Arm=
      [0,
       InvalidCommand,
       sign_plus,
       sign_minus,
       a1,
       a2,
       a3,
       a4,
       v1,
       v2,
       v3,
       v4,
       v5,
       v6,
       v7,
       v8,
       sb,
       sl,
       fp,
       ip,
       sp,
       lr,
       pc,
       arm_to_binary,
       reverse_endianness,
       rotate_right,
       rotate_left];
    caml_register_global(482,Arm,"Arm");
    var
     charset_eng=_aH_.slice(),
     charset_ita=caml_call1(Stdlib_array[8],charset_eng),
     charset_spa=caml_call1(Stdlib_array[8],charset_eng),
     cs=caml_call1(Stdlib_array[8],charset_eng);
    caml_check_bound(cs,177)[178] = _aI_;
    caml_check_bound(cs,178)[179] = _aJ_;
    var i$4=241;
    for(;;)
     {var match$0=caml_check_bound(cs,i$4)[1 + i$4];
      if(typeof match$0 !== "number" && 1 === match$0[0])
       {var c=match$0[1];
        caml_check_bound(cs,i$4)[1 + i$4] = [2,c];
        var _dX_=i$4 + 1 | 0;
        if(246 !== i$4){var i$4=_dX_;continue}
        var charset_fra=caml_call1(Stdlib_array[8],charset_eng);
        caml_check_bound(charset_fra,177)[178] = _aK_;
        caml_check_bound(charset_fra,178)[179] = _aL_;
        var
         charset_jap=_aM_.slice(),
         charset=
          function(param)
           {switch(lang[1])
             {case 0:return charset_eng;
              case 1:return charset_fra;
              case 2:return charset_ita;
              case 3:return charset_spa;
              case 4:return cs;
              default:return charset_jap}},
         is_code_available=
          function(code)
           {var match=caml_check_bound(charset(0),code)[1 + code];
            if(typeof match !== "number" && 2 === match[0])return 1;
            return 0},
         is_code_readable=
          function(code)
           {var match=caml_check_bound(charset(0),code)[1 + code];
            if(typeof match !== "number" && 0 !== match[0])return 1;
            return 0},
         is_code_used=
          function(code)
           {var match=caml_check_bound(charset(0),code)[1 + code];
            return typeof match === "number"?0:1},
         char_at=
          function(code)
           {var match=caml_check_bound(charset(0),code)[1 + code];
            if(typeof match === "number")return invalid_char;
            var str=match[1];
            return str},
         readable_char_at=
          function(code)
           {var match=caml_check_bound(charset(0),code)[1 + code];
            if(typeof match !== "number" && 0 !== match[0])
             {var str=match[1];return str}
            return invalid_char},
         writable_char_at=
          function(code)
           {var match=caml_check_bound(charset(0),code)[1 + code];
            if(typeof match !== "number" && 2 === match[0])
             {var str=match[1];return str}
            return invalid_char},
         acc=0,
         i=255;
        for(;;)
         {if(0 <= i)
           {var match=caml_check_bound(charset(0),i)[1 + i];
            if(typeof match !== "number" && 2 === match[0])
             {var
               str=match[1],
               i$1=i - 1 | 0,
               acc$0=[0,str,acc],
               acc=acc$0,
               i=i$1;
              continue}
            var i$0=i - 1 | 0,i=i$0;
            continue}
          var
           encode_writable_char=
            function(str)
             {var i=255;
              for(;;)
               {if(0 <= i)
                 {var match=caml_check_bound(charset(0),i)[1 + i];
                  if(typeof match !== "number" && 2 === match[0])
                   {var str$0=match[1];
                    if(caml_call2(Stdlib_string[4],str,str$0))return i}
                  var i$0=i - 1 | 0,i=i$0;
                  continue}
                throw Stdlib[8]}},
           Charset=
            [0,
             is_code_available,
             is_code_readable,
             is_code_used,
             spacing_char,
             invalid_char,
             char_at,
             readable_char_at,
             writable_char_at,
             acc,
             encode_writable_char];
          caml_register_global(483,Charset,"Charset");
          var
           eof=255,
           space=0,
           codes_for_command=
            function(v)
             {var
               v1=255 & v,
               v$0=v >>> 8 | 0,
               v2=255 & v$0,
               v$1=v$0 >>> 8 | 0,
               v3=255 & v$1,
               v$2=v$1 >>> 8 | 0,
               v4=255 & v$2,
               _lI_=[0,uint32_to_int(v4),0],
               _lJ_=[0,uint32_to_int(v3),_lI_],
               _lK_=[0,uint32_to_int(v2),_lJ_];
              return [0,uint32_to_int(v1),_lK_]},
           command_for_codes=
            function(codes)
             {if(codes)
               {var _lF_=codes[2];
                if(_lF_)
                 {var _lG_=_lF_[2];
                  if(_lG_)
                   {var _lH_=_lG_[2];
                    if(_lH_ && ! _lH_[2])
                     {var
                       c4=_lH_[1],
                       c3=_lG_[1],
                       c2=_lF_[1],
                       c1=codes[1],
                       v=c4 << 8,
                       v$0=v | c3,
                       v$1=v$0 << 8,
                       v$2=v$1 | c2,
                       v$3=v$2 << 8;
                      return v$3 | c1}}}}
              throw [0,Assert_failure,_aN_]},
           codes_to_chars=
            function(c){return caml_call2(Stdlib_list[19],writable_char_at,c)},
           chars_for_command=
            function(v){return codes_to_chars(codes_for_command(v))},
           pp_chars=
            function(fmt,lst)
             {function _lD_(i,str)
               {var _lE_=0 === i?cst:cst$0;
                return caml_call4(Stdlib_format[126],fmt,_aO_,_lE_,str)}
              return caml_call2(Stdlib_list[18],_lD_,lst)},
           pp_chars_raw=
            function(fmt,lst)
             {function _lC_(str)
               {var str$0=caml_string_equal(str,spacing_char)?cst$1:str;
                return caml_call3(Stdlib_format[126],fmt,_aP_,str$0)}
              return caml_call2(Stdlib_list[17],_lC_,lst)},
           is_code_writable=
            function(codes)
             {return caml_call2(Stdlib_list[32],is_code_available,codes)},
           first_code=
            function(f,codes)
             {var codes$0=codes;
              for(;;)
               {if(codes$0)
                 {var codes$1=codes$0[2],code=codes$0[1];
                  if(caml_call1(f,code))return code;
                  var codes$0=codes$1;
                  continue}
                throw Stdlib[8]}},
           first_writable_code=
            function(codes){return first_code(is_code_writable,codes)},
           is_code_writable_or_one_eof=
            function(code)
             {function _lx_(c){return c !== 255?1:0}
              var
               _ly_=
                is_code_writable(caml_call2(Stdlib_list[41],_lx_,code));
              if(_ly_)
               var
                _lz_=0,
                _lA_=function(nb,c){return c === 255?nb + 1 | 0:nb},
                _lB_=caml_call3(Stdlib_list[25],_lA_,_lz_,code) <= 1?1:0;
              else
               var _lB_=_ly_;
              return _lB_},
           preferred_code=
            function(codes)
             {try
               {var _lu_=first_writable_code(codes);return _lu_}
              catch(_lv_)
               {_lv_ = caml_wrap_exception(_lv_);
                if(_lv_ === Stdlib[8])
                 try
                  {var _lt_=first_code(is_code_writable_or_one_eof,codes);
                   return _lt_}
                 catch(_lw_)
                  {_lw_ = caml_wrap_exception(_lw_);
                   if(_lw_ === Stdlib[8])
                    return caml_call1(Stdlib_list[5],codes);
                   throw _lw_}
                throw _lv_}},
           is_full_of_spaces=
            function(codes)
             {function _ls_(c){return c === 0?1:0}
              return caml_call2(Stdlib_list[32],_ls_,codes)},
           Name=
            [0,
             eof,
             space,
             codes_for_command,
             command_for_codes,
             chars_for_command,
             codes_to_chars,
             pp_chars,
             pp_chars_raw,
             is_code_writable,
             first_writable_code,
             preferred_code,
             is_full_of_spaces];
          caml_register_global(484,Name,"Name");
          var
           CannotOptimize=
            [248,cst_Optimizer_CannotOptimize,caml_fresh_oo_id(0)],
           compare=Stdlib_int32[16],
           UInt32=[0,compare],
           UInt32Set=caml_call1(Stdlib_set[1],UInt32),
           padding_code=[0,Stdlib_int32[1]],
           acc$1=0,
           i$2=Stdlib_int32[1],
           max=255;
          for(;;)
           {if(caml_call2(Stdlib_int32[17],i$2,max))
             {var
               immed8=[0,i$2,acc$1],
               _aQ_=
                function(i){return is_code_writable([0,uint32_to_int(i),0])},
               immed8$0=caml_call2(Stdlib_list[41],_aQ_,immed8),
               _aR_=
                function(i$1)
                 {var acc$1=[0,i$1,0],acc=acc$1,i=i$1;
                  for(;;)
                   {var i$0=rotate_right(rotate_right(i));
                    if(caml_call2(Stdlib_int32[17],i$0,i$1))return acc;
                    var acc$0=[0,i$0,acc],acc=acc$0,i=i$0;
                    continue}},
               _aS_=caml_call2(Stdlib_list[19],_aR_,immed8$0),
               _aT_=caml_call1(Stdlib_list[14],_aS_),
               constants_set=caml_call1(UInt32Set[37],_aT_),
               _aU_=
                function(i)
                 {return 1
                         -
                         (caml_call2(Stdlib_int32[15],i,Stdlib_int32[1]) < 0?1:0)},
               constants_set_no_carry=
                caml_call2(UInt32Set[19],_aU_,constants_set),
               constants=caml_call1(UInt32Set[23],constants_set),
               rev_constants=caml_call1(Stdlib_list[9],constants),
               nset=caml_call2(UInt32Set[15],Stdlib_int32[11],constants_set),
               _aV_=caml_call2(UInt32Set[7],constants_set_no_carry,nset),
               _aW_=caml_call2(UInt32Set[6],Stdlib_int32[1],_aV_),
               constants_mov_mvn=caml_call1(UInt32Set[23],_aW_),
               nset$0=caml_call2(UInt32Set[15],Stdlib_int32[11],constants_set),
               _aX_=caml_call2(UInt32Set[7],constants_set,nset$0),
               constants_mov_mvn_strict=caml_call1(UInt32Set[23],_aX_),
               rev_constants_mov_mvn=
                caml_call1(Stdlib_list[9],constants_mov_mvn),
               rev_constants_mov_mvn_strict=
                caml_call1(Stdlib_list[9],constants_mov_mvn_strict),
               tad0=_aY_.slice(),
               remove_while=
                function(f,lst)
                 {var lst$0=lst;
                  for(;;)
                   {if(lst$0)
                     {var lst$1=lst$0[2],i=lst$0[1];
                      if(caml_call1(f,i)){var lst$0=lst$1;continue}
                      return lst$0}
                    return 0}},
               synthesis=
                function
                 (constants_cat,
                  additive,
                  incr,
                  max_card,
                  i,
                  is_valid_fst,
                  is_valid)
                 {var tad0_len=tad0.length - 1;
                  if(tad0_len < max_card)
                   var
                    _lh_=tad0_len - 1 | 0,
                    tad0$0=caml_check_bound(tad0,_lh_)[1 + _lh_];
                  else
                   var
                    _lj_=max_card - 1 | 0,
                    tad0$0=caml_check_bound(tad0,_lj_)[1 + _lj_];
                  function remove(i)
                   {function _lq_(j)
                     {return caml_call2(Stdlib_int32[16],i,j) < 0?1:0}
                    return function(_lr_){return remove_while(_lq_,_lr_)}}
                  function next(acc,rc,i)
                   {var rc$0=rc;
                    for(;;)
                     {if(caml_call2(Stdlib_int32[17],i,Stdlib_int32[1]))
                       return [0,acc];
                      var depth=caml_call1(Stdlib_list[1],acc);
                      if(max_card <= depth)return 0;
                      var
                       rem_depth=caml_int64_of_int32(max_card - depth | 0),
                       i64=int64_of_uint32(i),
                       ii=incr?caml_call1(Stdlib_int32[7],i):i,
                       match=caml_call1(remove(ii),rc$0);
                      if(match)
                       {var
                         fst=match[1],
                         _lo_=incr?caml_call1(Stdlib_int32[6],fst):fst,
                         _lp_=runtime.caml_int64_mul(int64_of_uint32(_lo_),rem_depth);
                        if(0 <= caml_call2(Stdlib_int64[16],_lp_,i64))
                         {var
                           rc$1=match[2],
                           remainder=ii - fst | 0,
                           match$0=next([0,fst,acc],[0,fst,rc$1],remainder);
                          if(match$0){var res=match$0[1];return [0,res]}
                          var rc$0=rc$1;
                          continue}
                        return 0}
                      return 0}}
                  var
                   filtered_rev_constants=
                    caml_call2(Stdlib_list[41],is_valid,rev_constants),
                   remove_init=
                    additive
                     ?remove
                     :function(i)
                       {function _lm_(j)
                         {return 0 < caml_call2(Stdlib_int32[16],i,j)?1:0}
                        return function(_ln_){return remove_while(_lm_,_ln_)}},
                   op_init=
                    additive
                     ?function(_ll_,_lk_){return _ll_ - _lk_ | 0}
                     :function(x,y){return y - x | 0};
                  if(additive)
                   switch(constants_cat)
                    {case 0:var init_rc=rev_constants;break;
                     case 1:var init_rc=rev_constants_mov_mvn;break;
                     default:var init_rc=rev_constants_mov_mvn_strict}
                  else
                   switch(constants_cat)
                    {case 0:var init_rc=constants;break;
                     case 1:var init_rc=constants_mov_mvn;break;
                     default:var init_rc=constants_mov_mvn_strict}
                  var
                   rc$1=caml_call2(Stdlib_list[41],is_valid_fst,init_rc),
                   try_nb=0,
                   rc=rc$1;
                  for(;;)
                   {if(tad0$0 <= try_nb)
                     var _li_=0;
                    else
                     {var match=caml_call1(remove_init(i),rc);
                      if(match)
                       {var
                         rc$0=match[2],
                         fst=match[1],
                         remainder=op_init(i,fst),
                         match$0=next([0,fst,0],filtered_rev_constants,remainder);
                        if(! match$0)
                         {var try_nb$0=try_nb + 1 | 0,try_nb=try_nb$0,rc=rc$0;
                          continue}
                        var res=match$0[1],_li_=[0,res]}
                      else
                       var _li_=0}
                    if(_li_)
                     {var lst=_li_[1];return [0,caml_call1(Stdlib_list[9],lst)]}
                    return 0}},
               synthesis_optimal=
                function
                 (constants_cat,
                  incr_add,
                  incr_sub,
                  max_card,
                  i,
                  is_valid_fst,
                  is_valid)
                 {var card=1;
                  for(;;)
                   {if(max_card < card)return 0;
                    var
                     match=
                      synthesis
                       (constants_cat,
                        1,
                        incr_add,
                        card,
                        i,
                        is_valid_fst,
                        caml_call1(is_valid,1));
                    if(match){var lst=match[1];return [0,[0,lst,1]]}
                    var
                     match$0=
                      synthesis
                       (constants_cat,
                        0,
                        incr_sub,
                        card,
                        i,
                        is_valid_fst,
                        caml_call1(is_valid,0));
                    if(match$0){var lst$0=match$0[1];return [0,[0,lst$0,0]]}
                    var card$0=card + 1 | 0,card=card$0;
                    continue}},
               synthesis_test=
                function(max_card,i)
                 {function _lf_(param,_lg_){return 1}
                  return synthesis_optimal
                          (1,0,1,max_card,i,function(param){return 1},_lf_)},
               is_command_valid=
                function(arm)
                 {try
                   {var
                     _lb_=arm_to_binary(arm),
                     _lc_=
                      function(i){return is_code_writable(codes_for_command(i))},
                     _ld_=caml_call2(Stdlib_list[33],_lc_,_lb_);
                    return _ld_}
                  catch(_le_)
                   {_le_ = caml_wrap_exception(_le_);
                    if(_le_ === InvalidCommand)return 0;
                    throw _le_}},
               tweak_command=
                function(param)
                 {var
                   optimize=param[2],
                   arm=param[1],
                   strict=tweaker_mode[1]?0:1;
                  function optimize_with_card(arm,n,pad)
                   {var switch$0=0;
                    switch(arm[0])
                     {case 2:
                       var
                        rs=arm[5],
                        rd=arm[4],
                        cond=arm[3],
                        s=arm[2],
                        instr=arm[1],
                        cmd=[2,instr,s,cond,rd,rs];
                       switch(rs[0])
                        {case 0:
                          var
                           i=rs[1],
                           mk_cmd_first=
                            function(fst)
                             {var
                               nfst=caml_call1(Stdlib_int32[11],fst),
                               constant_set_mov=strict?constants_set:constants_set_no_carry,
                               _k$_=0 === instr?1:0,
                               _la_=_k$_?caml_call2(UInt32Set[3],fst,constant_set_mov):_k$_,
                               is_mov=
                                _la_
                                ||
                                1
                                -
                                caml_call2(UInt32Set[3],nfst,constants_set);
                              return is_mov
                                      ?strict?[2,0,s,cond,rd,[0,fst]]:[2,0,1,cond,rd,[0,fst]]
                                      :strict?[2,1,s,cond,rd,[0,nfst]]:[2,1,0,cond,rd,[0,nfst]]},
                           mk_cmd=
                            function(additive,i)
                             {if(additive)
                               {if(strict)return [3,4,s,cond,rd,rd,[0,i]];
                                var
                                 _k9_=15 === rd?1:0,
                                 _k8_=[0,i],
                                 _k__=_k9_ || (0 === rd?1:0);
                                return [3,0,_k__,cond,rd,rd,_k8_]}
                              return strict
                                      ?[3,5,s,cond,rd,rd,[0,i]]
                                      :[3,1,0,cond,rd,rd,[0,i]]},
                           i$0=0 === instr?i:caml_call1(Stdlib_int32[11],i),
                           _kC_=function(add,i){return is_command_valid(mk_cmd(add,i))},
                           _kD_=function(i){return is_command_valid(mk_cmd_first(i))},
                           _kE_=1 - strict,
                           _kF_=0,
                           _kG_=strict?2:1,
                           match=synthesis_optimal(_kG_,_kF_,_kE_,n,i$0,_kD_,_kC_);
                          if(match)
                           {var _kH_=match[1],_kI_=_kH_[1];
                            if(! _kI_)throw [0,Assert_failure,_aZ_];
                            var
                             additive=_kH_[2],
                             lst=_kI_[2],
                             fst=_kI_[1],
                             _kJ_=function(_k7_){return mk_cmd(additive,_k7_)},
                             _kK_=caml_call2(Stdlib_list[19],_kJ_,lst),
                             _kX_=[0,mk_cmd_first(fst),_kK_]}
                          else
                           var _kX_=[0,cmd,0];
                          break;
                         case 1:var _kX_=[0,cmd,0];break;
                         default:var _kX_=caml_call1(Stdlib[2],cst_Not_implemented$1)}
                       var res=_kX_;
                       break;
                      case 3:
                       var
                        op2=arm[6],
                        rn=arm[5],
                        rd$0=arm[4],
                        cond$0=arm[3],
                        s$0=arm[2],
                        instr$0=arm[1],
                        switch$1=0;
                       if
                        (0
                         !==
                         instr$0
                         &&
                         1
                         !==
                         instr$0
                         &&
                         4
                         !==
                         instr$0
                         &&
                         5
                         !==
                         instr$0)
                        {switch$0 = 1;switch$1 = 1}
                       if(! switch$1)
                        {if
                          (0
                           !==
                           instr$0
                           &&
                           1
                           !==
                           instr$0
                           &&
                           4
                           !==
                           instr$0
                           &&
                           5
                           !==
                           instr$0)
                          throw [0,Assert_failure,_a1_];
                         var cmd$0=[3,instr$0,s$0,cond$0,rd$0,rn,op2];
                         switch(op2[0])
                          {case 0:
                            var i$1=op2[1],switch$2=0;
                            if(! strict && 5 === instr$0)
                             {var i$2=caml_call1(Stdlib_int32[7],i$1);switch$2 = 1}
                            if(! switch$2)var i$2=i$1;
                            var
                             _kL_=0 === instr$0?1:0,
                             is_addition=_kL_ || (4 === instr$0?1:0),
                             mk_cmd_first$0=
                              function(fst)
                               {if(strict)return [3,instr$0,s$0,cond$0,rd$0,rn,[0,fst]];
                                if(is_addition)
                                 {var
                                   _k5_=15 === rn?1:0,
                                   _k4_=[0,fst],
                                   _k6_=_k5_ || (0 === rn?1:0);
                                  return [3,0,_k6_,cond$0,rd$0,rn,_k4_]}
                                return [3,1,0,cond$0,rd$0,rn,[0,fst]]},
                             mk_cmd$0=
                              function(additive,i)
                               {var is_addition$0=additive?is_addition:additive;
                                if(is_addition$0)
                                 var must_add=is_addition$0;
                                else
                                 var _k3_=1 - additive,must_add=_k3_?1 - is_addition:_k3_;
                                if(must_add)
                                 {if(strict)return [3,4,s$0,cond$0,rd$0,rd$0,[0,i]];
                                  var
                                   _k1_=15 === rd$0?1:0,
                                   _k0_=[0,i],
                                   _k2_=_k1_ || (0 === rd$0?1:0);
                                  return [3,0,_k2_,cond$0,rd$0,rd$0,_k0_]}
                                return strict
                                        ?[3,5,s$0,cond$0,rd$0,rd$0,[0,i]]
                                        :[3,1,0,cond$0,rd$0,rd$0,[0,i]]},
                             _kM_=
                              function(add,i){return is_command_valid(mk_cmd$0(add,i))},
                             _kN_=function(i){return is_command_valid(mk_cmd_first$0(i))},
                             _kO_=is_addition?1 - strict:is_addition,
                             _kP_=1 - is_addition,
                             _kQ_=_kP_?1 - strict:_kP_,
                             match$0=synthesis_optimal(0,_kQ_,_kO_,n,i$2,_kN_,_kM_);
                            if(match$0)
                             {var _kR_=match$0[1],_kS_=_kR_[1];
                              if(! _kS_)throw [0,Assert_failure,_a0_];
                              var
                               additive$0=_kR_[2],
                               lst$0=_kS_[2],
                               fst$0=_kS_[1],
                               _kT_=function(_kZ_){return mk_cmd$0(additive$0,_kZ_)},
                               _kU_=caml_call2(Stdlib_list[19],_kT_,lst$0),
                               _kY_=[0,mk_cmd_first$0(fst$0),_kU_]}
                            else
                             var _kY_=[0,cmd$0,0];
                            break;
                           case 1:var _kY_=[0,cmd$0,0];break;
                           default:var _kY_=caml_call1(Stdlib[2],cst_Not_implemented$2)}
                         var res=_kY_}
                       break;
                      default:switch$0 = 1}
                    if(switch$0)var res=[0,arm,0];
                    if(pad)
                     {var
                       _kV_=function(param){return padding_code},
                       _kW_=n - caml_call1(Stdlib_list[1],res) | 0,
                       padding=caml_call2(Stdlib_list[10],_kW_,_kV_);
                      return caml_call2(Stdlib[37],res,padding)}
                    return res}
                  if(typeof optimize === "number")
                   return optimize?optimize_with_card(arm,5,0):[0,arm,0];
                  var card=optimize[1];
                  return optimize_with_card(arm,card,1)},
               tweak_arm=
                function(lst)
                 {var _kB_=caml_call2(Stdlib_list[19],tweak_command,lst);
                  return caml_call1(Stdlib_list[14],_kB_)},
               do_not_tweak_arm=
                function(lst)
                 {function _kA_(param)
                   {var optimize=param[2],arm=param[1];
                    if(0 === optimize)return arm;
                    throw CannotOptimize}
                  return caml_call2(Stdlib_list[19],_kA_,lst)},
               Optimizer=
                [0,CannotOptimize,synthesis_test,tweak_arm,do_not_tweak_arm];
              caml_register_global(486,Optimizer,"Optimizer");
              var
               CommandError=
                [248,cst_Parser_ast_CommandError,caml_fresh_oo_id(0)],
               StructError=
                [248,cst_Parser_ast_StructError,caml_fresh_oo_id(0)],
               preprocess=
                function(env,ui)
                 {if(0 === ui[0]){var i=ui[1];return i}
                  var e=ui[1];
                  return eval_meta_expr(env,e)},
               combine_opt=
                function(o1,o2)
                 {if(o1)
                   {var _kz_=o1[1];if(o2)throw StructError;var s=_kz_}
                  else
                   {if(! o2)return 0;var s=o2[1]}
                  return [0,s]},
               combine_bool=
                function(b1,b2)
                 {if(b1){if(b2)throw StructError}else if(! b2)return 0;
                  return 1},
               recognize_modifiers=
                function(str$3,i)
                 {var n$2=caml_ml_string_length(str$3),mods$1=mods,i$0=i;
                  for(;;)
                   {if(n$2 <= i$0)return mods$1;
                    var
                     n=caml_ml_string_length(str$3),
                     _kp_=caml_call2(Stdlib[16],2,n - i$0 | 0),
                     str=caml_call3(Stdlib_string[9],str$3,i$0,_kp_),
                     switch$0=caml_string_compare(str,cst_LE),
                     switch$1=0;
                    if(0 <= switch$0)
                     if(0 < switch$0)
                      if(caml_string_notequal(str,cst_LO))
                       if(caml_string_notequal(str,cst_LS))
                        if(caml_string_notequal(str,cst_LT))
                         if(caml_string_notequal(str,cst_MI))
                          if(caml_string_notequal(str,cst_NE))
                           if(caml_string_notequal(str,cst_PL))
                            if(caml_string_notequal(str,cst_VC))
                             if(caml_string_notequal(str,cst_VS))
                              switch$1 = 1;
                             else
                              var _kt_=[0,_a2_,i$0 + 2 | 0];
                            else
                             var _kt_=[0,_a3_,i$0 + 2 | 0];
                           else
                            var _kt_=[0,_a4_,i$0 + 2 | 0];
                          else
                           var _kt_=[0,_a5_,i$0 + 2 | 0];
                         else
                          var _kt_=[0,_a6_,i$0 + 2 | 0];
                        else
                         var _kt_=[0,_a7_,i$0 + 2 | 0];
                       else
                        var _kt_=[0,_a8_,i$0 + 2 | 0];
                      else
                       var _kt_=[0,_a9_,i$0 + 2 | 0];
                     else
                      var _kt_=[0,_a__,i$0 + 2 | 0];
                    else
                     if(caml_string_notequal(str,cst_AL))
                      if(caml_string_notequal(str,cst_CC))
                       if(caml_string_notequal(str,cst_CS))
                        if(caml_string_notequal(str,cst_EQ))
                         if(caml_string_notequal(str,cst_GE))
                          if(caml_string_notequal(str,cst_GT))
                           if(caml_string_notequal(str,cst_HI))
                            if(caml_string_notequal(str,cst_HS))
                             switch$1 = 1;
                            else
                             var _kt_=[0,_a$_,i$0 + 2 | 0];
                           else
                            var _kt_=[0,_ba_,i$0 + 2 | 0];
                          else
                           var _kt_=[0,_bb_,i$0 + 2 | 0];
                         else
                          var _kt_=[0,_bc_,i$0 + 2 | 0];
                        else
                         var _kt_=[0,_bd_,i$0 + 2 | 0];
                       else
                        var _kt_=[0,_be_,i$0 + 2 | 0];
                      else
                       var _kt_=[0,_bf_,i$0 + 2 | 0];
                     else
                      var _kt_=[0,_bg_,i$0 + 2 | 0];
                    if(switch$1)var _kt_=[0,0,i$0];
                    var _ku_=_kt_[1];
                    if(_ku_)
                     var i$1=_kt_[2],c=_ku_[1],i$2=i$1,nmods=[0,[0,c],0,0,0,0];
                    else
                     {var
                       i$3=_kt_[2],
                       n$0=caml_ml_string_length(str$3),
                       _kq_=caml_call2(Stdlib[16],2,n$0 - i$3 | 0),
                       str$0=caml_call3(Stdlib_string[9],str$3,i$3,_kq_);
                      if(caml_string_notequal(str$0,cst_BT))
                       if(caml_string_notequal(str$0,cst_SB))
                        if(caml_string_notequal(str$0,cst_SH))
                         var
                          _kr_=caml_call2(Stdlib[16],1,n$0 - i$3 | 0),
                          str$1=caml_call3(Stdlib_string[9],str$0,0,_kr_),
                          _kv_=
                           caml_string_notequal(str$1,cst_B)
                            ?caml_string_notequal(str$1,cst_H)
                              ?caml_string_notequal(str$1,cst_T)
                                ?caml_string_notequal(str$1,cst_W)
                                  ?[0,0,i$3]
                                  :[0,_bh_,i$3 + 1 | 0]
                                :[0,_bi_,i$3 + 1 | 0]
                              :[0,_bj_,i$3 + 1 | 0]
                            :[0,_bk_,i$3 + 1 | 0];
                        else
                         var _kv_=[0,_bl_,i$3 + 2 | 0];
                       else
                        var _kv_=[0,_bm_,i$3 + 2 | 0];
                      else
                       var _kv_=[0,_bn_,i$3 + 2 | 0];
                      var _kw_=_kv_[1];
                      if(_kw_)
                       var
                        i$4=_kv_[2],
                        lst$2=_kw_[1],
                        i$2=i$4,
                        nmods=[0,0,[0,lst$2],0,0,0];
                      else
                       {var
                         i$5=_kv_[2],
                         n$1=caml_ml_string_length(str$3),
                         _ks_=caml_call2(Stdlib[16],1,n$1 - i$5 | 0),
                         str$2=caml_call3(Stdlib_string[9],str$3,i$5,_ks_),
                         match=
                          caml_string_notequal(str$2,cst_L)
                           ?caml_string_notequal(str$2,cst_S)
                             ?caml_string_notequal(str$2,cst_X)
                               ?[0,0,i$5]
                               :[0,_bo_,i$5 + 1 | 0]
                             :[0,_bp_,i$5 + 1 | 0]
                           :[0,_bq_,i$5 + 1 | 0],
                         _kx_=match[1],
                         switch$2=0;
                        if(_kx_)
                         {var _ky_=_kx_[1];
                          if(caml_string_notequal(_ky_,cst_L$0))
                           if(caml_string_notequal(_ky_,cst_S$0))
                            if(caml_string_notequal(_ky_,cst_X$0))
                             switch$2 = 1;
                            else
                             var i$6=match[2],i$2=i$6,nmods=_br_;
                           else
                            var i$7=match[2],i$2=i$7,nmods=_bs_;
                          else
                           var i$8=match[2],i$2=i$8,nmods=_bt_}
                        else
                         switch$2 = 1;
                        if(switch$2)throw StructError}}
                    var
                     x=nmods[5],
                     l=nmods[4],
                     s=nmods[3],
                     lst=nmods[2],
                     cond=nmods[1],
                     x$0=mods$1[5],
                     l$0=mods$1[4],
                     s$0=mods$1[3],
                     lst$0=mods$1[2],
                     cond$0=mods$1[1],
                     cond$1=combine_opt(cond$0,cond),
                     lst$1=combine_opt(lst$0,lst),
                     s$1=combine_bool(s$0,s),
                     l$1=combine_bool(l$0,l),
                     x$1=combine_bool(x$0,x),
                     mods$0=[0,cond$1,lst$1,s$1,l$1,x$1],
                     mods$1=mods$0,
                     i$0=i$2;
                    continue}},
               register_of_str=
                function(str)
                 {var
                   str$0=caml_call1(Stdlib_string[16],str),
                   switch$0=caml_string_compare(str$0,cst_r15);
                  if(0 <= switch$0)
                   {if(! (0 < switch$0))return 15;
                    var switch$1=caml_string_compare(str$0,cst_r7);
                    if(0 <= switch$1)
                     {if(! (0 < switch$1))return 7;
                      if(! caml_string_notequal(str$0,cst_r8))return 8;
                      if(! caml_string_notequal(str$0,cst_r9))return 9;
                      if(! caml_string_notequal(str$0,cst_sb))return sb;
                      if(! caml_string_notequal(str$0,cst_sl))return sl;
                      if(! caml_string_notequal(str$0,cst_sp))return sp}
                    else
                     {if(! caml_string_notequal(str$0,cst_r2))return 2;
                      if(! caml_string_notequal(str$0,cst_r3))return 3;
                      if(! caml_string_notequal(str$0,cst_r4))return 4;
                      if(! caml_string_notequal(str$0,cst_r5))return 5;
                      if(! caml_string_notequal(str$0,cst_r6))return 6}}
                  else
                   {var switch$2=caml_string_compare(str$0,cst_r1);
                    if(0 <= switch$2)
                     {if(! (0 < switch$2))return 1;
                      if(! caml_string_notequal(str$0,cst_r10))return 10;
                      if(! caml_string_notequal(str$0,cst_r11))return 11;
                      if(! caml_string_notequal(str$0,cst_r12))return 12;
                      if(! caml_string_notequal(str$0,cst_r13))return 13;
                      if(! caml_string_notequal(str$0,cst_r14))return 14}
                    else
                     {if(! caml_string_notequal(str$0,cst_fp))return fp;
                      if(! caml_string_notequal(str$0,cst_ip))return ip;
                      if(! caml_string_notequal(str$0,cst_lr))return lr;
                      if(! caml_string_notequal(str$0,cst_pc))return pc;
                      if(! caml_string_notequal(str$0,cst_r0))return 0}}
                  throw StructError},
               get_register=
                function(arg)
                 {if(0 === arg[0]){var str=arg[1];return register_of_str(str)}
                  throw StructError},
               get_rd=
                function(args)
                 {return get_register(caml_call1(Stdlib_list[5],args))},
               get_rn=
                function(args)
                 {var n=caml_call1(Stdlib_list[1],args);
                  return get_register
                          (caml_call2(Stdlib_list[7],args,n - 2 | 0))},
               get_op2=
                function(env,args)
                 {var
                   n=caml_call1(Stdlib_list[1],args),
                   arg=caml_call2(Stdlib_list[7],args,n - 1 | 0);
                  switch(arg[0])
                   {case 0:var str=arg[1];return [1,register_of_str(str)];
                    case 1:var i=arg[1];return [0,preprocess(env,i)];
                    default:throw StructError}},
               get_ro=
                function(env,args)
                 {var
                   n=caml_call1(Stdlib_list[1],args),
                   match=caml_call2(Stdlib_list[7],args,n - 1 | 0);
                  if(2 === match[0])
                   {var
                     addr_typ=match[3],
                     offset=match[2],
                     str=match[1],
                     r=register_of_str(str);
                    if(0 === offset[0])
                     var
                      i=offset[2],
                      sign=offset[1],
                      ro=[0,r,sign,preprocess(env,i)];
                    else
                     var
                      str$0=offset[2],
                      sign$0=offset[1],
                      ro=[1,r,sign$0,register_of_str(str$0)];
                    return [0,ro,addr_typ]}
                  throw StructError},
               get_target=
                function(env,args)
                 {var arg=caml_call1(Stdlib_list[5],args);
                  if(1 === arg[0]){var i=arg[1];return preprocess(env,i)}
                  throw StructError},
               cmd_to_arm=
                function(env,cmd$1)
                 {if(0 === cmd$1[0])
                   {var
                     optimize=cmd$1[4],
                     args=cmd$1[3],
                     cmd$2=cmd$1[2],
                     pos=cmd$1[1];
                    try
                     {try
                       {if(caml_ml_string_length(cmd$2) < 3)throw StructError;
                        var
                         cmd=caml_call1(Stdlib_string[15],cmd$2),
                         match=recognize_modifiers(cmd,3),
                         s=match[3],
                         typ=match[2],
                         cond=match[1];
                        if(cond)var c=cond[1],cond$0=c;else var cond$0=16;
                        if(typ)var typ$0=typ[1],typ$1=typ$0;else var typ$1=4;
                        try
                         {var
                           match$0=caml_call3(Stdlib_string[9],cmd,0,3),
                           switch$0=caml_string_compare(match$0,cst_MOV),
                           switch$1=0;
                          if(0 <= switch$0)
                           if(0 < switch$0)
                            if(caml_string_notequal(match$0,cst_MVN))
                             if(caml_string_notequal(match$0,cst_ORR))
                              if(caml_string_notequal(match$0,cst_SBC))
                               if(caml_string_notequal(match$0,cst_STR))
                                if(caml_string_notequal(match$0,cst_SUB))
                                 switch$1 = 1;
                                else
                                 var
                                  _jZ_=get_op2(env,args),
                                  _j0_=get_rn(args),
                                  _j1_=[3,5,s,cond$0,get_rd(args),_j0_,_jZ_];
                               else
                                var
                                 _j2_=get_ro(env,args),
                                 _j1_=[1,1,typ$1,cond$0,get_rd(args),_j2_];
                              else
                               var
                                _j3_=get_op2(env,args),
                                _j4_=get_rn(args),
                                _j1_=[3,1,s,cond$0,get_rd(args),_j4_,_j3_];
                             else
                              var
                               _j5_=get_op2(env,args),
                               _j6_=get_rn(args),
                               _j1_=[3,6,s,cond$0,get_rd(args),_j6_,_j5_];
                            else
                             var
                              _j7_=get_op2(env,args),
                              _j1_=[2,1,s,cond$0,get_rd(args),_j7_];
                           else
                            var
                             _j8_=get_op2(env,args),
                             _j1_=[2,0,s,cond$0,get_rd(args),_j8_];
                          else
                           if(caml_string_notequal(match$0,cst_ADC))
                            if(caml_string_notequal(match$0,cst_ADD))
                             if(caml_string_notequal(match$0,cst_AND))
                              if(caml_string_notequal(match$0,cst_BIC))
                               if(caml_string_notequal(match$0,cst_EOR))
                                if(caml_string_notequal(match$0,cst_LDR))
                                 switch$1 = 1;
                                else
                                 var
                                  _j9_=get_ro(env,args),
                                  _j1_=[1,0,typ$1,cond$0,get_rd(args),_j9_];
                               else
                                var
                                 _j__=get_op2(env,args),
                                 _j$_=get_rn(args),
                                 _j1_=[3,7,s,cond$0,get_rd(args),_j$_,_j__];
                              else
                               var
                                _ka_=get_op2(env,args),
                                _kb_=get_rn(args),
                                _j1_=[3,2,s,cond$0,get_rd(args),_kb_,_ka_];
                             else
                              var
                               _kc_=get_op2(env,args),
                               _kd_=get_rn(args),
                               _j1_=[3,3,s,cond$0,get_rd(args),_kd_,_kc_];
                            else
                             var
                              _ke_=get_op2(env,args),
                              _kf_=get_rn(args),
                              _j1_=[3,4,s,cond$0,get_rd(args),_kf_,_ke_];
                           else
                            var
                             _kg_=get_op2(env,args),
                             _kh_=get_rn(args),
                             _j1_=[3,0,s,cond$0,get_rd(args),_kh_,_kg_];
                          if(switch$1)throw StructError}
                        catch(_ko_)
                         {_ko_ = caml_wrap_exception(_ko_);
                          if(_ko_[1] !== Stdlib[7] && _ko_[1] !== Stdlib[6])
                           throw _ko_;
                          throw StructError}
                        var _kj_=_j1_}
                      catch(_km_)
                       {_km_ = caml_wrap_exception(_km_);
                        if(_km_ !== StructError)throw _km_;
                        if(caml_ml_string_length(cmd$2) < 1)throw StructError;
                        var
                         cmd$0=caml_call1(Stdlib_string[15],cmd$2),
                         match$1=recognize_modifiers(cmd$0,1),
                         x=match$1[5],
                         l=match$1[4],
                         cond$1=match$1[1];
                        if(cond$1)var c$0=cond$1[1],cond$2=c$0;else var cond$2=16;
                        try
                         {var match$2=caml_call3(Stdlib_string[9],cmd$0,0,1);
                          if(caml_string_notequal(match$2,cst_B$0))throw StructError;
                          var
                           _ki_=
                            x
                             ?[5,l,cond$2,get_rd(args)]
                             :[4,l,cond$2,get_target(env,args)]}
                        catch(_kn_)
                         {_kn_ = caml_wrap_exception(_kn_);
                          if(_kn_[1] !== Stdlib[7] && _kn_[1] !== Stdlib[6])
                           throw _kn_;
                          throw StructError}
                        var _kj_=_ki_}
                      var _kk_=[0,_kj_,optimize];
                      return _kk_}
                    catch(_kl_)
                     {_kl_ = caml_wrap_exception(_kl_);
                      if(_kl_ === StructError)throw [0,CommandError,pos];
                      throw _kl_}}
                  var i=cmd$1[2];
                  return [0,[0,preprocess(env,i)],0]},
               to_arm=
                function(env,ast)
                 {function _jX_(_jY_){return cmd_to_arm(env,_jY_)}
                  return caml_call2(Stdlib_list[19],_jX_,ast)},
               Parser_ast=[0,CommandError,to_arm];
              caml_register_global(487,Parser_ast,"Parser_ast");
              var
               eRR=[248,cst_Parser_MenhirBasics_Error,caml_fresh_oo_id(0)],
               menhir_discard=
                function(menhir_env)
                 {var
                   lexer=menhir_env[1],
                   lexbuf=menhir_env[2],
                   tok=caml_call1(lexer,lexbuf);
                  return [0,lexer,lexbuf,tok,0]},
               menhir_errorcase=
                function(menhir_env,menhir_stack,menhir_s)
                 {var menhir_stack$0=menhir_stack,menhir_s$0=menhir_s;
                  for(;;)
                   switch(menhir_s$0)
                    {case 0:
                      var
                       match=menhir_stack$0[1],
                       menhir_s$1=match[2],
                       menhir_stack$1=match[1],
                       menhir_stack$0=menhir_stack$1,
                       menhir_s$0=menhir_s$1;
                      continue;
                     case 1:throw eRR;
                     case 2:throw eRR;
                     case 3:throw eRR;
                     case 4:
                      var
                       menhir_s$2=menhir_stack$0[2],
                       menhir_stack$2=menhir_stack$0[1],
                       menhir_stack$0=menhir_stack$2,
                       menhir_s$0=menhir_s$2;
                      continue;
                     case 5:
                      var
                       menhir_s$3=menhir_stack$0[2],
                       menhir_stack$3=menhir_stack$0[1],
                       menhir_stack$0=menhir_stack$3,
                       menhir_s$0=menhir_s$3;
                      continue;
                     case 6:
                      var
                       menhir_s$4=menhir_stack$0[2],
                       menhir_stack$4=menhir_stack$0[1],
                       menhir_stack$0=menhir_stack$4,
                       menhir_s$0=menhir_s$4;
                      continue;
                     case 7:
                      var
                       match$0=menhir_stack$0[1],
                       menhir_s$5=match$0[2],
                       menhir_stack$5=match$0[1],
                       menhir_stack$0=menhir_stack$5,
                       menhir_s$0=menhir_s$5;
                      continue;
                     case 8:
                      var
                       menhir_s$6=menhir_stack$0[2],
                       menhir_stack$6=menhir_stack$0[1],
                       menhir_stack$0=menhir_stack$6,
                       menhir_s$0=menhir_s$6;
                      continue;
                     case 9:
                      var
                       menhir_s$7=menhir_stack$0[2],
                       menhir_stack$7=menhir_stack$0[1],
                       menhir_stack$0=menhir_stack$7,
                       menhir_s$0=menhir_s$7;
                      continue;
                     case 10:
                      var
                       menhir_s$8=menhir_stack$0[2],
                       menhir_stack$8=menhir_stack$0[1],
                       menhir_stack$0=menhir_stack$8,
                       menhir_s$0=menhir_s$8;
                      continue;
                     case 11:
                      var
                       menhir_s$9=menhir_stack$0[2],
                       menhir_stack$9=menhir_stack$0[1],
                       menhir_stack$0=menhir_stack$9,
                       menhir_s$0=menhir_s$9;
                      continue;
                     case 12:
                      var
                       menhir_s$10=menhir_stack$0[2],
                       menhir_stack$10=menhir_stack$0[1],
                       menhir_stack$0=menhir_stack$10,
                       menhir_s$0=menhir_s$10;
                      continue;
                     case 13:
                      var
                       match$1=menhir_stack$0[1],
                       menhir_s$11=match$1[2],
                       menhir_stack$11=match$1[1],
                       menhir_stack$0=menhir_stack$11,
                       menhir_s$0=menhir_s$11;
                      continue;
                     case 14:
                      var
                       menhir_s$12=menhir_stack$0[2],
                       menhir_stack$12=menhir_stack$0[1],
                       menhir_stack$0=menhir_stack$12,
                       menhir_s$0=menhir_s$12;
                      continue;
                     case 15:
                      var
                       menhir_s$13=menhir_stack$0[2],
                       menhir_stack$13=menhir_stack$0[1],
                       menhir_stack$0=menhir_stack$13,
                       menhir_s$0=menhir_s$13;
                      continue;
                     case 16:
                      var
                       menhir_s$14=menhir_stack$0[2],
                       menhir_stack$14=menhir_stack$0[1],
                       menhir_stack$0=menhir_stack$14,
                       menhir_s$0=menhir_s$14;
                      continue;
                     case 17:
                      var
                       menhir_s$15=menhir_stack$0[2],
                       menhir_stack$15=menhir_stack$0[1],
                       menhir_stack$0=menhir_stack$15,
                       menhir_s$0=menhir_s$15;
                      continue;
                     case 18:
                      var
                       menhir_s$16=menhir_stack$0[2],
                       menhir_stack$16=menhir_stack$0[1],
                       menhir_stack$0=menhir_stack$16,
                       menhir_s$0=menhir_s$16;
                      continue;
                     case 19:
                      var
                       menhir_s$17=menhir_stack$0[2],
                       menhir_stack$17=menhir_stack$0[1],
                       menhir_stack$0=menhir_stack$17,
                       menhir_s$0=menhir_s$17;
                      continue;
                     case 20:
                      var
                       menhir_s$18=menhir_stack$0[2],
                       menhir_stack$18=menhir_stack$0[1],
                       menhir_stack$0=menhir_stack$18,
                       menhir_s$0=menhir_s$18;
                      continue;
                     case 21:
                      var
                       menhir_s$19=menhir_stack$0[2],
                       menhir_stack$19=menhir_stack$0[1],
                       menhir_stack$0=menhir_stack$19,
                       menhir_s$0=menhir_s$19;
                      continue;
                     case 22:
                      var
                       menhir_s$20=menhir_stack$0[2],
                       menhir_stack$20=menhir_stack$0[1],
                       menhir_stack$0=menhir_stack$20,
                       menhir_s$0=menhir_s$20;
                      continue;
                     case 23:
                      var
                       menhir_s$21=menhir_stack$0[2],
                       menhir_stack$21=menhir_stack$0[1],
                       menhir_stack$0=menhir_stack$21,
                       menhir_s$0=menhir_s$21;
                      continue;
                     case 24:
                      var
                       menhir_s$22=menhir_stack$0[2],
                       menhir_stack$22=menhir_stack$0[1],
                       menhir_stack$0=menhir_stack$22,
                       menhir_s$0=menhir_s$22;
                      continue;
                     case 25:
                      var
                       menhir_s$23=menhir_stack$0[2],
                       menhir_stack$23=menhir_stack$0[1],
                       menhir_stack$0=menhir_stack$23,
                       menhir_s$0=menhir_s$23;
                      continue;
                     case 26:
                      var
                       menhir_s$24=menhir_stack$0[2],
                       menhir_stack$24=menhir_stack$0[1],
                       menhir_stack$0=menhir_stack$24,
                       menhir_s$0=menhir_s$24;
                      continue;
                     case 27:
                      var
                       menhir_s$25=menhir_stack$0[2],
                       menhir_stack$25=menhir_stack$0[1],
                       menhir_stack$0=menhir_stack$25,
                       menhir_s$0=menhir_s$25;
                      continue;
                     case 28:
                      var
                       menhir_s$26=menhir_stack$0[2],
                       menhir_stack$26=menhir_stack$0[1],
                       menhir_stack$0=menhir_stack$26,
                       menhir_s$0=menhir_s$26;
                      continue;
                     case 29:
                      var
                       menhir_s$27=menhir_stack$0[2],
                       menhir_stack$27=menhir_stack$0[1],
                       menhir_stack$0=menhir_stack$27,
                       menhir_s$0=menhir_s$27;
                      continue;
                     case 30:
                      var
                       menhir_s$28=menhir_stack$0[2],
                       menhir_stack$28=menhir_stack$0[1],
                       menhir_stack$0=menhir_stack$28,
                       menhir_s$0=menhir_s$28;
                      continue;
                     case 31:
                      var
                       menhir_s$29=menhir_stack$0[2],
                       menhir_stack$29=menhir_stack$0[1],
                       menhir_stack$0=menhir_stack$29,
                       menhir_s$0=menhir_s$29;
                      continue;
                     case 32:
                      var
                       menhir_s$30=menhir_stack$0[2],
                       menhir_stack$30=menhir_stack$0[1],
                       menhir_stack$0=menhir_stack$30,
                       menhir_s$0=menhir_s$30;
                      continue;
                     case 33:
                      var
                       menhir_s$31=menhir_stack$0[2],
                       menhir_stack$31=menhir_stack$0[1],
                       menhir_stack$0=menhir_stack$31,
                       menhir_s$0=menhir_s$31;
                      continue;
                     case 34:
                      var
                       menhir_s$32=menhir_stack$0[2],
                       menhir_stack$32=menhir_stack$0[1],
                       menhir_stack$0=menhir_stack$32,
                       menhir_s$0=menhir_s$32;
                      continue;
                     case 35:
                      var
                       menhir_s$33=menhir_stack$0[2],
                       menhir_stack$33=menhir_stack$0[1],
                       menhir_stack$0=menhir_stack$33,
                       menhir_s$0=menhir_s$33;
                      continue;
                     case 36:
                      var
                       menhir_s$34=menhir_stack$0[2],
                       menhir_stack$34=menhir_stack$0[1],
                       menhir_stack$0=menhir_stack$34,
                       menhir_s$0=menhir_s$34;
                      continue;
                     case 37:
                      var
                       menhir_s$35=menhir_stack$0[2],
                       menhir_stack$35=menhir_stack$0[1],
                       menhir_stack$0=menhir_stack$35,
                       menhir_s$0=menhir_s$35;
                      continue;
                     case 38:
                      var
                       menhir_s$36=menhir_stack$0[2],
                       menhir_stack$36=menhir_stack$0[1],
                       menhir_stack$0=menhir_stack$36,
                       menhir_s$0=menhir_s$36;
                      continue;
                     default:throw eRR}},
               menhir_fail=
                function(param)
                 {caml_call2(Stdlib_printf[1],Stdlib[40],_cu_);
                  throw [0,Assert_failure,_cv_]},
               menhir_goto_ast=
                function(menhir_env,menhir_stack,menhir_s,v)
                 {var menhir_stack$0=menhir_stack,menhir_s$0=menhir_s,v$0=v;
                  for(;;)
                   {if(4 === menhir_s$0)
                     {var
                       cmd=menhir_stack$0[3],
                       match=menhir_stack$0[1],
                       menhir_s$1=match[2],
                       menhir_stack$1=match[1],
                       v$1=[0,cmd,v$0],
                       menhir_stack$0=menhir_stack$1,
                       menhir_s$0=menhir_s$1,
                       v$0=v$1;
                      continue}
                    return 39 <= menhir_s$0?v$0:menhir_fail(0)}},
               menhir_goto_headers=
                function(menhir_env,menhir_stack,menhir_s,v)
                 {var menhir_stack$0=menhir_stack,menhir_s$0=menhir_s,v$0=v;
                  for(;;)
                   {if(3 === menhir_s$0)return v$0;
                    if(menhir_s$0)return menhir_fail(0);
                    var
                     d=menhir_stack$0[2],
                     match=menhir_stack$0[1],
                     menhir_s$1=match[2],
                     menhir_stack$1=match[1],
                     v$1=[0,d,v$0],
                     menhir_stack$0=menhir_stack$1,
                     menhir_s$0=menhir_s$1,
                     v$0=v$1;
                    continue}},
               menhir_run15=
                function(counter,menhir_env,menhir_stack)
                 {var
                   menhir_env$0=menhir_discard(menhir_env),
                   tok=menhir_env$0[3];
                  if(typeof tok === "number")
                   switch(tok)
                    {case 6:
                      var _jO_=30;
                      if(counter < 50)
                       {var counter$6=counter + 1 | 0;
                        return menhir_run6(counter$6,menhir_env$0,menhir_stack,_jO_)}
                      return caml_trampoline_return
                              (menhir_run6,[0,menhir_env$0,menhir_stack,_jO_]);
                     case 9:
                      var _jP_=30;
                      if(counter < 50)
                       {var counter$4=counter + 1 | 0;
                        return menhir_run8(counter$4,menhir_env$0,menhir_stack,_jP_)}
                      return caml_trampoline_return
                              (menhir_run8,[0,menhir_env$0,menhir_stack,_jP_]);
                     case 12:
                      var _jQ_=30;
                      if(counter < 50)
                       {var counter$3=counter + 1 | 0;
                        return menhir_run9(counter$3,menhir_env$0,menhir_stack,_jQ_)}
                      return caml_trampoline_return
                              (menhir_run9,[0,menhir_env$0,menhir_stack,_jQ_]);
                     case 14:
                      var _jR_=30;
                      if(counter < 50)
                       {var counter$2=counter + 1 | 0;
                        return menhir_run10
                                (counter$2,menhir_env$0,menhir_stack,_jR_)}
                      return caml_trampoline_return
                              (menhir_run10,[0,menhir_env$0,menhir_stack,_jR_]);
                     case 20:
                      var _jS_=30;
                      if(counter < 50)
                       {var counter$0=counter + 1 | 0;
                        return menhir_run12
                                (counter$0,menhir_env$0,menhir_stack,_jS_)}
                      return caml_trampoline_return
                              (menhir_run12,[0,menhir_env$0,menhir_stack,_jS_])
                     }
                  else
                   switch(tok[0])
                    {case 1:
                      var v=tok[1],_jT_=menhir_env$0[2][11],_jU_=30;
                      if(counter < 50)
                       {var counter$5=counter + 1 | 0;
                        return menhir_run7
                                (counter$5,menhir_env$0,menhir_stack,_jU_,v,_jT_)}
                      return caml_trampoline_return
                              (menhir_run7,[0,menhir_env$0,menhir_stack,_jU_,v,_jT_]);
                     case 2:
                      var v$0=tok[1],_jV_=menhir_env$0[2][11],_jW_=30;
                      if(counter < 50)
                       {var counter$1=counter + 1 | 0;
                        return menhir_run11
                                (counter$1,menhir_env$0,menhir_stack,_jW_,v$0,_jV_)}
                      return caml_trampoline_return
                              (menhir_run11,[0,menhir_env$0,menhir_stack,_jW_,v$0,_jV_])
                     }
                  if(menhir_env$0[4])throw [0,Assert_failure,_bu_];
                  menhir_env$0[4] = 1;
                  return menhir_errorcase(menhir_env$0,menhir_stack,30)},
               menhir_run17=
                function(counter,menhir_env,menhir_stack)
                 {var
                   menhir_env$0=menhir_discard(menhir_env),
                   tok=menhir_env$0[3];
                  if(typeof tok === "number")
                   switch(tok)
                    {case 6:
                      var _jF_=29;
                      if(counter < 50)
                       {var counter$6=counter + 1 | 0;
                        return menhir_run6(counter$6,menhir_env$0,menhir_stack,_jF_)}
                      return caml_trampoline_return
                              (menhir_run6,[0,menhir_env$0,menhir_stack,_jF_]);
                     case 9:
                      var _jG_=29;
                      if(counter < 50)
                       {var counter$4=counter + 1 | 0;
                        return menhir_run8(counter$4,menhir_env$0,menhir_stack,_jG_)}
                      return caml_trampoline_return
                              (menhir_run8,[0,menhir_env$0,menhir_stack,_jG_]);
                     case 12:
                      var _jH_=29;
                      if(counter < 50)
                       {var counter$3=counter + 1 | 0;
                        return menhir_run9(counter$3,menhir_env$0,menhir_stack,_jH_)}
                      return caml_trampoline_return
                              (menhir_run9,[0,menhir_env$0,menhir_stack,_jH_]);
                     case 14:
                      var _jI_=29;
                      if(counter < 50)
                       {var counter$2=counter + 1 | 0;
                        return menhir_run10
                                (counter$2,menhir_env$0,menhir_stack,_jI_)}
                      return caml_trampoline_return
                              (menhir_run10,[0,menhir_env$0,menhir_stack,_jI_]);
                     case 20:
                      var _jJ_=29;
                      if(counter < 50)
                       {var counter$0=counter + 1 | 0;
                        return menhir_run12
                                (counter$0,menhir_env$0,menhir_stack,_jJ_)}
                      return caml_trampoline_return
                              (menhir_run12,[0,menhir_env$0,menhir_stack,_jJ_])
                     }
                  else
                   switch(tok[0])
                    {case 1:
                      var v=tok[1],_jK_=menhir_env$0[2][11],_jL_=29;
                      if(counter < 50)
                       {var counter$5=counter + 1 | 0;
                        return menhir_run7
                                (counter$5,menhir_env$0,menhir_stack,_jL_,v,_jK_)}
                      return caml_trampoline_return
                              (menhir_run7,[0,menhir_env$0,menhir_stack,_jL_,v,_jK_]);
                     case 2:
                      var v$0=tok[1],_jM_=menhir_env$0[2][11],_jN_=29;
                      if(counter < 50)
                       {var counter$1=counter + 1 | 0;
                        return menhir_run11
                                (counter$1,menhir_env$0,menhir_stack,_jN_,v$0,_jM_)}
                      return caml_trampoline_return
                              (menhir_run11,[0,menhir_env$0,menhir_stack,_jN_,v$0,_jM_])
                     }
                  if(menhir_env$0[4])throw [0,Assert_failure,_bv_];
                  menhir_env$0[4] = 1;
                  return menhir_errorcase(menhir_env$0,menhir_stack,29)},
               menhir_run19=
                function(counter,menhir_env,menhir_stack)
                 {var
                   menhir_env$0=menhir_discard(menhir_env),
                   tok=menhir_env$0[3];
                  if(typeof tok === "number")
                   switch(tok)
                    {case 6:
                      var _jw_=28;
                      if(counter < 50)
                       {var counter$6=counter + 1 | 0;
                        return menhir_run6(counter$6,menhir_env$0,menhir_stack,_jw_)}
                      return caml_trampoline_return
                              (menhir_run6,[0,menhir_env$0,menhir_stack,_jw_]);
                     case 9:
                      var _jx_=28;
                      if(counter < 50)
                       {var counter$4=counter + 1 | 0;
                        return menhir_run8(counter$4,menhir_env$0,menhir_stack,_jx_)}
                      return caml_trampoline_return
                              (menhir_run8,[0,menhir_env$0,menhir_stack,_jx_]);
                     case 12:
                      var _jy_=28;
                      if(counter < 50)
                       {var counter$3=counter + 1 | 0;
                        return menhir_run9(counter$3,menhir_env$0,menhir_stack,_jy_)}
                      return caml_trampoline_return
                              (menhir_run9,[0,menhir_env$0,menhir_stack,_jy_]);
                     case 14:
                      var _jz_=28;
                      if(counter < 50)
                       {var counter$2=counter + 1 | 0;
                        return menhir_run10
                                (counter$2,menhir_env$0,menhir_stack,_jz_)}
                      return caml_trampoline_return
                              (menhir_run10,[0,menhir_env$0,menhir_stack,_jz_]);
                     case 20:
                      var _jA_=28;
                      if(counter < 50)
                       {var counter$0=counter + 1 | 0;
                        return menhir_run12
                                (counter$0,menhir_env$0,menhir_stack,_jA_)}
                      return caml_trampoline_return
                              (menhir_run12,[0,menhir_env$0,menhir_stack,_jA_])
                     }
                  else
                   switch(tok[0])
                    {case 1:
                      var v=tok[1],_jB_=menhir_env$0[2][11],_jC_=28;
                      if(counter < 50)
                       {var counter$5=counter + 1 | 0;
                        return menhir_run7
                                (counter$5,menhir_env$0,menhir_stack,_jC_,v,_jB_)}
                      return caml_trampoline_return
                              (menhir_run7,[0,menhir_env$0,menhir_stack,_jC_,v,_jB_]);
                     case 2:
                      var v$0=tok[1],_jD_=menhir_env$0[2][11],_jE_=28;
                      if(counter < 50)
                       {var counter$1=counter + 1 | 0;
                        return menhir_run11
                                (counter$1,menhir_env$0,menhir_stack,_jE_,v$0,_jD_)}
                      return caml_trampoline_return
                              (menhir_run11,[0,menhir_env$0,menhir_stack,_jE_,v$0,_jD_])
                     }
                  if(menhir_env$0[4])throw [0,Assert_failure,_bw_];
                  menhir_env$0[4] = 1;
                  return menhir_errorcase(menhir_env$0,menhir_stack,28)},
               menhir_run21=
                function(counter,menhir_env,menhir_stack)
                 {var
                   menhir_env$0=menhir_discard(menhir_env),
                   tok=menhir_env$0[3];
                  if(typeof tok === "number")
                   switch(tok)
                    {case 6:
                      var _jn_=27;
                      if(counter < 50)
                       {var counter$6=counter + 1 | 0;
                        return menhir_run6(counter$6,menhir_env$0,menhir_stack,_jn_)}
                      return caml_trampoline_return
                              (menhir_run6,[0,menhir_env$0,menhir_stack,_jn_]);
                     case 9:
                      var _jo_=27;
                      if(counter < 50)
                       {var counter$4=counter + 1 | 0;
                        return menhir_run8(counter$4,menhir_env$0,menhir_stack,_jo_)}
                      return caml_trampoline_return
                              (menhir_run8,[0,menhir_env$0,menhir_stack,_jo_]);
                     case 12:
                      var _jp_=27;
                      if(counter < 50)
                       {var counter$3=counter + 1 | 0;
                        return menhir_run9(counter$3,menhir_env$0,menhir_stack,_jp_)}
                      return caml_trampoline_return
                              (menhir_run9,[0,menhir_env$0,menhir_stack,_jp_]);
                     case 14:
                      var _jq_=27;
                      if(counter < 50)
                       {var counter$2=counter + 1 | 0;
                        return menhir_run10
                                (counter$2,menhir_env$0,menhir_stack,_jq_)}
                      return caml_trampoline_return
                              (menhir_run10,[0,menhir_env$0,menhir_stack,_jq_]);
                     case 20:
                      var _jr_=27;
                      if(counter < 50)
                       {var counter$0=counter + 1 | 0;
                        return menhir_run12
                                (counter$0,menhir_env$0,menhir_stack,_jr_)}
                      return caml_trampoline_return
                              (menhir_run12,[0,menhir_env$0,menhir_stack,_jr_])
                     }
                  else
                   switch(tok[0])
                    {case 1:
                      var v=tok[1],_js_=menhir_env$0[2][11],_jt_=27;
                      if(counter < 50)
                       {var counter$5=counter + 1 | 0;
                        return menhir_run7
                                (counter$5,menhir_env$0,menhir_stack,_jt_,v,_js_)}
                      return caml_trampoline_return
                              (menhir_run7,[0,menhir_env$0,menhir_stack,_jt_,v,_js_]);
                     case 2:
                      var v$0=tok[1],_ju_=menhir_env$0[2][11],_jv_=27;
                      if(counter < 50)
                       {var counter$1=counter + 1 | 0;
                        return menhir_run11
                                (counter$1,menhir_env$0,menhir_stack,_jv_,v$0,_ju_)}
                      return caml_trampoline_return
                              (menhir_run11,[0,menhir_env$0,menhir_stack,_jv_,v$0,_ju_])
                     }
                  if(menhir_env$0[4])throw [0,Assert_failure,_bx_];
                  menhir_env$0[4] = 1;
                  return menhir_errorcase(menhir_env$0,menhir_stack,27)},
               menhir_run38=
                function(counter,menhir_env,menhir_stack)
                 {var
                   menhir_env$0=menhir_discard(menhir_env),
                   tok=menhir_env$0[3];
                  if(typeof tok === "number")
                   switch(tok)
                    {case 6:
                      var _je_=19;
                      if(counter < 50)
                       {var counter$6=counter + 1 | 0;
                        return menhir_run6(counter$6,menhir_env$0,menhir_stack,_je_)}
                      return caml_trampoline_return
                              (menhir_run6,[0,menhir_env$0,menhir_stack,_je_]);
                     case 9:
                      var _jf_=19;
                      if(counter < 50)
                       {var counter$4=counter + 1 | 0;
                        return menhir_run8(counter$4,menhir_env$0,menhir_stack,_jf_)}
                      return caml_trampoline_return
                              (menhir_run8,[0,menhir_env$0,menhir_stack,_jf_]);
                     case 12:
                      var _jg_=19;
                      if(counter < 50)
                       {var counter$3=counter + 1 | 0;
                        return menhir_run9(counter$3,menhir_env$0,menhir_stack,_jg_)}
                      return caml_trampoline_return
                              (menhir_run9,[0,menhir_env$0,menhir_stack,_jg_]);
                     case 14:
                      var _jh_=19;
                      if(counter < 50)
                       {var counter$2=counter + 1 | 0;
                        return menhir_run10
                                (counter$2,menhir_env$0,menhir_stack,_jh_)}
                      return caml_trampoline_return
                              (menhir_run10,[0,menhir_env$0,menhir_stack,_jh_]);
                     case 20:
                      var _ji_=19;
                      if(counter < 50)
                       {var counter$0=counter + 1 | 0;
                        return menhir_run12
                                (counter$0,menhir_env$0,menhir_stack,_ji_)}
                      return caml_trampoline_return
                              (menhir_run12,[0,menhir_env$0,menhir_stack,_ji_])
                     }
                  else
                   switch(tok[0])
                    {case 1:
                      var v=tok[1],_jj_=menhir_env$0[2][11],_jk_=19;
                      if(counter < 50)
                       {var counter$5=counter + 1 | 0;
                        return menhir_run7
                                (counter$5,menhir_env$0,menhir_stack,_jk_,v,_jj_)}
                      return caml_trampoline_return
                              (menhir_run7,[0,menhir_env$0,menhir_stack,_jk_,v,_jj_]);
                     case 2:
                      var v$0=tok[1],_jl_=menhir_env$0[2][11],_jm_=19;
                      if(counter < 50)
                       {var counter$1=counter + 1 | 0;
                        return menhir_run11
                                (counter$1,menhir_env$0,menhir_stack,_jm_,v$0,_jl_)}
                      return caml_trampoline_return
                              (menhir_run11,[0,menhir_env$0,menhir_stack,_jm_,v$0,_jl_])
                     }
                  if(menhir_env$0[4])throw [0,Assert_failure,_by_];
                  menhir_env$0[4] = 1;
                  return menhir_errorcase(menhir_env$0,menhir_stack,19)},
               menhir_run29=
                function(counter,menhir_env,menhir_stack)
                 {var
                   menhir_env$0=menhir_discard(menhir_env),
                   tok=menhir_env$0[3];
                  if(typeof tok === "number")
                   switch(tok)
                    {case 6:
                      var _i7_=23;
                      if(counter < 50)
                       {var counter$6=counter + 1 | 0;
                        return menhir_run6(counter$6,menhir_env$0,menhir_stack,_i7_)}
                      return caml_trampoline_return
                              (menhir_run6,[0,menhir_env$0,menhir_stack,_i7_]);
                     case 9:
                      var _i8_=23;
                      if(counter < 50)
                       {var counter$4=counter + 1 | 0;
                        return menhir_run8(counter$4,menhir_env$0,menhir_stack,_i8_)}
                      return caml_trampoline_return
                              (menhir_run8,[0,menhir_env$0,menhir_stack,_i8_]);
                     case 12:
                      var _i9_=23;
                      if(counter < 50)
                       {var counter$3=counter + 1 | 0;
                        return menhir_run9(counter$3,menhir_env$0,menhir_stack,_i9_)}
                      return caml_trampoline_return
                              (menhir_run9,[0,menhir_env$0,menhir_stack,_i9_]);
                     case 14:
                      var _i__=23;
                      if(counter < 50)
                       {var counter$2=counter + 1 | 0;
                        return menhir_run10
                                (counter$2,menhir_env$0,menhir_stack,_i__)}
                      return caml_trampoline_return
                              (menhir_run10,[0,menhir_env$0,menhir_stack,_i__]);
                     case 20:
                      var _i$_=23;
                      if(counter < 50)
                       {var counter$0=counter + 1 | 0;
                        return menhir_run12
                                (counter$0,menhir_env$0,menhir_stack,_i$_)}
                      return caml_trampoline_return
                              (menhir_run12,[0,menhir_env$0,menhir_stack,_i$_])
                     }
                  else
                   switch(tok[0])
                    {case 1:
                      var v=tok[1],_ja_=menhir_env$0[2][11],_jb_=23;
                      if(counter < 50)
                       {var counter$5=counter + 1 | 0;
                        return menhir_run7
                                (counter$5,menhir_env$0,menhir_stack,_jb_,v,_ja_)}
                      return caml_trampoline_return
                              (menhir_run7,[0,menhir_env$0,menhir_stack,_jb_,v,_ja_]);
                     case 2:
                      var v$0=tok[1],_jc_=menhir_env$0[2][11],_jd_=23;
                      if(counter < 50)
                       {var counter$1=counter + 1 | 0;
                        return menhir_run11
                                (counter$1,menhir_env$0,menhir_stack,_jd_,v$0,_jc_)}
                      return caml_trampoline_return
                              (menhir_run11,[0,menhir_env$0,menhir_stack,_jd_,v$0,_jc_])
                     }
                  if(menhir_env$0[4])throw [0,Assert_failure,_bz_];
                  menhir_env$0[4] = 1;
                  return menhir_errorcase(menhir_env$0,menhir_stack,23)},
               menhir_run23=
                function(counter,menhir_env,menhir_stack)
                 {var
                   menhir_env$0=menhir_discard(menhir_env),
                   tok=menhir_env$0[3];
                  if(typeof tok === "number")
                   switch(tok)
                    {case 6:
                      var _iY_=26;
                      if(counter < 50)
                       {var counter$6=counter + 1 | 0;
                        return menhir_run6(counter$6,menhir_env$0,menhir_stack,_iY_)}
                      return caml_trampoline_return
                              (menhir_run6,[0,menhir_env$0,menhir_stack,_iY_]);
                     case 9:
                      var _iZ_=26;
                      if(counter < 50)
                       {var counter$4=counter + 1 | 0;
                        return menhir_run8(counter$4,menhir_env$0,menhir_stack,_iZ_)}
                      return caml_trampoline_return
                              (menhir_run8,[0,menhir_env$0,menhir_stack,_iZ_]);
                     case 12:
                      var _i0_=26;
                      if(counter < 50)
                       {var counter$3=counter + 1 | 0;
                        return menhir_run9(counter$3,menhir_env$0,menhir_stack,_i0_)}
                      return caml_trampoline_return
                              (menhir_run9,[0,menhir_env$0,menhir_stack,_i0_]);
                     case 14:
                      var _i1_=26;
                      if(counter < 50)
                       {var counter$2=counter + 1 | 0;
                        return menhir_run10
                                (counter$2,menhir_env$0,menhir_stack,_i1_)}
                      return caml_trampoline_return
                              (menhir_run10,[0,menhir_env$0,menhir_stack,_i1_]);
                     case 20:
                      var _i2_=26;
                      if(counter < 50)
                       {var counter$0=counter + 1 | 0;
                        return menhir_run12
                                (counter$0,menhir_env$0,menhir_stack,_i2_)}
                      return caml_trampoline_return
                              (menhir_run12,[0,menhir_env$0,menhir_stack,_i2_])
                     }
                  else
                   switch(tok[0])
                    {case 1:
                      var v=tok[1],_i3_=menhir_env$0[2][11],_i4_=26;
                      if(counter < 50)
                       {var counter$5=counter + 1 | 0;
                        return menhir_run7
                                (counter$5,menhir_env$0,menhir_stack,_i4_,v,_i3_)}
                      return caml_trampoline_return
                              (menhir_run7,[0,menhir_env$0,menhir_stack,_i4_,v,_i3_]);
                     case 2:
                      var v$0=tok[1],_i5_=menhir_env$0[2][11],_i6_=26;
                      if(counter < 50)
                       {var counter$1=counter + 1 | 0;
                        return menhir_run11
                                (counter$1,menhir_env$0,menhir_stack,_i6_,v$0,_i5_)}
                      return caml_trampoline_return
                              (menhir_run11,[0,menhir_env$0,menhir_stack,_i6_,v$0,_i5_])
                     }
                  if(menhir_env$0[4])throw [0,Assert_failure,_bA_];
                  menhir_env$0[4] = 1;
                  return menhir_errorcase(menhir_env$0,menhir_stack,26)},
               menhir_run27=
                function(counter,menhir_env,menhir_stack)
                 {var
                   menhir_env$0=menhir_discard(menhir_env),
                   tok=menhir_env$0[3];
                  if(typeof tok === "number")
                   switch(tok)
                    {case 6:
                      var _iP_=24;
                      if(counter < 50)
                       {var counter$6=counter + 1 | 0;
                        return menhir_run6(counter$6,menhir_env$0,menhir_stack,_iP_)}
                      return caml_trampoline_return
                              (menhir_run6,[0,menhir_env$0,menhir_stack,_iP_]);
                     case 9:
                      var _iQ_=24;
                      if(counter < 50)
                       {var counter$4=counter + 1 | 0;
                        return menhir_run8(counter$4,menhir_env$0,menhir_stack,_iQ_)}
                      return caml_trampoline_return
                              (menhir_run8,[0,menhir_env$0,menhir_stack,_iQ_]);
                     case 12:
                      var _iR_=24;
                      if(counter < 50)
                       {var counter$3=counter + 1 | 0;
                        return menhir_run9(counter$3,menhir_env$0,menhir_stack,_iR_)}
                      return caml_trampoline_return
                              (menhir_run9,[0,menhir_env$0,menhir_stack,_iR_]);
                     case 14:
                      var _iS_=24;
                      if(counter < 50)
                       {var counter$2=counter + 1 | 0;
                        return menhir_run10
                                (counter$2,menhir_env$0,menhir_stack,_iS_)}
                      return caml_trampoline_return
                              (menhir_run10,[0,menhir_env$0,menhir_stack,_iS_]);
                     case 20:
                      var _iT_=24;
                      if(counter < 50)
                       {var counter$0=counter + 1 | 0;
                        return menhir_run12
                                (counter$0,menhir_env$0,menhir_stack,_iT_)}
                      return caml_trampoline_return
                              (menhir_run12,[0,menhir_env$0,menhir_stack,_iT_])
                     }
                  else
                   switch(tok[0])
                    {case 1:
                      var v=tok[1],_iU_=menhir_env$0[2][11],_iV_=24;
                      if(counter < 50)
                       {var counter$5=counter + 1 | 0;
                        return menhir_run7
                                (counter$5,menhir_env$0,menhir_stack,_iV_,v,_iU_)}
                      return caml_trampoline_return
                              (menhir_run7,[0,menhir_env$0,menhir_stack,_iV_,v,_iU_]);
                     case 2:
                      var v$0=tok[1],_iW_=menhir_env$0[2][11],_iX_=24;
                      if(counter < 50)
                       {var counter$1=counter + 1 | 0;
                        return menhir_run11
                                (counter$1,menhir_env$0,menhir_stack,_iX_,v$0,_iW_)}
                      return caml_trampoline_return
                              (menhir_run11,[0,menhir_env$0,menhir_stack,_iX_,v$0,_iW_])
                     }
                  if(menhir_env$0[4])throw [0,Assert_failure,_bB_];
                  menhir_env$0[4] = 1;
                  return menhir_errorcase(menhir_env$0,menhir_stack,24)},
               menhir_run31=
                function(counter,menhir_env,menhir_stack)
                 {var
                   menhir_env$0=menhir_discard(menhir_env),
                   tok=menhir_env$0[3];
                  if(typeof tok === "number")
                   switch(tok)
                    {case 6:
                      var _iG_=22;
                      if(counter < 50)
                       {var counter$6=counter + 1 | 0;
                        return menhir_run6(counter$6,menhir_env$0,menhir_stack,_iG_)}
                      return caml_trampoline_return
                              (menhir_run6,[0,menhir_env$0,menhir_stack,_iG_]);
                     case 9:
                      var _iH_=22;
                      if(counter < 50)
                       {var counter$4=counter + 1 | 0;
                        return menhir_run8(counter$4,menhir_env$0,menhir_stack,_iH_)}
                      return caml_trampoline_return
                              (menhir_run8,[0,menhir_env$0,menhir_stack,_iH_]);
                     case 12:
                      var _iI_=22;
                      if(counter < 50)
                       {var counter$3=counter + 1 | 0;
                        return menhir_run9(counter$3,menhir_env$0,menhir_stack,_iI_)}
                      return caml_trampoline_return
                              (menhir_run9,[0,menhir_env$0,menhir_stack,_iI_]);
                     case 14:
                      var _iJ_=22;
                      if(counter < 50)
                       {var counter$2=counter + 1 | 0;
                        return menhir_run10
                                (counter$2,menhir_env$0,menhir_stack,_iJ_)}
                      return caml_trampoline_return
                              (menhir_run10,[0,menhir_env$0,menhir_stack,_iJ_]);
                     case 20:
                      var _iK_=22;
                      if(counter < 50)
                       {var counter$0=counter + 1 | 0;
                        return menhir_run12
                                (counter$0,menhir_env$0,menhir_stack,_iK_)}
                      return caml_trampoline_return
                              (menhir_run12,[0,menhir_env$0,menhir_stack,_iK_])
                     }
                  else
                   switch(tok[0])
                    {case 1:
                      var v=tok[1],_iL_=menhir_env$0[2][11],_iM_=22;
                      if(counter < 50)
                       {var counter$5=counter + 1 | 0;
                        return menhir_run7
                                (counter$5,menhir_env$0,menhir_stack,_iM_,v,_iL_)}
                      return caml_trampoline_return
                              (menhir_run7,[0,menhir_env$0,menhir_stack,_iM_,v,_iL_]);
                     case 2:
                      var v$0=tok[1],_iN_=menhir_env$0[2][11],_iO_=22;
                      if(counter < 50)
                       {var counter$1=counter + 1 | 0;
                        return menhir_run11
                                (counter$1,menhir_env$0,menhir_stack,_iO_,v$0,_iN_)}
                      return caml_trampoline_return
                              (menhir_run11,[0,menhir_env$0,menhir_stack,_iO_,v$0,_iN_])
                     }
                  if(menhir_env$0[4])throw [0,Assert_failure,_bC_];
                  menhir_env$0[4] = 1;
                  return menhir_errorcase(menhir_env$0,menhir_stack,22)},
               menhir_run40=
                function(counter,menhir_env,menhir_stack)
                 {var
                   menhir_env$0=menhir_discard(menhir_env),
                   tok=menhir_env$0[3];
                  if(typeof tok === "number")
                   switch(tok)
                    {case 6:
                      var _ix_=18;
                      if(counter < 50)
                       {var counter$6=counter + 1 | 0;
                        return menhir_run6(counter$6,menhir_env$0,menhir_stack,_ix_)}
                      return caml_trampoline_return
                              (menhir_run6,[0,menhir_env$0,menhir_stack,_ix_]);
                     case 9:
                      var _iy_=18;
                      if(counter < 50)
                       {var counter$4=counter + 1 | 0;
                        return menhir_run8(counter$4,menhir_env$0,menhir_stack,_iy_)}
                      return caml_trampoline_return
                              (menhir_run8,[0,menhir_env$0,menhir_stack,_iy_]);
                     case 12:
                      var _iz_=18;
                      if(counter < 50)
                       {var counter$3=counter + 1 | 0;
                        return menhir_run9(counter$3,menhir_env$0,menhir_stack,_iz_)}
                      return caml_trampoline_return
                              (menhir_run9,[0,menhir_env$0,menhir_stack,_iz_]);
                     case 14:
                      var _iA_=18;
                      if(counter < 50)
                       {var counter$2=counter + 1 | 0;
                        return menhir_run10
                                (counter$2,menhir_env$0,menhir_stack,_iA_)}
                      return caml_trampoline_return
                              (menhir_run10,[0,menhir_env$0,menhir_stack,_iA_]);
                     case 20:
                      var _iB_=18;
                      if(counter < 50)
                       {var counter$0=counter + 1 | 0;
                        return menhir_run12
                                (counter$0,menhir_env$0,menhir_stack,_iB_)}
                      return caml_trampoline_return
                              (menhir_run12,[0,menhir_env$0,menhir_stack,_iB_])
                     }
                  else
                   switch(tok[0])
                    {case 1:
                      var v=tok[1],_iC_=menhir_env$0[2][11],_iD_=18;
                      if(counter < 50)
                       {var counter$5=counter + 1 | 0;
                        return menhir_run7
                                (counter$5,menhir_env$0,menhir_stack,_iD_,v,_iC_)}
                      return caml_trampoline_return
                              (menhir_run7,[0,menhir_env$0,menhir_stack,_iD_,v,_iC_]);
                     case 2:
                      var v$0=tok[1],_iE_=menhir_env$0[2][11],_iF_=18;
                      if(counter < 50)
                       {var counter$1=counter + 1 | 0;
                        return menhir_run11
                                (counter$1,menhir_env$0,menhir_stack,_iF_,v$0,_iE_)}
                      return caml_trampoline_return
                              (menhir_run11,[0,menhir_env$0,menhir_stack,_iF_,v$0,_iE_])
                     }
                  if(menhir_env$0[4])throw [0,Assert_failure,_bD_];
                  menhir_env$0[4] = 1;
                  return menhir_errorcase(menhir_env$0,menhir_stack,18)},
               menhir_run33=
                function(counter,menhir_env,menhir_stack)
                 {var
                   menhir_env$0=menhir_discard(menhir_env),
                   tok=menhir_env$0[3];
                  if(typeof tok === "number")
                   switch(tok)
                    {case 6:
                      var _io_=21;
                      if(counter < 50)
                       {var counter$6=counter + 1 | 0;
                        return menhir_run6(counter$6,menhir_env$0,menhir_stack,_io_)}
                      return caml_trampoline_return
                              (menhir_run6,[0,menhir_env$0,menhir_stack,_io_]);
                     case 9:
                      var _ip_=21;
                      if(counter < 50)
                       {var counter$4=counter + 1 | 0;
                        return menhir_run8(counter$4,menhir_env$0,menhir_stack,_ip_)}
                      return caml_trampoline_return
                              (menhir_run8,[0,menhir_env$0,menhir_stack,_ip_]);
                     case 12:
                      var _iq_=21;
                      if(counter < 50)
                       {var counter$3=counter + 1 | 0;
                        return menhir_run9(counter$3,menhir_env$0,menhir_stack,_iq_)}
                      return caml_trampoline_return
                              (menhir_run9,[0,menhir_env$0,menhir_stack,_iq_]);
                     case 14:
                      var _ir_=21;
                      if(counter < 50)
                       {var counter$2=counter + 1 | 0;
                        return menhir_run10
                                (counter$2,menhir_env$0,menhir_stack,_ir_)}
                      return caml_trampoline_return
                              (menhir_run10,[0,menhir_env$0,menhir_stack,_ir_]);
                     case 20:
                      var _is_=21;
                      if(counter < 50)
                       {var counter$0=counter + 1 | 0;
                        return menhir_run12
                                (counter$0,menhir_env$0,menhir_stack,_is_)}
                      return caml_trampoline_return
                              (menhir_run12,[0,menhir_env$0,menhir_stack,_is_])
                     }
                  else
                   switch(tok[0])
                    {case 1:
                      var v=tok[1],_it_=menhir_env$0[2][11],_iu_=21;
                      if(counter < 50)
                       {var counter$5=counter + 1 | 0;
                        return menhir_run7
                                (counter$5,menhir_env$0,menhir_stack,_iu_,v,_it_)}
                      return caml_trampoline_return
                              (menhir_run7,[0,menhir_env$0,menhir_stack,_iu_,v,_it_]);
                     case 2:
                      var v$0=tok[1],_iv_=menhir_env$0[2][11],_iw_=21;
                      if(counter < 50)
                       {var counter$1=counter + 1 | 0;
                        return menhir_run11
                                (counter$1,menhir_env$0,menhir_stack,_iw_,v$0,_iv_)}
                      return caml_trampoline_return
                              (menhir_run11,[0,menhir_env$0,menhir_stack,_iw_,v$0,_iv_])
                     }
                  if(menhir_env$0[4])throw [0,Assert_failure,_bE_];
                  menhir_env$0[4] = 1;
                  return menhir_errorcase(menhir_env$0,menhir_stack,21)},
               menhir_run25=
                function(counter,menhir_env,menhir_stack)
                 {var
                   menhir_env$0=menhir_discard(menhir_env),
                   tok=menhir_env$0[3];
                  if(typeof tok === "number")
                   switch(tok)
                    {case 6:
                      var _if_=25;
                      if(counter < 50)
                       {var counter$6=counter + 1 | 0;
                        return menhir_run6(counter$6,menhir_env$0,menhir_stack,_if_)}
                      return caml_trampoline_return
                              (menhir_run6,[0,menhir_env$0,menhir_stack,_if_]);
                     case 9:
                      var _ig_=25;
                      if(counter < 50)
                       {var counter$4=counter + 1 | 0;
                        return menhir_run8(counter$4,menhir_env$0,menhir_stack,_ig_)}
                      return caml_trampoline_return
                              (menhir_run8,[0,menhir_env$0,menhir_stack,_ig_]);
                     case 12:
                      var _ih_=25;
                      if(counter < 50)
                       {var counter$3=counter + 1 | 0;
                        return menhir_run9(counter$3,menhir_env$0,menhir_stack,_ih_)}
                      return caml_trampoline_return
                              (menhir_run9,[0,menhir_env$0,menhir_stack,_ih_]);
                     case 14:
                      var _ii_=25;
                      if(counter < 50)
                       {var counter$2=counter + 1 | 0;
                        return menhir_run10
                                (counter$2,menhir_env$0,menhir_stack,_ii_)}
                      return caml_trampoline_return
                              (menhir_run10,[0,menhir_env$0,menhir_stack,_ii_]);
                     case 20:
                      var _ij_=25;
                      if(counter < 50)
                       {var counter$0=counter + 1 | 0;
                        return menhir_run12
                                (counter$0,menhir_env$0,menhir_stack,_ij_)}
                      return caml_trampoline_return
                              (menhir_run12,[0,menhir_env$0,menhir_stack,_ij_])
                     }
                  else
                   switch(tok[0])
                    {case 1:
                      var v=tok[1],_ik_=menhir_env$0[2][11],_il_=25;
                      if(counter < 50)
                       {var counter$5=counter + 1 | 0;
                        return menhir_run7
                                (counter$5,menhir_env$0,menhir_stack,_il_,v,_ik_)}
                      return caml_trampoline_return
                              (menhir_run7,[0,menhir_env$0,menhir_stack,_il_,v,_ik_]);
                     case 2:
                      var v$0=tok[1],_im_=menhir_env$0[2][11],_in_=25;
                      if(counter < 50)
                       {var counter$1=counter + 1 | 0;
                        return menhir_run11
                                (counter$1,menhir_env$0,menhir_stack,_in_,v$0,_im_)}
                      return caml_trampoline_return
                              (menhir_run11,[0,menhir_env$0,menhir_stack,_in_,v$0,_im_])
                     }
                  if(menhir_env$0[4])throw [0,Assert_failure,_bF_];
                  menhir_env$0[4] = 1;
                  return menhir_errorcase(menhir_env$0,menhir_stack,25)},
               menhir_run44=
                function(counter,menhir_env,menhir_stack)
                 {var
                   menhir_env$0=menhir_discard(menhir_env),
                   tok=menhir_env$0[3];
                  if(typeof tok === "number")
                   switch(tok)
                    {case 6:
                      var _h8_=16;
                      if(counter < 50)
                       {var counter$6=counter + 1 | 0;
                        return menhir_run6(counter$6,menhir_env$0,menhir_stack,_h8_)}
                      return caml_trampoline_return
                              (menhir_run6,[0,menhir_env$0,menhir_stack,_h8_]);
                     case 9:
                      var _h9_=16;
                      if(counter < 50)
                       {var counter$4=counter + 1 | 0;
                        return menhir_run8(counter$4,menhir_env$0,menhir_stack,_h9_)}
                      return caml_trampoline_return
                              (menhir_run8,[0,menhir_env$0,menhir_stack,_h9_]);
                     case 12:
                      var _h__=16;
                      if(counter < 50)
                       {var counter$3=counter + 1 | 0;
                        return menhir_run9(counter$3,menhir_env$0,menhir_stack,_h__)}
                      return caml_trampoline_return
                              (menhir_run9,[0,menhir_env$0,menhir_stack,_h__]);
                     case 14:
                      var _h$_=16;
                      if(counter < 50)
                       {var counter$2=counter + 1 | 0;
                        return menhir_run10
                                (counter$2,menhir_env$0,menhir_stack,_h$_)}
                      return caml_trampoline_return
                              (menhir_run10,[0,menhir_env$0,menhir_stack,_h$_]);
                     case 20:
                      var _ia_=16;
                      if(counter < 50)
                       {var counter$0=counter + 1 | 0;
                        return menhir_run12
                                (counter$0,menhir_env$0,menhir_stack,_ia_)}
                      return caml_trampoline_return
                              (menhir_run12,[0,menhir_env$0,menhir_stack,_ia_])
                     }
                  else
                   switch(tok[0])
                    {case 1:
                      var v=tok[1],_ib_=menhir_env$0[2][11],_ic_=16;
                      if(counter < 50)
                       {var counter$5=counter + 1 | 0;
                        return menhir_run7
                                (counter$5,menhir_env$0,menhir_stack,_ic_,v,_ib_)}
                      return caml_trampoline_return
                              (menhir_run7,[0,menhir_env$0,menhir_stack,_ic_,v,_ib_]);
                     case 2:
                      var v$0=tok[1],_id_=menhir_env$0[2][11],_ie_=16;
                      if(counter < 50)
                       {var counter$1=counter + 1 | 0;
                        return menhir_run11
                                (counter$1,menhir_env$0,menhir_stack,_ie_,v$0,_id_)}
                      return caml_trampoline_return
                              (menhir_run11,[0,menhir_env$0,menhir_stack,_ie_,v$0,_id_])
                     }
                  if(menhir_env$0[4])throw [0,Assert_failure,_bG_];
                  menhir_env$0[4] = 1;
                  return menhir_errorcase(menhir_env$0,menhir_stack,16)},
               menhir_run46=
                function(counter,menhir_env,menhir_stack)
                 {var
                   menhir_env$0=menhir_discard(menhir_env),
                   tok=menhir_env$0[3];
                  if(typeof tok === "number")
                   switch(tok)
                    {case 6:
                      var _hZ_=15;
                      if(counter < 50)
                       {var counter$6=counter + 1 | 0;
                        return menhir_run6(counter$6,menhir_env$0,menhir_stack,_hZ_)}
                      return caml_trampoline_return
                              (menhir_run6,[0,menhir_env$0,menhir_stack,_hZ_]);
                     case 9:
                      var _h0_=15;
                      if(counter < 50)
                       {var counter$4=counter + 1 | 0;
                        return menhir_run8(counter$4,menhir_env$0,menhir_stack,_h0_)}
                      return caml_trampoline_return
                              (menhir_run8,[0,menhir_env$0,menhir_stack,_h0_]);
                     case 12:
                      var _h1_=15;
                      if(counter < 50)
                       {var counter$3=counter + 1 | 0;
                        return menhir_run9(counter$3,menhir_env$0,menhir_stack,_h1_)}
                      return caml_trampoline_return
                              (menhir_run9,[0,menhir_env$0,menhir_stack,_h1_]);
                     case 14:
                      var _h2_=15;
                      if(counter < 50)
                       {var counter$2=counter + 1 | 0;
                        return menhir_run10
                                (counter$2,menhir_env$0,menhir_stack,_h2_)}
                      return caml_trampoline_return
                              (menhir_run10,[0,menhir_env$0,menhir_stack,_h2_]);
                     case 20:
                      var _h3_=15;
                      if(counter < 50)
                       {var counter$0=counter + 1 | 0;
                        return menhir_run12
                                (counter$0,menhir_env$0,menhir_stack,_h3_)}
                      return caml_trampoline_return
                              (menhir_run12,[0,menhir_env$0,menhir_stack,_h3_])
                     }
                  else
                   switch(tok[0])
                    {case 1:
                      var v=tok[1],_h4_=menhir_env$0[2][11],_h5_=15;
                      if(counter < 50)
                       {var counter$5=counter + 1 | 0;
                        return menhir_run7
                                (counter$5,menhir_env$0,menhir_stack,_h5_,v,_h4_)}
                      return caml_trampoline_return
                              (menhir_run7,[0,menhir_env$0,menhir_stack,_h5_,v,_h4_]);
                     case 2:
                      var v$0=tok[1],_h6_=menhir_env$0[2][11],_h7_=15;
                      if(counter < 50)
                       {var counter$1=counter + 1 | 0;
                        return menhir_run11
                                (counter$1,menhir_env$0,menhir_stack,_h7_,v$0,_h6_)}
                      return caml_trampoline_return
                              (menhir_run11,[0,menhir_env$0,menhir_stack,_h7_,v$0,_h6_])
                     }
                  if(menhir_env$0[4])throw [0,Assert_failure,_bH_];
                  menhir_env$0[4] = 1;
                  return menhir_errorcase(menhir_env$0,menhir_stack,15)},
               menhir_run35=
                function(counter,menhir_env,menhir_stack)
                 {var
                   menhir_env$0=menhir_discard(menhir_env),
                   tok=menhir_env$0[3];
                  if(typeof tok === "number")
                   switch(tok)
                    {case 6:
                      var _hQ_=20;
                      if(counter < 50)
                       {var counter$6=counter + 1 | 0;
                        return menhir_run6(counter$6,menhir_env$0,menhir_stack,_hQ_)}
                      return caml_trampoline_return
                              (menhir_run6,[0,menhir_env$0,menhir_stack,_hQ_]);
                     case 9:
                      var _hR_=20;
                      if(counter < 50)
                       {var counter$4=counter + 1 | 0;
                        return menhir_run8(counter$4,menhir_env$0,menhir_stack,_hR_)}
                      return caml_trampoline_return
                              (menhir_run8,[0,menhir_env$0,menhir_stack,_hR_]);
                     case 12:
                      var _hS_=20;
                      if(counter < 50)
                       {var counter$3=counter + 1 | 0;
                        return menhir_run9(counter$3,menhir_env$0,menhir_stack,_hS_)}
                      return caml_trampoline_return
                              (menhir_run9,[0,menhir_env$0,menhir_stack,_hS_]);
                     case 14:
                      var _hT_=20;
                      if(counter < 50)
                       {var counter$2=counter + 1 | 0;
                        return menhir_run10
                                (counter$2,menhir_env$0,menhir_stack,_hT_)}
                      return caml_trampoline_return
                              (menhir_run10,[0,menhir_env$0,menhir_stack,_hT_]);
                     case 20:
                      var _hU_=20;
                      if(counter < 50)
                       {var counter$0=counter + 1 | 0;
                        return menhir_run12
                                (counter$0,menhir_env$0,menhir_stack,_hU_)}
                      return caml_trampoline_return
                              (menhir_run12,[0,menhir_env$0,menhir_stack,_hU_])
                     }
                  else
                   switch(tok[0])
                    {case 1:
                      var v=tok[1],_hV_=menhir_env$0[2][11],_hW_=20;
                      if(counter < 50)
                       {var counter$5=counter + 1 | 0;
                        return menhir_run7
                                (counter$5,menhir_env$0,menhir_stack,_hW_,v,_hV_)}
                      return caml_trampoline_return
                              (menhir_run7,[0,menhir_env$0,menhir_stack,_hW_,v,_hV_]);
                     case 2:
                      var v$0=tok[1],_hX_=menhir_env$0[2][11],_hY_=20;
                      if(counter < 50)
                       {var counter$1=counter + 1 | 0;
                        return menhir_run11
                                (counter$1,menhir_env$0,menhir_stack,_hY_,v$0,_hX_)}
                      return caml_trampoline_return
                              (menhir_run11,[0,menhir_env$0,menhir_stack,_hY_,v$0,_hX_])
                     }
                  if(menhir_env$0[4])throw [0,Assert_failure,_bI_];
                  menhir_env$0[4] = 1;
                  return menhir_errorcase(menhir_env$0,menhir_stack,20)},
               menhir_goto_offset=
                function(counter,menhir_env,menhir_stack,menhir_s,o)
                 {if(7 === menhir_s)
                   {if(menhir_env[4])throw [0,Assert_failure,_bJ_];
                    var tok=menhir_env[3];
                    if(typeof tok === "number" && 4 === tok)
                     {var
                       menhir_env$0=menhir_discard(menhir_env),
                       tok$0=menhir_env$0[3];
                      if(typeof tok$0 === "number" && 17 <= tok$0)
                       {var switcher=tok$0 - 17 | 0;
                        switch(switcher)
                         {case 3:
                           var
                            menhir_env$1=menhir_discard(menhir_env$0),
                            id$0=menhir_stack[2],
                            match$0=menhir_stack[1],
                            menhir_s$1=match$0[2],
                            menhir_stack$1=match$0[1],
                            v$0=[2,id$0,o,1];
                           if(counter < 50)
                            {var counter$1=counter + 1 | 0;
                             return menhir_goto_arg
                                     (counter$1,menhir_env$1,menhir_stack$1,menhir_s$1,v$0)}
                           return caml_trampoline_return
                                   (menhir_goto_arg,
                                    [0,menhir_env$1,menhir_stack$1,menhir_s$1,v$0]);
                          case 0:
                          case 6:
                          case 7:
                          case 9:
                           var
                            id=menhir_stack[2],
                            match=menhir_stack[1],
                            menhir_s$0=match[2],
                            menhir_stack$0=match[1],
                            v=[2,id,o,0];
                           if(counter < 50)
                            {var counter$2=counter + 1 | 0;
                             return menhir_goto_arg
                                     (counter$2,menhir_env$0,menhir_stack$0,menhir_s$0,v)}
                           return caml_trampoline_return
                                   (menhir_goto_arg,
                                    [0,menhir_env$0,menhir_stack$0,menhir_s$0,v])
                          }}
                      if(menhir_env$0[4])throw [0,Assert_failure,_bK_];
                      menhir_env$0[4] = 1;
                      return menhir_errorcase(menhir_env$0,menhir_stack,menhir_s)}
                    if(menhir_env[4])throw [0,Assert_failure,_bL_];
                    menhir_env[4] = 1;
                    return menhir_errorcase(menhir_env,menhir_stack,menhir_s)}
                  if(13 === menhir_s)
                   {var
                     id$1=menhir_stack[2],
                     match$1=menhir_stack[1],
                     menhir_s$2=match$1[2],
                     menhir_stack$2=match$1[1],
                     v$1=[2,id$1,o,2];
                    if(counter < 50)
                     {var counter$0=counter + 1 | 0;
                      return menhir_goto_arg
                              (counter$0,menhir_env,menhir_stack$2,menhir_s$2,v$1)}
                    return caml_trampoline_return
                            (menhir_goto_arg,
                             [0,menhir_env,menhir_stack$2,menhir_s$2,v$1])}
                  return menhir_fail(0)},
               menhir_goto_meta_expr=
                function(counter,menhir_env,menhir_stack,menhir_s,v)
                 {var
                   menhir_env$0=menhir_env,
                   menhir_stack$0=menhir_stack,
                   menhir_s$0=menhir_s,
                   v$0=v;
                  for(;;)
                   {var menhir_stack$1=[0,menhir_stack$0,menhir_s$0,v$0];
                    switch(menhir_s$0)
                     {case 1:
                       if(menhir_env$0[4])throw [0,Assert_failure,_bM_];
                       var tok=menhir_env$0[3];
                       if(typeof tok === "number")
                        switch(tok)
                         {case 0:
                           if(counter < 50)
                            {var counter$176=counter + 1 | 0;
                             return menhir_run15(counter$176,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run15,[0,menhir_env$0,menhir_stack$1]);
                          case 1:
                           if(counter < 50)
                            {var counter$159=counter + 1 | 0;
                             return menhir_run17(counter$159,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run17,[0,menhir_env$0,menhir_stack$1]);
                          case 2:
                           if(counter < 50)
                            {var counter$146=counter + 1 | 0;
                             return menhir_run19(counter$146,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run19,[0,menhir_env$0,menhir_stack$1]);
                          case 6:
                           if(counter < 50)
                            {var counter$131=counter + 1 | 0;
                             return menhir_run21(counter$131,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run21,[0,menhir_env$0,menhir_stack$1]);
                          case 7:
                           if(counter < 50)
                            {var counter$123=counter + 1 | 0;
                             return menhir_run38(counter$123,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run38,[0,menhir_env$0,menhir_stack$1]);
                          case 10:
                           if(counter < 50)
                            {var counter$112=counter + 1 | 0;
                             return menhir_run29(counter$112,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run29,[0,menhir_env$0,menhir_stack$1]);
                          case 11:
                           if(counter < 50)
                            {var counter$95=counter + 1 | 0;
                             return menhir_run23(counter$95,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run23,[0,menhir_env$0,menhir_stack$1]);
                          case 12:
                           if(counter < 50)
                            {var counter$80=counter + 1 | 0;
                             return menhir_run27(counter$80,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run27,[0,menhir_env$0,menhir_stack$1]);
                          case 13:
                           if(counter < 50)
                            {var counter$67=counter + 1 | 0;
                             return menhir_run31(counter$67,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run31,[0,menhir_env$0,menhir_stack$1]);
                          case 17:
                           if(counter < 50)
                            {var counter$61=counter + 1 | 0;
                             return menhir_run40(counter$61,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run40,[0,menhir_env$0,menhir_stack$1]);
                          case 22:
                           if(counter < 50)
                            {var counter$50=counter + 1 | 0;
                             return menhir_run33(counter$50,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run33,[0,menhir_env$0,menhir_stack$1]);
                          case 23:
                           var
                            e=menhir_stack$1[3],
                            match=menhir_stack$1[1],
                            id=match[2],
                            menhir_stack$3=match[1],
                            v$1=[1,id,0,e];
                           if(counter < 50)
                            {var counter$0=counter + 1 | 0;
                             return menhir_goto_definition
                                     (counter$0,menhir_env$0,menhir_stack$3,v$1)}
                           return caml_trampoline_return
                                   (menhir_goto_definition,[0,menhir_env$0,menhir_stack$3,v$1]);
                          case 25:
                           if(counter < 50)
                            {var counter$33=counter + 1 | 0;
                             return menhir_run25(counter$33,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run25,[0,menhir_env$0,menhir_stack$1]);
                          case 28:
                           if(counter < 50)
                            {var counter$27=counter + 1 | 0;
                             return menhir_run44(counter$27,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run44,[0,menhir_env$0,menhir_stack$1]);
                          case 29:
                           if(counter < 50)
                            {var counter$20=counter + 1 | 0;
                             return menhir_run46(counter$20,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run46,[0,menhir_env$0,menhir_stack$1]);
                          case 30:
                           if(counter < 50)
                            {var counter$10=counter + 1 | 0;
                             return menhir_run35(counter$10,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run35,[0,menhir_env$0,menhir_stack$1])
                          }
                       if(menhir_env$0[4])throw [0,Assert_failure,_bN_];
                       menhir_env$0[4] = 1;
                       var
                        menhir_s$1=menhir_stack$1[2],
                        menhir_stack$2=menhir_stack$1[1];
                       return menhir_errorcase
                               (menhir_env$0,menhir_stack$2,menhir_s$1);
                      case 2:
                       if(menhir_env$0[4])throw [0,Assert_failure,_bO_];
                       var tok$0=menhir_env$0[3];
                       if(typeof tok$0 === "number")
                        switch(tok$0)
                         {case 0:
                           if(counter < 50)
                            {var counter$177=counter + 1 | 0;
                             return menhir_run15(counter$177,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run15,[0,menhir_env$0,menhir_stack$1]);
                          case 1:
                           if(counter < 50)
                            {var counter$160=counter + 1 | 0;
                             return menhir_run17(counter$160,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run17,[0,menhir_env$0,menhir_stack$1]);
                          case 2:
                           if(counter < 50)
                            {var counter$147=counter + 1 | 0;
                             return menhir_run19(counter$147,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run19,[0,menhir_env$0,menhir_stack$1]);
                          case 6:
                           if(counter < 50)
                            {var counter$132=counter + 1 | 0;
                             return menhir_run21(counter$132,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run21,[0,menhir_env$0,menhir_stack$1]);
                          case 7:
                           if(counter < 50)
                            {var counter$124=counter + 1 | 0;
                             return menhir_run38(counter$124,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run38,[0,menhir_env$0,menhir_stack$1]);
                          case 10:
                           if(counter < 50)
                            {var counter$113=counter + 1 | 0;
                             return menhir_run29(counter$113,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run29,[0,menhir_env$0,menhir_stack$1]);
                          case 11:
                           if(counter < 50)
                            {var counter$96=counter + 1 | 0;
                             return menhir_run23(counter$96,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run23,[0,menhir_env$0,menhir_stack$1]);
                          case 12:
                           if(counter < 50)
                            {var counter$81=counter + 1 | 0;
                             return menhir_run27(counter$81,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run27,[0,menhir_env$0,menhir_stack$1]);
                          case 13:
                           if(counter < 50)
                            {var counter$68=counter + 1 | 0;
                             return menhir_run31(counter$68,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run31,[0,menhir_env$0,menhir_stack$1]);
                          case 17:
                           if(counter < 50)
                            {var counter$62=counter + 1 | 0;
                             return menhir_run40(counter$62,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run40,[0,menhir_env$0,menhir_stack$1]);
                          case 22:
                           if(counter < 50)
                            {var counter$51=counter + 1 | 0;
                             return menhir_run33(counter$51,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run33,[0,menhir_env$0,menhir_stack$1]);
                          case 23:
                           var
                            e$0=menhir_stack$1[3],
                            match$0=menhir_stack$1[1],
                            id$0=match$0[2],
                            menhir_stack$5=match$0[1],
                            v$2=[1,id$0,1,e$0];
                           if(counter < 50)
                            {var counter$1=counter + 1 | 0;
                             return menhir_goto_definition
                                     (counter$1,menhir_env$0,menhir_stack$5,v$2)}
                           return caml_trampoline_return
                                   (menhir_goto_definition,[0,menhir_env$0,menhir_stack$5,v$2]);
                          case 25:
                           if(counter < 50)
                            {var counter$34=counter + 1 | 0;
                             return menhir_run25(counter$34,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run25,[0,menhir_env$0,menhir_stack$1]);
                          case 28:
                           if(counter < 50)
                            {var counter$28=counter + 1 | 0;
                             return menhir_run44(counter$28,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run44,[0,menhir_env$0,menhir_stack$1]);
                          case 29:
                           if(counter < 50)
                            {var counter$21=counter + 1 | 0;
                             return menhir_run46(counter$21,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run46,[0,menhir_env$0,menhir_stack$1]);
                          case 30:
                           if(counter < 50)
                            {var counter$11=counter + 1 | 0;
                             return menhir_run35(counter$11,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run35,[0,menhir_env$0,menhir_stack$1])
                          }
                       if(menhir_env$0[4])throw [0,Assert_failure,_bP_];
                       menhir_env$0[4] = 1;
                       var
                        menhir_s$2=menhir_stack$1[2],
                        menhir_stack$4=menhir_stack$1[1];
                       return menhir_errorcase
                               (menhir_env$0,menhir_stack$4,menhir_s$2);
                      case 15:
                       if(menhir_env$0[4])throw [0,Assert_failure,_bQ_];
                       var tok$1=menhir_env$0[3];
                       if(typeof tok$1 === "number")
                        switch(tok$1)
                         {case 0:
                           if(counter < 50)
                            {var counter$178=counter + 1 | 0;
                             return menhir_run15(counter$178,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run15,[0,menhir_env$0,menhir_stack$1]);
                          case 1:
                           if(counter < 50)
                            {var counter$161=counter + 1 | 0;
                             return menhir_run17(counter$161,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run17,[0,menhir_env$0,menhir_stack$1]);
                          case 2:
                           if(counter < 50)
                            {var counter$148=counter + 1 | 0;
                             return menhir_run19(counter$148,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run19,[0,menhir_env$0,menhir_stack$1]);
                          case 6:
                           if(counter < 50)
                            {var counter$133=counter + 1 | 0;
                             return menhir_run21(counter$133,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run21,[0,menhir_env$0,menhir_stack$1]);
                          case 7:
                           if(counter < 50)
                            {var counter$125=counter + 1 | 0;
                             return menhir_run38(counter$125,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run38,[0,menhir_env$0,menhir_stack$1]);
                          case 10:
                           if(counter < 50)
                            {var counter$114=counter + 1 | 0;
                             return menhir_run29(counter$114,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run29,[0,menhir_env$0,menhir_stack$1]);
                          case 11:
                           if(counter < 50)
                            {var counter$97=counter + 1 | 0;
                             return menhir_run23(counter$97,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run23,[0,menhir_env$0,menhir_stack$1]);
                          case 12:
                           if(counter < 50)
                            {var counter$82=counter + 1 | 0;
                             return menhir_run27(counter$82,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run27,[0,menhir_env$0,menhir_stack$1]);
                          case 13:
                           if(counter < 50)
                            {var counter$69=counter + 1 | 0;
                             return menhir_run31(counter$69,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run31,[0,menhir_env$0,menhir_stack$1]);
                          case 22:
                           if(counter < 50)
                            {var counter$52=counter + 1 | 0;
                             return menhir_run33(counter$52,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run33,[0,menhir_env$0,menhir_stack$1]);
                          case 25:
                           if(counter < 50)
                            {var counter$35=counter + 1 | 0;
                             return menhir_run25(counter$35,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run25,[0,menhir_env$0,menhir_stack$1]);
                          case 30:
                           if(counter < 50)
                            {var counter$12=counter + 1 | 0;
                             return menhir_run35(counter$12,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run35,[0,menhir_env$0,menhir_stack$1]);
                          case 3:
                          case 5:
                          case 17:
                          case 23:
                          case 27:
                          case 28:
                          case 29:
                           var
                            e2=menhir_stack$1[3],
                            match$1=menhir_stack$1[1],
                            e1=match$1[3],
                            menhir_s$3=match$1[2],
                            menhir_stack$6=match$1[1],
                            v$3=[1,13,e1,e2],
                            menhir_stack$0=menhir_stack$6,
                            menhir_s$0=menhir_s$3,
                            v$0=v$3;
                           continue
                          }
                       if(menhir_env$0[4])throw [0,Assert_failure,_bR_];
                       menhir_env$0[4] = 1;
                       var
                        menhir_s$4=menhir_stack$1[2],
                        menhir_stack$7=menhir_stack$1[1];
                       return menhir_errorcase
                               (menhir_env$0,menhir_stack$7,menhir_s$4);
                      case 16:
                       if(menhir_env$0[4])throw [0,Assert_failure,_bS_];
                       var tok$2=menhir_env$0[3];
                       if(typeof tok$2 === "number")
                        switch(tok$2)
                         {case 0:
                           if(counter < 50)
                            {var counter$179=counter + 1 | 0;
                             return menhir_run15(counter$179,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run15,[0,menhir_env$0,menhir_stack$1]);
                          case 1:
                           if(counter < 50)
                            {var counter$162=counter + 1 | 0;
                             return menhir_run17(counter$162,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run17,[0,menhir_env$0,menhir_stack$1]);
                          case 2:
                           if(counter < 50)
                            {var counter$149=counter + 1 | 0;
                             return menhir_run19(counter$149,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run19,[0,menhir_env$0,menhir_stack$1]);
                          case 6:
                           if(counter < 50)
                            {var counter$134=counter + 1 | 0;
                             return menhir_run21(counter$134,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run21,[0,menhir_env$0,menhir_stack$1]);
                          case 7:
                           if(counter < 50)
                            {var counter$126=counter + 1 | 0;
                             return menhir_run38(counter$126,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run38,[0,menhir_env$0,menhir_stack$1]);
                          case 10:
                           if(counter < 50)
                            {var counter$115=counter + 1 | 0;
                             return menhir_run29(counter$115,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run29,[0,menhir_env$0,menhir_stack$1]);
                          case 11:
                           if(counter < 50)
                            {var counter$98=counter + 1 | 0;
                             return menhir_run23(counter$98,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run23,[0,menhir_env$0,menhir_stack$1]);
                          case 12:
                           if(counter < 50)
                            {var counter$83=counter + 1 | 0;
                             return menhir_run27(counter$83,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run27,[0,menhir_env$0,menhir_stack$1]);
                          case 13:
                           if(counter < 50)
                            {var counter$70=counter + 1 | 0;
                             return menhir_run31(counter$70,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run31,[0,menhir_env$0,menhir_stack$1]);
                          case 22:
                           if(counter < 50)
                            {var counter$53=counter + 1 | 0;
                             return menhir_run33(counter$53,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run33,[0,menhir_env$0,menhir_stack$1]);
                          case 25:
                           if(counter < 50)
                            {var counter$36=counter + 1 | 0;
                             return menhir_run25(counter$36,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run25,[0,menhir_env$0,menhir_stack$1]);
                          case 29:
                           if(counter < 50)
                            {var counter$22=counter + 1 | 0;
                             return menhir_run46(counter$22,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run46,[0,menhir_env$0,menhir_stack$1]);
                          case 30:
                           if(counter < 50)
                            {var counter$13=counter + 1 | 0;
                             return menhir_run35(counter$13,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run35,[0,menhir_env$0,menhir_stack$1]);
                          case 3:
                          case 5:
                          case 17:
                          case 23:
                          case 27:
                          case 28:
                           var
                            e2$0=menhir_stack$1[3],
                            match$2=menhir_stack$1[1],
                            e1$0=match$2[3],
                            menhir_s$5=match$2[2],
                            menhir_stack$8=match$2[1],
                            v$4=[1,12,e1$0,e2$0],
                            menhir_stack$0=menhir_stack$8,
                            menhir_s$0=menhir_s$5,
                            v$0=v$4;
                           continue
                          }
                       if(menhir_env$0[4])throw [0,Assert_failure,_bT_];
                       menhir_env$0[4] = 1;
                       var
                        menhir_s$6=menhir_stack$1[2],
                        menhir_stack$9=menhir_stack$1[1];
                       return menhir_errorcase
                               (menhir_env$0,menhir_stack$9,menhir_s$6);
                      case 17:
                       if(menhir_env$0[4])throw [0,Assert_failure,_bU_];
                       var tok$3=menhir_env$0[3];
                       if(typeof tok$3 === "number")
                        switch(tok$3)
                         {case 0:
                           if(counter < 50)
                            {var counter$180=counter + 1 | 0;
                             return menhir_run15(counter$180,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run15,[0,menhir_env$0,menhir_stack$1]);
                          case 1:
                           if(counter < 50)
                            {var counter$163=counter + 1 | 0;
                             return menhir_run17(counter$163,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run17,[0,menhir_env$0,menhir_stack$1]);
                          case 2:
                           if(counter < 50)
                            {var counter$150=counter + 1 | 0;
                             return menhir_run19(counter$150,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run19,[0,menhir_env$0,menhir_stack$1]);
                          case 6:
                           if(counter < 50)
                            {var counter$135=counter + 1 | 0;
                             return menhir_run21(counter$135,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run21,[0,menhir_env$0,menhir_stack$1]);
                          case 7:
                           if(counter < 50)
                            {var counter$127=counter + 1 | 0;
                             return menhir_run38(counter$127,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run38,[0,menhir_env$0,menhir_stack$1]);
                          case 10:
                           if(counter < 50)
                            {var counter$116=counter + 1 | 0;
                             return menhir_run29(counter$116,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run29,[0,menhir_env$0,menhir_stack$1]);
                          case 11:
                           if(counter < 50)
                            {var counter$99=counter + 1 | 0;
                             return menhir_run23(counter$99,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run23,[0,menhir_env$0,menhir_stack$1]);
                          case 12:
                           if(counter < 50)
                            {var counter$84=counter + 1 | 0;
                             return menhir_run27(counter$84,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run27,[0,menhir_env$0,menhir_stack$1]);
                          case 13:
                           if(counter < 50)
                            {var counter$71=counter + 1 | 0;
                             return menhir_run31(counter$71,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run31,[0,menhir_env$0,menhir_stack$1]);
                          case 17:
                           if(counter < 50)
                            {var counter$63=counter + 1 | 0;
                             return menhir_run40(counter$63,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run40,[0,menhir_env$0,menhir_stack$1]);
                          case 22:
                           if(counter < 50)
                            {var counter$54=counter + 1 | 0;
                             return menhir_run33(counter$54,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run33,[0,menhir_env$0,menhir_stack$1]);
                          case 25:
                           if(counter < 50)
                            {var counter$37=counter + 1 | 0;
                             return menhir_run25(counter$37,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run25,[0,menhir_env$0,menhir_stack$1]);
                          case 28:
                           if(counter < 50)
                            {var counter$29=counter + 1 | 0;
                             return menhir_run44(counter$29,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run44,[0,menhir_env$0,menhir_stack$1]);
                          case 29:
                           if(counter < 50)
                            {var counter$23=counter + 1 | 0;
                             return menhir_run46(counter$23,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run46,[0,menhir_env$0,menhir_stack$1]);
                          case 30:
                           if(counter < 50)
                            {var counter$14=counter + 1 | 0;
                             return menhir_run35(counter$14,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run35,[0,menhir_env$0,menhir_stack$1]);
                          case 3:
                          case 5:
                          case 23:
                          case 27:
                           var
                            e2$1=menhir_stack$1[3],
                            _hG_=menhir_stack$1[1],
                            e1$1=_hG_[3],
                            match$3=_hG_[1],
                            e0=match$3[3],
                            menhir_s$7=match$3[2],
                            menhir_stack$10=match$3[1],
                            v$5=[4,e0,e1$1,e2$1],
                            menhir_stack$0=menhir_stack$10,
                            menhir_s$0=menhir_s$7,
                            v$0=v$5;
                           continue
                          }
                       if(menhir_env$0[4])throw [0,Assert_failure,_bV_];
                       menhir_env$0[4] = 1;
                       var
                        menhir_s$8=menhir_stack$1[2],
                        menhir_stack$11=menhir_stack$1[1];
                       return menhir_errorcase
                               (menhir_env$0,menhir_stack$11,menhir_s$8);
                      case 18:
                       if(menhir_env$0[4])throw [0,Assert_failure,_bW_];
                       var tok$4=menhir_env$0[3];
                       if(typeof tok$4 === "number")
                        switch(tok$4)
                         {case 0:
                           if(counter < 50)
                            {var counter$181=counter + 1 | 0;
                             return menhir_run15(counter$181,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run15,[0,menhir_env$0,menhir_stack$1]);
                          case 1:
                           if(counter < 50)
                            {var counter$164=counter + 1 | 0;
                             return menhir_run17(counter$164,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run17,[0,menhir_env$0,menhir_stack$1]);
                          case 2:
                           if(counter < 50)
                            {var counter$151=counter + 1 | 0;
                             return menhir_run19(counter$151,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run19,[0,menhir_env$0,menhir_stack$1]);
                          case 6:
                           if(counter < 50)
                            {var counter$136=counter + 1 | 0;
                             return menhir_run21(counter$136,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run21,[0,menhir_env$0,menhir_stack$1]);
                          case 7:
                           if(counter < 50)
                            {var counter$128=counter + 1 | 0;
                             return menhir_run38(counter$128,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run38,[0,menhir_env$0,menhir_stack$1]);
                          case 10:
                           if(counter < 50)
                            {var counter$117=counter + 1 | 0;
                             return menhir_run29(counter$117,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run29,[0,menhir_env$0,menhir_stack$1]);
                          case 11:
                           if(counter < 50)
                            {var counter$100=counter + 1 | 0;
                             return menhir_run23(counter$100,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run23,[0,menhir_env$0,menhir_stack$1]);
                          case 12:
                           if(counter < 50)
                            {var counter$85=counter + 1 | 0;
                             return menhir_run27(counter$85,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run27,[0,menhir_env$0,menhir_stack$1]);
                          case 13:
                           if(counter < 50)
                            {var counter$72=counter + 1 | 0;
                             return menhir_run31(counter$72,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run31,[0,menhir_env$0,menhir_stack$1]);
                          case 17:
                           if(counter < 50)
                            {var counter$64=counter + 1 | 0;
                             return menhir_run40(counter$64,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run40,[0,menhir_env$0,menhir_stack$1]);
                          case 22:
                           if(counter < 50)
                            {var counter$55=counter + 1 | 0;
                             return menhir_run33(counter$55,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run33,[0,menhir_env$0,menhir_stack$1]);
                          case 25:
                           if(counter < 50)
                            {var counter$38=counter + 1 | 0;
                             return menhir_run25(counter$38,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run25,[0,menhir_env$0,menhir_stack$1]);
                          case 27:
                           var
                            menhir_env$1=menhir_discard(menhir_env$0),
                            tok$5=menhir_env$1[3];
                           if(typeof tok$5 === "number")
                            switch(tok$5)
                             {case 6:
                               var _hH_=17;
                               if(counter < 50)
                                {var counter$8=counter + 1 | 0;
                                 return menhir_run6
                                         (counter$8,menhir_env$1,menhir_stack$1,_hH_)}
                               return caml_trampoline_return
                                       (menhir_run6,[0,menhir_env$1,menhir_stack$1,_hH_]);
                              case 9:
                               var _hI_=17;
                               if(counter < 50)
                                {var counter$6=counter + 1 | 0;
                                 return menhir_run8
                                         (counter$6,menhir_env$1,menhir_stack$1,_hI_)}
                               return caml_trampoline_return
                                       (menhir_run8,[0,menhir_env$1,menhir_stack$1,_hI_]);
                              case 12:
                               var _hJ_=17;
                               if(counter < 50)
                                {var counter$5=counter + 1 | 0;
                                 return menhir_run9
                                         (counter$5,menhir_env$1,menhir_stack$1,_hJ_)}
                               return caml_trampoline_return
                                       (menhir_run9,[0,menhir_env$1,menhir_stack$1,_hJ_]);
                              case 14:
                               var _hK_=17;
                               if(counter < 50)
                                {var counter$4=counter + 1 | 0;
                                 return menhir_run10
                                         (counter$4,menhir_env$1,menhir_stack$1,_hK_)}
                               return caml_trampoline_return
                                       (menhir_run10,[0,menhir_env$1,menhir_stack$1,_hK_]);
                              case 20:
                               var _hL_=17;
                               if(counter < 50)
                                {var counter$2=counter + 1 | 0;
                                 return menhir_run12
                                         (counter$2,menhir_env$1,menhir_stack$1,_hL_)}
                               return caml_trampoline_return
                                       (menhir_run12,[0,menhir_env$1,menhir_stack$1,_hL_])
                              }
                           else
                            switch(tok$5[0])
                             {case 1:
                               var v$6=tok$5[1],_hM_=menhir_env$1[2][11],_hN_=17;
                               if(counter < 50)
                                {var counter$7=counter + 1 | 0;
                                 return menhir_run7
                                         (counter$7,menhir_env$1,menhir_stack$1,_hN_,v$6,_hM_)}
                               return caml_trampoline_return
                                       (menhir_run7,[0,menhir_env$1,menhir_stack$1,_hN_,v$6,_hM_]);
                              case 2:
                               var v$7=tok$5[1],_hO_=menhir_env$1[2][11],_hP_=17;
                               if(counter < 50)
                                {var counter$3=counter + 1 | 0;
                                 return menhir_run11
                                         (counter$3,menhir_env$1,menhir_stack$1,_hP_,v$7,_hO_)}
                               return caml_trampoline_return
                                       (menhir_run11,[0,menhir_env$1,menhir_stack$1,_hP_,v$7,_hO_])
                              }
                           if(menhir_env$1[4])throw [0,Assert_failure,_bY_];
                           menhir_env$1[4] = 1;
                           return menhir_errorcase(menhir_env$1,menhir_stack$1,17);
                          case 28:
                           if(counter < 50)
                            {var counter$30=counter + 1 | 0;
                             return menhir_run44(counter$30,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run44,[0,menhir_env$0,menhir_stack$1]);
                          case 29:
                           if(counter < 50)
                            {var counter$24=counter + 1 | 0;
                             return menhir_run46(counter$24,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run46,[0,menhir_env$0,menhir_stack$1]);
                          case 30:
                           if(counter < 50)
                            {var counter$15=counter + 1 | 0;
                             return menhir_run35(counter$15,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run35,[0,menhir_env$0,menhir_stack$1])
                          }
                       if(menhir_env$0[4])throw [0,Assert_failure,_bX_];
                       menhir_env$0[4] = 1;
                       var
                        menhir_s$9=menhir_stack$1[2],
                        menhir_stack$12=menhir_stack$1[1];
                       return menhir_errorcase
                               (menhir_env$0,menhir_stack$12,menhir_s$9);
                      case 19:
                       if(menhir_env$0[4])throw [0,Assert_failure,_bZ_];
                       var tok$6=menhir_env$0[3];
                       if(typeof tok$6 === "number")
                        switch(tok$6)
                         {case 0:
                           if(counter < 50)
                            {var counter$182=counter + 1 | 0;
                             return menhir_run15(counter$182,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run15,[0,menhir_env$0,menhir_stack$1]);
                          case 1:
                           if(counter < 50)
                            {var counter$165=counter + 1 | 0;
                             return menhir_run17(counter$165,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run17,[0,menhir_env$0,menhir_stack$1]);
                          case 2:
                           if(counter < 50)
                            {var counter$152=counter + 1 | 0;
                             return menhir_run19(counter$152,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run19,[0,menhir_env$0,menhir_stack$1]);
                          case 6:
                           if(counter < 50)
                            {var counter$137=counter + 1 | 0;
                             return menhir_run21(counter$137,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run21,[0,menhir_env$0,menhir_stack$1]);
                          case 10:
                           if(counter < 50)
                            {var counter$118=counter + 1 | 0;
                             return menhir_run29(counter$118,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run29,[0,menhir_env$0,menhir_stack$1]);
                          case 11:
                           if(counter < 50)
                            {var counter$101=counter + 1 | 0;
                             return menhir_run23(counter$101,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run23,[0,menhir_env$0,menhir_stack$1]);
                          case 12:
                           if(counter < 50)
                            {var counter$86=counter + 1 | 0;
                             return menhir_run27(counter$86,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run27,[0,menhir_env$0,menhir_stack$1]);
                          case 13:
                           if(counter < 50)
                            {var counter$73=counter + 1 | 0;
                             return menhir_run31(counter$73,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run31,[0,menhir_env$0,menhir_stack$1]);
                          case 22:
                           if(counter < 50)
                            {var counter$56=counter + 1 | 0;
                             return menhir_run33(counter$56,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run33,[0,menhir_env$0,menhir_stack$1]);
                          case 25:
                           if(counter < 50)
                            {var counter$39=counter + 1 | 0;
                             return menhir_run25(counter$39,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run25,[0,menhir_env$0,menhir_stack$1]);
                          case 30:
                           if(counter < 50)
                            {var counter$16=counter + 1 | 0;
                             return menhir_run35(counter$16,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run35,[0,menhir_env$0,menhir_stack$1]);
                          case 3:
                          case 5:
                          case 7:
                          case 17:
                          case 23:
                          case 27:
                          case 28:
                          case 29:
                           var
                            e2$2=menhir_stack$1[3],
                            match$4=menhir_stack$1[1],
                            e1$2=match$4[3],
                            menhir_s$10=match$4[2],
                            menhir_stack$13=match$4[1],
                            v$8=[1,7,e1$2,e2$2],
                            menhir_stack$0=menhir_stack$13,
                            menhir_s$0=menhir_s$10,
                            v$0=v$8;
                           continue
                          }
                       if(menhir_env$0[4])throw [0,Assert_failure,_b0_];
                       menhir_env$0[4] = 1;
                       var
                        menhir_s$11=menhir_stack$1[2],
                        menhir_stack$14=menhir_stack$1[1];
                       return menhir_errorcase
                               (menhir_env$0,menhir_stack$14,menhir_s$11);
                      case 20:
                       if(menhir_env$0[4])throw [0,Assert_failure,_b1_];
                       var tok$7=menhir_env$0[3];
                       if(typeof tok$7 === "number")
                        switch(tok$7)
                         {case 1:
                           if(counter < 50)
                            {var counter$166=counter + 1 | 0;
                             return menhir_run17(counter$166,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run17,[0,menhir_env$0,menhir_stack$1]);
                          case 2:
                           if(counter < 50)
                            {var counter$153=counter + 1 | 0;
                             return menhir_run19(counter$153,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run19,[0,menhir_env$0,menhir_stack$1]);
                          case 6:
                           if(counter < 50)
                            {var counter$138=counter + 1 | 0;
                             return menhir_run21(counter$138,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run21,[0,menhir_env$0,menhir_stack$1]);
                          case 10:
                           if(counter < 50)
                            {var counter$119=counter + 1 | 0;
                             return menhir_run29(counter$119,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run29,[0,menhir_env$0,menhir_stack$1]);
                          case 11:
                           if(counter < 50)
                            {var counter$102=counter + 1 | 0;
                             return menhir_run23(counter$102,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run23,[0,menhir_env$0,menhir_stack$1]);
                          case 12:
                           if(counter < 50)
                            {var counter$87=counter + 1 | 0;
                             return menhir_run27(counter$87,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run27,[0,menhir_env$0,menhir_stack$1]);
                          case 13:
                           if(counter < 50)
                            {var counter$74=counter + 1 | 0;
                             return menhir_run31(counter$74,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run31,[0,menhir_env$0,menhir_stack$1]);
                          case 22:
                           if(counter < 50)
                            {var counter$57=counter + 1 | 0;
                             return menhir_run33(counter$57,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run33,[0,menhir_env$0,menhir_stack$1]);
                          case 25:
                           if(counter < 50)
                            {var counter$40=counter + 1 | 0;
                             return menhir_run25(counter$40,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run25,[0,menhir_env$0,menhir_stack$1]);
                          case 0:
                          case 3:
                          case 5:
                          case 7:
                          case 17:
                          case 23:
                          case 27:
                          case 28:
                          case 29:
                          case 30:
                           var
                            e2$3=menhir_stack$1[3],
                            match$5=menhir_stack$1[1],
                            e1$3=match$5[3],
                            menhir_s$12=match$5[2],
                            menhir_stack$15=match$5[1],
                            v$9=[1,5,e1$3,e2$3],
                            menhir_stack$0=menhir_stack$15,
                            menhir_s$0=menhir_s$12,
                            v$0=v$9;
                           continue
                          }
                       if(menhir_env$0[4])throw [0,Assert_failure,_b2_];
                       menhir_env$0[4] = 1;
                       var
                        menhir_s$13=menhir_stack$1[2],
                        menhir_stack$16=menhir_stack$1[1];
                       return menhir_errorcase
                               (menhir_env$0,menhir_stack$16,menhir_s$13);
                      case 21:
                       if(menhir_env$0[4])throw [0,Assert_failure,_b3_];
                       var tok$8=menhir_env$0[3];
                       if(typeof tok$8 === "number")
                        switch(tok$8)
                         {case 1:
                           if(counter < 50)
                            {var counter$167=counter + 1 | 0;
                             return menhir_run17(counter$167,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run17,[0,menhir_env$0,menhir_stack$1]);
                          case 2:
                           if(counter < 50)
                            {var counter$154=counter + 1 | 0;
                             return menhir_run19(counter$154,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run19,[0,menhir_env$0,menhir_stack$1]);
                          case 6:
                           if(counter < 50)
                            {var counter$139=counter + 1 | 0;
                             return menhir_run21(counter$139,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run21,[0,menhir_env$0,menhir_stack$1]);
                          case 11:
                           if(counter < 50)
                            {var counter$103=counter + 1 | 0;
                             return menhir_run23(counter$103,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run23,[0,menhir_env$0,menhir_stack$1]);
                          case 12:
                           if(counter < 50)
                            {var counter$88=counter + 1 | 0;
                             return menhir_run27(counter$88,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run27,[0,menhir_env$0,menhir_stack$1]);
                          case 13:
                           if(counter < 50)
                            {var counter$75=counter + 1 | 0;
                             return menhir_run31(counter$75,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run31,[0,menhir_env$0,menhir_stack$1]);
                          case 25:
                           if(counter < 50)
                            {var counter$41=counter + 1 | 0;
                             return menhir_run25(counter$41,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run25,[0,menhir_env$0,menhir_stack$1]);
                          case 4:
                          case 8:
                          case 9:
                          case 14:
                          case 15:
                          case 16:
                          case 18:
                          case 19:
                          case 20:
                          case 21:
                          case 24:
                          case 26:break;
                          default:
                           var
                            e2$4=menhir_stack$1[3],
                            match$6=menhir_stack$1[1],
                            e1$4=match$6[3],
                            menhir_s$14=match$6[2],
                            menhir_stack$17=match$6[1],
                            v$10=[1,10,e1$4,e2$4],
                            menhir_stack$0=menhir_stack$17,
                            menhir_s$0=menhir_s$14,
                            v$0=v$10;
                           continue}
                       if(menhir_env$0[4])throw [0,Assert_failure,_b4_];
                       menhir_env$0[4] = 1;
                       var
                        menhir_s$15=menhir_stack$1[2],
                        menhir_stack$18=menhir_stack$1[1];
                       return menhir_errorcase
                               (menhir_env$0,menhir_stack$18,menhir_s$15);
                      case 22:
                       if(menhir_env$0[4])throw [0,Assert_failure,_b5_];
                       var tok$9=menhir_env$0[3];
                       if(typeof tok$9 === "number")
                        switch(tok$9)
                         {case 1:
                           if(counter < 50)
                            {var counter$168=counter + 1 | 0;
                             return menhir_run17(counter$168,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run17,[0,menhir_env$0,menhir_stack$1]);
                          case 6:
                           if(counter < 50)
                            {var counter$140=counter + 1 | 0;
                             return menhir_run21(counter$140,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run21,[0,menhir_env$0,menhir_stack$1]);
                          case 11:
                           if(counter < 50)
                            {var counter$104=counter + 1 | 0;
                             return menhir_run23(counter$104,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run23,[0,menhir_env$0,menhir_stack$1]);
                          case 12:
                           if(counter < 50)
                            {var counter$89=counter + 1 | 0;
                             return menhir_run27(counter$89,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run27,[0,menhir_env$0,menhir_stack$1]);
                          case 25:
                           if(counter < 50)
                            {var counter$42=counter + 1 | 0;
                             return menhir_run25(counter$42,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run25,[0,menhir_env$0,menhir_stack$1]);
                          case 4:
                          case 8:
                          case 9:
                          case 14:
                          case 15:
                          case 16:
                          case 18:
                          case 19:
                          case 20:
                          case 21:
                          case 24:
                          case 26:break;
                          default:
                           var
                            e2$5=menhir_stack$1[3],
                            match$7=menhir_stack$1[1],
                            e1$5=match$7[3],
                            menhir_s$16=match$7[2],
                            menhir_stack$19=match$7[1],
                            v$11=[1,8,e1$5,e2$5],
                            menhir_stack$0=menhir_stack$19,
                            menhir_s$0=menhir_s$16,
                            v$0=v$11;
                           continue}
                       if(menhir_env$0[4])throw [0,Assert_failure,_b6_];
                       menhir_env$0[4] = 1;
                       var
                        menhir_s$17=menhir_stack$1[2],
                        menhir_stack$20=menhir_stack$1[1];
                       return menhir_errorcase
                               (menhir_env$0,menhir_stack$20,menhir_s$17);
                      case 23:
                       if(menhir_env$0[4])throw [0,Assert_failure,_b7_];
                       var tok$10=menhir_env$0[3];
                       if(typeof tok$10 === "number")
                        switch(tok$10)
                         {case 1:
                           if(counter < 50)
                            {var counter$169=counter + 1 | 0;
                             return menhir_run17(counter$169,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run17,[0,menhir_env$0,menhir_stack$1]);
                          case 2:
                           if(counter < 50)
                            {var counter$155=counter + 1 | 0;
                             return menhir_run19(counter$155,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run19,[0,menhir_env$0,menhir_stack$1]);
                          case 6:
                           if(counter < 50)
                            {var counter$141=counter + 1 | 0;
                             return menhir_run21(counter$141,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run21,[0,menhir_env$0,menhir_stack$1]);
                          case 11:
                           if(counter < 50)
                            {var counter$105=counter + 1 | 0;
                             return menhir_run23(counter$105,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run23,[0,menhir_env$0,menhir_stack$1]);
                          case 12:
                           if(counter < 50)
                            {var counter$90=counter + 1 | 0;
                             return menhir_run27(counter$90,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run27,[0,menhir_env$0,menhir_stack$1]);
                          case 13:
                           if(counter < 50)
                            {var counter$76=counter + 1 | 0;
                             return menhir_run31(counter$76,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run31,[0,menhir_env$0,menhir_stack$1]);
                          case 25:
                           if(counter < 50)
                            {var counter$43=counter + 1 | 0;
                             return menhir_run25(counter$43,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run25,[0,menhir_env$0,menhir_stack$1]);
                          case 4:
                          case 8:
                          case 9:
                          case 14:
                          case 15:
                          case 16:
                          case 18:
                          case 19:
                          case 20:
                          case 21:
                          case 24:
                          case 26:break;
                          default:
                           var
                            e2$6=menhir_stack$1[3],
                            match$8=menhir_stack$1[1],
                            e1$6=match$8[3],
                            menhir_s$18=match$8[2],
                            menhir_stack$21=match$8[1],
                            v$12=[1,11,e1$6,e2$6],
                            menhir_stack$0=menhir_stack$21,
                            menhir_s$0=menhir_s$18,
                            v$0=v$12;
                           continue}
                       if(menhir_env$0[4])throw [0,Assert_failure,_b8_];
                       menhir_env$0[4] = 1;
                       var
                        menhir_s$19=menhir_stack$1[2],
                        menhir_stack$22=menhir_stack$1[1];
                       return menhir_errorcase
                               (menhir_env$0,menhir_stack$22,menhir_s$19);
                      case 24:
                       if(menhir_env$0[4])throw [0,Assert_failure,_b9_];
                       var tok$11=menhir_env$0[3];
                       if(typeof tok$11 === "number")
                        switch(tok$11)
                         {case 1:
                           if(counter < 50)
                            {var counter$170=counter + 1 | 0;
                             return menhir_run17(counter$170,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run17,[0,menhir_env$0,menhir_stack$1]);
                          case 11:
                           if(counter < 50)
                            {var counter$106=counter + 1 | 0;
                             return menhir_run23(counter$106,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run23,[0,menhir_env$0,menhir_stack$1]);
                          case 25:
                           if(counter < 50)
                            {var counter$44=counter + 1 | 0;
                             return menhir_run25(counter$44,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run25,[0,menhir_env$0,menhir_stack$1]);
                          case 4:
                          case 8:
                          case 9:
                          case 14:
                          case 15:
                          case 16:
                          case 18:
                          case 19:
                          case 20:
                          case 21:
                          case 24:
                          case 26:break;
                          default:
                           var
                            e2$7=menhir_stack$1[3],
                            match$9=menhir_stack$1[1],
                            e1$7=match$9[3],
                            menhir_s$20=match$9[2],
                            menhir_stack$23=match$9[1],
                            v$13=[1,1,e1$7,e2$7],
                            menhir_stack$0=menhir_stack$23,
                            menhir_s$0=menhir_s$20,
                            v$0=v$13;
                           continue}
                       if(menhir_env$0[4])throw [0,Assert_failure,_b__];
                       menhir_env$0[4] = 1;
                       var
                        menhir_s$21=menhir_stack$1[2],
                        menhir_stack$24=menhir_stack$1[1];
                       return menhir_errorcase
                               (menhir_env$0,menhir_stack$24,menhir_s$21);
                      case 25:
                       var
                        e2$8=menhir_stack$1[3],
                        match$10=menhir_stack$1[1],
                        e1$8=match$10[3],
                        menhir_s$22=match$10[2],
                        menhir_stack$25=match$10[1],
                        v$14=[1,3,e1$8,e2$8],
                        menhir_stack$0=menhir_stack$25,
                        menhir_s$0=menhir_s$22,
                        v$0=v$14;
                       continue;
                      case 26:
                       var
                        e2$9=menhir_stack$1[3],
                        match$11=menhir_stack$1[1],
                        e1$9=match$11[3],
                        menhir_s$23=match$11[2],
                        menhir_stack$26=match$11[1],
                        v$15=[1,4,e1$9,e2$9],
                        menhir_stack$0=menhir_stack$26,
                        menhir_s$0=menhir_s$23,
                        v$0=v$15;
                       continue;
                      case 27:
                       if(menhir_env$0[4])throw [0,Assert_failure,_b$_];
                       var tok$12=menhir_env$0[3];
                       if(typeof tok$12 === "number")
                        switch(tok$12)
                         {case 1:
                           if(counter < 50)
                            {var counter$171=counter + 1 | 0;
                             return menhir_run17(counter$171,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run17,[0,menhir_env$0,menhir_stack$1]);
                          case 11:
                           if(counter < 50)
                            {var counter$107=counter + 1 | 0;
                             return menhir_run23(counter$107,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run23,[0,menhir_env$0,menhir_stack$1]);
                          case 25:
                           if(counter < 50)
                            {var counter$45=counter + 1 | 0;
                             return menhir_run25(counter$45,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run25,[0,menhir_env$0,menhir_stack$1]);
                          case 4:
                          case 8:
                          case 9:
                          case 14:
                          case 15:
                          case 16:
                          case 18:
                          case 19:
                          case 20:
                          case 21:
                          case 24:
                          case 26:break;
                          default:
                           var
                            e2$10=menhir_stack$1[3],
                            match$12=menhir_stack$1[1],
                            e1$10=match$12[3],
                            menhir_s$24=match$12[2],
                            menhir_stack$27=match$12[1],
                            v$16=[1,0,e1$10,e2$10],
                            menhir_stack$0=menhir_stack$27,
                            menhir_s$0=menhir_s$24,
                            v$0=v$16;
                           continue}
                       if(menhir_env$0[4])throw [0,Assert_failure,_ca_];
                       menhir_env$0[4] = 1;
                       var
                        menhir_s$25=menhir_stack$1[2],
                        menhir_stack$28=menhir_stack$1[1];
                       return menhir_errorcase
                               (menhir_env$0,menhir_stack$28,menhir_s$25);
                      case 28:
                       if(menhir_env$0[4])throw [0,Assert_failure,_cb_];
                       var tok$13=menhir_env$0[3];
                       if(typeof tok$13 === "number")
                        switch(tok$13)
                         {case 1:
                           if(counter < 50)
                            {var counter$172=counter + 1 | 0;
                             return menhir_run17(counter$172,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run17,[0,menhir_env$0,menhir_stack$1]);
                          case 6:
                           if(counter < 50)
                            {var counter$142=counter + 1 | 0;
                             return menhir_run21(counter$142,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run21,[0,menhir_env$0,menhir_stack$1]);
                          case 11:
                           if(counter < 50)
                            {var counter$108=counter + 1 | 0;
                             return menhir_run23(counter$108,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run23,[0,menhir_env$0,menhir_stack$1]);
                          case 12:
                           if(counter < 50)
                            {var counter$91=counter + 1 | 0;
                             return menhir_run27(counter$91,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run27,[0,menhir_env$0,menhir_stack$1]);
                          case 25:
                           if(counter < 50)
                            {var counter$46=counter + 1 | 0;
                             return menhir_run25(counter$46,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run25,[0,menhir_env$0,menhir_stack$1]);
                          case 4:
                          case 8:
                          case 9:
                          case 14:
                          case 15:
                          case 16:
                          case 18:
                          case 19:
                          case 20:
                          case 21:
                          case 24:
                          case 26:break;
                          default:
                           var
                            e2$11=menhir_stack$1[3],
                            match$13=menhir_stack$1[1],
                            e1$11=match$13[3],
                            menhir_s$26=match$13[2],
                            menhir_stack$29=match$13[1],
                            v$17=[1,9,e1$11,e2$11],
                            menhir_stack$0=menhir_stack$29,
                            menhir_s$0=menhir_s$26,
                            v$0=v$17;
                           continue}
                       if(menhir_env$0[4])throw [0,Assert_failure,_cc_];
                       menhir_env$0[4] = 1;
                       var
                        menhir_s$27=menhir_stack$1[2],
                        menhir_stack$30=menhir_stack$1[1];
                       return menhir_errorcase
                               (menhir_env$0,menhir_stack$30,menhir_s$27);
                      case 29:
                       var
                        e2$12=menhir_stack$1[3],
                        match$14=menhir_stack$1[1],
                        e1$12=match$14[3],
                        menhir_s$28=match$14[2],
                        menhir_stack$31=match$14[1],
                        v$18=[1,2,e1$12,e2$12],
                        menhir_stack$0=menhir_stack$31,
                        menhir_s$0=menhir_s$28,
                        v$0=v$18;
                       continue;
                      case 30:
                       if(menhir_env$0[4])throw [0,Assert_failure,_cd_];
                       var tok$14=menhir_env$0[3];
                       if(typeof tok$14 === "number")
                        switch(tok$14)
                         {case 1:
                           if(counter < 50)
                            {var counter$173=counter + 1 | 0;
                             return menhir_run17(counter$173,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run17,[0,menhir_env$0,menhir_stack$1]);
                          case 2:
                           if(counter < 50)
                            {var counter$156=counter + 1 | 0;
                             return menhir_run19(counter$156,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run19,[0,menhir_env$0,menhir_stack$1]);
                          case 6:
                           if(counter < 50)
                            {var counter$143=counter + 1 | 0;
                             return menhir_run21(counter$143,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run21,[0,menhir_env$0,menhir_stack$1]);
                          case 10:
                           if(counter < 50)
                            {var counter$120=counter + 1 | 0;
                             return menhir_run29(counter$120,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run29,[0,menhir_env$0,menhir_stack$1]);
                          case 11:
                           if(counter < 50)
                            {var counter$109=counter + 1 | 0;
                             return menhir_run23(counter$109,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run23,[0,menhir_env$0,menhir_stack$1]);
                          case 12:
                           if(counter < 50)
                            {var counter$92=counter + 1 | 0;
                             return menhir_run27(counter$92,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run27,[0,menhir_env$0,menhir_stack$1]);
                          case 13:
                           if(counter < 50)
                            {var counter$77=counter + 1 | 0;
                             return menhir_run31(counter$77,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run31,[0,menhir_env$0,menhir_stack$1]);
                          case 22:
                           if(counter < 50)
                            {var counter$58=counter + 1 | 0;
                             return menhir_run33(counter$58,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run33,[0,menhir_env$0,menhir_stack$1]);
                          case 25:
                           if(counter < 50)
                            {var counter$47=counter + 1 | 0;
                             return menhir_run25(counter$47,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run25,[0,menhir_env$0,menhir_stack$1]);
                          case 30:
                           if(counter < 50)
                            {var counter$17=counter + 1 | 0;
                             return menhir_run35(counter$17,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run35,[0,menhir_env$0,menhir_stack$1]);
                          case 0:
                          case 3:
                          case 5:
                          case 7:
                          case 17:
                          case 23:
                          case 27:
                          case 28:
                          case 29:
                           var
                            e2$13=menhir_stack$1[3],
                            match$15=menhir_stack$1[1],
                            e1$13=match$15[3],
                            menhir_s$29=match$15[2],
                            menhir_stack$32=match$15[1],
                            v$19=[1,6,e1$13,e2$13],
                            menhir_stack$0=menhir_stack$32,
                            menhir_s$0=menhir_s$29,
                            v$0=v$19;
                           continue
                          }
                       if(menhir_env$0[4])throw [0,Assert_failure,_ce_];
                       menhir_env$0[4] = 1;
                       var
                        menhir_s$30=menhir_stack$1[2],
                        menhir_stack$33=menhir_stack$1[1];
                       return menhir_errorcase
                               (menhir_env$0,menhir_stack$33,menhir_s$30);
                      case 31:
                       var
                        e$1=menhir_stack$1[3],
                        match$16=menhir_stack$1[1],
                        menhir_s$31=match$16[2],
                        menhir_stack$34=match$16[1],
                        v$20=[2,3,e$1],
                        menhir_stack$0=menhir_stack$34,
                        menhir_s$0=menhir_s$31,
                        v$0=v$20;
                       continue;
                      case 32:
                       if(menhir_env$0[4])throw [0,Assert_failure,_cf_];
                       var tok$15=menhir_env$0[3];
                       if(typeof tok$15 === "number")
                        switch(tok$15)
                         {case 0:
                           if(counter < 50)
                            {var counter$183=counter + 1 | 0;
                             return menhir_run15(counter$183,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run15,[0,menhir_env$0,menhir_stack$1]);
                          case 1:
                           if(counter < 50)
                            {var counter$174=counter + 1 | 0;
                             return menhir_run17(counter$174,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run17,[0,menhir_env$0,menhir_stack$1]);
                          case 2:
                           if(counter < 50)
                            {var counter$157=counter + 1 | 0;
                             return menhir_run19(counter$157,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run19,[0,menhir_env$0,menhir_stack$1]);
                          case 3:
                           var
                            menhir_env$2=menhir_discard(menhir_env$0),
                            v$21=menhir_stack$1[3],
                            match$17=menhir_stack$1[1],
                            menhir_s$32=match$17[2],
                            menhir_stack$35=match$17[1],
                            menhir_env$0=menhir_env$2,
                            menhir_stack$0=menhir_stack$35,
                            menhir_s$0=menhir_s$32,
                            v$0=v$21;
                           continue;
                          case 6:
                           if(counter < 50)
                            {var counter$144=counter + 1 | 0;
                             return menhir_run21(counter$144,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run21,[0,menhir_env$0,menhir_stack$1]);
                          case 7:
                           if(counter < 50)
                            {var counter$129=counter + 1 | 0;
                             return menhir_run38(counter$129,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run38,[0,menhir_env$0,menhir_stack$1]);
                          case 10:
                           if(counter < 50)
                            {var counter$121=counter + 1 | 0;
                             return menhir_run29(counter$121,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run29,[0,menhir_env$0,menhir_stack$1]);
                          case 11:
                           if(counter < 50)
                            {var counter$110=counter + 1 | 0;
                             return menhir_run23(counter$110,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run23,[0,menhir_env$0,menhir_stack$1]);
                          case 12:
                           if(counter < 50)
                            {var counter$93=counter + 1 | 0;
                             return menhir_run27(counter$93,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run27,[0,menhir_env$0,menhir_stack$1]);
                          case 13:
                           if(counter < 50)
                            {var counter$78=counter + 1 | 0;
                             return menhir_run31(counter$78,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run31,[0,menhir_env$0,menhir_stack$1]);
                          case 17:
                           if(counter < 50)
                            {var counter$65=counter + 1 | 0;
                             return menhir_run40(counter$65,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run40,[0,menhir_env$0,menhir_stack$1]);
                          case 22:
                           if(counter < 50)
                            {var counter$59=counter + 1 | 0;
                             return menhir_run33(counter$59,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run33,[0,menhir_env$0,menhir_stack$1]);
                          case 25:
                           if(counter < 50)
                            {var counter$48=counter + 1 | 0;
                             return menhir_run25(counter$48,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run25,[0,menhir_env$0,menhir_stack$1]);
                          case 28:
                           if(counter < 50)
                            {var counter$31=counter + 1 | 0;
                             return menhir_run44(counter$31,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run44,[0,menhir_env$0,menhir_stack$1]);
                          case 29:
                           if(counter < 50)
                            {var counter$25=counter + 1 | 0;
                             return menhir_run46(counter$25,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run46,[0,menhir_env$0,menhir_stack$1]);
                          case 30:
                           if(counter < 50)
                            {var counter$18=counter + 1 | 0;
                             return menhir_run35(counter$18,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run35,[0,menhir_env$0,menhir_stack$1])
                          }
                       if(menhir_env$0[4])throw [0,Assert_failure,_cg_];
                       menhir_env$0[4] = 1;
                       var
                        menhir_s$33=menhir_stack$1[2],
                        menhir_stack$36=menhir_stack$1[1];
                       return menhir_errorcase
                               (menhir_env$0,menhir_stack$36,menhir_s$33);
                      case 33:
                       var
                        e$2=menhir_stack$1[3],
                        match$18=menhir_stack$1[1],
                        menhir_s$34=match$18[2],
                        menhir_stack$37=match$18[1],
                        v$22=[2,1,e$2],
                        menhir_stack$0=menhir_stack$37,
                        menhir_s$0=menhir_s$34,
                        v$0=v$22;
                       continue;
                      case 34:
                       var
                        e$3=menhir_stack$1[3],
                        match$19=menhir_stack$1[1],
                        menhir_s$35=match$19[2],
                        menhir_stack$38=match$19[1],
                        v$23=[2,2,e$3],
                        menhir_stack$0=menhir_stack$38,
                        menhir_s$0=menhir_s$35,
                        v$0=v$23;
                       continue;
                      case 35:
                       var
                        e$4=menhir_stack$1[3],
                        match$20=menhir_stack$1[1],
                        menhir_s$36=match$20[2],
                        menhir_stack$39=match$20[1],
                        v$24=[2,0,e$4],
                        menhir_stack$0=menhir_stack$39,
                        menhir_s$0=menhir_s$36,
                        v$0=v$24;
                       continue;
                      case 36:
                       if(menhir_env$0[4])throw [0,Assert_failure,_ch_];
                       var tok$16=menhir_env$0[3];
                       if(typeof tok$16 === "number")
                        switch(tok$16)
                         {case 0:
                           if(counter < 50)
                            {var counter$184=counter + 1 | 0;
                             return menhir_run15(counter$184,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run15,[0,menhir_env$0,menhir_stack$1]);
                          case 1:
                           if(counter < 50)
                            {var counter$175=counter + 1 | 0;
                             return menhir_run17(counter$175,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run17,[0,menhir_env$0,menhir_stack$1]);
                          case 2:
                           if(counter < 50)
                            {var counter$158=counter + 1 | 0;
                             return menhir_run19(counter$158,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run19,[0,menhir_env$0,menhir_stack$1]);
                          case 5:
                           var
                            menhir_env$3=menhir_discard(menhir_env$0),
                            e$5=menhir_stack$1[3],
                            match$21=menhir_stack$1[1],
                            startpos_1=match$21[3],
                            menhir_s$38=match$21[2],
                            menhir_stack$41=match$21[1],
                            v$25=[1,e$5];
                           if(counter < 50)
                            {var counter$9=counter + 1 | 0;
                             return menhir_goto_number
                                     (counter$9,
                                      menhir_env$3,
                                      menhir_stack$41,
                                      menhir_s$38,
                                      v$25,
                                      startpos_1)}
                           return caml_trampoline_return
                                   (menhir_goto_number,
                                    [0,menhir_env$3,menhir_stack$41,menhir_s$38,v$25,startpos_1]);
                          case 6:
                           if(counter < 50)
                            {var counter$145=counter + 1 | 0;
                             return menhir_run21(counter$145,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run21,[0,menhir_env$0,menhir_stack$1]);
                          case 7:
                           if(counter < 50)
                            {var counter$130=counter + 1 | 0;
                             return menhir_run38(counter$130,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run38,[0,menhir_env$0,menhir_stack$1]);
                          case 10:
                           if(counter < 50)
                            {var counter$122=counter + 1 | 0;
                             return menhir_run29(counter$122,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run29,[0,menhir_env$0,menhir_stack$1]);
                          case 11:
                           if(counter < 50)
                            {var counter$111=counter + 1 | 0;
                             return menhir_run23(counter$111,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run23,[0,menhir_env$0,menhir_stack$1]);
                          case 12:
                           if(counter < 50)
                            {var counter$94=counter + 1 | 0;
                             return menhir_run27(counter$94,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run27,[0,menhir_env$0,menhir_stack$1]);
                          case 13:
                           if(counter < 50)
                            {var counter$79=counter + 1 | 0;
                             return menhir_run31(counter$79,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run31,[0,menhir_env$0,menhir_stack$1]);
                          case 17:
                           if(counter < 50)
                            {var counter$66=counter + 1 | 0;
                             return menhir_run40(counter$66,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run40,[0,menhir_env$0,menhir_stack$1]);
                          case 22:
                           if(counter < 50)
                            {var counter$60=counter + 1 | 0;
                             return menhir_run33(counter$60,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run33,[0,menhir_env$0,menhir_stack$1]);
                          case 25:
                           if(counter < 50)
                            {var counter$49=counter + 1 | 0;
                             return menhir_run25(counter$49,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run25,[0,menhir_env$0,menhir_stack$1]);
                          case 28:
                           if(counter < 50)
                            {var counter$32=counter + 1 | 0;
                             return menhir_run44(counter$32,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run44,[0,menhir_env$0,menhir_stack$1]);
                          case 29:
                           if(counter < 50)
                            {var counter$26=counter + 1 | 0;
                             return menhir_run46(counter$26,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run46,[0,menhir_env$0,menhir_stack$1]);
                          case 30:
                           if(counter < 50)
                            {var counter$19=counter + 1 | 0;
                             return menhir_run35(counter$19,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run35,[0,menhir_env$0,menhir_stack$1])
                          }
                       if(menhir_env$0[4])throw [0,Assert_failure,_ci_];
                       menhir_env$0[4] = 1;
                       var
                        menhir_s$37=menhir_stack$1[2],
                        menhir_stack$40=menhir_stack$1[1];
                       return menhir_errorcase
                               (menhir_env$0,menhir_stack$40,menhir_s$37);
                      default:return menhir_fail(0)}}},
               menhir_goto_command=
                function(counter,menhir_env,menhir_stack,menhir_s,v)
                 {var menhir_stack$0=[0,menhir_stack,menhir_s,v];
                  if(menhir_env[4])throw [0,Assert_failure,_cj_];
                  var tok=menhir_env[3];
                  if(typeof tok === "number")
                   {if(23 === tok)
                     {var
                       menhir_env$0=menhir_discard(menhir_env),
                       tok$0=menhir_env$0[3],
                       switch$0=0;
                      if(typeof tok$0 === "number")
                       switch(tok$0)
                        {case 23:
                          var _hF_=4;
                          if(counter < 50)
                           {var counter$0=counter + 1 | 0;
                            return menhir_run1$0
                                    (counter$0,menhir_env$0,menhir_stack$0,_hF_)}
                          return caml_trampoline_return
                                  (menhir_run1$0,[0,menhir_env$0,menhir_stack$0,_hF_]);
                         case 16:
                         case 24:switch$0 = 1;break
                         }
                      else
                       switch(tok$0[0]){case 0:case 3:break;default:switch$0 = 1}
                      if(switch$0)
                       {var _hE_=4;
                        if(counter < 50)
                         {var counter$1=counter + 1 | 0;
                          return menhir_reduce26$0
                                  (counter$1,menhir_env$0,menhir_stack$0,_hE_)}
                        return caml_trampoline_return
                                (menhir_reduce26$0,[0,menhir_env$0,menhir_stack$0,_hE_])}
                      if(menhir_env$0[4])throw [0,Assert_failure,_ck_];
                      menhir_env$0[4] = 1;
                      return menhir_errorcase(menhir_env$0,menhir_stack$0,4)}
                    if(24 === tok)
                     {var
                       cmd=menhir_stack$0[3],
                       match=menhir_stack$0[1],
                       menhir_s$0=match[2],
                       menhir_stack$1=match[1],
                       v$0=[0,cmd,0];
                      return menhir_goto_ast
                              (menhir_env,menhir_stack$1,menhir_s$0,v$0)}}
                  if(menhir_env[4])throw [0,Assert_failure,_cl_];
                  menhir_env[4] = 1;
                  var
                   menhir_s$1=menhir_stack$0[2],
                   menhir_stack$2=menhir_stack$0[1];
                  return menhir_errorcase
                          (menhir_env,menhir_stack$2,menhir_s$1)},
               menhir_goto_number=
                function(counter,menhir_env,menhir_stack,menhir_s,nb,startpos)
                 {switch(menhir_s)
                   {case 6:
                     var
                      menhir_s$0=menhir_stack[2],
                      menhir_stack$0=menhir_stack[1],
                      v$0=[1,nb];
                     if(counter < 50)
                      {var counter$0=counter + 1 | 0;
                       return menhir_goto_arg
                               (counter$0,menhir_env,menhir_stack$0,menhir_s$0,v$0)}
                     return caml_trampoline_return
                             (menhir_goto_arg,
                              [0,menhir_env,menhir_stack$0,menhir_s$0,v$0]);
                    case 8:
                     var
                      match=menhir_stack[1],
                      menhir_s$1=match[2],
                      menhir_stack$1=match[1],
                      v$2=[0,sign_minus,nb];
                     if(counter < 50)
                      {var counter$3=counter + 1 | 0;
                       return menhir_goto_offset
                               (counter$3,menhir_env,menhir_stack$1,menhir_s$1,v$2)}
                     return caml_trampoline_return
                             (menhir_goto_offset,
                              [0,menhir_env,menhir_stack$1,menhir_s$1,v$2]);
                    case 9:
                     var
                      match$0=menhir_stack[1],
                      menhir_s$2=match$0[2],
                      menhir_stack$2=match$0[1],
                      v$3=[0,sign_plus,nb];
                     if(counter < 50)
                      {var counter$4=counter + 1 | 0;
                       return menhir_goto_offset
                               (counter$4,menhir_env,menhir_stack$2,menhir_s$2,v$3)}
                     return caml_trampoline_return
                             (menhir_goto_offset,
                              [0,menhir_env,menhir_stack$2,menhir_s$2,v$3]);
                    case 10:
                     var
                      menhir_s$3=menhir_stack[2],
                      menhir_stack$3=menhir_stack[1],
                      v$4=[0,sign_plus,nb];
                     if(counter < 50)
                      {var counter$5=counter + 1 | 0;
                       return menhir_goto_offset
                               (counter$5,menhir_env,menhir_stack$3,menhir_s$3,v$4)}
                     return caml_trampoline_return
                             (menhir_goto_offset,
                              [0,menhir_env,menhir_stack$3,menhir_s$3,v$4]);
                    case 11:
                     var
                      menhir_s$4=menhir_stack[2],
                      menhir_stack$4=menhir_stack[1],
                      v$5=[0,sign_minus,nb];
                     if(counter < 50)
                      {var counter$6=counter + 1 | 0;
                       return menhir_goto_offset
                               (counter$6,menhir_env,menhir_stack$4,menhir_s$4,v$5)}
                     return caml_trampoline_return
                             (menhir_goto_offset,
                              [0,menhir_env,menhir_stack$4,menhir_s$4,v$5]);
                    case 12:
                     var
                      menhir_s$5=menhir_stack[2],
                      menhir_stack$5=menhir_stack[1],
                      v$6=[0,sign_plus,nb];
                     if(counter < 50)
                      {var counter$7=counter + 1 | 0;
                       return menhir_goto_offset
                               (counter$7,menhir_env,menhir_stack$5,menhir_s$5,v$6)}
                     return caml_trampoline_return
                             (menhir_goto_offset,
                              [0,menhir_env,menhir_stack$5,menhir_s$5,v$6]);
                    case 37:
                     var v$7=[1,startpos,nb];
                     if(counter < 50)
                      {var counter$2=counter + 1 | 0;
                       return menhir_goto_command
                               (counter$2,menhir_env,menhir_stack,menhir_s,v$7)}
                     return caml_trampoline_return
                             (menhir_goto_command,
                              [0,menhir_env,menhir_stack,menhir_s,v$7]);
                    case 7:
                    case 13:
                     var v$1=[0,sign_plus,nb];
                     if(counter < 50)
                      {var counter$8=counter + 1 | 0;
                       return menhir_goto_offset
                               (counter$8,menhir_env,menhir_stack,menhir_s,v$1)}
                     return caml_trampoline_return
                             (menhir_goto_offset,
                              [0,menhir_env,menhir_stack,menhir_s,v$1]);
                    case 5:
                    case 14:
                     var v=[1,nb];
                     if(counter < 50)
                      {var counter$1=counter + 1 | 0;
                       return menhir_goto_arg
                               (counter$1,menhir_env,menhir_stack,menhir_s,v)}
                     return caml_trampoline_return
                             (menhir_goto_arg,[0,menhir_env,menhir_stack,menhir_s,v]);
                    default:return menhir_fail(0)}},
               menhir_run59=
                function(counter,menhir_env,menhir_stack,menhir_s)
                 {var
                   menhir_stack$0=[0,menhir_stack,menhir_s],
                   menhir_env$0=menhir_discard(menhir_env),
                   tok=menhir_env$0[3];
                  if(typeof tok === "number")
                   {if(16 === tok)
                     {var _hA_=menhir_env$0[2][11],_hB_=12;
                      if(counter < 50)
                       {var counter$0=counter + 1 | 0;
                        return menhir_run5
                                (counter$0,menhir_env$0,menhir_stack$0,_hB_,_hA_)}
                      return caml_trampoline_return
                              (menhir_run5,[0,menhir_env$0,menhir_stack$0,_hB_,_hA_])}}
                  else
                   switch(tok[0])
                    {case 1:
                      var v=tok[1],_hC_=menhir_env$0[2][11],_hD_=12;
                      if(counter < 50)
                       {var counter$1=counter + 1 | 0;
                        return menhir_run4
                                (counter$1,menhir_env$0,menhir_stack$0,_hD_,v,_hC_)}
                      return caml_trampoline_return
                              (menhir_run4,[0,menhir_env$0,menhir_stack$0,_hD_,v,_hC_]);
                     case 2:
                      var
                       v$0=tok[1],
                       menhir_env$1=menhir_discard(menhir_env$0),
                       menhir_s$0=menhir_stack$0[2],
                       menhir_stack$1=menhir_stack$0[1],
                       v$1=[1,sign_plus,v$0];
                      if(counter < 50)
                       {var counter$2=counter + 1 | 0;
                        return menhir_goto_offset
                                (counter$2,menhir_env$1,menhir_stack$1,menhir_s$0,v$1)}
                      return caml_trampoline_return
                              (menhir_goto_offset,
                               [0,menhir_env$1,menhir_stack$1,menhir_s$0,v$1])
                     }
                  if(menhir_env$0[4])throw [0,Assert_failure,_cm_];
                  menhir_env$0[4] = 1;
                  return menhir_errorcase(menhir_env$0,menhir_stack$0,12)},
               menhir_run62=
                function(counter,menhir_env,menhir_stack,menhir_s)
                 {var
                   menhir_stack$0=[0,menhir_stack,menhir_s],
                   menhir_env$0=menhir_discard(menhir_env),
                   tok=menhir_env$0[3];
                  if(typeof tok === "number")
                   {if(16 === tok)
                     {var _hw_=menhir_env$0[2][11],_hx_=11;
                      if(counter < 50)
                       {var counter$0=counter + 1 | 0;
                        return menhir_run5
                                (counter$0,menhir_env$0,menhir_stack$0,_hx_,_hw_)}
                      return caml_trampoline_return
                              (menhir_run5,[0,menhir_env$0,menhir_stack$0,_hx_,_hw_])}}
                  else
                   switch(tok[0])
                    {case 1:
                      var v=tok[1],_hy_=menhir_env$0[2][11],_hz_=11;
                      if(counter < 50)
                       {var counter$1=counter + 1 | 0;
                        return menhir_run4
                                (counter$1,menhir_env$0,menhir_stack$0,_hz_,v,_hy_)}
                      return caml_trampoline_return
                              (menhir_run4,[0,menhir_env$0,menhir_stack$0,_hz_,v,_hy_]);
                     case 2:
                      var
                       v$0=tok[1],
                       menhir_env$1=menhir_discard(menhir_env$0),
                       menhir_s$0=menhir_stack$0[2],
                       menhir_stack$1=menhir_stack$0[1],
                       v$1=[1,sign_minus,v$0];
                      if(counter < 50)
                       {var counter$2=counter + 1 | 0;
                        return menhir_goto_offset
                                (counter$2,menhir_env$1,menhir_stack$1,menhir_s$0,v$1)}
                      return caml_trampoline_return
                              (menhir_goto_offset,
                               [0,menhir_env$1,menhir_stack$1,menhir_s$0,v$1])
                     }
                  if(menhir_env$0[4])throw [0,Assert_failure,_cn_];
                  menhir_env$0[4] = 1;
                  return menhir_errorcase(menhir_env$0,menhir_stack$0,11)},
               menhir_run65=
                function(counter,menhir_env,menhir_stack,menhir_s,id,startpos)
                 {var
                   menhir_env$0=menhir_discard(menhir_env),
                   v=[1,sign_plus,id];
                  if(counter < 50)
                   {var counter$0=counter + 1 | 0;
                    return menhir_goto_offset
                            (counter$0,menhir_env$0,menhir_stack,menhir_s,v)}
                  return caml_trampoline_return
                          (menhir_goto_offset,
                           [0,menhir_env$0,menhir_stack,menhir_s,v])},
               menhir_run66=
                function(counter,menhir_env,menhir_stack,menhir_s)
                 {var
                   menhir_stack$0=[0,menhir_stack,menhir_s],
                   menhir_env$0=menhir_discard(menhir_env),
                   tok=menhir_env$0[3];
                  if(typeof tok === "number")
                   switch(tok)
                    {case 6:
                      var
                       menhir_stack$1=[0,menhir_stack$0,10],
                       menhir_env$1=menhir_discard(menhir_env$0),
                       tok$0=menhir_env$1[3];
                      if(typeof tok$0 === "number")
                       {if(16 === tok$0)
                         {var _hk_=menhir_env$1[2][11],_hl_=9;
                          if(counter < 50)
                           {var counter$0=counter + 1 | 0;
                            return menhir_run5
                                    (counter$0,menhir_env$1,menhir_stack$1,_hl_,_hk_)}
                          return caml_trampoline_return
                                  (menhir_run5,[0,menhir_env$1,menhir_stack$1,_hl_,_hk_])}}
                      else
                       if(1 === tok$0[0])
                        {var v=tok$0[1],_hm_=menhir_env$1[2][11],_hn_=9;
                         if(counter < 50)
                          {var counter$3=counter + 1 | 0;
                           return menhir_run4
                                   (counter$3,menhir_env$1,menhir_stack$1,_hn_,v,_hm_)}
                         return caml_trampoline_return
                                 (menhir_run4,[0,menhir_env$1,menhir_stack$1,_hn_,v,_hm_])}
                      if(menhir_env$1[4])throw [0,Assert_failure,_cp_];
                      menhir_env$1[4] = 1;
                      return menhir_errorcase(menhir_env$1,menhir_stack$1,9);
                     case 12:
                      var
                       menhir_stack$2=[0,menhir_stack$0,10],
                       menhir_env$2=menhir_discard(menhir_env$0),
                       tok$1=menhir_env$2[3];
                      if(typeof tok$1 === "number")
                       {if(16 === tok$1)
                         {var _ho_=menhir_env$2[2][11],_hp_=8;
                          if(counter < 50)
                           {var counter$1=counter + 1 | 0;
                            return menhir_run5
                                    (counter$1,menhir_env$2,menhir_stack$2,_hp_,_ho_)}
                          return caml_trampoline_return
                                  (menhir_run5,[0,menhir_env$2,menhir_stack$2,_hp_,_ho_])}}
                      else
                       if(1 === tok$1[0])
                        {var v$0=tok$1[1],_hq_=menhir_env$2[2][11],_hr_=8;
                         if(counter < 50)
                          {var counter$4=counter + 1 | 0;
                           return menhir_run4
                                   (counter$4,menhir_env$2,menhir_stack$2,_hr_,v$0,_hq_)}
                         return caml_trampoline_return
                                 (menhir_run4,[0,menhir_env$2,menhir_stack$2,_hr_,v$0,_hq_])}
                      if(menhir_env$2[4])throw [0,Assert_failure,_cq_];
                      menhir_env$2[4] = 1;
                      return menhir_errorcase(menhir_env$2,menhir_stack$2,8);
                     case 16:
                      var _hs_=menhir_env$0[2][11],_ht_=10;
                      if(counter < 50)
                       {var counter$2=counter + 1 | 0;
                        return menhir_run5
                                (counter$2,menhir_env$0,menhir_stack$0,_ht_,_hs_)}
                      return caml_trampoline_return
                              (menhir_run5,[0,menhir_env$0,menhir_stack$0,_ht_,_hs_])
                     }
                  else
                   if(1 === tok[0])
                    {var v$1=tok[1],_hu_=menhir_env$0[2][11],_hv_=10;
                     if(counter < 50)
                      {var counter$5=counter + 1 | 0;
                       return menhir_run4
                               (counter$5,menhir_env$0,menhir_stack$0,_hv_,v$1,_hu_)}
                     return caml_trampoline_return
                             (menhir_run4,[0,menhir_env$0,menhir_stack$0,_hv_,v$1,_hu_])}
                  if(menhir_env$0[4])throw [0,Assert_failure,_co_];
                  menhir_env$0[4] = 1;
                  return menhir_errorcase(menhir_env$0,menhir_stack$0,10)},
               menhir_goto_arg=
                function(counter,menhir_env,menhir_stack$1,menhir_s$1,v$1)
                 {var menhir_stack$2=[0,menhir_stack$1,menhir_s$1,v$1];
                  if(menhir_env[4])throw [0,Assert_failure,_cr_];
                  var tok=menhir_env[3];
                  if(typeof tok === "number")
                   {var switcher=tok - 17 | 0;
                    if(! (9 < switcher >>> 0))
                     switch(switcher)
                      {case 9:
                        var
                         menhir_env$0=menhir_discard(menhir_env),
                         tok$0=menhir_env$0[3];
                        if(typeof tok$0 === "number")
                         switch(tok$0)
                          {case 15:
                            var _hc_=5;
                            if(counter < 50)
                             {var counter$3=counter + 1 | 0;
                              return menhir_run54
                                      (counter$3,menhir_env$0,menhir_stack$2,_hc_)}
                            return caml_trampoline_return
                                    (menhir_run54,[0,menhir_env$0,menhir_stack$2,_hc_]);
                           case 16:
                            var _hd_=menhir_env$0[2][11],_he_=5;
                            if(counter < 50)
                             {var counter$2=counter + 1 | 0;
                              return menhir_run5
                                      (counter$2,menhir_env$0,menhir_stack$2,_he_,_hd_)}
                            return caml_trampoline_return
                                    (menhir_run5,[0,menhir_env$0,menhir_stack$2,_he_,_hd_]);
                           case 19:
                            var _hf_=5;
                            if(counter < 50)
                             {var counter$0=counter + 1 | 0;
                              return menhir_run79
                                      (counter$0,menhir_env$0,menhir_stack$2,_hf_)}
                            return caml_trampoline_return
                                    (menhir_run79,[0,menhir_env$0,menhir_stack$2,_hf_])
                           }
                        else
                         switch(tok$0[0])
                          {case 1:
                            var v$3=tok$0[1],_hg_=menhir_env$0[2][11],_hh_=5;
                            if(counter < 50)
                             {var counter$4=counter + 1 | 0;
                              return menhir_run4
                                      (counter$4,menhir_env$0,menhir_stack$2,_hh_,v$3,_hg_)}
                            return caml_trampoline_return
                                    (menhir_run4,[0,menhir_env$0,menhir_stack$2,_hh_,v$3,_hg_]);
                           case 2:
                            var v$4=tok$0[1],_hi_=menhir_env$0[2][11],_hj_=5;
                            if(counter < 50)
                             {var counter$1=counter + 1 | 0;
                              return menhir_run78
                                      (counter$1,menhir_env$0,menhir_stack$2,_hj_,v$4,_hi_)}
                            return caml_trampoline_return
                                    (menhir_run78,[0,menhir_env$0,menhir_stack$2,_hj_,v$4,_hi_])
                           }
                        if(menhir_env$0[4])throw [0,Assert_failure,_ct_];
                        menhir_env$0[4] = 1;
                        return menhir_errorcase(menhir_env$0,menhir_stack$2,5);
                       case 0:
                       case 6:
                       case 7:
                        var
                         x$0=menhir_stack$2[3],
                         menhir_s$3=menhir_stack$2[2],
                         menhir_stack$4=menhir_stack$2[1],
                         v$2=[0,x$0,0],
                         menhir_stack=menhir_stack$4,
                         menhir_s=menhir_s$3,
                         v=v$2;
                        for(;;)
                         {if(5 === menhir_s)
                           {var
                             x=menhir_stack[3],
                             menhir_s$0=menhir_stack[2],
                             menhir_stack$0=menhir_stack[1],
                             v$0=[0,x,v],
                             menhir_stack=menhir_stack$0,
                             menhir_s=menhir_s$0,
                             v=v$0;
                            continue}
                          if(14 === menhir_s)
                           {if(counter < 50)
                             {var counter$5=counter + 1 | 0;
                              return menhir_goto_loption_separated_
                                      (counter$5,menhir_env,menhir_stack,menhir_s,v)}
                            return caml_trampoline_return
                                    (menhir_goto_loption_separated_,
                                     [0,menhir_env,menhir_stack,menhir_s,v])}
                          return menhir_fail(0)}
                       }}
                  if(menhir_env[4])throw [0,Assert_failure,_cs_];
                  menhir_env[4] = 1;
                  var
                   menhir_s$2=menhir_stack$2[2],
                   menhir_stack$3=menhir_stack$2[1];
                  return menhir_errorcase
                          (menhir_env,menhir_stack$3,menhir_s$2)},
               menhir_run6=
                function(counter,menhir_env,menhir_stack,menhir_s)
                 {var
                   menhir_env$0=menhir_env,
                   menhir_stack$0=menhir_stack,
                   menhir_s$0=menhir_s;
                  for(;;)
                   {var
                     menhir_stack$1=[0,menhir_stack$0,menhir_s$0],
                     menhir_env$1=menhir_discard(menhir_env$0),
                     tok=menhir_env$1[3];
                    if(typeof tok === "number")
                     switch(tok)
                      {case 6:
                        var
                         menhir_env$0=menhir_env$1,
                         menhir_stack$0=menhir_stack$1,
                         menhir_s$0=35;
                        continue;
                       case 9:
                        var _g6_=35;
                        if(counter < 50)
                         {var counter$4=counter + 1 | 0;
                          return menhir_run8
                                  (counter$4,menhir_env$1,menhir_stack$1,_g6_)}
                        return caml_trampoline_return
                                (menhir_run8,[0,menhir_env$1,menhir_stack$1,_g6_]);
                       case 12:
                        var _g7_=35;
                        if(counter < 50)
                         {var counter$3=counter + 1 | 0;
                          return menhir_run9
                                  (counter$3,menhir_env$1,menhir_stack$1,_g7_)}
                        return caml_trampoline_return
                                (menhir_run9,[0,menhir_env$1,menhir_stack$1,_g7_]);
                       case 14:
                        var _g8_=35;
                        if(counter < 50)
                         {var counter$2=counter + 1 | 0;
                          return menhir_run10
                                  (counter$2,menhir_env$1,menhir_stack$1,_g8_)}
                        return caml_trampoline_return
                                (menhir_run10,[0,menhir_env$1,menhir_stack$1,_g8_]);
                       case 20:
                        var _g9_=35;
                        if(counter < 50)
                         {var counter$0=counter + 1 | 0;
                          return menhir_run12
                                  (counter$0,menhir_env$1,menhir_stack$1,_g9_)}
                        return caml_trampoline_return
                                (menhir_run12,[0,menhir_env$1,menhir_stack$1,_g9_])
                       }
                    else
                     switch(tok[0])
                      {case 1:
                        var v=tok[1],_g__=menhir_env$1[2][11],_g$_=35;
                        if(counter < 50)
                         {var counter$5=counter + 1 | 0;
                          return menhir_run7
                                  (counter$5,menhir_env$1,menhir_stack$1,_g$_,v,_g__)}
                        return caml_trampoline_return
                                (menhir_run7,[0,menhir_env$1,menhir_stack$1,_g$_,v,_g__]);
                       case 2:
                        var v$0=tok[1],_ha_=menhir_env$1[2][11],_hb_=35;
                        if(counter < 50)
                         {var counter$1=counter + 1 | 0;
                          return menhir_run11
                                  (counter$1,menhir_env$1,menhir_stack$1,_hb_,v$0,_ha_)}
                        return caml_trampoline_return
                                (menhir_run11,[0,menhir_env$1,menhir_stack$1,_hb_,v$0,_ha_])
                       }
                    if(menhir_env$1[4])throw [0,Assert_failure,_cw_];
                    menhir_env$1[4] = 1;
                    return menhir_errorcase(menhir_env$1,menhir_stack$1,35)}},
               menhir_run7=
                function(counter,menhir_env,menhir_stack,menhir_s,i,startpos)
                 {var menhir_env$0=menhir_discard(menhir_env),v=[0,i];
                  if(counter < 50)
                   {var counter$0=counter + 1 | 0;
                    return menhir_goto_meta_expr
                            (counter$0,menhir_env$0,menhir_stack,menhir_s,v)}
                  return caml_trampoline_return
                          (menhir_goto_meta_expr,
                           [0,menhir_env$0,menhir_stack,menhir_s,v])},
               menhir_run8=
                function(counter,menhir_env,menhir_stack,menhir_s)
                 {var
                   menhir_env$0=menhir_env,
                   menhir_stack$0=menhir_stack,
                   menhir_s$0=menhir_s;
                  for(;;)
                   {var
                     menhir_stack$1=[0,menhir_stack$0,menhir_s$0],
                     menhir_env$1=menhir_discard(menhir_env$0),
                     tok=menhir_env$1[3];
                    if(typeof tok === "number")
                     switch(tok)
                      {case 6:
                        var _gY_=34;
                        if(counter < 50)
                         {var counter$5=counter + 1 | 0;
                          return menhir_run6
                                  (counter$5,menhir_env$1,menhir_stack$1,_gY_)}
                        return caml_trampoline_return
                                (menhir_run6,[0,menhir_env$1,menhir_stack$1,_gY_]);
                       case 9:
                        var
                         menhir_env$0=menhir_env$1,
                         menhir_stack$0=menhir_stack$1,
                         menhir_s$0=34;
                        continue;
                       case 12:
                        var _gZ_=34;
                        if(counter < 50)
                         {var counter$3=counter + 1 | 0;
                          return menhir_run9
                                  (counter$3,menhir_env$1,menhir_stack$1,_gZ_)}
                        return caml_trampoline_return
                                (menhir_run9,[0,menhir_env$1,menhir_stack$1,_gZ_]);
                       case 14:
                        var _g0_=34;
                        if(counter < 50)
                         {var counter$2=counter + 1 | 0;
                          return menhir_run10
                                  (counter$2,menhir_env$1,menhir_stack$1,_g0_)}
                        return caml_trampoline_return
                                (menhir_run10,[0,menhir_env$1,menhir_stack$1,_g0_]);
                       case 20:
                        var _g1_=34;
                        if(counter < 50)
                         {var counter$0=counter + 1 | 0;
                          return menhir_run12
                                  (counter$0,menhir_env$1,menhir_stack$1,_g1_)}
                        return caml_trampoline_return
                                (menhir_run12,[0,menhir_env$1,menhir_stack$1,_g1_])
                       }
                    else
                     switch(tok[0])
                      {case 1:
                        var v=tok[1],_g2_=menhir_env$1[2][11],_g3_=34;
                        if(counter < 50)
                         {var counter$4=counter + 1 | 0;
                          return menhir_run7
                                  (counter$4,menhir_env$1,menhir_stack$1,_g3_,v,_g2_)}
                        return caml_trampoline_return
                                (menhir_run7,[0,menhir_env$1,menhir_stack$1,_g3_,v,_g2_]);
                       case 2:
                        var v$0=tok[1],_g4_=menhir_env$1[2][11],_g5_=34;
                        if(counter < 50)
                         {var counter$1=counter + 1 | 0;
                          return menhir_run11
                                  (counter$1,menhir_env$1,menhir_stack$1,_g5_,v$0,_g4_)}
                        return caml_trampoline_return
                                (menhir_run11,[0,menhir_env$1,menhir_stack$1,_g5_,v$0,_g4_])
                       }
                    if(menhir_env$1[4])throw [0,Assert_failure,_cx_];
                    menhir_env$1[4] = 1;
                    return menhir_errorcase(menhir_env$1,menhir_stack$1,34)}},
               menhir_run9=
                function(counter,menhir_env,menhir_stack,menhir_s)
                 {var
                   menhir_env$0=menhir_env,
                   menhir_stack$0=menhir_stack,
                   menhir_s$0=menhir_s;
                  for(;;)
                   {var
                     menhir_stack$1=[0,menhir_stack$0,menhir_s$0],
                     menhir_env$1=menhir_discard(menhir_env$0),
                     tok=menhir_env$1[3];
                    if(typeof tok === "number")
                     switch(tok)
                      {case 6:
                        var _gQ_=33;
                        if(counter < 50)
                         {var counter$5=counter + 1 | 0;
                          return menhir_run6
                                  (counter$5,menhir_env$1,menhir_stack$1,_gQ_)}
                        return caml_trampoline_return
                                (menhir_run6,[0,menhir_env$1,menhir_stack$1,_gQ_]);
                       case 9:
                        var _gR_=33;
                        if(counter < 50)
                         {var counter$3=counter + 1 | 0;
                          return menhir_run8
                                  (counter$3,menhir_env$1,menhir_stack$1,_gR_)}
                        return caml_trampoline_return
                                (menhir_run8,[0,menhir_env$1,menhir_stack$1,_gR_]);
                       case 12:
                        var
                         menhir_env$0=menhir_env$1,
                         menhir_stack$0=menhir_stack$1,
                         menhir_s$0=33;
                        continue;
                       case 14:
                        var _gS_=33;
                        if(counter < 50)
                         {var counter$2=counter + 1 | 0;
                          return menhir_run10
                                  (counter$2,menhir_env$1,menhir_stack$1,_gS_)}
                        return caml_trampoline_return
                                (menhir_run10,[0,menhir_env$1,menhir_stack$1,_gS_]);
                       case 20:
                        var _gT_=33;
                        if(counter < 50)
                         {var counter$0=counter + 1 | 0;
                          return menhir_run12
                                  (counter$0,menhir_env$1,menhir_stack$1,_gT_)}
                        return caml_trampoline_return
                                (menhir_run12,[0,menhir_env$1,menhir_stack$1,_gT_])
                       }
                    else
                     switch(tok[0])
                      {case 1:
                        var v=tok[1],_gU_=menhir_env$1[2][11],_gV_=33;
                        if(counter < 50)
                         {var counter$4=counter + 1 | 0;
                          return menhir_run7
                                  (counter$4,menhir_env$1,menhir_stack$1,_gV_,v,_gU_)}
                        return caml_trampoline_return
                                (menhir_run7,[0,menhir_env$1,menhir_stack$1,_gV_,v,_gU_]);
                       case 2:
                        var v$0=tok[1],_gW_=menhir_env$1[2][11],_gX_=33;
                        if(counter < 50)
                         {var counter$1=counter + 1 | 0;
                          return menhir_run11
                                  (counter$1,menhir_env$1,menhir_stack$1,_gX_,v$0,_gW_)}
                        return caml_trampoline_return
                                (menhir_run11,[0,menhir_env$1,menhir_stack$1,_gX_,v$0,_gW_])
                       }
                    if(menhir_env$1[4])throw [0,Assert_failure,_cy_];
                    menhir_env$1[4] = 1;
                    return menhir_errorcase(menhir_env$1,menhir_stack$1,33)}},
               menhir_run10=
                function(counter,menhir_env,menhir_stack,menhir_s)
                 {var
                   menhir_env$0=menhir_env,
                   menhir_stack$0=menhir_stack,
                   menhir_s$0=menhir_s;
                  for(;;)
                   {var
                     menhir_stack$1=[0,menhir_stack$0,menhir_s$0],
                     menhir_env$1=menhir_discard(menhir_env$0),
                     tok=menhir_env$1[3];
                    if(typeof tok === "number")
                     switch(tok)
                      {case 6:
                        var _gI_=32;
                        if(counter < 50)
                         {var counter$5=counter + 1 | 0;
                          return menhir_run6
                                  (counter$5,menhir_env$1,menhir_stack$1,_gI_)}
                        return caml_trampoline_return
                                (menhir_run6,[0,menhir_env$1,menhir_stack$1,_gI_]);
                       case 9:
                        var _gJ_=32;
                        if(counter < 50)
                         {var counter$3=counter + 1 | 0;
                          return menhir_run8
                                  (counter$3,menhir_env$1,menhir_stack$1,_gJ_)}
                        return caml_trampoline_return
                                (menhir_run8,[0,menhir_env$1,menhir_stack$1,_gJ_]);
                       case 12:
                        var _gK_=32;
                        if(counter < 50)
                         {var counter$2=counter + 1 | 0;
                          return menhir_run9
                                  (counter$2,menhir_env$1,menhir_stack$1,_gK_)}
                        return caml_trampoline_return
                                (menhir_run9,[0,menhir_env$1,menhir_stack$1,_gK_]);
                       case 14:
                        var
                         menhir_env$0=menhir_env$1,
                         menhir_stack$0=menhir_stack$1,
                         menhir_s$0=32;
                        continue;
                       case 20:
                        var _gL_=32;
                        if(counter < 50)
                         {var counter$0=counter + 1 | 0;
                          return menhir_run12
                                  (counter$0,menhir_env$1,menhir_stack$1,_gL_)}
                        return caml_trampoline_return
                                (menhir_run12,[0,menhir_env$1,menhir_stack$1,_gL_])
                       }
                    else
                     switch(tok[0])
                      {case 1:
                        var v=tok[1],_gM_=menhir_env$1[2][11],_gN_=32;
                        if(counter < 50)
                         {var counter$4=counter + 1 | 0;
                          return menhir_run7
                                  (counter$4,menhir_env$1,menhir_stack$1,_gN_,v,_gM_)}
                        return caml_trampoline_return
                                (menhir_run7,[0,menhir_env$1,menhir_stack$1,_gN_,v,_gM_]);
                       case 2:
                        var v$0=tok[1],_gO_=menhir_env$1[2][11],_gP_=32;
                        if(counter < 50)
                         {var counter$1=counter + 1 | 0;
                          return menhir_run11
                                  (counter$1,menhir_env$1,menhir_stack$1,_gP_,v$0,_gO_)}
                        return caml_trampoline_return
                                (menhir_run11,[0,menhir_env$1,menhir_stack$1,_gP_,v$0,_gO_])
                       }
                    if(menhir_env$1[4])throw [0,Assert_failure,_cz_];
                    menhir_env$1[4] = 1;
                    return menhir_errorcase(menhir_env$1,menhir_stack$1,32)}},
               menhir_run11=
                function(counter,menhir_env,menhir_stack,menhir_s,v,startpos)
                 {var menhir_env$0=menhir_discard(menhir_env),v$0=[3,v];
                  if(counter < 50)
                   {var counter$0=counter + 1 | 0;
                    return menhir_goto_meta_expr
                            (counter$0,menhir_env$0,menhir_stack,menhir_s,v$0)}
                  return caml_trampoline_return
                          (menhir_goto_meta_expr,
                           [0,menhir_env$0,menhir_stack,menhir_s,v$0])},
               menhir_run12=
                function(counter,menhir_env,menhir_stack,menhir_s)
                 {var
                   menhir_env$0=menhir_env,
                   menhir_stack$0=menhir_stack,
                   menhir_s$0=menhir_s;
                  for(;;)
                   {var
                     menhir_stack$1=[0,menhir_stack$0,menhir_s$0],
                     menhir_env$1=menhir_discard(menhir_env$0),
                     tok=menhir_env$1[3];
                    if(typeof tok === "number")
                     switch(tok)
                      {case 6:
                        var _gA_=31;
                        if(counter < 50)
                         {var counter$5=counter + 1 | 0;
                          return menhir_run6
                                  (counter$5,menhir_env$1,menhir_stack$1,_gA_)}
                        return caml_trampoline_return
                                (menhir_run6,[0,menhir_env$1,menhir_stack$1,_gA_]);
                       case 9:
                        var _gB_=31;
                        if(counter < 50)
                         {var counter$3=counter + 1 | 0;
                          return menhir_run8
                                  (counter$3,menhir_env$1,menhir_stack$1,_gB_)}
                        return caml_trampoline_return
                                (menhir_run8,[0,menhir_env$1,menhir_stack$1,_gB_]);
                       case 12:
                        var _gC_=31;
                        if(counter < 50)
                         {var counter$2=counter + 1 | 0;
                          return menhir_run9
                                  (counter$2,menhir_env$1,menhir_stack$1,_gC_)}
                        return caml_trampoline_return
                                (menhir_run9,[0,menhir_env$1,menhir_stack$1,_gC_]);
                       case 14:
                        var _gD_=31;
                        if(counter < 50)
                         {var counter$1=counter + 1 | 0;
                          return menhir_run10
                                  (counter$1,menhir_env$1,menhir_stack$1,_gD_)}
                        return caml_trampoline_return
                                (menhir_run10,[0,menhir_env$1,menhir_stack$1,_gD_]);
                       case 20:
                        var
                         menhir_env$0=menhir_env$1,
                         menhir_stack$0=menhir_stack$1,
                         menhir_s$0=31;
                        continue
                       }
                    else
                     switch(tok[0])
                      {case 1:
                        var v=tok[1],_gE_=menhir_env$1[2][11],_gF_=31;
                        if(counter < 50)
                         {var counter$4=counter + 1 | 0;
                          return menhir_run7
                                  (counter$4,menhir_env$1,menhir_stack$1,_gF_,v,_gE_)}
                        return caml_trampoline_return
                                (menhir_run7,[0,menhir_env$1,menhir_stack$1,_gF_,v,_gE_]);
                       case 2:
                        var v$0=tok[1],_gG_=menhir_env$1[2][11],_gH_=31;
                        if(counter < 50)
                         {var counter$0=counter + 1 | 0;
                          return menhir_run11
                                  (counter$0,menhir_env$1,menhir_stack$1,_gH_,v$0,_gG_)}
                        return caml_trampoline_return
                                (menhir_run11,[0,menhir_env$1,menhir_stack$1,_gH_,v$0,_gG_])
                       }
                    if(menhir_env$1[4])throw [0,Assert_failure,_cA_];
                    menhir_env$1[4] = 1;
                    return menhir_errorcase(menhir_env$1,menhir_stack$1,31)}},
               menhir_goto_definition=
                function(counter,menhir_env,menhir_stack,v)
                 {var menhir_stack$0=[0,menhir_stack,v];
                  if(menhir_env[4])throw [0,Assert_failure,_cB_];
                  var tok=menhir_env[3];
                  if(typeof tok === "number" && 23 === tok)
                   {var
                     menhir_env$0=menhir_discard(menhir_env),
                     tok$0=menhir_env$0[3],
                     switch$0=0;
                    if(typeof tok$0 === "number")
                     switch(tok$0)
                      {case 23:
                        var _gz_=0;
                        if(counter < 50)
                         {var counter$0=counter + 1 | 0;
                          return menhir_run1$0
                                  (counter$0,menhir_env$0,menhir_stack$0,_gz_)}
                        return caml_trampoline_return
                                (menhir_run1$0,[0,menhir_env$0,menhir_stack$0,_gz_]);
                       case 18:switch$0 = 1;break
                       }
                    else
                     if(2 === tok$0[0])switch$0 = 1;
                    if(switch$0)
                     {var _gy_=0;
                      if(counter < 50)
                       {var counter$1=counter + 1 | 0;
                        return menhir_reduce26$0
                                (counter$1,menhir_env$0,menhir_stack$0,_gy_)}
                      return caml_trampoline_return
                              (menhir_reduce26$0,[0,menhir_env$0,menhir_stack$0,_gy_])}
                    if(menhir_env$0[4])throw [0,Assert_failure,_cC_];
                    menhir_env$0[4] = 1;
                    return menhir_errorcase(menhir_env$0,menhir_stack$0,0)}
                  if(menhir_env[4])throw [0,Assert_failure,_cD_];
                  menhir_env[4] = 1;
                  var
                   match=menhir_stack$0[1],
                   menhir_s=match[2],
                   menhir_stack$1=match[1];
                  return menhir_errorcase(menhir_env,menhir_stack$1,menhir_s)},
               menhir_goto_loption_separated_=
                function(counter,menhir_env,match,menhir_s,args)
                 {if(menhir_env[4])throw [0,Assert_failure,_cE_];
                  var tok=menhir_env[3];
                  if(typeof tok === "number")
                   if(23 <= tok)
                    {if(! (25 <= tok))
                      {var
                        startpos_id=match[4],
                        id=match[3],
                        menhir_s$0=match[2],
                        menhir_stack=match[1],
                        v=[0,startpos_id,id,args,0];
                       if(counter < 50)
                        {var counter$0=counter + 1 | 0;
                         return menhir_goto_command
                                 (counter$0,menhir_env,menhir_stack,menhir_s$0,v)}
                       return caml_trampoline_return
                               (menhir_goto_command,
                                [0,menhir_env,menhir_stack,menhir_s$0,v])}}
                   else
                    if(17 === tok)
                     {var
                       menhir_env$0=menhir_discard(menhir_env),
                       tok$0=menhir_env$0[3];
                      if(typeof tok$0 === "number")
                       switch(tok$0)
                        {case 23:
                         case 24:
                          var
                           startpos_id$0=match[4],
                           id$0=match[3],
                           menhir_s$1=match[2],
                           menhir_stack$0=match[1],
                           v$0=[0,startpos_id$0,id$0,args,1];
                          if(counter < 50)
                           {var counter$2=counter + 1 | 0;
                            return menhir_goto_command
                                    (counter$2,menhir_env$0,menhir_stack$0,menhir_s$1,v$0)}
                          return caml_trampoline_return
                                  (menhir_goto_command,
                                   [0,menhir_env$0,menhir_stack$0,menhir_s$1,v$0])
                         }
                      else
                       if(1 === tok$0[0])
                        {var
                          v$1=tok$0[1],
                          menhir_env$1=menhir_discard(menhir_env$0),
                          startpos_id$1=match[4],
                          id$1=match[3],
                          menhir_s$2=match[2],
                          menhir_stack$1=match[1],
                          v$2=[0,startpos_id$1,id$1,args,[0,uint32_to_int(v$1)]];
                         if(counter < 50)
                          {var counter$1=counter + 1 | 0;
                           return menhir_goto_command
                                   (counter$1,menhir_env$1,menhir_stack$1,menhir_s$2,v$2)}
                         return caml_trampoline_return
                                 (menhir_goto_command,
                                  [0,menhir_env$1,menhir_stack$1,menhir_s$2,v$2])}
                      if(menhir_env$0[4])throw [0,Assert_failure,_cG_];
                      menhir_env$0[4] = 1;
                      return menhir_errorcase(menhir_env$0,match,menhir_s)}
                  if(menhir_env[4])throw [0,Assert_failure,_cF_];
                  menhir_env[4] = 1;
                  return menhir_errorcase(menhir_env,match,menhir_s)},
               menhir_run4=
                function
                 (counter,menhir_env,menhir_stack,menhir_s,i,startpos_i)
                 {var menhir_env$0=menhir_discard(menhir_env),v=[0,i];
                  if(counter < 50)
                   {var counter$0=counter + 1 | 0;
                    return menhir_goto_number
                            (counter$0,menhir_env$0,menhir_stack,menhir_s,v,startpos_i)}
                  return caml_trampoline_return
                          (menhir_goto_number,
                           [0,menhir_env$0,menhir_stack,menhir_s,v,startpos_i])},
               menhir_run54=
                function(counter,menhir_env,menhir_stack,menhir_s)
                 {var
                   menhir_stack$0=[0,menhir_stack,menhir_s],
                   menhir_env$0=menhir_discard(menhir_env),
                   tok=menhir_env$0[3];
                  if(typeof tok !== "number" && 2 === tok[0])
                   {var
                     v=tok[1],
                     startpos=menhir_env$0[2][11],
                     menhir_stack$2=[0,menhir_stack$0,v,startpos],
                     menhir_env$1=menhir_discard(menhir_env$0),
                     tok$0=menhir_env$1[3];
                    if(typeof tok$0 === "number")
                     {if(4 === tok$0)
                       {var
                         menhir_env$2=menhir_discard(menhir_env$1),
                         tok$1=menhir_env$2[3];
                        if(typeof tok$1 === "number" && 17 <= tok$1)
                         {var switcher=tok$1 - 17 | 0;
                          switch(switcher)
                           {case 3:
                             var
                              menhir_env$3=menhir_discard(menhir_env$2),
                              id$0=menhir_stack$2[2],
                              match$1=menhir_stack$2[1],
                              menhir_s$3=match$1[2],
                              menhir_stack$5=match$1[1],
                              v$1=[2,id$0,[0,sign_plus,[0,Stdlib_int32[1]]],1];
                             if(counter < 50)
                              {var counter$4=counter + 1 | 0;
                               return menhir_goto_arg
                                       (counter$4,menhir_env$3,menhir_stack$5,menhir_s$3,v$1)}
                             return caml_trampoline_return
                                     (menhir_goto_arg,
                                      [0,menhir_env$3,menhir_stack$5,menhir_s$3,v$1]);
                            case 9:
                             var
                              menhir_env$4=menhir_discard(menhir_env$2),
                              tok$2=menhir_env$4[3];
                             if(typeof tok$2 === "number")
                              switch(tok$2)
                               {case 6:
                                 var _gg_=13;
                                 if(counter < 50)
                                  {var counter$13=counter + 1 | 0;
                                   return menhir_run59
                                           (counter$13,menhir_env$4,menhir_stack$2,_gg_)}
                                 return caml_trampoline_return
                                         (menhir_run59,[0,menhir_env$4,menhir_stack$2,_gg_]);
                                case 12:
                                 var _gh_=13;
                                 if(counter < 50)
                                  {var counter$11=counter + 1 | 0;
                                   return menhir_run62
                                           (counter$11,menhir_env$4,menhir_stack$2,_gh_)}
                                 return caml_trampoline_return
                                         (menhir_run62,[0,menhir_env$4,menhir_stack$2,_gh_]);
                                case 16:
                                 var _gi_=menhir_env$4[2][11],_gj_=13;
                                 if(counter < 50)
                                  {var counter$1=counter + 1 | 0;
                                   return menhir_run5
                                           (counter$1,menhir_env$4,menhir_stack$2,_gj_,_gi_)}
                                 return caml_trampoline_return
                                         (menhir_run5,[0,menhir_env$4,menhir_stack$2,_gj_,_gi_]);
                                case 19:
                                 var _gk_=13;
                                 if(counter < 50)
                                  {var counter$7=counter + 1 | 0;
                                   return menhir_run66
                                           (counter$7,menhir_env$4,menhir_stack$2,_gk_)}
                                 return caml_trampoline_return
                                         (menhir_run66,[0,menhir_env$4,menhir_stack$2,_gk_])
                                }
                             else
                              switch(tok$2[0])
                               {case 1:
                                 var v$2=tok$2[1],_gl_=menhir_env$4[2][11],_gm_=13;
                                 if(counter < 50)
                                  {var counter$3=counter + 1 | 0;
                                   return menhir_run4
                                           (counter$3,menhir_env$4,menhir_stack$2,_gm_,v$2,_gl_)}
                                 return caml_trampoline_return
                                         (menhir_run4,[0,menhir_env$4,menhir_stack$2,_gm_,v$2,_gl_]);
                                case 2:
                                 var v$3=tok$2[1],_gn_=menhir_env$4[2][11],_go_=13;
                                 if(counter < 50)
                                  {var counter$9=counter + 1 | 0;
                                   return menhir_run65
                                           (counter$9,menhir_env$4,menhir_stack$2,_go_,v$3,_gn_)}
                                 return caml_trampoline_return
                                         (menhir_run65,[0,menhir_env$4,menhir_stack$2,_go_,v$3,_gn_])
                                }
                             if(menhir_env$4[4])throw [0,Assert_failure,_cJ_];
                             menhir_env$4[4] = 1;
                             return menhir_errorcase(menhir_env$4,menhir_stack$2,13);
                            case 0:
                            case 6:
                            case 7:
                             var
                              id=menhir_stack$2[2],
                              match=menhir_stack$2[1],
                              menhir_s$1=match[2],
                              menhir_stack$3=match[1],
                              v$0=[2,id,[0,sign_plus,[0,Stdlib_int32[1]]],0];
                             if(counter < 50)
                              {var counter$5=counter + 1 | 0;
                               return menhir_goto_arg
                                       (counter$5,menhir_env$2,menhir_stack$3,menhir_s$1,v$0)}
                             return caml_trampoline_return
                                     (menhir_goto_arg,
                                      [0,menhir_env$2,menhir_stack$3,menhir_s$1,v$0])
                            }}
                        if(menhir_env$2[4])throw [0,Assert_failure,_cI_];
                        menhir_env$2[4] = 1;
                        var
                         match$0=menhir_stack$2[1],
                         menhir_s$2=match$0[2],
                         menhir_stack$4=match$0[1];
                        return menhir_errorcase
                                (menhir_env$2,menhir_stack$4,menhir_s$2)}
                      if(26 === tok$0)
                       {var
                         menhir_env$5=menhir_discard(menhir_env$1),
                         tok$3=menhir_env$5[3];
                        if(typeof tok$3 === "number")
                         switch(tok$3)
                          {case 6:
                            var _gp_=7;
                            if(counter < 50)
                             {var counter$12=counter + 1 | 0;
                              return menhir_run59
                                      (counter$12,menhir_env$5,menhir_stack$2,_gp_)}
                            return caml_trampoline_return
                                    (menhir_run59,[0,menhir_env$5,menhir_stack$2,_gp_]);
                           case 12:
                            var _gq_=7;
                            if(counter < 50)
                             {var counter$10=counter + 1 | 0;
                              return menhir_run62
                                      (counter$10,menhir_env$5,menhir_stack$2,_gq_)}
                            return caml_trampoline_return
                                    (menhir_run62,[0,menhir_env$5,menhir_stack$2,_gq_]);
                           case 16:
                            var _gr_=menhir_env$5[2][11],_gs_=7;
                            if(counter < 50)
                             {var counter$0=counter + 1 | 0;
                              return menhir_run5
                                      (counter$0,menhir_env$5,menhir_stack$2,_gs_,_gr_)}
                            return caml_trampoline_return
                                    (menhir_run5,[0,menhir_env$5,menhir_stack$2,_gs_,_gr_]);
                           case 19:
                            var _gt_=7;
                            if(counter < 50)
                             {var counter$6=counter + 1 | 0;
                              return menhir_run66
                                      (counter$6,menhir_env$5,menhir_stack$2,_gt_)}
                            return caml_trampoline_return
                                    (menhir_run66,[0,menhir_env$5,menhir_stack$2,_gt_])
                           }
                        else
                         switch(tok$3[0])
                          {case 1:
                            var v$4=tok$3[1],_gu_=menhir_env$5[2][11],_gv_=7;
                            if(counter < 50)
                             {var counter$2=counter + 1 | 0;
                              return menhir_run4
                                      (counter$2,menhir_env$5,menhir_stack$2,_gv_,v$4,_gu_)}
                            return caml_trampoline_return
                                    (menhir_run4,[0,menhir_env$5,menhir_stack$2,_gv_,v$4,_gu_]);
                           case 2:
                            var v$5=tok$3[1],_gw_=menhir_env$5[2][11],_gx_=7;
                            if(counter < 50)
                             {var counter$8=counter + 1 | 0;
                              return menhir_run65
                                      (counter$8,menhir_env$5,menhir_stack$2,_gx_,v$5,_gw_)}
                            return caml_trampoline_return
                                    (menhir_run65,[0,menhir_env$5,menhir_stack$2,_gx_,v$5,_gw_])
                           }
                        if(menhir_env$5[4])throw [0,Assert_failure,_cK_];
                        menhir_env$5[4] = 1;
                        return menhir_errorcase(menhir_env$5,menhir_stack$2,7)}}
                    if(menhir_env$1[4])throw [0,Assert_failure,_cL_];
                    menhir_env$1[4] = 1;
                    var
                     match$2=menhir_stack$2[1],
                     menhir_s$4=match$2[2],
                     menhir_stack$6=match$2[1];
                    return menhir_errorcase
                            (menhir_env$1,menhir_stack$6,menhir_s$4)}
                  if(menhir_env$0[4])throw [0,Assert_failure,_cH_];
                  menhir_env$0[4] = 1;
                  var
                   menhir_s$0=menhir_stack$0[2],
                   menhir_stack$1=menhir_stack$0[1];
                  return menhir_errorcase
                          (menhir_env$0,menhir_stack$1,menhir_s$0)},
               menhir_run5=
                function(counter,menhir_env,menhir_stack,menhir_s,startpos)
                 {var
                   menhir_stack$0=[0,menhir_stack,menhir_s,startpos],
                   menhir_env$0=menhir_discard(menhir_env),
                   tok=menhir_env$0[3];
                  if(typeof tok === "number")
                   switch(tok)
                    {case 6:
                      var _f9_=36;
                      if(counter < 50)
                       {var counter$6=counter + 1 | 0;
                        return menhir_run6
                                (counter$6,menhir_env$0,menhir_stack$0,_f9_)}
                      return caml_trampoline_return
                              (menhir_run6,[0,menhir_env$0,menhir_stack$0,_f9_]);
                     case 9:
                      var _f__=36;
                      if(counter < 50)
                       {var counter$4=counter + 1 | 0;
                        return menhir_run8
                                (counter$4,menhir_env$0,menhir_stack$0,_f__)}
                      return caml_trampoline_return
                              (menhir_run8,[0,menhir_env$0,menhir_stack$0,_f__]);
                     case 12:
                      var _f$_=36;
                      if(counter < 50)
                       {var counter$3=counter + 1 | 0;
                        return menhir_run9
                                (counter$3,menhir_env$0,menhir_stack$0,_f$_)}
                      return caml_trampoline_return
                              (menhir_run9,[0,menhir_env$0,menhir_stack$0,_f$_]);
                     case 14:
                      var _ga_=36;
                      if(counter < 50)
                       {var counter$2=counter + 1 | 0;
                        return menhir_run10
                                (counter$2,menhir_env$0,menhir_stack$0,_ga_)}
                      return caml_trampoline_return
                              (menhir_run10,[0,menhir_env$0,menhir_stack$0,_ga_]);
                     case 20:
                      var _gb_=36;
                      if(counter < 50)
                       {var counter$0=counter + 1 | 0;
                        return menhir_run12
                                (counter$0,menhir_env$0,menhir_stack$0,_gb_)}
                      return caml_trampoline_return
                              (menhir_run12,[0,menhir_env$0,menhir_stack$0,_gb_])
                     }
                  else
                   switch(tok[0])
                    {case 1:
                      var v=tok[1],_gc_=menhir_env$0[2][11],_gd_=36;
                      if(counter < 50)
                       {var counter$5=counter + 1 | 0;
                        return menhir_run7
                                (counter$5,menhir_env$0,menhir_stack$0,_gd_,v,_gc_)}
                      return caml_trampoline_return
                              (menhir_run7,[0,menhir_env$0,menhir_stack$0,_gd_,v,_gc_]);
                     case 2:
                      var v$0=tok[1],_ge_=menhir_env$0[2][11],_gf_=36;
                      if(counter < 50)
                       {var counter$1=counter + 1 | 0;
                        return menhir_run11
                                (counter$1,menhir_env$0,menhir_stack$0,_gf_,v$0,_ge_)}
                      return caml_trampoline_return
                              (menhir_run11,[0,menhir_env$0,menhir_stack$0,_gf_,v$0,_ge_])
                     }
                  if(menhir_env$0[4])throw [0,Assert_failure,_cM_];
                  menhir_env$0[4] = 1;
                  return menhir_errorcase(menhir_env$0,menhir_stack$0,36)},
               menhir_run78=
                function(counter,menhir_env,menhir_stack,menhir_s,id,startpos)
                 {var menhir_env$0=menhir_discard(menhir_env),v=[0,id];
                  if(counter < 50)
                   {var counter$0=counter + 1 | 0;
                    return menhir_goto_arg
                            (counter$0,menhir_env$0,menhir_stack,menhir_s,v)}
                  return caml_trampoline_return
                          (menhir_goto_arg,[0,menhir_env$0,menhir_stack,menhir_s,v])},
               menhir_run79=
                function(counter,menhir_env,menhir_stack,menhir_s)
                 {var
                   menhir_stack$0=[0,menhir_stack,menhir_s],
                   menhir_env$0=menhir_discard(menhir_env),
                   tok=menhir_env$0[3];
                  if(typeof tok === "number")
                   {if(16 === tok)
                     {var _f5_=menhir_env$0[2][11],_f6_=6;
                      if(counter < 50)
                       {var counter$0=counter + 1 | 0;
                        return menhir_run5
                                (counter$0,menhir_env$0,menhir_stack$0,_f6_,_f5_)}
                      return caml_trampoline_return
                              (menhir_run5,[0,menhir_env$0,menhir_stack$0,_f6_,_f5_])}}
                  else
                   if(1 === tok[0])
                    {var v=tok[1],_f7_=menhir_env$0[2][11],_f8_=6;
                     if(counter < 50)
                      {var counter$1=counter + 1 | 0;
                       return menhir_run4
                               (counter$1,menhir_env$0,menhir_stack$0,_f8_,v,_f7_)}
                     return caml_trampoline_return
                             (menhir_run4,[0,menhir_env$0,menhir_stack$0,_f8_,v,_f7_])}
                  if(menhir_env$0[4])throw [0,Assert_failure,_cN_];
                  menhir_env$0[4] = 1;
                  return menhir_errorcase(menhir_env$0,menhir_stack$0,6)},
               menhir_reduce26$0=
                function(counter,menhir_env$11,menhir_stack$9,menhir_s$7)
                 {var menhir_stack=menhir_stack$9,menhir_s=menhir_s$7,v=0;
                  for(;;)
                   {var menhir_stack$0=[0,menhir_stack,menhir_s,v];
                    if(38 <= menhir_s)
                     {if(! (39 <= menhir_s))
                       {var
                         xs=menhir_stack$0[3],
                         match=menhir_stack$0[1],
                         menhir_s$2=match[2],
                         menhir_stack$3=match[1],
                         v$5=[0,0,xs],
                         menhir_stack=menhir_stack$3,
                         menhir_s=menhir_s$2,
                         v=v$5;
                        continue}}
                    else
                     {var switch$0=0;
                      if(! (5 <= menhir_s))
                       switch(menhir_s)
                        {case 4:switch$0 = 1;break;
                         case 1:
                         case 2:break;
                         default:
                          if(menhir_env$11[4])throw [0,Assert_failure,_cR_];
                          var tok$1=menhir_env$11[3];
                          if(typeof tok$1 === "number")
                           {if(18 === tok$1)
                             {var
                               menhir_env$0=menhir_discard(menhir_env$11),
                               tok$2=menhir_env$0[3];
                              if(typeof tok$2 === "number")
                               switch(tok$2)
                                {case 23:
                                  var
                                   menhir_s$5=menhir_stack$0[2],
                                   menhir_stack$6=menhir_stack$0[1];
                                  return menhir_goto_headers
                                          (menhir_env$0,menhir_stack$6,menhir_s$5,0);
                                 case 24:
                                  var
                                   menhir_s$6=menhir_stack$0[2],
                                   menhir_stack$7=menhir_stack$0[1];
                                  return menhir_goto_headers
                                          (menhir_env$0,menhir_stack$7,menhir_s$6,0)
                                 }
                              else
                               if(2 === tok$2[0])
                                {var
                                  id=tok$2[1],
                                  menhir_env$1=menhir_discard(menhir_env$0),
                                  tok$3=menhir_env$1[3];
                                 if(typeof tok$3 === "number" && 21 === tok$3)
                                  {var
                                    menhir_env$2=menhir_discard(menhir_env$1),
                                    tok$4=menhir_env$2[3];
                                   if(typeof tok$4 === "number")
                                    {if(8 === tok$4)
                                      {var menhir_env$3=menhir_discard(menhir_env$2),v$6=[0,id,0];
                                       if(counter < 50)
                                        {var counter$8=counter + 1 | 0;
                                         return menhir_goto_definition
                                                 (counter$8,menhir_env$3,menhir_stack$0,v$6)}
                                       return caml_trampoline_return
                                               (menhir_goto_definition,[0,menhir_env$3,menhir_stack$0,v$6])}}
                                   else
                                    switch(tok$4[0])
                                     {case 0:
                                       var
                                        v$7=tok$4[1],
                                        menhir_env$4=menhir_discard(menhir_env$2),
                                        v$8=[0,id,[0,v$7]];
                                       if(counter < 50)
                                        {var counter$9=counter + 1 | 0;
                                         return menhir_goto_definition
                                                 (counter$9,menhir_env$4,menhir_stack$0,v$8)}
                                       return caml_trampoline_return
                                               (menhir_goto_definition,[0,menhir_env$4,menhir_stack$0,v$8]);
                                      case 1:
                                       var
                                        v$9=tok$4[1],
                                        menhir_env$5=menhir_discard(menhir_env$2),
                                        v$10=[0,id,[1,v$9]];
                                       if(counter < 50)
                                        {var counter$10=counter + 1 | 0;
                                         return menhir_goto_definition
                                                 (counter$10,menhir_env$5,menhir_stack$0,v$10)}
                                       return caml_trampoline_return
                                               (menhir_goto_definition,
                                                [0,menhir_env$5,menhir_stack$0,v$10]);
                                      case 3:
                                       var
                                        v$11=tok$4[1],
                                        menhir_env$6=menhir_discard(menhir_env$2),
                                        v$12=[0,id,[2,v$11]];
                                       if(counter < 50)
                                        {var counter$11=counter + 1 | 0;
                                         return menhir_goto_definition
                                                 (counter$11,menhir_env$6,menhir_stack$0,v$12)}
                                       return caml_trampoline_return
                                               (menhir_goto_definition,
                                                [0,menhir_env$6,menhir_stack$0,v$12])
                                      }
                                   if(menhir_env$2[4])throw [0,Assert_failure,_cU_];
                                   menhir_env$2[4] = 1;
                                   throw eRR}
                                 if(menhir_env$1[4])throw [0,Assert_failure,_cV_];
                                 menhir_env$1[4] = 1;
                                 throw eRR}
                              if(menhir_env$0[4])throw [0,Assert_failure,_cT_];
                              menhir_env$0[4] = 1;
                              var
                               menhir_s$4=menhir_stack$0[2],
                               menhir_stack$5=menhir_stack$0[1];
                              return menhir_errorcase
                                      (menhir_env$0,menhir_stack$5,menhir_s$4)}}
                          else
                           if(2 === tok$1[0])
                            {var
                              v$13=tok$1[1],
                              startpos$0=menhir_env$11[2][11],
                              menhir_stack$8=[0,menhir_stack$0,v$13,startpos$0],
                              menhir_env$7=menhir_discard(menhir_env$11),
                              tok$5=menhir_env$7[3];
                             if(typeof tok$5 === "number")
                              {if(17 === tok$5)
                                {var
                                  menhir_env$8=menhir_discard(menhir_env$7),
                                  tok$6=menhir_env$8[3];
                                 if(typeof tok$6 === "number" && 21 === tok$6)
                                  {var
                                    menhir_env$9=menhir_discard(menhir_env$8),
                                    tok$7=menhir_env$9[3];
                                   if(typeof tok$7 === "number")
                                    switch(tok$7)
                                     {case 6:
                                       var _fN_=2;
                                       if(counter < 50)
                                        {var counter$25=counter + 1 | 0;
                                         return menhir_run6
                                                 (counter$25,menhir_env$9,menhir_stack$8,_fN_)}
                                       return caml_trampoline_return
                                               (menhir_run6,[0,menhir_env$9,menhir_stack$8,_fN_]);
                                      case 9:
                                       var _fO_=2;
                                       if(counter < 50)
                                        {var counter$21=counter + 1 | 0;
                                         return menhir_run8
                                                 (counter$21,menhir_env$9,menhir_stack$8,_fO_)}
                                       return caml_trampoline_return
                                               (menhir_run8,[0,menhir_env$9,menhir_stack$8,_fO_]);
                                      case 12:
                                       var _fP_=2;
                                       if(counter < 50)
                                        {var counter$19=counter + 1 | 0;
                                         return menhir_run9
                                                 (counter$19,menhir_env$9,menhir_stack$8,_fP_)}
                                       return caml_trampoline_return
                                               (menhir_run9,[0,menhir_env$9,menhir_stack$8,_fP_]);
                                      case 14:
                                       var _fQ_=2;
                                       if(counter < 50)
                                        {var counter$17=counter + 1 | 0;
                                         return menhir_run10
                                                 (counter$17,menhir_env$9,menhir_stack$8,_fQ_)}
                                       return caml_trampoline_return
                                               (menhir_run10,[0,menhir_env$9,menhir_stack$8,_fQ_]);
                                      case 20:
                                       var _fR_=2;
                                       if(counter < 50)
                                        {var counter$13=counter + 1 | 0;
                                         return menhir_run12
                                                 (counter$13,menhir_env$9,menhir_stack$8,_fR_)}
                                       return caml_trampoline_return
                                               (menhir_run12,[0,menhir_env$9,menhir_stack$8,_fR_])
                                      }
                                   else
                                    switch(tok$7[0])
                                     {case 1:
                                       var v$14=tok$7[1],_fS_=menhir_env$9[2][11],_fT_=2;
                                       if(counter < 50)
                                        {var counter$23=counter + 1 | 0;
                                         return menhir_run7
                                                 (counter$23,menhir_env$9,menhir_stack$8,_fT_,v$14,_fS_)}
                                       return caml_trampoline_return
                                               (menhir_run7,[0,menhir_env$9,menhir_stack$8,_fT_,v$14,_fS_]);
                                      case 2:
                                       var v$15=tok$7[1],_fU_=menhir_env$9[2][11],_fV_=2;
                                       if(counter < 50)
                                        {var counter$15=counter + 1 | 0;
                                         return menhir_run11
                                                 (counter$15,menhir_env$9,menhir_stack$8,_fV_,v$15,_fU_)}
                                       return caml_trampoline_return
                                               (menhir_run11,
                                                [0,menhir_env$9,menhir_stack$8,_fV_,v$15,_fU_])
                                      }
                                   if(menhir_env$9[4])throw [0,Assert_failure,_cW_];
                                   menhir_env$9[4] = 1;
                                   return menhir_errorcase(menhir_env$9,menhir_stack$8,2)}
                                 if(menhir_env$8[4])throw [0,Assert_failure,_cX_];
                                 menhir_env$8[4] = 1;
                                 throw eRR}
                               if(21 === tok$5)
                                {var
                                  menhir_env$10=menhir_discard(menhir_env$7),
                                  tok$8=menhir_env$10[3];
                                 if(typeof tok$8 === "number")
                                  switch(tok$8)
                                   {case 6:
                                     var _fW_=1;
                                     if(counter < 50)
                                      {var counter$24=counter + 1 | 0;
                                       return menhir_run6
                                               (counter$24,menhir_env$10,menhir_stack$8,_fW_)}
                                     return caml_trampoline_return
                                             (menhir_run6,[0,menhir_env$10,menhir_stack$8,_fW_]);
                                    case 9:
                                     var _fX_=1;
                                     if(counter < 50)
                                      {var counter$20=counter + 1 | 0;
                                       return menhir_run8
                                               (counter$20,menhir_env$10,menhir_stack$8,_fX_)}
                                     return caml_trampoline_return
                                             (menhir_run8,[0,menhir_env$10,menhir_stack$8,_fX_]);
                                    case 12:
                                     var _fY_=1;
                                     if(counter < 50)
                                      {var counter$18=counter + 1 | 0;
                                       return menhir_run9
                                               (counter$18,menhir_env$10,menhir_stack$8,_fY_)}
                                     return caml_trampoline_return
                                             (menhir_run9,[0,menhir_env$10,menhir_stack$8,_fY_]);
                                    case 14:
                                     var _fZ_=1;
                                     if(counter < 50)
                                      {var counter$16=counter + 1 | 0;
                                       return menhir_run10
                                               (counter$16,menhir_env$10,menhir_stack$8,_fZ_)}
                                     return caml_trampoline_return
                                             (menhir_run10,[0,menhir_env$10,menhir_stack$8,_fZ_]);
                                    case 20:
                                     var _f0_=1;
                                     if(counter < 50)
                                      {var counter$12=counter + 1 | 0;
                                       return menhir_run12
                                               (counter$12,menhir_env$10,menhir_stack$8,_f0_)}
                                     return caml_trampoline_return
                                             (menhir_run12,[0,menhir_env$10,menhir_stack$8,_f0_])
                                    }
                                 else
                                  switch(tok$8[0])
                                   {case 1:
                                     var v$16=tok$8[1],_f1_=menhir_env$10[2][11],_f2_=1;
                                     if(counter < 50)
                                      {var counter$22=counter + 1 | 0;
                                       return menhir_run7
                                               (counter$22,menhir_env$10,menhir_stack$8,_f2_,v$16,_f1_)}
                                     return caml_trampoline_return
                                             (menhir_run7,
                                              [0,menhir_env$10,menhir_stack$8,_f2_,v$16,_f1_]);
                                    case 2:
                                     var v$17=tok$8[1],_f3_=menhir_env$10[2][11],_f4_=1;
                                     if(counter < 50)
                                      {var counter$14=counter + 1 | 0;
                                       return menhir_run11
                                               (counter$14,menhir_env$10,menhir_stack$8,_f4_,v$17,_f3_)}
                                     return caml_trampoline_return
                                             (menhir_run11,
                                              [0,menhir_env$10,menhir_stack$8,_f4_,v$17,_f3_])
                                    }
                                 if(menhir_env$10[4])throw [0,Assert_failure,_cY_];
                                 menhir_env$10[4] = 1;
                                 return menhir_errorcase(menhir_env$10,menhir_stack$8,1)}}
                             if(menhir_env$7[4])throw [0,Assert_failure,_cZ_];
                             menhir_env$7[4] = 1;
                             throw eRR}
                          if(menhir_env$11[4])throw [0,Assert_failure,_cS_];
                          menhir_env$11[4] = 1;
                          var
                           menhir_s$3=menhir_stack$0[2],
                           menhir_stack$4=menhir_stack$0[1];
                          return menhir_errorcase
                                  (menhir_env$11,menhir_stack$4,menhir_s$3)}
                      if(! switch$0)return menhir_fail(0)}
                    if(menhir_env$11[4])throw [0,Assert_failure,_cO_];
                    var tok=menhir_env$11[3];
                    if(typeof tok === "number")
                     switch(tok)
                      {case 16:
                        var _fB_=menhir_env$11[2][11],_fC_=37;
                        if(counter < 50)
                         {var counter$2=counter + 1 | 0;
                          return menhir_run5
                                  (counter$2,menhir_env$11,menhir_stack$0,_fC_,_fB_)}
                        return caml_trampoline_return
                                (menhir_run5,[0,menhir_env$11,menhir_stack$0,_fC_,_fB_]);
                       case 24:
                        var
                         menhir_s$0=menhir_stack$0[2],
                         menhir_stack$1=menhir_stack$0[1];
                        return menhir_goto_ast
                                (menhir_env$11,menhir_stack$1,menhir_s$0,0)
                       }
                    else
                     switch(tok[0])
                      {case 1:
                        var v$0=tok[1],_fD_=menhir_env$11[2][11],_fE_=37;
                        if(counter < 50)
                         {var counter$5=counter + 1 | 0;
                          return menhir_run4
                                  (counter$5,menhir_env$11,menhir_stack$0,_fE_,v$0,_fD_)}
                        return caml_trampoline_return
                                (menhir_run4,[0,menhir_env$11,menhir_stack$0,_fE_,v$0,_fD_]);
                       case 2:
                        var
                         v$1=tok[1],
                         startpos=menhir_env$11[2][11],
                         menhir_stack$2=[0,menhir_stack$0,37,v$1,startpos],
                         menhir_env=menhir_discard(menhir_env$11),
                         tok$0=menhir_env[3];
                        if(typeof tok$0 === "number")
                         switch(tok$0)
                          {case 15:
                            var _fF_=14;
                            if(counter < 50)
                             {var counter$4=counter + 1 | 0;
                              return menhir_run54
                                      (counter$4,menhir_env,menhir_stack$2,_fF_)}
                            return caml_trampoline_return
                                    (menhir_run54,[0,menhir_env,menhir_stack$2,_fF_]);
                           case 16:
                            var _fG_=menhir_env[2][11],_fH_=14;
                            if(counter < 50)
                             {var counter$3=counter + 1 | 0;
                              return menhir_run5
                                      (counter$3,menhir_env,menhir_stack$2,_fH_,_fG_)}
                            return caml_trampoline_return
                                    (menhir_run5,[0,menhir_env,menhir_stack$2,_fH_,_fG_]);
                           case 19:
                            var _fI_=14;
                            if(counter < 50)
                             {var counter$0=counter + 1 | 0;
                              return menhir_run79
                                      (counter$0,menhir_env,menhir_stack$2,_fI_)}
                            return caml_trampoline_return
                                    (menhir_run79,[0,menhir_env,menhir_stack$2,_fI_]);
                           case 17:
                           case 23:
                           case 24:
                            var menhir_s$1=14,v$2=0;
                            if(counter < 50)
                             {var counter$7=counter + 1 | 0;
                              return menhir_goto_loption_separated_
                                      (counter$7,menhir_env,menhir_stack$2,menhir_s$1,v$2)}
                            return caml_trampoline_return
                                    (menhir_goto_loption_separated_,
                                     [0,menhir_env,menhir_stack$2,menhir_s$1,v$2])
                           }
                        else
                         switch(tok$0[0])
                          {case 1:
                            var v$3=tok$0[1],_fJ_=menhir_env[2][11],_fK_=14;
                            if(counter < 50)
                             {var counter$6=counter + 1 | 0;
                              return menhir_run4
                                      (counter$6,menhir_env,menhir_stack$2,_fK_,v$3,_fJ_)}
                            return caml_trampoline_return
                                    (menhir_run4,[0,menhir_env,menhir_stack$2,_fK_,v$3,_fJ_]);
                           case 2:
                            var v$4=tok$0[1],_fL_=menhir_env[2][11],_fM_=14;
                            if(counter < 50)
                             {var counter$1=counter + 1 | 0;
                              return menhir_run78
                                      (counter$1,menhir_env,menhir_stack$2,_fM_,v$4,_fL_)}
                            return caml_trampoline_return
                                    (menhir_run78,[0,menhir_env,menhir_stack$2,_fM_,v$4,_fL_])
                           }
                        if(menhir_env[4])throw [0,Assert_failure,_cQ_];
                        menhir_env[4] = 1;
                        return menhir_errorcase(menhir_env,menhir_stack$2,14)
                       }
                    if(menhir_env$11[4])throw [0,Assert_failure,_cP_];
                    menhir_env$11[4] = 1;
                    return menhir_errorcase(menhir_env$11,menhir_stack$0,37)}},
               menhir_run1$0=
                function(counter,menhir_env,menhir_stack,menhir_s)
                 {var
                   menhir_env$0=menhir_env,
                   menhir_stack$0=menhir_stack,
                   menhir_s$0=menhir_s;
                  for(;;)
                   {var
                     menhir_stack$1=[0,menhir_stack$0,menhir_s$0],
                     menhir_env$1=menhir_discard(menhir_env$0),
                     tok=menhir_env$1[3],
                     switch$0=0;
                    if(typeof tok === "number")
                     switch(tok)
                      {case 23:
                        var
                         menhir_env$0=menhir_env$1,
                         menhir_stack$0=menhir_stack$1,
                         menhir_s$0=38;
                        continue;
                       case 16:
                       case 18:
                       case 24:switch$0 = 1;break
                       }
                    else
                     switch(tok[0]){case 0:case 3:break;default:switch$0 = 1}
                    if(switch$0)
                     {var _fA_=38;
                      if(counter < 50)
                       {var counter$0=counter + 1 | 0;
                        return menhir_reduce26$0
                                (counter$0,menhir_env$1,menhir_stack$1,_fA_)}
                      return caml_trampoline_return
                              (menhir_reduce26$0,[0,menhir_env$1,menhir_stack$1,_fA_])}
                    if(menhir_env$1[4])throw [0,Assert_failure,_c0_];
                    menhir_env$1[4] = 1;
                    return menhir_errorcase(menhir_env$1,menhir_stack$1,38)}},
               menhir_reduce26=
                function(menhir_env,menhir_stack,menhir_s)
                 {return caml_trampoline
                          (menhir_reduce26$0(0,menhir_env,menhir_stack,menhir_s))},
               menhir_run1=
                function(menhir_env,menhir_stack,menhir_s)
                 {return caml_trampoline
                          (menhir_run1$0(0,menhir_env,menhir_stack,menhir_s))},
               ast=
                function(lexer,lexbuf)
                 {var
                   menhir_env=[0,lexer,lexbuf,0,0],
                   menhir_stack=[0,0,menhir_env[2][12]],
                   menhir_env$0=menhir_discard(menhir_env),
                   tok=menhir_env$0[3],
                   switch$0=0;
                  if(typeof tok === "number")
                   switch(tok)
                    {case 23:return menhir_run1(menhir_env$0,menhir_stack,39);
                     case 16:
                     case 24:switch$0 = 1;break
                     }
                  else
                   switch(tok[0]){case 0:case 3:break;default:switch$0 = 1}
                  if(switch$0)
                   return menhir_reduce26(menhir_env$0,menhir_stack,39);
                  if(menhir_env$0[4])throw [0,Assert_failure,_c1_];
                  menhir_env$0[4] = 1;
                  return menhir_errorcase(menhir_env$0,menhir_stack,39)},
               headers=
                function(lexer,lexbuf)
                 {var
                   menhir_env=[0,lexer,lexbuf,0,0],
                   menhir_stack=[0,0,menhir_env[2][12]],
                   menhir_env$0=menhir_discard(menhir_env),
                   tok=menhir_env$0[3],
                   switch$0=0;
                  if(typeof tok === "number")
                   switch(tok)
                    {case 23:return menhir_run1(menhir_env$0,menhir_stack,3);
                     case 18:switch$0 = 1;break
                     }
                  else
                   if(2 === tok[0])switch$0 = 1;
                  if(switch$0)
                   return menhir_reduce26(menhir_env$0,menhir_stack,3);
                  if(menhir_env$0[4])throw [0,Assert_failure,_c2_];
                  menhir_env$0[4] = 1;
                  return menhir_errorcase(menhir_env$0,menhir_stack,3)},
               Parser=[0,eRR,headers,ast];
              caml_register_global(489,Parser,"Parser");
              var
               SyntaxError=[248,cst_Lexer_SyntaxError,caml_fresh_oo_id(0)],
               next_line=
                function(lexbuf)
                 {var pos=lexbuf[12];
                  lexbuf[12] = [0,pos[1],pos[2] + 1 | 0,lexbuf[6],pos[4]];
                  return 0},
               eof_reached=function(lexbuf){lexbuf[9] = 1;return 0},
               read_comment$0=
                function(counter,lexbuf)
                 {var _fz_=82;
                  if(counter < 50)
                   {var counter$0=counter + 1 | 0;
                    return ocaml_lex_read_comment_rec$0(counter$0,lexbuf,_fz_)}
                  return caml_trampoline_return
                          (ocaml_lex_read_comment_rec$0,[0,lexbuf,_fz_])},
               ocaml_lex_read_comment_rec$0=
                function(counter,lexbuf,ocaml_lex_state)
                 {var ocaml_lex_state$0=ocaml_lex_state;
                  for(;;)
                   {var
                     ocaml_lex_state$1=
                      caml_call3
                       (Stdlib_lexing[20],
                        ocaml_lex_tables,
                        ocaml_lex_state$0,
                        lexbuf);
                    if(2 < ocaml_lex_state$1 >>> 0)
                     {caml_call1(lexbuf[1],lexbuf);
                      var ocaml_lex_state$0=ocaml_lex_state$1;
                      continue}
                    switch(ocaml_lex_state$1)
                     {case 0:next_line(lexbuf);return 23;
                      case 1:eof_reached(lexbuf);return 24;
                      default:
                       if(counter < 50)
                        {var counter$0=counter + 1 | 0;
                         return read_comment$0(counter$0,lexbuf)}
                       return caml_trampoline_return(read_comment$0,[0,lexbuf])}}},
               read_comment=
                function(lexbuf)
                 {return caml_trampoline(read_comment$0(0,lexbuf))},
               ocaml_lex_read_comment_rec=
                function(lexbuf,ocaml_lex_state)
                 {return caml_trampoline
                          (ocaml_lex_read_comment_rec$0(0,lexbuf,ocaml_lex_state))},
               read_string$0=
                function(counter,buf,lexbuf)
                 {var _fy_=68;
                  if(counter < 50)
                   {var counter$0=counter + 1 | 0;
                    return ocaml_lex_read_string_rec$0
                            (counter$0,buf,lexbuf,_fy_)}
                  return caml_trampoline_return
                          (ocaml_lex_read_string_rec$0,[0,buf,lexbuf,_fy_])},
               ocaml_lex_read_string_rec$0=
                function(counter,buf,lexbuf,ocaml_lex_state)
                 {var ocaml_lex_state$0=ocaml_lex_state;
                  for(;;)
                   {var
                     ocaml_lex_state$1=
                      caml_call3
                       (Stdlib_lexing[20],
                        ocaml_lex_tables,
                        ocaml_lex_state$0,
                        lexbuf);
                    if(11 < ocaml_lex_state$1 >>> 0)
                     {caml_call1(lexbuf[1],lexbuf);
                      var ocaml_lex_state$0=ocaml_lex_state$1;
                      continue}
                    switch(ocaml_lex_state$1)
                     {case 0:return [0,caml_call1(Stdlib_buffer[2],buf)];
                      case 1:
                       caml_call2(Stdlib_buffer[10],buf,47);
                       if(counter < 50)
                        {var counter$0=counter + 1 | 0;
                         return read_string$0(counter$0,buf,lexbuf)}
                       return caml_trampoline_return(read_string$0,[0,buf,lexbuf]);
                      case 2:
                       caml_call2(Stdlib_buffer[10],buf,92);
                       if(counter < 50)
                        {var counter$1=counter + 1 | 0;
                         return read_string$0(counter$1,buf,lexbuf)}
                       return caml_trampoline_return(read_string$0,[0,buf,lexbuf]);
                      case 3:
                       caml_call2(Stdlib_buffer[10],buf,8);
                       if(counter < 50)
                        {var counter$2=counter + 1 | 0;
                         return read_string$0(counter$2,buf,lexbuf)}
                       return caml_trampoline_return(read_string$0,[0,buf,lexbuf]);
                      case 4:
                       caml_call2(Stdlib_buffer[10],buf,12);
                       if(counter < 50)
                        {var counter$3=counter + 1 | 0;
                         return read_string$0(counter$3,buf,lexbuf)}
                       return caml_trampoline_return(read_string$0,[0,buf,lexbuf]);
                      case 5:
                       caml_call2(Stdlib_buffer[10],buf,10);
                       if(counter < 50)
                        {var counter$4=counter + 1 | 0;
                         return read_string$0(counter$4,buf,lexbuf)}
                       return caml_trampoline_return(read_string$0,[0,buf,lexbuf]);
                      case 6:
                       caml_call2(Stdlib_buffer[10],buf,13);
                       if(counter < 50)
                        {var counter$5=counter + 1 | 0;
                         return read_string$0(counter$5,buf,lexbuf)}
                       return caml_trampoline_return(read_string$0,[0,buf,lexbuf]);
                      case 7:
                       caml_call2(Stdlib_buffer[10],buf,9);
                       if(counter < 50)
                        {var counter$6=counter + 1 | 0;
                         return read_string$0(counter$6,buf,lexbuf)}
                       return caml_trampoline_return(read_string$0,[0,buf,lexbuf]);
                      case 8:
                       var _fw_=caml_call1(Stdlib_lexing[8],lexbuf);
                       caml_call2(Stdlib_buffer[14],buf,_fw_);
                       if(counter < 50)
                        {var counter$7=counter + 1 | 0;
                         return read_string$0(counter$7,buf,lexbuf)}
                       return caml_trampoline_return(read_string$0,[0,buf,lexbuf]);
                      case 9:throw [0,SyntaxError,cst_String_cannot_be_multiline];
                      case 10:throw [0,SyntaxError,cst_String_is_not_terminated];
                      default:
                       var _fx_=caml_call1(Stdlib_lexing[8],lexbuf);
                       throw [0,
                              SyntaxError,
                              caml_call2(Stdlib[28],cst_Illegal_string_character,_fx_)]}}},
               read_string=
                function(buf,lexbuf)
                 {return caml_trampoline(read_string$0(0,buf,lexbuf))},
               ocaml_lex_read_string_rec=
                function(buf,lexbuf,ocaml_lex_state)
                 {return caml_trampoline
                          (ocaml_lex_read_string_rec$0(0,buf,lexbuf,ocaml_lex_state))},
               read$0=
                function(counter,lexbuf)
                 {var _fv_=0;
                  if(counter < 50)
                   {var counter$0=counter + 1 | 0;
                    return ocaml_lex_read_rec$0(counter$0,lexbuf,_fv_)}
                  return caml_trampoline_return
                          (ocaml_lex_read_rec$0,[0,lexbuf,_fv_])},
               ocaml_lex_read_rec$0=
                function(counter,lexbuf,ocaml_lex_state)
                 {var ocaml_lex_state$0=ocaml_lex_state;
                  for(;;)
                   {var
                     ocaml_lex_state$1=
                      caml_call3
                       (Stdlib_lexing[20],
                        ocaml_lex_tables,
                        ocaml_lex_state$0,
                        lexbuf);
                    if(40 < ocaml_lex_state$1 >>> 0)
                     {caml_call1(lexbuf[1],lexbuf);
                      var ocaml_lex_state$0=ocaml_lex_state$1;
                      continue}
                    switch(ocaml_lex_state$1)
                     {case 0:return 24;
                      case 1:return 18;
                      case 2:return 8;
                      case 3:return _c3_;
                      case 4:return _c4_;
                      case 5:return 13;
                      case 6:return 2;
                      case 7:return 22;
                      case 8:return 10;
                      case 9:return 28;
                      case 10:return 29;
                      case 11:return read_comment(lexbuf);
                      case 12:
                       if(counter < 50)
                        {var counter$0=counter + 1 | 0;
                         return read$0(counter$0,lexbuf)}
                       return caml_trampoline_return(read$0,[0,lexbuf]);
                      case 13:
                       next_line(lexbuf);
                       if(counter < 50)
                        {var counter$1=counter + 1 | 0;
                         return read$0(counter$1,lexbuf)}
                       return caml_trampoline_return(read$0,[0,lexbuf]);
                      case 14:next_line(lexbuf);return 23;
                      case 15:
                       return [1,
                               uint32_of_str(caml_call1(Stdlib_lexing[8],lexbuf))];
                      case 16:return [2,caml_call1(Stdlib_lexing[8],lexbuf)];
                      case 17:
                       return read_string(caml_call1(Stdlib_buffer[1],17),lexbuf);
                      case 18:return 21;
                      case 19:return 19;
                      case 20:return 15;
                      case 21:return 4;
                      case 22:return 16;
                      case 23:return 5;
                      case 24:return 26;
                      case 25:return 20;
                      case 26:return 17;
                      case 27:return 27;
                      case 28:return 14;
                      case 29:return 3;
                      case 30:return 6;
                      case 31:return 12;
                      case 32:return 1;
                      case 33:return 25;
                      case 34:return 11;
                      case 35:return 30;
                      case 36:return 7;
                      case 37:return 0;
                      case 38:return 9;
                      case 39:eof_reached(lexbuf);return 24;
                      default:
                       var _fu_=caml_call1(Stdlib_lexing[8],lexbuf);
                       throw [0,
                              SyntaxError,
                              caml_call2(Stdlib[28],cst_Unexpected_char,_fu_)]}}},
               read=function(lexbuf){return caml_trampoline(read$0(0,lexbuf))},
               ocaml_lex_read_rec=
                function(lexbuf,ocaml_lex_state)
                 {return caml_trampoline
                          (ocaml_lex_read_rec$0(0,lexbuf,ocaml_lex_state))},
               Lexer=
                [0,
                 SyntaxError,
                 next_line,
                 eof_reached,
                 ocaml_lex_tables,
                 read,
                 ocaml_lex_read_rec,
                 read_string,
                 ocaml_lex_read_string_rec,
                 read_comment,
                 ocaml_lex_read_comment_rec];
              caml_register_global(492,Lexer,"Lexer");
              var
               InvalidContent=
                [248,cst_Parse_InvalidContent,caml_fresh_oo_id(0)],
               print_position=
                function(fmt,pos)
                 {return caml_call5
                          (Stdlib_format[126],
                           fmt,
                           _c5_,
                           pos[1],
                           pos[2],
                           (pos[4] - pos[3] | 0) + 1 | 0)},
               print_lexbuf_pos=
                function(fmt,lexbuf){return print_position(fmt,lexbuf[12])},
               parse_with_error=
                function(f,lexbuf)
                 {try
                   {var _ft_=caml_call1(f,lexbuf);return _ft_}
                  catch(exn)
                   {exn = caml_wrap_exception(exn);
                    if(exn[1] === SyntaxError)
                     {var msg=exn[2];
                      throw [0,
                             InvalidContent,
                             caml_call4
                              (Stdlib_format[130],_c6_,print_lexbuf_pos,lexbuf,msg)]}
                    if(exn === eRR)
                     throw [0,
                            InvalidContent,
                            caml_call3(Stdlib_format[130],_c7_,print_lexbuf_pos,lexbuf)];
                    throw exn}},
               from_lexbuf=
                function(headers$0,lexbuf)
                 {var
                   headers$1=
                    headers$0
                     ?parse_with_error
                       (function(_fs_){return headers(read,_fs_)},lexbuf)
                     :0,
                   ast$0=
                    parse_with_error
                     (function(_fr_){return ast(read,_fr_)},lexbuf);
                  return [0,headers$1,ast$0]},
               from_filename=
                function(headers,filename)
                 {var
                   channel=caml_call1(Stdlib[79],filename),
                   lexbuf=caml_call2(Stdlib_lexing[2],0,channel),
                   _fq_=lexbuf[12];
                  lexbuf[12] = [0,filename,_fq_[2],_fq_[3],_fq_[4]];
                  var res=from_lexbuf(headers,lexbuf);
                  caml_call1(Stdlib[93],channel);
                  return res},
               from_str=
                function(headers,str)
                 {return from_lexbuf
                          (headers,caml_call2(Stdlib_lexing[3],0,str))},
               parsed_ast_to_arm=
                function(optimize,env,lst)
                 {try
                   {var
                     _fn_=to_arm(env,lst),
                     _fo_=optimize?tweak_arm:do_not_tweak_arm,
                     _fp_=_fo_(_fn_);
                    return _fp_}
                  catch(exn)
                   {exn = caml_wrap_exception(exn);
                    if(exn[1] === CommandError)
                     {var pos=exn[2];
                      throw [0,
                             InvalidContent,
                             caml_call3(Stdlib_format[130],_c8_,print_position,pos)]}
                    throw exn}},
               parsed_content_to_arm=
                function(fmt,optimize,env,param)
                 {var
                   lst=param[2],
                   headers=param[1],
                   env$0=concat_env(env,env_from_headers(fmt,headers));
                  return parsed_ast_to_arm(optimize,env$0,lst)},
               Parse=
                [0,
                 InvalidContent,
                 from_lexbuf,
                 from_str,
                 from_filename,
                 parsed_ast_to_arm,
                 parsed_content_to_arm];
              caml_register_global(493,Parse,"Parse");
              var
               StrMap$0=caml_call1(Stdlib_map[1],[0,Stdlib_string[5]]),
               parse=
                function(lexbuf)
                 {lexbuf[9] = 0;
                  var main_file=from_lexbuf(1,lexbuf),acc=StrMap$0[1];
                  for(;;)
                   {if(lexbuf[9])return [0,main_file,acc];
                    var
                     match=from_lexbuf(1,lexbuf),
                     arm=match[2],
                     headers=match[1],
                     match$0=get_param(headers,cst_filename);
                    if(typeof match$0 === "number")
                     var fn=caml_call1(Stdlib[2],cst_Please_specify_the_filenam);
                    else
                     if(0 === match$0[0])
                      var fn$0=match$0[1],fn=fn$0;
                     else
                      var fn=caml_call1(Stdlib[2],cst_Invalid_headers);
                    var
                     acc$0=caml_call3(StrMap$0[4],fn,[0,headers,arm],acc),
                     acc=acc$0;
                    continue}},
               from_filename$0=
                function(filename)
                 {var
                   channel=caml_call1(Stdlib[79],filename),
                   lexbuf=caml_call2(Stdlib_lexing[2],0,channel),
                   _fm_=lexbuf[12];
                  lexbuf[12] = [0,filename,_fm_[2],_fm_[3],_fm_[4]];
                  var res=parse(lexbuf);
                  caml_call1(Stdlib[93],channel);
                  return res},
               from_str$0=
                function(str)
                 {return parse(caml_call2(Stdlib_lexing[3],0,str))},
               main_file=function(param){var mf=param[1];return mf},
               get_file=
                function(name,param)
                 {var files=param[2];
                  return caml_call2(StrMap$0[28],name,files)},
               Fs=[0,from_str$0,from_filename$0,main_file,get_file];
              caml_register_global(494,Fs,"Fs");
              var
               load_from_dir=
                function(env,dirname)
                 {try
                   {var
                     _fb_=enumerate_files(dirname,cst_txt),
                     _fc_=
                      function(x)
                       {var
                         path=caml_call2(Stdlib_filename[4],dirname,x),
                         _fj_=caml_call1(Stdlib_filename[13],x),
                         str=caml_call1(Stdlib_filename[11],_fj_),
                         i=runtime.caml_int_of_string(str),
                         arm=
                          parsed_content_to_arm(dummy_fmt,0,env,from_filename(0,path));
                        function _fk_(arm)
                         {var _fl_=arm_to_binary(arm);
                          return preferred_code
                                  (caml_call2(Stdlib_list[19],codes_for_command,_fl_))}
                        var codes=caml_call2(Stdlib_list[19],_fk_,arm);
                        return [0,i,codes]},
                     _fd_=caml_call2(Stdlib_list[19],_fc_,_fb_),
                     _fe_=
                      function(param,_fi_)
                       {var j=_fi_[1],i=param[1];
                        return runtime.caml_int_compare(i,j)},
                     _ff_=caml_call2(Stdlib_list[56],_fe_,_fd_),
                     _fg_=function(x){return [0,x,0]}(_ff_);
                    return _fg_}
                  catch(_fh_)
                   {_fh_ = caml_wrap_exception(_fh_);
                    if(_fh_ === CannotOptimize)
                     return caml_call1(Stdlib[2],cst_Exit_codes_cannot_be_tweak);
                    throw _fh_}},
               load_from_parsed_file=
                function(fmt,env,param)
                 {var
                   arm=param[2],
                   h=param[1],
                   _e__=parsed_content_to_arm(fmt,1,env,[0,h,arm]);
                  function _e$_(arm)
                   {var _fa_=arm_to_binary(arm);
                    return preferred_code
                            (caml_call2(Stdlib_list[19],codes_for_command,_fa_))}
                  var
                   codes=caml_call2(Stdlib_list[19],_e$_,_e__),
                   match=get_param(h,cst_start);
                  if(typeof match === "number")
                   return [0,0,[0,codes]];
                  else
                   {if(1 === match[0])
                     {var i=match[1];
                      return [0,[0,[0,uint32_to_int(i),codes],0],0]}
                    return caml_call1(Stdlib[2],cst_Exit_code_has_invalid_head)}},
               load_from_file=
                function(fmt,env,filename)
                 {var
                   match=from_filename(1,filename),
                   ast=match[2],
                   headers=match[1];
                  return [0,
                          headers,
                          load_from_parsed_file(fmt,env,[0,headers,ast])]},
               NoExitCode=[248,cst_Exit_NoExitCode,caml_fresh_oo_id(0)],
               get_preferred=
                function(param,i)
                 {var default$0=param[2],lst=param[1];
                  try
                   {var
                     aux=
                      function(lst)
                       {var lst$0=lst;
                        for(;;)
                         {if(lst$0)
                           {var match=lst$0[1],c=match[2],j=match[1];
                            if(runtime.caml_lessequal(i,j))return [0,j,c];
                            var lst$1=lst$0[2],lst$0=lst$1;
                            continue}
                          throw NoExitCode}},
                     _e8_=aux(lst);
                    return _e8_}
                  catch(_e9_)
                   {_e9_ = caml_wrap_exception(_e9_);
                    if(_e9_ === NoExitCode)
                     {if(default$0){var c=default$0[1];return [0,i,c]}
                      throw NoExitCode}
                    throw _e9_}},
               Exit=
                [0,
                 load_from_dir,
                 load_from_file,
                 load_from_parsed_file,
                 NoExitCode,
                 get_preferred];
              caml_register_global(495,Exit,"Exit");
              var
               string_of_uchar=
                function(uchar)
                 {var buffer=caml_call1(Stdlib_buffer[1],4);
                  caml_call2(Uutf[23][1],buffer,uchar);
                  return caml_call1(Stdlib_buffer[2],buffer)},
               decompose_into_uchars=
                function(str)
                 {var _e5_=0;
                  function _e6_(acc,param,uc)
                   {if(852405675 <= uc[1]){var uc$0=uc[2];return [0,uc$0,acc]}
                    throw Stdlib[8]}
                  var _e7_=caml_call5(Uutf[22][2],0,0,_e6_,_e5_,str);
                  return caml_call1(Stdlib_list[9],_e7_)},
               main$1=
                function(fmt)
                 {caml_call2(Stdlib_format[126],fmt,_c9_);
                  var _e4_=caml_call2(Stdlib_format[126],fmt,_c__);
                  caml_call2(Stdlib_list[17],_e4_,acc);
                  caml_call2(Stdlib_format[126],fmt,_c$_);
                  return [0,main_1$1]},
               main_1$1=
                function(fmt,str)
                 {function aux2(lst)
                   {var lst$0=lst;
                    for(;;)
                     {if(lst$0)
                       {var _e3_=lst$0[2];
                        if(_e3_)
                         {var lst$1=_e3_[2],b=_e3_[1],a=lst$0[1];
                          caml_call4(Stdlib_format[126],fmt,_da_,b,a);
                          var lst$0=lst$1;
                          continue}
                        throw [0,Assert_failure,_db_]}
                      return 0}}
                  function aux4(lst)
                   {var lst$0=lst;
                    for(;;)
                     {if(lst$0)
                       {var _e0_=lst$0[2];
                        if(_e0_)
                         {var _e1_=_e0_[2];
                          if(_e1_)
                           {var _e2_=_e1_[2];
                            if(_e2_)
                             {var lst$1=_e2_[2],d=_e2_[1],c=_e1_[1],b=_e0_[1],a=lst$0[1];
                              caml_call6(Stdlib_format[126],fmt,_dc_,d,c,b,a);
                              var lst$0=lst$1;
                              continue}}}
                        throw [0,Assert_failure,_dd_]}
                      return 0}}
                  try
                   {var
                     _eW_=decompose_into_uchars(str),
                     _eX_=caml_call2(Stdlib_list[19],string_of_uchar,_eW_),
                     encoding=
                      caml_call2(Stdlib_list[19],encode_writable_char,_eX_),
                     encoding$0=caml_call2(Stdlib[37],encoding,[0,eof,0]);
                    caml_call2(Stdlib_format[126],fmt,_df_);
                    var _eY_=caml_call2(Stdlib_format[126],fmt,_dg_);
                    caml_call2(Stdlib_list[17],_eY_,encoding$0);
                    var
                     n=caml_call1(Stdlib_list[1],encoding$0),
                     encoding$1=
                      0 === (n % 2 | 0)
                       ?encoding$0
                       :caml_call2(Stdlib[37],encoding$0,_dl_);
                    caml_call2(Stdlib_format[126],fmt,_dh_);
                    aux2(encoding$1);
                    var
                     n$0=caml_call1(Stdlib_list[1],encoding$1),
                     encoding$2=
                      0 === (n$0 % 4 | 0)
                       ?encoding$1
                       :caml_call2(Stdlib[37],encoding$1,_dk_);
                    caml_call2(Stdlib_format[126],fmt,_di_);
                    aux4(encoding$2);
                    caml_call2(Stdlib_format[126],fmt,_dj_)}
                  catch(_eZ_)
                   {_eZ_ = caml_wrap_exception(_eZ_);
                    if(_eZ_ !== Stdlib[8])throw _eZ_;
                    caml_call2(Stdlib_format[126],fmt,_de_)}
                  return 0},
               Encoder_common=
                [0,string_of_uchar,decompose_into_uchars,main$1,main_1$1];
              caml_register_global(497,Encoder_common,"Encoder_common");
              var Constants=[0,33703148,100];
              caml_register_global(498,Constants,"Constants");
              var
               BoxFittingError=
                [248,cst_Boxes_BoxFittingError,caml_fresh_oo_id(0)],
               default_fillers=[0,_dp_,_do_,_dn_,_dm_],
               nb_boxes=14,
               no_eof=
                function(codes)
                 {function _eV_(c){return c !== 255?1:0}
                  return caml_call2(Stdlib_list[32],_eV_,codes)},
               pad_nb=
                function(fillers,pos$0,nb)
                 {if(0 <= nb)
                   {if(0 === nb)return 0;
                    var pos=pos$0 % 9 | 0,n=caml_call1(Stdlib_list[1],nop_code);
                    if((pos + n | 0) <= 8)
                     var code=nop_code;
                    else
                     var
                      _eT_=8 - pos | 0,
                      code=caml_check_bound(fillers,_eT_)[1 + _eT_];
                    var
                     m=caml_call1(Stdlib_list[1],code),
                     _eU_=pad_nb(fillers,pos$0 + m | 0,nb - m | 0);
                    return caml_call2(Stdlib[37],code,_eU_)}
                  return caml_call1(Stdlib[2],cst_Invalid_starting_position)},
               fit_code_at_pos=
                function(opt,fillers,pos,codes$9)
                 {if(opt)var sth=opt[1],next=sth;else var next=_dr_;
                  var
                   pos$0=pos % 9 | 0,
                   n$0=caml_call1(Stdlib_list[1],codes$9);
                  if(no_eof(codes$9))
                   var is_ok_here=(pos$0 + n$0 | 0) <= 8?1:0;
                  else
                   {var codes=codes$9;
                    for(;;)
                     {if(codes)
                       {var c=codes[1],codes$0=codes[2];
                        if(c !== 255){var codes=codes$0;continue}
                        if(codes$0)
                         {var codes$1=codes$0[2],c$0=codes$0[1];
                          if(c$0 === 255)
                           {var codes$2=[0,c$0,codes$1],codes=codes$2;continue}}
                        var codes$3=codes[2],_eK_=no_eof(codes$3)}
                      else
                       var _eK_=1;
                      if(! _eK_)
                       throw [0,BoxFittingError,cst_Some_codes_cannot_be_posit];
                      var
                       n=caml_call1(Stdlib_list[1],codes$9),
                       codes$4=caml_call1(Stdlib_list[9],codes$9),
                       acc=0,
                       codes$5=codes$4;
                      for(;;)
                       {if(! codes$5)throw [0,Assert_failure,_dq_];
                        var c$1=codes$5[1];
                        if(c$1 !== 255)
                         {var
                           codes$6=codes$5[2],
                           acc$0=acc + 1 | 0,
                           acc=acc$0,
                           codes$5=codes$6;
                          continue}
                        var i=(n - 1 | 0) - acc | 0;
                        if(next)
                         {var next$0=next[1],acc$1=0,codes$7=next$0;
                          for(;;)
                           {if(codes$7)
                             {var codes$8=codes$7[2],c$2=codes$7[1];
                              if(c$2 === 255)
                               {var acc$2=acc$1 + 1 | 0,acc$1=acc$2,codes$7=codes$8;
                                continue}}
                            var j=acc$1;
                            break}}
                        else
                         var j=0;
                        var _eL_=(pos$0 + i | 0) === 8?1:0;
                        if(_eL_)
                         var _eM_=_eL_;
                        else
                         {var
                           _eN_=i === (n$0 - 1 | 0)?1:0,
                           _eO_=_eN_?((pos$0 + i | 0) + 1 | 0) === 8?1:0:_eN_;
                          if(_eO_)
                           var _eM_=_eO_;
                          else
                           {var
                             _eP_=i === (n$0 - 1 | 0)?1:0,
                             _eQ_=_eP_?((pos$0 + i | 0) + j | 0) === 8?1:0:_eP_;
                            if(_eQ_)
                             var _eM_=_eQ_;
                            else
                             {var _eR_=0 === next?1:0;
                              if(_eR_)
                               var
                                _eS_=i === (n$0 - 1 | 0)?1:0,
                                _eM_=_eS_?(pos$0 + i | 0) <= 8?1:0:_eS_;
                              else
                               var _eM_=_eR_}}}
                        var is_ok_here=_eM_;
                        break}
                      break}}
                  if(is_ok_here)return codes$9;
                  if((pos$0 + n$0 | 0) <= 8)
                   var nop_code$0=nop_code;
                  else
                   var
                    _eJ_=8 - pos$0 | 0,
                    nop_code$0=caml_check_bound(fillers,_eJ_)[1 + _eJ_];
                  var
                   m=caml_call1(Stdlib_list[1],nop_code$0),
                   _eI_=fit_code_at_pos([0,next],fillers,pos$0 + m | 0,codes$9);
                  return caml_call2(Stdlib[37],nop_code$0,_eI_)},
               add_codes_after=
                function(opt,fillers,res,codes)
                 {if(opt)var sth=opt[1],final$0=sth;else var final$0=0;
                  var acc=res,codes$0=codes;
                  for(;;)
                   {if(codes$0)
                     {var _eF_=codes$0[2],_eG_=codes$0[1];
                      if(_eF_)
                       {var
                         codes$1=_eF_[2],
                         c2=_eF_[1],
                         nc=
                          fit_code_at_pos
                           ([0,[0,c2]],fillers,caml_call1(Stdlib_list[1],acc),_eG_),
                         codes$2=[0,c2,codes$1],
                         acc$0=caml_call2(Stdlib[37],acc,nc),
                         acc=acc$0,
                         codes$0=codes$2;
                        continue}
                      var
                       next=final$0?0:_ds_,
                       _eH_=
                        fit_code_at_pos
                         ([0,next],fillers,caml_call1(Stdlib_list[1],acc),_eG_);
                      return caml_call2(Stdlib[37],acc,_eH_)}
                    return acc}},
               split_raw_into_boxes=
                function(opt,raw)
                 {if(opt)var sth=opt[1],fill_last=sth;else var fill_last=0;
                  var finished=0,current=0,codes=raw,i=0;
                  for(;;)
                   {if(codes)
                     {var c=codes[1],codes$0=codes[2];
                      if(i === 8)
                       {if(c !== 255)
                         throw [0,BoxFittingError,cst_Result_is_inconsistent_Ple];
                        var
                         finished$0=[0,current,finished],
                         finished=finished$0,
                         current=0,
                         codes=codes$0,
                         i=0;
                        continue}
                      if(c === 255)
                       {var i$0=i + 1 | 0,codes=codes$0,i=i$0;continue}
                      var codes$1=codes[2];
                      if(caml_call1(Stdlib_list[1],current) !== i)
                       throw [0,BoxFittingError,cst_Result_is_inconsistent_Ple$0];
                      var
                       i$1=i + 1 | 0,
                       current$0=[0,c,current],
                       current=current$0,
                       codes=codes$1,
                       i=i$1;
                      continue}
                    if(0 === i)
                     var _eD_=finished;
                    else
                     {var n=caml_call1(Stdlib_list[1],current),switch$0=0;
                      if(fill_last && n === i)
                       {var
                         _eB_=function(param){return space},
                         _eC_=caml_call2(Stdlib_list[10],8 - n | 0,_eB_),
                         current$1=caml_call2(Stdlib[37],_eC_,current);
                        switch$0 = 1}
                      if(! switch$0)var current$1=current;
                      var _eD_=[0,current$1,finished]}
                    var _eE_=caml_call2(Stdlib_list[19],Stdlib_list[9],_eD_);
                    return caml_call1(Stdlib_list[9],_eE_)}},
               fit_codes_into_boxes=
                function(opt,_ex_,_ew_,_ev_,codes)
                 {if(opt)var sth=opt[1],fill_last=sth;else var fill_last=1;
                  if(_ex_)
                   var sth$0=_ex_[1],fillers=sth$0;
                  else
                   var fillers=default_fillers;
                  if(_ew_)var sth$1=_ew_[1],start=sth$1;else var start=0;
                  if(_ev_)var sth$2=_ev_[1],exit=sth$2;else var exit=0;
                  var
                   padding=pad_nb(fillers,0,start),
                   res=
                    add_codes_after([0,0 === exit?1:0],fillers,padding,codes);
                  if(exit)
                   var
                    exit$0=exit[1],
                    i=caml_call1(Stdlib_list[1],res),
                    match=get_preferred(exit$0,i),
                    ecode=match[2],
                    j=match[1],
                    padding$0=pad_nb(fillers,i,j - i | 0),
                    res$0=caml_call2(Stdlib[37],res,padding$0),
                    res$1=add_codes_after(_dt_,fillers,res$0,ecode);
                  else
                   var res$1=res;
                  var res$2=split_raw_into_boxes([0,fill_last],res$1);
                  function _ey_(i,lst)
                   {if(is_full_of_spaces(lst))
                     {var
                       y=caml_call1(Stdlib_list[1],nop_code2),
                       x=(- i | 0) * 9 | 0,
                       result=caml_mod(x,y),
                       pos=0 <= result?result:result + y | 0,
                       _ez_=function(param){return space},
                       prefix=caml_call2(Stdlib_list[10],pos,_ez_),
                       suffix_len=
                        (caml_call1(Stdlib_list[1],lst) - pos | 0)
                        -
                        y
                        |
                        0;
                      if(0 <= suffix_len)
                       {var
                         _eA_=function(param){return space},
                         suffix=caml_call2(Stdlib_list[10],suffix_len,_eA_);
                        return caml_call1
                                (Stdlib_list[13],[0,prefix,[0,nop_code2,[0,suffix,0]]])}
                      return lst}
                    return lst}
                  return caml_call2(Stdlib_list[20],_ey_,res$2)},
               pp_boxes_names=
                function(fmt,lst)
                 {function pp_box(i,codes)
                   {var chars=codes_to_chars(codes);
                    return caml_call7
                            (Stdlib_format[126],
                             fmt,
                             _du_,
                             i + 1 | 0,
                             pp_chars,
                             chars,
                             pp_chars_raw,
                             chars)}
                  return caml_call2(Stdlib_list[18],pp_box,lst)},
               pp_box_raw=
                function(fmt,lst)
                 {function _er_(param){return eof}
                  var
                   _es_=9 - caml_call1(Stdlib_list[1],lst) | 0,
                   pad=caml_call2(Stdlib_list[10],_es_,_er_),
                   _et_=caml_call2(Stdlib[37],lst,pad),
                   _eu_=caml_call2(Stdlib_format[126],fmt,_dv_);
                  return caml_call2(Stdlib_list[17],_eu_,_et_)},
               Boxes=
                [0,
                 BoxFittingError,
                 default_fillers,
                 fit_codes_into_boxes,
                 split_raw_into_boxes,
                 pp_boxes_names,
                 pp_box_raw,
                 nb_boxes];
              caml_register_global(499,Boxes,"Boxes");
              var
               pp_hex=
                function(fmt,i)
                 {return caml_call3(Stdlib_format[126],fmt,_dw_,i)},
               cond_to_str=
                function(c)
                 {switch(c)
                   {case 0:return cst_EQ$0;
                    case 1:return cst_NE$0;
                    case 2:return cst_CS$0;
                    case 3:return cst_HS$0;
                    case 4:return cst_CC$0;
                    case 5:return cst_LO$0;
                    case 6:return cst_MI$0;
                    case 7:return cst_PL$0;
                    case 8:return cst_VS$0;
                    case 9:return cst_VC$0;
                    case 10:return cst_HI$0;
                    case 11:return cst_LS$0;
                    case 12:return cst_GE$0;
                    case 13:return cst_LT$0;
                    case 14:return cst_GT$0;
                    case 15:return cst_LE$0;
                    default:return cst$2}},
               sign_to_str=function(sign){return sign === 0?cst$4:cst$5},
               s_to_str=function(s){return s?cst_S$1:cst$6},
               l_to_str=function(l){return l?cst_L$1:cst$7},
               print_register=
                function(fmt,r)
                 {return caml_call3(Stdlib_format[126],fmt,_dx_,r)},
               print_immediate=
                function(fmt,i)
                 {return caml_call3(Stdlib_format[126],fmt,_dy_,i)},
               print_operand=
                function(fmt,op)
                 {switch(op[0])
                   {case 0:var i=op[1];return print_immediate(fmt,i);
                    case 1:
                     var r=op[1];
                     return caml_call4
                             (Stdlib_format[126],fmt,_dz_,print_register,r);
                    default:return caml_call1(Stdlib[2],cst_Not_implemented$3)}},
               print_immediate_offset=
                function(fmt,param)
                 {var i=param[2],s=param[1],_eq_=sign_to_str(s);
                  return caml_call4(Stdlib_format[126],fmt,_dA_,_eq_,i)},
               print_register_offset=
                function(fmt,param)
                 {var
                   addr_typ=param[2],
                   ro=param[1],
                   str=1 === addr_typ?cst$8:cst$9;
                  switch(ro[0])
                   {case 0:
                     var _em_=ro[1];
                     if(2 <= addr_typ)
                      {var i=ro[3],s=ro[2];
                       return caml_call6
                               (Stdlib_format[126],
                                fmt,
                                _dB_,
                                print_register,
                                _em_,
                                print_immediate_offset,
                                [0,s,i])}
                     var i$0=ro[3],s$0=ro[2];
                     return caml_call7
                             (Stdlib_format[126],
                              fmt,
                              _dC_,
                              print_register,
                              _em_,
                              print_immediate_offset,
                              [0,s$0,i$0],
                              str);
                    case 1:
                     var _en_=ro[1];
                     if(2 <= addr_typ)
                      {var ro$0=ro[3],s$1=ro[2],_eo_=sign_to_str(s$1);
                       return caml_call7
                               (Stdlib_format[126],
                                fmt,
                                _dD_,
                                print_register,
                                _en_,
                                _eo_,
                                print_register,
                                ro$0)}
                     var ro$1=ro[3],s$2=ro[2],_ep_=sign_to_str(s$2);
                     return caml_call8
                             (Stdlib_format[126],
                              fmt,
                              _dE_,
                              print_register,
                              _en_,
                              _ep_,
                              print_register,
                              ro$1,
                              str);
                    default:return caml_call1(Stdlib[2],cst_Not_implemented$4)}},
               pp_arm=
                function(fmt,arm)
                 {switch(arm[0])
                   {case 0:var i=arm[1];return pp_hex(fmt,i);
                    case 1:
                     var ro=arm[5],rd=arm[4],cond=arm[3],typ=arm[2],instr=arm[1];
                     switch(typ)
                      {case 0:var _d$_=cst_B$1;break;
                       case 1:var _d$_=cst_SB$0;break;
                       case 2:var _d$_=cst_H$0;break;
                       case 3:var _d$_=cst_SH$0;break;
                       case 4:var _d$_=cst$3;break;
                       case 5:var _d$_=cst_T$0;break;
                       default:var _d$_=cst_BT$0}
                     var _ea_=cond_to_str(cond),_eb_=instr?cst_STR$0:cst_LDR$0;
                     return caml_call9
                             (Stdlib_format[126],
                              fmt,
                              _dF_,
                              _eb_,
                              _ea_,
                              _d$_,
                              print_register,
                              rd,
                              print_register_offset,
                              ro);
                    case 2:
                     var
                      rs=arm[5],
                      rd$0=arm[4],
                      cond$0=arm[3],
                      s=arm[2],
                      instr$0=arm[1],
                      _ec_=s_to_str(s),
                      _ed_=cond_to_str(cond$0),
                      _ee_=instr$0?cst_MVN$0:cst_MOV$0;
                     return caml_call9
                             (Stdlib_format[126],
                              fmt,
                              _dG_,
                              _ee_,
                              _ed_,
                              _ec_,
                              print_register,
                              rd$0,
                              print_operand,
                              rs);
                    case 3:
                     var
                      op2=arm[6],
                      rn=arm[5],
                      rd$1=arm[4],
                      cond$1=arm[3],
                      s$0=arm[2],
                      instr$1=arm[1],
                      _ef_=s_to_str(s$0),
                      _eg_=cond_to_str(cond$1);
                     switch(instr$1)
                      {case 0:var _eh_=cst_ADC$0;break;
                       case 1:var _eh_=cst_SBC$0;break;
                       case 2:var _eh_=cst_BIC$0;break;
                       case 3:var _eh_=cst_AND$0;break;
                       case 4:var _eh_=cst_ADD$0;break;
                       case 5:var _eh_=cst_SUB$0;break;
                       case 6:var _eh_=cst_ORR$0;break;
                       default:var _eh_=cst_EOR$0}
                     return caml_call11
                             (Stdlib_format[126],
                              fmt,
                              _dH_,
                              _eh_,
                              _eg_,
                              _ef_,
                              print_register,
                              rd$1,
                              print_register,
                              rn,
                              print_operand,
                              op2);
                    case 4:
                     var
                      target=arm[3],
                      cond$2=arm[2],
                      l=arm[1],
                      _ei_=cond_to_str(cond$2),
                      _ej_=l_to_str(l);
                     return caml_call6
                             (Stdlib_format[126],
                              fmt,
                              _dI_,
                              _ej_,
                              _ei_,
                              print_immediate,
                              target);
                    default:
                     var
                      rm=arm[3],
                      cond$3=arm[2],
                      l$0=arm[1],
                      _ek_=cond_to_str(cond$3),
                      _el_=l_to_str(l$0);
                     return caml_call6
                             (Stdlib_format[126],fmt,_dJ_,_el_,_ek_,print_register,rm)}},
               Arm_printer=[0,pp_arm,pp_hex];
              caml_register_global(500,Arm_printer,"Arm_printer");
              var
               treat_command=
                function(fmt,arm)
                 {var
                   hexs=arm_to_binary(arm),
                   codes=caml_call2(Stdlib_list[19],codes_for_command,hexs),
                   code=preferred_code(codes),
                   hex=command_for_codes(code),
                   chars=codes_to_chars(code);
                  caml_call8
                   (Stdlib_format[126],
                    fmt,
                    _dK_,
                    pp_chars,
                    chars,
                    pp_hex,
                    hex,
                    pp_arm,
                    arm);
                  return code},
               main$2=
                function(fmt,env,param,parsed,exit)
                 {var
                   headers2=param[2],
                   headers=param[1],
                   match=get_param(headers,cst_onlyraw);
                  if(typeof match === "number")
                   var onlyraw=0;
                  else
                   if(2 === match[0])
                    var b$0=match[1],onlyraw=b$0;
                   else
                    var onlyraw=caml_call1(Stdlib[2],cst_Invalid_headers$3);
                  var _dY_=onlyraw?0 !== exit?1:0:onlyraw;
                  if(_dY_)
                   caml_call1(Stdlib[2],cst_Only_raw_mode_does_not_sup);
                  var match$0=get_param(headers,cst_start$0);
                  if(typeof match$0 === "number")
                   var start=0;
                  else
                   if(1 === match$0[0])
                    var i=match$0[1],start=uint32_to_int(i);
                   else
                    var start=caml_call1(Stdlib[2],cst_Invalid_headers$2);
                  function _dZ_(n)
                   {var
                     header_name=caml_call2(Stdlib_format[129],_dL_,n + 1 | 0),
                     match=get_param(headers,header_name);
                    if(typeof match === "number")
                     return caml_check_bound(default_fillers,n)[1 + n];
                    else
                     {if(1 === match[0])
                       {var i=match[1],codes=codes_for_command(i);
                        if(caml_call2(Stdlib_list[7],codes,n) !== 255)
                         caml_call1(Stdlib[2],cst_Invalid_filler);
                        return codes}
                      return caml_call1(Stdlib[2],cst_Invalid_headers$0)}}
                  var
                   fillers=caml_call2(Stdlib_array[2],4,_dZ_),
                   match$1=get_param(headers,cst_fill),
                   match$2=get_param(headers2,cst_fill$0),
                   switch$0=0;
                  if(typeof match$1 === "number")
                   if(typeof match$2 === "number")
                    var fill_last=1;
                   else
                    if(2 === match$2[0])
                     {var b=match$2[1];switch$0 = 2}
                    else
                     switch$0 = 1;
                  else
                   if(2 === match$1[0])
                    {var _d8_=match$1[1];
                     if(typeof match$2 === "number")
                      {var b=_d8_;switch$0 = 2}
                     else
                      if(2 === match$2[0])
                       var
                        b2=match$2[1],
                        b1=
                         _d8_ === b2
                          ?_d8_
                          :caml_call1(Stdlib[2],cst_The_fill_header_has_a_diff),
                        fill_last=b1;
                      else
                       switch$0 = 1}
                   else
                    switch$0 = 1;
                  switch(switch$0)
                   {case 1:
                     var fill_last=caml_call1(Stdlib[2],cst_Invalid_headers$1);
                     break;
                    case 2:var fill_last=b;break
                    }
                  var _d0_=parsed_ast_to_arm(1,env,parsed);
                  function _d1_(_d__){return treat_command(fmt,_d__)}
                  var res=caml_call2(Stdlib_list[19],_d1_,_d0_);
                  if(onlyraw)
                   {var
                     _d2_=function(param){return 0},
                     start$0=caml_call2(Stdlib_list[10],start,_d2_),
                     res$0=caml_call1(Stdlib_list[13],[0,start$0,res]);
                    caml_call2(Stdlib_format[126],fmt,_dM_);
                    var _d3_=caml_call2(Stdlib_format[126],fmt,_dN_);
                    caml_call2(Stdlib_list[17],_d3_,res$0);
                    caml_call2(Stdlib_format[126],fmt,_dO_);
                    return 0}
                  try
                   {var
                     boxes_codes=
                      fit_codes_into_boxes
                       ([0,fill_last],[0,fillers],[0,start],[0,exit],res);
                    caml_call4
                     (Stdlib_format[126],fmt,_dP_,pp_boxes_names,boxes_codes);
                    var size=caml_call1(Stdlib_list[1],boxes_codes);
                    if(14 < size)
                     caml_call4(Stdlib_format[126],fmt,_dQ_,size,nb_boxes);
                    var _d4_=function(c){return 1 - is_code_writable(c)};
                    if(caml_call2(Stdlib_list[33],_d4_,boxes_codes))
                     caml_call2(Stdlib_format[126],fmt,_dR_);
                    else
                     if
                      (caml_call2(Stdlib_list[33],is_full_of_spaces,boxes_codes))
                      caml_call2(Stdlib_format[126],fmt,_dV_);
                    caml_call2(Stdlib_format[126],fmt,_dS_);
                    var _d5_=caml_call3(Stdlib_format[126],fmt,_dT_,pp_box_raw);
                    caml_call2(Stdlib_list[17],_d5_,boxes_codes);
                    caml_call2(Stdlib_format[126],fmt,_dU_);
                    var
                     _d6_=function(c){return concat_strings(codes_to_chars(c))},
                     _d7_=[0,caml_call2(Stdlib_list[19],_d6_,boxes_codes)];
                    return _d7_}
                  catch(_d9_)
                   {_d9_ = caml_wrap_exception(_d9_);
                    if(_d9_ === NoExitCode)
                     return caml_call1(Stdlib[2],cst_The_exit_code_overlaps_thi);
                    throw _d9_}},
               Ace_common=[0,treat_command,main$2];
              caml_register_global(501,Ace_common,"Ace_common");
              return}
            var
             i$3=caml_call1(Stdlib_int32[6],i$2),
             acc$2=[0,i$2,acc$1],
             acc$1=acc$2,
             i$2=i$3;
            continue}}}
      throw [0,Assert_failure,_dW_]}}
  (function(){return this}()));


//# 1 ".js/js_of_ocaml/js_of_ocaml.cma.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_exn_with_js_backtrace=runtime.caml_exn_with_js_backtrace,
     caml_float_of_string=runtime.caml_float_of_string,
     caml_fresh_oo_id=runtime.caml_fresh_oo_id,
     caml_int_of_string=runtime.caml_int_of_string,
     caml_js_from_array=runtime.caml_js_from_array,
     caml_js_get=runtime.caml_js_get,
     caml_js_html_escape=runtime.caml_js_html_escape,
     caml_js_set=runtime.caml_js_set,
     caml_js_wrap_callback=runtime.caml_js_wrap_callback,
     caml_js_wrap_meth_callback=runtime.caml_js_wrap_meth_callback,
     caml_jsbytes_of_string=runtime.caml_jsbytes_of_string,
     caml_jsstring_of_string=runtime.caml_jsstring_of_string,
     caml_list_of_js_array=runtime.caml_list_of_js_array,
     caml_ml_string_length=runtime.caml_ml_string_length,
     caml_register_global=runtime.caml_register_global,
     caml_string_compare=runtime.caml_string_compare,
     caml_string_notequal=runtime.caml_string_notequal,
     caml_string_of_array=runtime.caml_string_of_array,
     caml_string_of_jsbytes=runtime.caml_string_of_jsbytes,
     caml_string_of_jsstring=runtime.caml_string_of_jsstring,
     caml_wrap_exception=runtime.caml_wrap_exception;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5
              ?f(a0,a1,a2,a3,a4)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4])}
    var
     global_data=runtime.caml_get_global_data(),
     cst_parseFloat=caml_string_of_jsbytes("parseFloat"),
     cst_parseInt=caml_string_of_jsbytes("parseInt"),
     cst_Js_of_ocaml_Js_Error=caml_string_of_jsbytes("Js_of_ocaml__Js.Error"),
     cst_jsError=caml_string_of_jsbytes("jsError"),
     cst_can_t_retrieve_file_name_n=
      caml_string_of_jsbytes("can't retrieve file name: not implemented"),
     cst_endings=caml_string_of_jsbytes("endings"),
     cst_type=caml_string_of_jsbytes("type"),
     cst_loadstart=caml_string_of_jsbytes("loadstart"),
     cst_progress=caml_string_of_jsbytes("progress"),
     cst_abort=caml_string_of_jsbytes("abort"),
     cst_error=caml_string_of_jsbytes("error"),
     cst_load=caml_string_of_jsbytes("load"),
     cst_loadend=caml_string_of_jsbytes("loadend"),
     cst_a$1=caml_string_of_jsbytes("a"),
     cst_area$1=caml_string_of_jsbytes("area"),
     cst_audio$1=caml_string_of_jsbytes("audio"),
     cst_base$1=caml_string_of_jsbytes("base"),
     cst_blockquote$1=caml_string_of_jsbytes("blockquote"),
     cst_body$1=caml_string_of_jsbytes("body"),
     cst_br$1=caml_string_of_jsbytes("br"),
     cst_button$1=caml_string_of_jsbytes("button"),
     cst_canvas$1=caml_string_of_jsbytes("canvas"),
     cst_caption$1=caml_string_of_jsbytes("caption"),
     cst_col$1=caml_string_of_jsbytes("col"),
     cst_colgroup$1=caml_string_of_jsbytes("colgroup"),
     cst_del$1=caml_string_of_jsbytes("del"),
     cst_div$1=caml_string_of_jsbytes("div"),
     cst_dl$1=caml_string_of_jsbytes("dl"),
     cst_embed$1=caml_string_of_jsbytes("embed"),
     cst_fieldset$1=caml_string_of_jsbytes("fieldset"),
     cst_form$1=caml_string_of_jsbytes("form"),
     cst_frame$1=caml_string_of_jsbytes("frame"),
     cst_frameset$1=caml_string_of_jsbytes("frameset"),
     cst_h1$1=caml_string_of_jsbytes("h1"),
     cst_h2$1=caml_string_of_jsbytes("h2"),
     cst_h3$1=caml_string_of_jsbytes("h3"),
     cst_h4$1=caml_string_of_jsbytes("h4"),
     cst_h5$1=caml_string_of_jsbytes("h5"),
     cst_h6$1=caml_string_of_jsbytes("h6"),
     cst_head$1=caml_string_of_jsbytes("head"),
     cst_hr$1=caml_string_of_jsbytes("hr"),
     cst_html$1=caml_string_of_jsbytes("html"),
     cst_iframe$1=caml_string_of_jsbytes("iframe"),
     cst_img$1=caml_string_of_jsbytes("img"),
     cst_input$2=caml_string_of_jsbytes("input"),
     cst_ins$1=caml_string_of_jsbytes("ins"),
     cst_label$1=caml_string_of_jsbytes("label"),
     cst_legend$1=caml_string_of_jsbytes("legend"),
     cst_li$1=caml_string_of_jsbytes("li"),
     cst_link$1=caml_string_of_jsbytes("link"),
     cst_map$1=caml_string_of_jsbytes("map"),
     cst_meta$1=caml_string_of_jsbytes("meta"),
     cst_object$1=caml_string_of_jsbytes("object"),
     cst_ol$1=caml_string_of_jsbytes("ol"),
     cst_optgroup$1=caml_string_of_jsbytes("optgroup"),
     cst_option$1=caml_string_of_jsbytes("option"),
     cst_p$1=caml_string_of_jsbytes("p"),
     cst_param$1=caml_string_of_jsbytes("param"),
     cst_pre$1=caml_string_of_jsbytes("pre"),
     cst_q$1=caml_string_of_jsbytes("q"),
     cst_script$1=caml_string_of_jsbytes("script"),
     cst_select$2=caml_string_of_jsbytes("select"),
     cst_style$1=caml_string_of_jsbytes("style"),
     cst_table$1=caml_string_of_jsbytes("table"),
     cst_tbody$1=caml_string_of_jsbytes("tbody"),
     cst_td$1=caml_string_of_jsbytes("td"),
     cst_textarea$1=caml_string_of_jsbytes("textarea"),
     cst_tfoot$1=caml_string_of_jsbytes("tfoot"),
     cst_th$1=caml_string_of_jsbytes("th"),
     cst_thead$1=caml_string_of_jsbytes("thead"),
     cst_title$1=caml_string_of_jsbytes("title"),
     cst_tr$1=caml_string_of_jsbytes("tr"),
     cst_ul$1=caml_string_of_jsbytes("ul"),
     cst_video$1=caml_string_of_jsbytes("video"),
     cst_KeyH=caml_string_of_jsbytes("KeyH"),
     cst_Digit6=caml_string_of_jsbytes("Digit6"),
     cst_BrowserRefresh=caml_string_of_jsbytes("BrowserRefresh"),
     cst_Backslash=caml_string_of_jsbytes("Backslash"),
     cst_AltLeft=caml_string_of_jsbytes("AltLeft"),
     cst_AltRight=caml_string_of_jsbytes("AltRight"),
     cst_ArrowDown=caml_string_of_jsbytes("ArrowDown"),
     cst_ArrowLeft=caml_string_of_jsbytes("ArrowLeft"),
     cst_ArrowRight=caml_string_of_jsbytes("ArrowRight"),
     cst_ArrowUp=caml_string_of_jsbytes("ArrowUp"),
     cst_Backquote=caml_string_of_jsbytes("Backquote"),
     cst_Backspace=caml_string_of_jsbytes("Backspace"),
     cst_BracketLeft=caml_string_of_jsbytes("BracketLeft"),
     cst_BracketRight=caml_string_of_jsbytes("BracketRight"),
     cst_BrowserBack=caml_string_of_jsbytes("BrowserBack"),
     cst_BrowserFavorites=caml_string_of_jsbytes("BrowserFavorites"),
     cst_BrowserForward=caml_string_of_jsbytes("BrowserForward"),
     cst_BrowserHome=caml_string_of_jsbytes("BrowserHome"),
     cst_Delete=caml_string_of_jsbytes("Delete"),
     cst_BrowserSearch=caml_string_of_jsbytes("BrowserSearch"),
     cst_BrowserStop=caml_string_of_jsbytes("BrowserStop"),
     cst_CapsLock=caml_string_of_jsbytes("CapsLock"),
     cst_Comma=caml_string_of_jsbytes("Comma"),
     cst_ContextMenu=caml_string_of_jsbytes("ContextMenu"),
     cst_ControlLeft=caml_string_of_jsbytes("ControlLeft"),
     cst_ControlRight=caml_string_of_jsbytes("ControlRight"),
     cst_Digit0=caml_string_of_jsbytes("Digit0"),
     cst_Digit1=caml_string_of_jsbytes("Digit1"),
     cst_Digit2=caml_string_of_jsbytes("Digit2"),
     cst_Digit3=caml_string_of_jsbytes("Digit3"),
     cst_Digit4=caml_string_of_jsbytes("Digit4"),
     cst_Digit5=caml_string_of_jsbytes("Digit5"),
     cst_F6=caml_string_of_jsbytes("F6"),
     cst_F1=caml_string_of_jsbytes("F1"),
     cst_Digit7=caml_string_of_jsbytes("Digit7"),
     cst_Digit8=caml_string_of_jsbytes("Digit8"),
     cst_Digit9=caml_string_of_jsbytes("Digit9"),
     cst_End=caml_string_of_jsbytes("End"),
     cst_Enter=caml_string_of_jsbytes("Enter"),
     cst_Equal=caml_string_of_jsbytes("Equal"),
     cst_Escape=caml_string_of_jsbytes("Escape"),
     cst_F10=caml_string_of_jsbytes("F10"),
     cst_F11=caml_string_of_jsbytes("F11"),
     cst_F12=caml_string_of_jsbytes("F12"),
     cst_F2=caml_string_of_jsbytes("F2"),
     cst_F3=caml_string_of_jsbytes("F3"),
     cst_F4=caml_string_of_jsbytes("F4"),
     cst_F5=caml_string_of_jsbytes("F5"),
     cst_KeyA=caml_string_of_jsbytes("KeyA"),
     cst_F7=caml_string_of_jsbytes("F7"),
     cst_F8=caml_string_of_jsbytes("F8"),
     cst_F9=caml_string_of_jsbytes("F9"),
     cst_Home=caml_string_of_jsbytes("Home"),
     cst_Insert=caml_string_of_jsbytes("Insert"),
     cst_IntlBackslash=caml_string_of_jsbytes("IntlBackslash"),
     cst_IntlYen=caml_string_of_jsbytes("IntlYen"),
     cst_KeyB=caml_string_of_jsbytes("KeyB"),
     cst_KeyC=caml_string_of_jsbytes("KeyC"),
     cst_KeyD=caml_string_of_jsbytes("KeyD"),
     cst_KeyE=caml_string_of_jsbytes("KeyE"),
     cst_KeyF=caml_string_of_jsbytes("KeyF"),
     cst_KeyG=caml_string_of_jsbytes("KeyG"),
     cst_Numpad4=caml_string_of_jsbytes("Numpad4"),
     cst_KeyX=caml_string_of_jsbytes("KeyX"),
     cst_KeyP=caml_string_of_jsbytes("KeyP"),
     cst_KeyI=caml_string_of_jsbytes("KeyI"),
     cst_KeyJ=caml_string_of_jsbytes("KeyJ"),
     cst_KeyK=caml_string_of_jsbytes("KeyK"),
     cst_KeyL=caml_string_of_jsbytes("KeyL"),
     cst_KeyM=caml_string_of_jsbytes("KeyM"),
     cst_KeyN=caml_string_of_jsbytes("KeyN"),
     cst_KeyO=caml_string_of_jsbytes("KeyO"),
     cst_KeyQ=caml_string_of_jsbytes("KeyQ"),
     cst_KeyR=caml_string_of_jsbytes("KeyR"),
     cst_KeyS=caml_string_of_jsbytes("KeyS"),
     cst_KeyT=caml_string_of_jsbytes("KeyT"),
     cst_KeyU=caml_string_of_jsbytes("KeyU"),
     cst_KeyV=caml_string_of_jsbytes("KeyV"),
     cst_KeyW=caml_string_of_jsbytes("KeyW"),
     cst_MetaRight=caml_string_of_jsbytes("MetaRight"),
     cst_KeyY=caml_string_of_jsbytes("KeyY"),
     cst_KeyZ=caml_string_of_jsbytes("KeyZ"),
     cst_MediaPlayPause=caml_string_of_jsbytes("MediaPlayPause"),
     cst_MediaStop=caml_string_of_jsbytes("MediaStop"),
     cst_MediaTrackNext=caml_string_of_jsbytes("MediaTrackNext"),
     cst_MediaTrackPrevious=caml_string_of_jsbytes("MediaTrackPrevious"),
     cst_MetaLeft=caml_string_of_jsbytes("MetaLeft"),
     cst_Minus=caml_string_of_jsbytes("Minus"),
     cst_NumLock=caml_string_of_jsbytes("NumLock"),
     cst_Numpad0=caml_string_of_jsbytes("Numpad0"),
     cst_Numpad1=caml_string_of_jsbytes("Numpad1"),
     cst_Numpad2=caml_string_of_jsbytes("Numpad2"),
     cst_Numpad3=caml_string_of_jsbytes("Numpad3"),
     cst_PageUp=caml_string_of_jsbytes("PageUp"),
     cst_NumpadDivide=caml_string_of_jsbytes("NumpadDivide"),
     cst_Numpad5=caml_string_of_jsbytes("Numpad5"),
     cst_Numpad6=caml_string_of_jsbytes("Numpad6"),
     cst_Numpad7=caml_string_of_jsbytes("Numpad7"),
     cst_Numpad8=caml_string_of_jsbytes("Numpad8"),
     cst_Numpad9=caml_string_of_jsbytes("Numpad9"),
     cst_NumpadAdd=caml_string_of_jsbytes("NumpadAdd"),
     cst_NumpadDecimal=caml_string_of_jsbytes("NumpadDecimal"),
     cst_NumpadEnter=caml_string_of_jsbytes("NumpadEnter"),
     cst_NumpadEqual=caml_string_of_jsbytes("NumpadEqual"),
     cst_NumpadMultiply=caml_string_of_jsbytes("NumpadMultiply"),
     cst_NumpadSubtract=caml_string_of_jsbytes("NumpadSubtract"),
     cst_OSLeft=caml_string_of_jsbytes("OSLeft"),
     cst_OSRight=caml_string_of_jsbytes("OSRight"),
     cst_PageDown=caml_string_of_jsbytes("PageDown"),
     cst_ShiftRight=caml_string_of_jsbytes("ShiftRight"),
     cst_Pause=caml_string_of_jsbytes("Pause"),
     cst_Period=caml_string_of_jsbytes("Period"),
     cst_PrintScreen=caml_string_of_jsbytes("PrintScreen"),
     cst_Quote=caml_string_of_jsbytes("Quote"),
     cst_ScrollLock=caml_string_of_jsbytes("ScrollLock"),
     cst_Semicolon=caml_string_of_jsbytes("Semicolon"),
     cst_ShiftLeft=caml_string_of_jsbytes("ShiftLeft"),
     cst_Slash=caml_string_of_jsbytes("Slash"),
     cst_Space=caml_string_of_jsbytes("Space"),
     cst_Tab=caml_string_of_jsbytes("Tab"),
     cst_VolumeDown=caml_string_of_jsbytes("VolumeDown"),
     cst_VolumeMute=caml_string_of_jsbytes("VolumeMute"),
     cst_VolumeUp=caml_string_of_jsbytes("VolumeUp"),
     cst_mouseout$0=caml_string_of_jsbytes("mouseout"),
     cst_mouseover$0=caml_string_of_jsbytes("mouseover"),
     cst_video$0=caml_string_of_jsbytes("video"),
     cst_audio$0=caml_string_of_jsbytes("audio"),
     cst_ul$0=caml_string_of_jsbytes("ul"),
     cst_tr$0=caml_string_of_jsbytes("tr"),
     cst_title$0=caml_string_of_jsbytes("title"),
     cst_thead$0=caml_string_of_jsbytes("thead"),
     cst_th$0=caml_string_of_jsbytes("th"),
     cst_tfoot$0=caml_string_of_jsbytes("tfoot"),
     cst_textarea$0=caml_string_of_jsbytes("textarea"),
     cst_td$0=caml_string_of_jsbytes("td"),
     cst_tbody$0=caml_string_of_jsbytes("tbody"),
     cst_table$0=caml_string_of_jsbytes("table"),
     cst_style$0=caml_string_of_jsbytes("style"),
     cst_select$1=caml_string_of_jsbytes("select"),
     cst_script$0=caml_string_of_jsbytes("script"),
     cst_q$0=caml_string_of_jsbytes("q"),
     cst_pre$0=caml_string_of_jsbytes("pre"),
     cst_param$0=caml_string_of_jsbytes("param"),
     cst_p$0=caml_string_of_jsbytes("p"),
     cst_option$0=caml_string_of_jsbytes("option"),
     cst_optgroup$0=caml_string_of_jsbytes("optgroup"),
     cst_ol$0=caml_string_of_jsbytes("ol"),
     cst_object$0=caml_string_of_jsbytes("object"),
     cst_meta$0=caml_string_of_jsbytes("meta"),
     cst_map$0=caml_string_of_jsbytes("map"),
     cst_link$0=caml_string_of_jsbytes("link"),
     cst_li$0=caml_string_of_jsbytes("li"),
     cst_legend$0=caml_string_of_jsbytes("legend"),
     cst_label$0=caml_string_of_jsbytes("label"),
     cst_ins$0=caml_string_of_jsbytes("ins"),
     cst_input$1=caml_string_of_jsbytes("input"),
     cst_img$0=caml_string_of_jsbytes("img"),
     cst_iframe$0=caml_string_of_jsbytes("iframe"),
     cst_html$0=caml_string_of_jsbytes("html"),
     cst_hr$0=caml_string_of_jsbytes("hr"),
     cst_head$0=caml_string_of_jsbytes("head"),
     cst_h6$0=caml_string_of_jsbytes("h6"),
     cst_h5$0=caml_string_of_jsbytes("h5"),
     cst_h4$0=caml_string_of_jsbytes("h4"),
     cst_h3$0=caml_string_of_jsbytes("h3"),
     cst_h2$0=caml_string_of_jsbytes("h2"),
     cst_h1$0=caml_string_of_jsbytes("h1"),
     cst_frame$0=caml_string_of_jsbytes("frame"),
     cst_frameset$0=caml_string_of_jsbytes("frameset"),
     cst_form$0=caml_string_of_jsbytes("form"),
     cst_embed$0=caml_string_of_jsbytes("embed"),
     cst_fieldset$0=caml_string_of_jsbytes("fieldset"),
     cst_dl$0=caml_string_of_jsbytes("dl"),
     cst_div$0=caml_string_of_jsbytes("div"),
     cst_del$0=caml_string_of_jsbytes("del"),
     cst_colgroup$0=caml_string_of_jsbytes("colgroup"),
     cst_col$0=caml_string_of_jsbytes("col"),
     cst_caption$0=caml_string_of_jsbytes("caption"),
     cst_canvas$0=caml_string_of_jsbytes("canvas"),
     cst_button$0=caml_string_of_jsbytes("button"),
     cst_br$0=caml_string_of_jsbytes("br"),
     cst_body$0=caml_string_of_jsbytes("body"),
     cst_blockquote$0=caml_string_of_jsbytes("blockquote"),
     cst_base$0=caml_string_of_jsbytes("base"),
     cst_area$0=caml_string_of_jsbytes("area"),
     cst_a$0=caml_string_of_jsbytes("a"),
     cst_canvas=caml_string_of_jsbytes("canvas"),
     cst_video=caml_string_of_jsbytes("video"),
     cst_audio=caml_string_of_jsbytes("audio"),
     cst_iframe=caml_string_of_jsbytes("iframe"),
     cst_frame=caml_string_of_jsbytes("frame"),
     cst_frameset=caml_string_of_jsbytes("frameset"),
     cst_address=caml_string_of_jsbytes("address"),
     cst_noscript=caml_string_of_jsbytes("noscript"),
     cst_dt=caml_string_of_jsbytes("dt"),
     cst_dd=caml_string_of_jsbytes("dd"),
     cst_abbr=caml_string_of_jsbytes("abbr"),
     cst_var=caml_string_of_jsbytes("var"),
     cst_kbd=caml_string_of_jsbytes("kbd"),
     cst_samp=caml_string_of_jsbytes("samp"),
     cst_code=caml_string_of_jsbytes("code"),
     cst_dfn=caml_string_of_jsbytes("dfn"),
     cst_cite=caml_string_of_jsbytes("cite"),
     cst_strong=caml_string_of_jsbytes("strong"),
     cst_em=caml_string_of_jsbytes("em"),
     cst_small=caml_string_of_jsbytes("small"),
     cst_big=caml_string_of_jsbytes("big"),
     cst_b=caml_string_of_jsbytes("b"),
     cst_i=caml_string_of_jsbytes("i"),
     cst_tt=caml_string_of_jsbytes("tt"),
     cst_span=caml_string_of_jsbytes("span"),
     cst_sup=caml_string_of_jsbytes("sup"),
     cst_sub=caml_string_of_jsbytes("sub"),
     cst_td=caml_string_of_jsbytes("td"),
     cst_th=caml_string_of_jsbytes("th"),
     cst_tr=caml_string_of_jsbytes("tr"),
     cst_tbody=caml_string_of_jsbytes("tbody"),
     cst_tfoot=caml_string_of_jsbytes("tfoot"),
     cst_thead=caml_string_of_jsbytes("thead"),
     cst_colgroup=caml_string_of_jsbytes("colgroup"),
     cst_col=caml_string_of_jsbytes("col"),
     cst_caption=caml_string_of_jsbytes("caption"),
     cst_table=caml_string_of_jsbytes("table"),
     cst_script=caml_string_of_jsbytes("script"),
     cst_area=caml_string_of_jsbytes("area"),
     cst_map=caml_string_of_jsbytes("map"),
     cst_param=caml_string_of_jsbytes("param"),
     cst_object=caml_string_of_jsbytes("object"),
     cst_img=caml_string_of_jsbytes("img"),
     cst_a=caml_string_of_jsbytes("a"),
     cst_del=caml_string_of_jsbytes("del"),
     cst_ins=caml_string_of_jsbytes("ins"),
     cst_hr=caml_string_of_jsbytes("hr"),
     cst_br=caml_string_of_jsbytes("br"),
     cst_pre=caml_string_of_jsbytes("pre"),
     cst_blockquote=caml_string_of_jsbytes("blockquote"),
     cst_q=caml_string_of_jsbytes("q"),
     cst_h6=caml_string_of_jsbytes("h6"),
     cst_h5=caml_string_of_jsbytes("h5"),
     cst_h4=caml_string_of_jsbytes("h4"),
     cst_h3=caml_string_of_jsbytes("h3"),
     cst_h2=caml_string_of_jsbytes("h2"),
     cst_h1=caml_string_of_jsbytes("h1"),
     cst_p=caml_string_of_jsbytes("p"),
     cst_embed=caml_string_of_jsbytes("embed"),
     cst_div=caml_string_of_jsbytes("div"),
     cst_li=caml_string_of_jsbytes("li"),
     cst_dl=caml_string_of_jsbytes("dl"),
     cst_ol=caml_string_of_jsbytes("ol"),
     cst_ul=caml_string_of_jsbytes("ul"),
     cst_legend=caml_string_of_jsbytes("legend"),
     cst_fieldset=caml_string_of_jsbytes("fieldset"),
     cst_label=caml_string_of_jsbytes("label"),
     cst_button=caml_string_of_jsbytes("button"),
     cst_textarea=caml_string_of_jsbytes("textarea"),
     cst_input$0=caml_string_of_jsbytes("input"),
     cst_select$0=caml_string_of_jsbytes("select"),
     cst_option=caml_string_of_jsbytes("option"),
     cst_optgroup=caml_string_of_jsbytes("optgroup"),
     cst_form=caml_string_of_jsbytes("form"),
     cst_body=caml_string_of_jsbytes("body"),
     cst_style=caml_string_of_jsbytes("style"),
     cst_base=caml_string_of_jsbytes("base"),
     cst_meta=caml_string_of_jsbytes("meta"),
     cst_title=caml_string_of_jsbytes("title"),
     cst_link=caml_string_of_jsbytes("link"),
     cst_head=caml_string_of_jsbytes("head"),
     cst_html=caml_string_of_jsbytes("html"),
     cst_click=caml_string_of_jsbytes("click"),
     cst_copy=caml_string_of_jsbytes("copy"),
     cst_cut=caml_string_of_jsbytes("cut"),
     cst_paste=caml_string_of_jsbytes("paste"),
     cst_dblclick=caml_string_of_jsbytes("dblclick"),
     cst_mousedown=caml_string_of_jsbytes("mousedown"),
     cst_mouseup=caml_string_of_jsbytes("mouseup"),
     cst_mouseover=caml_string_of_jsbytes("mouseover"),
     cst_mousemove=caml_string_of_jsbytes("mousemove"),
     cst_mouseout=caml_string_of_jsbytes("mouseout"),
     cst_keypress=caml_string_of_jsbytes("keypress"),
     cst_keydown=caml_string_of_jsbytes("keydown"),
     cst_keyup=caml_string_of_jsbytes("keyup"),
     cst_mousewheel=caml_string_of_jsbytes("mousewheel"),
     cst_DOMMouseScroll=caml_string_of_jsbytes("DOMMouseScroll"),
     cst_touchstart=caml_string_of_jsbytes("touchstart"),
     cst_touchmove=caml_string_of_jsbytes("touchmove"),
     cst_touchend=caml_string_of_jsbytes("touchend"),
     cst_touchcancel=caml_string_of_jsbytes("touchcancel"),
     cst_dragstart=caml_string_of_jsbytes("dragstart"),
     cst_dragend=caml_string_of_jsbytes("dragend"),
     cst_dragenter=caml_string_of_jsbytes("dragenter"),
     cst_dragover=caml_string_of_jsbytes("dragover"),
     cst_dragleave=caml_string_of_jsbytes("dragleave"),
     cst_drag=caml_string_of_jsbytes("drag"),
     cst_drop=caml_string_of_jsbytes("drop"),
     cst_hashchange=caml_string_of_jsbytes("hashchange"),
     cst_change=caml_string_of_jsbytes("change"),
     cst_input=caml_string_of_jsbytes("input"),
     cst_timeupdate=caml_string_of_jsbytes("timeupdate"),
     cst_submit=caml_string_of_jsbytes("submit"),
     cst_scroll=caml_string_of_jsbytes("scroll"),
     cst_focus=caml_string_of_jsbytes("focus"),
     cst_blur=caml_string_of_jsbytes("blur"),
     cst_load$0=caml_string_of_jsbytes("load"),
     cst_unload=caml_string_of_jsbytes("unload"),
     cst_beforeunload=caml_string_of_jsbytes("beforeunload"),
     cst_resize=caml_string_of_jsbytes("resize"),
     cst_orientationchange=caml_string_of_jsbytes("orientationchange"),
     cst_popstate=caml_string_of_jsbytes("popstate"),
     cst_error$0=caml_string_of_jsbytes("error"),
     cst_abort$0=caml_string_of_jsbytes("abort"),
     cst_select=caml_string_of_jsbytes("select"),
     cst_online=caml_string_of_jsbytes("online"),
     cst_offline=caml_string_of_jsbytes("offline"),
     cst_checking=caml_string_of_jsbytes("checking"),
     cst_noupdate=caml_string_of_jsbytes("noupdate"),
     cst_downloading=caml_string_of_jsbytes("downloading"),
     cst_progress$0=caml_string_of_jsbytes("progress"),
     cst_updateready=caml_string_of_jsbytes("updateready"),
     cst_cached=caml_string_of_jsbytes("cached"),
     cst_obsolete=caml_string_of_jsbytes("obsolete"),
     cst_DOMContentLoaded=caml_string_of_jsbytes("DOMContentLoaded"),
     cst_animationstart=caml_string_of_jsbytes("animationstart"),
     cst_animationend=caml_string_of_jsbytes("animationend"),
     cst_animationiteration=caml_string_of_jsbytes("animationiteration"),
     cst_animationcancel=caml_string_of_jsbytes("animationcancel"),
     cst_canplay=caml_string_of_jsbytes("canplay"),
     cst_canplaythrough=caml_string_of_jsbytes("canplaythrough"),
     cst_durationchange=caml_string_of_jsbytes("durationchange"),
     cst_emptied=caml_string_of_jsbytes("emptied"),
     cst_ended=caml_string_of_jsbytes("ended"),
     cst_gotpointercapture=caml_string_of_jsbytes("gotpointercapture"),
     cst_loadeddata=caml_string_of_jsbytes("loadeddata"),
     cst_loadedmetadata=caml_string_of_jsbytes("loadedmetadata"),
     cst_loadstart$0=caml_string_of_jsbytes("loadstart"),
     cst_lostpointercapture=caml_string_of_jsbytes("lostpointercapture"),
     cst_pause=caml_string_of_jsbytes("pause"),
     cst_play=caml_string_of_jsbytes("play"),
     cst_playing=caml_string_of_jsbytes("playing"),
     cst_pointerenter=caml_string_of_jsbytes("pointerenter"),
     cst_pointercancel=caml_string_of_jsbytes("pointercancel"),
     cst_pointerdown=caml_string_of_jsbytes("pointerdown"),
     cst_pointerleave=caml_string_of_jsbytes("pointerleave"),
     cst_pointermove=caml_string_of_jsbytes("pointermove"),
     cst_pointerout=caml_string_of_jsbytes("pointerout"),
     cst_pointerover=caml_string_of_jsbytes("pointerover"),
     cst_pointerup=caml_string_of_jsbytes("pointerup"),
     cst_ratechange=caml_string_of_jsbytes("ratechange"),
     cst_seeked=caml_string_of_jsbytes("seeked"),
     cst_seeking=caml_string_of_jsbytes("seeking"),
     cst_stalled=caml_string_of_jsbytes("stalled"),
     cst_suspend=caml_string_of_jsbytes("suspend"),
     cst_volumechange=caml_string_of_jsbytes("volumechange"),
     cst_waiting=caml_string_of_jsbytes("waiting"),
     cst_Js_of_ocaml_Dom_html_Canva=
      caml_string_of_jsbytes("Js_of_ocaml__Dom_html.Canvas_not_available"),
     cst_checkbox=caml_string_of_jsbytes("checkbox"),
     cst_file=caml_string_of_jsbytes("file"),
     cst_password=caml_string_of_jsbytes("password"),
     cst_radio=caml_string_of_jsbytes("radio"),
     cst_reset=caml_string_of_jsbytes("reset"),
     cst_submit$0=caml_string_of_jsbytes("submit"),
     cst_text=caml_string_of_jsbytes("text"),
     cst_readystatechange=caml_string_of_jsbytes("readystatechange"),
     cst_loadstart$1=caml_string_of_jsbytes("loadstart"),
     cst_progress$1=caml_string_of_jsbytes("progress"),
     cst_abort$1=caml_string_of_jsbytes("abort"),
     cst_error$1=caml_string_of_jsbytes("error"),
     cst_load$1=caml_string_of_jsbytes("load"),
     cst_timeout=caml_string_of_jsbytes("timeout"),
     cst_loadend$0=caml_string_of_jsbytes("loadend"),
     cst_Worker_onmessage_is_undefi$0=
      caml_string_of_jsbytes("Worker.onmessage is undefined"),
     cst_Worker_onmessage_is_undefi=
      caml_string_of_jsbytes("Worker.onmessage is undefined"),
     cst_Worker_import_scripts_is_u=
      caml_string_of_jsbytes("Worker.import_scripts is undefined"),
     cst_webglcontextlost=caml_string_of_jsbytes("webglcontextlost"),
     cst_webglcontextrestored=caml_string_of_jsbytes("webglcontextrestored"),
     cst_webglcontextcreationerror=
      caml_string_of_jsbytes("webglcontextcreationerror"),
     cst_g=caml_string_of_jsbytes("g"),
     cst=caml_string_of_jsbytes("[\\][()\\\\|+*.?{}^$]"),
     cst$37=caml_string_of_jsbytes(""),
     cst$13=caml_string_of_jsbytes(""),
     cst$21=caml_string_of_jsbytes(""),
     cst$14=caml_string_of_jsbytes("#"),
     cst$15=caml_string_of_jsbytes("?"),
     cst$20=caml_string_of_jsbytes(""),
     cst$16=caml_string_of_jsbytes("/"),
     cst$17=caml_string_of_jsbytes("/"),
     cst$19=caml_string_of_jsbytes(":"),
     cst$18=caml_string_of_jsbytes(""),
     cst_http$1=caml_string_of_jsbytes("http://"),
     cst$22=caml_string_of_jsbytes(""),
     cst$30=caml_string_of_jsbytes(""),
     cst$23=caml_string_of_jsbytes("#"),
     cst$24=caml_string_of_jsbytes("?"),
     cst$29=caml_string_of_jsbytes(""),
     cst$25=caml_string_of_jsbytes("/"),
     cst$26=caml_string_of_jsbytes("/"),
     cst$28=caml_string_of_jsbytes(":"),
     cst$27=caml_string_of_jsbytes(""),
     cst_https$1=caml_string_of_jsbytes("https://"),
     cst$31=caml_string_of_jsbytes(""),
     cst$36=caml_string_of_jsbytes(""),
     cst$32=caml_string_of_jsbytes("#"),
     cst$33=caml_string_of_jsbytes("?"),
     cst$35=caml_string_of_jsbytes(""),
     cst$34=caml_string_of_jsbytes("/"),
     cst_file$2=caml_string_of_jsbytes("file://"),
     cst$12=caml_string_of_jsbytes(""),
     cst$11=caml_string_of_jsbytes(""),
     cst$10=caml_string_of_jsbytes(""),
     cst$9=caml_string_of_jsbytes(""),
     cst$8=caml_string_of_jsbytes(""),
     cst$7=caml_string_of_jsbytes(""),
     cst$6=caml_string_of_jsbytes(""),
     cst$4=caml_string_of_jsbytes("="),
     cst$5=caml_string_of_jsbytes("&"),
     cst$2=caml_string_of_jsbytes(""),
     cst$3=caml_string_of_jsbytes(""),
     cst_file$0=caml_string_of_jsbytes("file"),
     cst_file$1=caml_string_of_jsbytes("file:"),
     cst_http=caml_string_of_jsbytes("http"),
     cst_http$0=caml_string_of_jsbytes("http:"),
     cst_https=caml_string_of_jsbytes("https"),
     cst_https$0=caml_string_of_jsbytes("https:"),
     cst$1=caml_string_of_jsbytes(" "),
     cst_2B=caml_string_of_jsbytes("%2B"),
     cst_Js_of_ocaml_Url_Local_exn=
      caml_string_of_jsbytes("Js_of_ocaml__Url.Local_exn"),
     cst$0=caml_string_of_jsbytes("+"),
     cst_Js_of_ocaml_Url_Not_an_htt=
      caml_string_of_jsbytes("Js_of_ocaml__Url.Not_an_http_protocol"),
     cst_Hh_Tt_Tt_Pp_Ss_0_9a_zA_Z_0=
      caml_string_of_jsbytes
       ("^([Hh][Tt][Tt][Pp][Ss]?)://([0-9a-zA-Z.-]+|\\[[0-9a-zA-Z.-]+\\]|\\[[0-9A-Fa-f:.]+\\])?(:([0-9]+))?(/([^\\?#]*)(\\?([^#]*))?(#(.*))?)?$"),
     cst_Ff_Ii_Ll_Ee=
      caml_string_of_jsbytes
       ("^([Ff][Ii][Ll][Ee])://([^\\?#]*)(\\?([^#]*))?(#(.*))?$"),
     s=caml_string_of_jsbytes("3.9.0"),
     git_version=caml_string_of_jsbytes(""),
     cst$38=caml_string_of_jsbytes(""),
     cst$41=caml_string_of_jsbytes("+"),
     cst_Jstable_keys=caml_string_of_jsbytes("Jstable.keys"),
     dummy_string=caml_string_of_jsbytes(""),
     dummy_int64=runtime.caml_int64_create_lo_mi_hi(1,0,0),
     cst_is_not_a_valid_length$0=
      caml_string_of_jsbytes(" is not a valid length"),
     cst_d_d_deg_grad_rad_turns=
      caml_string_of_jsbytes("^(\\d*(?:\\.\\d*))(deg|grad|rad|turns)$"),
     cst_length_conversion_error$0=
      caml_string_of_jsbytes("length conversion error: "),
     cst_deg$0=caml_string_of_jsbytes("deg"),
     cst_grad$0=caml_string_of_jsbytes("grad"),
     cst_rad$0=caml_string_of_jsbytes("rad"),
     cst_turns$0=caml_string_of_jsbytes("turns"),
     cst_deg=caml_string_of_jsbytes("deg"),
     cst_grad=caml_string_of_jsbytes("grad"),
     cst_rad=caml_string_of_jsbytes("rad"),
     cst_turns=caml_string_of_jsbytes("turns"),
     cst_is_not_a_valid_length=
      caml_string_of_jsbytes(" is not a valid length"),
     cst_0$0=caml_string_of_jsbytes("0"),
     cst_d_d_s_S=caml_string_of_jsbytes("^(\\d*(?:\\.\\d*)?)\\s*(\\S*)$"),
     cst_length_conversion_error=
      caml_string_of_jsbytes("length conversion error: "),
     cst_pc$0=caml_string_of_jsbytes("pc"),
     cst_ch$0=caml_string_of_jsbytes("ch"),
     cst_cm$0=caml_string_of_jsbytes("cm"),
     cst_em$1=caml_string_of_jsbytes("em"),
     cst_ex$0=caml_string_of_jsbytes("ex"),
     cst_gd$0=caml_string_of_jsbytes("gd"),
     cst_in$0=caml_string_of_jsbytes("in"),
     cst_mm$0=caml_string_of_jsbytes("mm"),
     cst_pt$0=caml_string_of_jsbytes("pt"),
     cst_px$0=caml_string_of_jsbytes("px"),
     cst_rem$0=caml_string_of_jsbytes("rem"),
     cst_vh$0=caml_string_of_jsbytes("vh"),
     cst_vm$0=caml_string_of_jsbytes("vm"),
     cst_vw$0=caml_string_of_jsbytes("vw"),
     cst_0=caml_string_of_jsbytes("0"),
     cst_em$0=caml_string_of_jsbytes("em"),
     cst_ex=caml_string_of_jsbytes("ex"),
     cst_px=caml_string_of_jsbytes("px"),
     cst_gd=caml_string_of_jsbytes("gd"),
     cst_rem=caml_string_of_jsbytes("rem"),
     cst_vw=caml_string_of_jsbytes("vw"),
     cst_vh=caml_string_of_jsbytes("vh"),
     cst_vm=caml_string_of_jsbytes("vm"),
     cst_ch=caml_string_of_jsbytes("ch"),
     cst_mm=caml_string_of_jsbytes("mm"),
     cst_cm=caml_string_of_jsbytes("cm"),
     cst_in=caml_string_of_jsbytes("in"),
     cst_pt=caml_string_of_jsbytes("pt"),
     cst_pc=caml_string_of_jsbytes("pc"),
     cst$40=caml_string_of_jsbytes("): "),
     cst_color_conversion_error$0=
      caml_string_of_jsbytes("color conversion error ("),
     cst$39=caml_string_of_jsbytes("): "),
     cst_color_conversion_error=
      caml_string_of_jsbytes("color conversion error ("),
     cst_is_not_a_valid_color$0=
      caml_string_of_jsbytes(" is not a valid color"),
     cst_rgba_d_d_d_d_d=
      caml_string_of_jsbytes
       ("(rgba?)\\((?:(\\d*),(\\d*),(\\d*)(?:,(\\d*(?:\\.\\d*)?))?)\\)"),
     cst_rgba_d_d_d_d_d$0=
      caml_string_of_jsbytes
       ("(rgba?)\\((?:(\\d*)%,(\\d*)%,(\\d*)%(?:,(\\d*(?:\\.\\d*)?))?)\\)"),
     cst_hsla_d_d_d_d_d=
      caml_string_of_jsbytes
       ("(hsla?)\\((?:(\\d*),(\\d*)%,(\\d*)%(?:,(\\d*(?:\\.\\d*)?))?)\\)"),
     cst_rgb=caml_string_of_jsbytes("rgb"),
     cst_rgba=caml_string_of_jsbytes("rgba"),
     cst_rgb$0=caml_string_of_jsbytes("rgb"),
     cst_rgba$0=caml_string_of_jsbytes("rgba"),
     cst_hsl=caml_string_of_jsbytes("hsl"),
     cst_hsla=caml_string_of_jsbytes("hsla"),
     cst_rgb_s_d_s_d_s_d=
      caml_string_of_jsbytes("^rgb\\(\\s*\\d*,\\s*\\d*,\\s*\\d*\\)$"),
     cst_rgb_s_d_s_d_s_d$0=
      caml_string_of_jsbytes("^rgb\\(\\s*\\d*%,\\s*\\d*%,\\s*\\d*%\\)$"),
     cst_rgba_s_d_s_d_s_d_d_d=
      caml_string_of_jsbytes
       ("^rgba\\(\\s*\\d*,\\s*\\d*,\\s*\\d*,\\d*\\.?\\d*\\)$"),
     cst_rgba_s_d_s_d_s_d_d_d$0=
      caml_string_of_jsbytes
       ("^rgba\\(\\s*\\d*%,\\s*\\d*%,\\s*\\d*%,\\d*\\.?\\d*\\)$"),
     cst_hsl_s_d_s_d_s_d=
      caml_string_of_jsbytes("^hsl\\(\\s*\\d*,\\s*\\d*%,\\s*\\d*%\\)$"),
     cst_hsla_s_d_s_d_s_d_d_d=
      caml_string_of_jsbytes
       ("^hsla\\(\\s*\\d*,\\s*\\d*%,\\s*\\d*%,\\d*\\.?\\d*\\)$"),
     cst_is_not_a_valid_color=caml_string_of_jsbytes(" is not a valid color"),
     cst_is_out_of_valid_range=
      caml_string_of_jsbytes(" is out of valid range"),
     partial=[8,[0,0,0],0,0,[12,41,0]],
     partial$0=[12,41,0],
     partial$1=[0,0,0],
     cst_lightgrey$0=caml_string_of_jsbytes("lightgrey"),
     cst_darkslategray$0=caml_string_of_jsbytes("darkslategray"),
     cst_cornsilk$0=caml_string_of_jsbytes("cornsilk"),
     cst_blue$0=caml_string_of_jsbytes("blue"),
     cst_aliceblue$0=caml_string_of_jsbytes("aliceblue"),
     cst_antiquewhite$0=caml_string_of_jsbytes("antiquewhite"),
     cst_aqua$0=caml_string_of_jsbytes("aqua"),
     cst_aquamarine$0=caml_string_of_jsbytes("aquamarine"),
     cst_azure$0=caml_string_of_jsbytes("azure"),
     cst_beige$0=caml_string_of_jsbytes("beige"),
     cst_bisque$0=caml_string_of_jsbytes("bisque"),
     cst_black$0=caml_string_of_jsbytes("black"),
     cst_blanchedalmond$0=caml_string_of_jsbytes("blanchedalmond"),
     cst_blueviolet$0=caml_string_of_jsbytes("blueviolet"),
     cst_brown$0=caml_string_of_jsbytes("brown"),
     cst_burlywood$0=caml_string_of_jsbytes("burlywood"),
     cst_cadetblue$0=caml_string_of_jsbytes("cadetblue"),
     cst_chartreuse$0=caml_string_of_jsbytes("chartreuse"),
     cst_chocolate$0=caml_string_of_jsbytes("chocolate"),
     cst_coral$0=caml_string_of_jsbytes("coral"),
     cst_cornflowerblue$0=caml_string_of_jsbytes("cornflowerblue"),
     cst_darkkhaki$0=caml_string_of_jsbytes("darkkhaki"),
     cst_crimson$0=caml_string_of_jsbytes("crimson"),
     cst_cyan$0=caml_string_of_jsbytes("cyan"),
     cst_darkblue$0=caml_string_of_jsbytes("darkblue"),
     cst_darkcyan$0=caml_string_of_jsbytes("darkcyan"),
     cst_darkgoldenrod$0=caml_string_of_jsbytes("darkgoldenrod"),
     cst_darkgray$0=caml_string_of_jsbytes("darkgray"),
     cst_darkgreen$0=caml_string_of_jsbytes("darkgreen"),
     cst_darkgrey$0=caml_string_of_jsbytes("darkgrey"),
     cst_darkmagenta$0=caml_string_of_jsbytes("darkmagenta"),
     cst_darkolivegreen$0=caml_string_of_jsbytes("darkolivegreen"),
     cst_darkorange$0=caml_string_of_jsbytes("darkorange"),
     cst_darkorchid$0=caml_string_of_jsbytes("darkorchid"),
     cst_darkred$0=caml_string_of_jsbytes("darkred"),
     cst_darksalmon$0=caml_string_of_jsbytes("darksalmon"),
     cst_darkseagreen$0=caml_string_of_jsbytes("darkseagreen"),
     cst_darkslateblue$0=caml_string_of_jsbytes("darkslateblue"),
     cst_greenyellow$0=caml_string_of_jsbytes("greenyellow"),
     cst_floralwhite$0=caml_string_of_jsbytes("floralwhite"),
     cst_darkslategrey$0=caml_string_of_jsbytes("darkslategrey"),
     cst_darkturquoise$0=caml_string_of_jsbytes("darkturquoise"),
     cst_darkviolet$0=caml_string_of_jsbytes("darkviolet"),
     cst_deeppink$0=caml_string_of_jsbytes("deeppink"),
     cst_deepskyblue$0=caml_string_of_jsbytes("deepskyblue"),
     cst_dimgray$0=caml_string_of_jsbytes("dimgray"),
     cst_dimgrey$0=caml_string_of_jsbytes("dimgrey"),
     cst_dodgerblue$0=caml_string_of_jsbytes("dodgerblue"),
     cst_firebrick$0=caml_string_of_jsbytes("firebrick"),
     cst_forestgreen$0=caml_string_of_jsbytes("forestgreen"),
     cst_fuchsia$0=caml_string_of_jsbytes("fuchsia"),
     cst_gainsboro$0=caml_string_of_jsbytes("gainsboro"),
     cst_ghostwhite$0=caml_string_of_jsbytes("ghostwhite"),
     cst_gold$0=caml_string_of_jsbytes("gold"),
     cst_goldenrod$0=caml_string_of_jsbytes("goldenrod"),
     cst_gray$0=caml_string_of_jsbytes("gray"),
     cst_green$0=caml_string_of_jsbytes("green"),
     cst_lavenderblush$0=caml_string_of_jsbytes("lavenderblush"),
     cst_grey$0=caml_string_of_jsbytes("grey"),
     cst_honeydew$0=caml_string_of_jsbytes("honeydew"),
     cst_hotpink$0=caml_string_of_jsbytes("hotpink"),
     cst_indianred$0=caml_string_of_jsbytes("indianred"),
     cst_indigo$0=caml_string_of_jsbytes("indigo"),
     cst_ivory$0=caml_string_of_jsbytes("ivory"),
     cst_khaki$0=caml_string_of_jsbytes("khaki"),
     cst_lavender$0=caml_string_of_jsbytes("lavender"),
     cst_lawngreen$0=caml_string_of_jsbytes("lawngreen"),
     cst_lemonchiffon$0=caml_string_of_jsbytes("lemonchiffon"),
     cst_lightblue$0=caml_string_of_jsbytes("lightblue"),
     cst_lightcoral$0=caml_string_of_jsbytes("lightcoral"),
     cst_lightcyan$0=caml_string_of_jsbytes("lightcyan"),
     cst_lightgoldenrodyellow$0=caml_string_of_jsbytes("lightgoldenrodyellow"),
     cst_lightgray$0=caml_string_of_jsbytes("lightgray"),
     cst_lightgreen$0=caml_string_of_jsbytes("lightgreen"),
     cst_paleturquoise$0=caml_string_of_jsbytes("paleturquoise"),
     cst_mediumslateblue$0=caml_string_of_jsbytes("mediumslateblue"),
     cst_limegreen$0=caml_string_of_jsbytes("limegreen"),
     cst_lightpink$0=caml_string_of_jsbytes("lightpink"),
     cst_lightsalmon$0=caml_string_of_jsbytes("lightsalmon"),
     cst_lightseagreen$0=caml_string_of_jsbytes("lightseagreen"),
     cst_lightskyblue$0=caml_string_of_jsbytes("lightskyblue"),
     cst_lightslategray$0=caml_string_of_jsbytes("lightslategray"),
     cst_lightslategrey$0=caml_string_of_jsbytes("lightslategrey"),
     cst_lightsteelblue$0=caml_string_of_jsbytes("lightsteelblue"),
     cst_lightyellow$0=caml_string_of_jsbytes("lightyellow"),
     cst_lime$0=caml_string_of_jsbytes("lime"),
     cst_linen$0=caml_string_of_jsbytes("linen"),
     cst_magenta$0=caml_string_of_jsbytes("magenta"),
     cst_maroon$0=caml_string_of_jsbytes("maroon"),
     cst_mediumaquamarine$0=caml_string_of_jsbytes("mediumaquamarine"),
     cst_mediumblue$0=caml_string_of_jsbytes("mediumblue"),
     cst_mediumorchid$0=caml_string_of_jsbytes("mediumorchid"),
     cst_mediumpurple$0=caml_string_of_jsbytes("mediumpurple"),
     cst_mediumseagreen$0=caml_string_of_jsbytes("mediumseagreen"),
     cst_navy$0=caml_string_of_jsbytes("navy"),
     cst_mediumspringgreen$0=caml_string_of_jsbytes("mediumspringgreen"),
     cst_mediumturquoise$0=caml_string_of_jsbytes("mediumturquoise"),
     cst_mediumvioletred$0=caml_string_of_jsbytes("mediumvioletred"),
     cst_midnightblue$0=caml_string_of_jsbytes("midnightblue"),
     cst_mintcream$0=caml_string_of_jsbytes("mintcream"),
     cst_mistyrose$0=caml_string_of_jsbytes("mistyrose"),
     cst_moccasin$0=caml_string_of_jsbytes("moccasin"),
     cst_navajowhite$0=caml_string_of_jsbytes("navajowhite"),
     cst_oldlace$0=caml_string_of_jsbytes("oldlace"),
     cst_olive$0=caml_string_of_jsbytes("olive"),
     cst_olivedrab$0=caml_string_of_jsbytes("olivedrab"),
     cst_orange$0=caml_string_of_jsbytes("orange"),
     cst_orangered$0=caml_string_of_jsbytes("orangered"),
     cst_orchid$0=caml_string_of_jsbytes("orchid"),
     cst_palegoldenrod$0=caml_string_of_jsbytes("palegoldenrod"),
     cst_palegreen$0=caml_string_of_jsbytes("palegreen"),
     cst_skyblue$0=caml_string_of_jsbytes("skyblue"),
     cst_rosybrown$0=caml_string_of_jsbytes("rosybrown"),
     cst_palevioletred$0=caml_string_of_jsbytes("palevioletred"),
     cst_papayawhip$0=caml_string_of_jsbytes("papayawhip"),
     cst_peachpuff$0=caml_string_of_jsbytes("peachpuff"),
     cst_peru$0=caml_string_of_jsbytes("peru"),
     cst_pink$0=caml_string_of_jsbytes("pink"),
     cst_plum$0=caml_string_of_jsbytes("plum"),
     cst_powderblue$0=caml_string_of_jsbytes("powderblue"),
     cst_purple$0=caml_string_of_jsbytes("purple"),
     cst_red$0=caml_string_of_jsbytes("red"),
     cst_royalblue$0=caml_string_of_jsbytes("royalblue"),
     cst_saddlebrown$0=caml_string_of_jsbytes("saddlebrown"),
     cst_salmon$0=caml_string_of_jsbytes("salmon"),
     cst_sandybrown$0=caml_string_of_jsbytes("sandybrown"),
     cst_seagreen$0=caml_string_of_jsbytes("seagreen"),
     cst_seashell$0=caml_string_of_jsbytes("seashell"),
     cst_sienna$0=caml_string_of_jsbytes("sienna"),
     cst_silver$0=caml_string_of_jsbytes("silver"),
     cst_thistle$0=caml_string_of_jsbytes("thistle"),
     cst_slateblue$0=caml_string_of_jsbytes("slateblue"),
     cst_slategray$0=caml_string_of_jsbytes("slategray"),
     cst_slategrey$0=caml_string_of_jsbytes("slategrey"),
     cst_snow$0=caml_string_of_jsbytes("snow"),
     cst_springgreen$0=caml_string_of_jsbytes("springgreen"),
     cst_steelblue$0=caml_string_of_jsbytes("steelblue"),
     cst_tan$0=caml_string_of_jsbytes("tan"),
     cst_teal$0=caml_string_of_jsbytes("teal"),
     cst_tomato$0=caml_string_of_jsbytes("tomato"),
     cst_turquoise$0=caml_string_of_jsbytes("turquoise"),
     cst_violet$0=caml_string_of_jsbytes("violet"),
     cst_wheat$0=caml_string_of_jsbytes("wheat"),
     cst_white$0=caml_string_of_jsbytes("white"),
     cst_whitesmoke$0=caml_string_of_jsbytes("whitesmoke"),
     cst_yellow$0=caml_string_of_jsbytes("yellow"),
     cst_yellowgreen$0=caml_string_of_jsbytes("yellowgreen"),
     cst_is_not_a_valid_color_name=
      caml_string_of_jsbytes(" is not a valid color name"),
     cst_aliceblue=caml_string_of_jsbytes("aliceblue"),
     cst_antiquewhite=caml_string_of_jsbytes("antiquewhite"),
     cst_aqua=caml_string_of_jsbytes("aqua"),
     cst_aquamarine=caml_string_of_jsbytes("aquamarine"),
     cst_azure=caml_string_of_jsbytes("azure"),
     cst_beige=caml_string_of_jsbytes("beige"),
     cst_bisque=caml_string_of_jsbytes("bisque"),
     cst_black=caml_string_of_jsbytes("black"),
     cst_blanchedalmond=caml_string_of_jsbytes("blanchedalmond"),
     cst_blue=caml_string_of_jsbytes("blue"),
     cst_blueviolet=caml_string_of_jsbytes("blueviolet"),
     cst_brown=caml_string_of_jsbytes("brown"),
     cst_burlywood=caml_string_of_jsbytes("burlywood"),
     cst_cadetblue=caml_string_of_jsbytes("cadetblue"),
     cst_chartreuse=caml_string_of_jsbytes("chartreuse"),
     cst_chocolate=caml_string_of_jsbytes("chocolate"),
     cst_coral=caml_string_of_jsbytes("coral"),
     cst_cornflowerblue=caml_string_of_jsbytes("cornflowerblue"),
     cst_cornsilk=caml_string_of_jsbytes("cornsilk"),
     cst_crimson=caml_string_of_jsbytes("crimson"),
     cst_cyan=caml_string_of_jsbytes("cyan"),
     cst_darkblue=caml_string_of_jsbytes("darkblue"),
     cst_darkcyan=caml_string_of_jsbytes("darkcyan"),
     cst_darkgoldenrod=caml_string_of_jsbytes("darkgoldenrod"),
     cst_darkgray=caml_string_of_jsbytes("darkgray"),
     cst_darkgreen=caml_string_of_jsbytes("darkgreen"),
     cst_darkgrey=caml_string_of_jsbytes("darkgrey"),
     cst_darkkhaki=caml_string_of_jsbytes("darkkhaki"),
     cst_darkmagenta=caml_string_of_jsbytes("darkmagenta"),
     cst_darkolivegreen=caml_string_of_jsbytes("darkolivegreen"),
     cst_darkorange=caml_string_of_jsbytes("darkorange"),
     cst_darkorchid=caml_string_of_jsbytes("darkorchid"),
     cst_darkred=caml_string_of_jsbytes("darkred"),
     cst_darksalmon=caml_string_of_jsbytes("darksalmon"),
     cst_darkseagreen=caml_string_of_jsbytes("darkseagreen"),
     cst_darkslateblue=caml_string_of_jsbytes("darkslateblue"),
     cst_darkslategray=caml_string_of_jsbytes("darkslategray"),
     cst_darkslategrey=caml_string_of_jsbytes("darkslategrey"),
     cst_darkturquoise=caml_string_of_jsbytes("darkturquoise"),
     cst_darkviolet=caml_string_of_jsbytes("darkviolet"),
     cst_deeppink=caml_string_of_jsbytes("deeppink"),
     cst_deepskyblue=caml_string_of_jsbytes("deepskyblue"),
     cst_dimgray=caml_string_of_jsbytes("dimgray"),
     cst_dimgrey=caml_string_of_jsbytes("dimgrey"),
     cst_dodgerblue=caml_string_of_jsbytes("dodgerblue"),
     cst_firebrick=caml_string_of_jsbytes("firebrick"),
     cst_floralwhite=caml_string_of_jsbytes("floralwhite"),
     cst_forestgreen=caml_string_of_jsbytes("forestgreen"),
     cst_fuchsia=caml_string_of_jsbytes("fuchsia"),
     cst_gainsboro=caml_string_of_jsbytes("gainsboro"),
     cst_ghostwhite=caml_string_of_jsbytes("ghostwhite"),
     cst_gold=caml_string_of_jsbytes("gold"),
     cst_goldenrod=caml_string_of_jsbytes("goldenrod"),
     cst_gray=caml_string_of_jsbytes("gray"),
     cst_grey=caml_string_of_jsbytes("grey"),
     cst_green=caml_string_of_jsbytes("green"),
     cst_greenyellow=caml_string_of_jsbytes("greenyellow"),
     cst_honeydew=caml_string_of_jsbytes("honeydew"),
     cst_hotpink=caml_string_of_jsbytes("hotpink"),
     cst_indianred=caml_string_of_jsbytes("indianred"),
     cst_indigo=caml_string_of_jsbytes("indigo"),
     cst_ivory=caml_string_of_jsbytes("ivory"),
     cst_khaki=caml_string_of_jsbytes("khaki"),
     cst_lavender=caml_string_of_jsbytes("lavender"),
     cst_lavenderblush=caml_string_of_jsbytes("lavenderblush"),
     cst_lawngreen=caml_string_of_jsbytes("lawngreen"),
     cst_lemonchiffon=caml_string_of_jsbytes("lemonchiffon"),
     cst_lightblue=caml_string_of_jsbytes("lightblue"),
     cst_lightcoral=caml_string_of_jsbytes("lightcoral"),
     cst_lightcyan=caml_string_of_jsbytes("lightcyan"),
     cst_lightgoldenrodyellow=caml_string_of_jsbytes("lightgoldenrodyellow"),
     cst_lightgray=caml_string_of_jsbytes("lightgray"),
     cst_lightgreen=caml_string_of_jsbytes("lightgreen"),
     cst_lightgrey=caml_string_of_jsbytes("lightgrey"),
     cst_lightpink=caml_string_of_jsbytes("lightpink"),
     cst_lightsalmon=caml_string_of_jsbytes("lightsalmon"),
     cst_lightseagreen=caml_string_of_jsbytes("lightseagreen"),
     cst_lightskyblue=caml_string_of_jsbytes("lightskyblue"),
     cst_lightslategray=caml_string_of_jsbytes("lightslategray"),
     cst_lightslategrey=caml_string_of_jsbytes("lightslategrey"),
     cst_lightsteelblue=caml_string_of_jsbytes("lightsteelblue"),
     cst_lightyellow=caml_string_of_jsbytes("lightyellow"),
     cst_lime=caml_string_of_jsbytes("lime"),
     cst_limegreen=caml_string_of_jsbytes("limegreen"),
     cst_linen=caml_string_of_jsbytes("linen"),
     cst_magenta=caml_string_of_jsbytes("magenta"),
     cst_maroon=caml_string_of_jsbytes("maroon"),
     cst_mediumaquamarine=caml_string_of_jsbytes("mediumaquamarine"),
     cst_mediumblue=caml_string_of_jsbytes("mediumblue"),
     cst_mediumorchid=caml_string_of_jsbytes("mediumorchid"),
     cst_mediumpurple=caml_string_of_jsbytes("mediumpurple"),
     cst_mediumseagreen=caml_string_of_jsbytes("mediumseagreen"),
     cst_mediumslateblue=caml_string_of_jsbytes("mediumslateblue"),
     cst_mediumspringgreen=caml_string_of_jsbytes("mediumspringgreen"),
     cst_mediumturquoise=caml_string_of_jsbytes("mediumturquoise"),
     cst_mediumvioletred=caml_string_of_jsbytes("mediumvioletred"),
     cst_midnightblue=caml_string_of_jsbytes("midnightblue"),
     cst_mintcream=caml_string_of_jsbytes("mintcream"),
     cst_mistyrose=caml_string_of_jsbytes("mistyrose"),
     cst_moccasin=caml_string_of_jsbytes("moccasin"),
     cst_navajowhite=caml_string_of_jsbytes("navajowhite"),
     cst_navy=caml_string_of_jsbytes("navy"),
     cst_oldlace=caml_string_of_jsbytes("oldlace"),
     cst_olive=caml_string_of_jsbytes("olive"),
     cst_olivedrab=caml_string_of_jsbytes("olivedrab"),
     cst_orange=caml_string_of_jsbytes("orange"),
     cst_orangered=caml_string_of_jsbytes("orangered"),
     cst_orchid=caml_string_of_jsbytes("orchid"),
     cst_palegoldenrod=caml_string_of_jsbytes("palegoldenrod"),
     cst_palegreen=caml_string_of_jsbytes("palegreen"),
     cst_paleturquoise=caml_string_of_jsbytes("paleturquoise"),
     cst_palevioletred=caml_string_of_jsbytes("palevioletred"),
     cst_papayawhip=caml_string_of_jsbytes("papayawhip"),
     cst_peachpuff=caml_string_of_jsbytes("peachpuff"),
     cst_peru=caml_string_of_jsbytes("peru"),
     cst_pink=caml_string_of_jsbytes("pink"),
     cst_plum=caml_string_of_jsbytes("plum"),
     cst_powderblue=caml_string_of_jsbytes("powderblue"),
     cst_purple=caml_string_of_jsbytes("purple"),
     cst_red=caml_string_of_jsbytes("red"),
     cst_rosybrown=caml_string_of_jsbytes("rosybrown"),
     cst_royalblue=caml_string_of_jsbytes("royalblue"),
     cst_saddlebrown=caml_string_of_jsbytes("saddlebrown"),
     cst_salmon=caml_string_of_jsbytes("salmon"),
     cst_sandybrown=caml_string_of_jsbytes("sandybrown"),
     cst_seagreen=caml_string_of_jsbytes("seagreen"),
     cst_seashell=caml_string_of_jsbytes("seashell"),
     cst_sienna=caml_string_of_jsbytes("sienna"),
     cst_silver=caml_string_of_jsbytes("silver"),
     cst_skyblue=caml_string_of_jsbytes("skyblue"),
     cst_slateblue=caml_string_of_jsbytes("slateblue"),
     cst_slategray=caml_string_of_jsbytes("slategray"),
     cst_slategrey=caml_string_of_jsbytes("slategrey"),
     cst_snow=caml_string_of_jsbytes("snow"),
     cst_springgreen=caml_string_of_jsbytes("springgreen"),
     cst_steelblue=caml_string_of_jsbytes("steelblue"),
     cst_tan=caml_string_of_jsbytes("tan"),
     cst_teal=caml_string_of_jsbytes("teal"),
     cst_thistle=caml_string_of_jsbytes("thistle"),
     cst_tomato=caml_string_of_jsbytes("tomato"),
     cst_turquoise=caml_string_of_jsbytes("turquoise"),
     cst_violet=caml_string_of_jsbytes("violet"),
     cst_wheat=caml_string_of_jsbytes("wheat"),
     cst_white=caml_string_of_jsbytes("white"),
     cst_whitesmoke=caml_string_of_jsbytes("whitesmoke"),
     cst_yellow=caml_string_of_jsbytes("yellow"),
     cst_yellowgreen=caml_string_of_jsbytes("yellowgreen"),
     cst_vkern$0=caml_string_of_jsbytes("vkern"),
     cst_view$0=caml_string_of_jsbytes("view"),
     cst_use$0=caml_string_of_jsbytes("use"),
     cst_tspan$0=caml_string_of_jsbytes("tspan"),
     cst_tref$0=caml_string_of_jsbytes("tref"),
     cst_title$3=caml_string_of_jsbytes("title"),
     cst_textpath$0=caml_string_of_jsbytes("textpath"),
     cst_text$1=caml_string_of_jsbytes("text"),
     cst_symbol$0=caml_string_of_jsbytes("symbol"),
     cst_switch$0=caml_string_of_jsbytes("switch"),
     cst_svg$0=caml_string_of_jsbytes("svg"),
     cst_style$3=caml_string_of_jsbytes("style"),
     cst_stop$0=caml_string_of_jsbytes("stop"),
     cst_set$0=caml_string_of_jsbytes("set"),
     cst_script$3=caml_string_of_jsbytes("script"),
     cst_rect$0=caml_string_of_jsbytes("rect"),
     cst_radialgradient$0=caml_string_of_jsbytes("radialgradient"),
     cst_polyline$0=caml_string_of_jsbytes("polyline"),
     cst_polygon$0=caml_string_of_jsbytes("polygon"),
     cst_pattern$0=caml_string_of_jsbytes("pattern"),
     cst_path$0=caml_string_of_jsbytes("path"),
     cst_mpath$0=caml_string_of_jsbytes("mpath"),
     cst_missing_glyph$0=caml_string_of_jsbytes("missing-glyph"),
     cst_metadata$0=caml_string_of_jsbytes("metadata"),
     cst_mask$0=caml_string_of_jsbytes("mask"),
     cst_lineargradient$0=caml_string_of_jsbytes("lineargradient"),
     cst_line$0=caml_string_of_jsbytes("line"),
     cst_image$0=caml_string_of_jsbytes("image"),
     cst_hkern$0=caml_string_of_jsbytes("hkern"),
     cst_glyphref$0=caml_string_of_jsbytes("glyphref"),
     cst_glyph$0=caml_string_of_jsbytes("glyph"),
     cst_g$1=caml_string_of_jsbytes("g"),
     cst_foreignobject=caml_string_of_jsbytes("foreignobject"),
     cst_font_face_uri$0=caml_string_of_jsbytes("font-face-uri"),
     cst_font_face_src$0=caml_string_of_jsbytes("font-face-src"),
     cst_font_face_name$0=caml_string_of_jsbytes("font-face-name"),
     cst_font_face_format$0=caml_string_of_jsbytes("font-face-format"),
     cst_font_face$0=caml_string_of_jsbytes("font-face"),
     cst_font$0=caml_string_of_jsbytes("font"),
     cst_filter$0=caml_string_of_jsbytes("filter"),
     cst_ellipse$0=caml_string_of_jsbytes("ellipse"),
     cst_desc$0=caml_string_of_jsbytes("desc"),
     cst_defs$0=caml_string_of_jsbytes("defs"),
     cst_cursor$0=caml_string_of_jsbytes("cursor"),
     cst_clippath$0=caml_string_of_jsbytes("clippath"),
     cst_circle$0=caml_string_of_jsbytes("circle"),
     cst_animatetransform$0=caml_string_of_jsbytes("animatetransform"),
     cst_animatemotion$0=caml_string_of_jsbytes("animatemotion"),
     cst_animatecolor$0=caml_string_of_jsbytes("animatecolor"),
     cst_animate$0=caml_string_of_jsbytes("animate"),
     cst_altglyphitem$0=caml_string_of_jsbytes("altglyphitem"),
     cst_altglyphdef$0=caml_string_of_jsbytes("altglyphdef"),
     cst_altglyph$0=caml_string_of_jsbytes("altglyph"),
     cst_a$3=caml_string_of_jsbytes("a"),
     cst_vkern=caml_string_of_jsbytes("vkern"),
     cst_view=caml_string_of_jsbytes("view"),
     cst_use=caml_string_of_jsbytes("use"),
     cst_tspan=caml_string_of_jsbytes("tspan"),
     cst_tref=caml_string_of_jsbytes("tref"),
     cst_title$2=caml_string_of_jsbytes("title"),
     cst_textpath=caml_string_of_jsbytes("textpath"),
     cst_text$0=caml_string_of_jsbytes("text"),
     cst_symbol=caml_string_of_jsbytes("symbol"),
     cst_switch=caml_string_of_jsbytes("switch"),
     cst_svg=caml_string_of_jsbytes("svg"),
     cst_style$2=caml_string_of_jsbytes("style"),
     cst_stop=caml_string_of_jsbytes("stop"),
     cst_set=caml_string_of_jsbytes("set"),
     cst_script$2=caml_string_of_jsbytes("script"),
     cst_rect=caml_string_of_jsbytes("rect"),
     cst_radialgradient=caml_string_of_jsbytes("radialgradient"),
     cst_polyline=caml_string_of_jsbytes("polyline"),
     cst_polygon=caml_string_of_jsbytes("polygon"),
     cst_pattern=caml_string_of_jsbytes("pattern"),
     cst_path=caml_string_of_jsbytes("path"),
     cst_mpath=caml_string_of_jsbytes("mpath"),
     cst_missing_glyph=caml_string_of_jsbytes("missing-glyph"),
     cst_metadata=caml_string_of_jsbytes("metadata"),
     cst_mask=caml_string_of_jsbytes("mask"),
     cst_lineargradient=caml_string_of_jsbytes("lineargradient"),
     cst_line=caml_string_of_jsbytes("line"),
     cst_image=caml_string_of_jsbytes("image"),
     cst_hkern=caml_string_of_jsbytes("hkern"),
     cst_glyphref=caml_string_of_jsbytes("glyphref"),
     cst_glyph=caml_string_of_jsbytes("glyph"),
     cst_g$0=caml_string_of_jsbytes("g"),
     cst_foreignObject=caml_string_of_jsbytes("foreignObject"),
     cst_font_face_uri=caml_string_of_jsbytes("font-face-uri"),
     cst_font_face_src=caml_string_of_jsbytes("font-face-src"),
     cst_font_face_name=caml_string_of_jsbytes("font-face-name"),
     cst_font_face_format=caml_string_of_jsbytes("font-face-format"),
     cst_font_face=caml_string_of_jsbytes("font-face"),
     cst_font=caml_string_of_jsbytes("font"),
     cst_filter=caml_string_of_jsbytes("filter"),
     cst_ellipse=caml_string_of_jsbytes("ellipse"),
     cst_desc=caml_string_of_jsbytes("desc"),
     cst_defs=caml_string_of_jsbytes("defs"),
     cst_cursor=caml_string_of_jsbytes("cursor"),
     cst_clippath=caml_string_of_jsbytes("clippath"),
     cst_circle=caml_string_of_jsbytes("circle"),
     cst_animatetransform=caml_string_of_jsbytes("animatetransform"),
     cst_animatemotion=caml_string_of_jsbytes("animatemotion"),
     cst_animatecolor=caml_string_of_jsbytes("animatecolor"),
     cst_animate=caml_string_of_jsbytes("animate"),
     cst_altglyphitem=caml_string_of_jsbytes("altglyphitem"),
     cst_altglyphdef=caml_string_of_jsbytes("altglyphdef"),
     cst_altglyph=caml_string_of_jsbytes("altglyph"),
     cst_a$2=caml_string_of_jsbytes("a"),
     cst_Js_of_ocaml_Dom_svg_SVGErr=
      caml_string_of_jsbytes("Js_of_ocaml__Dom_svg.SVGError"),
     Stdlib_string=global_data.Stdlib__string,
     Stdlib_char=global_data.Stdlib__char,
     Stdlib=global_data.Stdlib,
     Stdlib_callback=global_data.Stdlib__callback,
     Stdlib_printexc=global_data.Stdlib__printexc,
     Assert_failure=global_data.Assert_failure,
     Stdlib_list=global_data.Stdlib__list,
     Stdlib_array=global_data.Stdlib__array,
     Stdlib_uchar=global_data.Stdlib__uchar,
     Stdlib_printf=global_data.Stdlib__printf,
     Js_of_ocaml=[0];
    caml_register_global(1632,Js_of_ocaml,"Js_of_ocaml__");
    var
     Poly=[0],
     _f_=[0,caml_string_of_jsbytes("lib/js_of_ocaml/dom.ml"),351,67],
     _g_=[0,caml_string_of_jsbytes("transparent")],
     _h_=[0,caml_string_of_jsbytes("native")],
     _l_=[0,caml_string_of_jsbytes("lib/js_of_ocaml/dom_html.ml"),2816,58],
     _k_=[0,caml_string_of_jsbytes("lib/js_of_ocaml/dom_html.ml"),2815,61],
     _j_=
      [0,
       [11,
        caml_string_of_jsbytes("getElementById_exn: "),
        [3,0,[11,caml_string_of_jsbytes(" not found"),0]]],
       caml_string_of_jsbytes("getElementById_exn: %S not found")],
     _n_=[0,caml_string_of_jsbytes("lib/js_of_ocaml/form.ml"),177,13],
     _m_=[0,1],
     _o_=[0,caml_string_of_jsbytes("lib/js_of_ocaml/regexp.ml"),34,64],
     _p_=[0,caml_string_of_jsbytes(""),0],
     _cj_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _ck_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _cl_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _cm_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _b7_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _b8_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _b9_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _b__=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _b$_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _ca_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _cb_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _cc_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _cd_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _ce_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _cf_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _cg_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _ch_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _ci_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _b6_=
      caml_list_of_js_array
       ([caml_string_of_jsbytes("aliceblue"),
         caml_string_of_jsbytes("antiquewhite"),
         caml_string_of_jsbytes("aqua"),
         caml_string_of_jsbytes("aquamarine"),
         caml_string_of_jsbytes("azure"),
         caml_string_of_jsbytes("beige"),
         caml_string_of_jsbytes("bisque"),
         caml_string_of_jsbytes("black"),
         caml_string_of_jsbytes("blanchedalmond"),
         caml_string_of_jsbytes("blue"),
         caml_string_of_jsbytes("blueviolet"),
         caml_string_of_jsbytes("brown"),
         caml_string_of_jsbytes("burlywood"),
         caml_string_of_jsbytes("cadetblue"),
         caml_string_of_jsbytes("chartreuse"),
         caml_string_of_jsbytes("chocolate"),
         caml_string_of_jsbytes("coral"),
         caml_string_of_jsbytes("cornflowerblue"),
         caml_string_of_jsbytes("cornsilk"),
         caml_string_of_jsbytes("crimson"),
         caml_string_of_jsbytes("cyan"),
         caml_string_of_jsbytes("darkblue"),
         caml_string_of_jsbytes("darkcyan"),
         caml_string_of_jsbytes("darkgoldenrod"),
         caml_string_of_jsbytes("darkgray"),
         caml_string_of_jsbytes("darkgreen"),
         caml_string_of_jsbytes("darkgrey"),
         caml_string_of_jsbytes("darkkhaki"),
         caml_string_of_jsbytes("darkmagenta"),
         caml_string_of_jsbytes("darkolivegreen"),
         caml_string_of_jsbytes("darkorange"),
         caml_string_of_jsbytes("darkorchid"),
         caml_string_of_jsbytes("darkred"),
         caml_string_of_jsbytes("darksalmon"),
         caml_string_of_jsbytes("darkseagreen"),
         caml_string_of_jsbytes("darkslateblue"),
         caml_string_of_jsbytes("darkslategray"),
         caml_string_of_jsbytes("darkslategrey"),
         caml_string_of_jsbytes("darkturquoise"),
         caml_string_of_jsbytes("darkviolet"),
         caml_string_of_jsbytes("deeppink"),
         caml_string_of_jsbytes("deepskyblue"),
         caml_string_of_jsbytes("dimgray"),
         caml_string_of_jsbytes("dimgrey"),
         caml_string_of_jsbytes("dodgerblue"),
         caml_string_of_jsbytes("firebrick"),
         caml_string_of_jsbytes("floralwhite"),
         caml_string_of_jsbytes("forestgreen"),
         caml_string_of_jsbytes("fuchsia"),
         caml_string_of_jsbytes("gainsboro"),
         caml_string_of_jsbytes("ghostwhite"),
         caml_string_of_jsbytes("gold"),
         caml_string_of_jsbytes("goldenrod"),
         caml_string_of_jsbytes("gray"),
         caml_string_of_jsbytes("green"),
         caml_string_of_jsbytes("greenyellow"),
         caml_string_of_jsbytes("grey"),
         caml_string_of_jsbytes("honeydew"),
         caml_string_of_jsbytes("hotpink"),
         caml_string_of_jsbytes("indianred"),
         caml_string_of_jsbytes("indigo"),
         caml_string_of_jsbytes("ivory"),
         caml_string_of_jsbytes("khaki"),
         caml_string_of_jsbytes("lavender"),
         caml_string_of_jsbytes("lavenderblush"),
         caml_string_of_jsbytes("lawngreen"),
         caml_string_of_jsbytes("lemonchiffon"),
         caml_string_of_jsbytes("lightblue"),
         caml_string_of_jsbytes("lightcoral"),
         caml_string_of_jsbytes("lightcyan"),
         caml_string_of_jsbytes("lightgoldenrodyellow"),
         caml_string_of_jsbytes("lightgray"),
         caml_string_of_jsbytes("lightgreen"),
         caml_string_of_jsbytes("lightgrey"),
         caml_string_of_jsbytes("lightpink"),
         caml_string_of_jsbytes("lightsalmon"),
         caml_string_of_jsbytes("lightseagreen"),
         caml_string_of_jsbytes("lightskyblue"),
         caml_string_of_jsbytes("lightslategray"),
         caml_string_of_jsbytes("lightslategrey"),
         caml_string_of_jsbytes("lightsteelblue"),
         caml_string_of_jsbytes("lightyellow"),
         caml_string_of_jsbytes("lime"),
         caml_string_of_jsbytes("limegreen"),
         caml_string_of_jsbytes("linen"),
         caml_string_of_jsbytes("magenta"),
         caml_string_of_jsbytes("maroon"),
         caml_string_of_jsbytes("mediumaquamarine"),
         caml_string_of_jsbytes("mediumblue"),
         caml_string_of_jsbytes("mediumorchid"),
         caml_string_of_jsbytes("mediumpurple"),
         caml_string_of_jsbytes("mediumseagreen"),
         caml_string_of_jsbytes("mediumslateblue"),
         caml_string_of_jsbytes("mediumspringgreen"),
         caml_string_of_jsbytes("mediumturquoise"),
         caml_string_of_jsbytes("mediumvioletred"),
         caml_string_of_jsbytes("midnightblue"),
         caml_string_of_jsbytes("mintcream"),
         caml_string_of_jsbytes("mistyrose"),
         caml_string_of_jsbytes("moccasin"),
         caml_string_of_jsbytes("navajowhite"),
         caml_string_of_jsbytes("navy"),
         caml_string_of_jsbytes("oldlace"),
         caml_string_of_jsbytes("olive"),
         caml_string_of_jsbytes("olivedrab"),
         caml_string_of_jsbytes("orange"),
         caml_string_of_jsbytes("orangered"),
         caml_string_of_jsbytes("orchid"),
         caml_string_of_jsbytes("palegoldenrod"),
         caml_string_of_jsbytes("palegreen"),
         caml_string_of_jsbytes("paleturquoise"),
         caml_string_of_jsbytes("palevioletred"),
         caml_string_of_jsbytes("papayawhip"),
         caml_string_of_jsbytes("peachpuff"),
         caml_string_of_jsbytes("peru"),
         caml_string_of_jsbytes("pink"),
         caml_string_of_jsbytes("plum"),
         caml_string_of_jsbytes("powderblue"),
         caml_string_of_jsbytes("purple"),
         caml_string_of_jsbytes("red"),
         caml_string_of_jsbytes("rosybrown"),
         caml_string_of_jsbytes("royalblue"),
         caml_string_of_jsbytes("saddlebrown"),
         caml_string_of_jsbytes("salmon"),
         caml_string_of_jsbytes("sandybrown"),
         caml_string_of_jsbytes("seagreen"),
         caml_string_of_jsbytes("seashell"),
         caml_string_of_jsbytes("sienna"),
         caml_string_of_jsbytes("silver"),
         caml_string_of_jsbytes("skyblue"),
         caml_string_of_jsbytes("slateblue"),
         caml_string_of_jsbytes("slategray"),
         caml_string_of_jsbytes("slategrey"),
         caml_string_of_jsbytes("snow"),
         caml_string_of_jsbytes("springgreen"),
         caml_string_of_jsbytes("steelblue"),
         caml_string_of_jsbytes("tan"),
         caml_string_of_jsbytes("teal"),
         caml_string_of_jsbytes("thistle"),
         caml_string_of_jsbytes("tomato"),
         caml_string_of_jsbytes("turquoise"),
         caml_string_of_jsbytes("violet"),
         caml_string_of_jsbytes("wheat"),
         caml_string_of_jsbytes("white"),
         caml_string_of_jsbytes("whitesmoke"),
         caml_string_of_jsbytes("yellow"),
         caml_string_of_jsbytes("yellowgreen")]),
     _b5_=
      [0,
       [12,35,[4,8,[0,2,2],0,[4,8,[0,2,2],0,[4,8,[0,2,2],0,0]]]],
       caml_string_of_jsbytes("#%02X%02X%02X")],
     _bZ_=
      [0,
       [11,
        caml_string_of_jsbytes("rgb("),
        [4,0,0,0,[12,44,[4,0,0,0,[12,44,[4,0,0,0,[12,41,0]]]]]]],
       caml_string_of_jsbytes("rgb(%d,%d,%d)")],
     _b0_=
      [0,
       [11,
        caml_string_of_jsbytes("rgb("),
        [4,
         0,
         0,
         0,
         [12,37,[12,44,[4,0,0,0,[12,37,[12,44,[4,0,0,0,[12,37,[12,41,0]]]]]]]]]],
       caml_string_of_jsbytes("rgb(%d%%,%d%%,%d%%)")],
     _b1_=
      [0,
       [11,
        caml_string_of_jsbytes("rgba("),
        [4,
         0,
         0,
         0,
         [12,44,[4,0,0,0,[12,44,[4,0,0,0,[12,44,[8,[0,0,0],0,0,[12,41,0]]]]]]]]],
       caml_string_of_jsbytes("rgba(%d,%d,%d,%f)")],
     _b2_=
      [0,
       [11,
        caml_string_of_jsbytes("rgba("),
        [4,
         0,
         0,
         0,
         [12,
          37,
          [12,44,[4,0,0,0,[12,37,[12,44,[4,0,0,0,[12,37,[12,44,partial]]]]]]]]]],
       caml_string_of_jsbytes("rgba(%d%%,%d%%,%d%%,%f)")],
     _b3_=
      [0,
       [11,
        caml_string_of_jsbytes("hsl("),
        [4,
         0,
         0,
         0,
         [12,44,[4,0,0,0,[12,37,[12,44,[4,0,0,0,[12,37,[12,41,0]]]]]]]]],
       caml_string_of_jsbytes("hsl(%d,%d%%,%d%%)")],
     _b4_=
      [0,
       [11,
        caml_string_of_jsbytes("hsla("),
        [4,
         0,
         0,
         0,
         [12,
          44,
          [4,
           0,
           0,
           0,
           [12,
            37,
            [12,44,[4,0,0,0,[12,37,[12,44,[8,partial$1,0,0,partial$0]]]]]]]]]],
       caml_string_of_jsbytes("hsla(%d,%d%%,%d%%,%f)")],
     _w_=[0,240,248,255],
     _x_=[0,250,235,215],
     _y_=[0,0,255,255],
     _z_=[0,127,255,212],
     _A_=[0,240,255,255],
     _B_=[0,245,245,220],
     _C_=[0,255,228,196],
     _D_=[0,0,0,0],
     _E_=[0,255,235,205],
     _F_=[0,0,0,255],
     _G_=[0,138,43,226],
     _H_=[0,165,42,42],
     _I_=[0,222,184,135],
     _J_=[0,95,158,160],
     _K_=[0,127,255,0],
     _L_=[0,210,105,30],
     _M_=[0,255,127,80],
     _N_=[0,100,149,237],
     _O_=[0,255,248,220],
     _P_=[0,220,20,60],
     _Q_=[0,0,255,255],
     _R_=[0,0,0,139],
     _S_=[0,0,139,139],
     _T_=[0,184,134,11],
     _U_=[0,169,169,169],
     _V_=[0,0,100,0],
     _W_=[0,169,169,169],
     _X_=[0,189,183,107],
     _Y_=[0,139,0,139],
     _Z_=[0,85,107,47],
     ___=[0,255,140,0],
     _$_=[0,153,50,204],
     _aa_=[0,139,0,0],
     _ab_=[0,233,150,122],
     _ac_=[0,143,188,143],
     _ad_=[0,72,61,139],
     _ae_=[0,47,79,79],
     _af_=[0,47,79,79],
     _ag_=[0,0,206,209],
     _ah_=[0,148,0,211],
     _ai_=[0,255,20,147],
     _aj_=[0,0,191,255],
     _ak_=[0,105,105,105],
     _al_=[0,105,105,105],
     _am_=[0,30,144,255],
     _an_=[0,178,34,34],
     _ao_=[0,255,250,240],
     _ap_=[0,34,139,34],
     _aq_=[0,255,0,255],
     _ar_=[0,220,220,220],
     _as_=[0,248,248,255],
     _at_=[0,255,215,0],
     _au_=[0,218,165,32],
     _av_=[0,128,128,128],
     _aw_=[0,128,128,128],
     _ax_=[0,0,128,0],
     _ay_=[0,173,255,47],
     _az_=[0,240,255,240],
     _aA_=[0,255,105,180],
     _aB_=[0,205,92,92],
     _aC_=[0,75,0,130],
     _aD_=[0,255,255,240],
     _aE_=[0,240,230,140],
     _aF_=[0,230,230,250],
     _aG_=[0,255,240,245],
     _aH_=[0,124,252,0],
     _aI_=[0,255,250,205],
     _aJ_=[0,173,216,230],
     _aK_=[0,240,128,128],
     _aL_=[0,224,255,255],
     _aM_=[0,250,250,210],
     _aN_=[0,211,211,211],
     _aO_=[0,144,238,144],
     _aP_=[0,211,211,211],
     _aQ_=[0,255,182,193],
     _aR_=[0,255,160,122],
     _aS_=[0,32,178,170],
     _aT_=[0,135,206,250],
     _aU_=[0,119,136,153],
     _aV_=[0,119,136,153],
     _aW_=[0,176,196,222],
     _aX_=[0,255,255,224],
     _aY_=[0,0,255,0],
     _aZ_=[0,50,205,50],
     _a0_=[0,250,240,230],
     _a1_=[0,255,0,255],
     _a2_=[0,128,0,0],
     _a3_=[0,102,205,170],
     _a4_=[0,0,0,205],
     _a5_=[0,186,85,211],
     _a6_=[0,147,112,219],
     _a7_=[0,60,179,113],
     _a8_=[0,123,104,238],
     _a9_=[0,0,250,154],
     _a__=[0,72,209,204],
     _a$_=[0,199,21,133],
     _ba_=[0,25,25,112],
     _bb_=[0,245,255,250],
     _bc_=[0,255,228,225],
     _bd_=[0,255,228,181],
     _be_=[0,255,222,173],
     _bf_=[0,0,0,128],
     _bg_=[0,253,245,230],
     _bh_=[0,128,128,0],
     _bi_=[0,107,142,35],
     _bj_=[0,255,165,0],
     _bk_=[0,255,69,0],
     _bl_=[0,218,112,214],
     _bm_=[0,238,232,170],
     _bn_=[0,152,251,152],
     _bo_=[0,175,238,238],
     _bp_=[0,219,112,147],
     _bq_=[0,255,239,213],
     _br_=[0,255,218,185],
     _bs_=[0,205,133,63],
     _bt_=[0,255,192,203],
     _bu_=[0,221,160,221],
     _bv_=[0,176,224,230],
     _bw_=[0,128,0,128],
     _bx_=[0,255,0,0],
     _by_=[0,188,143,143],
     _bz_=[0,65,105,225],
     _bA_=[0,139,69,19],
     _bB_=[0,250,128,114],
     _bC_=[0,244,164,96],
     _bD_=[0,46,139,87],
     _bE_=[0,255,245,238],
     _bF_=[0,160,82,45],
     _bG_=[0,192,192,192],
     _bH_=[0,135,206,235],
     _bI_=[0,106,90,205],
     _bJ_=[0,112,128,144],
     _bK_=[0,112,128,144],
     _bL_=[0,255,250,250],
     _bM_=[0,0,255,127],
     _bN_=[0,70,130,180],
     _bO_=[0,210,180,140],
     _bP_=[0,0,128,128],
     _bQ_=[0,216,191,216],
     _bR_=[0,255,99,71],
     _bS_=[0,64,224,208],
     _bT_=[0,238,130,238],
     _bU_=[0,245,222,179],
     _bV_=[0,255,255,255],
     _bW_=[0,245,245,245],
     _bX_=[0,255,255,0],
     _bY_=[0,154,205,50];
    function symbol(x,y){return x < y?1:0}
    function symbol$0(x,y){return x <= y?1:0}
    function symbol$1(x,y){return x !== y?1:0}
    function symbol$2(x,y){return x === y?1:0}
    function symbol$3(x,y){return y < x?1:0}
    function symbol$4(x,y){return y <= x?1:0}
    var compare=runtime.caml_int_compare;
    function equal(x,y){return x === y?1:0}
    function max(x,y){return y <= x?x:y}
    function min(x,y){return x <= y?x:y}
    var
     Int_replace_polymorphic_compar=
      [0,
       symbol,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       compare,
       equal,
       max,
       min],
     make=Stdlib_string[1],
     init=Stdlib_string[2],
     concat=Stdlib_string[3],
     compare$0=Stdlib_string[5],
     contains_from=Stdlib_string[6],
     rcontains_from=Stdlib_string[7],
     contains=Stdlib_string[8],
     sub=Stdlib_string[9],
     split_on_char=Stdlib_string[10],
     map=Stdlib_string[11],
     mapi=Stdlib_string[12],
     trim=Stdlib_string[13],
     escaped=Stdlib_string[14],
     uppercase_ascii=Stdlib_string[15],
     lowercase_ascii=Stdlib_string[16],
     capitalize_ascii=Stdlib_string[17],
     uncapitalize_ascii=Stdlib_string[18],
     iter=Stdlib_string[19],
     iteri=Stdlib_string[20],
     index_from=Stdlib_string[21],
     index_from_opt=Stdlib_string[22],
     rindex_from=Stdlib_string[23],
     rindex_from_opt=Stdlib_string[24],
     index=Stdlib_string[25],
     index_opt=Stdlib_string[26],
     rindex=Stdlib_string[27],
     rindex_opt=Stdlib_string[28],
     to_seq=Stdlib_string[29],
     to_seqi=Stdlib_string[30],
     of_seq=Stdlib_string[31],
     blit=Stdlib_string[32],
     copy=Stdlib_string[33],
     fill=Stdlib_string[34],
     uppercase=Stdlib_string[35],
     lowercase=Stdlib_string[36],
     capitalize=Stdlib_string[37],
     uncapitalize=Stdlib_string[38];
    function equal$0(x,y){return runtime.caml_string_equal(x,y)}
    var
     String=
      [0,
       make,
       init,
       concat,
       compare$0,
       contains_from,
       rcontains_from,
       contains,
       sub,
       split_on_char,
       map,
       mapi,
       trim,
       escaped,
       uppercase_ascii,
       lowercase_ascii,
       capitalize_ascii,
       uncapitalize_ascii,
       iter,
       iteri,
       index_from,
       index_from_opt,
       rindex_from,
       rindex_from_opt,
       index,
       index_opt,
       rindex,
       rindex_opt,
       to_seq,
       to_seqi,
       of_seq,
       blit,
       copy,
       fill,
       uppercase,
       lowercase,
       capitalize,
       uncapitalize,
       equal$0],
     chr=Stdlib_char[1],
     escaped$0=Stdlib_char[2],
     lowercase$0=Stdlib_char[3],
     uppercase$0=Stdlib_char[4],
     lowercase_ascii$0=Stdlib_char[5],
     uppercase_ascii$0=Stdlib_char[6],
     compare$1=Stdlib_char[7];
    function equal$1(x,y){return x === y?1:0}
    var
     Char=
      [0,
       chr,
       escaped$0,
       lowercase$0,
       uppercase$0,
       lowercase_ascii$0,
       uppercase_ascii$0,
       compare$1,
       equal$1],
     symbol$5=Int_replace_polymorphic_compar[1],
     symbol$6=Int_replace_polymorphic_compar[2],
     symbol$7=Int_replace_polymorphic_compar[3],
     symbol$8=Int_replace_polymorphic_compar[4],
     symbol$9=Int_replace_polymorphic_compar[5],
     symbol$10=Int_replace_polymorphic_compar[6],
     compare$2=Int_replace_polymorphic_compar[7],
     equal$2=Int_replace_polymorphic_compar[8],
     max$0=Int_replace_polymorphic_compar[9],
     min$0=Int_replace_polymorphic_compar[10],
     Js_of_ocaml_Import=
      [0,
       Poly,
       Int_replace_polymorphic_compar,
       String,
       Char,
       symbol$5,
       symbol$6,
       symbol$7,
       symbol$8,
       symbol$9,
       symbol$10,
       compare$2,
       equal$2,
       max$0,
       min$0];
    caml_register_global(1635,Js_of_ocaml_Import,"Js_of_ocaml__Import");
    var
     global=joo_global_object,
     Unsafe=[0,global],
     no_handler=null,
     t39=undefined;
    function return$0(_gH_){return _gH_}
    function map$0(x,f){return x == no_handler?no_handler:caml_call1(f,x)}
    function bind(x,f){return x == no_handler?no_handler:caml_call1(f,x)}
    function test(x){return 1 - (x == no_handler?1:0)}
    function iter$0(x,f)
     {var _gG_=1 - (x == no_handler?1:0);return _gG_?caml_call1(f,x):_gG_}
    function case$0(x,f,g)
     {return x == no_handler?caml_call1(f,0):caml_call1(g,x)}
    function get(x,f){return x == no_handler?caml_call1(f,0):x}
    function option(x){if(x){var x$0=x[1];return x$0}return no_handler}
    function to_option(x)
     {function _gF_(x){return [0,x]}
      return case$0(x,function(param){return 0},_gF_)}
    var
     Opt=
      [0,
       no_handler,
       return$0,
       map$0,
       bind,
       test,
       iter$0,
       case$0,
       get,
       option,
       to_option];
    function return$1(_gE_){return _gE_}
    function map$1(x,f){return x === t39?t39:caml_call1(f,x)}
    function bind$0(x,f){return x === t39?t39:caml_call1(f,x)}
    function test$0(x){return x !== t39?1:0}
    function iter$1(x,f)
     {var _gD_=x !== t39?1:0;return _gD_?caml_call1(f,x):_gD_}
    function case$1(x,f,g){return x === t39?caml_call1(f,0):caml_call1(g,x)}
    function get$0(x,f){return x === t39?caml_call1(f,0):x}
    function option$0(x){if(x){var x$0=x[1];return x$0}return t39}
    function to_option$0(x)
     {function _gC_(x){return [0,x]}
      return case$1(x,function(param){return 0},_gC_)}
    var
     Optdef=
      [0,
       t39,
       return$1,
       map$1,
       bind$0,
       test$0,
       iter$1,
       case$1,
       get$0,
       option$0,
       to_option$0];
    function coerce(x,f,g)
     {function _gA_(param){return caml_call1(g,x)}
      var _gB_=caml_call1(f,x);
      return caml_call2(Opt[8],_gB_,_gA_)}
    function coerce_opt(x,f,g)
     {function _gy_(param){return caml_call1(g,x)}
      var _gz_=caml_call2(Opt[4],x,f);
      return caml_call2(Opt[8],_gz_,_gy_)}
    var
     t25=true,
     t4=false,
     string_constr=Unsafe[1].String,
     t11=Unsafe[1].RegExp,
     t4$0=Unsafe[1].Object;
    function object_keys(t3){return t4$0.keys(t3)}
    var
     array_length=Unsafe[1].Array,
     array_get=caml_js_get,
     array_set=caml_js_set;
    function array_map(f,a)
     {return a.map
              (caml_js_wrap_callback
                (function(x,idx,param){return caml_call1(f,x)}))}
    function array_mapi(f,a)
     {return a.map
              (caml_js_wrap_callback
                (function(x,idx,param){return caml_call2(f,idx,x)}))}
    function str_array(_gx_){return _gx_}
    function match_result(_gw_){return _gw_}
    var
     t121=Unsafe[1].Date,
     math=Unsafe[1].Math,
     Error=[248,cst_Js_of_ocaml_Js_Error,caml_fresh_oo_id(0)],
     error_constr=Unsafe[1].Error;
    caml_call2(Stdlib_callback[2],cst_jsError,[0,Error,{}]);
    function raise_js_error(exn){throw exn}
    var JSON=Unsafe[1].JSON;
    function decodeURI(s){return Unsafe[1].decodeURI(s)}
    function decodeURIComponent(s){return Unsafe[1].decodeURIComponent(s)}
    function encodeURI(s){return Unsafe[1].encodeURI(s)}
    function encodeURIComponent(s){return Unsafe[1].encodeURIComponent(s)}
    function escape(s){return Unsafe[1].escape(s)}
    function unescape(s){return Unsafe[1].unescape(s)}
    function isNaN(i){return Unsafe[1].isNaN(i) | 0}
    function parseInt(s)
     {var s$0=Unsafe[1].parseInt(s);
      return isNaN(s$0)?caml_call1(Stdlib[2],cst_parseInt):s$0}
    function parseFloat(s)
     {var s$0=Unsafe[1].parseFloat(s);
      return isNaN(s$0)?caml_call1(Stdlib[2],cst_parseFloat):s$0}
    function _a_(param)
     {if(param[1] === Error)
       {var e=param[2];return [0,caml_string_of_jsstring(e.toString())]}
      return 0}
    caml_call1(Stdlib_printexc[9],_a_);
    function _b_(e)
     {return e instanceof array_length
              ?0
              :[0,caml_string_of_jsstring(e.toString())]}
    caml_call1(Stdlib_printexc[9],_b_);
    function string_of_error(e){return caml_string_of_jsstring(e.toString())}
    function export_js(field,x)
     {return runtime.caml_js_export_var(0)[field] = x}
    function export$0(field,x)
     {return export_js(caml_jsstring_of_string(field),x)}
    function export_all(obj)
     {var
       t25=object_keys(obj),
       t24=
        caml_js_wrap_callback
         (function(key,param,_gv_){return export_js(key,obj[key])});
      return t25.forEach(t24)}
    var _c_=runtime.caml_js_error_of_exception,_d_=caml_exn_with_js_backtrace;
    function _e_(_gu_){return _gu_}
    var
     Js_of_ocaml_Js=
      [0,
       no_handler,
       function(_gt_){return _gt_},
       t39,
       _e_,
       Opt,
       Optdef,
       t25,
       t4,
       string_constr,
       t11,
       t11,
       t11,
       object_keys,
       array_length,
       array_length,
       array_get,
       array_set,
       array_map,
       array_mapi,
       str_array,
       match_result,
       t121,
       t121,
       t121,
       t121,
       t121,
       t121,
       t121,
       t121,
       t121,
       math,
       error_constr,
       string_of_error,
       raise_js_error,
       _d_,
       _c_,
       Error,
       JSON,
       decodeURI,
       decodeURIComponent,
       encodeURI,
       encodeURIComponent,
       escape,
       unescape,
       isNaN,
       parseInt,
       parseFloat,
       coerce,
       coerce_opt,
       export$0,
       export_all,
       Unsafe];
    caml_register_global(1639,Js_of_ocaml_Js,"Js_of_ocaml__Js");
    function list_of_nodeList(nodeList)
     {var length=nodeList.length,acc=0,i=0;
      for(;;)
       {if(caml_call2(symbol$5,i,length))
         {var _gs_=nodeList.item(i),match=caml_call1(Opt[10],_gs_);
          if(match)
           {var e=match[1],i$0=i + 1 | 0,acc$0=[0,e,acc],acc=acc$0,i=i$0;
            continue}
          var i$1=i + 1 | 0,i=i$1;
          continue}
        return caml_call1(Stdlib_list[9],acc)}}
    var
     disconnected=1,
     preceding=2,
     following=4,
     contains$0=8,
     contained_by=16,
     implementation_specific=32;
    function has(t,mask){return caml_call2(symbol$8,t & mask,mask)}
    function add(x,y){return x | y}
    var
     DocumentPosition=
      [0,
       disconnected,
       preceding,
       following,
       contains$0,
       contained_by,
       implementation_specific,
       has,
       add,
       add];
    function appendChild(p,n){p.appendChild(n);return 0}
    function removeChild(p,n){p.removeChild(n);return 0}
    function replaceChild(p,n,o){p.replaceChild(n,o);return 0}
    function insertBefore(p,n,o){p.insertBefore(n,o);return 0}
    function nodeType(e)
     {var match=e.nodeType;
      if(match)
       {var switcher=match - 1 | 0;
        switch(switcher)
         {case 0:return [0,e];case 1:return [1,e];case 2:case 3:return [2,e]}}
      return [3,e]}
    function cast(e,t){return e.nodeType === t?e:no_handler}
    function element(e){return cast(e,1)}
    function text(e)
     {if(3 !== e.nodeType && 4 !== e.nodeType)return no_handler;return e}
    function attr(e){return cast(e,2)}
    function handler(f)
     {return function(e)
       {if(caml_call1(Opt[5],e))
         {var res=caml_call1(f,e);
          if(1 - (res | 0))e.preventDefault();
          return res}
        var e$0=event,res$0=caml_call1(f,e$0);
        if(1 - (res$0 | 0))e$0.returnValue = res$0;
        return res$0}}
    function full_handler(f)
     {return runtime.caml_js_wrap_meth_callback_unsafe
              (function(this$0,e)
                {if(caml_call1(Opt[5],e))
                  {var res=caml_call2(f,this$0,e);
                   if(1 - (res | 0))e.preventDefault();
                   return res}
                 var e$0=event,res$0=caml_call2(f,this$0,e$0);
                 if(1 - (res$0 | 0))e$0.returnValue = res$0;
                 return res$0})}
    function invoke_handler(f,this$0,event){return f.call(this$0,event)}
    function eventTarget(e)
     {function _gp_(param)
       {function _gr_(param){throw Stdlib[8]}
        return caml_call2(Opt[8],e.srcElement,_gr_)}
      var target=caml_call2(Opt[8],e.target,_gp_);
      if(target instanceof Unsafe[1].Node)
       {if(3 === target.nodeType)
         {var _gq_=function(param){throw [0,Assert_failure,_f_]};
          return caml_call2(Opt[8],target.parentNode,_gq_)}
        return target}
      return target}
    function make$0(s){return caml_jsstring_of_string(s)}
    var Event=[0,make$0];
    function addEventListenerWithOptions(t50,t47,capture,once,passive,t48)
     {if(t50.addEventListener === t39)
       {var
         t34="on".concat(t47),
         t35=
          function(e)
           {var _gm_=[0,t48,e,[0]];
            return function(_gn_,_go_)
             {return runtime.caml_js_call(_gm_,_gn_,_go_)}};
        t50.attachEvent(t34,t35);
        return function(param){return t50.detachEvent(t34,t35)}}
      var t49={};
      function iter(t,f){if(t){var b=t[1];return caml_call1(f,b)}return 0}
      iter(capture,function(b){return t49.capture = b});
      iter(once,function(b){return t49.once = b});
      iter(passive,function(b){return t49.passive = b});
      t50.addEventListener(t47,t48,t49);
      return function(param){return t50.removeEventListener(t47,t48,t49)}}
    function addEventListener(e,typ,h,capt)
     {return addEventListenerWithOptions(e,typ,[0,capt],0,0,h)}
    function removeEventListener(id){return caml_call1(id,0)}
    function preventDefault(ev)
     {return caml_call1(Optdef[5],ev.preventDefault)
              ?ev.preventDefault()
              :ev.returnValue = ! ! 0}
    function createCustomEvent(bubbles,cancelable,detail,t62)
     {function opt_iter(f,param)
       {if(param){var x=param[1];return caml_call1(f,x)}return 0}
      var t63={};
      opt_iter(function(x){return t63.bubbles = ! ! x},bubbles);
      opt_iter(function(x){return t63.cancelable = ! ! x},cancelable);
      opt_iter(function(x){return t63.detail = x},detail);
      var t64=Unsafe[1].CustomEvent;
      return new t64(t62,t63)}
    var
     Js_of_ocaml_Dom=
      [0,
       DocumentPosition,
       insertBefore,
       replaceChild,
       removeChild,
       appendChild,
       list_of_nodeList,
       nodeType,
       [0,element,text,attr],
       no_handler,
       handler,
       full_handler,
       invoke_handler,
       eventTarget,
       Event,
       addEventListenerWithOptions,
       addEventListener,
       removeEventListener,
       preventDefault,
       createCustomEvent];
    caml_register_global(1642,Js_of_ocaml_Dom,"Js_of_ocaml__Dom");
    var
     arrayBuffer=Unsafe[1].ArrayBuffer,
     int8Array_inBuffer=Unsafe[1].Int8Array,
     t11$0=Unsafe[1].Uint8Array,
     int16Array_inBuffer=Unsafe[1].Int16Array,
     uint16Array_inBuffer=Unsafe[1].Uint16Array,
     int32Array_inBuffer=Unsafe[1].Int32Array,
     uint32Array_inBuffer=Unsafe[1].Uint32Array,
     float32Array_inBuffer=Unsafe[1].Float32Array,
     float64Array_inBuffer=Unsafe[1].Float64Array,
     set=caml_js_set;
    function get$1(a,i){return a[i]}
    function unsafe_get(a,i){return a[i]}
    var dataView=Unsafe[1].DataView;
    function of_arrayBuffer(ab)
     {var uint8=new t11$0(ab);return caml_string_of_array(uint8)}
    var
     Js_of_ocaml_Typed_array=
      [0,
       arrayBuffer,
       runtime.caml_ba_kind_of_typed_array,
       runtime.caml_ba_to_typed_array,
       runtime.caml_ba_from_typed_array,
       int8Array_inBuffer,
       int8Array_inBuffer,
       int8Array_inBuffer,
       int8Array_inBuffer,
       int8Array_inBuffer,
       t11$0,
       t11$0,
       t11$0,
       t11$0,
       t11$0,
       int16Array_inBuffer,
       int16Array_inBuffer,
       int16Array_inBuffer,
       int16Array_inBuffer,
       int16Array_inBuffer,
       uint16Array_inBuffer,
       uint16Array_inBuffer,
       uint16Array_inBuffer,
       uint16Array_inBuffer,
       uint16Array_inBuffer,
       int32Array_inBuffer,
       int32Array_inBuffer,
       int32Array_inBuffer,
       int32Array_inBuffer,
       int32Array_inBuffer,
       uint32Array_inBuffer,
       uint32Array_inBuffer,
       uint32Array_inBuffer,
       uint32Array_inBuffer,
       uint32Array_inBuffer,
       float32Array_inBuffer,
       float32Array_inBuffer,
       float32Array_inBuffer,
       float32Array_inBuffer,
       float32Array_inBuffer,
       float64Array_inBuffer,
       float64Array_inBuffer,
       float64Array_inBuffer,
       float64Array_inBuffer,
       float64Array_inBuffer,
       set,
       get$1,
       unsafe_get,
       dataView,
       dataView,
       [0,
        runtime.bigstring_to_array_buffer,
        runtime.bigstring_to_typed_array,
        runtime.bigstring_of_array_buffer,
        runtime.bigstring_of_typed_array],
       [0,of_arrayBuffer,caml_string_of_array]];
    caml_register_global
     (1643,Js_of_ocaml_Typed_array,"Js_of_ocaml__Typed_array");
    var t3=Unsafe[1].Blob;
    function filter_map(f,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var q=param$0[2],v=param$0[1],match=caml_call1(f,v);
          if(match){var v$0=match[1];return [0,v$0,filter_map(f,q)]}
          var param$0=q;
          continue}
        return 0}}
    function blob_raw(contentType,endings,a)
     {var _gi_=0;
      if(endings)
       var _gj_=116179762 <= endings[1]?_g_:_h_,_gk_=_gj_;
      else
       var _gk_=0;
      var
       _gl_=[0,[0,cst_type,contentType],[0,[0,cst_endings,_gk_],_gi_]],
       options=
        filter_map
         (function(param)
           {var v=param[2],name=param[1];
            if(v)
             {var v$0=v[1];return [0,[0,name,caml_jsstring_of_string(v$0)]]}
            return 0},
          _gl_),
       options$0=
        options
         ?runtime.caml_js_object(caml_call1(Stdlib_array[12],options))
         :t39,
       t1=caml_js_from_array(a);
      return new t3(t1,options$0)}
    function blob_from_string(contentType,endings,s)
     {return blob_raw(contentType,endings,[0,caml_jsstring_of_string(s)])}
    function blob_from_any(contentType,endings,l)
     {function _gg_(param)
       {var _gh_=param[1];
        if(155580615 === _gh_){var s=param[2];return s}
        if(486041214 <= _gh_)
         {if(1037850489 <= _gh_){var a=param[2];return a}
          var a$0=param[2];
          return a$0}
        if(288368849 <= _gh_)
         {var s$0=param[2];return caml_jsstring_of_string(s$0)}
        var b=param[2];
        return b}
      var l$0=caml_call2(Stdlib_list[19],_gg_,l);
      return blob_raw(contentType,endings,caml_call1(Stdlib_array[12],l$0))}
    function filename(file)
     {var match=caml_call1(Optdef[10],file.name);
      if(match){var name=match[1];return name}
      var match$0=caml_call1(Optdef[10],file.fileName);
      if(match$0){var name$0=match$0[1];return name$0}
      return caml_call1(Stdlib[2],cst_can_t_retrieve_file_name_n)}
    var doc_constr=Unsafe[1].Document;
    function document(e){return e instanceof doc_constr?e:no_handler}
    function blob(e){return e instanceof t3?e:no_handler}
    function string(e){return typeof e === "string"?e:no_handler}
    function arrayBuffer$0(e){return e instanceof arrayBuffer?e:no_handler}
    var
     loadstart=caml_call1(Event[1],cst_loadstart),
     progress=caml_call1(Event[1],cst_progress),
     abort=caml_call1(Event[1],cst_abort),
     error=caml_call1(Event[1],cst_error),
     load=caml_call1(Event[1],cst_load),
     loadend=caml_call1(Event[1],cst_loadend),
     ReaderEvent=[0,loadstart,progress,abort,error,load,loadend],
     fileReader=Unsafe[1].FileReader,
     Js_of_ocaml_File=
      [0,
       blob_from_string,
       blob_from_any,
       [0,document,blob,function(_gf_){return _gf_},string,arrayBuffer$0],
       ReaderEvent,
       filename,
       fileReader,
       addEventListener];
    caml_register_global(1645,Js_of_ocaml_File,"Js_of_ocaml__File");
    var
     onIE=runtime.caml_js_on_ie(0) | 0,
     click=caml_call1(Event[1],cst_click),
     copy$0=caml_call1(Event[1],cst_copy),
     cut=caml_call1(Event[1],cst_cut),
     paste=caml_call1(Event[1],cst_paste),
     dblclick=caml_call1(Event[1],cst_dblclick),
     mousedown=caml_call1(Event[1],cst_mousedown),
     mouseup=caml_call1(Event[1],cst_mouseup),
     mouseover=caml_call1(Event[1],cst_mouseover),
     mousemove=caml_call1(Event[1],cst_mousemove),
     mouseout=caml_call1(Event[1],cst_mouseout),
     keypress=caml_call1(Event[1],cst_keypress),
     keydown=caml_call1(Event[1],cst_keydown),
     keyup=caml_call1(Event[1],cst_keyup),
     mousewheel=caml_call1(Event[1],cst_mousewheel),
     DOMMouseScroll=caml_call1(Event[1],cst_DOMMouseScroll),
     touchstart=caml_call1(Event[1],cst_touchstart),
     touchmove=caml_call1(Event[1],cst_touchmove),
     touchend=caml_call1(Event[1],cst_touchend),
     touchcancel=caml_call1(Event[1],cst_touchcancel),
     dragstart=caml_call1(Event[1],cst_dragstart),
     dragend=caml_call1(Event[1],cst_dragend),
     dragenter=caml_call1(Event[1],cst_dragenter),
     dragover=caml_call1(Event[1],cst_dragover),
     dragleave=caml_call1(Event[1],cst_dragleave),
     drag=caml_call1(Event[1],cst_drag),
     drop=caml_call1(Event[1],cst_drop),
     hashchange=caml_call1(Event[1],cst_hashchange),
     change=caml_call1(Event[1],cst_change),
     input=caml_call1(Event[1],cst_input),
     timeupdate=caml_call1(Event[1],cst_timeupdate),
     submit=caml_call1(Event[1],cst_submit),
     scroll=caml_call1(Event[1],cst_scroll),
     focus=caml_call1(Event[1],cst_focus),
     blur=caml_call1(Event[1],cst_blur),
     load$0=caml_call1(Event[1],cst_load$0),
     unload=caml_call1(Event[1],cst_unload),
     beforeunload=caml_call1(Event[1],cst_beforeunload),
     resize=caml_call1(Event[1],cst_resize),
     orientationchange=caml_call1(Event[1],cst_orientationchange),
     popstate=caml_call1(Event[1],cst_popstate),
     error$0=caml_call1(Event[1],cst_error$0),
     abort$0=caml_call1(Event[1],cst_abort$0),
     select=caml_call1(Event[1],cst_select),
     online=caml_call1(Event[1],cst_online),
     offline=caml_call1(Event[1],cst_offline),
     checking=caml_call1(Event[1],cst_checking),
     noupdate=caml_call1(Event[1],cst_noupdate),
     downloading=caml_call1(Event[1],cst_downloading),
     progress$0=caml_call1(Event[1],cst_progress$0),
     updateready=caml_call1(Event[1],cst_updateready),
     cached=caml_call1(Event[1],cst_cached),
     obsolete=caml_call1(Event[1],cst_obsolete),
     domContentLoaded=caml_call1(Event[1],cst_DOMContentLoaded),
     animationstart=caml_call1(Event[1],cst_animationstart),
     animationend=caml_call1(Event[1],cst_animationend),
     animationiteration=caml_call1(Event[1],cst_animationiteration),
     animationcancel=caml_call1(Event[1],cst_animationcancel),
     canplay=caml_call1(Event[1],cst_canplay),
     canplaythrough=caml_call1(Event[1],cst_canplaythrough),
     durationchange=caml_call1(Event[1],cst_durationchange),
     emptied=caml_call1(Event[1],cst_emptied),
     ended=caml_call1(Event[1],cst_ended),
     gotpointercapture=caml_call1(Event[1],cst_gotpointercapture),
     loadeddata=caml_call1(Event[1],cst_loadeddata),
     loadedmetadata=caml_call1(Event[1],cst_loadedmetadata),
     loadstart$0=caml_call1(Event[1],cst_loadstart$0),
     lostpointercapture=caml_call1(Event[1],cst_lostpointercapture),
     pause=caml_call1(Event[1],cst_pause),
     play=caml_call1(Event[1],cst_play),
     playing=caml_call1(Event[1],cst_playing),
     pointerenter=caml_call1(Event[1],cst_pointerenter),
     pointercancel=caml_call1(Event[1],cst_pointercancel),
     pointerdown=caml_call1(Event[1],cst_pointerdown),
     pointerleave=caml_call1(Event[1],cst_pointerleave),
     pointermove=caml_call1(Event[1],cst_pointermove),
     pointerout=caml_call1(Event[1],cst_pointerout),
     pointerover=caml_call1(Event[1],cst_pointerover),
     pointerup=caml_call1(Event[1],cst_pointerup),
     ratechange=caml_call1(Event[1],cst_ratechange),
     seeked=caml_call1(Event[1],cst_seeked),
     seeking=caml_call1(Event[1],cst_seeking),
     stalled=caml_call1(Event[1],cst_stalled),
     suspend=caml_call1(Event[1],cst_suspend),
     volumechange=caml_call1(Event[1],cst_volumechange),
     waiting=caml_call1(Event[1],cst_waiting),
     make$1=Event[1],
     Event$0=
      [0,
       click,
       copy$0,
       cut,
       paste,
       dblclick,
       mousedown,
       mouseup,
       mouseover,
       mousemove,
       mouseout,
       keypress,
       keydown,
       keyup,
       mousewheel,
       DOMMouseScroll,
       touchstart,
       touchmove,
       touchend,
       touchcancel,
       dragstart,
       dragend,
       dragenter,
       dragover,
       dragleave,
       drag,
       drop,
       hashchange,
       change,
       input,
       timeupdate,
       submit,
       scroll,
       focus,
       blur,
       load$0,
       unload,
       beforeunload,
       resize,
       orientationchange,
       popstate,
       error$0,
       abort$0,
       select,
       online,
       offline,
       checking,
       noupdate,
       downloading,
       progress$0,
       updateready,
       cached,
       obsolete,
       domContentLoaded,
       animationstart,
       animationend,
       animationiteration,
       animationcancel,
       canplay,
       canplaythrough,
       durationchange,
       emptied,
       ended,
       gotpointercapture,
       loadeddata,
       loadedmetadata,
       loadstart$0,
       lostpointercapture,
       pause,
       play,
       playing,
       pointerenter,
       pointercancel,
       pointerdown,
       pointerleave,
       pointermove,
       pointerout,
       pointerover,
       pointerup,
       ratechange,
       seeked,
       seeking,
       stalled,
       suspend,
       volumechange,
       waiting,
       make$1],
     d="2d";
    function location_origin(loc)
     {function _gd_(o){return o}
      function _ge_(param)
       {var t8=loc.protocol,t7=loc.hostname,port=loc.port;
        if
         (caml_call2(symbol$8,t8.length,0)
          &&
          caml_call2(symbol$8,t7.length,0))
         return "";
        var t13=t8.concat("//",t7);
        if(caml_call2(symbol$9,port.length,0))
         {var t12=loc.port;return t13.concat(":",t12)}
        return t13}
      return caml_call3(Optdef[7],loc.origin,_ge_,_gd_)}
    var _i_=Unsafe[1],t22=_i_.document;
    function getElementById(id)
     {function _ga_(pnode){return pnode}
      function _gb_(param){throw Stdlib[8]}
      var t15=caml_jsstring_of_string(id),_gc_=t22.getElementById(t15);
      return caml_call3(Opt[7],_gc_,_gb_,_ga_)}
    function getElementById_exn(id)
     {function _f8_(pnode){return pnode}
      function _f9_(param)
       {var _f$_=caml_call2(Stdlib_printf[4],_j_,id);
        return caml_call1(Stdlib[2],_f$_)}
      var t17=caml_jsstring_of_string(id),_f__=t22.getElementById(t17);
      return caml_call3(Opt[7],_f__,_f9_,_f8_)}
    function getElementById_opt(id)
     {var t19=caml_jsstring_of_string(id),_f7_=t22.getElementById(t19);
      return caml_call1(Opt[10],_f7_)}
    function getElementById_coerce(id,coerce)
     {function _f3_(e)
       {var _f6_=caml_call1(coerce,e);return caml_call1(Opt[10],_f6_)}
      function _f4_(param){return 0}
      var t21=caml_jsstring_of_string(id),_f5_=t22.getElementById(t21);
      return caml_call3(Opt[7],_f5_,_f4_,_f3_)}
    function opt_iter(x,f){if(x){var v=x[1];return caml_call1(f,v)}return 0}
    function createElement(t24,name)
     {var t23=caml_jsstring_of_string(name);return t24.createElement(t23)}
    function unsafeCreateElement(doc,name){return createElement(doc,name)}
    var createElementSyntax=[0,785140586];
    function unsafeCreateElementEx(type,name,doc,elt)
     {for(;;)
       {if(0 === type && 0 === name)return createElement(doc,elt);
        var _fX_=createElementSyntax[1];
        if(785140586 === _fX_)
         {try
           {var
             el=t22.createElement('<input name="x">'),
             _f0_=el.tagName.toLowerCase() === "input"?1:0,
             _f1_=_f0_?el.name === "x"?1:0:_f0_,
             _fY_=_f1_}
          catch(_f2_){var _fY_=0}
          var _fZ_=_fY_?982028505:-1003883683;
          createElementSyntax[1] = _fZ_;
          continue}
        if(982028505 <= _fX_)
         {var t40=new array_length();
          t40.push("<",caml_jsstring_of_string(elt));
          opt_iter
           (type,
            function(t)
             {var t34=caml_js_html_escape(t);
              t40.push(' type="',t34,'"');
              return 0});
          opt_iter
           (name,
            function(n)
             {var t38=caml_js_html_escape(n);
              t40.push(' name="',t38,'"');
              return 0});
          t40.push(">");
          return doc.createElement(t40.join(""))}
        var res=createElement(doc,elt);
        opt_iter(type,function(t){return res.type = t});
        opt_iter(name,function(n){return res.name = n});
        return res}}
    function createHtml(doc){return unsafeCreateElement(doc,cst_html)}
    function createHead(doc){return unsafeCreateElement(doc,cst_head)}
    function createLink(doc){return unsafeCreateElement(doc,cst_link)}
    function createTitle(doc){return unsafeCreateElement(doc,cst_title)}
    function createMeta(doc){return unsafeCreateElement(doc,cst_meta)}
    function createBase(doc){return unsafeCreateElement(doc,cst_base)}
    function createStyle(doc){return unsafeCreateElement(doc,cst_style)}
    function createBody(doc){return unsafeCreateElement(doc,cst_body)}
    function createForm(doc){return unsafeCreateElement(doc,cst_form)}
    function createOptgroup(doc){return unsafeCreateElement(doc,cst_optgroup)}
    function createOption(doc){return unsafeCreateElement(doc,cst_option)}
    function createSelect(type,name,doc)
     {return unsafeCreateElementEx(type,name,doc,cst_select$0)}
    function createInput(type,name,doc)
     {return unsafeCreateElementEx(type,name,doc,cst_input$0)}
    function createTextarea(type,name,doc)
     {return unsafeCreateElementEx(type,name,doc,cst_textarea)}
    function createButton(type,name,doc)
     {return unsafeCreateElementEx(type,name,doc,cst_button)}
    function createLabel(doc){return unsafeCreateElement(doc,cst_label)}
    function createFieldset(doc){return unsafeCreateElement(doc,cst_fieldset)}
    function createLegend(doc){return unsafeCreateElement(doc,cst_legend)}
    function createUl(doc){return unsafeCreateElement(doc,cst_ul)}
    function createOl(doc){return unsafeCreateElement(doc,cst_ol)}
    function createDl(doc){return unsafeCreateElement(doc,cst_dl)}
    function createLi(doc){return unsafeCreateElement(doc,cst_li)}
    function createDiv(doc){return unsafeCreateElement(doc,cst_div)}
    function createEmbed(doc){return unsafeCreateElement(doc,cst_embed)}
    function createP(doc){return unsafeCreateElement(doc,cst_p)}
    function createH1(doc){return unsafeCreateElement(doc,cst_h1)}
    function createH2(doc){return unsafeCreateElement(doc,cst_h2)}
    function createH3(doc){return unsafeCreateElement(doc,cst_h3)}
    function createH4(doc){return unsafeCreateElement(doc,cst_h4)}
    function createH5(doc){return unsafeCreateElement(doc,cst_h5)}
    function createH6(doc){return unsafeCreateElement(doc,cst_h6)}
    function createQ(doc){return unsafeCreateElement(doc,cst_q)}
    function createBlockquote(doc)
     {return unsafeCreateElement(doc,cst_blockquote)}
    function createPre(doc){return unsafeCreateElement(doc,cst_pre)}
    function createBr(doc){return unsafeCreateElement(doc,cst_br)}
    function createHr(doc){return unsafeCreateElement(doc,cst_hr)}
    function createIns(doc){return unsafeCreateElement(doc,cst_ins)}
    function createDel(doc){return unsafeCreateElement(doc,cst_del)}
    function createA(doc){return unsafeCreateElement(doc,cst_a)}
    function createImg(doc){return unsafeCreateElement(doc,cst_img)}
    function createObject(doc){return unsafeCreateElement(doc,cst_object)}
    function createParam(doc){return unsafeCreateElement(doc,cst_param)}
    function createMap(doc){return unsafeCreateElement(doc,cst_map)}
    function createArea(doc){return unsafeCreateElement(doc,cst_area)}
    function createScript(doc){return unsafeCreateElement(doc,cst_script)}
    function createTable(doc){return unsafeCreateElement(doc,cst_table)}
    function createCaption(doc){return unsafeCreateElement(doc,cst_caption)}
    function createCol(doc){return unsafeCreateElement(doc,cst_col)}
    function createColgroup(doc){return unsafeCreateElement(doc,cst_colgroup)}
    function createThead(doc){return unsafeCreateElement(doc,cst_thead)}
    function createTfoot(doc){return unsafeCreateElement(doc,cst_tfoot)}
    function createTbody(doc){return unsafeCreateElement(doc,cst_tbody)}
    function createTr(doc){return unsafeCreateElement(doc,cst_tr)}
    function createTh(doc){return unsafeCreateElement(doc,cst_th)}
    function createTd(doc){return unsafeCreateElement(doc,cst_td)}
    function createSub(doc){return createElement(doc,cst_sub)}
    function createSup(doc){return createElement(doc,cst_sup)}
    function createSpan(doc){return createElement(doc,cst_span)}
    function createTt(doc){return createElement(doc,cst_tt)}
    function createI(doc){return createElement(doc,cst_i)}
    function createB(doc){return createElement(doc,cst_b)}
    function createBig(doc){return createElement(doc,cst_big)}
    function createSmall(doc){return createElement(doc,cst_small)}
    function createEm(doc){return createElement(doc,cst_em)}
    function createStrong(doc){return createElement(doc,cst_strong)}
    function createCite(doc){return createElement(doc,cst_cite)}
    function createDfn(doc){return createElement(doc,cst_dfn)}
    function createCode(doc){return createElement(doc,cst_code)}
    function createSamp(doc){return createElement(doc,cst_samp)}
    function createKbd(doc){return createElement(doc,cst_kbd)}
    function createVar(doc){return createElement(doc,cst_var)}
    function createAbbr(doc){return createElement(doc,cst_abbr)}
    function createDd(doc){return createElement(doc,cst_dd)}
    function createDt(doc){return createElement(doc,cst_dt)}
    function createNoscript(doc){return createElement(doc,cst_noscript)}
    function createAddress(doc){return createElement(doc,cst_address)}
    function createFrameset(doc){return unsafeCreateElement(doc,cst_frameset)}
    function createFrame(doc){return unsafeCreateElement(doc,cst_frame)}
    function createIframe(doc){return unsafeCreateElement(doc,cst_iframe)}
    function createAudio(doc){return unsafeCreateElement(doc,cst_audio)}
    function createVideo(doc){return unsafeCreateElement(doc,cst_video)}
    var
     Canvas_not_available=
      [248,cst_Js_of_ocaml_Dom_html_Canva,caml_fresh_oo_id(0)];
    function createCanvas(doc)
     {var c=unsafeCreateElement(doc,cst_canvas);
      if(1 - caml_call1(Opt[5],c.getContext))throw Canvas_not_available;
      return c}
    var
     html_element=Unsafe[1].HTMLElement,
     element$0=
      html_element === t39
       ?function(e){return e.innerHTML === t39?no_handler:e}
       :function(e){return e instanceof html_element?e:no_handler};
    function unsafeCoerce(tag,e)
     {var t56=e.tagName,_fW_=caml_jsstring_of_string(tag);
      return t56.toLowerCase() === _fW_?e:no_handler}
    function a(e){return unsafeCoerce(cst_a$0,e)}
    function area(e){return unsafeCoerce(cst_area$0,e)}
    function base(e){return unsafeCoerce(cst_base$0,e)}
    function blockquote(e){return unsafeCoerce(cst_blockquote$0,e)}
    function body(e){return unsafeCoerce(cst_body$0,e)}
    function br(e){return unsafeCoerce(cst_br$0,e)}
    function button(e){return unsafeCoerce(cst_button$0,e)}
    function canvas(e){return unsafeCoerce(cst_canvas$0,e)}
    function caption(e){return unsafeCoerce(cst_caption$0,e)}
    function col(e){return unsafeCoerce(cst_col$0,e)}
    function colgroup(e){return unsafeCoerce(cst_colgroup$0,e)}
    function del(e){return unsafeCoerce(cst_del$0,e)}
    function div(e){return unsafeCoerce(cst_div$0,e)}
    function dl(e){return unsafeCoerce(cst_dl$0,e)}
    function fieldset(e){return unsafeCoerce(cst_fieldset$0,e)}
    function embed(e){return unsafeCoerce(cst_embed$0,e)}
    function form(e){return unsafeCoerce(cst_form$0,e)}
    function frameset(e){return unsafeCoerce(cst_frameset$0,e)}
    function frame(e){return unsafeCoerce(cst_frame$0,e)}
    function h1(e){return unsafeCoerce(cst_h1$0,e)}
    function h2(e){return unsafeCoerce(cst_h2$0,e)}
    function h3(e){return unsafeCoerce(cst_h3$0,e)}
    function h4(e){return unsafeCoerce(cst_h4$0,e)}
    function h5(e){return unsafeCoerce(cst_h5$0,e)}
    function h6(e){return unsafeCoerce(cst_h6$0,e)}
    function head(e){return unsafeCoerce(cst_head$0,e)}
    function hr(e){return unsafeCoerce(cst_hr$0,e)}
    function html(e){return unsafeCoerce(cst_html$0,e)}
    function iframe(e){return unsafeCoerce(cst_iframe$0,e)}
    function img(e){return unsafeCoerce(cst_img$0,e)}
    function input$0(e){return unsafeCoerce(cst_input$1,e)}
    function ins(e){return unsafeCoerce(cst_ins$0,e)}
    function label(e){return unsafeCoerce(cst_label$0,e)}
    function legend(e){return unsafeCoerce(cst_legend$0,e)}
    function li(e){return unsafeCoerce(cst_li$0,e)}
    function link(e){return unsafeCoerce(cst_link$0,e)}
    function map$2(e){return unsafeCoerce(cst_map$0,e)}
    function meta(e){return unsafeCoerce(cst_meta$0,e)}
    function object(e){return unsafeCoerce(cst_object$0,e)}
    function ol(e){return unsafeCoerce(cst_ol$0,e)}
    function optgroup(e){return unsafeCoerce(cst_optgroup$0,e)}
    function option$1(e){return unsafeCoerce(cst_option$0,e)}
    function p(e){return unsafeCoerce(cst_p$0,e)}
    function param(e){return unsafeCoerce(cst_param$0,e)}
    function pre(e){return unsafeCoerce(cst_pre$0,e)}
    function q(e){return unsafeCoerce(cst_q$0,e)}
    function script(e){return unsafeCoerce(cst_script$0,e)}
    function select$0(e){return unsafeCoerce(cst_select$1,e)}
    function style(e){return unsafeCoerce(cst_style$0,e)}
    function table(e){return unsafeCoerce(cst_table$0,e)}
    function tbody(e){return unsafeCoerce(cst_tbody$0,e)}
    function td(e){return unsafeCoerce(cst_td$0,e)}
    function textarea(e){return unsafeCoerce(cst_textarea$0,e)}
    function tfoot(e){return unsafeCoerce(cst_tfoot$0,e)}
    function th(e){return unsafeCoerce(cst_th$0,e)}
    function thead(e){return unsafeCoerce(cst_thead$0,e)}
    function title(e){return unsafeCoerce(cst_title$0,e)}
    function tr(e){return unsafeCoerce(cst_tr$0,e)}
    function ul(e){return unsafeCoerce(cst_ul$0,e)}
    function audio(e){return unsafeCoerce(cst_audio$0,e)}
    function video(e){return unsafeCoerce(cst_video$0,e)}
    function unsafeCoerceEvent(constr,ev)
     {if(constr !== t39 && ev instanceof constr)return ev;return no_handler}
    function mouseEvent(ev){return unsafeCoerceEvent(Unsafe[1].MouseEvent,ev)}
    function keyboardEvent(ev)
     {return unsafeCoerceEvent(Unsafe[1].KeyboardEvent,ev)}
    function wheelEvent(ev){return unsafeCoerceEvent(Unsafe[1].WheelEvent,ev)}
    function mouseScrollEvent(ev)
     {return unsafeCoerceEvent(Unsafe[1].MouseScrollEvent,ev)}
    function popStateEvent(ev)
     {return unsafeCoerceEvent(Unsafe[1].PopStateEvent,ev)}
    function eventRelatedTarget(e)
     {function _fT_(param)
       {var match=caml_string_of_jsstring(e.type);
        if(caml_string_notequal(match,cst_mouseout$0))
         {if(caml_string_notequal(match,cst_mouseover$0))return no_handler;
          var _fU_=function(param){throw [0,Assert_failure,_k_]};
          return caml_call2(Optdef[8],e.fromElement,_fU_)}
        function _fV_(param){throw [0,Assert_failure,_l_]}
        return caml_call2(Optdef[8],e.toElement,_fV_)}
      return caml_call2(Optdef[8],e.relatedTarget,_fT_)}
    function eventAbsolutePosition(e)
     {var body=t22.body,html=t22.documentElement;
      return [0,
              (e.clientX + body.scrollLeft | 0) + html.scrollLeft | 0,
              (e.clientY + body.scrollTop | 0) + html.scrollTop | 0]}
    function eventAbsolutePosition$0(e)
     {function _fP_(x)
       {function _fR_(y){return [0,x,y]}
        function _fS_(param){return eventAbsolutePosition(e)}
        return caml_call3(Optdef[7],e.pageY,_fS_,_fR_)}
      function _fQ_(param){return eventAbsolutePosition(e)}
      return caml_call3(Optdef[7],e.pageX,_fQ_,_fP_)}
    function elementClientPosition(e)
     {var r=e.getBoundingClientRect(),body=t22.body,html=t22.documentElement;
      return [0,
              ((r.left | 0) - body.clientLeft | 0) - html.clientLeft | 0,
              ((r.top | 0) - body.clientTop | 0) - html.clientTop | 0]}
    function getDocumentScroll(param)
     {var body=t22.body,html=t22.documentElement;
      return [0,
              body.scrollLeft + html.scrollLeft | 0,
              body.scrollTop + html.scrollTop | 0]}
    function buttonPressed(ev)
     {function _fN_(x){return x}
      function _fO_(param)
       {var match=ev.button,switcher=match - 1 | 0;
        if(! (3 < switcher >>> 0))
         switch(switcher)
          {case 0:return 1;case 1:return 3;case 2:break;default:return 2}
        return 0}
      return caml_call3(Optdef[7],ev.which,_fO_,_fN_)}
    function addMousewheelEventListenerWith(e,capture,once,passive,h)
     {var t95=createDiv(t22);
      t95.setAttribute("onmousewheel","return;");
      if(typeof t95.onmousewheel === "function")
       {var
         _fJ_=
          handler
           (function(e)
             {function _fL_(param){return 0}
              var
               dx=
                (- caml_call2(Optdef[8],e.wheelDeltaX,_fL_) | 0) / 40 | 0;
              function _fM_(param){return e.wheelDelta}
              var
               dy=
                (- caml_call2(Optdef[8],e.wheelDeltaY,_fM_) | 0) / 40 | 0;
              return caml_call3(h,e,dx,dy)});
        return addEventListenerWithOptions
                (e,Event$0[14],capture,once,passive,_fJ_)}
      var
       _fK_=
        handler
         (function(e)
           {var d=e.detail;
            return e.axis === e.HORIZONTAL
                    ?caml_call3(h,e,d,0)
                    :caml_call3(h,e,0,d)});
      return addEventListenerWithOptions
              (e,Event$0[15],capture,once,passive,_fK_)}
    function addMousewheelEventListener(e,h,capt)
     {return addMousewheelEventListenerWith(e,[0,capt],0,0,h)}
    function f(v)
     {var
       match=caml_string_of_jsstring(v),
       switch$0=caml_string_compare(match,cst_KeyH);
      if(0 <= switch$0)
       {if(! (0 < switch$0))return 8;
        var switch$1=caml_string_compare(match,cst_Numpad4);
        if(0 <= switch$1)
         {if(! (0 < switch$1))return 72;
          var switch$2=caml_string_compare(match,cst_PageUp);
          if(0 <= switch$2)
           {if(! (0 < switch$2))return 98;
            var switch$3=caml_string_compare(match,cst_ShiftRight);
            if(0 <= switch$3)
             {if(! (0 < switch$3))return 91;
              if(! caml_string_notequal(match,cst_Slash))return 55;
              if(! caml_string_notequal(match,cst_Space))return 41;
              if(! caml_string_notequal(match,cst_Tab))return 39;
              if(! caml_string_notequal(match,cst_VolumeDown))return 103;
              if(! caml_string_notequal(match,cst_VolumeMute))return 102;
              if(! caml_string_notequal(match,cst_VolumeUp))return 104}
            else
             {if(! caml_string_notequal(match,cst_Pause))return 123;
              if(! caml_string_notequal(match,cst_Period))return 54;
              if(! caml_string_notequal(match,cst_PrintScreen))return 120;
              if(! caml_string_notequal(match,cst_Quote))return 50;
              if(! caml_string_notequal(match,cst_ScrollLock))return 119;
              if(! caml_string_notequal(match,cst_Semicolon))return 49;
              if(! caml_string_notequal(match,cst_ShiftLeft))return 90}}
          else
           {var switch$4=caml_string_compare(match,cst_NumpadDivide);
            if(0 <= switch$4)
             {if(! (0 < switch$4))return 84;
              if(! caml_string_notequal(match,cst_NumpadEnter))return 83;
              if(! caml_string_notequal(match,cst_NumpadEqual))return 82;
              if(! caml_string_notequal(match,cst_NumpadMultiply))return 78;
              if(! caml_string_notequal(match,cst_NumpadSubtract))return 79;
              if(! caml_string_notequal(match,cst_OSLeft))return 117;
              if(! caml_string_notequal(match,cst_OSRight))return 118;
              if(! caml_string_notequal(match,cst_PageDown))return 99}
            else
             {if(! caml_string_notequal(match,cst_Numpad5))return 73;
              if(! caml_string_notequal(match,cst_Numpad6))return 74;
              if(! caml_string_notequal(match,cst_Numpad7))return 75;
              if(! caml_string_notequal(match,cst_Numpad8))return 76;
              if(! caml_string_notequal(match,cst_Numpad9))return 77;
              if(! caml_string_notequal(match,cst_NumpadAdd))return 80;
              if(! caml_string_notequal(match,cst_NumpadDecimal))return 81}}}
        else
         {var switch$5=caml_string_compare(match,cst_KeyX);
          if(0 <= switch$5)
           {if(! (0 < switch$5))return 24;
            var switch$6=caml_string_compare(match,cst_MetaRight);
            if(0 <= switch$6)
             {if(! (0 < switch$6))return 89;
              if(! caml_string_notequal(match,cst_Minus))return 37;
              if(! caml_string_notequal(match,cst_NumLock))return 85;
              if(! caml_string_notequal(match,cst_Numpad0))return 68;
              if(! caml_string_notequal(match,cst_Numpad1))return 69;
              if(! caml_string_notequal(match,cst_Numpad2))return 70;
              if(! caml_string_notequal(match,cst_Numpad3))return 71}
            else
             {if(! caml_string_notequal(match,cst_KeyY))return 25;
              if(! caml_string_notequal(match,cst_KeyZ))return 26;
              if(! caml_string_notequal(match,cst_MediaPlayPause))return 107;
              if(! caml_string_notequal(match,cst_MediaStop))return 108;
              if(! caml_string_notequal(match,cst_MediaTrackNext))return 106;
              if(! caml_string_notequal(match,cst_MediaTrackPrevious))
               return 105;
              if(! caml_string_notequal(match,cst_MetaLeft))return 88}}
          else
           {var switch$7=caml_string_compare(match,cst_KeyP);
            if(0 <= switch$7)
             {if(! (0 < switch$7))return 16;
              if(! caml_string_notequal(match,cst_KeyQ))return 17;
              if(! caml_string_notequal(match,cst_KeyR))return 18;
              if(! caml_string_notequal(match,cst_KeyS))return 19;
              if(! caml_string_notequal(match,cst_KeyT))return 20;
              if(! caml_string_notequal(match,cst_KeyU))return 21;
              if(! caml_string_notequal(match,cst_KeyV))return 22;
              if(! caml_string_notequal(match,cst_KeyW))return 23}
            else
             {if(! caml_string_notequal(match,cst_KeyI))return 9;
              if(! caml_string_notequal(match,cst_KeyJ))return 10;
              if(! caml_string_notequal(match,cst_KeyK))return 11;
              if(! caml_string_notequal(match,cst_KeyL))return 12;
              if(! caml_string_notequal(match,cst_KeyM))return 13;
              if(! caml_string_notequal(match,cst_KeyN))return 14;
              if(! caml_string_notequal(match,cst_KeyO))return 15}}}}
      else
       {var switch$8=caml_string_compare(match,cst_Digit6);
        if(0 <= switch$8)
         {if(! (0 < switch$8))return 33;
          var switch$9=caml_string_compare(match,cst_F6);
          if(0 <= switch$9)
           {if(! (0 < switch$9))return 61;
            var switch$10=caml_string_compare(match,cst_KeyA);
            if(0 <= switch$10)
             {if(! (0 < switch$10))return 1;
              if(! caml_string_notequal(match,cst_KeyB))return 2;
              if(! caml_string_notequal(match,cst_KeyC))return 3;
              if(! caml_string_notequal(match,cst_KeyD))return 4;
              if(! caml_string_notequal(match,cst_KeyE))return 5;
              if(! caml_string_notequal(match,cst_KeyF))return 6;
              if(! caml_string_notequal(match,cst_KeyG))return 7}
            else
             {if(! caml_string_notequal(match,cst_F7))return 62;
              if(! caml_string_notequal(match,cst_F8))return 63;
              if(! caml_string_notequal(match,cst_F9))return 64;
              if(! caml_string_notequal(match,cst_Home))return 100;
              if(! caml_string_notequal(match,cst_Insert))return 44;
              if(! caml_string_notequal(match,cst_IntlBackslash))return 121;
              if(! caml_string_notequal(match,cst_IntlYen))return 122}}
          else
           {var switch$11=caml_string_compare(match,cst_F1);
            if(0 <= switch$11)
             {if(! (0 < switch$11))return 56;
              if(! caml_string_notequal(match,cst_F10))return 65;
              if(! caml_string_notequal(match,cst_F11))return 66;
              if(! caml_string_notequal(match,cst_F12))return 67;
              if(! caml_string_notequal(match,cst_F2))return 57;
              if(! caml_string_notequal(match,cst_F3))return 58;
              if(! caml_string_notequal(match,cst_F4))return 59;
              if(! caml_string_notequal(match,cst_F5))return 60}
            else
             {if(! caml_string_notequal(match,cst_Digit7))return 34;
              if(! caml_string_notequal(match,cst_Digit8))return 35;
              if(! caml_string_notequal(match,cst_Digit9))return 36;
              if(! caml_string_notequal(match,cst_End))return 101;
              if(! caml_string_notequal(match,cst_Enter))return 40;
              if(! caml_string_notequal(match,cst_Equal))return 38;
              if(! caml_string_notequal(match,cst_Escape))return 42}}}
        else
         {var switch$12=caml_string_compare(match,cst_BrowserRefresh);
          if(0 <= switch$12)
           {if(! (0 < switch$12))return 113;
            var switch$13=caml_string_compare(match,cst_Delete);
            if(0 <= switch$13)
             {if(! (0 < switch$13))return 45;
              if(! caml_string_notequal(match,cst_Digit0))return 27;
              if(! caml_string_notequal(match,cst_Digit1))return 28;
              if(! caml_string_notequal(match,cst_Digit2))return 29;
              if(! caml_string_notequal(match,cst_Digit3))return 30;
              if(! caml_string_notequal(match,cst_Digit4))return 31;
              if(! caml_string_notequal(match,cst_Digit5))return 32}
            else
             {if(! caml_string_notequal(match,cst_BrowserSearch))return 110;
              if(! caml_string_notequal(match,cst_BrowserStop))return 114;
              if(! caml_string_notequal(match,cst_CapsLock))return 46;
              if(! caml_string_notequal(match,cst_Comma))return 53;
              if(! caml_string_notequal(match,cst_ContextMenu))return 109;
              if(! caml_string_notequal(match,cst_ControlLeft))return 86;
              if(! caml_string_notequal(match,cst_ControlRight))return 87}}
          else
           {var switch$14=caml_string_compare(match,cst_Backslash);
            if(0 <= switch$14)
             {if(! (0 < switch$14))return 52;
              if(! caml_string_notequal(match,cst_Backspace))return 43;
              if(! caml_string_notequal(match,cst_BracketLeft))return 47;
              if(! caml_string_notequal(match,cst_BracketRight))return 48;
              if(! caml_string_notequal(match,cst_BrowserBack))return 116;
              if(! caml_string_notequal(match,cst_BrowserFavorites))
               return 112;
              if(! caml_string_notequal(match,cst_BrowserForward))return 115;
              if(! caml_string_notequal(match,cst_BrowserHome))return 111}
            else
             {if(! caml_string_notequal(match,cst_AltLeft))return 92;
              if(! caml_string_notequal(match,cst_AltRight))return 93;
              if(! caml_string_notequal(match,cst_ArrowDown))return 97;
              if(! caml_string_notequal(match,cst_ArrowLeft))return 94;
              if(! caml_string_notequal(match,cst_ArrowRight))return 95;
              if(! caml_string_notequal(match,cst_ArrowUp))return 96;
              if(! caml_string_notequal(match,cst_Backquote))return 51}}}}
      return 0}
    function try_key_code_left(param)
     {if(19 <= param)
       {if(91 === param)return 88}
      else
       if(16 <= param)
        {var switcher=param - 16 | 0;
         switch(switcher){case 0:return 90;case 1:return 86;default:return 92}}
      return 0}
    function try_key_code_right(param)
     {if(19 <= param)
       {if(91 === param)return 89}
      else
       if(16 <= param)
        {var switcher=param - 16 | 0;
         switch(switcher){case 0:return 91;case 1:return 87;default:return 93}}
      return 0}
    function try_key_code_numpad(param)
     {if(47 <= param)
       {var switcher=param - 96 | 0;
        if(! (15 < switcher >>> 0))
         switch(switcher)
          {case 0:return 68;
           case 1:return 69;
           case 2:return 70;
           case 3:return 71;
           case 4:return 72;
           case 5:return 73;
           case 6:return 74;
           case 7:return 75;
           case 8:return 76;
           case 9:return 77;
           case 10:return 78;
           case 11:return 80;
           case 12:break;
           case 13:return 79;
           case 14:return 81;
           default:return 84}}
      else
       if(12 <= param)
        {var switcher$0=param - 12 | 0;
         switch(switcher$0)
          {case 0:return 73;
           case 1:return 83;
           case 21:return 77;
           case 22:return 71;
           case 23:return 69;
           case 24:return 75;
           case 25:return 72;
           case 26:return 76;
           case 27:return 74;
           case 28:return 70;
           case 33:return 68;
           case 34:return 81
           }}
      return 0}
    function try_key_code_normal(param)
     {var switcher=param - 8 | 0;
      if(! (214 < switcher >>> 0))
       {var _fI_=switcher;
        if(67 <= _fI_)
         switch(_fI_)
          {case 67:return 11;
           case 68:return 12;
           case 69:return 13;
           case 70:return 14;
           case 71:return 15;
           case 72:return 16;
           case 73:return 17;
           case 74:return 18;
           case 75:return 19;
           case 76:return 20;
           case 77:return 21;
           case 78:return 22;
           case 79:return 23;
           case 80:return 24;
           case 81:return 25;
           case 82:return 26;
           case 85:return 109;
           case 104:return 56;
           case 105:return 57;
           case 106:return 58;
           case 107:return 59;
           case 108:return 60;
           case 109:return 61;
           case 110:return 62;
           case 111:return 63;
           case 112:return 64;
           case 113:return 65;
           case 114:return 66;
           case 115:return 67;
           case 137:return 119;
           case 178:return 49;
           case 179:return 38;
           case 180:return 53;
           case 181:return 37;
           case 182:return 54;
           case 183:return 55;
           case 184:return 51;
           case 211:return 47;
           case 212:return 52;
           case 213:return 48;
           case 214:return 50
           }
        else
         switch(_fI_)
          {case 0:return 43;
           case 1:return 39;
           case 5:return 40;
           case 11:return 123;
           case 12:return 46;
           case 19:return 42;
           case 24:return 41;
           case 25:return 98;
           case 26:return 99;
           case 27:return 101;
           case 28:return 100;
           case 29:return 94;
           case 30:return 96;
           case 31:return 95;
           case 32:return 97;
           case 34:return 120;
           case 37:return 44;
           case 38:return 45;
           case 40:return 27;
           case 41:return 28;
           case 42:return 29;
           case 43:return 30;
           case 44:return 31;
           case 45:return 32;
           case 46:return 33;
           case 47:return 34;
           case 48:return 35;
           case 49:return 36;
           case 57:return 1;
           case 58:return 2;
           case 59:return 3;
           case 60:return 4;
           case 61:return 5;
           case 62:return 6;
           case 63:return 7;
           case 64:return 8;
           case 65:return 9;
           case 66:return 10
           }}
      return 0}
    function make_unidentified(param){return 0}
    function run_next(value,f,v){return v?v:caml_call1(f,value)}
    function symbol$11(x,f){return caml_call1(f,x)}
    function of_event(evt)
     {var _fB_=evt.keyCode;
      function _fC_(_fH_){return run_next(_fB_,try_key_code_normal,_fH_)}
      var match=evt.location,switcher=match - 1 | 0;
      if(2 < switcher >>> 0)
       var _fD_=make_unidentified;
      else
       switch(switcher)
        {case 0:
          var
           _fy_=evt.keyCode,
           _fD_=function(_fF_){return run_next(_fy_,try_key_code_left,_fF_)};
          break;
         case 1:
          var
           _fz_=evt.keyCode,
           _fD_=function(_fE_){return run_next(_fz_,try_key_code_right,_fE_)};
          break;
         default:
          var
           _fA_=evt.keyCode,
           _fD_=function(_fG_){return run_next(_fA_,try_key_code_numpad,_fG_)}}
      var value=evt.code;
      return symbol$11
              (symbol$11
                (symbol$11
                  (0,
                   function(v)
                    {return v?v:caml_call3(Optdef[7],value,make_unidentified,f)}),
                 _fD_),
               _fC_)}
    function char_of_int(value)
     {if(caml_call2(symbol$5,0,value))
       try
        {var _fw_=[0,caml_call1(Stdlib_uchar[8],value)];return _fw_}
       catch(_fx_){return 0}
      return 0}
    function empty_string(param){return ""}
    function none(param){return 0}
    function of_event$0(evt)
     {var t109=caml_call2(Optdef[8],evt.key,empty_string),match=t109.length;
      return 0 === match
              ?caml_call3(Optdef[7],evt.charCode,none,char_of_int)
              :1 === match?char_of_int(t109.charCodeAt(0) | 0):0}
    function element$1(_fv_){return _fv_}
    function tagged(e)
     {var t111=e.tagName,tag=caml_string_of_jsbytes(t111.toLowerCase());
      if(caml_call2(symbol$8,caml_ml_string_length(tag),0))return [61,e];
      var match=runtime.caml_string_unsafe_get(tag,0),switcher=match - 97 | 0;
      if(! (21 < switcher >>> 0))
       switch(switcher)
        {case 0:
          return caml_string_notequal(tag,cst_a$1)
                  ?caml_string_notequal(tag,cst_area$1)
                    ?caml_string_notequal(tag,cst_audio$1)?[61,e]:[2,e]
                    :[1,e]
                  :[0,e];
         case 1:
          return caml_string_notequal(tag,cst_base$1)
                  ?caml_string_notequal(tag,cst_blockquote$1)
                    ?caml_string_notequal(tag,cst_body$1)
                      ?caml_string_notequal(tag,cst_br$1)
                        ?caml_string_notequal(tag,cst_button$1)?[61,e]:[7,e]
                        :[6,e]
                      :[5,e]
                    :[4,e]
                  :[3,e];
         case 2:
          return caml_string_notequal(tag,cst_canvas$1)
                  ?caml_string_notequal(tag,cst_caption$1)
                    ?caml_string_notequal(tag,cst_col$1)
                      ?caml_string_notequal(tag,cst_colgroup$1)?[61,e]:[11,e]
                      :[10,e]
                    :[9,e]
                  :[8,e];
         case 3:
          return caml_string_notequal(tag,cst_del$1)
                  ?caml_string_notequal(tag,cst_div$1)
                    ?caml_string_notequal(tag,cst_dl$1)?[61,e]:[14,e]
                    :[13,e]
                  :[12,e];
         case 4:return caml_string_notequal(tag,cst_embed$1)?[61,e]:[15,e];
         case 5:
          return caml_string_notequal(tag,cst_fieldset$1)
                  ?caml_string_notequal(tag,cst_form$1)
                    ?caml_string_notequal(tag,cst_frame$1)
                      ?caml_string_notequal(tag,cst_frameset$1)?[61,e]:[18,e]
                      :[19,e]
                    :[17,e]
                  :[16,e];
         case 7:
          return caml_string_notequal(tag,cst_h1$1)
                  ?caml_string_notequal(tag,cst_h2$1)
                    ?caml_string_notequal(tag,cst_h3$1)
                      ?caml_string_notequal(tag,cst_h4$1)
                        ?caml_string_notequal(tag,cst_h5$1)
                          ?caml_string_notequal(tag,cst_h6$1)
                            ?caml_string_notequal(tag,cst_head$1)
                              ?caml_string_notequal(tag,cst_hr$1)
                                ?caml_string_notequal(tag,cst_html$1)?[61,e]:[28,e]
                                :[27,e]
                              :[26,e]
                            :[25,e]
                          :[24,e]
                        :[23,e]
                      :[22,e]
                    :[21,e]
                  :[20,e];
         case 8:
          return caml_string_notequal(tag,cst_iframe$1)
                  ?caml_string_notequal(tag,cst_img$1)
                    ?caml_string_notequal(tag,cst_input$2)
                      ?caml_string_notequal(tag,cst_ins$1)?[61,e]:[32,e]
                      :[31,e]
                    :[30,e]
                  :[29,e];
         case 11:
          return caml_string_notequal(tag,cst_label$1)
                  ?caml_string_notequal(tag,cst_legend$1)
                    ?caml_string_notequal(tag,cst_li$1)
                      ?caml_string_notequal(tag,cst_link$1)?[61,e]:[36,e]
                      :[35,e]
                    :[34,e]
                  :[33,e];
         case 12:
          return caml_string_notequal(tag,cst_map$1)
                  ?caml_string_notequal(tag,cst_meta$1)?[61,e]:[38,e]
                  :[37,e];
         case 14:
          return caml_string_notequal(tag,cst_object$1)
                  ?caml_string_notequal(tag,cst_ol$1)
                    ?caml_string_notequal(tag,cst_optgroup$1)
                      ?caml_string_notequal(tag,cst_option$1)?[61,e]:[42,e]
                      :[41,e]
                    :[40,e]
                  :[39,e];
         case 15:
          return caml_string_notequal(tag,cst_p$1)
                  ?caml_string_notequal(tag,cst_param$1)
                    ?caml_string_notequal(tag,cst_pre$1)?[61,e]:[45,e]
                    :[44,e]
                  :[43,e];
         case 16:return caml_string_notequal(tag,cst_q$1)?[61,e]:[46,e];
         case 18:
          return caml_string_notequal(tag,cst_script$1)
                  ?caml_string_notequal(tag,cst_select$2)
                    ?caml_string_notequal(tag,cst_style$1)?[61,e]:[49,e]
                    :[48,e]
                  :[47,e];
         case 19:
          return caml_string_notequal(tag,cst_table$1)
                  ?caml_string_notequal(tag,cst_tbody$1)
                    ?caml_string_notequal(tag,cst_td$1)
                      ?caml_string_notequal(tag,cst_textarea$1)
                        ?caml_string_notequal(tag,cst_tfoot$1)
                          ?caml_string_notequal(tag,cst_th$1)
                            ?caml_string_notequal(tag,cst_thead$1)
                              ?caml_string_notequal(tag,cst_title$1)
                                ?caml_string_notequal(tag,cst_tr$1)?[61,e]:[58,e]
                                :[57,e]
                              :[56,e]
                            :[55,e]
                          :[54,e]
                        :[53,e]
                      :[52,e]
                    :[51,e]
                  :[50,e];
         case 20:return caml_string_notequal(tag,cst_ul$1)?[61,e]:[59,e];
         case 21:return caml_string_notequal(tag,cst_video$1)?[61,e]:[60,e]
         }
      return [61,e]}
    function opt_tagged(e)
     {function _ft_(e){return [0,tagged(e)]}
      function _fu_(param){return 0}
      return caml_call3(Opt[7],e,_fu_,_ft_)}
    function taggedEvent(ev)
     {function _fe_(ev){return [0,ev]}
      function _ff_(param)
       {function _fh_(ev){return [1,ev]}
        function _fi_(param)
         {function _fk_(ev){return [2,ev]}
          function _fl_(param)
           {function _fn_(ev){return [3,ev]}
            function _fo_(param)
             {function _fq_(ev){return [4,ev]}
              function _fr_(param){return [5,ev]}
              var _fs_=popStateEvent(ev);
              return caml_call3(Opt[7],_fs_,_fr_,_fq_)}
            var _fp_=mouseScrollEvent(ev);
            return caml_call3(Opt[7],_fp_,_fo_,_fn_)}
          var _fm_=wheelEvent(ev);
          return caml_call3(Opt[7],_fm_,_fl_,_fk_)}
        var _fj_=keyboardEvent(ev);
        return caml_call3(Opt[7],_fj_,_fi_,_fh_)}
      var _fg_=mouseEvent(ev);
      return caml_call3(Opt[7],_fg_,_ff_,_fe_)}
    function opt_taggedEvent(ev)
     {function _fc_(ev){return [0,taggedEvent(ev)]}
      function _fd_(param){return 0}
      return caml_call3(Opt[7],ev,_fd_,_fc_)}
    function stopPropagation(ev)
     {function _fa_(param){return ev.stopPropagation()}
      function _fb_(param){return ev.cancelBubble = t25}
      return caml_call3(Optdef[7],ev.stopPropagation,_fb_,_fa_)}
    var
     requestAnimationFrame=
      runtime.caml_js_pure_expr
       (function(param)
         {var
           l=
            [0,
             _i_.requestAnimationFrame,
             [0,
              _i_.mozRequestAnimationFrame,
              [0,
               _i_.webkitRequestAnimationFrame,
               [0,
                _i_.oRequestAnimationFrame,
                [0,_i_.msRequestAnimationFrame,0]]]]];
          try
           {var
             _e9_=function(c){return caml_call1(Optdef[5],c)},
             req=caml_call2(Stdlib_list[38],_e9_,l),
             _e__=function(callback){return req(callback)};
            return _e__}
          catch(_e$_)
           {_e$_ = caml_wrap_exception(_e$_);
            if(_e$_ === Stdlib[8])
             {var
               now=function(param){var t122=new t121();return t122.getTime()},
               last=[0,now(0)];
              return function(callback)
               {var
                 t=now(0),
                 dt=last[1] + 16.6666666666666679 - t,
                 dt$0=dt < 0.?0.:dt;
                last[1] = t;
                _i_.setTimeout(callback,dt$0);
                return 0}}
            throw _e$_}});
    function hasPushState(param)
     {return caml_call1(Optdef[5],_i_.history.pushState)}
    function hasPlaceholder(param)
     {var i=createInput(0,0,t22);return caml_call1(Optdef[5],i.placeholder)}
    function hasRequired(param)
     {var i=createInput(0,0,t22);return caml_call1(Optdef[5],i.required)}
    var overflow_limit=2147483000.;
    function setTimeout(callback,d)
     {var id=[0,0];
      function loop(step,param)
       {if(2147483000. < step)
         var remain=step - 2147483000.,step$0=overflow_limit;
        else
         var remain=0.,step$0=step;
        var
         cb=remain == 0.?callback:function(_e8_){return loop(remain,_e8_)},
         t130=caml_js_wrap_callback(cb);
        id[1] = [0,_i_.setTimeout(t130,step$0)];
        return 0}
      loop(d,0);
      return id}
    function clearTimeout(id)
     {var _e7_=id[1];
      if(_e7_){var x=_e7_[1];id[1] = 0;return _i_.clearTimeout(x)}
      return 0}
    function js_array_of_collection(c){return [].slice.call(c)}
    var
     Js_of_ocaml_Dom_html=
      [0,
       d,
       t22,
       getElementById_opt,
       getElementById_exn,
       getElementById_coerce,
       getElementById,
       location_origin,
       _i_,
       no_handler,
       handler,
       full_handler,
       invoke_handler,
       eventTarget,
       eventRelatedTarget,
       Event$0,
       addEventListenerWithOptions,
       addEventListener,
       removeEventListener,
       addMousewheelEventListenerWith,
       addMousewheelEventListener,
       createCustomEvent,
       buttonPressed,
       eventAbsolutePosition$0,
       elementClientPosition,
       getDocumentScroll,
       [0,of_event,try_key_code_normal],
       [0,of_event$0],
       createHtml,
       createHead,
       createLink,
       createTitle,
       createMeta,
       createBase,
       createStyle,
       createBody,
       createForm,
       createOptgroup,
       createOption,
       createSelect,
       createInput,
       createTextarea,
       createButton,
       createLabel,
       createFieldset,
       createLegend,
       createUl,
       createOl,
       createDl,
       createLi,
       createDiv,
       createEmbed,
       createP,
       createH1,
       createH2,
       createH3,
       createH4,
       createH5,
       createH6,
       createQ,
       createBlockquote,
       createPre,
       createBr,
       createHr,
       createIns,
       createDel,
       createA,
       createImg,
       createObject,
       createParam,
       createMap,
       createArea,
       createScript,
       createTable,
       createCaption,
       createCol,
       createColgroup,
       createThead,
       createTfoot,
       createTbody,
       createTr,
       createTh,
       createTd,
       createSub,
       createSup,
       createSpan,
       createTt,
       createI,
       createB,
       createBig,
       createSmall,
       createEm,
       createStrong,
       createCite,
       createDfn,
       createCode,
       createSamp,
       createKbd,
       createVar,
       createAbbr,
       createDd,
       createDt,
       createNoscript,
       createAddress,
       createFrameset,
       createFrame,
       createIframe,
       createAudio,
       createVideo,
       Canvas_not_available,
       createCanvas,
       element$1,
       tagged,
       opt_tagged,
       taggedEvent,
       opt_taggedEvent,
       stopPropagation,
       [0,
        element$0,
        a,
        area,
        audio,
        base,
        blockquote,
        body,
        br,
        button,
        canvas,
        caption,
        col,
        colgroup,
        del,
        div,
        embed,
        dl,
        fieldset,
        form,
        frameset,
        frame,
        h1,
        h2,
        h3,
        h4,
        h5,
        h6,
        head,
        hr,
        html,
        iframe,
        img,
        input$0,
        ins,
        label,
        legend,
        li,
        link,
        map$2,
        meta,
        object,
        ol,
        optgroup,
        option$1,
        p,
        param,
        pre,
        q,
        script,
        select$0,
        style,
        table,
        tbody,
        td,
        textarea,
        tfoot,
        th,
        thead,
        title,
        tr,
        ul,
        video,
        mouseEvent,
        keyboardEvent,
        wheelEvent,
        mouseScrollEvent,
        popStateEvent],
       setTimeout,
       clearTimeout,
       js_array_of_collection,
       requestAnimationFrame,
       runtime.caml_js_html_entities,
       onIE,
       hasPushState,
       hasPlaceholder,
       hasRequired];
    caml_register_global(1648,Js_of_ocaml_Dom_html,"Js_of_ocaml__Dom_html");
    var formData=Unsafe[1].FormData,formData_form=Unsafe[1].FormData;
    function filter_map$0(f,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var q=param$0[2],v=param$0[1],match=caml_call1(f,v);
          if(match){var v$0=match[1];return [0,v$0,filter_map$0(f,q)]}
          var param$0=q;
          continue}
        return 0}}
    function have_content(elt)
     {var
       _e5_=caml_call2(symbol$9,elt.name.length,0),
       _e6_=_e5_?1 - (elt.disabled | 0):_e5_;
      return _e6_}
    function form_elements(get,form)
     {var length=form.elements.length;
      function _eT_(i)
       {var t34=form.elements,_e4_=t34.item(i);
        return caml_call1(Opt[10],_e4_)}
      var
       _eU_=caml_call2(Stdlib_array[2],length,_eT_),
       elements=caml_call1(Stdlib_array[11],_eU_);
      function _eV_(param)
       {if(param)
         {var v=param[1],match$3=tagged(v);
          switch(match$3[0])
           {case 31:
             var v$0=match$3[1];
             if(get)var sth=get[1],get$0=sth;else var get$0=0;
             if(have_content(v$0))
              {var
                name$1=caml_string_of_jsstring(v$0.name),
                value=v$0.value,
                t20=v$0.type,
                match=caml_string_of_jsbytes(t20.toLowerCase());
               if(caml_string_notequal(match,cst_checkbox))
                {if(! caml_string_notequal(match,cst_file))
                  {if(get$0)return [0,[0,name$1,[0,-976970511,value]],0];
                   var match$0=caml_call1(Optdef[10],v$0.files);
                   if(match$0)
                    {var list=match$0[1];
                     if(caml_call2(symbol$8,list.length,0))
                      return [0,[0,name$1,[0,-976970511,""]],0];
                     var match$1=caml_call1(Optdef[10],v$0.multiple);
                     if(match$1 && match$1[1])
                      {var
                        _eZ_=function(t28){return list.item(t28)},
                        _e0_=caml_call2(Stdlib_array[2],list.length,_eZ_),
                        _e1_=caml_call1(Stdlib_array[11],_e0_);
                       return filter_map$0
                               (function(f)
                                 {var match=caml_call1(Opt[10],f);
                                  if(match)
                                   {var file=match[1];return [0,[0,name$1,[0,781515420,file]]]}
                                  return 0},
                                _e1_)}
                     var _e2_=list.item(0),match$2=caml_call1(Opt[10],_e2_);
                     if(match$2)
                      {var file=match$2[1];
                       return [0,[0,name$1,[0,781515420,file]],0]}
                     return 0}
                   return 0}
                 var switch$0=0;
                 if(caml_string_notequal(match,cst_password))
                  {if(caml_string_notequal(match,cst_radio))
                    {var switch$1=0;
                     if
                      (caml_string_notequal(match,cst_reset)
                       &&
                       caml_string_notequal(match,cst_submit$0))
                      {if(caml_string_notequal(match,cst_text))
                        return [0,[0,name$1,[0,-976970511,value]],0];
                       switch$0 = 1;
                       switch$1 = 1}
                     if(! switch$1)return 0}}
                 else
                  switch$0 = 1;
                 if(switch$0)return [0,[0,name$1,[0,-976970511,value]],0]}
               return v$0.checked | 0?[0,[0,name$1,[0,-976970511,value]],0]:0}
             return 0;
            case 48:
             var v$1=match$3[1];
             if(have_content(v$1))
              {var name$0=caml_string_of_jsstring(v$1.name);
               if(v$1.multiple | 0)
                {var
                  _eX_=
                   function(i)
                    {var t13=v$1.options,_e3_=t13.item(i);
                     return caml_call1(Opt[10],_e3_)},
                  options=caml_call2(Stdlib_array[2],v$1.options.length,_eX_),
                  _eY_=caml_call1(Stdlib_array[11],options);
                 return filter_map$0
                         (function(param)
                           {if(param)
                             {var e=param[1];
                              return e.selected | 0
                                      ?[0,[0,name$0,[0,-976970511,e.value]]]
                                      :0}
                            return 0},
                          _eY_)}
               return [0,[0,name$0,[0,-976970511,v$1.value]],0]}
             return 0;
            case 53:
             var v$2=match$3[1];
             if(have_content(v$2))
              {var name=caml_string_of_jsstring(v$2.name);
               return [0,[0,name,[0,-976970511,v$2.value]],0]}
             return 0;
            default:return 0}}
        return 0}
      var
       _eW_=caml_call2(Stdlib_list[19],_eV_,elements),
       contents=caml_call1(Stdlib_list[14],_eW_);
      return contents}
    function append(form_contents,form_elt)
     {if(891486873 <= form_contents[1])
       {var list=form_contents[2];list[1] = [0,form_elt,list[1]];return 0}
      var f=form_contents[2],_eR_=form_elt[2],_eS_=form_elt[1];
      if(781515420 <= _eR_[1])
       {var file=_eR_[2],t38=caml_jsstring_of_string(_eS_);
        return f.append(t38,file)}
      var s=_eR_[2],t35=caml_jsstring_of_string(_eS_);
      return f.append(t35,s)}
    function empty_form_contents(param)
     {var match=caml_call1(Optdef[10],formData);
      if(match){var constr=match[1];return [0,808620462,new constr()]}
      return [0,891486873,[0,0]]}
    function post_form_contents(form)
     {var contents=empty_form_contents(0),_eO_=form_elements(0,form);
      function _eP_(_eQ_){return append(contents,_eQ_)}
      caml_call2(Stdlib_list[17],_eP_,_eO_);
      return contents}
    function get_form_contents(form)
     {var _eL_=form_elements(_m_,form);
      function _eM_(param)
       {var _eN_=param[2];
        if(typeof _eN_ !== "number" && -976970511 === _eN_[1])
         {var s=_eN_[2],name=param[1];
          return [0,name,caml_string_of_jsstring(s)]}
        throw [0,Assert_failure,_n_]}
      return caml_call2(Stdlib_list[19],_eM_,_eL_)}
    var
     Js_of_ocaml_Form=
      [0,
       formData,
       formData_form,
       append,
       post_form_contents,
       get_form_contents,
       empty_form_contents,
       form_elements];
    caml_register_global(1649,Js_of_ocaml_Form,"Js_of_ocaml__Form");
    var
     readystatechange=caml_call1(Event[1],cst_readystatechange),
     loadstart$1=caml_call1(Event[1],cst_loadstart$1),
     progress$1=caml_call1(Event[1],cst_progress$1),
     abort$1=caml_call1(Event[1],cst_abort$1),
     error$1=caml_call1(Event[1],cst_error$1),
     load$1=caml_call1(Event[1],cst_load$1),
     timeout=caml_call1(Event[1],cst_timeout),
     loadend$0=caml_call1(Event[1],cst_loadend$0),
     Event$1=
      [0,
       readystatechange,
       loadstart$1,
       progress$1,
       abort$1,
       error$1,
       load$1,
       timeout,
       loadend$0],
     Js_of_ocaml_XmlHttpRequest=[0,runtime.caml_xmlhttprequest_create,Event$1];
    caml_register_global
     (1650,Js_of_ocaml_XmlHttpRequest,"Js_of_ocaml__XmlHttpRequest");
    var t2=Unsafe[1].Worker;
    function create(script)
     {var t1=caml_jsstring_of_string(script);return new t2(t1)}
    function import_scripts(scripts)
     {if(Unsafe[1].importScripts === t39)
       caml_call1(Stdlib[1],cst_Worker_import_scripts_is_u);
      var _eI_=caml_call1(Stdlib_array[12],scripts);
      function _eJ_(s){return caml_jsstring_of_string(s)}
      var _eK_=caml_call2(Stdlib_array[15],_eJ_,_eI_);
      return runtime.caml_js_fun_call(Unsafe[1].importScripts,_eK_)}
    function set_onmessage(handler)
     {if(Unsafe[1].onmessage === t39)
       caml_call1(Stdlib[1],cst_Worker_onmessage_is_undefi);
      function js_handler(ev){return caml_call1(handler,ev.data)}
      return Unsafe[1].onmessage = caml_js_wrap_callback(js_handler)}
    function post_message(t10)
     {if(Unsafe[1].postMessage === t39)
       caml_call1(Stdlib[1],cst_Worker_onmessage_is_undefi$0);
      return Unsafe[1].postMessage(t10)}
    var
     Js_of_ocaml_Worker=
      [0,create,import_scripts,set_onmessage,post_message];
    caml_register_global(1651,Js_of_ocaml_Worker,"Js_of_ocaml__Worker");
    var webSocket=Unsafe[1].WebSocket;
    function is_supported(param){return caml_call1(Optdef[5],webSocket)}
    var Js_of_ocaml_WebSockets=[0,webSocket,webSocket,webSocket,is_supported];
    caml_register_global
     (1652,Js_of_ocaml_WebSockets,"Js_of_ocaml__WebSockets");
    var
     defaultContextAttributes=
      {"alpha":t25,
       "depth":t25,
       "stencil":t4,
       "antialias":t25,
       "premultipliedAlpha":t4,
       "preserveDrawingBuffer":t4,
       "preferLowPowerToHighPerformance":t4,
       "failIfMajorPerformanceCaveat":t4},
     webglcontextlost=caml_call1(Event$0[86],cst_webglcontextlost),
     webglcontextrestored=caml_call1(Event$0[86],cst_webglcontextrestored),
     webglcontextcreationerror=
      caml_call1(Event$0[86],cst_webglcontextcreationerror),
     Event$2=
      [0,webglcontextlost,webglcontextrestored,webglcontextcreationerror];
    function getContext(t3)
     {var ctx=t3.getContext("webgl");
      return caml_call1(Opt[5],ctx)?ctx:t3.getContext("experimental-webgl")}
    function getContextWithAttributes(t9,t8)
     {var ctx=t9.getContext("webgl",t8);
      return caml_call1(Opt[5],ctx)?ctx:t9.getContext("experimental-webgl",t8)}
    var
     Js_of_ocaml_WebGL=
      [0,defaultContextAttributes,Event$2,getContext,getContextWithAttributes];
    caml_register_global(1653,Js_of_ocaml_WebGL,"Js_of_ocaml__WebGL");
    function regexp(s)
     {var t0=caml_jsbytes_of_string(s);return new t11(t0,"g")}
    function regexp_case_fold(s)
     {var t3=caml_jsbytes_of_string(s);return new t11(t3,"gi")}
    function regexp_with_flag(s,f)
     {var
       t7=caml_jsstring_of_string(caml_call2(Stdlib[28],cst_g,f)),
       t6=caml_jsbytes_of_string(s);
      return new t11(t6,t7)}
    function blunt_str_array_get(a,i)
     {function _eH_(param){throw [0,Assert_failure,_o_]}
      return caml_string_of_jsbytes(caml_call2(Optdef[8],a[i],_eH_))}
    function string_match(r,s,i)
     {r.lastIndex = i;
      var
       t11=caml_jsbytes_of_string(s),
       _eF_=r.exec(t11),
       _eG_=caml_call2(Opt[3],_eF_,match_result);
      return caml_call1(Opt[10],_eG_)}
    function search_forward(r,s,i)
     {r.lastIndex = i;
      var t15=caml_jsbytes_of_string(s);
      function _eC_(res){return [0,res.index,res]}
      var _eD_=r.exec(t15),_eE_=caml_call2(Opt[3],_eD_,_eC_);
      return caml_call1(Opt[10],_eE_)}
    function matched_string(r){return blunt_str_array_get(r,0)}
    function matched_group(r,i)
     {var _eB_=caml_call2(Optdef[3],r[i],caml_string_of_jsbytes);
      return caml_call1(Optdef[10],_eB_)}
    var t21=new t11("[$]","g");
    function quote_repl(s)
     {var t23=caml_jsbytes_of_string(s);return t23.replace(t21,"$$$$")}
    function global_replace(r,s,s_by)
     {r.lastIndex = 0;
      var t27=quote_repl(s_by),t28=caml_jsbytes_of_string(s);
      return caml_string_of_jsbytes(t28.replace(r,t27))}
    function replace_first(r,s,s_by)
     {var
       match=r.ignoreCase | 0,
       match$0=r.multiline | 0,
       flags=match?match$0?"mi":"i":match$0?"m":"",
       t32=r.source,
       t35=new t11(t32,flags),
       t36=quote_repl(s_by),
       t37=caml_jsbytes_of_string(s);
      return caml_string_of_jsbytes(t37.replace(t35,t36))}
    function list_of_js_array(a)
     {var idx$1=a.length - 1 | 0,accu=0,idx=idx$1;
      for(;;)
       {if(caml_call2(symbol$5,idx,0))return accu;
        var
         idx$0=idx - 1 | 0,
         accu$0=[0,blunt_str_array_get(a,idx),accu],
         accu=accu$0,
         idx=idx$0;
        continue}}
    function split(r,s)
     {r.lastIndex = 0;
      var t42=caml_jsbytes_of_string(s);
      return list_of_js_array(t42.split(r))}
    function bounded_split(r,s,i)
     {r.lastIndex = 0;
      var t47=caml_jsbytes_of_string(s);
      return list_of_js_array(t47.split(r,i))}
    var t48=regexp(cst);
    function quote(s)
     {var t50=caml_jsbytes_of_string(s);
      return caml_string_of_jsbytes(t50.replace(t48,"\\$&"))}
    function regexp_string(s){return regexp(quote(s))}
    function regexp_string_case_fold(s){return regexp_case_fold(quote(s))}
    var
     Js_of_ocaml_Regexp=
      [0,
       regexp,
       regexp_case_fold,
       regexp_with_flag,
       quote,
       regexp_string,
       regexp_string_case_fold,
       string_match,
       search_forward,
       search_forward,
       matched_string,
       matched_group,
       global_replace,
       replace_first,
       split,
       bounded_split];
    caml_register_global(1654,Js_of_ocaml_Regexp,"Js_of_ocaml__Regexp");
    var Local_exn=[248,cst_Js_of_ocaml_Url_Local_exn,caml_fresh_oo_id(0)];
    function interrupt(param){throw Local_exn}
    var plus_re=regexp_string(cst$0),t14=new t11("\\+","g");
    function urldecode_js_string_string(s)
     {t14.lastIndex = 0;
      return caml_string_of_jsbytes(unescape(s.replace(t14," ")))}
    function urldecode(s)
     {return caml_string_of_jsbytes
              (unescape
                (caml_jsbytes_of_string(global_replace(plus_re,s,cst$1))))}
    function urlencode(opt,s)
     {if(opt)var sth=opt[1],with_plus=sth;else var with_plus=1;
      if(with_plus)
       {var s$0=caml_string_of_jsbytes(escape(caml_jsbytes_of_string(s)));
        return global_replace(plus_re,s$0,cst_2B)}
      return caml_string_of_jsbytes(escape(caml_jsbytes_of_string(s)))}
    var
     Not_an_http_protocol=
      [248,cst_Js_of_ocaml_Url_Not_an_htt,caml_fresh_oo_id(0)],
     default_http_port=80,
     default_https_port=443;
    function path_of_path_string(s)
     {var l=caml_ml_string_length(s);
      function aux(i)
       {try
         {var _ez_=caml_call3(String[20],s,i,47),j=_ez_}
        catch(_eA_)
         {_eA_ = caml_wrap_exception(_eA_);
          if(_eA_ !== Stdlib[8])throw _eA_;
          var j=l}
        var word=caml_call3(String[8],s,i,j - i | 0);
        return caml_call2(symbol$10,j,l)?[0,word,0]:[0,word,aux(j + 1 | 0)]}
      var a=aux(0);
      if(a && ! caml_string_notequal(a[1],cst$2))
       {var _ey_=a[2];
        if(! _ey_)return 0;
        if(! caml_string_notequal(_ey_[1],cst$3) && ! _ey_[2])return _p_}
      return a}
    function encode_arguments(l)
     {function _et_(param)
       {var
         v=param[2],
         n=param[1],
         _ev_=urlencode(0,v),
         _ew_=caml_call2(Stdlib[28],cst$4,_ev_),
         _ex_=urlencode(0,n);
        return caml_call2(Stdlib[28],_ex_,_ew_)}
      var _eu_=caml_call2(Stdlib_list[19],_et_,l);
      return caml_call2(String[3],cst$5,_eu_)}
    function decode_arguments_js_string(s)
     {var
       t0=caml_jsstring_of_string(caml_call2(String[1],1,38)),
       arr=s.split(t0),
       len=arr.length;
      function aux(acc,idx)
       {var idx$0=idx;
        for(;;)
         {if(caml_call2(symbol$5,idx$0,0))return acc;
          try
           {var
             _el_=idx$0 - 1 | 0,
             _em_=
              function(s)
               {function _er_(param)
                 {var
                   y=param[2],
                   x=param[1],
                   _es_=urldecode_js_string_string(y);
                  return [0,urldecode_js_string_string(x),_es_]}
                var
                 t2=caml_jsstring_of_string(caml_call2(String[1],1,61)),
                 t5=s.indexOf(t2);
                if(caml_call2(symbol$5,t5,0))
                 var _eq_=t39;
                else
                 var
                  t7=t5 + 1 | 0,
                  _ep_=s.slice(t7),
                  _eq_=[0,s.slice(0,t5),_ep_];
                return caml_call3(Optdef[7],_eq_,interrupt,_er_)},
             _en_=
              aux
               ([0,caml_call3(Optdef[7],arr[idx$0],interrupt,_em_),acc],_el_);
            return _en_}
          catch(_eo_)
           {_eo_ = caml_wrap_exception(_eo_);
            if(_eo_ === Local_exn)
             {var idx$1=idx$0 - 1 | 0,idx$0=idx$1;continue}
            throw _eo_}}}
      return aux(0,len - 1 | 0)}
    function decode_arguments(s)
     {return decode_arguments_js_string(caml_jsbytes_of_string(s))}
    var
     t19=caml_jsbytes_of_string(cst_Hh_Tt_Tt_Pp_Ss_0_9a_zA_Z_0),
     t24=new t11(t19),
     t21$0=caml_jsbytes_of_string(cst_Ff_Ii_Ll_Ee),
     t26=new t11(t21$0);
    function url_of_js_string(s)
     {function _d4_(res)
       {var
         prot_string=caml_call2(Optdef[8],res[1],interrupt),
         match=caml_string_of_jsbytes(prot_string.toLowerCase());
        if
         (caml_string_notequal(match,cst_file$0)
          &&
          caml_string_notequal(match,cst_file$1))
         {var switch$0=0;
          if
           (caml_string_notequal(match,cst_http)
            &&
            caml_string_notequal(match,cst_http$0))
           {var switch$1=0;
            if
             (caml_string_notequal(match,cst_https)
              &&
              caml_string_notequal(match,cst_https$0))
             switch$1 = 1;
            if(! switch$1){var ssl=1;switch$0 = 2}}
          else
           switch$0 = 1;
          var switch$2=0;
          switch(switch$0)
           {case 1:var ssl=0;switch$2 = 1;break;
            case 0:break;
            default:switch$2 = 1}
          if(switch$2)
           {var
             _ec_=function(param){return caml_jsbytes_of_string(cst$7)},
             path_str=
              urldecode_js_string_string(caml_call2(Optdef[8],res[6],_ec_)),
             _ed_=function(param){return caml_jsbytes_of_string(cst$8)},
             _ee_=
              urldecode_js_string_string(caml_call2(Optdef[8],res[10],_ed_)),
             _ef_=function(param){return caml_jsbytes_of_string(cst$9)},
             _eg_=
              decode_arguments_js_string(caml_call2(Optdef[8],res[8],_ef_)),
             _eh_=path_of_path_string(path_str),
             _ei_=function(param){return caml_jsbytes_of_string(cst$10)},
             s=caml_string_of_jsbytes(caml_call2(Optdef[8],res[4],_ei_)),
             _ej_=
              caml_string_notequal(s,cst$6)?caml_int_of_string(s):ssl?443:80,
             url=
              [0,
               urldecode_js_string_string
                (caml_call2(Optdef[8],res[2],interrupt)),
               _ej_,
               _eh_,
               path_str,
               _eg_,
               _ee_],
             _ek_=ssl?[1,url]:[0,url];
            return [0,_ek_]}}
        throw Not_an_http_protocol}
      function _d5_(param)
       {function _d7_(res)
         {var
           path_str=
            urldecode_js_string_string(caml_call2(Optdef[8],res[2],interrupt));
          function _d__(param){return caml_jsbytes_of_string(cst$11)}
          var _d$_=caml_string_of_jsbytes(caml_call2(Optdef[8],res[6],_d__));
          function _ea_(param){return caml_jsbytes_of_string(cst$12)}
          var
           _eb_=
            decode_arguments_js_string(caml_call2(Optdef[8],res[4],_ea_));
          return [0,[2,[0,path_of_path_string(path_str),path_str,_eb_,_d$_]]]}
        function _d8_(param){return 0}
        var _d9_=t26.exec(s);
        return caml_call3(Opt[7],_d9_,_d8_,_d7_)}
      var _d6_=t24.exec(s);
      return caml_call3(Opt[7],_d6_,_d5_,_d4_)}
    function url_of_string(s)
     {return url_of_js_string(caml_jsbytes_of_string(s))}
    function string_of_url(param)
     {switch(param[0])
       {case 0:
         var
          match=param[1],
          frag=match[6],
          args=match[5],
          path=match[3],
          port=match[2],
          host=match[1];
         if(caml_string_notequal(frag,cst$13))
          var _dr_=urlencode(0,frag),_ds_=caml_call2(Stdlib[28],cst$14,_dr_);
         else
          var _ds_=cst$21;
         if(args)
          var
           _dt_=encode_arguments(args),
           _du_=caml_call2(Stdlib[28],cst$15,_dt_);
         else
          var _du_=cst$20;
         var
          _dv_=caml_call2(Stdlib[28],_du_,_ds_),
          _dw_=function(x){return urlencode(0,x)},
          _dx_=caml_call2(Stdlib_list[19],_dw_,path),
          _dy_=caml_call2(String[3],cst$16,_dx_),
          _dz_=caml_call2(Stdlib[28],_dy_,_dv_),
          _dA_=caml_call2(Stdlib[28],cst$17,_dz_);
         if(80 === port)
          var _dB_=cst$18;
         else
          var
           _dF_=caml_call1(Stdlib[33],port),
           _dB_=caml_call2(Stdlib[28],cst$19,_dF_);
         var
          _dC_=caml_call2(Stdlib[28],_dB_,_dA_),
          _dD_=urlencode(0,host),
          _dE_=caml_call2(Stdlib[28],_dD_,_dC_);
         return caml_call2(Stdlib[28],cst_http$1,_dE_);
        case 1:
         var
          match$0=param[1],
          frag$0=match$0[6],
          args$0=match$0[5],
          path$0=match$0[3],
          port$0=match$0[2],
          host$0=match$0[1];
         if(caml_string_notequal(frag$0,cst$22))
          var
           _dG_=urlencode(0,frag$0),
           _dH_=caml_call2(Stdlib[28],cst$23,_dG_);
         else
          var _dH_=cst$30;
         if(args$0)
          var
           _dI_=encode_arguments(args$0),
           _dJ_=caml_call2(Stdlib[28],cst$24,_dI_);
         else
          var _dJ_=cst$29;
         var
          _dK_=caml_call2(Stdlib[28],_dJ_,_dH_),
          _dL_=function(x){return urlencode(0,x)},
          _dM_=caml_call2(Stdlib_list[19],_dL_,path$0),
          _dN_=caml_call2(String[3],cst$25,_dM_),
          _dO_=caml_call2(Stdlib[28],_dN_,_dK_),
          _dP_=caml_call2(Stdlib[28],cst$26,_dO_);
         if(443 === port$0)
          var _dQ_=cst$27;
         else
          var
           _dU_=caml_call1(Stdlib[33],port$0),
           _dQ_=caml_call2(Stdlib[28],cst$28,_dU_);
         var
          _dR_=caml_call2(Stdlib[28],_dQ_,_dP_),
          _dS_=urlencode(0,host$0),
          _dT_=caml_call2(Stdlib[28],_dS_,_dR_);
         return caml_call2(Stdlib[28],cst_https$1,_dT_);
        default:
         var
          match$1=param[1],
          frag$1=match$1[4],
          args$1=match$1[3],
          path$1=match$1[1];
         if(caml_string_notequal(frag$1,cst$31))
          var
           _dV_=urlencode(0,frag$1),
           _dW_=caml_call2(Stdlib[28],cst$32,_dV_);
         else
          var _dW_=cst$36;
         if(args$1)
          var
           _dX_=encode_arguments(args$1),
           _dY_=caml_call2(Stdlib[28],cst$33,_dX_);
         else
          var _dY_=cst$35;
         var
          _dZ_=caml_call2(Stdlib[28],_dY_,_dW_),
          _d0_=function(x){return urlencode(0,x)},
          _d1_=caml_call2(Stdlib_list[19],_d0_,path$1),
          _d2_=caml_call2(String[3],cst$34,_d1_),
          _d3_=caml_call2(Stdlib[28],_d2_,_dZ_);
         return caml_call2(Stdlib[28],cst_file$2,_d3_)}}
    var _q_=caml_call1(Optdef[2],_i_.location);
    if(caml_call1(Optdef[5],_q_))
     var _r_=_i_.location;
    else
     var
      t42=function(param,_dq_){return 0},
      t41=function(param,_dp_){return 0},
      t40=function(param){return 0},
      _r_=
       {"href":"",
        "protocol":"",
        "host":"",
        "hostname":"",
        "port":"",
        "pathname":"",
        "search":"",
        "hash":"",
        "origin":t39,
        "reload":caml_js_wrap_meth_callback(t40),
        "replace":caml_js_wrap_meth_callback(t41),
        "assign":caml_js_wrap_meth_callback(t42)};
    var
     host=urldecode_js_string_string(_r_.hostname),
     protocol=urldecode_js_string_string(_r_.protocol),
     _s_=0,
     port=
      function(param)
        {try
          {var _dn_=[0,caml_int_of_string(caml_string_of_jsbytes(_r_.port))];
           return _dn_}
         catch(_do_)
          {_do_ = caml_wrap_exception(_do_);
           if(_do_[1] === Stdlib[7])return 0;
           throw _do_}}
       (_s_),
     path_string=urldecode_js_string_string(_r_.pathname),
     path=path_of_path_string(path_string),
     t49=_r_.search;
    if(t49.charAt(0) === "?")
     var t52=_r_.search,_t_=t52.slice(1);
    else
     var _t_=_r_.search;
    var arguments$0=decode_arguments_js_string(_t_);
    function get_fragment(param)
     {function _dk_(res){return caml_string_of_jsstring(res[1])}
      function _dl_(param){return cst$37}
      var t57=new t11("#(.*)"),t58=_r_.href,_dm_=t58.match(t57);
      return caml_call3(Opt[7],_dm_,_dl_,_dk_)}
    function set_fragment(s)
     {return _r_.hash = caml_jsbytes_of_string(urlencode(0,s))}
    function get$2(param){return url_of_js_string(_r_.href)}
    function set$0(u)
     {return _r_.href = caml_jsbytes_of_string(string_of_url(u))}
    var
     as_string=urldecode_js_string_string(_r_.href),
     Js_of_ocaml_Url=
      [0,
       urldecode,
       urlencode,
       default_http_port,
       default_https_port,
       path_of_path_string,
       encode_arguments,
       decode_arguments,
       url_of_string,
       string_of_url,
       [0,
        host,
        port,
        protocol,
        path_string,
        path,
        arguments$0,
        get_fragment,
        set_fragment,
        get$2,
        set$0,
        as_string]];
    caml_register_global(1656,Js_of_ocaml_Url,"Js_of_ocaml__Url");
    var Js_of_ocaml_Lib_version=[0,s,git_version];
    caml_register_global
     (1657,Js_of_ocaml_Lib_version,"Js_of_ocaml__Lib_version");
    function update_file(name,content)
     {var oc=caml_call1(Stdlib[60],name);
      caml_call2(Stdlib[66],oc,content);
      return caml_call1(Stdlib[76],oc)}
    function set_channel_flusher(out_channel,f)
     {var
       f$0=
        caml_js_wrap_callback
         (function(s){return caml_call1(f,caml_string_of_jsbytes(s))});
      return runtime.caml_ml_set_channel_output(out_channel,f$0)}
    function set_channel_filler(in_channel,f)
     {var f$0=caml_js_wrap_callback(f);
      return runtime.caml_ml_set_channel_refill(in_channel,f$0)}
    function mount(path,f)
     {return runtime.caml_mount_autoload
              (path,
               caml_js_wrap_callback
                (function(prefix,path){return caml_call2(f,prefix,path)}))}
    function unmount(path){return runtime.caml_unmount(path)}
    if(caml_call2(String[38],git_version,cst$38))
     var js_of_ocaml_version=s;
    else
     var
      _cn_=caml_call2(Stdlib[28],cst$41,git_version),
      js_of_ocaml_version=caml_call2(Stdlib[28],s,_cn_);
    var
     _u_=runtime.caml_create_file,
     _v_=runtime.caml_read_file_content,
     Js_of_ocaml_Sys_js=
      [0,
       set_channel_flusher,
       set_channel_filler,
       function(_dj_){return runtime.caml_list_mount_point(_dj_)},
       unmount,
       mount,
       _v_,
       _u_,
       update_file,
       js_of_ocaml_version];
    caml_register_global(1658,Js_of_ocaml_Sys_js,"Js_of_ocaml__Sys_js");
    function empty_resize_observer_options(param){return {}}
    var t2$0=Unsafe[1].ResizeObserver;
    function is_supported$0(param){return caml_call1(Optdef[5],t2$0)}
    function observe(node,f,box,param)
     {var t1=caml_js_wrap_callback(f),t4=new t2$0(t1);
      if(box)
       {var box$0=box[1],t8={};t8.box = box$0;t4.observe(node,t8)}
      else
       t4.observe(node);
      return t4}
    var
     Js_of_ocaml_ResizeObserver=
      [0,empty_resize_observer_options,t2$0,is_supported$0,observe];
    caml_register_global
     (1659,Js_of_ocaml_ResizeObserver,"Js_of_ocaml__ResizeObserver");
    function empty_mutation_observer_init(param){return {}}
    var t2$1=Unsafe[1].MutationObserver;
    function is_supported$1(param){return caml_call1(Optdef[5],t2$1)}
    function observe$0
     (node,
      f,
      child_list,
      attributes,
      character_data,
      subtree,
      attribute_old_value,
      character_data_old_value,
      attribute_filter,
      param)
     {function opt_iter(x,f)
       {if(x){var x$0=x[1];return caml_call1(f,x$0)}return 0}
      var t1=caml_js_wrap_callback(f),t19=new t2$1(t1),t18={};
      opt_iter(child_list,function(v){return t18.childList = v});
      opt_iter(attributes,function(v){return t18.attributes = v});
      opt_iter(character_data,function(v){return t18.characterData = v});
      opt_iter(subtree,function(v){return t18.subtree = v});
      opt_iter
       (attribute_old_value,function(v){return t18.attributeOldValue = v});
      opt_iter
       (character_data_old_value,
        function(v){return t18.characterDataOldValue = v});
      opt_iter
       (attribute_filter,
        function(l)
         {return t18.attributeFilter
                 =
                 caml_js_from_array(caml_call1(Stdlib_array[12],l))});
      t19.observe(node,t18);
      return t19}
    var
     Js_of_ocaml_MutationObserver=
      [0,empty_mutation_observer_init,t2$1,is_supported$1,observe$0];
    caml_register_global
     (1660,Js_of_ocaml_MutationObserver,"Js_of_ocaml__MutationObserver");
    var t1=Unsafe[1].Object;
    function create$0(param){return new t1()}
    function add$0(t,k,v){return t[k.concat("_")] = v}
    function remove(t,k){return delete t[k.concat("_")]}
    function find(t,k){return t[k.concat("_")]}
    function keys(t)
     {var
       t10=Unsafe[1].Object,
       key_array=t10.keys(t),
       res=[0,0],
       _df_=key_array.length - 1 | 0,
       _de_=0;
      if(! (_df_ < 0))
       {var i=_de_;
        for(;;)
         {var
           _dg_=function(param){return caml_call1(Stdlib[2],cst_Jstable_keys)},
           t15=caml_call2(Optdef[8],key_array[i],_dg_),
           t14=t15.length - 1 | 0,
           _dh_=res[1];
          res[1] = [0,t15.substring(0,t14),_dh_];
          var _di_=i + 1 | 0;
          if(_df_ !== i){var i=_di_;continue}
          break}}
      return caml_call1(Stdlib_list[9],res[1])}
    var Js_of_ocaml_Jstable=[0,create$0,add$0,remove,find,keys];
    caml_register_global(1661,Js_of_ocaml_Jstable,"Js_of_ocaml__Jstable");
    var t12=Unsafe[1].JSON;
    function reviver(this$0,key,value)
     {if(typeof value == typeof "foo")return caml_string_of_jsbytes(value);
      if
       (value instanceof array_length
        &&
        4
        ===
        value.length
        &&
        255
        ===
        value[0])
       return runtime.caml_int64_create_lo_mi_hi(value[1],value[2],value[3]);
      return value}
    var t3$0=caml_js_wrap_meth_callback(reviver);
    function unsafe_input(t2){return t12.parse(t2,t3$0)}
    var
     mlString_constr=dummy_string.constructor,
     mlInt64_constr=dummy_int64.constructor;
    function t11$1(key,value)
     {return value instanceof mlString_constr
              ?caml_jsbytes_of_string(value)
              :value instanceof mlInt64_constr
                ?caml_js_from_array([0,255,value.lo,value.mi,value.hi])
                :value}
    function output(t10){return t12.stringify(t10,t11$1)}
    var Js_of_ocaml_Json=[0,output,unsafe_input];
    caml_register_global(1662,Js_of_ocaml_Json,"Js_of_ocaml__Json");
    function string_of_name(param)
     {var _dd_=param;
      if(74 <= _dd_)
       {if(111 <= _dd_)
         switch(_dd_)
          {case 111:return cst_palevioletred;
           case 112:return cst_papayawhip;
           case 113:return cst_peachpuff;
           case 114:return cst_peru;
           case 115:return cst_pink;
           case 116:return cst_plum;
           case 117:return cst_powderblue;
           case 118:return cst_purple;
           case 119:return cst_red;
           case 120:return cst_rosybrown;
           case 121:return cst_royalblue;
           case 122:return cst_saddlebrown;
           case 123:return cst_salmon;
           case 124:return cst_sandybrown;
           case 125:return cst_seagreen;
           case 126:return cst_seashell;
           case 127:return cst_sienna;
           case 128:return cst_silver;
           case 129:return cst_skyblue;
           case 130:return cst_slateblue;
           case 131:return cst_slategray;
           case 132:return cst_slategrey;
           case 133:return cst_snow;
           case 134:return cst_springgreen;
           case 135:return cst_steelblue;
           case 136:return cst_tan;
           case 137:return cst_teal;
           case 138:return cst_thistle;
           case 139:return cst_tomato;
           case 140:return cst_turquoise;
           case 141:return cst_violet;
           case 142:return cst_wheat;
           case 143:return cst_white;
           case 144:return cst_whitesmoke;
           case 145:return cst_yellow;
           default:return cst_yellowgreen}
        switch(_dd_)
         {case 74:return cst_lightpink;
          case 75:return cst_lightsalmon;
          case 76:return cst_lightseagreen;
          case 77:return cst_lightskyblue;
          case 78:return cst_lightslategray;
          case 79:return cst_lightslategrey;
          case 80:return cst_lightsteelblue;
          case 81:return cst_lightyellow;
          case 82:return cst_lime;
          case 83:return cst_limegreen;
          case 84:return cst_linen;
          case 85:return cst_magenta;
          case 86:return cst_maroon;
          case 87:return cst_mediumaquamarine;
          case 88:return cst_mediumblue;
          case 89:return cst_mediumorchid;
          case 90:return cst_mediumpurple;
          case 91:return cst_mediumseagreen;
          case 92:return cst_mediumslateblue;
          case 93:return cst_mediumspringgreen;
          case 94:return cst_mediumturquoise;
          case 95:return cst_mediumvioletred;
          case 96:return cst_midnightblue;
          case 97:return cst_mintcream;
          case 98:return cst_mistyrose;
          case 99:return cst_moccasin;
          case 100:return cst_navajowhite;
          case 101:return cst_navy;
          case 102:return cst_oldlace;
          case 103:return cst_olive;
          case 104:return cst_olivedrab;
          case 105:return cst_orange;
          case 106:return cst_orangered;
          case 107:return cst_orchid;
          case 108:return cst_palegoldenrod;
          case 109:return cst_palegreen;
          default:return cst_paleturquoise}}
      if(37 <= _dd_)
       switch(_dd_)
        {case 37:return cst_darkslategrey;
         case 38:return cst_darkturquoise;
         case 39:return cst_darkviolet;
         case 40:return cst_deeppink;
         case 41:return cst_deepskyblue;
         case 42:return cst_dimgray;
         case 43:return cst_dimgrey;
         case 44:return cst_dodgerblue;
         case 45:return cst_firebrick;
         case 46:return cst_floralwhite;
         case 47:return cst_forestgreen;
         case 48:return cst_fuchsia;
         case 49:return cst_gainsboro;
         case 50:return cst_ghostwhite;
         case 51:return cst_gold;
         case 52:return cst_goldenrod;
         case 53:return cst_gray;
         case 54:return cst_grey;
         case 55:return cst_green;
         case 56:return cst_greenyellow;
         case 57:return cst_honeydew;
         case 58:return cst_hotpink;
         case 59:return cst_indianred;
         case 60:return cst_indigo;
         case 61:return cst_ivory;
         case 62:return cst_khaki;
         case 63:return cst_lavender;
         case 64:return cst_lavenderblush;
         case 65:return cst_lawngreen;
         case 66:return cst_lemonchiffon;
         case 67:return cst_lightblue;
         case 68:return cst_lightcoral;
         case 69:return cst_lightcyan;
         case 70:return cst_lightgoldenrodyellow;
         case 71:return cst_lightgray;
         case 72:return cst_lightgreen;
         default:return cst_lightgrey}
      switch(_dd_)
       {case 0:return cst_aliceblue;
        case 1:return cst_antiquewhite;
        case 2:return cst_aqua;
        case 3:return cst_aquamarine;
        case 4:return cst_azure;
        case 5:return cst_beige;
        case 6:return cst_bisque;
        case 7:return cst_black;
        case 8:return cst_blanchedalmond;
        case 9:return cst_blue;
        case 10:return cst_blueviolet;
        case 11:return cst_brown;
        case 12:return cst_burlywood;
        case 13:return cst_cadetblue;
        case 14:return cst_chartreuse;
        case 15:return cst_chocolate;
        case 16:return cst_coral;
        case 17:return cst_cornflowerblue;
        case 18:return cst_cornsilk;
        case 19:return cst_crimson;
        case 20:return cst_cyan;
        case 21:return cst_darkblue;
        case 22:return cst_darkcyan;
        case 23:return cst_darkgoldenrod;
        case 24:return cst_darkgray;
        case 25:return cst_darkgreen;
        case 26:return cst_darkgrey;
        case 27:return cst_darkkhaki;
        case 28:return cst_darkmagenta;
        case 29:return cst_darkolivegreen;
        case 30:return cst_darkorange;
        case 31:return cst_darkorchid;
        case 32:return cst_darkred;
        case 33:return cst_darksalmon;
        case 34:return cst_darkseagreen;
        case 35:return cst_darkslateblue;
        default:return cst_darkslategray}}
    function name_of_string(s)
     {var switch$0=caml_string_compare(s,cst_lightgrey$0);
      if(0 <= switch$0)
       {if(! (0 < switch$0))return 73;
        var switch$1=caml_string_compare(s,cst_paleturquoise$0);
        if(0 <= switch$1)
         {if(! (0 < switch$1))return 110;
          var switch$2=caml_string_compare(s,cst_skyblue$0);
          if(0 <= switch$2)
           {if(! (0 < switch$2))return 129;
            var switch$3=caml_string_compare(s,cst_thistle$0);
            if(0 <= switch$3)
             {if(! (0 < switch$3))return 138;
              if(! caml_string_notequal(s,cst_tomato$0))return 139;
              if(! caml_string_notequal(s,cst_turquoise$0))return 140;
              if(! caml_string_notequal(s,cst_violet$0))return 141;
              if(! caml_string_notequal(s,cst_wheat$0))return 142;
              if(! caml_string_notequal(s,cst_white$0))return 143;
              if(! caml_string_notequal(s,cst_whitesmoke$0))return 144;
              if(! caml_string_notequal(s,cst_yellow$0))return 145;
              if(! caml_string_notequal(s,cst_yellowgreen$0))return 146}
            else
             {if(! caml_string_notequal(s,cst_slateblue$0))return 130;
              if(! caml_string_notequal(s,cst_slategray$0))return 131;
              if(! caml_string_notequal(s,cst_slategrey$0))return 132;
              if(! caml_string_notequal(s,cst_snow$0))return 133;
              if(! caml_string_notequal(s,cst_springgreen$0))return 134;
              if(! caml_string_notequal(s,cst_steelblue$0))return 135;
              if(! caml_string_notequal(s,cst_tan$0))return 136;
              if(! caml_string_notequal(s,cst_teal$0))return 137}}
          else
           {var switch$4=caml_string_compare(s,cst_rosybrown$0);
            if(0 <= switch$4)
             {if(! (0 < switch$4))return 120;
              if(! caml_string_notequal(s,cst_royalblue$0))return 121;
              if(! caml_string_notequal(s,cst_saddlebrown$0))return 122;
              if(! caml_string_notequal(s,cst_salmon$0))return 123;
              if(! caml_string_notequal(s,cst_sandybrown$0))return 124;
              if(! caml_string_notequal(s,cst_seagreen$0))return 125;
              if(! caml_string_notequal(s,cst_seashell$0))return 126;
              if(! caml_string_notequal(s,cst_sienna$0))return 127;
              if(! caml_string_notequal(s,cst_silver$0))return 128}
            else
             {if(! caml_string_notequal(s,cst_palevioletred$0))return 111;
              if(! caml_string_notequal(s,cst_papayawhip$0))return 112;
              if(! caml_string_notequal(s,cst_peachpuff$0))return 113;
              if(! caml_string_notequal(s,cst_peru$0))return 114;
              if(! caml_string_notequal(s,cst_pink$0))return 115;
              if(! caml_string_notequal(s,cst_plum$0))return 116;
              if(! caml_string_notequal(s,cst_powderblue$0))return 117;
              if(! caml_string_notequal(s,cst_purple$0))return 118;
              if(! caml_string_notequal(s,cst_red$0))return 119}}}
        else
         {var switch$5=caml_string_compare(s,cst_mediumslateblue$0);
          if(0 <= switch$5)
           {if(! (0 < switch$5))return 92;
            var switch$6=caml_string_compare(s,cst_navy$0);
            if(0 <= switch$6)
             {if(! (0 < switch$6))return 101;
              if(! caml_string_notequal(s,cst_oldlace$0))return 102;
              if(! caml_string_notequal(s,cst_olive$0))return 103;
              if(! caml_string_notequal(s,cst_olivedrab$0))return 104;
              if(! caml_string_notequal(s,cst_orange$0))return 105;
              if(! caml_string_notequal(s,cst_orangered$0))return 106;
              if(! caml_string_notequal(s,cst_orchid$0))return 107;
              if(! caml_string_notequal(s,cst_palegoldenrod$0))return 108;
              if(! caml_string_notequal(s,cst_palegreen$0))return 109}
            else
             {if(! caml_string_notequal(s,cst_mediumspringgreen$0))return 93;
              if(! caml_string_notequal(s,cst_mediumturquoise$0))return 94;
              if(! caml_string_notequal(s,cst_mediumvioletred$0))return 95;
              if(! caml_string_notequal(s,cst_midnightblue$0))return 96;
              if(! caml_string_notequal(s,cst_mintcream$0))return 97;
              if(! caml_string_notequal(s,cst_mistyrose$0))return 98;
              if(! caml_string_notequal(s,cst_moccasin$0))return 99;
              if(! caml_string_notequal(s,cst_navajowhite$0))return 100}}
          else
           {var switch$7=caml_string_compare(s,cst_limegreen$0);
            if(0 <= switch$7)
             {if(! (0 < switch$7))return 83;
              if(! caml_string_notequal(s,cst_linen$0))return 84;
              if(! caml_string_notequal(s,cst_magenta$0))return 85;
              if(! caml_string_notequal(s,cst_maroon$0))return 86;
              if(! caml_string_notequal(s,cst_mediumaquamarine$0))return 87;
              if(! caml_string_notequal(s,cst_mediumblue$0))return 88;
              if(! caml_string_notequal(s,cst_mediumorchid$0))return 89;
              if(! caml_string_notequal(s,cst_mediumpurple$0))return 90;
              if(! caml_string_notequal(s,cst_mediumseagreen$0))return 91}
            else
             {if(! caml_string_notequal(s,cst_lightpink$0))return 74;
              if(! caml_string_notequal(s,cst_lightsalmon$0))return 75;
              if(! caml_string_notequal(s,cst_lightseagreen$0))return 76;
              if(! caml_string_notequal(s,cst_lightskyblue$0))return 77;
              if(! caml_string_notequal(s,cst_lightslategray$0))return 78;
              if(! caml_string_notequal(s,cst_lightslategrey$0))return 79;
              if(! caml_string_notequal(s,cst_lightsteelblue$0))return 80;
              if(! caml_string_notequal(s,cst_lightyellow$0))return 81;
              if(! caml_string_notequal(s,cst_lime$0))return 82}}}}
      else
       {var switch$8=caml_string_compare(s,cst_darkslategray$0);
        if(0 <= switch$8)
         {if(! (0 < switch$8))return 36;
          var switch$9=caml_string_compare(s,cst_greenyellow$0);
          if(0 <= switch$9)
           {if(! (0 < switch$9))return 56;
            var switch$10=caml_string_compare(s,cst_lavenderblush$0);
            if(0 <= switch$10)
             {if(! (0 < switch$10))return 64;
              if(! caml_string_notequal(s,cst_lawngreen$0))return 65;
              if(! caml_string_notequal(s,cst_lemonchiffon$0))return 66;
              if(! caml_string_notequal(s,cst_lightblue$0))return 67;
              if(! caml_string_notequal(s,cst_lightcoral$0))return 68;
              if(! caml_string_notequal(s,cst_lightcyan$0))return 69;
              if(! caml_string_notequal(s,cst_lightgoldenrodyellow$0))
               return 70;
              if(! caml_string_notequal(s,cst_lightgray$0))return 71;
              if(! caml_string_notequal(s,cst_lightgreen$0))return 72}
            else
             {if(! caml_string_notequal(s,cst_grey$0))return 54;
              if(! caml_string_notequal(s,cst_honeydew$0))return 57;
              if(! caml_string_notequal(s,cst_hotpink$0))return 58;
              if(! caml_string_notequal(s,cst_indianred$0))return 59;
              if(! caml_string_notequal(s,cst_indigo$0))return 60;
              if(! caml_string_notequal(s,cst_ivory$0))return 61;
              if(! caml_string_notequal(s,cst_khaki$0))return 62;
              if(! caml_string_notequal(s,cst_lavender$0))return 63}}
          else
           {var switch$11=caml_string_compare(s,cst_floralwhite$0);
            if(0 <= switch$11)
             {if(! (0 < switch$11))return 46;
              if(! caml_string_notequal(s,cst_forestgreen$0))return 47;
              if(! caml_string_notequal(s,cst_fuchsia$0))return 48;
              if(! caml_string_notequal(s,cst_gainsboro$0))return 49;
              if(! caml_string_notequal(s,cst_ghostwhite$0))return 50;
              if(! caml_string_notequal(s,cst_gold$0))return 51;
              if(! caml_string_notequal(s,cst_goldenrod$0))return 52;
              if(! caml_string_notequal(s,cst_gray$0))return 53;
              if(! caml_string_notequal(s,cst_green$0))return 55}
            else
             {if(! caml_string_notequal(s,cst_darkslategrey$0))return 37;
              if(! caml_string_notequal(s,cst_darkturquoise$0))return 38;
              if(! caml_string_notequal(s,cst_darkviolet$0))return 39;
              if(! caml_string_notequal(s,cst_deeppink$0))return 40;
              if(! caml_string_notequal(s,cst_deepskyblue$0))return 41;
              if(! caml_string_notequal(s,cst_dimgray$0))return 42;
              if(! caml_string_notequal(s,cst_dimgrey$0))return 43;
              if(! caml_string_notequal(s,cst_dodgerblue$0))return 44;
              if(! caml_string_notequal(s,cst_firebrick$0))return 45}}}
        else
         {var switch$12=caml_string_compare(s,cst_cornsilk$0);
          if(0 <= switch$12)
           {if(! (0 < switch$12))return 18;
            var switch$13=caml_string_compare(s,cst_darkkhaki$0);
            if(0 <= switch$13)
             {if(! (0 < switch$13))return 27;
              if(! caml_string_notequal(s,cst_darkmagenta$0))return 28;
              if(! caml_string_notequal(s,cst_darkolivegreen$0))return 29;
              if(! caml_string_notequal(s,cst_darkorange$0))return 30;
              if(! caml_string_notequal(s,cst_darkorchid$0))return 31;
              if(! caml_string_notequal(s,cst_darkred$0))return 32;
              if(! caml_string_notequal(s,cst_darksalmon$0))return 33;
              if(! caml_string_notequal(s,cst_darkseagreen$0))return 34;
              if(! caml_string_notequal(s,cst_darkslateblue$0))return 35}
            else
             {if(! caml_string_notequal(s,cst_crimson$0))return 19;
              if(! caml_string_notequal(s,cst_cyan$0))return 20;
              if(! caml_string_notequal(s,cst_darkblue$0))return 21;
              if(! caml_string_notequal(s,cst_darkcyan$0))return 22;
              if(! caml_string_notequal(s,cst_darkgoldenrod$0))return 23;
              if(! caml_string_notequal(s,cst_darkgray$0))return 24;
              if(! caml_string_notequal(s,cst_darkgreen$0))return 25;
              if(! caml_string_notequal(s,cst_darkgrey$0))return 26}}
          else
           {var switch$14=caml_string_compare(s,cst_blue$0);
            if(0 <= switch$14)
             {if(! (0 < switch$14))return 9;
              if(! caml_string_notequal(s,cst_blueviolet$0))return 10;
              if(! caml_string_notequal(s,cst_brown$0))return 11;
              if(! caml_string_notequal(s,cst_burlywood$0))return 12;
              if(! caml_string_notequal(s,cst_cadetblue$0))return 13;
              if(! caml_string_notequal(s,cst_chartreuse$0))return 14;
              if(! caml_string_notequal(s,cst_chocolate$0))return 15;
              if(! caml_string_notequal(s,cst_coral$0))return 16;
              if(! caml_string_notequal(s,cst_cornflowerblue$0))return 17}
            else
             {if(! caml_string_notequal(s,cst_aliceblue$0))return 0;
              if(! caml_string_notequal(s,cst_antiquewhite$0))return 1;
              if(! caml_string_notequal(s,cst_aqua$0))return 2;
              if(! caml_string_notequal(s,cst_aquamarine$0))return 3;
              if(! caml_string_notequal(s,cst_azure$0))return 4;
              if(! caml_string_notequal(s,cst_beige$0))return 5;
              if(! caml_string_notequal(s,cst_bisque$0))return 6;
              if(! caml_string_notequal(s,cst_black$0))return 7;
              if(! caml_string_notequal(s,cst_blanchedalmond$0))return 8}}}}
      var _dc_=caml_call2(Stdlib[28],s,cst_is_not_a_valid_color_name);
      throw [0,Stdlib[6],_dc_]}
    function rgb_of_name(param)
     {var _db_=param;
      if(74 <= _db_)
       {if(111 <= _db_)
         switch(_db_)
          {case 111:return _bp_;
           case 112:return _bq_;
           case 113:return _br_;
           case 114:return _bs_;
           case 115:return _bt_;
           case 116:return _bu_;
           case 117:return _bv_;
           case 118:return _bw_;
           case 119:return _bx_;
           case 120:return _by_;
           case 121:return _bz_;
           case 122:return _bA_;
           case 123:return _bB_;
           case 124:return _bC_;
           case 125:return _bD_;
           case 126:return _bE_;
           case 127:return _bF_;
           case 128:return _bG_;
           case 129:return _bH_;
           case 130:return _bI_;
           case 131:return _bJ_;
           case 132:return _bK_;
           case 133:return _bL_;
           case 134:return _bM_;
           case 135:return _bN_;
           case 136:return _bO_;
           case 137:return _bP_;
           case 138:return _bQ_;
           case 139:return _bR_;
           case 140:return _bS_;
           case 141:return _bT_;
           case 142:return _bU_;
           case 143:return _bV_;
           case 144:return _bW_;
           case 145:return _bX_;
           default:return _bY_}
        switch(_db_)
         {case 74:return _aQ_;
          case 75:return _aR_;
          case 76:return _aS_;
          case 77:return _aT_;
          case 78:return _aU_;
          case 79:return _aV_;
          case 80:return _aW_;
          case 81:return _aX_;
          case 82:return _aY_;
          case 83:return _aZ_;
          case 84:return _a0_;
          case 85:return _a1_;
          case 86:return _a2_;
          case 87:return _a3_;
          case 88:return _a4_;
          case 89:return _a5_;
          case 90:return _a6_;
          case 91:return _a7_;
          case 92:return _a8_;
          case 93:return _a9_;
          case 94:return _a__;
          case 95:return _a$_;
          case 96:return _ba_;
          case 97:return _bb_;
          case 98:return _bc_;
          case 99:return _bd_;
          case 100:return _be_;
          case 101:return _bf_;
          case 102:return _bg_;
          case 103:return _bh_;
          case 104:return _bi_;
          case 105:return _bj_;
          case 106:return _bk_;
          case 107:return _bl_;
          case 108:return _bm_;
          case 109:return _bn_;
          default:return _bo_}}
      if(37 <= _db_)
       switch(_db_)
        {case 37:return _af_;
         case 38:return _ag_;
         case 39:return _ah_;
         case 40:return _ai_;
         case 41:return _aj_;
         case 42:return _ak_;
         case 43:return _al_;
         case 44:return _am_;
         case 45:return _an_;
         case 46:return _ao_;
         case 47:return _ap_;
         case 48:return _aq_;
         case 49:return _ar_;
         case 50:return _as_;
         case 51:return _at_;
         case 52:return _au_;
         case 53:return _av_;
         case 54:return _aw_;
         case 55:return _ax_;
         case 56:return _ay_;
         case 57:return _az_;
         case 58:return _aA_;
         case 59:return _aB_;
         case 60:return _aC_;
         case 61:return _aD_;
         case 62:return _aE_;
         case 63:return _aF_;
         case 64:return _aG_;
         case 65:return _aH_;
         case 66:return _aI_;
         case 67:return _aJ_;
         case 68:return _aK_;
         case 69:return _aL_;
         case 70:return _aM_;
         case 71:return _aN_;
         case 72:return _aO_;
         default:return _aP_}
      switch(_db_)
       {case 0:return _w_;
        case 1:return _x_;
        case 2:return _y_;
        case 3:return _z_;
        case 4:return _A_;
        case 5:return _B_;
        case 6:return _C_;
        case 7:return _D_;
        case 8:return _E_;
        case 9:return _F_;
        case 10:return _G_;
        case 11:return _H_;
        case 12:return _I_;
        case 13:return _J_;
        case 14:return _K_;
        case 15:return _L_;
        case 16:return _M_;
        case 17:return _N_;
        case 18:return _O_;
        case 19:return _P_;
        case 20:return _Q_;
        case 21:return _R_;
        case 22:return _S_;
        case 23:return _T_;
        case 24:return _U_;
        case 25:return _V_;
        case 26:return _W_;
        case 27:return _X_;
        case 28:return _Y_;
        case 29:return _Z_;
        case 30:return ___;
        case 31:return _$_;
        case 32:return _aa_;
        case 33:return _ab_;
        case 34:return _ac_;
        case 35:return _ad_;
        default:return _ae_}}
    function rgb(a,r,g,b)
     {if(a){var a$0=a[1];return [3,[0,r,g,b,a$0]]}return [1,[0,r,g,b]]}
    function hsl(a,h,s,l)
     {if(a){var a$0=a[1];return [6,[0,h,s,l,a$0]]}return [5,[0,h,s,l]]}
    function string_of_t(param)
     {switch(param[0])
       {case 0:var n=param[1];return string_of_name(n);
        case 1:
         var match=param[1],b=match[3],g=match[2],r=match[1];
         return caml_call4(Stdlib_printf[4],_bZ_,r,g,b);
        case 2:
         var match$0=param[1],b$0=match$0[3],g$0=match$0[2],r$0=match$0[1];
         return caml_call4(Stdlib_printf[4],_b0_,r$0,g$0,b$0);
        case 3:
         var
          match$1=param[1],
          a=match$1[4],
          b$1=match$1[3],
          g$1=match$1[2],
          r$1=match$1[1];
         return caml_call5(Stdlib_printf[4],_b1_,r$1,g$1,b$1,a);
        case 4:
         var
          match$2=param[1],
          a$0=match$2[4],
          b$2=match$2[3],
          g$2=match$2[2],
          r$2=match$2[1];
         return caml_call5(Stdlib_printf[4],_b2_,r$2,g$2,b$2,a$0);
        case 5:
         var match$3=param[1],l=match$3[3],s=match$3[2],h=match$3[1];
         return caml_call4(Stdlib_printf[4],_b3_,h,s,l);
        default:
         var
          match$4=param[1],
          a$1=match$4[4],
          l$0=match$4[3],
          s$0=match$4[2],
          h$0=match$4[1];
         return caml_call5(Stdlib_printf[4],_b4_,h$0,s$0,l$0,a$1)}}
    function hex_of_rgb(param)
     {var blue=param[3],green=param[2],red=param[1];
      function in_range(i)
       {var
         _c9_=caml_call2(symbol$5,i,0),
         _c__=_c9_ || caml_call2(symbol$9,i,255);
        if(_c__)
         {var
           _c$_=caml_call1(Stdlib[33],i),
           _da_=caml_call2(Stdlib[28],_c$_,cst_is_out_of_valid_range);
          throw [0,Stdlib[6],_da_]}
        return _c__}
      in_range(red);
      in_range(green);
      in_range(blue);
      return caml_call4(Stdlib_printf[4],_b5_,red,green,blue)}
    function js_t_of_js_string(s)
     {var
       t0=caml_jsbytes_of_string(cst_rgb_s_d_s_d_s_d),
       t13=new t11(t0),
       t2=caml_jsbytes_of_string(cst_rgb_s_d_s_d_s_d$0),
       t17=new t11(t2),
       t4=caml_jsbytes_of_string(cst_rgba_s_d_s_d_s_d_d_d),
       t15=new t11(t4),
       t6=caml_jsbytes_of_string(cst_rgba_s_d_s_d_s_d_d_d$0),
       t19=new t11(t6),
       t8=caml_jsbytes_of_string(cst_hsl_s_d_s_d_s_d),
       t21=new t11(t8),
       t10=caml_jsbytes_of_string(cst_hsla_s_d_s_d_s_d_d_d),
       t23=new t11(t10);
      if
       (!
        (t13.test(s) | 0)
        &&
        !
        (t15.test(s) | 0)
        &&
        !
        (t17.test(s) | 0)
        &&
        !
        (t19.test(s) | 0)
        &&
        !
        (t21.test(s) | 0)
        &&
        !
        (t23.test(s) | 0))
       {var _c6_=caml_string_of_jsstring(s);
        if(caml_call2(Stdlib_list[36],_c6_,_b6_))return s;
        var
         _c7_=caml_string_of_jsstring(s),
         _c8_=caml_call2(Stdlib[28],_c7_,cst_is_not_a_valid_color);
        throw [0,Stdlib[6],_c8_]}
      return s}
    function js(c)
     {if(0 === c[0])
       {var n=c[1];return caml_jsstring_of_string(string_of_name(n))}
      return caml_jsstring_of_string(string_of_t(c))}
    function ml(c)
     {var s=caml_string_of_jsstring(c);
      try
       {var _cT_=[0,name_of_string(s)];return _cT_}
      catch(_cU_)
       {_cU_ = caml_wrap_exception(_cU_);
        if(_cU_[1] === Stdlib[6])
         {var
           fail=
            function(param)
             {var _c5_=caml_call2(Stdlib[28],s,cst_is_not_a_valid_color$0);
              throw [0,Stdlib[6],_c5_]},
           re_rgb=regexp(cst_rgba_d_d_d_d_d),
           re_rgb_pct=regexp(cst_rgba_d_d_d_d_d$0),
           re_hsl=regexp(cst_hsla_d_d_d_d_d),
           i_of_s_o=
            function(param)
             {if(param)
               {var i=param[1];
                try
                 {var _c3_=caml_int_of_string(i);return _c3_}
                catch(_c4_)
                 {_c4_ = caml_wrap_exception(_c4_);
                  if(_c4_[1] === Stdlib[6])
                   var s=_c4_[2];
                  else
                   {if(_c4_[1] !== Stdlib[7])throw _c4_;var s=_c4_[2]}
                  var
                   _c0_=caml_call2(Stdlib[28],cst$39,s),
                   _c1_=caml_call2(Stdlib[28],i,_c0_),
                   _c2_=caml_call2(Stdlib[28],cst_color_conversion_error,_c1_);
                  throw [0,Stdlib[6],_c2_]}}
              return fail(0)},
           f_of_s=
            function(f)
             {try
               {var _cY_=caml_float_of_string(f);return _cY_}
              catch(_cZ_)
               {_cZ_ = caml_wrap_exception(_cZ_);
                if(_cZ_[1] === Stdlib[6])
                 var s=_cZ_[2];
                else
                 {if(_cZ_[1] !== Stdlib[7])throw _cZ_;var s=_cZ_[2]}
                var
                 _cV_=caml_call2(Stdlib[28],cst$40,s),
                 _cW_=caml_call2(Stdlib[28],f,_cV_),
                 _cX_=caml_call2(Stdlib[28],cst_color_conversion_error$0,_cW_);
                throw [0,Stdlib[6],_cX_]}},
           match=string_match(re_rgb,s,0);
          if(match)
           {var
             r=match[1],
             red=matched_group(r,2),
             green=matched_group(r,3),
             blue=matched_group(r,4),
             alpha=matched_group(r,5),
             match$0=matched_group(r,1);
            if(match$0)
             {var _cB_=match$0[1];
              if(! caml_string_notequal(_cB_,cst_rgb))
               {if(alpha)return fail(0);
                var _cF_=i_of_s_o(blue),_cG_=i_of_s_o(green);
                return [1,[0,i_of_s_o(red),_cG_,_cF_]]}
              if(! caml_string_notequal(_cB_,cst_rgba))
               {if(alpha)
                 {var
                   a=alpha[1],
                   _cC_=f_of_s(a),
                   _cD_=i_of_s_o(blue),
                   _cE_=i_of_s_o(green);
                  return [3,[0,i_of_s_o(red),_cE_,_cD_,_cC_]]}
                return fail(0)}}
            return fail(0)}
          var match$1=string_match(re_rgb_pct,s,0);
          if(match$1)
           {var
             r$0=match$1[1],
             red$0=matched_group(r$0,2),
             green$0=matched_group(r$0,3),
             blue$0=matched_group(r$0,4),
             alpha$0=matched_group(r$0,5),
             match$2=matched_group(r$0,1);
            if(match$2)
             {var _cH_=match$2[1];
              if(! caml_string_notequal(_cH_,cst_rgb$0))
               {if(alpha$0)return fail(0);
                var _cL_=i_of_s_o(blue$0),_cM_=i_of_s_o(green$0);
                return [2,[0,i_of_s_o(red$0),_cM_,_cL_]]}
              if(! caml_string_notequal(_cH_,cst_rgba$0))
               {if(alpha$0)
                 {var
                   a$0=alpha$0[1],
                   _cI_=f_of_s(a$0),
                   _cJ_=i_of_s_o(blue$0),
                   _cK_=i_of_s_o(green$0);
                  return [4,[0,i_of_s_o(red$0),_cK_,_cJ_,_cI_]]}
                return fail(0)}}
            return fail(0)}
          var match$3=string_match(re_hsl,s,0);
          if(match$3)
           {var
             r$1=match$3[1],
             red$1=matched_group(r$1,2),
             green$1=matched_group(r$1,3),
             blue$1=matched_group(r$1,4),
             alpha$1=matched_group(r$1,5),
             match$4=matched_group(r$1,1);
            if(match$4)
             {var _cN_=match$4[1];
              if(! caml_string_notequal(_cN_,cst_hsl))
               {if(alpha$1)return fail(0);
                var _cR_=i_of_s_o(blue$1),_cS_=i_of_s_o(green$1);
                return [5,[0,i_of_s_o(red$1),_cS_,_cR_]]}
              if(! caml_string_notequal(_cN_,cst_hsla))
               {if(alpha$1)
                 {var
                   a$1=alpha$1[1],
                   _cO_=f_of_s(a$1),
                   _cP_=i_of_s_o(blue$1),
                   _cQ_=i_of_s_o(green$1);
                  return [6,[0,i_of_s_o(red$1),_cQ_,_cP_,_cO_]]}
                return fail(0)}}
            return fail(0)}
          return fail(0)}
        throw _cU_}}
    function string_of_t$0(param)
     {if(typeof param === "number")
       return cst_0;
      else
       switch(param[0])
        {case 0:
          var f=param[1];return caml_call3(Stdlib_printf[4],_b7_,f,cst_em$0);
         case 1:
          var f$0=param[1];
          return caml_call3(Stdlib_printf[4],_b8_,f$0,cst_ex);
         case 2:
          var f$1=param[1];
          return caml_call3(Stdlib_printf[4],_b9_,f$1,cst_px);
         case 3:
          var f$2=param[1];
          return caml_call3(Stdlib_printf[4],_b__,f$2,cst_gd);
         case 4:
          var f$3=param[1];
          return caml_call3(Stdlib_printf[4],_b$_,f$3,cst_rem);
         case 5:
          var f$4=param[1];
          return caml_call3(Stdlib_printf[4],_ca_,f$4,cst_vw);
         case 6:
          var f$5=param[1];
          return caml_call3(Stdlib_printf[4],_cb_,f$5,cst_vh);
         case 7:
          var f$6=param[1];
          return caml_call3(Stdlib_printf[4],_cc_,f$6,cst_vm);
         case 8:
          var f$7=param[1];
          return caml_call3(Stdlib_printf[4],_cd_,f$7,cst_ch);
         case 9:
          var f$8=param[1];
          return caml_call3(Stdlib_printf[4],_ce_,f$8,cst_mm);
         case 10:
          var f$9=param[1];
          return caml_call3(Stdlib_printf[4],_cf_,f$9,cst_cm);
         case 11:
          var f$10=param[1];
          return caml_call3(Stdlib_printf[4],_cg_,f$10,cst_in);
         case 12:
          var f$11=param[1];
          return caml_call3(Stdlib_printf[4],_ch_,f$11,cst_pt);
         default:
          var f$12=param[1];
          return caml_call3(Stdlib_printf[4],_ci_,f$12,cst_pc)}}
    function js$0(t){return caml_jsstring_of_string(string_of_t$0(t))}
    function ml$0(t)
     {var s=caml_string_of_jsstring(t);
      if(caml_call2(String[38],s,cst_0$0))return 0;
      function fail(param)
       {var _cA_=caml_call2(Stdlib[28],s,cst_is_not_a_valid_length);
        throw [0,Stdlib[6],_cA_]}
      var re=regexp(cst_d_d_s_S),match=string_match(re,s,0);
      if(match)
       {var r=match[1],match$0=matched_group(r,1);
        if(match$0)
         {var f=match$0[1];
          try
           {var _cy_=caml_float_of_string(f)}
          catch(exn)
           {exn = caml_wrap_exception(exn);
            if(exn[1] === Stdlib[6])
             {var
               s$0=exn[2],
               _cx_=caml_call2(Stdlib[28],cst_length_conversion_error,s$0);
              throw [0,Stdlib[6],_cx_]}
            throw exn}
          var f$0=_cy_}
        else
         var f$0=fail(0);
        var match$1=matched_group(r,2);
        if(match$1)
         {var _cz_=match$1[1],switch$0=caml_string_compare(_cz_,cst_pc$0);
          if(0 <= switch$0)
           {if(! (0 < switch$0))return [13,f$0];
            if(! caml_string_notequal(_cz_,cst_pt$0))return [12,f$0];
            if(! caml_string_notequal(_cz_,cst_px$0))return [2,f$0];
            if(! caml_string_notequal(_cz_,cst_rem$0))return [4,f$0];
            if(! caml_string_notequal(_cz_,cst_vh$0))return [6,f$0];
            if(! caml_string_notequal(_cz_,cst_vm$0))return [7,f$0];
            if(! caml_string_notequal(_cz_,cst_vw$0))return [5,f$0]}
          else
           {if(! caml_string_notequal(_cz_,cst_ch$0))return [8,f$0];
            if(! caml_string_notequal(_cz_,cst_cm$0))return [10,f$0];
            if(! caml_string_notequal(_cz_,cst_em$1))return [0,f$0];
            if(! caml_string_notequal(_cz_,cst_ex$0))return [1,f$0];
            if(! caml_string_notequal(_cz_,cst_gd$0))return [3,f$0];
            if(! caml_string_notequal(_cz_,cst_in$0))return [11,f$0];
            if(! caml_string_notequal(_cz_,cst_mm$0))return [9,f$0]}
          return fail(0)}
        return fail(0)}
      return fail(0)}
    var Length=[0,string_of_t$0,js$0,ml$0];
    function string_of_t$1(param)
     {switch(param[0])
       {case 0:
         var f=param[1];return caml_call3(Stdlib_printf[4],_cj_,f,cst_deg);
        case 1:
         var f$0=param[1];
         return caml_call3(Stdlib_printf[4],_ck_,f$0,cst_grad);
        case 2:
         var f$1=param[1];
         return caml_call3(Stdlib_printf[4],_cl_,f$1,cst_rad);
        default:
         var f$2=param[1];
         return caml_call3(Stdlib_printf[4],_cm_,f$2,cst_turns)}}
    function js$1(t){return caml_jsstring_of_string(string_of_t$1(t))}
    function ml$1(j)
     {var s=caml_string_of_jsstring(j),re=regexp(cst_d_d_deg_grad_rad_turns);
      function fail(param)
       {var _cw_=caml_call2(Stdlib[28],s,cst_is_not_a_valid_length$0);
        throw [0,Stdlib[6],_cw_]}
      var match=string_match(re,s,0);
      if(match)
       {var r=match[1],match$0=matched_group(r,1);
        if(match$0)
         {var f=match$0[1];
          try
           {var _cu_=caml_float_of_string(f)}
          catch(exn)
           {exn = caml_wrap_exception(exn);
            if(exn[1] === Stdlib[6])
             {var
               s$0=exn[2],
               _ct_=caml_call2(Stdlib[28],cst_length_conversion_error$0,s$0);
              throw [0,Stdlib[6],_ct_]}
            throw exn}
          var f$0=_cu_}
        else
         var f$0=fail(0);
        var match$1=matched_group(r,2);
        if(match$1)
         {var _cv_=match$1[1];
          if(! caml_string_notequal(_cv_,cst_deg$0))return [0,f$0];
          if(! caml_string_notequal(_cv_,cst_grad$0))return [1,f$0];
          if(! caml_string_notequal(_cv_,cst_rad$0))return [2,f$0];
          if(! caml_string_notequal(_cv_,cst_turns$0))return [3,f$0]}
        return fail(0)}
      return fail(0)}
    var
     Angle=[0,string_of_t$1,js$1,ml$1],
     Js_of_ocaml_CSS=
      [0,
       [0,
        string_of_name,
        rgb_of_name,
        hex_of_rgb,
        rgb,
        hsl,
        string_of_t,
        js,
        ml,
        js_t_of_js_string],
       Length,
       Angle];
    caml_register_global(1663,Js_of_ocaml_CSS,"Js_of_ocaml__CSS");
    function listen(opt,target,typ,cb)
     {if(opt)var sth=opt[1],capture=sth;else var capture=0;
      var _cs_=! ! capture;
      return addEventListener
              (target,
               typ,
               full_handler(function(n,e){return ! ! caml_call2(cb,n,e)}),
               _cs_)}
    var Js_of_ocaml_Dom_events=[0,Event$0,listen,removeEventListener];
    caml_register_global
     (1664,Js_of_ocaml_Dom_events,"Js_of_ocaml__Dom_events");
    var
     t0="http://www.w3.org/2000/svg",
     SVGError=[248,cst_Js_of_ocaml_Dom_svg_SVGErr,caml_fresh_oo_id(0)];
    function createElement$0(t2,name)
     {var t1=caml_jsstring_of_string(name);
      return t2.createElementNS("http://www.w3.org/2000/svg",t1)}
    function unsafeCreateElement$0(doc,name){return createElement$0(doc,name)}
    function createA$0(doc){return unsafeCreateElement$0(doc,cst_a$2)}
    function createAltGlyph(doc)
     {return unsafeCreateElement$0(doc,cst_altglyph)}
    function createAltGlyphDef(doc)
     {return unsafeCreateElement$0(doc,cst_altglyphdef)}
    function createAltGlyphItem(doc)
     {return unsafeCreateElement$0(doc,cst_altglyphitem)}
    function createAnimate(doc){return unsafeCreateElement$0(doc,cst_animate)}
    function createAnimateColor(doc)
     {return unsafeCreateElement$0(doc,cst_animatecolor)}
    function createAnimateMotion(doc)
     {return unsafeCreateElement$0(doc,cst_animatemotion)}
    function createAnimateTransform(doc)
     {return unsafeCreateElement$0(doc,cst_animatetransform)}
    function createCircle(doc){return unsafeCreateElement$0(doc,cst_circle)}
    function createClipPath(doc)
     {return unsafeCreateElement$0(doc,cst_clippath)}
    function createCursor(doc){return unsafeCreateElement$0(doc,cst_cursor)}
    function createDefs(doc){return unsafeCreateElement$0(doc,cst_defs)}
    function createDesc(doc){return unsafeCreateElement$0(doc,cst_desc)}
    function createEllipse(doc){return unsafeCreateElement$0(doc,cst_ellipse)}
    function createFilter(doc){return unsafeCreateElement$0(doc,cst_filter)}
    function createFont(doc){return unsafeCreateElement$0(doc,cst_font)}
    function createFontFace(doc)
     {return unsafeCreateElement$0(doc,cst_font_face)}
    function createFontFaceFormat(doc)
     {return unsafeCreateElement$0(doc,cst_font_face_format)}
    function createFontFaceName(doc)
     {return unsafeCreateElement$0(doc,cst_font_face_name)}
    function createFontFaceSrc(doc)
     {return unsafeCreateElement$0(doc,cst_font_face_src)}
    function createFontFaceUri(doc)
     {return unsafeCreateElement$0(doc,cst_font_face_uri)}
    function createForeignObject(doc)
     {return unsafeCreateElement$0(doc,cst_foreignObject)}
    function createG(doc){return unsafeCreateElement$0(doc,cst_g$0)}
    function createGlyph(doc){return unsafeCreateElement$0(doc,cst_glyph)}
    function createGlyphRef(doc)
     {return unsafeCreateElement$0(doc,cst_glyphref)}
    function createhkern(doc){return unsafeCreateElement$0(doc,cst_hkern)}
    function createImage(doc){return unsafeCreateElement$0(doc,cst_image)}
    function createLineElement(doc)
     {return unsafeCreateElement$0(doc,cst_line)}
    function createLinearElement(doc)
     {return unsafeCreateElement$0(doc,cst_lineargradient)}
    function createMask(doc){return unsafeCreateElement$0(doc,cst_mask)}
    function createMetaData(doc)
     {return unsafeCreateElement$0(doc,cst_metadata)}
    function createMissingGlyph(doc)
     {return unsafeCreateElement$0(doc,cst_missing_glyph)}
    function createMPath(doc){return unsafeCreateElement$0(doc,cst_mpath)}
    function createPath(doc){return unsafeCreateElement$0(doc,cst_path)}
    function createPattern(doc){return unsafeCreateElement$0(doc,cst_pattern)}
    function createPolygon(doc){return unsafeCreateElement$0(doc,cst_polygon)}
    function createPolyline(doc)
     {return unsafeCreateElement$0(doc,cst_polyline)}
    function createRadialgradient(doc)
     {return unsafeCreateElement$0(doc,cst_radialgradient)}
    function createRect(doc){return unsafeCreateElement$0(doc,cst_rect)}
    function createScript$0(doc)
     {return unsafeCreateElement$0(doc,cst_script$2)}
    function createSet(doc){return unsafeCreateElement$0(doc,cst_set)}
    function createStop(doc){return unsafeCreateElement$0(doc,cst_stop)}
    function createStyle$0(doc){return unsafeCreateElement$0(doc,cst_style$2)}
    function createSvg(doc){return unsafeCreateElement$0(doc,cst_svg)}
    function createSwitch(doc){return unsafeCreateElement$0(doc,cst_switch)}
    function createSymbol(doc){return unsafeCreateElement$0(doc,cst_symbol)}
    function createTextElement(doc)
     {return unsafeCreateElement$0(doc,cst_text$0)}
    function createTextpath(doc)
     {return unsafeCreateElement$0(doc,cst_textpath)}
    function createTitle$0(doc){return unsafeCreateElement$0(doc,cst_title$2)}
    function createTref(doc){return unsafeCreateElement$0(doc,cst_tref)}
    function createTspan(doc){return unsafeCreateElement$0(doc,cst_tspan)}
    function createUse(doc){return unsafeCreateElement$0(doc,cst_use)}
    function createView(doc){return unsafeCreateElement$0(doc,cst_view)}
    function createvkern(doc){return unsafeCreateElement$0(doc,cst_vkern)}
    var svg_element=Unsafe[1].SVGElement,document$0=Unsafe[1].document;
    function getElementById$0(id)
     {function _cp_(e){if(e instanceof svg_element)return e;throw Stdlib[8]}
      function _cq_(param){throw Stdlib[8]}
      var
       t6=caml_jsstring_of_string(id),
       t7=Unsafe[1].document,
       _cr_=t7.getElementById(t6);
      return caml_call3(Opt[7],_cr_,_cq_,_cp_)}
    function element$2(e){return e instanceof svg_element?e:no_handler}
    function unsafeCoerce$0(e,tag)
     {var t9=e.tagName,_co_=caml_jsstring_of_string(tag);
      return t9.toLowerCase() === _co_?e:no_handler}
    function a$0(e){return unsafeCoerce$0(e,cst_a$3)}
    function altGlyph(e){return unsafeCoerce$0(e,cst_altglyph$0)}
    function altGlyphDef(e){return unsafeCoerce$0(e,cst_altglyphdef$0)}
    function altGlyphItem(e){return unsafeCoerce$0(e,cst_altglyphitem$0)}
    function animate(e){return unsafeCoerce$0(e,cst_animate$0)}
    function animateColor(e){return unsafeCoerce$0(e,cst_animatecolor$0)}
    function animateMotion(e){return unsafeCoerce$0(e,cst_animatemotion$0)}
    function animateTransform(e)
     {return unsafeCoerce$0(e,cst_animatetransform$0)}
    function circle(e){return unsafeCoerce$0(e,cst_circle$0)}
    function clipPath(e){return unsafeCoerce$0(e,cst_clippath$0)}
    function cursor(e){return unsafeCoerce$0(e,cst_cursor$0)}
    function defs(e){return unsafeCoerce$0(e,cst_defs$0)}
    function desc(e){return unsafeCoerce$0(e,cst_desc$0)}
    function ellipse(e){return unsafeCoerce$0(e,cst_ellipse$0)}
    function filter(e){return unsafeCoerce$0(e,cst_filter$0)}
    function font(e){return unsafeCoerce$0(e,cst_font$0)}
    function fontFace(e){return unsafeCoerce$0(e,cst_font_face$0)}
    function fontFaceFormat(e)
     {return unsafeCoerce$0(e,cst_font_face_format$0)}
    function fontFaceName(e){return unsafeCoerce$0(e,cst_font_face_name$0)}
    function fontFaceSrc(e){return unsafeCoerce$0(e,cst_font_face_src$0)}
    function fontFaceUri(e){return unsafeCoerce$0(e,cst_font_face_uri$0)}
    function foreignObject(e){return unsafeCoerce$0(e,cst_foreignobject)}
    function g(e){return unsafeCoerce$0(e,cst_g$1)}
    function glyph(e){return unsafeCoerce$0(e,cst_glyph$0)}
    function glyphRef(e){return unsafeCoerce$0(e,cst_glyphref$0)}
    function hkern(e){return unsafeCoerce$0(e,cst_hkern$0)}
    function image(e){return unsafeCoerce$0(e,cst_image$0)}
    function lineElement(e){return unsafeCoerce$0(e,cst_line$0)}
    function linearElement(e){return unsafeCoerce$0(e,cst_lineargradient$0)}
    function mask(e){return unsafeCoerce$0(e,cst_mask$0)}
    function metaData(e){return unsafeCoerce$0(e,cst_metadata$0)}
    function missingGlyph(e){return unsafeCoerce$0(e,cst_missing_glyph$0)}
    function mPath(e){return unsafeCoerce$0(e,cst_mpath$0)}
    function path$0(e){return unsafeCoerce$0(e,cst_path$0)}
    function pattern(e){return unsafeCoerce$0(e,cst_pattern$0)}
    function polygon(e){return unsafeCoerce$0(e,cst_polygon$0)}
    function polyline(e){return unsafeCoerce$0(e,cst_polyline$0)}
    function radialgradient(e){return unsafeCoerce$0(e,cst_radialgradient$0)}
    function rect(e){return unsafeCoerce$0(e,cst_rect$0)}
    function script$0(e){return unsafeCoerce$0(e,cst_script$3)}
    function set$1(e){return unsafeCoerce$0(e,cst_set$0)}
    function stop(e){return unsafeCoerce$0(e,cst_stop$0)}
    function style$0(e){return unsafeCoerce$0(e,cst_style$3)}
    function svg(e){return unsafeCoerce$0(e,cst_svg$0)}
    function switch$0(e){return unsafeCoerce$0(e,cst_switch$0)}
    function symbol$12(e){return unsafeCoerce$0(e,cst_symbol$0)}
    function textElement(e){return unsafeCoerce$0(e,cst_text$1)}
    function textpath(e){return unsafeCoerce$0(e,cst_textpath$0)}
    function title$0(e){return unsafeCoerce$0(e,cst_title$3)}
    function tref(e){return unsafeCoerce$0(e,cst_tref$0)}
    function tspan(e){return unsafeCoerce$0(e,cst_tspan$0)}
    function use(e){return unsafeCoerce$0(e,cst_use$0)}
    function view(e){return unsafeCoerce$0(e,cst_view$0)}
    function vkern(e){return unsafeCoerce$0(e,cst_vkern$0)}
    var
     Js_of_ocaml_Dom_svg=
      [0,
       t0,
       SVGError,
       createElement$0,
       createA$0,
       createAltGlyph,
       createAltGlyphDef,
       createAltGlyphItem,
       createAnimate,
       createAnimateColor,
       createAnimateMotion,
       createAnimateTransform,
       createCircle,
       createClipPath,
       createCursor,
       createDefs,
       createDesc,
       createEllipse,
       createFilter,
       createFont,
       createFontFace,
       createFontFaceFormat,
       createFontFaceName,
       createFontFaceSrc,
       createFontFaceUri,
       createForeignObject,
       createG,
       createGlyph,
       createGlyphRef,
       createhkern,
       createImage,
       createLineElement,
       createLinearElement,
       createMask,
       createMetaData,
       createMissingGlyph,
       createMPath,
       createPath,
       createPattern,
       createPolygon,
       createPolyline,
       createRadialgradient,
       createRect,
       createScript$0,
       createSet,
       createStop,
       createStyle$0,
       createSvg,
       createSwitch,
       createSymbol,
       createTextElement,
       createTextpath,
       createTitle$0,
       createTref,
       createTspan,
       createUse,
       createView,
       createvkern,
       svg_element,
       document$0,
       getElementById$0,
       [0,
        element$2,
        a$0,
        altGlyph,
        altGlyphDef,
        altGlyphItem,
        animate,
        animateColor,
        animateMotion,
        animateTransform,
        circle,
        clipPath,
        cursor,
        defs,
        desc,
        ellipse,
        filter,
        font,
        fontFace,
        fontFaceFormat,
        fontFaceName,
        fontFaceSrc,
        fontFaceUri,
        foreignObject,
        g,
        glyph,
        glyphRef,
        hkern,
        image,
        lineElement,
        linearElement,
        mask,
        metaData,
        missingGlyph,
        mPath,
        path$0,
        pattern,
        polygon,
        polyline,
        radialgradient,
        rect,
        script$0,
        set$1,
        stop,
        style$0,
        svg,
        switch$0,
        symbol$12,
        textElement,
        textpath,
        title$0,
        tref,
        tspan,
        use,
        view,
        vkern]];
    caml_register_global(1665,Js_of_ocaml_Dom_svg,"Js_of_ocaml__Dom_svg");
    function withCredentials(b)
     {var init={};init.withCredentials = ! ! b;return init}
    var
     eventSource=Unsafe[1].EventSource,
     eventSource_options=Unsafe[1].EventSource,
     Js_of_ocaml_EventSource=
      [0,withCredentials,eventSource,eventSource_options,addEventListener];
    caml_register_global
     (1666,Js_of_ocaml_EventSource,"Js_of_ocaml__EventSource");
    var
     console=runtime.caml_js_get_console(0),
     Js_of_ocaml_Firebug=[0,console];
    caml_register_global(1667,Js_of_ocaml_Firebug,"Js_of_ocaml__Firebug");
    function empty_position_options(param){return {}}
    var
     x=Unsafe[1].navigator,
     geolocation=caml_call1(Optdef[5],x)?x.geolocation:x;
    function is_supported$2(param){return caml_call1(Optdef[5],geolocation)}
    var
     Js_of_ocaml_Geolocation=
      [0,empty_position_options,geolocation,is_supported$2];
    caml_register_global
     (1668,Js_of_ocaml_Geolocation,"Js_of_ocaml__Geolocation");
    function empty_intersection_observer_op(param){return {}}
    var intersectionObserver_unsafe=Unsafe[1].IntersectionObserver;
    function is_supported$3(param)
     {return caml_call1(Optdef[5],intersectionObserver_unsafe)}
    var
     Js_of_ocaml_IntersectionObserv=
      [0,
       empty_intersection_observer_op,
       is_supported$3,
       intersectionObserver_unsafe];
    caml_register_global
     (1669,Js_of_ocaml_IntersectionObserv,"Js_of_ocaml__IntersectionObserver");
    function object_options(param){return {"localeMatcher":"best fit"}}
    function options(param)
     {return {"localeMatcher":"best fit",
              "usage":"sort",
              "sensitivity":"variant",
              "ignorePunctuation":t4,
              "numeric":t4,
              "caseFirst":"false"}}
    var Collator=[0,object_options,options];
    function options$0(param)
     {return {"localeMatcher":"best fit",
              "timeZone":t39,
              "hour12":t39,
              "hourCycle":t39,
              "formatMatcher":"best fit",
              "weekday":t39,
              "era":t39,
              "year":t39,
              "month":t39,
              "day":t39,
              "hour":t39,
              "minute":t39,
              "second":t39,
              "timeZoneName":t39}}
    var DateTimeFormat=[0,object_options,options$0];
    function options$1(param)
     {return {"localeMatcher":"best fit",
              "style":"decimal",
              "currency":t39,
              "currencyDisplay":t39,
              "useGrouping":t25,
              "minimumIntegerDigits":t39,
              "minimumFractionDigits":t39,
              "maximumFractionDigits":t39,
              "minimumSignificantDigits":t39,
              "maximumSignificantDigits":t39}}
    var NumberFormat=[0,object_options,options$1];
    function options$2(param)
     {return {"localeMatcher":"best fit","type":"cardinal"}}
    var
     PluralRules=[0,object_options,options$2],
     intl=Unsafe[1].Intl,
     collator_constr=Unsafe[1].Intl.Collator,
     dateTimeFormat_constr=Unsafe[1].Intl.DateTimeFormat,
     numberFormat_constr=Unsafe[1].Intl.NumberFormat,
     pluralRules_constr=Unsafe[1].Intl.PluralRules;
    function is_supported$4(param){return caml_call1(Optdef[5],intl)}
    var
     Js_of_ocaml_Intl=
      [0,
       Collator,
       DateTimeFormat,
       NumberFormat,
       PluralRules,
       intl,
       collator_constr,
       dateTimeFormat_constr,
       numberFormat_constr,
       pluralRules_constr,
       is_supported$4];
    caml_register_global(1670,Js_of_ocaml_Intl,"Js_of_ocaml__Intl");
    var Js_of_ocaml$0=[0];
    caml_register_global(1671,Js_of_ocaml$0,"Js_of_ocaml");
    return}
  (function(){return this}()));


//# 1 ".ace_js.eobjs/byte/dune__exe__Ace_js.cmo.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_string_of_jsbytes=runtime.caml_string_of_jsbytes,
     caml_string_of_jsstring=runtime.caml_string_of_jsstring,
     caml_wrap_exception=runtime.caml_wrap_exception;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5
              ?f(a0,a1,a2,a3,a4)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4])}
    var
     global_data=runtime.caml_get_global_data(),
     cst_compute=caml_string_of_jsbytes("compute"),
     cst_click=caml_string_of_jsbytes("click"),
     cst_main=caml_string_of_jsbytes("main"),
     cst_secondary=caml_string_of_jsbytes("secondary"),
     cst_output=caml_string_of_jsbytes("output"),
     cst_lang=caml_string_of_jsbytes("lang"),
     cst=caml_string_of_jsbytes(""),
     cst$0=caml_string_of_jsbytes("\n=====\n"),
     cst_exit=caml_string_of_jsbytes("exit"),
     cst_Invalid_headers=caml_string_of_jsbytes("Invalid headers."),
     cst_load=caml_string_of_jsbytes("load"),
     Js_of_ocaml_Dom_html=global_data.Js_of_ocaml__Dom_html,
     Stdlib_option=global_data.Stdlib__option,
     Js_of_ocaml_Js=global_data.Js_of_ocaml__Js,
     Stdlib=global_data.Stdlib,
     Settings=global_data.Settings,
     Stdlib_buffer=global_data.Stdlib__buffer,
     Stdlib_format=global_data.Stdlib__format,
     Fs=global_data.Fs,
     Preprocess=global_data.Preprocess,
     Exit=global_data.Exit,
     Ace_common=global_data.Ace_common,
     Stdlib_printexc=global_data.Stdlib__printexc;
    function treat_input(lang,str)
     {caml_call1(Settings[3],lang);
      var
       buffer=caml_call1(Stdlib_buffer[1],1000),
       fmt=caml_call1(Stdlib_format[109],buffer);
      try
       {var
         fs=caml_call1(Fs[1],str),
         match=caml_call1(Fs[3],fs),
         program=match[2],
         headers=match[1],
         env=caml_call2(Preprocess[5],fmt,headers),
         match$0=caml_call2(Preprocess[2],headers,cst_exit);
        if(typeof match$0 === "number")
         var headers2=0,exit=0;
        else
         if(0 === match$0[0])
          var
           fn=match$0[1],
           match$1=caml_call2(Fs[4],fn,fs),
           ast=match$1[2],
           headers$0=match$1[1],
           exit$0=caml_call3(Exit[3],fmt,env,[0,headers$0,ast]),
           headers2=headers$0,
           exit=[0,exit$0];
         else
          var
           _l_=caml_call1(Stdlib[2],cst_Invalid_headers),
           headers2=_l_[2],
           exit=_l_[1];
        caml_call5(Ace_common[2],fmt,env,[0,headers,headers2],program,exit)}
      catch(e)
       {e = caml_wrap_exception(e);
        var _k_=caml_call1(Stdlib_printexc[1],e);
        caml_call2(Stdlib_buffer[14],buffer,_k_)}
      caml_call2(Stdlib_format[36],fmt,0);
      return caml_call1(Stdlib_buffer[2],buffer)}
    function is_blank_str(s)
     {var i$1=runtime.caml_ml_string_length(s) - 1 | 0,i=i$1;
      for(;;)
       {if(0 <= i)
         {var c=runtime.caml_string_get(s,i);
          if(32 !== c && 9 !== c && 10 !== c && 13 !== c)return 0;
          var i$0=i - 1 | 0,i=i$0;
          continue}
        return 1}}
    function compute(param)
     {var
       _f_=
        caml_call2
         (Js_of_ocaml_Dom_html[5],cst_main,Js_of_ocaml_Dom_html[117][55]),
       main_input=caml_call1(Stdlib_option[4],_f_),
       _g_=
        caml_call2
         (Js_of_ocaml_Dom_html[5],cst_secondary,Js_of_ocaml_Dom_html[117][55]),
       secondary_input=caml_call1(Stdlib_option[4],_g_),
       _h_=
        caml_call2
         (Js_of_ocaml_Dom_html[5],cst_output,Js_of_ocaml_Dom_html[117][55]),
       output=caml_call1(Stdlib_option[4],_h_),
       _i_=
        caml_call2
         (Js_of_ocaml_Dom_html[5],cst_lang,Js_of_ocaml_Dom_html[117][50]),
       lang=caml_call1(Stdlib_option[4],_i_),
       main_input$0=caml_string_of_jsstring(main_input.value),
       secondary_input$0=caml_string_of_jsstring(secondary_input.value),
       _j_=
        is_blank_str(secondary_input$0)
         ?cst
         :caml_call2(Stdlib[28],cst$0,secondary_input$0),
       input=caml_call2(Stdlib[28],main_input$0,_j_),
       lang$0=caml_string_of_jsstring(lang.value),
       res=treat_input(lang$0,input);
      output.value = runtime.caml_jsstring_of_string(res);
      return Js_of_ocaml_Js[7]}
    function init(param)
     {var
       _c_=
        caml_call2
         (Js_of_ocaml_Dom_html[5],cst_compute,Js_of_ocaml_Dom_html[117][9]),
       compute_button=caml_call1(Stdlib_option[4],_c_),
       _d_=caml_call1(Js_of_ocaml_Dom_html[10],compute),
       _e_=caml_call1(Js_of_ocaml_Dom_html[15][86],cst_click);
      caml_call4(Js_of_ocaml_Dom_html[17],compute_button,_e_,_d_,! ! 0);
      return Js_of_ocaml_Js[8]}
    var
     _a_=caml_call1(Js_of_ocaml_Dom_html[10],init),
     _b_=caml_call1(Js_of_ocaml_Dom_html[15][86],cst_load);
    caml_call4(Js_of_ocaml_Dom_html[17],Js_of_ocaml_Dom_html[8],_b_,_a_,! ! 0);
    var Dune_exe_Ace_js=[0,treat_input,is_blank_str,compute,init];
    runtime.caml_register_global(27,Dune_exe_Ace_js,"Dune__exe__Ace_js");
    return}
  (function(){return this}()));


//# 1 ".js/stdlib/std_exit.cmo.js"
(function(joo_global_object)
   {"use strict";
    var runtime=joo_global_object.jsoo_runtime;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    var global_data=runtime.caml_get_global_data(),Stdlib=global_data.Stdlib;
    caml_call1(Stdlib[103],0);
    var Std_exit=[0];
    runtime.caml_register_global(1,Std_exit,"Std_exit");
    return}
  (function(){return this}()));


//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJhY2VfanMuYmMuanMiLCJzb3VyY2VSb290IjoiIiwibmFtZXMiOlsiY2FtbF9pbnQ2NF9pc196ZXJvIiwieCIsImNhbWxfc3RyX3JlcGVhdCIsIm4iLCJzIiwiciIsImwiLCJjYW1sX2ludDY0X29mZnNldCIsIk1hdGgiLCJjYW1sX3JhaXNlX2NvbnN0YW50IiwidGFnIiwiY2FtbF9nbG9iYWxfZGF0YSIsImNhbWxfcmFpc2VfemVyb19kaXZpZGUiLCJNbEludDY0IiwibG8iLCJtaSIsImhpIiwidGhpcyIsInhoaSIsImgiLCJzaWduIiwib2Zmc2V0IiwibW9kdWx1cyIsImRpdmlzb3IiLCJxdW90aWVudCIsInkiLCJxIiwiY2FtbF9pbnQ2NF9vZl9pbnQzMiIsImNhbWxfaW50NjRfdG9faW50MzIiLCJjYW1sX2ludDY0X2lzX25lZ2F0aXZlIiwiY2FtbF9pbnQ2NF9uZWciLCJjYW1sX3N1YmFycmF5X3RvX2pzYnl0ZXMiLCJhIiwiaSIsImxlbiIsImYiLCJTdHJpbmciLCJudWxsIiwiY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyIsImNhbWxfanNieXRlc19vZl9zdHJpbmciLCJjYW1sX3JhaXNlX3dpdGhfYXJnIiwiYXJnIiwianNvb19pc19hc2NpaSIsImNhbWxfdXRmMTZfb2ZfdXRmOCIsImIiLCJ0IiwiYyIsImMxIiwiYzIiLCJ2IiwiaiIsIk1sQnl0ZXMiLCJjb250ZW50cyIsImxlbmd0aCIsImNvbnRlbnQiLCJjYW1sX2J5dGVzX29mX2pzYnl0ZXMiLCJjYW1sX3N0cmluZ19vZl9qc2J5dGVzIiwiY2FtbF9yYWlzZV93aXRoX3N0cmluZyIsIm1zZyIsImNhbWxfaW52YWxpZF9hcmd1bWVudCIsImNhbWxfcGFyc2VfZm9ybWF0IiwiZm10IiwiY2FtbF9maW5pc2hfZm9ybWF0dGluZyIsInJhd2J1ZmZlciIsImJ1ZmZlciIsImNhbWxfaW50NjRfZm9ybWF0Iiwid2Jhc2UiLCJjdnRibCIsInAiLCJjYW1sX2V4cG0xX2Zsb2F0IiwieiIsImNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nIiwiam9vX2dsb2JhbF9vYmplY3QiLCJjYW1sX2N1cnJlbnRfZGlyIiwiY2FtbF9tYWtlX3BhdGgiLCJuYW1lIiwiY29tcCIsIm5jb21wIiwiY2FtbF9pc19tbF9ieXRlcyIsImNhbWxfaXNfbWxfc3RyaW5nIiwiY2FtbF9ieXRlc19vZl9hcnJheSIsImNhbWxfYnl0ZXNfb2Zfc3RyaW5nIiwiY2FtbF91dGY4X29mX3V0ZjE2IiwiZCIsImNhbWxfYnl0ZXNfb2ZfdXRmMTZfanNzdHJpbmciLCJjYW1sX3N0cmluZ19vZl9qc3N0cmluZyIsImNhbWxfcmFpc2Vfc3lzX2Vycm9yIiwiY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUiLCJjYW1sX2J5dGVzX2JvdW5kX2Vycm9yIiwiY2FtbF9ieXRlc191bnNhZmVfZ2V0IiwiY2FtbF9ieXRlc19nZXQiLCJjYW1sX2NyZWF0ZV9ieXRlcyIsImNhbWxfbWxfYnl0ZXNfbGVuZ3RoIiwiY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5IiwiQXJyYXkiLCJjYW1sX2JsaXRfYnl0ZXMiLCJzMSIsImkxIiwiczIiLCJpMiIsImNhbWxfYmxpdF9zdHJpbmciLCJlIiwiTWxGaWxlIiwiTWxGYWtlRmlsZSIsIm9sZCIsImJ1ZiIsInBvcyIsImNsZW4iLCJuZXdfc3RyIiwib2xkX2RhdGEiLCJNbEZha2VEZXZpY2UiLCJyb290IiwicmVzIiwibmFtZV9zbGFzaCIsIlJlZ0V4cCIsInNlZW4iLCJtIiwib2siLCJmaWxlIiwiYnl0ZXMiLCJjYW1sX21sX3N0cmluZ19sZW5ndGgiLCJjYW1sX3N0cmluZ191bnNhZmVfZ2V0IiwiY2FtbF9hcnJheV9vZl9zdHJpbmciLCJjYW1sX2FycmF5X29mX2J5dGVzIiwiY2FtbF9ieXRlc191bnNhZmVfc2V0IiwiY2FtbF9ieXRlc19zZXQiLCJNbE5vZGVGaWxlIiwiZmQiLCJyZXF1aXJlIiwiZXJyIiwiYnVmX29mZnNldCIsIk1sTm9kZURldmljZSIsImNvbnN0cyIsImtleSIsIm8iLCJjYW1sX3Jvb3QiLCJmc19ub2RlX3N1cHBvcnRlZCIsImpzb29fbW91bnRfcG9pbnQiLCJyZXNvbHZlX2ZzX2RldmljZSIsInBhdGgiLCJjYW1sX3N5c19pc19kaXJlY3RvcnkiLCJjYW1sX3JhaXNlX25vdF9mb3VuZCIsImNhbWxfc3lzX2dldGVudiIsImciLCJ1bmRlZmluZWQiLCJzaGlmdF9yaWdodF9uYXQiLCJuYXQxIiwib2ZzMSIsImxlbjEiLCJuYXQyIiwib2ZzMiIsIm5iaXRzIiwid3JhcCIsImNhbWxfbmFtZWRfdmFsdWVzIiwiY2FtbF9uYW1lZF92YWx1ZSIsIm5tIiwiY2FtbF9ncl9zdGF0ZSIsImNhbWxfZ3Jfc3RhdGVfZ2V0IiwiY2FtbF9ncl9wb2ludF9jb2xvciIsImltIiwiTWxPYmplY3RUYWJsZSIsIk5haXZlTG9va3VwIiwib2JqcyIsImNhbWxfZmFpbHdpdGgiLCJjYW1sX3N5c19yZW5hbWUiLCJvX3Jvb3QiLCJuX3Jvb3QiLCJjYW1sX2xvZzEwX2Zsb2F0IiwiY2FtbF9ydW50aW1lX3dhcm5pbmdzIiwiY2FtbF9tbF9lbmFibGVfcnVudGltZV93YXJuaW5ncyIsImJvb2wiLCJjYW1sX2NsYXNzaWZ5X2Zsb2F0IiwiaXNGaW5pdGUiLCJpc05hTiIsImNhbWxfbWxfcmVmaWxsX2lucHV0IiwiY2hhbiIsInN0ciIsInN0cl9sZW4iLCJjYW1sX21sX2NoYW5uZWxzIiwiY2FtbF9tbF9tYXlfcmVmaWxsX2lucHV0IiwiY2hhbmlkIiwiY2FtbF9hcnJheV9ib3VuZF9lcnJvciIsImNhbWxfbWxfaW5wdXRfc2Nhbl9saW5lIiwiY2FtbF9nY19taW5vciIsImNhbWxfaW50NjRfb2ZfYnl0ZXMiLCJjYW1sX2JhX3VpbnQ4X2dldDY0IiwiYmEiLCJpMCIsIm9mcyIsImIxIiwiYjIiLCJiMyIsImI0IiwiYjUiLCJiNiIsImI3IiwiYjgiLCJjYW1sX2ludDY0X3RvX2J5dGVzIiwiY2FtbF9pbnQ2NF9tYXJzaGFsIiwid3JpdGVyIiwic2l6ZXMiLCJjYW1sX2JhX251bV9kaW1zIiwiY2FtbF9yZXR1cm5fZXhuX2NvbnN0YW50IiwiY2FtbF93cmFwX2V4Y2VwdGlvbiIsImNhbWxfY3JlYXRlX2ZpbGUiLCJjYW1sX2ZzX2luaXQiLCJ0bXAiLCJjYW1sX3NldF9wYXJzZXJfdHJhY2UiLCJjYW1sX2xpc3Rfb2ZfanNfYXJyYXkiLCJ1bml4X2dldHRpbWVvZmRheSIsIkRhdGUiLCJjYW1sX211bCIsImNhbWxfaGFzaF9taXhfaW50IiwibnVtX2RpZ2l0c19uYXQiLCJuYXQiLCJjYW1sX2hhc2hfbmF0IiwiY2FtbF9jYWxsX2dlbiIsImFyZ3MiLCJhcmdzTGVuIiwiZXh0cmFfYXJncyIsImFyZ3VtZW50cyIsIm5hcmdzIiwiY2FtbF9qc193cmFwX2NhbGxiYWNrX2FyZ3VtZW50cyIsImNhbWxfc3lzX2NoZGlyIiwiZGlyIiwiY2FtbF9nY19jb3VudGVycyIsImNhbWxfZ3Jfc3luY2hyb25pemUiLCJsb2cyX29rIiwianNvb19mbG9vcl9sb2cyIiwiSW5maW5pdHkiLCJjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXQiLCJmbG9hdDMyYSIsImludDMyYSIsImNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpIiwiY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0IiwiZXhwIiwiayIsInIzIiwicjIiLCJyMSIsImNhbWxfYmFfc2VyaWFsaXplIiwic3oiLCJjb21wbGV4IiwiY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudCIsImtpbmQiLCJjYW1sX2JhX2NyZWF0ZV9idWZmZXIiLCJzaXplIiwidmlldyIsImRhdGEiLCJjYW1sX2ludDMyX2Zsb2F0X29mX2JpdHMiLCJjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMiLCJOYU4iLCJjYW1sX2JhX2dldF9zaXplIiwiZGltcyIsIm5fZGltcyIsImNhbWxfaW50NjRfY3JlYXRlX2xvX2hpIiwiY2FtbF9pbnQ2NF9oaTMyIiwiY2FtbF9pbnQ2NF9sbzMyIiwiY2FtbF9iYV9jdXN0b21fbmFtZSIsIk1sX0JpZ2FycmF5IiwibGF5b3V0IiwicmUiLCJ0b3RhbCIsImsxIiwiazIiLCJNbF9CaWdhcnJheV9jXzFfMSIsImNhbWxfYmFfY3JlYXRlX3Vuc2FmZSIsInNpemVfcGVyX2VsZW1lbnQiLCJjYW1sX2JhX2Rlc2VyaWFsaXplIiwicmVhZGVyIiwibnVtX2RpbXMiLCJzaXplX2RpbSIsInNpemVfZGltX2hpIiwic2l6ZV9kaW1fbG8iLCJzaXh0eSIsImludDY0IiwiY2FtbF9iYV9jb21wYXJlIiwiY2FtbF9oYXNoX21peF9pbnQ2NCIsImNhbWxfaGFzaF9taXhfZmxvYXQiLCJ2MCIsImNhbWxfYmFfaGFzaCIsIm51bV9lbHRzIiwidyIsImNhbWxfaW50MzJfdW5tYXJzaGFsIiwiY2FtbF9uYXRpdmVpbnRfdW5tYXJzaGFsIiwiY2FtbF9pbnQ2NF91bm1hcnNoYWwiLCJjYW1sX2ludDY0X2NvbXBhcmUiLCJjYW1sX2ludDY0X2hhc2giLCJjYW1sX2N1c3RvbV9vcHMiLCJjYW1sX2NvbXBhcmVfdmFsX2dldF9jdXN0b20iLCJjYW1sX2NvbXBhcmVfdmFsX251bWJlcl9jdXN0b20iLCJudW0iLCJjdXN0b20iLCJzd2FwIiwiY2FtbF9jb21wYXJlX3ZhbF90YWciLCJOdW1iZXIiLCJjYW1sX2ludF9jb21wYXJlIiwiY2FtbF9ieXRlc19jb21wYXJlIiwiY2FtbF9zdHJpbmdfY29tcGFyZSIsImNhbWxfY29tcGFyZV92YWwiLCJzdGFjayIsInRhZ19hIiwidGFnX2IiLCJjYW1sX2dyZWF0ZXJ0aGFuIiwiZGl2X2hlbHBlciIsImRpdl9kaWdpdF9uYXQiLCJuYXRxIiwib2ZzcSIsIm5hdHIiLCJvZnNyIiwicmVtIiwibnVtX2xlYWRpbmdfemVyb19iaXRzX2luX2RpZ2l0Iiwic2hpZnRfbGVmdF9uYXQiLCJNbE5hdCIsImNyZWF0ZV9uYXQiLCJhcnIiLCJzZXRfdG9femVyb19uYXQiLCJpbmNyX25hdCIsImNhcnJ5X2luIiwiY2FycnkiLCJhZGRfbmF0IiwibGVuMiIsIm5hdF9vZl9hcnJheSIsIm11bHRfZGlnaXRfbmF0IiwibmF0MyIsIm9mczMiLCJ4MSIsIngyIiwieDMiLCJkZWNyX25hdCIsImJvcnJvdyIsInN1Yl9uYXQiLCJjb21wYXJlX25hdCIsImRpdl9uYXQiLCJxdW8iLCJjYW1sX2JhX2JsaXQiLCJzcmMiLCJkc3QiLCJpc19kaWdpdF9pbnQiLCJjYW1sX2ludDY0X2RpdiIsImNhbWxfanNfaHRtbF9lbnRpdGllcyIsImVudGl0eSIsInRlbXAiLCJkb2N1bWVudCIsImNhbWxfc3RyaW5nX3Vuc2FmZV9zZXQiLCJjYW1sX2ludDY0X29mX2Zsb2F0IiwiY2FtbF9tbF9jaGFubmVsX3NpemVfNjQiLCJjYW1sX2JhX3NldF8yIiwiY2FtbF9hcmd2IiwibWFpbiIsImFyZ3YiLCJhcmdzMiIsImNhbWxfZXhlY3V0YWJsZV9uYW1lIiwiY2FtbF9qc19ldmFsX3N0cmluZyIsImV2YWwiLCJjYW1sX0NhbWxpbnRlcm5hbE1vZF9pbml0X21vZCIsImxvYyIsInNoYXBlIiwidW5kZWZfbW9kdWxlIiwiX3giLCJsb29wIiwic3RydWN0IiwiaWR4Iiwic2VyaWFsaXplX25hdCIsImNhbWxfbWVtcHJvZl9zZXQiLCJfY29udHJvbCIsImNhbWxfc3lzX2V4aXQiLCJjb2RlIiwiY2FtbF9jaGFubmVsX2Rlc2NyaXB0b3IiLCJjYW1sX2pzX2Zyb21fYXJyYXkiLCJjYW1sX2JhX3Jlc2hhcGUiLCJ2aW5kIiwibmV3X2RpbSIsImNhbWxfb29fbGFzdF9pZCIsImNhbWxfc2V0X29vX2lkIiwiY2FtbF9ncl9maWxsX3JlY3QiLCJjYW1sX2JpZ3N0cmluZ19ibGl0X3N0cmluZ190b19iYSIsInN0cjEiLCJwb3MxIiwiYmEyIiwicG9zMiIsInNsaWNlIiwiY2FtbF9ncl9zZXRfd2luZG93X3RpdGxlIiwianNuYW1lIiwiY2FtbF9nZXRfZ2xvYmFsX2RhdGEiLCJjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0X3Vuc2lnbmVkIiwiY2FtbF9iYV91aW50OF9nZXQxNiIsImNhbWxfY29tcGFyZSIsImNhbWxfZnJlc2hfb29faWQiLCJjYW1sX2ludDY0X3RvX2Zsb2F0IiwiY2FtbF9iYV9nZXRfMSIsImNhbWxfYmlnc3RyaW5nX21lbWNtcCIsImNhbWxfbmV3X3N0cmluZyIsImNhbWxfYmFfdWludDhfZ2V0MzIiLCJjYW1sX3Jhd19iYWNrdHJhY2VfbGVuZ3RoIiwiY2FtbF9vYmpfYmxvY2siLCJjYW1sX2dyX2NsZWFyX2dyYXBoIiwiYmlnc3RyaW5nX3RvX2FycmF5X2J1ZmZlciIsImJzIiwiY2FtbF9zeXNfY29uc3RfbmFrZWRfcG9pbnRlcnNfY2hlY2tlZCIsIl91bml0IiwibHhvcl9kaWdpdF9uYXQiLCJjYW1sX2ZpbmFsX3JlbGVhc2UiLCJjYW1sX2pzX3RvX2FycmF5IiwiY2FtbF9ncl9wbG90IiwiY29sb3IiLCJjYW1sX2J5dGVzX3NldDY0IiwiaTY0IiwiY2FtbF9ieXRlc19zZXQxNiIsImkxNiIsImNhbWxfc3RyaW5nX3NldDE2IiwiY2FtbF9pbnQ2NF9ic3dhcCIsImNhbWxfZmlsbF9ieXRlcyIsImNhbWxfZmlsbF9zdHJpbmciLCJjYW1sX2djX21ham9yIiwiY2FtbF9sZXhfYXJyYXkiLCJjYW1sX2xleF9lbmdpbmUiLCJ0YmwiLCJzdGFydF9zdGF0ZSIsImxleGJ1ZiIsImxleF9idWZmZXIiLCJsZXhfYnVmZmVyX2xlbiIsImxleF9zdGFydF9wb3MiLCJsZXhfY3Vycl9wb3MiLCJsZXhfbGFzdF9wb3MiLCJsZXhfbGFzdF9hY3Rpb24iLCJsZXhfZW9mX3JlYWNoZWQiLCJsZXhfYmFzZSIsImxleF9iYWNrdHJrIiwibGV4X2RlZmF1bHQiLCJsZXhfdHJhbnMiLCJsZXhfY2hlY2siLCJzdGF0ZSIsImJhc2UiLCJiYWNrdHJrIiwiY2FtbF9zeXNfZmlsZV9leGlzdHMiLCJjYW1sX2NvbnZlcnRfcmF3X2JhY2t0cmFjZV9zbG90IiwiY2FtbF9hcnJheV9zdWIiLCJhMiIsImNhbWxfYnl0ZXNfZXF1YWwiLCJjYW1sX2dyX3NpemVfeCIsImNhbWxfbWxfZGVidWdfaW5mb19zdGF0dXMiLCJjYW1sX3N5c19jb25zdF9vc3R5cGVfY3lnd2luIiwiY2FtbF9jb3NoX2Zsb2F0IiwiY2FtbF9lcGhlX2tleV9vZmZzZXQiLCJjYW1sX3dlYWtfY2hlY2siLCJjYW1sX2VwaGVfY2hlY2tfa2V5IiwiY2FtbF9oYXNoX21peF9maW5hbCIsImNhbWxfZ3JfdGV4dF9zaXplIiwidHh0IiwiY2FtbF9sZXhfcnVuX21lbSIsIm1lbSIsImN1cnJfcG9zIiwiY2FtbF9sZXhfcnVuX3RhZyIsImNhbWxfbmV3X2xleF9lbmdpbmUiLCJsZXhfbWVtIiwibGV4X2Jhc2VfY29kZSIsImxleF9iYWNrdHJrX2NvZGUiLCJsZXhfZGVmYXVsdF9jb2RlIiwibGV4X3RyYW5zX2NvZGUiLCJsZXhfY2hlY2tfY29kZSIsImxleF9jb2RlIiwicGNfb2ZmIiwicHN0YXRlIiwiYmFzZV9jb2RlIiwiY2FtbF9iYV91aW50OF9zZXQ2NCIsImNhbWxfc3lzX2V4ZWN1dGFibGVfbmFtZSIsImNhbWxfbGVzc2VxdWFsIiwiY2FtbF9tbF9mbHVzaCIsIm91dHB1dCIsImNhbWxfbWxfc2Vla19vdXRfNjQiLCJjb21wYXJlX25hdF9yZWFsIiwiY2FtbF9nY19zZXQiLCJjYW1sX2pzX2dldCIsImNhbWxfZ2NfY29tcGFjdGlvbiIsImNhbWxfd2Vha19nZXQiLCJjYW1sX2VwaGVfZ2V0X2tleSIsImNhbWxfYmlnc3RyaW5nX2JsaXRfYnl0ZXNfdG9fYmEiLCJ3aW5fY2xlYW51cCIsImNhbWxfc3lzX2Nsb3NlIiwiY2FtbF9tbF9jbG9zZV9jaGFubmVsIiwiY2FtbF9leG5fd2l0aF9qc19iYWNrdHJhY2UiLCJleG4iLCJmb3JjZSIsImNhbWxfc3lzX2lzYXR0eSIsIl9jaGFuIiwiaXNfZGlnaXRfemVybyIsInVuaXhfaW5ldF9hZGRyX29mX3N0cmluZyIsImNhbWxfanNfc2V0IiwiY2FtbF9hcnJheV9nZXQiLCJhcnJheSIsImluZGV4IiwiY2FtbF9zcGFjZXRpbWVfb25seV93b3Jrc19mb3JfbmF0aXZlX2NvZGUiLCJjYW1sX2ludDY0X3N1YiIsImNhbWxfbWxfc2Vla19pbl82NCIsImNhbWxfaW50NjRfc2hpZnRfbGVmdCIsImNhbWxfbm90ZXF1YWwiLCJjYW1sX3N5c19jb25zdF9pbnRfc2l6ZSIsImNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrIiwiY2FtbF9pc19qcyIsImNhbWxfYmFfZGltIiwiY2FtbF9iYV9kaW1fMSIsInVuaXhfbG9jYWx0aW1lIiwiZF9udW0iLCJqYW51YXJ5Zmlyc3QiLCJkb3kiLCJqYW4iLCJqdWwiLCJzdGRUaW1lem9uZU9mZnNldCIsImNhbWxfanNfbWV0aF9jYWxsIiwiY2FtbF93ZWFrX2NyZWF0ZSIsImNhbWxfZXBoZV9jcmVhdGUiLCJjYW1sX2pzX3RvX2J5dGVfc3RyaW5nIiwidW5peF9ta3RpbWUiLCJ0bSIsInRtMiIsImNhbWxfdHJhbXBvbGluZSIsImNhbWxfYnl0ZXNfZ2V0NjQiLCJjYW1sX3dlYWtfc2V0IiwiY2FtbF9zeXNfcmVtb3ZlIiwiY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IiLCJjYW1sX3N0cmluZ19nZXQzMiIsImNhbWxfaHlwb3RfZmxvYXQiLCJjYW1sX2pzX2NhbGwiLCJjYW1sX3N5c19jb25zdF9tYXhfd29zaXplIiwiY2FtbF9lcGhlX3Vuc2V0X2tleSIsImNhbWxfaGFzaF9taXhfYnl0ZXNfYXJyIiwiY2FtbF9oYXNoX21peF9qc2J5dGVzIiwiY2FtbF9oYXNoX21peF9ieXRlcyIsImNhbWxfYnl0ZXNfbGVzc3RoYW4iLCJjYW1sX2dyX2ZpbGxfcG9seSIsImFyIiwiY2FtbF9nY19xdWlja19zdGF0IiwiY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZSIsImNhbWxfbWxfaW5wdXRfaW50IiwiY2FtbF9ncl9kaXNwbGF5X21vZGUiLCJudGhfZGlnaXRfbmF0IiwiY2FtbF9hcnJheV9ibGl0IiwiYTEiLCJjYW1sX2Zsb2F0X29mX3N0cmluZyIsIm0zIiwibWFudGlzc2EiLCJwYXJzZUludCIsImV4cG9uZW50IiwiY2FtbF9zeXNfZ2V0Y3dkIiwiY2FtbF9zeXNfY29uc3RfYmlnX2VuZGlhbiIsImNhbWxfbGlzdF90b19qc19hcnJheSIsImNhbWxfbGVnYWN5X2N1c3RvbV9jb2RlIiwiY2FtbF9vdXRwdXRfdmFsIiwiV3JpdGVyIiwidmFsdWUiLCJmbGFncyIsIm5vX3NoYXJpbmciLCJjbG9zdXJlcyIsImludGVybl9vYmpfdGFibGUiLCJtZW1vIiwiZXhpc3Rpbmdfb2Zmc2V0IiwiZXh0ZXJuX3JlYyIsIm9wcyIsInN6XzMyXzY0IiwiaGVhZGVyX3BvcyIsIm9sZF9wb3MiLCJ0eXBlX29mX3YiLCJjYW1sX3N0cmluZ19vZl9hcnJheSIsImNhbWxfb3V0cHV0X3ZhbHVlX3RvX3N0cmluZyIsImNhbWxfcmFpc2Vfbm90X2FfZGlyIiwiY2FtbF9zeXNfc3lzdGVtX2NvbW1hbmQiLCJjbWQiLCJ1bml4X2lzYXR0eSIsImZpbGVEZXNjcmlwdG9yIiwidHR5IiwiY2FtbF9qc19lcnJvcl9vZl9leGNlcHRpb24iLCJkZXNlcmlhbGl6ZV9uYXQiLCJpbml0aWFsaXplX25hdCIsImNhbWxfZ3Jfb3Blbl9zdWJ3aW5kb3ciLCJqc19wcmludF9zdGRvdXQiLCJjYW1sX2NvcHlzaWduX2Zsb2F0IiwiY2FtbF9ncl9zZXRfdGV4dF9zaXplIiwiY2FtbF9tZDVfYnl0ZXMiLCJhZGQiLCJ4eCIsImZmIiwiZ2ciLCJoaCIsImlpIiwibWQ1IiwiY2FtbF9iYV9zZXRfZ2VuZXJpYyIsImNhbWxfZXBoZV9zZXRfa2V5IiwiY2FtbF9ieXRlc19sZXNzZXF1YWwiLCJjYW1sX3N0cmluZ19sZXNzZXF1YWwiLCJjYW1sX3N0cmluZ19ncmVhdGVyZXF1YWwiLCJjYW1sX2ludDY0X2FkZCIsImNhbWxfbmV4dGFmdGVyX2Zsb2F0IiwiYml0cyIsIm9uZSIsImNhbWxfZ3Jfc2l6ZV95IiwiY2FtbF9tbF9wb3NfaW4iLCJjYW1sX2ludDY0X2FuZCIsImNhbWxfc3lzX2NvbnN0X3dvcmRfc2l6ZSIsImNhbWxfc3RkX291dHB1dCIsInNsZW4iLCJqc19wcmludF9zdGRlcnIiLCJjYW1sX3N5c19vcGVuX2ludGVybmFsIiwiaW5mbyIsImNhbWxfc3lzX29wZW4iLCJfcGVybXMiLCJNbFN0cmluZ1JlYWRlciIsImNhbWxfZmxvYXRfb2ZfYnl0ZXMiLCJjYW1sX2lucHV0X3ZhbHVlX2Zyb21fcmVhZGVyIiwiX21hZ2ljIiwiX2Jsb2NrX2xlbiIsIm51bV9vYmplY3RzIiwiX3NpemVfMzIiLCJfc2l6ZV82NCIsIm9ial9jb3VudGVyIiwiaW50ZXJuX3JlYyIsImhlYWRlciIsImV4cGVjdGVkX3NpemUiLCJjYW1sX3N0cmluZ19vZl9ieXRlcyIsImNhbWxfaW5wdXRfdmFsdWVfZnJvbV9ieXRlcyIsImNhbWxfc3RyaW5nX2dldCIsInJlX21hdGNoIiwicmVfd29yZF9sZXR0ZXJzIiwib3Bjb2RlcyIsImlzX3dvcmRfbGV0dGVyIiwiaW5fYml0c2V0IiwicmVfbWF0Y2hfaW1wbCIsInBhcnRpYWwiLCJwcm9nIiwiY3Bvb2wiLCJub3JtdGFibGUiLCJudW1ncm91cHMiLCJudW1yZWdpc3RlcnMiLCJzdGFydGNoYXJzIiwicGMiLCJxdWl0IiwiZ3JvdXBzIiwicmVfcmVnaXN0ZXIiLCJiYWNrdHJhY2siLCJpdGVtIiwicHVzaCIsImFjY2VwdCIsInJlc3VsdCIsInByZWZpeF9tYXRjaCIsIm9wIiwic2FyZyIsInVhcmciLCJncm91cCIsIkVycm9yIiwicmVfc2VhcmNoX2JhY2t3YXJkIiwiY2FtbF9qc19mcm9tX3N0cmluZyIsImNhbWxfYmFfc3ViIiwiY2hhbmdlZF9kaW0iLCJtdWwiLCJuZXdfZGltcyIsIm5ld19kYXRhIiwiY2FtbF9nY19mdWxsX21ham9yIiwiY2FtbF9ieXRlc19zZXQzMiIsImkzMiIsImNhbWxfZ3Jfc2lnaW9fc2lnbmFsIiwiY2FtbF9iYV91aW50OF9zZXQzMiIsImNhbWxfc3lzX2NvbnN0X29zdHlwZV91bml4IiwiY2FtbF9zaWduYml0X2Zsb2F0IiwiY2FtbF9ncl9jdXJyZW50X3giLCJjYW1sX2dyX3NldF9saW5lX3dpZHRoIiwiY2FtbF9ncl9zZXRfZm9udCIsImNhbWxfZ3Jfc2V0X2NvbG9yIiwiY29udmVydCIsIm51bWJlciIsImNfc3RyIiwiY2FtbF9ncl9tb3ZldG8iLCJjYW1sX2dyX3Jlc2l6ZV93aW5kb3ciLCJjYW1sX2dyX3N0YXRlX2luaXQiLCJjYW1sX2JhX2tpbmRfb2ZfdHlwZWRfYXJyYXkiLCJ0YSIsImNhbWxfYmFfZnJvbV90eXBlZF9hcnJheSIsImNhbWxfbWxfc2Vla19vdXQiLCJjYW1sX2pzX3R5cGVvZiIsImNhbWxfcmVzdG9yZV9yYXdfYmFja3RyYWNlIiwiYnQiLCJjYW1sX2dyX2xpbmV0byIsImNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrX3Vuc2FmZSIsImNhbWxfYmFfZGltXzMiLCJjYW1sX2VwaGVfZGF0YV9vZmZzZXQiLCJjYW1sX2VwaGVfY2hlY2tfZGF0YSIsImNhbWxfYnl0ZXNfZ2V0MTYiLCJjYW1sX29ial9tYWtlX2ZvcndhcmQiLCJjYW1sX2pzX2Zyb21fYm9vbCIsImNhbWxfbWxfc2V0X2NoYW5uZWxfbmFtZSIsImNhbWxfZ3JfY2xvc2VfZ3JhcGgiLCJjYW1sX2NyZWF0ZV9zdHJpbmciLCJjYW1sX21kNV9zdHJpbmciLCJjYW1sX21kNV9jaGFuIiwiY2hhbl9sZW4iLCJjYW1sX29ial9kdXAiLCJjYW1sX3dlYWtfZ2V0X2NvcHkiLCJjYW1sX21sX291dHB1dF9ieXRlcyIsInN0cmluZyIsImpzc3RyaW5nIiwiaWQiLCJjYW1sX21sX291dHB1dCIsImNhbWxfZXBoZV9nZXRfZGF0YSIsImNhbWxfeG1saHR0cHJlcXVlc3RfY3JlYXRlIiwidW5pdCIsImNhbWxfdHJhbXBvbGluZV9yZXR1cm4iLCJjYW1sX2FycmF5X2FwcGVuZCIsImwxIiwibDIiLCJjYW1sX21sX3NldF9jaGFubmVsX3JlZmlsbCIsImNhbWxfanNfZXhwciIsImNhbWxfaW50NjRfbXVsIiwiY2FtbF9tbF9ydW50aW1lX3dhcm5pbmdzX2VuYWJsZWQiLCJjYW1sX291dHB1dF92YWx1ZV90b19ieXRlcyIsImNhbWxfaGFzaF91bml2X3BhcmFtIiwiY291bnQiLCJsaW1pdCIsIm9iaiIsImhhc2hfYWNjdSIsImhhc2hfYXV4IiwianNieXRlcyIsImNhbWxfc3RyaW5nX2VxdWFsIiwiY2FtbF9vdXRwdXRfdmFsdWVfdG9fYnVmZmVyIiwicmVfcmVwbGFjZW1lbnRfdGV4dCIsInJlcGwiLCJvcmlnIiwiY3VyIiwic3RhcnQiLCJlbmQiLCJjYW1sX3B1cmVfanNfZXhwciIsImJsaXRfbmF0IiwiY2FtbF9pbnQ2NF91bHQiLCJjYW1sX2ludDY0X3hvciIsImNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYnl0ZXMiLCJiYTEiLCJieXRlczIiLCJjYW1sX3JlZ2lzdGVyX25hbWVkX3ZhbHVlIiwiY2FtbF90b19qc19zdHJpbmciLCJjYW1sX3BhcnNlX3NpZ25fYW5kX2Jhc2UiLCJjYW1sX3BhcnNlX2RpZ2l0IiwiY2FtbF9pbnQ2NF9vZl9zdHJpbmciLCJiYXNlNjQiLCJ0aHJlc2hvbGQiLCJyZV9zZWFyY2hfZm9yd2FyZCIsImNhbWxfYmxpdF9zdHJpbmdfdG9fYmlnc3RyaW5nIiwiY2FtbF9tYWtlX3ZlY3QiLCJpbml0IiwiY2FtbF9tbF9zZWVrX2luIiwiY2FtbF9zeXNfcmVhZF9kaXJlY3RvcnkiLCJjYW1sX21sX291dHB1dF9jaGFyIiwiY2FtbF9zeXNfY29uc3Rfb3N0eXBlX3dpbjMyIiwiY2FtbF9vYmpfaXNfYmxvY2siLCJjYW1sX21sX2lucHV0X2NoYXIiLCJjYW1sX29ial9zZXRfcmF3X2ZpZWxkIiwiY2FtbF9qc192YXIiLCJjYW1sX3RydW5jX2Zsb2F0IiwiY2FtbF9lcGhlX2JsaXRfZGF0YSIsImNhbWxfaXNfcHJpbnRhYmxlIiwiY2FtbF9lcXVhbCIsInJlX3BhcnRpYWxfbWF0Y2giLCJjYW1sX3N5c19yYW5kb21fc2VlZCIsIm5vdyIsImNhbWxfZmluYWxfcmVnaXN0ZXJfY2FsbGVkX3dpdGhvdXRfdmFsdWUiLCJjYW1sX2JhX2dldF8yIiwid2luX2hhbmRsZV9mZCIsImNhbWxfYmFfdWludDhfc2V0MTYiLCJjYW1sX2pzX2RlbGV0ZSIsImNhbWxfaW50X29mX3N0cmluZyIsImNhbWxfbGlzdF9tb3VudF9wb2ludCIsInByZXYiLCJjYW1sX21hcnNoYWxfY29uc3RhbnRzIiwiY2FtbF9vYmpfcmF3X2ZpZWxkIiwiY2FtbF9qc19lcXVhbHMiLCJiaWdzdHJpbmdfdG9fdHlwZWRfYXJyYXkiLCJjYW1sX2dyX2FyY19hdXgiLCJjdHgiLCJjeCIsImN5IiwicnkiLCJyeCIsInJvdCIsInhQb3MiLCJ5UG9zIiwieFBvc19wcmV2IiwieVBvc19wcmV2Iiwic3BhY2UiLCJkZWx0YSIsImNhbWxfZ3JfZmlsbF9hcmMiLCJjYW1sX2JhX3NsaWNlIiwibnVtX2luZHMiLCJzdWJfZGltcyIsImNhbWxfbWFyc2hhbF9kYXRhX3NpemUiLCJnZXQzMiIsImNhbWxfaW5wdXRfdmFsdWUiLCJjYW1sX2JhX2tpbmQiLCJjYW1sX2pzX2Z1bl9jYWxsIiwiY2FtbF9qc19wdXJlX2V4cHIiLCJjb21wYXJlX2RpZ2l0c19uYXQiLCJjYW1sX21sX2lucHV0IiwiY2FtbF9ncl93YWl0X2V2ZW50IiwiX2V2bCIsImNhbWxfZ3Jfc2lnaW9faGFuZGxlciIsImNhbWxfaGFzaF9taXhfYmlnc3RyaW5nIiwiY2FtbF9yZWNvcmRfYmFja3RyYWNlIiwidW5peF9nbXRpbWUiLCJjYW1sX3N5c19nZXRfY29uZmlnIiwiY2FtbF9zeXNfY29uc3RfYmFja2VuZF90eXBlIiwidW5peF90aW1lIiwiY2FtbF9tbF9vdXRfY2hhbm5lbHNfbGlzdCIsImJpZ3N0cmluZ19vZl9hcnJheV9idWZmZXIiLCJhYiIsImNhbWxfbW9kIiwiY2FtbF9iYV9pbml0IiwicmVfc3RyaW5nX21hdGNoIiwiQmlnU3RyaW5nUmVhZGVyIiwiY2FtbF9ncl9kdW1wX2ltYWdlIiwiY2FtbF9iYV9nZXRfZ2VuZXJpYyIsImNhbWxfZ2V0X2V4Y2VwdGlvbl9iYWNrdHJhY2UiLCJjYW1sX2Zvcm1hdF9mbG9hdCIsInRvRml4ZWQiLCJkcCIsInByZWMiLCJjYW1sX21vdW50X2F1dG9sb2FkIiwiY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19iYSIsImNhbWxfYmxpdF9iaWdzdHJpbmdfdG9fYmlnc3RyaW5nIiwiY2FtbF9zdHJpbmdfbGVzc3RoYW4iLCJjYW1sX3N0cmluZ19ncmVhdGVydGhhbiIsImNhbWxfZGl2IiwiY2FtbF9lcGhlX2dldF9kYXRhX2NvcHkiLCJjYW1sX21lbXByb2Zfc3RhcnQiLCJyYXRlIiwic3RhY2tfc2l6ZSIsInRyYWNrZXIiLCJjYW1sX3N5c19nZXRfYXJndiIsImNhbWxfanNfdG9fYm9vbCIsImNhbWxfZ3JfY3JlYXRlX2ltYWdlIiwiY2FtbF9lcGhlX2dldF9rZXlfY29weSIsImNhbWxfbGVzc3RoYW4iLCJjYW1sX3Jhd19iYWNrdHJhY2VfbmV4dF9zbG90IiwiY2FtbF9yZWdpc3Rlcl9nbG9iYWwiLCJuYW1lX29wdCIsIm11bHRfbmF0IiwibGVuMyIsInNxdWFyZV9uYXQiLCJjYW1sX2pzX2Zyb21fZmxvYXQiLCJjYW1sX2Zsb2F0YXJyYXlfY3JlYXRlIiwiY2FtbF9nY19zdGF0IiwiY2FtbF9zeXNfbW9kaWZ5X2FyZ3YiLCJjYW1sX21ldGhvZF9jYWNoZSIsImNhbWxfZ2V0X3B1YmxpY19tZXRob2QiLCJjYWNoZWlkIiwibWV0aHMiLCJsaSIsImNhbWxfanNfZ2V0X2NvbnNvbGUiLCJjYW1sX3N5c191bnNhZmVfZ2V0ZW52IiwiY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3JfaW4iLCJjaGFubmVsIiwiYmlnc3RyaW5nX29mX3R5cGVkX2FycmF5IiwiY2FtbF9yb3VuZF9mbG9hdCIsImNhbWxfb2pzX25ld19hcnIiLCJGIiwiY29tcGxlbWVudF9uYXQiLCJjYW1sX2pzX3JlZ2V4cHMiLCJjYW1sX2pzX2h0bWxfZXNjYXBlIiwiY2FtbF9iYV9kaW1fMiIsImNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrX2FyZ3VtZW50cyIsImNhbWxfc2luaF9mbG9hdCIsImNhbWxfbGRleHBfZmxvYXQiLCJjYW1sX2dyX3N0YXRlX3NldCIsImNhbWxfanNfd3JhcF9jYWxsYmFja19zdHJpY3QiLCJhcml0eSIsImNhbWxfYmFfc2V0XzEiLCJjYW1sX2dldF9jdXJyZW50X2NhbGxzdGFjayIsImxhbmRfZGlnaXRfbmF0IiwiY2FtbF9pbnQ2NF9tb2QiLCJjYW1sX29ial9zZXRfdGFnIiwiY2FtbF9jcmVhdGVfZmlsZV9leHRlcm4iLCJjYW1sX2ludDMyX2Jzd2FwIiwid2luX3N0YXJ0dXAiLCJjYW1sX2JhX3NldF8zIiwiY2FtbF9qc19pbnN0YW5jZW9mIiwiY2FtbF9ibGl0X2JpZ3N0cmluZ190b19zdHJpbmciLCJudGhfZGlnaXRfbmF0X25hdGl2ZSIsInNldF9kaWdpdF9uYXRfbmF0aXZlIiwiZGlnaXQiLCJjYW1sX3N0cmluZ19zZXQ2NCIsImNhbWxfZ3Jfc3RhdGVfY3JlYXRlIiwiY2FudmFzIiwiY29udGV4dCIsImNhbWxfanNfd3JhcF9jYWxsYmFjayIsImNhbWxfZ3JfZHJhd19hcmMiLCJjYW1sX2JhX21hcF9maWxlIiwidmZkIiwic2hhcmVkIiwiY2FtbF9iYV9tYXBfZmlsZV9ieXRlY29kZSIsImFyZ24iLCJjYW1sX2JhX2NyZWF0ZV9mcm9tIiwiZGF0YTEiLCJkYXRhMiIsImpzdHlwIiwiY2FtbF90YW5oX2Zsb2F0IiwiY2FtbF9ncl9kcmF3X3N0ciIsImR4IiwiY2FtbF9ncl9kcmF3X3N0cmluZyIsImNhbWxfZ3JfZHJhd19jaGFyIiwiY2FtbF91bm1vdW50IiwiY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3N0cmluZyIsImNhbWxfbWxfcG9zX2luXzY0IiwiY2FtbF9ncl9kcmF3X2ltYWdlIiwiaW1hZ2UiLCJjYW1sX3JlZ2lzdGVyX2NoYW5uZWxfZm9yX3NwYWNldGltZSIsIl9jaGFubmVsIiwiY2FtbF9zdHJpbmdfc2V0IiwiY2FtbF9tbF9wb3Nfb3V0IiwiY2FtbF9zcGFjZXRpbWVfZW5hYmxlZCIsImNhbWxfYnl0ZXNfbm90ZXF1YWwiLCJjYW1sX3J1bnRpbWVfcGFyYW1ldGVycyIsImNhbWxfanNfb2JqZWN0IiwiY2FtbF9iYV9jcmVhdGUiLCJkaW1zX21sIiwiY2FtbF93ZWFrX2JsaXQiLCJjYW1sX2dyX3JlbWVtYmVyX21vZGUiLCJjYW1sX2Jzd2FwMTYiLCJjYW1sX21sX3NldF9iaW5hcnlfbW9kZSIsIm1vZGUiLCJjYW1sX2ZpbmFsX3JlZ2lzdGVyIiwiY2FtbF9ncl9kcmF3X3JlY3QiLCJjYW1sX3N0cmluZ19nZXQxNiIsImNhbWxfZXBoZV91bnNldF9kYXRhIiwiY2FtbF9vdXRwdXRfdmFsdWUiLCJjYW1sX2JhX2dldF8zIiwiY2FtbF9lcGhlX2JsaXRfa2V5IiwiY2FtbF9pbml0aWFsX3RpbWUiLCJjYW1sX3N5c190aW1lIiwiY2FtbF9zeXNfdGltZV9pbmNsdWRlX2NoaWxkcmVuIiwiY2FtbF9jaGVja19ib3VuZCIsImNhbWxfaGFzaF9taXhfc3RyaW5nIiwiY2FtbF9oYXNoIiwic2VlZCIsInF1ZXVlIiwicmQiLCJ3ciIsImNhbWxfb2JqX3RhZyIsIkZ1bmN0aW9uIiwiY2FtbF9iYV90b190eXBlZF9hcnJheSIsImNhbWxfanNfZXhwb3J0X3ZhciIsIm1vZHVsZSIsImNhbWxfYnl0ZXNfZ2V0MzIiLCJjYW1sX2ZyZXhwX2Zsb2F0IiwibmVnIiwiY2FtbF9zdHJpbmdfZ2V0NjQiLCJjYW1sX21sX3Bvc19vdXRfNjQiLCJjYW1sX2dyX2Nsb3NlX3N1YndpbmRvdyIsImNhbWxfZmxvYXRhcnJheV9ibGl0IiwiY2FtbF9zZXRfc3RhdGljX2VudiIsImNhbWxfYmFfY2hhbmdlX2xheW91dCIsImNhbWxfanNfbmV3IiwiY2FtbF9ncl9jdXJyZW50X3kiLCJjYW1sX2Zvcm1hdF9pbnQiLCJjYW1sX29ial90cnVuY2F0ZSIsImNhbWxfanNfdG9fc3RyaW5nIiwiaXNfZGlnaXRfb2RkIiwiY2FtbF9ydW50aW1lX3ZhcmlhbnQiLCJjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9vdXQiLCJjYW1sX2FycmF5X2NvbmNhdCIsImNhbWxfZ3Jfb3Blbl9ncmFwaCIsImdldCIsInNwZWNzIiwidGFyZ2V0Iiwic3RhdHVzIiwid2luIiwiZG9jIiwidGl0bGUiLCJib2R5IiwiY2FtbF9lcGhlX3NldF9kYXRhIiwiY2FtbF9tYWtlX2Zsb2F0X3ZlY3QiLCJjYW1sX21lbXByb2Zfc3RvcCIsImNhbWxfZ3JlYXRlcmVxdWFsIiwiY2FtbF9nZXRfZXhjZXB0aW9uX3Jhd19iYWNrdHJhY2UiLCJjYW1sX2xvZzFwX2Zsb2F0IiwiY2FtbF9pbnQ2NF9vciIsImNhbWxfbGF6eV9tYWtlX2ZvcndhcmQiLCJsb3JfZGlnaXRfbmF0IiwiY2FtbF9ncl9ibGl0X2ltYWdlIiwiaW0yIiwiY2FtbF9ncl93aW5kb3dfaWQiLCJjYW1sX2pzX29uX2llIiwidWEiLCJjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0IiwiY2FtbF9iYV9sYXlvdXQiLCJjYW1sX2NvbnZlcnRfcmF3X2JhY2t0cmFjZSIsImNhbWxfYXJyYXlfc2V0IiwibmV3dmFsIiwiY2FtbF9ieXRlc19ncmVhdGVyZXF1YWwiLCJzZXRfZGlnaXRfbmF0IiwiY2FtbF91cGRhdGVfZHVtbXkiLCJjYW1sX0NhbWxpbnRlcm5hbE1vZF91cGRhdGVfbW9kIiwicmVhbCIsImNhbWxfZ3JfZG9jX29mX3N0YXRlIiwiY2FtbF9tbF9vdXRwdXRfaW50IiwiY2FtbF9vYmpfd2l0aF90YWciLCJjYW1sX21sX2NoYW5uZWxfc2l6ZSIsImNhbWxfcmF3X2JhY2t0cmFjZV9zbG90IiwiY2FtbF9oZXhzdHJpbmdfb2ZfZmxvYXQiLCJzdHlsZSIsImV4cF9zaWduIiwic2lnbl9zdHIiLCJjc3QiLCJ4X3N0ciIsImNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrX3N0cmljdCIsImNhbWxfYmFja3RyYWNlX3N0YXR1cyIsImNhbWxfaW5zdGFsbF9zaWduYWxfaGFuZGxlciIsImNhbWxfc3lzX2FyZ3YiLCJjYW1sX2JhX2ZpbGwiLCJjYW1sX21vZGZfZmxvYXQiLCJjYW1sX2djX2dldCIsImNhbWxfZmxvYXRfY29tcGFyZSIsImNhbWxfc3RyaW5nX3NldDMyIiwiY2FtbF9wYXJzZV9lbmdpbmUiLCJ0YWJsZXMiLCJlbnYiLCJFUlJDT0RFIiwidGVzdHNoaWZ0Iiwic2hpZnQiLCJzaGlmdF9yZWNvdmVyIiwicmVkdWNlIiwiUkVBRF9UT0tFTiIsIlJBSVNFX1BBUlNFX0VSUk9SIiwiR1JPV19TVEFDS1NfMSIsIkdST1dfU1RBQ0tTXzIiLCJDT01QVVRFX1NFTUFOVElDX0FDVElPTiIsIkNBTExfRVJST1JfRlVOQ1RJT04iLCJlbnZfc19zdGFjayIsImVudl92X3N0YWNrIiwiZW52X3N5bWJfc3RhcnRfc3RhY2siLCJlbnZfc3ltYl9lbmRfc3RhY2siLCJlbnZfc3RhY2tzaXplIiwiZW52X3N0YWNrYmFzZSIsImVudl9jdXJyX2NoYXIiLCJlbnZfbHZhbCIsImVudl9zeW1iX3N0YXJ0IiwiZW52X3N5bWJfZW5kIiwiZW52X2FzcCIsImVudl9ydWxlX2xlbiIsImVudl9ydWxlX251bWJlciIsImVudl9zcCIsImVudl9zdGF0ZSIsImVudl9lcnJmbGFnIiwidGJsX3RyYW5zbF9jb25zdCIsInRibF90cmFuc2xfYmxvY2siLCJ0YmxfbGhzIiwidGJsX2xlbiIsInRibF9kZWZyZWQiLCJ0YmxfZGdvdG8iLCJ0Ymxfc2luZGV4IiwidGJsX3JpbmRleCIsInRibF9naW5kZXgiLCJ0YmxfdGFibGVzaXplIiwidGJsX3RhYmxlIiwidGJsX2NoZWNrIiwibjEiLCJuMiIsInN0YXRlMSIsInNwIiwiZXJyZmxhZyIsImFzcCIsImNhbWxfYXJyYXlfZmlsbCIsImNhbWxfc3RyaW5nX25vdGVxdWFsIiwiY2FtbF9ieXRlc19ncmVhdGVydGhhbiIsImNhbWxfZ3JfbWFrZV9pbWFnZSIsImNhbWxfbWxfc2V0X2NoYW5uZWxfb3V0cHV0IiwiY2FtbF9yZWFkX2ZpbGVfY29udGVudCIsImNhbWxfanNfdG9fZmxvYXQiLCJlcnJfbm9fcHJlZCIsImVycl9ub19zdWNjIiwiemVybyQyIiwib25lJDIiLCJtaW51c19vbmUkMiIsIm1pbl9pbnQkMiIsIm1heF9pbnQkMiIsImR1bW15X3BvcyIsInplcm9fcG9zIiwic3ViX2Zvcm1hdCIsImZvcm1hdHRpbmdfbGl0IiwibG9jZm10IiwibnVsbCQwIiwiY3VycmVudF9kaXJfbmFtZSIsInBhcmVudF9kaXJfbmFtZSIsImRpcl9zZXAiLCJxdW90ZXF1b3RlIiwibnVsbCQxIiwiY3VycmVudF9kaXJfbmFtZSQwIiwicGFyZW50X2Rpcl9uYW1lJDAiLCJkaXJfc2VwJDAiLCJudWxsJDIiLCJjdXJyZW50X2Rpcl9uYW1lJDEiLCJwYXJlbnRfZGlyX25hbWUkMSIsImRpcl9zZXAkMSIsInplcm8kNCIsIm9uZSQ0IiwiaSIsImVyYXNlX3JlbCIsInJlc3QiLCJyZXN0JDAiLCJyZXN0JDEiLCJyZXN0JDIiLCJyZXN0JDMiLCJyZXN0JDQiLCJyZXN0JDUiLCJyZXN0JDYiLCJyZXN0JDciLCJ0eSIsInJlc3QkOCIsInR5MSIsInJlc3QkOSIsInJlc3QkMTAiLCJyZXN0JDExIiwicmVzdCQxMiIsInJlc3QkMTMiLCJjb25jYXRfZm10dHkiLCJmbXR0eTEiLCJmbXR0eTIiLCJ0eTIiLCJjb25jYXRfZm10IiwiZm10MSIsImZtdDIiLCJwYWQiLCJwYWQkMCIsInByZWMiLCJwYWQkMSIsImljb252IiwicHJlYyQwIiwicGFkJDIiLCJpY29udiQwIiwicHJlYyQxIiwicGFkJDMiLCJpY29udiQxIiwicHJlYyQyIiwicGFkJDQiLCJpY29udiQyIiwicHJlYyQzIiwicGFkJDUiLCJmY29udiIsInBhZCQ2Iiwic3RyIiwiY2hyIiwiZm10dHkiLCJwYWQkNyIsImZtdHR5JDAiLCJwYWQkOCIsInJlc3QkMTQiLCJyZXN0JDE1IiwicmVzdCQxNiIsImZtdGluZ19saXQiLCJyZXN0JDE3IiwiZm10aW5nX2dlbiIsInJlc3QkMTgiLCJyZXN0JDE5IiwiY2hhcl9zZXQiLCJ3aWR0aF9vcHQiLCJyZXN0JDIwIiwiY291bnRlciIsInJlc3QkMjEiLCJyZXN0JDIyIiwiaWduIiwicmVzdCQyMyIsImYiLCJhcml0eSIsInYiLCJyIiwiY3VyIiwic2VlbiIsIm4iLCJmYWlsd2l0aCIsInMiLCJpbnZhbGlkX2FyZyIsIm1pbiIsIngiLCJ5IiwibWF4IiwiYWJzIiwibG5vdCIsImluZmluaXR5IiwibmVnX2luZmluaXR5IiwibmFuIiwibWF4X2Zsb2F0IiwibWluX2Zsb2F0IiwiZXBzaWxvbiIsIm1heF9pbnQiLCJtaW5faW50Iiwic3ltYm9sIiwiczEiLCJzMiIsImwxIiwibDIiLCJjaGFyX29mX2ludCIsInN0cmluZ19vZl9ib29sIiwiYiIsImJvb2xfb2Zfc3RyaW5nIiwiYm9vbF9vZl9zdHJpbmdfb3B0Iiwic3RyaW5nX29mX2ludCIsImludF9vZl9zdHJpbmdfb3B0IiwidmFsaWRfZmxvYXRfbGV4ZW0iLCJsIiwiaSQwIiwidG9fc3RyaW5nIiwib2Zfc3RyaW5nX29wdCIsImFwcGVuZCIsInRsIiwiaGQiLCJzdGRpbiIsInN0ZG91dCIsInN0ZGVyciIsIm9wZW5fb3V0X2dlbiIsIm1vZGUiLCJwZXJtIiwibmFtZSIsImMiLCJvcGVuX291dCIsIm9wZW5fb3V0X2JpbiIsImZsdXNoX2FsbCIsIml0ZXIiLCJhIiwib3V0cHV0X2J5dGVzIiwib2MiLCJvdXRwdXRfc3RyaW5nIiwib3V0cHV0Iiwib2ZzIiwibGVuIiwib3V0cHV0X3N1YnN0cmluZyIsIm91dHB1dF92YWx1ZSIsImNoYW4iLCJjbG9zZV9vdXQiLCJjbG9zZV9vdXRfbm9lcnIiLCJvcGVuX2luX2dlbiIsIm9wZW5faW4iLCJvcGVuX2luX2JpbiIsImlucHV0IiwiaWMiLCJ1bnNhZmVfcmVhbGx5X2lucHV0Iiwib2ZzJDAiLCJsZW4kMCIsImxlbiQxIiwib2ZzJDEiLCJyZWFsbHlfaW5wdXQiLCJyZWFsbHlfaW5wdXRfc3RyaW5nIiwiaW5wdXRfbGluZSIsImJ1aWxkX3Jlc3VsdCIsImJ1ZiIsImFjY3UiLCJiZWciLCJhY2N1JDAiLCJyZXMiLCJjbG9zZV9pbl9ub2VyciIsInByaW50X2NoYXIiLCJwcmludF9zdHJpbmciLCJwcmludF9ieXRlcyIsInByaW50X2ludCIsInByaW50X2Zsb2F0IiwicHJpbnRfZW5kbGluZSIsInByaW50X25ld2xpbmUiLCJwcmVycl9jaGFyIiwicHJlcnJfc3RyaW5nIiwicHJlcnJfYnl0ZXMiLCJwcmVycl9pbnQiLCJwcmVycl9mbG9hdCIsInByZXJyX2VuZGxpbmUiLCJwcmVycl9uZXdsaW5lIiwicmVhZF9saW5lIiwicmVhZF9pbnQiLCJyZWFkX2ludF9vcHQiLCJyZWFkX2Zsb2F0IiwicmVhZF9mbG9hdF9vcHQiLCJzdHJpbmdfb2ZfZm9ybWF0Iiwic3ltYm9sJDAiLCJzdHIyIiwic3RyMSIsImV4aXRfZnVuY3Rpb24iLCJhdF9leGl0IiwiZl95ZXRfdG9fcnVuIiwib2xkX2V4aXQiLCJuZXdfZXhpdCQwIiwibmV3X2V4aXQiLCJzdWNjZXNzIiwiZG9fYXRfZXhpdCIsImV4aXQiLCJyZXRjb2RlIiwic2V0X2JpbmFyeV9tb2RlX2luIiwiY2xvc2VfaW4iLCJpbl9jaGFubmVsX2xlbmd0aCIsInBvc19pbiIsInNlZWtfaW4iLCJpbnB1dF92YWx1ZSIsImlucHV0X2JpbmFyeV9pbnQiLCJpbnB1dF9ieXRlIiwiaW5wdXRfY2hhciIsInNldF9iaW5hcnlfbW9kZV9vdXQiLCJvdXRfY2hhbm5lbF9sZW5ndGgiLCJwb3Nfb3V0Iiwic2Vla19vdXQiLCJvdXRwdXRfYmluYXJ5X2ludCIsIm91dHB1dF9ieXRlIiwib3V0cHV0X2NoYXIiLCJmbHVzaCIsImVtcHR5IiwicmV0dXJuJDAiLCJjb25zIiwibmV4dCIsImFwcGVuZCQwIiwic2VxMSIsInNlcTIiLCJtYXAiLCJzZXEiLCJmaWx0ZXJfbWFwIiwic2VxJDAiLCJmaWx0ZXIiLCJmbGF0X21hcCQwIiwiZmxhdF9tYXBfYXBwJDAiLCJ0YWlsIiwiZmxhdF9tYXBfYXBwIiwiZmxhdF9tYXAiLCJmb2xkX2xlZnQiLCJhY2MiLCJhY2MkMCIsImFjYyQxIiwidW5mb2xkIiwidSIsInUkMCIsIm5vbmUiLCJzb21lIiwidmFsdWUiLCJvIiwiZGVmYXVsdCQwIiwiZ2V0JDAiLCJiaW5kIiwiam9pbiIsIm1hcCQwIiwiZm9sZCIsIml0ZXIkMCIsImlzX25vbmUiLCJpc19zb21lIiwiZXF1YWwiLCJlcSIsIm8wIiwibzEiLCJ2MSIsInYwIiwiY29tcGFyZSIsImNtcCIsInRvX3Jlc3VsdCIsInRvX2xpc3QiLCJ0b19zZXEiLCJsZWZ0IiwicmlnaHQiLCJpc19sZWZ0IiwiaXNfcmlnaHQiLCJmaW5kX2xlZnQiLCJmaW5kX3JpZ2h0IiwibWFwX2xlZnQiLCJlIiwibWFwX3JpZ2h0IiwibWFwJDEiLCJ2JDAiLCJmb2xkJDAiLCJlcXVhbCQwIiwiZTEiLCJtYXRjaCIsInYyIiwidjIkMCIsImNvbXBhcmUkMCIsIm9rIiwiZXJyb3IiLCJ2YWx1ZSQwIiwiZ2V0X29rIiwiZ2V0X2Vycm9yIiwiYmluZCQwIiwiam9pbiQwIiwibWFwJDIiLCJtYXBfZXJyb3IiLCJmb2xkJDEiLCJpdGVyJDEiLCJpdGVyX2Vycm9yIiwiaXNfb2siLCJpc19lcnJvciIsImVxdWFsJDEiLCJyMCIsImNvbXBhcmUkMSIsInRvX29wdGlvbiIsInRvX2xpc3QkMCIsInRvX3NlcSQwIiwiZXF1YWwkMiIsImNvbXBhcmUkMiIsInRvX2Zsb2F0IiwidG9fc3RyaW5nJDAiLCJlc2NhcGVkIiwicyQwIiwibG93ZXJjYXNlIiwidXBwZXJjYXNlIiwibG93ZXJjYXNlX2FzY2lpIiwidXBwZXJjYXNlX2FzY2lpIiwiY29tcGFyZSQzIiwiYzEiLCJjMiIsImVxdWFsJDMiLCJtaW4kMCIsIm1heCQwIiwibG9fYm91bmQiLCJoaV9ib3VuZCIsImJvbSIsInJlcCIsInN1Y2MiLCJwcmVkIiwiaXNfdmFsaWQiLCJvZl9pbnQiLCJpc19jaGFyIiwib2ZfY2hhciIsInRvX2NoYXIiLCJ1bnNhZmVfdG9fY2hhciIsImVxdWFsJDQiLCJjb21wYXJlJDQiLCJoYXNoIiwibWF0Y2gkMSIsImxlbmd0aCIsInBhcmFtJDAiLCJjb25zJDAiLCJudGgiLCJsJDAiLCJuJDAiLCJsJDEiLCJuJDEiLCJudGhfb3B0IiwicmV2X2FwcGVuZCIsImwxJDAiLCJsMiQwIiwibDEkMSIsImwyJDEiLCJyZXYiLCJpbml0X2F1eCIsInJldl9pbml0X3RocmVzaG9sZCIsInBhcmFtIiwiYWNjdSQxIiwiYTIiLCJhMSIsInAiLCJwYWlyIiwicmVzdWx0IiwieHMiLCJ4JDAiLCJyeSIsInJ4IiwidDIiLCJoMiIsInQxIiwiaDEiLCJyZXZfc29ydCIsIngyIiwieDEiLCJ0bCQxIiwieDMiLCJ4MiQwIiwieDEkMCIsIm4xIiwibjIiLCJzb3J0IiwidGwkMCIsImMkMCIsImMkMSIsImMkMiIsImMkMyIsImMkNCIsImMkNSIsImMkNiIsImFjY3UkMiIsImF1eCIsImRpcmVjdCIsImRlcHRoIiwic3ltYm9sJDEiLCJkc3RvZmYiLCJzcmNvZmYiLCJjcHlsZW4iLCJvZnMxIiwib2ZzMiIsInNlcCIsInNlcGxlbiIsImRzdCIsImlzX3NwYWNlIiwiaiIsImFwcGx5MSIsImluZGV4X3JlYyIsImxpbSIsImkkMSIsImluZGV4X3JlY19vcHQiLCJyaW5kZXhfcmVjIiwicmluZGV4X3JlY19vcHQiLCJuZXdfbGVuIiwibmV3X2J1ZiIsImlzX3NwYWNlJDAiLCJpbmRleF9yZWMkMCIsImluZGV4X3JlY19vcHQkMCIsInJpbmRleF9yZWMkMCIsInJpbmRleF9yZWNfb3B0JDAiLCJnIiwiZXF1YWwkOCIsImNvbXBhcmUkOCIsInRvX3N0cmluZyQyIiwidG9fYnVmZmVyIiwiYnVmZiIsImZsYWdzIiwiaGVhZGVyX3NpemUiLCJkYXRhX3NpemUiLCJ0b3RhbF9zaXplIiwiZnJvbV9ieXRlcyIsImZyb21fc3RyaW5nIiwiaXNfYmxvY2siLCJkb3VibGVfZmllbGQiLCJzZXRfZG91YmxlX2ZpZWxkIiwibWFyc2hhbCIsIm9iaiIsInVubWFyc2hhbCIsInBvcyIsImZpcnN0X25vbl9jb25zdGFudF9jb25zdHJ1Y3RvciIsImxhc3Rfbm9uX2NvbnN0YW50X2NvbnN0cnVjdG9yXyIsImxhenlfdGFnIiwiY2xvc3VyZV90YWciLCJvYmplY3RfdGFnIiwiaW5maXhfdGFnIiwiZm9yd2FyZF90YWciLCJub19zY2FuX3RhZyIsImFic3RyYWN0X3RhZyIsInN0cmluZ190YWciLCJkb3VibGVfdGFnIiwiZG91YmxlX2FycmF5X3RhZyIsImN1c3RvbV90YWciLCJpbnRfdGFnIiwib3V0X29mX2hlYXBfdGFnIiwidW5hbGlnbmVkX3RhZyIsImluZm8iLCJzdGFydF9lbnYiLCJvZl92YWwiLCJzbG90IiwiaWQiLCJleHRlbnNpb25fY29uc3RydWN0b3IiLCJleHRlbnNpb25fbmFtZSIsImV4dGVuc2lvbl9pZCIsIm1heF9lcGhlX2xlbmd0aCIsImNyZWF0ZSIsImxlbmd0aCQwIiwicmFpc2VfaWZfaW52YWxpZF9vZmZzZXQiLCJtc2ciLCJnZXRfa2V5IiwiZ2V0X2tleV9jb3B5Iiwic2V0X2tleSIsInVuc2V0X2tleSIsImNoZWNrX2tleSIsImJsaXRfa2V5IiwiZTIiLCJvMiIsInN4Iiwic3kiLCJpbml0IiwibGEiLCJsYiIsInJlcyQwIiwibGlzdF9sZW5ndGgiLCJwYXJhbSQxIiwiaGQkMCIsIm1heHNvbiIsImkzMSIsInRyaWNrbGVkb3duIiwidHJpY2tsZSIsImJ1YmJsZWRvd24iLCJidWJibGUiLCJpJDIiLCJlJDAiLCJmYXRoZXIiLCJtZXJnZSIsInNyYzFvZnMiLCJzcmMxbGVuIiwic3JjMiIsInNyYzJvZnMiLCJzcmMybGVuIiwiZHN0b2ZzIiwic3JjMXIiLCJzcmMyciIsInMyJDEiLCJzMSQxIiwiaTEiLCJpMiIsImQiLCJpMiQwIiwiZCQwIiwiczIkMCIsImkxJDAiLCJkJDEiLCJzMSQwIiwiaXNvcnR0byIsInNyY29mcyIsInNvcnR0byIsInQiLCJ6ZXJvIiwib25lIiwibWludXNfb25lIiwiaXNfZmluaXRlIiwiaXNfaW5maW5pdGUiLCJpc19uYW4iLCJwaSIsImlzX2ludGVnZXIiLCJzdWNjJDAiLCJwcmVkJDAiLCJlcXVhbCQ5IiwibWluJDEiLCJtYXgkMSIsIm1pbl9tYXgiLCJtaW5fbnVtIiwibWF4X251bSIsIm1pbl9tYXhfbnVtIiwiaGFzaCQwIiwidW5zYWZlX2ZpbGwiLCJjaGVjayIsIm1ha2UkMiIsImluaXQkMyIsImFwcGVuZCQyIiwiY29uY2F0JDIiLCJobGVuIiwic3ViJDIiLCJjb3B5JDIiLCJmaWxsJDEiLCJibGl0JDIiLCJzcmMiLCJzb2ZzIiwiZG9mcyIsInRvX2xpc3QkMiIsIm9mX2xpc3QkMCIsImgiLCJpdGVyJDYiLCJpdGVyMiQxIiwibWFwJDciLCJtYXAyJDEiLCJpdGVyaSQzIiwibWFwaSQzIiwiZm9sZF9sZWZ0JDIiLCJmb2xkX3JpZ2h0JDEiLCJleGlzdHMkMSIsImZvcl9hbGwkMSIsIm1lbSQxIiwibWVtX2llZWUiLCJzb3J0JDAiLCJzdGFibGVfc29ydCIsInRvX3NlcSQ1IiwidG9fc2VxaSQyIiwib2Zfc2VxJDMiLCJtYXBfdG9fYXJyYXkiLCJtYXBfZnJvbV9hcnJheSIsInplcm8kMCIsIm9uZSQwIiwibWludXNfb25lJDAiLCJhYnMkMCIsIm1heF9pbnQkMCIsIm1pbl9pbnQkMCIsImxvZ25vdCIsImVxdWFsJDEwIiwiY29tcGFyZSQ5IiwidG9fc3RyaW5nJDMiLCJ6ZXJvJDEiLCJvbmUkMSIsIm1pbnVzX29uZSQxIiwic3VjYyQxIiwicHJlZCQxIiwiYWJzJDEiLCJtaW5faW50JDEiLCJtYXhfaW50JDEiLCJsb2dub3QkMCIsInVuc2lnbmVkX3RvX2ludCIsInRvX3N0cmluZyQ0Iiwib2Zfc3RyaW5nX29wdCQwIiwiY29tcGFyZSQxMCIsImVxdWFsJDExIiwidW5zaWduZWRfY29tcGFyZSIsIm0iLCJ1bnNpZ25lZF9kaXYiLCJxIiwidW5zaWduZWRfcmVtIiwic3VjYyQyIiwicHJlZCQyIiwiYWJzJDIiLCJsb2dub3QkMSIsIm1heF9pbnQkMyIsInVuc2lnbmVkX3RvX2ludCQwIiwidG9fc3RyaW5nJDUiLCJvZl9zdHJpbmdfb3B0JDEiLCJjb21wYXJlJDExIiwiZXF1YWwkMTIiLCJ1bnNpZ25lZF9jb21wYXJlJDAiLCJ1bnNpZ25lZF9kaXYkMCIsInVuc2lnbmVkX3JlbSQwIiwiemVybyQzIiwib25lJDMiLCJtaW51c19vbmUkMyIsInN1Y2MkMyIsInByZWQkMyIsImFicyQzIiwibWluX2ludCQzIiwibWF4X2ludCQ0IiwibG9nbm90JDIiLCJ1bnNpZ25lZF90b19pbnQkMSIsInRvX3N0cmluZyQ2Iiwib2Zfc3RyaW5nX29wdCQyIiwiY29tcGFyZSQxMiIsImVxdWFsJDEzIiwidW5zaWduZWRfY29tcGFyZSQxIiwidW5zaWduZWRfZGl2JDEiLCJ1bnNpZ25lZF9yZW0kMSIsImVuZ2luZSIsInRibCIsInN0YXRlIiwibmV3X2VuZ2luZSIsImZyb21fZnVuY3Rpb24iLCJvcHQiLCJzdGgiLCJ3aXRoX3Bvc2l0aW9ucyIsImF1eF9idWZmZXIiLCJsZXhidWYiLCJyZWFkIiwibmV3bGVuIiwibmV3YnVmIiwiZnJvbV9jaGFubmVsIiwiZnJvbV9zdHJpbmckMCIsInNldF9wb3NpdGlvbiIsInBvc2l0aW9uIiwic2V0X2ZpbGVuYW1lIiwiZm5hbWUiLCJsZXhlbWUiLCJzdWJfbGV4ZW1lIiwic3ViX2xleGVtZV9vcHQiLCJzdWJfbGV4ZW1lX2NoYXIiLCJzdWJfbGV4ZW1lX2NoYXJfb3B0IiwibGV4ZW1lX2NoYXIiLCJsZXhlbWVfc3RhcnQiLCJsZXhlbWVfZW5kIiwibGV4ZW1lX3N0YXJ0X3AiLCJsZXhlbWVfZW5kX3AiLCJuZXdfbGluZSIsImxjcCIsImZsdXNoX2lucHV0IiwiZW52IiwiZ3Jvd19zdGFja3MiLCJvbGRzaXplIiwibmV3c2l6ZSIsIm5ld19zIiwibmV3X3YiLCJuZXdfc3RhcnQiLCJuZXdfZW5kIiwiY2xlYXJfcGFyc2VyIiwiY3VycmVudF9sb29rYWhlYWRfZnVuIiwieXlwYXJzZSIsInRhYmxlcyIsInN0YXJ0IiwibGV4ZXIiLCJpbml0X2FzcCIsImluaXRfc3AiLCJpbml0X3N0YWNrYmFzZSIsImluaXRfc3RhdGUiLCJpbml0X2N1cnJfY2hhciIsImluaXRfbHZhbCIsImluaXRfZXJyZmxhZyIsImNtZCIsImFyZyIsImFyZyQwIiwiYXJnJDEiLCJjbWQkMCIsImV4biIsImN1cnJfY2hhciIsInRvayIsInBlZWtfdmFsIiwic3ltYm9sX3N0YXJ0X3BvcyIsInN0IiwiZW4iLCJzeW1ib2xfZW5kX3BvcyIsInJoc19zdGFydF9wb3MiLCJyaHNfZW5kX3BvcyIsInN5bWJvbF9zdGFydCIsInN5bWJvbF9lbmQiLCJyaHNfc3RhcnQiLCJyaHNfZW5kIiwiaXNfY3VycmVudF9sb29rYWhlYWQiLCJwYXJzZV9lcnJvciIsImhlaWdodCIsImhsIiwiaCQwIiwiaHIiLCJiYWwiLCJsciIsImx2IiwibGwiLCJscnIiLCJscnYiLCJscmwiLCJyciIsInJ2IiwicmwiLCJybHIiLCJybHYiLCJybGwiLCJhZGQiLCJzaW5nbGV0b24iLCJhZGRfbWluX2VsZW1lbnQiLCJhZGRfbWF4X2VsZW1lbnQiLCJyaCIsImxoIiwibWluX2VsdCIsIm1pbl9lbHRfb3B0IiwibWF4X2VsdCIsIm1heF9lbHRfb3B0IiwicmVtb3ZlX21pbl9lbHQiLCJyJDAiLCJjb25jYXQiLCJzcGxpdCIsInByZXMiLCJwcmVzJDAiLCJpc19lbXB0eSIsIm1lbSIsInJlbW92ZSIsInVuaW9uIiwicjIiLCJyMSIsInIyJDAiLCJyMSQwIiwiaW50ZXIiLCJzcGxpdF9iaXMiLCJkaXNqb2ludCIsImRpZmYiLCJjb25zX2VudW0iLCJzJDEiLCJlJDEiLCJlMiQyIiwiZTEkMiIsImUyJDAiLCJlMSQwIiwiZTIkMSIsImUxJDEiLCJzdWJzZXQiLCJmb3JfYWxsIiwiZXhpc3RzIiwicHYiLCJwYXJ0aXRpb24iLCJsZiIsImx0IiwicmYiLCJydCIsImNhcmRpbmFsIiwiZWxlbWVudHNfYXV4IiwiZWxlbWVudHMiLCJmaW5kIiwiZmluZF9maXJzdCIsImZpbmRfZmlyc3Rfb3B0IiwiZmluZF9sYXN0IiwiZmluZF9sYXN0X29wdCIsImZpbmRfb3B0IiwidHJ5X2pvaW4iLCJ0JDAiLCJ2JDEiLCJvZl9saXN0Iiwic3ViIiwibCQzIiwieDAiLCJsJDQiLCJ4MCQwIiwibCQ1IiwieDAkMSIsIm5sIiwibWlkIiwibCQyIiwieDQiLCJhZGRfc2VxIiwib2Zfc2VxIiwic2VxX29mX2VudW0iLCJzbm9jX2VudW0iLCJyZXZfc2VxX29mX2VudW0iLCJ0b19yZXZfc2VxIiwidG9fc2VxX2Zyb20iLCJsb3ciLCJsZCIsImxyZCIsInJkIiwicmxkIiwiZGF0YSIsIm1pbl9iaW5kaW5nIiwibWluX2JpbmRpbmdfb3B0IiwibWF4X2JpbmRpbmciLCJtYXhfYmluZGluZ19vcHQiLCJyZW1vdmVfbWluX2JpbmRpbmciLCJ1cGRhdGUiLCJkYXRhJDAiLCJtYXBpIiwibSQwIiwiYWRkX21pbl9iaW5kaW5nIiwiayIsImFkZF9tYXhfYmluZGluZyIsImNvbmNhdF9vcl9qb2luIiwiZDEiLCJkMiIsImQyJDAiLCJkMSQwIiwiZDIkMSIsImQxJDEiLCJwdmQiLCJmdmQiLCJtJDEiLCJtMSIsIm0yIiwiYmluZGluZ3NfYXV4IiwiYmluZGluZ3MiLCJjcmVhdGUkMCIsImNsZWFyIiwiY29weSQzIiwicHVzaCIsInBvcCIsInBvcF9vcHQiLCJ0b3AiLCJ0b3Bfb3B0IiwibGVuZ3RoJDEiLCJpdGVyJDciLCJmb2xkJDIiLCJ0b19zZXEkNiIsIm9mX3NlcSQ0IiwiY3JlYXRlJDEiLCJjbGVhciQwIiwiY2VsbCIsInBlZWsiLCJjb250ZW50IiwicGVla19vcHQiLCJ0YWtlIiwidGFrZV9vcHQiLCJjb3B5JDQiLCJxX3JlcyIsInByZXYiLCJpc19lbXB0eSQwIiwibGVuZ3RoJDIiLCJpdGVyJDgiLCJmb2xkJDMiLCJ0cmFuc2ZlciIsInExIiwicTIiLCJ0b19zZXEkNyIsImFkZF9zZXEkMCIsIm9mX3NlcSQ1IiwicmFpc2VfdW5kZWZpbmVkIiwiZm9yY2VfbGF6eV9ibG9jayIsImJsayIsImNsb3N1cmUiLCJmb3JjZV92YWxfbGF6eV9ibG9jayIsImZvcmNlIiwibHp2IiwiZm9yY2VfdmFsIiwiZnJvbV9mdW4iLCJmcm9tX3ZhbCIsImlzX3ZhbCIsImNvdW50IiwiZmlsbF9idWZmIiwiZ2V0X2RhdGEiLCJkMTEiLCJhJDAiLCJhJDEiLCJwZWVrX2RhdGEiLCJwZWVrJDAiLCJqdW5rX2RhdGEiLCJqdW5rIiwibmdldF9kYXRhIiwiYWwiLCJucGVlayIsImVtcHR5JDEiLCJpdGVyJDkiLCJzdHJtIiwiZnJvbSIsIm9mX2xpc3QkMSIsIm9mX3N0cmluZyQwIiwib2ZfYnl0ZXMiLCJvZl9jaGFubmVsIiwiaWFwcCIsImljb25zIiwiaXNpbmciLCJsYXBwIiwibGNvbnMiLCJsc2luZyIsInNlbXB0eSIsInNsYXp5IiwiZHVtcF9kYXRhIiwiZHVtcCIsImNyZWF0ZSQyIiwiY29udGVudHMiLCJ0b19ieXRlcyIsInN1YiQzIiwiYmxpdCQzIiwibnRoJDAiLCJsZW5ndGgkMyIsImNsZWFyJDEiLCJyZXNldCIsInJlc2l6ZSIsIm1vcmUiLCJvbGRfcG9zIiwib2xkX2xlbiIsIm5ld19idWZmZXIiLCJhZGRfY2hhciIsImFkZF91dGZfOF91Y2hhciIsInBvcyQwIiwicG9zJDEiLCJhZGRfdXRmXzE2YmVfdWNoYXIiLCJoaSIsImxvIiwiYWRkX3V0Zl8xNmxlX3VjaGFyIiwiYWRkX3N1YnN0cmluZyIsIm9mZnNldCIsIm5ld19wb3NpdGlvbiIsImFkZF9zdWJieXRlcyIsImFkZF9zdHJpbmciLCJhZGRfYnl0ZXMiLCJhZGRfYnVmZmVyIiwiYnMiLCJhZGRfY2hhbm5lbCIsImFscmVhZHlfcmVhZCIsInRvX3JlYWQiLCJhbHJlYWR5X3JlYWQkMCIsInRvX3JlYWQkMCIsIm91dHB1dF9idWZmZXIiLCJhZGRfc3Vic3RpdHV0ZSIsImxpbSQxIiwicHJldmlvdXMiLCJpJDciLCJjdXJyZW50IiwiaSQ4Iiwib3BlbmluZyIsImkkNiIsImxpbSQwIiwiaSQzIiwic3RvcCIsImkkNCIsImkkNSIsImskMiIsImskMCIsImskMSIsIm5leHRfaSIsImlkZW50IiwiaSQ5IiwiaSQxMCIsImkkMTEiLCJ0cnVuY2F0ZSIsInRvX3NlcSQ4IiwidG9fc2VxaSQzIiwiYWRkX3NlcSQxIiwib2Zfc2VxJDYiLCJhZGRfaW50OCIsImFkZF9pbnQxNl9uZSIsImFkZF9pbnQzMl9uZSIsImFkZF9pbnQ2NF9uZSIsImFkZF9pbnQxNl9sZSIsImFkZF9pbnQxNl9iZSIsImFkZF9pbnQzMl9sZSIsImFkZF9pbnQzMl9iZSIsImFkZF9pbnQ2NF9sZSIsImFkZF9pbnQ2NF9iZSIsImNyZWF0ZV9jaGFyX3NldCIsImFkZF9pbl9jaGFyX3NldCIsInN0cl9pbmQiLCJtYXNrIiwiZnJlZXplX2NoYXJfc2V0IiwicmV2X2NoYXJfc2V0IiwiY2hhcl9zZXQkMCIsImlzX2luX2NoYXJfc2V0IiwicGFkX29mX3BhZF9vcHQiLCJwYWRfb3B0Iiwid2lkdGgiLCJwYXJhbV9mb3JtYXRfb2ZfaWdub3JlZF9mb3JtYXQiLCJmbXQiLCJwYWRfb3B0JDAiLCJwYWRfb3B0JDEiLCJwYWRfb3B0JDIiLCJwYWRfb3B0JDMiLCJwYWRfb3B0JDQiLCJwcmVjX29wdCIsInBhZF9vcHQkNSIsIm5kZWMiLCJwYWRfb3B0JDYiLCJwYWRfb3B0JDciLCJwYWRfb3B0JDgiLCJkZWZhdWx0X2Zsb2F0X3ByZWNpc2lvbiIsImJ1ZmZlcl9jcmVhdGUiLCJpbml0X3NpemUiLCJidWZmZXJfY2hlY2tfc2l6ZSIsIm92ZXJoZWFkIiwibWluX2xlbiIsIm5ld19zdHIiLCJidWZmZXJfYWRkX2NoYXIiLCJidWZmZXJfYWRkX3N0cmluZyIsInN0cl9sZW4iLCJidWZmZXJfY29udGVudHMiLCJjaGFyX29mX2ljb252IiwiY2hhcl9vZl9mY29udiIsImNGIiwiYnByaW50X3BhZHR5IiwicGFkdHkiLCJicHJpbnRfaWdub3JlZF9mbGFnIiwiaWduX2ZsYWciLCJicHJpbnRfcGFkX29wdCIsImJwcmludF9wYWRkaW5nIiwicGFkdHkkMCIsImJwcmludF9wcmVjaXNpb24iLCJicHJpbnRfaWNvbnZfZmxhZyIsImJwcmludF9hbHRpbnRfZm10IiwiYnByaW50X2Zjb252X2ZsYWciLCJzdHJpbmdfb2ZfZm9ybWF0dGluZ19saXQiLCJzdHIkMCIsImJwcmludF9jaGFyX2xpdGVyYWwiLCJicHJpbnRfc3RyaW5nX2xpdGVyYWwiLCJicHJpbnRfZm10dHkiLCJzdWJfZm10dHkiLCJzdWJfZm10dHkkMCIsImludF9vZl9jdXN0b21fYXJpdHkiLCJzdHJpbmdfb2ZfZm10IiwiZm10JDEiLCJjaHIkMCIsInN0ciQxIiwiaXNfYWxvbmUkMCIsImlzX2Fsb25lIiwiYWZ0ZXIiLCJiZWZvcmUiLCJqJDAiLCJqJDEiLCJmbXQkMCIsInN5bW0iLCJ0cmFucyIsInJlc3QyIiwicmVzdDIkMCIsInJlc3QyJDEiLCJyZXN0MiQyIiwicmVzdDIkMyIsInJlc3QyJDQiLCJyZXN0MiQ1IiwicmVzdDIkNiIsInJlc3QyJDciLCJyZXN0MiQ4IiwidHkyMiIsInR5MjEiLCJmbXR0eV9yZWxfZGV0IiwiZjQiLCJmMiIsInJlc3QyJDkiLCJyZXN0MiQxMCIsInJlc3QyJDExIiwicmVzdDIkMTIiLCJyZXN0MiQxMyIsImRlIiwiZWQiLCJhZiIsImZhIiwiZGUkMCIsImVkJDAiLCJhZiQwIiwiZmEkMCIsImRlJDEiLCJlZCQxIiwiYWYkMSIsImZhJDEiLCJkZSQyIiwiZWQkMiIsImFmJDIiLCJmYSQyIiwiZGUkMyIsImVkJDMiLCJhZiQzIiwiZmEkMyIsImRlJDQiLCJlZCQ0IiwiYWYkNCIsImZhJDQiLCJkZSQ1IiwiZWQkNSIsImFmJDUiLCJmYSQ1IiwiZGUkNiIsImVkJDYiLCJhZiQ2IiwiZmEkNiIsImRlJDciLCJlZCQ3IiwiYWYkNyIsImZhJDciLCJkZSQ4IiwiZWQkOCIsImFmJDgiLCJmYSQ4IiwiamQiLCJkaiIsImdhIiwiYWciLCJkZSQ5IiwiZWQkOSIsImFmJDkiLCJmYSQ5IiwiZGUkMTAiLCJlZCQxMCIsImFmJDEwIiwiZmEkMTAiLCJkZSQxMSIsImVkJDExIiwiYWYkMTEiLCJmYSQxMSIsImRlJDEyIiwiZWQkMTIiLCJhZiQxMiIsImZhJDEyIiwiZGUkMTMiLCJlZCQxMyIsImFmJDEzIiwiZmEkMTMiLCJmbXR0eV9vZl9wcmVjaXNpb25fZm10dHkiLCJmbXR0eV9vZl9wYWRkaW5nX2ZtdHR5IiwiZm10dHlfb2ZfY3VzdG9tIiwiYXJpdHkkMCIsImZtdHR5X29mX2ZtdCIsInR5X3Jlc3QiLCJwcmVjX3R5IiwidHlfcmVzdCQwIiwicHJlY190eSQwIiwidHlfcmVzdCQxIiwicHJlY190eSQxIiwidHlfcmVzdCQyIiwicHJlY190eSQyIiwidHlfcmVzdCQzIiwicHJlY190eSQzIiwiZm10dHkkMSIsImZtdHR5JDIiLCJmbXR0eSQzIiwidHkkMCIsImZtdHR5JDQiLCJmbXR0eSQ1IiwidHlwZV9wYWRkaW5nIiwidyIsInR5cGVfcGFkcHJlYyIsInR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aSIsInR5cGVfZm9ybWF0X2dlbiIsImZtdHR5X3Jlc3QiLCJzdWJfZm10dHlfcmVzdCIsInN1Yl9mbXR0eV9yZXN0JDAiLCJmbXR0eV9yZXN0JDAiLCJzdWJfZm10dHlfcmVzdCQxIiwic3ViX2ZtdHR5X3Jlc3QkMiIsImZtdHR5X3Jlc3QkMSIsInN1Yl9mbXR0eV9yZXN0JDMiLCJmbXQkMiIsInN1Yl9mbXR0eV9yZXN0JDQiLCJmbXR0eV9yZXN0JDIiLCJzdWJfZm10dHlfcmVzdCQ1IiwiZm10JDMiLCJzdWJfZm10dHlfcmVzdCQ2IiwiZm10dHlfcmVzdCQzIiwic3ViX2ZtdHR5X3Jlc3QkNyIsImZtdCQ0Iiwic3ViX2ZtdHR5X3Jlc3QkOCIsImZtdHR5X3Jlc3QkNCIsInN1Yl9mbXR0eV9yZXN0JDkiLCJmbXQkNSIsInN1Yl9mbXR0eV9yZXN0JDEwIiwiZm10dHlfcmVzdCQ1Iiwic3ViX2ZtdHR5X3Jlc3QkMTEiLCJmbXQkNiIsInN1Yl9mbXR0eV9yZXN0JDEyIiwiZm10dHlfcmVzdCQ2Iiwic3ViX2ZtdHR5X3Jlc3QkMTMiLCJmbXQkNyIsInN1Yl9mbXR0eV9yZXN0JDE0IiwiZm10dHlfcmVzdCQ3Iiwic3ViMl9mbXR0eSIsInN1Yl9mbXR0eV9yZXN0JDE1Iiwic3ViMl9mbXR0eSQwIiwiZm10JDgiLCJzdWJfZm10dHlfcmVzdCQxNiIsImZtdHR5X3Jlc3QkOCIsInN1YjJfZm10dHkkMSIsInN1YjFfZm10dHkiLCJzdWJfZm10dHlfcmVzdCQxNyIsInN1YjJfZm10dHkkMiIsInN1YjFfZm10dHkkMCIsImZtdCQ5Iiwic3ViX2ZtdHR5X3Jlc3QkMTgiLCJmbXR0eV9yZXN0JDkiLCJzdWJfZm10dHlfcmVzdCQxOSIsImZtdCQxMCIsInN1Yl9mbXR0eV9yZXN0JDIwIiwiZm10dHlfcmVzdCQxMCIsInN1Yl9mbXR0eV9yZXN0JDIxIiwiZm10JDExIiwic3ViX2ZtdHR5X3Jlc3QkMjIiLCJmbXR0eV9yZXN0JDExIiwic3ViX2ZtdHR5X3Jlc3QkMjMiLCJmbXQkMTIiLCJzdWJfZm10dHlfcmVzdCQyNCIsImZtdHR5X3Jlc3QkMTIiLCJzdWJfZm10dHlfcmVzdCQyNSIsImZtdCQxMyIsInN1Yl9mbXR0eV9yZXN0JDI2IiwiZm10X3Jlc3QiLCJmbXRfcmVzdCQwIiwiZm10X3Jlc3QkMSIsImZtdF9yZXN0JDIiLCJmbXRfcmVzdCQzIiwiZm10X3Jlc3QkNCIsImZtdF9yZXN0JDUiLCJwcmVjJDQiLCJmbXR0eSQ2IiwiZm10X3Jlc3QkNiIsInByZWMkNSIsInByZWMkNiIsImZtdHR5JDciLCJmbXRfcmVzdCQ3IiwicHJlYyQ3IiwicHJlYyQ4IiwiZm10dHkkOCIsImZtdF9yZXN0JDgiLCJmbXR0eSQ5IiwiZm10X3Jlc3QkOSIsImZtdHR5JDEwIiwiZm10X3Jlc3QkMTAiLCJmbXR0eSQxMSIsImZtdF9yZXN0JDExIiwiZm10dHkkMTIiLCJmbXRfcmVzdCQxMiIsImZtdHR5JDEzIiwic3ViX2ZtdHR5MSIsImZtdF9yZXN0JDEzIiwic3ViX2ZtdHR5JDEiLCJmbXR0eSQxNCIsImZtdCQxNCIsImZtdF9yZXN0JDE0IiwiZm10dHkkMTUiLCJmbXQkMTUiLCJmbXRfcmVzdCQxNSIsImZtdHR5JDE2IiwiZm10JDE2IiwiZm10X3Jlc3QkMTYiLCJmbXR0eSQxNyIsImZtdCQxNyIsImZtdF9yZXN0JDE3IiwiZm9ybWF0dGluZ19nZW4iLCJmbXR0eTMiLCJmbXQzIiwiZm10MSQwIiwiZm10dHkyJDAiLCJmbXQyJDAiLCJmbXR0eTMkMCIsImZtdDMkMCIsImZtdHR5X3Jlc3QkMTMiLCJmbXRfcmVzdCQxOCIsImZtdHR5JDE4IiwiZm10JDE4IiwiZm10dHlfcmVzdCQxNCIsImZtdF9yZXN0JDE5IiwiZm10dHkkMTkiLCJmbXQkMTkiLCJmbXR0eV9yZXN0JDE1IiwiZm10X3Jlc3QkMjAiLCJmbXR0eSQyMCIsImZtdCQyMCIsInR5cGVfaWdub3JlZF9wYXJhbV9vbmUiLCJmbXR0eV9yZXN0JDE2IiwiZm10dHkkMjEiLCJmbXQkMjEiLCJzdWJfZm10dHkkMiIsInN1Yl9mbXR0eSQzIiwiZm10dHkkMjIiLCJmbXQkMjIiLCJzdWJfZm10dHkkNCIsInR5cGVfZm9ybWF0IiwicmVjYXN0IiwiZml4X3BhZGRpbmciLCJ3aWR0aCQwIiwiZml4X2ludF9wcmVjaXNpb24iLCJyZXMkMSIsInN0cmluZ190b19jYW1sX3N0cmluZyIsImZvcm1hdF9vZl9mY29udiIsInN5bWIiLCJ0cmFuc2Zvcm1faW50X2FsdCIsImRpZ2l0cyIsInB1dCIsImNvbnZlcnRfaW50IiwiY29udmVydF9pbnQzMiIsImNvbnZlcnRfbmF0aXZlaW50IiwiY29udmVydF9pbnQ2NCIsImNvbnZlcnRfZmxvYXQiLCJoZXgiLCJzaWduIiwiY2FtbF9zcGVjaWFsX3ZhbCIsInN0cmluZ19vZl9mbXR0eSIsIm1ha2VfcHJpbnRmJDAiLCJuZXdfYWNjIiwibWFrZV9wcmludGYiLCJtYWtlX3BhZGRpbmciLCJtYWtlX2ludF9wYWRkaW5nX3ByZWNpc2lvbiIsInAkMCIsInAkMSIsImFjYyQyIiwiYWNjJDMiLCJhY2MkNCIsImskMyIsImthY2MiLCJrJDQiLCJtYWtlX2lnbm9yZWRfcGFyYW0kMCIsIm1ha2VfY3VzdG9tJDAiLCJtYWtlX2ludmFsaWRfYXJnIiwibWFrZV9mcm9tX2ZtdHR5JDAiLCJtYWtlX2Zyb21fZm10dHkiLCJtYWtlX2N1c3RvbSIsIm1ha2VfaWdub3JlZF9wYXJhbSIsIm1ha2VfaXByaW50ZiQwIiwibWFrZV9pcHJpbnRmIiwiZm5fb2ZfcGFkZGluZ19wcmVjaXNpb24iLCJrb2MiLCJyZXN0JDI0IiwicmVzdCQyNSIsImZuX29mX2N1c3RvbV9hcml0eSQwIiwiZm5fb2ZfY3VzdG9tX2FyaXR5Iiwib3V0cHV0X2FjYyIsInAkMiIsInAkMyIsInAkNCIsImJ1ZnB1dF9hY2MiLCJzdHJwdXRfYWNjIiwiZmFpbHdpdGhfbWVzc2FnZSIsIm9wZW5fYm94X29mX3N0cmluZyIsImludmFsaWRfYm94IiwicGFyc2Vfc3BhY2VzIiwicGFyc2VfbHdvcmQiLCJwYXJzZV9pbnQiLCJ3c3RhcnQiLCJ3ZW5kIiwiYm94X25hbWUiLCJuc3RhcnQiLCJuZW5kIiwiaW5kZW50IiwiZXhwX2VuZCIsImJveF90eXBlIiwibWFrZV9wYWRkaW5nX2ZtdF9lYmIiLCJtYWtlX3BhZHByZWNfZm10X2ViYiIsImZtdF9lYmJfb2Zfc3RyaW5nIiwibGVnYWN5X2JlaGF2aW9yIiwiZmxhZyIsImxlZ2FjeV9iZWhhdmlvciQwIiwiaW52YWxpZF9mb3JtYXRfbWVzc2FnZSIsInVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCIsImVuZF9pbmQiLCJpbnZhbGlkX2Zvcm1hdF93aXRob3V0IiwiZXhwZWN0ZWRfY2hhcmFjdGVyIiwiZXhwZWN0ZWQiLCJhZGRfbGl0ZXJhbCIsImxpdF9zdGFydCIsInNpemUiLCJwYXJzZV9wb3NpdGl2ZSIsInN0cl9pbmQkMCIsInN0cl9pbmQkMSIsInBhcnNlX2ludGVnZXIiLCJuZXh0X2luZCIsImluY29tcGF0aWJsZV9mbGFnIiwicGN0X2luZCIsIm9wdGlvbiIsInN1YmZtdCIsImNvbXB1dGVfaW50X2NvbnYiLCJwbHVzIiwic3BhY2UiLCJwbHVzJDAiLCJzcGFjZSQwIiwic2VhcmNoX3N1YmZvcm1hdF9lbmQiLCJzdWJfZW5kIiwic3RyX2luZCQyIiwic3ViX2VuZCQwIiwic3RyX2luZCQzIiwic3ViX2VuZCQxIiwic3RyX2luZCQ0Iiwic3RyX2luZCQ1Iiwic3ViX2VuZCQyIiwic3RyX2luZCQ2Iiwic3RyX2luZCQ3IiwicGFyc2VfbWFnaWNfc2l6ZSIsInN0cl9pbmRfMSIsInN0cl9pbmRfMiIsInN0cl9pbmRfMyIsInBhcnNlIiwicGFyc2VfZ29vZF9icmVhayIsImZvcm1hdHRpbmdfbGl0JDAiLCJzdHJfaW5kXzQiLCJzdHJfaW5kXzUiLCJwYXJzZV90YWciLCJpc19vcGVuX3RhZyIsImluZCIsInN1Yl9zdHIiLCJzdWJfZm10Iiwic3ViX2Zvcm1hdCQwIiwiZm9ybWF0dGluZyQwIiwiZm9ybWF0dGluZyIsInBhcnNlX2ZsYWdzIiwibWludXMiLCJzZXRfZmxhZyIsIm5ld19pbmQiLCJwYXJzZV9hZnRlcl9wYWRkaW5nIiwicGFyc2VfbGl0ZXJhbCIsInBhcnNlX2FmdGVyX3ByZWNpc2lvbiIsInN5bWIkMCIsIm1pbnVzJDAiLCJwYXJzZV9jb252ZXJzaW9uIiwicGFyc2VfY29udiIsInBhZHByZWMiLCJwbHVzX3VzZWQiLCJoYXNoX3VzZWQiLCJzcGFjZV91c2VkIiwiaWduX3VzZWQiLCJwYWRfdXNlZCIsInByZWNfdXNlZCIsImdldF9wbHVzIiwiZ2V0X2hhc2giLCJnZXRfc3BhY2UiLCJnZXRfaWduIiwiZ2V0X3BhZCIsImdldF9wcmVjIiwiZ2V0X3BhZHByZWMiLCJnZXRfaW50X3BhZCIsImNoZWNrX25vXzAiLCJvcHRfb2ZfcGFkIiwid2lkdGgkMSIsImdldF9wYWRfb3B0IiwiZ2V0X3BhZHByZWNfb3B0IiwiZm10X3Jlc3VsdCIsImlnbm9yZWQkMiIsImNvdW50ZXIkMCIsImlnbm9yZWQkNiIsImlnbm9yZWQkNyIsImFkZF9yYW5nZSIsImZhaWxfc2luZ2xlX3BlcmNlbnQiLCJwYXJzZV9jaGFyX3NldF9jb250ZW50IiwicGFyc2VfY2hhcl9zZXRfYWZ0ZXJfY2hhciQwIiwicGFyc2VfY2hhcl9zZXRfYWZ0ZXJfY2hhciIsInJldmVyc2UiLCJjaGFyX3NldCQxIiwiaWdub3JlZCQ5IiwiY2hhcl9mb3JtYXQiLCJmbXRfcmVzdCQyMSIsImZtdF9yZXN0JDIyIiwicGFkJDkiLCJmbXRfcmVzdCQyMyIsImlnbm9yZWQkMTAiLCJmbXRfcmVzdCQyNCIsInBhZCQxMCIsImZtdF9yZXN0JDI1Iiwic3ViX2ZtdCQwIiwiZm10X3Jlc3QkMjYiLCJpZ25vcmVkJDExIiwiaWdub3JlZCQzIiwiaWdub3JlZCQ1IiwiaWdub3JlZCQ4Iiwic3BhY2UkMSIsImhhc2gkMSIsInBsdXMkMiIsImtpbmQiLCJpZ25vcmVkJDQiLCJpZ25vcmVkIiwiaWdub3JlZCQwIiwiaWdub3JlZCQxIiwicGx1cyQxIiwiaWduJDAiLCJmb3JtYXRfb2Zfc3RyaW5nX2ZtdHR5IiwiZm9ybWF0X29mX3N0cmluZ19mb3JtYXQiLCJrZnByaW50ZiIsImticHJpbnRmIiwiaWtmcHJpbnRmIiwiZnByaW50ZiIsImJwcmludGYiLCJpZnByaW50ZiIsImlicHJpbnRmIiwicHJpbnRmIiwiZXByaW50ZiIsImtzcHJpbnRmIiwic3ByaW50ZiIsImFzc29jMyIsInkyIiwieTEiLCJzcGxpdCQwIiwibWFrZV9zeW1saXN0IiwicHJlZml4Iiwic3VmZml4IiwiaGVscF9hY3Rpb24iLCJhZGRfaGVscCIsInNwZWNsaXN0IiwiYWRkMiIsInVzYWdlX2IiLCJlcnJtc2ciLCJkb2MiLCJzcGVjIiwia2V5IiwidXNhZ2Vfc3RyaW5nIiwidXNhZ2UiLCJib29sX29mX3N0cmluZ19vcHQkMCIsImludF9vZl9zdHJpbmdfb3B0JDAiLCJmbG9hdF9vZl9zdHJpbmdfb3B0IiwicGFyc2VfYW5kX2V4cGFuZF9hcmd2X2R5bmFtaWNfIiwiYWxsb3dfZXhwYW5kIiwiYXJndiIsImFub25mdW4iLCJpbml0cG9zIiwiY29udmVydF9lcnJvciIsInByb2duYW1lIiwiZm9sbG93JDAiLCJhY3Rpb24iLCJrZXl3b3JkIiwibm9fYXJnJDAiLCJmb2xsb3ciLCJub19hcmciLCJnZXRfYXJnJDAiLCJnZXRfYXJnIiwiY29uc3VtZV9hcmckMCIsImNvbnN1bWVfYXJnIiwidHJlYXRfYWN0aW9uJDAiLCJ0cmVhdF9hY3Rpb24iLCJmJDAiLCJmJDEiLCJyJDEiLCJmJDIiLCJyJDIiLCJhcmckMiIsImYkMyIsImFyZyQzIiwieCQxIiwiciQzIiwiYXJnJDQiLCJ4JDIiLCJzcGVjcyIsImYkNCIsImFyZyQ1IiwiZiQ1IiwiZiQ2IiwiZiQ3IiwiYXJnJDYiLCJuZXdhcmciLCJwYXJzZV9hbmRfZXhwYW5kX2FyZ3ZfZHluYW1pYyIsInBhcnNlX2FyZ3ZfZHluYW1pYyIsImN1cnJlbnQkMCIsInBhcnNlX2FyZ3YiLCJtc2ckMCIsIm1zZyQxIiwicGFyc2VfZHluYW1pYyIsInBhcnNlX2V4cGFuZCIsInNlY29uZF93b3JkIiwibG9vcCIsIm1heF9hcmdfbGVuIiwia3dkIiwicmVwbGFjZV9sZWFkaW5nX3RhYiIsImFsaWduIiwibGltaXQiLCJjb21wbGV0ZWQiLCJrc2QiLCJjdXRjb2wkMCIsInNwYWNlcyQwIiwiY3V0Y29sIiwia3dkX2xlbiIsInNwYWNlcyIsInJlYWRfYXV4IiwidHJpbSIsImZpbGUiLCJ3b3JkcyIsInN0YXNoIiwid29yZCIsInJlYWRfYXJnIiwicmVhZF9hcmcwIiwid3JpdGVfYXV4IiwiYXJncyIsIndyaXRlX2FyZyIsIndyaXRlX2FyZzAiLCJwcmludGVycyIsImZpZWxkIiwib3RoZXJfZmllbGRzIiwidXNlX3ByaW50ZXJzIiwiY29udiIsInRvX3N0cmluZ19kZWZhdWx0IiwiY2hhciQwIiwibGluZSIsImNoYXIkMSIsImxpbmUkMCIsImZpbGUkMCIsImNoYXIkMiIsImxpbmUkMSIsImZpbGUkMSIsImNvbnN0cnVjdG9yIiwidG9fc3RyaW5nJDciLCJwcmludCIsImZjdCIsImNhdGNoJDAiLCJyYXdfYmFja3RyYWNlX2VudHJpZXMiLCJidCIsImNvbnZlcnRfcmF3X2JhY2t0cmFjZSIsImZvcm1hdF9iYWNrdHJhY2Vfc2xvdCIsImlzX3JhaXNlIiwicHJpbnRfcmF3X2JhY2t0cmFjZSIsIm91dGNoYW4iLCJyYXdfYmFja3RyYWNlIiwiYmFja3RyYWNlIiwicHJpbnRfYmFja3RyYWNlIiwicmF3X2JhY2t0cmFjZV90b19zdHJpbmciLCJiYWNrdHJhY2Vfc2xvdF9pc19yYWlzZSIsImJhY2t0cmFjZV9zbG90X2lzX2lubGluZSIsImJhY2t0cmFjZV9zbG90X2xvY2F0aW9uIiwiYmFja3RyYWNlX3Nsb3RfZGVmbmFtZSIsImJhY2t0cmFjZV9zbG90cyIsImJhY2t0cmFjZV9zbG90c19vZl9yYXdfZW50cnkiLCJlbnRyeSIsInJhd19iYWNrdHJhY2VfbGVuZ3RoIiwiZ2V0X2JhY2t0cmFjZSIsInJlZ2lzdGVyX3ByaW50ZXIiLCJmbiIsIm9sZF9wcmludGVycyIsIm5ld19wcmludGVycyIsImV4bl9zbG90IiwiZXhuX3Nsb3RfaWQiLCJleG5fc2xvdF9uYW1lIiwiZXJyb3JzIiwiZGVmYXVsdF91bmNhdWdodF9leGNlcHRpb25faGFuIiwic3RhdHVzIiwidW5jYXVnaHRfZXhjZXB0aW9uX2hhbmRsZXIiLCJzZXRfdW5jYXVnaHRfZXhjZXB0aW9uX2hhbmRsZXIiLCJjb25zdCQwIiwiZmxpcCIsIm5lZ2F0ZSIsInByb3RlY3QiLCJmaW5hbGx5JDAiLCJ3b3JrIiwiZmluYWxseV9ub19leG4iLCJ3b3JrX2V4biIsIndvcmtfYnQiLCJwcmludF9zdGF0IiwiYWxsb2NhdGVkX2J5dGVzIiwibWEiLCJwcm8iLCJtaSIsImNyZWF0ZV9hbGFybSIsImRlbGV0ZV9hbGFybSIsIm51bGxfdHJhY2tlciIsInNhbXBsaW5nX3JhdGUiLCJ0cmFja2VyIiwiY2FsbHN0YWNrX3NpemUiLCJzdHJpbmciLCJieXRlcyIsInN1YnN0cmluZyIsInN1YmJ5dGVzIiwiZmlsZW5hbWUiLCJvdXRwdXQkMCIsImRpZ2VzdCIsImlucHV0JDAiLCJjaGFyX2hleCIsInRvX2hleCIsImZyb21faGV4IiwiZGlnaXQiLCJuZXdfc3RhdGUiLCJhc3NpZ24iLCJzdDEiLCJzdDIiLCJmdWxsX2luaXQiLCJzZWVkIiwic2VlZCQwIiwibWFrZSQzIiwibWFrZV9zZWxmX2luaXQiLCJjb3B5JDUiLCJiaXRzIiwiY3VydmFsIiwibmV3dmFsIiwibmV3dmFsMzAiLCJpbnQkMCIsImJvdW5kIiwiaW50MzIiLCJiMSIsImIyIiwiaW50NjQiLCJiMyIsIm5hdGl2ZWludCIsImZsb2F0JDAiLCJib29sIiwiYml0cyQwIiwiaW50JDEiLCJpbnQzMiQwIiwibmF0aXZlaW50JDAiLCJpbnQ2NCQwIiwiZmxvYXQkMSIsInNjYWxlIiwiYm9vbCQwIiwiZnVsbF9pbml0JDAiLCJpbml0JDQiLCJzZWxmX2luaXQiLCJnZXRfc3RhdGUiLCJzZXRfc3RhdGUiLCJvbmdvaW5nX3RyYXZlcnNhbCIsImZsaXBfb25nb2luZ190cmF2ZXJzYWwiLCJwYXJhbXMiLCJyYW5kb21pemVkX2RlZmF1bHQiLCJyYW5kb21pemVkIiwicmFuZG9taXplIiwiaXNfcmFuZG9taXplZCIsInBybmciLCJwb3dlcl8yX2Fib3ZlIiwiY3JlYXRlJDMiLCJpbml0aWFsX3NpemUiLCJyYW5kb20iLCJjbGVhciQyIiwicmVzZXQkMCIsImNvcHlfYnVja2V0bGlzdCIsImtleSQwIiwibmV4dCQwIiwiY29weSQ2IiwibGVuZ3RoJDQiLCJpbnNlcnRfYWxsX2J1Y2tldHMiLCJpbmRleGZ1biIsImlucGxhY2UiLCJvZGF0YSIsIm5kYXRhIiwibnNpemUiLCJuZGF0YV90YWlsIiwiY2VsbCQwIiwibmlkeCIsIm1hdGNoJDAiLCJyZXNpemUkMCIsIm9zaXplIiwiaXRlciQxMCIsImRvX2J1Y2tldCIsIm9sZF90cmF2IiwiZmlsdGVyX21hcF9pbnBsYWNlX2J1Y2tldCIsImZpbHRlcl9tYXBfaW5wbGFjZSIsImZvbGQkNCIsImIkMCIsImJ1Y2tldF9sZW5ndGgiLCJzdGF0cyIsIm1ibCIsImhpc3RvIiwidG9fc2VxJDkiLCJ0YmxfZGF0YSIsImJ1Y2siLCJidWNrJDAiLCJidWNrJDEiLCJ0b19zZXFfa2V5cyIsInRvX3NlcV92YWx1ZXMiLCJrZXlfaW5kZXgiLCJidWNrZXQiLCJrMSIsIm5leHQxIiwiazIiLCJuZXh0MiIsImszIiwiZDMiLCJuZXh0MyIsImZpbmRfYWxsIiwiZmluZF9pbl9idWNrZXQiLCJyZXBsYWNlIiwicmVwbGFjZV9zZXEiLCJjb3B5Iiwic3oiLCJoYXNoX3BhcmFtIiwic2VlZGVkX2hhc2giLCJhZGQkMCIsImZpbmQkMCIsImZpbmRfb3B0JDAiLCJmaW5kX2FsbCQwIiwibWVtJDIiLCJhZGRfc2VxJDIiLCJvZl9zZXEkNyIsInJlYnVpbGQiLCJ3ZWFrX2NyZWF0ZSIsImxlbmd0aCQ1IiwicmFpc2VfaWZfaW52YWxpZF9vZmZzZXQkMCIsInNldCQwIiwiZ2V0JDEiLCJnZXRfY29weSIsImNoZWNrJDAiLCJibGl0JDQiLCJmaWxsJDIiLCJhciIsImVtcHR5YnVja2V0IiwiZ2V0X2luZGV4Iiwic3okMCIsInN6JDEiLCJjb3VudF9idWNrZXQiLCJhZGRfYXV4Iiwic2V0dGVyIiwiaW5kZXgiLCJidWNrZXQkMCIsImhhc2hlcyIsIm5ld3N6IiwibmV3YnVja2V0JDAiLCJuZXdoYXNoZXMiLCJoYnVja2V0IiwicHJldl9sZW4iLCJsaXZlIiwiaiQyIiwibmV3YnVja2V0IiwibmV3dCIsIm9iIiwib2giLCJzZXR0ZXIkMCIsIm5iIiwibmkiLCJmaW5kX29yIiwiaWZub3Rmb3VuZCIsImZpbmRfc2hhZG93IiwiaWZmb3VuZCIsImxlbnMiLCJ0b3RsZW4iLCJpZCQwIiwidW5rbm93biIsInBwX2VucXVldWUiLCJ0b2tlbiIsInBwX2luZmluaXR5IiwicHBfb3V0cHV0X3N0cmluZyIsInBwX291dHB1dF9uZXdsaW5lIiwiZm9ybWF0X3BwX3RleHQiLCJ0ZXh0IiwiZm9ybWF0X3N0cmluZyIsImJyZWFrX25ld19saW5lIiwicmVhbF9pbmRlbnQiLCJicmVha19saW5lIiwiYnJlYWtfc2FtZV9saW5lIiwiYWR2YW5jZV9sZWZ0Iiwic2l6ZSQwIiwicGVuZGluZ19jb3VudCIsInNpemUkMSIsInRhYnMiLCJhZGRfdGFiIiwibHMiLCJ0YWdfbmFtZSIsIm1hcmtlciIsImJyZWFrcyIsImZpdHMiLCJvZmYiLCJib3hfdHlwZSQwIiwib2ZmJDAiLCJpbnNlcnRpb25fcG9pbnQiLCJ0YWJzJDAiLCJmaXJzdCIsImhlYWQiLCJ0YWIiLCJvZmYkMSIsImluc2VydGlvbl9wb2ludCQwIiwid2lkdGgkMiIsImJveF90eXBlJDEiLCJ0Ym94IiwidGFnX25hbWUkMCIsIm1hcmtlciQwIiwiZW5xdWV1ZV9hZHZhbmNlIiwiZW5xdWV1ZV9zdHJpbmdfYXMiLCJpbml0aWFsaXplX3NjYW5fc3RhY2siLCJzdGFjayIsInF1ZXVlX2VsZW0iLCJzZXRfc2l6ZSIsImxlZnRfdG90YWwiLCJzY2FuX3B1c2giLCJlbGVtIiwicHBfb3Blbl9ib3hfZ2VuIiwiYnJfdHkiLCJwcF9jbG9zZV9ib3giLCJwcF9vcGVuX3N0YWciLCJwcF9jbG9zZV9zdGFnIiwicHBfb3Blbl90YWciLCJwcF9jbG9zZV90YWciLCJwcF9zZXRfcHJpbnRfdGFncyIsInBwX3NldF9tYXJrX3RhZ3MiLCJwcF9nZXRfcHJpbnRfdGFncyIsInBwX2dldF9tYXJrX3RhZ3MiLCJwcF9zZXRfdGFncyIsInBwX2dldF9mb3JtYXR0ZXJfc3RhZ19mdW5jdGlvbiIsInBwX3NldF9mb3JtYXR0ZXJfc3RhZ19mdW5jdGlvbiIsInBjdCIsInBvdCIsIm1jdCIsIm1vdCIsInBwX3Jpbml0IiwicHBfZmx1c2hfcXVldWUiLCJwcF9wcmludF9hc19zaXplIiwicHBfcHJpbnRfYXMiLCJpc2l6ZSIsInBwX3ByaW50X3N0cmluZyIsInBwX3ByaW50X2ludCIsInBwX3ByaW50X2Zsb2F0IiwicHBfcHJpbnRfYm9vbCIsInBwX3ByaW50X2NoYXIiLCJwcF9vcGVuX2hib3giLCJwcF9vcGVuX3Zib3giLCJwcF9vcGVuX2h2Ym94IiwicHBfb3Blbl9ob3Zib3giLCJwcF9vcGVuX2JveCIsInBwX3ByaW50X25ld2xpbmUiLCJwcF9wcmludF9mbHVzaCIsInBwX2ZvcmNlX25ld2xpbmUiLCJwcF9wcmludF9pZl9uZXdsaW5lIiwicHBfcHJpbnRfY3VzdG9tX2JyZWFrIiwicHBfcHJpbnRfYnJlYWsiLCJwcF9wcmludF9zcGFjZSIsInBwX3ByaW50X2N1dCIsInBwX29wZW5fdGJveCIsInBwX2Nsb3NlX3Rib3giLCJwcF9wcmludF90YnJlYWsiLCJwcF9wcmludF90YWIiLCJwcF9zZXRfdGFiIiwicHBfc2V0X21heF9ib3hlcyIsInBwX2dldF9tYXhfYm94ZXMiLCJwcF9vdmVyX21heF9ib3hlcyIsInBwX3NldF9lbGxpcHNpc190ZXh0IiwicHBfZ2V0X2VsbGlwc2lzX3RleHQiLCJwcF9saW1pdCIsInBwX3NldF9tYXhfaW5kZW50IiwicHBfZ2V0X21heF9pbmRlbnQiLCJwcF9zZXRfbWFyZ2luIiwibmV3X21heF9pbmRlbnQiLCJ2YWxpZGF0ZV9nZW9tZXRyeSIsIm1hcmdpbiIsIm1heF9pbmRlbnQiLCJjaGVja19nZW9tZXRyeSIsImdlb21ldHJ5IiwicHBfZ2V0X21hcmdpbiIsInBwX3NldF9mdWxsX2dlb21ldHJ5IiwicHBfc2V0X2dlb21ldHJ5IiwicHBfc2FmZV9zZXRfZ2VvbWV0cnkiLCJwcF9nZXRfZ2VvbWV0cnkiLCJwcF91cGRhdGVfZ2VvbWV0cnkiLCJwcF9zZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMiLCJwcF9nZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMiLCJwcF9zZXRfZm9ybWF0dGVyX291dHB1dF9mdW5jdGkiLCJwcF9nZXRfZm9ybWF0dGVyX291dHB1dF9mdW5jdGkiLCJkaXNwbGF5X25ld2xpbmUiLCJibGFua19saW5lIiwiZGlzcGxheV9pbmRlbnQiLCJwcF9zZXRfZm9ybWF0dGVyX291dF9jaGFubmVsIiwiZGVmYXVsdF9wcF9tYXJrX29wZW5fdGFnIiwiZGVmYXVsdF9wcF9tYXJrX2Nsb3NlX3RhZyIsImRlZmF1bHRfcHBfcHJpbnRfb3Blbl90YWciLCJkZWZhdWx0X3BwX3ByaW50X2Nsb3NlX3RhZyIsInBwX21ha2VfZm9ybWF0dGVyIiwicHBfcXVldWUiLCJzeXNfdG9rIiwic2Nhbl9zdGFjayIsImZvcm1hdHRlcl9vZl9vdXRfZnVuY3Rpb25zIiwib3V0X2Z1bnMiLCJtYWtlX2Zvcm1hdHRlciIsInBwZiIsImZvcm1hdHRlcl9vZl9vdXRfY2hhbm5lbCIsImZvcm1hdHRlcl9vZl9idWZmZXIiLCJwcF9idWZmZXJfc2l6ZSIsInBwX21ha2VfYnVmZmVyIiwic3RkYnVmIiwic3RkX2Zvcm1hdHRlciIsImVycl9mb3JtYXR0ZXIiLCJzdHJfZm9ybWF0dGVyIiwiZmx1c2hfYnVmZmVyX2Zvcm1hdHRlciIsImZsdXNoX3N0cl9mb3JtYXR0ZXIiLCJtYWtlX3N5bWJvbGljX291dHB1dF9idWZmZXIiLCJjbGVhcl9zeW1ib2xpY19vdXRwdXRfYnVmZmVyIiwic29iIiwiZ2V0X3N5bWJvbGljX291dHB1dF9idWZmZXIiLCJmbHVzaF9zeW1ib2xpY19vdXRwdXRfYnVmZmVyIiwiaXRlbXMiLCJhZGRfc3ltYm9saWNfb3V0cHV0X2l0ZW0iLCJpdGVtIiwiZm9ybWF0dGVyX29mX3N5bWJvbGljX291dHB1dF9iIiwib3Blbl9oYm94Iiwib3Blbl92Ym94Iiwib3Blbl9odmJveCIsIm9wZW5faG92Ym94Iiwib3Blbl9ib3giLCJjbG9zZV9ib3giLCJvcGVuX3RhZyIsImNsb3NlX3RhZyIsIm9wZW5fc3RhZyIsImNsb3NlX3N0YWciLCJwcmludF9hcyIsInByaW50X3N0cmluZyQwIiwicHJpbnRfaW50JDAiLCJwcmludF9mbG9hdCQwIiwicHJpbnRfY2hhciQwIiwicHJpbnRfYm9vbCIsInByaW50X2JyZWFrIiwicHJpbnRfY3V0IiwicHJpbnRfc3BhY2UiLCJmb3JjZV9uZXdsaW5lIiwicHJpbnRfZmx1c2giLCJwcmludF9uZXdsaW5lJDAiLCJwcmludF9pZl9uZXdsaW5lIiwib3Blbl90Ym94IiwiY2xvc2VfdGJveCIsInByaW50X3RicmVhayIsInNldF90YWIiLCJwcmludF90YWIiLCJzZXRfbWFyZ2luIiwiZ2V0X21hcmdpbiIsInNldF9tYXhfaW5kZW50IiwiZ2V0X21heF9pbmRlbnQiLCJzZXRfZ2VvbWV0cnkiLCJzYWZlX3NldF9nZW9tZXRyeSIsImdldF9nZW9tZXRyeSIsInVwZGF0ZV9nZW9tZXRyeSIsInNldF9tYXhfYm94ZXMiLCJnZXRfbWF4X2JveGVzIiwib3Zlcl9tYXhfYm94ZXMiLCJzZXRfZWxsaXBzaXNfdGV4dCIsImdldF9lbGxpcHNpc190ZXh0Iiwic2V0X2Zvcm1hdHRlcl9vdXRfY2hhbm5lbCIsInNldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyIsImdldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyIsInNldF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyIsImdldF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyIsInNldF9mb3JtYXR0ZXJfc3RhZ19mdW5jdGlvbnMiLCJnZXRfZm9ybWF0dGVyX3N0YWdfZnVuY3Rpb25zIiwic2V0X3ByaW50X3RhZ3MiLCJnZXRfcHJpbnRfdGFncyIsInNldF9tYXJrX3RhZ3MiLCJnZXRfbWFya190YWdzIiwic2V0X3RhZ3MiLCJwcF9wcmludF9saXN0IiwicHBfdiIsIm9wdCQwIiwicHBfc2VwIiwidnMiLCJvcHQkMSIsInBwX3ByaW50X3NlcSIsInNlcSQxIiwic2VxJDIiLCJwcF9wcmludF90ZXh0IiwicHBfcHJpbnRfb3B0aW9uIiwicHBfcHJpbnRfcmVzdWx0IiwiY29tcHV0ZV90YWciLCJ0YWdfYWNjIiwib3V0cHV0X2Zvcm1hdHRpbmdfbGl0Iiwib3V0cHV0X2FjYyQwIiwiYnR5IiwicCQ1IiwicCQ2Iiwic3RycHV0X2FjYyQwIiwia2ZwcmludGYkMCIsImlrZnByaW50ZiQwIiwiaWZwcmludGYkMCIsImZwcmludGYkMCIsInByaW50ZiQwIiwiZXByaW50ZiQwIiwia2RwcmludGYiLCJkcHJpbnRmIiwia3ByaW50ZiIsInNwcmludGYkMCIsImthc3ByaW50ZiIsImFzcHJpbnRmIiwiZmx1c2hfc3RhbmRhcmRfZm9ybWF0dGVycyIsInBwX3NldF9hbGxfZm9ybWF0dGVyX291dHB1dF9mdSIsInBwX2dldF9hbGxfZm9ybWF0dGVyX291dHB1dF9mdSIsInNldF9hbGxfZm9ybWF0dGVyX291dHB1dF9mdW5jdCIsImdldF9hbGxfZm9ybWF0dGVyX291dHB1dF9mdW5jdCIsImJwcmludGYkMCIsInBwX3NldF9mb3JtYXR0ZXJfdGFnX2Z1bmN0aW9ucyIsInN0cmluZ2lmeSIsInBwX2dldF9mb3JtYXR0ZXJfdGFnX2Z1bmN0aW9ucyIsImZ1bnMiLCJtYXJrX29wZW5fdGFnIiwibWFya19jbG9zZV90YWciLCJwcmludF9vcGVuX3RhZyIsInByaW50X2Nsb3NlX3RhZyIsInNldF9mb3JtYXR0ZXJfdGFnX2Z1bmN0aW9ucyIsImdldF9mb3JtYXR0ZXJfdGFnX2Z1bmN0aW9ucyIsIm51bGxfY2hhciIsIm5leHRfY2hhciIsImliIiwicGVla19jaGFyIiwiY2hlY2tlZF9wZWVrX2NoYXIiLCJlbmRfb2ZfaW5wdXQiLCJiZWdpbm5pbmdfb2ZfaW5wdXQiLCJuYW1lX29mX2lucHV0IiwiY2hhcl9jb3VudCIsInJlc2V0X3Rva2VuIiwiaW52YWxpZGF0ZV9jdXJyZW50X2NoYXIiLCJ0b2tlbl9zdHJpbmciLCJ0b2tlbl9idWZmZXIiLCJza2lwX2NoYXIiLCJpZ25vcmVfY2hhciIsInN0b3JlX2NoYXIiLCJkZWZhdWx0X3Rva2VuX2J1ZmZlcl9zaXplIiwiY3JlYXRlJDQiLCJpbmFtZSIsImZyb21fc3RyaW5nJDEiLCJmcm9tX2Z1bmN0aW9uJDAiLCJzY2FuX2Nsb3NlX2F0X2VuZCIsInNjYW5fcmFpc2VfYXRfZW5kIiwiZnJvbV9pYyIsInNjYW5fY2xvc2VfaWMiLCJlb2YiLCJzdGRpYiIsIm9wZW5faW5fZmlsZSIsImZyb21fZmlsZSIsImZyb21fZmlsZV9iaW4iLCJmcm9tX2NoYW5uZWwkMCIsImNsb3NlX2luJDAiLCJpYyQwIiwibWVtbyIsIm1lbW9fZnJvbV9pYyIsIm1lbW9fZnJvbV9jaGFubmVsIiwiYmFkX2lucHV0IiwiYmFkX2lucHV0X2VzY2FwZSIsImJhZF90b2tlbl9sZW5ndGgiLCJtZXNzYWdlIiwiYmFkX2Zsb2F0IiwiYmFkX2hleF9mbG9hdCIsImNoYXJhY3Rlcl9taXNtYXRjaCIsImNpIiwiY2hlY2tfdGhpc19jaGFyIiwiY2hlY2tfY2hhciIsInRva2VuX2NoYXIiLCJ0b2tlbl9ib29sIiwiaW50ZWdlcl9jb252ZXJzaW9uX29mX2NoYXIiLCJ0b2tlbl9pbnRfbGl0ZXJhbCIsInRva2VuX2Zsb2F0Iiwic2Nhbl9kZWNpbWFsX2RpZ2l0X3N0YXIiLCJzY2FuX3Vuc2lnbmVkX2RlY2ltYWxfaW50Iiwic2Nhbl9kaWdpdF9wbHVzIiwiYmFzaXMiLCJkaWdpdHAiLCJ3aWR0aCQzIiwiaXNfYmluYXJ5X2RpZ2l0Iiwic2Nhbl9iaW5hcnlfaW50IiwiaXNfb2N0YWxfZGlnaXQiLCJzY2FuX29jdGFsX2ludCIsImlzX2hleGFfZGlnaXQiLCJzY2FuX2hleGFkZWNpbWFsX2ludCIsInNjYW5fc2lnbiIsInNjYW5fb3B0aW9uYWxseV9zaWduZWRfZGVjaW1hbCIsInNjYW5faW50X2NvbnZlcnNpb24iLCJzY2FuX2ZyYWN0aW9uYWxfcGFydCIsInNjYW5fZXhwb25lbnRfcGFydCIsInNjYW5fZmxvYXQiLCJwcmVjaXNpb24iLCJwcmVjaXNpb24kMCIsImNoZWNrX2Nhc2VfaW5zZW5zaXRpdmVfc3RyaW5nIiwic2Nhbl9oZXhfZmxvYXQiLCJ3aWR0aCQ0Iiwid2lkdGgkNSIsIndpZHRoJDYiLCJ3aWR0aCQxMCIsIndpZHRoJDciLCJ3aWR0aCQ4Iiwid2lkdGgkOSIsInNjYW5fY2FtbF9mbG9hdF9yZXN0Iiwid2lkdGhfcHJlY2lzaW9uIiwiZnJhY193aWR0aCIsInNjYW5fY2FtbF9mbG9hdCIsInNjYW5fc3RyaW5nIiwic3RwIiwic2Nhbl9jaGFyIiwiaGV4YWRlY2ltYWxfdmFsdWVfb2ZfY2hhciIsImNoZWNrX25leHRfY2hhciIsImNoZWNrX25leHRfY2hhcl9mb3JfY2hhciIsImNoZWNrX25leHRfY2hhcl9mb3Jfc3RyaW5nIiwic2Nhbl9iYWNrc2xhc2hfY2hhciIsImMwIiwiZ2V0X2RpZ2l0IiwiZ2V0X2RpZ2l0JDAiLCJjMSQwIiwiYzIkMCIsInNjYW5fY2FtbF9jaGFyIiwiZmluZF9zdG9wIiwic2Nhbl9jYW1sX3N0cmluZyIsImZpbmRfc3RvcCQwIiwic2tpcF9zcGFjZXMiLCJzY2FuX2NoYXJzX2luX2NoYXJfc2V0Iiwic2Nhbl9pbmRpYyIsInNjYW5fY2hhcnMiLCJzY2FuZl9iYWRfaW5wdXQiLCJnZXRfY291bnRlciIsIndpZHRoX29mX3BhZF9vcHQiLCJzdG9wcGVyX29mX2Zvcm1hdHRpbmdfbGl0IiwiZm10aW5nIiwidGFrZV9mb3JtYXRfcmVhZGVycyQwIiwidGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyQwIiwicmVhZGVyIiwibmV3X2siLCJyZWFkZXJzX3Jlc3QiLCJ0YWtlX2Zvcm1hdF9yZWFkZXJzIiwiZm10JDIzIiwiZm10JDI0IiwiZm10JDI1IiwidGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyIsIm1ha2Vfc2NhbmYiLCJyZWFkZXJzIiwic2NhbiQwIiwic3RyX3Jlc3QiLCJwYWRfcHJlY19zY2FuZiIsInNjYW4kMSIsInNjYW4kMiIsInNjYW4iLCJzY2FuJDMiLCJzY2FuJDQiLCJjb252JDAiLCJzY2FuJDUiLCJjb252JDEiLCJzY2FuJDYiLCJjb252JDIiLCJzY2FuJDciLCJzY2FuJDgiLCJmbXRpbmdfbGl0JDAiLCJzdHAkMCIsInMkMiIsInN0cl9yZXN0JDAiLCJyZXN0JDI2IiwiYXJnX3Jlc3QiLCJrc2NhbmYiLCJlZiIsImFwcGx5IiwiYXJncyQwIiwiZXhjIiwiYnNjYW5mIiwia3NzY2FuZiIsInNzY2FuZiIsInNjYW5mIiwiYnNjYW5mX2Zvcm1hdCIsImZvcm1hdCIsInNzY2FuZl9mb3JtYXQiLCJmb3JtYXRfZnJvbV9zdHJpbmciLCJ1bmVzY2FwZWQiLCJrZnNjYW5mIiwiZnNjYW5mIiwicmVnaXN0ZXIiLCJyZWdpc3Rlcl9leGNlcHRpb24iLCJvJDAiLCJwYXJhbXMkMCIsImluaXRpYWxfb2JqZWN0X3NpemUiLCJkdW1teV9pdGVtIiwidGFnIiwiY29tcGFyZSQxMyIsImNvbXBhcmUkMTQiLCJjb21wYXJlJDE1IiwiZHVtbXlfdGFibGUiLCJ0YWJsZV9jb3VudCIsImR1bW15X21ldCIsImZpdF9zaXplIiwibmV3X3RhYmxlIiwicHViX2xhYmVscyIsIm1ldGhvZHMiLCJyZXNpemUkMSIsImFycmF5IiwibmV3X3NpemUiLCJvbGRfc2l6ZSIsIm5ld19idWNrIiwibWV0aG9kX2NvdW50IiwiaW5zdF92YXJfY291bnQiLCJuZXdfbWV0aG9kIiwidGFibGUiLCJnZXRfbWV0aG9kX2xhYmVsIiwibGFiZWwiLCJnZXRfbWV0aG9kX2xhYmVscyIsIm5hbWVzIiwic2V0X21ldGhvZCIsImVsZW1lbnQiLCJnZXRfbWV0aG9kIiwidG9fbGlzdCQzIiwiYXJyIiwibmFycm93IiwidmFycyIsInZpcnRfbWV0aHMiLCJjb25jcl9tZXRocyIsInZhcnMkMCIsInZpcnRfbWV0aHMkMCIsImNvbmNyX21ldGhzJDAiLCJ2aXJ0X21ldGhfbGFicyIsImNvbmNyX21ldGhfbGFicyIsImxhYiIsInR2YXJzIiwiYnlfbmFtZSIsImJ5X2xhYmVsIiwibWV0IiwiaG0iLCJ3aWRlbiIsInNhdmVkX3ZhcnMiLCJzYXZlZF9oaWRkZW5fbWV0aHMiLCJuZXdfc2xvdCIsIm5ld192YXJpYWJsZSIsInRvX2FycmF5IiwibmV3X21ldGhvZHNfdmFyaWFibGVzIiwibWV0aHMiLCJ2YWxzIiwibWV0aHMkMCIsIm5tZXRocyIsIm52YWxzIiwiZ2V0X3ZhcmlhYmxlIiwiZ2V0X3ZhcmlhYmxlcyIsImFkZF9pbml0aWFsaXplciIsImNyZWF0ZV90YWJsZSIsInB1YmxpY19tZXRob2RzIiwidGFncyIsImluaXRfY2xhc3MiLCJpbmhlcml0cyIsImNsYSIsInN1cGVyJDAiLCJubSIsIm1ha2VfY2xhc3MiLCJwdWJfbWV0aHMiLCJjbGFzc19pbml0IiwiZW52X2luaXQiLCJtYWtlX2NsYXNzX3N0b3JlIiwiaW5pdF90YWJsZSIsImR1bW15X2NsYXNzIiwibG9jIiwidW5kZWYiLCJjcmVhdGVfb2JqZWN0IiwiY3JlYXRlX29iamVjdF9vcHQiLCJvYmpfMCIsIml0ZXJfZiIsInJ1bl9pbml0aWFsaXplcnMiLCJpbml0cyIsInJ1bl9pbml0aWFsaXplcnNfb3B0IiwiY3JlYXRlX29iamVjdF9hbmRfcnVuX2luaXRpYWxpIiwiZ2V0X2RhdGEkMCIsImJ1aWxkX3BhdGgiLCJrZXlzIiwibG9va3VwX3RhYmxlcyIsInJvb3QiLCJ0YWJsZXMkMiIsInRhYmxlcyQwIiwidGFibGVzJDEiLCJuZXdfY2FjaGUiLCJzZXRfbWV0aG9kcyIsImNsbyIsImNsbyQwIiwibiQyIiwibiQzIiwibiQ0IiwibiQ1IiwibiQ2IiwieCQzIiwibiQ3IiwieCQ0IiwibiQ4IiwibiQ5IiwieCQ1IiwiZiQ4IiwiZSQyIiwibiQxMCIsIngkNiIsImYkOSIsIm4kMTEiLCJ4JDciLCJuJDEyIiwieCQ4IiwibiQxMyIsIm4kMTQiLCJlJDMiLCJuJDE1IiwibSQyIiwieCQ5IiwibSQzIiwibiQxNiIsIm0kNCIsImUkNCIsIm4kMTciLCJtJDUiLCJuJDE4Iiwic3RhdHMkMCIsImluaXRpYWxfYnVmZmVyIiwiYnVmZmVyIiwiYnVmcG9zIiwicmVzZXRfYnVmZmVyIiwic3RvcmUiLCJuZXdidWZmZXIiLCJnZXRfc3RyaW5nIiwibWFrZV9sZXhlciIsImtleXdvcmRzIiwia3dkX3RhYmxlIiwiaWRlbnRfb3Jfa2V5d29yZCIsImtleXdvcmRfb3JfZXJyb3IiLCJjb21tZW50IiwiZXNjYXBlIiwiZW5kX2V4cG9uZW50X3BhcnQiLCJleHBvbmVudF9wYXJ0IiwibnVtYmVyIiwiaWRlbnQyIiwibmVnX251bWJlciIsIm5leHRfdG9rZW4kMCIsIm1heWJlX2NvbW1lbnQiLCJuZXh0X3Rva2VuIiwiaGtleSIsImNsZWFuIiwiaW5zZXJ0X2J1Y2tldCIsImNvbnRhaW5lciIsInJlbW92ZV9idWNrZXQiLCJoayIsInJlcGxhY2VfYnVja2V0IiwibmV3X2QiLCJidWNrZXRfbGVuZ3RoX2FsaXZlIiwic3RhdHNfYWxpdmUiLCJjcmVhdGUkNSIsImdldF9rZXkkMCIsImdldF9rZXlfY29weSQwIiwic2V0X2tleSQwIiwidW5zZXRfa2V5JDAiLCJjaGVja19rZXkkMCIsImJsaXRfa2V5JDAiLCJnZXRfZGF0YSQxIiwiZ2V0X2RhdGFfY29weSIsInNldF9kYXRhIiwidW5zZXRfZGF0YSIsImNoZWNrX2RhdGEiLCJibGl0X2RhdGEiLCJzZXRfa2V5X2RhdGEiLCJjcmVhdGUkNiIsImdldF9rZXkxIiwiZ2V0X2tleTFfY29weSIsInNldF9rZXkxIiwidW5zZXRfa2V5MSIsImNoZWNrX2tleTEiLCJnZXRfa2V5MiIsImdldF9rZXkyX2NvcHkiLCJzZXRfa2V5MiIsInVuc2V0X2tleTIiLCJjaGVja19rZXkyIiwiYmxpdF9rZXkxIiwiYmxpdF9rZXkyIiwiYmxpdF9rZXkxMiIsImdldF9kYXRhJDIiLCJnZXRfZGF0YV9jb3B5JDAiLCJzZXRfZGF0YSQwIiwidW5zZXRfZGF0YSQwIiwiY2hlY2tfZGF0YSQwIiwiYmxpdF9kYXRhJDAiLCJrMiQwIiwiazEkMCIsImNyZWF0ZSQ3IiwibGVuZ3RoJDYiLCJnZXRfa2V5JDEiLCJnZXRfa2V5X2NvcHkkMSIsInNldF9rZXkkMSIsInVuc2V0X2tleSQxIiwiY2hlY2tfa2V5JDEiLCJibGl0X2tleSQxIiwiZ2V0X2RhdGEkMyIsImdldF9kYXRhX2NvcHkkMSIsInNldF9kYXRhJDEiLCJ1bnNldF9kYXRhJDEiLCJjaGVja19kYXRhJDEiLCJibGl0X2RhdGEkMSIsImtpIiwiazAiLCJnZW5lcmljX2Jhc2VuYW1lIiwiaXNfZGlyX3NlcCIsImdlbmVyaWNfZGlybmFtZSIsImlzX3JlbGF0aXZlIiwiaXNfaW1wbGljaXQiLCJjaGVja19zdWZmaXgiLCJzdWZmIiwiY2hvcF9zdWZmaXhfb3B0IiwibGVuX3MiLCJsZW5fZiIsInF1b3RlIiwicXVvdGVfY29tbWFuZCIsImJhc2VuYW1lIiwiZGlybmFtZSIsImlzX2Rpcl9zZXAkMCIsImlzX3JlbGF0aXZlJDAiLCJpc19pbXBsaWNpdCQwIiwiY2hlY2tfc3VmZml4JDAiLCJjaG9wX3N1ZmZpeF9vcHQkMCIsInRlbXBfZGlyX25hbWUiLCJxdW90ZSQwIiwiYWRkX2JzIiwibG9vcCQwIiwibG9vcF9icyIsInF1b3RlX2NtZF9maWxlbmFtZSIsInF1b3RlX2NvbW1hbmQkMCIsImRyaXZlX2FuZF9wYXRoIiwiZGlybmFtZSQwIiwicGF0aCIsImRyaXZlIiwiZGlyIiwiYmFzZW5hbWUkMCIsImJhc2VuYW1lJDEiLCJkaXJuYW1lJDEiLCJudWxsJDMiLCJjdXJyZW50X2Rpcl9uYW1lJDIiLCJwYXJlbnRfZGlyX25hbWUkMiIsImRpcl9zZXAkMiIsImlzX2Rpcl9zZXAkMSIsImlzX3JlbGF0aXZlJDEiLCJpc19pbXBsaWNpdCQxIiwiY2hlY2tfc3VmZml4JDEiLCJjaG9wX3N1ZmZpeF9vcHQkMSIsInRlbXBfZGlyX25hbWUkMCIsInF1b3RlJDEiLCJxdW90ZV9jb21tYW5kJDEiLCJiYXNlbmFtZSQyIiwiZGlybmFtZSQyIiwiY29uY2F0JDMiLCJjaG9wX3N1ZmZpeCIsImV4dGVuc2lvbl9sZW4iLCJleHRlbnNpb24iLCJjaG9wX2V4dGVuc2lvbiIsInJlbW92ZV9leHRlbnNpb24iLCJwcm5nJDAiLCJ0ZW1wX2ZpbGVfbmFtZSIsInRlbXBfZGlyIiwicm5kIiwiY3VycmVudF90ZW1wX2Rpcl9uYW1lIiwic2V0X3RlbXBfZGlyX25hbWUiLCJnZXRfdGVtcF9kaXJfbmFtZSIsInRlbXBfZmlsZSIsInRyeV9uYW1lIiwiY291bnRlciQxIiwib3Blbl90ZW1wX2ZpbGUiLCJzdGgkMCIsInBlcm1zIiwic3RoJDEiLCJhZGQkMSIsInN1YiQ0IiwibmVnIiwiY29uaiIsIm11bCIsImRpdiIsImludiIsIm5vcm0yIiwibm9ybSIsInEkMCIsInBvbGFyIiwic3FydCIsInckMCIsImV4cCIsImxvZyIsInBvdyIsImZsb2F0MzIiLCJmbG9hdDY0IiwiaW50OF9zaWduZWQiLCJpbnQ4X3Vuc2lnbmVkIiwiaW50MTZfc2lnbmVkIiwiaW50MTZfdW5zaWduZWQiLCJpbnQzMiQxIiwiaW50NjQkMSIsImludCQyIiwibmF0aXZlaW50JDEiLCJjb21wbGV4MzIiLCJjb21wbGV4NjQiLCJraW5kX3NpemVfaW5fYnl0ZXMiLCJjX2xheW91dCIsImZvcnRyYW5fbGF5b3V0IiwiY2xvb3AiLCJpZHgiLCJjb2wiLCJmbG9vcCIsImluaXQkNSIsImxheW91dCIsImRpbXMiLCJkbGVuIiwic2l6ZV9pbl9ieXRlcyIsImNyZWF0ZSQ4IiwiZ2V0JDIiLCJzZXQkMSIsInNpemVfaW5fYnl0ZXMkMCIsIm9mX3ZhbHVlIiwiY3JlYXRlJDkiLCJkaW0iLCJzaXplX2luX2J5dGVzJDEiLCJzbGljZSIsImluaXQkNiIsIm9mX2FycmF5IiwiYmEiLCJjcmVhdGUkMTAiLCJkaW0xIiwiZGltMiIsInNpemVfaW5fYnl0ZXMkMiIsInNsaWNlX2xlZnQiLCJzbGljZV9yaWdodCIsImluaXQkNyIsIm9mX2FycmF5JDAiLCJyb3ciLCJjcmVhdGUkMTEiLCJkaW0zIiwic2l6ZV9pbl9ieXRlcyQzIiwic2xpY2VfbGVmdF8xIiwic2xpY2VfcmlnaHRfMSIsInNsaWNlX2xlZnRfMiIsInNsaWNlX3JpZ2h0XzIiLCJpbml0JDgiLCJvZl9hcnJheSQxIiwiYXJyYXkwX29mX2dlbmFycmF5IiwiYXJyYXkxX29mX2dlbmFycmF5IiwiYXJyYXkyX29mX2dlbmFycmF5IiwiYXJyYXkzX29mX2dlbmFycmF5IiwicmVzaGFwZV8wIiwicmVzaGFwZV8xIiwicmVzaGFwZV8yIiwicmVzaGFwZV8zIiwic3BhY2luZ19jaGFyIiwiaW52YWxpZF9jaGFyIiwibW9kcyIsIm9jYW1sX2xleF90YWJsZXMiLCJub3BfY29kZSIsIm5vcF9jb2RlMiIsImVudW1lcmF0ZV9maWxlcyIsImRpcm5hbWUiLCJleHQiLCJ4IiwidWludDMyX29mX3N0ciIsInN0ciIsInN0ciQwIiwiaTY0IiwidWludDMyX3RvX2ludCIsInYiLCJpIiwiaW50NjRfb2ZfdWludDMyIiwiZHVtbXlfZm10IiwiY29uY2F0X3N0cmluZ3MiLCJsc3QiLCJwcCIsImZtdCIsImludDMyX2Zyb21fbG93X2hpZ2giLCJsIiwiaCIsImludDMyX3RvX2xvd19oaWdoIiwic3Vic3RydWN0dXJlc19vcmRlciIsImRhdGFfb2Zmc2V0IiwibGVuIiwicGlkX29mZnNldCIsIm90aWRfb2Zmc2V0IiwiY2hlY2tzdW1fb2Zmc2V0IiwicGttbl9mcm9tX2J5dGVzIiwiYnVmIiwicGlkIiwib3RpZCIsInN1YnN0cnVjdHVyZV9wb3NpdGlvbiIsInNzIiwib3JkZXIiLCJpJDAiLCJpJDEiLCJzdWJzdHJ1Y3R1cmVfb2Zmc2V0IiwicGttbiIsInAiLCJlbmNyeXB0X2FsaWduZWRfaW50MzIiLCJrZXkiLCJjaGVja3N1bV9kaWZmX2Zvcl9hbGlnbmVkX2ludDMiLCJvIiwibiIsImhvIiwibG8iLCJobiIsImxuIiwiZGlmZiIsImVuY19kZWMiLCJvZmZzZXQiLCJvZmZzZXQkMCIsIm9mZnNldCQxIiwiZXh0cmFjdF9kYXRhIiwicmVzIiwidXBkYXRlX3dpdGhfZGF0YSIsImRhdGEiLCJhY2MiLCJsb3ciLCJjaGVja3N1bSIsIm5iIiwiYWNjJDAiLCJzcGVjaWVzX29mZnNldCIsInNwZWNpZXNfb2Zmc2V0X3JlbGF0aXZlX3RvX2RhdCIsIml2ZWFfb2Zmc2V0IiwiaXZlYV9kYXRhX3RvX2l2cyIsImhwIiwiZGF0YSQwIiwiYXRrIiwiZGF0YSQxIiwiZGVmIiwiZGF0YSQyIiwic3BlZWQiLCJkYXRhJDMiLCJzcF9hdGsiLCJkYXRhJDQiLCJzcF9kZWYiLCJkYXRhJDUiLCJpdnNfdG9faXZlYV9kYXRhIiwiZGF0YSQ2IiwiZGF0YSQ3IiwiZGF0YSQ4IiwiZGF0YSQ5IiwiZGF0YSQxMCIsImRhdGEkMTEiLCJsYW5nIiwidHdlYWtlcl9tb2RlIiwiY29uZmlndXJlIiwibGFuZ3VhZ2UiLCJtdWx0X21vZCIsInkiLCJtIiwidHdvX2JpZ19pbnQiLCJhIiwiYiIsImFfaW52IiwiYl9pbnYiLCJiXzEiLCJjeWNsZV9wYXJ0X3Byb2R1Y3QiLCJtYXNrMzIiLCJldmVuIiwib2RkIiwibXBvdyIsImJhc2UiLCJleHAiLCJiYXNlJDAiLCJleHAkMCIsImJhc2UkMSIsImV4cCQxIiwiYmFzZSQyIiwicG93Iiwic2VlZCIsImJpZ19pbnRfb2ZfdWludDMyIiwiaTMyIiwidWludDMyX29mX2JpZ2ludCIsImJpIiwibWF4aW50MzIiLCJtaW5pbnQzMiIsInRvdGFsIiwiYmkkMCIsInJuZ19vZiIsImFQcmVzc2VzIiwibW9yZUFQcmVzc2VzIiwib2xkX3JvZCIsImdvb2Rfcm9kIiwic3VwZXJfcm9kIiwibmV4dF9zZWVkIiwicHJldl9zZWVkIiwiY3ljbGVfdG8iLCJzZWVkJDAiLCJwb3dlciIsIm0kMCIsImJpdG1hc2siLCJscyIsImwkMCIsImJpdCIsImIkMCIsImJpdCQwIiwiaSQyIiwic2VlZF9hdCIsImN5Y2xlIiwiY3ljbGUkMCIsIm9wMSIsImF1eCIsImJlc3Rfc2VlZF9mb3Jfcm9kIiwicm91dGUxMTkiLCJmZWViYXMiLCJ0YXJnZXRfc2VlZCIsInJvZCIsInRhcmdldF9zZWVkJDAiLCJtYXhBZGRpdGlvbmFsT2Zmc2V0cyIsImJlc3RSZXN1bHRzIiwic3RhcnRpbmdfc2VlZCIsIm9mZnNldDExOSIsImFkZGl0aW9uYWxPZmZzZXQiLCJtaW5Sb3VuZHMiLCJiaXRlUm9sbCIsImJpdGVSZXN1bHQiLCJhZHZhbmNlbWVudCIsImJpdGVSb2xsJDAiLCJmZWViYXNSZXN1bHQiLCJhZHZhbmNlbWVudCQwIiwiYnIiLCJzIiwiYWR2IiwicyQwIiwiYWR2JDAiLCJzJDEiLCJtYWluIiwibWFpbl8xIiwibWFpbl8zIiwicm9kbmFtZSIsInNlZWQkMSIsInNob3dfdmljaW5pdHkiLCJwcmludF9jeWNsZSIsInN0YXJ0Iiwic3RvcCIsInN0YXJ0X3NlZWQiLCJtYWluX3ZpY2luaXR5IiwiaiIsIm1haW5fMiIsImdhbWVfc2F2ZV9BIiwiZ2FtZV9zYXZlX0IiLCJzZWN0aW9uX3NpemUiLCJzZWN0aW9uX2lkX29mZnNldCIsImNoZWNrc3VtX29mZnNldCQwIiwic2F2ZV9pbmRleF9vZmZzZXQiLCJib3hfbmFtZXNfc2VjdGlvbl9pZCIsImJveF9uYW1lc19zZWN0aW9uX2RhdGFfbGVuZ3RoIiwiYm94X25hbWVzX29mZnNldCIsImJveF9uYW1lc19sZW5ndGgiLCJ0ZWFtX2l0ZW1zX3NlY3Rpb25faWQiLCJ0ZWFtX2l0ZW1zX3NlY3Rpb25fZGF0YV9sZW5ndGgiLCJ0ZWFtX3NpemVfb2Zmc2V0IiwicGttbl9kYXRhX3NpemUiLCJyZWFkX3NlY3Rpb24iLCJpbmMiLCJzZWN0aW9uX2lkIiwicmJ1ZiIsImFkZHIiLCJpZCIsImluZGV4IiwiaW5kZXhhIiwiYWRkcmEiLCJpbmRleGIiLCJhZGRyYiIsIndyaXRlX3NlY3Rpb24iLCJvYyIsImNvbXB1dGVfY2hlY2tzdW0iLCJoaWdoIiwiZXh0cmFjdF9ib3hfbmFtZXNfZnJvbV9zZWN0aW9uIiwidXBkYXRlX2JveF9uYW1lcyIsImJveF9uYW1lcyIsImVtcHR5X3BrbW4iLCJleHRyYWN0X3RlYW1fZnJvbV9zZWN0aW9uIiwidXBkYXRlX3RlYW0iLCJwa21ucyIsInVwZGF0ZV9wa21uIiwiZ2V0X3BhcmFtIiwibmFtZSIsImxzdCQwIiwibHN0JDEiLCJsc3QkMiIsImV2YWxfbWV0YV9leHByIiwiZW52IiwiZSIsImUkMCIsImUyIiwiZTEiLCJvcCIsImkxIiwiaTIiLCJlJDEiLCJvcCQwIiwiZTIkMCIsImUxJDAiLCJlMCIsImkwIiwiZW1wdHlfZW52IiwiZW52X2Zyb21faGVhZGVycyIsImhlYWRlcnMiLCJ0cmVhdF9kZWYiLCJwcmludGVkIiwiZXhwciIsInByaW50IiwicHJpbnRlZCQwIiwiY29uY2F0X2VudiIsImVudjEiLCJlbnYyIiwiayIsIm1haW4kMCIsIm1haW5fMSQwIiwibWFpbl82IiwibGl2ZWEiLCJoaXZlYSIsIml2ZWEiLCJ1aXZlYSIsInVpdmVhJDAiLCJpdmVhJDAiLCJoaXZlYSQwIiwibGl2ZWEkMCIsImNoZWNrc3VtX2RpZmYiLCJtYWluXzUiLCJtYWluXzQiLCJ2aWQiLCJzaWQiLCJ0aWQiLCJtaXNjX3BvcyIsIml2ZWFfb2Zmc2V0JDAiLCJtYWluXzMkMCIsIm1haW5fMiQwIiwibHBpZCIsImhwaWQiLCJhMSIsImEyIiwiYTMiLCJhNCIsInYxIiwidjIiLCJ2MyIsInY0IiwidjUiLCJ2NiIsInY3IiwidjgiLCJzYiIsInNsIiwiZnAiLCJpcCIsInNwIiwibHIiLCJwYyIsInNpZ25fcGx1cyIsInNpZ25fbWludXMiLCJtYXNrOCIsIm1hc2s5IiwibWFzazEyIiwiYWRkX2NvbmRpdGlvbl9jb2RlIiwiYyIsImFkZF9ybl9jb2RlIiwicm4iLCJhZGRfcmRfY29kZSIsInJkIiwicm90YXRlX3JpZ2h0IiwibGIiLCJ2JDAiLCJyb3RhdGVfbGVmdCIsImhiIiwiYWRkcl9tb2RlXzEiLCJycyIsImltbSIsIm90aGVycyIsImltbTgiLCJyciIsInBvc3NpYmlsaXRpZXMiLCJybSIsInBfYW5kX3ciLCJhZGRyX3R5cCIsImFybV90b19iaW5hcnkiLCJhcm0iLCJpJDMiLCJybyIsImNvbmQiLCJ0eXAiLCJpbnN0ciIsImNoZWNrX3Bvc3RfYWRkciIsIm9wY29kZSIsInYkMyIsInNpZ24iLCJyZWciLCJzaWduJDAiLCJzaWduJDEiLCJ3IiwidSIsInAkMCIsInckMCIsImFkZHJfbW9kZSIsInYkMSIsInNpZ24kMiIsImltbWVkTCIsImltbWVkSCIsInYkMiIsInNpZ24kMyIsInJtJDAiLCJzaWduJDQiLCJ3JDEiLCJwJDEiLCJ1JDAiLCJwJDIiLCJ3JDIiLCJyZCQwIiwiY29uZCQwIiwiaW5zdHIkMCIsIm9wY29kZSQwIiwic2NvZGUiLCJzY29kZSQwIiwidiQ0Iiwib3AyIiwicm4kMCIsInJkJDEiLCJjb25kJDEiLCJpbnN0ciQxIiwib3Bjb2RlJDEiLCJzY29kZSQxIiwic2NvZGUkMiIsInYkNSIsInRhcmdldCIsImNvbmQkMiIsIm9wY29kZSQyIiwidiQ2IiwibXM5IiwiaW1tJDAiLCJybSQxIiwiY29uZCQzIiwib3Bjb2RlJDMiLCJ2JDciLCJyZXZlcnNlX2VuZGlhbm5lc3MiLCJjaGFyc2V0X2VuZyIsImNoYXJzZXRfaXRhIiwiY2hhcnNldF9zcGEiLCJjcyIsImkkNCIsImNoYXJzZXRfZnJhIiwiY2hhcnNldF9qYXAiLCJjaGFyc2V0IiwiaXNfY29kZV9hdmFpbGFibGUiLCJjb2RlIiwiaXNfY29kZV9yZWFkYWJsZSIsImlzX2NvZGVfdXNlZCIsImNoYXJfYXQiLCJyZWFkYWJsZV9jaGFyX2F0Iiwid3JpdGFibGVfY2hhcl9hdCIsImVuY29kZV93cml0YWJsZV9jaGFyIiwiZW9mIiwic3BhY2UiLCJjb2Rlc19mb3JfY29tbWFuZCIsImNvbW1hbmRfZm9yX2NvZGVzIiwiY29kZXMiLCJjNCIsImMzIiwiYzIiLCJjMSIsImNvZGVzX3RvX2NoYXJzIiwiY2hhcnNfZm9yX2NvbW1hbmQiLCJwcF9jaGFycyIsInBwX2NoYXJzX3JhdyIsImlzX2NvZGVfd3JpdGFibGUiLCJmaXJzdF9jb2RlIiwiZiIsImNvZGVzJDAiLCJjb2RlcyQxIiwiZmlyc3Rfd3JpdGFibGVfY29kZSIsImlzX2NvZGVfd3JpdGFibGVfb3Jfb25lX2VvZiIsInByZWZlcnJlZF9jb2RlIiwiaXNfZnVsbF9vZl9zcGFjZXMiLCJjb21wYXJlIiwicGFkZGluZ19jb2RlIiwiYWNjJDEiLCJtYXgiLCJpbW1lZDgiLCJpbW1lZDgkMCIsImNvbnN0YW50c19zZXQiLCJjb25zdGFudHNfc2V0X25vX2NhcnJ5IiwiY29uc3RhbnRzIiwicmV2X2NvbnN0YW50cyIsIm5zZXQiLCJjb25zdGFudHNfbW92X212biIsIm5zZXQkMCIsImNvbnN0YW50c19tb3ZfbXZuX3N0cmljdCIsInJldl9jb25zdGFudHNfbW92X212biIsInJldl9jb25zdGFudHNfbW92X212bl9zdHJpY3QiLCJ0YWQwIiwicmVtb3ZlX3doaWxlIiwic3ludGhlc2lzIiwiY29uc3RhbnRzX2NhdCIsImFkZGl0aXZlIiwiaW5jciIsIm1heF9jYXJkIiwiaXNfdmFsaWRfZnN0IiwiaXNfdmFsaWQiLCJ0YWQwX2xlbiIsInRhZDAkMCIsInJlbW92ZSIsIm5leHQiLCJyYyIsInJjJDAiLCJkZXB0aCIsInJlbV9kZXB0aCIsImlpIiwiZnN0IiwicmMkMSIsInJlbWFpbmRlciIsImZpbHRlcmVkX3Jldl9jb25zdGFudHMiLCJyZW1vdmVfaW5pdCIsIm9wX2luaXQiLCJpbml0X3JjIiwidHJ5X25iIiwidHJ5X25iJDAiLCJzeW50aGVzaXNfb3B0aW1hbCIsImluY3JfYWRkIiwiaW5jcl9zdWIiLCJjYXJkIiwiY2FyZCQwIiwic3ludGhlc2lzX3Rlc3QiLCJpc19jb21tYW5kX3ZhbGlkIiwidHdlYWtfY29tbWFuZCIsIm9wdGltaXplIiwic3RyaWN0Iiwib3B0aW1pemVfd2l0aF9jYXJkIiwicGFkIiwiY21kIiwibWtfY21kX2ZpcnN0IiwibmZzdCIsImNvbnN0YW50X3NldF9tb3YiLCJpc19tb3YiLCJta19jbWQiLCJhZGQiLCJjbWQkMCIsImlzX2FkZGl0aW9uIiwibWtfY21kX2ZpcnN0JDAiLCJta19jbWQkMCIsImlzX2FkZGl0aW9uJDAiLCJtdXN0X2FkZCIsImFkZGl0aXZlJDAiLCJmc3QkMCIsInBhZGRpbmciLCJ0d2Vha19hcm0iLCJkb19ub3RfdHdlYWtfYXJtIiwicHJlcHJvY2VzcyIsInVpIiwiY29tYmluZV9vcHQiLCJvMSIsIm8yIiwiY29tYmluZV9ib29sIiwiYjEiLCJiMiIsInJlY29nbml6ZV9tb2RpZmllcnMiLCJzdHIkMyIsIm4kMiIsIm1vZHMkMSIsIm5tb2RzIiwibiQwIiwic3RyJDEiLCJpJDUiLCJuJDEiLCJzdHIkMiIsImkkNiIsImkkNyIsImkkOCIsIngkMCIsImwkMSIsIngkMSIsIm1vZHMkMCIsInJlZ2lzdGVyX29mX3N0ciIsImdldF9yZWdpc3RlciIsImFyZyIsImdldF9yZCIsImFyZ3MiLCJnZXRfcm4iLCJnZXRfb3AyIiwiZ2V0X3JvIiwiciIsImdldF90YXJnZXQiLCJjbWRfdG9fYXJtIiwiY21kJDEiLCJjbWQkMiIsInBvcyIsInR5cCQwIiwidHlwJDEiLCJjJDAiLCJ0b19hcm0iLCJhc3QiLCJlUlIiLCJtZW5oaXJfZGlzY2FyZCIsIm1lbmhpcl9lbnYiLCJsZXhlciIsImxleGJ1ZiIsInRvayIsIm1lbmhpcl9lcnJvcmNhc2UiLCJtZW5oaXJfc3RhY2siLCJtZW5oaXJfcyIsIm1lbmhpcl9zdGFjayQwIiwibWVuaGlyX3MkMCIsIm1lbmhpcl9zJDEiLCJtZW5oaXJfc3RhY2skMSIsIm1lbmhpcl9zJDIiLCJtZW5oaXJfc3RhY2skMiIsIm1lbmhpcl9zJDMiLCJtZW5oaXJfc3RhY2skMyIsIm1lbmhpcl9zJDQiLCJtZW5oaXJfc3RhY2skNCIsIm1lbmhpcl9zJDUiLCJtZW5oaXJfc3RhY2skNSIsIm1lbmhpcl9zJDYiLCJtZW5oaXJfc3RhY2skNiIsIm1lbmhpcl9zJDciLCJtZW5oaXJfc3RhY2skNyIsIm1lbmhpcl9zJDgiLCJtZW5oaXJfc3RhY2skOCIsIm1lbmhpcl9zJDkiLCJtZW5oaXJfc3RhY2skOSIsIm1lbmhpcl9zJDEwIiwibWVuaGlyX3N0YWNrJDEwIiwibWVuaGlyX3MkMTEiLCJtZW5oaXJfc3RhY2skMTEiLCJtZW5oaXJfcyQxMiIsIm1lbmhpcl9zdGFjayQxMiIsIm1lbmhpcl9zJDEzIiwibWVuaGlyX3N0YWNrJDEzIiwibWVuaGlyX3MkMTQiLCJtZW5oaXJfc3RhY2skMTQiLCJtZW5oaXJfcyQxNSIsIm1lbmhpcl9zdGFjayQxNSIsIm1lbmhpcl9zJDE2IiwibWVuaGlyX3N0YWNrJDE2IiwibWVuaGlyX3MkMTciLCJtZW5oaXJfc3RhY2skMTciLCJtZW5oaXJfcyQxOCIsIm1lbmhpcl9zdGFjayQxOCIsIm1lbmhpcl9zJDE5IiwibWVuaGlyX3N0YWNrJDE5IiwibWVuaGlyX3MkMjAiLCJtZW5oaXJfc3RhY2skMjAiLCJtZW5oaXJfcyQyMSIsIm1lbmhpcl9zdGFjayQyMSIsIm1lbmhpcl9zJDIyIiwibWVuaGlyX3N0YWNrJDIyIiwibWVuaGlyX3MkMjMiLCJtZW5oaXJfc3RhY2skMjMiLCJtZW5oaXJfcyQyNCIsIm1lbmhpcl9zdGFjayQyNCIsIm1lbmhpcl9zJDI1IiwibWVuaGlyX3N0YWNrJDI1IiwibWVuaGlyX3MkMjYiLCJtZW5oaXJfc3RhY2skMjYiLCJtZW5oaXJfcyQyNyIsIm1lbmhpcl9zdGFjayQyNyIsIm1lbmhpcl9zJDI4IiwibWVuaGlyX3N0YWNrJDI4IiwibWVuaGlyX3MkMjkiLCJtZW5oaXJfc3RhY2skMjkiLCJtZW5oaXJfcyQzMCIsIm1lbmhpcl9zdGFjayQzMCIsIm1lbmhpcl9zJDMxIiwibWVuaGlyX3N0YWNrJDMxIiwibWVuaGlyX3MkMzIiLCJtZW5oaXJfc3RhY2skMzIiLCJtZW5oaXJfcyQzMyIsIm1lbmhpcl9zdGFjayQzMyIsIm1lbmhpcl9zJDM0IiwibWVuaGlyX3N0YWNrJDM0IiwibWVuaGlyX3MkMzUiLCJtZW5oaXJfc3RhY2skMzUiLCJtZW5oaXJfcyQzNiIsIm1lbmhpcl9zdGFjayQzNiIsIm1lbmhpcl9mYWlsIiwibWVuaGlyX2dvdG9fYXN0IiwibWVuaGlyX2dvdG9faGVhZGVycyIsImQiLCJtZW5oaXJfcnVuMTUiLCJtZW5oaXJfZW52JDAiLCJtZW5oaXJfcnVuNiIsIm1lbmhpcl9ydW44IiwibWVuaGlyX3J1bjkiLCJtZW5oaXJfcnVuMTAiLCJtZW5oaXJfcnVuMTIiLCJtZW5oaXJfcnVuNyIsIm1lbmhpcl9ydW4xMSIsIm1lbmhpcl9ydW4xNyIsIm1lbmhpcl9ydW4xOSIsIm1lbmhpcl9ydW4yMSIsIm1lbmhpcl9ydW4zOCIsIm1lbmhpcl9ydW4yOSIsIm1lbmhpcl9ydW4yMyIsIm1lbmhpcl9ydW4yNyIsIm1lbmhpcl9ydW4zMSIsIm1lbmhpcl9ydW40MCIsIm1lbmhpcl9ydW4zMyIsIm1lbmhpcl9ydW4yNSIsIm1lbmhpcl9ydW40NCIsIm1lbmhpcl9ydW40NiIsIm1lbmhpcl9ydW4zNSIsIm1lbmhpcl9nb3RvX29mZnNldCIsInRvayQwIiwibWVuaGlyX2VudiQxIiwiaWQkMCIsIm1lbmhpcl9nb3RvX2FyZyIsImlkJDEiLCJtZW5oaXJfZ290b19tZXRhX2V4cHIiLCJtZW5oaXJfZ290b19kZWZpbml0aW9uIiwidG9rJDEiLCJ0b2skMiIsInRvayQzIiwiZTIkMSIsImUxJDEiLCJ0b2skNCIsInRvayQ1IiwidG9rJDYiLCJlMiQyIiwiZTEkMiIsInYkOCIsInRvayQ3IiwiZTIkMyIsImUxJDMiLCJ2JDkiLCJ0b2skOCIsImUyJDQiLCJlMSQ0IiwidiQxMCIsInRvayQ5IiwiZTIkNSIsImUxJDUiLCJ2JDExIiwidG9rJDEwIiwiZTIkNiIsImUxJDYiLCJ2JDEyIiwidG9rJDExIiwiZTIkNyIsImUxJDciLCJ2JDEzIiwiZTIkOCIsImUxJDgiLCJ2JDE0IiwiZTIkOSIsImUxJDkiLCJ2JDE1IiwidG9rJDEyIiwiZTIkMTAiLCJlMSQxMCIsInYkMTYiLCJ0b2skMTMiLCJlMiQxMSIsImUxJDExIiwidiQxNyIsImUyJDEyIiwiZTEkMTIiLCJ2JDE4IiwidG9rJDE0IiwiZTIkMTMiLCJlMSQxMyIsInYkMTkiLCJ2JDIwIiwidG9rJDE1IiwibWVuaGlyX2VudiQyIiwidiQyMSIsImUkMiIsIm1lbmhpcl9zdGFjayQzNyIsInYkMjIiLCJlJDMiLCJtZW5oaXJfc3RhY2skMzgiLCJ2JDIzIiwiZSQ0IiwibWVuaGlyX3N0YWNrJDM5IiwidiQyNCIsInRvayQxNiIsIm1lbmhpcl9lbnYkMyIsImUkNSIsInN0YXJ0cG9zXzEiLCJtZW5oaXJfcyQzOCIsIm1lbmhpcl9zdGFjayQ0MSIsInYkMjUiLCJtZW5oaXJfZ290b19udW1iZXIiLCJtZW5oaXJfcyQzNyIsIm1lbmhpcl9zdGFjayQ0MCIsIm1lbmhpcl9nb3RvX2NvbW1hbmQiLCJtZW5oaXJfcnVuMSQwIiwibWVuaGlyX3JlZHVjZTI2JDAiLCJzdGFydHBvcyIsIm1lbmhpcl9ydW41OSIsIm1lbmhpcl9ydW41IiwibWVuaGlyX3J1bjQiLCJtZW5oaXJfcnVuNjIiLCJtZW5oaXJfcnVuNjUiLCJtZW5oaXJfcnVuNjYiLCJtZW5oaXJfcnVuNTQiLCJtZW5oaXJfcnVuNzkiLCJtZW5oaXJfcnVuNzgiLCJtZW5oaXJfZ290b19sb3B0aW9uX3NlcGFyYXRlZF8iLCJtYXRjaCIsInN0YXJ0cG9zX2lkIiwic3RhcnRwb3NfaWQkMCIsInN0YXJ0cG9zX2lkJDEiLCJzdGFydHBvc19pIiwibWVuaGlyX2VudiQ0IiwibWVuaGlyX2VudiQ1IiwibWVuaGlyX2VudiQxMSIsInhzIiwibWVuaGlyX2VudiQ2Iiwic3RhcnRwb3MkMCIsIm1lbmhpcl9lbnYkNyIsIm1lbmhpcl9lbnYkOCIsIm1lbmhpcl9lbnYkOSIsIm1lbmhpcl9lbnYkMTAiLCJtZW5oaXJfcmVkdWNlMjYiLCJtZW5oaXJfcnVuMSIsIm5leHRfbGluZSIsImVvZl9yZWFjaGVkIiwicmVhZF9jb21tZW50JDAiLCJvY2FtbF9sZXhfcmVhZF9jb21tZW50X3JlYyQwIiwib2NhbWxfbGV4X3N0YXRlIiwib2NhbWxfbGV4X3N0YXRlJDAiLCJvY2FtbF9sZXhfc3RhdGUkMSIsInJlYWRfY29tbWVudCIsIm9jYW1sX2xleF9yZWFkX2NvbW1lbnRfcmVjIiwicmVhZF9zdHJpbmckMCIsIm9jYW1sX2xleF9yZWFkX3N0cmluZ19yZWMkMCIsInJlYWRfc3RyaW5nIiwib2NhbWxfbGV4X3JlYWRfc3RyaW5nX3JlYyIsInJlYWQkMCIsIm9jYW1sX2xleF9yZWFkX3JlYyQwIiwicmVhZCIsIm9jYW1sX2xleF9yZWFkX3JlYyIsInByaW50X3Bvc2l0aW9uIiwicHJpbnRfbGV4YnVmX3BvcyIsInBhcnNlX3dpdGhfZXJyb3IiLCJtc2ciLCJmcm9tX2xleGJ1ZiIsImhlYWRlcnMkMCIsImhlYWRlcnMkMSIsImFzdCQwIiwiZnJvbV9maWxlbmFtZSIsImZpbGVuYW1lIiwiY2hhbm5lbCIsImZyb21fc3RyIiwicGFyc2VkX2FzdF90b19hcm0iLCJwYXJzZWRfY29udGVudF90b19hcm0iLCJlbnYkMCIsInBhcnNlIiwibWFpbl9maWxlIiwiZm4iLCJmbiQwIiwiZnJvbV9maWxlbmFtZSQwIiwiZnJvbV9zdHIkMCIsIm1mIiwiZ2V0X2ZpbGUiLCJmaWxlcyIsImxvYWRfZnJvbV9kaXIiLCJwYXRoIiwibG9hZF9mcm9tX3BhcnNlZF9maWxlIiwibG9hZF9mcm9tX2ZpbGUiLCJnZXRfcHJlZmVycmVkIiwiZGVmYXVsdCQwIiwic3RyaW5nX29mX3VjaGFyIiwidWNoYXIiLCJidWZmZXIiLCJkZWNvbXBvc2VfaW50b191Y2hhcnMiLCJ1YyIsInVjJDAiLCJtYWluJDEiLCJtYWluXzEkMSIsImF1eDIiLCJhdXg0IiwiZW5jb2RpbmciLCJlbmNvZGluZyQwIiwiZW5jb2RpbmckMSIsImVuY29kaW5nJDIiLCJkZWZhdWx0X2ZpbGxlcnMiLCJuYl9ib3hlcyIsIm5vX2VvZiIsInBhZF9uYiIsImZpbGxlcnMiLCJwb3MkMCIsImZpdF9jb2RlX2F0X3BvcyIsIm9wdCIsImNvZGVzJDkiLCJzdGgiLCJpc19va19oZXJlIiwiY29kZXMkMiIsImNvZGVzJDMiLCJjb2RlcyQ0IiwiY29kZXMkNSIsImMkMSIsImNvZGVzJDYiLCJuZXh0JDAiLCJjb2RlcyQ3IiwiY29kZXMkOCIsImMkMiIsImFjYyQyIiwibm9wX2NvZGUkMCIsImFkZF9jb2Rlc19hZnRlciIsImZpbmFsJDAiLCJuYyIsInNwbGl0X3Jhd19pbnRvX2JveGVzIiwicmF3IiwiZmlsbF9sYXN0IiwiZmluaXNoZWQiLCJjdXJyZW50IiwiZmluaXNoZWQkMCIsImN1cnJlbnQkMCIsImN1cnJlbnQkMSIsImZpdF9jb2Rlc19pbnRvX2JveGVzIiwic3RoJDAiLCJzdGgkMSIsInN0aCQyIiwiZXhpdCIsImV4aXQkMCIsImVjb2RlIiwicGFkZGluZyQwIiwicmVzJDAiLCJyZXMkMSIsInJlcyQyIiwicmVzdWx0IiwicHJlZml4Iiwic3VmZml4X2xlbiIsInN1ZmZpeCIsInBwX2JveGVzX25hbWVzIiwicHBfYm94IiwiY2hhcnMiLCJwcF9ib3hfcmF3IiwicHBfaGV4IiwiY29uZF90b19zdHIiLCJzaWduX3RvX3N0ciIsInNfdG9fc3RyIiwibF90b19zdHIiLCJwcmludF9yZWdpc3RlciIsInByaW50X2ltbWVkaWF0ZSIsInByaW50X29wZXJhbmQiLCJwcmludF9pbW1lZGlhdGVfb2Zmc2V0IiwicHJpbnRfcmVnaXN0ZXJfb2Zmc2V0Iiwicm8kMCIsInJvJDEiLCJzJDIiLCJwcF9hcm0iLCJ0cmVhdF9jb21tYW5kIiwiaGV4cyIsImhleCIsIm1haW4kMiIsInBhcnNlZCIsImhlYWRlcnMyIiwib25seXJhdyIsImhlYWRlcl9uYW1lIiwic3RhcnQkMCIsImJveGVzX2NvZGVzIiwic2l6ZSIsImpvb19nbG9iYWxfb2JqZWN0IiwibnVsbCIsInVuZGVmaW5lZCIsImV4biIsImV2ZW50IiwidHJlYXRfaW5wdXQiLCJsYW5nIiwic3RyIiwiYnVmZmVyIiwiZm10IiwiZnMiLCJwcm9ncmFtIiwiaGVhZGVycyIsImVudiIsImhlYWRlcnMyIiwiZXhpdCIsImZuIiwiYXN0IiwiaGVhZGVycyQwIiwiZXhpdCQwIiwiZSIsImlzX2JsYW5rX3N0ciIsInMiLCJpJDEiLCJpIiwiYyIsImkkMCIsImNvbXB1dGUiLCJtYWluX2lucHV0Iiwic2Vjb25kYXJ5X2lucHV0Iiwib3V0cHV0IiwibWFpbl9pbnB1dCQwIiwic2Vjb25kYXJ5X2lucHV0JDAiLCJpbnB1dCIsImxhbmckMCIsInJlcyIsImluaXQiLCJjb21wdXRlX2J1dHRvbiJdLCJzb3VyY2VzIjpbIi9idWlsdGluLytpbnQ2NC5qcyIsIi9idWlsdGluLyttbEJ5dGVzLmpzIiwiL2J1aWx0aW4vK2ZhaWwuanMiLCIvYnVpbHRpbi8rc3RkbGliLmpzIiwiL2J1aWx0aW4vK2Zvcm1hdC5qcyIsIi9idWlsdGluLytpZWVlXzc1NC5qcyIsIi9idWlsdGluLytmcy5qcyIsIi9idWlsdGluLytzeXMuanMiLCIvYnVpbHRpbi8rZnNfZmFrZS5qcyIsIi9idWlsdGluLytmc19ub2RlLmpzIiwiL2J1aWx0aW4vK25hdC5qcyIsIi9idWlsdGluLytncmFwaGljcy5qcyIsIi9idWlsdGluLyttYXJzaGFsLmpzIiwiL2J1aWx0aW4vK2lvLmpzIiwiL2J1aWx0aW4vK2djLmpzIiwiL2J1aWx0aW4vK2JpZ2FycmF5LmpzIiwiL2J1aWx0aW4vK2pzbGliLmpzIiwiL2J1aWx0aW4vK3BhcnNpbmcuanMiLCIvYnVpbHRpbi8ranNsaWJfanNfb2Zfb2NhbWwuanMiLCIvYnVpbHRpbi8rdW5peC5qcyIsIi9idWlsdGluLytpbnRzLmpzIiwiL2J1aWx0aW4vK2hhc2guanMiLCIvYnVpbHRpbi8rY29tcGFyZS5qcyIsIi9idWlsdGluLytpbnRlcm5hbE1vZC5qcyIsIi9idWlsdGluLytvYmouanMiLCIvYnVpbHRpbi8rYmlnc3RyaW5nLmpzIiwiL2J1aWx0aW4vK2JhY2t0cmFjZS5qcyIsIi9idWlsdGluLytsZXhpbmcuanMiLCIvYnVpbHRpbi8rYXJyYXkuanMiLCIvYnVpbHRpbi8rd2Vhay5qcyIsIi9idWlsdGluLyttZDUuanMiLCIvYnVpbHRpbi8rc3RyLmpzIiwiL2J1aWx0aW4vK2JpZ3N0cmluZy1jc3RydWN0LmpzIiwiL2hvbWUvbWljay8ub3BhbS80LjEyLjAvbGliL29jYW1sL3VjaGFyLm1sIiwiL2hvbWUvbWljay8ub3BhbS80LjEyLjAvbGliL29jYW1sL2ludDY0Lm1sIiwiL2hvbWUvbWljay8ub3BhbS80LjEyLjAvbGliL29jYW1sL2xleGluZy5tbCIsIi9ob21lL21pY2svLm9wYW0vNC4xMi4wL2xpYi9vY2FtbC9jYW1saW50ZXJuYWxGb3JtYXQubWwiLCIvaG9tZS9taWNrLy5vcGFtLzQuMTIuMC9saWIvb2NhbWwvcHJpbnRleGMubWwiLCIvaG9tZS9taWNrLy5vcGFtLzQuMTIuMC9saWIvb2NhbWwvZmlsZW5hbWUubWwiLCIvaG9tZS9taWNrLy5vcGFtLzQuMTIuMC9saWIvb2NhbWwvY29tcGxleC5tbCIsIi9ob21lL21pY2svLm9wYW0vNC4xMi4wL2xpYi9vY2FtbC9jYW1saW50ZXJuYWxGb3JtYXRCYXNpY3MubWwiLCIvaG9tZS9taWNrLy5vcGFtLzQuMTIuMC9saWIvb2NhbWwvY2FtbGludGVybmFsQXRvbWljLm1sIiwiL2hvbWUvbWljay8ub3BhbS80LjEyLjAvbGliL29jYW1sL3N0ZGxpYi5tbCIsIi9ob21lL21pY2svLm9wYW0vNC4xMi4wL2xpYi9vY2FtbC9wZXJ2YXNpdmVzLm1sIiwiL2hvbWUvbWljay8ub3BhbS80LjEyLjAvbGliL29jYW1sL2Zsb2F0Lm1sIiwiL2hvbWUvbWljay8ub3BhbS80LjEyLjAvbGliL29jYW1sL25hdGl2ZWludC5tbCIsIi9ob21lL21pY2svLm9wYW0vNC4xMi4wL2xpYi9vY2FtbC9saXN0Lm1sIiwiL2hvbWUvbWljay8ub3BhbS80LjEyLjAvbGliL29jYW1sL3NlcS5tbCIsIi9ob21lL21pY2svLm9wYW0vNC4xMi4wL2xpYi9vY2FtbC9vcHRpb24ubWwiLCIvaG9tZS9taWNrLy5vcGFtLzQuMTIuMC9saWIvb2NhbWwvZWl0aGVyLm1sIiwiL2hvbWUvbWljay8ub3BhbS80LjEyLjAvbGliL29jYW1sL3Jlc3VsdC5tbCIsIi9ob21lL21pY2svLm9wYW0vNC4xMi4wL2xpYi9vY2FtbC9ib29sLm1sIiwiL2hvbWUvbWljay8ub3BhbS80LjEyLjAvbGliL29jYW1sL2NoYXIubWwiLCIvaG9tZS9taWNrLy5vcGFtLzQuMTIuMC9saWIvb2NhbWwvYnl0ZXMubWwiLCIvaG9tZS9taWNrLy5vcGFtLzQuMTIuMC9saWIvb2NhbWwvc3RyaW5nLm1sIiwiL2hvbWUvbWljay8ub3BhbS80LjEyLjAvbGliL29jYW1sL3VuaXQubWwiLCIvaG9tZS9taWNrLy5vcGFtLzQuMTIuMC9saWIvb2NhbWwvbWFyc2hhbC5tbCIsIi9ob21lL21pY2svLm9wYW0vNC4xMi4wL2xpYi9vY2FtbC9vYmoubWwiLCIvaG9tZS9taWNrLy5vcGFtLzQuMTIuMC9saWIvb2NhbWwvYXJyYXkubWwiLCIvaG9tZS9taWNrLy5vcGFtLzQuMTIuMC9saWIvb2NhbWwvaW50Lm1sIiwiL2hvbWUvbWljay8ub3BhbS80LjEyLjAvbGliL29jYW1sL2ludDMyLm1sIiwiL2hvbWUvbWljay8ub3BhbS80LjEyLjAvbGliL29jYW1sL3BhcnNpbmcubWwiLCIvaG9tZS9taWNrLy5vcGFtLzQuMTIuMC9saWIvb2NhbWwvc2V0Lm1sIiwiL2hvbWUvbWljay8ub3BhbS80LjEyLjAvbGliL29jYW1sL21hcC5tbCIsIi9ob21lL21pY2svLm9wYW0vNC4xMi4wL2xpYi9vY2FtbC9zdGFjay5tbCIsIi9ob21lL21pY2svLm9wYW0vNC4xMi4wL2xpYi9vY2FtbC9xdWV1ZS5tbCIsIi9ob21lL21pY2svLm9wYW0vNC4xMi4wL2xpYi9vY2FtbC9jYW1saW50ZXJuYWxMYXp5Lm1sIiwiL2hvbWUvbWljay8ub3BhbS80LjEyLjAvbGliL29jYW1sL2xhenkubWwiLCIvaG9tZS9taWNrLy5vcGFtLzQuMTIuMC9saWIvb2NhbWwvc3RyZWFtLm1sIiwiL2hvbWUvbWljay8ub3BhbS80LjEyLjAvbGliL29jYW1sL2J1ZmZlci5tbCIsIi9ob21lL21pY2svLm9wYW0vNC4xMi4wL2xpYi9vY2FtbC9wcmludGYubWwiLCIvaG9tZS9taWNrLy5vcGFtLzQuMTIuMC9saWIvb2NhbWwvYXJnLm1sIiwiL2hvbWUvbWljay8ub3BhbS80LjEyLjAvbGliL29jYW1sL2Z1bi5tbCIsIi9ob21lL21pY2svLm9wYW0vNC4xMi4wL2xpYi9vY2FtbC9nYy5tbCIsIi9ob21lL21pY2svLm9wYW0vNC4xMi4wL2xpYi9vY2FtbC9kaWdlc3QubWwiLCIvaG9tZS9taWNrLy5vcGFtLzQuMTIuMC9saWIvb2NhbWwvcmFuZG9tLm1sIiwiL2hvbWUvbWljay8ub3BhbS80LjEyLjAvbGliL29jYW1sL2hhc2h0YmwubWwiLCIvaG9tZS9taWNrLy5vcGFtLzQuMTIuMC9saWIvb2NhbWwvd2Vhay5tbCIsIi9ob21lL21pY2svLm9wYW0vNC4xMi4wL2xpYi9vY2FtbC9mb3JtYXQubWwiLCIvaG9tZS9taWNrLy5vcGFtLzQuMTIuMC9saWIvb2NhbWwvc2NhbmYubWwiLCIvaG9tZS9taWNrLy5vcGFtLzQuMTIuMC9saWIvb2NhbWwvY2FsbGJhY2subWwiLCIvaG9tZS9taWNrLy5vcGFtLzQuMTIuMC9saWIvb2NhbWwvY2FtbGludGVybmFsT08ubWwiLCIvaG9tZS9taWNrLy5vcGFtLzQuMTIuMC9saWIvb2NhbWwvZ2VubGV4Lm1sIiwiL2hvbWUvbWljay8ub3BhbS80LjEyLjAvbGliL29jYW1sL2VwaGVtZXJvbi5tbCIsIi9ob21lL21pY2svLm9wYW0vNC4xMi4wL2xpYi9vY2FtbC9iaWdhcnJheS5tbCIsIi9tbnQvYy9Vc2Vycy9NaWNrL0Rlc2t0b3AvRW1lcmFsZEFDRS9fYnVpbGQvZGVmYXVsdC9Cb3hlcy9jaGFyc2V0Lm1sIiwiL21udC9jL1VzZXJzL01pY2svRGVza3RvcC9FbWVyYWxkQUNFL19idWlsZC9kZWZhdWx0L0FSTS9wYXJzZXJfYXN0Lm1sIiwiL21udC9jL1VzZXJzL01pY2svRGVza3RvcC9FbWVyYWxkQUNFL19idWlsZC9kZWZhdWx0L0lPL2xleGVyLm1sIiwiL21udC9jL1VzZXJzL01pY2svRGVza3RvcC9FbWVyYWxkQUNFL19idWlsZC9kZWZhdWx0L0JveGVzL2JveGVzLm1sIiwiL21udC9jL1VzZXJzL01pY2svRGVza3RvcC9FbWVyYWxkQUNFL19idWlsZC9kZWZhdWx0L0lPL3V0aWxzLm1sIiwiL21udC9jL1VzZXJzL01pY2svRGVza3RvcC9FbWVyYWxkQUNFL19idWlsZC9kZWZhdWx0L1Bva2Vtb24vc3RydWN0dXJlLm1sIiwiL21udC9jL1VzZXJzL01pY2svRGVza3RvcC9FbWVyYWxkQUNFL19idWlsZC9kZWZhdWx0L01haW4vc2V0dGluZ3MubWwiLCIvbW50L2MvVXNlcnMvTWljay9EZXNrdG9wL0VtZXJhbGRBQ0UvX2J1aWxkL2RlZmF1bHQvUG9rZW1vbi9zZWVkLm1sIiwiL21udC9jL1VzZXJzL01pY2svRGVza3RvcC9FbWVyYWxkQUNFL19idWlsZC9kZWZhdWx0L01haW4vc2VlZF90b29sc19jb21tb24ubWwiLCIvbW50L2MvVXNlcnMvTWljay9EZXNrdG9wL0VtZXJhbGRBQ0UvX2J1aWxkL2RlZmF1bHQvU2F2ZS9zYXZlLm1sIiwiL21udC9jL1VzZXJzL01pY2svRGVza3RvcC9FbWVyYWxkQUNFL19idWlsZC9kZWZhdWx0L0lPL3ByZXByb2Nlc3MubWwiLCIvbW50L2MvVXNlcnMvTWljay9EZXNrdG9wL0VtZXJhbGRBQ0UvX2J1aWxkL2RlZmF1bHQvTWFpbi9wa21uX2RhdGFfY29tbW9uLm1sIiwiL21udC9jL1VzZXJzL01pY2svRGVza3RvcC9FbWVyYWxkQUNFL19idWlsZC9kZWZhdWx0L0FSTS9hcm0ubWwiLCIvbW50L2MvVXNlcnMvTWljay9EZXNrdG9wL0VtZXJhbGRBQ0UvX2J1aWxkL2RlZmF1bHQvQm94ZXMvbmFtZS5tbCIsIi9tbnQvYy9Vc2Vycy9NaWNrL0Rlc2t0b3AvRW1lcmFsZEFDRS9fYnVpbGQvZGVmYXVsdC9BUk0vb3B0aW1pemVyLm1sIiwiL21udC9jL1VzZXJzL01pY2svRGVza3RvcC9FbWVyYWxkQUNFL19idWlsZC9kZWZhdWx0L0lPL3BhcnNlci5tbCIsIi9tbnQvYy9Vc2Vycy9NaWNrL0Rlc2t0b3AvRW1lcmFsZEFDRS9fYnVpbGQvZGVmYXVsdC9JTy9wYXJzZXIubWx5IiwiL21udC9jL1VzZXJzL01pY2svRGVza3RvcC9FbWVyYWxkQUNFL19idWlsZC9kZWZhdWx0L0lPL2xleGVyLm1sbCIsIi9tbnQvYy9Vc2Vycy9NaWNrL0Rlc2t0b3AvRW1lcmFsZEFDRS9fYnVpbGQvZGVmYXVsdC9JTy9wYXJzZS5tbCIsIi9tbnQvYy9Vc2Vycy9NaWNrL0Rlc2t0b3AvRW1lcmFsZEFDRS9fYnVpbGQvZGVmYXVsdC9JTy9mcy5tbCIsIi9tbnQvYy9Vc2Vycy9NaWNrL0Rlc2t0b3AvRW1lcmFsZEFDRS9fYnVpbGQvZGVmYXVsdC9Cb3hlcy9leGl0Lm1sIiwiL21udC9jL1VzZXJzL01pY2svRGVza3RvcC9FbWVyYWxkQUNFL19idWlsZC9kZWZhdWx0L01haW4vZW5jb2Rlcl9jb21tb24ubWwiLCIvbW50L2MvVXNlcnMvTWljay9EZXNrdG9wL0VtZXJhbGRBQ0UvX2J1aWxkL2RlZmF1bHQvQVJNL2FybV9wcmludGVyLm1sIiwiL21udC9jL1VzZXJzL01pY2svRGVza3RvcC9FbWVyYWxkQUNFL19idWlsZC9kZWZhdWx0L01haW4vYWNlX2NvbW1vbi5tbCIsIiIsIi9tbnQvYy9Vc2Vycy9NaWNrL0Rlc2t0b3AvRW1lcmFsZEFDRS9fYnVpbGQvZGVmYXVsdC9NYWluL2FjZV9qcy5tbCIsIi9ob21lL21pY2svLm9wYW0vNC4xMi4wL2xpYi9vY2FtbC9zdGRfZXhpdC5tbCJdLCJtYXBwaW5ncyI6Ijs7OztJQTBPQSxTQUFTQSxtQkFBbUJDLEdBQUssU0FBUSxVQUFZO0lDekxyRCxTQUFTQyxnQkFBZ0JDLEVBQUdDO01BQzFCLEdBQUdELE9BQVE7TUFDWCxHQUFJQyxTQUFVLE9BQVEsU0FBU0Q7TUFDL0IsSUFBTSxLQUFRO01BQ2Q7T0FBUSxDQUNOLEdBQUlBLE1BQU9FLEtBQUtEO1FBQ2hCRDtRQUNBLEdBQUlBLE9BQVEsT0FBT0U7UUFDbkJELEtBQUtBO1FBQ0xFO1FBQ0EsR0FBSUEsT0FBUSxhQU1oQjtJRDdDQSxJQUFJQyxrQkFBb0I7SUVBeEIsU0FBU0Usb0JBQXFCQyxLQUFPLE1BQU1BLEdBQUs7SUMyQ2hELElBQUlDO0lEUkosU0FBU0M7TUFDUCxvQkFBb0JELGtDQUN0QjtJRmpDQSxTQUFTRSxRQUFTQyxHQUFHQyxHQUFHQztNQUN0QkMsVUFBVUgsY0FDVkcsVUFBVUYsY0FDVkUsVUFBVUQsV0FDWjtJQUNBSDtJQUNBQTs7ZUFDRSxXQUFXQSxRQUFRSSxRQUFRQSxRQUFRQSxRQURaO0lBSXpCSjs7YUFBdUNaO01BQ3JDLEdBQUlnQixVQUFVaEIsS0FBTTtNQUNwQixHQUFJZ0IsVUFBVWhCLEtBQU07TUFDcEIs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Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztVOzs7Ozs7O0ljN0IxQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tDa0JLK2lDO0tBQ0FDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0N3QkFDO0tBQ0FDO0tBQ0FDO0tBSUFDO0tBQ0FDOzs7O0tDekJBQztLQW9IQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tDbTlFTUM7S0FRUUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tDbGxGZEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tDc0VFQztLQUNBQztLQUNBQztLQUNBQzs7O0tBL0VZQztLQXFIWkM7S0FDQUM7S0FDQUM7S0FDQUM7OztLQW1JQUM7S0FDQUM7S0FDQUM7S0FDQUM7OztLQzFQRkM7S0FDQUM7S0FDQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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QztNQUNRLG9CQ3pVdEJxQztNRHlVK0MscUJDelUvQ0EsT0R5VTJEO0lBaExsRCxTQ2pKVGlEO01Ea1VtQixvQkMxVW5CakQsV0QwVTRDLHFCQzFVNUNBLE9EMFV3RDtJQWpML0MsU0NoSlRrRCxXRHFVVzVDLEdBQUksMkJDN1VmTCxPRDZVV0ssRUFBd0I7SUFyTDFCLFNDL0lUNkMsYURxVWF4RixHQUFJLHFCQzlVakJzQyxPRDhVYXRDLEVBQTBCO0lBdEw5QixTQzlJVHlGLFlEcVVZekYsR0FBSSxvQkMvVWhCc0MsT0QrVVl0QyxFQUF5QjtJQXZMNUIsU0M3SVQwRixVRHFVVXBLO01BQXlCLHFCQ2hWbkNnSCxPRGdWbUMsNEJBQXpCaEgsR0FBMEM7SUF4TDNDLFNDNUlUcUssWURxVVluRyxHQUF5QixxQkNqVnJDOEMsT0RpVnFDLFVBQXpCOUMsR0FBNEM7SUF6TC9DLFNDM0lUb0csY0RxVWM1RjtNQUNoQixjQ25WRXNDLE9Ea1ZjdEM7TUFDUSxvQkNuVnRCc0M7TURtVitDLHFCQ25WL0NBLE9EbVYyRDtJQTNMbEQsU0MxSVR1RDtNRHNVbUIsb0JDcFZuQnZELFdEb1Y0QyxxQkNwVjVDQSxPRG9Wd0Q7SUE1TC9DLFNDeklUd0QsaUJEeVVlLGNDelZmekQsUUR5VmUsa0JDMVZmRCxNRDBWNkM7SUFoTXBDLFNDeElUMkQsZ0JEeVV3QywwQkFBYixhQUFhO0lBak0vQixTQ3ZJVEMsb0JEeVVtQyxzQ0FBYTtJQWxNdkMsU0N0SVRDLGtCRHlVNEMsNEJBQWIsYUFBYTtJQW5NbkMsU0NySVRDLHNCRHlVdUMsa0NBQWE7SUFwTTNDLFNDMUVUQyx3Qlg1T0wsSVVvaEJxQ2pJO0lBOU52QixTQ3RFVGtJO01ENFNNO09BRnNDQztPQUFOdEo7T0FBaEJ1SjtPQUFOeEo7T0FFVixZQUZnQndKLEtBRVQsYUFGK0JEO01BQ3RDLHFCQURVdkosS0FBc0JDO0lBUXRCLElBQWhCd0osaUJDbFdBekQ7SURrV2dCLFNDaFRoQjBELFFEa1RZaEg7TUFDZDtRQUVtQjs7U0FDSixTQU5iK0c7U0FNYTttQkFEWEUsYUFDQUM7cUJB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OztJb0RBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0N1TktDO0tBQ0FDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQ25IVUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQ2xGVkM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tDUEFDO0tBQ0FDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztZQ0NDcXZCO0tEREQ7Z0JDQ0NDO0tEREQsSUNDQ0M7SURERDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7NEJDQ1lDLEtBQU8sTUFBTUEsR0FBdkI7OzBCRERGOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Z0JDQ0NDLE1EREQ7Ozs7Ozs7Ozs7eUJDQ0NBLE1EREQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lDQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2FDTUtDLFlBQVlDLEtBQUtDO01BQ25CLHVCQURjRDtNQUVEOztPQUNILGtDQURORTtNQUNNO1FBRUM7NkJBTFFEO1NBTVEsdUJBRHJCRztTQUNxQjs7U0FDZiw2QkFKUkQsSUFHR0c7U0FHRyxpQ0FISEE7UUFHRzthQURHRSxXQUFOQzs7U0FDRztVQUdpQjtXQURiQztXQUNhLHlCQURiQSxHQU5STjtXQU9xQjs7V0FDViwwQkFWYkQsSUFJRUksT0FLS0ssVUFBU0Q7V0FKUEgsU0FJRkk7V0FKSkgsUUFLR0k7O1VBRUM7O1dBUEVMO1dBQU5DO1FBU0wseUJBZEVOLElBSUVJLE9BRENELFFBRU1FLFVBRkdILFFBRVRJO1lBVUFLOztRQUE4QixzQ0FBOUJBO1FBQUssNkJBaEJSWjtNQWlCSiw2QkFoQklDO01BZ0JKLG1DQWpCSUQsT0FrQmtCO2FBRXBCYSxhQUFhQztNQUNmLHNDQURlQSxXQUNERTtNQUNaO2dCQURZQTtVQUdGLElBQUpDLEVBQUksd0JBSkdILEVBQ0RFO29CQUdOQyxxQ0FFQztVQUZHLElBQzRDLElBSjFDRDs7UUFDRSxTQU1XO2FBRXpCRztNQUdFOzs7O09BREY7T0FLRTs7O09BREY7T0FLRTs7O09BREY7T0FLRTs7O09BREY7T0FHOEMscUNBaEI1Q0M7T0FpQnNELDBDQWJ0REM7T0FlQztxQkFGREc7O1VBR1csNEJBSFhBO09BQ1EsNEJBRlJEO09BTWdDLCtCQVZoQ3pCO09BV00sZ0JBRE40QixPQUpBRDtNQVZBSCxlQWdCYyxnQ0FEZEs7OEJBRUk7YUFFTkM7TUFHRTs7OztPQURGO09BSTBCLHdDQWxDMUJUO09Ba0NBO01BREYsb0NBSklVO01BTUQsd0JBQ007SUFHZ0I7NkNBWHZCRDtLQVdGO0lBRE07SUFDbUIsdUJBdkV2Qi9CLFlBc0JBZ0IsYUFVQU0sUUE0QkFTO0lBWUM7VUQ5RU47Ozs7Ozs7SUNBQTs7OztJQ2tCUzs7O1VEbEJUIiwic291cmNlc0NvbnRlbnQiOlsiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwIErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfb2Zmc2V0XG52YXIgY2FtbF9pbnQ2NF9vZmZzZXQgPSBNYXRoLnBvdygyLCAtMjQpO1xuXG4vL1Byb3ZpZGVzOiBNbEludDY0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mZnNldCwgY2FtbF9yYWlzZV96ZXJvX2RpdmlkZVxuZnVuY3Rpb24gTWxJbnQ2NCAobG8sbWksaGkpIHtcbiAgdGhpcy5sbyA9IGxvICYgMHhmZmZmZmY7XG4gIHRoaXMubWkgPSBtaSAmIDB4ZmZmZmZmO1xuICB0aGlzLmhpID0gaGkgJiAweGZmZmY7XG59XG5NbEludDY0LnByb3RvdHlwZS5jYW1sX2N1c3RvbSA9IFwiX2pcIlxuTWxJbnQ2NC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG5ldyBNbEludDY0KHRoaXMubG8sdGhpcy5taSx0aGlzLmhpKTtcbn1cblxuTWxJbnQ2NC5wcm90b3R5cGUudWNvbXBhcmUgPSBmdW5jdGlvbiAoeCkge1xuICBpZiAodGhpcy5oaSA+IHguaGkpIHJldHVybiAxO1xuICBpZiAodGhpcy5oaSA8IHguaGkpIHJldHVybiAtMTtcbiAgaWYgKHRoaXMubWkgPiB4Lm1pKSByZXR1cm4gMTtcbiAgaWYgKHRoaXMubWkgPCB4Lm1pKSByZXR1cm4gLTE7XG4gIGlmICh0aGlzLmxvID4geC5sbykgcmV0dXJuIDE7XG4gIGlmICh0aGlzLmxvIDwgeC5sbykgcmV0dXJuIC0xO1xuICByZXR1cm4gMDtcbn1cbk1sSW50NjQucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiAoeCkge1xuICB2YXIgaGkgPSB0aGlzLmhpIDw8IDE2O1xuICB2YXIgeGhpID0geC5oaSA8PCAxNjtcbiAgaWYgKGhpID4geGhpKSByZXR1cm4gMTtcbiAgaWYgKGhpIDwgeGhpKSByZXR1cm4gLTE7XG4gIGlmICh0aGlzLm1pID4geC5taSkgcmV0dXJuIDE7XG4gIGlmICh0aGlzLm1pIDwgeC5taSkgcmV0dXJuIC0xO1xuICBpZiAodGhpcy5sbyA+IHgubG8pIHJldHVybiAxO1xuICBpZiAodGhpcy5sbyA8IHgubG8pIHJldHVybiAtMTtcbiAgcmV0dXJuIDA7XG59XG5NbEludDY0LnByb3RvdHlwZS5uZWcgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBsbyA9IC0gdGhpcy5sbztcbiAgdmFyIG1pID0gLSB0aGlzLm1pICsgKGxvID4+IDI0KTtcbiAgdmFyIGhpID0gLSB0aGlzLmhpICsgKG1pID4+IDI0KTtcbiAgcmV0dXJuIG5ldyBNbEludDY0KGxvLCBtaSwgaGkpO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHgpIHtcbiAgdmFyIGxvID0gdGhpcy5sbyArIHgubG87XG4gIHZhciBtaSA9IHRoaXMubWkgKyB4Lm1pICsgKGxvID4+IDI0KTtcbiAgdmFyIGhpID0gdGhpcy5oaSArIHguaGkgKyAobWkgPj4gMjQpO1xuICByZXR1cm4gbmV3IE1sSW50NjQobG8sIG1pLCBoaSk7XG59XG5NbEludDY0LnByb3RvdHlwZS5zdWIgPSBmdW5jdGlvbiAoeCkge1xuICB2YXIgbG8gPSB0aGlzLmxvIC0geC5sbztcbiAgdmFyIG1pID0gdGhpcy5taSAtIHgubWkgKyAobG8gPj4gMjQpO1xuICB2YXIgaGkgPSB0aGlzLmhpIC0geC5oaSArIChtaSA+PiAyNCk7XG4gIHJldHVybiBuZXcgTWxJbnQ2NChsbywgbWksIGhpKTtcbn1cbk1sSW50NjQucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uICh4KSB7XG4gIHZhciBsbyA9IHRoaXMubG8gKiB4LmxvO1xuICB2YXIgbWkgPSAoKGxvICogY2FtbF9pbnQ2NF9vZmZzZXQpIHwgMCkgKyB0aGlzLm1pICogeC5sbyArIHRoaXMubG8gKiB4Lm1pO1xuICB2YXIgaGkgPSAoKG1pICogY2FtbF9pbnQ2NF9vZmZzZXQpIHwgMCkgKyB0aGlzLmhpICogeC5sbyArIHRoaXMubWkgKiB4Lm1pICsgdGhpcy5sbyAqIHguaGk7XG4gIHJldHVybiBuZXcgTWxJbnQ2NChsbywgbWksIGhpKTtcbn1cbk1sSW50NjQucHJvdG90eXBlLmlzWmVybyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICh0aGlzLmxvfHRoaXMubWl8dGhpcy5oaSkgPT0gMDtcbn1cbk1sSW50NjQucHJvdG90eXBlLmlzTmVnID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gKHRoaXMuaGkgPDwgMTYpIDwgMDtcbn1cbk1sSW50NjQucHJvdG90eXBlLmFuZCA9IGZ1bmN0aW9uICh4KSB7XG4gIHJldHVybiBuZXcgTWxJbnQ2NCh0aGlzLmxvICYgeC5sbywgdGhpcy5taSAmIHgubWksIHRoaXMuaGkgJiB4LmhpKTtcbn1cbk1sSW50NjQucHJvdG90eXBlLm9yID0gZnVuY3Rpb24gKHgpIHtcbiAgcmV0dXJuIG5ldyBNbEludDY0KHRoaXMubG98eC5sbywgdGhpcy5taXx4Lm1pLCB0aGlzLmhpfHguaGkpO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUueG9yID0gZnVuY3Rpb24gKHgpIHtcbiAgcmV0dXJuIG5ldyBNbEludDY0KHRoaXMubG9eeC5sbywgdGhpcy5taV54Lm1pLCB0aGlzLmhpXnguaGkpO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUuc2hpZnRfbGVmdCA9IGZ1bmN0aW9uIChzKSB7XG4gIHMgPSBzICYgNjM7XG4gIGlmIChzID09IDApIHJldHVybiB0aGlzO1xuICBpZiAocyA8IDI0KSB7XG4gICAgcmV0dXJuIG5ldyBNbEludDY0ICh0aGlzLmxvIDw8IHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAodGhpcy5taSA8PCBzKSB8ICh0aGlzLmxvID4+ICgyNCAtIHMpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzLmhpIDw8IHMpIHwgKHRoaXMubWkgPj4gKDI0IC0gcykpKTtcbiAgfVxuICBpZiAocyA8IDQ4KVxuICAgIHJldHVybiBuZXcgTWxJbnQ2NCAoMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG8gPDwgKHMgLSAyNCksXG4gICAgICAgICAgICAgICAgICAgICAgICAodGhpcy5taSA8PCAocyAtIDI0KSkgfCAodGhpcy5sbyA+PiAoNDggLSBzKSkpO1xuICByZXR1cm4gbmV3IE1sSW50NjQoMCwgMCwgdGhpcy5sbyA8PCAocyAtIDQ4KSlcbn1cbk1sSW50NjQucHJvdG90eXBlLnNoaWZ0X3JpZ2h0X3Vuc2lnbmVkID0gZnVuY3Rpb24gKHMpIHtcbiAgcyA9IHMgJiA2MztcbiAgaWYgKHMgPT0gMCkgcmV0dXJuIHRoaXM7XG4gIGlmIChzIDwgMjQpXG4gICAgcmV0dXJuIG5ldyBNbEludDY0IChcbiAgICAgICh0aGlzLmxvID4+IHMpIHwgKHRoaXMubWkgPDwgKDI0IC0gcykpLFxuICAgICAgKHRoaXMubWkgPj4gcykgfCAodGhpcy5oaSA8PCAoMjQgLSBzKSksXG4gICAgICAodGhpcy5oaSA+PiBzKSk7XG4gIGlmIChzIDwgNDgpXG4gICAgcmV0dXJuIG5ldyBNbEludDY0IChcbiAgICAgICh0aGlzLm1pID4+IChzIC0gMjQpKSB8ICh0aGlzLmhpIDw8ICg0OCAtIHMpKSxcbiAgICAgICh0aGlzLmhpID4+IChzIC0gMjQpKSxcbiAgICAgIDApO1xuICByZXR1cm4gbmV3IE1sSW50NjQgKHRoaXMuaGkgPj4gKHMgLSA0OCksIDAsIDApO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUuc2hpZnRfcmlnaHQgPSBmdW5jdGlvbiAocykge1xuICBzID0gcyAmIDYzO1xuICBpZiAocyA9PSAwKSByZXR1cm4gdGhpcztcbiAgdmFyIGggPSAodGhpcy5oaSA8PCAxNikgPj4gMTY7XG4gIGlmIChzIDwgMjQpXG4gICAgcmV0dXJuIG5ldyBNbEludDY0IChcbiAgICAgICh0aGlzLmxvID4+IHMpIHwgKHRoaXMubWkgPDwgKDI0IC0gcykpLFxuICAgICAgKHRoaXMubWkgPj4gcykgfCAoaCA8PCAoMjQgLSBzKSksXG4gICAgICAoKHRoaXMuaGkgPDwgMTYpID4+IHMpID4+PiAxNik7XG4gIHZhciBzaWduID0gKHRoaXMuaGkgPDwgMTYpID4+IDMxO1xuICBpZiAocyA8IDQ4KVxuICAgIHJldHVybiBuZXcgTWxJbnQ2NCAoXG4gICAgICAodGhpcy5taSA+PiAocyAtIDI0KSkgfCAodGhpcy5oaSA8PCAoNDggLSBzKSksXG4gICAgICAodGhpcy5oaSA8PCAxNikgPj4gKHMgLSAyNCkgPj4gMTYsXG4gICAgICBzaWduICYgMHhmZmZmKTtcbiAgcmV0dXJuIG5ldyBNbEludDY0ICgodGhpcy5oaSA8PCAxNikgPj4gKHMgLSAzMiksIHNpZ24sIHNpZ24pO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUubHNsMSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5oaSA9ICh0aGlzLmhpIDw8IDEpIHwgKHRoaXMubWkgPj4gMjMpO1xuICB0aGlzLm1pID0gKCh0aGlzLm1pIDw8IDEpIHwgKHRoaXMubG8gPj4gMjMpKSAmIDB4ZmZmZmZmO1xuICB0aGlzLmxvID0gKHRoaXMubG8gPDwgMSkgJiAweGZmZmZmZjtcbn1cbk1sSW50NjQucHJvdG90eXBlLmxzcjEgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMubG8gPSAoKHRoaXMubG8gPj4+IDEpIHwgKHRoaXMubWkgPDwgMjMpKSAmIDB4ZmZmZmZmO1xuICB0aGlzLm1pID0gKCh0aGlzLm1pID4+PiAxKSB8ICh0aGlzLmhpIDw8IDIzKSkgJiAweGZmZmZmZjtcbiAgdGhpcy5oaSA9IHRoaXMuaGkgPj4+IDE7XG59XG5NbEludDY0LnByb3RvdHlwZS51ZGl2bW9kID0gZnVuY3Rpb24gKHgpIHtcbiAgdmFyIG9mZnNldCA9IDA7XG4gIHZhciBtb2R1bHVzID0gdGhpcy5jb3B5KCk7XG4gIHZhciBkaXZpc29yID0geC5jb3B5KCk7XG4gIHZhciBxdW90aWVudCA9IG5ldyBNbEludDY0KDAsMCwwKTtcbiAgd2hpbGUgKG1vZHVsdXMudWNvbXBhcmUoZGl2aXNvcikgPiAwKSB7XG4gICAgb2Zmc2V0Kys7XG4gICAgZGl2aXNvci5sc2wxKCk7XG4gIH1cbiAgd2hpbGUgKG9mZnNldCA+PSAwKSB7XG4gICAgb2Zmc2V0IC0tO1xuICAgIHF1b3RpZW50LmxzbDEoKTtcbiAgICBpZiAobW9kdWx1cy51Y29tcGFyZShkaXZpc29yKSA+PSAwKSB7XG4gICAgICBxdW90aWVudC5sbyArKztcbiAgICAgIG1vZHVsdXMgPSBtb2R1bHVzLnN1YihkaXZpc29yKTtcbiAgICB9XG4gICAgZGl2aXNvci5sc3IxKCk7XG4gIH1cbiAgcmV0dXJuIHsgcXVvdGllbnQgOiBxdW90aWVudCwgbW9kdWx1cyA6IG1vZHVsdXMgfTtcbn1cbk1sSW50NjQucHJvdG90eXBlLmRpdiA9IGZ1bmN0aW9uICh5KVxue1xuICB2YXIgeCA9IHRoaXM7XG4gIGlmICh5LmlzWmVybygpKSBjYW1sX3JhaXNlX3plcm9fZGl2aWRlICgpO1xuICB2YXIgc2lnbiA9IHguaGkgXiB5LmhpO1xuICBpZiAoeC5oaSAmIDB4ODAwMCkgeCA9IHgubmVnKCk7XG4gIGlmICh5LmhpICYgMHg4MDAwKSB5ID0geS5uZWcoKTtcbiAgdmFyIHEgPSB4LnVkaXZtb2QoeSkucXVvdGllbnQ7XG4gIGlmIChzaWduICYgMHg4MDAwKSBxID0gcS5uZWcoKTtcbiAgcmV0dXJuIHE7XG59XG5NbEludDY0LnByb3RvdHlwZS5tb2QgPSBmdW5jdGlvbiAoeSlcbntcbiAgdmFyIHggPSB0aGlzO1xuICBpZiAoeS5pc1plcm8oKSkgY2FtbF9yYWlzZV96ZXJvX2RpdmlkZSAoKTtcbiAgdmFyIHNpZ24gPSB4LmhpO1xuICBpZiAoeC5oaSAmIDB4ODAwMCkgeCA9IHgubmVnKCk7XG4gIGlmICh5LmhpICYgMHg4MDAwKSB5ID0geS5uZWcoKTtcbiAgdmFyIHIgPSB4LnVkaXZtb2QoeSkubW9kdWx1cztcbiAgaWYgKHNpZ24gJiAweDgwMDApIHIgPSByLm5lZygpO1xuICByZXR1cm4gcjtcbn1cbk1sSW50NjQucHJvdG90eXBlLnRvSW50ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5sbyB8ICh0aGlzLm1pIDw8IDI0KTtcbn1cbk1sSW50NjQucHJvdG90eXBlLnRvRmxvYXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAoKHRoaXMuaGkgPDwgMTYpICogTWF0aC5wb3coMiwgMzIpICsgdGhpcy5taSAqIE1hdGgucG93KDIsIDI0KSkgKyB0aGlzLmxvO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIFt0aGlzLmhpID4+IDgsXG4gICAgICAgICAgdGhpcy5oaSAmIDB4ZmYsXG4gICAgICAgICAgdGhpcy5taSA+PiAxNixcbiAgICAgICAgICAodGhpcy5taSA+PiA4KSAmIDB4ZmYsXG4gICAgICAgICAgdGhpcy5taSAmIDB4ZmYsXG4gICAgICAgICAgdGhpcy5sbyA+PiAxNixcbiAgICAgICAgICAodGhpcy5sbyA+PiA4KSAmIDB4ZmYsXG4gICAgICAgICAgdGhpcy5sbyAmIDB4ZmZdO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUubG8zMiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubG8gfCAoKHRoaXMubWkgJiAweGZmKSA8PCAyNCk7XG59XG5NbEludDY0LnByb3RvdHlwZS5oaTMyID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gKCh0aGlzLm1pID4+PiA4KSAmIDB4ZmZmZikgfCAodGhpcy5oaSA8PCAxNik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfdWx0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X3VsdCh4LHkpIHsgcmV0dXJuIHgudWNvbXBhcmUoeSkgPCAwOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfY29tcGFyZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9jb21wYXJlKHgseSwgdG90YWwpIHsgcmV0dXJuIHguY29tcGFyZSh5KSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfbmVnIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X25lZyAoeCkgeyByZXR1cm4geC5uZWcoKSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfYWRkIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2FkZCAoeCwgeSkgeyByZXR1cm4geC5hZGQoeSkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3N1YiBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9zdWIgKHgsIHkpIHsgcmV0dXJuIHguc3ViKHkpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9tdWwgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2Zmc2V0XG5mdW5jdGlvbiBjYW1sX2ludDY0X211bCh4LHkpIHsgcmV0dXJuIHgubXVsKHkpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9pc196ZXJvIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2lzX3plcm8oeCkgeyByZXR1cm4gK3guaXNaZXJvKCk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9pc19uZWdhdGl2ZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9pc19uZWdhdGl2ZSh4KSB7IHJldHVybiAreC5pc05lZygpOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfYW5kIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2FuZCAoeCwgeSkgeyByZXR1cm4geC5hbmQoeSk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9vciBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9vciAoeCwgeSkgeyByZXR1cm4geC5vcih5KTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3hvciBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF94b3IgKHgsIHkpIHsgcmV0dXJuIHgueG9yKHkpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9zaGlmdF9sZWZ0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X3NoaWZ0X2xlZnQgKHgsIHMpIHsgcmV0dXJuIHguc2hpZnRfbGVmdChzKSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfc2hpZnRfcmlnaHRfdW5zaWduZWQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfc2hpZnRfcmlnaHRfdW5zaWduZWQgKHgsIHMpIHsgcmV0dXJuIHguc2hpZnRfcmlnaHRfdW5zaWduZWQocykgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0ICh4LCBzKSB7IHJldHVybiB4LnNoaWZ0X3JpZ2h0KHMpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9kaXYgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfZGl2ICh4LCB5KSB7IHJldHVybiB4LmRpdih5KSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfbW9kIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X21vZCAoeCwgeSkgeyByZXR1cm4geC5tb2QoeSkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X29mX2ludDMyIGNvbnN0XG4vL1JlcXVpcmVzOiBNbEludDY0XG5mdW5jdGlvbiBjYW1sX2ludDY0X29mX2ludDMyICh4KSB7XG4gIHJldHVybiBuZXcgTWxJbnQ2NCh4ICYgMHhmZmZmZmYsICh4ID4+IDI0KSAmIDB4ZmZmZmZmLCAoeCA+PiAzMSkgJiAweGZmZmYpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfdG9faW50MzIgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfdG9faW50MzIgKHgpIHsgcmV0dXJuIHgudG9JbnQoKSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfdG9fZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfdG9fZmxvYXQgKHgpIHsgcmV0dXJuIHgudG9GbG9hdCAoKSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfb2ZfZmxvYXQgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2Zmc2V0LCBNbEludDY0XG5mdW5jdGlvbiBjYW1sX2ludDY0X29mX2Zsb2F0ICh4KSB7XG4gIGlmICh4IDwgMCkgeCA9IE1hdGguY2VpbCh4KTtcbiAgcmV0dXJuIG5ldyBNbEludDY0KFxuICAgIHggJiAweGZmZmZmZixcbiAgICBNYXRoLmZsb29yKHggKiBjYW1sX2ludDY0X29mZnNldCkgJiAweGZmZmZmZixcbiAgICBNYXRoLmZsb29yKHggKiBjYW1sX2ludDY0X29mZnNldCAqIGNhbWxfaW50NjRfb2Zmc2V0KSAmIDB4ZmZmZik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfZm9ybWF0IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX3BhcnNlX2Zvcm1hdCwgY2FtbF9maW5pc2hfZm9ybWF0dGluZ1xuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9pc19uZWdhdGl2ZSwgY2FtbF9pbnQ2NF9uZWdcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfaW50MzIsIGNhbWxfaW50NjRfdG9faW50MzJcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfaXNfemVybywgY2FtbF9zdHJfcmVwZWF0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2Zvcm1hdCAoZm10LCB4KSB7XG4gIHZhciBmID0gY2FtbF9wYXJzZV9mb3JtYXQoZm10KTtcbiAgaWYgKGYuc2lnbmVkY29udiAmJiBjYW1sX2ludDY0X2lzX25lZ2F0aXZlKHgpKSB7XG4gICAgZi5zaWduID0gLTE7IHggPSBjYW1sX2ludDY0X25lZyh4KTtcbiAgfVxuICB2YXIgYnVmZmVyID0gXCJcIjtcbiAgdmFyIHdiYXNlID0gY2FtbF9pbnQ2NF9vZl9pbnQzMihmLmJhc2UpO1xuICB2YXIgY3Z0YmwgPSBcIjAxMjM0NTY3ODlhYmNkZWZcIjtcbiAgZG8ge1xuICAgIHZhciBwID0geC51ZGl2bW9kKHdiYXNlKTtcbiAgICB4ID0gcC5xdW90aWVudDtcbiAgICBidWZmZXIgPSBjdnRibC5jaGFyQXQoY2FtbF9pbnQ2NF90b19pbnQzMihwLm1vZHVsdXMpKSArIGJ1ZmZlcjtcbiAgfSB3aGlsZSAoISBjYW1sX2ludDY0X2lzX3plcm8oeCkpO1xuICBpZiAoZi5wcmVjID49IDApIHtcbiAgICBmLmZpbGxlciA9ICcgJztcbiAgICB2YXIgbiA9IGYucHJlYyAtIGJ1ZmZlci5sZW5ndGg7XG4gICAgaWYgKG4gPiAwKSBidWZmZXIgPSBjYW1sX3N0cl9yZXBlYXQgKG4sICcwJykgKyBidWZmZXI7XG4gIH1cbiAgcmV0dXJuIGNhbWxfZmluaXNoX2Zvcm1hdHRpbmcoZiwgYnVmZmVyKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9vZl9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfcGFyc2Vfc2lnbl9hbmRfYmFzZSwgY2FtbF9mYWlsd2l0aCwgY2FtbF9wYXJzZV9kaWdpdFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZl9pbnQzMiwgY2FtbF9pbnQ2NF91bHRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfYWRkLCBjYW1sX2ludDY0X211bCwgY2FtbF9pbnQ2NF9uZWdcbi8vUmVxdWlyZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aCxjYW1sX3N0cmluZ191bnNhZmVfZ2V0LCBNbEludDY0XG5mdW5jdGlvbiBjYW1sX2ludDY0X29mX3N0cmluZyhzKSB7XG4gIHZhciByID0gY2FtbF9wYXJzZV9zaWduX2FuZF9iYXNlIChzKTtcbiAgdmFyIGkgPSByWzBdLCBzaWduID0gclsxXSwgYmFzZSA9IHJbMl07XG4gIHZhciBiYXNlNjQgPSBjYW1sX2ludDY0X29mX2ludDMyKGJhc2UpO1xuICB2YXIgdGhyZXNob2xkID1cbiAgICAgIG5ldyBNbEludDY0KDB4ZmZmZmZmLCAweGZmZmZmZmYsIDB4ZmZmZikudWRpdm1vZChiYXNlNjQpLnF1b3RpZW50O1xuICB2YXIgYyA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQocywgaSk7XG4gIHZhciBkID0gY2FtbF9wYXJzZV9kaWdpdChjKTtcbiAgaWYgKGQgPCAwIHx8IGQgPj0gYmFzZSkgY2FtbF9mYWlsd2l0aChcImludF9vZl9zdHJpbmdcIik7XG4gIHZhciByZXMgPSBjYW1sX2ludDY0X29mX2ludDMyKGQpO1xuICBmb3IgKDs7KSB7XG4gICAgaSsrO1xuICAgIGMgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0KHMsIGkpO1xuICAgIGlmIChjID09IDk1KSBjb250aW51ZTtcbiAgICBkID0gY2FtbF9wYXJzZV9kaWdpdChjKTtcbiAgICBpZiAoZCA8IDAgfHwgZCA+PSBiYXNlKSBicmVhaztcbiAgICAvKiBEZXRlY3Qgb3ZlcmZsb3cgaW4gbXVsdGlwbGljYXRpb24gYmFzZSAqIHJlcyAqL1xuICAgIGlmIChjYW1sX2ludDY0X3VsdCh0aHJlc2hvbGQsIHJlcykpIGNhbWxfZmFpbHdpdGgoXCJpbnRfb2Zfc3RyaW5nXCIpO1xuICAgIGQgPSBjYW1sX2ludDY0X29mX2ludDMyKGQpO1xuICAgIHJlcyA9IGNhbWxfaW50NjRfYWRkKGNhbWxfaW50NjRfbXVsKGJhc2U2NCwgcmVzKSwgZCk7XG4gICAgLyogRGV0ZWN0IG92ZXJmbG93IGluIGFkZGl0aW9uIChiYXNlICogcmVzKSArIGQgKi9cbiAgICBpZiAoY2FtbF9pbnQ2NF91bHQocmVzLCBkKSkgY2FtbF9mYWlsd2l0aChcImludF9vZl9zdHJpbmdcIik7XG4gIH1cbiAgaWYgKGkgIT0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpKSBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgaWYgKGJhc2UgPT0gMTAgJiYgY2FtbF9pbnQ2NF91bHQobmV3IE1sSW50NjQoMCwgMCwgMHg4MDAwKSwgcmVzKSlcbiAgICBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgaWYgKHNpZ24gPCAwKSByZXMgPSBjYW1sX2ludDY0X25lZyhyZXMpO1xuICByZXR1cm4gcmVzO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2NyZWF0ZV9sb19taV9oaSBjb25zdFxuLy9SZXF1aXJlczogTWxJbnQ2NFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9jcmVhdGVfbG9fbWlfaGkobG8sIG1pLCBoaSl7XG4gIHJldHVybiBuZXcgTWxJbnQ2NChsbywgbWksIGhpKVxufVxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9jcmVhdGVfbG9faGkgY29uc3Rcbi8vUmVxdWlyZXM6IE1sSW50NjRcbmZ1bmN0aW9uIGNhbWxfaW50NjRfY3JlYXRlX2xvX2hpKGxvLCBoaSl7XG4gIHJldHVybiBuZXcgTWxJbnQ2NCAoXG4gICAgbG8gJiAweGZmZmZmZixcbiAgICAoKGxvID4+PiAyNCkgJiAweGZmKSB8ICgoaGkgJiAweGZmZmYpIDw8IDgpLFxuICAgIChoaSA+Pj4gMTYpICYgMHhmZmZmKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfbG8zMiBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9sbzMyKHYpeyByZXR1cm4gdi5sbzMyKCkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2hpMzIgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfaGkzMih2KXsgcmV0dXJuIHYuaGkzMigpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9vZl9ieXRlcyBjb25zdFxuLy9SZXF1aXJlczogTWxJbnQ2NFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9vZl9ieXRlcyhhKSB7XG4gIHJldHVybiBuZXcgTWxJbnQ2NChhWzddIDw8IDAgfCAoYVs2XSA8PCA4KSB8IChhWzVdIDw8IDE2KSxcbiAgICAgICAgICAgICAgICAgICAgIGFbNF0gPDwgMCB8IChhWzNdIDw8IDgpIHwgKGFbMl0gPDwgMTYpLFxuICAgICAgICAgICAgICAgICAgICAgYVsxXSA8PCAwIHwgKGFbMF0gPDwgOCkpO1xufVxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF90b19ieXRlcyBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF90b19ieXRlcyh4KSB7IHJldHVybiB4LnRvQXJyYXkoKSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfaGFzaCBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9oYXNoKHYpe1xuICByZXR1cm4gKHYubG8zMigpKSBeICh2LmhpMzIoKSlcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxMC0yMDE0IErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vIEFuIE9DYW1sIHN0cmluZyBpcyBhbiBvYmplY3Qgd2l0aCB0aHJlZSBmaWVsZHM6XG4vLyAtIHRhZyAndCdcbi8vIC0gbGVuZ3RoICdsJ1xuLy8gLSBjb250ZW50cyAnYydcbi8vXG4vLyBUaGUgY29udGVudHMgb2YgdGhlIHN0cmluZyBjYW4gYmUgZWl0aGVyIGEgSmF2YVNjcmlwdCBhcnJheSBvclxuLy8gYSBKYXZhU2NyaXB0IHN0cmluZy4gVGhlIGxlbmd0aCBvZiB0aGlzIHN0cmluZyBjYW4gYmUgbGVzcyB0aGFuIHRoZVxuLy8gbGVuZ3RoIG9mIHRoZSBPQ2FtbCBzdHJpbmcuIEluIHRoaXMgY2FzZSwgcmVtYWluaW5nIGJ5dGVzIGFyZVxuLy8gYXNzdW1lZCB0byBiZSB6ZXJvZXMuIEFycmF5cyBhcmUgbXV0YWJsZSBidXQgY29uc3VtZXMgbW9yZSBtZW1vcnlcbi8vIHRoYW4gc3RyaW5ncy4gQSBjb21tb24gcGF0dGVybiBpcyB0byBzdGFydCBmcm9tIGFuIGVtcHR5IHN0cmluZyBhbmRcbi8vIHByb2dyZXNzaXZlbHkgZmlsbCBpdCBmcm9tIHRoZSBzdGFydC4gUGFydGlhbCBzdHJpbmdzIG1ha2VzIGl0XG4vLyBwb3NzaWJsZSB0byBpbXBsZW1lbnQgdGhpcyBlZmZpY2llbnRseS5cbi8vXG4vLyBXaGVuIGNvbnZlcnRpbmcgdG8gYW5kIGZyb20gVVRGLTE2LCB3ZSBrZWVwIHRyYWNrIG9mIHdoZXRoZXIgdGhlXG4vLyBzdHJpbmcgaXMgY29tcG9zZWQgb25seSBvZiBBU0NJSSBjaGFyYWN0ZXJzIChpbiB3aGljaCBjYXNlLCBub1xuLy8gY29udmVyc2lvbiBuZWVkcyB0byBiZSBwZXJmb3JtZWQpIG9yIG5vdC5cbi8vXG4vLyBUaGUgc3RyaW5nIHRhZyBjYW4gdGh1cyB0YWtlIHRoZSBmb2xsb3dpbmcgdmFsdWVzOlxuLy8gICBmdWxsIHN0cmluZyAgICAgQllURSB8IFVOS05PV046ICAgICAgMFxuLy8gICAgICAgICAgICAgICAgICAgQllURSB8IEFTQ0lJOiAgICAgICAgOVxuLy8gICAgICAgICAgICAgICAgICAgQllURSB8IE5PVF9BU0NJSTogICAgOFxuLy8gICBzdHJpbmcgcHJlZml4ICAgUEFSVElBTDogICAgICAgICAgICAgMlxuLy8gICBhcnJheSAgICAgICAgICAgQVJSQVk6ICAgICAgICAgICAgICAgNFxuLy9cbi8vIE9uZSBjYW4gdXNlIGJpdCBtYXNraW5nIHRvIGRpc2NyaW1pbmF0ZSB0aGVzZSBkaWZmZXJlbnQgY2FzZXM6XG4vLyAgIGtub3duX2VuY29kaW5nKHgpID0geCY4XG4vLyAgIGlzX2FzY2lpKHgpID0gICAgICAgeCYxXG4vLyAgIGtpbmQoeCkgPSAgICAgICAgICAgeCY2XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyX3JlcGVhdFxuZnVuY3Rpb24gY2FtbF9zdHJfcmVwZWF0KG4sIHMpIHtcbiAgaWYobiA9PSAwKSByZXR1cm4gXCJcIjtcbiAgaWYgKHMucmVwZWF0KSB7cmV0dXJuIHMucmVwZWF0KG4pO30gLy8gRUNNQXNjcmlwdCA2IGFuZCBGaXJlZm94IDI0K1xuICB2YXIgciA9IFwiXCIsIGwgPSAwO1xuICBmb3IoOzspIHtcbiAgICBpZiAobiAmIDEpIHIgKz0gcztcbiAgICBuID4+PSAxO1xuICAgIGlmIChuID09IDApIHJldHVybiByO1xuICAgIHMgKz0gcztcbiAgICBsKys7XG4gICAgaWYgKGwgPT0gOSkge1xuICAgICAgcy5zbGljZSgwLDEpOyAvLyBmbGF0dGVuIHRoZSBzdHJpbmdcbiAgICAgIC8vIHRoZW4sIHRoZSBmbGF0dGVuaW5nIG9mIHRoZSB3aG9sZSBzdHJpbmcgd2lsbCBiZSBmYXN0ZXIsXG4gICAgICAvLyBhcyBpdCB3aWxsIGJlIGNvbXBvc2VkIG9mIGxhcmdlciBwaWVjZXNcbiAgICB9XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdWJhcnJheV90b19qc2J5dGVzXG4vL1dlYWtkZWZcbi8vIFByZSBFQ01BU2NyaXB0IDUsIFthcHBseV0gd291bGQgbm90IHN1cHBvcnQgYXJyYXktbGlrZSBvYmplY3QuXG4vLyBJbiBzdWNoIHNldHVwLCBUeXBlZF9hcnJheSB3b3VsZCBiZSBpbXBsZW1lbnRlZCBhcyBwb2x5ZmlsbCwgYW5kIFtmLmFwcGx5XSB3b3VsZFxuLy8gZmFpbCBoZXJlLiBNYXJrIHRoZSBwcmltaXRpdmUgYXMgV2Vha2RlZiwgc28gdGhhdCBwZW9wbGUgY2FuIG92ZXJyaWRlIGl0IGVhc2lseS5cbmZ1bmN0aW9uIGNhbWxfc3ViYXJyYXlfdG9fanNieXRlcyAoYSwgaSwgbGVuKSB7XG4gIHZhciBmID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcbiAgaWYgKGkgPT0gMCAmJiBsZW4gPD0gNDA5NiAmJiBsZW4gPT0gYS5sZW5ndGgpIHJldHVybiBmLmFwcGx5IChudWxsLCBhKTtcbiAgdmFyIHMgPSBcIlwiO1xuICBmb3IgKDsgMCA8IGxlbjsgaSArPSAxMDI0LGxlbi09MTAyNClcbiAgICBzICs9IGYuYXBwbHkgKG51bGwsIGEuc2xpY2UoaSxpICsgTWF0aC5taW4obGVuLCAxMDI0KSkpO1xuICByZXR1cm4gcztcbn1cblxuLy9Qcm92aWRlczogY2FtbF91dGY4X29mX3V0ZjE2XG5mdW5jdGlvbiBjYW1sX3V0Zjhfb2ZfdXRmMTYocykge1xuICBmb3IgKHZhciBiID0gXCJcIiwgdCA9IGIsIGMsIGQsIGkgPSAwLCBsID0gcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBjID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjIDwgMHg4MCkge1xuICAgICAgZm9yICh2YXIgaiA9IGkgKyAxOyAoaiA8IGwpICYmIChjID0gcy5jaGFyQ29kZUF0KGopKSA8IDB4ODA7IGorKyk7XG4gICAgICBpZiAoaiAtIGkgPiA1MTIpIHsgdC5zdWJzdHIoMCwgMSk7IGIgKz0gdDsgdCA9IFwiXCI7IGIgKz0gcy5zbGljZShpLCBqKSB9XG4gICAgICBlbHNlIHQgKz0gcy5zbGljZShpLCBqKTtcbiAgICAgIGlmIChqID09IGwpIGJyZWFrO1xuICAgICAgaSA9IGo7XG4gICAgfVxuICAgIGlmIChjIDwgMHg4MDApIHtcbiAgICAgIHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweGMwIHwgKGMgPj4gNikpO1xuICAgICAgdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ODAgfCAoYyAmIDB4M2YpKTtcbiAgICB9IGVsc2UgaWYgKGMgPCAweGQ4MDAgfHwgYyA+PSAweGRmZmYpIHtcbiAgICAgIHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweGUwIHwgKGMgPj4gMTIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4ODAgfCAoKGMgPj4gNikgJiAweDNmKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDgwIHwgKGMgJiAweDNmKSk7XG4gICAgfSBlbHNlIGlmIChjID49IDB4ZGJmZiB8fCBpICsgMSA9PSBsIHx8XG4gICAgICAgICAgICAgICAoZCA9IHMuY2hhckNvZGVBdChpICsgMSkpIDwgMHhkYzAwIHx8IGQgPiAweGRmZmYpIHtcbiAgICAgIC8vIFVubWF0Y2hlZCBzdXJyb2dhdGUgcGFpciwgcmVwbGFjZWQgYnkgXFx1ZmZmZCAocmVwbGFjZW1lbnQgY2hhcmFjdGVyKVxuICAgICAgdCArPSBcIlxceGVmXFx4YmZcXHhiZFwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBpKys7XG4gICAgICBjID0gKGMgPDwgMTApICsgZCAtIDB4MzVmZGMwMDtcbiAgICAgIHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweGYwIHwgKGMgPj4gMTgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4ODAgfCAoKGMgPj4gMTIpICYgMHgzZiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg4MCB8ICgoYyA+PiA2KSAmIDB4M2YpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4ODAgfCAoYyAmIDB4M2YpKTtcbiAgICB9XG4gICAgaWYgKHQubGVuZ3RoID4gMTAyNCkge3Quc3Vic3RyKDAsIDEpOyBiICs9IHQ7IHQgPSBcIlwiO31cbiAgfVxuICByZXR1cm4gYit0O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3V0ZjE2X29mX3V0ZjhcbmZ1bmN0aW9uIGNhbWxfdXRmMTZfb2ZfdXRmOChzKSB7XG4gIGZvciAodmFyIGIgPSBcIlwiLCB0ID0gXCJcIiwgYywgYzEsIGMyLCB2LCBpID0gMCwgbCA9IHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgYzEgPSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGMxIDwgMHg4MCkge1xuICAgICAgZm9yICh2YXIgaiA9IGkgKyAxOyAoaiA8IGwpICYmIChjMSA9IHMuY2hhckNvZGVBdChqKSkgPCAweDgwOyBqKyspO1xuICAgICAgaWYgKGogLSBpID4gNTEyKSB7IHQuc3Vic3RyKDAsIDEpOyBiICs9IHQ7IHQgPSBcIlwiOyBiICs9IHMuc2xpY2UoaSwgaikgfVxuICAgICAgZWxzZSB0ICs9IHMuc2xpY2UoaSwgaik7XG4gICAgICBpZiAoaiA9PSBsKSBicmVhaztcbiAgICAgIGkgPSBqO1xuICAgIH1cbiAgICB2ID0gMTtcbiAgICBpZiAoKCsraSA8IGwpICYmICgoKGMyID0gcy5jaGFyQ29kZUF0KGkpKSAmIC02NCkgPT0gMTI4KSkge1xuICAgICAgYyA9IGMyICsgKGMxIDw8IDYpO1xuICAgICAgaWYgKGMxIDwgMHhlMCkge1xuICAgICAgICB2ID0gYyAtIDB4MzA4MDtcbiAgICAgICAgaWYgKHYgPCAweDgwKSB2ID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHYgPSAyO1xuICAgICAgICBpZiAoKCsraSA8IGwpICYmICgoKGMyID0gcy5jaGFyQ29kZUF0KGkpKSAmIC02NCkgPT0gMTI4KSkge1xuICAgICAgICAgIGMgPSBjMiArIChjIDw8IDYpO1xuICAgICAgICAgIGlmIChjMSA8IDB4ZjApIHtcbiAgICAgICAgICAgIHYgPSBjIC0gMHhlMjA4MDtcbiAgICAgICAgICAgIGlmICgodiA8IDB4ODAwKSB8fCAoKHYgPj0gMHhkN2ZmKSAmJiAodiA8IDB4ZTAwMCkpKSB2ID0gMjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdiA9IDM7XG4gICAgICAgICAgICBpZiAoKCsraSA8IGwpICYmICgoKGMyID0gcy5jaGFyQ29kZUF0KGkpKSAmIC02NCkgPT0gMTI4KSAmJlxuICAgICAgICAgICAgICAgIChjMSA8IDB4ZjUpKSB7XG4gICAgICAgICAgICAgIHYgPSBjMiAtIDB4M2M4MjA4MCArIChjIDw8IDYpO1xuICAgICAgICAgICAgICBpZiAodiA8IDB4MTAwMDAgfHwgdiA+IDB4MTBmZmZmKSB2ID0gMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHYgPCA0KSB7IC8vIEludmFsaWQgc2VxdWVuY2VcbiAgICAgIGkgLT0gdjtcbiAgICAgIHQgKz0gXCJcXHVmZmZkXCI7XG4gICAgfSBlbHNlIGlmICh2ID4gMHhmZmZmKVxuICAgICAgdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZDdjMCArICh2ID4+IDEwKSwgMHhkYzAwICsgKHYgJiAweDNGRikpXG4gICAgZWxzZVxuICAgICAgdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHYpO1xuICAgIGlmICh0Lmxlbmd0aCA+IDEwMjQpIHt0LnN1YnN0cigwLCAxKTsgYiArPSB0OyB0ID0gXCJcIjt9XG4gIH1cbiAgcmV0dXJuIGIrdDtcbn1cblxuLy9Qcm92aWRlczoganNvb19pc19hc2NpaVxuZnVuY3Rpb24ganNvb19pc19hc2NpaSAocykge1xuICAvLyBUaGUgcmVndWxhciBleHByZXNzaW9uIGdldHMgYmV0dGVyIGF0IGFyb3VuZCB0aGlzIHBvaW50IGZvciBhbGwgYnJvd3NlcnNcbiAgaWYgKHMubGVuZ3RoIDwgMjQpIHtcbiAgICAvLyBTcGlkZXJtb25rZXkgZ2V0cyBtdWNoIHNsb3dlciB3aGVuIHMubGVuZ3RoID49IDI0IChvbiA2NCBiaXQgYXJjaHMpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzLmxlbmd0aDsgaSsrKSBpZiAocy5jaGFyQ29kZUF0KGkpID4gMTI3KSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZVxuICAgIHJldHVybiAhL1teXFx4MDAtXFx4N2ZdLy50ZXN0KHMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQgbXV0YWJsZVxuZnVuY3Rpb24gY2FtbF9ieXRlc191bnNhZmVfZ2V0IChzLCBpKSB7XG4gIHN3aXRjaCAocy50ICYgNikge1xuICBkZWZhdWx0OiAvKiBQQVJUSUFMICovXG4gICAgaWYgKGkgPj0gcy5jLmxlbmd0aCkgcmV0dXJuIDA7XG4gIGNhc2UgMDogLyogQllURVMgKi9cbiAgICByZXR1cm4gcy5jLmNoYXJDb2RlQXQoaSk7XG4gIGNhc2UgNDogLyogQVJSQVkgKi9cbiAgICByZXR1cm4gcy5jW2ldXG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc191bnNhZmVfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfdW5zYWZlX3NldCAocywgaSwgYykge1xuICAvLyBUaGUgT0NhbWwgY29tcGlsZXIgdXNlcyBDaGFyLnVuc2FmZV9jaHIgb24gaW50ZWdlcnMgbGFyZ2VyIHRoYW4gMjU1IVxuICBjICY9IDB4ZmY7XG4gIGlmIChzLnQgIT0gNCAvKiBBUlJBWSAqLykge1xuICAgIGlmIChpID09IHMuYy5sZW5ndGgpIHtcbiAgICAgIHMuYyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlIChjKTtcbiAgICAgIGlmIChpICsgMSA9PSBzLmwpIHMudCA9IDA7IC8qQllURVMgfCBVTktPV04qL1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGNhbWxfY29udmVydF9ieXRlc190b19hcnJheSAocyk7XG4gIH1cbiAgcy5jW2ldID0gYztcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yICgpIHtcbiAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50IChcImluZGV4IG91dCBvZiBib3VuZHNcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfYm91bmRfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9ieXRlc19ib3VuZF9lcnJvciAoKSB7XG4gIGNhbWxfaW52YWxpZF9hcmd1bWVudCAoXCJpbmRleCBvdXQgb2YgYm91bmRzXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19nZXRcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yLCBjYW1sX3N0cmluZ191bnNhZmVfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2dldCAocywgaSkge1xuICBpZiAoaSA+Pj4gMCA+PSBjYW1sX21sX3N0cmluZ19sZW5ndGgocykpIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yKCk7XG4gIHJldHVybiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfZ2V0MTZcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQsIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2dldDE2KHMsaSkge1xuICBpZiAoaSA+Pj4gMCA+PSBjYW1sX21sX3N0cmluZ19sZW5ndGgocykgLSAxKSBjYW1sX3N0cmluZ19ib3VuZF9lcnJvcigpO1xuICB2YXIgYjEgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpKSxcbiAgICAgIGIyID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSArIDEpO1xuICByZXR1cm4gKGIyIDw8IDggfCBiMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfZ2V0MTZcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfdW5zYWZlX2dldCwgY2FtbF9ieXRlc19ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9ieXRlc19nZXQxNihzLGkpIHtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sIC0gMSkgY2FtbF9ieXRlc19ib3VuZF9lcnJvcigpO1xuICB2YXIgYjEgPSBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQgKHMsIGkpLFxuICAgICAgYjIgPSBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQgKHMsIGkgKyAxKTtcbiAgcmV0dXJuIChiMiA8PCA4IHwgYjEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19nZXQzMlxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfdW5zYWZlX2dldCwgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9zdHJpbmdfZ2V0MzIocyxpKSB7XG4gIGlmIChpID4+PiAwID49IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSAtIDMpIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yKCk7XG4gIHZhciBiMSA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkpLFxuICAgICAgYjIgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpICsgMSksXG4gICAgICBiMyA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkgKyAyKSxcbiAgICAgIGI0ID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSArIDMpO1xuICByZXR1cm4gKGI0IDw8IDI0IHwgYjMgPDwgMTYgfCBiMiA8PCA4IHwgYjEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2dldDMyXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQsIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfZ2V0MzIocyxpKSB7XG4gIGlmIChpID4+PiAwID49IHMubCAtIDMpIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGIxID0gY2FtbF9ieXRlc191bnNhZmVfZ2V0IChzLCBpKSxcbiAgICAgIGIyID0gY2FtbF9ieXRlc191bnNhZmVfZ2V0IChzLCBpICsgMSksXG4gICAgICBiMyA9IGNhbWxfYnl0ZXNfdW5zYWZlX2dldCAocywgaSArIDIpLFxuICAgICAgYjQgPSBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQgKHMsIGkgKyAzKTtcbiAgcmV0dXJuIChiNCA8PCAyNCB8IGIzIDw8IDE2IHwgYjIgPDwgOCB8IGIxKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfZ2V0NjRcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQsIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2dldDY0KHMsaSkge1xuICBpZiAoaSA+Pj4gMCA+PSBjYW1sX21sX3N0cmluZ19sZW5ndGgocykgLSA3KSBjYW1sX3N0cmluZ19ib3VuZF9lcnJvcigpO1xuICB2YXIgYSA9IG5ldyBBcnJheSg4KTtcbiAgZm9yKHZhciBqID0gMDsgaiA8IDg7IGorKyl7XG4gICAgYVs3IC0gal0gPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpICsgaik7XG4gIH1cbiAgcmV0dXJuIGNhbWxfaW50NjRfb2ZfYnl0ZXMoYSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfZ2V0NjRcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfdW5zYWZlX2dldCwgY2FtbF9ieXRlc19ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZl9ieXRlc1xuZnVuY3Rpb24gY2FtbF9ieXRlc19nZXQ2NChzLGkpIHtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sIC0gNykgY2FtbF9ieXRlc19ib3VuZF9lcnJvcigpO1xuICB2YXIgYSA9IG5ldyBBcnJheSg4KTtcbiAgZm9yKHZhciBqID0gMDsgaiA8IDg7IGorKyl7XG4gICAgYVs3IC0gal0gPSBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQgKHMsIGkgKyBqKTtcbiAgfVxuICByZXR1cm4gY2FtbF9pbnQ2NF9vZl9ieXRlcyhhKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19nZXRcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IsIGNhbWxfYnl0ZXNfdW5zYWZlX2dldFxuZnVuY3Rpb24gY2FtbF9ieXRlc19nZXQgKHMsIGkpIHtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sKSBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yKCk7XG4gIHJldHVybiBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQgKHMsIGkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19zZXRcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfc2V0IChzLCBpLCBjKSB7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3N0cmluZ19zZXRcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3NldFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfdW5zYWZlX3NldCwgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3Jcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3NldCAocywgaSwgYykge1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwpIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yKCk7XG4gIHJldHVybiBjYW1sX3N0cmluZ191bnNhZmVfc2V0IChzLCBpLCBjKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19zZXQxNlxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19ib3VuZF9lcnJvciwgY2FtbF9ieXRlc191bnNhZmVfc2V0XG5mdW5jdGlvbiBjYW1sX2J5dGVzX3NldDE2KHMsaSxpMTYpe1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwgLSAxKSBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yKCk7XG4gIHZhciBiMiA9IDB4RkYgJiBpMTYgPj4gOCxcbiAgICAgIGIxID0gMHhGRiAmIGkxNjtcbiAgY2FtbF9ieXRlc191bnNhZmVfc2V0IChzLCBpICsgMCwgYjEpO1xuICBjYW1sX2J5dGVzX3Vuc2FmZV9zZXQgKHMsIGkgKyAxLCBiMik7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3NldDE2XG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3NldDE2KHMsaSxpMTYpe1xuICAgIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3N0cmluZ19zZXQxNlwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfc2V0MTZcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfc2V0MTZcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3NldDE2KHMsaSxpMTYpe1xuICByZXR1cm4gY2FtbF9ieXRlc19zZXQxNihzLGksaTE2KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19zZXQzMlxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19ib3VuZF9lcnJvciwgY2FtbF9ieXRlc191bnNhZmVfc2V0XG5mdW5jdGlvbiBjYW1sX2J5dGVzX3NldDMyKHMsaSxpMzIpe1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwgLSAzKSBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yKCk7XG4gIHZhciBiNCA9IDB4RkYgJiBpMzIgPj4gMjQsXG4gICAgICBiMyA9IDB4RkYgJiBpMzIgPj4gMTYsXG4gICAgICBiMiA9IDB4RkYgJiBpMzIgPj4gOCxcbiAgICAgIGIxID0gMHhGRiAmIGkzMjtcbiAgY2FtbF9ieXRlc191bnNhZmVfc2V0IChzLCBpICsgMCwgYjEpO1xuICBjYW1sX2J5dGVzX3Vuc2FmZV9zZXQgKHMsIGkgKyAxLCBiMik7XG4gIGNhbWxfYnl0ZXNfdW5zYWZlX3NldCAocywgaSArIDIsIGIzKTtcbiAgY2FtbF9ieXRlc191bnNhZmVfc2V0IChzLCBpICsgMywgYjQpO1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19zZXQzMlxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19zZXQzMihzLGksaTMyKXtcbiAgICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9zdHJpbmdfc2V0MzJcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3NldDMyXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX3NldDMyXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19zZXQzMihzLGksaTMyKXtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfc2V0MzIocyxpLGkzMik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfc2V0NjRcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IsIGNhbWxfYnl0ZXNfdW5zYWZlX3NldFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF90b19ieXRlc1xuZnVuY3Rpb24gY2FtbF9ieXRlc19zZXQ2NChzLGksaTY0KXtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sIC0gNykgY2FtbF9ieXRlc19ib3VuZF9lcnJvcigpO1xuICB2YXIgYSA9IGNhbWxfaW50NjRfdG9fYnl0ZXMoaTY0KTtcbiAgZm9yKHZhciBqID0gMDsgaiA8IDg7IGorKykge1xuICAgIGNhbWxfYnl0ZXNfdW5zYWZlX3NldCAocywgaSArIDcgLSBqLCBhW2pdKTtcbiAgfVxuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19zZXQ2NFxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19zZXQ2NChzLGksaTY0KXtcbiAgICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9zdHJpbmdfc2V0NjRcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3NldDY0XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX3NldDY0XG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19zZXQ2NChzLGksaTY0KXtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfc2V0NjQocyxpLGk2NCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yLCBjYW1sX2J5dGVzX3Vuc2FmZV9zZXRcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfc2V0IChzLCBpLCBjKSB7XG4gIGlmIChpID4+PiAwID49IHMubCkgY2FtbF9ieXRlc19ib3VuZF9lcnJvcigpO1xuICByZXR1cm4gY2FtbF9ieXRlc191bnNhZmVfc2V0IChzLCBpLCBjKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19vZl91dGYxNl9qc3N0cmluZ1xuLy9SZXF1aXJlczoganNvb19pc19hc2NpaSwgY2FtbF91dGY4X29mX3V0ZjE2LCBNbEJ5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX29mX3V0ZjE2X2pzc3RyaW5nIChzKSB7XG4gIHZhciB0YWcgPSA5IC8qIEJZVEVTIHwgQVNDSUkgKi87XG4gIGlmICghanNvb19pc19hc2NpaShzKSlcbiAgICB0YWcgPSA4IC8qIEJZVEVTIHwgTk9UX0FTQ0lJICovLCBzID0gY2FtbF91dGY4X29mX3V0ZjE2KHMpO1xuICByZXR1cm4gbmV3IE1sQnl0ZXModGFnLCBzLCBzLmxlbmd0aCk7XG59XG5cblxuLy9Qcm92aWRlczogTWxCeXRlc1xuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcywganNvb19pc19hc2NpaSwgY2FtbF91dGYxNl9vZl91dGY4XG5mdW5jdGlvbiBNbEJ5dGVzICh0YWcsIGNvbnRlbnRzLCBsZW5ndGgpIHtcbiAgdGhpcy50PXRhZzsgdGhpcy5jPWNvbnRlbnRzOyB0aGlzLmw9bGVuZ3RoO1xufVxuTWxCeXRlcy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpe1xuICBzd2l0Y2ggKHRoaXMudCkge1xuICBjYXNlIDk6IC8qQllURVMgfCBBU0NJSSovXG4gICAgcmV0dXJuIHRoaXMuYztcbiAgZGVmYXVsdDpcbiAgICBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHRoaXMpO1xuICBjYXNlIDA6IC8qQllURVMgfCBVTktPV04qL1xuICAgIGlmIChqc29vX2lzX2FzY2lpKHRoaXMuYykpIHtcbiAgICAgIHRoaXMudCA9IDk7IC8qQllURVMgfCBBU0NJSSovXG4gICAgICByZXR1cm4gdGhpcy5jO1xuICAgIH1cbiAgICB0aGlzLnQgPSA4OyAvKkJZVEVTIHwgTk9UX0FTQ0lJKi9cbiAgY2FzZSA4OiAvKkJZVEVTIHwgTk9UX0FTQ0lJKi9cbiAgICByZXR1cm4gdGhpcy5jO1xuICB9XG59O1xuTWxCeXRlcy5wcm90b3R5cGUudG9VdGYxNiA9IGZ1bmN0aW9uICgpe1xuICB2YXIgciA9IHRoaXMudG9TdHJpbmcoKTtcbiAgaWYodGhpcy50ID09IDkpIHJldHVybiByXG4gIHJldHVybiBjYW1sX3V0ZjE2X29mX3V0Zjgocik7XG59XG5NbEJ5dGVzLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uICgpe1xuICB2YXIgY29udGVudCA9IHRoaXMudCA9PSA0ID8gdGhpcy5jLnNsaWNlKCkgOiB0aGlzLmM7XG4gIHJldHVybiBuZXcgTWxCeXRlcyh0aGlzLnQsY29udGVudCx0aGlzLmwpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX3N0cl9yZXBlYXQsIGNhbWxfc3ViYXJyYXlfdG9fanNieXRlc1xuZnVuY3Rpb24gY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyAocykge1xuICAvKiBBc3N1bWVzIG5vdCBCWVRFUyAqL1xuICBpZiAocy50ID09IDIgLyogUEFSVElBTCAqLylcbiAgICBzLmMgKz0gY2FtbF9zdHJfcmVwZWF0KHMubCAtIHMuYy5sZW5ndGgsICdcXDAnKVxuICBlbHNlXG4gICAgcy5jID0gY2FtbF9zdWJhcnJheV90b19qc2J5dGVzIChzLmMsIDAsIHMuYy5sZW5ndGgpO1xuICBzLnQgPSAwOyAvKkJZVEVTIHwgVU5LT1dOKi9cbn1cblxuLy9Qcm92aWRlczogY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5XG5mdW5jdGlvbiBjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXkgKHMpIHtcbiAgLyogQXNzdW1lcyBub3QgQVJSQVkgKi9cbiAgaWYoam9vX2dsb2JhbF9vYmplY3QuVWludDhBcnJheSkge1xuICAgIHZhciBhID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0LlVpbnQ4QXJyYXkocy5sKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgYSA9IG5ldyBBcnJheShzLmwpO1xuICB9XG4gIHZhciBiID0gcy5jLCBsID0gYi5sZW5ndGgsIGkgPSAwO1xuICBmb3IgKDsgaSA8IGw7IGkrKykgYVtpXSA9IGIuY2hhckNvZGVBdChpKTtcbiAgZm9yIChsID0gcy5sOyBpIDwgbDsgaSsrKSBhW2ldID0gMDtcbiAgcy5jID0gYTtcbiAgcy50ID0gNDsgLyogQVJSQVkgKi9cbiAgcmV0dXJuIGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYXJyYXlfb2ZfYnl0ZXMgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5XG5mdW5jdGlvbiBjYW1sX2FycmF5X29mX2J5dGVzIChzKSB7XG4gIGlmIChzLnQgIT0gNCAvKiBBUlJBWSAqLykgY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5KHMpO1xuICByZXR1cm4gcy5jO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X29mX3N0cmluZyBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aCwgY2FtbF9zdHJpbmdfdW5zYWZlX2dldFxuZnVuY3Rpb24gY2FtbF9hcnJheV9vZl9zdHJpbmcgKHMpIHtcbiAgdmFyIGwgPSBjYW1sX21sX3N0cmluZ19sZW5ndGgocyk7XG4gIHZhciBhID0gbmV3IEFycmF5KGwpO1xuICB2YXIgaSA9IDA7XG4gIGZvciAoOyBpIDwgbDsgaSsrKSBhW2ldID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldChzLGkpO1xuICByZXR1cm4gYTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jcmVhdGVfc3RyaW5nIGNvbnN0XG4vL1JlcXVpcmVzOiBNbEJ5dGVzLCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfY3JlYXRlX3N0cmluZyhsZW4pIHtcbiAgaWYobGVuIDwgMCkgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiU3RyaW5nLmNyZWF0ZVwiKTtcbiAgcmV0dXJuIG5ldyBNbEJ5dGVzKGxlbj8yOjksXCJcIixsZW4pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NyZWF0ZV9zdHJpbmcgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2NyZWF0ZV9zdHJpbmcobGVuKSB7XG4gIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIlN0cmluZy5jcmVhdGVcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY3JlYXRlX2J5dGVzIGNvbnN0XG4vL1JlcXVpcmVzOiBNbEJ5dGVzLGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9jcmVhdGVfYnl0ZXMobGVuKSB7XG4gIGlmIChsZW4gPCAwKSBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCeXRlcy5jcmVhdGVcIik7XG4gIHJldHVybiBuZXcgTWxCeXRlcyhsZW4/Mjo5LFwiXCIsbGVuKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfb2ZfYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfc3ViYXJyYXlfdG9fanNieXRlcywgY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfb2ZfYXJyYXkgKGEpIHtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoY2FtbF9zdWJhcnJheV90b19qc2J5dGVzKGEsMCxhLmxlbmd0aCkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX29mX2FycmF5XG4vL1JlcXVpcmVzOiBNbEJ5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX29mX2FycmF5IChhKSB7XG4gIHJldHVybiBuZXcgTWxCeXRlcyg0LGEsYS5sZW5ndGgpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2NvbXBhcmUgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlc1xuZnVuY3Rpb24gY2FtbF9ieXRlc19jb21wYXJlKHMxLCBzMikge1xuICAoczEudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczEpO1xuICAoczIudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczIpO1xuICByZXR1cm4gKHMxLmMgPCBzMi5jKT8tMTooczEuYyA+IHMyLmMpPzE6MDtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2VxdWFsIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfZXF1YWwoczEsIHMyKSB7XG4gIGlmKHMxID09PSBzMikgcmV0dXJuIDE7XG4gIChzMS50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzMSk7XG4gIChzMi50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzMik7XG4gIHJldHVybiAoczEuYyA9PSBzMi5jKT8xOjA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX25vdGVxdWFsIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX2VxdWFsXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19ub3RlcXVhbChzMSwgczIpIHsgcmV0dXJuIDEtY2FtbF9zdHJpbmdfZXF1YWwoczEsIHMyKTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX25vdGVxdWFsIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX2VxdWFsXG5mdW5jdGlvbiBjYW1sX2J5dGVzX25vdGVxdWFsKHMxLCBzMikgeyByZXR1cm4gMS1jYW1sX3N0cmluZ19lcXVhbChzMSwgczIpOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfbGVzc2VxdWFsIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfbGVzc2VxdWFsKHMxLCBzMikge1xuICAoczEudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczEpO1xuICAoczIudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczIpO1xuICByZXR1cm4gKHMxLmMgPD0gczIuYyk/MTowO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2xlc3N0aGFuIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfbGVzc3RoYW4oczEsIHMyKSB7XG4gIChzMS50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzMSk7XG4gIChzMi50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzMik7XG4gIHJldHVybiAoczEuYyA8IHMyLmMpPzE6MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfZ3JlYXRlcmVxdWFsXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19sZXNzZXF1YWxcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2dyZWF0ZXJlcXVhbChzMSwgczIpIHtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX2xlc3NlcXVhbChzMixzMSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2dyZWF0ZXJlcXVhbFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19sZXNzZXF1YWxcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfZ3JlYXRlcmVxdWFsKHMxLCBzMikge1xuICByZXR1cm4gY2FtbF9ieXRlc19sZXNzZXF1YWwoczIsczEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19ncmVhdGVydGhhblxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfbGVzc3RoYW5cbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2dyZWF0ZXJ0aGFuKHMxLCBzMikge1xuICByZXR1cm4gY2FtbF9zdHJpbmdfbGVzc3RoYW4oczIsIHMxKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19ncmVhdGVydGhhblxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19sZXNzdGhhblxuZnVuY3Rpb24gY2FtbF9ieXRlc19ncmVhdGVydGhhbihzMSwgczIpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfbGVzc3RoYW4oczIsIHMxKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9maWxsX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX3N0cl9yZXBlYXQsIGNhbWxfY29udmVydF9ieXRlc190b19hcnJheVxuZnVuY3Rpb24gY2FtbF9maWxsX2J5dGVzKHMsIGksIGwsIGMpIHtcbiAgaWYgKGwgPiAwKSB7XG4gICAgaWYgKGkgPT0gMCAmJiAobCA+PSBzLmwgfHwgKHMudCA9PSAyIC8qIFBBUlRJQUwgKi8gJiYgbCA+PSBzLmMubGVuZ3RoKSkpIHtcbiAgICAgIGlmIChjID09IDApIHtcbiAgICAgICAgcy5jID0gXCJcIjtcbiAgICAgICAgcy50ID0gMjsgLyogUEFSVElBTCAqL1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcy5jID0gY2FtbF9zdHJfcmVwZWF0IChsLCBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpKTtcbiAgICAgICAgcy50ID0gKGwgPT0gcy5sKT8wIC8qIEJZVEVTIHwgVU5LT1dOICovIDoyOyAvKiBQQVJUSUFMICovXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzLnQgIT0gNCAvKiBBUlJBWSAqLykgY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5KHMpO1xuICAgICAgZm9yIChsICs9IGk7IGkgPCBsOyBpKyspIHMuY1tpXSA9IGM7XG4gICAgfVxuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ZpbGxfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2ZpbGxfYnl0ZXNcbnZhciBjYW1sX2ZpbGxfc3RyaW5nID0gY2FtbF9maWxsX2J5dGVzXG5cbi8vUHJvdmlkZXM6IGNhbWxfYmxpdF9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9zdWJhcnJheV90b19qc2J5dGVzLCBjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfYmxpdF9ieXRlcyhzMSwgaTEsIHMyLCBpMiwgbGVuKSB7XG4gIGlmIChsZW4gPT0gMCkgcmV0dXJuIDA7XG4gIGlmICgoaTIgPT0gMCkgJiZcbiAgICAgIChsZW4gPj0gczIubCB8fCAoczIudCA9PSAyIC8qIFBBUlRJQUwgKi8gJiYgbGVuID49IHMyLmMubGVuZ3RoKSkpIHtcbiAgICBzMi5jID0gKHMxLnQgPT0gNCAvKiBBUlJBWSAqLyk/XG4gICAgICBjYW1sX3N1YmFycmF5X3RvX2pzYnl0ZXMoczEuYywgaTEsIGxlbik6XG4gICAgICAoaTEgPT0gMCAmJiBzMS5jLmxlbmd0aCA9PSBsZW4pP3MxLmM6czEuYy5zdWJzdHIoaTEsIGxlbik7XG4gICAgczIudCA9IChzMi5jLmxlbmd0aCA9PSBzMi5sKT8wIC8qIEJZVEVTIHwgVU5LT1dOICovIDoyOyAvKiBQQVJUSUFMICovXG4gIH0gZWxzZSBpZiAoczIudCA9PSAyIC8qIFBBUlRJQUwgKi8gJiYgaTIgPT0gczIuYy5sZW5ndGgpIHtcbiAgICBzMi5jICs9IChzMS50ID09IDQgLyogQVJSQVkgKi8pP1xuICAgICAgY2FtbF9zdWJhcnJheV90b19qc2J5dGVzKHMxLmMsIGkxLCBsZW4pOlxuICAgICAgKGkxID09IDAgJiYgczEuYy5sZW5ndGggPT0gbGVuKT9zMS5jOnMxLmMuc3Vic3RyKGkxLCBsZW4pO1xuICAgIHMyLnQgPSAoczIuYy5sZW5ndGggPT0gczIubCk/MCAvKiBCWVRFUyB8IFVOS09XTiAqLyA6MjsgLyogUEFSVElBTCAqL1xuICB9IGVsc2Uge1xuICAgIGlmIChzMi50ICE9IDQgLyogQVJSQVkgKi8pIGNhbWxfY29udmVydF9ieXRlc190b19hcnJheShzMik7XG4gICAgdmFyIGMxID0gczEuYywgYzIgPSBzMi5jO1xuICAgIGlmIChzMS50ID09IDQgLyogQVJSQVkgKi8pIHtcbiAgICAgIGlmIChpMiA8PSBpMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSBjMiBbaTIgKyBpXSA9IGMxIFtpMSArIGldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IGxlbiAtIDE7IGkgPj0gMDsgaS0tKSBjMiBbaTIgKyBpXSA9IGMxIFtpMSArIGldO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbCA9IE1hdGgubWluIChsZW4sIGMxLmxlbmd0aCAtIGkxKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSBjMiBbaTIgKyBpXSA9IGMxLmNoYXJDb2RlQXQoaTEgKyBpKTtcbiAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIGMyIFtpMiArIGldID0gMDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmxpdF9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfYmxpdF9ieXRlcywgY2FtbF9ieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfYmxpdF9zdHJpbmcoYSxiLGMsZCxlKSB7XG4gICAgY2FtbF9ibGl0X2J5dGVzKGNhbWxfYnl0ZXNfb2Zfc3RyaW5nKGEpLGIsYyxkLGUpO1xuICAgIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfYnl0ZXNfbGVuZ3RoIGNvbnN0XG5mdW5jdGlvbiBjYW1sX21sX2J5dGVzX2xlbmd0aChzKSB7IHJldHVybiBzLmwgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IGNvbnN0XG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkpIHtcbiAgcmV0dXJuIHMuY2hhckNvZGVBdChpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfdW5zYWZlX3NldFxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ191bnNhZmVfc2V0IChzLCBpLCBjKSB7XG4gICAgY2FtbF9mYWlsd2l0aChcImNhbWxfc3RyaW5nX3Vuc2FmZV9zZXRcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aCBjb25zdFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX21sX3N0cmluZ19sZW5ndGgocykge1xuICByZXR1cm4gcy5sZW5ndGhcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfY29tcGFyZSBjb25zdFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19jb21wYXJlKHMxLCBzMikge1xuICByZXR1cm4gKHMxIDwgczIpPy0xOihzMSA+IHMyKT8xOjA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2VxdWFsIGNvbnN0XG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2VxdWFsKHMxLCBzMikge1xuICBpZihzMSA9PT0gczIpIHJldHVybiAxO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfbGVzc2VxdWFsIGNvbnN0XG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2xlc3NlcXVhbChzMSwgczIpIHtcbiAgcmV0dXJuIChzMSA8PSBzMik/MTowO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19sZXNzdGhhbiBjb25zdFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19sZXNzdGhhbihzMSwgczIpIHtcbiAgcmV0dXJuIChzMSA8IHMyKT8xOjA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX29mX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX29mX2J5dGVzKHMpIHtcbiAgICAocy50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzKTtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMocy5jKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19vZl9zdHJpbmcgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfb2ZfanNieXRlcywgY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2J5dGVzX29mX3N0cmluZyhzKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX29mX2pzYnl0ZXMoY2FtbF9qc2J5dGVzX29mX3N0cmluZyhzKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMgY29uc3Rcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyh4KSB7IHJldHVybiB4IH1cblxuLy9Qcm92aWRlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZyBjb25zdFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKHgpIHsgcmV0dXJuIHggfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyBjb25zdFxuLy9SZXF1aXJlczoganNvb19pc19hc2NpaSwgY2FtbF91dGYxNl9vZl91dGY4XG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHMpIHtcbiAgaWYoanNvb19pc19hc2NpaShzKSlcbiAgICByZXR1cm4gcztcbiAgcmV0dXJuIGNhbWxfdXRmMTZfb2ZfdXRmOChzKTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyBjb25zdFxuLy9SZXF1aXJlczoganNvb19pc19hc2NpaSwgY2FtbF91dGY4X29mX3V0ZjE2LCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nIChzKSB7XG4gIGlmIChqc29vX2lzX2FzY2lpKHMpKVxuICAgIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKHMpXG4gIGVsc2UgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoY2FtbF91dGY4X29mX3V0ZjE2KHMpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19vZl9qc2J5dGVzIGNvbnN0XG4vL1JlcXVpcmVzOiBNbEJ5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX29mX2pzYnl0ZXMocykgeyByZXR1cm4gbmV3IE1sQnl0ZXMoMCxzLHMubGVuZ3RoKTsgfVxuXG5cbi8vIFRoZSBzZWN0aW9uIGJlbG93IHNob3VsZCBiZSB1c2VkIHdoZW4gdXNlLWpzLXN0cmluZz1mYWxzZVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX3Vuc2FmZV9nZXRcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfdW5zYWZlX2dldChzLGkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ191bnNhZmVfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX3Vuc2FmZV9zZXRcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3Vuc2FmZV9zZXQgKHMsIGksIGMpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfdW5zYWZlX3NldChzLGksYyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9tbF9ieXRlc19sZW5ndGhcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSB7XG4gIHJldHVybiBjYW1sX21sX2J5dGVzX2xlbmd0aChzKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19jb21wYXJlXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2NvbXBhcmVcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2NvbXBhcmUoczEsIHMyKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX2NvbXBhcmUoczEsczIpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2VxdWFsXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2VxdWFsXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19lcXVhbChzMSwgczIpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfZXF1YWwoczEsczIpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2xlc3NlcXVhbFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19sZXNzZXF1YWxcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2xlc3NlcXVhbChzMSwgczIpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfbGVzc2VxdWFsKHMxLHMyKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19sZXNzdGhhblxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19sZXNzdGhhblxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfbGVzc3RoYW4oczEsIHMyKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX2xlc3N0aGFuKHMxLHMyKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19vZl9ieXRlc1xuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfb2ZfYnl0ZXMocykgeyByZXR1cm4gcyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfb2Zfc3RyaW5nIGNvbnN0XG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2J5dGVzX29mX3N0cmluZyhzKSB7IHJldHVybiBzIH1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlcyBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19vZl9qc2J5dGVzXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKHMpIHsgcmV0dXJuIGNhbWxfYnl0ZXNfb2ZfanNieXRlcyhzKTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKHMpIHtcbiAgaWYgKChzLnQgJiA2KSAhPSAwIC8qIEJZVEVTICovKSBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMpO1xuICByZXR1cm4gcy5jIH1cblxuLy9Qcm92aWRlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcgbXV0YWJsZSAoY29uc3QpXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhzKXtcbiAgcmV0dXJuIHMudG9VdGYxNigpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX29mX3V0ZjE2X2pzc3RyaW5nXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyAocykge1xuICByZXR1cm4gY2FtbF9ieXRlc19vZl91dGYxNl9qc3N0cmluZyhzKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pc19tbF9ieXRlc1xuLy9SZXF1aXJlczogTWxCeXRlc1xuZnVuY3Rpb24gY2FtbF9pc19tbF9ieXRlcyhzKSB7XG4gIHJldHVybiAocyBpbnN0YW5jZW9mIE1sQnl0ZXMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lzX21sX3N0cmluZ1xuLy9SZXF1aXJlczoganNvb19pc19hc2NpaVxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2lzX21sX3N0cmluZyhzKSB7XG4gIHJldHVybiAodHlwZW9mIHMgPT09IFwic3RyaW5nXCIgJiYgIS9bXlxceDAwLVxceGZmXS8udGVzdChzKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaXNfbWxfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2lzX21sX2J5dGVzXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2lzX21sX3N0cmluZyhzKSB7XG4gIHJldHVybiBjYW1sX2lzX21sX2J5dGVzKHMpO1xufVxuXG4vLyBUaGUgZnVuY3Rpb25zIGJlbG93IGFyZSBkZXByZWNhdGVkXG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfdG9fYnl0ZV9zdHJpbmcgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfanNfdG9fYnl0ZV9zdHJpbmcocykgeyByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhzKSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfbmV3X3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9uZXdfc3RyaW5nIChzKSB7IHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKHMpIH1cblxuLy9Qcm92aWRlczogY2FtbF9qc19mcm9tX3N0cmluZyBtdXRhYmxlIChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2pzX2Zyb21fc3RyaW5nKHMpIHtcbiAgcmV0dXJuIGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHMpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdG9fanNfc3RyaW5nIG11dGFibGUgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfdG9fanNfc3RyaW5nKHMpIHtcbiAgcmV0dXJuIGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHMpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfdG9fc3RyaW5nIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc190b19zdHJpbmcgKHMpIHtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKHMpO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9SYWlzZSBleGNlcHRpb25cblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV9jb25zdGFudCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX3JhaXNlX2NvbnN0YW50ICh0YWcpIHsgdGhyb3cgdGFnOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmV0dXJuX2V4bl9jb25zdGFudCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX3JldHVybl9leG5fY29uc3RhbnQgKHRhZykgeyByZXR1cm4gdGFnOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2Vfd2l0aF9hcmcgKGNvbnN0LCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfcmFpc2Vfd2l0aF9hcmcgKHRhZywgYXJnKSB7IHRocm93IFswLCB0YWcsIGFyZ107IH1cblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV93aXRoX3N0cmluZyAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV93aXRoX2FyZywgY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9yYWlzZV93aXRoX3N0cmluZyAodGFnLCBtc2cpIHtcbiAgY2FtbF9yYWlzZV93aXRoX2FyZyAodGFnLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKG1zZykpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ZhaWx3aXRoIChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcsIGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfZmFpbHdpdGggKG1zZykge1xuICBjYW1sX3JhaXNlX3dpdGhfc3RyaW5nKGNhbWxfZ2xvYmFsX2RhdGEuRmFpbHVyZSwgbXNnKTtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnQgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV93aXRoX3N0cmluZywgY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9pbnZhbGlkX2FyZ3VtZW50IChtc2cpIHtcbiAgY2FtbF9yYWlzZV93aXRoX3N0cmluZyhjYW1sX2dsb2JhbF9kYXRhLkludmFsaWRfYXJndW1lbnQsIG1zZyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2VfZW5kX29mX2ZpbGVcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2VfY29uc3RhbnQsIGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfcmFpc2VfZW5kX29mX2ZpbGUgKCkge1xuICBjYW1sX3JhaXNlX2NvbnN0YW50KGNhbWxfZ2xvYmFsX2RhdGEuRW5kX29mX2ZpbGUpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JhaXNlX3plcm9fZGl2aWRlXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX2NvbnN0YW50LCBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX3JhaXNlX3plcm9fZGl2aWRlICgpIHtcbiAgY2FtbF9yYWlzZV9jb25zdGFudChjYW1sX2dsb2JhbF9kYXRhLkRpdmlzaW9uX2J5X3plcm8pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JhaXNlX25vdF9mb3VuZFxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9jb25zdGFudCwgY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9yYWlzZV9ub3RfZm91bmQgKCkge1xuICBjYW1sX3JhaXNlX2NvbnN0YW50KGNhbWxfZ2xvYmFsX2RhdGEuTm90X2ZvdW5kKTsgfVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9hcnJheV9ib3VuZF9lcnJvciAoKSB7XG4gIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImluZGV4IG91dCBvZiBib3VuZHNcIik7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogY2FtbF9jYWxsX2dlbiAoY29uc3QsIHNoYWxsb3cpXG4vL1dlYWtkZWZcbmZ1bmN0aW9uIGNhbWxfY2FsbF9nZW4oZiwgYXJncykge1xuICBpZihmLmZ1bilcbiAgICByZXR1cm4gY2FtbF9jYWxsX2dlbihmLmZ1biwgYXJncyk7XG4gIC8vRklYTUUsIGNhbiBoYXBwZW4gd2l0aCB0b28gbWFueSBhcmd1bWVudHNcbiAgaWYodHlwZW9mIGYgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIGY7XG4gIHZhciBuID0gZi5sZW5ndGggfCAwO1xuICBpZihuID09PSAwKSByZXR1cm4gZi5hcHBseShudWxsLGFyZ3MpO1xuICB2YXIgYXJnc0xlbiA9IGFyZ3MubGVuZ3RoIHwgMDtcbiAgdmFyIGQgPSBuIC0gYXJnc0xlbiB8IDA7XG4gIGlmIChkID09IDApXG4gICAgcmV0dXJuIGYuYXBwbHkobnVsbCwgYXJncyk7XG4gIGVsc2UgaWYgKGQgPCAwKSB7XG4gICAgcmV0dXJuIGNhbWxfY2FsbF9nZW4oZi5hcHBseShudWxsLGFyZ3Muc2xpY2UoMCxuKSksYXJncy5zbGljZShuKSk7XG4gIH1cbiAgZWxzZSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpe1xuICAgICAgdmFyIGV4dHJhX2FyZ3MgPSAoYXJndW1lbnRzLmxlbmd0aCA9PSAwKT8xOmFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICB2YXIgbmFyZ3MgPSBuZXcgQXJyYXkoYXJncy5sZW5ndGgrZXh0cmFfYXJncyk7XG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKyApIG5hcmdzW2ldID0gYXJnc1tpXTtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKysgKSBuYXJnc1thcmdzLmxlbmd0aCtpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIHJldHVybiBjYW1sX2NhbGxfZ2VuKGYsIG5hcmdzKVxuICAgIH1cbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX25hbWVkX3ZhbHVlc1xudmFyIGNhbWxfbmFtZWRfdmFsdWVzID0ge307XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmVnaXN0ZXJfbmFtZWRfdmFsdWUgKGNvbnN0LGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9uYW1lZF92YWx1ZXMsIGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfcmVnaXN0ZXJfbmFtZWRfdmFsdWUobm0sdikge1xuICBjYW1sX25hbWVkX3ZhbHVlc1tjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKG5tKV0gPSB2O1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9uYW1lZF92YWx1ZVxuLy9SZXF1aXJlczogY2FtbF9uYW1lZF92YWx1ZXNcbmZ1bmN0aW9uIGNhbWxfbmFtZWRfdmFsdWUobm0pIHtcbiAgcmV0dXJuIGNhbWxfbmFtZWRfdmFsdWVzW25tXVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dsb2JhbF9kYXRhXG52YXIgY2FtbF9nbG9iYWxfZGF0YSA9IFswXTtcblxuLy9Qcm92aWRlczogY2FtbF9yZWdpc3Rlcl9nbG9iYWwgKGNvbnN0LCBzaGFsbG93LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfcmVnaXN0ZXJfZ2xvYmFsIChuLCB2LCBuYW1lX29wdCkge1xuICBpZihuYW1lX29wdCAmJiBqb29fZ2xvYmFsX29iamVjdC50b3BsZXZlbFJlbG9jKVxuICAgIG4gPSBqb29fZ2xvYmFsX29iamVjdC50b3BsZXZlbFJlbG9jKG5hbWVfb3B0KTtcbiAgY2FtbF9nbG9iYWxfZGF0YVtuICsgMV0gPSB2O1xuICBpZihuYW1lX29wdCkgY2FtbF9nbG9iYWxfZGF0YVtuYW1lX29wdF0gPSB2O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dldF9nbG9iYWxfZGF0YSBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX2dldF9nbG9iYWxfZGF0YSAoKSB7IHJldHVybiBjYW1sX2dsb2JhbF9kYXRhOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaXNfcHJpbnRhYmxlIGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfaXNfcHJpbnRhYmxlKGMpIHsgcmV0dXJuICsoYyA+IDMxICYmIGMgPCAxMjcpOyB9XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vLy8vLy8vLy8vLy8vIEZvcm1hdFxuXG4vL1Byb3ZpZGVzOiBjYW1sX3BhcnNlX2Zvcm1hdFxuLy9SZXF1aXJlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZywgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX3BhcnNlX2Zvcm1hdCAoZm10KSB7XG4gIGZtdCA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcoZm10KTtcbiAgdmFyIGxlbiA9IGZtdC5sZW5ndGg7XG4gIGlmIChsZW4gPiAzMSkgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiZm9ybWF0X2ludDogZm9ybWF0IHRvbyBsb25nXCIpO1xuICB2YXIgZiA9XG4gICAgICB7IGp1c3RpZnk6JysnLCBzaWduc3R5bGU6Jy0nLCBmaWxsZXI6JyAnLCBhbHRlcm5hdGU6ZmFsc2UsXG4gICAgICAgIGJhc2U6MCwgc2lnbmVkY29udjpmYWxzZSwgd2lkdGg6MCwgdXBwZXJjYXNlOmZhbHNlLFxuICAgICAgICBzaWduOjEsIHByZWM6LTEsIGNvbnY6J2YnIH07XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgYyA9IGZtdC5jaGFyQXQoaSk7XG4gICAgc3dpdGNoIChjKSB7XG4gICAgY2FzZSAnLSc6XG4gICAgICBmLmp1c3RpZnkgPSAnLSc7IGJyZWFrO1xuICAgIGNhc2UgJysnOiBjYXNlICcgJzpcbiAgICAgIGYuc2lnbnN0eWxlID0gYzsgYnJlYWs7XG4gICAgY2FzZSAnMCc6XG4gICAgICBmLmZpbGxlciA9ICcwJzsgYnJlYWs7XG4gICAgY2FzZSAnIyc6XG4gICAgICBmLmFsdGVybmF0ZSA9IHRydWU7IGJyZWFrO1xuICAgIGNhc2UgJzEnOiBjYXNlICcyJzogY2FzZSAnMyc6IGNhc2UgJzQnOiBjYXNlICc1JzpcbiAgICBjYXNlICc2JzogY2FzZSAnNyc6IGNhc2UgJzgnOiBjYXNlICc5JzpcbiAgICAgIGYud2lkdGggPSAwO1xuICAgICAgd2hpbGUgKGM9Zm10LmNoYXJDb2RlQXQoaSkgLSA0OCwgYyA+PSAwICYmIGMgPD0gOSkge1xuICAgICAgICBmLndpZHRoID0gZi53aWR0aCAqIDEwICsgYzsgaSsrXG4gICAgICB9XG4gICAgICBpLS07XG4gICAgICBicmVhaztcbiAgICBjYXNlICcuJzpcbiAgICAgIGYucHJlYyA9IDA7XG4gICAgICBpKys7XG4gICAgICB3aGlsZSAoYz1mbXQuY2hhckNvZGVBdChpKSAtIDQ4LCBjID49IDAgJiYgYyA8PSA5KSB7XG4gICAgICAgIGYucHJlYyA9IGYucHJlYyAqIDEwICsgYzsgaSsrXG4gICAgICB9XG4gICAgICBpLS07XG4gICAgY2FzZSAnZCc6IGNhc2UgJ2knOlxuICAgICAgZi5zaWduZWRjb252ID0gdHJ1ZTsgLyogZmFsbHRocm91Z2ggKi9cbiAgICBjYXNlICd1JzpcbiAgICAgIGYuYmFzZSA9IDEwOyBicmVhaztcbiAgICBjYXNlICd4JzpcbiAgICAgIGYuYmFzZSA9IDE2OyBicmVhaztcbiAgICBjYXNlICdYJzpcbiAgICAgIGYuYmFzZSA9IDE2OyBmLnVwcGVyY2FzZSA9IHRydWU7IGJyZWFrO1xuICAgIGNhc2UgJ28nOlxuICAgICAgZi5iYXNlID0gODsgYnJlYWs7XG4gICAgY2FzZSAnZSc6IGNhc2UgJ2YnOiBjYXNlICdnJzpcbiAgICAgIGYuc2lnbmVkY29udiA9IHRydWU7IGYuY29udiA9IGM7IGJyZWFrO1xuICAgIGNhc2UgJ0UnOiBjYXNlICdGJzogY2FzZSAnRyc6XG4gICAgICBmLnNpZ25lZGNvbnYgPSB0cnVlOyBmLnVwcGVyY2FzZSA9IHRydWU7XG4gICAgICBmLmNvbnYgPSBjLnRvTG93ZXJDYXNlICgpOyBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGY7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmluaXNoX2Zvcm1hdHRpbmdcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfZmluaXNoX2Zvcm1hdHRpbmcoZiwgcmF3YnVmZmVyKSB7XG4gIGlmIChmLnVwcGVyY2FzZSkgcmF3YnVmZmVyID0gcmF3YnVmZmVyLnRvVXBwZXJDYXNlKCk7XG4gIHZhciBsZW4gPSByYXdidWZmZXIubGVuZ3RoO1xuICAvKiBBZGp1c3QgbGVuIHRvIHJlZmxlY3QgYWRkaXRpb25hbCBjaGFycyAoc2lnbiwgZXRjKSAqL1xuICBpZiAoZi5zaWduZWRjb252ICYmIChmLnNpZ24gPCAwIHx8IGYuc2lnbnN0eWxlICE9ICctJykpIGxlbisrO1xuICBpZiAoZi5hbHRlcm5hdGUpIHtcbiAgICBpZiAoZi5iYXNlID09IDgpIGxlbiArPSAxO1xuICAgIGlmIChmLmJhc2UgPT0gMTYpIGxlbiArPSAyO1xuICB9XG4gIC8qIERvIHRoZSBmb3JtYXR0aW5nICovXG4gIHZhciBidWZmZXIgPSBcIlwiO1xuICBpZiAoZi5qdXN0aWZ5ID09ICcrJyAmJiBmLmZpbGxlciA9PSAnICcpXG4gICAgZm9yICh2YXIgaSA9IGxlbjsgaSA8IGYud2lkdGg7IGkrKykgYnVmZmVyICs9ICcgJztcbiAgaWYgKGYuc2lnbmVkY29udikge1xuICAgIGlmIChmLnNpZ24gPCAwKSBidWZmZXIgKz0gJy0nO1xuICAgIGVsc2UgaWYgKGYuc2lnbnN0eWxlICE9ICctJykgYnVmZmVyICs9IGYuc2lnbnN0eWxlO1xuICB9XG4gIGlmIChmLmFsdGVybmF0ZSAmJiBmLmJhc2UgPT0gOCkgYnVmZmVyICs9ICcwJztcbiAgaWYgKGYuYWx0ZXJuYXRlICYmIGYuYmFzZSA9PSAxNikgYnVmZmVyICs9IFwiMHhcIjtcbiAgaWYgKGYuanVzdGlmeSA9PSAnKycgJiYgZi5maWxsZXIgPT0gJzAnKVxuICAgIGZvciAodmFyIGkgPSBsZW47IGkgPCBmLndpZHRoOyBpKyspIGJ1ZmZlciArPSAnMCc7XG4gIGJ1ZmZlciArPSByYXdidWZmZXI7XG4gIGlmIChmLmp1c3RpZnkgPT0gJy0nKVxuICAgIGZvciAodmFyIGkgPSBsZW47IGkgPCBmLndpZHRoOyBpKyspIGJ1ZmZlciArPSAnICc7XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKGJ1ZmZlcik7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczoganNvb19mbG9vcl9sb2cyXG52YXIgbG9nMl9vayA9IE1hdGgubG9nMiAmJiBNYXRoLmxvZzIoMS4xMjM1NTgyMDkyODg5NDc0RSszMDcpID09IDEwMjBcbmZ1bmN0aW9uIGpzb29fZmxvb3JfbG9nMih4KSB7XG4gIGlmKGxvZzJfb2spIHJldHVybiBNYXRoLmZsb29yKE1hdGgubG9nMih4KSlcbiAgdmFyIGkgPSAwO1xuICBpZiAoeCA9PSAwKSByZXR1cm4gLUluZmluaXR5O1xuICBpZih4Pj0xKSB7d2hpbGUgKHg+PTIpIHt4Lz0yOyBpKyt9IH1cbiAgZWxzZSB7d2hpbGUgKHggPCAxKSB7eCo9MjsgaS0tfSB9O1xuICByZXR1cm4gaTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0IGNvbnN0XG4vL1JlcXVpcmVzOiBqc29vX2Zsb29yX2xvZzIsIGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpXG5mdW5jdGlvbiBjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQgKHgpIHtcbiAgaWYgKCFpc0Zpbml0ZSh4KSkge1xuICAgIGlmIChpc05hTih4KSlcbiAgICAgIHJldHVybiBjYW1sX2ludDY0X2NyZWF0ZV9sb19taV9oaSgxLCAwLCAweDdmZjApO1xuICAgIGlmICh4ID4gMClcbiAgICAgIHJldHVybiBjYW1sX2ludDY0X2NyZWF0ZV9sb19taV9oaSgwLCAwLCAweDdmZjApXG4gICAgZWxzZVxuICAgICAgcmV0dXJuIGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpKDAsIDAsIDB4ZmZmMClcbiAgfVxuICB2YXIgc2lnbiA9ICh4PT0wICYmIDEveCA9PSAtSW5maW5pdHkpPzB4ODAwMDooeD49MCk/MDoweDgwMDA7XG4gIGlmIChzaWduKSB4ID0gLXg7XG4gIC8vIEludDY0LmJpdHNfb2ZfZmxvYXQgMS4xMjM1NTgyMDkyODg5NDc0RSszMDcgPSAweDdmYjAwMDAwMDAwMDAwMDBMXG4gIC8vIHVzaW5nIE1hdGguTE9HMkUqTWF0aC5sb2coeCkgaW4gcGxhY2Ugb2YgTWF0aC5sb2cyIHJlc3VsdCBpbiBwcmVjaXNpb24gbG9zdFxuICB2YXIgZXhwID0ganNvb19mbG9vcl9sb2cyKHgpICsgMTAyMztcbiAgaWYgKGV4cCA8PSAwKSB7XG4gICAgZXhwID0gMDtcbiAgICB4IC89IE1hdGgucG93KDIsLTEwMjYpO1xuICB9IGVsc2Uge1xuICAgIHggLz0gTWF0aC5wb3coMixleHAtMTAyNyk7XG4gICAgaWYgKHggPCAxNikge1xuICAgICAgeCAqPSAyOyBleHAgLT0xOyB9XG4gICAgaWYgKGV4cCA9PSAwKSB7XG4gICAgICB4IC89IDI7IH1cbiAgfVxuICB2YXIgayA9IE1hdGgucG93KDIsMjQpO1xuICB2YXIgcjMgPSB4fDA7XG4gIHggPSAoeCAtIHIzKSAqIGs7XG4gIHZhciByMiA9IHh8MDtcbiAgeCA9ICh4IC0gcjIpICogaztcbiAgdmFyIHIxID0geHwwO1xuICByMyA9IChyMyAmMHhmKSB8IHNpZ24gfCBleHAgPDwgNDtcbiAgcmV0dXJuIGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpKHIxLCByMiwgcjMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXQgY29uc3Rcbi8vUmVxdWlyZXM6IGpzb29fZmxvb3JfbG9nMlxuZnVuY3Rpb24gY2FtbF9pbnQzMl9iaXRzX29mX2Zsb2F0ICh4KSB7XG4gIHZhciBmbG9hdDMyYSA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5GbG9hdDMyQXJyYXkoMSk7XG4gIGZsb2F0MzJhWzBdID0geDtcbiAgdmFyIGludDMyYSA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5JbnQzMkFycmF5KGZsb2F0MzJhLmJ1ZmZlcik7XG4gIHJldHVybiBpbnQzMmFbMF0gfCAwO1xufVxuXG4vL0ZQIGxpdGVyYWxzIGNhbiBiZSB3cml0dGVuIHVzaW5nIHRoZSBoZXhhZGVjaW1hbFxuLy9ub3RhdGlvbiAweDxtYW50aXNzYSBpbiBoZXg+cDxleHBvbmVudD4gZnJvbSBJU08gQzk5LlxuLy9odHRwczovL2dpdGh1Yi5jb20vZGFua29nYWkvanMtaGV4ZmxvYXQvYmxvYi9tYXN0ZXIvaGV4ZmxvYXQuanNcbi8vUHJvdmlkZXM6IGNhbWxfaGV4c3RyaW5nX29mX2Zsb2F0IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZywgY2FtbF9zdHJfcmVwZWF0XG5mdW5jdGlvbiBjYW1sX2hleHN0cmluZ19vZl9mbG9hdCAoeCwgcHJlYywgc3R5bGUpIHtcbiAgaWYgKCFpc0Zpbml0ZSh4KSkge1xuICAgIGlmIChpc05hTih4KSkgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKFwibmFuXCIpO1xuICAgIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyAoKHggPiAwKT9cImluZmluaXR5XCI6XCItaW5maW5pdHlcIik7XG4gIH1cbiAgdmFyIHNpZ24gPSAoeD09MCAmJiAxL3ggPT0gLUluZmluaXR5KT8xOih4Pj0wKT8wOjE7XG4gIGlmKHNpZ24pIHggPSAteDtcbiAgdmFyIGV4cCA9IDA7XG4gIGlmICh4ID09IDApIHsgfVxuICBlbHNlIGlmICh4IDwgMSkge1xuICAgIHdoaWxlICh4IDwgMSAmJiBleHAgPiAtMTAyMikgIHsgeCAqPSAyOyBleHAtLSB9XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKHggPj0gMikgeyB4IC89IDI7IGV4cCsrIH1cbiAgfVxuICB2YXIgZXhwX3NpZ24gPSBleHAgPCAwID8gJycgOiAnKyc7XG4gIHZhciBzaWduX3N0ciA9ICcnO1xuICBpZiAoc2lnbikgc2lnbl9zdHIgPSAnLSdcbiAgZWxzZSB7XG4gICAgc3dpdGNoKHN0eWxlKXtcbiAgICBjYXNlIDQzIC8qICcrJyAqLzogc2lnbl9zdHIgPSAnKyc7IGJyZWFrO1xuICAgIGNhc2UgMzIgLyogJyAnICovOiBzaWduX3N0ciA9ICcgJzsgYnJlYWs7XG4gICAgZGVmYXVsdDogYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmIChwcmVjID49IDAgJiYgcHJlYyA8IDEzKSB7XG4gICAgLyogSWYgYSBwcmVjaXNpb24gaXMgZ2l2ZW4sIGFuZCBpcyBzbWFsbCwgcm91bmQgbWFudGlzc2EgYWNjb3JkaW5nbHkgKi9cbiAgICB2YXIgY3N0ID0gTWF0aC5wb3coMixwcmVjICogNCk7XG4gICAgeCA9IE1hdGgucm91bmQoeCAqIGNzdCkgLyBjc3Q7XG4gIH1cbiAgdmFyIHhfc3RyID0geC50b1N0cmluZygxNik7XG4gIGlmKHByZWMgPj0gMCl7XG4gICAgdmFyIGlkeCA9IHhfc3RyLmluZGV4T2YoJy4nKTtcbiAgICBpZihpZHg8MCkge1xuICAgICAgeF9zdHIgKz0gJy4nICsgY2FtbF9zdHJfcmVwZWF0KHByZWMsICcwJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIHNpemUgPSBpZHgrMStwcmVjO1xuICAgICAgaWYoeF9zdHIubGVuZ3RoIDwgc2l6ZSlcbiAgICAgICAgeF9zdHIgKz0gY2FtbF9zdHJfcmVwZWF0KHNpemUgLSB4X3N0ci5sZW5ndGgsICcwJyk7XG4gICAgICBlbHNlXG4gICAgICAgIHhfc3RyID0geF9zdHIuc3Vic3RyKDAsc2l6ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyAoc2lnbl9zdHIgKyAnMHgnICsgeF9zdHIgKyAncCcgKyBleHBfc2lnbiArIGV4cC50b1N0cmluZygxMCkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cyAoeCkge1xuICB2YXIgbG8gPSB4LmxvO1xuICB2YXIgbWkgPSB4Lm1pO1xuICB2YXIgaGkgPSB4LmhpO1xuICB2YXIgZXhwID0gKGhpICYgMHg3ZmZmKSA+PiA0O1xuICBpZiAoZXhwID09IDIwNDcpIHtcbiAgICBpZiAoKGxvfG1pfChoaSYweGYpKSA9PSAwKVxuICAgICAgcmV0dXJuIChoaSAmIDB4ODAwMCk/KC1JbmZpbml0eSk6SW5maW5pdHk7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIE5hTjtcbiAgfVxuICB2YXIgayA9IE1hdGgucG93KDIsLTI0KTtcbiAgdmFyIHJlcyA9IChsbyprK21pKSprKyhoaSYweGYpO1xuICBpZiAoZXhwID4gMCkge1xuICAgIHJlcyArPSAxNjtcbiAgICByZXMgKj0gTWF0aC5wb3coMixleHAtMTAyNyk7XG4gIH0gZWxzZVxuICAgIHJlcyAqPSBNYXRoLnBvdygyLC0xMDI2KTtcbiAgaWYgKGhpICYgMHg4MDAwKSByZXMgPSAtIHJlcztcbiAgcmV0dXJuIHJlcztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9uZXh0YWZ0ZXJfZmxvYXQgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cywgY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0LCBjYW1sX2ludDY0X2FkZCwgY2FtbF9pbnQ2NF9zdWIsY2FtbF9pbnQ2NF9vZl9pbnQzMlxuZnVuY3Rpb24gY2FtbF9uZXh0YWZ0ZXJfZmxvYXQgKHgseSkge1xuICBpZihpc05hTih4KSB8fCBpc05hTih5KSkgcmV0dXJuIE5hTjtcbiAgaWYoeD09eSkgcmV0dXJuIHk7XG4gIGlmKHg9PTApe1xuICAgIGlmKHkgPCAwKVxuICAgICAgcmV0dXJuIC1NYXRoLnBvdygyLCAtMTA3NClcbiAgICBlbHNlXG4gICAgICByZXR1cm4gTWF0aC5wb3coMiwgLTEwNzQpXG4gIH1cbiAgdmFyIGJpdHMgPSBjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQoeCk7XG4gIHZhciBvbmUgPSBjYW1sX2ludDY0X29mX2ludDMyKDEpO1xuICBpZiAoKHg8eSkgPT0gKHg+MCkpXG4gICAgYml0cyA9IGNhbWxfaW50NjRfYWRkKGJpdHMsIG9uZSlcbiAgZWxzZVxuICAgIGJpdHMgPSBjYW1sX2ludDY0X3N1YihiaXRzLCBvbmUpXG4gIHJldHVybiBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMoYml0cyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdHJ1bmNfZmxvYXRcbmZ1bmN0aW9uIGNhbWxfdHJ1bmNfZmxvYXQoeCl7XG4gIHJldHVybiBNYXRoLnRydW5jKHgpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDMyX2Zsb2F0X29mX2JpdHMgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50MzJfZmxvYXRfb2ZfYml0cyAoeCkge1xuICB2YXIgaW50MzJhID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0LkludDMyQXJyYXkoMSk7XG4gIGludDMyYVswXSA9IHg7XG4gIHZhciBmbG9hdDMyYSA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5GbG9hdDMyQXJyYXkoaW50MzJhLmJ1ZmZlcik7XG4gIHJldHVybiBmbG9hdDMyYVswXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jbGFzc2lmeV9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9jbGFzc2lmeV9mbG9hdCAoeCkge1xuICBpZiAoaXNGaW5pdGUgKHgpKSB7XG4gICAgaWYgKE1hdGguYWJzKHgpID49IDIuMjI1MDczODU4NTA3MjAxNGUtMzA4KSByZXR1cm4gMDtcbiAgICBpZiAoeCAhPSAwKSByZXR1cm4gMTtcbiAgICByZXR1cm4gMjtcbiAgfVxuICByZXR1cm4gaXNOYU4oeCk/NDozO1xufVxuLy9Qcm92aWRlczogY2FtbF9tb2RmX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX21vZGZfZmxvYXQgKHgpIHtcbiAgaWYgKGlzRmluaXRlICh4KSkge1xuICAgIHZhciBuZWcgPSAoMS94KSA8IDA7XG4gICAgeCA9IE1hdGguYWJzKHgpO1xuICAgIHZhciBpID0gTWF0aC5mbG9vciAoeCk7XG4gICAgdmFyIGYgPSB4IC0gaTtcbiAgICBpZiAobmVnKSB7IGkgPSAtaTsgZiA9IC1mOyB9XG4gICAgcmV0dXJuIFswLCBmLCBpXTtcbiAgfVxuICBpZiAoaXNOYU4gKHgpKSByZXR1cm4gWzAsIE5hTiwgTmFOXTtcbiAgcmV0dXJuIFswLCAxL3gsIHhdO1xufVxuLy9Qcm92aWRlczogY2FtbF9sZGV4cF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9sZGV4cF9mbG9hdCAoeCxleHApIHtcbiAgZXhwIHw9IDA7XG4gIGlmIChleHAgPiAxMDIzKSB7XG4gICAgZXhwIC09IDEwMjM7XG4gICAgeCAqPSBNYXRoLnBvdygyLCAxMDIzKTtcbiAgICBpZiAoZXhwID4gMTAyMykgeyAgLy8gaW4gY2FzZSB4IGlzIHN1Ym5vcm1hbFxuICAgICAgZXhwIC09IDEwMjM7XG4gICAgICB4ICo9IE1hdGgucG93KDIsIDEwMjMpO1xuICAgIH1cbiAgfVxuICBpZiAoZXhwIDwgLTEwMjMpIHtcbiAgICBleHAgKz0gMTAyMztcbiAgICB4ICo9IE1hdGgucG93KDIsIC0xMDIzKTtcbiAgfVxuICB4ICo9IE1hdGgucG93KDIsIGV4cCk7XG4gIHJldHVybiB4O1xufVxuLy9Qcm92aWRlczogY2FtbF9mcmV4cF9mbG9hdCBjb25zdFxuLy9SZXF1aXJlczoganNvb19mbG9vcl9sb2cyXG5mdW5jdGlvbiBjYW1sX2ZyZXhwX2Zsb2F0ICh4KSB7XG4gIGlmICgoeCA9PSAwKSB8fCAhaXNGaW5pdGUoeCkpIHJldHVybiBbMCwgeCwgMF07XG4gIHZhciBuZWcgPSB4IDwgMDtcbiAgaWYgKG5lZykgeCA9IC0geDtcbiAgdmFyIGV4cCA9IE1hdGgubWF4KC0xMDIzLCBqc29vX2Zsb29yX2xvZzIoeCkgKyAxKTtcbiAgeCAqPSBNYXRoLnBvdygyLC1leHApO1xuICB3aGlsZSAoeCA8IDAuNSkge1xuICAgIHggKj0gMjtcbiAgICBleHAtLTtcbiAgfVxuICB3aGlsZSAoeCA+PSAxKSB7XG4gICAgeCAqPSAwLjU7XG4gICAgZXhwKys7XG4gIH1cbiAgaWYgKG5lZykgeCA9IC0geDtcbiAgcmV0dXJuIFswLCB4LCBleHBdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2Zsb2F0X2NvbXBhcmUgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZmxvYXRfY29tcGFyZSAoeCwgeSkge1xuICBpZiAoeCA9PT0geSkgcmV0dXJuIDA7XG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xO1xuICBpZiAoeCA+IHkpIHJldHVybiAxO1xuICBpZiAoeCA9PT0geCkgcmV0dXJuIDE7XG4gIGlmICh5ID09PSB5KSByZXR1cm4gLTE7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvcHlzaWduX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2NvcHlzaWduX2Zsb2F0ICh4LCB5KSB7XG4gIGlmICh5ID09IDApIHkgPSAxIC8geTtcbiAgeCA9IE1hdGguYWJzKHgpO1xuICByZXR1cm4gKHkgPCAwKT8oLXgpOng7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc2lnbmJpdF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9zaWduYml0X2Zsb2F0KHgpIHtcbiAgaWYgKHggPT0gMCkgeCA9IDEgLyB4O1xuICByZXR1cm4gKHggPCAwKT8xOjA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXhwbTFfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZXhwbTFfZmxvYXQgKHgpIHtcbiAgdmFyIHkgPSBNYXRoLmV4cCh4KSwgeiA9IHkgLSAxO1xuICByZXR1cm4gKE1hdGguYWJzKHgpPjE/ejooej09MD94Ongqei9NYXRoLmxvZyh5KSkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2xvZzFwX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2xvZzFwX2Zsb2F0ICh4KSB7XG4gIHZhciB5ID0gMSArIHgsIHogPSB5IC0gMTtcbiAgcmV0dXJuICh6PT0wP3g6eCpNYXRoLmxvZyh5KS96KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9oeXBvdF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9oeXBvdF9mbG9hdCAoeCwgeSkge1xuICB2YXIgeCA9IE1hdGguYWJzKHgpLCB5ID0gTWF0aC5hYnMoeSk7XG4gIHZhciBhID0gTWF0aC5tYXgoeCwgeSksIGIgPSBNYXRoLm1pbih4LHkpIC8gKGE/YToxKTtcbiAgcmV0dXJuIChhICogTWF0aC5zcXJ0KDEgKyBiKmIpKTtcbn1cblxuLy8gRklYOiB0aGVzZSBmaXZlIGZ1bmN0aW9ucyBvbmx5IGdpdmUgYXBwcm94aW1hdGUgcmVzdWx0cy5cbi8vUHJvdmlkZXM6IGNhbWxfbG9nMTBfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfbG9nMTBfZmxvYXQgKHgpIHsgcmV0dXJuIE1hdGguTE9HMTBFICogTWF0aC5sb2coeCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfY29zaF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9jb3NoX2Zsb2F0ICh4KSB7IHJldHVybiAoTWF0aC5leHAoeCkgKyBNYXRoLmV4cCgteCkpIC8gMjsgfVxuLy9Qcm92aWRlczogY2FtbF9zaW5oX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX3NpbmhfZmxvYXQgKHgpIHsgcmV0dXJuIChNYXRoLmV4cCh4KSAtIE1hdGguZXhwKC14KSkgLyAyOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX3RhbmhfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfdGFuaF9mbG9hdCAoeCkge1xuICB2YXIgeSA9IE1hdGguZXhwKHgpLCB6ID0gTWF0aC5leHAoLXgpO1xuICByZXR1cm4gKHkgLSB6KSAvICh5ICsgeik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcm91bmRfZmxvYXRcbmZ1bmN0aW9uIGNhbWxfcm91bmRfZmxvYXQgKHgpIHsgcmV0dXJuIE1hdGgucm91bmQoeCk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9mb3JtYXRfZmxvYXQgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfcGFyc2VfZm9ybWF0LCBjYW1sX2ZpbmlzaF9mb3JtYXR0aW5nXG5mdW5jdGlvbiBjYW1sX2Zvcm1hdF9mbG9hdCAoZm10LCB4KSB7XG4gIGZ1bmN0aW9uIHRvRml4ZWQoeCxkcCkge1xuICAgIGlmIChNYXRoLmFicyh4KSA8IDEuMCkge1xuICAgICAgcmV0dXJuIHgudG9GaXhlZChkcCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBlID0gcGFyc2VJbnQoeC50b1N0cmluZygpLnNwbGl0KCcrJylbMV0pO1xuICAgICAgaWYgKGUgPiAyMCkge1xuICAgICAgICBlIC09IDIwO1xuICAgICAgICB4IC89IE1hdGgucG93KDEwLGUpO1xuICAgICAgICB4ICs9IChuZXcgQXJyYXkoZSsxKSkuam9pbignMCcpO1xuICAgICAgICBpZihkcCA+IDApIHtcbiAgICAgICAgICB4ID0geCArICcuJyArIChuZXcgQXJyYXkoZHArMSkpLmpvaW4oJzAnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geDtcbiAgICAgIH1cbiAgICAgIGVsc2UgcmV0dXJuIHgudG9GaXhlZChkcClcbiAgICB9XG4gIH1cbiAgdmFyIHMsIGYgPSBjYW1sX3BhcnNlX2Zvcm1hdChmbXQpO1xuICB2YXIgcHJlYyA9IChmLnByZWMgPCAwKT82OmYucHJlYztcbiAgaWYgKHggPCAwIHx8ICh4ID09IDAgJiYgMS94ID09IC1JbmZpbml0eSkpIHsgZi5zaWduID0gLTE7IHggPSAteDsgfVxuICBpZiAoaXNOYU4oeCkpIHsgcyA9IFwibmFuXCI7IGYuZmlsbGVyID0gJyAnOyB9XG4gIGVsc2UgaWYgKCFpc0Zpbml0ZSh4KSkgeyBzID0gXCJpbmZcIjsgZi5maWxsZXIgPSAnICc7IH1cbiAgZWxzZVxuICAgIHN3aXRjaCAoZi5jb252KSB7XG4gICAgY2FzZSAnZSc6XG4gICAgICB2YXIgcyA9IHgudG9FeHBvbmVudGlhbChwcmVjKTtcbiAgICAgIC8vIGV4cG9uZW50IHNob3VsZCBiZSBhdCBsZWFzdCB0d28gZGlnaXRzXG4gICAgICB2YXIgaSA9IHMubGVuZ3RoO1xuICAgICAgaWYgKHMuY2hhckF0KGkgLSAzKSA9PSAnZScpXG4gICAgICAgIHMgPSBzLnNsaWNlICgwLCBpIC0gMSkgKyAnMCcgKyBzLnNsaWNlIChpIC0gMSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdmJzpcbiAgICAgIHMgPSB0b0ZpeGVkKHgsIHByZWMpOyBicmVhaztcbiAgICBjYXNlICdnJzpcbiAgICAgIHByZWMgPSBwcmVjP3ByZWM6MTtcbiAgICAgIHMgPSB4LnRvRXhwb25lbnRpYWwocHJlYyAtIDEpO1xuICAgICAgdmFyIGogPSBzLmluZGV4T2YoJ2UnKTtcbiAgICAgIHZhciBleHAgPSArcy5zbGljZShqICsgMSk7XG4gICAgICBpZiAoZXhwIDwgLTQgfHwgeCA+PSAxZTIxIHx8IHgudG9GaXhlZCgwKS5sZW5ndGggPiBwcmVjKSB7XG4gICAgICAgIC8vIHJlbW92ZSB0cmFpbGluZyB6ZXJvZXNcbiAgICAgICAgdmFyIGkgPSBqIC0gMTsgd2hpbGUgKHMuY2hhckF0KGkpID09ICcwJykgaS0tO1xuICAgICAgICBpZiAocy5jaGFyQXQoaSkgPT0gJy4nKSBpLS07XG4gICAgICAgIHMgPSBzLnNsaWNlKDAsIGkgKyAxKSArIHMuc2xpY2Uoaik7XG4gICAgICAgIGkgPSBzLmxlbmd0aDtcbiAgICAgICAgaWYgKHMuY2hhckF0KGkgLSAzKSA9PSAnZScpXG4gICAgICAgICAgcyA9IHMuc2xpY2UgKDAsIGkgLSAxKSArICcwJyArIHMuc2xpY2UgKGkgLSAxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcCA9IHByZWM7XG4gICAgICAgIGlmIChleHAgPCAwKSB7IHAgLT0gZXhwICsgMTsgcyA9IHgudG9GaXhlZChwKTsgfVxuICAgICAgICBlbHNlIHdoaWxlIChzID0geC50b0ZpeGVkKHApLCBzLmxlbmd0aCA+IHByZWMgKyAxKSBwLS07XG4gICAgICAgIGlmIChwKSB7XG4gICAgICAgICAgLy8gcmVtb3ZlIHRyYWlsaW5nIHplcm9lc1xuICAgICAgICAgIHZhciBpID0gcy5sZW5ndGggLSAxOyB3aGlsZSAocy5jaGFyQXQoaSkgPT0gJzAnKSBpLS07XG4gICAgICAgICAgaWYgKHMuY2hhckF0KGkpID09ICcuJykgaS0tO1xuICAgICAgICAgIHMgPSBzLnNsaWNlKDAsIGkgKyAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICByZXR1cm4gY2FtbF9maW5pc2hfZm9ybWF0dGluZyhmLCBzKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9mbG9hdF9vZl9zdHJpbmcgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aCwgY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9mbG9hdF9vZl9zdHJpbmcocykge1xuICB2YXIgcmVzO1xuICBzID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhzKVxuICByZXMgPSArcztcbiAgaWYgKChzLmxlbmd0aCA+IDApICYmIChyZXMgPT09IHJlcykpIHJldHVybiByZXM7XG4gIHMgPSBzLnJlcGxhY2UoL18vZyxcIlwiKTtcbiAgcmVzID0gK3M7XG4gIGlmICgoKHMubGVuZ3RoID4gMCkgJiYgKHJlcyA9PT0gcmVzKSkgfHwgL15bKy1dP25hbiQvaS50ZXN0KHMpKSByZXR1cm4gcmVzO1xuICB2YXIgbSA9IC9eICooWystXT8pMHgoWzAtOWEtZl0rKVxcLj8oWzAtOWEtZl0qKXAoWystXT9bMC05XSspL2kuZXhlYyhzKTtcbiAgLy8gICAgICAgICAgMSAgICAgICAgMiAgICAgICAgICAgICAzICAgICAgICAgICA0XG4gIGlmKG0pe1xuICAgIHZhciBtMyA9IG1bM10ucmVwbGFjZSgvMCskLywnJyk7XG4gICAgdmFyIG1hbnRpc3NhID0gcGFyc2VJbnQobVsxXSArIG1bMl0gKyBtMywgMTYpO1xuICAgIHZhciBleHBvbmVudCA9IChtWzRdfDApIC0gNCptMy5sZW5ndGg7XG4gICAgcmVzID0gbWFudGlzc2EgKiBNYXRoLnBvdygyLCBleHBvbmVudCk7XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICBpZigvXlxcKz9pbmYoaW5pdHkpPyQvaS50ZXN0KHMpKSByZXR1cm4gSW5maW5pdHk7XG4gIGlmKC9eLWluZihpbml0eSk/JC9pLnRlc3QocykpIHJldHVybiAtSW5maW5pdHk7XG4gIGNhbWxfZmFpbHdpdGgoXCJmbG9hdF9vZl9zdHJpbmdcIik7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTQgSsOpcsO0bWUgVm91aWxsb24sIEh1Z28gSGV1emFyZFxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vLy8vLy8vLy8vLy8vIER1bW15IGZpbGVzeXN0ZW1cblxuLy9Qcm92aWRlczogY2FtbF9jdXJyZW50X2RpclxuaWYoam9vX2dsb2JhbF9vYmplY3QucHJvY2VzcyAmJiBqb29fZ2xvYmFsX29iamVjdC5wcm9jZXNzLmN3ZClcbiAgdmFyIGNhbWxfY3VycmVudF9kaXIgPSBqb29fZ2xvYmFsX29iamVjdC5wcm9jZXNzLmN3ZCgpLnJlcGxhY2UoL1xcXFwvZywnLycpO1xuZWxzZVxuICB2YXIgY2FtbF9jdXJyZW50X2RpciA9ICBcIi9zdGF0aWNcIjtcbmlmKGNhbWxfY3VycmVudF9kaXIuc2xpY2UoLTEpICE9PSBcIi9cIikgY2FtbF9jdXJyZW50X2RpciArPSBcIi9cIlxuXG4vL1Byb3ZpZGVzOiBjYW1sX3Jvb3Rcbi8vUmVxdWlyZXM6IGNhbWxfY3VycmVudF9kaXJcbnZhciBjYW1sX3Jvb3QgPSBjYW1sX2N1cnJlbnRfZGlyLm1hdGNoKC9bXlxcL10qXFwvLylbMF07XG5cblxuLy9Qcm92aWRlczogTWxGaWxlXG5mdW5jdGlvbiBNbEZpbGUoKXsgIH1cblxuLy9Qcm92aWRlczogY2FtbF9tYWtlX3BhdGhcbi8vUmVxdWlyZXM6IGNhbWxfY3VycmVudF9kaXJcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX21ha2VfcGF0aCAobmFtZSkge1xuICBuYW1lPWNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKG5hbWUpO1xuICBpZihuYW1lLmNoYXJDb2RlQXQoMCkgIT0gNDcpXG4gICAgbmFtZSA9IGNhbWxfY3VycmVudF9kaXIgKyBuYW1lO1xuICB2YXIgY29tcCA9IG5hbWUuc3BsaXQoXCIvXCIpO1xuICB2YXIgbmNvbXAgPSBbXVxuICBmb3IodmFyIGkgPSAwOyBpPGNvbXAubGVuZ3RoOyBpKyspe1xuICAgIHN3aXRjaChjb21wW2ldKXtcbiAgICBjYXNlIFwiLi5cIjogaWYobmNvbXAubGVuZ3RoPjEpIG5jb21wLnBvcCgpOyBicmVhaztcbiAgICBjYXNlIFwiLlwiOiBicmVhaztcbiAgICBjYXNlIFwiXCI6IGlmKG5jb21wLmxlbmd0aCA9PSAwKSBuY29tcC5wdXNoKFwiXCIpOyBicmVhaztcbiAgICBkZWZhdWx0OiBuY29tcC5wdXNoKGNvbXBbaV0pO2JyZWFrXG4gICAgfVxuICB9XG4gIG5jb21wLm9yaWcgPSBuYW1lO1xuICByZXR1cm4gbmNvbXA7XG59XG5cbi8vUHJvdmlkZXM6anNvb19tb3VudF9wb2ludFxuLy9SZXF1aXJlczogTWxGYWtlRGV2aWNlLCBNbE5vZGVEZXZpY2UsIGNhbWxfcm9vdCwgZnNfbm9kZV9zdXBwb3J0ZWRcbnZhciBqc29vX21vdW50X3BvaW50ID0gW11cbmlmIChmc19ub2RlX3N1cHBvcnRlZCgpKSB7XG4gIGpzb29fbW91bnRfcG9pbnQucHVzaCh7cGF0aDpjYW1sX3Jvb3QsZGV2aWNlOm5ldyBNbE5vZGVEZXZpY2UoY2FtbF9yb290KX0pO1xufSBlbHNlIHtcbiAganNvb19tb3VudF9wb2ludC5wdXNoKHtwYXRoOmNhbWxfcm9vdCxkZXZpY2U6bmV3IE1sRmFrZURldmljZShjYW1sX3Jvb3QpfSk7XG59XG5qc29vX21vdW50X3BvaW50LnB1c2goe3BhdGg6Y2FtbF9yb290K1wic3RhdGljL1wiLCBkZXZpY2U6bmV3IE1sRmFrZURldmljZShjYW1sX3Jvb3QrXCJzdGF0aWMvXCIpfSk7XG5cbi8vUHJvdmlkZXM6Y2FtbF9saXN0X21vdW50X3BvaW50XG4vL1JlcXVpcmVzOiBqc29vX21vdW50X3BvaW50LCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX2xpc3RfbW91bnRfcG9pbnQoKXtcbiAgdmFyIHByZXYgPSAwXG4gIGZvcih2YXIgaSA9IDA7IGkgPCBqc29vX21vdW50X3BvaW50Lmxlbmd0aDsgaSsrKXtcbiAgICB2YXIgb2xkID0gcHJldjtcbiAgICBwcmV2ID0gWzAsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoanNvb19tb3VudF9wb2ludFtpXS5wYXRoKSwgb2xkXVxuICB9XG4gIHJldHVybiBwcmV2O1xufVxuXG4vL1Byb3ZpZGVzOiByZXNvbHZlX2ZzX2RldmljZVxuLy9SZXF1aXJlczogY2FtbF9tYWtlX3BhdGgsIGpzb29fbW91bnRfcG9pbnRcbmZ1bmN0aW9uIHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpe1xuICB2YXIgcGF0aCA9IGNhbWxfbWFrZV9wYXRoKG5hbWUpO1xuICB2YXIgbmFtZSA9IHBhdGguam9pbihcIi9cIik7XG4gIHZhciBuYW1lX3NsYXNoID0gbmFtZSArIFwiL1wiO1xuICB2YXIgcmVzO1xuICBmb3IodmFyIGkgPSAwOyBpIDwganNvb19tb3VudF9wb2ludC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBtID0ganNvb19tb3VudF9wb2ludFtpXTtcbiAgICBpZihuYW1lX3NsYXNoLnNlYXJjaChtLnBhdGgpID09IDBcbiAgICAgICAmJiAoIXJlcyB8fCByZXMucGF0aC5sZW5ndGggPCBtLnBhdGgubGVuZ3RoKSlcbiAgICAgIHJlcyA9IHtwYXRoOm0ucGF0aCxkZXZpY2U6bS5kZXZpY2UscmVzdDpuYW1lLnN1YnN0cmluZyhtLnBhdGgubGVuZ3RoLG5hbWUubGVuZ3RoKX07XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tb3VudF9hdXRvbG9hZFxuLy9SZXF1aXJlczogTWxGYWtlRGV2aWNlLCBjYW1sX21ha2VfcGF0aCwganNvb19tb3VudF9wb2ludFxuZnVuY3Rpb24gY2FtbF9tb3VudF9hdXRvbG9hZChuYW1lLGYpe1xuICB2YXIgcGF0aCA9IGNhbWxfbWFrZV9wYXRoKG5hbWUpO1xuICB2YXIgbmFtZSA9IHBhdGguam9pbihcIi9cIikgKyBcIi9cIjtcbiAganNvb19tb3VudF9wb2ludC5wdXNoKHtwYXRoOm5hbWUsZGV2aWNlOm5ldyBNbEZha2VEZXZpY2UobmFtZSxmKX0pXG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VubW91bnRcbi8vUmVxdWlyZXM6IGpzb29fbW91bnRfcG9pbnQsIGNhbWxfbWFrZV9wYXRoXG5mdW5jdGlvbiBjYW1sX3VubW91bnQobmFtZSl7XG4gIHZhciBwYXRoID0gY2FtbF9tYWtlX3BhdGgobmFtZSk7XG4gIHZhciBuYW1lID0gcGF0aC5qb2luKFwiL1wiKSArIFwiL1wiO1xuICB2YXIgaWR4ID0gLTE7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBqc29vX21vdW50X3BvaW50Lmxlbmd0aDsgaSsrKVxuICAgIGlmKGpzb29fbW91bnRfcG9pbnRbaV0ucGF0aCA9PSBuYW1lKSBpZHggPSBpO1xuICBpZihpZHggPiAtMSkganNvb19tb3VudF9wb2ludC5zcGxpY2UoaWR4LDEpO1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19nZXRjd2Rcbi8vUmVxdWlyZXM6IGNhbWxfY3VycmVudF9kaXIsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfc3lzX2dldGN3ZCgpIHtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoY2FtbF9jdXJyZW50X2Rpcik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NoZGlyXG4vL1JlcXVpcmVzOiBjYW1sX2N1cnJlbnRfZGlyLCBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZSwgcmVzb2x2ZV9mc19kZXZpY2VcbmZ1bmN0aW9uIGNhbWxfc3lzX2NoZGlyKGRpcikge1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKGRpcik7XG4gIGlmKHJvb3QuZGV2aWNlLmV4aXN0cyhyb290LnJlc3QpKSB7XG4gICAgaWYocm9vdC5yZXN0KSBjYW1sX2N1cnJlbnRfZGlyID0gcm9vdC5wYXRoICsgcm9vdC5yZXN0ICsgXCIvXCI7XG4gICAgZWxzZSBjYW1sX2N1cnJlbnRfZGlyID0gcm9vdC5wYXRoO1xuICAgIHJldHVybiAwO1xuICB9XG4gIGVsc2Uge1xuICAgIGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlKGRpcik7XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGVcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfc3lzX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZShuYW1lKXtcbiAgbmFtZSA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcobmFtZSk7XG4gIGNhbWxfcmFpc2Vfc3lzX2Vycm9yIChuYW1lICsgXCI6IE5vIHN1Y2ggZmlsZSBvciBkaXJlY3RvcnlcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2Vfbm90X2FfZGlyXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3N5c19lcnJvclxuLy9SZXF1aXJlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9yYWlzZV9ub3RfYV9kaXIobmFtZSl7XG4gIG5hbWUgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKG5hbWUpO1xuICBjYW1sX3JhaXNlX3N5c19lcnJvciAobmFtZSArIFwiOiBOb3QgYSBkaXJlY3RvcnlcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2ZpbGVfZXhpc3RzXG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZVxuZnVuY3Rpb24gY2FtbF9zeXNfZmlsZV9leGlzdHMgKG5hbWUpIHtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgcmV0dXJuIHJvb3QuZGV2aWNlLmV4aXN0cyhyb290LnJlc3QpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19yZWFkX2RpcmVjdG9yeVxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9ub3RfYV9kaXIsIHJlc29sdmVfZnNfZGV2aWNlXG5mdW5jdGlvbiBjYW1sX3N5c19yZWFkX2RpcmVjdG9yeShuYW1lKXtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgdmFyIGEgPSByb290LmRldmljZS5yZWFkZGlyKHJvb3QucmVzdCk7XG4gIHZhciBsID0gbmV3IEFycmF5KGEubGVuZ3RoICsgMSk7XG4gIGxbMF0gPSAwO1xuICBmb3IodmFyIGk9MDtpPGEubGVuZ3RoO2krKylcbiAgICBsW2krMV0gPSBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKGFbaV0pO1xuICByZXR1cm4gbDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfcmVtb3ZlXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZSwgcmVzb2x2ZV9mc19kZXZpY2VcbmZ1bmN0aW9uIGNhbWxfc3lzX3JlbW92ZShuYW1lKXtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgdmFyIG9rID0gcm9vdC5kZXZpY2UudW5saW5rKHJvb3QucmVzdCk7XG4gIGlmKG9rID09IDApIGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlKG5hbWUpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfaXNfZGlyZWN0b3J5XG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZVxuZnVuY3Rpb24gY2FtbF9zeXNfaXNfZGlyZWN0b3J5KG5hbWUpe1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICB2YXIgYSA9IHJvb3QuZGV2aWNlLmlzX2Rpcihyb290LnJlc3QpO1xuICByZXR1cm4gYT8xOjA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX3JlbmFtZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aCwgcmVzb2x2ZV9mc19kZXZpY2VcbmZ1bmN0aW9uIGNhbWxfc3lzX3JlbmFtZShvLG4pe1xuICB2YXIgb19yb290ID0gcmVzb2x2ZV9mc19kZXZpY2Uobyk7XG4gIHZhciBuX3Jvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuKTtcbiAgaWYob19yb290LmRldmljZSAhPSBuX3Jvb3QuZGV2aWNlKVxuICAgIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3N5c19yZW5hbWU6IGNhbm5vdCBtb3ZlIGZpbGUgYmV0d2VlbiB0d28gZmlsZXN5c3RlbVwiKTtcbiAgaWYoIW9fcm9vdC5kZXZpY2UucmVuYW1lKVxuICAgIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3N5c19yZW5hbWU6IG5vIGltcGxlbWVudGVkXCIpO1xuICBvX3Jvb3QuZGV2aWNlLnJlbmFtZShvX3Jvb3QucmVzdCwgbl9yb290LnJlc3QpO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfbWFwX2ZpbGVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfYmFfbWFwX2ZpbGUodmZkLCBraW5kLCBsYXlvdXQsIHNoYXJlZCwgZGltcywgcG9zKSB7XG4gIC8vIHZhciBkYXRhID0gY2FtbF9nbG9iYWxfZGF0YS5mZHNbdmZkXTtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfYmFfbWFwX2ZpbGUgbm90IGltcGxlbWVudGVkXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX21hcF9maWxlX2J5dGVjb2RlXG4vL1JlcXVpcmVzOiBjYW1sX2JhX21hcF9maWxlXG5mdW5jdGlvbiBjYW1sX2JhX21hcF9maWxlX2J5dGVjb2RlKGFyZ3YsYXJnbil7XG4gIHJldHVybiBjYW1sX2JhX21hcF9maWxlKGFyZ3ZbMF0sYXJndlsxXSxhcmd2WzJdLGFyZ3ZbM10sYXJndls0XSxhcmd2WzVdKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jcmVhdGVfZmlsZV9leHRlcm5cbmZ1bmN0aW9uIGNhbWxfY3JlYXRlX2ZpbGVfZXh0ZXJuKG5hbWUsY29udGVudCl7XG4gIGlmKGpvb19nbG9iYWxfb2JqZWN0LmNhbWxfY3JlYXRlX2ZpbGUpXG4gICAgam9vX2dsb2JhbF9vYmplY3QuY2FtbF9jcmVhdGVfZmlsZShuYW1lLGNvbnRlbnQpO1xuICBlbHNlIHtcbiAgICBpZigham9vX2dsb2JhbF9vYmplY3QuY2FtbF9mc190bXApIGpvb19nbG9iYWxfb2JqZWN0LmNhbWxfZnNfdG1wID0gW107XG4gICAgam9vX2dsb2JhbF9vYmplY3QuY2FtbF9mc190bXAucHVzaCh7bmFtZTpuYW1lLGNvbnRlbnQ6Y29udGVudH0pO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ZzX2luaXRcbi8vUmVxdWlyZXM6IGNhbWxfY3JlYXRlX2ZpbGVcbmZ1bmN0aW9uIGNhbWxfZnNfaW5pdCAoKXtcbiAgdmFyIHRtcD1qb29fZ2xvYmFsX29iamVjdC5jYW1sX2ZzX3RtcFxuICBpZih0bXApe1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0bXAubGVuZ3RoOyBpKyspe1xuICAgICAgY2FtbF9jcmVhdGVfZmlsZSh0bXBbaV0ubmFtZSx0bXBbaV0uY29udGVudCk7XG4gICAgfVxuICB9XG4gIGpvb19nbG9iYWxfb2JqZWN0LmNhbWxfY3JlYXRlX2ZpbGUgPSBjYW1sX2NyZWF0ZV9maWxlO1xuICBqb29fZ2xvYmFsX29iamVjdC5jYW1sX2ZzX3RtcCA9IFtdO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jcmVhdGVfZmlsZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aCwgcmVzb2x2ZV9mc19kZXZpY2UsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfY3JlYXRlX2ZpbGUobmFtZSxjb250ZW50KSB7XG4gIHZhciBuYW1lID0gKHR5cGVvZiBuYW1lID09IFwic3RyaW5nXCIpP2NhbWxfc3RyaW5nX29mX2pzYnl0ZXMobmFtZSk6bmFtZTtcbiAgdmFyIGNvbnRlbnQgPSAodHlwZW9mIGNvbnRlbnQgPT0gXCJzdHJpbmdcIik/Y2FtbF9zdHJpbmdfb2ZfanNieXRlcyhjb250ZW50KTpjb250ZW50O1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICBpZighIHJvb3QuZGV2aWNlLnJlZ2lzdGVyKSBjYW1sX2ZhaWx3aXRoKFwiY2Fubm90IHJlZ2lzdGVyIGZpbGVcIik7XG4gIHJvb3QuZGV2aWNlLnJlZ2lzdGVyKHJvb3QucmVzdCxjb250ZW50KTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmVhZF9maWxlX2NvbnRlbnRcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlLCBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZSwgY2FtbF9jcmVhdGVfYnl0ZXMsIGNhbWxfc3RyaW5nX29mX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX3JlYWRfZmlsZV9jb250ZW50IChuYW1lKSB7XG4gIHZhciBuYW1lID0gKHR5cGVvZiBuYW1lID09IFwic3RyaW5nXCIpP2NhbWxfc3RyaW5nX29mX2pzYnl0ZXMobmFtZSk6bmFtZTtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgaWYocm9vdC5kZXZpY2UuZXhpc3RzKHJvb3QucmVzdCkpIHtcbiAgICB2YXIgZmlsZSA9IHJvb3QuZGV2aWNlLm9wZW4ocm9vdC5yZXN0LHtyZG9ubHk6MX0pO1xuICAgIHZhciBsZW4gID0gZmlsZS5sZW5ndGgoKTtcbiAgICB2YXIgYnVmICA9IGNhbWxfY3JlYXRlX2J5dGVzKGxlbik7XG4gICAgZmlsZS5yZWFkKDAsYnVmLDAsbGVuKTtcbiAgICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfYnl0ZXMoYnVmKVxuICB9XG4gIGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlKG5hbWUpO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8vLy8vLy8vLy8vLyBTeXNcblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV9zeXNfZXJyb3IgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV93aXRoX3N0cmluZywgY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9yYWlzZV9zeXNfZXJyb3IgKG1zZykge1xuICBjYW1sX3JhaXNlX3dpdGhfc3RyaW5nKGNhbWxfZ2xvYmFsX2RhdGEuU3lzX2Vycm9yLCBtc2cpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19leGl0XG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfc3lzX2V4aXQgKGNvZGUpIHtcbiAgdmFyIGcgPSBqb29fZ2xvYmFsX29iamVjdDtcbiAgaWYoZy5xdWl0KSBnLnF1aXQoY29kZSk7XG4gIC8vbm9kZWpzXG4gIGlmKGcucHJvY2VzcyAmJiBnLnByb2Nlc3MuZXhpdClcbiAgICBnLnByb2Nlc3MuZXhpdChjb2RlKTtcbiAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiRnVuY3Rpb24gJ2V4aXQnIG5vdCBpbXBsZW1lbnRlZFwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zZXRfc3RhdGljX2VudlxuZnVuY3Rpb24gY2FtbF9zZXRfc3RhdGljX2VudihrLHYpe1xuICBpZigham9vX2dsb2JhbF9vYmplY3QuanNvb19zdGF0aWNfZW52KVxuICAgIGpvb19nbG9iYWxfb2JqZWN0Lmpzb29fc3RhdGljX2VudiA9IHt9XG4gIGpvb19nbG9iYWxfb2JqZWN0Lmpzb29fc3RhdGljX2VudltrXSA9IHY7XG4gIHJldHVybiAwO1xufVxuLy9Qcm92aWRlczogY2FtbF9zeXNfZ2V0ZW52IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfbm90X2ZvdW5kXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3lzX2dldGVudiAobmFtZSkge1xuICB2YXIgZyA9IGpvb19nbG9iYWxfb2JqZWN0O1xuICB2YXIgbiA9IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKG5hbWUpO1xuICAvL25vZGVqcyBlbnZcbiAgaWYoZy5wcm9jZXNzXG4gICAgICYmIGcucHJvY2Vzcy5lbnZcbiAgICAgJiYgZy5wcm9jZXNzLmVudltuXSAhPSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKGcucHJvY2Vzcy5lbnZbbl0pO1xuICBpZihqb29fZ2xvYmFsX29iamVjdC5qc29vX3N0YXRpY19lbnZcbiAgICAgJiYgam9vX2dsb2JhbF9vYmplY3QuanNvb19zdGF0aWNfZW52W25dKVxuICAgIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhqb29fZ2xvYmFsX29iamVjdC5qc29vX3N0YXRpY19lbnZbbl0pXG4gIGNhbWxfcmFpc2Vfbm90X2ZvdW5kICgpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c191bnNhZmVfZ2V0ZW52XG4vL1JlcXVpcmVzOiBjYW1sX3N5c19nZXRlbnZcbmZ1bmN0aW9uIGNhbWxfc3lzX3Vuc2FmZV9nZXRlbnYobmFtZSl7XG4gIHJldHVybiBjYW1sX3N5c19nZXRlbnYgKG5hbWUpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FyZ3Zcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nXG52YXIgY2FtbF9hcmd2ID0gKChmdW5jdGlvbiAoKSB7XG4gIHZhciBnID0gam9vX2dsb2JhbF9vYmplY3Q7XG4gIHZhciBtYWluID0gXCJhLm91dFwiO1xuICB2YXIgYXJncyA9IFtdXG5cbiAgaWYoZy5wcm9jZXNzXG4gICAgICYmIGcucHJvY2Vzcy5hcmd2XG4gICAgICYmIGcucHJvY2Vzcy5hcmd2Lmxlbmd0aCA+IDEpIHtcbiAgICB2YXIgYXJndiA9IGcucHJvY2Vzcy5hcmd2XG4gICAgLy9ub2RlanNcbiAgICBtYWluID0gYXJndlsxXTtcbiAgICBhcmdzID0gYXJndi5zbGljZSgyKTtcbiAgfVxuXG4gIHZhciBwID0gY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcobWFpbik7XG4gIHZhciBhcmdzMiA9IFswLCBwXTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspXG4gICAgYXJnczIucHVzaChjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhhcmdzW2ldKSk7XG4gIHJldHVybiBhcmdzMjtcbn0pKCkpXG5cbi8vUHJvdmlkZXM6IGNhbWxfZXhlY3V0YWJsZV9uYW1lXG4vL1JlcXVpcmVzOiBjYW1sX2FyZ3ZcbnZhciBjYW1sX2V4ZWN1dGFibGVfbmFtZSA9IGNhbWxfYXJndlsxXVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19nZXRfYXJndlxuLy9SZXF1aXJlczogY2FtbF9hcmd2XG5mdW5jdGlvbiBjYW1sX3N5c19nZXRfYXJndiAoYSkge1xuICByZXR1cm4gWzAsIGNhbWxfYXJndlsxXSwgY2FtbF9hcmd2XTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfYXJndlxuLy9SZXF1aXJlczogY2FtbF9hcmd2XG5mdW5jdGlvbiBjYW1sX3N5c19hcmd2IChhKSB7XG4gIHJldHVybiBjYW1sX2FyZ3Y7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX21vZGlmeV9hcmd2XG4vL1JlcXVpcmVzOiBjYW1sX2FyZ3ZcbmZ1bmN0aW9uIGNhbWxfc3lzX21vZGlmeV9hcmd2KGFyZyl7XG4gIGNhbWxfYXJndiA9IGFyZztcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2V4ZWN1dGFibGVfbmFtZSBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9leGVjdXRhYmxlX25hbWVcbmZ1bmN0aW9uIGNhbWxfc3lzX2V4ZWN1dGFibGVfbmFtZShhKXtcbiAgcmV0dXJuIGNhbWxfZXhlY3V0YWJsZV9uYW1lXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX3N5c3RlbV9jb21tYW5kXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9zeXNfc3lzdGVtX2NvbW1hbmQoY21kKXtcbiAgdmFyIGNtZCA9IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKGNtZCk7XG4gIGlmICh0eXBlb2YgcmVxdWlyZSAhPSBcInVuZGVmaW5lZFwiXG4gICAgICAmJiByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJylcbiAgICAgICYmIHJlcXVpcmUoJ2NoaWxkX3Byb2Nlc3MnKS5leGVjU3luYykge1xuICAgIHRyeSB7cmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpLmV4ZWNTeW5jKGNtZCx7c3RkaW86ICdpbmhlcml0J30pOyByZXR1cm4gMH1cbiAgICBjYXRjaCAoZSkge3JldHVybiAxfVxuICB9XG4gIGVsc2UgcmV0dXJuIDEyNztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfdGltZSBtdXRhYmxlXG52YXIgY2FtbF9pbml0aWFsX3RpbWUgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpICogMC4wMDE7XG5mdW5jdGlvbiBjYW1sX3N5c190aW1lICgpIHtcbiAgdmFyIG5vdyA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG4gIHJldHVybiBub3cgKiAwLjAwMSAtIGNhbWxfaW5pdGlhbF90aW1lO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c190aW1lX2luY2x1ZGVfY2hpbGRyZW5cbi8vUmVxdWlyZXM6IGNhbWxfc3lzX3RpbWVcbmZ1bmN0aW9uIGNhbWxfc3lzX3RpbWVfaW5jbHVkZV9jaGlsZHJlbihiKSB7XG4gIHJldHVybiBjYW1sX3N5c190aW1lKCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX3JhbmRvbV9zZWVkIG11dGFibGVcbi8vVGhlIGZ1bmN0aW9uIG5lZWRzIHRvIHJldHVybiBhbiBhcnJheSBzaW5jZSBPQ2FtbCA0LjAuLi5cbmZ1bmN0aW9uIGNhbWxfc3lzX3JhbmRvbV9zZWVkICgpIHtcbiAgdmFyIG5vdyA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG4gIHZhciB4ID0gbm93XjB4ZmZmZmZmZmYqTWF0aC5yYW5kb20oKTtcbiAgcmV0dXJuIFswLHhdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jb25zdF9iaWdfZW5kaWFuIGNvbnN0XG5mdW5jdGlvbiBjYW1sX3N5c19jb25zdF9iaWdfZW5kaWFuICgpIHsgcmV0dXJuIDA7IH1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfY29uc3Rfd29yZF9zaXplIGNvbnN0XG5mdW5jdGlvbiBjYW1sX3N5c19jb25zdF93b3JkX3NpemUgKCkgeyByZXR1cm4gMzI7IH1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfY29uc3RfaW50X3NpemUgY29uc3RcbmZ1bmN0aW9uIGNhbWxfc3lzX2NvbnN0X2ludF9zaXplICgpIHsgcmV0dXJuIDMyOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X21heF93b3NpemUgY29uc3Rcbi8vIG1heF9pbnQgLyA0IHNvIHRoYXQgdGhlIGZvbGxvd2luZyBkb2VzIG5vdCBvdmVyZmxvd1xuLy9sZXQgbWF4X3N0cmluZ19sZW5ndGggPSB3b3JkX3NpemUgLyA4ICogbWF4X2FycmF5X2xlbmd0aCAtIDE7O1xuZnVuY3Rpb24gY2FtbF9zeXNfY29uc3RfbWF4X3dvc2l6ZSAoKSB7IHJldHVybiAoMHg3RkZGRkZGRi80KSB8IDA7fVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jb25zdF9vc3R5cGVfdW5peCBjb25zdFxuZnVuY3Rpb24gY2FtbF9zeXNfY29uc3Rfb3N0eXBlX3VuaXggKCkgeyByZXR1cm4gMTsgfVxuLy9Qcm92aWRlczogY2FtbF9zeXNfY29uc3Rfb3N0eXBlX3dpbjMyIGNvbnN0XG5mdW5jdGlvbiBjYW1sX3N5c19jb25zdF9vc3R5cGVfd2luMzIgKCkgeyByZXR1cm4gMDsgfVxuLy9Qcm92aWRlczogY2FtbF9zeXNfY29uc3Rfb3N0eXBlX2N5Z3dpbiBjb25zdFxuZnVuY3Rpb24gY2FtbF9zeXNfY29uc3Rfb3N0eXBlX2N5Z3dpbiAoKSB7IHJldHVybiAwOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X2JhY2tlbmRfdHlwZSBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9zeXNfY29uc3RfYmFja2VuZF90eXBlICgpIHtcbiAgcmV0dXJuIFswLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKFwianNfb2Zfb2NhbWxcIildO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19nZXRfY29uZmlnIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX3N5c19nZXRfY29uZmlnICgpIHtcbiAgcmV0dXJuIFswLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKFwiVW5peFwiKSwgMzIsIDBdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19pc2F0dHlcbmZ1bmN0aW9uIGNhbWxfc3lzX2lzYXR0eShfY2hhbikge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ydW50aW1lX3ZhcmlhbnRcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfcnVudGltZV92YXJpYW50KF91bml0KSB7XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKFwiXCIpO1xufVxuLy9Qcm92aWRlczogY2FtbF9ydW50aW1lX3BhcmFtZXRlcnNcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfcnVudGltZV9wYXJhbWV0ZXJzKF91bml0KSB7XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKFwiXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2luc3RhbGxfc2lnbmFsX2hhbmRsZXIgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW5zdGFsbF9zaWduYWxfaGFuZGxlcigpe3JldHVybiAwfVxuXG4vL1Byb3ZpZGVzOiB1bml4X2luZXRfYWRkcl9vZl9zdHJpbmdcbmZ1bmN0aW9uIHVuaXhfaW5ldF9hZGRyX29mX3N0cmluZyAoKSB7cmV0dXJuIDA7fVxuXG5cblxuLy9Qcm92aWRlczogY2FtbF9ydW50aW1lX3dhcm5pbmdzXG52YXIgY2FtbF9ydW50aW1lX3dhcm5pbmdzID0gMDtcblxuLy9Qcm92aWRlczogY2FtbF9tbF9lbmFibGVfcnVudGltZV93YXJuaW5nc1xuLy9SZXF1aXJlczogY2FtbF9ydW50aW1lX3dhcm5pbmdzXG5mdW5jdGlvbiBjYW1sX21sX2VuYWJsZV9ydW50aW1lX3dhcm5pbmdzIChib29sKSB7XG4gIGNhbWxfcnVudGltZV93YXJuaW5ncyA9IGJvb2w7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3J1bnRpbWVfd2FybmluZ3NfZW5hYmxlZFxuLy9SZXF1aXJlczogY2FtbF9ydW50aW1lX3dhcm5pbmdzXG5mdW5jdGlvbiBjYW1sX21sX3J1bnRpbWVfd2FybmluZ3NfZW5hYmxlZCAoX3VuaXQpIHtcbiAgcmV0dXJuIGNhbWxfcnVudGltZV93YXJuaW5ncztcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX3NwYWNldGltZV9lbmFibGVkIGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfc3BhY2V0aW1lX2VuYWJsZWQoX3VuaXQpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X25ha2VkX3BvaW50ZXJzX2NoZWNrZWQgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9zeXNfY29uc3RfbmFrZWRfcG9pbnRlcnNfY2hlY2tlZChfdW5pdCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9yZWdpc3Rlcl9jaGFubmVsX2Zvcl9zcGFjZXRpbWUgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9yZWdpc3Rlcl9jaGFubmVsX2Zvcl9zcGFjZXRpbWUoX2NoYW5uZWwpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3BhY2V0aW1lX29ubHlfd29ya3NfZm9yX25hdGl2ZV9jb2RlXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX3NwYWNldGltZV9vbmx5X3dvcmtzX2Zvcl9uYXRpdmVfY29kZSgpIHtcbiAgY2FtbF9mYWlsd2l0aChcIlNwYWNldGltZSBwcm9maWxpbmcgb25seSB3b3JrcyBmb3IgbmF0aXZlIGNvZGVcIik7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTQgSsOpcsO0bWUgVm91aWxsb24sIEh1Z28gSGV1emFyZFxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBNbEZha2VEZXZpY2Vcbi8vUmVxdWlyZXM6IE1sRmFrZUZpbGUsIGNhbWxfY3JlYXRlX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3N5c19lcnJvciwgY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGVcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMsIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX29mX2FycmF5LCBjYW1sX2J5dGVzX29mX3N0cmluZywgY2FtbF9ieXRlc19vZl9qc2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2lzX21sX2J5dGVzLCBjYW1sX2lzX21sX3N0cmluZ1xuZnVuY3Rpb24gTWxGYWtlRGV2aWNlIChyb290LCBmKSB7XG4gIHRoaXMuY29udGVudD17fTtcbiAgdGhpcy5yb290ID0gcm9vdDtcbiAgdGhpcy5sb29rdXBGdW4gPSBmO1xufVxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5ubSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgcmV0dXJuICh0aGlzLnJvb3QgKyBuYW1lKTtcbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUubG9va3VwID0gZnVuY3Rpb24obmFtZSkge1xuICBpZighdGhpcy5jb250ZW50W25hbWVdICYmIHRoaXMubG9va3VwRnVuKSB7XG4gICAgdmFyIHJlcyA9IHRoaXMubG9va3VwRnVuKGNhbWxfc3RyaW5nX29mX2pzYnl0ZXModGhpcy5yb290KSwgY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhuYW1lKSk7XG4gICAgaWYocmVzICE9PSAwKSB0aGlzLmNvbnRlbnRbbmFtZV09bmV3IE1sRmFrZUZpbGUoY2FtbF9ieXRlc19vZl9zdHJpbmcocmVzWzFdKSk7XG4gIH1cbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUuZXhpc3RzID0gZnVuY3Rpb24obmFtZSkge1xuICAvLyBUaGUgcm9vdCBvZiB0aGUgZGV2aWNlIGV4aXN0c1xuICBpZihuYW1lID09IFwiXCIpIHJldHVybiAxO1xuICAvLyBDaGVjayBpZiBhIGRpcmVjdG9yeSBleGlzdHNcbiAgdmFyIG5hbWVfc2xhc2ggPSAobmFtZSArIFwiL1wiKTtcbiAgdmFyIHIgPSBuZXcgUmVnRXhwKFwiXlwiICsgbmFtZV9zbGFzaCk7XG4gIGZvcih2YXIgbiBpbiB0aGlzLmNvbnRlbnQpIHtcbiAgICBpZiAobi5tYXRjaChyKSkgcmV0dXJuIDFcbiAgfVxuICAvLyBDaGVjayBpZiBhIGZpbGUgZXhpc3RzXG4gIHRoaXMubG9va3VwKG5hbWUpO1xuICByZXR1cm4gdGhpcy5jb250ZW50W25hbWVdPzE6MDtcbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUucmVhZGRpciA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdmFyIG5hbWVfc2xhc2ggPSAobmFtZSA9PSBcIlwiKT9cIlwiOihuYW1lICsgXCIvXCIpO1xuICB2YXIgciA9IG5ldyBSZWdFeHAoXCJeXCIgKyBuYW1lX3NsYXNoICsgXCIoW14vXSopXCIpO1xuICB2YXIgc2VlbiA9IHt9XG4gIHZhciBhID0gW107XG4gIGZvcih2YXIgbiBpbiB0aGlzLmNvbnRlbnQpIHtcbiAgICB2YXIgbSA9IG4ubWF0Y2gocik7XG4gICAgaWYobSAmJiAhc2VlblttWzFdXSkge3NlZW5bbVsxXV0gPSB0cnVlOyBhLnB1c2gobVsxXSl9XG4gIH1cbiAgcmV0dXJuIGE7XG59XG5NbEZha2VEZXZpY2UucHJvdG90eXBlLmlzX2RpciA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdmFyIG5hbWVfc2xhc2ggPSAobmFtZSA9PSBcIlwiKT9cIlwiOihuYW1lICsgXCIvXCIpO1xuICB2YXIgciA9IG5ldyBSZWdFeHAoXCJeXCIgKyBuYW1lX3NsYXNoICsgXCIoW14vXSopXCIpO1xuICB2YXIgYSA9IFtdO1xuICBmb3IodmFyIG4gaW4gdGhpcy5jb250ZW50KSB7XG4gICAgdmFyIG0gPSBuLm1hdGNoKHIpO1xuICAgIGlmKG0pIHJldHVybiAxXG4gIH1cbiAgcmV0dXJuIDBcbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUudW5saW5rID0gZnVuY3Rpb24obmFtZSkge1xuICB2YXIgb2sgPSB0aGlzLmNvbnRlbnRbbmFtZV0/dHJ1ZTpmYWxzZTtcbiAgZGVsZXRlIHRoaXMuY29udGVudFtuYW1lXTtcbiAgcmV0dXJuIG9rO1xufVxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24obmFtZSwgZikge1xuICBpZihmLnJkb25seSAmJiBmLndyb25seSlcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcih0aGlzLm5tKG5hbWUpICsgXCIgOiBmbGFncyBPcGVuX3Jkb25seSBhbmQgT3Blbl93cm9ubHkgYXJlIG5vdCBjb21wYXRpYmxlXCIpO1xuICBpZihmLnRleHQgJiYgZi5iaW5hcnkpXG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IodGhpcy5ubShuYW1lKSArIFwiIDogZmxhZ3MgT3Blbl90ZXh0IGFuZCBPcGVuX2JpbmFyeSBhcmUgbm90IGNvbXBhdGlibGVcIik7XG4gIHRoaXMubG9va3VwKG5hbWUpO1xuICBpZiAodGhpcy5jb250ZW50W25hbWVdKSB7XG4gICAgaWYgKHRoaXMuaXNfZGlyKG5hbWUpKSBjYW1sX3JhaXNlX3N5c19lcnJvcih0aGlzLm5tKG5hbWUpICsgXCIgOiBpcyBhIGRpcmVjdG9yeVwiKTtcbiAgICBpZiAoZi5jcmVhdGUgJiYgZi5leGNsKSBjYW1sX3JhaXNlX3N5c19lcnJvcih0aGlzLm5tKG5hbWUpICsgXCIgOiBmaWxlIGFscmVhZHkgZXhpc3RzXCIpO1xuICAgIHZhciBmaWxlID0gdGhpcy5jb250ZW50W25hbWVdO1xuICAgIGlmKGYudHJ1bmNhdGUpIGZpbGUudHJ1bmNhdGUoKTtcbiAgICByZXR1cm4gZmlsZTtcbiAgfSBlbHNlIGlmIChmLmNyZWF0ZSkge1xuICAgIHRoaXMuY29udGVudFtuYW1lXSA9IG5ldyBNbEZha2VGaWxlKGNhbWxfY3JlYXRlX2J5dGVzKDApKTtcbiAgICByZXR1cm4gdGhpcy5jb250ZW50W25hbWVdO1xuICB9IGVsc2Uge1xuICAgIGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlICh0aGlzLm5tKG5hbWUpKTtcbiAgfVxufVxuXG5NbEZha2VEZXZpY2UucHJvdG90eXBlLnJlZ2lzdGVyPSBmdW5jdGlvbiAobmFtZSxjb250ZW50KXtcbiAgaWYodGhpcy5jb250ZW50W25hbWVdKSBjYW1sX3JhaXNlX3N5c19lcnJvcih0aGlzLm5tKG5hbWUpICsgXCIgOiBmaWxlIGFscmVhZHkgZXhpc3RzXCIpO1xuICBpZihjYW1sX2lzX21sX2J5dGVzKGNvbnRlbnQpKVxuICAgIHRoaXMuY29udGVudFtuYW1lXSA9IG5ldyBNbEZha2VGaWxlKGNvbnRlbnQpO1xuICBpZihjYW1sX2lzX21sX3N0cmluZyhjb250ZW50KSlcbiAgICB0aGlzLmNvbnRlbnRbbmFtZV0gPSBuZXcgTWxGYWtlRmlsZShjYW1sX2J5dGVzX29mX3N0cmluZyhjb250ZW50KSk7XG4gIGVsc2UgaWYoY29udGVudCBpbnN0YW5jZW9mIEFycmF5KVxuICAgIHRoaXMuY29udGVudFtuYW1lXSA9IG5ldyBNbEZha2VGaWxlKGNhbWxfYnl0ZXNfb2ZfYXJyYXkoY29udGVudCkpO1xuICBlbHNlIGlmKHR5cGVvZiBjb250ZW50ID09PSBcInN0cmluZ1wiKVxuICAgIHRoaXMuY29udGVudFtuYW1lXSA9IG5ldyBNbEZha2VGaWxlKGNhbWxfYnl0ZXNfb2ZfanNieXRlcyhjb250ZW50KSk7XG4gIGVsc2UgaWYoY29udGVudC50b1N0cmluZykge1xuICAgIHZhciBieXRlcyA9IGNhbWxfYnl0ZXNfb2Zfc3RyaW5nKGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKGNvbnRlbnQudG9TdHJpbmcoKSkpO1xuICAgIHRoaXMuY29udGVudFtuYW1lXSA9IG5ldyBNbEZha2VGaWxlKGJ5dGVzKTtcbiAgfVxuICBlbHNlIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHRoaXMubm0obmFtZSkgKyBcIiA6IHJlZ2lzdGVyaW5nIGZpbGUgd2l0aCBpbnZhbGlkIGNvbnRlbnQgdHlwZVwiKTtcbn1cblxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1sRmFrZURldmljZVxuXG4vL1Byb3ZpZGVzOiBNbEZha2VGaWxlXG4vL1JlcXVpcmVzOiBNbEZpbGVcbi8vUmVxdWlyZXM6IGNhbWxfY3JlYXRlX2J5dGVzLCBjYW1sX21sX2J5dGVzX2xlbmd0aCwgY2FtbF9ibGl0X2J5dGVzLCBjYW1sX2JsaXRfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2dldFxuZnVuY3Rpb24gTWxGYWtlRmlsZShjb250ZW50KXtcbiAgdGhpcy5kYXRhID0gY29udGVudDtcbn1cbk1sRmFrZUZpbGUucHJvdG90eXBlID0gbmV3IE1sRmlsZSAoKTtcbk1sRmFrZUZpbGUucHJvdG90eXBlLnRydW5jYXRlID0gZnVuY3Rpb24obGVuKXtcbiAgdmFyIG9sZCA9IHRoaXMuZGF0YTtcbiAgdGhpcy5kYXRhID0gY2FtbF9jcmVhdGVfYnl0ZXMobGVufDApO1xuICBjYW1sX2JsaXRfYnl0ZXMob2xkLCAwLCB0aGlzLmRhdGEsIDAsIGxlbik7XG59XG5NbEZha2VGaWxlLnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBjYW1sX21sX2J5dGVzX2xlbmd0aCh0aGlzLmRhdGEpO1xufVxuTWxGYWtlRmlsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihvZmZzZXQsYnVmLHBvcyxsZW4pe1xuICB2YXIgY2xlbiA9IHRoaXMubGVuZ3RoKCk7XG4gIGlmKG9mZnNldCArIGxlbiA+PSBjbGVuKSB7XG4gICAgdmFyIG5ld19zdHIgPSBjYW1sX2NyZWF0ZV9ieXRlcyhvZmZzZXQgKyBsZW4pO1xuICAgIHZhciBvbGRfZGF0YSA9IHRoaXMuZGF0YTtcbiAgICB0aGlzLmRhdGEgPSBuZXdfc3RyO1xuICAgIGNhbWxfYmxpdF9ieXRlcyhvbGRfZGF0YSwgMCwgdGhpcy5kYXRhLCAwLCBjbGVuKTtcbiAgfVxuICBjYW1sX2JsaXRfc3RyaW5nKGJ1ZiwgcG9zLCB0aGlzLmRhdGEsIG9mZnNldCwgbGVuKTtcbiAgcmV0dXJuIDBcbn1cbk1sRmFrZUZpbGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbihvZmZzZXQsYnVmLHBvcyxsZW4pe1xuICB2YXIgY2xlbiA9IHRoaXMubGVuZ3RoKCk7XG4gIGNhbWxfYmxpdF9ieXRlcyh0aGlzLmRhdGEsIG9mZnNldCwgYnVmLCBwb3MsIGxlbik7XG4gIHJldHVybiAwXG59XG5NbEZha2VGaWxlLnByb3RvdHlwZS5yZWFkX29uZSA9IGZ1bmN0aW9uKG9mZnNldCl7XG4gIHJldHVybiBjYW1sX2J5dGVzX2dldCh0aGlzLmRhdGEsIG9mZnNldCk7XG59XG5NbEZha2VGaWxlLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCl7XG5cbn1cbk1sRmFrZUZpbGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWxGYWtlRmlsZVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDE0IErDqXLDtG1lIFZvdWlsbG9uLCBIdWdvIEhldXphcmRcbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogZnNfbm9kZV9zdXBwb3J0ZWRcbmZ1bmN0aW9uIGZzX25vZGVfc3VwcG9ydGVkICgpIHtcbiAgcmV0dXJuIChcbiAgICB0eXBlb2Ygam9vX2dsb2JhbF9vYmplY3QucHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICYmIHR5cGVvZiBqb29fZ2xvYmFsX29iamVjdC5wcm9jZXNzLnZlcnNpb25zICE9PSAndW5kZWZpbmVkJ1xuICAgICAgJiYgdHlwZW9mIGpvb19nbG9iYWxfb2JqZWN0LnByb2Nlc3MudmVyc2lvbnMubm9kZSAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICYmIGpvb19nbG9iYWxfb2JqZWN0LnByb2Nlc3MucGxhdGZvcm0gIT09IFwiYnJvd3NlclwiKVxufVxuXG5cbi8vUHJvdmlkZXM6IE1sTm9kZURldmljZVxuLy9SZXF1aXJlczogTWxOb2RlRmlsZSwgY2FtbF9yYWlzZV9zeXNfZXJyb3JcbmZ1bmN0aW9uIE1sTm9kZURldmljZShyb290KSB7XG4gIHRoaXMuZnMgPSByZXF1aXJlKCdmcycpO1xuICB0aGlzLnJvb3QgPSByb290O1xufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5ubSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgcmV0dXJuICh0aGlzLnJvb3QgKyBuYW1lKTtcbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUuZXhpc3RzID0gZnVuY3Rpb24obmFtZSkge1xuICB0cnkge1xuICAgIHJldHVybiB0aGlzLmZzLmV4aXN0c1N5bmModGhpcy5ubShuYW1lKSk/MTowO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihlcnIudG9TdHJpbmcoKSk7XG4gIH1cbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUucmVhZGRpciA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gdGhpcy5mcy5yZWFkZGlyU3luYyh0aGlzLm5tKG5hbWUpKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoZXJyLnRvU3RyaW5nKCkpO1xuICB9XG59XG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLmlzX2RpciA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gdGhpcy5mcy5zdGF0U3luYyh0aGlzLm5tKG5hbWUpKS5pc0RpcmVjdG9yeSgpPzE6MDtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoZXJyLnRvU3RyaW5nKCkpO1xuICB9XG59XG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLnVubGluayA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdHJ5IHtcbiAgICB2YXIgYiA9IHRoaXMuZnMuZXhpc3RzU3luYyh0aGlzLm5tKG5hbWUpKT8xOjA7XG4gICAgdGhpcy5mcy51bmxpbmtTeW5jKHRoaXMubm0obmFtZSkpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihlcnIudG9TdHJpbmcoKSk7XG4gIH1cbiAgcmV0dXJuIGJcbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uKG5hbWUsIGYpIHtcbiAgdmFyIGNvbnN0cyA9IHJlcXVpcmUoJ2NvbnN0YW50cycpO1xuICB2YXIgcmVzID0gMDtcbiAgZm9yKHZhciBrZXkgaW4gZil7XG4gICAgc3dpdGNoKGtleSl7XG4gICAgY2FzZSBcInJkb25seVwiICA6IHJlcyB8PSBjb25zdHMuT19SRE9OTFk7IGJyZWFrO1xuICAgIGNhc2UgXCJ3cm9ubHlcIiAgOiByZXMgfD0gY29uc3RzLk9fV1JPTkxZOyBicmVhaztcbiAgICBjYXNlIFwiYXBwZW5kXCIgIDpcbiAgICAgIHJlcyB8PSBjb25zdHMuT19XUk9OTFkgfCBjb25zdHMuT19BUFBFTkQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiY3JlYXRlXCIgICA6IHJlcyB8PSBjb25zdHMuT19DUkVBVDsgICAgYnJlYWs7XG4gICAgY2FzZSBcInRydW5jYXRlXCIgOiByZXMgfD0gY29uc3RzLk9fVFJVTkM7ICAgIGJyZWFrO1xuICAgIGNhc2UgXCJleGNsXCIgICAgIDogcmVzIHw9IGNvbnN0cy5PX0VYQ0w7ICAgICBicmVhaztcbiAgICBjYXNlIFwiYmluYXJ5XCIgICA6IHJlcyB8PSBjb25zdHMuT19CSU5BUlk7ICAgYnJlYWs7XG4gICAgY2FzZSBcInRleHRcIiAgICAgOiByZXMgfD0gY29uc3RzLk9fVEVYVDsgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJub25ibG9ja1wiIDogcmVzIHw9IGNvbnN0cy5PX05PTkJMT0NLOyBicmVhaztcbiAgICB9XG4gIH1cbiAgdHJ5IHtcbiAgICB2YXIgZmQgPSB0aGlzLmZzLm9wZW5TeW5jKHRoaXMubm0obmFtZSksIHJlcyk7XG4gICAgcmV0dXJuIG5ldyBNbE5vZGVGaWxlKGZkKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoZXJyLnRvU3RyaW5nKCkpO1xuICB9XG59XG5cbk1sTm9kZURldmljZS5wcm90b3R5cGUucmVuYW1lID0gZnVuY3Rpb24obyxuKSB7XG4gIHRyeSB7XG4gICAgdGhpcy5mcy5yZW5hbWVTeW5jKHRoaXMubm0obyksIHRoaXMubm0obikpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihlcnIudG9TdHJpbmcoKSk7XG4gIH1cbn1cblxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1sTm9kZURldmljZVxuXG4vL1Byb3ZpZGVzOiBNbE5vZGVGaWxlXG4vL1JlcXVpcmVzOiBNbEZpbGUsIGNhbWxfYXJyYXlfb2Zfc3RyaW5nLCBjYW1sX2FycmF5X29mX2J5dGVzLCBjYW1sX2J5dGVzX3NldCwgY2FtbF9yYWlzZV9zeXNfZXJyb3JcbmZ1bmN0aW9uIE1sTm9kZUZpbGUoZmQpe1xuICB0aGlzLmZzID0gcmVxdWlyZSgnZnMnKTtcbiAgdGhpcy5mZCA9IGZkO1xufVxuTWxOb2RlRmlsZS5wcm90b3R5cGUgPSBuZXcgTWxGaWxlICgpO1xuXG5NbE5vZGVGaWxlLnByb3RvdHlwZS50cnVuY2F0ZSA9IGZ1bmN0aW9uKGxlbil7XG4gIHRyeSB7XG4gICAgdGhpcy5mcy5mdHJ1bmNhdGVTeW5jKHRoaXMuZmQsbGVufDApXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKGVyci50b1N0cmluZygpKTtcbiAgfVxufVxuTWxOb2RlRmlsZS5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIHJldHVybiB0aGlzLmZzLmZzdGF0U3luYyh0aGlzLmZkKS5zaXplO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihlcnIudG9TdHJpbmcoKSk7XG4gIH1cbn1cbk1sTm9kZUZpbGUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24ob2Zmc2V0LGJ1ZixidWZfb2Zmc2V0LGxlbil7XG4gIHZhciBhID0gY2FtbF9hcnJheV9vZl9zdHJpbmcoYnVmKTtcbiAgaWYoISAoYSBpbnN0YW5jZW9mIGpvb19nbG9iYWxfb2JqZWN0LlVpbnQ4QXJyYXkpKVxuICAgIGEgPSBuZXcgam9vX2dsb2JhbF9vYmplY3QuVWludDhBcnJheShhKTtcbiAgdmFyIGJ1ZmZlciA9IGpvb19nbG9iYWxfb2JqZWN0LkJ1ZmZlci5mcm9tKGEpO1xuICB0cnkge1xuICAgIHRoaXMuZnMud3JpdGVTeW5jKHRoaXMuZmQsIGJ1ZmZlciwgYnVmX29mZnNldCwgbGVuLCBvZmZzZXQpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihlcnIudG9TdHJpbmcoKSk7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5NbE5vZGVGaWxlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24ob2Zmc2V0LGJ1ZixidWZfb2Zmc2V0LGxlbil7XG4gIHZhciBhID0gY2FtbF9hcnJheV9vZl9ieXRlcyhidWYpO1xuICBpZighIChhIGluc3RhbmNlb2Ygam9vX2dsb2JhbF9vYmplY3QuVWludDhBcnJheSkpXG4gICAgYSA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5VaW50OEFycmF5KGEpO1xuICB2YXIgYnVmZmVyID0gam9vX2dsb2JhbF9vYmplY3QuQnVmZmVyLmZyb20oYSk7XG4gIHRyeSB7XG4gICAgdGhpcy5mcy5yZWFkU3luYyh0aGlzLmZkLCBidWZmZXIsIGJ1Zl9vZmZzZXQsIGxlbiwgb2Zmc2V0KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoZXJyLnRvU3RyaW5nKCkpO1xuICB9XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKyl7XG4gICAgY2FtbF9ieXRlc19zZXQoYnVmLGJ1Zl9vZmZzZXQgKyBpLGJ1ZmZlcltidWZfb2Zmc2V0K2ldKTtcbiAgfVxuICByZXR1cm4gMFxufVxuTWxOb2RlRmlsZS5wcm90b3R5cGUucmVhZF9vbmUgPSBmdW5jdGlvbihvZmZzZXQpe1xuICB2YXIgYSA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5VaW50OEFycmF5KDEpO1xuICB2YXIgYnVmZmVyID0gam9vX2dsb2JhbF9vYmplY3QuQnVmZmVyLmZyb20oYSk7XG4gIHRyeSB7XG4gICAgdGhpcy5mcy5yZWFkU3luYyh0aGlzLmZkLCBidWZmZXIsIDAsIDEsIG9mZnNldCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKGVyci50b1N0cmluZygpKTtcbiAgfVxuICByZXR1cm4gYnVmZmVyWzBdO1xufVxuTWxOb2RlRmlsZS5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpe1xuICB0cnkge1xuICAgIHRoaXMuZnMuY2xvc2VTeW5jKHRoaXMuZmQpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihlcnIudG9TdHJpbmcoKSk7XG4gIH1cbn1cblxuTWxOb2RlRmlsZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNbE5vZGVGaWxlO1xuIiwiLy9Qcm92aWRlczogaW5pdGlhbGl6ZV9uYXRcbi8vUmVxdWlyZXM6IGNhbWxfY3VzdG9tX29wc1xuLy9SZXF1aXJlczogc2VyaWFsaXplX25hdCwgZGVzZXJpYWxpemVfbmF0LCBjYW1sX2hhc2hfbmF0XG5mdW5jdGlvbiBpbml0aWFsaXplX25hdCgpIHtcbiAgY2FtbF9jdXN0b21fb3BzW1wiX25hdFwiXSA9XG4gICAgeyBkZXNlcmlhbGl6ZSA6IGRlc2VyaWFsaXplX25hdCxcbiAgICAgIHNlcmlhbGl6ZSA6IHNlcmlhbGl6ZV9uYXQsXG4gICAgICBoYXNoIDogY2FtbF9oYXNoX25hdFxuICAgIH1cbn1cblxuLy9Qcm92aWRlczogTWxOYXRcbmZ1bmN0aW9uIE1sTmF0KHgpe1xuICB0aGlzLmRhdGEgPSBuZXcgam9vX2dsb2JhbF9vYmplY3QuSW50MzJBcnJheSh4KTtcbiAgLy8gbGVuZ3RoX25hdCBpc24ndCBleHRlcm5hbCwgc28gd2UgaGF2ZSB0byBtYWtlIHRoZSBPYmouc2l6ZVxuICAvLyB3b3JrIG91dCByaWdodC4gVGhlICsyIHRvIGFycmF5IGxlbmd0aCBzZWVtcyB0byB3b3JrLlxuICB0aGlzLmxlbmd0aCA9IHRoaXMuZGF0YS5sZW5ndGggKyAyXG59XG5cbk1sTmF0LnByb3RvdHlwZS5jYW1sX2N1c3RvbSA9IFwiX25hdFwiO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbmF0XG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2ludCwgbnVtX2RpZ2l0c19uYXRcbmZ1bmN0aW9uIGNhbWxfaGFzaF9uYXQoeCkge1xuICB2YXIgbGVuID0gbnVtX2RpZ2l0c19uYXQoeCwgMCwgeC5kYXRhLmxlbmd0aCk7XG4gIHZhciBoID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCB4LmRhdGFbaV0pO1xuICB9XG4gIHJldHVybiBoO1xufVxuXG5cbi8vUHJvdmlkZXM6IG5hdF9vZl9hcnJheVxuLy9SZXF1aXJlczogTWxOYXRcbmZ1bmN0aW9uIG5hdF9vZl9hcnJheShsKXtcbiAgcmV0dXJuIG5ldyBNbE5hdChsKTtcbn1cblxuLy9Qcm92aWRlczogY3JlYXRlX25hdFxuLy9SZXF1aXJlczogTWxOYXRcbmZ1bmN0aW9uIGNyZWF0ZV9uYXQoc2l6ZSkge1xuICB2YXIgYXJyID0gbmV3IE1sTmF0KHNpemUpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgYXJyLmRhdGFbaV0gPSAtMTtcbiAgfVxuICByZXR1cm4gYXJyO1xufVxuXG4vL1Byb3ZpZGVzOiBzZXRfdG9femVyb19uYXRcbmZ1bmN0aW9uIHNldF90b196ZXJvX25hdChuYXQsIG9mcywgbGVuKSB7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIG5hdC5kYXRhW29mcytpXSA9IDA7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGJsaXRfbmF0XG5mdW5jdGlvbiBibGl0X25hdChuYXQxLCBvZnMxLCBuYXQyLCBvZnMyLCBsZW4pIHtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgbmF0MS5kYXRhW29mczEraV0gPSBuYXQyLmRhdGFbb2ZzMitpXTtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogc2V0X2RpZ2l0X25hdFxuZnVuY3Rpb24gc2V0X2RpZ2l0X25hdChuYXQsIG9mcywgZGlnaXQpIHtcbiAgbmF0LmRhdGFbb2ZzXSA9IGRpZ2l0O1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogbnRoX2RpZ2l0X25hdFxuZnVuY3Rpb24gbnRoX2RpZ2l0X25hdChuYXQsIG9mcykge1xuICByZXR1cm4gbmF0LmRhdGFbb2ZzXTtcbn1cblxuLy9Qcm92aWRlczogc2V0X2RpZ2l0X25hdF9uYXRpdmVcbmZ1bmN0aW9uIHNldF9kaWdpdF9uYXRfbmF0aXZlKG5hdCwgb2ZzLCBkaWdpdCkge1xuICBuYXQuZGF0YVtvZnNdID0gZGlnaXQ7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBudGhfZGlnaXRfbmF0X25hdGl2ZVxuZnVuY3Rpb24gbnRoX2RpZ2l0X25hdF9uYXRpdmUobmF0LCBvZnMpIHtcbiAgcmV0dXJuIG5hdC5kYXRhW29mc107XG59XG5cbi8vUHJvdmlkZXM6IG51bV9kaWdpdHNfbmF0XG5mdW5jdGlvbiBudW1fZGlnaXRzX25hdChuYXQsIG9mcywgbGVuKSB7XG4gIGZvcih2YXIgaSA9IGxlbiAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYobmF0LmRhdGFbb2ZzK2ldICE9IDApIHJldHVybiBpKzE7XG4gIH1cbiAgcmV0dXJuIDE7IC8vIDAgY291bnRzIGFzIDEgZGlnaXRcbn1cblxuLy9Qcm92aWRlczogbnVtX2xlYWRpbmdfemVyb19iaXRzX2luX2RpZ2l0XG5mdW5jdGlvbiBudW1fbGVhZGluZ196ZXJvX2JpdHNfaW5fZGlnaXQobmF0LCBvZnMpIHtcbiAgdmFyIGEgPSBuYXQuZGF0YVtvZnNdO1xuICB2YXIgYiA9IDA7XG4gIGlmKGEgJiAweEZGRkYwMDAwKSB7IGIgKz0xNjsgYSA+Pj49MTY7IH1cbiAgaWYoYSAmIDB4RkYwMCkgICAgIHsgYiArPSA4OyBhID4+Pj0gODsgfVxuICBpZihhICYgMHhGMCkgICAgICAgeyBiICs9IDQ7IGEgPj4+PSA0OyB9XG4gIGlmKGEgJiAxMikgICAgICAgICB7IGIgKz0gMjsgYSA+Pj49IDI7IH1cbiAgaWYoYSAmIDIpICAgICAgICAgIHsgYiArPSAxOyBhID4+Pj0gMTsgfVxuICBpZihhICYgMSkgICAgICAgICAgeyBiICs9IDE7IH1cbiAgcmV0dXJuIDMyIC0gYjtcbn1cblxuLy9Qcm92aWRlczogaXNfZGlnaXRfaW50XG5mdW5jdGlvbiBpc19kaWdpdF9pbnQobmF0LCBvZnMpIHtcbiAgaWYgKG5hdC5kYXRhW29mc10gPj0gMCkgcmV0dXJuIDFcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGlzX2RpZ2l0X3plcm9cbmZ1bmN0aW9uIGlzX2RpZ2l0X3plcm8obmF0LCBvZnMpIHtcbiAgaWYobmF0LmRhdGFbb2ZzXSA9PSAwKSByZXR1cm4gMTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGlzX2RpZ2l0X29kZFxuZnVuY3Rpb24gaXNfZGlnaXRfb2RkKG5hdCwgb2ZzKSB7XG4gIGlmKG5hdC5kYXRhW29mc10gJiAxKSByZXR1cm4gMTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGluY3JfbmF0XG5mdW5jdGlvbiBpbmNyX25hdChuYXQsIG9mcywgbGVuLCBjYXJyeV9pbikge1xuICB2YXIgY2FycnkgPSBjYXJyeV9pbjtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIHggPSAobmF0LmRhdGFbb2ZzK2ldID4+PiAwKSArIGNhcnJ5O1xuICAgIG5hdC5kYXRhW29mcytpXSA9ICh4IHwgMCk7XG4gICAgaWYoeCA9PSAoeCA+Pj4gMCkpIHtcbiAgICAgIGNhcnJ5ID0gMDtcbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYXJyeSA9IDE7XG4gICAgfVxuICB9XG4gIHJldHVybiBjYXJyeTtcbn1cblxuLy8gbGVuMSA+PSBsZW4yXG4vL1Byb3ZpZGVzOiBhZGRfbmF0XG4vL1JlcXVpcmVzOiBpbmNyX25hdFxuZnVuY3Rpb24gYWRkX25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBsZW4yLCBjYXJyeV9pbikge1xuICB2YXIgY2FycnkgPSBjYXJyeV9pbjtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjI7IGkrKykge1xuICAgIHZhciB4ID0gKG5hdDEuZGF0YVtvZnMxK2ldID4+PiAwKSArIChuYXQyLmRhdGFbb2ZzMitpXSA+Pj4gMCkgKyBjYXJyeTtcbiAgICBuYXQxLmRhdGFbb2ZzMStpXSA9IHhcbiAgICBpZih4ID09ICh4ID4+PiAwKSkge1xuICAgICAgY2FycnkgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYXJyeSA9IDE7XG4gICAgfVxuICB9XG4gIHJldHVybiBpbmNyX25hdChuYXQxLCBvZnMxK2xlbjIsIGxlbjEtbGVuMiwgY2FycnkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjb21wbGVtZW50X25hdFxuZnVuY3Rpb24gY29tcGxlbWVudF9uYXQobmF0LCBvZnMsIGxlbikge1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBuYXQuZGF0YVtvZnMraV0gPSAoLTEgPj4+IDApIC0gKG5hdC5kYXRhW29mcytpXSA+Pj4gMCk7XG4gIH1cbn1cblxuLy8gb2NhbWwgZmxpcHMgY2FycnlfaW5cbi8vUHJvdmlkZXM6IGRlY3JfbmF0XG5mdW5jdGlvbiBkZWNyX25hdChuYXQsIG9mcywgbGVuLCBjYXJyeV9pbikge1xuICB2YXIgYm9ycm93ID0gKGNhcnJ5X2luID09IDEpID8gMCA6IDE7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciB4ID0gKG5hdC5kYXRhW29mcytpXSA+Pj4wKSAtIGJvcnJvdztcbiAgICBuYXQuZGF0YVtvZnMraV0gPSB4O1xuICAgIGlmICh4ID49IDApIHtcbiAgICAgIGJvcnJvdyA9IDA7XG4gICAgICBicmVhaztcbiAgICB9IGVsc2Uge1xuICAgICAgYm9ycm93ID0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIChib3Jyb3cgPT0gMSkgPyAwIDogMTtcbn1cblxuLy8gb2NhbWwgZmxpcHMgY2FycnlfaW5cbi8vIGxlbjEgPj0gbGVuMlxuLy9Qcm92aWRlczogc3ViX25hdFxuLy9SZXF1aXJlczogZGVjcl9uYXRcbmZ1bmN0aW9uIHN1Yl9uYXQobmF0MSwgb2ZzMSwgbGVuMSwgbmF0Miwgb2ZzMiwgbGVuMiwgY2FycnlfaW4pIHtcbiAgdmFyIGJvcnJvdyA9IChjYXJyeV9pbiA9PSAxKSA/IDAgOiAxO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuMjsgaSsrKSB7XG4gICAgdmFyIHggPSAobmF0MS5kYXRhW29mczEraV0gPj4+IDApIC0gKG5hdDIuZGF0YVtvZnMyK2ldID4+PiAwKSAtIGJvcnJvdztcbiAgICBuYXQxLmRhdGFbb2ZzMStpXSA9IHg7XG4gICAgaWYgKHggPj0gMCkge1xuICAgICAgYm9ycm93ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgYm9ycm93ID0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlY3JfbmF0KG5hdDEsIG9mczErbGVuMiwgbGVuMS1sZW4yLCAoYm9ycm93PT0xKT8wOjEpO1xufVxuXG4vLyBuYXQxICs9IG5hdDIgKiBuYXQzW29mczNdXG4vLyBsZW4xID49IGxlbjJcbi8vUHJvdmlkZXM6IG11bHRfZGlnaXRfbmF0XG4vL1JlcXVpcmVzOiBhZGRfbmF0LCBuYXRfb2ZfYXJyYXlcbmZ1bmN0aW9uIG11bHRfZGlnaXRfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIGxlbjIsIG5hdDMsIG9mczMpIHtcbiAgdmFyIGNhcnJ5ID0gMDtcbiAgdmFyIGEgPSAobmF0My5kYXRhW29mczNdID4+PiAwKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjI7IGkrKykge1xuICAgIHZhciB4MSA9IChuYXQxLmRhdGFbb2ZzMStpXSA+Pj4gMCkgKyAobmF0Mi5kYXRhW29mczIraV0gPj4+IDApICogKGEgJiAweDAwMDBGRkZGKSArIGNhcnJ5O1xuICAgIHZhciB4MiA9IChuYXQyLmRhdGFbb2ZzMitpXSA+Pj4gMCkgKiAoYSA+Pj4gMTYpO1xuICAgIGNhcnJ5ID0gTWF0aC5mbG9vcih4Mi82NTUzNik7XG4gICAgdmFyIHgzID0geDEgKyAoeDIgJSA2NTUzNikgKiA2NTUzNjtcbiAgICBuYXQxLmRhdGFbb2ZzMStpXSA9IHgzO1xuICAgIGNhcnJ5ICs9IE1hdGguZmxvb3IoeDMvNDI5NDk2NzI5Nik7XG4gIH1cblxuICBpZihsZW4yIDwgbGVuMSAmJiBjYXJyeSkge1xuICAgIHJldHVybiBhZGRfbmF0KG5hdDEsIG9mczErbGVuMiwgbGVuMS1sZW4yLCBuYXRfb2ZfYXJyYXkoW2NhcnJ5XSksIDAsIDEsIDApO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjYXJyeTtcbiAgfVxufVxuXG4vLyBuYXQxICs9IG5hdDIgKiBuYXQzXG4vLyBsZW4xID49IGxlbjIgKyBsZW4zLlxuLy9Qcm92aWRlczogbXVsdF9uYXRcbi8vUmVxdWlyZXM6IG11bHRfZGlnaXRfbmF0XG5mdW5jdGlvbiBtdWx0X25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBsZW4yLCBuYXQzLCBvZnMzLCBsZW4zKSB7XG4gIHZhciBjYXJyeSA9IDA7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW4zOyBpKyspIHtcbiAgICBjYXJyeSArPSBtdWx0X2RpZ2l0X25hdChuYXQxLCBvZnMxK2ksIGxlbjEtaSwgbmF0Miwgb2ZzMiwgbGVuMiwgbmF0Mywgb2ZzMytpKTtcbiAgfVxuICByZXR1cm4gY2Fycnk7XG59XG5cbi8vIG5hdDEgPSAyICogbmF0MSArIG5hdDIgKiBuYXQyXG4vLyBsZW4xID49IDIgKiBsZW4yXG4vL1Byb3ZpZGVzOiBzcXVhcmVfbmF0XG4vL1JlcXVpcmVzOiBtdWx0X25hdCwgYWRkX25hdFxuZnVuY3Rpb24gc3F1YXJlX25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBsZW4yKSB7XG4gIHZhciBjYXJyeSA9IDA7XG4gIGNhcnJ5ICs9IGFkZF9uYXQobmF0MSwgb2ZzMSwgbGVuMSwgbmF0MSwgb2ZzMSwgbGVuMSwgMCk7XG4gIGNhcnJ5ICs9IG11bHRfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIGxlbjIsIG5hdDIsIG9mczIsIGxlbjIpO1xuICByZXR1cm4gY2Fycnk7XG59XG5cblxuLy8gMCA8PSBzaGlmdCA8IDMyXG4vL1Byb3ZpZGVzOiBzaGlmdF9sZWZ0X25hdFxuZnVuY3Rpb24gc2hpZnRfbGVmdF9uYXQobmF0MSwgb2ZzMSwgbGVuMSwgbmF0Miwgb2ZzMiwgbmJpdHMpIHtcbiAgaWYobmJpdHMgPT0gMCkge1xuICAgIG5hdDIuZGF0YVtvZnMyXSA9IDA7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgdmFyIHdyYXAgPSAwO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuMTsgaSsrKSB7XG4gICAgdmFyIGEgPSAobmF0MS5kYXRhW29mczEraV0gPj4+IDApO1xuICAgIG5hdDEuZGF0YVtvZnMxK2ldID0gKGEgPDwgbmJpdHMpIHwgd3JhcDtcbiAgICB3cmFwID0gYSA+Pj4gKDMyIC0gbmJpdHMpO1xuICB9XG4gIG5hdDIuZGF0YVtvZnMyXSA9IHdyYXA7XG4gIHJldHVybiAwO1xufVxuXG4vLyBBc3N1bWluZyBjID4gYSwgcmV0dXJucyBbcXVvdGllbnQsIHJlbWFpbmRlcl0gb2YgKGE8PDMyICsgYikvY1xuLy9Qcm92aWRlczogZGl2X2hlbHBlclxuZnVuY3Rpb24gZGl2X2hlbHBlcihhLCBiLCBjKSB7XG4gIHZhciB4ID0gYSAqIDY1NTM2ICsgKGI+Pj4xNik7XG4gIHZhciB5ID0gTWF0aC5mbG9vcih4L2MpICogNjU1MzY7XG4gIHZhciB6ID0gKHggJSBjKSAqIDY1NTM2O1xuICB2YXIgdyA9IHogKyAoYiAmIDB4MDAwMEZGRkYpO1xuICByZXR1cm4gW3kgKyBNYXRoLmZsb29yKHcvYyksIHcgJSBjXTtcbn1cblxuLy8gbmF0MVtvZnMxK2xlbl0gPCBuYXQyW29mczJdXG4vL1Byb3ZpZGVzOiBkaXZfZGlnaXRfbmF0XG4vL1JlcXVpcmVzOiBkaXZfaGVscGVyXG5mdW5jdGlvbiBkaXZfZGlnaXRfbmF0KG5hdHEsIG9mc3EsIG5hdHIsIG9mc3IsIG5hdDEsIG9mczEsIGxlbiwgbmF0Miwgb2ZzMikge1xuICB2YXIgcmVtID0gKG5hdDEuZGF0YVtvZnMxK2xlbi0xXSA+Pj4wKTtcbiAgLy8gbmF0cVtvZnNxK2xlbi0xXSBpcyBndWFyYW50ZWVkIHRvIGJlIHplcm8gKGR1ZSB0byB0aGUgTVNEIHJlcXVpcmVtZW50KSxcbiAgLy8gYW5kIHNob3VsZCBub3QgYmUgd3JpdHRlbiB0by5cbiAgZm9yKHZhciBpID0gbGVuLTI7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIHggPSBkaXZfaGVscGVyKHJlbSwgKG5hdDEuZGF0YVtvZnMxK2ldID4+PiAwKSwgKG5hdDIuZGF0YVtvZnMyXSA+Pj4gMCkpO1xuICAgIG5hdHEuZGF0YVtvZnNxK2ldID0geFswXTtcbiAgICByZW0gPSB4WzFdO1xuICB9XG4gIG5hdHIuZGF0YVtvZnNyXSA9IHJlbTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vIG5hdDFbbmF0MjpdIDo9IG5hdDEgLyBuYXQyXG4vLyBuYXQxWzpuYXQyXSA6PSBuYXQxICUgbmF0MlxuLy8gbGVuMSA+IGxlbjIsIG5hdDJbb2ZzMitsZW4yLTFdID4gbmF0MVtvZnMxK2xlbjEtMV1cbi8vUHJvdmlkZXM6IGRpdl9uYXRcbi8vUmVxdWlyZXM6IGRpdl9kaWdpdF9uYXQsIGRpdl9oZWxwZXIsIG51bV9sZWFkaW5nX3plcm9fYml0c19pbl9kaWdpdCwgc2hpZnRfbGVmdF9uYXQsIHNoaWZ0X3JpZ2h0X25hdCwgY3JlYXRlX25hdCwgc2V0X3RvX3plcm9fbmF0LCBtdWx0X2RpZ2l0X25hdCwgc3ViX25hdCwgY29tcGFyZV9uYXQsIG5hdF9vZl9hcnJheVxuZnVuY3Rpb24gZGl2X25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBsZW4yKSB7XG4gIGlmKGxlbjIgPT0gMSkge1xuICAgIGRpdl9kaWdpdF9uYXQobmF0MSwgb2ZzMSsxLCBuYXQxLCBvZnMxLCBuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyKTtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHZhciBzID0gbnVtX2xlYWRpbmdfemVyb19iaXRzX2luX2RpZ2l0KG5hdDIsIG9mczIrbGVuMi0xKTtcbiAgc2hpZnRfbGVmdF9uYXQobmF0Miwgb2ZzMiwgbGVuMiwgbmF0X29mX2FycmF5KFswXSksIDAsIHMpO1xuICBzaGlmdF9sZWZ0X25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXRfb2ZfYXJyYXkoWzBdKSwgMCwgcyk7XG5cbiAgdmFyIGQgPSAobmF0Mi5kYXRhW29mczIrbGVuMi0xXSA+Pj4gMCkgKyAxO1xuICB2YXIgYSA9IGNyZWF0ZV9uYXQobGVuMisxKTtcbiAgZm9yICh2YXIgaSA9IGxlbjEgLSAxOyBpID49IGxlbjI7IGktLSkge1xuICAgIC8vIERlY2VudCBsb3dlciBib3VuZCBvbiBxdW9cbiAgICB2YXIgcXVvID0gZCA9PSA0Mjk0OTY3Mjk2ID8gKG5hdDEuZGF0YVtvZnMxK2ldID4+PiAwKSA6IGRpdl9oZWxwZXIoKG5hdDEuZGF0YVtvZnMxK2ldID4+PiAwKSwgKG5hdDEuZGF0YVtvZnMxK2ktMV0gPj4+MCksIGQpWzBdO1xuICAgIHNldF90b196ZXJvX25hdChhLCAwLCBsZW4yKzEpO1xuICAgIG11bHRfZGlnaXRfbmF0KGEsIDAsIGxlbjIrMSwgbmF0Miwgb2ZzMiwgbGVuMiwgbmF0X29mX2FycmF5KFtxdW9dKSwgMCk7XG4gICAgc3ViX25hdChuYXQxLCBvZnMxK2ktbGVuMiwgbGVuMisxLCBhLCAwLCBsZW4yKzEsIDEpO1xuXG4gICAgd2hpbGUgKG5hdDEuZGF0YVtvZnMxK2ldICE9IDAgfHwgY29tcGFyZV9uYXQobmF0MSwgb2ZzMStpLWxlbjIsIGxlbjIsIG5hdDIsIG9mczIsIGxlbjIpID49IDApIHtcbiAgICAgIHF1byA9IHF1byArIDE7XG4gICAgICBzdWJfbmF0KG5hdDEsIG9mczEraS1sZW4yLCBsZW4yKzEsIG5hdDIsIG9mczIsIGxlbjIsIDEpO1xuICAgIH1cblxuICAgIG5hdDEuZGF0YVtvZnMxK2ldID0gcXVvO1xuICB9XG5cbiAgc2hpZnRfcmlnaHRfbmF0KG5hdDEsIG9mczEsIGxlbjIsIG5hdF9vZl9hcnJheShbMF0pLCAwLCBzKTsgLy8gc2hpZnQgcmVtYWluZGVyXG4gIHNoaWZ0X3JpZ2h0X25hdChuYXQyLCBvZnMyLCBsZW4yLCBuYXRfb2ZfYXJyYXkoWzBdKSwgMCwgcyk7IC8vIHJlc3RvcmVcbiAgcmV0dXJuIDA7XG59XG5cblxuLy8gMCA8PSBzaGlmdCA8IDMyXG4vL1Byb3ZpZGVzOiBzaGlmdF9yaWdodF9uYXRcbmZ1bmN0aW9uIHNoaWZ0X3JpZ2h0X25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBuYml0cykge1xuICBpZihuYml0cyA9PSAwKSB7XG4gICAgbmF0Mi5kYXRhW29mczJdID0gMDtcbiAgICByZXR1cm4gMDtcbiAgfVxuICB2YXIgd3JhcCA9IDA7XG4gIGZvcih2YXIgaSA9IGxlbjEtMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgYSA9IG5hdDEuZGF0YVtvZnMxK2ldID4+PiAwO1xuICAgIG5hdDEuZGF0YVtvZnMxK2ldID0gKGEgPj4+IG5iaXRzKSB8IHdyYXA7XG4gICAgd3JhcCA9IGEgPDwgKDMyIC0gbmJpdHMpO1xuICB9XG4gIG5hdDIuZGF0YVtvZnMyXSA9IHdyYXA7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjb21wYXJlX2RpZ2l0c19uYXRcbmZ1bmN0aW9uIGNvbXBhcmVfZGlnaXRzX25hdChuYXQxLCBvZnMxLCBuYXQyLCBvZnMyKSB7XG4gIGlmKG5hdDEuZGF0YVtvZnMxXSA+IG5hdDIuZGF0YVtvZnMyXSkgcmV0dXJuIDE7XG4gIGlmKG5hdDEuZGF0YVtvZnMxXSA8IG5hdDIuZGF0YVtvZnMyXSkgcmV0dXJuIC0xO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY29tcGFyZV9uYXRcbi8vUmVxdWlyZXM6IG51bV9kaWdpdHNfbmF0XG5mdW5jdGlvbiBjb21wYXJlX25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBsZW4yKSB7XG4gIHZhciBhID0gbnVtX2RpZ2l0c19uYXQobmF0MSwgb2ZzMSwgbGVuMSk7XG4gIHZhciBiID0gbnVtX2RpZ2l0c19uYXQobmF0Miwgb2ZzMiwgbGVuMik7XG4gIGlmKGEgPiBiKSByZXR1cm4gMTtcbiAgaWYoYSA8IGIpIHJldHVybiAtMTtcbiAgZm9yKHZhciBpID0gbGVuMSAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKChuYXQxLmRhdGFbb2ZzMStpXSA+Pj4gMCkgPiAobmF0Mi5kYXRhW29mczIraV0gPj4+IDApKSByZXR1cm4gMTtcbiAgICBpZiAoKG5hdDEuZGF0YVtvZnMxK2ldID4+PiAwKSA8IChuYXQyLmRhdGFbb2ZzMitpXSA+Pj4gMCkpIHJldHVybiAtMTtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY29tcGFyZV9uYXRfcmVhbFxuLy9SZXF1aXJlczogY29tcGFyZV9uYXRcbmZ1bmN0aW9uIGNvbXBhcmVfbmF0X3JlYWwobmF0MSxuYXQyKXtcbiAgcmV0dXJuIGNvbXBhcmVfbmF0KG5hdDEsMCxuYXQxLmRhdGEubGVuZ3RoLG5hdDIsMCxuYXQyLmRhdGEubGVuZ3RoKTtcbn1cblxuLy9Qcm92aWRlczogbGFuZF9kaWdpdF9uYXRcbmZ1bmN0aW9uIGxhbmRfZGlnaXRfbmF0KG5hdDEsIG9mczEsIG5hdDIsIG9mczIpIHtcbiAgbmF0MS5kYXRhW29mczFdICY9IG5hdDIuZGF0YVtvZnMyXTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGxvcl9kaWdpdF9uYXRcbmZ1bmN0aW9uIGxvcl9kaWdpdF9uYXQobmF0MSwgb2ZzMSwgbmF0Miwgb2ZzMikge1xuICBuYXQxLmRhdGFbb2ZzMV0gfD0gbmF0Mi5kYXRhW29mczJdO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogbHhvcl9kaWdpdF9uYXRcbmZ1bmN0aW9uIGx4b3JfZGlnaXRfbmF0KG5hdDEsIG9mczEsIG5hdDIsIG9mczIpIHtcbiAgbmF0MS5kYXRhW29mczFdIF49IG5hdDIuZGF0YVtvZnMyXTtcbiAgcmV0dXJuIDA7XG59XG5cblxuLy9Qcm92aWRlczogc2VyaWFsaXplX25hdFxuZnVuY3Rpb24gc2VyaWFsaXplX25hdCh3cml0ZXIsIG5hdCwgc3ope1xuICB2YXIgbGVuID0gbmF0LmRhdGEubGVuZ3RoO1xuICB3cml0ZXIud3JpdGUoMzIsIGxlbik7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKyl7XG4gICAgd3JpdGVyLndyaXRlKDMyLCBuYXQuZGF0YVtpXSk7XG4gIH1cbiAgc3pbMF0gPSBsZW4gKiA0O1xuICBzelsxXSA9IGxlbiAqIDg7XG59XG5cbi8vUHJvdmlkZXM6IGRlc2VyaWFsaXplX25hdFxuLy9SZXF1aXJlczogTWxOYXRcbmZ1bmN0aW9uIGRlc2VyaWFsaXplX25hdChyZWFkZXIsIHN6KXtcbiAgdmFyIGxlbiA9IHJlYWRlci5yZWFkMzJzKCk7XG4gIHZhciBuYXQgPSBuZXcgTWxOYXQobGVuKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKXtcbiAgICBuYXQuZGF0YVtpXSA9IHJlYWRlci5yZWFkMzJzKCk7XG4gIH1cbiAgc3pbMF0gPSBsZW4gKiA0O1xuICByZXR1cm4gbmF0O1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDE0IEh1Z28gSGV1emFyZFxuXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogY2FtbF9ncl9zdGF0ZVxudmFyIGNhbWxfZ3Jfc3RhdGU7XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlXG4vL1JlcXVpcmVzOiBjYW1sX25hbWVkX3ZhbHVlLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX2dyX3N0YXRlX2dldCgpIHtcbiAgaWYoY2FtbF9ncl9zdGF0ZSkge1xuICAgIHJldHVybiBjYW1sX2dyX3N0YXRlO1xuICB9XG4gIHRocm93IFswLGNhbWxfbmFtZWRfdmFsdWUoXCJHcmFwaGljcy5HcmFwaGljX2ZhaWx1cmVcIiksIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoXCJOb3QgaW5pdGlhbGl6ZWRcIildXG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3N0YXRlX3NldFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZSxjYW1sX2dyX3N0YXRlX2luaXRcbmZ1bmN0aW9uIGNhbWxfZ3Jfc3RhdGVfc2V0KGN0eCkge1xuICBjYW1sX2dyX3N0YXRlPWN0eDtcbiAgY2FtbF9ncl9zdGF0ZV9pbml0KClcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfb3Blbl9ncmFwaFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9jcmVhdGVcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9ncl9vcGVuX2dyYXBoKGluZm8pe1xuICB2YXIgZyA9IGpvb19nbG9iYWxfb2JqZWN0O1xuICB2YXIgaW5mbyA9IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKGluZm8pO1xuICBmdW5jdGlvbiBnZXQobmFtZSl7XG4gICAgdmFyIHJlcyA9IGluZm8ubWF0Y2goXCIoXnwsKSAqXCIrbmFtZStcIiAqPSAqKFthLXpBLVowLTlfXSspICooLHwkKVwiKTtcbiAgICBpZihyZXMpIHJldHVybiByZXNbMl07XG4gIH1cbiAgdmFyIHNwZWNzID0gW107XG4gIGlmKCEoaW5mbz09XCJcIikpIHNwZWNzLnB1c2goaW5mbyk7XG4gIHZhciB0YXJnZXQgPSBnZXQoXCJ0YXJnZXRcIik7XG4gIGlmKCF0YXJnZXQpIHRhcmdldD1cIlwiO1xuICB2YXIgc3RhdHVzID0gZ2V0KFwic3RhdHVzXCIpO1xuICBpZighc3RhdHVzKSBzcGVjcy5wdXNoKFwic3RhdHVzPTFcIilcblxuICB2YXIgdyA9IGdldChcIndpZHRoXCIpO1xuICB3ID0gdz9wYXJzZUludCh3KToyMDA7XG4gIHNwZWNzLnB1c2goXCJ3aWR0aD1cIit3KTtcblxuICB2YXIgaCA9IGdldChcImhlaWdodFwiKTtcbiAgaCA9IGg/cGFyc2VJbnQoaCk6MjAwO1xuICBzcGVjcy5wdXNoKFwiaGVpZ2h0PVwiK2gpO1xuXG4gIHZhciB3aW4gPSBnLm9wZW4oXCJhYm91dDpibGFua1wiLHRhcmdldCxzcGVjcy5qb2luKFwiLFwiKSk7XG4gIGlmKCF3aW4pIHtjYW1sX2ZhaWx3aXRoKFwiR3JhcGhpY3Mub3Blbl9ncmFwaDogY2Fubm90IG9wZW4gdGhlIHdpbmRvd1wiKX1cbiAgdmFyIGRvYyA9IHdpbi5kb2N1bWVudDtcbiAgdmFyIGNhbnZhcyA9IGRvYy5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICBjYW52YXMud2lkdGggPSB3O1xuICBjYW52YXMuaGVpZ2h0ID0gaDtcbiAgdmFyIGN0eCA9IGNhbWxfZ3Jfc3RhdGVfY3JlYXRlKGNhbnZhcyx3LGgpO1xuICBjdHguc2V0X3RpdGxlID0gZnVuY3Rpb24gKHRpdGxlKSB7XG4gICAgZG9jLnRpdGxlID0gdGl0bGU7XG4gIH07XG4gIGNhbWxfZ3Jfc3RhdGVfc2V0KGN0eCk7XG4gIHZhciBib2R5ID0gZG9jLmJvZHk7XG4gIGJvZHkuc3R5bGUubWFyZ2luID0gXCIwcHhcIjtcbiAgYm9keS5hcHBlbmRDaGlsZChjYW52YXMpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9zdGF0ZV9pbml0XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3NldF9jb2xvcixjYW1sX2dyX21vdmV0byxjYW1sX2dyX3Jlc2l6ZV93aW5kb3dcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc2V0X2xpbmVfd2lkdGgsY2FtbF9ncl9zZXRfdGV4dF9zaXplLGNhbWxfZ3Jfc2V0X2ZvbnRcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc2V0X3dpbmRvd190aXRsZVxuZnVuY3Rpb24gY2FtbF9ncl9zdGF0ZV9pbml0KCl7XG4gIGNhbWxfZ3JfbW92ZXRvKGNhbWxfZ3Jfc3RhdGUueCxjYW1sX2dyX3N0YXRlLnkpO1xuICBjYW1sX2dyX3Jlc2l6ZV93aW5kb3coY2FtbF9ncl9zdGF0ZS53aWR0aCxjYW1sX2dyX3N0YXRlLmhlaWdodCk7XG4gIGNhbWxfZ3Jfc2V0X2xpbmVfd2lkdGgoY2FtbF9ncl9zdGF0ZS5saW5lX3dpZHRoKTtcbiAgY2FtbF9ncl9zZXRfdGV4dF9zaXplKGNhbWxfZ3Jfc3RhdGUudGV4dF9zaXplKTtcbiAgY2FtbF9ncl9zZXRfZm9udChjYW1sX2dyX3N0YXRlLmZvbnQpO1xuICBjYW1sX2dyX3NldF9jb2xvcihjYW1sX2dyX3N0YXRlLmNvbG9yKTtcbiAgY2FtbF9ncl9zZXRfd2luZG93X3RpdGxlKGNhbWxfZ3Jfc3RhdGUudGl0bGUpO1xuICAvL2NhbWxfZ3JfcmVzaXplX3dpbmRvdyBtaWdodCByZXNldCBzb21lIGNhbnZhcycgcHJvcGVydGllc1xuICBjYW1sX2dyX3N0YXRlLmNvbnRleHQudGV4dEJhc2VsaW5lID0gJ2JvdHRvbSc7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc3RhdGVfY3JlYXRlXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX2dyX3N0YXRlX2NyZWF0ZShjYW52YXMsdyxoKXtcbiAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICByZXR1cm4ge1xuICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgY2FudmFzIDogY2FudmFzLFxuICAgIHggOiAwLFxuICAgIHkgOiAwLFxuICAgIHdpZHRoIDogdyxcbiAgICBoZWlnaHQgOiBoLFxuICAgIGxpbmVfd2lkdGggOiAxLFxuICAgIGZvbnQgOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKFwiZml4ZWRcIiksXG4gICAgdGV4dF9zaXplIDogMjYsXG4gICAgY29sb3IgOiAweDAwMDAwMCxcbiAgICB0aXRsZSA6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoXCJcIilcbiAgfTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9kb2Nfb2Zfc3RhdGVcbmZ1bmN0aW9uIGNhbWxfZ3JfZG9jX29mX3N0YXRlKHN0YXRlKSB7XG4gIGlmKHN0YXRlLmNhbnZhcy5vd25lckRvY3VtZW50KVxuICAgIHJldHVybiBzdGF0ZS5jYW52YXMub3duZXJEb2N1bWVudDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9jbG9zZV9ncmFwaFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfY2xvc2VfZ3JhcGgoKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLmNhbnZhcy53aWR0aCA9IDA7XG4gIHMuY2FudmFzLmhlaWdodCA9IDA7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3NldF93aW5kb3dfdGl0bGVcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9ncl9zZXRfd2luZG93X3RpdGxlKG5hbWUpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMudGl0bGUgPSBuYW1lO1xuICB2YXIganNuYW1lID0gY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcobmFtZSk7XG4gIGlmKHMuc2V0X3RpdGxlKSBzLnNldF90aXRsZShqc25hbWUpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9yZXNpemVfd2luZG93XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9yZXNpemVfd2luZG93KHcsaCl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKVxuICBzLndpZHRoID0gdztcbiAgcy5oZWlnaHQgPSBoO1xuICBzLmNhbnZhcy53aWR0aCA9IHc7XG4gIHMuY2FudmFzLmhlaWdodCA9IGg7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2NsZWFyX2dyYXBoXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9jbGVhcl9ncmFwaCgpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMuY2FudmFzLndpZHRoID0gcy53aWR0aDtcbiAgcy5jYW52YXMuaGVpZ2h0ID0gcy5oZWlnaHQ7XG4gIC8vICBzLmNvbnRleHQuc3Ryb2tlUmVjdCAoMC4sIDAuLCBzLndpZHRoLCBzLmhlaWdodCk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3NpemVfeFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3Jfc2l6ZV94KCl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcmV0dXJuIHMud2lkdGg7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3NpemVfeVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3Jfc2l6ZV95KCl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcmV0dXJuIHMuaGVpZ2h0O1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc2V0X2NvbG9yXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9zZXRfY29sb3IoY29sb3Ipe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIGZ1bmN0aW9uIGNvbnZlcnQobnVtYmVyKSB7XG4gICAgdmFyIHN0ciA9ICcnICsgbnVtYmVyLnRvU3RyaW5nKDE2KTtcbiAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IDIpIHN0ciA9ICcwJyArIHN0cjtcbiAgICByZXR1cm4gc3RyO1xuICB9XG4gIHZhclxuICByID0gKGNvbG9yID4+IDE2KSAmIDB4ZmYsXG4gIGcgPSAoY29sb3IgPj4gOCkgICYgMHhmZixcbiAgYiA9IChjb2xvciA+PiAwKSAgJiAweGZmO1xuICBzLmNvbG9yPWNvbG9yO1xuICB2YXIgY19zdHIgPSAnIycgKyBjb252ZXJ0KHIpICsgY29udmVydChnKSArIGNvbnZlcnQoYik7XG4gIHMuY29udGV4dC5maWxsU3R5bGUgPSAgIGNfc3RyO1xuICBzLmNvbnRleHQuc3Ryb2tlU3R5bGUgPSBjX3N0cjtcbiAgcmV0dXJuIDA7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3Bsb3Rcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX3Bsb3QoeCx5KXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICB2YXIgaW09cy5jb250ZXh0LmNyZWF0ZUltYWdlRGF0YSgxLDEpO1xuICB2YXIgZCA9IGltLmRhdGE7XG4gIHZhciBjb2xvciA9IHMuY29sb3I7XG4gIGRbMF0gPSAoY29sb3IgPj4gMTYpICYgMHhmZjsgLy9yXG4gIGRbMV0gPSAoY29sb3IgPj4gOCkgICYgMHhmZiwgLy9nXG4gIGRbMl0gPSAoY29sb3IgPj4gMCkgICYgMHhmZjsgLy9iXG4gIGRbM10gPSAweEZGOyAvL2FcbiAgcy54PXg7XG4gIHMueT15O1xuICBzLmNvbnRleHQucHV0SW1hZ2VEYXRhKGltLHgscy5oZWlnaHQgLSB5KTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfcG9pbnRfY29sb3Jcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX3BvaW50X2NvbG9yKHgseSl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgdmFyIGltPXMuY29udGV4dC5nZXRJbWFnZURhdGEoeCxzLmhlaWdodCAtIHksMSwxKTtcbiAgdmFyIGQgPSBpbS5kYXRhO1xuICByZXR1cm4gKGRbMF0gPDwgMTYpICsgKGRbMV0gPDwgOCkgKyBkWzJdO1xufVxuLy9Qcm92aWRlczogY2FtbF9ncl9tb3ZldG9cbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX21vdmV0byh4LHkpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMueD14O1xuICBzLnk9eTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfY3VycmVudF94XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9jdXJyZW50X3goKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICByZXR1cm4gcy54XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2N1cnJlbnRfeVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfY3VycmVudF95KCl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcmV0dXJuIHMueVxufVxuLy9Qcm92aWRlczogY2FtbF9ncl9saW5ldG9cbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2xpbmV0byh4LHkpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMuY29udGV4dC5iZWdpblBhdGgoKTtcbiAgcy5jb250ZXh0Lm1vdmVUbyhzLngscy5oZWlnaHQgLSBzLnkpO1xuICBzLmNvbnRleHQubGluZVRvKHgscy5oZWlnaHQgLSB5KTtcbiAgcy5jb250ZXh0LnN0cm9rZSgpO1xuICBzLng9eDtcbiAgcy55PXk7XG4gIHJldHVybiAwO1xufVxuLy9Qcm92aWRlczogY2FtbF9ncl9kcmF3X3JlY3Rcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2RyYXdfcmVjdCh4LHksdyxoKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLmNvbnRleHQuc3Ryb2tlUmVjdCh4LHMuaGVpZ2h0IC0geSx3LC1oKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfYXJjX2F1eFxuZnVuY3Rpb24gY2FtbF9ncl9hcmNfYXV4KGN0eCxjeCxjeSxyeSxyeCxhMSxhMil7XG4gIHdoaWxlKGExPmEyKSBhMis9MzYwO1xuICBhMSAvPSAxODA7XG4gIGEyIC89IDE4MDtcbiAgdmFyIHJvdCA9IDAseFBvcyx5UG9zLHhQb3NfcHJldix5UG9zX3ByZXY7XG4gIHZhciBzcGFjZSA9IDI7XG4gIHZhciBudW0gPSAoKChhMiAtIGExKSAqIE1hdGguUEkgKiAoKHJ4K3J5KS8yKSkgLyBzcGFjZSkgfCAwO1xuICB2YXIgZGVsdGEgPSAoYTIgLSBhMSkgKiBNYXRoLlBJIC8gbnVtO1xuICB2YXIgaSA9IGExICogTWF0aC5QSTtcbiAgZm9yICh2YXIgaj0wO2o8PW51bTtqKyspe1xuICAgIHhQb3MgPSBjeCAtIChyeCAqIE1hdGguc2luKGkpKSAqIE1hdGguc2luKHJvdCAqIE1hdGguUEkpICsgKHJ5ICogTWF0aC5jb3MoaSkpICogTWF0aC5jb3Mocm90ICogTWF0aC5QSSk7XG4gICAgeFBvcyA9IHhQb3MudG9GaXhlZCgyKTtcbiAgICB5UG9zID0gY3kgKyAocnkgKiBNYXRoLmNvcyhpKSkgKiBNYXRoLnNpbihyb3QgKiBNYXRoLlBJKSArIChyeCAqIE1hdGguc2luKGkpKSAqIE1hdGguY29zKHJvdCAqIE1hdGguUEkpO1xuICAgIHlQb3MgPSB5UG9zLnRvRml4ZWQoMik7XG4gICAgaWYgKGo9PTApIHtcbiAgICAgIGN0eC5tb3ZlVG8oeFBvcywgeVBvcyk7XG4gICAgfSBlbHNlIGlmICh4UG9zX3ByZXYhPXhQb3MgfHwgeVBvc19wcmV2IT15UG9zKXtcbiAgICAgIGN0eC5saW5lVG8oeFBvcywgeVBvcyk7XG4gICAgfVxuICAgIHhQb3NfcHJldj14UG9zO1xuICAgIHlQb3NfcHJldj15UG9zO1xuICAgIGktPSBkZWx0YTsvL2Njd1xuICB9XG4gIHJldHVybiAwO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfZHJhd19hcmNcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0LCBjYW1sX2dyX2FyY19hdXhcbmZ1bmN0aW9uIGNhbWxfZ3JfZHJhd19hcmMoeCx5LHJ4LHJ5LGExLGEyKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLmNvbnRleHQuYmVnaW5QYXRoKCk7XG4gIGNhbWxfZ3JfYXJjX2F1eChzLmNvbnRleHQseCxzLmhlaWdodCAtIHkscngscnksYTEsYTIpO1xuICBzLmNvbnRleHQuc3Ryb2tlKCk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3NldF9saW5lX3dpZHRoXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9zZXRfbGluZV93aWR0aCh3KXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLmxpbmVfd2lkdGggPSB3O1xuICBzLmNvbnRleHQubGluZVdpZHRoID0gd1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9maWxsX3JlY3Rcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2ZpbGxfcmVjdCh4LHksdyxoKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLmNvbnRleHQuZmlsbFJlY3QoeCxzLmhlaWdodCAtIHksdywtaCk7XG4gIHJldHVybiAwO1xufVxuLy9Qcm92aWRlczogY2FtbF9ncl9maWxsX3BvbHlcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2ZpbGxfcG9seShhcil7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy5jb250ZXh0LmJlZ2luUGF0aCgpO1xuICBzLmNvbnRleHQubW92ZVRvKGFyWzFdWzFdLHMuaGVpZ2h0IC0gYXJbMV1bMl0pO1xuICBmb3IodmFyIGkgPSAyOyBpIDwgYXIubGVuZ3RoOyBpKyspXG4gICAgcy5jb250ZXh0LmxpbmVUbyhhcltpXVsxXSxzLmhlaWdodCAtIGFyW2ldWzJdKTtcbiAgcy5jb250ZXh0LmxpbmVUbyhhclsxXVsxXSxzLmhlaWdodCAtIGFyWzFdWzJdKTtcbiAgcy5jb250ZXh0LmZpbGwoKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfZmlsbF9hcmNcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0LCBjYW1sX2dyX2FyY19hdXhcbmZ1bmN0aW9uIGNhbWxfZ3JfZmlsbF9hcmMoeCx5LHJ4LHJ5LGExLGEyKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLmNvbnRleHQuYmVnaW5QYXRoKCk7XG4gIGNhbWxfZ3JfYXJjX2F1eChzLmNvbnRleHQseCxzLmhlaWdodCAtIHkscngscnksYTEsYTIpO1xuICBzLmNvbnRleHQuZmlsbCgpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9kcmF3X3N0clxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfZHJhd19zdHIoc3RyKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICB2YXIgbSA9IHMuY29udGV4dC5tZWFzdXJlVGV4dChzdHIpO1xuICB2YXIgZHggPSBtLndpZHRoO1xuICBzLmNvbnRleHQuZmlsbFRleHQoc3RyLHMueCxzLmhlaWdodCAtIHMueSk7XG4gIHMueCArPSBkeCB8IDA7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2RyYXdfY2hhclxuLy9SZXF1aXJlczogY2FtbF9ncl9kcmF3X3N0clxuZnVuY3Rpb24gY2FtbF9ncl9kcmF3X2NoYXIoYyl7XG4gIGNhbWxfZ3JfZHJhd19zdHIoU3RyaW5nLmZyb21DaGFyQ29kZShjKSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2RyYXdfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2dyX2RyYXdfc3RyXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9ncl9kcmF3X3N0cmluZyhzdHIpe1xuICBjYW1sX2dyX2RyYXdfc3RyKGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHN0cikpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9zZXRfZm9udFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2dyX3NldF9mb250KGYpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMuZm9udCA9IGY7XG4gIHMuY29udGV4dC5mb250ID0gcy50ZXh0X3NpemUgKyBcInB4IFwiICsgY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocy5mb250KTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc2V0X3RleHRfc2l6ZVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2dyX3NldF90ZXh0X3NpemUoc2l6ZSl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy50ZXh0X3NpemUgPSBzaXplO1xuICBzLmNvbnRleHQuZm9udCA9IHMudGV4dF9zaXplICsgXCJweCBcIiArIGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHMuZm9udCk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3RleHRfc2l6ZVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2dyX3RleHRfc2l6ZSh0eHQpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHZhciB3ID0gcy5jb250ZXh0Lm1lYXN1cmVUZXh0KGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHR4dCkpLndpZHRoO1xuICByZXR1cm4gWzAsdyxzLnRleHRfc2l6ZV07XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9ncl9tYWtlX2ltYWdlXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9tYWtlX2ltYWdlKGFycil7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgdmFyIGggPSBhcnIubGVuZ3RoIC0gMSA7XG4gIHZhciB3ID0gYXJyWzFdLmxlbmd0aCAtIDE7XG4gIHZhciBpbSA9IHMuY29udGV4dC5jcmVhdGVJbWFnZURhdGEodyxoKTtcbiAgZm9yKHZhciBpPTA7aTxoO2krKyl7XG4gICAgZm9yKHZhciBqPTA7ajx3O2orKyl7XG4gICAgICB2YXIgYyA9IGFycltpKzFdW2orMV07XG4gICAgICB2YXIgbyA9IGkqKHcqNCkgKyAoaiAqIDQpO1xuICAgICAgaWYoYyA9PSAtMSkge1xuICAgICAgICBpbS5kYXRhW28gKyAwXSA9IDA7XG4gICAgICAgIGltLmRhdGFbbyArIDFdID0gMDtcbiAgICAgICAgaW0uZGF0YVtvICsgMl0gPSAwO1xuICAgICAgICBpbS5kYXRhW28gKyAzXSA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbS5kYXRhW28gKyAwXSA9IGMgPj4gMTYgJiAweGZmO1xuICAgICAgICBpbS5kYXRhW28gKyAxXSA9IGMgPj4gIDggJiAweGZmO1xuICAgICAgICBpbS5kYXRhW28gKyAyXSA9IGMgPj4gIDAgJiAwWGZmO1xuICAgICAgICBpbS5kYXRhW28gKyAzXSA9IDB4ZmY7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBpbVxufVxuLy9Qcm92aWRlczogY2FtbF9ncl9kdW1wX2ltYWdlXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9kdW1wX2ltYWdlKGltKXtcbiAgdmFyIGRhdGEgPSBbMF1cbiAgZm9yKHZhciBpPTA7IGk8aW0uaGVpZ2h0O2krKyl7XG4gICAgZGF0YVtpKzFdID0gWzBdXG4gICAgZm9yKHZhciBqPTA7IGo8aW0ud2lkdGg7aisrKXtcbiAgICAgIHZhciBvID0gaSooaW0ud2lkdGgqNCkgKyAoaiAqIDQpLFxuICAgICAgICAgIHIgPSBpbS5kYXRhW28rMF0sXG4gICAgICAgICAgZyA9IGltLmRhdGFbbysxXSxcbiAgICAgICAgICBiID0gaW0uZGF0YVtvKzJdO1xuICAgICAgZGF0YVtpKzFdW2orMV0gPSAociA8PCAxNikgKyAoZyA8PCA4KSArIGJcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfZHJhd19pbWFnZVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfZHJhd19pbWFnZShpbSx4LHkpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIGlmKCFpbS5pbWFnZSkge1xuICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgIGNhbnZhcy53aWR0aCA9IHMud2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IHMuaGVpZ2h0O1xuICAgIGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIikucHV0SW1hZ2VEYXRhKGltLDAsMCk7XG4gICAgdmFyIGltYWdlID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0LkltYWdlKCk7XG4gICAgaW1hZ2Uub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcy5jb250ZXh0LmRyYXdJbWFnZShpbWFnZSx4LHMuaGVpZ2h0IC0gaW0uaGVpZ2h0IC0geSk7XG4gICAgICBpbS5pbWFnZSA9IGltYWdlO1xuICAgIH1cbiAgICBpbWFnZS5zcmMgPSBjYW52YXMudG9EYXRhVVJMKFwiaW1hZ2UvcG5nXCIpO1xuICB9IGVsc2Uge1xuICAgIHMuY29udGV4dC5kcmF3SW1hZ2UoaW0uaW1hZ2UseCxzLmhlaWdodCAtIGltLmhlaWdodCAtIHkpO1xuICB9XG4gIHJldHVybiAwO1xufVxuLy9Qcm92aWRlczogY2FtbF9ncl9jcmVhdGVfaW1hZ2Vcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2NyZWF0ZV9pbWFnZSh4LHkpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHJldHVybiBzLmNvbnRleHQuY3JlYXRlSW1hZ2VEYXRhKHgseSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2JsaXRfaW1hZ2Vcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2JsaXRfaW1hZ2UoaW0seCx5KXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICB2YXIgaW0yID0gcy5jb250ZXh0LmdldEltYWdlRGF0YSh4LHMuaGVpZ2h0IC0gaW0uaGVpZ2h0IC0geSxpbS53aWR0aCxpbS5oZWlnaHQpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGltMi5kYXRhLmxlbmd0aDsgaSs9NCl7XG4gICAgaW0uZGF0YVtpXSA9IGltMi5kYXRhW2ldO1xuICAgIGltLmRhdGFbaSsxXSA9IGltMi5kYXRhW2krMV07XG4gICAgaW0uZGF0YVtpKzJdID0gaW0yLmRhdGFbaSsyXTtcbiAgICBpbS5kYXRhW2krM10gPSBpbTIuZGF0YVtpKzNdO1xuICB9XG4gIHJldHVybiAwO1xufVxuLy9Qcm92aWRlczogY2FtbF9ncl9zaWdpb19oYW5kbGVyXG5mdW5jdGlvbiBjYW1sX2dyX3NpZ2lvX2hhbmRsZXIoKXtyZXR1cm4gMH1cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc2lnaW9fc2lnbmFsXG5mdW5jdGlvbiBjYW1sX2dyX3NpZ2lvX3NpZ25hbCgpe3JldHVybiAwfVxuLy9Qcm92aWRlczogY2FtbF9ncl93YWl0X2V2ZW50XG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2dyX3dhaXRfZXZlbnQoX2V2bCl7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX2dyX3dhaXRfZXZlbnQgbm90IEltcGxlbWVudGVkOiB1c2UgR3JhcGhpY3NfanMgaW5zdGVhZFwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9zeW5jaHJvbml6ZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9ncl9zeW5jaHJvbml6ZSAoKSB7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX2dyX3N5bmNocm9uaXplIG5vdCBJbXBsZW1lbnRlZFwiKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfcmVtZW1iZXJfbW9kZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9ncl9yZW1lbWJlcl9tb2RlICgpIHtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfZ3JfcmVtZW1iZXJfbW9kZSBub3QgSW1wbGVtZW50ZWRcIik7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2Rpc3BsYXlfbW9kZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9ncl9kaXNwbGF5X21vZGUoKSB7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX2dyX2Rpc3BsYXlfbW9kZSBub3QgSW1wbGVtZW50ZWRcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfd2luZG93X2lkXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2dyX3dpbmRvd19pZChhKSB7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX2dyX3dpbmRvd19pZCBub3QgSW1wbGVtZW50ZWRcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfb3Blbl9zdWJ3aW5kb3dcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfZ3Jfb3Blbl9zdWJ3aW5kb3coYSxiLGMsZCkge1xuICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9ncl9vcGVuX3N1YndpbmRvdyBub3QgSW1wbGVtZW50ZWRcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfY2xvc2Vfc3Vid2luZG93XG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2dyX2Nsb3NlX3N1YndpbmRvdyhhKSB7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX2dyX2Nsb3NlX3N1YndpbmRvdyBub3QgSW1wbGVtZW50ZWRcIik7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogY2FtbF9tYXJzaGFsX2NvbnN0YW50c1xudmFyIGNhbWxfbWFyc2hhbF9jb25zdGFudHMgPSB7XG4gIFBSRUZJWF9TTUFMTF9CTE9DSzogICAgICAgICAweDgwLFxuICBQUkVGSVhfU01BTExfSU5UOiAgICAgICAgICAgMHg0MCxcbiAgUFJFRklYX1NNQUxMX1NUUklORzogICAgICAgIDB4MjAsXG4gIENPREVfSU5UODogICAgICAgICAgICAgICAgICAweDAwLFxuICBDT0RFX0lOVDE2OiAgICAgICAgICAgICAgICAgMHgwMSxcbiAgQ09ERV9JTlQzMjogICAgICAgICAgICAgICAgIDB4MDIsXG4gIENPREVfSU5UNjQ6ICAgICAgICAgICAgICAgICAweDAzLFxuICBDT0RFX1NIQVJFRDg6ICAgICAgICAgICAgICAgMHgwNCxcbiAgQ09ERV9TSEFSRUQxNjogICAgICAgICAgICAgIDB4MDUsXG4gIENPREVfU0hBUkVEMzI6ICAgICAgICAgICAgICAweDA2LFxuICBDT0RFX0JMT0NLMzI6ICAgICAgICAgICAgICAgMHgwOCxcbiAgQ09ERV9CTE9DSzY0OiAgICAgICAgICAgICAgIDB4MTMsXG4gIENPREVfU1RSSU5HODogICAgICAgICAgICAgICAweDA5LFxuICBDT0RFX1NUUklORzMyOiAgICAgICAgICAgICAgMHgwQSxcbiAgQ09ERV9ET1VCTEVfQklHOiAgICAgICAgICAgIDB4MEIsXG4gIENPREVfRE9VQkxFX0xJVFRMRTogICAgICAgICAweDBDLFxuICBDT0RFX0RPVUJMRV9BUlJBWThfQklHOiAgICAgMHgwRCxcbiAgQ09ERV9ET1VCTEVfQVJSQVk4X0xJVFRMRTogIDB4MEUsXG4gIENPREVfRE9VQkxFX0FSUkFZMzJfQklHOiAgICAweDBGLFxuICBDT0RFX0RPVUJMRV9BUlJBWTMyX0xJVFRMRTogMHgwNyxcbiAgQ09ERV9DT0RFUE9JTlRFUjogICAgICAgICAgIDB4MTAsXG4gIENPREVfSU5GSVhQT0lOVEVSOiAgICAgICAgICAweDExLFxuICBDT0RFX0NVU1RPTTogICAgICAgICAgICAgICAgMHgxMixcbiAgQ09ERV9DVVNUT01fTEVOOiAgICAgICAgICAgIDB4MTgsXG4gIENPREVfQ1VTVE9NX0ZJWEVEOiAgICAgICAgICAweDE5XG59XG5cblxuLy9Qcm92aWRlczogTWxTdHJpbmdSZWFkZXJcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMsIGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIE1sU3RyaW5nUmVhZGVyIChzLCBpKSB7IHRoaXMucyA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcocyk7IHRoaXMuaSA9IGk7IH1cbk1sU3RyaW5nUmVhZGVyLnByb3RvdHlwZSA9IHtcbiAgcmVhZDh1OmZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMucy5jaGFyQ29kZUF0KHRoaXMuaSsrKTsgfSxcbiAgcmVhZDhzOmZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMucy5jaGFyQ29kZUF0KHRoaXMuaSsrKSA8PCAyNCA+PiAyNDsgfSxcbiAgcmVhZDE2dTpmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDI7XG4gICAgcmV0dXJuIChzLmNoYXJDb2RlQXQoaSkgPDwgOCkgfCBzLmNoYXJDb2RlQXQoaSArIDEpXG4gIH0sXG4gIHJlYWQxNnM6ZnVuY3Rpb24gKCkge1xuICAgIHZhciBzID0gdGhpcy5zLCBpID0gdGhpcy5pO1xuICAgIHRoaXMuaSA9IGkgKyAyO1xuICAgIHJldHVybiAocy5jaGFyQ29kZUF0KGkpIDw8IDI0ID4+IDE2KSB8IHMuY2hhckNvZGVBdChpICsgMSk7XG4gIH0sXG4gIHJlYWQzMnU6ZnVuY3Rpb24gKCkge1xuICAgIHZhciBzID0gdGhpcy5zLCBpID0gdGhpcy5pO1xuICAgIHRoaXMuaSA9IGkgKyA0O1xuICAgIHJldHVybiAoKHMuY2hhckNvZGVBdChpKSA8PCAyNCkgfCAocy5jaGFyQ29kZUF0KGkrMSkgPDwgMTYpIHxcbiAgICAgICAgICAgIChzLmNoYXJDb2RlQXQoaSsyKSA8PCA4KSB8IHMuY2hhckNvZGVBdChpKzMpKSA+Pj4gMDtcbiAgfSxcbiAgcmVhZDMyczpmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDQ7XG4gICAgcmV0dXJuIChzLmNoYXJDb2RlQXQoaSkgPDwgMjQpIHwgKHMuY2hhckNvZGVBdChpKzEpIDw8IDE2KSB8XG4gICAgICAocy5jaGFyQ29kZUF0KGkrMikgPDwgOCkgfCBzLmNoYXJDb2RlQXQoaSszKTtcbiAgfSxcbiAgcmVhZHN0cjpmdW5jdGlvbiAobGVuKSB7XG4gICAgdmFyIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIGxlbjtcbiAgICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyh0aGlzLnMuc3Vic3RyaW5nKGksIGkgKyBsZW4pKTtcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBCaWdTdHJpbmdSZWFkZXJcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2FycmF5LCBjYW1sX2JhX2dldF8xXG5mdW5jdGlvbiBCaWdTdHJpbmdSZWFkZXIgKGJzLCBpKSB7IHRoaXMucyA9IGJzOyB0aGlzLmkgPSBpOyB9XG5CaWdTdHJpbmdSZWFkZXIucHJvdG90eXBlID0ge1xuICByZWFkOHU6ZnVuY3Rpb24gKCkgeyByZXR1cm4gY2FtbF9iYV9nZXRfMSh0aGlzLnMsdGhpcy5pKyspOyB9LFxuICByZWFkOHM6ZnVuY3Rpb24gKCkgeyByZXR1cm4gY2FtbF9iYV9nZXRfMSh0aGlzLnMsdGhpcy5pKyspIDw8IDI0ID4+IDI0OyB9LFxuICByZWFkMTZ1OmZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IHRoaXMucywgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgMjtcbiAgICByZXR1cm4gKGNhbWxfYmFfZ2V0XzEocyxpKSA8PCA4KSB8IGNhbWxfYmFfZ2V0XzEocyxpICsgMSlcbiAgfSxcbiAgcmVhZDE2czpmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDI7XG4gICAgcmV0dXJuIChjYW1sX2JhX2dldF8xKHMsaSkgPDwgMjQgPj4gMTYpIHwgY2FtbF9iYV9nZXRfMShzLGkgKyAxKTtcbiAgfSxcbiAgcmVhZDMydTpmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDQ7XG4gICAgcmV0dXJuICgoY2FtbF9iYV9nZXRfMShzLGkpICAgPDwgMjQpIHwgKGNhbWxfYmFfZ2V0XzEocyxpKzEpIDw8IDE2KSB8XG4gICAgICAgICAgICAoY2FtbF9iYV9nZXRfMShzLGkrMikgPDwgOCkgIHwgY2FtbF9iYV9nZXRfMShzLGkrMykgICAgICAgICApID4+PiAwO1xuICB9LFxuICByZWFkMzJzOmZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IHRoaXMucywgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgNDtcbiAgICByZXR1cm4gKGNhbWxfYmFfZ2V0XzEocyxpKSAgIDw8IDI0KSB8IChjYW1sX2JhX2dldF8xKHMsaSsxKSA8PCAxNikgfFxuICAgICAgKGNhbWxfYmFfZ2V0XzEocyxpKzIpIDw8IDgpICB8IGNhbWxfYmFfZ2V0XzEocyxpKzMpO1xuICB9LFxuICByZWFkc3RyOmZ1bmN0aW9uIChsZW4pIHtcbiAgICB2YXIgaSA9IHRoaXMuaTtcbiAgICB2YXIgYXJyID0gbmV3IEFycmF5KGxlbilcbiAgICBmb3IodmFyIGogPSAwOyBqIDwgbGVuOyBqKyspe1xuICAgICAgYXJyW2pdID0gY2FtbF9iYV9nZXRfMSh0aGlzLnMsIGkraik7XG4gICAgfVxuICAgIHRoaXMuaSA9IGkgKyBsZW47XG4gICAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2FycmF5KGFycik7XG4gIH1cbn1cblxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfZmxvYXRfb2ZfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cywgY2FtbF9pbnQ2NF9vZl9ieXRlc1xuZnVuY3Rpb24gY2FtbF9mbG9hdF9vZl9ieXRlcyAoYSkge1xuICByZXR1cm4gY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzIChjYW1sX2ludDY0X29mX2J5dGVzIChhKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9zdHJpbmcgbXV0YWJsZVxuLy9SZXF1aXJlczogTWxTdHJpbmdSZWFkZXIsIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9yZWFkZXJcbmZ1bmN0aW9uIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9zdHJpbmcocyxvZnMpIHtcbiAgdmFyIHJlYWRlciA9IG5ldyBNbFN0cmluZ1JlYWRlciAocywgdHlwZW9mIG9mcz09XCJudW1iZXJcIj9vZnM6b2ZzWzBdKTtcbiAgcmV0dXJuIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9yZWFkZXIocmVhZGVyLCBvZnMpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9ieXRlcyBtdXRhYmxlXG4vL1JlcXVpcmVzOiBNbFN0cmluZ1JlYWRlciwgY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3JlYWRlciwgY2FtbF9zdHJpbmdfb2ZfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9ieXRlcyhzLG9mcykge1xuICB2YXIgcmVhZGVyID0gbmV3IE1sU3RyaW5nUmVhZGVyIChjYW1sX3N0cmluZ19vZl9ieXRlcyhzKSwgdHlwZW9mIG9mcz09XCJudW1iZXJcIj9vZnM6b2ZzWzBdKTtcbiAgcmV0dXJuIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9yZWFkZXIocmVhZGVyLCBvZnMpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfdW5tYXJzaGFsXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2ludDY0X3VubWFyc2hhbChyZWFkZXIsIHNpemUpe1xuICB2YXIgdCA9IG5ldyBBcnJheSg4KTs7XG4gIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFtqXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgc2l6ZVswXSA9IDg7XG4gIHJldHVybiBjYW1sX2ludDY0X29mX2J5dGVzICh0KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9tYXJzaGFsXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3RvX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2ludDY0X21hcnNoYWwod3JpdGVyLCB2LCBzaXplcykge1xuICB2YXIgYiA9IGNhbWxfaW50NjRfdG9fYnl0ZXMgKHYpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkrKykgd3JpdGVyLndyaXRlICg4LCBiW2ldKTtcbiAgc2l6ZXNbMF0gPSA4OyBzaXplc1sxXSA9IDg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50MzJfdW5tYXJzaGFsXG5mdW5jdGlvbiBjYW1sX2ludDMyX3VubWFyc2hhbChyZWFkZXIsIHNpemUpe1xuICBzaXplWzBdID0gNDtcbiAgcmV0dXJuIHJlYWRlci5yZWFkMzJzICgpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX25hdGl2ZWludF91bm1hcnNoYWxcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfbmF0aXZlaW50X3VubWFyc2hhbChyZWFkZXIsIHNpemUpe1xuICBzd2l0Y2ggKHJlYWRlci5yZWFkOHUgKCkpIHtcbiAgY2FzZSAxOlxuICAgIHNpemVbMF0gPSA0O1xuICAgIHJldHVybiByZWFkZXIucmVhZDMycyAoKTtcbiAgY2FzZSAyOlxuICAgIGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogbmF0aXZlIGludGVnZXIgdmFsdWUgdG9vIGxhcmdlXCIpO1xuICBkZWZhdWx0OiBjYW1sX2ZhaWx3aXRoKFwiaW5wdXRfdmFsdWU6IGlsbC1mb3JtZWQgbmF0aXZlIGludGVnZXJcIik7XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9jdXN0b21fb3BzXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3VubWFyc2hhbCwgY2FtbF9pbnQ2NF9tYXJzaGFsLCBjYW1sX2ludDY0X2NvbXBhcmUsIGNhbWxfaW50NjRfaGFzaFxuLy9SZXF1aXJlczogY2FtbF9pbnQzMl91bm1hcnNoYWwsIGNhbWxfbmF0aXZlaW50X3VubWFyc2hhbFxuLy9SZXF1aXJlczogY2FtbF9iYV9zZXJpYWxpemUsIGNhbWxfYmFfZGVzZXJpYWxpemUsIGNhbWxfYmFfY29tcGFyZSwgY2FtbF9iYV9oYXNoXG52YXIgY2FtbF9jdXN0b21fb3BzID1cbiAgICB7XCJfalwiOiB7XG4gICAgICBkZXNlcmlhbGl6ZSA6IGNhbWxfaW50NjRfdW5tYXJzaGFsLFxuICAgICAgc2VyaWFsaXplICA6IGNhbWxfaW50NjRfbWFyc2hhbCxcbiAgICAgIGZpeGVkX2xlbmd0aCA6IDgsXG4gICAgICBjb21wYXJlIDogY2FtbF9pbnQ2NF9jb21wYXJlLFxuICAgICAgaGFzaCA6IGNhbWxfaW50NjRfaGFzaFxuICAgIH0sXG4gICAgIFwiX2lcIjoge1xuICAgICAgIGRlc2VyaWFsaXplIDogY2FtbF9pbnQzMl91bm1hcnNoYWwsXG4gICAgICAgZml4ZWRfbGVuZ3RoIDogNCxcbiAgICAgfSxcbiAgICAgXCJfblwiOiB7XG4gICAgICAgZGVzZXJpYWxpemUgOiBjYW1sX25hdGl2ZWludF91bm1hcnNoYWwsXG4gICAgICAgZml4ZWRfbGVuZ3RoIDogNCxcbiAgICAgfSxcbiAgICAgXCJfYmlnYXJyYXlcIjp7XG4gICAgICAgZGVzZXJpYWxpemUgOiAoZnVuY3Rpb24gKHJlYWRlciwgc3opIHtyZXR1cm4gY2FtbF9iYV9kZXNlcmlhbGl6ZSAocmVhZGVyLHN6LFwiX2JpZ2FycmF5XCIpfSksXG4gICAgICAgc2VyaWFsaXplIDogY2FtbF9iYV9zZXJpYWxpemUsXG4gICAgICAgY29tcGFyZSA6IGNhbWxfYmFfY29tcGFyZSxcbiAgICAgICBoYXNoOiBjYW1sX2JhX2hhc2gsXG4gICAgIH0sXG4gICAgIFwiX2JpZ2FycjAyXCI6e1xuICAgICAgIGRlc2VyaWFsaXplIDogKGZ1bmN0aW9uIChyZWFkZXIsIHN6KSB7cmV0dXJuIGNhbWxfYmFfZGVzZXJpYWxpemUgKHJlYWRlcixzeixcIl9iaWdhcnIwMlwiKX0pLFxuICAgICAgIHNlcmlhbGl6ZSA6IGNhbWxfYmFfc2VyaWFsaXplLFxuICAgICAgIGNvbXBhcmUgOiBjYW1sX2JhX2NvbXBhcmUsXG4gICAgICAgaGFzaDogY2FtbF9iYV9oYXNoLFxuICAgICB9XG4gICAgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fcmVhZGVyIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbi8vUmVxdWlyZXM6IGNhbWxfZmxvYXRfb2ZfYnl0ZXMsIGNhbWxfY3VzdG9tX29wc1xuXG5mdW5jdGlvbiBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fcmVhZGVyKHJlYWRlciwgb2ZzKSB7XG4gIHZhciBfbWFnaWMgPSByZWFkZXIucmVhZDMydSAoKVxuICB2YXIgX2Jsb2NrX2xlbiA9IHJlYWRlci5yZWFkMzJ1ICgpO1xuICB2YXIgbnVtX29iamVjdHMgPSByZWFkZXIucmVhZDMydSAoKTtcbiAgdmFyIF9zaXplXzMyID0gcmVhZGVyLnJlYWQzMnUgKCk7XG4gIHZhciBfc2l6ZV82NCA9IHJlYWRlci5yZWFkMzJ1ICgpO1xuICB2YXIgc3RhY2sgPSBbXTtcbiAgdmFyIGludGVybl9vYmpfdGFibGUgPSAobnVtX29iamVjdHMgPiAwKT9bXTpudWxsO1xuICB2YXIgb2JqX2NvdW50ZXIgPSAwO1xuICBmdW5jdGlvbiBpbnRlcm5fcmVjICgpIHtcbiAgICB2YXIgY29kZSA9IHJlYWRlci5yZWFkOHUgKCk7XG4gICAgaWYgKGNvZGUgPj0gMHg0MCAvKmNzdC5QUkVGSVhfU01BTExfSU5UKi8pIHtcbiAgICAgIGlmIChjb2RlID49IDB4ODAgLypjc3QuUFJFRklYX1NNQUxMX0JMT0NLKi8pIHtcbiAgICAgICAgdmFyIHRhZyA9IGNvZGUgJiAweEY7XG4gICAgICAgIHZhciBzaXplID0gKGNvZGUgPj4gNCkgJiAweDc7XG4gICAgICAgIHZhciB2ID0gW3RhZ107XG4gICAgICAgIGlmIChzaXplID09IDApIHJldHVybiB2O1xuICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgIHN0YWNrLnB1c2godiwgc2l6ZSk7XG4gICAgICAgIHJldHVybiB2O1xuICAgICAgfSBlbHNlXG4gICAgICAgIHJldHVybiAoY29kZSAmIDB4M0YpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoY29kZSA+PSAweDIwLypjc3QuUFJFRklYX1NNQUxMX1NUUklORyAqLykge1xuICAgICAgICB2YXIgbGVuID0gY29kZSAmIDB4MUY7XG4gICAgICAgIHZhciB2ID0gcmVhZGVyLnJlYWRzdHIgKGxlbik7XG4gICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzd2l0Y2goY29kZSkge1xuICAgICAgICBjYXNlIDB4MDA6IC8vY3N0LkNPREVfSU5UODpcbiAgICAgICAgICByZXR1cm4gcmVhZGVyLnJlYWQ4cyAoKTtcbiAgICAgICAgY2FzZSAweDAxOiAvL2NzdC5DT0RFX0lOVDE2OlxuICAgICAgICAgIHJldHVybiByZWFkZXIucmVhZDE2cyAoKTtcbiAgICAgICAgY2FzZSAweDAyOiAvL2NzdC5DT0RFX0lOVDMyOlxuICAgICAgICAgIHJldHVybiByZWFkZXIucmVhZDMycyAoKTtcbiAgICAgICAgY2FzZSAweDAzOiAvL2NzdC5DT0RFX0lOVDY0OlxuICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogaW50ZWdlciB0b28gbGFyZ2VcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMHgwNDogLy9jc3QuQ09ERV9TSEFSRUQ4OlxuICAgICAgICAgIHZhciBvZmZzZXQgPSByZWFkZXIucmVhZDh1ICgpO1xuICAgICAgICAgIHJldHVybiBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyIC0gb2Zmc2V0XTtcbiAgICAgICAgY2FzZSAweDA1OiAvL2NzdC5DT0RFX1NIQVJFRDE2OlxuICAgICAgICAgIHZhciBvZmZzZXQgPSByZWFkZXIucmVhZDE2dSAoKTtcbiAgICAgICAgICByZXR1cm4gaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlciAtIG9mZnNldF07XG4gICAgICAgIGNhc2UgMHgwNjogLy9jc3QuQ09ERV9TSEFSRUQzMjpcbiAgICAgICAgICB2YXIgb2Zmc2V0ID0gcmVhZGVyLnJlYWQzMnUgKCk7XG4gICAgICAgICAgcmV0dXJuIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIgLSBvZmZzZXRdO1xuICAgICAgICBjYXNlIDB4MDg6IC8vY3N0LkNPREVfQkxPQ0szMjpcbiAgICAgICAgICB2YXIgaGVhZGVyID0gcmVhZGVyLnJlYWQzMnUgKCk7XG4gICAgICAgICAgdmFyIHRhZyA9IGhlYWRlciAmIDB4RkY7XG4gICAgICAgICAgdmFyIHNpemUgPSBoZWFkZXIgPj4gMTA7XG4gICAgICAgICAgdmFyIHYgPSBbdGFnXTtcbiAgICAgICAgICBpZiAoc2l6ZSA9PSAwKSByZXR1cm4gdjtcbiAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgc3RhY2sucHVzaCh2LCBzaXplKTtcbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgY2FzZSAweDEzOiAvL2NzdC5DT0RFX0JMT0NLNjQ6XG4gICAgICAgICAgY2FtbF9mYWlsd2l0aCAoXCJpbnB1dF92YWx1ZTogZGF0YSBibG9jayB0b28gbGFyZ2VcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMHgwOTogLy9jc3QuQ09ERV9TVFJJTkc4OlxuICAgICAgICAgIHZhciBsZW4gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICAgICAgdmFyIHYgPSByZWFkZXIucmVhZHN0ciAobGVuKTtcbiAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGNhc2UgMHgwQTogLy9jc3QuQ09ERV9TVFJJTkczMjpcbiAgICAgICAgICB2YXIgbGVuID0gcmVhZGVyLnJlYWQzMnUoKTtcbiAgICAgICAgICB2YXIgdiA9IHJlYWRlci5yZWFkc3RyIChsZW4pO1xuICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgY2FzZSAweDBDOiAvL2NzdC5DT0RFX0RPVUJMRV9MSVRUTEU6XG4gICAgICAgICAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7O1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwO2kgPCA4O2krKykgdFs3IC0gaV0gPSByZWFkZXIucmVhZDh1ICgpO1xuICAgICAgICAgIHZhciB2ID0gY2FtbF9mbG9hdF9vZl9ieXRlcyAodCk7XG4gICAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjYXNlIDB4MEI6IC8vY3N0LkNPREVfRE9VQkxFX0JJRzpcbiAgICAgICAgICB2YXIgdCA9IG5ldyBBcnJheSg4KTs7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7aSA8IDg7aSsrKSB0W2ldID0gcmVhZGVyLnJlYWQ4dSAoKTtcbiAgICAgICAgICB2YXIgdiA9IGNhbWxfZmxvYXRfb2ZfYnl0ZXMgKHQpO1xuICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgY2FzZSAweDBFOiAvL2NzdC5DT0RFX0RPVUJMRV9BUlJBWThfTElUVExFOlxuICAgICAgICAgIHZhciBsZW4gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICAgICAgdmFyIHYgPSBuZXcgQXJyYXkobGVuKzEpO1xuICAgICAgICAgIHZbMF0gPSAyNTQ7XG4gICAgICAgICAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7O1xuICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMTtpIDw9IGxlbjtpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFs3IC0gal0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICAgICAgICB2W2ldID0gY2FtbF9mbG9hdF9vZl9ieXRlcyAodCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjYXNlIDB4MEQ6IC8vY3N0LkNPREVfRE9VQkxFX0FSUkFZOF9CSUc6XG4gICAgICAgICAgdmFyIGxlbiA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgICAgICB2YXIgdiA9IG5ldyBBcnJheShsZW4rMSk7XG4gICAgICAgICAgdlswXSA9IDI1NDtcbiAgICAgICAgICB2YXIgdCA9IG5ldyBBcnJheSg4KTs7XG4gICAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICAgIGZvciAodmFyIGkgPSAxO2kgPD0gbGVuO2krKykge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7aiA8IDg7aisrKSB0W2pdID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgICAgICAgdiBbaV0gPSBjYW1sX2Zsb2F0X29mX2J5dGVzICh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGNhc2UgMHgwNzogLy9jc3QuQ09ERV9ET1VCTEVfQVJSQVkzMl9MSVRUTEU6XG4gICAgICAgICAgdmFyIGxlbiA9IHJlYWRlci5yZWFkMzJ1KCk7XG4gICAgICAgICAgdmFyIHYgPSBuZXcgQXJyYXkobGVuKzEpO1xuICAgICAgICAgIHZbMF0gPSAyNTQ7XG4gICAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICAgIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgICAgICAgICBmb3IgKHZhciBpID0gMTtpIDw9IGxlbjtpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFs3IC0gal0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICAgICAgICB2W2ldID0gY2FtbF9mbG9hdF9vZl9ieXRlcyAodCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjYXNlIDB4MEY6IC8vY3N0LkNPREVfRE9VQkxFX0FSUkFZMzJfQklHOlxuICAgICAgICAgIHZhciBsZW4gPSByZWFkZXIucmVhZDMydSgpO1xuICAgICAgICAgIHZhciB2ID0gbmV3IEFycmF5KGxlbisxKTtcbiAgICAgICAgICB2WzBdID0gMjU0O1xuICAgICAgICAgIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgICAgICAgICBmb3IgKHZhciBpID0gMTtpIDw9IGxlbjtpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFtqXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgICAgICAgIHYgW2ldID0gY2FtbF9mbG9hdF9vZl9ieXRlcyAodCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjYXNlIDB4MTA6IC8vY3N0LkNPREVfQ09ERVBPSU5URVI6XG4gICAgICAgIGNhc2UgMHgxMTogLy9jc3QuQ09ERV9JTkZJWFBPSU5URVI6XG4gICAgICAgICAgY2FtbF9mYWlsd2l0aCAoXCJpbnB1dF92YWx1ZTogY29kZSBwb2ludGVyXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDB4MTI6IC8vY3N0LkNPREVfQ1VTVE9NOlxuICAgICAgICBjYXNlIDB4MTg6IC8vY3N0LkNPREVfQ1VTVE9NX0xFTjpcbiAgICAgICAgY2FzZSAweDE5OiAvL2NzdC5DT0RFX0NVU1RPTV9GSVhFRDpcbiAgICAgICAgICB2YXIgYywgcyA9IFwiXCI7XG4gICAgICAgICAgd2hpbGUgKChjID0gcmVhZGVyLnJlYWQ4dSAoKSkgIT0gMCkgcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlIChjKTtcbiAgICAgICAgICB2YXIgb3BzID0gY2FtbF9jdXN0b21fb3BzW3NdO1xuICAgICAgICAgIHZhciBleHBlY3RlZF9zaXplO1xuICAgICAgICAgIGlmKCFvcHMpXG4gICAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwiaW5wdXRfdmFsdWU6IHVua25vd24gY3VzdG9tIGJsb2NrIGlkZW50aWZpZXJcIik7XG4gICAgICAgICAgc3dpdGNoKGNvZGUpe1xuICAgICAgICAgIGNhc2UgMHgxMjogLy8gY3N0LkNPREVfQ1VTVE9NIChkZXByZWNhdGVkKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAweDE5OiAvLyBjc3QuQ09ERV9DVVNUT01fRklYRURcbiAgICAgICAgICAgIGlmKCFvcHMuZml4ZWRfbGVuZ3RoKVxuICAgICAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwiaW5wdXRfdmFsdWU6IGV4cGVjdGVkIGEgZml4ZWQtc2l6ZSBjdXN0b20gYmxvY2tcIik7XG4gICAgICAgICAgICBleHBlY3RlZF9zaXplID0gb3BzLmZpeGVkX2xlbmd0aDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMHgxODogLy8gY3N0LkNPREVfQ1VTVE9NX0xFTlxuICAgICAgICAgICAgZXhwZWN0ZWRfc2l6ZSA9IHJlYWRlci5yZWFkMzJ1ICgpO1xuICAgICAgICAgICAgLy8gU2tpcCBzaXplNjRcbiAgICAgICAgICAgIHJlYWRlci5yZWFkMzJzKCk7IHJlYWRlci5yZWFkMzJzKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG9sZF9wb3MgPSByZWFkZXIuaTtcbiAgICAgICAgICB2YXIgc2l6ZSA9IFswXTtcbiAgICAgICAgICB2YXIgdiA9IG9wcy5kZXNlcmlhbGl6ZShyZWFkZXIsIHNpemUpO1xuICAgICAgICAgIGlmKGV4cGVjdGVkX3NpemUgIT0gdW5kZWZpbmVkKXtcbiAgICAgICAgICAgIGlmKGV4cGVjdGVkX3NpemUgIT0gc2l6ZVswXSlcbiAgICAgICAgICAgICAgY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiBpbmNvcnJlY3QgbGVuZ3RoIG9mIHNlcmlhbGl6ZWQgY3VzdG9tIGJsb2NrXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgY2FtbF9mYWlsd2l0aCAoXCJpbnB1dF92YWx1ZTogaWxsLWZvcm1lZCBtZXNzYWdlXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHZhciByZXMgPSBpbnRlcm5fcmVjICgpO1xuICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgIHZhciBzaXplID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIHYgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgZCA9IHYubGVuZ3RoO1xuICAgIGlmIChkIDwgc2l6ZSkgc3RhY2sucHVzaCh2LCBzaXplKTtcbiAgICB2W2RdID0gaW50ZXJuX3JlYyAoKTtcbiAgfVxuICBpZiAodHlwZW9mIG9mcyE9XCJudW1iZXJcIikgb2ZzWzBdID0gcmVhZGVyLmk7XG4gIHJldHVybiByZXM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWFyc2hhbF9kYXRhX3NpemUgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aCwgY2FtbF9ieXRlc191bnNhZmVfZ2V0XG5mdW5jdGlvbiBjYW1sX21hcnNoYWxfZGF0YV9zaXplIChzLCBvZnMpIHtcbiAgZnVuY3Rpb24gZ2V0MzIocyxpKSB7XG4gICAgcmV0dXJuIChjYW1sX2J5dGVzX3Vuc2FmZV9nZXQocywgaSkgPDwgMjQpIHxcbiAgICAgIChjYW1sX2J5dGVzX3Vuc2FmZV9nZXQocywgaSArIDEpIDw8IDE2KSB8XG4gICAgICAoY2FtbF9ieXRlc191bnNhZmVfZ2V0KHMsIGkgKyAyKSA8PCA4KSB8XG4gICAgICBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQocywgaSArIDMpO1xuICB9XG4gIGlmIChnZXQzMihzLCBvZnMpICE9ICgweDg0OTVBNkJFfDApKVxuICAgIGNhbWxfZmFpbHdpdGgoXCJNYXJzaGFsLmRhdGFfc2l6ZTogYmFkIG9iamVjdFwiKTtcbiAgcmV0dXJuIChnZXQzMihzLCBvZnMgKyA0KSk7XG59XG5cbi8vUHJvdmlkZXM6IE1sT2JqZWN0VGFibGVcbnZhciBNbE9iamVjdFRhYmxlO1xuaWYgKHR5cGVvZiBqb29fZ2xvYmFsX29iamVjdC5XZWFrTWFwID09PSAndW5kZWZpbmVkJykge1xuICBNbE9iamVjdFRhYmxlID0gZnVuY3Rpb24oKSB7XG4gICAgLyogcG9seWZpbGwgKHVzaW5nIGxpbmVhciBzZWFyY2gpICovXG4gICAgZnVuY3Rpb24gTmFpdmVMb29rdXAob2JqcykgeyB0aGlzLm9ianMgPSBvYmpzOyB9XG4gICAgTmFpdmVMb29rdXAucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5vYmpzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzLm9ianNbaV0gPT09IHYpIHJldHVybiBpO1xuICAgICAgfVxuICAgIH07XG4gICAgTmFpdmVMb29rdXAucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gRG8gbm90aGluZyBoZXJlLiBbTWxPYmplY3RUYWJsZS5zdG9yZV0gd2lsbCBwdXNoIHRvIFt0aGlzLm9ianNdIGRpcmVjdGx5LlxuICAgIH07XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gTWxPYmplY3RUYWJsZSgpIHtcbiAgICAgIHRoaXMub2JqcyA9IFtdOyB0aGlzLmxvb2t1cCA9IG5ldyBOYWl2ZUxvb2t1cCh0aGlzLm9ianMpO1xuICAgIH07XG4gIH0oKTtcbn1cbmVsc2Uge1xuICBNbE9iamVjdFRhYmxlID0gZnVuY3Rpb24gTWxPYmplY3RUYWJsZSgpIHtcbiAgICB0aGlzLm9ianMgPSBbXTsgdGhpcy5sb29rdXAgPSBuZXcgam9vX2dsb2JhbF9vYmplY3QuV2Vha01hcCgpO1xuICB9O1xufVxuXG5NbE9iamVjdFRhYmxlLnByb3RvdHlwZS5zdG9yZSA9IGZ1bmN0aW9uKHYpIHtcbiAgdGhpcy5sb29rdXAuc2V0KHYsIHRoaXMub2Jqcy5sZW5ndGgpO1xuICB0aGlzLm9ianMucHVzaCh2KTtcbn1cblxuTWxPYmplY3RUYWJsZS5wcm90b3R5cGUucmVjYWxsID0gZnVuY3Rpb24odikge1xuICB2YXIgaSA9IHRoaXMubG9va3VwLmdldCh2KTtcbiAgcmV0dXJuIChpID09PSB1bmRlZmluZWQpXG4gICAgPyB1bmRlZmluZWQgOiB0aGlzLm9ianMubGVuZ3RoIC0gaTsgICAvKiBpbmRleCBpcyByZWxhdGl2ZSAqL1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2xlZ2FjeV9jdXN0b21fY29kZVxuLy9WZXJzaW9uOiA+PSA0LjA4XG52YXIgY2FtbF9sZWdhY3lfY3VzdG9tX2NvZGUgPSBmYWxzZVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2xlZ2FjeV9jdXN0b21fY29kZVxuLy9WZXJzaW9uOiA8IDQuMDhcbnZhciBjYW1sX2xlZ2FjeV9jdXN0b21fY29kZSA9IHRydWVcblxuLy9Qcm92aWRlczogY2FtbF9vdXRwdXRfdmFsXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3RvX2J5dGVzLCBjYW1sX2ZhaWx3aXRoXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXRcbi8vUmVxdWlyZXM6IGNhbWxfaXNfbWxfYnl0ZXMsIGNhbWxfbWxfYnl0ZXNfbGVuZ3RoLCBjYW1sX2J5dGVzX3Vuc2FmZV9nZXRcbi8vUmVxdWlyZXM6IGNhbWxfaXNfbWxfc3RyaW5nLCBjYW1sX21sX3N0cmluZ19sZW5ndGgsIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXRcbi8vUmVxdWlyZXM6IE1sT2JqZWN0VGFibGUsIGNhbWxfbGlzdF90b19qc19hcnJheSwgY2FtbF9sZWdhY3lfY3VzdG9tX2NvZGUsIGNhbWxfY3VzdG9tX29wc1xuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50LGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbnZhciBjYW1sX291dHB1dF92YWwgPSBmdW5jdGlvbiAoKXtcbiAgZnVuY3Rpb24gV3JpdGVyICgpIHsgdGhpcy5jaHVuayA9IFtdOyB9XG4gIFdyaXRlci5wcm90b3R5cGUgPSB7XG4gICAgY2h1bmtfaWR4OjIwLCBibG9ja19sZW46MCwgb2JqX2NvdW50ZXI6MCwgc2l6ZV8zMjowLCBzaXplXzY0OjAsXG4gICAgd3JpdGU6ZnVuY3Rpb24gKHNpemUsIHZhbHVlKSB7XG4gICAgICBmb3IgKHZhciBpID0gc2l6ZSAtIDg7aSA+PSAwO2kgLT0gOClcbiAgICAgICAgdGhpcy5jaHVua1t0aGlzLmNodW5rX2lkeCsrXSA9ICh2YWx1ZSA+PiBpKSAmIDB4RkY7XG4gICAgfSxcbiAgICB3cml0ZV9hdDpmdW5jdGlvbiAocG9zLCBzaXplLCB2YWx1ZSkge1xuICAgICAgdmFyIHBvcyA9IHBvcztcbiAgICAgIGZvciAodmFyIGkgPSBzaXplIC0gODtpID49IDA7aSAtPSA4KVxuICAgICAgICB0aGlzLmNodW5rW3BvcysrXSA9ICh2YWx1ZSA+PiBpKSAmIDB4RkY7XG4gICAgfSxcbiAgICB3cml0ZV9jb2RlOmZ1bmN0aW9uIChzaXplLCBjb2RlLCB2YWx1ZSkge1xuICAgICAgdGhpcy5jaHVua1t0aGlzLmNodW5rX2lkeCsrXSA9IGNvZGU7XG4gICAgICBmb3IgKHZhciBpID0gc2l6ZSAtIDg7aSA+PSAwO2kgLT0gOClcbiAgICAgICAgdGhpcy5jaHVua1t0aGlzLmNodW5rX2lkeCsrXSA9ICh2YWx1ZSA+PiBpKSAmIDB4RkY7XG4gICAgfSxcbiAgICB3cml0ZV9zaGFyZWQ6ZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgaWYgKG9mZnNldCA8ICgxIDw8IDgpKSB0aGlzLndyaXRlX2NvZGUoOCwgMHgwNCAvKmNzdC5DT0RFX1NIQVJFRDgqLywgb2Zmc2V0KTtcbiAgICAgIGVsc2UgaWYgKG9mZnNldCA8ICgxIDw8IDE2KSkgdGhpcy53cml0ZV9jb2RlKDE2LCAweDA1IC8qY3N0LkNPREVfU0hBUkVEMTYqLywgb2Zmc2V0KTtcbiAgICAgIGVsc2UgdGhpcy53cml0ZV9jb2RlKDMyLCAweDA2IC8qY3N0LkNPREVfU0hBUkVEMzIqLywgb2Zmc2V0KTtcbiAgICB9LFxuICAgIHBvczpmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmNodW5rX2lkeCB9LFxuICAgIGZpbmFsaXplOmZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuYmxvY2tfbGVuID0gdGhpcy5jaHVua19pZHggLSAyMDtcbiAgICAgIHRoaXMuY2h1bmtfaWR4ID0gMDtcbiAgICAgIHRoaXMud3JpdGUgKDMyLCAweDg0OTVBNkJFKTtcbiAgICAgIHRoaXMud3JpdGUgKDMyLCB0aGlzLmJsb2NrX2xlbik7XG4gICAgICB0aGlzLndyaXRlICgzMiwgdGhpcy5vYmpfY291bnRlcik7XG4gICAgICB0aGlzLndyaXRlICgzMiwgdGhpcy5zaXplXzMyKTtcbiAgICAgIHRoaXMud3JpdGUgKDMyLCB0aGlzLnNpemVfNjQpO1xuICAgICAgcmV0dXJuIHRoaXMuY2h1bms7XG4gICAgfVxuICB9XG4gIHJldHVybiBmdW5jdGlvbiAodiwgZmxhZ3MpIHtcbiAgICBmbGFncyA9IGNhbWxfbGlzdF90b19qc19hcnJheShmbGFncyk7XG5cbiAgICB2YXIgbm9fc2hhcmluZyA9IChmbGFncy5pbmRleE9mKDAgLypNYXJzaGFsLk5vX3NoYXJpbmcqLykgIT09IC0xKSxcbiAgICAgICAgY2xvc3VyZXMgPSAgKGZsYWdzLmluZGV4T2YoMSAvKk1hcnNoYWwuQ2xvc3VyZXMqLykgIT09IC0xKTtcbiAgICAgICAgLyogTWFyc2hhbC5Db21wYXRfMzIgaXMgcmVkdW5kYW50IHNpbmNlIGludGVnZXJzIGFyZSAzMi1iaXQgYW55d2F5ICovXG5cbiAgICBpZiAoY2xvc3VyZXMpXG4gICAgICBqb29fZ2xvYmFsX29iamVjdC5jb25zb2xlLndhcm4oXCJpbiBjYW1sX291dHB1dF92YWw6IGZsYWcgTWFyc2hhbC5DbG9zdXJlcyBpcyBub3Qgc3VwcG9ydGVkLlwiKTtcblxuICAgIHZhciB3cml0ZXIgPSBuZXcgV3JpdGVyICgpO1xuICAgIHZhciBzdGFjayA9IFtdO1xuICAgIHZhciBpbnRlcm5fb2JqX3RhYmxlID0gbm9fc2hhcmluZyA/IG51bGwgOiBuZXcgTWxPYmplY3RUYWJsZSgpO1xuXG4gICAgZnVuY3Rpb24gbWVtbyh2KSB7XG4gICAgICBpZiAobm9fc2hhcmluZykgcmV0dXJuIGZhbHNlO1xuICAgICAgdmFyIGV4aXN0aW5nX29mZnNldCA9IGludGVybl9vYmpfdGFibGUucmVjYWxsKHYpO1xuICAgICAgaWYgKGV4aXN0aW5nX29mZnNldCkgeyB3cml0ZXIud3JpdGVfc2hhcmVkKGV4aXN0aW5nX29mZnNldCk7IHJldHVybiB0cnVlOyB9XG4gICAgICBlbHNlIHsgaW50ZXJuX29ial90YWJsZS5zdG9yZSh2KTsgcmV0dXJuIGZhbHNlOyB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXh0ZXJuX3JlYyAodikge1xuICAgICAgaWYgKHYuY2FtbF9jdXN0b20pIHtcbiAgICAgICAgaWYgKG1lbW8odikpIHJldHVybjtcbiAgICAgICAgdmFyIG5hbWUgPSB2LmNhbWxfY3VzdG9tO1xuICAgICAgICB2YXIgb3BzID0gY2FtbF9jdXN0b21fb3BzW25hbWVdO1xuICAgICAgICB2YXIgc3pfMzJfNjQgPSBbMCwwXTtcbiAgICAgICAgaWYoIW9wcy5zZXJpYWxpemUpXG4gICAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwib3V0cHV0X3ZhbHVlOiBhYnN0cmFjdCB2YWx1ZSAoQ3VzdG9tKVwiKTtcbiAgICAgICAgaWYoY2FtbF9sZWdhY3lfY3VzdG9tX2NvZGUpIHtcbiAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIDB4MTIgLypjc3QuQ09ERV9DVVNUT00qLyk7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgd3JpdGVyLndyaXRlICg4LCBuYW1lLmNoYXJDb2RlQXQoaSkpO1xuICAgICAgICAgIHdyaXRlci53cml0ZSg4LCAwKTtcbiAgICAgICAgICBvcHMuc2VyaWFsaXplKHdyaXRlciwgdiwgc3pfMzJfNjQpO1xuICAgICAgICB9IGVsc2UgaWYob3BzLmZpeGVkX2xlbmd0aCA9PSB1bmRlZmluZWQpe1xuICAgICAgICAgIHdyaXRlci53cml0ZSAoOCwgMHgxOCAvKmNzdC5DT0RFX0NVU1RPTV9MRU4qLyk7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgd3JpdGVyLndyaXRlICg4LCBuYW1lLmNoYXJDb2RlQXQoaSkpO1xuICAgICAgICAgIHdyaXRlci53cml0ZSg4LCAwKTtcbiAgICAgICAgICB2YXIgaGVhZGVyX3BvcyA9IHdyaXRlci5wb3MgKCk7XG4gICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgIHdyaXRlci53cml0ZSg4LCAwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3BzLnNlcmlhbGl6ZSh3cml0ZXIsIHYsIHN6XzMyXzY0KTtcbiAgICAgICAgICB3cml0ZXIud3JpdGVfYXQoaGVhZGVyX3BvcywgMzIsIHN6XzMyXzY0WzBdKTtcbiAgICAgICAgICB3cml0ZXIud3JpdGVfYXQoaGVhZGVyX3BvcyArIDQsIDMyLCAwKTsgLy8gemVyb1xuICAgICAgICAgIHdyaXRlci53cml0ZV9hdChoZWFkZXJfcG9zICsgOCwgMzIsIHN6XzMyXzY0WzFdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIDB4MTkgLypjc3QuQ09ERV9DVVNUT01fRklYRUQqLyk7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgd3JpdGVyLndyaXRlICg4LCBuYW1lLmNoYXJDb2RlQXQoaSkpO1xuICAgICAgICAgIHdyaXRlci53cml0ZSg4LCAwKTtcbiAgICAgICAgICB2YXIgb2xkX3BvcyA9IHdyaXRlci5wb3MoKTtcbiAgICAgICAgICBvcHMuc2VyaWFsaXplKHdyaXRlciwgdiwgc3pfMzJfNjQpO1xuICAgICAgICAgIGlmIChvcHMuZml4ZWRfbGVuZ3RoICE9IHdyaXRlci5wb3MoKSAtIG9sZF9wb3MpXG4gICAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwib3V0cHV0X3ZhbHVlOiBpbmNvcnJlY3QgZml4ZWQgc2l6ZXMgc3BlY2lmaWVkIGJ5IFwiICsgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgd3JpdGVyLnNpemVfMzIgKz0gMiArICgoc3pfMzJfNjRbMF0gKyAzKSA+PiAyKTtcbiAgICAgICAgd3JpdGVyLnNpemVfNjQgKz0gMiArICgoc3pfMzJfNjRbMV0gKyA3KSA+PiAzKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHYgaW5zdGFuY2VvZiBBcnJheSAmJiB2WzBdID09PSAodlswXXwwKSkge1xuICAgICAgICBpZiAodlswXSA9PSAyNTEpIHtcbiAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwib3V0cHV0X3ZhbHVlOiBhYnN0cmFjdCB2YWx1ZSAoQWJzdHJhY3QpXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2Lmxlbmd0aCA+IDEgJiYgbWVtbyh2KSkgcmV0dXJuO1xuICAgICAgICBpZiAodlswXSA8IDE2ICYmIHYubGVuZ3RoIC0gMSA8IDgpXG4gICAgICAgICAgd3JpdGVyLndyaXRlICg4LCAweDgwIC8qY3N0LlBSRUZJWF9TTUFMTF9CTE9DSyovICsgdlswXSArICgodi5sZW5ndGggLSAxKTw8NCkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgd3JpdGVyLndyaXRlX2NvZGUoMzIsIDB4MDggLypjc3QuQ09ERV9CTE9DSzMyKi8sICgodi5sZW5ndGgtMSkgPDwgMTApIHwgdlswXSk7XG4gICAgICAgIHdyaXRlci5zaXplXzMyICs9IHYubGVuZ3RoO1xuICAgICAgICB3cml0ZXIuc2l6ZV82NCArPSB2Lmxlbmd0aDtcbiAgICAgICAgaWYgKHYubGVuZ3RoID4gMSkgc3RhY2sucHVzaCAodiwgMSk7XG4gICAgICB9IGVsc2UgaWYgKGNhbWxfaXNfbWxfYnl0ZXModikpIHtcbiAgICAgICAgaWYoIShjYW1sX2lzX21sX2J5dGVzKGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoXCJcIikpKSkge1xuICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJvdXRwdXRfdmFsdWU6IFtCeXRlcy50XSBjYW5ub3Qgc2FmZWx5IGJlIG1hcnNoYWxlZCB3aXRoIFstLWVuYWJsZSB1c2UtanMtc3RyaW5nXVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVtbyh2KSkgcmV0dXJuO1xuICAgICAgICB2YXIgbGVuID0gY2FtbF9tbF9ieXRlc19sZW5ndGgodik7XG4gICAgICAgIGlmIChsZW4gPCAweDIwKVxuICAgICAgICAgIHdyaXRlci53cml0ZSAoOCwgMHgyMCAvKmNzdC5QUkVGSVhfU01BTExfU1RSSU5HKi8gKyBsZW4pO1xuICAgICAgICBlbHNlIGlmIChsZW4gPCAweDEwMClcbiAgICAgICAgICB3cml0ZXIud3JpdGVfY29kZSAoOCwgMHgwOS8qY3N0LkNPREVfU1RSSU5HOCovLCBsZW4pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgd3JpdGVyLndyaXRlX2NvZGUgKDMyLCAweDBBIC8qY3N0LkNPREVfU1RSSU5HMzIqLywgbGVuKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7aSA8IGxlbjtpKyspXG4gICAgICAgICAgd3JpdGVyLndyaXRlICg4LCBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQodixpKSk7XG4gICAgICAgIHdyaXRlci5zaXplXzMyICs9IDEgKyAoKChsZW4gKyA0KSAvIDQpfDApO1xuICAgICAgICB3cml0ZXIuc2l6ZV82NCArPSAxICsgKCgobGVuICsgOCkgLyA4KXwwKTtcbiAgICAgIH0gZWxzZSBpZiAoY2FtbF9pc19tbF9zdHJpbmcodikpIHtcbiAgICAgICAgdmFyIGxlbiA9IGNhbWxfbWxfc3RyaW5nX2xlbmd0aCh2KTtcbiAgICAgICAgaWYgKGxlbiA8IDB4MjApXG4gICAgICAgICAgd3JpdGVyLndyaXRlICg4LCAweDIwIC8qY3N0LlBSRUZJWF9TTUFMTF9TVFJJTkcqLyArIGxlbik7XG4gICAgICAgIGVsc2UgaWYgKGxlbiA8IDB4MTAwKVxuICAgICAgICAgIHdyaXRlci53cml0ZV9jb2RlICg4LCAweDA5Lypjc3QuQ09ERV9TVFJJTkc4Ki8sIGxlbik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB3cml0ZXIud3JpdGVfY29kZSAoMzIsIDB4MEEgLypjc3QuQ09ERV9TVFJJTkczMiovLCBsZW4pO1xuICAgICAgICBmb3IgKHZhciBpID0gMDtpIDwgbGVuO2krKylcbiAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQodixpKSk7XG4gICAgICAgIHdyaXRlci5zaXplXzMyICs9IDEgKyAoKChsZW4gKyA0KSAvIDQpfDApO1xuICAgICAgICB3cml0ZXIuc2l6ZV82NCArPSAxICsgKCgobGVuICsgOCkgLyA4KXwwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh2ICE9ICh2fDApKXtcbiAgICAgICAgICB2YXIgdHlwZV9vZl92ID0gdHlwZW9mIHY7XG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBJZiBhIGZsb2F0IGhhcHBlbnMgdG8gYmUgYW4gaW50ZWdlciBpdCBpcyBzZXJpYWxpemVkIGFzIGFuIGludGVnZXJcbiAgICAgICAgICAvLyAoSnNfb2Zfb2NhbWwgY2Fubm90IHRlbGwgd2hldGhlciB0aGUgdHlwZSBvZiBhbiBpbnRlZ2VyIG51bWJlciBpc1xuICAgICAgICAgIC8vIGZsb2F0IG9yIGludGVnZXIuKSBUaGlzIGNhbiByZXN1bHQgaW4gdW5leHBlY3RlZCBjcmFzaGVzIHdoZW5cbiAgICAgICAgICAvLyB1bm1hcnNoYWxsaW5nIHVzaW5nIHRoZSBzdGFuZGFyZCBydW50aW1lLiBJdCBzZWVtcyBiZXR0ZXIgdG9cbiAgICAgICAgICAvLyBzeXN0ZW1hdGljYWxseSBmYWlsIG9uIG1hcnNoYWxsaW5nLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gICAgICAgICAgaWYodHlwZV9vZl92ICE9IFwibnVtYmVyXCIpXG4gICAgICAgICAgY2FtbF9mYWlsd2l0aChcIm91dHB1dF92YWx1ZTogYWJzdHJhY3QgdmFsdWUgKFwiK3R5cGVfb2ZfditcIilcIik7XG4gICAgICAgICAgLy8gICAgICAgICAgdmFyIHQgPSBjYW1sX2ludDY0X3RvX2J5dGVzKGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCh2KSk7XG4gICAgICAgICAgLy8gICAgICAgICAgd3JpdGVyLndyaXRlICg4LCAweDBCIC8qY3N0LkNPREVfRE9VQkxFX0JJRyovKTtcbiAgICAgICAgICAvLyAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpPDg7IGkrKyl7d3JpdGVyLndyaXRlKDgsdFtpXSl9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodiA+PSAwICYmIHYgPCAweDQwKSB7XG4gICAgICAgICAgd3JpdGVyLndyaXRlICg4LCAwWDQwIC8qY3N0LlBSRUZJWF9TTUFMTF9JTlQqLyArIHYpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh2ID49IC0oMSA8PCA3KSAmJiB2IDwgKDEgPDwgNykpXG4gICAgICAgICAgICB3cml0ZXIud3JpdGVfY29kZSg4LCAweDAwIC8qY3N0LkNPREVfSU5UOCovLCB2KTtcbiAgICAgICAgICBlbHNlIGlmICh2ID49IC0oMSA8PCAxNSkgJiYgdiA8ICgxIDw8IDE1KSlcbiAgICAgICAgICAgIHdyaXRlci53cml0ZV9jb2RlKDE2LCAweDAxIC8qY3N0LkNPREVfSU5UMTYqLywgdik7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgd3JpdGVyLndyaXRlX2NvZGUoMzIsIDB4MDIgLypjc3QuQ09ERV9JTlQzMiovLCB2KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBleHRlcm5fcmVjICh2KTtcbiAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgdmFyIGkgPSBzdGFjay5wb3AgKCk7XG4gICAgICB2YXIgdiA9IHN0YWNrLnBvcCAoKTtcbiAgICAgIGlmIChpICsgMSA8IHYubGVuZ3RoKSBzdGFjay5wdXNoICh2LCBpICsgMSk7XG4gICAgICBleHRlcm5fcmVjICh2W2ldKTtcbiAgICB9XG4gICAgaWYgKGludGVybl9vYmpfdGFibGUpIHdyaXRlci5vYmpfY291bnRlciA9IGludGVybl9vYmpfdGFibGUub2Jqcy5sZW5ndGg7XG4gICAgd3JpdGVyLmZpbmFsaXplKCk7XG4gICAgcmV0dXJuIHdyaXRlci5jaHVuaztcbiAgfVxufSAoKTtcblxuLy9Qcm92aWRlczogY2FtbF9vdXRwdXRfdmFsdWVfdG9fc3RyaW5nIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfb3V0cHV0X3ZhbCwgY2FtbF9zdHJpbmdfb2ZfYXJyYXlcbmZ1bmN0aW9uIGNhbWxfb3V0cHV0X3ZhbHVlX3RvX3N0cmluZyAodiwgZmxhZ3MpIHtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2FycmF5IChjYW1sX291dHB1dF92YWwgKHYsIGZsYWdzKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb3V0cHV0X3ZhbHVlX3RvX2J5dGVzIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfb3V0cHV0X3ZhbCwgY2FtbF9ieXRlc19vZl9hcnJheVxuZnVuY3Rpb24gY2FtbF9vdXRwdXRfdmFsdWVfdG9fYnl0ZXMgKHYsIGZsYWdzKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX29mX2FycmF5IChjYW1sX291dHB1dF92YWwgKHYsIGZsYWdzKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb3V0cHV0X3ZhbHVlX3RvX2J1ZmZlclxuLy9SZXF1aXJlczogY2FtbF9vdXRwdXRfdmFsLCBjYW1sX2ZhaWx3aXRoLCBjYW1sX2JsaXRfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfb3V0cHV0X3ZhbHVlX3RvX2J1ZmZlciAocywgb2ZzLCBsZW4sIHYsIGZsYWdzKSB7XG4gIHZhciB0ID0gY2FtbF9vdXRwdXRfdmFsICh2LCBmbGFncyk7XG4gIGlmICh0Lmxlbmd0aCA+IGxlbikgY2FtbF9mYWlsd2l0aCAoXCJNYXJzaGFsLnRvX2J1ZmZlcjogYnVmZmVyIG92ZXJmbG93XCIpO1xuICBjYW1sX2JsaXRfYnl0ZXModCwgMCwgcywgb2ZzLCB0Lmxlbmd0aCk7XG4gIHJldHVybiAwO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDE0IErDqXLDtG1lIFZvdWlsbG9uLCBIdWdvIEhldXphcmRcbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8vLy8vLy8vLy8vLyBJb1xuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jbG9zZVxuLy9SZXF1aXJlczogY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9zeXNfY2xvc2UoZmQpIHtcbiAgZGVsZXRlIGNhbWxfZ2xvYmFsX2RhdGEuZmRzW2ZkXTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RkX291dHB1dFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlcywgY2FtbF9tbF9zdHJpbmdfbGVuZ3RoLCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX3N0ZF9vdXRwdXQoY2hhbmlkLHMpe1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgdmFyIHN0ciA9IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMocyk7XG4gIHZhciBzbGVuID0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHN0cik7XG4gIGNoYW4uZmlsZS53cml0ZShjaGFuLm9mZnNldCwgc3RyLCAwLCBzbGVuKTtcbiAgY2hhbi5vZmZzZXQgKz0gc2xlbjtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX29wZW5cbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfc3lzX2Vycm9yLCBjYW1sX2dsb2JhbF9kYXRhXG4vL1JlcXVpcmVzOiBjYW1sX2NyZWF0ZV9ieXRlcyxNbEZha2VGaWxlXG4vL1JlcXVpcmVzOiBqc19wcmludF9zdGRlcnIsIGpzX3ByaW50X3N0ZG91dFxuLy9SZXF1aXJlczogY2FtbF9zdGRfb3V0cHV0XG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZVxuLy9SZXF1aXJlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9zeXNfb3Blbl9pbnRlcm5hbChpZHgsb3V0cHV0LGZpbGUsZmxhZ3MpIHtcbiAgaWYoY2FtbF9nbG9iYWxfZGF0YS5mZHMgPT09IHVuZGVmaW5lZCkgY2FtbF9nbG9iYWxfZGF0YS5mZHMgPSBuZXcgQXJyYXkoKTtcbiAgZmxhZ3M9ZmxhZ3M/ZmxhZ3M6e307XG4gIHZhciBpbmZvID0ge307XG4gIGluZm8uZmlsZSA9IGZpbGU7XG4gIGluZm8ub2Zmc2V0ID0gZmxhZ3MuYXBwZW5kP2ZpbGUubGVuZ3RoKCk6MDtcbiAgaW5mby5mbGFncyA9IGZsYWdzO1xuICBpbmZvLm91dHB1dCA9IG91dHB1dDtcbiAgY2FtbF9nbG9iYWxfZGF0YS5mZHNbaWR4XSA9IGluZm87XG4gIGlmKCFjYW1sX2dsb2JhbF9kYXRhLmZkX2xhc3RfaWR4IHx8IGlkeCA+IGNhbWxfZ2xvYmFsX2RhdGEuZmRfbGFzdF9pZHgpXG4gICAgY2FtbF9nbG9iYWxfZGF0YS5mZF9sYXN0X2lkeCA9IGlkeDtcbiAgcmV0dXJuIGlkeDtcbn1cbmZ1bmN0aW9uIGNhbWxfc3lzX29wZW4gKG5hbWUsIGZsYWdzLCBfcGVybXMpIHtcbiAgdmFyIGYgPSB7fTtcbiAgd2hpbGUoZmxhZ3Mpe1xuICAgIHN3aXRjaChmbGFnc1sxXSl7XG4gICAgY2FzZSAwOiBmLnJkb25seSA9IDE7YnJlYWs7XG4gICAgY2FzZSAxOiBmLndyb25seSA9IDE7YnJlYWs7XG4gICAgY2FzZSAyOiBmLmFwcGVuZCA9IDE7YnJlYWs7XG4gICAgY2FzZSAzOiBmLmNyZWF0ZSA9IDE7YnJlYWs7XG4gICAgY2FzZSA0OiBmLnRydW5jYXRlID0gMTticmVhaztcbiAgICBjYXNlIDU6IGYuZXhjbCA9IDE7IGJyZWFrO1xuICAgIGNhc2UgNjogZi5iaW5hcnkgPSAxO2JyZWFrO1xuICAgIGNhc2UgNzogZi50ZXh0ID0gMTticmVhaztcbiAgICBjYXNlIDg6IGYubm9uYmxvY2sgPSAxO2JyZWFrO1xuICAgIH1cbiAgICBmbGFncz1mbGFnc1syXTtcbiAgfVxuICBpZihmLnJkb25seSAmJiBmLndyb25seSlcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKG5hbWUpICsgXCIgOiBmbGFncyBPcGVuX3Jkb25seSBhbmQgT3Blbl93cm9ubHkgYXJlIG5vdCBjb21wYXRpYmxlXCIpO1xuICBpZihmLnRleHQgJiYgZi5iaW5hcnkpXG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoY2FtbF9qc2J5dGVzX29mX3N0cmluZyhuYW1lKSArIFwiIDogZmxhZ3MgT3Blbl90ZXh0IGFuZCBPcGVuX2JpbmFyeSBhcmUgbm90IGNvbXBhdGlibGVcIik7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIHZhciBmaWxlID0gcm9vdC5kZXZpY2Uub3Blbihyb290LnJlc3QsZik7XG4gIHZhciBpZHggPSBjYW1sX2dsb2JhbF9kYXRhLmZkX2xhc3RfaWR4P2NhbWxfZ2xvYmFsX2RhdGEuZmRfbGFzdF9pZHg6MDtcbiAgcmV0dXJuIGNhbWxfc3lzX29wZW5faW50ZXJuYWwgKGlkeCsxLGNhbWxfc3RkX291dHB1dCxmaWxlLGYpO1xufVxuY2FtbF9zeXNfb3Blbl9pbnRlcm5hbCgwLGNhbWxfc3RkX291dHB1dCwgbmV3IE1sRmFrZUZpbGUoY2FtbF9jcmVhdGVfYnl0ZXMoMCkpKTsgLy9zdGRpblxuY2FtbF9zeXNfb3Blbl9pbnRlcm5hbCgxLGpzX3ByaW50X3N0ZG91dCwgbmV3IE1sRmFrZUZpbGUoY2FtbF9jcmVhdGVfYnl0ZXMoMCkpKTsgLy9zdGRvdXRcbmNhbWxfc3lzX29wZW5faW50ZXJuYWwoMixqc19wcmludF9zdGRlcnIsIG5ldyBNbEZha2VGaWxlKGNhbWxfY3JlYXRlX2J5dGVzKDApKSk7IC8vc3RkZXJyXG5cblxuLy8gb2NhbWwgQ2hhbm5lbHNcblxuLy9Qcm92aWRlczogY2FtbF9tbF9zZXRfY2hhbm5lbF9uYW1lXG5mdW5jdGlvbiBjYW1sX21sX3NldF9jaGFubmVsX25hbWUoKSB7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfY2hhbm5lbHNcbnZhciBjYW1sX21sX2NoYW5uZWxzID0gbmV3IEFycmF5KCk7XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfb3V0X2NoYW5uZWxzX2xpc3Rcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfb3V0X2NoYW5uZWxzX2xpc3QgKCkge1xuICB2YXIgbCA9IDA7XG4gIGZvcih2YXIgYyA9IDA7IGMgPCBjYW1sX21sX2NoYW5uZWxzLmxlbmd0aDsgYysrKXtcbiAgICBpZihjYW1sX21sX2NoYW5uZWxzW2NdICYmIGNhbWxfbWxfY2hhbm5lbHNbY10ub3BlbmVkICYmIGNhbWxfbWxfY2hhbm5lbHNbY10ub3V0KVxuICAgICAgbD1bMCxjYW1sX21sX2NoYW5uZWxzW2NdLmZkLGxdO1xuICB9XG4gIHJldHVybiBsO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX291dFxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVscywgY2FtbF9nbG9iYWxfZGF0YVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXNfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX291dCAoZmQpIHtcbiAgdmFyIGRhdGEgPSBjYW1sX2dsb2JhbF9kYXRhLmZkc1tmZF07XG4gIGlmKGRhdGEuZmxhZ3MucmRvbmx5KSBjYW1sX3JhaXNlX3N5c19lcnJvcihcImZkIFwiKyBmZCArIFwiIGlzIHJlYWRvbmx5XCIpO1xuICB2YXIgY2hhbm5lbCA9IHtcbiAgICBmaWxlOmRhdGEuZmlsZSxcbiAgICBvZmZzZXQ6ZGF0YS5vZmZzZXQsXG4gICAgZmQ6ZmQsXG4gICAgb3BlbmVkOnRydWUsXG4gICAgb3V0OnRydWUsXG4gICAgYnVmZmVyOlwiXCJcbiAgfTtcbiAgY2FtbF9tbF9jaGFubmVsc1tjaGFubmVsLmZkXT1jaGFubmVsO1xuICByZXR1cm4gY2hhbm5lbC5mZDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3JfaW5cbi8vUmVxdWlyZXM6IGNhbWxfZ2xvYmFsX2RhdGEsY2FtbF9zeXNfb3BlbixjYW1sX3JhaXNlX3N5c19lcnJvciwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3JfaW4gKGZkKSAge1xuICB2YXIgZGF0YSA9IGNhbWxfZ2xvYmFsX2RhdGEuZmRzW2ZkXTtcbiAgaWYoZGF0YS5mbGFncy53cm9ubHkpIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKFwiZmQgXCIrIGZkICsgXCIgaXMgd3JpdGVvbmx5XCIpO1xuXG4gIHZhciBjaGFubmVsID0ge1xuICAgIGZpbGU6ZGF0YS5maWxlLFxuICAgIG9mZnNldDpkYXRhLm9mZnNldCxcbiAgICBmZDpmZCxcbiAgICBvcGVuZWQ6dHJ1ZSxcbiAgICBvdXQ6IGZhbHNlLFxuICAgIHJlZmlsbDpudWxsXG4gIH07XG4gIGNhbWxfbWxfY2hhbm5lbHNbY2hhbm5lbC5mZF09Y2hhbm5lbDtcbiAgcmV0dXJuIGNoYW5uZWwuZmQ7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9jaGFubmVsX2Rlc2NyaXB0b3Jcbi8vUmVxdWlyZXM6IGNhbWxfZ2xvYmFsX2RhdGEsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfY2hhbm5lbF9kZXNjcmlwdG9yKGNoYW5pZCl7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICByZXR1cm4gY2hhbi5mZDtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3NldF9iaW5hcnlfbW9kZVxuLy9SZXF1aXJlczogY2FtbF9nbG9iYWxfZGF0YSwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9zZXRfYmluYXJ5X21vZGUoY2hhbmlkLG1vZGUpe1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgdmFyIGRhdGEgPSBjYW1sX2dsb2JhbF9kYXRhLmZkc1tjaGFuLmZkXTtcbiAgZGF0YS5mbGFncy50ZXh0ID0gIW1vZGVcbiAgZGF0YS5mbGFncy5iaW5hcnkgPSBtb2RlXG4gIHJldHVybiAwO1xufVxuXG4vL0lucHV0IGZyb20gaW5fY2hhbm5lbFxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2Nsb3NlX2NoYW5uZWxcbi8vUmVxdWlyZXM6IGNhbWxfbWxfZmx1c2gsIGNhbWxfbWxfY2hhbm5lbHNcbi8vUmVxdWlyZXM6IGNhbWxfc3lzX2Nsb3NlXG5mdW5jdGlvbiBjYW1sX21sX2Nsb3NlX2NoYW5uZWwgKGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgY2FtbF9tbF9mbHVzaChjaGFuaWQpO1xuICBjaGFuLm9wZW5lZCA9IGZhbHNlO1xuICBjaGFuLmZpbGUuY2xvc2UoKTtcbiAgY2FtbF9zeXNfY2xvc2UoY2hhbi5mZClcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfY2hhbm5lbF9zaXplXG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX2NoYW5uZWxfc2l6ZShjaGFuaWQpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIHJldHVybiBjaGFuLmZpbGUubGVuZ3RoKCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfY2hhbm5lbF9zaXplXzY0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2Zsb2F0LGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfY2hhbm5lbF9zaXplXzY0KGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgcmV0dXJuIGNhbWxfaW50NjRfb2ZfZmxvYXQoY2hhbi5maWxlLmxlbmd0aCAoKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2V0X2NoYW5uZWxfb3V0cHV0XG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxzLCBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX21sX3NldF9jaGFubmVsX291dHB1dChjaGFuaWQsZikge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgY2FtbF9nbG9iYWxfZGF0YS5mZHNbY2hhbi5mZF0ub3V0cHV0ID0gZjtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2V0X2NoYW5uZWxfcmVmaWxsXG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxzLCBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX21sX3NldF9jaGFubmVsX3JlZmlsbChjaGFuaWQsZikge1xuICBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF0ucmVmaWxsID0gZjtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfcmVmaWxsX2lucHV0XG4vL1JlcXVpcmVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfbWxfcmVmaWxsX2lucHV0IChjaGFuKSB7XG4gIHZhciBzdHIgPSBjaGFuLnJlZmlsbCgpO1xuICB2YXIgc3RyX2xlbiA9IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzdHIpO1xuICBpZiAoc3RyX2xlbiA9PSAwKSBjaGFuLnJlZmlsbCA9IG51bGw7XG4gIGNoYW4uZmlsZS53cml0ZShjaGFuLmZpbGUubGVuZ3RoKCksIHN0ciwgMCwgc3RyX2xlbik7XG4gIHJldHVybiBzdHJfbGVuO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX21heV9yZWZpbGxfaW5wdXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfcmVmaWxsX2lucHV0LCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX21heV9yZWZpbGxfaW5wdXQgKGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgaWYgKGNoYW4ucmVmaWxsID09IG51bGwpIHJldHVybjtcbiAgaWYgKGNoYW4uZmlsZS5sZW5ndGgoKSAhPSBjaGFuLm9mZnNldCkgcmV0dXJuO1xuICBjYW1sX21sX3JlZmlsbF9pbnB1dCAoY2hhbik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfaW5wdXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfcmVmaWxsX2lucHV0LCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX2lucHV0IChjaGFuaWQsIHMsIGksIGwpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIHZhciBsMiA9IGNoYW4uZmlsZS5sZW5ndGgoKSAtIGNoYW4ub2Zmc2V0O1xuICBpZiAobDIgPT0gMCAmJiBjaGFuLnJlZmlsbCAhPSBudWxsKSBsMiA9IGNhbWxfbWxfcmVmaWxsX2lucHV0KGNoYW4pO1xuICBpZiAobDIgPCBsKSBsID0gbDI7XG4gIGNoYW4uZmlsZS5yZWFkKGNoYW4ub2Zmc2V0LCBzLCBpLCBsKTtcbiAgY2hhbi5vZmZzZXQgKz0gbDtcbiAgcmV0dXJuIGw7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW5wdXRfdmFsdWVcbi8vUmVxdWlyZXM6IGNhbWxfbWFyc2hhbF9kYXRhX3NpemUsIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9ieXRlcywgY2FtbF9jcmVhdGVfYnl0ZXMsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfaW5wdXRfdmFsdWUgKGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcblxuICB2YXIgYnVmID0gY2FtbF9jcmVhdGVfYnl0ZXMoOCk7XG4gIGNoYW4uZmlsZS5yZWFkKGNoYW4ub2Zmc2V0LGJ1ZiwwLDgpO1xuXG4gIC8vIEhlYWRlciBpcyAyMCBieXRlc1xuICB2YXIgbGVuID0gY2FtbF9tYXJzaGFsX2RhdGFfc2l6ZSAoYnVmLCAwKSArIDIwO1xuXG4gIHZhciBidWYgPSBjYW1sX2NyZWF0ZV9ieXRlcyhsZW4pO1xuICBjaGFuLmZpbGUucmVhZChjaGFuLm9mZnNldCxidWYsMCxsZW4pO1xuXG4gIHZhciBvZmZzZXQgPSBbMF07XG4gIHZhciByZXMgPSBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fYnl0ZXMoYnVmLCBvZmZzZXQpO1xuICBjaGFuLm9mZnNldCA9IGNoYW4ub2Zmc2V0ICsgb2Zmc2V0WzBdO1xuICByZXR1cm4gcmVzO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2lucHV0X2NoYXJcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2VfZW5kX29mX2ZpbGUsIGNhbWxfYXJyYXlfYm91bmRfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfbWxfbWF5X3JlZmlsbF9pbnB1dCwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9pbnB1dF9jaGFyIChjaGFuaWQpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIGNhbWxfbWxfbWF5X3JlZmlsbF9pbnB1dChjaGFuaWQpO1xuICBpZiAoY2hhbi5vZmZzZXQgPj0gY2hhbi5maWxlLmxlbmd0aCgpKVxuICAgIGNhbWxfcmFpc2VfZW5kX29mX2ZpbGUoKTtcbiAgdmFyIHJlcyA9IGNoYW4uZmlsZS5yZWFkX29uZShjaGFuLm9mZnNldCk7XG4gIGNoYW4ub2Zmc2V0Kys7XG4gIHJldHVybiByZXM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfaW5wdXRfaW50XG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX2VuZF9vZl9maWxlXG4vL1JlcXVpcmVzOiBjYW1sX21sX3JlZmlsbF9pbnB1dCwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9pbnB1dF9pbnQgKGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgdmFyIGZpbGUgPSBjaGFuLmZpbGU7XG4gIHdoaWxlICgoY2hhbi5vZmZzZXQgKyAzKSA+PSBmaWxlLmxlbmd0aCgpKSB7XG4gICAgdmFyIGwgPSBjYW1sX21sX3JlZmlsbF9pbnB1dChjaGFuKTtcbiAgICBpZiAobCA9PSAwKSBjYW1sX3JhaXNlX2VuZF9vZl9maWxlKCk7XG4gIH1cbiAgdmFyIG8gPSBjaGFuLm9mZnNldDtcbiAgdmFyIHIgPShmaWxlLnJlYWRfb25lKG8gICkgPDwgMjQpXG4gICAgICB8ICAoZmlsZS5yZWFkX29uZShvKzEpIDw8IDE2KVxuICAgICAgfCAgKGZpbGUucmVhZF9vbmUobysyKSA8PCA4KVxuICAgICAgfCAgKGZpbGUucmVhZF9vbmUobyszKSk7XG4gIGNoYW4ub2Zmc2V0Kz00O1xuICByZXR1cm4gcjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9zZWVrX2luXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3N5c19lcnJvciwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9zZWVrX2luKGNoYW5pZCxwb3Mpe1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgaWYgKGNoYW4ucmVmaWxsICE9IG51bGwpIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKFwiSWxsZWdhbCBzZWVrXCIpO1xuICBjaGFuLm9mZnNldCA9IHBvcztcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2Vla19pbl82NFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF90b19mbG9hdCwgY2FtbF9yYWlzZV9zeXNfZXJyb3IsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfc2Vla19pbl82NChjaGFuaWQscG9zKXtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIGlmIChjaGFuLnJlZmlsbCAhPSBudWxsKSBjYW1sX3JhaXNlX3N5c19lcnJvcihcIklsbGVnYWwgc2Vla1wiKTtcbiAgY2hhbi5vZmZzZXQgPSBjYW1sX2ludDY0X3RvX2Zsb2F0KHBvcyk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3Bvc19pblxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9wb3NfaW4oY2hhbmlkKSB7cmV0dXJuIGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXS5vZmZzZXR9XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfcG9zX2luXzY0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2Zsb2F0LCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX3Bvc19pbl82NChjaGFuaWQpIHtyZXR1cm4gY2FtbF9pbnQ2NF9vZl9mbG9hdChjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF0ub2Zmc2V0KX1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9pbnB1dF9zY2FuX2xpbmVcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfbWxfbWF5X3JlZmlsbF9pbnB1dCwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9pbnB1dF9zY2FuX2xpbmUoY2hhbmlkKXtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIGNhbWxfbWxfbWF5X3JlZmlsbF9pbnB1dChjaGFuaWQpO1xuICB2YXIgcCA9IGNoYW4ub2Zmc2V0O1xuICB2YXIgbGVuID0gY2hhbi5maWxlLmxlbmd0aCgpO1xuICBpZihwID49IGxlbikgeyByZXR1cm4gMDt9XG4gIHdoaWxlKHRydWUpIHtcbiAgICBpZihwID49IGxlbikgcmV0dXJuIC0gKHAgLSBjaGFuLm9mZnNldCk7XG4gICAgaWYoY2hhbi5maWxlLnJlYWRfb25lKHApID09IDEwKSByZXR1cm4gcCAtIGNoYW4ub2Zmc2V0ICsgMTtcbiAgICBwKys7XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9mbHVzaFxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXNfZXJyb3IsIGNhbWxfZ2xvYmFsX2RhdGEsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfZmx1c2ggKGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgaWYoISBjaGFuLm9wZW5lZCkgY2FtbF9yYWlzZV9zeXNfZXJyb3IoXCJDYW5ub3QgZmx1c2ggYSBjbG9zZWQgY2hhbm5lbFwiKTtcbiAgaWYoIWNoYW4uYnVmZmVyIHx8IGNoYW4uYnVmZmVyID09IFwiXCIpIHJldHVybiAwO1xuICBpZihjaGFuLmZkXG4gICAgICYmIGNhbWxfZ2xvYmFsX2RhdGEuZmRzW2NoYW4uZmRdXG4gICAgICYmIGNhbWxfZ2xvYmFsX2RhdGEuZmRzW2NoYW4uZmRdLm91dHB1dCkge1xuICAgIHZhciBvdXRwdXQgPSBjYW1sX2dsb2JhbF9kYXRhLmZkc1tjaGFuLmZkXS5vdXRwdXQ7XG4gICAgc3dpdGNoKG91dHB1dC5sZW5ndGgpe1xuICAgIGNhc2UgMjogb3V0cHV0KGNoYW5pZCxjaGFuLmJ1ZmZlcik7YnJlYWs7XG4gICAgZGVmYXVsdDogb3V0cHV0KGNoYW4uYnVmZmVyKVxuICAgIH07XG4gIH1cbiAgY2hhbi5idWZmZXIgPSBcIlwiO1xuICByZXR1cm4gMDtcbn1cblxuLy9vdXRwdXQgdG8gb3V0X2NoYW5uZWxcblxuLy9Qcm92aWRlczogY2FtbF9tbF9vdXRwdXRfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfbWxfZmx1c2gsY2FtbF9tbF9ieXRlc19sZW5ndGhcbi8vUmVxdWlyZXM6IGNhbWxfY3JlYXRlX2J5dGVzLCBjYW1sX2JsaXRfYnl0ZXMsIGNhbWxfcmFpc2Vfc3lzX2Vycm9yLCBjYW1sX21sX2NoYW5uZWxzLCBjYW1sX3N0cmluZ19vZl9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9tbF9vdXRwdXRfYnl0ZXMoY2hhbmlkLGJ1ZmZlcixvZmZzZXQsbGVuKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICBpZighIGNoYW4ub3BlbmVkKSBjYW1sX3JhaXNlX3N5c19lcnJvcihcIkNhbm5vdCBvdXRwdXQgdG8gYSBjbG9zZWQgY2hhbm5lbFwiKTtcbiAgdmFyIGJ5dGVzO1xuICBpZihvZmZzZXQgPT0gMCAmJiBjYW1sX21sX2J5dGVzX2xlbmd0aChidWZmZXIpID09IGxlbilcbiAgICBieXRlcyA9IGJ1ZmZlcjtcbiAgZWxzZSB7XG4gICAgYnl0ZXMgPSBjYW1sX2NyZWF0ZV9ieXRlcyhsZW4pO1xuICAgIGNhbWxfYmxpdF9ieXRlcyhidWZmZXIsb2Zmc2V0LGJ5dGVzLDAsbGVuKTtcbiAgfVxuICB2YXIgc3RyaW5nID0gY2FtbF9zdHJpbmdfb2ZfYnl0ZXMoYnl0ZXMpO1xuICB2YXIganNzdHJpbmcgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKHN0cmluZyk7XG4gIHZhciBpZCA9IGpzc3RyaW5nLmxhc3RJbmRleE9mKFwiXFxuXCIpO1xuICBpZihpZCA8IDApXG4gICAgY2hhbi5idWZmZXIrPWpzc3RyaW5nO1xuICBlbHNlIHtcbiAgICBjaGFuLmJ1ZmZlcis9anNzdHJpbmcuc3Vic3RyKDAsaWQrMSk7XG4gICAgY2FtbF9tbF9mbHVzaCAoY2hhbmlkKTtcbiAgICBjaGFuLmJ1ZmZlciArPSBqc3N0cmluZy5zdWJzdHIoaWQrMSk7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfb3V0cHV0XG4vL1JlcXVpcmVzOiBjYW1sX21sX291dHB1dF9ieXRlcywgY2FtbF9ieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfbWxfb3V0cHV0KGNoYW5pZCxidWZmZXIsb2Zmc2V0LGxlbil7XG4gIHJldHVybiBjYW1sX21sX291dHB1dF9ieXRlcyhjaGFuaWQsY2FtbF9ieXRlc19vZl9zdHJpbmcoYnVmZmVyKSxvZmZzZXQsbGVuKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9vdXRwdXRfY2hhclxuLy9SZXF1aXJlczogY2FtbF9tbF9vdXRwdXRcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfbWxfb3V0cHV0X2NoYXIgKGNoYW5pZCxjKSB7XG4gIHZhciBzID0gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhTdHJpbmcuZnJvbUNoYXJDb2RlKGMpKTtcbiAgY2FtbF9tbF9vdXRwdXQoY2hhbmlkLHMsMCwxKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb3V0cHV0X3ZhbHVlXG4vL1JlcXVpcmVzOiBjYW1sX291dHB1dF92YWx1ZV90b19zdHJpbmcsIGNhbWxfbWxfb3V0cHV0LGNhbWxfbWxfc3RyaW5nX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9vdXRwdXRfdmFsdWUgKGNoYW5pZCx2LGZsYWdzKSB7XG4gIHZhciBzID0gY2FtbF9vdXRwdXRfdmFsdWVfdG9fc3RyaW5nKHYsIGZsYWdzKTtcbiAgY2FtbF9tbF9vdXRwdXQoY2hhbmlkLHMsMCxjYW1sX21sX3N0cmluZ19sZW5ndGgocykpO1xuICByZXR1cm4gMDtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3NlZWtfb3V0XG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxzLCBjYW1sX21sX2ZsdXNoXG5mdW5jdGlvbiBjYW1sX21sX3NlZWtfb3V0KGNoYW5pZCxwb3Mpe1xuICBjYW1sX21sX2ZsdXNoKGNoYW5pZCk7XG4gIGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXS5vZmZzZXQgPSBwb3M7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3NlZWtfb3V0XzY0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3RvX2Zsb2F0LCBjYW1sX21sX2NoYW5uZWxzLCBjYW1sX21sX2ZsdXNoXG5mdW5jdGlvbiBjYW1sX21sX3NlZWtfb3V0XzY0KGNoYW5pZCxwb3Mpe1xuICBjYW1sX21sX2ZsdXNoKGNoYW5pZCk7XG4gIGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXS5vZmZzZXQgPSBjYW1sX2ludDY0X3RvX2Zsb2F0KHBvcyk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3Bvc19vdXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbHMsIGNhbWxfbWxfZmx1c2hcbmZ1bmN0aW9uIGNhbWxfbWxfcG9zX291dChjaGFuaWQpIHtcbiAgY2FtbF9tbF9mbHVzaChjaGFuaWQpO1xuICByZXR1cm4gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdLm9mZnNldFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3Bvc19vdXRfNjRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfZmxvYXQsIGNhbWxfbWxfY2hhbm5lbHMsIGNhbWxfbWxfZmx1c2hcbmZ1bmN0aW9uIGNhbWxfbWxfcG9zX291dF82NChjaGFuaWQpIHtcbiAgY2FtbF9tbF9mbHVzaChjaGFuaWQpO1xuICByZXR1cm4gY2FtbF9pbnQ2NF9vZl9mbG9hdCAoY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdLm9mZnNldCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfb3V0cHV0X2ludFxuLy9SZXF1aXJlczogY2FtbF9tbF9vdXRwdXRcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2FycmF5XG5mdW5jdGlvbiBjYW1sX21sX291dHB1dF9pbnQgKGNoYW5pZCxpKSB7XG4gIHZhciBhcnIgPSBbKGk+PjI0KSAmIDB4RkYsKGk+PjE2KSAmIDB4RkYsKGk+PjgpICYgMHhGRixpICYgMHhGRiBdO1xuICB2YXIgcyA9IGNhbWxfc3RyaW5nX29mX2FycmF5KGFycik7XG4gIGNhbWxfbWxfb3V0cHV0KGNoYW5pZCxzLDAsNCk7XG4gIHJldHVybiAwXG59XG4iLCJcblxuLy9Qcm92aWRlczogY2FtbF9nY19taW5vclxuZnVuY3Rpb24gY2FtbF9nY19taW5vcigpeyByZXR1cm4gMH1cbi8vUHJvdmlkZXM6IGNhbWxfZ2NfbWFqb3JcbmZ1bmN0aW9uIGNhbWxfZ2NfbWFqb3IoKXsgcmV0dXJuIDB9XG4vL1Byb3ZpZGVzOiBjYW1sX2djX2Z1bGxfbWFqb3JcbmZ1bmN0aW9uIGNhbWxfZ2NfZnVsbF9tYWpvcigpeyByZXR1cm4gMH1cbi8vUHJvdmlkZXM6IGNhbWxfZ2NfY29tcGFjdGlvblxuZnVuY3Rpb24gY2FtbF9nY19jb21wYWN0aW9uKCl7IHJldHVybiAwfVxuLy9Qcm92aWRlczogY2FtbF9nY19jb3VudGVyc1xuZnVuY3Rpb24gY2FtbF9nY19jb3VudGVycygpIHsgcmV0dXJuIFsyNTQsMCwwLDBdIH1cbi8vUHJvdmlkZXM6IGNhbWxfZ2NfcXVpY2tfc3RhdFxuZnVuY3Rpb24gY2FtbF9nY19xdWlja19zdGF0KCl7XG4gIHJldHVybiBbMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwXVxufVxuLy9Qcm92aWRlczogY2FtbF9nY19zdGF0XG5mdW5jdGlvbiBjYW1sX2djX3N0YXQoKSB7XG4gIHJldHVybiBbMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwXVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2djX3NldFxuZnVuY3Rpb24gY2FtbF9nY19zZXQoX2NvbnRyb2wpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2NfZ2V0XG5mdW5jdGlvbiBjYW1sX2djX2dldCgpe1xuICByZXR1cm4gWzAsMCwwLDAsMCwwLDAsMCwwXVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21lbXByb2Zfc2V0XG5mdW5jdGlvbiBjYW1sX21lbXByb2Zfc2V0KF9jb250cm9sKSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ZpbmFsX3JlZ2lzdGVyIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ZpbmFsX3JlZ2lzdGVyICgpIHsgcmV0dXJuIDA7IH1cbi8vUHJvdmlkZXM6IGNhbWxfZmluYWxfcmVnaXN0ZXJfY2FsbGVkX3dpdGhvdXRfdmFsdWUgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZmluYWxfcmVnaXN0ZXJfY2FsbGVkX3dpdGhvdXRfdmFsdWUgKCkgeyByZXR1cm4gMDsgfVxuLy9Qcm92aWRlczogY2FtbF9maW5hbF9yZWxlYXNlIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ZpbmFsX3JlbGVhc2UgKCkgeyByZXR1cm4gMDsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21lbXByb2Zfc3RhcnRcbmZ1bmN0aW9uIGNhbWxfbWVtcHJvZl9zdGFydChyYXRlLHN0YWNrX3NpemUsdHJhY2tlcil7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21lbXByb2Zfc3RvcFxuZnVuY3Rpb24gY2FtbF9tZW1wcm9mX3N0b3AodW5pdCkge1xuICByZXR1cm4gMDtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxNCBKw6lyw7RtZSBWb3VpbGxvbiwgSHVnbyBIZXV6YXJkLCBBbmR5IFJheVxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuLy9cbi8vIEJpZ2FycmF5LlxuLy9cbi8vIC0gYWxsIGJpZ2FycmF5IHR5cGVzIGluY2x1ZGluZyBJbnQ2NCBhbmQgQ29tcGxleC5cbi8vIC0gZm9ydHJhbiArIGMgbGF5b3V0c1xuLy8gLSBzdWIvc2xpY2UvcmVzaGFwZVxuLy8gLSByZXRhaW4gZmFzdCBwYXRoIGZvciAxZCBhcnJheSBhY2Nlc3NcblxuLy9Qcm92aWRlczogY2FtbF9iYV9pbml0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2JhX2luaXQoKSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2dldF9zaXplXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfYmFfZ2V0X3NpemUoZGltcykge1xuICB2YXIgbl9kaW1zID0gZGltcy5sZW5ndGg7XG4gIHZhciBzaXplID0gMTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuX2RpbXM7IGkrKykge1xuICAgIGlmIChkaW1zW2ldIDwgMClcbiAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LmNyZWF0ZTogbmVnYXRpdmUgZGltZW5zaW9uXCIpO1xuICAgIHNpemUgPSBzaXplICogZGltc1tpXTtcbiAgfVxuICByZXR1cm4gc2l6ZTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudFxuZnVuY3Rpb24gY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudChraW5kKXtcbiAgc3dpdGNoKGtpbmQpe1xuICBjYXNlIDc6IGNhc2UgMTA6IGNhc2UgMTE6IHJldHVybiAyO1xuICBkZWZhdWx0OiByZXR1cm4gMTtcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2NyZWF0ZV9idWZmZXJcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnRcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9iYV9jcmVhdGVfYnVmZmVyKGtpbmQsIHNpemUpe1xuICB2YXIgZyA9IGpvb19nbG9iYWxfb2JqZWN0O1xuICB2YXIgdmlldztcbiAgc3dpdGNoKGtpbmQpe1xuICBjYXNlIDA6ICB2aWV3ID0gZy5GbG9hdDMyQXJyYXk7IGJyZWFrO1xuICBjYXNlIDE6ICB2aWV3ID0gZy5GbG9hdDY0QXJyYXk7IGJyZWFrO1xuICBjYXNlIDI6ICB2aWV3ID0gZy5JbnQ4QXJyYXk7IGJyZWFrO1xuICBjYXNlIDM6ICB2aWV3ID0gZy5VaW50OEFycmF5OyBicmVhaztcbiAgY2FzZSA0OiAgdmlldyA9IGcuSW50MTZBcnJheTsgYnJlYWs7XG4gIGNhc2UgNTogIHZpZXcgPSBnLlVpbnQxNkFycmF5OyBicmVhaztcbiAgY2FzZSA2OiAgdmlldyA9IGcuSW50MzJBcnJheTsgYnJlYWs7XG4gIGNhc2UgNzogIHZpZXcgPSBnLkludDMyQXJyYXk7IGJyZWFrO1xuICBjYXNlIDg6ICB2aWV3ID0gZy5JbnQzMkFycmF5OyBicmVhaztcbiAgY2FzZSA5OiAgdmlldyA9IGcuSW50MzJBcnJheTsgYnJlYWs7XG4gIGNhc2UgMTA6IHZpZXcgPSBnLkZsb2F0MzJBcnJheTsgYnJlYWs7XG4gIGNhc2UgMTE6IHZpZXcgPSBnLkZsb2F0NjRBcnJheTsgYnJlYWs7XG4gIGNhc2UgMTI6IHZpZXcgPSBnLlVpbnQ4QXJyYXk7IGJyZWFrO1xuICB9XG4gIGlmICghdmlldykgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkuY3JlYXRlOiB1bnN1cHBvcnRlZCBraW5kXCIpO1xuICB2YXIgZGF0YSA9IG5ldyB2aWV3KHNpemUgKiBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50KGtpbmQpKTtcbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfY3VzdG9tX25hbWVcbi8vVmVyc2lvbjogPCA0LjExXG52YXIgY2FtbF9iYV9jdXN0b21fbmFtZSA9IFwiX2JpZ2FycmF5XCJcblxuLy9Qcm92aWRlczogY2FtbF9iYV9jdXN0b21fbmFtZVxuLy9WZXJzaW9uOiA+PSA0LjExXG52YXIgY2FtbF9iYV9jdXN0b21fbmFtZSA9IFwiX2JpZ2FycjAyXCJcblxuLy9Qcm92aWRlczogTWxfQmlnYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3IsIGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9iYV9jdXN0b21fbmFtZVxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9jcmVhdGVfbG9faGksIGNhbWxfaW50NjRfaGkzMiwgY2FtbF9pbnQ2NF9sbzMyXG5mdW5jdGlvbiBNbF9CaWdhcnJheSAoa2luZCwgbGF5b3V0LCBkaW1zLCBidWZmZXIpIHtcblxuICB0aGlzLmtpbmQgICA9IGtpbmQgO1xuICB0aGlzLmxheW91dCA9IGxheW91dDtcbiAgdGhpcy5kaW1zICAgPSBkaW1zO1xuICB0aGlzLmRhdGEgPSBidWZmZXI7XG59XG5cbk1sX0JpZ2FycmF5LnByb3RvdHlwZS5jYW1sX2N1c3RvbSA9IGNhbWxfYmFfY3VzdG9tX25hbWU7XG5cbk1sX0JpZ2FycmF5LnByb3RvdHlwZS5vZmZzZXQgPSBmdW5jdGlvbiAoYXJnKSB7XG4gIHZhciBvZnMgPSAwO1xuICBpZih0eXBlb2YgYXJnID09PSBcIm51bWJlclwiKSBhcmcgPSBbYXJnXTtcbiAgaWYgKCEgKGFyZyBpbnN0YW5jZW9mIEFycmF5KSkgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiYmlnYXJyYXkuanM6IGludmFsaWQgb2Zmc2V0XCIpO1xuICBpZiAodGhpcy5kaW1zLmxlbmd0aCAhPSBhcmcubGVuZ3RoKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LmdldC9zZXQ6IGJhZCBudW1iZXIgb2YgZGltZW5zaW9uc1wiKTtcbiAgaWYodGhpcy5sYXlvdXQgPT0gMCAvKiBjX2xheW91dCAqLykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kaW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYXJnW2ldIDwgMCB8fCBhcmdbaV0gPj0gdGhpcy5kaW1zW2ldKVxuICAgICAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gICAgICBvZnMgPSAob2ZzICogdGhpcy5kaW1zW2ldKSArIGFyZ1tpXTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMuZGltcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgaWYgKGFyZ1tpXSA8IDEgfHwgYXJnW2ldID4gdGhpcy5kaW1zW2ldKXtcbiAgICAgICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICAgICAgfVxuICAgICAgb2ZzID0gKG9mcyAqIHRoaXMuZGltc1tpXSkgKyAoYXJnW2ldIC0gMSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBvZnM7XG59XG5cbk1sX0JpZ2FycmF5LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAob2ZzKSB7XG4gIHN3aXRjaCh0aGlzLmtpbmQpe1xuICBjYXNlIDc6XG4gICAgLy8gSW50NjRcbiAgICB2YXIgbCA9IHRoaXMuZGF0YVtvZnMgKiAyICsgMF07XG4gICAgdmFyIGggPSB0aGlzLmRhdGFbb2ZzICogMiArIDFdO1xuICAgIHJldHVybiBjYW1sX2ludDY0X2NyZWF0ZV9sb19oaShsLGgpO1xuICBjYXNlIDEwOiBjYXNlIDExOlxuICAgIC8vIENvbXBsZXgzMiwgQ29tcGxleDY0XG4gICAgdmFyIHIgPSB0aGlzLmRhdGFbb2ZzICogMiArIDBdO1xuICAgIHZhciBpID0gdGhpcy5kYXRhW29mcyAqIDIgKyAxXTtcbiAgICByZXR1cm4gWzI1NCwgciwgaV07XG4gIGRlZmF1bHQ6XG4gICAgcmV0dXJuIHRoaXMuZGF0YVtvZnNdXG4gIH1cbn1cblxuTWxfQmlnYXJyYXkucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChvZnMsdikge1xuICBzd2l0Y2godGhpcy5raW5kKXtcbiAgY2FzZSA3OlxuICAgIC8vIEludDY0XG4gICAgdGhpcy5kYXRhW29mcyAqIDIgKyAwXSA9IGNhbWxfaW50NjRfbG8zMih2KTtcbiAgICB0aGlzLmRhdGFbb2ZzICogMiArIDFdID0gY2FtbF9pbnQ2NF9oaTMyKHYpO1xuICAgIGJyZWFrO1xuICBjYXNlIDEwOiBjYXNlIDExOlxuICAgIC8vIENvbXBsZXgzMiwgQ29tcGxleDY0XG4gICAgdGhpcy5kYXRhW29mcyAqIDIgKyAwXSA9IHZbMV07XG4gICAgdGhpcy5kYXRhW29mcyAqIDIgKyAxXSA9IHZbMl07XG4gICAgYnJlYWs7XG4gIGRlZmF1bHQ6XG4gICAgdGhpcy5kYXRhW29mc10gPSB2O1xuICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiAwXG59XG5cblxuTWxfQmlnYXJyYXkucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiAodikge1xuICBzd2l0Y2godGhpcy5raW5kKXtcbiAgY2FzZSA3OlxuICAgIC8vIEludDY0XG4gICAgdmFyIGEgPSBjYW1sX2ludDY0X2xvMzIodik7XG4gICAgdmFyIGIgPSBjYW1sX2ludDY0X2hpMzIodik7XG4gICAgaWYoYSA9PSBiKXtcbiAgICAgIHRoaXMuZGF0YS5maWxsKGEpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGk8dGhpcy5kYXRhLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdGhpcy5kYXRhW2ldID0gKGklMiA9PSAwKSA/IGEgOiBiO1xuICAgICAgfVxuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAxMDogY2FzZSAxMTpcbiAgICAvLyBDb21wbGV4MzIsIENvbXBsZXg2NFxuICAgIHZhciBpbSA9IHZbMV07XG4gICAgdmFyIHJlID0gdlsyXTtcbiAgICBpZihpbSA9PSByZSl7XG4gICAgICB0aGlzLmRhdGEuZmlsbChpbSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZm9yKHZhciBpID0gMDsgaTx0aGlzLmRhdGEubGVuZ3RoOyBpKyspe1xuICAgICAgICB0aGlzLmRhdGFbaV0gPSAoaSUyID09IDApID8gaW0gOiByZTtcbiAgICAgIH1cbiAgICB9XG4gICAgYnJlYWs7XG4gIGRlZmF1bHQ6XG4gICAgdGhpcy5kYXRhLmZpbGwodik7XG4gICAgYnJlYWs7XG4gIH1cbn1cblxuXG5NbF9CaWdhcnJheS5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIChiLCB0b3RhbCkge1xuICBpZiAodGhpcy5sYXlvdXQgIT0gYi5sYXlvdXQgfHwgdGhpcy5raW5kICE9IGIua2luZCkge1xuICAgIHZhciBrMSA9IHRoaXMua2luZCB8ICh0aGlzLmxheW91dCA8PCA4KTtcbiAgICB2YXIgazIgPSAgICBiLmtpbmQgfCAoYi5sYXlvdXQgPDwgOCk7XG4gICAgcmV0dXJuIGsyIC0gazE7XG4gIH1cbiAgaWYgKHRoaXMuZGltcy5sZW5ndGggIT0gYi5kaW1zLmxlbmd0aCkge1xuICAgIHJldHVybiBiLmRpbXMubGVuZ3RoIC0gdGhpcy5kaW1zLmxlbmd0aDtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGltcy5sZW5ndGg7IGkrKylcbiAgICBpZiAodGhpcy5kaW1zW2ldICE9IGIuZGltc1tpXSlcbiAgICAgIHJldHVybiAodGhpcy5kaW1zW2ldIDwgYi5kaW1zW2ldKSA/IC0xIDogMTtcbiAgc3dpdGNoICh0aGlzLmtpbmQpIHtcbiAgY2FzZSAwOlxuICBjYXNlIDE6XG4gIGNhc2UgMTA6XG4gIGNhc2UgMTE6XG4gICAgLy8gRmxvYXRzXG4gICAgdmFyIHgsIHk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIHggPSB0aGlzLmRhdGFbaV07XG4gICAgICB5ID0gYi5kYXRhW2ldO1xuICAgICAgaWYgKHggPCB5KVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgICBpZiAoeCA+IHkpXG4gICAgICAgIHJldHVybiAxO1xuICAgICAgaWYgKHggIT0geSkge1xuICAgICAgICBpZiAoIXRvdGFsKSByZXR1cm4gTmFOO1xuICAgICAgICBpZiAoeCA9PSB4KSByZXR1cm4gMTtcbiAgICAgICAgaWYgKHkgPT0geSkgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSA3OlxuICAgIC8vIEludDY0XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyBpKz0yKSB7XG4gICAgICAvLyBDaGVjayBoaWdoZXN0IGJpdHMgZmlyc3RcbiAgICAgIGlmICh0aGlzLmRhdGFbaSsxXSA8IGIuZGF0YVtpKzFdKVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgICBpZiAodGhpcy5kYXRhW2krMV0gPiBiLmRhdGFbaSsxXSlcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICBpZiAoKHRoaXMuZGF0YVtpXSA+Pj4gMCkgPCAoYi5kYXRhW2ldID4+PiAwKSlcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgaWYgKCh0aGlzLmRhdGFbaV0gPj4+IDApID4gKGIuZGF0YVtpXSA+Pj4gMCkpXG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAyOlxuICBjYXNlIDM6XG4gIGNhc2UgNDpcbiAgY2FzZSA1OlxuICBjYXNlIDY6XG4gIGNhc2UgODpcbiAgY2FzZSA5OlxuICBjYXNlIDEyOlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodGhpcy5kYXRhW2ldIDwgYi5kYXRhW2ldKVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgICBpZiAodGhpcy5kYXRhW2ldID4gYi5kYXRhW2ldKVxuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IE1sX0JpZ2FycmF5X2NfMV8xXG4vL1JlcXVpcmVzOiBNbF9CaWdhcnJheSwgY2FtbF9hcnJheV9ib3VuZF9lcnJvciwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBNbF9CaWdhcnJheV9jXzFfMShraW5kLCBsYXlvdXQsIGRpbXMsIGJ1ZmZlcikge1xuICB0aGlzLmtpbmQgICA9IGtpbmQgO1xuICB0aGlzLmxheW91dCA9IGxheW91dDtcbiAgdGhpcy5kaW1zICAgPSBkaW1zO1xuICB0aGlzLmRhdGEgICA9IGJ1ZmZlcjtcbn1cblxuTWxfQmlnYXJyYXlfY18xXzEucHJvdG90eXBlID0gbmV3IE1sX0JpZ2FycmF5KClcbk1sX0JpZ2FycmF5X2NfMV8xLnByb3RvdHlwZS5vZmZzZXQgPSBmdW5jdGlvbiAoYXJnKSB7XG4gIGlmKHR5cGVvZiBhcmcgIT09IFwibnVtYmVyXCIpe1xuICAgIGlmKChhcmcgaW5zdGFuY2VvZiBBcnJheSkgJiYgYXJnLmxlbmd0aCA9PSAxKVxuICAgICAgYXJnID0gYXJnWzBdO1xuICAgIGVsc2UgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiTWxfQmlnYXJyYXlfY18xXzEub2Zmc2V0XCIpO1xuICB9XG4gIGlmIChhcmcgPCAwIHx8IGFyZyA+PSB0aGlzLmRpbXNbMF0pXG4gICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICByZXR1cm4gYXJnO1xufVxuXG5NbF9CaWdhcnJheV9jXzFfMS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKG9mcykge1xuICByZXR1cm4gdGhpcy5kYXRhW29mc107XG59XG5cbk1sX0JpZ2FycmF5X2NfMV8xLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAob2ZzLHYpIHtcbiAgdGhpcy5kYXRhW29mc10gPSB2O1xuICByZXR1cm4gMFxufVxuXG5NbF9CaWdhcnJheV9jXzFfMS5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uICh2KSB7XG4gIHRoaXMuZGF0YS5maWxsKHYpO1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2NvbXBhcmVcbmZ1bmN0aW9uIGNhbWxfYmFfY29tcGFyZShhLGIsdG90YWwpe1xuICByZXR1cm4gYS5jb21wYXJlKGIsdG90YWwpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfY3JlYXRlX3Vuc2FmZVxuLy9SZXF1aXJlczogTWxfQmlnYXJyYXksIE1sX0JpZ2FycmF5X2NfMV8xLCBjYW1sX2JhX2dldF9zaXplLCBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50XG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZShraW5kLCBsYXlvdXQsIGRpbXMsIGRhdGEpe1xuICB2YXIgc2l6ZV9wZXJfZWxlbWVudCA9IGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnQoa2luZCk7XG4gIGlmKGNhbWxfYmFfZ2V0X3NpemUoZGltcykgKiBzaXplX3Blcl9lbGVtZW50ICE9IGRhdGEubGVuZ3RoKSB7XG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwibGVuZ3RoIGRvZXNuJ3QgbWF0Y2ggZGltc1wiKTtcbiAgfVxuICBpZihsYXlvdXQgPT0gMCAmJiAvLyBjX2xheW91dFxuICAgICBkaW1zLmxlbmd0aCA9PSAxICYmIC8vIEFycmF5MVxuICAgICBzaXplX3Blcl9lbGVtZW50ID09IDEpIC8vIDEtdG8tMSBtYXBwaW5nXG4gICAgcmV0dXJuIG5ldyBNbF9CaWdhcnJheV9jXzFfMShraW5kLCBsYXlvdXQsIGRpbXMsIGRhdGEpO1xuICByZXR1cm4gbmV3IE1sX0JpZ2FycmF5KGtpbmQsIGxheW91dCwgZGltcywgZGF0YSk7XG5cbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2NyZWF0ZVxuLy9SZXF1aXJlczogY2FtbF9qc19mcm9tX2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF9zaXplLCBjYW1sX2JhX2NyZWF0ZV91bnNhZmVcbi8vUmVxdWlyZXM6IGNhbWxfYmFfY3JlYXRlX2J1ZmZlclxuZnVuY3Rpb24gY2FtbF9iYV9jcmVhdGUoa2luZCwgbGF5b3V0LCBkaW1zX21sKSB7XG4gIHZhciBkaW1zID0gY2FtbF9qc19mcm9tX2FycmF5KGRpbXNfbWwpO1xuICB2YXIgZGF0YSA9IGNhbWxfYmFfY3JlYXRlX2J1ZmZlcihraW5kLCBjYW1sX2JhX2dldF9zaXplKGRpbXMpKTtcbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZShraW5kLCBsYXlvdXQsIGRpbXMsIGRhdGEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2NoYW5nZV9sYXlvdXRcbi8vUmVxdWlyZXM6IGNhbWxfYmFfY3JlYXRlX3Vuc2FmZVxuZnVuY3Rpb24gY2FtbF9iYV9jaGFuZ2VfbGF5b3V0KGJhLCBsYXlvdXQpIHtcbiAgaWYoYmEubGF5b3V0ID09IGxheW91dCkgcmV0dXJuIGJhO1xuICB2YXIgbmV3X2RpbXMgPSBbXVxuICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGltcy5sZW5ndGg7IGkrKykgbmV3X2RpbXNbaV0gPSBiYS5kaW1zW2JhLmRpbXMubGVuZ3RoIC0gaSAtIDFdO1xuICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGJhLmtpbmQsIGxheW91dCwgbmV3X2RpbXMsIGJhLmRhdGEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2tpbmRcbmZ1bmN0aW9uIGNhbWxfYmFfa2luZChiYSkge1xuICByZXR1cm4gYmEua2luZDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9sYXlvdXRcbmZ1bmN0aW9uIGNhbWxfYmFfbGF5b3V0KGJhKSB7XG4gIHJldHVybiBiYS5sYXlvdXQ7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfbnVtX2RpbXNcbmZ1bmN0aW9uIGNhbWxfYmFfbnVtX2RpbXMoYmEpIHtcbiAgcmV0dXJuIGJhLmRpbXMubGVuZ3RoO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2RpbVxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX2JhX2RpbShiYSwgaSkge1xuICBpZiAoaSA8IDAgfHwgaSA+PSBiYS5kaW1zLmxlbmd0aClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5kaW1cIik7XG4gIHJldHVybiBiYS5kaW1zW2ldO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2RpbV8xXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2RpbVxuZnVuY3Rpb24gY2FtbF9iYV9kaW1fMShiYSkge1xuICByZXR1cm4gY2FtbF9iYV9kaW0oYmEsIDApO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2RpbV8yXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2RpbVxuZnVuY3Rpb24gY2FtbF9iYV9kaW1fMihiYSkge1xuICByZXR1cm4gY2FtbF9iYV9kaW0oYmEsIDEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2RpbV8zXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2RpbVxuZnVuY3Rpb24gY2FtbF9iYV9kaW1fMyhiYSkge1xuICByZXR1cm4gY2FtbF9iYV9kaW0oYmEsIDIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2dldF9nZW5lcmljXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfYmFfZ2V0X2dlbmVyaWMoYmEsIGkpIHtcbiAgdmFyIG9mcyA9IGJhLm9mZnNldChjYW1sX2pzX2Zyb21fYXJyYXkoaSkpO1xuICByZXR1cm4gYmEuZ2V0KG9mcyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfdWludDhfZ2V0MTZcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfYmFfdWludDhfZ2V0MTYoYmEsIGkwKSB7XG4gIHZhciBvZnMgPSBiYS5vZmZzZXQoaTApO1xuICBpZihvZnMgKyAxID49IGJhLmRhdGEubGVuZ3RoKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHZhciBiMSA9IGJhLmdldChvZnMpO1xuICB2YXIgYjIgPSBiYS5nZXQob2ZzICsgMSk7XG4gIHJldHVybiAoYjEgfCAoYjIgPDwgOCkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3VpbnQ4X2dldDMyXG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX2JhX3VpbnQ4X2dldDMyKGJhLCBpMCkge1xuICB2YXIgb2ZzID0gYmEub2Zmc2V0KGkwKTtcbiAgaWYob2ZzICsgMyA+PSBiYS5kYXRhLmxlbmd0aCkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB2YXIgYjEgPSBiYS5nZXQob2ZzKzApO1xuICB2YXIgYjIgPSBiYS5nZXQob2ZzKzEpO1xuICB2YXIgYjMgPSBiYS5nZXQob2ZzKzIpO1xuICB2YXIgYjQgPSBiYS5nZXQob2ZzKzMpO1xuICByZXR1cm4gKCAoYjEgPDwgMCkgIHxcbiAgICAgICAgICAgKGIyIDw8IDgpICB8XG4gICAgICAgICAgIChiMyA8PCAxNikgfFxuICAgICAgICAgICAoYjQgPDwgMjQpICk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfdWludDhfZ2V0NjRcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3IsIGNhbWxfaW50NjRfb2ZfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYmFfdWludDhfZ2V0NjQoYmEsIGkwKSB7XG4gIHZhciBvZnMgPSBiYS5vZmZzZXQoaTApO1xuICBpZihvZnMgKyA3ID49IGJhLmRhdGEubGVuZ3RoKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHZhciBiMSA9IGJhLmdldChvZnMrMCk7XG4gIHZhciBiMiA9IGJhLmdldChvZnMrMSk7XG4gIHZhciBiMyA9IGJhLmdldChvZnMrMik7XG4gIHZhciBiNCA9IGJhLmdldChvZnMrMyk7XG4gIHZhciBiNSA9IGJhLmdldChvZnMrNCk7XG4gIHZhciBiNiA9IGJhLmdldChvZnMrNSk7XG4gIHZhciBiNyA9IGJhLmdldChvZnMrNik7XG4gIHZhciBiOCA9IGJhLmdldChvZnMrNyk7XG4gIHJldHVybiBjYW1sX2ludDY0X29mX2J5dGVzKFtiOCxiNyxiNixiNSxiNCxiMyxiMixiMV0pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2dldF8xXG5mdW5jdGlvbiBjYW1sX2JhX2dldF8xKGJhLCBpMCkge1xuICByZXR1cm4gYmEuZ2V0KGJhLm9mZnNldChpMCkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2dldF8yXG5mdW5jdGlvbiBjYW1sX2JhX2dldF8yKGJhLCBpMCwgaTEpIHtcbiAgcmV0dXJuIGJhLmdldChiYS5vZmZzZXQoW2kwLGkxXSkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2dldF8zXG5mdW5jdGlvbiBjYW1sX2JhX2dldF8zKGJhLCBpMCwgaTEsIGkyKSB7XG4gIHJldHVybiBiYS5nZXQoYmEub2Zmc2V0KFtpMCxpMSxpMl0pKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9zZXRfZ2VuZXJpY1xuLy9SZXF1aXJlczogY2FtbF9qc19mcm9tX2FycmF5XG5mdW5jdGlvbiBjYW1sX2JhX3NldF9nZW5lcmljKGJhLCBpLCB2KSB7XG4gIGJhLnNldChiYS5vZmZzZXQoY2FtbF9qc19mcm9tX2FycmF5KGkpKSwgdik7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfdWludDhfc2V0MTZcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfYmFfdWludDhfc2V0MTYoYmEsIGkwLCB2KSB7XG4gIHZhciBvZnMgPSBiYS5vZmZzZXQoaTApO1xuICBpZihvZnMgKyAxID49IGJhLmRhdGEubGVuZ3RoKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIGJhLnNldChvZnMrMCwgIHYgICAgICAgICYgMHhmZik7XG4gIGJhLnNldChvZnMrMSwgKHYgPj4+IDgpICYgMHhmZik7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3VpbnQ4X3NldDMyXG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX2JhX3VpbnQ4X3NldDMyKGJhLCBpMCwgdikge1xuICB2YXIgb2ZzID0gYmEub2Zmc2V0KGkwKTtcbiAgaWYob2ZzICsgMyA+PSBiYS5kYXRhLmxlbmd0aCkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICBiYS5zZXQob2ZzKzAsICB2ICAgICAgICAgJiAweGZmKTtcbiAgYmEuc2V0KG9mcysxLCAodiA+Pj4gOCkgICYgMHhmZik7XG4gIGJhLnNldChvZnMrMiwgKHYgPj4+IDE2KSAmIDB4ZmYpO1xuICBiYS5zZXQob2ZzKzMsICh2ID4+PiAyNCkgJiAweGZmKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfdWludDhfc2V0NjRcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3IsIGNhbWxfaW50NjRfdG9fYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYmFfdWludDhfc2V0NjQoYmEsIGkwLCB2KSB7XG4gIHZhciBvZnMgPSBiYS5vZmZzZXQoaTApO1xuICBpZihvZnMgKyA3ID49IGJhLmRhdGEubGVuZ3RoKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHZhciB2ID0gY2FtbF9pbnQ2NF90b19ieXRlcyh2KTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IDg7IGkrKykgYmEuc2V0KG9mcytpLCB2WzctaV0pXG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3NldF8xXG5mdW5jdGlvbiBjYW1sX2JhX3NldF8xKGJhLCBpMCwgdikge1xuICBiYS5zZXQoYmEub2Zmc2V0KGkwKSwgdik7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfc2V0XzJcbmZ1bmN0aW9uIGNhbWxfYmFfc2V0XzIoYmEsIGkwLCBpMSwgdikge1xuICBiYS5zZXQoYmEub2Zmc2V0KFtpMCxpMV0pLCB2KTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfc2V0XzNcbmZ1bmN0aW9uIGNhbWxfYmFfc2V0XzMoYmEsIGkwLCBpMSwgaTIsIHYpIHtcbiAgYmEuc2V0KGJhLm9mZnNldChbaTAsaTEsaTJdKSwgdik7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2ZpbGxcbmZ1bmN0aW9uIGNhbWxfYmFfZmlsbChiYSwgdikge1xuICBiYS5maWxsKHYpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9ibGl0XG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfYmFfYmxpdChzcmMsIGRzdCkge1xuICBpZiAoZHN0LmRpbXMubGVuZ3RoICE9IHNyYy5kaW1zLmxlbmd0aClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5ibGl0OiBkaW1lbnNpb24gbWlzbWF0Y2hcIik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZHN0LmRpbXMubGVuZ3RoOyBpKyspXG4gICAgaWYgKGRzdC5kaW1zW2ldICE9IHNyYy5kaW1zW2ldKVxuICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkuYmxpdDogZGltZW5zaW9uIG1pc21hdGNoXCIpO1xuICBkc3QuZGF0YS5zZXQoc3JjLmRhdGEpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9zdWJcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9iYV9jcmVhdGVfdW5zYWZlLCBjYW1sX2JhX2dldF9zaXplXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50XG5mdW5jdGlvbiBjYW1sX2JhX3N1YihiYSwgb2ZzLCBsZW4pIHtcbiAgdmFyIGNoYW5nZWRfZGltO1xuICB2YXIgbXVsID0gMTtcbiAgaWYgKGJhLmxheW91dCA9PSAwKSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBiYS5kaW1zLmxlbmd0aDsgaSsrKVxuICAgICAgbXVsID0gbXVsICogYmEuZGltc1tpXTtcbiAgICBjaGFuZ2VkX2RpbSA9IDA7XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAoYmEuZGltcy5sZW5ndGggLSAxKTsgaSsrKVxuICAgICAgbXVsID0gbXVsICogYmEuZGltc1tpXTtcbiAgICBjaGFuZ2VkX2RpbSA9IGJhLmRpbXMubGVuZ3RoIC0gMTtcbiAgICBvZnMgPSBvZnMgLSAxO1xuICB9XG4gIGlmIChvZnMgPCAwIHx8IGxlbiA8IDAgfHwgKG9mcyArIGxlbikgPiBiYS5kaW1zW2NoYW5nZWRfZGltXSl7XG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkuc3ViOiBiYWQgc3ViLWFycmF5XCIpO1xuICB9XG4gIHZhciBuZXdfZGltcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJhLmRpbXMubGVuZ3RoOyBpKyspXG4gICAgbmV3X2RpbXNbaV0gPSBiYS5kaW1zW2ldO1xuICBuZXdfZGltc1tjaGFuZ2VkX2RpbV0gPSBsZW47XG4gIG11bCAqPSBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50KGJhLmtpbmQpO1xuICB2YXIgbmV3X2RhdGEgPSBiYS5kYXRhLnN1YmFycmF5KG9mcyAqIG11bCwgKG9mcyArIGxlbikgKiBtdWwpO1xuICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGJhLmtpbmQsIGJhLmxheW91dCwgbmV3X2RpbXMsIG5ld19kYXRhKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9zbGljZVxuLy9SZXF1aXJlczogY2FtbF9qc19mcm9tX2FycmF5LCBjYW1sX2JhX2NyZWF0ZV91bnNhZmUsIGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9iYV9nZXRfc2l6ZVxuLy9SZXF1aXJlczogY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudFxuZnVuY3Rpb24gY2FtbF9iYV9zbGljZShiYSwgdmluZCkge1xuICB2aW5kID0gY2FtbF9qc19mcm9tX2FycmF5KHZpbmQpO1xuICB2YXIgbnVtX2luZHMgPSB2aW5kLmxlbmd0aDtcbiAgdmFyIGluZGV4ID0gW107XG4gIHZhciBzdWJfZGltcyA9IFtdO1xuICB2YXIgb2ZzO1xuXG4gIGlmIChudW1faW5kcyA+IGJhLmRpbXMubGVuZ3RoKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LnNsaWNlOiB0b28gbWFueSBpbmRpY2VzXCIpO1xuXG4gIC8vIENvbXB1dGUgb2Zmc2V0IGFuZCBjaGVjayBib3VuZHNcbiAgaWYgKGJhLmxheW91dCA9PSAwKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1faW5kczsgaSsrKVxuICAgICAgaW5kZXhbaV0gPSB2aW5kW2ldO1xuICAgIGZvciAoOyBpIDwgYmEuZGltcy5sZW5ndGg7IGkrKylcbiAgICAgIGluZGV4W2ldID0gMDtcbiAgICBzdWJfZGltcyA9IGJhLmRpbXMuc2xpY2UobnVtX2luZHMpO1xuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2luZHM7IGkrKylcbiAgICAgIGluZGV4W2JhLmRpbXMubGVuZ3RoIC0gbnVtX2luZHMgKyBpXSA9IHZpbmRbaV07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiYS5kaW1zLmxlbmd0aCAtIG51bV9pbmRzOyBpKyspXG4gICAgICBpbmRleFtpXSA9IDE7XG4gICAgc3ViX2RpbXMgPSBiYS5kaW1zLnNsaWNlKDAsIGJhLmRpbXMubGVuZ3RoIC0gbnVtX2luZHMpO1xuICB9XG4gIG9mcyA9IGJhLm9mZnNldChpbmRleCk7XG4gIHZhciBzaXplID0gY2FtbF9iYV9nZXRfc2l6ZShzdWJfZGltcyk7XG4gIHZhciBzaXplX3Blcl9lbGVtZW50ID0gY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudChiYS5raW5kKTtcbiAgdmFyIG5ld19kYXRhID0gYmEuZGF0YS5zdWJhcnJheShvZnMgKiBzaXplX3Blcl9lbGVtZW50LCAob2ZzICsgc2l6ZSkgKiBzaXplX3Blcl9lbGVtZW50KTtcbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZShiYS5raW5kLCBiYS5sYXlvdXQsIHN1Yl9kaW1zLCBuZXdfZGF0YSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfcmVzaGFwZVxuLy9SZXF1aXJlczogY2FtbF9qc19mcm9tX2FycmF5LCBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZSwgY2FtbF9iYV9nZXRfc2l6ZVxuZnVuY3Rpb24gY2FtbF9iYV9yZXNoYXBlKGJhLCB2aW5kKSB7XG4gIHZpbmQgPSBjYW1sX2pzX2Zyb21fYXJyYXkodmluZCk7XG4gIHZhciBuZXdfZGltID0gW107XG4gIHZhciBudW1fZGltcyA9IHZpbmQubGVuZ3RoO1xuXG4gIGlmIChudW1fZGltcyA8IDAgfHwgbnVtX2RpbXMgPiAxNil7XG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkucmVzaGFwZTogYmFkIG51bWJlciBvZiBkaW1lbnNpb25zXCIpO1xuICB9XG4gIHZhciBudW1fZWx0cyA9IDE7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2RpbXM7IGkrKykge1xuICAgIG5ld19kaW1baV0gPSB2aW5kW2ldO1xuICAgIGlmIChuZXdfZGltW2ldIDwgMClcbiAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LnJlc2hhcGU6IG5lZ2F0aXZlIGRpbWVuc2lvblwiKTtcbiAgICBudW1fZWx0cyA9IG51bV9lbHRzICogbmV3X2RpbVtpXTtcbiAgfVxuXG4gIHZhciBzaXplID0gY2FtbF9iYV9nZXRfc2l6ZShiYS5kaW1zKTtcbiAgLy8gQ2hlY2sgdGhhdCBzaXplcyBhZ3JlZVxuICBpZiAobnVtX2VsdHMgIT0gc2l6ZSlcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5yZXNoYXBlOiBzaXplIG1pc21hdGNoXCIpO1xuICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGJhLmtpbmQsIGJhLmxheW91dCwgbmV3X2RpbSwgYmEuZGF0YSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfc2VyaWFsaXplXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQsIGNhbWxfaW50NjRfdG9fYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfaW50MzJfYml0c19vZl9mbG9hdFxuZnVuY3Rpb24gY2FtbF9iYV9zZXJpYWxpemUod3JpdGVyLCBiYSwgc3opIHtcbiAgd3JpdGVyLndyaXRlKDMyLCBiYS5kaW1zLmxlbmd0aCk7XG4gIHdyaXRlci53cml0ZSgzMiwgKGJhLmtpbmQgfCAoYmEubGF5b3V0IDw8IDgpKSk7XG4gIGlmKGJhLmNhbWxfY3VzdG9tID09IFwiX2JpZ2FycjAyXCIpXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRpbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmKGJhLmRpbXNbaV0gPCAweGZmZmYpXG4gICAgICAgIHdyaXRlci53cml0ZSgxNiwgYmEuZGltc1tpXSk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgd3JpdGVyLndyaXRlKDE2LCAweGZmZmYpO1xuICAgICAgICB3cml0ZXIud3JpdGUoMzIsIDApO1xuICAgICAgICB3cml0ZXIud3JpdGUoMzIsIGJhLmRpbXNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgZWxzZVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kaW1zLmxlbmd0aDsgaSsrKSB3cml0ZXIud3JpdGUoMzIsYmEuZGltc1tpXSlcbiAgc3dpdGNoKGJhLmtpbmQpe1xuICBjYXNlIDI6ICAvL0ludDhBcnJheVxuICBjYXNlIDM6ICAvL1VpbnQ4QXJyYXlcbiAgY2FzZSAxMjogLy9VaW50OEFycmF5XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRhdGEubGVuZ3RoOyBpKyspe1xuICAgICAgd3JpdGVyLndyaXRlKDgsIGJhLmRhdGFbaV0pO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSA0OiAgLy8gSW50MTZBcnJheVxuICBjYXNlIDU6ICAvLyBVaW50MTZBcnJheVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kYXRhLmxlbmd0aDsgaSsrKXtcbiAgICAgIHdyaXRlci53cml0ZSgxNiwgYmEuZGF0YVtpXSk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDY6ICAvLyBJbnQzMkFycmF5IChpbnQzMilcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGF0YS5sZW5ndGg7IGkrKyl7XG4gICAgICB3cml0ZXIud3JpdGUoMzIsIGJhLmRhdGFbaV0pO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSA4OiAgLy8gSW50MzJBcnJheSAoaW50KVxuICBjYXNlIDk6ICAvLyBJbnQzMkFycmF5IChuYXRpdmVpbnQpXG4gICAgd3JpdGVyLndyaXRlKDgsMCk7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRhdGEubGVuZ3RoOyBpKyspe1xuICAgICAgd3JpdGVyLndyaXRlKDMyLCBiYS5kYXRhW2ldKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgNzogIC8vIEludDMyQXJyYXkgKGludDY0KVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kYXRhLmxlbmd0aCAvIDI7IGkrKyl7XG4gICAgICB2YXIgYiA9IGNhbWxfaW50NjRfdG9fYnl0ZXMoYmEuZ2V0KGkpKTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgODsgaisrKSB3cml0ZXIud3JpdGUgKDgsIGJbal0pO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAxOiAgLy8gRmxvYXQ2NEFycmF5XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRhdGEubGVuZ3RoOyBpKyspe1xuICAgICAgdmFyIGIgPSBjYW1sX2ludDY0X3RvX2J5dGVzKGNhbWxfaW50NjRfYml0c19vZl9mbG9hdChiYS5nZXQoaSkpKTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgODsgaisrKSB3cml0ZXIud3JpdGUgKDgsIGJbal0pO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAwOiAgLy8gRmxvYXQzMkFycmF5XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRhdGEubGVuZ3RoOyBpKyspe1xuICAgICAgdmFyIGIgPSBjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXQoYmEuZ2V0KGkpKTtcbiAgICAgIHdyaXRlci53cml0ZSgzMiwgYik7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDEwOiAvLyBGbG9hdDMyQXJyYXkgKGNvbXBsZXgzMilcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGF0YS5sZW5ndGggLyAyOyBpKyspe1xuICAgICAgdmFyIGogPSBiYS5nZXQoaSk7XG4gICAgICB3cml0ZXIud3JpdGUoMzIsIGNhbWxfaW50MzJfYml0c19vZl9mbG9hdChqWzFdKSk7XG4gICAgICB3cml0ZXIud3JpdGUoMzIsIGNhbWxfaW50MzJfYml0c19vZl9mbG9hdChqWzJdKSk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDExOiAvLyBGbG9hdDY0QXJyYXkgKGNvbXBsZXg2NClcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGF0YS5sZW5ndGggLyAyOyBpKyspe1xuICAgICAgdmFyIGNvbXBsZXggPSBiYS5nZXQoaSk7XG4gICAgICB2YXIgYiA9IGNhbWxfaW50NjRfdG9fYnl0ZXMoY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0KGNvbXBsZXhbMV0pKTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgODsgaisrKSB3cml0ZXIud3JpdGUgKDgsIGJbal0pO1xuICAgICAgdmFyIGIgPSBjYW1sX2ludDY0X3RvX2J5dGVzKGNhbWxfaW50NjRfYml0c19vZl9mbG9hdChjb21wbGV4WzJdKSk7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDg7IGorKykgd3JpdGVyLndyaXRlICg4LCBiW2pdKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIH1cbiAgc3pbMF0gPSAoNCArIGJhLmRpbXMubGVuZ3RoKSAqIDQ7XG4gIHN6WzFdID0gKDQgKyBiYS5kaW1zLmxlbmd0aCkgKiA4O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2Rlc2VyaWFsaXplXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUsIGNhbWxfZmFpbHdpdGhcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZ2V0X3NpemVcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfYnl0ZXMsIGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0c1xuLy9SZXF1aXJlczogY2FtbF9pbnQzMl9mbG9hdF9vZl9iaXRzXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2NyZWF0ZV9idWZmZXJcbmZ1bmN0aW9uIGNhbWxfYmFfZGVzZXJpYWxpemUocmVhZGVyLCBzeiwgbmFtZSl7XG4gIHZhciBudW1fZGltcyA9IHJlYWRlci5yZWFkMzJzKCk7XG4gIGlmIChudW1fZGltcyA8IDAgfHwgbnVtX2RpbXMgPiAxNilcbiAgICBjYW1sX2ZhaWx3aXRoKFwiaW5wdXRfdmFsdWU6IHdyb25nIG51bWJlciBvZiBiaWdhcnJheSBkaW1lbnNpb25zXCIpO1xuICB2YXIgdGFnID0gcmVhZGVyLnJlYWQzMnMoKTtcbiAgdmFyIGtpbmQgPSB0YWcgJiAweGZmXG4gIHZhciBsYXlvdXQgPSAodGFnID4+IDgpICYgMTtcbiAgdmFyIGRpbXMgPSBbXVxuICBpZihuYW1lID09IFwiX2JpZ2FycjAyXCIpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1fZGltczsgaSsrKSB7XG4gICAgICB2YXIgc2l6ZV9kaW0gPSByZWFkZXIucmVhZDE2dSgpO1xuICAgICAgaWYoc2l6ZV9kaW0gPT0gMHhmZmZmKXtcbiAgICAgICAgdmFyIHNpemVfZGltX2hpID0gcmVhZGVyLnJlYWQzMnUoKTtcbiAgICAgICAgdmFyIHNpemVfZGltX2xvID0gcmVhZGVyLnJlYWQzMnUoKTtcbiAgICAgICAgaWYoc2l6ZV9kaW1faGkgIT0gMClcbiAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwiaW5wdXRfdmFsdWU6IGJpZ2FycmF5IGRpbWVuc2lvbiBvdmVyZmxvdyBpbiAzMmJpdFwiKTtcbiAgICAgICAgc2l6ZV9kaW0gPSBzaXplX2RpbV9sbztcbiAgICAgIH1cbiAgICAgIGRpbXMucHVzaChzaXplX2RpbSk7XG4gICAgfVxuICBlbHNlXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1fZGltczsgaSsrKSBkaW1zLnB1c2gocmVhZGVyLnJlYWQzMnUoKSk7XG4gIHZhciBzaXplID0gY2FtbF9iYV9nZXRfc2l6ZShkaW1zKTtcbiAgdmFyIGRhdGEgPSBjYW1sX2JhX2NyZWF0ZV9idWZmZXIoa2luZCwgc2l6ZSk7XG4gIHZhciBiYSA9IGNhbWxfYmFfY3JlYXRlX3Vuc2FmZShraW5kLCBsYXlvdXQsIGRpbXMsIGRhdGEpO1xuICBzd2l0Y2goa2luZCl7XG4gIGNhc2UgMjogIC8vSW50OEFycmF5XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICBkYXRhW2ldID0gcmVhZGVyLnJlYWQ4cygpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAzOiAgLy9VaW50OEFycmF5XG4gIGNhc2UgMTI6IC8vVWludDhBcnJheVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspe1xuICAgICAgZGF0YVtpXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgNDogIC8vIEludDE2QXJyYXlcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIGRhdGFbaV0gPSByZWFkZXIucmVhZDE2cygpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSA1OiAgLy8gVWludDE2QXJyYXlcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIGRhdGFbaV0gPSByZWFkZXIucmVhZDE2dSgpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSA2OiAgLy8gSW50MzJBcnJheSAoaW50MzIpXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICBkYXRhW2ldID0gcmVhZGVyLnJlYWQzMnMoKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgODogIC8vIEludDMyQXJyYXkgKGludClcbiAgY2FzZSA5OiAgLy8gSW50MzJBcnJheSAobmF0aXZlaW50KVxuICAgIHZhciBzaXh0eSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICBpZihzaXh0eSkgY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiBjYW5ub3QgcmVhZCBiaWdhcnJheSB3aXRoIDY0LWJpdCBPQ2FtbCBpbnRzXCIpO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspe1xuICAgICAgZGF0YVtpXSA9IHJlYWRlci5yZWFkMzJzKCk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDc6IC8vIChpbnQ2NClcbiAgICB2YXIgdCA9IG5ldyBBcnJheSg4KTs7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICBmb3IgKHZhciBqID0gMDtqIDwgODtqKyspIHRbal0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICB2YXIgaW50NjQgPSBjYW1sX2ludDY0X29mX2J5dGVzKHQpO1xuICAgICAgYmEuc2V0KGksaW50NjQpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAxOiAgLy8gRmxvYXQ2NEFycmF5XG4gICAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7O1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspe1xuICAgICAgZm9yICh2YXIgaiA9IDA7aiA8IDg7aisrKSB0W2pdID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgdmFyIGYgPSBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMoY2FtbF9pbnQ2NF9vZl9ieXRlcyh0KSk7XG4gICAgICBiYS5zZXQoaSxmKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMDogIC8vIEZsb2F0MzJBcnJheVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspe1xuICAgICAgdmFyIGYgPSBjYW1sX2ludDMyX2Zsb2F0X29mX2JpdHMocmVhZGVyLnJlYWQzMnMoKSk7XG4gICAgICBiYS5zZXQoaSxmKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMTA6IC8vIEZsb2F0MzJBcnJheSAoY29tcGxleDMyKVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspe1xuICAgICAgdmFyIHJlID0gY2FtbF9pbnQzMl9mbG9hdF9vZl9iaXRzKHJlYWRlci5yZWFkMzJzKCkpO1xuICAgICAgdmFyIGltID0gY2FtbF9pbnQzMl9mbG9hdF9vZl9iaXRzKHJlYWRlci5yZWFkMzJzKCkpO1xuICAgICAgYmEuc2V0KGksWzI1NCxyZSxpbV0pO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAxMTogLy8gRmxvYXQ2NEFycmF5IChjb21wbGV4NjQpXG4gICAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7O1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspe1xuICAgICAgZm9yICh2YXIgaiA9IDA7aiA8IDg7aisrKSB0W2pdID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgdmFyIHJlID0gY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzKGNhbWxfaW50NjRfb2ZfYnl0ZXModCkpO1xuICAgICAgZm9yICh2YXIgaiA9IDA7aiA8IDg7aisrKSB0W2pdID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgdmFyIGltID0gY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzKGNhbWxfaW50NjRfb2ZfYnl0ZXModCkpO1xuICAgICAgYmEuc2V0KGksWzI1NCxyZSxpbV0pO1xuICAgIH1cbiAgICBicmVha1xuICB9XG4gIHN6WzBdID0gKDQgKyBudW1fZGltcykgKiA0O1xuICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGtpbmQsIGxheW91dCwgZGltcywgZGF0YSk7XG59XG5cbi8vRGVwcmVjYXRlZFxuLy9Qcm92aWRlczogY2FtbF9iYV9jcmVhdGVfZnJvbVxuLy9SZXF1aXJlczogY2FtbF9iYV9jcmVhdGVfdW5zYWZlLCBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnRcbmZ1bmN0aW9uIGNhbWxfYmFfY3JlYXRlX2Zyb20oZGF0YTEsIGRhdGEyLCBqc3R5cCwga2luZCwgbGF5b3V0LCBkaW1zKXtcbiAgaWYoZGF0YTIgfHwgY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudChraW5kKSA9PSAyKXtcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJjYW1sX2JhX2NyZWF0ZV9mcm9tOiB1c2UgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZVwiKTtcbiAgfVxuICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGtpbmQsIGxheW91dCwgZGltcywgZGF0YTEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2hhc2ggY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZ2V0X3NpemUsIGNhbWxfaGFzaF9taXhfaW50LCBjYW1sX2hhc2hfbWl4X2Zsb2F0XG5mdW5jdGlvbiBjYW1sX2JhX2hhc2goYmEpe1xuICB2YXIgbnVtX2VsdHMgPSBjYW1sX2JhX2dldF9zaXplKGJhLmRpbXMpO1xuICB2YXIgaCA9IDA7XG4gIHN3aXRjaChiYS5raW5kKXtcbiAgY2FzZSAyOiAgLy9JbnQ4QXJyYXlcbiAgY2FzZSAzOiAgLy9VaW50OEFycmF5XG4gIGNhc2UgMTI6IC8vVWludDhBcnJheVxuICAgIGlmKG51bV9lbHRzID4gMjU2KSBudW1fZWx0cyA9IDI1NjtcbiAgICB2YXIgdyA9IDAsIGkgPTA7XG4gICAgZm9yKGkgPSAwOyBpICsgNCA8PSBiYS5kYXRhLmxlbmd0aDsgaSs9NCl7XG4gICAgICB3ID0gYmEuZGF0YVtpKzBdIHwgKGJhLmRhdGFbaSsxXSA8PCA4KSB8IChiYS5kYXRhW2krMl0gPDwgMTYpIHwgKGJhLmRhdGFbaSszXSA8PCAyNCk7XG4gICAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCx3KTtcbiAgICB9XG4gICAgdyA9IDA7XG4gICAgc3dpdGNoIChudW1fZWx0cyAmIDMpIHtcbiAgICBjYXNlIDM6IHcgID0gYmEuZGF0YVtpKzJdIDw8IDE2OyAgICAvKiBmYWxsdGhyb3VnaCAqL1xuICAgIGNhc2UgMjogdyB8PSBiYS5kYXRhW2krMV0gPDwgODsgICAgIC8qIGZhbGx0aHJvdWdoICovXG4gICAgY2FzZSAxOiB3IHw9IGJhLmRhdGFbaSswXTtcbiAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCB3KTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgNDogIC8vIEludDE2QXJyYXlcbiAgY2FzZSA1OiAgLy8gVWludDE2QXJyYXlcbiAgICBpZihudW1fZWx0cyA+IDEyOCkgbnVtX2VsdHMgPSAxMjg7XG4gICAgdmFyIHcgPSAwLCBpID0wO1xuICAgIGZvcihpID0gMDsgaSArIDIgPD0gYmEuZGF0YS5sZW5ndGg7IGkrPTIpe1xuICAgICAgdyA9IGJhLmRhdGFbaSswXSB8IChiYS5kYXRhW2krMV0gPDwgMTYpO1xuICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsdyk7XG4gICAgfVxuICAgIGlmICgobnVtX2VsdHMgJiAxKSAhPSAwKVxuICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIGJhLmRhdGFbaV0pO1xuICAgIGJyZWFrO1xuICBjYXNlIDY6ICAvLyBJbnQzMkFycmF5IChpbnQzMilcbiAgICBpZiAobnVtX2VsdHMgPiA2NCkgbnVtX2VsdHMgPSA2NDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9lbHRzOyBpKyspIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCBiYS5kYXRhW2ldKTtcbiAgICBicmVhaztcbiAgY2FzZSA4OiAgLy8gSW50MzJBcnJheSAoaW50KVxuICBjYXNlIDk6ICAvLyBJbnQzMkFycmF5IChuYXRpdmVpbnQpXG4gICAgaWYgKG51bV9lbHRzID4gNjQpIG51bV9lbHRzID0gNjQ7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1fZWx0czsgaSsrKSBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgYmEuZGF0YVtpXSk7XG4gICAgYnJlYWs7XG4gIGNhc2UgNzogIC8vIEludDMyQXJyYXkgKGludDY0KVxuICAgIGlmIChudW1fZWx0cyA+IDMyKSBudW1fZWx0cyA9IDMyO1xuICAgIG51bV9lbHRzICo9IDJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9lbHRzOyBpKyspIHtcbiAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCBiYS5kYXRhW2ldKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMTA6IC8vIEZsb2F0MzJBcnJheSAoY29tcGxleDMyKVxuICAgIG51bV9lbHRzICo9MjsgLyogZmFsbHRocm91Z2ggKi9cbiAgY2FzZSAwOiAgLy8gRmxvYXQzMkFycmF5XG4gICAgaWYgKG51bV9lbHRzID4gNjQpIG51bV9lbHRzID0gNjQ7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1fZWx0czsgaSsrKSBoID0gY2FtbF9oYXNoX21peF9mbG9hdChoLCBiYS5kYXRhW2ldKTtcbiAgICBicmVhaztcbiAgY2FzZSAxMTogLy8gRmxvYXQ2NEFycmF5IChjb21wbGV4NjQpXG4gICAgbnVtX2VsdHMgKj0yOyAvKiBmYWxsdGhyb3VnaCAqL1xuICBjYXNlIDE6ICAvLyBGbG9hdDY0QXJyYXlcbiAgICBpZiAobnVtX2VsdHMgPiAzMikgbnVtX2VsdHMgPSAzMjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9lbHRzOyBpKyspIGggPSBjYW1sX2hhc2hfbWl4X2Zsb2F0KGgsIGJhLmRhdGFbaV0pO1xuICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiBoO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3RvX3R5cGVkX2FycmF5IG11dGFibGVcbmZ1bmN0aW9uIGNhbWxfYmFfdG9fdHlwZWRfYXJyYXkoYmEpe1xuICByZXR1cm4gYmEuZGF0YTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9raW5kX29mX3R5cGVkX2FycmF5IG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9iYV9raW5kX29mX3R5cGVkX2FycmF5KHRhKXtcbiAgdmFyIGcgPSBqb29fZ2xvYmFsX29iamVjdDtcbiAgdmFyIGtpbmQ7XG4gIGlmICh0YSBpbnN0YW5jZW9mIGcuRmxvYXQzMkFycmF5KSBraW5kID0gMDtcbiAgZWxzZSBpZiAodGEgaW5zdGFuY2VvZiBnLkZsb2F0NjRBcnJheSkga2luZCA9IDE7XG4gIGVsc2UgaWYgKHRhIGluc3RhbmNlb2YgZy5JbnQ4QXJyYXkpIGtpbmQgPSAyO1xuICBlbHNlIGlmICh0YSBpbnN0YW5jZW9mIGcuVWludDhBcnJheSkga2luZCA9IDM7XG4gIGVsc2UgaWYgKHRhIGluc3RhbmNlb2YgZy5JbnQxNkFycmF5KSBraW5kID0gNDtcbiAgZWxzZSBpZiAodGEgaW5zdGFuY2VvZiBnLlVpbnQxNkFycmF5KSBraW5kID0gNTtcbiAgZWxzZSBpZiAodGEgaW5zdGFuY2VvZiBnLkludDMyQXJyYXkpIGtpbmQgPSA2O1xuICBlbHNlIGlmICh0YSBpbnN0YW5jZW9mIGcuVWludDMyQXJyYXkpIGtpbmQgPSA2O1xuICBlbHNlIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNhbWxfYmFfa2luZF9vZl90eXBlZF9hcnJheTogdW5zdXBwb3J0ZWQga2luZFwiKTtcbiAgcmV0dXJuIGtpbmQ7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZnJvbV90eXBlZF9hcnJheSBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2tpbmRfb2ZfdHlwZWRfYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfYmFfY3JlYXRlX3Vuc2FmZVxuZnVuY3Rpb24gY2FtbF9iYV9mcm9tX3R5cGVkX2FycmF5KHRhKXtcbiAgdmFyIGtpbmQgPSBjYW1sX2JhX2tpbmRfb2ZfdHlwZWRfYXJyYXkodGEpO1xuICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGtpbmQsIDAsIFt0YS5sZW5ndGhdLCB0YSk7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBsaWJyYXJ5XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwIErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vLy8vLy8vLy8vLy8gSnNsaWJcblxuLy9Qcm92aWRlczogY2FtbF9qc19wdXJlX2V4cHIgY29uc3RcbmZ1bmN0aW9uIGNhbWxfanNfcHVyZV9leHByIChmKSB7IHJldHVybiBmKCk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9qc19zZXQgKG11dGFibGUsIGNvbnN0LCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfc2V0KG8sZix2KSB7IG9bZl09djtyZXR1cm4gMH1cbi8vUHJvdmlkZXM6IGNhbWxfanNfZ2V0IG11dGFibGUgKGNvbnN0LCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfZ2V0KG8sZikgeyByZXR1cm4gb1tmXTsgfVxuLy9Qcm92aWRlczogY2FtbF9qc19kZWxldGUgKG11dGFibGUsIGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc19kZWxldGUobyxmKSB7IGRlbGV0ZSBvW2ZdOyByZXR1cm4gMH1cblxuLy9Qcm92aWRlczogY2FtbF9qc19pbnN0YW5jZW9mIChjb25zdCwgY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX2luc3RhbmNlb2YobyxjKSB7IHJldHVybiBvIGluc3RhbmNlb2YgYzsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3R5cGVvZiAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX3R5cGVvZihvKSB7IHJldHVybiB0eXBlb2YgbzsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX29uX2llIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2pzX29uX2llICgpIHtcbiAgdmFyIHVhID1cbiAgICAgIGpvb19nbG9iYWxfb2JqZWN0Lm5hdmlnYXRvcj9qb29fZ2xvYmFsX29iamVjdC5uYXZpZ2F0b3IudXNlckFnZW50OlwiXCI7XG4gIHJldHVybiB1YS5pbmRleE9mKFwiTVNJRVwiKSAhPSAtMSAmJiB1YS5pbmRleE9mKFwiT3BlcmFcIikgIT0gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9qc19odG1sX2VzY2FwZSBjb25zdCAoY29uc3QpXG52YXIgY2FtbF9qc19yZWdleHBzID0geyBhbXA6LyYvZywgbHQ6LzwvZywgcXVvdDovXFxcIi9nLCBhbGw6L1smPFxcXCJdLyB9O1xuZnVuY3Rpb24gY2FtbF9qc19odG1sX2VzY2FwZSAocykge1xuICBpZiAoIWNhbWxfanNfcmVnZXhwcy5hbGwudGVzdChzKSkgcmV0dXJuIHM7XG4gIHJldHVybiBzLnJlcGxhY2UoY2FtbF9qc19yZWdleHBzLmFtcCwgXCImYW1wO1wiKVxuICAgIC5yZXBsYWNlKGNhbWxfanNfcmVnZXhwcy5sdCwgXCImbHQ7XCIpXG4gICAgLnJlcGxhY2UoY2FtbF9qc19yZWdleHBzLnF1b3QsIFwiJnF1b3Q7XCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2h0bWxfZW50aXRpZXNcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfanNfaHRtbF9lbnRpdGllcyhzKSB7XG4gIHZhciBlbnRpdHkgPSAvXiYjP1swLTlhLXpBLVpdKzskL1xuICBpZihzLm1hdGNoKGVudGl0eSkpXG4gIHtcbiAgICB2YXIgc3RyLCB0ZW1wID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpO1xuICAgIHRlbXAuaW5uZXJIVE1MPSBzO1xuICAgIHN0cj0gdGVtcC50ZXh0Q29udGVudCB8fCB0ZW1wLmlubmVyVGV4dDtcbiAgICB0ZW1wPW51bGw7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuICBlbHNlIHtcbiAgICBjYW1sX2ZhaWx3aXRoKFwiSW52YWxpZCBlbnRpdHkgXCIgKyBzKTtcbiAgfVxufVxuXG4vLy8vLy8vLy8vLyBEZWJ1Z2dpbmcgY29uc29sZVxuLy9Qcm92aWRlczogY2FtbF9qc19nZXRfY29uc29sZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9qc19nZXRfY29uc29sZSAoKSB7XG4gIHZhciBjID0gam9vX2dsb2JhbF9vYmplY3QuY29uc29sZT9qb29fZ2xvYmFsX29iamVjdC5jb25zb2xlOnt9O1xuICB2YXIgbSA9IFtcImxvZ1wiLCBcImRlYnVnXCIsIFwiaW5mb1wiLCBcIndhcm5cIiwgXCJlcnJvclwiLCBcImFzc2VydFwiLCBcImRpclwiLCBcImRpcnhtbFwiLFxuICAgICAgICAgICBcInRyYWNlXCIsIFwiZ3JvdXBcIiwgXCJncm91cENvbGxhcHNlZFwiLCBcImdyb3VwRW5kXCIsIFwidGltZVwiLCBcInRpbWVFbmRcIl07XG4gIGZ1bmN0aW9uIGYgKCkge31cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtLmxlbmd0aDsgaSsrKSBpZiAoIWNbbVtpXV0pIGNbbVtpXV09ZjtcbiAgcmV0dXJuIGM7XG59XG5cbi8vUHJvdmlkZXM6Y2FtbF90cmFtcG9saW5lXG5mdW5jdGlvbiBjYW1sX3RyYW1wb2xpbmUocmVzKSB7XG4gIHZhciBjID0gMTtcbiAgd2hpbGUocmVzICYmIHJlcy5qb29fdHJhbXApe1xuICAgIHJlcyA9IHJlcy5qb29fdHJhbXAuYXBwbHkobnVsbCwgcmVzLmpvb19hcmdzKTtcbiAgICBjKys7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLy9Qcm92aWRlczpjYW1sX3RyYW1wb2xpbmVfcmV0dXJuXG5mdW5jdGlvbiBjYW1sX3RyYW1wb2xpbmVfcmV0dXJuKGYsYXJncykge1xuICByZXR1cm4ge2pvb190cmFtcDpmLGpvb19hcmdzOmFyZ3N9O1xufVxuXG4vL1Byb3ZpZGVzOiBqc19wcmludF9zdGRvdXQgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF91dGYxNl9vZl91dGY4XG5mdW5jdGlvbiBqc19wcmludF9zdGRvdXQocykge1xuICB2YXIgcyA9IGNhbWxfdXRmMTZfb2ZfdXRmOChzKTtcbiAgdmFyIGcgPSBqb29fZ2xvYmFsX29iamVjdDtcbiAgaWYgKGcucHJvY2VzcyAmJiBnLnByb2Nlc3Muc3Rkb3V0ICYmIGcucHJvY2Vzcy5zdGRvdXQud3JpdGUpIHtcbiAgICBnLnByb2Nlc3Muc3Rkb3V0LndyaXRlKHMpXG4gIH0gZWxzZSB7XG4gICAgLy8gRG8gbm90IG91dHB1dCB0aGUgbGFzdCBcXG4gaWYgcHJlc2VudFxuICAgIC8vIGFzIGNvbnNvbGUgbG9nZ2luZyBkaXNwbGF5IGEgbmV3bGluZSBhdCB0aGUgZW5kXG4gICAgaWYocy5jaGFyQ29kZUF0KHMubGVuZ3RoIC0gMSkgPT0gMTApXG4gICAgICBzID0gcy5zdWJzdHIoMCxzLmxlbmd0aCAtIDEgKTtcbiAgICB2YXIgdiA9IGcuY29uc29sZTtcbiAgICB2ICAmJiB2LmxvZyAmJiB2LmxvZyhzKTtcbiAgfVxufVxuLy9Qcm92aWRlczoganNfcHJpbnRfc3RkZXJyIChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfdXRmMTZfb2ZfdXRmOFxuZnVuY3Rpb24ganNfcHJpbnRfc3RkZXJyKHMpIHtcbiAgdmFyIHMgPSBjYW1sX3V0ZjE2X29mX3V0Zjgocyk7XG4gIHZhciBnID0gam9vX2dsb2JhbF9vYmplY3Q7XG4gIGlmIChnLnByb2Nlc3MgJiYgZy5wcm9jZXNzLnN0ZG91dCAmJiBnLnByb2Nlc3Muc3Rkb3V0LndyaXRlKSB7XG4gICAgZy5wcm9jZXNzLnN0ZGVyci53cml0ZShzKVxuICB9IGVsc2Uge1xuICAgIC8vIERvIG5vdCBvdXRwdXQgdGhlIGxhc3QgXFxuIGlmIHByZXNlbnRcbiAgICAvLyBhcyBjb25zb2xlIGxvZ2dpbmcgZGlzcGxheSBhIG5ld2xpbmUgYXQgdGhlIGVuZFxuICAgIGlmKHMuY2hhckNvZGVBdChzLmxlbmd0aCAtIDEpID09IDEwKVxuICAgICAgcyA9IHMuc3Vic3RyKDAscy5sZW5ndGggLSAxICk7XG4gICAgdmFyIHYgPSBnLmNvbnNvbGU7XG4gICAgdiAmJiB2LmVycm9yICYmIHYuZXJyb3Iocyk7XG4gIH1cbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lzX2pzXG5mdW5jdGlvbiBjYW1sX2lzX2pzKCkge1xuICByZXR1cm4gMTtcbn1cblxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfd3JhcF9leGNlcHRpb24gY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9nbG9iYWxfZGF0YSxjYW1sX3N0cmluZ19vZl9qc3N0cmluZyxjYW1sX25hbWVkX3ZhbHVlXG4vL1JlcXVpcmVzOiBjYW1sX3JldHVybl9leG5fY29uc3RhbnRcbmZ1bmN0aW9uIGNhbWxfd3JhcF9leGNlcHRpb24oZSkge1xuICBpZihlIGluc3RhbmNlb2YgQXJyYXkpIHJldHVybiBlO1xuICAvL1N0YWNrX292ZXJmbG93OiBjaHJvbWUsIHNhZmFyaVxuICBpZihqb29fZ2xvYmFsX29iamVjdC5SYW5nZUVycm9yXG4gICAgICYmIGUgaW5zdGFuY2VvZiBqb29fZ2xvYmFsX29iamVjdC5SYW5nZUVycm9yXG4gICAgICYmIGUubWVzc2FnZVxuICAgICAmJiBlLm1lc3NhZ2UubWF0Y2goL21heGltdW0gY2FsbCBzdGFjay9pKSlcbiAgICByZXR1cm4gY2FtbF9yZXR1cm5fZXhuX2NvbnN0YW50KGNhbWxfZ2xvYmFsX2RhdGEuU3RhY2tfb3ZlcmZsb3cpO1xuICAvL1N0YWNrX292ZXJmbG93OiBmaXJlZm94XG4gIGlmKGpvb19nbG9iYWxfb2JqZWN0LkludGVybmFsRXJyb3JcbiAgICAgJiYgZSBpbnN0YW5jZW9mIGpvb19nbG9iYWxfb2JqZWN0LkludGVybmFsRXJyb3JcbiAgICAgJiYgZS5tZXNzYWdlXG4gICAgICYmIGUubWVzc2FnZS5tYXRjaCgvdG9vIG11Y2ggcmVjdXJzaW9uL2kpKVxuICAgIHJldHVybiBjYW1sX3JldHVybl9leG5fY29uc3RhbnQoY2FtbF9nbG9iYWxfZGF0YS5TdGFja19vdmVyZmxvdyk7XG4gIC8vV3JhcCBFcnJvciBpbiBKcy5FcnJvciBleGNlcHRpb25cbiAgaWYoZSBpbnN0YW5jZW9mIGpvb19nbG9iYWxfb2JqZWN0LkVycm9yICYmIGNhbWxfbmFtZWRfdmFsdWUoXCJqc0Vycm9yXCIpKVxuICAgIHJldHVybiBbMCxjYW1sX25hbWVkX3ZhbHVlKFwianNFcnJvclwiKSxlXTtcbiAgLy9mYWxsYmFjazogd3JhcHBlZCBpbiBGYWlsdXJlXG4gIHJldHVybiBbMCxjYW1sX2dsb2JhbF9kYXRhLkZhaWx1cmUsY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcgKFN0cmluZyhlKSldO1xufVxuXG4vLyBFeHBlcmltZW50YWxcbi8vUHJvdmlkZXM6IGNhbWxfZXhuX3dpdGhfanNfYmFja3RyYWNlXG4vL1JlcXVpcmVzOiBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX2V4bl93aXRoX2pzX2JhY2t0cmFjZShleG4sIGZvcmNlKSB7XG4gIC8vbmV2ZXIgcmVyYWlzZSBmb3IgY29uc3RhbnQgZXhuXG4gIGlmKCFleG4uanNfZXJyb3IgfHwgZm9yY2UgfHwgZXhuWzBdID09IDI0OCkgZXhuLmpzX2Vycm9yID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0LkVycm9yKFwiSnMgZXhjZXB0aW9uIGNvbnRhaW5pbmcgYmFja3RyYWNlXCIpO1xuICByZXR1cm4gZXhuO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2Vycm9yX29mX2V4Y2VwdGlvblxuZnVuY3Rpb24gY2FtbF9qc19lcnJvcl9vZl9leGNlcHRpb24oZXhuKSB7XG4gIGlmKGV4bi5qc19lcnJvcikgeyByZXR1cm4gZXhuLmpzX2Vycm9yOyB9XG4gIHJldHVybiBudWxsO1xufVxuIiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3RpdmUgQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAqL1xuLyogIGVuIEF1dG9tYXRpcXVlLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCAgICAqL1xuLyogIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlLCB3aXRoICAgICAqL1xuLyogIHRoZSBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiBmaWxlIC4uL0xJQ0VOU0UuICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vKiAkSWQ6IHBhcnNpbmcuYyA4OTgzIDIwMDgtMDgtMDYgMDk6Mzg6MjVaIHhsZXJveSAkICovXG5cbi8qIFRoZSBQREEgYXV0b21hdG9uIGZvciBwYXJzZXJzIGdlbmVyYXRlZCBieSBjYW1seWFjYyAqL1xuXG4vKiBUaGUgcHVzaGRvd24gYXV0b21hdGEgKi9cblxuLy9Qcm92aWRlczogY2FtbF9wYXJzZV9lbmdpbmVcbi8vUmVxdWlyZXM6IGNhbWxfbGV4X2FycmF5XG5mdW5jdGlvbiBjYW1sX3BhcnNlX2VuZ2luZSh0YWJsZXMsIGVudiwgY21kLCBhcmcpXG57XG4gIHZhciBFUlJDT0RFID0gMjU2O1xuXG4gIC8vdmFyIFNUQVJUID0gMDtcbiAgLy92YXIgVE9LRU5fUkVBRCA9IDE7XG4gIC8vdmFyIFNUQUNLU19HUk9XTl8xID0gMjtcbiAgLy92YXIgU1RBQ0tTX0dST1dOXzIgPSAzO1xuICAvL3ZhciBTRU1BTlRJQ19BQ1RJT05fQ09NUFVURUQgPSA0O1xuICAvL3ZhciBFUlJPUl9ERVRFQ1RFRCA9IDU7XG4gIHZhciBsb29wID0gNjtcbiAgdmFyIHRlc3RzaGlmdCA9IDc7XG4gIHZhciBzaGlmdCA9IDg7XG4gIHZhciBzaGlmdF9yZWNvdmVyID0gOTtcbiAgdmFyIHJlZHVjZSA9IDEwO1xuXG4gIHZhciBSRUFEX1RPS0VOID0gMDtcbiAgdmFyIFJBSVNFX1BBUlNFX0VSUk9SID0gMTtcbiAgdmFyIEdST1dfU1RBQ0tTXzEgPSAyO1xuICB2YXIgR1JPV19TVEFDS1NfMiA9IDM7XG4gIHZhciBDT01QVVRFX1NFTUFOVElDX0FDVElPTiA9IDQ7XG4gIHZhciBDQUxMX0VSUk9SX0ZVTkNUSU9OID0gNTtcblxuICB2YXIgZW52X3Nfc3RhY2sgPSAxO1xuICB2YXIgZW52X3Zfc3RhY2sgPSAyO1xuICB2YXIgZW52X3N5bWJfc3RhcnRfc3RhY2sgPSAzO1xuICB2YXIgZW52X3N5bWJfZW5kX3N0YWNrID0gNDtcbiAgdmFyIGVudl9zdGFja3NpemUgPSA1O1xuICB2YXIgZW52X3N0YWNrYmFzZSA9IDY7XG4gIHZhciBlbnZfY3Vycl9jaGFyID0gNztcbiAgdmFyIGVudl9sdmFsID0gODtcbiAgdmFyIGVudl9zeW1iX3N0YXJ0ID0gOTtcbiAgdmFyIGVudl9zeW1iX2VuZCA9IDEwO1xuICB2YXIgZW52X2FzcCA9IDExO1xuICB2YXIgZW52X3J1bGVfbGVuID0gMTI7XG4gIHZhciBlbnZfcnVsZV9udW1iZXIgPSAxMztcbiAgdmFyIGVudl9zcCA9IDE0O1xuICB2YXIgZW52X3N0YXRlID0gMTU7XG4gIHZhciBlbnZfZXJyZmxhZyA9IDE2O1xuXG4gIC8vIHZhciBfdGJsX2FjdGlvbnMgPSAxO1xuICB2YXIgdGJsX3RyYW5zbF9jb25zdCA9IDI7XG4gIHZhciB0YmxfdHJhbnNsX2Jsb2NrID0gMztcbiAgdmFyIHRibF9saHMgPSA0O1xuICB2YXIgdGJsX2xlbiA9IDU7XG4gIHZhciB0YmxfZGVmcmVkID0gNjtcbiAgdmFyIHRibF9kZ290byA9IDc7XG4gIHZhciB0Ymxfc2luZGV4ID0gODtcbiAgdmFyIHRibF9yaW5kZXggPSA5O1xuICB2YXIgdGJsX2dpbmRleCA9IDEwO1xuICB2YXIgdGJsX3RhYmxlc2l6ZSA9IDExO1xuICB2YXIgdGJsX3RhYmxlID0gMTI7XG4gIHZhciB0YmxfY2hlY2sgPSAxMztcbiAgLy8gdmFyIF90YmxfZXJyb3JfZnVuY3Rpb24gPSAxNDtcbiAgLy8gdmFyIF90YmxfbmFtZXNfY29uc3QgPSAxNTtcbiAgLy8gdmFyIF90YmxfbmFtZXNfYmxvY2sgPSAxNjtcblxuICBpZiAoIXRhYmxlcy5kZ290bykge1xuICAgIHRhYmxlcy5kZWZyZWQgPSBjYW1sX2xleF9hcnJheSAodGFibGVzW3RibF9kZWZyZWRdKTtcbiAgICB0YWJsZXMuc2luZGV4ID0gY2FtbF9sZXhfYXJyYXkgKHRhYmxlc1t0Ymxfc2luZGV4XSk7XG4gICAgdGFibGVzLmNoZWNrICA9IGNhbWxfbGV4X2FycmF5ICh0YWJsZXNbdGJsX2NoZWNrXSk7XG4gICAgdGFibGVzLnJpbmRleCA9IGNhbWxfbGV4X2FycmF5ICh0YWJsZXNbdGJsX3JpbmRleF0pO1xuICAgIHRhYmxlcy50YWJsZSAgPSBjYW1sX2xleF9hcnJheSAodGFibGVzW3RibF90YWJsZV0pO1xuICAgIHRhYmxlcy5sZW4gICAgPSBjYW1sX2xleF9hcnJheSAodGFibGVzW3RibF9sZW5dKTtcbiAgICB0YWJsZXMubGhzICAgID0gY2FtbF9sZXhfYXJyYXkgKHRhYmxlc1t0YmxfbGhzXSk7XG4gICAgdGFibGVzLmdpbmRleCA9IGNhbWxfbGV4X2FycmF5ICh0YWJsZXNbdGJsX2dpbmRleF0pO1xuICAgIHRhYmxlcy5kZ290byAgPSBjYW1sX2xleF9hcnJheSAodGFibGVzW3RibF9kZ290b10pO1xuICB9XG5cbiAgdmFyIHJlcyA9IDAsIG4sIG4xLCBuMiwgc3RhdGUxO1xuXG4gIC8vIFJFU1RPUkVcbiAgdmFyIHNwID0gZW52W2Vudl9zcF07XG4gIHZhciBzdGF0ZSA9IGVudltlbnZfc3RhdGVdO1xuICB2YXIgZXJyZmxhZyA9IGVudltlbnZfZXJyZmxhZ107XG5cbiAgZXhpdDpmb3IgKDs7KSB7XG4gICAgc3dpdGNoKGNtZCkge1xuICAgIGNhc2UgMDovL1NUQVJUOlxuICAgICAgc3RhdGUgPSAwO1xuICAgICAgZXJyZmxhZyA9IDA7XG4gICAgICAvLyBGYWxsIHRocm91Z2hcblxuICAgIGNhc2UgNjovL2xvb3A6XG4gICAgICBuID0gdGFibGVzLmRlZnJlZFtzdGF0ZV07XG4gICAgICBpZiAobiAhPSAwKSB7IGNtZCA9IHJlZHVjZTsgYnJlYWs7IH1cbiAgICAgIGlmIChlbnZbZW52X2N1cnJfY2hhcl0gPj0gMCkgeyBjbWQgPSB0ZXN0c2hpZnQ7IGJyZWFrOyB9XG4gICAgICByZXMgPSBSRUFEX1RPS0VOO1xuICAgICAgYnJlYWsgZXhpdDtcbiAgICAgIC8qIFRoZSBNTCBjb2RlIGNhbGxzIHRoZSBsZXhlciBhbmQgdXBkYXRlcyAqL1xuICAgICAgLyogc3ltYl9zdGFydCBhbmQgc3ltYl9lbmQgKi9cbiAgICBjYXNlIDE6Ly9UT0tFTl9SRUFEOlxuICAgICAgaWYgKGFyZyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIGVudltlbnZfY3Vycl9jaGFyXSA9IHRhYmxlc1t0YmxfdHJhbnNsX2Jsb2NrXVthcmdbMF0gKyAxXTtcbiAgICAgICAgZW52W2Vudl9sdmFsXSA9IGFyZ1sxXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVudltlbnZfY3Vycl9jaGFyXSA9IHRhYmxlc1t0YmxfdHJhbnNsX2NvbnN0XVthcmcgKyAxXTtcbiAgICAgICAgZW52W2Vudl9sdmFsXSA9IDA7XG4gICAgICB9XG4gICAgICAvLyBGYWxsIHRocm91Z2hcblxuICAgIGNhc2UgNzovL3Rlc3RzaGlmdDpcbiAgICAgIG4xID0gdGFibGVzLnNpbmRleFtzdGF0ZV07XG4gICAgICBuMiA9IG4xICsgZW52W2Vudl9jdXJyX2NoYXJdO1xuICAgICAgaWYgKG4xICE9IDAgJiYgbjIgPj0gMCAmJiBuMiA8PSB0YWJsZXNbdGJsX3RhYmxlc2l6ZV0gJiZcbiAgICAgICAgICB0YWJsZXMuY2hlY2tbbjJdID09IGVudltlbnZfY3Vycl9jaGFyXSkge1xuICAgICAgICBjbWQgPSBzaGlmdDsgYnJlYWs7XG4gICAgICB9XG4gICAgICBuMSA9IHRhYmxlcy5yaW5kZXhbc3RhdGVdO1xuICAgICAgbjIgPSBuMSArIGVudltlbnZfY3Vycl9jaGFyXTtcbiAgICAgIGlmIChuMSAhPSAwICYmIG4yID49IDAgJiYgbjIgPD0gdGFibGVzW3RibF90YWJsZXNpemVdICYmXG4gICAgICAgICAgdGFibGVzLmNoZWNrW24yXSA9PSBlbnZbZW52X2N1cnJfY2hhcl0pIHtcbiAgICAgICAgbiA9IHRhYmxlcy50YWJsZVtuMl07XG4gICAgICAgIGNtZCA9IHJlZHVjZTsgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoZXJyZmxhZyA8PSAwKSB7XG4gICAgICAgIHJlcyA9IENBTExfRVJST1JfRlVOQ1RJT047XG4gICAgICAgIGJyZWFrIGV4aXQ7XG4gICAgICB9XG4gICAgICAvLyBGYWxsIHRocm91Z2hcbiAgICAgIC8qIFRoZSBNTCBjb2RlIGNhbGxzIHRoZSBlcnJvciBmdW5jdGlvbiAqL1xuICAgIGNhc2UgNTovL0VSUk9SX0RFVEVDVEVEOlxuICAgICAgaWYgKGVycmZsYWcgPCAzKSB7XG4gICAgICAgIGVycmZsYWcgPSAzO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgc3RhdGUxID0gZW52W2Vudl9zX3N0YWNrXVtzcCArIDFdO1xuICAgICAgICAgIG4xID0gdGFibGVzLnNpbmRleFtzdGF0ZTFdO1xuICAgICAgICAgIG4yID0gbjEgKyBFUlJDT0RFO1xuICAgICAgICAgIGlmIChuMSAhPSAwICYmIG4yID49IDAgJiYgbjIgPD0gdGFibGVzW3RibF90YWJsZXNpemVdICYmXG4gICAgICAgICAgICAgIHRhYmxlcy5jaGVja1tuMl0gPT0gRVJSQ09ERSkge1xuICAgICAgICAgICAgY21kID0gc2hpZnRfcmVjb3ZlcjsgYnJlYWs7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChzcCA8PSBlbnZbZW52X3N0YWNrYmFzZV0pIHJldHVybiBSQUlTRV9QQVJTRV9FUlJPUjtcbiAgICAgICAgICAgIC8qIFRoZSBNTCBjb2RlIHJhaXNlcyBQYXJzZV9lcnJvciAqL1xuICAgICAgICAgICAgc3AtLTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChlbnZbZW52X2N1cnJfY2hhcl0gPT0gMCkgcmV0dXJuIFJBSVNFX1BBUlNFX0VSUk9SO1xuICAgICAgICAvKiBUaGUgTUwgY29kZSByYWlzZXMgUGFyc2VfZXJyb3IgKi9cbiAgICAgICAgZW52W2Vudl9jdXJyX2NoYXJdID0gLTE7XG4gICAgICAgIGNtZCA9IGxvb3A7IGJyZWFrO1xuICAgICAgfVxuICAgICAgLy8gRmFsbCB0aHJvdWdoXG4gICAgY2FzZSA4Oi8vc2hpZnQ6XG4gICAgICBlbnZbZW52X2N1cnJfY2hhcl0gPSAtMTtcbiAgICAgIGlmIChlcnJmbGFnID4gMCkgZXJyZmxhZy0tO1xuICAgICAgLy8gRmFsbCB0aHJvdWdoXG4gICAgY2FzZSA5Oi8vc2hpZnRfcmVjb3ZlcjpcbiAgICAgIHN0YXRlID0gdGFibGVzLnRhYmxlW24yXTtcbiAgICAgIHNwKys7XG4gICAgICBpZiAoc3AgPj0gZW52W2Vudl9zdGFja3NpemVdKSB7XG4gICAgICAgIHJlcyA9IEdST1dfU1RBQ0tTXzE7XG4gICAgICAgIGJyZWFrIGV4aXQ7XG4gICAgICB9XG4gICAgICAvLyBGYWxsIHRocm91Z2hcbiAgICAgIC8qIFRoZSBNTCBjb2RlIHJlc2l6ZXMgdGhlIHN0YWNrcyAqL1xuICAgIGNhc2UgMjovL1NUQUNLU19HUk9XTl8xOlxuICAgICAgZW52W2Vudl9zX3N0YWNrXVtzcCArIDFdID0gc3RhdGU7XG4gICAgICBlbnZbZW52X3Zfc3RhY2tdW3NwICsgMV0gPSBlbnZbZW52X2x2YWxdO1xuICAgICAgZW52W2Vudl9zeW1iX3N0YXJ0X3N0YWNrXVtzcCArIDFdID0gZW52W2Vudl9zeW1iX3N0YXJ0XTtcbiAgICAgIGVudltlbnZfc3ltYl9lbmRfc3RhY2tdW3NwICsgMV0gPSBlbnZbZW52X3N5bWJfZW5kXTtcbiAgICAgIGNtZCA9IGxvb3A7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgMTA6Ly9yZWR1Y2U6XG4gICAgICB2YXIgbSA9IHRhYmxlcy5sZW5bbl07XG4gICAgICBlbnZbZW52X2FzcF0gPSBzcDtcbiAgICAgIGVudltlbnZfcnVsZV9udW1iZXJdID0gbjtcbiAgICAgIGVudltlbnZfcnVsZV9sZW5dID0gbTtcbiAgICAgIHNwID0gc3AgLSBtICsgMTtcbiAgICAgIG0gPSB0YWJsZXMubGhzW25dO1xuICAgICAgc3RhdGUxID0gZW52W2Vudl9zX3N0YWNrXVtzcF07XG4gICAgICBuMSA9IHRhYmxlcy5naW5kZXhbbV07XG4gICAgICBuMiA9IG4xICsgc3RhdGUxO1xuICAgICAgaWYgKG4xICE9IDAgJiYgbjIgPj0gMCAmJiBuMiA8PSB0YWJsZXNbdGJsX3RhYmxlc2l6ZV0gJiZcbiAgICAgICAgICB0YWJsZXMuY2hlY2tbbjJdID09IHN0YXRlMSlcbiAgICAgICAgc3RhdGUgPSB0YWJsZXMudGFibGVbbjJdO1xuICAgICAgZWxzZVxuICAgICAgICBzdGF0ZSA9IHRhYmxlcy5kZ290b1ttXTtcbiAgICAgIGlmIChzcCA+PSBlbnZbZW52X3N0YWNrc2l6ZV0pIHtcbiAgICAgICAgcmVzID0gR1JPV19TVEFDS1NfMjtcbiAgICAgICAgYnJlYWsgZXhpdDtcbiAgICAgIH1cbiAgICAgIC8vIEZhbGwgdGhyb3VnaFxuICAgICAgLyogVGhlIE1MIGNvZGUgcmVzaXplcyB0aGUgc3RhY2tzICovXG4gICAgY2FzZSAzOi8vU1RBQ0tTX0dST1dOXzI6XG4gICAgICByZXMgPSBDT01QVVRFX1NFTUFOVElDX0FDVElPTjtcbiAgICAgIGJyZWFrIGV4aXQ7XG4gICAgICAvKiBUaGUgTUwgY29kZSBjYWxscyB0aGUgc2VtYW50aWMgYWN0aW9uICovXG4gICAgY2FzZSA0Oi8vU0VNQU5USUNfQUNUSU9OX0NPTVBVVEVEOlxuICAgICAgZW52W2Vudl9zX3N0YWNrXVtzcCArIDFdID0gc3RhdGU7XG4gICAgICBlbnZbZW52X3Zfc3RhY2tdW3NwICsgMV0gPSBhcmc7XG4gICAgICB2YXIgYXNwID0gZW52W2Vudl9hc3BdO1xuICAgICAgZW52W2Vudl9zeW1iX2VuZF9zdGFja11bc3AgKyAxXSA9IGVudltlbnZfc3ltYl9lbmRfc3RhY2tdW2FzcCArIDFdO1xuICAgICAgaWYgKHNwID4gYXNwKSB7XG4gICAgICAgIC8qIFRoaXMgaXMgYW4gZXBzaWxvbiBwcm9kdWN0aW9uLiBUYWtlIHN5bWJfc3RhcnQgZXF1YWwgdG8gc3ltYl9lbmQuICovXG4gICAgICAgIGVudltlbnZfc3ltYl9zdGFydF9zdGFja11bc3AgKyAxXSA9IGVudltlbnZfc3ltYl9lbmRfc3RhY2tdW2FzcCArIDFdO1xuICAgICAgfVxuICAgICAgY21kID0gbG9vcDsgYnJlYWs7XG4gICAgICAvKiBTaG91bGQgbm90IGhhcHBlbiAqL1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gUkFJU0VfUEFSU0VfRVJST1I7XG4gICAgfVxuICB9XG4gIC8vIFNBVkVcbiAgZW52W2Vudl9zcF0gPSBzcDtcbiAgZW52W2Vudl9zdGF0ZV0gPSBzdGF0ZTtcbiAgZW52W2Vudl9lcnJmbGFnXSA9IGVycmZsYWc7XG4gIHJldHVybiByZXM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc2V0X3BhcnNlcl90cmFjZSBjb25zdFxuLy9EdW1teSBmdW5jdGlvbiFcbmZ1bmN0aW9uIGNhbWxfc2V0X3BhcnNlcl90cmFjZSgpIHsgcmV0dXJuIDA7IH1cbiIsIi8vIEpzX29mX29jYW1sIGxpYnJhcnlcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8vLy8vLy8vLy8vLyBKc2xpYjogY29kZSBzcGVjaWZpYyB0byBKc19vZl9vY2FtbFxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2Zyb21fYm9vbCBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX2Zyb21fYm9vbCh4KSB7IHJldHVybiAhIXg7IH1cbi8vUHJvdmlkZXM6IGNhbWxfanNfdG9fYm9vbCBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX3RvX2Jvb2woeCkgeyByZXR1cm4gK3g7IH1cbi8vUHJvdmlkZXM6IGNhbWxfanNfZnJvbV9mbG9hdCBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX2Zyb21fZmxvYXQoeCkgeyByZXR1cm4geDsgfVxuLy9Qcm92aWRlczogY2FtbF9qc190b19mbG9hdCBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX3RvX2Zsb2F0KHgpIHsgcmV0dXJuIHg7IH1cblxuLy9Qcm92aWRlczogY2FtbF9qc19mcm9tX2FycmF5IG11dGFibGUgKHNoYWxsb3cpXG5mdW5jdGlvbiBjYW1sX2pzX2Zyb21fYXJyYXkoYSkge1xuICByZXR1cm4gYS5zbGljZSgxKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfdG9fYXJyYXkgbXV0YWJsZSAoc2hhbGxvdylcbmZ1bmN0aW9uIGNhbWxfanNfdG9fYXJyYXkoYSkge1xuICB2YXIgbGVuID0gYS5sZW5ndGg7XG4gIHZhciBiID0gbmV3IEFycmF5KGxlbisxKTtcbiAgYlswXSA9IDA7XG4gIGZvcih2YXIgaT0wO2k8bGVuO2krKykgYltpKzFdID0gYVtpXTtcbiAgcmV0dXJuIGI7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbGlzdF9vZl9qc19hcnJheSBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX2xpc3Rfb2ZfanNfYXJyYXkoYSl7XG4gIHZhciBsID0gMDtcbiAgZm9yKHZhciBpPWEubGVuZ3RoIC0gMTsgaT49MDsgaS0tKXtcbiAgICB2YXIgZSA9IGFbaV07XG4gICAgbCA9IFswLGUsbF07XG4gIH1cbiAgcmV0dXJuIGxcbn1cblxuLy9Qcm92aWRlczogY2FtbF9saXN0X3RvX2pzX2FycmF5IGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfbGlzdF90b19qc19hcnJheShsKXtcbiAgdmFyIGEgPSBbXTtcbiAgZm9yKDsgbCAhPT0gMDsgbCA9IGxbMl0pIHtcbiAgICBhLnB1c2gobFsxXSk7XG4gIH1cbiAgcmV0dXJuIGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfdmFyIG11dGFibGUgKGNvbnN0KVxuLy9SZXF1aXJlczoganNfcHJpbnRfc3RkZXJyXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc192YXIoeCkge1xuICB2YXIgeCA9IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHgpO1xuICAvL0NoZWNrcyB0aGF0IHggaGFzIHRoZSBmb3JtIGlkZW50Wy5pZGVudF0qXG4gIGlmKCF4Lm1hdGNoKC9eW2EtekEtWl8kXVthLXpBLVpfJDAtOV0qKFxcLlthLXpBLVpfJF1bYS16QS1aXyQwLTldKikqJC8pKXtcbiAgICBqc19wcmludF9zdGRlcnIoXCJjYW1sX2pzX3ZhcjogXFxcIlwiICsgeCArIFwiXFxcIiBpcyBub3QgYSB2YWxpZCBKYXZhU2NyaXB0IHZhcmlhYmxlLiBjb250aW51aW5nIC4uXCIpO1xuICAgIC8vam9vX2dsb2JhbF9vYmplY3QuY29uc29sZS5lcnJvcihcIkpzLlVuc2FmZS5ldmFsX3N0cmluZ1wiKVxuICB9XG4gIHJldHVybiBldmFsKHgpO1xufVxuLy9Qcm92aWRlczogY2FtbF9qc19jYWxsIChjb25zdCwgbXV0YWJsZSwgc2hhbGxvdylcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheVxuZnVuY3Rpb24gY2FtbF9qc19jYWxsKGYsIG8sIGFyZ3MpIHsgcmV0dXJuIGYuYXBwbHkobywgY2FtbF9qc19mcm9tX2FycmF5KGFyZ3MpKTsgfVxuLy9Qcm92aWRlczogY2FtbF9qc19mdW5fY2FsbCAoY29uc3QsIHNoYWxsb3cpXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfanNfZnVuX2NhbGwoZiwgYSkge1xuICBzd2l0Y2ggKGEubGVuZ3RoKSB7XG4gIGNhc2UgMTogcmV0dXJuIGYoKTtcbiAgY2FzZSAyOiByZXR1cm4gZiAoYVsxXSk7XG4gIGNhc2UgMzogcmV0dXJuIGYgKGFbMV0sYVsyXSk7XG4gIGNhc2UgNDogcmV0dXJuIGYgKGFbMV0sYVsyXSxhWzNdKTtcbiAgY2FzZSA1OiByZXR1cm4gZiAoYVsxXSxhWzJdLGFbM10sYVs0XSk7XG4gIGNhc2UgNjogcmV0dXJuIGYgKGFbMV0sYVsyXSxhWzNdLGFbNF0sYVs1XSk7XG4gIGNhc2UgNzogcmV0dXJuIGYgKGFbMV0sYVsyXSxhWzNdLGFbNF0sYVs1XSxhWzZdKTtcbiAgY2FzZSA4OiByZXR1cm4gZiAoYVsxXSxhWzJdLGFbM10sYVs0XSxhWzVdLGFbNl0sYVs3XSk7XG4gIH1cbiAgcmV0dXJuIGYuYXBwbHkobnVsbCwgY2FtbF9qc19mcm9tX2FycmF5KGEpKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfbWV0aF9jYWxsIChtdXRhYmxlLCBjb25zdCwgc2hhbGxvdylcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfanNfbWV0aF9jYWxsKG8sIGYsIGFyZ3MpIHtcbiAgcmV0dXJuIG9bY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcoZildLmFwcGx5KG8sIGNhbWxfanNfZnJvbV9hcnJheShhcmdzKSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX25ldyAoY29uc3QsIHNoYWxsb3cpXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfanNfbmV3KGMsIGEpIHtcbiAgc3dpdGNoIChhLmxlbmd0aCkge1xuICBjYXNlIDE6IHJldHVybiBuZXcgYztcbiAgY2FzZSAyOiByZXR1cm4gbmV3IGMgKGFbMV0pO1xuICBjYXNlIDM6IHJldHVybiBuZXcgYyAoYVsxXSxhWzJdKTtcbiAgY2FzZSA0OiByZXR1cm4gbmV3IGMgKGFbMV0sYVsyXSxhWzNdKTtcbiAgY2FzZSA1OiByZXR1cm4gbmV3IGMgKGFbMV0sYVsyXSxhWzNdLGFbNF0pO1xuICBjYXNlIDY6IHJldHVybiBuZXcgYyAoYVsxXSxhWzJdLGFbM10sYVs0XSxhWzVdKTtcbiAgY2FzZSA3OiByZXR1cm4gbmV3IGMgKGFbMV0sYVsyXSxhWzNdLGFbNF0sYVs1XSxhWzZdKTtcbiAgY2FzZSA4OiByZXR1cm4gbmV3IGMgKGFbMV0sYVsyXSxhWzNdLGFbNF0sYVs1XSxhWzZdLGFbN10pO1xuICB9XG4gIGZ1bmN0aW9uIEYoKSB7IHJldHVybiBjLmFwcGx5KHRoaXMsIGNhbWxfanNfZnJvbV9hcnJheShhKSk7IH1cbiAgRi5wcm90b3R5cGUgPSBjLnByb3RvdHlwZTtcbiAgcmV0dXJuIG5ldyBGO1xufVxuLy9Qcm92aWRlczogY2FtbF9vanNfbmV3X2FyciAoY29uc3QsIHNoYWxsb3cpXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfb2pzX25ld19hcnIoYywgYSkge1xuICBzd2l0Y2ggKGEubGVuZ3RoKSB7XG4gIGNhc2UgMDogcmV0dXJuIG5ldyBjO1xuICBjYXNlIDE6IHJldHVybiBuZXcgYyAoYVswXSk7XG4gIGNhc2UgMjogcmV0dXJuIG5ldyBjIChhWzBdLGFbMV0pO1xuICBjYXNlIDM6IHJldHVybiBuZXcgYyAoYVswXSxhWzFdLGFbMl0pO1xuICBjYXNlIDQ6IHJldHVybiBuZXcgYyAoYVswXSxhWzFdLGFbMl0sYVszXSk7XG4gIGNhc2UgNTogcmV0dXJuIG5ldyBjIChhWzBdLGFbMV0sYVsyXSxhWzNdLGFbNF0pO1xuICBjYXNlIDY6IHJldHVybiBuZXcgYyAoYVswXSxhWzFdLGFbMl0sYVszXSxhWzRdLGFbNV0pO1xuICBjYXNlIDc6IHJldHVybiBuZXcgYyAoYVswXSxhWzFdLGFbMl0sYVszXSxhWzRdLGFbNV0sYVs2XSk7XG4gIH1cbiAgZnVuY3Rpb24gRigpIHsgcmV0dXJuIGMuYXBwbHkodGhpcywgYSk7IH1cbiAgRi5wcm90b3R5cGUgPSBjLnByb3RvdHlwZTtcbiAgcmV0dXJuIG5ldyBGO1xufVxuLy9Qcm92aWRlczogY2FtbF9qc193cmFwX2NhbGxiYWNrIGNvbnN0IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY2FsbF9nZW5cbmZ1bmN0aW9uIGNhbWxfanNfd3JhcF9jYWxsYmFjayhmKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgaWYobGVuID4gMCl7XG4gICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShsZW4pO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIHJldHVybiBjYW1sX2NhbGxfZ2VuKGYsIGFyZ3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY2FtbF9jYWxsX2dlbihmLCBbdW5kZWZpbmVkXSk7XG4gICAgfVxuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfd3JhcF9jYWxsYmFja19hcmd1bWVudHNcbi8vUmVxdWlyZXM6IGNhbWxfY2FsbF9nZW5cbmZ1bmN0aW9uIGNhbWxfanNfd3JhcF9jYWxsYmFja19hcmd1bWVudHMoZikge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkobGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIHJldHVybiBjYW1sX2NhbGxfZ2VuKGYsIFthcmdzXSk7XG4gIH1cbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfd3JhcF9jYWxsYmFja19zdHJpY3QgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfY2FsbF9nZW5cbmZ1bmN0aW9uIGNhbWxfanNfd3JhcF9jYWxsYmFja19zdHJpY3QoYXJpdHksIGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgaWYobiA9PSBhcml0eSAmJiBmLmxlbmd0aCA9PSBhcml0eSkgcmV0dXJuIGYuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcml0eSk7XG4gICAgdmFyIGxlbiA9IE1hdGgubWluKGFyZ3VtZW50cy5sZW5ndGgsIGFyaXR5KVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgcmV0dXJuIGNhbWxfY2FsbF9nZW4oZiwgYXJncyk7XG4gIH07XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFjayBjb25zdCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NhbGxfZ2VuXG5mdW5jdGlvbiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFjayhmKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkobGVuICsgMSk7XG4gICAgYXJnc1swXSA9IHRoaXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgYXJnc1tpKzFdID0gYXJndW1lbnRzW2ldO1xuICAgIHJldHVybiBjYW1sX2NhbGxfZ2VuKGYsYXJncyk7XG4gIH1cbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrX2FyZ3VtZW50cyBjb25zdCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NhbGxfZ2VuXG5mdW5jdGlvbiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja19hcmd1bWVudHMoZikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICByZXR1cm4gY2FtbF9jYWxsX2dlbihmLFt0aGlzLGFyZ3NdKTtcbiAgfVxufVxuLy9Qcm92aWRlczogY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2tfc3RyaWN0IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2NhbGxfZ2VuXG5mdW5jdGlvbiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja19zdHJpY3QoYXJpdHksIGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcml0eSArIDEpO1xuICAgIHZhciBsZW4gPSBNYXRoLm1pbihhcmd1bWVudHMubGVuZ3RoLCBhcml0eSlcbiAgICBhcmdzWzBdID0gdGhpcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSBhcmdzW2krMV0gPSBhcmd1bWVudHNbaV07XG4gICAgcmV0dXJuIGNhbWxfY2FsbF9nZW4oZiwgYXJncyk7XG4gIH07XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja191bnNhZmUgY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jYWxsX2dlblxuZnVuY3Rpb24gY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2tfdW5zYWZlKGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShsZW4gKyAxKTtcbiAgICBhcmdzWzBdID0gdGhpcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSBhcmdzW2krMV0gPSBhcmd1bWVudHNbaV07XG4gICAgcmV0dXJuIGYuYXBwbHkobnVsbCwgYXJncyk7IH1cbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfZXF1YWxzIG11dGFibGUgKGNvbnN0LCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfZXF1YWxzICh4LCB5KSB7IHJldHVybiArKHggPT0geSk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9qc19ldmFsX3N0cmluZyAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc19ldmFsX3N0cmluZyAocykge3JldHVybiBldmFsKGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHMpKTt9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZXhwciAoY29uc3QpXG4vL1JlcXVpcmVzOiBqc19wcmludF9zdGRlcnJcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2pzX2V4cHIocykge1xuICBqc19wcmludF9zdGRlcnIoXCJjYW1sX2pzX2V4cHI6IGZhbGxiYWNrIHRvIHJ1bnRpbWUgZXZhbHVhdGlvblxcblwiKTtcbiAgcmV0dXJuIGV2YWwoY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocykpO31cblxuLy9Qcm92aWRlczogY2FtbF9wdXJlX2pzX2V4cHIgY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczoganNfcHJpbnRfc3RkZXJyXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9wdXJlX2pzX2V4cHIgKHMpe1xuICBqc19wcmludF9zdGRlcnIoXCJjYW1sX3B1cmVfanNfZXhwcjogZmFsbGJhY2sgdG8gcnVudGltZSBldmFsdWF0aW9uXFxuXCIpO1xuICByZXR1cm4gZXZhbChjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhzKSk7fVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX29iamVjdCAob2JqZWN0X2xpdGVyYWwpXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc19vYmplY3QgKGEpIHtcbiAgdmFyIG8gPSB7fTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHAgPSBhW2ldO1xuICAgIG9bY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocFsxXSldID0gcFsyXTtcbiAgfVxuICByZXR1cm4gbztcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2V4cG9ydF92YXJcbmZ1bmN0aW9uIGNhbWxfanNfZXhwb3J0X3ZhciAoKXtcbiAgaWYodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlICYmIG1vZHVsZS5leHBvcnRzKVxuICAgIHJldHVybiBtb2R1bGUuZXhwb3J0c1xuICBlbHNlXG4gICAgcmV0dXJuIGpvb19nbG9iYWxfb2JqZWN0O1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfeG1saHR0cHJlcXVlc3RfY3JlYXRlXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG4vL1dlYWtkZWZcbmZ1bmN0aW9uIGNhbWxfeG1saHR0cHJlcXVlc3RfY3JlYXRlKHVuaXQpe1xuICB2YXIgZyA9IGpvb19nbG9iYWxfb2JqZWN0O1xuICBpZih0eXBlb2YgZy5YTUxIdHRwUmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0cnkgeyByZXR1cm4gbmV3IGcuWE1MSHR0cFJlcXVlc3QgfSBjYXRjaCAoZSkgeyB9O1xuICB9XG4gIGlmKHR5cGVvZiBnLmFjdGl2ZVhPYmplY3QgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdHJ5IHsgcmV0dXJuIG5ldyBnLmFjdGl2ZVhPYmplY3QoXCJNc3htbDIuWE1MSFRUUFwiKSB9IGNhdGNoKGUpeyB9O1xuICAgIHRyeSB7IHJldHVybiBuZXcgZy5hY3RpdmVYT2JqZWN0KFwiTXN4bWwzLlhNTEhUVFBcIikgfSBjYXRjaChlKXsgfTtcbiAgICB0cnkgeyByZXR1cm4gbmV3IGcuYWN0aXZlWE9iamVjdChcIk1pY3Jvc29mdC5YTUxIVFRQXCIpIH0gY2F0Y2goZSl7IH07XG4gIH1cbiAgY2FtbF9mYWlsd2l0aChcIkNhbm5vdCBjcmVhdGUgYSBYTUxIdHRwUmVxdWVzdFwiKTtcbn1cbiIsIi8vUHJvdmlkZXM6IHVuaXhfZ2V0dGltZW9mZGF5XG5mdW5jdGlvbiB1bml4X2dldHRpbWVvZmRheSAoKSB7XG4gIHJldHVybiAobmV3IERhdGUoKSkuZ2V0VGltZSgpIC8gMTAwMDtcbn1cblxuLy9Qcm92aWRlczogdW5peF90aW1lXG4vL1JlcXVpcmVzOiB1bml4X2dldHRpbWVvZmRheVxuZnVuY3Rpb24gdW5peF90aW1lICgpIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IodW5peF9nZXR0aW1lb2ZkYXkgKCkpO1xufVxuXG4vL1Byb3ZpZGVzOiB1bml4X2dtdGltZVxuZnVuY3Rpb24gdW5peF9nbXRpbWUgKHQpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSAodCAqIDEwMDApO1xuICB2YXIgZF9udW0gPSBkLmdldFRpbWUoKTtcbiAgdmFyIGphbnVhcnlmaXJzdCA9IChuZXcgRGF0ZShEYXRlLlVUQyhkLmdldFVUQ0Z1bGxZZWFyKCksIDAsIDEpKSkuZ2V0VGltZSgpO1xuICB2YXIgZG95ID0gTWF0aC5mbG9vcigoZF9udW0gLSBqYW51YXJ5Zmlyc3QpIC8gODY0MDAwMDApO1xuICByZXR1cm4gQkxPQ0soMCwgZC5nZXRVVENTZWNvbmRzKCksIGQuZ2V0VVRDTWludXRlcygpLCBkLmdldFVUQ0hvdXJzKCksXG4gICAgICAgICAgZC5nZXRVVENEYXRlKCksIGQuZ2V0VVRDTW9udGgoKSwgZC5nZXRVVENGdWxsWWVhcigpIC0gMTkwMCxcbiAgICAgICAgICBkLmdldFVUQ0RheSgpLCBkb3ksXG4gICAgICAgICAgZmFsc2UgfCAwIC8qIGZvciBVVEMgZGF5bGlnaHQgc2F2aW5ncyB0aW1lIGlzIGZhbHNlICovKVxufVxuXG4vL1Byb3ZpZGVzOiB1bml4X2xvY2FsdGltZVxuZnVuY3Rpb24gdW5peF9sb2NhbHRpbWUgKHQpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSAodCAqIDEwMDApO1xuICB2YXIgZF9udW0gPSBkLmdldFRpbWUoKTtcbiAgdmFyIGphbnVhcnlmaXJzdCA9IChuZXcgRGF0ZShkLmdldEZ1bGxZZWFyKCksIDAsIDEpKS5nZXRUaW1lKCk7XG4gIHZhciBkb3kgPSBNYXRoLmZsb29yKChkX251bSAtIGphbnVhcnlmaXJzdCkgLyA4NjQwMDAwMCk7XG4gIHZhciBqYW4gPSBuZXcgRGF0ZShkLmdldEZ1bGxZZWFyKCksIDAsIDEpO1xuICB2YXIganVsID0gbmV3IERhdGUoZC5nZXRGdWxsWWVhcigpLCA2LCAxKTtcbiAgdmFyIHN0ZFRpbWV6b25lT2Zmc2V0ID0gTWF0aC5tYXgoamFuLmdldFRpbWV6b25lT2Zmc2V0KCksIGp1bC5nZXRUaW1lem9uZU9mZnNldCgpKTtcbiAgcmV0dXJuIEJMT0NLKDAsIGQuZ2V0U2Vjb25kcygpLCBkLmdldE1pbnV0ZXMoKSwgZC5nZXRIb3VycygpLFxuICAgICAgICAgIGQuZ2V0RGF0ZSgpLCBkLmdldE1vbnRoKCksIGQuZ2V0RnVsbFllYXIoKSAtIDE5MDAsXG4gICAgICAgICAgZC5nZXREYXkoKSwgZG95LFxuICAgICAgICAgIChkLmdldFRpbWV6b25lT2Zmc2V0KCkgPCBzdGRUaW1lem9uZU9mZnNldCkgfCAwIC8qIGRheWxpZ2h0IHNhdmluZ3MgdGltZSAgZmllbGQuICovKVxufVxuXG4vL1Byb3ZpZGVzOiB1bml4X21rdGltZVxuLy9SZXF1aXJlczogdW5peF9sb2NhbHRpbWVcbmZ1bmN0aW9uIHVuaXhfbWt0aW1lKHRtKXtcbiAgdmFyIGQgPSAobmV3IERhdGUodG1bNl0rMTkwMCx0bVs1XSx0bVs0XSx0bVszXSx0bVsyXSx0bVsxXSkpLmdldFRpbWUoKTtcbiAgdmFyIHQgPSBNYXRoLmZsb29yKGQgLyAxMDAwKTtcbiAgdmFyIHRtMiA9IHVuaXhfbG9jYWx0aW1lKHQpO1xuICByZXR1cm4gQkxPQ0soMCx0LHRtMik7XG59XG5cbi8vUHJvdmlkZXM6IHdpbl9zdGFydHVwIGNvbnN0XG5mdW5jdGlvbiB3aW5fc3RhcnR1cCgpIHt9XG5cbi8vUHJvdmlkZXM6IHdpbl9jbGVhbnVwIGNvbnN0XG5mdW5jdGlvbiB3aW5fY2xlYW51cCgpIHt9XG5cbi8vUHJvdmlkZXM6IHdpbl9oYW5kbGVfZmQgY29uc3RcbmZ1bmN0aW9uIHdpbl9oYW5kbGVfZmQoeCkge3JldHVybiB4O31cblxuLy9Qcm92aWRlczogdW5peF9pc2F0dHkgXG4vL1JlcXVpcmVzOiBmc19ub2RlX3N1cHBvcnRlZFxuZnVuY3Rpb24gdW5peF9pc2F0dHkoZmlsZURlc2NyaXB0b3IpIHtcbiAgaWYoZnNfbm9kZV9zdXBwb3J0ZWQoKSkge1xuICAgIHZhciB0dHkgPSByZXF1aXJlKCd0dHknKTtcbiAgICByZXR1cm4gdHR5LmlzYXR0eShmaWxlRGVzY3JpcHRvcik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBjYW1sX2Zvcm1hdF9pbnQgY29uc3QgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfcGFyc2VfZm9ybWF0LCBjYW1sX2ZpbmlzaF9mb3JtYXR0aW5nLCBjYW1sX3N0cl9yZXBlYXRcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMsIGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfZm9ybWF0X2ludChmbXQsIGkpIHtcbiAgaWYgKGNhbWxfanNieXRlc19vZl9zdHJpbmcoZm10KSA9PSBcIiVkXCIpIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKFwiXCIraSk7XG4gIHZhciBmID0gY2FtbF9wYXJzZV9mb3JtYXQoZm10KTtcbiAgaWYgKGkgPCAwKSB7IGlmIChmLnNpZ25lZGNvbnYpIHsgZi5zaWduID0gLTE7IGkgPSAtaTsgfSBlbHNlIGkgPj4+PSAwOyB9XG4gIHZhciBzID0gaS50b1N0cmluZyhmLmJhc2UpO1xuICBpZiAoZi5wcmVjID49IDApIHtcbiAgICBmLmZpbGxlciA9ICcgJztcbiAgICB2YXIgbiA9IGYucHJlYyAtIHMubGVuZ3RoO1xuICAgIGlmIChuID4gMCkgcyA9IGNhbWxfc3RyX3JlcGVhdCAobiwgJzAnKSArIHM7XG4gIH1cbiAgcmV0dXJuIGNhbWxfZmluaXNoX2Zvcm1hdHRpbmcoZiwgcyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcGFyc2Vfc2lnbl9hbmRfYmFzZVxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfdW5zYWZlX2dldCwgY2FtbF9tbF9zdHJpbmdfbGVuZ3RoXG5mdW5jdGlvbiBjYW1sX3BhcnNlX3NpZ25fYW5kX2Jhc2UgKHMpIHtcbiAgdmFyIGkgPSAwLCBsZW4gPSBjYW1sX21sX3N0cmluZ19sZW5ndGgocyksIGJhc2UgPSAxMCwgc2lnbiA9IDE7XG4gIGlmIChsZW4gPiAwKSB7XG4gICAgc3dpdGNoIChjYW1sX3N0cmluZ191bnNhZmVfZ2V0KHMsaSkpIHtcbiAgICBjYXNlIDQ1OiBpKys7IHNpZ24gPSAtMTsgYnJlYWs7XG4gICAgY2FzZSA0MzogaSsrOyBzaWduID0gMTsgYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmIChpICsgMSA8IGxlbiAmJiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0KHMsIGkpID09IDQ4KVxuICAgIHN3aXRjaCAoY2FtbF9zdHJpbmdfdW5zYWZlX2dldChzLCBpICsgMSkpIHtcbiAgICBjYXNlIDEyMDogY2FzZSA4ODogYmFzZSA9IDE2OyBpICs9IDI7IGJyZWFrO1xuICAgIGNhc2UgMTExOiBjYXNlIDc5OiBiYXNlID0gIDg7IGkgKz0gMjsgYnJlYWs7XG4gICAgY2FzZSAgOTg6IGNhc2UgNjY6IGJhc2UgPSAgMjsgaSArPSAyOyBicmVhaztcbiAgICBjYXNlIDExNzogY2FzZSA4NTogaSArPSAyOyBicmVhaztcbiAgICB9XG4gIHJldHVybiBbaSwgc2lnbiwgYmFzZV07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcGFyc2VfZGlnaXRcbmZ1bmN0aW9uIGNhbWxfcGFyc2VfZGlnaXQoYykge1xuICBpZiAoYyA+PSA0OCAmJiBjIDw9IDU3KSAgcmV0dXJuIGMgLSA0ODtcbiAgaWYgKGMgPj0gNjUgJiYgYyA8PSA5MCkgIHJldHVybiBjIC0gNTU7XG4gIGlmIChjID49IDk3ICYmIGMgPD0gMTIyKSByZXR1cm4gYyAtIDg3O1xuICByZXR1cm4gLTE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50X29mX3N0cmluZyAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGgsIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXRcbi8vUmVxdWlyZXM6IGNhbWxfcGFyc2Vfc2lnbl9hbmRfYmFzZSwgY2FtbF9wYXJzZV9kaWdpdCwgY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9pbnRfb2Zfc3RyaW5nIChzKSB7XG4gIHZhciByID0gY2FtbF9wYXJzZV9zaWduX2FuZF9iYXNlIChzKTtcbiAgdmFyIGkgPSByWzBdLCBzaWduID0gclsxXSwgYmFzZSA9IHJbMl07XG4gIHZhciBsZW4gPSBjYW1sX21sX3N0cmluZ19sZW5ndGgocyk7XG4gIHZhciB0aHJlc2hvbGQgPSAtMSA+Pj4gMDtcbiAgdmFyIGMgPSAoaSA8IGxlbik/Y2FtbF9zdHJpbmdfdW5zYWZlX2dldChzLCBpKTowO1xuICB2YXIgZCA9IGNhbWxfcGFyc2VfZGlnaXQoYyk7XG4gIGlmIChkIDwgMCB8fCBkID49IGJhc2UpIGNhbWxfZmFpbHdpdGgoXCJpbnRfb2Zfc3RyaW5nXCIpO1xuICB2YXIgcmVzID0gZDtcbiAgZm9yIChpKys7aTxsZW47aSsrKSB7XG4gICAgYyA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQocywgaSk7XG4gICAgaWYgKGMgPT0gOTUpIGNvbnRpbnVlO1xuICAgIGQgPSBjYW1sX3BhcnNlX2RpZ2l0KGMpO1xuICAgIGlmIChkIDwgMCB8fCBkID49IGJhc2UpIGJyZWFrO1xuICAgIHJlcyA9IGJhc2UgKiByZXMgKyBkO1xuICAgIGlmIChyZXMgPiB0aHJlc2hvbGQpIGNhbWxfZmFpbHdpdGgoXCJpbnRfb2Zfc3RyaW5nXCIpO1xuICB9XG4gIGlmIChpICE9IGxlbikgY2FtbF9mYWlsd2l0aChcImludF9vZl9zdHJpbmdcIik7XG4gIC8vIEZvciBiYXNlIGRpZmZlcmVudCBmcm9tIDEwLCB3ZSBleHBlY3QgYW4gdW5zaWduZWQgcmVwcmVzZW50YXRpb24sXG4gIC8vIGhlbmNlIGFueSB2YWx1ZSBvZiAncmVzJyAobGVzcyB0aGFuICd0aHJlc2hvbGQnKSBpcyBhY2NlcHRhYmxlLlxuICAvLyBCdXQgd2UgaGF2ZSB0byBjb252ZXJ0IHRoZSByZXN1bHQgYmFjayB0byBhIHNpZ25lZCBpbnRlZ2VyLlxuICByZXMgPSBzaWduICogcmVzO1xuICBpZiAoKGJhc2UgPT0gMTApICYmICgocmVzIHwgMCkgIT0gcmVzKSlcbiAgICAvKiBTaWduZWQgcmVwcmVzZW50YXRpb24gZXhwZWN0ZWQsIGFsbG93IC0yXihuYml0cy0xKSB0byAyXihuYml0cy0xKSAtIDEgKi9cbiAgICBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgcmV0dXJuIHJlcyB8IDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbXVsIGNvbnN0XG5mdW5jdGlvbiBjYW1sX211bChhLGIpe1xuICByZXR1cm4gTWF0aC5pbXVsKGEsYik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZGl2XG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3plcm9fZGl2aWRlXG5mdW5jdGlvbiBjYW1sX2Rpdih4LHkpIHtcbiAgaWYgKHkgPT0gMCkgY2FtbF9yYWlzZV96ZXJvX2RpdmlkZSAoKTtcbiAgcmV0dXJuICh4L3kpfDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbW9kXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3plcm9fZGl2aWRlXG5mdW5jdGlvbiBjYW1sX21vZCh4LHkpIHtcbiAgaWYgKHkgPT0gMCkgY2FtbF9yYWlzZV96ZXJvX2RpdmlkZSAoKTtcbiAgcmV0dXJuIHgleTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ic3dhcDE2XG5mdW5jdGlvbiBjYW1sX2Jzd2FwMTYoeCkge1xuICByZXR1cm4gKCgoKHggJiAweDAwRkYpIDw8IDgpIHxcbiAgICAgICAgICAgKCh4ICYgMHhGRjAwKSA+PiA4KSkpO1xufVxuLy9Qcm92aWRlczogY2FtbF9pbnQzMl9ic3dhcFxuZnVuY3Rpb24gY2FtbF9pbnQzMl9ic3dhcCh4KSB7XG4gIHJldHVybiAoKCh4ICYgMHgwMDAwMDBGRikgPDwgMjQpIHxcbiAgICAgICAgICAoKHggJiAweDAwMDBGRjAwKSA8PCA4KSB8XG4gICAgICAgICAgKCh4ICYgMHgwMEZGMDAwMCkgPj4+IDgpIHxcbiAgICAgICAgICAoKHggJiAweEZGMDAwMDAwKSA+Pj4gMjQpKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfYnN3YXBcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfdG9fYnl0ZXMsIGNhbWxfaW50NjRfb2ZfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfaW50NjRfYnN3YXAoeCkge1xuICB2YXIgeSA9IGNhbWxfaW50NjRfdG9fYnl0ZXMoeCk7XG4gIHJldHVybiBjYW1sX2ludDY0X29mX2J5dGVzKFt5WzddLCB5WzZdLCB5WzVdLCB5WzRdLCB5WzNdLCB5WzJdLCB5WzFdLCB5WzBdXSk7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vLy8vLy8vLy8vLy8vIEhhc2h0YmxcblxuLy9Qcm92aWRlczogY2FtbF9oYXNoX3VuaXZfcGFyYW0gbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9pc19tbF9zdHJpbmcsIGNhbWxfaXNfbWxfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfdG9fYnl0ZXMsIGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCwgY2FtbF9jdXN0b21fb3BzXG4vL1JlcXVpcmVzOiBjYW1sX21sX2J5dGVzX2xlbmd0aCwgY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9oYXNoX3VuaXZfcGFyYW0gKGNvdW50LCBsaW1pdCwgb2JqKSB7XG4gIHZhciBoYXNoX2FjY3UgPSAwO1xuICBmdW5jdGlvbiBoYXNoX2F1eCAob2JqKSB7XG4gICAgbGltaXQgLS07XG4gICAgaWYgKGNvdW50IDwgMCB8fCBsaW1pdCA8IDApIHJldHVybjtcbiAgICBpZiAob2JqIGluc3RhbmNlb2YgQXJyYXkgJiYgb2JqWzBdID09PSAob2JqWzBdfDApKSB7XG4gICAgICBzd2l0Y2ggKG9ialswXSkge1xuICAgICAgY2FzZSAyNDg6XG4gICAgICAgIC8vIE9iamVjdFxuICAgICAgICBjb3VudCAtLTtcbiAgICAgICAgaGFzaF9hY2N1ID0gKGhhc2hfYWNjdSAqIDY1NTk5ICsgb2JqWzJdKSB8IDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNTA6XG4gICAgICAgIC8vIEZvcndhcmRcbiAgICAgICAgbGltaXQrKzsgaGFzaF9hdXgob2JqKTsgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjb3VudCAtLTtcbiAgICAgICAgaGFzaF9hY2N1ID0gKGhhc2hfYWNjdSAqIDE5ICsgb2JqWzBdKSB8IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSBvYmoubGVuZ3RoIC0gMTsgaSA+IDA7IGktLSkgaGFzaF9hdXggKG9ialtpXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjYW1sX2lzX21sX2J5dGVzKG9iaikpIHtcbiAgICAgIGNvdW50IC0tO1xuICAgICAgc3dpdGNoIChvYmoudCAmIDYpIHtcbiAgICAgIGRlZmF1bHQ6IC8qIFBBUlRJQUwgKi9cbiAgICAgICAgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhvYmopO1xuICAgICAgY2FzZSAwOiAvKiBCWVRFUyAqL1xuICAgICAgICBmb3IgKHZhciBiID0gb2JqLmMsIGwgPSBjYW1sX21sX2J5dGVzX2xlbmd0aChvYmopLCBpID0gMDsgaSA8IGw7IGkrKylcbiAgICAgICAgICBoYXNoX2FjY3UgPSAoaGFzaF9hY2N1ICogMTkgKyBiLmNoYXJDb2RlQXQoaSkpIHwgMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6IC8qIEFSUkFZICovXG4gICAgICAgIGZvciAodmFyIGEgPSBvYmouYywgbCA9IGNhbWxfbWxfYnl0ZXNfbGVuZ3RoKG9iaiksIGkgPSAwOyBpIDwgbDsgaSsrKVxuICAgICAgICAgIGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiAxOSArIGFbaV0pIHwgMDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNhbWxfaXNfbWxfc3RyaW5nKG9iaikpIHtcbiAgICAgICAgdmFyIGpzYnl0ZXMgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKG9iaik7XG4gICAgICAgIGZvciAodmFyIGIgPSBqc2J5dGVzLCBsID0ganNieXRlcy5sZW5ndGgsIGkgPSAwOyBpIDwgbDsgaSsrKVxuICAgICAgICAgIGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiAxOSArIGIuY2hhckNvZGVBdChpKSkgfCAwO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBmb3IgKHZhciBiID0gb2JqLCBsID0gb2JqLmxlbmd0aCwgaSA9IDA7IGkgPCBsOyBpKyspXG4gICAgICAgICAgaGFzaF9hY2N1ID0gKGhhc2hfYWNjdSAqIDE5ICsgYi5jaGFyQ29kZUF0KGkpKSB8IDA7XG4gICAgfSBlbHNlIGlmIChvYmogPT09IChvYmp8MCkpIHtcbiAgICAgIC8vIEludGVnZXJcbiAgICAgIGNvdW50IC0tO1xuICAgICAgaGFzaF9hY2N1ID0gKGhhc2hfYWNjdSAqIDY1NTk5ICsgb2JqKSB8IDA7XG4gICAgfSBlbHNlIGlmIChvYmogPT09ICtvYmopIHtcbiAgICAgIC8vIEZsb2F0XG4gICAgICBjb3VudC0tO1xuICAgICAgdmFyIHAgPSBjYW1sX2ludDY0X3RvX2J5dGVzIChjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQgKG9iaikpO1xuICAgICAgZm9yICh2YXIgaSA9IDc7IGkgPj0gMDsgaS0tKSBoYXNoX2FjY3UgPSAoaGFzaF9hY2N1ICogMTkgKyBwW2ldKSB8IDA7XG4gICAgfSBlbHNlIGlmKG9iaiAmJiBvYmouY2FtbF9jdXN0b20pIHtcbiAgICAgIGlmKGNhbWxfY3VzdG9tX29wc1tvYmouY2FtbF9jdXN0b21dICYmIGNhbWxfY3VzdG9tX29wc1tvYmouY2FtbF9jdXN0b21dLmhhc2gpIHtcbiAgICAgICAgdmFyIGggPSBjYW1sX2N1c3RvbV9vcHNbb2JqLmNhbWxfY3VzdG9tXS5oYXNoKG9iaikgfCAwO1xuICAgICAgICBoYXNoX2FjY3UgPSAoaGFzaF9hY2N1ICogNjU1OTkgKyBoKSB8IDA7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGhhc2hfYXV4IChvYmopO1xuICByZXR1cm4gaGFzaF9hY2N1ICYgMHgzRkZGRkZGRjtcbn1cblxuLy9mdW5jdGlvbiBST1RMMzIoeCxuKSB7IHJldHVybiAoKHggPDwgbikgfCAoeCA+Pj4gKDMyLW4pKSk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfaW50XG4vL1JlcXVpcmVzOiBjYW1sX211bFxuZnVuY3Rpb24gY2FtbF9oYXNoX21peF9pbnQoaCxkKSB7XG4gIGQgPSBjYW1sX211bChkLCAweGNjOWUyZDUxfDApO1xuICBkID0gKChkIDw8IDE1KSB8IChkID4+PiAoMzItMTUpKSk7IC8vIFJPVEwzMihkLCAxNSk7XG4gIGQgPSBjYW1sX211bChkLCAweDFiODczNTkzKTtcbiAgaCBePSBkO1xuICBoID0gKChoIDw8IDEzKSB8IChoID4+PiAoMzItMTMpKSk7ICAgLy9ST1RMMzIoaCwgMTMpO1xuICByZXR1cm4gKCgoaCArIChoIDw8IDIpKXwwKSArICgweGU2NTQ2YjY0fDApKXwwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbWl4X2ZpbmFsXG4vL1JlcXVpcmVzOiBjYW1sX211bFxuZnVuY3Rpb24gY2FtbF9oYXNoX21peF9maW5hbChoKSB7XG4gIGggXj0gaCA+Pj4gMTY7XG4gIGggPSBjYW1sX211bCAoaCwgMHg4NWViY2E2YnwwKTtcbiAgaCBePSBoID4+PiAxMztcbiAgaCA9IGNhbWxfbXVsIChoLCAweGMyYjJhZTM1fDApO1xuICBoIF49IGggPj4+IDE2O1xuICByZXR1cm4gaDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9oYXNoX21peF9mbG9hdFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0LCBjYW1sX2hhc2hfbWl4X2ludDY0XG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X2Zsb2F0IChoLCB2MCkge1xuICByZXR1cm4gY2FtbF9oYXNoX21peF9pbnQ2NChoLCBjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQgKHYwKSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbWl4X2ludDY0XG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2ludFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9sbzMyLCBjYW1sX2ludDY0X2hpMzJcbmZ1bmN0aW9uIGNhbWxfaGFzaF9taXhfaW50NjQgKGgsIHYpIHtcbiAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIGNhbWxfaW50NjRfbG8zMih2KSk7XG4gIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCBjYW1sX2ludDY0X2hpMzIodikpO1xuICByZXR1cm4gaDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9oYXNoX21peF9qc2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2ludFxuZnVuY3Rpb24gY2FtbF9oYXNoX21peF9qc2J5dGVzKGgsIHMpIHtcbiAgdmFyIGxlbiA9IHMubGVuZ3RoLCBpLCB3O1xuICBmb3IgKGkgPSAwOyBpICsgNCA8PSBsZW47IGkgKz0gNCkge1xuICAgIHcgPSBzLmNoYXJDb2RlQXQoaSlcbiAgICAgIHwgKHMuY2hhckNvZGVBdChpKzEpIDw8IDgpXG4gICAgICB8IChzLmNoYXJDb2RlQXQoaSsyKSA8PCAxNilcbiAgICAgIHwgKHMuY2hhckNvZGVBdChpKzMpIDw8IDI0KTtcbiAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgdyk7XG4gIH1cbiAgdyA9IDA7XG4gIHN3aXRjaCAobGVuICYgMykge1xuICBjYXNlIDM6IHcgID0gcy5jaGFyQ29kZUF0KGkrMikgPDwgMTY7XG4gIGNhc2UgMjogdyB8PSBzLmNoYXJDb2RlQXQoaSsxKSA8PCA4O1xuICBjYXNlIDE6XG4gICAgdyB8PSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHcpO1xuICBkZWZhdWx0OlxuICB9XG4gIGggXj0gbGVuO1xuICByZXR1cm4gaDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9oYXNoX21peF9ieXRlc19hcnJcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfaW50XG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X2J5dGVzX2FycihoLCBzKSB7XG4gIHZhciBsZW4gPSBzLmxlbmd0aCwgaSwgdztcbiAgZm9yIChpID0gMDsgaSArIDQgPD0gbGVuOyBpICs9IDQpIHtcbiAgICB3ID0gc1tpXVxuICAgICAgfCAoc1tpKzFdIDw8IDgpXG4gICAgICB8IChzW2krMl0gPDwgMTYpXG4gICAgICB8IChzW2krM10gPDwgMjQpO1xuICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCB3KTtcbiAgfVxuICB3ID0gMDtcbiAgc3dpdGNoIChsZW4gJiAzKSB7XG4gIGNhc2UgMzogdyAgPSBzW2krMl0gPDwgMTY7XG4gIGNhc2UgMjogdyB8PSBzW2krMV0gPDwgODtcbiAgY2FzZSAxOiB3IHw9IHNbaV07XG4gICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHcpO1xuICBkZWZhdWx0OlxuICB9XG4gIGggXj0gbGVuO1xuICByZXR1cm4gaDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9oYXNoX21peF9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9qc2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2J5dGVzX2FyclxuZnVuY3Rpb24gY2FtbF9oYXNoX21peF9ieXRlcyhoLCB2KSB7XG4gIHN3aXRjaCAodi50ICYgNikge1xuICBkZWZhdWx0OlxuICAgIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMgKHYpO1xuICBjYXNlIDA6IC8qIEJZVEVTICovXG4gICAgaCA9IGNhbWxfaGFzaF9taXhfanNieXRlcyhoLCB2LmMpO1xuICAgIGJyZWFrO1xuICBjYXNlIDI6IC8qIEFSUkFZICovXG4gICAgaCA9IGNhbWxfaGFzaF9taXhfYnl0ZXNfYXJyKGgsIHYuYyk7XG4gIH1cbiAgcmV0dXJuIGhcbn1cblxuLy9Qcm92aWRlczogY2FtbF9oYXNoX21peF9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfanNieXRlcywgY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9oYXNoX21peF9zdHJpbmcoaCwgdikge1xuICByZXR1cm4gY2FtbF9oYXNoX21peF9qc2J5dGVzKGgsIGNhbWxfanNieXRlc19vZl9zdHJpbmcodikpO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaCBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2lzX21sX3N0cmluZywgY2FtbF9pc19tbF9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9pbnQsIGNhbWxfaGFzaF9taXhfZmluYWxcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfZmxvYXQsIGNhbWxfaGFzaF9taXhfc3RyaW5nLCBjYW1sX2hhc2hfbWl4X2J5dGVzLCBjYW1sX2N1c3RvbV9vcHNcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9oYXNoIChjb3VudCwgbGltaXQsIHNlZWQsIG9iaikge1xuICB2YXIgcXVldWUsIHJkLCB3ciwgc3osIG51bSwgaCwgdiwgaSwgbGVuO1xuICBzeiA9IGxpbWl0O1xuICBpZiAoc3ogPCAwIHx8IHN6ID4gMjU2KSBzeiA9IDI1NjtcbiAgbnVtID0gY291bnQ7XG4gIGggPSBzZWVkO1xuICBxdWV1ZSA9IFtvYmpdOyByZCA9IDA7IHdyID0gMTtcbiAgd2hpbGUgKHJkIDwgd3IgJiYgbnVtID4gMCkge1xuICAgIHYgPSBxdWV1ZVtyZCsrXTtcbiAgICBpZiAodiAmJiB2LmNhbWxfY3VzdG9tKXtcbiAgICAgIGlmKGNhbWxfY3VzdG9tX29wc1t2LmNhbWxfY3VzdG9tXSAmJiBjYW1sX2N1c3RvbV9vcHNbdi5jYW1sX2N1c3RvbV0uaGFzaCkge1xuICAgICAgICB2YXIgaGggPSBjYW1sX2N1c3RvbV9vcHNbdi5jYW1sX2N1c3RvbV0uaGFzaCh2KTtcbiAgICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50IChoLCBoaCk7XG4gICAgICAgIG51bSAtLTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodiBpbnN0YW5jZW9mIEFycmF5ICYmIHZbMF0gPT09ICh2WzBdfDApKSB7XG4gICAgICBzd2l0Y2ggKHZbMF0pIHtcbiAgICAgIGNhc2UgMjQ4OlxuICAgICAgICAvLyBPYmplY3RcbiAgICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHZbMl0pO1xuICAgICAgICBudW0tLTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI1MDpcbiAgICAgICAgLy8gRm9yd2FyZFxuICAgICAgICBxdWV1ZVstLXJkXSA9IHZbMV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdmFyIHRhZyA9ICgodi5sZW5ndGggLSAxKSA8PCAxMCkgfCB2WzBdO1xuICAgICAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgdGFnKTtcbiAgICAgICAgZm9yIChpID0gMSwgbGVuID0gdi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGlmICh3ciA+PSBzeikgYnJlYWs7XG4gICAgICAgICAgcXVldWVbd3IrK10gPSB2W2ldO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2FtbF9pc19tbF9ieXRlcyh2KSkge1xuICAgICAgaCA9IGNhbWxfaGFzaF9taXhfYnl0ZXMoaCx2KVxuICAgICAgbnVtLS07XG4gICAgfSBlbHNlIGlmIChjYW1sX2lzX21sX3N0cmluZyh2KSkge1xuICAgICAgaCA9IGNhbWxfaGFzaF9taXhfc3RyaW5nKGgsdilcbiAgICAgIG51bS0tO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHYgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2pzYnl0ZXMoaCx2KVxuICAgICAgbnVtLS07XG4gICAgfSBlbHNlIGlmICh2ID09PSAodnwwKSkge1xuICAgICAgLy8gSW50ZWdlclxuICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHYrdisxKTtcbiAgICAgIG51bS0tO1xuICAgIH0gZWxzZSBpZiAodiA9PT0gK3YpIHtcbiAgICAgIC8vIEZsb2F0XG4gICAgICBoID0gY2FtbF9oYXNoX21peF9mbG9hdChoLHYpO1xuICAgICAgbnVtLS07XG4gICAgfVxuICB9XG4gIGggPSBjYW1sX2hhc2hfbWl4X2ZpbmFsKGgpO1xuICByZXR1cm4gaCAmIDB4M0ZGRkZGRkY7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvbXBhcmVfdmFsX3RhZ1xuLy9SZXF1aXJlczogY2FtbF9pc19tbF9zdHJpbmcsIGNhbWxfaXNfbWxfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfY29tcGFyZV92YWxfdGFnKGEpe1xuICBpZiAodHlwZW9mIGEgPT09IFwibnVtYmVyXCIpIHJldHVybiAxMDAwOyAvLyBpbnRfdGFnICh3ZSB1c2UgaXQgZm9yIGFsbCBudW1iZXJzKVxuICBlbHNlIGlmIChjYW1sX2lzX21sX2J5dGVzKGEpKSByZXR1cm4gMjUyOyAvLyBzdHJpbmdfdGFnXG4gIGVsc2UgaWYgKGNhbWxfaXNfbWxfc3RyaW5nKGEpKSByZXR1cm4gMTI1MjsgLy8gb2NhbWwgc3RyaW5nIChpZiBkaWZmZXJlbnQgZnJvbSBieXRlcylcbiAgZWxzZSBpZiAoYSBpbnN0YW5jZW9mIEFycmF5ICYmIGFbMF0gPT09IChhWzBdPj4+MCkgJiYgYVswXSA8PSAyNTUpIHtcbiAgICAvLyBMb29rIGxpa2UgYW4gb2NhbWwgYmxvY2tcbiAgICB2YXIgdGFnID0gYVswXSB8IDA7XG4gICAgLy8gaWdub3JlIGRvdWJsZV9hcnJheV90YWcgYmVjYXVzZSB3ZSBjYW5ub3QgYWNjdXJhdGVseSBzZXRcbiAgICAvLyB0aGlzIHRhZyB3aGVuIHdlIGNyZWF0ZSBhbiBhcnJheSBvZiBmbG9hdC5cbiAgICByZXR1cm4gKHRhZyA9PSAyNTQpPzA6dGFnXG4gIH1cbiAgZWxzZSBpZiAoYSBpbnN0YW5jZW9mIFN0cmluZykgcmV0dXJuIDEyNTIwOyAvLyBqYXZhc2NyaXB0IHN0cmluZywgbGlrZSBzdHJpbmdfdGFnICgyNTIpXG4gIGVsc2UgaWYgKHR5cGVvZiBhID09IFwic3RyaW5nXCIpIHJldHVybiAxMjUyMDsgLy8gamF2YXNjcmlwdCBzdHJpbmcsIGxpa2Ugc3RyaW5nX3RhZyAoMjUyKVxuICBlbHNlIGlmIChhIGluc3RhbmNlb2YgTnVtYmVyKSByZXR1cm4gMTAwMDsgLy8gaW50X3RhZyAod2UgdXNlIGl0IGZvciBhbGwgbnVtYmVycylcbiAgZWxzZSBpZiAoYSAmJiBhLmNhbWxfY3VzdG9tKSByZXR1cm4gMTI1NTsgLy8gbGlrZSBjdXN0b21fdGFnICgyNTUpXG4gIGVsc2UgaWYgKGEgJiYgYS5jb21wYXJlKSByZXR1cm4gMTI1NjsgLy8gbGlrZSBjdXN0b21fdGFnICgyNTUpXG4gIGVsc2UgaWYgKHR5cGVvZiBhID09IFwiZnVuY3Rpb25cIikgcmV0dXJuIDEyNDc7IC8vIGxpa2UgY2xvc3VyZV90YWcgKDI0NylcbiAgZWxzZSBpZiAodHlwZW9mIGEgPT0gXCJzeW1ib2xcIikgcmV0dXJuIDEyNTE7XG4gIHJldHVybiAxMDAxOyAvL291dF9vZl9oZWFwX3RhZ1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvbXBhcmVfdmFsX2dldF9jdXN0b21cbi8vUmVxdWlyZXM6IGNhbWxfY3VzdG9tX29wc1xuZnVuY3Rpb24gY2FtbF9jb21wYXJlX3ZhbF9nZXRfY3VzdG9tKGEpe1xuICByZXR1cm4gY2FtbF9jdXN0b21fb3BzW2EuY2FtbF9jdXN0b21dICYmIGNhbWxfY3VzdG9tX29wc1thLmNhbWxfY3VzdG9tXS5jb21wYXJlO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvbXBhcmVfdmFsX251bWJlcl9jdXN0b21cbi8vUmVxdWlyZXM6IGNhbWxfY29tcGFyZV92YWxfZ2V0X2N1c3RvbVxuZnVuY3Rpb24gY2FtbF9jb21wYXJlX3ZhbF9udW1iZXJfY3VzdG9tKG51bSwgY3VzdG9tLCBzd2FwLCB0b3RhbCkge1xuICB2YXIgY29tcCA9IGNhbWxfY29tcGFyZV92YWxfZ2V0X2N1c3RvbShjdXN0b20pO1xuICBpZihjb21wKSB7XG4gICAgdmFyIHggPSAoc3dhcCA+IDApP2NvbXAoY3VzdG9tLG51bSx0b3RhbCk6Y29tcChudW0sY3VzdG9tLHRvdGFsKTtcbiAgICBpZih0b3RhbCAmJiB4ICE9IHgpIHJldHVybiBzd2FwOyAvLyB0b3RhbCAmJiBuYW5cbiAgICBpZigreCAhPSAreCkgcmV0dXJuICt4OyAvLyBuYW5cbiAgICBpZigoeCB8IDApICE9IDApIHJldHVybiAoeCB8IDApOyAvLyAhbmFuXG4gIH1cbiAgcmV0dXJuIHN3YXBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jb21wYXJlX3ZhbCAoY29uc3QsIGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfaW50X2NvbXBhcmUsIGNhbWxfc3RyaW5nX2NvbXBhcmUsIGNhbWxfYnl0ZXNfY29tcGFyZVxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2NvbXBhcmVfdmFsX2dldF9jdXN0b20sIGNhbWxfY29tcGFyZV92YWxfdGFnXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsX251bWJlcl9jdXN0b21cbi8vUmVxdWlyZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfY29tcGFyZV92YWwgKGEsIGIsIHRvdGFsKSB7XG4gIHZhciBzdGFjayA9IFtdO1xuICBmb3IoOzspIHtcbiAgICBpZiAoISh0b3RhbCAmJiBhID09PSBiKSkge1xuICAgICAgdmFyIHRhZ19hID0gY2FtbF9jb21wYXJlX3ZhbF90YWcoYSk7XG4gICAgICAvLyBmb3J3YXJkX3RhZyA/XG4gICAgICBpZih0YWdfYSA9PSAyNTApIHsgYSA9IGFbMV07IGNvbnRpbnVlIH1cblxuICAgICAgdmFyIHRhZ19iID0gY2FtbF9jb21wYXJlX3ZhbF90YWcoYik7XG4gICAgICAvLyBmb3J3YXJkX3RhZyA/XG4gICAgICBpZih0YWdfYiA9PSAyNTApIHsgYiA9IGJbMV07IGNvbnRpbnVlIH1cblxuICAgICAgLy8gdGFncyBhcmUgZGlmZmVyZW50XG4gICAgICBpZih0YWdfYSAhPT0gdGFnX2IpIHtcbiAgICAgICAgaWYodGFnX2EgPT0gMTAwMCkge1xuICAgICAgICAgIGlmKHRhZ19iID09IDEyNTUpIHsgLy9pbW1lZGlhdGUgY2FuIGNvbXBhcmUgYWdhaW5zdCBjdXN0b21cbiAgICAgICAgICAgIHJldHVybiBjYW1sX2NvbXBhcmVfdmFsX251bWJlcl9jdXN0b20oYSwgYiwgLTEsIHRvdGFsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIC0xXG4gICAgICAgIH1cbiAgICAgICAgaWYodGFnX2IgPT0gMTAwMCkge1xuICAgICAgICAgIGlmKHRhZ19hID09IDEyNTUpIHsgLy9pbW1lZGlhdGUgY2FuIGNvbXBhcmUgYWdhaW5zdCBjdXN0b21cbiAgICAgICAgICAgIHJldHVybiBjYW1sX2NvbXBhcmVfdmFsX251bWJlcl9jdXN0b20oYiwgYSwgMSwgdG90YWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gMVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAodGFnX2EgPCB0YWdfYik/LTE6MTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCh0YWdfYSl7XG4gICAgICAgIC8vIDI0NjogTGF6eV90YWcgaGFuZGxlZCBiZWxsb3dcbiAgICAgIGNhc2UgMjQ3OiAvLyBDbG9zdXJlX3RhZ1xuICAgICAgICAvLyBDYW5ub3QgaGFwcGVuXG4gICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNvbXBhcmU6IGZ1bmN0aW9uYWwgdmFsdWVcIik7XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIDI0ODogLy8gT2JqZWN0XG4gICAgICAgIHZhciB4ID0gY2FtbF9pbnRfY29tcGFyZShhWzJdLCBiWzJdKTtcbiAgICAgICAgaWYgKHggIT0gMCkgcmV0dXJuICh4IHwgMCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNDk6IC8vIEluZml4XG4gICAgICAgIC8vIENhbm5vdCBoYXBwZW5cbiAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY29tcGFyZTogZnVuY3Rpb25hbCB2YWx1ZVwiKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgMjUwOiAvLyBGb3J3YXJkIHRhZ1xuICAgICAgICAvLyBDYW5ub3QgaGFwcGVuLCBoYW5kbGVkIGFib3ZlXG4gICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImVxdWFsOiBnb3QgRm9yd2FyZF90YWcsIHNob3VsZCBub3QgaGFwcGVuXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjUxOiAvL0Fic3RyYWN0XG4gICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImVxdWFsOiBhYnN0cmFjdCB2YWx1ZVwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI1MjogLy8gT0NhbWwgYnl0ZXNcbiAgICAgICAgaWYgKGEgIT09IGIpIHtcbiAgICAgICAgICB2YXIgeCA9IGNhbWxfYnl0ZXNfY29tcGFyZShhLCBiKTtcbiAgICAgICAgICBpZiAoeCAhPSAwKSByZXR1cm4gKHggfCAwKTtcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI1MzogLy8gRG91YmxlX3RhZ1xuICAgICAgICAvLyBDYW5ub3QgaGFwcGVuXG4gICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImVxdWFsOiBnb3QgRG91YmxlX3RhZywgc2hvdWxkIG5vdCBoYXBwZW5cIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNTQ6IC8vIERvdWJsZV9hcnJheV90YWdcbiAgICAgICAgLy8gQ2Fubm90IGhhcHBlbiwgaGFuZGxlZCBhYm92ZVxuICAgICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJlcXVhbDogZ290IERvdWJsZV9hcnJheV90YWcsIHNob3VsZCBub3QgaGFwcGVuXCIpO1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSAyNTU6IC8vIEN1c3RvbV90YWdcbiAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiZXF1YWw6IGdvdCBDdXN0b21fdGFnLCBzaG91bGQgbm90IGhhcHBlblwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEyNDc6IC8vIEZ1bmN0aW9uXG4gICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNvbXBhcmU6IGZ1bmN0aW9uYWwgdmFsdWVcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxMjU1OiAvLyBDdXN0b21cbiAgICAgICAgdmFyIGNvbXAgPSBjYW1sX2NvbXBhcmVfdmFsX2dldF9jdXN0b20oYSk7XG4gICAgICAgIGlmKGNvbXAgIT0gY2FtbF9jb21wYXJlX3ZhbF9nZXRfY3VzdG9tKGIpKXtcbiAgICAgICAgICByZXR1cm4gKGEuY2FtbF9jdXN0b208Yi5jYW1sX2N1c3RvbSk/LTE6MTtcbiAgICAgICAgfVxuICAgICAgICBpZighY29tcClcbiAgICAgICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJjb21wYXJlOiBhYnN0cmFjdCB2YWx1ZVwiKTtcbiAgICAgICAgdmFyIHggPSBjb21wKGEsYix0b3RhbCk7XG4gICAgICAgIGlmKHggIT0geCl7IC8vIFByb3RlY3QgYWdhaW5zdCBpbnZhbGlkIFVOT1JERVJFRFxuICAgICAgICAgIHJldHVybiB0b3RhbD8tMTp4O1xuICAgICAgICB9XG4gICAgICAgIGlmKHggIT09ICh4fDApKXsgLy8gUHJvdGVjdCBhZ2FpbnN0IGludmFsaWQgcmV0dXJuIHZhbHVlXG4gICAgICAgICAgcmV0dXJuIC0xXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHggIT0gMCkgcmV0dXJuICh4IHwgMCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxMjU2OiAvLyBjb21wYXJlIGZ1bmN0aW9uXG4gICAgICAgIHZhciB4ID0gYS5jb21wYXJlKGIsdG90YWwpO1xuICAgICAgICBpZih4ICE9IHgpIHsgLy8gUHJvdGVjdCBhZ2FpbnN0IGludmFsaWQgVU5PUkRFUkVEXG4gICAgICAgICAgcmV0dXJuIHRvdGFsPy0xOng7XG4gICAgICAgIH1cbiAgICAgICAgaWYoeCAhPT0gKHh8MCkpeyAvLyBQcm90ZWN0IGFnYWluc3QgaW52YWxpZCByZXR1cm4gdmFsdWVcbiAgICAgICAgICByZXR1cm4gLTFcbiAgICAgICAgfVxuICAgICAgICBpZiAoeCAhPSAwKSByZXR1cm4gKHggfCAwKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEwMDA6IC8vIE51bWJlclxuICAgICAgICBhID0gK2E7XG4gICAgICAgIGIgPSArYjtcbiAgICAgICAgaWYgKGEgPCBiKSByZXR1cm4gLTE7XG4gICAgICAgIGlmIChhID4gYikgcmV0dXJuIDE7XG4gICAgICAgIGlmIChhICE9IGIpIHtcbiAgICAgICAgICBpZiAoIXRvdGFsKSByZXR1cm4gTmFOO1xuICAgICAgICAgIGlmIChhID09IGEpIHJldHVybiAxO1xuICAgICAgICAgIGlmIChiID09IGIpIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTAwMTogLy8gVGhlIHJlc3RcbiAgICAgICAgLy8gSGVyZSB3ZSBjYW4gYmUgaW4gdGhlIGZvbGxvd2luZyBjYXNlczpcbiAgICAgICAgLy8gMS4gSmF2YVNjcmlwdCBwcmltaXRpdmUgdHlwZXNcbiAgICAgICAgLy8gMi4gSmF2YVNjcmlwdCBvYmplY3QgdGhhdCBjYW4gYmUgY29lcmNlZCB0byBwcmltaXRpdmUgdHlwZXNcbiAgICAgICAgLy8gMy4gSmF2YVNjcmlwdCBvYmplY3QgdGhhbiBjYW5ub3QgYmUgY29lcmNlZCB0byBwcmltaXRpdmUgdHlwZXNcbiAgICAgICAgLy9cbiAgICAgICAgLy8gKDMpIHdpbGwgcmFpc2UgYSBbVHlwZUVycm9yXVxuICAgICAgICAvLyAoMikgd2lsbCBjb2VyY2UgdG8gcHJpbWl0aXZlIHR5cGVzIHVzaW5nIFt2YWx1ZU9mXSBvciBbdG9TdHJpbmddXG4gICAgICAgIC8vICgyKSBhbmQgKDMpLCBhZnRlciBldmVudHVhbCBjb2VyY2lvblxuICAgICAgICAvLyAtIGlmIGEgYW5kIGIgYXJlIHN0cmluZ3MsIGFwcGx5IGxleGljb2dyYXBoaWMgY29tcGFyaXNvblxuICAgICAgICAvLyAtIGlmIGEgb3IgYiBhcmUgbm90IHN0cmluZ3MsIGNvbnZlcnQgYSBhbmQgYiB0byBudW1iZXJcbiAgICAgICAgLy8gICBhbmQgYXBwbHkgc3RhbmRhcmQgY29tcGFyaXNvblxuICAgICAgICAvL1xuICAgICAgICAvLyBFeGNlcHRpb246IGAhPWAgd2lsbCBub3QgY29lcmNlL2NvbnZlcnQgaWYgYm90aCBhIGFuZCBiIGFyZSBvYmplY3RzXG4gICAgICAgIGlmIChhIDwgYikgcmV0dXJuIC0xO1xuICAgICAgICBpZiAoYSA+IGIpIHJldHVybiAxO1xuICAgICAgICBpZiAoYSAhPSBiKSB7XG4gICAgICAgICAgaWYgKCF0b3RhbCkgcmV0dXJuIE5hTjtcbiAgICAgICAgICBpZiAoYSA9PSBhKSByZXR1cm4gMTtcbiAgICAgICAgICBpZiAoYiA9PSBiKSByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEyNTE6IC8vIEphdmFTY3JpcHQgU3ltYm9sLCBubyBvcmRlcmluZy5cbiAgICAgICAgaWYoYSAhPT0gYikge1xuICAgICAgICAgIGlmICghdG90YWwpIHJldHVybiBOYU47XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEyNTI6IC8vIG9jYW1sIHN0cmluZ3NcbiAgICAgICAgdmFyIGEgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKGEpO1xuICAgICAgICB2YXIgYiA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcoYik7XG4gICAgICAgIGlmKGEgIT09IGIpIHtcbiAgICAgICAgICBpZihhIDwgYikgcmV0dXJuIC0xO1xuICAgICAgICAgIGlmKGEgPiBiKSByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTI1MjA6IC8vIGphdmFzY3JpcHQgc3RyaW5nc1xuICAgICAgICB2YXIgYSA9IGEudG9TdHJpbmcoKTtcbiAgICAgICAgdmFyIGIgPSBiLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmKGEgIT09IGIpIHtcbiAgICAgICAgICBpZihhIDwgYikgcmV0dXJuIC0xO1xuICAgICAgICAgIGlmKGEgPiBiKSByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjQ2OiAvLyBMYXp5X3RhZ1xuICAgICAgY2FzZSAyNTQ6IC8vIERvdWJsZV9hcnJheVxuICAgICAgZGVmYXVsdDogLy8gQmxvY2sgd2l0aCBvdGhlciB0YWdcbiAgICAgICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKSByZXR1cm4gKGEubGVuZ3RoIDwgYi5sZW5ndGgpPy0xOjE7XG4gICAgICAgIGlmIChhLmxlbmd0aCA+IDEpIHN0YWNrLnB1c2goYSwgYiwgMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3RhY2subGVuZ3RoID09IDApIHJldHVybiAwO1xuICAgIHZhciBpID0gc3RhY2sucG9wKCk7XG4gICAgYiA9IHN0YWNrLnBvcCgpO1xuICAgIGEgPSBzdGFjay5wb3AoKTtcbiAgICBpZiAoaSArIDEgPCBhLmxlbmd0aCkgc3RhY2sucHVzaChhLCBiLCBpICsgMSk7XG4gICAgYSA9IGFbaV07XG4gICAgYiA9IGJbaV07XG4gIH1cbn1cbi8vUHJvdmlkZXM6IGNhbWxfY29tcGFyZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jb21wYXJlX3ZhbFxuZnVuY3Rpb24gY2FtbF9jb21wYXJlIChhLCBiKSB7IHJldHVybiBjYW1sX2NvbXBhcmVfdmFsIChhLCBiLCB0cnVlKTsgfVxuLy9Qcm92aWRlczogY2FtbF9pbnRfY29tcGFyZSBtdXRhYmxlIChjb25zdCwgY29uc3QpXG5mdW5jdGlvbiBjYW1sX2ludF9jb21wYXJlIChhLCBiKSB7XG4gIGlmIChhIDwgYikgcmV0dXJuICgtMSk7IGlmIChhID09IGIpIHJldHVybiAwOyByZXR1cm4gMTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZXF1YWwgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jb21wYXJlX3ZhbFxuZnVuY3Rpb24gY2FtbF9lcXVhbCAoeCwgeSkgeyByZXR1cm4gKyhjYW1sX2NvbXBhcmVfdmFsKHgseSxmYWxzZSkgPT0gMCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfbm90ZXF1YWwgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jb21wYXJlX3ZhbFxuZnVuY3Rpb24gY2FtbF9ub3RlcXVhbCAoeCwgeSkgeyByZXR1cm4gKyhjYW1sX2NvbXBhcmVfdmFsKHgseSxmYWxzZSkgIT0gMCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JlYXRlcmVxdWFsIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY29tcGFyZV92YWxcbmZ1bmN0aW9uIGNhbWxfZ3JlYXRlcmVxdWFsICh4LCB5KSB7IHJldHVybiArKGNhbWxfY29tcGFyZV92YWwoeCx5LGZhbHNlKSA+PSAwKTsgfVxuLy9Qcm92aWRlczogY2FtbF9ncmVhdGVydGhhbiBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsXG5mdW5jdGlvbiBjYW1sX2dyZWF0ZXJ0aGFuICh4LCB5KSB7IHJldHVybiArKGNhbWxfY29tcGFyZV92YWwoeCx5LGZhbHNlKSA+IDApOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2xlc3NlcXVhbCBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsXG5mdW5jdGlvbiBjYW1sX2xlc3NlcXVhbCAoeCwgeSkgeyByZXR1cm4gKyhjYW1sX2NvbXBhcmVfdmFsKHgseSxmYWxzZSkgPD0gMCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfbGVzc3RoYW4gbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jb21wYXJlX3ZhbFxuZnVuY3Rpb24gY2FtbF9sZXNzdGhhbiAoeCwgeSkgeyByZXR1cm4gKyhjYW1sX2NvbXBhcmVfdmFsKHgseSxmYWxzZSkgPCAwKTsgfVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDE0IErDqXLDtG1lIFZvdWlsbG9uLCBIdWdvIEhldXphcmRcbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogY2FtbF9DYW1saW50ZXJuYWxNb2RfaW5pdF9tb2Rcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfd2l0aF9hcmcsIGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfQ2FtbGludGVybmFsTW9kX2luaXRfbW9kKGxvYyxzaGFwZSkge1xuICBmdW5jdGlvbiB1bmRlZl9tb2R1bGUgKF94KSB7XG4gICAgY2FtbF9yYWlzZV93aXRoX2FyZyhjYW1sX2dsb2JhbF9kYXRhLlVuZGVmaW5lZF9yZWN1cnNpdmVfbW9kdWxlLCBsb2MpO1xuICB9XG4gIGZ1bmN0aW9uIGxvb3AgKHNoYXBlLHN0cnVjdCxpZHgpe1xuICAgIGlmKHR5cGVvZiBzaGFwZSA9PT0gXCJudW1iZXJcIilcbiAgICAgIHN3aXRjaChzaGFwZSl7XG4gICAgICBjYXNlIDA6Ly9mdW5jdGlvblxuICAgICAgICBzdHJ1Y3RbaWR4XT17ZnVuOnVuZGVmX21vZHVsZX07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxOi8vbGF6eVxuICAgICAgICBzdHJ1Y3RbaWR4XT1bMjQ2LCB1bmRlZl9tb2R1bGVdO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6Ly9jYXNlIDI6Ly9jbGFzc1xuICAgICAgICBzdHJ1Y3RbaWR4XT1bXTtcbiAgICAgIH1cbiAgICBlbHNlXG4gICAgICBzd2l0Y2goc2hhcGVbMF0pe1xuICAgICAgY2FzZSAwOi8vbW9kdWxlXG4gICAgICAgIHN0cnVjdFtpZHhdID0gWzBdO1xuICAgICAgICBmb3IodmFyIGk9MTtpPHNoYXBlWzFdLmxlbmd0aDtpKyspXG4gICAgICAgICAgbG9vcChzaGFwZVsxXVtpXSxzdHJ1Y3RbaWR4XSxpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0Oi8vY2FzZSAxOi8vVmFsdWVcbiAgICAgICAgc3RydWN0W2lkeF0gPSBzaGFwZVsxXTtcbiAgICAgIH1cbiAgfVxuICB2YXIgcmVzID0gW107XG4gIGxvb3Aoc2hhcGUscmVzLDApO1xuICByZXR1cm4gcmVzWzBdXG59XG4vL1Byb3ZpZGVzOiBjYW1sX0NhbWxpbnRlcm5hbE1vZF91cGRhdGVfbW9kXG4vL1JlcXVpcmVzOiBjYW1sX3VwZGF0ZV9kdW1teVxuZnVuY3Rpb24gY2FtbF9DYW1saW50ZXJuYWxNb2RfdXBkYXRlX21vZChzaGFwZSxyZWFsLHgpIHtcbiAgaWYodHlwZW9mIHNoYXBlID09PSBcIm51bWJlclwiKVxuICAgIHN3aXRjaChzaGFwZSl7XG4gICAgY2FzZSAwOi8vZnVuY3Rpb25cbiAgICBjYXNlIDE6Ly9sYXp5XG4gICAgY2FzZSAyOi8vY2xhc3NcbiAgICBkZWZhdWx0OlxuICAgICAgY2FtbF91cGRhdGVfZHVtbXkocmVhbCx4KTtcbiAgICB9XG4gIGVsc2VcbiAgICBzd2l0Y2goc2hhcGVbMF0pe1xuICAgIGNhc2UgMDovL21vZHVsZVxuICAgICAgZm9yKHZhciBpPTE7aTxzaGFwZVsxXS5sZW5ndGg7aSsrKVxuICAgICAgICBjYW1sX0NhbWxpbnRlcm5hbE1vZF91cGRhdGVfbW9kKHNoYXBlWzFdW2ldLHJlYWxbaV0seFtpXSk7XG4gICAgICBicmVhaztcbiAgICAgIC8vY2FzZSAxOi8vVmFsdWVcbiAgICBkZWZhdWx0OlxuICAgIH07XG4gIHJldHVybiAwXG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VwZGF0ZV9kdW1teVxuZnVuY3Rpb24gY2FtbF91cGRhdGVfZHVtbXkgKHgsIHkpIHtcbiAgaWYoIHR5cGVvZiB5PT09XCJmdW5jdGlvblwiICkgeyB4LmZ1biA9IHk7IHJldHVybiAwOyB9XG4gIGlmKCB5LmZ1biApIHsgeC5mdW4gPSB5LmZ1bjsgcmV0dXJuIDA7IH1cbiAgdmFyIGkgPSB5Lmxlbmd0aDsgd2hpbGUgKGktLSkgeFtpXSA9IHlbaV07IHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29ial9pc19ibG9jayBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX29ial9pc19ibG9jayAoeCkgeyByZXR1cm4gKyh4IGluc3RhbmNlb2YgQXJyYXkpOyB9XG5cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfdGFnXG4vL1JlcXVpcmVzOiBjYW1sX2lzX21sX2J5dGVzLCBjYW1sX2lzX21sX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9vYmpfdGFnICh4KSB7XG4gIGlmICgoeCBpbnN0YW5jZW9mIEFycmF5KSAmJiB4WzBdID09ICh4WzBdID4+PiAwKSlcbiAgICByZXR1cm4geFswXVxuICBlbHNlIGlmIChjYW1sX2lzX21sX2J5dGVzKHgpKVxuICAgIHJldHVybiAyNTJcbiAgZWxzZSBpZiAoY2FtbF9pc19tbF9zdHJpbmcoeCkpXG4gICAgcmV0dXJuIDI1MlxuICBlbHNlIGlmICgoeCBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB8fCB0eXBlb2YgeCA9PSBcImZ1bmN0aW9uXCIpXG4gICAgcmV0dXJuIDI0N1xuICBlbHNlIGlmICh4ICYmIHguY2FtbF9jdXN0b20pXG4gICAgcmV0dXJuIDI1NVxuICBlbHNlXG4gICAgcmV0dXJuIDEwMDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfc2V0X3RhZyAobXV0YWJsZSwgY29uc3QpXG5mdW5jdGlvbiBjYW1sX29ial9zZXRfdGFnICh4LCB0YWcpIHsgeFswXSA9IHRhZzsgcmV0dXJuIDA7IH1cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX2Jsb2NrIGNvbnN0IChjb25zdCxjb25zdClcbmZ1bmN0aW9uIGNhbWxfb2JqX2Jsb2NrICh0YWcsIHNpemUpIHtcbiAgdmFyIG8gPSBuZXcgQXJyYXkoc2l6ZSsxKTtcbiAgb1swXT10YWc7XG4gIGZvciAodmFyIGkgPSAxOyBpIDw9IHNpemU7IGkrKykgb1tpXSA9IDA7XG4gIHJldHVybiBvO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29ial93aXRoX3RhZ1xuZnVuY3Rpb24gY2FtbF9vYmpfd2l0aF90YWcodGFnLHgpIHtcbiAgdmFyIGwgPSB4Lmxlbmd0aDtcbiAgdmFyIGEgPSBuZXcgQXJyYXkobCk7XG4gIGFbMF0gPSB0YWc7XG4gIGZvcih2YXIgaSA9IDE7IGkgPCBsOyBpKysgKSBhW2ldID0geFtpXTtcbiAgcmV0dXJuIGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX2R1cCBtdXRhYmxlIChjb25zdClcbmZ1bmN0aW9uIGNhbWxfb2JqX2R1cCAoeCkge1xuICB2YXIgbCA9IHgubGVuZ3RoO1xuICB2YXIgYSA9IG5ldyBBcnJheShsKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGw7IGkrKyApIGFbaV0gPSB4W2ldO1xuICByZXR1cm4gYTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfdHJ1bmNhdGUgKG11dGFibGUsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX29ial90cnVuY2F0ZSAoeCwgcykge1xuICBpZiAoczw9MCB8fCBzICsgMSA+IHgubGVuZ3RoKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudCAoXCJPYmoudHJ1bmNhdGVcIik7XG4gIGlmICh4Lmxlbmd0aCAhPSBzICsgMSkgeC5sZW5ndGggPSBzICsgMTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX21ha2VfZm9yd2FyZFxuZnVuY3Rpb24gY2FtbF9vYmpfbWFrZV9mb3J3YXJkIChiLHYpIHtcbiAgYlswXT0yNTA7XG4gIGJbMV09djtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9sYXp5X21ha2VfZm9yd2FyZCBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX2xhenlfbWFrZV9mb3J3YXJkICh2KSB7IHJldHVybiBbMjUwLCB2XTsgfVxuXG4vLy8vLy8vLy8vLy8vIENhbWxpbnRlcm5hbE9PXG4vL1Byb3ZpZGVzOiBjYW1sX2dldF9wdWJsaWNfbWV0aG9kIGNvbnN0XG52YXIgY2FtbF9tZXRob2RfY2FjaGUgPSBbXTtcbmZ1bmN0aW9uIGNhbWxfZ2V0X3B1YmxpY19tZXRob2QgKG9iaiwgdGFnLCBjYWNoZWlkKSB7XG4gIHZhciBtZXRocyA9IG9ialsxXTtcbiAgdmFyIG9mcyA9IGNhbWxfbWV0aG9kX2NhY2hlW2NhY2hlaWRdO1xuICBpZiAob2ZzID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBNYWtlIHN1cmUgdGhlIGFycmF5IGlzIG5vdCBzcGFyc2VcbiAgICBmb3IgKHZhciBpID0gY2FtbF9tZXRob2RfY2FjaGUubGVuZ3RoOyBpIDwgY2FjaGVpZDsgaSsrKVxuICAgICAgY2FtbF9tZXRob2RfY2FjaGVbaV0gPSAwO1xuICB9IGVsc2UgaWYgKG1ldGhzW29mc10gPT09IHRhZykge1xuICAgIHJldHVybiBtZXRoc1tvZnMgLSAxXTtcbiAgfVxuICB2YXIgbGkgPSAzLCBoaSA9IG1ldGhzWzFdICogMiArIDEsIG1pO1xuICB3aGlsZSAobGkgPCBoaSkge1xuICAgIG1pID0gKChsaStoaSkgPj4gMSkgfCAxO1xuICAgIGlmICh0YWcgPCBtZXRoc1ttaSsxXSkgaGkgPSBtaS0yO1xuICAgIGVsc2UgbGkgPSBtaTtcbiAgfVxuICBjYW1sX21ldGhvZF9jYWNoZVtjYWNoZWlkXSA9IGxpICsgMTtcbiAgLyogcmV0dXJuIDAgaWYgdGFnIGlzIG5vdCB0aGVyZSAqL1xuICByZXR1cm4gKHRhZyA9PSBtZXRoc1tsaSsxXSA/IG1ldGhzW2xpXSA6IDApO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29vX2xhc3RfaWRcbnZhciBjYW1sX29vX2xhc3RfaWQgPSAwO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX3NldF9vb19pZFxuLy9SZXF1aXJlczogY2FtbF9vb19sYXN0X2lkXG5mdW5jdGlvbiBjYW1sX3NldF9vb19pZCAoYikge1xuICBiWzJdPWNhbWxfb29fbGFzdF9pZCsrO1xuICByZXR1cm4gYjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9mcmVzaF9vb19pZFxuLy9SZXF1aXJlczogY2FtbF9vb19sYXN0X2lkXG5mdW5jdGlvbiBjYW1sX2ZyZXNoX29vX2lkKCkge1xuICByZXR1cm4gY2FtbF9vb19sYXN0X2lkKys7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX3Jhd19maWVsZFxuZnVuY3Rpb24gY2FtbF9vYmpfcmF3X2ZpZWxkKG8saSkgeyByZXR1cm4gb1tpKzFdIH1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfc2V0X3Jhd19maWVsZFxuZnVuY3Rpb24gY2FtbF9vYmpfc2V0X3Jhd19maWVsZChvLGksdikgeyByZXR1cm4gb1tpKzFdID0gdiB9XG4iLCIvLy8vLy8vLy8gQklHU1RSSU5HXG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfYmlnc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2J5dGVzX2FyclxuZnVuY3Rpb24gY2FtbF9oYXNoX21peF9iaWdzdHJpbmcoaCwgYnMpIHtcbiAgcmV0dXJuIGNhbWxfaGFzaF9taXhfYnl0ZXNfYXJyKGgsYnMuZGF0YSk7XG59XG5cbi8vUHJvdmlkZXM6IGJpZ3N0cmluZ190b19hcnJheV9idWZmZXIgbXV0YWJsZVxuZnVuY3Rpb24gYmlnc3RyaW5nX3RvX2FycmF5X2J1ZmZlcihicykge1xuICByZXR1cm4gYnMuZGF0YS5idWZmZXJcbn1cblxuLy9Qcm92aWRlczogYmlnc3RyaW5nX3RvX3R5cGVkX2FycmF5IG11dGFibGVcbmZ1bmN0aW9uIGJpZ3N0cmluZ190b190eXBlZF9hcnJheShicykge1xuICByZXR1cm4gYnMuZGF0YVxufVxuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdfb2ZfYXJyYXlfYnVmZmVyIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfYmFfY3JlYXRlX3Vuc2FmZVxuZnVuY3Rpb24gYmlnc3RyaW5nX29mX2FycmF5X2J1ZmZlcihhYikge1xuICB2YXIgdGEgPSBuZXcgam9vX2dsb2JhbF9vYmplY3QuVWludDhBcnJheShhYik7XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoMTIsIDAsIFt0YS5sZW5ndGhdLCB0YSk7XG59XG5cbi8vUHJvdmlkZXM6IGJpZ3N0cmluZ19vZl90eXBlZF9hcnJheSBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2NyZWF0ZV91bnNhZmVcbmZ1bmN0aW9uIGJpZ3N0cmluZ19vZl90eXBlZF9hcnJheShiYSkge1xuICB2YXIgdGEgPSBuZXcgam9vX2dsb2JhbF9vYmplY3QuVWludDhBcnJheShiYS5idWZmZXIsIGJhLmJ5dGVPZmZzZXQsIGJhLmxlbmd0aCAqIGJhLkJZVEVTX1BFUl9FTEVNRU5UKTtcbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZSgxMiwgMCwgW3RhLmxlbmd0aF0sIHRhKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iaWdzdHJpbmdfbWVtY21wXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF8xXG5mdW5jdGlvbiBjYW1sX2JpZ3N0cmluZ19tZW1jbXAoczEsIHBvczEsIHMyLCBwb3MyLCBsZW4pe1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIGEgPSBjYW1sX2JhX2dldF8xKHMxLHBvczEgKyBpKTtcbiAgICB2YXIgYiA9IGNhbWxfYmFfZ2V0XzEoczIscG9zMiArIGkpO1xuICAgIGlmIChhIDwgYikgcmV0dXJuIC0xO1xuICAgIGlmIChhID4gYikgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYmFcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19iYShiYTEsIHBvczEsIGJhMiwgcG9zMiwgbGVuKXtcbiAgaWYoMTIgIT0gYmExLmtpbmQpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19iYToga2luZCBtaXNtYXRjaFwiKTtcbiAgaWYoMTIgIT0gYmEyLmtpbmQpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19iYToga2luZCBtaXNtYXRjaFwiKTtcbiAgaWYobGVuID09IDApIHJldHVybiAwO1xuICB2YXIgb2ZzMSA9IGJhMS5vZmZzZXQocG9zMSk7XG4gIHZhciBvZnMyID0gYmEyLm9mZnNldChwb3MyKTtcbiAgaWYob2ZzMSArIGxlbiA+IGJhMS5kYXRhLmxlbmd0aCl7XG4gICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB9XG4gIGlmKG9mczIgKyBsZW4gPiBiYTIuZGF0YS5sZW5ndGgpe1xuICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgfVxuICB2YXIgc2xpY2UgPSBiYTEuZGF0YS5zdWJhcnJheShvZnMxLG9mczErbGVuKTtcbiAgYmEyLmRhdGEuc2V0KHNsaWNlLHBvczIpO1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JpZ3N0cmluZ19ibGl0X3N0cmluZ190b19iYVxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2FycmF5X2JvdW5kX2Vycm9yLCBjYW1sX2FycmF5X29mX3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoXG5mdW5jdGlvbiBjYW1sX2JpZ3N0cmluZ19ibGl0X3N0cmluZ190b19iYShzdHIxLCBwb3MxLCBiYTIsIHBvczIsIGxlbil7XG4gIGlmKDEyICE9IGJhMi5raW5kKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNhbWxfYmlnc3RyaW5nX2JsaXRfc3RyaW5nX3RvX2JhOiBraW5kIG1pc21hdGNoXCIpO1xuICBpZihsZW4gPT0gMCkgcmV0dXJuIDA7XG4gIHZhciBvZnMyID0gYmEyLm9mZnNldChwb3MyKTtcbiAgaWYocG9zMSArIGxlbiA+IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzdHIxKSkge1xuICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgfVxuICBpZihvZnMyICsgbGVuID4gYmEyLmRhdGEubGVuZ3RoKSB7XG4gICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB9XG4gIHZhciBzbGljZSA9IGNhbWxfYXJyYXlfb2Zfc3RyaW5nKHN0cjEpLnNsaWNlKHBvczEscG9zMSArIGxlbik7XG4gIGJhMi5kYXRhLnNldChzbGljZSxvZnMyKTtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iaWdzdHJpbmdfYmxpdF9ieXRlc190b19iYVxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2FycmF5X2JvdW5kX2Vycm9yLCBjYW1sX2FycmF5X29mX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX21sX2J5dGVzX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9iaWdzdHJpbmdfYmxpdF9ieXRlc190b19iYShzdHIxLCBwb3MxLCBiYTIsIHBvczIsIGxlbil7XG4gIGlmKDEyICE9IGJhMi5raW5kKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNhbWxfYmlnc3RyaW5nX2JsaXRfc3RyaW5nX3RvX2JhOiBraW5kIG1pc21hdGNoXCIpO1xuICBpZihsZW4gPT0gMCkgcmV0dXJuIDA7XG4gIHZhciBvZnMyID0gYmEyLm9mZnNldChwb3MyKTtcbiAgaWYocG9zMSArIGxlbiA+IGNhbWxfbWxfYnl0ZXNfbGVuZ3RoKHN0cjEpKSB7XG4gICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB9XG4gIGlmKG9mczIgKyBsZW4gPiBiYTIuZGF0YS5sZW5ndGgpIHtcbiAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIH1cbiAgdmFyIHNsaWNlID0gY2FtbF9hcnJheV9vZl9ieXRlcyhzdHIxKS5zbGljZShwb3MxLHBvczEgKyBsZW4pO1xuICBiYTIuZGF0YS5zZXQoc2xpY2Usb2ZzMik7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9ibGl0X2J5dGVzLCBjYW1sX2J5dGVzX29mX2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX21sX2J5dGVzX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19ieXRlcyhiYTEsIHBvczEsIGJ5dGVzMiwgcG9zMiwgbGVuKXtcbiAgaWYoMTIgIT0gYmExLmtpbmQpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY2FtbF9iaWdzdHJpbmdfYmxpdF9zdHJpbmdfdG9fYmE6IGtpbmQgbWlzbWF0Y2hcIik7XG4gIGlmKGxlbiA9PSAwKSByZXR1cm4gMDtcbiAgdmFyIG9mczEgPSBiYTEub2Zmc2V0KHBvczEpO1xuICBpZihvZnMxICsgbGVuID4gYmExLmRhdGEubGVuZ3RoKXtcbiAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIH1cbiAgaWYocG9zMiArIGxlbiA+IGNhbWxfbWxfYnl0ZXNfbGVuZ3RoKGJ5dGVzMikpe1xuICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgfVxuICB2YXIgc2xpY2UgPSBiYTEuZGF0YS5zbGljZShvZnMxLCBvZnMxK2xlbik7XG4gIGNhbWxfYmxpdF9ieXRlcyhjYW1sX2J5dGVzX29mX2FycmF5KHNsaWNlKSwgMCwgYnl0ZXMyLCBwb3MyLCBsZW4pO1xuICByZXR1cm4gMFxufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogY2FtbF9tbF9kZWJ1Z19pbmZvX3N0YXR1cyBjb25zdFxuZnVuY3Rpb24gY2FtbF9tbF9kZWJ1Z19pbmZvX3N0YXR1cyAoKSB7IHJldHVybiAwOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2JhY2t0cmFjZV9zdGF0dXMgY29uc3RcbmZ1bmN0aW9uIGNhbWxfYmFja3RyYWNlX3N0YXR1cyAoKSB7IHJldHVybiAwOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2dldF9leGNlcHRpb25fYmFja3RyYWNlIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2dldF9leGNlcHRpb25fYmFja3RyYWNlICgpIHsgcmV0dXJuIDA7IH1cbi8vUHJvdmlkZXM6IGNhbWxfZ2V0X2V4Y2VwdGlvbl9yYXdfYmFja3RyYWNlIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2dldF9leGNlcHRpb25fcmF3X2JhY2t0cmFjZSAoKSB7IHJldHVybiBbMF07IH1cbi8vUHJvdmlkZXM6IGNhbWxfcmVjb3JkX2JhY2t0cmFjZVxuZnVuY3Rpb24gY2FtbF9yZWNvcmRfYmFja3RyYWNlICgpIHsgcmV0dXJuIDA7IH1cbi8vUHJvdmlkZXM6IGNhbWxfY29udmVydF9yYXdfYmFja3RyYWNlIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2NvbnZlcnRfcmF3X2JhY2t0cmFjZSAoKSB7IHJldHVybiBbMF07IH1cbi8vUHJvdmlkZXM6IGNhbWxfcmF3X2JhY2t0cmFjZV9sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfcmF3X2JhY2t0cmFjZV9sZW5ndGgoKSB7IHJldHVybiAwOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX3Jhd19iYWNrdHJhY2VfbmV4dF9zbG90XG5mdW5jdGlvbiBjYW1sX3Jhd19iYWNrdHJhY2VfbmV4dF9zbG90KCkgeyByZXR1cm4gMCB9XG4vL1Byb3ZpZGVzOiBjYW1sX3Jhd19iYWNrdHJhY2Vfc2xvdFxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX3Jhd19iYWNrdHJhY2Vfc2xvdCAoKSB7XG4gIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIlByaW50ZXhjLmdldF9yYXdfYmFja3RyYWNlX3Nsb3Q6IGluZGV4IG91dCBvZiBib3VuZHNcIik7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX3Jlc3RvcmVfcmF3X2JhY2t0cmFjZVxuZnVuY3Rpb24gY2FtbF9yZXN0b3JlX3Jhd19iYWNrdHJhY2UoZXhuLCBidCkgeyByZXR1cm4gMCB9XG4vL1Byb3ZpZGVzOiBjYW1sX2dldF9jdXJyZW50X2NhbGxzdGFjayBjb25zdFxuZnVuY3Rpb24gY2FtbF9nZXRfY3VycmVudF9jYWxsc3RhY2sgKCkgeyByZXR1cm4gWzBdOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfY29udmVydF9yYXdfYmFja3RyYWNlX3Nsb3Rcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfY29udmVydF9yYXdfYmFja3RyYWNlX3Nsb3QoKXtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfY29udmVydF9yYXdfYmFja3RyYWNlX3Nsb3RcIik7XG59XG4iLCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdGl2ZSBDYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKiAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKiAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICovXG4vKiAgZW4gQXV0b21hdGlxdWUuICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkICAgICovXG4vKiAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UsIHdpdGggICAgICovXG4vKiAgdGhlIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIGZpbGUgLi4vTElDRU5TRS4gICAgICovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8qICRJZDogbGV4aW5nLmMgNjA0NSAyMDA0LTAxLTAxIDE2OjQyOjQzWiBkb2xpZ2V6ICQgKi9cblxuLyogVGhlIHRhYmxlLWRyaXZlbiBhdXRvbWF0b24gZm9yIGxleGVycyBnZW5lcmF0ZWQgYnkgY2FtbGxleC4gKi9cblxuLy9Qcm92aWRlczogY2FtbF9sZXhfYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfbGV4X2FycmF5KHMpIHtcbiAgcyA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcocyk7XG4gIHZhciBsID0gcy5sZW5ndGggLyAyO1xuICB2YXIgYSA9IG5ldyBBcnJheShsKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspXG4gICAgYVtpXSA9IChzLmNoYXJDb2RlQXQoMiAqIGkpIHwgKHMuY2hhckNvZGVBdCgyICogaSArIDEpIDw8IDgpKSA8PCAxNiA+PiAxNjtcbiAgcmV0dXJuIGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbGV4X2VuZ2luZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aCwgY2FtbF9sZXhfYXJyYXksIGNhbWxfYXJyYXlfb2ZfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfbGV4X2VuZ2luZSh0YmwsIHN0YXJ0X3N0YXRlLCBsZXhidWYpIHtcbiAgdmFyIGxleF9idWZmZXIgPSAyO1xuICB2YXIgbGV4X2J1ZmZlcl9sZW4gPSAzO1xuICB2YXIgbGV4X3N0YXJ0X3BvcyA9IDU7XG4gIHZhciBsZXhfY3Vycl9wb3MgPSA2O1xuICB2YXIgbGV4X2xhc3RfcG9zID0gNztcbiAgdmFyIGxleF9sYXN0X2FjdGlvbiA9IDg7XG4gIHZhciBsZXhfZW9mX3JlYWNoZWQgPSA5O1xuICB2YXIgbGV4X2Jhc2UgPSAxO1xuICB2YXIgbGV4X2JhY2t0cmsgPSAyO1xuICB2YXIgbGV4X2RlZmF1bHQgPSAzO1xuICB2YXIgbGV4X3RyYW5zID0gNDtcbiAgdmFyIGxleF9jaGVjayA9IDU7XG5cbiAgaWYgKCF0YmwubGV4X2RlZmF1bHQpIHtcbiAgICB0YmwubGV4X2Jhc2UgPSAgICBjYW1sX2xleF9hcnJheSAodGJsW2xleF9iYXNlXSk7XG4gICAgdGJsLmxleF9iYWNrdHJrID0gY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfYmFja3Rya10pO1xuICAgIHRibC5sZXhfY2hlY2sgPSAgIGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2NoZWNrXSk7XG4gICAgdGJsLmxleF90cmFucyA9ICAgY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfdHJhbnNdKTtcbiAgICB0YmwubGV4X2RlZmF1bHQgPSBjYW1sX2xleF9hcnJheSAodGJsW2xleF9kZWZhdWx0XSk7XG4gIH1cblxuICB2YXIgYywgc3RhdGUgPSBzdGFydF9zdGF0ZTtcblxuICB2YXIgYnVmZmVyID0gY2FtbF9hcnJheV9vZl9ieXRlcyhsZXhidWZbbGV4X2J1ZmZlcl0pO1xuXG4gIGlmIChzdGF0ZSA+PSAwKSB7XG4gICAgLyogRmlyc3QgZW50cnkgKi9cbiAgICBsZXhidWZbbGV4X2xhc3RfcG9zXSA9IGxleGJ1ZltsZXhfc3RhcnRfcG9zXSA9IGxleGJ1ZltsZXhfY3Vycl9wb3NdO1xuICAgIGxleGJ1ZltsZXhfbGFzdF9hY3Rpb25dID0gLTE7XG4gIH0gZWxzZSB7XG4gICAgLyogUmVlbnRyeSBhZnRlciByZWZpbGwgKi9cbiAgICBzdGF0ZSA9IC1zdGF0ZSAtIDE7XG4gIH1cbiAgZm9yKDs7KSB7XG4gICAgLyogTG9va3VwIGJhc2UgYWRkcmVzcyBvciBhY3Rpb24gbnVtYmVyIGZvciBjdXJyZW50IHN0YXRlICovXG4gICAgdmFyIGJhc2UgPSB0YmwubGV4X2Jhc2Vbc3RhdGVdO1xuICAgIGlmIChiYXNlIDwgMCkgcmV0dXJuIC1iYXNlLTE7XG4gICAgLyogU2VlIGlmIGl0J3MgYSBiYWNrdHJhY2sgcG9pbnQgKi9cbiAgICB2YXIgYmFja3RyayA9IHRibC5sZXhfYmFja3Rya1tzdGF0ZV07XG4gICAgaWYgKGJhY2t0cmsgPj0gMCkge1xuICAgICAgbGV4YnVmW2xleF9sYXN0X3Bvc10gPSBsZXhidWZbbGV4X2N1cnJfcG9zXTtcbiAgICAgIGxleGJ1ZltsZXhfbGFzdF9hY3Rpb25dID0gYmFja3RyaztcbiAgICB9XG4gICAgLyogU2VlIGlmIHdlIG5lZWQgYSByZWZpbGwgKi9cbiAgICBpZiAobGV4YnVmW2xleF9jdXJyX3Bvc10gPj0gbGV4YnVmW2xleF9idWZmZXJfbGVuXSl7XG4gICAgICBpZiAobGV4YnVmW2xleF9lb2ZfcmVhY2hlZF0gPT0gMClcbiAgICAgICAgcmV0dXJuIC1zdGF0ZSAtIDE7XG4gICAgICBlbHNlXG4gICAgICAgIGMgPSAyNTY7XG4gICAgfWVsc2V7XG4gICAgICAvKiBSZWFkIG5leHQgaW5wdXQgY2hhciAqL1xuICAgICAgYyA9IGJ1ZmZlcltsZXhidWZbbGV4X2N1cnJfcG9zXV07XG4gICAgICBsZXhidWZbbGV4X2N1cnJfcG9zXSArKztcbiAgICB9XG4gICAgLyogRGV0ZXJtaW5lIG5leHQgc3RhdGUgKi9cbiAgICBpZiAodGJsLmxleF9jaGVja1tiYXNlICsgY10gPT0gc3RhdGUpXG4gICAgICBzdGF0ZSA9IHRibC5sZXhfdHJhbnNbYmFzZSArIGNdO1xuICAgIGVsc2VcbiAgICAgIHN0YXRlID0gdGJsLmxleF9kZWZhdWx0W3N0YXRlXTtcbiAgICAvKiBJZiBubyB0cmFuc2l0aW9uIG9uIHRoaXMgY2hhciwgcmV0dXJuIHRvIGxhc3QgYmFja3RyYWNrIHBvaW50ICovXG4gICAgaWYgKHN0YXRlIDwgMCkge1xuICAgICAgbGV4YnVmW2xleF9jdXJyX3Bvc10gPSBsZXhidWZbbGV4X2xhc3RfcG9zXTtcbiAgICAgIGlmIChsZXhidWZbbGV4X2xhc3RfYWN0aW9uXSA9PSAtMSlcbiAgICAgICAgY2FtbF9mYWlsd2l0aChcImxleGluZzogZW1wdHkgdG9rZW5cIik7XG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiBsZXhidWZbbGV4X2xhc3RfYWN0aW9uXTtcbiAgICB9ZWxzZXtcbiAgICAgIC8qIEVyYXNlIHRoZSBFT0YgY29uZGl0aW9uIG9ubHkgaWYgdGhlIEVPRiBwc2V1ZG8tY2hhcmFjdGVyIHdhc1xuICAgICAgICAgY29uc3VtZWQgYnkgdGhlIGF1dG9tYXRvbiAoaS5lLiB0aGVyZSB3YXMgbm8gYmFja3RyYWNrIGFib3ZlKVxuICAgICAgKi9cbiAgICAgIGlmIChjID09IDI1NikgbGV4YnVmW2xleF9lb2ZfcmVhY2hlZF0gPSAwO1xuICAgIH1cbiAgfVxufVxuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiBOZXcgbGV4ZXIgZW5naW5lLCB3aXRoIG1lbW9yeSBvZiBwb3NpdGlvbnMgICovXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8vUHJvdmlkZXM6IGNhbWxfbmV3X2xleF9lbmdpbmVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGgsIGNhbWxfbGV4X2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nLCBjYW1sX2FycmF5X29mX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2xleF9ydW5fbWVtKHMsIGksIG1lbSwgY3Vycl9wb3MpIHtcbiAgZm9yICg7Oykge1xuICAgIHZhciBkc3QgPSBzLmNoYXJDb2RlQXQoaSk7IGkrKztcbiAgICBpZiAoZHN0ID09IDB4ZmYpIHJldHVybjtcbiAgICB2YXIgc3JjID0gcy5jaGFyQ29kZUF0KGkpOyBpKys7XG4gICAgaWYgKHNyYyA9PSAweGZmKVxuICAgICAgbWVtIFtkc3QgKyAxXSA9IGN1cnJfcG9zO1xuICAgIGVsc2VcbiAgICAgIG1lbSBbZHN0ICsgMV0gPSBtZW0gW3NyYyArIDFdO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbWxfbGV4X3J1bl90YWcocywgaSwgbWVtKSB7XG4gIGZvciAoOzspIHtcbiAgICB2YXIgZHN0ID0gcy5jaGFyQ29kZUF0KGkpOyBpKys7XG4gICAgaWYgKGRzdCA9PSAweGZmKSByZXR1cm4gO1xuICAgIHZhciBzcmMgPSBzLmNoYXJDb2RlQXQoaSk7IGkrKztcbiAgICBpZiAoc3JjID09IDB4ZmYpXG4gICAgICBtZW0gW2RzdCArIDFdID0gLTE7XG4gICAgZWxzZVxuICAgICAgbWVtIFtkc3QgKyAxXSA9IG1lbSBbc3JjICsgMV07XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FtbF9uZXdfbGV4X2VuZ2luZSh0YmwsIHN0YXJ0X3N0YXRlLCBsZXhidWYpIHtcbiAgdmFyIGxleF9idWZmZXIgPSAyO1xuICB2YXIgbGV4X2J1ZmZlcl9sZW4gPSAzO1xuICB2YXIgbGV4X3N0YXJ0X3BvcyA9IDU7XG4gIHZhciBsZXhfY3Vycl9wb3MgPSA2O1xuICB2YXIgbGV4X2xhc3RfcG9zID0gNztcbiAgdmFyIGxleF9sYXN0X2FjdGlvbiA9IDg7XG4gIHZhciBsZXhfZW9mX3JlYWNoZWQgPSA5O1xuICB2YXIgbGV4X21lbSA9IDEwO1xuICB2YXIgbGV4X2Jhc2UgPSAxO1xuICB2YXIgbGV4X2JhY2t0cmsgPSAyO1xuICB2YXIgbGV4X2RlZmF1bHQgPSAzO1xuICB2YXIgbGV4X3RyYW5zID0gNDtcbiAgdmFyIGxleF9jaGVjayA9IDU7XG4gIHZhciBsZXhfYmFzZV9jb2RlID0gNjtcbiAgdmFyIGxleF9iYWNrdHJrX2NvZGUgPSA3O1xuICB2YXIgbGV4X2RlZmF1bHRfY29kZSA9IDg7XG4gIHZhciBsZXhfdHJhbnNfY29kZSA9IDk7XG4gIHZhciBsZXhfY2hlY2tfY29kZSA9IDEwO1xuICB2YXIgbGV4X2NvZGUgPSAxMTtcblxuICBpZiAoIXRibC5sZXhfZGVmYXVsdCkge1xuICAgIHRibC5sZXhfYmFzZSA9ICAgIGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2Jhc2VdKTtcbiAgICB0YmwubGV4X2JhY2t0cmsgPSBjYW1sX2xleF9hcnJheSAodGJsW2xleF9iYWNrdHJrXSk7XG4gICAgdGJsLmxleF9jaGVjayA9ICAgY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfY2hlY2tdKTtcbiAgICB0YmwubGV4X3RyYW5zID0gICBjYW1sX2xleF9hcnJheSAodGJsW2xleF90cmFuc10pO1xuICAgIHRibC5sZXhfZGVmYXVsdCA9IGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2RlZmF1bHRdKTtcbiAgfVxuICBpZiAoIXRibC5sZXhfZGVmYXVsdF9jb2RlKSB7XG4gICAgdGJsLmxleF9iYXNlX2NvZGUgPSAgICBjYW1sX2xleF9hcnJheSAodGJsW2xleF9iYXNlX2NvZGVdKTtcbiAgICB0YmwubGV4X2JhY2t0cmtfY29kZSA9IGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2JhY2t0cmtfY29kZV0pO1xuICAgIHRibC5sZXhfY2hlY2tfY29kZSA9ICAgY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfY2hlY2tfY29kZV0pO1xuICAgIHRibC5sZXhfdHJhbnNfY29kZSA9ICAgY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfdHJhbnNfY29kZV0pO1xuICAgIHRibC5sZXhfZGVmYXVsdF9jb2RlID0gY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfZGVmYXVsdF9jb2RlXSk7XG4gIH1cbiAgaWYgKHRibC5sZXhfY29kZSA9PSBudWxsKSB0YmwubGV4X2NvZGUgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKHRibFtsZXhfY29kZV0pO1xuXG4gIHZhciBjLCBzdGF0ZSA9IHN0YXJ0X3N0YXRlO1xuXG4gIHZhciBidWZmZXIgPSBjYW1sX2FycmF5X29mX2J5dGVzKGxleGJ1ZltsZXhfYnVmZmVyXSk7XG5cbiAgaWYgKHN0YXRlID49IDApIHtcbiAgICAvKiBGaXJzdCBlbnRyeSAqL1xuICAgIGxleGJ1ZltsZXhfbGFzdF9wb3NdID0gbGV4YnVmW2xleF9zdGFydF9wb3NdID0gbGV4YnVmW2xleF9jdXJyX3Bvc107XG4gICAgbGV4YnVmW2xleF9sYXN0X2FjdGlvbl0gPSAtMTtcbiAgfSBlbHNlIHtcbiAgICAvKiBSZWVudHJ5IGFmdGVyIHJlZmlsbCAqL1xuICAgIHN0YXRlID0gLXN0YXRlIC0gMTtcbiAgfVxuICBmb3IoOzspIHtcbiAgICAvKiBMb29rdXAgYmFzZSBhZGRyZXNzIG9yIGFjdGlvbiBudW1iZXIgZm9yIGN1cnJlbnQgc3RhdGUgKi9cbiAgICB2YXIgYmFzZSA9IHRibC5sZXhfYmFzZVtzdGF0ZV07XG4gICAgaWYgKGJhc2UgPCAwKSB7XG4gICAgICB2YXIgcGNfb2ZmID0gdGJsLmxleF9iYXNlX2NvZGVbc3RhdGVdO1xuICAgICAgY2FtbF9sZXhfcnVuX3RhZyh0YmwubGV4X2NvZGUsIHBjX29mZiwgbGV4YnVmW2xleF9tZW1dKTtcbiAgICAgIHJldHVybiAtYmFzZS0xO1xuICAgIH1cbiAgICAvKiBTZWUgaWYgaXQncyBhIGJhY2t0cmFjayBwb2ludCAqL1xuICAgIHZhciBiYWNrdHJrID0gdGJsLmxleF9iYWNrdHJrW3N0YXRlXTtcbiAgICBpZiAoYmFja3RyayA+PSAwKSB7XG4gICAgICB2YXIgcGNfb2ZmID0gdGJsLmxleF9iYWNrdHJrX2NvZGVbc3RhdGVdO1xuICAgICAgY2FtbF9sZXhfcnVuX3RhZyh0YmwubGV4X2NvZGUsIHBjX29mZiwgbGV4YnVmW2xleF9tZW1dKTtcbiAgICAgIGxleGJ1ZltsZXhfbGFzdF9wb3NdID0gbGV4YnVmW2xleF9jdXJyX3Bvc107XG4gICAgICBsZXhidWZbbGV4X2xhc3RfYWN0aW9uXSA9IGJhY2t0cms7XG4gICAgfVxuICAgIC8qIFNlZSBpZiB3ZSBuZWVkIGEgcmVmaWxsICovXG4gICAgaWYgKGxleGJ1ZltsZXhfY3Vycl9wb3NdID49IGxleGJ1ZltsZXhfYnVmZmVyX2xlbl0pe1xuICAgICAgaWYgKGxleGJ1ZltsZXhfZW9mX3JlYWNoZWRdID09IDApXG4gICAgICAgIHJldHVybiAtc3RhdGUgLSAxO1xuICAgICAgZWxzZVxuICAgICAgICBjID0gMjU2O1xuICAgIH1lbHNle1xuICAgICAgLyogUmVhZCBuZXh0IGlucHV0IGNoYXIgKi9cbiAgICAgIGMgPSBidWZmZXJbbGV4YnVmW2xleF9jdXJyX3Bvc11dO1xuICAgICAgbGV4YnVmW2xleF9jdXJyX3Bvc10gKys7XG4gICAgfVxuICAgIC8qIERldGVybWluZSBuZXh0IHN0YXRlICovXG4gICAgdmFyIHBzdGF0ZSA9IHN0YXRlIDtcbiAgICBpZiAodGJsLmxleF9jaGVja1tiYXNlICsgY10gPT0gc3RhdGUpXG4gICAgICBzdGF0ZSA9IHRibC5sZXhfdHJhbnNbYmFzZSArIGNdO1xuICAgIGVsc2VcbiAgICAgIHN0YXRlID0gdGJsLmxleF9kZWZhdWx0W3N0YXRlXTtcbiAgICAvKiBJZiBubyB0cmFuc2l0aW9uIG9uIHRoaXMgY2hhciwgcmV0dXJuIHRvIGxhc3QgYmFja3RyYWNrIHBvaW50ICovXG4gICAgaWYgKHN0YXRlIDwgMCkge1xuICAgICAgbGV4YnVmW2xleF9jdXJyX3Bvc10gPSBsZXhidWZbbGV4X2xhc3RfcG9zXTtcbiAgICAgIGlmIChsZXhidWZbbGV4X2xhc3RfYWN0aW9uXSA9PSAtMSlcbiAgICAgICAgY2FtbF9mYWlsd2l0aChcImxleGluZzogZW1wdHkgdG9rZW5cIik7XG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiBsZXhidWZbbGV4X2xhc3RfYWN0aW9uXTtcbiAgICB9ZWxzZXtcbiAgICAgIC8qIElmIHNvbWUgdHJhbnNpdGlvbiwgZ2V0IGFuZCBwZXJmb3JtIG1lbW9yeSBtb3ZlcyAqL1xuICAgICAgdmFyIGJhc2VfY29kZSA9IHRibC5sZXhfYmFzZV9jb2RlW3BzdGF0ZV0sIHBjX29mZjtcbiAgICAgIGlmICh0YmwubGV4X2NoZWNrX2NvZGVbYmFzZV9jb2RlICsgY10gPT0gcHN0YXRlKVxuICAgICAgICBwY19vZmYgPSB0YmwubGV4X3RyYW5zX2NvZGVbYmFzZV9jb2RlICsgY107XG4gICAgICBlbHNlXG4gICAgICAgIHBjX29mZiA9IHRibC5sZXhfZGVmYXVsdF9jb2RlW3BzdGF0ZV07XG4gICAgICBpZiAocGNfb2ZmID4gMClcbiAgICAgICAgY2FtbF9sZXhfcnVuX21lbVxuICAgICAgKHRibC5sZXhfY29kZSwgcGNfb2ZmLCBsZXhidWZbbGV4X21lbV0sIGxleGJ1ZltsZXhfY3Vycl9wb3NdKTtcbiAgICAgIC8qIEVyYXNlIHRoZSBFT0YgY29uZGl0aW9uIG9ubHkgaWYgdGhlIEVPRiBwc2V1ZG8tY2hhcmFjdGVyIHdhc1xuICAgICAgICAgY29uc3VtZWQgYnkgdGhlIGF1dG9tYXRvbiAoaS5lLiB0aGVyZSB3YXMgbm8gYmFja3RyYWNrIGFib3ZlKVxuICAgICAgKi9cbiAgICAgIGlmIChjID09IDI1NikgbGV4YnVmW2xleF9lb2ZfcmVhY2hlZF0gPSAwO1xuICAgIH1cbiAgfVxufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8vLy8vLy8vLy8vLyBBcnJheVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X3N1YiBtdXRhYmxlXG5mdW5jdGlvbiBjYW1sX2FycmF5X3N1YiAoYSwgaSwgbGVuKSB7XG4gIHZhciBhMiA9IG5ldyBBcnJheShsZW4rMSk7XG4gIGEyWzBdPTA7XG4gIGZvcih2YXIgaTIgPSAxLCBpMT0gaSsxOyBpMiA8PSBsZW47IGkyKyssaTErKyApe1xuICAgIGEyW2kyXT1hW2kxXTtcbiAgfVxuICByZXR1cm4gYTI7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYXJyYXlfYXBwZW5kIG11dGFibGVcbmZ1bmN0aW9uIGNhbWxfYXJyYXlfYXBwZW5kKGExLCBhMikge1xuICB2YXIgbDEgPSBhMS5sZW5ndGgsIGwyID0gYTIubGVuZ3RoO1xuICB2YXIgbCA9IGwxK2wyLTFcbiAgdmFyIGEgPSBuZXcgQXJyYXkobCk7XG4gIGFbMF0gPSAwO1xuICB2YXIgaSA9IDEsaiA9IDE7XG4gIGZvcig7aTxsMTtpKyspIGFbaV09YTFbaV07XG4gIGZvcig7aTxsO2krKyxqKyspIGFbaV09YTJbal07XG4gIHJldHVybiBhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X2NvbmNhdCBtdXRhYmxlXG5mdW5jdGlvbiBjYW1sX2FycmF5X2NvbmNhdChsKSB7XG4gIHZhciBhID0gWzBdO1xuICB3aGlsZSAobCAhPT0gMCkge1xuICAgIHZhciBiID0gbFsxXTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGIubGVuZ3RoOyBpKyspIGEucHVzaChiW2ldKTtcbiAgICBsID0gbFsyXTtcbiAgfVxuICByZXR1cm4gYTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9ibGl0XG5mdW5jdGlvbiBjYW1sX2FycmF5X2JsaXQoYTEsIGkxLCBhMiwgaTIsIGxlbikge1xuICBpZiAoaTIgPD0gaTEpIHtcbiAgICBmb3IgKHZhciBqID0gMTsgaiA8PSBsZW47IGorKykgYTJbaTIgKyBqXSA9IGExW2kxICsgal07XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaiA9IGxlbjsgaiA+PSAxOyBqLS0pIGEyW2kyICsgal0gPSBhMVtpMSArIGpdO1xuICB9O1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9mbG9hdGFycmF5X2JsaXRcbmZ1bmN0aW9uIGNhbWxfZmxvYXRhcnJheV9ibGl0KGExLCBpMSwgYTIsIGkyLCBsZW4pIHtcbiAgaWYgKGkyIDw9IGkxKSB7XG4gICAgZm9yICh2YXIgaiA9IDE7IGogPD0gbGVuOyBqKyspIGEyW2kyICsgal0gPSBhMVtpMSArIGpdO1xuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGogPSBsZW47IGogPj0gMTsgai0tKSBhMltpMiArIGpdID0gYTFbaTEgKyBqXTtcbiAgfTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vLy8vLy8vLy8vLy8gUGVydmFzaXZlXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X3NldCAobXV0YWJsZSwgY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9hcnJheV9zZXQgKGFycmF5LCBpbmRleCwgbmV3dmFsKSB7XG4gIGlmICgoaW5kZXggPCAwKSB8fCAoaW5kZXggPj0gYXJyYXkubGVuZ3RoIC0gMSkpIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgYXJyYXlbaW5kZXgrMV09bmV3dmFsOyByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9nZXQgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9hcnJheV9nZXQgKGFycmF5LCBpbmRleCkge1xuICBpZiAoKGluZGV4IDwgMCkgfHwgKGluZGV4ID49IGFycmF5Lmxlbmd0aCAtIDEpKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHJldHVybiBhcnJheVtpbmRleCsxXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9maWxsXG5mdW5jdGlvbiBjYW1sX2FycmF5X2ZpbGwoYXJyYXksIG9mcywgbGVuLCB2KXtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKXtcbiAgICBhcnJheVtvZnMraSsxXSA9IHY7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY2hlY2tfYm91bmQgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfY2hlY2tfYm91bmQgKGFycmF5LCBpbmRleCkge1xuICBpZiAoaW5kZXggPj4+IDAgPj0gYXJyYXkubGVuZ3RoIC0gMSkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICByZXR1cm4gYXJyYXk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWFrZV92ZWN0IGNvbnN0IChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX21ha2VfdmVjdCAobGVuLCBpbml0KSB7XG4gIGlmIChsZW4gPCAwKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHZhciBsZW4gPSBsZW4gKyAxIHwgMDtcbiAgdmFyIGIgPSBuZXcgQXJyYXkobGVuKTtcbiAgYlswXT0wO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGxlbjsgaSsrKSBiW2ldID0gaW5pdDtcbiAgcmV0dXJuIGI7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWFrZV9mbG9hdF92ZWN0IGNvbnN0IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfbWFrZV9mbG9hdF92ZWN0KGxlbil7XG4gIGlmIChsZW4gPCAwKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHZhciBsZW4gPSBsZW4gKyAxIHwgMDtcbiAgdmFyIGIgPSBuZXcgQXJyYXkobGVuKTtcbiAgYlswXT0yNTQ7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuOyBpKyspIGJbaV0gPSAwO1xuICByZXR1cm4gYlxufVxuLy9Qcm92aWRlczogY2FtbF9mbG9hdGFycmF5X2NyZWF0ZSBjb25zdCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX2Zsb2F0YXJyYXlfY3JlYXRlKGxlbil7XG4gIGlmIChsZW4gPCAwKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHZhciBsZW4gPSBsZW4gKyAxIHwgMDtcbiAgdmFyIGIgPSBuZXcgQXJyYXkobGVuKTtcbiAgYlswXT0yNTQ7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuOyBpKyspIGJbaV0gPSAwO1xuICByZXR1cm4gYlxufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwIErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vIFdlYWsgQVBJLCBidXQgd2l0aG91dCB0aGUgd2VhayBzZW1hbnRpY3NcblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2tleV9vZmZzZXRcbi8vVmVyc2lvbjogPCA0LjAzXG52YXIgY2FtbF9lcGhlX2tleV9vZmZzZXQgPSAyXG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9rZXlfb2Zmc2V0XG4vL1ZlcnNpb246ID49IDQuMDNcbnZhciBjYW1sX2VwaGVfa2V5X29mZnNldCA9IDNcblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XG4vL1ZlcnNpb246ID49IDQuMDNcbnZhciBjYW1sX2VwaGVfZGF0YV9vZmZzZXQgPSAyXG5cbi8vUHJvdmlkZXM6IGNhbWxfd2Vha19jcmVhdGVcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9rZXlfb2Zmc2V0LCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfd2Vha19jcmVhdGUgKG4pIHtcbiAgaWYgKG4gPCAwKSBjYW1sX2ludmFsaWRfYXJndW1lbnQgKFwiV2Vhay5jcmVhdGVcIik7XG4gIHZhciB4ID0gWzI1MSxcImNhbWxfZXBoZV9saXN0X2hlYWRcIl07XG4gIHgubGVuZ3RoID0gY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBuO1xuICByZXR1cm4geDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF93ZWFrX3NldFxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2tleV9vZmZzZXQsIGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF93ZWFrX3NldCh4LCBpLCB2KSB7XG4gIGlmKGkgPCAwIHx8IGNhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaSA+PSB4Lmxlbmd0aClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQgKFwiV2Vhay5zZXRcIik7XG4gIHhbY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpXSA9IHY7XG4gIHJldHVybiAwO1xufVxuLy9Qcm92aWRlczogY2FtbF93ZWFrX2dldFxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2tleV9vZmZzZXQsIGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF93ZWFrX2dldCh4LCBpKSB7XG4gIGlmKGkgPCAwIHx8IGNhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaSA+PSB4Lmxlbmd0aClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQgKFwiV2Vhay5nZXRfa2V5XCIpO1xuICByZXR1cm4gKHhbY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpIF09PT11bmRlZmluZWQpPzA6eFtjYW1sX2VwaGVfa2V5X29mZnNldCArIGldO1xufVxuLy9Qcm92aWRlczogY2FtbF93ZWFrX2dldF9jb3B5XG4vL1JlcXVpcmVzOiBjYW1sX3dlYWtfZ2V0LGNhbWxfZXBoZV9rZXlfb2Zmc2V0XG4vL1JlcXVpcmVzOiBjYW1sX29ial9kdXAsIGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF93ZWFrX2dldF9jb3B5KHgsIGkpIHtcbiAgaWYoaSA8IDAgfHwgY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpID49IHgubGVuZ3RoKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudCAoXCJXZWFrLmdldF9jb3B5XCIpO1xuICB2YXIgeSA9IGNhbWxfd2Vha19nZXQoeCwgaSk7XG4gIGlmICh5ID09PSAwKSByZXR1cm4geTtcbiAgdmFyIHogPSB5WzFdO1xuICBpZiAoeiBpbnN0YW5jZW9mIEFycmF5KSByZXR1cm4gWzAsIGNhbWxfb2JqX2R1cCh6KV07XG4gIHJldHVybiB5O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3dlYWtfY2hlY2sgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2tleV9vZmZzZXRcbmZ1bmN0aW9uIGNhbWxfd2Vha19jaGVjayh4LCBpKSB7XG4gIGlmKHhbY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpXSE9PXVuZGVmaW5lZCAmJiB4W2NhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaV0gIT09MClcbiAgICByZXR1cm4gMTtcbiAgZWxzZVxuICAgIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3dlYWtfYmxpdFxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ibGl0XG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfa2V5X29mZnNldFxuZnVuY3Rpb24gY2FtbF93ZWFrX2JsaXQoYTEsIGkxLCBhMiwgaTIsIGxlbikge1xuICAvLyBtaW51cyBvbmUgYmVjYXVzZSBjYW1sX2FycmF5X2JsaXQgd29ya3Mgb24gb2NhbWwgYXJyYXlcbiAgY2FtbF9hcnJheV9ibGl0KGExLCBjYW1sX2VwaGVfa2V5X29mZnNldCArIGkxIC0gMSxcbiAgICAgICAgICAgICAgICAgIGEyLCBjYW1sX2VwaGVfa2V5X29mZnNldCArIGkyIC0gMSxcbiAgICAgICAgICAgICAgICAgIGxlbik7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfY3JlYXRlXG4vL1JlcXVpcmVzOiBjYW1sX3dlYWtfY3JlYXRlXG52YXIgY2FtbF9lcGhlX2NyZWF0ZSA9IGNhbWxfd2Vha19jcmVhdGVcblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2JsaXRfa2V5XG4vL1JlcXVpcmVzOiBjYW1sX3dlYWtfYmxpdFxudmFyIGNhbWxfZXBoZV9ibGl0X2tleSA9IGNhbWxfd2Vha19ibGl0XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9nZXRfa2V5XG4vL1JlcXVpcmVzOiBjYW1sX3dlYWtfZ2V0XG52YXIgY2FtbF9lcGhlX2dldF9rZXkgPSBjYW1sX3dlYWtfZ2V0XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9nZXRfa2V5X2NvcHlcbi8vUmVxdWlyZXM6IGNhbWxfd2Vha19nZXRfY29weVxudmFyIGNhbWxfZXBoZV9nZXRfa2V5X2NvcHkgPSBjYW1sX3dlYWtfZ2V0X2NvcHlcblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2NoZWNrX2tleVxuLy9SZXF1aXJlczogY2FtbF93ZWFrX2NoZWNrXG52YXIgY2FtbF9lcGhlX2NoZWNrX2tleSA9IGNhbWxfd2Vha19jaGVja1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfc2V0X2tleVxuLy9SZXF1aXJlczogY2FtbF93ZWFrX3NldFxuZnVuY3Rpb24gY2FtbF9lcGhlX3NldF9rZXkoeCwgaSwgdikge1xuICByZXR1cm4gY2FtbF93ZWFrX3NldCh4LCBpLCBbMCwgdl0pXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV91bnNldF9rZXlcbi8vUmVxdWlyZXM6IGNhbWxfd2Vha19zZXRcbmZ1bmN0aW9uIGNhbWxfZXBoZV91bnNldF9rZXkoeCwgaSkge1xuICByZXR1cm4gY2FtbF93ZWFrX3NldCh4LCBpLCAwKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfYmxpdF9kYXRhXG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfZGF0YV9vZmZzZXRcbi8vVmVyc2lvbjogPj0gNC4wM1xuZnVuY3Rpb24gY2FtbF9lcGhlX2JsaXRfZGF0YShzcmMsIGRzdCl7XG4gIGRzdFtjYW1sX2VwaGVfZGF0YV9vZmZzZXRdID0gc3JjW2NhbWxfZXBoZV9kYXRhX29mZnNldF07XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfZ2V0X2RhdGFcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9kYXRhX29mZnNldFxuLy9WZXJzaW9uOiA+PSA0LjAzXG5mdW5jdGlvbiBjYW1sX2VwaGVfZ2V0X2RhdGEoeCl7XG4gIGlmKHhbY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XSA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiAwO1xuICBlbHNlXG4gICAgcmV0dXJuIFswLCB4W2NhbWxfZXBoZV9kYXRhX29mZnNldF1dO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfZ2V0X2RhdGFfY29weVxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XG4vL1JlcXVpcmVzOiBjYW1sX29ial9kdXBcbi8vVmVyc2lvbjogPj0gNC4wM1xuZnVuY3Rpb24gY2FtbF9lcGhlX2dldF9kYXRhX2NvcHkoeCl7XG4gIGlmKHhbY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XSA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiAwO1xuICBlbHNlXG4gICAgcmV0dXJuIFswLCBjYW1sX29ial9kdXAoeFtjYW1sX2VwaGVfZGF0YV9vZmZzZXRdKV07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9zZXRfZGF0YVxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XG4vL1ZlcnNpb246ID49IDQuMDNcbmZ1bmN0aW9uIGNhbWxfZXBoZV9zZXRfZGF0YSh4LCBkYXRhKXtcbiAgeFtjYW1sX2VwaGVfZGF0YV9vZmZzZXRdID0gZGF0YTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV91bnNldF9kYXRhXG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfZGF0YV9vZmZzZXRcbi8vVmVyc2lvbjogPj0gNC4wM1xuZnVuY3Rpb24gY2FtbF9lcGhlX3Vuc2V0X2RhdGEoeCwgZGF0YSl7XG4gIHhbY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XSA9IHVuZGVmaW5lZDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9jaGVja19kYXRhXG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfZGF0YV9vZmZzZXRcbi8vVmVyc2lvbjogPj0gNC4wM1xuZnVuY3Rpb24gY2FtbF9lcGhlX2NoZWNrX2RhdGEoeCl7XG4gIGlmKHhbY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XSA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiAwO1xuICBlbHNlXG4gICAgcmV0dXJuIDE7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX21kNV9jaGFuXG4vL1JlcXVpcmVzOiBjYW1sX21kNV9zdHJpbmcsIGNhbWxfc3RyaW5nX29mX2FycmF5LGNhbWxfbWxfY2hhbm5lbHNcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2VfZW5kX29mX2ZpbGUsIGNhbWxfY3JlYXRlX2J5dGVzLCBjYW1sX3N0cmluZ19vZl9ieXRlc1xuZnVuY3Rpb24gY2FtbF9tZDVfY2hhbihjaGFuaWQsbGVuKXtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIHZhciBjaGFuX2xlbiA9IGNoYW4uZmlsZS5sZW5ndGgoKTtcbiAgaWYobGVuPDApIGxlbiA9IGNoYW5fbGVuIC0gY2hhbi5vZmZzZXQ7XG4gIGlmKGNoYW4ub2Zmc2V0ICsgbGVuID4gY2hhbl9sZW4pIGNhbWxfcmFpc2VfZW5kX29mX2ZpbGUoKTtcbiAgdmFyIGJ1ZiA9IGNhbWxfY3JlYXRlX2J5dGVzKGxlbik7XG4gIGNoYW4uZmlsZS5yZWFkKGNoYW4ub2Zmc2V0LGJ1ZiwwLGxlbik7XG4gIHJldHVybiBjYW1sX21kNV9zdHJpbmcoY2FtbF9zdHJpbmdfb2ZfYnl0ZXMoYnVmKSwwLGxlbik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWQ1X3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9ieXRlc19vZl9zdHJpbmcsIGNhbWxfbWQ1X2J5dGVzXG5mdW5jdGlvbiBjYW1sX21kNV9zdHJpbmcocywgb2ZzLCBsZW4pIHtcbiAgcmV0dXJuIGNhbWxfbWQ1X2J5dGVzKGNhbWxfYnl0ZXNfb2Zfc3RyaW5nKHMpLG9mcyxsZW4pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21kNV9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfYXJyYXksIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXNcbnZhciBjYW1sX21kNV9ieXRlcyA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gYWRkICh4LCB5KSB7IHJldHVybiAoeCArIHkpIHwgMDsgfVxuICBmdW5jdGlvbiB4eChxLGEsYix4LHMsdCkge1xuICAgIGEgPSBhZGQoYWRkKGEsIHEpLCBhZGQoeCwgdCkpO1xuICAgIHJldHVybiBhZGQoKGEgPDwgcykgfCAoYSA+Pj4gKDMyIC0gcykpLCBiKTtcbiAgfVxuICBmdW5jdGlvbiBmZihhLGIsYyxkLHgscyx0KSB7XG4gICAgcmV0dXJuIHh4KChiICYgYykgfCAoKH5iKSAmIGQpLCBhLCBiLCB4LCBzLCB0KTtcbiAgfVxuICBmdW5jdGlvbiBnZyhhLGIsYyxkLHgscyx0KSB7XG4gICAgcmV0dXJuIHh4KChiICYgZCkgfCAoYyAmICh+ZCkpLCBhLCBiLCB4LCBzLCB0KTtcbiAgfVxuICBmdW5jdGlvbiBoaChhLGIsYyxkLHgscyx0KSB7IHJldHVybiB4eChiIF4gYyBeIGQsIGEsIGIsIHgsIHMsIHQpOyB9XG4gIGZ1bmN0aW9uIGlpKGEsYixjLGQseCxzLHQpIHsgcmV0dXJuIHh4KGMgXiAoYiB8ICh+ZCkpLCBhLCBiLCB4LCBzLCB0KTsgfVxuXG4gIGZ1bmN0aW9uIG1kNShidWZmZXIsIGxlbmd0aCkge1xuICAgIHZhciBpID0gbGVuZ3RoO1xuICAgIGJ1ZmZlcltpID4+IDJdIHw9IDB4ODAgPDwgKDggKiAoaSAmIDMpKTtcbiAgICBmb3IgKGkgPSAoaSAmIH4weDMpICsgODsoaSAmIDB4M0YpIDwgNjAgO2kgKz0gNClcbiAgICAgIGJ1ZmZlclsoaSA+PiAyKSAtIDFdID0gMDtcbiAgICBidWZmZXJbKGkgPj4gMikgLTFdID0gbGVuZ3RoIDw8IDM7XG4gICAgYnVmZmVyW2kgPj4gMl0gPSAobGVuZ3RoID4+IDI5KSAmIDB4MUZGRkZGRkY7XG5cbiAgICB2YXIgdyA9IFsweDY3NDUyMzAxLCAweEVGQ0RBQjg5LCAweDk4QkFEQ0ZFLCAweDEwMzI1NDc2XTtcblxuICAgIGZvcihpID0gMDsgaSA8IGJ1ZmZlci5sZW5ndGg7IGkgKz0gMTYpIHtcbiAgICAgIHZhciBhID0gd1swXSwgYiA9IHdbMV0sIGMgPSB3WzJdLCBkID0gd1szXTtcblxuICAgICAgYSA9IGZmKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKyAwXSwgNywgMHhENzZBQTQ3OCk7XG4gICAgICBkID0gZmYoZCwgYSwgYiwgYywgYnVmZmVyW2krIDFdLCAxMiwgMHhFOEM3Qjc1Nik7XG4gICAgICBjID0gZmYoYywgZCwgYSwgYiwgYnVmZmVyW2krIDJdLCAxNywgMHgyNDIwNzBEQik7XG4gICAgICBiID0gZmYoYiwgYywgZCwgYSwgYnVmZmVyW2krIDNdLCAyMiwgMHhDMUJEQ0VFRSk7XG4gICAgICBhID0gZmYoYSwgYiwgYywgZCwgYnVmZmVyW2krIDRdLCA3LCAweEY1N0MwRkFGKTtcbiAgICAgIGQgPSBmZihkLCBhLCBiLCBjLCBidWZmZXJbaSsgNV0sIDEyLCAweDQ3ODdDNjJBKTtcbiAgICAgIGMgPSBmZihjLCBkLCBhLCBiLCBidWZmZXJbaSsgNl0sIDE3LCAweEE4MzA0NjEzKTtcbiAgICAgIGIgPSBmZihiLCBjLCBkLCBhLCBidWZmZXJbaSsgN10sIDIyLCAweEZENDY5NTAxKTtcbiAgICAgIGEgPSBmZihhLCBiLCBjLCBkLCBidWZmZXJbaSsgOF0sIDcsIDB4Njk4MDk4RDgpO1xuICAgICAgZCA9IGZmKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKyA5XSwgMTIsIDB4OEI0NEY3QUYpO1xuICAgICAgYyA9IGZmKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKzEwXSwgMTcsIDB4RkZGRjVCQjEpO1xuICAgICAgYiA9IGZmKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKzExXSwgMjIsIDB4ODk1Q0Q3QkUpO1xuICAgICAgYSA9IGZmKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKzEyXSwgNywgMHg2QjkwMTEyMik7XG4gICAgICBkID0gZmYoZCwgYSwgYiwgYywgYnVmZmVyW2krMTNdLCAxMiwgMHhGRDk4NzE5Myk7XG4gICAgICBjID0gZmYoYywgZCwgYSwgYiwgYnVmZmVyW2krMTRdLCAxNywgMHhBNjc5NDM4RSk7XG4gICAgICBiID0gZmYoYiwgYywgZCwgYSwgYnVmZmVyW2krMTVdLCAyMiwgMHg0OUI0MDgyMSk7XG5cbiAgICAgIGEgPSBnZyhhLCBiLCBjLCBkLCBidWZmZXJbaSsgMV0sIDUsIDB4RjYxRTI1NjIpO1xuICAgICAgZCA9IGdnKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKyA2XSwgOSwgMHhDMDQwQjM0MCk7XG4gICAgICBjID0gZ2coYywgZCwgYSwgYiwgYnVmZmVyW2krMTFdLCAxNCwgMHgyNjVFNUE1MSk7XG4gICAgICBiID0gZ2coYiwgYywgZCwgYSwgYnVmZmVyW2krIDBdLCAyMCwgMHhFOUI2QzdBQSk7XG4gICAgICBhID0gZ2coYSwgYiwgYywgZCwgYnVmZmVyW2krIDVdLCA1LCAweEQ2MkYxMDVEKTtcbiAgICAgIGQgPSBnZyhkLCBhLCBiLCBjLCBidWZmZXJbaSsxMF0sIDksIDB4MDI0NDE0NTMpO1xuICAgICAgYyA9IGdnKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKzE1XSwgMTQsIDB4RDhBMUU2ODEpO1xuICAgICAgYiA9IGdnKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKyA0XSwgMjAsIDB4RTdEM0ZCQzgpO1xuICAgICAgYSA9IGdnKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKyA5XSwgNSwgMHgyMUUxQ0RFNik7XG4gICAgICBkID0gZ2coZCwgYSwgYiwgYywgYnVmZmVyW2krMTRdLCA5LCAweEMzMzcwN0Q2KTtcbiAgICAgIGMgPSBnZyhjLCBkLCBhLCBiLCBidWZmZXJbaSsgM10sIDE0LCAweEY0RDUwRDg3KTtcbiAgICAgIGIgPSBnZyhiLCBjLCBkLCBhLCBidWZmZXJbaSsgOF0sIDIwLCAweDQ1NUExNEVEKTtcbiAgICAgIGEgPSBnZyhhLCBiLCBjLCBkLCBidWZmZXJbaSsxM10sIDUsIDB4QTlFM0U5MDUpO1xuICAgICAgZCA9IGdnKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKyAyXSwgOSwgMHhGQ0VGQTNGOCk7XG4gICAgICBjID0gZ2coYywgZCwgYSwgYiwgYnVmZmVyW2krIDddLCAxNCwgMHg2NzZGMDJEOSk7XG4gICAgICBiID0gZ2coYiwgYywgZCwgYSwgYnVmZmVyW2krMTJdLCAyMCwgMHg4RDJBNEM4QSk7XG5cbiAgICAgIGEgPSBoaChhLCBiLCBjLCBkLCBidWZmZXJbaSsgNV0sIDQsIDB4RkZGQTM5NDIpO1xuICAgICAgZCA9IGhoKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKyA4XSwgMTEsIDB4ODc3MUY2ODEpO1xuICAgICAgYyA9IGhoKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKzExXSwgMTYsIDB4NkQ5RDYxMjIpO1xuICAgICAgYiA9IGhoKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKzE0XSwgMjMsIDB4RkRFNTM4MEMpO1xuICAgICAgYSA9IGhoKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKyAxXSwgNCwgMHhBNEJFRUE0NCk7XG4gICAgICBkID0gaGgoZCwgYSwgYiwgYywgYnVmZmVyW2krIDRdLCAxMSwgMHg0QkRFQ0ZBOSk7XG4gICAgICBjID0gaGgoYywgZCwgYSwgYiwgYnVmZmVyW2krIDddLCAxNiwgMHhGNkJCNEI2MCk7XG4gICAgICBiID0gaGgoYiwgYywgZCwgYSwgYnVmZmVyW2krMTBdLCAyMywgMHhCRUJGQkM3MCk7XG4gICAgICBhID0gaGgoYSwgYiwgYywgZCwgYnVmZmVyW2krMTNdLCA0LCAweDI4OUI3RUM2KTtcbiAgICAgIGQgPSBoaChkLCBhLCBiLCBjLCBidWZmZXJbaSsgMF0sIDExLCAweEVBQTEyN0ZBKTtcbiAgICAgIGMgPSBoaChjLCBkLCBhLCBiLCBidWZmZXJbaSsgM10sIDE2LCAweEQ0RUYzMDg1KTtcbiAgICAgIGIgPSBoaChiLCBjLCBkLCBhLCBidWZmZXJbaSsgNl0sIDIzLCAweDA0ODgxRDA1KTtcbiAgICAgIGEgPSBoaChhLCBiLCBjLCBkLCBidWZmZXJbaSsgOV0sIDQsIDB4RDlENEQwMzkpO1xuICAgICAgZCA9IGhoKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKzEyXSwgMTEsIDB4RTZEQjk5RTUpO1xuICAgICAgYyA9IGhoKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKzE1XSwgMTYsIDB4MUZBMjdDRjgpO1xuICAgICAgYiA9IGhoKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKyAyXSwgMjMsIDB4QzRBQzU2NjUpO1xuXG4gICAgICBhID0gaWkoYSwgYiwgYywgZCwgYnVmZmVyW2krIDBdLCA2LCAweEY0MjkyMjQ0KTtcbiAgICAgIGQgPSBpaShkLCBhLCBiLCBjLCBidWZmZXJbaSsgN10sIDEwLCAweDQzMkFGRjk3KTtcbiAgICAgIGMgPSBpaShjLCBkLCBhLCBiLCBidWZmZXJbaSsxNF0sIDE1LCAweEFCOTQyM0E3KTtcbiAgICAgIGIgPSBpaShiLCBjLCBkLCBhLCBidWZmZXJbaSsgNV0sIDIxLCAweEZDOTNBMDM5KTtcbiAgICAgIGEgPSBpaShhLCBiLCBjLCBkLCBidWZmZXJbaSsxMl0sIDYsIDB4NjU1QjU5QzMpO1xuICAgICAgZCA9IGlpKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKyAzXSwgMTAsIDB4OEYwQ0NDOTIpO1xuICAgICAgYyA9IGlpKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKzEwXSwgMTUsIDB4RkZFRkY0N0QpO1xuICAgICAgYiA9IGlpKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKyAxXSwgMjEsIDB4ODU4NDVERDEpO1xuICAgICAgYSA9IGlpKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKyA4XSwgNiwgMHg2RkE4N0U0Rik7XG4gICAgICBkID0gaWkoZCwgYSwgYiwgYywgYnVmZmVyW2krMTVdLCAxMCwgMHhGRTJDRTZFMCk7XG4gICAgICBjID0gaWkoYywgZCwgYSwgYiwgYnVmZmVyW2krIDZdLCAxNSwgMHhBMzAxNDMxNCk7XG4gICAgICBiID0gaWkoYiwgYywgZCwgYSwgYnVmZmVyW2krMTNdLCAyMSwgMHg0RTA4MTFBMSk7XG4gICAgICBhID0gaWkoYSwgYiwgYywgZCwgYnVmZmVyW2krIDRdLCA2LCAweEY3NTM3RTgyKTtcbiAgICAgIGQgPSBpaShkLCBhLCBiLCBjLCBidWZmZXJbaSsxMV0sIDEwLCAweEJEM0FGMjM1KTtcbiAgICAgIGMgPSBpaShjLCBkLCBhLCBiLCBidWZmZXJbaSsgMl0sIDE1LCAweDJBRDdEMkJCKTtcbiAgICAgIGIgPSBpaShiLCBjLCBkLCBhLCBidWZmZXJbaSsgOV0sIDIxLCAweEVCODZEMzkxKTtcblxuICAgICAgd1swXSA9IGFkZChhLCB3WzBdKTtcbiAgICAgIHdbMV0gPSBhZGQoYiwgd1sxXSk7XG4gICAgICB3WzJdID0gYWRkKGMsIHdbMl0pO1xuICAgICAgd1szXSA9IGFkZChkLCB3WzNdKTtcbiAgICB9XG5cbiAgICB2YXIgdCA9IG5ldyBBcnJheSgxNik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDQ7IGorKylcbiAgICAgICAgdFtpICogNCArIGpdID0gKHdbaV0gPj4gKDggKiBqKSkgJiAweEZGO1xuICAgIHJldHVybiB0O1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChzLCBvZnMsIGxlbikge1xuICAgIC8vIEZJWDogbWF5YmUgd2Ugc2hvdWxkIHBlcmZvcm0gdGhlIGNvbXB1dGF0aW9uIGJ5IGNodW5rIG9mIDY0IGJ5dGVzXG4gICAgLy8gYXMgaW4gaHR0cDovL3d3dy5teWVyc2RhaWx5Lm9yZy9qb3NlcGgvamF2YXNjcmlwdC9tZDUuanNcbiAgICB2YXIgYnVmID0gW107XG4gICAgc3dpdGNoIChzLnQgJiA2KSB7XG4gICAgZGVmYXVsdDpcbiAgICAgIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMocyk7XG4gICAgY2FzZSAwOiAvKiBCWVRFUyAqL1xuICAgICAgdmFyIGIgPSBzLmM7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSs9NCkge1xuICAgICAgICB2YXIgaiA9IGkgKyBvZnM7XG4gICAgICAgIGJ1ZltpPj4yXSA9XG4gICAgICAgICAgYi5jaGFyQ29kZUF0KGopIHwgKGIuY2hhckNvZGVBdChqKzEpIDw8IDgpIHxcbiAgICAgICAgICAoYi5jaGFyQ29kZUF0KGorMikgPDwgMTYpIHwgKGIuY2hhckNvZGVBdChqKzMpIDw8IDI0KTtcbiAgICAgIH1cbiAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIGJ1ZltpPj4yXSB8PSBiLmNoYXJDb2RlQXQoaSArIG9mcykgPDwgKDggKiAoaSAmIDMpKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgNDogLyogQVJSQVkgKi9cbiAgICAgIHZhciBhID0gcy5jO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrPTQpIHtcbiAgICAgICAgdmFyIGogPSBpICsgb2ZzO1xuICAgICAgICBidWZbaT4+Ml0gPSBhW2pdIHwgKGFbaisxXSA8PCA4KSB8IChhW2orMl0gPDwgMTYpIHwgKGFbaiszXSA8PCAyNCk7XG4gICAgICB9XG4gICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSBidWZbaT4+Ml0gfD0gYVtpICsgb2ZzXSA8PCAoOCAqIChpICYgMykpO1xuICAgIH1cbiAgICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfYXJyYXkobWQ1KGJ1ZiwgbGVuKSk7XG4gIH1cbn0gKCk7XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMjAgLSBIdWdvIEhldXphcmRcbi8vIENvcHlyaWdodCAoQykgMjAyMCAtIFNoYWNoYXIgSXR6aGFreVxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8gQmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL29jYW1sL29jYW1sL2Jsb2IvNC4wNy9vdGhlcmxpYnMvc3RyL3N0cnN0dWJzLmNcbi8vIENvcGllZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9qc2NvcS9qc2NvcS9ibG9iL3Y4LjExL2NvcS1qcy9qc19zdHViL3N0ci5qc1xuXG4vL1Byb3ZpZGVzOiByZV9tYXRjaFxuLy9SZXF1aXJlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZywgY2FtbF9qc19mcm9tX2FycmF5LCBjYW1sX2FycmF5X29mX3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfZ2V0XG5cbnZhciByZV9tYXRjaCA9IGZ1bmN0aW9uKCl7XG4gIHZhciByZV93b3JkX2xldHRlcnMgPSBbXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgICAgICAgLyogMHgwMC0weDFGOiBub25lICovXG4gICAgMHgwMCwgMHgwMCwgMHhGRiwgMHgwMywgICAgICAgLyogMHgyMC0weDNGOiBkaWdpdHMgMC05ICovXG4gICAgMHhGRSwgMHhGRiwgMHhGRiwgMHg4NywgICAgICAgLyogMHg0MC0weDVGOiBBIHRvIFosIF8gKi9cbiAgICAweEZFLCAweEZGLCAweEZGLCAweDA3LCAgICAgICAvKiAweDYwLTB4N0Y6IGEgdG8geiAqL1xuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsICAgICAgIC8qIDB4ODAtMHg5Rjogbm9uZSAqL1xuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsICAgICAgIC8qIDB4QTAtMHhCRjogbm9uZSAqL1xuICAgIDB4RkYsIDB4RkYsIDB4N0YsIDB4RkYsICAgICAgIC8qIDB4QzAtMHhERjogTGF0aW4tMSBhY2NlbnRlZCB1cHBlcmNhc2UgKi9cbiAgICAweEZGLCAweEZGLCAweDdGLCAweEZGICAgICAgICAvKiAweEUwLTB4RkY6IExhdGluLTEgYWNjZW50ZWQgbG93ZXJjYXNlICovXG4gIF07XG5cbiAgdmFyIG9wY29kZXMgPSB7XG4gICAgQ0hBUjogMCwgQ0hBUk5PUk06IDEsIFNUUklORzogMiwgU1RSSU5HTk9STTogMywgQ0hBUkNMQVNTOiA0LFxuICAgIEJPTDogNSwgRU9MOiA2LCBXT1JEQk9VTkRBUlk6IDcsXG4gICAgQkVHR1JPVVA6IDgsIEVOREdST1VQOiA5LCBSRUZHUk9VUDogMTAsXG4gICAgQUNDRVBUOiAxMSxcbiAgICBTSU1QTEVPUFQ6IDEyLCBTSU1QTEVTVEFSOiAxMywgU0lNUExFUExVUzogMTQsXG4gICAgR09UTzogMTUsIFBVU0hCQUNLOiAxNiwgU0VUTUFSSzogMTcsXG4gICAgQ0hFQ0tQUk9HUkVTUzogMThcbiAgfTtcblxuICBmdW5jdGlvbiBpc193b3JkX2xldHRlcihjKSB7XG4gICAgcmV0dXJuIChyZV93b3JkX2xldHRlcnNbICAoYyA+PiAzKV0gPj4gKGMgJiA3KSkgJiAxO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5fYml0c2V0KHMsaSkge1xuICAgIHJldHVybiAoY2FtbF9zdHJpbmdfZ2V0KHMsKGkgPj4gMykpID4+IChpICYgNykpICYgMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlX21hdGNoX2ltcGwocmUsIHMsIHBvcywgcGFydGlhbCkge1xuXG4gICAgdmFyIHByb2cgICAgICAgICAgPSBjYW1sX2pzX2Zyb21fYXJyYXkocmVbMV0pLFxuICAgICAgICBjcG9vbCAgICAgICAgID0gY2FtbF9qc19mcm9tX2FycmF5KHJlWzJdKSxcbiAgICAgICAgbm9ybXRhYmxlICAgICA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcocmVbM10pLFxuICAgICAgICBudW1ncm91cHMgICAgID0gcmVbNF0gfCAwLFxuICAgICAgICBudW1yZWdpc3RlcnMgID0gcmVbNV0gfCAwLFxuICAgICAgICBzdGFydGNoYXJzICAgID0gcmVbNl0gfCAwO1xuXG4gICAgdmFyIHMgPSBjYW1sX2FycmF5X29mX3N0cmluZyhzKTtcblxuICAgIHZhciBwYyA9IDAsXG4gICAgICAgIHF1aXQgPSBmYWxzZSxcbiAgICAgICAgc3RhY2sgPSBbXSxcbiAgICAgICAgZ3JvdXBzID0gbmV3IEFycmF5KG51bWdyb3VwcyksXG4gICAgICAgIHJlX3JlZ2lzdGVyID0gbmV3IEFycmF5KG51bXJlZ2lzdGVycyk7XG5cbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aDsgaSsrKXtcbiAgICAgIGdyb3Vwc1tpXSA9IHtzdGFydDogLTEsIGVuZDotMX1cbiAgICB9XG4gICAgZ3JvdXBzWzBdLnN0YXJ0ID0gcG9zO1xuXG4gICAgdmFyIGJhY2t0cmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHdoaWxlIChzdGFjay5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBzdGFjay5wb3AoKTtcbiAgICAgICAgaWYgKGl0ZW0udW5kbykge1xuICAgICAgICAgIGl0ZW0udW5kby5vYmpbaXRlbS51bmRvLnByb3BdID0gaXRlbS51bmRvLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYoaXRlbS5wb3MpIHtcbiAgICAgICAgICBwYyA9IGl0ZW0ucG9zLnBjO1xuICAgICAgICAgIHBvcyA9IGl0ZW0ucG9zLnR4dDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHF1aXQgPSB0cnVlO1xuICAgIH07XG5cbiAgICB2YXIgcHVzaCA9IGZ1bmN0aW9uKGl0ZW0pIHsgc3RhY2sucHVzaChpdGVtKTsgfTtcblxuICAgIHZhciBhY2NlcHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBncm91cHNbMF0uZW5kID0gcG9zO1xuICAgICAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheSgxICsgZ3JvdXBzLmxlbmd0aCoyKTtcbiAgICAgIHJlc3VsdFswXSA9IDA7IC8vIHRhZ1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGdyb3Vwcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBnID0gZ3JvdXBzW2ldO1xuICAgICAgICBpZihnLnN0YXJ0IDwgMCB8fCBnLmVuZCA8IDApIHtcbiAgICAgICAgICBnLnN0YXJ0ID0gZy5lbmQgPSAtMTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRbMippICsgMSBdID0gZy5zdGFydDtcbiAgICAgICAgcmVzdWx0WzIqaSArIDEgKyAxIF0gPSBnLmVuZDtcbiAgICAgIH07XG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfTtcblxuICAgIHZhciBwcmVmaXhfbWF0Y2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZihwYXJ0aWFsKSByZXR1cm4gYWNjZXB0ICgpO1xuICAgICAgZWxzZSBiYWNrdHJhY2sgKCk7XG4gICAgfVxuXG4gICAgLyogTWFpbiBERkEgaW50ZXJwcmV0ZXIgbG9vcCAqL1xuICAgIHdoaWxlICghcXVpdCkge1xuICAgICAgdmFyIG9wID0gcHJvZ1twY10gJiAweGZmLFxuICAgICAgICAgIHNhcmcgPSBwcm9nW3BjXSA+PiA4LFxuICAgICAgICAgIHVhcmcgPSBzYXJnICYgMHhmZixcbiAgICAgICAgICBjID0gc1twb3NdLFxuICAgICAgICAgIGdyb3VwO1xuXG4gICAgICBwYysrO1xuXG4gICAgICBzd2l0Y2ggKG9wKSB7XG4gICAgICBjYXNlIG9wY29kZXMuQ0hBUjpcbiAgICAgICAgaWYocG9zID09PSBzLmxlbmd0aCkge3ByZWZpeF9tYXRjaCAoKTsgYnJlYWt9O1xuICAgICAgICBpZiAoYyA9PT0gdWFyZykgcG9zKys7XG4gICAgICAgIGVsc2UgYmFja3RyYWNrKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLkNIQVJOT1JNOlxuICAgICAgICBpZihwb3MgPT09IHMubGVuZ3RoKSB7cHJlZml4X21hdGNoICgpOyBicmVha307XG4gICAgICAgIGlmIChub3JtdGFibGUuY2hhckNvZGVBdChjKSA9PT0gdWFyZykgcG9zKys7XG4gICAgICAgIGVsc2UgYmFja3RyYWNrKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLlNUUklORzpcbiAgICAgICAgZm9yICh2YXIgYXJnID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhjcG9vbFt1YXJnXSksIGkgPSAwOyBpIDwgYXJnLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYocG9zID09PSBzLmxlbmd0aCkge3ByZWZpeF9tYXRjaCAoKTsgYnJlYWt9O1xuICAgICAgICAgIGlmIChjID09PSBhcmcuY2hhckNvZGVBdChpKSlcbiAgICAgICAgICAgIGMgPSBzWysrcG9zXTtcbiAgICAgICAgICBlbHNlIHsgYmFja3RyYWNrKCk7IGJyZWFrOyB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuU1RSSU5HTk9STTpcbiAgICAgICAgZm9yICh2YXIgYXJnID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhjcG9vbFt1YXJnXSksIGkgPSAwOyBpIDwgYXJnLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYocG9zID09PSBzLmxlbmd0aCkge3ByZWZpeF9tYXRjaCAoKTsgYnJlYWt9O1xuICAgICAgICAgIGlmIChub3JtdGFibGUuY2hhckNvZGVBdChjKSA9PT0gYXJnLmNoYXJDb2RlQXQoaSkpXG4gICAgICAgICAgICBjID0gc1srK3Bvc107XG4gICAgICAgICAgZWxzZSB7IGJhY2t0cmFjaygpOyBicmVhazsgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLkNIQVJDTEFTUzpcbiAgICAgIGlmKHBvcyA9PT0gcy5sZW5ndGgpIHtwcmVmaXhfbWF0Y2ggKCk7IGJyZWFrfTtcbiAgICAgICAgaWYgKGluX2JpdHNldChjcG9vbFt1YXJnXSwgYykpIHBvcysrO1xuICAgICAgICBlbHNlIGJhY2t0cmFjaygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5CT0w6XG4gICAgICAgIGlmKHBvcyA+IDAgJiYgc1twb3MgLSAxXSAhPSAxMCAvKiBcXG4gKi8pIHtiYWNrdHJhY2soKX1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuRU9MOlxuICAgICAgICBpZihwb3MgPCBzLmxlbmd0aCAmJiBzW3Bvc10gIT0gMTAgLyogXFxuICovKSB7YmFja3RyYWNrKCl9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLldPUkRCT1VOREFSWTpcbiAgICAgICAgaWYocG9zID09IDApIHtcbiAgICAgICAgICBpZihwb3MgPT09IHMubGVuZ3RoKSB7cHJlZml4X21hdGNoICgpOyBicmVha307XG4gICAgICAgICAgaWYoaXNfd29yZF9sZXR0ZXIoc1swXSkpIGJyZWFrO1xuICAgICAgICAgIGJhY2t0cmFjaygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBvcyA9PT0gcy5sZW5ndGgpIHtcbiAgICAgICAgICBpZihpc193b3JkX2xldHRlcihzW3BvcyAtIDFdKSkgYnJlYWs7XG4gICAgICAgICAgYmFja3RyYWNrICgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmKGlzX3dvcmRfbGV0dGVyKHNbcG9zIC0gMV0pICE9IGlzX3dvcmRfbGV0dGVyKHNbcG9zXSkpIGJyZWFrO1xuICAgICAgICAgIGJhY2t0cmFjayAoKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5CRUdHUk9VUDpcbiAgICAgICAgZ3JvdXAgPSBncm91cHNbdWFyZ107XG4gICAgICAgIHB1c2goe3VuZG86IHtvYmo6Z3JvdXAsXG4gICAgICAgICAgICAgICAgICAgICBwcm9wOidzdGFydCcsXG4gICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZ3JvdXAuc3RhcnR9fSk7XG4gICAgICAgIGdyb3VwLnN0YXJ0ID0gcG9zO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5FTkRHUk9VUDpcbiAgICAgICAgZ3JvdXAgPSBncm91cHNbdWFyZ107XG4gICAgICAgIHB1c2goe3VuZG86IHtvYmo6IGdyb3VwLFxuICAgICAgICAgICAgICAgICAgICAgcHJvcDonZW5kJyxcbiAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBncm91cC5lbmR9fSk7XG4gICAgICAgIGdyb3VwLmVuZCA9IHBvcztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuUkVGR1JPVVA6XG4gICAgICAgIGdyb3VwID0gZ3JvdXBzW3VhcmddO1xuICAgICAgICBpZihncm91cC5zdGFydCA8IDAgfHwgZ3JvdXAuZW5kIDwgMCkge2JhY2t0cmFjayAoKTsgYnJlYWt9XG4gICAgICAgIGZvciAodmFyIGkgPSBncm91cC5zdGFydDsgaSA8IGdyb3VwLmVuZDsgaSsrKXtcbiAgICAgICAgICBpZihwb3MgPT09IHMubGVuZ3RoKSB7cHJlZml4X21hdGNoICgpOyBicmVha307XG4gICAgICAgICAgaWYoc1tpXSAhPSBzW3Bvc10pIHtiYWNrdHJhY2sgKCk7IGJyZWFrfVxuICAgICAgICAgIHBvcysrO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLlNJTVBMRU9QVDpcbiAgICAgICAgaWYgKGluX2JpdHNldChjcG9vbFt1YXJnXSwgYykpIHBvcysrO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5TSU1QTEVTVEFSOlxuICAgICAgICB3aGlsZSAoaW5fYml0c2V0KGNwb29sW3VhcmddLCBjKSlcbiAgICAgICAgICBjID0gc1srK3Bvc107XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLlNJTVBMRVBMVVM6XG4gICAgICAgIGlmKHBvcyA9PT0gcy5sZW5ndGgpIHtwcmVmaXhfbWF0Y2ggKCk7IGJyZWFrfTtcbiAgICAgICAgaWYgKGluX2JpdHNldChjcG9vbFt1YXJnXSwgYykpIHtcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBjID0gc1srK3Bvc107XG4gICAgICAgICAgfSB3aGlsZSAoaW5fYml0c2V0KGNwb29sW3VhcmddLCBjKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBiYWNrdHJhY2soKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuQUNDRVBUOlxuICAgICAgICByZXR1cm4gYWNjZXB0KCk7XG4gICAgICBjYXNlIG9wY29kZXMuR09UTzpcbiAgICAgICAgcGMgPSBwYyArIHNhcmc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLlBVU0hCQUNLOlxuICAgICAgICBwdXNoKHtwb3M6IHtwYzogcGMgKyBzYXJnLCB0eHQ6IHBvc319KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuU0VUTUFSSzpcbiAgICAgICAgcHVzaCh7dW5kbzoge29iajpyZV9yZWdpc3RlcixcbiAgICAgICAgICAgICAgICAgICAgIHByb3A6IHVhcmcsXG4gICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcmVfcmVnaXN0ZXJbdWFyZ119fSk7XG4gICAgICAgIHJlX3JlZ2lzdGVyW3VhcmddID0gcG9zO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5DSEVDS1BST0dSRVNTOlxuICAgICAgICBpZiAocmVfcmVnaXN0ZXJbdWFyZ10gPT09IHBvcykgYmFja3RyYWNrKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBieXRlY29kZVwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICByZXR1cm4gcmVfbWF0Y2hfaW1wbDtcbn0oKTtcblxuXG4vL1Byb3ZpZGVzOiByZV9zZWFyY2hfZm9yd2FyZFxuLy9SZXF1aXJlczogcmVfbWF0Y2gsIGNhbWxfbWxfc3RyaW5nX2xlbmd0aCwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiByZV9zZWFyY2hfZm9yd2FyZChyZSwgcywgcG9zKSB7XG4gIGlmKHBvcyA8IDAgfHwgcG9zID4gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIlN0ci5zZWFyY2hfZm9yd2FyZFwiKVxuICB3aGlsZSAocG9zIDw9IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSkge1xuICAgIHZhciByZXMgPSByZV9tYXRjaChyZSwgcywgcG9zLCAwKTtcbiAgICBpZiAocmVzKSByZXR1cm4gcmVzO1xuICAgIHBvcysrO1xuICB9XG5cbiAgcmV0dXJuIFswXTsgIC8qIFt8fF0gOiBpbnQgYXJyYXkgKi9cbn1cblxuLy9Qcm92aWRlczogcmVfc2VhcmNoX2JhY2t3YXJkXG4vL1JlcXVpcmVzOiByZV9tYXRjaCwgY2FtbF9tbF9zdHJpbmdfbGVuZ3RoLCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIHJlX3NlYXJjaF9iYWNrd2FyZChyZSwgcywgcG9zKSB7XG4gIGlmKHBvcyA8IDAgfHwgcG9zID4gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIlN0ci5zZWFyY2hfYmFja3dhcmRcIilcbiAgd2hpbGUgKHBvcyA+PSAwKSB7XG4gICAgdmFyIHJlcyA9IHJlX21hdGNoKHJlLCBzLCBwb3MsIDApO1xuICAgIGlmIChyZXMpIHJldHVybiByZXM7XG4gICAgcG9zLS07XG4gIH1cblxuICByZXR1cm4gWzBdOyAgLyogW3x8XSA6IGludCBhcnJheSAqL1xufVxuXG5cbi8vUHJvdmlkZXM6IHJlX3N0cmluZ19tYXRjaFxuLy9SZXF1aXJlczogcmVfbWF0Y2gsIGNhbWxfbWxfc3RyaW5nX2xlbmd0aCwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiByZV9zdHJpbmdfbWF0Y2gocmUscyxwb3Mpe1xuICBpZihwb3MgPCAwIHx8IHBvcyA+IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSlcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJTdHIuc3RyaW5nX21hdGNoXCIpXG4gIHZhciByZXMgPSByZV9tYXRjaChyZSwgcywgcG9zLCAwKTtcbiAgaWYgKHJlcykgcmV0dXJuIHJlcztcbiAgZWxzZSByZXR1cm4gWzBdO1xufVxuXG4vL1Byb3ZpZGVzOiByZV9wYXJ0aWFsX21hdGNoXG4vL1JlcXVpcmVzOiByZV9tYXRjaCwgY2FtbF9tbF9zdHJpbmdfbGVuZ3RoLCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIHJlX3BhcnRpYWxfbWF0Y2gocmUscyxwb3Mpe1xuICBpZihwb3MgPCAwIHx8IHBvcyA+IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSlcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJTdHIucGFydGlhbF9tYXRjaFwiKVxuICB2YXIgcmVzID0gcmVfbWF0Y2gocmUsIHMsIHBvcywgMSk7XG4gIGlmIChyZXMpIHJldHVybiByZXM7XG4gIGVsc2UgcmV0dXJuIFswXTtcbn1cblxuLy9Qcm92aWRlczogcmVfcmVwbGFjZW1lbnRfdGV4dFxuLy9SZXF1aXJlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZywgY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuLy9SZXF1aXJlczogY2FtbF9hcnJheV9nZXRcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbi8vIGV4dGVybmFsIHJlX3JlcGxhY2VtZW50X3RleHQ6IHN0cmluZyAtPiBpbnQgYXJyYXkgLT4gc3RyaW5nIC0+IHN0cmluZ1xuZnVuY3Rpb24gcmVfcmVwbGFjZW1lbnRfdGV4dChyZXBsLGdyb3VwcyxvcmlnKSB7XG4gIHZhciByZXBsID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhyZXBsKTtcbiAgdmFyIGxlbiA9IHJlcGwubGVuZ3RoO1xuICB2YXIgb3JpZyA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcob3JpZyk7XG4gIHZhciByZXMgPSBcIlwiOyAvL3Jlc3VsdFxuICB2YXIgbiA9IDA7IC8vIGN1cnJlbnQgcG9zaXRpb25cbiAgdmFyIGN1cjsgLy9jdXJyZW50IGNoYXJcbiAgdmFyIHN0YXJ0LCBlbmQsIGM7XG4gIHdoaWxlKG4gPCBsZW4pe1xuICAgIGN1ciA9IHJlcGwuY2hhckF0KG4rKyk7XG4gICAgaWYoY3VyICE9ICdcXFxcJyl7XG4gICAgICByZXMgKz0gY3VyO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmKG4gPT0gbGVuKSBjYW1sX2ZhaWx3aXRoKFwiU3RyLnJlcGxhY2U6IGlsbGVnYWwgYmFja3NsYXNoIHNlcXVlbmNlXCIpO1xuICAgICAgY3VyID0gcmVwbC5jaGFyQXQobisrKTtcbiAgICAgIHN3aXRjaChjdXIpe1xuICAgICAgY2FzZSAnXFxcXCc6XG4gICAgICAgIHJlcyArPSBjdXI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnMCc6IGNhc2UgJzEnOiBjYXNlICcyJzogY2FzZSAnMyc6IGNhc2UgJzQnOlxuICAgICAgY2FzZSAnNSc6IGNhc2UgJzYnOiBjYXNlICc3JzogY2FzZSAnOCc6IGNhc2UgJzknOlxuICAgICAgICBjID0gK2N1cjtcbiAgICAgICAgaWYgKGMqMiA+PSBncm91cHMubGVuZ3RoIC0gMSApXG4gICAgICAgICAgY2FtbF9mYWlsd2l0aChcIlN0ci5yZXBsYWNlOiByZWZlcmVuY2UgdG8gdW5tYXRjaGVkIGdyb3VwXCIgKTtcbiAgICAgICAgc3RhcnQgPSBjYW1sX2FycmF5X2dldChncm91cHMsYyoyKTtcbiAgICAgICAgZW5kID0gY2FtbF9hcnJheV9nZXQoZ3JvdXBzLCBjKjIgKzEpO1xuICAgICAgICBpZiAoc3RhcnQgPT0gLTEpXG4gICAgICAgICAgY2FtbF9mYWlsd2l0aChcIlN0ci5yZXBsYWNlOiByZWZlcmVuY2UgdG8gdW5tYXRjaGVkIGdyb3VwXCIpO1xuICAgICAgICByZXMrPW9yaWcuc2xpY2Uoc3RhcnQsZW5kKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXMgKz0gKCdcXFxcJyAgKyBjdXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhyZXMpOyB9XG4iLCIvL1RoZSBmb2xsb3dpbmcgYXJlIGRlZmluZWQgaW4gQ3N0cnVjdFxuLy9UaGVyZSBhcmUganVzdCBwcm92aWRlZCBoZXJlIGZvciBjb21wYXRpYmlsaXR5IHJlYXNvbnNcblxuLy9Qcm92aWRlczogY2FtbF9ibGl0X2JpZ3N0cmluZ190b19iaWdzdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYmFcbi8vV2Vha2RlZlxudmFyIGNhbWxfYmxpdF9iaWdzdHJpbmdfdG9fYmlnc3RyaW5nID0gY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19iYVxuLy9Qcm92aWRlczogY2FtbF9ibGl0X2JpZ3N0cmluZ190b19zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYnl0ZXNcbi8vV2Vha2RlZlxudmFyIGNhbWxfYmxpdF9iaWdzdHJpbmdfdG9fc3RyaW5nID0gY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19ieXRlc1xuLy9Qcm92aWRlczogY2FtbF9ibGl0X3N0cmluZ190b19iaWdzdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfYmlnc3RyaW5nX2JsaXRfc3RyaW5nX3RvX2JhXG4vL1dlYWtkZWZcbnZhciBjYW1sX2JsaXRfc3RyaW5nX3RvX2JpZ3N0cmluZyA9IGNhbWxfYmlnc3RyaW5nX2JsaXRfc3RyaW5nX3RvX2JhXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgIERhbmllbCBDLiBCdWVuemxpICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE0IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbmV4dGVybmFsIGZvcm1hdF9pbnQgOiBzdHJpbmcgLT4gaW50IC0+IHN0cmluZyA9IFwiY2FtbF9mb3JtYXRfaW50XCJcblxubGV0IGVycl9ub19wcmVkID0gXCJVKzAwMDAgaGFzIG5vIHByZWRlY2Vzc29yXCJcbmxldCBlcnJfbm9fc3VjYyA9IFwiVSsxMEZGRkYgaGFzIG5vIHN1Y2Nlc3NvclwiXG5sZXQgZXJyX25vdF9zdiBpID0gZm9ybWF0X2ludCBcIiVYXCIgaSBeIFwiIGlzIG5vdCBhbiBVbmljb2RlIHNjYWxhciB2YWx1ZVwiXG5sZXQgZXJyX25vdF9sYXRpbjEgdSA9IFwiVStcIiBeIGZvcm1hdF9pbnQgXCIlMDRYXCIgdSBeIFwiIGlzIG5vdCBhIGxhdGluMSBjaGFyYWN0ZXJcIlxuXG50eXBlIHQgPSBpbnRcblxubGV0IG1pbiA9IDB4MDAwMFxubGV0IG1heCA9IDB4MTBGRkZGXG5sZXQgbG9fYm91bmQgPSAweEQ3RkZcbmxldCBoaV9ib3VuZCA9IDB4RTAwMFxuXG5sZXQgYm9tID0gMHhGRUZGXG5sZXQgcmVwID0gMHhGRkZEXG5cbmxldCBzdWNjIHUgPVxuICBpZiB1ID0gbG9fYm91bmQgdGhlbiBoaV9ib3VuZCBlbHNlXG4gIGlmIHUgPSBtYXggdGhlbiBpbnZhbGlkX2FyZyBlcnJfbm9fc3VjYyBlbHNlXG4gIHUgKyAxXG5cbmxldCBwcmVkIHUgPVxuICBpZiB1ID0gaGlfYm91bmQgdGhlbiBsb19ib3VuZCBlbHNlXG4gIGlmIHUgPSBtaW4gdGhlbiBpbnZhbGlkX2FyZyBlcnJfbm9fcHJlZCBlbHNlXG4gIHUgLSAxXG5cbmxldCBpc192YWxpZCBpID0gKG1pbiA8PSBpICYmIGkgPD0gbG9fYm91bmQpIHx8IChoaV9ib3VuZCA8PSBpICYmIGkgPD0gbWF4KVxubGV0IG9mX2ludCBpID0gaWYgaXNfdmFsaWQgaSB0aGVuIGkgZWxzZSBpbnZhbGlkX2FyZyAoZXJyX25vdF9zdiBpKVxuZXh0ZXJuYWwgdW5zYWZlX29mX2ludCA6IGludCAtPiB0ID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgdG9faW50IDogdCAtPiBpbnQgPSBcIiVpZGVudGl0eVwiXG5cbmxldCBpc19jaGFyIHUgPSB1IDwgMjU2XG5sZXQgb2ZfY2hhciBjID0gQ2hhci5jb2RlIGNcbmxldCB0b19jaGFyIHUgPVxuICBpZiB1ID4gMjU1IHRoZW4gaW52YWxpZF9hcmcgKGVycl9ub3RfbGF0aW4xIHUpIGVsc2VcbiAgQ2hhci51bnNhZmVfY2hyIHVcblxubGV0IHVuc2FmZV90b19jaGFyID0gQ2hhci51bnNhZmVfY2hyXG5cbmxldCBlcXVhbCA6IGludCAtPiBpbnQgLT4gYm9vbCA9ICggPSApXG5sZXQgY29tcGFyZSA6IGludCAtPiBpbnQgLT4gaW50ID0gU3RkbGliLmNvbXBhcmVcbmxldCBoYXNoID0gdG9faW50XG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIE1vZHVsZSBbSW50NjRdOiA2NC1iaXQgaW50ZWdlcnMgKilcblxuZXh0ZXJuYWwgbmVnIDogaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9uZWdcIlxuZXh0ZXJuYWwgYWRkIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9hZGRcIlxuZXh0ZXJuYWwgc3ViIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9zdWJcIlxuZXh0ZXJuYWwgbXVsIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9tdWxcIlxuZXh0ZXJuYWwgZGl2IDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9kaXZcIlxuZXh0ZXJuYWwgcmVtIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9tb2RcIlxuZXh0ZXJuYWwgbG9nYW5kIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9hbmRcIlxuZXh0ZXJuYWwgbG9nb3IgOiBpbnQ2NCAtPiBpbnQ2NCAtPiBpbnQ2NCA9IFwiJWludDY0X29yXCJcbmV4dGVybmFsIGxvZ3hvciA6IGludDY0IC0+IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfeG9yXCJcbmV4dGVybmFsIHNoaWZ0X2xlZnQgOiBpbnQ2NCAtPiBpbnQgLT4gaW50NjQgPSBcIiVpbnQ2NF9sc2xcIlxuZXh0ZXJuYWwgc2hpZnRfcmlnaHQgOiBpbnQ2NCAtPiBpbnQgLT4gaW50NjQgPSBcIiVpbnQ2NF9hc3JcIlxuZXh0ZXJuYWwgc2hpZnRfcmlnaHRfbG9naWNhbCA6IGludDY0IC0+IGludCAtPiBpbnQ2NCA9IFwiJWludDY0X2xzclwiXG5leHRlcm5hbCBvZl9pbnQgOiBpbnQgLT4gaW50NjQgPSBcIiVpbnQ2NF9vZl9pbnRcIlxuZXh0ZXJuYWwgdG9faW50IDogaW50NjQgLT4gaW50ID0gXCIlaW50NjRfdG9faW50XCJcbmV4dGVybmFsIG9mX2Zsb2F0IDogZmxvYXQgLT4gaW50NjRcbiAgPSBcImNhbWxfaW50NjRfb2ZfZmxvYXRcIiBcImNhbWxfaW50NjRfb2ZfZmxvYXRfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCB0b19mbG9hdCA6IGludDY0IC0+IGZsb2F0XG4gID0gXCJjYW1sX2ludDY0X3RvX2Zsb2F0XCIgXCJjYW1sX2ludDY0X3RvX2Zsb2F0X3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgb2ZfaW50MzIgOiBpbnQzMiAtPiBpbnQ2NCA9IFwiJWludDY0X29mX2ludDMyXCJcbmV4dGVybmFsIHRvX2ludDMyIDogaW50NjQgLT4gaW50MzIgPSBcIiVpbnQ2NF90b19pbnQzMlwiXG5leHRlcm5hbCBvZl9uYXRpdmVpbnQgOiBuYXRpdmVpbnQgLT4gaW50NjQgPSBcIiVpbnQ2NF9vZl9uYXRpdmVpbnRcIlxuZXh0ZXJuYWwgdG9fbmF0aXZlaW50IDogaW50NjQgLT4gbmF0aXZlaW50ID0gXCIlaW50NjRfdG9fbmF0aXZlaW50XCJcblxubGV0IHplcm8gPSAwTFxubGV0IG9uZSA9IDFMXG5sZXQgbWludXNfb25lID0gLTFMXG5sZXQgc3VjYyBuID0gYWRkIG4gMUxcbmxldCBwcmVkIG4gPSBzdWIgbiAxTFxubGV0IGFicyBuID0gaWYgbiA+PSAwTCB0aGVuIG4gZWxzZSBuZWcgblxubGV0IG1pbl9pbnQgPSAweDgwMDAwMDAwMDAwMDAwMDBMXG5sZXQgbWF4X2ludCA9IDB4N0ZGRkZGRkZGRkZGRkZGRkxcbmxldCBsb2dub3QgbiA9IGxvZ3hvciBuICgtMUwpXG5cbmxldCB1bnNpZ25lZF90b19pbnQgPVxuICBsZXQgbWF4X2ludCA9IG9mX2ludCBTdGRsaWIubWF4X2ludCBpblxuICBmdW4gbiAtPlxuICAgIGlmIGNvbXBhcmUgemVybyBuIDw9IDAgJiYgY29tcGFyZSBuIG1heF9pbnQgPD0gMCB0aGVuXG4gICAgICBTb21lICh0b19pbnQgbilcbiAgICBlbHNlXG4gICAgICBOb25lXG5cbmV4dGVybmFsIGZvcm1hdCA6IHN0cmluZyAtPiBpbnQ2NCAtPiBzdHJpbmcgPSBcImNhbWxfaW50NjRfZm9ybWF0XCJcbmxldCB0b19zdHJpbmcgbiA9IGZvcm1hdCBcIiVkXCIgblxuXG5leHRlcm5hbCBvZl9zdHJpbmcgOiBzdHJpbmcgLT4gaW50NjQgPSBcImNhbWxfaW50NjRfb2Zfc3RyaW5nXCJcblxubGV0IG9mX3N0cmluZ19vcHQgcyA9XG4gICgqIFRPRE86IGV4cG9zZSBhIG5vbi1yYWlzaW5nIHByaW1pdGl2ZSBkaXJlY3RseS4gKilcbiAgdHJ5IFNvbWUgKG9mX3N0cmluZyBzKVxuICB3aXRoIEZhaWx1cmUgXyAtPiBOb25lXG5cblxuXG5leHRlcm5hbCBiaXRzX29mX2Zsb2F0IDogZmxvYXQgLT4gaW50NjRcbiAgPSBcImNhbWxfaW50NjRfYml0c19vZl9mbG9hdFwiIFwiY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0X3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZmxvYXRfb2ZfYml0cyA6IGludDY0IC0+IGZsb2F0XG4gID0gXCJjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHNcIiBcImNhbWxfaW50NjRfZmxvYXRfb2ZfYml0c191bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cblxudHlwZSB0ID0gaW50NjRcblxubGV0IGNvbXBhcmUgKHg6IHQpICh5OiB0KSA9IFN0ZGxpYi5jb21wYXJlIHggeVxubGV0IGVxdWFsICh4OiB0KSAoeTogdCkgPSBjb21wYXJlIHggeSA9IDBcblxubGV0IHVuc2lnbmVkX2NvbXBhcmUgbiBtID1cbiAgY29tcGFyZSAoc3ViIG4gbWluX2ludCkgKHN1YiBtIG1pbl9pbnQpXG5cbigqIFVuc2lnbmVkIGRpdmlzaW9uIGZyb20gc2lnbmVkIGRpdmlzaW9uIG9mIHRoZSBzYW1lXG4gICBiaXRuZXNzLiBTZWUgV2FycmVuIEpyLiwgSGVucnkgUy4gKDIwMTMpLiBIYWNrZXIncyBEZWxpZ2h0ICgyIGVkLiksIFNlYyA5LTMuXG4qKVxubGV0IHVuc2lnbmVkX2RpdiBuIGQgPVxuICBpZiBkIDwgemVybyB0aGVuXG4gICAgaWYgdW5zaWduZWRfY29tcGFyZSBuIGQgPCAwIHRoZW4gemVybyBlbHNlIG9uZVxuICBlbHNlXG4gICAgbGV0IHEgPSBzaGlmdF9sZWZ0IChkaXYgKHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgbiAxKSBkKSAxIGluXG4gICAgbGV0IHIgPSBzdWIgbiAobXVsIHEgZCkgaW5cbiAgICBpZiB1bnNpZ25lZF9jb21wYXJlIHIgZCA+PSAwIHRoZW4gc3VjYyBxIGVsc2UgcVxuXG5sZXQgdW5zaWduZWRfcmVtIG4gZCA9XG4gIHN1YiBuIChtdWwgKHVuc2lnbmVkX2RpdiBuIGQpIGQpXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIFRoZSBydW4tdGltZSBsaWJyYXJ5IGZvciBsZXhlcnMgZ2VuZXJhdGVkIGJ5IGNhbWxsZXggKilcblxudHlwZSBwb3NpdGlvbiA9IHtcbiAgcG9zX2ZuYW1lIDogc3RyaW5nO1xuICBwb3NfbG51bSA6IGludDtcbiAgcG9zX2JvbCA6IGludDtcbiAgcG9zX2NudW0gOiBpbnQ7XG59XG5cbmxldCBkdW1teV9wb3MgPSB7XG4gIHBvc19mbmFtZSA9IFwiXCI7XG4gIHBvc19sbnVtID0gMDtcbiAgcG9zX2JvbCA9IDA7XG4gIHBvc19jbnVtID0gLTE7XG59XG5cbnR5cGUgbGV4YnVmID1cbiAgeyByZWZpbGxfYnVmZiA6IGxleGJ1ZiAtPiB1bml0O1xuICAgIG11dGFibGUgbGV4X2J1ZmZlciA6IGJ5dGVzO1xuICAgIG11dGFibGUgbGV4X2J1ZmZlcl9sZW4gOiBpbnQ7XG4gICAgbXV0YWJsZSBsZXhfYWJzX3BvcyA6IGludDtcbiAgICBtdXRhYmxlIGxleF9zdGFydF9wb3MgOiBpbnQ7XG4gICAgbXV0YWJsZSBsZXhfY3Vycl9wb3MgOiBpbnQ7XG4gICAgbXV0YWJsZSBsZXhfbGFzdF9wb3MgOiBpbnQ7XG4gICAgbXV0YWJsZSBsZXhfbGFzdF9hY3Rpb24gOiBpbnQ7XG4gICAgbXV0YWJsZSBsZXhfZW9mX3JlYWNoZWQgOiBib29sO1xuICAgIG11dGFibGUgbGV4X21lbSA6IGludCBhcnJheTtcbiAgICBtdXRhYmxlIGxleF9zdGFydF9wIDogcG9zaXRpb247XG4gICAgbXV0YWJsZSBsZXhfY3Vycl9wIDogcG9zaXRpb247XG4gIH1cblxudHlwZSBsZXhfdGFibGVzID1cbiAgeyBsZXhfYmFzZTogc3RyaW5nO1xuICAgIGxleF9iYWNrdHJrOiBzdHJpbmc7XG4gICAgbGV4X2RlZmF1bHQ6IHN0cmluZztcbiAgICBsZXhfdHJhbnM6IHN0cmluZztcbiAgICBsZXhfY2hlY2s6IHN0cmluZztcbiAgICBsZXhfYmFzZV9jb2RlIDogc3RyaW5nO1xuICAgIGxleF9iYWNrdHJrX2NvZGUgOiBzdHJpbmc7XG4gICAgbGV4X2RlZmF1bHRfY29kZSA6IHN0cmluZztcbiAgICBsZXhfdHJhbnNfY29kZSA6IHN0cmluZztcbiAgICBsZXhfY2hlY2tfY29kZSA6IHN0cmluZztcbiAgICBsZXhfY29kZTogc3RyaW5nO31cblxuZXh0ZXJuYWwgY19lbmdpbmUgOiBsZXhfdGFibGVzIC0+IGludCAtPiBsZXhidWYgLT4gaW50ID0gXCJjYW1sX2xleF9lbmdpbmVcIlxuZXh0ZXJuYWwgY19uZXdfZW5naW5lIDogbGV4X3RhYmxlcyAtPiBpbnQgLT4gbGV4YnVmIC0+IGludFxuICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX25ld19sZXhfZW5naW5lXCJcblxubGV0IGVuZ2luZSB0Ymwgc3RhdGUgYnVmID1cbiAgbGV0IHJlc3VsdCA9IGNfZW5naW5lIHRibCBzdGF0ZSBidWYgaW5cbiAgaWYgcmVzdWx0ID49IDAgJiYgYnVmLmxleF9jdXJyX3AgIT0gZHVtbXlfcG9zIHRoZW4gYmVnaW5cbiAgICBidWYubGV4X3N0YXJ0X3AgPC0gYnVmLmxleF9jdXJyX3A7XG4gICAgYnVmLmxleF9jdXJyX3AgPC0ge2J1Zi5sZXhfY3Vycl9wXG4gICAgICAgICAgICAgICAgICAgICAgIHdpdGggcG9zX2NudW0gPSBidWYubGV4X2Fic19wb3MgKyBidWYubGV4X2N1cnJfcG9zfTtcbiAgZW5kO1xuICByZXN1bHRcblxuXG5sZXQgbmV3X2VuZ2luZSB0Ymwgc3RhdGUgYnVmID1cbiAgbGV0IHJlc3VsdCA9IGNfbmV3X2VuZ2luZSB0Ymwgc3RhdGUgYnVmIGluXG4gIGlmIHJlc3VsdCA+PSAwICYmIGJ1Zi5sZXhfY3Vycl9wICE9IGR1bW15X3BvcyB0aGVuIGJlZ2luXG4gICAgYnVmLmxleF9zdGFydF9wIDwtIGJ1Zi5sZXhfY3Vycl9wO1xuICAgIGJ1Zi5sZXhfY3Vycl9wIDwtIHtidWYubGV4X2N1cnJfcFxuICAgICAgICAgICAgICAgICAgICAgICB3aXRoIHBvc19jbnVtID0gYnVmLmxleF9hYnNfcG9zICsgYnVmLmxleF9jdXJyX3Bvc307XG4gIGVuZDtcbiAgcmVzdWx0XG5cblxubGV0IGxleF9yZWZpbGwgcmVhZF9mdW4gYXV4X2J1ZmZlciBsZXhidWYgPVxuICBsZXQgcmVhZCA9XG4gICAgcmVhZF9mdW4gYXV4X2J1ZmZlciAoQnl0ZXMubGVuZ3RoIGF1eF9idWZmZXIpIGluXG4gIGxldCBuID1cbiAgICBpZiByZWFkID4gMFxuICAgIHRoZW4gcmVhZFxuICAgIGVsc2UgKGxleGJ1Zi5sZXhfZW9mX3JlYWNoZWQgPC0gdHJ1ZTsgMCkgaW5cbiAgKCogQ3VycmVudCBzdGF0ZSBvZiB0aGUgYnVmZmVyOlxuICAgICAgICA8LS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0+XG4gICAgICAgIHwgIGp1bmsgfCAgICAgIHZhbGlkIGRhdGEgICAgIHwgICBqdW5rICAgIHxcbiAgICAgICAgXiAgICAgICBeICAgICAgICAgICAgICAgICAgICAgXiAgICAgICAgICAgXlxuICAgICAgICAwICAgIHN0YXJ0X3BvcyAgICAgICAgICAgICBidWZmZXJfZW5kICAgIEJ5dGVzLmxlbmd0aCBidWZmZXJcbiAgKilcbiAgaWYgbGV4YnVmLmxleF9idWZmZXJfbGVuICsgbiA+IEJ5dGVzLmxlbmd0aCBsZXhidWYubGV4X2J1ZmZlciB0aGVuIGJlZ2luXG4gICAgKCogVGhlcmUgaXMgbm90IGVub3VnaCBzcGFjZSBhdCB0aGUgZW5kIG9mIHRoZSBidWZmZXIgKilcbiAgICBpZiBsZXhidWYubGV4X2J1ZmZlcl9sZW4gLSBsZXhidWYubGV4X3N0YXJ0X3BvcyArIG5cbiAgICAgICA8PSBCeXRlcy5sZW5ndGggbGV4YnVmLmxleF9idWZmZXJcbiAgICB0aGVuIGJlZ2luXG4gICAgICAoKiBCdXQgdGhlcmUgaXMgZW5vdWdoIHNwYWNlIGlmIHdlIHJlY2xhaW0gdGhlIGp1bmsgYXQgdGhlIGJlZ2lubmluZ1xuICAgICAgICAgb2YgdGhlIGJ1ZmZlciAqKVxuICAgICAgQnl0ZXMuYmxpdCBsZXhidWYubGV4X2J1ZmZlciBsZXhidWYubGV4X3N0YXJ0X3Bvc1xuICAgICAgICAgICAgICAgICAgbGV4YnVmLmxleF9idWZmZXIgMFxuICAgICAgICAgICAgICAgICAgKGxleGJ1Zi5sZXhfYnVmZmVyX2xlbiAtIGxleGJ1Zi5sZXhfc3RhcnRfcG9zKVxuICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAoKiBXZSBtdXN0IGdyb3cgdGhlIGJ1ZmZlci4gIERvdWJsaW5nIGl0cyBzaXplIHdpbGwgcHJvdmlkZSBlbm91Z2hcbiAgICAgICAgIHNwYWNlIHNpbmNlIG4gPD0gU3RyaW5nLmxlbmd0aCBhdXhfYnVmZmVyIDw9IFN0cmluZy5sZW5ndGggYnVmZmVyLlxuICAgICAgICAgV2F0Y2ggb3V0IGZvciBzdHJpbmcgbGVuZ3RoIG92ZXJmbG93LCB0aG91Z2guICopXG4gICAgICBsZXQgbmV3bGVuID1cbiAgICAgICAgbWluICgyICogQnl0ZXMubGVuZ3RoIGxleGJ1Zi5sZXhfYnVmZmVyKSBTeXMubWF4X3N0cmluZ19sZW5ndGggaW5cbiAgICAgIGlmIGxleGJ1Zi5sZXhfYnVmZmVyX2xlbiAtIGxleGJ1Zi5sZXhfc3RhcnRfcG9zICsgbiA+IG5ld2xlblxuICAgICAgdGhlbiBmYWlsd2l0aCBcIkxleGluZy5sZXhfcmVmaWxsOiBjYW5ub3QgZ3JvdyBidWZmZXJcIjtcbiAgICAgIGxldCBuZXdidWYgPSBCeXRlcy5jcmVhdGUgbmV3bGVuIGluXG4gICAgICAoKiBDb3B5IHRoZSB2YWxpZCBkYXRhIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIG5ldyBidWZmZXIgKilcbiAgICAgIEJ5dGVzLmJsaXQgbGV4YnVmLmxleF9idWZmZXIgbGV4YnVmLmxleF9zdGFydF9wb3NcbiAgICAgICAgICAgICAgICAgIG5ld2J1ZiAwXG4gICAgICAgICAgICAgICAgICAobGV4YnVmLmxleF9idWZmZXJfbGVuIC0gbGV4YnVmLmxleF9zdGFydF9wb3MpO1xuICAgICAgbGV4YnVmLmxleF9idWZmZXIgPC0gbmV3YnVmXG4gICAgZW5kO1xuICAgICgqIFJlYWxsb2NhdGlvbiBvciBub3QsIHdlIGhhdmUgc2hpZnRlZCB0aGUgZGF0YSBsZWZ0IGJ5XG4gICAgICAgc3RhcnRfcG9zIGNoYXJhY3RlcnM7IHVwZGF0ZSB0aGUgcG9zaXRpb25zICopXG4gICAgbGV0IHMgPSBsZXhidWYubGV4X3N0YXJ0X3BvcyBpblxuICAgIGxleGJ1Zi5sZXhfYWJzX3BvcyA8LSBsZXhidWYubGV4X2Fic19wb3MgKyBzO1xuICAgIGxleGJ1Zi5sZXhfY3Vycl9wb3MgPC0gbGV4YnVmLmxleF9jdXJyX3BvcyAtIHM7XG4gICAgbGV4YnVmLmxleF9zdGFydF9wb3MgPC0gMDtcbiAgICBsZXhidWYubGV4X2xhc3RfcG9zIDwtIGxleGJ1Zi5sZXhfbGFzdF9wb3MgLSBzO1xuICAgIGxleGJ1Zi5sZXhfYnVmZmVyX2xlbiA8LSBsZXhidWYubGV4X2J1ZmZlcl9sZW4gLSBzIDtcbiAgICBsZXQgdCA9IGxleGJ1Zi5sZXhfbWVtIGluXG4gICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCB0LTEgZG9cbiAgICAgIGxldCB2ID0gdC4oaSkgaW5cbiAgICAgIGlmIHYgPj0gMCB0aGVuXG4gICAgICAgIHQuKGkpIDwtIHYtc1xuICAgIGRvbmVcbiAgZW5kO1xuICAoKiBUaGVyZSBpcyBub3cgZW5vdWdoIHNwYWNlIGF0IHRoZSBlbmQgb2YgdGhlIGJ1ZmZlciAqKVxuICBCeXRlcy5ibGl0IGF1eF9idWZmZXIgMCBsZXhidWYubGV4X2J1ZmZlciBsZXhidWYubGV4X2J1ZmZlcl9sZW4gbjtcbiAgbGV4YnVmLmxleF9idWZmZXJfbGVuIDwtIGxleGJ1Zi5sZXhfYnVmZmVyX2xlbiArIG5cblxubGV0IHplcm9fcG9zID0ge1xuICBwb3NfZm5hbWUgPSBcIlwiO1xuICBwb3NfbG51bSA9IDE7XG4gIHBvc19ib2wgPSAwO1xuICBwb3NfY251bSA9IDA7XG59XG5cbmxldCBmcm9tX2Z1bmN0aW9uID8od2l0aF9wb3NpdGlvbnMgPSB0cnVlKSBmID1cbiAgeyByZWZpbGxfYnVmZiA9IGxleF9yZWZpbGwgZiAoQnl0ZXMuY3JlYXRlIDUxMik7XG4gICAgbGV4X2J1ZmZlciA9IEJ5dGVzLmNyZWF0ZSAxMDI0O1xuICAgIGxleF9idWZmZXJfbGVuID0gMDtcbiAgICBsZXhfYWJzX3BvcyA9IDA7XG4gICAgbGV4X3N0YXJ0X3BvcyA9IDA7XG4gICAgbGV4X2N1cnJfcG9zID0gMDtcbiAgICBsZXhfbGFzdF9wb3MgPSAwO1xuICAgIGxleF9sYXN0X2FjdGlvbiA9IDA7XG4gICAgbGV4X21lbSA9IFt8fF07XG4gICAgbGV4X2VvZl9yZWFjaGVkID0gZmFsc2U7XG4gICAgbGV4X3N0YXJ0X3AgPSBpZiB3aXRoX3Bvc2l0aW9ucyB0aGVuIHplcm9fcG9zIGVsc2UgZHVtbXlfcG9zO1xuICAgIGxleF9jdXJyX3AgPSBpZiB3aXRoX3Bvc2l0aW9ucyB0aGVuIHplcm9fcG9zIGVsc2UgZHVtbXlfcG9zO1xuICB9XG5cbmxldCBmcm9tX2NoYW5uZWwgP3dpdGhfcG9zaXRpb25zIGljID1cbiAgZnJvbV9mdW5jdGlvbiA/d2l0aF9wb3NpdGlvbnMgKGZ1biBidWYgbiAtPiBpbnB1dCBpYyBidWYgMCBuKVxuXG5sZXQgZnJvbV9zdHJpbmcgPyh3aXRoX3Bvc2l0aW9ucyA9IHRydWUpIHMgPVxuICB7IHJlZmlsbF9idWZmID0gKGZ1biBsZXhidWYgLT4gbGV4YnVmLmxleF9lb2ZfcmVhY2hlZCA8LSB0cnVlKTtcbiAgICBsZXhfYnVmZmVyID0gQnl0ZXMub2Zfc3RyaW5nIHM7ICgqIGhhdmUgdG8gbWFrZSBhIGNvcHkgZm9yIGNvbXBhdGliaWxpdHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpdGggdW5zYWZlLXN0cmluZyBtb2RlICopXG4gICAgbGV4X2J1ZmZlcl9sZW4gPSBTdHJpbmcubGVuZ3RoIHM7XG4gICAgbGV4X2Fic19wb3MgPSAwO1xuICAgIGxleF9zdGFydF9wb3MgPSAwO1xuICAgIGxleF9jdXJyX3BvcyA9IDA7XG4gICAgbGV4X2xhc3RfcG9zID0gMDtcbiAgICBsZXhfbGFzdF9hY3Rpb24gPSAwO1xuICAgIGxleF9tZW0gPSBbfHxdO1xuICAgIGxleF9lb2ZfcmVhY2hlZCA9IHRydWU7XG4gICAgbGV4X3N0YXJ0X3AgPSBpZiB3aXRoX3Bvc2l0aW9ucyB0aGVuIHplcm9fcG9zIGVsc2UgZHVtbXlfcG9zO1xuICAgIGxleF9jdXJyX3AgPSBpZiB3aXRoX3Bvc2l0aW9ucyB0aGVuIHplcm9fcG9zIGVsc2UgZHVtbXlfcG9zO1xuICB9XG5cbmxldCBzZXRfcG9zaXRpb24gbGV4YnVmIHBvc2l0aW9uID1cbiAgbGV4YnVmLmxleF9jdXJyX3AgIDwtIHtwb3NpdGlvbiB3aXRoIHBvc19mbmFtZSA9IGxleGJ1Zi5sZXhfY3Vycl9wLnBvc19mbmFtZX07XG4gIGxleGJ1Zi5sZXhfYWJzX3BvcyA8LSBwb3NpdGlvbi5wb3NfY251bVxuXG5sZXQgc2V0X2ZpbGVuYW1lIGxleGJ1ZiBmbmFtZSA9XG4gIGxleGJ1Zi5sZXhfY3Vycl9wIDwtIHtsZXhidWYubGV4X2N1cnJfcCB3aXRoIHBvc19mbmFtZSA9IGZuYW1lfVxuXG5sZXQgd2l0aF9wb3NpdGlvbnMgbGV4YnVmID0gbGV4YnVmLmxleF9jdXJyX3AgIT0gZHVtbXlfcG9zXG5cbmxldCBsZXhlbWUgbGV4YnVmID1cbiAgbGV0IGxlbiA9IGxleGJ1Zi5sZXhfY3Vycl9wb3MgLSBsZXhidWYubGV4X3N0YXJ0X3BvcyBpblxuICBCeXRlcy5zdWJfc3RyaW5nIGxleGJ1Zi5sZXhfYnVmZmVyIGxleGJ1Zi5sZXhfc3RhcnRfcG9zIGxlblxuXG5sZXQgc3ViX2xleGVtZSBsZXhidWYgaTEgaTIgPVxuICBsZXQgbGVuID0gaTItaTEgaW5cbiAgQnl0ZXMuc3ViX3N0cmluZyBsZXhidWYubGV4X2J1ZmZlciBpMSBsZW5cblxubGV0IHN1Yl9sZXhlbWVfb3B0IGxleGJ1ZiBpMSBpMiA9XG4gIGlmIGkxID49IDAgdGhlbiBiZWdpblxuICAgIGxldCBsZW4gPSBpMi1pMSBpblxuICAgIFNvbWUgKEJ5dGVzLnN1Yl9zdHJpbmcgbGV4YnVmLmxleF9idWZmZXIgaTEgbGVuKVxuICBlbmQgZWxzZSBiZWdpblxuICAgIE5vbmVcbiAgZW5kXG5cbmxldCBzdWJfbGV4ZW1lX2NoYXIgbGV4YnVmIGkgPSBCeXRlcy5nZXQgbGV4YnVmLmxleF9idWZmZXIgaVxuXG5sZXQgc3ViX2xleGVtZV9jaGFyX29wdCBsZXhidWYgaSA9XG4gIGlmIGkgPj0gMCB0aGVuXG4gICAgU29tZSAoQnl0ZXMuZ2V0IGxleGJ1Zi5sZXhfYnVmZmVyIGkpXG4gIGVsc2VcbiAgICBOb25lXG5cblxubGV0IGxleGVtZV9jaGFyIGxleGJ1ZiBpID1cbiAgQnl0ZXMuZ2V0IGxleGJ1Zi5sZXhfYnVmZmVyIChsZXhidWYubGV4X3N0YXJ0X3BvcyArIGkpXG5cbmxldCBsZXhlbWVfc3RhcnQgbGV4YnVmID0gbGV4YnVmLmxleF9zdGFydF9wLnBvc19jbnVtXG5sZXQgbGV4ZW1lX2VuZCBsZXhidWYgPSBsZXhidWYubGV4X2N1cnJfcC5wb3NfY251bVxuXG5sZXQgbGV4ZW1lX3N0YXJ0X3AgbGV4YnVmID0gbGV4YnVmLmxleF9zdGFydF9wXG5sZXQgbGV4ZW1lX2VuZF9wIGxleGJ1ZiA9IGxleGJ1Zi5sZXhfY3Vycl9wXG5cbmxldCBuZXdfbGluZSBsZXhidWYgPVxuICBsZXQgbGNwID0gbGV4YnVmLmxleF9jdXJyX3AgaW5cbiAgaWYgbGNwICE9IGR1bW15X3BvcyB0aGVuXG4gICAgbGV4YnVmLmxleF9jdXJyX3AgPC1cbiAgICAgIHsgbGNwIHdpdGhcbiAgICAgICAgcG9zX2xudW0gPSBsY3AucG9zX2xudW0gKyAxO1xuICAgICAgICBwb3NfYm9sID0gbGNwLnBvc19jbnVtO1xuICAgICAgfVxuXG5cblxuKCogRGlzY2FyZCBkYXRhIGxlZnQgaW4gbGV4ZXIgYnVmZmVyLiAqKVxuXG5sZXQgZmx1c2hfaW5wdXQgbGIgPVxuICBsYi5sZXhfY3Vycl9wb3MgPC0gMDtcbiAgbGIubGV4X2Fic19wb3MgPC0gMDtcbiAgbGV0IGxjcCA9IGxiLmxleF9jdXJyX3AgaW5cbiAgaWYgbGNwICE9IGR1bW15X3BvcyB0aGVuXG4gICAgbGIubGV4X2N1cnJfcCA8LSB7emVyb19wb3Mgd2l0aCBwb3NfZm5hbWUgPSBsY3AucG9zX2ZuYW1lfTtcbiAgbGIubGV4X2J1ZmZlcl9sZW4gPC0gMDtcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICBCZW5vaXQgVmF1Z29uLCBFTlNUQSAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMTQgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxub3BlbiBDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3NcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgKCogVG9vbHMgdG8gbWFuaXB1bGF0ZSBzY2FubmluZyBzZXQgb2YgY2hhcnMgKHNlZSAlWy4uLl0pICopXG5cbnR5cGUgbXV0YWJsZV9jaGFyX3NldCA9IGJ5dGVzXG5cbigqIENyZWF0ZSBhIGZyZXNoLCBlbXB0eSwgbXV0YWJsZSBjaGFyIHNldC4gKilcbmxldCBjcmVhdGVfY2hhcl9zZXQgKCkgPSBCeXRlcy5tYWtlIDMyICdcXDAwMCdcblxuKCogQWRkIGEgY2hhciBpbiBhIG11dGFibGUgY2hhciBzZXQuICopXG5sZXQgYWRkX2luX2NoYXJfc2V0IGNoYXJfc2V0IGMgPVxuICBsZXQgaW5kID0gaW50X29mX2NoYXIgYyBpblxuICBsZXQgc3RyX2luZCA9IGluZCBsc3IgMyBhbmQgbWFzayA9IDEgbHNsIChpbmQgbGFuZCAwYjExMSkgaW5cbiAgQnl0ZXMuc2V0IGNoYXJfc2V0IHN0cl9pbmRcbiAgICAoY2hhcl9vZl9pbnQgKGludF9vZl9jaGFyIChCeXRlcy5nZXQgY2hhcl9zZXQgc3RyX2luZCkgbG9yIG1hc2spKVxuXG5sZXQgZnJlZXplX2NoYXJfc2V0IGNoYXJfc2V0ID1cbiAgQnl0ZXMudG9fc3RyaW5nIGNoYXJfc2V0XG5cbigqIENvbXB1dGUgdGhlIGNvbXBsZW1lbnQgb2YgYSBjaGFyIHNldC4gKilcbmxldCByZXZfY2hhcl9zZXQgY2hhcl9zZXQgPVxuICBsZXQgY2hhcl9zZXQnID0gY3JlYXRlX2NoYXJfc2V0ICgpIGluXG4gIGZvciBpID0gMCB0byAzMSBkb1xuICAgIEJ5dGVzLnNldCBjaGFyX3NldCcgaVxuICAgICAgKGNoYXJfb2ZfaW50IChpbnRfb2ZfY2hhciAoU3RyaW5nLmdldCBjaGFyX3NldCBpKSBseG9yIDB4RkYpKTtcbiAgZG9uZTtcbiAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBjaGFyX3NldCdcblxuKCogUmV0dXJuIHRydWUgaWYgYSBgYycgaXMgaW4gYGNoYXJfc2V0Jy4gKilcbmxldCBpc19pbl9jaGFyX3NldCBjaGFyX3NldCBjID1cbiAgbGV0IGluZCA9IGludF9vZl9jaGFyIGMgaW5cbiAgbGV0IHN0cl9pbmQgPSBpbmQgbHNyIDMgYW5kIG1hc2sgPSAxIGxzbCAoaW5kIGxhbmQgMGIxMTEpIGluXG4gIChpbnRfb2ZfY2hhciAoU3RyaW5nLmdldCBjaGFyX3NldCBzdHJfaW5kKSBsYW5kIG1hc2spIDw+IDBcblxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICgqIElnbm9yZWQgcGFyYW0gY29udmVyc2lvbiAqKVxuXG4oKiBHQURUIHVzZWQgdG8gYWJzdHJhY3QgYW4gZXhpc3RlbnRpYWwgdHlwZSBwYXJhbWV0ZXIuICopXG4oKiBTZWUgcGFyYW1fZm9ybWF0X29mX2lnbm9yZWRfZm9ybWF0LiAqKVxudHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgcGFyYW1fZm9ybWF0X2ViYiA9IFBhcmFtX2Zvcm1hdF9FQkIgOlxuICAgICgneCAtPiAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgcGFyYW1fZm9ybWF0X2ViYlxuXG4oKiBDb21wdXRlIGEgcGFkZGluZyBhc3NvY2lhdGVkIHRvIGEgcGFkX29wdGlvbiAoc2VlIFwiJV80MmRcIikuICopXG5sZXQgcGFkX29mX3BhZF9vcHQgcGFkX29wdCA9IG1hdGNoIHBhZF9vcHQgd2l0aFxuICB8IE5vbmUgLT4gTm9fcGFkZGluZ1xuICB8IFNvbWUgd2lkdGggLT4gTGl0X3BhZGRpbmcgKFJpZ2h0LCB3aWR0aClcblxuKCogQ29tcHV0ZSBhIHByZWNpc2lvbiBhc3NvY2lhdGVkIHRvIGEgcHJlY19vcHRpb24gKHNlZSBcIiVfLjQyZlwiKS4gKilcbmxldCBwcmVjX29mX3ByZWNfb3B0IHByZWNfb3B0ID0gbWF0Y2ggcHJlY19vcHQgd2l0aFxuICB8IE5vbmUgLT4gTm9fcHJlY2lzaW9uXG4gIHwgU29tZSBuZGVjIC0+IExpdF9wcmVjaXNpb24gbmRlY1xuXG4oKiBUdXJuIGFuIGlnbm9yZWQgcGFyYW0gaW50byBpdHMgZXF1aXZhbGVudCBub3QtaWdub3JlZCBmb3JtYXQgbm9kZS4gKilcbigqIFVzZWQgZm9yIGZvcm1hdCBwcmV0dHktcHJpbnRpbmcgYW5kIFNjYW5mLiAqKVxubGV0IHBhcmFtX2Zvcm1hdF9vZl9pZ25vcmVkX2Zvcm1hdCA6IHR5cGUgYSBiIGMgZCBlIGYgeCB5IC5cbiAgICAoYSwgYiwgYywgZCwgeSwgeCkgaWdub3JlZCAtPiAoeCwgYiwgYywgeSwgZSwgZikgZm10IC0+XG4gICAgICAoYSwgYiwgYywgZCwgZSwgZikgcGFyYW1fZm9ybWF0X2ViYiA9XG5mdW4gaWduIGZtdCAtPiBtYXRjaCBpZ24gd2l0aFxuICB8IElnbm9yZWRfY2hhciAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkIgKENoYXIgZm10KVxuICB8IElnbm9yZWRfY2FtbF9jaGFyIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQiAoQ2FtbF9jaGFyIGZtdClcbiAgfCBJZ25vcmVkX3N0cmluZyBwYWRfb3B0IC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQiAoU3RyaW5nIChwYWRfb2ZfcGFkX29wdCBwYWRfb3B0LCBmbXQpKVxuICB8IElnbm9yZWRfY2FtbF9zdHJpbmcgcGFkX29wdCAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkIgKENhbWxfc3RyaW5nIChwYWRfb2ZfcGFkX29wdCBwYWRfb3B0LCBmbXQpKVxuICB8IElnbm9yZWRfaW50IChpY29udiwgcGFkX29wdCkgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChJbnQgKGljb252LCBwYWRfb2ZfcGFkX29wdCBwYWRfb3B0LCBOb19wcmVjaXNpb24sIGZtdCkpXG4gIHwgSWdub3JlZF9pbnQzMiAoaWNvbnYsIHBhZF9vcHQpIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQlxuICAgICAgKEludDMyIChpY29udiwgcGFkX29mX3BhZF9vcHQgcGFkX29wdCwgTm9fcHJlY2lzaW9uLCBmbXQpKVxuICB8IElnbm9yZWRfbmF0aXZlaW50IChpY29udiwgcGFkX29wdCkgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCXG4gICAgICAoTmF0aXZlaW50IChpY29udiwgcGFkX29mX3BhZF9vcHQgcGFkX29wdCwgTm9fcHJlY2lzaW9uLCBmbXQpKVxuICB8IElnbm9yZWRfaW50NjQgKGljb252LCBwYWRfb3B0KSAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkJcbiAgICAgIChJbnQ2NCAoaWNvbnYsIHBhZF9vZl9wYWRfb3B0IHBhZF9vcHQsIE5vX3ByZWNpc2lvbiwgZm10KSlcbiAgfCBJZ25vcmVkX2Zsb2F0IChwYWRfb3B0LCBwcmVjX29wdCkgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCXG4gICAgICAoRmxvYXQgKChGbG9hdF9mbGFnXywgRmxvYXRfZiksXG4gICAgICAgICAgICAgIHBhZF9vZl9wYWRfb3B0IHBhZF9vcHQsIHByZWNfb2ZfcHJlY19vcHQgcHJlY19vcHQsIGZtdCkpXG4gIHwgSWdub3JlZF9ib29sIHBhZF9vcHQgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChCb29sIChwYWRfb2ZfcGFkX29wdCBwYWRfb3B0LCBmbXQpKVxuICB8IElnbm9yZWRfZm9ybWF0X2FyZyAocGFkX29wdCwgZm10dHkpIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQiAoRm9ybWF0X2FyZyAocGFkX29wdCwgZm10dHksIGZtdCkpXG4gIHwgSWdub3JlZF9mb3JtYXRfc3Vic3QgKHBhZF9vcHQsIGZtdHR5KSAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkJcbiAgICAgIChGb3JtYXRfc3Vic3QgKHBhZF9vcHQsIGZtdHR5LCBmbXQpKVxuICB8IElnbm9yZWRfcmVhZGVyIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQiAoUmVhZGVyIGZtdClcbiAgfCBJZ25vcmVkX3NjYW5fY2hhcl9zZXQgKHdpZHRoX29wdCwgY2hhcl9zZXQpIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQiAoU2Nhbl9jaGFyX3NldCAod2lkdGhfb3B0LCBjaGFyX3NldCwgZm10KSlcbiAgfCBJZ25vcmVkX3NjYW5fZ2V0X2NvdW50ZXIgY291bnRlciAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkIgKFNjYW5fZ2V0X2NvdW50ZXIgKGNvdW50ZXIsIGZtdCkpXG4gIHwgSWdub3JlZF9zY2FuX25leHRfY2hhciAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkIgKFNjYW5fbmV4dF9jaGFyIGZtdClcblxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogVHlwZXMgKilcblxudHlwZSAoJ2IsICdjKSBhY2NfZm9ybWF0dGluZ19nZW4gPVxuICB8IEFjY19vcGVuX3RhZyBvZiAoJ2IsICdjKSBhY2NcbiAgfCBBY2Nfb3Blbl9ib3ggb2YgKCdiLCAnYykgYWNjXG5cbigqIFJldmVyc2VkIGxpc3Qgb2YgcHJpbnRpbmcgYXRvbXMuICopXG4oKiBVc2VkIHRvIGFjY3VtdWxhdGUgcHJpbnRmIGFyZ3VtZW50cy4gKilcbmFuZCAoJ2IsICdjKSBhY2MgPVxuICB8IEFjY19mb3JtYXR0aW5nX2xpdCBvZiAoJ2IsICdjKSBhY2MgKiBmb3JtYXR0aW5nX2xpdFxuICAgICAgKCogU3BlY2lhbCBmbXR0aW5nIChib3gpICopXG4gIHwgQWNjX2Zvcm1hdHRpbmdfZ2VuIG9mICgnYiwgJ2MpIGFjYyAqICgnYiwgJ2MpIGFjY19mb3JtYXR0aW5nX2dlblxuICAgICAgKCogU3BlY2lhbCBmbXR0aW5nIChib3gpICopXG4gIHwgQWNjX3N0cmluZ19saXRlcmFsIG9mICgnYiwgJ2MpIGFjYyAqIHN0cmluZyAgICAgKCogTGl0ZXJhbCBzdHJpbmcgKilcbiAgfCBBY2NfY2hhcl9saXRlcmFsICAgb2YgKCdiLCAnYykgYWNjICogY2hhciAgICAgICAoKiBMaXRlcmFsIGNoYXIgKilcbiAgfCBBY2NfZGF0YV9zdHJpbmcgICAgb2YgKCdiLCAnYykgYWNjICogc3RyaW5nICAgICAoKiBHZW5lcmF0ZWQgc3RyaW5nICopXG4gIHwgQWNjX2RhdGFfY2hhciAgICAgIG9mICgnYiwgJ2MpIGFjYyAqIGNoYXIgICAgICAgKCogR2VuZXJhdGVkIGNoYXIgKilcbiAgfCBBY2NfZGVsYXkgICAgICAgICAgb2YgKCdiLCAnYykgYWNjICogKCdiIC0+ICdjKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogRGVsYXllZCBwcmludGluZyAoJWEsICV0KSAqKVxuICB8IEFjY19mbHVzaCAgICAgICAgICBvZiAoJ2IsICdjKSBhY2MgICAgICAgICAgICAgICgqIEZsdXNoICopXG4gIHwgQWNjX2ludmFsaWRfYXJnICAgIG9mICgnYiwgJ2MpIGFjYyAqIHN0cmluZ1xuICAgICAgKCogUmFpc2UgSW52YWxpZF9hcmd1bWVudCBtc2cgKilcbiAgfCBFbmRfb2ZfYWNjXG5cbigqIExpc3Qgb2YgaGV0ZXJvZ2VuZW91cyB2YWx1ZXMuICopXG4oKiBVc2VkIHRvIGFjY3VtdWxhdGUgc2NhbmYgY2FsbGJhY2sgYXJndW1lbnRzLiAqKVxudHlwZSAoJ2EsICdiKSBoZXRlcl9saXN0ID1cbiAgfCBDb25zIDogJ2MgKiAoJ2EsICdiKSBoZXRlcl9saXN0IC0+ICgnYyAtPiAnYSwgJ2IpIGhldGVyX2xpc3RcbiAgfCBOaWwgOiAoJ2IsICdiKSBoZXRlcl9saXN0XG5cbigqIEV4aXN0ZW50aWFsIEJsYWNrIEJveGVzLiAqKVxuKCogVXNlZCB0byBhYnN0cmFjdCBzb21lIGV4aXN0ZW50aWFsIHR5cGUgcGFyYW1ldGVycy4gKilcblxuKCogR0FEVCB0eXBlIGFzc29jaWF0aW5nIGEgcGFkZGluZyBhbmQgYW4gZm10dHkuICopXG4oKiBTZWUgdGhlIHR5cGVfcGFkZGluZyBmdW5jdGlvbi4gKilcbnR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIHBhZGRpbmdfZm10dHlfZWJiID0gUGFkZGluZ19mbXR0eV9FQkIgOlxuICAgICAoJ3gsICd5KSBwYWRkaW5nICogKCd5LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdHR5IC0+XG4gICAgICgneCwgJ2IsICdjLCAnZCwgJ2UsICdmKSBwYWRkaW5nX2ZtdHR5X2ViYlxuXG4oKiBHQURUIHR5cGUgYXNzb2NpYXRpbmcgYSBwYWRkaW5nLCBhIHByZWNpc2lvbiBhbmQgYW4gZm10dHkuICopXG4oKiBTZWUgdGhlIHR5cGVfcGFkcHJlYyBmdW5jdGlvbi4gKilcbnR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIHBhZHByZWNfZm10dHlfZWJiID0gUGFkcHJlY19mbXR0eV9FQkIgOlxuICAgICAoJ3gsICd5KSBwYWRkaW5nICogKCd5LCAneikgcHJlY2lzaW9uICogKCd6LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdHR5IC0+XG4gICAgICgneCwgJ2IsICdjLCAnZCwgJ2UsICdmKSBwYWRwcmVjX2ZtdHR5X2ViYlxuXG4oKiBHQURUIHR5cGUgYXNzb2NpYXRpbmcgYSBwYWRkaW5nIGFuZCBhbiBmbXQuICopXG4oKiBTZWUgbWFrZV9wYWRkaW5nX2ZtdF9lYmIgYW5kIHBhcnNlX2Zvcm1hdCBmdW5jdGlvbnMuICopXG50eXBlICgnYSwgJ2IsICdjLCAnZSwgJ2YpIHBhZGRpbmdfZm10X2ViYiA9IFBhZGRpbmdfZm10X0VCQiA6XG4gICAgIChfLCAneCAtPiAnYSkgcGFkZGluZyAqXG4gICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgKCd4LCAnYiwgJ2MsICdlLCAnZikgcGFkZGluZ19mbXRfZWJiXG5cbigqIEdBRFQgdHlwZSBhc3NvY2lhdGluZyBhIHByZWNpc2lvbiBhbmQgYW4gZm10LiAqKVxuKCogU2VlIG1ha2VfcHJlY2lzaW9uX2ZtdF9lYmIgYW5kIHBhcnNlX2Zvcm1hdCBmdW5jdGlvbnMuICopXG50eXBlICgnYSwgJ2IsICdjLCAnZSwgJ2YpIHByZWNpc2lvbl9mbXRfZWJiID0gUHJlY2lzaW9uX2ZtdF9FQkIgOlxuICAgICAoXywgJ3ggLT4gJ2EpIHByZWNpc2lvbiAqXG4gICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgKCd4LCAnYiwgJ2MsICdlLCAnZikgcHJlY2lzaW9uX2ZtdF9lYmJcblxuKCogR0FEVCB0eXBlIGFzc29jaWF0aW5nIGEgcGFkZGluZywgYSBwcmVjaXNpb24gYW5kIGFuIGZtdC4gKilcbigqIFNlZSBtYWtlX3BhZHByZWNfZm10X2ViYiBhbmQgcGFyc2VfZm9ybWF0IGZ1bmN0aW9ucy4gKilcbnR5cGUgKCdwLCAnYiwgJ2MsICdlLCAnZikgcGFkcHJlY19mbXRfZWJiID0gUGFkcHJlY19mbXRfRUJCIDpcbiAgICAgKCd4LCAneSkgcGFkZGluZyAqICgneSwgJ3AgLT4gJ2EpIHByZWNpc2lvbiAqXG4gICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgKCdwLCAnYiwgJ2MsICdlLCAnZikgcGFkcHJlY19mbXRfZWJiXG5cbigqIEFic3RyYWN0IHRoZSAnYSBhbmQgJ2QgcGFyYW1ldGVycyBvZiBhbiBmbXQuICopXG4oKiBPdXRwdXQgdHlwZSBvZiB0aGUgZm9ybWF0IHBhcnNpbmcgZnVuY3Rpb24uICopXG50eXBlICgnYiwgJ2MsICdlLCAnZikgZm10X2ViYiA9IEZtdF9FQkIgOlxuICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICgnYiwgJ2MsICdlLCAnZikgZm10X2ViYlxuXG4oKiBHQURUIHR5cGUgYXNzb2NpYXRpbmcgYW4gZm10dHkgYW5kIGFuIGZtdC4gKilcbigqIFNlZSB0aGUgdHlwZV9mb3JtYXRfZ2VuIGZ1bmN0aW9uLiAqKVxudHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10X2ZtdHR5X2ViYiA9IEZtdF9mbXR0eV9FQkIgOlxuICAgICAoJ2EsICdiLCAnYywgJ2QsICd5LCAneCkgZm10ICpcbiAgICAgKCd4LCAnYiwgJ2MsICd5LCAnZSwgJ2YpIGZtdHR5IC0+XG4gICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRfZm10dHlfZWJiXG5cbigqIEdBRFQgdHlwZSBhc3NvY2lhdGluZyBhbiBmbXR0eSBhbmQgYW4gZm10LiAqKVxuKCogU2VlIHRoZSB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBmdW5jdGlvbi4gKilcbnR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdHR5X2ZtdF9lYmIgPSBGbXR0eV9mbXRfRUJCIDpcbiAgICAgKCdhLCAnYiwgJ2MsICdkLCAneSwgJ3gpIGZtdHR5ICpcbiAgICAgKCd4LCAnYiwgJ2MsICd5LCAnZSwgJ2YpIGZtdF9mbXR0eV9lYmIgLT5cbiAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdHR5X2ZtdF9lYmJcblxuKCogQWJzdHJhY3QgYWxsIGZtdHR5IHR5cGUgcGFyYW1ldGVycy4gKilcbigqIFVzZWQgdG8gY29tcGFyZSBmb3JtYXQgdHlwZXMuICopXG50eXBlIGZtdHR5X2ViYiA9IEZtdHR5X0VCQiA6ICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXR0eSAtPiBmbXR0eV9lYmJcblxuKCogQWJzdHJhY3QgYWxsIHBhZGRpbmcgdHlwZSBwYXJhbWV0ZXJzLiAqKVxuKCogVXNlZCB0byBjb21wYXJlIHBhZGRpbmdzLiAqKVxudHlwZSBwYWRkaW5nX2ViYiA9IFBhZGRpbmdfRUJCIDogKCdhLCAnYikgcGFkZGluZyAtPiBwYWRkaW5nX2ViYlxuXG4oKiBBYnN0cmFjdCBhbGwgcHJlY2lzaW9uIHR5cGUgcGFyYW1ldGVycy4gKilcbigqIFVzZWQgdG8gY29tcGFyZSBwcmVjaXNpb25zLiAqKVxudHlwZSBwcmVjaXNpb25fZWJiID0gUHJlY2lzaW9uX0VCQiA6ICgnYSwgJ2IpIHByZWNpc2lvbiAtPiBwcmVjaXNpb25fZWJiXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQ29uc3RhbnRzICopXG5cbigqIERlZmF1bHQgcHJlY2lzaW9uIGZvciBmbG9hdCBwcmludGluZy4gKilcbmxldCBkZWZhdWx0X2Zsb2F0X3ByZWNpc2lvbiBmY29udiA9XG4gIG1hdGNoIHNuZCBmY29udiB3aXRoXG4gIHwgRmxvYXRfZiB8IEZsb2F0X2UgfCBGbG9hdF9FIHwgRmxvYXRfZyB8IEZsb2F0X0cgfCBGbG9hdF9oIHwgRmxvYXRfSFxuICB8IEZsb2F0X0NGIC0+IC02XG4gICgqIEZvciAlaCAlSCBhbmQgJSNGIGZvcm1hdHMsIGEgbmVnYXRpdmUgcHJlY2lzaW9uIG1lYW5zIFwiYXMgbWFueSBkaWdpdHMgYXNcbiAgICAgbmVjZXNzYXJ5XCIuICBGb3IgdGhlIG90aGVyIEZQIGZvcm1hdHMsIHdlIHRha2UgdGhlIGFic29sdXRlIHZhbHVlXG4gICAgIG9mIHRoZSBwcmVjaXNpb24sIGhlbmNlIDYgZGlnaXRzIGJ5IGRlZmF1bHQuICopXG4gIHwgRmxvYXRfRiAtPiAxMlxuICAoKiBEZWZhdWx0IHByZWNpc2lvbiBmb3IgT0NhbWwgZmxvYXQgcHJpbnRpbmcgKCVGKS4gKilcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBFeHRlcm5hbHMgKilcblxuZXh0ZXJuYWwgZm9ybWF0X2Zsb2F0OiBzdHJpbmcgLT4gZmxvYXQgLT4gc3RyaW5nXG4gID0gXCJjYW1sX2Zvcm1hdF9mbG9hdFwiXG5leHRlcm5hbCBmb3JtYXRfaW50OiBzdHJpbmcgLT4gaW50IC0+IHN0cmluZ1xuICA9IFwiY2FtbF9mb3JtYXRfaW50XCJcbmV4dGVybmFsIGZvcm1hdF9pbnQzMjogc3RyaW5nIC0+IGludDMyIC0+IHN0cmluZ1xuICA9IFwiY2FtbF9pbnQzMl9mb3JtYXRcIlxuZXh0ZXJuYWwgZm9ybWF0X25hdGl2ZWludDogc3RyaW5nIC0+IG5hdGl2ZWludCAtPiBzdHJpbmdcbiAgPSBcImNhbWxfbmF0aXZlaW50X2Zvcm1hdFwiXG5leHRlcm5hbCBmb3JtYXRfaW50NjQ6IHN0cmluZyAtPiBpbnQ2NCAtPiBzdHJpbmdcbiAgPSBcImNhbWxfaW50NjRfZm9ybWF0XCJcbmV4dGVybmFsIGhleHN0cmluZ19vZl9mbG9hdDogZmxvYXQgLT4gaW50IC0+IGNoYXIgLT4gc3RyaW5nXG4gID0gXCJjYW1sX2hleHN0cmluZ19vZl9mbG9hdFwiXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAoKiBUb29scyB0byBwcmV0dHktcHJpbnQgZm9ybWF0cyAqKVxuXG4oKiBUeXBlIG9mIGV4dGVuc2libGUgY2hhcmFjdGVyIGJ1ZmZlcnMuICopXG50eXBlIGJ1ZmZlciA9IHtcbiAgbXV0YWJsZSBpbmQgOiBpbnQ7XG4gIG11dGFibGUgYnl0ZXMgOiBieXRlcztcbn1cblxuKCogQ3JlYXRlIGEgZnJlc2ggYnVmZmVyLiAqKVxubGV0IGJ1ZmZlcl9jcmVhdGUgaW5pdF9zaXplID0geyBpbmQgPSAwOyBieXRlcyA9IEJ5dGVzLmNyZWF0ZSBpbml0X3NpemUgfVxuXG4oKiBDaGVjayBzaXplIG9mIHRoZSBidWZmZXIgYW5kIGdyb3cgaXQgaWYgbmVlZGVkLiAqKVxubGV0IGJ1ZmZlcl9jaGVja19zaXplIGJ1ZiBvdmVyaGVhZCA9XG4gIGxldCBsZW4gPSBCeXRlcy5sZW5ndGggYnVmLmJ5dGVzIGluXG4gIGxldCBtaW5fbGVuID0gYnVmLmluZCArIG92ZXJoZWFkIGluXG4gIGlmIG1pbl9sZW4gPiBsZW4gdGhlbiAoXG4gICAgbGV0IG5ld19sZW4gPSBtYXggKGxlbiAqIDIpIG1pbl9sZW4gaW5cbiAgICBsZXQgbmV3X3N0ciA9IEJ5dGVzLmNyZWF0ZSBuZXdfbGVuIGluXG4gICAgQnl0ZXMuYmxpdCBidWYuYnl0ZXMgMCBuZXdfc3RyIDAgbGVuO1xuICAgIGJ1Zi5ieXRlcyA8LSBuZXdfc3RyO1xuICApXG5cbigqIEFkZCB0aGUgY2hhcmFjdGVyIGBjJyB0byB0aGUgYnVmZmVyIGBidWYnLiAqKVxubGV0IGJ1ZmZlcl9hZGRfY2hhciBidWYgYyA9XG4gIGJ1ZmZlcl9jaGVja19zaXplIGJ1ZiAxO1xuICBCeXRlcy5zZXQgYnVmLmJ5dGVzIGJ1Zi5pbmQgYztcbiAgYnVmLmluZCA8LSBidWYuaW5kICsgMVxuXG4oKiBBZGQgdGhlIHN0cmluZyBgcycgdG8gdGhlIGJ1ZmZlciBgYnVmJy4gKilcbmxldCBidWZmZXJfYWRkX3N0cmluZyBidWYgcyA9XG4gIGxldCBzdHJfbGVuID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gIGJ1ZmZlcl9jaGVja19zaXplIGJ1ZiBzdHJfbGVuO1xuICBTdHJpbmcuYmxpdCBzIDAgYnVmLmJ5dGVzIGJ1Zi5pbmQgc3RyX2xlbjtcbiAgYnVmLmluZCA8LSBidWYuaW5kICsgc3RyX2xlblxuXG4oKiBHZXQgdGhlIGNvbnRlbnQgb2YgdGhlIGJ1ZmZlci4gKilcbmxldCBidWZmZXJfY29udGVudHMgYnVmID1cbiAgQnl0ZXMuc3ViX3N0cmluZyBidWYuYnl0ZXMgMCBidWYuaW5kXG5cbigqKiopXG5cbigqIENvbnZlcnQgYW4gaW50ZWdlciBjb252ZXJzaW9uIHRvIGNoYXIuICopXG5sZXQgY2hhcl9vZl9pY29udiBpY29udiA9IG1hdGNoIGljb252IHdpdGhcbiAgfCBJbnRfZCB8IEludF9wZCB8IEludF9zZCB8IEludF9DZCAtPiAnZCcgfCBJbnRfaSB8IEludF9waSB8IEludF9zaVxuICB8IEludF9DaSAtPiAnaScgfCBJbnRfeCB8IEludF9DeCAtPiAneCcgfCBJbnRfWCB8IEludF9DWCAtPiAnWCcgfCBJbnRfb1xuICB8IEludF9DbyAtPiAnbycgfCBJbnRfdSB8IEludF9DdSAtPiAndSdcblxuKCogQ29udmVydCBhIGZsb2F0IGNvbnZlcnNpb24gdG8gY2hhci4gKilcbigqIGBjRicgd2lsbCBiZSAnRicgZm9yIGRpc3BsYXlpbmcgZm9ybWF0IGFuZCAnZycgdG8gY2FsbCBsaWJjIHByaW50ZiAqKVxubGV0IGNoYXJfb2ZfZmNvbnYgPyhjRj0nRicpIGZjb252ID0gbWF0Y2ggc25kIGZjb252IHdpdGhcbiAgfCBGbG9hdF9mIC0+ICdmJyB8IEZsb2F0X2UgLT4gJ2UnXG4gIHwgRmxvYXRfRSAtPiAnRScgfCBGbG9hdF9nIC0+ICdnJ1xuICB8IEZsb2F0X0cgLT4gJ0cnIHwgRmxvYXRfRiAtPiBjRlxuICB8IEZsb2F0X2ggLT4gJ2gnIHwgRmxvYXRfSCAtPiAnSCdcbiAgfCBGbG9hdF9DRiAtPiAnRidcblxuXG4oKiBDb252ZXJ0IGEgc2Nhbm5pbmcgY291bnRlciB0byBjaGFyLiAqKVxubGV0IGNoYXJfb2ZfY291bnRlciBjb3VudGVyID0gbWF0Y2ggY291bnRlciB3aXRoXG4gIHwgTGluZV9jb3VudGVyICAtPiAnbCdcbiAgfCBDaGFyX2NvdW50ZXIgIC0+ICduJ1xuICB8IFRva2VuX2NvdW50ZXIgLT4gJ04nXG5cbigqKiopXG5cbigqIFByaW50IGEgY2hhcl9zZXQgaW4gYSBidWZmZXIgd2l0aCB0aGUgT0NhbWwgZm9ybWF0IGxleGljYWwgY29udmVudGlvbi4gKilcbmxldCBicHJpbnRfY2hhcl9zZXQgYnVmIGNoYXJfc2V0ID1cbiAgbGV0IHJlYyBwcmludF9zdGFydCBzZXQgPVxuICAgIGxldCBpc19hbG9uZSBjID1cbiAgICAgIGxldCBiZWZvcmUsIGFmdGVyID0gQ2hhci4oY2hyIChjb2RlIGMgLSAxKSwgY2hyIChjb2RlIGMgKyAxKSkgaW5cbiAgICAgIGlzX2luX2NoYXJfc2V0IHNldCBjXG4gICAgICAmJiBub3QgKGlzX2luX2NoYXJfc2V0IHNldCBiZWZvcmUgJiYgaXNfaW5fY2hhcl9zZXQgc2V0IGFmdGVyKSBpblxuICAgIGlmIGlzX2Fsb25lICddJyB0aGVuIGJ1ZmZlcl9hZGRfY2hhciBidWYgJ10nO1xuICAgIHByaW50X291dCBzZXQgMTtcbiAgICBpZiBpc19hbG9uZSAnLScgdGhlbiBidWZmZXJfYWRkX2NoYXIgYnVmICctJztcbiAgYW5kIHByaW50X291dCBzZXQgaSA9XG4gICAgaWYgaSA8IDI1NiB0aGVuXG4gICAgICBpZiBpc19pbl9jaGFyX3NldCBzZXQgKGNoYXJfb2ZfaW50IGkpIHRoZW4gcHJpbnRfZmlyc3Qgc2V0IGlcbiAgICAgIGVsc2UgcHJpbnRfb3V0IHNldCAoaSArIDEpXG4gIGFuZCBwcmludF9maXJzdCBzZXQgaSA9XG4gICAgbWF0Y2ggY2hhcl9vZl9pbnQgaSB3aXRoXG4gICAgfCAnXFwyNTUnIC0+IHByaW50X2NoYXIgYnVmIDI1NTtcbiAgICB8ICddJyB8ICctJyAtPiBwcmludF9vdXQgc2V0IChpICsgMSk7XG4gICAgfCBfIC0+IHByaW50X3NlY29uZCBzZXQgKGkgKyAxKTtcbiAgYW5kIHByaW50X3NlY29uZCBzZXQgaSA9XG4gICAgaWYgaXNfaW5fY2hhcl9zZXQgc2V0IChjaGFyX29mX2ludCBpKSB0aGVuXG4gICAgICBtYXRjaCBjaGFyX29mX2ludCBpIHdpdGhcbiAgICAgIHwgJ1xcMjU1JyAtPlxuICAgICAgICBwcmludF9jaGFyIGJ1ZiAyNTQ7XG4gICAgICAgIHByaW50X2NoYXIgYnVmIDI1NTtcbiAgICAgIHwgJ10nIHwgJy0nIHdoZW4gbm90IChpc19pbl9jaGFyX3NldCBzZXQgKGNoYXJfb2ZfaW50IChpICsgMSkpKSAtPlxuICAgICAgICBwcmludF9jaGFyIGJ1ZiAoaSAtIDEpO1xuICAgICAgICBwcmludF9vdXQgc2V0IChpICsgMSk7XG4gICAgICB8IF8gd2hlbiBub3QgKGlzX2luX2NoYXJfc2V0IHNldCAoY2hhcl9vZl9pbnQgKGkgKyAxKSkpIC0+XG4gICAgICAgIHByaW50X2NoYXIgYnVmIChpIC0gMSk7XG4gICAgICAgIHByaW50X2NoYXIgYnVmIGk7XG4gICAgICAgIHByaW50X291dCBzZXQgKGkgKyAyKTtcbiAgICAgIHwgXyAtPlxuICAgICAgICBwcmludF9pbiBzZXQgKGkgLSAxKSAoaSArIDIpO1xuICAgIGVsc2UgKFxuICAgICAgcHJpbnRfY2hhciBidWYgKGkgLSAxKTtcbiAgICAgIHByaW50X291dCBzZXQgKGkgKyAxKTtcbiAgICApXG4gIGFuZCBwcmludF9pbiBzZXQgaSBqID1cbiAgICBpZiBqID0gMjU2IHx8IG5vdCAoaXNfaW5fY2hhcl9zZXQgc2V0IChjaGFyX29mX2ludCBqKSkgdGhlbiAoXG4gICAgICBwcmludF9jaGFyIGJ1ZiBpO1xuICAgICAgcHJpbnRfY2hhciBidWYgKGludF9vZl9jaGFyICctJyk7XG4gICAgICBwcmludF9jaGFyIGJ1ZiAoaiAtIDEpO1xuICAgICAgaWYgaiA8IDI1NiB0aGVuIHByaW50X291dCBzZXQgKGogKyAxKTtcbiAgICApIGVsc2VcbiAgICAgIHByaW50X2luIHNldCBpIChqICsgMSk7XG4gIGFuZCBwcmludF9jaGFyIGJ1ZiBpID0gbWF0Y2ggY2hhcl9vZl9pbnQgaSB3aXRoXG4gICAgfCAnJScgLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnO1xuICAgIHwgJ0AnIC0+IGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBidWZmZXJfYWRkX2NoYXIgYnVmICdAJztcbiAgICB8IGMgICAtPiBidWZmZXJfYWRkX2NoYXIgYnVmIGM7XG4gIGluXG4gIGJ1ZmZlcl9hZGRfY2hhciBidWYgJ1snO1xuICBwcmludF9zdGFydCAoXG4gICAgaWYgaXNfaW5fY2hhcl9zZXQgY2hhcl9zZXQgJ1xcMDAwJ1xuICAgIHRoZW4gKCBidWZmZXJfYWRkX2NoYXIgYnVmICdeJzsgcmV2X2NoYXJfc2V0IGNoYXJfc2V0IClcbiAgICBlbHNlIGNoYXJfc2V0XG4gICk7XG4gIGJ1ZmZlcl9hZGRfY2hhciBidWYgJ10nXG5cbigqKiopXG5cbigqIFByaW50IGEgcGFkdHkgaW4gYSBidWZmZXIgd2l0aCB0aGUgZm9ybWF0LWxpa2Ugc3ludGF4LiAqKVxubGV0IGJwcmludF9wYWR0eSBidWYgcGFkdHkgPSBtYXRjaCBwYWR0eSB3aXRoXG4gIHwgTGVmdCAgLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnLSdcbiAgfCBSaWdodCAtPiAoKVxuICB8IFplcm9zIC0+IGJ1ZmZlcl9hZGRfY2hhciBidWYgJzAnXG5cbigqIFByaW50IHRoZSAnXycgb2YgYW4gaWdub3JlZCBmbGFnIGlmIG5lZWRlZC4gKilcbmxldCBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZyA9XG4gIGlmIGlnbl9mbGFnIHRoZW4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnXydcblxuKCoqKilcblxubGV0IGJwcmludF9wYWRfb3B0IGJ1ZiBwYWRfb3B0ID0gbWF0Y2ggcGFkX29wdCB3aXRoXG4gIHwgTm9uZSAtPiAoKVxuICB8IFNvbWUgd2lkdGggLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIChJbnQudG9fc3RyaW5nIHdpZHRoKVxuXG4oKioqKVxuXG4oKiBQcmludCBwYWRkaW5nIGluIGEgYnVmZmVyIHdpdGggdGhlIGZvcm1hdC1saWtlIHN5bnRheC4gKilcbmxldCBicHJpbnRfcGFkZGluZyA6IHR5cGUgYSBiIC4gYnVmZmVyIC0+IChhLCBiKSBwYWRkaW5nIC0+IHVuaXQgPVxuZnVuIGJ1ZiBwYWQgLT4gbWF0Y2ggcGFkIHdpdGhcbiAgfCBOb19wYWRkaW5nIC0+ICgpXG4gIHwgTGl0X3BhZGRpbmcgKHBhZHR5LCBuKSAtPlxuICAgIGJwcmludF9wYWR0eSBidWYgcGFkdHk7XG4gICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIChJbnQudG9fc3RyaW5nIG4pO1xuICB8IEFyZ19wYWRkaW5nIHBhZHR5IC0+XG4gICAgYnByaW50X3BhZHR5IGJ1ZiBwYWR0eTtcbiAgICBidWZmZXJfYWRkX2NoYXIgYnVmICcqJ1xuXG4oKiBQcmludCBwcmVjaXNpb24gaW4gYSBidWZmZXIgd2l0aCB0aGUgZm9ybWF0LWxpa2Ugc3ludGF4LiAqKVxubGV0IGJwcmludF9wcmVjaXNpb24gOiB0eXBlIGEgYiAuIGJ1ZmZlciAtPiAoYSwgYikgcHJlY2lzaW9uIC0+IHVuaXQgPVxuICBmdW4gYnVmIHByZWMgLT4gbWF0Y2ggcHJlYyB3aXRoXG4gIHwgTm9fcHJlY2lzaW9uIC0+ICgpXG4gIHwgTGl0X3ByZWNpc2lvbiBuIC0+XG4gICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnLic7XG4gICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIChJbnQudG9fc3RyaW5nIG4pO1xuICB8IEFyZ19wcmVjaXNpb24gLT5cbiAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIuKlwiXG5cbigqKiopXG5cbigqIFByaW50IHRoZSBvcHRpb25hbCAnKycsICcgJyBvciAnIycgYXNzb2NpYXRlZCB0byBhbiBpbnQgY29udmVyc2lvbi4gKilcbmxldCBicHJpbnRfaWNvbnZfZmxhZyBidWYgaWNvbnYgPSBtYXRjaCBpY29udiB3aXRoXG4gIHwgSW50X3BkIHwgSW50X3BpIC0+IGJ1ZmZlcl9hZGRfY2hhciBidWYgJysnXG4gIHwgSW50X3NkIHwgSW50X3NpIC0+IGJ1ZmZlcl9hZGRfY2hhciBidWYgJyAnXG4gIHwgSW50X0N4IHwgSW50X0NYIHwgSW50X0NvIHwgSW50X0NkIHwgSW50X0NpIHwgSW50X0N1IC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICcjJ1xuICB8IEludF9kIHwgSW50X2kgfCBJbnRfeCB8IEludF9YIHwgSW50X28gfCBJbnRfdSAtPiAoKVxuXG4oKiBQcmludCBhbiBjb21wbGV0ZSBpbnQgZm9ybWF0IGluIGEgYnVmZmVyIChleDogXCIlMy4qZFwiKS4gKilcbmxldCBicHJpbnRfaW50X2ZtdCBidWYgaWduX2ZsYWcgaWNvbnYgcGFkIHByZWMgPVxuICBidWZmZXJfYWRkX2NoYXIgYnVmICclJztcbiAgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gIGJwcmludF9pY29udl9mbGFnIGJ1ZiBpY29udjtcbiAgYnByaW50X3BhZGRpbmcgYnVmIHBhZDtcbiAgYnByaW50X3ByZWNpc2lvbiBidWYgcHJlYztcbiAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAoY2hhcl9vZl9pY29udiBpY29udilcblxuKCogUHJpbnQgYSBjb21wbGV0ZSBpbnQzMiwgbmF0aXZlaW50IG9yIGludDY0IGZvcm1hdCBpbiBhIGJ1ZmZlci4gKilcbmxldCBicHJpbnRfYWx0aW50X2ZtdCBidWYgaWduX2ZsYWcgaWNvbnYgcGFkIHByZWMgYyA9XG4gIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnO1xuICBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgYnByaW50X2ljb252X2ZsYWcgYnVmIGljb252O1xuICBicHJpbnRfcGFkZGluZyBidWYgcGFkO1xuICBicHJpbnRfcHJlY2lzaW9uIGJ1ZiBwcmVjO1xuICBidWZmZXJfYWRkX2NoYXIgYnVmIGM7XG4gIGJ1ZmZlcl9hZGRfY2hhciBidWYgKGNoYXJfb2ZfaWNvbnYgaWNvbnYpXG5cbigqKiopXG5cbigqIFByaW50IHRoZSBvcHRpb25hbCAnKycsICcgJyBhbmQvb3IgJyMnIGFzc29jaWF0ZWQgdG8gYSBmbG9hdCBjb252ZXJzaW9uLiAqKVxubGV0IGJwcmludF9mY29udl9mbGFnIGJ1ZiBmY29udiA9XG4gIGJlZ2luIG1hdGNoIGZzdCBmY29udiB3aXRoXG4gIHwgRmxvYXRfZmxhZ19wIC0+IGJ1ZmZlcl9hZGRfY2hhciBidWYgJysnXG4gIHwgRmxvYXRfZmxhZ19zIC0+IGJ1ZmZlcl9hZGRfY2hhciBidWYgJyAnXG4gIHwgRmxvYXRfZmxhZ18gLT4gKCkgZW5kO1xuICBtYXRjaCBzbmQgZmNvbnYgd2l0aFxuICB8IEZsb2F0X0NGIC0+IGJ1ZmZlcl9hZGRfY2hhciBidWYgJyMnXG4gIHwgRmxvYXRfZiB8IEZsb2F0X2UgfCBGbG9hdF9FIHwgRmxvYXRfZyB8IEZsb2F0X0dcbiAgfCBGbG9hdF9GIHwgRmxvYXRfaCB8IEZsb2F0X0ggLT4gKClcblxuKCogUHJpbnQgYSBjb21wbGV0ZSBmbG9hdCBmb3JtYXQgaW4gYSBidWZmZXIgKGV4OiBcIiUrKi4zZlwiKS4gKilcbmxldCBicHJpbnRfZmxvYXRfZm10IGJ1ZiBpZ25fZmxhZyBmY29udiBwYWQgcHJlYyA9XG4gIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnO1xuICBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgYnByaW50X2Zjb252X2ZsYWcgYnVmIGZjb252O1xuICBicHJpbnRfcGFkZGluZyBidWYgcGFkO1xuICBicHJpbnRfcHJlY2lzaW9uIGJ1ZiBwcmVjO1xuICBidWZmZXJfYWRkX2NoYXIgYnVmIChjaGFyX29mX2Zjb252IGZjb252KVxuXG4oKiBDb21wdXRlIHRoZSBsaXRlcmFsIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIEZvcm1hdHRpbmdfbGl0LiAqKVxuKCogVXNlZCBieSBQcmludGYgYW5kIFNjYW5mIHdoZXJlIGZvcm1hdHRpbmcgaXMgbm90IGludGVycHJldGVkLiAqKVxubGV0IHN0cmluZ19vZl9mb3JtYXR0aW5nX2xpdCBmb3JtYXR0aW5nX2xpdCA9IG1hdGNoIGZvcm1hdHRpbmdfbGl0IHdpdGhcbiAgfCBDbG9zZV9ib3ggICAgICAgICAgICAtPiBcIkBdXCJcbiAgfCBDbG9zZV90YWcgICAgICAgICAgICAtPiBcIkB9XCJcbiAgfCBCcmVhayAoc3RyLCBfLCBfKSAgICAtPiBzdHJcbiAgfCBGRmx1c2ggICAgICAgICAgICAgICAtPiBcIkA/XCJcbiAgfCBGb3JjZV9uZXdsaW5lICAgICAgICAtPiBcIkBcXG5cIlxuICB8IEZsdXNoX25ld2xpbmUgICAgICAgIC0+IFwiQC5cIlxuICB8IE1hZ2ljX3NpemUgKHN0ciwgXykgIC0+IHN0clxuICB8IEVzY2FwZWRfYXQgICAgICAgICAgIC0+IFwiQEBcIlxuICB8IEVzY2FwZWRfcGVyY2VudCAgICAgIC0+IFwiQCVcIlxuICB8IFNjYW5faW5kaWMgYyAtPiBcIkBcIiBeIChTdHJpbmcubWFrZSAxIGMpXG5cbigqKiopXG5cbigqIFByaW50IGEgbGl0ZXJhbCBjaGFyIGluIGEgYnVmZmVyLCBlc2NhcGUgJyUnIGJ5IFwiJSVcIi4gKilcbmxldCBicHJpbnRfY2hhcl9saXRlcmFsIGJ1ZiBjaHIgPSBtYXRjaCBjaHIgd2l0aFxuICB8ICclJyAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlJVwiXG4gIHwgXyAtPiBidWZmZXJfYWRkX2NoYXIgYnVmIGNoclxuXG4oKiBQcmludCBhIGxpdGVyYWwgc3RyaW5nIGluIGEgYnVmZmVyLCBlc2NhcGUgYWxsICclJyBieSBcIiUlXCIuICopXG5sZXQgYnByaW50X3N0cmluZ19saXRlcmFsIGJ1ZiBzdHIgPVxuICBmb3IgaSA9IDAgdG8gU3RyaW5nLmxlbmd0aCBzdHIgLSAxIGRvXG4gICAgYnByaW50X2NoYXJfbGl0ZXJhbCBidWYgc3RyLltpXVxuICBkb25lXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICgqIEZvcm1hdCBwcmV0dHktcHJpbnRpbmcgKilcblxuKCogUHJpbnQgYSBjb21wbGV0ZSBmb3JtYXQgdHlwZSAoYW4gZm10dHkpIGluIGEgYnVmZmVyLiAqKVxubGV0IHJlYyBicHJpbnRfZm10dHkgOiB0eXBlIGEgYiBjIGQgZSBmIGcgaCBpIGogayBsIC5cbiAgICBidWZmZXIgLT4gKGEsIGIsIGMsIGQsIGUsIGYsIGcsIGgsIGksIGosIGssIGwpIGZtdHR5X3JlbCAtPiB1bml0ID1cbmZ1biBidWYgZm10dHkgLT4gbWF0Y2ggZm10dHkgd2l0aFxuICB8IENoYXJfdHkgcmVzdCAgICAgIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiVjXCI7ICBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgU3RyaW5nX3R5IHJlc3QgICAgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJXNcIjsgIGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBJbnRfdHkgcmVzdCAgICAgICAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlaVwiOyAgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IEludDMyX3R5IHJlc3QgICAgIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiVsaVwiOyBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgTmF0aXZlaW50X3R5IHJlc3QgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJW5pXCI7IGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBJbnQ2NF90eSByZXN0ICAgICAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlTGlcIjsgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IEZsb2F0X3R5IHJlc3QgICAgIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiVmXCI7ICBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgQm9vbF90eSByZXN0ICAgICAgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJUJcIjsgIGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBBbHBoYV90eSByZXN0ICAgICAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlYVwiOyAgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IFRoZXRhX3R5IHJlc3QgICAgIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiV0XCI7ICBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgQW55X3R5IHJlc3QgICAgICAgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJT9cIjsgIGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBSZWFkZXJfdHkgcmVzdCAgICAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlclwiOyAgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuXG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgcmVzdCAtPlxuICAgIGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiVfclwiO1xuICAgIGJwcmludF9mbXR0eSBidWYgcmVzdDtcblxuICB8IEZvcm1hdF9hcmdfdHkgKHN1Yl9mbXR0eSwgcmVzdCkgLT5cbiAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIle1wiOyBicHJpbnRfZm10dHkgYnVmIHN1Yl9mbXR0eTtcbiAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlfVwiOyBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgRm9ybWF0X3N1YnN0X3R5IChzdWJfZm10dHksIF8sIHJlc3QpIC0+XG4gICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJShcIjsgYnByaW50X2ZtdHR5IGJ1ZiBzdWJfZm10dHk7XG4gICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJSlcIjsgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuXG4gIHwgRW5kX29mX2ZtdHR5IC0+ICgpXG5cbigqKiopXG5cbmxldCByZWMgaW50X29mX2N1c3RvbV9hcml0eSA6IHR5cGUgYSBiIGMgLlxuICAoYSwgYiwgYykgY3VzdG9tX2FyaXR5IC0+IGludCA9XG4gIGZ1bmN0aW9uXG4gIHwgQ3VzdG9tX3plcm8gLT4gMFxuICB8IEN1c3RvbV9zdWNjIHggLT4gMSArIGludF9vZl9jdXN0b21fYXJpdHkgeFxuXG4oKiBQcmludCBhIGNvbXBsZXRlIGZvcm1hdCBpbiBhIGJ1ZmZlci4gKilcbmxldCBicHJpbnRfZm10IGJ1ZiBmbXQgPVxuICBsZXQgcmVjIGZtdGl0ZXIgOiB0eXBlIGEgYiBjIGQgZSBmIC5cbiAgICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT4gYm9vbCAtPiB1bml0ID1cbiAgZnVuIGZtdCBpZ25fZmxhZyAtPiBtYXRjaCBmbXQgd2l0aFxuICAgIHwgU3RyaW5nIChwYWQsIHJlc3QpIC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBicHJpbnRfcGFkZGluZyBidWYgcGFkOyBidWZmZXJfYWRkX2NoYXIgYnVmICdzJztcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IENhbWxfc3RyaW5nIChwYWQsIHJlc3QpIC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBicHJpbnRfcGFkZGluZyBidWYgcGFkOyBidWZmZXJfYWRkX2NoYXIgYnVmICdTJztcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcblxuICAgIHwgSW50IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgICAgYnByaW50X2ludF9mbXQgYnVmIGlnbl9mbGFnIGljb252IHBhZCBwcmVjO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgSW50MzIgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgICBicHJpbnRfYWx0aW50X2ZtdCBidWYgaWduX2ZsYWcgaWNvbnYgcGFkIHByZWMgJ2wnO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgTmF0aXZlaW50IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgICAgYnByaW50X2FsdGludF9mbXQgYnVmIGlnbl9mbGFnIGljb252IHBhZCBwcmVjICduJztcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IEludDY0IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgICAgYnByaW50X2FsdGludF9mbXQgYnVmIGlnbl9mbGFnIGljb252IHBhZCBwcmVjICdMJztcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IEZsb2F0IChmY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgICAgYnByaW50X2Zsb2F0X2ZtdCBidWYgaWduX2ZsYWcgZmNvbnYgcGFkIHByZWM7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG5cbiAgICB8IENoYXIgcmVzdCAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnYyc7IGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IENhbWxfY2hhciByZXN0IC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICdDJzsgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgQm9vbCAocGFkLCByZXN0KSAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnByaW50X3BhZGRpbmcgYnVmIHBhZDsgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnQic7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBBbHBoYSByZXN0IC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICdhJzsgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgVGhldGEgcmVzdCAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAndCc7IGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IEN1c3RvbSAoYXJpdHksIF8sIHJlc3QpIC0+XG4gICAgICBmb3IgX2kgPSAxIHRvIGludF9vZl9jdXN0b21fYXJpdHkgYXJpdHkgZG9cbiAgICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICc/JztcbiAgICAgIGRvbmU7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBSZWFkZXIgcmVzdCAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAncic7IGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IEZsdXNoIHJlc3QgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiUhXCI7XG4gICAgICBmbXRpdGVyIHJlc3QgaWduX2ZsYWc7XG5cbiAgICB8IFN0cmluZ19saXRlcmFsIChzdHIsIHJlc3QpIC0+XG4gICAgICBicHJpbnRfc3RyaW5nX2xpdGVyYWwgYnVmIHN0cjtcbiAgICAgIGZtdGl0ZXIgcmVzdCBpZ25fZmxhZztcbiAgICB8IENoYXJfbGl0ZXJhbCAoY2hyLCByZXN0KSAtPlxuICAgICAgYnByaW50X2NoYXJfbGl0ZXJhbCBidWYgY2hyO1xuICAgICAgZm10aXRlciByZXN0IGlnbl9mbGFnO1xuXG4gICAgfCBGb3JtYXRfYXJnIChwYWRfb3B0LCBmbXR0eSwgcmVzdCkgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJwcmludF9wYWRfb3B0IGJ1ZiBwYWRfb3B0OyBidWZmZXJfYWRkX2NoYXIgYnVmICd7JztcbiAgICAgIGJwcmludF9mbXR0eSBidWYgZm10dHk7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBidWZmZXJfYWRkX2NoYXIgYnVmICd9JztcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IEZvcm1hdF9zdWJzdCAocGFkX29wdCwgZm10dHksIHJlc3QpIC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBicHJpbnRfcGFkX29wdCBidWYgcGFkX29wdDsgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnKCc7XG4gICAgICBicHJpbnRfZm10dHkgYnVmIGZtdHR5OyBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnKSc7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG5cbiAgICB8IFNjYW5fY2hhcl9zZXQgKHdpZHRoX29wdCwgY2hhcl9zZXQsIHJlc3QpIC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBicHJpbnRfcGFkX29wdCBidWYgd2lkdGhfb3B0OyBicHJpbnRfY2hhcl9zZXQgYnVmIGNoYXJfc2V0O1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgU2Nhbl9nZXRfY291bnRlciAoY291bnRlciwgcmVzdCkgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgKGNoYXJfb2ZfY291bnRlciBjb3VudGVyKTtcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IFNjYW5fbmV4dF9jaGFyIHJlc3QgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJwcmludF9zdHJpbmdfbGl0ZXJhbCBidWYgXCIwY1wiOyBmbXRpdGVyIHJlc3QgZmFsc2U7XG5cbiAgICB8IElnbm9yZWRfcGFyYW0gKGlnbiwgcmVzdCkgLT5cbiAgICAgIGxldCBQYXJhbV9mb3JtYXRfRUJCIGZtdCcgPSBwYXJhbV9mb3JtYXRfb2ZfaWdub3JlZF9mb3JtYXQgaWduIHJlc3QgaW5cbiAgICAgIGZtdGl0ZXIgZm10JyB0cnVlO1xuXG4gICAgfCBGb3JtYXR0aW5nX2xpdCAoZm10aW5nX2xpdCwgcmVzdCkgLT5cbiAgICAgIGJwcmludF9zdHJpbmdfbGl0ZXJhbCBidWYgKHN0cmluZ19vZl9mb3JtYXR0aW5nX2xpdCBmbXRpbmdfbGl0KTtcbiAgICAgIGZtdGl0ZXIgcmVzdCBpZ25fZmxhZztcbiAgICB8IEZvcm1hdHRpbmdfZ2VuIChmbXRpbmdfZ2VuLCByZXN0KSAtPlxuICAgICAgYmVnaW4gbWF0Y2ggZm10aW5nX2dlbiB3aXRoXG4gICAgICB8IE9wZW5fdGFnIChGb3JtYXQgKF8sIHN0cikpIC0+XG4gICAgICAgIGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIkB7XCI7IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBzdHJcbiAgICAgIHwgT3Blbl9ib3ggKEZvcm1hdCAoXywgc3RyKSkgLT5cbiAgICAgICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiQFtcIjsgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIHN0clxuICAgICAgZW5kO1xuICAgICAgZm10aXRlciByZXN0IGlnbl9mbGFnO1xuXG4gICAgfCBFbmRfb2ZfZm9ybWF0IC0+ICgpXG5cbiAgaW4gZm10aXRlciBmbXQgZmFsc2VcblxuKCoqKilcblxuKCogQ29udmVydCBhIGZvcm1hdCB0byBzdHJpbmcuICopXG5sZXQgc3RyaW5nX29mX2ZtdCBmbXQgPVxuICBsZXQgYnVmID0gYnVmZmVyX2NyZWF0ZSAxNiBpblxuICBicHJpbnRfZm10IGJ1ZiBmbXQ7XG4gIGJ1ZmZlcl9jb250ZW50cyBidWZcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKCogVHlwZSBleHRyYWN0aW9uICopXG5cbnR5cGUgKF8sIF8pIGVxID0gUmVmbCA6ICgnYSwgJ2EpIGVxXG5cbigqIEludmFyaWFudDogdGhpcyBmdW5jdGlvbiBpcyB0aGUgaWRlbnRpdHkgb24gdmFsdWVzLlxuXG4gICBJbiBwYXJ0aWN1bGFyLCBpZiAodHkxLCB0eTIpIGhhdmUgZXF1YWwgdmFsdWVzLCB0aGVuXG4gICAodHJhbnMgKHN5bW0gdHkxKSB0eTIpIHJlc3BlY3RzIHRoZSAndHJhbnMnIHByZWNvbmRpdGlvbi4gKilcbmxldCByZWMgc3ltbSA6IHR5cGUgYTEgYjEgYzEgZDEgZTEgZjEgYTIgYjIgYzIgZDIgZTIgZjIgLlxuICAgKGExLCBiMSwgYzEsIGQxLCBlMSwgZjEsXG4gICAgYTIsIGIyLCBjMiwgZDIsIGUyLCBmMikgZm10dHlfcmVsXG4tPiAoYTIsIGIyLCBjMiwgZDIsIGUyLCBmMixcbiAgICBhMSwgYjEsIGMxLCBkMSwgZTEsIGYxKSBmbXR0eV9yZWxcbj0gZnVuY3Rpb25cbiAgfCBDaGFyX3R5IHJlc3QgLT4gQ2hhcl90eSAoc3ltbSByZXN0KVxuICB8IEludF90eSByZXN0IC0+IEludF90eSAoc3ltbSByZXN0KVxuICB8IEludDMyX3R5IHJlc3QgLT4gSW50MzJfdHkgKHN5bW0gcmVzdClcbiAgfCBJbnQ2NF90eSByZXN0IC0+IEludDY0X3R5IChzeW1tIHJlc3QpXG4gIHwgTmF0aXZlaW50X3R5IHJlc3QgLT4gTmF0aXZlaW50X3R5IChzeW1tIHJlc3QpXG4gIHwgRmxvYXRfdHkgcmVzdCAtPiBGbG9hdF90eSAoc3ltbSByZXN0KVxuICB8IEJvb2xfdHkgcmVzdCAtPiBCb29sX3R5IChzeW1tIHJlc3QpXG4gIHwgU3RyaW5nX3R5IHJlc3QgLT4gU3RyaW5nX3R5IChzeW1tIHJlc3QpXG4gIHwgVGhldGFfdHkgcmVzdCAtPiBUaGV0YV90eSAoc3ltbSByZXN0KVxuICB8IEFscGhhX3R5IHJlc3QgLT4gQWxwaGFfdHkgKHN5bW0gcmVzdClcbiAgfCBBbnlfdHkgcmVzdCAtPiBBbnlfdHkgKHN5bW0gcmVzdClcbiAgfCBSZWFkZXJfdHkgcmVzdCAtPiBSZWFkZXJfdHkgKHN5bW0gcmVzdClcbiAgfCBJZ25vcmVkX3JlYWRlcl90eSByZXN0IC0+IElnbm9yZWRfcmVhZGVyX3R5IChzeW1tIHJlc3QpXG4gIHwgRm9ybWF0X2FyZ190eSAodHksIHJlc3QpIC0+XG4gICAgRm9ybWF0X2FyZ190eSAodHksIHN5bW0gcmVzdClcbiAgfCBGb3JtYXRfc3Vic3RfdHkgKHR5MSwgdHkyLCByZXN0KSAtPlxuICAgIEZvcm1hdF9zdWJzdF90eSAodHkyLCB0eTEsIHN5bW0gcmVzdClcbiAgfCBFbmRfb2ZfZm10dHkgLT4gRW5kX29mX2ZtdHR5XG5cbmxldCByZWMgZm10dHlfcmVsX2RldCA6IHR5cGUgYTEgYiBjIGQxIGUxIGYxIGEyIGQyIGUyIGYyIC5cbiAgKGExLCBiLCBjLCBkMSwgZTEsIGYxLFxuICAgYTIsIGIsIGMsIGQyLCBlMiwgZjIpIGZtdHR5X3JlbCAtPlxuICAgICgoZjEsIGYyKSBlcSAtPiAoYTEsIGEyKSBlcSlcbiAgKiAoKGExLCBhMikgZXEgLT4gKGYxLCBmMikgZXEpXG4gICogKChlMSwgZTIpIGVxIC0+IChkMSwgZDIpIGVxKVxuICAqICgoZDEsIGQyKSBlcSAtPiAoZTEsIGUyKSBlcSlcbj0gZnVuY3Rpb25cbiAgfCBFbmRfb2ZfZm10dHkgLT5cbiAgICAoZnVuIFJlZmwgLT4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gUmVmbClcbiAgfCBDaGFyX3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG4gIHwgU3RyaW5nX3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG4gIHwgSW50X3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG4gIHwgSW50MzJfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcbiAgfCBJbnQ2NF90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuICB8IE5hdGl2ZWludF90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuICB8IEZsb2F0X3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG4gIHwgQm9vbF90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuXG4gIHwgVGhldGFfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcbiAgfCBBbHBoYV90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuICB8IEFueV90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuICB8IFJlYWRlcl90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGVkIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZGUgUmVmbCBpbiBSZWZsKVxuICB8IElnbm9yZWRfcmVhZGVyX3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZWQgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBkZSBSZWZsIGluIFJlZmwpXG4gIHwgRm9ybWF0X2FyZ190eSAoX3R5LCByZXN0KSAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcbiAgfCBGb3JtYXRfc3Vic3RfdHkgKHR5MSwgdHkyLCByZXN0KSAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIGxldCB0eSA9IHRyYW5zIChzeW1tIHR5MSkgdHkyIGluXG4gICAgbGV0IGFnLCBnYSwgZGosIGpkID0gZm10dHlfcmVsX2RldCB0eSBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gbGV0IFJlZmwgPSBhZyBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGdhIFJlZmwgaW4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGVkIFJlZmwgaW4gbGV0IFJlZmwgPSBkaiBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGpkIFJlZmwgaW4gbGV0IFJlZmwgPSBkZSBSZWZsIGluIFJlZmwpXG5cbigqIFByZWNvbmRpdGlvbjogd2UgYXNzdW1lIHRoYXQgdGhlIHR3byBmbXR0eV9yZWwgYXJndW1lbnRzIGhhdmUgZXF1YWxcbiAgIHZhbHVlcyAoYXQgcG9zc2libHkgZGlzdGluY3QgdHlwZXMpOyB0aGlzIGludmFyaWFudCBjb21lcyBmcm9tIHRoZSB3YXlcbiAgIGZtdHR5X3JlbCB3aXRuZXNzZXMgYXJlIHByb2R1Y2VkIGJ5IHRoZSB0eXBlLWNoZWNrZXJcblxuICAgVGhlIGNvZGUgYmVsb3cgdXNlcyAoYXNzZXJ0IGZhbHNlKSB3aGVuIHRoaXMgYXNzdW1wdGlvbiBpcyBicm9rZW4uIFRoZVxuICAgY29kZSBwYXR0ZXJuIGlzIHRoZSBmb2xsb3dpbmc6XG5cbiAgICAgfCBGb28geCwgRm9vIHkgLT5cbiAgICAgICAoKiBjYXNlIHdoZXJlIGluZGVlZCBib3RoIHZhbHVlc1xuICAgICAgICAgIHN0YXJ0IHdpdGggY29uc3RydWN0b3IgRm9vICopXG4gICAgIHwgRm9vIF8sIF9cbiAgICAgfCBfLCBGb28gXyAtPlxuICAgICAgICgqIGRpZmZlcmVudCBoZWFkIGNvbnN0cnVjdG9yczogYnJva2VuIHByZWNvbmRpdGlvbiAqKVxuICAgICAgIGFzc2VydCBmYWxzZVxuKilcbmFuZCB0cmFucyA6IHR5cGVcbiAgYTEgYjEgYzEgZDEgZTEgZjFcbiAgYTIgYjIgYzIgZDIgZTIgZjJcbiAgYTMgYjMgYzMgZDMgZTMgZjNcbi5cbiAgIChhMSwgYjEsIGMxLCBkMSwgZTEsIGYxLFxuICAgIGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIpIGZtdHR5X3JlbFxuLT4gKGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIsXG4gICAgYTMsIGIzLCBjMywgZDMsIGUzLCBmMykgZm10dHlfcmVsXG4tPiAoYTEsIGIxLCBjMSwgZDEsIGUxLCBmMSxcbiAgICBhMywgYjMsIGMzLCBkMywgZTMsIGYzKSBmbXR0eV9yZWxcbj0gZnVuIHR5MSB0eTIgLT4gbWF0Y2ggdHkxLCB0eTIgd2l0aFxuICB8IENoYXJfdHkgcmVzdDEsIENoYXJfdHkgcmVzdDIgLT4gQ2hhcl90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgU3RyaW5nX3R5IHJlc3QxLCBTdHJpbmdfdHkgcmVzdDIgLT4gU3RyaW5nX3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBCb29sX3R5IHJlc3QxLCBCb29sX3R5IHJlc3QyIC0+IEJvb2xfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IEludF90eSByZXN0MSwgSW50X3R5IHJlc3QyIC0+IEludF90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgSW50MzJfdHkgcmVzdDEsIEludDMyX3R5IHJlc3QyIC0+IEludDMyX3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBJbnQ2NF90eSByZXN0MSwgSW50NjRfdHkgcmVzdDIgLT4gSW50NjRfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IE5hdGl2ZWludF90eSByZXN0MSwgTmF0aXZlaW50X3R5IHJlc3QyIC0+IE5hdGl2ZWludF90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgRmxvYXRfdHkgcmVzdDEsIEZsb2F0X3R5IHJlc3QyIC0+IEZsb2F0X3R5ICh0cmFucyByZXN0MSByZXN0MilcblxuICB8IEFscGhhX3R5IHJlc3QxLCBBbHBoYV90eSByZXN0MiAtPiBBbHBoYV90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgQWxwaGFfdHkgXywgXyAtPiBhc3NlcnQgZmFsc2VcbiAgfCBfLCBBbHBoYV90eSBfIC0+IGFzc2VydCBmYWxzZVxuXG4gIHwgVGhldGFfdHkgcmVzdDEsIFRoZXRhX3R5IHJlc3QyIC0+IFRoZXRhX3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBUaGV0YV90eSBfLCBfIC0+IGFzc2VydCBmYWxzZVxuICB8IF8sIFRoZXRhX3R5IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiAgfCBBbnlfdHkgcmVzdDEsIEFueV90eSByZXN0MiAtPiBBbnlfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IEFueV90eSBfLCBfIC0+IGFzc2VydCBmYWxzZVxuICB8IF8sIEFueV90eSBfIC0+IGFzc2VydCBmYWxzZVxuXG4gIHwgUmVhZGVyX3R5IHJlc3QxLCBSZWFkZXJfdHkgcmVzdDIgLT4gUmVhZGVyX3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBSZWFkZXJfdHkgXywgXyAtPiBhc3NlcnQgZmFsc2VcbiAgfCBfLCBSZWFkZXJfdHkgXyAtPiBhc3NlcnQgZmFsc2VcblxuICB8IElnbm9yZWRfcmVhZGVyX3R5IHJlc3QxLCBJZ25vcmVkX3JlYWRlcl90eSByZXN0MiAtPlxuICAgIElnbm9yZWRfcmVhZGVyX3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBJZ25vcmVkX3JlYWRlcl90eSBfLCBfIC0+IGFzc2VydCBmYWxzZVxuICB8IF8sIElnbm9yZWRfcmVhZGVyX3R5IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiAgfCBGb3JtYXRfYXJnX3R5ICh0eTEsIHJlc3QxKSwgRm9ybWF0X2FyZ190eSAodHkyLCByZXN0MikgLT5cbiAgICBGb3JtYXRfYXJnX3R5ICh0cmFucyB0eTEgdHkyLCB0cmFucyByZXN0MSByZXN0MilcbiAgfCBGb3JtYXRfYXJnX3R5IF8sIF8gLT4gYXNzZXJ0IGZhbHNlXG4gIHwgXywgRm9ybWF0X2FyZ190eSBfIC0+IGFzc2VydCBmYWxzZVxuXG4gIHwgRm9ybWF0X3N1YnN0X3R5ICh0eTExLCB0eTEyLCByZXN0MSksXG4gICAgRm9ybWF0X3N1YnN0X3R5ICh0eTIxLCB0eTIyLCByZXN0MikgLT5cbiAgICBsZXQgdHkgPSB0cmFucyAoc3ltbSB0eTEyKSB0eTIxIGluXG4gICAgbGV0IF8sIGYyLCBfLCBmNCA9IGZtdHR5X3JlbF9kZXQgdHkgaW5cbiAgICBsZXQgUmVmbCA9IGYyIFJlZmwgaW5cbiAgICBsZXQgUmVmbCA9IGY0IFJlZmwgaW5cbiAgICBGb3JtYXRfc3Vic3RfdHkgKHR5MTEsIHR5MjIsIHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IEZvcm1hdF9zdWJzdF90eSBfLCBfIC0+IGFzc2VydCBmYWxzZVxuICB8IF8sIEZvcm1hdF9zdWJzdF90eSBfIC0+IGFzc2VydCBmYWxzZVxuXG4gIHwgRW5kX29mX2ZtdHR5LCBFbmRfb2ZfZm10dHkgLT4gRW5kX29mX2ZtdHR5XG4gIHwgRW5kX29mX2ZtdHR5LCBfIC0+IGFzc2VydCBmYWxzZVxuICB8IF8sIEVuZF9vZl9mbXR0eSAtPiBhc3NlcnQgZmFsc2VcblxubGV0IHJlYyBmbXR0eV9vZl9mb3JtYXR0aW5nX2dlbiA6IHR5cGUgYSBiIGMgZCBlIGYgLlxuICAoYSwgYiwgYywgZCwgZSwgZikgZm9ybWF0dGluZ19nZW4gLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10dHkgPVxuZnVuIGZvcm1hdHRpbmdfZ2VuIC0+IG1hdGNoIGZvcm1hdHRpbmdfZ2VuIHdpdGhcbiAgfCBPcGVuX3RhZyAoRm9ybWF0IChmbXQsIF8pKSAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgT3Blbl9ib3ggKEZvcm1hdCAoZm10LCBfKSkgLT4gZm10dHlfb2ZfZm10IGZtdFxuXG4oKiBFeHRyYWN0IHRoZSB0eXBlIHJlcHJlc2VudGF0aW9uIChhbiBmbXR0eSkgb2YgYSBmb3JtYXQuICopXG5hbmQgZm10dHlfb2ZfZm10IDogdHlwZSBhIGIgYyBkIGUgZiAuXG4gIChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT4gKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5ID1cbmZ1biBmbXR0eSAtPiBtYXRjaCBmbXR0eSB3aXRoXG4gIHwgU3RyaW5nIChwYWQsIHJlc3QpIC0+XG4gICAgZm10dHlfb2ZfcGFkZGluZ19mbXR0eSBwYWQgKFN0cmluZ190eSAoZm10dHlfb2ZfZm10IHJlc3QpKVxuICB8IENhbWxfc3RyaW5nIChwYWQsIHJlc3QpIC0+XG4gICAgZm10dHlfb2ZfcGFkZGluZ19mbXR0eSBwYWQgKFN0cmluZ190eSAoZm10dHlfb2ZfZm10IHJlc3QpKVxuXG4gIHwgSW50IChfLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbGV0IHR5X3Jlc3QgPSBmbXR0eV9vZl9mbXQgcmVzdCBpblxuICAgIGxldCBwcmVjX3R5ID0gZm10dHlfb2ZfcHJlY2lzaW9uX2ZtdHR5IHByZWMgKEludF90eSB0eV9yZXN0KSBpblxuICAgIGZtdHR5X29mX3BhZGRpbmdfZm10dHkgcGFkIHByZWNfdHlcbiAgfCBJbnQzMiAoXywgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIGxldCB0eV9yZXN0ID0gZm10dHlfb2ZfZm10IHJlc3QgaW5cbiAgICBsZXQgcHJlY190eSA9IGZtdHR5X29mX3ByZWNpc2lvbl9mbXR0eSBwcmVjIChJbnQzMl90eSB0eV9yZXN0KSBpblxuICAgIGZtdHR5X29mX3BhZGRpbmdfZm10dHkgcGFkIHByZWNfdHlcbiAgfCBOYXRpdmVpbnQgKF8sIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBsZXQgdHlfcmVzdCA9IGZtdHR5X29mX2ZtdCByZXN0IGluXG4gICAgbGV0IHByZWNfdHkgPSBmbXR0eV9vZl9wcmVjaXNpb25fZm10dHkgcHJlYyAoTmF0aXZlaW50X3R5IHR5X3Jlc3QpIGluXG4gICAgZm10dHlfb2ZfcGFkZGluZ19mbXR0eSBwYWQgcHJlY190eVxuICB8IEludDY0IChfLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbGV0IHR5X3Jlc3QgPSBmbXR0eV9vZl9mbXQgcmVzdCBpblxuICAgIGxldCBwcmVjX3R5ID0gZm10dHlfb2ZfcHJlY2lzaW9uX2ZtdHR5IHByZWMgKEludDY0X3R5IHR5X3Jlc3QpIGluXG4gICAgZm10dHlfb2ZfcGFkZGluZ19mbXR0eSBwYWQgcHJlY190eVxuICB8IEZsb2F0IChfLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbGV0IHR5X3Jlc3QgPSBmbXR0eV9vZl9mbXQgcmVzdCBpblxuICAgIGxldCBwcmVjX3R5ID0gZm10dHlfb2ZfcHJlY2lzaW9uX2ZtdHR5IHByZWMgKEZsb2F0X3R5IHR5X3Jlc3QpIGluXG4gICAgZm10dHlfb2ZfcGFkZGluZ19mbXR0eSBwYWQgcHJlY190eVxuXG4gIHwgQ2hhciByZXN0ICAgICAgICAgICAgICAgICAgLT4gQ2hhcl90eSAoZm10dHlfb2ZfZm10IHJlc3QpXG4gIHwgQ2FtbF9jaGFyIHJlc3QgICAgICAgICAgICAgLT4gQ2hhcl90eSAoZm10dHlfb2ZfZm10IHJlc3QpXG4gIHwgQm9vbCAocGFkLCByZXN0KSAgICAgICAgICAgLT5cbiAgICAgIGZtdHR5X29mX3BhZGRpbmdfZm10dHkgcGFkIChCb29sX3R5IChmbXR0eV9vZl9mbXQgcmVzdCkpXG4gIHwgQWxwaGEgcmVzdCAgICAgICAgICAgICAgICAgLT4gQWxwaGFfdHkgKGZtdHR5X29mX2ZtdCByZXN0KVxuICB8IFRoZXRhIHJlc3QgICAgICAgICAgICAgICAgIC0+IFRoZXRhX3R5IChmbXR0eV9vZl9mbXQgcmVzdClcbiAgfCBDdXN0b20gKGFyaXR5LCBfLCByZXN0KSAgICAtPiBmbXR0eV9vZl9jdXN0b20gYXJpdHkgKGZtdHR5X29mX2ZtdCByZXN0KVxuICB8IFJlYWRlciByZXN0ICAgICAgICAgICAgICAgIC0+IFJlYWRlcl90eSAoZm10dHlfb2ZfZm10IHJlc3QpXG5cbiAgfCBGb3JtYXRfYXJnIChfLCB0eSwgcmVzdCkgLT5cbiAgICBGb3JtYXRfYXJnX3R5ICh0eSwgZm10dHlfb2ZfZm10IHJlc3QpXG4gIHwgRm9ybWF0X3N1YnN0IChfLCB0eSwgcmVzdCkgLT5cbiAgICBGb3JtYXRfc3Vic3RfdHkgKHR5LCB0eSwgZm10dHlfb2ZfZm10IHJlc3QpXG5cbiAgfCBGbHVzaCByZXN0ICAgICAgICAgICAgICAgICAtPiBmbXR0eV9vZl9mbXQgcmVzdFxuICB8IFN0cmluZ19saXRlcmFsIChfLCByZXN0KSAgIC0+IGZtdHR5X29mX2ZtdCByZXN0XG4gIHwgQ2hhcl9saXRlcmFsIChfLCByZXN0KSAgICAgLT4gZm10dHlfb2ZfZm10IHJlc3RcblxuICB8IFNjYW5fY2hhcl9zZXQgKF8sIF8sIHJlc3QpIC0+IFN0cmluZ190eSAoZm10dHlfb2ZfZm10IHJlc3QpXG4gIHwgU2Nhbl9nZXRfY291bnRlciAoXywgcmVzdCkgLT4gSW50X3R5IChmbXR0eV9vZl9mbXQgcmVzdClcbiAgfCBTY2FuX25leHRfY2hhciByZXN0ICAgICAgICAtPiBDaGFyX3R5IChmbXR0eV9vZl9mbXQgcmVzdClcbiAgfCBJZ25vcmVkX3BhcmFtIChpZ24sIHJlc3QpICAtPiBmbXR0eV9vZl9pZ25vcmVkX2Zvcm1hdCBpZ24gcmVzdFxuICB8IEZvcm1hdHRpbmdfbGl0IChfLCByZXN0KSAgIC0+IGZtdHR5X29mX2ZtdCByZXN0XG4gIHwgRm9ybWF0dGluZ19nZW4gKGZtdGluZ19nZW4sIHJlc3QpICAtPlxuICAgIGNvbmNhdF9mbXR0eSAoZm10dHlfb2ZfZm9ybWF0dGluZ19nZW4gZm10aW5nX2dlbikgKGZtdHR5X29mX2ZtdCByZXN0KVxuXG4gIHwgRW5kX29mX2Zvcm1hdCAgICAgICAgICAgICAgLT4gRW5kX29mX2ZtdHR5XG5cbmFuZCBmbXR0eV9vZl9jdXN0b20gOiB0eXBlIHggeSBhIGIgYyBkIGUgZiAuXG4gIChhLCB4LCB5KSBjdXN0b21fYXJpdHkgLT4gKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5IC0+XG4gICh5LCBiLCBjLCBkLCBlLCBmKSBmbXR0eSA9XG5mdW4gYXJpdHkgZm10dHkgLT4gbWF0Y2ggYXJpdHkgd2l0aFxuICB8IEN1c3RvbV96ZXJvIC0+IGZtdHR5XG4gIHwgQ3VzdG9tX3N1Y2MgYXJpdHkgLT4gQW55X3R5IChmbXR0eV9vZl9jdXN0b20gYXJpdHkgZm10dHkpXG5cbigqIEV4dHJhY3QgdGhlIGZtdHR5IG9mIGFuIGlnbm9yZWQgcGFyYW1ldGVyIGZvbGxvd2VkIGJ5IHRoZSByZXN0IG9mXG4gICB0aGUgZm9ybWF0LiAqKVxuYW5kIGZtdHR5X29mX2lnbm9yZWRfZm9ybWF0IDogdHlwZSB4IHkgYSBiIGMgZCBlIGYgLlxuICAgIChhLCBiLCBjLCBkLCB5LCB4KSBpZ25vcmVkIC0+XG4gICAgKHgsIGIsIGMsIHksIGUsIGYpIGZtdCAtPlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSA9XG5mdW4gaWduIGZtdCAtPiBtYXRjaCBpZ24gd2l0aFxuICB8IElnbm9yZWRfY2hhciAgICAgICAgICAgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfY2FtbF9jaGFyICAgICAgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfc3RyaW5nIF8gICAgICAgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfY2FtbF9zdHJpbmcgXyAgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfaW50IChfLCBfKSAgICAgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfaW50MzIgKF8sIF8pICAgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfbmF0aXZlaW50IChfLCBfKSAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfaW50NjQgKF8sIF8pICAgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfZmxvYXQgKF8sIF8pICAgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfYm9vbCBfICAgICAgICAgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfZm9ybWF0X2FyZyBfICAgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfZm9ybWF0X3N1YnN0IChfLCBmbXR0eSkgLT4gY29uY2F0X2ZtdHR5IGZtdHR5IChmbXR0eV9vZl9mbXQgZm10KVxuICB8IElnbm9yZWRfcmVhZGVyICAgICAgICAgICAgICAgICAgLT4gSWdub3JlZF9yZWFkZXJfdHkgKGZtdHR5X29mX2ZtdCBmbXQpXG4gIHwgSWdub3JlZF9zY2FuX2NoYXJfc2V0IF8gICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9zY2FuX2dldF9jb3VudGVyIF8gICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9zY2FuX25leHRfY2hhciAgICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG5cbigqIEFkZCBhbiBJbnRfdHkgbm9kZSBpZiBwYWRkaW5nIGlzIHRha2VuIGFzIGFuIGV4dHJhIGFyZ3VtZW50IChleDogXCIlKnNcIikuICopXG5hbmQgZm10dHlfb2ZfcGFkZGluZ19mbXR0eSA6IHR5cGUgeCBhIGIgYyBkIGUgZiAuXG4gICAgKHgsIGEpIHBhZGRpbmcgLT4gKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5IC0+ICh4LCBiLCBjLCBkLCBlLCBmKSBmbXR0eSA9XG4gIGZ1biBwYWQgZm10dHkgLT4gbWF0Y2ggcGFkIHdpdGhcbiAgICB8IE5vX3BhZGRpbmcgICAgLT4gZm10dHlcbiAgICB8IExpdF9wYWRkaW5nIF8gLT4gZm10dHlcbiAgICB8IEFyZ19wYWRkaW5nIF8gLT4gSW50X3R5IGZtdHR5XG5cbigqIEFkZCBhbiBJbnRfdHkgbm9kZSBpZiBwcmVjaXNpb24gaXMgdGFrZW4gYXMgYW4gZXh0cmEgYXJndW1lbnQgKGV4OiBcIiUuKmZcIikuKilcbmFuZCBmbXR0eV9vZl9wcmVjaXNpb25fZm10dHkgOiB0eXBlIHggYSBiIGMgZCBlIGYgLlxuICAgICh4LCBhKSBwcmVjaXNpb24gLT4gKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5IC0+ICh4LCBiLCBjLCBkLCBlLCBmKSBmbXR0eSA9XG4gIGZ1biBwcmVjIGZtdHR5IC0+IG1hdGNoIHByZWMgd2l0aFxuICAgIHwgTm9fcHJlY2lzaW9uICAgIC0+IGZtdHR5XG4gICAgfCBMaXRfcHJlY2lzaW9uIF8gLT4gZm10dHlcbiAgICB8IEFyZ19wcmVjaXNpb24gICAtPiBJbnRfdHkgZm10dHlcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBGb3JtYXQgdHlwaW5nICopXG5cbigqIEV4Y2VwdGlvbiByYWlzZWQgd2hlbiBhIGZvcm1hdCBkb2VzIG5vdCBtYXRjaCBhIGdpdmVuIGZvcm1hdCB0eXBlLiAqKVxuZXhjZXB0aW9uIFR5cGVfbWlzbWF0Y2hcblxuKCogVHlwZSBhIHBhZGRpbmcuICopXG4oKiBUYWtlIGFuIEludF90eSBmcm9tIHRoZSBmbXR0eSBpZiB0aGUgaW50ZWdlciBzaG91bGQgYmUga2VwdCBhcyBhcmd1bWVudC4gKilcbigqIFJhaXNlIFR5cGVfbWlzbWF0Y2ggaW4gY2FzZSBvZiB0eXBlIG1pc21hdGNoLiAqKVxubGV0IHR5cGVfcGFkZGluZyA6IHR5cGUgYSBiIGMgZCBlIGYgeCB5IC5cbiAgICAoeCwgeSkgcGFkZGluZyAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10dHkgLT5cbiAgICAgIChhLCBiLCBjLCBkLCBlLCBmKSBwYWRkaW5nX2ZtdHR5X2ViYiA9XG5mdW4gcGFkIGZtdHR5IC0+IG1hdGNoIHBhZCwgZm10dHkgd2l0aFxuICB8IE5vX3BhZGRpbmcsIF8gLT4gUGFkZGluZ19mbXR0eV9FQkIgKE5vX3BhZGRpbmcsIGZtdHR5KVxuICB8IExpdF9wYWRkaW5nIChwYWR0eSwgdyksIF8gLT4gUGFkZGluZ19mbXR0eV9FQkIgKExpdF9wYWRkaW5nIChwYWR0eSx3KSxmbXR0eSlcbiAgfCBBcmdfcGFkZGluZyBwYWR0eSwgSW50X3R5IHJlc3QgLT4gUGFkZGluZ19mbXR0eV9FQkIgKEFyZ19wYWRkaW5nIHBhZHR5LHJlc3QpXG4gIHwgXyAtPiByYWlzZSBUeXBlX21pc21hdGNoXG5cbigqIENvbnZlcnQgYSAodXBhZGRpbmcsIHVwcmVjaXNpb24pIHRvIGEgKHBhZGRpbmcsIHByZWNpc2lvbikuICopXG4oKiBUYWtlIG9uZSBvciB0d28gSW50X3R5IGZyb20gdGhlIGZtdHR5IGlmIG5lZWRlZC4gKilcbigqIFJhaXNlIFR5cGVfbWlzbWF0Y2ggaW4gY2FzZSBvZiB0eXBlIG1pc21hdGNoLiAqKVxubGV0IHR5cGVfcGFkcHJlYyA6IHR5cGUgYSBiIGMgZCBlIGYgeCB5IHogLlxuICAoeCwgeSkgcGFkZGluZyAtPiAoeSwgeikgcHJlY2lzaW9uIC0+IChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSAtPlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBwYWRwcmVjX2ZtdHR5X2ViYiA9XG5mdW4gcGFkIHByZWMgZm10dHkgLT4gbWF0Y2ggcHJlYywgdHlwZV9wYWRkaW5nIHBhZCBmbXR0eSB3aXRoXG4gIHwgTm9fcHJlY2lzaW9uLCBQYWRkaW5nX2ZtdHR5X0VCQiAocGFkLCByZXN0KSAtPlxuICAgIFBhZHByZWNfZm10dHlfRUJCIChwYWQsIE5vX3ByZWNpc2lvbiwgcmVzdClcbiAgfCBMaXRfcHJlY2lzaW9uIHAsIFBhZGRpbmdfZm10dHlfRUJCIChwYWQsIHJlc3QpIC0+XG4gICAgUGFkcHJlY19mbXR0eV9FQkIgKHBhZCwgTGl0X3ByZWNpc2lvbiBwLCByZXN0KVxuICB8IEFyZ19wcmVjaXNpb24sIFBhZGRpbmdfZm10dHlfRUJCIChwYWQsIEludF90eSByZXN0KSAtPlxuICAgIFBhZHByZWNfZm10dHlfRUJCIChwYWQsIEFyZ19wcmVjaXNpb24sIHJlc3QpXG4gIHwgXywgUGFkZGluZ19mbXR0eV9FQkIgKF8sIF8pIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcblxuKCogVHlwZSBhIGZvcm1hdCBhY2NvcmRpbmcgdG8gYW4gZm10dHkuICopXG4oKiBJZiB0eXBpbmcgc3VjY2VlZCwgZ2VuZXJhdGUgYSBjb3B5IG9mIHRoZSBmb3JtYXQgd2l0aCB0aGUgc2FtZVxuICAgIHR5cGUgcGFyYW1ldGVycyBhcyB0aGUgZm10dHkuICopXG4oKiBSYWlzZSBbRmFpbHVyZV0gd2l0aCBhbiBlcnJvciBtZXNzYWdlIGluIGNhc2Ugb2YgdHlwZSBtaXNtYXRjaC4gKilcbmxldCByZWMgdHlwZV9mb3JtYXQgOlxuICB0eXBlIGExIGIxIGMxIGQxIGUxIGYxXG4gICAgICAgYTIgYjIgYzIgZDIgZTIgZjIgIC5cbiAgICAgKGExLCBiMSwgYzEsIGQxLCBlMSwgZjEpIGZtdFxuICAtPiAoYTIsIGIyLCBjMiwgZDIsIGUyLCBmMikgZm10dHlcbiAgLT4gKGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIpIGZtdFxuPSBmdW4gZm10IGZtdHR5IC0+IG1hdGNoIHR5cGVfZm9ybWF0X2dlbiBmbXQgZm10dHkgd2l0aFxuICB8IEZtdF9mbXR0eV9FQkIgKGZtdCcsIEVuZF9vZl9mbXR0eSkgLT4gZm10J1xuICB8IF8gLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuXG5hbmQgdHlwZV9mb3JtYXRfZ2VuIDpcbiAgdHlwZSBhMSBiMSBjMSBkMSBlMSBmMVxuICAgICAgIGEyIGIyIGMyIGQyIGUyIGYyICAuXG4gICAgIChhMSwgYjEsIGMxLCBkMSwgZTEsIGYxKSBmbXRcbiAgLT4gKGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIpIGZtdHR5XG4gIC0+IChhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXRfZm10dHlfZWJiXG49IGZ1biBmbXQgZm10dHkgLT4gbWF0Y2ggZm10LCBmbXR0eSB3aXRoXG4gIHwgQ2hhciBmbXRfcmVzdCwgQ2hhcl90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKENoYXIgZm10JywgZm10dHknKVxuICB8IENhbWxfY2hhciBmbXRfcmVzdCwgQ2hhcl90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKENhbWxfY2hhciBmbXQnLCBmbXR0eScpXG4gIHwgU3RyaW5nIChwYWQsIGZtdF9yZXN0KSwgXyAtPiAoXG4gICAgbWF0Y2ggdHlwZV9wYWRkaW5nIHBhZCBmbXR0eSB3aXRoXG4gICAgfCBQYWRkaW5nX2ZtdHR5X0VCQiAocGFkLCBTdHJpbmdfdHkgZm10dHlfcmVzdCkgLT5cbiAgICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICAgIEZtdF9mbXR0eV9FQkIgKFN0cmluZyAocGFkLCBmbXQnKSwgZm10dHknKVxuICAgIHwgUGFkZGluZ19mbXR0eV9FQkIgKF8sIF8pIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcbiAgKVxuICB8IENhbWxfc3RyaW5nIChwYWQsIGZtdF9yZXN0KSwgXyAtPiAoXG4gICAgbWF0Y2ggdHlwZV9wYWRkaW5nIHBhZCBmbXR0eSB3aXRoXG4gICAgfCBQYWRkaW5nX2ZtdHR5X0VCQiAocGFkLCBTdHJpbmdfdHkgZm10dHlfcmVzdCkgLT5cbiAgICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICAgIEZtdF9mbXR0eV9FQkIgKENhbWxfc3RyaW5nIChwYWQsIGZtdCcpLCBmbXR0eScpXG4gICAgfCBQYWRkaW5nX2ZtdHR5X0VCQiAoXywgXykgLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuICApXG4gIHwgSW50IChpY29udiwgcGFkLCBwcmVjLCBmbXRfcmVzdCksIF8gLT4gKFxuICAgIG1hdGNoIHR5cGVfcGFkcHJlYyBwYWQgcHJlYyBmbXR0eSB3aXRoXG4gICAgfCBQYWRwcmVjX2ZtdHR5X0VCQiAocGFkLCBwcmVjLCBJbnRfdHkgZm10dHlfcmVzdCkgLT5cbiAgICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICAgIEZtdF9mbXR0eV9FQkIgKEludCAoaWNvbnYsIHBhZCwgcHJlYywgZm10JyksIGZtdHR5JylcbiAgICB8IFBhZHByZWNfZm10dHlfRUJCIChfLCBfLCBfKSAtPiByYWlzZSBUeXBlX21pc21hdGNoXG4gIClcbiAgfCBJbnQzMiAoaWNvbnYsIHBhZCwgcHJlYywgZm10X3Jlc3QpLCBfIC0+IChcbiAgICBtYXRjaCB0eXBlX3BhZHByZWMgcGFkIHByZWMgZm10dHkgd2l0aFxuICAgIHwgUGFkcHJlY19mbXR0eV9FQkIgKHBhZCwgcHJlYywgSW50MzJfdHkgZm10dHlfcmVzdCkgLT5cbiAgICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICAgIEZtdF9mbXR0eV9FQkIgKEludDMyIChpY29udiwgcGFkLCBwcmVjLCBmbXQnKSwgZm10dHknKVxuICAgIHwgUGFkcHJlY19mbXR0eV9FQkIgKF8sIF8sIF8pIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcbiAgKVxuICB8IE5hdGl2ZWludCAoaWNvbnYsIHBhZCwgcHJlYywgZm10X3Jlc3QpLCBfIC0+IChcbiAgICBtYXRjaCB0eXBlX3BhZHByZWMgcGFkIHByZWMgZm10dHkgd2l0aFxuICAgIHwgUGFkcHJlY19mbXR0eV9FQkIgKHBhZCwgcHJlYywgTmF0aXZlaW50X3R5IGZtdHR5X3Jlc3QpIC0+XG4gICAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgICBGbXRfZm10dHlfRUJCIChOYXRpdmVpbnQgKGljb252LCBwYWQsIHByZWMsIGZtdCcpLCBmbXR0eScpXG4gICAgfCBQYWRwcmVjX2ZtdHR5X0VCQiAoXywgXywgXykgLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuICApXG4gIHwgSW50NjQgKGljb252LCBwYWQsIHByZWMsIGZtdF9yZXN0KSwgXyAtPiAoXG4gICAgbWF0Y2ggdHlwZV9wYWRwcmVjIHBhZCBwcmVjIGZtdHR5IHdpdGhcbiAgICB8IFBhZHByZWNfZm10dHlfRUJCIChwYWQsIHByZWMsIEludDY0X3R5IGZtdHR5X3Jlc3QpIC0+XG4gICAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgICBGbXRfZm10dHlfRUJCIChJbnQ2NCAoaWNvbnYsIHBhZCwgcHJlYywgZm10JyksIGZtdHR5JylcbiAgICB8IFBhZHByZWNfZm10dHlfRUJCIChfLCBfLCBfKSAtPiByYWlzZSBUeXBlX21pc21hdGNoXG4gIClcbiAgfCBGbG9hdCAoZmNvbnYsIHBhZCwgcHJlYywgZm10X3Jlc3QpLCBfIC0+IChcbiAgICBtYXRjaCB0eXBlX3BhZHByZWMgcGFkIHByZWMgZm10dHkgd2l0aFxuICAgIHwgUGFkcHJlY19mbXR0eV9FQkIgKHBhZCwgcHJlYywgRmxvYXRfdHkgZm10dHlfcmVzdCkgLT5cbiAgICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICAgIEZtdF9mbXR0eV9FQkIgKEZsb2F0IChmY29udiwgcGFkLCBwcmVjLCBmbXQnKSwgZm10dHknKVxuICAgIHwgUGFkcHJlY19mbXR0eV9FQkIgKF8sIF8sIF8pIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcbiAgKVxuICB8IEJvb2wgKHBhZCwgZm10X3Jlc3QpLCBfIC0+IChcbiAgICBtYXRjaCB0eXBlX3BhZGRpbmcgcGFkIGZtdHR5IHdpdGhcbiAgICB8IFBhZGRpbmdfZm10dHlfRUJCIChwYWQsIEJvb2xfdHkgZm10dHlfcmVzdCkgLT5cbiAgICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICAgIEZtdF9mbXR0eV9FQkIgKEJvb2wgKHBhZCwgZm10JyksIGZtdHR5JylcbiAgICB8IFBhZGRpbmdfZm10dHlfRUJCIChfLCBfKSAtPiByYWlzZSBUeXBlX21pc21hdGNoXG4gIClcbiAgfCBGbHVzaCBmbXRfcmVzdCwgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChGbHVzaCBmbXQnLCBmbXR0eScpXG5cbiAgfCBTdHJpbmdfbGl0ZXJhbCAoc3RyLCBmbXRfcmVzdCksIGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoU3RyaW5nX2xpdGVyYWwgKHN0ciwgZm10JyksIGZtdHR5JylcbiAgfCBDaGFyX2xpdGVyYWwgKGNociwgZm10X3Jlc3QpLCBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKENoYXJfbGl0ZXJhbCAoY2hyLCBmbXQnKSwgZm10dHknKVxuXG4gIHwgRm9ybWF0X2FyZyAocGFkX29wdCwgc3ViX2ZtdHR5LCBmbXRfcmVzdCksXG4gICAgRm9ybWF0X2FyZ190eSAoc3ViX2ZtdHR5JywgZm10dHlfcmVzdCkgLT5cbiAgICBpZiBGbXR0eV9FQkIgc3ViX2ZtdHR5IDw+IEZtdHR5X0VCQiBzdWJfZm10dHknIHRoZW4gcmFpc2UgVHlwZV9taXNtYXRjaDtcbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoRm9ybWF0X2FyZyAocGFkX29wdCwgc3ViX2ZtdHR5JywgZm10JyksIGZtdHR5JylcbiAgfCBGb3JtYXRfc3Vic3QgKHBhZF9vcHQsIHN1Yl9mbXR0eSwgZm10X3Jlc3QpLFxuICAgIEZvcm1hdF9zdWJzdF90eSAoc3ViX2ZtdHR5MSwgX3N1Yl9mbXR0eTIsIGZtdHR5X3Jlc3QpIC0+XG4gICAgaWYgRm10dHlfRUJCIChlcmFzZV9yZWwgc3ViX2ZtdHR5KSA8PiBGbXR0eV9FQkIgKGVyYXNlX3JlbCBzdWJfZm10dHkxKSB0aGVuXG4gICAgICByYWlzZSBUeXBlX21pc21hdGNoO1xuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID1cbiAgICAgIHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCAoZXJhc2VfcmVsIGZtdHR5X3Jlc3QpXG4gICAgaW5cbiAgICBGbXRfZm10dHlfRUJCIChGb3JtYXRfc3Vic3QgKHBhZF9vcHQsIHN1Yl9mbXR0eTEsIGZtdCcpLCBmbXR0eScpXG4gICgqIFByaW50ZiBhbmQgRm9ybWF0IHNwZWNpZmljIGNvbnN0cnVjdG9yczogKilcbiAgfCBBbHBoYSBmbXRfcmVzdCwgQWxwaGFfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChBbHBoYSBmbXQnLCBmbXR0eScpXG4gIHwgVGhldGEgZm10X3Jlc3QsIFRoZXRhX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoVGhldGEgZm10JywgZm10dHknKVxuXG4gICgqIEZvcm1hdCBzcGVjaWZpYyBjb25zdHJ1Y3RvcnM6ICopXG4gIHwgRm9ybWF0dGluZ19saXQgKGZvcm1hdHRpbmdfbGl0LCBmbXRfcmVzdCksIGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoRm9ybWF0dGluZ19saXQgKGZvcm1hdHRpbmdfbGl0LCBmbXQnKSwgZm10dHknKVxuICB8IEZvcm1hdHRpbmdfZ2VuIChmb3JtYXR0aW5nX2dlbiwgZm10X3Jlc3QpLCBmbXR0eV9yZXN0IC0+XG4gICAgdHlwZV9mb3JtYXR0aW5nX2dlbiBmb3JtYXR0aW5nX2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0XG5cbiAgKCogU2NhbmYgc3BlY2lmaWMgY29uc3RydWN0b3JzOiAqKVxuICB8IFJlYWRlciBmbXRfcmVzdCwgUmVhZGVyX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoUmVhZGVyIGZtdCcsIGZtdHR5JylcbiAgfCBTY2FuX2NoYXJfc2V0ICh3aWR0aF9vcHQsIGNoYXJfc2V0LCBmbXRfcmVzdCksIFN0cmluZ190eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKFNjYW5fY2hhcl9zZXQgKHdpZHRoX29wdCwgY2hhcl9zZXQsIGZtdCcpLCBmbXR0eScpXG4gIHwgU2Nhbl9nZXRfY291bnRlciAoY291bnRlciwgZm10X3Jlc3QpLCBJbnRfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChTY2FuX2dldF9jb3VudGVyIChjb3VudGVyLCBmbXQnKSwgZm10dHknKVxuICB8IElnbm9yZWRfcGFyYW0gKGlnbiwgcmVzdCksIGZtdHR5X3Jlc3QgLT5cbiAgICB0eXBlX2lnbm9yZWRfcGFyYW0gaWduIHJlc3QgZm10dHlfcmVzdFxuXG4gIHwgRW5kX29mX2Zvcm1hdCwgZm10dHlfcmVzdCAtPiBGbXRfZm10dHlfRUJCIChFbmRfb2ZfZm9ybWF0LCBmbXR0eV9yZXN0KVxuXG4gIHwgXyAtPiByYWlzZSBUeXBlX21pc21hdGNoXG5cbmFuZCB0eXBlX2Zvcm1hdHRpbmdfZ2VuIDogdHlwZSBhMSBhMyBiMSBiMyBjMSBjMyBkMSBkMyBlMSBlMiBlMyBmMSBmMiBmMyAuXG4gICAgKGExLCBiMSwgYzEsIGQxLCBlMSwgZjEpIGZvcm1hdHRpbmdfZ2VuIC0+XG4gICAgKGYxLCBiMSwgYzEsIGUxLCBlMiwgZjIpIGZtdCAtPlxuICAgIChhMywgYjMsIGMzLCBkMywgZTMsIGYzKSBmbXR0eSAtPlxuICAgIChhMywgYjMsIGMzLCBkMywgZTMsIGYzKSBmbXRfZm10dHlfZWJiID1cbmZ1biBmb3JtYXR0aW5nX2dlbiBmbXQwIGZtdHR5MCAtPiBtYXRjaCBmb3JtYXR0aW5nX2dlbiB3aXRoXG4gIHwgT3Blbl90YWcgKEZvcm1hdCAoZm10MSwgc3RyKSkgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10MiwgZm10dHkyKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXQxIGZtdHR5MCBpblxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQzLCBmbXR0eTMpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdDAgZm10dHkyIGluXG4gICAgRm10X2ZtdHR5X0VCQiAoRm9ybWF0dGluZ19nZW4gKE9wZW5fdGFnIChGb3JtYXQgKGZtdDIsIHN0cikpLCBmbXQzKSwgZm10dHkzKVxuICB8IE9wZW5fYm94IChGb3JtYXQgKGZtdDEsIHN0cikpIC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdDIsIGZtdHR5MikgPSB0eXBlX2Zvcm1hdF9nZW4gZm10MSBmbXR0eTAgaW5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10MywgZm10dHkzKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXQwIGZtdHR5MiBpblxuICAgIEZtdF9mbXR0eV9FQkIgKEZvcm1hdHRpbmdfZ2VuIChPcGVuX2JveCAoRm9ybWF0IChmbXQyLCBzdHIpKSwgZm10MyksIGZtdHR5MylcblxuKCogVHlwZSBhbiBJZ25vcmVkX3BhcmFtIG5vZGUgYWNjb3JkaW5nIHRvIGFuIGZtdHR5LiAqKVxuYW5kIHR5cGVfaWdub3JlZF9wYXJhbSA6IHR5cGUgcCBxIHggeSB6IHQgdSB2IGEgYiBjIGQgZSBmIC5cbiAgICAoeCwgeSwgeiwgdCwgcSwgcCkgaWdub3JlZCAtPlxuICAgIChwLCB5LCB6LCBxLCB1LCB2KSBmbXQgLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10dHkgLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10X2ZtdHR5X2ViYiA9XG5mdW4gaWduIGZtdCBmbXR0eSAtPiBtYXRjaCBpZ24gd2l0aFxuICB8IElnbm9yZWRfY2hhciAgICAgICAgICAgICAgIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfY2FtbF9jaGFyICAgICAgICAgIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfc3RyaW5nIF8gICAgICAgICAgIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfY2FtbF9zdHJpbmcgXyAgICAgIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfaW50IF8gICAgICAgICAgICAgIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfaW50MzIgXyAgICAgICAgICAgIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfbmF0aXZlaW50IF8gICAgICAgIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfaW50NjQgXyAgICAgICAgICAgIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfZmxvYXQgXyAgICAgICAgICAgIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfYm9vbCBfICAgICAgICAgICAgIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfc2Nhbl9jaGFyX3NldCBfICAgIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfc2Nhbl9nZXRfY291bnRlciBfIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfc2Nhbl9uZXh0X2NoYXIgICAgIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfZm9ybWF0X2FyZyAocGFkX29wdCwgc3ViX2ZtdHR5KSAtPlxuICAgIHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgKElnbm9yZWRfZm9ybWF0X2FyZyAocGFkX29wdCwgc3ViX2ZtdHR5KSkgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9mb3JtYXRfc3Vic3QgKHBhZF9vcHQsIHN1Yl9mbXR0eSkgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5JywgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSkgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5IGZtdCBmbXR0eSBpblxuICAgIEZtdF9mbXR0eV9FQkIgKElnbm9yZWRfcGFyYW0gKElnbm9yZWRfZm9ybWF0X3N1YnN0IChwYWRfb3B0LCBzdWJfZm10dHknKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbXQnKSxcbiAgICAgICAgICAgICAgICAgICBmbXR0eScpXG4gIHwgSWdub3JlZF9yZWFkZXIgLT4gKFxuICAgIG1hdGNoIGZtdHR5IHdpdGhcbiAgICB8IElnbm9yZWRfcmVhZGVyX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdCBmbXR0eV9yZXN0IGluXG4gICAgICBGbXRfZm10dHlfRUJCIChJZ25vcmVkX3BhcmFtIChJZ25vcmVkX3JlYWRlciwgZm10JyksIGZtdHR5JylcbiAgICB8IF8gLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuICApXG5cbmFuZCB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIDogdHlwZSBhMSBhMiBiMSBiMiBjMSBjMiBkMSBkMiBlMSBlMiBmMSBmMiAuXG4gICAgKGEyLCBiMiwgYzIsIGQyLCBkMiwgYTIpIGlnbm9yZWQgLT5cbiAgICAoYTEsIGIxLCBjMSwgZDEsIGUxLCBmMSkgZm10IC0+XG4gICAgKGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIpIGZtdHR5IC0+XG4gICAgKGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIpIGZtdF9mbXR0eV9lYmJcbj0gZnVuIGlnbiBmbXQgZm10dHkgLT5cbiAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10IGZtdHR5IGluXG4gIEZtdF9mbXR0eV9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbiwgZm10JyksIGZtdHR5JylcblxuKCogVHlwaW5nIG9mIHRoZSBjb21wbGV4IGNhc2U6IFwiJV8oLi4uJSlcIi4gKilcbmFuZCB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiA6IHR5cGUgdyB4IHkgeiBwIHMgdCB1IGEgYiBjIGQgZSBmIC5cbiAgICAodywgeCwgeSwgeiwgcywgcCkgZm10dHkgLT5cbiAgICAocCwgeCwgeSwgcywgdCwgdSkgZm10IC0+XG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5IC0+IChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eV9mbXRfZWJiID1cbmZ1biBzdWJfZm10dHkgZm10IGZtdHR5IC0+IG1hdGNoIHN1Yl9mbXR0eSwgZm10dHkgd2l0aFxuICB8IENoYXJfdHkgc3ViX2ZtdHR5X3Jlc3QsIENoYXJfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoQ2hhcl90eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG4gIHwgU3RyaW5nX3R5IHN1Yl9mbXR0eV9yZXN0LCBTdHJpbmdfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoU3RyaW5nX3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcbiAgfCBJbnRfdHkgc3ViX2ZtdHR5X3Jlc3QsIEludF90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChJbnRfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuICB8IEludDMyX3R5IHN1Yl9mbXR0eV9yZXN0LCBJbnQzMl90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChJbnQzMl90eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG4gIHwgTmF0aXZlaW50X3R5IHN1Yl9mbXR0eV9yZXN0LCBOYXRpdmVpbnRfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoTmF0aXZlaW50X3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcbiAgfCBJbnQ2NF90eSBzdWJfZm10dHlfcmVzdCwgSW50NjRfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoSW50NjRfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuICB8IEZsb2F0X3R5IHN1Yl9mbXR0eV9yZXN0LCBGbG9hdF90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChGbG9hdF90eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG4gIHwgQm9vbF90eSBzdWJfZm10dHlfcmVzdCwgQm9vbF90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChCb29sX3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcbiAgfCBBbHBoYV90eSBzdWJfZm10dHlfcmVzdCwgQWxwaGFfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoQWxwaGFfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuICB8IFRoZXRhX3R5IHN1Yl9mbXR0eV9yZXN0LCBUaGV0YV90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChUaGV0YV90eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG4gIHwgUmVhZGVyX3R5IHN1Yl9mbXR0eV9yZXN0LCBSZWFkZXJfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoUmVhZGVyX3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcbiAgfCBJZ25vcmVkX3JlYWRlcl90eSBzdWJfZm10dHlfcmVzdCwgSWdub3JlZF9yZWFkZXJfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoSWdub3JlZF9yZWFkZXJfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuXG4gIHwgRm9ybWF0X2FyZ190eSAoc3ViMl9mbXR0eSwgc3ViX2ZtdHR5X3Jlc3QpLFxuICAgIEZvcm1hdF9hcmdfdHkgKHN1YjJfZm10dHknLCBmbXR0eV9yZXN0KSAtPlxuICAgIGlmIEZtdHR5X0VCQiBzdWIyX2ZtdHR5IDw+IEZtdHR5X0VCQiBzdWIyX2ZtdHR5JyB0aGVuIHJhaXNlIFR5cGVfbWlzbWF0Y2g7XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChGb3JtYXRfYXJnX3R5IChzdWIyX2ZtdHR5Jywgc3ViX2ZtdHR5X3Jlc3QnKSwgZm10JylcbiAgfCBGb3JtYXRfc3Vic3RfdHkgKHN1YjFfZm10dHksICBzdWIyX2ZtdHR5LCAgc3ViX2ZtdHR5X3Jlc3QpLFxuICAgIEZvcm1hdF9zdWJzdF90eSAoc3ViMV9mbXR0eScsIHN1YjJfZm10dHknLCBmbXR0eV9yZXN0KSAtPlxuICAgICgqIFRPRE8gZGVmaW5lIEZtdHR5X3JlbF9FQkIgdG8gcmVtb3ZlIHRob3NlIGVyYXNlX3JlbCAqKVxuICAgIGlmIEZtdHR5X0VCQiAoZXJhc2VfcmVsIHN1YjFfZm10dHkpIDw+IEZtdHR5X0VCQiAoZXJhc2VfcmVsIHN1YjFfZm10dHknKVxuICAgIHRoZW4gcmFpc2UgVHlwZV9taXNtYXRjaDtcbiAgICBpZiBGbXR0eV9FQkIgKGVyYXNlX3JlbCBzdWIyX2ZtdHR5KSA8PiBGbXR0eV9FQkIgKGVyYXNlX3JlbCBzdWIyX2ZtdHR5JylcbiAgICB0aGVuIHJhaXNlIFR5cGVfbWlzbWF0Y2g7XG4gICAgbGV0IHN1Yl9mbXR0eScgPSB0cmFucyAoc3ltbSBzdWIxX2ZtdHR5Jykgc3ViMl9mbXR0eScgaW5cbiAgICBsZXQgXywgZjIsIF8sIGY0ID0gZm10dHlfcmVsX2RldCBzdWJfZm10dHknIGluXG4gICAgbGV0IFJlZmwgPSBmMiBSZWZsIGluXG4gICAgbGV0IFJlZmwgPSBmNCBSZWZsIGluXG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gKGVyYXNlX3JlbCBzdWJfZm10dHlfcmVzdCkgZm10IGZtdHR5X3Jlc3RcbiAgICBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKEZvcm1hdF9zdWJzdF90eSAoc3ViMV9mbXR0eScsIHN1YjJfZm10dHknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltbSBzdWJfZm10dHlfcmVzdCcpLFxuICAgICAgICAgICAgICAgICAgIGZtdCcpXG4gIHwgRW5kX29mX2ZtdHR5LCBmbXR0eSAtPlxuICAgIEZtdHR5X2ZtdF9FQkIgKEVuZF9vZl9mbXR0eSwgdHlwZV9mb3JtYXRfZ2VuIGZtdCBmbXR0eSlcbiAgfCBfIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcblxuKCogVGhpcyBpbXBsZW1lbnRhdGlvbiBvZiBgcmVjYXN0YCBpcyBhIGJpdCBkaXNhcHBvaW50aW5nLiBUaGVcbiAgIGludmFyaWFudCBwcm92aWRlZCBieSB0aGUgdHlwZSBhcmUgdmVyeSBzdHJvbmc6IHRoZSBpbnB1dCBmb3JtYXQnc1xuICAgdHlwZSBpcyBpbiByZWxhdGlvbiB0byB0aGUgb3V0cHV0IHR5cGUncyBhcyB3aXRuZXNzZWQgYnkgdGhlXG4gICBmbXR0eV9yZWwgYXJndW1lbnQuIE9uZSB3b3VsZCBhdCBmaXJzdCBleHBlY3QgdGhpcyBmdW5jdGlvbiB0byBiZVxuICAgdG90YWwsIGFuZCBpbXBsZW1lbnRhYmxlIGJ5IGV4aGF1c3RpdmUgcGF0dGVybiBtYXRjaGluZy4gSW5zdGVhZCxcbiAgIHdlIHJldXNlIHRoZSBoaWdobHkgcGFydGlhbCBhbmQgbXVjaCBsZXNzIHdlbGwtZGVmaW5lZCBmdW5jdGlvblxuICAgYHR5cGVfZm9ybWF0YCB0aGF0IGhhcyBsb3N0IGFsbCBrbm93bGVkZ2Ugb2YgdGhlIGNvcnJlc3BvbmRlbmNlXG4gICBiZXR3ZWVuIHRoZSBhcmd1bWVudCdzIHR5cGVzLlxuXG4gICBCZXNpZGVzIHRoZSBmYWN0IHRoYXQgdGhpcyBmdW5jdGlvbiByZXVzZXMgYSBsb3Qgb2YgdGhlXG4gICBgdHlwZV9mb3JtYXRgIGxvZ2ljIChlZy46IHNlZWluZyBJbnRfdHkgaW4gdGhlIGZtdHR5IHBhcmFtZXRlciBkb2VzXG4gICBub3QgbGV0IHlvdSBtYXRjaCBvbiBJbnQgb25seSwgYXMgeW91IG1heSBpbiBmYWN0IGhhdmUgRmxvYXRcbiAgIChBcmdfcGFkZGluZywgLi4uKSAoXCIlLipkXCIpIGJlZ2lubmluZyB3aXRoIGFuIEludF90eSksIGl0IGlzIGFsc29cbiAgIGEgcGFydGlhbCBmdW5jdGlvbiwgYmVjYXVzZSB0aGUgdHlwaW5nIGluZm9ybWF0aW9uIGluIGEgZm9ybWF0IGlzXG4gICBub3QgcXVpdGUgZW5vdWdoIHRvIHJlY29uc3RydWN0IGl0IHVuYW1iaWd1b3VzbHkuIEZvciBleGFtcGxlLCB0aGVcbiAgIGZvcm1hdCB0eXBlcyBvZiBcIiVkJV9yXCIgYW5kIFwiJV9yJWRcIiBoYXZlIHRoZSBzYW1lIGZvcm1hdDZcbiAgIHBhcmFtZXRlcnMsIGJ1dCB0aGV5IGFyZSBub3QgYXQgYWxsIGV4Y2hhbmdlYWJsZSwgYW5kIHB1dHRpbmcgb25lXG4gICBpbiBwbGFjZSBvZiB0aGUgb3RoZXIgbXVzdCByZXN1bHQgaW4gYSBkeW5hbWljIGZhaWx1cmUuXG5cbiAgIEdpdmVuIHRoYXQ6XG4gICAtIHdlJ2QgaGF2ZSB0byBkdXBsaWNhdGUgYSBsb3Qgb2Ygbm9uLXRyaXZpYWwgdHlwaW5nIGxvZ2ljIGZyb20gdHlwZV9mb3JtYXRcbiAgIC0gdGhpcyB3b3VsZG4ndCBldmVuIGVsaW1pbmF0ZSAoYWxsKSB0aGUgZHluYW1pYyBmYWlsdXJlc1xuICAgd2UgZGVjaWRlZCB0byBqdXN0IHJldXNlIHR5cGVfZm9ybWF0IGRpcmVjdGx5IGZvciBub3cuXG4qKVxubGV0IHJlY2FzdCA6XG4gIHR5cGUgYTEgYjEgYzEgZDEgZTEgZjFcbiAgICAgICBhMiBiMiBjMiBkMiBlMiBmMlxuICAuXG4gICAgIChhMSwgYjEsIGMxLCBkMSwgZTEsIGYxKSBmbXRcbiAgLT4gKGExLCBiMSwgYzEsIGQxLCBlMSwgZjEsXG4gICAgICBhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXR0eV9yZWxcbiAgLT4gKGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIpIGZtdFxuPSBmdW4gZm10IGZtdHR5IC0+XG4gIHR5cGVfZm9ybWF0IGZtdCAoZXJhc2VfcmVsIChzeW1tIGZtdHR5KSlcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogUHJpbnRpbmcgdG9vbHMgKilcblxuKCogQWRkIHBhZGRpbmcgc3BhY2VzIGFyb3VuZCBhIHN0cmluZy4gKilcbmxldCBmaXhfcGFkZGluZyBwYWR0eSB3aWR0aCBzdHIgPVxuICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzdHIgaW5cbiAgbGV0IHdpZHRoLCBwYWR0eSA9XG4gICAgYWJzIHdpZHRoLFxuICAgICgqIHdoaWxlIGxpdGVyYWwgcGFkZGluZyB3aWR0aHMgYXJlIGFsd2F5cyBub24tbmVnYXRpdmUsXG4gICAgICAgZHluYW1pY2FsbHktc2V0IHdpZHRocyAoQXJnX3BhZGRpbmcsIGVnLiAlKmQpIG1heSBiZSBuZWdhdGl2ZTtcbiAgICAgICB3ZSBpbnRlcnByZXQgdGhvc2UgYXMgc3BlY2lmeWluZyBhIHBhZGRpbmctdG8tdGhlLWxlZnQ7IHRoaXNcbiAgICAgICBtZWFucyB0aGF0ICcwJyBtYXkgZ2V0IGRyb3BwZWQgZXZlbiBpZiBpdCB3YXMgZXhwbGljaXRseSBzZXQsXG4gICAgICAgYnV0OlxuICAgICAgIC0gdGhpcyBpcyB3aGF0IHRoZSBsZWdhY3kgaW1wbGVtZW50YXRpb24gZG9lcywgYW5kXG4gICAgICAgICB3ZSBwcmVzZXJ2ZSBjb21wYXRpYmlsaXR5IGlmIHBvc3NpYmxlXG4gICAgICAgLSB3ZSBjb3VsZCBvbmx5IHNpZ25hbCB0aGlzIGlzc3VlIGJ5IGZhaWxpbmcgYXQgcnVudGltZSxcbiAgICAgICAgIHdoaWNoIGlzIG5vdCB2ZXJ5IG5pY2UuLi4gKilcbiAgICBpZiB3aWR0aCA8IDAgdGhlbiBMZWZ0IGVsc2UgcGFkdHkgaW5cbiAgaWYgd2lkdGggPD0gbGVuIHRoZW4gc3RyIGVsc2VcbiAgICBsZXQgcmVzID0gQnl0ZXMubWFrZSB3aWR0aCAoaWYgcGFkdHkgPSBaZXJvcyB0aGVuICcwJyBlbHNlICcgJykgaW5cbiAgICBiZWdpbiBtYXRjaCBwYWR0eSB3aXRoXG4gICAgfCBMZWZ0ICAtPiBTdHJpbmcuYmxpdCBzdHIgMCByZXMgMCBsZW5cbiAgICB8IFJpZ2h0IC0+IFN0cmluZy5ibGl0IHN0ciAwIHJlcyAod2lkdGggLSBsZW4pIGxlblxuICAgIHwgWmVyb3Mgd2hlbiBsZW4gPiAwICYmIChzdHIuWzBdID0gJysnIHx8IHN0ci5bMF0gPSAnLScgfHwgc3RyLlswXSA9ICcgJykgLT5cbiAgICAgIEJ5dGVzLnNldCByZXMgMCBzdHIuWzBdO1xuICAgICAgU3RyaW5nLmJsaXQgc3RyIDEgcmVzICh3aWR0aCAtIGxlbiArIDEpIChsZW4gLSAxKVxuICAgIHwgWmVyb3Mgd2hlbiBsZW4gPiAxICYmIHN0ci5bMF0gPSAnMCcgJiYgKHN0ci5bMV0gPSAneCcgfHwgc3RyLlsxXSA9ICdYJykgLT5cbiAgICAgIEJ5dGVzLnNldCByZXMgMSBzdHIuWzFdO1xuICAgICAgU3RyaW5nLmJsaXQgc3RyIDIgcmVzICh3aWR0aCAtIGxlbiArIDIpIChsZW4gLSAyKVxuICAgIHwgWmVyb3MgLT5cbiAgICAgIFN0cmluZy5ibGl0IHN0ciAwIHJlcyAod2lkdGggLSBsZW4pIGxlblxuICAgIGVuZDtcbiAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHJlc1xuXG4oKiBBZGQgJzAnIHBhZGRpbmcgdG8gaW50LCBpbnQzMiwgbmF0aXZlaW50IG9yIGludDY0IHN0cmluZyByZXByZXNlbnRhdGlvbi4gKilcbmxldCBmaXhfaW50X3ByZWNpc2lvbiBwcmVjIHN0ciA9XG4gIGxldCBwcmVjID0gYWJzIHByZWMgaW5cbiAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggc3RyIGluXG4gIG1hdGNoIHN0ci5bMF0gd2l0aFxuICB8ICgnKycgfCAnLScgfCAnICcpIGFzIGMgd2hlbiBwcmVjICsgMSA+IGxlbiAtPlxuICAgIGxldCByZXMgPSBCeXRlcy5tYWtlIChwcmVjICsgMSkgJzAnIGluXG4gICAgQnl0ZXMuc2V0IHJlcyAwIGM7XG4gICAgU3RyaW5nLmJsaXQgc3RyIDEgcmVzIChwcmVjIC0gbGVuICsgMikgKGxlbiAtIDEpO1xuICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcmVzXG4gIHwgJzAnIHdoZW4gcHJlYyArIDIgPiBsZW4gJiYgbGVuID4gMSAmJiAoc3RyLlsxXSA9ICd4JyB8fCBzdHIuWzFdID0gJ1gnKSAtPlxuICAgIGxldCByZXMgPSBCeXRlcy5tYWtlIChwcmVjICsgMikgJzAnIGluXG4gICAgQnl0ZXMuc2V0IHJlcyAxIHN0ci5bMV07XG4gICAgU3RyaW5nLmJsaXQgc3RyIDIgcmVzIChwcmVjIC0gbGVuICsgNCkgKGxlbiAtIDIpO1xuICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcmVzXG4gIHwgJzAnIC4uICc5JyB8ICdhJyAuLiAnZicgfCAnQScgLi4gJ0YnIHdoZW4gcHJlYyA+IGxlbiAtPlxuICAgIGxldCByZXMgPSBCeXRlcy5tYWtlIHByZWMgJzAnIGluXG4gICAgU3RyaW5nLmJsaXQgc3RyIDAgcmVzIChwcmVjIC0gbGVuKSBsZW47XG4gICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyByZXNcbiAgfCBfIC0+XG4gICAgc3RyXG5cbigqIEVzY2FwZSBhIHN0cmluZyBhY2NvcmRpbmcgdG8gdGhlIE9DYW1sIGxleGluZyBjb252ZW50aW9uLiAqKVxubGV0IHN0cmluZ190b19jYW1sX3N0cmluZyBzdHIgPVxuICBsZXQgc3RyID0gU3RyaW5nLmVzY2FwZWQgc3RyIGluXG4gIGxldCBsID0gU3RyaW5nLmxlbmd0aCBzdHIgaW5cbiAgbGV0IHJlcyA9IEJ5dGVzLm1ha2UgKGwgKyAyKSAnXFxcIicgaW5cbiAgU3RyaW5nLnVuc2FmZV9ibGl0IHN0ciAwIHJlcyAxIGw7XG4gIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcmVzXG5cbigqIEdlbmVyYXRlIHRoZSBmb3JtYXRfaW50L2ludDMyL25hdGl2ZWludC9pbnQ2NCBmaXJzdCBhcmd1bWVudFxuICAgZnJvbSBhbiBpbnRfY29udi4gKilcbmxldCBmb3JtYXRfb2ZfaWNvbnYgPSBmdW5jdGlvblxuICB8IEludF9kIHwgSW50X0NkIC0+IFwiJWRcIiB8IEludF9wZCAtPiBcIiUrZFwiIHwgSW50X3NkIC0+IFwiJSBkXCJcbiAgfCBJbnRfaSB8IEludF9DaSAtPiBcIiVpXCIgfCBJbnRfcGkgLT4gXCIlK2lcIiB8IEludF9zaSAtPiBcIiUgaVwiXG4gIHwgSW50X3ggLT4gXCIleFwiIHwgSW50X0N4IC0+IFwiJSN4XCJcbiAgfCBJbnRfWCAtPiBcIiVYXCIgfCBJbnRfQ1ggLT4gXCIlI1hcIlxuICB8IEludF9vIC0+IFwiJW9cIiB8IEludF9DbyAtPiBcIiUjb1wiXG4gIHwgSW50X3UgfCBJbnRfQ3UgLT4gXCIldVwiXG5cbmxldCBmb3JtYXRfb2ZfaWNvbnZMID0gZnVuY3Rpb25cbiAgfCBJbnRfZCB8IEludF9DZCAtPiBcIiVMZFwiIHwgSW50X3BkIC0+IFwiJStMZFwiIHwgSW50X3NkIC0+IFwiJSBMZFwiXG4gIHwgSW50X2kgfCBJbnRfQ2kgLT4gXCIlTGlcIiB8IEludF9waSAtPiBcIiUrTGlcIiB8IEludF9zaSAtPiBcIiUgTGlcIlxuICB8IEludF94IC0+IFwiJUx4XCIgfCBJbnRfQ3ggLT4gXCIlI0x4XCJcbiAgfCBJbnRfWCAtPiBcIiVMWFwiIHwgSW50X0NYIC0+IFwiJSNMWFwiXG4gIHwgSW50X28gLT4gXCIlTG9cIiB8IEludF9DbyAtPiBcIiUjTG9cIlxuICB8IEludF91IHwgSW50X0N1IC0+IFwiJUx1XCJcblxubGV0IGZvcm1hdF9vZl9pY29udmwgPSBmdW5jdGlvblxuICB8IEludF9kIHwgSW50X0NkIC0+IFwiJWxkXCIgfCBJbnRfcGQgLT4gXCIlK2xkXCIgfCBJbnRfc2QgLT4gXCIlIGxkXCJcbiAgfCBJbnRfaSB8IEludF9DaSAtPiBcIiVsaVwiIHwgSW50X3BpIC0+IFwiJStsaVwiIHwgSW50X3NpIC0+IFwiJSBsaVwiXG4gIHwgSW50X3ggLT4gXCIlbHhcIiB8IEludF9DeCAtPiBcIiUjbHhcIlxuICB8IEludF9YIC0+IFwiJWxYXCIgfCBJbnRfQ1ggLT4gXCIlI2xYXCJcbiAgfCBJbnRfbyAtPiBcIiVsb1wiIHwgSW50X0NvIC0+IFwiJSNsb1wiXG4gIHwgSW50X3UgfCBJbnRfQ3UgLT4gXCIlbHVcIlxuXG5sZXQgZm9ybWF0X29mX2ljb252biA9IGZ1bmN0aW9uXG4gIHwgSW50X2QgfCBJbnRfQ2QgLT4gXCIlbmRcIiB8IEludF9wZCAtPiBcIiUrbmRcIiB8IEludF9zZCAtPiBcIiUgbmRcIlxuICB8IEludF9pIHwgSW50X0NpIC0+IFwiJW5pXCIgfCBJbnRfcGkgLT4gXCIlK25pXCIgfCBJbnRfc2kgLT4gXCIlIG5pXCJcbiAgfCBJbnRfeCAtPiBcIiVueFwiIHwgSW50X0N4IC0+IFwiJSNueFwiXG4gIHwgSW50X1ggLT4gXCIlblhcIiB8IEludF9DWCAtPiBcIiUjblhcIlxuICB8IEludF9vIC0+IFwiJW5vXCIgfCBJbnRfQ28gLT4gXCIlI25vXCJcbiAgfCBJbnRfdSB8IEludF9DdSAtPiBcIiVudVwiXG5cbigqIEdlbmVyYXRlIHRoZSBmb3JtYXRfZmxvYXQgZmlyc3QgYXJndW1lbnQgZnJvbSBhIGZsb2F0X2NvbnYuICopXG5sZXQgZm9ybWF0X29mX2Zjb252IGZjb252IHByZWMgPVxuICAgIGxldCBwcmVjID0gYWJzIHByZWMgaW5cbiAgICBsZXQgc3ltYiA9IGNoYXJfb2ZfZmNvbnYgfmNGOidnJyBmY29udiBpblxuICAgIGxldCBidWYgPSBidWZmZXJfY3JlYXRlIDE2IGluXG4gICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7XG4gICAgYnByaW50X2Zjb252X2ZsYWcgYnVmIGZjb252O1xuICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJy4nO1xuICAgIGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiAoSW50LnRvX3N0cmluZyBwcmVjKTtcbiAgICBidWZmZXJfYWRkX2NoYXIgYnVmIHN5bWI7XG4gICAgYnVmZmVyX2NvbnRlbnRzIGJ1ZlxuXG5sZXQgdHJhbnNmb3JtX2ludF9hbHQgaWNvbnYgcyA9XG4gIG1hdGNoIGljb252IHdpdGhcbiAgfCBJbnRfQ2QgfCBJbnRfQ2kgfCBJbnRfQ3UgLT5cbiAgICBsZXQgZGlnaXRzID1cbiAgICAgIGxldCBuID0gcmVmIDAgaW5cbiAgICAgIGZvciBpID0gMCB0byBTdHJpbmcubGVuZ3RoIHMgLSAxIGRvXG4gICAgICAgIG1hdGNoIFN0cmluZy51bnNhZmVfZ2V0IHMgaSB3aXRoXG4gICAgICAgIHwgJzAnLi4nOScgLT4gaW5jciBuXG4gICAgICAgIHwgXyAtPiAoKVxuICAgICAgZG9uZTtcbiAgICAgICFuXG4gICAgaW5cbiAgICBsZXQgYnVmID0gQnl0ZXMuY3JlYXRlIChTdHJpbmcubGVuZ3RoIHMgKyAoZGlnaXRzIC0gMSkgLyAzKSBpblxuICAgIGxldCBwb3MgPSByZWYgMCBpblxuICAgIGxldCBwdXQgYyA9IEJ5dGVzLnNldCBidWYgIXBvcyBjOyBpbmNyIHBvcyBpblxuICAgIGxldCBsZWZ0ID0gcmVmICgoZGlnaXRzIC0gMSkgbW9kIDMgKyAxKSBpblxuICAgIGZvciBpID0gMCB0byBTdHJpbmcubGVuZ3RoIHMgLSAxIGRvXG4gICAgICBtYXRjaCBTdHJpbmcudW5zYWZlX2dldCBzIGkgd2l0aFxuICAgICAgfCAnMCcuLic5JyBhcyBjIC0+XG4gICAgICAgICAgaWYgIWxlZnQgPSAwIHRoZW4gKHB1dCAnXyc7IGxlZnQgOj0gMyk7IGRlY3IgbGVmdDsgcHV0IGNcbiAgICAgIHwgYyAtPiBwdXQgY1xuICAgIGRvbmU7XG4gICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBidWZcbiAgfCBfIC0+IHNcblxuKCogQ29udmVydCBhbiBpbnRlZ2VyIHRvIGEgc3RyaW5nIGFjY29yZGluZyB0byBhIGNvbnZlcnNpb24uICopXG5sZXQgY29udmVydF9pbnQgaWNvbnYgbiA9XG4gIHRyYW5zZm9ybV9pbnRfYWx0IGljb252IChmb3JtYXRfaW50IChmb3JtYXRfb2ZfaWNvbnYgaWNvbnYpIG4pXG5sZXQgY29udmVydF9pbnQzMiBpY29udiBuID1cbiAgdHJhbnNmb3JtX2ludF9hbHQgaWNvbnYgKGZvcm1hdF9pbnQzMiAoZm9ybWF0X29mX2ljb252bCBpY29udikgbilcbmxldCBjb252ZXJ0X25hdGl2ZWludCBpY29udiBuID1cbiAgdHJhbnNmb3JtX2ludF9hbHQgaWNvbnYgKGZvcm1hdF9uYXRpdmVpbnQgKGZvcm1hdF9vZl9pY29udm4gaWNvbnYpIG4pXG5sZXQgY29udmVydF9pbnQ2NCBpY29udiBuID1cbiAgdHJhbnNmb3JtX2ludF9hbHQgaWNvbnYgKGZvcm1hdF9pbnQ2NCAoZm9ybWF0X29mX2ljb252TCBpY29udikgbilcblxuKCogQ29udmVydCBhIGZsb2F0IHRvIHN0cmluZy4gKilcbigqIEZpeCBzcGVjaWFsIGNhc2Ugb2YgXCJPQ2FtbCBmbG9hdCBmb3JtYXRcIi4gKilcbmxldCBjb252ZXJ0X2Zsb2F0IGZjb252IHByZWMgeCA9XG4gIGxldCBoZXggKCkgPVxuICAgIGxldCBzaWduID1cbiAgICAgIG1hdGNoIGZzdCBmY29udiB3aXRoXG4gICAgICB8IEZsb2F0X2ZsYWdfcCAtPiAnKydcbiAgICAgIHwgRmxvYXRfZmxhZ19zIC0+ICcgJ1xuICAgICAgfCBfIC0+ICctJyBpblxuICAgIGhleHN0cmluZ19vZl9mbG9hdCB4IHByZWMgc2lnbiBpblxuICBsZXQgYWRkX2RvdF9pZl9uZWVkZWQgc3RyID1cbiAgICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzdHIgaW5cbiAgICBsZXQgcmVjIGlzX3ZhbGlkIGkgPVxuICAgICAgaWYgaSA9IGxlbiB0aGVuIGZhbHNlIGVsc2VcbiAgICAgICAgbWF0Y2ggc3RyLltpXSB3aXRoXG4gICAgICAgIHwgJy4nIHwgJ2UnIHwgJ0UnIC0+IHRydWVcbiAgICAgICAgfCBfIC0+IGlzX3ZhbGlkIChpICsgMSkgaW5cbiAgICBpZiBpc192YWxpZCAwIHRoZW4gc3RyIGVsc2Ugc3RyIF4gXCIuXCIgaW5cbiAgbGV0IGNhbWxfc3BlY2lhbF92YWwgc3RyID0gbWF0Y2ggY2xhc3NpZnlfZmxvYXQgeCB3aXRoXG4gICAgfCBGUF9ub3JtYWwgfCBGUF9zdWJub3JtYWwgfCBGUF96ZXJvIC0+IHN0clxuICAgIHwgRlBfaW5maW5pdGUgLT4gaWYgeCA8IDAuMCB0aGVuIFwibmVnX2luZmluaXR5XCIgZWxzZSBcImluZmluaXR5XCJcbiAgICB8IEZQX25hbiAtPiBcIm5hblwiIGluXG4gIG1hdGNoIHNuZCBmY29udiB3aXRoXG4gIHwgRmxvYXRfaCAtPiBoZXggKClcbiAgfCBGbG9hdF9IIC0+IFN0cmluZy51cHBlcmNhc2VfYXNjaWkgKGhleCAoKSlcbiAgfCBGbG9hdF9DRiAtPiBjYW1sX3NwZWNpYWxfdmFsIChoZXggKCkpXG4gIHwgRmxvYXRfRiAtPlxuICAgIGxldCBzdHIgPSBmb3JtYXRfZmxvYXQgKGZvcm1hdF9vZl9mY29udiBmY29udiBwcmVjKSB4IGluXG4gICAgY2FtbF9zcGVjaWFsX3ZhbCAoYWRkX2RvdF9pZl9uZWVkZWQgc3RyKVxuICB8IEZsb2F0X2YgfCBGbG9hdF9lIHwgRmxvYXRfRSB8IEZsb2F0X2cgfCBGbG9hdF9HIC0+XG4gICAgZm9ybWF0X2Zsb2F0IChmb3JtYXRfb2ZfZmNvbnYgZmNvbnYgcHJlYykgeFxuXG4oKiBDb252ZXJ0IGEgY2hhciB0byBhIHN0cmluZyBhY2NvcmRpbmcgdG8gdGhlIE9DYW1sIGxleGljYWwgY29udmVudGlvbi4gKilcbmxldCBmb3JtYXRfY2FtbF9jaGFyIGMgPVxuICBsZXQgc3RyID0gQ2hhci5lc2NhcGVkIGMgaW5cbiAgbGV0IGwgPSBTdHJpbmcubGVuZ3RoIHN0ciBpblxuICBsZXQgcmVzID0gQnl0ZXMubWFrZSAobCArIDIpICdcXCcnIGluXG4gIFN0cmluZy51bnNhZmVfYmxpdCBzdHIgMCByZXMgMSBsO1xuICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHJlc1xuXG4oKiBDb252ZXJ0IGEgZm9ybWF0IHR5cGUgdG8gc3RyaW5nICopXG5sZXQgc3RyaW5nX29mX2ZtdHR5IGZtdHR5ID1cbiAgbGV0IGJ1ZiA9IGJ1ZmZlcl9jcmVhdGUgMTYgaW5cbiAgYnByaW50X2ZtdHR5IGJ1ZiBmbXR0eTtcbiAgYnVmZmVyX2NvbnRlbnRzIGJ1ZlxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgKCogR2VuZXJpYyBwcmludGluZyBmdW5jdGlvbiAqKVxuXG4oKiBNYWtlIGEgZ2VuZXJpYyBwcmludGluZyBmdW5jdGlvbi4gKilcbigqIFVzZWQgdG8gZ2VuZXJhdGUgUHJpbnRmIGFuZCBGb3JtYXQgcHJpbnRpbmcgZnVuY3Rpb25zLiAqKVxuKCogUGFyYW1ldGVyczpcbiAgICAgazogYSBjb250aW51YXRpb24gZmluYWxseSBhcHBsaWVkIHRvIHRoZSBvdXRwdXQgc3RyZWFtIGFuZCB0aGUgYWNjdW11bGF0b3IuXG4gICAgIG86IHRoZSBvdXRwdXQgc3RyZWFtIChzZWUgaywgJWEgYW5kICV0KS5cbiAgICAgYWNjOiByZXYgbGlzdCBvZiBwcmludGluZyBlbnRpdGllcyAoc3RyaW5nLCBjaGFyLCBmbHVzaCwgZm9ybWF0dGluZywgLi4uKS5cbiAgICAgZm10OiB0aGUgZm9ybWF0LiAqKVxubGV0IHJlYyBtYWtlX3ByaW50ZiA6IHR5cGUgYSBiIGMgZCBlIGYgLlxuICAgICgoYiwgYykgYWNjIC0+IGYpIC0+IChiLCBjKSBhY2MgLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+IGEgPVxuZnVuIGsgYWNjIGZtdCAtPiBtYXRjaCBmbXQgd2l0aFxuICB8IENoYXIgcmVzdCAtPlxuICAgIGZ1biBjIC0+XG4gICAgICBsZXQgbmV3X2FjYyA9IEFjY19kYXRhX2NoYXIgKGFjYywgYykgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgbmV3X2FjYyByZXN0XG4gIHwgQ2FtbF9jaGFyIHJlc3QgLT5cbiAgICBmdW4gYyAtPlxuICAgICAgbGV0IG5ld19hY2MgPSBBY2NfZGF0YV9zdHJpbmcgKGFjYywgZm9ybWF0X2NhbWxfY2hhciBjKSBpblxuICAgICAgbWFrZV9wcmludGYgayBuZXdfYWNjIHJlc3RcbiAgfCBTdHJpbmcgKHBhZCwgcmVzdCkgLT5cbiAgICBtYWtlX3BhZGRpbmcgayBhY2MgcmVzdCBwYWQgKGZ1biBzdHIgLT4gc3RyKVxuICB8IENhbWxfc3RyaW5nIChwYWQsIHJlc3QpIC0+XG4gICAgbWFrZV9wYWRkaW5nIGsgYWNjIHJlc3QgcGFkIHN0cmluZ190b19jYW1sX3N0cmluZ1xuICB8IEludCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBtYWtlX2ludF9wYWRkaW5nX3ByZWNpc2lvbiBrIGFjYyByZXN0IHBhZCBwcmVjIGNvbnZlcnRfaW50IGljb252XG4gIHwgSW50MzIgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbWFrZV9pbnRfcGFkZGluZ19wcmVjaXNpb24gayBhY2MgcmVzdCBwYWQgcHJlYyBjb252ZXJ0X2ludDMyIGljb252XG4gIHwgTmF0aXZlaW50IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIG1ha2VfaW50X3BhZGRpbmdfcHJlY2lzaW9uIGsgYWNjIHJlc3QgcGFkIHByZWMgY29udmVydF9uYXRpdmVpbnQgaWNvbnZcbiAgfCBJbnQ2NCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBtYWtlX2ludF9wYWRkaW5nX3ByZWNpc2lvbiBrIGFjYyByZXN0IHBhZCBwcmVjIGNvbnZlcnRfaW50NjQgaWNvbnZcbiAgfCBGbG9hdCAoZmNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBtYWtlX2Zsb2F0X3BhZGRpbmdfcHJlY2lzaW9uIGsgYWNjIHJlc3QgcGFkIHByZWMgZmNvbnZcbiAgfCBCb29sIChwYWQsIHJlc3QpIC0+XG4gICAgbWFrZV9wYWRkaW5nIGsgYWNjIHJlc3QgcGFkIHN0cmluZ19vZl9ib29sXG4gIHwgQWxwaGEgcmVzdCAtPlxuICAgIGZ1biBmIHggLT4gbWFrZV9wcmludGYgayAoQWNjX2RlbGF5IChhY2MsIGZ1biBvIC0+IGYgbyB4KSkgcmVzdFxuICB8IFRoZXRhIHJlc3QgLT5cbiAgICBmdW4gZiAtPiBtYWtlX3ByaW50ZiBrIChBY2NfZGVsYXkgKGFjYywgZikpIHJlc3RcbiAgfCBDdXN0b20gKGFyaXR5LCBmLCByZXN0KSAtPlxuICAgIG1ha2VfY3VzdG9tIGsgYWNjIHJlc3QgYXJpdHkgKGYgKCkpXG4gIHwgUmVhZGVyIF8gLT5cbiAgICAoKiBUaGlzIGNhc2UgaXMgaW1wb3NzaWJsZSwgYnkgdHlwaW5nIG9mIGZvcm1hdHMuICopXG4gICAgKCogSW5kZWVkLCBzaW5jZSBwcmludGYgYW5kIGNvLiB0YWtlIGEgZm9ybWF0NCBhcyBhcmd1bWVudCwgdGhlICdkIGFuZCAnZVxuICAgICAgIHR5cGUgcGFyYW1ldGVycyBvZiBmbXQgYXJlIG9idmlvdXNseSBlcXVhbHMuIFRoZSBSZWFkZXIgaXMgdGhlXG4gICAgICAgb25seSBjb25zdHJ1Y3RvciB3aGljaCB0b3VjaCAnZCBhbmQgJ2UgdHlwZSBwYXJhbWV0ZXJzIG9mIHRoZSBmb3JtYXRcbiAgICAgICB0eXBlLCBpdCBhZGRzIGFuICgtPikgdG8gdGhlICdkIHBhcmFtZXRlcnMuIENvbnNlcXVlbnRseSwgYSBmb3JtYXQ0XG4gICAgICAgY2Fubm90IGNvbnRhaW4gYSBSZWFkZXIgbm9kZSwgZXhjZXB0IGluIHRoZSBzdWItZm9ybWF0IGFzc29jaWF0ZWQgdG9cbiAgICAgICBhbiAley4uLiV9LiBJdCdzIG5vdCBhIHByb2JsZW0gYmVjYXVzZSBtYWtlX3ByaW50ZiBkbyBub3QgY2FsbFxuICAgICAgIGl0c2VsZiByZWN1cnNpdmVseSBvbiB0aGUgc3ViLWZvcm1hdCBhc3NvY2lhdGVkIHRvICV7Li4uJX0uICopXG4gICAgYXNzZXJ0IGZhbHNlXG4gIHwgRmx1c2ggcmVzdCAtPlxuICAgIG1ha2VfcHJpbnRmIGsgKEFjY19mbHVzaCBhY2MpIHJlc3RcblxuICB8IFN0cmluZ19saXRlcmFsIChzdHIsIHJlc3QpIC0+XG4gICAgbWFrZV9wcmludGYgayAoQWNjX3N0cmluZ19saXRlcmFsIChhY2MsIHN0cikpIHJlc3RcbiAgfCBDaGFyX2xpdGVyYWwgKGNociwgcmVzdCkgLT5cbiAgICBtYWtlX3ByaW50ZiBrIChBY2NfY2hhcl9saXRlcmFsIChhY2MsIGNocikpIHJlc3RcblxuICB8IEZvcm1hdF9hcmcgKF8sIHN1Yl9mbXR0eSwgcmVzdCkgLT5cbiAgICBsZXQgdHkgPSBzdHJpbmdfb2ZfZm10dHkgc3ViX2ZtdHR5IGluXG4gICAgKGZ1biBzdHIgLT5cbiAgICAgIGlnbm9yZSBzdHI7XG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgdHkpKSByZXN0KVxuICB8IEZvcm1hdF9zdWJzdCAoXywgZm10dHksIHJlc3QpIC0+XG4gICAgZnVuIChGb3JtYXQgKGZtdCwgXykpIC0+IG1ha2VfcHJpbnRmIGsgYWNjXG4gICAgICAoY29uY2F0X2ZtdCAocmVjYXN0IGZtdCBmbXR0eSkgcmVzdClcblxuICB8IFNjYW5fY2hhcl9zZXQgKF8sIF8sIHJlc3QpIC0+XG4gICAgbGV0IG5ld19hY2MgPSBBY2NfaW52YWxpZF9hcmcgKGFjYywgXCJQcmludGY6IGJhZCBjb252ZXJzaW9uICVbXCIpIGluXG4gICAgZnVuIF8gLT4gbWFrZV9wcmludGYgayBuZXdfYWNjIHJlc3RcbiAgfCBTY2FuX2dldF9jb3VudGVyIChfLCByZXN0KSAtPlxuICAgICgqIFRoaXMgY2FzZSBzaG91bGQgYmUgcmVmdXNlZCBmb3IgUHJpbnRmLiAqKVxuICAgICgqIEFjY2VwdGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LiAqKVxuICAgICgqIEludGVycHJldCAlbCwgJW4gYW5kICVMIGFzICV1LiAqKVxuICAgIGZ1biBuIC0+XG4gICAgICBsZXQgbmV3X2FjYyA9IEFjY19kYXRhX3N0cmluZyAoYWNjLCBmb3JtYXRfaW50IFwiJXVcIiBuKSBpblxuICAgICAgbWFrZV9wcmludGYgayBuZXdfYWNjIHJlc3RcbiAgfCBTY2FuX25leHRfY2hhciByZXN0IC0+XG4gICAgZnVuIGMgLT5cbiAgICAgIGxldCBuZXdfYWNjID0gQWNjX2RhdGFfY2hhciAoYWNjLCBjKSBpblxuICAgICAgbWFrZV9wcmludGYgayBuZXdfYWNjIHJlc3RcbiAgfCBJZ25vcmVkX3BhcmFtIChpZ24sIHJlc3QpIC0+XG4gICAgbWFrZV9pZ25vcmVkX3BhcmFtIGsgYWNjIGlnbiByZXN0XG5cbiAgfCBGb3JtYXR0aW5nX2xpdCAoZm10aW5nX2xpdCwgcmVzdCkgLT5cbiAgICBtYWtlX3ByaW50ZiBrIChBY2NfZm9ybWF0dGluZ19saXQgKGFjYywgZm10aW5nX2xpdCkpIHJlc3RcbiAgfCBGb3JtYXR0aW5nX2dlbiAoT3Blbl90YWcgKEZvcm1hdCAoZm10JywgXykpLCByZXN0KSAtPlxuICAgIGxldCBrJyBrYWNjID1cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19mb3JtYXR0aW5nX2dlbiAoYWNjLCBBY2Nfb3Blbl90YWcga2FjYykpIHJlc3QgaW5cbiAgICBtYWtlX3ByaW50ZiBrJyBFbmRfb2ZfYWNjIGZtdCdcbiAgfCBGb3JtYXR0aW5nX2dlbiAoT3Blbl9ib3ggKEZvcm1hdCAoZm10JywgXykpLCByZXN0KSAtPlxuICAgIGxldCBrJyBrYWNjID1cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19mb3JtYXR0aW5nX2dlbiAoYWNjLCBBY2Nfb3Blbl9ib3gga2FjYykpIHJlc3QgaW5cbiAgICBtYWtlX3ByaW50ZiBrJyBFbmRfb2ZfYWNjIGZtdCdcblxuICB8IEVuZF9vZl9mb3JtYXQgLT5cbiAgICBrIGFjY1xuXG4oKiBEZWxheSB0aGUgZXJyb3IgKEludmFsaWRfYXJndW1lbnQgXCJQcmludGY6IGJhZCBjb252ZXJzaW9uICVfXCIpLiAqKVxuKCogR2VuZXJhdGUgZnVuY3Rpb25zIHRvIHRha2UgcmVtYWluaW5nIGFyZ3VtZW50cyAoYWZ0ZXIgdGhlIFwiJV9cIikuICopXG5hbmQgbWFrZV9pZ25vcmVkX3BhcmFtIDogdHlwZSB4IHkgYSBiIGMgZCBlIGYgLlxuICAgICgoYiwgYykgYWNjIC0+IGYpIC0+IChiLCBjKSBhY2MgLT5cbiAgICAoYSwgYiwgYywgZCwgeSwgeCkgaWdub3JlZCAtPlxuICAgICh4LCBiLCBjLCB5LCBlLCBmKSBmbXQgLT4gYSA9XG5mdW4gayBhY2MgaWduIGZtdCAtPiBtYXRjaCBpZ24gd2l0aFxuICB8IElnbm9yZWRfY2hhciAgICAgICAgICAgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcbiAgfCBJZ25vcmVkX2NhbWxfY2hhciAgICAgICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG4gIHwgSWdub3JlZF9zdHJpbmcgXyAgICAgICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuICB8IElnbm9yZWRfY2FtbF9zdHJpbmcgXyAgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcbiAgfCBJZ25vcmVkX2ludCAoXywgXykgICAgICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG4gIHwgSWdub3JlZF9pbnQzMiAoXywgXykgICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuICB8IElnbm9yZWRfbmF0aXZlaW50IChfLCBfKSAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcbiAgfCBJZ25vcmVkX2ludDY0IChfLCBfKSAgICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG4gIHwgSWdub3JlZF9mbG9hdCAoXywgXykgICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuICB8IElnbm9yZWRfYm9vbCBfICAgICAgICAgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcbiAgfCBJZ25vcmVkX2Zvcm1hdF9hcmcgXyAgICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG4gIHwgSWdub3JlZF9mb3JtYXRfc3Vic3QgKF8sIGZtdHR5KSAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgZm10dHkgZm10XG4gIHwgSWdub3JlZF9yZWFkZXIgICAgICAgICAgICAgICAgICAtPiBhc3NlcnQgZmFsc2VcbiAgfCBJZ25vcmVkX3NjYW5fY2hhcl9zZXQgXyAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG4gIHwgSWdub3JlZF9zY2FuX2dldF9jb3VudGVyIF8gICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuICB8IElnbm9yZWRfc2Nhbl9uZXh0X2NoYXIgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcblxuXG4oKiBTcGVjaWFsIGNhc2Ugb2YgcHJpbnRmIFwiJV8oXCIuICopXG5hbmQgbWFrZV9mcm9tX2ZtdHR5IDogdHlwZSB4IHkgYSBiIGMgZCBlIGYgLlxuICAgICgoYiwgYykgYWNjIC0+IGYpIC0+IChiLCBjKSBhY2MgLT5cbiAgICAoYSwgYiwgYywgZCwgeSwgeCkgZm10dHkgLT5cbiAgICAoeCwgYiwgYywgeSwgZSwgZikgZm10IC0+IGEgPVxuZnVuIGsgYWNjIGZtdHR5IGZtdCAtPiBtYXRjaCBmbXR0eSB3aXRoXG4gIHwgQ2hhcl90eSByZXN0ICAgICAgICAgICAgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIHJlc3QgZm10XG4gIHwgU3RyaW5nX3R5IHJlc3QgICAgICAgICAgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIHJlc3QgZm10XG4gIHwgSW50X3R5IHJlc3QgICAgICAgICAgICAgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIHJlc3QgZm10XG4gIHwgSW50MzJfdHkgcmVzdCAgICAgICAgICAgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIHJlc3QgZm10XG4gIHwgTmF0aXZlaW50X3R5IHJlc3QgICAgICAgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIHJlc3QgZm10XG4gIHwgSW50NjRfdHkgcmVzdCAgICAgICAgICAgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIHJlc3QgZm10XG4gIHwgRmxvYXRfdHkgcmVzdCAgICAgICAgICAgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIHJlc3QgZm10XG4gIHwgQm9vbF90eSByZXN0ICAgICAgICAgICAgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIHJlc3QgZm10XG4gIHwgQWxwaGFfdHkgcmVzdCAgICAgICAgICAgLT4gZnVuIF8gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgcmVzdCBmbXRcbiAgfCBUaGV0YV90eSByZXN0ICAgICAgICAgICAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgcmVzdCBmbXRcbiAgfCBBbnlfdHkgcmVzdCAgICAgICAgICAgICAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgcmVzdCBmbXRcbiAgfCBSZWFkZXJfdHkgXyAgICAgICAgICAgICAtPiBhc3NlcnQgZmFsc2VcbiAgfCBJZ25vcmVkX3JlYWRlcl90eSBfICAgICAtPiBhc3NlcnQgZmFsc2VcbiAgfCBGb3JtYXRfYXJnX3R5IChfLCByZXN0KSAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgcmVzdCBmbXRcbiAgfCBFbmRfb2ZfZm10dHkgICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuICB8IEZvcm1hdF9zdWJzdF90eSAodHkxLCB0eTIsIHJlc3QpIC0+XG4gICAgbGV0IHR5ID0gdHJhbnMgKHN5bW0gdHkxKSB0eTIgaW5cbiAgICBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgKGNvbmNhdF9mbXR0eSB0eSByZXN0KSBmbXRcblxuKCogSW5zZXJ0IGFuIEFjY19pbnZhbGlkX2FyZyBpbiB0aGUgYWNjdW11bGF0b3IgYW5kIGNvbnRpbnVlIHRvIGdlbmVyYXRlXG4gICBjbG9zdXJlcyB0byBnZXQgdGhlIHJlbWFpbmluZyBhcmd1bWVudHMuICopXG5hbmQgbWFrZV9pbnZhbGlkX2FyZyA6IHR5cGUgYSBiIGMgZCBlIGYgLlxuICAgICgoYiwgYykgYWNjIC0+IGYpIC0+IChiLCBjKSBhY2MgLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+IGEgPVxuZnVuIGsgYWNjIGZtdCAtPlxuICBtYWtlX3ByaW50ZiBrIChBY2NfaW52YWxpZF9hcmcgKGFjYywgXCJQcmludGY6IGJhZCBjb252ZXJzaW9uICVfXCIpKSBmbXRcblxuKCogRml4IHBhZGRpbmcsIHRha2UgaXQgYXMgYW4gZXh0cmEgaW50ZWdlciBhcmd1bWVudCBpZiBuZWVkZWQuICopXG5hbmQgbWFrZV9wYWRkaW5nIDogdHlwZSB4IHogYSBiIGMgZCBlIGYgLlxuICAgICgoYiwgYykgYWNjIC0+IGYpIC0+IChiLCBjKSBhY2MgLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+XG4gICAgKHgsIHogLT4gYSkgcGFkZGluZyAtPiAoeiAtPiBzdHJpbmcpIC0+IHggPVxuICBmdW4gayBhY2MgZm10IHBhZCB0cmFucyAtPiBtYXRjaCBwYWQgd2l0aFxuICB8IE5vX3BhZGRpbmcgLT5cbiAgICBmdW4geCAtPlxuICAgICAgbGV0IG5ld19hY2MgPSBBY2NfZGF0YV9zdHJpbmcgKGFjYywgdHJhbnMgeCkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgbmV3X2FjYyBmbXRcbiAgfCBMaXRfcGFkZGluZyAocGFkdHksIHdpZHRoKSAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBsZXQgbmV3X2FjYyA9IEFjY19kYXRhX3N0cmluZyAoYWNjLCBmaXhfcGFkZGluZyBwYWR0eSB3aWR0aCAodHJhbnMgeCkpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG5ld19hY2MgZm10XG4gIHwgQXJnX3BhZGRpbmcgcGFkdHkgLT5cbiAgICBmdW4gdyB4IC0+XG4gICAgICBsZXQgbmV3X2FjYyA9IEFjY19kYXRhX3N0cmluZyAoYWNjLCBmaXhfcGFkZGluZyBwYWR0eSB3ICh0cmFucyB4KSkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgbmV3X2FjYyBmbXRcblxuKCogRml4IHBhZGRpbmcgYW5kIHByZWNpc2lvbiBmb3IgaW50LCBpbnQzMiwgbmF0aXZlaW50IG9yIGludDY0LiAqKVxuKCogVGFrZSBvbmUgb3IgdHdvIGV4dHJhIGludGVnZXIgYXJndW1lbnRzIGlmIG5lZWRlZC4gKilcbmFuZCBtYWtlX2ludF9wYWRkaW5nX3ByZWNpc2lvbiA6IHR5cGUgeCB5IHogYSBiIGMgZCBlIGYgLlxuICAgICgoYiwgYykgYWNjIC0+IGYpIC0+IChiLCBjKSBhY2MgLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+XG4gICAgKHgsIHkpIHBhZGRpbmcgLT4gKHksIHogLT4gYSkgcHJlY2lzaW9uIC0+IChpbnRfY29udiAtPiB6IC0+IHN0cmluZykgLT5cbiAgICBpbnRfY29udiAtPiB4ID1cbiAgZnVuIGsgYWNjIGZtdCBwYWQgcHJlYyB0cmFucyBpY29udiAtPiBtYXRjaCBwYWQsIHByZWMgd2l0aFxuICB8IE5vX3BhZGRpbmcsIE5vX3ByZWNpc2lvbiAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBsZXQgc3RyID0gdHJhbnMgaWNvbnYgeCBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IE5vX3BhZGRpbmcsIExpdF9wcmVjaXNpb24gcCAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X2ludF9wcmVjaXNpb24gcCAodHJhbnMgaWNvbnYgeCkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBOb19wYWRkaW5nLCBBcmdfcHJlY2lzaW9uIC0+XG4gICAgZnVuIHAgeCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9pbnRfcHJlY2lzaW9uIHAgKHRyYW5zIGljb252IHgpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgTGl0X3BhZGRpbmcgKHBhZHR5LCB3KSwgTm9fcHJlY2lzaW9uIC0+XG4gICAgZnVuIHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfcGFkZGluZyBwYWR0eSB3ICh0cmFucyBpY29udiB4KSBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IExpdF9wYWRkaW5nIChwYWR0eSwgdyksIExpdF9wcmVjaXNpb24gcCAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X3BhZGRpbmcgcGFkdHkgdyAoZml4X2ludF9wcmVjaXNpb24gcCAodHJhbnMgaWNvbnYgeCkpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgTGl0X3BhZGRpbmcgKHBhZHR5LCB3KSwgQXJnX3ByZWNpc2lvbiAtPlxuICAgIGZ1biBwIHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfcGFkZGluZyBwYWR0eSB3IChmaXhfaW50X3ByZWNpc2lvbiBwICh0cmFucyBpY29udiB4KSkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBBcmdfcGFkZGluZyBwYWR0eSwgTm9fcHJlY2lzaW9uIC0+XG4gICAgZnVuIHcgeCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgKHRyYW5zIGljb252IHgpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgQXJnX3BhZGRpbmcgcGFkdHksIExpdF9wcmVjaXNpb24gcCAtPlxuICAgIGZ1biB3IHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfcGFkZGluZyBwYWR0eSB3IChmaXhfaW50X3ByZWNpc2lvbiBwICh0cmFucyBpY29udiB4KSkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBBcmdfcGFkZGluZyBwYWR0eSwgQXJnX3ByZWNpc2lvbiAtPlxuICAgIGZ1biB3IHAgeCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgKGZpeF9pbnRfcHJlY2lzaW9uIHAgKHRyYW5zIGljb252IHgpKSBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuXG4oKiBDb252ZXJ0IGEgZmxvYXQsIGZpeCBwYWRkaW5nIGFuZCBwcmVjaXNpb24gaWYgbmVlZGVkLiAqKVxuKCogVGFrZSB0aGUgZmxvYXQgYXJndW1lbnQgYW5kIG9uZSBvciB0d28gZXh0cmEgaW50ZWdlciBhcmd1bWVudHMgaWYgbmVlZGVkLiAqKVxuYW5kIG1ha2VfZmxvYXRfcGFkZGluZ19wcmVjaXNpb24gOiB0eXBlIHggeSBhIGIgYyBkIGUgZiAuXG4gICAgKChiLCBjKSBhY2MgLT4gZikgLT4gKGIsIGMpIGFjYyAtPlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT5cbiAgICAoeCwgeSkgcGFkZGluZyAtPiAoeSwgZmxvYXQgLT4gYSkgcHJlY2lzaW9uIC0+IGZsb2F0X2NvbnYgLT4geCA9XG4gIGZ1biBrIGFjYyBmbXQgcGFkIHByZWMgZmNvbnYgLT4gbWF0Y2ggcGFkLCBwcmVjIHdpdGhcbiAgfCBOb19wYWRkaW5nLCBOb19wcmVjaXNpb24gLT5cbiAgICBmdW4geCAtPlxuICAgICAgbGV0IHN0ciA9IGNvbnZlcnRfZmxvYXQgZmNvbnYgKGRlZmF1bHRfZmxvYXRfcHJlY2lzaW9uIGZjb252KSB4IGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgTm9fcGFkZGluZywgTGl0X3ByZWNpc2lvbiBwIC0+XG4gICAgZnVuIHggLT5cbiAgICAgIGxldCBzdHIgPSBjb252ZXJ0X2Zsb2F0IGZjb252IHAgeCBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IE5vX3BhZGRpbmcsIEFyZ19wcmVjaXNpb24gLT5cbiAgICBmdW4gcCB4IC0+XG4gICAgICBsZXQgc3RyID0gY29udmVydF9mbG9hdCBmY29udiBwIHggaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBMaXRfcGFkZGluZyAocGFkdHksIHcpLCBOb19wcmVjaXNpb24gLT5cbiAgICBmdW4geCAtPlxuICAgICAgbGV0IHN0ciA9IGNvbnZlcnRfZmxvYXQgZmNvbnYgKGRlZmF1bHRfZmxvYXRfcHJlY2lzaW9uIGZjb252KSB4IGluXG4gICAgICBsZXQgc3RyJyA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgc3RyIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyJykpIGZtdFxuICB8IExpdF9wYWRkaW5nIChwYWR0eSwgdyksIExpdF9wcmVjaXNpb24gcCAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X3BhZGRpbmcgcGFkdHkgdyAoY29udmVydF9mbG9hdCBmY29udiBwIHgpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgTGl0X3BhZGRpbmcgKHBhZHR5LCB3KSwgQXJnX3ByZWNpc2lvbiAtPlxuICAgIGZ1biBwIHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfcGFkZGluZyBwYWR0eSB3IChjb252ZXJ0X2Zsb2F0IGZjb252IHAgeCkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBBcmdfcGFkZGluZyBwYWR0eSwgTm9fcHJlY2lzaW9uIC0+XG4gICAgZnVuIHcgeCAtPlxuICAgICAgbGV0IHN0ciA9IGNvbnZlcnRfZmxvYXQgZmNvbnYgKGRlZmF1bHRfZmxvYXRfcHJlY2lzaW9uIGZjb252KSB4IGluXG4gICAgICBsZXQgc3RyJyA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgc3RyIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyJykpIGZtdFxuICB8IEFyZ19wYWRkaW5nIHBhZHR5LCBMaXRfcHJlY2lzaW9uIHAgLT5cbiAgICBmdW4gdyB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X3BhZGRpbmcgcGFkdHkgdyAoY29udmVydF9mbG9hdCBmY29udiBwIHgpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgQXJnX3BhZGRpbmcgcGFkdHksIEFyZ19wcmVjaXNpb24gLT5cbiAgICBmdW4gdyBwIHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfcGFkZGluZyBwYWR0eSB3IChjb252ZXJ0X2Zsb2F0IGZjb252IHAgeCkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbmFuZCBtYWtlX2N1c3RvbSA6IHR5cGUgeCB5IGEgYiBjIGQgZSBmIC5cbiAgKChiLCBjKSBhY2MgLT4gZikgLT4gKGIsIGMpIGFjYyAtPlxuICAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+XG4gIChhLCB4LCB5KSBjdXN0b21fYXJpdHkgLT4geCAtPiB5ID1cbiAgZnVuIGsgYWNjIHJlc3QgYXJpdHkgZiAtPiBtYXRjaCBhcml0eSB3aXRoXG4gIHwgQ3VzdG9tX3plcm8gLT4gbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIGYpKSByZXN0XG4gIHwgQ3VzdG9tX3N1Y2MgYXJpdHkgLT5cbiAgICBmdW4geCAtPlxuICAgICAgbWFrZV9jdXN0b20gayBhY2MgcmVzdCBhcml0eSAoZiB4KVxuXG5sZXQgY29uc3QgeCBfID0geFxuXG5sZXQgcmVjIG1ha2VfaXByaW50ZiA6IHR5cGUgYSBiIGMgZCBlIGYgc3RhdGUuXG4gIChzdGF0ZSAtPiBmKSAtPiBzdGF0ZSAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+IGEgPVxuICBmdW4gayBvIGZtdCAtPiBtYXRjaCBmbXQgd2l0aFxuICAgIHwgQ2hhciByZXN0IC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBDYW1sX2NoYXIgcmVzdCAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgU3RyaW5nIChOb19wYWRkaW5nLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgU3RyaW5nIChMaXRfcGFkZGluZyBfLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgU3RyaW5nIChBcmdfcGFkZGluZyBfLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAoY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdCkpXG4gICAgfCBDYW1sX3N0cmluZyAoTm9fcGFkZGluZywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IENhbWxfc3RyaW5nIChMaXRfcGFkZGluZyBfLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgQ2FtbF9zdHJpbmcgKEFyZ19wYWRkaW5nIF8sIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KSlcbiAgICB8IEludCAoXywgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgICAgICBmbl9vZl9wYWRkaW5nX3ByZWNpc2lvbiBrIG8gcmVzdCBwYWQgcHJlY1xuICAgIHwgSW50MzIgKF8sIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICAgICAgZm5fb2ZfcGFkZGluZ19wcmVjaXNpb24gayBvIHJlc3QgcGFkIHByZWNcbiAgICB8IE5hdGl2ZWludCAoXywgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgICAgICBmbl9vZl9wYWRkaW5nX3ByZWNpc2lvbiBrIG8gcmVzdCBwYWQgcHJlY1xuICAgIHwgSW50NjQgKF8sIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICAgICAgZm5fb2ZfcGFkZGluZ19wcmVjaXNpb24gayBvIHJlc3QgcGFkIHByZWNcbiAgICB8IEZsb2F0IChfLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgICAgIGZuX29mX3BhZGRpbmdfcHJlY2lzaW9uIGsgbyByZXN0IHBhZCBwcmVjXG4gICAgfCBCb29sIChOb19wYWRkaW5nLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgQm9vbCAoTGl0X3BhZGRpbmcgXywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IEJvb2wgKEFyZ19wYWRkaW5nIF8sIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KSlcbiAgICB8IEFscGhhIHJlc3QgLT5cbiAgICAgICAgY29uc3QgKGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpKVxuICAgIHwgVGhldGEgcmVzdCAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgQ3VzdG9tIChhcml0eSwgXywgcmVzdCkgLT5cbiAgICAgICAgZm5fb2ZfY3VzdG9tX2FyaXR5IGsgbyByZXN0IGFyaXR5XG4gICAgfCBSZWFkZXIgXyAtPlxuICAgICAgICAoKiBUaGlzIGNhc2UgaXMgaW1wb3NzaWJsZSwgYnkgdHlwaW5nIG9mIGZvcm1hdHMuICBTZWUgdGhlXG4gICAgICAgICAgIG5vdGUgaW4gdGhlIGNvcnJlc3BvbmRpbmcgY2FzZSBmb3IgbWFrZV9wcmludGYuICopXG4gICAgICAgIGFzc2VydCBmYWxzZVxuICAgIHwgRmx1c2ggcmVzdCAtPlxuICAgICAgICBtYWtlX2lwcmludGYgayBvIHJlc3RcbiAgICB8IFN0cmluZ19saXRlcmFsIChfLCByZXN0KSAtPlxuICAgICAgICBtYWtlX2lwcmludGYgayBvIHJlc3RcbiAgICB8IENoYXJfbGl0ZXJhbCAoXywgcmVzdCkgLT5cbiAgICAgICAgbWFrZV9pcHJpbnRmIGsgbyByZXN0XG4gICAgfCBGb3JtYXRfYXJnIChfLCBfLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgRm9ybWF0X3N1YnN0IChfLCBmbXR0eSwgcmVzdCkgLT5cbiAgICAgICAgZnVuIChGb3JtYXQgKGZtdCwgXykpIC0+XG4gICAgICAgICAgbWFrZV9pcHJpbnRmIGsgb1xuICAgICAgICAgICAgKGNvbmNhdF9mbXQgKHJlY2FzdCBmbXQgZm10dHkpIHJlc3QpXG4gICAgfCBTY2FuX2NoYXJfc2V0IChfLCBfLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgU2Nhbl9nZXRfY291bnRlciAoXywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IFNjYW5fbmV4dF9jaGFyIHJlc3QgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IElnbm9yZWRfcGFyYW0gKGlnbiwgcmVzdCkgLT5cbiAgICAgICAgbWFrZV9pZ25vcmVkX3BhcmFtIChmdW4gXyAtPiBrIG8pIChFbmRfb2ZfYWNjKSBpZ24gcmVzdFxuICAgIHwgRm9ybWF0dGluZ19saXQgKF8sIHJlc3QpIC0+XG4gICAgICAgIG1ha2VfaXByaW50ZiBrIG8gcmVzdFxuICAgIHwgRm9ybWF0dGluZ19nZW4gKE9wZW5fdGFnIChGb3JtYXQgKGZtdCcsIF8pKSwgcmVzdCkgLT5cbiAgICAgICAgbWFrZV9pcHJpbnRmIChmdW4ga29jIC0+IG1ha2VfaXByaW50ZiBrIGtvYyByZXN0KSBvIGZtdCdcbiAgICB8IEZvcm1hdHRpbmdfZ2VuIChPcGVuX2JveCAoRm9ybWF0IChmbXQnLCBfKSksIHJlc3QpIC0+XG4gICAgICAgIG1ha2VfaXByaW50ZiAoZnVuIGtvYyAtPiBtYWtlX2lwcmludGYgayBrb2MgcmVzdCkgbyBmbXQnXG4gICAgfCBFbmRfb2ZfZm9ybWF0IC0+XG4gICAgICAgIGsgb1xuYW5kIGZuX29mX3BhZGRpbmdfcHJlY2lzaW9uIDpcbiAgdHlwZSB4IHkgeiBhIGIgYyBkIGUgZiBzdGF0ZS5cbiAgKHN0YXRlIC0+IGYpIC0+IHN0YXRlIC0+IChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT5cbiAgKHgsIHkpIHBhZGRpbmcgLT4gKHksIHogLT4gYSkgcHJlY2lzaW9uIC0+IHggPVxuICBmdW4gayBvIGZtdCBwYWQgcHJlYyAtPiBtYXRjaCBwYWQsIHByZWMgd2l0aFxuICAgIHwgTm9fcGFkZGluZyAgICwgTm9fcHJlY2lzaW9uICAgIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIGZtdClcbiAgICB8IE5vX3BhZGRpbmcgICAsIExpdF9wcmVjaXNpb24gXyAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyBmbXQpXG4gICAgfCBOb19wYWRkaW5nICAgLCBBcmdfcHJlY2lzaW9uICAgLT5cbiAgICAgICAgY29uc3QgKGNvbnN0IChtYWtlX2lwcmludGYgayBvIGZtdCkpXG4gICAgfCBMaXRfcGFkZGluZyBfLCBOb19wcmVjaXNpb24gICAgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gZm10KVxuICAgIHwgTGl0X3BhZGRpbmcgXywgTGl0X3ByZWNpc2lvbiBfIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIGZtdClcbiAgICB8IExpdF9wYWRkaW5nIF8sIEFyZ19wcmVjaXNpb24gICAtPlxuICAgICAgICBjb25zdCAoY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gZm10KSlcbiAgICB8IEFyZ19wYWRkaW5nIF8sIE5vX3ByZWNpc2lvbiAgICAtPlxuICAgICAgICBjb25zdCAoY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gZm10KSlcbiAgICB8IEFyZ19wYWRkaW5nIF8sIExpdF9wcmVjaXNpb24gXyAtPlxuICAgICAgICBjb25zdCAoY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gZm10KSlcbiAgICB8IEFyZ19wYWRkaW5nIF8sIEFyZ19wcmVjaXNpb24gICAtPlxuICAgICAgICBjb25zdCAoY29uc3QgKGNvbnN0IChtYWtlX2lwcmludGYgayBvIGZtdCkpKVxuYW5kIGZuX29mX2N1c3RvbV9hcml0eSA6IHR5cGUgeCB5IGEgYiBjIGQgZSBmIHN0YXRlLlxuICAoc3RhdGUgLT4gZikgLT5cbiAgc3RhdGUgLT4gKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPiAoYSwgeCwgeSkgY3VzdG9tX2FyaXR5IC0+IHkgPVxuICBmdW4gayBvIGZtdCAtPiBmdW5jdGlvblxuICAgIHwgQ3VzdG9tX3plcm8gLT5cbiAgICAgICAgbWFrZV9pcHJpbnRmIGsgbyBmbXRcbiAgICB8IEN1c3RvbV9zdWNjIGFyaXR5IC0+XG4gICAgICAgIGNvbnN0IChmbl9vZl9jdXN0b21fYXJpdHkgayBvIGZtdCBhcml0eSlcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQ29udGludWF0aW9ucyBmb3IgbWFrZV9wcmludGYgKilcblxuKCogUmVjdXJzaXZlbHkgb3V0cHV0IGFuIFwiYWNjdW11bGF0b3JcIiBjb250YWluaW5nIGEgcmV2ZXJzZWQgbGlzdCBvZlxuICAgcHJpbnRpbmcgZW50aXRpZXMgKHN0cmluZywgY2hhciwgZmx1cywgLi4uKSBpbiBhbiBvdXRwdXRfc3RyZWFtLiAqKVxuKCogVXNlZCBhcyBhIGNvbnRpbnVhdGlvbiBvZiBtYWtlX3ByaW50Zi4gKilcbmxldCByZWMgb3V0cHV0X2FjYyBvIGFjYyA9IG1hdGNoIGFjYyB3aXRoXG4gIHwgQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBmbXRpbmdfbGl0KSAtPlxuICAgIGxldCBzID0gc3RyaW5nX29mX2Zvcm1hdHRpbmdfbGl0IGZtdGluZ19saXQgaW5cbiAgICBvdXRwdXRfYWNjIG8gcDsgb3V0cHV0X3N0cmluZyBvIHM7XG4gIHwgQWNjX2Zvcm1hdHRpbmdfZ2VuIChwLCBBY2Nfb3Blbl90YWcgYWNjJykgLT5cbiAgICBvdXRwdXRfYWNjIG8gcDsgb3V0cHV0X3N0cmluZyBvIFwiQHtcIjsgb3V0cHV0X2FjYyBvIGFjYyc7XG4gIHwgQWNjX2Zvcm1hdHRpbmdfZ2VuIChwLCBBY2Nfb3Blbl9ib3ggYWNjJykgLT5cbiAgICBvdXRwdXRfYWNjIG8gcDsgb3V0cHV0X3N0cmluZyBvIFwiQFtcIjsgb3V0cHV0X2FjYyBvIGFjYyc7XG4gIHwgQWNjX3N0cmluZ19saXRlcmFsIChwLCBzKVxuICB8IEFjY19kYXRhX3N0cmluZyAocCwgcykgICAtPiBvdXRwdXRfYWNjIG8gcDsgb3V0cHV0X3N0cmluZyBvIHNcbiAgfCBBY2NfY2hhcl9saXRlcmFsIChwLCBjKVxuICB8IEFjY19kYXRhX2NoYXIgKHAsIGMpICAgICAtPiBvdXRwdXRfYWNjIG8gcDsgb3V0cHV0X2NoYXIgbyBjXG4gIHwgQWNjX2RlbGF5IChwLCBmKSAgICAgICAgIC0+IG91dHB1dF9hY2MgbyBwOyBmIG9cbiAgfCBBY2NfZmx1c2ggcCAgICAgICAgICAgICAgLT4gb3V0cHV0X2FjYyBvIHA7IGZsdXNoIG9cbiAgfCBBY2NfaW52YWxpZF9hcmcgKHAsIG1zZykgLT4gb3V0cHV0X2FjYyBvIHA7IGludmFsaWRfYXJnIG1zZztcbiAgfCBFbmRfb2ZfYWNjICAgICAgICAgICAgICAgLT4gKClcblxuKCogUmVjdXJzaXZlbHkgb3V0cHV0IGFuIFwiYWNjdW11bGF0b3JcIiBjb250YWluaW5nIGEgcmV2ZXJzZWQgbGlzdCBvZlxuICAgcHJpbnRpbmcgZW50aXRpZXMgKHN0cmluZywgY2hhciwgZmx1cywgLi4uKSBpbiBhIGJ1ZmZlci4gKilcbigqIFVzZWQgYXMgYSBjb250aW51YXRpb24gb2YgbWFrZV9wcmludGYuICopXG5sZXQgcmVjIGJ1ZnB1dF9hY2MgYiBhY2MgPSBtYXRjaCBhY2Mgd2l0aFxuICB8IEFjY19mb3JtYXR0aW5nX2xpdCAocCwgZm10aW5nX2xpdCkgLT5cbiAgICBsZXQgcyA9IHN0cmluZ19vZl9mb3JtYXR0aW5nX2xpdCBmbXRpbmdfbGl0IGluXG4gICAgYnVmcHV0X2FjYyBiIHA7IEJ1ZmZlci5hZGRfc3RyaW5nIGIgcztcbiAgfCBBY2NfZm9ybWF0dGluZ19nZW4gKHAsIEFjY19vcGVuX3RhZyBhY2MnKSAtPlxuICAgIGJ1ZnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX3N0cmluZyBiIFwiQHtcIjsgYnVmcHV0X2FjYyBiIGFjYyc7XG4gIHwgQWNjX2Zvcm1hdHRpbmdfZ2VuIChwLCBBY2Nfb3Blbl9ib3ggYWNjJykgLT5cbiAgICBidWZwdXRfYWNjIGIgcDsgQnVmZmVyLmFkZF9zdHJpbmcgYiBcIkBbXCI7IGJ1ZnB1dF9hY2MgYiBhY2MnO1xuICB8IEFjY19zdHJpbmdfbGl0ZXJhbCAocCwgcylcbiAgfCBBY2NfZGF0YV9zdHJpbmcgKHAsIHMpICAgLT4gYnVmcHV0X2FjYyBiIHA7IEJ1ZmZlci5hZGRfc3RyaW5nIGIgc1xuICB8IEFjY19jaGFyX2xpdGVyYWwgKHAsIGMpXG4gIHwgQWNjX2RhdGFfY2hhciAocCwgYykgICAgIC0+IGJ1ZnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX2NoYXIgYiBjXG4gIHwgQWNjX2RlbGF5IChwLCBmKSAgICAgICAgIC0+IGJ1ZnB1dF9hY2MgYiBwOyBmIGJcbiAgfCBBY2NfZmx1c2ggcCAgICAgICAgICAgICAgLT4gYnVmcHV0X2FjYyBiIHA7XG4gIHwgQWNjX2ludmFsaWRfYXJnIChwLCBtc2cpIC0+IGJ1ZnB1dF9hY2MgYiBwOyBpbnZhbGlkX2FyZyBtc2c7XG4gIHwgRW5kX29mX2FjYyAgICAgICAgICAgICAgIC0+ICgpXG5cbigqIFJlY3Vyc2l2ZWx5IG91dHB1dCBhbiBcImFjY3VtdWxhdG9yXCIgY29udGFpbmluZyBhIHJldmVyc2VkIGxpc3Qgb2ZcbiAgIHByaW50aW5nIGVudGl0aWVzIChzdHJpbmcsIGNoYXIsIGZsdXMsIC4uLikgaW4gYSBidWZmZXIuICopXG4oKiBEaWZmZXIgZnJvbSBidWZwdXRfYWNjIGJ5IHRoZSBpbnRlcnByZXRhdGlvbiBvZiAlYSBhbmQgJXQuICopXG4oKiBVc2VkIGFzIGEgY29udGludWF0aW9uIG9mIG1ha2VfcHJpbnRmLiAqKVxubGV0IHJlYyBzdHJwdXRfYWNjIGIgYWNjID0gbWF0Y2ggYWNjIHdpdGhcbiAgfCBBY2NfZm9ybWF0dGluZ19saXQgKHAsIGZtdGluZ19saXQpIC0+XG4gICAgbGV0IHMgPSBzdHJpbmdfb2ZfZm9ybWF0dGluZ19saXQgZm10aW5nX2xpdCBpblxuICAgIHN0cnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX3N0cmluZyBiIHM7XG4gIHwgQWNjX2Zvcm1hdHRpbmdfZ2VuIChwLCBBY2Nfb3Blbl90YWcgYWNjJykgLT5cbiAgICBzdHJwdXRfYWNjIGIgcDsgQnVmZmVyLmFkZF9zdHJpbmcgYiBcIkB7XCI7IHN0cnB1dF9hY2MgYiBhY2MnO1xuICB8IEFjY19mb3JtYXR0aW5nX2dlbiAocCwgQWNjX29wZW5fYm94IGFjYycpIC0+XG4gICAgc3RycHV0X2FjYyBiIHA7IEJ1ZmZlci5hZGRfc3RyaW5nIGIgXCJAW1wiOyBzdHJwdXRfYWNjIGIgYWNjJztcbiAgfCBBY2Nfc3RyaW5nX2xpdGVyYWwgKHAsIHMpXG4gIHwgQWNjX2RhdGFfc3RyaW5nIChwLCBzKSAgIC0+IHN0cnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX3N0cmluZyBiIHNcbiAgfCBBY2NfY2hhcl9saXRlcmFsIChwLCBjKVxuICB8IEFjY19kYXRhX2NoYXIgKHAsIGMpICAgICAtPiBzdHJwdXRfYWNjIGIgcDsgQnVmZmVyLmFkZF9jaGFyIGIgY1xuICB8IEFjY19kZWxheSAocCwgZikgICAgICAgICAtPiBzdHJwdXRfYWNjIGIgcDsgQnVmZmVyLmFkZF9zdHJpbmcgYiAoZiAoKSlcbiAgfCBBY2NfZmx1c2ggcCAgICAgICAgICAgICAgLT4gc3RycHV0X2FjYyBiIHA7XG4gIHwgQWNjX2ludmFsaWRfYXJnIChwLCBtc2cpIC0+IHN0cnB1dF9hY2MgYiBwOyBpbnZhbGlkX2FyZyBtc2c7XG4gIHwgRW5kX29mX2FjYyAgICAgICAgICAgICAgIC0+ICgpXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICgqIEVycm9yIG1hbmFnZW1lbnQgKilcblxuKCogUmFpc2UgW0ZhaWx1cmVdIHdpdGggYSBwcmV0dHktcHJpbnRlZCBlcnJvciBtZXNzYWdlLiAqKVxubGV0IGZhaWx3aXRoX21lc3NhZ2UgKEZvcm1hdCAoZm10LCBfKSkgPVxuICBsZXQgYnVmID0gQnVmZmVyLmNyZWF0ZSAyNTYgaW5cbiAgbGV0IGsgYWNjID0gc3RycHV0X2FjYyBidWYgYWNjOyBmYWlsd2l0aCAoQnVmZmVyLmNvbnRlbnRzIGJ1ZikgaW5cbiAgbWFrZV9wcmludGYgayBFbmRfb2ZfYWNjIGZtdFxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEZvcm1hdHRpbmcgdG9vbHMgKilcblxuKCogQ29udmVydCBhIHN0cmluZyB0byBhbiBvcGVuIGJsb2NrIGRlc2NyaXB0aW9uIChpbmRlbnQsIGJsb2NrX3R5cGUpICopXG5sZXQgb3Blbl9ib3hfb2Zfc3RyaW5nIHN0ciA9XG4gIGlmIHN0ciA9IFwiXCIgdGhlbiAoMCwgUHBfYm94KSBlbHNlXG4gICAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggc3RyIGluXG4gICAgbGV0IGludmFsaWRfYm94ICgpID0gZmFpbHdpdGhfbWVzc2FnZSBcImludmFsaWQgYm94IGRlc2NyaXB0aW9uICVTXCIgc3RyIGluXG4gICAgbGV0IHJlYyBwYXJzZV9zcGFjZXMgaSA9XG4gICAgICBpZiBpID0gbGVuIHRoZW4gaSBlbHNlXG4gICAgICAgIG1hdGNoIHN0ci5baV0gd2l0aFxuICAgICAgICB8ICcgJyB8ICdcXHQnIC0+IHBhcnNlX3NwYWNlcyAoaSArIDEpXG4gICAgICAgIHwgXyAtPiBpXG4gICAgYW5kIHBhcnNlX2x3b3JkIGkgaiA9XG4gICAgICBpZiBqID0gbGVuIHRoZW4gaiBlbHNlXG4gICAgICAgIG1hdGNoIHN0ci5bal0gd2l0aFxuICAgICAgICB8ICdhJyAuLiAneicgLT4gcGFyc2VfbHdvcmQgaSAoaiArIDEpXG4gICAgICAgIHwgXyAtPiBqXG4gICAgYW5kIHBhcnNlX2ludCBpIGogPVxuICAgICAgaWYgaiA9IGxlbiB0aGVuIGogZWxzZVxuICAgICAgICBtYXRjaCBzdHIuW2pdIHdpdGhcbiAgICAgICAgfCAnMCcgLi4gJzknIHwgJy0nIC0+IHBhcnNlX2ludCBpIChqICsgMSlcbiAgICAgICAgfCBfIC0+IGogaW5cbiAgICBsZXQgd3N0YXJ0ID0gcGFyc2Vfc3BhY2VzIDAgaW5cbiAgICBsZXQgd2VuZCA9IHBhcnNlX2x3b3JkIHdzdGFydCB3c3RhcnQgaW5cbiAgICBsZXQgYm94X25hbWUgPSBTdHJpbmcuc3ViIHN0ciB3c3RhcnQgKHdlbmQgLSB3c3RhcnQpIGluXG4gICAgbGV0IG5zdGFydCA9IHBhcnNlX3NwYWNlcyB3ZW5kIGluXG4gICAgbGV0IG5lbmQgPSBwYXJzZV9pbnQgbnN0YXJ0IG5zdGFydCBpblxuICAgIGxldCBpbmRlbnQgPVxuICAgICAgaWYgbnN0YXJ0ID0gbmVuZCB0aGVuIDAgZWxzZVxuICAgICAgICB0cnkgaW50X29mX3N0cmluZyAoU3RyaW5nLnN1YiBzdHIgbnN0YXJ0IChuZW5kIC0gbnN0YXJ0KSlcbiAgICAgICAgd2l0aCBGYWlsdXJlIF8gLT4gaW52YWxpZF9ib3ggKCkgaW5cbiAgICBsZXQgZXhwX2VuZCA9IHBhcnNlX3NwYWNlcyBuZW5kIGluXG4gICAgaWYgZXhwX2VuZCA8PiBsZW4gdGhlbiBpbnZhbGlkX2JveCAoKTtcbiAgICBsZXQgYm94X3R5cGUgPSBtYXRjaCBib3hfbmFtZSB3aXRoXG4gICAgICB8IFwiXCIgfCBcImJcIiAtPiBQcF9ib3hcbiAgICAgIHwgXCJoXCIgICAgICAtPiBQcF9oYm94XG4gICAgICB8IFwidlwiICAgICAgLT4gUHBfdmJveFxuICAgICAgfCBcImh2XCIgICAgIC0+IFBwX2h2Ym94XG4gICAgICB8IFwiaG92XCIgICAgLT4gUHBfaG92Ym94XG4gICAgICB8IF8gICAgICAgIC0+IGludmFsaWRfYm94ICgpIGluXG4gICAgKGluZGVudCwgYm94X3R5cGUpXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogUGFyc2luZyB0b29scyAqKVxuXG4oKiBDcmVhdGUgYSBwYWRkaW5nX2ZtdF9lYmIgZnJvbSBhIHBhZGRpbmcgYW5kIGEgZm9ybWF0LiAqKVxuKCogQ29weSB0aGUgcGFkZGluZyB0byBkaXNqb2luIHRoZSB0eXBlIHBhcmFtZXRlcnMgb2YgYXJndW1lbnQgYW5kIHJlc3VsdC4gKilcbmxldCBtYWtlX3BhZGRpbmdfZm10X2ViYiA6IHR5cGUgeCB5IC5cbiAgICAoeCwgeSkgcGFkZGluZyAtPiAoXywgXywgXywgXywgXywgXykgZm10IC0+XG4gICAgICAoXywgXywgXywgXywgXykgcGFkZGluZ19mbXRfZWJiID1cbmZ1biBwYWQgZm10IC0+IG1hdGNoIHBhZCB3aXRoXG4gIHwgTm9fcGFkZGluZyAgICAgICAgIC0+IFBhZGRpbmdfZm10X0VCQiAoTm9fcGFkZGluZywgZm10KVxuICB8IExpdF9wYWRkaW5nIChzLCB3KSAtPiBQYWRkaW5nX2ZtdF9FQkIgKExpdF9wYWRkaW5nIChzLCB3KSwgZm10KVxuICB8IEFyZ19wYWRkaW5nIHMgICAgICAtPiBQYWRkaW5nX2ZtdF9FQkIgKEFyZ19wYWRkaW5nIHMsIGZtdClcblxuKCogQ3JlYXRlIGEgcHJlY2lzaW9uX2ZtdF9lYmIgZnJvbSBhIHByZWNpc2lvbiBhbmQgYSBmb3JtYXQuICopXG4oKiBDb3B5IHRoZSBwcmVjaXNpb24gdG8gZGlzam9pbiB0aGUgdHlwZSBwYXJhbWV0ZXJzIG9mIGFyZ3VtZW50IGFuZCByZXN1bHQuICopXG5sZXQgbWFrZV9wcmVjaXNpb25fZm10X2ViYiA6IHR5cGUgeCB5IC5cbiAgICAoeCwgeSkgcHJlY2lzaW9uIC0+IChfLCBfLCBfLCBfLCBfLCBfKSBmbXQgLT5cbiAgICAgIChfLCBfLCBfLCBfLCBfKSBwcmVjaXNpb25fZm10X2ViYiA9XG5mdW4gcHJlYyBmbXQgLT4gbWF0Y2ggcHJlYyB3aXRoXG4gIHwgTm9fcHJlY2lzaW9uICAgIC0+IFByZWNpc2lvbl9mbXRfRUJCIChOb19wcmVjaXNpb24sIGZtdClcbiAgfCBMaXRfcHJlY2lzaW9uIHAgLT4gUHJlY2lzaW9uX2ZtdF9FQkIgKExpdF9wcmVjaXNpb24gcCwgZm10KVxuICB8IEFyZ19wcmVjaXNpb24gICAtPiBQcmVjaXNpb25fZm10X0VCQiAoQXJnX3ByZWNpc2lvbiwgZm10KVxuXG4oKiBDcmVhdGUgYSBwYWRwcmVjX2ZtdF9lYmIgZnJvbSBhIHBhZGRpbmcsIGEgcHJlY2lzaW9uIGFuZCBhIGZvcm1hdC4gKilcbigqIENvcHkgdGhlIHBhZGRpbmcgYW5kIHRoZSBwcmVjaXNpb24gdG8gZGlzam9pbiB0eXBlIHBhcmFtZXRlcnMgb2YgYXJndW1lbnRzXG4gICBhbmQgcmVzdWx0LiAqKVxubGV0IG1ha2VfcGFkcHJlY19mbXRfZWJiIDogdHlwZSB4IHkgeiB0IC5cbiAgICAoeCwgeSkgcGFkZGluZyAtPiAoeiwgdCkgcHJlY2lzaW9uIC0+XG4gICAgKF8sIF8sIF8sIF8sIF8sIF8pIGZtdCAtPlxuICAgIChfLCBfLCBfLCBfLCBfKSBwYWRwcmVjX2ZtdF9lYmIgPVxuZnVuIHBhZCBwcmVjIGZtdCAtPlxuICBsZXQgUHJlY2lzaW9uX2ZtdF9FQkIgKHByZWMsIGZtdCcpID0gbWFrZV9wcmVjaXNpb25fZm10X2ViYiBwcmVjIGZtdCBpblxuICBtYXRjaCBwYWQgd2l0aFxuICB8IE5vX3BhZGRpbmcgICAgICAgICAtPiBQYWRwcmVjX2ZtdF9FQkIgKE5vX3BhZGRpbmcsIHByZWMsIGZtdCcpXG4gIHwgTGl0X3BhZGRpbmcgKHMsIHcpIC0+IFBhZHByZWNfZm10X0VCQiAoTGl0X3BhZGRpbmcgKHMsIHcpLCBwcmVjLCBmbXQnKVxuICB8IEFyZ19wYWRkaW5nIHMgICAgICAtPiBQYWRwcmVjX2ZtdF9FQkIgKEFyZ19wYWRkaW5nIHMsIHByZWMsIGZtdCcpXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEZvcm1hdCBwYXJzaW5nICopXG5cbigqIFBhcnNlIGEgc3RyaW5nIHJlcHJlc2VudGluZyBhIGZvcm1hdCBhbmQgY3JlYXRlIGEgZm10X2ViYi4gKilcbigqIFJhaXNlIFtGYWlsdXJlXSBpbiBjYXNlIG9mIGludmFsaWQgZm9ybWF0LiAqKVxubGV0IGZtdF9lYmJfb2Zfc3RyaW5nID9sZWdhY3lfYmVoYXZpb3Igc3RyID1cbiAgKCogUGFyYW1ldGVycyBuYW1pbmcgY29udmVudGlvbjogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuICAoKiAgIC0gbGl0X3N0YXJ0OiBzdGFydCBvZiB0aGUgbGl0ZXJhbCBzZXF1ZW5jZS4gICAgICAgICAgICAgICAgICAgICopXG4gICgqICAgLSBzdHJfaW5kOiBjdXJyZW50IGluZGV4IGluIHRoZSBzdHJpbmcuICAgICAgICAgICAgICAgICAgICAgICAgKilcbiAgKCogICAtIGVuZF9pbmQ6IGVuZCBvZiB0aGUgY3VycmVudCAoc3ViLSlmb3JtYXQuICAgICAgICAgICAgICAgICAgICAqKVxuICAoKiAgIC0gcGN0X2luZDogaW5kZXggb2YgdGhlICclJyBpbiB0aGUgY3VycmVudCBtaWNyby1mb3JtYXQuICAgICAgICopXG4gICgqICAgLSB6ZXJvOiAgaXMgdGhlICcwJyBmbGFnIGRlZmluZWQgaW4gdGhlIGN1cnJlbnQgbWljcm8tZm9ybWF0LiAgKilcbiAgKCogICAtIG1pbnVzOiBpcyB0aGUgJy0nIGZsYWcgZGVmaW5lZCBpbiB0aGUgY3VycmVudCBtaWNyby1mb3JtYXQuICAqKVxuICAoKiAgIC0gcGx1czogIGlzIHRoZSAnKycgZmxhZyBkZWZpbmVkIGluIHRoZSBjdXJyZW50IG1pY3JvLWZvcm1hdC4gICopXG4gICgqICAgLSBoYXNoOiAgaXMgdGhlICcjJyBmbGFnIGRlZmluZWQgaW4gdGhlIGN1cnJlbnQgbWljcm8tZm9ybWF0LiAgKilcbiAgKCogICAtIHNwYWNlOiBpcyB0aGUgJyAnIGZsYWcgZGVmaW5lZCBpbiB0aGUgY3VycmVudCBtaWNyby1mb3JtYXQuICAqKVxuICAoKiAgIC0gaWduOiAgIGlzIHRoZSAnXycgZmxhZyBkZWZpbmVkIGluIHRoZSBjdXJyZW50IG1pY3JvLWZvcm1hdC4gICopXG4gICgqICAgLSBwYWQ6IHBhZGRpbmcgb2YgdGhlIGN1cnJlbnQgbWljcm8tZm9ybWF0LiAgICAgICAgICAgICAgICAgICAgKilcbiAgKCogICAtIHByZWM6IHByZWNpc2lvbiBvZiB0aGUgY3VycmVudCBtaWNyby1mb3JtYXQuICAgICAgICAgICAgICAgICAqKVxuICAoKiAgIC0gc3ltYjogY2hhciByZXByZXNlbnRpbmcgdGhlIGNvbnZlcnNpb24gKCdjJywgJ3MnLCAnZCcsIC4uLikuICopXG4gICgqICAgLSBjaGFyX3NldDogc2V0IG9mIGNoYXJhY3RlcnMgYXMgYml0bWFwIChzZWUgc2NhbmYgJVsuLi5dKS4gICAgKilcblxuICBsZXQgbGVnYWN5X2JlaGF2aW9yID0gbWF0Y2ggbGVnYWN5X2JlaGF2aW9yIHdpdGhcbiAgICB8IFNvbWUgZmxhZyAtPiBmbGFnXG4gICAgfCBOb25lIC0+IHRydWVcbiAgKCogIFdoZW4gdGhpcyBmbGFnIGlzIGVuYWJsZWQsIHRoZSBmb3JtYXQgcGFyc2VyIHRyaWVzIHRvIGJlaGF2ZSBhc1xuICAgICAgdGhlIDw0LjAyIGltcGxlbWVudGF0aW9ucywgaW4gcGFydGljdWxhciBpdCBpZ25vcmVzIG1vc3QgYmVuaW5lXG4gICAgICBub25zZW5zaWNhbCBmb3JtYXQuIFdoZW4gdGhlIGZsYWcgaXMgZGlzYWJsZWQsIGl0IHdpbGwgcmVqZWN0IGFueVxuICAgICAgZm9ybWF0IHRoYXQgaXMgbm90IGFjY2VwdGVkIGJ5IHRoZSBzcGVjaWZpY2F0aW9uLlxuXG4gICAgICBBIHR5cGljYWwgZXhhbXBsZSB3b3VsZCBiZSBcIiUrIGRcIjogc3BlY2lmeWluZyBib3RoICcrJyAoaWYgdGhlXG4gICAgICBudW1iZXIgaXMgcG9zaXRpdmUsIHBhZCB3aXRoIGEgJysnIHRvIGdldCB0aGUgc2FtZSB3aWR0aCBhc1xuICAgICAgbmVnYXRpdmUgbnVtYmVycykgYW5kICcgJyAoaWYgdGhlIG51bWJlciBpcyBwb3NpdGl2ZSwgcGFkIHdpdGhcbiAgICAgIGEgc3BhY2UpIGRvZXMgbm90IG1ha2Ugc2Vuc2UsIGJ1dCB0aGUgbGVnYWN5ICg8IDQuMDIpXG4gICAgICBpbXBsZW1lbnRhdGlvbiB3YXMgaGFwcHkgdG8ganVzdCBpZ25vcmUgdGhlIHNwYWNlLlxuICAqKVxuICBpblxuXG4gICgqIFJhaXNlIFtGYWlsdXJlXSB3aXRoIGEgZnJpZW5kbHkgZXJyb3IgbWVzc2FnZS4gKilcbiAgbGV0IGludmFsaWRfZm9ybWF0X21lc3NhZ2Ugc3RyX2luZCBtc2cgPVxuICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgIFwiaW52YWxpZCBmb3JtYXQgJVM6IGF0IGNoYXJhY3RlciBudW1iZXIgJWQsICVzXCJcbiAgICAgIHN0ciBzdHJfaW5kIG1zZ1xuICBpblxuXG4gICgqIFVzZWQgd2hlbiB0aGUgZW5kIG9mIHRoZSBmb3JtYXQgKG9yIHRoZSBjdXJyZW50IHN1Yi1mb3JtYXQpIHdhcyBlbmNvdW50ZXJlZFxuICAgICAgdW5leHBlY3RlZGx5LiAqKVxuICBsZXQgdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQgPVxuICAgIGludmFsaWRfZm9ybWF0X21lc3NhZ2UgZW5kX2luZFxuICAgICAgXCJ1bmV4cGVjdGVkIGVuZCBvZiBmb3JtYXRcIlxuICBpblxuXG4gICgqIFVzZWQgZm9yICUwYzogbm8gb3RoZXIgd2lkdGhzIGFyZSBpbXBsZW1lbnRlZCAqKVxuICBsZXQgaW52YWxpZF9ub25udWxsX2NoYXJfd2lkdGggc3RyX2luZCA9XG4gICAgaW52YWxpZF9mb3JtYXRfbWVzc2FnZSBzdHJfaW5kXG4gICAgICBcIm5vbi16ZXJvIHdpZHRocyBhcmUgdW5zdXBwb3J0ZWQgZm9yICVjIGNvbnZlcnNpb25zXCJcbiAgaW5cbiAgKCogUmFpc2UgW0ZhaWx1cmVdIHdpdGggYSBmcmllbmRseSBlcnJvciBtZXNzYWdlIGFib3V0IGFuIG9wdGlvbiBkZXBlbmRlbmN5XG4gICAgIHByb2JsZW0uICopXG4gIGxldCBpbnZhbGlkX2Zvcm1hdF93aXRob3V0IHN0cl9pbmQgYyBzID1cbiAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICBcImludmFsaWQgZm9ybWF0ICVTOiBhdCBjaGFyYWN0ZXIgbnVtYmVyICVkLCAnJWMnIHdpdGhvdXQgJXNcIlxuICAgICAgc3RyIHN0cl9pbmQgYyBzXG4gIGluXG5cbiAgKCogUmFpc2UgW0ZhaWx1cmVdIHdpdGggYSBmcmllbmRseSBlcnJvciBtZXNzYWdlIGFib3V0IGFuIHVuZXhwZWN0ZWRcbiAgICAgY2hhcmFjdGVyLiAqKVxuICBsZXQgZXhwZWN0ZWRfY2hhcmFjdGVyIHN0cl9pbmQgZXhwZWN0ZWQgcmVhZCA9XG4gICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICBcImludmFsaWQgZm9ybWF0ICVTOiBhdCBjaGFyYWN0ZXIgbnVtYmVyICVkLCAlcyBleHBlY3RlZCwgcmVhZCAlQ1wiXG4gICAgICBzdHIgc3RyX2luZCBleHBlY3RlZCByZWFkXG4gIGluXG5cbiAgKCogUGFyc2UgdGhlIHN0cmluZyBmcm9tIGJlZ19pbmQgKGluY2x1ZGVkKSB0byBlbmRfaW5kIChleGNsdWRlZCkuICopXG4gIGxldCByZWMgcGFyc2UgOiB0eXBlIGUgZiAuIGludCAtPiBpbnQgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gYmVnX2luZCBlbmRfaW5kIC0+IHBhcnNlX2xpdGVyYWwgYmVnX2luZCBiZWdfaW5kIGVuZF9pbmRcblxuICAoKiBSZWFkIGxpdGVyYWwgY2hhcmFjdGVycyB1cCB0byAnJScgb3IgJ0AnIHNwZWNpYWwgY2hhcmFjdGVycy4gKilcbiAgYW5kIHBhcnNlX2xpdGVyYWwgOiB0eXBlIGUgZiAuIGludCAtPiBpbnQgLT4gaW50IC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIGxpdF9zdGFydCBzdHJfaW5kIGVuZF9pbmQgLT5cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIGFkZF9saXRlcmFsIGxpdF9zdGFydCBzdHJfaW5kIEVuZF9vZl9mb3JtYXQgZWxzZVxuICAgICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgICB8ICclJyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlX2Zvcm1hdCBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgICAgYWRkX2xpdGVyYWwgbGl0X3N0YXJ0IHN0cl9pbmQgZm10X3Jlc3RcbiAgICAgIHwgJ0AnIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2VfYWZ0ZXJfYXQgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICAgIGFkZF9saXRlcmFsIGxpdF9zdGFydCBzdHJfaW5kIGZtdF9yZXN0XG4gICAgICB8IF8gLT5cbiAgICAgICAgcGFyc2VfbGl0ZXJhbCBsaXRfc3RhcnQgKHN0cl9pbmQgKyAxKSBlbmRfaW5kXG5cbiAgKCogUGFyc2UgYSBmb3JtYXQgYWZ0ZXIgJyUnICopXG4gIGFuZCBwYXJzZV9mb3JtYXQgOiB0eXBlIGUgZiAuIGludCAtPiBpbnQgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gcGN0X2luZCBlbmRfaW5kIC0+IHBhcnNlX2lnbiBwY3RfaW5kIChwY3RfaW5kICsgMSkgZW5kX2luZFxuXG4gIGFuZCBwYXJzZV9pZ24gOiB0eXBlIGUgZiAuIGludCAtPiBpbnQgLT4gaW50IC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIC0+XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICAgIHwgJ18nIC0+IHBhcnNlX2ZsYWdzIHBjdF9pbmQgKHN0cl9pbmQrMSkgZW5kX2luZCB0cnVlXG4gICAgICB8IF8gLT4gcGFyc2VfZmxhZ3MgcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgZmFsc2VcblxuICBhbmQgcGFyc2VfZmxhZ3MgOiB0eXBlIGUgZiAuIGludCAtPiBpbnQgLT4gaW50IC0+IGJvb2wgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmJcbiAgPVxuICBmdW4gcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgaWduIC0+XG4gICAgbGV0IHplcm8gPSByZWYgZmFsc2UgYW5kIG1pbnVzID0gcmVmIGZhbHNlXG4gICAgYW5kIHBsdXMgPSByZWYgZmFsc2UgYW5kIHNwYWNlID0gcmVmIGZhbHNlXG4gICAgYW5kIGhhc2ggPSByZWYgZmFsc2UgaW5cbiAgICBsZXQgc2V0X2ZsYWcgc3RyX2luZCBmbGFnID1cbiAgICAgICgqIGluIGxlZ2FjeSBtb2RlLCBkdXBsaWNhdGUgZmxhZ3MgYXJlIGFjY2VwdGVkICopXG4gICAgICBpZiAhZmxhZyAmJiBub3QgbGVnYWN5X2JlaGF2aW9yIHRoZW5cbiAgICAgICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgICAgIFwiaW52YWxpZCBmb3JtYXQgJVM6IGF0IGNoYXJhY3RlciBudW1iZXIgJWQsIGR1cGxpY2F0ZSBmbGFnICVDXCJcbiAgICAgICAgICBzdHIgc3RyX2luZCBzdHIuW3N0cl9pbmRdO1xuICAgICAgZmxhZyA6PSB0cnVlO1xuICAgIGluXG4gICAgbGV0IHJlYyByZWFkX2ZsYWdzIHN0cl9pbmQgPVxuICAgICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICAgIGJlZ2luIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgICAgfCAnMCcgLT4gc2V0X2ZsYWcgc3RyX2luZCB6ZXJvOyAgcmVhZF9mbGFncyAoc3RyX2luZCArIDEpXG4gICAgICB8ICctJyAtPiBzZXRfZmxhZyBzdHJfaW5kIG1pbnVzOyByZWFkX2ZsYWdzIChzdHJfaW5kICsgMSlcbiAgICAgIHwgJysnIC0+IHNldF9mbGFnIHN0cl9pbmQgcGx1czsgIHJlYWRfZmxhZ3MgKHN0cl9pbmQgKyAxKVxuICAgICAgfCAnIycgLT4gc2V0X2ZsYWcgc3RyX2luZCBoYXNoOyByZWFkX2ZsYWdzIChzdHJfaW5kICsgMSlcbiAgICAgIHwgJyAnIC0+IHNldF9mbGFnIHN0cl9pbmQgc3BhY2U7IHJlYWRfZmxhZ3MgKHN0cl9pbmQgKyAxKVxuICAgICAgfCBfIC0+XG4gICAgICAgIHBhcnNlX3BhZGRpbmcgcGN0X2luZCBzdHJfaW5kIGVuZF9pbmRcbiAgICAgICAgICAhemVybyAhbWludXMgIXBsdXMgIWhhc2ggIXNwYWNlIGlnblxuICAgICAgZW5kXG4gICAgaW5cbiAgICByZWFkX2ZsYWdzIHN0cl9pbmRcblxuICAoKiBUcnkgdG8gcmVhZCBhIGRpZ2l0YWwgb3IgYSAnKicgcGFkZGluZy4gKilcbiAgYW5kIHBhcnNlX3BhZGRpbmcgOiB0eXBlIGUgZiAuXG4gICAgICBpbnQgLT4gaW50IC0+IGludCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPlxuICAgICAgICAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCB6ZXJvIG1pbnVzIHBsdXMgaGFzaCBzcGFjZSBpZ24gLT5cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgIGxldCBwYWR0eSA9IG1hdGNoIHplcm8sIG1pbnVzIHdpdGhcbiAgICAgIHwgZmFsc2UsIGZhbHNlIC0+IFJpZ2h0XG4gICAgICB8IGZhbHNlLCB0cnVlICAtPiBMZWZ0XG4gICAgICB8ICB0cnVlLCBmYWxzZSAtPiBaZXJvc1xuICAgICAgfCAgdHJ1ZSwgdHJ1ZSAgLT5cbiAgICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW4gTGVmdFxuICAgICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCAnLScgXCIwXCIgaW5cbiAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICB8ICcwJyAuLiAnOScgLT5cbiAgICAgIGxldCBuZXdfaW5kLCB3aWR0aCA9IHBhcnNlX3Bvc2l0aXZlIHN0cl9pbmQgZW5kX2luZCAwIGluXG4gICAgICBwYXJzZV9hZnRlcl9wYWRkaW5nIHBjdF9pbmQgbmV3X2luZCBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZSBpZ25cbiAgICAgICAgKExpdF9wYWRkaW5nIChwYWR0eSwgd2lkdGgpKVxuICAgIHwgJyonIC0+XG4gICAgICBwYXJzZV9hZnRlcl9wYWRkaW5nIHBjdF9pbmQgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZVxuICAgICAgICBpZ24gKEFyZ19wYWRkaW5nIHBhZHR5KVxuICAgIHwgXyAtPlxuICAgICAgYmVnaW4gbWF0Y2ggcGFkdHkgd2l0aFxuICAgICAgfCBMZWZ0ICAtPlxuICAgICAgICBpZiBub3QgbGVnYWN5X2JlaGF2aW9yIHRoZW5cbiAgICAgICAgICBpbnZhbGlkX2Zvcm1hdF93aXRob3V0IChzdHJfaW5kIC0gMSkgJy0nIFwicGFkZGluZ1wiO1xuICAgICAgICBwYXJzZV9hZnRlcl9wYWRkaW5nIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZSBpZ25cbiAgICAgICAgICBOb19wYWRkaW5nXG4gICAgICB8IFplcm9zIC0+XG4gICAgICAgICAoKiBhICcwJyBwYWRkaW5nIGluZGljYXRpb24gbm90IGZvbGxvd2VkIGJ5IGFueXRoaW5nIHNob3VsZFxuICAgICAgICAgICBiZSBpbnRlcnByZXRlZCBhcyBhIFJpZ2h0IHBhZGRpbmcgb2Ygd2lkdGggMC4gVGhpcyBpcyB1c2VkXG4gICAgICAgICAgIGJ5IHNjYW5uaW5nIGNvbnZlcnNpb25zICUwcyBhbmQgJTBjICopXG4gICAgICAgIHBhcnNlX2FmdGVyX3BhZGRpbmcgcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlIGlnblxuICAgICAgICAgIChMaXRfcGFkZGluZyAoUmlnaHQsIDApKVxuICAgICAgfCBSaWdodCAtPlxuICAgICAgICBwYXJzZV9hZnRlcl9wYWRkaW5nIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZSBpZ25cbiAgICAgICAgICBOb19wYWRkaW5nXG4gICAgICBlbmRcblxuICAoKiBJcyBwcmVjaXNpb24gZGVmaW5lZD8gKilcbiAgYW5kIHBhcnNlX2FmdGVyX3BhZGRpbmcgOiB0eXBlIHggZSBmIC5cbiAgICAgIGludCAtPiBpbnQgLT4gaW50IC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPlxuICAgICAgICAoeCwgXykgcGFkZGluZyAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2UgaWduIHBhZCAtPlxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgfCAnLicgLT5cbiAgICAgIHBhcnNlX3ByZWNpc2lvbiBwY3RfaW5kIChzdHJfaW5kICsgMSkgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2UgaWduXG4gICAgICAgIHBhZFxuICAgIHwgc3ltYiAtPlxuICAgICAgcGFyc2VfY29udmVyc2lvbiBwY3RfaW5kIChzdHJfaW5kICsgMSkgZW5kX2luZCBwbHVzIGhhc2ggc3BhY2UgaWduIHBhZFxuICAgICAgICBOb19wcmVjaXNpb24gcGFkIHN5bWJcblxuICAoKiBSZWFkIHRoZSBkaWdpdGFsIG9yICcqJyBwcmVjaXNpb24uICopXG4gIGFuZCBwYXJzZV9wcmVjaXNpb24gOiB0eXBlIHggZSBmIC5cbiAgICAgIGludCAtPiBpbnQgLT4gaW50IC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPlxuICAgICAgICAoeCwgXykgcGFkZGluZyAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2UgaWduIHBhZCAtPlxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgbGV0IHBhcnNlX2xpdGVyYWwgbWludXMgc3RyX2luZCA9XG4gICAgICBsZXQgbmV3X2luZCwgcHJlYyA9IHBhcnNlX3Bvc2l0aXZlIHN0cl9pbmQgZW5kX2luZCAwIGluXG4gICAgICBwYXJzZV9hZnRlcl9wcmVjaXNpb24gcGN0X2luZCBuZXdfaW5kIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlIGlnblxuICAgICAgICBwYWQgKExpdF9wcmVjaXNpb24gcHJlYykgaW5cbiAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICB8ICcwJyAuLiAnOScgLT4gcGFyc2VfbGl0ZXJhbCBtaW51cyBzdHJfaW5kXG4gICAgfCAoJysnIHwgJy0nKSBhcyBzeW1iIHdoZW4gbGVnYWN5X2JlaGF2aW9yIC0+XG4gICAgICAoKiBMZWdhY3kgbW9kZSB3b3VsZCBhY2NlcHQgYW5kIGlnbm9yZSAnKycgb3IgJy0nIGJlZm9yZSB0aGVcbiAgICAgICAgIGludGVnZXIgZGVzY3JpYmluZyB0aGUgZGVzaXJlZCBwcmVjaXNpb247IG5vdGUgdGhhdCB0aGlzXG4gICAgICAgICBjYW5ub3QgaGFwcGVuIGZvciBwYWRkaW5nIHdpZHRoLCBhcyAnKycgYW5kICctJyBhbHJlYWR5IGhhdmVcbiAgICAgICAgIGEgc2VtYW50aWNzIHRoZXJlLlxuXG4gICAgICAgICBUaGF0IHNhaWQsIHRoZSBpZGVhIChzdXBwb3J0ZWQgYnkgdGhpcyB0d2VhaykgdGhhdCB3aWR0aCBhbmRcbiAgICAgICAgIHByZWNpc2lvbiBsaXRlcmFscyBhcmUgXCJpbnRlZ2VyIGxpdGVyYWxzXCIgaW4gdGhlIE9DYW1sIHNlbnNlIGlzXG4gICAgICAgICBzdGlsbCBibGF0YW50bHkgd3JvbmcsIGFzIDEyM180NTYgb3IgMHhGRiBhcmUgcmVqZWN0ZWQuICopXG4gICAgICBwYXJzZV9saXRlcmFsIChtaW51cyB8fCBzeW1iID0gJy0nKSAoc3RyX2luZCArIDEpXG4gICAgfCAnKicgLT5cbiAgICAgIHBhcnNlX2FmdGVyX3ByZWNpc2lvbiBwY3RfaW5kIChzdHJfaW5kICsgMSkgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2VcbiAgICAgICAgaWduIHBhZCBBcmdfcHJlY2lzaW9uXG4gICAgfCBfIC0+XG4gICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlblxuICAgICAgICAoKiBub3RlIHRoYXQgbGVnYWN5IGltcGxlbWVudGF0aW9uIGRpZCBub3QgaWdub3JlICcuJyB3aXRob3V0XG4gICAgICAgICAgIGEgbnVtYmVyIChhcyBpdCBkb2VzIGZvciBwYWRkaW5nIGluZGljYXRpb25zKSwgYnV0XG4gICAgICAgICAgIGludGVycHJldHMgaXQgYXMgJy4wJyAqKVxuICAgICAgICBwYXJzZV9hZnRlcl9wcmVjaXNpb24gcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlIGlnblxuICAgICAgICAgIHBhZCAoTGl0X3ByZWNpc2lvbiAwKVxuICAgICAgZWxzZVxuICAgICAgICBpbnZhbGlkX2Zvcm1hdF93aXRob3V0IChzdHJfaW5kIC0gMSkgJy4nIFwicHJlY2lzaW9uXCJcblxuICAoKiBUcnkgdG8gcmVhZCB0aGUgY29udmVyc2lvbi4gKilcbiAgYW5kIHBhcnNlX2FmdGVyX3ByZWNpc2lvbiA6IHR5cGUgeCB5IHogdCBlIGYgLlxuICAgICAgaW50IC0+IGludCAtPiBpbnQgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+XG4gICAgICAgICh4LCB5KSBwYWRkaW5nIC0+ICh6LCB0KSBwcmVjaXNpb24gLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlIGlnbiBwYWQgcHJlYyAtPlxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgbGV0IHBhcnNlX2NvbnYgKHR5cGUgdSkgKHR5cGUgdikgKHBhZHByZWMgOiAodSwgdikgcGFkZGluZykgPVxuICAgICAgcGFyc2VfY29udmVyc2lvbiBwY3RfaW5kIChzdHJfaW5kICsgMSkgZW5kX2luZCBwbHVzIGhhc2ggc3BhY2UgaWduIHBhZFxuICAgICAgICBwcmVjIHBhZHByZWMgc3RyLltzdHJfaW5kXSBpblxuICAgICgqIGluIGxlZ2FjeSBtb2RlLCBzb21lIGZvcm1hdHMgKCVzIGFuZCAlUykgYWNjZXB0IGEgd2VpcmQgbWl4IG9mXG4gICAgICAgcGFkZGluZyBhbmQgcHJlY2lzaW9uLCB3aGljaCBpcyBtZXJnZWQgYXMgYSBzaW5nbGUgcGFkZGluZ1xuICAgICAgIGluZm9ybWF0aW9uLiBGb3IgZXhhbXBsZSwgaW4gJS4xMHMgdGhlIHByZWNpc2lvbiBpcyBpbXBsaWNpdGx5XG4gICAgICAgdW5kZXJzdG9vZCBhcyBwYWRkaW5nICUxMHMsIGJ1dCB0aGUgbGVmdC1wYWRkaW5nIGNvbXBvbmVudCBtYXlcbiAgICAgICBiZSBzcGVjaWZpZWQgZWl0aGVyIGFzIGEgbGVmdCBwYWRkaW5nIG9yIGEgbmVnYXRpdmUgcHJlY2lzaW9uOlxuICAgICAgICUtLjNzIGFuZCAlLi0zcyBhcmUgZXF1aXZhbGVudCB0byAlLTNzICopXG4gICAgbWF0Y2ggcGFkIHdpdGhcbiAgICB8IE5vX3BhZGRpbmcgLT4gKFxuICAgICAgbWF0Y2ggbWludXMsIHByZWMgd2l0aFxuICAgICAgICB8IF8sIE5vX3ByZWNpc2lvbiAtPiBwYXJzZV9jb252IE5vX3BhZGRpbmdcbiAgICAgICAgfCBmYWxzZSwgTGl0X3ByZWNpc2lvbiBuIC0+IHBhcnNlX2NvbnYgKExpdF9wYWRkaW5nIChSaWdodCwgbikpXG4gICAgICAgIHwgdHJ1ZSwgTGl0X3ByZWNpc2lvbiBuIC0+IHBhcnNlX2NvbnYgKExpdF9wYWRkaW5nIChMZWZ0LCBuKSlcbiAgICAgICAgfCBmYWxzZSwgQXJnX3ByZWNpc2lvbiAtPiBwYXJzZV9jb252IChBcmdfcGFkZGluZyBSaWdodClcbiAgICAgICAgfCB0cnVlLCBBcmdfcHJlY2lzaW9uIC0+IHBhcnNlX2NvbnYgKEFyZ19wYWRkaW5nIExlZnQpXG4gICAgKVxuICAgIHwgcGFkIC0+IHBhcnNlX2NvbnYgcGFkXG5cbiAgKCogQ2FzZSBhbmFseXNpcyBvbiBjb252ZXJzaW9uLiAqKVxuICBhbmQgcGFyc2VfY29udmVyc2lvbiA6IHR5cGUgeCB5IHogdCB1IHYgZSBmIC5cbiAgICAgIGludCAtPiBpbnQgLT4gaW50IC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT4gKHgsIHkpIHBhZGRpbmcgLT5cbiAgICAgICAgKHosIHQpIHByZWNpc2lvbiAtPiAodSwgdikgcGFkZGluZyAtPiBjaGFyIC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIHBsdXMgaGFzaCBzcGFjZSBpZ24gcGFkIHByZWMgcGFkcHJlYyBzeW1iIC0+XG4gICAgKCogRmxhZ3MgdXNlZCB0byBjaGVjayBvcHRpb24gdXNhZ2VzL2NvbXBhdGliaWxpdGllcy4gKilcbiAgICBsZXQgcGx1c191c2VkICA9IHJlZiBmYWxzZSBhbmQgaGFzaF91c2VkID0gcmVmIGZhbHNlXG4gICAgYW5kIHNwYWNlX3VzZWQgPSByZWYgZmFsc2UgYW5kIGlnbl91c2VkICAgPSByZWYgZmFsc2VcbiAgICBhbmQgcGFkX3VzZWQgICA9IHJlZiBmYWxzZSBhbmQgcHJlY191c2VkICA9IHJlZiBmYWxzZSBpblxuXG4gICAgKCogQWNjZXNzIHRvIG9wdGlvbnMsIHVwZGF0ZSBmbGFncy4gKilcbiAgICBsZXQgZ2V0X3BsdXMgICAgKCkgPSBwbHVzX3VzZWQgIDo9IHRydWU7IHBsdXNcbiAgICBhbmQgZ2V0X2hhc2ggICAoKSA9IGhhc2hfdXNlZCA6PSB0cnVlOyBoYXNoXG4gICAgYW5kIGdldF9zcGFjZSAgICgpID0gc3BhY2VfdXNlZCA6PSB0cnVlOyBzcGFjZVxuICAgIGFuZCBnZXRfaWduICAgICAoKSA9IGlnbl91c2VkICAgOj0gdHJ1ZTsgaWduXG4gICAgYW5kIGdldF9wYWQgICAgICgpID0gcGFkX3VzZWQgICA6PSB0cnVlOyBwYWRcbiAgICBhbmQgZ2V0X3ByZWMgICAgKCkgPSBwcmVjX3VzZWQgIDo9IHRydWU7IHByZWNcbiAgICBhbmQgZ2V0X3BhZHByZWMgKCkgPSBwYWRfdXNlZCAgIDo9IHRydWU7IHBhZHByZWMgaW5cblxuICAgIGxldCBnZXRfaW50X3BhZCAoKSA6ICh4LHkpIHBhZGRpbmcgPVxuICAgICAgKCogJTUuM2QgaXMgYWNjZXB0ZWQgYW5kIG1lYW5pbmdmdWw6IHBhZCB0byBsZW5ndGggNSB3aXRoXG4gICAgICAgICBzcGFjZXMsIGJ1dCBmaXJzdCBwYWQgd2l0aCB6ZXJvcyB1cHRvIGxlbmd0aCAzICgwLXBhZGRpbmdcbiAgICAgICAgIGlzIHRoZSBpbnRlcnByZXRhdGlvbiBvZiBcInByZWNpc2lvblwiIGZvciBpbnRlZ2VyIGZvcm1hdHMpLlxuXG4gICAgICAgICAlMDUuM2QgaXMgcmVkdW5kYW50OiBwYWQgdG8gbGVuZ3RoIDUgKndpdGggemVyb3MqLCBidXRcbiAgICAgICAgIGZpcnN0IHBhZCB3aXRoIHplcm9zLi4uIFRvIGFkZCBpbnN1bHQgdG8gdGhlIGluanVyeSwgdGhlXG4gICAgICAgICBsZWdhY3kgaW1wbGVtZW50YXRpb24gaWdub3JlcyB0aGUgMC1wYWRkaW5nIGluZGljYXRpb24gYW5kXG4gICAgICAgICBkb2VzIHRoZSA1IHBhZGRpbmcgd2l0aCBzcGFjZXMgaW5zdGVhZC4gV2UgcmV1c2UgdGhpc1xuICAgICAgICAgaW50ZXJwcmV0YXRpb24gZm9yIGNvbXBhdGliaWxpdHksIGJ1dCBzdGF0aWNhbGx5IHJlamVjdCB0aGlzXG4gICAgICAgICBmb3JtYXQgd2hlbiB0aGUgbGVnYWN5IG1vZGUgaXMgZGlzYWJsZWQsIHRvIHByb3RlY3Qgc3RyaWN0XG4gICAgICAgICB1c2VycyBmcm9tIHRoaXMgY29ybmVyIGNhc2UuICopXG4gICAgICAgbWF0Y2ggZ2V0X3BhZCAoKSwgZ2V0X3ByZWMgKCkgd2l0aFxuICAgICAgICAgfCBwYWQsIE5vX3ByZWNpc2lvbiAtPiBwYWRcbiAgICAgICAgIHwgTm9fcGFkZGluZywgXyAgICAgLT4gTm9fcGFkZGluZ1xuICAgICAgICAgfCBMaXRfcGFkZGluZyAoWmVyb3MsIG4pLCBfIC0+XG4gICAgICAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuIExpdF9wYWRkaW5nIChSaWdodCwgbilcbiAgICAgICAgICAgZWxzZSBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgJzAnIFwicHJlY2lzaW9uXCJcbiAgICAgICAgIHwgQXJnX3BhZGRpbmcgWmVyb3MsIF8gLT5cbiAgICAgICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW4gQXJnX3BhZGRpbmcgUmlnaHRcbiAgICAgICAgICAgZWxzZSBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgJzAnIFwicHJlY2lzaW9uXCJcbiAgICAgICAgIHwgTGl0X3BhZGRpbmcgXyBhcyBwYWQsIF8gLT4gcGFkXG4gICAgICAgICB8IEFyZ19wYWRkaW5nIF8gYXMgcGFkLCBfIC0+IHBhZCBpblxuXG4gICAgKCogQ2hlY2sgdGhhdCBwYWR0eSA8PiBaZXJvcy4gKilcbiAgICBsZXQgY2hlY2tfbm9fMCBzeW1iICh0eXBlIGEgYikgKHBhZCA6IChhLCBiKSBwYWRkaW5nKSA6IChhLGIpIHBhZGRpbmcgPVxuICAgICAgbWF0Y2ggcGFkIHdpdGhcbiAgICAgIHwgTm9fcGFkZGluZyAtPiBwYWRcbiAgICAgIHwgTGl0X3BhZGRpbmcgKChMZWZ0IHwgUmlnaHQpLCBfKSAtPiBwYWRcbiAgICAgIHwgQXJnX3BhZGRpbmcgKExlZnQgfCBSaWdodCkgLT4gcGFkXG4gICAgICB8IExpdF9wYWRkaW5nIChaZXJvcywgd2lkdGgpIC0+XG4gICAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuIExpdF9wYWRkaW5nIChSaWdodCwgd2lkdGgpXG4gICAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIHN5bWIgXCIwXCJcbiAgICAgIHwgQXJnX3BhZGRpbmcgWmVyb3MgLT5cbiAgICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW4gQXJnX3BhZGRpbmcgUmlnaHRcbiAgICAgICAgZWxzZSBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgc3ltYiBcIjBcIlxuICAgIGluXG5cbiAgICAoKiBHZXQgcGFkZGluZyBhcyBhIHBhZF9vcHRpb24gKHNlZSBcIiVfXCIsIFwiJXtcIiwgXCIlKFwiIGFuZCBcIiVbXCIpLlxuICAgICAgIChubyBuZWVkIGZvciBsZWdhY3kgbW9kZSB0d2Vha2luZywgdGhvc2Ugd2VyZSByZWplY3RlZCBieSB0aGVcbiAgICAgICBsZWdhY3kgcGFyc2VyIGFzIHdlbGwpICopXG4gICAgbGV0IG9wdF9vZl9wYWQgYyAodHlwZSBhKSAodHlwZSBiKSAocGFkIDogKGEsIGIpIHBhZGRpbmcpID0gbWF0Y2ggcGFkIHdpdGhcbiAgICAgIHwgTm9fcGFkZGluZyAtPiBOb25lXG4gICAgICB8IExpdF9wYWRkaW5nIChSaWdodCwgd2lkdGgpIC0+IFNvbWUgd2lkdGhcbiAgICAgIHwgTGl0X3BhZGRpbmcgKFplcm9zLCB3aWR0aCkgLT5cbiAgICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW4gU29tZSB3aWR0aFxuICAgICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBjIFwiJzAnXCJcbiAgICAgIHwgTGl0X3BhZGRpbmcgKExlZnQsIHdpZHRoKSAtPlxuICAgICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiBTb21lIHdpZHRoXG4gICAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIGMgXCInLSdcIlxuICAgICAgfCBBcmdfcGFkZGluZyBfIC0+IGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBjIFwiJyonXCJcbiAgICBpblxuICAgIGxldCBnZXRfcGFkX29wdCBjID0gb3B0X29mX3BhZCBjIChnZXRfcGFkICgpKSBpblxuICAgIGxldCBnZXRfcGFkcHJlY19vcHQgYyA9IG9wdF9vZl9wYWQgYyAoZ2V0X3BhZHByZWMgKCkpIGluXG5cbiAgICAoKiBHZXQgcHJlY2lzaW9uIGFzIGEgcHJlY19vcHRpb24gKHNlZSBcIiVfZlwiKS5cbiAgICAgICAobm8gbmVlZCBmb3IgbGVnYWN5IG1vZGUgdHdlYWtpbmcsIHRob3NlIHdlcmUgcmVqZWN0ZWQgYnkgdGhlXG4gICAgICAgbGVnYWN5IHBhcnNlciBhcyB3ZWxsKSAqKVxuICAgIGxldCBnZXRfcHJlY19vcHQgKCkgPSBtYXRjaCBnZXRfcHJlYyAoKSB3aXRoXG4gICAgICB8IE5vX3ByZWNpc2lvbiAgICAgICAtPiBOb25lXG4gICAgICB8IExpdF9wcmVjaXNpb24gbmRlYyAtPiBTb21lIG5kZWNcbiAgICAgIHwgQXJnX3ByZWNpc2lvbiAgICAgIC0+IGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCAnXycgXCInKidcIlxuICAgIGluXG5cbiAgICBsZXQgZm10X3Jlc3VsdCA9IG1hdGNoIHN5bWIgd2l0aFxuICAgIHwgJywnIC0+XG4gICAgICBwYXJzZSBzdHJfaW5kIGVuZF9pbmRcbiAgICB8ICdjJyAtPlxuICAgICAgbGV0IGNoYXJfZm9ybWF0IGZtdF9yZXN0ID0gKCogJWMgKilcbiAgICAgICAgaWYgZ2V0X2lnbiAoKVxuICAgICAgICB0aGVuIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKElnbm9yZWRfY2hhciwgZm10X3Jlc3QpKVxuICAgICAgICBlbHNlIEZtdF9FQkIgKENoYXIgZm10X3Jlc3QpXG4gICAgICBpblxuICAgICAgbGV0IHNjYW5fZm9ybWF0IGZtdF9yZXN0ID0gKCogJTBjICopXG4gICAgICAgIGlmIGdldF9pZ24gKClcbiAgICAgICAgdGhlbiBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChJZ25vcmVkX3NjYW5fbmV4dF9jaGFyLCBmbXRfcmVzdCkpXG4gICAgICAgIGVsc2UgRm10X0VCQiAoU2Nhbl9uZXh0X2NoYXIgZm10X3Jlc3QpXG4gICAgICBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGJlZ2luIG1hdGNoIGdldF9wYWRfb3B0ICdjJyB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiBjaGFyX2Zvcm1hdCBmbXRfcmVzdFxuICAgICAgICB8IFNvbWUgMCAtPiBzY2FuX2Zvcm1hdCBmbXRfcmVzdFxuICAgICAgICB8IFNvbWUgX24gLT5cbiAgICAgICAgICAgaWYgbm90IGxlZ2FjeV9iZWhhdmlvclxuICAgICAgICAgICB0aGVuIGludmFsaWRfbm9ubnVsbF9jaGFyX3dpZHRoIHN0cl9pbmRcbiAgICAgICAgICAgZWxzZSAoKiBsZWdhY3kgaWdub3JlcyAlYyB3aWR0aHMgKikgY2hhcl9mb3JtYXQgZm10X3Jlc3RcbiAgICAgIGVuZFxuICAgIHwgJ0MnIC0+XG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKElnbm9yZWRfY2FtbF9jaGFyLGZtdF9yZXN0KSlcbiAgICAgIGVsc2UgRm10X0VCQiAoQ2FtbF9jaGFyIGZtdF9yZXN0KVxuICAgIHwgJ3MnIC0+XG4gICAgICBsZXQgcGFkID0gY2hlY2tfbm9fMCBzeW1iIChnZXRfcGFkcHJlYyAoKSkgaW5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBJZ25vcmVkX3N0cmluZyAoZ2V0X3BhZHByZWNfb3B0ICdfJykgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBsZXQgUGFkZGluZ19mbXRfRUJCIChwYWQnLCBmbXRfcmVzdCcpID1cbiAgICAgICAgICBtYWtlX3BhZGRpbmdfZm10X2ViYiBwYWQgZm10X3Jlc3QgaW5cbiAgICAgICAgRm10X0VCQiAoU3RyaW5nIChwYWQnLCBmbXRfcmVzdCcpKVxuICAgIHwgJ1MnIC0+XG4gICAgICBsZXQgcGFkID0gY2hlY2tfbm9fMCBzeW1iIChnZXRfcGFkcHJlYyAoKSkgaW5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBJZ25vcmVkX2NhbWxfc3RyaW5nIChnZXRfcGFkcHJlY19vcHQgJ18nKSBpblxuICAgICAgICBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChpZ25vcmVkLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlXG4gICAgICAgIGxldCBQYWRkaW5nX2ZtdF9FQkIgKHBhZCcsIGZtdF9yZXN0JykgPVxuICAgICAgICAgIG1ha2VfcGFkZGluZ19mbXRfZWJiIHBhZCBmbXRfcmVzdCBpblxuICAgICAgICBGbXRfRUJCIChDYW1sX3N0cmluZyAocGFkJywgZm10X3Jlc3QnKSlcbiAgICB8ICdkJyB8ICdpJyB8ICd4JyB8ICdYJyB8ICdvJyB8ICd1JyAtPlxuICAgICAgbGV0IGljb252ID0gY29tcHV0ZV9pbnRfY29udiBwY3RfaW5kIHN0cl9pbmQgKGdldF9wbHVzICgpKSAoZ2V0X2hhc2ggKCkpXG4gICAgICAgIChnZXRfc3BhY2UgKCkpIHN5bWIgaW5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBJZ25vcmVkX2ludCAoaWNvbnYsIGdldF9wYWRfb3B0ICdfJykgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBsZXQgUGFkcHJlY19mbXRfRUJCIChwYWQnLCBwcmVjJywgZm10X3Jlc3QnKSA9XG4gICAgICAgICAgbWFrZV9wYWRwcmVjX2ZtdF9lYmIgKGdldF9pbnRfcGFkICgpKSAoZ2V0X3ByZWMgKCkpIGZtdF9yZXN0IGluXG4gICAgICAgIEZtdF9FQkIgKEludCAoaWNvbnYsIHBhZCcsIHByZWMnLCBmbXRfcmVzdCcpKVxuICAgIHwgJ04nIC0+XG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgbGV0IGNvdW50ZXIgPSBUb2tlbl9jb3VudGVyIGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBJZ25vcmVkX3NjYW5fZ2V0X2NvdW50ZXIgY291bnRlciBpblxuICAgICAgICBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChpZ25vcmVkLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlXG4gICAgICAgIEZtdF9FQkIgKFNjYW5fZ2V0X2NvdW50ZXIgKGNvdW50ZXIsIGZtdF9yZXN0KSlcbiAgICB8ICdsJyB8ICduJyB8ICdMJyB3aGVuIHN0cl9pbmQ9ZW5kX2luZCB8fCBub3QgKGlzX2ludF9iYXNlIHN0ci5bc3RyX2luZF0pIC0+XG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgbGV0IGNvdW50ZXIgPSBjb3VudGVyX29mX2NoYXIgc3ltYiBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9zY2FuX2dldF9jb3VudGVyIGNvdW50ZXIgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBGbXRfRUJCIChTY2FuX2dldF9jb3VudGVyIChjb3VudGVyLCBmbXRfcmVzdCkpXG4gICAgfCAnbCcgLT5cbiAgICAgIGxldCBpY29udiA9XG4gICAgICAgIGNvbXB1dGVfaW50X2NvbnYgcGN0X2luZCAoc3RyX2luZCArIDEpIChnZXRfcGx1cyAoKSkgKGdldF9oYXNoICgpKVxuICAgICAgICAgIChnZXRfc3BhY2UgKCkpIHN0ci5bc3RyX2luZF0gaW5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBJZ25vcmVkX2ludDMyIChpY29udiwgZ2V0X3BhZF9vcHQgJ18nKSBpblxuICAgICAgICBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChpZ25vcmVkLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlXG4gICAgICAgIGxldCBQYWRwcmVjX2ZtdF9FQkIgKHBhZCcsIHByZWMnLCBmbXRfcmVzdCcpID1cbiAgICAgICAgICBtYWtlX3BhZHByZWNfZm10X2ViYiAoZ2V0X2ludF9wYWQgKCkpIChnZXRfcHJlYyAoKSkgZm10X3Jlc3QgaW5cbiAgICAgICAgRm10X0VCQiAoSW50MzIgKGljb252LCBwYWQnLCBwcmVjJywgZm10X3Jlc3QnKSlcbiAgICB8ICduJyAtPlxuICAgICAgbGV0IGljb252ID1cbiAgICAgICAgY29tcHV0ZV9pbnRfY29udiBwY3RfaW5kIChzdHJfaW5kICsgMSkgKGdldF9wbHVzICgpKVxuICAgICAgICAgIChnZXRfaGFzaCAoKSkgKGdldF9zcGFjZSAoKSkgc3RyLltzdHJfaW5kXSBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfbmF0aXZlaW50IChpY29udiwgZ2V0X3BhZF9vcHQgJ18nKSBpblxuICAgICAgICBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChpZ25vcmVkLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlXG4gICAgICAgIGxldCBQYWRwcmVjX2ZtdF9FQkIgKHBhZCcsIHByZWMnLCBmbXRfcmVzdCcpID1cbiAgICAgICAgICBtYWtlX3BhZHByZWNfZm10X2ViYiAoZ2V0X2ludF9wYWQgKCkpIChnZXRfcHJlYyAoKSkgZm10X3Jlc3QgaW5cbiAgICAgICAgRm10X0VCQiAoTmF0aXZlaW50IChpY29udiwgcGFkJywgcHJlYycsIGZtdF9yZXN0JykpXG4gICAgfCAnTCcgLT5cbiAgICAgIGxldCBpY29udiA9XG4gICAgICAgIGNvbXB1dGVfaW50X2NvbnYgcGN0X2luZCAoc3RyX2luZCArIDEpIChnZXRfcGx1cyAoKSkgKGdldF9oYXNoICgpKVxuICAgICAgICAgIChnZXRfc3BhY2UgKCkpIHN0ci5bc3RyX2luZF0gaW5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBJZ25vcmVkX2ludDY0IChpY29udiwgZ2V0X3BhZF9vcHQgJ18nKSBpblxuICAgICAgICBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChpZ25vcmVkLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlXG4gICAgICAgIGxldCBQYWRwcmVjX2ZtdF9FQkIgKHBhZCcsIHByZWMnLCBmbXRfcmVzdCcpID1cbiAgICAgICAgICBtYWtlX3BhZHByZWNfZm10X2ViYiAoZ2V0X2ludF9wYWQgKCkpIChnZXRfcHJlYyAoKSkgZm10X3Jlc3QgaW5cbiAgICAgICAgRm10X0VCQiAoSW50NjQgKGljb252LCBwYWQnLCBwcmVjJywgZm10X3Jlc3QnKSlcbiAgICB8ICdmJyB8ICdlJyB8ICdFJyB8ICdnJyB8ICdHJyB8ICdGJyB8ICdoJyB8ICdIJyAtPlxuICAgICAgbGV0IGZjb252ID1cbiAgICAgICAgY29tcHV0ZV9mbG9hdF9jb252IHBjdF9pbmQgc3RyX2luZFxuICAgICAgICAgIChnZXRfcGx1cyAoKSkgKGdldF9oYXNoICgpKSAoZ2V0X3NwYWNlICgpKSBzeW1iIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9mbG9hdCAoZ2V0X3BhZF9vcHQgJ18nLCBnZXRfcHJlY19vcHQgKCkpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IFBhZHByZWNfZm10X0VCQiAocGFkJywgcHJlYycsIGZtdF9yZXN0JykgPVxuICAgICAgICAgIG1ha2VfcGFkcHJlY19mbXRfZWJiIChnZXRfcGFkICgpKSAoZ2V0X3ByZWMgKCkpIGZtdF9yZXN0IGluXG4gICAgICAgIEZtdF9FQkIgKEZsb2F0IChmY29udiwgcGFkJywgcHJlYycsIGZtdF9yZXN0JykpXG4gICAgfCAnYicgfCAnQicgLT5cbiAgICAgIGxldCBwYWQgPSBjaGVja19ub18wIHN5bWIgKGdldF9wYWRwcmVjICgpKSBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfYm9vbCAoZ2V0X3BhZHByZWNfb3B0ICdfJykgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBsZXQgUGFkZGluZ19mbXRfRUJCIChwYWQnLCBmbXRfcmVzdCcpID1cbiAgICAgICAgICBtYWtlX3BhZGRpbmdfZm10X2ViYiBwYWQgZm10X3Jlc3QgaW5cbiAgICAgICAgRm10X0VCQiAoQm9vbCAocGFkJywgZm10X3Jlc3QnKSlcbiAgICB8ICdhJyAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIEZtdF9FQkIgKEFscGhhIGZtdF9yZXN0KVxuICAgIHwgJ3QnIC0+XG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgRm10X0VCQiAoVGhldGEgZm10X3Jlc3QpXG4gICAgfCAncicgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW4gRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoSWdub3JlZF9yZWFkZXIsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2UgRm10X0VCQiAoUmVhZGVyIGZtdF9yZXN0KVxuICAgIHwgJyEnIC0+XG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgRm10X0VCQiAoRmx1c2ggZm10X3Jlc3QpXG4gICAgfCAoJyUnIHwgJ0AnKSBhcyBjIC0+XG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgRm10X0VCQiAoQ2hhcl9saXRlcmFsIChjLCBmbXRfcmVzdCkpXG4gICAgfCAneycgLT5cbiAgICAgIGxldCBzdWJfZW5kID0gc2VhcmNoX3N1YmZvcm1hdF9lbmQgc3RyX2luZCBlbmRfaW5kICd9JyBpblxuICAgICAgbGV0IEZtdF9FQkIgc3ViX2ZtdCA9IHBhcnNlIHN0cl9pbmQgc3ViX2VuZCBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3ViX2VuZCArIDIpIGVuZF9pbmQgaW5cbiAgICAgIGxldCBzdWJfZm10dHkgPSBmbXR0eV9vZl9mbXQgc3ViX2ZtdCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9mb3JtYXRfYXJnIChnZXRfcGFkX29wdCAnXycsIHN1Yl9mbXR0eSkgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBGbXRfRUJCIChGb3JtYXRfYXJnIChnZXRfcGFkX29wdCAneycsIHN1Yl9mbXR0eSwgZm10X3Jlc3QpKVxuICAgIHwgJygnIC0+XG4gICAgICBsZXQgc3ViX2VuZCA9IHNlYXJjaF9zdWJmb3JtYXRfZW5kIHN0cl9pbmQgZW5kX2luZCAnKScgaW5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN1Yl9lbmQgKyAyKSBlbmRfaW5kIGluXG4gICAgICBsZXQgRm10X0VCQiBzdWJfZm10ID0gcGFyc2Ugc3RyX2luZCBzdWJfZW5kIGluXG4gICAgICBsZXQgc3ViX2ZtdHR5ID0gZm10dHlfb2ZfZm10IHN1Yl9mbXQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfZm9ybWF0X3N1YnN0IChnZXRfcGFkX29wdCAnXycsIHN1Yl9mbXR0eSkgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBGbXRfRUJCIChGb3JtYXRfc3Vic3QgKGdldF9wYWRfb3B0ICcoJywgc3ViX2ZtdHR5LCBmbXRfcmVzdCkpXG4gICAgfCAnWycgLT5cbiAgICAgIGxldCBuZXh0X2luZCwgY2hhcl9zZXQgPSBwYXJzZV9jaGFyX3NldCBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgbmV4dF9pbmQgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9zY2FuX2NoYXJfc2V0IChnZXRfcGFkX29wdCAnXycsIGNoYXJfc2V0KSBpblxuICAgICAgICBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChpZ25vcmVkLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlXG4gICAgICAgIEZtdF9FQkIgKFNjYW5fY2hhcl9zZXQgKGdldF9wYWRfb3B0ICdbJywgY2hhcl9zZXQsIGZtdF9yZXN0KSlcbiAgICB8ICctJyB8ICcrJyB8ICcjJyB8ICcgJyB8ICdfJyAtPlxuICAgICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgICBcImludmFsaWQgZm9ybWF0ICVTOiBhdCBjaGFyYWN0ZXIgbnVtYmVyICVkLCBcXFxuICAgICAgICAgZmxhZyAlQyBpcyBvbmx5IGFsbG93ZWQgYWZ0ZXIgdGhlICclJScsIGJlZm9yZSBwYWRkaW5nIGFuZCBwcmVjaXNpb25cIlxuICAgICAgICBzdHIgcGN0X2luZCBzeW1iXG4gICAgfCBfIC0+XG4gICAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICAgIFwiaW52YWxpZCBmb3JtYXQgJVM6IGF0IGNoYXJhY3RlciBudW1iZXIgJWQsIFxcXG4gICAgICAgICBpbnZhbGlkIGNvbnZlcnNpb24gXFxcIiUlJWNcXFwiXCIgc3RyIChzdHJfaW5kIC0gMSkgc3ltYlxuICAgIGluXG4gICAgKCogQ2hlY2sgZm9yIHVudXNlZCBvcHRpb25zLCBhbmQgcmVqZWN0IHRoZW0gYXMgaW5jb21wYXRpYmxlLlxuXG4gICAgICAgU3VjaCBjaGVja3MgbmVlZCB0byBiZSBkaXNhYmxlZCBpbiBsZWdhY3kgbW9kZSwgYXMgdGhlIGxlZ2FjeVxuICAgICAgIHBhcnNlciBzaWxlbnRseSBpZ25vcmVkIGluY29tcGF0aWJsZSBmbGFncy4gKilcbiAgICBpZiBub3QgbGVnYWN5X2JlaGF2aW9yIHRoZW4gYmVnaW5cbiAgICBpZiBub3QgIXBsdXNfdXNlZCAmJiBwbHVzIHRoZW5cbiAgICAgIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiJysnXCI7XG4gICAgaWYgbm90ICFoYXNoX3VzZWQgJiYgaGFzaCB0aGVuXG4gICAgICBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgc3ltYiBcIicjJ1wiO1xuICAgIGlmIG5vdCAhc3BhY2VfdXNlZCAmJiBzcGFjZSB0aGVuXG4gICAgICBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgc3ltYiBcIicgJ1wiO1xuICAgIGlmIG5vdCAhcGFkX3VzZWQgICYmIFBhZGRpbmdfRUJCIHBhZCA8PiBQYWRkaW5nX0VCQiBOb19wYWRkaW5nIHRoZW5cbiAgICAgIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiYHBhZGRpbmcnXCI7XG4gICAgaWYgbm90ICFwcmVjX3VzZWQgJiYgUHJlY2lzaW9uX0VCQiBwcmVjIDw+IFByZWNpc2lvbl9FQkIgTm9fcHJlY2lzaW9uIHRoZW5cbiAgICAgIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCAoaWYgaWduIHRoZW4gJ18nIGVsc2Ugc3ltYilcbiAgICAgICAgXCJgcHJlY2lzaW9uJ1wiO1xuICAgIGlmIGlnbiAmJiBwbHVzIHRoZW4gaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kICdfJyBcIicrJ1wiO1xuICAgIGVuZDtcbiAgICAoKiB0aGlzIGxhc3QgdGVzdCBtdXN0IG5vdCBiZSBkaXNhYmxlZCBpbiBsZWdhY3kgbW9kZSxcbiAgICAgICBhcyBpZ25vcmluZyBpdCB3b3VsZCB0eXBpY2FsbHkgcmVzdWx0IGluIGEgZGlmZmVyZW50IHR5cGluZ1xuICAgICAgIHRoYW4gd2hhdCB0aGUgbGVnYWN5IHBhcnNlciB1c2VkICopXG4gICAgaWYgbm90ICFpZ25fdXNlZCAmJiBpZ24gdGhlblxuICAgICAgYmVnaW4gbWF0Y2ggc3ltYiB3aXRoXG4gICAgICAgICgqIGFyZ3VtZW50LWxlc3MgZm9ybWF0cyBjYW4gc2FmZWx5IGJlIGlnbm9yZWQgaW4gbGVnYWN5IG1vZGUgKilcbiAgICAgICAgfCAoJ0AnIHwgJyUnIHwgJyEnIHwgJywnKSB3aGVuIGxlZ2FjeV9iZWhhdmlvciAtPiAoKVxuICAgICAgICB8IF8gLT5cbiAgICAgICAgICBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgc3ltYiBcIidfJ1wiXG4gICAgICBlbmQ7XG4gICAgZm10X3Jlc3VsdFxuXG4gICgqIFBhcnNlIGZvcm1hdHRpbmcgaW5mb3JtYXRpb24gKGFmdGVyICdAJykuICopXG4gIGFuZCBwYXJzZV9hZnRlcl9hdCA6IHR5cGUgZSBmIC4gaW50IC0+IGludCAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBzdHJfaW5kIGVuZF9pbmQgLT5cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIEZtdF9FQkIgKENoYXJfbGl0ZXJhbCAoJ0AnLCBFbmRfb2ZfZm9ybWF0KSlcbiAgICBlbHNlXG4gICAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICAgIHwgJ1snIC0+XG4gICAgICAgIHBhcnNlX3RhZyBmYWxzZSAoc3RyX2luZCArIDEpIGVuZF9pbmRcbiAgICAgIHwgJ10nIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChDbG9zZV9ib3gsIGZtdF9yZXN0KSlcbiAgICAgIHwgJ3snIC0+XG4gICAgICAgIHBhcnNlX3RhZyB0cnVlIChzdHJfaW5kICsgMSkgZW5kX2luZFxuICAgICAgfCAnfScgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKENsb3NlX3RhZywgZm10X3Jlc3QpKVxuICAgICAgfCAnLCcgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKEJyZWFrIChcIkAsXCIsIDAsIDApLCBmbXRfcmVzdCkpXG4gICAgICB8ICcgJyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoQnJlYWsgKFwiQCBcIiwgMSwgMCksIGZtdF9yZXN0KSlcbiAgICAgIHwgJzsnIC0+XG4gICAgICAgIHBhcnNlX2dvb2RfYnJlYWsgKHN0cl9pbmQgKyAxKSBlbmRfaW5kXG4gICAgICB8ICc/JyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoRkZsdXNoLCBmbXRfcmVzdCkpXG4gICAgICB8ICdcXG4nIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChGb3JjZV9uZXdsaW5lLCBmbXRfcmVzdCkpXG4gICAgICB8ICcuJyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoRmx1c2hfbmV3bGluZSwgZm10X3Jlc3QpKVxuICAgICAgfCAnPCcgLT5cbiAgICAgICAgcGFyc2VfbWFnaWNfc2l6ZSAoc3RyX2luZCArIDEpIGVuZF9pbmRcbiAgICAgIHwgJ0AnIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChFc2NhcGVkX2F0LCBmbXRfcmVzdCkpXG4gICAgICB8ICclJyB3aGVuIHN0cl9pbmQgKyAxIDwgZW5kX2luZCAmJiBzdHIuW3N0cl9pbmQgKyAxXSA9ICclJyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMikgZW5kX2luZCBpblxuICAgICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoRXNjYXBlZF9wZXJjZW50LCBmbXRfcmVzdCkpXG4gICAgICB8ICclJyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgICBGbXRfRUJCIChDaGFyX2xpdGVyYWwgKCdAJywgZm10X3Jlc3QpKVxuICAgICAgfCBjIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChTY2FuX2luZGljIGMsIGZtdF9yZXN0KSlcblxuICAoKiBUcnkgdG8gcmVhZCB0aGUgb3B0aW9uYWwgPG5hbWU+IGFmdGVyIFwiQHtcIiBvciBcIkBbXCIuICopXG4gIGFuZCBwYXJzZV90YWcgOiB0eXBlIGUgZiAuIGJvb2wgLT4gaW50IC0+IGludCAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBpc19vcGVuX3RhZyBzdHJfaW5kIGVuZF9pbmQgLT5cbiAgICB0cnlcbiAgICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gcmFpc2UgTm90X2ZvdW5kO1xuICAgICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgICB8ICc8JyAtPlxuICAgICAgICBsZXQgaW5kID0gU3RyaW5nLmluZGV4X2Zyb20gc3RyIChzdHJfaW5kICsgMSkgJz4nIGluXG4gICAgICAgIGlmIGluZCA+PSBlbmRfaW5kIHRoZW4gcmFpc2UgTm90X2ZvdW5kO1xuICAgICAgICBsZXQgc3ViX3N0ciA9IFN0cmluZy5zdWIgc3RyIHN0cl9pbmQgKGluZCAtIHN0cl9pbmQgKyAxKSBpblxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChpbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICAgIGxldCBGbXRfRUJCIHN1Yl9mbXQgPSBwYXJzZSBzdHJfaW5kIChpbmQgKyAxKSBpblxuICAgICAgICBsZXQgc3ViX2Zvcm1hdCA9IEZvcm1hdCAoc3ViX2ZtdCwgc3ViX3N0cikgaW5cbiAgICAgICAgbGV0IGZvcm1hdHRpbmcgPVxuICAgICAgICAgIGlmIGlzX29wZW5fdGFnIHRoZW4gT3Blbl90YWcgc3ViX2Zvcm1hdCBlbHNlIE9wZW5fYm94IHN1Yl9mb3JtYXQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19nZW4gKGZvcm1hdHRpbmcsIGZtdF9yZXN0KSlcbiAgICAgIHwgXyAtPlxuICAgICAgICByYWlzZSBOb3RfZm91bmRcbiAgICB3aXRoIE5vdF9mb3VuZCAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGxldCBzdWJfZm9ybWF0ID0gRm9ybWF0IChFbmRfb2ZfZm9ybWF0LCBcIlwiKSBpblxuICAgICAgbGV0IGZvcm1hdHRpbmcgPVxuICAgICAgICBpZiBpc19vcGVuX3RhZyB0aGVuIE9wZW5fdGFnIHN1Yl9mb3JtYXQgZWxzZSBPcGVuX2JveCBzdWJfZm9ybWF0IGluXG4gICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2dlbiAoZm9ybWF0dGluZywgZm10X3Jlc3QpKVxuXG4gICgqIFRyeSB0byByZWFkIHRoZSBvcHRpb25hbCA8d2lkdGggb2Zmc2V0PiBhZnRlciBcIkA7XCIuICopXG4gIGFuZCBwYXJzZV9nb29kX2JyZWFrIDogdHlwZSBlIGYgLiBpbnQgLT4gaW50IC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIHN0cl9pbmQgZW5kX2luZCAtPlxuICAgIGxldCBuZXh0X2luZCwgZm9ybWF0dGluZ19saXQgPVxuICAgICAgdHJ5XG4gICAgICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHx8IHN0ci5bc3RyX2luZF0gPD4gJzwnIHRoZW4gcmFpc2UgTm90X2ZvdW5kO1xuICAgICAgICBsZXQgc3RyX2luZF8xID0gcGFyc2Vfc3BhY2VzIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBtYXRjaCBzdHIuW3N0cl9pbmRfMV0gd2l0aFxuICAgICAgICB8ICcwJyAuLiAnOScgfCAnLScgLT4gKFxuICAgICAgICAgIGxldCBzdHJfaW5kXzIsIHdpZHRoID0gcGFyc2VfaW50ZWdlciBzdHJfaW5kXzEgZW5kX2luZCBpblxuICAgICAgICAgICAgbGV0IHN0cl9pbmRfMyA9IHBhcnNlX3NwYWNlcyBzdHJfaW5kXzIgZW5kX2luZCBpblxuICAgICAgICAgICAgbWF0Y2ggc3RyLltzdHJfaW5kXzNdIHdpdGhcbiAgICAgICAgICAgICAgfCAnPicgLT5cbiAgICAgICAgICAgICAgICBsZXQgcyA9IFN0cmluZy5zdWIgc3RyIChzdHJfaW5kLTIpIChzdHJfaW5kXzMtc3RyX2luZCszKSBpblxuICAgICAgICAgICAgICAgIHN0cl9pbmRfMyArIDEsIEJyZWFrIChzLCB3aWR0aCwgMClcbiAgICAgICAgICAgICAgfCAnMCcgLi4gJzknIHwgJy0nIC0+XG4gICAgICAgICAgICAgICAgbGV0IHN0cl9pbmRfNCwgb2Zmc2V0ID0gcGFyc2VfaW50ZWdlciBzdHJfaW5kXzMgZW5kX2luZCBpblxuICAgICAgICAgICAgICAgIGxldCBzdHJfaW5kXzUgPSBwYXJzZV9zcGFjZXMgc3RyX2luZF80IGVuZF9pbmQgaW5cbiAgICAgICAgICAgICAgICBpZiBzdHIuW3N0cl9pbmRfNV0gPD4gJz4nIHRoZW4gcmFpc2UgTm90X2ZvdW5kO1xuICAgICAgICAgICAgICAgIGxldCBzID0gU3RyaW5nLnN1YiBzdHIgKHN0cl9pbmQtMikgKHN0cl9pbmRfNS1zdHJfaW5kKzMpIGluXG4gICAgICAgICAgICAgICAgc3RyX2luZF81ICsgMSwgQnJlYWsgKHMsIHdpZHRoLCBvZmZzZXQpXG4gICAgICAgICAgICAgIHwgXyAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgICAgKVxuICAgICAgICB8IF8gLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICB3aXRoIE5vdF9mb3VuZCB8IEZhaWx1cmUgXyAtPlxuICAgICAgICBzdHJfaW5kLCBCcmVhayAoXCJAO1wiLCAxLCAwKVxuICAgIGluXG4gICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBuZXh0X2luZCBlbmRfaW5kIGluXG4gICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKGZvcm1hdHRpbmdfbGl0LCBmbXRfcmVzdCkpXG5cbiAgKCogUGFyc2UgdGhlIHNpemUgaW4gYSA8bj4uICopXG4gIGFuZCBwYXJzZV9tYWdpY19zaXplIDogdHlwZSBlIGYgLiBpbnQgLT4gaW50IC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIHN0cl9pbmQgZW5kX2luZCAtPlxuICAgIG1hdGNoXG4gICAgICB0cnlcbiAgICAgICAgbGV0IHN0cl9pbmRfMSA9IHBhcnNlX3NwYWNlcyBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgICAgbWF0Y2ggc3RyLltzdHJfaW5kXzFdIHdpdGhcbiAgICAgICAgfCAnMCcgLi4gJzknIHwgJy0nIC0+XG4gICAgICAgICAgbGV0IHN0cl9pbmRfMiwgc2l6ZSA9IHBhcnNlX2ludGVnZXIgc3RyX2luZF8xIGVuZF9pbmQgaW5cbiAgICAgICAgICBsZXQgc3RyX2luZF8zID0gcGFyc2Vfc3BhY2VzIHN0cl9pbmRfMiBlbmRfaW5kIGluXG4gICAgICAgICAgaWYgc3RyLltzdHJfaW5kXzNdIDw+ICc+JyB0aGVuIHJhaXNlIE5vdF9mb3VuZDtcbiAgICAgICAgICBsZXQgcyA9IFN0cmluZy5zdWIgc3RyIChzdHJfaW5kIC0gMikgKHN0cl9pbmRfMyAtIHN0cl9pbmQgKyAzKSBpblxuICAgICAgICAgIFNvbWUgKHN0cl9pbmRfMyArIDEsIE1hZ2ljX3NpemUgKHMsIHNpemUpKVxuICAgICAgICB8IF8gLT4gTm9uZVxuICAgICAgd2l0aCBOb3RfZm91bmQgfCBGYWlsdXJlIF8gLT5cbiAgICAgICAgTm9uZVxuICAgIHdpdGhcbiAgICB8IFNvbWUgKG5leHRfaW5kLCBmb3JtYXR0aW5nX2xpdCkgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgbmV4dF9pbmQgZW5kX2luZCBpblxuICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKGZvcm1hdHRpbmdfbGl0LCBmbXRfcmVzdCkpXG4gICAgfCBOb25lIC0+XG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKFNjYW5faW5kaWMgJzwnLCBmbXRfcmVzdCkpXG5cbiAgKCogUGFyc2UgYW5kIGNvbnN0cnVjdCBhIGNoYXIgc2V0LiAqKVxuICBhbmQgcGFyc2VfY2hhcl9zZXQgc3RyX2luZCBlbmRfaW5kID1cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuXG4gICAgbGV0IGNoYXJfc2V0ID0gY3JlYXRlX2NoYXJfc2V0ICgpIGluXG4gICAgbGV0IGFkZF9jaGFyIGMgPVxuICAgICAgYWRkX2luX2NoYXJfc2V0IGNoYXJfc2V0IGM7XG4gICAgaW5cbiAgICBsZXQgYWRkX3JhbmdlIGMgYycgPVxuICAgICAgZm9yIGkgPSBpbnRfb2ZfY2hhciBjIHRvIGludF9vZl9jaGFyIGMnIGRvXG4gICAgICAgIGFkZF9pbl9jaGFyX3NldCBjaGFyX3NldCAoY2hhcl9vZl9pbnQgaSk7XG4gICAgICBkb25lO1xuICAgIGluXG5cbiAgICBsZXQgZmFpbF9zaW5nbGVfcGVyY2VudCBzdHJfaW5kID1cbiAgICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgICAgXCJpbnZhbGlkIGZvcm1hdCAlUzogJyUlJyBhbG9uZSBpcyBub3QgYWNjZXB0ZWQgaW4gY2hhcmFjdGVyIHNldHMsIFxcXG4gICAgICAgICB1c2UgJSUlJSBpbnN0ZWFkIGF0IHBvc2l0aW9uICVkLlwiIHN0ciBzdHJfaW5kXG4gICAgaW5cblxuICAgICgqIFBhcnNlIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgYSBjaGFyIHNldC4gKilcbiAgICBsZXQgcmVjIHBhcnNlX2NoYXJfc2V0X3N0YXJ0IHN0cl9pbmQgZW5kX2luZCA9XG4gICAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgbGV0IGMgPSBzdHIuW3N0cl9pbmRdIGluXG4gICAgICBwYXJzZV9jaGFyX3NldF9hZnRlcl9jaGFyIChzdHJfaW5kICsgMSkgZW5kX2luZCBjXG5cbiAgICAoKiBQYXJzZSB0aGUgY29udGVudCBvZiBhIGNoYXIgc2V0IHVudGlsIHRoZSBmaXJzdCAnXScuICopXG4gICAgYW5kIHBhcnNlX2NoYXJfc2V0X2NvbnRlbnQgc3RyX2luZCBlbmRfaW5kID1cbiAgICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICAgIHwgJ10nIC0+XG4gICAgICAgIHN0cl9pbmQgKyAxXG4gICAgICB8ICctJyAtPlxuICAgICAgICBhZGRfY2hhciAnLSc7XG4gICAgICAgIHBhcnNlX2NoYXJfc2V0X2NvbnRlbnQgKHN0cl9pbmQgKyAxKSBlbmRfaW5kXG4gICAgICB8IGMgLT5cbiAgICAgICAgcGFyc2VfY2hhcl9zZXRfYWZ0ZXJfY2hhciAoc3RyX2luZCArIDEpIGVuZF9pbmQgY1xuXG4gICAgKCogVGVzdCBmb3IgcmFuZ2UgaW4gY2hhciBzZXQuICopXG4gICAgYW5kIHBhcnNlX2NoYXJfc2V0X2FmdGVyX2NoYXIgc3RyX2luZCBlbmRfaW5kIGMgPVxuICAgICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgICAgfCAnXScgLT5cbiAgICAgICAgYWRkX2NoYXIgYztcbiAgICAgICAgc3RyX2luZCArIDFcbiAgICAgIHwgJy0nIC0+XG4gICAgICAgIHBhcnNlX2NoYXJfc2V0X2FmdGVyX21pbnVzIChzdHJfaW5kICsgMSkgZW5kX2luZCBjXG4gICAgICB8ICgnJScgfCAnQCcpIGFzIGMnIHdoZW4gYyA9ICclJyAtPlxuICAgICAgICBhZGRfY2hhciBjJztcbiAgICAgICAgcGFyc2VfY2hhcl9zZXRfY29udGVudCAoc3RyX2luZCArIDEpIGVuZF9pbmRcbiAgICAgIHwgYycgLT5cbiAgICAgICAgaWYgYyA9ICclJyB0aGVuIGZhaWxfc2luZ2xlX3BlcmNlbnQgc3RyX2luZDtcbiAgICAgICAgKCogbm90ZSB0aGF0ICdAJyBhbG9uZSBpcyBhY2NlcHRlZCwgYXMgZG9uZSBieSB0aGUgbGVnYWN5XG4gICAgICAgICAgIGltcGxlbWVudGF0aW9uOyB0aGUgZG9jdW1lbnRhdGlvbiBzcGVjaWZpY2FsbHkgcmVxdWlyZXMgJUBcbiAgICAgICAgICAgc28gd2UgY291bGQgd2FybiBvbiB0aGF0ICopXG4gICAgICAgIGFkZF9jaGFyIGM7XG4gICAgICAgIHBhcnNlX2NoYXJfc2V0X2FmdGVyX2NoYXIgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGMnXG5cbiAgICAoKiBNYW5hZ2UgcmFuZ2UgaW4gY2hhciBzZXQgKGV4Y2VwdCBpZiB0aGUgJy0nIHRoZSBsYXN0IGNoYXIgYmVmb3JlICddJykgKilcbiAgICBhbmQgcGFyc2VfY2hhcl9zZXRfYWZ0ZXJfbWludXMgc3RyX2luZCBlbmRfaW5kIGMgPVxuICAgICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgICAgfCAnXScgLT5cbiAgICAgICAgYWRkX2NoYXIgYztcbiAgICAgICAgYWRkX2NoYXIgJy0nO1xuICAgICAgICBzdHJfaW5kICsgMVxuICAgICAgfCAnJScgLT5cbiAgICAgICAgaWYgc3RyX2luZCArIDEgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgICAgIGJlZ2luIG1hdGNoIHN0ci5bc3RyX2luZCArIDFdIHdpdGhcbiAgICAgICAgICB8ICgnJScgfCAnQCcpIGFzIGMnIC0+XG4gICAgICAgICAgICBhZGRfcmFuZ2UgYyBjJztcbiAgICAgICAgICAgIHBhcnNlX2NoYXJfc2V0X2NvbnRlbnQgKHN0cl9pbmQgKyAyKSBlbmRfaW5kXG4gICAgICAgICAgfCBfIC0+IGZhaWxfc2luZ2xlX3BlcmNlbnQgc3RyX2luZFxuICAgICAgICBlbmRcbiAgICAgIHwgYycgLT5cbiAgICAgICAgYWRkX3JhbmdlIGMgYyc7XG4gICAgICAgIHBhcnNlX2NoYXJfc2V0X2NvbnRlbnQgKHN0cl9pbmQgKyAxKSBlbmRfaW5kXG4gICAgaW5cbiAgICBsZXQgc3RyX2luZCwgcmV2ZXJzZSA9XG4gICAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgICAgIHwgJ14nIC0+IHN0cl9pbmQgKyAxLCB0cnVlXG4gICAgICAgIHwgXyAtPiBzdHJfaW5kLCBmYWxzZSBpblxuICAgIGxldCBuZXh0X2luZCA9IHBhcnNlX2NoYXJfc2V0X3N0YXJ0IHN0cl9pbmQgZW5kX2luZCBpblxuICAgIGxldCBjaGFyX3NldCA9IGZyZWV6ZV9jaGFyX3NldCBjaGFyX3NldCBpblxuICAgIG5leHRfaW5kLCAoaWYgcmV2ZXJzZSB0aGVuIHJldl9jaGFyX3NldCBjaGFyX3NldCBlbHNlIGNoYXJfc2V0KVxuXG4gICgqIENvbnN1bWUgYWxsIG5leHQgc3BhY2VzLCByYWlzZSBhbiBGYWlsdXJlIGlmIGVuZF9pbmQgaXMgcmVhY2hlZC4gKilcbiAgYW5kIHBhcnNlX3NwYWNlcyBzdHJfaW5kIGVuZF9pbmQgPVxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgaWYgc3RyLltzdHJfaW5kXSA9ICcgJyB0aGVuIHBhcnNlX3NwYWNlcyAoc3RyX2luZCArIDEpIGVuZF9pbmQgZWxzZSBzdHJfaW5kXG5cbiAgKCogUmVhZCBhIHBvc2l0aXZlIGludGVnZXIgZnJvbSB0aGUgc3RyaW5nLCByYWlzZSBhIEZhaWx1cmUgaWYgZW5kX2luZCBpc1xuICAgICByZWFjaGVkLiAqKVxuICBhbmQgcGFyc2VfcG9zaXRpdmUgc3RyX2luZCBlbmRfaW5kIGFjYyA9XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICB8ICcwJyAuLiAnOScgYXMgYyAtPlxuICAgICAgbGV0IG5ld19hY2MgPSBhY2MgKiAxMCArIChpbnRfb2ZfY2hhciBjIC0gaW50X29mX2NoYXIgJzAnKSBpblxuICAgICAgaWYgbmV3X2FjYyA+IFN5cy5tYXhfc3RyaW5nX2xlbmd0aCB0aGVuXG4gICAgICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgICAgICBcImludmFsaWQgZm9ybWF0ICVTOiBpbnRlZ2VyICVkIGlzIGdyZWF0ZXIgdGhhbiB0aGUgbGltaXQgJWRcIlxuICAgICAgICAgIHN0ciBuZXdfYWNjIFN5cy5tYXhfc3RyaW5nX2xlbmd0aFxuICAgICAgZWxzZVxuICAgICAgICBwYXJzZV9wb3NpdGl2ZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgbmV3X2FjY1xuICAgIHwgXyAtPiBzdHJfaW5kLCBhY2NcblxuICAoKiBSZWFkIGEgcG9zaXRpdmUgb3IgbmVnYXRpdmUgaW50ZWdlciBmcm9tIHRoZSBzdHJpbmcsIHJhaXNlIGEgRmFpbHVyZVxuICAgICBpZiBlbmRfaW5kIGlzIHJlYWNoZWQuICopXG4gIGFuZCBwYXJzZV9pbnRlZ2VyIHN0cl9pbmQgZW5kX2luZCA9XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICB8ICcwJyAuLiAnOScgLT4gcGFyc2VfcG9zaXRpdmUgc3RyX2luZCBlbmRfaW5kIDBcbiAgICB8ICctJyAtPiAoXG4gICAgICBpZiBzdHJfaW5kICsgMSA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICAgIG1hdGNoIHN0ci5bc3RyX2luZCArIDFdIHdpdGhcbiAgICAgIHwgJzAnIC4uICc5JyAtPlxuICAgICAgICBsZXQgbmV4dF9pbmQsIG4gPSBwYXJzZV9wb3NpdGl2ZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgMCBpblxuICAgICAgICBuZXh0X2luZCwgLW5cbiAgICAgIHwgYyAtPlxuICAgICAgICBleHBlY3RlZF9jaGFyYWN0ZXIgKHN0cl9pbmQgKyAxKSBcImRpZ2l0XCIgY1xuICAgIClcbiAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiAgKCogQWRkIGEgbGl0ZXJhbCB0byBhIGZvcm1hdCBmcm9tIGEgbGl0ZXJhbCBjaGFyYWN0ZXIgc3ViLXNlcXVlbmNlLiAqKVxuICBhbmQgYWRkX2xpdGVyYWwgOiB0eXBlIGEgZCBlIGYgLlxuICAgICAgaW50IC0+IGludCAtPiAoYSwgXywgXywgZCwgZSwgZikgZm10IC0+XG4gICAgICAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBsaXRfc3RhcnQgc3RyX2luZCBmbXQgLT4gbWF0Y2ggc3RyX2luZCAtIGxpdF9zdGFydCB3aXRoXG4gICAgfCAwICAgIC0+IEZtdF9FQkIgZm10XG4gICAgfCAxICAgIC0+IEZtdF9FQkIgKENoYXJfbGl0ZXJhbCAoc3RyLltsaXRfc3RhcnRdLCBmbXQpKVxuICAgIHwgc2l6ZSAtPiBGbXRfRUJCIChTdHJpbmdfbGl0ZXJhbCAoU3RyaW5nLnN1YiBzdHIgbGl0X3N0YXJ0IHNpemUsIGZtdCkpXG5cbiAgKCogU2VhcmNoIHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgc3ViLWZvcm1hdFxuICAgICAoaS5lLiB0aGUgY29ycmVzcG9uZGluZyBcIiV9XCIgb3IgXCIlKVwiKSAqKVxuICBhbmQgc2VhcmNoX3N1YmZvcm1hdF9lbmQgc3RyX2luZCBlbmRfaW5kIGMgPVxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW5cbiAgICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgICAgXCJpbnZhbGlkIGZvcm1hdCAlUzogdW5jbG9zZWQgc3ViLWZvcm1hdCwgXFxcbiAgICAgICAgIGV4cGVjdGVkIFxcXCIlJSVjXFxcIiBhdCBjaGFyYWN0ZXIgbnVtYmVyICVkXCIgc3RyIGMgZW5kX2luZDtcbiAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICB8ICclJyAtPlxuICAgICAgaWYgc3RyX2luZCArIDEgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgICBpZiBzdHIuW3N0cl9pbmQgKyAxXSA9IGMgdGhlbiAoKiBFbmQgb2YgZm9ybWF0IGZvdW5kICopIHN0cl9pbmQgZWxzZVxuICAgICAgICBiZWdpbiBtYXRjaCBzdHIuW3N0cl9pbmQgKyAxXSB3aXRoXG4gICAgICAgIHwgJ18nIC0+XG4gICAgICAgICAgKCogU2VhcmNoIGZvciBcIiVfKFwiIG9yIFwiJV97XCIuICopXG4gICAgICAgICAgaWYgc3RyX2luZCArIDIgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgICAgICAgYmVnaW4gbWF0Y2ggc3RyLltzdHJfaW5kICsgMl0gd2l0aFxuICAgICAgICAgIHwgJ3snIC0+XG4gICAgICAgICAgICBsZXQgc3ViX2VuZCA9IHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdHJfaW5kICsgMykgZW5kX2luZCAnfScgaW5cbiAgICAgICAgICAgIHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdWJfZW5kICsgMikgZW5kX2luZCBjXG4gICAgICAgICAgfCAnKCcgLT5cbiAgICAgICAgICAgIGxldCBzdWJfZW5kID0gc2VhcmNoX3N1YmZvcm1hdF9lbmQgKHN0cl9pbmQgKyAzKSBlbmRfaW5kICcpJyBpblxuICAgICAgICAgICAgc2VhcmNoX3N1YmZvcm1hdF9lbmQgKHN1Yl9lbmQgKyAyKSBlbmRfaW5kIGNcbiAgICAgICAgICB8IF8gLT4gc2VhcmNoX3N1YmZvcm1hdF9lbmQgKHN0cl9pbmQgKyAzKSBlbmRfaW5kIGNcbiAgICAgICAgICBlbmRcbiAgICAgICAgfCAneycgLT5cbiAgICAgICAgICAoKiAley4uLiV9IHN1Yi1mb3JtYXQgZm91bmQuICopXG4gICAgICAgICAgbGV0IHN1Yl9lbmQgPSBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3RyX2luZCArIDIpIGVuZF9pbmQgJ30nIGluXG4gICAgICAgICAgc2VhcmNoX3N1YmZvcm1hdF9lbmQgKHN1Yl9lbmQgKyAyKSBlbmRfaW5kIGNcbiAgICAgICAgfCAnKCcgLT5cbiAgICAgICAgICAoKiAlKC4uLiUpIHN1Yi1mb3JtYXQgZm91bmQuICopXG4gICAgICAgICAgbGV0IHN1Yl9lbmQgPSBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3RyX2luZCArIDIpIGVuZF9pbmQgJyknIGluXG4gICAgICAgICAgc2VhcmNoX3N1YmZvcm1hdF9lbmQgKHN1Yl9lbmQgKyAyKSBlbmRfaW5kIGNcbiAgICAgICAgfCAnfScgLT5cbiAgICAgICAgICAoKiBFcnJvcjogJSguLi4lfS4gKilcbiAgICAgICAgICBleHBlY3RlZF9jaGFyYWN0ZXIgKHN0cl9pbmQgKyAxKSBcImNoYXJhY3RlciAnKSdcIiAnfSdcbiAgICAgICAgfCAnKScgLT5cbiAgICAgICAgICAoKiBFcnJvcjogJXsuLi4lKS4gKilcbiAgICAgICAgICBleHBlY3RlZF9jaGFyYWN0ZXIgKHN0cl9pbmQgKyAxKSBcImNoYXJhY3RlciAnfSdcIiAnKSdcbiAgICAgICAgfCBfIC0+XG4gICAgICAgICAgc2VhcmNoX3N1YmZvcm1hdF9lbmQgKHN0cl9pbmQgKyAyKSBlbmRfaW5kIGNcbiAgICAgICAgZW5kXG4gICAgfCBfIC0+IHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdHJfaW5kICsgMSkgZW5kX2luZCBjXG5cbiAgKCogQ2hlY2sgaWYgc3ltYiBpcyBhIHZhbGlkIGludCBjb252ZXJzaW9uIGFmdGVyIFwiJWxcIiwgXCIlblwiIG9yIFwiJUxcIiAqKVxuICBhbmQgaXNfaW50X2Jhc2Ugc3ltYiA9IG1hdGNoIHN5bWIgd2l0aFxuICAgIHwgJ2QnIHwgJ2knIHwgJ3gnIHwgJ1gnIHwgJ28nIHwgJ3UnIC0+IHRydWVcbiAgICB8IF8gLT4gZmFsc2VcblxuICAoKiBDb252ZXJ0IGEgY2hhciAobCwgbiBvciBMKSB0byBpdHMgYXNzb2NpYXRlZCBjb3VudGVyLiAqKVxuICBhbmQgY291bnRlcl9vZl9jaGFyIHN5bWIgPSBtYXRjaCBzeW1iIHdpdGhcbiAgICB8ICdsJyAtPiBMaW5lX2NvdW50ZXIgIHwgJ24nIC0+IENoYXJfY291bnRlclxuICAgIHwgJ0wnIC0+IFRva2VuX2NvdW50ZXIgfCBfIC0+IGFzc2VydCBmYWxzZVxuXG4gICgqIENvbnZlcnQgKHBsdXMsIHN5bWIpIHRvIGl0cyBhc3NvY2lhdGVkIGludF9jb252LiAqKVxuICBhbmQgY29tcHV0ZV9pbnRfY29udiBwY3RfaW5kIHN0cl9pbmQgcGx1cyBoYXNoIHNwYWNlIHN5bWIgPVxuICAgIG1hdGNoIHBsdXMsIGhhc2gsIHNwYWNlLCBzeW1iIHdpdGhcbiAgICB8IGZhbHNlLCBmYWxzZSwgZmFsc2UsICdkJyAtPiBJbnRfZCAgfCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAnaScgLT4gSW50X2lcbiAgICB8IGZhbHNlLCBmYWxzZSwgIHRydWUsICdkJyAtPiBJbnRfc2QgfCBmYWxzZSwgZmFsc2UsICB0cnVlLCAnaScgLT4gSW50X3NpXG4gICAgfCAgdHJ1ZSwgZmFsc2UsIGZhbHNlLCAnZCcgLT4gSW50X3BkIHwgIHRydWUsIGZhbHNlLCBmYWxzZSwgJ2knIC0+IEludF9waVxuICAgIHwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgJ3gnIC0+IEludF94ICB8IGZhbHNlLCBmYWxzZSwgZmFsc2UsICdYJyAtPiBJbnRfWFxuICAgIHwgZmFsc2UsICB0cnVlLCBmYWxzZSwgJ3gnIC0+IEludF9DeCB8IGZhbHNlLCAgdHJ1ZSwgZmFsc2UsICdYJyAtPiBJbnRfQ1hcbiAgICB8IGZhbHNlLCBmYWxzZSwgZmFsc2UsICdvJyAtPiBJbnRfb1xuICAgIHwgZmFsc2UsICB0cnVlLCBmYWxzZSwgJ28nIC0+IEludF9Db1xuICAgIHwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgJ3UnIC0+IEludF91XG4gICAgfCBmYWxzZSwgIHRydWUsIGZhbHNlLCAnZCcgLT4gSW50X0NkXG4gICAgfCBmYWxzZSwgIHRydWUsIGZhbHNlLCAnaScgLT4gSW50X0NpXG4gICAgfCBmYWxzZSwgIHRydWUsIGZhbHNlLCAndScgLT4gSW50X0N1XG4gICAgfCBfLCB0cnVlLCBfLCAneCcgd2hlbiBsZWdhY3lfYmVoYXZpb3IgLT4gSW50X0N4XG4gICAgfCBfLCB0cnVlLCBfLCAnWCcgd2hlbiBsZWdhY3lfYmVoYXZpb3IgLT4gSW50X0NYXG4gICAgfCBfLCB0cnVlLCBfLCAnbycgd2hlbiBsZWdhY3lfYmVoYXZpb3IgLT4gSW50X0NvXG4gICAgfCBfLCB0cnVlLCBfLCAoJ2QnIHwgJ2knIHwgJ3UnKSAtPlxuICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW4gKCogaWdub3JlICopXG4gICAgICAgIGNvbXB1dGVfaW50X2NvbnYgcGN0X2luZCBzdHJfaW5kIHBsdXMgZmFsc2Ugc3BhY2Ugc3ltYlxuICAgICAgZWxzZSBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgc3ltYiBcIicjJ1wiXG4gICAgfCB0cnVlLCBfLCB0cnVlLCBfIC0+XG4gICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlblxuICAgICAgICAoKiBwbHVzIGFuZCBzcGFjZTogbGVnYWN5IGltcGxlbWVudGF0aW9uIHByZWZlcnMgcGx1cyAqKVxuICAgICAgICBjb21wdXRlX2ludF9jb252IHBjdF9pbmQgc3RyX2luZCBwbHVzIGhhc2ggZmFsc2Ugc3ltYlxuICAgICAgZWxzZSBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgJyAnIFwiJysnXCJcbiAgICB8IGZhbHNlLCBfLCB0cnVlLCBfICAgIC0+XG4gICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiAoKiBpZ25vcmUgKilcbiAgICAgICAgY29tcHV0ZV9pbnRfY29udiBwY3RfaW5kIHN0cl9pbmQgcGx1cyBoYXNoIGZhbHNlIHN5bWJcbiAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIHN5bWIgXCInICdcIlxuICAgIHwgdHJ1ZSwgXywgZmFsc2UsIF8gICAgLT5cbiAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuICgqIGlnbm9yZSAqKVxuICAgICAgICBjb21wdXRlX2ludF9jb252IHBjdF9pbmQgc3RyX2luZCBmYWxzZSBoYXNoIHNwYWNlIHN5bWJcbiAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIHN5bWIgXCInKydcIlxuICAgIHwgZmFsc2UsIF8sIGZhbHNlLCBfIC0+IGFzc2VydCBmYWxzZVxuXG4gICgqIENvbnZlcnQgKHBsdXMsIHNwYWNlLCBzeW1iKSB0byBpdHMgYXNzb2NpYXRlZCBmbG9hdF9jb252LiAqKVxuICBhbmQgY29tcHV0ZV9mbG9hdF9jb252IHBjdF9pbmQgc3RyX2luZCBwbHVzIGhhc2ggc3BhY2Ugc3ltYiA9XG4gICAgbGV0IGZsYWcgPSBtYXRjaCBwbHVzLCBzcGFjZSB3aXRoXG4gICAgfCBmYWxzZSwgZmFsc2UgLT4gRmxvYXRfZmxhZ19cbiAgICB8IGZhbHNlLCAgdHJ1ZSAtPiBGbG9hdF9mbGFnX3NcbiAgICB8ICB0cnVlLCBmYWxzZSAtPiBGbG9hdF9mbGFnX3BcbiAgICB8ICB0cnVlLCAgdHJ1ZSAtPlxuICAgICAgKCogcGx1cyBhbmQgc3BhY2U6IGxlZ2FjeSBpbXBsZW1lbnRhdGlvbiBwcmVmZXJzIHBsdXMgKilcbiAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuIEZsb2F0X2ZsYWdfcFxuICAgICAgZWxzZSBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgJyAnIFwiJysnXCIgaW5cbiAgICBsZXQga2luZCA9IG1hdGNoIGhhc2gsIHN5bWIgd2l0aFxuICAgIHwgXywgJ2YnIC0+IEZsb2F0X2ZcbiAgICB8IF8sICdlJyAtPiBGbG9hdF9lXG4gICAgfCBfLCAnRScgLT4gRmxvYXRfRVxuICAgIHwgXywgJ2cnIC0+IEZsb2F0X2dcbiAgICB8IF8sICdHJyAtPiBGbG9hdF9HXG4gICAgfCBfLCAnaCcgLT4gRmxvYXRfaFxuICAgIHwgXywgJ0gnIC0+IEZsb2F0X0hcbiAgICB8IGZhbHNlLCAnRicgLT4gRmxvYXRfRlxuICAgIHwgdHJ1ZSwgJ0YnIC0+IEZsb2F0X0NGXG4gICAgfCBfIC0+IGFzc2VydCBmYWxzZSBpblxuICAgIGZsYWcsIGtpbmRcblxuICAoKiBSYWlzZSBbRmFpbHVyZV0gd2l0aCBhIGZyaWVuZGx5IGVycm9yIG1lc3NhZ2UgYWJvdXQgaW5jb21wYXRpYmxlIG9wdGlvbnMuKilcbiAgYW5kIGluY29tcGF0aWJsZV9mbGFnIDogdHlwZSBhIC4gaW50IC0+IGludCAtPiBjaGFyIC0+IHN0cmluZyAtPiBhID1cbiAgICBmdW4gcGN0X2luZCBzdHJfaW5kIHN5bWIgb3B0aW9uIC0+XG4gICAgICBsZXQgc3ViZm10ID0gU3RyaW5nLnN1YiBzdHIgcGN0X2luZCAoc3RyX2luZCAtIHBjdF9pbmQpIGluXG4gICAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICAgIFwiaW52YWxpZCBmb3JtYXQgJVM6IGF0IGNoYXJhY3RlciBudW1iZXIgJWQsIFxcXG4gICAgICAgICAlcyBpcyBpbmNvbXBhdGlibGUgd2l0aCAnJWMnIGluIHN1Yi1mb3JtYXQgJVNcIlxuICAgICAgICBzdHIgcGN0X2luZCBvcHRpb24gc3ltYiBzdWJmbXRcblxuICBpbiBwYXJzZSAwIChTdHJpbmcubGVuZ3RoIHN0cilcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICgqIEd1YXJkZWQgc3RyaW5nIHRvIGZvcm1hdCBjb252ZXJzaW9ucyAqKVxuXG4oKiBDb252ZXJ0IGEgc3RyaW5nIHRvIGEgZm9ybWF0IGFjY29yZGluZyB0byBhbiBmbXR0eS4gKilcbigqIFJhaXNlIFtGYWlsdXJlXSB3aXRoIGFuIGVycm9yIG1lc3NhZ2UgaW4gY2FzZSBvZiB0eXBlIG1pc21hdGNoLiAqKVxubGV0IGZvcm1hdF9vZl9zdHJpbmdfZm10dHkgc3RyIGZtdHR5ID1cbiAgbGV0IEZtdF9FQkIgZm10ID0gZm10X2ViYl9vZl9zdHJpbmcgc3RyIGluXG4gIHRyeSBGb3JtYXQgKHR5cGVfZm9ybWF0IGZtdCBmbXR0eSwgc3RyKVxuICB3aXRoIFR5cGVfbWlzbWF0Y2ggLT5cbiAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICBcImJhZCBpbnB1dDogZm9ybWF0IHR5cGUgbWlzbWF0Y2ggYmV0d2VlbiAlUyBhbmQgJVNcIlxuICAgICAgc3RyIChzdHJpbmdfb2ZfZm10dHkgZm10dHkpXG5cbigqIENvbnZlcnQgYSBzdHJpbmcgdG8gYSBmb3JtYXQgY29tcGF0aWJsZSB3aXRoIGFuIG90aGVyIGZvcm1hdC4gKilcbigqIFJhaXNlIFtGYWlsdXJlXSB3aXRoIGFuIGVycm9yIG1lc3NhZ2UgaW4gY2FzZSBvZiB0eXBlIG1pc21hdGNoLiAqKVxubGV0IGZvcm1hdF9vZl9zdHJpbmdfZm9ybWF0IHN0ciAoRm9ybWF0IChmbXQnLCBzdHInKSkgPVxuICBsZXQgRm10X0VCQiBmbXQgPSBmbXRfZWJiX29mX3N0cmluZyBzdHIgaW5cbiAgdHJ5IEZvcm1hdCAodHlwZV9mb3JtYXQgZm10IChmbXR0eV9vZl9mbXQgZm10JyksIHN0cilcbiAgd2l0aCBUeXBlX21pc21hdGNoIC0+XG4gICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgXCJiYWQgaW5wdXQ6IGZvcm1hdCB0eXBlIG1pc21hdGNoIGJldHdlZW4gJVMgYW5kICVTXCIgc3RyIHN0cidcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxub3BlbiBQcmludGZcblxudHlwZSB0ID0gZXhuID0gLi5cblxubGV0IHByaW50ZXJzID0gQXRvbWljLm1ha2UgW11cblxubGV0IGxvY2ZtdCA9IGZvcm1hdF9vZl9zdHJpbmcgXCJGaWxlIFxcXCIlc1xcXCIsIGxpbmUgJWQsIGNoYXJhY3RlcnMgJWQtJWQ6ICVzXCJcblxubGV0IGZpZWxkIHggaSA9XG4gIGxldCBmID0gT2JqLmZpZWxkIHggaSBpblxuICBpZiBub3QgKE9iai5pc19ibG9jayBmKSB0aGVuXG4gICAgc3ByaW50ZiBcIiVkXCIgKE9iai5tYWdpYyBmIDogaW50KSAgICAgICAgICAgKCogY2FuIGFsc28gYmUgYSBjaGFyICopXG4gIGVsc2UgaWYgT2JqLnRhZyBmID0gT2JqLnN0cmluZ190YWcgdGhlblxuICAgIHNwcmludGYgXCIlU1wiIChPYmoubWFnaWMgZiA6IHN0cmluZylcbiAgZWxzZSBpZiBPYmoudGFnIGYgPSBPYmouZG91YmxlX3RhZyB0aGVuXG4gICAgc3RyaW5nX29mX2Zsb2F0IChPYmoubWFnaWMgZiA6IGZsb2F0KVxuICBlbHNlXG4gICAgXCJfXCJcblxubGV0IHJlYyBvdGhlcl9maWVsZHMgeCBpID1cbiAgaWYgaSA+PSBPYmouc2l6ZSB4IHRoZW4gXCJcIlxuICBlbHNlIHNwcmludGYgXCIsICVzJXNcIiAoZmllbGQgeCBpKSAob3RoZXJfZmllbGRzIHggKGkrMSkpXG5cbmxldCBmaWVsZHMgeCA9XG4gIG1hdGNoIE9iai5zaXplIHggd2l0aFxuICB8IDAgLT4gXCJcIlxuICB8IDEgLT4gXCJcIlxuICB8IDIgLT4gc3ByaW50ZiBcIiglcylcIiAoZmllbGQgeCAxKVxuICB8IF8gLT4gc3ByaW50ZiBcIiglcyVzKVwiIChmaWVsZCB4IDEpIChvdGhlcl9maWVsZHMgeCAyKVxuXG5sZXQgdXNlX3ByaW50ZXJzIHggPVxuICBsZXQgcmVjIGNvbnYgPSBmdW5jdGlvblxuICAgIHwgaGQgOjogdGwgLT5cbiAgICAgICAgKG1hdGNoIGhkIHggd2l0aFxuICAgICAgICAgfCBOb25lIHwgZXhjZXB0aW9uIF8gLT4gY29udiB0bFxuICAgICAgICAgfCBTb21lIHMgLT4gU29tZSBzKVxuICAgIHwgW10gLT4gTm9uZSBpblxuICBjb252IChBdG9taWMuZ2V0IHByaW50ZXJzKVxuXG5sZXQgdG9fc3RyaW5nX2RlZmF1bHQgPSBmdW5jdGlvblxuICB8IE91dF9vZl9tZW1vcnkgLT4gXCJPdXQgb2YgbWVtb3J5XCJcbiAgfCBTdGFja19vdmVyZmxvdyAtPiBcIlN0YWNrIG92ZXJmbG93XCJcbiAgfCBNYXRjaF9mYWlsdXJlKGZpbGUsIGxpbmUsIGNoYXIpIC0+XG4gICAgICBzcHJpbnRmIGxvY2ZtdCBmaWxlIGxpbmUgY2hhciAoY2hhcis1KSBcIlBhdHRlcm4gbWF0Y2hpbmcgZmFpbGVkXCJcbiAgfCBBc3NlcnRfZmFpbHVyZShmaWxlLCBsaW5lLCBjaGFyKSAtPlxuICAgICAgc3ByaW50ZiBsb2NmbXQgZmlsZSBsaW5lIGNoYXIgKGNoYXIrNikgXCJBc3NlcnRpb24gZmFpbGVkXCJcbiAgfCBVbmRlZmluZWRfcmVjdXJzaXZlX21vZHVsZShmaWxlLCBsaW5lLCBjaGFyKSAtPlxuICAgICAgc3ByaW50ZiBsb2NmbXQgZmlsZSBsaW5lIGNoYXIgKGNoYXIrNikgXCJVbmRlZmluZWQgcmVjdXJzaXZlIG1vZHVsZVwiXG4gIHwgeCAtPlxuICAgICAgbGV0IHggPSBPYmoucmVwciB4IGluXG4gICAgICBpZiBPYmoudGFnIHggPD4gMCB0aGVuXG4gICAgICAgIChPYmoubWFnaWMgKE9iai5maWVsZCB4IDApIDogc3RyaW5nKVxuICAgICAgZWxzZVxuICAgICAgICBsZXQgY29uc3RydWN0b3IgPVxuICAgICAgICAgIChPYmoubWFnaWMgKE9iai5maWVsZCAoT2JqLmZpZWxkIHggMCkgMCkgOiBzdHJpbmcpIGluXG4gICAgICAgIGNvbnN0cnVjdG9yIF4gKGZpZWxkcyB4KVxuXG5sZXQgdG9fc3RyaW5nIGUgPVxuICBtYXRjaCB1c2VfcHJpbnRlcnMgZSB3aXRoXG4gIHwgU29tZSBzIC0+IHNcbiAgfCBOb25lIC0+IHRvX3N0cmluZ19kZWZhdWx0IGVcblxubGV0IHByaW50IGZjdCBhcmcgPVxuICB0cnlcbiAgICBmY3QgYXJnXG4gIHdpdGggeCAtPlxuICAgIGVwcmludGYgXCJVbmNhdWdodCBleGNlcHRpb246ICVzXFxuXCIgKHRvX3N0cmluZyB4KTtcbiAgICBmbHVzaCBzdGRlcnI7XG4gICAgcmFpc2UgeFxuXG5sZXQgY2F0Y2ggZmN0IGFyZyA9XG4gIHRyeVxuICAgIGZjdCBhcmdcbiAgd2l0aCB4IC0+XG4gICAgZmx1c2ggc3Rkb3V0O1xuICAgIGVwcmludGYgXCJVbmNhdWdodCBleGNlcHRpb246ICVzXFxuXCIgKHRvX3N0cmluZyB4KTtcbiAgICBleGl0IDJcblxudHlwZSByYXdfYmFja3RyYWNlX3Nsb3RcbnR5cGUgcmF3X2JhY2t0cmFjZV9lbnRyeSA9IHByaXZhdGUgaW50XG50eXBlIHJhd19iYWNrdHJhY2UgPSByYXdfYmFja3RyYWNlX2VudHJ5IGFycmF5XG5cbmxldCByYXdfYmFja3RyYWNlX2VudHJpZXMgYnQgPSBidFxuXG5leHRlcm5hbCBnZXRfcmF3X2JhY2t0cmFjZTpcbiAgdW5pdCAtPiByYXdfYmFja3RyYWNlID0gXCJjYW1sX2dldF9leGNlcHRpb25fcmF3X2JhY2t0cmFjZVwiXG5cbmV4dGVybmFsIHJhaXNlX3dpdGhfYmFja3RyYWNlOiBleG4gLT4gcmF3X2JhY2t0cmFjZSAtPiAnYVxuICA9IFwiJXJhaXNlX3dpdGhfYmFja3RyYWNlXCJcblxudHlwZSBiYWNrdHJhY2Vfc2xvdCA9XG4gIHwgS25vd25fbG9jYXRpb24gb2Yge1xuICAgICAgaXNfcmFpc2UgICAgOiBib29sO1xuICAgICAgZmlsZW5hbWUgICAgOiBzdHJpbmc7XG4gICAgICBsaW5lX251bWJlciA6IGludDtcbiAgICAgIHN0YXJ0X2NoYXIgIDogaW50O1xuICAgICAgZW5kX2NoYXIgICAgOiBpbnQ7XG4gICAgICBpc19pbmxpbmUgICA6IGJvb2w7XG4gICAgICBkZWZuYW1lICAgICA6IHN0cmluZztcbiAgICB9XG4gIHwgVW5rbm93bl9sb2NhdGlvbiBvZiB7XG4gICAgICBpc19yYWlzZSA6IGJvb2xcbiAgICB9XG5cbigqIHRvIGF2b2lkIHdhcm5pbmcgKilcbmxldCBfID0gW0tub3duX2xvY2F0aW9uIHsgaXNfcmFpc2UgPSBmYWxzZTsgZmlsZW5hbWUgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lX251bWJlciA9IDA7IHN0YXJ0X2NoYXIgPSAwOyBlbmRfY2hhciA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlzX2lubGluZSA9IGZhbHNlOyBkZWZuYW1lID0gXCJcIiB9O1xuICAgICAgICAgVW5rbm93bl9sb2NhdGlvbiB7IGlzX3JhaXNlID0gZmFsc2UgfV1cblxuZXh0ZXJuYWwgY29udmVydF9yYXdfYmFja3RyYWNlX3Nsb3Q6XG4gIHJhd19iYWNrdHJhY2Vfc2xvdCAtPiBiYWNrdHJhY2Vfc2xvdCA9IFwiY2FtbF9jb252ZXJ0X3Jhd19iYWNrdHJhY2Vfc2xvdFwiXG5cbmV4dGVybmFsIGNvbnZlcnRfcmF3X2JhY2t0cmFjZTpcbiAgcmF3X2JhY2t0cmFjZSAtPiBiYWNrdHJhY2Vfc2xvdCBhcnJheSA9IFwiY2FtbF9jb252ZXJ0X3Jhd19iYWNrdHJhY2VcIlxuXG5sZXQgY29udmVydF9yYXdfYmFja3RyYWNlIGJ0ID1cbiAgdHJ5IFNvbWUgKGNvbnZlcnRfcmF3X2JhY2t0cmFjZSBidClcbiAgd2l0aCBGYWlsdXJlIF8gLT4gTm9uZVxuXG5sZXQgZm9ybWF0X2JhY2t0cmFjZV9zbG90IHBvcyBzbG90ID1cbiAgbGV0IGluZm8gaXNfcmFpc2UgPVxuICAgIGlmIGlzX3JhaXNlIHRoZW5cbiAgICAgIGlmIHBvcyA9IDAgdGhlbiBcIlJhaXNlZCBhdFwiIGVsc2UgXCJSZS1yYWlzZWQgYXRcIlxuICAgIGVsc2VcbiAgICAgIGlmIHBvcyA9IDAgdGhlbiBcIlJhaXNlZCBieSBwcmltaXRpdmUgb3BlcmF0aW9uIGF0XCIgZWxzZSBcIkNhbGxlZCBmcm9tXCJcbiAgaW5cbiAgbWF0Y2ggc2xvdCB3aXRoXG4gIHwgVW5rbm93bl9sb2NhdGlvbiBsIC0+XG4gICAgICBpZiBsLmlzX3JhaXNlIHRoZW5cbiAgICAgICAgKCogY29tcGlsZXItaW5zZXJ0ZWQgcmUtcmFpc2UsIHNraXBwZWQgKikgTm9uZVxuICAgICAgZWxzZVxuICAgICAgICBTb21lIChzcHJpbnRmIFwiJXMgdW5rbm93biBsb2NhdGlvblwiIChpbmZvIGZhbHNlKSlcbiAgfCBLbm93bl9sb2NhdGlvbiBsIC0+XG4gICAgICBTb21lIChzcHJpbnRmIFwiJXMgJXMgaW4gZmlsZSBcXFwiJXNcXFwiJXMsIGxpbmUgJWQsIGNoYXJhY3RlcnMgJWQtJWRcIlxuICAgICAgICAgICAgICAoaW5mbyBsLmlzX3JhaXNlKSBsLmRlZm5hbWUgbC5maWxlbmFtZVxuICAgICAgICAgICAgICAoaWYgbC5pc19pbmxpbmUgdGhlbiBcIiAoaW5saW5lZClcIiBlbHNlIFwiXCIpXG4gICAgICAgICAgICAgIGwubGluZV9udW1iZXIgbC5zdGFydF9jaGFyIGwuZW5kX2NoYXIpXG5cbmxldCBwcmludF9leGNlcHRpb25fYmFja3RyYWNlIG91dGNoYW4gYmFja3RyYWNlID1cbiAgbWF0Y2ggYmFja3RyYWNlIHdpdGhcbiAgfCBOb25lIC0+XG4gICAgICBmcHJpbnRmIG91dGNoYW5cbiAgICAgICAgXCIoUHJvZ3JhbSBub3QgbGlua2VkIHdpdGggLWcsIGNhbm5vdCBwcmludCBzdGFjayBiYWNrdHJhY2UpXFxuXCJcbiAgfCBTb21lIGEgLT5cbiAgICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggYSAtIDEgZG9cbiAgICAgICAgbWF0Y2ggZm9ybWF0X2JhY2t0cmFjZV9zbG90IGkgYS4oaSkgd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPiAoKVxuICAgICAgICAgIHwgU29tZSBzdHIgLT4gZnByaW50ZiBvdXRjaGFuIFwiJXNcXG5cIiBzdHJcbiAgICAgIGRvbmVcblxubGV0IHByaW50X3Jhd19iYWNrdHJhY2Ugb3V0Y2hhbiByYXdfYmFja3RyYWNlID1cbiAgcHJpbnRfZXhjZXB0aW9uX2JhY2t0cmFjZSBvdXRjaGFuIChjb252ZXJ0X3Jhd19iYWNrdHJhY2UgcmF3X2JhY2t0cmFjZSlcblxuKCogY29uZnVzaW5nbHkgbmFtZWQ6IHByaW50cyB0aGUgZ2xvYmFsIGN1cnJlbnQgYmFja3RyYWNlICopXG5sZXQgcHJpbnRfYmFja3RyYWNlIG91dGNoYW4gPVxuICBwcmludF9yYXdfYmFja3RyYWNlIG91dGNoYW4gKGdldF9yYXdfYmFja3RyYWNlICgpKVxuXG5sZXQgYmFja3RyYWNlX3RvX3N0cmluZyBiYWNrdHJhY2UgPVxuICBtYXRjaCBiYWNrdHJhY2Ugd2l0aFxuICB8IE5vbmUgLT5cbiAgICAgXCIoUHJvZ3JhbSBub3QgbGlua2VkIHdpdGggLWcsIGNhbm5vdCBwcmludCBzdGFjayBiYWNrdHJhY2UpXFxuXCJcbiAgfCBTb21lIGEgLT5cbiAgICAgIGxldCBiID0gQnVmZmVyLmNyZWF0ZSAxMDI0IGluXG4gICAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGEgLSAxIGRvXG4gICAgICAgIG1hdGNoIGZvcm1hdF9iYWNrdHJhY2Vfc2xvdCBpIGEuKGkpIHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gKClcbiAgICAgICAgICB8IFNvbWUgc3RyIC0+IGJwcmludGYgYiBcIiVzXFxuXCIgc3RyXG4gICAgICBkb25lO1xuICAgICAgQnVmZmVyLmNvbnRlbnRzIGJcblxubGV0IHJhd19iYWNrdHJhY2VfdG9fc3RyaW5nIHJhd19iYWNrdHJhY2UgPVxuICBiYWNrdHJhY2VfdG9fc3RyaW5nIChjb252ZXJ0X3Jhd19iYWNrdHJhY2UgcmF3X2JhY2t0cmFjZSlcblxubGV0IGJhY2t0cmFjZV9zbG90X2lzX3JhaXNlID0gZnVuY3Rpb25cbiAgfCBLbm93bl9sb2NhdGlvbiBsIC0+IGwuaXNfcmFpc2VcbiAgfCBVbmtub3duX2xvY2F0aW9uIGwgLT4gbC5pc19yYWlzZVxuXG5sZXQgYmFja3RyYWNlX3Nsb3RfaXNfaW5saW5lID0gZnVuY3Rpb25cbiAgfCBLbm93bl9sb2NhdGlvbiBsIC0+IGwuaXNfaW5saW5lXG4gIHwgVW5rbm93bl9sb2NhdGlvbiBfIC0+IGZhbHNlXG5cbnR5cGUgbG9jYXRpb24gPSB7XG4gIGZpbGVuYW1lIDogc3RyaW5nO1xuICBsaW5lX251bWJlciA6IGludDtcbiAgc3RhcnRfY2hhciA6IGludDtcbiAgZW5kX2NoYXIgOiBpbnQ7XG59XG5cbmxldCBiYWNrdHJhY2Vfc2xvdF9sb2NhdGlvbiA9IGZ1bmN0aW9uXG4gIHwgVW5rbm93bl9sb2NhdGlvbiBfIC0+IE5vbmVcbiAgfCBLbm93bl9sb2NhdGlvbiBsIC0+XG4gICAgU29tZSB7XG4gICAgICBmaWxlbmFtZSAgICA9IGwuZmlsZW5hbWU7XG4gICAgICBsaW5lX251bWJlciA9IGwubGluZV9udW1iZXI7XG4gICAgICBzdGFydF9jaGFyICA9IGwuc3RhcnRfY2hhcjtcbiAgICAgIGVuZF9jaGFyICAgID0gbC5lbmRfY2hhcjtcbiAgICB9XG5cbmxldCBiYWNrdHJhY2Vfc2xvdF9kZWZuYW1lID0gZnVuY3Rpb25cbiAgfCBVbmtub3duX2xvY2F0aW9uIF9cbiAgfCBLbm93bl9sb2NhdGlvbiB7IGRlZm5hbWUgPSBcIlwiIH0gLT4gTm9uZVxuICB8IEtub3duX2xvY2F0aW9uIGwgLT4gU29tZSBsLmRlZm5hbWVcblxubGV0IGJhY2t0cmFjZV9zbG90cyByYXdfYmFja3RyYWNlID1cbiAgKCogVGhlIGRvY3VtZW50YXRpb24gb2YgdGhpcyBmdW5jdGlvbiBndWFyYW50ZWVzIHRoYXQgU29tZSBpc1xuICAgICByZXR1cm5lZCBvbmx5IGlmIGEgcGFydCBvZiB0aGUgdHJhY2UgaXMgdXNhYmxlLiBUaGlzIGdpdmVzIHVzXG4gICAgIGEgYml0IG1vcmUgd29yayB0aGFuIGp1c3QgY29udmVydF9yYXdfYmFja3RyYWNlLCBidXQgaXQgbWFrZXMgdGhlXG4gICAgIEFQSSBtb3JlIHVzZXItZnJpZW5kbHkgLS0gb3RoZXJ3aXNlIG1vc3QgdXNlcnMgd291bGQgaGF2ZSB0b1xuICAgICByZWltcGxlbWVudCB0aGUgXCJQcm9ncmFtIG5vdCBsaW5rZWQgd2l0aCAtZywgc29ycnlcIiBsb2dpY1xuICAgICB0aGVtc2VsdmVzLiAqKVxuICBtYXRjaCBjb252ZXJ0X3Jhd19iYWNrdHJhY2UgcmF3X2JhY2t0cmFjZSB3aXRoXG4gICAgfCBOb25lIC0+IE5vbmVcbiAgICB8IFNvbWUgYmFja3RyYWNlIC0+XG4gICAgICBsZXQgdXNhYmxlX3Nsb3QgPSBmdW5jdGlvblxuICAgICAgICB8IFVua25vd25fbG9jYXRpb24gXyAtPiBmYWxzZVxuICAgICAgICB8IEtub3duX2xvY2F0aW9uIF8gLT4gdHJ1ZSBpblxuICAgICAgbGV0IHJlYyBleGlzdHNfdXNhYmxlID0gZnVuY3Rpb25cbiAgICAgICAgfCAoLTEpIC0+IGZhbHNlXG4gICAgICAgIHwgaSAtPiB1c2FibGVfc2xvdCBiYWNrdHJhY2UuKGkpIHx8IGV4aXN0c191c2FibGUgKGkgLSAxKSBpblxuICAgICAgaWYgZXhpc3RzX3VzYWJsZSAoQXJyYXkubGVuZ3RoIGJhY2t0cmFjZSAtIDEpXG4gICAgICB0aGVuIFNvbWUgYmFja3RyYWNlXG4gICAgICBlbHNlIE5vbmVcblxubGV0IGJhY2t0cmFjZV9zbG90c19vZl9yYXdfZW50cnkgZW50cnkgPVxuICBiYWNrdHJhY2Vfc2xvdHMgW3wgZW50cnkgfF1cblxubW9kdWxlIFNsb3QgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gYmFja3RyYWNlX3Nsb3RcbiAgbGV0IGZvcm1hdCA9IGZvcm1hdF9iYWNrdHJhY2Vfc2xvdFxuICBsZXQgaXNfcmFpc2UgPSBiYWNrdHJhY2Vfc2xvdF9pc19yYWlzZVxuICBsZXQgaXNfaW5saW5lID0gYmFja3RyYWNlX3Nsb3RfaXNfaW5saW5lXG4gIGxldCBsb2NhdGlvbiA9IGJhY2t0cmFjZV9zbG90X2xvY2F0aW9uXG4gIGxldCBuYW1lID0gYmFja3RyYWNlX3Nsb3RfZGVmbmFtZVxuZW5kXG5cbmxldCByYXdfYmFja3RyYWNlX2xlbmd0aCBidCA9IEFycmF5Lmxlbmd0aCBidFxuXG5leHRlcm5hbCBnZXRfcmF3X2JhY2t0cmFjZV9zbG90IDpcbiAgcmF3X2JhY2t0cmFjZSAtPiBpbnQgLT4gcmF3X2JhY2t0cmFjZV9zbG90ID0gXCJjYW1sX3Jhd19iYWNrdHJhY2Vfc2xvdFwiXG5cbmV4dGVybmFsIGdldF9yYXdfYmFja3RyYWNlX25leHRfc2xvdCA6XG4gIHJhd19iYWNrdHJhY2Vfc2xvdCAtPiByYXdfYmFja3RyYWNlX3Nsb3Qgb3B0aW9uXG4gID0gXCJjYW1sX3Jhd19iYWNrdHJhY2VfbmV4dF9zbG90XCJcblxuKCogY29uZnVzaW5nbHkgbmFtZWQ6XG4gICByZXR1cm5zIHRoZSAqc3RyaW5nKiBjb3JyZXNwb25kaW5nIHRvIHRoZSBnbG9iYWwgY3VycmVudCBiYWNrdHJhY2UgKilcbmxldCBnZXRfYmFja3RyYWNlICgpID0gcmF3X2JhY2t0cmFjZV90b19zdHJpbmcgKGdldF9yYXdfYmFja3RyYWNlICgpKVxuXG5leHRlcm5hbCByZWNvcmRfYmFja3RyYWNlOiBib29sIC0+IHVuaXQgPSBcImNhbWxfcmVjb3JkX2JhY2t0cmFjZVwiXG5leHRlcm5hbCBiYWNrdHJhY2Vfc3RhdHVzOiB1bml0IC0+IGJvb2wgPSBcImNhbWxfYmFja3RyYWNlX3N0YXR1c1wiXG5cbmxldCByZWMgcmVnaXN0ZXJfcHJpbnRlciBmbiA9XG4gIGxldCBvbGRfcHJpbnRlcnMgPSBBdG9taWMuZ2V0IHByaW50ZXJzIGluXG4gIGxldCBuZXdfcHJpbnRlcnMgPSBmbiA6OiBvbGRfcHJpbnRlcnMgaW5cbiAgbGV0IHN1Y2Nlc3MgPSBBdG9taWMuY29tcGFyZV9hbmRfc2V0IHByaW50ZXJzIG9sZF9wcmludGVycyBuZXdfcHJpbnRlcnMgaW5cbiAgaWYgbm90IHN1Y2Nlc3MgdGhlbiByZWdpc3Rlcl9wcmludGVyIGZuXG5cbmV4dGVybmFsIGdldF9jYWxsc3RhY2s6IGludCAtPiByYXdfYmFja3RyYWNlID0gXCJjYW1sX2dldF9jdXJyZW50X2NhbGxzdGFja1wiXG5cbmxldCBleG5fc2xvdCB4ID1cbiAgbGV0IHggPSBPYmoucmVwciB4IGluXG4gIGlmIE9iai50YWcgeCA9IDAgdGhlbiBPYmouZmllbGQgeCAwIGVsc2UgeFxuXG5sZXQgZXhuX3Nsb3RfaWQgeCA9XG4gIGxldCBzbG90ID0gZXhuX3Nsb3QgeCBpblxuICAoT2JqLm9iaiAoT2JqLmZpZWxkIHNsb3QgMSkgOiBpbnQpXG5cbmxldCBleG5fc2xvdF9uYW1lIHggPVxuICBsZXQgc2xvdCA9IGV4bl9zbG90IHggaW5cbiAgKE9iai5vYmogKE9iai5maWVsZCBzbG90IDApIDogc3RyaW5nKVxuXG5leHRlcm5hbCBnZXRfZGVidWdfaW5mb19zdGF0dXMgOiB1bml0IC0+IGludCA9IFwiY2FtbF9tbF9kZWJ1Z19pbmZvX3N0YXR1c1wiXG5cbigqIERlc2NyaXB0aW9ucyBmb3IgZXJyb3JzIGluIHN0YXJ0dXAuaC4gU2VlIGFsc28gYmFja3RyYWNlLmMgKilcbmxldCBlcnJvcnMgPSBbfCBcIlwiO1xuICAoKiBGSUxFX05PVF9GT1VORCAqKVxuICBcIihDYW5ub3QgcHJpbnQgbG9jYXRpb25zOlxcbiBcXFxuICAgICAgYnl0ZWNvZGUgZXhlY3V0YWJsZSBwcm9ncmFtIGZpbGUgbm90IGZvdW5kKVwiO1xuICAoKiBCQURfQllURUNPREUgKilcbiAgXCIoQ2Fubm90IHByaW50IGxvY2F0aW9uczpcXG4gXFxcbiAgICAgIGJ5dGVjb2RlIGV4ZWN1dGFibGUgcHJvZ3JhbSBmaWxlIGFwcGVhcnMgdG8gYmUgY29ycnVwdClcIjtcbiAgKCogV1JPTkdfTUFHSUMgKilcbiAgXCIoQ2Fubm90IHByaW50IGxvY2F0aW9uczpcXG4gXFxcbiAgICAgIGJ5dGVjb2RlIGV4ZWN1dGFibGUgcHJvZ3JhbSBmaWxlIGhhcyB3cm9uZyBtYWdpYyBudW1iZXIpXCI7XG4gICgqIE5PX0ZEUyAqKVxuICBcIihDYW5ub3QgcHJpbnQgbG9jYXRpb25zOlxcbiBcXFxuICAgICAgYnl0ZWNvZGUgZXhlY3V0YWJsZSBwcm9ncmFtIGZpbGUgY2Fubm90IGJlIG9wZW5lZDtcXG4gXFxcbiAgICAgIC0tIHRvbyBtYW55IG9wZW4gZmlsZXMuIFRyeSBydW5uaW5nIHdpdGggT0NBTUxSVU5QQVJBTT1iPTIpXCJcbnxdXG5cbmxldCBkZWZhdWx0X3VuY2F1Z2h0X2V4Y2VwdGlvbl9oYW5kbGVyIGV4biByYXdfYmFja3RyYWNlID1cbiAgZXByaW50ZiBcIkZhdGFsIGVycm9yOiBleGNlcHRpb24gJXNcXG5cIiAodG9fc3RyaW5nIGV4bik7XG4gIHByaW50X3Jhd19iYWNrdHJhY2Ugc3RkZXJyIHJhd19iYWNrdHJhY2U7XG4gIGxldCBzdGF0dXMgPSBnZXRfZGVidWdfaW5mb19zdGF0dXMgKCkgaW5cbiAgaWYgc3RhdHVzIDwgMCB0aGVuXG4gICAgcHJlcnJfZW5kbGluZSBlcnJvcnMuKGFicyBzdGF0dXMpO1xuICBmbHVzaCBzdGRlcnJcblxubGV0IHVuY2F1Z2h0X2V4Y2VwdGlvbl9oYW5kbGVyID0gcmVmIGRlZmF1bHRfdW5jYXVnaHRfZXhjZXB0aW9uX2hhbmRsZXJcblxubGV0IHNldF91bmNhdWdodF9leGNlcHRpb25faGFuZGxlciBmbiA9IHVuY2F1Z2h0X2V4Y2VwdGlvbl9oYW5kbGVyIDo9IGZuXG5cbmxldCBlbXB0eV9iYWNrdHJhY2UgOiByYXdfYmFja3RyYWNlID0gW3wgfF1cblxubGV0IHRyeV9nZXRfcmF3X2JhY2t0cmFjZSAoKSA9XG4gIHRyeVxuICAgIGdldF9yYXdfYmFja3RyYWNlICgpXG4gIHdpdGggXyAoKiBPdXRfb2ZfbWVtb3J5PyAqKSAtPlxuICAgIGVtcHR5X2JhY2t0cmFjZVxuXG5sZXQgaGFuZGxlX3VuY2F1Z2h0X2V4Y2VwdGlvbicgZXhuIGRlYnVnZ2VyX2luX3VzZSA9XG4gIHRyeVxuICAgICgqIEdldCB0aGUgYmFja3RyYWNlIG5vdywgaW4gY2FzZSBvbmUgb2YgdGhlIFthdF9leGl0XSBmdW5jdGlvblxuICAgICAgIGRlc3Ryb3lzIGl0LiAqKVxuICAgIGxldCByYXdfYmFja3RyYWNlID1cbiAgICAgIGlmIGRlYnVnZ2VyX2luX3VzZSAoKiBTYW1lIHRlc3QgYXMgaW4gW3J1bnRpbWUvcHJpbnRleGMuY10gKikgdGhlblxuICAgICAgICBlbXB0eV9iYWNrdHJhY2VcbiAgICAgIGVsc2VcbiAgICAgICAgdHJ5X2dldF9yYXdfYmFja3RyYWNlICgpXG4gICAgaW5cbiAgICAodHJ5IFN0ZGxpYi5kb19hdF9leGl0ICgpIHdpdGggXyAtPiAoKSk7XG4gICAgdHJ5XG4gICAgICAhdW5jYXVnaHRfZXhjZXB0aW9uX2hhbmRsZXIgZXhuIHJhd19iYWNrdHJhY2VcbiAgICB3aXRoIGV4bicgLT5cbiAgICAgIGxldCByYXdfYmFja3RyYWNlJyA9IHRyeV9nZXRfcmF3X2JhY2t0cmFjZSAoKSBpblxuICAgICAgZXByaW50ZiBcIkZhdGFsIGVycm9yOiBleGNlcHRpb24gJXNcXG5cIiAodG9fc3RyaW5nIGV4bik7XG4gICAgICBwcmludF9yYXdfYmFja3RyYWNlIHN0ZGVyciByYXdfYmFja3RyYWNlO1xuICAgICAgZXByaW50ZiBcIkZhdGFsIGVycm9yIGluIHVuY2F1Z2h0IGV4Y2VwdGlvbiBoYW5kbGVyOiBleGNlcHRpb24gJXNcXG5cIlxuICAgICAgICAodG9fc3RyaW5nIGV4bicpO1xuICAgICAgcHJpbnRfcmF3X2JhY2t0cmFjZSBzdGRlcnIgcmF3X2JhY2t0cmFjZSc7XG4gICAgICBmbHVzaCBzdGRlcnJcbiAgd2l0aFxuICAgIHwgT3V0X29mX21lbW9yeSAtPlxuICAgICAgICBwcmVycl9lbmRsaW5lXG4gICAgICAgICAgXCJGYXRhbCBlcnJvcjogb3V0IG9mIG1lbW9yeSBpbiB1bmNhdWdodCBleGNlcHRpb24gaGFuZGxlclwiXG5cbigqIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGJ5IFtjYW1sX2ZhdGFsX3VuY2F1Z2h0X2V4Y2VwdGlvbl0gaW5cbiAgIFtydW50aW1lL3ByaW50ZXhjLmNdIHdoaWNoIGV4cGVjdHMgbm8gZXhjZXB0aW9uIGlzIHJhaXNlZC4gKilcbmxldCBoYW5kbGVfdW5jYXVnaHRfZXhjZXB0aW9uIGV4biBkZWJ1Z2dlcl9pbl91c2UgPVxuICB0cnlcbiAgICBoYW5kbGVfdW5jYXVnaHRfZXhjZXB0aW9uJyBleG4gZGVidWdnZXJfaW5fdXNlXG4gIHdpdGggXyAtPlxuICAgICgqIFRoZXJlIGlzIG5vdCBtdWNoIHdlIGNhbiBkbyBhdCB0aGlzIHBvaW50ICopXG4gICAgKClcblxuZXh0ZXJuYWwgcmVnaXN0ZXJfbmFtZWRfdmFsdWUgOiBzdHJpbmcgLT4gJ2EgLT4gdW5pdFxuICA9IFwiY2FtbF9yZWdpc3Rlcl9uYW1lZF92YWx1ZVwiXG5cbmxldCAoKSA9XG4gIHJlZ2lzdGVyX25hbWVkX3ZhbHVlIFwiUHJpbnRleGMuaGFuZGxlX3VuY2F1Z2h0X2V4Y2VwdGlvblwiXG4gICAgaGFuZGxlX3VuY2F1Z2h0X2V4Y2VwdGlvblxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgIFhhdmllciBMZXJveSBhbmQgRGFtaWVuIERvbGlnZXosIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5sZXQgZ2VuZXJpY19xdW90ZSBxdW90ZXF1b3RlIHMgPVxuICBsZXQgbCA9IFN0cmluZy5sZW5ndGggcyBpblxuICBsZXQgYiA9IEJ1ZmZlci5jcmVhdGUgKGwgKyAyMCkgaW5cbiAgQnVmZmVyLmFkZF9jaGFyIGIgJ1xcJyc7XG4gIGZvciBpID0gMCB0byBsIC0gMSBkb1xuICAgIGlmIHMuW2ldID0gJ1xcJydcbiAgICB0aGVuIEJ1ZmZlci5hZGRfc3RyaW5nIGIgcXVvdGVxdW90ZVxuICAgIGVsc2UgQnVmZmVyLmFkZF9jaGFyIGIgIHMuW2ldXG4gIGRvbmU7XG4gIEJ1ZmZlci5hZGRfY2hhciBiICdcXCcnO1xuICBCdWZmZXIuY29udGVudHMgYlxuXG4oKiBUaGlzIGZ1bmN0aW9uIGltcGxlbWVudHMgdGhlIE9wZW4gR3JvdXAgc3BlY2lmaWNhdGlvbiBmb3VuZCBoZXJlOlxuICBbWzFdXSBodHRwOi8vcHVicy5vcGVuZ3JvdXAub3JnL29ubGluZXB1YnMvOTY5OTkxOTc5OS91dGlsaXRpZXMvYmFzZW5hbWUuaHRtbFxuICBJbiBzdGVwIDEgb2YgW1sxXV0sIHdlIGNob29zZSB0byByZXR1cm4gXCIuXCIgZm9yIGVtcHR5IGlucHV0LlxuICAgIChmb3IgY29tcGF0aWJpbGl0eSB3aXRoIHByZXZpb3VzIHZlcnNpb25zIG9mIE9DYW1sKVxuICBJbiBzdGVwIDIsIHdlIGNob29zZSB0byBwcm9jZXNzIFwiLy9cIiBub3JtYWxseS5cbiAgU3RlcCA2IGlzIG5vdCBpbXBsZW1lbnRlZDogd2UgY29uc2lkZXIgdGhhdCB0aGUgW3N1ZmZpeF0gb3BlcmFuZCBpc1xuICAgIGFsd2F5cyBhYnNlbnQuICBTdWZmaXhlcyBhcmUgaGFuZGxlZCBieSBbY2hvcF9zdWZmaXhdIGFuZCBbY2hvcF9leHRlbnNpb25dLlxuKilcbmxldCBnZW5lcmljX2Jhc2VuYW1lIGlzX2Rpcl9zZXAgY3VycmVudF9kaXJfbmFtZSBuYW1lID1cbiAgbGV0IHJlYyBmaW5kX2VuZCBuID1cbiAgICBpZiBuIDwgMCB0aGVuIFN0cmluZy5zdWIgbmFtZSAwIDFcbiAgICBlbHNlIGlmIGlzX2Rpcl9zZXAgbmFtZSBuIHRoZW4gZmluZF9lbmQgKG4gLSAxKVxuICAgIGVsc2UgZmluZF9iZWcgbiAobiArIDEpXG4gIGFuZCBmaW5kX2JlZyBuIHAgPVxuICAgIGlmIG4gPCAwIHRoZW4gU3RyaW5nLnN1YiBuYW1lIDAgcFxuICAgIGVsc2UgaWYgaXNfZGlyX3NlcCBuYW1lIG4gdGhlbiBTdHJpbmcuc3ViIG5hbWUgKG4gKyAxKSAocCAtIG4gLSAxKVxuICAgIGVsc2UgZmluZF9iZWcgKG4gLSAxKSBwXG4gIGluXG4gIGlmIG5hbWUgPSBcIlwiXG4gIHRoZW4gY3VycmVudF9kaXJfbmFtZVxuICBlbHNlIGZpbmRfZW5kIChTdHJpbmcubGVuZ3RoIG5hbWUgLSAxKVxuXG4oKiBUaGlzIGZ1bmN0aW9uIGltcGxlbWVudHMgdGhlIE9wZW4gR3JvdXAgc3BlY2lmaWNhdGlvbiBmb3VuZCBoZXJlOlxuICBbWzJdXSBodHRwOi8vcHVicy5vcGVuZ3JvdXAub3JnL29ubGluZXB1YnMvOTY5OTkxOTc5OS91dGlsaXRpZXMvZGlybmFtZS5odG1sXG4gIEluIHN0ZXAgNiBvZiBbWzJdXSwgd2UgY2hvb3NlIHRvIHByb2Nlc3MgXCIvL1wiIG5vcm1hbGx5LlxuKilcbmxldCBnZW5lcmljX2Rpcm5hbWUgaXNfZGlyX3NlcCBjdXJyZW50X2Rpcl9uYW1lIG5hbWUgPVxuICBsZXQgcmVjIHRyYWlsaW5nX3NlcCBuID1cbiAgICBpZiBuIDwgMCB0aGVuIFN0cmluZy5zdWIgbmFtZSAwIDFcbiAgICBlbHNlIGlmIGlzX2Rpcl9zZXAgbmFtZSBuIHRoZW4gdHJhaWxpbmdfc2VwIChuIC0gMSlcbiAgICBlbHNlIGJhc2UgblxuICBhbmQgYmFzZSBuID1cbiAgICBpZiBuIDwgMCB0aGVuIGN1cnJlbnRfZGlyX25hbWVcbiAgICBlbHNlIGlmIGlzX2Rpcl9zZXAgbmFtZSBuIHRoZW4gaW50ZXJtZWRpYXRlX3NlcCBuXG4gICAgZWxzZSBiYXNlIChuIC0gMSlcbiAgYW5kIGludGVybWVkaWF0ZV9zZXAgbiA9XG4gICAgaWYgbiA8IDAgdGhlbiBTdHJpbmcuc3ViIG5hbWUgMCAxXG4gICAgZWxzZSBpZiBpc19kaXJfc2VwIG5hbWUgbiB0aGVuIGludGVybWVkaWF0ZV9zZXAgKG4gLSAxKVxuICAgIGVsc2UgU3RyaW5nLnN1YiBuYW1lIDAgKG4gKyAxKVxuICBpblxuICBpZiBuYW1lID0gXCJcIlxuICB0aGVuIGN1cnJlbnRfZGlyX25hbWVcbiAgZWxzZSB0cmFpbGluZ19zZXAgKFN0cmluZy5sZW5ndGggbmFtZSAtIDEpXG5cbm1vZHVsZSB0eXBlIFNZU0RFUFMgPSBzaWdcbiAgdmFsIG51bGwgOiBzdHJpbmdcbiAgdmFsIGN1cnJlbnRfZGlyX25hbWUgOiBzdHJpbmdcbiAgdmFsIHBhcmVudF9kaXJfbmFtZSA6IHN0cmluZ1xuICB2YWwgZGlyX3NlcCA6IHN0cmluZ1xuICB2YWwgaXNfZGlyX3NlcCA6IHN0cmluZyAtPiBpbnQgLT4gYm9vbFxuICB2YWwgaXNfcmVsYXRpdmUgOiBzdHJpbmcgLT4gYm9vbFxuICB2YWwgaXNfaW1wbGljaXQgOiBzdHJpbmcgLT4gYm9vbFxuICB2YWwgY2hlY2tfc3VmZml4IDogc3RyaW5nIC0+IHN0cmluZyAtPiBib29sXG4gIHZhbCBjaG9wX3N1ZmZpeF9vcHQgOiBzdWZmaXg6c3RyaW5nIC0+IHN0cmluZyAtPiBzdHJpbmcgb3B0aW9uXG4gIHZhbCB0ZW1wX2Rpcl9uYW1lIDogc3RyaW5nXG4gIHZhbCBxdW90ZSA6IHN0cmluZyAtPiBzdHJpbmdcbiAgdmFsIHF1b3RlX2NvbW1hbmQgOlxuICAgIHN0cmluZyAtPiA/c3RkaW46IHN0cmluZyAtPiA/c3Rkb3V0OiBzdHJpbmcgLT4gP3N0ZGVycjogc3RyaW5nXG4gICAgICAgICAgIC0+IHN0cmluZyBsaXN0IC0+IHN0cmluZ1xuICB2YWwgYmFzZW5hbWUgOiBzdHJpbmcgLT4gc3RyaW5nXG4gIHZhbCBkaXJuYW1lIDogc3RyaW5nIC0+IHN0cmluZ1xuZW5kXG5cbm1vZHVsZSBVbml4IDogU1lTREVQUyA9IHN0cnVjdFxuICBsZXQgbnVsbCA9IFwiL2Rldi9udWxsXCJcbiAgbGV0IGN1cnJlbnRfZGlyX25hbWUgPSBcIi5cIlxuICBsZXQgcGFyZW50X2Rpcl9uYW1lID0gXCIuLlwiXG4gIGxldCBkaXJfc2VwID0gXCIvXCJcbiAgbGV0IGlzX2Rpcl9zZXAgcyBpID0gcy5baV0gPSAnLydcbiAgbGV0IGlzX3JlbGF0aXZlIG4gPSBTdHJpbmcubGVuZ3RoIG4gPCAxIHx8IG4uWzBdIDw+ICcvJ1xuICBsZXQgaXNfaW1wbGljaXQgbiA9XG4gICAgaXNfcmVsYXRpdmUgblxuICAgICYmIChTdHJpbmcubGVuZ3RoIG4gPCAyIHx8IFN0cmluZy5zdWIgbiAwIDIgPD4gXCIuL1wiKVxuICAgICYmIChTdHJpbmcubGVuZ3RoIG4gPCAzIHx8IFN0cmluZy5zdWIgbiAwIDMgPD4gXCIuLi9cIilcbiAgbGV0IGNoZWNrX3N1ZmZpeCBuYW1lIHN1ZmYgPVxuICAgIFN0cmluZy5sZW5ndGggbmFtZSA+PSBTdHJpbmcubGVuZ3RoIHN1ZmYgJiZcbiAgICBTdHJpbmcuc3ViIG5hbWUgKFN0cmluZy5sZW5ndGggbmFtZSAtIFN0cmluZy5sZW5ndGggc3VmZilcbiAgICAgICAgICAgICAgICAgICAgKFN0cmluZy5sZW5ndGggc3VmZikgPSBzdWZmXG5cbiAgbGV0IGNob3Bfc3VmZml4X29wdCB+c3VmZml4IGZpbGVuYW1lID1cbiAgICBsZXQgbGVuX3MgPSBTdHJpbmcubGVuZ3RoIHN1ZmZpeCBhbmQgbGVuX2YgPSBTdHJpbmcubGVuZ3RoIGZpbGVuYW1lIGluXG4gICAgaWYgbGVuX2YgPj0gbGVuX3MgdGhlblxuICAgICAgbGV0IHIgPSBTdHJpbmcuc3ViIGZpbGVuYW1lIChsZW5fZiAtIGxlbl9zKSBsZW5fcyBpblxuICAgICAgaWYgciA9IHN1ZmZpeCB0aGVuXG4gICAgICAgIFNvbWUgKFN0cmluZy5zdWIgZmlsZW5hbWUgMCAobGVuX2YgLSBsZW5fcykpXG4gICAgICBlbHNlXG4gICAgICAgIE5vbmVcbiAgICBlbHNlXG4gICAgICBOb25lXG5cbiAgbGV0IHRlbXBfZGlyX25hbWUgPVxuICAgIHRyeSBTeXMuZ2V0ZW52IFwiVE1QRElSXCIgd2l0aCBOb3RfZm91bmQgLT4gXCIvdG1wXCJcbiAgbGV0IHF1b3RlID0gZ2VuZXJpY19xdW90ZSBcIidcXFxcJydcIlxuICBsZXQgcXVvdGVfY29tbWFuZCBjbWQgP3N0ZGluID9zdGRvdXQgP3N0ZGVyciBhcmdzID1cbiAgICBTdHJpbmcuY29uY2F0IFwiIFwiIChMaXN0Lm1hcCBxdW90ZSAoY21kIDo6IGFyZ3MpKVxuICAgIF4gKG1hdGNoIHN0ZGluICB3aXRoIE5vbmUgLT4gXCJcIiB8IFNvbWUgZiAtPiBcIiA8XCIgXiBxdW90ZSBmKVxuICAgIF4gKG1hdGNoIHN0ZG91dCB3aXRoIE5vbmUgLT4gXCJcIiB8IFNvbWUgZiAtPiBcIiA+XCIgXiBxdW90ZSBmKVxuICAgIF4gKG1hdGNoIHN0ZGVyciB3aXRoIE5vbmUgLT4gXCJcIiB8IFNvbWUgZiAtPiBpZiBzdGRlcnIgPSBzdGRvdXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZW4gXCIgMj4mMVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIFwiIDI+XCIgXiBxdW90ZSBmKVxuICBsZXQgYmFzZW5hbWUgPSBnZW5lcmljX2Jhc2VuYW1lIGlzX2Rpcl9zZXAgY3VycmVudF9kaXJfbmFtZVxuICBsZXQgZGlybmFtZSA9IGdlbmVyaWNfZGlybmFtZSBpc19kaXJfc2VwIGN1cnJlbnRfZGlyX25hbWVcbmVuZFxuXG5tb2R1bGUgV2luMzIgOiBTWVNERVBTID0gc3RydWN0XG4gIGxldCBudWxsID0gXCJOVUxcIlxuICBsZXQgY3VycmVudF9kaXJfbmFtZSA9IFwiLlwiXG4gIGxldCBwYXJlbnRfZGlyX25hbWUgPSBcIi4uXCJcbiAgbGV0IGRpcl9zZXAgPSBcIlxcXFxcIlxuICBsZXQgaXNfZGlyX3NlcCBzIGkgPSBsZXQgYyA9IHMuW2ldIGluIGMgPSAnLycgfHwgYyA9ICdcXFxcJyB8fCBjID0gJzonXG4gIGxldCBpc19yZWxhdGl2ZSBuID1cbiAgICAoU3RyaW5nLmxlbmd0aCBuIDwgMSB8fCBuLlswXSA8PiAnLycpXG4gICAgJiYgKFN0cmluZy5sZW5ndGggbiA8IDEgfHwgbi5bMF0gPD4gJ1xcXFwnKVxuICAgICYmIChTdHJpbmcubGVuZ3RoIG4gPCAyIHx8IG4uWzFdIDw+ICc6JylcbiAgbGV0IGlzX2ltcGxpY2l0IG4gPVxuICAgIGlzX3JlbGF0aXZlIG5cbiAgICAmJiAoU3RyaW5nLmxlbmd0aCBuIDwgMiB8fCBTdHJpbmcuc3ViIG4gMCAyIDw+IFwiLi9cIilcbiAgICAmJiAoU3RyaW5nLmxlbmd0aCBuIDwgMiB8fCBTdHJpbmcuc3ViIG4gMCAyIDw+IFwiLlxcXFxcIilcbiAgICAmJiAoU3RyaW5nLmxlbmd0aCBuIDwgMyB8fCBTdHJpbmcuc3ViIG4gMCAzIDw+IFwiLi4vXCIpXG4gICAgJiYgKFN0cmluZy5sZW5ndGggbiA8IDMgfHwgU3RyaW5nLnN1YiBuIDAgMyA8PiBcIi4uXFxcXFwiKVxuICBsZXQgY2hlY2tfc3VmZml4IG5hbWUgc3VmZiA9XG4gICBTdHJpbmcubGVuZ3RoIG5hbWUgPj0gU3RyaW5nLmxlbmd0aCBzdWZmICYmXG4gICAobGV0IHMgPSBTdHJpbmcuc3ViIG5hbWUgKFN0cmluZy5sZW5ndGggbmFtZSAtIFN0cmluZy5sZW5ndGggc3VmZilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoU3RyaW5nLmxlbmd0aCBzdWZmKSBpblxuICAgIFN0cmluZy5sb3dlcmNhc2VfYXNjaWkgcyA9IFN0cmluZy5sb3dlcmNhc2VfYXNjaWkgc3VmZilcblxuICBsZXQgY2hvcF9zdWZmaXhfb3B0IH5zdWZmaXggZmlsZW5hbWUgPVxuICAgIGxldCBsZW5fcyA9IFN0cmluZy5sZW5ndGggc3VmZml4IGFuZCBsZW5fZiA9IFN0cmluZy5sZW5ndGggZmlsZW5hbWUgaW5cbiAgICBpZiBsZW5fZiA+PSBsZW5fcyB0aGVuXG4gICAgICBsZXQgciA9IFN0cmluZy5zdWIgZmlsZW5hbWUgKGxlbl9mIC0gbGVuX3MpIGxlbl9zIGluXG4gICAgICBpZiBTdHJpbmcubG93ZXJjYXNlX2FzY2lpIHIgPSBTdHJpbmcubG93ZXJjYXNlX2FzY2lpIHN1ZmZpeCB0aGVuXG4gICAgICAgIFNvbWUgKFN0cmluZy5zdWIgZmlsZW5hbWUgMCAobGVuX2YgLSBsZW5fcykpXG4gICAgICBlbHNlXG4gICAgICAgIE5vbmVcbiAgICBlbHNlXG4gICAgICBOb25lXG5cblxuICBsZXQgdGVtcF9kaXJfbmFtZSA9XG4gICAgdHJ5IFN5cy5nZXRlbnYgXCJURU1QXCIgd2l0aCBOb3RfZm91bmQgLT4gXCIuXCJcbiAgbGV0IHF1b3RlIHMgPVxuICAgIGxldCBsID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gICAgbGV0IGIgPSBCdWZmZXIuY3JlYXRlIChsICsgMjApIGluXG4gICAgQnVmZmVyLmFkZF9jaGFyIGIgJ1xcXCInO1xuICAgIGxldCByZWMgbG9vcCBpID1cbiAgICAgIGlmIGkgPSBsIHRoZW4gQnVmZmVyLmFkZF9jaGFyIGIgJ1xcXCInIGVsc2VcbiAgICAgIG1hdGNoIHMuW2ldIHdpdGhcbiAgICAgIHwgJ1xcXCInIC0+IGxvb3BfYnMgMCBpO1xuICAgICAgfCAnXFxcXCcgLT4gbG9vcF9icyAwIGk7XG4gICAgICB8IGMgICAgLT4gQnVmZmVyLmFkZF9jaGFyIGIgYzsgbG9vcCAoaSsxKTtcbiAgICBhbmQgbG9vcF9icyBuIGkgPVxuICAgICAgaWYgaSA9IGwgdGhlbiBiZWdpblxuICAgICAgICBCdWZmZXIuYWRkX2NoYXIgYiAnXFxcIic7XG4gICAgICAgIGFkZF9icyBuO1xuICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgbWF0Y2ggcy5baV0gd2l0aFxuICAgICAgICB8ICdcXFwiJyAtPiBhZGRfYnMgKDIqbisxKTsgQnVmZmVyLmFkZF9jaGFyIGIgJ1xcXCInOyBsb29wIChpKzEpO1xuICAgICAgICB8ICdcXFxcJyAtPiBsb29wX2JzIChuKzEpIChpKzEpO1xuICAgICAgICB8IF8gICAgLT4gYWRkX2JzIG47IGxvb3AgaVxuICAgICAgZW5kXG4gICAgYW5kIGFkZF9icyBuID0gZm9yIF9qID0gMSB0byBuIGRvIEJ1ZmZlci5hZGRfY2hhciBiICdcXFxcJzsgZG9uZVxuICAgIGluXG4gICAgbG9vcCAwO1xuICAgIEJ1ZmZlci5jb250ZW50cyBiXG4oKlxuUXVvdGluZyBjb21tYW5kcyBmb3IgZXhlY3V0aW9uIGJ5IGNtZC5leGUgaXMgZGlmZmljdWx0LlxuMS0gRWFjaCBhcmd1bWVudCBpcyBmaXJzdCBxdW90ZWQgdXNpbmcgdGhlIFwicXVvdGVcIiBmdW5jdGlvbiBhYm92ZSwgdG9cbiAgIHByb3RlY3QgaXQgYWdhaW5zdCB0aGUgcHJvY2Vzc2luZyBwZXJmb3JtZWQgYnkgdGhlIEMgcnVudGltZSBzeXN0ZW0sXG4gICB0aGVuIGNtZC5leGUncyBzcGVjaWFsIGNoYXJhY3RlcnMgYXJlIGVzY2FwZWQgd2l0aCAnXicsIHVzaW5nXG4gICB0aGUgXCJxdW90ZV9jbWRcIiBmdW5jdGlvbiBiZWxvdy4gIEZvciBtb3JlIGRldGFpbHMsIHNlZVxuICAgaHR0cHM6Ly9ibG9ncy5tc2RuLm1pY3Jvc29mdC5jb20vdHdpc3R5bGl0dGxlcGFzc2FnZXNhbGxhbGlrZS8yMDExLzA0LzIzXG4yLSBUaGUgY29tbWFuZCBhbmQgdGhlIHJlZGlyZWN0aW9uIGZpbGVzLCBpZiBhbnksIG11c3QgYmUgZG91YmxlLXF1b3RlZFxuICAgaW4gY2FzZSB0aGV5IGNvbnRhaW4gc3BhY2VzLiAgVGhpcyBxdW90aW5nIGlzIGludGVycHJldGVkIGJ5IGNtZC5leGUsXG4gICBub3QgYnkgdGhlIEMgcnVudGltZSBzeXN0ZW0sIGhlbmNlIHRoZSBcInF1b3RlXCIgZnVuY3Rpb24gYWJvdmVcbiAgIGNhbm5vdCBiZSB1c2VkLiAgVGhlIHR3byBjaGFyYWN0ZXJzIHdlIGRvbid0IGtub3cgaG93IHRvIHF1b3RlXG4gICBpbnNpZGUgYSBkb3VibGUtcXVvdGVkIGNtZC5leGUgc3RyaW5nIGFyZSBkb3VibGUtcXVvdGUgYW5kIHBlcmNlbnQuXG4gICBXZSBqdXN0IGZhaWwgaWYgdGhlIGNvbW1hbmQgbmFtZSBvciB0aGUgcmVkaXJlY3Rpb24gZmlsZSBuYW1lc1xuICAgY29udGFpbiBhIGRvdWJsZSBxdW90ZSAobm90IGFsbG93ZWQgaW4gV2luZG93cyBmaWxlIG5hbWVzLCBhbnl3YXkpXG4gICBvciBhIHBlcmNlbnQuICBTZWUgZnVuY3Rpb24gXCJxdW90ZV9jbWRfZmlsZW5hbWVcIiBiZWxvdy5cbjMtIFRoZSB3aG9sZSBzdHJpbmcgcGFzc2VkIHRvIFN5cy5jb21tYW5kIGlzIHRoZW4gZW5jbG9zZWQgaW4gZG91YmxlXG4gICBxdW90ZXMsIHdoaWNoIGFyZSBpbW1lZGlhdGVseSBzdHJpcHBlZCBieSBjbWQuZXhlLiAgT3RoZXJ3aXNlLFxuICAgc29tZSBvZiB0aGUgZG91YmxlIHF1b3RlcyBmcm9tIHN0ZXAgMiBhYm92ZSBjYW4gYmUgbWlzcGFyc2VkLlxuICAgU2VlIGUuZy4gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzk5NjUxNDFcbiopXG4gIGxldCBxdW90ZV9jbWQgcyA9XG4gICAgbGV0IGIgPSBCdWZmZXIuY3JlYXRlIChTdHJpbmcubGVuZ3RoIHMgKyAyMCkgaW5cbiAgICBTdHJpbmcuaXRlclxuICAgICAgKGZ1biBjIC0+XG4gICAgICAgIG1hdGNoIGMgd2l0aFxuICAgICAgICB8ICcoJyB8ICcpJyB8ICchJyB8ICdeJyB8ICclJyB8ICdcXFwiJyB8ICc8JyB8ICc+JyB8ICcmJyB8ICd8JyAtPlxuICAgICAgICAgICAgQnVmZmVyLmFkZF9jaGFyIGIgJ14nOyBCdWZmZXIuYWRkX2NoYXIgYiBjXG4gICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgQnVmZmVyLmFkZF9jaGFyIGIgYylcbiAgICAgIHM7XG4gICAgQnVmZmVyLmNvbnRlbnRzIGJcbiAgbGV0IHF1b3RlX2NtZF9maWxlbmFtZSBmID1cbiAgICBpZiBTdHJpbmcuY29udGFpbnMgZiAnXFxcIicgfHwgU3RyaW5nLmNvbnRhaW5zIGYgJyUnIHRoZW5cbiAgICAgIGZhaWx3aXRoIChcIkZpbGVuYW1lLnF1b3RlX2NvbW1hbmQ6IGJhZCBmaWxlIG5hbWUgXCIgXiBmKVxuICAgIGVsc2UgaWYgU3RyaW5nLmNvbnRhaW5zIGYgJyAnIHRoZW5cbiAgICAgIFwiXFxcIlwiIF4gZiBeIFwiXFxcIlwiXG4gICAgZWxzZVxuICAgICAgZlxuICAoKiBSZWRpcmVjdGlvbnMgaW4gY21kLmV4ZTogc2VlIGh0dHBzOi8vc3M2NC5jb20vbnQvc3ludGF4LXJlZGlyZWN0aW9uLmh0bWxcbiAgICAgYW5kIGh0dHBzOi8vZG9jcy5taWNyb3NvZnQuY29tL2VuLXVzL3ByZXZpb3VzLXZlcnNpb25zL3dpbmRvd3MvaXQtcHJvL3dpbmRvd3MteHAvYmI0OTA5ODIodj10ZWNobmV0LjEwKVxuICAqKVxuICBsZXQgcXVvdGVfY29tbWFuZCBjbWQgP3N0ZGluID9zdGRvdXQgP3N0ZGVyciBhcmdzID1cbiAgICBTdHJpbmcuY29uY2F0IFwiXCIgW1xuICAgICAgXCJcXFwiXCI7XG4gICAgICBxdW90ZV9jbWRfZmlsZW5hbWUgY21kO1xuICAgICAgXCIgXCI7XG4gICAgICBxdW90ZV9jbWQgKFN0cmluZy5jb25jYXQgXCIgXCIgKExpc3QubWFwIHF1b3RlIGFyZ3MpKTtcbiAgICAgIChtYXRjaCBzdGRpbiAgd2l0aCBOb25lIC0+IFwiXCIgfCBTb21lIGYgLT4gXCIgPFwiIF4gcXVvdGVfY21kX2ZpbGVuYW1lIGYpO1xuICAgICAgKG1hdGNoIHN0ZG91dCB3aXRoIE5vbmUgLT4gXCJcIiB8IFNvbWUgZiAtPiBcIiA+XCIgXiBxdW90ZV9jbWRfZmlsZW5hbWUgZik7XG4gICAgICAobWF0Y2ggc3RkZXJyIHdpdGggTm9uZSAtPiBcIlwiIHwgU29tZSBmIC0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgc3RkZXJyID0gc3Rkb3V0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlbiBcIiAyPiYxXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIFwiIDI+XCIgXiBxdW90ZV9jbWRfZmlsZW5hbWUgZik7XG4gICAgICBcIlxcXCJcIlxuICAgIF1cbiAgbGV0IGhhc19kcml2ZSBzID1cbiAgICBsZXQgaXNfbGV0dGVyID0gZnVuY3Rpb25cbiAgICAgIHwgJ0EnIC4uICdaJyB8ICdhJyAuLiAneicgLT4gdHJ1ZVxuICAgICAgfCBfIC0+IGZhbHNlXG4gICAgaW5cbiAgICBTdHJpbmcubGVuZ3RoIHMgPj0gMiAmJiBpc19sZXR0ZXIgcy5bMF0gJiYgcy5bMV0gPSAnOidcbiAgbGV0IGRyaXZlX2FuZF9wYXRoIHMgPVxuICAgIGlmIGhhc19kcml2ZSBzXG4gICAgdGhlbiAoU3RyaW5nLnN1YiBzIDAgMiwgU3RyaW5nLnN1YiBzIDIgKFN0cmluZy5sZW5ndGggcyAtIDIpKVxuICAgIGVsc2UgKFwiXCIsIHMpXG4gIGxldCBkaXJuYW1lIHMgPVxuICAgIGxldCAoZHJpdmUsIHBhdGgpID0gZHJpdmVfYW5kX3BhdGggcyBpblxuICAgIGxldCBkaXIgPSBnZW5lcmljX2Rpcm5hbWUgaXNfZGlyX3NlcCBjdXJyZW50X2Rpcl9uYW1lIHBhdGggaW5cbiAgICBkcml2ZSBeIGRpclxuICBsZXQgYmFzZW5hbWUgcyA9XG4gICAgbGV0IChfZHJpdmUsIHBhdGgpID0gZHJpdmVfYW5kX3BhdGggcyBpblxuICAgIGdlbmVyaWNfYmFzZW5hbWUgaXNfZGlyX3NlcCBjdXJyZW50X2Rpcl9uYW1lIHBhdGhcbmVuZFxuXG5tb2R1bGUgQ3lnd2luIDogU1lTREVQUyA9IHN0cnVjdFxuICBsZXQgbnVsbCA9IFwiL2Rldi9udWxsXCJcbiAgbGV0IGN1cnJlbnRfZGlyX25hbWUgPSBcIi5cIlxuICBsZXQgcGFyZW50X2Rpcl9uYW1lID0gXCIuLlwiXG4gIGxldCBkaXJfc2VwID0gXCIvXCJcbiAgbGV0IGlzX2Rpcl9zZXAgPSBXaW4zMi5pc19kaXJfc2VwXG4gIGxldCBpc19yZWxhdGl2ZSA9IFdpbjMyLmlzX3JlbGF0aXZlXG4gIGxldCBpc19pbXBsaWNpdCA9IFdpbjMyLmlzX2ltcGxpY2l0XG4gIGxldCBjaGVja19zdWZmaXggPSBXaW4zMi5jaGVja19zdWZmaXhcbiAgbGV0IGNob3Bfc3VmZml4X29wdCA9IFdpbjMyLmNob3Bfc3VmZml4X29wdFxuICBsZXQgdGVtcF9kaXJfbmFtZSA9IFVuaXgudGVtcF9kaXJfbmFtZVxuICBsZXQgcXVvdGUgPSBVbml4LnF1b3RlXG4gIGxldCBxdW90ZV9jb21tYW5kID0gVW5peC5xdW90ZV9jb21tYW5kXG4gIGxldCBiYXNlbmFtZSA9IGdlbmVyaWNfYmFzZW5hbWUgaXNfZGlyX3NlcCBjdXJyZW50X2Rpcl9uYW1lXG4gIGxldCBkaXJuYW1lID0gZ2VuZXJpY19kaXJuYW1lIGlzX2Rpcl9zZXAgY3VycmVudF9kaXJfbmFtZVxuZW5kXG5cbm1vZHVsZSBTeXNkZXBzID1cbiAgKHZhbCAobWF0Y2ggU3lzLm9zX3R5cGUgd2l0aFxuICAgICAgIHwgXCJXaW4zMlwiIC0+IChtb2R1bGUgV2luMzI6IFNZU0RFUFMpXG4gICAgICAgfCBcIkN5Z3dpblwiIC0+IChtb2R1bGUgQ3lnd2luOiBTWVNERVBTKVxuICAgICAgIHwgXyAtPiAobW9kdWxlIFVuaXg6IFNZU0RFUFMpKSlcblxuaW5jbHVkZSBTeXNkZXBzXG5cbmxldCBjb25jYXQgZGlybmFtZSBmaWxlbmFtZSA9XG4gIGxldCBsID0gU3RyaW5nLmxlbmd0aCBkaXJuYW1lIGluXG4gIGlmIGwgPSAwIHx8IGlzX2Rpcl9zZXAgZGlybmFtZSAobC0xKVxuICB0aGVuIGRpcm5hbWUgXiBmaWxlbmFtZVxuICBlbHNlIGRpcm5hbWUgXiBkaXJfc2VwIF4gZmlsZW5hbWVcblxubGV0IGNob3Bfc3VmZml4IG5hbWUgc3VmZiA9XG4gIGxldCBuID0gU3RyaW5nLmxlbmd0aCBuYW1lIC0gU3RyaW5nLmxlbmd0aCBzdWZmIGluXG4gIGlmIG4gPCAwIHRoZW4gaW52YWxpZF9hcmcgXCJGaWxlbmFtZS5jaG9wX3N1ZmZpeFwiIGVsc2UgU3RyaW5nLnN1YiBuYW1lIDAgblxuXG5sZXQgZXh0ZW5zaW9uX2xlbiBuYW1lID1cbiAgbGV0IHJlYyBjaGVjayBpMCBpID1cbiAgICBpZiBpIDwgMCB8fCBpc19kaXJfc2VwIG5hbWUgaSB0aGVuIDBcbiAgICBlbHNlIGlmIG5hbWUuW2ldID0gJy4nIHRoZW4gY2hlY2sgaTAgKGkgLSAxKVxuICAgIGVsc2UgU3RyaW5nLmxlbmd0aCBuYW1lIC0gaTBcbiAgaW5cbiAgbGV0IHJlYyBzZWFyY2hfZG90IGkgPVxuICAgIGlmIGkgPCAwIHx8IGlzX2Rpcl9zZXAgbmFtZSBpIHRoZW4gMFxuICAgIGVsc2UgaWYgbmFtZS5baV0gPSAnLicgdGhlbiBjaGVjayBpIChpIC0gMSlcbiAgICBlbHNlIHNlYXJjaF9kb3QgKGkgLSAxKVxuICBpblxuICBzZWFyY2hfZG90IChTdHJpbmcubGVuZ3RoIG5hbWUgLSAxKVxuXG5sZXQgZXh0ZW5zaW9uIG5hbWUgPVxuICBsZXQgbCA9IGV4dGVuc2lvbl9sZW4gbmFtZSBpblxuICBpZiBsID0gMCB0aGVuIFwiXCIgZWxzZSBTdHJpbmcuc3ViIG5hbWUgKFN0cmluZy5sZW5ndGggbmFtZSAtIGwpIGxcblxubGV0IGNob3BfZXh0ZW5zaW9uIG5hbWUgPVxuICBsZXQgbCA9IGV4dGVuc2lvbl9sZW4gbmFtZSBpblxuICBpZiBsID0gMCB0aGVuIGludmFsaWRfYXJnIFwiRmlsZW5hbWUuY2hvcF9leHRlbnNpb25cIlxuICBlbHNlIFN0cmluZy5zdWIgbmFtZSAwIChTdHJpbmcubGVuZ3RoIG5hbWUgLSBsKVxuXG5sZXQgcmVtb3ZlX2V4dGVuc2lvbiBuYW1lID1cbiAgbGV0IGwgPSBleHRlbnNpb25fbGVuIG5hbWUgaW5cbiAgaWYgbCA9IDAgdGhlbiBuYW1lIGVsc2UgU3RyaW5nLnN1YiBuYW1lIDAgKFN0cmluZy5sZW5ndGggbmFtZSAtIGwpXG5cbmV4dGVybmFsIG9wZW5fZGVzYzogc3RyaW5nIC0+IG9wZW5fZmxhZyBsaXN0IC0+IGludCAtPiBpbnQgPSBcImNhbWxfc3lzX29wZW5cIlxuZXh0ZXJuYWwgY2xvc2VfZGVzYzogaW50IC0+IHVuaXQgPSBcImNhbWxfc3lzX2Nsb3NlXCJcblxubGV0IHBybmcgPSBsYXp5KFJhbmRvbS5TdGF0ZS5tYWtlX3NlbGZfaW5pdCAoKSlcblxubGV0IHRlbXBfZmlsZV9uYW1lIHRlbXBfZGlyIHByZWZpeCBzdWZmaXggPVxuICBsZXQgcm5kID0gKFJhbmRvbS5TdGF0ZS5iaXRzIChMYXp5LmZvcmNlIHBybmcpKSBsYW5kIDB4RkZGRkZGIGluXG4gIGNvbmNhdCB0ZW1wX2RpciAoUHJpbnRmLnNwcmludGYgXCIlcyUwNnglc1wiIHByZWZpeCBybmQgc3VmZml4KVxuXG5cbmxldCBjdXJyZW50X3RlbXBfZGlyX25hbWUgPSByZWYgdGVtcF9kaXJfbmFtZVxuXG5sZXQgc2V0X3RlbXBfZGlyX25hbWUgcyA9IGN1cnJlbnRfdGVtcF9kaXJfbmFtZSA6PSBzXG5sZXQgZ2V0X3RlbXBfZGlyX25hbWUgKCkgPSAhY3VycmVudF90ZW1wX2Rpcl9uYW1lXG5cbmxldCB0ZW1wX2ZpbGUgPyh0ZW1wX2RpciA9ICFjdXJyZW50X3RlbXBfZGlyX25hbWUpIHByZWZpeCBzdWZmaXggPVxuICBsZXQgcmVjIHRyeV9uYW1lIGNvdW50ZXIgPVxuICAgIGxldCBuYW1lID0gdGVtcF9maWxlX25hbWUgdGVtcF9kaXIgcHJlZml4IHN1ZmZpeCBpblxuICAgIHRyeVxuICAgICAgY2xvc2VfZGVzYyhvcGVuX2Rlc2MgbmFtZSBbT3Blbl93cm9ubHk7IE9wZW5fY3JlYXQ7IE9wZW5fZXhjbF0gMG82MDApO1xuICAgICAgbmFtZVxuICAgIHdpdGggU3lzX2Vycm9yIF8gYXMgZSAtPlxuICAgICAgaWYgY291bnRlciA+PSAxMDAwIHRoZW4gcmFpc2UgZSBlbHNlIHRyeV9uYW1lIChjb3VudGVyICsgMSlcbiAgaW4gdHJ5X25hbWUgMFxuXG5sZXQgb3Blbl90ZW1wX2ZpbGUgPyhtb2RlID0gW09wZW5fdGV4dF0pID8ocGVybXMgPSAwbzYwMClcbiAgICAgICAgICAgICAgICAgICA/KHRlbXBfZGlyID0gIWN1cnJlbnRfdGVtcF9kaXJfbmFtZSkgcHJlZml4IHN1ZmZpeCA9XG4gIGxldCByZWMgdHJ5X25hbWUgY291bnRlciA9XG4gICAgbGV0IG5hbWUgPSB0ZW1wX2ZpbGVfbmFtZSB0ZW1wX2RpciBwcmVmaXggc3VmZml4IGluXG4gICAgdHJ5XG4gICAgICAobmFtZSxcbiAgICAgICBvcGVuX291dF9nZW4gKE9wZW5fd3Jvbmx5OjpPcGVuX2NyZWF0OjpPcGVuX2V4Y2w6Om1vZGUpIHBlcm1zIG5hbWUpXG4gICAgd2l0aCBTeXNfZXJyb3IgXyBhcyBlIC0+XG4gICAgICBpZiBjb3VudGVyID49IDEwMDAgdGhlbiByYWlzZSBlIGVsc2UgdHJ5X25hbWUgKGNvdW50ZXIgKyAxKVxuICBpbiB0cnlfbmFtZSAwXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDAyIEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIENvbXBsZXggbnVtYmVycyAqKVxuXG50eXBlIHQgPSB7IHJlOiBmbG9hdDsgaW06IGZsb2F0IH1cblxubGV0IHplcm8gPSB7IHJlID0gMC4wOyBpbSA9IDAuMCB9XG5sZXQgb25lID0geyByZSA9IDEuMDsgaW0gPSAwLjAgfVxubGV0IGkgPSB7IHJlID0gMC4wOyBpbSA9IDEuMCB9XG5cbmxldCBhZGQgeCB5ID0geyByZSA9IHgucmUgKy4geS5yZTsgaW0gPSB4LmltICsuIHkuaW0gfVxuXG5sZXQgc3ViIHggeSA9IHsgcmUgPSB4LnJlIC0uIHkucmU7IGltID0geC5pbSAtLiB5LmltIH1cblxubGV0IG5lZyB4ID0geyByZSA9IC0uIHgucmU7IGltID0gLS4geC5pbSB9XG5cbmxldCBjb25qIHggPSB7IHJlID0geC5yZTsgaW0gPSAtLiB4LmltIH1cblxubGV0IG11bCB4IHkgPSB7IHJlID0geC5yZSAqLiB5LnJlIC0uIHguaW0gKi4geS5pbTtcbiAgICAgICAgICAgICAgICBpbSA9IHgucmUgKi4geS5pbSArLiB4LmltICouIHkucmUgfVxuXG5sZXQgZGl2IHggeSA9XG4gIGlmIGFic19mbG9hdCB5LnJlID49IGFic19mbG9hdCB5LmltIHRoZW5cbiAgICBsZXQgciA9IHkuaW0gLy4geS5yZSBpblxuICAgIGxldCBkID0geS5yZSArLiByICouIHkuaW0gaW5cbiAgICB7IHJlID0gKHgucmUgKy4gciAqLiB4LmltKSAvLiBkO1xuICAgICAgaW0gPSAoeC5pbSAtLiByICouIHgucmUpIC8uIGQgfVxuICBlbHNlXG4gICAgbGV0IHIgPSB5LnJlIC8uIHkuaW0gaW5cbiAgICBsZXQgZCA9IHkuaW0gKy4gciAqLiB5LnJlIGluXG4gICAgeyByZSA9IChyICouIHgucmUgKy4geC5pbSkgLy4gZDtcbiAgICAgIGltID0gKHIgKi4geC5pbSAtLiB4LnJlKSAvLiBkIH1cblxubGV0IGludiB4ID0gZGl2IG9uZSB4XG5cbmxldCBub3JtMiB4ID0geC5yZSAqLiB4LnJlICsuIHguaW0gKi4geC5pbVxuXG5sZXQgbm9ybSB4ID1cbiAgKCogV2F0Y2ggb3V0IGZvciBvdmVyZmxvdyBpbiBjb21wdXRpbmcgcmVeMiArIGltXjIgKilcbiAgbGV0IHIgPSBhYnNfZmxvYXQgeC5yZSBhbmQgaSA9IGFic19mbG9hdCB4LmltIGluXG4gIGlmIHIgPSAwLjAgdGhlbiBpXG4gIGVsc2UgaWYgaSA9IDAuMCB0aGVuIHJcbiAgZWxzZSBpZiByID49IGkgdGhlblxuICAgIGxldCBxID0gaSAvLiByIGluIHIgKi4gc3FydCgxLjAgKy4gcSAqLiBxKVxuICBlbHNlXG4gICAgbGV0IHEgPSByIC8uIGkgaW4gaSAqLiBzcXJ0KDEuMCArLiBxICouIHEpXG5cbmxldCBhcmcgeCA9IGF0YW4yIHguaW0geC5yZVxuXG5sZXQgcG9sYXIgbiBhID0geyByZSA9IGNvcyBhICouIG47IGltID0gc2luIGEgKi4gbiB9XG5cbmxldCBzcXJ0IHggPVxuICBpZiB4LnJlID0gMC4wICYmIHguaW0gPSAwLjAgdGhlbiB7IHJlID0gMC4wOyBpbSA9IDAuMCB9XG4gIGVsc2UgYmVnaW5cbiAgICBsZXQgciA9IGFic19mbG9hdCB4LnJlIGFuZCBpID0gYWJzX2Zsb2F0IHguaW0gaW5cbiAgICBsZXQgdyA9XG4gICAgICBpZiByID49IGkgdGhlbiBiZWdpblxuICAgICAgICBsZXQgcSA9IGkgLy4gciBpblxuICAgICAgICBzcXJ0KHIpICouIHNxcnQoMC41ICouICgxLjAgKy4gc3FydCgxLjAgKy4gcSAqLiBxKSkpXG4gICAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgICBsZXQgcSA9IHIgLy4gaSBpblxuICAgICAgICBzcXJ0KGkpICouIHNxcnQoMC41ICouIChxICsuIHNxcnQoMS4wICsuIHEgKi4gcSkpKVxuICAgICAgZW5kIGluXG4gICAgaWYgeC5yZSA+PSAwLjBcbiAgICB0aGVuIHsgcmUgPSB3OyAgaW0gPSAwLjUgKi4geC5pbSAvLiB3IH1cbiAgICBlbHNlIHsgcmUgPSAwLjUgKi4gaSAvLiB3OyAgaW0gPSBpZiB4LmltID49IDAuMCB0aGVuIHcgZWxzZSAtLiB3IH1cbiAgZW5kXG5cbmxldCBleHAgeCA9XG4gIGxldCBlID0gZXhwIHgucmUgaW4geyByZSA9IGUgKi4gY29zIHguaW07IGltID0gZSAqLiBzaW4geC5pbSB9XG5cbmxldCBsb2cgeCA9IHsgcmUgPSBsb2cgKG5vcm0geCk7IGltID0gYXRhbjIgeC5pbSB4LnJlIH1cblxubGV0IHBvdyB4IHkgPSBleHAgKG11bCB5IChsb2cgeCkpXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgQmVub2l0IFZhdWdvbiwgRU5TVEEgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE0IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIFBhZGRpbmcgcG9zaXRpb24uICopXG50eXBlIHBhZHR5ID1cbiAgfCBMZWZ0ICAgKCogVGV4dCBpcyBsZWZ0IGp1c3RpZmllZCAoJy0nIG9wdGlvbikuICAgICAgICAgICAgICAgKilcbiAgfCBSaWdodCAgKCogVGV4dCBpcyByaWdodCBqdXN0aWZpZWQgKG5vICctJyBvcHRpb24pLiAgICAgICAgICAgKilcbiAgfCBaZXJvcyAgKCogVGV4dCBpcyByaWdodCBqdXN0aWZpZWQgYnkgemVyb3MgKHNlZSAnMCcgb3B0aW9uKS4gKilcblxuKCoqKilcblxuKCogSW50ZWdlciBjb252ZXJzaW9uLiAqKVxudHlwZSBpbnRfY29udiA9XG4gIHwgSW50X2QgfCBJbnRfcGQgfCBJbnRfc2QgICAgICAgICgqICAlZCB8ICUrZCB8ICUgZCAgKilcbiAgfCBJbnRfaSB8IEludF9waSB8IEludF9zaSAgICAgICAgKCogICVpIHwgJStpIHwgJSBpICAqKVxuICB8IEludF94IHwgSW50X0N4ICAgICAgICAgICAgICAgICAoKiAgJXggfCAlI3ggICAgICAgICopXG4gIHwgSW50X1ggfCBJbnRfQ1ggICAgICAgICAgICAgICAgICgqICAlWCB8ICUjWCAgICAgICAgKilcbiAgfCBJbnRfbyB8IEludF9DbyAgICAgICAgICAgICAgICAgKCogICVvIHwgJSNvICAgICAgICAqKVxuICB8IEludF91ICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAgJXUgICAgICAgICAgICAgICopXG4gIHwgSW50X0NkIHwgSW50X0NpIHwgSW50X0N1ICAgICAgICgqICAlI2QgfCAlI2kgfCAlI3UgKilcblxuKCogRmxvYXQgY29udmVyc2lvbi4gKilcbnR5cGUgZmxvYXRfZmxhZ19jb252ID1cbiAgfCBGbG9hdF9mbGFnXyAgICAgICAgICAgICAgICAgICAgKCogJVtmZUVnR0ZoSF0gKilcbiAgfCBGbG9hdF9mbGFnX3AgICAgICAgICAgICAgICAgICAgKCogJStbZmVFZ0dGaEhdICopXG4gIHwgRmxvYXRfZmxhZ19zICAgICAgICAgICAgICAgICAgICgqICUgW2ZlRWdHRmhIXSAqKVxudHlwZSBmbG9hdF9raW5kX2NvbnYgPVxuICB8IEZsb2F0X2YgICAgICAgICAgICAgICAgICAgICAgICAoKiAgJWYgfCAlK2YgfCAlIGYgICopXG4gIHwgRmxvYXRfZSAgICAgICAgICAgICAgICAgICAgICAgICgqICAlZSB8ICUrZSB8ICUgZSAgKilcbiAgfCBGbG9hdF9FICAgICAgICAgICAgICAgICAgICAgICAgKCogICVFIHwgJStFIHwgJSBFICAqKVxuICB8IEZsb2F0X2cgICAgICAgICAgICAgICAgICAgICAgICAoKiAgJWcgfCAlK2cgfCAlIGcgICopXG4gIHwgRmxvYXRfRyAgICAgICAgICAgICAgICAgICAgICAgICgqICAlRyB8ICUrRyB8ICUgRyAgKilcbiAgfCBGbG9hdF9GICAgICAgICAgICAgICAgICAgICAgICAgKCogICVGIHwgJStGIHwgJSBGICAqKVxuICB8IEZsb2F0X2ggICAgICAgICAgICAgICAgICAgICAgICAoKiAgJWggfCAlK2ggfCAlIGggICopXG4gIHwgRmxvYXRfSCAgICAgICAgICAgICAgICAgICAgICAgICgqICAlSCB8ICUrSCB8ICUgSCAgKilcbiAgfCBGbG9hdF9DRiAgICAgICAgICAgICAgICAgICAgICAgKCogICUjRnwgJSsjRnwgJSAjRiAqKVxudHlwZSBmbG9hdF9jb252ID0gZmxvYXRfZmxhZ19jb252ICogZmxvYXRfa2luZF9jb252XG5cbigqKiopXG5cbigqIENoYXIgc2V0cyAoc2VlICVbLi4uXSkgYXJlIGJpdG1hcHMgaW1wbGVtZW50ZWQgYXMgMzItY2hhciBzdHJpbmdzLiAqKVxudHlwZSBjaGFyX3NldCA9IHN0cmluZ1xuXG4oKioqKVxuXG4oKiBDb3VudGVyIHVzZWQgaW4gU2NhbmYuICopXG50eXBlIGNvdW50ZXIgPVxuICB8IExpbmVfY291bnRlciAgICAgKCogICVsICAgICAgKilcbiAgfCBDaGFyX2NvdW50ZXIgICAgICgqICAlbiAgICAgICopXG4gIHwgVG9rZW5fY291bnRlciAgICAoKiAgJU4sICVMICAqKVxuXG4oKioqKVxuXG4oKiBQYWRkaW5nIG9mIHN0cmluZ3MgYW5kIG51bWJlcnMuICopXG50eXBlICgnYSwgJ2IpIHBhZGRpbmcgPVxuICAoKiBObyBwYWRkaW5nIChleDogXCIlZFwiKSAqKVxuICB8IE5vX3BhZGRpbmcgIDogKCdhLCAnYSkgcGFkZGluZ1xuICAoKiBMaXRlcmFsIHBhZGRpbmcgKGV4OiBcIiU4ZFwiKSAqKVxuICB8IExpdF9wYWRkaW5nIDogcGFkdHkgKiBpbnQgLT4gKCdhLCAnYSkgcGFkZGluZ1xuICAoKiBQYWRkaW5nIGFzIGV4dHJhIGFyZ3VtZW50IChleDogXCIlKmRcIikgKilcbiAgfCBBcmdfcGFkZGluZyA6IHBhZHR5IC0+IChpbnQgLT4gJ2EsICdhKSBwYWRkaW5nXG5cbigqIFNvbWUgZm9ybWF0cywgc3VjaCBhcyAlX2QsXG4gICBvbmx5IGFjY2VwdCBhbiBvcHRpb25hbCBudW1iZXIgYXMgcGFkZGluZyBvcHRpb24gKG5vIGV4dHJhIGFyZ3VtZW50KSAqKVxudHlwZSBwYWRfb3B0aW9uID0gaW50IG9wdGlvblxuXG4oKiBQcmVjaXNpb24gb2YgZmxvYXRzIGFuZCAnMCctcGFkZGluZyBvZiBpbnRlZ2Vycy4gKilcbnR5cGUgKCdhLCAnYikgcHJlY2lzaW9uID1cbiAgKCogTm8gcHJlY2lzaW9uIChleDogXCIlZlwiKSAqKVxuICB8IE5vX3ByZWNpc2lvbiA6ICgnYSwgJ2EpIHByZWNpc2lvblxuICAoKiBMaXRlcmFsIHByZWNpc2lvbiAoZXg6IFwiJS4zZlwiKSAqKVxuICB8IExpdF9wcmVjaXNpb24gOiBpbnQgLT4gKCdhLCAnYSkgcHJlY2lzaW9uXG4gICgqIFByZWNpc2lvbiBhcyBleHRyYSBhcmd1bWVudCAoZXg6IFwiJS4qZlwiKSAqKVxuICB8IEFyZ19wcmVjaXNpb24gOiAoaW50IC0+ICdhLCAnYSkgcHJlY2lzaW9uXG5cbigqIFNvbWUgZm9ybWF0cywgc3VjaCBhcyAlX2YsXG4gICBvbmx5IGFjY2VwdCBhbiBvcHRpb25hbCBudW1iZXIgYXMgcHJlY2lzaW9uIG9wdGlvbiAobm8gZXh0cmEgYXJndW1lbnQpICopXG50eXBlIHByZWNfb3B0aW9uID0gaW50IG9wdGlvblxuXG4oKiBzZWUgdGhlIEN1c3RvbSBmb3JtYXQgY29tYmluYXRvciAqKVxudHlwZSAoJ2EsICdiLCAnYykgY3VzdG9tX2FyaXR5ID1cbiAgfCBDdXN0b21femVybyA6ICgnYSwgc3RyaW5nLCAnYSkgY3VzdG9tX2FyaXR5XG4gIHwgQ3VzdG9tX3N1Y2MgOiAoJ2EsICdiLCAnYykgY3VzdG9tX2FyaXR5IC0+XG4gICAgKCdhLCAneCAtPiAnYiwgJ3ggLT4gJ2MpIGN1c3RvbV9hcml0eVxuXG4oKioqKVxuXG4oKiAgICAgICAgUmVsYXRpb25hbCBmb3JtYXQgdHlwZXNcblxuSW4gdGhlIGZpcnN0IGZvcm1hdCtnYWR0cyBpbXBsZW1lbnRhdGlvbiwgdGhlIHR5cGUgZm9yICUoLi4lKSBpbiB0aGVcbmZtdCBHQURUIHdhcyBhcyBmb2xsb3dzOlxuXG58IEZvcm1hdF9zdWJzdCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICUoLi4uJSkgKilcbiAgICBwYWRfb3B0aW9uICogKCdkMSwgJ3ExLCAnZDIsICdxMikgcmVhZGVyX25iX3VuaWZpZXIgKlxuICAgICgneCwgJ2IsICdjLCAnZDEsICdxMSwgJ3UpIGZtdHR5ICpcbiAgICAoJ3UsICdiLCAnYywgJ3ExLCAnZTEsICdmKSBmbXQgLT5cbiAgICAgICgoJ3gsICdiLCAnYywgJ2QyLCAncTIsICd1KSBmb3JtYXQ2IC0+ICd4LCAnYiwgJ2MsICdkMSwgJ2UxLCAnZikgZm10XG5cbk5vdGljZSB0aGF0IHRoZSAndSBwYXJhbWV0ZXIgaW4gJ2YgcG9zaXRpb24gaW4gdGhlIGZvcm1hdCBhcmd1bWVudFxuKCgneCwgLi4sICd1KSBmb3JtYXQ2IC0+IC4uKSBpcyBlcXVhbCB0byB0aGUgJ3UgcGFyYW1ldGVyIGluICdhXG5wb3NpdGlvbiBpbiB0aGUgZm9ybWF0IHRhaWwgKCgndSwgLi4sICdmKSBmbXQpLiBUaGlzIG1lYW5zIHRoYXQgdGhlXG50eXBlIG9mIHRoZSBleHBlY3RlZCBmb3JtYXQgcGFyYW1ldGVyIGRlcGVuZHMgb2Ygd2hlcmUgdGhlICUoLi4uJSlcbmFyZSBpbiB0aGUgZm9ybWF0IHN0cmluZzpcblxuICAjIFByaW50Zi5wcmludGYgXCIlKCUpXCJcbiAgLSA6ICh1bml0LCBvdXRfY2hhbm5lbCwgdW5pdCwgJ19hLCAnX2EsIHVuaXQpXG4gICAgICBDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3MuZm9ybWF0NiAtPiB1bml0XG4gID0gPGZ1bj5cbiAgIyBQcmludGYucHJpbnRmIFwiJSglKSVkXCJcbiAgLSA6IChpbnQgLT4gdW5pdCwgb3V0X2NoYW5uZWwsIHVuaXQsICdfYSwgJ19hLCBpbnQgLT4gdW5pdClcbiAgICAgIENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljcy5mb3JtYXQ2IC0+IGludCAtPiB1bml0XG4gID0gPGZ1bj5cblxuT24gdGhlIGNvbnRyYXJ5LCB0aGUgbGVnYWN5IHR5cGVyIGdpdmVzIGEgY2xldmVyIHR5cGUgdGhhdCBkb2VzIG5vdFxuZGVwZW5kIG9uIHRoZSBwb3NpdGlvbiBvZiAlKC4uJSkgaW4gdGhlIGZvcm1hdCBzdHJpbmcuIEZvciBleGFtcGxlLFxuJSglKSB3aWxsIGhhdmUgdGhlIHBvbHltb3JwaGljIHR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpOiBpdCBjYW5cbmJlIGNvbmNhdGVuYXRlZCB0byBhbnkgZm9ybWF0IHR5cGUsIGFuZCBvbmx5IGVuZm9yY2VzIHRoZSBjb25zdHJhaW50XG50aGF0IGl0cyAnYSBhbmQgJ2YgcGFyYW1ldGVycyBhcmUgZXF1YWwgKG5vIGZvcm1hdCBhcmd1bWVudHMpIGFuZCAnZFxuYW5kICdlIGFyZSBlcXVhbCAobm8gcmVhZGVyIGFyZ3VtZW50KS5cblxuVGhlIHdlYWtlbmluZyBvZiB0aGlzIHBhcmFtZXRlciB0eXBlIGluIHRoZSBHQURUIHZlcnNpb24gYnJva2UgdXNlclxuY29kZSAoaW4gZmFjdCBpdCBlc3NlbnRpYWxseSBtYWRlICUoLi4uJSkgdW51c2FibGUgZXhjZXB0IGF0IHRoZSBsYXN0XG5wb3NpdGlvbiBvZiBhIGZvcm1hdCkuIEluIHBhcnRpY3VsYXIsIHRoZSBmb2xsb3dpbmcgd291bGQgbm90IHdvcmtcbmFueW1vcmU6XG5cbiAgZnVuIHNlcCAtPlxuICAgIEZvcm1hdC5wcmludGYgXCJmb28lKCUpYmFyJSglKWJhelwiIHNlcCBzZXBcblxuQXMgdGhlIHR5cGUtY2hlY2tlciB3b3VsZCByZXF1aXJlIHR3byAqaW5jb21wYXRpYmxlKiB0eXBlcyBmb3IgdGhlICUoJSlcbmluIGRpZmZlcmVudCBwb3NpdGlvbnMuXG5cblRoZSBzb2x1dGlvbiB0byByZWdhaW4gYSBnZW5lcmFsIHR5cGUgZm9yICUoLi4lKSBpcyB0byBnZW5lcmFsaXplIHRoaXNcbnRlY2huaXF1ZSwgbm90IG9ubHkgb24gdGhlICdkLCAnZSBwYXJhbWV0ZXJzLCBidXQgb24gYWxsIHNpeFxucGFyYW1ldGVycyBvZiBhIGZvcm1hdDogd2UgaW50cm9kdWNlIGEgXCJyZWxhdGlvbmFsXCIgdHlwZVxuICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxud2hvc2UgdmFsdWVzIGFyZSBwcm9vZnMgdGhhdCAoJ2ExLCAuLiwgJ2YxKSBhbmQgKCdhMiwgLi4sICdmMikgbW9yYWxseVxuY29ycmVzcG9uZCB0byB0aGUgc2FtZSBmb3JtYXQgdHlwZTogJ2ExIGlzIG9idGFpbmVkIGZyb20gJ2YxLCdiMSwnYzFcbmluIHRoZSBleGFjdCBzYW1lIHdheSB0aGF0ICdhMiBpcyBvYnRhaW5lZCBmcm9tICdmMiwnYjIsJ2MyLCBldGMuXG5cbkZvciBleGFtcGxlLCB0aGUgcmVsYXRpb24gYmV0d2VlbiB0d28gZm9ybWF0IHR5cGVzIGJlZ2lubmluZyB3aXRoIGEgQ2hhclxucGFyYW1ldGVyIGlzIGFzIGZvbGxvd3M6XG5cbnwgQ2hhcl90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVjICAqKVxuICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAoY2hhciAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICBjaGFyIC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuXG5JbiB0aGUgZ2VuZXJhbCBjYXNlLCB0aGUgdGVybSBzdHJ1Y3R1cmUgb2YgZm10dHlfcmVsIGlzIChhbG1vc3RbMV0pXG5pc29tb3JwaGljIHRvIHRoZSBmbXR0eSBvZiB0aGUgcHJldmlvdXMgaW1wbGVtZW50YXRpb246IGV2ZXJ5XG5jb25zdHJ1Y3RvciBpcyByZS1yZWFkIHdpdGggYSBiaW5hcnksIHJlbGF0aW9uYWwgdHlwZSwgaW5zdGVhZCBvZiB0aGVcbnByZXZpb3VzIHVuYXJ5IHR5cGluZy4gZm10dHkgY2FuIHRoZW4gYmUgcmUtZGVmaW5lZCBhcyB0aGUgZGlhZ29uYWwgb2ZcbmZtdHR5X3JlbDpcblxuICB0eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXR0eSA9XG4gICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YsXG4gICAgICAgICdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdHR5X3JlbFxuXG5PbmNlIHdlIGhhdmUgdGhpcyBmbXR0eV9yZWwgdHlwZSBpbiBwbGFjZSwgd2UgY2FuIGdpdmUgdGhlIG1vcmVcbmdlbmVyYWwgdHlwZSB0byAlKC4uLiUpOlxuXG58IEZvcm1hdF9zdWJzdCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICUoLi4uJSkgKilcbiAgICBwYWRfb3B0aW9uICpcbiAgICAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCxcbiAgICAgJ2cyLCAnYiwgJ2MsICdqMiwgJ2QsICdhKSBmbXR0eV9yZWwgKlxuICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAoKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZvcm1hdDYgLT4gJ2cyLCAnYiwgJ2MsICdqMiwgJ2UsICdmKSBmbXRcblxuV2UgYWNjZXB0IGFueSBmb3JtYXQgKCgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmb3JtYXQ2KSAodGhpcyBpc1xuY29tcGxldGVseSB1bnJlbGF0ZWQgdG8gdGhlIHR5cGUgb2YgdGhlIGN1cnJlbnQgZm9ybWF0KSwgYnV0IGFsc29cbnJlcXVpcmUgYSBwcm9vZiB0aGF0IHRoaXMgZm9ybWF0IGlzIGluIHJlbGF0aW9uIHRvIGFub3RoZXIgZm9ybWF0IHRoYXRcbmlzIGNvbmNhdGVuYWJsZSB0byB0aGUgZm9ybWF0IHRhaWwuIFdoZW4gZXhlY3V0aW5nIGEgJSguLi4lKSBmb3JtYXRcbihpbiBjYW1saW50ZXJuYWxGb3JtYXQubWw6bWFrZV9wcmludGYgb3Igc2NhbmYubWw6bWFrZV9zY2FuZiksIHdlXG50cmFuc3R5cGUgdGhlIGZvcm1hdCBhbG9uZyB0aGlzIHJlbGF0aW9uIHVzaW5nIHRoZSAncmVjYXN0JyBmdW5jdGlvblxudG8gdHJhbnNwb3NlIGJldHdlZW4gcmVsYXRlZCBmb3JtYXQgdHlwZXMuXG5cbiAgdmFsIHJlY2FzdCA6XG4gICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxKSBmbXRcbiAgLT4gKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgLT4gKCdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdFxuXG5OT1RFIFsxXTogdGhlIHR5cGluZyBvZiBGb3JtYXRfc3Vic3RfdHkgcmVxdWlyZXMgbm90IG9uZSBmb3JtYXQgdHlwZSwgYnV0XG50d28sIG9uZSB0byBlc3RhYmxpc2ggdGhlIGxpbmsgYmV0d2VlbiB0aGUgZm9ybWF0IGFyZ3VtZW50IGFuZCB0aGVcbmZpcnN0IHNpeCBwYXJhbWV0ZXJzLCBhbmQgdGhlIG90aGVyIGZvciB0aGUgbGluayBiZXR3ZWVuIHRoZSBmb3JtYXRcbmFyZ3VtZW50IGFuZCB0aGUgbGFzdCBzaXggcGFyYW1ldGVycy5cblxufCBGb3JtYXRfc3Vic3RfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJSguLi4lKSAqKVxuICAgICgnZywgJ2gsICdpLCAnaiwgJ2ssICdsLFxuICAgICAnZzEsICdiMSwgJ2MxLCAnajEsICdkMSwgJ2ExKSBmbXR0eV9yZWwgKlxuICAgICgnZywgJ2gsICdpLCAnaiwgJ2ssICdsLFxuICAgICAnZzIsICdiMiwgJ2MyLCAnajIsICdkMiwgJ2EyKSBmbXR0eV9yZWwgKlxuICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAoKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZvcm1hdDYgLT4gJ2cxLCAnYjEsICdjMSwgJ2oxLCAnZTEsICdmMSxcbiAgICAgKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZvcm1hdDYgLT4gJ2cyLCAnYjIsICdjMiwgJ2oyLCAnZTIsICdmMikgZm10dHlfcmVsXG5cbldoZW4gd2UgZ2VuZXJhdGUgYSBmb3JtYXQgQVNULCB3ZSBnZW5lcmF0ZSBleGFjdGx5IHRoZSBzYW1lIHdpdG5lc3NcbmZvciBib3RoIHJlbGF0aW9ucywgYW5kIHRoZSB3aXRuZXNzLWNvbnZlcnNpb24gZnVuY3Rpb25zIGluXG5jYW1saW50ZXJuYWxGb3JtYXQgZG8gcmVseSBvbiB0aGlzIGludmFyaWFudC4gRm9yIGV4YW1wbGUsIHRoZVxuZnVuY3Rpb24gdGhhdCBwcm92ZXMgdGhhdCB0aGUgcmVsYXRpb24gaXMgdHJhbnNpdGl2ZVxuXG4gIHZhbCB0cmFucyA6XG4gICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG4gIC0+ICgnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyLFxuICAgICAgJ2EzLCAnYjMsICdjMywgJ2QzLCAnZTMsICdmMykgZm10dHlfcmVsXG4gIC0+ICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgJ2EzLCAnYjMsICdjMywgJ2QzLCAnZTMsICdmMykgZm10dHlfcmVsXG5cbmRvZXMgYXNzdW1lIHRoYXQgdGhlIHR3byBpbnB1dHMgaGF2ZSBleGFjdGx5IHRoZSBzYW1lIHRlcm0gc3RydWN0dXJlXG4oYW5kIGlzIG9ubHkgZXZlcnkgdXNlZCBmb3IgYXJndW1lbnQgd2l0bmVzc2VzIG9mIHRoZVxuRm9ybWF0X3N1YnN0X3R5IGNvbnN0cnVjdG9yKS5cbiopXG5cbigqIFR5cGUgb2YgYSBibG9jayB1c2VkIGJ5IHRoZSBGb3JtYXQgcHJldHR5LXByaW50ZXIuICopXG50eXBlIGJsb2NrX3R5cGUgPVxuICB8IFBwX2hib3ggICAoKiBIb3Jpem9udGFsIGJsb2NrIG5vIGxpbmUgYnJlYWtpbmcgKilcbiAgfCBQcF92Ym94ICAgKCogVmVydGljYWwgYmxvY2sgZWFjaCBicmVhayBsZWFkcyB0byBhIG5ldyBsaW5lICopXG4gIHwgUHBfaHZib3ggICgqIEhvcml6b250YWwtdmVydGljYWwgYmxvY2s6IHNhbWUgYXMgdmJveCwgZXhjZXB0IGlmIHRoaXMgYmxvY2tcbiAgICAgICAgICAgICAgICAgaXMgc21hbGwgZW5vdWdoIHRvIGZpdCBvbiBhIHNpbmdsZSBsaW5lICopXG4gIHwgUHBfaG92Ym94ICgqIEhvcml6b250YWwgb3IgVmVydGljYWwgYmxvY2s6IGJyZWFrcyBsZWFkIHRvIG5ldyBsaW5lXG4gICAgICAgICAgICAgICAgIG9ubHkgd2hlbiBuZWNlc3NhcnkgdG8gcHJpbnQgdGhlIGNvbnRlbnQgb2YgdGhlIGJsb2NrICopXG4gIHwgUHBfYm94ICAgICgqIEhvcml6b250YWwgb3IgSW5kZW50IGJsb2NrOiBicmVha3MgbGVhZCB0byBuZXcgbGluZVxuICAgICAgICAgICAgICAgICBvbmx5IHdoZW4gbmVjZXNzYXJ5IHRvIHByaW50IHRoZSBjb250ZW50IG9mIHRoZSBibG9jaywgb3JcbiAgICAgICAgICAgICAgICAgd2hlbiBpdCBsZWFkcyB0byBhIG5ldyBpbmRlbnRhdGlvbiBvZiB0aGUgY3VycmVudCBsaW5lICopXG4gIHwgUHBfZml0cyAgICgqIEludGVybmFsIHVzYWdlOiB3aGVuIGEgYmxvY2sgZml0cyBvbiBhIHNpbmdsZSBsaW5lICopXG5cbigqIEZvcm1hdHRpbmcgZWxlbWVudCB1c2VkIGJ5IHRoZSBGb3JtYXQgcHJldHR5LXByaW50ZXIuICopXG50eXBlIGZvcm1hdHRpbmdfbGl0ID1cbiAgfCBDbG9zZV9ib3ggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQF0gICAqKVxuICB8IENsb3NlX3RhZyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBAfSAgICopXG4gIHwgQnJlYWsgb2Ygc3RyaW5nICogaW50ICogaW50ICAgICAgICAgICgqIEAsIHwgQCAgfCBAOyB8IEA7PD4gKilcbiAgfCBGRmx1c2ggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQD8gICAqKVxuICB8IEZvcmNlX25ld2xpbmUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBAXFxuICAqKVxuICB8IEZsdXNoX25ld2xpbmUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBALiAgICopXG4gIHwgTWFnaWNfc2l6ZSBvZiBzdHJpbmcgKiBpbnQgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEA8bj4gKilcbiAgfCBFc2NhcGVkX2F0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQEAgICAqKVxuICB8IEVzY2FwZWRfcGVyY2VudCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBAJSUgICopXG4gIHwgU2Nhbl9pbmRpYyBvZiBjaGFyICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEBYICAgKilcblxuKCogRm9ybWF0dGluZyBlbGVtZW50IHVzZWQgYnkgdGhlIEZvcm1hdCBwcmV0dHktcHJpbnRlci4gKilcbnR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdHRpbmdfZ2VuID1cbiAgfCBPcGVuX3RhZyA6ICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2IC0+ICAgICAgKCogQHsgICAqKVxuICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXR0aW5nX2dlblxuICB8IE9wZW5fYm94IDogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgLT4gICAgICAoKiBAWyAgICopXG4gICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdHRpbmdfZ2VuXG5cbigqKiopXG5cbigqIExpc3Qgb2YgZm9ybWF0IHR5cGUgZWxlbWVudHMuICopXG4oKiBJbiBwYXJ0aWN1bGFyIHVzZWQgdG8gcmVwcmVzZW50ICUoLi4uJSkgYW5kICV7Li4uJX0gY29udGVudHMuICopXG5hbmQgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdHR5ID1cbiAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YsXG4gICAgICAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXR0eV9yZWxcbmFuZCAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsID1cbiAgfCBDaGFyX3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJWMgICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgIChjaGFyIC0+ICdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgY2hhciAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgfCBTdHJpbmdfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJXMgICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgIChzdHJpbmcgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICBzdHJpbmcgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG4gIHwgSW50X3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVkICAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoaW50IC0+ICdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgaW50IC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICB8IEludDMyX3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlbGQgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKGludDMyIC0+ICdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgaW50MzIgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG4gIHwgTmF0aXZlaW50X3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVuZCAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAobmF0aXZlaW50IC0+ICdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgbmF0aXZlaW50IC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICB8IEludDY0X3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlTGQgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKGludDY0IC0+ICdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgaW50NjQgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG4gIHwgRmxvYXRfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVmICAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoZmxvYXQgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICBmbG9hdCAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgfCBCb29sX3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJUIgICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgIChib29sIC0+ICdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgYm9vbCAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcblxuICB8IEZvcm1hdF9hcmdfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAley4uLiV9ICopXG4gICAgICAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm10dHkgKlxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZvcm1hdDYgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm9ybWF0NiAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKVxuICAgICAgICAgICBmbXR0eV9yZWxcbiAgfCBGb3JtYXRfc3Vic3RfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJSguLi4lKSAqKVxuICAgICAgKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wsXG4gICAgICAgJ2cxLCAnYjEsICdjMSwgJ2oxLCAnZDEsICdhMSkgZm10dHlfcmVsICpcbiAgICAgICgnZywgJ2gsICdpLCAnaiwgJ2ssICdsLFxuICAgICAgICdnMiwgJ2IyLCAnYzIsICdqMiwgJ2QyLCAnYTIpIGZtdHR5X3JlbCAqXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgICgoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm9ybWF0NiAtPiAnZzEsICdiMSwgJ2MxLCAnajEsICdlMSwgJ2YxLFxuICAgICAgICgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmb3JtYXQ2IC0+ICdnMiwgJ2IyLCAnYzIsICdqMiwgJ2UyLCAnZjIpXG4gICAgICAgICAgIGZtdHR5X3JlbFxuXG4gICgqIFByaW50ZiBhbmQgRm9ybWF0IHNwZWNpZmljIGNvbnN0cnVjdG9ycy4gKilcbiAgfCBBbHBoYV90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJWEgICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgICgoJ2IxIC0+ICd4IC0+ICdjMSkgLT4gJ3ggLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAoJ2IyIC0+ICd4IC0+ICdjMikgLT4gJ3ggLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG4gIHwgVGhldGFfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICV0ICAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoKCdiMSAtPiAnYzEpIC0+ICdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgKCdiMiAtPiAnYzIpIC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICB8IEFueV90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogVXNlZCBmb3IgY3VzdG9tIGZvcm1hdHMgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKCd4IC0+ICdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ3ggLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG5cbiAgKCogU2NhbmYgc3BlY2lmaWMgY29uc3RydWN0b3IuICopXG4gIHwgUmVhZGVyX3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVyICAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoJ3ggLT4gJ2ExLCAnYjEsICdjMSwgKCdiMSAtPiAneCkgLT4gJ2QxLCAnZTEsICdmMSxcbiAgICAgICAneCAtPiAnYTIsICdiMiwgJ2MyLCAoJ2IyIC0+ICd4KSAtPiAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgfCBJZ25vcmVkX3JlYWRlcl90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9yICAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoJ2ExLCAnYjEsICdjMSwgKCdiMSAtPiAneCkgLT4gJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAoJ2IyIC0+ICd4KSAtPiAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcblxuICB8IEVuZF9vZl9mbXR0eSA6XG4gICAgICAoJ2YxLCAnYjEsICdjMSwgJ2QxLCAnZDEsICdmMSxcbiAgICAgICAnZjIsICdiMiwgJ2MyLCAnZDIsICdkMiwgJ2YyKSBmbXR0eV9yZWxcblxuKCoqKilcblxuKCogTGlzdCBvZiBmb3JtYXQgZWxlbWVudHMuICopXG5hbmQgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCA9XG4gIHwgQ2hhciA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJWMgKilcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKGNoYXIgLT4gJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgQ2FtbF9jaGFyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJUMgKilcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKGNoYXIgLT4gJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgU3RyaW5nIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJXMgKilcbiAgICAgICgneCwgc3RyaW5nIC0+ICdhKSBwYWRkaW5nICogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ3gsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgQ2FtbF9zdHJpbmcgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJVMgKilcbiAgICAgICgneCwgc3RyaW5nIC0+ICdhKSBwYWRkaW5nICogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ3gsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgSW50IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJVtkaXhYdW9dICopXG4gICAgICBpbnRfY29udiAqICgneCwgJ3kpIHBhZGRpbmcgKiAoJ3ksIGludCAtPiAnYSkgcHJlY2lzaW9uICpcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCd4LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IEludDMyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVsW2RpeFh1b10gKilcbiAgICAgIGludF9jb252ICogKCd4LCAneSkgcGFkZGluZyAqICgneSwgaW50MzIgLT4gJ2EpIHByZWNpc2lvbiAqXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgneCwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBOYXRpdmVpbnQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlbltkaXhYdW9dICopXG4gICAgICBpbnRfY29udiAqICgneCwgJ3kpIHBhZGRpbmcgKiAoJ3ksIG5hdGl2ZWludCAtPiAnYSkgcHJlY2lzaW9uICpcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCd4LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IEludDY0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVMW2RpeFh1b10gKilcbiAgICAgIGludF9jb252ICogKCd4LCAneSkgcGFkZGluZyAqICgneSwgaW50NjQgLT4gJ2EpIHByZWNpc2lvbiAqXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgneCwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBGbG9hdCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlW2ZlRWdHRmhIXSAqKVxuICAgICAgZmxvYXRfY29udiAqICgneCwgJ3kpIHBhZGRpbmcgKiAoJ3ksIGZsb2F0IC0+ICdhKSBwcmVjaXNpb24gKlxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ3gsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgQm9vbCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJVtiQl0gKilcbiAgICAgICgneCwgYm9vbCAtPiAnYSkgcGFkZGluZyAqICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCd4LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IEZsdXNoIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICUhICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcblxuICB8IFN0cmluZ19saXRlcmFsIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIGFiYyAqKVxuICAgICAgc3RyaW5nICogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgQ2hhcl9saXRlcmFsIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogeCAqKVxuICAgICAgY2hhciAqICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuXG4gIHwgRm9ybWF0X2FyZyA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJXsuLi4lfSAqKVxuICAgICAgcGFkX29wdGlvbiAqICgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmbXR0eSAqXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm9ybWF0NiAtPiAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBGb3JtYXRfc3Vic3QgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlKC4uLiUpICopXG4gICAgICBwYWRfb3B0aW9uICpcbiAgICAgICgnZywgJ2gsICdpLCAnaiwgJ2ssICdsLFxuICAgICAgICdnMiwgJ2IsICdjLCAnajIsICdkLCAnYSkgZm10dHlfcmVsICpcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICgoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm9ybWF0NiAtPiAnZzIsICdiLCAnYywgJ2oyLCAnZSwgJ2YpIGZtdFxuXG4gICgqIFByaW50ZiBhbmQgRm9ybWF0IHNwZWNpZmljIGNvbnN0cnVjdG9yLiAqKVxuICB8IEFscGhhIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVhICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgoJ2IgLT4gJ3ggLT4gJ2MpIC0+ICd4IC0+ICdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IFRoZXRhIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICV0ICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgoJ2IgLT4gJ2MpIC0+ICdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuXG4gICgqIEZvcm1hdCBzcGVjaWZpYyBjb25zdHJ1Y3RvcjogKilcbiAgfCBGb3JtYXR0aW5nX2xpdCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBAXyAqKVxuICAgICAgZm9ybWF0dGluZ19saXQgKiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBGb3JtYXR0aW5nX2dlbiA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQF8gKilcbiAgICAgICgnYTEsICdiLCAnYywgJ2QxLCAnZTEsICdmMSkgZm9ybWF0dGluZ19nZW4gKlxuICAgICAgKCdmMSwgJ2IsICdjLCAnZTEsICdlMiwgJ2YyKSBmbXQgLT4gKCdhMSwgJ2IsICdjLCAnZDEsICdlMiwgJ2YyKSBmbXRcblxuICAoKiBTY2FuZiBzcGVjaWZpYyBjb25zdHJ1Y3RvcnM6ICopXG4gIHwgUmVhZGVyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJXIgKilcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCd4IC0+ICdhLCAnYiwgJ2MsICgnYiAtPiAneCkgLT4gJ2QsICdlLCAnZikgZm10XG4gIHwgU2Nhbl9jaGFyX3NldCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJVsuLi5dICopXG4gICAgICBwYWRfb3B0aW9uICogY2hhcl9zZXQgKiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgIChzdHJpbmcgLT4gJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgU2Nhbl9nZXRfY291bnRlciA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJVtubE5MXSAqKVxuICAgICAgY291bnRlciAqICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKGludCAtPiAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBTY2FuX25leHRfY2hhciA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlMGMgKilcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgIChjaGFyIC0+ICdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IElnbm9yZWRfcGFyYW0gOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICd5LCAneCkgaWdub3JlZCAqICgneCwgJ2IsICdjLCAneSwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuXG4gICgqIEN1c3RvbSBwcmludGluZyBmb3JtYXQgKFBSIzY0NTIsIEdQUiMxNDApXG5cbiAgICAgV2UgaW5jbHVkZSBhIHR5cGUgQ3VzdG9tIG9mIFwiY3VzdG9tIGNvbnZlcnRlcnNcIiwgd2hlcmUgYW5cbiAgICAgYXJiaXRyYXJ5IGZ1bmN0aW9uIGNhbiBiZSB1c2VkIHRvIGNvbnZlcnQgb25lIG9yIG1vcmVcbiAgICAgYXJndW1lbnRzLiBUaGVyZSBpcyBubyBzeW50YXggZm9yIGN1c3RvbSBjb252ZXJ0ZXJzLCBpdCBpcyBvbmx5XG4gICAgIGludGVuZGVkIGZvciBjdXN0b20gcHJvY2Vzc29ycyB0aGF0IHdpc2ggdG8gcmVseSBvbiB0aGVcbiAgICAgc3RkbGliLWRlZmluZWQgZm9ybWF0IEdBRFRzLlxuXG4gICAgIEZvciBpbnN0YW5jZSBhIHByZS1wcm9jZXNzb3IgY291bGQgY2hvb3NlIHRvIGludGVycHJldCBzdHJpbmdzXG4gICAgIHByZWZpeGVkIHdpdGggW1wiIVwiXSBhcyBmb3JtYXQgc3RyaW5ncyB3aGVyZSBbJXt7IC4uLiB9fV0gaXNcbiAgICAgYSBzcGVjaWFsIGZvcm0gdG8gcGFzcyBhIHRvX3N0cmluZyBmdW5jdGlvbiwgc28gdGhhdCBvbmUgY291bGRcbiAgICAgd3JpdGU6XG5cbiAgICAge1tcbiAgICAgICB0eXBlIHQgPSB7IHggOiBpbnQ7IHkgOiBpbnQgfVxuXG4gICAgICAgbGV0IHN0cmluZ19vZl90IHQgPSBQcmludGYuc3ByaW50ZiBcInsgeCA9ICVkOyB5ID0gJWQgfVwiIHQueCB0LnlcblxuICAgICAgIFByaW50Zi5wcmludGYgIVwidCA9ICV7e3N0cmluZ19vZl90fX1cIiB7IHggPSA0MjsgeSA9IDQyIH1cbiAgICAgXX1cbiAgKilcbiAgfCBDdXN0b20gOlxuICAgICAgKCdhLCAneCwgJ3kpIGN1c3RvbV9hcml0eSAqICh1bml0IC0+ICd4KSAqICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICgneSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcblxuICAoKiBlbmQgb2YgYSBmb3JtYXQgc3BlY2lmaWNhdGlvbiAqKVxuICB8IEVuZF9vZl9mb3JtYXQgOlxuICAgICAgICAoJ2YsICdiLCAnYywgJ2UsICdlLCAnZikgZm10XG5cbigqKiopXG5cbigqIFR5cGUgZm9yIGlnbm9yZWQgcGFyYW1ldGVycyAoc2VlIFwiJV9cIikuICopXG5hbmQgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGlnbm9yZWQgPVxuICB8IElnbm9yZWRfY2hhciA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfYyAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX2NhbWxfY2hhciA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX0MgKilcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9zdHJpbmcgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9zICopXG4gICAgICBwYWRfb3B0aW9uIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9jYW1sX3N0cmluZyA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9TICopXG4gICAgICBwYWRfb3B0aW9uIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9pbnQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9kICopXG4gICAgICBpbnRfY29udiAqIHBhZF9vcHRpb24gLT4gKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX2ludDMyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX2xkICopXG4gICAgICBpbnRfY29udiAqIHBhZF9vcHRpb24gLT4gKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX25hdGl2ZWludCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX25kICopXG4gICAgICBpbnRfY29udiAqIHBhZF9vcHRpb24gLT4gKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX2ludDY0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX0xkICopXG4gICAgICBpbnRfY29udiAqIHBhZF9vcHRpb24gLT4gKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX2Zsb2F0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX2YgKilcbiAgICAgIHBhZF9vcHRpb24gKiBwcmVjX29wdGlvbiAtPiAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfYm9vbCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfQiAqKVxuICAgICAgcGFkX29wdGlvbiAtPiAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfZm9ybWF0X2FyZyA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfey4uLiV9ICopXG4gICAgICBwYWRfb3B0aW9uICogKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZtdHR5IC0+XG4gICAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9mb3JtYXRfc3Vic3QgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV8oLi4uJSkgKilcbiAgICAgIHBhZF9vcHRpb24gKiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHkgLT5cbiAgICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX3JlYWRlciA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX3IgKilcbiAgICAgICgnYSwgJ2IsICdjLCAoJ2IgLT4gJ3gpIC0+ICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX3NjYW5fY2hhcl9zZXQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX1suLi5dICopXG4gICAgICBwYWRfb3B0aW9uICogY2hhcl9zZXQgLT4gKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX3NjYW5fZ2V0X2NvdW50ZXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX1tubE5MXSAqKVxuICAgICAgY291bnRlciAtPiAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfc2Nhbl9uZXh0X2NoYXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfMGMgKilcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG5cbmFuZCAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiA9XG4gIEZvcm1hdCBvZiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10ICogc3RyaW5nXG5cbmxldCByZWMgZXJhc2VfcmVsIDogdHlwZSBhIGIgYyBkIGUgZiBnIGggaSBqIGsgbCAuXG4gIChhLCBiLCBjLCBkLCBlLCBmLFxuICAgZywgaCwgaSwgaiwgaywgbCkgZm10dHlfcmVsIC0+IChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eVxuPSBmdW5jdGlvblxuICB8IENoYXJfdHkgcmVzdCAtPlxuICAgIENoYXJfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IFN0cmluZ190eSByZXN0IC0+XG4gICAgU3RyaW5nX3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBJbnRfdHkgcmVzdCAtPlxuICAgIEludF90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgSW50MzJfdHkgcmVzdCAtPlxuICAgIEludDMyX3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBJbnQ2NF90eSByZXN0IC0+XG4gICAgSW50NjRfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IE5hdGl2ZWludF90eSByZXN0IC0+XG4gICAgTmF0aXZlaW50X3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBGbG9hdF90eSByZXN0IC0+XG4gICAgRmxvYXRfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IEJvb2xfdHkgcmVzdCAtPlxuICAgIEJvb2xfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IEZvcm1hdF9hcmdfdHkgKHR5LCByZXN0KSAtPlxuICAgIEZvcm1hdF9hcmdfdHkgKHR5LCBlcmFzZV9yZWwgcmVzdClcbiAgfCBGb3JtYXRfc3Vic3RfdHkgKHR5MSwgX3R5MiwgcmVzdCkgLT5cbiAgICBGb3JtYXRfc3Vic3RfdHkgKHR5MSwgdHkxLCBlcmFzZV9yZWwgcmVzdClcbiAgfCBBbHBoYV90eSByZXN0IC0+XG4gICAgQWxwaGFfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IFRoZXRhX3R5IHJlc3QgLT5cbiAgICBUaGV0YV90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgQW55X3R5IHJlc3QgLT5cbiAgICBBbnlfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IFJlYWRlcl90eSByZXN0IC0+XG4gICAgUmVhZGVyX3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBJZ25vcmVkX3JlYWRlcl90eSByZXN0IC0+XG4gICAgSWdub3JlZF9yZWFkZXJfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IEVuZF9vZl9mbXR0eSAtPiBFbmRfb2ZfZm10dHlcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAoKiBGb3JtYXQgdHlwZSBjb25jYXRlbmF0aW9uICopXG5cbigqIENvbmNhdGVuYXRlIHR3byBmb3JtYXQgdHlwZXMuICopXG4oKiBVc2VkIGJ5OlxuICAgKiByZWFkZXJfbmJfdW5pZmllcl9vZl9mbXR0eSB0byBjb3VudCByZWFkZXJzIGluIGFuIGZtdHR5LFxuICAgKiBTY2FuZi50YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIHRvIGV4dHJhY3QgcmVhZGVycyBpbnNpZGUgJSguLi4lKSxcbiAgICogQ2FtbGludGVybmFsRm9ybWF0LmZtdHR5X29mX2lnbm9yZWRfZm9ybWF0IHRvIGV4dHJhY3QgZm9ybWF0IHR5cGUuICopXG5cbigqXG5sZXQgcmVjIGNvbmNhdF9mbXR0eSA6IHR5cGUgYSBiIGMgZCBlIGYgZyBoIC5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10dHkgLT5cbiAgICAoZiwgYiwgYywgZSwgZywgaCkgZm10dHkgLT5cbiAgICAoYSwgYiwgYywgZCwgZywgaCkgZm10dHkgPVxuKilcbmxldCByZWMgY29uY2F0X2ZtdHR5IDpcbiAgdHlwZSBhMSBiMSBjMSBkMSBlMSBmMVxuICAgICAgIGEyIGIyIGMyIGQyIGUyIGYyXG4gICAgICAgZzEgajEgZzIgajJcbiAgLlxuICAgIChnMSwgYjEsIGMxLCBqMSwgZDEsIGExLFxuICAgICBnMiwgYjIsIGMyLCBqMiwgZDIsIGEyKSBmbXR0eV9yZWwgLT5cbiAgICAoYTEsIGIxLCBjMSwgZDEsIGUxLCBmMSxcbiAgICAgYTIsIGIyLCBjMiwgZDIsIGUyLCBmMikgZm10dHlfcmVsIC0+XG4gICAgKGcxLCBiMSwgYzEsIGoxLCBlMSwgZjEsXG4gICAgIGcyLCBiMiwgYzIsIGoyLCBlMiwgZjIpIGZtdHR5X3JlbCA9XG5mdW4gZm10dHkxIGZtdHR5MiAtPiBtYXRjaCBmbXR0eTEgd2l0aFxuICB8IENoYXJfdHkgcmVzdCAtPlxuICAgIENoYXJfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBTdHJpbmdfdHkgcmVzdCAtPlxuICAgIFN0cmluZ190eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IEludF90eSByZXN0IC0+XG4gICAgSW50X3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgSW50MzJfdHkgcmVzdCAtPlxuICAgIEludDMyX3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgTmF0aXZlaW50X3R5IHJlc3QgLT5cbiAgICBOYXRpdmVpbnRfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBJbnQ2NF90eSByZXN0IC0+XG4gICAgSW50NjRfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBGbG9hdF90eSByZXN0IC0+XG4gICAgRmxvYXRfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBCb29sX3R5IHJlc3QgLT5cbiAgICBCb29sX3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgQWxwaGFfdHkgcmVzdCAtPlxuICAgIEFscGhhX3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgVGhldGFfdHkgcmVzdCAtPlxuICAgIFRoZXRhX3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgQW55X3R5IHJlc3QgLT5cbiAgICBBbnlfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBSZWFkZXJfdHkgcmVzdCAtPlxuICAgIFJlYWRlcl90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IElnbm9yZWRfcmVhZGVyX3R5IHJlc3QgLT5cbiAgICBJZ25vcmVkX3JlYWRlcl90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IEZvcm1hdF9hcmdfdHkgKHR5LCByZXN0KSAtPlxuICAgIEZvcm1hdF9hcmdfdHkgKHR5LCBjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgRm9ybWF0X3N1YnN0X3R5ICh0eTEsIHR5MiwgcmVzdCkgLT5cbiAgICBGb3JtYXRfc3Vic3RfdHkgKHR5MSwgdHkyLCBjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgRW5kX29mX2ZtdHR5IC0+IGZtdHR5MlxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogRm9ybWF0IGNvbmNhdGVuYXRpb24gKilcblxuKCogQ29uY2F0ZW5hdGUgdHdvIGZvcm1hdHMuICopXG5sZXQgcmVjIGNvbmNhdF9mbXQgOiB0eXBlIGEgYiBjIGQgZSBmIGcgaCAuXG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPlxuICAgIChmLCBiLCBjLCBlLCBnLCBoKSBmbXQgLT5cbiAgICAoYSwgYiwgYywgZCwgZywgaCkgZm10ID1cbmZ1biBmbXQxIGZtdDIgLT4gbWF0Y2ggZm10MSB3aXRoXG4gIHwgU3RyaW5nIChwYWQsIHJlc3QpIC0+XG4gICAgU3RyaW5nIChwYWQsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IENhbWxfc3RyaW5nIChwYWQsIHJlc3QpIC0+XG4gICAgQ2FtbF9zdHJpbmcgKHBhZCwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG5cbiAgfCBJbnQgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgSW50IChpY29udiwgcGFkLCBwcmVjLCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBJbnQzMiAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBJbnQzMiAoaWNvbnYsIHBhZCwgcHJlYywgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgTmF0aXZlaW50IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIE5hdGl2ZWludCAoaWNvbnYsIHBhZCwgcHJlYywgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgSW50NjQgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgSW50NjQgKGljb252LCBwYWQsIHByZWMsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IEZsb2F0IChmY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIEZsb2F0IChmY29udiwgcGFkLCBwcmVjLCBjb25jYXRfZm10IHJlc3QgZm10MilcblxuICB8IENoYXIgKHJlc3QpIC0+XG4gICAgQ2hhciAoY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgQ2FtbF9jaGFyIHJlc3QgLT5cbiAgICBDYW1sX2NoYXIgKGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IEJvb2wgKHBhZCwgcmVzdCkgLT5cbiAgICBCb29sIChwYWQsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IEFscGhhIHJlc3QgLT5cbiAgICBBbHBoYSAoY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgVGhldGEgcmVzdCAtPlxuICAgIFRoZXRhIChjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBDdXN0b20gKGFyaXR5LCBmLCByZXN0KSAtPlxuICAgIEN1c3RvbSAoYXJpdHksIGYsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IFJlYWRlciByZXN0IC0+XG4gICAgUmVhZGVyIChjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBGbHVzaCByZXN0IC0+XG4gICAgRmx1c2ggKGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuXG4gIHwgU3RyaW5nX2xpdGVyYWwgKHN0ciwgcmVzdCkgLT5cbiAgICBTdHJpbmdfbGl0ZXJhbCAoc3RyLCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBDaGFyX2xpdGVyYWwgKGNociwgcmVzdCkgLT5cbiAgICBDaGFyX2xpdGVyYWwgICAoY2hyLCBjb25jYXRfZm10IHJlc3QgZm10MilcblxuICB8IEZvcm1hdF9hcmcgKHBhZCwgZm10dHksIHJlc3QpIC0+XG4gICAgRm9ybWF0X2FyZyAgIChwYWQsIGZtdHR5LCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBGb3JtYXRfc3Vic3QgKHBhZCwgZm10dHksIHJlc3QpIC0+XG4gICAgRm9ybWF0X3N1YnN0IChwYWQsIGZtdHR5LCBjb25jYXRfZm10IHJlc3QgZm10MilcblxuICB8IFNjYW5fY2hhcl9zZXQgKHdpZHRoX29wdCwgY2hhcl9zZXQsIHJlc3QpIC0+XG4gICAgU2Nhbl9jaGFyX3NldCAod2lkdGhfb3B0LCBjaGFyX3NldCwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgU2Nhbl9nZXRfY291bnRlciAoY291bnRlciwgcmVzdCkgLT5cbiAgICBTY2FuX2dldF9jb3VudGVyIChjb3VudGVyLCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBTY2FuX25leHRfY2hhciAocmVzdCkgLT5cbiAgICBTY2FuX25leHRfY2hhciAoY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgSWdub3JlZF9wYXJhbSAoaWduLCByZXN0KSAtPlxuICAgIElnbm9yZWRfcGFyYW0gKGlnbiwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG5cbiAgfCBGb3JtYXR0aW5nX2xpdCAoZm10aW5nX2xpdCwgcmVzdCkgLT5cbiAgICBGb3JtYXR0aW5nX2xpdCAoZm10aW5nX2xpdCwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgRm9ybWF0dGluZ19nZW4gKGZtdGluZ19nZW4sIHJlc3QpIC0+XG4gICAgRm9ybWF0dGluZ19nZW4gKGZtdGluZ19nZW4sIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuXG4gIHwgRW5kX29mX2Zvcm1hdCAtPlxuICAgIGZtdDJcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIEdhYnJpZWwgU2NoZXJlciwgcHJvamV0IFBhcnRvdXQsIElOUklBIFBhcmlzLVNhY2xheSAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMjAgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogQ2FtbGludGVybmFsQXRvbWljIGlzIGEgZGVwZW5kZW5jeSBvZiBTdGRsaWIsIHNvIGl0IGlzIGNvbXBpbGVkIHdpdGhcbiAgIC1ub3BlcnZhc2l2ZXMuICopXG5leHRlcm5hbCAoID09ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlZXFcIlxuZXh0ZXJuYWwgKCArICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWFkZGludFwiXG5leHRlcm5hbCBpZ25vcmUgOiAnYSAtPiB1bml0ID0gXCIlaWdub3JlXCJcblxuKCogV2UgYXJlIG5vdCByZXVzaW5nICgnYSByZWYpIGRpcmVjdGx5IHRvIG1ha2UgaXQgZWFzaWVyIHRvIHJlYXNvblxuICAgYWJvdXQgYXRvbWljaXR5IGlmIHdlIHdpc2ggdG86IGV2ZW4gaW4gYSBzZXF1ZW50aWFsIGltcGxlbWVudGF0aW9uLFxuICAgc2lnbmFscyBhbmQgb3RoZXIgYXN5bmNocm9ub3VzIGNhbGxiYWNrcyBtaWdodCBicmVhayBhdG9taWNpdHkuICopXG50eXBlICdhIHQgPSB7bXV0YWJsZSB2OiAnYX1cblxubGV0IG1ha2UgdiA9IHt2fVxubGV0IGdldCByID0gci52XG5sZXQgc2V0IHIgdiA9IHIudiA8LSB2XG5cbigqIFRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zIGFyZSBzZXQgdG8gbmV2ZXIgYmUgaW5saW5lZDogRmxhbWJkYSBpc1xuICAgYWxsb3dlZCB0byBtb3ZlIHN1cnJvdW5kaW5nIGNvZGUgaW5zaWRlIHRoZSBjcml0aWNhbCBzZWN0aW9uLFxuICAgaW5jbHVkaW5nIGFsbG9jYXRpb25zLiAqKVxuXG5sZXRbQGlubGluZSBuZXZlcl0gZXhjaGFuZ2UgciB2ID1cbiAgKCogQkVHSU4gQVRPTUlDICopXG4gIGxldCBjdXIgPSByLnYgaW5cbiAgci52IDwtIHY7XG4gICgqIEVORCBBVE9NSUMgKilcbiAgY3VyXG5cbmxldFtAaW5saW5lIG5ldmVyXSBjb21wYXJlX2FuZF9zZXQgciBzZWVuIHYgPVxuICAoKiBCRUdJTiBBVE9NSUMgKilcbiAgbGV0IGN1ciA9IHIudiBpblxuICBpZiBjdXIgPT0gc2VlbiB0aGVuIChcbiAgICByLnYgPC0gdjtcbiAgICAoKiBFTkQgQVRPTUlDICopXG4gICAgdHJ1ZVxuICApIGVsc2VcbiAgICBmYWxzZVxuXG5sZXRbQGlubGluZSBuZXZlcl0gZmV0Y2hfYW5kX2FkZCByIG4gPVxuICAoKiBCRUdJTiBBVE9NSUMgKilcbiAgbGV0IGN1ciA9IHIudiBpblxuICByLnYgPC0gKGN1ciArIG4pO1xuICAoKiBFTkQgQVRPTUlDICopXG4gIGN1clxuXG5sZXQgaW5jciByID0gaWdub3JlIChmZXRjaF9hbmRfYWRkIHIgMSlcbmxldCBkZWNyIHIgPSBpZ25vcmUgKGZldGNoX2FuZF9hZGQgciAoLTEpKVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBFeGNlcHRpb25zICopXG5cbmV4dGVybmFsIHJlZ2lzdGVyX25hbWVkX3ZhbHVlIDogc3RyaW5nIC0+ICdhIC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX3JlZ2lzdGVyX25hbWVkX3ZhbHVlXCJcblxubGV0ICgpID1cbiAgKCogZm9yIHJ1bnRpbWUvZmFpbF9uYXQuYyAqKVxuICByZWdpc3Rlcl9uYW1lZF92YWx1ZSBcIlBlcnZhc2l2ZXMuYXJyYXlfYm91bmRfZXJyb3JcIlxuICAgIChJbnZhbGlkX2FyZ3VtZW50IFwiaW5kZXggb3V0IG9mIGJvdW5kc1wiKVxuXG5leHRlcm5hbCByYWlzZSA6IGV4biAtPiAnYSA9IFwiJXJhaXNlXCJcbmV4dGVybmFsIHJhaXNlX25vdHJhY2UgOiBleG4gLT4gJ2EgPSBcIiVyYWlzZV9ub3RyYWNlXCJcblxubGV0IGZhaWx3aXRoIHMgPSByYWlzZShGYWlsdXJlIHMpXG5sZXQgaW52YWxpZF9hcmcgcyA9IHJhaXNlKEludmFsaWRfYXJndW1lbnQgcylcblxuZXhjZXB0aW9uIEV4aXRcbmV4Y2VwdGlvbiBNYXRjaF9mYWlsdXJlID0gTWF0Y2hfZmFpbHVyZVxuZXhjZXB0aW9uIEFzc2VydF9mYWlsdXJlID0gQXNzZXJ0X2ZhaWx1cmVcbmV4Y2VwdGlvbiBJbnZhbGlkX2FyZ3VtZW50ID0gSW52YWxpZF9hcmd1bWVudFxuZXhjZXB0aW9uIEZhaWx1cmUgPSBGYWlsdXJlXG5leGNlcHRpb24gTm90X2ZvdW5kID0gTm90X2ZvdW5kXG5leGNlcHRpb24gT3V0X29mX21lbW9yeSA9IE91dF9vZl9tZW1vcnlcbmV4Y2VwdGlvbiBTdGFja19vdmVyZmxvdyA9IFN0YWNrX292ZXJmbG93XG5leGNlcHRpb24gU3lzX2Vycm9yID0gU3lzX2Vycm9yXG5leGNlcHRpb24gRW5kX29mX2ZpbGUgPSBFbmRfb2ZfZmlsZVxuZXhjZXB0aW9uIERpdmlzaW9uX2J5X3plcm8gPSBEaXZpc2lvbl9ieV96ZXJvXG5leGNlcHRpb24gU3lzX2Jsb2NrZWRfaW8gPSBTeXNfYmxvY2tlZF9pb1xuZXhjZXB0aW9uIFVuZGVmaW5lZF9yZWN1cnNpdmVfbW9kdWxlID0gVW5kZWZpbmVkX3JlY3Vyc2l2ZV9tb2R1bGVcblxuKCogQ29tcG9zaXRpb24gb3BlcmF0b3JzICopXG5cbmV4dGVybmFsICggfD4gKSA6ICdhIC0+ICgnYSAtPiAnYikgLT4gJ2IgPSBcIiVyZXZhcHBseVwiXG5leHRlcm5hbCAoIEBAICkgOiAoJ2EgLT4gJ2IpIC0+ICdhIC0+ICdiID0gXCIlYXBwbHlcIlxuXG4oKiBEZWJ1Z2dpbmcgKilcblxuZXh0ZXJuYWwgX19MT0NfXyA6IHN0cmluZyA9IFwiJWxvY19MT0NcIlxuZXh0ZXJuYWwgX19GSUxFX18gOiBzdHJpbmcgPSBcIiVsb2NfRklMRVwiXG5leHRlcm5hbCBfX0xJTkVfXyA6IGludCA9IFwiJWxvY19MSU5FXCJcbmV4dGVybmFsIF9fTU9EVUxFX18gOiBzdHJpbmcgPSBcIiVsb2NfTU9EVUxFXCJcbmV4dGVybmFsIF9fUE9TX18gOiBzdHJpbmcgKiBpbnQgKiBpbnQgKiBpbnQgPSBcIiVsb2NfUE9TXCJcbmV4dGVybmFsIF9fRlVOQ1RJT05fXyA6IHN0cmluZyA9IFwiJWxvY19GVU5DVElPTlwiXG5cbmV4dGVybmFsIF9fTE9DX09GX18gOiAnYSAtPiBzdHJpbmcgKiAnYSA9IFwiJWxvY19MT0NcIlxuZXh0ZXJuYWwgX19MSU5FX09GX18gOiAnYSAtPiBpbnQgKiAnYSA9IFwiJWxvY19MSU5FXCJcbmV4dGVybmFsIF9fUE9TX09GX18gOiAnYSAtPiAoc3RyaW5nICogaW50ICogaW50ICogaW50KSAqICdhID0gXCIlbG9jX1BPU1wiXG5cbigqIENvbXBhcmlzb25zICopXG5cbmV4dGVybmFsICggPSApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWVxdWFsXCJcbmV4dGVybmFsICggPD4gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVub3RlcXVhbFwiXG5leHRlcm5hbCAoIDwgKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVsZXNzdGhhblwiXG5leHRlcm5hbCAoID4gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVncmVhdGVydGhhblwiXG5leHRlcm5hbCAoIDw9ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlbGVzc2VxdWFsXCJcbmV4dGVybmFsICggPj0gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVncmVhdGVyZXF1YWxcIlxuZXh0ZXJuYWwgY29tcGFyZSA6ICdhIC0+ICdhIC0+IGludCA9IFwiJWNvbXBhcmVcIlxuXG5sZXQgbWluIHggeSA9IGlmIHggPD0geSB0aGVuIHggZWxzZSB5XG5sZXQgbWF4IHggeSA9IGlmIHggPj0geSB0aGVuIHggZWxzZSB5XG5cbmV4dGVybmFsICggPT0gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVlcVwiXG5leHRlcm5hbCAoICE9ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlbm90ZXFcIlxuXG4oKiBCb29sZWFuIG9wZXJhdGlvbnMgKilcblxuZXh0ZXJuYWwgbm90IDogYm9vbCAtPiBib29sID0gXCIlYm9vbG5vdFwiXG5leHRlcm5hbCAoICYgKSA6IGJvb2wgLT4gYm9vbCAtPiBib29sID0gXCIlc2VxdWFuZFwiXG5leHRlcm5hbCAoICYmICkgOiBib29sIC0+IGJvb2wgLT4gYm9vbCA9IFwiJXNlcXVhbmRcIlxuZXh0ZXJuYWwgKCBvciApIDogYm9vbCAtPiBib29sIC0+IGJvb2wgPSBcIiVzZXF1b3JcIlxuZXh0ZXJuYWwgKCB8fCApIDogYm9vbCAtPiBib29sIC0+IGJvb2wgPSBcIiVzZXF1b3JcIlxuXG4oKiBJbnRlZ2VyIG9wZXJhdGlvbnMgKilcblxuZXh0ZXJuYWwgKCB+LSApIDogaW50IC0+IGludCA9IFwiJW5lZ2ludFwiXG5leHRlcm5hbCAoIH4rICkgOiBpbnQgLT4gaW50ID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgc3VjYyA6IGludCAtPiBpbnQgPSBcIiVzdWNjaW50XCJcbmV4dGVybmFsIHByZWQgOiBpbnQgLT4gaW50ID0gXCIlcHJlZGludFwiXG5leHRlcm5hbCAoICsgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlYWRkaW50XCJcbmV4dGVybmFsICggLSApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVzdWJpbnRcIlxuZXh0ZXJuYWwgKCAqICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJW11bGludFwiXG5leHRlcm5hbCAoIC8gKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlZGl2aW50XCJcbmV4dGVybmFsICggbW9kICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJW1vZGludFwiXG5cbmxldCBhYnMgeCA9IGlmIHggPj0gMCB0aGVuIHggZWxzZSAteFxuXG5leHRlcm5hbCAoIGxhbmQgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlYW5kaW50XCJcbmV4dGVybmFsICggbG9yICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJW9yaW50XCJcbmV4dGVybmFsICggbHhvciApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiV4b3JpbnRcIlxuXG5sZXQgbG5vdCB4ID0geCBseG9yICgtMSlcblxuZXh0ZXJuYWwgKCBsc2wgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlbHNsaW50XCJcbmV4dGVybmFsICggbHNyICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWxzcmludFwiXG5leHRlcm5hbCAoIGFzciApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVhc3JpbnRcIlxuXG5sZXQgbWF4X2ludCA9ICgtMSkgbHNyIDFcbmxldCBtaW5faW50ID0gbWF4X2ludCArIDFcblxuKCogRmxvYXRpbmctcG9pbnQgb3BlcmF0aW9ucyAqKVxuXG5leHRlcm5hbCAoIH4tLiApIDogZmxvYXQgLT4gZmxvYXQgPSBcIiVuZWdmbG9hdFwiXG5leHRlcm5hbCAoIH4rLiApIDogZmxvYXQgLT4gZmxvYXQgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCAoICsuICkgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiJWFkZGZsb2F0XCJcbmV4dGVybmFsICggLS4gKSA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCIlc3ViZmxvYXRcIlxuZXh0ZXJuYWwgKCAqLiApIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcIiVtdWxmbG9hdFwiXG5leHRlcm5hbCAoIC8uICkgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiJWRpdmZsb2F0XCJcbmV4dGVybmFsICggKiogKSA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3Bvd2VyX2Zsb2F0XCIgXCJwb3dcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZXhwIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfZXhwX2Zsb2F0XCIgXCJleHBcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZXhwbTEgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9leHBtMV9mbG9hdFwiIFwiY2FtbF9leHBtMVwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBhY29zIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYWNvc19mbG9hdFwiIFwiYWNvc1wiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBhc2luIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYXNpbl9mbG9hdFwiIFwiYXNpblwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBhdGFuIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYXRhbl9mbG9hdFwiIFwiYXRhblwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBhdGFuMiA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2F0YW4yX2Zsb2F0XCIgXCJhdGFuMlwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBoeXBvdCA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0XG4gICAgICAgICAgICAgICA9IFwiY2FtbF9oeXBvdF9mbG9hdFwiIFwiY2FtbF9oeXBvdFwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBjb3MgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9jb3NfZmxvYXRcIiBcImNvc1wiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBjb3NoIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfY29zaF9mbG9hdFwiIFwiY29zaFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBsb2cgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9sb2dfZmxvYXRcIiBcImxvZ1wiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBsb2cxMCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2xvZzEwX2Zsb2F0XCIgXCJsb2cxMFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBsb2cxcCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2xvZzFwX2Zsb2F0XCIgXCJjYW1sX2xvZzFwXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHNpbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3Npbl9mbG9hdFwiIFwic2luXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHNpbmggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9zaW5oX2Zsb2F0XCIgXCJzaW5oXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHNxcnQgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9zcXJ0X2Zsb2F0XCIgXCJzcXJ0XCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHRhbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3Rhbl9mbG9hdFwiIFwidGFuXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHRhbmggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF90YW5oX2Zsb2F0XCIgXCJ0YW5oXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGNlaWwgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9jZWlsX2Zsb2F0XCIgXCJjZWlsXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGZsb29yIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfZmxvb3JfZmxvYXRcIiBcImZsb29yXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGFic19mbG9hdCA6IGZsb2F0IC0+IGZsb2F0ID0gXCIlYWJzZmxvYXRcIlxuZXh0ZXJuYWwgY29weXNpZ24gOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdFxuICAgICAgICAgICAgICAgICAgPSBcImNhbWxfY29weXNpZ25fZmxvYXRcIiBcImNhbWxfY29weXNpZ25cIlxuICAgICAgICAgICAgICAgICAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIG1vZF9mbG9hdCA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Ztb2RfZmxvYXRcIiBcImZtb2RcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZnJleHAgOiBmbG9hdCAtPiBmbG9hdCAqIGludCA9IFwiY2FtbF9mcmV4cF9mbG9hdFwiXG5leHRlcm5hbCBsZGV4cCA6IChmbG9hdCBbQHVuYm94ZWRdKSAtPiAoaW50IFtAdW50YWdnZWRdKSAtPiAoZmxvYXQgW0B1bmJveGVkXSkgPVxuICBcImNhbWxfbGRleHBfZmxvYXRcIiBcImNhbWxfbGRleHBfZmxvYXRfdW5ib3hlZFwiIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBtb2RmIDogZmxvYXQgLT4gZmxvYXQgKiBmbG9hdCA9IFwiY2FtbF9tb2RmX2Zsb2F0XCJcbmV4dGVybmFsIGZsb2F0IDogaW50IC0+IGZsb2F0ID0gXCIlZmxvYXRvZmludFwiXG5leHRlcm5hbCBmbG9hdF9vZl9pbnQgOiBpbnQgLT4gZmxvYXQgPSBcIiVmbG9hdG9maW50XCJcbmV4dGVybmFsIHRydW5jYXRlIDogZmxvYXQgLT4gaW50ID0gXCIlaW50b2ZmbG9hdFwiXG5leHRlcm5hbCBpbnRfb2ZfZmxvYXQgOiBmbG9hdCAtPiBpbnQgPSBcIiVpbnRvZmZsb2F0XCJcbmV4dGVybmFsIGZsb2F0X29mX2JpdHMgOiBpbnQ2NCAtPiBmbG9hdFxuICA9IFwiY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzXCIgXCJjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHNfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5sZXQgaW5maW5pdHkgPVxuICBmbG9hdF9vZl9iaXRzIDB4N0ZfRjBfMDBfMDBfMDBfMDBfMDBfMDBMXG5sZXQgbmVnX2luZmluaXR5ID1cbiAgZmxvYXRfb2ZfYml0cyAweEZGX0YwXzAwXzAwXzAwXzAwXzAwXzAwTFxubGV0IG5hbiA9XG4gIGZsb2F0X29mX2JpdHMgMHg3Rl9GMF8wMF8wMF8wMF8wMF8wMF8wMUxcbmxldCBtYXhfZmxvYXQgPVxuICBmbG9hdF9vZl9iaXRzIDB4N0ZfRUZfRkZfRkZfRkZfRkZfRkZfRkZMXG5sZXQgbWluX2Zsb2F0ID1cbiAgZmxvYXRfb2ZfYml0cyAweDAwXzEwXzAwXzAwXzAwXzAwXzAwXzAwTFxubGV0IGVwc2lsb25fZmxvYXQgPVxuICBmbG9hdF9vZl9iaXRzIDB4M0NfQjBfMDBfMDBfMDBfMDBfMDBfMDBMXG5cbnR5cGUgZnBjbGFzcyA9XG4gICAgRlBfbm9ybWFsXG4gIHwgRlBfc3Vibm9ybWFsXG4gIHwgRlBfemVyb1xuICB8IEZQX2luZmluaXRlXG4gIHwgRlBfbmFuXG5leHRlcm5hbCBjbGFzc2lmeV9mbG9hdCA6IChmbG9hdCBbQHVuYm94ZWRdKSAtPiBmcGNsYXNzID1cbiAgXCJjYW1sX2NsYXNzaWZ5X2Zsb2F0XCIgXCJjYW1sX2NsYXNzaWZ5X2Zsb2F0X3VuYm94ZWRcIiBbQEBub2FsbG9jXVxuXG4oKiBTdHJpbmcgYW5kIGJ5dGUgc2VxdWVuY2Ugb3BlcmF0aW9ucyAtLSBtb3JlIGluIG1vZHVsZXMgU3RyaW5nIGFuZCBCeXRlcyAqKVxuXG5leHRlcm5hbCBzdHJpbmdfbGVuZ3RoIDogc3RyaW5nIC0+IGludCA9IFwiJXN0cmluZ19sZW5ndGhcIlxuZXh0ZXJuYWwgYnl0ZXNfbGVuZ3RoIDogYnl0ZXMgLT4gaW50ID0gXCIlYnl0ZXNfbGVuZ3RoXCJcbmV4dGVybmFsIGJ5dGVzX2NyZWF0ZSA6IGludCAtPiBieXRlcyA9IFwiY2FtbF9jcmVhdGVfYnl0ZXNcIlxuZXh0ZXJuYWwgc3RyaW5nX2JsaXQgOiBzdHJpbmcgLT4gaW50IC0+IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfYmxpdF9zdHJpbmdcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYnl0ZXNfYmxpdCA6IGJ5dGVzIC0+IGludCAtPiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX2JsaXRfYnl0ZXNcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYnl0ZXNfdW5zYWZlX3RvX3N0cmluZyA6IGJ5dGVzIC0+IHN0cmluZyA9IFwiJWJ5dGVzX3RvX3N0cmluZ1wiXG5cbmxldCAoIF4gKSBzMSBzMiA9XG4gIGxldCBsMSA9IHN0cmluZ19sZW5ndGggczEgYW5kIGwyID0gc3RyaW5nX2xlbmd0aCBzMiBpblxuICBsZXQgcyA9IGJ5dGVzX2NyZWF0ZSAobDEgKyBsMikgaW5cbiAgc3RyaW5nX2JsaXQgczEgMCBzIDAgbDE7XG4gIHN0cmluZ19ibGl0IHMyIDAgcyBsMSBsMjtcbiAgYnl0ZXNfdW5zYWZlX3RvX3N0cmluZyBzXG5cbigqIENoYXJhY3RlciBvcGVyYXRpb25zIC0tIG1vcmUgaW4gbW9kdWxlIENoYXIgKilcblxuZXh0ZXJuYWwgaW50X29mX2NoYXIgOiBjaGFyIC0+IGludCA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIHVuc2FmZV9jaGFyX29mX2ludCA6IGludCAtPiBjaGFyID0gXCIlaWRlbnRpdHlcIlxubGV0IGNoYXJfb2ZfaW50IG4gPVxuICBpZiBuIDwgMCB8fCBuID4gMjU1IHRoZW4gaW52YWxpZF9hcmcgXCJjaGFyX29mX2ludFwiIGVsc2UgdW5zYWZlX2NoYXJfb2ZfaW50IG5cblxuKCogVW5pdCBvcGVyYXRpb25zICopXG5cbmV4dGVybmFsIGlnbm9yZSA6ICdhIC0+IHVuaXQgPSBcIiVpZ25vcmVcIlxuXG4oKiBQYWlyIG9wZXJhdGlvbnMgKilcblxuZXh0ZXJuYWwgZnN0IDogJ2EgKiAnYiAtPiAnYSA9IFwiJWZpZWxkMFwiXG5leHRlcm5hbCBzbmQgOiAnYSAqICdiIC0+ICdiID0gXCIlZmllbGQxXCJcblxuKCogUmVmZXJlbmNlcyAqKVxuXG50eXBlICdhIHJlZiA9IHsgbXV0YWJsZSBjb250ZW50cyA6ICdhIH1cbmV4dGVybmFsIHJlZiA6ICdhIC0+ICdhIHJlZiA9IFwiJW1ha2VtdXRhYmxlXCJcbmV4dGVybmFsICggISApIDogJ2EgcmVmIC0+ICdhID0gXCIlZmllbGQwXCJcbmV4dGVybmFsICggOj0gKSA6ICdhIHJlZiAtPiAnYSAtPiB1bml0ID0gXCIlc2V0ZmllbGQwXCJcbmV4dGVybmFsIGluY3IgOiBpbnQgcmVmIC0+IHVuaXQgPSBcIiVpbmNyXCJcbmV4dGVybmFsIGRlY3IgOiBpbnQgcmVmIC0+IHVuaXQgPSBcIiVkZWNyXCJcblxuKCogUmVzdWx0IHR5cGUgKilcblxudHlwZSAoJ2EsJ2IpIHJlc3VsdCA9IE9rIG9mICdhIHwgRXJyb3Igb2YgJ2JcblxuKCogU3RyaW5nIGNvbnZlcnNpb24gZnVuY3Rpb25zICopXG5cbmV4dGVybmFsIGZvcm1hdF9pbnQgOiBzdHJpbmcgLT4gaW50IC0+IHN0cmluZyA9IFwiY2FtbF9mb3JtYXRfaW50XCJcbmV4dGVybmFsIGZvcm1hdF9mbG9hdCA6IHN0cmluZyAtPiBmbG9hdCAtPiBzdHJpbmcgPSBcImNhbWxfZm9ybWF0X2Zsb2F0XCJcblxubGV0IHN0cmluZ19vZl9ib29sIGIgPVxuICBpZiBiIHRoZW4gXCJ0cnVlXCIgZWxzZSBcImZhbHNlXCJcbmxldCBib29sX29mX3N0cmluZyA9IGZ1bmN0aW9uXG4gIHwgXCJ0cnVlXCIgLT4gdHJ1ZVxuICB8IFwiZmFsc2VcIiAtPiBmYWxzZVxuICB8IF8gLT4gaW52YWxpZF9hcmcgXCJib29sX29mX3N0cmluZ1wiXG5cbmxldCBib29sX29mX3N0cmluZ19vcHQgPSBmdW5jdGlvblxuICB8IFwidHJ1ZVwiIC0+IFNvbWUgdHJ1ZVxuICB8IFwiZmFsc2VcIiAtPiBTb21lIGZhbHNlXG4gIHwgXyAtPiBOb25lXG5cbmxldCBzdHJpbmdfb2ZfaW50IG4gPVxuICBmb3JtYXRfaW50IFwiJWRcIiBuXG5cbmV4dGVybmFsIGludF9vZl9zdHJpbmcgOiBzdHJpbmcgLT4gaW50ID0gXCJjYW1sX2ludF9vZl9zdHJpbmdcIlxuXG5sZXQgaW50X29mX3N0cmluZ19vcHQgcyA9XG4gICgqIFRPRE86IHByb3ZpZGUgdGhpcyBkaXJlY3RseSBhcyBhIG5vbi1yYWlzaW5nIHByaW1pdGl2ZS4gKilcbiAgdHJ5IFNvbWUgKGludF9vZl9zdHJpbmcgcylcbiAgd2l0aCBGYWlsdXJlIF8gLT4gTm9uZVxuXG5leHRlcm5hbCBzdHJpbmdfZ2V0IDogc3RyaW5nIC0+IGludCAtPiBjaGFyID0gXCIlc3RyaW5nX3NhZmVfZ2V0XCJcblxubGV0IHZhbGlkX2Zsb2F0X2xleGVtIHMgPVxuICBsZXQgbCA9IHN0cmluZ19sZW5ndGggcyBpblxuICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgaWYgaSA+PSBsIHRoZW4gcyBeIFwiLlwiIGVsc2VcbiAgICBtYXRjaCBzdHJpbmdfZ2V0IHMgaSB3aXRoXG4gICAgfCAnMCcgLi4gJzknIHwgJy0nIC0+IGxvb3AgKGkgKyAxKVxuICAgIHwgXyAtPiBzXG4gIGluXG4gIGxvb3AgMFxuXG5sZXQgc3RyaW5nX29mX2Zsb2F0IGYgPSB2YWxpZF9mbG9hdF9sZXhlbSAoZm9ybWF0X2Zsb2F0IFwiJS4xMmdcIiBmKVxuXG5leHRlcm5hbCBmbG9hdF9vZl9zdHJpbmcgOiBzdHJpbmcgLT4gZmxvYXQgPSBcImNhbWxfZmxvYXRfb2Zfc3RyaW5nXCJcblxubGV0IGZsb2F0X29mX3N0cmluZ19vcHQgcyA9XG4gICgqIFRPRE86IHByb3ZpZGUgdGhpcyBkaXJlY3RseSBhcyBhIG5vbi1yYWlzaW5nIHByaW1pdGl2ZS4gKilcbiAgdHJ5IFNvbWUgKGZsb2F0X29mX3N0cmluZyBzKVxuICB3aXRoIEZhaWx1cmUgXyAtPiBOb25lXG5cbigqIExpc3Qgb3BlcmF0aW9ucyAtLSBtb3JlIGluIG1vZHVsZSBMaXN0ICopXG5cbmxldCByZWMgKCBAICkgbDEgbDIgPVxuICBtYXRjaCBsMSB3aXRoXG4gICAgW10gLT4gbDJcbiAgfCBoZCA6OiB0bCAtPiBoZCA6OiAodGwgQCBsMilcblxuKCogSS9PIG9wZXJhdGlvbnMgKilcblxudHlwZSBpbl9jaGFubmVsXG50eXBlIG91dF9jaGFubmVsXG5cbmV4dGVybmFsIG9wZW5fZGVzY3JpcHRvcl9vdXQgOiBpbnQgLT4gb3V0X2NoYW5uZWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX291dFwiXG5leHRlcm5hbCBvcGVuX2Rlc2NyaXB0b3JfaW4gOiBpbnQgLT4gaW5fY2hhbm5lbCA9IFwiY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3JfaW5cIlxuXG5sZXQgc3RkaW4gPSBvcGVuX2Rlc2NyaXB0b3JfaW4gMFxubGV0IHN0ZG91dCA9IG9wZW5fZGVzY3JpcHRvcl9vdXQgMVxubGV0IHN0ZGVyciA9IG9wZW5fZGVzY3JpcHRvcl9vdXQgMlxuXG4oKiBHZW5lcmFsIG91dHB1dCBmdW5jdGlvbnMgKilcblxudHlwZSBvcGVuX2ZsYWcgPVxuICAgIE9wZW5fcmRvbmx5IHwgT3Blbl93cm9ubHkgfCBPcGVuX2FwcGVuZFxuICB8IE9wZW5fY3JlYXQgfCBPcGVuX3RydW5jIHwgT3Blbl9leGNsXG4gIHwgT3Blbl9iaW5hcnkgfCBPcGVuX3RleHQgfCBPcGVuX25vbmJsb2NrXG5cbmV4dGVybmFsIG9wZW5fZGVzYyA6IHN0cmluZyAtPiBvcGVuX2ZsYWcgbGlzdCAtPiBpbnQgLT4gaW50ID0gXCJjYW1sX3N5c19vcGVuXCJcblxuZXh0ZXJuYWwgc2V0X291dF9jaGFubmVsX25hbWU6IG91dF9jaGFubmVsIC0+IHN0cmluZyAtPiB1bml0ID1cbiAgXCJjYW1sX21sX3NldF9jaGFubmVsX25hbWVcIlxuXG5sZXQgb3Blbl9vdXRfZ2VuIG1vZGUgcGVybSBuYW1lID1cbiAgbGV0IGMgPSBvcGVuX2Rlc2NyaXB0b3Jfb3V0KG9wZW5fZGVzYyBuYW1lIG1vZGUgcGVybSkgaW5cbiAgc2V0X291dF9jaGFubmVsX25hbWUgYyBuYW1lO1xuICBjXG5cbmxldCBvcGVuX291dCBuYW1lID1cbiAgb3Blbl9vdXRfZ2VuIFtPcGVuX3dyb25seTsgT3Blbl9jcmVhdDsgT3Blbl90cnVuYzsgT3Blbl90ZXh0XSAwbzY2NiBuYW1lXG5cbmxldCBvcGVuX291dF9iaW4gbmFtZSA9XG4gIG9wZW5fb3V0X2dlbiBbT3Blbl93cm9ubHk7IE9wZW5fY3JlYXQ7IE9wZW5fdHJ1bmM7IE9wZW5fYmluYXJ5XSAwbzY2NiBuYW1lXG5cbmV4dGVybmFsIGZsdXNoIDogb3V0X2NoYW5uZWwgLT4gdW5pdCA9IFwiY2FtbF9tbF9mbHVzaFwiXG5cbmV4dGVybmFsIG91dF9jaGFubmVsc19saXN0IDogdW5pdCAtPiBvdXRfY2hhbm5lbCBsaXN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9tbF9vdXRfY2hhbm5lbHNfbGlzdFwiXG5cbmxldCBmbHVzaF9hbGwgKCkgPVxuICBsZXQgcmVjIGl0ZXIgPSBmdW5jdGlvblxuICAgICAgW10gLT4gKClcbiAgICB8IGE6OmwgLT5cbiAgICAgICAgYmVnaW4gdHJ5XG4gICAgICAgICAgICBmbHVzaCBhXG4gICAgICAgIHdpdGggU3lzX2Vycm9yIF8gLT5cbiAgICAgICAgICAoKSAoKiBpZ25vcmUgY2hhbm5lbHMgY2xvc2VkIGR1cmluZyBhIHByZWNlZGluZyBmbHVzaC4gKilcbiAgICAgICAgZW5kO1xuICAgICAgICBpdGVyIGxcbiAgaW4gaXRlciAob3V0X2NoYW5uZWxzX2xpc3QgKCkpXG5cbmV4dGVybmFsIHVuc2FmZV9vdXRwdXQgOiBvdXRfY2hhbm5lbCAtPiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfbWxfb3V0cHV0X2J5dGVzXCJcbmV4dGVybmFsIHVuc2FmZV9vdXRwdXRfc3RyaW5nIDogb3V0X2NoYW5uZWwgLT4gc3RyaW5nIC0+IGludCAtPiBpbnQgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfbWxfb3V0cHV0XCJcblxuZXh0ZXJuYWwgb3V0cHV0X2NoYXIgOiBvdXRfY2hhbm5lbCAtPiBjaGFyIC0+IHVuaXQgPSBcImNhbWxfbWxfb3V0cHV0X2NoYXJcIlxuXG5sZXQgb3V0cHV0X2J5dGVzIG9jIHMgPVxuICB1bnNhZmVfb3V0cHV0IG9jIHMgMCAoYnl0ZXNfbGVuZ3RoIHMpXG5cbmxldCBvdXRwdXRfc3RyaW5nIG9jIHMgPVxuICB1bnNhZmVfb3V0cHV0X3N0cmluZyBvYyBzIDAgKHN0cmluZ19sZW5ndGggcylcblxubGV0IG91dHB1dCBvYyBzIG9mcyBsZW4gPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gYnl0ZXNfbGVuZ3RoIHMgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIm91dHB1dFwiXG4gIGVsc2UgdW5zYWZlX291dHB1dCBvYyBzIG9mcyBsZW5cblxubGV0IG91dHB1dF9zdWJzdHJpbmcgb2MgcyBvZnMgbGVuID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IHN0cmluZ19sZW5ndGggcyAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwib3V0cHV0X3N1YnN0cmluZ1wiXG4gIGVsc2UgdW5zYWZlX291dHB1dF9zdHJpbmcgb2MgcyBvZnMgbGVuXG5cbmV4dGVybmFsIG91dHB1dF9ieXRlIDogb3V0X2NoYW5uZWwgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfbWxfb3V0cHV0X2NoYXJcIlxuZXh0ZXJuYWwgb3V0cHV0X2JpbmFyeV9pbnQgOiBvdXRfY2hhbm5lbCAtPiBpbnQgLT4gdW5pdCA9IFwiY2FtbF9tbF9vdXRwdXRfaW50XCJcblxuZXh0ZXJuYWwgbWFyc2hhbF90b19jaGFubmVsIDogb3V0X2NoYW5uZWwgLT4gJ2EgLT4gdW5pdCBsaXN0IC0+IHVuaXRcbiAgICAgPSBcImNhbWxfb3V0cHV0X3ZhbHVlXCJcbmxldCBvdXRwdXRfdmFsdWUgY2hhbiB2ID0gbWFyc2hhbF90b19jaGFubmVsIGNoYW4gdiBbXVxuXG5leHRlcm5hbCBzZWVrX291dCA6IG91dF9jaGFubmVsIC0+IGludCAtPiB1bml0ID0gXCJjYW1sX21sX3NlZWtfb3V0XCJcbmV4dGVybmFsIHBvc19vdXQgOiBvdXRfY2hhbm5lbCAtPiBpbnQgPSBcImNhbWxfbWxfcG9zX291dFwiXG5leHRlcm5hbCBvdXRfY2hhbm5lbF9sZW5ndGggOiBvdXRfY2hhbm5lbCAtPiBpbnQgPSBcImNhbWxfbWxfY2hhbm5lbF9zaXplXCJcbmV4dGVybmFsIGNsb3NlX291dF9jaGFubmVsIDogb3V0X2NoYW5uZWwgLT4gdW5pdCA9IFwiY2FtbF9tbF9jbG9zZV9jaGFubmVsXCJcbmxldCBjbG9zZV9vdXQgb2MgPSBmbHVzaCBvYzsgY2xvc2Vfb3V0X2NoYW5uZWwgb2NcbmxldCBjbG9zZV9vdXRfbm9lcnIgb2MgPVxuICAodHJ5IGZsdXNoIG9jIHdpdGggXyAtPiAoKSk7XG4gICh0cnkgY2xvc2Vfb3V0X2NoYW5uZWwgb2Mgd2l0aCBfIC0+ICgpKVxuZXh0ZXJuYWwgc2V0X2JpbmFyeV9tb2RlX291dCA6IG91dF9jaGFubmVsIC0+IGJvb2wgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9tbF9zZXRfYmluYXJ5X21vZGVcIlxuXG4oKiBHZW5lcmFsIGlucHV0IGZ1bmN0aW9ucyAqKVxuXG5leHRlcm5hbCBzZXRfaW5fY2hhbm5lbF9uYW1lOiBpbl9jaGFubmVsIC0+IHN0cmluZyAtPiB1bml0ID1cbiAgXCJjYW1sX21sX3NldF9jaGFubmVsX25hbWVcIlxuXG5sZXQgb3Blbl9pbl9nZW4gbW9kZSBwZXJtIG5hbWUgPVxuICBsZXQgYyA9IG9wZW5fZGVzY3JpcHRvcl9pbihvcGVuX2Rlc2MgbmFtZSBtb2RlIHBlcm0pIGluXG4gIHNldF9pbl9jaGFubmVsX25hbWUgYyBuYW1lO1xuICBjXG5cbmxldCBvcGVuX2luIG5hbWUgPVxuICBvcGVuX2luX2dlbiBbT3Blbl9yZG9ubHk7IE9wZW5fdGV4dF0gMCBuYW1lXG5cbmxldCBvcGVuX2luX2JpbiBuYW1lID1cbiAgb3Blbl9pbl9nZW4gW09wZW5fcmRvbmx5OyBPcGVuX2JpbmFyeV0gMCBuYW1lXG5cbmV4dGVybmFsIGlucHV0X2NoYXIgOiBpbl9jaGFubmVsIC0+IGNoYXIgPSBcImNhbWxfbWxfaW5wdXRfY2hhclwiXG5cbmV4dGVybmFsIHVuc2FmZV9pbnB1dCA6IGluX2NoYW5uZWwgLT4gYnl0ZXMgLT4gaW50IC0+IGludCAtPiBpbnRcbiAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9tbF9pbnB1dFwiXG5cbmxldCBpbnB1dCBpYyBzIG9mcyBsZW4gPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gYnl0ZXNfbGVuZ3RoIHMgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcImlucHV0XCJcbiAgZWxzZSB1bnNhZmVfaW5wdXQgaWMgcyBvZnMgbGVuXG5cbmxldCByZWMgdW5zYWZlX3JlYWxseV9pbnB1dCBpYyBzIG9mcyBsZW4gPVxuICBpZiBsZW4gPD0gMCB0aGVuICgpIGVsc2UgYmVnaW5cbiAgICBsZXQgciA9IHVuc2FmZV9pbnB1dCBpYyBzIG9mcyBsZW4gaW5cbiAgICBpZiByID0gMFxuICAgIHRoZW4gcmFpc2UgRW5kX29mX2ZpbGVcbiAgICBlbHNlIHVuc2FmZV9yZWFsbHlfaW5wdXQgaWMgcyAob2ZzICsgcikgKGxlbiAtIHIpXG4gIGVuZFxuXG5sZXQgcmVhbGx5X2lucHV0IGljIHMgb2ZzIGxlbiA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBieXRlc19sZW5ndGggcyAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwicmVhbGx5X2lucHV0XCJcbiAgZWxzZSB1bnNhZmVfcmVhbGx5X2lucHV0IGljIHMgb2ZzIGxlblxuXG5sZXQgcmVhbGx5X2lucHV0X3N0cmluZyBpYyBsZW4gPVxuICBsZXQgcyA9IGJ5dGVzX2NyZWF0ZSBsZW4gaW5cbiAgcmVhbGx5X2lucHV0IGljIHMgMCBsZW47XG4gIGJ5dGVzX3Vuc2FmZV90b19zdHJpbmcgc1xuXG5leHRlcm5hbCBpbnB1dF9zY2FuX2xpbmUgOiBpbl9jaGFubmVsIC0+IGludCA9IFwiY2FtbF9tbF9pbnB1dF9zY2FuX2xpbmVcIlxuXG5sZXQgaW5wdXRfbGluZSBjaGFuID1cbiAgbGV0IHJlYyBidWlsZF9yZXN1bHQgYnVmIHBvcyA9IGZ1bmN0aW9uXG4gICAgW10gLT4gYnVmXG4gIHwgaGQgOjogdGwgLT5cbiAgICAgIGxldCBsZW4gPSBieXRlc19sZW5ndGggaGQgaW5cbiAgICAgIGJ5dGVzX2JsaXQgaGQgMCBidWYgKHBvcyAtIGxlbikgbGVuO1xuICAgICAgYnVpbGRfcmVzdWx0IGJ1ZiAocG9zIC0gbGVuKSB0bCBpblxuICBsZXQgcmVjIHNjYW4gYWNjdSBsZW4gPVxuICAgIGxldCBuID0gaW5wdXRfc2Nhbl9saW5lIGNoYW4gaW5cbiAgICBpZiBuID0gMCB0aGVuIGJlZ2luICAgICAgICAgICAgICAgICAgICgqIG4gPSAwOiB3ZSBhcmUgYXQgRU9GICopXG4gICAgICBtYXRjaCBhY2N1IHdpdGhcbiAgICAgICAgW10gLT4gcmFpc2UgRW5kX29mX2ZpbGVcbiAgICAgIHwgXyAgLT4gYnVpbGRfcmVzdWx0IChieXRlc19jcmVhdGUgbGVuKSBsZW4gYWNjdVxuICAgIGVuZCBlbHNlIGlmIG4gPiAwIHRoZW4gYmVnaW4gICAgICAgICAgKCogbiA+IDA6IG5ld2xpbmUgZm91bmQgaW4gYnVmZmVyICopXG4gICAgICBsZXQgcmVzID0gYnl0ZXNfY3JlYXRlIChuIC0gMSkgaW5cbiAgICAgIGlnbm9yZSAodW5zYWZlX2lucHV0IGNoYW4gcmVzIDAgKG4gLSAxKSk7XG4gICAgICBpZ25vcmUgKGlucHV0X2NoYXIgY2hhbik7ICAgICAgICAgICAoKiBza2lwIHRoZSBuZXdsaW5lICopXG4gICAgICBtYXRjaCBhY2N1IHdpdGhcbiAgICAgICAgW10gLT4gcmVzXG4gICAgICB8ICBfIC0+IGxldCBsZW4gPSBsZW4gKyBuIC0gMSBpblxuICAgICAgICAgICAgICBidWlsZF9yZXN1bHQgKGJ5dGVzX2NyZWF0ZSBsZW4pIGxlbiAocmVzIDo6IGFjY3UpXG4gICAgZW5kIGVsc2UgYmVnaW4gICAgICAgICAgICAgICAgICAgICAgICAoKiBuIDwgMDogbmV3bGluZSBub3QgZm91bmQgKilcbiAgICAgIGxldCBiZWcgPSBieXRlc19jcmVhdGUgKC1uKSBpblxuICAgICAgaWdub3JlKHVuc2FmZV9pbnB1dCBjaGFuIGJlZyAwICgtbikpO1xuICAgICAgc2NhbiAoYmVnIDo6IGFjY3UpIChsZW4gLSBuKVxuICAgIGVuZFxuICBpbiBieXRlc191bnNhZmVfdG9fc3RyaW5nIChzY2FuIFtdIDApXG5cbmV4dGVybmFsIGlucHV0X2J5dGUgOiBpbl9jaGFubmVsIC0+IGludCA9IFwiY2FtbF9tbF9pbnB1dF9jaGFyXCJcbmV4dGVybmFsIGlucHV0X2JpbmFyeV9pbnQgOiBpbl9jaGFubmVsIC0+IGludCA9IFwiY2FtbF9tbF9pbnB1dF9pbnRcIlxuZXh0ZXJuYWwgaW5wdXRfdmFsdWUgOiBpbl9jaGFubmVsIC0+ICdhID0gXCJjYW1sX2lucHV0X3ZhbHVlXCJcbmV4dGVybmFsIHNlZWtfaW4gOiBpbl9jaGFubmVsIC0+IGludCAtPiB1bml0ID0gXCJjYW1sX21sX3NlZWtfaW5cIlxuZXh0ZXJuYWwgcG9zX2luIDogaW5fY2hhbm5lbCAtPiBpbnQgPSBcImNhbWxfbWxfcG9zX2luXCJcbmV4dGVybmFsIGluX2NoYW5uZWxfbGVuZ3RoIDogaW5fY2hhbm5lbCAtPiBpbnQgPSBcImNhbWxfbWxfY2hhbm5lbF9zaXplXCJcbmV4dGVybmFsIGNsb3NlX2luIDogaW5fY2hhbm5lbCAtPiB1bml0ID0gXCJjYW1sX21sX2Nsb3NlX2NoYW5uZWxcIlxubGV0IGNsb3NlX2luX25vZXJyIGljID0gKHRyeSBjbG9zZV9pbiBpYyB3aXRoIF8gLT4gKCkpXG5leHRlcm5hbCBzZXRfYmluYXJ5X21vZGVfaW4gOiBpbl9jaGFubmVsIC0+IGJvb2wgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX21sX3NldF9iaW5hcnlfbW9kZVwiXG5cbigqIE91dHB1dCBmdW5jdGlvbnMgb24gc3RhbmRhcmQgb3V0cHV0ICopXG5cbmxldCBwcmludF9jaGFyIGMgPSBvdXRwdXRfY2hhciBzdGRvdXQgY1xubGV0IHByaW50X3N0cmluZyBzID0gb3V0cHV0X3N0cmluZyBzdGRvdXQgc1xubGV0IHByaW50X2J5dGVzIHMgPSBvdXRwdXRfYnl0ZXMgc3Rkb3V0IHNcbmxldCBwcmludF9pbnQgaSA9IG91dHB1dF9zdHJpbmcgc3Rkb3V0IChzdHJpbmdfb2ZfaW50IGkpXG5sZXQgcHJpbnRfZmxvYXQgZiA9IG91dHB1dF9zdHJpbmcgc3Rkb3V0IChzdHJpbmdfb2ZfZmxvYXQgZilcbmxldCBwcmludF9lbmRsaW5lIHMgPVxuICBvdXRwdXRfc3RyaW5nIHN0ZG91dCBzOyBvdXRwdXRfY2hhciBzdGRvdXQgJ1xcbic7IGZsdXNoIHN0ZG91dFxubGV0IHByaW50X25ld2xpbmUgKCkgPSBvdXRwdXRfY2hhciBzdGRvdXQgJ1xcbic7IGZsdXNoIHN0ZG91dFxuXG4oKiBPdXRwdXQgZnVuY3Rpb25zIG9uIHN0YW5kYXJkIGVycm9yICopXG5cbmxldCBwcmVycl9jaGFyIGMgPSBvdXRwdXRfY2hhciBzdGRlcnIgY1xubGV0IHByZXJyX3N0cmluZyBzID0gb3V0cHV0X3N0cmluZyBzdGRlcnIgc1xubGV0IHByZXJyX2J5dGVzIHMgPSBvdXRwdXRfYnl0ZXMgc3RkZXJyIHNcbmxldCBwcmVycl9pbnQgaSA9IG91dHB1dF9zdHJpbmcgc3RkZXJyIChzdHJpbmdfb2ZfaW50IGkpXG5sZXQgcHJlcnJfZmxvYXQgZiA9IG91dHB1dF9zdHJpbmcgc3RkZXJyIChzdHJpbmdfb2ZfZmxvYXQgZilcbmxldCBwcmVycl9lbmRsaW5lIHMgPVxuICBvdXRwdXRfc3RyaW5nIHN0ZGVyciBzOyBvdXRwdXRfY2hhciBzdGRlcnIgJ1xcbic7IGZsdXNoIHN0ZGVyclxubGV0IHByZXJyX25ld2xpbmUgKCkgPSBvdXRwdXRfY2hhciBzdGRlcnIgJ1xcbic7IGZsdXNoIHN0ZGVyclxuXG4oKiBJbnB1dCBmdW5jdGlvbnMgb24gc3RhbmRhcmQgaW5wdXQgKilcblxubGV0IHJlYWRfbGluZSAoKSA9IGZsdXNoIHN0ZG91dDsgaW5wdXRfbGluZSBzdGRpblxubGV0IHJlYWRfaW50ICgpID0gaW50X29mX3N0cmluZyhyZWFkX2xpbmUoKSlcbmxldCByZWFkX2ludF9vcHQgKCkgPSBpbnRfb2Zfc3RyaW5nX29wdChyZWFkX2xpbmUoKSlcbmxldCByZWFkX2Zsb2F0ICgpID0gZmxvYXRfb2Zfc3RyaW5nKHJlYWRfbGluZSgpKVxubGV0IHJlYWRfZmxvYXRfb3B0ICgpID0gZmxvYXRfb2Zfc3RyaW5nX29wdChyZWFkX2xpbmUoKSlcblxuKCogT3BlcmF0aW9ucyBvbiBsYXJnZSBmaWxlcyAqKVxuXG5tb2R1bGUgTGFyZ2VGaWxlID1cbiAgc3RydWN0XG4gICAgZXh0ZXJuYWwgc2Vla19vdXQgOiBvdXRfY2hhbm5lbCAtPiBpbnQ2NCAtPiB1bml0ID0gXCJjYW1sX21sX3NlZWtfb3V0XzY0XCJcbiAgICBleHRlcm5hbCBwb3Nfb3V0IDogb3V0X2NoYW5uZWwgLT4gaW50NjQgPSBcImNhbWxfbWxfcG9zX291dF82NFwiXG4gICAgZXh0ZXJuYWwgb3V0X2NoYW5uZWxfbGVuZ3RoIDogb3V0X2NoYW5uZWwgLT4gaW50NjRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfbWxfY2hhbm5lbF9zaXplXzY0XCJcbiAgICBleHRlcm5hbCBzZWVrX2luIDogaW5fY2hhbm5lbCAtPiBpbnQ2NCAtPiB1bml0ID0gXCJjYW1sX21sX3NlZWtfaW5fNjRcIlxuICAgIGV4dGVybmFsIHBvc19pbiA6IGluX2NoYW5uZWwgLT4gaW50NjQgPSBcImNhbWxfbWxfcG9zX2luXzY0XCJcbiAgICBleHRlcm5hbCBpbl9jaGFubmVsX2xlbmd0aCA6IGluX2NoYW5uZWwgLT4gaW50NjQgPSBcImNhbWxfbWxfY2hhbm5lbF9zaXplXzY0XCJcbiAgZW5kXG5cbigqIEZvcm1hdHMgKilcblxudHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NlxuICAgPSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzLmZvcm1hdDZcbiAgID0gRm9ybWF0IG9mICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3MuZm10XG4gICAgICAgICAgICAgICAqIHN0cmluZ1xuXG50eXBlICgnYSwgJ2IsICdjLCAnZCkgZm9ybWF0NCA9ICgnYSwgJ2IsICdjLCAnYywgJ2MsICdkKSBmb3JtYXQ2XG5cbnR5cGUgKCdhLCAnYiwgJ2MpIGZvcm1hdCA9ICgnYSwgJ2IsICdjLCAnYykgZm9ybWF0NFxuXG5sZXQgc3RyaW5nX29mX2Zvcm1hdCAoRm9ybWF0IChfZm10LCBzdHIpKSA9IHN0clxuXG5leHRlcm5hbCBmb3JtYXRfb2Zfc3RyaW5nIDpcbiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiAtPlxuICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2ID0gXCIlaWRlbnRpdHlcIlxuXG5sZXQgKCBeXiApIChGb3JtYXQgKGZtdDEsIHN0cjEpKSAoRm9ybWF0IChmbXQyLCBzdHIyKSkgPVxuICBGb3JtYXQgKENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljcy5jb25jYXRfZm10IGZtdDEgZm10MixcbiAgICAgICAgICBzdHIxIF4gXCIlLFwiIF4gc3RyMilcblxuKCogTWlzY2VsbGFuZW91cyAqKVxuXG5leHRlcm5hbCBzeXNfZXhpdCA6IGludCAtPiAnYSA9IFwiY2FtbF9zeXNfZXhpdFwiXG5cbmxldCBleGl0X2Z1bmN0aW9uID0gQ2FtbGludGVybmFsQXRvbWljLm1ha2UgZmx1c2hfYWxsXG5cbmxldCByZWMgYXRfZXhpdCBmID1cbiAgbGV0IG1vZHVsZSBBdG9taWMgPSBDYW1saW50ZXJuYWxBdG9taWMgaW5cbiAgKCogTVBSIzcyNTMsIE1QUiM3Nzk2OiBtYWtlIHN1cmUgXCJmXCIgaXMgZXhlY3V0ZWQgb25seSBvbmNlICopXG4gIGxldCBmX3lldF90b19ydW4gPSBBdG9taWMubWFrZSB0cnVlIGluXG4gIGxldCBvbGRfZXhpdCA9IEF0b21pYy5nZXQgZXhpdF9mdW5jdGlvbiBpblxuICBsZXQgbmV3X2V4aXQgKCkgPVxuICAgIGlmIEF0b21pYy5jb21wYXJlX2FuZF9zZXQgZl95ZXRfdG9fcnVuIHRydWUgZmFsc2UgdGhlbiBmICgpIDtcbiAgICBvbGRfZXhpdCAoKVxuICBpblxuICBsZXQgc3VjY2VzcyA9IEF0b21pYy5jb21wYXJlX2FuZF9zZXQgZXhpdF9mdW5jdGlvbiBvbGRfZXhpdCBuZXdfZXhpdCBpblxuICBpZiBub3Qgc3VjY2VzcyB0aGVuIGF0X2V4aXQgZlxuXG5sZXQgZG9fYXRfZXhpdCAoKSA9IChDYW1saW50ZXJuYWxBdG9taWMuZ2V0IGV4aXRfZnVuY3Rpb24pICgpXG5cbmxldCBleGl0IHJldGNvZGUgPVxuICBkb19hdF9leGl0ICgpO1xuICBzeXNfZXhpdCByZXRjb2RlXG5cbmxldCBfID0gcmVnaXN0ZXJfbmFtZWRfdmFsdWUgXCJQZXJ2YXNpdmVzLmRvX2F0X2V4aXRcIiBkb19hdF9leGl0XG5cbmV4dGVybmFsIG1ham9yIDogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2djX21ham9yXCJcbmV4dGVybmFsIG5ha2VkX3BvaW50ZXJzX2NoZWNrZWQgOiB1bml0IC0+IGJvb2xcbiAgPSBcImNhbWxfc3lzX2NvbnN0X25ha2VkX3BvaW50ZXJzX2NoZWNrZWRcIlxubGV0ICgpID0gaWYgbmFrZWRfcG9pbnRlcnNfY2hlY2tlZCAoKSB0aGVuIGF0X2V4aXQgbWFqb3JcblxuKCpNT0RVTEVfQUxJQVNFUyopXG5tb2R1bGUgQXJnICAgICAgICAgID0gQXJnXG5tb2R1bGUgQXJyYXkgICAgICAgID0gQXJyYXlcbm1vZHVsZSBBcnJheUxhYmVscyAgPSBBcnJheUxhYmVsc1xubW9kdWxlIEF0b21pYyAgICAgICA9IEF0b21pY1xubW9kdWxlIEJpZ2FycmF5ICAgICA9IEJpZ2FycmF5XG5tb2R1bGUgQm9vbCAgICAgICAgID0gQm9vbFxubW9kdWxlIEJ1ZmZlciAgICAgICA9IEJ1ZmZlclxubW9kdWxlIEJ5dGVzICAgICAgICA9IEJ5dGVzXG5tb2R1bGUgQnl0ZXNMYWJlbHMgID0gQnl0ZXNMYWJlbHNcbm1vZHVsZSBDYWxsYmFjayAgICAgPSBDYWxsYmFja1xubW9kdWxlIENoYXIgICAgICAgICA9IENoYXJcbm1vZHVsZSBDb21wbGV4ICAgICAgPSBDb21wbGV4XG5tb2R1bGUgRGlnZXN0ICAgICAgID0gRGlnZXN0XG5tb2R1bGUgRWl0aGVyICAgICAgID0gRWl0aGVyXG5tb2R1bGUgRXBoZW1lcm9uICAgID0gRXBoZW1lcm9uXG5tb2R1bGUgRmlsZW5hbWUgICAgID0gRmlsZW5hbWVcbm1vZHVsZSBGbG9hdCAgICAgICAgPSBGbG9hdFxubW9kdWxlIEZvcm1hdCAgICAgICA9IEZvcm1hdFxubW9kdWxlIEZ1biAgICAgICAgICA9IEZ1blxubW9kdWxlIEdjICAgICAgICAgICA9IEdjXG5tb2R1bGUgR2VubGV4ICAgICAgID0gR2VubGV4XG5tb2R1bGUgSGFzaHRibCAgICAgID0gSGFzaHRibFxubW9kdWxlIEludCAgICAgICAgICA9IEludFxubW9kdWxlIEludDMyICAgICAgICA9IEludDMyXG5tb2R1bGUgSW50NjQgICAgICAgID0gSW50NjRcbm1vZHVsZSBMYXp5ICAgICAgICAgPSBMYXp5XG5tb2R1bGUgTGV4aW5nICAgICAgID0gTGV4aW5nXG5tb2R1bGUgTGlzdCAgICAgICAgID0gTGlzdFxubW9kdWxlIExpc3RMYWJlbHMgICA9IExpc3RMYWJlbHNcbm1vZHVsZSBNYXAgICAgICAgICAgPSBNYXBcbm1vZHVsZSBNYXJzaGFsICAgICAgPSBNYXJzaGFsXG5tb2R1bGUgTW9yZUxhYmVscyAgID0gTW9yZUxhYmVsc1xubW9kdWxlIE5hdGl2ZWludCAgICA9IE5hdGl2ZWludFxubW9kdWxlIE9iaiAgICAgICAgICA9IE9ialxubW9kdWxlIE9vICAgICAgICAgICA9IE9vXG5tb2R1bGUgT3B0aW9uICAgICAgID0gT3B0aW9uXG5tb2R1bGUgUGFyc2luZyAgICAgID0gUGFyc2luZ1xubW9kdWxlIFBlcnZhc2l2ZXMgICA9IFBlcnZhc2l2ZXNcbm1vZHVsZSBQcmludGV4YyAgICAgPSBQcmludGV4Y1xubW9kdWxlIFByaW50ZiAgICAgICA9IFByaW50ZlxubW9kdWxlIFF1ZXVlICAgICAgICA9IFF1ZXVlXG5tb2R1bGUgUmFuZG9tICAgICAgID0gUmFuZG9tXG5tb2R1bGUgUmVzdWx0ICAgICAgID0gUmVzdWx0XG5tb2R1bGUgU2NhbmYgICAgICAgID0gU2NhbmZcbm1vZHVsZSBTZXEgICAgICAgICAgPSBTZXFcbm1vZHVsZSBTZXQgICAgICAgICAgPSBTZXRcbm1vZHVsZSBTdGFjayAgICAgICAgPSBTdGFja1xubW9kdWxlIFN0ZExhYmVscyAgICA9IFN0ZExhYmVsc1xubW9kdWxlIFN0cmVhbSAgICAgICA9IFN0cmVhbVxubW9kdWxlIFN0cmluZyAgICAgICA9IFN0cmluZ1xubW9kdWxlIFN0cmluZ0xhYmVscyA9IFN0cmluZ0xhYmVsc1xubW9kdWxlIFN5cyAgICAgICAgICA9IFN5c1xubW9kdWxlIFVjaGFyICAgICAgICA9IFVjaGFyXG5tb2R1bGUgVW5pdCAgICAgICAgID0gVW5pdFxubW9kdWxlIFdlYWsgICAgICAgICA9IFdlYWtcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgIEplcmVtaWUgRGltaW5vLCBKYW5lIFN0cmVldCBFdXJvcGUgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMTcgSmFuZSBTdHJlZXQgR3JvdXAgTExDICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCoqIEBkZXByZWNhdGVkIFVzZSB7IVN0ZGxpYn0gKilcblxuZXh0ZXJuYWwgcmFpc2UgOiBleG4gLT4gJ2EgPSBcIiVyYWlzZVwiXG5leHRlcm5hbCByYWlzZV9ub3RyYWNlIDogZXhuIC0+ICdhID0gXCIlcmFpc2Vfbm90cmFjZVwiXG5sZXQgaW52YWxpZF9hcmcgPSBpbnZhbGlkX2FyZ1xubGV0IGZhaWx3aXRoID0gZmFpbHdpdGhcbmV4Y2VwdGlvbiBFeGl0XG5leHRlcm5hbCAoID0gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVlcXVhbFwiXG5leHRlcm5hbCAoIDw+ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlbm90ZXF1YWxcIlxuZXh0ZXJuYWwgKCA8ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlbGVzc3RoYW5cIlxuZXh0ZXJuYWwgKCA+ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlZ3JlYXRlcnRoYW5cIlxuZXh0ZXJuYWwgKCA8PSApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWxlc3NlcXVhbFwiXG5leHRlcm5hbCAoID49ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlZ3JlYXRlcmVxdWFsXCJcbmV4dGVybmFsIGNvbXBhcmUgOiAnYSAtPiAnYSAtPiBpbnQgPSBcIiVjb21wYXJlXCJcbmxldCBtaW4gPSBtaW5cbmxldCBtYXggPSBtYXhcbmV4dGVybmFsICggPT0gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVlcVwiXG5leHRlcm5hbCAoICE9ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlbm90ZXFcIlxuZXh0ZXJuYWwgbm90IDogYm9vbCAtPiBib29sID0gXCIlYm9vbG5vdFwiXG5leHRlcm5hbCAoICYmICkgOiBib29sIC0+IGJvb2wgLT4gYm9vbCA9IFwiJXNlcXVhbmRcIlxuZXh0ZXJuYWwgKCAmICkgOiBib29sIC0+IGJvb2wgLT4gYm9vbCA9IFwiJXNlcXVhbmRcIlxuICBbQEBvY2FtbC5kZXByZWNhdGVkIFwiVXNlICgmJikgaW5zdGVhZC5cIl1cbmV4dGVybmFsICggfHwgKSA6IGJvb2wgLT4gYm9vbCAtPiBib29sID0gXCIlc2VxdW9yXCJcbmV4dGVybmFsICggb3IgKSA6IGJvb2wgLT4gYm9vbCAtPiBib29sID0gXCIlc2VxdW9yXCJcbiAgW0BAb2NhbWwuZGVwcmVjYXRlZCBcIlVzZSAofHwpIGluc3RlYWQuXCJdXG5leHRlcm5hbCBfX0xPQ19fIDogc3RyaW5nID0gXCIlbG9jX0xPQ1wiXG5leHRlcm5hbCBfX0ZJTEVfXyA6IHN0cmluZyA9IFwiJWxvY19GSUxFXCJcbmV4dGVybmFsIF9fTElORV9fIDogaW50ID0gXCIlbG9jX0xJTkVcIlxuZXh0ZXJuYWwgX19NT0RVTEVfXyA6IHN0cmluZyA9IFwiJWxvY19NT0RVTEVcIlxuZXh0ZXJuYWwgX19QT1NfXyA6IHN0cmluZyAqIGludCAqIGludCAqIGludCA9IFwiJWxvY19QT1NcIlxuZXh0ZXJuYWwgX19MT0NfT0ZfXyA6ICdhIC0+IHN0cmluZyAqICdhID0gXCIlbG9jX0xPQ1wiXG5leHRlcm5hbCBfX0xJTkVfT0ZfXyA6ICdhIC0+IGludCAqICdhID0gXCIlbG9jX0xJTkVcIlxuZXh0ZXJuYWwgX19QT1NfT0ZfXyA6ICdhIC0+IChzdHJpbmcgKiBpbnQgKiBpbnQgKiBpbnQpICogJ2EgPSBcIiVsb2NfUE9TXCJcbmV4dGVybmFsICggfD4gKSA6ICdhIC0+ICgnYSAtPiAnYikgLT4gJ2IgPSBcIiVyZXZhcHBseVwiXG5leHRlcm5hbCAoIEBAICkgOiAoJ2EgLT4gJ2IpIC0+ICdhIC0+ICdiID0gXCIlYXBwbHlcIlxuZXh0ZXJuYWwgKCB+LSApIDogaW50IC0+IGludCA9IFwiJW5lZ2ludFwiXG5leHRlcm5hbCAoIH4rICkgOiBpbnQgLT4gaW50ID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgc3VjYyA6IGludCAtPiBpbnQgPSBcIiVzdWNjaW50XCJcbmV4dGVybmFsIHByZWQgOiBpbnQgLT4gaW50ID0gXCIlcHJlZGludFwiXG5leHRlcm5hbCAoICsgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlYWRkaW50XCJcbmV4dGVybmFsICggLSApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVzdWJpbnRcIlxuZXh0ZXJuYWwgKCAqICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJW11bGludFwiXG5leHRlcm5hbCAoIC8gKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlZGl2aW50XCJcbmV4dGVybmFsICggbW9kICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJW1vZGludFwiXG5sZXQgYWJzID0gYWJzXG5sZXQgbWF4X2ludCA9IG1heF9pbnRcbmxldCBtaW5faW50ID0gbWluX2ludFxuZXh0ZXJuYWwgKCBsYW5kICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWFuZGludFwiXG5leHRlcm5hbCAoIGxvciApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVvcmludFwiXG5leHRlcm5hbCAoIGx4b3IgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIleG9yaW50XCJcbmxldCBsbm90ID0gbG5vdFxuZXh0ZXJuYWwgKCBsc2wgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlbHNsaW50XCJcbmV4dGVybmFsICggbHNyICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWxzcmludFwiXG5leHRlcm5hbCAoIGFzciApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVhc3JpbnRcIlxuZXh0ZXJuYWwgKCB+LS4gKSA6IGZsb2F0IC0+IGZsb2F0ID0gXCIlbmVnZmxvYXRcIlxuZXh0ZXJuYWwgKCB+Ky4gKSA6IGZsb2F0IC0+IGZsb2F0ID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgKCArLiApIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcIiVhZGRmbG9hdFwiXG5leHRlcm5hbCAoIC0uICkgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiJXN1YmZsb2F0XCJcbmV4dGVybmFsICggKi4gKSA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCIlbXVsZmxvYXRcIlxuZXh0ZXJuYWwgKCAvLiApIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcIiVkaXZmbG9hdFwiXG5leHRlcm5hbCAoICoqICkgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9wb3dlcl9mbG9hdFwiIFwicG93XCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHNxcnQgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9zcXJ0X2Zsb2F0XCIgXCJzcXJ0XCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGV4cCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2V4cF9mbG9hdFwiIFwiZXhwXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGxvZyA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2xvZ19mbG9hdFwiIFwibG9nXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGxvZzEwIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfbG9nMTBfZmxvYXRcIiBcImxvZzEwXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGV4cG0xIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfZXhwbTFfZmxvYXRcIiBcImNhbWxfZXhwbTFcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgbG9nMXAgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9sb2cxcF9mbG9hdFwiIFwiY2FtbF9sb2cxcFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBjb3MgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9jb3NfZmxvYXRcIiBcImNvc1wiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBzaW4gOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9zaW5fZmxvYXRcIiBcInNpblwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCB0YW4gOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF90YW5fZmxvYXRcIiBcInRhblwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBhY29zIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYWNvc19mbG9hdFwiIFwiYWNvc1wiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBhc2luIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYXNpbl9mbG9hdFwiIFwiYXNpblwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBhdGFuIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYXRhbl9mbG9hdFwiIFwiYXRhblwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBhdGFuMiA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2F0YW4yX2Zsb2F0XCIgXCJhdGFuMlwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBoeXBvdCA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2h5cG90X2Zsb2F0XCIgXCJjYW1sX2h5cG90XCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGNvc2ggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9jb3NoX2Zsb2F0XCIgXCJjb3NoXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHNpbmggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9zaW5oX2Zsb2F0XCIgXCJzaW5oXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHRhbmggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF90YW5oX2Zsb2F0XCIgXCJ0YW5oXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGNlaWwgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9jZWlsX2Zsb2F0XCIgXCJjZWlsXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGZsb29yIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfZmxvb3JfZmxvYXRcIiBcImZsb29yXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGFic19mbG9hdCA6IGZsb2F0IC0+IGZsb2F0ID0gXCIlYWJzZmxvYXRcIlxuZXh0ZXJuYWwgY29weXNpZ24gOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdFxuICAgICAgICAgICAgICAgICAgPSBcImNhbWxfY29weXNpZ25fZmxvYXRcIiBcImNhbWxfY29weXNpZ25cIlxuICAgICAgICAgICAgICAgICAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIG1vZF9mbG9hdCA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Ztb2RfZmxvYXRcIiBcImZtb2RcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZnJleHAgOiBmbG9hdCAtPiBmbG9hdCAqIGludCA9IFwiY2FtbF9mcmV4cF9mbG9hdFwiXG5leHRlcm5hbCBsZGV4cCA6IChmbG9hdCBbQHVuYm94ZWRdKSAtPiAoaW50IFtAdW50YWdnZWRdKSAtPiAoZmxvYXQgW0B1bmJveGVkXSkgPVxuICBcImNhbWxfbGRleHBfZmxvYXRcIiBcImNhbWxfbGRleHBfZmxvYXRfdW5ib3hlZFwiIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBtb2RmIDogZmxvYXQgLT4gZmxvYXQgKiBmbG9hdCA9IFwiY2FtbF9tb2RmX2Zsb2F0XCJcbmV4dGVybmFsIGZsb2F0IDogaW50IC0+IGZsb2F0ID0gXCIlZmxvYXRvZmludFwiXG5leHRlcm5hbCBmbG9hdF9vZl9pbnQgOiBpbnQgLT4gZmxvYXQgPSBcIiVmbG9hdG9maW50XCJcbmV4dGVybmFsIHRydW5jYXRlIDogZmxvYXQgLT4gaW50ID0gXCIlaW50b2ZmbG9hdFwiXG5leHRlcm5hbCBpbnRfb2ZfZmxvYXQgOiBmbG9hdCAtPiBpbnQgPSBcIiVpbnRvZmZsb2F0XCJcbmxldCBpbmZpbml0eSA9IGluZmluaXR5XG5sZXQgbmVnX2luZmluaXR5ID0gbmVnX2luZmluaXR5XG5sZXQgbmFuID0gbmFuXG5sZXQgbWF4X2Zsb2F0ID0gbWF4X2Zsb2F0XG5sZXQgbWluX2Zsb2F0ID0gbWluX2Zsb2F0XG5sZXQgZXBzaWxvbl9mbG9hdCA9IGVwc2lsb25fZmxvYXRcbnR5cGUgbm9ucmVjIGZwY2xhc3MgPSBmcGNsYXNzID1cbiAgICBGUF9ub3JtYWxcbiAgfCBGUF9zdWJub3JtYWxcbiAgfCBGUF96ZXJvXG4gIHwgRlBfaW5maW5pdGVcbiAgfCBGUF9uYW5cbmV4dGVybmFsIGNsYXNzaWZ5X2Zsb2F0IDogKGZsb2F0IFtAdW5ib3hlZF0pIC0+IGZwY2xhc3MgPVxuICBcImNhbWxfY2xhc3NpZnlfZmxvYXRcIiBcImNhbWxfY2xhc3NpZnlfZmxvYXRfdW5ib3hlZFwiIFtAQG5vYWxsb2NdXG5sZXQgKCBeICkgPSAoIF4gKVxuZXh0ZXJuYWwgaW50X29mX2NoYXIgOiBjaGFyIC0+IGludCA9IFwiJWlkZW50aXR5XCJcbmxldCBjaGFyX29mX2ludCA9IGNoYXJfb2ZfaW50XG5leHRlcm5hbCBpZ25vcmUgOiAnYSAtPiB1bml0ID0gXCIlaWdub3JlXCJcbmxldCBzdHJpbmdfb2ZfYm9vbCA9IHN0cmluZ19vZl9ib29sXG5sZXQgYm9vbF9vZl9zdHJpbmcgPSBib29sX29mX3N0cmluZ1xubGV0IGJvb2xfb2Zfc3RyaW5nX29wdCA9IGJvb2xfb2Zfc3RyaW5nX29wdFxubGV0IHN0cmluZ19vZl9pbnQgPSBzdHJpbmdfb2ZfaW50XG5leHRlcm5hbCBpbnRfb2Zfc3RyaW5nIDogc3RyaW5nIC0+IGludCA9IFwiY2FtbF9pbnRfb2Zfc3RyaW5nXCJcbmxldCBpbnRfb2Zfc3RyaW5nX29wdCA9IGludF9vZl9zdHJpbmdfb3B0XG5sZXQgc3RyaW5nX29mX2Zsb2F0ID0gc3RyaW5nX29mX2Zsb2F0XG5leHRlcm5hbCBmbG9hdF9vZl9zdHJpbmcgOiBzdHJpbmcgLT4gZmxvYXQgPSBcImNhbWxfZmxvYXRfb2Zfc3RyaW5nXCJcbmxldCBmbG9hdF9vZl9zdHJpbmdfb3B0ID0gZmxvYXRfb2Zfc3RyaW5nX29wdFxuZXh0ZXJuYWwgZnN0IDogJ2EgKiAnYiAtPiAnYSA9IFwiJWZpZWxkMFwiXG5leHRlcm5hbCBzbmQgOiAnYSAqICdiIC0+ICdiID0gXCIlZmllbGQxXCJcbmxldCAoIEAgKSAgPSAoIEAgKVxudHlwZSBub25yZWMgaW5fY2hhbm5lbCA9IGluX2NoYW5uZWxcbnR5cGUgbm9ucmVjIG91dF9jaGFubmVsID0gb3V0X2NoYW5uZWxcbmxldCBzdGRpbiA9IHN0ZGluXG5sZXQgc3Rkb3V0ID0gc3Rkb3V0XG5sZXQgc3RkZXJyID0gc3RkZXJyXG5sZXQgcHJpbnRfY2hhciA9IHByaW50X2NoYXJcbmxldCBwcmludF9zdHJpbmcgPSBwcmludF9zdHJpbmdcbmxldCBwcmludF9ieXRlcyA9IHByaW50X2J5dGVzXG5sZXQgcHJpbnRfaW50ID0gcHJpbnRfaW50XG5sZXQgcHJpbnRfZmxvYXQgPSBwcmludF9mbG9hdFxubGV0IHByaW50X2VuZGxpbmUgPSBwcmludF9lbmRsaW5lXG5sZXQgcHJpbnRfbmV3bGluZSA9IHByaW50X25ld2xpbmVcbmxldCBwcmVycl9jaGFyID0gcHJlcnJfY2hhclxubGV0IHByZXJyX3N0cmluZyA9IHByZXJyX3N0cmluZ1xubGV0IHByZXJyX2J5dGVzID0gcHJlcnJfYnl0ZXNcbmxldCBwcmVycl9pbnQgPSBwcmVycl9pbnRcbmxldCBwcmVycl9mbG9hdCA9IHByZXJyX2Zsb2F0XG5sZXQgcHJlcnJfZW5kbGluZSA9IHByZXJyX2VuZGxpbmVcbmxldCBwcmVycl9uZXdsaW5lID0gcHJlcnJfbmV3bGluZVxubGV0IHJlYWRfbGluZSA9IHJlYWRfbGluZVxubGV0IHJlYWRfaW50ID0gcmVhZF9pbnRcbmxldCByZWFkX2ludF9vcHQgPSByZWFkX2ludF9vcHRcbmxldCByZWFkX2Zsb2F0ID0gcmVhZF9mbG9hdFxubGV0IHJlYWRfZmxvYXRfb3B0ID0gcmVhZF9mbG9hdF9vcHRcbnR5cGUgbm9ucmVjIG9wZW5fZmxhZyA9IG9wZW5fZmxhZyA9XG4gICAgT3Blbl9yZG9ubHlcbiAgfCBPcGVuX3dyb25seVxuICB8IE9wZW5fYXBwZW5kXG4gIHwgT3Blbl9jcmVhdFxuICB8IE9wZW5fdHJ1bmNcbiAgfCBPcGVuX2V4Y2xcbiAgfCBPcGVuX2JpbmFyeVxuICB8IE9wZW5fdGV4dFxuICB8IE9wZW5fbm9uYmxvY2tcbmxldCBvcGVuX291dCA9IG9wZW5fb3V0XG5sZXQgb3Blbl9vdXRfYmluID0gb3Blbl9vdXRfYmluXG5sZXQgb3Blbl9vdXRfZ2VuID0gb3Blbl9vdXRfZ2VuXG5sZXQgZmx1c2ggPSBmbHVzaFxubGV0IGZsdXNoX2FsbCA9IGZsdXNoX2FsbFxubGV0IG91dHB1dF9jaGFyID0gb3V0cHV0X2NoYXJcbmxldCBvdXRwdXRfc3RyaW5nID0gb3V0cHV0X3N0cmluZ1xubGV0IG91dHB1dF9ieXRlcyA9IG91dHB1dF9ieXRlc1xubGV0IG91dHB1dCA9IG91dHB1dFxubGV0IG91dHB1dF9zdWJzdHJpbmcgPSBvdXRwdXRfc3Vic3RyaW5nXG5sZXQgb3V0cHV0X2J5dGUgPSBvdXRwdXRfYnl0ZVxubGV0IG91dHB1dF9iaW5hcnlfaW50ID0gb3V0cHV0X2JpbmFyeV9pbnRcbmxldCBvdXRwdXRfdmFsdWUgPSBvdXRwdXRfdmFsdWVcbmxldCBzZWVrX291dCA9IHNlZWtfb3V0XG5sZXQgcG9zX291dCA9IHBvc19vdXRcbmxldCBvdXRfY2hhbm5lbF9sZW5ndGggPSBvdXRfY2hhbm5lbF9sZW5ndGhcbmxldCBjbG9zZV9vdXQgPSBjbG9zZV9vdXRcbmxldCBjbG9zZV9vdXRfbm9lcnIgPSBjbG9zZV9vdXRfbm9lcnJcbmxldCBzZXRfYmluYXJ5X21vZGVfb3V0ID0gc2V0X2JpbmFyeV9tb2RlX291dFxubGV0IG9wZW5faW4gPSBvcGVuX2luXG5sZXQgb3Blbl9pbl9iaW4gPSBvcGVuX2luX2JpblxubGV0IG9wZW5faW5fZ2VuID0gb3Blbl9pbl9nZW5cbmxldCBpbnB1dF9jaGFyID0gaW5wdXRfY2hhclxubGV0IGlucHV0X2xpbmUgPSBpbnB1dF9saW5lXG5sZXQgaW5wdXQgPSBpbnB1dFxubGV0IHJlYWxseV9pbnB1dCA9IHJlYWxseV9pbnB1dFxubGV0IHJlYWxseV9pbnB1dF9zdHJpbmcgPSByZWFsbHlfaW5wdXRfc3RyaW5nXG5sZXQgaW5wdXRfYnl0ZSA9IGlucHV0X2J5dGVcbmxldCBpbnB1dF9iaW5hcnlfaW50ID0gaW5wdXRfYmluYXJ5X2ludFxubGV0IGlucHV0X3ZhbHVlID0gaW5wdXRfdmFsdWVcbmxldCBzZWVrX2luID0gc2Vla19pblxubGV0IHBvc19pbiA9IHBvc19pblxubGV0IGluX2NoYW5uZWxfbGVuZ3RoID0gaW5fY2hhbm5lbF9sZW5ndGhcbmxldCBjbG9zZV9pbiA9IGNsb3NlX2luXG5sZXQgY2xvc2VfaW5fbm9lcnIgPSBjbG9zZV9pbl9ub2VyclxubGV0IHNldF9iaW5hcnlfbW9kZV9pbiA9IHNldF9iaW5hcnlfbW9kZV9pblxubW9kdWxlIExhcmdlRmlsZSA9IExhcmdlRmlsZVxudHlwZSBub25yZWMgJ2EgcmVmID0gJ2EgcmVmID0geyBtdXRhYmxlIGNvbnRlbnRzIDogJ2EgfVxuZXh0ZXJuYWwgcmVmIDogJ2EgLT4gJ2EgcmVmID0gXCIlbWFrZW11dGFibGVcIlxuZXh0ZXJuYWwgKCAhICkgOiAnYSByZWYgLT4gJ2EgPSBcIiVmaWVsZDBcIlxuZXh0ZXJuYWwgKCA6PSApIDogJ2EgcmVmIC0+ICdhIC0+IHVuaXQgPSBcIiVzZXRmaWVsZDBcIlxuZXh0ZXJuYWwgaW5jciA6IGludCByZWYgLT4gdW5pdCA9IFwiJWluY3JcIlxuZXh0ZXJuYWwgZGVjciA6IGludCByZWYgLT4gdW5pdCA9IFwiJWRlY3JcIlxudHlwZSBub25yZWMgKCdhLCdiKSByZXN1bHQgPSAoJ2EsJ2IpIHJlc3VsdCA9IE9rIG9mICdhIHwgRXJyb3Igb2YgJ2JcbnR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgPVxuICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzLmZvcm1hdDZcbnR5cGUgKCdhLCAnYiwgJ2MsICdkKSBmb3JtYXQ0ID0gKCdhLCAnYiwgJ2MsICdjLCAnYywgJ2QpIGZvcm1hdDZcbnR5cGUgKCdhLCAnYiwgJ2MpIGZvcm1hdCA9ICgnYSwgJ2IsICdjLCAnYykgZm9ybWF0NFxubGV0IHN0cmluZ19vZl9mb3JtYXQgPSBzdHJpbmdfb2ZfZm9ybWF0XG5leHRlcm5hbCBmb3JtYXRfb2Zfc3RyaW5nIDpcbiAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgLT5cbiAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgPSBcIiVpZGVudGl0eVwiXG5sZXQgKCBeXiApID0gKCBeXiApXG5sZXQgZXhpdCA9IGV4aXRcbmxldCBhdF9leGl0ID0gYXRfZXhpdFxubGV0IHZhbGlkX2Zsb2F0X2xleGVtID0gdmFsaWRfZmxvYXRfbGV4ZW1cbmxldCBkb19hdF9leGl0ID0gZG9fYXRfZXhpdFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICBOaWNvbGFzIE9qZWRhIEJhciwgTGV4aUZpICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxOCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5leHRlcm5hbCBuZWcgOiBmbG9hdCAtPiBmbG9hdCA9IFwiJW5lZ2Zsb2F0XCJcbmV4dGVybmFsIGFkZCA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCIlYWRkZmxvYXRcIlxuZXh0ZXJuYWwgc3ViIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcIiVzdWJmbG9hdFwiXG5leHRlcm5hbCBtdWwgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiJW11bGZsb2F0XCJcbmV4dGVybmFsIGRpdiA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCIlZGl2ZmxvYXRcIlxuZXh0ZXJuYWwgcmVtIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfZm1vZF9mbG9hdFwiIFwiZm1vZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBmbWEgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9mbWFfZmxvYXRcIiBcImNhbWxfZm1hXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGFicyA6IGZsb2F0IC0+IGZsb2F0ID0gXCIlYWJzZmxvYXRcIlxuXG5sZXQgemVybyA9IDAuXG5sZXQgb25lID0gMS5cbmxldCBtaW51c19vbmUgPSAtMS5cbmxldCBpbmZpbml0eSA9IFN0ZGxpYi5pbmZpbml0eVxubGV0IG5lZ19pbmZpbml0eSA9IFN0ZGxpYi5uZWdfaW5maW5pdHlcbmxldCBuYW4gPSBTdGRsaWIubmFuXG5sZXQgaXNfZmluaXRlICh4OiBmbG9hdCkgPSB4IC0uIHggPSAwLlxubGV0IGlzX2luZmluaXRlICh4OiBmbG9hdCkgPSAxLiAvLiB4ID0gMC5cbmxldCBpc19uYW4gKHg6IGZsb2F0KSA9IHggPD4geFxuXG5sZXQgcGkgPSAweDEuOTIxZmI1NDQ0MmQxOHArMVxubGV0IG1heF9mbG9hdCA9IFN0ZGxpYi5tYXhfZmxvYXRcbmxldCBtaW5fZmxvYXQgPSBTdGRsaWIubWluX2Zsb2F0XG5sZXQgZXBzaWxvbiA9IFN0ZGxpYi5lcHNpbG9uX2Zsb2F0XG5leHRlcm5hbCBvZl9pbnQgOiBpbnQgLT4gZmxvYXQgPSBcIiVmbG9hdG9maW50XCJcbmV4dGVybmFsIHRvX2ludCA6IGZsb2F0IC0+IGludCA9IFwiJWludG9mZmxvYXRcIlxuZXh0ZXJuYWwgb2Zfc3RyaW5nIDogc3RyaW5nIC0+IGZsb2F0ID0gXCJjYW1sX2Zsb2F0X29mX3N0cmluZ1wiXG5sZXQgb2Zfc3RyaW5nX29wdCA9IFN0ZGxpYi5mbG9hdF9vZl9zdHJpbmdfb3B0XG5sZXQgdG9fc3RyaW5nID0gU3RkbGliLnN0cmluZ19vZl9mbG9hdFxudHlwZSBmcGNsYXNzID0gU3RkbGliLmZwY2xhc3MgPVxuICAgIEZQX25vcm1hbFxuICB8IEZQX3N1Ym5vcm1hbFxuICB8IEZQX3plcm9cbiAgfCBGUF9pbmZpbml0ZVxuICB8IEZQX25hblxuZXh0ZXJuYWwgY2xhc3NpZnlfZmxvYXQgOiAoZmxvYXQgW0B1bmJveGVkXSkgLT4gZnBjbGFzcyA9XG4gIFwiY2FtbF9jbGFzc2lmeV9mbG9hdFwiIFwiY2FtbF9jbGFzc2lmeV9mbG9hdF91bmJveGVkXCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIHBvdyA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3Bvd2VyX2Zsb2F0XCIgXCJwb3dcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgc3FydCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3NxcnRfZmxvYXRcIiBcInNxcnRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZXhwIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfZXhwX2Zsb2F0XCIgXCJleHBcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgbG9nIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfbG9nX2Zsb2F0XCIgXCJsb2dcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgbG9nMTAgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9sb2cxMF9mbG9hdFwiIFwibG9nMTBcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZXhwbTEgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9leHBtMV9mbG9hdFwiIFwiY2FtbF9leHBtMVwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBsb2cxcCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2xvZzFwX2Zsb2F0XCIgXCJjYW1sX2xvZzFwXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGNvcyA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Nvc19mbG9hdFwiIFwiY29zXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHNpbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3Npbl9mbG9hdFwiIFwic2luXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHRhbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3Rhbl9mbG9hdFwiIFwidGFuXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGFjb3MgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hY29zX2Zsb2F0XCIgXCJhY29zXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGFzaW4gOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hc2luX2Zsb2F0XCIgXCJhc2luXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGF0YW4gOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hdGFuX2Zsb2F0XCIgXCJhdGFuXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGF0YW4yIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYXRhbjJfZmxvYXRcIiBcImF0YW4yXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGh5cG90IDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXRcbiAgICAgICAgICAgICAgID0gXCJjYW1sX2h5cG90X2Zsb2F0XCIgXCJjYW1sX2h5cG90XCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGNvc2ggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9jb3NoX2Zsb2F0XCIgXCJjb3NoXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHNpbmggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9zaW5oX2Zsb2F0XCIgXCJzaW5oXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHRhbmggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF90YW5oX2Zsb2F0XCIgXCJ0YW5oXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHRydW5jIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfdHJ1bmNfZmxvYXRcIiBcImNhbWxfdHJ1bmNcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgcm91bmQgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9yb3VuZF9mbG9hdFwiIFwiY2FtbF9yb3VuZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBjZWlsIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfY2VpbF9mbG9hdFwiIFwiY2VpbFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBmbG9vciA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Zsb29yX2Zsb2F0XCIgXCJmbG9vclwiXG5bQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuXG5sZXQgaXNfaW50ZWdlciB4ID0geCA9IHRydW5jIHggJiYgaXNfZmluaXRlIHhcblxuZXh0ZXJuYWwgbmV4dF9hZnRlciA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0XG4gID0gXCJjYW1sX25leHRhZnRlcl9mbG9hdFwiIFwiY2FtbF9uZXh0YWZ0ZXJcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuXG5sZXQgc3VjYyB4ID0gbmV4dF9hZnRlciB4IGluZmluaXR5XG5sZXQgcHJlZCB4ID0gbmV4dF9hZnRlciB4IG5lZ19pbmZpbml0eVxuXG5leHRlcm5hbCBjb3B5X3NpZ24gOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdFxuICAgICAgICAgICAgICAgICAgPSBcImNhbWxfY29weXNpZ25fZmxvYXRcIiBcImNhbWxfY29weXNpZ25cIlxuICAgICAgICAgICAgICAgICAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHNpZ25fYml0IDogKGZsb2F0IFtAdW5ib3hlZF0pIC0+IGJvb2xcbiAgPSBcImNhbWxfc2lnbmJpdF9mbG9hdFwiIFwiY2FtbF9zaWduYml0XCIgW0BAbm9hbGxvY11cblxuZXh0ZXJuYWwgZnJleHAgOiBmbG9hdCAtPiBmbG9hdCAqIGludCA9IFwiY2FtbF9mcmV4cF9mbG9hdFwiXG5leHRlcm5hbCBsZGV4cCA6IChmbG9hdCBbQHVuYm94ZWRdKSAtPiAoaW50IFtAdW50YWdnZWRdKSAtPiAoZmxvYXQgW0B1bmJveGVkXSkgPVxuICBcImNhbWxfbGRleHBfZmxvYXRcIiBcImNhbWxfbGRleHBfZmxvYXRfdW5ib3hlZFwiIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBtb2RmIDogZmxvYXQgLT4gZmxvYXQgKiBmbG9hdCA9IFwiY2FtbF9tb2RmX2Zsb2F0XCJcbnR5cGUgdCA9IGZsb2F0XG5leHRlcm5hbCBjb21wYXJlIDogZmxvYXQgLT4gZmxvYXQgLT4gaW50ID0gXCIlY29tcGFyZVwiXG5sZXQgZXF1YWwgeCB5ID0gY29tcGFyZSB4IHkgPSAwXG5cbmxldFtAaW5saW5lXSBtaW4gKHg6IGZsb2F0KSAoeTogZmxvYXQpID1cbiAgaWYgeSA+IHggfHwgKG5vdChzaWduX2JpdCB5KSAmJiBzaWduX2JpdCB4KSB0aGVuXG4gICAgaWYgaXNfbmFuIHkgdGhlbiB5IGVsc2UgeFxuICBlbHNlIGlmIGlzX25hbiB4IHRoZW4geCBlbHNlIHlcblxubGV0W0BpbmxpbmVdIG1heCAoeDogZmxvYXQpICh5OiBmbG9hdCkgPVxuICBpZiB5ID4geCB8fCAobm90KHNpZ25fYml0IHkpICYmIHNpZ25fYml0IHgpIHRoZW5cbiAgICBpZiBpc19uYW4geCB0aGVuIHggZWxzZSB5XG4gIGVsc2UgaWYgaXNfbmFuIHkgdGhlbiB5IGVsc2UgeFxuXG5sZXRbQGlubGluZV0gbWluX21heCAoeDogZmxvYXQpICh5OiBmbG9hdCkgPVxuICBpZiBpc19uYW4geCB8fCBpc19uYW4geSB0aGVuIChuYW4sIG5hbilcbiAgZWxzZSBpZiB5ID4geCB8fCAobm90KHNpZ25fYml0IHkpICYmIHNpZ25fYml0IHgpIHRoZW4gKHgsIHkpIGVsc2UgKHksIHgpXG5cbmxldFtAaW5saW5lXSBtaW5fbnVtICh4OiBmbG9hdCkgKHk6IGZsb2F0KSA9XG4gIGlmIHkgPiB4IHx8IChub3Qoc2lnbl9iaXQgeSkgJiYgc2lnbl9iaXQgeCkgdGhlblxuICAgIGlmIGlzX25hbiB4IHRoZW4geSBlbHNlIHhcbiAgZWxzZSBpZiBpc19uYW4geSB0aGVuIHggZWxzZSB5XG5cbmxldFtAaW5saW5lXSBtYXhfbnVtICh4OiBmbG9hdCkgKHk6IGZsb2F0KSA9XG4gIGlmIHkgPiB4IHx8IChub3Qoc2lnbl9iaXQgeSkgJiYgc2lnbl9iaXQgeCkgdGhlblxuICAgIGlmIGlzX25hbiB5IHRoZW4geCBlbHNlIHlcbiAgZWxzZSBpZiBpc19uYW4geCB0aGVuIHkgZWxzZSB4XG5cbmxldFtAaW5saW5lXSBtaW5fbWF4X251bSAoeDogZmxvYXQpICh5OiBmbG9hdCkgPVxuICBpZiBpc19uYW4geCB0aGVuICh5LHkpXG4gIGVsc2UgaWYgaXNfbmFuIHkgdGhlbiAoeCx4KVxuICBlbHNlIGlmIHkgPiB4IHx8IChub3Qoc2lnbl9iaXQgeSkgJiYgc2lnbl9iaXQgeCkgdGhlbiAoeCx5KSBlbHNlICh5LHgpXG5cbmV4dGVybmFsIHNlZWRlZF9oYXNoX3BhcmFtIDogaW50IC0+IGludCAtPiBpbnQgLT4gZmxvYXQgLT4gaW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9oYXNoXCIgW0BAbm9hbGxvY11cbmxldCBoYXNoIHggPSBzZWVkZWRfaGFzaF9wYXJhbSAxMCAxMDAgMCB4XG5cbm1vZHVsZSBBcnJheSA9IHN0cnVjdFxuXG4gIHR5cGUgdCA9IGZsb2F0YXJyYXlcblxuICBleHRlcm5hbCBsZW5ndGggOiB0IC0+IGludCA9IFwiJWZsb2F0YXJyYXlfbGVuZ3RoXCJcbiAgZXh0ZXJuYWwgZ2V0IDogdCAtPiBpbnQgLT4gZmxvYXQgPSBcIiVmbG9hdGFycmF5X3NhZmVfZ2V0XCJcbiAgZXh0ZXJuYWwgc2V0IDogdCAtPiBpbnQgLT4gZmxvYXQgLT4gdW5pdCA9IFwiJWZsb2F0YXJyYXlfc2FmZV9zZXRcIlxuICBleHRlcm5hbCBjcmVhdGUgOiBpbnQgLT4gdCA9IFwiY2FtbF9mbG9hdGFycmF5X2NyZWF0ZVwiXG4gIGV4dGVybmFsIHVuc2FmZV9nZXQgOiB0IC0+IGludCAtPiBmbG9hdCA9IFwiJWZsb2F0YXJyYXlfdW5zYWZlX2dldFwiXG4gIGV4dGVybmFsIHVuc2FmZV9zZXQgOiB0IC0+IGludCAtPiBmbG9hdCAtPiB1bml0ID0gXCIlZmxvYXRhcnJheV91bnNhZmVfc2V0XCJcblxuICBsZXQgdW5zYWZlX2ZpbGwgYSBvZnMgbGVuIHYgPVxuICAgIGZvciBpID0gb2ZzIHRvIG9mcyArIGxlbiAtIDEgZG8gdW5zYWZlX3NldCBhIGkgdiBkb25lXG5cbiAgZXh0ZXJuYWwgdW5zYWZlX2JsaXQ6IHQgLT4gaW50IC0+IHQgLT4gaW50IC0+IGludCAtPiB1bml0ID1cbiAgICBcImNhbWxfZmxvYXRhcnJheV9ibGl0XCIgW0BAbm9hbGxvY11cblxuICBsZXQgY2hlY2sgYSBvZnMgbGVuIG1zZyA9XG4gICAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyArIGxlbiA8IDAgfHwgb2ZzICsgbGVuID4gbGVuZ3RoIGEgdGhlblxuICAgICAgaW52YWxpZF9hcmcgbXNnXG5cbiAgbGV0IG1ha2UgbiB2ID1cbiAgICBsZXQgcmVzdWx0ID0gY3JlYXRlIG4gaW5cbiAgICB1bnNhZmVfZmlsbCByZXN1bHQgMCBuIHY7XG4gICAgcmVzdWx0XG5cbiAgbGV0IGluaXQgbCBmID1cbiAgICBpZiBsIDwgMCB0aGVuIGludmFsaWRfYXJnIFwiRmxvYXQuQXJyYXkuaW5pdFwiXG4gICAgZWxzZVxuICAgICAgbGV0IHJlcyA9IGNyZWF0ZSBsIGluXG4gICAgICBmb3IgaSA9IDAgdG8gbCAtIDEgZG9cbiAgICAgICAgdW5zYWZlX3NldCByZXMgaSAoZiBpKVxuICAgICAgZG9uZTtcbiAgICAgIHJlc1xuXG4gIGxldCBhcHBlbmQgYTEgYTIgPVxuICAgIGxldCBsMSA9IGxlbmd0aCBhMSBpblxuICAgIGxldCBsMiA9IGxlbmd0aCBhMiBpblxuICAgIGxldCByZXN1bHQgPSBjcmVhdGUgKGwxICsgbDIpIGluXG4gICAgdW5zYWZlX2JsaXQgYTEgMCByZXN1bHQgMCBsMTtcbiAgICB1bnNhZmVfYmxpdCBhMiAwIHJlc3VsdCBsMSBsMjtcbiAgICByZXN1bHRcblxuICAoKiBuZXh0IDMgZnVuY3Rpb25zOiBtb2RpZmllZCBjb3B5IG9mIGNvZGUgZnJvbSBzdHJpbmcubWwgKilcbiAgbGV0IGVuc3VyZV9nZSAoeDppbnQpIHkgPVxuICAgIGlmIHggPj0geSB0aGVuIHggZWxzZSBpbnZhbGlkX2FyZyBcIkZsb2F0LkFycmF5LmNvbmNhdFwiXG5cbiAgbGV0IHJlYyBzdW1fbGVuZ3RocyBhY2MgPSBmdW5jdGlvblxuICAgIHwgW10gLT4gYWNjXG4gICAgfCBoZCA6OiB0bCAtPiBzdW1fbGVuZ3RocyAoZW5zdXJlX2dlIChsZW5ndGggaGQgKyBhY2MpIGFjYykgdGxcblxuICBsZXQgY29uY2F0IGwgPVxuICAgIGxldCBsZW4gPSBzdW1fbGVuZ3RocyAwIGwgaW5cbiAgICBsZXQgcmVzdWx0ID0gY3JlYXRlIGxlbiBpblxuICAgIGxldCByZWMgbG9vcCBsIGkgPVxuICAgICAgbWF0Y2ggbCB3aXRoXG4gICAgICB8IFtdIC0+IGFzc2VydCAoaSA9IGxlbilcbiAgICAgIHwgaGQgOjogdGwgLT5cbiAgICAgICAgbGV0IGhsZW4gPSBsZW5ndGggaGQgaW5cbiAgICAgICAgdW5zYWZlX2JsaXQgaGQgMCByZXN1bHQgaSBobGVuO1xuICAgICAgICBsb29wIHRsIChpICsgaGxlbilcbiAgICBpblxuICAgIGxvb3AgbCAwO1xuICAgIHJlc3VsdFxuXG4gIGxldCBzdWIgYSBvZnMgbGVuID1cbiAgICBjaGVjayBhIG9mcyBsZW4gXCJGbG9hdC5BcnJheS5zdWJcIjtcbiAgICBsZXQgcmVzdWx0ID0gY3JlYXRlIGxlbiBpblxuICAgIHVuc2FmZV9ibGl0IGEgb2ZzIHJlc3VsdCAwIGxlbjtcbiAgICByZXN1bHRcblxuICBsZXQgY29weSBhID1cbiAgICBsZXQgbCA9IGxlbmd0aCBhIGluXG4gICAgbGV0IHJlc3VsdCA9IGNyZWF0ZSBsIGluXG4gICAgdW5zYWZlX2JsaXQgYSAwIHJlc3VsdCAwIGw7XG4gICAgcmVzdWx0XG5cbiAgbGV0IGZpbGwgYSBvZnMgbGVuIHYgPVxuICAgIGNoZWNrIGEgb2ZzIGxlbiBcIkZsb2F0LkFycmF5LmZpbGxcIjtcbiAgICB1bnNhZmVfZmlsbCBhIG9mcyBsZW4gdlxuXG4gIGxldCBibGl0IHNyYyBzb2ZzIGRzdCBkb2ZzIGxlbiA9XG4gICAgY2hlY2sgc3JjIHNvZnMgbGVuIFwiRmxvYXQuYXJyYXkuYmxpdFwiO1xuICAgIGNoZWNrIGRzdCBkb2ZzIGxlbiBcIkZsb2F0LmFycmF5LmJsaXRcIjtcbiAgICB1bnNhZmVfYmxpdCBzcmMgc29mcyBkc3QgZG9mcyBsZW5cblxuICBsZXQgdG9fbGlzdCBhID1cbiAgICBMaXN0LmluaXQgKGxlbmd0aCBhKSAodW5zYWZlX2dldCBhKVxuXG4gIGxldCBvZl9saXN0IGwgPVxuICAgIGxldCByZXN1bHQgPSBjcmVhdGUgKExpc3QubGVuZ3RoIGwpIGluXG4gICAgbGV0IHJlYyBmaWxsIGkgbCA9XG4gICAgICBtYXRjaCBsIHdpdGhcbiAgICAgIHwgW10gLT4gcmVzdWx0XG4gICAgICB8IGggOjogdCAtPiB1bnNhZmVfc2V0IHJlc3VsdCBpIGg7IGZpbGwgKGkgKyAxKSB0XG4gICAgaW5cbiAgICBmaWxsIDAgbFxuXG4gICgqIGR1cGxpY2F0ZWQgZnJvbSBhcnJheS5tbCAqKVxuICBsZXQgaXRlciBmIGEgPVxuICAgIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG8gZiAodW5zYWZlX2dldCBhIGkpIGRvbmVcblxuICAoKiBkdXBsaWNhdGVkIGZyb20gYXJyYXkubWwgKilcbiAgbGV0IGl0ZXIyIGYgYSBiID1cbiAgICBpZiBsZW5ndGggYSA8PiBsZW5ndGggYiB0aGVuXG4gICAgICBpbnZhbGlkX2FyZyBcIkZsb2F0LkFycmF5Lml0ZXIyOiBhcnJheXMgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aFwiXG4gICAgZWxzZVxuICAgICAgZm9yIGkgPSAwIHRvIGxlbmd0aCBhIC0gMSBkbyBmICh1bnNhZmVfZ2V0IGEgaSkgKHVuc2FmZV9nZXQgYiBpKSBkb25lXG5cbiAgbGV0IG1hcCBmIGEgPVxuICAgIGxldCBsID0gbGVuZ3RoIGEgaW5cbiAgICBsZXQgciA9IGNyZWF0ZSBsIGluXG4gICAgZm9yIGkgPSAwIHRvIGwgLSAxIGRvXG4gICAgICB1bnNhZmVfc2V0IHIgaSAoZiAodW5zYWZlX2dldCBhIGkpKVxuICAgIGRvbmU7XG4gICAgclxuXG4gIGxldCBtYXAyIGYgYSBiID1cbiAgICBsZXQgbGEgPSBsZW5ndGggYSBpblxuICAgIGxldCBsYiA9IGxlbmd0aCBiIGluXG4gICAgaWYgbGEgPD4gbGIgdGhlblxuICAgICAgaW52YWxpZF9hcmcgXCJGbG9hdC5BcnJheS5tYXAyOiBhcnJheXMgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aFwiXG4gICAgZWxzZSBiZWdpblxuICAgICAgbGV0IHIgPSBjcmVhdGUgbGEgaW5cbiAgICAgIGZvciBpID0gMCB0byBsYSAtIDEgZG9cbiAgICAgICAgdW5zYWZlX3NldCByIGkgKGYgKHVuc2FmZV9nZXQgYSBpKSAodW5zYWZlX2dldCBiIGkpKVxuICAgICAgZG9uZTtcbiAgICAgIHJcbiAgICBlbmRcblxuICAoKiBkdXBsaWNhdGVkIGZyb20gYXJyYXkubWwgKilcbiAgbGV0IGl0ZXJpIGYgYSA9XG4gICAgZm9yIGkgPSAwIHRvIGxlbmd0aCBhIC0gMSBkbyBmIGkgKHVuc2FmZV9nZXQgYSBpKSBkb25lXG5cbiAgbGV0IG1hcGkgZiBhID1cbiAgICBsZXQgbCA9IGxlbmd0aCBhIGluXG4gICAgbGV0IHIgPSBjcmVhdGUgbCBpblxuICAgIGZvciBpID0gMCB0byBsIC0gMSBkb1xuICAgICAgdW5zYWZlX3NldCByIGkgKGYgaSAodW5zYWZlX2dldCBhIGkpKVxuICAgIGRvbmU7XG4gICAgclxuXG4gICgqIGR1cGxpY2F0ZWQgZnJvbSBhcnJheS5tbCAqKVxuICBsZXQgZm9sZF9sZWZ0IGYgeCBhID1cbiAgICBsZXQgciA9IHJlZiB4IGluXG4gICAgZm9yIGkgPSAwIHRvIGxlbmd0aCBhIC0gMSBkb1xuICAgICAgciA6PSBmICFyICh1bnNhZmVfZ2V0IGEgaSlcbiAgICBkb25lO1xuICAgICFyXG5cbiAgKCogZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sICopXG4gIGxldCBmb2xkX3JpZ2h0IGYgYSB4ID1cbiAgICBsZXQgciA9IHJlZiB4IGluXG4gICAgZm9yIGkgPSBsZW5ndGggYSAtIDEgZG93bnRvIDAgZG9cbiAgICAgIHIgOj0gZiAodW5zYWZlX2dldCBhIGkpICFyXG4gICAgZG9uZTtcbiAgICAhclxuXG4gICgqIGR1cGxpY2F0ZWQgZnJvbSBhcnJheS5tbCAqKVxuICBsZXQgZXhpc3RzIHAgYSA9XG4gICAgbGV0IG4gPSBsZW5ndGggYSBpblxuICAgIGxldCByZWMgbG9vcCBpID1cbiAgICAgIGlmIGkgPSBuIHRoZW4gZmFsc2VcbiAgICAgIGVsc2UgaWYgcCAodW5zYWZlX2dldCBhIGkpIHRoZW4gdHJ1ZVxuICAgICAgZWxzZSBsb29wIChpICsgMSkgaW5cbiAgICBsb29wIDBcblxuICAoKiBkdXBsaWNhdGVkIGZyb20gYXJyYXkubWwgKilcbiAgbGV0IGZvcl9hbGwgcCBhID1cbiAgICBsZXQgbiA9IGxlbmd0aCBhIGluXG4gICAgbGV0IHJlYyBsb29wIGkgPVxuICAgICAgaWYgaSA9IG4gdGhlbiB0cnVlXG4gICAgICBlbHNlIGlmIHAgKHVuc2FmZV9nZXQgYSBpKSB0aGVuIGxvb3AgKGkgKyAxKVxuICAgICAgZWxzZSBmYWxzZSBpblxuICAgIGxvb3AgMFxuXG4gICgqIGR1cGxpY2F0ZWQgZnJvbSBhcnJheS5tbCAqKVxuICBsZXQgbWVtIHggYSA9XG4gICAgbGV0IG4gPSBsZW5ndGggYSBpblxuICAgIGxldCByZWMgbG9vcCBpID1cbiAgICAgIGlmIGkgPSBuIHRoZW4gZmFsc2VcbiAgICAgIGVsc2UgaWYgY29tcGFyZSAodW5zYWZlX2dldCBhIGkpIHggPSAwIHRoZW4gdHJ1ZVxuICAgICAgZWxzZSBsb29wIChpICsgMSlcbiAgICBpblxuICAgIGxvb3AgMFxuXG4gICgqIG1vc3RseSBkdXBsaWNhdGVkIGZyb20gYXJyYXkubWwsIGJ1dCBzbGlnaHRseSBkaWZmZXJlbnQgKilcbiAgbGV0IG1lbV9pZWVlIHggYSA9XG4gICAgbGV0IG4gPSBsZW5ndGggYSBpblxuICAgIGxldCByZWMgbG9vcCBpID1cbiAgICAgIGlmIGkgPSBuIHRoZW4gZmFsc2VcbiAgICAgIGVsc2UgaWYgeCA9ICh1bnNhZmVfZ2V0IGEgaSkgdGhlbiB0cnVlXG4gICAgICBlbHNlIGxvb3AgKGkgKyAxKVxuICAgIGluXG4gICAgbG9vcCAwXG5cbiAgKCogZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sICopXG4gIGV4Y2VwdGlvbiBCb3R0b20gb2YgaW50XG4gIGxldCBzb3J0IGNtcCBhID1cbiAgICBsZXQgbWF4c29uIGwgaSA9XG4gICAgICBsZXQgaTMxID0gaStpK2krMSBpblxuICAgICAgbGV0IHggPSByZWYgaTMxIGluXG4gICAgICBpZiBpMzErMiA8IGwgdGhlbiBiZWdpblxuICAgICAgICBpZiBjbXAgKGdldCBhIGkzMSkgKGdldCBhIChpMzErMSkpIDwgMCB0aGVuIHggOj0gaTMxKzE7XG4gICAgICAgIGlmIGNtcCAoZ2V0IGEgIXgpIChnZXQgYSAoaTMxKzIpKSA8IDAgdGhlbiB4IDo9IGkzMSsyO1xuICAgICAgICAheFxuICAgICAgZW5kIGVsc2VcbiAgICAgICAgaWYgaTMxKzEgPCBsICYmIGNtcCAoZ2V0IGEgaTMxKSAoZ2V0IGEgKGkzMSsxKSkgPCAwXG4gICAgICAgIHRoZW4gaTMxKzFcbiAgICAgICAgZWxzZSBpZiBpMzEgPCBsIHRoZW4gaTMxIGVsc2UgcmFpc2UgKEJvdHRvbSBpKVxuICAgIGluXG4gICAgbGV0IHJlYyB0cmlja2xlZG93biBsIGkgZSA9XG4gICAgICBsZXQgaiA9IG1heHNvbiBsIGkgaW5cbiAgICAgIGlmIGNtcCAoZ2V0IGEgaikgZSA+IDAgdGhlbiBiZWdpblxuICAgICAgICBzZXQgYSBpIChnZXQgYSBqKTtcbiAgICAgICAgdHJpY2tsZWRvd24gbCBqIGU7XG4gICAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgICBzZXQgYSBpIGU7XG4gICAgICBlbmQ7XG4gICAgaW5cbiAgICBsZXQgdHJpY2tsZSBsIGkgZSA9IHRyeSB0cmlja2xlZG93biBsIGkgZSB3aXRoIEJvdHRvbSBpIC0+IHNldCBhIGkgZSBpblxuICAgIGxldCByZWMgYnViYmxlZG93biBsIGkgPVxuICAgICAgbGV0IGogPSBtYXhzb24gbCBpIGluXG4gICAgICBzZXQgYSBpIChnZXQgYSBqKTtcbiAgICAgIGJ1YmJsZWRvd24gbCBqXG4gICAgaW5cbiAgICBsZXQgYnViYmxlIGwgaSA9IHRyeSBidWJibGVkb3duIGwgaSB3aXRoIEJvdHRvbSBpIC0+IGkgaW5cbiAgICBsZXQgcmVjIHRyaWNrbGV1cCBpIGUgPVxuICAgICAgbGV0IGZhdGhlciA9IChpIC0gMSkgLyAzIGluXG4gICAgICBhc3NlcnQgKGkgPD4gZmF0aGVyKTtcbiAgICAgIGlmIGNtcCAoZ2V0IGEgZmF0aGVyKSBlIDwgMCB0aGVuIGJlZ2luXG4gICAgICAgIHNldCBhIGkgKGdldCBhIGZhdGhlcik7XG4gICAgICAgIGlmIGZhdGhlciA+IDAgdGhlbiB0cmlja2xldXAgZmF0aGVyIGUgZWxzZSBzZXQgYSAwIGU7XG4gICAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgICBzZXQgYSBpIGU7XG4gICAgICBlbmQ7XG4gICAgaW5cbiAgICBsZXQgbCA9IGxlbmd0aCBhIGluXG4gICAgZm9yIGkgPSAobCArIDEpIC8gMyAtIDEgZG93bnRvIDAgZG8gdHJpY2tsZSBsIGkgKGdldCBhIGkpOyBkb25lO1xuICAgIGZvciBpID0gbCAtIDEgZG93bnRvIDIgZG9cbiAgICAgIGxldCBlID0gKGdldCBhIGkpIGluXG4gICAgICBzZXQgYSBpIChnZXQgYSAwKTtcbiAgICAgIHRyaWNrbGV1cCAoYnViYmxlIGkgMCkgZTtcbiAgICBkb25lO1xuICAgIGlmIGwgPiAxIHRoZW4gKGxldCBlID0gKGdldCBhIDEpIGluIHNldCBhIDEgKGdldCBhIDApOyBzZXQgYSAwIGUpXG5cbiAgKCogZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sLCBleGNlcHQgZm9yIHRoZSBjYWxsIHRvIFtjcmVhdGVdICopXG4gIGxldCBjdXRvZmYgPSA1XG4gIGxldCBzdGFibGVfc29ydCBjbXAgYSA9XG4gICAgbGV0IG1lcmdlIHNyYzFvZnMgc3JjMWxlbiBzcmMyIHNyYzJvZnMgc3JjMmxlbiBkc3QgZHN0b2ZzID1cbiAgICAgIGxldCBzcmMxciA9IHNyYzFvZnMgKyBzcmMxbGVuIGFuZCBzcmMyciA9IHNyYzJvZnMgKyBzcmMybGVuIGluXG4gICAgICBsZXQgcmVjIGxvb3AgaTEgczEgaTIgczIgZCA9XG4gICAgICAgIGlmIGNtcCBzMSBzMiA8PSAwIHRoZW4gYmVnaW5cbiAgICAgICAgICBzZXQgZHN0IGQgczE7XG4gICAgICAgICAgbGV0IGkxID0gaTEgKyAxIGluXG4gICAgICAgICAgaWYgaTEgPCBzcmMxciB0aGVuXG4gICAgICAgICAgICBsb29wIGkxIChnZXQgYSBpMSkgaTIgczIgKGQgKyAxKVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGJsaXQgc3JjMiBpMiBkc3QgKGQgKyAxKSAoc3JjMnIgLSBpMilcbiAgICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgICBzZXQgZHN0IGQgczI7XG4gICAgICAgICAgbGV0IGkyID0gaTIgKyAxIGluXG4gICAgICAgICAgaWYgaTIgPCBzcmMyciB0aGVuXG4gICAgICAgICAgICBsb29wIGkxIHMxIGkyIChnZXQgc3JjMiBpMikgKGQgKyAxKVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGJsaXQgYSBpMSBkc3QgKGQgKyAxKSAoc3JjMXIgLSBpMSlcbiAgICAgICAgZW5kXG4gICAgICBpbiBsb29wIHNyYzFvZnMgKGdldCBhIHNyYzFvZnMpIHNyYzJvZnMgKGdldCBzcmMyIHNyYzJvZnMpIGRzdG9mcztcbiAgICBpblxuICAgIGxldCBpc29ydHRvIHNyY29mcyBkc3QgZHN0b2ZzIGxlbiA9XG4gICAgICBmb3IgaSA9IDAgdG8gbGVuIC0gMSBkb1xuICAgICAgICBsZXQgZSA9IChnZXQgYSAoc3Jjb2ZzICsgaSkpIGluXG4gICAgICAgIGxldCBqID0gcmVmIChkc3RvZnMgKyBpIC0gMSkgaW5cbiAgICAgICAgd2hpbGUgKCFqID49IGRzdG9mcyAmJiBjbXAgKGdldCBkc3QgIWopIGUgPiAwKSBkb1xuICAgICAgICAgIHNldCBkc3QgKCFqICsgMSkgKGdldCBkc3QgIWopO1xuICAgICAgICAgIGRlY3IgajtcbiAgICAgICAgZG9uZTtcbiAgICAgICAgc2V0IGRzdCAoIWogKyAxKSBlO1xuICAgICAgZG9uZTtcbiAgICBpblxuICAgIGxldCByZWMgc29ydHRvIHNyY29mcyBkc3QgZHN0b2ZzIGxlbiA9XG4gICAgICBpZiBsZW4gPD0gY3V0b2ZmIHRoZW4gaXNvcnR0byBzcmNvZnMgZHN0IGRzdG9mcyBsZW4gZWxzZSBiZWdpblxuICAgICAgICBsZXQgbDEgPSBsZW4gLyAyIGluXG4gICAgICAgIGxldCBsMiA9IGxlbiAtIGwxIGluXG4gICAgICAgIHNvcnR0byAoc3Jjb2ZzICsgbDEpIGRzdCAoZHN0b2ZzICsgbDEpIGwyO1xuICAgICAgICBzb3J0dG8gc3Jjb2ZzIGEgKHNyY29mcyArIGwyKSBsMTtcbiAgICAgICAgbWVyZ2UgKHNyY29mcyArIGwyKSBsMSBkc3QgKGRzdG9mcyArIGwxKSBsMiBkc3QgZHN0b2ZzO1xuICAgICAgZW5kO1xuICAgIGluXG4gICAgbGV0IGwgPSBsZW5ndGggYSBpblxuICAgIGlmIGwgPD0gY3V0b2ZmIHRoZW4gaXNvcnR0byAwIGEgMCBsIGVsc2UgYmVnaW5cbiAgICAgIGxldCBsMSA9IGwgLyAyIGluXG4gICAgICBsZXQgbDIgPSBsIC0gbDEgaW5cbiAgICAgIGxldCB0ID0gY3JlYXRlIGwyIGluXG4gICAgICBzb3J0dG8gbDEgdCAwIGwyO1xuICAgICAgc29ydHRvIDAgYSBsMiBsMTtcbiAgICAgIG1lcmdlIGwyIGwxIHQgMCBsMiBhIDA7XG4gICAgZW5kXG5cbiAgbGV0IGZhc3Rfc29ydCA9IHN0YWJsZV9zb3J0XG5cbiAgKCogZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sICopXG4gIGxldCB0b19zZXEgYSA9XG4gICAgbGV0IHJlYyBhdXggaSAoKSA9XG4gICAgICBpZiBpIDwgbGVuZ3RoIGFcbiAgICAgIHRoZW5cbiAgICAgICAgbGV0IHggPSB1bnNhZmVfZ2V0IGEgaSBpblxuICAgICAgICBTZXEuQ29ucyAoeCwgYXV4IChpKzEpKVxuICAgICAgZWxzZSBTZXEuTmlsXG4gICAgaW5cbiAgICBhdXggMFxuXG4gICgqIGR1cGxpY2F0ZWQgZnJvbSBhcnJheS5tbCAqKVxuICBsZXQgdG9fc2VxaSBhID1cbiAgICBsZXQgcmVjIGF1eCBpICgpID1cbiAgICAgIGlmIGkgPCBsZW5ndGggYVxuICAgICAgdGhlblxuICAgICAgICBsZXQgeCA9IHVuc2FmZV9nZXQgYSBpIGluXG4gICAgICAgIFNlcS5Db25zICgoaSx4KSwgYXV4IChpKzEpKVxuICAgICAgZWxzZSBTZXEuTmlsXG4gICAgaW5cbiAgICBhdXggMFxuXG4gICgqIG1vc3RseSBkdXBsaWNhdGVkIGZyb20gYXJyYXkubWwgKilcbiAgbGV0IG9mX3Jldl9saXN0IGwgPVxuICAgIGxldCBsZW4gPSBMaXN0Lmxlbmd0aCBsIGluXG4gICAgbGV0IGEgPSBjcmVhdGUgbGVuIGluXG4gICAgbGV0IHJlYyBmaWxsIGkgPSBmdW5jdGlvblxuICAgICAgICBbXSAtPiBhXG4gICAgICB8IGhkOjp0bCAtPiB1bnNhZmVfc2V0IGEgaSBoZDsgZmlsbCAoaS0xKSB0bFxuICAgIGluXG4gICAgZmlsbCAobGVuLTEpIGxcblxuICAoKiBkdXBsaWNhdGVkIGZyb20gYXJyYXkubWwgKilcbiAgbGV0IG9mX3NlcSBpID1cbiAgICBsZXQgbCA9IFNlcS5mb2xkX2xlZnQgKGZ1biBhY2MgeCAtPiB4OjphY2MpIFtdIGkgaW5cbiAgICBvZl9yZXZfbGlzdCBsXG5cblxuICBsZXQgbWFwX3RvX2FycmF5IGYgYSA9XG4gICAgbGV0IGwgPSBsZW5ndGggYSBpblxuICAgIGlmIGwgPSAwIHRoZW4gW3wgfF0gZWxzZSBiZWdpblxuICAgICAgbGV0IHIgPSBBcnJheS5tYWtlIGwgKGYgKHVuc2FmZV9nZXQgYSAwKSkgaW5cbiAgICAgIGZvciBpID0gMSB0byBsIC0gMSBkb1xuICAgICAgICBBcnJheS51bnNhZmVfc2V0IHIgaSAoZiAodW5zYWZlX2dldCBhIGkpKVxuICAgICAgZG9uZTtcbiAgICAgIHJcbiAgICBlbmRcblxuICBsZXQgbWFwX2Zyb21fYXJyYXkgZiBhID1cbiAgICBsZXQgbCA9IEFycmF5Lmxlbmd0aCBhIGluXG4gICAgbGV0IHIgPSBjcmVhdGUgbCBpblxuICAgIGZvciBpID0gMCB0byBsIC0gMSBkb1xuICAgICAgdW5zYWZlX3NldCByIGkgKGYgKEFycmF5LnVuc2FmZV9nZXQgYSBpKSlcbiAgICBkb25lO1xuICAgIHJcblxuZW5kXG5cbm1vZHVsZSBBcnJheUxhYmVscyA9IEFycmF5XG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIE1vZHVsZSBbTmF0aXZlaW50XTogcHJvY2Vzc29yLW5hdGl2ZSBpbnRlZ2VycyAqKVxuXG5leHRlcm5hbCBuZWc6IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfbmVnXCJcbmV4dGVybmFsIGFkZDogbmF0aXZlaW50IC0+IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfYWRkXCJcbmV4dGVybmFsIHN1YjogbmF0aXZlaW50IC0+IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfc3ViXCJcbmV4dGVybmFsIG11bDogbmF0aXZlaW50IC0+IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfbXVsXCJcbmV4dGVybmFsIGRpdjogbmF0aXZlaW50IC0+IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfZGl2XCJcbmV4dGVybmFsIHJlbTogbmF0aXZlaW50IC0+IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfbW9kXCJcbmV4dGVybmFsIGxvZ2FuZDogbmF0aXZlaW50IC0+IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfYW5kXCJcbmV4dGVybmFsIGxvZ29yOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9vclwiXG5leHRlcm5hbCBsb2d4b3I6IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X3hvclwiXG5leHRlcm5hbCBzaGlmdF9sZWZ0OiBuYXRpdmVpbnQgLT4gaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9sc2xcIlxuZXh0ZXJuYWwgc2hpZnRfcmlnaHQ6IG5hdGl2ZWludCAtPiBpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X2FzclwiXG5leHRlcm5hbCBzaGlmdF9yaWdodF9sb2dpY2FsOiBuYXRpdmVpbnQgLT4gaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9sc3JcIlxuZXh0ZXJuYWwgb2ZfaW50OiBpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X29mX2ludFwiXG5leHRlcm5hbCB0b19pbnQ6IG5hdGl2ZWludCAtPiBpbnQgPSBcIiVuYXRpdmVpbnRfdG9faW50XCJcbmV4dGVybmFsIG9mX2Zsb2F0IDogZmxvYXQgLT4gbmF0aXZlaW50XG4gID0gXCJjYW1sX25hdGl2ZWludF9vZl9mbG9hdFwiIFwiY2FtbF9uYXRpdmVpbnRfb2ZfZmxvYXRfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCB0b19mbG9hdCA6IG5hdGl2ZWludCAtPiBmbG9hdFxuICA9IFwiY2FtbF9uYXRpdmVpbnRfdG9fZmxvYXRcIiBcImNhbWxfbmF0aXZlaW50X3RvX2Zsb2F0X3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgb2ZfaW50MzI6IGludDMyIC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9vZl9pbnQzMlwiXG5leHRlcm5hbCB0b19pbnQzMjogbmF0aXZlaW50IC0+IGludDMyID0gXCIlbmF0aXZlaW50X3RvX2ludDMyXCJcblxubGV0IHplcm8gPSAwblxubGV0IG9uZSA9IDFuXG5sZXQgbWludXNfb25lID0gLTFuXG5sZXQgc3VjYyBuID0gYWRkIG4gMW5cbmxldCBwcmVkIG4gPSBzdWIgbiAxblxubGV0IGFicyBuID0gaWYgbiA+PSAwbiB0aGVuIG4gZWxzZSBuZWcgblxubGV0IHNpemUgPSBTeXMud29yZF9zaXplXG5sZXQgbWluX2ludCA9IHNoaWZ0X2xlZnQgMW4gKHNpemUgLSAxKVxubGV0IG1heF9pbnQgPSBzdWIgbWluX2ludCAxblxubGV0IGxvZ25vdCBuID0gbG9neG9yIG4gKC0xbilcblxubGV0IHVuc2lnbmVkX3RvX2ludCA9XG4gIGxldCBtYXhfaW50ID0gb2ZfaW50IFN0ZGxpYi5tYXhfaW50IGluXG4gIGZ1biBuIC0+XG4gICAgaWYgY29tcGFyZSB6ZXJvIG4gPD0gMCAmJiBjb21wYXJlIG4gbWF4X2ludCA8PSAwIHRoZW5cbiAgICAgIFNvbWUgKHRvX2ludCBuKVxuICAgIGVsc2VcbiAgICAgIE5vbmVcblxuZXh0ZXJuYWwgZm9ybWF0IDogc3RyaW5nIC0+IG5hdGl2ZWludCAtPiBzdHJpbmcgPSBcImNhbWxfbmF0aXZlaW50X2Zvcm1hdFwiXG5sZXQgdG9fc3RyaW5nIG4gPSBmb3JtYXQgXCIlZFwiIG5cblxuZXh0ZXJuYWwgb2Zfc3RyaW5nOiBzdHJpbmcgLT4gbmF0aXZlaW50ID0gXCJjYW1sX25hdGl2ZWludF9vZl9zdHJpbmdcIlxuXG5sZXQgb2Zfc3RyaW5nX29wdCBzID1cbiAgKCogVE9ETzogZXhwb3NlIGEgbm9uLXJhaXNpbmcgcHJpbWl0aXZlIGRpcmVjdGx5LiAqKVxuICB0cnkgU29tZSAob2Zfc3RyaW5nIHMpXG4gIHdpdGggRmFpbHVyZSBfIC0+IE5vbmVcblxudHlwZSB0ID0gbmF0aXZlaW50XG5cbmxldCBjb21wYXJlICh4OiB0KSAoeTogdCkgPSBTdGRsaWIuY29tcGFyZSB4IHlcbmxldCBlcXVhbCAoeDogdCkgKHk6IHQpID0gY29tcGFyZSB4IHkgPSAwXG5cbmxldCB1bnNpZ25lZF9jb21wYXJlIG4gbSA9XG4gIGNvbXBhcmUgKHN1YiBuIG1pbl9pbnQpIChzdWIgbSBtaW5faW50KVxuXG4oKiBVbnNpZ25lZCBkaXZpc2lvbiBmcm9tIHNpZ25lZCBkaXZpc2lvbiBvZiB0aGUgc2FtZVxuICAgYml0bmVzcy4gU2VlIFdhcnJlbiBKci4sIEhlbnJ5IFMuICgyMDEzKS4gSGFja2VyJ3MgRGVsaWdodCAoMiBlZC4pLCBTZWMgOS0zLlxuKilcbmxldCB1bnNpZ25lZF9kaXYgbiBkID1cbiAgaWYgZCA8IHplcm8gdGhlblxuICAgIGlmIHVuc2lnbmVkX2NvbXBhcmUgbiBkIDwgMCB0aGVuIHplcm8gZWxzZSBvbmVcbiAgZWxzZVxuICAgIGxldCBxID0gc2hpZnRfbGVmdCAoZGl2IChzaGlmdF9yaWdodF9sb2dpY2FsIG4gMSkgZCkgMSBpblxuICAgIGxldCByID0gc3ViIG4gKG11bCBxIGQpIGluXG4gICAgaWYgdW5zaWduZWRfY29tcGFyZSByIGQgPj0gMCB0aGVuIHN1Y2MgcSBlbHNlIHFcblxubGV0IHVuc2lnbmVkX3JlbSBuIGQgPVxuICBzdWIgbiAobXVsICh1bnNpZ25lZF9kaXYgbiBkKSBkKVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBBbiBhbGlhcyBmb3IgdGhlIHR5cGUgb2YgbGlzdHMuICopXG50eXBlICdhIHQgPSAnYSBsaXN0ID0gW10gfCAoOjopIG9mICdhICogJ2EgbGlzdFxuXG4oKiBMaXN0IG9wZXJhdGlvbnMgKilcblxubGV0IHJlYyBsZW5ndGhfYXV4IGxlbiA9IGZ1bmN0aW9uXG4gICAgW10gLT4gbGVuXG4gIHwgXzo6bCAtPiBsZW5ndGhfYXV4IChsZW4gKyAxKSBsXG5cbmxldCBsZW5ndGggbCA9IGxlbmd0aF9hdXggMCBsXG5cbmxldCBjb25zIGEgbCA9IGE6OmxcblxubGV0IGhkID0gZnVuY3Rpb25cbiAgICBbXSAtPiBmYWlsd2l0aCBcImhkXCJcbiAgfCBhOjpfIC0+IGFcblxubGV0IHRsID0gZnVuY3Rpb25cbiAgICBbXSAtPiBmYWlsd2l0aCBcInRsXCJcbiAgfCBfOjpsIC0+IGxcblxubGV0IG50aCBsIG4gPVxuICBpZiBuIDwgMCB0aGVuIGludmFsaWRfYXJnIFwiTGlzdC5udGhcIiBlbHNlXG4gIGxldCByZWMgbnRoX2F1eCBsIG4gPVxuICAgIG1hdGNoIGwgd2l0aFxuICAgIHwgW10gLT4gZmFpbHdpdGggXCJudGhcIlxuICAgIHwgYTo6bCAtPiBpZiBuID0gMCB0aGVuIGEgZWxzZSBudGhfYXV4IGwgKG4tMSlcbiAgaW4gbnRoX2F1eCBsIG5cblxubGV0IG50aF9vcHQgbCBuID1cbiAgaWYgbiA8IDAgdGhlbiBpbnZhbGlkX2FyZyBcIkxpc3QubnRoXCIgZWxzZVxuICBsZXQgcmVjIG50aF9hdXggbCBuID1cbiAgICBtYXRjaCBsIHdpdGhcbiAgICB8IFtdIC0+IE5vbmVcbiAgICB8IGE6OmwgLT4gaWYgbiA9IDAgdGhlbiBTb21lIGEgZWxzZSBudGhfYXV4IGwgKG4tMSlcbiAgaW4gbnRoX2F1eCBsIG5cblxubGV0IGFwcGVuZCA9IChAKVxuXG5sZXQgcmVjIHJldl9hcHBlbmQgbDEgbDIgPVxuICBtYXRjaCBsMSB3aXRoXG4gICAgW10gLT4gbDJcbiAgfCBhIDo6IGwgLT4gcmV2X2FwcGVuZCBsIChhIDo6IGwyKVxuXG5sZXQgcmV2IGwgPSByZXZfYXBwZW5kIGwgW11cblxubGV0IHJlYyBpbml0X3RhaWxyZWNfYXV4IGFjYyBpIG4gZiA9XG4gIGlmIGkgPj0gbiB0aGVuIGFjY1xuICBlbHNlIGluaXRfdGFpbHJlY19hdXggKGYgaSA6OiBhY2MpIChpKzEpIG4gZlxuXG5sZXQgcmVjIGluaXRfYXV4IGkgbiBmID1cbiAgaWYgaSA+PSBuIHRoZW4gW11cbiAgZWxzZVxuICAgIGxldCByID0gZiBpIGluXG4gICAgciA6OiBpbml0X2F1eCAoaSsxKSBuIGZcblxubGV0IHJldl9pbml0X3RocmVzaG9sZCA9XG4gIG1hdGNoIFN5cy5iYWNrZW5kX3R5cGUgd2l0aFxuICB8IFN5cy5OYXRpdmUgfCBTeXMuQnl0ZWNvZGUgLT4gMTBfMDAwXG4gICgqIFdlIGRvbid0IGtub3cgdGhlIHNpemUgb2YgdGhlIHN0YWNrLCBiZXR0ZXIgYmUgc2FmZSBhbmQgYXNzdW1lIGl0J3NcbiAgICAgc21hbGwuICopXG4gIHwgU3lzLk90aGVyIF8gLT4gNTBcblxubGV0IGluaXQgbGVuIGYgPVxuICBpZiBsZW4gPCAwIHRoZW4gaW52YWxpZF9hcmcgXCJMaXN0LmluaXRcIiBlbHNlXG4gIGlmIGxlbiA+IHJldl9pbml0X3RocmVzaG9sZCB0aGVuIHJldiAoaW5pdF90YWlscmVjX2F1eCBbXSAwIGxlbiBmKVxuICBlbHNlIGluaXRfYXV4IDAgbGVuIGZcblxubGV0IHJlYyBmbGF0dGVuID0gZnVuY3Rpb25cbiAgICBbXSAtPiBbXVxuICB8IGw6OnIgLT4gbCBAIGZsYXR0ZW4gclxuXG5sZXQgY29uY2F0ID0gZmxhdHRlblxuXG5sZXQgcmVjIG1hcCBmID0gZnVuY3Rpb25cbiAgICBbXSAtPiBbXVxuICB8IGE6OmwgLT4gbGV0IHIgPSBmIGEgaW4gciA6OiBtYXAgZiBsXG5cbmxldCByZWMgbWFwaSBpIGYgPSBmdW5jdGlvblxuICAgIFtdIC0+IFtdXG4gIHwgYTo6bCAtPiBsZXQgciA9IGYgaSBhIGluIHIgOjogbWFwaSAoaSArIDEpIGYgbFxuXG5sZXQgbWFwaSBmIGwgPSBtYXBpIDAgZiBsXG5cbmxldCByZXZfbWFwIGYgbCA9XG4gIGxldCByZWMgcm1hcF9mIGFjY3UgPSBmdW5jdGlvblxuICAgIHwgW10gLT4gYWNjdVxuICAgIHwgYTo6bCAtPiBybWFwX2YgKGYgYSA6OiBhY2N1KSBsXG4gIGluXG4gIHJtYXBfZiBbXSBsXG5cblxubGV0IHJlYyBpdGVyIGYgPSBmdW5jdGlvblxuICAgIFtdIC0+ICgpXG4gIHwgYTo6bCAtPiBmIGE7IGl0ZXIgZiBsXG5cbmxldCByZWMgaXRlcmkgaSBmID0gZnVuY3Rpb25cbiAgICBbXSAtPiAoKVxuICB8IGE6OmwgLT4gZiBpIGE7IGl0ZXJpIChpICsgMSkgZiBsXG5cbmxldCBpdGVyaSBmIGwgPSBpdGVyaSAwIGYgbFxuXG5sZXQgcmVjIGZvbGRfbGVmdCBmIGFjY3UgbCA9XG4gIG1hdGNoIGwgd2l0aFxuICAgIFtdIC0+IGFjY3VcbiAgfCBhOjpsIC0+IGZvbGRfbGVmdCBmIChmIGFjY3UgYSkgbFxuXG5sZXQgcmVjIGZvbGRfcmlnaHQgZiBsIGFjY3UgPVxuICBtYXRjaCBsIHdpdGhcbiAgICBbXSAtPiBhY2N1XG4gIHwgYTo6bCAtPiBmIGEgKGZvbGRfcmlnaHQgZiBsIGFjY3UpXG5cbmxldCByZWMgbWFwMiBmIGwxIGwyID1cbiAgbWF0Y2ggKGwxLCBsMikgd2l0aFxuICAgIChbXSwgW10pIC0+IFtdXG4gIHwgKGExOjpsMSwgYTI6OmwyKSAtPiBsZXQgciA9IGYgYTEgYTIgaW4gciA6OiBtYXAyIGYgbDEgbDJcbiAgfCAoXywgXykgLT4gaW52YWxpZF9hcmcgXCJMaXN0Lm1hcDJcIlxuXG5sZXQgcmV2X21hcDIgZiBsMSBsMiA9XG4gIGxldCByZWMgcm1hcDJfZiBhY2N1IGwxIGwyID1cbiAgICBtYXRjaCAobDEsIGwyKSB3aXRoXG4gICAgfCAoW10sIFtdKSAtPiBhY2N1XG4gICAgfCAoYTE6OmwxLCBhMjo6bDIpIC0+IHJtYXAyX2YgKGYgYTEgYTIgOjogYWNjdSkgbDEgbDJcbiAgICB8IChfLCBfKSAtPiBpbnZhbGlkX2FyZyBcIkxpc3QucmV2X21hcDJcIlxuICBpblxuICBybWFwMl9mIFtdIGwxIGwyXG5cblxubGV0IHJlYyBpdGVyMiBmIGwxIGwyID1cbiAgbWF0Y2ggKGwxLCBsMikgd2l0aFxuICAgIChbXSwgW10pIC0+ICgpXG4gIHwgKGExOjpsMSwgYTI6OmwyKSAtPiBmIGExIGEyOyBpdGVyMiBmIGwxIGwyXG4gIHwgKF8sIF8pIC0+IGludmFsaWRfYXJnIFwiTGlzdC5pdGVyMlwiXG5cbmxldCByZWMgZm9sZF9sZWZ0MiBmIGFjY3UgbDEgbDIgPVxuICBtYXRjaCAobDEsIGwyKSB3aXRoXG4gICAgKFtdLCBbXSkgLT4gYWNjdVxuICB8IChhMTo6bDEsIGEyOjpsMikgLT4gZm9sZF9sZWZ0MiBmIChmIGFjY3UgYTEgYTIpIGwxIGwyXG4gIHwgKF8sIF8pIC0+IGludmFsaWRfYXJnIFwiTGlzdC5mb2xkX2xlZnQyXCJcblxubGV0IHJlYyBmb2xkX3JpZ2h0MiBmIGwxIGwyIGFjY3UgPVxuICBtYXRjaCAobDEsIGwyKSB3aXRoXG4gICAgKFtdLCBbXSkgLT4gYWNjdVxuICB8IChhMTo6bDEsIGEyOjpsMikgLT4gZiBhMSBhMiAoZm9sZF9yaWdodDIgZiBsMSBsMiBhY2N1KVxuICB8IChfLCBfKSAtPiBpbnZhbGlkX2FyZyBcIkxpc3QuZm9sZF9yaWdodDJcIlxuXG5sZXQgcmVjIGZvcl9hbGwgcCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gdHJ1ZVxuICB8IGE6OmwgLT4gcCBhICYmIGZvcl9hbGwgcCBsXG5cbmxldCByZWMgZXhpc3RzIHAgPSBmdW5jdGlvblxuICAgIFtdIC0+IGZhbHNlXG4gIHwgYTo6bCAtPiBwIGEgfHwgZXhpc3RzIHAgbFxuXG5sZXQgcmVjIGZvcl9hbGwyIHAgbDEgbDIgPVxuICBtYXRjaCAobDEsIGwyKSB3aXRoXG4gICAgKFtdLCBbXSkgLT4gdHJ1ZVxuICB8IChhMTo6bDEsIGEyOjpsMikgLT4gcCBhMSBhMiAmJiBmb3JfYWxsMiBwIGwxIGwyXG4gIHwgKF8sIF8pIC0+IGludmFsaWRfYXJnIFwiTGlzdC5mb3JfYWxsMlwiXG5cbmxldCByZWMgZXhpc3RzMiBwIGwxIGwyID1cbiAgbWF0Y2ggKGwxLCBsMikgd2l0aFxuICAgIChbXSwgW10pIC0+IGZhbHNlXG4gIHwgKGExOjpsMSwgYTI6OmwyKSAtPiBwIGExIGEyIHx8IGV4aXN0czIgcCBsMSBsMlxuICB8IChfLCBfKSAtPiBpbnZhbGlkX2FyZyBcIkxpc3QuZXhpc3RzMlwiXG5cbmxldCByZWMgbWVtIHggPSBmdW5jdGlvblxuICAgIFtdIC0+IGZhbHNlXG4gIHwgYTo6bCAtPiBjb21wYXJlIGEgeCA9IDAgfHwgbWVtIHggbFxuXG5sZXQgcmVjIG1lbXEgeCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gZmFsc2VcbiAgfCBhOjpsIC0+IGEgPT0geCB8fCBtZW1xIHggbFxuXG5sZXQgcmVjIGFzc29jIHggPSBmdW5jdGlvblxuICAgIFtdIC0+IHJhaXNlIE5vdF9mb3VuZFxuICB8IChhLGIpOjpsIC0+IGlmIGNvbXBhcmUgYSB4ID0gMCB0aGVuIGIgZWxzZSBhc3NvYyB4IGxcblxubGV0IHJlYyBhc3NvY19vcHQgeCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gTm9uZVxuICB8IChhLGIpOjpsIC0+IGlmIGNvbXBhcmUgYSB4ID0gMCB0aGVuIFNvbWUgYiBlbHNlIGFzc29jX29wdCB4IGxcblxubGV0IHJlYyBhc3NxIHggPSBmdW5jdGlvblxuICAgIFtdIC0+IHJhaXNlIE5vdF9mb3VuZFxuICB8IChhLGIpOjpsIC0+IGlmIGEgPT0geCB0aGVuIGIgZWxzZSBhc3NxIHggbFxuXG5sZXQgcmVjIGFzc3Ffb3B0IHggPSBmdW5jdGlvblxuICAgIFtdIC0+IE5vbmVcbiAgfCAoYSxiKTo6bCAtPiBpZiBhID09IHggdGhlbiBTb21lIGIgZWxzZSBhc3NxX29wdCB4IGxcblxubGV0IHJlYyBtZW1fYXNzb2MgeCA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gZmFsc2VcbiAgfCAoYSwgXykgOjogbCAtPiBjb21wYXJlIGEgeCA9IDAgfHwgbWVtX2Fzc29jIHggbFxuXG5sZXQgcmVjIG1lbV9hc3NxIHggPSBmdW5jdGlvblxuICB8IFtdIC0+IGZhbHNlXG4gIHwgKGEsIF8pIDo6IGwgLT4gYSA9PSB4IHx8IG1lbV9hc3NxIHggbFxuXG5sZXQgcmVjIHJlbW92ZV9hc3NvYyB4ID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBbXVxuICB8IChhLCBfIGFzIHBhaXIpIDo6IGwgLT5cbiAgICAgIGlmIGNvbXBhcmUgYSB4ID0gMCB0aGVuIGwgZWxzZSBwYWlyIDo6IHJlbW92ZV9hc3NvYyB4IGxcblxubGV0IHJlYyByZW1vdmVfYXNzcSB4ID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBbXVxuICB8IChhLCBfIGFzIHBhaXIpIDo6IGwgLT4gaWYgYSA9PSB4IHRoZW4gbCBlbHNlIHBhaXIgOjogcmVtb3ZlX2Fzc3EgeCBsXG5cbmxldCByZWMgZmluZCBwID0gZnVuY3Rpb25cbiAgfCBbXSAtPiByYWlzZSBOb3RfZm91bmRcbiAgfCB4IDo6IGwgLT4gaWYgcCB4IHRoZW4geCBlbHNlIGZpbmQgcCBsXG5cbmxldCByZWMgZmluZF9vcHQgcCA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gTm9uZVxuICB8IHggOjogbCAtPiBpZiBwIHggdGhlbiBTb21lIHggZWxzZSBmaW5kX29wdCBwIGxcblxubGV0IHJlYyBmaW5kX21hcCBmID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBOb25lXG4gIHwgeCA6OiBsIC0+XG4gICAgIGJlZ2luIG1hdGNoIGYgeCB3aXRoXG4gICAgICAgfCBTb21lIF8gYXMgcmVzdWx0IC0+IHJlc3VsdFxuICAgICAgIHwgTm9uZSAtPiBmaW5kX21hcCBmIGxcbiAgICAgZW5kXG5cbmxldCBmaW5kX2FsbCBwID1cbiAgbGV0IHJlYyBmaW5kIGFjY3UgPSBmdW5jdGlvblxuICB8IFtdIC0+IHJldiBhY2N1XG4gIHwgeCA6OiBsIC0+IGlmIHAgeCB0aGVuIGZpbmQgKHggOjogYWNjdSkgbCBlbHNlIGZpbmQgYWNjdSBsIGluXG4gIGZpbmQgW11cblxubGV0IGZpbHRlciA9IGZpbmRfYWxsXG5cbmxldCBmaWx0ZXJpIHAgbCA9XG4gIGxldCByZWMgYXV4IGkgYWNjID0gZnVuY3Rpb25cbiAgfCBbXSAtPiByZXYgYWNjXG4gIHwgeDo6bCAtPiBhdXggKGkgKyAxKSAoaWYgcCBpIHggdGhlbiB4OjphY2MgZWxzZSBhY2MpIGxcbiAgaW5cbiAgYXV4IDAgW10gbFxuXG5sZXQgZmlsdGVyX21hcCBmID1cbiAgbGV0IHJlYyBhdXggYWNjdSA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiByZXYgYWNjdVxuICAgIHwgeCA6OiBsIC0+XG4gICAgICAgIG1hdGNoIGYgeCB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiBhdXggYWNjdSBsXG4gICAgICAgIHwgU29tZSB2IC0+IGF1eCAodiA6OiBhY2N1KSBsXG4gIGluXG4gIGF1eCBbXVxuXG5sZXQgY29uY2F0X21hcCBmIGwgPVxuICBsZXQgcmVjIGF1eCBmIGFjYyA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiByZXYgYWNjXG4gICAgfCB4IDo6IGwgLT5cbiAgICAgICBsZXQgeHMgPSBmIHggaW5cbiAgICAgICBhdXggZiAocmV2X2FwcGVuZCB4cyBhY2MpIGxcbiAgaW4gYXV4IGYgW10gbFxuXG5sZXQgZm9sZF9sZWZ0X21hcCBmIGFjY3UgbCA9XG4gIGxldCByZWMgYXV4IGFjY3UgbF9hY2N1ID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IGFjY3UsIHJldiBsX2FjY3VcbiAgICB8IHggOjogbCAtPlxuICAgICAgICBsZXQgYWNjdSwgeCA9IGYgYWNjdSB4IGluXG4gICAgICAgIGF1eCBhY2N1ICh4IDo6IGxfYWNjdSkgbCBpblxuICBhdXggYWNjdSBbXSBsXG5cbmxldCBwYXJ0aXRpb24gcCBsID1cbiAgbGV0IHJlYyBwYXJ0IHllcyBubyA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gKHJldiB5ZXMsIHJldiBubylcbiAgfCB4IDo6IGwgLT4gaWYgcCB4IHRoZW4gcGFydCAoeCA6OiB5ZXMpIG5vIGwgZWxzZSBwYXJ0IHllcyAoeCA6OiBubykgbCBpblxuICBwYXJ0IFtdIFtdIGxcblxubGV0IHBhcnRpdGlvbl9tYXAgcCBsID1cbiAgbGV0IHJlYyBwYXJ0IGxlZnQgcmlnaHQgPSBmdW5jdGlvblxuICB8IFtdIC0+IChyZXYgbGVmdCwgcmV2IHJpZ2h0KVxuICB8IHggOjogbCAtPlxuICAgICBiZWdpbiBtYXRjaCBwIHggd2l0aFxuICAgICAgIHwgRWl0aGVyLkxlZnQgdiAtPiBwYXJ0ICh2IDo6IGxlZnQpIHJpZ2h0IGxcbiAgICAgICB8IEVpdGhlci5SaWdodCB2IC0+IHBhcnQgbGVmdCAodiA6OiByaWdodCkgbFxuICAgICBlbmRcbiAgaW5cbiAgcGFydCBbXSBbXSBsXG5cbmxldCByZWMgc3BsaXQgPSBmdW5jdGlvblxuICAgIFtdIC0+IChbXSwgW10pXG4gIHwgKHgseSk6OmwgLT5cbiAgICAgIGxldCAocngsIHJ5KSA9IHNwbGl0IGwgaW4gKHg6OnJ4LCB5OjpyeSlcblxubGV0IHJlYyBjb21iaW5lIGwxIGwyID1cbiAgbWF0Y2ggKGwxLCBsMikgd2l0aFxuICAgIChbXSwgW10pIC0+IFtdXG4gIHwgKGExOjpsMSwgYTI6OmwyKSAtPiAoYTEsIGEyKSA6OiBjb21iaW5lIGwxIGwyXG4gIHwgKF8sIF8pIC0+IGludmFsaWRfYXJnIFwiTGlzdC5jb21iaW5lXCJcblxuKCoqIHNvcnRpbmcgKilcblxubGV0IHJlYyBtZXJnZSBjbXAgbDEgbDIgPVxuICBtYXRjaCBsMSwgbDIgd2l0aFxuICB8IFtdLCBsMiAtPiBsMlxuICB8IGwxLCBbXSAtPiBsMVxuICB8IGgxIDo6IHQxLCBoMiA6OiB0MiAtPlxuICAgICAgaWYgY21wIGgxIGgyIDw9IDBcbiAgICAgIHRoZW4gaDEgOjogbWVyZ2UgY21wIHQxIGwyXG4gICAgICBlbHNlIGgyIDo6IG1lcmdlIGNtcCBsMSB0MlxuXG5cbmxldCBzdGFibGVfc29ydCBjbXAgbCA9XG4gIGxldCByZWMgcmV2X21lcmdlIGwxIGwyIGFjY3UgPVxuICAgIG1hdGNoIGwxLCBsMiB3aXRoXG4gICAgfCBbXSwgbDIgLT4gcmV2X2FwcGVuZCBsMiBhY2N1XG4gICAgfCBsMSwgW10gLT4gcmV2X2FwcGVuZCBsMSBhY2N1XG4gICAgfCBoMTo6dDEsIGgyOjp0MiAtPlxuICAgICAgICBpZiBjbXAgaDEgaDIgPD0gMFxuICAgICAgICB0aGVuIHJldl9tZXJnZSB0MSBsMiAoaDE6OmFjY3UpXG4gICAgICAgIGVsc2UgcmV2X21lcmdlIGwxIHQyIChoMjo6YWNjdSlcbiAgaW5cbiAgbGV0IHJlYyByZXZfbWVyZ2VfcmV2IGwxIGwyIGFjY3UgPVxuICAgIG1hdGNoIGwxLCBsMiB3aXRoXG4gICAgfCBbXSwgbDIgLT4gcmV2X2FwcGVuZCBsMiBhY2N1XG4gICAgfCBsMSwgW10gLT4gcmV2X2FwcGVuZCBsMSBhY2N1XG4gICAgfCBoMTo6dDEsIGgyOjp0MiAtPlxuICAgICAgICBpZiBjbXAgaDEgaDIgPiAwXG4gICAgICAgIHRoZW4gcmV2X21lcmdlX3JldiB0MSBsMiAoaDE6OmFjY3UpXG4gICAgICAgIGVsc2UgcmV2X21lcmdlX3JldiBsMSB0MiAoaDI6OmFjY3UpXG4gIGluXG4gIGxldCByZWMgc29ydCBuIGwgPVxuICAgIG1hdGNoIG4sIGwgd2l0aFxuICAgIHwgMiwgeDEgOjogeDIgOjogdGwgLT5cbiAgICAgICAgbGV0IHMgPSBpZiBjbXAgeDEgeDIgPD0gMCB0aGVuIFt4MTsgeDJdIGVsc2UgW3gyOyB4MV0gaW5cbiAgICAgICAgKHMsIHRsKVxuICAgIHwgMywgeDEgOjogeDIgOjogeDMgOjogdGwgLT5cbiAgICAgICAgbGV0IHMgPVxuICAgICAgICAgIGlmIGNtcCB4MSB4MiA8PSAwIHRoZW5cbiAgICAgICAgICAgIGlmIGNtcCB4MiB4MyA8PSAwIHRoZW4gW3gxOyB4MjsgeDNdXG4gICAgICAgICAgICBlbHNlIGlmIGNtcCB4MSB4MyA8PSAwIHRoZW4gW3gxOyB4MzsgeDJdXG4gICAgICAgICAgICBlbHNlIFt4MzsgeDE7IHgyXVxuICAgICAgICAgIGVsc2UgaWYgY21wIHgxIHgzIDw9IDAgdGhlbiBbeDI7IHgxOyB4M11cbiAgICAgICAgICBlbHNlIGlmIGNtcCB4MiB4MyA8PSAwIHRoZW4gW3gyOyB4MzsgeDFdXG4gICAgICAgICAgZWxzZSBbeDM7IHgyOyB4MV1cbiAgICAgICAgaW5cbiAgICAgICAgKHMsIHRsKVxuICAgIHwgbiwgbCAtPlxuICAgICAgICBsZXQgbjEgPSBuIGFzciAxIGluXG4gICAgICAgIGxldCBuMiA9IG4gLSBuMSBpblxuICAgICAgICBsZXQgczEsIGwyID0gcmV2X3NvcnQgbjEgbCBpblxuICAgICAgICBsZXQgczIsIHRsID0gcmV2X3NvcnQgbjIgbDIgaW5cbiAgICAgICAgKHJldl9tZXJnZV9yZXYgczEgczIgW10sIHRsKVxuICBhbmQgcmV2X3NvcnQgbiBsID1cbiAgICBtYXRjaCBuLCBsIHdpdGhcbiAgICB8IDIsIHgxIDo6IHgyIDo6IHRsIC0+XG4gICAgICAgIGxldCBzID0gaWYgY21wIHgxIHgyID4gMCB0aGVuIFt4MTsgeDJdIGVsc2UgW3gyOyB4MV0gaW5cbiAgICAgICAgKHMsIHRsKVxuICAgIHwgMywgeDEgOjogeDIgOjogeDMgOjogdGwgLT5cbiAgICAgICAgbGV0IHMgPVxuICAgICAgICAgIGlmIGNtcCB4MSB4MiA+IDAgdGhlblxuICAgICAgICAgICAgaWYgY21wIHgyIHgzID4gMCB0aGVuIFt4MTsgeDI7IHgzXVxuICAgICAgICAgICAgZWxzZSBpZiBjbXAgeDEgeDMgPiAwIHRoZW4gW3gxOyB4MzsgeDJdXG4gICAgICAgICAgICBlbHNlIFt4MzsgeDE7IHgyXVxuICAgICAgICAgIGVsc2UgaWYgY21wIHgxIHgzID4gMCB0aGVuIFt4MjsgeDE7IHgzXVxuICAgICAgICAgIGVsc2UgaWYgY21wIHgyIHgzID4gMCB0aGVuIFt4MjsgeDM7IHgxXVxuICAgICAgICAgIGVsc2UgW3gzOyB4MjsgeDFdXG4gICAgICAgIGluXG4gICAgICAgIChzLCB0bClcbiAgICB8IG4sIGwgLT5cbiAgICAgICAgbGV0IG4xID0gbiBhc3IgMSBpblxuICAgICAgICBsZXQgbjIgPSBuIC0gbjEgaW5cbiAgICAgICAgbGV0IHMxLCBsMiA9IHNvcnQgbjEgbCBpblxuICAgICAgICBsZXQgczIsIHRsID0gc29ydCBuMiBsMiBpblxuICAgICAgICAocmV2X21lcmdlIHMxIHMyIFtdLCB0bClcbiAgaW5cbiAgbGV0IGxlbiA9IGxlbmd0aCBsIGluXG4gIGlmIGxlbiA8IDIgdGhlbiBsIGVsc2UgZnN0IChzb3J0IGxlbiBsKVxuXG5cbmxldCBzb3J0ID0gc3RhYmxlX3NvcnRcbmxldCBmYXN0X3NvcnQgPSBzdGFibGVfc29ydFxuXG4oKiBOb3RlOiBvbiBhIGxpc3Qgb2YgbGVuZ3RoIGJldHdlZW4gYWJvdXQgMTAwMDAwIChkZXBlbmRpbmcgb24gdGhlIG1pbm9yXG4gICBoZWFwIHNpemUgYW5kIHRoZSB0eXBlIG9mIHRoZSBsaXN0KSBhbmQgU3lzLm1heF9hcnJheV9zaXplLCBpdCBpc1xuICAgYWN0dWFsbHkgZmFzdGVyIHRvIHVzZSB0aGUgZm9sbG93aW5nLCBidXQgaXQgbWlnaHQgYWxzbyB1c2UgbW9yZSBtZW1vcnlcbiAgIGJlY2F1c2UgdGhlIGFyZ3VtZW50IGxpc3QgY2Fubm90IGJlIGRlYWxsb2NhdGVkIGluY3JlbWVudGFsbHkuXG5cbiAgIEFsc28sIHRoZXJlIHNlZW1zIHRvIGJlIGEgYnVnIGluIHRoaXMgY29kZSBvciBpbiB0aGVcbiAgIGltcGxlbWVudGF0aW9uIG9mIG9ial90cnVuY2F0ZS5cblxuZXh0ZXJuYWwgb2JqX3RydW5jYXRlIDogJ2EgYXJyYXkgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfb2JqX3RydW5jYXRlXCJcblxubGV0IGFycmF5X3RvX2xpc3RfaW5fcGxhY2UgYSA9XG4gIGxldCBsID0gQXJyYXkubGVuZ3RoIGEgaW5cbiAgbGV0IHJlYyBsb29wIGFjY3UgbiBwID1cbiAgICBpZiBwIDw9IDAgdGhlbiBhY2N1IGVsc2UgYmVnaW5cbiAgICAgIGlmIHAgPSBuIHRoZW4gYmVnaW5cbiAgICAgICAgb2JqX3RydW5jYXRlIGEgcDtcbiAgICAgICAgbG9vcCAoYS4ocC0xKSA6OiBhY2N1KSAobi0xMDAwKSAocC0xKVxuICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgbG9vcCAoYS4ocC0xKSA6OiBhY2N1KSBuIChwLTEpXG4gICAgICBlbmRcbiAgICBlbmRcbiAgaW5cbiAgbG9vcCBbXSAobC0xMDAwKSBsXG5cblxubGV0IHN0YWJsZV9zb3J0IGNtcCBsID1cbiAgbGV0IGEgPSBBcnJheS5vZl9saXN0IGwgaW5cbiAgQXJyYXkuc3RhYmxlX3NvcnQgY21wIGE7XG4gIGFycmF5X3RvX2xpc3RfaW5fcGxhY2UgYVxuXG4qKVxuXG5cbigqKiBzb3J0aW5nICsgcmVtb3ZpbmcgZHVwbGljYXRlcyAqKVxuXG5sZXQgc29ydF91bmlxIGNtcCBsID1cbiAgbGV0IHJlYyByZXZfbWVyZ2UgbDEgbDIgYWNjdSA9XG4gICAgbWF0Y2ggbDEsIGwyIHdpdGhcbiAgICB8IFtdLCBsMiAtPiByZXZfYXBwZW5kIGwyIGFjY3VcbiAgICB8IGwxLCBbXSAtPiByZXZfYXBwZW5kIGwxIGFjY3VcbiAgICB8IGgxOjp0MSwgaDI6OnQyIC0+XG4gICAgICAgIGxldCBjID0gY21wIGgxIGgyIGluXG4gICAgICAgIGlmIGMgPSAwIHRoZW4gcmV2X21lcmdlIHQxIHQyIChoMTo6YWNjdSlcbiAgICAgICAgZWxzZSBpZiBjIDwgMFxuICAgICAgICB0aGVuIHJldl9tZXJnZSB0MSBsMiAoaDE6OmFjY3UpXG4gICAgICAgIGVsc2UgcmV2X21lcmdlIGwxIHQyIChoMjo6YWNjdSlcbiAgaW5cbiAgbGV0IHJlYyByZXZfbWVyZ2VfcmV2IGwxIGwyIGFjY3UgPVxuICAgIG1hdGNoIGwxLCBsMiB3aXRoXG4gICAgfCBbXSwgbDIgLT4gcmV2X2FwcGVuZCBsMiBhY2N1XG4gICAgfCBsMSwgW10gLT4gcmV2X2FwcGVuZCBsMSBhY2N1XG4gICAgfCBoMTo6dDEsIGgyOjp0MiAtPlxuICAgICAgICBsZXQgYyA9IGNtcCBoMSBoMiBpblxuICAgICAgICBpZiBjID0gMCB0aGVuIHJldl9tZXJnZV9yZXYgdDEgdDIgKGgxOjphY2N1KVxuICAgICAgICBlbHNlIGlmIGMgPiAwXG4gICAgICAgIHRoZW4gcmV2X21lcmdlX3JldiB0MSBsMiAoaDE6OmFjY3UpXG4gICAgICAgIGVsc2UgcmV2X21lcmdlX3JldiBsMSB0MiAoaDI6OmFjY3UpXG4gIGluXG4gIGxldCByZWMgc29ydCBuIGwgPVxuICAgIG1hdGNoIG4sIGwgd2l0aFxuICAgIHwgMiwgeDEgOjogeDIgOjogdGwgLT5cbiAgICAgICAgbGV0IHMgPVxuICAgICAgICAgIGxldCBjID0gY21wIHgxIHgyIGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiBbeDFdIGVsc2UgaWYgYyA8IDAgdGhlbiBbeDE7IHgyXSBlbHNlIFt4MjsgeDFdXG4gICAgICAgIGluXG4gICAgICAgIChzLCB0bClcbiAgICB8IDMsIHgxIDo6IHgyIDo6IHgzIDo6IHRsIC0+XG4gICAgICAgIGxldCBzID1cbiAgICAgICAgICBsZXQgYyA9IGNtcCB4MSB4MiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW5cbiAgICAgICAgICAgIGxldCBjID0gY21wIHgyIHgzIGluXG4gICAgICAgICAgICBpZiBjID0gMCB0aGVuIFt4Ml0gZWxzZSBpZiBjIDwgMCB0aGVuIFt4MjsgeDNdIGVsc2UgW3gzOyB4Ml1cbiAgICAgICAgICBlbHNlIGlmIGMgPCAwIHRoZW5cbiAgICAgICAgICAgIGxldCBjID0gY21wIHgyIHgzIGluXG4gICAgICAgICAgICBpZiBjID0gMCB0aGVuIFt4MTsgeDJdXG4gICAgICAgICAgICBlbHNlIGlmIGMgPCAwIHRoZW4gW3gxOyB4MjsgeDNdXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGxldCBjID0gY21wIHgxIHgzIGluXG4gICAgICAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gxOyB4Ml1cbiAgICAgICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuIFt4MTsgeDM7IHgyXVxuICAgICAgICAgICAgICBlbHNlIFt4MzsgeDE7IHgyXVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxldCBjID0gY21wIHgxIHgzIGluXG4gICAgICAgICAgICBpZiBjID0gMCB0aGVuIFt4MjsgeDFdXG4gICAgICAgICAgICBlbHNlIGlmIGMgPCAwIHRoZW4gW3gyOyB4MTsgeDNdXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGxldCBjID0gY21wIHgyIHgzIGluXG4gICAgICAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gyOyB4MV1cbiAgICAgICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuIFt4MjsgeDM7IHgxXVxuICAgICAgICAgICAgICBlbHNlIFt4MzsgeDI7IHgxXVxuICAgICAgICBpblxuICAgICAgICAocywgdGwpXG4gICAgfCBuLCBsIC0+XG4gICAgICAgIGxldCBuMSA9IG4gYXNyIDEgaW5cbiAgICAgICAgbGV0IG4yID0gbiAtIG4xIGluXG4gICAgICAgIGxldCBzMSwgbDIgPSByZXZfc29ydCBuMSBsIGluXG4gICAgICAgIGxldCBzMiwgdGwgPSByZXZfc29ydCBuMiBsMiBpblxuICAgICAgICAocmV2X21lcmdlX3JldiBzMSBzMiBbXSwgdGwpXG4gIGFuZCByZXZfc29ydCBuIGwgPVxuICAgIG1hdGNoIG4sIGwgd2l0aFxuICAgIHwgMiwgeDEgOjogeDIgOjogdGwgLT5cbiAgICAgICAgbGV0IHMgPVxuICAgICAgICAgIGxldCBjID0gY21wIHgxIHgyIGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiBbeDFdIGVsc2UgaWYgYyA+IDAgdGhlbiBbeDE7IHgyXSBlbHNlIFt4MjsgeDFdXG4gICAgICAgIGluXG4gICAgICAgIChzLCB0bClcbiAgICB8IDMsIHgxIDo6IHgyIDo6IHgzIDo6IHRsIC0+XG4gICAgICAgIGxldCBzID1cbiAgICAgICAgICBsZXQgYyA9IGNtcCB4MSB4MiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW5cbiAgICAgICAgICAgIGxldCBjID0gY21wIHgyIHgzIGluXG4gICAgICAgICAgICBpZiBjID0gMCB0aGVuIFt4Ml0gZWxzZSBpZiBjID4gMCB0aGVuIFt4MjsgeDNdIGVsc2UgW3gzOyB4Ml1cbiAgICAgICAgICBlbHNlIGlmIGMgPiAwIHRoZW5cbiAgICAgICAgICAgIGxldCBjID0gY21wIHgyIHgzIGluXG4gICAgICAgICAgICBpZiBjID0gMCB0aGVuIFt4MTsgeDJdXG4gICAgICAgICAgICBlbHNlIGlmIGMgPiAwIHRoZW4gW3gxOyB4MjsgeDNdXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGxldCBjID0gY21wIHgxIHgzIGluXG4gICAgICAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gxOyB4Ml1cbiAgICAgICAgICAgICAgZWxzZSBpZiBjID4gMCB0aGVuIFt4MTsgeDM7IHgyXVxuICAgICAgICAgICAgICBlbHNlIFt4MzsgeDE7IHgyXVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxldCBjID0gY21wIHgxIHgzIGluXG4gICAgICAgICAgICBpZiBjID0gMCB0aGVuIFt4MjsgeDFdXG4gICAgICAgICAgICBlbHNlIGlmIGMgPiAwIHRoZW4gW3gyOyB4MTsgeDNdXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGxldCBjID0gY21wIHgyIHgzIGluXG4gICAgICAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gyOyB4MV1cbiAgICAgICAgICAgICAgZWxzZSBpZiBjID4gMCB0aGVuIFt4MjsgeDM7IHgxXVxuICAgICAgICAgICAgICBlbHNlIFt4MzsgeDI7IHgxXVxuICAgICAgICBpblxuICAgICAgICAocywgdGwpXG4gICAgfCBuLCBsIC0+XG4gICAgICAgIGxldCBuMSA9IG4gYXNyIDEgaW5cbiAgICAgICAgbGV0IG4yID0gbiAtIG4xIGluXG4gICAgICAgIGxldCBzMSwgbDIgPSBzb3J0IG4xIGwgaW5cbiAgICAgICAgbGV0IHMyLCB0bCA9IHNvcnQgbjIgbDIgaW5cbiAgICAgICAgKHJldl9tZXJnZSBzMSBzMiBbXSwgdGwpXG4gIGluXG4gIGxldCBsZW4gPSBsZW5ndGggbCBpblxuICBpZiBsZW4gPCAyIHRoZW4gbCBlbHNlIGZzdCAoc29ydCBsZW4gbClcblxuXG5sZXQgcmVjIGNvbXBhcmVfbGVuZ3RocyBsMSBsMiA9XG4gIG1hdGNoIGwxLCBsMiB3aXRoXG4gIHwgW10sIFtdIC0+IDBcbiAgfCBbXSwgXyAtPiAtMVxuICB8IF8sIFtdIC0+IDFcbiAgfCBfIDo6IGwxLCBfIDo6IGwyIC0+IGNvbXBhcmVfbGVuZ3RocyBsMSBsMlxuOztcblxubGV0IHJlYyBjb21wYXJlX2xlbmd0aF93aXRoIGwgbiA9XG4gIG1hdGNoIGwgd2l0aFxuICB8IFtdIC0+XG4gICAgaWYgbiA9IDAgdGhlbiAwIGVsc2VcbiAgICAgIGlmIG4gPiAwIHRoZW4gLTEgZWxzZSAxXG4gIHwgXyA6OiBsIC0+XG4gICAgaWYgbiA8PSAwIHRoZW4gMSBlbHNlXG4gICAgICBjb21wYXJlX2xlbmd0aF93aXRoIGwgKG4tMSlcbjs7XG5cbigqKiB7MSBDb21wYXJpc29ufSAqKVxuXG4oKiBOb3RlOiB3ZSBhcmUgKm5vdCogc2hvcnRjdXR0aW5nIHRoZSBsaXN0IGJ5IHVzaW5nXG4gICBbTGlzdC5jb21wYXJlX2xlbmd0aHNdIGZpcnN0OyB0aGlzIG1heSBiZSBzbG93ZXIgb24gbG9uZyBsaXN0c1xuICAgaW1tZWRpYXRlbHkgc3RhcnQgd2l0aCBkaXN0aW5jdCBlbGVtZW50cy4gSXQgaXMgYWxzbyBpbmNvcnJlY3QgZm9yXG4gICBbY29tcGFyZV0gYmVsb3csIGFuZCBpdCBpcyBiZXR0ZXIgKHByaW5jaXBsZSBvZiBsZWFzdCBzdXJwcmlzZSkgdG9cbiAgIHVzZSB0aGUgc2FtZSBhcHByb2FjaCBmb3IgYm90aCBmdW5jdGlvbnMuICopXG5sZXQgcmVjIGVxdWFsIGVxIGwxIGwyID1cbiAgbWF0Y2ggbDEsIGwyIHdpdGhcbiAgfCBbXSwgW10gLT4gdHJ1ZVxuICB8IFtdLCBfOjpfIHwgXzo6XywgW10gLT4gZmFsc2VcbiAgfCBhMTo6bDEsIGEyOjpsMiAtPiBlcSBhMSBhMiAmJiBlcXVhbCBlcSBsMSBsMlxuXG5sZXQgcmVjIGNvbXBhcmUgY21wIGwxIGwyID1cbiAgbWF0Y2ggbDEsIGwyIHdpdGhcbiAgfCBbXSwgW10gLT4gMFxuICB8IFtdLCBfOjpfIC0+IC0xXG4gIHwgXzo6XywgW10gLT4gMVxuICB8IGExOjpsMSwgYTI6OmwyIC0+XG4gICAgbGV0IGMgPSBjbXAgYTEgYTIgaW5cbiAgICBpZiBjIDw+IDAgdGhlbiBjXG4gICAgZWxzZSBjb21wYXJlIGNtcCBsMSBsMlxuXG4oKiogezEgSXRlcmF0b3JzfSAqKVxuXG5sZXQgdG9fc2VxIGwgPVxuICBsZXQgcmVjIGF1eCBsICgpID0gbWF0Y2ggbCB3aXRoXG4gICAgfCBbXSAtPiBTZXEuTmlsXG4gICAgfCB4IDo6IHRhaWwgLT4gU2VxLkNvbnMgKHgsIGF1eCB0YWlsKVxuICBpblxuICBhdXggbFxuXG5sZXQgb2Zfc2VxIHNlcSA9XG4gIGxldCByZWMgZGlyZWN0IGRlcHRoIHNlcSA6IF8gbGlzdCA9XG4gICAgaWYgZGVwdGg9MFxuICAgIHRoZW5cbiAgICAgIFNlcS5mb2xkX2xlZnQgKGZ1biBhY2MgeCAtPiB4OjphY2MpIFtdIHNlcVxuICAgICAgfD4gcmV2ICgqIHRhaWxyZWMgKilcbiAgICBlbHNlIG1hdGNoIHNlcSgpIHdpdGhcbiAgICAgIHwgU2VxLk5pbCAtPiBbXVxuICAgICAgfCBTZXEuQ29ucyAoeCwgbmV4dCkgLT4geCA6OiBkaXJlY3QgKGRlcHRoLTEpIG5leHRcbiAgaW5cbiAgZGlyZWN0IDUwMCBzZXFcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICBTaW1vbiBDcnVhbmVzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMTcgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogTW9kdWxlIFtTZXFdOiBmdW5jdGlvbmFsIGl0ZXJhdG9ycyAqKVxuXG50eXBlICsnYSBub2RlID1cbiAgfCBOaWxcbiAgfCBDb25zIG9mICdhICogJ2EgdFxuXG5hbmQgJ2EgdCA9IHVuaXQgLT4gJ2Egbm9kZVxuXG5sZXQgZW1wdHkgKCkgPSBOaWxcblxubGV0IHJldHVybiB4ICgpID0gQ29ucyAoeCwgZW1wdHkpXG5cbmxldCBjb25zIHggbmV4dCAoKSA9IENvbnMgKHgsIG5leHQpXG5cbmxldCByZWMgYXBwZW5kIHNlcTEgc2VxMiAoKSA9XG4gIG1hdGNoIHNlcTEoKSB3aXRoXG4gIHwgTmlsIC0+IHNlcTIoKVxuICB8IENvbnMgKHgsIG5leHQpIC0+IENvbnMgKHgsIGFwcGVuZCBuZXh0IHNlcTIpXG5cbmxldCByZWMgbWFwIGYgc2VxICgpID0gbWF0Y2ggc2VxKCkgd2l0aFxuICB8IE5pbCAtPiBOaWxcbiAgfCBDb25zICh4LCBuZXh0KSAtPiBDb25zIChmIHgsIG1hcCBmIG5leHQpXG5cbmxldCByZWMgZmlsdGVyX21hcCBmIHNlcSAoKSA9IG1hdGNoIHNlcSgpIHdpdGhcbiAgfCBOaWwgLT4gTmlsXG4gIHwgQ29ucyAoeCwgbmV4dCkgLT5cbiAgICAgIG1hdGNoIGYgeCB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiBmaWx0ZXJfbWFwIGYgbmV4dCAoKVxuICAgICAgICB8IFNvbWUgeSAtPiBDb25zICh5LCBmaWx0ZXJfbWFwIGYgbmV4dClcblxubGV0IHJlYyBmaWx0ZXIgZiBzZXEgKCkgPSBtYXRjaCBzZXEoKSB3aXRoXG4gIHwgTmlsIC0+IE5pbFxuICB8IENvbnMgKHgsIG5leHQpIC0+XG4gICAgICBpZiBmIHhcbiAgICAgIHRoZW4gQ29ucyAoeCwgZmlsdGVyIGYgbmV4dClcbiAgICAgIGVsc2UgZmlsdGVyIGYgbmV4dCAoKVxuXG5sZXQgcmVjIGZsYXRfbWFwIGYgc2VxICgpID0gbWF0Y2ggc2VxICgpIHdpdGhcbiAgfCBOaWwgLT4gTmlsXG4gIHwgQ29ucyAoeCwgbmV4dCkgLT5cbiAgICBmbGF0X21hcF9hcHAgZiAoZiB4KSBuZXh0ICgpXG5cbigqIHRoaXMgaXMgW2FwcGVuZCBzZXEgKGZsYXRfbWFwIGYgdGFpbCldICopXG5hbmQgZmxhdF9tYXBfYXBwIGYgc2VxIHRhaWwgKCkgPSBtYXRjaCBzZXEgKCkgd2l0aFxuICB8IE5pbCAtPiBmbGF0X21hcCBmIHRhaWwgKClcbiAgfCBDb25zICh4LCBuZXh0KSAtPlxuICAgIENvbnMgKHgsIGZsYXRfbWFwX2FwcCBmIG5leHQgdGFpbClcblxubGV0IGZvbGRfbGVmdCBmIGFjYyBzZXEgPVxuICBsZXQgcmVjIGF1eCBmIGFjYyBzZXEgPSBtYXRjaCBzZXEgKCkgd2l0aFxuICAgIHwgTmlsIC0+IGFjY1xuICAgIHwgQ29ucyAoeCwgbmV4dCkgLT5cbiAgICAgICAgbGV0IGFjYyA9IGYgYWNjIHggaW5cbiAgICAgICAgYXV4IGYgYWNjIG5leHRcbiAgaW5cbiAgYXV4IGYgYWNjIHNlcVxuXG5sZXQgaXRlciBmIHNlcSA9XG4gIGxldCByZWMgYXV4IHNlcSA9IG1hdGNoIHNlcSAoKSB3aXRoXG4gICAgfCBOaWwgLT4gKClcbiAgICB8IENvbnMgKHgsIG5leHQpIC0+XG4gICAgICAgIGYgeDtcbiAgICAgICAgYXV4IG5leHRcbiAgaW5cbiAgYXV4IHNlcVxuXG5sZXQgcmVjIHVuZm9sZCBmIHUgKCkgPVxuICBtYXRjaCBmIHUgd2l0aFxuICB8IE5vbmUgLT4gTmlsXG4gIHwgU29tZSAoeCwgdScpIC0+IENvbnMgKHgsIHVuZm9sZCBmIHUnKVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgVGhlIE9DYW1sIHByb2dyYW1tZXJzICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxOCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlICdhIHQgPSAnYSBvcHRpb24gPSBOb25lIHwgU29tZSBvZiAnYVxuXG5sZXQgbm9uZSA9IE5vbmVcbmxldCBzb21lIHYgPSBTb21lIHZcbmxldCB2YWx1ZSBvIH5kZWZhdWx0ID0gbWF0Y2ggbyB3aXRoIFNvbWUgdiAtPiB2IHwgTm9uZSAtPiBkZWZhdWx0XG5sZXQgZ2V0ID0gZnVuY3Rpb24gU29tZSB2IC0+IHYgfCBOb25lIC0+IGludmFsaWRfYXJnIFwib3B0aW9uIGlzIE5vbmVcIlxubGV0IGJpbmQgbyBmID0gbWF0Y2ggbyB3aXRoIE5vbmUgLT4gTm9uZSB8IFNvbWUgdiAtPiBmIHZcbmxldCBqb2luID0gZnVuY3Rpb24gU29tZSBvIC0+IG8gfCBOb25lIC0+IE5vbmVcbmxldCBtYXAgZiBvID0gbWF0Y2ggbyB3aXRoIE5vbmUgLT4gTm9uZSB8IFNvbWUgdiAtPiBTb21lIChmIHYpXG5sZXQgZm9sZCB+bm9uZSB+c29tZSA9IGZ1bmN0aW9uIFNvbWUgdiAtPiBzb21lIHYgfCBOb25lIC0+IG5vbmVcbmxldCBpdGVyIGYgPSBmdW5jdGlvbiBTb21lIHYgLT4gZiB2IHwgTm9uZSAtPiAoKVxubGV0IGlzX25vbmUgPSBmdW5jdGlvbiBOb25lIC0+IHRydWUgfCBTb21lIF8gLT4gZmFsc2VcbmxldCBpc19zb21lID0gZnVuY3Rpb24gTm9uZSAtPiBmYWxzZSB8IFNvbWUgXyAtPiB0cnVlXG5cbmxldCBlcXVhbCBlcSBvMCBvMSA9IG1hdGNoIG8wLCBvMSB3aXRoXG58IFNvbWUgdjAsIFNvbWUgdjEgLT4gZXEgdjAgdjFcbnwgTm9uZSwgTm9uZSAtPiB0cnVlXG58IF8gLT4gZmFsc2VcblxubGV0IGNvbXBhcmUgY21wIG8wIG8xID0gbWF0Y2ggbzAsIG8xIHdpdGhcbnwgU29tZSB2MCwgU29tZSB2MSAtPiBjbXAgdjAgdjFcbnwgTm9uZSwgTm9uZSAtPiAwXG58IE5vbmUsIFNvbWUgXyAtPiAtMVxufCBTb21lIF8sIE5vbmUgLT4gMVxuXG5sZXQgdG9fcmVzdWx0IH5ub25lID0gZnVuY3Rpb24gTm9uZSAtPiBFcnJvciBub25lIHwgU29tZSB2IC0+IE9rIHZcbmxldCB0b19saXN0ID0gZnVuY3Rpb24gTm9uZSAtPiBbXSB8IFNvbWUgdiAtPiBbdl1cbmxldCB0b19zZXEgPSBmdW5jdGlvbiBOb25lIC0+IFNlcS5lbXB0eSB8IFNvbWUgdiAtPiBTZXEucmV0dXJuIHZcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgR2FicmllbCBTY2hlcmVyLCBwcm9qZXQgUGFyc2lmYWwsIElOUklBIFNhY2xheSAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMTkgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxudHlwZSAoJ2EsICdiKSB0ID0gTGVmdCBvZiAnYSB8IFJpZ2h0IG9mICdiXG5cbmxldCBsZWZ0IHYgPSBMZWZ0IHZcbmxldCByaWdodCB2ID0gUmlnaHQgdlxuXG5sZXQgaXNfbGVmdCA9IGZ1bmN0aW9uXG58IExlZnQgXyAtPiB0cnVlXG58IFJpZ2h0IF8gLT4gZmFsc2VcblxubGV0IGlzX3JpZ2h0ID0gZnVuY3Rpb25cbnwgTGVmdCBfIC0+IGZhbHNlXG58IFJpZ2h0IF8gLT4gdHJ1ZVxuXG5sZXQgZmluZF9sZWZ0ID0gZnVuY3Rpb25cbnwgTGVmdCB2IC0+IFNvbWUgdlxufCBSaWdodCBfIC0+IE5vbmVcblxubGV0IGZpbmRfcmlnaHQgPSBmdW5jdGlvblxufCBMZWZ0IF8gLT4gTm9uZVxufCBSaWdodCB2IC0+IFNvbWUgdlxuXG5sZXQgbWFwX2xlZnQgZiA9IGZ1bmN0aW9uXG58IExlZnQgdiAtPiBMZWZ0IChmIHYpXG58IFJpZ2h0IF8gYXMgZSAtPiBlXG5cbmxldCBtYXBfcmlnaHQgZiA9IGZ1bmN0aW9uXG58IExlZnQgXyBhcyBlIC0+IGVcbnwgUmlnaHQgdiAtPiBSaWdodCAoZiB2KVxuXG5sZXQgbWFwIH5sZWZ0IH5yaWdodCA9IGZ1bmN0aW9uXG58IExlZnQgdiAtPiBMZWZ0IChsZWZ0IHYpXG58IFJpZ2h0IHYgLT4gUmlnaHQgKHJpZ2h0IHYpXG5cbmxldCBmb2xkIH5sZWZ0IH5yaWdodCA9IGZ1bmN0aW9uXG58IExlZnQgdiAtPiBsZWZ0IHZcbnwgUmlnaHQgdiAtPiByaWdodCB2XG5cbmxldCBpdGVyID0gZm9sZFxuXG5sZXQgZm9yX2FsbCA9IGZvbGRcblxubGV0IGVxdWFsIH5sZWZ0IH5yaWdodCBlMSBlMiA9IG1hdGNoIGUxLCBlMiB3aXRoXG58IExlZnQgdjEsIExlZnQgdjIgLT4gbGVmdCB2MSB2MlxufCBSaWdodCB2MSwgUmlnaHQgdjIgLT4gcmlnaHQgdjEgdjJcbnwgTGVmdCBfLCBSaWdodCBfIHwgUmlnaHQgXywgTGVmdCBfIC0+IGZhbHNlXG5cbmxldCBjb21wYXJlIH5sZWZ0IH5yaWdodCBlMSBlMiA9IG1hdGNoIGUxLCBlMiB3aXRoXG58IExlZnQgdjEsIExlZnQgdjIgLT4gbGVmdCB2MSB2MlxufCBSaWdodCB2MSwgUmlnaHQgdjIgLT4gcmlnaHQgdjEgdjJcbnwgTGVmdCBfLCBSaWdodCBfIC0+ICgtMSlcbnwgUmlnaHQgXywgTGVmdCBfIC0+IDFcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBPQ2FtbCBwcm9ncmFtbWVycyAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMTggSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxudHlwZSAoJ2EsICdlKSB0ID0gKCdhLCAnZSkgcmVzdWx0ID0gT2sgb2YgJ2EgfCBFcnJvciBvZiAnZVxuXG5sZXQgb2sgdiA9IE9rIHZcbmxldCBlcnJvciBlID0gRXJyb3IgZVxubGV0IHZhbHVlIHIgfmRlZmF1bHQgPSBtYXRjaCByIHdpdGggT2sgdiAtPiB2IHwgRXJyb3IgXyAtPiBkZWZhdWx0XG5sZXQgZ2V0X29rID0gZnVuY3Rpb24gT2sgdiAtPiB2IHwgRXJyb3IgXyAtPiBpbnZhbGlkX2FyZyBcInJlc3VsdCBpcyBFcnJvciBfXCJcbmxldCBnZXRfZXJyb3IgPSBmdW5jdGlvbiBFcnJvciBlIC0+IGUgfCBPayBfIC0+IGludmFsaWRfYXJnIFwicmVzdWx0IGlzIE9rIF9cIlxubGV0IGJpbmQgciBmID0gbWF0Y2ggciB3aXRoIE9rIHYgLT4gZiB2IHwgRXJyb3IgXyBhcyBlIC0+IGVcbmxldCBqb2luID0gZnVuY3Rpb24gT2sgciAtPiByIHwgRXJyb3IgXyBhcyBlIC0+IGVcbmxldCBtYXAgZiA9IGZ1bmN0aW9uIE9rIHYgLT4gT2sgKGYgdikgfCBFcnJvciBfIGFzIGUgLT4gZVxubGV0IG1hcF9lcnJvciBmID0gZnVuY3Rpb24gRXJyb3IgZSAtPiBFcnJvciAoZiBlKSB8IE9rIF8gYXMgdiAtPiB2XG5sZXQgZm9sZCB+b2sgfmVycm9yID0gZnVuY3Rpb24gT2sgdiAtPiBvayB2IHwgRXJyb3IgZSAtPiBlcnJvciBlXG5sZXQgaXRlciBmID0gZnVuY3Rpb24gT2sgdiAtPiBmIHYgfCBFcnJvciBfIC0+ICgpXG5sZXQgaXRlcl9lcnJvciBmID0gZnVuY3Rpb24gRXJyb3IgZSAtPiBmIGUgfCBPayBfIC0+ICgpXG5sZXQgaXNfb2sgPSBmdW5jdGlvbiBPayBfIC0+IHRydWUgfCBFcnJvciBfIC0+IGZhbHNlXG5sZXQgaXNfZXJyb3IgPSBmdW5jdGlvbiBFcnJvciBfIC0+IHRydWUgfCBPayBfIC0+IGZhbHNlXG5cbmxldCBlcXVhbCB+b2sgfmVycm9yIHIwIHIxID0gbWF0Y2ggcjAsIHIxIHdpdGhcbnwgT2sgdjAsIE9rIHYxIC0+IG9rIHYwIHYxXG58IEVycm9yIGUwLCBFcnJvciBlMSAtPiBlcnJvciBlMCBlMVxufCBfLCBfIC0+IGZhbHNlXG5cbmxldCBjb21wYXJlIH5vayB+ZXJyb3IgcjAgcjEgPSBtYXRjaCByMCwgcjEgd2l0aFxufCBPayB2MCwgT2sgdjEgLT4gb2sgdjAgdjFcbnwgRXJyb3IgZTAsIEVycm9yIGUxIC0+IGVycm9yIGUwIGUxXG58IE9rIF8sIEVycm9yIF8gLT4gLTFcbnwgRXJyb3IgXywgT2sgXyAtPiAxXG5cbmxldCB0b19vcHRpb24gPSBmdW5jdGlvbiBPayB2IC0+IFNvbWUgdiB8IEVycm9yIF8gLT4gTm9uZVxubGV0IHRvX2xpc3QgPSBmdW5jdGlvbiBPayB2IC0+IFt2XSB8IEVycm9yIF8gLT4gW11cbmxldCB0b19zZXEgPSBmdW5jdGlvbiBPayB2IC0+IFNlcS5yZXR1cm4gdiB8IEVycm9yIF8gLT4gU2VxLmVtcHR5XG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgT0NhbWwgcHJvZ3JhbW1lcnMgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE4IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUgdCA9IGJvb2wgPSBmYWxzZSB8IHRydWVcblxuZXh0ZXJuYWwgbm90IDogYm9vbCAtPiBib29sID0gXCIlYm9vbG5vdFwiXG5leHRlcm5hbCAoICYmICkgOiBib29sIC0+IGJvb2wgLT4gYm9vbCA9IFwiJXNlcXVhbmRcIlxuZXh0ZXJuYWwgKCB8fCApIDogYm9vbCAtPiBib29sIC0+IGJvb2wgPSBcIiVzZXF1b3JcIlxubGV0IGVxdWFsIDogYm9vbCAtPiBib29sIC0+IGJvb2wgPSAoID0gKVxubGV0IGNvbXBhcmUgOiBib29sIC0+IGJvb2wgLT4gaW50ID0gU3RkbGliLmNvbXBhcmVcbmV4dGVybmFsIHRvX2ludCA6IGJvb2wgLT4gaW50ID0gXCIlaWRlbnRpdHlcIlxubGV0IHRvX2Zsb2F0ID0gZnVuY3Rpb24gZmFsc2UgLT4gMC4gfCB0cnVlIC0+IDEuXG5cbigqXG5sZXQgb2Zfc3RyaW5nID0gZnVuY3Rpb25cbnwgXCJmYWxzZVwiIC0+IFNvbWUgZmFsc2VcbnwgXCJ0cnVlXCIgLT4gU29tZSB0cnVlXG58IF8gLT4gTm9uZVxuKilcblxubGV0IHRvX3N0cmluZyA9IGZ1bmN0aW9uIGZhbHNlIC0+IFwiZmFsc2VcIiB8IHRydWUgLT4gXCJ0cnVlXCJcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogQ2hhcmFjdGVyIG9wZXJhdGlvbnMgKilcblxuZXh0ZXJuYWwgY29kZTogY2hhciAtPiBpbnQgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCB1bnNhZmVfY2hyOiBpbnQgLT4gY2hhciA9IFwiJWlkZW50aXR5XCJcblxubGV0IGNociBuID1cbiAgaWYgbiA8IDAgfHwgbiA+IDI1NSB0aGVuIGludmFsaWRfYXJnIFwiQ2hhci5jaHJcIiBlbHNlIHVuc2FmZV9jaHIgblxuXG5leHRlcm5hbCBieXRlc19jcmVhdGU6IGludCAtPiBieXRlcyA9IFwiY2FtbF9jcmVhdGVfYnl0ZXNcIlxuZXh0ZXJuYWwgYnl0ZXNfdW5zYWZlX3NldCA6IGJ5dGVzIC0+IGludCAtPiBjaGFyIC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgID0gXCIlYnl0ZXNfdW5zYWZlX3NldFwiXG5leHRlcm5hbCB1bnNhZmVfdG9fc3RyaW5nIDogYnl0ZXMgLT4gc3RyaW5nID0gXCIlYnl0ZXNfdG9fc3RyaW5nXCJcblxubGV0IGVzY2FwZWQgPSBmdW5jdGlvblxuICB8ICdcXCcnIC0+IFwiXFxcXCdcIlxuICB8ICdcXFxcJyAtPiBcIlxcXFxcXFxcXCJcbiAgfCAnXFxuJyAtPiBcIlxcXFxuXCJcbiAgfCAnXFx0JyAtPiBcIlxcXFx0XCJcbiAgfCAnXFxyJyAtPiBcIlxcXFxyXCJcbiAgfCAnXFxiJyAtPiBcIlxcXFxiXCJcbiAgfCAnICcgLi4gJ34nIGFzIGMgLT5cbiAgICAgIGxldCBzID0gYnl0ZXNfY3JlYXRlIDEgaW5cbiAgICAgIGJ5dGVzX3Vuc2FmZV9zZXQgcyAwIGM7XG4gICAgICB1bnNhZmVfdG9fc3RyaW5nIHNcbiAgfCBjIC0+XG4gICAgICBsZXQgbiA9IGNvZGUgYyBpblxuICAgICAgbGV0IHMgPSBieXRlc19jcmVhdGUgNCBpblxuICAgICAgYnl0ZXNfdW5zYWZlX3NldCBzIDAgJ1xcXFwnO1xuICAgICAgYnl0ZXNfdW5zYWZlX3NldCBzIDEgKHVuc2FmZV9jaHIgKDQ4ICsgbiAvIDEwMCkpO1xuICAgICAgYnl0ZXNfdW5zYWZlX3NldCBzIDIgKHVuc2FmZV9jaHIgKDQ4ICsgKG4gLyAxMCkgbW9kIDEwKSk7XG4gICAgICBieXRlc191bnNhZmVfc2V0IHMgMyAodW5zYWZlX2NociAoNDggKyBuIG1vZCAxMCkpO1xuICAgICAgdW5zYWZlX3RvX3N0cmluZyBzXG5cbmxldCBsb3dlcmNhc2UgPSBmdW5jdGlvblxuICB8ICdBJyAuLiAnWidcbiAgfCAnXFwxOTInIC4uICdcXDIxNCdcbiAgfCAnXFwyMTYnIC4uICdcXDIyMicgYXMgYyAtPlxuICAgIHVuc2FmZV9jaHIoY29kZSBjICsgMzIpXG4gIHwgYyAtPiBjXG5cbmxldCB1cHBlcmNhc2UgPSBmdW5jdGlvblxuICB8ICdhJyAuLiAneidcbiAgfCAnXFwyMjQnIC4uICdcXDI0NidcbiAgfCAnXFwyNDgnIC4uICdcXDI1NCcgYXMgYyAtPlxuICAgIHVuc2FmZV9jaHIoY29kZSBjIC0gMzIpXG4gIHwgYyAtPiBjXG5cbmxldCBsb3dlcmNhc2VfYXNjaWkgPSBmdW5jdGlvblxuICB8ICdBJyAuLiAnWicgYXMgYyAtPiB1bnNhZmVfY2hyKGNvZGUgYyArIDMyKVxuICB8IGMgLT4gY1xuXG5sZXQgdXBwZXJjYXNlX2FzY2lpID0gZnVuY3Rpb25cbiAgfCAnYScgLi4gJ3onIGFzIGMgLT4gdW5zYWZlX2Nocihjb2RlIGMgLSAzMilcbiAgfCBjIC0+IGNcblxudHlwZSB0ID0gY2hhclxuXG5sZXQgY29tcGFyZSBjMSBjMiA9IGNvZGUgYzEgLSBjb2RlIGMyXG5sZXQgZXF1YWwgKGMxOiB0KSAoYzI6IHQpID0gY29tcGFyZSBjMSBjMiA9IDBcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogQnl0ZSBzZXF1ZW5jZSBvcGVyYXRpb25zICopXG5cbigqIFdBUk5JTkc6IFNvbWUgZnVuY3Rpb25zIGluIHRoaXMgZmlsZSBhcmUgZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgZm9yXG4gICBlZmZpY2llbmN5IHJlYXNvbnMuIFdoZW4geW91IG1vZGlmeSB0aGUgb25lIGluIHRoaXMgZmlsZSB5b3UgbmVlZCB0b1xuICAgbW9kaWZ5IGl0cyBkdXBsaWNhdGUgaW4gc3RyaW5nLm1sLlxuICAgVGhlc2UgZnVuY3Rpb25zIGhhdmUgYSBcImR1cGxpY2F0ZWRcIiBjb21tZW50IGFib3ZlIHRoZWlyIGRlZmluaXRpb24uXG4qKVxuXG5leHRlcm5hbCBsZW5ndGggOiBieXRlcyAtPiBpbnQgPSBcIiVieXRlc19sZW5ndGhcIlxuZXh0ZXJuYWwgc3RyaW5nX2xlbmd0aCA6IHN0cmluZyAtPiBpbnQgPSBcIiVzdHJpbmdfbGVuZ3RoXCJcbmV4dGVybmFsIGdldCA6IGJ5dGVzIC0+IGludCAtPiBjaGFyID0gXCIlYnl0ZXNfc2FmZV9nZXRcIlxuZXh0ZXJuYWwgc2V0IDogYnl0ZXMgLT4gaW50IC0+IGNoYXIgLT4gdW5pdCA9IFwiJWJ5dGVzX3NhZmVfc2V0XCJcbmV4dGVybmFsIGNyZWF0ZSA6IGludCAtPiBieXRlcyA9IFwiY2FtbF9jcmVhdGVfYnl0ZXNcIlxuZXh0ZXJuYWwgdW5zYWZlX2dldCA6IGJ5dGVzIC0+IGludCAtPiBjaGFyID0gXCIlYnl0ZXNfdW5zYWZlX2dldFwiXG5leHRlcm5hbCB1bnNhZmVfc2V0IDogYnl0ZXMgLT4gaW50IC0+IGNoYXIgLT4gdW5pdCA9IFwiJWJ5dGVzX3Vuc2FmZV9zZXRcIlxuZXh0ZXJuYWwgdW5zYWZlX2ZpbGwgOiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IGNoYXIgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfZmlsbF9ieXRlc1wiIFtAQG5vYWxsb2NdXG5leHRlcm5hbCB1bnNhZmVfdG9fc3RyaW5nIDogYnl0ZXMgLT4gc3RyaW5nID0gXCIlYnl0ZXNfdG9fc3RyaW5nXCJcbmV4dGVybmFsIHVuc2FmZV9vZl9zdHJpbmcgOiBzdHJpbmcgLT4gYnl0ZXMgPSBcIiVieXRlc19vZl9zdHJpbmdcIlxuXG5leHRlcm5hbCB1bnNhZmVfYmxpdCA6IGJ5dGVzIC0+IGludCAtPiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX2JsaXRfYnl0ZXNcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdW5zYWZlX2JsaXRfc3RyaW5nIDogc3RyaW5nIC0+IGludCAtPiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX2JsaXRfc3RyaW5nXCIgW0BAbm9hbGxvY11cblxubGV0IG1ha2UgbiBjID1cbiAgbGV0IHMgPSBjcmVhdGUgbiBpblxuICB1bnNhZmVfZmlsbCBzIDAgbiBjO1xuICBzXG5cbmxldCBpbml0IG4gZiA9XG4gIGxldCBzID0gY3JlYXRlIG4gaW5cbiAgZm9yIGkgPSAwIHRvIG4gLSAxIGRvXG4gICAgdW5zYWZlX3NldCBzIGkgKGYgaSlcbiAgZG9uZTtcbiAgc1xuXG5sZXQgZW1wdHkgPSBjcmVhdGUgMFxuXG5sZXQgY29weSBzID1cbiAgbGV0IGxlbiA9IGxlbmd0aCBzIGluXG4gIGxldCByID0gY3JlYXRlIGxlbiBpblxuICB1bnNhZmVfYmxpdCBzIDAgciAwIGxlbjtcbiAgclxuXG5sZXQgdG9fc3RyaW5nIGIgPSB1bnNhZmVfdG9fc3RyaW5nIChjb3B5IGIpXG5sZXQgb2Zfc3RyaW5nIHMgPSBjb3B5ICh1bnNhZmVfb2Zfc3RyaW5nIHMpXG5cbmxldCBzdWIgcyBvZnMgbGVuID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IGxlbmd0aCBzIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJTdHJpbmcuc3ViIC8gQnl0ZXMuc3ViXCJcbiAgZWxzZSBiZWdpblxuICAgIGxldCByID0gY3JlYXRlIGxlbiBpblxuICAgIHVuc2FmZV9ibGl0IHMgb2ZzIHIgMCBsZW47XG4gICAgclxuICBlbmRcblxubGV0IHN1Yl9zdHJpbmcgYiBvZnMgbGVuID0gdW5zYWZlX3RvX3N0cmluZyAoc3ViIGIgb2ZzIGxlbilcblxuKCogYWRkaXRpb24gd2l0aCBhbiBvdmVyZmxvdyBjaGVjayAqKVxubGV0ICgrKykgYSBiID1cbiAgbGV0IGMgPSBhICsgYiBpblxuICBtYXRjaCBhIDwgMCwgYiA8IDAsIGMgPCAwIHdpdGhcbiAgfCB0cnVlICwgdHJ1ZSAsIGZhbHNlXG4gIHwgZmFsc2UsIGZhbHNlLCB0cnVlICAtPiBpbnZhbGlkX2FyZyBcIkJ5dGVzLmV4dGVuZFwiICgqIG92ZXJmbG93ICopXG4gIHwgXyAtPiBjXG5cbmxldCBleHRlbmQgcyBsZWZ0IHJpZ2h0ID1cbiAgbGV0IGxlbiA9IGxlbmd0aCBzICsrIGxlZnQgKysgcmlnaHQgaW5cbiAgbGV0IHIgPSBjcmVhdGUgbGVuIGluXG4gIGxldCAoc3Jjb2ZmLCBkc3RvZmYpID0gaWYgbGVmdCA8IDAgdGhlbiAtbGVmdCwgMCBlbHNlIDAsIGxlZnQgaW5cbiAgbGV0IGNweWxlbiA9IG1pbiAobGVuZ3RoIHMgLSBzcmNvZmYpIChsZW4gLSBkc3RvZmYpIGluXG4gIGlmIGNweWxlbiA+IDAgdGhlbiB1bnNhZmVfYmxpdCBzIHNyY29mZiByIGRzdG9mZiBjcHlsZW47XG4gIHJcblxubGV0IGZpbGwgcyBvZnMgbGVuIGMgPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gbGVuZ3RoIHMgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIlN0cmluZy5maWxsIC8gQnl0ZXMuZmlsbFwiXG4gIGVsc2UgdW5zYWZlX2ZpbGwgcyBvZnMgbGVuIGNcblxubGV0IGJsaXQgczEgb2ZzMSBzMiBvZnMyIGxlbiA9XG4gIGlmIGxlbiA8IDAgfHwgb2ZzMSA8IDAgfHwgb2ZzMSA+IGxlbmd0aCBzMSAtIGxlblxuICAgICAgICAgICAgIHx8IG9mczIgPCAwIHx8IG9mczIgPiBsZW5ndGggczIgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIkJ5dGVzLmJsaXRcIlxuICBlbHNlIHVuc2FmZV9ibGl0IHMxIG9mczEgczIgb2ZzMiBsZW5cblxubGV0IGJsaXRfc3RyaW5nIHMxIG9mczEgczIgb2ZzMiBsZW4gPVxuICBpZiBsZW4gPCAwIHx8IG9mczEgPCAwIHx8IG9mczEgPiBzdHJpbmdfbGVuZ3RoIHMxIC0gbGVuXG4gICAgICAgICAgICAgfHwgb2ZzMiA8IDAgfHwgb2ZzMiA+IGxlbmd0aCBzMiAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiU3RyaW5nLmJsaXQgLyBCeXRlcy5ibGl0X3N0cmluZ1wiXG4gIGVsc2UgdW5zYWZlX2JsaXRfc3RyaW5nIHMxIG9mczEgczIgb2ZzMiBsZW5cblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCBpdGVyIGYgYSA9XG4gIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG8gZih1bnNhZmVfZ2V0IGEgaSkgZG9uZVxuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IGl0ZXJpIGYgYSA9XG4gIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG8gZiBpICh1bnNhZmVfZ2V0IGEgaSkgZG9uZVxuXG5sZXQgZW5zdXJlX2dlICh4OmludCkgeSA9IGlmIHggPj0geSB0aGVuIHggZWxzZSBpbnZhbGlkX2FyZyBcIkJ5dGVzLmNvbmNhdFwiXG5cbmxldCByZWMgc3VtX2xlbmd0aHMgYWNjIHNlcGxlbiA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gYWNjXG4gIHwgaGQgOjogW10gLT4gbGVuZ3RoIGhkICsgYWNjXG4gIHwgaGQgOjogdGwgLT4gc3VtX2xlbmd0aHMgKGVuc3VyZV9nZSAobGVuZ3RoIGhkICsgc2VwbGVuICsgYWNjKSBhY2MpIHNlcGxlbiB0bFxuXG5sZXQgcmVjIHVuc2FmZV9ibGl0cyBkc3QgcG9zIHNlcCBzZXBsZW4gPSBmdW5jdGlvblxuICAgIFtdIC0+IGRzdFxuICB8IGhkIDo6IFtdIC0+XG4gICAgdW5zYWZlX2JsaXQgaGQgMCBkc3QgcG9zIChsZW5ndGggaGQpOyBkc3RcbiAgfCBoZCA6OiB0bCAtPlxuICAgIHVuc2FmZV9ibGl0IGhkIDAgZHN0IHBvcyAobGVuZ3RoIGhkKTtcbiAgICB1bnNhZmVfYmxpdCBzZXAgMCBkc3QgKHBvcyArIGxlbmd0aCBoZCkgc2VwbGVuO1xuICAgIHVuc2FmZV9ibGl0cyBkc3QgKHBvcyArIGxlbmd0aCBoZCArIHNlcGxlbikgc2VwIHNlcGxlbiB0bFxuXG5sZXQgY29uY2F0IHNlcCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gZW1wdHlcbiAgfCBsIC0+IGxldCBzZXBsZW4gPSBsZW5ndGggc2VwIGluXG4gICAgICAgICAgdW5zYWZlX2JsaXRzXG4gICAgICAgICAgICAoY3JlYXRlIChzdW1fbGVuZ3RocyAwIHNlcGxlbiBsKSlcbiAgICAgICAgICAgIDAgc2VwIHNlcGxlbiBsXG5cbmxldCBjYXQgczEgczIgPVxuICBsZXQgbDEgPSBsZW5ndGggczEgaW5cbiAgbGV0IGwyID0gbGVuZ3RoIHMyIGluXG4gIGxldCByID0gY3JlYXRlIChsMSArIGwyKSBpblxuICB1bnNhZmVfYmxpdCBzMSAwIHIgMCBsMTtcbiAgdW5zYWZlX2JsaXQgczIgMCByIGwxIGwyO1xuICByXG5cblxuZXh0ZXJuYWwgY2hhcl9jb2RlOiBjaGFyIC0+IGludCA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIGNoYXJfY2hyOiBpbnQgLT4gY2hhciA9IFwiJWlkZW50aXR5XCJcblxubGV0IGlzX3NwYWNlID0gZnVuY3Rpb25cbiAgfCAnICcgfCAnXFwwMTInIHwgJ1xcbicgfCAnXFxyJyB8ICdcXHQnIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG5cbmxldCB0cmltIHMgPVxuICBsZXQgbGVuID0gbGVuZ3RoIHMgaW5cbiAgbGV0IGkgPSByZWYgMCBpblxuICB3aGlsZSAhaSA8IGxlbiAmJiBpc19zcGFjZSAodW5zYWZlX2dldCBzICFpKSBkb1xuICAgIGluY3IgaVxuICBkb25lO1xuICBsZXQgaiA9IHJlZiAobGVuIC0gMSkgaW5cbiAgd2hpbGUgIWogPj0gIWkgJiYgaXNfc3BhY2UgKHVuc2FmZV9nZXQgcyAhaikgZG9cbiAgICBkZWNyIGpcbiAgZG9uZTtcbiAgaWYgIWogPj0gIWkgdGhlblxuICAgIHN1YiBzICFpICghaiAtICFpICsgMSlcbiAgZWxzZVxuICAgIGVtcHR5XG5cbmxldCBlc2NhcGVkIHMgPVxuICBsZXQgbiA9IHJlZiAwIGluXG4gIGZvciBpID0gMCB0byBsZW5ndGggcyAtIDEgZG9cbiAgICBuIDo9ICFuICtcbiAgICAgIChtYXRjaCB1bnNhZmVfZ2V0IHMgaSB3aXRoXG4gICAgICAgfCAnXFxcIicgfCAnXFxcXCcgfCAnXFxuJyB8ICdcXHQnIHwgJ1xccicgfCAnXFxiJyAtPiAyXG4gICAgICAgfCAnICcgLi4gJ34nIC0+IDFcbiAgICAgICB8IF8gLT4gNClcbiAgZG9uZTtcbiAgaWYgIW4gPSBsZW5ndGggcyB0aGVuIGNvcHkgcyBlbHNlIGJlZ2luXG4gICAgbGV0IHMnID0gY3JlYXRlICFuIGluXG4gICAgbiA6PSAwO1xuICAgIGZvciBpID0gMCB0byBsZW5ndGggcyAtIDEgZG9cbiAgICAgIGJlZ2luIG1hdGNoIHVuc2FmZV9nZXQgcyBpIHdpdGhcbiAgICAgIHwgKCdcXFwiJyB8ICdcXFxcJykgYXMgYyAtPlxuICAgICAgICAgIHVuc2FmZV9zZXQgcycgIW4gJ1xcXFwnOyBpbmNyIG47IHVuc2FmZV9zZXQgcycgIW4gY1xuICAgICAgfCAnXFxuJyAtPlxuICAgICAgICAgIHVuc2FmZV9zZXQgcycgIW4gJ1xcXFwnOyBpbmNyIG47IHVuc2FmZV9zZXQgcycgIW4gJ24nXG4gICAgICB8ICdcXHQnIC0+XG4gICAgICAgICAgdW5zYWZlX3NldCBzJyAhbiAnXFxcXCc7IGluY3IgbjsgdW5zYWZlX3NldCBzJyAhbiAndCdcbiAgICAgIHwgJ1xccicgLT5cbiAgICAgICAgICB1bnNhZmVfc2V0IHMnICFuICdcXFxcJzsgaW5jciBuOyB1bnNhZmVfc2V0IHMnICFuICdyJ1xuICAgICAgfCAnXFxiJyAtPlxuICAgICAgICAgIHVuc2FmZV9zZXQgcycgIW4gJ1xcXFwnOyBpbmNyIG47IHVuc2FmZV9zZXQgcycgIW4gJ2InXG4gICAgICB8ICgnICcgLi4gJ34nKSBhcyBjIC0+IHVuc2FmZV9zZXQgcycgIW4gY1xuICAgICAgfCBjIC0+XG4gICAgICAgICAgbGV0IGEgPSBjaGFyX2NvZGUgYyBpblxuICAgICAgICAgIHVuc2FmZV9zZXQgcycgIW4gJ1xcXFwnO1xuICAgICAgICAgIGluY3IgbjtcbiAgICAgICAgICB1bnNhZmVfc2V0IHMnICFuIChjaGFyX2NociAoNDggKyBhIC8gMTAwKSk7XG4gICAgICAgICAgaW5jciBuO1xuICAgICAgICAgIHVuc2FmZV9zZXQgcycgIW4gKGNoYXJfY2hyICg0OCArIChhIC8gMTApIG1vZCAxMCkpO1xuICAgICAgICAgIGluY3IgbjtcbiAgICAgICAgICB1bnNhZmVfc2V0IHMnICFuIChjaGFyX2NociAoNDggKyBhIG1vZCAxMCkpO1xuICAgICAgZW5kO1xuICAgICAgaW5jciBuXG4gICAgZG9uZTtcbiAgICBzJ1xuICBlbmRcblxubGV0IG1hcCBmIHMgPVxuICBsZXQgbCA9IGxlbmd0aCBzIGluXG4gIGlmIGwgPSAwIHRoZW4gcyBlbHNlIGJlZ2luXG4gICAgbGV0IHIgPSBjcmVhdGUgbCBpblxuICAgIGZvciBpID0gMCB0byBsIC0gMSBkbyB1bnNhZmVfc2V0IHIgaSAoZiAodW5zYWZlX2dldCBzIGkpKSBkb25lO1xuICAgIHJcbiAgZW5kXG5cbmxldCBtYXBpIGYgcyA9XG4gIGxldCBsID0gbGVuZ3RoIHMgaW5cbiAgaWYgbCA9IDAgdGhlbiBzIGVsc2UgYmVnaW5cbiAgICBsZXQgciA9IGNyZWF0ZSBsIGluXG4gICAgZm9yIGkgPSAwIHRvIGwgLSAxIGRvIHVuc2FmZV9zZXQgciBpIChmIGkgKHVuc2FmZV9nZXQgcyBpKSkgZG9uZTtcbiAgICByXG4gIGVuZFxuXG5sZXQgdXBwZXJjYXNlX2FzY2lpIHMgPSBtYXAgQ2hhci51cHBlcmNhc2VfYXNjaWkgc1xubGV0IGxvd2VyY2FzZV9hc2NpaSBzID0gbWFwIENoYXIubG93ZXJjYXNlX2FzY2lpIHNcblxubGV0IGFwcGx5MSBmIHMgPVxuICBpZiBsZW5ndGggcyA9IDAgdGhlbiBzIGVsc2UgYmVnaW5cbiAgICBsZXQgciA9IGNvcHkgcyBpblxuICAgIHVuc2FmZV9zZXQgciAwIChmKHVuc2FmZV9nZXQgcyAwKSk7XG4gICAgclxuICBlbmRcblxubGV0IGNhcGl0YWxpemVfYXNjaWkgcyA9IGFwcGx5MSBDaGFyLnVwcGVyY2FzZV9hc2NpaSBzXG5sZXQgdW5jYXBpdGFsaXplX2FzY2lpIHMgPSBhcHBseTEgQ2hhci5sb3dlcmNhc2VfYXNjaWkgc1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IHJlYyBpbmRleF9yZWMgcyBsaW0gaSBjID1cbiAgaWYgaSA+PSBsaW0gdGhlbiByYWlzZSBOb3RfZm91bmQgZWxzZVxuICBpZiB1bnNhZmVfZ2V0IHMgaSA9IGMgdGhlbiBpIGVsc2UgaW5kZXhfcmVjIHMgbGltIChpICsgMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IGluZGV4IHMgYyA9IGluZGV4X3JlYyBzIChsZW5ndGggcykgMCBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgcmVjIGluZGV4X3JlY19vcHQgcyBsaW0gaSBjID1cbiAgaWYgaSA+PSBsaW0gdGhlbiBOb25lIGVsc2VcbiAgaWYgdW5zYWZlX2dldCBzIGkgPSBjIHRoZW4gU29tZSBpIGVsc2UgaW5kZXhfcmVjX29wdCBzIGxpbSAoaSArIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCBpbmRleF9vcHQgcyBjID0gaW5kZXhfcmVjX29wdCBzIChsZW5ndGggcykgMCBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgaW5kZXhfZnJvbSBzIGkgYyA9XG4gIGxldCBsID0gbGVuZ3RoIHMgaW5cbiAgaWYgaSA8IDAgfHwgaSA+IGwgdGhlbiBpbnZhbGlkX2FyZyBcIlN0cmluZy5pbmRleF9mcm9tIC8gQnl0ZXMuaW5kZXhfZnJvbVwiIGVsc2VcbiAgaW5kZXhfcmVjIHMgbCBpIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCBpbmRleF9mcm9tX29wdCBzIGkgYyA9XG4gIGxldCBsID0gbGVuZ3RoIHMgaW5cbiAgaWYgaSA8IDAgfHwgaSA+IGwgdGhlblxuICAgIGludmFsaWRfYXJnIFwiU3RyaW5nLmluZGV4X2Zyb21fb3B0IC8gQnl0ZXMuaW5kZXhfZnJvbV9vcHRcIlxuICBlbHNlXG4gICAgaW5kZXhfcmVjX29wdCBzIGwgaSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgcmVjIHJpbmRleF9yZWMgcyBpIGMgPVxuICBpZiBpIDwgMCB0aGVuIHJhaXNlIE5vdF9mb3VuZCBlbHNlXG4gIGlmIHVuc2FmZV9nZXQgcyBpID0gYyB0aGVuIGkgZWxzZSByaW5kZXhfcmVjIHMgKGkgLSAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgcmluZGV4IHMgYyA9IHJpbmRleF9yZWMgcyAobGVuZ3RoIHMgLSAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgcmluZGV4X2Zyb20gcyBpIGMgPVxuICBpZiBpIDwgLTEgfHwgaSA+PSBsZW5ndGggcyB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJTdHJpbmcucmluZGV4X2Zyb20gLyBCeXRlcy5yaW5kZXhfZnJvbVwiXG4gIGVsc2VcbiAgICByaW5kZXhfcmVjIHMgaSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgcmVjIHJpbmRleF9yZWNfb3B0IHMgaSBjID1cbiAgaWYgaSA8IDAgdGhlbiBOb25lIGVsc2VcbiAgaWYgdW5zYWZlX2dldCBzIGkgPSBjIHRoZW4gU29tZSBpIGVsc2UgcmluZGV4X3JlY19vcHQgcyAoaSAtIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCByaW5kZXhfb3B0IHMgYyA9IHJpbmRleF9yZWNfb3B0IHMgKGxlbmd0aCBzIC0gMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IHJpbmRleF9mcm9tX29wdCBzIGkgYyA9XG4gIGlmIGkgPCAtMSB8fCBpID49IGxlbmd0aCBzIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIlN0cmluZy5yaW5kZXhfZnJvbV9vcHQgLyBCeXRlcy5yaW5kZXhfZnJvbV9vcHRcIlxuICBlbHNlXG4gICAgcmluZGV4X3JlY19vcHQgcyBpIGNcblxuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IGNvbnRhaW5zX2Zyb20gcyBpIGMgPVxuICBsZXQgbCA9IGxlbmd0aCBzIGluXG4gIGlmIGkgPCAwIHx8IGkgPiBsIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIlN0cmluZy5jb250YWluc19mcm9tIC8gQnl0ZXMuY29udGFpbnNfZnJvbVwiXG4gIGVsc2VcbiAgICB0cnkgaWdub3JlIChpbmRleF9yZWMgcyBsIGkgYyk7IHRydWUgd2l0aCBOb3RfZm91bmQgLT4gZmFsc2VcblxuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IGNvbnRhaW5zIHMgYyA9IGNvbnRhaW5zX2Zyb20gcyAwIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCByY29udGFpbnNfZnJvbSBzIGkgYyA9XG4gIGlmIGkgPCAwIHx8IGkgPj0gbGVuZ3RoIHMgdGhlblxuICAgIGludmFsaWRfYXJnIFwiU3RyaW5nLnJjb250YWluc19mcm9tIC8gQnl0ZXMucmNvbnRhaW5zX2Zyb21cIlxuICBlbHNlXG4gICAgdHJ5IGlnbm9yZSAocmluZGV4X3JlYyBzIGkgYyk7IHRydWUgd2l0aCBOb3RfZm91bmQgLT4gZmFsc2VcblxuXG50eXBlIHQgPSBieXRlc1xuXG5sZXQgY29tcGFyZSAoeDogdCkgKHk6IHQpID0gU3RkbGliLmNvbXBhcmUgeCB5XG5leHRlcm5hbCBlcXVhbCA6IHQgLT4gdCAtPiBib29sID0gXCJjYW1sX2J5dGVzX2VxdWFsXCIgW0BAbm9hbGxvY11cblxuKCogRGVwcmVjYXRlZCBmdW5jdGlvbnMgaW1wbGVtZW50ZWQgdmlhIG90aGVyIGRlcHJlY2F0ZWQgZnVuY3Rpb25zICopXG5bQEBAb2NhbWwud2FybmluZyBcIi0zXCJdXG5sZXQgdXBwZXJjYXNlIHMgPSBtYXAgQ2hhci51cHBlcmNhc2Ugc1xubGV0IGxvd2VyY2FzZSBzID0gbWFwIENoYXIubG93ZXJjYXNlIHNcblxubGV0IGNhcGl0YWxpemUgcyA9IGFwcGx5MSBDaGFyLnVwcGVyY2FzZSBzXG5sZXQgdW5jYXBpdGFsaXplIHMgPSBhcHBseTEgQ2hhci5sb3dlcmNhc2Ugc1xuXG4oKiogezEgSXRlcmF0b3JzfSAqKVxuXG5sZXQgdG9fc2VxIHMgPVxuICBsZXQgcmVjIGF1eCBpICgpID1cbiAgICBpZiBpID0gbGVuZ3RoIHMgdGhlbiBTZXEuTmlsXG4gICAgZWxzZVxuICAgICAgbGV0IHggPSBnZXQgcyBpIGluXG4gICAgICBTZXEuQ29ucyAoeCwgYXV4IChpKzEpKVxuICBpblxuICBhdXggMFxuXG5sZXQgdG9fc2VxaSBzID1cbiAgbGV0IHJlYyBhdXggaSAoKSA9XG4gICAgaWYgaSA9IGxlbmd0aCBzIHRoZW4gU2VxLk5pbFxuICAgIGVsc2VcbiAgICAgIGxldCB4ID0gZ2V0IHMgaSBpblxuICAgICAgU2VxLkNvbnMgKChpLHgpLCBhdXggKGkrMSkpXG4gIGluXG4gIGF1eCAwXG5cbmxldCBvZl9zZXEgaSA9XG4gIGxldCBuID0gcmVmIDAgaW5cbiAgbGV0IGJ1ZiA9IHJlZiAobWFrZSAyNTYgJ1xcMDAwJykgaW5cbiAgbGV0IHJlc2l6ZSAoKSA9XG4gICAgKCogcmVzaXplICopXG4gICAgbGV0IG5ld19sZW4gPSBtaW4gKDIgKiBsZW5ndGggIWJ1ZikgU3lzLm1heF9zdHJpbmdfbGVuZ3RoIGluXG4gICAgaWYgbGVuZ3RoICFidWYgPSBuZXdfbGVuIHRoZW4gZmFpbHdpdGggXCJCeXRlcy5vZl9zZXE6IGNhbm5vdCBncm93IGJ5dGVzXCI7XG4gICAgbGV0IG5ld19idWYgPSBtYWtlIG5ld19sZW4gJ1xcMDAwJyBpblxuICAgIGJsaXQgIWJ1ZiAwIG5ld19idWYgMCAhbjtcbiAgICBidWYgOj0gbmV3X2J1ZlxuICBpblxuICBTZXEuaXRlclxuICAgIChmdW4gYyAtPlxuICAgICAgIGlmICFuID0gbGVuZ3RoICFidWYgdGhlbiByZXNpemUoKTtcbiAgICAgICBzZXQgIWJ1ZiAhbiBjO1xuICAgICAgIGluY3IgbilcbiAgICBpO1xuICBzdWIgIWJ1ZiAwICFuXG5cbigqKiB7NiBCaW5hcnkgZW5jb2RpbmcvZGVjb2Rpbmcgb2YgaW50ZWdlcnN9ICopXG5cbmV4dGVybmFsIGdldF91aW50OCA6IGJ5dGVzIC0+IGludCAtPiBpbnQgPSBcIiVieXRlc19zYWZlX2dldFwiXG5leHRlcm5hbCBnZXRfdWludDE2X25lIDogYnl0ZXMgLT4gaW50IC0+IGludCA9IFwiJWNhbWxfYnl0ZXNfZ2V0MTZcIlxuZXh0ZXJuYWwgZ2V0X2ludDMyX25lIDogYnl0ZXMgLT4gaW50IC0+IGludDMyID0gXCIlY2FtbF9ieXRlc19nZXQzMlwiXG5leHRlcm5hbCBnZXRfaW50NjRfbmUgOiBieXRlcyAtPiBpbnQgLT4gaW50NjQgPSBcIiVjYW1sX2J5dGVzX2dldDY0XCJcbmV4dGVybmFsIHNldF9pbnQ4IDogYnl0ZXMgLT4gaW50IC0+IGludCAtPiB1bml0ID0gXCIlYnl0ZXNfc2FmZV9zZXRcIlxuZXh0ZXJuYWwgc2V0X2ludDE2X25lIDogYnl0ZXMgLT4gaW50IC0+IGludCAtPiB1bml0ID0gXCIlY2FtbF9ieXRlc19zZXQxNlwiXG5leHRlcm5hbCBzZXRfaW50MzJfbmUgOiBieXRlcyAtPiBpbnQgLT4gaW50MzIgLT4gdW5pdCA9IFwiJWNhbWxfYnl0ZXNfc2V0MzJcIlxuZXh0ZXJuYWwgc2V0X2ludDY0X25lIDogYnl0ZXMgLT4gaW50IC0+IGludDY0IC0+IHVuaXQgPSBcIiVjYW1sX2J5dGVzX3NldDY0XCJcbmV4dGVybmFsIHN3YXAxNiA6IGludCAtPiBpbnQgPSBcIiVic3dhcDE2XCJcbmV4dGVybmFsIHN3YXAzMiA6IGludDMyIC0+IGludDMyID0gXCIlYnN3YXBfaW50MzJcIlxuZXh0ZXJuYWwgc3dhcDY0IDogaW50NjQgLT4gaW50NjQgPSBcIiVic3dhcF9pbnQ2NFwiXG5cbmxldCBnZXRfaW50OCBiIGkgPVxuICAoKGdldF91aW50OCBiIGkpIGxzbCAoU3lzLmludF9zaXplIC0gOCkpIGFzciAoU3lzLmludF9zaXplIC0gOClcblxubGV0IGdldF91aW50MTZfbGUgYiBpID1cbiAgaWYgU3lzLmJpZ19lbmRpYW4gdGhlbiBzd2FwMTYgKGdldF91aW50MTZfbmUgYiBpKVxuICBlbHNlIGdldF91aW50MTZfbmUgYiBpXG5cbmxldCBnZXRfdWludDE2X2JlIGIgaSA9XG4gIGlmIG5vdCBTeXMuYmlnX2VuZGlhbiB0aGVuIHN3YXAxNiAoZ2V0X3VpbnQxNl9uZSBiIGkpXG4gIGVsc2UgZ2V0X3VpbnQxNl9uZSBiIGlcblxubGV0IGdldF9pbnQxNl9uZSBiIGkgPVxuICAoKGdldF91aW50MTZfbmUgYiBpKSBsc2wgKFN5cy5pbnRfc2l6ZSAtIDE2KSkgYXNyIChTeXMuaW50X3NpemUgLSAxNilcblxubGV0IGdldF9pbnQxNl9sZSBiIGkgPVxuICAoKGdldF91aW50MTZfbGUgYiBpKSBsc2wgKFN5cy5pbnRfc2l6ZSAtIDE2KSkgYXNyIChTeXMuaW50X3NpemUgLSAxNilcblxubGV0IGdldF9pbnQxNl9iZSBiIGkgPVxuICAoKGdldF91aW50MTZfYmUgYiBpKSBsc2wgKFN5cy5pbnRfc2l6ZSAtIDE2KSkgYXNyIChTeXMuaW50X3NpemUgLSAxNilcblxubGV0IGdldF9pbnQzMl9sZSBiIGkgPVxuICBpZiBTeXMuYmlnX2VuZGlhbiB0aGVuIHN3YXAzMiAoZ2V0X2ludDMyX25lIGIgaSlcbiAgZWxzZSBnZXRfaW50MzJfbmUgYiBpXG5cbmxldCBnZXRfaW50MzJfYmUgYiBpID1cbiAgaWYgbm90IFN5cy5iaWdfZW5kaWFuIHRoZW4gc3dhcDMyIChnZXRfaW50MzJfbmUgYiBpKVxuICBlbHNlIGdldF9pbnQzMl9uZSBiIGlcblxubGV0IGdldF9pbnQ2NF9sZSBiIGkgPVxuICBpZiBTeXMuYmlnX2VuZGlhbiB0aGVuIHN3YXA2NCAoZ2V0X2ludDY0X25lIGIgaSlcbiAgZWxzZSBnZXRfaW50NjRfbmUgYiBpXG5cbmxldCBnZXRfaW50NjRfYmUgYiBpID1cbiAgaWYgbm90IFN5cy5iaWdfZW5kaWFuIHRoZW4gc3dhcDY0IChnZXRfaW50NjRfbmUgYiBpKVxuICBlbHNlIGdldF9pbnQ2NF9uZSBiIGlcblxubGV0IHNldF9pbnQxNl9sZSBiIGkgeCA9XG4gIGlmIFN5cy5iaWdfZW5kaWFuIHRoZW4gc2V0X2ludDE2X25lIGIgaSAoc3dhcDE2IHgpXG4gIGVsc2Ugc2V0X2ludDE2X25lIGIgaSB4XG5cbmxldCBzZXRfaW50MTZfYmUgYiBpIHggPVxuICBpZiBub3QgU3lzLmJpZ19lbmRpYW4gdGhlbiBzZXRfaW50MTZfbmUgYiBpIChzd2FwMTYgeClcbiAgZWxzZSBzZXRfaW50MTZfbmUgYiBpIHhcblxubGV0IHNldF9pbnQzMl9sZSBiIGkgeCA9XG4gIGlmIFN5cy5iaWdfZW5kaWFuIHRoZW4gc2V0X2ludDMyX25lIGIgaSAoc3dhcDMyIHgpXG4gIGVsc2Ugc2V0X2ludDMyX25lIGIgaSB4XG5cbmxldCBzZXRfaW50MzJfYmUgYiBpIHggPVxuICBpZiBub3QgU3lzLmJpZ19lbmRpYW4gdGhlbiBzZXRfaW50MzJfbmUgYiBpIChzd2FwMzIgeClcbiAgZWxzZSBzZXRfaW50MzJfbmUgYiBpIHhcblxubGV0IHNldF9pbnQ2NF9sZSBiIGkgeCA9XG4gIGlmIFN5cy5iaWdfZW5kaWFuIHRoZW4gc2V0X2ludDY0X25lIGIgaSAoc3dhcDY0IHgpXG4gIGVsc2Ugc2V0X2ludDY0X25lIGIgaSB4XG5cbmxldCBzZXRfaW50NjRfYmUgYiBpIHggPVxuICBpZiBub3QgU3lzLmJpZ19lbmRpYW4gdGhlbiBzZXRfaW50NjRfbmUgYiBpIChzd2FwNjQgeClcbiAgZWxzZSBzZXRfaW50NjRfbmUgYiBpIHhcblxubGV0IHNldF91aW50OCA9IHNldF9pbnQ4XG5sZXQgc2V0X3VpbnQxNl9uZSA9IHNldF9pbnQxNl9uZVxubGV0IHNldF91aW50MTZfYmUgPSBzZXRfaW50MTZfYmVcbmxldCBzZXRfdWludDE2X2xlID0gc2V0X2ludDE2X2xlXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgRGFtaWVuIERvbGlnZXosIHByb2pldCBHYWxsaXVtLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE0IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIFN0cmluZyBvcGVyYXRpb25zLCBiYXNlZCBvbiBieXRlIHNlcXVlbmNlIG9wZXJhdGlvbnMgKilcblxuKCogV0FSTklORzogU29tZSBmdW5jdGlvbnMgaW4gdGhpcyBmaWxlIGFyZSBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sIGZvclxuICAgZWZmaWNpZW5jeSByZWFzb25zLiBXaGVuIHlvdSBtb2RpZnkgdGhlIG9uZSBpbiB0aGlzIGZpbGUgeW91IG5lZWQgdG9cbiAgIG1vZGlmeSBpdHMgZHVwbGljYXRlIGluIGJ5dGVzLm1sLlxuICAgVGhlc2UgZnVuY3Rpb25zIGhhdmUgYSBcImR1cGxpY2F0ZWRcIiBjb21tZW50IGFib3ZlIHRoZWlyIGRlZmluaXRpb24uXG4qKVxuXG5leHRlcm5hbCBsZW5ndGggOiBzdHJpbmcgLT4gaW50ID0gXCIlc3RyaW5nX2xlbmd0aFwiXG5leHRlcm5hbCBnZXQgOiBzdHJpbmcgLT4gaW50IC0+IGNoYXIgPSBcIiVzdHJpbmdfc2FmZV9nZXRcIlxuZXh0ZXJuYWwgc2V0IDogYnl0ZXMgLT4gaW50IC0+IGNoYXIgLT4gdW5pdCA9IFwiJXN0cmluZ19zYWZlX3NldFwiXG5leHRlcm5hbCBjcmVhdGUgOiBpbnQgLT4gYnl0ZXMgPSBcImNhbWxfY3JlYXRlX3N0cmluZ1wiXG5leHRlcm5hbCB1bnNhZmVfZ2V0IDogc3RyaW5nIC0+IGludCAtPiBjaGFyID0gXCIlc3RyaW5nX3Vuc2FmZV9nZXRcIlxuZXh0ZXJuYWwgdW5zYWZlX3NldCA6IGJ5dGVzIC0+IGludCAtPiBjaGFyIC0+IHVuaXQgPSBcIiVzdHJpbmdfdW5zYWZlX3NldFwiXG5leHRlcm5hbCB1bnNhZmVfYmxpdCA6IHN0cmluZyAtPiBpbnQgLT4gIGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfYmxpdF9zdHJpbmdcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdW5zYWZlX2ZpbGwgOiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IGNoYXIgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfZmlsbF9zdHJpbmdcIiBbQEBub2FsbG9jXVxuXG5tb2R1bGUgQiA9IEJ5dGVzXG5cbmxldCBidHMgPSBCLnVuc2FmZV90b19zdHJpbmdcbmxldCBib3MgPSBCLnVuc2FmZV9vZl9zdHJpbmdcblxubGV0IG1ha2UgbiBjID1cbiAgQi5tYWtlIG4gYyB8PiBidHNcbmxldCBpbml0IG4gZiA9XG4gIEIuaW5pdCBuIGYgfD4gYnRzXG5sZXQgY29weSBzID1cbiAgQi5jb3B5IChib3MgcykgfD4gYnRzXG5sZXQgc3ViIHMgb2ZzIGxlbiA9XG4gIEIuc3ViIChib3Mgcykgb2ZzIGxlbiB8PiBidHNcbmxldCBmaWxsID1cbiAgQi5maWxsXG5sZXQgYmxpdCA9XG4gIEIuYmxpdF9zdHJpbmdcblxubGV0IGVuc3VyZV9nZSAoeDppbnQpIHkgPSBpZiB4ID49IHkgdGhlbiB4IGVsc2UgaW52YWxpZF9hcmcgXCJTdHJpbmcuY29uY2F0XCJcblxubGV0IHJlYyBzdW1fbGVuZ3RocyBhY2Mgc2VwbGVuID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBhY2NcbiAgfCBoZCA6OiBbXSAtPiBsZW5ndGggaGQgKyBhY2NcbiAgfCBoZCA6OiB0bCAtPiBzdW1fbGVuZ3RocyAoZW5zdXJlX2dlIChsZW5ndGggaGQgKyBzZXBsZW4gKyBhY2MpIGFjYykgc2VwbGVuIHRsXG5cbmxldCByZWMgdW5zYWZlX2JsaXRzIGRzdCBwb3Mgc2VwIHNlcGxlbiA9IGZ1bmN0aW9uXG4gICAgW10gLT4gZHN0XG4gIHwgaGQgOjogW10gLT5cbiAgICB1bnNhZmVfYmxpdCBoZCAwIGRzdCBwb3MgKGxlbmd0aCBoZCk7IGRzdFxuICB8IGhkIDo6IHRsIC0+XG4gICAgdW5zYWZlX2JsaXQgaGQgMCBkc3QgcG9zIChsZW5ndGggaGQpO1xuICAgIHVuc2FmZV9ibGl0IHNlcCAwIGRzdCAocG9zICsgbGVuZ3RoIGhkKSBzZXBsZW47XG4gICAgdW5zYWZlX2JsaXRzIGRzdCAocG9zICsgbGVuZ3RoIGhkICsgc2VwbGVuKSBzZXAgc2VwbGVuIHRsXG5cbmxldCBjb25jYXQgc2VwID0gZnVuY3Rpb25cbiAgICBbXSAtPiBcIlwiXG4gIHwgbCAtPiBsZXQgc2VwbGVuID0gbGVuZ3RoIHNlcCBpbiBidHMgQEBcbiAgICAgICAgICB1bnNhZmVfYmxpdHNcbiAgICAgICAgICAgIChCLmNyZWF0ZSAoc3VtX2xlbmd0aHMgMCBzZXBsZW4gbCkpXG4gICAgICAgICAgICAwIHNlcCBzZXBsZW4gbFxuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgaXRlciBmIHMgPVxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIHMgLSAxIGRvIGYgKHVuc2FmZV9nZXQgcyBpKSBkb25lXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCBpdGVyaSBmIHMgPVxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIHMgLSAxIGRvIGYgaSAodW5zYWZlX2dldCBzIGkpIGRvbmVcblxubGV0IG1hcCBmIHMgPVxuICBCLm1hcCBmIChib3MgcykgfD4gYnRzXG5sZXQgbWFwaSBmIHMgPVxuICBCLm1hcGkgZiAoYm9zIHMpIHw+IGJ0c1xuXG4oKiBCZXdhcmU6IHdlIGNhbm5vdCB1c2UgQi50cmltIG9yIEIuZXNjYXBlIGJlY2F1c2UgdGhleSBhbHdheXMgbWFrZSBhXG4gICBjb3B5LCBidXQgU3RyaW5nLm1saSBzcGVsbHMgb3V0IHNvbWUgY2FzZXMgd2hlcmUgd2UgYXJlIG5vdCBhbGxvd2VkXG4gICB0byBtYWtlIGEgY29weS4gKilcblxubGV0IGlzX3NwYWNlID0gZnVuY3Rpb25cbiAgfCAnICcgfCAnXFwwMTInIHwgJ1xcbicgfCAnXFxyJyB8ICdcXHQnIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG5cbmxldCB0cmltIHMgPVxuICBpZiBzID0gXCJcIiB0aGVuIHNcbiAgZWxzZSBpZiBpc19zcGFjZSAodW5zYWZlX2dldCBzIDApIHx8IGlzX3NwYWNlICh1bnNhZmVfZ2V0IHMgKGxlbmd0aCBzIC0gMSkpXG4gICAgdGhlbiBidHMgKEIudHJpbSAoYm9zIHMpKVxuICBlbHNlIHNcblxubGV0IGVzY2FwZWQgcyA9XG4gIGxldCByZWMgZXNjYXBlX2lmX25lZWRlZCBzIG4gaSA9XG4gICAgaWYgaSA+PSBuIHRoZW4gcyBlbHNlXG4gICAgICBtYXRjaCB1bnNhZmVfZ2V0IHMgaSB3aXRoXG4gICAgICB8ICdcXFwiJyB8ICdcXFxcJyB8ICdcXDAwMCcuLidcXDAzMScgfCAnXFwxMjcnLi4gJ1xcMjU1JyAtPlxuICAgICAgICAgIGJ0cyAoQi5lc2NhcGVkIChib3MgcykpXG4gICAgICB8IF8gLT4gZXNjYXBlX2lmX25lZWRlZCBzIG4gKGkrMSlcbiAgaW5cbiAgZXNjYXBlX2lmX25lZWRlZCBzIChsZW5ndGggcykgMFxuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgcmVjIGluZGV4X3JlYyBzIGxpbSBpIGMgPVxuICBpZiBpID49IGxpbSB0aGVuIHJhaXNlIE5vdF9mb3VuZCBlbHNlXG4gIGlmIHVuc2FmZV9nZXQgcyBpID0gYyB0aGVuIGkgZWxzZSBpbmRleF9yZWMgcyBsaW0gKGkgKyAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCBpbmRleCBzIGMgPSBpbmRleF9yZWMgcyAobGVuZ3RoIHMpIDAgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgcmVjIGluZGV4X3JlY19vcHQgcyBsaW0gaSBjID1cbiAgaWYgaSA+PSBsaW0gdGhlbiBOb25lIGVsc2VcbiAgaWYgdW5zYWZlX2dldCBzIGkgPSBjIHRoZW4gU29tZSBpIGVsc2UgaW5kZXhfcmVjX29wdCBzIGxpbSAoaSArIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IGluZGV4X29wdCBzIGMgPSBpbmRleF9yZWNfb3B0IHMgKGxlbmd0aCBzKSAwIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IGluZGV4X2Zyb20gcyBpIGMgPVxuICBsZXQgbCA9IGxlbmd0aCBzIGluXG4gIGlmIGkgPCAwIHx8IGkgPiBsIHRoZW4gaW52YWxpZF9hcmcgXCJTdHJpbmcuaW5kZXhfZnJvbSAvIEJ5dGVzLmluZGV4X2Zyb21cIiBlbHNlXG4gICAgaW5kZXhfcmVjIHMgbCBpIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IGluZGV4X2Zyb21fb3B0IHMgaSBjID1cbiAgbGV0IGwgPSBsZW5ndGggcyBpblxuICBpZiBpIDwgMCB8fCBpID4gbCB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJTdHJpbmcuaW5kZXhfZnJvbV9vcHQgLyBCeXRlcy5pbmRleF9mcm9tX29wdFwiXG4gIGVsc2VcbiAgICBpbmRleF9yZWNfb3B0IHMgbCBpIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IHJlYyByaW5kZXhfcmVjIHMgaSBjID1cbiAgaWYgaSA8IDAgdGhlbiByYWlzZSBOb3RfZm91bmQgZWxzZVxuICBpZiB1bnNhZmVfZ2V0IHMgaSA9IGMgdGhlbiBpIGVsc2UgcmluZGV4X3JlYyBzIChpIC0gMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgcmluZGV4IHMgYyA9IHJpbmRleF9yZWMgcyAobGVuZ3RoIHMgLSAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCByaW5kZXhfZnJvbSBzIGkgYyA9XG4gIGlmIGkgPCAtMSB8fCBpID49IGxlbmd0aCBzIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIlN0cmluZy5yaW5kZXhfZnJvbSAvIEJ5dGVzLnJpbmRleF9mcm9tXCJcbiAgZWxzZVxuICAgIHJpbmRleF9yZWMgcyBpIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IHJlYyByaW5kZXhfcmVjX29wdCBzIGkgYyA9XG4gIGlmIGkgPCAwIHRoZW4gTm9uZSBlbHNlXG4gIGlmIHVuc2FmZV9nZXQgcyBpID0gYyB0aGVuIFNvbWUgaSBlbHNlIHJpbmRleF9yZWNfb3B0IHMgKGkgLSAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCByaW5kZXhfb3B0IHMgYyA9IHJpbmRleF9yZWNfb3B0IHMgKGxlbmd0aCBzIC0gMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgcmluZGV4X2Zyb21fb3B0IHMgaSBjID1cbiAgaWYgaSA8IC0xIHx8IGkgPj0gbGVuZ3RoIHMgdGhlblxuICAgIGludmFsaWRfYXJnIFwiU3RyaW5nLnJpbmRleF9mcm9tX29wdCAvIEJ5dGVzLnJpbmRleF9mcm9tX29wdFwiXG4gIGVsc2VcbiAgICByaW5kZXhfcmVjX29wdCBzIGkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgY29udGFpbnNfZnJvbSBzIGkgYyA9XG4gIGxldCBsID0gbGVuZ3RoIHMgaW5cbiAgaWYgaSA8IDAgfHwgaSA+IGwgdGhlblxuICAgIGludmFsaWRfYXJnIFwiU3RyaW5nLmNvbnRhaW5zX2Zyb20gLyBCeXRlcy5jb250YWluc19mcm9tXCJcbiAgZWxzZVxuICAgIHRyeSBpZ25vcmUgKGluZGV4X3JlYyBzIGwgaSBjKTsgdHJ1ZSB3aXRoIE5vdF9mb3VuZCAtPiBmYWxzZVxuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgY29udGFpbnMgcyBjID0gY29udGFpbnNfZnJvbSBzIDAgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgcmNvbnRhaW5zX2Zyb20gcyBpIGMgPVxuICBpZiBpIDwgMCB8fCBpID49IGxlbmd0aCBzIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIlN0cmluZy5yY29udGFpbnNfZnJvbSAvIEJ5dGVzLnJjb250YWluc19mcm9tXCJcbiAgZWxzZVxuICAgIHRyeSBpZ25vcmUgKHJpbmRleF9yZWMgcyBpIGMpOyB0cnVlIHdpdGggTm90X2ZvdW5kIC0+IGZhbHNlXG5cbmxldCB1cHBlcmNhc2VfYXNjaWkgcyA9XG4gIEIudXBwZXJjYXNlX2FzY2lpIChib3MgcykgfD4gYnRzXG5sZXQgbG93ZXJjYXNlX2FzY2lpIHMgPVxuICBCLmxvd2VyY2FzZV9hc2NpaSAoYm9zIHMpIHw+IGJ0c1xubGV0IGNhcGl0YWxpemVfYXNjaWkgcyA9XG4gIEIuY2FwaXRhbGl6ZV9hc2NpaSAoYm9zIHMpIHw+IGJ0c1xubGV0IHVuY2FwaXRhbGl6ZV9hc2NpaSBzID1cbiAgQi51bmNhcGl0YWxpemVfYXNjaWkgKGJvcyBzKSB8PiBidHNcblxubGV0IHNwbGl0X29uX2NoYXIgc2VwIHMgPVxuICBsZXQgciA9IHJlZiBbXSBpblxuICBsZXQgaiA9IHJlZiAobGVuZ3RoIHMpIGluXG4gIGZvciBpID0gbGVuZ3RoIHMgLSAxIGRvd250byAwIGRvXG4gICAgaWYgdW5zYWZlX2dldCBzIGkgPSBzZXAgdGhlbiBiZWdpblxuICAgICAgciA6PSBzdWIgcyAoaSArIDEpICghaiAtIGkgLSAxKSA6OiAhcjtcbiAgICAgIGogOj0gaVxuICAgIGVuZFxuICBkb25lO1xuICBzdWIgcyAwICFqIDo6ICFyXG5cbigqIERlcHJlY2F0ZWQgZnVuY3Rpb25zIGltcGxlbWVudGVkIHZpYSBvdGhlciBkZXByZWNhdGVkIGZ1bmN0aW9ucyAqKVxuW0BAQG9jYW1sLndhcm5pbmcgXCItM1wiXVxubGV0IHVwcGVyY2FzZSBzID1cbiAgQi51cHBlcmNhc2UgKGJvcyBzKSB8PiBidHNcbmxldCBsb3dlcmNhc2UgcyA9XG4gIEIubG93ZXJjYXNlIChib3MgcykgfD4gYnRzXG5sZXQgY2FwaXRhbGl6ZSBzID1cbiAgQi5jYXBpdGFsaXplIChib3MgcykgfD4gYnRzXG5sZXQgdW5jYXBpdGFsaXplIHMgPVxuICBCLnVuY2FwaXRhbGl6ZSAoYm9zIHMpIHw+IGJ0c1xuXG50eXBlIHQgPSBzdHJpbmdcblxubGV0IGNvbXBhcmUgKHg6IHQpICh5OiB0KSA9IFN0ZGxpYi5jb21wYXJlIHggeVxuZXh0ZXJuYWwgZXF1YWwgOiBzdHJpbmcgLT4gc3RyaW5nIC0+IGJvb2wgPSBcImNhbWxfc3RyaW5nX2VxdWFsXCIgW0BAbm9hbGxvY11cblxuKCoqIHsxIEl0ZXJhdG9yc30gKilcblxubGV0IHRvX3NlcSBzID0gYm9zIHMgfD4gQi50b19zZXFcblxubGV0IHRvX3NlcWkgcyA9IGJvcyBzIHw+IEIudG9fc2VxaVxuXG5sZXQgb2Zfc2VxIGcgPSBCLm9mX3NlcSBnIHw+IGJ0c1xuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgVGhlIE9DYW1sIHByb2dyYW1tZXJzICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxOCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlIHQgPSB1bml0ID0gKClcblxubGV0IGVxdWFsICgpICgpID0gdHJ1ZVxubGV0IGNvbXBhcmUgKCkgKCkgPSAwXG5sZXQgdG9fc3RyaW5nICgpID0gXCIoKVwiXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk3IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUgZXh0ZXJuX2ZsYWdzID1cbiAgICBOb19zaGFyaW5nXG4gIHwgQ2xvc3VyZXNcbiAgfCBDb21wYXRfMzJcbigqIG5vdGU6IHRoaXMgdHlwZSBkZWZpbml0aW9uIGlzIHVzZWQgaW4gJ3J1bnRpbWUvZGVidWdnZXIuYycgKilcblxuZXh0ZXJuYWwgdG9fY2hhbm5lbDogb3V0X2NoYW5uZWwgLT4gJ2EgLT4gZXh0ZXJuX2ZsYWdzIGxpc3QgLT4gdW5pdFxuICAgID0gXCJjYW1sX291dHB1dF92YWx1ZVwiXG5leHRlcm5hbCB0b19ieXRlczogJ2EgLT4gZXh0ZXJuX2ZsYWdzIGxpc3QgLT4gYnl0ZXNcbiAgICA9IFwiY2FtbF9vdXRwdXRfdmFsdWVfdG9fYnl0ZXNcIlxuZXh0ZXJuYWwgdG9fc3RyaW5nOiAnYSAtPiBleHRlcm5fZmxhZ3MgbGlzdCAtPiBzdHJpbmdcbiAgICA9IFwiY2FtbF9vdXRwdXRfdmFsdWVfdG9fc3RyaW5nXCJcbmV4dGVybmFsIHRvX2J1ZmZlcl91bnNhZmU6XG4gICAgICBieXRlcyAtPiBpbnQgLT4gaW50IC0+ICdhIC0+IGV4dGVybl9mbGFncyBsaXN0IC0+IGludFxuICAgID0gXCJjYW1sX291dHB1dF92YWx1ZV90b19idWZmZXJcIlxuXG5sZXQgdG9fYnVmZmVyIGJ1ZmYgb2ZzIGxlbiB2IGZsYWdzID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IEJ5dGVzLmxlbmd0aCBidWZmIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJNYXJzaGFsLnRvX2J1ZmZlcjogc3Vic3RyaW5nIG91dCBvZiBib3VuZHNcIlxuICBlbHNlIHRvX2J1ZmZlcl91bnNhZmUgYnVmZiBvZnMgbGVuIHYgZmxhZ3NcblxuKCogVGhlIGZ1bmN0aW9ucyBiZWxvdyB1c2UgYnl0ZSBzZXF1ZW5jZXMgYXMgaW5wdXQsIG5ldmVyIHVzaW5nIGFueVxuICAgbXV0YXRpb24uIEl0IG1ha2VzIHNlbnNlIHRvIHVzZSBub24tbXV0YXRlZCBbYnl0ZXNdIHJhdGhlciB0aGFuXG4gICBbc3RyaW5nXSwgYmVjYXVzZSB3ZSByZWFsbHkgd29yayB3aXRoIHNlcXVlbmNlcyBvZiBieXRlcywgbm90XG4gICBhIHRleHQgcmVwcmVzZW50YXRpb24uXG4qKVxuXG5leHRlcm5hbCBmcm9tX2NoYW5uZWw6IGluX2NoYW5uZWwgLT4gJ2EgPSBcImNhbWxfaW5wdXRfdmFsdWVcIlxuZXh0ZXJuYWwgZnJvbV9ieXRlc191bnNhZmU6IGJ5dGVzIC0+IGludCAtPiAnYSA9IFwiY2FtbF9pbnB1dF92YWx1ZV9mcm9tX2J5dGVzXCJcbmV4dGVybmFsIGRhdGFfc2l6ZV91bnNhZmU6IGJ5dGVzIC0+IGludCAtPiBpbnQgPSBcImNhbWxfbWFyc2hhbF9kYXRhX3NpemVcIlxuXG5sZXQgaGVhZGVyX3NpemUgPSAyMFxubGV0IGRhdGFfc2l6ZSBidWZmIG9mcyA9XG4gIGlmIG9mcyA8IDAgfHwgb2ZzID4gQnl0ZXMubGVuZ3RoIGJ1ZmYgLSBoZWFkZXJfc2l6ZVxuICB0aGVuIGludmFsaWRfYXJnIFwiTWFyc2hhbC5kYXRhX3NpemVcIlxuICBlbHNlIGRhdGFfc2l6ZV91bnNhZmUgYnVmZiBvZnNcbmxldCB0b3RhbF9zaXplIGJ1ZmYgb2ZzID0gaGVhZGVyX3NpemUgKyBkYXRhX3NpemUgYnVmZiBvZnNcblxubGV0IGZyb21fYnl0ZXMgYnVmZiBvZnMgPVxuICBpZiBvZnMgPCAwIHx8IG9mcyA+IEJ5dGVzLmxlbmd0aCBidWZmIC0gaGVhZGVyX3NpemVcbiAgdGhlbiBpbnZhbGlkX2FyZyBcIk1hcnNoYWwuZnJvbV9ieXRlc1wiXG4gIGVsc2UgYmVnaW5cbiAgICBsZXQgbGVuID0gZGF0YV9zaXplX3Vuc2FmZSBidWZmIG9mcyBpblxuICAgIGlmIG9mcyA+IEJ5dGVzLmxlbmd0aCBidWZmIC0gKGhlYWRlcl9zaXplICsgbGVuKVxuICAgIHRoZW4gaW52YWxpZF9hcmcgXCJNYXJzaGFsLmZyb21fYnl0ZXNcIlxuICAgIGVsc2UgZnJvbV9ieXRlc191bnNhZmUgYnVmZiBvZnNcbiAgZW5kXG5cbmxldCBmcm9tX3N0cmluZyBidWZmIG9mcyA9XG4gICgqIEJ5dGVzLnVuc2FmZV9vZl9zdHJpbmcgaXMgc2FmZSBoZXJlLCBhcyB0aGUgcHJvZHVjZWQgYnl0ZVxuICAgICBzZXF1ZW5jZSBpcyBuZXZlciBtdXRhdGVkICopXG4gIGZyb21fYnl0ZXMgKEJ5dGVzLnVuc2FmZV9vZl9zdHJpbmcgYnVmZikgb2ZzXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIE9wZXJhdGlvbnMgb24gaW50ZXJuYWwgcmVwcmVzZW50YXRpb25zIG9mIHZhbHVlcyAqKVxuXG50eXBlIHRcblxudHlwZSByYXdfZGF0YSA9IG5hdGl2ZWludFxuXG5leHRlcm5hbCByZXByIDogJ2EgLT4gdCA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIG9iaiA6IHQgLT4gJ2EgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCBtYWdpYyA6ICdhIC0+ICdiID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgaXNfaW50IDogdCAtPiBib29sID0gXCIlb2JqX2lzX2ludFwiXG5sZXQgW0BpbmxpbmUgYWx3YXlzXSBpc19ibG9jayBhID0gbm90IChpc19pbnQgYSlcbmV4dGVybmFsIHRhZyA6IHQgLT4gaW50ID0gXCJjYW1sX29ial90YWdcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgc2V0X3RhZyA6IHQgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfb2JqX3NldF90YWdcIlxuZXh0ZXJuYWwgc2l6ZSA6IHQgLT4gaW50ID0gXCIlb2JqX3NpemVcIlxuZXh0ZXJuYWwgcmVhY2hhYmxlX3dvcmRzIDogdCAtPiBpbnQgPSBcImNhbWxfb2JqX3JlYWNoYWJsZV93b3Jkc1wiXG5leHRlcm5hbCBmaWVsZCA6IHQgLT4gaW50IC0+IHQgPSBcIiVvYmpfZmllbGRcIlxuZXh0ZXJuYWwgc2V0X2ZpZWxkIDogdCAtPiBpbnQgLT4gdCAtPiB1bml0ID0gXCIlb2JqX3NldF9maWVsZFwiXG5leHRlcm5hbCBmbG9hdGFycmF5X2dldCA6IGZsb2F0YXJyYXkgLT4gaW50IC0+IGZsb2F0ID0gXCJjYW1sX2Zsb2F0YXJyYXlfZ2V0XCJcbmV4dGVybmFsIGZsb2F0YXJyYXlfc2V0IDpcbiAgICBmbG9hdGFycmF5IC0+IGludCAtPiBmbG9hdCAtPiB1bml0ID0gXCJjYW1sX2Zsb2F0YXJyYXlfc2V0XCJcbmxldCBbQGlubGluZSBhbHdheXNdIGRvdWJsZV9maWVsZCB4IGkgPSBmbG9hdGFycmF5X2dldCAob2JqIHggOiBmbG9hdGFycmF5KSBpXG5sZXQgW0BpbmxpbmUgYWx3YXlzXSBzZXRfZG91YmxlX2ZpZWxkIHggaSB2ID1cbiAgZmxvYXRhcnJheV9zZXQgKG9iaiB4IDogZmxvYXRhcnJheSkgaSB2XG5leHRlcm5hbCByYXdfZmllbGQgOiB0IC0+IGludCAtPiByYXdfZGF0YSA9IFwiY2FtbF9vYmpfcmF3X2ZpZWxkXCJcbmV4dGVybmFsIHNldF9yYXdfZmllbGQgOiB0IC0+IGludCAtPiByYXdfZGF0YSAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9vYmpfc2V0X3Jhd19maWVsZFwiXG5cbmV4dGVybmFsIG5ld19ibG9jayA6IGludCAtPiBpbnQgLT4gdCA9IFwiY2FtbF9vYmpfYmxvY2tcIlxuZXh0ZXJuYWwgZHVwIDogdCAtPiB0ID0gXCJjYW1sX29ial9kdXBcIlxuZXh0ZXJuYWwgdHJ1bmNhdGUgOiB0IC0+IGludCAtPiB1bml0ID0gXCJjYW1sX29ial90cnVuY2F0ZVwiXG5leHRlcm5hbCBhZGRfb2Zmc2V0IDogdCAtPiBJbnQzMi50IC0+IHQgPSBcImNhbWxfb2JqX2FkZF9vZmZzZXRcIlxuZXh0ZXJuYWwgd2l0aF90YWcgOiBpbnQgLT4gdCAtPiB0ID0gXCJjYW1sX29ial93aXRoX3RhZ1wiXG5cbmxldCBtYXJzaGFsIChvYmogOiB0KSA9XG4gIE1hcnNoYWwudG9fYnl0ZXMgb2JqIFtdXG5sZXQgdW5tYXJzaGFsIHN0ciBwb3MgPVxuICAoTWFyc2hhbC5mcm9tX2J5dGVzIHN0ciBwb3MsIHBvcyArIE1hcnNoYWwudG90YWxfc2l6ZSBzdHIgcG9zKVxuXG5sZXQgZmlyc3Rfbm9uX2NvbnN0YW50X2NvbnN0cnVjdG9yX3RhZyA9IDBcbmxldCBsYXN0X25vbl9jb25zdGFudF9jb25zdHJ1Y3Rvcl90YWcgPSAyNDVcblxubGV0IGxhenlfdGFnID0gMjQ2XG5sZXQgY2xvc3VyZV90YWcgPSAyNDdcbmxldCBvYmplY3RfdGFnID0gMjQ4XG5sZXQgaW5maXhfdGFnID0gMjQ5XG5sZXQgZm9yd2FyZF90YWcgPSAyNTBcblxubGV0IG5vX3NjYW5fdGFnID0gMjUxXG5cbmxldCBhYnN0cmFjdF90YWcgPSAyNTFcbmxldCBzdHJpbmdfdGFnID0gMjUyXG5sZXQgZG91YmxlX3RhZyA9IDI1M1xubGV0IGRvdWJsZV9hcnJheV90YWcgPSAyNTRcbmxldCBjdXN0b21fdGFnID0gMjU1XG5sZXQgZmluYWxfdGFnID0gY3VzdG9tX3RhZ1xuXG5cbmxldCBpbnRfdGFnID0gMTAwMFxubGV0IG91dF9vZl9oZWFwX3RhZyA9IDEwMDFcbmxldCB1bmFsaWduZWRfdGFnID0gMTAwMlxuXG5tb2R1bGUgQ2xvc3VyZSA9IHN0cnVjdFxuICB0eXBlIGluZm8gPSB7XG4gICAgYXJpdHk6IGludDtcbiAgICBzdGFydF9lbnY6IGludDtcbiAgfVxuXG4gIGxldCBpbmZvX29mX3JhdyAoaW5mbyA6IG5hdGl2ZWludCkgPVxuICAgIGxldCBvcGVuIE5hdGl2ZWludCBpblxuICAgIGxldCBhcml0eSA9XG4gICAgICAoKiBzaWduZWQ6IG5lZ2F0aXZlIGZvciB0dXBsZWQgZnVuY3Rpb25zICopXG4gICAgICBpZiBTeXMud29yZF9zaXplID0gNjQgdGhlblxuICAgICAgICB0b19pbnQgKHNoaWZ0X3JpZ2h0IGluZm8gNTYpXG4gICAgICBlbHNlXG4gICAgICAgIHRvX2ludCAoc2hpZnRfcmlnaHQgaW5mbyAyNClcbiAgICBpblxuICAgIGxldCBzdGFydF9lbnYgPVxuICAgICAgKCogc3RhcnRfZW52IGlzIHVuc2lnbmVkLCBidXQgd2Uga25vdyBpdCBjYW4gYWx3YXlzIGZpdCBhbiBPQ2FtbFxuICAgICAgICAgaW50ZWdlciBzbyB3ZSB1c2UgW3RvX2ludF0gaW5zdGVhZCBvZiBbdW5zaWduZWRfdG9faW50XS4gKilcbiAgICAgIHRvX2ludCAoc2hpZnRfcmlnaHRfbG9naWNhbCAoc2hpZnRfbGVmdCBpbmZvIDgpIDkpIGluXG4gICAgeyBhcml0eTsgc3RhcnRfZW52IH1cblxuICAoKiBub3RlOiB3ZSBleHBlY3QgYSBjbG9zdXJlLCBub3QgYW4gaW5maXggcG9pbnRlciAqKVxuICBsZXQgaW5mbyAob2JqIDogdCkgPVxuICAgIGFzc2VydCAodGFnIG9iaiA9IGNsb3N1cmVfdGFnKTtcbiAgICBpbmZvX29mX3JhdyAocmF3X2ZpZWxkIG9iaiAxKVxuZW5kXG5cbm1vZHVsZSBFeHRlbnNpb25fY29uc3RydWN0b3IgPVxuc3RydWN0XG4gIHR5cGUgdCA9IGV4dGVuc2lvbl9jb25zdHJ1Y3RvclxuICBsZXQgb2ZfdmFsIHggPVxuICAgIGxldCB4ID0gcmVwciB4IGluXG4gICAgbGV0IHNsb3QgPVxuICAgICAgaWYgKGlzX2Jsb2NrIHgpICYmICh0YWcgeCkgPD4gb2JqZWN0X3RhZyAmJiAoc2l6ZSB4KSA+PSAxIHRoZW4gZmllbGQgeCAwXG4gICAgICBlbHNlIHhcbiAgICBpblxuICAgIGxldCBuYW1lID1cbiAgICAgIGlmIChpc19ibG9jayBzbG90KSAmJiAodGFnIHNsb3QpID0gb2JqZWN0X3RhZyB0aGVuIGZpZWxkIHNsb3QgMFxuICAgICAgZWxzZSBpbnZhbGlkX2FyZyBcIk9iai5leHRlbnNpb25fY29uc3RydWN0b3JcIlxuICAgIGluXG4gICAgICBpZiAodGFnIG5hbWUpID0gc3RyaW5nX3RhZyB0aGVuIChvYmogc2xvdCA6IHQpXG4gICAgICBlbHNlIGludmFsaWRfYXJnIFwiT2JqLmV4dGVuc2lvbl9jb25zdHJ1Y3RvclwiXG5cbiAgbGV0IFtAaW5saW5lIGFsd2F5c10gbmFtZSAoc2xvdCA6IHQpID1cbiAgICAob2JqIChmaWVsZCAocmVwciBzbG90KSAwKSA6IHN0cmluZylcblxuICBsZXQgW0BpbmxpbmUgYWx3YXlzXSBpZCAoc2xvdCA6IHQpID1cbiAgICAob2JqIChmaWVsZCAocmVwciBzbG90KSAxKSA6IGludClcbmVuZFxuXG5sZXQgZXh0ZW5zaW9uX2NvbnN0cnVjdG9yID0gRXh0ZW5zaW9uX2NvbnN0cnVjdG9yLm9mX3ZhbFxubGV0IGV4dGVuc2lvbl9uYW1lID0gRXh0ZW5zaW9uX2NvbnN0cnVjdG9yLm5hbWVcbmxldCBleHRlbnNpb25faWQgPSBFeHRlbnNpb25fY29uc3RydWN0b3IuaWRcblxubW9kdWxlIEVwaGVtZXJvbiA9IHN0cnVjdFxuICB0eXBlIG9ial90ID0gdFxuXG4gIHR5cGUgdCAoKiogZXBoZW1lcm9uICopXG5cbiAgICgqKiBUbyBjaGFuZ2UgaW4gc3luYyB3aXRoIHdlYWsuaCAqKVxuICBsZXQgYWRkaXRpb25hbF92YWx1ZXMgPSAyXG4gIGxldCBtYXhfZXBoZV9sZW5ndGggPSBTeXMubWF4X2FycmF5X2xlbmd0aCAtIGFkZGl0aW9uYWxfdmFsdWVzXG5cbiAgZXh0ZXJuYWwgY3JlYXRlIDogaW50IC0+IHQgPSBcImNhbWxfZXBoZV9jcmVhdGVcIjs7XG4gIGxldCBjcmVhdGUgbCA9XG4gICAgaWYgbm90ICgwIDw9IGwgJiYgbCA8PSBtYXhfZXBoZV9sZW5ndGgpIHRoZW5cbiAgICAgIGludmFsaWRfYXJnIFwiT2JqLkVwaGVtZXJvbi5jcmVhdGVcIjtcbiAgICBjcmVhdGUgbFxuXG4gIGxldCBsZW5ndGggeCA9IHNpemUocmVwciB4KSAtIGFkZGl0aW9uYWxfdmFsdWVzXG5cbiAgbGV0IHJhaXNlX2lmX2ludmFsaWRfb2Zmc2V0IGUgbyBtc2cgPVxuICAgIGlmIG5vdCAoMCA8PSBvICYmIG8gPCBsZW5ndGggZSkgdGhlblxuICAgICAgaW52YWxpZF9hcmcgbXNnXG5cbiAgZXh0ZXJuYWwgZ2V0X2tleTogdCAtPiBpbnQgLT4gb2JqX3Qgb3B0aW9uID0gXCJjYW1sX2VwaGVfZ2V0X2tleVwiXG4gIGxldCBnZXRfa2V5IGUgbyA9XG4gICAgcmFpc2VfaWZfaW52YWxpZF9vZmZzZXQgZSBvIFwiT2JqLkVwaGVtZXJvbi5nZXRfa2V5XCI7XG4gICAgZ2V0X2tleSBlIG9cblxuICBleHRlcm5hbCBnZXRfa2V5X2NvcHk6IHQgLT4gaW50IC0+IG9ial90IG9wdGlvbiA9IFwiY2FtbF9lcGhlX2dldF9rZXlfY29weVwiXG4gIGxldCBnZXRfa2V5X2NvcHkgZSBvID1cbiAgICByYWlzZV9pZl9pbnZhbGlkX29mZnNldCBlIG8gXCJPYmouRXBoZW1lcm9uLmdldF9rZXlfY29weVwiO1xuICAgIGdldF9rZXlfY29weSBlIG9cblxuICBleHRlcm5hbCBzZXRfa2V5OiB0IC0+IGludCAtPiBvYmpfdCAtPiB1bml0ID0gXCJjYW1sX2VwaGVfc2V0X2tleVwiXG4gIGxldCBzZXRfa2V5IGUgbyB4ID1cbiAgICByYWlzZV9pZl9pbnZhbGlkX29mZnNldCBlIG8gXCJPYmouRXBoZW1lcm9uLnNldF9rZXlcIjtcbiAgICBzZXRfa2V5IGUgbyB4XG5cbiAgZXh0ZXJuYWwgdW5zZXRfa2V5OiB0IC0+IGludCAtPiB1bml0ID0gXCJjYW1sX2VwaGVfdW5zZXRfa2V5XCJcbiAgbGV0IHVuc2V0X2tleSBlIG8gPVxuICAgIHJhaXNlX2lmX2ludmFsaWRfb2Zmc2V0IGUgbyBcIk9iai5FcGhlbWVyb24udW5zZXRfa2V5XCI7XG4gICAgdW5zZXRfa2V5IGUgb1xuXG4gIGV4dGVybmFsIGNoZWNrX2tleTogdCAtPiBpbnQgLT4gYm9vbCA9IFwiY2FtbF9lcGhlX2NoZWNrX2tleVwiXG4gIGxldCBjaGVja19rZXkgZSBvID1cbiAgICByYWlzZV9pZl9pbnZhbGlkX29mZnNldCBlIG8gXCJPYmouRXBoZW1lcm9uLmNoZWNrX2tleVwiO1xuICAgIGNoZWNrX2tleSBlIG9cblxuICBleHRlcm5hbCBibGl0X2tleSA6IHQgLT4gaW50IC0+IHQgLT4gaW50IC0+IGludCAtPiB1bml0XG4gICAgPSBcImNhbWxfZXBoZV9ibGl0X2tleVwiXG5cbiAgbGV0IGJsaXRfa2V5IGUxIG8xIGUyIG8yIGwgPVxuICAgIGlmIGwgPCAwIHx8IG8xIDwgMCB8fCBvMSA+IGxlbmd0aCBlMSAtIGxcbiAgICAgICB8fCBvMiA8IDAgfHwgbzIgPiBsZW5ndGggZTIgLSBsXG4gICAgdGhlbiBpbnZhbGlkX2FyZyBcIk9iai5FcGhlbWVyb24uYmxpdF9rZXlcIlxuICAgIGVsc2UgaWYgbCA8PiAwIHRoZW4gYmxpdF9rZXkgZTEgbzEgZTIgbzIgbFxuXG4gIGV4dGVybmFsIGdldF9kYXRhOiB0IC0+IG9ial90IG9wdGlvbiA9IFwiY2FtbF9lcGhlX2dldF9kYXRhXCJcbiAgZXh0ZXJuYWwgZ2V0X2RhdGFfY29weTogdCAtPiBvYmpfdCBvcHRpb24gPSBcImNhbWxfZXBoZV9nZXRfZGF0YV9jb3B5XCJcbiAgZXh0ZXJuYWwgc2V0X2RhdGE6IHQgLT4gb2JqX3QgLT4gdW5pdCA9IFwiY2FtbF9lcGhlX3NldF9kYXRhXCJcbiAgZXh0ZXJuYWwgdW5zZXRfZGF0YTogdCAtPiB1bml0ID0gXCJjYW1sX2VwaGVfdW5zZXRfZGF0YVwiXG4gIGV4dGVybmFsIGNoZWNrX2RhdGE6IHQgLT4gYm9vbCA9IFwiY2FtbF9lcGhlX2NoZWNrX2RhdGFcIlxuICBleHRlcm5hbCBibGl0X2RhdGEgOiB0IC0+IHQgLT4gdW5pdCA9IFwiY2FtbF9lcGhlX2JsaXRfZGF0YVwiXG5cbmVuZFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBBbiBhbGlhcyBmb3IgdGhlIHR5cGUgb2YgYXJyYXlzLiAqKVxudHlwZSAnYSB0ID0gJ2EgYXJyYXlcblxuKCogQXJyYXkgb3BlcmF0aW9ucyAqKVxuXG5leHRlcm5hbCBsZW5ndGggOiAnYSBhcnJheSAtPiBpbnQgPSBcIiVhcnJheV9sZW5ndGhcIlxuZXh0ZXJuYWwgZ2V0OiAnYSBhcnJheSAtPiBpbnQgLT4gJ2EgPSBcIiVhcnJheV9zYWZlX2dldFwiXG5leHRlcm5hbCBzZXQ6ICdhIGFycmF5IC0+IGludCAtPiAnYSAtPiB1bml0ID0gXCIlYXJyYXlfc2FmZV9zZXRcIlxuZXh0ZXJuYWwgdW5zYWZlX2dldDogJ2EgYXJyYXkgLT4gaW50IC0+ICdhID0gXCIlYXJyYXlfdW5zYWZlX2dldFwiXG5leHRlcm5hbCB1bnNhZmVfc2V0OiAnYSBhcnJheSAtPiBpbnQgLT4gJ2EgLT4gdW5pdCA9IFwiJWFycmF5X3Vuc2FmZV9zZXRcIlxuZXh0ZXJuYWwgbWFrZTogaW50IC0+ICdhIC0+ICdhIGFycmF5ID0gXCJjYW1sX21ha2VfdmVjdFwiXG5leHRlcm5hbCBjcmVhdGU6IGludCAtPiAnYSAtPiAnYSBhcnJheSA9IFwiY2FtbF9tYWtlX3ZlY3RcIlxuZXh0ZXJuYWwgdW5zYWZlX3N1YiA6ICdhIGFycmF5IC0+IGludCAtPiBpbnQgLT4gJ2EgYXJyYXkgPSBcImNhbWxfYXJyYXlfc3ViXCJcbmV4dGVybmFsIGFwcGVuZF9wcmltIDogJ2EgYXJyYXkgLT4gJ2EgYXJyYXkgLT4gJ2EgYXJyYXkgPSBcImNhbWxfYXJyYXlfYXBwZW5kXCJcbmV4dGVybmFsIGNvbmNhdCA6ICdhIGFycmF5IGxpc3QgLT4gJ2EgYXJyYXkgPSBcImNhbWxfYXJyYXlfY29uY2F0XCJcbmV4dGVybmFsIHVuc2FmZV9ibGl0IDpcbiAgJ2EgYXJyYXkgLT4gaW50IC0+ICdhIGFycmF5IC0+IGludCAtPiBpbnQgLT4gdW5pdCA9IFwiY2FtbF9hcnJheV9ibGl0XCJcbmV4dGVybmFsIHVuc2FmZV9maWxsIDpcbiAgJ2EgYXJyYXkgLT4gaW50IC0+IGludCAtPiAnYSAtPiB1bml0ID0gXCJjYW1sX2FycmF5X2ZpbGxcIlxuZXh0ZXJuYWwgY3JlYXRlX2Zsb2F0OiBpbnQgLT4gZmxvYXQgYXJyYXkgPSBcImNhbWxfbWFrZV9mbG9hdF92ZWN0XCJcbmxldCBtYWtlX2Zsb2F0ID0gY3JlYXRlX2Zsb2F0XG5cbm1vZHVsZSBGbG9hdGFycmF5ID0gc3RydWN0XG4gIGV4dGVybmFsIGNyZWF0ZSA6IGludCAtPiBmbG9hdGFycmF5ID0gXCJjYW1sX2Zsb2F0YXJyYXlfY3JlYXRlXCJcbiAgZXh0ZXJuYWwgbGVuZ3RoIDogZmxvYXRhcnJheSAtPiBpbnQgPSBcIiVmbG9hdGFycmF5X2xlbmd0aFwiXG4gIGV4dGVybmFsIGdldCA6IGZsb2F0YXJyYXkgLT4gaW50IC0+IGZsb2F0ID0gXCIlZmxvYXRhcnJheV9zYWZlX2dldFwiXG4gIGV4dGVybmFsIHNldCA6IGZsb2F0YXJyYXkgLT4gaW50IC0+IGZsb2F0IC0+IHVuaXQgPSBcIiVmbG9hdGFycmF5X3NhZmVfc2V0XCJcbiAgZXh0ZXJuYWwgdW5zYWZlX2dldCA6IGZsb2F0YXJyYXkgLT4gaW50IC0+IGZsb2F0ID0gXCIlZmxvYXRhcnJheV91bnNhZmVfZ2V0XCJcbiAgZXh0ZXJuYWwgdW5zYWZlX3NldCA6IGZsb2F0YXJyYXkgLT4gaW50IC0+IGZsb2F0IC0+IHVuaXRcbiAgICAgID0gXCIlZmxvYXRhcnJheV91bnNhZmVfc2V0XCJcbmVuZFxuXG5sZXQgaW5pdCBsIGYgPVxuICBpZiBsID0gMCB0aGVuIFt8fF0gZWxzZVxuICBpZiBsIDwgMCB0aGVuIGludmFsaWRfYXJnIFwiQXJyYXkuaW5pdFwiXG4gICgqIFNlZSAjNjU3NS4gV2UgY291bGQgYWxzbyBjaGVjayBmb3IgbWF4aW11bSBhcnJheSBzaXplLCBidXQgdGhpcyBkZXBlbmRzXG4gICAgIG9uIHdoZXRoZXIgd2UgY3JlYXRlIGEgZmxvYXQgYXJyYXkgb3IgYSByZWd1bGFyIG9uZS4uLiAqKVxuICBlbHNlXG4gICBsZXQgcmVzID0gY3JlYXRlIGwgKGYgMCkgaW5cbiAgIGZvciBpID0gMSB0byBwcmVkIGwgZG9cbiAgICAgdW5zYWZlX3NldCByZXMgaSAoZiBpKVxuICAgZG9uZTtcbiAgIHJlc1xuXG5sZXQgbWFrZV9tYXRyaXggc3ggc3kgaW5pdCA9XG4gIGxldCByZXMgPSBjcmVhdGUgc3ggW3x8XSBpblxuICBmb3IgeCA9IDAgdG8gcHJlZCBzeCBkb1xuICAgIHVuc2FmZV9zZXQgcmVzIHggKGNyZWF0ZSBzeSBpbml0KVxuICBkb25lO1xuICByZXNcblxubGV0IGNyZWF0ZV9tYXRyaXggPSBtYWtlX21hdHJpeFxuXG5sZXQgY29weSBhID1cbiAgbGV0IGwgPSBsZW5ndGggYSBpbiBpZiBsID0gMCB0aGVuIFt8fF0gZWxzZSB1bnNhZmVfc3ViIGEgMCBsXG5cbmxldCBhcHBlbmQgYTEgYTIgPVxuICBsZXQgbDEgPSBsZW5ndGggYTEgaW5cbiAgaWYgbDEgPSAwIHRoZW4gY29weSBhMlxuICBlbHNlIGlmIGxlbmd0aCBhMiA9IDAgdGhlbiB1bnNhZmVfc3ViIGExIDAgbDFcbiAgZWxzZSBhcHBlbmRfcHJpbSBhMSBhMlxuXG5sZXQgc3ViIGEgb2ZzIGxlbiA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBsZW5ndGggYSAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiQXJyYXkuc3ViXCJcbiAgZWxzZSB1bnNhZmVfc3ViIGEgb2ZzIGxlblxuXG5sZXQgZmlsbCBhIG9mcyBsZW4gdiA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBsZW5ndGggYSAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiQXJyYXkuZmlsbFwiXG4gIGVsc2UgdW5zYWZlX2ZpbGwgYSBvZnMgbGVuIHZcblxubGV0IGJsaXQgYTEgb2ZzMSBhMiBvZnMyIGxlbiA9XG4gIGlmIGxlbiA8IDAgfHwgb2ZzMSA8IDAgfHwgb2ZzMSA+IGxlbmd0aCBhMSAtIGxlblxuICAgICAgICAgICAgIHx8IG9mczIgPCAwIHx8IG9mczIgPiBsZW5ndGggYTIgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIkFycmF5LmJsaXRcIlxuICBlbHNlIHVuc2FmZV9ibGl0IGExIG9mczEgYTIgb2ZzMiBsZW5cblxubGV0IGl0ZXIgZiBhID1cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCBhIC0gMSBkbyBmKHVuc2FmZV9nZXQgYSBpKSBkb25lXG5cbmxldCBpdGVyMiBmIGEgYiA9XG4gIGlmIGxlbmd0aCBhIDw+IGxlbmd0aCBiIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIkFycmF5Lml0ZXIyOiBhcnJheXMgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aFwiXG4gIGVsc2VcbiAgICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvIGYgKHVuc2FmZV9nZXQgYSBpKSAodW5zYWZlX2dldCBiIGkpIGRvbmVcblxubGV0IG1hcCBmIGEgPVxuICBsZXQgbCA9IGxlbmd0aCBhIGluXG4gIGlmIGwgPSAwIHRoZW4gW3x8XSBlbHNlIGJlZ2luXG4gICAgbGV0IHIgPSBjcmVhdGUgbCAoZih1bnNhZmVfZ2V0IGEgMCkpIGluXG4gICAgZm9yIGkgPSAxIHRvIGwgLSAxIGRvXG4gICAgICB1bnNhZmVfc2V0IHIgaSAoZih1bnNhZmVfZ2V0IGEgaSkpXG4gICAgZG9uZTtcbiAgICByXG4gIGVuZFxuXG5sZXQgbWFwMiBmIGEgYiA9XG4gIGxldCBsYSA9IGxlbmd0aCBhIGluXG4gIGxldCBsYiA9IGxlbmd0aCBiIGluXG4gIGlmIGxhIDw+IGxiIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIkFycmF5Lm1hcDI6IGFycmF5cyBtdXN0IGhhdmUgdGhlIHNhbWUgbGVuZ3RoXCJcbiAgZWxzZSBiZWdpblxuICAgIGlmIGxhID0gMCB0aGVuIFt8fF0gZWxzZSBiZWdpblxuICAgICAgbGV0IHIgPSBjcmVhdGUgbGEgKGYgKHVuc2FmZV9nZXQgYSAwKSAodW5zYWZlX2dldCBiIDApKSBpblxuICAgICAgZm9yIGkgPSAxIHRvIGxhIC0gMSBkb1xuICAgICAgICB1bnNhZmVfc2V0IHIgaSAoZiAodW5zYWZlX2dldCBhIGkpICh1bnNhZmVfZ2V0IGIgaSkpXG4gICAgICBkb25lO1xuICAgICAgclxuICAgIGVuZFxuICBlbmRcblxubGV0IGl0ZXJpIGYgYSA9XG4gIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG8gZiBpICh1bnNhZmVfZ2V0IGEgaSkgZG9uZVxuXG5sZXQgbWFwaSBmIGEgPVxuICBsZXQgbCA9IGxlbmd0aCBhIGluXG4gIGlmIGwgPSAwIHRoZW4gW3x8XSBlbHNlIGJlZ2luXG4gICAgbGV0IHIgPSBjcmVhdGUgbCAoZiAwICh1bnNhZmVfZ2V0IGEgMCkpIGluXG4gICAgZm9yIGkgPSAxIHRvIGwgLSAxIGRvXG4gICAgICB1bnNhZmVfc2V0IHIgaSAoZiBpICh1bnNhZmVfZ2V0IGEgaSkpXG4gICAgZG9uZTtcbiAgICByXG4gIGVuZFxuXG5sZXQgdG9fbGlzdCBhID1cbiAgbGV0IHJlYyB0b2xpc3QgaSByZXMgPVxuICAgIGlmIGkgPCAwIHRoZW4gcmVzIGVsc2UgdG9saXN0IChpIC0gMSkgKHVuc2FmZV9nZXQgYSBpIDo6IHJlcykgaW5cbiAgdG9saXN0IChsZW5ndGggYSAtIDEpIFtdXG5cbigqIENhbm5vdCB1c2UgTGlzdC5sZW5ndGggaGVyZSBiZWNhdXNlIHRoZSBMaXN0IG1vZHVsZSBkZXBlbmRzIG9uIEFycmF5LiAqKVxubGV0IHJlYyBsaXN0X2xlbmd0aCBhY2N1ID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBhY2N1XG4gIHwgXzo6dCAtPiBsaXN0X2xlbmd0aCAoc3VjYyBhY2N1KSB0XG5cbmxldCBvZl9saXN0ID0gZnVuY3Rpb25cbiAgICBbXSAtPiBbfHxdXG4gIHwgaGQ6OnRsIGFzIGwgLT5cbiAgICAgIGxldCBhID0gY3JlYXRlIChsaXN0X2xlbmd0aCAwIGwpIGhkIGluXG4gICAgICBsZXQgcmVjIGZpbGwgaSA9IGZ1bmN0aW9uXG4gICAgICAgICAgW10gLT4gYVxuICAgICAgICB8IGhkOjp0bCAtPiB1bnNhZmVfc2V0IGEgaSBoZDsgZmlsbCAoaSsxKSB0bCBpblxuICAgICAgZmlsbCAxIHRsXG5cbmxldCBmb2xkX2xlZnQgZiB4IGEgPVxuICBsZXQgciA9IHJlZiB4IGluXG4gIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG9cbiAgICByIDo9IGYgIXIgKHVuc2FmZV9nZXQgYSBpKVxuICBkb25lO1xuICAhclxuXG5sZXQgZm9sZF9yaWdodCBmIGEgeCA9XG4gIGxldCByID0gcmVmIHggaW5cbiAgZm9yIGkgPSBsZW5ndGggYSAtIDEgZG93bnRvIDAgZG9cbiAgICByIDo9IGYgKHVuc2FmZV9nZXQgYSBpKSAhclxuICBkb25lO1xuICAhclxuXG5sZXQgZXhpc3RzIHAgYSA9XG4gIGxldCBuID0gbGVuZ3RoIGEgaW5cbiAgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPSBuIHRoZW4gZmFsc2VcbiAgICBlbHNlIGlmIHAgKHVuc2FmZV9nZXQgYSBpKSB0aGVuIHRydWVcbiAgICBlbHNlIGxvb3AgKHN1Y2MgaSkgaW5cbiAgbG9vcCAwXG5cbmxldCBmb3JfYWxsIHAgYSA9XG4gIGxldCBuID0gbGVuZ3RoIGEgaW5cbiAgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPSBuIHRoZW4gdHJ1ZVxuICAgIGVsc2UgaWYgcCAodW5zYWZlX2dldCBhIGkpIHRoZW4gbG9vcCAoc3VjYyBpKVxuICAgIGVsc2UgZmFsc2UgaW5cbiAgbG9vcCAwXG5cbmxldCBmb3JfYWxsMiBwIGwxIGwyID1cbiAgbGV0IG4xID0gbGVuZ3RoIGwxXG4gIGFuZCBuMiA9IGxlbmd0aCBsMiBpblxuICBpZiBuMSA8PiBuMiB0aGVuIGludmFsaWRfYXJnIFwiQXJyYXkuZm9yX2FsbDJcIlxuICBlbHNlIGxldCByZWMgbG9vcCBpID1cbiAgICBpZiBpID0gbjEgdGhlbiB0cnVlXG4gICAgZWxzZSBpZiBwICh1bnNhZmVfZ2V0IGwxIGkpICh1bnNhZmVfZ2V0IGwyIGkpIHRoZW4gbG9vcCAoc3VjYyBpKVxuICAgIGVsc2UgZmFsc2UgaW5cbiAgbG9vcCAwXG5cbmxldCBleGlzdHMyIHAgbDEgbDIgPVxuICBsZXQgbjEgPSBsZW5ndGggbDFcbiAgYW5kIG4yID0gbGVuZ3RoIGwyIGluXG4gIGlmIG4xIDw+IG4yIHRoZW4gaW52YWxpZF9hcmcgXCJBcnJheS5leGlzdHMyXCJcbiAgZWxzZSBsZXQgcmVjIGxvb3AgaSA9XG4gICAgaWYgaSA9IG4xIHRoZW4gZmFsc2VcbiAgICBlbHNlIGlmIHAgKHVuc2FmZV9nZXQgbDEgaSkgKHVuc2FmZV9nZXQgbDIgaSkgdGhlbiB0cnVlXG4gICAgZWxzZSBsb29wIChzdWNjIGkpIGluXG4gIGxvb3AgMFxuXG5sZXQgbWVtIHggYSA9XG4gIGxldCBuID0gbGVuZ3RoIGEgaW5cbiAgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPSBuIHRoZW4gZmFsc2VcbiAgICBlbHNlIGlmIGNvbXBhcmUgKHVuc2FmZV9nZXQgYSBpKSB4ID0gMCB0aGVuIHRydWVcbiAgICBlbHNlIGxvb3AgKHN1Y2MgaSkgaW5cbiAgbG9vcCAwXG5cbmxldCBtZW1xIHggYSA9XG4gIGxldCBuID0gbGVuZ3RoIGEgaW5cbiAgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPSBuIHRoZW4gZmFsc2VcbiAgICBlbHNlIGlmIHggPT0gKHVuc2FmZV9nZXQgYSBpKSB0aGVuIHRydWVcbiAgICBlbHNlIGxvb3AgKHN1Y2MgaSkgaW5cbiAgbG9vcCAwXG5cbmV4Y2VwdGlvbiBCb3R0b20gb2YgaW50XG5sZXQgc29ydCBjbXAgYSA9XG4gIGxldCBtYXhzb24gbCBpID1cbiAgICBsZXQgaTMxID0gaStpK2krMSBpblxuICAgIGxldCB4ID0gcmVmIGkzMSBpblxuICAgIGlmIGkzMSsyIDwgbCB0aGVuIGJlZ2luXG4gICAgICBpZiBjbXAgKGdldCBhIGkzMSkgKGdldCBhIChpMzErMSkpIDwgMCB0aGVuIHggOj0gaTMxKzE7XG4gICAgICBpZiBjbXAgKGdldCBhICF4KSAoZ2V0IGEgKGkzMSsyKSkgPCAwIHRoZW4geCA6PSBpMzErMjtcbiAgICAgICF4XG4gICAgZW5kIGVsc2VcbiAgICAgIGlmIGkzMSsxIDwgbCAmJiBjbXAgKGdldCBhIGkzMSkgKGdldCBhIChpMzErMSkpIDwgMFxuICAgICAgdGhlbiBpMzErMVxuICAgICAgZWxzZSBpZiBpMzEgPCBsIHRoZW4gaTMxIGVsc2UgcmFpc2UgKEJvdHRvbSBpKVxuICBpblxuICBsZXQgcmVjIHRyaWNrbGVkb3duIGwgaSBlID1cbiAgICBsZXQgaiA9IG1heHNvbiBsIGkgaW5cbiAgICBpZiBjbXAgKGdldCBhIGopIGUgPiAwIHRoZW4gYmVnaW5cbiAgICAgIHNldCBhIGkgKGdldCBhIGopO1xuICAgICAgdHJpY2tsZWRvd24gbCBqIGU7XG4gICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgIHNldCBhIGkgZTtcbiAgICBlbmQ7XG4gIGluXG4gIGxldCB0cmlja2xlIGwgaSBlID0gdHJ5IHRyaWNrbGVkb3duIGwgaSBlIHdpdGggQm90dG9tIGkgLT4gc2V0IGEgaSBlIGluXG4gIGxldCByZWMgYnViYmxlZG93biBsIGkgPVxuICAgIGxldCBqID0gbWF4c29uIGwgaSBpblxuICAgIHNldCBhIGkgKGdldCBhIGopO1xuICAgIGJ1YmJsZWRvd24gbCBqXG4gIGluXG4gIGxldCBidWJibGUgbCBpID0gdHJ5IGJ1YmJsZWRvd24gbCBpIHdpdGggQm90dG9tIGkgLT4gaSBpblxuICBsZXQgcmVjIHRyaWNrbGV1cCBpIGUgPVxuICAgIGxldCBmYXRoZXIgPSAoaSAtIDEpIC8gMyBpblxuICAgIGFzc2VydCAoaSA8PiBmYXRoZXIpO1xuICAgIGlmIGNtcCAoZ2V0IGEgZmF0aGVyKSBlIDwgMCB0aGVuIGJlZ2luXG4gICAgICBzZXQgYSBpIChnZXQgYSBmYXRoZXIpO1xuICAgICAgaWYgZmF0aGVyID4gMCB0aGVuIHRyaWNrbGV1cCBmYXRoZXIgZSBlbHNlIHNldCBhIDAgZTtcbiAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgc2V0IGEgaSBlO1xuICAgIGVuZDtcbiAgaW5cbiAgbGV0IGwgPSBsZW5ndGggYSBpblxuICBmb3IgaSA9IChsICsgMSkgLyAzIC0gMSBkb3dudG8gMCBkbyB0cmlja2xlIGwgaSAoZ2V0IGEgaSk7IGRvbmU7XG4gIGZvciBpID0gbCAtIDEgZG93bnRvIDIgZG9cbiAgICBsZXQgZSA9IChnZXQgYSBpKSBpblxuICAgIHNldCBhIGkgKGdldCBhIDApO1xuICAgIHRyaWNrbGV1cCAoYnViYmxlIGkgMCkgZTtcbiAgZG9uZTtcbiAgaWYgbCA+IDEgdGhlbiAobGV0IGUgPSAoZ2V0IGEgMSkgaW4gc2V0IGEgMSAoZ2V0IGEgMCk7IHNldCBhIDAgZSlcblxuXG5sZXQgY3V0b2ZmID0gNVxubGV0IHN0YWJsZV9zb3J0IGNtcCBhID1cbiAgbGV0IG1lcmdlIHNyYzFvZnMgc3JjMWxlbiBzcmMyIHNyYzJvZnMgc3JjMmxlbiBkc3QgZHN0b2ZzID1cbiAgICBsZXQgc3JjMXIgPSBzcmMxb2ZzICsgc3JjMWxlbiBhbmQgc3JjMnIgPSBzcmMyb2ZzICsgc3JjMmxlbiBpblxuICAgIGxldCByZWMgbG9vcCBpMSBzMSBpMiBzMiBkID1cbiAgICAgIGlmIGNtcCBzMSBzMiA8PSAwIHRoZW4gYmVnaW5cbiAgICAgICAgc2V0IGRzdCBkIHMxO1xuICAgICAgICBsZXQgaTEgPSBpMSArIDEgaW5cbiAgICAgICAgaWYgaTEgPCBzcmMxciB0aGVuXG4gICAgICAgICAgbG9vcCBpMSAoZ2V0IGEgaTEpIGkyIHMyIChkICsgMSlcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGJsaXQgc3JjMiBpMiBkc3QgKGQgKyAxKSAoc3JjMnIgLSBpMilcbiAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgIHNldCBkc3QgZCBzMjtcbiAgICAgICAgbGV0IGkyID0gaTIgKyAxIGluXG4gICAgICAgIGlmIGkyIDwgc3JjMnIgdGhlblxuICAgICAgICAgIGxvb3AgaTEgczEgaTIgKGdldCBzcmMyIGkyKSAoZCArIDEpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBibGl0IGEgaTEgZHN0IChkICsgMSkgKHNyYzFyIC0gaTEpXG4gICAgICBlbmRcbiAgICBpbiBsb29wIHNyYzFvZnMgKGdldCBhIHNyYzFvZnMpIHNyYzJvZnMgKGdldCBzcmMyIHNyYzJvZnMpIGRzdG9mcztcbiAgaW5cbiAgbGV0IGlzb3J0dG8gc3Jjb2ZzIGRzdCBkc3RvZnMgbGVuID1cbiAgICBmb3IgaSA9IDAgdG8gbGVuIC0gMSBkb1xuICAgICAgbGV0IGUgPSAoZ2V0IGEgKHNyY29mcyArIGkpKSBpblxuICAgICAgbGV0IGogPSByZWYgKGRzdG9mcyArIGkgLSAxKSBpblxuICAgICAgd2hpbGUgKCFqID49IGRzdG9mcyAmJiBjbXAgKGdldCBkc3QgIWopIGUgPiAwKSBkb1xuICAgICAgICBzZXQgZHN0ICghaiArIDEpIChnZXQgZHN0ICFqKTtcbiAgICAgICAgZGVjciBqO1xuICAgICAgZG9uZTtcbiAgICAgIHNldCBkc3QgKCFqICsgMSkgZTtcbiAgICBkb25lO1xuICBpblxuICBsZXQgcmVjIHNvcnR0byBzcmNvZnMgZHN0IGRzdG9mcyBsZW4gPVxuICAgIGlmIGxlbiA8PSBjdXRvZmYgdGhlbiBpc29ydHRvIHNyY29mcyBkc3QgZHN0b2ZzIGxlbiBlbHNlIGJlZ2luXG4gICAgICBsZXQgbDEgPSBsZW4gLyAyIGluXG4gICAgICBsZXQgbDIgPSBsZW4gLSBsMSBpblxuICAgICAgc29ydHRvIChzcmNvZnMgKyBsMSkgZHN0IChkc3RvZnMgKyBsMSkgbDI7XG4gICAgICBzb3J0dG8gc3Jjb2ZzIGEgKHNyY29mcyArIGwyKSBsMTtcbiAgICAgIG1lcmdlIChzcmNvZnMgKyBsMikgbDEgZHN0IChkc3RvZnMgKyBsMSkgbDIgZHN0IGRzdG9mcztcbiAgICBlbmQ7XG4gIGluXG4gIGxldCBsID0gbGVuZ3RoIGEgaW5cbiAgaWYgbCA8PSBjdXRvZmYgdGhlbiBpc29ydHRvIDAgYSAwIGwgZWxzZSBiZWdpblxuICAgIGxldCBsMSA9IGwgLyAyIGluXG4gICAgbGV0IGwyID0gbCAtIGwxIGluXG4gICAgbGV0IHQgPSBtYWtlIGwyIChnZXQgYSAwKSBpblxuICAgIHNvcnR0byBsMSB0IDAgbDI7XG4gICAgc29ydHRvIDAgYSBsMiBsMTtcbiAgICBtZXJnZSBsMiBsMSB0IDAgbDIgYSAwO1xuICBlbmRcblxuXG5sZXQgZmFzdF9zb3J0ID0gc3RhYmxlX3NvcnRcblxuKCoqIHsxIEl0ZXJhdG9yc30gKilcblxubGV0IHRvX3NlcSBhID1cbiAgbGV0IHJlYyBhdXggaSAoKSA9XG4gICAgaWYgaSA8IGxlbmd0aCBhXG4gICAgdGhlblxuICAgICAgbGV0IHggPSB1bnNhZmVfZ2V0IGEgaSBpblxuICAgICAgU2VxLkNvbnMgKHgsIGF1eCAoaSsxKSlcbiAgICBlbHNlIFNlcS5OaWxcbiAgaW5cbiAgYXV4IDBcblxubGV0IHRvX3NlcWkgYSA9XG4gIGxldCByZWMgYXV4IGkgKCkgPVxuICAgIGlmIGkgPCBsZW5ndGggYVxuICAgIHRoZW5cbiAgICAgIGxldCB4ID0gdW5zYWZlX2dldCBhIGkgaW5cbiAgICAgIFNlcS5Db25zICgoaSx4KSwgYXV4IChpKzEpKVxuICAgIGVsc2UgU2VxLk5pbFxuICBpblxuICBhdXggMFxuXG5sZXQgb2ZfcmV2X2xpc3QgPSBmdW5jdGlvblxuICAgIFtdIC0+IFt8fF1cbiAgfCBoZDo6dGwgYXMgbCAtPlxuICAgICAgbGV0IGxlbiA9IGxpc3RfbGVuZ3RoIDAgbCBpblxuICAgICAgbGV0IGEgPSBjcmVhdGUgbGVuIGhkIGluXG4gICAgICBsZXQgcmVjIGZpbGwgaSA9IGZ1bmN0aW9uXG4gICAgICAgICAgW10gLT4gYVxuICAgICAgICB8IGhkOjp0bCAtPiB1bnNhZmVfc2V0IGEgaSBoZDsgZmlsbCAoaS0xKSB0bFxuICAgICAgaW5cbiAgICAgIGZpbGwgKGxlbi0yKSB0bFxuXG5sZXQgb2Zfc2VxIGkgPVxuICBsZXQgbCA9IFNlcS5mb2xkX2xlZnQgKGZ1biBhY2MgeCAtPiB4OjphY2MpIFtdIGkgaW5cbiAgb2ZfcmV2X2xpc3QgbFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgVGhlIE9DYW1sIHByb2dyYW1tZXJzICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxOCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlIHQgPSBpbnRcblxubGV0IHplcm8gPSAwXG5sZXQgb25lID0gMVxubGV0IG1pbnVzX29uZSA9IC0xXG5leHRlcm5hbCBuZWcgOiBpbnQgLT4gaW50ID0gXCIlbmVnaW50XCJcbmV4dGVybmFsIGFkZCA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlYWRkaW50XCJcbmV4dGVybmFsIHN1YiA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlc3ViaW50XCJcbmV4dGVybmFsIG11bCA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlbXVsaW50XCJcbmV4dGVybmFsIGRpdiA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlZGl2aW50XCJcbmV4dGVybmFsIHJlbSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlbW9kaW50XCJcbmV4dGVybmFsIHN1Y2MgOiBpbnQgLT4gaW50ID0gXCIlc3VjY2ludFwiXG5leHRlcm5hbCBwcmVkIDogaW50IC0+IGludCA9IFwiJXByZWRpbnRcIlxubGV0IGFicyB4ID0gaWYgeCA+PSAwIHRoZW4geCBlbHNlIC14XG5sZXQgbWF4X2ludCA9ICgtMSkgbHNyIDFcbmxldCBtaW5faW50ID0gbWF4X2ludCArIDFcbmV4dGVybmFsIGxvZ2FuZCA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlYW5kaW50XCJcbmV4dGVybmFsIGxvZ29yIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVvcmludFwiXG5leHRlcm5hbCBsb2d4b3IgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJXhvcmludFwiXG5sZXQgbG9nbm90IHggPSBsb2d4b3IgeCAoLTEpXG5leHRlcm5hbCBzaGlmdF9sZWZ0IDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVsc2xpbnRcIlxuZXh0ZXJuYWwgc2hpZnRfcmlnaHQgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWFzcmludFwiXG5leHRlcm5hbCBzaGlmdF9yaWdodF9sb2dpY2FsIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVsc3JpbnRcIlxubGV0IGVxdWFsIDogaW50IC0+IGludCAtPiBib29sID0gKCA9IClcbmxldCBjb21wYXJlIDogaW50IC0+IGludCAtPiBpbnQgPSBTdGRsaWIuY29tcGFyZVxuZXh0ZXJuYWwgdG9fZmxvYXQgOiBpbnQgLT4gZmxvYXQgPSBcIiVmbG9hdG9maW50XCJcbmV4dGVybmFsIG9mX2Zsb2F0IDogZmxvYXQgLT4gaW50ID0gXCIlaW50b2ZmbG9hdFwiXG5cbigqXG5leHRlcm5hbCBpbnRfb2Zfc3RyaW5nIDogc3RyaW5nIC0+IGludCA9IFwiY2FtbF9pbnRfb2Zfc3RyaW5nXCJcbmxldCBvZl9zdHJpbmcgcyA9IHRyeSBTb21lIChpbnRfb2Zfc3RyaW5nIHMpIHdpdGggRmFpbHVyZSBfIC0+IE5vbmVcbiopXG5cbmV4dGVybmFsIGZvcm1hdF9pbnQgOiBzdHJpbmcgLT4gaW50IC0+IHN0cmluZyA9IFwiY2FtbF9mb3JtYXRfaW50XCJcbmxldCB0b19zdHJpbmcgeCA9IGZvcm1hdF9pbnQgXCIlZFwiIHhcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogTW9kdWxlIFtJbnQzMl06IDMyLWJpdCBpbnRlZ2VycyAqKVxuXG5leHRlcm5hbCBuZWcgOiBpbnQzMiAtPiBpbnQzMiA9IFwiJWludDMyX25lZ1wiXG5leHRlcm5hbCBhZGQgOiBpbnQzMiAtPiBpbnQzMiAtPiBpbnQzMiA9IFwiJWludDMyX2FkZFwiXG5leHRlcm5hbCBzdWIgOiBpbnQzMiAtPiBpbnQzMiAtPiBpbnQzMiA9IFwiJWludDMyX3N1YlwiXG5leHRlcm5hbCBtdWwgOiBpbnQzMiAtPiBpbnQzMiAtPiBpbnQzMiA9IFwiJWludDMyX211bFwiXG5leHRlcm5hbCBkaXYgOiBpbnQzMiAtPiBpbnQzMiAtPiBpbnQzMiA9IFwiJWludDMyX2RpdlwiXG5leHRlcm5hbCByZW0gOiBpbnQzMiAtPiBpbnQzMiAtPiBpbnQzMiA9IFwiJWludDMyX21vZFwiXG5leHRlcm5hbCBsb2dhbmQgOiBpbnQzMiAtPiBpbnQzMiAtPiBpbnQzMiA9IFwiJWludDMyX2FuZFwiXG5leHRlcm5hbCBsb2dvciA6IGludDMyIC0+IGludDMyIC0+IGludDMyID0gXCIlaW50MzJfb3JcIlxuZXh0ZXJuYWwgbG9neG9yIDogaW50MzIgLT4gaW50MzIgLT4gaW50MzIgPSBcIiVpbnQzMl94b3JcIlxuZXh0ZXJuYWwgc2hpZnRfbGVmdCA6IGludDMyIC0+IGludCAtPiBpbnQzMiA9IFwiJWludDMyX2xzbFwiXG5leHRlcm5hbCBzaGlmdF9yaWdodCA6IGludDMyIC0+IGludCAtPiBpbnQzMiA9IFwiJWludDMyX2FzclwiXG5leHRlcm5hbCBzaGlmdF9yaWdodF9sb2dpY2FsIDogaW50MzIgLT4gaW50IC0+IGludDMyID0gXCIlaW50MzJfbHNyXCJcbmV4dGVybmFsIG9mX2ludCA6IGludCAtPiBpbnQzMiA9IFwiJWludDMyX29mX2ludFwiXG5leHRlcm5hbCB0b19pbnQgOiBpbnQzMiAtPiBpbnQgPSBcIiVpbnQzMl90b19pbnRcIlxuZXh0ZXJuYWwgb2ZfZmxvYXQgOiBmbG9hdCAtPiBpbnQzMlxuICA9IFwiY2FtbF9pbnQzMl9vZl9mbG9hdFwiIFwiY2FtbF9pbnQzMl9vZl9mbG9hdF91bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHRvX2Zsb2F0IDogaW50MzIgLT4gZmxvYXRcbiAgPSBcImNhbWxfaW50MzJfdG9fZmxvYXRcIiBcImNhbWxfaW50MzJfdG9fZmxvYXRfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBiaXRzX29mX2Zsb2F0IDogZmxvYXQgLT4gaW50MzJcbiAgPSBcImNhbWxfaW50MzJfYml0c19vZl9mbG9hdFwiIFwiY2FtbF9pbnQzMl9iaXRzX29mX2Zsb2F0X3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZmxvYXRfb2ZfYml0cyA6IGludDMyIC0+IGZsb2F0XG4gID0gXCJjYW1sX2ludDMyX2Zsb2F0X29mX2JpdHNcIiBcImNhbWxfaW50MzJfZmxvYXRfb2ZfYml0c191bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cblxubGV0IHplcm8gPSAwbFxubGV0IG9uZSA9IDFsXG5sZXQgbWludXNfb25lID0gLTFsXG5sZXQgc3VjYyBuID0gYWRkIG4gMWxcbmxldCBwcmVkIG4gPSBzdWIgbiAxbFxubGV0IGFicyBuID0gaWYgbiA+PSAwbCB0aGVuIG4gZWxzZSBuZWcgblxubGV0IG1pbl9pbnQgPSAweDgwMDAwMDAwbFxubGV0IG1heF9pbnQgPSAweDdGRkZGRkZGbFxubGV0IGxvZ25vdCBuID0gbG9neG9yIG4gKC0xbClcblxubGV0IHVuc2lnbmVkX3RvX2ludCA9XG4gIG1hdGNoIFN5cy53b3JkX3NpemUgd2l0aFxuICB8IDMyIC0+XG4gICAgICBsZXQgbWF4X2ludCA9IG9mX2ludCBTdGRsaWIubWF4X2ludCBpblxuICAgICAgZnVuIG4gLT5cbiAgICAgICAgaWYgY29tcGFyZSB6ZXJvIG4gPD0gMCAmJiBjb21wYXJlIG4gbWF4X2ludCA8PSAwIHRoZW5cbiAgICAgICAgICBTb21lICh0b19pbnQgbilcbiAgICAgICAgZWxzZVxuICAgICAgICAgIE5vbmVcbiAgfCA2NCAtPlxuICAgICAgKCogU28gdGhhdCBpdCBjb21waWxlcyBpbiAzMi1iaXQgKilcbiAgICAgIGxldCBtb3ZlID0gaW50X29mX3N0cmluZyBcIjB4MV8wMDAwXzAwMDBcIiBpblxuICAgICAgZnVuIG4gLT4gbGV0IGkgPSB0b19pbnQgbiBpbiBTb21lIChpZiBpIDwgMCB0aGVuIGkgKyBtb3ZlIGVsc2UgaSlcbiAgfCBfIC0+XG4gICAgICBhc3NlcnQgZmFsc2VcblxuZXh0ZXJuYWwgZm9ybWF0IDogc3RyaW5nIC0+IGludDMyIC0+IHN0cmluZyA9IFwiY2FtbF9pbnQzMl9mb3JtYXRcIlxubGV0IHRvX3N0cmluZyBuID0gZm9ybWF0IFwiJWRcIiBuXG5cbmV4dGVybmFsIG9mX3N0cmluZyA6IHN0cmluZyAtPiBpbnQzMiA9IFwiY2FtbF9pbnQzMl9vZl9zdHJpbmdcIlxuXG5sZXQgb2Zfc3RyaW5nX29wdCBzID1cbiAgKCogVE9ETzogZXhwb3NlIGEgbm9uLXJhaXNpbmcgcHJpbWl0aXZlIGRpcmVjdGx5LiAqKVxuICB0cnkgU29tZSAob2Zfc3RyaW5nIHMpXG4gIHdpdGggRmFpbHVyZSBfIC0+IE5vbmVcblxudHlwZSB0ID0gaW50MzJcblxubGV0IGNvbXBhcmUgKHg6IHQpICh5OiB0KSA9IFN0ZGxpYi5jb21wYXJlIHggeVxubGV0IGVxdWFsICh4OiB0KSAoeTogdCkgPSBjb21wYXJlIHggeSA9IDBcblxubGV0IHVuc2lnbmVkX2NvbXBhcmUgbiBtID1cbiAgY29tcGFyZSAoc3ViIG4gbWluX2ludCkgKHN1YiBtIG1pbl9pbnQpXG5cbigqIFVuc2lnbmVkIGRpdmlzaW9uIGZyb20gc2lnbmVkIGRpdmlzaW9uIG9mIHRoZSBzYW1lXG4gICBiaXRuZXNzLiBTZWUgV2FycmVuIEpyLiwgSGVucnkgUy4gKDIwMTMpLiBIYWNrZXIncyBEZWxpZ2h0ICgyIGVkLiksIFNlYyA5LTMuXG4qKVxubGV0IHVuc2lnbmVkX2RpdiBuIGQgPVxuICBpZiBkIDwgemVybyB0aGVuXG4gICAgaWYgdW5zaWduZWRfY29tcGFyZSBuIGQgPCAwIHRoZW4gemVybyBlbHNlIG9uZVxuICBlbHNlXG4gICAgbGV0IHEgPSBzaGlmdF9sZWZ0IChkaXYgKHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgbiAxKSBkKSAxIGluXG4gICAgbGV0IHIgPSBzdWIgbiAobXVsIHEgZCkgaW5cbiAgICBpZiB1bnNpZ25lZF9jb21wYXJlIHIgZCA+PSAwIHRoZW4gc3VjYyBxIGVsc2UgcVxuXG5sZXQgdW5zaWduZWRfcmVtIG4gZCA9XG4gIHN1YiBuIChtdWwgKHVuc2lnbmVkX2RpdiBuIGQpIGQpXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIFRoZSBwYXJzaW5nIGVuZ2luZSAqKVxuXG5vcGVuIExleGluZ1xuXG4oKiBJbnRlcm5hbCBpbnRlcmZhY2UgdG8gdGhlIHBhcnNpbmcgZW5naW5lICopXG5cbnR5cGUgcGFyc2VyX2VudiA9XG4gIHsgbXV0YWJsZSBzX3N0YWNrIDogaW50IGFycmF5OyAgICAgICAgKCogU3RhdGVzICopXG4gICAgbXV0YWJsZSB2X3N0YWNrIDogT2JqLnQgYXJyYXk7ICAgICAgKCogU2VtYW50aWMgYXR0cmlidXRlcyAqKVxuICAgIG11dGFibGUgc3ltYl9zdGFydF9zdGFjayA6IHBvc2l0aW9uIGFycmF5OyAoKiBTdGFydCBwb3NpdGlvbnMgKilcbiAgICBtdXRhYmxlIHN5bWJfZW5kX3N0YWNrIDogcG9zaXRpb24gYXJyYXk7ICAgKCogRW5kIHBvc2l0aW9ucyAqKVxuICAgIG11dGFibGUgc3RhY2tzaXplIDogaW50OyAgICAgICAgICAgICgqIFNpemUgb2YgdGhlIHN0YWNrcyAqKVxuICAgIG11dGFibGUgc3RhY2tiYXNlIDogaW50OyAgICAgICAgICAgICgqIEJhc2Ugc3AgZm9yIGN1cnJlbnQgcGFyc2UgKilcbiAgICBtdXRhYmxlIGN1cnJfY2hhciA6IGludDsgICAgICAgICAgICAoKiBMYXN0IHRva2VuIHJlYWQgKilcbiAgICBtdXRhYmxlIGx2YWwgOiBPYmoudDsgICAgICAgICAgICAgICAoKiBJdHMgc2VtYW50aWMgYXR0cmlidXRlICopXG4gICAgbXV0YWJsZSBzeW1iX3N0YXJ0IDogcG9zaXRpb247ICAgICAgKCogU3RhcnQgcG9zLiBvZiB0aGUgY3VycmVudCBzeW1ib2wqKVxuICAgIG11dGFibGUgc3ltYl9lbmQgOiBwb3NpdGlvbjsgICAgICAgICgqIEVuZCBwb3MuIG9mIHRoZSBjdXJyZW50IHN5bWJvbCAqKVxuICAgIG11dGFibGUgYXNwIDogaW50OyAgICAgICAgICAgICAgICAgICgqIFRoZSBzdGFjayBwb2ludGVyIGZvciBhdHRyaWJ1dGVzICopXG4gICAgbXV0YWJsZSBydWxlX2xlbiA6IGludDsgICAgICAgICAgICAgKCogTnVtYmVyIG9mIHJocyBpdGVtcyBpbiB0aGUgcnVsZSAqKVxuICAgIG11dGFibGUgcnVsZV9udW1iZXIgOiBpbnQ7ICAgICAgICAgICgqIFJ1bGUgbnVtYmVyIHRvIHJlZHVjZSBieSAqKVxuICAgIG11dGFibGUgc3AgOiBpbnQ7ICAgICAgICAgICAgICAgICAgICgqIFNhdmVkIHNwIGZvciBwYXJzZV9lbmdpbmUgKilcbiAgICBtdXRhYmxlIHN0YXRlIDogaW50OyAgICAgICAgICAgICAgICAoKiBTYXZlZCBzdGF0ZSBmb3IgcGFyc2VfZW5naW5lICopXG4gICAgbXV0YWJsZSBlcnJmbGFnIDogaW50IH0gICAgICAgICAgICAgKCogU2F2ZWQgZXJyb3IgZmxhZyBmb3IgcGFyc2VfZW5naW5lICopXG5cbnR5cGUgcGFyc2VfdGFibGVzID1cbiAgeyBhY3Rpb25zIDogKHBhcnNlcl9lbnYgLT4gT2JqLnQpIGFycmF5O1xuICAgIHRyYW5zbF9jb25zdCA6IGludCBhcnJheTtcbiAgICB0cmFuc2xfYmxvY2sgOiBpbnQgYXJyYXk7XG4gICAgbGhzIDogc3RyaW5nO1xuICAgIGxlbiA6IHN0cmluZztcbiAgICBkZWZyZWQgOiBzdHJpbmc7XG4gICAgZGdvdG8gOiBzdHJpbmc7XG4gICAgc2luZGV4IDogc3RyaW5nO1xuICAgIHJpbmRleCA6IHN0cmluZztcbiAgICBnaW5kZXggOiBzdHJpbmc7XG4gICAgdGFibGVzaXplIDogaW50O1xuICAgIHRhYmxlIDogc3RyaW5nO1xuICAgIGNoZWNrIDogc3RyaW5nO1xuICAgIGVycm9yX2Z1bmN0aW9uIDogc3RyaW5nIC0+IHVuaXQ7XG4gICAgbmFtZXNfY29uc3QgOiBzdHJpbmc7XG4gICAgbmFtZXNfYmxvY2sgOiBzdHJpbmcgfVxuXG5leGNlcHRpb24gWVlleGl0IG9mIE9iai50XG5leGNlcHRpb24gUGFyc2VfZXJyb3JcblxudHlwZSBwYXJzZXJfaW5wdXQgPVxuICAgIFN0YXJ0XG4gIHwgVG9rZW5fcmVhZFxuICB8IFN0YWNrc19ncm93bl8xXG4gIHwgU3RhY2tzX2dyb3duXzJcbiAgfCBTZW1hbnRpY19hY3Rpb25fY29tcHV0ZWRcbiAgfCBFcnJvcl9kZXRlY3RlZFxuXG50eXBlIHBhcnNlcl9vdXRwdXQgPVxuICAgIFJlYWRfdG9rZW5cbiAgfCBSYWlzZV9wYXJzZV9lcnJvclxuICB8IEdyb3dfc3RhY2tzXzFcbiAgfCBHcm93X3N0YWNrc18yXG4gIHwgQ29tcHV0ZV9zZW1hbnRpY19hY3Rpb25cbiAgfCBDYWxsX2Vycm9yX2Z1bmN0aW9uXG5cbigqIHRvIGF2b2lkIHdhcm5pbmdzICopXG5sZXQgXyA9IFtSZWFkX3Rva2VuOyBSYWlzZV9wYXJzZV9lcnJvcjsgR3Jvd19zdGFja3NfMTsgR3Jvd19zdGFja3NfMjtcbiAgICAgICAgIENvbXB1dGVfc2VtYW50aWNfYWN0aW9uOyBDYWxsX2Vycm9yX2Z1bmN0aW9uXVxuXG5leHRlcm5hbCBwYXJzZV9lbmdpbmUgOlxuICAgIHBhcnNlX3RhYmxlcyAtPiBwYXJzZXJfZW52IC0+IHBhcnNlcl9pbnB1dCAtPiBPYmoudCAtPiBwYXJzZXJfb3V0cHV0XG4gICAgPSBcImNhbWxfcGFyc2VfZW5naW5lXCJcblxuZXh0ZXJuYWwgc2V0X3RyYWNlOiBib29sIC0+IGJvb2xcbiAgICA9IFwiY2FtbF9zZXRfcGFyc2VyX3RyYWNlXCJcblxubGV0IGVudiA9XG4gIHsgc19zdGFjayA9IEFycmF5Lm1ha2UgMTAwIDA7XG4gICAgdl9zdGFjayA9IEFycmF5Lm1ha2UgMTAwIChPYmoucmVwciAoKSk7XG4gICAgc3ltYl9zdGFydF9zdGFjayA9IEFycmF5Lm1ha2UgMTAwIGR1bW15X3BvcztcbiAgICBzeW1iX2VuZF9zdGFjayA9IEFycmF5Lm1ha2UgMTAwIGR1bW15X3BvcztcbiAgICBzdGFja3NpemUgPSAxMDA7XG4gICAgc3RhY2tiYXNlID0gMDtcbiAgICBjdXJyX2NoYXIgPSAwO1xuICAgIGx2YWwgPSBPYmoucmVwciAoKTtcbiAgICBzeW1iX3N0YXJ0ID0gZHVtbXlfcG9zO1xuICAgIHN5bWJfZW5kID0gZHVtbXlfcG9zO1xuICAgIGFzcCA9IDA7XG4gICAgcnVsZV9sZW4gPSAwO1xuICAgIHJ1bGVfbnVtYmVyID0gMDtcbiAgICBzcCA9IDA7XG4gICAgc3RhdGUgPSAwO1xuICAgIGVycmZsYWcgPSAwIH1cblxubGV0IGdyb3dfc3RhY2tzKCkgPVxuICBsZXQgb2xkc2l6ZSA9IGVudi5zdGFja3NpemUgaW5cbiAgbGV0IG5ld3NpemUgPSBvbGRzaXplICogMiBpblxuICBsZXQgbmV3X3MgPSBBcnJheS5tYWtlIG5ld3NpemUgMFxuICBhbmQgbmV3X3YgPSBBcnJheS5tYWtlIG5ld3NpemUgKE9iai5yZXByICgpKVxuICBhbmQgbmV3X3N0YXJ0ID0gQXJyYXkubWFrZSBuZXdzaXplIGR1bW15X3Bvc1xuICBhbmQgbmV3X2VuZCA9IEFycmF5Lm1ha2UgbmV3c2l6ZSBkdW1teV9wb3MgaW5cbiAgICBBcnJheS5ibGl0IGVudi5zX3N0YWNrIDAgbmV3X3MgMCBvbGRzaXplO1xuICAgIGVudi5zX3N0YWNrIDwtIG5ld19zO1xuICAgIEFycmF5LmJsaXQgZW52LnZfc3RhY2sgMCBuZXdfdiAwIG9sZHNpemU7XG4gICAgZW52LnZfc3RhY2sgPC0gbmV3X3Y7XG4gICAgQXJyYXkuYmxpdCBlbnYuc3ltYl9zdGFydF9zdGFjayAwIG5ld19zdGFydCAwIG9sZHNpemU7XG4gICAgZW52LnN5bWJfc3RhcnRfc3RhY2sgPC0gbmV3X3N0YXJ0O1xuICAgIEFycmF5LmJsaXQgZW52LnN5bWJfZW5kX3N0YWNrIDAgbmV3X2VuZCAwIG9sZHNpemU7XG4gICAgZW52LnN5bWJfZW5kX3N0YWNrIDwtIG5ld19lbmQ7XG4gICAgZW52LnN0YWNrc2l6ZSA8LSBuZXdzaXplXG5cbmxldCBjbGVhcl9wYXJzZXIoKSA9XG4gIEFycmF5LmZpbGwgZW52LnZfc3RhY2sgMCBlbnYuc3RhY2tzaXplIChPYmoucmVwciAoKSk7XG4gIGVudi5sdmFsIDwtIE9iai5yZXByICgpXG5cbmxldCBjdXJyZW50X2xvb2thaGVhZF9mdW4gPSByZWYgKGZ1biAoXyA6IE9iai50KSAtPiBmYWxzZSlcblxubGV0IHl5cGFyc2UgdGFibGVzIHN0YXJ0IGxleGVyIGxleGJ1ZiA9XG4gIGxldCByZWMgbG9vcCBjbWQgYXJnID1cbiAgICBtYXRjaCBwYXJzZV9lbmdpbmUgdGFibGVzIGVudiBjbWQgYXJnIHdpdGhcbiAgICAgIFJlYWRfdG9rZW4gLT5cbiAgICAgICAgbGV0IHQgPSBPYmoucmVwcihsZXhlciBsZXhidWYpIGluXG4gICAgICAgIGVudi5zeW1iX3N0YXJ0IDwtIGxleGJ1Zi5sZXhfc3RhcnRfcDtcbiAgICAgICAgZW52LnN5bWJfZW5kIDwtIGxleGJ1Zi5sZXhfY3Vycl9wO1xuICAgICAgICBsb29wIFRva2VuX3JlYWQgdFxuICAgIHwgUmFpc2VfcGFyc2VfZXJyb3IgLT5cbiAgICAgICAgcmFpc2UgUGFyc2VfZXJyb3JcbiAgICB8IENvbXB1dGVfc2VtYW50aWNfYWN0aW9uIC0+XG4gICAgICAgIGxldCAoYWN0aW9uLCB2YWx1ZSkgPVxuICAgICAgICAgIHRyeVxuICAgICAgICAgICAgKFNlbWFudGljX2FjdGlvbl9jb21wdXRlZCwgdGFibGVzLmFjdGlvbnMuKGVudi5ydWxlX251bWJlcikgZW52KVxuICAgICAgICAgIHdpdGggUGFyc2VfZXJyb3IgLT5cbiAgICAgICAgICAgIChFcnJvcl9kZXRlY3RlZCwgT2JqLnJlcHIgKCkpIGluXG4gICAgICAgIGxvb3AgYWN0aW9uIHZhbHVlXG4gICAgfCBHcm93X3N0YWNrc18xIC0+XG4gICAgICAgIGdyb3dfc3RhY2tzKCk7IGxvb3AgU3RhY2tzX2dyb3duXzEgKE9iai5yZXByICgpKVxuICAgIHwgR3Jvd19zdGFja3NfMiAtPlxuICAgICAgICBncm93X3N0YWNrcygpOyBsb29wIFN0YWNrc19ncm93bl8yIChPYmoucmVwciAoKSlcbiAgICB8IENhbGxfZXJyb3JfZnVuY3Rpb24gLT5cbiAgICAgICAgdGFibGVzLmVycm9yX2Z1bmN0aW9uIFwic3ludGF4IGVycm9yXCI7XG4gICAgICAgIGxvb3AgRXJyb3JfZGV0ZWN0ZWQgKE9iai5yZXByICgpKSBpblxuICBsZXQgaW5pdF9hc3AgPSBlbnYuYXNwXG4gIGFuZCBpbml0X3NwID0gZW52LnNwXG4gIGFuZCBpbml0X3N0YWNrYmFzZSA9IGVudi5zdGFja2Jhc2VcbiAgYW5kIGluaXRfc3RhdGUgPSBlbnYuc3RhdGVcbiAgYW5kIGluaXRfY3Vycl9jaGFyID0gZW52LmN1cnJfY2hhclxuICBhbmQgaW5pdF9sdmFsID0gZW52Lmx2YWxcbiAgYW5kIGluaXRfZXJyZmxhZyA9IGVudi5lcnJmbGFnIGluXG4gIGVudi5zdGFja2Jhc2UgPC0gZW52LnNwICsgMTtcbiAgZW52LmN1cnJfY2hhciA8LSBzdGFydDtcbiAgZW52LnN5bWJfZW5kIDwtIGxleGJ1Zi5sZXhfY3Vycl9wO1xuICB0cnlcbiAgICBsb29wIFN0YXJ0IChPYmoucmVwciAoKSlcbiAgd2l0aCBleG4gLT5cbiAgICBsZXQgY3Vycl9jaGFyID0gZW52LmN1cnJfY2hhciBpblxuICAgIGVudi5hc3AgPC0gaW5pdF9hc3A7XG4gICAgZW52LnNwIDwtIGluaXRfc3A7XG4gICAgZW52LnN0YWNrYmFzZSA8LSBpbml0X3N0YWNrYmFzZTtcbiAgICBlbnYuc3RhdGUgPC0gaW5pdF9zdGF0ZTtcbiAgICBlbnYuY3Vycl9jaGFyIDwtIGluaXRfY3Vycl9jaGFyO1xuICAgIGVudi5sdmFsIDwtIGluaXRfbHZhbDtcbiAgICBlbnYuZXJyZmxhZyA8LSBpbml0X2VycmZsYWc7XG4gICAgbWF0Y2ggZXhuIHdpdGhcbiAgICAgIFlZZXhpdCB2IC0+XG4gICAgICAgIE9iai5tYWdpYyB2XG4gICAgfCBfIC0+XG4gICAgICAgIGN1cnJlbnRfbG9va2FoZWFkX2Z1biA6PVxuICAgICAgICAgIChmdW4gdG9rIC0+XG4gICAgICAgICAgICBpZiBPYmouaXNfYmxvY2sgdG9rXG4gICAgICAgICAgICB0aGVuIHRhYmxlcy50cmFuc2xfYmxvY2suKE9iai50YWcgdG9rKSA9IGN1cnJfY2hhclxuICAgICAgICAgICAgZWxzZSB0YWJsZXMudHJhbnNsX2NvbnN0LihPYmoubWFnaWMgdG9rKSA9IGN1cnJfY2hhcik7XG4gICAgICAgIHJhaXNlIGV4blxuXG5sZXQgcGVla192YWwgZW52IG4gPVxuICBPYmoubWFnaWMgZW52LnZfc3RhY2suKGVudi5hc3AgLSBuKVxuXG5sZXQgc3ltYm9sX3N0YXJ0X3BvcyAoKSA9XG4gIGxldCByZWMgbG9vcCBpID1cbiAgICBpZiBpIDw9IDAgdGhlbiBlbnYuc3ltYl9lbmRfc3RhY2suKGVudi5hc3ApXG4gICAgZWxzZSBiZWdpblxuICAgICAgbGV0IHN0ID0gZW52LnN5bWJfc3RhcnRfc3RhY2suKGVudi5hc3AgLSBpICsgMSkgaW5cbiAgICAgIGxldCBlbiA9IGVudi5zeW1iX2VuZF9zdGFjay4oZW52LmFzcCAtIGkgKyAxKSBpblxuICAgICAgaWYgc3QgPD4gZW4gdGhlbiBzdCBlbHNlIGxvb3AgKGkgLSAxKVxuICAgIGVuZFxuICBpblxuICBsb29wIGVudi5ydWxlX2xlblxuXG5sZXQgc3ltYm9sX2VuZF9wb3MgKCkgPSBlbnYuc3ltYl9lbmRfc3RhY2suKGVudi5hc3ApXG5sZXQgcmhzX3N0YXJ0X3BvcyBuID0gZW52LnN5bWJfc3RhcnRfc3RhY2suKGVudi5hc3AgLSAoZW52LnJ1bGVfbGVuIC0gbikpXG5sZXQgcmhzX2VuZF9wb3MgbiA9IGVudi5zeW1iX2VuZF9zdGFjay4oZW52LmFzcCAtIChlbnYucnVsZV9sZW4gLSBuKSlcblxubGV0IHN5bWJvbF9zdGFydCAoKSA9IChzeW1ib2xfc3RhcnRfcG9zICgpKS5wb3NfY251bVxubGV0IHN5bWJvbF9lbmQgKCkgPSAoc3ltYm9sX2VuZF9wb3MgKCkpLnBvc19jbnVtXG5sZXQgcmhzX3N0YXJ0IG4gPSAocmhzX3N0YXJ0X3BvcyBuKS5wb3NfY251bVxubGV0IHJoc19lbmQgbiA9IChyaHNfZW5kX3BvcyBuKS5wb3NfY251bVxuXG5sZXQgaXNfY3VycmVudF9sb29rYWhlYWQgdG9rID1cbiAgKCFjdXJyZW50X2xvb2thaGVhZF9mdW4pKE9iai5yZXByIHRvaylcblxubGV0IHBhcnNlX2Vycm9yIChfIDogc3RyaW5nKSA9ICgpXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIFNldHMgb3ZlciBvcmRlcmVkIHR5cGVzICopXG5cbm1vZHVsZSB0eXBlIE9yZGVyZWRUeXBlID1cbiAgc2lnXG4gICAgdHlwZSB0XG4gICAgdmFsIGNvbXBhcmU6IHQgLT4gdCAtPiBpbnRcbiAgZW5kXG5cbm1vZHVsZSB0eXBlIFMgPVxuICBzaWdcbiAgICB0eXBlIGVsdFxuICAgIHR5cGUgdFxuICAgIHZhbCBlbXB0eTogdFxuICAgIHZhbCBpc19lbXB0eTogdCAtPiBib29sXG4gICAgdmFsIG1lbTogZWx0IC0+IHQgLT4gYm9vbFxuICAgIHZhbCBhZGQ6IGVsdCAtPiB0IC0+IHRcbiAgICB2YWwgc2luZ2xldG9uOiBlbHQgLT4gdFxuICAgIHZhbCByZW1vdmU6IGVsdCAtPiB0IC0+IHRcbiAgICB2YWwgdW5pb246IHQgLT4gdCAtPiB0XG4gICAgdmFsIGludGVyOiB0IC0+IHQgLT4gdFxuICAgIHZhbCBkaXNqb2ludDogdCAtPiB0IC0+IGJvb2xcbiAgICB2YWwgZGlmZjogdCAtPiB0IC0+IHRcbiAgICB2YWwgY29tcGFyZTogdCAtPiB0IC0+IGludFxuICAgIHZhbCBlcXVhbDogdCAtPiB0IC0+IGJvb2xcbiAgICB2YWwgc3Vic2V0OiB0IC0+IHQgLT4gYm9vbFxuICAgIHZhbCBpdGVyOiAoZWx0IC0+IHVuaXQpIC0+IHQgLT4gdW5pdFxuICAgIHZhbCBtYXA6IChlbHQgLT4gZWx0KSAtPiB0IC0+IHRcbiAgICB2YWwgZm9sZDogKGVsdCAtPiAnYSAtPiAnYSkgLT4gdCAtPiAnYSAtPiAnYVxuICAgIHZhbCBmb3JfYWxsOiAoZWx0IC0+IGJvb2wpIC0+IHQgLT4gYm9vbFxuICAgIHZhbCBleGlzdHM6IChlbHQgLT4gYm9vbCkgLT4gdCAtPiBib29sXG4gICAgdmFsIGZpbHRlcjogKGVsdCAtPiBib29sKSAtPiB0IC0+IHRcbiAgICB2YWwgZmlsdGVyX21hcDogKGVsdCAtPiBlbHQgb3B0aW9uKSAtPiB0IC0+IHRcbiAgICB2YWwgcGFydGl0aW9uOiAoZWx0IC0+IGJvb2wpIC0+IHQgLT4gdCAqIHRcbiAgICB2YWwgY2FyZGluYWw6IHQgLT4gaW50XG4gICAgdmFsIGVsZW1lbnRzOiB0IC0+IGVsdCBsaXN0XG4gICAgdmFsIG1pbl9lbHQ6IHQgLT4gZWx0XG4gICAgdmFsIG1pbl9lbHRfb3B0OiB0IC0+IGVsdCBvcHRpb25cbiAgICB2YWwgbWF4X2VsdDogdCAtPiBlbHRcbiAgICB2YWwgbWF4X2VsdF9vcHQ6IHQgLT4gZWx0IG9wdGlvblxuICAgIHZhbCBjaG9vc2U6IHQgLT4gZWx0XG4gICAgdmFsIGNob29zZV9vcHQ6IHQgLT4gZWx0IG9wdGlvblxuICAgIHZhbCBzcGxpdDogZWx0IC0+IHQgLT4gdCAqIGJvb2wgKiB0XG4gICAgdmFsIGZpbmQ6IGVsdCAtPiB0IC0+IGVsdFxuICAgIHZhbCBmaW5kX29wdDogZWx0IC0+IHQgLT4gZWx0IG9wdGlvblxuICAgIHZhbCBmaW5kX2ZpcnN0OiAoZWx0IC0+IGJvb2wpIC0+IHQgLT4gZWx0XG4gICAgdmFsIGZpbmRfZmlyc3Rfb3B0OiAoZWx0IC0+IGJvb2wpIC0+IHQgLT4gZWx0IG9wdGlvblxuICAgIHZhbCBmaW5kX2xhc3Q6IChlbHQgLT4gYm9vbCkgLT4gdCAtPiBlbHRcbiAgICB2YWwgZmluZF9sYXN0X29wdDogKGVsdCAtPiBib29sKSAtPiB0IC0+IGVsdCBvcHRpb25cbiAgICB2YWwgb2ZfbGlzdDogZWx0IGxpc3QgLT4gdFxuICAgIHZhbCB0b19zZXFfZnJvbSA6IGVsdCAtPiB0IC0+IGVsdCBTZXEudFxuICAgIHZhbCB0b19zZXEgOiB0IC0+IGVsdCBTZXEudFxuICAgIHZhbCB0b19yZXZfc2VxIDogdCAtPiBlbHQgU2VxLnRcbiAgICB2YWwgYWRkX3NlcSA6IGVsdCBTZXEudCAtPiB0IC0+IHRcbiAgICB2YWwgb2Zfc2VxIDogZWx0IFNlcS50IC0+IHRcbiAgZW5kXG5cbm1vZHVsZSBNYWtlKE9yZDogT3JkZXJlZFR5cGUpID1cbiAgc3RydWN0XG4gICAgdHlwZSBlbHQgPSBPcmQudFxuICAgIHR5cGUgdCA9IEVtcHR5IHwgTm9kZSBvZiB7bDp0OyB2OmVsdDsgcjp0OyBoOmludH1cblxuICAgICgqIFNldHMgYXJlIHJlcHJlc2VudGVkIGJ5IGJhbGFuY2VkIGJpbmFyeSB0cmVlcyAodGhlIGhlaWdodHMgb2YgdGhlXG4gICAgICAgY2hpbGRyZW4gZGlmZmVyIGJ5IGF0IG1vc3QgMiAqKVxuXG4gICAgbGV0IGhlaWdodCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IDBcbiAgICAgIHwgTm9kZSB7aH0gLT4gaFxuXG4gICAgKCogQ3JlYXRlcyBhIG5ldyBub2RlIHdpdGggbGVmdCBzb24gbCwgdmFsdWUgdiBhbmQgcmlnaHQgc29uIHIuXG4gICAgICAgV2UgbXVzdCBoYXZlIGFsbCBlbGVtZW50cyBvZiBsIDwgdiA8IGFsbCBlbGVtZW50cyBvZiByLlxuICAgICAgIGwgYW5kIHIgbXVzdCBiZSBiYWxhbmNlZCBhbmQgfCBoZWlnaHQgbCAtIGhlaWdodCByIHwgPD0gMi5cbiAgICAgICBJbmxpbmUgZXhwYW5zaW9uIG9mIGhlaWdodCBmb3IgYmV0dGVyIHNwZWVkLiAqKVxuXG4gICAgbGV0IGNyZWF0ZSBsIHYgciA9XG4gICAgICBsZXQgaGwgPSBtYXRjaCBsIHdpdGggRW1wdHkgLT4gMCB8IE5vZGUge2h9IC0+IGggaW5cbiAgICAgIGxldCBociA9IG1hdGNoIHIgd2l0aCBFbXB0eSAtPiAwIHwgTm9kZSB7aH0gLT4gaCBpblxuICAgICAgTm9kZXtsOyB2OyByOyBoPShpZiBobCA+PSBociB0aGVuIGhsICsgMSBlbHNlIGhyICsgMSl9XG5cbiAgICAoKiBTYW1lIGFzIGNyZWF0ZSwgYnV0IHBlcmZvcm1zIG9uZSBzdGVwIG9mIHJlYmFsYW5jaW5nIGlmIG5lY2Vzc2FyeS5cbiAgICAgICBBc3N1bWVzIGwgYW5kIHIgYmFsYW5jZWQgYW5kIHwgaGVpZ2h0IGwgLSBoZWlnaHQgciB8IDw9IDMuXG4gICAgICAgSW5saW5lIGV4cGFuc2lvbiBvZiBjcmVhdGUgZm9yIGJldHRlciBzcGVlZCBpbiB0aGUgbW9zdCBmcmVxdWVudCBjYXNlXG4gICAgICAgd2hlcmUgbm8gcmViYWxhbmNpbmcgaXMgcmVxdWlyZWQuICopXG5cbiAgICBsZXQgYmFsIGwgdiByID1cbiAgICAgIGxldCBobCA9IG1hdGNoIGwgd2l0aCBFbXB0eSAtPiAwIHwgTm9kZSB7aH0gLT4gaCBpblxuICAgICAgbGV0IGhyID0gbWF0Y2ggciB3aXRoIEVtcHR5IC0+IDAgfCBOb2RlIHtofSAtPiBoIGluXG4gICAgICBpZiBobCA+IGhyICsgMiB0aGVuIGJlZ2luXG4gICAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgICAgIEVtcHR5IC0+IGludmFsaWRfYXJnIFwiU2V0LmJhbFwiXG4gICAgICAgIHwgTm9kZXtsPWxsOyB2PWx2OyByPWxyfSAtPlxuICAgICAgICAgICAgaWYgaGVpZ2h0IGxsID49IGhlaWdodCBsciB0aGVuXG4gICAgICAgICAgICAgIGNyZWF0ZSBsbCBsdiAoY3JlYXRlIGxyIHYgcilcbiAgICAgICAgICAgIGVsc2UgYmVnaW5cbiAgICAgICAgICAgICAgbWF0Y2ggbHIgd2l0aFxuICAgICAgICAgICAgICAgIEVtcHR5IC0+IGludmFsaWRfYXJnIFwiU2V0LmJhbFwiXG4gICAgICAgICAgICAgIHwgTm9kZXtsPWxybDsgdj1scnY7IHI9bHJyfS0+XG4gICAgICAgICAgICAgICAgICBjcmVhdGUgKGNyZWF0ZSBsbCBsdiBscmwpIGxydiAoY3JlYXRlIGxyciB2IHIpXG4gICAgICAgICAgICBlbmRcbiAgICAgIGVuZCBlbHNlIGlmIGhyID4gaGwgKyAyIHRoZW4gYmVnaW5cbiAgICAgICAgbWF0Y2ggciB3aXRoXG4gICAgICAgICAgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJTZXQuYmFsXCJcbiAgICAgICAgfCBOb2Rle2w9cmw7IHY9cnY7IHI9cnJ9IC0+XG4gICAgICAgICAgICBpZiBoZWlnaHQgcnIgPj0gaGVpZ2h0IHJsIHRoZW5cbiAgICAgICAgICAgICAgY3JlYXRlIChjcmVhdGUgbCB2IHJsKSBydiByclxuICAgICAgICAgICAgZWxzZSBiZWdpblxuICAgICAgICAgICAgICBtYXRjaCBybCB3aXRoXG4gICAgICAgICAgICAgICAgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJTZXQuYmFsXCJcbiAgICAgICAgICAgICAgfCBOb2Rle2w9cmxsOyB2PXJsdjsgcj1ybHJ9IC0+XG4gICAgICAgICAgICAgICAgICBjcmVhdGUgKGNyZWF0ZSBsIHYgcmxsKSBybHYgKGNyZWF0ZSBybHIgcnYgcnIpXG4gICAgICAgICAgICBlbmRcbiAgICAgIGVuZCBlbHNlXG4gICAgICAgIE5vZGV7bDsgdjsgcjsgaD0oaWYgaGwgPj0gaHIgdGhlbiBobCArIDEgZWxzZSBociArIDEpfVxuXG4gICAgKCogSW5zZXJ0aW9uIG9mIG9uZSBlbGVtZW50ICopXG5cbiAgICBsZXQgcmVjIGFkZCB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gTm9kZXtsPUVtcHR5OyB2PXg7IHI9RW1wdHk7IGg9MX1cbiAgICAgIHwgTm9kZXtsOyB2OyByfSBhcyB0IC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuIHQgZWxzZVxuICAgICAgICAgIGlmIGMgPCAwIHRoZW5cbiAgICAgICAgICAgIGxldCBsbCA9IGFkZCB4IGwgaW5cbiAgICAgICAgICAgIGlmIGwgPT0gbGwgdGhlbiB0IGVsc2UgYmFsIGxsIHYgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxldCByciA9IGFkZCB4IHIgaW5cbiAgICAgICAgICAgIGlmIHIgPT0gcnIgdGhlbiB0IGVsc2UgYmFsIGwgdiByclxuXG4gICAgbGV0IHNpbmdsZXRvbiB4ID0gTm9kZXtsPUVtcHR5OyB2PXg7IHI9RW1wdHk7IGg9MX1cblxuICAgICgqIEJld2FyZTogdGhvc2UgdHdvIGZ1bmN0aW9ucyBhc3N1bWUgdGhhdCB0aGUgYWRkZWQgdiBpcyAqc3RyaWN0bHkqXG4gICAgICAgc21hbGxlciAob3IgYmlnZ2VyKSB0aGFuIGFsbCB0aGUgcHJlc2VudCBlbGVtZW50cyBpbiB0aGUgdHJlZTsgaXRcbiAgICAgICBkb2VzIG5vdCB0ZXN0IGZvciBlcXVhbGl0eSB3aXRoIHRoZSBjdXJyZW50IG1pbiAob3IgbWF4KSBlbGVtZW50LlxuICAgICAgIEluZGVlZCwgdGhleSBhcmUgb25seSB1c2VkIGR1cmluZyB0aGUgXCJqb2luXCIgb3BlcmF0aW9uIHdoaWNoXG4gICAgICAgcmVzcGVjdHMgdGhpcyBwcmVjb25kaXRpb24uXG4gICAgKilcblxuICAgIGxldCByZWMgYWRkX21pbl9lbGVtZW50IHggPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiBzaW5nbGV0b24geFxuICAgICAgfCBOb2RlIHtsOyB2OyByfSAtPlxuICAgICAgICBiYWwgKGFkZF9taW5fZWxlbWVudCB4IGwpIHYgclxuXG4gICAgbGV0IHJlYyBhZGRfbWF4X2VsZW1lbnQgeCA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+IHNpbmdsZXRvbiB4XG4gICAgICB8IE5vZGUge2w7IHY7IHJ9IC0+XG4gICAgICAgIGJhbCBsIHYgKGFkZF9tYXhfZWxlbWVudCB4IHIpXG5cbiAgICAoKiBTYW1lIGFzIGNyZWF0ZSBhbmQgYmFsLCBidXQgbm8gYXNzdW1wdGlvbnMgYXJlIG1hZGUgb24gdGhlXG4gICAgICAgcmVsYXRpdmUgaGVpZ2h0cyBvZiBsIGFuZCByLiAqKVxuXG4gICAgbGV0IHJlYyBqb2luIGwgdiByID1cbiAgICAgIG1hdGNoIChsLCByKSB3aXRoXG4gICAgICAgIChFbXB0eSwgXykgLT4gYWRkX21pbl9lbGVtZW50IHYgclxuICAgICAgfCAoXywgRW1wdHkpIC0+IGFkZF9tYXhfZWxlbWVudCB2IGxcbiAgICAgIHwgKE5vZGV7bD1sbDsgdj1sdjsgcj1scjsgaD1saH0sIE5vZGV7bD1ybDsgdj1ydjsgcj1ycjsgaD1yaH0pIC0+XG4gICAgICAgICAgaWYgbGggPiByaCArIDIgdGhlbiBiYWwgbGwgbHYgKGpvaW4gbHIgdiByKSBlbHNlXG4gICAgICAgICAgaWYgcmggPiBsaCArIDIgdGhlbiBiYWwgKGpvaW4gbCB2IHJsKSBydiByciBlbHNlXG4gICAgICAgICAgY3JlYXRlIGwgdiByXG5cbiAgICAoKiBTbWFsbGVzdCBhbmQgZ3JlYXRlc3QgZWxlbWVudCBvZiBhIHNldCAqKVxuXG4gICAgbGV0IHJlYyBtaW5fZWx0ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IE5vZGV7bD1FbXB0eTsgdn0gLT4gdlxuICAgICAgfCBOb2Rle2x9IC0+IG1pbl9lbHQgbFxuXG4gICAgbGV0IHJlYyBtaW5fZWx0X29wdCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IE5vbmVcbiAgICAgIHwgTm9kZXtsPUVtcHR5OyB2fSAtPiBTb21lIHZcbiAgICAgIHwgTm9kZXtsfSAtPiBtaW5fZWx0X29wdCBsXG5cbiAgICBsZXQgcmVjIG1heF9lbHQgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgTm9kZXt2OyByPUVtcHR5fSAtPiB2XG4gICAgICB8IE5vZGV7cn0gLT4gbWF4X2VsdCByXG5cbiAgICBsZXQgcmVjIG1heF9lbHRfb3B0ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gTm9uZVxuICAgICAgfCBOb2Rle3Y7IHI9RW1wdHl9IC0+IFNvbWUgdlxuICAgICAgfCBOb2Rle3J9IC0+IG1heF9lbHRfb3B0IHJcblxuICAgICgqIFJlbW92ZSB0aGUgc21hbGxlc3QgZWxlbWVudCBvZiB0aGUgZ2l2ZW4gc2V0ICopXG5cbiAgICBsZXQgcmVjIHJlbW92ZV9taW5fZWx0ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJTZXQucmVtb3ZlX21pbl9lbHRcIlxuICAgICAgfCBOb2Rle2w9RW1wdHk7IHJ9IC0+IHJcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPiBiYWwgKHJlbW92ZV9taW5fZWx0IGwpIHYgclxuXG4gICAgKCogTWVyZ2UgdHdvIHRyZWVzIGwgYW5kIHIgaW50byBvbmUuXG4gICAgICAgQWxsIGVsZW1lbnRzIG9mIGwgbXVzdCBwcmVjZWRlIHRoZSBlbGVtZW50cyBvZiByLlxuICAgICAgIEFzc3VtZSB8IGhlaWdodCBsIC0gaGVpZ2h0IHIgfCA8PSAyLiAqKVxuXG4gICAgbGV0IG1lcmdlIHQxIHQyID1cbiAgICAgIG1hdGNoICh0MSwgdDIpIHdpdGhcbiAgICAgICAgKEVtcHR5LCB0KSAtPiB0XG4gICAgICB8ICh0LCBFbXB0eSkgLT4gdFxuICAgICAgfCAoXywgXykgLT4gYmFsIHQxIChtaW5fZWx0IHQyKSAocmVtb3ZlX21pbl9lbHQgdDIpXG5cbiAgICAoKiBNZXJnZSB0d28gdHJlZXMgbCBhbmQgciBpbnRvIG9uZS5cbiAgICAgICBBbGwgZWxlbWVudHMgb2YgbCBtdXN0IHByZWNlZGUgdGhlIGVsZW1lbnRzIG9mIHIuXG4gICAgICAgTm8gYXNzdW1wdGlvbiBvbiB0aGUgaGVpZ2h0cyBvZiBsIGFuZCByLiAqKVxuXG4gICAgbGV0IGNvbmNhdCB0MSB0MiA9XG4gICAgICBtYXRjaCAodDEsIHQyKSB3aXRoXG4gICAgICAgIChFbXB0eSwgdCkgLT4gdFxuICAgICAgfCAodCwgRW1wdHkpIC0+IHRcbiAgICAgIHwgKF8sIF8pIC0+IGpvaW4gdDEgKG1pbl9lbHQgdDIpIChyZW1vdmVfbWluX2VsdCB0MilcblxuICAgICgqIFNwbGl0dGluZy4gIHNwbGl0IHggcyByZXR1cm5zIGEgdHJpcGxlIChsLCBwcmVzZW50LCByKSB3aGVyZVxuICAgICAgICAtIGwgaXMgdGhlIHNldCBvZiBlbGVtZW50cyBvZiBzIHRoYXQgYXJlIDwgeFxuICAgICAgICAtIHIgaXMgdGhlIHNldCBvZiBlbGVtZW50cyBvZiBzIHRoYXQgYXJlID4geFxuICAgICAgICAtIHByZXNlbnQgaXMgZmFsc2UgaWYgcyBjb250YWlucyBubyBlbGVtZW50IGVxdWFsIHRvIHgsXG4gICAgICAgICAgb3IgdHJ1ZSBpZiBzIGNvbnRhaW5zIGFuIGVsZW1lbnQgZXF1YWwgdG8geC4gKilcblxuICAgIGxldCByZWMgc3BsaXQgeCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgKEVtcHR5LCBmYWxzZSwgRW1wdHkpXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gKGwsIHRydWUsIHIpXG4gICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuXG4gICAgICAgICAgICBsZXQgKGxsLCBwcmVzLCBybCkgPSBzcGxpdCB4IGwgaW4gKGxsLCBwcmVzLCBqb2luIHJsIHYgcilcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsZXQgKGxyLCBwcmVzLCBycikgPSBzcGxpdCB4IHIgaW4gKGpvaW4gbCB2IGxyLCBwcmVzLCBycilcblxuICAgICgqIEltcGxlbWVudGF0aW9uIG9mIHRoZSBzZXQgb3BlcmF0aW9ucyAqKVxuXG4gICAgbGV0IGVtcHR5ID0gRW1wdHlcblxuICAgIGxldCBpc19lbXB0eSA9IGZ1bmN0aW9uIEVtcHR5IC0+IHRydWUgfCBfIC0+IGZhbHNlXG5cbiAgICBsZXQgcmVjIG1lbSB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gZmFsc2VcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgYyA9IDAgfHwgbWVtIHggKGlmIGMgPCAwIHRoZW4gbCBlbHNlIHIpXG5cbiAgICBsZXQgcmVjIHJlbW92ZSB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gRW1wdHlcbiAgICAgIHwgKE5vZGV7bDsgdjsgcn0gYXMgdCkgLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gbWVyZ2UgbCByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgaWYgYyA8IDAgdGhlblxuICAgICAgICAgICAgICBsZXQgbGwgPSByZW1vdmUgeCBsIGluXG4gICAgICAgICAgICAgIGlmIGwgPT0gbGwgdGhlbiB0XG4gICAgICAgICAgICAgIGVsc2UgYmFsIGxsIHYgclxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBsZXQgcnIgPSByZW1vdmUgeCByIGluXG4gICAgICAgICAgICAgIGlmIHIgPT0gcnIgdGhlbiB0XG4gICAgICAgICAgICAgIGVsc2UgYmFsIGwgdiByclxuXG4gICAgbGV0IHJlYyB1bmlvbiBzMSBzMiA9XG4gICAgICBtYXRjaCAoczEsIHMyKSB3aXRoXG4gICAgICAgIChFbXB0eSwgdDIpIC0+IHQyXG4gICAgICB8ICh0MSwgRW1wdHkpIC0+IHQxXG4gICAgICB8IChOb2Rle2w9bDE7IHY9djE7IHI9cjE7IGg9aDF9LCBOb2Rle2w9bDI7IHY9djI7IHI9cjI7IGg9aDJ9KSAtPlxuICAgICAgICAgIGlmIGgxID49IGgyIHRoZW5cbiAgICAgICAgICAgIGlmIGgyID0gMSB0aGVuIGFkZCB2MiBzMSBlbHNlIGJlZ2luXG4gICAgICAgICAgICAgIGxldCAobDIsIF8sIHIyKSA9IHNwbGl0IHYxIHMyIGluXG4gICAgICAgICAgICAgIGpvaW4gKHVuaW9uIGwxIGwyKSB2MSAodW5pb24gcjEgcjIpXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBpZiBoMSA9IDEgdGhlbiBhZGQgdjEgczIgZWxzZSBiZWdpblxuICAgICAgICAgICAgICBsZXQgKGwxLCBfLCByMSkgPSBzcGxpdCB2MiBzMSBpblxuICAgICAgICAgICAgICBqb2luICh1bmlvbiBsMSBsMikgdjIgKHVuaW9uIHIxIHIyKVxuICAgICAgICAgICAgZW5kXG5cbiAgICBsZXQgcmVjIGludGVyIHMxIHMyID1cbiAgICAgIG1hdGNoIChzMSwgczIpIHdpdGhcbiAgICAgICAgKEVtcHR5LCBfKSAtPiBFbXB0eVxuICAgICAgfCAoXywgRW1wdHkpIC0+IEVtcHR5XG4gICAgICB8IChOb2Rle2w9bDE7IHY9djE7IHI9cjF9LCB0MikgLT5cbiAgICAgICAgICBtYXRjaCBzcGxpdCB2MSB0MiB3aXRoXG4gICAgICAgICAgICAobDIsIGZhbHNlLCByMikgLT5cbiAgICAgICAgICAgICAgY29uY2F0IChpbnRlciBsMSBsMikgKGludGVyIHIxIHIyKVxuICAgICAgICAgIHwgKGwyLCB0cnVlLCByMikgLT5cbiAgICAgICAgICAgICAgam9pbiAoaW50ZXIgbDEgbDIpIHYxIChpbnRlciByMSByMilcblxuICAgICgqIFNhbWUgYXMgc3BsaXQsIGJ1dCBjb21wdXRlIHRoZSBsZWZ0IGFuZCByaWdodCBzdWJ0cmVlc1xuICAgICAgIG9ubHkgaWYgdGhlIHBpdm90IGVsZW1lbnQgaXMgbm90IGluIHRoZSBzZXQuICBUaGUgcmlnaHQgc3VidHJlZVxuICAgICAgIGlzIGNvbXB1dGVkIG9uIGRlbWFuZC4gKilcblxuICAgIHR5cGUgc3BsaXRfYmlzID1cbiAgICAgIHwgRm91bmRcbiAgICAgIHwgTm90Rm91bmQgb2YgdCAqICh1bml0IC0+IHQpXG5cbiAgICBsZXQgcmVjIHNwbGl0X2JpcyB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBOb3RGb3VuZCAoRW1wdHksIChmdW4gKCkgLT4gRW1wdHkpKVxuICAgICAgfCBOb2Rle2w7IHY7IHI7IF99IC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuIEZvdW5kXG4gICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuXG4gICAgICAgICAgICBtYXRjaCBzcGxpdF9iaXMgeCBsIHdpdGhcbiAgICAgICAgICAgIHwgRm91bmQgLT4gRm91bmRcbiAgICAgICAgICAgIHwgTm90Rm91bmQgKGxsLCBybCkgLT4gTm90Rm91bmQgKGxsLCAoZnVuICgpIC0+IGpvaW4gKHJsICgpKSB2IHIpKVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIG1hdGNoIHNwbGl0X2JpcyB4IHIgd2l0aFxuICAgICAgICAgICAgfCBGb3VuZCAtPiBGb3VuZFxuICAgICAgICAgICAgfCBOb3RGb3VuZCAobHIsIHJyKSAtPiBOb3RGb3VuZCAoam9pbiBsIHYgbHIsIHJyKVxuXG4gICAgbGV0IHJlYyBkaXNqb2ludCBzMSBzMiA9XG4gICAgICBtYXRjaCAoczEsIHMyKSB3aXRoXG4gICAgICAgIChFbXB0eSwgXykgfCAoXywgRW1wdHkpIC0+IHRydWVcbiAgICAgIHwgKE5vZGV7bD1sMTsgdj12MTsgcj1yMX0sIHQyKSAtPlxuICAgICAgICAgIGlmIHMxID09IHMyIHRoZW4gZmFsc2VcbiAgICAgICAgICBlbHNlIG1hdGNoIHNwbGl0X2JpcyB2MSB0MiB3aXRoXG4gICAgICAgICAgICAgIE5vdEZvdW5kKGwyLCByMikgLT4gZGlzam9pbnQgbDEgbDIgJiYgZGlzam9pbnQgcjEgKHIyICgpKVxuICAgICAgICAgICAgfCBGb3VuZCAtPiBmYWxzZVxuXG4gICAgbGV0IHJlYyBkaWZmIHMxIHMyID1cbiAgICAgIG1hdGNoIChzMSwgczIpIHdpdGhcbiAgICAgICAgKEVtcHR5LCBfKSAtPiBFbXB0eVxuICAgICAgfCAodDEsIEVtcHR5KSAtPiB0MVxuICAgICAgfCAoTm9kZXtsPWwxOyB2PXYxOyByPXIxfSwgdDIpIC0+XG4gICAgICAgICAgbWF0Y2ggc3BsaXQgdjEgdDIgd2l0aFxuICAgICAgICAgICAgKGwyLCBmYWxzZSwgcjIpIC0+XG4gICAgICAgICAgICAgIGpvaW4gKGRpZmYgbDEgbDIpIHYxIChkaWZmIHIxIHIyKVxuICAgICAgICAgIHwgKGwyLCB0cnVlLCByMikgLT5cbiAgICAgICAgICAgICAgY29uY2F0IChkaWZmIGwxIGwyKSAoZGlmZiByMSByMilcblxuICAgIHR5cGUgZW51bWVyYXRpb24gPSBFbmQgfCBNb3JlIG9mIGVsdCAqIHQgKiBlbnVtZXJhdGlvblxuXG4gICAgbGV0IHJlYyBjb25zX2VudW0gcyBlID1cbiAgICAgIG1hdGNoIHMgd2l0aFxuICAgICAgICBFbXB0eSAtPiBlXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT4gY29uc19lbnVtIGwgKE1vcmUodiwgciwgZSkpXG5cbiAgICBsZXQgcmVjIGNvbXBhcmVfYXV4IGUxIGUyID1cbiAgICAgICAgbWF0Y2ggKGUxLCBlMikgd2l0aFxuICAgICAgICAoRW5kLCBFbmQpIC0+IDBcbiAgICAgIHwgKEVuZCwgXykgIC0+IC0xXG4gICAgICB8IChfLCBFbmQpIC0+IDFcbiAgICAgIHwgKE1vcmUodjEsIHIxLCBlMSksIE1vcmUodjIsIHIyLCBlMikpIC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB2MSB2MiBpblxuICAgICAgICAgIGlmIGMgPD4gMFxuICAgICAgICAgIHRoZW4gY1xuICAgICAgICAgIGVsc2UgY29tcGFyZV9hdXggKGNvbnNfZW51bSByMSBlMSkgKGNvbnNfZW51bSByMiBlMilcblxuICAgIGxldCBjb21wYXJlIHMxIHMyID1cbiAgICAgIGNvbXBhcmVfYXV4IChjb25zX2VudW0gczEgRW5kKSAoY29uc19lbnVtIHMyIEVuZClcblxuICAgIGxldCBlcXVhbCBzMSBzMiA9XG4gICAgICBjb21wYXJlIHMxIHMyID0gMFxuXG4gICAgbGV0IHJlYyBzdWJzZXQgczEgczIgPVxuICAgICAgbWF0Y2ggKHMxLCBzMikgd2l0aFxuICAgICAgICBFbXB0eSwgXyAtPlxuICAgICAgICAgIHRydWVcbiAgICAgIHwgXywgRW1wdHkgLT5cbiAgICAgICAgICBmYWxzZVxuICAgICAgfCBOb2RlIHtsPWwxOyB2PXYxOyByPXIxfSwgKE5vZGUge2w9bDI7IHY9djI7IHI9cjJ9IGFzIHQyKSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgdjEgdjIgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuXG4gICAgICAgICAgICBzdWJzZXQgbDEgbDIgJiYgc3Vic2V0IHIxIHIyXG4gICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuXG4gICAgICAgICAgICBzdWJzZXQgKE5vZGUge2w9bDE7IHY9djE7IHI9RW1wdHk7IGg9MH0pIGwyICYmIHN1YnNldCByMSB0MlxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHN1YnNldCAoTm9kZSB7bD1FbXB0eTsgdj12MTsgcj1yMTsgaD0wfSkgcjIgJiYgc3Vic2V0IGwxIHQyXG5cbiAgICBsZXQgcmVjIGl0ZXIgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+ICgpXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT4gaXRlciBmIGw7IGYgdjsgaXRlciBmIHJcblxuICAgIGxldCByZWMgZm9sZCBmIHMgYWNjdSA9XG4gICAgICBtYXRjaCBzIHdpdGhcbiAgICAgICAgRW1wdHkgLT4gYWNjdVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+IGZvbGQgZiByIChmIHYgKGZvbGQgZiBsIGFjY3UpKVxuXG4gICAgbGV0IHJlYyBmb3JfYWxsIHAgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiB0cnVlXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT4gcCB2ICYmIGZvcl9hbGwgcCBsICYmIGZvcl9hbGwgcCByXG5cbiAgICBsZXQgcmVjIGV4aXN0cyBwID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gZmFsc2VcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPiBwIHYgfHwgZXhpc3RzIHAgbCB8fCBleGlzdHMgcCByXG5cbiAgICBsZXQgcmVjIGZpbHRlciBwID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gRW1wdHlcbiAgICAgIHwgKE5vZGV7bDsgdjsgcn0pIGFzIHQgLT5cbiAgICAgICAgICAoKiBjYWxsIFtwXSBpbiB0aGUgZXhwZWN0ZWQgbGVmdC10by1yaWdodCBvcmRlciAqKVxuICAgICAgICAgIGxldCBsJyA9IGZpbHRlciBwIGwgaW5cbiAgICAgICAgICBsZXQgcHYgPSBwIHYgaW5cbiAgICAgICAgICBsZXQgcicgPSBmaWx0ZXIgcCByIGluXG4gICAgICAgICAgaWYgcHYgdGhlblxuICAgICAgICAgICAgaWYgbD09bCcgJiYgcj09cicgdGhlbiB0IGVsc2Ugam9pbiBsJyB2IHInXG4gICAgICAgICAgZWxzZSBjb25jYXQgbCcgcidcblxuICAgIGxldCByZWMgcGFydGl0aW9uIHAgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiAoRW1wdHksIEVtcHR5KVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgKCogY2FsbCBbcF0gaW4gdGhlIGV4cGVjdGVkIGxlZnQtdG8tcmlnaHQgb3JkZXIgKilcbiAgICAgICAgICBsZXQgKGx0LCBsZikgPSBwYXJ0aXRpb24gcCBsIGluXG4gICAgICAgICAgbGV0IHB2ID0gcCB2IGluXG4gICAgICAgICAgbGV0IChydCwgcmYpID0gcGFydGl0aW9uIHAgciBpblxuICAgICAgICAgIGlmIHB2XG4gICAgICAgICAgdGhlbiAoam9pbiBsdCB2IHJ0LCBjb25jYXQgbGYgcmYpXG4gICAgICAgICAgZWxzZSAoY29uY2F0IGx0IHJ0LCBqb2luIGxmIHYgcmYpXG5cbiAgICBsZXQgcmVjIGNhcmRpbmFsID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gMFxuICAgICAgfCBOb2Rle2w7IHJ9IC0+IGNhcmRpbmFsIGwgKyAxICsgY2FyZGluYWwgclxuXG4gICAgbGV0IHJlYyBlbGVtZW50c19hdXggYWNjdSA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IGFjY3VcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPiBlbGVtZW50c19hdXggKHYgOjogZWxlbWVudHNfYXV4IGFjY3UgcikgbFxuXG4gICAgbGV0IGVsZW1lbnRzIHMgPVxuICAgICAgZWxlbWVudHNfYXV4IFtdIHNcblxuICAgIGxldCBjaG9vc2UgPSBtaW5fZWx0XG5cbiAgICBsZXQgY2hvb3NlX29wdCA9IG1pbl9lbHRfb3B0XG5cbiAgICBsZXQgcmVjIGZpbmQgeCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuIHZcbiAgICAgICAgICBlbHNlIGZpbmQgeCAoaWYgYyA8IDAgdGhlbiBsIGVsc2UgcilcblxuICAgIGxldCByZWMgZmluZF9maXJzdF9hdXggdjAgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgdjBcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X2F1eCB2IGYgbFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfZmlyc3RfYXV4IHYwIGYgclxuXG4gICAgbGV0IHJlYyBmaW5kX2ZpcnN0IGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfZmlyc3RfYXV4IHYgZiBsXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9maXJzdCBmIHJcblxuICAgIGxldCByZWMgZmluZF9maXJzdF9vcHRfYXV4IHYwIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIFNvbWUgdjBcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X29wdF9hdXggdiBmIGxcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X29wdF9hdXggdjAgZiByXG5cbiAgICBsZXQgcmVjIGZpbmRfZmlyc3Rfb3B0IGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIE5vbmVcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X29wdF9hdXggdiBmIGxcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X29wdCBmIHJcblxuICAgIGxldCByZWMgZmluZF9sYXN0X2F1eCB2MCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICB2MFxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfbGFzdF9hdXggdiBmIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2xhc3RfYXV4IHYwIGYgbFxuXG4gICAgbGV0IHJlYyBmaW5kX2xhc3QgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9sYXN0X2F1eCB2IGYgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfbGFzdCBmIGxcblxuICAgIGxldCByZWMgZmluZF9sYXN0X29wdF9hdXggdjAgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgU29tZSB2MFxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfbGFzdF9vcHRfYXV4IHYgZiByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9sYXN0X29wdF9hdXggdjAgZiBsXG5cbiAgICBsZXQgcmVjIGZpbmRfbGFzdF9vcHQgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgTm9uZVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfbGFzdF9vcHRfYXV4IHYgZiByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9sYXN0X29wdCBmIGxcblxuICAgIGxldCByZWMgZmluZF9vcHQgeCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IE5vbmVcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiBTb21lIHZcbiAgICAgICAgICBlbHNlIGZpbmRfb3B0IHggKGlmIGMgPCAwIHRoZW4gbCBlbHNlIHIpXG5cbiAgICBsZXQgdHJ5X2pvaW4gbCB2IHIgPVxuICAgICAgKCogW2pvaW4gbCB2IHJdIGNhbiBvbmx5IGJlIGNhbGxlZCB3aGVuIChlbGVtZW50cyBvZiBsIDwgdiA8XG4gICAgICAgICBlbGVtZW50cyBvZiByKTsgdXNlIFt0cnlfam9pbiBsIHYgcl0gd2hlbiB0aGlzIHByb3BlcnR5IG1heVxuICAgICAgICAgbm90IGhvbGQsIGJ1dCB5b3UgaG9wZSBpdCBkb2VzIGhvbGQgaW4gdGhlIGNvbW1vbiBjYXNlICopXG4gICAgICBpZiAobCA9IEVtcHR5IHx8IE9yZC5jb21wYXJlIChtYXhfZWx0IGwpIHYgPCAwKVxuICAgICAgJiYgKHIgPSBFbXB0eSB8fCBPcmQuY29tcGFyZSB2IChtaW5fZWx0IHIpIDwgMClcbiAgICAgIHRoZW4gam9pbiBsIHYgclxuICAgICAgZWxzZSB1bmlvbiBsIChhZGQgdiByKVxuXG4gICAgbGV0IHJlYyBtYXAgZiA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+IEVtcHR5XG4gICAgICB8IE5vZGV7bDsgdjsgcn0gYXMgdCAtPlxuICAgICAgICAgKCogZW5mb3JjZSBsZWZ0LXRvLXJpZ2h0IGV2YWx1YXRpb24gb3JkZXIgKilcbiAgICAgICAgIGxldCBsJyA9IG1hcCBmIGwgaW5cbiAgICAgICAgIGxldCB2JyA9IGYgdiBpblxuICAgICAgICAgbGV0IHInID0gbWFwIGYgciBpblxuICAgICAgICAgaWYgbCA9PSBsJyAmJiB2ID09IHYnICYmIHIgPT0gcicgdGhlbiB0XG4gICAgICAgICBlbHNlIHRyeV9qb2luIGwnIHYnIHInXG5cbiAgICBsZXQgdHJ5X2NvbmNhdCB0MSB0MiA9XG4gICAgICBtYXRjaCAodDEsIHQyKSB3aXRoXG4gICAgICAgIChFbXB0eSwgdCkgLT4gdFxuICAgICAgfCAodCwgRW1wdHkpIC0+IHRcbiAgICAgIHwgKF8sIF8pIC0+IHRyeV9qb2luIHQxIChtaW5fZWx0IHQyKSAocmVtb3ZlX21pbl9lbHQgdDIpXG5cbiAgICBsZXQgcmVjIGZpbHRlcl9tYXAgZiA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+IEVtcHR5XG4gICAgICB8IE5vZGV7bDsgdjsgcn0gYXMgdCAtPlxuICAgICAgICAgKCogZW5mb3JjZSBsZWZ0LXRvLXJpZ2h0IGV2YWx1YXRpb24gb3JkZXIgKilcbiAgICAgICAgIGxldCBsJyA9IGZpbHRlcl9tYXAgZiBsIGluXG4gICAgICAgICBsZXQgdicgPSBmIHYgaW5cbiAgICAgICAgIGxldCByJyA9IGZpbHRlcl9tYXAgZiByIGluXG4gICAgICAgICBiZWdpbiBtYXRjaCB2JyB3aXRoXG4gICAgICAgICAgIHwgU29tZSB2JyAtPlxuICAgICAgICAgICAgICBpZiBsID09IGwnICYmIHYgPT0gdicgJiYgciA9PSByJyB0aGVuIHRcbiAgICAgICAgICAgICAgZWxzZSB0cnlfam9pbiBsJyB2JyByJ1xuICAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgICAgdHJ5X2NvbmNhdCBsJyByJ1xuICAgICAgICAgZW5kXG5cbiAgICBsZXQgb2Zfc29ydGVkX2xpc3QgbCA9XG4gICAgICBsZXQgcmVjIHN1YiBuIGwgPVxuICAgICAgICBtYXRjaCBuLCBsIHdpdGhcbiAgICAgICAgfCAwLCBsIC0+IEVtcHR5LCBsXG4gICAgICAgIHwgMSwgeDAgOjogbCAtPiBOb2RlIHtsPUVtcHR5OyB2PXgwOyByPUVtcHR5OyBoPTF9LCBsXG4gICAgICAgIHwgMiwgeDAgOjogeDEgOjogbCAtPlxuICAgICAgICAgICAgTm9kZXtsPU5vZGV7bD1FbXB0eTsgdj14MDsgcj1FbXB0eTsgaD0xfTsgdj14MTsgcj1FbXB0eTsgaD0yfSwgbFxuICAgICAgICB8IDMsIHgwIDo6IHgxIDo6IHgyIDo6IGwgLT5cbiAgICAgICAgICAgIE5vZGV7bD1Ob2Rle2w9RW1wdHk7IHY9eDA7IHI9RW1wdHk7IGg9MX07IHY9eDE7XG4gICAgICAgICAgICAgICAgIHI9Tm9kZXtsPUVtcHR5OyB2PXgyOyByPUVtcHR5OyBoPTF9OyBoPTJ9LCBsXG4gICAgICAgIHwgbiwgbCAtPlxuICAgICAgICAgIGxldCBubCA9IG4gLyAyIGluXG4gICAgICAgICAgbGV0IGxlZnQsIGwgPSBzdWIgbmwgbCBpblxuICAgICAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgICAgIHwgW10gLT4gYXNzZXJ0IGZhbHNlXG4gICAgICAgICAgfCBtaWQgOjogbCAtPlxuICAgICAgICAgICAgbGV0IHJpZ2h0LCBsID0gc3ViIChuIC0gbmwgLSAxKSBsIGluXG4gICAgICAgICAgICBjcmVhdGUgbGVmdCBtaWQgcmlnaHQsIGxcbiAgICAgIGluXG4gICAgICBmc3QgKHN1YiAoTGlzdC5sZW5ndGggbCkgbClcblxuICAgIGxldCBvZl9saXN0IGwgPVxuICAgICAgbWF0Y2ggbCB3aXRoXG4gICAgICB8IFtdIC0+IGVtcHR5XG4gICAgICB8IFt4MF0gLT4gc2luZ2xldG9uIHgwXG4gICAgICB8IFt4MDsgeDFdIC0+IGFkZCB4MSAoc2luZ2xldG9uIHgwKVxuICAgICAgfCBbeDA7IHgxOyB4Ml0gLT4gYWRkIHgyIChhZGQgeDEgKHNpbmdsZXRvbiB4MCkpXG4gICAgICB8IFt4MDsgeDE7IHgyOyB4M10gLT4gYWRkIHgzIChhZGQgeDIgKGFkZCB4MSAoc2luZ2xldG9uIHgwKSkpXG4gICAgICB8IFt4MDsgeDE7IHgyOyB4MzsgeDRdIC0+IGFkZCB4NCAoYWRkIHgzIChhZGQgeDIgKGFkZCB4MSAoc2luZ2xldG9uIHgwKSkpKVxuICAgICAgfCBfIC0+IG9mX3NvcnRlZF9saXN0IChMaXN0LnNvcnRfdW5pcSBPcmQuY29tcGFyZSBsKVxuXG4gICAgbGV0IGFkZF9zZXEgaSBtID1cbiAgICAgIFNlcS5mb2xkX2xlZnQgKGZ1biBzIHggLT4gYWRkIHggcykgbSBpXG5cbiAgICBsZXQgb2Zfc2VxIGkgPSBhZGRfc2VxIGkgZW1wdHlcblxuICAgIGxldCByZWMgc2VxX29mX2VudW1fIGMgKCkgPSBtYXRjaCBjIHdpdGhcbiAgICAgIHwgRW5kIC0+IFNlcS5OaWxcbiAgICAgIHwgTW9yZSAoeCwgdCwgcmVzdCkgLT4gU2VxLkNvbnMgKHgsIHNlcV9vZl9lbnVtXyAoY29uc19lbnVtIHQgcmVzdCkpXG5cbiAgICBsZXQgdG9fc2VxIGMgPSBzZXFfb2ZfZW51bV8gKGNvbnNfZW51bSBjIEVuZClcblxuICAgIGxldCByZWMgc25vY19lbnVtIHMgZSA9XG4gICAgICBtYXRjaCBzIHdpdGhcbiAgICAgICAgRW1wdHkgLT4gZVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+IHNub2NfZW51bSByIChNb3JlKHYsIGwsIGUpKVxuXG4gICAgbGV0IHJlYyByZXZfc2VxX29mX2VudW1fIGMgKCkgPSBtYXRjaCBjIHdpdGhcbiAgICAgIHwgRW5kIC0+IFNlcS5OaWxcbiAgICAgIHwgTW9yZSAoeCwgdCwgcmVzdCkgLT4gU2VxLkNvbnMgKHgsIHJldl9zZXFfb2ZfZW51bV8gKHNub2NfZW51bSB0IHJlc3QpKVxuXG4gICAgbGV0IHRvX3Jldl9zZXEgYyA9IHJldl9zZXFfb2ZfZW51bV8gKHNub2NfZW51bSBjIEVuZClcblxuICAgIGxldCB0b19zZXFfZnJvbSBsb3cgcyA9XG4gICAgICBsZXQgcmVjIGF1eCBsb3cgcyBjID0gbWF0Y2ggcyB3aXRoXG4gICAgICAgIHwgRW1wdHkgLT4gY1xuICAgICAgICB8IE5vZGUge2w7IHI7IHY7IF99IC0+XG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBPcmQuY29tcGFyZSB2IGxvdyB3aXRoXG4gICAgICAgICAgICAgIHwgMCAtPiBNb3JlICh2LCByLCBjKVxuICAgICAgICAgICAgICB8IG4gd2hlbiBuPDAgLT4gYXV4IGxvdyByIGNcbiAgICAgICAgICAgICAgfCBfIC0+IGF1eCBsb3cgbCAoTW9yZSAodiwgciwgYykpXG4gICAgICAgICAgICBlbmRcbiAgICAgIGluXG4gICAgICBzZXFfb2ZfZW51bV8gKGF1eCBsb3cgcyBFbmQpXG4gIGVuZFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5tb2R1bGUgdHlwZSBPcmRlcmVkVHlwZSA9XG4gIHNpZ1xuICAgIHR5cGUgdFxuICAgIHZhbCBjb21wYXJlOiB0IC0+IHQgLT4gaW50XG4gIGVuZFxuXG5tb2R1bGUgdHlwZSBTID1cbiAgc2lnXG4gICAgdHlwZSBrZXlcbiAgICB0eXBlICErJ2EgdFxuICAgIHZhbCBlbXB0eTogJ2EgdFxuICAgIHZhbCBpc19lbXB0eTogJ2EgdCAtPiBib29sXG4gICAgdmFsIG1lbTogIGtleSAtPiAnYSB0IC0+IGJvb2xcbiAgICB2YWwgYWRkOiBrZXkgLT4gJ2EgLT4gJ2EgdCAtPiAnYSB0XG4gICAgdmFsIHVwZGF0ZToga2V5IC0+ICgnYSBvcHRpb24gLT4gJ2Egb3B0aW9uKSAtPiAnYSB0IC0+ICdhIHRcbiAgICB2YWwgc2luZ2xldG9uOiBrZXkgLT4gJ2EgLT4gJ2EgdFxuICAgIHZhbCByZW1vdmU6IGtleSAtPiAnYSB0IC0+ICdhIHRcbiAgICB2YWwgbWVyZ2U6XG4gICAgICAgICAgKGtleSAtPiAnYSBvcHRpb24gLT4gJ2Igb3B0aW9uIC0+ICdjIG9wdGlvbikgLT4gJ2EgdCAtPiAnYiB0IC0+ICdjIHRcbiAgICB2YWwgdW5pb246IChrZXkgLT4gJ2EgLT4gJ2EgLT4gJ2Egb3B0aW9uKSAtPiAnYSB0IC0+ICdhIHQgLT4gJ2EgdFxuICAgIHZhbCBjb21wYXJlOiAoJ2EgLT4gJ2EgLT4gaW50KSAtPiAnYSB0IC0+ICdhIHQgLT4gaW50XG4gICAgdmFsIGVxdWFsOiAoJ2EgLT4gJ2EgLT4gYm9vbCkgLT4gJ2EgdCAtPiAnYSB0IC0+IGJvb2xcbiAgICB2YWwgaXRlcjogKGtleSAtPiAnYSAtPiB1bml0KSAtPiAnYSB0IC0+IHVuaXRcbiAgICB2YWwgZm9sZDogKGtleSAtPiAnYSAtPiAnYiAtPiAnYikgLT4gJ2EgdCAtPiAnYiAtPiAnYlxuICAgIHZhbCBmb3JfYWxsOiAoa2V5IC0+ICdhIC0+IGJvb2wpIC0+ICdhIHQgLT4gYm9vbFxuICAgIHZhbCBleGlzdHM6IChrZXkgLT4gJ2EgLT4gYm9vbCkgLT4gJ2EgdCAtPiBib29sXG4gICAgdmFsIGZpbHRlcjogKGtleSAtPiAnYSAtPiBib29sKSAtPiAnYSB0IC0+ICdhIHRcbiAgICB2YWwgZmlsdGVyX21hcDogKGtleSAtPiAnYSAtPiAnYiBvcHRpb24pIC0+ICdhIHQgLT4gJ2IgdFxuICAgIHZhbCBwYXJ0aXRpb246IChrZXkgLT4gJ2EgLT4gYm9vbCkgLT4gJ2EgdCAtPiAnYSB0ICogJ2EgdFxuICAgIHZhbCBjYXJkaW5hbDogJ2EgdCAtPiBpbnRcbiAgICB2YWwgYmluZGluZ3M6ICdhIHQgLT4gKGtleSAqICdhKSBsaXN0XG4gICAgdmFsIG1pbl9iaW5kaW5nOiAnYSB0IC0+IChrZXkgKiAnYSlcbiAgICB2YWwgbWluX2JpbmRpbmdfb3B0OiAnYSB0IC0+IChrZXkgKiAnYSkgb3B0aW9uXG4gICAgdmFsIG1heF9iaW5kaW5nOiAnYSB0IC0+IChrZXkgKiAnYSlcbiAgICB2YWwgbWF4X2JpbmRpbmdfb3B0OiAnYSB0IC0+IChrZXkgKiAnYSkgb3B0aW9uXG4gICAgdmFsIGNob29zZTogJ2EgdCAtPiAoa2V5ICogJ2EpXG4gICAgdmFsIGNob29zZV9vcHQ6ICdhIHQgLT4gKGtleSAqICdhKSBvcHRpb25cbiAgICB2YWwgc3BsaXQ6IGtleSAtPiAnYSB0IC0+ICdhIHQgKiAnYSBvcHRpb24gKiAnYSB0XG4gICAgdmFsIGZpbmQ6IGtleSAtPiAnYSB0IC0+ICdhXG4gICAgdmFsIGZpbmRfb3B0OiBrZXkgLT4gJ2EgdCAtPiAnYSBvcHRpb25cbiAgICB2YWwgZmluZF9maXJzdDogKGtleSAtPiBib29sKSAtPiAnYSB0IC0+IGtleSAqICdhXG4gICAgdmFsIGZpbmRfZmlyc3Rfb3B0OiAoa2V5IC0+IGJvb2wpIC0+ICdhIHQgLT4gKGtleSAqICdhKSBvcHRpb25cbiAgICB2YWwgZmluZF9sYXN0OiAoa2V5IC0+IGJvb2wpIC0+ICdhIHQgLT4ga2V5ICogJ2FcbiAgICB2YWwgZmluZF9sYXN0X29wdDogKGtleSAtPiBib29sKSAtPiAnYSB0IC0+IChrZXkgKiAnYSkgb3B0aW9uXG4gICAgdmFsIG1hcDogKCdhIC0+ICdiKSAtPiAnYSB0IC0+ICdiIHRcbiAgICB2YWwgbWFwaTogKGtleSAtPiAnYSAtPiAnYikgLT4gJ2EgdCAtPiAnYiB0XG4gICAgdmFsIHRvX3NlcSA6ICdhIHQgLT4gKGtleSAqICdhKSBTZXEudFxuICAgIHZhbCB0b19yZXZfc2VxIDogJ2EgdCAtPiAoa2V5ICogJ2EpIFNlcS50XG4gICAgdmFsIHRvX3NlcV9mcm9tIDoga2V5IC0+ICdhIHQgLT4gKGtleSAqICdhKSBTZXEudFxuICAgIHZhbCBhZGRfc2VxIDogKGtleSAqICdhKSBTZXEudCAtPiAnYSB0IC0+ICdhIHRcbiAgICB2YWwgb2Zfc2VxIDogKGtleSAqICdhKSBTZXEudCAtPiAnYSB0XG4gIGVuZFxuXG5tb2R1bGUgTWFrZShPcmQ6IE9yZGVyZWRUeXBlKSA9IHN0cnVjdFxuXG4gICAgdHlwZSBrZXkgPSBPcmQudFxuXG4gICAgdHlwZSAnYSB0ID1cbiAgICAgICAgRW1wdHlcbiAgICAgIHwgTm9kZSBvZiB7bDonYSB0OyB2OmtleTsgZDonYTsgcjonYSB0OyBoOmludH1cblxuICAgIGxldCBoZWlnaHQgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiAwXG4gICAgICB8IE5vZGUge2h9IC0+IGhcblxuICAgIGxldCBjcmVhdGUgbCB4IGQgciA9XG4gICAgICBsZXQgaGwgPSBoZWlnaHQgbCBhbmQgaHIgPSBoZWlnaHQgciBpblxuICAgICAgTm9kZXtsOyB2PXg7IGQ7IHI7IGg9KGlmIGhsID49IGhyIHRoZW4gaGwgKyAxIGVsc2UgaHIgKyAxKX1cblxuICAgIGxldCBzaW5nbGV0b24geCBkID0gTm9kZXtsPUVtcHR5OyB2PXg7IGQ7IHI9RW1wdHk7IGg9MX1cblxuICAgIGxldCBiYWwgbCB4IGQgciA9XG4gICAgICBsZXQgaGwgPSBtYXRjaCBsIHdpdGggRW1wdHkgLT4gMCB8IE5vZGUge2h9IC0+IGggaW5cbiAgICAgIGxldCBociA9IG1hdGNoIHIgd2l0aCBFbXB0eSAtPiAwIHwgTm9kZSB7aH0gLT4gaCBpblxuICAgICAgaWYgaGwgPiBociArIDIgdGhlbiBiZWdpblxuICAgICAgICBtYXRjaCBsIHdpdGhcbiAgICAgICAgICBFbXB0eSAtPiBpbnZhbGlkX2FyZyBcIk1hcC5iYWxcIlxuICAgICAgICB8IE5vZGV7bD1sbDsgdj1sdjsgZD1sZDsgcj1scn0gLT5cbiAgICAgICAgICAgIGlmIGhlaWdodCBsbCA+PSBoZWlnaHQgbHIgdGhlblxuICAgICAgICAgICAgICBjcmVhdGUgbGwgbHYgbGQgKGNyZWF0ZSBsciB4IGQgcilcbiAgICAgICAgICAgIGVsc2UgYmVnaW5cbiAgICAgICAgICAgICAgbWF0Y2ggbHIgd2l0aFxuICAgICAgICAgICAgICAgIEVtcHR5IC0+IGludmFsaWRfYXJnIFwiTWFwLmJhbFwiXG4gICAgICAgICAgICAgIHwgTm9kZXtsPWxybDsgdj1scnY7IGQ9bHJkOyByPWxycn0tPlxuICAgICAgICAgICAgICAgICAgY3JlYXRlIChjcmVhdGUgbGwgbHYgbGQgbHJsKSBscnYgbHJkIChjcmVhdGUgbHJyIHggZCByKVxuICAgICAgICAgICAgZW5kXG4gICAgICBlbmQgZWxzZSBpZiBociA+IGhsICsgMiB0aGVuIGJlZ2luXG4gICAgICAgIG1hdGNoIHIgd2l0aFxuICAgICAgICAgIEVtcHR5IC0+IGludmFsaWRfYXJnIFwiTWFwLmJhbFwiXG4gICAgICAgIHwgTm9kZXtsPXJsOyB2PXJ2OyBkPXJkOyByPXJyfSAtPlxuICAgICAgICAgICAgaWYgaGVpZ2h0IHJyID49IGhlaWdodCBybCB0aGVuXG4gICAgICAgICAgICAgIGNyZWF0ZSAoY3JlYXRlIGwgeCBkIHJsKSBydiByZCByclxuICAgICAgICAgICAgZWxzZSBiZWdpblxuICAgICAgICAgICAgICBtYXRjaCBybCB3aXRoXG4gICAgICAgICAgICAgICAgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJNYXAuYmFsXCJcbiAgICAgICAgICAgICAgfCBOb2Rle2w9cmxsOyB2PXJsdjsgZD1ybGQ7IHI9cmxyfSAtPlxuICAgICAgICAgICAgICAgICAgY3JlYXRlIChjcmVhdGUgbCB4IGQgcmxsKSBybHYgcmxkIChjcmVhdGUgcmxyIHJ2IHJkIHJyKVxuICAgICAgICAgICAgZW5kXG4gICAgICBlbmQgZWxzZVxuICAgICAgICBOb2Rle2w7IHY9eDsgZDsgcjsgaD0oaWYgaGwgPj0gaHIgdGhlbiBobCArIDEgZWxzZSBociArIDEpfVxuXG4gICAgbGV0IGVtcHR5ID0gRW1wdHlcblxuICAgIGxldCBpc19lbXB0eSA9IGZ1bmN0aW9uIEVtcHR5IC0+IHRydWUgfCBfIC0+IGZhbHNlXG5cbiAgICBsZXQgcmVjIGFkZCB4IGRhdGEgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIE5vZGV7bD1FbXB0eTsgdj14OyBkPWRhdGE7IHI9RW1wdHk7IGg9MX1cbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcjsgaH0gYXMgbSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlblxuICAgICAgICAgICAgaWYgZCA9PSBkYXRhIHRoZW4gbSBlbHNlIE5vZGV7bDsgdj14OyBkPWRhdGE7IHI7IGh9XG4gICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuXG4gICAgICAgICAgICBsZXQgbGwgPSBhZGQgeCBkYXRhIGwgaW5cbiAgICAgICAgICAgIGlmIGwgPT0gbGwgdGhlbiBtIGVsc2UgYmFsIGxsIHYgZCByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbGV0IHJyID0gYWRkIHggZGF0YSByIGluXG4gICAgICAgICAgICBpZiByID09IHJyIHRoZW4gbSBlbHNlIGJhbCBsIHYgZCByclxuXG4gICAgbGV0IHJlYyBmaW5kIHggPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiBkXG4gICAgICAgICAgZWxzZSBmaW5kIHggKGlmIGMgPCAwIHRoZW4gbCBlbHNlIHIpXG5cbiAgICBsZXQgcmVjIGZpbmRfZmlyc3RfYXV4IHYwIGQwIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgICh2MCwgZDApXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfZmlyc3RfYXV4IHYgZCBmIGxcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X2F1eCB2MCBkMCBmIHJcblxuICAgIGxldCByZWMgZmluZF9maXJzdCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9maXJzdF9hdXggdiBkIGYgbFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfZmlyc3QgZiByXG5cbiAgICBsZXQgcmVjIGZpbmRfZmlyc3Rfb3B0X2F1eCB2MCBkMCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBTb21lICh2MCwgZDApXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfZmlyc3Rfb3B0X2F1eCB2IGQgZiBsXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9maXJzdF9vcHRfYXV4IHYwIGQwIGYgclxuXG4gICAgbGV0IHJlYyBmaW5kX2ZpcnN0X29wdCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBOb25lXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfZmlyc3Rfb3B0X2F1eCB2IGQgZiBsXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9maXJzdF9vcHQgZiByXG5cbiAgICBsZXQgcmVjIGZpbmRfbGFzdF9hdXggdjAgZDAgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgKHYwLCBkMClcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9sYXN0X2F1eCB2IGQgZiByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9sYXN0X2F1eCB2MCBkMCBmIGxcblxuICAgIGxldCByZWMgZmluZF9sYXN0IGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2xhc3RfYXV4IHYgZCBmIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2xhc3QgZiBsXG5cbiAgICBsZXQgcmVjIGZpbmRfbGFzdF9vcHRfYXV4IHYwIGQwIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIFNvbWUgKHYwLCBkMClcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9sYXN0X29wdF9hdXggdiBkIGYgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfbGFzdF9vcHRfYXV4IHYwIGQwIGYgbFxuXG4gICAgbGV0IHJlYyBmaW5kX2xhc3Rfb3B0IGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIE5vbmVcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9sYXN0X29wdF9hdXggdiBkIGYgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfbGFzdF9vcHQgZiBsXG5cbiAgICBsZXQgcmVjIGZpbmRfb3B0IHggPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIE5vbmVcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gU29tZSBkXG4gICAgICAgICAgZWxzZSBmaW5kX29wdCB4IChpZiBjIDwgMCB0aGVuIGwgZWxzZSByKVxuXG4gICAgbGV0IHJlYyBtZW0geCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgZmFsc2VcbiAgICAgIHwgTm9kZSB7bDsgdjsgcn0gLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGMgPSAwIHx8IG1lbSB4IChpZiBjIDwgMCB0aGVuIGwgZWxzZSByKVxuXG4gICAgbGV0IHJlYyBtaW5fYmluZGluZyA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBOb2RlIHtsPUVtcHR5OyB2OyBkfSAtPiAodiwgZClcbiAgICAgIHwgTm9kZSB7bH0gLT4gbWluX2JpbmRpbmcgbFxuXG4gICAgbGV0IHJlYyBtaW5fYmluZGluZ19vcHQgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBOb25lXG4gICAgICB8IE5vZGUge2w9RW1wdHk7IHY7IGR9IC0+IFNvbWUgKHYsIGQpXG4gICAgICB8IE5vZGUge2x9LT4gbWluX2JpbmRpbmdfb3B0IGxcblxuICAgIGxldCByZWMgbWF4X2JpbmRpbmcgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgTm9kZSB7djsgZDsgcj1FbXB0eX0gLT4gKHYsIGQpXG4gICAgICB8IE5vZGUge3J9IC0+IG1heF9iaW5kaW5nIHJcblxuICAgIGxldCByZWMgbWF4X2JpbmRpbmdfb3B0ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gTm9uZVxuICAgICAgfCBOb2RlIHt2OyBkOyByPUVtcHR5fSAtPiBTb21lICh2LCBkKVxuICAgICAgfCBOb2RlIHtyfSAtPiBtYXhfYmluZGluZ19vcHQgclxuXG4gICAgbGV0IHJlYyByZW1vdmVfbWluX2JpbmRpbmcgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBpbnZhbGlkX2FyZyBcIk1hcC5yZW1vdmVfbWluX2VsdFwiXG4gICAgICB8IE5vZGUge2w9RW1wdHk7IHJ9IC0+IHJcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT4gYmFsIChyZW1vdmVfbWluX2JpbmRpbmcgbCkgdiBkIHJcblxuICAgIGxldCBtZXJnZSB0MSB0MiA9XG4gICAgICBtYXRjaCAodDEsIHQyKSB3aXRoXG4gICAgICAgIChFbXB0eSwgdCkgLT4gdFxuICAgICAgfCAodCwgRW1wdHkpIC0+IHRcbiAgICAgIHwgKF8sIF8pIC0+XG4gICAgICAgICAgbGV0ICh4LCBkKSA9IG1pbl9iaW5kaW5nIHQyIGluXG4gICAgICAgICAgYmFsIHQxIHggZCAocmVtb3ZlX21pbl9iaW5kaW5nIHQyKVxuXG4gICAgbGV0IHJlYyByZW1vdmUgeCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgRW1wdHlcbiAgICAgIHwgKE5vZGUge2w7IHY7IGQ7IHJ9IGFzIG0pIC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuIG1lcmdlIGwgclxuICAgICAgICAgIGVsc2UgaWYgYyA8IDAgdGhlblxuICAgICAgICAgICAgbGV0IGxsID0gcmVtb3ZlIHggbCBpbiBpZiBsID09IGxsIHRoZW4gbSBlbHNlIGJhbCBsbCB2IGQgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxldCByciA9IHJlbW92ZSB4IHIgaW4gaWYgciA9PSByciB0aGVuIG0gZWxzZSBiYWwgbCB2IGQgcnJcblxuICAgIGxldCByZWMgdXBkYXRlIHggZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgYmVnaW4gbWF0Y2ggZiBOb25lIHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gRW1wdHlcbiAgICAgICAgICB8IFNvbWUgZGF0YSAtPiBOb2Rle2w9RW1wdHk7IHY9eDsgZD1kYXRhOyByPUVtcHR5OyBoPTF9XG4gICAgICAgICAgZW5kXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHI7IGh9IGFzIG0gLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gYmVnaW5cbiAgICAgICAgICAgIG1hdGNoIGYgKFNvbWUgZCkgd2l0aFxuICAgICAgICAgICAgfCBOb25lIC0+IG1lcmdlIGwgclxuICAgICAgICAgICAgfCBTb21lIGRhdGEgLT5cbiAgICAgICAgICAgICAgICBpZiBkID09IGRhdGEgdGhlbiBtIGVsc2UgTm9kZXtsOyB2PXg7IGQ9ZGF0YTsgcjsgaH1cbiAgICAgICAgICBlbmQgZWxzZSBpZiBjIDwgMCB0aGVuXG4gICAgICAgICAgICBsZXQgbGwgPSB1cGRhdGUgeCBmIGwgaW5cbiAgICAgICAgICAgIGlmIGwgPT0gbGwgdGhlbiBtIGVsc2UgYmFsIGxsIHYgZCByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbGV0IHJyID0gdXBkYXRlIHggZiByIGluXG4gICAgICAgICAgICBpZiByID09IHJyIHRoZW4gbSBlbHNlIGJhbCBsIHYgZCByclxuXG4gICAgbGV0IHJlYyBpdGVyIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiAoKVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGl0ZXIgZiBsOyBmIHYgZDsgaXRlciBmIHJcblxuICAgIGxldCByZWMgbWFwIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIEVtcHR5XG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHI7IGh9IC0+XG4gICAgICAgICAgbGV0IGwnID0gbWFwIGYgbCBpblxuICAgICAgICAgIGxldCBkJyA9IGYgZCBpblxuICAgICAgICAgIGxldCByJyA9IG1hcCBmIHIgaW5cbiAgICAgICAgICBOb2Rle2w9bCc7IHY7IGQ9ZCc7IHI9cic7IGh9XG5cbiAgICBsZXQgcmVjIG1hcGkgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgRW1wdHlcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcjsgaH0gLT5cbiAgICAgICAgICBsZXQgbCcgPSBtYXBpIGYgbCBpblxuICAgICAgICAgIGxldCBkJyA9IGYgdiBkIGluXG4gICAgICAgICAgbGV0IHInID0gbWFwaSBmIHIgaW5cbiAgICAgICAgICBOb2Rle2w9bCc7IHY7IGQ9ZCc7IHI9cic7IGh9XG5cbiAgICBsZXQgcmVjIGZvbGQgZiBtIGFjY3UgPVxuICAgICAgbWF0Y2ggbSB3aXRoXG4gICAgICAgIEVtcHR5IC0+IGFjY3VcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBmb2xkIGYgciAoZiB2IGQgKGZvbGQgZiBsIGFjY3UpKVxuXG4gICAgbGV0IHJlYyBmb3JfYWxsIHAgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiB0cnVlXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+IHAgdiBkICYmIGZvcl9hbGwgcCBsICYmIGZvcl9hbGwgcCByXG5cbiAgICBsZXQgcmVjIGV4aXN0cyBwID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gZmFsc2VcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT4gcCB2IGQgfHwgZXhpc3RzIHAgbCB8fCBleGlzdHMgcCByXG5cbiAgICAoKiBCZXdhcmU6IHRob3NlIHR3byBmdW5jdGlvbnMgYXNzdW1lIHRoYXQgdGhlIGFkZGVkIGsgaXMgKnN0cmljdGx5KlxuICAgICAgIHNtYWxsZXIgKG9yIGJpZ2dlcikgdGhhbiBhbGwgdGhlIHByZXNlbnQga2V5cyBpbiB0aGUgdHJlZTsgaXRcbiAgICAgICBkb2VzIG5vdCB0ZXN0IGZvciBlcXVhbGl0eSB3aXRoIHRoZSBjdXJyZW50IG1pbiAob3IgbWF4KSBrZXkuXG5cbiAgICAgICBJbmRlZWQsIHRoZXkgYXJlIG9ubHkgdXNlZCBkdXJpbmcgdGhlIFwiam9pblwiIG9wZXJhdGlvbiB3aGljaFxuICAgICAgIHJlc3BlY3RzIHRoaXMgcHJlY29uZGl0aW9uLlxuICAgICopXG5cbiAgICBsZXQgcmVjIGFkZF9taW5fYmluZGluZyBrIHggPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiBzaW5nbGV0b24gayB4XG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgIGJhbCAoYWRkX21pbl9iaW5kaW5nIGsgeCBsKSB2IGQgclxuXG4gICAgbGV0IHJlYyBhZGRfbWF4X2JpbmRpbmcgayB4ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT4gc2luZ2xldG9uIGsgeFxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICBiYWwgbCB2IGQgKGFkZF9tYXhfYmluZGluZyBrIHggcilcblxuICAgICgqIFNhbWUgYXMgY3JlYXRlIGFuZCBiYWwsIGJ1dCBubyBhc3N1bXB0aW9ucyBhcmUgbWFkZSBvbiB0aGVcbiAgICAgICByZWxhdGl2ZSBoZWlnaHRzIG9mIGwgYW5kIHIuICopXG5cbiAgICBsZXQgcmVjIGpvaW4gbCB2IGQgciA9XG4gICAgICBtYXRjaCAobCwgcikgd2l0aFxuICAgICAgICAoRW1wdHksIF8pIC0+IGFkZF9taW5fYmluZGluZyB2IGQgclxuICAgICAgfCAoXywgRW1wdHkpIC0+IGFkZF9tYXhfYmluZGluZyB2IGQgbFxuICAgICAgfCAoTm9kZXtsPWxsOyB2PWx2OyBkPWxkOyByPWxyOyBoPWxofSxcbiAgICAgICAgIE5vZGV7bD1ybDsgdj1ydjsgZD1yZDsgcj1ycjsgaD1yaH0pIC0+XG4gICAgICAgICAgaWYgbGggPiByaCArIDIgdGhlbiBiYWwgbGwgbHYgbGQgKGpvaW4gbHIgdiBkIHIpIGVsc2VcbiAgICAgICAgICBpZiByaCA+IGxoICsgMiB0aGVuIGJhbCAoam9pbiBsIHYgZCBybCkgcnYgcmQgcnIgZWxzZVxuICAgICAgICAgIGNyZWF0ZSBsIHYgZCByXG5cbiAgICAoKiBNZXJnZSB0d28gdHJlZXMgbCBhbmQgciBpbnRvIG9uZS5cbiAgICAgICBBbGwgZWxlbWVudHMgb2YgbCBtdXN0IHByZWNlZGUgdGhlIGVsZW1lbnRzIG9mIHIuXG4gICAgICAgTm8gYXNzdW1wdGlvbiBvbiB0aGUgaGVpZ2h0cyBvZiBsIGFuZCByLiAqKVxuXG4gICAgbGV0IGNvbmNhdCB0MSB0MiA9XG4gICAgICBtYXRjaCAodDEsIHQyKSB3aXRoXG4gICAgICAgIChFbXB0eSwgdCkgLT4gdFxuICAgICAgfCAodCwgRW1wdHkpIC0+IHRcbiAgICAgIHwgKF8sIF8pIC0+XG4gICAgICAgICAgbGV0ICh4LCBkKSA9IG1pbl9iaW5kaW5nIHQyIGluXG4gICAgICAgICAgam9pbiB0MSB4IGQgKHJlbW92ZV9taW5fYmluZGluZyB0MilcblxuICAgIGxldCBjb25jYXRfb3Jfam9pbiB0MSB2IGQgdDIgPVxuICAgICAgbWF0Y2ggZCB3aXRoXG4gICAgICB8IFNvbWUgZCAtPiBqb2luIHQxIHYgZCB0MlxuICAgICAgfCBOb25lIC0+IGNvbmNhdCB0MSB0MlxuXG4gICAgbGV0IHJlYyBzcGxpdCB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICAoRW1wdHksIE5vbmUsIEVtcHR5KVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiAobCwgU29tZSBkLCByKVxuICAgICAgICAgIGVsc2UgaWYgYyA8IDAgdGhlblxuICAgICAgICAgICAgbGV0IChsbCwgcHJlcywgcmwpID0gc3BsaXQgeCBsIGluIChsbCwgcHJlcywgam9pbiBybCB2IGQgcilcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsZXQgKGxyLCBwcmVzLCBycikgPSBzcGxpdCB4IHIgaW4gKGpvaW4gbCB2IGQgbHIsIHByZXMsIHJyKVxuXG4gICAgbGV0IHJlYyBtZXJnZSBmIHMxIHMyID1cbiAgICAgIG1hdGNoIChzMSwgczIpIHdpdGhcbiAgICAgICAgKEVtcHR5LCBFbXB0eSkgLT4gRW1wdHlcbiAgICAgIHwgKE5vZGUge2w9bDE7IHY9djE7IGQ9ZDE7IHI9cjE7IGg9aDF9LCBfKSB3aGVuIGgxID49IGhlaWdodCBzMiAtPlxuICAgICAgICAgIGxldCAobDIsIGQyLCByMikgPSBzcGxpdCB2MSBzMiBpblxuICAgICAgICAgIGNvbmNhdF9vcl9qb2luIChtZXJnZSBmIGwxIGwyKSB2MSAoZiB2MSAoU29tZSBkMSkgZDIpIChtZXJnZSBmIHIxIHIyKVxuICAgICAgfCAoXywgTm9kZSB7bD1sMjsgdj12MjsgZD1kMjsgcj1yMn0pIC0+XG4gICAgICAgICAgbGV0IChsMSwgZDEsIHIxKSA9IHNwbGl0IHYyIHMxIGluXG4gICAgICAgICAgY29uY2F0X29yX2pvaW4gKG1lcmdlIGYgbDEgbDIpIHYyIChmIHYyIGQxIChTb21lIGQyKSkgKG1lcmdlIGYgcjEgcjIpXG4gICAgICB8IF8gLT5cbiAgICAgICAgICBhc3NlcnQgZmFsc2VcblxuICAgIGxldCByZWMgdW5pb24gZiBzMSBzMiA9XG4gICAgICBtYXRjaCAoczEsIHMyKSB3aXRoXG4gICAgICB8IChFbXB0eSwgcykgfCAocywgRW1wdHkpIC0+IHNcbiAgICAgIHwgKE5vZGUge2w9bDE7IHY9djE7IGQ9ZDE7IHI9cjE7IGg9aDF9LFxuICAgICAgICAgTm9kZSB7bD1sMjsgdj12MjsgZD1kMjsgcj1yMjsgaD1oMn0pIC0+XG4gICAgICAgICAgaWYgaDEgPj0gaDIgdGhlblxuICAgICAgICAgICAgbGV0IChsMiwgZDIsIHIyKSA9IHNwbGl0IHYxIHMyIGluXG4gICAgICAgICAgICBsZXQgbCA9IHVuaW9uIGYgbDEgbDIgYW5kIHIgPSB1bmlvbiBmIHIxIHIyIGluXG4gICAgICAgICAgICBtYXRjaCBkMiB3aXRoXG4gICAgICAgICAgICB8IE5vbmUgLT4gam9pbiBsIHYxIGQxIHJcbiAgICAgICAgICAgIHwgU29tZSBkMiAtPiBjb25jYXRfb3Jfam9pbiBsIHYxIChmIHYxIGQxIGQyKSByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbGV0IChsMSwgZDEsIHIxKSA9IHNwbGl0IHYyIHMxIGluXG4gICAgICAgICAgICBsZXQgbCA9IHVuaW9uIGYgbDEgbDIgYW5kIHIgPSB1bmlvbiBmIHIxIHIyIGluXG4gICAgICAgICAgICBtYXRjaCBkMSB3aXRoXG4gICAgICAgICAgICB8IE5vbmUgLT4gam9pbiBsIHYyIGQyIHJcbiAgICAgICAgICAgIHwgU29tZSBkMSAtPiBjb25jYXRfb3Jfam9pbiBsIHYyIChmIHYyIGQxIGQyKSByXG5cbiAgICBsZXQgcmVjIGZpbHRlciBwID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gRW1wdHlcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gYXMgbSAtPlxuICAgICAgICAgICgqIGNhbGwgW3BdIGluIHRoZSBleHBlY3RlZCBsZWZ0LXRvLXJpZ2h0IG9yZGVyICopXG4gICAgICAgICAgbGV0IGwnID0gZmlsdGVyIHAgbCBpblxuICAgICAgICAgIGxldCBwdmQgPSBwIHYgZCBpblxuICAgICAgICAgIGxldCByJyA9IGZpbHRlciBwIHIgaW5cbiAgICAgICAgICBpZiBwdmQgdGhlbiBpZiBsPT1sJyAmJiByPT1yJyB0aGVuIG0gZWxzZSBqb2luIGwnIHYgZCByJ1xuICAgICAgICAgIGVsc2UgY29uY2F0IGwnIHInXG5cbiAgICBsZXQgcmVjIGZpbHRlcl9tYXAgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IEVtcHR5XG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgKCogY2FsbCBbZl0gaW4gdGhlIGV4cGVjdGVkIGxlZnQtdG8tcmlnaHQgb3JkZXIgKilcbiAgICAgICAgICBsZXQgbCcgPSBmaWx0ZXJfbWFwIGYgbCBpblxuICAgICAgICAgIGxldCBmdmQgPSBmIHYgZCBpblxuICAgICAgICAgIGxldCByJyA9IGZpbHRlcl9tYXAgZiByIGluXG4gICAgICAgICAgYmVnaW4gbWF0Y2ggZnZkIHdpdGhcbiAgICAgICAgICAgIHwgU29tZSBkJyAtPiBqb2luIGwnIHYgZCcgcidcbiAgICAgICAgICAgIHwgTm9uZSAtPiBjb25jYXQgbCcgcidcbiAgICAgICAgICBlbmRcblxuICAgIGxldCByZWMgcGFydGl0aW9uIHAgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiAoRW1wdHksIEVtcHR5KVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgICgqIGNhbGwgW3BdIGluIHRoZSBleHBlY3RlZCBsZWZ0LXRvLXJpZ2h0IG9yZGVyICopXG4gICAgICAgICAgbGV0IChsdCwgbGYpID0gcGFydGl0aW9uIHAgbCBpblxuICAgICAgICAgIGxldCBwdmQgPSBwIHYgZCBpblxuICAgICAgICAgIGxldCAocnQsIHJmKSA9IHBhcnRpdGlvbiBwIHIgaW5cbiAgICAgICAgICBpZiBwdmRcbiAgICAgICAgICB0aGVuIChqb2luIGx0IHYgZCBydCwgY29uY2F0IGxmIHJmKVxuICAgICAgICAgIGVsc2UgKGNvbmNhdCBsdCBydCwgam9pbiBsZiB2IGQgcmYpXG5cbiAgICB0eXBlICdhIGVudW1lcmF0aW9uID0gRW5kIHwgTW9yZSBvZiBrZXkgKiAnYSAqICdhIHQgKiAnYSBlbnVtZXJhdGlvblxuXG4gICAgbGV0IHJlYyBjb25zX2VudW0gbSBlID1cbiAgICAgIG1hdGNoIG0gd2l0aFxuICAgICAgICBFbXB0eSAtPiBlXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+IGNvbnNfZW51bSBsIChNb3JlKHYsIGQsIHIsIGUpKVxuXG4gICAgbGV0IGNvbXBhcmUgY21wIG0xIG0yID1cbiAgICAgIGxldCByZWMgY29tcGFyZV9hdXggZTEgZTIgPVxuICAgICAgICAgIG1hdGNoIChlMSwgZTIpIHdpdGhcbiAgICAgICAgICAoRW5kLCBFbmQpIC0+IDBcbiAgICAgICAgfCAoRW5kLCBfKSAgLT4gLTFcbiAgICAgICAgfCAoXywgRW5kKSAtPiAxXG4gICAgICAgIHwgKE1vcmUodjEsIGQxLCByMSwgZTEpLCBNb3JlKHYyLCBkMiwgcjIsIGUyKSkgLT5cbiAgICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgdjEgdjIgaW5cbiAgICAgICAgICAgIGlmIGMgPD4gMCB0aGVuIGMgZWxzZVxuICAgICAgICAgICAgbGV0IGMgPSBjbXAgZDEgZDIgaW5cbiAgICAgICAgICAgIGlmIGMgPD4gMCB0aGVuIGMgZWxzZVxuICAgICAgICAgICAgY29tcGFyZV9hdXggKGNvbnNfZW51bSByMSBlMSkgKGNvbnNfZW51bSByMiBlMilcbiAgICAgIGluIGNvbXBhcmVfYXV4IChjb25zX2VudW0gbTEgRW5kKSAoY29uc19lbnVtIG0yIEVuZClcblxuICAgIGxldCBlcXVhbCBjbXAgbTEgbTIgPVxuICAgICAgbGV0IHJlYyBlcXVhbF9hdXggZTEgZTIgPVxuICAgICAgICAgIG1hdGNoIChlMSwgZTIpIHdpdGhcbiAgICAgICAgICAoRW5kLCBFbmQpIC0+IHRydWVcbiAgICAgICAgfCAoRW5kLCBfKSAgLT4gZmFsc2VcbiAgICAgICAgfCAoXywgRW5kKSAtPiBmYWxzZVxuICAgICAgICB8IChNb3JlKHYxLCBkMSwgcjEsIGUxKSwgTW9yZSh2MiwgZDIsIHIyLCBlMikpIC0+XG4gICAgICAgICAgICBPcmQuY29tcGFyZSB2MSB2MiA9IDAgJiYgY21wIGQxIGQyICYmXG4gICAgICAgICAgICBlcXVhbF9hdXggKGNvbnNfZW51bSByMSBlMSkgKGNvbnNfZW51bSByMiBlMilcbiAgICAgIGluIGVxdWFsX2F1eCAoY29uc19lbnVtIG0xIEVuZCkgKGNvbnNfZW51bSBtMiBFbmQpXG5cbiAgICBsZXQgcmVjIGNhcmRpbmFsID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gMFxuICAgICAgfCBOb2RlIHtsOyByfSAtPiBjYXJkaW5hbCBsICsgMSArIGNhcmRpbmFsIHJcblxuICAgIGxldCByZWMgYmluZGluZ3NfYXV4IGFjY3UgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBhY2N1XG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+IGJpbmRpbmdzX2F1eCAoKHYsIGQpIDo6IGJpbmRpbmdzX2F1eCBhY2N1IHIpIGxcblxuICAgIGxldCBiaW5kaW5ncyBzID1cbiAgICAgIGJpbmRpbmdzX2F1eCBbXSBzXG5cbiAgICBsZXQgY2hvb3NlID0gbWluX2JpbmRpbmdcblxuICAgIGxldCBjaG9vc2Vfb3B0ID0gbWluX2JpbmRpbmdfb3B0XG5cbiAgICBsZXQgYWRkX3NlcSBpIG0gPVxuICAgICAgU2VxLmZvbGRfbGVmdCAoZnVuIG0gKGssdikgLT4gYWRkIGsgdiBtKSBtIGlcblxuICAgIGxldCBvZl9zZXEgaSA9IGFkZF9zZXEgaSBlbXB0eVxuXG4gICAgbGV0IHJlYyBzZXFfb2ZfZW51bV8gYyAoKSA9IG1hdGNoIGMgd2l0aFxuICAgICAgfCBFbmQgLT4gU2VxLk5pbFxuICAgICAgfCBNb3JlIChrLHYsdCxyZXN0KSAtPiBTZXEuQ29ucyAoKGssdiksIHNlcV9vZl9lbnVtXyAoY29uc19lbnVtIHQgcmVzdCkpXG5cbiAgICBsZXQgdG9fc2VxIG0gPVxuICAgICAgc2VxX29mX2VudW1fIChjb25zX2VudW0gbSBFbmQpXG5cbiAgICBsZXQgcmVjIHNub2NfZW51bSBzIGUgPVxuICAgICAgbWF0Y2ggcyB3aXRoXG4gICAgICAgIEVtcHR5IC0+IGVcbiAgICAgIHwgTm9kZXtsOyB2OyBkOyByfSAtPiBzbm9jX2VudW0gciAoTW9yZSh2LCBkLCBsLCBlKSlcblxuICAgIGxldCByZWMgcmV2X3NlcV9vZl9lbnVtXyBjICgpID0gbWF0Y2ggYyB3aXRoXG4gICAgICB8IEVuZCAtPiBTZXEuTmlsXG4gICAgICB8IE1vcmUgKGssdix0LHJlc3QpIC0+XG4gICAgICAgICAgU2VxLkNvbnMgKChrLHYpLCByZXZfc2VxX29mX2VudW1fIChzbm9jX2VudW0gdCByZXN0KSlcblxuICAgIGxldCB0b19yZXZfc2VxIGMgPVxuICAgICAgcmV2X3NlcV9vZl9lbnVtXyAoc25vY19lbnVtIGMgRW5kKVxuXG4gICAgbGV0IHRvX3NlcV9mcm9tIGxvdyBtID1cbiAgICAgIGxldCByZWMgYXV4IGxvdyBtIGMgPSBtYXRjaCBtIHdpdGhcbiAgICAgICAgfCBFbXB0eSAtPiBjXG4gICAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcjsgX30gLT5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIE9yZC5jb21wYXJlIHYgbG93IHdpdGhcbiAgICAgICAgICAgICAgfCAwIC0+IE1vcmUgKHYsIGQsIHIsIGMpXG4gICAgICAgICAgICAgIHwgbiB3aGVuIG48MCAtPiBhdXggbG93IHIgY1xuICAgICAgICAgICAgICB8IF8gLT4gYXV4IGxvdyBsIChNb3JlICh2LCBkLCByLCBjKSlcbiAgICAgICAgICAgIGVuZFxuICAgICAgaW5cbiAgICAgIHNlcV9vZl9lbnVtXyAoYXV4IGxvdyBtIEVuZClcbmVuZFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlICdhIHQgPSB7IG11dGFibGUgYyA6ICdhIGxpc3Q7IG11dGFibGUgbGVuIDogaW50OyB9XG5cbmV4Y2VwdGlvbiBFbXB0eVxuXG5sZXQgY3JlYXRlICgpID0geyBjID0gW107IGxlbiA9IDA7IH1cblxubGV0IGNsZWFyIHMgPSBzLmMgPC0gW107IHMubGVuIDwtIDBcblxubGV0IGNvcHkgcyA9IHsgYyA9IHMuYzsgbGVuID0gcy5sZW47IH1cblxubGV0IHB1c2ggeCBzID0gcy5jIDwtIHggOjogcy5jOyBzLmxlbiA8LSBzLmxlbiArIDFcblxubGV0IHBvcCBzID1cbiAgbWF0Y2ggcy5jIHdpdGhcbiAgfCBoZDo6dGwgLT4gcy5jIDwtIHRsOyBzLmxlbiA8LSBzLmxlbiAtIDE7IGhkXG4gIHwgW10gICAgIC0+IHJhaXNlIEVtcHR5XG5cbmxldCBwb3Bfb3B0IHMgPVxuICBtYXRjaCBzLmMgd2l0aFxuICB8IGhkOjp0bCAtPiBzLmMgPC0gdGw7IHMubGVuIDwtIHMubGVuIC0gMTsgU29tZSBoZFxuICB8IFtdICAgICAtPiBOb25lXG5cbmxldCB0b3AgcyA9XG4gIG1hdGNoIHMuYyB3aXRoXG4gIHwgaGQ6Ol8gLT4gaGRcbiAgfCBbXSAgICAtPiByYWlzZSBFbXB0eVxuXG5sZXQgdG9wX29wdCBzID1cbiAgbWF0Y2ggcy5jIHdpdGhcbiAgfCBoZDo6XyAtPiBTb21lIGhkXG4gIHwgW10gICAgLT4gTm9uZVxuXG5sZXQgaXNfZW1wdHkgcyA9IChzLmMgPSBbXSlcblxubGV0IGxlbmd0aCBzID0gcy5sZW5cblxubGV0IGl0ZXIgZiBzID0gTGlzdC5pdGVyIGYgcy5jXG5cbmxldCBmb2xkIGYgYWNjIHMgPSBMaXN0LmZvbGRfbGVmdCBmIGFjYyBzLmNcblxuKCoqIHsxIEl0ZXJhdG9yc30gKilcblxubGV0IHRvX3NlcSBzID0gTGlzdC50b19zZXEgcy5jXG5cbmxldCBhZGRfc2VxIHEgaSA9IFNlcS5pdGVyIChmdW4geCAtPiBwdXNoIHggcSkgaVxuXG5sZXQgb2Zfc2VxIGcgPVxuICBsZXQgcyA9IGNyZWF0ZSgpIGluXG4gIGFkZF9zZXEgcyBnO1xuICBzXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgIEZyYW5jb2lzIFBvdHRpZXIsIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgIEplcmVtaWUgRGltaW5vLCBKYW5lIFN0cmVldCBFdXJvcGUgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDAyIEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbmV4Y2VwdGlvbiBFbXB0eVxuXG50eXBlICdhIGNlbGwgPVxuICB8IE5pbFxuICB8IENvbnMgb2YgeyBjb250ZW50OiAnYTsgbXV0YWJsZSBuZXh0OiAnYSBjZWxsIH1cblxudHlwZSAnYSB0ID0ge1xuICBtdXRhYmxlIGxlbmd0aDogaW50O1xuICBtdXRhYmxlIGZpcnN0OiAnYSBjZWxsO1xuICBtdXRhYmxlIGxhc3Q6ICdhIGNlbGxcbn1cblxubGV0IGNyZWF0ZSAoKSA9IHtcbiAgbGVuZ3RoID0gMDtcbiAgZmlyc3QgPSBOaWw7XG4gIGxhc3QgPSBOaWxcbn1cblxubGV0IGNsZWFyIHEgPVxuICBxLmxlbmd0aCA8LSAwO1xuICBxLmZpcnN0IDwtIE5pbDtcbiAgcS5sYXN0IDwtIE5pbFxuXG5sZXQgYWRkIHggcSA9XG4gIGxldCBjZWxsID0gQ29ucyB7XG4gICAgY29udGVudCA9IHg7XG4gICAgbmV4dCA9IE5pbFxuICB9IGluXG4gIG1hdGNoIHEubGFzdCB3aXRoXG4gIHwgTmlsIC0+XG4gICAgcS5sZW5ndGggPC0gMTtcbiAgICBxLmZpcnN0IDwtIGNlbGw7XG4gICAgcS5sYXN0IDwtIGNlbGxcbiAgfCBDb25zIGxhc3QgLT5cbiAgICBxLmxlbmd0aCA8LSBxLmxlbmd0aCArIDE7XG4gICAgbGFzdC5uZXh0IDwtIGNlbGw7XG4gICAgcS5sYXN0IDwtIGNlbGxcblxubGV0IHB1c2ggPVxuICBhZGRcblxubGV0IHBlZWsgcSA9XG4gIG1hdGNoIHEuZmlyc3Qgd2l0aFxuICB8IE5pbCAtPiByYWlzZSBFbXB0eVxuICB8IENvbnMgeyBjb250ZW50IH0gLT4gY29udGVudFxuXG5sZXQgcGVla19vcHQgcSA9XG4gIG1hdGNoIHEuZmlyc3Qgd2l0aFxuICB8IE5pbCAtPiBOb25lXG4gIHwgQ29ucyB7IGNvbnRlbnQgfSAtPiBTb21lIGNvbnRlbnRcblxubGV0IHRvcCA9XG4gIHBlZWtcblxubGV0IHRha2UgcSA9XG4gIG1hdGNoIHEuZmlyc3Qgd2l0aFxuICB8IE5pbCAtPiByYWlzZSBFbXB0eVxuICB8IENvbnMgeyBjb250ZW50OyBuZXh0ID0gTmlsIH0gLT5cbiAgICBjbGVhciBxO1xuICAgIGNvbnRlbnRcbiAgfCBDb25zIHsgY29udGVudDsgbmV4dCB9IC0+XG4gICAgcS5sZW5ndGggPC0gcS5sZW5ndGggLSAxO1xuICAgIHEuZmlyc3QgPC0gbmV4dDtcbiAgICBjb250ZW50XG5cbmxldCB0YWtlX29wdCBxID1cbiAgbWF0Y2ggcS5maXJzdCB3aXRoXG4gIHwgTmlsIC0+IE5vbmVcbiAgfCBDb25zIHsgY29udGVudDsgbmV4dCA9IE5pbCB9IC0+XG4gICAgY2xlYXIgcTtcbiAgICBTb21lIGNvbnRlbnRcbiAgfCBDb25zIHsgY29udGVudDsgbmV4dCB9IC0+XG4gICAgcS5sZW5ndGggPC0gcS5sZW5ndGggLSAxO1xuICAgIHEuZmlyc3QgPC0gbmV4dDtcbiAgICBTb21lIGNvbnRlbnRcblxubGV0IHBvcCA9XG4gIHRha2VcblxubGV0IGNvcHkgPVxuICBsZXQgcmVjIGNvcHkgcV9yZXMgcHJldiBjZWxsID1cbiAgICBtYXRjaCBjZWxsIHdpdGhcbiAgICB8IE5pbCAtPiBxX3Jlcy5sYXN0IDwtIHByZXY7IHFfcmVzXG4gICAgfCBDb25zIHsgY29udGVudDsgbmV4dCB9IC0+XG4gICAgICBsZXQgcmVzID0gQ29ucyB7IGNvbnRlbnQ7IG5leHQgPSBOaWwgfSBpblxuICAgICAgYmVnaW4gbWF0Y2ggcHJldiB3aXRoXG4gICAgICB8IE5pbCAtPiBxX3Jlcy5maXJzdCA8LSByZXNcbiAgICAgIHwgQ29ucyBwIC0+IHAubmV4dCA8LSByZXNcbiAgICAgIGVuZDtcbiAgICAgIGNvcHkgcV9yZXMgcmVzIG5leHRcbiAgaW5cbiAgZnVuIHEgLT4gY29weSB7IGxlbmd0aCA9IHEubGVuZ3RoOyBmaXJzdCA9IE5pbDsgbGFzdCA9IE5pbCB9IE5pbCBxLmZpcnN0XG5cbmxldCBpc19lbXB0eSBxID1cbiAgcS5sZW5ndGggPSAwXG5cbmxldCBsZW5ndGggcSA9XG4gIHEubGVuZ3RoXG5cbmxldCBpdGVyID1cbiAgbGV0IHJlYyBpdGVyIGYgY2VsbCA9XG4gICAgbWF0Y2ggY2VsbCB3aXRoXG4gICAgfCBOaWwgLT4gKClcbiAgICB8IENvbnMgeyBjb250ZW50OyBuZXh0IH0gLT5cbiAgICAgIGYgY29udGVudDtcbiAgICAgIGl0ZXIgZiBuZXh0XG4gIGluXG4gIGZ1biBmIHEgLT4gaXRlciBmIHEuZmlyc3RcblxubGV0IGZvbGQgPVxuICBsZXQgcmVjIGZvbGQgZiBhY2N1IGNlbGwgPVxuICAgIG1hdGNoIGNlbGwgd2l0aFxuICAgIHwgTmlsIC0+IGFjY3VcbiAgICB8IENvbnMgeyBjb250ZW50OyBuZXh0IH0gLT5cbiAgICAgIGxldCBhY2N1ID0gZiBhY2N1IGNvbnRlbnQgaW5cbiAgICAgIGZvbGQgZiBhY2N1IG5leHRcbiAgaW5cbiAgZnVuIGYgYWNjdSBxIC0+IGZvbGQgZiBhY2N1IHEuZmlyc3RcblxubGV0IHRyYW5zZmVyIHExIHEyID1cbiAgaWYgcTEubGVuZ3RoID4gMCB0aGVuXG4gICAgbWF0Y2ggcTIubGFzdCB3aXRoXG4gICAgfCBOaWwgLT5cbiAgICAgIHEyLmxlbmd0aCA8LSBxMS5sZW5ndGg7XG4gICAgICBxMi5maXJzdCA8LSBxMS5maXJzdDtcbiAgICAgIHEyLmxhc3QgPC0gcTEubGFzdDtcbiAgICAgIGNsZWFyIHExXG4gICAgfCBDb25zIGxhc3QgLT5cbiAgICAgIHEyLmxlbmd0aCA8LSBxMi5sZW5ndGggKyBxMS5sZW5ndGg7XG4gICAgICBsYXN0Lm5leHQgPC0gcTEuZmlyc3Q7XG4gICAgICBxMi5sYXN0IDwtIHExLmxhc3Q7XG4gICAgICBjbGVhciBxMVxuXG4oKiogezEgSXRlcmF0b3JzfSAqKVxuXG5sZXQgdG9fc2VxIHEgPVxuICBsZXQgcmVjIGF1eCBjICgpID0gbWF0Y2ggYyB3aXRoXG4gICAgfCBOaWwgLT4gU2VxLk5pbFxuICAgIHwgQ29ucyB7IGNvbnRlbnQ9eDsgbmV4dDsgfSAtPiBTZXEuQ29ucyAoeCwgYXV4IG5leHQpXG4gIGluXG4gIGF1eCBxLmZpcnN0XG5cbmxldCBhZGRfc2VxIHEgaSA9IFNlcS5pdGVyIChmdW4geCAtPiBwdXNoIHggcSkgaVxuXG5sZXQgb2Zfc2VxIGcgPVxuICBsZXQgcSA9IGNyZWF0ZSgpIGluXG4gIGFkZF9zZXEgcSBnO1xuICBxXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBEYW1pZW4gRG9saWdleiwgcHJvamV0IFBhcmEsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk3IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIEludGVybmFscyBvZiBmb3JjaW5nIGxhenkgdmFsdWVzLiAqKVxuXG50eXBlICdhIHQgPSAnYSBsYXp5X3RcblxuZXhjZXB0aW9uIFVuZGVmaW5lZFxuXG5sZXQgcmFpc2VfdW5kZWZpbmVkID0gT2JqLnJlcHIgKGZ1biAoKSAtPiByYWlzZSBVbmRlZmluZWQpXG5cbmV4dGVybmFsIG1ha2VfZm9yd2FyZCA6IE9iai50IC0+IE9iai50IC0+IHVuaXQgPSBcImNhbWxfb2JqX21ha2VfZm9yd2FyZFwiXG5cbigqIEFzc3VtZSBbYmxrXSBpcyBhIGJsb2NrIHdpdGggdGFnIGxhenkgKilcbmxldCBmb3JjZV9sYXp5X2Jsb2NrIChibGsgOiAnYXJnIGxhenlfdCkgPVxuICBsZXQgY2xvc3VyZSA9IChPYmoub2JqIChPYmouZmllbGQgKE9iai5yZXByIGJsaykgMCkgOiB1bml0IC0+ICdhcmcpIGluXG4gIE9iai5zZXRfZmllbGQgKE9iai5yZXByIGJsaykgMCByYWlzZV91bmRlZmluZWQ7XG4gIHRyeVxuICAgIGxldCByZXN1bHQgPSBjbG9zdXJlICgpIGluXG4gICAgbWFrZV9mb3J3YXJkIChPYmoucmVwciBibGspIChPYmoucmVwciByZXN1bHQpO1xuICAgIHJlc3VsdFxuICB3aXRoIGUgLT5cbiAgICBPYmouc2V0X2ZpZWxkIChPYmoucmVwciBibGspIDAgKE9iai5yZXByIChmdW4gKCkgLT4gcmFpc2UgZSkpO1xuICAgIHJhaXNlIGVcblxuXG4oKiBBc3N1bWUgW2Jsa10gaXMgYSBibG9jayB3aXRoIHRhZyBsYXp5ICopXG5sZXQgZm9yY2VfdmFsX2xhenlfYmxvY2sgKGJsayA6ICdhcmcgbGF6eV90KSA9XG4gIGxldCBjbG9zdXJlID0gKE9iai5vYmogKE9iai5maWVsZCAoT2JqLnJlcHIgYmxrKSAwKSA6IHVuaXQgLT4gJ2FyZykgaW5cbiAgT2JqLnNldF9maWVsZCAoT2JqLnJlcHIgYmxrKSAwIHJhaXNlX3VuZGVmaW5lZDtcbiAgbGV0IHJlc3VsdCA9IGNsb3N1cmUgKCkgaW5cbiAgbWFrZV9mb3J3YXJkIChPYmoucmVwciBibGspIChPYmoucmVwciByZXN1bHQpO1xuICByZXN1bHRcblxuXG4oKiBbZm9yY2VdIGlzIG5vdCB1c2VkLCBzaW5jZSBbTGF6eS5mb3JjZV0gaXMgZGVjbGFyZWQgYXMgYSBwcmltaXRpdmVcbiAgIHdob3NlIGNvZGUgaW5saW5lcyB0aGUgdGFnIHRlc3RzIG9mIGl0cyBhcmd1bWVudCwgZXhjZXB0IHdoZW4gYWZsXG4gICBpbnN0cnVtZW50YXRpb24gaXMgdHVybmVkIG9uLiAqKVxuXG5sZXQgZm9yY2UgKGx6diA6ICdhcmcgbGF6eV90KSA9XG4gICgqIFVzaW5nIFtTeXMub3BhcXVlX2lkZW50aXR5XSBwcmV2ZW50cyB0d28gcG90ZW50aWFsIHByb2JsZW1zOlxuICAgICAtIElmIHRoZSB2YWx1ZSBpcyBrbm93biB0byBoYXZlIEZvcndhcmRfdGFnLCB0aGVuIGl0cyB0YWcgY291bGQgaGF2ZVxuICAgICAgIGNoYW5nZWQgZHVyaW5nIEdDLCBzbyB0aGF0IGluZm9ybWF0aW9uIG11c3QgYmUgZm9yZ290dGVuIChzZWUgR1BSIzcxM1xuICAgICAgIGFuZCBpc3N1ZSAjNzMwMSlcbiAgICAgLSBJZiB0aGUgdmFsdWUgaXMga25vd24gdG8gYmUgaW1tdXRhYmxlLCB0aGVuIGlmIHRoZSBjb21waWxlclxuICAgICAgIGNhbm5vdCBwcm92ZSB0aGF0IHRoZSBsYXN0IGJyYW5jaCBpcyBub3QgdGFrZW4gaXQgd2lsbCBpc3N1ZSBhXG4gICAgICAgd2FybmluZyA1OSAobW9kaWZpY2F0aW9uIG9mIGFuIGltbXV0YWJsZSB2YWx1ZSkgKilcbiAgbGV0IGx6diA9IFN5cy5vcGFxdWVfaWRlbnRpdHkgbHp2IGluXG4gIGxldCB4ID0gT2JqLnJlcHIgbHp2IGluXG4gIGxldCB0ID0gT2JqLnRhZyB4IGluXG4gIGlmIHQgPSBPYmouZm9yd2FyZF90YWcgdGhlbiAoT2JqLm9iaiAoT2JqLmZpZWxkIHggMCkgOiAnYXJnKSBlbHNlXG4gIGlmIHQgPD4gT2JqLmxhenlfdGFnIHRoZW4gKE9iai5vYmogeCA6ICdhcmcpXG4gIGVsc2UgZm9yY2VfbGF6eV9ibG9jayBsenZcblxuXG5sZXQgZm9yY2VfdmFsIChsenYgOiAnYXJnIGxhenlfdCkgPVxuICBsZXQgeCA9IE9iai5yZXByIGx6diBpblxuICBsZXQgdCA9IE9iai50YWcgeCBpblxuICBpZiB0ID0gT2JqLmZvcndhcmRfdGFnIHRoZW4gKE9iai5vYmogKE9iai5maWVsZCB4IDApIDogJ2FyZykgZWxzZVxuICBpZiB0IDw+IE9iai5sYXp5X3RhZyB0aGVuIChPYmoub2JqIHggOiAnYXJnKVxuICBlbHNlIGZvcmNlX3ZhbF9sYXp5X2Jsb2NrIGx6dlxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgRGFtaWVuIERvbGlnZXosIHByb2pldCBQYXJhLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NyBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBNb2R1bGUgW0xhenldOiBkZWZlcnJlZCBjb21wdXRhdGlvbnMgKilcblxuXG4oKlxuICAgV0FSTklORzogc29tZSBwdXJwbGUgbWFnaWMgaXMgZ29pbmcgb24gaGVyZS4gIERvIG5vdCB0YWtlIHRoaXMgZmlsZVxuICAgYXMgYW4gZXhhbXBsZSBvZiBob3cgdG8gcHJvZ3JhbSBpbiBPQ2FtbC5cbiopXG5cblxuKCogV2UgbWFrZSB1c2Ugb2YgdHdvIHNwZWNpYWwgdGFncyBwcm92aWRlZCBieSB0aGUgcnVudGltZTpcbiAgIFtsYXp5X3RhZ10gYW5kIFtmb3J3YXJkX3RhZ10uXG5cbiAgIEEgdmFsdWUgb2YgdHlwZSBbJ2EgTGF6eS50XSBjYW4gYmUgb25lIG9mIHRocmVlIHRoaW5nczpcbiAgIDEuIEEgYmxvY2sgb2Ygc2l6ZSAxIHdpdGggdGFnIFtsYXp5X3RhZ10uICBJdHMgZmllbGQgaXMgYSBjbG9zdXJlIG9mXG4gICAgICB0eXBlIFt1bml0IC0+ICdhXSB0aGF0IGNvbXB1dGVzIHRoZSB2YWx1ZS5cbiAgIDIuIEEgYmxvY2sgb2Ygc2l6ZSAxIHdpdGggdGFnIFtmb3J3YXJkX3RhZ10uICBJdHMgZmllbGQgaXMgdGhlIHZhbHVlXG4gICAgICBvZiB0eXBlIFsnYV0gdGhhdCB3YXMgY29tcHV0ZWQuXG4gICAzLiBBbnl0aGluZyBlbHNlIGV4Y2VwdCBhIGZsb2F0LiAgVGhpcyBoYXMgdHlwZSBbJ2FdIGFuZCBpcyB0aGUgdmFsdWVcbiAgICAgIHRoYXQgd2FzIGNvbXB1dGVkLlxuICAgRXhjZXB0aW9ucyBhcmUgc3RvcmVkIGluIGZvcm1hdCAoMSkuXG4gICBUaGUgR0Mgd2lsbCBtYWdpY2FsbHkgY2hhbmdlIHRoaW5ncyBmcm9tICgyKSB0byAoMykgYWNjb3JkaW5nIHRvIGl0c1xuICAgZmFuY3kuXG5cbiAgIElmIE9DYW1sIHdhcyBjb25maWd1cmVkIHdpdGggdGhlIC1mbGF0LWZsb2F0LWFycmF5IG9wdGlvbiAod2hpY2ggaXNcbiAgIGN1cnJlbnRseSB0aGUgZGVmYXVsdCksIHRoZSBmb2xsb3dpbmcgaXMgYWxzbyB0cnVlOlxuICAgV2UgY2Fubm90IHVzZSByZXByZXNlbnRhdGlvbiAoMykgZm9yIGEgW2Zsb2F0IExhenkudF0gYmVjYXVzZVxuICAgW2NhbWxfbWFrZV9hcnJheV0gYXNzdW1lcyB0aGF0IG9ubHkgYSBbZmxvYXRdIHZhbHVlIGNhbiBoYXZlIHRhZ1xuICAgW0RvdWJsZV90YWddLlxuXG4gICBXZSBoYXZlIHRvIHVzZSB0aGUgYnVpbHQtaW4gdHlwZSBjb25zdHJ1Y3RvciBbbGF6eV90XSB0b1xuICAgbGV0IHRoZSBjb21waWxlciBpbXBsZW1lbnQgdGhlIHNwZWNpYWwgdHlwaW5nIGFuZCBjb21waWxhdGlvblxuICAgcnVsZXMgZm9yIHRoZSBbbGF6eV0ga2V5d29yZC5cbiopXG5cbnR5cGUgJ2EgdCA9ICdhIENhbWxpbnRlcm5hbExhenkudFxuXG5leGNlcHRpb24gVW5kZWZpbmVkID0gQ2FtbGludGVybmFsTGF6eS5VbmRlZmluZWRcblxuZXh0ZXJuYWwgbWFrZV9mb3J3YXJkIDogJ2EgLT4gJ2EgbGF6eV90ID0gXCJjYW1sX2xhenlfbWFrZV9mb3J3YXJkXCJcblxuZXh0ZXJuYWwgZm9yY2UgOiAnYSB0IC0+ICdhID0gXCIlbGF6eV9mb3JjZVwiXG5cbigqIGxldCBmb3JjZSA9IGZvcmNlICopXG5cbmxldCBmb3JjZV92YWwgPSBDYW1saW50ZXJuYWxMYXp5LmZvcmNlX3ZhbFxuXG5sZXQgZnJvbV9mdW4gKGYgOiB1bml0IC0+ICdhcmcpID1cbiAgbGV0IHggPSBPYmoubmV3X2Jsb2NrIE9iai5sYXp5X3RhZyAxIGluXG4gIE9iai5zZXRfZmllbGQgeCAwIChPYmoucmVwciBmKTtcbiAgKE9iai5vYmogeCA6ICdhcmcgdClcblxuXG5sZXQgZnJvbV92YWwgKHYgOiAnYXJnKSA9XG4gIGxldCB0ID0gT2JqLnRhZyAoT2JqLnJlcHIgdikgaW5cbiAgaWYgdCA9IE9iai5mb3J3YXJkX3RhZyB8fCB0ID0gT2JqLmxhenlfdGFnIHx8IHQgPSBPYmouZG91YmxlX3RhZyB0aGVuIGJlZ2luXG4gICAgbWFrZV9mb3J3YXJkIHZcbiAgZW5kIGVsc2UgYmVnaW5cbiAgICAoT2JqLm1hZ2ljIHYgOiAnYXJnIHQpXG4gIGVuZFxuXG5cbmxldCBpc192YWwgKGwgOiAnYXJnIHQpID0gT2JqLnRhZyAoT2JqLnJlcHIgbCkgPD4gT2JqLmxhenlfdGFnXG5cbmxldCBsYXp5X2Zyb21fZnVuID0gZnJvbV9mdW5cblxubGV0IGxhenlfZnJvbV92YWwgPSBmcm9tX3ZhbFxuXG5sZXQgbGF6eV9pc192YWwgPSBpc192YWxcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgRGFuaWVsIGRlIFJhdWdsYXVkcmUsIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTcgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxudHlwZSAnYSB0ID0gJ2EgY2VsbCBvcHRpb25cbmFuZCAnYSBjZWxsID0geyBtdXRhYmxlIGNvdW50IDogaW50OyBtdXRhYmxlIGRhdGEgOiAnYSBkYXRhIH1cbmFuZCAnYSBkYXRhID1cbiAgICBTZW1wdHlcbiAgfCBTY29ucyBvZiAnYSAqICdhIGRhdGFcbiAgfCBTYXBwIG9mICdhIGRhdGEgKiAnYSBkYXRhXG4gIHwgU2xhenkgb2YgJ2EgZGF0YSBMYXp5LnRcbiAgfCBTZ2VuIG9mICdhIGdlblxuICB8IFNidWZmaW8gOiBidWZmaW8gLT4gY2hhciBkYXRhXG5hbmQgJ2EgZ2VuID0geyBtdXRhYmxlIGN1cnIgOiAnYSBvcHRpb24gb3B0aW9uOyBmdW5jIDogaW50IC0+ICdhIG9wdGlvbiB9XG5hbmQgYnVmZmlvID1cbiAgeyBpYyA6IGluX2NoYW5uZWw7IGJ1ZmYgOiBieXRlczsgbXV0YWJsZSBsZW4gOiBpbnQ7IG11dGFibGUgaW5kIDogaW50IH1cblxuZXhjZXB0aW9uIEZhaWx1cmVcbmV4Y2VwdGlvbiBFcnJvciBvZiBzdHJpbmdcblxubGV0IGNvdW50ID0gZnVuY3Rpb25cbiAgfCBOb25lIC0+IDBcbiAgfCBTb21lIHsgY291bnQgfSAtPiBjb3VudFxubGV0IGRhdGEgPSBmdW5jdGlvblxuICB8IE5vbmUgLT4gU2VtcHR5XG4gIHwgU29tZSB7IGRhdGEgfSAtPiBkYXRhXG5cbmxldCBmaWxsX2J1ZmYgYiA9XG4gIGIubGVuIDwtIGlucHV0IGIuaWMgYi5idWZmIDAgKEJ5dGVzLmxlbmd0aCBiLmJ1ZmYpOyBiLmluZCA8LSAwXG5cblxubGV0IHJlYyBnZXRfZGF0YSA6IHR5cGUgdi4gaW50IC0+IHYgZGF0YSAtPiB2IGRhdGEgPSBmdW4gY291bnQgZCAtPiBtYXRjaCBkIHdpdGhcbiAoKiBSZXR1cm5zIGVpdGhlciBTZW1wdHkgb3IgU2NvbnMoYSwgXykgZXZlbiB3aGVuIGQgaXMgYSBnZW5lcmF0b3JcbiAgICBvciBhIGJ1ZmZlci4gSW4gdGhvc2UgY2FzZXMsIHRoZSBpdGVtIGEgaXMgc2VlbiBhcyBleHRyYWN0ZWQgZnJvbVxuIHRoZSBnZW5lcmF0b3IvYnVmZmVyLlxuIFRoZSBjb3VudCBwYXJhbWV0ZXIgaXMgdXNlZCBmb3IgY2FsbGluZyBgU2dlbi1mdW5jdGlvbnMnLiAgKilcbiAgIFNlbXB0eSB8IFNjb25zIChfLCBfKSAtPiBkXG4gfCBTYXBwIChkMSwgZDIpIC0+XG4gICAgIGJlZ2luIG1hdGNoIGdldF9kYXRhIGNvdW50IGQxIHdpdGhcbiAgICAgICBTY29ucyAoYSwgZDExKSAtPiBTY29ucyAoYSwgU2FwcCAoZDExLCBkMikpXG4gICAgIHwgU2VtcHR5IC0+IGdldF9kYXRhIGNvdW50IGQyXG4gICAgIHwgXyAtPiBhc3NlcnQgZmFsc2VcbiAgICAgZW5kXG4gfCBTZ2VuIHtjdXJyID0gU29tZSBOb25lfSAtPiBTZW1wdHlcbiB8IFNnZW4gKHtjdXJyID0gU29tZShTb21lIGEpfSBhcyBnKSAtPlxuICAgICBnLmN1cnIgPC0gTm9uZTsgU2NvbnMoYSwgZClcbiB8IFNnZW4gZyAtPlxuICAgICBiZWdpbiBtYXRjaCBnLmZ1bmMgY291bnQgd2l0aFxuICAgICAgIE5vbmUgLT4gZy5jdXJyIDwtIFNvbWUoTm9uZSk7IFNlbXB0eVxuICAgICB8IFNvbWUgYSAtPiBTY29ucyhhLCBkKVxuICAgICAgICAgKCogV2FybmluZzogYW55b25lIHVzaW5nIGcgdGhpbmtzIHRoYXQgYW4gaXRlbSBoYXMgYmVlbiByZWFkICopXG4gICAgIGVuZFxuIHwgU2J1ZmZpbyBiIC0+XG4gICAgIGlmIGIuaW5kID49IGIubGVuIHRoZW4gZmlsbF9idWZmIGI7XG4gICAgIGlmIGIubGVuID09IDAgdGhlbiBTZW1wdHkgZWxzZVxuICAgICAgIGxldCByID0gQnl0ZXMudW5zYWZlX2dldCBiLmJ1ZmYgYi5pbmQgaW5cbiAgICAgICAoKiBXYXJuaW5nOiBhbnlvbmUgdXNpbmcgZyB0aGlua3MgdGhhdCBhbiBpdGVtIGhhcyBiZWVuIHJlYWQgKilcbiAgICAgICBiLmluZCA8LSBzdWNjIGIuaW5kOyBTY29ucyhyLCBkKVxuIHwgU2xhenkgZiAtPiBnZXRfZGF0YSBjb3VudCAoTGF6eS5mb3JjZSBmKVxuXG5cbmxldCByZWMgcGVla19kYXRhIDogdHlwZSB2LiB2IGNlbGwgLT4gdiBvcHRpb24gPSBmdW4gcyAtPlxuICgqIGNvbnN1bHQgdGhlIGZpcnN0IGl0ZW0gb2YgcyAqKVxuIG1hdGNoIHMuZGF0YSB3aXRoXG4gICBTZW1wdHkgLT4gTm9uZVxuIHwgU2NvbnMgKGEsIF8pIC0+IFNvbWUgYVxuIHwgU2FwcCAoXywgXykgLT5cbiAgICAgYmVnaW4gbWF0Y2ggZ2V0X2RhdGEgcy5jb3VudCBzLmRhdGEgd2l0aFxuICAgICAgIFNjb25zKGEsIF8pIGFzIGQgLT4gcy5kYXRhIDwtIGQ7IFNvbWUgYVxuICAgICB8IFNlbXB0eSAtPiBOb25lXG4gICAgIHwgXyAtPiBhc3NlcnQgZmFsc2VcbiAgICAgZW5kXG4gfCBTbGF6eSBmIC0+IHMuZGF0YSA8LSAoTGF6eS5mb3JjZSBmKTsgcGVla19kYXRhIHNcbiB8IFNnZW4ge2N1cnIgPSBTb21lIGF9IC0+IGFcbiB8IFNnZW4gZyAtPiBsZXQgeCA9IGcuZnVuYyBzLmNvdW50IGluIGcuY3VyciA8LSBTb21lIHg7IHhcbiB8IFNidWZmaW8gYiAtPlxuICAgICBpZiBiLmluZCA+PSBiLmxlbiB0aGVuIGZpbGxfYnVmZiBiO1xuICAgICBpZiBiLmxlbiA9PSAwIHRoZW4gYmVnaW4gcy5kYXRhIDwtIFNlbXB0eTsgTm9uZSBlbmRcbiAgICAgZWxzZSBTb21lIChCeXRlcy51bnNhZmVfZ2V0IGIuYnVmZiBiLmluZClcblxuXG5sZXQgcGVlayA9IGZ1bmN0aW9uXG4gIHwgTm9uZSAtPiBOb25lXG4gIHwgU29tZSBzIC0+IHBlZWtfZGF0YSBzXG5cblxubGV0IHJlYyBqdW5rX2RhdGEgOiB0eXBlIHYuIHYgY2VsbCAtPiB1bml0ID0gZnVuIHMgLT5cbiAgbWF0Y2ggcy5kYXRhIHdpdGhcbiAgICBTY29ucyAoXywgZCkgLT4gcy5jb3VudCA8LSAoc3VjYyBzLmNvdW50KTsgcy5kYXRhIDwtIGRcbiAgfCBTZ2VuICh7Y3VyciA9IFNvbWUgX30gYXMgZykgLT4gcy5jb3VudCA8LSAoc3VjYyBzLmNvdW50KTsgZy5jdXJyIDwtIE5vbmVcbiAgfCBTYnVmZmlvIGIgLT5cbiAgICAgIGlmIGIuaW5kID49IGIubGVuIHRoZW4gZmlsbF9idWZmIGI7XG4gICAgICBpZiBiLmxlbiA9PSAwIHRoZW4gcy5kYXRhIDwtIFNlbXB0eVxuICAgICAgZWxzZSAocy5jb3VudCA8LSAoc3VjYyBzLmNvdW50KTsgYi5pbmQgPC0gc3VjYyBiLmluZClcbiAgfCBfIC0+XG4gICAgICBtYXRjaCBwZWVrX2RhdGEgcyB3aXRoXG4gICAgICAgIE5vbmUgLT4gKClcbiAgICAgIHwgU29tZSBfIC0+IGp1bmtfZGF0YSBzXG5cblxubGV0IGp1bmsgPSBmdW5jdGlvblxuICB8IE5vbmUgLT4gKClcbiAgfCBTb21lIGRhdGEgLT4ganVua19kYXRhIGRhdGFcblxubGV0IHJlYyBuZ2V0X2RhdGEgbiBzID1cbiAgaWYgbiA8PSAwIHRoZW4gW10sIHMuZGF0YSwgMFxuICBlbHNlXG4gICAgbWF0Y2ggcGVla19kYXRhIHMgd2l0aFxuICAgICAgU29tZSBhIC0+XG4gICAgICAgIGp1bmtfZGF0YSBzO1xuICAgICAgICBsZXQgKGFsLCBkLCBrKSA9IG5nZXRfZGF0YSAocHJlZCBuKSBzIGluIGEgOjogYWwsIFNjb25zIChhLCBkKSwgc3VjYyBrXG4gICAgfCBOb25lIC0+IFtdLCBzLmRhdGEsIDBcblxuXG5sZXQgbnBlZWtfZGF0YSBuIHMgPVxuICBsZXQgKGFsLCBkLCBsZW4pID0gbmdldF9kYXRhIG4gcyBpblxuICBzLmNvdW50IDwtIChzLmNvdW50IC0gbGVuKTtcbiAgcy5kYXRhIDwtIGQ7XG4gIGFsXG5cblxubGV0IG5wZWVrIG4gPSBmdW5jdGlvblxuICB8IE5vbmUgLT4gW11cbiAgfCBTb21lIGQgLT4gbnBlZWtfZGF0YSBuIGRcblxubGV0IG5leHQgcyA9XG4gIG1hdGNoIHBlZWsgcyB3aXRoXG4gICAgU29tZSBhIC0+IGp1bmsgczsgYVxuICB8IE5vbmUgLT4gcmFpc2UgRmFpbHVyZVxuXG5cbmxldCBlbXB0eSBzID1cbiAgbWF0Y2ggcGVlayBzIHdpdGhcbiAgICBTb21lIF8gLT4gcmFpc2UgRmFpbHVyZVxuICB8IE5vbmUgLT4gKClcblxuXG5sZXQgaXRlciBmIHN0cm0gPVxuICBsZXQgcmVjIGRvX3JlYyAoKSA9XG4gICAgbWF0Y2ggcGVlayBzdHJtIHdpdGhcbiAgICAgIFNvbWUgYSAtPiBqdW5rIHN0cm07IGlnbm9yZShmIGEpOyBkb19yZWMgKClcbiAgICB8IE5vbmUgLT4gKClcbiAgaW5cbiAgZG9fcmVjICgpXG5cblxuKCogU3RyZWFtIGJ1aWxkaW5nIGZ1bmN0aW9ucyAqKVxuXG5sZXQgZnJvbSBmID0gU29tZSB7Y291bnQgPSAwOyBkYXRhID0gU2dlbiB7Y3VyciA9IE5vbmU7IGZ1bmMgPSBmfX1cblxubGV0IG9mX2xpc3QgbCA9XG4gIFNvbWUge2NvdW50ID0gMDsgZGF0YSA9IExpc3QuZm9sZF9yaWdodCAoZnVuIHggbCAtPiBTY29ucyAoeCwgbCkpIGwgU2VtcHR5fVxuXG5cbmxldCBvZl9zdHJpbmcgcyA9XG4gIGxldCBjb3VudCA9IHJlZiAwIGluXG4gIGZyb20gKGZ1biBfIC0+XG4gICAgKCogV2UgY2Fubm90IHVzZSB0aGUgaW5kZXggcGFzc2VkIGJ5IHRoZSBbZnJvbV0gZnVuY3Rpb24gZGlyZWN0bHlcbiAgICAgICBiZWNhdXNlIGl0IHJldHVybnMgdGhlIGN1cnJlbnQgc3RyZWFtIGNvdW50LCB3aXRoIGFic29sdXRlbHkgbm9cbiAgICAgICBndWFyYW50ZWUgdGhhdCBpdCB3aWxsIHN0YXJ0IGZyb20gMC4gRm9yIGV4YW1wbGUsIGluIHRoZSBjYXNlXG4gICAgICAgb2YgW1N0cmVhbS5pY29ucyAnYycgKFN0cmVhbS5mcm9tX3N0cmluZyBcImFiXCIpXSwgdGhlIGZpcnN0XG4gICAgICAgYWNjZXNzIHRvIHRoZSBzdHJpbmcgd2lsbCBiZSBtYWRlIHdpdGggY291bnQgWzFdIGFscmVhZHkuXG4gICAgKilcbiAgICBsZXQgYyA9ICFjb3VudCBpblxuICAgIGlmIGMgPCBTdHJpbmcubGVuZ3RoIHNcbiAgICB0aGVuIChpbmNyIGNvdW50OyBTb21lIHMuW2NdKVxuICAgIGVsc2UgTm9uZSlcblxuXG5sZXQgb2ZfYnl0ZXMgcyA9XG4gIGxldCBjb3VudCA9IHJlZiAwIGluXG4gIGZyb20gKGZ1biBfIC0+XG4gICAgbGV0IGMgPSAhY291bnQgaW5cbiAgICBpZiBjIDwgQnl0ZXMubGVuZ3RoIHNcbiAgICB0aGVuIChpbmNyIGNvdW50OyBTb21lIChCeXRlcy5nZXQgcyBjKSlcbiAgICBlbHNlIE5vbmUpXG5cblxubGV0IG9mX2NoYW5uZWwgaWMgPVxuICBTb21lIHtjb3VudCA9IDA7XG4gICAgICAgIGRhdGEgPSBTYnVmZmlvIHtpYyA9IGljOyBidWZmID0gQnl0ZXMuY3JlYXRlIDQwOTY7IGxlbiA9IDA7IGluZCA9IDB9fVxuXG5cbigqIFN0cmVhbSBleHByZXNzaW9ucyBidWlsZGVycyAqKVxuXG5sZXQgaWFwcCBpIHMgPSBTb21lIHtjb3VudCA9IDA7IGRhdGEgPSBTYXBwIChkYXRhIGksIGRhdGEgcyl9XG5sZXQgaWNvbnMgaSBzID0gU29tZSB7Y291bnQgPSAwOyBkYXRhID0gU2NvbnMgKGksIGRhdGEgcyl9XG5sZXQgaXNpbmcgaSA9IFNvbWUge2NvdW50ID0gMDsgZGF0YSA9IFNjb25zIChpLCBTZW1wdHkpfVxuXG5sZXQgbGFwcCBmIHMgPVxuICBTb21lIHtjb3VudCA9IDA7IGRhdGEgPSBTbGF6eSAobGF6eShTYXBwIChkYXRhIChmICgpKSwgZGF0YSBzKSkpfVxuXG5sZXQgbGNvbnMgZiBzID0gU29tZSB7Y291bnQgPSAwOyBkYXRhID0gU2xhenkgKGxhenkoU2NvbnMgKGYgKCksIGRhdGEgcykpKX1cbmxldCBsc2luZyBmID0gU29tZSB7Y291bnQgPSAwOyBkYXRhID0gU2xhenkgKGxhenkoU2NvbnMgKGYgKCksIFNlbXB0eSkpKX1cblxubGV0IHNlbXB0eSA9IE5vbmVcbmxldCBzbGF6eSBmID0gU29tZSB7Y291bnQgPSAwOyBkYXRhID0gU2xhenkgKGxhenkoZGF0YSAoZiAoKSkpKX1cblxuKCogRm9yIGRlYnVnZ2luZyB1c2UgKilcblxubGV0IHJlYyBkdW1wIDogdHlwZSB2LiAodiAtPiB1bml0KSAtPiB2IHQgLT4gdW5pdCA9IGZ1biBmIHMgLT5cbiAgcHJpbnRfc3RyaW5nIFwie2NvdW50ID0gXCI7XG4gIHByaW50X2ludCAoY291bnQgcyk7XG4gIHByaW50X3N0cmluZyBcIjsgZGF0YSA9IFwiO1xuICBkdW1wX2RhdGEgZiAoZGF0YSBzKTtcbiAgcHJpbnRfc3RyaW5nIFwifVwiO1xuICBwcmludF9uZXdsaW5lICgpXG5hbmQgZHVtcF9kYXRhIDogdHlwZSB2LiAodiAtPiB1bml0KSAtPiB2IGRhdGEgLT4gdW5pdCA9IGZ1biBmIC0+XG4gIGZ1bmN0aW9uXG4gICAgU2VtcHR5IC0+IHByaW50X3N0cmluZyBcIlNlbXB0eVwiXG4gIHwgU2NvbnMgKGEsIGQpIC0+XG4gICAgICBwcmludF9zdHJpbmcgXCJTY29ucyAoXCI7XG4gICAgICBmIGE7XG4gICAgICBwcmludF9zdHJpbmcgXCIsIFwiO1xuICAgICAgZHVtcF9kYXRhIGYgZDtcbiAgICAgIHByaW50X3N0cmluZyBcIilcIlxuICB8IFNhcHAgKGQxLCBkMikgLT5cbiAgICAgIHByaW50X3N0cmluZyBcIlNhcHAgKFwiO1xuICAgICAgZHVtcF9kYXRhIGYgZDE7XG4gICAgICBwcmludF9zdHJpbmcgXCIsIFwiO1xuICAgICAgZHVtcF9kYXRhIGYgZDI7XG4gICAgICBwcmludF9zdHJpbmcgXCIpXCJcbiAgfCBTbGF6eSBfIC0+IHByaW50X3N0cmluZyBcIlNsYXp5XCJcbiAgfCBTZ2VuIF8gLT4gcHJpbnRfc3RyaW5nIFwiU2dlblwiXG4gIHwgU2J1ZmZpbyBfIC0+IHByaW50X3N0cmluZyBcIlNidWZmaW9cIlxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgUGllcnJlIFdlaXMgYW5kIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5OSBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBFeHRlbnNpYmxlIGJ1ZmZlcnMgKilcblxudHlwZSB0ID1cbiB7bXV0YWJsZSBidWZmZXIgOiBieXRlcztcbiAgbXV0YWJsZSBwb3NpdGlvbiA6IGludDtcbiAgbXV0YWJsZSBsZW5ndGggOiBpbnQ7XG4gIGluaXRpYWxfYnVmZmVyIDogYnl0ZXN9XG4oKiBJbnZhcmlhbnRzOiBhbGwgcGFydHMgb2YgdGhlIGNvZGUgcHJlc2VydmUgdGhlIGludmFyaWFudHMgdGhhdDpcbiAgIC0gWzAgPD0gYi5wb3NpdGlvbiA8PSBiLmxlbmd0aF1cbiAgIC0gW2IubGVuZ3RoID0gQnl0ZXMubGVuZ3RoIGIuYnVmZmVyXVxuXG4gICBOb3RlIGluIHBhcnRpY3VsYXIgdGhhdCBbYi5wb3NpdGlvbiA9IGIubGVuZ3RoXSBpcyBsZWdhbCxcbiAgIGl0IG1lYW5zIHRoYXQgdGhlIGJ1ZmZlciBpcyBmdWxsIGFuZCB3aWxsIGhhdmUgdG8gYmUgZXh0ZW5kZWRcbiAgIGJlZm9yZSBhbnkgZnVydGhlciBhZGRpdGlvbi4gKilcblxubGV0IGNyZWF0ZSBuID1cbiBsZXQgbiA9IGlmIG4gPCAxIHRoZW4gMSBlbHNlIG4gaW5cbiBsZXQgbiA9IGlmIG4gPiBTeXMubWF4X3N0cmluZ19sZW5ndGggdGhlbiBTeXMubWF4X3N0cmluZ19sZW5ndGggZWxzZSBuIGluXG4gbGV0IHMgPSBCeXRlcy5jcmVhdGUgbiBpblxuIHtidWZmZXIgPSBzOyBwb3NpdGlvbiA9IDA7IGxlbmd0aCA9IG47IGluaXRpYWxfYnVmZmVyID0gc31cblxubGV0IGNvbnRlbnRzIGIgPSBCeXRlcy5zdWJfc3RyaW5nIGIuYnVmZmVyIDAgYi5wb3NpdGlvblxubGV0IHRvX2J5dGVzIGIgPSBCeXRlcy5zdWIgYi5idWZmZXIgMCBiLnBvc2l0aW9uXG5cbmxldCBzdWIgYiBvZnMgbGVuID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IGIucG9zaXRpb24gLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIkJ1ZmZlci5zdWJcIlxuICBlbHNlIEJ5dGVzLnN1Yl9zdHJpbmcgYi5idWZmZXIgb2ZzIGxlblxuXG5cbmxldCBibGl0IHNyYyBzcmNvZmYgZHN0IGRzdG9mZiBsZW4gPVxuICBpZiBsZW4gPCAwIHx8IHNyY29mZiA8IDAgfHwgc3Jjb2ZmID4gc3JjLnBvc2l0aW9uIC0gbGVuXG4gICAgICAgICAgICAgfHwgZHN0b2ZmIDwgMCB8fCBkc3RvZmYgPiAoQnl0ZXMubGVuZ3RoIGRzdCkgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIkJ1ZmZlci5ibGl0XCJcbiAgZWxzZVxuICAgIEJ5dGVzLnVuc2FmZV9ibGl0IHNyYy5idWZmZXIgc3Jjb2ZmIGRzdCBkc3RvZmYgbGVuXG5cblxubGV0IG50aCBiIG9mcyA9XG4gIGlmIG9mcyA8IDAgfHwgb2ZzID49IGIucG9zaXRpb24gdGhlblxuICAgaW52YWxpZF9hcmcgXCJCdWZmZXIubnRoXCJcbiAgZWxzZSBCeXRlcy51bnNhZmVfZ2V0IGIuYnVmZmVyIG9mc1xuXG5cbmxldCBsZW5ndGggYiA9IGIucG9zaXRpb25cblxubGV0IGNsZWFyIGIgPSBiLnBvc2l0aW9uIDwtIDBcblxubGV0IHJlc2V0IGIgPVxuICBiLnBvc2l0aW9uIDwtIDA7XG4gIGIuYnVmZmVyIDwtIGIuaW5pdGlhbF9idWZmZXI7XG4gIGIubGVuZ3RoIDwtIEJ5dGVzLmxlbmd0aCBiLmJ1ZmZlclxuXG4oKiBbcmVzaXplIGIgbW9yZV0gZW5zdXJlcyB0aGF0IFtiLnBvc2l0aW9uICsgbW9yZSA8PSBiLmxlbmd0aF0gaG9sZHNcbiAgIGJ5IGR5bmFtaWNhbGx5IGV4dGVuZGluZyBbYi5idWZmZXJdIGlmIG5lY2Vzc2FyeSAtLSBhbmQgdGh1c1xuICAgaW5jcmVhc2luZyBbYi5sZW5ndGhdLlxuXG4gICBJbiBwYXJ0aWN1bGFyLCBhZnRlciBbcmVzaXplIGIgbW9yZV0gaXMgY2FsbGVkLCBhIGRpcmVjdCBhY2Nlc3Mgb2ZcbiAgIHNpemUgW21vcmVdIGF0IFtiLnBvc2l0aW9uXSB3aWxsIGFsd2F5cyBiZSBpbi1ib3VuZHMsIHNvIHRoYXRcbiAgICh1bnNhZmVfe2dldCxzZXR9KSBtYXkgYmUgdXNlZCBmb3IgcGVyZm9ybWFuY2UuXG4qKVxubGV0IHJlc2l6ZSBiIG1vcmUgPVxuICBsZXQgb2xkX3BvcyA9IGIucG9zaXRpb24gaW5cbiAgbGV0IG9sZF9sZW4gPSBiLmxlbmd0aCBpblxuICBsZXQgbmV3X2xlbiA9IHJlZiBvbGRfbGVuIGluXG4gIHdoaWxlIG9sZF9wb3MgKyBtb3JlID4gIW5ld19sZW4gZG8gbmV3X2xlbiA6PSAyICogIW5ld19sZW4gZG9uZTtcbiAgaWYgIW5ld19sZW4gPiBTeXMubWF4X3N0cmluZ19sZW5ndGggdGhlbiBiZWdpblxuICAgIGlmIG9sZF9wb3MgKyBtb3JlIDw9IFN5cy5tYXhfc3RyaW5nX2xlbmd0aFxuICAgIHRoZW4gbmV3X2xlbiA6PSBTeXMubWF4X3N0cmluZ19sZW5ndGhcbiAgICBlbHNlIGZhaWx3aXRoIFwiQnVmZmVyLmFkZDogY2Fubm90IGdyb3cgYnVmZmVyXCJcbiAgZW5kO1xuICBsZXQgbmV3X2J1ZmZlciA9IEJ5dGVzLmNyZWF0ZSAhbmV3X2xlbiBpblxuICAoKiBQUiM2MTQ4OiBsZXQncyBrZWVwIHVzaW5nIFtibGl0XSByYXRoZXIgdGhhbiBbdW5zYWZlX2JsaXRdIGluXG4gICAgIHRoaXMgdHJpY2t5IGZ1bmN0aW9uIHRoYXQgaXMgc2xvdyBhbnl3YXkuICopXG4gIEJ5dGVzLmJsaXQgYi5idWZmZXIgMCBuZXdfYnVmZmVyIDAgYi5wb3NpdGlvbjtcbiAgYi5idWZmZXIgPC0gbmV3X2J1ZmZlcjtcbiAgYi5sZW5ndGggPC0gIW5ld19sZW47XG4gIGFzc2VydCAoYi5wb3NpdGlvbiArIG1vcmUgPD0gYi5sZW5ndGgpO1xuICBhc3NlcnQgKG9sZF9wb3MgKyBtb3JlIDw9IGIubGVuZ3RoKTtcbiAgKClcbiAgKCogTm90ZTogdGhlcmUgYXJlIHZhcmlvdXMgc2l0dWF0aW9ucyAocHJlZW1wdGl2ZSB0aHJlYWRzLCBzaWduYWxzIGFuZFxuICAgICBnYyBmaW5hbGl6ZXJzKSB3aGVyZSBPQ2FtbCBjb2RlIG1heSBiZSBydW4gYXN5bmNocm9ub3VzbHk7IGluXG4gICAgIHBhcnRpY3VsYXIsIHRoZXJlIG1heSBiZSBhIHJhY2Ugd2l0aCBhbm90aGVyIHVzZXIgb2YgW2JdLCBjaGFuZ2luZ1xuICAgICBpdHMgbXV0YWJsZSBmaWVsZHMgaW4gdGhlIG1pZGRsZSBvZiB0aGUgW3Jlc2l6ZV0gY2FsbC4gVGhlIEJ1ZmZlclxuICAgICBtb2R1bGUgZG9lcyBub3QgcHJvdmlkZSBhbnkgY29ycmVjdG5lc3MgZ3VhcmFudGVlIGlmIHRoYXQgaGFwcGVucyxcbiAgICAgYnV0IHdlIG11c3Qgc3RpbGwgZW5zdXJlIHRoYXQgdGhlIGRhdGFzdHJ1Y3R1cmUgaW52YXJpYW50cyBob2xkIGZvclxuICAgICBtZW1vcnktc2FmZXR5IC0tIGFzIHdlIHBsYW4gdG8gdXNlIFt1bnNhZmVfe2dldCxzZXR9XS5cblxuICAgICBUaGVyZSBhcmUgdHdvIHBvdGVudGlhbCBhbGxvY2F0aW9uIHBvaW50cyBpbiB0aGlzIGZ1bmN0aW9uLFxuICAgICBbcmVmXSBhbmQgW0J5dGVzLmNyZWF0ZV0sIGJ1dCBhbGwgcmVhZHMgYW5kIHdyaXRlcyB0byB0aGUgZmllbGRzXG4gICAgIG9mIFtiXSBoYXBwZW4gYmVmb3JlIGJvdGggb2YgdGhlbSBvciBhZnRlciBib3RoIG9mIHRoZW0uXG5cbiAgICAgV2UgdGhlcmVmb3JlIGFzc3VtZSB0aGF0IFtiLnBvc2l0aW9uXSBtYXkgY2hhbmdlIGF0IHRoZXNlIGFsbG9jYXRpb25zLFxuICAgICBhbmQgY2hlY2sgdGhhdCB0aGUgW2IucG9zaXRpb24gKyBtb3JlIDw9IGIubGVuZ3RoXSBwb3N0Y29uZGl0aW9uXG4gICAgIGhvbGRzIGZvciBib3RoIHZhbHVlcyBvZiBbYi5wb3NpdGlvbl0sIGJlZm9yZSBvciBhZnRlciB0aGUgZnVuY3Rpb25cbiAgICAgaXMgY2FsbGVkLiBNb3JlIHByZWNpc2VseSwgdGhlIGZvbGxvd2luZyBpbnZhcmlhbnRzIG11c3QgaG9sZCBpZiB0aGVcbiAgICAgZnVuY3Rpb24gcmV0dXJucyBjb3JyZWN0bHksIGluIGFkZGl0aW9uIHRvIHRoZSB1c3VhbCBidWZmZXIgaW52YXJpYW50czpcbiAgICAgLSBbb2xkKGIucG9zaXRpb24pICsgbW9yZSA8PSBuZXcoYi5sZW5ndGgpXVxuICAgICAtIFtuZXcoYi5wb3NpdGlvbikgKyBtb3JlIDw9IG5ldyhiLmxlbmd0aCldXG4gICAgIC0gW29sZChiLmxlbmd0aCkgPD0gbmV3KGIubGVuZ3RoKV1cblxuICAgICBOb3RlOiBbYi5wb3NpdGlvbiArIG1vcmUgPD0gb2xkKGIubGVuZ3RoKV0gZG9lcyAqbm90KlxuICAgICBob2xkIGluIGdlbmVyYWwsIGFzIGl0IGlzIHByZWNpc2VseSB0aGUgY2FzZSB3aGVyZSB5b3UgbmVlZFxuICAgICB0byBjYWxsIFtyZXNpemVdIHRvIGluY3JlYXNlIFtiLmxlbmd0aF0uXG5cbiAgICAgTm90ZTogW2Fzc2VydF0gYWJvdmUgZG9lcyBub3QgbWVhbiB0aGF0IHdlIGtub3cgdGhlIGNvbmRpdGlvbnNcbiAgICAgYWx3YXlzIGhvbGQsIGJ1dCB0aGF0IHRoZSBmdW5jdGlvbiBtYXkgcmV0dXJuIGNvcnJlY3RseVxuICAgICBvbmx5IGlmIHRoZXkgaG9sZC5cblxuICAgICBOb3RlOiB0aGUgb3RoZXIgZnVuY3Rpb25zIGluIHRoaXMgbW9kdWxlIGRvZXMgbm90IG5lZWRcbiAgICAgdG8gYmUgY2hlY2tlZCB3aXRoIHRoaXMgbGV2ZWwgb2Ygc2NydXRpbnksIGdpdmVuIHRoYXQgdGhleVxuICAgICByZWFkL3dyaXRlIHRoZSBidWZmZXIgaW1tZWRpYXRlbHkgYWZ0ZXIgY2hlY2tpbmcgdGhhdFxuICAgICBbYi5wb3NpdGlvbiArIG1vcmUgPD0gYi5sZW5ndGhdIGhvbGQgb3IgY2FsbGluZyBbcmVzaXplXS5cbiAgKilcblxubGV0IGFkZF9jaGFyIGIgYyA9XG4gIGxldCBwb3MgPSBiLnBvc2l0aW9uIGluXG4gIGlmIHBvcyA+PSBiLmxlbmd0aCB0aGVuIHJlc2l6ZSBiIDE7XG4gIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgcG9zIGM7XG4gIGIucG9zaXRpb24gPC0gcG9zICsgMVxuXG4gbGV0IGFkZF91dGZfOF91Y2hhciBiIHUgPSBtYXRjaCBVY2hhci50b19pbnQgdSB3aXRoXG4gfCB1IHdoZW4gdSA8IDAgLT4gYXNzZXJ0IGZhbHNlXG4gfCB1IHdoZW4gdSA8PSAweDAwN0YgLT5cbiAgICAgYWRkX2NoYXIgYiAoQ2hhci51bnNhZmVfY2hyIHUpXG4gfCB1IHdoZW4gdSA8PSAweDA3RkYgLT5cbiAgICAgbGV0IHBvcyA9IGIucG9zaXRpb24gaW5cbiAgICAgaWYgcG9zICsgMiA+IGIubGVuZ3RoIHRoZW4gcmVzaXplIGIgMjtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICAgIClcbiAgICAgICAoQ2hhci51bnNhZmVfY2hyICgweEMwIGxvciAodSBsc3IgNikpKTtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICsgMSlcbiAgICAgICAoQ2hhci51bnNhZmVfY2hyICgweDgwIGxvciAodSBsYW5kIDB4M0YpKSk7XG4gICAgIGIucG9zaXRpb24gPC0gcG9zICsgMlxuIHwgdSB3aGVuIHUgPD0gMHhGRkZGIC0+XG4gICAgIGxldCBwb3MgPSBiLnBvc2l0aW9uIGluXG4gICAgIGlmIHBvcyArIDMgPiBiLmxlbmd0aCB0aGVuIHJlc2l6ZSBiIDM7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyAgICApXG4gICAgICAgKENoYXIudW5zYWZlX2NociAoMHhFMCBsb3IgKHUgbHNyIDEyKSkpO1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgKyAxKVxuICAgICAgIChDaGFyLnVuc2FmZV9jaHIgKDB4ODAgbG9yICgodSBsc3IgNikgbGFuZCAweDNGKSkpO1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgKyAyKVxuICAgICAgIChDaGFyLnVuc2FmZV9jaHIgKDB4ODAgbG9yICh1IGxhbmQgMHgzRikpKTtcbiAgICAgYi5wb3NpdGlvbiA8LSBwb3MgKyAzXG4gfCB1IHdoZW4gdSA8PSAweDEwRkZGRiAtPlxuICAgICBsZXQgcG9zID0gYi5wb3NpdGlvbiBpblxuICAgICBpZiBwb3MgKyA0ID4gYi5sZW5ndGggdGhlbiByZXNpemUgYiA0O1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgICAgKVxuICAgICAgIChDaGFyLnVuc2FmZV9jaHIgKDB4RjAgbG9yICh1IGxzciAxOCkpKTtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICsgMSlcbiAgICAgICAoQ2hhci51bnNhZmVfY2hyICgweDgwIGxvciAoKHUgbHNyIDEyKSBsYW5kIDB4M0YpKSk7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyArIDIpXG4gICAgICAgKENoYXIudW5zYWZlX2NociAoMHg4MCBsb3IgKCh1IGxzciA2KSBsYW5kIDB4M0YpKSk7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyArIDMpXG4gICAgICAgKENoYXIudW5zYWZlX2NociAoMHg4MCBsb3IgKHUgbGFuZCAweDNGKSkpO1xuICAgICBiLnBvc2l0aW9uIDwtIHBvcyArIDRcbiB8IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiBsZXQgYWRkX3V0Zl8xNmJlX3VjaGFyIGIgdSA9IG1hdGNoIFVjaGFyLnRvX2ludCB1IHdpdGhcbiB8IHUgd2hlbiB1IDwgMCAtPiBhc3NlcnQgZmFsc2VcbiB8IHUgd2hlbiB1IDw9IDB4RkZGRiAtPlxuICAgICBsZXQgcG9zID0gYi5wb3NpdGlvbiBpblxuICAgICBpZiBwb3MgKyAyID4gYi5sZW5ndGggdGhlbiByZXNpemUgYiAyO1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgICAgKSAoQ2hhci51bnNhZmVfY2hyICh1IGxzciA4KSk7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyArIDEpIChDaGFyLnVuc2FmZV9jaHIgKHUgbGFuZCAweEZGKSk7XG4gICAgIGIucG9zaXRpb24gPC0gcG9zICsgMlxuIHwgdSB3aGVuIHUgPD0gMHgxMEZGRkYgLT5cbiAgICAgbGV0IHUnID0gdSAtIDB4MTAwMDAgaW5cbiAgICAgbGV0IGhpID0gMHhEODAwIGxvciAodScgbHNyIDEwKSBpblxuICAgICBsZXQgbG8gPSAweERDMDAgbG9yICh1JyBsYW5kIDB4M0ZGKSBpblxuICAgICBsZXQgcG9zID0gYi5wb3NpdGlvbiBpblxuICAgICBpZiBwb3MgKyA0ID4gYi5sZW5ndGggdGhlbiByZXNpemUgYiA0O1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgICAgKSAoQ2hhci51bnNhZmVfY2hyIChoaSBsc3IgOCkpO1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgKyAxKSAoQ2hhci51bnNhZmVfY2hyIChoaSBsYW5kIDB4RkYpKTtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICsgMikgKENoYXIudW5zYWZlX2NociAobG8gbHNyIDgpKTtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICsgMykgKENoYXIudW5zYWZlX2NociAobG8gbGFuZCAweEZGKSk7XG4gICAgIGIucG9zaXRpb24gPC0gcG9zICsgNFxuIHwgXyAtPiBhc3NlcnQgZmFsc2VcblxuIGxldCBhZGRfdXRmXzE2bGVfdWNoYXIgYiB1ID0gbWF0Y2ggVWNoYXIudG9faW50IHUgd2l0aFxuIHwgdSB3aGVuIHUgPCAwIC0+IGFzc2VydCBmYWxzZVxuIHwgdSB3aGVuIHUgPD0gMHhGRkZGIC0+XG4gICAgIGxldCBwb3MgPSBiLnBvc2l0aW9uIGluXG4gICAgIGlmIHBvcyArIDIgPiBiLmxlbmd0aCB0aGVuIHJlc2l6ZSBiIDI7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyAgICApIChDaGFyLnVuc2FmZV9jaHIgKHUgbGFuZCAweEZGKSk7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyArIDEpIChDaGFyLnVuc2FmZV9jaHIgKHUgbHNyIDgpKTtcbiAgICAgYi5wb3NpdGlvbiA8LSBwb3MgKyAyXG4gfCB1IHdoZW4gdSA8PSAweDEwRkZGRiAtPlxuICAgICBsZXQgdScgPSB1IC0gMHgxMDAwMCBpblxuICAgICBsZXQgaGkgPSAweEQ4MDAgbG9yICh1JyBsc3IgMTApIGluXG4gICAgIGxldCBsbyA9IDB4REMwMCBsb3IgKHUnIGxhbmQgMHgzRkYpIGluXG4gICAgIGxldCBwb3MgPSBiLnBvc2l0aW9uIGluXG4gICAgIGlmIHBvcyArIDQgPiBiLmxlbmd0aCB0aGVuIHJlc2l6ZSBiIDQ7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyAgICApIChDaGFyLnVuc2FmZV9jaHIgKGhpIGxhbmQgMHhGRikpO1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgKyAxKSAoQ2hhci51bnNhZmVfY2hyIChoaSBsc3IgOCkpO1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgKyAyKSAoQ2hhci51bnNhZmVfY2hyIChsbyBsYW5kIDB4RkYpKTtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICsgMykgKENoYXIudW5zYWZlX2NociAobG8gbHNyIDgpKTtcbiAgICAgYi5wb3NpdGlvbiA8LSBwb3MgKyA0XG4gfCBfIC0+IGFzc2VydCBmYWxzZVxuXG5sZXQgYWRkX3N1YnN0cmluZyBiIHMgb2Zmc2V0IGxlbiA9XG4gIGlmIG9mZnNldCA8IDAgfHwgbGVuIDwgMCB8fCBvZmZzZXQgPiBTdHJpbmcubGVuZ3RoIHMgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIkJ1ZmZlci5hZGRfc3Vic3RyaW5nL2FkZF9zdWJieXRlc1wiO1xuICBsZXQgbmV3X3Bvc2l0aW9uID0gYi5wb3NpdGlvbiArIGxlbiBpblxuICBpZiBuZXdfcG9zaXRpb24gPiBiLmxlbmd0aCB0aGVuIHJlc2l6ZSBiIGxlbjtcbiAgQnl0ZXMudW5zYWZlX2JsaXRfc3RyaW5nIHMgb2Zmc2V0IGIuYnVmZmVyIGIucG9zaXRpb24gbGVuO1xuICBiLnBvc2l0aW9uIDwtIG5ld19wb3NpdGlvblxuXG5sZXQgYWRkX3N1YmJ5dGVzIGIgcyBvZmZzZXQgbGVuID1cbiAgYWRkX3N1YnN0cmluZyBiIChCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHMpIG9mZnNldCBsZW5cblxubGV0IGFkZF9zdHJpbmcgYiBzID1cbiAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggcyBpblxuICBsZXQgbmV3X3Bvc2l0aW9uID0gYi5wb3NpdGlvbiArIGxlbiBpblxuICBpZiBuZXdfcG9zaXRpb24gPiBiLmxlbmd0aCB0aGVuIHJlc2l6ZSBiIGxlbjtcbiAgQnl0ZXMudW5zYWZlX2JsaXRfc3RyaW5nIHMgMCBiLmJ1ZmZlciBiLnBvc2l0aW9uIGxlbjtcbiAgYi5wb3NpdGlvbiA8LSBuZXdfcG9zaXRpb25cblxubGV0IGFkZF9ieXRlcyBiIHMgPSBhZGRfc3RyaW5nIGIgKEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcylcblxubGV0IGFkZF9idWZmZXIgYiBicyA9XG4gIGFkZF9zdWJieXRlcyBiIGJzLmJ1ZmZlciAwIGJzLnBvc2l0aW9uXG5cbigqIHRoaXMgKHByaXZhdGUpIGZ1bmN0aW9uIGNvdWxkIG1vdmUgaW50byB0aGUgc3RhbmRhcmQgbGlicmFyeSAqKVxubGV0IHJlYWxseV9pbnB1dF91cF90byBpYyBidWYgb2ZzIGxlbiA9XG4gIGxldCByZWMgbG9vcCBpYyBidWYgfmFscmVhZHlfcmVhZCB+b2ZzIH50b19yZWFkID1cbiAgICBpZiB0b19yZWFkID0gMCB0aGVuIGFscmVhZHlfcmVhZFxuICAgIGVsc2UgYmVnaW5cbiAgICAgIGxldCByID0gaW5wdXQgaWMgYnVmIG9mcyB0b19yZWFkIGluXG4gICAgICBpZiByID0gMCB0aGVuIGFscmVhZHlfcmVhZFxuICAgICAgZWxzZSBiZWdpblxuICAgICAgICBsZXQgYWxyZWFkeV9yZWFkID0gYWxyZWFkeV9yZWFkICsgciBpblxuICAgICAgICBsZXQgb2ZzID0gb2ZzICsgciBpblxuICAgICAgICBsZXQgdG9fcmVhZCA9IHRvX3JlYWQgLSByIGluXG4gICAgICAgIGxvb3AgaWMgYnVmIH5hbHJlYWR5X3JlYWQgfm9mcyB+dG9fcmVhZFxuICAgICAgZW5kXG4gICAgZW5kXG4gIGluIGxvb3AgaWMgYnVmIH5hbHJlYWR5X3JlYWQ6MCB+b2ZzIH50b19yZWFkOmxlblxuXG5cbmxldCB1bnNhZmVfYWRkX2NoYW5uZWxfdXBfdG8gYiBpYyBsZW4gPVxuICBpZiBiLnBvc2l0aW9uICsgbGVuID4gYi5sZW5ndGggdGhlbiByZXNpemUgYiBsZW47XG4gIGxldCBuID0gcmVhbGx5X2lucHV0X3VwX3RvIGljIGIuYnVmZmVyIGIucG9zaXRpb24gbGVuIGluXG4gICgqIFRoZSBhc3NlcnRpb24gYmVsb3cgbWF5IGZhaWwgaW4gd2VpcmQgc2NlbmFyaW8gd2hlcmVcbiAgICAgdGhyZWFkZWQvZmluYWxpemVyIGNvZGUsIHJ1biBhc3luY2hyb25vdXNseSBkdXJpbmcgdGhlXG4gICAgIFtyZWFsbHlfaW5wdXRfdXBfdG9dIGNhbGwsIHJhY2VzIG9uIHRoZSBidWZmZXI7IHdlIGRvbid0IGVuc3VyZVxuICAgICBjb3JyZWN0bmVzcyBpbiB0aGlzIGNhc2UsIGJ1dCBuZWVkIHRvIHByZXNlcnZlIHRoZSBpbnZhcmlhbnRzIGZvclxuICAgICBtZW1vcnktc2FmZXR5IChzZWUgZGlzY3Vzc2lvbiBvZiBbcmVzaXplXSkuICopXG4gIGFzc2VydCAoYi5wb3NpdGlvbiArIG4gPD0gYi5sZW5ndGgpO1xuICBiLnBvc2l0aW9uIDwtIGIucG9zaXRpb24gKyBuO1xuICBuXG5cbmxldCBhZGRfY2hhbm5lbCBiIGljIGxlbiA9XG4gIGlmIGxlbiA8IDAgfHwgbGVuID4gU3lzLm1heF9zdHJpbmdfbGVuZ3RoIHRoZW4gICAoKiBQUiM1MDA0ICopXG4gICAgaW52YWxpZF9hcmcgXCJCdWZmZXIuYWRkX2NoYW5uZWxcIjtcbiAgbGV0IG4gPSB1bnNhZmVfYWRkX2NoYW5uZWxfdXBfdG8gYiBpYyBsZW4gaW5cbiAgKCogSXQgaXMgaW50ZW50aW9uYWwgdGhhdCBhIGNvbnN1bWVyIGNhdGNoaW5nIEVuZF9vZl9maWxlXG4gICAgIHdpbGwgc2VlIHRoZSBkYXRhIHdyaXR0ZW4gKHNlZSAjNjcxOSwgIzcxMzYpLiAqKVxuICBpZiBuIDwgbGVuIHRoZW4gcmFpc2UgRW5kX29mX2ZpbGU7XG4gICgpXG5cbmxldCBvdXRwdXRfYnVmZmVyIG9jIGIgPVxuICBvdXRwdXQgb2MgYi5idWZmZXIgMCBiLnBvc2l0aW9uXG5cbmxldCBjbG9zaW5nID0gZnVuY3Rpb25cbiAgfCAnKCcgLT4gJyknXG4gIHwgJ3snIC0+ICd9J1xuICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbigqIG9wZW5pbmcgYW5kIGNsb3Npbmc6IG9wZW4gYW5kIGNsb3NlIGNoYXJhY3RlcnMsIHR5cGljYWxseSAoIGFuZCApXG4gICBrOiBiYWxhbmNlIG9mIG9wZW5pbmcgYW5kIGNsb3NpbmcgY2hhcnNcbiAgIHM6IHRoZSBzdHJpbmcgd2hlcmUgd2UgYXJlIHNlYXJjaGluZ1xuICAgc3RhcnQ6IHRoZSBpbmRleCB3aGVyZSB3ZSBzdGFydCB0aGUgc2VhcmNoLiAqKVxubGV0IGFkdmFuY2VfdG9fY2xvc2luZyBvcGVuaW5nIGNsb3NpbmcgayBzIHN0YXJ0ID1cbiAgbGV0IHJlYyBhZHZhbmNlIGsgaSBsaW0gPVxuICAgIGlmIGkgPj0gbGltIHRoZW4gcmFpc2UgTm90X2ZvdW5kIGVsc2VcbiAgICBpZiBzLltpXSA9IG9wZW5pbmcgdGhlbiBhZHZhbmNlIChrICsgMSkgKGkgKyAxKSBsaW0gZWxzZVxuICAgIGlmIHMuW2ldID0gY2xvc2luZyB0aGVuXG4gICAgICBpZiBrID0gMCB0aGVuIGkgZWxzZSBhZHZhbmNlIChrIC0gMSkgKGkgKyAxKSBsaW1cbiAgICBlbHNlIGFkdmFuY2UgayAoaSArIDEpIGxpbSBpblxuICBhZHZhbmNlIGsgc3RhcnQgKFN0cmluZy5sZW5ndGggcylcblxubGV0IGFkdmFuY2VfdG9fbm9uX2FscGhhIHMgc3RhcnQgPVxuICBsZXQgcmVjIGFkdmFuY2UgaSBsaW0gPVxuICAgIGlmIGkgPj0gbGltIHRoZW4gbGltIGVsc2VcbiAgICBtYXRjaCBzLltpXSB3aXRoXG4gICAgfCAnYScgLi4gJ3onIHwgJ0EnIC4uICdaJyB8ICcwJyAuLiAnOScgfCAnXycgLT4gYWR2YW5jZSAoaSArIDEpIGxpbVxuICAgIHwgXyAtPiBpIGluXG4gIGFkdmFuY2Ugc3RhcnQgKFN0cmluZy5sZW5ndGggcylcblxuKCogV2UgYXJlIGp1c3QgYXQgdGhlIGJlZ2lubmluZyBvZiBhbiBpZGVudCBpbiBzLCBzdGFydGluZyBhdCBzdGFydC4gKilcbmxldCBmaW5kX2lkZW50IHMgc3RhcnQgbGltID1cbiAgaWYgc3RhcnQgPj0gbGltIHRoZW4gcmFpc2UgTm90X2ZvdW5kIGVsc2VcbiAgbWF0Y2ggcy5bc3RhcnRdIHdpdGhcbiAgKCogUGFyZW50aGVzaXplZCBpZGVudCA/ICopXG4gIHwgJygnIHwgJ3snIGFzIGMgLT5cbiAgICAgbGV0IG5ld19zdGFydCA9IHN0YXJ0ICsgMSBpblxuICAgICBsZXQgc3RvcCA9IGFkdmFuY2VfdG9fY2xvc2luZyBjIChjbG9zaW5nIGMpIDAgcyBuZXdfc3RhcnQgaW5cbiAgICAgU3RyaW5nLnN1YiBzIG5ld19zdGFydCAoc3RvcCAtIHN0YXJ0IC0gMSksIHN0b3AgKyAxXG4gICgqIFJlZ3VsYXIgaWRlbnQgKilcbiAgfCBfIC0+XG4gICAgIGxldCBzdG9wID0gYWR2YW5jZV90b19ub25fYWxwaGEgcyAoc3RhcnQgKyAxKSBpblxuICAgICBTdHJpbmcuc3ViIHMgc3RhcnQgKHN0b3AgLSBzdGFydCksIHN0b3BcblxuKCogU3Vic3RpdHV0ZSAkaWRlbnQsICQoaWRlbnQpLCBvciAke2lkZW50fSBpbiBzLFxuICAgIGFjY29yZGluZyB0byB0aGUgZnVuY3Rpb24gbWFwcGluZyBmLiAqKVxubGV0IGFkZF9zdWJzdGl0dXRlIGIgZiBzID1cbiAgbGV0IGxpbSA9IFN0cmluZy5sZW5ndGggcyBpblxuICBsZXQgcmVjIHN1YnN0IHByZXZpb3VzIGkgPVxuICAgIGlmIGkgPCBsaW0gdGhlbiBiZWdpblxuICAgICAgbWF0Y2ggcy5baV0gd2l0aFxuICAgICAgfCAnJCcgYXMgY3VycmVudCB3aGVuIHByZXZpb3VzID0gJ1xcXFwnIC0+XG4gICAgICAgICBhZGRfY2hhciBiIGN1cnJlbnQ7XG4gICAgICAgICBzdWJzdCAnICcgKGkgKyAxKVxuICAgICAgfCAnJCcgLT5cbiAgICAgICAgIGxldCBqID0gaSArIDEgaW5cbiAgICAgICAgIGxldCBpZGVudCwgbmV4dF9pID0gZmluZF9pZGVudCBzIGogbGltIGluXG4gICAgICAgICBhZGRfc3RyaW5nIGIgKGYgaWRlbnQpO1xuICAgICAgICAgc3Vic3QgJyAnIG5leHRfaVxuICAgICAgfCBjdXJyZW50IHdoZW4gcHJldmlvdXMgPT0gJ1xcXFwnIC0+XG4gICAgICAgICBhZGRfY2hhciBiICdcXFxcJztcbiAgICAgICAgIGFkZF9jaGFyIGIgY3VycmVudDtcbiAgICAgICAgIHN1YnN0ICcgJyAoaSArIDEpXG4gICAgICB8ICdcXFxcJyBhcyBjdXJyZW50IC0+XG4gICAgICAgICBzdWJzdCBjdXJyZW50IChpICsgMSlcbiAgICAgIHwgY3VycmVudCAtPlxuICAgICAgICAgYWRkX2NoYXIgYiBjdXJyZW50O1xuICAgICAgICAgc3Vic3QgY3VycmVudCAoaSArIDEpXG4gICAgZW5kIGVsc2VcbiAgICBpZiBwcmV2aW91cyA9ICdcXFxcJyB0aGVuIGFkZF9jaGFyIGIgcHJldmlvdXMgaW5cbiAgc3Vic3QgJyAnIDBcblxubGV0IHRydW5jYXRlIGIgbGVuID1cbiAgICBpZiBsZW4gPCAwIHx8IGxlbiA+IGxlbmd0aCBiIHRoZW5cbiAgICAgIGludmFsaWRfYXJnIFwiQnVmZmVyLnRydW5jYXRlXCJcbiAgICBlbHNlXG4gICAgICBiLnBvc2l0aW9uIDwtIGxlblxuXG4oKiogezEgSXRlcmF0b3JzfSAqKVxuXG5sZXQgdG9fc2VxIGIgPVxuICBsZXQgcmVjIGF1eCBpICgpID1cbiAgICAoKiBOb3RlIHRoYXQgYi5wb3NpdGlvbiBpcyBub3QgYSBjb25zdGFudCBhbmQgY2Fubm90IGJlIGxpZnRlZCBvdXQgb2YgYXV4ICopXG4gICAgaWYgaSA+PSBiLnBvc2l0aW9uIHRoZW4gU2VxLk5pbFxuICAgIGVsc2VcbiAgICAgIGxldCB4ID0gQnl0ZXMudW5zYWZlX2dldCBiLmJ1ZmZlciBpIGluXG4gICAgICBTZXEuQ29ucyAoeCwgYXV4IChpKzEpKVxuICBpblxuICBhdXggMFxuXG5sZXQgdG9fc2VxaSBiID1cbiAgbGV0IHJlYyBhdXggaSAoKSA9XG4gICAgKCogTm90ZSB0aGF0IGIucG9zaXRpb24gaXMgbm90IGEgY29uc3RhbnQgYW5kIGNhbm5vdCBiZSBsaWZ0ZWQgb3V0IG9mIGF1eCAqKVxuICAgIGlmIGkgPj0gYi5wb3NpdGlvbiB0aGVuIFNlcS5OaWxcbiAgICBlbHNlXG4gICAgICBsZXQgeCA9IEJ5dGVzLnVuc2FmZV9nZXQgYi5idWZmZXIgaSBpblxuICAgICAgU2VxLkNvbnMgKChpLHgpLCBhdXggKGkrMSkpXG4gIGluXG4gIGF1eCAwXG5cbmxldCBhZGRfc2VxIGIgc2VxID0gU2VxLml0ZXIgKGFkZF9jaGFyIGIpIHNlcVxuXG5sZXQgb2Zfc2VxIGkgPVxuICBsZXQgYiA9IGNyZWF0ZSAzMiBpblxuICBhZGRfc2VxIGIgaTtcbiAgYlxuXG4oKiogezYgQmluYXJ5IGVuY29kaW5nIG9mIGludGVnZXJzfSAqKVxuXG5leHRlcm5hbCB1bnNhZmVfc2V0X2ludDggOiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IHVuaXQgPSBcIiVieXRlc191bnNhZmVfc2V0XCJcbmV4dGVybmFsIHVuc2FmZV9zZXRfaW50MTYgOiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IHVuaXQgPSBcIiVjYW1sX2J5dGVzX3NldDE2dVwiXG5leHRlcm5hbCB1bnNhZmVfc2V0X2ludDMyIDogYnl0ZXMgLT4gaW50IC0+IGludDMyIC0+IHVuaXQgPSBcIiVjYW1sX2J5dGVzX3NldDMydVwiXG5leHRlcm5hbCB1bnNhZmVfc2V0X2ludDY0IDogYnl0ZXMgLT4gaW50IC0+IGludDY0IC0+IHVuaXQgPSBcIiVjYW1sX2J5dGVzX3NldDY0dVwiXG5leHRlcm5hbCBzd2FwMTYgOiBpbnQgLT4gaW50ID0gXCIlYnN3YXAxNlwiXG5leHRlcm5hbCBzd2FwMzIgOiBpbnQzMiAtPiBpbnQzMiA9IFwiJWJzd2FwX2ludDMyXCJcbmV4dGVybmFsIHN3YXA2NCA6IGludDY0IC0+IGludDY0ID0gXCIlYnN3YXBfaW50NjRcIlxuXG5cbmxldCBhZGRfaW50OCBiIHggPVxuICBsZXQgbmV3X3Bvc2l0aW9uID0gYi5wb3NpdGlvbiArIDEgaW5cbiAgaWYgbmV3X3Bvc2l0aW9uID4gYi5sZW5ndGggdGhlbiByZXNpemUgYiAxO1xuICB1bnNhZmVfc2V0X2ludDggYi5idWZmZXIgYi5wb3NpdGlvbiB4O1xuICBiLnBvc2l0aW9uIDwtIG5ld19wb3NpdGlvblxuXG5sZXQgYWRkX2ludDE2X25lIGIgeCA9XG4gIGxldCBuZXdfcG9zaXRpb24gPSBiLnBvc2l0aW9uICsgMiBpblxuICBpZiBuZXdfcG9zaXRpb24gPiBiLmxlbmd0aCB0aGVuIHJlc2l6ZSBiIDI7XG4gIHVuc2FmZV9zZXRfaW50MTYgYi5idWZmZXIgYi5wb3NpdGlvbiB4O1xuICBiLnBvc2l0aW9uIDwtIG5ld19wb3NpdGlvblxuXG5sZXQgYWRkX2ludDMyX25lIGIgeCA9XG4gIGxldCBuZXdfcG9zaXRpb24gPSBiLnBvc2l0aW9uICsgNCBpblxuICBpZiBuZXdfcG9zaXRpb24gPiBiLmxlbmd0aCB0aGVuIHJlc2l6ZSBiIDQ7XG4gIHVuc2FmZV9zZXRfaW50MzIgYi5idWZmZXIgYi5wb3NpdGlvbiB4O1xuICBiLnBvc2l0aW9uIDwtIG5ld19wb3NpdGlvblxuXG5sZXQgYWRkX2ludDY0X25lIGIgeCA9XG4gIGxldCBuZXdfcG9zaXRpb24gPSBiLnBvc2l0aW9uICsgOCBpblxuICBpZiBuZXdfcG9zaXRpb24gPiBiLmxlbmd0aCB0aGVuIHJlc2l6ZSBiIDg7XG4gIHVuc2FmZV9zZXRfaW50NjQgYi5idWZmZXIgYi5wb3NpdGlvbiB4O1xuICBiLnBvc2l0aW9uIDwtIG5ld19wb3NpdGlvblxuXG5sZXQgYWRkX2ludDE2X2xlIGIgeCA9XG4gIGFkZF9pbnQxNl9uZSBiIChpZiBTeXMuYmlnX2VuZGlhbiB0aGVuIHN3YXAxNiB4IGVsc2UgeClcblxubGV0IGFkZF9pbnQxNl9iZSBiIHggPVxuICBhZGRfaW50MTZfbmUgYiAoaWYgU3lzLmJpZ19lbmRpYW4gdGhlbiB4IGVsc2Ugc3dhcDE2IHgpXG5cbmxldCBhZGRfaW50MzJfbGUgYiB4ID1cbiAgYWRkX2ludDMyX25lIGIgKGlmIFN5cy5iaWdfZW5kaWFuIHRoZW4gc3dhcDMyIHggZWxzZSB4KVxuXG5sZXQgYWRkX2ludDMyX2JlIGIgeCA9XG4gIGFkZF9pbnQzMl9uZSBiIChpZiBTeXMuYmlnX2VuZGlhbiB0aGVuIHggZWxzZSBzd2FwMzIgeClcblxubGV0IGFkZF9pbnQ2NF9sZSBiIHggPVxuICBhZGRfaW50NjRfbmUgYiAoaWYgU3lzLmJpZ19lbmRpYW4gdGhlbiBzd2FwNjQgeCBlbHNlIHgpXG5cbmxldCBhZGRfaW50NjRfYmUgYiB4ID1cbiAgYWRkX2ludDY0X25lIGIgKGlmIFN5cy5iaWdfZW5kaWFuIHRoZW4geCBlbHNlIHN3YXA2NCB4KVxuXG5sZXQgYWRkX3VpbnQ4ID0gYWRkX2ludDhcbmxldCBhZGRfdWludDE2X25lID0gYWRkX2ludDE2X25lXG5sZXQgYWRkX3VpbnQxNl9sZSA9IGFkZF9pbnQxNl9sZVxubGV0IGFkZF91aW50MTZfYmUgPSBhZGRfaW50MTZfYmVcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgWGF2aWVyIExlcm95IGFuZCBQaWVycmUgV2VpcywgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxub3BlbiBDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3Ncbm9wZW4gQ2FtbGludGVybmFsRm9ybWF0XG5cbmxldCBrZnByaW50ZiBrIG8gKEZvcm1hdCAoZm10LCBfKSkgPVxuICBtYWtlX3ByaW50ZiAoZnVuIGFjYyAtPiBvdXRwdXRfYWNjIG8gYWNjOyBrIG8pIEVuZF9vZl9hY2MgZm10XG5sZXQga2JwcmludGYgayBiIChGb3JtYXQgKGZtdCwgXykpID1cbiAgbWFrZV9wcmludGYgKGZ1biBhY2MgLT4gYnVmcHV0X2FjYyBiIGFjYzsgayBiKSBFbmRfb2ZfYWNjIGZtdFxubGV0IGlrZnByaW50ZiBrIG9jIChGb3JtYXQgKGZtdCwgXykpID1cbiAgbWFrZV9pcHJpbnRmIGsgb2MgZm10XG5sZXQgaWticHJpbnRmID0gaWtmcHJpbnRmXG5cbmxldCBmcHJpbnRmIG9jIGZtdCA9IGtmcHJpbnRmIGlnbm9yZSBvYyBmbXRcbmxldCBicHJpbnRmIGIgZm10ID0ga2JwcmludGYgaWdub3JlIGIgZm10XG5sZXQgaWZwcmludGYgb2MgZm10ID0gaWtmcHJpbnRmIGlnbm9yZSBvYyBmbXRcbmxldCBpYnByaW50ZiBiIGZtdCA9IGlrYnByaW50ZiBpZ25vcmUgYiBmbXRcbmxldCBwcmludGYgZm10ID0gZnByaW50ZiBzdGRvdXQgZm10XG5sZXQgZXByaW50ZiBmbXQgPSBmcHJpbnRmIHN0ZGVyciBmbXRcblxubGV0IGtzcHJpbnRmIGsgKEZvcm1hdCAoZm10LCBfKSkgPVxuICBsZXQgaycgYWNjID1cbiAgICBsZXQgYnVmID0gQnVmZmVyLmNyZWF0ZSA2NCBpblxuICAgIHN0cnB1dF9hY2MgYnVmIGFjYztcbiAgICBrIChCdWZmZXIuY29udGVudHMgYnVmKSBpblxuICBtYWtlX3ByaW50ZiBrJyBFbmRfb2ZfYWNjIGZtdFxuXG5sZXQgc3ByaW50ZiBmbXQgPSBrc3ByaW50ZiAoZnVuIHMgLT4gcykgZm10XG5cbmxldCBrcHJpbnRmID0ga3NwcmludGZcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICBEYW1pZW4gRG9saWdleiwgcHJvamV0IFBhcmEsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxudHlwZSBrZXkgPSBzdHJpbmdcbnR5cGUgZG9jID0gc3RyaW5nXG50eXBlIHVzYWdlX21zZyA9IHN0cmluZ1xudHlwZSBhbm9uX2Z1biA9IChzdHJpbmcgLT4gdW5pdClcblxudHlwZSBzcGVjID1cbiAgfCBVbml0IG9mICh1bml0IC0+IHVuaXQpICAgICAoKiBDYWxsIHRoZSBmdW5jdGlvbiB3aXRoIHVuaXQgYXJndW1lbnQgKilcbiAgfCBCb29sIG9mIChib29sIC0+IHVuaXQpICAgICAoKiBDYWxsIHRoZSBmdW5jdGlvbiB3aXRoIGEgYm9vbCBhcmd1bWVudCAqKVxuICB8IFNldCBvZiBib29sIHJlZiAgICAgICAgICAgICgqIFNldCB0aGUgcmVmZXJlbmNlIHRvIHRydWUgKilcbiAgfCBDbGVhciBvZiBib29sIHJlZiAgICAgICAgICAoKiBTZXQgdGhlIHJlZmVyZW5jZSB0byBmYWxzZSAqKVxuICB8IFN0cmluZyBvZiAoc3RyaW5nIC0+IHVuaXQpICgqIENhbGwgdGhlIGZ1bmN0aW9uIHdpdGggYSBzdHJpbmcgYXJndW1lbnQgKilcbiAgfCBTZXRfc3RyaW5nIG9mIHN0cmluZyByZWYgICAoKiBTZXQgdGhlIHJlZmVyZW5jZSB0byB0aGUgc3RyaW5nIGFyZ3VtZW50ICopXG4gIHwgSW50IG9mIChpbnQgLT4gdW5pdCkgICAgICAgKCogQ2FsbCB0aGUgZnVuY3Rpb24gd2l0aCBhbiBpbnQgYXJndW1lbnQgKilcbiAgfCBTZXRfaW50IG9mIGludCByZWYgICAgICAgICAoKiBTZXQgdGhlIHJlZmVyZW5jZSB0byB0aGUgaW50IGFyZ3VtZW50ICopXG4gIHwgRmxvYXQgb2YgKGZsb2F0IC0+IHVuaXQpICAgKCogQ2FsbCB0aGUgZnVuY3Rpb24gd2l0aCBhIGZsb2F0IGFyZ3VtZW50ICopXG4gIHwgU2V0X2Zsb2F0IG9mIGZsb2F0IHJlZiAgICAgKCogU2V0IHRoZSByZWZlcmVuY2UgdG8gdGhlIGZsb2F0IGFyZ3VtZW50ICopXG4gIHwgVHVwbGUgb2Ygc3BlYyBsaXN0ICAgICAgICAgKCogVGFrZSBzZXZlcmFsIGFyZ3VtZW50cyBhY2NvcmRpbmcgdG8gdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3BlYyBsaXN0ICopXG4gIHwgU3ltYm9sIG9mIHN0cmluZyBsaXN0ICogKHN0cmluZyAtPiB1bml0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIFRha2Ugb25lIG9mIHRoZSBzeW1ib2xzIGFzIGFyZ3VtZW50IGFuZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGwgdGhlIGZ1bmN0aW9uIHdpdGggdGhlIHN5bWJvbC4gKilcbiAgfCBSZXN0IG9mIChzdHJpbmcgLT4gdW5pdCkgICAoKiBTdG9wIGludGVycHJldGluZyBrZXl3b3JkcyBhbmQgY2FsbCB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiB3aXRoIGVhY2ggcmVtYWluaW5nIGFyZ3VtZW50ICopXG4gIHwgUmVzdF9hbGwgb2YgKHN0cmluZyBsaXN0IC0+IHVuaXQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogU3RvcCBpbnRlcnByZXRpbmcga2V5d29yZHMgYW5kIGNhbGwgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gd2l0aCBhbGwgcmVtYWluaW5nIGFyZ3VtZW50cy4gKilcbiAgfCBFeHBhbmQgb2YgKHN0cmluZyAtPiBzdHJpbmcgYXJyYXkpICgqIElmIHRoZSByZW1haW5pbmcgYXJndW1lbnRzIHRvIHByb2Nlc3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZSBvZiB0aGUgZm9ybVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1tcIi1mb29cIjsgXCJhcmdcIl0gQCByZXN0XSB3aGVyZSBcImZvb1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcyByZWdpc3RlcmVkIGFzIFtFeHBhbmQgZl0sIHRoZW4gdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHMgW2YgXCJhcmdcIiBAIHJlc3RdIGFyZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc2VkLiBPbmx5IGFsbG93ZWQgaW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtwYXJzZV9hbmRfZXhwYW5kX2FyZ3ZfZHluYW1pY10uICopXG5cbmV4Y2VwdGlvbiBCYWQgb2Ygc3RyaW5nXG5leGNlcHRpb24gSGVscCBvZiBzdHJpbmdcblxudHlwZSBlcnJvciA9XG4gIHwgVW5rbm93biBvZiBzdHJpbmdcbiAgfCBXcm9uZyBvZiBzdHJpbmcgKiBzdHJpbmcgKiBzdHJpbmcgICgqIG9wdGlvbiwgYWN0dWFsLCBleHBlY3RlZCAqKVxuICB8IE1pc3Npbmcgb2Ygc3RyaW5nXG4gIHwgTWVzc2FnZSBvZiBzdHJpbmdcblxuZXhjZXB0aW9uIFN0b3Agb2YgZXJyb3IgKCogdXNlZCBpbnRlcm5hbGx5ICopXG5cbm9wZW4gUHJpbnRmXG5cbmxldCByZWMgYXNzb2MzIHggbCA9XG4gIG1hdGNoIGwgd2l0aFxuICB8IFtdIC0+IHJhaXNlIE5vdF9mb3VuZFxuICB8ICh5MSwgeTIsIF8pIDo6IF8gd2hlbiB5MSA9IHggLT4geTJcbiAgfCBfIDo6IHQgLT4gYXNzb2MzIHggdFxuXG5cbmxldCBzcGxpdCBzID1cbiAgbGV0IGkgPSBTdHJpbmcuaW5kZXggcyAnPScgaW5cbiAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggcyBpblxuICBTdHJpbmcuc3ViIHMgMCBpLCBTdHJpbmcuc3ViIHMgKGkrMSkgKGxlbi0oaSsxKSlcblxuXG5sZXQgbWFrZV9zeW1saXN0IHByZWZpeCBzZXAgc3VmZml4IGwgPVxuICBtYXRjaCBsIHdpdGhcbiAgfCBbXSAtPiBcIjxub25lPlwiXG4gIHwgaDo6dCAtPiAoTGlzdC5mb2xkX2xlZnQgKGZ1biB4IHkgLT4geCBeIHNlcCBeIHkpIChwcmVmaXggXiBoKSB0KSBeIHN1ZmZpeFxuXG5cbmxldCBwcmludF9zcGVjIGJ1ZiAoa2V5LCBzcGVjLCBkb2MpID1cbiAgaWYgU3RyaW5nLmxlbmd0aCBkb2MgPiAwIHRoZW5cbiAgICBtYXRjaCBzcGVjIHdpdGhcbiAgICB8IFN5bWJvbCAobCwgXykgLT5cbiAgICAgICAgYnByaW50ZiBidWYgXCIgICVzICVzJXNcXG5cIiBrZXkgKG1ha2Vfc3ltbGlzdCBcIntcIiBcInxcIiBcIn1cIiBsKSBkb2NcbiAgICB8IF8gLT5cbiAgICAgICAgYnByaW50ZiBidWYgXCIgICVzICVzXFxuXCIga2V5IGRvY1xuXG5cbmxldCBoZWxwX2FjdGlvbiAoKSA9IHJhaXNlIChTdG9wIChVbmtub3duIFwiLWhlbHBcIikpXG5cbmxldCBhZGRfaGVscCBzcGVjbGlzdCA9XG4gIGxldCBhZGQxID1cbiAgICB0cnkgaWdub3JlIChhc3NvYzMgXCItaGVscFwiIHNwZWNsaXN0KTsgW11cbiAgICB3aXRoIE5vdF9mb3VuZCAtPlxuICAgICAgICAgICAgW1wiLWhlbHBcIiwgVW5pdCBoZWxwX2FjdGlvbiwgXCIgRGlzcGxheSB0aGlzIGxpc3Qgb2Ygb3B0aW9uc1wiXVxuICBhbmQgYWRkMiA9XG4gICAgdHJ5IGlnbm9yZSAoYXNzb2MzIFwiLS1oZWxwXCIgc3BlY2xpc3QpOyBbXVxuICAgIHdpdGggTm90X2ZvdW5kIC0+XG4gICAgICAgICAgICBbXCItLWhlbHBcIiwgVW5pdCBoZWxwX2FjdGlvbiwgXCIgRGlzcGxheSB0aGlzIGxpc3Qgb2Ygb3B0aW9uc1wiXVxuICBpblxuICBzcGVjbGlzdCBAIChhZGQxIEAgYWRkMilcblxuXG5sZXQgdXNhZ2VfYiBidWYgc3BlY2xpc3QgZXJybXNnID1cbiAgYnByaW50ZiBidWYgXCIlc1xcblwiIGVycm1zZztcbiAgTGlzdC5pdGVyIChwcmludF9zcGVjIGJ1ZikgKGFkZF9oZWxwIHNwZWNsaXN0KVxuXG5cbmxldCB1c2FnZV9zdHJpbmcgc3BlY2xpc3QgZXJybXNnID1cbiAgbGV0IGIgPSBCdWZmZXIuY3JlYXRlIDIwMCBpblxuICB1c2FnZV9iIGIgc3BlY2xpc3QgZXJybXNnO1xuICBCdWZmZXIuY29udGVudHMgYlxuXG5cbmxldCB1c2FnZSBzcGVjbGlzdCBlcnJtc2cgPVxuICBlcHJpbnRmIFwiJXNcIiAodXNhZ2Vfc3RyaW5nIHNwZWNsaXN0IGVycm1zZylcblxuXG5sZXQgY3VycmVudCA9IHJlZiAwXG5cbmxldCBib29sX29mX3N0cmluZ19vcHQgeCA9XG4gIHRyeSBTb21lIChib29sX29mX3N0cmluZyB4KVxuICB3aXRoIEludmFsaWRfYXJndW1lbnQgXyAtPiBOb25lXG5cbmxldCBpbnRfb2Zfc3RyaW5nX29wdCB4ID1cbiAgdHJ5IFNvbWUgKGludF9vZl9zdHJpbmcgeClcbiAgd2l0aCBGYWlsdXJlIF8gLT4gTm9uZVxuXG5sZXQgZmxvYXRfb2Zfc3RyaW5nX29wdCB4ID1cbiAgdHJ5IFNvbWUgKGZsb2F0X29mX3N0cmluZyB4KVxuICB3aXRoIEZhaWx1cmUgXyAtPiBOb25lXG5cbmxldCBwYXJzZV9hbmRfZXhwYW5kX2FyZ3ZfZHluYW1pY19hdXggYWxsb3dfZXhwYW5kIGN1cnJlbnQgYXJndiBzcGVjbGlzdCBhbm9uZnVuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm1zZyA9XG4gIGxldCBpbml0cG9zID0gIWN1cnJlbnQgaW5cbiAgbGV0IGNvbnZlcnRfZXJyb3IgZXJyb3IgPVxuICAgICgqIGNvbnZlcnQgYW4gaW50ZXJuYWwgZXJyb3IgdG8gYSBCYWQvSGVscCBleGNlcHRpb25cbiAgICAgICAqb3IqIGFkZCB0aGUgcHJvZ3JhbSBuYW1lIGFzIGEgcHJlZml4IGFuZCB0aGUgdXNhZ2UgbWVzc2FnZSBhcyBhIHN1ZmZpeFxuICAgICAgIHRvIGFuIHVzZXItcmFpc2VkIEJhZCBleGNlcHRpb24uXG4gICAgKilcbiAgICBsZXQgYiA9IEJ1ZmZlci5jcmVhdGUgMjAwIGluXG4gICAgbGV0IHByb2duYW1lID1cbiAgICAgIGlmIGluaXRwb3MgPCAoQXJyYXkubGVuZ3RoICFhcmd2KSB0aGVuICFhcmd2Lihpbml0cG9zKSBlbHNlIFwiKD8pXCIgaW5cbiAgICBiZWdpbiBtYXRjaCBlcnJvciB3aXRoXG4gICAgICB8IFVua25vd24gXCItaGVscFwiIC0+ICgpXG4gICAgICB8IFVua25vd24gXCItLWhlbHBcIiAtPiAoKVxuICAgICAgfCBVbmtub3duIHMgLT5cbiAgICAgICAgICBicHJpbnRmIGIgXCIlczogdW5rbm93biBvcHRpb24gJyVzJy5cXG5cIiBwcm9nbmFtZSBzXG4gICAgICB8IE1pc3NpbmcgcyAtPlxuICAgICAgICAgIGJwcmludGYgYiBcIiVzOiBvcHRpb24gJyVzJyBuZWVkcyBhbiBhcmd1bWVudC5cXG5cIiBwcm9nbmFtZSBzXG4gICAgICB8IFdyb25nIChvcHQsIGFyZywgZXhwZWN0ZWQpIC0+XG4gICAgICAgICAgYnByaW50ZiBiIFwiJXM6IHdyb25nIGFyZ3VtZW50ICclcyc7IG9wdGlvbiAnJXMnIGV4cGVjdHMgJXMuXFxuXCJcbiAgICAgICAgICAgICAgICAgIHByb2duYW1lIGFyZyBvcHQgZXhwZWN0ZWRcbiAgICAgIHwgTWVzc2FnZSBzIC0+ICgqIHVzZXIgZXJyb3IgbWVzc2FnZSAqKVxuICAgICAgICAgIGJwcmludGYgYiBcIiVzOiAlcy5cXG5cIiBwcm9nbmFtZSBzXG4gICAgZW5kO1xuICAgIHVzYWdlX2IgYiAhc3BlY2xpc3QgZXJybXNnO1xuICAgIGlmIGVycm9yID0gVW5rbm93biBcIi1oZWxwXCIgfHwgZXJyb3IgPSBVbmtub3duIFwiLS1oZWxwXCJcbiAgICB0aGVuIEhlbHAgKEJ1ZmZlci5jb250ZW50cyBiKVxuICAgIGVsc2UgQmFkIChCdWZmZXIuY29udGVudHMgYilcbiAgaW5cbiAgaW5jciBjdXJyZW50O1xuICB3aGlsZSAhY3VycmVudCA8IChBcnJheS5sZW5ndGggIWFyZ3YpIGRvXG4gICAgYmVnaW4gdHJ5XG4gICAgICBsZXQgcyA9ICFhcmd2LighY3VycmVudCkgaW5cbiAgICAgIGlmIFN0cmluZy5sZW5ndGggcyA+PSAxICYmIHMuWzBdID0gJy0nIHRoZW4gYmVnaW5cbiAgICAgICAgbGV0IGFjdGlvbiwgZm9sbG93ID1cbiAgICAgICAgICB0cnkgYXNzb2MzIHMgIXNwZWNsaXN0LCBOb25lXG4gICAgICAgICAgd2l0aCBOb3RfZm91bmQgLT5cbiAgICAgICAgICB0cnlcbiAgICAgICAgICAgIGxldCBrZXl3b3JkLCBhcmcgPSBzcGxpdCBzIGluXG4gICAgICAgICAgICBhc3NvYzMga2V5d29yZCAhc3BlY2xpc3QsIFNvbWUgYXJnXG4gICAgICAgICAgd2l0aCBOb3RfZm91bmQgLT4gcmFpc2UgKFN0b3AgKFVua25vd24gcykpXG4gICAgICAgIGluXG4gICAgICAgIGxldCBub19hcmcgKCkgPVxuICAgICAgICAgIG1hdGNoIGZvbGxvdyB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+ICgpXG4gICAgICAgICAgfCBTb21lIGFyZyAtPiByYWlzZSAoU3RvcCAoV3JvbmcgKHMsIGFyZywgXCJubyBhcmd1bWVudFwiKSkpIGluXG4gICAgICAgIGxldCBnZXRfYXJnICgpID1cbiAgICAgICAgICBtYXRjaCBmb2xsb3cgd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgICAgICBpZiAhY3VycmVudCArIDEgPCAoQXJyYXkubGVuZ3RoICFhcmd2KSB0aGVuICFhcmd2LighY3VycmVudCArIDEpXG4gICAgICAgICAgICAgIGVsc2UgcmFpc2UgKFN0b3AgKE1pc3NpbmcgcykpXG4gICAgICAgICAgfCBTb21lIGFyZyAtPiBhcmdcbiAgICAgICAgaW5cbiAgICAgICAgbGV0IGNvbnN1bWVfYXJnICgpID1cbiAgICAgICAgICBtYXRjaCBmb2xsb3cgd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPiBpbmNyIGN1cnJlbnRcbiAgICAgICAgICB8IFNvbWUgXyAtPiAoKVxuICAgICAgICBpblxuICAgICAgICBsZXQgcmVjIHRyZWF0X2FjdGlvbiA9IGZ1bmN0aW9uXG4gICAgICAgIHwgVW5pdCBmIC0+IG5vX2FyZyAoKTsgZiAoKTtcbiAgICAgICAgfCBCb29sIGYgLT5cbiAgICAgICAgICAgIGxldCBhcmcgPSBnZXRfYXJnICgpIGluXG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBib29sX29mX3N0cmluZ19vcHQgYXJnIHdpdGhcbiAgICAgICAgICAgIHwgTm9uZSAtPiByYWlzZSAoU3RvcCAoV3JvbmcgKHMsIGFyZywgXCJhIGJvb2xlYW5cIikpKVxuICAgICAgICAgICAgfCBTb21lIHMgLT4gZiBzXG4gICAgICAgICAgICBlbmQ7XG4gICAgICAgICAgICBjb25zdW1lX2FyZyAoKTtcbiAgICAgICAgfCBTZXQgciAtPiBub19hcmcgKCk7IHIgOj0gdHJ1ZTtcbiAgICAgICAgfCBDbGVhciByIC0+IG5vX2FyZyAoKTsgciA6PSBmYWxzZTtcbiAgICAgICAgfCBTdHJpbmcgZiAtPlxuICAgICAgICAgICAgbGV0IGFyZyA9IGdldF9hcmcgKCkgaW5cbiAgICAgICAgICAgIGYgYXJnO1xuICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgIHwgU3ltYm9sIChzeW1iLCBmKSAtPlxuICAgICAgICAgICAgbGV0IGFyZyA9IGdldF9hcmcgKCkgaW5cbiAgICAgICAgICAgIGlmIExpc3QubWVtIGFyZyBzeW1iIHRoZW4gYmVnaW5cbiAgICAgICAgICAgICAgZiBhcmc7XG4gICAgICAgICAgICAgIGNvbnN1bWVfYXJnICgpO1xuICAgICAgICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgICAgICAgcmFpc2UgKFN0b3AgKFdyb25nIChzLCBhcmcsIFwib25lIG9mOiBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXiAobWFrZV9zeW1saXN0IFwiXCIgXCIgXCIgXCJcIiBzeW1iKSkpKVxuICAgICAgICAgICAgZW5kXG4gICAgICAgIHwgU2V0X3N0cmluZyByIC0+XG4gICAgICAgICAgICByIDo9IGdldF9hcmcgKCk7XG4gICAgICAgICAgICBjb25zdW1lX2FyZyAoKTtcbiAgICAgICAgfCBJbnQgZiAtPlxuICAgICAgICAgICAgbGV0IGFyZyA9IGdldF9hcmcgKCkgaW5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIGludF9vZl9zdHJpbmdfb3B0IGFyZyB3aXRoXG4gICAgICAgICAgICB8IE5vbmUgLT4gcmFpc2UgKFN0b3AgKFdyb25nIChzLCBhcmcsIFwiYW4gaW50ZWdlclwiKSkpXG4gICAgICAgICAgICB8IFNvbWUgeCAtPiBmIHhcbiAgICAgICAgICAgIGVuZDtcbiAgICAgICAgICAgIGNvbnN1bWVfYXJnICgpO1xuICAgICAgICB8IFNldF9pbnQgciAtPlxuICAgICAgICAgICAgbGV0IGFyZyA9IGdldF9hcmcgKCkgaW5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIGludF9vZl9zdHJpbmdfb3B0IGFyZyB3aXRoXG4gICAgICAgICAgICB8IE5vbmUgLT4gcmFpc2UgKFN0b3AgKFdyb25nIChzLCBhcmcsIFwiYW4gaW50ZWdlclwiKSkpXG4gICAgICAgICAgICB8IFNvbWUgeCAtPiByIDo9IHhcbiAgICAgICAgICAgIGVuZDtcbiAgICAgICAgICAgIGNvbnN1bWVfYXJnICgpO1xuICAgICAgICB8IEZsb2F0IGYgLT5cbiAgICAgICAgICAgIGxldCBhcmcgPSBnZXRfYXJnICgpIGluXG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBmbG9hdF9vZl9zdHJpbmdfb3B0IGFyZyB3aXRoXG4gICAgICAgICAgICB8IE5vbmUgLT4gcmFpc2UgKFN0b3AgKFdyb25nIChzLCBhcmcsIFwiYSBmbG9hdFwiKSkpXG4gICAgICAgICAgICB8IFNvbWUgeCAtPiBmIHhcbiAgICAgICAgICAgIGVuZDtcbiAgICAgICAgICAgIGNvbnN1bWVfYXJnICgpO1xuICAgICAgICB8IFNldF9mbG9hdCByIC0+XG4gICAgICAgICAgICBsZXQgYXJnID0gZ2V0X2FyZyAoKSBpblxuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggZmxvYXRfb2Zfc3RyaW5nX29wdCBhcmcgd2l0aFxuICAgICAgICAgICAgfCBOb25lIC0+IHJhaXNlIChTdG9wIChXcm9uZyAocywgYXJnLCBcImEgZmxvYXRcIikpKVxuICAgICAgICAgICAgfCBTb21lIHggLT4gciA6PSB4XG4gICAgICAgICAgICBlbmQ7XG4gICAgICAgICAgICBjb25zdW1lX2FyZyAoKTtcbiAgICAgICAgfCBUdXBsZSBzcGVjcyAtPlxuICAgICAgICAgICAgbm9fYXJnICgpO1xuICAgICAgICAgICAgTGlzdC5pdGVyIHRyZWF0X2FjdGlvbiBzcGVjcztcbiAgICAgICAgfCBSZXN0IGYgLT5cbiAgICAgICAgICAgIG5vX2FyZyAoKTtcbiAgICAgICAgICAgIHdoaWxlICFjdXJyZW50IDwgKEFycmF5Lmxlbmd0aCAhYXJndikgLSAxIGRvXG4gICAgICAgICAgICAgIGYgIWFyZ3YuKCFjdXJyZW50ICsgMSk7XG4gICAgICAgICAgICAgIGNvbnN1bWVfYXJnICgpO1xuICAgICAgICAgICAgZG9uZTtcbiAgICAgICAgfCBSZXN0X2FsbCBmIC0+XG4gICAgICAgICAgICBub19hcmcgKCk7XG4gICAgICAgICAgICBsZXQgYWNjID0gcmVmIFtdIGluXG4gICAgICAgICAgICB3aGlsZSAhY3VycmVudCA8IEFycmF5Lmxlbmd0aCAhYXJndiAtIDEgZG9cbiAgICAgICAgICAgICAgYWNjIDo9ICFhcmd2LighY3VycmVudCArIDEpIDo6ICFhY2M7XG4gICAgICAgICAgICAgIGNvbnN1bWVfYXJnICgpO1xuICAgICAgICAgICAgZG9uZTtcbiAgICAgICAgICAgIGYgKExpc3QucmV2ICFhY2MpXG4gICAgICAgIHwgRXhwYW5kIGYgLT5cbiAgICAgICAgICAgIGlmIG5vdCBhbGxvd19leHBhbmQgdGhlblxuICAgICAgICAgICAgICByYWlzZSAoSW52YWxpZF9hcmd1bWVudCBcIkFyZy5FeHBhbmQgaXMgaXMgb25seSBhbGxvd2VkIHdpdGggXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFyZy5wYXJzZV9hbmRfZXhwYW5kX2FyZ3ZfZHluYW1pY1wiKTtcbiAgICAgICAgICAgIGxldCBhcmcgPSBnZXRfYXJnICgpIGluXG4gICAgICAgICAgICBsZXQgbmV3YXJnID0gZiBhcmcgaW5cbiAgICAgICAgICAgIGNvbnN1bWVfYXJnICgpO1xuICAgICAgICAgICAgbGV0IGJlZm9yZSA9IEFycmF5LnN1YiAhYXJndiAwICghY3VycmVudCArIDEpXG4gICAgICAgICAgICBhbmQgYWZ0ZXIgPVxuICAgICAgICAgICAgICBBcnJheS5zdWIgIWFyZ3YgKCFjdXJyZW50ICsgMSlcbiAgICAgICAgICAgICAgICAgICAgICAgICgoQXJyYXkubGVuZ3RoICFhcmd2KSAtICFjdXJyZW50IC0gMSkgaW5cbiAgICAgICAgICAgIGFyZ3Y6PSBBcnJheS5jb25jYXQgW2JlZm9yZTtuZXdhcmc7YWZ0ZXJdO1xuICAgICAgICBpblxuICAgICAgICB0cmVhdF9hY3Rpb24gYWN0aW9uIGVuZFxuICAgICAgZWxzZSBhbm9uZnVuIHNcbiAgICB3aXRoIHwgQmFkIG0gLT4gcmFpc2UgKGNvbnZlcnRfZXJyb3IgKE1lc3NhZ2UgbSkpO1xuICAgICAgICAgfCBTdG9wIGUgLT4gcmFpc2UgKGNvbnZlcnRfZXJyb3IgZSk7XG4gICAgZW5kO1xuICAgIGluY3IgY3VycmVudFxuICBkb25lXG5cbmxldCBwYXJzZV9hbmRfZXhwYW5kX2FyZ3ZfZHluYW1pYyBjdXJyZW50IGFyZ3Ygc3BlY2xpc3QgYW5vbmZ1biBlcnJtc2cgPVxuICBwYXJzZV9hbmRfZXhwYW5kX2FyZ3ZfZHluYW1pY19hdXggdHJ1ZSBjdXJyZW50IGFyZ3Ygc3BlY2xpc3QgYW5vbmZ1biBlcnJtc2dcblxubGV0IHBhcnNlX2FyZ3ZfZHluYW1pYyA/KGN1cnJlbnQ9Y3VycmVudCkgYXJndiBzcGVjbGlzdCBhbm9uZnVuIGVycm1zZyA9XG4gIHBhcnNlX2FuZF9leHBhbmRfYXJndl9keW5hbWljX2F1eCBmYWxzZSBjdXJyZW50IChyZWYgYXJndikgc3BlY2xpc3QgYW5vbmZ1blxuICAgIGVycm1zZ1xuXG5cbmxldCBwYXJzZV9hcmd2ID8oY3VycmVudD1jdXJyZW50KSBhcmd2IHNwZWNsaXN0IGFub25mdW4gZXJybXNnID1cbiAgcGFyc2VfYXJndl9keW5hbWljIH5jdXJyZW50OmN1cnJlbnQgYXJndiAocmVmIHNwZWNsaXN0KSBhbm9uZnVuIGVycm1zZ1xuXG5cbmxldCBwYXJzZSBsIGYgbXNnID1cbiAgdHJ5XG4gICAgcGFyc2VfYXJndiBTeXMuYXJndiBsIGYgbXNnXG4gIHdpdGhcbiAgfCBCYWQgbXNnIC0+IGVwcmludGYgXCIlc1wiIG1zZzsgZXhpdCAyXG4gIHwgSGVscCBtc2cgLT4gcHJpbnRmIFwiJXNcIiBtc2c7IGV4aXQgMFxuXG5cbmxldCBwYXJzZV9keW5hbWljIGwgZiBtc2cgPVxuICB0cnlcbiAgICBwYXJzZV9hcmd2X2R5bmFtaWMgU3lzLmFyZ3YgbCBmIG1zZ1xuICB3aXRoXG4gIHwgQmFkIG1zZyAtPiBlcHJpbnRmIFwiJXNcIiBtc2c7IGV4aXQgMlxuICB8IEhlbHAgbXNnIC0+IHByaW50ZiBcIiVzXCIgbXNnOyBleGl0IDBcblxubGV0IHBhcnNlX2V4cGFuZCBsIGYgbXNnID1cbiAgdHJ5XG4gICAgbGV0IGFyZ3YgPSByZWYgU3lzLmFyZ3YgaW5cbiAgICBsZXQgc3BlYyA9IHJlZiBsIGluXG4gICAgbGV0IGN1cnJlbnQgPSByZWYgKCFjdXJyZW50KSBpblxuICAgIHBhcnNlX2FuZF9leHBhbmRfYXJndl9keW5hbWljIGN1cnJlbnQgYXJndiBzcGVjIGYgbXNnXG4gIHdpdGhcbiAgfCBCYWQgbXNnIC0+IGVwcmludGYgXCIlc1wiIG1zZzsgZXhpdCAyXG4gIHwgSGVscCBtc2cgLT4gcHJpbnRmIFwiJXNcIiBtc2c7IGV4aXQgMFxuXG5cbmxldCBzZWNvbmRfd29yZCBzID1cbiAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggcyBpblxuICBsZXQgcmVjIGxvb3AgbiA9XG4gICAgaWYgbiA+PSBsZW4gdGhlbiBsZW5cbiAgICBlbHNlIGlmIHMuW25dID0gJyAnIHRoZW4gbG9vcCAobisxKVxuICAgIGVsc2UgblxuICBpblxuICBtYXRjaCBTdHJpbmcuaW5kZXggcyAnXFx0JyB3aXRoXG4gIHwgbiAtPiBsb29wIChuKzEpXG4gIHwgZXhjZXB0aW9uIE5vdF9mb3VuZCAtPlxuICAgICAgYmVnaW4gbWF0Y2ggU3RyaW5nLmluZGV4IHMgJyAnIHdpdGhcbiAgICAgIHwgbiAtPiBsb29wIChuKzEpXG4gICAgICB8IGV4Y2VwdGlvbiBOb3RfZm91bmQgLT4gbGVuXG4gICAgICBlbmRcblxuXG5sZXQgbWF4X2FyZ19sZW4gY3VyIChrd2QsIHNwZWMsIGRvYykgPVxuICBtYXRjaCBzcGVjIHdpdGhcbiAgfCBTeW1ib2wgXyAtPiBtYXggY3VyIChTdHJpbmcubGVuZ3RoIGt3ZClcbiAgfCBfIC0+IG1heCBjdXIgKFN0cmluZy5sZW5ndGgga3dkICsgc2Vjb25kX3dvcmQgZG9jKVxuXG5cbmxldCByZXBsYWNlX2xlYWRpbmdfdGFiIHMgPVxuICBsZXQgc2VlbiA9IHJlZiBmYWxzZSBpblxuICBTdHJpbmcubWFwIChmdW5jdGlvbiAnXFx0JyB3aGVuIG5vdCAhc2VlbiAtPiBzZWVuIDo9IHRydWU7ICcgJyB8IGMgLT4gYykgc1xuXG5sZXQgYWRkX3BhZGRpbmcgbGVuIGtzZCA9XG4gIG1hdGNoIGtzZCB3aXRoXG4gIHwgKF8sIF8sIFwiXCIpIC0+XG4gICAgICAoKiBEbyBub3QgcGFkIHVuZG9jdW1lbnRlZCBvcHRpb25zLCBzbyB0aGF0IHRoZXkgc3RpbGwgZG9uJ3Qgc2hvdyB1cCB3aGVuXG4gICAgICAgKiBydW4gdGhyb3VnaCBbdXNhZ2VdIG9yIFtwYXJzZV0uICopXG4gICAgICBrc2RcbiAgfCAoa3dkLCAoU3ltYm9sIF8gYXMgc3BlYyksIG1zZykgLT5cbiAgICAgIGxldCBjdXRjb2wgPSBzZWNvbmRfd29yZCBtc2cgaW5cbiAgICAgIGxldCBzcGFjZXMgPSBTdHJpbmcubWFrZSAoKG1heCAwIChsZW4gLSBjdXRjb2wpKSArIDMpICcgJyBpblxuICAgICAgKGt3ZCwgc3BlYywgXCJcXG5cIiBeIHNwYWNlcyBeIHJlcGxhY2VfbGVhZGluZ190YWIgbXNnKVxuICB8IChrd2QsIHNwZWMsIG1zZykgLT5cbiAgICAgIGxldCBjdXRjb2wgPSBzZWNvbmRfd29yZCBtc2cgaW5cbiAgICAgIGxldCBrd2RfbGVuID0gU3RyaW5nLmxlbmd0aCBrd2QgaW5cbiAgICAgIGxldCBkaWZmID0gbGVuIC0ga3dkX2xlbiAtIGN1dGNvbCBpblxuICAgICAgaWYgZGlmZiA8PSAwIHRoZW5cbiAgICAgICAgKGt3ZCwgc3BlYywgcmVwbGFjZV9sZWFkaW5nX3RhYiBtc2cpXG4gICAgICBlbHNlXG4gICAgICAgIGxldCBzcGFjZXMgPSBTdHJpbmcubWFrZSBkaWZmICcgJyBpblxuICAgICAgICBsZXQgcHJlZml4ID0gU3RyaW5nLnN1YiAocmVwbGFjZV9sZWFkaW5nX3RhYiBtc2cpIDAgY3V0Y29sIGluXG4gICAgICAgIGxldCBzdWZmaXggPSBTdHJpbmcuc3ViIG1zZyBjdXRjb2wgKFN0cmluZy5sZW5ndGggbXNnIC0gY3V0Y29sKSBpblxuICAgICAgICAoa3dkLCBzcGVjLCBwcmVmaXggXiBzcGFjZXMgXiBzdWZmaXgpXG5cblxubGV0IGFsaWduID8obGltaXQ9bWF4X2ludCkgc3BlY2xpc3QgPVxuICBsZXQgY29tcGxldGVkID0gYWRkX2hlbHAgc3BlY2xpc3QgaW5cbiAgbGV0IGxlbiA9IExpc3QuZm9sZF9sZWZ0IG1heF9hcmdfbGVuIDAgY29tcGxldGVkIGluXG4gIGxldCBsZW4gPSBtaW4gbGVuIGxpbWl0IGluXG4gIExpc3QubWFwIChhZGRfcGFkZGluZyBsZW4pIGNvbXBsZXRlZFxuXG5sZXQgdHJpbV9jciBzID1cbiAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggcyBpblxuICBpZiBsZW4gPiAwICYmIFN0cmluZy5nZXQgcyAobGVuIC0gMSkgPSAnXFxyJyB0aGVuXG4gICAgU3RyaW5nLnN1YiBzIDAgKGxlbiAtIDEpXG4gIGVsc2VcbiAgICBzXG5cbmxldCByZWFkX2F1eCB0cmltIHNlcCBmaWxlID1cbiAgbGV0IGljID0gb3Blbl9pbl9iaW4gZmlsZSBpblxuICBsZXQgYnVmID0gQnVmZmVyLmNyZWF0ZSAyMDAgaW5cbiAgbGV0IHdvcmRzID0gcmVmIFtdIGluXG4gIGxldCBzdGFzaCAoKSA9XG4gICAgbGV0IHdvcmQgPSBCdWZmZXIuY29udGVudHMgYnVmIGluXG4gICAgbGV0IHdvcmQgPSBpZiB0cmltIHRoZW4gdHJpbV9jciB3b3JkIGVsc2Ugd29yZCBpblxuICAgIHdvcmRzIDo9IHdvcmQgOjogIXdvcmRzO1xuICAgIEJ1ZmZlci5jbGVhciBidWZcbiAgaW5cbiAgYmVnaW5cbiAgICB0cnkgd2hpbGUgdHJ1ZSBkb1xuICAgICAgICBsZXQgYyA9IGlucHV0X2NoYXIgaWMgaW5cbiAgICAgICAgaWYgYyA9IHNlcCB0aGVuIHN0YXNoICgpIGVsc2UgQnVmZmVyLmFkZF9jaGFyIGJ1ZiBjXG4gICAgICBkb25lXG4gICAgd2l0aCBFbmRfb2ZfZmlsZSAtPiAoKVxuICBlbmQ7XG4gIGlmIEJ1ZmZlci5sZW5ndGggYnVmID4gMCB0aGVuIHN0YXNoICgpO1xuICBjbG9zZV9pbiBpYztcbiAgQXJyYXkub2ZfbGlzdCAoTGlzdC5yZXYgIXdvcmRzKVxuXG5sZXQgcmVhZF9hcmcgPSByZWFkX2F1eCB0cnVlICdcXG4nXG5cbmxldCByZWFkX2FyZzAgPSByZWFkX2F1eCBmYWxzZSAnXFx4MDAnXG5cbmxldCB3cml0ZV9hdXggc2VwIGZpbGUgYXJncyA9XG4gIGxldCBvYyA9IG9wZW5fb3V0X2JpbiBmaWxlIGluXG4gIEFycmF5Lml0ZXIgKGZ1biBzIC0+IGZwcmludGYgb2MgXCIlcyVjXCIgcyBzZXApIGFyZ3M7XG4gIGNsb3NlX291dCBvY1xuXG5sZXQgd3JpdGVfYXJnID0gd3JpdGVfYXV4ICdcXG4nXG5cbmxldCB3cml0ZV9hcmcwID0gd3JpdGVfYXV4ICdcXHgwMCdcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBPQ2FtbCBwcm9ncmFtbWVycyAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMTggSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuZXh0ZXJuYWwgaWQgOiAnYSAtPiAnYSA9IFwiJWlkZW50aXR5XCJcbmxldCBjb25zdCBjIF8gPSBjXG5sZXQgZmxpcCBmIHggeSA9IGYgeSB4XG5sZXQgbmVnYXRlIHAgdiA9IG5vdCAocCB2KVxuXG5leGNlcHRpb24gRmluYWxseV9yYWlzZWQgb2YgZXhuXG5cbmxldCAoKSA9IFByaW50ZXhjLnJlZ2lzdGVyX3ByaW50ZXIgQEAgZnVuY3Rpb25cbnwgRmluYWxseV9yYWlzZWQgZXhuIC0+IFNvbWUgKFwiRnVuLkZpbmFsbHlfcmFpc2VkOiBcIiBeIFByaW50ZXhjLnRvX3N0cmluZyBleG4pXG58IF8gLT4gTm9uZVxuXG5sZXQgcHJvdGVjdCB+KGZpbmFsbHkgOiB1bml0IC0+IHVuaXQpIHdvcmsgPVxuICBsZXQgZmluYWxseV9ub19leG4gKCkgPVxuICAgIHRyeSBmaW5hbGx5ICgpIHdpdGggZSAtPlxuICAgICAgbGV0IGJ0ID0gUHJpbnRleGMuZ2V0X3Jhd19iYWNrdHJhY2UgKCkgaW5cbiAgICAgIFByaW50ZXhjLnJhaXNlX3dpdGhfYmFja3RyYWNlIChGaW5hbGx5X3JhaXNlZCBlKSBidFxuICBpblxuICBtYXRjaCB3b3JrICgpIHdpdGhcbiAgfCByZXN1bHQgLT4gZmluYWxseV9ub19leG4gKCkgOyByZXN1bHRcbiAgfCBleGNlcHRpb24gd29ya19leG4gLT5cbiAgICAgIGxldCB3b3JrX2J0ID0gUHJpbnRleGMuZ2V0X3Jhd19iYWNrdHJhY2UgKCkgaW5cbiAgICAgIGZpbmFsbHlfbm9fZXhuICgpIDtcbiAgICAgIFByaW50ZXhjLnJhaXNlX3dpdGhfYmFja3RyYWNlIHdvcmtfZXhuIHdvcmtfYnRcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgRGFtaWVuIERvbGlnZXosIHByb2pldCBQYXJhLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgSmFjcXVlcy1IZW5yaSBKb3VyZGFuLCBwcm9qZXQgR2FsbGl1bSwgSU5SSUEgUGFyaXMgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYtMjAxNiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlICAgKilcbigqICAgICBldCBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxudHlwZSBzdGF0ID0ge1xuICBtaW5vcl93b3JkcyA6IGZsb2F0O1xuICBwcm9tb3RlZF93b3JkcyA6IGZsb2F0O1xuICBtYWpvcl93b3JkcyA6IGZsb2F0O1xuICBtaW5vcl9jb2xsZWN0aW9ucyA6IGludDtcbiAgbWFqb3JfY29sbGVjdGlvbnMgOiBpbnQ7XG4gIGhlYXBfd29yZHMgOiBpbnQ7XG4gIGhlYXBfY2h1bmtzIDogaW50O1xuICBsaXZlX3dvcmRzIDogaW50O1xuICBsaXZlX2Jsb2NrcyA6IGludDtcbiAgZnJlZV93b3JkcyA6IGludDtcbiAgZnJlZV9ibG9ja3MgOiBpbnQ7XG4gIGxhcmdlc3RfZnJlZSA6IGludDtcbiAgZnJhZ21lbnRzIDogaW50O1xuICBjb21wYWN0aW9ucyA6IGludDtcbiAgdG9wX2hlYXBfd29yZHMgOiBpbnQ7XG4gIHN0YWNrX3NpemUgOiBpbnQ7XG4gIGZvcmNlZF9tYWpvcl9jb2xsZWN0aW9uczogaW50O1xufVxuXG50eXBlIGNvbnRyb2wgPSB7XG4gIG11dGFibGUgbWlub3JfaGVhcF9zaXplIDogaW50O1xuICBtdXRhYmxlIG1ham9yX2hlYXBfaW5jcmVtZW50IDogaW50O1xuICBtdXRhYmxlIHNwYWNlX292ZXJoZWFkIDogaW50O1xuICBtdXRhYmxlIHZlcmJvc2UgOiBpbnQ7XG4gIG11dGFibGUgbWF4X292ZXJoZWFkIDogaW50O1xuICBtdXRhYmxlIHN0YWNrX2xpbWl0IDogaW50O1xuICBtdXRhYmxlIGFsbG9jYXRpb25fcG9saWN5IDogaW50O1xuICB3aW5kb3dfc2l6ZSA6IGludDtcbiAgY3VzdG9tX21ham9yX3JhdGlvIDogaW50O1xuICBjdXN0b21fbWlub3JfcmF0aW8gOiBpbnQ7XG4gIGN1c3RvbV9taW5vcl9tYXhfc2l6ZSA6IGludDtcbn1cblxuZXh0ZXJuYWwgc3RhdCA6IHVuaXQgLT4gc3RhdCA9IFwiY2FtbF9nY19zdGF0XCJcbmV4dGVybmFsIHF1aWNrX3N0YXQgOiB1bml0IC0+IHN0YXQgPSBcImNhbWxfZ2NfcXVpY2tfc3RhdFwiXG5leHRlcm5hbCBjb3VudGVycyA6IHVuaXQgLT4gKGZsb2F0ICogZmxvYXQgKiBmbG9hdCkgPSBcImNhbWxfZ2NfY291bnRlcnNcIlxuZXh0ZXJuYWwgbWlub3Jfd29yZHMgOiB1bml0IC0+IChmbG9hdCBbQHVuYm94ZWRdKVxuICA9IFwiY2FtbF9nY19taW5vcl93b3Jkc1wiIFwiY2FtbF9nY19taW5vcl93b3Jkc191bmJveGVkXCJcbmV4dGVybmFsIGdldCA6IHVuaXQgLT4gY29udHJvbCA9IFwiY2FtbF9nY19nZXRcIlxuZXh0ZXJuYWwgc2V0IDogY29udHJvbCAtPiB1bml0ID0gXCJjYW1sX2djX3NldFwiXG5leHRlcm5hbCBtaW5vciA6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9nY19taW5vclwiXG5leHRlcm5hbCBtYWpvcl9zbGljZSA6IGludCAtPiBpbnQgPSBcImNhbWxfZ2NfbWFqb3Jfc2xpY2VcIlxuZXh0ZXJuYWwgbWFqb3IgOiB1bml0IC0+IHVuaXQgPSBcImNhbWxfZ2NfbWFqb3JcIlxuZXh0ZXJuYWwgZnVsbF9tYWpvciA6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9nY19mdWxsX21ham9yXCJcbmV4dGVybmFsIGNvbXBhY3QgOiB1bml0IC0+IHVuaXQgPSBcImNhbWxfZ2NfY29tcGFjdGlvblwiXG5leHRlcm5hbCBnZXRfbWlub3JfZnJlZSA6IHVuaXQgLT4gaW50ID0gXCJjYW1sX2dldF9taW5vcl9mcmVlXCJcbmV4dGVybmFsIGdldF9idWNrZXQgOiBpbnQgLT4gaW50ID0gXCJjYW1sX2dldF9tYWpvcl9idWNrZXRcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZ2V0X2NyZWRpdCA6IHVuaXQgLT4gaW50ID0gXCJjYW1sX2dldF9tYWpvcl9jcmVkaXRcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgaHVnZV9mYWxsYmFja19jb3VudCA6IHVuaXQgLT4gaW50ID0gXCJjYW1sX2djX2h1Z2VfZmFsbGJhY2tfY291bnRcIlxuZXh0ZXJuYWwgZXZlbnRsb2dfcGF1c2UgOiB1bml0IC0+IHVuaXQgPSBcImNhbWxfZXZlbnRsb2dfcGF1c2VcIlxuZXh0ZXJuYWwgZXZlbnRsb2dfcmVzdW1lIDogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2V2ZW50bG9nX3Jlc3VtZVwiXG5cbm9wZW4gUHJpbnRmXG5cbmxldCBwcmludF9zdGF0IGMgPVxuICBsZXQgc3QgPSBzdGF0ICgpIGluXG4gIGZwcmludGYgYyBcIm1pbm9yX2NvbGxlY3Rpb25zOiAgICAgICVkXFxuXCIgc3QubWlub3JfY29sbGVjdGlvbnM7XG4gIGZwcmludGYgYyBcIm1ham9yX2NvbGxlY3Rpb25zOiAgICAgICVkXFxuXCIgc3QubWFqb3JfY29sbGVjdGlvbnM7XG4gIGZwcmludGYgYyBcImNvbXBhY3Rpb25zOiAgICAgICAgICAgICVkXFxuXCIgc3QuY29tcGFjdGlvbnM7XG4gIGZwcmludGYgYyBcImZvcmNlZF9tYWpvcl9jb2xsZWN0aW9uczogJWRcXG5cIiBzdC5mb3JjZWRfbWFqb3JfY29sbGVjdGlvbnM7XG4gIGZwcmludGYgYyBcIlxcblwiO1xuICBsZXQgbDEgPSBTdHJpbmcubGVuZ3RoIChzcHJpbnRmIFwiJS4wZlwiIHN0Lm1pbm9yX3dvcmRzKSBpblxuICBmcHJpbnRmIGMgXCJtaW5vcl93b3JkczogICAgJSouMGZcXG5cIiBsMSBzdC5taW5vcl93b3JkcztcbiAgZnByaW50ZiBjIFwicHJvbW90ZWRfd29yZHM6ICUqLjBmXFxuXCIgbDEgc3QucHJvbW90ZWRfd29yZHM7XG4gIGZwcmludGYgYyBcIm1ham9yX3dvcmRzOiAgICAlKi4wZlxcblwiIGwxIHN0Lm1ham9yX3dvcmRzO1xuICBmcHJpbnRmIGMgXCJcXG5cIjtcbiAgbGV0IGwyID0gU3RyaW5nLmxlbmd0aCAoc3ByaW50ZiBcIiVkXCIgc3QudG9wX2hlYXBfd29yZHMpIGluXG4gIGZwcmludGYgYyBcInRvcF9oZWFwX3dvcmRzOiAlKmRcXG5cIiBsMiBzdC50b3BfaGVhcF93b3JkcztcbiAgZnByaW50ZiBjIFwiaGVhcF93b3JkczogICAgICUqZFxcblwiIGwyIHN0LmhlYXBfd29yZHM7XG4gIGZwcmludGYgYyBcImxpdmVfd29yZHM6ICAgICAlKmRcXG5cIiBsMiBzdC5saXZlX3dvcmRzO1xuICBmcHJpbnRmIGMgXCJmcmVlX3dvcmRzOiAgICAgJSpkXFxuXCIgbDIgc3QuZnJlZV93b3JkcztcbiAgZnByaW50ZiBjIFwibGFyZ2VzdF9mcmVlOiAgICUqZFxcblwiIGwyIHN0Lmxhcmdlc3RfZnJlZTtcbiAgZnByaW50ZiBjIFwiZnJhZ21lbnRzOiAgICAgICUqZFxcblwiIGwyIHN0LmZyYWdtZW50cztcbiAgZnByaW50ZiBjIFwiXFxuXCI7XG4gIGZwcmludGYgYyBcImxpdmVfYmxvY2tzOiAlZFxcblwiIHN0LmxpdmVfYmxvY2tzO1xuICBmcHJpbnRmIGMgXCJmcmVlX2Jsb2NrczogJWRcXG5cIiBzdC5mcmVlX2Jsb2NrcztcbiAgZnByaW50ZiBjIFwiaGVhcF9jaHVua3M6ICVkXFxuXCIgc3QuaGVhcF9jaHVua3NcblxuXG5sZXQgYWxsb2NhdGVkX2J5dGVzICgpID1cbiAgbGV0IChtaSwgcHJvLCBtYSkgPSBjb3VudGVycyAoKSBpblxuICAobWkgKy4gbWEgLS4gcHJvKSAqLiBmbG9hdF9vZl9pbnQgKFN5cy53b3JkX3NpemUgLyA4KVxuXG5cbmV4dGVybmFsIGZpbmFsaXNlIDogKCdhIC0+IHVuaXQpIC0+ICdhIC0+IHVuaXQgPSBcImNhbWxfZmluYWxfcmVnaXN0ZXJcIlxuZXh0ZXJuYWwgZmluYWxpc2VfbGFzdCA6ICh1bml0IC0+IHVuaXQpIC0+ICdhIC0+IHVuaXQgPVxuICBcImNhbWxfZmluYWxfcmVnaXN0ZXJfY2FsbGVkX3dpdGhvdXRfdmFsdWVcIlxuZXh0ZXJuYWwgZmluYWxpc2VfcmVsZWFzZSA6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9maW5hbF9yZWxlYXNlXCJcblxuXG50eXBlIGFsYXJtID0gYm9vbCByZWZcbnR5cGUgYWxhcm1fcmVjID0ge2FjdGl2ZSA6IGFsYXJtOyBmIDogdW5pdCAtPiB1bml0fVxuXG5sZXQgcmVjIGNhbGxfYWxhcm0gYXJlYyA9XG4gIGlmICEoYXJlYy5hY3RpdmUpIHRoZW4gYmVnaW5cbiAgICBmaW5hbGlzZSBjYWxsX2FsYXJtIGFyZWM7XG4gICAgYXJlYy5mICgpO1xuICBlbmRcblxuXG5sZXQgY3JlYXRlX2FsYXJtIGYgPVxuICBsZXQgYXJlYyA9IHsgYWN0aXZlID0gcmVmIHRydWU7IGYgPSBmIH0gaW5cbiAgZmluYWxpc2UgY2FsbF9hbGFybSBhcmVjO1xuICBhcmVjLmFjdGl2ZVxuXG5cbmxldCBkZWxldGVfYWxhcm0gYSA9IGEgOj0gZmFsc2VcblxubW9kdWxlIE1lbXByb2YgPVxuICBzdHJ1Y3RcbiAgICB0eXBlIGFsbG9jYXRpb25fc291cmNlID0gTm9ybWFsIHwgTWFyc2hhbCB8IEN1c3RvbVxuICAgIHR5cGUgYWxsb2NhdGlvbiA9XG4gICAgICB7IG5fc2FtcGxlcyA6IGludDtcbiAgICAgICAgc2l6ZSA6IGludDtcbiAgICAgICAgc291cmNlIDogYWxsb2NhdGlvbl9zb3VyY2U7XG4gICAgICAgIGNhbGxzdGFjayA6IFByaW50ZXhjLnJhd19iYWNrdHJhY2UgfVxuXG4gICAgdHlwZSAoJ21pbm9yLCAnbWFqb3IpIHRyYWNrZXIgPSB7XG4gICAgICBhbGxvY19taW5vcjogYWxsb2NhdGlvbiAtPiAnbWlub3Igb3B0aW9uO1xuICAgICAgYWxsb2NfbWFqb3I6IGFsbG9jYXRpb24gLT4gJ21ham9yIG9wdGlvbjtcbiAgICAgIHByb21vdGU6ICdtaW5vciAtPiAnbWFqb3Igb3B0aW9uO1xuICAgICAgZGVhbGxvY19taW5vcjogJ21pbm9yIC0+IHVuaXQ7XG4gICAgICBkZWFsbG9jX21ham9yOiAnbWFqb3IgLT4gdW5pdDtcbiAgICB9XG5cbiAgICBsZXQgbnVsbF90cmFja2VyID0ge1xuICAgICAgYWxsb2NfbWlub3IgPSAoZnVuIF8gLT4gTm9uZSk7XG4gICAgICBhbGxvY19tYWpvciA9IChmdW4gXyAtPiBOb25lKTtcbiAgICAgIHByb21vdGUgPSAoZnVuIF8gLT4gTm9uZSk7XG4gICAgICBkZWFsbG9jX21pbm9yID0gKGZ1biBfIC0+ICgpKTtcbiAgICAgIGRlYWxsb2NfbWFqb3IgPSAoZnVuIF8gLT4gKCkpO1xuICAgIH1cblxuICAgIGV4dGVybmFsIGNfc3RhcnQgOlxuICAgICAgZmxvYXQgLT4gaW50IC0+ICgnbWlub3IsICdtYWpvcikgdHJhY2tlciAtPiB1bml0XG4gICAgICA9IFwiY2FtbF9tZW1wcm9mX3N0YXJ0XCJcblxuICAgIGxldCBzdGFydFxuICAgICAgfnNhbXBsaW5nX3JhdGVcbiAgICAgID8oY2FsbHN0YWNrX3NpemUgPSBtYXhfaW50KVxuICAgICAgdHJhY2tlciA9XG4gICAgICBjX3N0YXJ0IHNhbXBsaW5nX3JhdGUgY2FsbHN0YWNrX3NpemUgdHJhY2tlclxuXG4gICAgZXh0ZXJuYWwgc3RvcCA6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9tZW1wcm9mX3N0b3BcIlxuICBlbmRcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogTWVzc2FnZSBkaWdlc3QgKE1ENSkgKilcblxudHlwZSB0ID0gc3RyaW5nXG5cbmxldCBjb21wYXJlID0gU3RyaW5nLmNvbXBhcmVcbmxldCBlcXVhbCA9IFN0cmluZy5lcXVhbFxuXG5leHRlcm5hbCB1bnNhZmVfc3RyaW5nOiBzdHJpbmcgLT4gaW50IC0+IGludCAtPiB0ID0gXCJjYW1sX21kNV9zdHJpbmdcIlxuZXh0ZXJuYWwgY2hhbm5lbDogaW5fY2hhbm5lbCAtPiBpbnQgLT4gdCA9IFwiY2FtbF9tZDVfY2hhblwiXG5cbmxldCBzdHJpbmcgc3RyID1cbiAgdW5zYWZlX3N0cmluZyBzdHIgMCAoU3RyaW5nLmxlbmd0aCBzdHIpXG5cbmxldCBieXRlcyBiID0gc3RyaW5nIChCeXRlcy51bnNhZmVfdG9fc3RyaW5nIGIpXG5cbmxldCBzdWJzdHJpbmcgc3RyIG9mcyBsZW4gPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gU3RyaW5nLmxlbmd0aCBzdHIgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIkRpZ2VzdC5zdWJzdHJpbmdcIlxuICBlbHNlIHVuc2FmZV9zdHJpbmcgc3RyIG9mcyBsZW5cblxubGV0IHN1YmJ5dGVzIGIgb2ZzIGxlbiA9IHN1YnN0cmluZyAoQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBiKSBvZnMgbGVuXG5cbmxldCBmaWxlIGZpbGVuYW1lID1cbiAgbGV0IGljID0gb3Blbl9pbl9iaW4gZmlsZW5hbWUgaW5cbiAgbWF0Y2ggY2hhbm5lbCBpYyAoLTEpIHdpdGhcbiAgICB8IGQgLT4gY2xvc2VfaW4gaWM7IGRcbiAgICB8IGV4Y2VwdGlvbiBlIC0+IGNsb3NlX2luIGljOyByYWlzZSBlXG5cbmxldCBvdXRwdXQgY2hhbiBkaWdlc3QgPVxuICBvdXRwdXRfc3RyaW5nIGNoYW4gZGlnZXN0XG5cbmxldCBpbnB1dCBjaGFuID0gcmVhbGx5X2lucHV0X3N0cmluZyBjaGFuIDE2XG5cbmxldCBjaGFyX2hleCBuID1cbiAgQ2hhci51bnNhZmVfY2hyIChuICsgaWYgbiA8IDEwIHRoZW4gQ2hhci5jb2RlICcwJyBlbHNlIChDaGFyLmNvZGUgJ2EnIC0gMTApKVxuXG5sZXQgdG9faGV4IGQgPVxuICBpZiBTdHJpbmcubGVuZ3RoIGQgPD4gMTYgdGhlbiBpbnZhbGlkX2FyZyBcIkRpZ2VzdC50b19oZXhcIjtcbiAgbGV0IHJlc3VsdCA9IEJ5dGVzLmNyZWF0ZSAzMiBpblxuICBmb3IgaSA9IDAgdG8gMTUgZG9cbiAgICBsZXQgeCA9IENoYXIuY29kZSBkLltpXSBpblxuICAgIEJ5dGVzLnVuc2FmZV9zZXQgcmVzdWx0IChpKjIpIChjaGFyX2hleCAoeCBsc3IgNCkpO1xuICAgIEJ5dGVzLnVuc2FmZV9zZXQgcmVzdWx0IChpKjIrMSkgKGNoYXJfaGV4ICh4IGxhbmQgMHgwZikpO1xuICBkb25lO1xuICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHJlc3VsdFxuXG5sZXQgZnJvbV9oZXggcyA9XG4gIGlmIFN0cmluZy5sZW5ndGggcyA8PiAzMiB0aGVuIGludmFsaWRfYXJnIFwiRGlnZXN0LmZyb21faGV4XCI7XG4gIGxldCBkaWdpdCBjID1cbiAgICBtYXRjaCBjIHdpdGhcbiAgICB8ICcwJy4uJzknIC0+IENoYXIuY29kZSBjIC0gQ2hhci5jb2RlICcwJ1xuICAgIHwgJ0EnLi4nRicgLT4gQ2hhci5jb2RlIGMgLSBDaGFyLmNvZGUgJ0EnICsgMTBcbiAgICB8ICdhJy4uJ2YnIC0+IENoYXIuY29kZSBjIC0gQ2hhci5jb2RlICdhJyArIDEwXG4gICAgfCBfIC0+IHJhaXNlIChJbnZhbGlkX2FyZ3VtZW50IFwiRGlnZXN0LmZyb21faGV4XCIpXG4gIGluXG4gIGxldCBieXRlIGkgPSBkaWdpdCBzLltpXSBsc2wgNCArIGRpZ2l0IHMuW2krMV0gaW5cbiAgbGV0IHJlc3VsdCA9IEJ5dGVzLmNyZWF0ZSAxNiBpblxuICBmb3IgaSA9IDAgdG8gMTUgZG9cbiAgICBCeXRlcy5zZXQgcmVzdWx0IGkgKENoYXIuY2hyIChieXRlICgyICogaSkpKTtcbiAgZG9uZTtcbiAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyByZXN1bHRcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgRGFtaWVuIERvbGlnZXosIHByb2pldCBQYXJhLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogUHNldWRvLXJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yXG4gICBUaGlzIGlzIGEgbGFnZ2VkLUZpYm9uYWNjaSBGKDU1LCAyNCwgKykgd2l0aCBhIG1vZGlmaWVkIGFkZGl0aW9uXG4gICBmdW5jdGlvbiB0byBlbmhhbmNlIHRoZSBtaXhpbmcgb2YgYml0cy5cbiAgIElmIHdlIHVzZSBub3JtYWwgYWRkaXRpb24sIHRoZSBsb3ctb3JkZXIgYml0IGZhaWxzIHRlc3RzIDEgYW5kIDdcbiAgIG9mIHRoZSBEaWVoYXJkIHRlc3Qgc3VpdGUsIGFuZCBiaXRzIDEgYW5kIDIgYWxzbyBmYWlsIHRlc3QgNy5cbiAgIElmIHdlIHVzZSBtdWx0aXBsaWNhdGlvbiBhcyBzdWdnZXN0ZWQgYnkgTWFyc2FnbGlhLCBpdCBkb2Vzbid0IGZhcmVcbiAgIG11Y2ggYmV0dGVyLlxuICAgQnkgbWl4aW5nIHRoZSBiaXRzIG9mIG9uZSBvZiB0aGUgbnVtYmVycyBiZWZvcmUgYWRkaXRpb24gKFhPUiB0aGVcbiAgIDUgaGlnaC1vcmRlciBiaXRzIGludG8gdGhlIGxvdy1vcmRlciBiaXRzKSwgd2UgZ2V0IGEgZ2VuZXJhdG9yIHRoYXRcbiAgIHBhc3NlcyBhbGwgdGhlIERpZWhhcmQgdGVzdHMuXG4qKVxuXG5leHRlcm5hbCByYW5kb21fc2VlZDogdW5pdCAtPiBpbnQgYXJyYXkgPSBcImNhbWxfc3lzX3JhbmRvbV9zZWVkXCJcblxubW9kdWxlIFN0YXRlID0gc3RydWN0XG5cbiAgdHlwZSB0ID0geyBzdCA6IGludCBhcnJheTsgbXV0YWJsZSBpZHggOiBpbnQgfVxuXG4gIGxldCBuZXdfc3RhdGUgKCkgPSB7IHN0ID0gQXJyYXkubWFrZSA1NSAwOyBpZHggPSAwIH1cbiAgbGV0IGFzc2lnbiBzdDEgc3QyID1cbiAgICBBcnJheS5ibGl0IHN0Mi5zdCAwIHN0MS5zdCAwIDU1O1xuICAgIHN0MS5pZHggPC0gc3QyLmlkeFxuXG5cbiAgbGV0IGZ1bGxfaW5pdCBzIHNlZWQgPVxuICAgIGxldCBjb21iaW5lIGFjY3UgeCA9IERpZ2VzdC5zdHJpbmcgKGFjY3UgXiBJbnQudG9fc3RyaW5nIHgpIGluXG4gICAgbGV0IGV4dHJhY3QgZCA9XG4gICAgICBDaGFyLmNvZGUgZC5bMF0gKyAoQ2hhci5jb2RlIGQuWzFdIGxzbCA4KSArIChDaGFyLmNvZGUgZC5bMl0gbHNsIDE2KVxuICAgICAgKyAoQ2hhci5jb2RlIGQuWzNdIGxzbCAyNClcbiAgICBpblxuICAgIGxldCBzZWVkID0gaWYgQXJyYXkubGVuZ3RoIHNlZWQgPSAwIHRoZW4gW3wgMCB8XSBlbHNlIHNlZWQgaW5cbiAgICBsZXQgbCA9IEFycmF5Lmxlbmd0aCBzZWVkIGluXG4gICAgZm9yIGkgPSAwIHRvIDU0IGRvXG4gICAgICBzLnN0LihpKSA8LSBpO1xuICAgIGRvbmU7XG4gICAgbGV0IGFjY3UgPSByZWYgXCJ4XCIgaW5cbiAgICBmb3IgaSA9IDAgdG8gNTQgKyBtYXggNTUgbCBkb1xuICAgICAgbGV0IGogPSBpIG1vZCA1NSBpblxuICAgICAgbGV0IGsgPSBpIG1vZCBsIGluXG4gICAgICBhY2N1IDo9IGNvbWJpbmUgIWFjY3Ugc2VlZC4oayk7XG4gICAgICBzLnN0LihqKSA8LSAocy5zdC4oaikgbHhvciBleHRyYWN0ICFhY2N1KSBsYW5kIDB4M0ZGRkZGRkY7ICAoKiBQUiM1NTc1ICopXG4gICAgZG9uZTtcbiAgICBzLmlkeCA8LSAwXG5cblxuICBsZXQgbWFrZSBzZWVkID1cbiAgICBsZXQgcmVzdWx0ID0gbmV3X3N0YXRlICgpIGluXG4gICAgZnVsbF9pbml0IHJlc3VsdCBzZWVkO1xuICAgIHJlc3VsdFxuXG5cbiAgbGV0IG1ha2Vfc2VsZl9pbml0ICgpID0gbWFrZSAocmFuZG9tX3NlZWQgKCkpXG5cbiAgbGV0IGNvcHkgcyA9XG4gICAgbGV0IHJlc3VsdCA9IG5ld19zdGF0ZSAoKSBpblxuICAgIGFzc2lnbiByZXN1bHQgcztcbiAgICByZXN1bHRcblxuXG4gICgqIFJldHVybnMgMzAgcmFuZG9tIGJpdHMgYXMgYW4gaW50ZWdlciAwIDw9IHggPCAxMDczNzQxODI0ICopXG4gIGxldCBiaXRzIHMgPVxuICAgIHMuaWR4IDwtIChzLmlkeCArIDEpIG1vZCA1NTtcbiAgICBsZXQgY3VydmFsID0gcy5zdC4ocy5pZHgpIGluXG4gICAgbGV0IG5ld3ZhbCA9IHMuc3QuKChzLmlkeCArIDI0KSBtb2QgNTUpXG4gICAgICAgICAgICAgICAgICsgKGN1cnZhbCBseG9yICgoY3VydmFsIGxzciAyNSkgbGFuZCAweDFGKSkgaW5cbiAgICBsZXQgbmV3dmFsMzAgPSBuZXd2YWwgbGFuZCAweDNGRkZGRkZGIGluICAoKiBQUiM1NTc1ICopXG4gICAgcy5zdC4ocy5pZHgpIDwtIG5ld3ZhbDMwO1xuICAgIG5ld3ZhbDMwXG5cblxuICBsZXQgcmVjIGludGF1eCBzIG4gPVxuICAgIGxldCByID0gYml0cyBzIGluXG4gICAgbGV0IHYgPSByIG1vZCBuIGluXG4gICAgaWYgciAtIHYgPiAweDNGRkZGRkZGIC0gbiArIDEgdGhlbiBpbnRhdXggcyBuIGVsc2UgdlxuXG4gIGxldCBpbnQgcyBib3VuZCA9XG4gICAgaWYgYm91bmQgPiAweDNGRkZGRkZGIHx8IGJvdW5kIDw9IDBcbiAgICB0aGVuIGludmFsaWRfYXJnIFwiUmFuZG9tLmludFwiXG4gICAgZWxzZSBpbnRhdXggcyBib3VuZFxuXG5cbiAgbGV0IHJlYyBpbnQzMmF1eCBzIG4gPVxuICAgIGxldCBiMSA9IEludDMyLm9mX2ludCAoYml0cyBzKSBpblxuICAgIGxldCBiMiA9IEludDMyLnNoaWZ0X2xlZnQgKEludDMyLm9mX2ludCAoYml0cyBzIGxhbmQgMSkpIDMwIGluXG4gICAgbGV0IHIgPSBJbnQzMi5sb2dvciBiMSBiMiBpblxuICAgIGxldCB2ID0gSW50MzIucmVtIHIgbiBpblxuICAgIGlmIEludDMyLnN1YiByIHYgPiBJbnQzMi5hZGQgKEludDMyLnN1YiBJbnQzMi5tYXhfaW50IG4pIDFsXG4gICAgdGhlbiBpbnQzMmF1eCBzIG5cbiAgICBlbHNlIHZcblxuICBsZXQgaW50MzIgcyBib3VuZCA9XG4gICAgaWYgYm91bmQgPD0gMGxcbiAgICB0aGVuIGludmFsaWRfYXJnIFwiUmFuZG9tLmludDMyXCJcbiAgICBlbHNlIGludDMyYXV4IHMgYm91bmRcblxuXG4gIGxldCByZWMgaW50NjRhdXggcyBuID1cbiAgICBsZXQgYjEgPSBJbnQ2NC5vZl9pbnQgKGJpdHMgcykgaW5cbiAgICBsZXQgYjIgPSBJbnQ2NC5zaGlmdF9sZWZ0IChJbnQ2NC5vZl9pbnQgKGJpdHMgcykpIDMwIGluXG4gICAgbGV0IGIzID0gSW50NjQuc2hpZnRfbGVmdCAoSW50NjQub2ZfaW50IChiaXRzIHMgbGFuZCA3KSkgNjAgaW5cbiAgICBsZXQgciA9IEludDY0LmxvZ29yIGIxIChJbnQ2NC5sb2dvciBiMiBiMykgaW5cbiAgICBsZXQgdiA9IEludDY0LnJlbSByIG4gaW5cbiAgICBpZiBJbnQ2NC5zdWIgciB2ID4gSW50NjQuYWRkIChJbnQ2NC5zdWIgSW50NjQubWF4X2ludCBuKSAxTFxuICAgIHRoZW4gaW50NjRhdXggcyBuXG4gICAgZWxzZSB2XG5cbiAgbGV0IGludDY0IHMgYm91bmQgPVxuICAgIGlmIGJvdW5kIDw9IDBMXG4gICAgdGhlbiBpbnZhbGlkX2FyZyBcIlJhbmRvbS5pbnQ2NFwiXG4gICAgZWxzZSBpbnQ2NGF1eCBzIGJvdW5kXG5cblxuICBsZXQgbmF0aXZlaW50ID1cbiAgICBpZiBOYXRpdmVpbnQuc2l6ZSA9IDMyXG4gICAgdGhlbiBmdW4gcyBib3VuZCAtPiBOYXRpdmVpbnQub2ZfaW50MzIgKGludDMyIHMgKE5hdGl2ZWludC50b19pbnQzMiBib3VuZCkpXG4gICAgZWxzZSBmdW4gcyBib3VuZCAtPiBJbnQ2NC50b19uYXRpdmVpbnQgKGludDY0IHMgKEludDY0Lm9mX25hdGl2ZWludCBib3VuZCkpXG5cblxuICAoKiBSZXR1cm5zIGEgZmxvYXQgMCA8PSB4IDw9IDEgd2l0aCBhdCBtb3N0IDYwIGJpdHMgb2YgcHJlY2lzaW9uLiAqKVxuICBsZXQgcmF3ZmxvYXQgcyA9XG4gICAgbGV0IHNjYWxlID0gMTA3Mzc0MTgyNC4wICAoKiAyXjMwICopXG4gICAgYW5kIHIxID0gU3RkbGliLmZsb2F0IChiaXRzIHMpXG4gICAgYW5kIHIyID0gU3RkbGliLmZsb2F0IChiaXRzIHMpXG4gICAgaW4gKHIxIC8uIHNjYWxlICsuIHIyKSAvLiBzY2FsZVxuXG5cbiAgbGV0IGZsb2F0IHMgYm91bmQgPSByYXdmbG9hdCBzICouIGJvdW5kXG5cbiAgbGV0IGJvb2wgcyA9IChiaXRzIHMgbGFuZCAxID0gMClcblxuZW5kXG5cbigqIFRoaXMgaXMgdGhlIHN0YXRlIHlvdSBnZXQgd2l0aCBbaW5pdCAyNzE4MjgxOF0gYW5kIHRoZW4gYXBwbHlpbmdcbiAgIHRoZSBcImxhbmQgMHgzRkZGRkZGRlwiIGZpbHRlciB0byB0aGVtLiAgU2VlICM1NTc1LCAjNTc5MywgIzU5NzcuICopXG5sZXQgZGVmYXVsdCA9IHtcbiAgU3RhdGUuc3QgPSBbfFxuICAgICAgMHgzYWUyNTIyYjsgMHgxZDhkNDYzNDsgMHgxNWI0ZmFkMDsgMHgxOGIxNGFjZTsgMHgxMmY4YTNjNDsgMHgzYjA4NmM0NztcbiAgICAgIDB4MTZkNDY3ZDY7IDB4MTAxZDkxYzc7IDB4MzIxZGYxNzc7IDB4MDE3NmMxOTM7IDB4MWZmNzJiZjE7IDB4MWU4ODkxMDk7XG4gICAgICAweDBiNDY0YjE4OyAweDJiODZiOTdjOyAweDA4OTFkYTQ4OyAweDAzMTM3NDYzOyAweDA4NWFjNWExOyAweDE1ZDYxZjJmO1xuICAgICAgMHgzYmNlZDM1OTsgMHgyOWMxYzEzMjsgMHgzYTg2NzY2ZTsgMHgzNjZkOGM4NjsgMHgxZjViNjIyMjsgMHgzY2UxYjU5ZjtcbiAgICAgIDB4MmViZjc4ZTE7IDB4MjdjZDFiODY7IDB4MjU4ZjNkYzM7IDB4Mzg5YTgxOTQ7IDB4MDJlNGM0NGM7IDB4MThjNDNmN2Q7XG4gICAgICAweDBmNmU1MzRmOyAweDFlN2RmMzU5OyAweDA1NWQwYjdlOyAweDEwZTg0ZTdlOyAweDEyNjE5OGU0OyAweDBlNzcyMmNiO1xuICAgICAgMHgxY2JlZGUyODsgMHgzMzkxYjk2NDsgMHgzZDQwZTkyYTsgMHgwYzU5OTMzZDsgMHgwYjhjZDBiNzsgMHgyNGVmZmYxYztcbiAgICAgIDB4MjgwM2ZkYWE7IDB4MDhlYmM3MmU7IDB4MGY1MjJlMzI7IDB4MDUzOThlZGM7IDB4MjE0NGEwNGM7IDB4MGFlZjNjYmQ7XG4gICAgICAweDAxYWQ0NzE5OyAweDM1YjkzY2Q2OyAweDJhNTU5ZDRmOyAweDFlNmZkNzY4OyAweDI2ZTI3ZjM2OyAweDE4NmYxOGMzO1xuICAgICAgMHgyZmJmOTY3YTtcbiAgICB8XTtcbiAgU3RhdGUuaWR4ID0gMDtcbn1cblxubGV0IGJpdHMgKCkgPSBTdGF0ZS5iaXRzIGRlZmF1bHRcbmxldCBpbnQgYm91bmQgPSBTdGF0ZS5pbnQgZGVmYXVsdCBib3VuZFxubGV0IGludDMyIGJvdW5kID0gU3RhdGUuaW50MzIgZGVmYXVsdCBib3VuZFxubGV0IG5hdGl2ZWludCBib3VuZCA9IFN0YXRlLm5hdGl2ZWludCBkZWZhdWx0IGJvdW5kXG5sZXQgaW50NjQgYm91bmQgPSBTdGF0ZS5pbnQ2NCBkZWZhdWx0IGJvdW5kXG5sZXQgZmxvYXQgc2NhbGUgPSBTdGF0ZS5mbG9hdCBkZWZhdWx0IHNjYWxlXG5sZXQgYm9vbCAoKSA9IFN0YXRlLmJvb2wgZGVmYXVsdFxuXG5sZXQgZnVsbF9pbml0IHNlZWQgPSBTdGF0ZS5mdWxsX2luaXQgZGVmYXVsdCBzZWVkXG5sZXQgaW5pdCBzZWVkID0gU3RhdGUuZnVsbF9pbml0IGRlZmF1bHQgW3wgc2VlZCB8XVxubGV0IHNlbGZfaW5pdCAoKSA9IGZ1bGxfaW5pdCAocmFuZG9tX3NlZWQoKSlcblxuKCogTWFuaXB1bGF0aW5nIHRoZSBjdXJyZW50IHN0YXRlLiAqKVxuXG5sZXQgZ2V0X3N0YXRlICgpID0gU3RhdGUuY29weSBkZWZhdWx0XG5sZXQgc2V0X3N0YXRlIHMgPSBTdGF0ZS5hc3NpZ24gZGVmYXVsdCBzXG5cbigqKioqKioqKioqKioqKioqKioqKlxuXG4oKiBUZXN0IGZ1bmN0aW9ucy4gIE5vdCBpbmNsdWRlZCBpbiB0aGUgbGlicmFyeS5cbiAgIFRoZSBbY2hpc3F1YXJlXSBmdW5jdGlvbiBzaG91bGQgYmUgY2FsbGVkIHdpdGggbiA+IDEwci5cbiAgIEl0IHJldHVybnMgYSB0cmlwbGUgKGxvdywgYWN0dWFsLCBoaWdoKS5cbiAgIElmIGxvdyA8PSBhY3R1YWwgPD0gaGlnaCwgdGhlIFtnXSBmdW5jdGlvbiBwYXNzZWQgdGhlIHRlc3QsXG4gICBvdGhlcndpc2UgaXQgZmFpbGVkLlxuXG4gIFNvbWUgcmVzdWx0czpcblxuaW5pdCAyNzE4MjgxODsgY2hpc3F1YXJlIGludCAxMDAwMDAgMTAwMFxuaW5pdCAyNzE4MjgxODsgY2hpc3F1YXJlIGludCAxMDAwMDAgMTAwXG5pbml0IDI3MTgyODE4OyBjaGlzcXVhcmUgaW50IDEwMDAwMCA1MDAwXG5pbml0IDI3MTgyODE4OyBjaGlzcXVhcmUgaW50IDEwMDAwMDAgMTAwMFxuaW5pdCAyNzE4MjgxODsgY2hpc3F1YXJlIGludCAxMDAwMDAgMTAyNFxuaW5pdCAyOTk3OTI2NDM7IGNoaXNxdWFyZSBpbnQgMTAwMDAwIDEwMjRcbmluaXQgMTQxNDIxMzY7IGNoaXNxdWFyZSBpbnQgMTAwMDAwIDEwMjRcbmluaXQgMjcxODI4MTg7IGluaXRfZGlmZiAxMDI0OyBjaGlzcXVhcmUgZGlmZiAxMDAwMDAgMTAyNFxuaW5pdCAyNzE4MjgxODsgaW5pdF9kaWZmIDEwMDsgY2hpc3F1YXJlIGRpZmYgMTAwMDAwIDEwMFxuaW5pdCAyNzE4MjgxODsgaW5pdF9kaWZmMiAxMDI0OyBjaGlzcXVhcmUgZGlmZjIgMTAwMDAwIDEwMjRcbmluaXQgMjcxODI4MTg7IGluaXRfZGlmZjIgMTAwOyBjaGlzcXVhcmUgZGlmZjIgMTAwMDAwIDEwMFxuaW5pdCAxNDE0MjEzNjsgaW5pdF9kaWZmMiAxMDA7IGNoaXNxdWFyZSBkaWZmMiAxMDAwMDAgMTAwXG5pbml0IDI5OTc5MjY0MzsgaW5pdF9kaWZmMiAxMDA7IGNoaXNxdWFyZSBkaWZmMiAxMDAwMDAgMTAwXG4tIDogZmxvYXQgKiBmbG9hdCAqIGZsb2F0ID0gKDkzNi43NTQ0NDY3OTY2MzI0NjUsIDk5Ny41LCAxMDYzLjI0NTU1MzIwMzM2NzU0KVxuIyAtIDogZmxvYXQgKiBmbG9hdCAqIGZsb2F0ID0gKDgwLiwgODkuNzQwMDAwMDAwMDA1MjM4NywgMTIwLilcbiMgLSA6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCA9ICg0ODU4LjU3ODY0Mzc2MjY5LCA1MDQ1LjUsIDUxNDEuNDIxMzU2MjM3MzEpXG4jIC0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPVxuKDkzNi43NTQ0NDY3OTY2MzI0NjUsIDk0NC44MDU5OTk5OTk5ODIzMDUsIDEwNjMuMjQ1NTUzMjAzMzY3NTQpXG4jIC0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPSAoOTYwLiwgMTAxOS4xOTc0NDAwMDAwMDM1NSwgMTA4OC4pXG4jIC0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPSAoOTYwLiwgMTA1OS4zMTc3NjAwMDAwMDUzNiwgMTA4OC4pXG4jIC0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPSAoOTYwLiwgMTAzOS45ODQ2Mzk5OTk5OTUxMiwgMTA4OC4pXG4jIC0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPSAoOTYwLiwgMTA1NC4zODIwNzk5OTk5OTU3NywgMTA4OC4pXG4jIC0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPSAoODAuLCA5MC4wOTYwMDAwMDAwMDUsIDEyMC4pXG4jIC0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPSAoOTYwLiwgMTA3Ni43ODcyMDAwMDAwMDYxMiwgMTA4OC4pXG4jIC0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPSAoODAuLCA4NS4xNzYwMDAwMDAwMDY3NTIxLCAxMjAuKVxuIyAtIDogZmxvYXQgKiBmbG9hdCAqIGZsb2F0ID0gKDgwLiwgODUuMjE2MDAwMDAwMDAwMzQ5MiwgMTIwLilcbiMgLSA6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCA9ICg4MC4sIDgwLjYyMjAwMDAwMDAwMzAyNjgsIDEyMC4pXG5cbiopXG5cbigqIFJldHVybiB0aGUgc3VtIG9mIHRoZSBzcXVhcmVzIG9mIHZbaTAsaTFbICopXG5sZXQgcmVjIHN1bXNxIHYgaTAgaTEgPVxuICBpZiBpMCA+PSBpMSB0aGVuIDAuMFxuICBlbHNlIGlmIGkxID0gaTAgKyAxIHRoZW4gU3RkbGliLmZsb2F0IHYuKGkwKSAqLiBTdGRsaWIuZmxvYXQgdi4oaTApXG4gIGVsc2Ugc3Vtc3EgdiBpMCAoKGkwK2kxKS8yKSArLiBzdW1zcSB2ICgoaTAraTEpLzIpIGkxXG5cblxubGV0IGNoaXNxdWFyZSBnIG4gciA9XG4gIGlmIG4gPD0gMTAgKiByIHRoZW4gaW52YWxpZF9hcmcgXCJjaGlzcXVhcmVcIjtcbiAgbGV0IGYgPSBBcnJheS5tYWtlIHIgMCBpblxuICBmb3IgaSA9IDEgdG8gbiBkb1xuICAgIGxldCB0ID0gZyByIGluXG4gICAgZi4odCkgPC0gZi4odCkgKyAxXG4gIGRvbmU7XG4gIGxldCB0ID0gc3Vtc3EgZiAwIHJcbiAgYW5kIHIgPSBTdGRsaWIuZmxvYXQgclxuICBhbmQgbiA9IFN0ZGxpYi5mbG9hdCBuIGluXG4gIGxldCBzciA9IDIuMCAqLiBzcXJ0IHIgaW5cbiAgKHIgLS4gc3IsICAgKHIgKi4gdCAvLiBuKSAtLiBuLCAgIHIgKy4gc3IpXG5cblxuKCogVGhpcyBpcyB0byB0ZXN0IGZvciBsaW5lYXIgZGVwZW5kZW5jaWVzIGJldHdlZW4gc3VjY2Vzc2l2ZSByYW5kb20gbnVtYmVycy5cbiopXG5sZXQgc3QgPSByZWYgMFxubGV0IGluaXRfZGlmZiByID0gc3QgOj0gaW50IHJcbmxldCBkaWZmIHIgPVxuICBsZXQgeDEgPSAhc3RcbiAgYW5kIHgyID0gaW50IHJcbiAgaW5cbiAgc3QgOj0geDI7XG4gIGlmIHgxID49IHgyIHRoZW5cbiAgICB4MSAtIHgyXG4gIGVsc2VcbiAgICByICsgeDEgLSB4MlxuXG5cbmxldCBzdDEgPSByZWYgMFxuYW5kIHN0MiA9IHJlZiAwXG5cblxuKCogVGhpcyBpcyB0byB0ZXN0IGZvciBxdWFkcmF0aWMgZGVwZW5kZW5jaWVzIGJldHdlZW4gc3VjY2Vzc2l2ZSByYW5kb21cbiAgIG51bWJlcnMuXG4qKVxubGV0IGluaXRfZGlmZjIgciA9IHN0MSA6PSBpbnQgcjsgc3QyIDo9IGludCByXG5sZXQgZGlmZjIgciA9XG4gIGxldCB4MSA9ICFzdDFcbiAgYW5kIHgyID0gIXN0MlxuICBhbmQgeDMgPSBpbnQgclxuICBpblxuICBzdDEgOj0geDI7XG4gIHN0MiA6PSB4MztcbiAgKHgzIC0geDIgLSB4MiArIHgxICsgMipyKSBtb2QgclxuXG5cbioqKioqKioqKioqKioqKioqKioqKVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBIYXNoIHRhYmxlcyAqKVxuXG4oKiBXZSBkbyBkeW5hbWljIGhhc2hpbmcsIGFuZCByZXNpemUgdGhlIHRhYmxlIGFuZCByZWhhc2ggdGhlIGVsZW1lbnRzXG4gICB3aGVuIGJ1Y2tldHMgYmVjb21lIHRvbyBsb25nLiAqKVxuXG50eXBlICgnYSwgJ2IpIHQgPVxuICB7IG11dGFibGUgc2l6ZTogaW50OyAgICAgICAgICAgICAgICAgICAgICAgICgqIG51bWJlciBvZiBlbnRyaWVzICopXG4gICAgbXV0YWJsZSBkYXRhOiAoJ2EsICdiKSBidWNrZXRsaXN0IGFycmF5OyAgKCogdGhlIGJ1Y2tldHMgKilcbiAgICBtdXRhYmxlIHNlZWQ6IGludDsgICAgICAgICAgICAgICAgICAgICAgICAoKiBmb3IgcmFuZG9taXphdGlvbiAqKVxuICAgIG11dGFibGUgaW5pdGlhbF9zaXplOiBpbnQ7ICAgICAgICAgICAgICAgICgqIGluaXRpYWwgYXJyYXkgc2l6ZSAqKVxuICB9XG5cbmFuZCAoJ2EsICdiKSBidWNrZXRsaXN0ID1cbiAgICBFbXB0eVxuICB8IENvbnMgb2YgeyBtdXRhYmxlIGtleTogJ2E7XG4gICAgICAgICAgICAgIG11dGFibGUgZGF0YTogJ2I7XG4gICAgICAgICAgICAgIG11dGFibGUgbmV4dDogKCdhLCAnYikgYnVja2V0bGlzdCB9XG5cbigqIFRoZSBzaWduIG9mIGluaXRpYWxfc2l6ZSBlbmNvZGVzIHRoZSBmYWN0IHRoYXQgYSB0cmF2ZXJzYWwgaXNcbiAgIG9uZ29pbmcgb3Igbm90LlxuXG4gICBUaGlzIGRpc2FibGVzIHRoZSBlZmZpY2llbnQgaW4gcGxhY2UgaW1wbGVtZW50YXRpb24gb2YgcmVzaXppbmcuXG4qKVxuXG5sZXQgb25nb2luZ190cmF2ZXJzYWwgaCA9XG4gIE9iai5zaXplIChPYmoucmVwciBoKSA8IDQgKCogY29tcGF0aWJpbGl0eSB3aXRoIG9sZCBoYXNoIHRhYmxlcyAqKVxuICB8fCBoLmluaXRpYWxfc2l6ZSA8IDBcblxubGV0IGZsaXBfb25nb2luZ190cmF2ZXJzYWwgaCA9XG4gIGguaW5pdGlhbF9zaXplIDwtIC0gaC5pbml0aWFsX3NpemVcblxuKCogVG8gcGljayByYW5kb20gc2VlZHMgaWYgcmVxdWVzdGVkICopXG5cbmxldCByYW5kb21pemVkX2RlZmF1bHQgPVxuICBsZXQgcGFyYW1zID1cbiAgICB0cnkgU3lzLmdldGVudiBcIk9DQU1MUlVOUEFSQU1cIiB3aXRoIE5vdF9mb3VuZCAtPlxuICAgIHRyeSBTeXMuZ2V0ZW52IFwiQ0FNTFJVTlBBUkFNXCIgd2l0aCBOb3RfZm91bmQgLT4gXCJcIiBpblxuICBTdHJpbmcuY29udGFpbnMgcGFyYW1zICdSJ1xuXG5sZXQgcmFuZG9taXplZCA9IHJlZiByYW5kb21pemVkX2RlZmF1bHRcblxubGV0IHJhbmRvbWl6ZSAoKSA9IHJhbmRvbWl6ZWQgOj0gdHJ1ZVxubGV0IGlzX3JhbmRvbWl6ZWQgKCkgPSAhcmFuZG9taXplZFxuXG5sZXQgcHJuZyA9IGxhenkgKFJhbmRvbS5TdGF0ZS5tYWtlX3NlbGZfaW5pdCgpKVxuXG4oKiBGdW5jdGlvbnMgd2hpY2ggYXBwZWFyIGJlZm9yZSB0aGUgZnVuY3RvcmlhbCBpbnRlcmZhY2UgbXVzdCBlaXRoZXIgYmVcbiAgIGluZGVwZW5kZW50IG9mIHRoZSBoYXNoIGZ1bmN0aW9uIG9yIHRha2UgaXQgYXMgYSBwYXJhbWV0ZXIgKHNlZSAjMjIwMiBhbmRcbiAgIGNvZGUgYmVsb3cgdGhlIGZ1bmN0b3IgZGVmaW5pdGlvbnMuICopXG5cbigqIENyZWF0aW5nIGEgZnJlc2gsIGVtcHR5IHRhYmxlICopXG5cbmxldCByZWMgcG93ZXJfMl9hYm92ZSB4IG4gPVxuICBpZiB4ID49IG4gdGhlbiB4XG4gIGVsc2UgaWYgeCAqIDIgPiBTeXMubWF4X2FycmF5X2xlbmd0aCB0aGVuIHhcbiAgZWxzZSBwb3dlcl8yX2Fib3ZlICh4ICogMikgblxuXG5sZXQgY3JlYXRlID8ocmFuZG9tID0gIXJhbmRvbWl6ZWQpIGluaXRpYWxfc2l6ZSA9XG4gIGxldCBzID0gcG93ZXJfMl9hYm92ZSAxNiBpbml0aWFsX3NpemUgaW5cbiAgbGV0IHNlZWQgPSBpZiByYW5kb20gdGhlbiBSYW5kb20uU3RhdGUuYml0cyAoTGF6eS5mb3JjZSBwcm5nKSBlbHNlIDAgaW5cbiAgeyBpbml0aWFsX3NpemUgPSBzOyBzaXplID0gMDsgc2VlZCA9IHNlZWQ7IGRhdGEgPSBBcnJheS5tYWtlIHMgRW1wdHkgfVxuXG5sZXQgY2xlYXIgaCA9XG4gIGlmIGguc2l6ZSA+IDAgdGhlbiBiZWdpblxuICAgIGguc2l6ZSA8LSAwO1xuICAgIEFycmF5LmZpbGwgaC5kYXRhIDAgKEFycmF5Lmxlbmd0aCBoLmRhdGEpIEVtcHR5XG4gIGVuZFxuXG5sZXQgcmVzZXQgaCA9XG4gIGxldCBsZW4gPSBBcnJheS5sZW5ndGggaC5kYXRhIGluXG4gIGlmIE9iai5zaXplIChPYmoucmVwciBoKSA8IDQgKCogY29tcGF0aWJpbGl0eSB3aXRoIG9sZCBoYXNoIHRhYmxlcyAqKVxuICAgIHx8IGxlbiA9IGFicyBoLmluaXRpYWxfc2l6ZSB0aGVuXG4gICAgY2xlYXIgaFxuICBlbHNlIGJlZ2luXG4gICAgaC5zaXplIDwtIDA7XG4gICAgaC5kYXRhIDwtIEFycmF5Lm1ha2UgKGFicyBoLmluaXRpYWxfc2l6ZSkgRW1wdHlcbiAgZW5kXG5cbmxldCBjb3B5X2J1Y2tldGxpc3QgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+IEVtcHR5XG4gIHwgQ29ucyB7a2V5OyBkYXRhOyBuZXh0fSAtPlxuICAgICAgbGV0IHJlYyBsb29wIHByZWMgPSBmdW5jdGlvblxuICAgICAgICB8IEVtcHR5IC0+ICgpXG4gICAgICAgIHwgQ29ucyB7a2V5OyBkYXRhOyBuZXh0fSAtPlxuICAgICAgICAgICAgbGV0IHIgPSBDb25zIHtrZXk7IGRhdGE7IG5leHR9IGluXG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBwcmVjIHdpdGhcbiAgICAgICAgICAgIHwgRW1wdHkgLT4gYXNzZXJ0IGZhbHNlXG4gICAgICAgICAgICB8IENvbnMgcHJlYyAtPiAgcHJlYy5uZXh0IDwtIHJcbiAgICAgICAgICAgIGVuZDtcbiAgICAgICAgICAgIGxvb3AgciBuZXh0XG4gICAgICBpblxuICAgICAgbGV0IHIgPSBDb25zIHtrZXk7IGRhdGE7IG5leHR9IGluXG4gICAgICBsb29wIHIgbmV4dDtcbiAgICAgIHJcblxubGV0IGNvcHkgaCA9IHsgaCB3aXRoIGRhdGEgPSBBcnJheS5tYXAgY29weV9idWNrZXRsaXN0IGguZGF0YSB9XG5cbmxldCBsZW5ndGggaCA9IGguc2l6ZVxuXG5sZXQgaW5zZXJ0X2FsbF9idWNrZXRzIGluZGV4ZnVuIGlucGxhY2Ugb2RhdGEgbmRhdGEgPVxuICBsZXQgbnNpemUgPSBBcnJheS5sZW5ndGggbmRhdGEgaW5cbiAgbGV0IG5kYXRhX3RhaWwgPSBBcnJheS5tYWtlIG5zaXplIEVtcHR5IGluXG4gIGxldCByZWMgaW5zZXJ0X2J1Y2tldCA9IGZ1bmN0aW9uXG4gICAgfCBFbXB0eSAtPiAoKVxuICAgIHwgQ29ucyB7a2V5OyBkYXRhOyBuZXh0fSBhcyBjZWxsIC0+XG4gICAgICAgIGxldCBjZWxsID1cbiAgICAgICAgICBpZiBpbnBsYWNlIHRoZW4gY2VsbFxuICAgICAgICAgIGVsc2UgQ29ucyB7a2V5OyBkYXRhOyBuZXh0ID0gRW1wdHl9XG4gICAgICAgIGluXG4gICAgICAgIGxldCBuaWR4ID0gaW5kZXhmdW4ga2V5IGluXG4gICAgICAgIGJlZ2luIG1hdGNoIG5kYXRhX3RhaWwuKG5pZHgpIHdpdGhcbiAgICAgICAgfCBFbXB0eSAtPiBuZGF0YS4obmlkeCkgPC0gY2VsbDtcbiAgICAgICAgfCBDb25zIHRhaWwgLT4gdGFpbC5uZXh0IDwtIGNlbGw7XG4gICAgICAgIGVuZDtcbiAgICAgICAgbmRhdGFfdGFpbC4obmlkeCkgPC0gY2VsbDtcbiAgICAgICAgaW5zZXJ0X2J1Y2tldCBuZXh0XG4gIGluXG4gIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggb2RhdGEgLSAxIGRvXG4gICAgaW5zZXJ0X2J1Y2tldCBvZGF0YS4oaSlcbiAgZG9uZTtcbiAgaWYgaW5wbGFjZSB0aGVuXG4gICAgZm9yIGkgPSAwIHRvIG5zaXplIC0gMSBkb1xuICAgICAgbWF0Y2ggbmRhdGFfdGFpbC4oaSkgd2l0aFxuICAgICAgfCBFbXB0eSAtPiAoKVxuICAgICAgfCBDb25zIHRhaWwgLT4gdGFpbC5uZXh0IDwtIEVtcHR5XG4gICAgZG9uZVxuXG5sZXQgcmVzaXplIGluZGV4ZnVuIGggPVxuICBsZXQgb2RhdGEgPSBoLmRhdGEgaW5cbiAgbGV0IG9zaXplID0gQXJyYXkubGVuZ3RoIG9kYXRhIGluXG4gIGxldCBuc2l6ZSA9IG9zaXplICogMiBpblxuICBpZiBuc2l6ZSA8IFN5cy5tYXhfYXJyYXlfbGVuZ3RoIHRoZW4gYmVnaW5cbiAgICBsZXQgbmRhdGEgPSBBcnJheS5tYWtlIG5zaXplIEVtcHR5IGluXG4gICAgbGV0IGlucGxhY2UgPSBub3QgKG9uZ29pbmdfdHJhdmVyc2FsIGgpIGluXG4gICAgaC5kYXRhIDwtIG5kYXRhOyAgICAgICAgICAoKiBzbyB0aGF0IGluZGV4ZnVuIHNlZXMgdGhlIG5ldyBidWNrZXQgY291bnQgKilcbiAgICBpbnNlcnRfYWxsX2J1Y2tldHMgKGluZGV4ZnVuIGgpIGlucGxhY2Ugb2RhdGEgbmRhdGFcbiAgZW5kXG5cbmxldCBpdGVyIGYgaCA9XG4gIGxldCByZWMgZG9fYnVja2V0ID0gZnVuY3Rpb25cbiAgICB8IEVtcHR5IC0+XG4gICAgICAgICgpXG4gICAgfCBDb25ze2tleTsgZGF0YTsgbmV4dH0gLT5cbiAgICAgICAgZiBrZXkgZGF0YTsgZG9fYnVja2V0IG5leHQgaW5cbiAgbGV0IG9sZF90cmF2ID0gb25nb2luZ190cmF2ZXJzYWwgaCBpblxuICBpZiBub3Qgb2xkX3RyYXYgdGhlbiBmbGlwX29uZ29pbmdfdHJhdmVyc2FsIGg7XG4gIHRyeVxuICAgIGxldCBkID0gaC5kYXRhIGluXG4gICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCBkIC0gMSBkb1xuICAgICAgZG9fYnVja2V0IGQuKGkpXG4gICAgZG9uZTtcbiAgICBpZiBub3Qgb2xkX3RyYXYgdGhlbiBmbGlwX29uZ29pbmdfdHJhdmVyc2FsIGg7XG4gIHdpdGggZXhuIHdoZW4gbm90IG9sZF90cmF2IC0+XG4gICAgZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoO1xuICAgIHJhaXNlIGV4blxuXG5sZXQgcmVjIGZpbHRlcl9tYXBfaW5wbGFjZV9idWNrZXQgZiBoIGkgcHJlYyA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT5cbiAgICAgIGJlZ2luIG1hdGNoIHByZWMgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBoLmRhdGEuKGkpIDwtIEVtcHR5XG4gICAgICB8IENvbnMgYyAtPiBjLm5leHQgPC0gRW1wdHlcbiAgICAgIGVuZFxuICB8IChDb25zICh7a2V5OyBkYXRhOyBuZXh0fSBhcyBjKSkgYXMgc2xvdCAtPlxuICAgICAgYmVnaW4gbWF0Y2ggZiBrZXkgZGF0YSB3aXRoXG4gICAgICB8IE5vbmUgLT5cbiAgICAgICAgICBoLnNpemUgPC0gaC5zaXplIC0gMTtcbiAgICAgICAgICBmaWx0ZXJfbWFwX2lucGxhY2VfYnVja2V0IGYgaCBpIHByZWMgbmV4dFxuICAgICAgfCBTb21lIGRhdGEgLT5cbiAgICAgICAgICBiZWdpbiBtYXRjaCBwcmVjIHdpdGhcbiAgICAgICAgICB8IEVtcHR5IC0+IGguZGF0YS4oaSkgPC0gc2xvdFxuICAgICAgICAgIHwgQ29ucyBjIC0+IGMubmV4dCA8LSBzbG90XG4gICAgICAgICAgZW5kO1xuICAgICAgICAgIGMuZGF0YSA8LSBkYXRhO1xuICAgICAgICAgIGZpbHRlcl9tYXBfaW5wbGFjZV9idWNrZXQgZiBoIGkgc2xvdCBuZXh0XG4gICAgICBlbmRcblxubGV0IGZpbHRlcl9tYXBfaW5wbGFjZSBmIGggPVxuICBsZXQgZCA9IGguZGF0YSBpblxuICBsZXQgb2xkX3RyYXYgPSBvbmdvaW5nX3RyYXZlcnNhbCBoIGluXG4gIGlmIG5vdCBvbGRfdHJhdiB0aGVuIGZsaXBfb25nb2luZ190cmF2ZXJzYWwgaDtcbiAgdHJ5XG4gICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCBkIC0gMSBkb1xuICAgICAgZmlsdGVyX21hcF9pbnBsYWNlX2J1Y2tldCBmIGggaSBFbXB0eSBoLmRhdGEuKGkpXG4gICAgZG9uZTtcbiAgICBpZiBub3Qgb2xkX3RyYXYgdGhlbiBmbGlwX29uZ29pbmdfdHJhdmVyc2FsIGhcbiAgd2l0aCBleG4gd2hlbiBub3Qgb2xkX3RyYXYgLT5cbiAgICBmbGlwX29uZ29pbmdfdHJhdmVyc2FsIGg7XG4gICAgcmFpc2UgZXhuXG5cbmxldCBmb2xkIGYgaCBpbml0ID1cbiAgbGV0IHJlYyBkb19idWNrZXQgYiBhY2N1ID1cbiAgICBtYXRjaCBiIHdpdGhcbiAgICAgIEVtcHR5IC0+XG4gICAgICAgIGFjY3VcbiAgICB8IENvbnN7a2V5OyBkYXRhOyBuZXh0fSAtPlxuICAgICAgICBkb19idWNrZXQgbmV4dCAoZiBrZXkgZGF0YSBhY2N1KSBpblxuICBsZXQgb2xkX3RyYXYgPSBvbmdvaW5nX3RyYXZlcnNhbCBoIGluXG4gIGlmIG5vdCBvbGRfdHJhdiB0aGVuIGZsaXBfb25nb2luZ190cmF2ZXJzYWwgaDtcbiAgdHJ5XG4gICAgbGV0IGQgPSBoLmRhdGEgaW5cbiAgICBsZXQgYWNjdSA9IHJlZiBpbml0IGluXG4gICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCBkIC0gMSBkb1xuICAgICAgYWNjdSA6PSBkb19idWNrZXQgZC4oaSkgIWFjY3VcbiAgICBkb25lO1xuICAgIGlmIG5vdCBvbGRfdHJhdiB0aGVuIGZsaXBfb25nb2luZ190cmF2ZXJzYWwgaDtcbiAgICAhYWNjdVxuICB3aXRoIGV4biB3aGVuIG5vdCBvbGRfdHJhdiAtPlxuICAgIGZsaXBfb25nb2luZ190cmF2ZXJzYWwgaDtcbiAgICByYWlzZSBleG5cblxudHlwZSBzdGF0aXN0aWNzID0ge1xuICBudW1fYmluZGluZ3M6IGludDtcbiAgbnVtX2J1Y2tldHM6IGludDtcbiAgbWF4X2J1Y2tldF9sZW5ndGg6IGludDtcbiAgYnVja2V0X2hpc3RvZ3JhbTogaW50IGFycmF5XG59XG5cbmxldCByZWMgYnVja2V0X2xlbmd0aCBhY2N1ID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPiBhY2N1XG4gIHwgQ29uc3tuZXh0fSAtPiBidWNrZXRfbGVuZ3RoIChhY2N1ICsgMSkgbmV4dFxuXG5sZXQgc3RhdHMgaCA9XG4gIGxldCBtYmwgPVxuICAgIEFycmF5LmZvbGRfbGVmdCAoZnVuIG0gYiAtPiBtYXggbSAoYnVja2V0X2xlbmd0aCAwIGIpKSAwIGguZGF0YSBpblxuICBsZXQgaGlzdG8gPSBBcnJheS5tYWtlIChtYmwgKyAxKSAwIGluXG4gIEFycmF5Lml0ZXJcbiAgICAoZnVuIGIgLT5cbiAgICAgIGxldCBsID0gYnVja2V0X2xlbmd0aCAwIGIgaW5cbiAgICAgIGhpc3RvLihsKSA8LSBoaXN0by4obCkgKyAxKVxuICAgIGguZGF0YTtcbiAgeyBudW1fYmluZGluZ3MgPSBoLnNpemU7XG4gICAgbnVtX2J1Y2tldHMgPSBBcnJheS5sZW5ndGggaC5kYXRhO1xuICAgIG1heF9idWNrZXRfbGVuZ3RoID0gbWJsO1xuICAgIGJ1Y2tldF9oaXN0b2dyYW0gPSBoaXN0byB9XG5cbigqKiB7MSBJdGVyYXRvcnN9ICopXG5cbmxldCB0b19zZXEgdGJsID1cbiAgKCogY2FwdHVyZSBjdXJyZW50IGFycmF5LCBzbyB0aGF0IGV2ZW4gaWYgdGhlIHRhYmxlIGlzIHJlc2l6ZWQgd2VcbiAgICAga2VlcCBpdGVyYXRpbmcgb24gdGhlIHNhbWUgYXJyYXkgKilcbiAgbGV0IHRibF9kYXRhID0gdGJsLmRhdGEgaW5cbiAgKCogc3RhdGU6IGluZGV4ICogbmV4dCBidWNrZXQgdG8gdHJhdmVyc2UgKilcbiAgbGV0IHJlYyBhdXggaSBidWNrICgpID0gbWF0Y2ggYnVjayB3aXRoXG4gICAgfCBFbXB0eSAtPlxuICAgICAgICBpZiBpID0gQXJyYXkubGVuZ3RoIHRibF9kYXRhXG4gICAgICAgIHRoZW4gU2VxLk5pbFxuICAgICAgICBlbHNlIGF1eChpKzEpIHRibF9kYXRhLihpKSAoKVxuICAgIHwgQ29ucyB7a2V5OyBkYXRhOyBuZXh0fSAtPlxuICAgICAgICBTZXEuQ29ucyAoKGtleSwgZGF0YSksIGF1eCBpIG5leHQpXG4gIGluXG4gIGF1eCAwIEVtcHR5XG5cbmxldCB0b19zZXFfa2V5cyBtID0gU2VxLm1hcCBmc3QgKHRvX3NlcSBtKVxuXG5sZXQgdG9fc2VxX3ZhbHVlcyBtID0gU2VxLm1hcCBzbmQgKHRvX3NlcSBtKVxuXG4oKiBGdW5jdG9yaWFsIGludGVyZmFjZSAqKVxuXG5tb2R1bGUgdHlwZSBIYXNoZWRUeXBlID1cbiAgc2lnXG4gICAgdHlwZSB0XG4gICAgdmFsIGVxdWFsOiB0IC0+IHQgLT4gYm9vbFxuICAgIHZhbCBoYXNoOiB0IC0+IGludFxuICBlbmRcblxubW9kdWxlIHR5cGUgU2VlZGVkSGFzaGVkVHlwZSA9XG4gIHNpZ1xuICAgIHR5cGUgdFxuICAgIHZhbCBlcXVhbDogdCAtPiB0IC0+IGJvb2xcbiAgICB2YWwgaGFzaDogaW50IC0+IHQgLT4gaW50XG4gIGVuZFxuXG5tb2R1bGUgdHlwZSBTID1cbiAgc2lnXG4gICAgdHlwZSBrZXlcbiAgICB0eXBlICEnYSB0XG4gICAgdmFsIGNyZWF0ZTogaW50IC0+ICdhIHRcbiAgICB2YWwgY2xlYXIgOiAnYSB0IC0+IHVuaXRcbiAgICB2YWwgcmVzZXQgOiAnYSB0IC0+IHVuaXRcbiAgICB2YWwgY29weTogJ2EgdCAtPiAnYSB0XG4gICAgdmFsIGFkZDogJ2EgdCAtPiBrZXkgLT4gJ2EgLT4gdW5pdFxuICAgIHZhbCByZW1vdmU6ICdhIHQgLT4ga2V5IC0+IHVuaXRcbiAgICB2YWwgZmluZDogJ2EgdCAtPiBrZXkgLT4gJ2FcbiAgICB2YWwgZmluZF9vcHQ6ICdhIHQgLT4ga2V5IC0+ICdhIG9wdGlvblxuICAgIHZhbCBmaW5kX2FsbDogJ2EgdCAtPiBrZXkgLT4gJ2EgbGlzdFxuICAgIHZhbCByZXBsYWNlIDogJ2EgdCAtPiBrZXkgLT4gJ2EgLT4gdW5pdFxuICAgIHZhbCBtZW0gOiAnYSB0IC0+IGtleSAtPiBib29sXG4gICAgdmFsIGl0ZXI6IChrZXkgLT4gJ2EgLT4gdW5pdCkgLT4gJ2EgdCAtPiB1bml0XG4gICAgdmFsIGZpbHRlcl9tYXBfaW5wbGFjZTogKGtleSAtPiAnYSAtPiAnYSBvcHRpb24pIC0+ICdhIHQgLT4gdW5pdFxuICAgIHZhbCBmb2xkOiAoa2V5IC0+ICdhIC0+ICdiIC0+ICdiKSAtPiAnYSB0IC0+ICdiIC0+ICdiXG4gICAgdmFsIGxlbmd0aDogJ2EgdCAtPiBpbnRcbiAgICB2YWwgc3RhdHM6ICdhIHQgLT4gc3RhdGlzdGljc1xuICAgIHZhbCB0b19zZXEgOiAnYSB0IC0+IChrZXkgKiAnYSkgU2VxLnRcbiAgICB2YWwgdG9fc2VxX2tleXMgOiBfIHQgLT4ga2V5IFNlcS50XG4gICAgdmFsIHRvX3NlcV92YWx1ZXMgOiAnYSB0IC0+ICdhIFNlcS50XG4gICAgdmFsIGFkZF9zZXEgOiAnYSB0IC0+IChrZXkgKiAnYSkgU2VxLnQgLT4gdW5pdFxuICAgIHZhbCByZXBsYWNlX3NlcSA6ICdhIHQgLT4gKGtleSAqICdhKSBTZXEudCAtPiB1bml0XG4gICAgdmFsIG9mX3NlcSA6IChrZXkgKiAnYSkgU2VxLnQgLT4gJ2EgdFxuICBlbmRcblxubW9kdWxlIHR5cGUgU2VlZGVkUyA9XG4gIHNpZ1xuICAgIHR5cGUga2V5XG4gICAgdHlwZSAhJ2EgdFxuICAgIHZhbCBjcmVhdGUgOiA/cmFuZG9tOmJvb2wgLT4gaW50IC0+ICdhIHRcbiAgICB2YWwgY2xlYXIgOiAnYSB0IC0+IHVuaXRcbiAgICB2YWwgcmVzZXQgOiAnYSB0IC0+IHVuaXRcbiAgICB2YWwgY29weSA6ICdhIHQgLT4gJ2EgdFxuICAgIHZhbCBhZGQgOiAnYSB0IC0+IGtleSAtPiAnYSAtPiB1bml0XG4gICAgdmFsIHJlbW92ZSA6ICdhIHQgLT4ga2V5IC0+IHVuaXRcbiAgICB2YWwgZmluZCA6ICdhIHQgLT4ga2V5IC0+ICdhXG4gICAgdmFsIGZpbmRfb3B0OiAnYSB0IC0+IGtleSAtPiAnYSBvcHRpb25cbiAgICB2YWwgZmluZF9hbGwgOiAnYSB0IC0+IGtleSAtPiAnYSBsaXN0XG4gICAgdmFsIHJlcGxhY2UgOiAnYSB0IC0+IGtleSAtPiAnYSAtPiB1bml0XG4gICAgdmFsIG1lbSA6ICdhIHQgLT4ga2V5IC0+IGJvb2xcbiAgICB2YWwgaXRlciA6IChrZXkgLT4gJ2EgLT4gdW5pdCkgLT4gJ2EgdCAtPiB1bml0XG4gICAgdmFsIGZpbHRlcl9tYXBfaW5wbGFjZTogKGtleSAtPiAnYSAtPiAnYSBvcHRpb24pIC0+ICdhIHQgLT4gdW5pdFxuICAgIHZhbCBmb2xkIDogKGtleSAtPiAnYSAtPiAnYiAtPiAnYikgLT4gJ2EgdCAtPiAnYiAtPiAnYlxuICAgIHZhbCBsZW5ndGggOiAnYSB0IC0+IGludFxuICAgIHZhbCBzdGF0czogJ2EgdCAtPiBzdGF0aXN0aWNzXG4gICAgdmFsIHRvX3NlcSA6ICdhIHQgLT4gKGtleSAqICdhKSBTZXEudFxuICAgIHZhbCB0b19zZXFfa2V5cyA6IF8gdCAtPiBrZXkgU2VxLnRcbiAgICB2YWwgdG9fc2VxX3ZhbHVlcyA6ICdhIHQgLT4gJ2EgU2VxLnRcbiAgICB2YWwgYWRkX3NlcSA6ICdhIHQgLT4gKGtleSAqICdhKSBTZXEudCAtPiB1bml0XG4gICAgdmFsIHJlcGxhY2Vfc2VxIDogJ2EgdCAtPiAoa2V5ICogJ2EpIFNlcS50IC0+IHVuaXRcbiAgICB2YWwgb2Zfc2VxIDogKGtleSAqICdhKSBTZXEudCAtPiAnYSB0XG4gIGVuZFxuXG5tb2R1bGUgTWFrZVNlZWRlZChIOiBTZWVkZWRIYXNoZWRUeXBlKTogKFNlZWRlZFMgd2l0aCB0eXBlIGtleSA9IEgudCkgPVxuICBzdHJ1Y3RcbiAgICB0eXBlIGtleSA9IEgudFxuICAgIHR5cGUgJ2EgaGFzaHRibCA9IChrZXksICdhKSB0XG4gICAgdHlwZSAnYSB0ID0gJ2EgaGFzaHRibFxuICAgIGxldCBjcmVhdGUgPSBjcmVhdGVcbiAgICBsZXQgY2xlYXIgPSBjbGVhclxuICAgIGxldCByZXNldCA9IHJlc2V0XG4gICAgbGV0IGNvcHkgPSBjb3B5XG5cbiAgICBsZXQga2V5X2luZGV4IGgga2V5ID1cbiAgICAgIChILmhhc2ggaC5zZWVkIGtleSkgbGFuZCAoQXJyYXkubGVuZ3RoIGguZGF0YSAtIDEpXG5cbiAgICBsZXQgYWRkIGgga2V5IGRhdGEgPVxuICAgICAgbGV0IGkgPSBrZXlfaW5kZXggaCBrZXkgaW5cbiAgICAgIGxldCBidWNrZXQgPSBDb25ze2tleTsgZGF0YTsgbmV4dD1oLmRhdGEuKGkpfSBpblxuICAgICAgaC5kYXRhLihpKSA8LSBidWNrZXQ7XG4gICAgICBoLnNpemUgPC0gaC5zaXplICsgMTtcbiAgICAgIGlmIGguc2l6ZSA+IEFycmF5Lmxlbmd0aCBoLmRhdGEgbHNsIDEgdGhlbiByZXNpemUga2V5X2luZGV4IGhcblxuICAgIGxldCByZWMgcmVtb3ZlX2J1Y2tldCBoIGkga2V5IHByZWMgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgICgpXG4gICAgICB8IChDb25zIHtrZXk9azsgbmV4dH0pIGFzIGMgLT5cbiAgICAgICAgICBpZiBILmVxdWFsIGsga2V5XG4gICAgICAgICAgdGhlbiBiZWdpblxuICAgICAgICAgICAgaC5zaXplIDwtIGguc2l6ZSAtIDE7XG4gICAgICAgICAgICBtYXRjaCBwcmVjIHdpdGhcbiAgICAgICAgICAgIHwgRW1wdHkgLT4gaC5kYXRhLihpKSA8LSBuZXh0XG4gICAgICAgICAgICB8IENvbnMgYyAtPiBjLm5leHQgPC0gbmV4dFxuICAgICAgICAgIGVuZFxuICAgICAgICAgIGVsc2UgcmVtb3ZlX2J1Y2tldCBoIGkga2V5IGMgbmV4dFxuXG4gICAgbGV0IHJlbW92ZSBoIGtleSA9XG4gICAgICBsZXQgaSA9IGtleV9pbmRleCBoIGtleSBpblxuICAgICAgcmVtb3ZlX2J1Y2tldCBoIGkga2V5IEVtcHR5IGguZGF0YS4oaSlcblxuICAgIGxldCByZWMgZmluZF9yZWMga2V5ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgQ29uc3trZXk9azsgZGF0YTsgbmV4dH0gLT5cbiAgICAgICAgICBpZiBILmVxdWFsIGtleSBrIHRoZW4gZGF0YSBlbHNlIGZpbmRfcmVjIGtleSBuZXh0XG5cbiAgICBsZXQgZmluZCBoIGtleSA9XG4gICAgICBtYXRjaCBoLmRhdGEuKGtleV9pbmRleCBoIGtleSkgd2l0aFxuICAgICAgfCBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgQ29uc3trZXk9azE7IGRhdGE9ZDE7IG5leHQ9bmV4dDF9IC0+XG4gICAgICAgICAgaWYgSC5lcXVhbCBrZXkgazEgdGhlbiBkMSBlbHNlXG4gICAgICAgICAgbWF0Y2ggbmV4dDEgd2l0aFxuICAgICAgICAgIHwgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICAgICAgfCBDb25ze2tleT1rMjsgZGF0YT1kMjsgbmV4dD1uZXh0Mn0gLT5cbiAgICAgICAgICAgICAgaWYgSC5lcXVhbCBrZXkgazIgdGhlbiBkMiBlbHNlXG4gICAgICAgICAgICAgIG1hdGNoIG5leHQyIHdpdGhcbiAgICAgICAgICAgICAgfCBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgICAgICAgICAgfCBDb25ze2tleT1rMzsgZGF0YT1kMzsgbmV4dD1uZXh0M30gLT5cbiAgICAgICAgICAgICAgICAgIGlmIEguZXF1YWwga2V5IGszIHRoZW4gZDMgZWxzZSBmaW5kX3JlYyBrZXkgbmV4dDNcblxuICAgIGxldCByZWMgZmluZF9yZWNfb3B0IGtleSA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgTm9uZVxuICAgICAgfCBDb25ze2tleT1rOyBkYXRhOyBuZXh0fSAtPlxuICAgICAgICAgIGlmIEguZXF1YWwga2V5IGsgdGhlbiBTb21lIGRhdGEgZWxzZSBmaW5kX3JlY19vcHQga2V5IG5leHRcblxuICAgIGxldCBmaW5kX29wdCBoIGtleSA9XG4gICAgICBtYXRjaCBoLmRhdGEuKGtleV9pbmRleCBoIGtleSkgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBOb25lXG4gICAgICB8IENvbnN7a2V5PWsxOyBkYXRhPWQxOyBuZXh0PW5leHQxfSAtPlxuICAgICAgICAgIGlmIEguZXF1YWwga2V5IGsxIHRoZW4gU29tZSBkMSBlbHNlXG4gICAgICAgICAgbWF0Y2ggbmV4dDEgd2l0aFxuICAgICAgICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgICAgICAgIHwgQ29uc3trZXk9azI7IGRhdGE9ZDI7IG5leHQ9bmV4dDJ9IC0+XG4gICAgICAgICAgICAgIGlmIEguZXF1YWwga2V5IGsyIHRoZW4gU29tZSBkMiBlbHNlXG4gICAgICAgICAgICAgIG1hdGNoIG5leHQyIHdpdGhcbiAgICAgICAgICAgICAgfCBFbXB0eSAtPiBOb25lXG4gICAgICAgICAgICAgIHwgQ29uc3trZXk9azM7IGRhdGE9ZDM7IG5leHQ9bmV4dDN9IC0+XG4gICAgICAgICAgICAgICAgICBpZiBILmVxdWFsIGtleSBrMyB0aGVuIFNvbWUgZDMgZWxzZSBmaW5kX3JlY19vcHQga2V5IG5leHQzXG5cbiAgICBsZXQgZmluZF9hbGwgaCBrZXkgPVxuICAgICAgbGV0IHJlYyBmaW5kX2luX2J1Y2tldCA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgW11cbiAgICAgIHwgQ29uc3trZXk9azsgZGF0YT1kOyBuZXh0fSAtPlxuICAgICAgICAgIGlmIEguZXF1YWwgayBrZXlcbiAgICAgICAgICB0aGVuIGQgOjogZmluZF9pbl9idWNrZXQgbmV4dFxuICAgICAgICAgIGVsc2UgZmluZF9pbl9idWNrZXQgbmV4dCBpblxuICAgICAgZmluZF9pbl9idWNrZXQgaC5kYXRhLihrZXlfaW5kZXggaCBrZXkpXG5cbiAgICBsZXQgcmVjIHJlcGxhY2VfYnVja2V0IGtleSBkYXRhID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICB0cnVlXG4gICAgICB8IENvbnMgKHtrZXk9azsgbmV4dH0gYXMgc2xvdCkgLT5cbiAgICAgICAgICBpZiBILmVxdWFsIGsga2V5XG4gICAgICAgICAgdGhlbiAoc2xvdC5rZXkgPC0ga2V5OyBzbG90LmRhdGEgPC0gZGF0YTsgZmFsc2UpXG4gICAgICAgICAgZWxzZSByZXBsYWNlX2J1Y2tldCBrZXkgZGF0YSBuZXh0XG5cbiAgICBsZXQgcmVwbGFjZSBoIGtleSBkYXRhID1cbiAgICAgIGxldCBpID0ga2V5X2luZGV4IGgga2V5IGluXG4gICAgICBsZXQgbCA9IGguZGF0YS4oaSkgaW5cbiAgICAgIGlmIHJlcGxhY2VfYnVja2V0IGtleSBkYXRhIGwgdGhlbiBiZWdpblxuICAgICAgICBoLmRhdGEuKGkpIDwtIENvbnN7a2V5OyBkYXRhOyBuZXh0PWx9O1xuICAgICAgICBoLnNpemUgPC0gaC5zaXplICsgMTtcbiAgICAgICAgaWYgaC5zaXplID4gQXJyYXkubGVuZ3RoIGguZGF0YSBsc2wgMSB0aGVuIHJlc2l6ZSBrZXlfaW5kZXggaFxuICAgICAgZW5kXG5cbiAgICBsZXQgbWVtIGgga2V5ID1cbiAgICAgIGxldCByZWMgbWVtX2luX2J1Y2tldCA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgZmFsc2VcbiAgICAgIHwgQ29uc3trZXk9azsgbmV4dH0gLT5cbiAgICAgICAgICBILmVxdWFsIGsga2V5IHx8IG1lbV9pbl9idWNrZXQgbmV4dCBpblxuICAgICAgbWVtX2luX2J1Y2tldCBoLmRhdGEuKGtleV9pbmRleCBoIGtleSlcblxuICAgIGxldCBhZGRfc2VxIHRibCBpID1cbiAgICAgIFNlcS5pdGVyIChmdW4gKGssdikgLT4gYWRkIHRibCBrIHYpIGlcblxuICAgIGxldCByZXBsYWNlX3NlcSB0YmwgaSA9XG4gICAgICBTZXEuaXRlciAoZnVuIChrLHYpIC0+IHJlcGxhY2UgdGJsIGsgdikgaVxuXG4gICAgbGV0IG9mX3NlcSBpID1cbiAgICAgIGxldCB0YmwgPSBjcmVhdGUgMTYgaW5cbiAgICAgIHJlcGxhY2Vfc2VxIHRibCBpO1xuICAgICAgdGJsXG5cbiAgICBsZXQgaXRlciA9IGl0ZXJcbiAgICBsZXQgZmlsdGVyX21hcF9pbnBsYWNlID0gZmlsdGVyX21hcF9pbnBsYWNlXG4gICAgbGV0IGZvbGQgPSBmb2xkXG4gICAgbGV0IGxlbmd0aCA9IGxlbmd0aFxuICAgIGxldCBzdGF0cyA9IHN0YXRzXG4gICAgbGV0IHRvX3NlcSA9IHRvX3NlcVxuICAgIGxldCB0b19zZXFfa2V5cyA9IHRvX3NlcV9rZXlzXG4gICAgbGV0IHRvX3NlcV92YWx1ZXMgPSB0b19zZXFfdmFsdWVzXG4gIGVuZFxuXG5tb2R1bGUgTWFrZShIOiBIYXNoZWRUeXBlKTogKFMgd2l0aCB0eXBlIGtleSA9IEgudCkgPVxuICBzdHJ1Y3RcbiAgICBpbmNsdWRlIE1ha2VTZWVkZWQoc3RydWN0XG4gICAgICAgIHR5cGUgdCA9IEgudFxuICAgICAgICBsZXQgZXF1YWwgPSBILmVxdWFsXG4gICAgICAgIGxldCBoYXNoIChfc2VlZDogaW50KSB4ID0gSC5oYXNoIHhcbiAgICAgIGVuZClcbiAgICBsZXQgY3JlYXRlIHN6ID0gY3JlYXRlIH5yYW5kb206ZmFsc2Ugc3pcbiAgICBsZXQgb2Zfc2VxIGkgPVxuICAgICAgbGV0IHRibCA9IGNyZWF0ZSAxNiBpblxuICAgICAgcmVwbGFjZV9zZXEgdGJsIGk7XG4gICAgICB0YmxcbiAgZW5kXG5cbigqIFBvbHltb3JwaGljIGhhc2ggZnVuY3Rpb24tYmFzZWQgdGFibGVzICopXG4oKiBDb2RlIGluY2x1ZGVkIGJlbG93IHRoZSBmdW5jdG9yaWFsIGludGVyZmFjZSB0byBndWFyZCBhZ2FpbnN0IGFjY2lkZW50YWxcbiAgIHVzZSAtIHNlZSAjMjIwMiAqKVxuXG5leHRlcm5hbCBzZWVkZWRfaGFzaF9wYXJhbSA6XG4gIGludCAtPiBpbnQgLT4gaW50IC0+ICdhIC0+IGludCA9IFwiY2FtbF9oYXNoXCIgW0BAbm9hbGxvY11cblxubGV0IGhhc2ggeCA9IHNlZWRlZF9oYXNoX3BhcmFtIDEwIDEwMCAwIHhcbmxldCBoYXNoX3BhcmFtIG4xIG4yIHggPSBzZWVkZWRfaGFzaF9wYXJhbSBuMSBuMiAwIHhcbmxldCBzZWVkZWRfaGFzaCBzZWVkIHggPSBzZWVkZWRfaGFzaF9wYXJhbSAxMCAxMDAgc2VlZCB4XG5cbmxldCBrZXlfaW5kZXggaCBrZXkgPVxuICBpZiBPYmouc2l6ZSAoT2JqLnJlcHIgaCkgPj0gNFxuICB0aGVuIChzZWVkZWRfaGFzaF9wYXJhbSAxMCAxMDAgaC5zZWVkIGtleSkgbGFuZCAoQXJyYXkubGVuZ3RoIGguZGF0YSAtIDEpXG4gIGVsc2UgaW52YWxpZF9hcmcgXCJIYXNodGJsOiB1bnN1cHBvcnRlZCBoYXNoIHRhYmxlIGZvcm1hdFwiXG5cbmxldCBhZGQgaCBrZXkgZGF0YSA9XG4gIGxldCBpID0ga2V5X2luZGV4IGgga2V5IGluXG4gIGxldCBidWNrZXQgPSBDb25ze2tleTsgZGF0YTsgbmV4dD1oLmRhdGEuKGkpfSBpblxuICBoLmRhdGEuKGkpIDwtIGJ1Y2tldDtcbiAgaC5zaXplIDwtIGguc2l6ZSArIDE7XG4gIGlmIGguc2l6ZSA+IEFycmF5Lmxlbmd0aCBoLmRhdGEgbHNsIDEgdGhlbiByZXNpemUga2V5X2luZGV4IGhcblxubGV0IHJlYyByZW1vdmVfYnVja2V0IGggaSBrZXkgcHJlYyA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT5cbiAgICAgICgpXG4gIHwgKENvbnMge2tleT1rOyBuZXh0fSkgYXMgYyAtPlxuICAgICAgaWYgY29tcGFyZSBrIGtleSA9IDBcbiAgICAgIHRoZW4gYmVnaW5cbiAgICAgICAgaC5zaXplIDwtIGguc2l6ZSAtIDE7XG4gICAgICAgIG1hdGNoIHByZWMgd2l0aFxuICAgICAgICB8IEVtcHR5IC0+IGguZGF0YS4oaSkgPC0gbmV4dFxuICAgICAgICB8IENvbnMgYyAtPiBjLm5leHQgPC0gbmV4dFxuICAgICAgZW5kXG4gICAgICBlbHNlIHJlbW92ZV9idWNrZXQgaCBpIGtleSBjIG5leHRcblxubGV0IHJlbW92ZSBoIGtleSA9XG4gIGxldCBpID0ga2V5X2luZGV4IGgga2V5IGluXG4gIHJlbW92ZV9idWNrZXQgaCBpIGtleSBFbXB0eSBoLmRhdGEuKGkpXG5cbmxldCByZWMgZmluZF9yZWMga2V5ID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPlxuICAgICAgcmFpc2UgTm90X2ZvdW5kXG4gIHwgQ29uc3trZXk9azsgZGF0YTsgbmV4dH0gLT5cbiAgICAgIGlmIGNvbXBhcmUga2V5IGsgPSAwIHRoZW4gZGF0YSBlbHNlIGZpbmRfcmVjIGtleSBuZXh0XG5cbmxldCBmaW5kIGgga2V5ID1cbiAgbWF0Y2ggaC5kYXRhLihrZXlfaW5kZXggaCBrZXkpIHdpdGhcbiAgfCBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgfCBDb25ze2tleT1rMTsgZGF0YT1kMTsgbmV4dD1uZXh0MX0gLT5cbiAgICAgIGlmIGNvbXBhcmUga2V5IGsxID0gMCB0aGVuIGQxIGVsc2VcbiAgICAgIG1hdGNoIG5leHQxIHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IENvbnN7a2V5PWsyOyBkYXRhPWQyOyBuZXh0PW5leHQyfSAtPlxuICAgICAgICAgIGlmIGNvbXBhcmUga2V5IGsyID0gMCB0aGVuIGQyIGVsc2VcbiAgICAgICAgICBtYXRjaCBuZXh0MiB3aXRoXG4gICAgICAgICAgfCBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgICAgICB8IENvbnN7a2V5PWszOyBkYXRhPWQzOyBuZXh0PW5leHQzfSAtPlxuICAgICAgICAgICAgICBpZiBjb21wYXJlIGtleSBrMyA9IDAgdGhlbiBkMyBlbHNlIGZpbmRfcmVjIGtleSBuZXh0M1xuXG5sZXQgcmVjIGZpbmRfcmVjX29wdCBrZXkgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+XG4gICAgICBOb25lXG4gIHwgQ29uc3trZXk9azsgZGF0YTsgbmV4dH0gLT5cbiAgICAgIGlmIGNvbXBhcmUga2V5IGsgPSAwIHRoZW4gU29tZSBkYXRhIGVsc2UgZmluZF9yZWNfb3B0IGtleSBuZXh0XG5cbmxldCBmaW5kX29wdCBoIGtleSA9XG4gIG1hdGNoIGguZGF0YS4oa2V5X2luZGV4IGgga2V5KSB3aXRoXG4gIHwgRW1wdHkgLT4gTm9uZVxuICB8IENvbnN7a2V5PWsxOyBkYXRhPWQxOyBuZXh0PW5leHQxfSAtPlxuICAgICAgaWYgY29tcGFyZSBrZXkgazEgPSAwIHRoZW4gU29tZSBkMSBlbHNlXG4gICAgICBtYXRjaCBuZXh0MSB3aXRoXG4gICAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICAgIHwgQ29uc3trZXk9azI7IGRhdGE9ZDI7IG5leHQ9bmV4dDJ9IC0+XG4gICAgICAgICAgaWYgY29tcGFyZSBrZXkgazIgPSAwIHRoZW4gU29tZSBkMiBlbHNlXG4gICAgICAgICAgbWF0Y2ggbmV4dDIgd2l0aFxuICAgICAgICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgICAgICAgIHwgQ29uc3trZXk9azM7IGRhdGE9ZDM7IG5leHQ9bmV4dDN9IC0+XG4gICAgICAgICAgICAgIGlmIGNvbXBhcmUga2V5IGszID0gMCB0aGVuIFNvbWUgZDMgZWxzZSBmaW5kX3JlY19vcHQga2V5IG5leHQzXG5cbmxldCBmaW5kX2FsbCBoIGtleSA9XG4gIGxldCByZWMgZmluZF9pbl9idWNrZXQgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+XG4gICAgICBbXVxuICB8IENvbnN7a2V5PWs7IGRhdGE7IG5leHR9IC0+XG4gICAgICBpZiBjb21wYXJlIGsga2V5ID0gMFxuICAgICAgdGhlbiBkYXRhIDo6IGZpbmRfaW5fYnVja2V0IG5leHRcbiAgICAgIGVsc2UgZmluZF9pbl9idWNrZXQgbmV4dCBpblxuICBmaW5kX2luX2J1Y2tldCBoLmRhdGEuKGtleV9pbmRleCBoIGtleSlcblxubGV0IHJlYyByZXBsYWNlX2J1Y2tldCBrZXkgZGF0YSA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT5cbiAgICAgIHRydWVcbiAgfCBDb25zICh7a2V5PWs7IG5leHR9IGFzIHNsb3QpIC0+XG4gICAgICBpZiBjb21wYXJlIGsga2V5ID0gMFxuICAgICAgdGhlbiAoc2xvdC5rZXkgPC0ga2V5OyBzbG90LmRhdGEgPC0gZGF0YTsgZmFsc2UpXG4gICAgICBlbHNlIHJlcGxhY2VfYnVja2V0IGtleSBkYXRhIG5leHRcblxubGV0IHJlcGxhY2UgaCBrZXkgZGF0YSA9XG4gIGxldCBpID0ga2V5X2luZGV4IGgga2V5IGluXG4gIGxldCBsID0gaC5kYXRhLihpKSBpblxuICBpZiByZXBsYWNlX2J1Y2tldCBrZXkgZGF0YSBsIHRoZW4gYmVnaW5cbiAgICBoLmRhdGEuKGkpIDwtIENvbnN7a2V5OyBkYXRhOyBuZXh0PWx9O1xuICAgIGguc2l6ZSA8LSBoLnNpemUgKyAxO1xuICAgIGlmIGguc2l6ZSA+IEFycmF5Lmxlbmd0aCBoLmRhdGEgbHNsIDEgdGhlbiByZXNpemUga2V5X2luZGV4IGhcbiAgZW5kXG5cbmxldCBtZW0gaCBrZXkgPVxuICBsZXQgcmVjIG1lbV9pbl9idWNrZXQgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+XG4gICAgICBmYWxzZVxuICB8IENvbnN7a2V5PWs7IG5leHR9IC0+XG4gICAgICBjb21wYXJlIGsga2V5ID0gMCB8fCBtZW1faW5fYnVja2V0IG5leHQgaW5cbiAgbWVtX2luX2J1Y2tldCBoLmRhdGEuKGtleV9pbmRleCBoIGtleSlcblxubGV0IGFkZF9zZXEgdGJsIGkgPVxuICBTZXEuaXRlciAoZnVuIChrLHYpIC0+IGFkZCB0YmwgayB2KSBpXG5cbmxldCByZXBsYWNlX3NlcSB0YmwgaSA9XG4gIFNlcS5pdGVyIChmdW4gKGssdikgLT4gcmVwbGFjZSB0YmwgayB2KSBpXG5cbmxldCBvZl9zZXEgaSA9XG4gIGxldCB0YmwgPSBjcmVhdGUgMTYgaW5cbiAgcmVwbGFjZV9zZXEgdGJsIGk7XG4gIHRibFxuXG5sZXQgcmVidWlsZCA/KHJhbmRvbSA9ICFyYW5kb21pemVkKSBoID1cbiAgbGV0IHMgPSBwb3dlcl8yX2Fib3ZlIDE2IChBcnJheS5sZW5ndGggaC5kYXRhKSBpblxuICBsZXQgc2VlZCA9XG4gICAgaWYgcmFuZG9tIHRoZW4gUmFuZG9tLlN0YXRlLmJpdHMgKExhenkuZm9yY2UgcHJuZylcbiAgICBlbHNlIGlmIE9iai5zaXplIChPYmoucmVwciBoKSA+PSA0IHRoZW4gaC5zZWVkXG4gICAgZWxzZSAwIGluXG4gIGxldCBoJyA9IHtcbiAgICBzaXplID0gaC5zaXplO1xuICAgIGRhdGEgPSBBcnJheS5tYWtlIHMgRW1wdHk7XG4gICAgc2VlZCA9IHNlZWQ7XG4gICAgaW5pdGlhbF9zaXplID0gaWYgT2JqLnNpemUgKE9iai5yZXByIGgpID49IDQgdGhlbiBoLmluaXRpYWxfc2l6ZSBlbHNlIHNcbiAgfSBpblxuICBpbnNlcnRfYWxsX2J1Y2tldHMgKGtleV9pbmRleCBoJykgZmFsc2UgaC5kYXRhIGgnLmRhdGE7XG4gIGgnXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBEYW1pZW4gRG9saWdleiwgcHJvamV0IFBhcmEsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk3IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqKiBXZWFrIGFycmF5IG9wZXJhdGlvbnMgKilcblxudHlwZSAhJ2EgdFxuXG5leHRlcm5hbCBjcmVhdGUgOiBpbnQgLT4gJ2EgdCA9IFwiY2FtbF93ZWFrX2NyZWF0ZVwiXG5cbmxldCBjcmVhdGUgbCA9XG4gIGlmIG5vdCAoMCA8PSBsICYmIGwgPD0gT2JqLkVwaGVtZXJvbi5tYXhfZXBoZV9sZW5ndGgpIHRoZW5cbiAgICBpbnZhbGlkX2FyZyhcIldlYWsuY3JlYXRlXCIpO1xuICBjcmVhdGUgbFxuXG4oKiogbnVtYmVyIG9mIGFkZGl0aW9uYWwgdmFsdWVzIGluIGEgd2VhayBwb2ludGVyICopXG5sZXQgYWRkaXRpb25hbF92YWx1ZXMgPSAyXG5cbmxldCBsZW5ndGggeCA9IE9iai5zaXplKE9iai5yZXByIHgpIC0gYWRkaXRpb25hbF92YWx1ZXNcblxubGV0IHJhaXNlX2lmX2ludmFsaWRfb2Zmc2V0IGUgbyBtc2cgPVxuICBpZiBub3QgKDAgPD0gbyAmJiBvIDwgbGVuZ3RoIGUpIHRoZW5cbiAgICBpbnZhbGlkX2FyZyhtc2cpXG5cbmV4dGVybmFsIHNldCcgOiAnYSB0IC0+IGludCAtPiAnYSAtPiB1bml0ID0gXCJjYW1sX2VwaGVfc2V0X2tleVwiXG5leHRlcm5hbCB1bnNldCA6ICdhIHQgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfZXBoZV91bnNldF9rZXlcIlxubGV0IHNldCBlIG8geCA9XG4gIHJhaXNlX2lmX2ludmFsaWRfb2Zmc2V0IGUgbyBcIldlYWsuc2V0XCI7XG4gIG1hdGNoIHggd2l0aFxuICB8IE5vbmUgLT4gdW5zZXQgZSBvXG4gIHwgU29tZSB4IC0+IHNldCcgZSBvIHhcblxuZXh0ZXJuYWwgZ2V0IDogJ2EgdCAtPiBpbnQgLT4gJ2Egb3B0aW9uID0gXCJjYW1sX3dlYWtfZ2V0XCJcbmxldCBnZXQgZSBvID1cbiAgcmFpc2VfaWZfaW52YWxpZF9vZmZzZXQgZSBvIFwiV2Vhay5nZXRcIjtcbiAgZ2V0IGUgb1xuXG5leHRlcm5hbCBnZXRfY29weSA6ICdhIHQgLT4gaW50IC0+ICdhIG9wdGlvbiA9IFwiY2FtbF93ZWFrX2dldF9jb3B5XCJcbmxldCBnZXRfY29weSBlIG8gPVxuICByYWlzZV9pZl9pbnZhbGlkX29mZnNldCBlIG8gXCJXZWFrLmdldF9jb3B5XCI7XG4gIGdldF9jb3B5IGUgb1xuXG5leHRlcm5hbCBjaGVjayA6ICdhIHQgLT4gaW50IC0+IGJvb2wgPSBcImNhbWxfd2Vha19jaGVja1wiXG5sZXQgY2hlY2sgZSBvID1cbiAgcmFpc2VfaWZfaW52YWxpZF9vZmZzZXQgZSBvIFwiV2Vhay5jaGVja1wiO1xuICBjaGVjayBlIG9cblxuZXh0ZXJuYWwgYmxpdCA6ICdhIHQgLT4gaW50IC0+ICdhIHQgLT4gaW50IC0+IGludCAtPiB1bml0ID0gXCJjYW1sX3dlYWtfYmxpdFwiXG5cbigqIGJsaXQ6IHNyYyBzcmNvZmYgZHN0IGRzdG9mZiBsZW4gKilcbmxldCBibGl0IGUxIG8xIGUyIG8yIGwgPVxuICBpZiBsIDwgMCB8fCBvMSA8IDAgfHwgbzEgPiBsZW5ndGggZTEgLSBsXG4gICAgIHx8IG8yIDwgMCB8fCBvMiA+IGxlbmd0aCBlMiAtIGxcbiAgdGhlbiBpbnZhbGlkX2FyZyBcIldlYWsuYmxpdFwiXG4gIGVsc2UgaWYgbCA8PiAwIHRoZW4gYmxpdCBlMSBvMSBlMiBvMiBsXG5cbmxldCBmaWxsIGFyIG9mcyBsZW4geCA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBsZW5ndGggYXIgLSBsZW5cbiAgdGhlbiByYWlzZSAoSW52YWxpZF9hcmd1bWVudCBcIldlYWsuZmlsbFwiKVxuICBlbHNlIGJlZ2luXG4gICAgZm9yIGkgPSBvZnMgdG8gKG9mcyArIGxlbiAtIDEpIGRvXG4gICAgICBzZXQgYXIgaSB4XG4gICAgZG9uZVxuICBlbmRcblxuXG4oKiogV2VhayBoYXNoIHRhYmxlcyAqKVxuXG5tb2R1bGUgdHlwZSBTID0gc2lnXG4gIHR5cGUgZGF0YVxuICB0eXBlIHRcbiAgdmFsIGNyZWF0ZSA6IGludCAtPiB0XG4gIHZhbCBjbGVhciA6IHQgLT4gdW5pdFxuICB2YWwgbWVyZ2UgOiB0IC0+IGRhdGEgLT4gZGF0YVxuICB2YWwgYWRkIDogdCAtPiBkYXRhIC0+IHVuaXRcbiAgdmFsIHJlbW92ZSA6IHQgLT4gZGF0YSAtPiB1bml0XG4gIHZhbCBmaW5kIDogdCAtPiBkYXRhIC0+IGRhdGFcbiAgdmFsIGZpbmRfb3B0IDogdCAtPiBkYXRhIC0+IGRhdGEgb3B0aW9uXG4gIHZhbCBmaW5kX2FsbCA6IHQgLT4gZGF0YSAtPiBkYXRhIGxpc3RcbiAgdmFsIG1lbSA6IHQgLT4gZGF0YSAtPiBib29sXG4gIHZhbCBpdGVyIDogKGRhdGEgLT4gdW5pdCkgLT4gdCAtPiB1bml0XG4gIHZhbCBmb2xkIDogKGRhdGEgLT4gJ2EgLT4gJ2EpIC0+IHQgLT4gJ2EgLT4gJ2FcbiAgdmFsIGNvdW50IDogdCAtPiBpbnRcbiAgdmFsIHN0YXRzIDogdCAtPiBpbnQgKiBpbnQgKiBpbnQgKiBpbnQgKiBpbnQgKiBpbnRcbmVuZFxuXG5tb2R1bGUgTWFrZSAoSCA6IEhhc2h0YmwuSGFzaGVkVHlwZSkgOiAoUyB3aXRoIHR5cGUgZGF0YSA9IEgudCkgPSBzdHJ1Y3RcblxuICB0eXBlICdhIHdlYWtfdCA9ICdhIHRcbiAgbGV0IHdlYWtfY3JlYXRlID0gY3JlYXRlXG4gIGxldCBlbXB0eWJ1Y2tldCA9IHdlYWtfY3JlYXRlIDBcblxuICB0eXBlIGRhdGEgPSBILnRcblxuICB0eXBlIHQgPSB7XG4gICAgbXV0YWJsZSB0YWJsZSA6IGRhdGEgd2Vha190IGFycmF5O1xuICAgIG11dGFibGUgaGFzaGVzIDogaW50IGFycmF5IGFycmF5O1xuICAgIG11dGFibGUgbGltaXQgOiBpbnQ7ICAgICAgICAgICAgICAgKCogYnVja2V0IHNpemUgbGltaXQgKilcbiAgICBtdXRhYmxlIG92ZXJzaXplIDogaW50OyAgICAgICAgICAgICgqIG51bWJlciBvZiBvdmVyc2l6ZSBidWNrZXRzICopXG4gICAgbXV0YWJsZSByb3ZlciA6IGludDsgICAgICAgICAgICAgICAoKiBmb3IgaW50ZXJuYWwgYm9va2tlZXBpbmcgKilcbiAgfVxuXG4gIGxldCBnZXRfaW5kZXggdCBoID0gKGggbGFuZCBtYXhfaW50KSBtb2QgKEFycmF5Lmxlbmd0aCB0LnRhYmxlKVxuXG4gIGxldCBsaW1pdCA9IDdcbiAgbGV0IG92ZXJfbGltaXQgPSAyXG5cbiAgbGV0IGNyZWF0ZSBzeiA9XG4gICAgbGV0IHN6ID0gaWYgc3ogPCA3IHRoZW4gNyBlbHNlIHN6IGluXG4gICAgbGV0IHN6ID0gaWYgc3ogPiBTeXMubWF4X2FycmF5X2xlbmd0aCB0aGVuIFN5cy5tYXhfYXJyYXlfbGVuZ3RoIGVsc2Ugc3ogaW5cbiAgICB7XG4gICAgICB0YWJsZSA9IEFycmF5Lm1ha2Ugc3ogZW1wdHlidWNrZXQ7XG4gICAgICBoYXNoZXMgPSBBcnJheS5tYWtlIHN6IFt8IHxdO1xuICAgICAgbGltaXQgPSBsaW1pdDtcbiAgICAgIG92ZXJzaXplID0gMDtcbiAgICAgIHJvdmVyID0gMDtcbiAgICB9XG5cbiAgbGV0IGNsZWFyIHQgPVxuICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggdC50YWJsZSAtIDEgZG9cbiAgICAgIHQudGFibGUuKGkpIDwtIGVtcHR5YnVja2V0O1xuICAgICAgdC5oYXNoZXMuKGkpIDwtIFt8IHxdO1xuICAgIGRvbmU7XG4gICAgdC5saW1pdCA8LSBsaW1pdDtcbiAgICB0Lm92ZXJzaXplIDwtIDBcblxuXG4gIGxldCBmb2xkIGYgdCBpbml0ID1cbiAgICBsZXQgcmVjIGZvbGRfYnVja2V0IGkgYiBhY2N1ID1cbiAgICAgIGlmIGkgPj0gbGVuZ3RoIGIgdGhlbiBhY2N1IGVsc2VcbiAgICAgIG1hdGNoIGdldCBiIGkgd2l0aFxuICAgICAgfCBTb21lIHYgLT4gZm9sZF9idWNrZXQgKGkrMSkgYiAoZiB2IGFjY3UpXG4gICAgICB8IE5vbmUgLT4gZm9sZF9idWNrZXQgKGkrMSkgYiBhY2N1XG4gICAgaW5cbiAgICBBcnJheS5mb2xkX3JpZ2h0IChmb2xkX2J1Y2tldCAwKSB0LnRhYmxlIGluaXRcblxuXG4gIGxldCBpdGVyIGYgdCA9XG4gICAgbGV0IHJlYyBpdGVyX2J1Y2tldCBpIGIgPVxuICAgICAgaWYgaSA+PSBsZW5ndGggYiB0aGVuICgpIGVsc2VcbiAgICAgIG1hdGNoIGdldCBiIGkgd2l0aFxuICAgICAgfCBTb21lIHYgLT4gZiB2OyBpdGVyX2J1Y2tldCAoaSsxKSBiXG4gICAgICB8IE5vbmUgLT4gaXRlcl9idWNrZXQgKGkrMSkgYlxuICAgIGluXG4gICAgQXJyYXkuaXRlciAoaXRlcl9idWNrZXQgMCkgdC50YWJsZVxuXG5cbiAgbGV0IGl0ZXJfd2VhayBmIHQgPVxuICAgIGxldCByZWMgaXRlcl9idWNrZXQgaSBqIGIgPVxuICAgICAgaWYgaSA+PSBsZW5ndGggYiB0aGVuICgpIGVsc2VcbiAgICAgIG1hdGNoIGNoZWNrIGIgaSB3aXRoXG4gICAgICB8IHRydWUgLT4gZiBiIHQuaGFzaGVzLihqKSBpOyBpdGVyX2J1Y2tldCAoaSsxKSBqIGJcbiAgICAgIHwgZmFsc2UgLT4gaXRlcl9idWNrZXQgKGkrMSkgaiBiXG4gICAgaW5cbiAgICBBcnJheS5pdGVyaSAoaXRlcl9idWNrZXQgMCkgdC50YWJsZVxuXG5cbiAgbGV0IHJlYyBjb3VudF9idWNrZXQgaSBiIGFjY3UgPVxuICAgIGlmIGkgPj0gbGVuZ3RoIGIgdGhlbiBhY2N1IGVsc2VcbiAgICBjb3VudF9idWNrZXQgKGkrMSkgYiAoYWNjdSArIChpZiBjaGVjayBiIGkgdGhlbiAxIGVsc2UgMCkpXG5cblxuICBsZXQgY291bnQgdCA9XG4gICAgQXJyYXkuZm9sZF9yaWdodCAoY291bnRfYnVja2V0IDApIHQudGFibGUgMFxuXG5cbiAgbGV0IG5leHRfc3ogbiA9IG1pbiAoMyAqIG4gLyAyICsgMykgU3lzLm1heF9hcnJheV9sZW5ndGhcbiAgbGV0IHByZXZfc3ogbiA9ICgobiAtIDMpICogMiArIDIpIC8gM1xuXG4gIGxldCB0ZXN0X3Nocmlua19idWNrZXQgdCA9XG4gICAgbGV0IGJ1Y2tldCA9IHQudGFibGUuKHQucm92ZXIpIGluXG4gICAgbGV0IGhidWNrZXQgPSB0Lmhhc2hlcy4odC5yb3ZlcikgaW5cbiAgICBsZXQgbGVuID0gbGVuZ3RoIGJ1Y2tldCBpblxuICAgIGxldCBwcmV2X2xlbiA9IHByZXZfc3ogbGVuIGluXG4gICAgbGV0IGxpdmUgPSBjb3VudF9idWNrZXQgMCBidWNrZXQgMCBpblxuICAgIGlmIGxpdmUgPD0gcHJldl9sZW4gdGhlbiBiZWdpblxuICAgICAgbGV0IHJlYyBsb29wIGkgaiA9XG4gICAgICAgIGlmIGogPj0gcHJldl9sZW4gdGhlbiBiZWdpblxuICAgICAgICAgIGlmIGNoZWNrIGJ1Y2tldCBpIHRoZW4gbG9vcCAoaSArIDEpIGpcbiAgICAgICAgICBlbHNlIGlmIGNoZWNrIGJ1Y2tldCBqIHRoZW4gYmVnaW5cbiAgICAgICAgICAgIGJsaXQgYnVja2V0IGogYnVja2V0IGkgMTtcbiAgICAgICAgICAgIGhidWNrZXQuKGkpIDwtIGhidWNrZXQuKGopO1xuICAgICAgICAgICAgbG9vcCAoaSArIDEpIChqIC0gMSk7XG4gICAgICAgICAgZW5kIGVsc2UgbG9vcCBpIChqIC0gMSk7XG4gICAgICAgIGVuZDtcbiAgICAgIGluXG4gICAgICBsb29wIDAgKGxlbmd0aCBidWNrZXQgLSAxKTtcbiAgICAgIGlmIHByZXZfbGVuID0gMCB0aGVuIGJlZ2luXG4gICAgICAgIHQudGFibGUuKHQucm92ZXIpIDwtIGVtcHR5YnVja2V0O1xuICAgICAgICB0Lmhhc2hlcy4odC5yb3ZlcikgPC0gW3wgfF07XG4gICAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgICBsZXQgbmV3YnVja2V0ID0gd2Vha19jcmVhdGUgcHJldl9sZW4gaW5cbiAgICAgICAgYmxpdCBidWNrZXQgMCBuZXdidWNrZXQgMCBwcmV2X2xlbjtcbiAgICAgICAgdC50YWJsZS4odC5yb3ZlcikgPC0gbmV3YnVja2V0O1xuICAgICAgICB0Lmhhc2hlcy4odC5yb3ZlcikgPC0gQXJyYXkuc3ViIGhidWNrZXQgMCBwcmV2X2xlblxuICAgICAgZW5kO1xuICAgICAgaWYgbGVuID4gdC5saW1pdCAmJiBwcmV2X2xlbiA8PSB0LmxpbWl0IHRoZW4gdC5vdmVyc2l6ZSA8LSB0Lm92ZXJzaXplIC0gMTtcbiAgICBlbmQ7XG4gICAgdC5yb3ZlciA8LSAodC5yb3ZlciArIDEpIG1vZCAoQXJyYXkubGVuZ3RoIHQudGFibGUpXG5cblxuICBsZXQgcmVjIHJlc2l6ZSB0ID1cbiAgICBsZXQgb2xkbGVuID0gQXJyYXkubGVuZ3RoIHQudGFibGUgaW5cbiAgICBsZXQgbmV3bGVuID0gbmV4dF9zeiBvbGRsZW4gaW5cbiAgICBpZiBuZXdsZW4gPiBvbGRsZW4gdGhlbiBiZWdpblxuICAgICAgbGV0IG5ld3QgPSBjcmVhdGUgbmV3bGVuIGluXG4gICAgICBsZXQgYWRkX3dlYWsgb2Igb2ggb2kgPVxuICAgICAgICBsZXQgc2V0dGVyIG5iIG5pIF8gPSBibGl0IG9iIG9pIG5iIG5pIDEgaW5cbiAgICAgICAgbGV0IGggPSBvaC4ob2kpIGluXG4gICAgICAgIGFkZF9hdXggbmV3dCBzZXR0ZXIgTm9uZSBoIChnZXRfaW5kZXggbmV3dCBoKTtcbiAgICAgIGluXG4gICAgICBpdGVyX3dlYWsgYWRkX3dlYWsgdDtcbiAgICAgIHQudGFibGUgPC0gbmV3dC50YWJsZTtcbiAgICAgIHQuaGFzaGVzIDwtIG5ld3QuaGFzaGVzO1xuICAgICAgdC5saW1pdCA8LSBuZXd0LmxpbWl0O1xuICAgICAgdC5vdmVyc2l6ZSA8LSBuZXd0Lm92ZXJzaXplO1xuICAgICAgdC5yb3ZlciA8LSB0LnJvdmVyIG1vZCBBcnJheS5sZW5ndGggbmV3dC50YWJsZTtcbiAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgdC5saW1pdCA8LSBtYXhfaW50OyAgICAgICAgICAgICAoKiBtYXhpbXVtIHNpemUgYWxyZWFkeSByZWFjaGVkICopXG4gICAgICB0Lm92ZXJzaXplIDwtIDA7XG4gICAgZW5kXG5cbiAgYW5kIGFkZF9hdXggdCBzZXR0ZXIgZCBoIGluZGV4ID1cbiAgICBsZXQgYnVja2V0ID0gdC50YWJsZS4oaW5kZXgpIGluXG4gICAgbGV0IGhhc2hlcyA9IHQuaGFzaGVzLihpbmRleCkgaW5cbiAgICBsZXQgc3ogPSBsZW5ndGggYnVja2V0IGluXG4gICAgbGV0IHJlYyBsb29wIGkgPVxuICAgICAgaWYgaSA+PSBzeiB0aGVuIGJlZ2luXG4gICAgICAgIGxldCBuZXdzeiA9XG4gICAgICAgICAgbWluICgzICogc3ogLyAyICsgMykgKFN5cy5tYXhfYXJyYXlfbGVuZ3RoIC0gYWRkaXRpb25hbF92YWx1ZXMpXG4gICAgICAgIGluXG4gICAgICAgIGlmIG5ld3N6IDw9IHN6IHRoZW4gZmFpbHdpdGggXCJXZWFrLk1ha2U6IGhhc2ggYnVja2V0IGNhbm5vdCBncm93IG1vcmVcIjtcbiAgICAgICAgbGV0IG5ld2J1Y2tldCA9IHdlYWtfY3JlYXRlIG5ld3N6IGluXG4gICAgICAgIGxldCBuZXdoYXNoZXMgPSBBcnJheS5tYWtlIG5ld3N6IDAgaW5cbiAgICAgICAgYmxpdCBidWNrZXQgMCBuZXdidWNrZXQgMCBzejtcbiAgICAgICAgQXJyYXkuYmxpdCBoYXNoZXMgMCBuZXdoYXNoZXMgMCBzejtcbiAgICAgICAgc2V0dGVyIG5ld2J1Y2tldCBzeiBkO1xuICAgICAgICBuZXdoYXNoZXMuKHN6KSA8LSBoO1xuICAgICAgICB0LnRhYmxlLihpbmRleCkgPC0gbmV3YnVja2V0O1xuICAgICAgICB0Lmhhc2hlcy4oaW5kZXgpIDwtIG5ld2hhc2hlcztcbiAgICAgICAgaWYgc3ogPD0gdC5saW1pdCAmJiBuZXdzeiA+IHQubGltaXQgdGhlbiBiZWdpblxuICAgICAgICAgIHQub3ZlcnNpemUgPC0gdC5vdmVyc2l6ZSArIDE7XG4gICAgICAgICAgZm9yIF9pID0gMCB0byBvdmVyX2xpbWl0IGRvIHRlc3Rfc2hyaW5rX2J1Y2tldCB0IGRvbmU7XG4gICAgICAgIGVuZDtcbiAgICAgICAgaWYgdC5vdmVyc2l6ZSA+IEFycmF5Lmxlbmd0aCB0LnRhYmxlIC8gb3Zlcl9saW1pdCB0aGVuIHJlc2l6ZSB0O1xuICAgICAgZW5kIGVsc2UgaWYgY2hlY2sgYnVja2V0IGkgdGhlbiBiZWdpblxuICAgICAgICBsb29wIChpICsgMSlcbiAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgIHNldHRlciBidWNrZXQgaSBkO1xuICAgICAgICBoYXNoZXMuKGkpIDwtIGg7XG4gICAgICBlbmQ7XG4gICAgaW5cbiAgICBsb29wIDBcblxuXG4gIGxldCBhZGQgdCBkID1cbiAgICBsZXQgaCA9IEguaGFzaCBkIGluXG4gICAgYWRkX2F1eCB0IHNldCAoU29tZSBkKSBoIChnZXRfaW5kZXggdCBoKVxuXG5cbiAgbGV0IGZpbmRfb3IgdCBkIGlmbm90Zm91bmQgPVxuICAgIGxldCBoID0gSC5oYXNoIGQgaW5cbiAgICBsZXQgaW5kZXggPSBnZXRfaW5kZXggdCBoIGluXG4gICAgbGV0IGJ1Y2tldCA9IHQudGFibGUuKGluZGV4KSBpblxuICAgIGxldCBoYXNoZXMgPSB0Lmhhc2hlcy4oaW5kZXgpIGluXG4gICAgbGV0IHN6ID0gbGVuZ3RoIGJ1Y2tldCBpblxuICAgIGxldCByZWMgbG9vcCBpID1cbiAgICAgIGlmIGkgPj0gc3ogdGhlbiBpZm5vdGZvdW5kIGggaW5kZXhcbiAgICAgIGVsc2UgaWYgaCA9IGhhc2hlcy4oaSkgdGhlbiBiZWdpblxuICAgICAgICBtYXRjaCBnZXRfY29weSBidWNrZXQgaSB3aXRoXG4gICAgICAgIHwgU29tZSB2IHdoZW4gSC5lcXVhbCB2IGRcbiAgICAgICAgICAgLT4gYmVnaW4gbWF0Y2ggZ2V0IGJ1Y2tldCBpIHdpdGhcbiAgICAgICAgICAgICAgfCBTb21lIHYgLT4gdlxuICAgICAgICAgICAgICB8IE5vbmUgLT4gbG9vcCAoaSArIDEpXG4gICAgICAgICAgICAgIGVuZFxuICAgICAgICB8IF8gLT4gbG9vcCAoaSArIDEpXG4gICAgICBlbmQgZWxzZSBsb29wIChpICsgMSlcbiAgICBpblxuICAgIGxvb3AgMFxuXG5cbiAgbGV0IG1lcmdlIHQgZCA9XG4gICAgZmluZF9vciB0IGQgKGZ1biBoIGluZGV4IC0+IGFkZF9hdXggdCBzZXQgKFNvbWUgZCkgaCBpbmRleDsgZClcblxuXG4gIGxldCBmaW5kIHQgZCA9IGZpbmRfb3IgdCBkIChmdW4gX2ggX2luZGV4IC0+IHJhaXNlIE5vdF9mb3VuZClcblxuICBsZXQgZmluZF9vcHQgdCBkID1cbiAgICBsZXQgaCA9IEguaGFzaCBkIGluXG4gICAgbGV0IGluZGV4ID0gZ2V0X2luZGV4IHQgaCBpblxuICAgIGxldCBidWNrZXQgPSB0LnRhYmxlLihpbmRleCkgaW5cbiAgICBsZXQgaGFzaGVzID0gdC5oYXNoZXMuKGluZGV4KSBpblxuICAgIGxldCBzeiA9IGxlbmd0aCBidWNrZXQgaW5cbiAgICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgICBpZiBpID49IHN6IHRoZW4gTm9uZVxuICAgICAgZWxzZSBpZiBoID0gaGFzaGVzLihpKSB0aGVuIGJlZ2luXG4gICAgICAgIG1hdGNoIGdldF9jb3B5IGJ1Y2tldCBpIHdpdGhcbiAgICAgICAgfCBTb21lIHYgd2hlbiBILmVxdWFsIHYgZFxuICAgICAgICAgICAtPiBiZWdpbiBtYXRjaCBnZXQgYnVja2V0IGkgd2l0aFxuICAgICAgICAgICAgICB8IFNvbWUgXyBhcyB2IC0+IHZcbiAgICAgICAgICAgICAgfCBOb25lIC0+IGxvb3AgKGkgKyAxKVxuICAgICAgICAgICAgICBlbmRcbiAgICAgICAgfCBfIC0+IGxvb3AgKGkgKyAxKVxuICAgICAgZW5kIGVsc2UgbG9vcCAoaSArIDEpXG4gICAgaW5cbiAgICBsb29wIDBcblxuXG4gIGxldCBmaW5kX3NoYWRvdyB0IGQgaWZmb3VuZCBpZm5vdGZvdW5kID1cbiAgICBsZXQgaCA9IEguaGFzaCBkIGluXG4gICAgbGV0IGluZGV4ID0gZ2V0X2luZGV4IHQgaCBpblxuICAgIGxldCBidWNrZXQgPSB0LnRhYmxlLihpbmRleCkgaW5cbiAgICBsZXQgaGFzaGVzID0gdC5oYXNoZXMuKGluZGV4KSBpblxuICAgIGxldCBzeiA9IGxlbmd0aCBidWNrZXQgaW5cbiAgICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgICBpZiBpID49IHN6IHRoZW4gaWZub3Rmb3VuZFxuICAgICAgZWxzZSBpZiBoID0gaGFzaGVzLihpKSB0aGVuIGJlZ2luXG4gICAgICAgIG1hdGNoIGdldF9jb3B5IGJ1Y2tldCBpIHdpdGhcbiAgICAgICAgfCBTb21lIHYgd2hlbiBILmVxdWFsIHYgZCAtPiBpZmZvdW5kIGJ1Y2tldCBpXG4gICAgICAgIHwgXyAtPiBsb29wIChpICsgMSlcbiAgICAgIGVuZCBlbHNlIGxvb3AgKGkgKyAxKVxuICAgIGluXG4gICAgbG9vcCAwXG5cblxuICBsZXQgcmVtb3ZlIHQgZCA9IGZpbmRfc2hhZG93IHQgZCAoZnVuIHcgaSAtPiBzZXQgdyBpIE5vbmUpICgpXG5cblxuICBsZXQgbWVtIHQgZCA9IGZpbmRfc2hhZG93IHQgZCAoZnVuIF93IF9pIC0+IHRydWUpIGZhbHNlXG5cblxuICBsZXQgZmluZF9hbGwgdCBkID1cbiAgICBsZXQgaCA9IEguaGFzaCBkIGluXG4gICAgbGV0IGluZGV4ID0gZ2V0X2luZGV4IHQgaCBpblxuICAgIGxldCBidWNrZXQgPSB0LnRhYmxlLihpbmRleCkgaW5cbiAgICBsZXQgaGFzaGVzID0gdC5oYXNoZXMuKGluZGV4KSBpblxuICAgIGxldCBzeiA9IGxlbmd0aCBidWNrZXQgaW5cbiAgICBsZXQgcmVjIGxvb3AgaSBhY2N1ID1cbiAgICAgIGlmIGkgPj0gc3ogdGhlbiBhY2N1XG4gICAgICBlbHNlIGlmIGggPSBoYXNoZXMuKGkpIHRoZW4gYmVnaW5cbiAgICAgICAgbWF0Y2ggZ2V0X2NvcHkgYnVja2V0IGkgd2l0aFxuICAgICAgICB8IFNvbWUgdiB3aGVuIEguZXF1YWwgdiBkXG4gICAgICAgICAgIC0+IGJlZ2luIG1hdGNoIGdldCBidWNrZXQgaSB3aXRoXG4gICAgICAgICAgICAgIHwgU29tZSB2IC0+IGxvb3AgKGkgKyAxKSAodiA6OiBhY2N1KVxuICAgICAgICAgICAgICB8IE5vbmUgLT4gbG9vcCAoaSArIDEpIGFjY3VcbiAgICAgICAgICAgICAgZW5kXG4gICAgICAgIHwgXyAtPiBsb29wIChpICsgMSkgYWNjdVxuICAgICAgZW5kIGVsc2UgbG9vcCAoaSArIDEpIGFjY3VcbiAgICBpblxuICAgIGxvb3AgMCBbXVxuXG5cbiAgbGV0IHN0YXRzIHQgPVxuICAgIGxldCBsZW4gPSBBcnJheS5sZW5ndGggdC50YWJsZSBpblxuICAgIGxldCBsZW5zID0gQXJyYXkubWFwIGxlbmd0aCB0LnRhYmxlIGluXG4gICAgQXJyYXkuc29ydCBjb21wYXJlIGxlbnM7XG4gICAgbGV0IHRvdGxlbiA9IEFycmF5LmZvbGRfbGVmdCAoICsgKSAwIGxlbnMgaW5cbiAgICAobGVuLCBjb3VudCB0LCB0b3RsZW4sIGxlbnMuKDApLCBsZW5zLihsZW4vMiksIGxlbnMuKGxlbi0xKSlcblxuXG5lbmRcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFBpZXJyZSBXZWlzLCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogQSBwcmV0dHktcHJpbnRpbmcgZmFjaWxpdHkgYW5kIGRlZmluaXRpb24gb2YgZm9ybWF0dGVycyBmb3IgJ3BhcmFsbGVsJ1xuICAgKGkuZS4gdW5yZWxhdGVkIG9yIGluZGVwZW5kZW50KSBwcmV0dHktcHJpbnRpbmcgb24gbXVsdGlwbGUgb3V0IGNoYW5uZWxzLiAqKVxuXG4oKlxuICAgVGhlIHByZXR0eS1wcmludGluZyBlbmdpbmUgaW50ZXJuYWwgZGF0YSBzdHJ1Y3R1cmVzLlxuKilcblxubGV0IGlkIHggPSB4XG5cbigqIEEgZGV2b3RlZCB0eXBlIGZvciBzaXplcyB0byBhdm9pZCBjb25mdXNpb25cbiAgIGJldHdlZW4gc2l6ZXMgYW5kIG1lcmUgaW50ZWdlcnMuICopXG5tb2R1bGUgU2l6ZSA6IHNpZ1xuICB0eXBlIHRcblxuICB2YWwgdG9faW50IDogdCAtPiBpbnRcbiAgdmFsIG9mX2ludCA6IGludCAtPiB0XG4gIHZhbCB6ZXJvIDogdFxuICB2YWwgdW5rbm93biA6IHRcbiAgdmFsIGlzX2tub3duIDogdCAtPiBib29sXG5lbmQgID0gc3RydWN0XG4gIHR5cGUgdCA9IGludFxuXG4gIGxldCB0b19pbnQgPSBpZFxuICBsZXQgb2ZfaW50ID0gaWRcbiAgbGV0IHplcm8gPSAwXG4gIGxldCB1bmtub3duID0gLTFcbiAgbGV0IGlzX2tub3duIG4gPSBuID49IDBcbmVuZFxuXG5cblxuKCogVGhlIHByZXR0eS1wcmludGluZyBib3hlcyBkZWZpbml0aW9uOlxuICAgYSBwcmV0dHktcHJpbnRpbmcgYm94IGlzIGVpdGhlclxuICAgLSBoYm94OiBob3Jpem9udGFsIGJveCAobm8gbGluZSBzcGxpdHRpbmcpXG4gICAtIHZib3g6IHZlcnRpY2FsIGJveCAoZXZlcnkgYnJlYWsgaGludCBzcGxpdHMgdGhlIGxpbmUpXG4gICAtIGh2Ym94OiBob3Jpem9udGFsL3ZlcnRpY2FsIGJveFxuICAgICAodGhlIGJveCBiZWhhdmVzIGFzIGFuIGhvcml6b250YWwgYm94IGlmIGl0IGZpdHMgb25cbiAgICAgIHRoZSBjdXJyZW50IGxpbmUsIG90aGVyd2lzZSB0aGUgYm94IGJlaGF2ZXMgYXMgYSB2ZXJ0aWNhbCBib3gpXG4gICAtIGhvdmJveDogaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbCBjb21wYWN0aW5nIGJveFxuICAgICAodGhlIGJveCBpcyBjb21wYWN0aW5nIG1hdGVyaWFsLCBwcmludGluZyBhcyBtdWNoIG1hdGVyaWFsIGFzIHBvc3NpYmxlXG4gICAgICBvbiBldmVyeSBsaW5lcylcbiAgIC0gYm94OiBob3Jpem9udGFsIG9yIHZlcnRpY2FsIGNvbXBhY3RpbmcgYm94IHdpdGggZW5oYW5jZWQgYm94IHN0cnVjdHVyZVxuICAgICAodGhlIGJveCBiZWhhdmVzIGFzIGFuIGhvcml6b250YWwgb3IgdmVydGljYWwgYm94IGJ1dCBicmVhayBoaW50cyBzcGxpdFxuICAgICAgdGhlIGxpbmUgaWYgc3BsaXR0aW5nIHdvdWxkIG1vdmUgdG8gdGhlIGxlZnQpXG4qKVxudHlwZSBib3hfdHlwZSA9IENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljcy5ibG9ja190eXBlID1cbiAgfCBQcF9oYm94IHwgUHBfdmJveCB8IFBwX2h2Ym94IHwgUHBfaG92Ym94IHwgUHBfYm94IHwgUHBfZml0c1xuXG5cbigqIFRoZSBwcmV0dHktcHJpbnRpbmcgdG9rZW5zIGRlZmluaXRpb246XG4gICBhcmUgZWl0aGVyIHRleHQgdG8gcHJpbnQgb3IgcHJldHR5IHByaW50aW5nXG4gICBlbGVtZW50cyB0aGF0IGRyaXZlIGluZGVudGF0aW9uIGFuZCBsaW5lIHNwbGl0dGluZy4gKilcbnR5cGUgcHBfdG9rZW4gPVxuICB8IFBwX3RleHQgb2Ygc3RyaW5nICAgICAgICAgICgqIG5vcm1hbCB0ZXh0ICopXG4gIHwgUHBfYnJlYWsgb2YgeyAgICAgICAgICAgICAgKCogY29tcGxldGUgYnJlYWsgKilcbiAgICAgIGZpdHM6IHN0cmluZyAqIGludCAqIHN0cmluZzsgICAoKiBsaW5lIGlzIG5vdCBzcGxpdCAqKVxuICAgICAgYnJlYWtzOiBzdHJpbmcgKiBpbnQgKiBzdHJpbmc7ICgqIGxpbmUgaXMgc3BsaXQgKilcbiAgICB9XG4gIHwgUHBfdGJyZWFrIG9mIGludCAqIGludCAgICAgKCogZ28gdG8gbmV4dCB0YWJ1bGF0aW9uICopXG4gIHwgUHBfc3RhYiAgICAgICAgICAgICAgICAgICAgKCogc2V0IGEgdGFidWxhdGlvbiAqKVxuICB8IFBwX2JlZ2luIG9mIGludCAqIGJveF90eXBlICgqIGJlZ2lubmluZyBvZiBhIGJveCAqKVxuICB8IFBwX2VuZCAgICAgICAgICAgICAgICAgICAgICgqIGVuZCBvZiBhIGJveCAqKVxuICB8IFBwX3RiZWdpbiBvZiB0Ym94ICAgICAgICAgICgqIGJlZ2lubmluZyBvZiBhIHRhYnVsYXRpb24gYm94ICopXG4gIHwgUHBfdGVuZCAgICAgICAgICAgICAgICAgICAgKCogZW5kIG9mIGEgdGFidWxhdGlvbiBib3ggKilcbiAgfCBQcF9uZXdsaW5lICAgICAgICAgICAgICAgICAoKiB0byBmb3JjZSBhIG5ld2xpbmUgaW5zaWRlIGEgYm94ICopXG4gIHwgUHBfaWZfbmV3bGluZSAgICAgICAgICAgICAgKCogdG8gZG8gc29tZXRoaW5nIG9ubHkgaWYgdGhpcyB2ZXJ5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZSBoYXMgYmVlbiBicm9rZW4gKilcbiAgfCBQcF9vcGVuX3RhZyBvZiBzdGFnICAgICAgICAgKCogb3BlbmluZyBhIHRhZyBuYW1lICopXG4gIHwgUHBfY2xvc2VfdGFnICAgICAgICAgICAgICAgKCogY2xvc2luZyB0aGUgbW9zdCByZWNlbnRseSBvcGVuIHRhZyAqKVxuXG5hbmQgc3RhZyA9IC4uXG5cbmFuZCB0Ym94ID0gUHBfdGJveCBvZiBpbnQgbGlzdCByZWYgICgqIFRhYnVsYXRpb24gYm94ICopXG5cbnR5cGUgdGFnID0gc3RyaW5nXG50eXBlIHN0YWcgKz0gU3RyaW5nX3RhZyBvZiB0YWdcblxuXG4oKiBUaGUgcHJldHR5LXByaW50ZXIgcXVldWU6XG4gICBwcmV0dHktcHJpbnRpbmcgbWF0ZXJpYWwgaXMgbm90IHdyaXR0ZW4gaW4gdGhlIG91dHB1dCBhcyBzb29uIGFzIGVtaXR0ZWQ7XG4gICBpbnN0ZWFkLCB0aGUgbWF0ZXJpYWwgaXMgc2ltcGx5IHJlY29yZGVkIGluIHRoZSBwcmV0dHktcHJpbnRlciBxdWV1ZSxcbiAgIHVudGlsIHRoZSBlbmNsb3NpbmcgYm94IGhhcyBhIGtub3duIGNvbXB1dGVkIHNpemUgYW5kIHByb3BlciBzcGxpdHRpbmdcbiAgIGRlY2lzaW9ucyBjYW4gYmUgbWFkZS5cblxuICAgVGhlIHByZXR0eS1wcmludGVyIHF1ZXVlIGNvbnRhaW5zIGZvcm1hdHRpbmcgZWxlbWVudHMgdG8gYmUgcHJpbnRlZC5cbiAgIEVhY2ggZm9ybWF0dGluZyBlbGVtZW50IGlzIGEgdHVwbGUgKHNpemUsIHRva2VuLCBsZW5ndGgpLCB3aGVyZVxuICAgLSBsZW5ndGggaXMgdGhlIGRlY2xhcmVkIGxlbmd0aCBvZiB0aGUgdG9rZW4sXG4gICAtIHNpemUgaXMgZWZmZWN0aXZlIHNpemUgb2YgdGhlIHRva2VuIHdoZW4gaXQgaXMgcHJpbnRlZFxuICAgICAoc2l6ZSBpcyBzZXQgd2hlbiB0aGUgc2l6ZSBvZiB0aGUgYm94IGlzIGtub3duLCBzbyB0aGF0IHNpemUgb2YgYnJlYWtcbiAgICAgIGhpbnRzIGFyZSBkZWZpbml0aXZlKS4gKilcbnR5cGUgcHBfcXVldWVfZWxlbSA9IHtcbiAgbXV0YWJsZSBzaXplIDogU2l6ZS50O1xuICB0b2tlbiA6IHBwX3Rva2VuO1xuICBsZW5ndGggOiBpbnQ7XG59XG5cblxuKCogVGhlIHByZXR0eS1wcmludGVyIHF1ZXVlIGRlZmluaXRpb24uICopXG50eXBlIHBwX3F1ZXVlID0gcHBfcXVldWVfZWxlbSBRdWV1ZS50XG5cbigqIFRoZSBwcmV0dHktcHJpbnRlciBzY2FubmluZyBzdGFjay4gKilcblxuKCogVGhlIHByZXR0eS1wcmludGVyIHNjYW5uaW5nIHN0YWNrOiBzY2FubmluZyBlbGVtZW50IGRlZmluaXRpb24uICopXG50eXBlIHBwX3NjYW5fZWxlbSA9IHtcbiAgbGVmdF90b3RhbCA6IGludDsgKCogVmFsdWUgb2YgcHBfbGVmdF90b3RhbCB3aGVuIHRoZSBlbGVtZW50IHdhcyBlbnF1ZXVlZC4gKilcbiAgcXVldWVfZWxlbSA6IHBwX3F1ZXVlX2VsZW1cbn1cblxuKCogVGhlIHByZXR0eS1wcmludGVyIGZvcm1hdHRpbmcgc3RhY2s6XG4gICB0aGUgZm9ybWF0dGluZyBzdGFjayBjb250YWlucyB0aGUgZGVzY3JpcHRpb24gb2YgYWxsIHRoZSBjdXJyZW50bHkgYWN0aXZlXG4gICBib3hlczsgdGhlIHByZXR0eS1wcmludGVyIGZvcm1hdHRpbmcgc3RhY2sgaXMgdXNlZCB0byBzcGxpdCB0aGUgbGluZXNcbiAgIHdoaWxlIHByaW50aW5nIHRva2Vucy4gKilcblxuKCogVGhlIHByZXR0eS1wcmludGVyIGZvcm1hdHRpbmcgc3RhY2s6IGZvcm1hdHRpbmcgc3RhY2sgZWxlbWVudCBkZWZpbml0aW9uLlxuICAgRWFjaCBzdGFjayBlbGVtZW50IGRlc2NyaWJlcyBhIHByZXR0eS1wcmludGluZyBib3guICopXG50eXBlIHBwX2Zvcm1hdF9lbGVtID0geyBib3hfdHlwZSA6IGJveF90eXBlOyB3aWR0aCA6IGludCB9XG5cbigqIFRoZSBmb3JtYXR0ZXIgZGVmaW5pdGlvbi5cbiAgIEVhY2ggZm9ybWF0dGVyIHZhbHVlIGlzIGEgcHJldHR5LXByaW50ZXIgaW5zdGFuY2Ugd2l0aCBhbGwgaXRzXG4gICBtYWNoaW5lcnkuICopXG50eXBlIGZvcm1hdHRlciA9IHtcbiAgKCogVGhlIHByZXR0eS1wcmludGVyIHNjYW5uaW5nIHN0YWNrLiAqKVxuICBwcF9zY2FuX3N0YWNrIDogcHBfc2Nhbl9lbGVtIFN0YWNrLnQ7XG4gICgqIFRoZSBwcmV0dHktcHJpbnRlciBmb3JtYXR0aW5nIHN0YWNrLiAqKVxuICBwcF9mb3JtYXRfc3RhY2sgOiBwcF9mb3JtYXRfZWxlbSBTdGFjay50O1xuICBwcF90Ym94X3N0YWNrIDogdGJveCBTdGFjay50O1xuICAoKiBUaGUgcHJldHR5LXByaW50ZXIgc2VtYW50aWNzIHRhZyBzdGFjay4gKilcbiAgcHBfdGFnX3N0YWNrIDogc3RhZyBTdGFjay50O1xuICBwcF9tYXJrX3N0YWNrIDogc3RhZyBTdGFjay50O1xuICAoKiBWYWx1ZSBvZiByaWdodCBtYXJnaW4uICopXG4gIG11dGFibGUgcHBfbWFyZ2luIDogaW50O1xuICAoKiBNaW5pbWFsIHNwYWNlIGxlZnQgYmVmb3JlIG1hcmdpbiwgd2hlbiBvcGVuaW5nIGEgYm94LiAqKVxuICBtdXRhYmxlIHBwX21pbl9zcGFjZV9sZWZ0IDogaW50O1xuICAoKiBNYXhpbXVtIHZhbHVlIG9mIGluZGVudGF0aW9uOlxuICAgICBubyBib3ggY2FuIGJlIG9wZW5lZCBmdXJ0aGVyLiAqKVxuICBtdXRhYmxlIHBwX21heF9pbmRlbnQgOiBpbnQ7XG4gICgqIFNwYWNlIHJlbWFpbmluZyBvbiB0aGUgY3VycmVudCBsaW5lLiAqKVxuICBtdXRhYmxlIHBwX3NwYWNlX2xlZnQgOiBpbnQ7XG4gICgqIEN1cnJlbnQgdmFsdWUgb2YgaW5kZW50YXRpb24uICopXG4gIG11dGFibGUgcHBfY3VycmVudF9pbmRlbnQgOiBpbnQ7XG4gICgqIFRydWUgd2hlbiB0aGUgbGluZSBoYXMgYmVlbiBicm9rZW4gYnkgdGhlIHByZXR0eS1wcmludGVyLiAqKVxuICBtdXRhYmxlIHBwX2lzX25ld19saW5lIDogYm9vbDtcbiAgKCogVG90YWwgd2lkdGggb2YgdG9rZW5zIGFscmVhZHkgcHJpbnRlZC4gKilcbiAgbXV0YWJsZSBwcF9sZWZ0X3RvdGFsIDogaW50O1xuICAoKiBUb3RhbCB3aWR0aCBvZiB0b2tlbnMgZXZlciBwdXQgaW4gcXVldWUuICopXG4gIG11dGFibGUgcHBfcmlnaHRfdG90YWwgOiBpbnQ7XG4gICgqIEN1cnJlbnQgbnVtYmVyIG9mIG9wZW4gYm94ZXMuICopXG4gIG11dGFibGUgcHBfY3Vycl9kZXB0aCA6IGludDtcbiAgKCogTWF4aW11bSBudW1iZXIgb2YgYm94ZXMgd2hpY2ggY2FuIGJlIHNpbXVsdGFuZW91c2x5IG9wZW4uICopXG4gIG11dGFibGUgcHBfbWF4X2JveGVzIDogaW50O1xuICAoKiBFbGxpcHNpcyBzdHJpbmcuICopXG4gIG11dGFibGUgcHBfZWxsaXBzaXMgOiBzdHJpbmc7XG4gICgqIE91dHB1dCBmdW5jdGlvbi4gKilcbiAgbXV0YWJsZSBwcF9vdXRfc3RyaW5nIDogc3RyaW5nIC0+IGludCAtPiBpbnQgLT4gdW5pdDtcbiAgKCogRmx1c2hpbmcgZnVuY3Rpb24uICopXG4gIG11dGFibGUgcHBfb3V0X2ZsdXNoIDogdW5pdCAtPiB1bml0O1xuICAoKiBPdXRwdXQgb2YgbmV3IGxpbmVzLiAqKVxuICBtdXRhYmxlIHBwX291dF9uZXdsaW5lIDogdW5pdCAtPiB1bml0O1xuICAoKiBPdXRwdXQgb2YgYnJlYWsgaGludHMgc3BhY2VzLiAqKVxuICBtdXRhYmxlIHBwX291dF9zcGFjZXMgOiBpbnQgLT4gdW5pdDtcbiAgKCogT3V0cHV0IG9mIGluZGVudGF0aW9uIG9mIG5ldyBsaW5lcy4gKilcbiAgbXV0YWJsZSBwcF9vdXRfaW5kZW50IDogaW50IC0+IHVuaXQ7XG4gICgqIEFyZSB0YWdzIHByaW50ZWQgPyAqKVxuICBtdXRhYmxlIHBwX3ByaW50X3RhZ3MgOiBib29sO1xuICAoKiBBcmUgdGFncyBtYXJrZWQgPyAqKVxuICBtdXRhYmxlIHBwX21hcmtfdGFncyA6IGJvb2w7XG4gICgqIEZpbmQgb3BlbmluZyBhbmQgY2xvc2luZyBtYXJrZXJzIG9mIHRhZ3MuICopXG4gIG11dGFibGUgcHBfbWFya19vcGVuX3RhZyA6IHN0YWcgLT4gc3RyaW5nO1xuICBtdXRhYmxlIHBwX21hcmtfY2xvc2VfdGFnIDogc3RhZyAtPiBzdHJpbmc7XG4gIG11dGFibGUgcHBfcHJpbnRfb3Blbl90YWcgOiBzdGFnIC0+IHVuaXQ7XG4gIG11dGFibGUgcHBfcHJpbnRfY2xvc2VfdGFnIDogc3RhZyAtPiB1bml0O1xuICAoKiBUaGUgcHJldHR5LXByaW50ZXIgcXVldWUuICopXG4gIHBwX3F1ZXVlIDogcHBfcXVldWU7XG59XG5cblxuKCogVGhlIGZvcm1hdHRlciBzcGVjaWZpYyB0YWcgaGFuZGxpbmcgZnVuY3Rpb25zLiAqKVxudHlwZSBmb3JtYXR0ZXJfc3RhZ19mdW5jdGlvbnMgPSB7XG4gIG1hcmtfb3Blbl9zdGFnIDogc3RhZyAtPiBzdHJpbmc7XG4gIG1hcmtfY2xvc2Vfc3RhZyA6IHN0YWcgLT4gc3RyaW5nO1xuICBwcmludF9vcGVuX3N0YWcgOiBzdGFnIC0+IHVuaXQ7XG4gIHByaW50X2Nsb3NlX3N0YWcgOiBzdGFnIC0+IHVuaXQ7XG59XG5cblxuKCogVGhlIGZvcm1hdHRlciBmdW5jdGlvbnMgdG8gb3V0cHV0IG1hdGVyaWFsLiAqKVxudHlwZSBmb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyA9IHtcbiAgb3V0X3N0cmluZyA6IHN0cmluZyAtPiBpbnQgLT4gaW50IC0+IHVuaXQ7XG4gIG91dF9mbHVzaCA6IHVuaXQgLT4gdW5pdDtcbiAgb3V0X25ld2xpbmUgOiB1bml0IC0+IHVuaXQ7XG4gIG91dF9zcGFjZXMgOiBpbnQgLT4gdW5pdDtcbiAgb3V0X2luZGVudCA6IGludCAtPiB1bml0O1xufVxuXG5cbigqXG5cbiAgQXV4aWxpYXJpZXMgYW5kIGJhc2ljIGZ1bmN0aW9ucy5cblxuKilcblxuKCogRW50ZXIgYSB0b2tlbiBpbiB0aGUgcHJldHR5LXByaW50ZXIgcXVldWUuICopXG5sZXQgcHBfZW5xdWV1ZSBzdGF0ZSB0b2tlbiA9XG4gIHN0YXRlLnBwX3JpZ2h0X3RvdGFsIDwtIHN0YXRlLnBwX3JpZ2h0X3RvdGFsICsgdG9rZW4ubGVuZ3RoO1xuICBRdWV1ZS5hZGQgdG9rZW4gc3RhdGUucHBfcXVldWVcblxuXG5sZXQgcHBfY2xlYXJfcXVldWUgc3RhdGUgPVxuICBzdGF0ZS5wcF9sZWZ0X3RvdGFsIDwtIDE7IHN0YXRlLnBwX3JpZ2h0X3RvdGFsIDwtIDE7XG4gIFF1ZXVlLmNsZWFyIHN0YXRlLnBwX3F1ZXVlXG5cblxuKCogUHBfaW5maW5pdHk6IGxhcmdlIHZhbHVlIGZvciBkZWZhdWx0IHRva2VucyBzaXplLlxuXG4gICBQcF9pbmZpbml0eSBpcyBkb2N1bWVudGVkIGFzIGJlaW5nIGdyZWF0ZXIgdGhhbiAxZTEwOyB0byBhdm9pZFxuICAgY29uZnVzaW9uIGFib3V0IHRoZSB3b3JkICdncmVhdGVyJywgd2UgY2hvb3NlIHBwX2luZmluaXR5IGdyZWF0ZXJcbiAgIHRoYW4gMWUxMCArIDE7IGZvciBjb3JyZWN0IGhhbmRsaW5nIG9mIHRlc3RzIGluIHRoZSBhbGdvcml0aG0sXG4gICBwcF9pbmZpbml0eSBtdXN0IGJlIGV2ZW4gb25lIG1vcmUgdGhhbiAxZTEwICsgMTsgbGV0J3Mgc3RhbmQgb24gdGhlXG4gICBzYWZlIHNpZGUgYnkgY2hvb3NpbmcgMS5lMTArMTAuXG5cbiAgIFBwX2luZmluaXR5IGNvdWxkIHByb2JhYmx5IGJlIDEwNzM3NDE4MjMgdGhhdCBpcyAyXjMwIC0gMSwgdGhhdCBpc1xuICAgdGhlIG1pbmltYWwgdXBwZXIgYm91bmQgZm9yIGludGVnZXJzOyBub3cgdGhhdCBtYXhfaW50IGlzIGRlZmluZWQsXG4gICB0aGlzIGxpbWl0IGNvdWxkIGFsc28gYmUgZGVmaW5lZCBhcyBtYXhfaW50IC0gMS5cblxuICAgSG93ZXZlciwgYmVmb3JlIHNldHRpbmcgcHBfaW5maW5pdHkgdG8gc29tZXRoaW5nIGFyb3VuZCBtYXhfaW50LCB3ZVxuICAgbXVzdCBjYXJlZnVsbHkgZG91YmxlLWNoZWNrIGFsbCB0aGUgaW50ZWdlciBhcml0aG1ldGljIG9wZXJhdGlvbnNcbiAgIHRoYXQgaW52b2x2ZSBwcF9pbmZpbml0eSwgc2luY2UgYW55IG92ZXJmbG93IHdvdWxkIHdyZWNrIGhhdm9jIHRoZVxuICAgcHJldHR5LXByaW50aW5nIGFsZ29yaXRobSdzIGludmFyaWFudHMuIEdpdmVuIHRoYXQgdGhpcyBhcml0aG1ldGljXG4gICBjb3JyZWN0bmVzcyBjaGVjayBpcyBkaWZmaWN1bHQgYW5kIGVycm9yIHByb25lIGFuZCBnaXZlbiB0aGF0IDFlMTBcbiAgICsgMSBpcyBpbiBwcmFjdGljZSBsYXJnZSBlbm91Z2gsIHRoZXJlIGlzIG5vIG5lZWQgdG8gYXR0ZW1wdCB0byBzZXRcbiAgIHBwX2luZmluaXR5IHRvIHRoZSB0aGVvcmV0aWNhbGx5IG1heGltdW0gbGltaXQuIEl0IGlzIG5vdCB3b3J0aCB0aGVcbiAgIGJ1cmRlbiAhICopXG5sZXQgcHBfaW5maW5pdHkgPSAxMDAwMDAwMDEwXG5cbigqIE91dHB1dCBmdW5jdGlvbnMgZm9yIHRoZSBmb3JtYXR0ZXIuICopXG5sZXQgcHBfb3V0cHV0X3N0cmluZyBzdGF0ZSBzID0gc3RhdGUucHBfb3V0X3N0cmluZyBzIDAgKFN0cmluZy5sZW5ndGggcylcbmFuZCBwcF9vdXRwdXRfbmV3bGluZSBzdGF0ZSA9IHN0YXRlLnBwX291dF9uZXdsaW5lICgpXG5hbmQgcHBfb3V0cHV0X3NwYWNlcyBzdGF0ZSBuID0gc3RhdGUucHBfb3V0X3NwYWNlcyBuXG5hbmQgcHBfb3V0cHV0X2luZGVudCBzdGF0ZSBuID0gc3RhdGUucHBfb3V0X2luZGVudCBuXG5cbigqIEZvcm1hdCBhIHRleHR1YWwgdG9rZW4gKilcbmxldCBmb3JtYXRfcHBfdGV4dCBzdGF0ZSBzaXplIHRleHQgPVxuICBzdGF0ZS5wcF9zcGFjZV9sZWZ0IDwtIHN0YXRlLnBwX3NwYWNlX2xlZnQgLSBzaXplO1xuICBwcF9vdXRwdXRfc3RyaW5nIHN0YXRlIHRleHQ7XG4gIHN0YXRlLnBwX2lzX25ld19saW5lIDwtIGZhbHNlXG5cbigqIEZvcm1hdCBhIHN0cmluZyBieSBpdHMgbGVuZ3RoLCBpZiBub3QgZW1wdHkgKilcbmxldCBmb3JtYXRfc3RyaW5nIHN0YXRlIHMgPVxuICBpZiBzIDw+IFwiXCIgdGhlbiBmb3JtYXRfcHBfdGV4dCBzdGF0ZSAoU3RyaW5nLmxlbmd0aCBzKSBzXG5cbigqIFRvIGZvcm1hdCBhIGJyZWFrLCBpbmRlbnRpbmcgYSBuZXcgbGluZS4gKilcbmxldCBicmVha19uZXdfbGluZSBzdGF0ZSAoYmVmb3JlLCBvZmZzZXQsIGFmdGVyKSB3aWR0aCA9XG4gIGZvcm1hdF9zdHJpbmcgc3RhdGUgYmVmb3JlO1xuICBwcF9vdXRwdXRfbmV3bGluZSBzdGF0ZTtcbiAgc3RhdGUucHBfaXNfbmV3X2xpbmUgPC0gdHJ1ZTtcbiAgbGV0IGluZGVudCA9IHN0YXRlLnBwX21hcmdpbiAtIHdpZHRoICsgb2Zmc2V0IGluXG4gICgqIERvbid0IGluZGVudCBtb3JlIHRoYW4gcHBfbWF4X2luZGVudC4gKilcbiAgbGV0IHJlYWxfaW5kZW50ID0gbWluIHN0YXRlLnBwX21heF9pbmRlbnQgaW5kZW50IGluXG4gIHN0YXRlLnBwX2N1cnJlbnRfaW5kZW50IDwtIHJlYWxfaW5kZW50O1xuICBzdGF0ZS5wcF9zcGFjZV9sZWZ0IDwtIHN0YXRlLnBwX21hcmdpbiAtIHN0YXRlLnBwX2N1cnJlbnRfaW5kZW50O1xuICBwcF9vdXRwdXRfaW5kZW50IHN0YXRlIHN0YXRlLnBwX2N1cnJlbnRfaW5kZW50O1xuICBmb3JtYXRfc3RyaW5nIHN0YXRlIGFmdGVyXG5cblxuKCogVG8gZm9yY2UgYSBsaW5lIGJyZWFrIGluc2lkZSBhIGJveDogbm8gb2Zmc2V0IGlzIGFkZGVkLiAqKVxubGV0IGJyZWFrX2xpbmUgc3RhdGUgd2lkdGggPSBicmVha19uZXdfbGluZSBzdGF0ZSAoXCJcIiwgMCwgXCJcIikgd2lkdGhcblxuKCogVG8gZm9ybWF0IGEgYnJlYWsgdGhhdCBmaXRzIG9uIHRoZSBjdXJyZW50IGxpbmUuICopXG5sZXQgYnJlYWtfc2FtZV9saW5lIHN0YXRlIChiZWZvcmUsIHdpZHRoLCBhZnRlcikgPVxuICBmb3JtYXRfc3RyaW5nIHN0YXRlIGJlZm9yZTtcbiAgc3RhdGUucHBfc3BhY2VfbGVmdCA8LSBzdGF0ZS5wcF9zcGFjZV9sZWZ0IC0gd2lkdGg7XG4gIHBwX291dHB1dF9zcGFjZXMgc3RhdGUgd2lkdGg7XG4gIGZvcm1hdF9zdHJpbmcgc3RhdGUgYWZ0ZXJcblxuXG4oKiBUbyBpbmRlbnQgbm8gbW9yZSB0aGFuIHBwX21heF9pbmRlbnQsIGlmIG9uZSB0cmllcyB0byBvcGVuIGEgYm94XG4gICBiZXlvbmQgcHBfbWF4X2luZGVudCwgdGhlbiB0aGUgYm94IGlzIHJlamVjdGVkIG9uIHRoZSBsZWZ0XG4gICBieSBzaW11bGF0aW5nIGEgYnJlYWsuICopXG5sZXQgcHBfZm9yY2VfYnJlYWtfbGluZSBzdGF0ZSA9XG4gIG1hdGNoIFN0YWNrLnRvcF9vcHQgc3RhdGUucHBfZm9ybWF0X3N0YWNrIHdpdGhcbiAgfCBOb25lIC0+IHBwX291dHB1dF9uZXdsaW5lIHN0YXRlXG4gIHwgU29tZSB7IGJveF90eXBlOyB3aWR0aCB9IC0+XG4gICAgaWYgd2lkdGggPiBzdGF0ZS5wcF9zcGFjZV9sZWZ0IHRoZW5cbiAgICAgIG1hdGNoIGJveF90eXBlIHdpdGhcbiAgICAgIHwgUHBfZml0cyB8IFBwX2hib3ggLT4gKClcbiAgICAgIHwgUHBfdmJveCB8IFBwX2h2Ym94IHwgUHBfaG92Ym94IHwgUHBfYm94IC0+IGJyZWFrX2xpbmUgc3RhdGUgd2lkdGhcblxuXG4oKiBUbyBza2lwIGEgdG9rZW4sIGlmIHRoZSBwcmV2aW91cyBsaW5lIGhhcyBiZWVuIGJyb2tlbi4gKilcbmxldCBwcF9za2lwX3Rva2VuIHN0YXRlID1cbiAgbWF0Y2ggUXVldWUudGFrZV9vcHQgc3RhdGUucHBfcXVldWUgd2l0aFxuICB8IE5vbmUgLT4gKCkgKCogcHJpbnRfaWZfbmV3bGluZSBtdXN0IGhhdmUgYmVlbiB0aGUgbGFzdCBwcmludGluZyBjb21tYW5kICopXG4gIHwgU29tZSB7IHNpemU7IGxlbmd0aDsgXyB9IC0+XG4gICAgc3RhdGUucHBfbGVmdF90b3RhbCA8LSBzdGF0ZS5wcF9sZWZ0X3RvdGFsIC0gbGVuZ3RoO1xuICAgIHN0YXRlLnBwX3NwYWNlX2xlZnQgPC0gc3RhdGUucHBfc3BhY2VfbGVmdCArIFNpemUudG9faW50IHNpemVcblxuXG4oKlxuXG4gIFRoZSBtYWluIHByZXR0eSBwcmludGluZyBmdW5jdGlvbnMuXG5cbiopXG5cbigqIEZvcm1hdHRpbmcgYSB0b2tlbiB3aXRoIGEgZ2l2ZW4gc2l6ZS4gKilcbmxldCBmb3JtYXRfcHBfdG9rZW4gc3RhdGUgc2l6ZSA9IGZ1bmN0aW9uXG5cbiAgfCBQcF90ZXh0IHMgLT5cbiAgICBmb3JtYXRfcHBfdGV4dCBzdGF0ZSBzaXplIHNcblxuICB8IFBwX2JlZ2luIChvZmYsIHR5KSAtPlxuICAgIGxldCBpbnNlcnRpb25fcG9pbnQgPSBzdGF0ZS5wcF9tYXJnaW4gLSBzdGF0ZS5wcF9zcGFjZV9sZWZ0IGluXG4gICAgaWYgaW5zZXJ0aW9uX3BvaW50ID4gc3RhdGUucHBfbWF4X2luZGVudCB0aGVuXG4gICAgICAoKiBjYW4gbm90IG9wZW4gYSBib3ggcmlnaHQgdGhlcmUuICopXG4gICAgICBiZWdpbiBwcF9mb3JjZV9icmVha19saW5lIHN0YXRlIGVuZDtcbiAgICBsZXQgd2lkdGggPSBzdGF0ZS5wcF9zcGFjZV9sZWZ0IC0gb2ZmIGluXG4gICAgbGV0IGJveF90eXBlID1cbiAgICAgIG1hdGNoIHR5IHdpdGhcbiAgICAgIHwgUHBfdmJveCAtPiBQcF92Ym94XG4gICAgICB8IFBwX2hib3ggfCBQcF9odmJveCB8IFBwX2hvdmJveCB8IFBwX2JveCB8IFBwX2ZpdHMgLT5cbiAgICAgICAgaWYgc2l6ZSA+IHN0YXRlLnBwX3NwYWNlX2xlZnQgdGhlbiB0eSBlbHNlIFBwX2ZpdHMgaW5cbiAgICBTdGFjay5wdXNoIHsgYm94X3R5cGU7IHdpZHRoIH0gc3RhdGUucHBfZm9ybWF0X3N0YWNrXG5cbiAgfCBQcF9lbmQgLT5cbiAgICBTdGFjay5wb3Bfb3B0IHN0YXRlLnBwX2Zvcm1hdF9zdGFjayB8PiBpZ25vcmVcblxuICB8IFBwX3RiZWdpbiAoUHBfdGJveCBfIGFzIHRib3gpIC0+XG4gICAgU3RhY2sucHVzaCB0Ym94IHN0YXRlLnBwX3Rib3hfc3RhY2tcblxuICB8IFBwX3RlbmQgLT5cbiAgICBTdGFjay5wb3Bfb3B0IHN0YXRlLnBwX3Rib3hfc3RhY2sgfD4gaWdub3JlXG5cbiAgfCBQcF9zdGFiIC0+XG4gICAgYmVnaW4gbWF0Y2ggU3RhY2sudG9wX29wdCBzdGF0ZS5wcF90Ym94X3N0YWNrIHdpdGhcbiAgICB8IE5vbmUgLT4gKCkgKCogTm8gb3BlbiB0YWJ1bGF0aW9uIGJveC4gKilcbiAgICB8IFNvbWUgKFBwX3Rib3ggdGFicykgLT5cbiAgICAgIGxldCByZWMgYWRkX3RhYiBuID0gZnVuY3Rpb25cbiAgICAgICAgfCBbXSAtPiBbbl1cbiAgICAgICAgfCB4IDo6IGwgYXMgbHMgLT4gaWYgbiA8IHggdGhlbiBuIDo6IGxzIGVsc2UgeCA6OiBhZGRfdGFiIG4gbCBpblxuICAgICAgdGFicyA6PSBhZGRfdGFiIChzdGF0ZS5wcF9tYXJnaW4gLSBzdGF0ZS5wcF9zcGFjZV9sZWZ0KSAhdGFic1xuICAgIGVuZFxuXG4gIHwgUHBfdGJyZWFrIChuLCBvZmYpIC0+XG4gICAgbGV0IGluc2VydGlvbl9wb2ludCA9IHN0YXRlLnBwX21hcmdpbiAtIHN0YXRlLnBwX3NwYWNlX2xlZnQgaW5cbiAgICBiZWdpbiBtYXRjaCBTdGFjay50b3Bfb3B0IHN0YXRlLnBwX3Rib3hfc3RhY2sgd2l0aFxuICAgIHwgTm9uZSAtPiAoKSAoKiBObyBvcGVuIHRhYnVsYXRpb24gYm94LiAqKVxuICAgIHwgU29tZSAoUHBfdGJveCB0YWJzKSAtPlxuICAgICAgbGV0IHRhYiA9XG4gICAgICAgIG1hdGNoICF0YWJzIHdpdGhcbiAgICAgICAgfCBbXSAtPiBpbnNlcnRpb25fcG9pbnRcbiAgICAgICAgfCBmaXJzdCA6OiBfIC0+XG4gICAgICAgICAgbGV0IHJlYyBmaW5kID0gZnVuY3Rpb25cbiAgICAgICAgICAgIHwgaGVhZCA6OiB0YWlsIC0+XG4gICAgICAgICAgICAgIGlmIGhlYWQgPj0gaW5zZXJ0aW9uX3BvaW50IHRoZW4gaGVhZCBlbHNlIGZpbmQgdGFpbFxuICAgICAgICAgICAgfCBbXSAtPiBmaXJzdCBpblxuICAgICAgICAgIGZpbmQgIXRhYnMgaW5cbiAgICAgIGxldCBvZmZzZXQgPSB0YWIgLSBpbnNlcnRpb25fcG9pbnQgaW5cbiAgICAgIGlmIG9mZnNldCA+PSAwXG4gICAgICB0aGVuIGJyZWFrX3NhbWVfbGluZSBzdGF0ZSAoXCJcIiwgb2Zmc2V0ICsgbiwgXCJcIilcbiAgICAgIGVsc2UgYnJlYWtfbmV3X2xpbmUgc3RhdGUgKFwiXCIsIHRhYiArIG9mZiwgXCJcIikgc3RhdGUucHBfbWFyZ2luXG4gICAgZW5kXG5cbiAgfCBQcF9uZXdsaW5lIC0+XG4gICAgYmVnaW4gbWF0Y2ggU3RhY2sudG9wX29wdCBzdGF0ZS5wcF9mb3JtYXRfc3RhY2sgd2l0aFxuICAgIHwgTm9uZSAtPiBwcF9vdXRwdXRfbmV3bGluZSBzdGF0ZSAoKiBObyBvcGVuIGJveC4gKilcbiAgICB8IFNvbWUgeyB3aWR0aDsgX30gLT4gYnJlYWtfbGluZSBzdGF0ZSB3aWR0aFxuICAgIGVuZFxuXG4gIHwgUHBfaWZfbmV3bGluZSAtPlxuICAgIGlmIHN0YXRlLnBwX2N1cnJlbnRfaW5kZW50ICE9IHN0YXRlLnBwX21hcmdpbiAtIHN0YXRlLnBwX3NwYWNlX2xlZnRcbiAgICB0aGVuIHBwX3NraXBfdG9rZW4gc3RhdGVcblxuICB8IFBwX2JyZWFrIHsgZml0czsgYnJlYWtzIH0gLT5cbiAgICBsZXQgYmVmb3JlLCBvZmYsIF8gPSBicmVha3MgaW5cbiAgICBiZWdpbiBtYXRjaCBTdGFjay50b3Bfb3B0IHN0YXRlLnBwX2Zvcm1hdF9zdGFjayB3aXRoXG4gICAgfCBOb25lIC0+ICgpICgqIE5vIG9wZW4gYm94LiAqKVxuICAgIHwgU29tZSB7IGJveF90eXBlOyB3aWR0aCB9IC0+XG4gICAgICBiZWdpbiBtYXRjaCBib3hfdHlwZSB3aXRoXG4gICAgICB8IFBwX2hvdmJveCAtPlxuICAgICAgICBpZiBzaXplICsgU3RyaW5nLmxlbmd0aCBiZWZvcmUgPiBzdGF0ZS5wcF9zcGFjZV9sZWZ0XG4gICAgICAgIHRoZW4gYnJlYWtfbmV3X2xpbmUgc3RhdGUgYnJlYWtzIHdpZHRoXG4gICAgICAgIGVsc2UgYnJlYWtfc2FtZV9saW5lIHN0YXRlIGZpdHNcbiAgICAgIHwgUHBfYm94IC0+XG4gICAgICAgICgqIEhhdmUgdGhlIGxpbmUganVzdCBiZWVuIGJyb2tlbiBoZXJlID8gKilcbiAgICAgICAgaWYgc3RhdGUucHBfaXNfbmV3X2xpbmUgdGhlbiBicmVha19zYW1lX2xpbmUgc3RhdGUgZml0cyBlbHNlXG4gICAgICAgIGlmIHNpemUgKyBTdHJpbmcubGVuZ3RoIGJlZm9yZSA+IHN0YXRlLnBwX3NwYWNlX2xlZnRcbiAgICAgICAgICB0aGVuIGJyZWFrX25ld19saW5lIHN0YXRlIGJyZWFrcyB3aWR0aCBlbHNlXG4gICAgICAgICgqIGJyZWFrIHRoZSBsaW5lIGhlcmUgbGVhZHMgdG8gbmV3IGluZGVudGF0aW9uID8gKilcbiAgICAgICAgaWYgc3RhdGUucHBfY3VycmVudF9pbmRlbnQgPiBzdGF0ZS5wcF9tYXJnaW4gLSB3aWR0aCArIG9mZlxuICAgICAgICB0aGVuIGJyZWFrX25ld19saW5lIHN0YXRlIGJyZWFrcyB3aWR0aFxuICAgICAgICBlbHNlIGJyZWFrX3NhbWVfbGluZSBzdGF0ZSBmaXRzXG4gICAgICB8IFBwX2h2Ym94IC0+IGJyZWFrX25ld19saW5lIHN0YXRlIGJyZWFrcyB3aWR0aFxuICAgICAgfCBQcF9maXRzIC0+IGJyZWFrX3NhbWVfbGluZSBzdGF0ZSBmaXRzXG4gICAgICB8IFBwX3Zib3ggLT4gYnJlYWtfbmV3X2xpbmUgc3RhdGUgYnJlYWtzIHdpZHRoXG4gICAgICB8IFBwX2hib3ggLT4gYnJlYWtfc2FtZV9saW5lIHN0YXRlIGZpdHNcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICB8IFBwX29wZW5fdGFnIHRhZ19uYW1lIC0+XG4gICAgIGxldCBtYXJrZXIgPSBzdGF0ZS5wcF9tYXJrX29wZW5fdGFnIHRhZ19uYW1lIGluXG4gICAgIHBwX291dHB1dF9zdHJpbmcgc3RhdGUgbWFya2VyO1xuICAgICBTdGFjay5wdXNoIHRhZ19uYW1lIHN0YXRlLnBwX21hcmtfc3RhY2tcblxuICAgfCBQcF9jbG9zZV90YWcgLT5cbiAgICAgYmVnaW4gbWF0Y2ggU3RhY2sucG9wX29wdCBzdGF0ZS5wcF9tYXJrX3N0YWNrIHdpdGhcbiAgICAgfCBOb25lIC0+ICgpICgqIE5vIG1vcmUgdGFnIHRvIGNsb3NlLiAqKVxuICAgICB8IFNvbWUgdGFnX25hbWUgLT5cbiAgICAgICBsZXQgbWFya2VyID0gc3RhdGUucHBfbWFya19jbG9zZV90YWcgdGFnX25hbWUgaW5cbiAgICAgICBwcF9vdXRwdXRfc3RyaW5nIHN0YXRlIG1hcmtlclxuICAgICBlbmRcblxuXG4oKiBQcmludCBpZiB0b2tlbiBzaXplIGlzIGtub3duIGVsc2UgcHJpbnRpbmcgaXMgZGVsYXllZC5cbiAgIFByaW50aW5nIGlzIGRlbGF5ZWQgd2hlbiB0aGUgdGV4dCB3YWl0aW5nIGluIHRoZSBxdWV1ZSByZXF1aXJlc1xuICAgbW9yZSByb29tIHRvIGZvcm1hdCB0aGFuIGV4aXN0cyBvbiB0aGUgY3VycmVudCBsaW5lLiAqKVxubGV0IHJlYyBhZHZhbmNlX2xlZnQgc3RhdGUgPVxuICBtYXRjaCBRdWV1ZS5wZWVrX29wdCBzdGF0ZS5wcF9xdWV1ZSB3aXRoXG4gIHwgTm9uZSAtPiAoKSAoKiBObyB0b2tlbnMgdG8gcHJpbnQgKilcbiAgfCBTb21lIHsgc2l6ZTsgdG9rZW47IGxlbmd0aCB9IC0+XG4gICAgbGV0IHBlbmRpbmdfY291bnQgPSBzdGF0ZS5wcF9yaWdodF90b3RhbCAtIHN0YXRlLnBwX2xlZnRfdG90YWwgaW5cbiAgICBpZiBTaXplLmlzX2tub3duIHNpemUgfHwgcGVuZGluZ19jb3VudCA+PSBzdGF0ZS5wcF9zcGFjZV9sZWZ0IHRoZW4gYmVnaW5cbiAgICAgIFF1ZXVlLnRha2Ugc3RhdGUucHBfcXVldWUgfD4gaWdub3JlOyAoKiBOb3QgZW1wdHk6IHdlIHBlZWsgaW50byBpdCAqKVxuICAgICAgbGV0IHNpemUgPSBpZiBTaXplLmlzX2tub3duIHNpemUgdGhlbiBTaXplLnRvX2ludCBzaXplIGVsc2UgcHBfaW5maW5pdHkgaW5cbiAgICAgIGZvcm1hdF9wcF90b2tlbiBzdGF0ZSBzaXplIHRva2VuO1xuICAgICAgc3RhdGUucHBfbGVmdF90b3RhbCA8LSBsZW5ndGggKyBzdGF0ZS5wcF9sZWZ0X3RvdGFsO1xuICAgICAgKGFkdmFuY2VfbGVmdCBbQHRhaWxjYWxsXSkgc3RhdGVcbiAgICBlbmRcblxuXG4oKiBUbyBlbnF1ZXVlIGEgdG9rZW4gOiB0cnkgdG8gYWR2YW5jZS4gKilcbmxldCBlbnF1ZXVlX2FkdmFuY2Ugc3RhdGUgdG9rID0gcHBfZW5xdWV1ZSBzdGF0ZSB0b2s7IGFkdmFuY2VfbGVmdCBzdGF0ZVxuXG5cbigqIFRvIGVucXVldWUgc3RyaW5ncy4gKilcbmxldCBlbnF1ZXVlX3N0cmluZ19hcyBzdGF0ZSBzaXplIHMgPVxuICBlbnF1ZXVlX2FkdmFuY2Ugc3RhdGUgeyBzaXplOyB0b2tlbiA9IFBwX3RleHQgczsgbGVuZ3RoID0gU2l6ZS50b19pbnQgc2l6ZSB9XG5cblxubGV0IGVucXVldWVfc3RyaW5nIHN0YXRlIHMgPVxuICBlbnF1ZXVlX3N0cmluZ19hcyBzdGF0ZSAoU2l6ZS5vZl9pbnQgKFN0cmluZy5sZW5ndGggcykpIHNcblxuXG4oKiBSb3V0aW5lcyBmb3Igc2NhbiBzdGFja1xuICAgZGV0ZXJtaW5lIHNpemUgb2YgYm94ZXMuICopXG5cbigqIFRoZSBzY2FuX3N0YWNrIGlzIG5ldmVyIGVtcHR5LiAqKVxubGV0IGluaXRpYWxpemVfc2Nhbl9zdGFjayBzdGFjayA9XG4gIFN0YWNrLmNsZWFyIHN0YWNrO1xuICBsZXQgcXVldWVfZWxlbSA9IHsgc2l6ZSA9IFNpemUudW5rbm93bjsgdG9rZW4gPSBQcF90ZXh0IFwiXCI7IGxlbmd0aCA9IDAgfSBpblxuICBTdGFjay5wdXNoIHsgbGVmdF90b3RhbCA9IC0xOyBxdWV1ZV9lbGVtIH0gc3RhY2tcblxuKCogU2V0dGluZyB0aGUgc2l6ZSBvZiBib3hlcyBvbiBzY2FuIHN0YWNrOlxuICAgaWYgdHkgPSB0cnVlIHRoZW4gc2l6ZSBvZiBicmVhayBpcyBzZXQgZWxzZSBzaXplIG9mIGJveCBpcyBzZXQ7XG4gICBpbiBlYWNoIGNhc2UgcHBfc2Nhbl9zdGFjayBpcyBwb3BwZWQuXG5cbiAgIE5vdGU6XG4gICBQYXR0ZXJuIG1hdGNoaW5nIG9uIHNjYW4gc3RhY2sgaXMgZXhoYXVzdGl2ZSwgc2luY2Ugc2Nhbl9zdGFjayBpcyBuZXZlclxuICAgZW1wdHkuXG4gICBQYXR0ZXJuIG1hdGNoaW5nIG9uIHRva2VuIGluIHNjYW4gc3RhY2sgaXMgYWxzbyBleGhhdXN0aXZlLFxuICAgc2luY2Ugc2Nhbl9wdXNoIGlzIHVzZWQgb24gYnJlYWtzIGFuZCBvcGVuaW5nIG9mIGJveGVzLiAqKVxubGV0IHNldF9zaXplIHN0YXRlIHR5ID1cbiAgbWF0Y2ggU3RhY2sudG9wX29wdCBzdGF0ZS5wcF9zY2FuX3N0YWNrIHdpdGhcbiAgfCBOb25lIC0+ICgpICgqIHNjYW5fc3RhY2sgaXMgbmV2ZXIgZW1wdHkuICopXG4gIHwgU29tZSB7IGxlZnRfdG90YWw7IHF1ZXVlX2VsZW0gfSAtPlxuICAgIGxldCBzaXplID0gU2l6ZS50b19pbnQgcXVldWVfZWxlbS5zaXplIGluXG4gICAgKCogdGVzdCBpZiBzY2FuIHN0YWNrIGNvbnRhaW5zIGFueSBkYXRhIHRoYXQgaXMgbm90IG9ic29sZXRlLiAqKVxuICAgIGlmIGxlZnRfdG90YWwgPCBzdGF0ZS5wcF9sZWZ0X3RvdGFsIHRoZW5cbiAgICAgIGluaXRpYWxpemVfc2Nhbl9zdGFjayBzdGF0ZS5wcF9zY2FuX3N0YWNrXG4gICAgZWxzZVxuICAgICAgbWF0Y2ggcXVldWVfZWxlbS50b2tlbiB3aXRoXG4gICAgICB8IFBwX2JyZWFrIF8gfCBQcF90YnJlYWsgKF8sIF8pIC0+XG4gICAgICAgIGlmIHR5IHRoZW4gYmVnaW5cbiAgICAgICAgICBxdWV1ZV9lbGVtLnNpemUgPC0gU2l6ZS5vZl9pbnQgKHN0YXRlLnBwX3JpZ2h0X3RvdGFsICsgc2l6ZSk7XG4gICAgICAgICAgU3RhY2sucG9wX29wdCBzdGF0ZS5wcF9zY2FuX3N0YWNrIHw+IGlnbm9yZVxuICAgICAgICBlbmRcbiAgICAgIHwgUHBfYmVnaW4gKF8sIF8pIC0+XG4gICAgICAgIGlmIG5vdCB0eSB0aGVuIGJlZ2luXG4gICAgICAgICAgcXVldWVfZWxlbS5zaXplIDwtIFNpemUub2ZfaW50IChzdGF0ZS5wcF9yaWdodF90b3RhbCArIHNpemUpO1xuICAgICAgICAgIFN0YWNrLnBvcF9vcHQgc3RhdGUucHBfc2Nhbl9zdGFjayB8PiBpZ25vcmVcbiAgICAgICAgZW5kXG4gICAgICB8IFBwX3RleHQgXyB8IFBwX3N0YWIgfCBQcF90YmVnaW4gXyB8IFBwX3RlbmQgfCBQcF9lbmRcbiAgICAgIHwgUHBfbmV3bGluZSB8IFBwX2lmX25ld2xpbmUgfCBQcF9vcGVuX3RhZyBfIHwgUHBfY2xvc2VfdGFnIC0+XG4gICAgICAgICgpICgqIHNjYW5fcHVzaCBpcyBvbmx5IHVzZWQgZm9yIGJyZWFrcyBhbmQgYm94ZXMuICopXG5cblxuKCogUHVzaCBhIHRva2VuIG9uIHByZXR0eS1wcmludGVyIHNjYW5uaW5nIHN0YWNrLlxuICAgSWYgYiBpcyB0cnVlIHNldF9zaXplIGlzIGNhbGxlZC4gKilcbmxldCBzY2FuX3B1c2ggc3RhdGUgYiB0b2tlbiA9XG4gIHBwX2VucXVldWUgc3RhdGUgdG9rZW47XG4gIGlmIGIgdGhlbiBzZXRfc2l6ZSBzdGF0ZSB0cnVlO1xuICBsZXQgZWxlbSA9IHsgbGVmdF90b3RhbCA9IHN0YXRlLnBwX3JpZ2h0X3RvdGFsOyBxdWV1ZV9lbGVtID0gdG9rZW4gfSBpblxuICBTdGFjay5wdXNoIGVsZW0gc3RhdGUucHBfc2Nhbl9zdGFja1xuXG5cbigqIFRvIG9wZW4gYSBuZXcgYm94IDpcbiAgIHRoZSB1c2VyIG1heSBzZXQgdGhlIGRlcHRoIGJvdW5kIHBwX21heF9ib3hlc1xuICAgYW55IHRleHQgbmVzdGVkIGRlZXBlciBpcyBwcmludGVkIGFzIHRoZSBlbGxpcHNpcyBzdHJpbmcuICopXG5sZXQgcHBfb3Blbl9ib3hfZ2VuIHN0YXRlIGluZGVudCBicl90eSA9XG4gIHN0YXRlLnBwX2N1cnJfZGVwdGggPC0gc3RhdGUucHBfY3Vycl9kZXB0aCArIDE7XG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXMgdGhlblxuICAgIGxldCBzaXplID0gU2l6ZS5vZl9pbnQgKC0gc3RhdGUucHBfcmlnaHRfdG90YWwpIGluXG4gICAgbGV0IGVsZW0gPSB7IHNpemU7IHRva2VuID0gUHBfYmVnaW4gKGluZGVudCwgYnJfdHkpOyBsZW5ndGggPSAwIH0gaW5cbiAgICBzY2FuX3B1c2ggc3RhdGUgZmFsc2UgZWxlbSBlbHNlXG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPSBzdGF0ZS5wcF9tYXhfYm94ZXNcbiAgdGhlbiBlbnF1ZXVlX3N0cmluZyBzdGF0ZSBzdGF0ZS5wcF9lbGxpcHNpc1xuXG5cbigqIFRoZSBib3ggd2hpY2ggaXMgYWx3YXlzIG9wZW4uICopXG5sZXQgcHBfb3Blbl9zeXNfYm94IHN0YXRlID0gcHBfb3Blbl9ib3hfZ2VuIHN0YXRlIDAgUHBfaG92Ym94XG5cbigqIENsb3NlIGEgYm94LCBzZXR0aW5nIHNpemVzIG9mIGl0cyBzdWIgYm94ZXMuICopXG5sZXQgcHBfY2xvc2VfYm94IHN0YXRlICgpID1cbiAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA+IDEgdGhlblxuICBiZWdpblxuICAgIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXMgdGhlblxuICAgIGJlZ2luXG4gICAgICBwcF9lbnF1ZXVlIHN0YXRlIHsgc2l6ZSA9IFNpemUuemVybzsgdG9rZW4gPSBQcF9lbmQ7IGxlbmd0aCA9IDAgfTtcbiAgICAgIHNldF9zaXplIHN0YXRlIHRydWU7IHNldF9zaXplIHN0YXRlIGZhbHNlXG4gICAgZW5kO1xuICAgIHN0YXRlLnBwX2N1cnJfZGVwdGggPC0gc3RhdGUucHBfY3Vycl9kZXB0aCAtIDE7XG4gIGVuZFxuXG5cbigqIE9wZW4gYSB0YWcsIHB1c2hpbmcgaXQgb24gdGhlIHRhZyBzdGFjay4gKilcbmxldCBwcF9vcGVuX3N0YWcgc3RhdGUgdGFnX25hbWUgPVxuICBpZiBzdGF0ZS5wcF9wcmludF90YWdzIHRoZW5cbiAgYmVnaW5cbiAgICBTdGFjay5wdXNoIHRhZ19uYW1lIHN0YXRlLnBwX3RhZ19zdGFjaztcbiAgICBzdGF0ZS5wcF9wcmludF9vcGVuX3RhZyB0YWdfbmFtZVxuICBlbmQ7XG4gIGlmIHN0YXRlLnBwX21hcmtfdGFncyB0aGVuXG4gICAgbGV0IHRva2VuID0gUHBfb3Blbl90YWcgdGFnX25hbWUgaW5cbiAgICBwcF9lbnF1ZXVlIHN0YXRlIHsgc2l6ZSA9IFNpemUuemVybzsgdG9rZW47IGxlbmd0aCA9IDAgfVxuXG5cbigqIENsb3NlIGEgdGFnLCBwb3BwaW5nIGl0IGZyb20gdGhlIHRhZyBzdGFjay4gKilcbmxldCBwcF9jbG9zZV9zdGFnIHN0YXRlICgpID1cbiAgaWYgc3RhdGUucHBfbWFya190YWdzIHRoZW5cbiAgICBwcF9lbnF1ZXVlIHN0YXRlIHsgc2l6ZSA9IFNpemUuemVybzsgdG9rZW4gPSBQcF9jbG9zZV90YWc7IGxlbmd0aCA9IDAgfTtcbiAgaWYgc3RhdGUucHBfcHJpbnRfdGFncyB0aGVuXG4gICAgbWF0Y2ggU3RhY2sucG9wX29wdCBzdGF0ZS5wcF90YWdfc3RhY2sgd2l0aFxuICAgIHwgTm9uZSAtPiAoKSAoKiBObyBtb3JlIHRhZyB0byBjbG9zZS4gKilcbiAgICB8IFNvbWUgdGFnX25hbWUgLT5cbiAgICAgIHN0YXRlLnBwX3ByaW50X2Nsb3NlX3RhZyB0YWdfbmFtZVxuXG5sZXQgcHBfb3Blbl90YWcgc3RhdGUgcyA9IHBwX29wZW5fc3RhZyBzdGF0ZSAoU3RyaW5nX3RhZyBzKVxubGV0IHBwX2Nsb3NlX3RhZyBzdGF0ZSAoKSA9IHBwX2Nsb3NlX3N0YWcgc3RhdGUgKClcblxubGV0IHBwX3NldF9wcmludF90YWdzIHN0YXRlIGIgPSBzdGF0ZS5wcF9wcmludF90YWdzIDwtIGJcbmxldCBwcF9zZXRfbWFya190YWdzIHN0YXRlIGIgPSBzdGF0ZS5wcF9tYXJrX3RhZ3MgPC0gYlxubGV0IHBwX2dldF9wcmludF90YWdzIHN0YXRlICgpID0gc3RhdGUucHBfcHJpbnRfdGFnc1xubGV0IHBwX2dldF9tYXJrX3RhZ3Mgc3RhdGUgKCkgPSBzdGF0ZS5wcF9tYXJrX3RhZ3NcbmxldCBwcF9zZXRfdGFncyBzdGF0ZSBiID1cbiAgcHBfc2V0X3ByaW50X3RhZ3Mgc3RhdGUgYjsgcHBfc2V0X21hcmtfdGFncyBzdGF0ZSBiXG5cblxuKCogSGFuZGxpbmcgdGFnIGhhbmRsaW5nIGZ1bmN0aW9uczogZ2V0L3NldCBmdW5jdGlvbnMuICopXG5sZXQgcHBfZ2V0X2Zvcm1hdHRlcl9zdGFnX2Z1bmN0aW9ucyBzdGF0ZSAoKSA9IHtcbiAgbWFya19vcGVuX3N0YWcgPSBzdGF0ZS5wcF9tYXJrX29wZW5fdGFnO1xuICBtYXJrX2Nsb3NlX3N0YWcgPSBzdGF0ZS5wcF9tYXJrX2Nsb3NlX3RhZztcbiAgcHJpbnRfb3Blbl9zdGFnID0gc3RhdGUucHBfcHJpbnRfb3Blbl90YWc7XG4gIHByaW50X2Nsb3NlX3N0YWcgPSBzdGF0ZS5wcF9wcmludF9jbG9zZV90YWc7XG59XG5cblxubGV0IHBwX3NldF9mb3JtYXR0ZXJfc3RhZ19mdW5jdGlvbnMgc3RhdGUge1xuICAgICBtYXJrX29wZW5fc3RhZyA9IG1vdDtcbiAgICAgbWFya19jbG9zZV9zdGFnID0gbWN0O1xuICAgICBwcmludF9vcGVuX3N0YWcgPSBwb3Q7XG4gICAgIHByaW50X2Nsb3NlX3N0YWcgPSBwY3Q7XG4gIH0gPVxuICBzdGF0ZS5wcF9tYXJrX29wZW5fdGFnIDwtIG1vdDtcbiAgc3RhdGUucHBfbWFya19jbG9zZV90YWcgPC0gbWN0O1xuICBzdGF0ZS5wcF9wcmludF9vcGVuX3RhZyA8LSBwb3Q7XG4gIHN0YXRlLnBwX3ByaW50X2Nsb3NlX3RhZyA8LSBwY3RcblxuXG4oKiBJbml0aWFsaXplIHByZXR0eS1wcmludGVyLiAqKVxubGV0IHBwX3Jpbml0IHN0YXRlID1cbiAgcHBfY2xlYXJfcXVldWUgc3RhdGU7XG4gIGluaXRpYWxpemVfc2Nhbl9zdGFjayBzdGF0ZS5wcF9zY2FuX3N0YWNrO1xuICBTdGFjay5jbGVhciBzdGF0ZS5wcF9mb3JtYXRfc3RhY2s7XG4gIFN0YWNrLmNsZWFyIHN0YXRlLnBwX3Rib3hfc3RhY2s7XG4gIFN0YWNrLmNsZWFyIHN0YXRlLnBwX3RhZ19zdGFjaztcbiAgU3RhY2suY2xlYXIgc3RhdGUucHBfbWFya19zdGFjaztcbiAgc3RhdGUucHBfY3VycmVudF9pbmRlbnQgPC0gMDtcbiAgc3RhdGUucHBfY3Vycl9kZXB0aCA8LSAwO1xuICBzdGF0ZS5wcF9zcGFjZV9sZWZ0IDwtIHN0YXRlLnBwX21hcmdpbjtcbiAgcHBfb3Blbl9zeXNfYm94IHN0YXRlXG5cbmxldCBjbGVhcl90YWdfc3RhY2sgc3RhdGUgPVxuICBTdGFjay5pdGVyIChmdW4gXyAtPiBwcF9jbG9zZV90YWcgc3RhdGUgKCkpIHN0YXRlLnBwX3RhZ19zdGFja1xuXG5cbigqIEZsdXNoaW5nIHByZXR0eS1wcmludGVyIHF1ZXVlLiAqKVxubGV0IHBwX2ZsdXNoX3F1ZXVlIHN0YXRlIGIgPVxuICBjbGVhcl90YWdfc3RhY2sgc3RhdGU7XG4gIHdoaWxlIHN0YXRlLnBwX2N1cnJfZGVwdGggPiAxIGRvXG4gICAgcHBfY2xvc2VfYm94IHN0YXRlICgpXG4gIGRvbmU7XG4gIHN0YXRlLnBwX3JpZ2h0X3RvdGFsIDwtIHBwX2luZmluaXR5O1xuICBhZHZhbmNlX2xlZnQgc3RhdGU7XG4gIGlmIGIgdGhlbiBwcF9vdXRwdXRfbmV3bGluZSBzdGF0ZTtcbiAgcHBfcmluaXQgc3RhdGVcblxuKCpcblxuICBQcm9jZWR1cmVzIHRvIGZvcm1hdCB2YWx1ZXMgYW5kIHVzZSBib3hlcy5cblxuKilcblxuKCogVG8gZm9ybWF0IGEgc3RyaW5nLiAqKVxubGV0IHBwX3ByaW50X2FzX3NpemUgc3RhdGUgc2l6ZSBzID1cbiAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA8IHN0YXRlLnBwX21heF9ib3hlc1xuICB0aGVuIGVucXVldWVfc3RyaW5nX2FzIHN0YXRlIHNpemUgc1xuXG5cbmxldCBwcF9wcmludF9hcyBzdGF0ZSBpc2l6ZSBzID1cbiAgcHBfcHJpbnRfYXNfc2l6ZSBzdGF0ZSAoU2l6ZS5vZl9pbnQgaXNpemUpIHNcblxuXG5sZXQgcHBfcHJpbnRfc3RyaW5nIHN0YXRlIHMgPVxuICBwcF9wcmludF9hcyBzdGF0ZSAoU3RyaW5nLmxlbmd0aCBzKSBzXG5cblxuKCogVG8gZm9ybWF0IGFuIGludGVnZXIuICopXG5sZXQgcHBfcHJpbnRfaW50IHN0YXRlIGkgPSBwcF9wcmludF9zdHJpbmcgc3RhdGUgKEludC50b19zdHJpbmcgaSlcblxuKCogVG8gZm9ybWF0IGEgZmxvYXQuICopXG5sZXQgcHBfcHJpbnRfZmxvYXQgc3RhdGUgZiA9IHBwX3ByaW50X3N0cmluZyBzdGF0ZSAoc3RyaW5nX29mX2Zsb2F0IGYpXG5cbigqIFRvIGZvcm1hdCBhIGJvb2xlYW4uICopXG5sZXQgcHBfcHJpbnRfYm9vbCBzdGF0ZSBiID0gcHBfcHJpbnRfc3RyaW5nIHN0YXRlIChzdHJpbmdfb2ZfYm9vbCBiKVxuXG4oKiBUbyBmb3JtYXQgYSBjaGFyLiAqKVxubGV0IHBwX3ByaW50X2NoYXIgc3RhdGUgYyA9XG4gIHBwX3ByaW50X2FzIHN0YXRlIDEgKFN0cmluZy5tYWtlIDEgYylcblxuXG4oKiBPcGVuaW5nIGJveGVzLiAqKVxubGV0IHBwX29wZW5faGJveCBzdGF0ZSAoKSA9IHBwX29wZW5fYm94X2dlbiBzdGF0ZSAwIFBwX2hib3hcbmFuZCBwcF9vcGVuX3Zib3ggc3RhdGUgaW5kZW50ID0gcHBfb3Blbl9ib3hfZ2VuIHN0YXRlIGluZGVudCBQcF92Ym94XG5cbmFuZCBwcF9vcGVuX2h2Ym94IHN0YXRlIGluZGVudCA9IHBwX29wZW5fYm94X2dlbiBzdGF0ZSBpbmRlbnQgUHBfaHZib3hcbmFuZCBwcF9vcGVuX2hvdmJveCBzdGF0ZSBpbmRlbnQgPSBwcF9vcGVuX2JveF9nZW4gc3RhdGUgaW5kZW50IFBwX2hvdmJveFxuYW5kIHBwX29wZW5fYm94IHN0YXRlIGluZGVudCA9IHBwX29wZW5fYm94X2dlbiBzdGF0ZSBpbmRlbnQgUHBfYm94XG5cblxuKCogUHJpbnRpbmcgcXVldWVkIHRleHQuXG5cbiAgIFtwcF9wcmludF9mbHVzaF0gcHJpbnRzIGFsbCBwZW5kaW5nIGl0ZW1zIGluIHRoZSBwcmV0dHktcHJpbnRlciBxdWV1ZSBhbmRcbiAgIHRoZW4gZmx1c2hlcyB0aGUgbG93IGxldmVsIG91dHB1dCBkZXZpY2Ugb2YgdGhlIGZvcm1hdHRlciB0byBhY3R1YWxseVxuICAgZGlzcGxheSBwcmludGluZyBtYXRlcmlhbC5cblxuICAgW3BwX3ByaW50X25ld2xpbmVdIGJlaGF2ZXMgYXMgW3BwX3ByaW50X2ZsdXNoXSBhZnRlciBwcmludGluZyBhbiBhZGRpdGlvbmFsXG4gICBuZXcgbGluZS4gKilcbmxldCBwcF9wcmludF9uZXdsaW5lIHN0YXRlICgpID1cbiAgcHBfZmx1c2hfcXVldWUgc3RhdGUgdHJ1ZTsgc3RhdGUucHBfb3V0X2ZsdXNoICgpXG5hbmQgcHBfcHJpbnRfZmx1c2ggc3RhdGUgKCkgPVxuICBwcF9mbHVzaF9xdWV1ZSBzdGF0ZSBmYWxzZTsgc3RhdGUucHBfb3V0X2ZsdXNoICgpXG5cblxuKCogVG8gZ2V0IGEgbmV3bGluZSB3aGVuIG9uZSBkb2VzIG5vdCB3YW50IHRvIGNsb3NlIHRoZSBjdXJyZW50IGJveC4gKilcbmxldCBwcF9mb3JjZV9uZXdsaW5lIHN0YXRlICgpID1cbiAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA8IHN0YXRlLnBwX21heF9ib3hlcyB0aGVuXG4gICAgZW5xdWV1ZV9hZHZhbmNlIHN0YXRlIHsgc2l6ZSA9IFNpemUuemVybzsgdG9rZW4gPSBQcF9uZXdsaW5lOyBsZW5ndGggPSAwIH1cblxuXG4oKiBUbyBmb3JtYXQgc29tZXRoaW5nLCBvbmx5IGluIGNhc2UgdGhlIGxpbmUgaGFzIGp1c3QgYmVlbiBicm9rZW4uICopXG5sZXQgcHBfcHJpbnRfaWZfbmV3bGluZSBzdGF0ZSAoKSA9XG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXMgdGhlblxuICAgIGVucXVldWVfYWR2YW5jZSBzdGF0ZVxuICAgICAgeyBzaXplID0gU2l6ZS56ZXJvOyB0b2tlbiA9IFBwX2lmX25ld2xpbmU7IGxlbmd0aCA9IDAgfVxuXG5cbigqIEdlbmVyYWxpemVkIGJyZWFrIGhpbnQgdGhhdCBhbGxvd3MgcHJpbnRpbmcgc3RyaW5ncyBiZWZvcmUvYWZ0ZXJcbiAgIHNhbWUtbGluZSBvZmZzZXQgKHdpZHRoKSBvciBuZXctbGluZSBvZmZzZXQgKilcbmxldCBwcF9wcmludF9jdXN0b21fYnJlYWsgc3RhdGUgfmZpdHMgfmJyZWFrcyA9XG4gIGxldCBiZWZvcmUsIHdpZHRoLCBhZnRlciA9IGZpdHMgaW5cbiAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA8IHN0YXRlLnBwX21heF9ib3hlcyB0aGVuXG4gICAgbGV0IHNpemUgPSBTaXplLm9mX2ludCAoLSBzdGF0ZS5wcF9yaWdodF90b3RhbCkgaW5cbiAgICBsZXQgdG9rZW4gPSBQcF9icmVhayB7IGZpdHM7IGJyZWFrcyB9IGluXG4gICAgbGV0IGxlbmd0aCA9IFN0cmluZy5sZW5ndGggYmVmb3JlICsgd2lkdGggKyBTdHJpbmcubGVuZ3RoIGFmdGVyIGluXG4gICAgbGV0IGVsZW0gPSB7IHNpemU7IHRva2VuOyBsZW5ndGggfSBpblxuICAgIHNjYW5fcHVzaCBzdGF0ZSB0cnVlIGVsZW1cblxuKCogUHJpbnRpbmcgYnJlYWsgaGludHM6XG4gICBBIGJyZWFrIGhpbnQgaW5kaWNhdGVzIHdoZXJlIGEgYm94IG1heSBiZSBicm9rZW4uXG4gICBJZiBsaW5lIGlzIGJyb2tlbiB0aGVuIG9mZnNldCBpcyBhZGRlZCB0byB0aGUgaW5kZW50YXRpb24gb2YgdGhlIGN1cnJlbnRcbiAgIGJveCBlbHNlICh0aGUgdmFsdWUgb2YpIHdpZHRoIGJsYW5rcyBhcmUgcHJpbnRlZC4gKilcbmxldCBwcF9wcmludF9icmVhayBzdGF0ZSB3aWR0aCBvZmZzZXQgPVxuICBwcF9wcmludF9jdXN0b21fYnJlYWsgc3RhdGVcbiAgICB+Zml0czooXCJcIiwgd2lkdGgsIFwiXCIpIH5icmVha3M6KFwiXCIsIG9mZnNldCwgXCJcIilcblxuXG4oKiBQcmludCBhIHNwYWNlIDpcbiAgIGEgc3BhY2UgaXMgYSBicmVhayBoaW50IHRoYXQgcHJpbnRzIGEgc2luZ2xlIHNwYWNlIGlmIHRoZSBicmVhayBkb2VzIG5vdFxuICAgc3BsaXQgdGhlIGxpbmU7XG4gICBhIGN1dCBpcyBhIGJyZWFrIGhpbnQgdGhhdCBwcmludHMgbm90aGluZyBpZiB0aGUgYnJlYWsgZG9lcyBub3Qgc3BsaXQgdGhlXG4gICBsaW5lLiAqKVxubGV0IHBwX3ByaW50X3NwYWNlIHN0YXRlICgpID0gcHBfcHJpbnRfYnJlYWsgc3RhdGUgMSAwXG5hbmQgcHBfcHJpbnRfY3V0IHN0YXRlICgpID0gcHBfcHJpbnRfYnJlYWsgc3RhdGUgMCAwXG5cblxuKCogVGFidWxhdGlvbiBib3hlcy4gKilcbmxldCBwcF9vcGVuX3Rib3ggc3RhdGUgKCkgPVxuICBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwtIHN0YXRlLnBwX2N1cnJfZGVwdGggKyAxO1xuICBpZiBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwgc3RhdGUucHBfbWF4X2JveGVzIHRoZW5cbiAgICBsZXQgc2l6ZSA9IFNpemUuemVybyBpblxuICAgIGxldCBlbGVtID0geyBzaXplOyB0b2tlbiA9IFBwX3RiZWdpbiAoUHBfdGJveCAocmVmIFtdKSk7IGxlbmd0aCA9IDAgfSBpblxuICAgIGVucXVldWVfYWR2YW5jZSBzdGF0ZSBlbGVtXG5cblxuKCogQ2xvc2UgYSB0YWJ1bGF0aW9uIGJveC4gKilcbmxldCBwcF9jbG9zZV90Ym94IHN0YXRlICgpID1cbiAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA+IDEgdGhlblxuICBiZWdpblxuICAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA8IHN0YXRlLnBwX21heF9ib3hlcyB0aGVuXG4gICAgIGxldCBlbGVtID0geyBzaXplID0gU2l6ZS56ZXJvOyB0b2tlbiA9IFBwX3RlbmQ7IGxlbmd0aCA9IDAgfSBpblxuICAgICBlbnF1ZXVlX2FkdmFuY2Ugc3RhdGUgZWxlbTtcbiAgICAgc3RhdGUucHBfY3Vycl9kZXB0aCA8LSBzdGF0ZS5wcF9jdXJyX2RlcHRoIC0gMVxuICBlbmRcblxuXG4oKiBQcmludCBhIHRhYnVsYXRpb24gYnJlYWsuICopXG5sZXQgcHBfcHJpbnRfdGJyZWFrIHN0YXRlIHdpZHRoIG9mZnNldCA9XG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXMgdGhlblxuICAgIGxldCBzaXplID0gU2l6ZS5vZl9pbnQgKC0gc3RhdGUucHBfcmlnaHRfdG90YWwpIGluXG4gICAgbGV0IGVsZW0gPSB7IHNpemU7IHRva2VuID0gUHBfdGJyZWFrICh3aWR0aCwgb2Zmc2V0KTsgbGVuZ3RoID0gd2lkdGggfSBpblxuICAgIHNjYW5fcHVzaCBzdGF0ZSB0cnVlIGVsZW1cblxuXG5sZXQgcHBfcHJpbnRfdGFiIHN0YXRlICgpID0gcHBfcHJpbnRfdGJyZWFrIHN0YXRlIDAgMFxuXG5sZXQgcHBfc2V0X3RhYiBzdGF0ZSAoKSA9XG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXMgdGhlblxuICAgIGxldCBlbGVtID0geyBzaXplID0gU2l6ZS56ZXJvOyB0b2tlbiA9IFBwX3N0YWI7IGxlbmd0aCA9IDAgfSBpblxuICAgIGVucXVldWVfYWR2YW5jZSBzdGF0ZSBlbGVtXG5cblxuKCpcblxuICBQcm9jZWR1cmVzIHRvIGNvbnRyb2wgdGhlIHByZXR0eS1wcmludGVyc1xuXG4qKVxuXG4oKiBTZXRfbWF4X2JveGVzLiAqKVxubGV0IHBwX3NldF9tYXhfYm94ZXMgc3RhdGUgbiA9IGlmIG4gPiAxIHRoZW4gc3RhdGUucHBfbWF4X2JveGVzIDwtIG5cblxuKCogVG8ga25vdyB0aGUgY3VycmVudCBtYXhpbXVtIG51bWJlciBvZiBib3hlcyBhbGxvd2VkLiAqKVxubGV0IHBwX2dldF9tYXhfYm94ZXMgc3RhdGUgKCkgPSBzdGF0ZS5wcF9tYXhfYm94ZXNcblxubGV0IHBwX292ZXJfbWF4X2JveGVzIHN0YXRlICgpID0gc3RhdGUucHBfY3Vycl9kZXB0aCA9IHN0YXRlLnBwX21heF9ib3hlc1xuXG4oKiBFbGxpcHNpcy4gKilcbmxldCBwcF9zZXRfZWxsaXBzaXNfdGV4dCBzdGF0ZSBzID0gc3RhdGUucHBfZWxsaXBzaXMgPC0gc1xuYW5kIHBwX2dldF9lbGxpcHNpc190ZXh0IHN0YXRlICgpID0gc3RhdGUucHBfZWxsaXBzaXNcblxuXG4oKiBUbyBzZXQgdGhlIG1hcmdpbiBvZiBwcmV0dHktcHJpbnRlci4gKilcbmxldCBwcF9saW1pdCBuID1cbiAgaWYgbiA8IHBwX2luZmluaXR5IHRoZW4gbiBlbHNlIHByZWQgcHBfaW5maW5pdHlcblxuXG4oKiBJbnRlcm5hbCBwcmV0dHktcHJpbnRlciBmdW5jdGlvbnMuICopXG5sZXQgcHBfc2V0X21pbl9zcGFjZV9sZWZ0IHN0YXRlIG4gPVxuICBpZiBuID49IDEgdGhlblxuICAgIGxldCBuID0gcHBfbGltaXQgbiBpblxuICAgIHN0YXRlLnBwX21pbl9zcGFjZV9sZWZ0IDwtIG47XG4gICAgc3RhdGUucHBfbWF4X2luZGVudCA8LSBzdGF0ZS5wcF9tYXJnaW4gLSBzdGF0ZS5wcF9taW5fc3BhY2VfbGVmdDtcbiAgICBwcF9yaW5pdCBzdGF0ZVxuXG5cbigqIEluaXRpYWxseSwgd2UgaGF2ZSA6XG4gICBwcF9tYXhfaW5kZW50ID0gcHBfbWFyZ2luIC0gcHBfbWluX3NwYWNlX2xlZnQsIGFuZFxuICAgcHBfc3BhY2VfbGVmdCA9IHBwX21hcmdpbi4gKilcbmxldCBwcF9zZXRfbWF4X2luZGVudCBzdGF0ZSBuID1cbiAgaWYgbiA+IDEgdGhlblxuICAgIHBwX3NldF9taW5fc3BhY2VfbGVmdCBzdGF0ZSAoc3RhdGUucHBfbWFyZ2luIC0gbilcblxuXG5sZXQgcHBfZ2V0X21heF9pbmRlbnQgc3RhdGUgKCkgPSBzdGF0ZS5wcF9tYXhfaW5kZW50XG5cbmxldCBwcF9zZXRfbWFyZ2luIHN0YXRlIG4gPVxuICBpZiBuID49IDEgdGhlblxuICAgIGxldCBuID0gcHBfbGltaXQgbiBpblxuICAgIHN0YXRlLnBwX21hcmdpbiA8LSBuO1xuICAgIGxldCBuZXdfbWF4X2luZGVudCA9XG4gICAgICAoKiBUcnkgdG8gbWFpbnRhaW4gbWF4X2luZGVudCB0byBpdHMgYWN0dWFsIHZhbHVlLiAqKVxuICAgICAgaWYgc3RhdGUucHBfbWF4X2luZGVudCA8PSBzdGF0ZS5wcF9tYXJnaW5cbiAgICAgIHRoZW4gc3RhdGUucHBfbWF4X2luZGVudCBlbHNlXG4gICAgICAoKiBJZiBwb3NzaWJsZSBtYWludGFpbiBwcF9taW5fc3BhY2VfbGVmdCB0byBpdHMgYWN0dWFsIHZhbHVlLFxuICAgICAgICAgaWYgdGhpcyBsZWFkcyB0byBhIHRvbyBzbWFsbCBtYXhfaW5kZW50LCB0YWtlIGhhbGYgb2YgdGhlXG4gICAgICAgICBuZXcgbWFyZ2luLCBpZiBpdCBpcyBncmVhdGVyIHRoYW4gMS4gKilcbiAgICAgICBtYXggKG1heCAoc3RhdGUucHBfbWFyZ2luIC0gc3RhdGUucHBfbWluX3NwYWNlX2xlZnQpXG4gICAgICAgICAgICAgICAgKHN0YXRlLnBwX21hcmdpbiAvIDIpKSAxIGluXG4gICAgKCogUmVidWlsZCBpbnZhcmlhbnRzLiAqKVxuICAgIHBwX3NldF9tYXhfaW5kZW50IHN0YXRlIG5ld19tYXhfaW5kZW50XG5cblxuKCoqIEdlb21ldHJ5IGZ1bmN0aW9ucyBhbmQgdHlwZXMgKilcbnR5cGUgZ2VvbWV0cnkgPSB7IG1heF9pbmRlbnQ6aW50OyBtYXJnaW46IGludH1cblxubGV0IHZhbGlkYXRlX2dlb21ldHJ5IHttYXJnaW47IG1heF9pbmRlbnR9ID1cbiAgaWYgbWF4X2luZGVudCA8IDIgdGhlblxuICAgIEVycm9yIFwibWF4X2luZGVudCA8IDJcIlxuICBlbHNlIGlmIG1hcmdpbiA8PSBtYXhfaW5kZW50IHRoZW5cbiAgICBFcnJvciBcIm1hcmdpbiA8PSBtYXhfaW5kZW50XCJcbiAgZWxzZSBPayAoKVxuXG5sZXQgY2hlY2tfZ2VvbWV0cnkgZ2VvbWV0cnkgPVxuICBtYXRjaCB2YWxpZGF0ZV9nZW9tZXRyeSBnZW9tZXRyeSB3aXRoXG4gIHwgT2sgKCkgLT4gdHJ1ZVxuICB8IEVycm9yIF8gLT4gZmFsc2VcblxubGV0IHBwX2dldF9tYXJnaW4gc3RhdGUgKCkgPSBzdGF0ZS5wcF9tYXJnaW5cblxubGV0IHBwX3NldF9mdWxsX2dlb21ldHJ5IHN0YXRlIHttYXJnaW47IG1heF9pbmRlbnR9ID1cbiAgcHBfc2V0X21hcmdpbiBzdGF0ZSBtYXJnaW47XG4gIHBwX3NldF9tYXhfaW5kZW50IHN0YXRlIG1heF9pbmRlbnQ7XG4gICgpXG5cbmxldCBwcF9zZXRfZ2VvbWV0cnkgc3RhdGUgfm1heF9pbmRlbnQgfm1hcmdpbiA9XG4gIGxldCBnZW9tZXRyeSA9IHsgbWF4X2luZGVudDsgbWFyZ2luIH0gaW5cbiAgbWF0Y2ggdmFsaWRhdGVfZ2VvbWV0cnkgZ2VvbWV0cnkgd2l0aFxuICB8IEVycm9yIG1zZyAtPlxuICAgIHJhaXNlIChJbnZhbGlkX2FyZ3VtZW50IChcIkZvcm1hdC5wcF9zZXRfZ2VvbWV0cnk6IFwiIF4gbXNnKSlcbiAgfCBPayAoKSAtPlxuICAgIHBwX3NldF9mdWxsX2dlb21ldHJ5IHN0YXRlIGdlb21ldHJ5XG5cbmxldCBwcF9zYWZlX3NldF9nZW9tZXRyeSBzdGF0ZSB+bWF4X2luZGVudCB+bWFyZ2luID1cbiAgbGV0IGdlb21ldHJ5ID0geyBtYXhfaW5kZW50OyBtYXJnaW4gfSBpblxuICBtYXRjaCB2YWxpZGF0ZV9nZW9tZXRyeSBnZW9tZXRyeSB3aXRoXG4gIHwgRXJyb3IgX21zZyAtPlxuICAgICAoKVxuICB8IE9rICgpIC0+XG4gICAgcHBfc2V0X2Z1bGxfZ2VvbWV0cnkgc3RhdGUgZ2VvbWV0cnlcblxubGV0IHBwX2dldF9nZW9tZXRyeSBzdGF0ZSAoKSA9XG4gIHsgbWFyZ2luID0gcHBfZ2V0X21hcmdpbiBzdGF0ZSAoKTsgbWF4X2luZGVudCA9IHBwX2dldF9tYXhfaW5kZW50IHN0YXRlICgpIH1cblxubGV0IHBwX3VwZGF0ZV9nZW9tZXRyeSBzdGF0ZSB1cGRhdGUgPVxuICBsZXQgZ2VvbWV0cnkgPSBwcF9nZXRfZ2VvbWV0cnkgc3RhdGUgKCkgaW5cbiAgcHBfc2V0X2Z1bGxfZ2VvbWV0cnkgc3RhdGUgKHVwZGF0ZSBnZW9tZXRyeSlcblxuKCogU2V0dGluZyBhIGZvcm1hdHRlciBiYXNpYyBvdXRwdXQgZnVuY3Rpb25zLiAqKVxubGV0IHBwX3NldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyBzdGF0ZSB7XG4gICAgICBvdXRfc3RyaW5nID0gZjtcbiAgICAgIG91dF9mbHVzaCA9IGc7XG4gICAgICBvdXRfbmV3bGluZSA9IGg7XG4gICAgICBvdXRfc3BhY2VzID0gaTtcbiAgICAgIG91dF9pbmRlbnQgPSBqO1xuICAgIH0gPVxuICBzdGF0ZS5wcF9vdXRfc3RyaW5nIDwtIGY7XG4gIHN0YXRlLnBwX291dF9mbHVzaCA8LSBnO1xuICBzdGF0ZS5wcF9vdXRfbmV3bGluZSA8LSBoO1xuICBzdGF0ZS5wcF9vdXRfc3BhY2VzIDwtIGk7XG4gIHN0YXRlLnBwX291dF9pbmRlbnQgPC0galxuXG5sZXQgcHBfZ2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zIHN0YXRlICgpID0ge1xuICBvdXRfc3RyaW5nID0gc3RhdGUucHBfb3V0X3N0cmluZztcbiAgb3V0X2ZsdXNoID0gc3RhdGUucHBfb3V0X2ZsdXNoO1xuICBvdXRfbmV3bGluZSA9IHN0YXRlLnBwX291dF9uZXdsaW5lO1xuICBvdXRfc3BhY2VzID0gc3RhdGUucHBfb3V0X3NwYWNlcztcbiAgb3V0X2luZGVudCA9IHN0YXRlLnBwX291dF9pbmRlbnQ7XG59XG5cblxuKCogU2V0dGluZyBhIGZvcm1hdHRlciBiYXNpYyBzdHJpbmcgb3V0cHV0IGFuZCBmbHVzaCBmdW5jdGlvbnMuICopXG5sZXQgcHBfc2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIHN0YXRlIGYgZyA9XG4gIHN0YXRlLnBwX291dF9zdHJpbmcgPC0gZjsgc3RhdGUucHBfb3V0X2ZsdXNoIDwtIGdcblxubGV0IHBwX2dldF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyBzdGF0ZSAoKSA9XG4gIChzdGF0ZS5wcF9vdXRfc3RyaW5nLCBzdGF0ZS5wcF9vdXRfZmx1c2gpXG5cblxuKCogVGhlIGRlZmF1bHQgZnVuY3Rpb24gdG8gb3V0cHV0IG5ldyBsaW5lcy4gKilcbmxldCBkaXNwbGF5X25ld2xpbmUgc3RhdGUgKCkgPSBzdGF0ZS5wcF9vdXRfc3RyaW5nIFwiXFxuXCIgMCAgMVxuXG4oKiBUaGUgZGVmYXVsdCBmdW5jdGlvbiB0byBvdXRwdXQgc3BhY2VzLiAqKVxubGV0IGJsYW5rX2xpbmUgPSBTdHJpbmcubWFrZSA4MCAnICdcbmxldCByZWMgZGlzcGxheV9ibGFua3Mgc3RhdGUgbiA9XG4gIGlmIG4gPiAwIHRoZW5cbiAgaWYgbiA8PSA4MCB0aGVuIHN0YXRlLnBwX291dF9zdHJpbmcgYmxhbmtfbGluZSAwIG4gZWxzZVxuICBiZWdpblxuICAgIHN0YXRlLnBwX291dF9zdHJpbmcgYmxhbmtfbGluZSAwIDgwO1xuICAgIGRpc3BsYXlfYmxhbmtzIHN0YXRlIChuIC0gODApXG4gIGVuZFxuXG5cbigqIFRoZSBkZWZhdWx0IGZ1bmN0aW9uIHRvIG91dHB1dCBpbmRlbnRhdGlvbiBvZiBuZXcgbGluZXMuICopXG5sZXQgZGlzcGxheV9pbmRlbnQgPSBkaXNwbGF5X2JsYW5rc1xuXG4oKiBTZXR0aW5nIGEgZm9ybWF0dGVyIGJhc2ljIG91dHB1dCBmdW5jdGlvbnMgYXMgcHJpbnRpbmcgdG8gYSBnaXZlblxuICAgW1BlcnZhc2l2ZS5vdXRfY2hhbm5lbF0gdmFsdWUuICopXG5sZXQgcHBfc2V0X2Zvcm1hdHRlcl9vdXRfY2hhbm5lbCBzdGF0ZSBvYyA9XG4gIHN0YXRlLnBwX291dF9zdHJpbmcgPC0gb3V0cHV0X3N1YnN0cmluZyBvYztcbiAgc3RhdGUucHBfb3V0X2ZsdXNoIDwtIChmdW4gKCkgLT4gZmx1c2ggb2MpO1xuICBzdGF0ZS5wcF9vdXRfbmV3bGluZSA8LSBkaXNwbGF5X25ld2xpbmUgc3RhdGU7XG4gIHN0YXRlLnBwX291dF9zcGFjZXMgPC0gZGlzcGxheV9ibGFua3Mgc3RhdGU7XG4gIHN0YXRlLnBwX291dF9pbmRlbnQgPC0gZGlzcGxheV9pbmRlbnQgc3RhdGVcblxuKCpcblxuICBEZWZpbmluZyBzcGVjaWZpYyBmb3JtYXR0ZXJzXG5cbiopXG5cbmxldCBkZWZhdWx0X3BwX21hcmtfb3Blbl90YWcgPSBmdW5jdGlvblxuICB8IFN0cmluZ190YWcgcyAtPiBcIjxcIiBeIHMgXiBcIj5cIlxuICB8IF8gLT4gXCJcIlxubGV0IGRlZmF1bHRfcHBfbWFya19jbG9zZV90YWcgPSBmdW5jdGlvblxuICB8IFN0cmluZ190YWcgcyAtPiBcIjwvXCIgXiBzIF4gXCI+XCJcbiAgfCBfIC0+IFwiXCJcblxubGV0IGRlZmF1bHRfcHBfcHJpbnRfb3Blbl90YWcgPSBpZ25vcmVcbmxldCBkZWZhdWx0X3BwX3ByaW50X2Nsb3NlX3RhZyA9IGlnbm9yZVxuXG4oKiBCdWlsZGluZyBhIGZvcm1hdHRlciBnaXZlbiBpdHMgYmFzaWMgb3V0cHV0IGZ1bmN0aW9ucy5cbiAgIE90aGVyIGZpZWxkcyBnZXQgcmVhc29uYWJsZSBkZWZhdWx0IHZhbHVlcy4gKilcbmxldCBwcF9tYWtlX2Zvcm1hdHRlciBmIGcgaCBpIGogPVxuICAoKiBUaGUgaW5pdGlhbCBzdGF0ZSBvZiB0aGUgZm9ybWF0dGVyIGNvbnRhaW5zIGEgZHVtbXkgYm94LiAqKVxuICBsZXQgcHBfcXVldWUgPSBRdWV1ZS5jcmVhdGUgKCkgaW5cbiAgbGV0IHN5c190b2sgPVxuICAgIHsgc2l6ZSA9IFNpemUudW5rbm93bjsgdG9rZW4gPSBQcF9iZWdpbiAoMCwgUHBfaG92Ym94KTsgbGVuZ3RoID0gMCB9IGluXG4gIFF1ZXVlLmFkZCBzeXNfdG9rIHBwX3F1ZXVlO1xuICBsZXQgc2Nhbl9zdGFjayA9IFN0YWNrLmNyZWF0ZSAoKSBpblxuICBpbml0aWFsaXplX3NjYW5fc3RhY2sgc2Nhbl9zdGFjaztcbiAgU3RhY2sucHVzaCB7IGxlZnRfdG90YWwgPSAxOyBxdWV1ZV9lbGVtID0gc3lzX3RvayB9IHNjYW5fc3RhY2s7XG4gIGxldCBwcF9tYXJnaW4gPSA3OFxuICBhbmQgcHBfbWluX3NwYWNlX2xlZnQgPSAxMCBpblxuICB7XG4gICAgcHBfc2Nhbl9zdGFjayA9IHNjYW5fc3RhY2s7XG4gICAgcHBfZm9ybWF0X3N0YWNrID0gU3RhY2suY3JlYXRlICgpO1xuICAgIHBwX3Rib3hfc3RhY2sgPSBTdGFjay5jcmVhdGUgKCk7XG4gICAgcHBfdGFnX3N0YWNrID0gU3RhY2suY3JlYXRlICgpO1xuICAgIHBwX21hcmtfc3RhY2sgPSBTdGFjay5jcmVhdGUgKCk7XG4gICAgcHBfbWFyZ2luID0gcHBfbWFyZ2luO1xuICAgIHBwX21pbl9zcGFjZV9sZWZ0ID0gcHBfbWluX3NwYWNlX2xlZnQ7XG4gICAgcHBfbWF4X2luZGVudCA9IHBwX21hcmdpbiAtIHBwX21pbl9zcGFjZV9sZWZ0O1xuICAgIHBwX3NwYWNlX2xlZnQgPSBwcF9tYXJnaW47XG4gICAgcHBfY3VycmVudF9pbmRlbnQgPSAwO1xuICAgIHBwX2lzX25ld19saW5lID0gdHJ1ZTtcbiAgICBwcF9sZWZ0X3RvdGFsID0gMTtcbiAgICBwcF9yaWdodF90b3RhbCA9IDE7XG4gICAgcHBfY3Vycl9kZXB0aCA9IDE7XG4gICAgcHBfbWF4X2JveGVzID0gbWF4X2ludDtcbiAgICBwcF9lbGxpcHNpcyA9IFwiLlwiO1xuICAgIHBwX291dF9zdHJpbmcgPSBmO1xuICAgIHBwX291dF9mbHVzaCA9IGc7XG4gICAgcHBfb3V0X25ld2xpbmUgPSBoO1xuICAgIHBwX291dF9zcGFjZXMgPSBpO1xuICAgIHBwX291dF9pbmRlbnQgPSBqO1xuICAgIHBwX3ByaW50X3RhZ3MgPSBmYWxzZTtcbiAgICBwcF9tYXJrX3RhZ3MgPSBmYWxzZTtcbiAgICBwcF9tYXJrX29wZW5fdGFnID0gZGVmYXVsdF9wcF9tYXJrX29wZW5fdGFnO1xuICAgIHBwX21hcmtfY2xvc2VfdGFnID0gZGVmYXVsdF9wcF9tYXJrX2Nsb3NlX3RhZztcbiAgICBwcF9wcmludF9vcGVuX3RhZyA9IGRlZmF1bHRfcHBfcHJpbnRfb3Blbl90YWc7XG4gICAgcHBfcHJpbnRfY2xvc2VfdGFnID0gZGVmYXVsdF9wcF9wcmludF9jbG9zZV90YWc7XG4gICAgcHBfcXVldWUgPSBwcF9xdWV1ZTtcbiAgfVxuXG5cbigqIEJ1aWxkIGEgZm9ybWF0dGVyIG91dCBvZiBpdHMgb3V0IGZ1bmN0aW9ucy4gKilcbmxldCBmb3JtYXR0ZXJfb2Zfb3V0X2Z1bmN0aW9ucyBvdXRfZnVucyA9XG4gIHBwX21ha2VfZm9ybWF0dGVyXG4gICAgb3V0X2Z1bnMub3V0X3N0cmluZ1xuICAgIG91dF9mdW5zLm91dF9mbHVzaFxuICAgIG91dF9mdW5zLm91dF9uZXdsaW5lXG4gICAgb3V0X2Z1bnMub3V0X3NwYWNlc1xuICAgIG91dF9mdW5zLm91dF9pbmRlbnRcblxuXG4oKiBNYWtlIGEgZm9ybWF0dGVyIHdpdGggZGVmYXVsdCBmdW5jdGlvbnMgdG8gb3V0cHV0IHNwYWNlcyxcbiAgaW5kZW50YXRpb24sIGFuZCBuZXcgbGluZXMuICopXG5sZXQgbWFrZV9mb3JtYXR0ZXIgb3V0cHV0IGZsdXNoID1cbiAgbGV0IHBwZiA9IHBwX21ha2VfZm9ybWF0dGVyIG91dHB1dCBmbHVzaCBpZ25vcmUgaWdub3JlIGlnbm9yZSBpblxuICBwcGYucHBfb3V0X25ld2xpbmUgPC0gZGlzcGxheV9uZXdsaW5lIHBwZjtcbiAgcHBmLnBwX291dF9zcGFjZXMgPC0gZGlzcGxheV9ibGFua3MgcHBmO1xuICBwcGYucHBfb3V0X2luZGVudCA8LSBkaXNwbGF5X2luZGVudCBwcGY7XG4gIHBwZlxuXG5cbigqIE1ha2UgYSBmb3JtYXR0ZXIgd3JpdGluZyB0byBhIGdpdmVuIFtQZXJ2YXNpdmUub3V0X2NoYW5uZWxdIHZhbHVlLiAqKVxubGV0IGZvcm1hdHRlcl9vZl9vdXRfY2hhbm5lbCBvYyA9XG4gIG1ha2VfZm9ybWF0dGVyIChvdXRwdXRfc3Vic3RyaW5nIG9jKSAoZnVuICgpIC0+IGZsdXNoIG9jKVxuXG5cbigqIE1ha2UgYSBmb3JtYXR0ZXIgd3JpdGluZyB0byBhIGdpdmVuIFtCdWZmZXIudF0gdmFsdWUuICopXG5sZXQgZm9ybWF0dGVyX29mX2J1ZmZlciBiID1cbiAgbWFrZV9mb3JtYXR0ZXIgKEJ1ZmZlci5hZGRfc3Vic3RyaW5nIGIpIGlnbm9yZVxuXG5cbigqIEFsbG9jYXRpbmcgYnVmZmVyIGZvciBwcmV0dHktcHJpbnRpbmcgcHVycG9zZXMuXG4gICBEZWZhdWx0IGJ1ZmZlciBzaXplIGlzIHBwX2J1ZmZlcl9zaXplIG9yIDUxMi5cbiopXG5sZXQgcHBfYnVmZmVyX3NpemUgPSA1MTJcbmxldCBwcF9tYWtlX2J1ZmZlciAoKSA9IEJ1ZmZlci5jcmVhdGUgcHBfYnVmZmVyX3NpemVcblxuKCogVGhlIHN0YW5kYXJkIChzaGFyZWQpIGJ1ZmZlci4gKilcbmxldCBzdGRidWYgPSBwcF9tYWtlX2J1ZmZlciAoKVxuXG4oKiBQcmVkZWZpbmVkIGZvcm1hdHRlcnMgc3RhbmRhcmQgZm9ybWF0dGVyIHRvIHByaW50XG4gICB0byBbU3RkbGliLnN0ZG91dF0sIFtTdGRsaWIuc3RkZXJyXSwgYW5kIHshc3RkYnVmfS4gKilcbmxldCBzdGRfZm9ybWF0dGVyID0gZm9ybWF0dGVyX29mX291dF9jaGFubmVsIFN0ZGxpYi5zdGRvdXRcbmFuZCBlcnJfZm9ybWF0dGVyID0gZm9ybWF0dGVyX29mX291dF9jaGFubmVsIFN0ZGxpYi5zdGRlcnJcbmFuZCBzdHJfZm9ybWF0dGVyID0gZm9ybWF0dGVyX29mX2J1ZmZlciBzdGRidWZcblxuXG4oKiBbZmx1c2hfYnVmZmVyX2Zvcm1hdHRlciBidWYgcHBmXSBmbHVzaGVzIGZvcm1hdHRlciBbcHBmXSxcbiAgIHRoZW4gcmV0dXJucyB0aGUgY29udGVudHMgb2YgYnVmZmVyIFtidWZdIHRoYXQgaXMgcmVzZXQuXG4gICBGb3JtYXR0ZXIgW3BwZl0gaXMgc3VwcG9zZWQgdG8gcHJpbnQgdG8gYnVmZmVyIFtidWZdLCBvdGhlcndpc2UgdGhpc1xuICAgZnVuY3Rpb24gaXMgbm90IHJlYWxseSB1c2VmdWwuICopXG5sZXQgZmx1c2hfYnVmZmVyX2Zvcm1hdHRlciBidWYgcHBmID1cbiAgcHBfZmx1c2hfcXVldWUgcHBmIGZhbHNlO1xuICBsZXQgcyA9IEJ1ZmZlci5jb250ZW50cyBidWYgaW5cbiAgQnVmZmVyLnJlc2V0IGJ1ZjtcbiAgc1xuXG5cbigqIEZsdXNoIFtzdHJfZm9ybWF0dGVyXSBhbmQgZ2V0IHRoZSBjb250ZW50cyBvZiBbc3RkYnVmXS4gKilcbmxldCBmbHVzaF9zdHJfZm9ybWF0dGVyICgpID0gZmx1c2hfYnVmZmVyX2Zvcm1hdHRlciBzdGRidWYgc3RyX2Zvcm1hdHRlclxuXG4oKlxuICBTeW1ib2xpYyBwcmV0dHktcHJpbnRpbmdcbiopXG5cbigqXG4gIFN5bWJvbGljIHByZXR0eS1wcmludGluZyBpcyBwcmV0dHktcHJpbnRpbmcgd2l0aCBubyBsb3cgbGV2ZWwgb3V0cHV0LlxuXG4gIFdoZW4gdXNpbmcgYSBzeW1ib2xpYyBmb3JtYXR0ZXIsIGFsbCByZWd1bGFyIHByZXR0eS1wcmludGluZyBhY3Rpdml0aWVzXG4gIG9jY3VyIGJ1dCBvdXRwdXQgbWF0ZXJpYWwgaXMgc3ltYm9saWMgYW5kIHN0b3JlZCBpbiBhIGJ1ZmZlciBvZiBvdXRwdXRcbiAgaXRlbXMuIEF0IHRoZSBlbmQgb2YgcHJldHR5LXByaW50aW5nLCBmbHVzaGluZyB0aGUgb3V0cHV0IGJ1ZmZlciBhbGxvd3NcbiAgcG9zdC1wcm9jZXNzaW5nIG9mIHN5bWJvbGljIG91dHB1dCBiZWZvcmUgbG93IGxldmVsIG91dHB1dCBvcGVyYXRpb25zLlxuKilcblxudHlwZSBzeW1ib2xpY19vdXRwdXRfaXRlbSA9XG4gIHwgT3V0cHV0X2ZsdXNoXG4gIHwgT3V0cHV0X25ld2xpbmVcbiAgfCBPdXRwdXRfc3RyaW5nIG9mIHN0cmluZ1xuICB8IE91dHB1dF9zcGFjZXMgb2YgaW50XG4gIHwgT3V0cHV0X2luZGVudCBvZiBpbnRcblxudHlwZSBzeW1ib2xpY19vdXRwdXRfYnVmZmVyID0ge1xuICBtdXRhYmxlIHN5bWJvbGljX291dHB1dF9jb250ZW50cyA6IHN5bWJvbGljX291dHB1dF9pdGVtIGxpc3Q7XG59XG5cbmxldCBtYWtlX3N5bWJvbGljX291dHB1dF9idWZmZXIgKCkgPVxuICB7IHN5bWJvbGljX291dHB1dF9jb250ZW50cyA9IFtdIH1cblxubGV0IGNsZWFyX3N5bWJvbGljX291dHB1dF9idWZmZXIgc29iID1cbiAgc29iLnN5bWJvbGljX291dHB1dF9jb250ZW50cyA8LSBbXVxuXG5sZXQgZ2V0X3N5bWJvbGljX291dHB1dF9idWZmZXIgc29iID1cbiAgTGlzdC5yZXYgc29iLnN5bWJvbGljX291dHB1dF9jb250ZW50c1xuXG5sZXQgZmx1c2hfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciBzb2IgPVxuICBsZXQgaXRlbXMgPSBnZXRfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciBzb2IgaW5cbiAgY2xlYXJfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciBzb2I7XG4gIGl0ZW1zXG5cbmxldCBhZGRfc3ltYm9saWNfb3V0cHV0X2l0ZW0gc29iIGl0ZW0gPVxuICBzb2Iuc3ltYm9saWNfb3V0cHV0X2NvbnRlbnRzIDwtIGl0ZW0gOjogc29iLnN5bWJvbGljX291dHB1dF9jb250ZW50c1xuXG5sZXQgZm9ybWF0dGVyX29mX3N5bWJvbGljX291dHB1dF9idWZmZXIgc29iID1cbiAgbGV0IHN5bWJvbGljX2ZsdXNoIHNvYiAoKSA9XG4gICAgYWRkX3N5bWJvbGljX291dHB1dF9pdGVtIHNvYiBPdXRwdXRfZmx1c2hcbiAgYW5kIHN5bWJvbGljX25ld2xpbmUgc29iICgpID1cbiAgICBhZGRfc3ltYm9saWNfb3V0cHV0X2l0ZW0gc29iIE91dHB1dF9uZXdsaW5lXG4gIGFuZCBzeW1ib2xpY19zdHJpbmcgc29iIHMgaSBuID1cbiAgICBhZGRfc3ltYm9saWNfb3V0cHV0X2l0ZW0gc29iIChPdXRwdXRfc3RyaW5nIChTdHJpbmcuc3ViIHMgaSBuKSlcbiAgYW5kIHN5bWJvbGljX3NwYWNlcyBzb2IgbiA9XG4gICAgYWRkX3N5bWJvbGljX291dHB1dF9pdGVtIHNvYiAoT3V0cHV0X3NwYWNlcyBuKVxuICBhbmQgc3ltYm9saWNfaW5kZW50IHNvYiBuID1cbiAgICBhZGRfc3ltYm9saWNfb3V0cHV0X2l0ZW0gc29iIChPdXRwdXRfaW5kZW50IG4pIGluXG5cbiAgbGV0IGYgPSBzeW1ib2xpY19zdHJpbmcgc29iXG4gIGFuZCBnID0gc3ltYm9saWNfZmx1c2ggc29iXG4gIGFuZCBoID0gc3ltYm9saWNfbmV3bGluZSBzb2JcbiAgYW5kIGkgPSBzeW1ib2xpY19zcGFjZXMgc29iXG4gIGFuZCBqID0gc3ltYm9saWNfaW5kZW50IHNvYiBpblxuICBwcF9tYWtlX2Zvcm1hdHRlciBmIGcgaCBpIGpcblxuKCpcblxuICBCYXNpYyBmdW5jdGlvbnMgb24gdGhlICdzdGFuZGFyZCcgZm9ybWF0dGVyXG4gICh0aGUgZm9ybWF0dGVyIHRoYXQgcHJpbnRzIHRvIFtTdGRsaWIuc3Rkb3V0XSkuXG5cbiopXG5cbmxldCBvcGVuX2hib3ggPSBwcF9vcGVuX2hib3ggc3RkX2Zvcm1hdHRlclxuYW5kIG9wZW5fdmJveCA9IHBwX29wZW5fdmJveCBzdGRfZm9ybWF0dGVyXG5hbmQgb3Blbl9odmJveCA9IHBwX29wZW5faHZib3ggc3RkX2Zvcm1hdHRlclxuYW5kIG9wZW5faG92Ym94ID0gcHBfb3Blbl9ob3Zib3ggc3RkX2Zvcm1hdHRlclxuYW5kIG9wZW5fYm94ID0gcHBfb3Blbl9ib3ggc3RkX2Zvcm1hdHRlclxuYW5kIGNsb3NlX2JveCA9IHBwX2Nsb3NlX2JveCBzdGRfZm9ybWF0dGVyXG5hbmQgb3Blbl90YWcgPSBwcF9vcGVuX3RhZyBzdGRfZm9ybWF0dGVyXG5hbmQgY2xvc2VfdGFnID0gcHBfY2xvc2VfdGFnIHN0ZF9mb3JtYXR0ZXJcbmFuZCBvcGVuX3N0YWcgPSBwcF9vcGVuX3N0YWcgc3RkX2Zvcm1hdHRlclxuYW5kIGNsb3NlX3N0YWcgPSBwcF9jbG9zZV9zdGFnIHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF9hcyA9IHBwX3ByaW50X2FzIHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF9zdHJpbmcgPSBwcF9wcmludF9zdHJpbmcgc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X2ludCA9IHBwX3ByaW50X2ludCBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfZmxvYXQgPSBwcF9wcmludF9mbG9hdCBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfY2hhciA9IHBwX3ByaW50X2NoYXIgc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X2Jvb2wgPSBwcF9wcmludF9ib29sIHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF9icmVhayA9IHBwX3ByaW50X2JyZWFrIHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF9jdXQgPSBwcF9wcmludF9jdXQgc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X3NwYWNlID0gcHBfcHJpbnRfc3BhY2Ugc3RkX2Zvcm1hdHRlclxuYW5kIGZvcmNlX25ld2xpbmUgPSBwcF9mb3JjZV9uZXdsaW5lIHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF9mbHVzaCA9IHBwX3ByaW50X2ZsdXNoIHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF9uZXdsaW5lID0gcHBfcHJpbnRfbmV3bGluZSBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfaWZfbmV3bGluZSA9IHBwX3ByaW50X2lmX25ld2xpbmUgc3RkX2Zvcm1hdHRlclxuXG5hbmQgb3Blbl90Ym94ID0gcHBfb3Blbl90Ym94IHN0ZF9mb3JtYXR0ZXJcbmFuZCBjbG9zZV90Ym94ID0gcHBfY2xvc2VfdGJveCBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfdGJyZWFrID0gcHBfcHJpbnRfdGJyZWFrIHN0ZF9mb3JtYXR0ZXJcblxuYW5kIHNldF90YWIgPSBwcF9zZXRfdGFiIHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF90YWIgPSBwcF9wcmludF90YWIgc3RkX2Zvcm1hdHRlclxuXG5hbmQgc2V0X21hcmdpbiA9IHBwX3NldF9tYXJnaW4gc3RkX2Zvcm1hdHRlclxuYW5kIGdldF9tYXJnaW4gPSBwcF9nZXRfbWFyZ2luIHN0ZF9mb3JtYXR0ZXJcblxuYW5kIHNldF9tYXhfaW5kZW50ID0gcHBfc2V0X21heF9pbmRlbnQgc3RkX2Zvcm1hdHRlclxuYW5kIGdldF9tYXhfaW5kZW50ID0gcHBfZ2V0X21heF9pbmRlbnQgc3RkX2Zvcm1hdHRlclxuXG5hbmQgc2V0X2dlb21ldHJ5ID0gcHBfc2V0X2dlb21ldHJ5IHN0ZF9mb3JtYXR0ZXJcbmFuZCBzYWZlX3NldF9nZW9tZXRyeSA9IHBwX3NhZmVfc2V0X2dlb21ldHJ5IHN0ZF9mb3JtYXR0ZXJcbmFuZCBnZXRfZ2VvbWV0cnkgPSBwcF9nZXRfZ2VvbWV0cnkgc3RkX2Zvcm1hdHRlclxuYW5kIHVwZGF0ZV9nZW9tZXRyeSA9IHBwX3VwZGF0ZV9nZW9tZXRyeSBzdGRfZm9ybWF0dGVyXG5cbmFuZCBzZXRfbWF4X2JveGVzID0gcHBfc2V0X21heF9ib3hlcyBzdGRfZm9ybWF0dGVyXG5hbmQgZ2V0X21heF9ib3hlcyA9IHBwX2dldF9tYXhfYm94ZXMgc3RkX2Zvcm1hdHRlclxuYW5kIG92ZXJfbWF4X2JveGVzID0gcHBfb3Zlcl9tYXhfYm94ZXMgc3RkX2Zvcm1hdHRlclxuXG5hbmQgc2V0X2VsbGlwc2lzX3RleHQgPSBwcF9zZXRfZWxsaXBzaXNfdGV4dCBzdGRfZm9ybWF0dGVyXG5hbmQgZ2V0X2VsbGlwc2lzX3RleHQgPSBwcF9nZXRfZWxsaXBzaXNfdGV4dCBzdGRfZm9ybWF0dGVyXG5cbmFuZCBzZXRfZm9ybWF0dGVyX291dF9jaGFubmVsID1cbiAgcHBfc2V0X2Zvcm1hdHRlcl9vdXRfY2hhbm5lbCBzdGRfZm9ybWF0dGVyXG5cbmFuZCBzZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgPVxuICBwcF9zZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgc3RkX2Zvcm1hdHRlclxuYW5kIGdldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyA9XG4gIHBwX2dldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyBzdGRfZm9ybWF0dGVyXG5cbmFuZCBzZXRfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgPVxuICBwcF9zZXRfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgc3RkX2Zvcm1hdHRlclxuYW5kIGdldF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyA9XG4gIHBwX2dldF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyBzdGRfZm9ybWF0dGVyXG5cbmFuZCBzZXRfZm9ybWF0dGVyX3N0YWdfZnVuY3Rpb25zID1cbiAgcHBfc2V0X2Zvcm1hdHRlcl9zdGFnX2Z1bmN0aW9ucyBzdGRfZm9ybWF0dGVyXG5hbmQgZ2V0X2Zvcm1hdHRlcl9zdGFnX2Z1bmN0aW9ucyA9XG4gIHBwX2dldF9mb3JtYXR0ZXJfc3RhZ19mdW5jdGlvbnMgc3RkX2Zvcm1hdHRlclxuYW5kIHNldF9wcmludF90YWdzID1cbiAgcHBfc2V0X3ByaW50X3RhZ3Mgc3RkX2Zvcm1hdHRlclxuYW5kIGdldF9wcmludF90YWdzID1cbiAgcHBfZ2V0X3ByaW50X3RhZ3Mgc3RkX2Zvcm1hdHRlclxuYW5kIHNldF9tYXJrX3RhZ3MgPVxuICBwcF9zZXRfbWFya190YWdzIHN0ZF9mb3JtYXR0ZXJcbmFuZCBnZXRfbWFya190YWdzID1cbiAgcHBfZ2V0X21hcmtfdGFncyBzdGRfZm9ybWF0dGVyXG5hbmQgc2V0X3RhZ3MgPVxuICBwcF9zZXRfdGFncyBzdGRfZm9ybWF0dGVyXG5cblxuKCogQ29udmVuaWVuY2UgZnVuY3Rpb25zICopXG5cbigqIFRvIGZvcm1hdCBhIGxpc3QgKilcbmxldCByZWMgcHBfcHJpbnRfbGlzdCA/KHBwX3NlcCA9IHBwX3ByaW50X2N1dCkgcHBfdiBwcGYgPSBmdW5jdGlvblxuICB8IFtdIC0+ICgpXG4gIHwgW3ZdIC0+IHBwX3YgcHBmIHZcbiAgfCB2IDo6IHZzIC0+XG4gICAgcHBfdiBwcGYgdjtcbiAgICBwcF9zZXAgcHBmICgpO1xuICAgIHBwX3ByaW50X2xpc3QgfnBwX3NlcCBwcF92IHBwZiB2c1xuXG4oKiBUbyBmb3JtYXQgYSBzZXF1ZW5jZSAqKVxubGV0IHJlYyBwcF9wcmludF9zZXFfaW4gfnBwX3NlcCBwcF92IHBwZiBzZXEgPVxuICBtYXRjaCBzZXEgKCkgd2l0aFxuICB8IFNlcS5OaWwgLT4gKClcbiAgfCBTZXEuQ29ucyAodiwgc2VxKSAtPlxuICAgIHBwX3NlcCBwcGYgKCk7XG4gICAgcHBfdiBwcGYgdjtcbiAgICBwcF9wcmludF9zZXFfaW4gfnBwX3NlcCBwcF92IHBwZiBzZXFcblxubGV0IHBwX3ByaW50X3NlcSA/KHBwX3NlcCA9IHBwX3ByaW50X2N1dCkgcHBfdiBwcGYgc2VxID1cbiAgbWF0Y2ggc2VxICgpIHdpdGhcbiAgfCBTZXEuTmlsIC0+ICgpXG4gIHwgU2VxLkNvbnMgKHYsIHNlcSkgLT5cbiAgICBwcF92IHBwZiB2O1xuICAgIHBwX3ByaW50X3NlcV9pbiB+cHBfc2VwIHBwX3YgcHBmIHNlcVxuXG4oKiBUbyBmb3JtYXQgZnJlZS1mbG93aW5nIHRleHQgKilcbmxldCBwcF9wcmludF90ZXh0IHBwZiBzID1cbiAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggcyBpblxuICBsZXQgbGVmdCA9IHJlZiAwIGluXG4gIGxldCByaWdodCA9IHJlZiAwIGluXG4gIGxldCBmbHVzaCAoKSA9XG4gICAgcHBfcHJpbnRfc3RyaW5nIHBwZiAoU3RyaW5nLnN1YiBzICFsZWZ0ICghcmlnaHQgLSAhbGVmdCkpO1xuICAgIGluY3IgcmlnaHQ7IGxlZnQgOj0gIXJpZ2h0O1xuICBpblxuICB3aGlsZSAoIXJpZ2h0IDw+IGxlbikgZG9cbiAgICBtYXRjaCBzLlshcmlnaHRdIHdpdGhcbiAgICAgIHwgJ1xcbicgLT5cbiAgICAgICAgZmx1c2ggKCk7XG4gICAgICAgIHBwX2ZvcmNlX25ld2xpbmUgcHBmICgpXG4gICAgICB8ICcgJyAtPlxuICAgICAgICBmbHVzaCAoKTsgcHBfcHJpbnRfc3BhY2UgcHBmICgpXG4gICAgICAoKiB0aGVyZSBpcyBubyBzcGVjaWZpYyBzdXBwb3J0IGZvciAnXFx0J1xuICAgICAgICAgYXMgaXQgaXMgdW5jbGVhciB3aGF0IGEgcmlnaHQgc2VtYW50aWNzIHdvdWxkIGJlICopXG4gICAgICB8IF8gLT4gaW5jciByaWdodFxuICBkb25lO1xuICBpZiAhbGVmdCA8PiBsZW4gdGhlbiBmbHVzaCAoKVxuXG5sZXQgcHBfcHJpbnRfb3B0aW9uID8obm9uZSA9IGZ1biBfICgpIC0+ICgpKSBwcF92IHBwZiA9IGZ1bmN0aW9uXG58IE5vbmUgLT4gbm9uZSBwcGYgKClcbnwgU29tZSB2IC0+IHBwX3YgcHBmIHZcblxubGV0IHBwX3ByaW50X3Jlc3VsdCB+b2sgfmVycm9yIHBwZiA9IGZ1bmN0aW9uXG58IE9rIHYgLT4gb2sgcHBmIHZcbnwgRXJyb3IgZSAtPiBlcnJvciBwcGYgZVxuXG4gKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5sZXQgY29tcHV0ZV90YWcgb3V0cHV0IHRhZ19hY2MgPVxuICBsZXQgYnVmID0gQnVmZmVyLmNyZWF0ZSAxNiBpblxuICBsZXQgcHBmID0gZm9ybWF0dGVyX29mX2J1ZmZlciBidWYgaW5cbiAgb3V0cHV0IHBwZiB0YWdfYWNjO1xuICBwcF9wcmludF9mbHVzaCBwcGYgKCk7XG4gIGxldCBsZW4gPSBCdWZmZXIubGVuZ3RoIGJ1ZiBpblxuICBpZiBsZW4gPCAyIHRoZW4gQnVmZmVyLmNvbnRlbnRzIGJ1ZlxuICBlbHNlIEJ1ZmZlci5zdWIgYnVmIDEgKGxlbiAtIDIpXG5cbiAoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblxuICBEZWZpbmluZyBjb250aW51YXRpb25zIHRvIGJlIHBhc3NlZCBhcyBhcmd1bWVudHMgb2ZcbiAgQ2FtbGludGVybmFsRm9ybWF0Lm1ha2VfcHJpbnRmLlxuXG4gICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5vcGVuIENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljc1xub3BlbiBDYW1saW50ZXJuYWxGb3JtYXRcblxuKCogSW50ZXJwcmV0IGEgZm9ybWF0dGluZyBlbnRpdHkgb24gYSBmb3JtYXR0ZXIuICopXG5sZXQgb3V0cHV0X2Zvcm1hdHRpbmdfbGl0IHBwZiBmbXRpbmdfbGl0ID0gbWF0Y2ggZm10aW5nX2xpdCB3aXRoXG4gIHwgQ2xvc2VfYm94ICAgICAgICAgICAgICAgICAtPiBwcF9jbG9zZV9ib3ggcHBmICgpXG4gIHwgQ2xvc2VfdGFnICAgICAgICAgICAgICAgICAtPiBwcF9jbG9zZV90YWcgcHBmICgpXG4gIHwgQnJlYWsgKF8sIHdpZHRoLCBvZmZzZXQpICAtPiBwcF9wcmludF9icmVhayBwcGYgd2lkdGggb2Zmc2V0XG4gIHwgRkZsdXNoICAgICAgICAgICAgICAgICAgICAtPiBwcF9wcmludF9mbHVzaCBwcGYgKClcbiAgfCBGb3JjZV9uZXdsaW5lICAgICAgICAgICAgIC0+IHBwX2ZvcmNlX25ld2xpbmUgcHBmICgpXG4gIHwgRmx1c2hfbmV3bGluZSAgICAgICAgICAgICAtPiBwcF9wcmludF9uZXdsaW5lIHBwZiAoKVxuICB8IE1hZ2ljX3NpemUgKF8sIF8pICAgICAgICAgLT4gKClcbiAgfCBFc2NhcGVkX2F0ICAgICAgICAgICAgICAgIC0+IHBwX3ByaW50X2NoYXIgcHBmICdAJ1xuICB8IEVzY2FwZWRfcGVyY2VudCAgICAgICAgICAgLT4gcHBfcHJpbnRfY2hhciBwcGYgJyUnXG4gIHwgU2Nhbl9pbmRpYyBjICAgICAgICAgICAgICAtPiBwcF9wcmludF9jaGFyIHBwZiAnQCc7IHBwX3ByaW50X2NoYXIgcHBmIGNcblxuKCogUmVjdXJzaXZlbHkgb3V0cHV0IGFuIFwiYWNjdW11bGF0b3JcIiBjb250YWluaW5nIGEgcmV2ZXJzZWQgbGlzdCBvZlxuICAgcHJpbnRpbmcgZW50aXRpZXMgKHN0cmluZywgY2hhciwgZmx1cywgLi4uKSBpbiBhbiBvdXRwdXRfc3RyZWFtLiAqKVxuKCogRGlmZmVyIGZyb20gUHJpbnRmLm91dHB1dF9hY2MgYnkgdGhlIGludGVycHJldGF0aW9uIG9mIGZvcm1hdHRpbmcuICopXG4oKiBVc2VkIGFzIGEgY29udGludWF0aW9uIG9mIENhbWxpbnRlcm5hbEZvcm1hdC5tYWtlX3ByaW50Zi4gKilcbmxldCByZWMgb3V0cHV0X2FjYyBwcGYgYWNjID0gbWF0Y2ggYWNjIHdpdGhcbiAgfCBBY2Nfc3RyaW5nX2xpdGVyYWwgKEFjY19mb3JtYXR0aW5nX2xpdCAocCwgTWFnaWNfc2l6ZSAoXywgc2l6ZSkpLCBzKVxuICB8IEFjY19kYXRhX3N0cmluZyAoQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBNYWdpY19zaXplIChfLCBzaXplKSksIHMpIC0+XG4gICAgb3V0cHV0X2FjYyBwcGYgcDtcbiAgICBwcF9wcmludF9hc19zaXplIHBwZiAoU2l6ZS5vZl9pbnQgc2l6ZSkgcztcbiAgfCBBY2NfY2hhcl9saXRlcmFsIChBY2NfZm9ybWF0dGluZ19saXQgKHAsIE1hZ2ljX3NpemUgKF8sIHNpemUpKSwgYylcbiAgfCBBY2NfZGF0YV9jaGFyIChBY2NfZm9ybWF0dGluZ19saXQgKHAsIE1hZ2ljX3NpemUgKF8sIHNpemUpKSwgYykgLT5cbiAgICBvdXRwdXRfYWNjIHBwZiBwO1xuICAgIHBwX3ByaW50X2FzX3NpemUgcHBmIChTaXplLm9mX2ludCBzaXplKSAoU3RyaW5nLm1ha2UgMSBjKTtcbiAgfCBBY2NfZm9ybWF0dGluZ19saXQgKHAsIGYpIC0+XG4gICAgb3V0cHV0X2FjYyBwcGYgcDtcbiAgICBvdXRwdXRfZm9ybWF0dGluZ19saXQgcHBmIGY7XG4gIHwgQWNjX2Zvcm1hdHRpbmdfZ2VuIChwLCBBY2Nfb3Blbl90YWcgYWNjJykgLT5cbiAgICBvdXRwdXRfYWNjIHBwZiBwO1xuICAgIHBwX29wZW5fc3RhZyBwcGYgKFN0cmluZ190YWcgKGNvbXB1dGVfdGFnIG91dHB1dF9hY2MgYWNjJykpXG4gIHwgQWNjX2Zvcm1hdHRpbmdfZ2VuIChwLCBBY2Nfb3Blbl9ib3ggYWNjJykgLT5cbiAgICBvdXRwdXRfYWNjIHBwZiBwO1xuICAgIGxldCAoaW5kZW50LCBidHkpID0gb3Blbl9ib3hfb2Zfc3RyaW5nIChjb21wdXRlX3RhZyBvdXRwdXRfYWNjIGFjYycpIGluXG4gICAgcHBfb3Blbl9ib3hfZ2VuIHBwZiBpbmRlbnQgYnR5XG4gIHwgQWNjX3N0cmluZ19saXRlcmFsIChwLCBzKVxuICB8IEFjY19kYXRhX3N0cmluZyAocCwgcykgICAtPiBvdXRwdXRfYWNjIHBwZiBwOyBwcF9wcmludF9zdHJpbmcgcHBmIHM7XG4gIHwgQWNjX2NoYXJfbGl0ZXJhbCAocCwgYylcbiAgfCBBY2NfZGF0YV9jaGFyIChwLCBjKSAgICAgLT4gb3V0cHV0X2FjYyBwcGYgcDsgcHBfcHJpbnRfY2hhciBwcGYgYztcbiAgfCBBY2NfZGVsYXkgKHAsIGYpICAgICAgICAgLT4gb3V0cHV0X2FjYyBwcGYgcDsgZiBwcGY7XG4gIHwgQWNjX2ZsdXNoIHAgICAgICAgICAgICAgIC0+IG91dHB1dF9hY2MgcHBmIHA7IHBwX3ByaW50X2ZsdXNoIHBwZiAoKTtcbiAgfCBBY2NfaW52YWxpZF9hcmcgKHAsIG1zZykgLT4gb3V0cHV0X2FjYyBwcGYgcDsgaW52YWxpZF9hcmcgbXNnO1xuICB8IEVuZF9vZl9hY2MgICAgICAgICAgICAgICAtPiAoKVxuXG4oKiBSZWN1cnNpdmVseSBvdXRwdXQgYW4gXCJhY2N1bXVsYXRvclwiIGNvbnRhaW5pbmcgYSByZXZlcnNlZCBsaXN0IG9mXG4gICBwcmludGluZyBlbnRpdGllcyAoc3RyaW5nLCBjaGFyLCBmbHVzLCAuLi4pIGluIGEgYnVmZmVyLiAqKVxuKCogRGlmZmVyIGZyb20gUHJpbnRmLmJ1ZnB1dF9hY2MgYnkgdGhlIGludGVycHJldGF0aW9uIG9mIGZvcm1hdHRpbmcuICopXG4oKiBVc2VkIGFzIGEgY29udGludWF0aW9uIG9mIENhbWxpbnRlcm5hbEZvcm1hdC5tYWtlX3ByaW50Zi4gKilcbmxldCByZWMgc3RycHV0X2FjYyBwcGYgYWNjID0gbWF0Y2ggYWNjIHdpdGhcbiAgfCBBY2Nfc3RyaW5nX2xpdGVyYWwgKEFjY19mb3JtYXR0aW5nX2xpdCAocCwgTWFnaWNfc2l6ZSAoXywgc2l6ZSkpLCBzKVxuICB8IEFjY19kYXRhX3N0cmluZyAoQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBNYWdpY19zaXplIChfLCBzaXplKSksIHMpIC0+XG4gICAgc3RycHV0X2FjYyBwcGYgcDtcbiAgICBwcF9wcmludF9hc19zaXplIHBwZiAoU2l6ZS5vZl9pbnQgc2l6ZSkgcztcbiAgfCBBY2NfY2hhcl9saXRlcmFsIChBY2NfZm9ybWF0dGluZ19saXQgKHAsIE1hZ2ljX3NpemUgKF8sIHNpemUpKSwgYylcbiAgfCBBY2NfZGF0YV9jaGFyIChBY2NfZm9ybWF0dGluZ19saXQgKHAsIE1hZ2ljX3NpemUgKF8sIHNpemUpKSwgYykgLT5cbiAgICBzdHJwdXRfYWNjIHBwZiBwO1xuICAgIHBwX3ByaW50X2FzX3NpemUgcHBmIChTaXplLm9mX2ludCBzaXplKSAoU3RyaW5nLm1ha2UgMSBjKTtcbiAgfCBBY2NfZGVsYXkgKEFjY19mb3JtYXR0aW5nX2xpdCAocCwgTWFnaWNfc2l6ZSAoXywgc2l6ZSkpLCBmKSAtPlxuICAgIHN0cnB1dF9hY2MgcHBmIHA7XG4gICAgcHBfcHJpbnRfYXNfc2l6ZSBwcGYgKFNpemUub2ZfaW50IHNpemUpIChmICgpKTtcbiAgfCBBY2NfZm9ybWF0dGluZ19saXQgKHAsIGYpIC0+XG4gICAgc3RycHV0X2FjYyBwcGYgcDtcbiAgICBvdXRwdXRfZm9ybWF0dGluZ19saXQgcHBmIGY7XG4gIHwgQWNjX2Zvcm1hdHRpbmdfZ2VuIChwLCBBY2Nfb3Blbl90YWcgYWNjJykgLT5cbiAgICBzdHJwdXRfYWNjIHBwZiBwO1xuICAgIHBwX29wZW5fc3RhZyBwcGYgKFN0cmluZ190YWcgKGNvbXB1dGVfdGFnIHN0cnB1dF9hY2MgYWNjJykpXG4gIHwgQWNjX2Zvcm1hdHRpbmdfZ2VuIChwLCBBY2Nfb3Blbl9ib3ggYWNjJykgLT5cbiAgICBzdHJwdXRfYWNjIHBwZiBwO1xuICAgIGxldCAoaW5kZW50LCBidHkpID0gb3Blbl9ib3hfb2Zfc3RyaW5nIChjb21wdXRlX3RhZyBzdHJwdXRfYWNjIGFjYycpIGluXG4gICAgcHBfb3Blbl9ib3hfZ2VuIHBwZiBpbmRlbnQgYnR5XG4gIHwgQWNjX3N0cmluZ19saXRlcmFsIChwLCBzKVxuICB8IEFjY19kYXRhX3N0cmluZyAocCwgcykgICAtPiBzdHJwdXRfYWNjIHBwZiBwOyBwcF9wcmludF9zdHJpbmcgcHBmIHM7XG4gIHwgQWNjX2NoYXJfbGl0ZXJhbCAocCwgYylcbiAgfCBBY2NfZGF0YV9jaGFyIChwLCBjKSAgICAgLT4gc3RycHV0X2FjYyBwcGYgcDsgcHBfcHJpbnRfY2hhciBwcGYgYztcbiAgfCBBY2NfZGVsYXkgKHAsIGYpICAgICAgICAgLT4gc3RycHV0X2FjYyBwcGYgcDsgcHBfcHJpbnRfc3RyaW5nIHBwZiAoZiAoKSk7XG4gIHwgQWNjX2ZsdXNoIHAgICAgICAgICAgICAgIC0+IHN0cnB1dF9hY2MgcHBmIHA7IHBwX3ByaW50X2ZsdXNoIHBwZiAoKTtcbiAgfCBBY2NfaW52YWxpZF9hcmcgKHAsIG1zZykgLT4gc3RycHV0X2FjYyBwcGYgcDsgaW52YWxpZF9hcmcgbXNnO1xuICB8IEVuZF9vZl9hY2MgICAgICAgICAgICAgICAtPiAoKVxuXG4oKlxuXG4gIERlZmluaW5nIFtmcHJpbnRmXSBhbmQgdmFyaW91cyBmbGF2b3JzIG9mIFtmcHJpbnRmXS5cblxuKilcblxubGV0IGtmcHJpbnRmIGsgcHBmIChGb3JtYXQgKGZtdCwgXykpID1cbiAgbWFrZV9wcmludGZcbiAgICAoZnVuIGFjYyAtPiBvdXRwdXRfYWNjIHBwZiBhY2M7IGsgcHBmKVxuICAgIEVuZF9vZl9hY2MgZm10XG5cbmFuZCBpa2ZwcmludGYgayBwcGYgKEZvcm1hdCAoZm10LCBfKSkgPVxuICBtYWtlX2lwcmludGYgayBwcGYgZm10XG5cbmxldCBpZnByaW50ZiBfcHBmIChGb3JtYXQgKGZtdCwgXykpID1cbiAgbWFrZV9pcHJpbnRmIGlnbm9yZSAoKSBmbXRcblxubGV0IGZwcmludGYgcHBmID0ga2ZwcmludGYgaWdub3JlIHBwZlxubGV0IHByaW50ZiBmbXQgPSBmcHJpbnRmIHN0ZF9mb3JtYXR0ZXIgZm10XG5sZXQgZXByaW50ZiBmbXQgPSBmcHJpbnRmIGVycl9mb3JtYXR0ZXIgZm10XG5cbmxldCBrZHByaW50ZiBrIChGb3JtYXQgKGZtdCwgXykpID1cbiAgbWFrZV9wcmludGZcbiAgICAoZnVuIGFjYyAtPiBrIChmdW4gcHBmIC0+IG91dHB1dF9hY2MgcHBmIGFjYykpXG4gICAgRW5kX29mX2FjYyBmbXRcblxubGV0IGRwcmludGYgZm10ID0ga2RwcmludGYgKGZ1biBpIC0+IGkpIGZtdFxuXG5sZXQga3NwcmludGYgayAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIGxldCBiID0gcHBfbWFrZV9idWZmZXIgKCkgaW5cbiAgbGV0IHBwZiA9IGZvcm1hdHRlcl9vZl9idWZmZXIgYiBpblxuICBsZXQgayBhY2MgPVxuICAgIHN0cnB1dF9hY2MgcHBmIGFjYztcbiAgICBrIChmbHVzaF9idWZmZXJfZm9ybWF0dGVyIGIgcHBmKSBpblxuICBtYWtlX3ByaW50ZiBrIEVuZF9vZl9hY2MgZm10XG5cblxubGV0IHNwcmludGYgZm10ID0ga3NwcmludGYgaWQgZm10XG5cbmxldCBrYXNwcmludGYgayAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIGxldCBiID0gcHBfbWFrZV9idWZmZXIgKCkgaW5cbiAgbGV0IHBwZiA9IGZvcm1hdHRlcl9vZl9idWZmZXIgYiBpblxuICBsZXQgayBhY2MgPVxuICAgIG91dHB1dF9hY2MgcHBmIGFjYztcbiAgICBrIChmbHVzaF9idWZmZXJfZm9ybWF0dGVyIGIgcHBmKSBpblxuICBtYWtlX3ByaW50ZiBrIEVuZF9vZl9hY2MgZm10XG5cblxubGV0IGFzcHJpbnRmIGZtdCA9IGthc3ByaW50ZiBpZCBmbXRcblxuKCogRmx1c2hpbmcgc3RhbmRhcmQgZm9ybWF0dGVycyBhdCBlbmQgb2YgZXhlY3V0aW9uLiAqKVxuXG5sZXQgZmx1c2hfc3RhbmRhcmRfZm9ybWF0dGVycyAoKSA9XG4gIHBwX3ByaW50X2ZsdXNoIHN0ZF9mb3JtYXR0ZXIgKCk7XG4gIHBwX3ByaW50X2ZsdXNoIGVycl9mb3JtYXR0ZXIgKClcblxubGV0ICgpID0gYXRfZXhpdCBmbHVzaF9zdGFuZGFyZF9mb3JtYXR0ZXJzXG5cbigqXG5cbiAgRGVwcmVjYXRlZCBzdHVmZi5cblxuKilcblxuKCogRGVwcmVjYXRlZCA6IHN1YnN1bWVkIGJ5IHBwX3NldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyAqKVxubGV0IHBwX3NldF9hbGxfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgc3RhdGVcbiAgICB+b3V0OmYgfmZsdXNoOmcgfm5ld2xpbmU6aCB+c3BhY2VzOmkgPVxuICBwcF9zZXRfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgc3RhdGUgZiBnO1xuICBzdGF0ZS5wcF9vdXRfbmV3bGluZSA8LSBoO1xuICBzdGF0ZS5wcF9vdXRfc3BhY2VzIDwtIGlcblxuKCogRGVwcmVjYXRlZCA6IHN1YnN1bWVkIGJ5IHBwX2dldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyAqKVxubGV0IHBwX2dldF9hbGxfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgc3RhdGUgKCkgPVxuICAoc3RhdGUucHBfb3V0X3N0cmluZywgc3RhdGUucHBfb3V0X2ZsdXNoLFxuICAgc3RhdGUucHBfb3V0X25ld2xpbmUsIHN0YXRlLnBwX291dF9zcGFjZXMpXG5cblxuKCogRGVwcmVjYXRlZCA6IHN1YnN1bWVkIGJ5IHNldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyAqKVxubGV0IHNldF9hbGxfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgPVxuICBwcF9zZXRfYWxsX2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIHN0ZF9mb3JtYXR0ZXJcblxuXG4oKiBEZXByZWNhdGVkIDogc3Vic3VtZWQgYnkgZ2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zICopXG5sZXQgZ2V0X2FsbF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyA9XG4gIHBwX2dldF9hbGxfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgc3RkX2Zvcm1hdHRlclxuXG5cbigqIERlcHJlY2F0ZWQgOiBlcnJvciBwcm9uZSBmdW5jdGlvbiwgZG8gbm90IHVzZSBpdC5cbiAgIFRoaXMgZnVuY3Rpb24gaXMgbmVpdGhlciBjb21wb3NpdGlvbmFsIG5vciBpbmNyZW1lbnRhbCwgc2luY2UgaXQgZmx1c2hlc1xuICAgdGhlIHByZXR0eS1wcmludGVyIHF1ZXVlIGF0IGVhY2ggY2FsbC5cbiAgIFRvIGdldCB0aGUgc2FtZSBmdW5jdGlvbmFsaXR5LCBkZWZpbmUgYSBmb3JtYXR0ZXIgb2YgeW91ciBvd24gd3JpdGluZyB0b1xuICAgdGhlIGJ1ZmZlciBhcmd1bWVudCwgYXMgaW5cbiAgIGxldCBwcGYgPSBmb3JtYXR0ZXJfb2ZfYnVmZmVyIGJcbiAgIHRoZW4gdXNlIHshZnByaW50ZiBwcGZ9IGFzIHVzdWFsLiAqKVxubGV0IGJwcmludGYgYiAoRm9ybWF0IChmbXQsIF8pIDogKCdhLCBmb3JtYXR0ZXIsIHVuaXQpIGZvcm1hdCkgPVxuICBsZXQgcHBmID0gZm9ybWF0dGVyX29mX2J1ZmZlciBiIGluXG4gIGxldCBrIGFjYyA9IG91dHB1dF9hY2MgcHBmIGFjYzsgcHBfZmx1c2hfcXVldWUgcHBmIGZhbHNlIGluXG4gIG1ha2VfcHJpbnRmIGsgRW5kX29mX2FjYyBmbXRcblxuXG4oKiBEZXByZWNhdGVkIDogYWxpYXMgZm9yIGtzcHJpbnRmLiAqKVxubGV0IGtwcmludGYgPSBrc3ByaW50ZlxuXG5cblxuKCogRGVwcmVjYXRlZCB0YWcgZnVuY3Rpb25zICopXG5cbnR5cGUgZm9ybWF0dGVyX3RhZ19mdW5jdGlvbnMgPSB7XG4gIG1hcmtfb3Blbl90YWcgOiB0YWcgLT4gc3RyaW5nO1xuICBtYXJrX2Nsb3NlX3RhZyA6IHRhZyAtPiBzdHJpbmc7XG4gIHByaW50X29wZW5fdGFnIDogdGFnIC0+IHVuaXQ7XG4gIHByaW50X2Nsb3NlX3RhZyA6IHRhZyAtPiB1bml0O1xufVxuXG5cbmxldCBwcF9zZXRfZm9ybWF0dGVyX3RhZ19mdW5jdGlvbnMgc3RhdGUge1xuICAgICBtYXJrX29wZW5fdGFnID0gbW90O1xuICAgICBtYXJrX2Nsb3NlX3RhZyA9IG1jdDtcbiAgICAgcHJpbnRfb3Blbl90YWcgPSBwb3Q7XG4gICAgIHByaW50X2Nsb3NlX3RhZyA9IHBjdDtcbiAgIH0gPVxuICBsZXQgc3RyaW5naWZ5IGYgZSA9IGZ1bmN0aW9uIFN0cmluZ190YWcgcyAtPiBmIHMgfCBfIC0+IGUgaW5cbiAgc3RhdGUucHBfbWFya19vcGVuX3RhZyA8LSBzdHJpbmdpZnkgbW90IFwiXCI7XG4gIHN0YXRlLnBwX21hcmtfY2xvc2VfdGFnIDwtIHN0cmluZ2lmeSBtY3QgXCJcIjtcbiAgc3RhdGUucHBfcHJpbnRfb3Blbl90YWcgPC0gc3RyaW5naWZ5IHBvdCAoKTtcbiAgc3RhdGUucHBfcHJpbnRfY2xvc2VfdGFnIDwtIHN0cmluZ2lmeSBwY3QgKClcblxubGV0IHBwX2dldF9mb3JtYXR0ZXJfdGFnX2Z1bmN0aW9ucyBmbXQgKCkgPVxuICBsZXQgZnVucyA9IHBwX2dldF9mb3JtYXR0ZXJfc3RhZ19mdW5jdGlvbnMgZm10ICgpIGluXG4gIGxldCBtYXJrX29wZW5fdGFnIHMgPSBmdW5zLm1hcmtfb3Blbl9zdGFnIChTdHJpbmdfdGFnIHMpIGluXG4gIGxldCBtYXJrX2Nsb3NlX3RhZyBzID0gZnVucy5tYXJrX2Nsb3NlX3N0YWcgKFN0cmluZ190YWcgcykgaW5cbiAgbGV0IHByaW50X29wZW5fdGFnIHMgPSBmdW5zLnByaW50X29wZW5fc3RhZyAoU3RyaW5nX3RhZyBzKSBpblxuICBsZXQgcHJpbnRfY2xvc2VfdGFnIHMgPSBmdW5zLnByaW50X2Nsb3NlX3N0YWcgKFN0cmluZ190YWcgcykgaW5cbiAge21hcmtfb3Blbl90YWc7IG1hcmtfY2xvc2VfdGFnOyBwcmludF9vcGVuX3RhZzsgcHJpbnRfY2xvc2VfdGFnfVxuXG5sZXQgc2V0X2Zvcm1hdHRlcl90YWdfZnVuY3Rpb25zID1cbiAgcHBfc2V0X2Zvcm1hdHRlcl90YWdfZnVuY3Rpb25zIHN0ZF9mb3JtYXR0ZXJcbmFuZCBnZXRfZm9ybWF0dGVyX3RhZ19mdW5jdGlvbnMgPVxuICBwcF9nZXRfZm9ybWF0dGVyX3RhZ19mdW5jdGlvbnMgc3RkX2Zvcm1hdHRlclxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgUGllcnJlIFdlaXMsIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAwMiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5vcGVuIENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljc1xub3BlbiBDYW1saW50ZXJuYWxGb3JtYXRcblxuKCogYWxpYXMgdG8gYXZvaWQgd2FybmluZyBmb3IgYW1iaWd1aXR5IGJldHdlZW5cbiAgIFN0ZGxpYi5mb3JtYXQ2XG4gICBhbmQgQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzLmZvcm1hdDZcblxuICAgKHRoZSBmb3JtZXIgaXMgaW4gZmFjdCBhbiBhbGlhcyBmb3IgdGhlIGxhdHRlcixcbiAgICBidXQgdGhlIGFtYmlndWl0eSB3YXJuaW5nIGRvZXNuJ3QgY2FyZSlcbiopXG50eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2ID1cbiAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIFN0ZGxpYi5mb3JtYXQ2XG5cblxuKCogVGhlIHJ1bi10aW1lIGxpYnJhcnkgZm9yIHNjYW5uZXJzLiAqKVxuXG4oKiBTY2FubmluZyBidWZmZXJzLiAqKVxubW9kdWxlIHR5cGUgU0NBTk5JTkcgPSBzaWdcblxuICB0eXBlIGluX2NoYW5uZWxcblxuICB0eXBlIHNjYW5idWYgPSBpbl9jaGFubmVsXG5cbiAgdHlwZSBmaWxlX25hbWUgPSBzdHJpbmdcblxuICB2YWwgc3RkaW4gOiBpbl9jaGFubmVsXG4gICgqIFRoZSBzY2FubmluZyBidWZmZXIgcmVhZGluZyBmcm9tIFtTdGRsaWIuc3RkaW5dLlxuICAgICBbc3RkaWJdIGlzIGVxdWl2YWxlbnQgdG8gW1NjYW5uaW5nLmZyb21fY2hhbm5lbCBTdGRsaWIuc3RkaW5dLiAqKVxuXG4gIHZhbCBzdGRpYiA6IGluX2NoYW5uZWxcbiAgKCogQW4gYWxpYXMgZm9yIFtTY2FuZi5zdGRpbl0sIHRoZSBzY2FubmluZyBidWZmZXIgcmVhZGluZyBmcm9tXG4gICAgIFtTdGRsaWIuc3RkaW5dLiAqKVxuXG4gIHZhbCBuZXh0X2NoYXIgOiBzY2FuYnVmIC0+IGNoYXJcbiAgKCogW1NjYW5uaW5nLm5leHRfY2hhciBpYl0gYWR2YW5jZSB0aGUgc2Nhbm5pbmcgYnVmZmVyIGZvclxuICAgICBvbmUgY2hhcmFjdGVyLlxuICAgICBJZiBubyBtb3JlIGNoYXJhY3RlciBjYW4gYmUgcmVhZCwgc2V0cyBhIGVuZCBvZiBmaWxlIGNvbmRpdGlvbiBhbmRcbiAgICAgcmV0dXJucyAnXFwwMDAnLiAqKVxuXG4gIHZhbCBpbnZhbGlkYXRlX2N1cnJlbnRfY2hhciA6IHNjYW5idWYgLT4gdW5pdFxuICAoKiBbU2Nhbm5pbmcuaW52YWxpZGF0ZV9jdXJyZW50X2NoYXIgaWJdIG1hcmsgdGhlIGN1cnJlbnRfY2hhciBhcyBhbHJlYWR5XG4gICAgIHNjYW5uZWQuICopXG5cbiAgdmFsIHBlZWtfY2hhciA6IHNjYW5idWYgLT4gY2hhclxuICAoKiBbU2Nhbm5pbmcucGVla19jaGFyIGliXSByZXR1cm5zIHRoZSBjdXJyZW50IGNoYXIgYXZhaWxhYmxlIGluXG4gICAgIHRoZSBidWZmZXIgb3IgcmVhZHMgb25lIGlmIG5lY2Vzc2FyeSAod2hlbiB0aGUgY3VycmVudCBjaGFyYWN0ZXIgaXNcbiAgICAgYWxyZWFkeSBzY2FubmVkKS5cbiAgICAgSWYgbm8gY2hhcmFjdGVyIGNhbiBiZSByZWFkLCBzZXRzIGFuIGVuZCBvZiBmaWxlIGNvbmRpdGlvbiBhbmRcbiAgICAgcmV0dXJucyAnXFwwMDAnLiAqKVxuXG4gIHZhbCBjaGVja2VkX3BlZWtfY2hhciA6IHNjYW5idWYgLT4gY2hhclxuICAoKiBTYW1lIGFzIFtTY2FubmluZy5wZWVrX2NoYXJdIGFib3ZlIGJ1dCBhbHdheXMgcmV0dXJucyBhIHZhbGlkIGNoYXIgb3JcbiAgICAgZmFpbHM6IGluc3RlYWQgb2YgcmV0dXJuaW5nIGEgbnVsbCBjaGFyIHdoZW4gdGhlIHJlYWRpbmcgbWV0aG9kIG9mIHRoZVxuICAgICBpbnB1dCBidWZmZXIgaGFzIHJlYWNoZWQgYW4gZW5kIG9mIGZpbGUsIHRoZSBmdW5jdGlvbiByYWlzZXMgZXhjZXB0aW9uXG4gICAgIFtFbmRfb2ZfZmlsZV0uICopXG5cbiAgdmFsIHN0b3JlX2NoYXIgOiBpbnQgLT4gc2NhbmJ1ZiAtPiBjaGFyIC0+IGludFxuICAoKiBbU2Nhbm5pbmcuc3RvcmVfY2hhciBsaW0gaWIgY10gYWRkcyBbY10gdG8gdGhlIHRva2VuIGJ1ZmZlclxuICAgICBvZiB0aGUgc2Nhbm5pbmcgYnVmZmVyIFtpYl0uIEl0IGFsc28gYWR2YW5jZXMgdGhlIHNjYW5uaW5nIGJ1ZmZlciBmb3JcbiAgICAgb25lIGNoYXJhY3RlciBhbmQgcmV0dXJucyBbbGltIC0gMV0sIGluZGljYXRpbmcgdGhlIG5ldyBsaW1pdCBmb3IgdGhlXG4gICAgIGxlbmd0aCBvZiB0aGUgY3VycmVudCB0b2tlbi4gKilcblxuICB2YWwgc2tpcF9jaGFyIDogaW50IC0+IHNjYW5idWYgLT4gaW50XG4gICgqIFtTY2FubmluZy5za2lwX2NoYXIgbGltIGliXSBpZ25vcmVzIHRoZSBjdXJyZW50IGNoYXJhY3Rlci4gKilcblxuICB2YWwgaWdub3JlX2NoYXIgOiBpbnQgLT4gc2NhbmJ1ZiAtPiBpbnRcbiAgKCogW1NjYW5uaW5nLmlnbm9yZV9jaGFyIGliIGxpbV0gaWdub3JlcyB0aGUgY3VycmVudCBjaGFyYWN0ZXIgYW5kXG4gICAgIGRlY3JlbWVudHMgdGhlIGxpbWl0LiAqKVxuXG4gIHZhbCB0b2tlbiA6IHNjYW5idWYgLT4gc3RyaW5nXG4gICgqIFtTY2FubmluZy50b2tlbiBpYl0gcmV0dXJucyB0aGUgc3RyaW5nIHN0b3JlZCBpbnRvIHRoZSB0b2tlblxuICAgICBidWZmZXIgb2YgdGhlIHNjYW5uaW5nIGJ1ZmZlcjogaXQgcmV0dXJucyB0aGUgdG9rZW4gbWF0Y2hlZCBieSB0aGVcbiAgICAgZm9ybWF0LiAqKVxuXG4gIHZhbCByZXNldF90b2tlbiA6IHNjYW5idWYgLT4gdW5pdFxuICAoKiBbU2Nhbm5pbmcucmVzZXRfdG9rZW4gaWJdIHJlc2V0cyB0aGUgdG9rZW4gYnVmZmVyIG9mXG4gICAgIHRoZSBnaXZlbiBzY2FubmluZyBidWZmZXIuICopXG5cbiAgdmFsIGNoYXJfY291bnQgOiBzY2FuYnVmIC0+IGludFxuICAoKiBbU2Nhbm5pbmcuY2hhcl9jb3VudCBpYl0gcmV0dXJucyB0aGUgbnVtYmVyIG9mIGNoYXJhY3RlcnNcbiAgICAgcmVhZCBzbyBmYXIgZnJvbSB0aGUgZ2l2ZW4gYnVmZmVyLiAqKVxuXG4gIHZhbCBsaW5lX2NvdW50IDogc2NhbmJ1ZiAtPiBpbnRcbiAgKCogW1NjYW5uaW5nLmxpbmVfY291bnQgaWJdIHJldHVybnMgdGhlIG51bWJlciBvZiBuZXcgbGluZVxuICAgICBjaGFyYWN0ZXJzIHJlYWQgc28gZmFyIGZyb20gdGhlIGdpdmVuIGJ1ZmZlci4gKilcblxuICB2YWwgdG9rZW5fY291bnQgOiBzY2FuYnVmIC0+IGludFxuICAoKiBbU2Nhbm5pbmcudG9rZW5fY291bnQgaWJdIHJldHVybnMgdGhlIG51bWJlciBvZiB0b2tlbnMgcmVhZFxuICAgICBzbyBmYXIgZnJvbSBbaWJdLiAqKVxuXG4gIHZhbCBlb2YgOiBzY2FuYnVmIC0+IGJvb2xcbiAgKCogW1NjYW5uaW5nLmVvZiBpYl0gcmV0dXJucyB0aGUgZW5kIG9mIGlucHV0IGNvbmRpdGlvblxuICAgICBvZiB0aGUgZ2l2ZW4gYnVmZmVyLiAqKVxuXG4gIHZhbCBlbmRfb2ZfaW5wdXQgOiBzY2FuYnVmIC0+IGJvb2xcbiAgKCogW1NjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYl0gdGVzdHMgdGhlIGVuZCBvZiBpbnB1dCBjb25kaXRpb25cbiAgICAgb2YgdGhlIGdpdmVuIGJ1ZmZlciAoaWYgbm8gY2hhciBoYXMgZXZlciBiZWVuIHJlYWQsIGFuIGF0dGVtcHQgdG9cbiAgICAgcmVhZCBvbmUgaXMgcGVyZm9ybWVkKS4gKilcblxuICB2YWwgYmVnaW5uaW5nX29mX2lucHV0IDogc2NhbmJ1ZiAtPiBib29sXG4gICgqIFtTY2FubmluZy5iZWdpbm5pbmdfb2ZfaW5wdXQgaWJdIHRlc3RzIHRoZSBiZWdpbm5pbmcgb2YgaW5wdXRcbiAgICAgY29uZGl0aW9uIG9mIHRoZSBnaXZlbiBidWZmZXIuICopXG5cbiAgdmFsIG5hbWVfb2ZfaW5wdXQgOiBzY2FuYnVmIC0+IHN0cmluZ1xuICAoKiBbU2Nhbm5pbmcubmFtZV9vZl9pbnB1dCBpYl0gcmV0dXJucyB0aGUgbmFtZSBvZiB0aGUgY2hhcmFjdGVyXG4gICAgIHNvdXJjZSBmb3IgaW5wdXQgYnVmZmVyIFtpYl0uICopXG5cbiAgdmFsIG9wZW5faW4gOiBmaWxlX25hbWUgLT4gaW5fY2hhbm5lbFxuICB2YWwgb3Blbl9pbl9iaW4gOiBmaWxlX25hbWUgLT4gaW5fY2hhbm5lbFxuICB2YWwgZnJvbV9maWxlIDogZmlsZV9uYW1lIC0+IGluX2NoYW5uZWxcbiAgdmFsIGZyb21fZmlsZV9iaW4gOiBmaWxlX25hbWUgLT4gaW5fY2hhbm5lbFxuICB2YWwgZnJvbV9zdHJpbmcgOiBzdHJpbmcgLT4gaW5fY2hhbm5lbFxuICB2YWwgZnJvbV9mdW5jdGlvbiA6ICh1bml0IC0+IGNoYXIpIC0+IGluX2NoYW5uZWxcbiAgdmFsIGZyb21fY2hhbm5lbCA6IFN0ZGxpYi5pbl9jaGFubmVsIC0+IGluX2NoYW5uZWxcblxuICB2YWwgY2xvc2VfaW4gOiBpbl9jaGFubmVsIC0+IHVuaXRcblxuICB2YWwgbWVtb19mcm9tX2NoYW5uZWwgOiBTdGRsaWIuaW5fY2hhbm5lbCAtPiBpbl9jaGFubmVsXG4gICgqIE9ic29sZXRlLiAqKVxuXG5lbmRcblxuXG5tb2R1bGUgU2Nhbm5pbmcgOiBTQ0FOTklORyA9IHN0cnVjdFxuXG4gICgqIFRoZSBydW4tdGltZSBsaWJyYXJ5IGZvciBzY2FuZi4gKilcblxuICB0eXBlIGZpbGVfbmFtZSA9IHN0cmluZ1xuXG4gIHR5cGUgaW5fY2hhbm5lbF9uYW1lID1cbiAgICB8IEZyb21fY2hhbm5lbCBvZiBTdGRsaWIuaW5fY2hhbm5lbFxuICAgIHwgRnJvbV9maWxlIG9mIGZpbGVfbmFtZSAqIFN0ZGxpYi5pbl9jaGFubmVsXG4gICAgfCBGcm9tX2Z1bmN0aW9uXG4gICAgfCBGcm9tX3N0cmluZ1xuXG5cbiAgdHlwZSBpbl9jaGFubmVsID0ge1xuICAgIG11dGFibGUgaWNfZW9mIDogYm9vbDtcbiAgICBtdXRhYmxlIGljX2N1cnJlbnRfY2hhciA6IGNoYXI7XG4gICAgbXV0YWJsZSBpY19jdXJyZW50X2NoYXJfaXNfdmFsaWQgOiBib29sO1xuICAgIG11dGFibGUgaWNfY2hhcl9jb3VudCA6IGludDtcbiAgICBtdXRhYmxlIGljX2xpbmVfY291bnQgOiBpbnQ7XG4gICAgbXV0YWJsZSBpY190b2tlbl9jb3VudCA6IGludDtcbiAgICBtdXRhYmxlIGljX2dldF9uZXh0X2NoYXIgOiB1bml0IC0+IGNoYXI7XG4gICAgaWNfdG9rZW5fYnVmZmVyIDogQnVmZmVyLnQ7XG4gICAgaWNfaW5wdXRfbmFtZSA6IGluX2NoYW5uZWxfbmFtZTtcbiAgfVxuXG5cbiAgdHlwZSBzY2FuYnVmID0gaW5fY2hhbm5lbFxuXG4gIGxldCBudWxsX2NoYXIgPSAnXFwwMDAnXG5cbiAgKCogUmVhZHMgYSBuZXcgY2hhcmFjdGVyIGZyb20gaW5wdXQgYnVmZmVyLlxuICAgICBOZXh0X2NoYXIgbmV2ZXIgZmFpbHMsIGV2ZW4gaW4gY2FzZSBvZiBlbmQgb2YgaW5wdXQ6XG4gICAgIGl0IHRoZW4gc2ltcGx5IHNldHMgdGhlIGVuZCBvZiBmaWxlIGNvbmRpdGlvbi4gKilcbiAgbGV0IG5leHRfY2hhciBpYiA9XG4gICAgdHJ5XG4gICAgICBsZXQgYyA9IGliLmljX2dldF9uZXh0X2NoYXIgKCkgaW5cbiAgICAgIGliLmljX2N1cnJlbnRfY2hhciA8LSBjO1xuICAgICAgaWIuaWNfY3VycmVudF9jaGFyX2lzX3ZhbGlkIDwtIHRydWU7XG4gICAgICBpYi5pY19jaGFyX2NvdW50IDwtIHN1Y2MgaWIuaWNfY2hhcl9jb3VudDtcbiAgICAgIGlmIGMgPSAnXFxuJyB0aGVuIGliLmljX2xpbmVfY291bnQgPC0gc3VjYyBpYi5pY19saW5lX2NvdW50O1xuICAgICAgYyB3aXRoXG4gICAgfCBFbmRfb2ZfZmlsZSAtPlxuICAgICAgbGV0IGMgPSBudWxsX2NoYXIgaW5cbiAgICAgIGliLmljX2N1cnJlbnRfY2hhciA8LSBjO1xuICAgICAgaWIuaWNfY3VycmVudF9jaGFyX2lzX3ZhbGlkIDwtIGZhbHNlO1xuICAgICAgaWIuaWNfZW9mIDwtIHRydWU7XG4gICAgICBjXG5cblxuICBsZXQgcGVla19jaGFyIGliID1cbiAgICBpZiBpYi5pY19jdXJyZW50X2NoYXJfaXNfdmFsaWRcbiAgICB0aGVuIGliLmljX2N1cnJlbnRfY2hhclxuICAgIGVsc2UgbmV4dF9jaGFyIGliXG5cblxuICAoKiBSZXR1cm5zIGEgdmFsaWQgY3VycmVudCBjaGFyIGZvciB0aGUgaW5wdXQgYnVmZmVyLiBJbiBwYXJ0aWN1bGFyXG4gICAgIG5vIGlycmVsZXZhbnQgbnVsbCBjaGFyYWN0ZXIgKGFzIHNldCBieSBbbmV4dF9jaGFyXSBpbiBjYXNlIG9mIGVuZFxuICAgICBvZiBpbnB1dCkgaXMgcmV0dXJuZWQsIHNpbmNlIFtFbmRfb2ZfZmlsZV0gaXMgcmFpc2VkIHdoZW5cbiAgICAgW25leHRfY2hhcl0gc2V0cyB0aGUgZW5kIG9mIGZpbGUgY29uZGl0aW9uIHdoaWxlIHRyeWluZyB0byByZWFkIGFcbiAgICAgbmV3IGNoYXJhY3Rlci4gKilcbiAgbGV0IGNoZWNrZWRfcGVla19jaGFyIGliID1cbiAgICBsZXQgYyA9IHBlZWtfY2hhciBpYiBpblxuICAgIGlmIGliLmljX2VvZiB0aGVuIHJhaXNlIEVuZF9vZl9maWxlO1xuICAgIGNcblxuXG4gIGxldCBlbmRfb2ZfaW5wdXQgaWIgPVxuICAgIGlnbm9yZSAocGVla19jaGFyIGliKTtcbiAgICBpYi5pY19lb2ZcblxuXG4gIGxldCBlb2YgaWIgPSBpYi5pY19lb2ZcblxuICBsZXQgYmVnaW5uaW5nX29mX2lucHV0IGliID0gaWIuaWNfY2hhcl9jb3VudCA9IDBcblxuICBsZXQgbmFtZV9vZl9pbnB1dCBpYiA9XG4gICAgbWF0Y2ggaWIuaWNfaW5wdXRfbmFtZSB3aXRoXG4gICAgfCBGcm9tX2NoYW5uZWwgX2ljIC0+IFwidW5uYW1lZCBTdGRsaWIgaW5wdXQgY2hhbm5lbFwiXG4gICAgfCBGcm9tX2ZpbGUgKGZuYW1lLCBfaWMpIC0+IGZuYW1lXG4gICAgfCBGcm9tX2Z1bmN0aW9uIC0+IFwidW5uYW1lZCBmdW5jdGlvblwiXG4gICAgfCBGcm9tX3N0cmluZyAtPiBcInVubmFtZWQgY2hhcmFjdGVyIHN0cmluZ1wiXG5cblxuICBsZXQgY2hhcl9jb3VudCBpYiA9XG4gICAgaWYgaWIuaWNfY3VycmVudF9jaGFyX2lzX3ZhbGlkXG4gICAgdGhlbiBpYi5pY19jaGFyX2NvdW50IC0gMVxuICAgIGVsc2UgaWIuaWNfY2hhcl9jb3VudFxuXG5cbiAgbGV0IGxpbmVfY291bnQgaWIgPSBpYi5pY19saW5lX2NvdW50XG5cbiAgbGV0IHJlc2V0X3Rva2VuIGliID0gQnVmZmVyLnJlc2V0IGliLmljX3Rva2VuX2J1ZmZlclxuXG4gIGxldCBpbnZhbGlkYXRlX2N1cnJlbnRfY2hhciBpYiA9IGliLmljX2N1cnJlbnRfY2hhcl9pc192YWxpZCA8LSBmYWxzZVxuXG4gIGxldCB0b2tlbiBpYiA9XG4gICAgbGV0IHRva2VuX2J1ZmZlciA9IGliLmljX3Rva2VuX2J1ZmZlciBpblxuICAgIGxldCB0b2sgPSBCdWZmZXIuY29udGVudHMgdG9rZW5fYnVmZmVyIGluXG4gICAgQnVmZmVyLmNsZWFyIHRva2VuX2J1ZmZlcjtcbiAgICBpYi5pY190b2tlbl9jb3VudCA8LSBzdWNjIGliLmljX3Rva2VuX2NvdW50O1xuICAgIHRva1xuXG5cbiAgbGV0IHRva2VuX2NvdW50IGliID0gaWIuaWNfdG9rZW5fY291bnRcblxuICBsZXQgc2tpcF9jaGFyIHdpZHRoIGliID1cbiAgICBpbnZhbGlkYXRlX2N1cnJlbnRfY2hhciBpYjtcbiAgICB3aWR0aFxuXG5cbiAgbGV0IGlnbm9yZV9jaGFyIHdpZHRoIGliID0gc2tpcF9jaGFyICh3aWR0aCAtIDEpIGliXG5cbiAgbGV0IHN0b3JlX2NoYXIgd2lkdGggaWIgYyA9XG4gICAgQnVmZmVyLmFkZF9jaGFyIGliLmljX3Rva2VuX2J1ZmZlciBjO1xuICAgIGlnbm9yZV9jaGFyIHdpZHRoIGliXG5cblxuICBsZXQgZGVmYXVsdF90b2tlbl9idWZmZXJfc2l6ZSA9IDEwMjRcblxuICBsZXQgY3JlYXRlIGluYW1lIG5leHQgPSB7XG4gICAgaWNfZW9mID0gZmFsc2U7XG4gICAgaWNfY3VycmVudF9jaGFyID0gbnVsbF9jaGFyO1xuICAgIGljX2N1cnJlbnRfY2hhcl9pc192YWxpZCA9IGZhbHNlO1xuICAgIGljX2NoYXJfY291bnQgPSAwO1xuICAgIGljX2xpbmVfY291bnQgPSAwO1xuICAgIGljX3Rva2VuX2NvdW50ID0gMDtcbiAgICBpY19nZXRfbmV4dF9jaGFyID0gbmV4dDtcbiAgICBpY190b2tlbl9idWZmZXIgPSBCdWZmZXIuY3JlYXRlIGRlZmF1bHRfdG9rZW5fYnVmZmVyX3NpemU7XG4gICAgaWNfaW5wdXRfbmFtZSA9IGluYW1lO1xuICB9XG5cblxuICBsZXQgZnJvbV9zdHJpbmcgcyA9XG4gICAgbGV0IGkgPSByZWYgMCBpblxuICAgIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgICBsZXQgbmV4dCAoKSA9XG4gICAgICBpZiAhaSA+PSBsZW4gdGhlbiByYWlzZSBFbmRfb2ZfZmlsZSBlbHNlXG4gICAgICBsZXQgYyA9IHMuWyFpXSBpblxuICAgICAgaW5jciBpO1xuICAgICAgYyBpblxuICAgIGNyZWF0ZSBGcm9tX3N0cmluZyBuZXh0XG5cblxuICBsZXQgZnJvbV9mdW5jdGlvbiA9IGNyZWF0ZSBGcm9tX2Z1bmN0aW9uXG5cbiAgKCogU2Nhbm5pbmcgZnJvbSBhbiBpbnB1dCBjaGFubmVsLiAqKVxuXG4gICgqIFBvc2l0aW9uIG9mIHRoZSBwcm9ibGVtOlxuXG4gICAgIFdlIGNhbm5vdCBwcmV2ZW50IHRoZSBzY2FubmluZyBtZWNoYW5pc20gdG8gdXNlIG9uZSBsb29rYWhlYWQgY2hhcmFjdGVyLFxuICAgICBpZiBuZWVkZWQgYnkgdGhlIHNlbWFudGljcyBvZiB0aGUgZm9ybWF0IHN0cmluZyBzcGVjaWZpY2F0aW9ucyAoZS5nLiBhXG4gICAgIHRyYWlsaW5nICdza2lwIHNwYWNlJyBzcGVjaWZpY2F0aW9uIGluIHRoZSBmb3JtYXQgc3RyaW5nKTsgaW4gdGhpcyBjYXNlLFxuICAgICB0aGUgbWFuZGF0b3J5IGxvb2thaGVhZCBjaGFyYWN0ZXIgaXMgaW5kZWVkIHJlYWQgZnJvbSB0aGUgaW5wdXQgYW5kIG5vdFxuICAgICB1c2VkIHRvIHJldHVybiB0aGUgdG9rZW4gcmVhZC4gSXQgaXMgdGh1cyBtYW5kYXRvcnkgdG8gYmUgYWJsZSB0byBzdG9yZVxuICAgICBhbiB1bnVzZWQgbG9va2FoZWFkIGNoYXJhY3RlciBzb21ld2hlcmUgdG8gZ2V0IGl0IGFzIHRoZSBmaXJzdCBjaGFyYWN0ZXJcbiAgICAgb2YgdGhlIG5leHQgc2Nhbi5cblxuICAgICBUbyBjaXJjdW12ZW50IHRoaXMgcHJvYmxlbSwgYWxsIHRoZSBzY2FubmluZyBmdW5jdGlvbnMgZ2V0IGEgbG93IGxldmVsXG4gICAgIGlucHV0IGJ1ZmZlciBhcmd1bWVudCB3aGVyZSB0aGV5IHN0b3JlIHRoZSBsb29rYWhlYWQgY2hhcmFjdGVyIHdoZW5cbiAgICAgbmVlZGVkOyBhZGRpdGlvbmFsbHksIHRoZSBpbnB1dCBidWZmZXIgaXMgdGhlIG9ubHkgc291cmNlIG9mIGNoYXJhY3RlciBvZlxuICAgICBhIHNjYW5uZXIuIFRoZSBbc2NhbmJ1Zl0gaW5wdXQgYnVmZmVycyBhcmUgZGVmaW5lZCBpbiBtb2R1bGUgeyFTY2FubmluZ30uXG5cbiAgICAgTm93IHdlIHVuZGVyc3RhbmQgdGhhdCBpdCBpcyBleHRyZW1lbHkgaW1wb3J0YW50IHRoYXQgcmVsYXRlZCBhbmRcbiAgICAgc3VjY2Vzc2l2ZSBjYWxscyB0byBzY2FubmVycyBpbmRlZWQgcmVhZCBmcm9tIHRoZSBzYW1lIGlucHV0IGJ1ZmZlci5cbiAgICAgSW4gZWZmZWN0LCBpZiBhIHNjYW5uZXIgW3NjYW4xXSBpcyByZWFkaW5nIGZyb20gW2liMV0gYW5kIHN0b3JlcyBhblxuICAgICB1bnVzZWQgbG9va2FoZWFkIGNoYXJhY3RlciBbYzFdIGludG8gaXRzIGlucHV0IGJ1ZmZlciBbaWIxXSwgdGhlblxuICAgICBhbm90aGVyIHNjYW5uZXIgW3NjYW4yXSBub3QgcmVhZGluZyBmcm9tIHRoZSBzYW1lIGJ1ZmZlciBbaWIxXSB3aWxsIG1pc3NcbiAgICAgdGhlIGNoYXJhY3RlciBbYzFdLCBzZWVtaW5nbHkgdmFuaXNoZWQgaW4gdGhlIGFpciBmcm9tIHRoZSBwb2ludCBvZiB2aWV3XG4gICAgIG9mIFtzY2FuMl0uXG5cbiAgICAgVGhpcyBtZWNoYW5pc20gd29ya3MgcGVyZmVjdGx5IHRvIHJlYWQgZnJvbSBzdHJpbmdzLCBmcm9tIGZpbGVzLCBhbmQgZnJvbVxuICAgICBmdW5jdGlvbnMsIHNpbmNlIGluIHRob3NlIGNhc2VzLCBhbGxvY2F0aW5nIHR3byBidWZmZXJzIHJlYWRpbmcgZnJvbSB0aGVcbiAgICAgc2FtZSBzb3VyY2UgaXMgdW5uYXR1cmFsLlxuXG4gICAgIFN0aWxsLCB0aGVyZSBpcyBhIGRpZmZpY3VsdHkgaW4gdGhlIGNhc2Ugb2Ygc2Nhbm5pbmcgZnJvbSBhbiBpbnB1dFxuICAgICBjaGFubmVsLiBJbiBlZmZlY3QsIHdoZW4gc2Nhbm5pbmcgZnJvbSBhbiBpbnB1dCBjaGFubmVsIFtpY10sIHRoaXMgY2hhbm5lbFxuICAgICBtYXkgbm90IGhhdmUgYmVlbiBhbGxvY2F0ZWQgZnJvbSB3aXRoaW4gdGhpcyBsaWJyYXJ5LiBIZW5jZSwgaXQgbWF5IGJlXG4gICAgIHNoYXJlZCAodHdvIGZ1bmN0aW9ucyBvZiB0aGUgdXNlcidzIHByb2dyYW0gbWF5IHN1Y2Nlc3NpdmVseSByZWFkIGZyb21cbiAgICAgW2ljXSkuIFRoaXMgaXMgaGlnaGx5IGVycm9yIHByb25lIHNpbmNlLCBvbmUgb2YgdGhlIGZ1bmN0aW9uIG1heSBzZWVrIHRoZVxuICAgICBpbnB1dCBjaGFubmVsLCB3aGlsZSB0aGUgb3RoZXIgZnVuY3Rpb24gaGFzIHN0aWxsIGFuIHVudXNlZCBsb29rYWhlYWRcbiAgICAgY2hhcmFjdGVyIGluIGl0cyBpbnB1dCBidWZmZXIuIEluIGNvbmNsdXNpb24sIHlvdSBzaG91bGQgbmV2ZXIgbWl4IGRpcmVjdFxuICAgICBsb3cgbGV2ZWwgcmVhZGluZyBhbmQgaGlnaCBsZXZlbCBzY2FubmluZyBmcm9tIHRoZSBzYW1lIGlucHV0IGNoYW5uZWwuXG5cbiAgKilcblxuICAoKiBQZXJmb3JtIGJ1ZmZlcml6ZWQgaW5wdXQgdG8gaW1wcm92ZSBlZmZpY2llbmN5LiAqKVxuICBsZXQgZmlsZV9idWZmZXJfc2l6ZSA9IHJlZiAxMDI0XG5cbiAgKCogVGhlIHNjYW5uZXIgY2xvc2VzIHRoZSBpbnB1dCBjaGFubmVsIGF0IGVuZCBvZiBpbnB1dC4gKilcbiAgbGV0IHNjYW5fY2xvc2VfYXRfZW5kIGljID0gU3RkbGliLmNsb3NlX2luIGljOyByYWlzZSBFbmRfb2ZfZmlsZVxuXG4gICgqIFRoZSBzY2FubmVyIGRvZXMgbm90IGNsb3NlIHRoZSBpbnB1dCBjaGFubmVsIGF0IGVuZCBvZiBpbnB1dDpcbiAgICAgaXQganVzdCByYWlzZXMgW0VuZF9vZl9maWxlXS4gKilcbiAgbGV0IHNjYW5fcmFpc2VfYXRfZW5kIF9pYyA9IHJhaXNlIEVuZF9vZl9maWxlXG5cbiAgbGV0IGZyb21faWMgc2Nhbl9jbG9zZV9pYyBpbmFtZSBpYyA9XG4gICAgbGV0IGxlbiA9ICFmaWxlX2J1ZmZlcl9zaXplIGluXG4gICAgbGV0IGJ1ZiA9IEJ5dGVzLmNyZWF0ZSBsZW4gaW5cbiAgICBsZXQgaSA9IHJlZiAwIGluXG4gICAgbGV0IGxpbSA9IHJlZiAwIGluXG4gICAgbGV0IGVvZiA9IHJlZiBmYWxzZSBpblxuICAgIGxldCBuZXh0ICgpID1cbiAgICAgIGlmICFpIDwgIWxpbSB0aGVuIGJlZ2luIGxldCBjID0gQnl0ZXMuZ2V0IGJ1ZiAhaSBpbiBpbmNyIGk7IGMgZW5kIGVsc2VcbiAgICAgIGlmICFlb2YgdGhlbiByYWlzZSBFbmRfb2ZfZmlsZSBlbHNlIGJlZ2luXG4gICAgICAgIGxpbSA6PSBpbnB1dCBpYyBidWYgMCBsZW47XG4gICAgICAgIGlmICFsaW0gPSAwIHRoZW4gYmVnaW4gZW9mIDo9IHRydWU7IHNjYW5fY2xvc2VfaWMgaWMgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgICBpIDo9IDE7XG4gICAgICAgICAgQnl0ZXMuZ2V0IGJ1ZiAwXG4gICAgICAgIGVuZFxuICAgICAgZW5kIGluXG4gICAgY3JlYXRlIGluYW1lIG5leHRcblxuXG4gIGxldCBmcm9tX2ljX2Nsb3NlX2F0X2VuZCA9IGZyb21faWMgc2Nhbl9jbG9zZV9hdF9lbmRcbiAgbGV0IGZyb21faWNfcmFpc2VfYXRfZW5kID0gZnJvbV9pYyBzY2FuX3JhaXNlX2F0X2VuZFxuXG4gICgqIFRoZSBzY2FubmluZyBidWZmZXIgcmVhZGluZyBmcm9tIFtTdGRsaWIuc3RkaW5dLlxuICAgICBPbmUgY291bGQgdHJ5IHRvIGRlZmluZSBbc3RkaWJdIGFzIGEgc2Nhbm5pbmcgYnVmZmVyIHJlYWRpbmcgYSBjaGFyYWN0ZXJcbiAgICAgYXQgYSB0aW1lIChubyBidWZmZXJpemF0aW9uIGF0IGFsbCksIGJ1dCB1bmZvcnR1bmF0ZWx5IHRoZSB0b3AtbGV2ZWxcbiAgICAgaW50ZXJhY3Rpb24gd291bGQgYmUgd3JvbmcuIFRoaXMgaXMgZHVlIHRvIHNvbWUga2luZCBvZlxuICAgICAncmFjZSBjb25kaXRpb24nIHdoZW4gcmVhZGluZyBmcm9tIFtTdGRsaWIuc3RkaW5dLFxuICAgICBzaW5jZSB0aGUgaW50ZXJhY3RpdmUgY29tcGlsZXIgYW5kIFtTY2FuZi5zY2FuZl0gd2lsbCBzaW11bHRhbmVvdXNseVxuICAgICByZWFkIHRoZSBtYXRlcmlhbCB0aGV5IG5lZWQgZnJvbSBbU3RkbGliLnN0ZGluXTsgdGhlbiwgY29uZnVzaW9uXG4gICAgIHdpbGwgcmVzdWx0IGZyb20gd2hhdCBzaG91bGQgYmUgcmVhZCBieSB0aGUgdG9wLWxldmVsIGFuZCB3aGF0IHNob3VsZCBiZVxuICAgICByZWFkIGJ5IFtTY2FuZi5zY2FuZl0uXG4gICAgIFRoaXMgaXMgZXZlbiBtb3JlIGNvbXBsaWNhdGVkIGJ5IHRoZSBvbmUgY2hhcmFjdGVyIGxvb2thaGVhZCB0aGF0XG4gICAgIFtTY2FuZi5zY2FuZl0gaXMgc29tZXRpbWVzIG9ibGlnZWQgdG8gbWFpbnRhaW46IHRoZSBsb29rYWhlYWQgY2hhcmFjdGVyXG4gICAgIHdpbGwgYmUgYXZhaWxhYmxlIGZvciB0aGUgbmV4dCBbU2NhbmYuc2NhbmZdIGVudHJ5LCBzZWVtaW5nbHkgY29taW5nIGZyb21cbiAgICAgbm93aGVyZS5cbiAgICAgQWxzbyBubyBbRW5kX29mX2ZpbGVdIGlzIHJhaXNlZCB3aGVuIHJlYWRpbmcgZnJvbSBzdGRpbjogaWYgbm90IGVub3VnaFxuICAgICBjaGFyYWN0ZXJzIGhhdmUgYmVlbiByZWFkLCB3ZSBzaW1wbHkgYXNrIHRvIHJlYWQgbW9yZS4gKilcbiAgbGV0IHN0ZGluID1cbiAgICBmcm9tX2ljIHNjYW5fcmFpc2VfYXRfZW5kXG4gICAgICAoRnJvbV9maWxlIChcIi1cIiwgU3RkbGliLnN0ZGluKSkgU3RkbGliLnN0ZGluXG5cblxuICBsZXQgc3RkaWIgPSBzdGRpblxuXG4gIGxldCBvcGVuX2luX2ZpbGUgb3Blbl9pbiBmbmFtZSA9XG4gICAgbWF0Y2ggZm5hbWUgd2l0aFxuICAgIHwgXCItXCIgLT4gc3RkaW5cbiAgICB8IGZuYW1lIC0+XG4gICAgICBsZXQgaWMgPSBvcGVuX2luIGZuYW1lIGluXG4gICAgICBmcm9tX2ljX2Nsb3NlX2F0X2VuZCAoRnJvbV9maWxlIChmbmFtZSwgaWMpKSBpY1xuXG5cbiAgbGV0IG9wZW5faW4gPSBvcGVuX2luX2ZpbGUgU3RkbGliLm9wZW5faW5cbiAgbGV0IG9wZW5faW5fYmluID0gb3Blbl9pbl9maWxlIFN0ZGxpYi5vcGVuX2luX2JpblxuXG4gIGxldCBmcm9tX2ZpbGUgPSBvcGVuX2luXG4gIGxldCBmcm9tX2ZpbGVfYmluID0gb3Blbl9pbl9iaW5cblxuICBsZXQgZnJvbV9jaGFubmVsIGljID1cbiAgICBmcm9tX2ljX3JhaXNlX2F0X2VuZCAoRnJvbV9jaGFubmVsIGljKSBpY1xuXG5cbiAgbGV0IGNsb3NlX2luIGliID1cbiAgICBtYXRjaCBpYi5pY19pbnB1dF9uYW1lIHdpdGhcbiAgICB8IEZyb21fY2hhbm5lbCBpYyAtPlxuICAgICAgU3RkbGliLmNsb3NlX2luIGljXG4gICAgfCBGcm9tX2ZpbGUgKF9mbmFtZSwgaWMpIC0+IFN0ZGxpYi5jbG9zZV9pbiBpY1xuICAgIHwgRnJvbV9mdW5jdGlvbiB8IEZyb21fc3RyaW5nIC0+ICgpXG5cblxuICAoKlxuICAgICBPYnNvbGV0ZTogYSBtZW1vIFtmcm9tX2NoYW5uZWxdIHZlcnNpb24gdG8gYnVpbGQgYSBbU2Nhbm5pbmcuaW5fY2hhbm5lbF1cbiAgICAgc2Nhbm5pbmcgYnVmZmVyIG91dCBvZiBhIFtTdGRsaWIuaW5fY2hhbm5lbF0uXG4gICAgIFRoaXMgZnVuY3Rpb24gd2FzIHVzZWQgdG8gdHJ5IHRvIHByZXNlcnZlIHRoZSBzY2FubmluZ1xuICAgICBzZW1hbnRpY3MgZm9yIHRoZSAobm93IG9ic29sZXRlKSBmdW5jdGlvbiBbZnNjYW5mXS5cbiAgICAgR2l2ZW4gdGhhdCBhbGwgc2Nhbm5lciBtdXN0IHJlYWQgZnJvbSBhIFtTY2FubmluZy5pbl9jaGFubmVsXSBzY2FubmluZ1xuICAgICBidWZmZXIsIFtmc2NhbmZdIG11c3QgcmVhZCBmcm9tIG9uZSFcbiAgICAgTW9yZSBwcmVjaXNlbHksIGdpdmVuIFtpY10sIGFsbCBzdWNjZXNzaXZlIGNhbGxzIFtmc2NhbmYgaWNdIG11c3QgcmVhZFxuICAgICBmcm9tIHRoZSBzYW1lIHNjYW5uaW5nIGJ1ZmZlci5cbiAgICAgVGhpcyBvYmxpZ2VkIHRoaXMgbGlicmFyeSB0byBhbGxvY2F0ZWQgc2Nhbm5pbmcgYnVmZmVycyB0aGF0IHdlcmVcbiAgICAgbm90IHByb3Blcmx5IGdhcmJhZ2UgY29sbGVjdGFibGUsIGhlbmNlIGxlYWRpbmcgdG8gbWVtb3J5IGxlYWtzLlxuICAgICBJZiB5b3UgbmVlZCB0byByZWFkIGZyb20gYSBbU3RkbGliLmluX2NoYW5uZWxdIGlucHV0IGNoYW5uZWxcbiAgICAgW2ljXSwgc2ltcGx5IGRlZmluZSBhIFtTY2FubmluZy5pbl9jaGFubmVsXSBmb3JtYXR0ZWQgaW5wdXQgY2hhbm5lbCBhcyBpblxuICAgICBbbGV0IGliID0gU2Nhbm5pbmcuZnJvbV9jaGFubmVsIGljXSwgdGhlbiB1c2UgW1NjYW5mLmJzY2FuZiBpYl0gYXMgdXN1YWwuXG4gICopXG4gIGxldCBtZW1vX2Zyb21faWMgPVxuICAgIGxldCBtZW1vID0gcmVmIFtdIGluXG4gICAgKGZ1biBzY2FuX2Nsb3NlX2ljIGljIC0+XG4gICAgIHRyeSBMaXN0LmFzc3EgaWMgIW1lbW8gd2l0aFxuICAgICB8IE5vdF9mb3VuZCAtPlxuICAgICAgIGxldCBpYiA9XG4gICAgICAgICBmcm9tX2ljIHNjYW5fY2xvc2VfaWMgKEZyb21fY2hhbm5lbCBpYykgaWMgaW5cbiAgICAgICBtZW1vIDo9IChpYywgaWIpIDo6ICFtZW1vO1xuICAgICAgIGliKVxuXG5cbiAgKCogT2Jzb2xldGU6IHNlZSB7IW1lbW9fZnJvbV9pY30gYWJvdmUuICopXG4gIGxldCBtZW1vX2Zyb21fY2hhbm5lbCA9IG1lbW9fZnJvbV9pYyBzY2FuX3JhaXNlX2F0X2VuZFxuXG5lbmRcblxuXG4oKiBGb3JtYXR0ZWQgaW5wdXQgZnVuY3Rpb25zLiAqKVxuXG50eXBlICgnYSwgJ2IsICdjLCAnZCkgc2Nhbm5lciA9XG4gICAgICgnYSwgU2Nhbm5pbmcuaW5fY2hhbm5lbCwgJ2IsICdjLCAnYSAtPiAnZCwgJ2QpIGZvcm1hdDYgLT4gJ2NcblxuXG4oKiBSZXBvcnRpbmcgZXJyb3JzLiAqKVxuZXhjZXB0aW9uIFNjYW5fZmFpbHVyZSBvZiBzdHJpbmdcblxubGV0IGJhZF9pbnB1dCBzID0gcmFpc2UgKFNjYW5fZmFpbHVyZSBzKVxuXG5sZXQgYmFkX2lucHV0X2VzY2FwZSBjID1cbiAgYmFkX2lucHV0IChQcmludGYuc3ByaW50ZiBcImlsbGVnYWwgZXNjYXBlIGNoYXJhY3RlciAlQ1wiIGMpXG5cblxubGV0IGJhZF90b2tlbl9sZW5ndGggbWVzc2FnZSA9XG4gIGJhZF9pbnB1dFxuICAgIChQcmludGYuc3ByaW50ZlxuICAgICAgIFwic2Nhbm5pbmcgb2YgJXMgZmFpbGVkOiBcXFxuICAgICAgICB0aGUgc3BlY2lmaWVkIGxlbmd0aCB3YXMgdG9vIHNob3J0IGZvciB0b2tlblwiXG4gICAgICAgbWVzc2FnZSlcblxuXG5sZXQgYmFkX2VuZF9vZl9pbnB1dCBtZXNzYWdlID1cbiAgYmFkX2lucHV0XG4gICAgKFByaW50Zi5zcHJpbnRmXG4gICAgICAgXCJzY2FubmluZyBvZiAlcyBmYWlsZWQ6IFxcXG4gICAgICAgIHByZW1hdHVyZSBlbmQgb2YgZmlsZSBvY2N1cnJlZCBiZWZvcmUgZW5kIG9mIHRva2VuXCJcbiAgICAgICBtZXNzYWdlKVxuXG5cbmxldCBiYWRfZmxvYXQgKCkgPVxuICBiYWRfaW5wdXQgXCJubyBkb3Qgb3IgZXhwb25lbnQgcGFydCBmb3VuZCBpbiBmbG9hdCB0b2tlblwiXG5cblxubGV0IGJhZF9oZXhfZmxvYXQgKCkgPVxuICBiYWRfaW5wdXQgXCJub3QgYSB2YWxpZCBmbG9hdCBpbiBoZXhhZGVjaW1hbCBub3RhdGlvblwiXG5cblxubGV0IGNoYXJhY3Rlcl9taXNtYXRjaF9lcnIgYyBjaSA9XG4gIFByaW50Zi5zcHJpbnRmIFwibG9va2luZyBmb3IgJUMsIGZvdW5kICVDXCIgYyBjaVxuXG5cbmxldCBjaGFyYWN0ZXJfbWlzbWF0Y2ggYyBjaSA9XG4gIGJhZF9pbnB1dCAoY2hhcmFjdGVyX21pc21hdGNoX2VyciBjIGNpKVxuXG5cbmxldCByZWMgc2tpcF93aGl0ZXMgaWIgPVxuICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICBpZiBub3QgKFNjYW5uaW5nLmVvZiBpYikgdGhlbiBiZWdpblxuICAgIG1hdGNoIGMgd2l0aFxuICAgIHwgJyAnIHwgJ1xcdCcgfCAnXFxuJyB8ICdcXHInIC0+XG4gICAgICBTY2FubmluZy5pbnZhbGlkYXRlX2N1cnJlbnRfY2hhciBpYjsgc2tpcF93aGl0ZXMgaWJcbiAgICB8IF8gLT4gKClcbiAgZW5kXG5cblxuKCogQ2hlY2tpbmcgdGhhdCBbY10gaXMgaW5kZWVkIGluIHRoZSBpbnB1dCwgdGhlbiBza2lwcyBpdC5cbiAgIEluIHRoaXMgY2FzZSwgdGhlIGNoYXJhY3RlciBbY10gaGFzIGJlZW4gZXhwbGljaXRseSBzcGVjaWZpZWQgaW4gdGhlXG4gICBmb3JtYXQgYXMgYmVpbmcgbWFuZGF0b3J5IGluIHRoZSBpbnB1dDsgaGVuY2Ugd2Ugc2hvdWxkIGZhaWwgd2l0aFxuICAgW0VuZF9vZl9maWxlXSBpbiBjYXNlIG9mIGVuZF9vZl9pbnB1dC5cbiAgIChSZW1lbWJlciB0aGF0IFtTY2FuX2ZhaWx1cmVdIGlzIHJhaXNlZCBvbmx5IHdoZW4gKHdlIGNhbiBwcm92ZSBieVxuICAgZXZpZGVuY2UpIHRoYXQgdGhlIGlucHV0IGRvZXMgbm90IG1hdGNoIHRoZSBmb3JtYXQgc3RyaW5nIGdpdmVuLiBXZSBtdXN0XG4gICB0aHVzIGRpZmZlcmVudGlhdGUgW0VuZF9vZl9maWxlXSBhcyBhbiBlcnJvciBkdWUgdG8gbGFjayBvZiBpbnB1dCwgYW5kXG4gICBbU2Nhbl9mYWlsdXJlXSB3aGljaCBpcyBkdWUgdG8gcHJvdmFibHkgd3JvbmcgaW5wdXQuIEkgYW0gbm90IHN1cmUgdGhpcyBpc1xuICAgd29ydGggdGhlIGJ1cmRlbjogaXQgaXMgY29tcGxleCBhbmQgc29tZWhvdyBzdWJsaW1pbmFsOyBzaG91bGQgYmUgY2xlYXJlclxuICAgdG8gZmFpbCB3aXRoIFNjYW5fZmFpbHVyZSBcIk5vdCBlbm91Z2ggaW5wdXQgdG8gY29tcGxldGUgc2Nhbm5pbmdcIiEpXG5cbiAgIFRoYXQncyB3aHksIHdhaXRpbmcgZm9yIGEgYmV0dGVyIHNvbHV0aW9uLCB3ZSB1c2UgY2hlY2tlZF9wZWVrX2NoYXIgaGVyZS5cbiAgIFdlIGFyZSBhbHNvIGNhcmVmdWwgdG8gdHJlYXQgXCJcXHJcXG5cIiBpbiB0aGUgaW5wdXQgYXMgYW4gZW5kIG9mIGxpbmUgbWFya2VyOlxuICAgaXQgYWx3YXlzIG1hdGNoZXMgYSAnXFxuJyBzcGVjaWZpY2F0aW9uIGluIHRoZSBpbnB1dCBmb3JtYXQgc3RyaW5nLiAqKVxubGV0IHJlYyBjaGVja19jaGFyIGliIGMgPVxuICBtYXRjaCBjIHdpdGhcbiAgfCAnICcgLT4gc2tpcF93aGl0ZXMgaWJcbiAgfCAnXFxuJyAtPiBjaGVja19uZXdsaW5lIGliXG4gIHwgYyAtPiBjaGVja190aGlzX2NoYXIgaWIgY1xuXG5hbmQgY2hlY2tfdGhpc19jaGFyIGliIGMgPVxuICBsZXQgY2kgPSBTY2FubmluZy5jaGVja2VkX3BlZWtfY2hhciBpYiBpblxuICBpZiBjaSA9IGMgdGhlbiBTY2FubmluZy5pbnZhbGlkYXRlX2N1cnJlbnRfY2hhciBpYiBlbHNlXG4gIGNoYXJhY3Rlcl9taXNtYXRjaCBjIGNpXG5cbmFuZCBjaGVja19uZXdsaW5lIGliID1cbiAgbGV0IGNpID0gU2Nhbm5pbmcuY2hlY2tlZF9wZWVrX2NoYXIgaWIgaW5cbiAgbWF0Y2ggY2kgd2l0aFxuICB8ICdcXG4nIC0+IFNjYW5uaW5nLmludmFsaWRhdGVfY3VycmVudF9jaGFyIGliXG4gIHwgJ1xccicgLT4gU2Nhbm5pbmcuaW52YWxpZGF0ZV9jdXJyZW50X2NoYXIgaWI7IGNoZWNrX3RoaXNfY2hhciBpYiAnXFxuJ1xuICB8IF8gLT4gY2hhcmFjdGVyX21pc21hdGNoICdcXG4nIGNpXG5cblxuKCogRXh0cmFjdGluZyB0b2tlbnMgZnJvbSB0aGUgb3V0cHV0IHRva2VuIGJ1ZmZlci4gKilcblxubGV0IHRva2VuX2NoYXIgaWIgPSAoU2Nhbm5pbmcudG9rZW4gaWIpLlswXVxuXG5sZXQgdG9rZW5fc3RyaW5nID0gU2Nhbm5pbmcudG9rZW5cblxubGV0IHRva2VuX2Jvb2wgaWIgPVxuICBtYXRjaCBTY2FubmluZy50b2tlbiBpYiB3aXRoXG4gIHwgXCJ0cnVlXCIgLT4gdHJ1ZVxuICB8IFwiZmFsc2VcIiAtPiBmYWxzZVxuICB8IHMgLT4gYmFkX2lucHV0IChQcmludGYuc3ByaW50ZiBcImludmFsaWQgYm9vbGVhbiAnJXMnXCIgcylcblxuXG4oKiBUaGUgdHlwZSBvZiBpbnRlZ2VyIGNvbnZlcnNpb25zLiAqKVxudHlwZSBpbnRlZ2VyX2NvbnZlcnNpb24gPVxuICB8IEJfY29udmVyc2lvbiAoKiBVbnNpZ25lZCBiaW5hcnkgY29udmVyc2lvbiAqKVxuICB8IERfY29udmVyc2lvbiAoKiBTaWduZWQgZGVjaW1hbCBjb252ZXJzaW9uICopXG4gIHwgSV9jb252ZXJzaW9uICgqIFNpZ25lZCBpbnRlZ2VyIGNvbnZlcnNpb24gKilcbiAgfCBPX2NvbnZlcnNpb24gKCogVW5zaWduZWQgb2N0YWwgY29udmVyc2lvbiAqKVxuICB8IFVfY29udmVyc2lvbiAoKiBVbnNpZ25lZCBkZWNpbWFsIGNvbnZlcnNpb24gKilcbiAgfCBYX2NvbnZlcnNpb24gKCogVW5zaWduZWQgaGV4YWRlY2ltYWwgY29udmVyc2lvbiAqKVxuXG5cbmxldCBpbnRlZ2VyX2NvbnZlcnNpb25fb2ZfY2hhciA9IGZ1bmN0aW9uXG4gIHwgJ2InIC0+IEJfY29udmVyc2lvblxuICB8ICdkJyAtPiBEX2NvbnZlcnNpb25cbiAgfCAnaScgLT4gSV9jb252ZXJzaW9uXG4gIHwgJ28nIC0+IE9fY29udmVyc2lvblxuICB8ICd1JyAtPiBVX2NvbnZlcnNpb25cbiAgfCAneCcgfCAnWCcgLT4gWF9jb252ZXJzaW9uXG4gIHwgXyAtPiBhc3NlcnQgZmFsc2VcblxuXG4oKiBFeHRyYWN0IGFuIGludGVnZXIgbGl0ZXJhbCB0b2tlbi5cbiAgIFNpbmNlIHRoZSBmdW5jdGlvbnMgU3RkbGliLippbnQqX29mX3N0cmluZyBkbyBub3QgYWNjZXB0IGEgbGVhZGluZyArLFxuICAgd2Ugc2tpcCBpdCBpZiBuZWNlc3NhcnkuICopXG5sZXQgdG9rZW5faW50X2xpdGVyYWwgY29udiBpYiA9XG4gIGxldCB0b2sgPVxuICAgIG1hdGNoIGNvbnYgd2l0aFxuICAgIHwgRF9jb252ZXJzaW9uIHwgSV9jb252ZXJzaW9uIC0+IFNjYW5uaW5nLnRva2VuIGliXG4gICAgfCBVX2NvbnZlcnNpb24gLT4gXCIwdVwiIF4gU2Nhbm5pbmcudG9rZW4gaWJcbiAgICB8IE9fY29udmVyc2lvbiAtPiBcIjBvXCIgXiBTY2FubmluZy50b2tlbiBpYlxuICAgIHwgWF9jb252ZXJzaW9uIC0+IFwiMHhcIiBeIFNjYW5uaW5nLnRva2VuIGliXG4gICAgfCBCX2NvbnZlcnNpb24gLT4gXCIwYlwiIF4gU2Nhbm5pbmcudG9rZW4gaWIgaW5cbiAgbGV0IGwgPSBTdHJpbmcubGVuZ3RoIHRvayBpblxuICBpZiBsID0gMCB8fCB0b2suWzBdIDw+ICcrJyB0aGVuIHRvayBlbHNlIFN0cmluZy5zdWIgdG9rIDEgKGwgLSAxKVxuXG5cbigqIEFsbCB0aGUgZnVuY3Rpb25zIHRoYXQgY29udmVydCBhIHN0cmluZyB0byBhIG51bWJlciByYWlzZSB0aGUgZXhjZXB0aW9uXG4gICBGYWlsdXJlIHdoZW4gdGhlIGNvbnZlcnNpb24gaXMgbm90IHBvc3NpYmxlLlxuICAgVGhpcyBleGNlcHRpb24gaXMgdGhlbiB0cmFwcGVkIGluIFtrc2NhbmZdLiAqKVxubGV0IHRva2VuX2ludCBjb252IGliID0gaW50X29mX3N0cmluZyAodG9rZW5faW50X2xpdGVyYWwgY29udiBpYilcblxubGV0IHRva2VuX2Zsb2F0IGliID0gZmxvYXRfb2Zfc3RyaW5nIChTY2FubmluZy50b2tlbiBpYilcblxuKCogVG8gc2NhbiBuYXRpdmUgaW50cywgaW50MzIgYW5kIGludDY0IGludGVnZXJzLlxuICAgV2UgY2Fubm90IGFjY2VzcyB0byBjb252ZXJzaW9ucyB0by9mcm9tIHN0cmluZ3MgZm9yIHRob3NlIHR5cGVzLFxuICAgTmF0aXZlaW50Lm9mX3N0cmluZywgSW50MzIub2Zfc3RyaW5nLCBhbmQgSW50NjQub2Zfc3RyaW5nLFxuICAgc2luY2UgdGhvc2UgbW9kdWxlcyBhcmUgbm90IGF2YWlsYWJsZSB0byBbU2NhbmZdLlxuICAgSG93ZXZlciwgd2UgY2FuIGJpbmQgYW5kIHVzZSB0aGUgY29ycmVzcG9uZGluZyBwcmltaXRpdmVzIHRoYXQgYXJlXG4gICBhdmFpbGFibGUgaW4gdGhlIHJ1bnRpbWUuICopXG5leHRlcm5hbCBuYXRpdmVpbnRfb2Zfc3RyaW5nIDogc3RyaW5nIC0+IG5hdGl2ZWludFxuICA9IFwiY2FtbF9uYXRpdmVpbnRfb2Zfc3RyaW5nXCJcblxuZXh0ZXJuYWwgaW50MzJfb2Zfc3RyaW5nIDogc3RyaW5nIC0+IGludDMyXG4gID0gXCJjYW1sX2ludDMyX29mX3N0cmluZ1wiXG5cbmV4dGVybmFsIGludDY0X29mX3N0cmluZyA6IHN0cmluZyAtPiBpbnQ2NFxuICA9IFwiY2FtbF9pbnQ2NF9vZl9zdHJpbmdcIlxuXG5cbmxldCB0b2tlbl9uYXRpdmVpbnQgY29udiBpYiA9IG5hdGl2ZWludF9vZl9zdHJpbmcgKHRva2VuX2ludF9saXRlcmFsIGNvbnYgaWIpXG5sZXQgdG9rZW5faW50MzIgY29udiBpYiA9IGludDMyX29mX3N0cmluZyAodG9rZW5faW50X2xpdGVyYWwgY29udiBpYilcbmxldCB0b2tlbl9pbnQ2NCBjb252IGliID0gaW50NjRfb2Zfc3RyaW5nICh0b2tlbl9pbnRfbGl0ZXJhbCBjb252IGliKVxuXG4oKiBTY2FubmluZyBudW1iZXJzLiAqKVxuXG4oKiBEaWdpdHMgc2Nhbm5pbmcgZnVuY3Rpb25zIHN1cHBvc2UgdGhhdCBvbmUgY2hhcmFjdGVyIGhhcyBiZWVuIGNoZWNrZWQgYW5kXG4gICBpcyBhdmFpbGFibGUsIHNpbmNlIHRoZXkgcmV0dXJuIGF0IGVuZCBvZiBmaWxlIHdpdGggdGhlIGN1cnJlbnRseSBmb3VuZFxuICAgdG9rZW4gc2VsZWN0ZWQuXG5cbiAgIFB1dCBpdCBpbiBhbm90aGVyIHdheSwgdGhlIGRpZ2l0cyBzY2FubmluZyBmdW5jdGlvbnMgc2NhbiBmb3IgYSBwb3NzaWJseVxuICAgZW1wdHkgc2VxdWVuY2Ugb2YgZGlnaXRzLCAoaGVuY2UsIGEgc3VjY2Vzc2Z1bCBzY2FubmluZyBmcm9tIG9uZSBvZiB0aG9zZVxuICAgZnVuY3Rpb25zIGRvZXMgbm90IGltcGx5IHRoYXQgdGhlIHRva2VuIGlzIGEgd2VsbC1mb3JtZWQgbnVtYmVyOiB0byBnZXQgYVxuICAgdHJ1ZSBudW1iZXIsIGl0IGlzIG1hbmRhdG9yeSB0byBjaGVjayB0aGF0IGF0IGxlYXN0IG9uZSB2YWxpZCBkaWdpdCBpc1xuICAgYXZhaWxhYmxlIGJlZm9yZSBjYWxsaW5nIG9uZSBvZiB0aGUgZGlnaXQgc2Nhbm5pbmcgZnVuY3Rpb25zKS4gKilcblxuKCogVGhlIGRlY2ltYWwgY2FzZSBpcyB0cmVhdGVkIGVzcGVjaWFsbHkgZm9yIG9wdGltaXphdGlvbiBwdXJwb3Nlcy4gKilcbmxldCByZWMgc2Nhbl9kZWNpbWFsX2RpZ2l0X3N0YXIgd2lkdGggaWIgPVxuICBpZiB3aWR0aCA9IDAgdGhlbiB3aWR0aCBlbHNlXG4gIGxldCBjID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gIGlmIFNjYW5uaW5nLmVvZiBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgbWF0Y2ggYyB3aXRoXG4gIHwgJzAnIC4uICc5JyBhcyBjIC0+XG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgc2Nhbl9kZWNpbWFsX2RpZ2l0X3N0YXIgd2lkdGggaWJcbiAgfCAnXycgLT5cbiAgICBsZXQgd2lkdGggPSBTY2FubmluZy5pZ25vcmVfY2hhciB3aWR0aCBpYiBpblxuICAgIHNjYW5fZGVjaW1hbF9kaWdpdF9zdGFyIHdpZHRoIGliXG4gIHwgXyAtPiB3aWR0aFxuXG5cbmxldCBzY2FuX2RlY2ltYWxfZGlnaXRfcGx1cyB3aWR0aCBpYiA9XG4gIGlmIHdpZHRoID0gMCB0aGVuIGJhZF90b2tlbl9sZW5ndGggXCJkZWNpbWFsIGRpZ2l0c1wiIGVsc2VcbiAgbGV0IGMgPSBTY2FubmluZy5jaGVja2VkX3BlZWtfY2hhciBpYiBpblxuICBtYXRjaCBjIHdpdGhcbiAgfCAnMCcgLi4gJzknIC0+XG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgc2Nhbl9kZWNpbWFsX2RpZ2l0X3N0YXIgd2lkdGggaWJcbiAgfCBjIC0+XG4gICAgYmFkX2lucHV0IChQcmludGYuc3ByaW50ZiBcImNoYXJhY3RlciAlQyBpcyBub3QgYSBkZWNpbWFsIGRpZ2l0XCIgYylcblxuXG4oKiBUbyBzY2FuIG51bWJlcnMgZnJvbSBvdGhlciBiYXNlcywgd2UgdXNlIGEgcHJlZGljYXRlIGFyZ3VtZW50IHRvXG4gICBzY2FuIGRpZ2l0cy4gKilcbmxldCBzY2FuX2RpZ2l0X3N0YXIgZGlnaXRwIHdpZHRoIGliID1cbiAgbGV0IHJlYyBzY2FuX2RpZ2l0cyB3aWR0aCBpYiA9XG4gICAgaWYgd2lkdGggPSAwIHRoZW4gd2lkdGggZWxzZVxuICAgIGxldCBjID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gICAgaWYgU2Nhbm5pbmcuZW9mIGliIHRoZW4gd2lkdGggZWxzZVxuICAgIG1hdGNoIGMgd2l0aFxuICAgIHwgYyB3aGVuIGRpZ2l0cCBjIC0+XG4gICAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICAgIHNjYW5fZGlnaXRzIHdpZHRoIGliXG4gICAgfCAnXycgLT5cbiAgICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliIGluXG4gICAgICBzY2FuX2RpZ2l0cyB3aWR0aCBpYlxuICAgIHwgXyAtPiB3aWR0aCBpblxuICBzY2FuX2RpZ2l0cyB3aWR0aCBpYlxuXG5cbmxldCBzY2FuX2RpZ2l0X3BsdXMgYmFzaXMgZGlnaXRwIHdpZHRoIGliID1cbiAgKCogRW5zdXJlIHdlIGhhdmUgZ290IGVub3VnaCB3aWR0aCBsZWZ0LFxuICAgICBhbmQgcmVhZCBhdCBsZWFzdCBvbmUgZGlnaXQuICopXG4gIGlmIHdpZHRoID0gMCB0aGVuIGJhZF90b2tlbl9sZW5ndGggXCJkaWdpdHNcIiBlbHNlXG4gIGxldCBjID0gU2Nhbm5pbmcuY2hlY2tlZF9wZWVrX2NoYXIgaWIgaW5cbiAgaWYgZGlnaXRwIGMgdGhlblxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgIHNjYW5fZGlnaXRfc3RhciBkaWdpdHAgd2lkdGggaWJcbiAgZWxzZVxuICAgIGJhZF9pbnB1dCAoUHJpbnRmLnNwcmludGYgXCJjaGFyYWN0ZXIgJUMgaXMgbm90IGEgdmFsaWQgJXMgZGlnaXRcIiBjIGJhc2lzKVxuXG5cbmxldCBpc19iaW5hcnlfZGlnaXQgPSBmdW5jdGlvblxuICB8ICcwJyAuLiAnMScgLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2VcblxuXG5sZXQgc2Nhbl9iaW5hcnlfaW50ID0gc2Nhbl9kaWdpdF9wbHVzIFwiYmluYXJ5XCIgaXNfYmluYXJ5X2RpZ2l0XG5cbmxldCBpc19vY3RhbF9kaWdpdCA9IGZ1bmN0aW9uXG4gIHwgJzAnIC4uICc3JyAtPiB0cnVlXG4gIHwgXyAtPiBmYWxzZVxuXG5cbmxldCBzY2FuX29jdGFsX2ludCA9IHNjYW5fZGlnaXRfcGx1cyBcIm9jdGFsXCIgaXNfb2N0YWxfZGlnaXRcblxubGV0IGlzX2hleGFfZGlnaXQgPSBmdW5jdGlvblxuICB8ICcwJyAuLiAnOScgfCAnYScgLi4gJ2YnIHwgJ0EnIC4uICdGJyAtPiB0cnVlXG4gIHwgXyAtPiBmYWxzZVxuXG5cbmxldCBzY2FuX2hleGFkZWNpbWFsX2ludCA9IHNjYW5fZGlnaXRfcGx1cyBcImhleGFkZWNpbWFsXCIgaXNfaGV4YV9kaWdpdFxuXG4oKiBTY2FuIGEgZGVjaW1hbCBpbnRlZ2VyLiAqKVxubGV0IHNjYW5fdW5zaWduZWRfZGVjaW1hbF9pbnQgPSBzY2FuX2RlY2ltYWxfZGlnaXRfcGx1c1xuXG5sZXQgc2Nhbl9zaWduIHdpZHRoIGliID1cbiAgbGV0IGMgPSBTY2FubmluZy5jaGVja2VkX3BlZWtfY2hhciBpYiBpblxuICBtYXRjaCBjIHdpdGhcbiAgfCAnKycgLT4gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjXG4gIHwgJy0nIC0+IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgY1xuICB8IF8gLT4gd2lkdGhcblxuXG5sZXQgc2Nhbl9vcHRpb25hbGx5X3NpZ25lZF9kZWNpbWFsX2ludCB3aWR0aCBpYiA9XG4gIGxldCB3aWR0aCA9IHNjYW5fc2lnbiB3aWR0aCBpYiBpblxuICBzY2FuX3Vuc2lnbmVkX2RlY2ltYWxfaW50IHdpZHRoIGliXG5cblxuKCogU2NhbiBhbiB1bnNpZ25lZCBpbnRlZ2VyIHRoYXQgY291bGQgYmUgZ2l2ZW4gaW4gYW55IChjb21tb24pIGJhc2lzLlxuICAgSWYgZGlnaXRzIGFyZSBwcmVmaXhlZCBieSBvbmUgb2YgMHgsIDBYLCAwbywgb3IgMGIsIHRoZSBudW1iZXIgaXNcbiAgIGFzc3VtZWQgdG8gYmUgd3JpdHRlbiByZXNwZWN0aXZlbHkgaW4gaGV4YWRlY2ltYWwsIGhleGFkZWNpbWFsLFxuICAgb2N0YWwsIG9yIGJpbmFyeS4gKilcbmxldCBzY2FuX3Vuc2lnbmVkX2ludCB3aWR0aCBpYiA9XG4gIG1hdGNoIFNjYW5uaW5nLmNoZWNrZWRfcGVla19jaGFyIGliIHdpdGhcbiAgfCAnMCcgYXMgYyAtPlxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgIGlmIHdpZHRoID0gMCB0aGVuIHdpZHRoIGVsc2VcbiAgICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICAgIGlmIFNjYW5uaW5nLmVvZiBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgICBiZWdpbiBtYXRjaCBjIHdpdGhcbiAgICB8ICd4JyB8ICdYJyAtPiBzY2FuX2hleGFkZWNpbWFsX2ludCAoU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjKSBpYlxuICAgIHwgJ28nIC0+IHNjYW5fb2N0YWxfaW50IChTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMpIGliXG4gICAgfCAnYicgLT4gc2Nhbl9iaW5hcnlfaW50IChTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMpIGliXG4gICAgfCBfIC0+IHNjYW5fZGVjaW1hbF9kaWdpdF9zdGFyIHdpZHRoIGliIGVuZFxuICB8IF8gLT4gc2Nhbl91bnNpZ25lZF9kZWNpbWFsX2ludCB3aWR0aCBpYlxuXG5cbmxldCBzY2FuX29wdGlvbmFsbHlfc2lnbmVkX2ludCB3aWR0aCBpYiA9XG4gIGxldCB3aWR0aCA9IHNjYW5fc2lnbiB3aWR0aCBpYiBpblxuICBzY2FuX3Vuc2lnbmVkX2ludCB3aWR0aCBpYlxuXG5cbmxldCBzY2FuX2ludF9jb252ZXJzaW9uIGNvbnYgd2lkdGggaWIgPVxuICBtYXRjaCBjb252IHdpdGhcbiAgfCBCX2NvbnZlcnNpb24gLT4gc2Nhbl9iaW5hcnlfaW50IHdpZHRoIGliXG4gIHwgRF9jb252ZXJzaW9uIC0+IHNjYW5fb3B0aW9uYWxseV9zaWduZWRfZGVjaW1hbF9pbnQgd2lkdGggaWJcbiAgfCBJX2NvbnZlcnNpb24gLT4gc2Nhbl9vcHRpb25hbGx5X3NpZ25lZF9pbnQgd2lkdGggaWJcbiAgfCBPX2NvbnZlcnNpb24gLT4gc2Nhbl9vY3RhbF9pbnQgd2lkdGggaWJcbiAgfCBVX2NvbnZlcnNpb24gLT4gc2Nhbl91bnNpZ25lZF9kZWNpbWFsX2ludCB3aWR0aCBpYlxuICB8IFhfY29udmVyc2lvbiAtPiBzY2FuX2hleGFkZWNpbWFsX2ludCB3aWR0aCBpYlxuXG5cbigqIFNjYW5uaW5nIGZsb2F0aW5nIHBvaW50IG51bWJlcnMuICopXG5cbigqIEZyYWN0aW9uYWwgcGFydCBpcyBvcHRpb25hbCBhbmQgY2FuIGJlIHJlZHVjZWQgdG8gMCBkaWdpdHMuICopXG5sZXQgc2Nhbl9mcmFjdGlvbmFsX3BhcnQgd2lkdGggaWIgPVxuICBpZiB3aWR0aCA9IDAgdGhlbiB3aWR0aCBlbHNlXG4gIGxldCBjID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gIGlmIFNjYW5uaW5nLmVvZiBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgbWF0Y2ggYyB3aXRoXG4gIHwgJzAnIC4uICc5JyBhcyBjIC0+XG4gICAgc2Nhbl9kZWNpbWFsX2RpZ2l0X3N0YXIgKFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYykgaWJcbiAgfCBfIC0+IHdpZHRoXG5cblxuKCogRXhwIHBhcnQgaXMgb3B0aW9uYWwgYW5kIGNhbiBiZSByZWR1Y2VkIHRvIDAgZGlnaXRzLiAqKVxubGV0IHNjYW5fZXhwb25lbnRfcGFydCB3aWR0aCBpYiA9XG4gIGlmIHdpZHRoID0gMCB0aGVuIHdpZHRoIGVsc2VcbiAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgaWYgU2Nhbm5pbmcuZW9mIGliIHRoZW4gd2lkdGggZWxzZVxuICBtYXRjaCBjIHdpdGhcbiAgfCAnZScgfCAnRScgYXMgYyAtPlxuICAgIHNjYW5fb3B0aW9uYWxseV9zaWduZWRfZGVjaW1hbF9pbnQgKFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYykgaWJcbiAgfCBfIC0+IHdpZHRoXG5cblxuKCogU2NhbiB0aGUgaW50ZWdlciBwYXJ0IG9mIGEgZmxvYXRpbmcgcG9pbnQgbnVtYmVyLCAobm90IHVzaW5nIHRoZVxuICAgT0NhbWwgbGV4aWNhbCBjb252ZW50aW9uIHNpbmNlIHRoZSBpbnRlZ2VyIHBhcnQgY2FuIGJlIGVtcHR5KTpcbiAgIGFuIG9wdGlvbmFsIHNpZ24sIGZvbGxvd2VkIGJ5IGEgcG9zc2libHkgZW1wdHkgc2VxdWVuY2Ugb2YgZGVjaW1hbFxuICAgZGlnaXRzIChlLmcuIC0uMSkuICopXG5sZXQgc2Nhbl9pbnRlZ2VyX3BhcnQgd2lkdGggaWIgPVxuICBsZXQgd2lkdGggPSBzY2FuX3NpZ24gd2lkdGggaWIgaW5cbiAgc2Nhbl9kZWNpbWFsX2RpZ2l0X3N0YXIgd2lkdGggaWJcblxuXG4oKlxuICAgRm9yIHRoZSB0aW1lIGJlaW5nIHdlIGhhdmUgKGFzIGZvdW5kIGluIHNjYW5mLm1saSk6XG4gICB0aGUgZmllbGQgd2lkdGggaXMgY29tcG9zZWQgb2YgYW4gb3B0aW9uYWwgaW50ZWdlciBsaXRlcmFsXG4gICBpbmRpY2F0aW5nIHRoZSBtYXhpbWFsIHdpZHRoIG9mIHRoZSB0b2tlbiB0byByZWFkLlxuICAgVW5mb3J0dW5hdGVseSwgdGhlIHR5cGUtY2hlY2tlciBsZXQgdGhlIHVzZXIgd3JpdGUgYW4gb3B0aW9uYWwgcHJlY2lzaW9uLFxuICAgc2luY2UgdGhpcyBpcyB2YWxpZCBmb3IgcHJpbnRmIGZvcm1hdCBzdHJpbmdzLlxuXG4gICBUaHVzLCB0aGUgbmV4dCBzdGVwIGZvciBTY2FuZiBpcyB0byBzdXBwb3J0IGEgZnVsbCB3aWR0aCBhbmQgcHJlY2lzaW9uXG4gICBpbmRpY2F0aW9uLCBtb3JlIG9yIGxlc3Mgc2ltaWxhciB0byB0aGUgb25lIGZvciBwcmludGYsIHBvc3NpYmx5IGV4dGVuZGVkXG4gICB0byB0aGUgc3BlY2lmaWNhdGlvbiBvZiBhIFttYXgsIG1pbl0gcmFuZ2UgZm9yIHRoZSB3aWR0aCBvZiB0aGUgdG9rZW4gcmVhZFxuICAgZm9yIHN0cmluZ3MuIFNvbWV0aGluZyBsaWtlIHRoZSBmb2xsb3dpbmcgc3BlYyBmb3Igc2NhbmYubWxpOlxuXG4gICBUaGUgb3B0aW9uYWwgW3dpZHRoXSBpcyBhbiBpbnRlZ2VyIGluZGljYXRpbmcgdGhlIG1heGltYWxcbiAgIHdpZHRoIG9mIHRoZSB0b2tlbiByZWFkLiBGb3IgaW5zdGFuY2UsIFslNmRdIHJlYWRzIGFuIGludGVnZXIsXG4gICBoYXZpbmcgYXQgbW9zdCA2IGNoYXJhY3RlcnMuXG5cbiAgIFRoZSBvcHRpb25hbCBbcHJlY2lzaW9uXSBpcyBhIGRvdCBbLl0gZm9sbG93ZWQgYnkgYW4gaW50ZWdlcjpcblxuICAgLSBpbiB0aGUgZmxvYXRpbmcgcG9pbnQgbnVtYmVyIGNvbnZlcnNpb25zIChbJWZdLCBbJWVdLCBbJWddLCBbJUZdLCBbJUVdLFxuICAgYW5kIFslRl0gY29udmVyc2lvbnMsIHRoZSBbcHJlY2lzaW9uXSBpbmRpY2F0ZXMgdGhlIG1heGltdW0gbnVtYmVyIG9mXG4gICBkaWdpdHMgdGhhdCBtYXkgZm9sbG93IHRoZSBkZWNpbWFsIHBvaW50LiBGb3IgaW5zdGFuY2UsIFslLjRmXSByZWFkcyBhXG4gICBbZmxvYXRdIHdpdGggYXQgbW9zdCA0IGZyYWN0aW9uYWwgZGlnaXRzLFxuXG4gICAtIGluIHRoZSBzdHJpbmcgY29udmVyc2lvbnMgKFslc10sIFslU10sIFslXFxbIHJhbmdlIFxcXV0pLCBhbmQgaW4gdGhlXG4gICBpbnRlZ2VyIG51bWJlciBjb252ZXJzaW9ucyAoWyVpXSwgWyVkXSwgWyV1XSwgWyV4XSwgWyVvXSwgYW5kIHRoZWlyXG4gICBbaW50MzJdLCBbaW50NjRdLCBhbmQgW25hdGl2ZV9pbnRdIGNvcnJlc3BvbmRlbnQpLCB0aGUgW3ByZWNpc2lvbl1cbiAgIGluZGljYXRlcyB0aGUgcmVxdWlyZWQgbWluaW11bSB3aWR0aCBvZiB0aGUgdG9rZW4gcmVhZCxcblxuICAgLSBvbiBhbGwgb3RoZXIgY29udmVyc2lvbnMsIHRoZSB3aWR0aCBhbmQgcHJlY2lzaW9uIHNwZWNpZnkgdGhlIFttYXgsIG1pbl1cbiAgIHJhbmdlIGZvciB0aGUgd2lkdGggb2YgdGhlIHRva2VuIHJlYWQuXG4qKVxubGV0IHNjYW5fZmxvYXQgd2lkdGggcHJlY2lzaW9uIGliID1cbiAgbGV0IHdpZHRoID0gc2Nhbl9pbnRlZ2VyX3BhcnQgd2lkdGggaWIgaW5cbiAgaWYgd2lkdGggPSAwIHRoZW4gd2lkdGgsIHByZWNpc2lvbiBlbHNlXG4gIGxldCBjID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gIGlmIFNjYW5uaW5nLmVvZiBpYiB0aGVuIHdpZHRoLCBwcmVjaXNpb24gZWxzZVxuICBtYXRjaCBjIHdpdGhcbiAgfCAnLicgLT5cbiAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICBsZXQgcHJlY2lzaW9uID0gbWluIHdpZHRoIHByZWNpc2lvbiBpblxuICAgIGxldCB3aWR0aCA9IHdpZHRoIC0gKHByZWNpc2lvbiAtIHNjYW5fZnJhY3Rpb25hbF9wYXJ0IHByZWNpc2lvbiBpYikgaW5cbiAgICBzY2FuX2V4cG9uZW50X3BhcnQgd2lkdGggaWIsIHByZWNpc2lvblxuICB8IF8gLT5cbiAgICBzY2FuX2V4cG9uZW50X3BhcnQgd2lkdGggaWIsIHByZWNpc2lvblxuXG5cbmxldCBjaGVja19jYXNlX2luc2Vuc2l0aXZlX3N0cmluZyB3aWR0aCBpYiBlcnJvciBzdHIgPVxuICBsZXQgbG93ZXJjYXNlIGMgPVxuICAgIG1hdGNoIGMgd2l0aFxuICAgIHwgJ0EnIC4uICdaJyAtPlxuICAgICAgY2hhcl9vZl9pbnQgKGludF9vZl9jaGFyIGMgLSBpbnRfb2ZfY2hhciAnQScgKyBpbnRfb2ZfY2hhciAnYScpXG4gICAgfCBfIC0+IGMgaW5cbiAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggc3RyIGluXG4gIGxldCB3aWR0aCA9IHJlZiB3aWR0aCBpblxuICBmb3IgaSA9IDAgdG8gbGVuIC0gMSBkb1xuICAgIGxldCBjID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gICAgaWYgbG93ZXJjYXNlIGMgPD4gbG93ZXJjYXNlIHN0ci5baV0gdGhlbiBlcnJvciAoKTtcbiAgICBpZiAhd2lkdGggPSAwIHRoZW4gZXJyb3IgKCk7XG4gICAgd2lkdGggOj0gU2Nhbm5pbmcuc3RvcmVfY2hhciAhd2lkdGggaWIgYztcbiAgZG9uZTtcbiAgIXdpZHRoXG5cblxubGV0IHNjYW5faGV4X2Zsb2F0IHdpZHRoIHByZWNpc2lvbiBpYiA9XG4gIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfaGV4X2Zsb2F0ICgpO1xuICBsZXQgd2lkdGggPSBzY2FuX3NpZ24gd2lkdGggaWIgaW5cbiAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9oZXhfZmxvYXQgKCk7XG4gIG1hdGNoIFNjYW5uaW5nLnBlZWtfY2hhciBpYiB3aXRoXG4gIHwgJzAnIGFzIGMgLT4gKFxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfaGV4X2Zsb2F0ICgpO1xuICAgIGxldCB3aWR0aCA9IGNoZWNrX2Nhc2VfaW5zZW5zaXRpdmVfc3RyaW5nIHdpZHRoIGliIGJhZF9oZXhfZmxvYXQgXCJ4XCIgaW5cbiAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gd2lkdGggZWxzZVxuICAgICAgbGV0IHdpZHRoID0gbWF0Y2ggU2Nhbm5pbmcucGVla19jaGFyIGliIHdpdGhcbiAgICAgICAgfCAnLicgfCAncCcgfCAnUCcgLT4gd2lkdGhcbiAgICAgICAgfCBfIC0+IHNjYW5faGV4YWRlY2ltYWxfaW50IHdpZHRoIGliIGluXG4gICAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gd2lkdGggZWxzZVxuICAgICAgICBsZXQgd2lkdGggPSBtYXRjaCBTY2FubmluZy5wZWVrX2NoYXIgaWIgd2l0aFxuICAgICAgICAgIHwgJy4nIGFzIGMgLT4gKFxuICAgICAgICAgICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgICAgICAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gd2lkdGggZWxzZVxuICAgICAgICAgICAgICBtYXRjaCBTY2FubmluZy5wZWVrX2NoYXIgaWIgd2l0aFxuICAgICAgICAgICAgICB8ICdwJyB8ICdQJyAtPiB3aWR0aFxuICAgICAgICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgICAgICBsZXQgcHJlY2lzaW9uID0gbWluIHdpZHRoIHByZWNpc2lvbiBpblxuICAgICAgICAgICAgICAgIHdpZHRoIC0gKHByZWNpc2lvbiAtIHNjYW5faGV4YWRlY2ltYWxfaW50IHByZWNpc2lvbiBpYilcbiAgICAgICAgICApXG4gICAgICAgICAgfCBfIC0+IHdpZHRoIGluXG4gICAgICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiB3aWR0aCBlbHNlXG4gICAgICAgICAgbWF0Y2ggU2Nhbm5pbmcucGVla19jaGFyIGliIHdpdGhcbiAgICAgICAgICB8ICdwJyB8ICdQJyBhcyBjIC0+XG4gICAgICAgICAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICAgICAgICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfaGV4X2Zsb2F0ICgpO1xuICAgICAgICAgICAgc2Nhbl9vcHRpb25hbGx5X3NpZ25lZF9kZWNpbWFsX2ludCB3aWR0aCBpYlxuICAgICAgICAgIHwgXyAtPiB3aWR0aFxuICApXG4gIHwgJ24nIHwgJ04nIGFzIGMgLT5cbiAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2hleF9mbG9hdCAoKTtcbiAgICBjaGVja19jYXNlX2luc2Vuc2l0aXZlX3N0cmluZyB3aWR0aCBpYiBiYWRfaGV4X2Zsb2F0IFwiYW5cIlxuICB8ICdpJyB8ICdJJyBhcyBjIC0+XG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9oZXhfZmxvYXQgKCk7XG4gICAgY2hlY2tfY2FzZV9pbnNlbnNpdGl2ZV9zdHJpbmcgd2lkdGggaWIgYmFkX2hleF9mbG9hdCBcIm5maW5pdHlcIlxuICB8IF8gLT4gYmFkX2hleF9mbG9hdCAoKVxuXG5cbmxldCBzY2FuX2NhbWxfZmxvYXRfcmVzdCB3aWR0aCBwcmVjaXNpb24gaWIgPVxuICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2Zsb2F0ICgpO1xuICBsZXQgd2lkdGggPSBzY2FuX2RlY2ltYWxfZGlnaXRfc3RhciB3aWR0aCBpYiBpblxuICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2Zsb2F0ICgpO1xuICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICBtYXRjaCBjIHdpdGhcbiAgfCAnLicgLT5cbiAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICAoKiBUaGUgZWZmZWN0aXZlIHdpZHRoIGF2YWlsYWJsZSBmb3Igc2Nhbm5pbmcgdGhlIGZyYWN0aW9uYWwgcGFydCBpc1xuICAgICAgIHRoZSBtaW5pbXVtIG9mIGRlY2xhcmVkIHByZWNpc2lvbiBhbmQgd2lkdGggbGVmdC4gKilcbiAgICBsZXQgcHJlY2lzaW9uID0gbWluIHdpZHRoIHByZWNpc2lvbiBpblxuICAgICgqIEFmdGVyIHNjYW5uaW5nIHRoZSBmcmFjdGlvbmFsIHBhcnQgd2l0aCBbcHJlY2lzaW9uXSBwcm92aXNpb25hbCB3aWR0aCxcbiAgICAgICBbd2lkdGhfcHJlY2lzaW9uXSBpcyBsZWZ0LiAqKVxuICAgIGxldCB3aWR0aF9wcmVjaXNpb24gPSBzY2FuX2ZyYWN0aW9uYWxfcGFydCBwcmVjaXNpb24gaWIgaW5cbiAgICAoKiBIZW5jZSwgc2Nhbm5pbmcgdGhlIGZyYWN0aW9uYWwgcGFydCB0b29rIGV4YWN0bHlcbiAgICAgICBbcHJlY2lzaW9uIC0gd2lkdGhfcHJlY2lzaW9uXSBjaGFycy4gKilcbiAgICBsZXQgZnJhY193aWR0aCA9IHByZWNpc2lvbiAtIHdpZHRoX3ByZWNpc2lvbiBpblxuICAgICgqIEFuZCBuZXcgcHJvdmlzaW9uYWwgd2lkdGggaXMgW3dpZHRoIC0gd2lkdGhfcHJlY2lzaW9uLiAqKVxuICAgIGxldCB3aWR0aCA9IHdpZHRoIC0gZnJhY193aWR0aCBpblxuICAgIHNjYW5fZXhwb25lbnRfcGFydCB3aWR0aCBpYlxuICB8ICdlJyB8ICdFJyAtPlxuICAgIHNjYW5fZXhwb25lbnRfcGFydCB3aWR0aCBpYlxuICB8IF8gLT4gYmFkX2Zsb2F0ICgpXG5cblxubGV0IHNjYW5fY2FtbF9mbG9hdCB3aWR0aCBwcmVjaXNpb24gaWIgPVxuICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2Zsb2F0ICgpO1xuICBsZXQgd2lkdGggPSBzY2FuX3NpZ24gd2lkdGggaWIgaW5cbiAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9mbG9hdCAoKTtcbiAgbWF0Y2ggU2Nhbm5pbmcucGVla19jaGFyIGliIHdpdGhcbiAgfCAnMCcgYXMgYyAtPiAoXG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9mbG9hdCAoKTtcbiAgICBtYXRjaCBTY2FubmluZy5wZWVrX2NoYXIgaWIgd2l0aFxuICAgIHwgJ3gnIHwgJ1gnIGFzIGMgLT4gKFxuICAgICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2Zsb2F0ICgpO1xuICAgICAgbGV0IHdpZHRoID0gc2Nhbl9oZXhhZGVjaW1hbF9pbnQgd2lkdGggaWIgaW5cbiAgICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfZmxvYXQgKCk7XG4gICAgICBsZXQgd2lkdGggPSBtYXRjaCBTY2FubmluZy5wZWVrX2NoYXIgaWIgd2l0aFxuICAgICAgICB8ICcuJyBhcyBjIC0+IChcbiAgICAgICAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICAgICAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gd2lkdGggZWxzZVxuICAgICAgICAgICAgbWF0Y2ggU2Nhbm5pbmcucGVla19jaGFyIGliIHdpdGhcbiAgICAgICAgICAgIHwgJ3AnIHwgJ1AnIC0+IHdpZHRoXG4gICAgICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgICAgbGV0IHByZWNpc2lvbiA9IG1pbiB3aWR0aCBwcmVjaXNpb24gaW5cbiAgICAgICAgICAgICAgd2lkdGggLSAocHJlY2lzaW9uIC0gc2Nhbl9oZXhhZGVjaW1hbF9pbnQgcHJlY2lzaW9uIGliKVxuICAgICAgICApXG4gICAgICAgIHwgJ3AnIHwgJ1AnIC0+IHdpZHRoXG4gICAgICAgIHwgXyAtPiBiYWRfZmxvYXQgKCkgaW5cbiAgICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiB3aWR0aCBlbHNlXG4gICAgICAgIG1hdGNoIFNjYW5uaW5nLnBlZWtfY2hhciBpYiB3aXRoXG4gICAgICAgIHwgJ3AnIHwgJ1AnIGFzIGMgLT5cbiAgICAgICAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICAgICAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2hleF9mbG9hdCAoKTtcbiAgICAgICAgICBzY2FuX29wdGlvbmFsbHlfc2lnbmVkX2RlY2ltYWxfaW50IHdpZHRoIGliXG4gICAgICAgIHwgXyAtPiB3aWR0aFxuICAgIClcbiAgICB8IF8gLT5cbiAgICAgIHNjYW5fY2FtbF9mbG9hdF9yZXN0IHdpZHRoIHByZWNpc2lvbiBpYlxuICApXG4gIHwgJzEnIC4uICc5JyBhcyBjIC0+XG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9mbG9hdCAoKTtcbiAgICBzY2FuX2NhbWxfZmxvYXRfcmVzdCB3aWR0aCBwcmVjaXNpb24gaWJcbigqIFNwZWNpYWwgY2FzZSBvZiBuYW4gYW5kIGluZmluaXR5OlxuICB8ICdpJyAtPlxuICB8ICduJyAtPlxuKilcbiAgfCBfIC0+IGJhZF9mbG9hdCAoKVxuXG5cbigqIFNjYW4gYSByZWd1bGFyIHN0cmluZzpcbiAgIHN0b3BzIHdoZW4gZW5jb3VudGVyaW5nIGEgc3BhY2UsIGlmIG5vIHNjYW5uaW5nIGluZGljYXRpb24gaGFzIGJlZW4gZ2l2ZW47XG4gICBvdGhlcndpc2UsIHN0b3BzIHdoZW4gZW5jb3VudGVyaW5nIHRoZSBjaGFyYWN0ZXJzIGluIHRoZSBzY2FubmluZ1xuICAgaW5kaWNhdGlvbiBbc3RwXS5cbiAgIEl0IGFsc28gc3RvcHMgYXQgZW5kIG9mIGZpbGUgb3Igd2hlbiB0aGUgbWF4aW11bSBudW1iZXIgb2YgY2hhcmFjdGVycyBoYXNcbiAgIGJlZW4gcmVhZC4gKilcbmxldCBzY2FuX3N0cmluZyBzdHAgd2lkdGggaWIgPVxuICBsZXQgcmVjIGxvb3Agd2lkdGggPVxuICAgIGlmIHdpZHRoID0gMCB0aGVuIHdpZHRoIGVsc2VcbiAgICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICAgIGlmIFNjYW5uaW5nLmVvZiBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgICAgIG1hdGNoIHN0cCB3aXRoXG4gICAgICB8IFNvbWUgYycgd2hlbiBjID0gYycgLT4gU2Nhbm5pbmcuc2tpcF9jaGFyIHdpZHRoIGliXG4gICAgICB8IFNvbWUgXyAtPiBsb29wIChTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMpXG4gICAgICB8IE5vbmUgLT5cbiAgICAgICAgbWF0Y2ggYyB3aXRoXG4gICAgICAgIHwgJyAnIHwgJ1xcdCcgfCAnXFxuJyB8ICdcXHInIC0+IHdpZHRoXG4gICAgICAgIHwgXyAtPiBsb29wIChTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMpIGluXG4gIGxvb3Agd2lkdGhcblxuXG4oKiBTY2FuIGEgY2hhcjogcGVlayBzdHJpY3RseSBvbmUgY2hhcmFjdGVyIGluIHRoZSBpbnB1dCwgd2hhdHNvZXZlci4gKilcbmxldCBzY2FuX2NoYXIgd2lkdGggaWIgPVxuICAoKiBUaGUgY2FzZSB3aWR0aCA9IDAgY291bGQgbm90IGhhcHBlbiBoZXJlLCBzaW5jZSBpdCBpcyB0ZXN0ZWQgYmVmb3JlXG4gICAgIGNhbGxpbmcgc2Nhbl9jaGFyLCBpbiB0aGUgbWFpbiBzY2FubmluZyBmdW5jdGlvbi5cbiAgICBpZiB3aWR0aCA9IDAgdGhlbiBiYWRfdG9rZW5fbGVuZ3RoIFwiYSBjaGFyYWN0ZXJcIiBlbHNlICopXG4gIFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgKFNjYW5uaW5nLmNoZWNrZWRfcGVla19jaGFyIGliKVxuXG5cbmxldCBjaGFyX2Zvcl9iYWNrc2xhc2ggPSBmdW5jdGlvblxuICB8ICduJyAtPiAnXFwwMTAnXG4gIHwgJ3InIC0+ICdcXDAxMydcbiAgfCAnYicgLT4gJ1xcMDA4J1xuICB8ICd0JyAtPiAnXFwwMDknXG4gIHwgYyAtPiBjXG5cblxuKCogVGhlIGludGVnZXIgdmFsdWUgY29ycmVzcG9uZGluZyB0byB0aGUgZmFjaWFsIHZhbHVlIG9mIGEgdmFsaWRcbiAgIGRlY2ltYWwgZGlnaXQgY2hhcmFjdGVyLiAqKVxubGV0IGRlY2ltYWxfdmFsdWVfb2ZfY2hhciBjID0gaW50X29mX2NoYXIgYyAtIGludF9vZl9jaGFyICcwJ1xuXG5sZXQgY2hhcl9mb3JfZGVjaW1hbF9jb2RlIGMwIGMxIGMyID1cbiAgbGV0IGMgPVxuICAgIDEwMCAqIGRlY2ltYWxfdmFsdWVfb2ZfY2hhciBjMCArXG4gICAgIDEwICogZGVjaW1hbF92YWx1ZV9vZl9jaGFyIGMxICtcbiAgICAgICAgICBkZWNpbWFsX3ZhbHVlX29mX2NoYXIgYzIgaW5cbiAgaWYgYyA8IDAgfHwgYyA+IDI1NSB0aGVuXG4gICAgYmFkX2lucHV0XG4gICAgICAoUHJpbnRmLnNwcmludGZcbiAgICAgICAgIFwiYmFkIGNoYXJhY3RlciBkZWNpbWFsIGVuY29kaW5nIFxcXFwlYyVjJWNcIiBjMCBjMSBjMikgZWxzZVxuICBjaGFyX29mX2ludCBjXG5cblxuKCogVGhlIGludGVnZXIgdmFsdWUgY29ycmVzcG9uZGluZyB0byB0aGUgZmFjaWFsIHZhbHVlIG9mIGEgdmFsaWRcbiAgIGhleGFkZWNpbWFsIGRpZ2l0IGNoYXJhY3Rlci4gKilcbmxldCBoZXhhZGVjaW1hbF92YWx1ZV9vZl9jaGFyIGMgPVxuICBsZXQgZCA9IGludF9vZl9jaGFyIGMgaW5cbiAgKCogQ291bGQgYWxzbyBiZTpcbiAgICBpZiBkIDw9IGludF9vZl9jaGFyICc5JyB0aGVuIGQgLSBpbnRfb2ZfY2hhciAnMCcgZWxzZVxuICAgIGlmIGQgPD0gaW50X29mX2NoYXIgJ0YnIHRoZW4gMTAgKyBkIC0gaW50X29mX2NoYXIgJ0EnIGVsc2VcbiAgICBpZiBkIDw9IGludF9vZl9jaGFyICdmJyB0aGVuIDEwICsgZCAtIGludF9vZl9jaGFyICdhJyBlbHNlIGFzc2VydCBmYWxzZVxuICAqKVxuICBpZiBkID49IGludF9vZl9jaGFyICdhJyB0aGVuXG4gICAgZCAtIDg3ICgqIDEwICsgaW50X29mX2NoYXIgYyAtIGludF9vZl9jaGFyICdhJyAqKSBlbHNlXG4gIGlmIGQgPj0gaW50X29mX2NoYXIgJ0EnIHRoZW5cbiAgICBkIC0gNTUgICgqIDEwICsgaW50X29mX2NoYXIgYyAtIGludF9vZl9jaGFyICdBJyAqKSBlbHNlXG4gICAgZCAtIGludF9vZl9jaGFyICcwJ1xuXG5cbmxldCBjaGFyX2Zvcl9oZXhhZGVjaW1hbF9jb2RlIGMxIGMyID1cbiAgbGV0IGMgPVxuICAgIDE2ICogaGV4YWRlY2ltYWxfdmFsdWVfb2ZfY2hhciBjMSArXG4gICAgICAgICBoZXhhZGVjaW1hbF92YWx1ZV9vZl9jaGFyIGMyIGluXG4gIGlmIGMgPCAwIHx8IGMgPiAyNTUgdGhlblxuICAgIGJhZF9pbnB1dFxuICAgICAgKFByaW50Zi5zcHJpbnRmIFwiYmFkIGNoYXJhY3RlciBoZXhhZGVjaW1hbCBlbmNvZGluZyBcXFxcJWMlY1wiIGMxIGMyKSBlbHNlXG4gIGNoYXJfb2ZfaW50IGNcblxuXG4oKiBDYWxsZWQgaW4gcGFydGljdWxhciB3aGVuIGVuY291bnRlcmluZyAnXFxcXCcgYXMgc3RhcnRlciBvZiBhIGNoYXIuXG4gICBTdG9wcyBiZWZvcmUgdGhlIGNvcnJlc3BvbmRpbmcgJ1xcJycuICopXG5sZXQgY2hlY2tfbmV4dF9jaGFyIG1lc3NhZ2Ugd2lkdGggaWIgPVxuICBpZiB3aWR0aCA9IDAgdGhlbiBiYWRfdG9rZW5fbGVuZ3RoIG1lc3NhZ2UgZWxzZVxuICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICBpZiBTY2FubmluZy5lb2YgaWIgdGhlbiBiYWRfZW5kX29mX2lucHV0IG1lc3NhZ2UgZWxzZVxuICBjXG5cblxubGV0IGNoZWNrX25leHRfY2hhcl9mb3JfY2hhciA9IGNoZWNrX25leHRfY2hhciBcImEgQ2hhclwiXG5sZXQgY2hlY2tfbmV4dF9jaGFyX2Zvcl9zdHJpbmcgPSBjaGVja19uZXh0X2NoYXIgXCJhIFN0cmluZ1wiXG5cbmxldCBzY2FuX2JhY2tzbGFzaF9jaGFyIHdpZHRoIGliID1cbiAgbWF0Y2ggY2hlY2tfbmV4dF9jaGFyX2Zvcl9jaGFyIHdpZHRoIGliIHdpdGhcbiAgfCAnXFxcXCcgfCAnXFwnJyB8ICdcXFwiJyB8ICduJyB8ICd0JyB8ICdiJyB8ICdyJyBhcyBjIC0+XG4gICAgU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiAoY2hhcl9mb3JfYmFja3NsYXNoIGMpXG4gIHwgJzAnIC4uICc5JyBhcyBjIC0+XG4gICAgbGV0IGdldF9kaWdpdCAoKSA9XG4gICAgICBsZXQgYyA9IFNjYW5uaW5nLm5leHRfY2hhciBpYiBpblxuICAgICAgbWF0Y2ggYyB3aXRoXG4gICAgICB8ICcwJyAuLiAnOScgYXMgYyAtPiBjXG4gICAgICB8IGMgLT4gYmFkX2lucHV0X2VzY2FwZSBjIGluXG4gICAgbGV0IGMwID0gYyBpblxuICAgIGxldCBjMSA9IGdldF9kaWdpdCAoKSBpblxuICAgIGxldCBjMiA9IGdldF9kaWdpdCAoKSBpblxuICAgIFNjYW5uaW5nLnN0b3JlX2NoYXIgKHdpZHRoIC0gMikgaWIgKGNoYXJfZm9yX2RlY2ltYWxfY29kZSBjMCBjMSBjMilcbiAgfCAneCcgLT5cbiAgICBsZXQgZ2V0X2RpZ2l0ICgpID1cbiAgICAgIGxldCBjID0gU2Nhbm5pbmcubmV4dF9jaGFyIGliIGluXG4gICAgICBtYXRjaCBjIHdpdGhcbiAgICAgIHwgJzAnIC4uICc5JyB8ICdBJyAuLiAnRicgfCAnYScgLi4gJ2YnIGFzIGMgLT4gY1xuICAgICAgfCBjIC0+IGJhZF9pbnB1dF9lc2NhcGUgYyBpblxuICAgIGxldCBjMSA9IGdldF9kaWdpdCAoKSBpblxuICAgIGxldCBjMiA9IGdldF9kaWdpdCAoKSBpblxuICAgIFNjYW5uaW5nLnN0b3JlX2NoYXIgKHdpZHRoIC0gMikgaWIgKGNoYXJfZm9yX2hleGFkZWNpbWFsX2NvZGUgYzEgYzIpXG4gIHwgYyAtPlxuICAgIGJhZF9pbnB1dF9lc2NhcGUgY1xuXG5cbigqIFNjYW4gYSBjaGFyYWN0ZXIgKGFuIE9DYW1sIHRva2VuKS4gKilcbmxldCBzY2FuX2NhbWxfY2hhciB3aWR0aCBpYiA9XG5cbiAgbGV0IHJlYyBmaW5kX3N0YXJ0IHdpZHRoID1cbiAgICBtYXRjaCBTY2FubmluZy5jaGVja2VkX3BlZWtfY2hhciBpYiB3aXRoXG4gICAgfCAnXFwnJyAtPiBmaW5kX2NoYXIgKFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliKVxuICAgIHwgYyAtPiBjaGFyYWN0ZXJfbWlzbWF0Y2ggJ1xcJycgY1xuXG4gIGFuZCBmaW5kX2NoYXIgd2lkdGggPVxuICAgIG1hdGNoIGNoZWNrX25leHRfY2hhcl9mb3JfY2hhciB3aWR0aCBpYiB3aXRoXG4gICAgfCAnXFxcXCcgLT5cbiAgICAgIGZpbmRfc3RvcCAoc2Nhbl9iYWNrc2xhc2hfY2hhciAoU2Nhbm5pbmcuaWdub3JlX2NoYXIgd2lkdGggaWIpIGliKVxuICAgIHwgYyAtPlxuICAgICAgZmluZF9zdG9wIChTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMpXG5cbiAgYW5kIGZpbmRfc3RvcCB3aWR0aCA9XG4gICAgbWF0Y2ggY2hlY2tfbmV4dF9jaGFyX2Zvcl9jaGFyIHdpZHRoIGliIHdpdGhcbiAgICB8ICdcXCcnIC0+IFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliXG4gICAgfCBjIC0+IGNoYXJhY3Rlcl9taXNtYXRjaCAnXFwnJyBjIGluXG5cbiAgZmluZF9zdGFydCB3aWR0aFxuXG5cbigqIFNjYW4gYSBkZWxpbWl0ZWQgc3RyaW5nIChhbiBPQ2FtbCB0b2tlbikuICopXG5sZXQgc2Nhbl9jYW1sX3N0cmluZyB3aWR0aCBpYiA9XG5cbiAgbGV0IHJlYyBmaW5kX3N0YXJ0IHdpZHRoID1cbiAgICBtYXRjaCBTY2FubmluZy5jaGVja2VkX3BlZWtfY2hhciBpYiB3aXRoXG4gICAgfCAnXFxcIicgLT4gZmluZF9zdG9wIChTY2FubmluZy5pZ25vcmVfY2hhciB3aWR0aCBpYilcbiAgICB8IGMgLT4gY2hhcmFjdGVyX21pc21hdGNoICdcXFwiJyBjXG5cbiAgYW5kIGZpbmRfc3RvcCB3aWR0aCA9XG4gICAgbWF0Y2ggY2hlY2tfbmV4dF9jaGFyX2Zvcl9zdHJpbmcgd2lkdGggaWIgd2l0aFxuICAgIHwgJ1xcXCInIC0+IFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliXG4gICAgfCAnXFxcXCcgLT4gc2Nhbl9iYWNrc2xhc2ggKFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliKVxuICAgIHwgYyAtPiBmaW5kX3N0b3AgKFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYylcblxuICBhbmQgc2Nhbl9iYWNrc2xhc2ggd2lkdGggPVxuICAgIG1hdGNoIGNoZWNrX25leHRfY2hhcl9mb3Jfc3RyaW5nIHdpZHRoIGliIHdpdGhcbiAgICB8ICdcXHInIC0+IHNraXBfbmV3bGluZSAoU2Nhbm5pbmcuaWdub3JlX2NoYXIgd2lkdGggaWIpXG4gICAgfCAnXFxuJyAtPiBza2lwX3NwYWNlcyAoU2Nhbm5pbmcuaWdub3JlX2NoYXIgd2lkdGggaWIpXG4gICAgfCBfIC0+IGZpbmRfc3RvcCAoc2Nhbl9iYWNrc2xhc2hfY2hhciB3aWR0aCBpYilcblxuICBhbmQgc2tpcF9uZXdsaW5lIHdpZHRoID1cbiAgICBtYXRjaCBjaGVja19uZXh0X2NoYXJfZm9yX3N0cmluZyB3aWR0aCBpYiB3aXRoXG4gICAgfCAnXFxuJyAtPiBza2lwX3NwYWNlcyAoU2Nhbm5pbmcuaWdub3JlX2NoYXIgd2lkdGggaWIpXG4gICAgfCBfIC0+IGZpbmRfc3RvcCAoU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiAnXFxyJylcblxuICBhbmQgc2tpcF9zcGFjZXMgd2lkdGggPVxuICAgIG1hdGNoIGNoZWNrX25leHRfY2hhcl9mb3Jfc3RyaW5nIHdpZHRoIGliIHdpdGhcbiAgICB8ICcgJyAtPiBza2lwX3NwYWNlcyAoU2Nhbm5pbmcuaWdub3JlX2NoYXIgd2lkdGggaWIpXG4gICAgfCBfIC0+IGZpbmRfc3RvcCB3aWR0aCBpblxuXG4gIGZpbmRfc3RhcnQgd2lkdGhcblxuXG4oKiBTY2FuIGEgYm9vbGVhbiAoYW4gT0NhbWwgdG9rZW4pLiAqKVxubGV0IHNjYW5fYm9vbCBpYiA9XG4gIGxldCBjID0gU2Nhbm5pbmcuY2hlY2tlZF9wZWVrX2NoYXIgaWIgaW5cbiAgbGV0IG0gPVxuICAgIG1hdGNoIGMgd2l0aFxuICAgIHwgJ3QnIC0+IDRcbiAgICB8ICdmJyAtPiA1XG4gICAgfCBjIC0+XG4gICAgICBiYWRfaW5wdXRcbiAgICAgICAgKFByaW50Zi5zcHJpbnRmIFwidGhlIGNoYXJhY3RlciAlQyBjYW5ub3Qgc3RhcnQgYSBib29sZWFuXCIgYykgaW5cbiAgc2Nhbl9zdHJpbmcgTm9uZSBtIGliXG5cblxuKCogU2NhbiBhIHN0cmluZyBjb250YWluaW5nIGVsZW1lbnRzIGluIGNoYXJfc2V0IGFuZCB0ZXJtaW5hdGVkIGJ5IHNjYW5faW5kaWNcbiAgIGlmIHByb3ZpZGVkLiAqKVxubGV0IHNjYW5fY2hhcnNfaW5fY2hhcl9zZXQgY2hhcl9zZXQgc2Nhbl9pbmRpYyB3aWR0aCBpYiA9XG4gIGxldCByZWMgc2Nhbl9jaGFycyBpIHN0cCA9XG4gICAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgICBpZiBpID4gMCAmJiBub3QgKFNjYW5uaW5nLmVvZiBpYikgJiZcbiAgICAgICBpc19pbl9jaGFyX3NldCBjaGFyX3NldCBjICYmXG4gICAgICAgaW50X29mX2NoYXIgYyA8PiBzdHAgdGhlblxuICAgICAgbGV0IF8gPSBTY2FubmluZy5zdG9yZV9jaGFyIG1heF9pbnQgaWIgYyBpblxuICAgICAgc2Nhbl9jaGFycyAoaSAtIDEpIHN0cCBpblxuICBtYXRjaCBzY2FuX2luZGljIHdpdGhcbiAgfCBOb25lIC0+IHNjYW5fY2hhcnMgd2lkdGggKC0xKTtcbiAgfCBTb21lIGMgLT5cbiAgICBzY2FuX2NoYXJzIHdpZHRoIChpbnRfb2ZfY2hhciBjKTtcbiAgICBpZiBub3QgKFNjYW5uaW5nLmVvZiBpYikgdGhlblxuICAgICAgbGV0IGNpID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gICAgICBpZiBjID0gY2lcbiAgICAgIHRoZW4gU2Nhbm5pbmcuaW52YWxpZGF0ZV9jdXJyZW50X2NoYXIgaWJcbiAgICAgIGVsc2UgY2hhcmFjdGVyX21pc21hdGNoIGMgY2lcblxuXG4oKiBUaGUgZ2xvYmFsIGVycm9yIHJlcG9ydCBmdW5jdGlvbiBmb3IgW1NjYW5mXS4gKilcbmxldCBzY2FuZl9iYWRfaW5wdXQgaWIgPSBmdW5jdGlvblxuICB8IFNjYW5fZmFpbHVyZSBzIHwgRmFpbHVyZSBzIC0+XG4gICAgbGV0IGkgPSBTY2FubmluZy5jaGFyX2NvdW50IGliIGluXG4gICAgYmFkX2lucHV0IChQcmludGYuc3ByaW50ZiBcInNjYW5mOiBiYWQgaW5wdXQgYXQgY2hhciBudW1iZXIgJWk6ICVzXCIgaSBzKVxuICB8IHggLT4gcmFpc2UgeFxuXG5cbigqIEdldCB0aGUgY29udGVudCBvZiBhIGNvdW50ZXIgZnJvbSBhbiBpbnB1dCBidWZmZXIuICopXG5sZXQgZ2V0X2NvdW50ZXIgaWIgY291bnRlciA9XG4gIG1hdGNoIGNvdW50ZXIgd2l0aFxuICB8IExpbmVfY291bnRlciAtPiBTY2FubmluZy5saW5lX2NvdW50IGliXG4gIHwgQ2hhcl9jb3VudGVyIC0+IFNjYW5uaW5nLmNoYXJfY291bnQgaWJcbiAgfCBUb2tlbl9jb3VudGVyIC0+IFNjYW5uaW5nLnRva2VuX2NvdW50IGliXG5cblxuKCogQ29tcHV0ZSB0aGUgd2lkdGggb2YgYSBwYWRkaW5nIG9wdGlvbiAoc2VlIFwiJTQye1wiIGFuZCBcIiUxMjMoXCIpLiAqKVxubGV0IHdpZHRoX29mX3BhZF9vcHQgcGFkX29wdCA9IG1hdGNoIHBhZF9vcHQgd2l0aFxuICB8IE5vbmUgLT4gbWF4X2ludFxuICB8IFNvbWUgd2lkdGggLT4gd2lkdGhcblxuXG5sZXQgc3RvcHBlcl9vZl9mb3JtYXR0aW5nX2xpdCBmbXRpbmcgPVxuICBpZiBmbXRpbmcgPSBFc2NhcGVkX3BlcmNlbnQgdGhlbiAnJScsIFwiXCIgZWxzZVxuICAgIGxldCBzdHIgPSBzdHJpbmdfb2ZfZm9ybWF0dGluZ19saXQgZm10aW5nIGluXG4gICAgbGV0IHN0cCA9IHN0ci5bMV0gaW5cbiAgICBsZXQgc3ViX3N0ciA9IFN0cmluZy5zdWIgc3RyIDIgKFN0cmluZy5sZW5ndGggc3RyIC0gMikgaW5cbiAgICBzdHAsIHN1Yl9zdHJcblxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogUmVhZGVyIG1hbmFnZW1lbnQgKilcblxuKCogQSBjYWxsIHRvIHRha2VfZm9ybWF0X3JlYWRlcnMgb24gYSBmb3JtYXQgaXMgZXZhbHVhdGVkIGludG8gZnVuY3Rpb25zXG4gICB0YWtpbmcgcmVhZGVycyBhcyBhcmd1bWVudHMgYW5kIGFnZ3JlZ2F0ZSB0aGVtIGludG8gYW4gaGV0ZXJvZ2VuZW91cyBsaXN0ICopXG4oKiBXaGVuIGFsbCByZWFkZXJzIGFyZSB0YWtlbiwgZmluYWxseSBwYXNzIHRoZSBsaXN0IG9mIHRoZSByZWFkZXJzIHRvIHRoZVxuICAgY29udGludWF0aW9uIGsuICopXG5sZXQgcmVjIHRha2VfZm9ybWF0X3JlYWRlcnMgOiB0eXBlIGEgYyBkIGUgZiAuXG4gICAgKChkLCBlKSBoZXRlcl9saXN0IC0+IGUpIC0+IChhLCBTY2FubmluZy5pbl9jaGFubmVsLCBjLCBkLCBlLCBmKSBmbXQgLT5cbiAgICBkID1cbmZ1biBrIGZtdCAtPiBtYXRjaCBmbXQgd2l0aFxuICB8IFJlYWRlciBmbXRfcmVzdCAtPlxuICAgIGZ1biByZWFkZXIgLT5cbiAgICAgIGxldCBuZXdfayByZWFkZXJzX3Jlc3QgPSBrIChDb25zIChyZWFkZXIsIHJlYWRlcnNfcmVzdCkpIGluXG4gICAgICB0YWtlX2Zvcm1hdF9yZWFkZXJzIG5ld19rIGZtdF9yZXN0XG4gIHwgQ2hhciByZXN0ICAgICAgICAgICAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBDYW1sX2NoYXIgcmVzdCAgICAgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IFN0cmluZyAoXywgcmVzdCkgICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgQ2FtbF9zdHJpbmcgKF8sIHJlc3QpICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBJbnQgKF8sIF8sIF8sIHJlc3QpICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IEludDMyIChfLCBfLCBfLCByZXN0KSAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgTmF0aXZlaW50IChfLCBfLCBfLCByZXN0KSAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBJbnQ2NCAoXywgXywgXywgcmVzdCkgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IEZsb2F0IChfLCBfLCBfLCByZXN0KSAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgQm9vbCAoXywgcmVzdCkgICAgICAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBBbHBoYSByZXN0ICAgICAgICAgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IFRoZXRhIHJlc3QgICAgICAgICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgRmx1c2ggcmVzdCAgICAgICAgICAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBTdHJpbmdfbGl0ZXJhbCAoXywgcmVzdCkgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IENoYXJfbGl0ZXJhbCAoXywgcmVzdCkgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgQ3VzdG9tIChfLCBfLCByZXN0KSAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcblxuICB8IFNjYW5fY2hhcl9zZXQgKF8sIF8sIHJlc3QpICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgU2Nhbl9nZXRfY291bnRlciAoXywgcmVzdCkgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBTY2FuX25leHRfY2hhciByZXN0ICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuXG4gIHwgRm9ybWF0dGluZ19saXQgKF8sIHJlc3QpICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBGb3JtYXR0aW5nX2dlbiAoT3Blbl90YWcgKEZvcm1hdCAoZm10LCBfKSksIHJlc3QpIC0+XG4gICAgICB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgKGNvbmNhdF9mbXQgZm10IHJlc3QpXG4gIHwgRm9ybWF0dGluZ19nZW4gKE9wZW5fYm94IChGb3JtYXQgKGZtdCwgXykpLCByZXN0KSAtPlxuICAgICAgdGFrZV9mb3JtYXRfcmVhZGVycyBrIChjb25jYXRfZm10IGZtdCByZXN0KVxuXG4gIHwgRm9ybWF0X2FyZyAoXywgXywgcmVzdCkgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBGb3JtYXRfc3Vic3QgKF8sIGZtdHR5LCByZXN0KSAgICAtPlxuICAgICB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgKGVyYXNlX3JlbCAoc3ltbSBmbXR0eSkpIHJlc3RcbiAgfCBJZ25vcmVkX3BhcmFtIChpZ24sIHJlc3QpICAgICAgICAtPiB0YWtlX2lnbm9yZWRfZm9ybWF0X3JlYWRlcnMgayBpZ24gcmVzdFxuXG4gIHwgRW5kX29mX2Zvcm1hdCAgICAgICAgICAgICAgICAgICAgLT4gayBOaWxcblxuKCogVGFrZSByZWFkZXJzIGFzc29jaWF0ZWQgdG8gYW4gZm10dHkgY29taW5nIGZyb20gYSBGb3JtYXRfc3Vic3QgXCIlKC4uLiUpXCIuICopXG5hbmQgdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyA6IHR5cGUgeCB5IGEgYyBkIGUgZiAuXG4gICAgKChkLCBlKSBoZXRlcl9saXN0IC0+IGUpIC0+IChhLCBTY2FubmluZy5pbl9jaGFubmVsLCBjLCBkLCB4LCB5KSBmbXR0eSAtPlxuICAgICAgKHksIFNjYW5uaW5nLmluX2NoYW5uZWwsIGMsIHgsIGUsIGYpIGZtdCAtPiBkID1cbmZ1biBrIGZtdHR5IGZtdCAtPiBtYXRjaCBmbXR0eSB3aXRoXG4gIHwgUmVhZGVyX3R5IGZtdF9yZXN0IC0+XG4gICAgZnVuIHJlYWRlciAtPlxuICAgICAgbGV0IG5ld19rIHJlYWRlcnNfcmVzdCA9IGsgKENvbnMgKHJlYWRlciwgcmVhZGVyc19yZXN0KSkgaW5cbiAgICAgIHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgbmV3X2sgZm10X3Jlc3QgZm10XG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgZm10X3Jlc3QgLT5cbiAgICBmdW4gcmVhZGVyIC0+XG4gICAgICBsZXQgbmV3X2sgcmVhZGVyc19yZXN0ID0gayAoQ29ucyAocmVhZGVyLCByZWFkZXJzX3Jlc3QpKSBpblxuICAgICAgdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBuZXdfayBmbXRfcmVzdCBmbXRcbiAgfCBDaGFyX3R5IHJlc3QgICAgICAgICAgICAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgU3RyaW5nX3R5IHJlc3QgICAgICAgICAgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IEludF90eSByZXN0ICAgICAgICAgICAgICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBJbnQzMl90eSByZXN0ICAgICAgICAgICAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgTmF0aXZlaW50X3R5IHJlc3QgICAgICAgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IEludDY0X3R5IHJlc3QgICAgICAgICAgICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBGbG9hdF90eSByZXN0ICAgICAgICAgICAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgQm9vbF90eSByZXN0ICAgICAgICAgICAgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IEFscGhhX3R5IHJlc3QgICAgICAgICAgICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBUaGV0YV90eSByZXN0ICAgICAgICAgICAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgQW55X3R5IHJlc3QgICAgICAgICAgICAgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IEZvcm1hdF9hcmdfdHkgKF8sIHJlc3QpICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBFbmRfb2ZfZm10dHkgICAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIGZtdFxuICB8IEZvcm1hdF9zdWJzdF90eSAodHkxLCB0eTIsIHJlc3QpIC0+XG4gICAgbGV0IHR5ID0gdHJhbnMgKHN5bW0gdHkxKSB0eTIgaW5cbiAgICB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgKGNvbmNhdF9mbXR0eSB0eSByZXN0KSBmbXRcblxuKCogVGFrZSByZWFkZXJzIGFzc29jaWF0ZWQgdG8gYW4gaWdub3JlZCBwYXJhbWV0ZXIuICopXG5hbmQgdGFrZV9pZ25vcmVkX2Zvcm1hdF9yZWFkZXJzIDogdHlwZSB4IHkgYSBjIGQgZSBmIC5cbiAgICAoKGQsIGUpIGhldGVyX2xpc3QgLT4gZSkgLT4gKGEsIFNjYW5uaW5nLmluX2NoYW5uZWwsIGMsIGQsIHgsIHkpIGlnbm9yZWQgLT5cbiAgICAgICh5LCBTY2FubmluZy5pbl9jaGFubmVsLCBjLCB4LCBlLCBmKSBmbXQgLT4gZCA9XG5mdW4gayBpZ24gZm10IC0+IG1hdGNoIGlnbiB3aXRoXG4gIHwgSWdub3JlZF9yZWFkZXIgLT5cbiAgICBmdW4gcmVhZGVyIC0+XG4gICAgICBsZXQgbmV3X2sgcmVhZGVyc19yZXN0ID0gayAoQ29ucyAocmVhZGVyLCByZWFkZXJzX3Jlc3QpKSBpblxuICAgICAgdGFrZV9mb3JtYXRfcmVhZGVycyBuZXdfayBmbXRcbiAgfCBJZ25vcmVkX2NoYXIgICAgICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX2NhbWxfY2hhciAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX3N0cmluZyBfICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX2NhbWxfc3RyaW5nIF8gICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX2ludCAoXywgXykgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX2ludDMyIChfLCBfKSAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX25hdGl2ZWludCAoXywgXykgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX2ludDY0IChfLCBfKSAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX2Zsb2F0IChfLCBfKSAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX2Jvb2wgXyAgICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX2Zvcm1hdF9hcmcgXyAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX2Zvcm1hdF9zdWJzdCAoXywgZm10dHkpIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayBmbXR0eSBmbXRcbiAgfCBJZ25vcmVkX3NjYW5fY2hhcl9zZXQgXyAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX3NjYW5fZ2V0X2NvdW50ZXIgXyAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX3NjYW5fbmV4dF9jaGFyICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKCogR2VuZXJpYyBzY2FubmluZyAqKVxuXG4oKiBNYWtlIGEgZ2VuZXJpYyBzY2FubmluZyBmdW5jdGlvbi4gKilcbigqIFNjYW4gYSBzdHJlYW0gYWNjb3JkaW5nIHRvIGEgZm9ybWF0IGFuZCByZWFkZXJzIG9idGFpbmVkIGJ5XG4gICB0YWtlX2Zvcm1hdF9yZWFkZXJzLCBhbmQgYWdncmVnYXRlIHNjYW5uZWQgdmFsdWVzIGludG8gYW5cbiAgIGhldGVyb2dlbmVvdXMgbGlzdC4gKilcbigqIFJldHVybiB0aGUgaGV0ZXJvZ2VuZW91cyBsaXN0IG9mIHNjYW5uZWQgdmFsdWVzLiAqKVxubGV0IHJlYyBtYWtlX3NjYW5mIDogdHlwZSBhIGMgZCBlIGYuXG4gICAgU2Nhbm5pbmcuaW5fY2hhbm5lbCAtPiAoYSwgU2Nhbm5pbmcuaW5fY2hhbm5lbCwgYywgZCwgZSwgZikgZm10IC0+XG4gICAgICAoZCwgZSkgaGV0ZXJfbGlzdCAtPiAoYSwgZikgaGV0ZXJfbGlzdCA9XG5mdW4gaWIgZm10IHJlYWRlcnMgLT4gbWF0Y2ggZm10IHdpdGhcbiAgfCBDaGFyIHJlc3QgLT5cbiAgICBsZXQgXyA9IHNjYW5fY2hhciAwIGliIGluXG4gICAgbGV0IGMgPSB0b2tlbl9jaGFyIGliIGluXG4gICAgQ29ucyAoYywgbWFrZV9zY2FuZiBpYiByZXN0IHJlYWRlcnMpXG4gIHwgQ2FtbF9jaGFyIHJlc3QgLT5cbiAgICBsZXQgXyA9IHNjYW5fY2FtbF9jaGFyIDAgaWIgaW5cbiAgICBsZXQgYyA9IHRva2VuX2NoYXIgaWIgaW5cbiAgICBDb25zIChjLCBtYWtlX3NjYW5mIGliIHJlc3QgcmVhZGVycylcblxuICB8IFN0cmluZyAocGFkLCBGb3JtYXR0aW5nX2xpdCAoZm10aW5nX2xpdCwgcmVzdCkpIC0+XG4gICAgbGV0IHN0cCwgc3RyID0gc3RvcHBlcl9vZl9mb3JtYXR0aW5nX2xpdCBmbXRpbmdfbGl0IGluXG4gICAgbGV0IHNjYW4gd2lkdGggXyBpYiA9IHNjYW5fc3RyaW5nIChTb21lIHN0cCkgd2lkdGggaWIgaW5cbiAgICBsZXQgc3RyX3Jlc3QgPSBTdHJpbmdfbGl0ZXJhbCAoc3RyLCByZXN0KSBpblxuICAgIHBhZF9wcmVjX3NjYW5mIGliIHN0cl9yZXN0IHJlYWRlcnMgcGFkIE5vX3ByZWNpc2lvbiBzY2FuIHRva2VuX3N0cmluZ1xuICB8IFN0cmluZyAocGFkLCBGb3JtYXR0aW5nX2dlbiAoT3Blbl90YWcgKEZvcm1hdCAoZm10JywgXykpLCByZXN0KSkgLT5cbiAgICBsZXQgc2NhbiB3aWR0aCBfIGliID0gc2Nhbl9zdHJpbmcgKFNvbWUgJ3snKSB3aWR0aCBpYiBpblxuICAgIHBhZF9wcmVjX3NjYW5mIGliIChjb25jYXRfZm10IGZtdCcgcmVzdCkgcmVhZGVycyBwYWQgTm9fcHJlY2lzaW9uIHNjYW5cbiAgICAgICAgICAgICAgICAgICB0b2tlbl9zdHJpbmdcbiAgfCBTdHJpbmcgKHBhZCwgRm9ybWF0dGluZ19nZW4gKE9wZW5fYm94IChGb3JtYXQgKGZtdCcsIF8pKSwgcmVzdCkpIC0+XG4gICAgbGV0IHNjYW4gd2lkdGggXyBpYiA9IHNjYW5fc3RyaW5nIChTb21lICdbJykgd2lkdGggaWIgaW5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiAoY29uY2F0X2ZtdCBmbXQnIHJlc3QpIHJlYWRlcnMgcGFkIE5vX3ByZWNpc2lvbiBzY2FuXG4gICAgICAgICAgICAgICAgICAgdG9rZW5fc3RyaW5nXG4gIHwgU3RyaW5nIChwYWQsIHJlc3QpIC0+XG4gICAgbGV0IHNjYW4gd2lkdGggXyBpYiA9IHNjYW5fc3RyaW5nIE5vbmUgd2lkdGggaWIgaW5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiByZXN0IHJlYWRlcnMgcGFkIE5vX3ByZWNpc2lvbiBzY2FuIHRva2VuX3N0cmluZ1xuXG4gIHwgQ2FtbF9zdHJpbmcgKHBhZCwgcmVzdCkgLT5cbiAgICBsZXQgc2NhbiB3aWR0aCBfIGliID0gc2Nhbl9jYW1sX3N0cmluZyB3aWR0aCBpYiBpblxuICAgIHBhZF9wcmVjX3NjYW5mIGliIHJlc3QgcmVhZGVycyBwYWQgTm9fcHJlY2lzaW9uIHNjYW4gdG9rZW5fc3RyaW5nXG4gIHwgSW50IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIGxldCBjID0gaW50ZWdlcl9jb252ZXJzaW9uX29mX2NoYXIgKGNoYXJfb2ZfaWNvbnYgaWNvbnYpIGluXG4gICAgbGV0IHNjYW4gd2lkdGggXyBpYiA9IHNjYW5faW50X2NvbnZlcnNpb24gYyB3aWR0aCBpYiBpblxuICAgIHBhZF9wcmVjX3NjYW5mIGliIHJlc3QgcmVhZGVycyBwYWQgcHJlYyBzY2FuICh0b2tlbl9pbnQgYylcbiAgfCBJbnQzMiAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBsZXQgYyA9IGludGVnZXJfY29udmVyc2lvbl9vZl9jaGFyIChjaGFyX29mX2ljb252IGljb252KSBpblxuICAgIGxldCBzY2FuIHdpZHRoIF8gaWIgPSBzY2FuX2ludF9jb252ZXJzaW9uIGMgd2lkdGggaWIgaW5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiByZXN0IHJlYWRlcnMgcGFkIHByZWMgc2NhbiAodG9rZW5faW50MzIgYylcbiAgfCBOYXRpdmVpbnQgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbGV0IGMgPSBpbnRlZ2VyX2NvbnZlcnNpb25fb2ZfY2hhciAoY2hhcl9vZl9pY29udiBpY29udikgaW5cbiAgICBsZXQgc2NhbiB3aWR0aCBfIGliID0gc2Nhbl9pbnRfY29udmVyc2lvbiBjIHdpZHRoIGliIGluXG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgcmVzdCByZWFkZXJzIHBhZCBwcmVjIHNjYW4gKHRva2VuX25hdGl2ZWludCBjKVxuICB8IEludDY0IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIGxldCBjID0gaW50ZWdlcl9jb252ZXJzaW9uX29mX2NoYXIgKGNoYXJfb2ZfaWNvbnYgaWNvbnYpIGluXG4gICAgbGV0IHNjYW4gd2lkdGggXyBpYiA9IHNjYW5faW50X2NvbnZlcnNpb24gYyB3aWR0aCBpYiBpblxuICAgIHBhZF9wcmVjX3NjYW5mIGliIHJlc3QgcmVhZGVycyBwYWQgcHJlYyBzY2FuICh0b2tlbl9pbnQ2NCBjKVxuICB8IEZsb2F0ICgoXywgKEZsb2F0X0YgfCBGbG9hdF9DRikpLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgcmVzdCByZWFkZXJzIHBhZCBwcmVjIHNjYW5fY2FtbF9mbG9hdCB0b2tlbl9mbG9hdFxuICB8IEZsb2F0ICgoXywgKEZsb2F0X2YgfCBGbG9hdF9lIHwgRmxvYXRfRSB8IEZsb2F0X2cgfCBGbG9hdF9HKSksXG4gICAgICAgICAgIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiByZXN0IHJlYWRlcnMgcGFkIHByZWMgc2Nhbl9mbG9hdCB0b2tlbl9mbG9hdFxuICB8IEZsb2F0ICgoXywgKEZsb2F0X2ggfCBGbG9hdF9IKSksIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiByZXN0IHJlYWRlcnMgcGFkIHByZWMgc2Nhbl9oZXhfZmxvYXQgdG9rZW5fZmxvYXRcbiAgfCBCb29sIChwYWQsIHJlc3QpIC0+XG4gICAgbGV0IHNjYW4gXyBfIGliID0gc2Nhbl9ib29sIGliIGluXG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgcmVzdCByZWFkZXJzIHBhZCBOb19wcmVjaXNpb24gc2NhbiB0b2tlbl9ib29sXG4gIHwgQWxwaGEgXyAtPlxuICAgIGludmFsaWRfYXJnIFwic2NhbmY6IGJhZCBjb252ZXJzaW9uIFxcXCIlYVxcXCJcIlxuICB8IFRoZXRhIF8gLT5cbiAgICBpbnZhbGlkX2FyZyBcInNjYW5mOiBiYWQgY29udmVyc2lvbiBcXFwiJXRcXFwiXCJcbiAgfCBDdXN0b20gXyAtPlxuICAgIGludmFsaWRfYXJnIFwic2NhbmY6IGJhZCBjb252ZXJzaW9uIFxcXCIlP1xcXCIgKGN1c3RvbSBjb252ZXJ0ZXIpXCJcbiAgfCBSZWFkZXIgZm10X3Jlc3QgLT5cbiAgICBiZWdpbiBtYXRjaCByZWFkZXJzIHdpdGhcbiAgICB8IENvbnMgKHJlYWRlciwgcmVhZGVyc19yZXN0KSAtPlxuICAgICAgICBsZXQgeCA9IHJlYWRlciBpYiBpblxuICAgICAgICBDb25zICh4LCBtYWtlX3NjYW5mIGliIGZtdF9yZXN0IHJlYWRlcnNfcmVzdClcbiAgICB8IE5pbCAtPlxuICAgICAgICBpbnZhbGlkX2FyZyBcInNjYW5mOiBtaXNzaW5nIHJlYWRlclwiXG4gICAgZW5kXG4gIHwgRmx1c2ggcmVzdCAtPlxuICAgIGlmIFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIG1ha2Vfc2NhbmYgaWIgcmVzdCByZWFkZXJzXG4gICAgZWxzZSBiYWRfaW5wdXQgXCJlbmQgb2YgaW5wdXQgbm90IGZvdW5kXCJcblxuICB8IFN0cmluZ19saXRlcmFsIChzdHIsIHJlc3QpIC0+XG4gICAgU3RyaW5nLml0ZXIgKGNoZWNrX2NoYXIgaWIpIHN0cjtcbiAgICBtYWtlX3NjYW5mIGliIHJlc3QgcmVhZGVyc1xuICB8IENoYXJfbGl0ZXJhbCAoY2hyLCByZXN0KSAtPlxuICAgIGNoZWNrX2NoYXIgaWIgY2hyO1xuICAgIG1ha2Vfc2NhbmYgaWIgcmVzdCByZWFkZXJzXG5cbiAgfCBGb3JtYXRfYXJnIChwYWRfb3B0LCBmbXR0eSwgcmVzdCkgLT5cbiAgICBsZXQgXyA9IHNjYW5fY2FtbF9zdHJpbmcgKHdpZHRoX29mX3BhZF9vcHQgcGFkX29wdCkgaWIgaW5cbiAgICBsZXQgcyA9IHRva2VuX3N0cmluZyBpYiBpblxuICAgIGxldCBmbXQgPVxuICAgICAgdHJ5IGZvcm1hdF9vZl9zdHJpbmdfZm10dHkgcyBmbXR0eVxuICAgICAgd2l0aCBGYWlsdXJlIG1zZyAtPiBiYWRfaW5wdXQgbXNnXG4gICAgaW5cbiAgICBDb25zIChmbXQsIG1ha2Vfc2NhbmYgaWIgcmVzdCByZWFkZXJzKVxuICB8IEZvcm1hdF9zdWJzdCAocGFkX29wdCwgZm10dHksIHJlc3QpIC0+XG4gICAgbGV0IF8gPSBzY2FuX2NhbWxfc3RyaW5nICh3aWR0aF9vZl9wYWRfb3B0IHBhZF9vcHQpIGliIGluXG4gICAgbGV0IHMgPSB0b2tlbl9zdHJpbmcgaWIgaW5cbiAgICBsZXQgZm10LCBmbXQnID1cbiAgICAgIHRyeVxuICAgICAgICBsZXQgRm10X0VCQiBmbXQgPSBmbXRfZWJiX29mX3N0cmluZyBzIGluXG4gICAgICAgIGxldCBGbXRfRUJCIGZtdCcgPSBmbXRfZWJiX29mX3N0cmluZyBzIGluXG4gICAgICAgICgqIFRPRE86IGZpbmQgYSB3YXkgdG8gYXZvaWQgcmVwYXJzaW5nIHR3aWNlICopXG5cbiAgICAgICAgKCogVE9ETzogdGhlc2UgdHlwZS1jaGVja3MgYmVsb3cgKmNhbiogZmFpbCBiZWNhdXNlIG9mIHR5cGVcbiAgICAgICAgICAgYW1iaWd1aXR5IGluIHByZXNlbmNlIG9mIGlnbm9yZWQtcmVhZGVyczogXCIlX3IlZFwiIGFuZCBcIiVkJV9yXCJcbiAgICAgICAgICAgYXJlIHR5cGVkIGluIHRoZSBzYW1lIHdheS5cblxuICAgICAgICAgICAjIFNjYW5mLnNzY2FuZiBcIlxcXCIlX3IlZFxcXCIzXCIgXCIlKCVkJV9yJSlcIiBpZ25vcmVcbiAgICAgICAgICAgICAoZnVuIGZtdCBuIC0+IHN0cmluZ19vZl9mb3JtYXQgZm10LCBuKVxuICAgICAgICAgICBFeGNlcHRpb246IENhbWxpbnRlcm5hbEZvcm1hdC5UeXBlX21pc21hdGNoLlxuXG4gICAgICAgICAgIFdlIHNob3VsZCBwcm9wZXJseSBjYXRjaCB0aGlzIGV4Y2VwdGlvbi5cbiAgICAgICAgKilcbiAgICAgICAgdHlwZV9mb3JtYXQgZm10IChlcmFzZV9yZWwgZm10dHkpLFxuICAgICAgICB0eXBlX2Zvcm1hdCBmbXQnIChlcmFzZV9yZWwgKHN5bW0gZm10dHkpKVxuICAgICAgd2l0aCBGYWlsdXJlIG1zZyAtPiBiYWRfaW5wdXQgbXNnXG4gICAgaW5cbiAgICBDb25zIChGb3JtYXQgKGZtdCwgcyksXG4gICAgICAgICAgbWFrZV9zY2FuZiBpYiAoY29uY2F0X2ZtdCBmbXQnIHJlc3QpIHJlYWRlcnMpXG5cbiAgfCBTY2FuX2NoYXJfc2V0ICh3aWR0aF9vcHQsIGNoYXJfc2V0LCBGb3JtYXR0aW5nX2xpdCAoZm10aW5nX2xpdCwgcmVzdCkpIC0+XG4gICAgbGV0IHN0cCwgc3RyID0gc3RvcHBlcl9vZl9mb3JtYXR0aW5nX2xpdCBmbXRpbmdfbGl0IGluXG4gICAgbGV0IHdpZHRoID0gd2lkdGhfb2ZfcGFkX29wdCB3aWR0aF9vcHQgaW5cbiAgICBzY2FuX2NoYXJzX2luX2NoYXJfc2V0IGNoYXJfc2V0IChTb21lIHN0cCkgd2lkdGggaWI7XG4gICAgbGV0IHMgPSB0b2tlbl9zdHJpbmcgaWIgaW5cbiAgICBsZXQgc3RyX3Jlc3QgPSBTdHJpbmdfbGl0ZXJhbCAoc3RyLCByZXN0KSBpblxuICAgIENvbnMgKHMsIG1ha2Vfc2NhbmYgaWIgc3RyX3Jlc3QgcmVhZGVycylcbiAgfCBTY2FuX2NoYXJfc2V0ICh3aWR0aF9vcHQsIGNoYXJfc2V0LCByZXN0KSAtPlxuICAgIGxldCB3aWR0aCA9IHdpZHRoX29mX3BhZF9vcHQgd2lkdGhfb3B0IGluXG4gICAgc2Nhbl9jaGFyc19pbl9jaGFyX3NldCBjaGFyX3NldCBOb25lIHdpZHRoIGliO1xuICAgIGxldCBzID0gdG9rZW5fc3RyaW5nIGliIGluXG4gICAgQ29ucyAocywgbWFrZV9zY2FuZiBpYiByZXN0IHJlYWRlcnMpXG4gIHwgU2Nhbl9nZXRfY291bnRlciAoY291bnRlciwgcmVzdCkgLT5cbiAgICBsZXQgY291bnQgPSBnZXRfY291bnRlciBpYiBjb3VudGVyIGluXG4gICAgQ29ucyAoY291bnQsIG1ha2Vfc2NhbmYgaWIgcmVzdCByZWFkZXJzKVxuICB8IFNjYW5fbmV4dF9jaGFyIHJlc3QgLT5cbiAgICBsZXQgYyA9IFNjYW5uaW5nLmNoZWNrZWRfcGVla19jaGFyIGliIGluXG4gICAgQ29ucyAoYywgbWFrZV9zY2FuZiBpYiByZXN0IHJlYWRlcnMpXG5cbiAgfCBGb3JtYXR0aW5nX2xpdCAoZm9ybWF0dGluZ19saXQsIHJlc3QpIC0+XG4gICAgU3RyaW5nLml0ZXIgKGNoZWNrX2NoYXIgaWIpIChzdHJpbmdfb2ZfZm9ybWF0dGluZ19saXQgZm9ybWF0dGluZ19saXQpO1xuICAgIG1ha2Vfc2NhbmYgaWIgcmVzdCByZWFkZXJzXG4gIHwgRm9ybWF0dGluZ19nZW4gKE9wZW5fdGFnIChGb3JtYXQgKGZtdCcsIF8pKSwgcmVzdCkgLT5cbiAgICBjaGVja19jaGFyIGliICdAJzsgY2hlY2tfY2hhciBpYiAneyc7XG4gICAgbWFrZV9zY2FuZiBpYiAoY29uY2F0X2ZtdCBmbXQnIHJlc3QpIHJlYWRlcnNcbiAgfCBGb3JtYXR0aW5nX2dlbiAoT3Blbl9ib3ggKEZvcm1hdCAoZm10JywgXykpLCByZXN0KSAtPlxuICAgIGNoZWNrX2NoYXIgaWIgJ0AnOyBjaGVja19jaGFyIGliICdbJztcbiAgICBtYWtlX3NjYW5mIGliIChjb25jYXRfZm10IGZtdCcgcmVzdCkgcmVhZGVyc1xuXG4gIHwgSWdub3JlZF9wYXJhbSAoaWduLCByZXN0KSAtPlxuICAgIGxldCBQYXJhbV9mb3JtYXRfRUJCIGZtdCcgPSBwYXJhbV9mb3JtYXRfb2ZfaWdub3JlZF9mb3JtYXQgaWduIHJlc3QgaW5cbiAgICBiZWdpbiBtYXRjaCBtYWtlX3NjYW5mIGliIGZtdCcgcmVhZGVycyB3aXRoXG4gICAgfCBDb25zIChfLCBhcmdfcmVzdCkgLT4gYXJnX3Jlc3RcbiAgICB8IE5pbCAtPiBhc3NlcnQgZmFsc2VcbiAgICBlbmRcblxuICB8IEVuZF9vZl9mb3JtYXQgLT5cbiAgICBOaWxcblxuKCogQ2FzZSBhbmFseXNpcyBvbiBwYWRkaW5nIGFuZCBwcmVjaXNpb24uICopXG4oKiBSZWplY3QgZm9ybWF0cyBjb250YWluaW5nIFwiJSpcIiBvciBcIiUuKlwiLiAqKVxuKCogUGFzcyBwYWRkaW5nIGFuZCBwcmVjaXNpb24gdG8gdGhlIGdlbmVyaWMgc2Nhbm5lciBgc2NhbicuICopXG5hbmQgcGFkX3ByZWNfc2NhbmYgOiB0eXBlIGEgYyBkIGUgZiB4IHkgeiB0IC5cbiAgICBTY2FubmluZy5pbl9jaGFubmVsIC0+IChhLCBTY2FubmluZy5pbl9jaGFubmVsLCBjLCBkLCBlLCBmKSBmbXQgLT5cbiAgICAgIChkLCBlKSBoZXRlcl9saXN0IC0+ICh4LCB5KSBwYWRkaW5nIC0+ICh5LCB6IC0+IGEpIHByZWNpc2lvbiAtPlxuICAgICAgKGludCAtPiBpbnQgLT4gU2Nhbm5pbmcuaW5fY2hhbm5lbCAtPiB0KSAtPlxuICAgICAgKFNjYW5uaW5nLmluX2NoYW5uZWwgLT4geikgLT5cbiAgICAgICh4LCBmKSBoZXRlcl9saXN0ID1cbmZ1biBpYiBmbXQgcmVhZGVycyBwYWQgcHJlYyBzY2FuIHRva2VuIC0+IG1hdGNoIHBhZCwgcHJlYyB3aXRoXG4gIHwgTm9fcGFkZGluZywgTm9fcHJlY2lzaW9uIC0+XG4gICAgbGV0IF8gPSBzY2FuIG1heF9pbnQgbWF4X2ludCBpYiBpblxuICAgIGxldCB4ID0gdG9rZW4gaWIgaW5cbiAgICBDb25zICh4LCBtYWtlX3NjYW5mIGliIGZtdCByZWFkZXJzKVxuICB8IE5vX3BhZGRpbmcsIExpdF9wcmVjaXNpb24gcCAtPlxuICAgIGxldCBfID0gc2NhbiBtYXhfaW50IHAgaWIgaW5cbiAgICBsZXQgeCA9IHRva2VuIGliIGluXG4gICAgQ29ucyAoeCwgbWFrZV9zY2FuZiBpYiBmbXQgcmVhZGVycylcbiAgfCBMaXRfcGFkZGluZyAoKFJpZ2h0IHwgWmVyb3MpLCB3KSwgTm9fcHJlY2lzaW9uIC0+XG4gICAgbGV0IF8gPSBzY2FuIHcgbWF4X2ludCBpYiBpblxuICAgIGxldCB4ID0gdG9rZW4gaWIgaW5cbiAgICBDb25zICh4LCBtYWtlX3NjYW5mIGliIGZtdCByZWFkZXJzKVxuICB8IExpdF9wYWRkaW5nICgoUmlnaHQgfCBaZXJvcyksIHcpLCBMaXRfcHJlY2lzaW9uIHAgLT5cbiAgICBsZXQgXyA9IHNjYW4gdyBwIGliIGluXG4gICAgbGV0IHggPSB0b2tlbiBpYiBpblxuICAgIENvbnMgKHgsIG1ha2Vfc2NhbmYgaWIgZm10IHJlYWRlcnMpXG4gIHwgTGl0X3BhZGRpbmcgKExlZnQsIF8pLCBfIC0+XG4gICAgaW52YWxpZF9hcmcgXCJzY2FuZjogYmFkIGNvbnZlcnNpb24gXFxcIiUtXFxcIlwiXG4gIHwgTGl0X3BhZGRpbmcgKChSaWdodCB8IFplcm9zKSwgXyksIEFyZ19wcmVjaXNpb24gLT5cbiAgICBpbnZhbGlkX2FyZyBcInNjYW5mOiBiYWQgY29udmVyc2lvbiBcXFwiJSpcXFwiXCJcbiAgfCBBcmdfcGFkZGluZyBfLCBfIC0+XG4gICAgaW52YWxpZF9hcmcgXCJzY2FuZjogYmFkIGNvbnZlcnNpb24gXFxcIiUqXFxcIlwiXG4gIHwgTm9fcGFkZGluZywgQXJnX3ByZWNpc2lvbiAtPlxuICAgIGludmFsaWRfYXJnIFwic2NhbmY6IGJhZCBjb252ZXJzaW9uIFxcXCIlKlxcXCJcIlxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgKCogRGVmaW5pbmcgW3NjYW5mXSBhbmQgdmFyaW91cyBmbGF2b3JzIG9mIFtzY2FuZl0gKilcblxudHlwZSAnYSBrc2NhbmZfcmVzdWx0ID0gQXJncyBvZiAnYSB8IEV4YyBvZiBleG5cblxubGV0IGtzY2FuZiBpYiBlZiAoRm9ybWF0IChmbXQsIHN0cikpID1cbiAgbGV0IHJlYyBhcHBseSA6IHR5cGUgYSBiIC4gYSAtPiAoYSwgYikgaGV0ZXJfbGlzdCAtPiBiID1cbiAgICBmdW4gZiBhcmdzIC0+IG1hdGNoIGFyZ3Mgd2l0aFxuICAgIHwgQ29ucyAoeCwgcikgLT4gYXBwbHkgKGYgeCkgclxuICAgIHwgTmlsIC0+IGZcbiAgaW5cbiAgbGV0IGsgcmVhZGVycyBmID1cbiAgICBTY2FubmluZy5yZXNldF90b2tlbiBpYjtcbiAgICBtYXRjaCB0cnkgQXJncyAobWFrZV9zY2FuZiBpYiBmbXQgcmVhZGVycykgd2l0aFxuICAgICAgfCAoU2Nhbl9mYWlsdXJlIF8gfCBGYWlsdXJlIF8gfCBFbmRfb2ZfZmlsZSkgYXMgZXhjIC0+IEV4YyBleGNcbiAgICAgIHwgSW52YWxpZF9hcmd1bWVudCBtc2cgLT5cbiAgICAgICAgaW52YWxpZF9hcmcgKG1zZyBeIFwiIGluIGZvcm1hdCBcXFwiXCIgXiBTdHJpbmcuZXNjYXBlZCBzdHIgXiBcIlxcXCJcIilcbiAgICB3aXRoXG4gICAgICB8IEFyZ3MgYXJncyAtPiBhcHBseSBmIGFyZ3NcbiAgICAgIHwgRXhjIGV4YyAtPiBlZiBpYiBleGNcbiAgaW5cbiAgdGFrZV9mb3JtYXRfcmVhZGVycyBrIGZtdFxuXG4oKioqKVxuXG5sZXQga2JzY2FuZiA9IGtzY2FuZlxubGV0IGJzY2FuZiBpYiBmbXQgPSBrYnNjYW5mIGliIHNjYW5mX2JhZF9pbnB1dCBmbXRcblxubGV0IGtzc2NhbmYgcyBlZiBmbXQgPSBrYnNjYW5mIChTY2FubmluZy5mcm9tX3N0cmluZyBzKSBlZiBmbXRcbmxldCBzc2NhbmYgcyBmbXQgPSBrYnNjYW5mIChTY2FubmluZy5mcm9tX3N0cmluZyBzKSBzY2FuZl9iYWRfaW5wdXQgZm10XG5cbmxldCBzY2FuZiBmbXQgPSBrc2NhbmYgU2Nhbm5pbmcuc3RkaWIgc2NhbmZfYmFkX2lucHV0IGZtdFxuXG4oKioqKVxuXG4oKiBTY2FubmluZyBmb3JtYXQgc3RyaW5ncy4gKilcbmxldCBic2NhbmZfZm9ybWF0IDpcbiAgU2Nhbm5pbmcuaW5fY2hhbm5lbCAtPiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiAtPlxuICAoKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgLT4gJ2cpIC0+ICdnID1cbiAgZnVuIGliIGZvcm1hdCBmIC0+XG4gICAgbGV0IF8gPSBzY2FuX2NhbWxfc3RyaW5nIG1heF9pbnQgaWIgaW5cbiAgICBsZXQgc3RyID0gdG9rZW5fc3RyaW5nIGliIGluXG4gICAgbGV0IGZtdCcgPVxuICAgICAgdHJ5IGZvcm1hdF9vZl9zdHJpbmdfZm9ybWF0IHN0ciBmb3JtYXRcbiAgICAgIHdpdGggRmFpbHVyZSBtc2cgLT4gYmFkX2lucHV0IG1zZyBpblxuICAgIGYgZm10J1xuXG5cbmxldCBzc2NhbmZfZm9ybWF0IDpcbiAgc3RyaW5nIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2IC0+XG4gICgoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiAtPiAnZykgLT4gJ2cgPVxuICBmdW4gcyBmb3JtYXQgZiAtPiBic2NhbmZfZm9ybWF0IChTY2FubmluZy5mcm9tX3N0cmluZyBzKSBmb3JtYXQgZlxuXG5cbmxldCBmb3JtYXRfZnJvbV9zdHJpbmcgcyBmbXQgPVxuICBzc2NhbmZfZm9ybWF0IChcIlxcXCJcIiBeIFN0cmluZy5lc2NhcGVkIHMgXiBcIlxcXCJcIikgZm10IChmdW4geCAtPiB4KVxuXG5cbmxldCB1bmVzY2FwZWQgcyA9XG4gIHNzY2FuZiAoXCJcXFwiXCIgXiBzIF4gXCJcXFwiXCIpIFwiJVMlIVwiIChmdW4geCAtPiB4KVxuXG5cbigqIERlcHJlY2F0ZWQgKilcbmxldCBrZnNjYW5mIGljIGVmIGZtdCA9IGtic2NhbmYgKFNjYW5uaW5nLm1lbW9fZnJvbV9jaGFubmVsIGljKSBlZiBmbXRcbmxldCBmc2NhbmYgaWMgZm10ID0ga3NjYW5mIChTY2FubmluZy5tZW1vX2Zyb21fY2hhbm5lbCBpYykgc2NhbmZfYmFkX2lucHV0IGZtdFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBSZWdpc3RlcmluZyBPQ2FtbCB2YWx1ZXMgd2l0aCB0aGUgQyBydW50aW1lIGZvciBsYXRlciBjYWxsYmFja3MgKilcblxuZXh0ZXJuYWwgcmVnaXN0ZXJfbmFtZWRfdmFsdWUgOiBzdHJpbmcgLT4gT2JqLnQgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfcmVnaXN0ZXJfbmFtZWRfdmFsdWVcIlxuXG5sZXQgcmVnaXN0ZXIgbmFtZSB2ID1cbiAgcmVnaXN0ZXJfbmFtZWRfdmFsdWUgbmFtZSAoT2JqLnJlcHIgdilcblxubGV0IHJlZ2lzdGVyX2V4Y2VwdGlvbiBuYW1lIChleG4gOiBleG4pID1cbiAgbGV0IGV4biA9IE9iai5yZXByIGV4biBpblxuICBsZXQgc2xvdCA9IGlmIE9iai50YWcgZXhuID0gT2JqLm9iamVjdF90YWcgdGhlbiBleG4gZWxzZSBPYmouZmllbGQgZXhuIDAgaW5cbiAgcmVnaXN0ZXJfbmFtZWRfdmFsdWUgbmFtZSBzbG90XG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICBKZXJvbWUgVm91aWxsb24sIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDAyIEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbm9wZW4gT2JqXG5cbigqKioqIE9iamVjdCByZXByZXNlbnRhdGlvbiAqKioqKVxuXG5leHRlcm5hbCBzZXRfaWQ6ICdhIC0+ICdhID0gXCJjYW1sX3NldF9vb19pZFwiIFtAQG5vYWxsb2NdXG5cbigqKioqIE9iamVjdCBjb3B5ICoqKiopXG5cbmxldCBjb3B5IG8gPVxuICBsZXQgbyA9IChPYmoub2JqIChPYmouZHVwIChPYmoucmVwciBvKSkpIGluXG4gIHNldF9pZCBvXG5cbigqKioqIENvbXByZXNzaW9uIG9wdGlvbnMgKioqKilcbigqIFBhcmFtZXRlcnMgKilcbnR5cGUgcGFyYW1zID0ge1xuICAgIG11dGFibGUgY29tcGFjdF90YWJsZSA6IGJvb2w7XG4gICAgbXV0YWJsZSBjb3B5X3BhcmVudCA6IGJvb2w7XG4gICAgbXV0YWJsZSBjbGVhbl93aGVuX2NvcHlpbmcgOiBib29sO1xuICAgIG11dGFibGUgcmV0cnlfY291bnQgOiBpbnQ7XG4gICAgbXV0YWJsZSBidWNrZXRfc21hbGxfc2l6ZSA6IGludFxuICB9XG5cbmxldCBwYXJhbXMgPSB7XG4gIGNvbXBhY3RfdGFibGUgPSB0cnVlO1xuICBjb3B5X3BhcmVudCA9IHRydWU7XG4gIGNsZWFuX3doZW5fY29weWluZyA9IHRydWU7XG4gIHJldHJ5X2NvdW50ID0gMztcbiAgYnVja2V0X3NtYWxsX3NpemUgPSAxNlxufVxuXG4oKioqKiBQYXJhbWV0ZXJzICoqKiopXG5cbmxldCBpbml0aWFsX29iamVjdF9zaXplID0gMlxuXG4oKioqKiBJdGVtcyAqKioqKVxuXG50eXBlIGl0ZW0gPSBEdW1teUEgfCBEdW1teUIgfCBEdW1teUMgb2YgaW50XG5sZXQgXyA9IFtEdW1teUE7IER1bW15QjsgRHVtbXlDIDBdICgqIHRvIGF2b2lkIHdhcm5pbmdzICopXG5cbmxldCBkdW1teV9pdGVtID0gKG1hZ2ljICgpIDogaXRlbSlcblxuKCoqKiogVHlwZXMgKioqKilcblxudHlwZSB0YWdcbnR5cGUgbGFiZWwgPSBpbnRcbnR5cGUgY2xvc3VyZSA9IGl0ZW1cbnR5cGUgdCA9IER1bW15QSB8IER1bW15QiB8IER1bW15QyBvZiBpbnRcbmxldCBfID0gW0R1bW15QTsgRHVtbXlCOyBEdW1teUMgMF0gKCogdG8gYXZvaWQgd2FybmluZ3MgKilcblxudHlwZSBvYmogPSB0IGFycmF5XG5leHRlcm5hbCByZXQgOiAob2JqIC0+ICdhKSAtPiBjbG9zdXJlID0gXCIlaWRlbnRpdHlcIlxuXG4oKioqKiBMYWJlbHMgKioqKilcblxubGV0IHB1YmxpY19tZXRob2RfbGFiZWwgcyA6IHRhZyA9XG4gIGxldCBhY2N1ID0gcmVmIDAgaW5cbiAgZm9yIGkgPSAwIHRvIFN0cmluZy5sZW5ndGggcyAtIDEgZG9cbiAgICBhY2N1IDo9IDIyMyAqICFhY2N1ICsgQ2hhci5jb2RlIHMuW2ldXG4gIGRvbmU7XG4gICgqIHJlZHVjZSB0byAzMSBiaXRzICopXG4gIGFjY3UgOj0gIWFjY3UgbGFuZCAoMSBsc2wgMzEgLSAxKTtcbiAgKCogbWFrZSBpdCBzaWduZWQgZm9yIDY0IGJpdHMgYXJjaGl0ZWN0dXJlcyAqKVxuICBsZXQgdGFnID0gaWYgIWFjY3UgPiAweDNGRkZGRkZGIHRoZW4gIWFjY3UgLSAoMSBsc2wgMzEpIGVsc2UgIWFjY3UgaW5cbiAgKCogUHJpbnRmLmVwcmludGYgXCIlcyA9ICVkXFxuXCIgcyB0YWc7IGZsdXNoIHN0ZGVycjsgKilcbiAgbWFnaWMgdGFnXG5cbigqKioqIFNwYXJzZSBhcnJheSAqKioqKVxuXG5tb2R1bGUgVmFycyA9XG4gIE1hcC5NYWtlKHN0cnVjdCB0eXBlIHQgPSBzdHJpbmcgbGV0IGNvbXBhcmUgKHg6dCkgeSA9IGNvbXBhcmUgeCB5IGVuZClcbnR5cGUgdmFycyA9IGludCBWYXJzLnRcblxubW9kdWxlIE1ldGhzID1cbiAgTWFwLk1ha2Uoc3RydWN0IHR5cGUgdCA9IHN0cmluZyBsZXQgY29tcGFyZSAoeDp0KSB5ID0gY29tcGFyZSB4IHkgZW5kKVxudHlwZSBtZXRocyA9IGxhYmVsIE1ldGhzLnRcbm1vZHVsZSBMYWJzID1cbiAgTWFwLk1ha2Uoc3RydWN0IHR5cGUgdCA9IGxhYmVsIGxldCBjb21wYXJlICh4OnQpIHkgPSBjb21wYXJlIHggeSBlbmQpXG50eXBlIGxhYnMgPSBib29sIExhYnMudFxuXG4oKiBUaGUgY29tcGlsZXIgYXNzdW1lcyB0aGF0IHRoZSBmaXJzdCBmaWVsZCBvZiB0aGlzIHN0cnVjdHVyZSBpcyBbc2l6ZV0uICopXG50eXBlIHRhYmxlID1cbiB7IG11dGFibGUgc2l6ZTogaW50O1xuICAgbXV0YWJsZSBtZXRob2RzOiBjbG9zdXJlIGFycmF5O1xuICAgbXV0YWJsZSBtZXRob2RzX2J5X25hbWU6IG1ldGhzO1xuICAgbXV0YWJsZSBtZXRob2RzX2J5X2xhYmVsOiBsYWJzO1xuICAgbXV0YWJsZSBwcmV2aW91c19zdGF0ZXM6XG4gICAgIChtZXRocyAqIGxhYnMgKiAobGFiZWwgKiBpdGVtKSBsaXN0ICogdmFycyAqXG4gICAgICBsYWJlbCBsaXN0ICogc3RyaW5nIGxpc3QpIGxpc3Q7XG4gICBtdXRhYmxlIGhpZGRlbl9tZXRoczogKGxhYmVsICogaXRlbSkgbGlzdDtcbiAgIG11dGFibGUgdmFyczogdmFycztcbiAgIG11dGFibGUgaW5pdGlhbGl6ZXJzOiAob2JqIC0+IHVuaXQpIGxpc3QgfVxuXG5sZXQgZHVtbXlfdGFibGUgPVxuICB7IG1ldGhvZHMgPSBbfCBkdW1teV9pdGVtIHxdO1xuICAgIG1ldGhvZHNfYnlfbmFtZSA9IE1ldGhzLmVtcHR5O1xuICAgIG1ldGhvZHNfYnlfbGFiZWwgPSBMYWJzLmVtcHR5O1xuICAgIHByZXZpb3VzX3N0YXRlcyA9IFtdO1xuICAgIGhpZGRlbl9tZXRocyA9IFtdO1xuICAgIHZhcnMgPSBWYXJzLmVtcHR5O1xuICAgIGluaXRpYWxpemVycyA9IFtdO1xuICAgIHNpemUgPSAwIH1cblxubGV0IHRhYmxlX2NvdW50ID0gcmVmIDBcblxuKCogZHVtbXlfbWV0IHNob3VsZCBiZSBhIHBvaW50ZXIsIHNvIHVzZSBhbiBhdG9tICopXG5sZXQgZHVtbXlfbWV0IDogaXRlbSA9IG9iaiAoT2JqLm5ld19ibG9jayAwIDApXG4oKiBpZiBkZWJ1Z2dpbmcgaXMgbmVlZGVkLCB0aGlzIGNvdWxkIGJlIGEgZ29vZCBpZGVhOiAqKVxuKCogbGV0IGR1bW15X21ldCAoKSA9IGZhaWx3aXRoIFwiVW5kZWZpbmVkIG1ldGhvZFwiICopXG5cbmxldCByZWMgZml0X3NpemUgbiA9XG4gIGlmIG4gPD0gMiB0aGVuIG4gZWxzZVxuICBmaXRfc2l6ZSAoKG4rMSkvMikgKiAyXG5cbmxldCBuZXdfdGFibGUgcHViX2xhYmVscyA9XG4gIGluY3IgdGFibGVfY291bnQ7XG4gIGxldCBsZW4gPSBBcnJheS5sZW5ndGggcHViX2xhYmVscyBpblxuICBsZXQgbWV0aG9kcyA9IEFycmF5Lm1ha2UgKGxlbioyKzIpIGR1bW15X21ldCBpblxuICBtZXRob2RzLigwKSA8LSBtYWdpYyBsZW47XG4gIG1ldGhvZHMuKDEpIDwtIG1hZ2ljIChmaXRfc2l6ZSBsZW4gKiBTeXMud29yZF9zaXplIC8gOCAtIDEpO1xuICBmb3IgaSA9IDAgdG8gbGVuIC0gMSBkbyBtZXRob2RzLihpKjIrMykgPC0gbWFnaWMgcHViX2xhYmVscy4oaSkgZG9uZTtcbiAgeyBtZXRob2RzID0gbWV0aG9kcztcbiAgICBtZXRob2RzX2J5X25hbWUgPSBNZXRocy5lbXB0eTtcbiAgICBtZXRob2RzX2J5X2xhYmVsID0gTGFicy5lbXB0eTtcbiAgICBwcmV2aW91c19zdGF0ZXMgPSBbXTtcbiAgICBoaWRkZW5fbWV0aHMgPSBbXTtcbiAgICB2YXJzID0gVmFycy5lbXB0eTtcbiAgICBpbml0aWFsaXplcnMgPSBbXTtcbiAgICBzaXplID0gaW5pdGlhbF9vYmplY3Rfc2l6ZSB9XG5cbmxldCByZXNpemUgYXJyYXkgbmV3X3NpemUgPVxuICBsZXQgb2xkX3NpemUgPSBBcnJheS5sZW5ndGggYXJyYXkubWV0aG9kcyBpblxuICBpZiBuZXdfc2l6ZSA+IG9sZF9zaXplIHRoZW4gYmVnaW5cbiAgICBsZXQgbmV3X2J1Y2sgPSBBcnJheS5tYWtlIG5ld19zaXplIGR1bW15X21ldCBpblxuICAgIEFycmF5LmJsaXQgYXJyYXkubWV0aG9kcyAwIG5ld19idWNrIDAgb2xkX3NpemU7XG4gICAgYXJyYXkubWV0aG9kcyA8LSBuZXdfYnVja1xuIGVuZFxuXG5sZXQgcHV0IGFycmF5IGxhYmVsIGVsZW1lbnQgPVxuICByZXNpemUgYXJyYXkgKGxhYmVsICsgMSk7XG4gIGFycmF5Lm1ldGhvZHMuKGxhYmVsKSA8LSBlbGVtZW50XG5cbigqKioqIENsYXNzZXMgKioqKilcblxubGV0IG1ldGhvZF9jb3VudCA9IHJlZiAwXG5sZXQgaW5zdF92YXJfY291bnQgPSByZWYgMFxuXG4oKiB0eXBlIHQgKilcbnR5cGUgbWV0aCA9IGl0ZW1cblxubGV0IG5ld19tZXRob2QgdGFibGUgPVxuICBsZXQgaW5kZXggPSBBcnJheS5sZW5ndGggdGFibGUubWV0aG9kcyBpblxuICByZXNpemUgdGFibGUgKGluZGV4ICsgMSk7XG4gIGluZGV4XG5cbmxldCBnZXRfbWV0aG9kX2xhYmVsIHRhYmxlIG5hbWUgPVxuICB0cnlcbiAgICBNZXRocy5maW5kIG5hbWUgdGFibGUubWV0aG9kc19ieV9uYW1lXG4gIHdpdGggTm90X2ZvdW5kIC0+XG4gICAgbGV0IGxhYmVsID0gbmV3X21ldGhvZCB0YWJsZSBpblxuICAgIHRhYmxlLm1ldGhvZHNfYnlfbmFtZSA8LSBNZXRocy5hZGQgbmFtZSBsYWJlbCB0YWJsZS5tZXRob2RzX2J5X25hbWU7XG4gICAgdGFibGUubWV0aG9kc19ieV9sYWJlbCA8LSBMYWJzLmFkZCBsYWJlbCB0cnVlIHRhYmxlLm1ldGhvZHNfYnlfbGFiZWw7XG4gICAgbGFiZWxcblxubGV0IGdldF9tZXRob2RfbGFiZWxzIHRhYmxlIG5hbWVzID1cbiAgQXJyYXkubWFwIChnZXRfbWV0aG9kX2xhYmVsIHRhYmxlKSBuYW1lc1xuXG5sZXQgc2V0X21ldGhvZCB0YWJsZSBsYWJlbCBlbGVtZW50ID1cbiAgaW5jciBtZXRob2RfY291bnQ7XG4gIGlmIExhYnMuZmluZCBsYWJlbCB0YWJsZS5tZXRob2RzX2J5X2xhYmVsIHRoZW5cbiAgICBwdXQgdGFibGUgbGFiZWwgZWxlbWVudFxuICBlbHNlXG4gICAgdGFibGUuaGlkZGVuX21ldGhzIDwtIChsYWJlbCwgZWxlbWVudCkgOjogdGFibGUuaGlkZGVuX21ldGhzXG5cbmxldCBnZXRfbWV0aG9kIHRhYmxlIGxhYmVsID1cbiAgdHJ5IExpc3QuYXNzb2MgbGFiZWwgdGFibGUuaGlkZGVuX21ldGhzXG4gIHdpdGggTm90X2ZvdW5kIC0+IHRhYmxlLm1ldGhvZHMuKGxhYmVsKVxuXG5sZXQgdG9fbGlzdCBhcnIgPVxuICBpZiBhcnIgPT0gbWFnaWMgMCB0aGVuIFtdIGVsc2UgQXJyYXkudG9fbGlzdCBhcnJcblxubGV0IG5hcnJvdyB0YWJsZSB2YXJzIHZpcnRfbWV0aHMgY29uY3JfbWV0aHMgPVxuICBsZXQgdmFycyA9IHRvX2xpc3QgdmFyc1xuICBhbmQgdmlydF9tZXRocyA9IHRvX2xpc3QgdmlydF9tZXRoc1xuICBhbmQgY29uY3JfbWV0aHMgPSB0b19saXN0IGNvbmNyX21ldGhzIGluXG4gIGxldCB2aXJ0X21ldGhfbGFicyA9IExpc3QubWFwIChnZXRfbWV0aG9kX2xhYmVsIHRhYmxlKSB2aXJ0X21ldGhzIGluXG4gIGxldCBjb25jcl9tZXRoX2xhYnMgPSBMaXN0Lm1hcCAoZ2V0X21ldGhvZF9sYWJlbCB0YWJsZSkgY29uY3JfbWV0aHMgaW5cbiAgdGFibGUucHJldmlvdXNfc3RhdGVzIDwtXG4gICAgICh0YWJsZS5tZXRob2RzX2J5X25hbWUsIHRhYmxlLm1ldGhvZHNfYnlfbGFiZWwsIHRhYmxlLmhpZGRlbl9tZXRocyxcbiAgICAgIHRhYmxlLnZhcnMsIHZpcnRfbWV0aF9sYWJzLCB2YXJzKVxuICAgICA6OiB0YWJsZS5wcmV2aW91c19zdGF0ZXM7XG4gIHRhYmxlLnZhcnMgPC1cbiAgICBWYXJzLmZvbGRcbiAgICAgIChmdW4gbGFiIGluZm8gdHZhcnMgLT5cbiAgICAgICAgaWYgTGlzdC5tZW0gbGFiIHZhcnMgdGhlbiBWYXJzLmFkZCBsYWIgaW5mbyB0dmFycyBlbHNlIHR2YXJzKVxuICAgICAgdGFibGUudmFycyBWYXJzLmVtcHR5O1xuICBsZXQgYnlfbmFtZSA9IHJlZiBNZXRocy5lbXB0eSBpblxuICBsZXQgYnlfbGFiZWwgPSByZWYgTGFicy5lbXB0eSBpblxuICBMaXN0Lml0ZXIyXG4gICAgKGZ1biBtZXQgbGFiZWwgLT5cbiAgICAgICBieV9uYW1lIDo9IE1ldGhzLmFkZCBtZXQgbGFiZWwgIWJ5X25hbWU7XG4gICAgICAgYnlfbGFiZWwgOj1cbiAgICAgICAgICBMYWJzLmFkZCBsYWJlbFxuICAgICAgICAgICAgKHRyeSBMYWJzLmZpbmQgbGFiZWwgdGFibGUubWV0aG9kc19ieV9sYWJlbCB3aXRoIE5vdF9mb3VuZCAtPiB0cnVlKVxuICAgICAgICAgICAgIWJ5X2xhYmVsKVxuICAgIGNvbmNyX21ldGhzIGNvbmNyX21ldGhfbGFicztcbiAgTGlzdC5pdGVyMlxuICAgIChmdW4gbWV0IGxhYmVsIC0+XG4gICAgICAgYnlfbmFtZSA6PSBNZXRocy5hZGQgbWV0IGxhYmVsICFieV9uYW1lO1xuICAgICAgIGJ5X2xhYmVsIDo9IExhYnMuYWRkIGxhYmVsIGZhbHNlICFieV9sYWJlbClcbiAgICB2aXJ0X21ldGhzIHZpcnRfbWV0aF9sYWJzO1xuICB0YWJsZS5tZXRob2RzX2J5X25hbWUgPC0gIWJ5X25hbWU7XG4gIHRhYmxlLm1ldGhvZHNfYnlfbGFiZWwgPC0gIWJ5X2xhYmVsO1xuICB0YWJsZS5oaWRkZW5fbWV0aHMgPC1cbiAgICAgTGlzdC5mb2xkX3JpZ2h0XG4gICAgICAgKGZ1biAoKGxhYiwgXykgYXMgbWV0KSBobSAtPlxuICAgICAgICAgIGlmIExpc3QubWVtIGxhYiB2aXJ0X21ldGhfbGFicyB0aGVuIGhtIGVsc2UgbWV0OjpobSlcbiAgICAgICB0YWJsZS5oaWRkZW5fbWV0aHNcbiAgICAgICBbXVxuXG5sZXQgd2lkZW4gdGFibGUgPVxuICBsZXQgKGJ5X25hbWUsIGJ5X2xhYmVsLCBzYXZlZF9oaWRkZW5fbWV0aHMsIHNhdmVkX3ZhcnMsIHZpcnRfbWV0aHMsIHZhcnMpID1cbiAgICBMaXN0LmhkIHRhYmxlLnByZXZpb3VzX3N0YXRlc1xuICBpblxuICB0YWJsZS5wcmV2aW91c19zdGF0ZXMgPC0gTGlzdC50bCB0YWJsZS5wcmV2aW91c19zdGF0ZXM7XG4gIHRhYmxlLnZhcnMgPC1cbiAgICAgTGlzdC5mb2xkX2xlZnRcbiAgICAgICAoZnVuIHMgdiAtPiBWYXJzLmFkZCB2IChWYXJzLmZpbmQgdiB0YWJsZS52YXJzKSBzKVxuICAgICAgIHNhdmVkX3ZhcnMgdmFycztcbiAgdGFibGUubWV0aG9kc19ieV9uYW1lIDwtIGJ5X25hbWU7XG4gIHRhYmxlLm1ldGhvZHNfYnlfbGFiZWwgPC0gYnlfbGFiZWw7XG4gIHRhYmxlLmhpZGRlbl9tZXRocyA8LVxuICAgICBMaXN0LmZvbGRfcmlnaHRcbiAgICAgICAoZnVuICgobGFiLCBfKSBhcyBtZXQpIGhtIC0+XG4gICAgICAgICAgaWYgTGlzdC5tZW0gbGFiIHZpcnRfbWV0aHMgdGhlbiBobSBlbHNlIG1ldDo6aG0pXG4gICAgICAgdGFibGUuaGlkZGVuX21ldGhzXG4gICAgICAgc2F2ZWRfaGlkZGVuX21ldGhzXG5cbmxldCBuZXdfc2xvdCB0YWJsZSA9XG4gIGxldCBpbmRleCA9IHRhYmxlLnNpemUgaW5cbiAgdGFibGUuc2l6ZSA8LSBpbmRleCArIDE7XG4gIGluZGV4XG5cbmxldCBuZXdfdmFyaWFibGUgdGFibGUgbmFtZSA9XG4gIHRyeSBWYXJzLmZpbmQgbmFtZSB0YWJsZS52YXJzXG4gIHdpdGggTm90X2ZvdW5kIC0+XG4gICAgbGV0IGluZGV4ID0gbmV3X3Nsb3QgdGFibGUgaW5cbiAgICBpZiBuYW1lIDw+IFwiXCIgdGhlbiB0YWJsZS52YXJzIDwtIFZhcnMuYWRkIG5hbWUgaW5kZXggdGFibGUudmFycztcbiAgICBpbmRleFxuXG5sZXQgdG9fYXJyYXkgYXJyID1cbiAgaWYgYXJyID0gT2JqLm1hZ2ljIDAgdGhlbiBbfHxdIGVsc2UgYXJyXG5cbmxldCBuZXdfbWV0aG9kc192YXJpYWJsZXMgdGFibGUgbWV0aHMgdmFscyA9XG4gIGxldCBtZXRocyA9IHRvX2FycmF5IG1ldGhzIGluXG4gIGxldCBubWV0aHMgPSBBcnJheS5sZW5ndGggbWV0aHMgYW5kIG52YWxzID0gQXJyYXkubGVuZ3RoIHZhbHMgaW5cbiAgbGV0IHJlcyA9IEFycmF5Lm1ha2UgKG5tZXRocyArIG52YWxzKSAwIGluXG4gIGZvciBpID0gMCB0byBubWV0aHMgLSAxIGRvXG4gICAgcmVzLihpKSA8LSBnZXRfbWV0aG9kX2xhYmVsIHRhYmxlIG1ldGhzLihpKVxuICBkb25lO1xuICBmb3IgaSA9IDAgdG8gbnZhbHMgLSAxIGRvXG4gICAgcmVzLihpK25tZXRocykgPC0gbmV3X3ZhcmlhYmxlIHRhYmxlIHZhbHMuKGkpXG4gIGRvbmU7XG4gIHJlc1xuXG5sZXQgZ2V0X3ZhcmlhYmxlIHRhYmxlIG5hbWUgPVxuICB0cnkgVmFycy5maW5kIG5hbWUgdGFibGUudmFycyB3aXRoIE5vdF9mb3VuZCAtPiBhc3NlcnQgZmFsc2VcblxubGV0IGdldF92YXJpYWJsZXMgdGFibGUgbmFtZXMgPVxuICBBcnJheS5tYXAgKGdldF92YXJpYWJsZSB0YWJsZSkgbmFtZXNcblxubGV0IGFkZF9pbml0aWFsaXplciB0YWJsZSBmID1cbiAgdGFibGUuaW5pdGlhbGl6ZXJzIDwtIGY6OnRhYmxlLmluaXRpYWxpemVyc1xuXG4oKlxubW9kdWxlIEtleXMgPVxuICBNYXAuTWFrZShzdHJ1Y3QgdHlwZSB0ID0gdGFnIGFycmF5IGxldCBjb21wYXJlICh4OnQpIHkgPSBjb21wYXJlIHggeSBlbmQpXG5sZXQga2V5X21hcCA9IHJlZiBLZXlzLmVtcHR5XG5sZXQgZ2V0X2tleSB0YWdzIDogaXRlbSA9XG4gIHRyeSBtYWdpYyAoS2V5cy5maW5kIHRhZ3MgIWtleV9tYXAgOiB0YWcgYXJyYXkpXG4gIHdpdGggTm90X2ZvdW5kIC0+XG4gICAga2V5X21hcCA6PSBLZXlzLmFkZCB0YWdzIHRhZ3MgIWtleV9tYXA7XG4gICAgbWFnaWMgdGFnc1xuKilcblxubGV0IGNyZWF0ZV90YWJsZSBwdWJsaWNfbWV0aG9kcyA9XG4gIGlmIHB1YmxpY19tZXRob2RzID09IG1hZ2ljIDAgdGhlbiBuZXdfdGFibGUgW3x8XSBlbHNlXG4gICgqIFtwdWJsaWNfbWV0aG9kc10gbXVzdCBiZSBpbiBhc2NlbmRpbmcgb3JkZXIgZm9yIGJ5dGVjb2RlICopXG4gIGxldCB0YWdzID0gQXJyYXkubWFwIHB1YmxpY19tZXRob2RfbGFiZWwgcHVibGljX21ldGhvZHMgaW5cbiAgbGV0IHRhYmxlID0gbmV3X3RhYmxlIHRhZ3MgaW5cbiAgQXJyYXkuaXRlcmlcbiAgICAoZnVuIGkgbWV0IC0+XG4gICAgICBsZXQgbGFiID0gaSoyKzIgaW5cbiAgICAgIHRhYmxlLm1ldGhvZHNfYnlfbmFtZSAgPC0gTWV0aHMuYWRkIG1ldCBsYWIgdGFibGUubWV0aG9kc19ieV9uYW1lO1xuICAgICAgdGFibGUubWV0aG9kc19ieV9sYWJlbCA8LSBMYWJzLmFkZCBsYWIgdHJ1ZSB0YWJsZS5tZXRob2RzX2J5X2xhYmVsKVxuICAgIHB1YmxpY19tZXRob2RzO1xuICB0YWJsZVxuXG5sZXQgaW5pdF9jbGFzcyB0YWJsZSA9XG4gIGluc3RfdmFyX2NvdW50IDo9ICFpbnN0X3Zhcl9jb3VudCArIHRhYmxlLnNpemUgLSAxO1xuICB0YWJsZS5pbml0aWFsaXplcnMgPC0gTGlzdC5yZXYgdGFibGUuaW5pdGlhbGl6ZXJzO1xuICByZXNpemUgdGFibGUgKDMgKyBtYWdpYyB0YWJsZS5tZXRob2RzLigxKSAqIDE2IC8gU3lzLndvcmRfc2l6ZSlcblxubGV0IGluaGVyaXRzIGNsYSB2YWxzIHZpcnRfbWV0aHMgY29uY3JfbWV0aHMgKF8sIHN1cGVyLCBfLCBlbnYpIHRvcCA9XG4gIG5hcnJvdyBjbGEgdmFscyB2aXJ0X21ldGhzIGNvbmNyX21ldGhzO1xuICBsZXQgaW5pdCA9XG4gICAgaWYgdG9wIHRoZW4gc3VwZXIgY2xhIGVudiBlbHNlIE9iai5yZXByIChzdXBlciBjbGEpIGluXG4gIHdpZGVuIGNsYTtcbiAgQXJyYXkuY29uY2F0XG4gICAgW1t8IHJlcHIgaW5pdCB8XTtcbiAgICAgbWFnaWMgKEFycmF5Lm1hcCAoZ2V0X3ZhcmlhYmxlIGNsYSkgKHRvX2FycmF5IHZhbHMpIDogaW50IGFycmF5KTtcbiAgICAgQXJyYXkubWFwXG4gICAgICAgKGZ1biBubSAtPiByZXByIChnZXRfbWV0aG9kIGNsYSAoZ2V0X21ldGhvZF9sYWJlbCBjbGEgbm0pIDogY2xvc3VyZSkpXG4gICAgICAgKHRvX2FycmF5IGNvbmNyX21ldGhzKSBdXG5cbmxldCBtYWtlX2NsYXNzIHB1Yl9tZXRocyBjbGFzc19pbml0ID1cbiAgbGV0IHRhYmxlID0gY3JlYXRlX3RhYmxlIHB1Yl9tZXRocyBpblxuICBsZXQgZW52X2luaXQgPSBjbGFzc19pbml0IHRhYmxlIGluXG4gIGluaXRfY2xhc3MgdGFibGU7XG4gIChlbnZfaW5pdCAoT2JqLnJlcHIgMCksIGNsYXNzX2luaXQsIGVudl9pbml0LCBPYmoucmVwciAwKVxuXG50eXBlIGluaXRfdGFibGUgPSB7IG11dGFibGUgZW52X2luaXQ6IHQ7IG11dGFibGUgY2xhc3NfaW5pdDogdGFibGUgLT4gdCB9XG5cbmxldCBtYWtlX2NsYXNzX3N0b3JlIHB1Yl9tZXRocyBjbGFzc19pbml0IGluaXRfdGFibGUgPVxuICBsZXQgdGFibGUgPSBjcmVhdGVfdGFibGUgcHViX21ldGhzIGluXG4gIGxldCBlbnZfaW5pdCA9IGNsYXNzX2luaXQgdGFibGUgaW5cbiAgaW5pdF9jbGFzcyB0YWJsZTtcbiAgaW5pdF90YWJsZS5jbGFzc19pbml0IDwtIGNsYXNzX2luaXQ7XG4gIGluaXRfdGFibGUuZW52X2luaXQgPC0gZW52X2luaXRcblxubGV0IGR1bW15X2NsYXNzIGxvYyA9XG4gIGxldCB1bmRlZiA9IGZ1biBfIC0+IHJhaXNlIChVbmRlZmluZWRfcmVjdXJzaXZlX21vZHVsZSBsb2MpIGluXG4gIChPYmoubWFnaWMgdW5kZWYsIHVuZGVmLCB1bmRlZiwgT2JqLnJlcHIgMClcblxuKCoqKiogT2JqZWN0cyAqKioqKVxuXG5sZXQgY3JlYXRlX29iamVjdCB0YWJsZSA9XG4gICgqIFhYWCBBcHBlbCBkZSBbb2JqX2Jsb2NrXSB8IENhbGwgdG8gW29ial9ibG9ja10gICopXG4gIGxldCBvYmogPSBPYmoubmV3X2Jsb2NrIE9iai5vYmplY3RfdGFnIHRhYmxlLnNpemUgaW5cbiAgKCogWFhYIEFwcGVsIGRlIFtjYW1sX21vZGlmeV0gfCBDYWxsIHRvIFtjYW1sX21vZGlmeV0gKilcbiAgT2JqLnNldF9maWVsZCBvYmogMCAoT2JqLnJlcHIgdGFibGUubWV0aG9kcyk7XG4gIE9iai5vYmogKHNldF9pZCBvYmopXG5cbmxldCBjcmVhdGVfb2JqZWN0X29wdCBvYmpfMCB0YWJsZSA9XG4gIGlmIChPYmoubWFnaWMgb2JqXzAgOiBib29sKSB0aGVuIG9ial8wIGVsc2UgYmVnaW5cbiAgICAoKiBYWFggQXBwZWwgZGUgW29ial9ibG9ja10gfCBDYWxsIHRvIFtvYmpfYmxvY2tdICAqKVxuICAgIGxldCBvYmogPSBPYmoubmV3X2Jsb2NrIE9iai5vYmplY3RfdGFnIHRhYmxlLnNpemUgaW5cbiAgICAoKiBYWFggQXBwZWwgZGUgW2NhbWxfbW9kaWZ5XSB8IENhbGwgdG8gW2NhbWxfbW9kaWZ5XSAqKVxuICAgIE9iai5zZXRfZmllbGQgb2JqIDAgKE9iai5yZXByIHRhYmxlLm1ldGhvZHMpO1xuICAgIE9iai5vYmogKHNldF9pZCBvYmopXG4gIGVuZFxuXG5sZXQgcmVjIGl0ZXJfZiBvYmogPVxuICBmdW5jdGlvblxuICAgIFtdICAgLT4gKClcbiAgfCBmOjpsIC0+IGYgb2JqOyBpdGVyX2Ygb2JqIGxcblxubGV0IHJ1bl9pbml0aWFsaXplcnMgb2JqIHRhYmxlID1cbiAgbGV0IGluaXRzID0gdGFibGUuaW5pdGlhbGl6ZXJzIGluXG4gIGlmIGluaXRzIDw+IFtdIHRoZW5cbiAgICBpdGVyX2Ygb2JqIGluaXRzXG5cbmxldCBydW5faW5pdGlhbGl6ZXJzX29wdCBvYmpfMCBvYmogdGFibGUgPVxuICBpZiAoT2JqLm1hZ2ljIG9ial8wIDogYm9vbCkgdGhlbiBvYmogZWxzZSBiZWdpblxuICAgIGxldCBpbml0cyA9IHRhYmxlLmluaXRpYWxpemVycyBpblxuICAgIGlmIGluaXRzIDw+IFtdIHRoZW4gaXRlcl9mIG9iaiBpbml0cztcbiAgICBvYmpcbiAgZW5kXG5cbmxldCBjcmVhdGVfb2JqZWN0X2FuZF9ydW5faW5pdGlhbGl6ZXJzIG9ial8wIHRhYmxlID1cbiAgaWYgKE9iai5tYWdpYyBvYmpfMCA6IGJvb2wpIHRoZW4gb2JqXzAgZWxzZSBiZWdpblxuICAgIGxldCBvYmogPSBjcmVhdGVfb2JqZWN0IHRhYmxlIGluXG4gICAgcnVuX2luaXRpYWxpemVycyBvYmogdGFibGU7XG4gICAgb2JqXG4gIGVuZFxuXG4oKiBFcXVpdmFsZW50IHByaW1pdGl2ZSBiZWxvd1xubGV0IHNlbmRzZWxmIG9iaiBsYWIgPVxuICAobWFnaWMgb2JqIDogKG9iaiAtPiB0KSBhcnJheSBhcnJheSkuKDApLihsYWIpIG9ialxuKilcbmV4dGVybmFsIHNlbmQgOiBvYmogLT4gdGFnIC0+ICdhID0gXCIlc2VuZFwiXG5leHRlcm5hbCBzZW5kY2FjaGUgOiBvYmogLT4gdGFnIC0+IHQgLT4gaW50IC0+ICdhID0gXCIlc2VuZGNhY2hlXCJcbmV4dGVybmFsIHNlbmRzZWxmIDogb2JqIC0+IGxhYmVsIC0+ICdhID0gXCIlc2VuZHNlbGZcIlxuZXh0ZXJuYWwgZ2V0X3B1YmxpY19tZXRob2QgOiBvYmogLT4gdGFnIC0+IGNsb3N1cmVcbiAgICA9IFwiY2FtbF9nZXRfcHVibGljX21ldGhvZFwiIFtAQG5vYWxsb2NdXG5cbigqKioqIHRhYmxlIGNvbGxlY3Rpb24gYWNjZXNzICoqKiopXG5cbnR5cGUgdGFibGVzID1cbiAgfCBFbXB0eVxuICB8IENvbnMgb2Yge2tleSA6IGNsb3N1cmU7IG11dGFibGUgZGF0YTogdGFibGVzOyBtdXRhYmxlIG5leHQ6IHRhYmxlc31cblxubGV0IHNldF9kYXRhIHRhYmxlcyB2ID0gbWF0Y2ggdGFibGVzIHdpdGhcbiAgfCBFbXB0eSAtPiBhc3NlcnQgZmFsc2VcbiAgfCBDb25zIHRhYmxlcyAtPiB0YWJsZXMuZGF0YSA8LSB2XG5sZXQgc2V0X25leHQgdGFibGVzIHYgPSBtYXRjaCB0YWJsZXMgd2l0aFxuICB8IEVtcHR5IC0+IGFzc2VydCBmYWxzZVxuICB8IENvbnMgdGFibGVzIC0+IHRhYmxlcy5uZXh0IDwtIHZcbmxldCBnZXRfa2V5ID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPiBhc3NlcnQgZmFsc2VcbiAgfCBDb25zIHRhYmxlcyAtPiB0YWJsZXMua2V5XG5sZXQgZ2V0X2RhdGEgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+IGFzc2VydCBmYWxzZVxuICB8IENvbnMgdGFibGVzIC0+IHRhYmxlcy5kYXRhXG5sZXQgZ2V0X25leHQgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+IGFzc2VydCBmYWxzZVxuICB8IENvbnMgdGFibGVzIC0+IHRhYmxlcy5uZXh0XG5cbmxldCBidWlsZF9wYXRoIG4ga2V5cyB0YWJsZXMgPVxuICBsZXQgcmVzID0gQ29ucyB7a2V5ID0gT2JqLm1hZ2ljIDA7IGRhdGEgPSBFbXB0eTsgbmV4dCA9IEVtcHR5fSBpblxuICBsZXQgciA9IHJlZiByZXMgaW5cbiAgZm9yIGkgPSAwIHRvIG4gZG9cbiAgICByIDo9IENvbnMge2tleSA9IGtleXMuKGkpOyBkYXRhID0gIXI7IG5leHQgPSBFbXB0eX1cbiAgZG9uZTtcbiAgc2V0X2RhdGEgdGFibGVzICFyO1xuICByZXNcblxubGV0IHJlYyBsb29rdXBfa2V5cyBpIGtleXMgdGFibGVzID1cbiAgaWYgaSA8IDAgdGhlbiB0YWJsZXMgZWxzZVxuICBsZXQga2V5ID0ga2V5cy4oaSkgaW5cbiAgbGV0IHJlYyBsb29rdXBfa2V5ICh0YWJsZXM6dGFibGVzKSA9XG4gICAgaWYgZ2V0X2tleSB0YWJsZXMgPT0ga2V5IHRoZW5cbiAgICAgIG1hdGNoIGdldF9kYXRhIHRhYmxlcyB3aXRoXG4gICAgICB8IEVtcHR5IC0+IGFzc2VydCBmYWxzZVxuICAgICAgfCBDb25zIF8gYXMgdGFibGVzX2RhdGEgLT5cbiAgICAgICAgICBsb29rdXBfa2V5cyAoaS0xKSBrZXlzIHRhYmxlc19kYXRhXG4gICAgZWxzZVxuICAgICAgbWF0Y2ggZ2V0X25leHQgdGFibGVzIHdpdGhcbiAgICAgIHwgQ29ucyBfIGFzIG5leHQgLT4gbG9va3VwX2tleSBuZXh0XG4gICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgbGV0IG5leHQgOiB0YWJsZXMgPSBDb25zIHtrZXk7IGRhdGEgPSBFbXB0eTsgbmV4dCA9IEVtcHR5fSBpblxuICAgICAgICAgIHNldF9uZXh0IHRhYmxlcyBuZXh0O1xuICAgICAgICAgIGJ1aWxkX3BhdGggKGktMSkga2V5cyBuZXh0XG4gIGluXG4gIGxvb2t1cF9rZXkgdGFibGVzXG5cbmxldCBsb29rdXBfdGFibGVzIHJvb3Qga2V5cyA9XG4gIG1hdGNoIGdldF9kYXRhIHJvb3Qgd2l0aFxuICB8IENvbnMgXyBhcyByb290X2RhdGEgLT5cbiAgICBsb29rdXBfa2V5cyAoQXJyYXkubGVuZ3RoIGtleXMgLSAxKSBrZXlzIHJvb3RfZGF0YVxuICB8IEVtcHR5IC0+XG4gICAgYnVpbGRfcGF0aCAoQXJyYXkubGVuZ3RoIGtleXMgLSAxKSBrZXlzIHJvb3RcblxuKCoqKiogYnVpbHRpbiBtZXRob2RzICoqKiopXG5cbmxldCBnZXRfY29uc3QgeCA9IHJldCAoZnVuIF9vYmogLT4geClcbmxldCBnZXRfdmFyIG4gICA9IHJldCAoZnVuIG9iaiAtPiBBcnJheS51bnNhZmVfZ2V0IG9iaiBuKVxubGV0IGdldF9lbnYgZSBuID1cbiAgcmV0IChmdW4gb2JqIC0+XG4gICAgQXJyYXkudW5zYWZlX2dldCAoT2JqLm1hZ2ljIChBcnJheS51bnNhZmVfZ2V0IG9iaiBlKSA6IG9iaikgbilcbmxldCBnZXRfbWV0aCBuICA9IHJldCAoZnVuIG9iaiAtPiBzZW5kc2VsZiBvYmogbilcbmxldCBzZXRfdmFyIG4gICA9IHJldCAoZnVuIG9iaiB4IC0+IEFycmF5LnVuc2FmZV9zZXQgb2JqIG4geClcbmxldCBhcHBfY29uc3QgZiB4ID0gcmV0IChmdW4gX29iaiAtPiBmIHgpXG5sZXQgYXBwX3ZhciBmIG4gICA9IHJldCAoZnVuIG9iaiAtPiBmIChBcnJheS51bnNhZmVfZ2V0IG9iaiBuKSlcbmxldCBhcHBfZW52IGYgZSBuID1cbiAgcmV0IChmdW4gb2JqIC0+XG4gICAgZiAoQXJyYXkudW5zYWZlX2dldCAoT2JqLm1hZ2ljIChBcnJheS51bnNhZmVfZ2V0IG9iaiBlKSA6IG9iaikgbikpXG5sZXQgYXBwX21ldGggZiBuICA9IHJldCAoZnVuIG9iaiAtPiBmIChzZW5kc2VsZiBvYmogbikpXG5sZXQgYXBwX2NvbnN0X2NvbnN0IGYgeCB5ID0gcmV0IChmdW4gX29iaiAtPiBmIHggeSlcbmxldCBhcHBfY29uc3RfdmFyIGYgeCBuICAgPSByZXQgKGZ1biBvYmogLT4gZiB4IChBcnJheS51bnNhZmVfZ2V0IG9iaiBuKSlcbmxldCBhcHBfY29uc3RfbWV0aCBmIHggbiA9IHJldCAoZnVuIG9iaiAtPiBmIHggKHNlbmRzZWxmIG9iaiBuKSlcbmxldCBhcHBfdmFyX2NvbnN0IGYgbiB4ID0gcmV0IChmdW4gb2JqIC0+IGYgKEFycmF5LnVuc2FmZV9nZXQgb2JqIG4pIHgpXG5sZXQgYXBwX21ldGhfY29uc3QgZiBuIHggPSByZXQgKGZ1biBvYmogLT4gZiAoc2VuZHNlbGYgb2JqIG4pIHgpXG5sZXQgYXBwX2NvbnN0X2VudiBmIHggZSBuID1cbiAgcmV0IChmdW4gb2JqIC0+XG4gICAgZiB4IChBcnJheS51bnNhZmVfZ2V0IChPYmoubWFnaWMgKEFycmF5LnVuc2FmZV9nZXQgb2JqIGUpIDogb2JqKSBuKSlcbmxldCBhcHBfZW52X2NvbnN0IGYgZSBuIHggPVxuICByZXQgKGZ1biBvYmogLT5cbiAgICBmIChBcnJheS51bnNhZmVfZ2V0IChPYmoubWFnaWMgKEFycmF5LnVuc2FmZV9nZXQgb2JqIGUpIDogb2JqKSBuKSB4KVxubGV0IG1ldGhfYXBwX2NvbnN0IG4geCA9IHJldCAoZnVuIG9iaiAtPiAoc2VuZHNlbGYgb2JqIG4gOiBfIC0+IF8pIHgpXG5sZXQgbWV0aF9hcHBfdmFyIG4gbSA9XG4gIHJldCAoZnVuIG9iaiAtPiAoc2VuZHNlbGYgb2JqIG4gOiBfIC0+IF8pIChBcnJheS51bnNhZmVfZ2V0IG9iaiBtKSlcbmxldCBtZXRoX2FwcF9lbnYgbiBlIG0gPVxuICByZXQgKGZ1biBvYmogLT4gKHNlbmRzZWxmIG9iaiBuIDogXyAtPiBfKVxuICAgICAgKEFycmF5LnVuc2FmZV9nZXQgKE9iai5tYWdpYyAoQXJyYXkudW5zYWZlX2dldCBvYmogZSkgOiBvYmopIG0pKVxubGV0IG1ldGhfYXBwX21ldGggbiBtID1cbiAgcmV0IChmdW4gb2JqIC0+IChzZW5kc2VsZiBvYmogbiA6IF8gLT4gXykgKHNlbmRzZWxmIG9iaiBtKSlcbmxldCBzZW5kX2NvbnN0IG0geCBjID1cbiAgcmV0IChmdW4gb2JqIC0+IHNlbmRjYWNoZSB4IG0gKEFycmF5LnVuc2FmZV9nZXQgb2JqIDApIGMpXG5sZXQgc2VuZF92YXIgbSBuIGMgPVxuICByZXQgKGZ1biBvYmogLT5cbiAgICBzZW5kY2FjaGUgKE9iai5tYWdpYyAoQXJyYXkudW5zYWZlX2dldCBvYmogbikgOiBvYmopIG1cbiAgICAgIChBcnJheS51bnNhZmVfZ2V0IG9iaiAwKSBjKVxubGV0IHNlbmRfZW52IG0gZSBuIGMgPVxuICByZXQgKGZ1biBvYmogLT5cbiAgICBzZW5kY2FjaGVcbiAgICAgIChPYmoubWFnaWMgKEFycmF5LnVuc2FmZV9nZXRcbiAgICAgICAgICAgICAgICAgICAgKE9iai5tYWdpYyAoQXJyYXkudW5zYWZlX2dldCBvYmogZSkgOiBvYmopIG4pIDogb2JqKVxuICAgICAgbSAoQXJyYXkudW5zYWZlX2dldCBvYmogMCkgYylcbmxldCBzZW5kX21ldGggbSBuIGMgPVxuICByZXQgKGZ1biBvYmogLT5cbiAgICBzZW5kY2FjaGUgKHNlbmRzZWxmIG9iaiBuKSBtIChBcnJheS51bnNhZmVfZ2V0IG9iaiAwKSBjKVxubGV0IG5ld19jYWNoZSB0YWJsZSA9XG4gIGxldCBuID0gbmV3X21ldGhvZCB0YWJsZSBpblxuICBsZXQgbiA9XG4gICAgaWYgbiBtb2QgMiA9IDAgfHwgbiA+IDIgKyBtYWdpYyB0YWJsZS5tZXRob2RzLigxKSAqIDE2IC8gU3lzLndvcmRfc2l6ZVxuICAgIHRoZW4gbiBlbHNlIG5ld19tZXRob2QgdGFibGVcbiAgaW5cbiAgdGFibGUubWV0aG9kcy4obikgPC0gT2JqLm1hZ2ljIDA7XG4gIG5cblxudHlwZSBpbXBsID1cbiAgICBHZXRDb25zdFxuICB8IEdldFZhclxuICB8IEdldEVudlxuICB8IEdldE1ldGhcbiAgfCBTZXRWYXJcbiAgfCBBcHBDb25zdFxuICB8IEFwcFZhclxuICB8IEFwcEVudlxuICB8IEFwcE1ldGhcbiAgfCBBcHBDb25zdENvbnN0XG4gIHwgQXBwQ29uc3RWYXJcbiAgfCBBcHBDb25zdEVudlxuICB8IEFwcENvbnN0TWV0aFxuICB8IEFwcFZhckNvbnN0XG4gIHwgQXBwRW52Q29uc3RcbiAgfCBBcHBNZXRoQ29uc3RcbiAgfCBNZXRoQXBwQ29uc3RcbiAgfCBNZXRoQXBwVmFyXG4gIHwgTWV0aEFwcEVudlxuICB8IE1ldGhBcHBNZXRoXG4gIHwgU2VuZENvbnN0XG4gIHwgU2VuZFZhclxuICB8IFNlbmRFbnZcbiAgfCBTZW5kTWV0aFxuICB8IENsb3N1cmUgb2YgY2xvc3VyZVxuXG5sZXQgbWV0aG9kX2ltcGwgdGFibGUgaSBhcnIgPVxuICBsZXQgbmV4dCAoKSA9IGluY3IgaTsgbWFnaWMgYXJyLighaSkgaW5cbiAgbWF0Y2ggbmV4dCgpIHdpdGhcbiAgICBHZXRDb25zdCAtPiBsZXQgeCA6IHQgPSBuZXh0KCkgaW4gZ2V0X2NvbnN0IHhcbiAgfCBHZXRWYXIgICAtPiBsZXQgbiA9IG5leHQoKSBpbiBnZXRfdmFyIG5cbiAgfCBHZXRFbnYgICAtPiBsZXQgZSA9IG5leHQoKSBpbiBsZXQgbiA9IG5leHQoKSBpbiBnZXRfZW52IGUgblxuICB8IEdldE1ldGggIC0+IGxldCBuID0gbmV4dCgpIGluIGdldF9tZXRoIG5cbiAgfCBTZXRWYXIgICAtPiBsZXQgbiA9IG5leHQoKSBpbiBzZXRfdmFyIG5cbiAgfCBBcHBDb25zdCAtPiBsZXQgZiA9IG5leHQoKSBpbiBsZXQgeCA9IG5leHQoKSBpbiBhcHBfY29uc3QgZiB4XG4gIHwgQXBwVmFyICAgLT4gbGV0IGYgPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0ICgpIGluIGFwcF92YXIgZiBuXG4gIHwgQXBwRW52ICAgLT5cbiAgICAgIGxldCBmID0gbmV4dCgpIGluICBsZXQgZSA9IG5leHQoKSBpbiBsZXQgbiA9IG5leHQoKSBpblxuICAgICAgYXBwX2VudiBmIGUgblxuICB8IEFwcE1ldGggIC0+IGxldCBmID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCAoKSBpbiBhcHBfbWV0aCBmIG5cbiAgfCBBcHBDb25zdENvbnN0IC0+XG4gICAgICBsZXQgZiA9IG5leHQoKSBpbiBsZXQgeCA9IG5leHQoKSBpbiBsZXQgeSA9IG5leHQoKSBpblxuICAgICAgYXBwX2NvbnN0X2NvbnN0IGYgeCB5XG4gIHwgQXBwQ29uc3RWYXIgLT5cbiAgICAgIGxldCBmID0gbmV4dCgpIGluIGxldCB4ID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCgpIGluXG4gICAgICBhcHBfY29uc3RfdmFyIGYgeCBuXG4gIHwgQXBwQ29uc3RFbnYgLT5cbiAgICAgIGxldCBmID0gbmV4dCgpIGluIGxldCB4ID0gbmV4dCgpIGluIGxldCBlID0gbmV4dCAoKSBpbiBsZXQgbiA9IG5leHQoKSBpblxuICAgICAgYXBwX2NvbnN0X2VudiBmIHggZSBuXG4gIHwgQXBwQ29uc3RNZXRoIC0+XG4gICAgICBsZXQgZiA9IG5leHQoKSBpbiBsZXQgeCA9IG5leHQoKSBpbiBsZXQgbiA9IG5leHQoKSBpblxuICAgICAgYXBwX2NvbnN0X21ldGggZiB4IG5cbiAgfCBBcHBWYXJDb25zdCAtPlxuICAgICAgbGV0IGYgPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0KCkgaW4gbGV0IHggPSBuZXh0KCkgaW5cbiAgICAgIGFwcF92YXJfY29uc3QgZiBuIHhcbiAgfCBBcHBFbnZDb25zdCAtPlxuICAgICAgbGV0IGYgPSBuZXh0KCkgaW4gbGV0IGUgPSBuZXh0ICgpIGluIGxldCBuID0gbmV4dCgpIGluIGxldCB4ID0gbmV4dCgpIGluXG4gICAgICBhcHBfZW52X2NvbnN0IGYgZSBuIHhcbiAgfCBBcHBNZXRoQ29uc3QgLT5cbiAgICAgIGxldCBmID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCgpIGluIGxldCB4ID0gbmV4dCgpIGluXG4gICAgICBhcHBfbWV0aF9jb25zdCBmIG4geFxuICB8IE1ldGhBcHBDb25zdCAtPlxuICAgICAgbGV0IG4gPSBuZXh0KCkgaW4gbGV0IHggPSBuZXh0KCkgaW4gbWV0aF9hcHBfY29uc3QgbiB4XG4gIHwgTWV0aEFwcFZhciAtPlxuICAgICAgbGV0IG4gPSBuZXh0KCkgaW4gbGV0IG0gPSBuZXh0KCkgaW4gbWV0aF9hcHBfdmFyIG4gbVxuICB8IE1ldGhBcHBFbnYgLT5cbiAgICAgIGxldCBuID0gbmV4dCgpIGluIGxldCBlID0gbmV4dCgpIGluIGxldCBtID0gbmV4dCgpIGluXG4gICAgICBtZXRoX2FwcF9lbnYgbiBlIG1cbiAgfCBNZXRoQXBwTWV0aCAtPlxuICAgICAgbGV0IG4gPSBuZXh0KCkgaW4gbGV0IG0gPSBuZXh0KCkgaW4gbWV0aF9hcHBfbWV0aCBuIG1cbiAgfCBTZW5kQ29uc3QgLT5cbiAgICAgIGxldCBtID0gbmV4dCgpIGluIGxldCB4ID0gbmV4dCgpIGluIHNlbmRfY29uc3QgbSB4IChuZXdfY2FjaGUgdGFibGUpXG4gIHwgU2VuZFZhciAtPlxuICAgICAgbGV0IG0gPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0ICgpIGluIHNlbmRfdmFyIG0gbiAobmV3X2NhY2hlIHRhYmxlKVxuICB8IFNlbmRFbnYgLT5cbiAgICAgIGxldCBtID0gbmV4dCgpIGluIGxldCBlID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCgpIGluXG4gICAgICBzZW5kX2VudiBtIGUgbiAobmV3X2NhY2hlIHRhYmxlKVxuICB8IFNlbmRNZXRoIC0+XG4gICAgICBsZXQgbSA9IG5leHQoKSBpbiBsZXQgbiA9IG5leHQgKCkgaW4gc2VuZF9tZXRoIG0gbiAobmV3X2NhY2hlIHRhYmxlKVxuICB8IENsb3N1cmUgXyBhcyBjbG8gLT4gbWFnaWMgY2xvXG5cbmxldCBzZXRfbWV0aG9kcyB0YWJsZSBtZXRob2RzID1cbiAgbGV0IGxlbiA9IEFycmF5Lmxlbmd0aCBtZXRob2RzIGluIGxldCBpID0gcmVmIDAgaW5cbiAgd2hpbGUgIWkgPCBsZW4gZG9cbiAgICBsZXQgbGFiZWwgPSBtZXRob2RzLighaSkgaW4gbGV0IGNsbyA9IG1ldGhvZF9pbXBsIHRhYmxlIGkgbWV0aG9kcyBpblxuICAgIHNldF9tZXRob2QgdGFibGUgbGFiZWwgY2xvO1xuICAgIGluY3IgaVxuICBkb25lXG5cbigqKioqIFN0YXRpc3RpY3MgKioqKilcblxudHlwZSBzdGF0cyA9XG4gIHsgY2xhc3NlczogaW50OyBtZXRob2RzOiBpbnQ7IGluc3RfdmFyczogaW50OyB9XG5cbmxldCBzdGF0cyAoKSA9XG4gIHsgY2xhc3NlcyA9ICF0YWJsZV9jb3VudDtcbiAgICBtZXRob2RzID0gIW1ldGhvZF9jb3VudDsgaW5zdF92YXJzID0gIWluc3RfdmFyX2NvdW50OyB9XG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUgdG9rZW4gPVxuICAgIEt3ZCBvZiBzdHJpbmdcbiAgfCBJZGVudCBvZiBzdHJpbmdcbiAgfCBJbnQgb2YgaW50XG4gIHwgRmxvYXQgb2YgZmxvYXRcbiAgfCBTdHJpbmcgb2Ygc3RyaW5nXG4gIHwgQ2hhciBvZiBjaGFyXG5cbigqIFRoZSBzdHJpbmcgYnVmZmVyaW5nIG1hY2hpbmVyeSAqKVxuXG5sZXQgaW5pdGlhbF9idWZmZXIgPSBCeXRlcy5jcmVhdGUgMzJcblxubGV0IGJ1ZmZlciA9IHJlZiBpbml0aWFsX2J1ZmZlclxubGV0IGJ1ZnBvcyA9IHJlZiAwXG5cbmxldCByZXNldF9idWZmZXIgKCkgPSBidWZmZXIgOj0gaW5pdGlhbF9idWZmZXI7IGJ1ZnBvcyA6PSAwXG5cbmxldCBzdG9yZSBjID1cbiAgaWYgIWJ1ZnBvcyA+PSBCeXRlcy5sZW5ndGggIWJ1ZmZlciB0aGVuIGJlZ2luXG4gICAgbGV0IG5ld2J1ZmZlciA9IEJ5dGVzLmNyZWF0ZSAoMiAqICFidWZwb3MpIGluXG4gICAgQnl0ZXMuYmxpdCAhYnVmZmVyIDAgbmV3YnVmZmVyIDAgIWJ1ZnBvcztcbiAgICBidWZmZXIgOj0gbmV3YnVmZmVyXG4gIGVuZDtcbiAgQnl0ZXMuc2V0ICFidWZmZXIgIWJ1ZnBvcyBjO1xuICBpbmNyIGJ1ZnBvc1xuXG5sZXQgZ2V0X3N0cmluZyAoKSA9XG4gIGxldCBzID0gQnl0ZXMuc3ViX3N0cmluZyAhYnVmZmVyIDAgIWJ1ZnBvcyBpbiBidWZmZXIgOj0gaW5pdGlhbF9idWZmZXI7IHNcblxuKCogVGhlIGxleGVyICopXG5cbmxldCBtYWtlX2xleGVyIGtleXdvcmRzID1cbiAgbGV0IGt3ZF90YWJsZSA9IEhhc2h0YmwuY3JlYXRlIDE3IGluXG4gIExpc3QuaXRlciAoZnVuIHMgLT4gSGFzaHRibC5hZGQga3dkX3RhYmxlIHMgKEt3ZCBzKSkga2V5d29yZHM7XG4gIGxldCBpZGVudF9vcl9rZXl3b3JkIGlkID1cbiAgICB0cnkgSGFzaHRibC5maW5kIGt3ZF90YWJsZSBpZCB3aXRoXG4gICAgICBOb3RfZm91bmQgLT4gSWRlbnQgaWRcbiAgYW5kIGtleXdvcmRfb3JfZXJyb3IgYyA9XG4gICAgbGV0IHMgPSBTdHJpbmcubWFrZSAxIGMgaW5cbiAgICB0cnkgSGFzaHRibC5maW5kIGt3ZF90YWJsZSBzIHdpdGhcbiAgICAgIE5vdF9mb3VuZCAtPiByYWlzZSAoU3RyZWFtLkVycm9yIChcIklsbGVnYWwgY2hhcmFjdGVyIFwiIF4gcykpXG4gIGluXG4gIGxldCByZWMgbmV4dF90b2tlbiAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICgnICcgfCAnXFwwMTAnIHwgJ1xcMDEzJyB8ICdcXDAwOScgfCAnXFwwMjYnIHwgJ1xcMDEyJykgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fOyBuZXh0X3Rva2VuIHN0cm1fX1xuICAgIHwgU29tZSAoJ0EnLi4nWicgfCAnYScuLid6JyB8ICdfJyB8ICdcXDE5MicuLidcXDI1NScgYXMgYykgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fO1xuICAgICAgICBsZXQgcyA9IHN0cm1fXyBpbiByZXNldF9idWZmZXIgKCk7IHN0b3JlIGM7IGlkZW50IHNcbiAgICB8IFNvbWVcbiAgICAgICAgKCchJyB8ICclJyB8ICcmJyB8ICckJyB8ICcjJyB8ICcrJyB8ICcvJyB8ICc6JyB8ICc8JyB8ICc9JyB8ICc+JyB8XG4gICAgICAgICAnPycgfCAnQCcgfCAnXFxcXCcgfCAnficgfCAnXicgfCAnfCcgfCAnKicgYXMgYykgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fO1xuICAgICAgICBsZXQgcyA9IHN0cm1fXyBpbiByZXNldF9idWZmZXIgKCk7IHN0b3JlIGM7IGlkZW50MiBzXG4gICAgfCBTb21lICgnMCcuLic5JyBhcyBjKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187XG4gICAgICAgIGxldCBzID0gc3RybV9fIGluIHJlc2V0X2J1ZmZlciAoKTsgc3RvcmUgYzsgbnVtYmVyIHNcbiAgICB8IFNvbWUgJ1xcJycgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fO1xuICAgICAgICBsZXQgYyA9XG4gICAgICAgICAgdHJ5IGNoYXIgc3RybV9fIHdpdGhcbiAgICAgICAgICAgIFN0cmVhbS5GYWlsdXJlIC0+IHJhaXNlIChTdHJlYW0uRXJyb3IgXCJcIilcbiAgICAgICAgaW5cbiAgICAgICAgYmVnaW4gbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgICAgICBTb21lICdcXCcnIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgU29tZSAoQ2hhciBjKVxuICAgICAgICB8IF8gLT4gcmFpc2UgKFN0cmVhbS5FcnJvciBcIlwiKVxuICAgICAgICBlbmRcbiAgICB8IFNvbWUgJ1xcXCInIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXztcbiAgICAgICAgbGV0IHMgPSBzdHJtX18gaW4gcmVzZXRfYnVmZmVyICgpOyBTb21lIChTdHJpbmcgKHN0cmluZyBzKSlcbiAgICB8IFNvbWUgJy0nIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgbmVnX251bWJlciBzdHJtX19cbiAgICB8IFNvbWUgJygnIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgbWF5YmVfY29tbWVudCBzdHJtX19cbiAgICB8IFNvbWUgYyAtPiBTdHJlYW0uanVuayBzdHJtX187IFNvbWUgKGtleXdvcmRfb3JfZXJyb3IgYylcbiAgICB8IF8gLT4gTm9uZVxuICBhbmQgaWRlbnQgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZVxuICAgICAgICAoJ0EnLi4nWicgfCAnYScuLid6JyB8ICdcXDE5MicuLidcXDI1NScgfCAnMCcuLic5JyB8ICdfJyB8ICdcXCcnIGFzIGMpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXzsgbGV0IHMgPSBzdHJtX18gaW4gc3RvcmUgYzsgaWRlbnQgc1xuICAgIHwgXyAtPiBTb21lIChpZGVudF9vcl9rZXl3b3JkIChnZXRfc3RyaW5nICgpKSlcbiAgYW5kIGlkZW50MiAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lXG4gICAgICAgICgnIScgfCAnJScgfCAnJicgfCAnJCcgfCAnIycgfCAnKycgfCAnLScgfCAnLycgfCAnOicgfCAnPCcgfCAnPScgfFxuICAgICAgICAgJz4nIHwgJz8nIHwgJ0AnIHwgJ1xcXFwnIHwgJ34nIHwgJ14nIHwgJ3wnIHwgJyonIGFzIGMpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXzsgbGV0IHMgPSBzdHJtX18gaW4gc3RvcmUgYzsgaWRlbnQyIHNcbiAgICB8IF8gLT4gU29tZSAoaWRlbnRfb3Jfa2V5d29yZCAoZ2V0X3N0cmluZyAoKSkpXG4gIGFuZCBuZWdfbnVtYmVyIChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWUgKCcwJy4uJzknIGFzIGMpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXztcbiAgICAgICAgbGV0IHMgPSBzdHJtX18gaW4gcmVzZXRfYnVmZmVyICgpOyBzdG9yZSAnLSc7IHN0b3JlIGM7IG51bWJlciBzXG4gICAgfCBfIC0+IGxldCBzID0gc3RybV9fIGluIHJlc2V0X2J1ZmZlciAoKTsgc3RvcmUgJy0nOyBpZGVudDIgc1xuICBhbmQgbnVtYmVyIChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWUgKCcwJy4uJzknIGFzIGMpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXzsgbGV0IHMgPSBzdHJtX18gaW4gc3RvcmUgYzsgbnVtYmVyIHNcbiAgICB8IFNvbWUgJy4nIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXzsgbGV0IHMgPSBzdHJtX18gaW4gc3RvcmUgJy4nOyBkZWNpbWFsX3BhcnQgc1xuICAgIHwgU29tZSAoJ2UnIHwgJ0UnKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187IGxldCBzID0gc3RybV9fIGluIHN0b3JlICdFJzsgZXhwb25lbnRfcGFydCBzXG4gICAgfCBfIC0+IFNvbWUgKEludCAoaW50X29mX3N0cmluZyAoZ2V0X3N0cmluZyAoKSkpKVxuICBhbmQgZGVjaW1hbF9wYXJ0IChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWUgKCcwJy4uJzknIGFzIGMpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXzsgbGV0IHMgPSBzdHJtX18gaW4gc3RvcmUgYzsgZGVjaW1hbF9wYXJ0IHNcbiAgICB8IFNvbWUgKCdlJyB8ICdFJykgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fOyBsZXQgcyA9IHN0cm1fXyBpbiBzdG9yZSAnRSc7IGV4cG9uZW50X3BhcnQgc1xuICAgIHwgXyAtPiBTb21lIChGbG9hdCAoZmxvYXRfb2Zfc3RyaW5nIChnZXRfc3RyaW5nICgpKSkpXG4gIGFuZCBleHBvbmVudF9wYXJ0IChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWUgKCcrJyB8ICctJyBhcyBjKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187IGxldCBzID0gc3RybV9fIGluIHN0b3JlIGM7IGVuZF9leHBvbmVudF9wYXJ0IHNcbiAgICB8IF8gLT4gZW5kX2V4cG9uZW50X3BhcnQgc3RybV9fXG4gIGFuZCBlbmRfZXhwb25lbnRfcGFydCAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICgnMCcuLic5JyBhcyBjKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187IGxldCBzID0gc3RybV9fIGluIHN0b3JlIGM7IGVuZF9leHBvbmVudF9wYXJ0IHNcbiAgICB8IF8gLT4gU29tZSAoRmxvYXQgKGZsb2F0X29mX3N0cmluZyAoZ2V0X3N0cmluZyAoKSkpKVxuICBhbmQgc3RyaW5nIChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWUgJ1xcXCInIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgZ2V0X3N0cmluZyAoKVxuICAgIHwgU29tZSAnXFxcXCcgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fO1xuICAgICAgICBsZXQgYyA9XG4gICAgICAgICAgdHJ5IGVzY2FwZSBzdHJtX18gd2l0aFxuICAgICAgICAgICAgU3RyZWFtLkZhaWx1cmUgLT4gcmFpc2UgKFN0cmVhbS5FcnJvciBcIlwiKVxuICAgICAgICBpblxuICAgICAgICBsZXQgcyA9IHN0cm1fXyBpbiBzdG9yZSBjOyBzdHJpbmcgc1xuICAgIHwgU29tZSBjIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgbGV0IHMgPSBzdHJtX18gaW4gc3RvcmUgYzsgc3RyaW5nIHNcbiAgICB8IF8gLT4gcmFpc2UgU3RyZWFtLkZhaWx1cmVcbiAgYW5kIGNoYXIgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZSAnXFxcXCcgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fO1xuICAgICAgICBiZWdpbiB0cnkgZXNjYXBlIHN0cm1fXyB3aXRoXG4gICAgICAgICAgU3RyZWFtLkZhaWx1cmUgLT4gcmFpc2UgKFN0cmVhbS5FcnJvciBcIlwiKVxuICAgICAgICBlbmRcbiAgICB8IFNvbWUgYyAtPiBTdHJlYW0uanVuayBzdHJtX187IGNcbiAgICB8IF8gLT4gcmFpc2UgU3RyZWFtLkZhaWx1cmVcbiAgYW5kIGVzY2FwZSAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICduJyAtPiBTdHJlYW0uanVuayBzdHJtX187ICdcXG4nXG4gICAgfCBTb21lICdyJyAtPiBTdHJlYW0uanVuayBzdHJtX187ICdcXHInXG4gICAgfCBTb21lICd0JyAtPiBTdHJlYW0uanVuayBzdHJtX187ICdcXHQnXG4gICAgfCBTb21lICgnMCcuLic5JyBhcyBjMSkgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fO1xuICAgICAgICBiZWdpbiBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgICAgIFNvbWUgKCcwJy4uJzknIGFzIGMyKSAtPlxuICAgICAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fO1xuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgICAgICAgICAgU29tZSAoJzAnLi4nOScgYXMgYzMpIC0+XG4gICAgICAgICAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fO1xuICAgICAgICAgICAgICAgIENoYXIuY2hyXG4gICAgICAgICAgICAgICAgICAoKENoYXIuY29kZSBjMSAtIDQ4KSAqIDEwMCArIChDaGFyLmNvZGUgYzIgLSA0OCkgKiAxMCArXG4gICAgICAgICAgICAgICAgICAgICAoQ2hhci5jb2RlIGMzIC0gNDgpKVxuICAgICAgICAgICAgfCBfIC0+IHJhaXNlIChTdHJlYW0uRXJyb3IgXCJcIilcbiAgICAgICAgICAgIGVuZFxuICAgICAgICB8IF8gLT4gcmFpc2UgKFN0cmVhbS5FcnJvciBcIlwiKVxuICAgICAgICBlbmRcbiAgICB8IFNvbWUgYyAtPiBTdHJlYW0uanVuayBzdHJtX187IGNcbiAgICB8IF8gLT4gcmFpc2UgU3RyZWFtLkZhaWx1cmVcbiAgYW5kIG1heWJlX2NvbW1lbnQgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZSAnKicgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fOyBsZXQgcyA9IHN0cm1fXyBpbiBjb21tZW50IHM7IG5leHRfdG9rZW4gc1xuICAgIHwgXyAtPiBTb21lIChrZXl3b3JkX29yX2Vycm9yICcoJylcbiAgYW5kIGNvbW1lbnQgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZSAnKCcgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBtYXliZV9uZXN0ZWRfY29tbWVudCBzdHJtX19cbiAgICB8IFNvbWUgJyonIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgbWF5YmVfZW5kX2NvbW1lbnQgc3RybV9fXG4gICAgfCBTb21lIF8gLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBjb21tZW50IHN0cm1fX1xuICAgIHwgXyAtPiByYWlzZSBTdHJlYW0uRmFpbHVyZVxuICBhbmQgbWF5YmVfbmVzdGVkX2NvbW1lbnQgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZSAnKicgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBsZXQgcyA9IHN0cm1fXyBpbiBjb21tZW50IHM7IGNvbW1lbnQgc1xuICAgIHwgU29tZSBfIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgY29tbWVudCBzdHJtX19cbiAgICB8IF8gLT4gcmFpc2UgU3RyZWFtLkZhaWx1cmVcbiAgYW5kIG1heWJlX2VuZF9jb21tZW50IChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWUgJyknIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgKClcbiAgICB8IFNvbWUgJyonIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgbWF5YmVfZW5kX2NvbW1lbnQgc3RybV9fXG4gICAgfCBTb21lIF8gLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBjb21tZW50IHN0cm1fX1xuICAgIHwgXyAtPiByYWlzZSBTdHJlYW0uRmFpbHVyZVxuICBpblxuICBmdW4gaW5wdXQgLT4gU3RyZWFtLmZyb20gKGZ1biBfY291bnQgLT4gbmV4dF90b2tlbiBpbnB1dClcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIERhbWllbiBEb2xpZ2V6LCBwcm9qZXQgUGFyYSwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTcgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxubW9kdWxlIHR5cGUgU2VlZGVkUyA9IHNpZ1xuICBpbmNsdWRlIEhhc2h0YmwuU2VlZGVkU1xuICB2YWwgY2xlYW46ICdhIHQgLT4gdW5pdFxuICB2YWwgc3RhdHNfYWxpdmU6ICdhIHQgLT4gSGFzaHRibC5zdGF0aXN0aWNzXG4gICAgKCoqIHNhbWUgYXMgeyFzdGF0c30gYnV0IG9ubHkgY291bnQgdGhlIGFsaXZlIGJpbmRpbmdzICopXG5lbmRcblxubW9kdWxlIHR5cGUgUyA9IHNpZ1xuICBpbmNsdWRlIEhhc2h0YmwuU1xuICB2YWwgY2xlYW46ICdhIHQgLT4gdW5pdFxuICB2YWwgc3RhdHNfYWxpdmU6ICdhIHQgLT4gSGFzaHRibC5zdGF0aXN0aWNzXG4gICAgKCoqIHNhbWUgYXMgeyFzdGF0c30gYnV0IG9ubHkgY291bnQgdGhlIGFsaXZlIGJpbmRpbmdzICopXG5lbmRcblxubW9kdWxlIEdlbkhhc2hUYWJsZSA9IHN0cnVjdFxuXG4gIHR5cGUgZXF1YWwgPVxuICB8IEVUcnVlIHwgRUZhbHNlXG4gIHwgRURlYWQgKCoqIHRoZSBnYXJiYWdlIGNvbGxlY3RvciByZWNsYWltZWQgdGhlIGRhdGEgKilcblxuICBtb2R1bGUgTWFrZVNlZWRlZChIOiBzaWdcbiAgICB0eXBlIHRcbiAgICB0eXBlICdhIGNvbnRhaW5lclxuICAgIHZhbCBjcmVhdGU6IHQgLT4gJ2EgLT4gJ2EgY29udGFpbmVyXG4gICAgdmFsIGhhc2g6IGludCAtPiB0IC0+IGludFxuICAgIHZhbCBlcXVhbDogJ2EgY29udGFpbmVyIC0+IHQgLT4gZXF1YWxcbiAgICB2YWwgZ2V0X2RhdGE6ICdhIGNvbnRhaW5lciAtPiAnYSBvcHRpb25cbiAgICB2YWwgZ2V0X2tleTogJ2EgY29udGFpbmVyIC0+IHQgb3B0aW9uXG4gICAgdmFsIHNldF9rZXlfZGF0YTogJ2EgY29udGFpbmVyIC0+IHQgLT4gJ2EgLT4gdW5pdFxuICAgIHZhbCBjaGVja19rZXk6ICdhIGNvbnRhaW5lciAtPiBib29sXG4gIGVuZCkgOiBTZWVkZWRTIHdpdGggdHlwZSBrZXkgPSBILnRcbiAgPSBzdHJ1Y3RcblxuICAgIHR5cGUgJ2EgdCA9XG4gICAgICB7IG11dGFibGUgc2l6ZTogaW50OyAgICAgICAgICAgICAgICAgICgqIG51bWJlciBvZiBlbnRyaWVzICopXG4gICAgICAgIG11dGFibGUgZGF0YTogJ2EgYnVja2V0bGlzdCBhcnJheTsgICgqIHRoZSBidWNrZXRzICopXG4gICAgICAgIG11dGFibGUgc2VlZDogaW50OyAgICAgICAgICAgICAgICAgICgqIGZvciByYW5kb21pemF0aW9uICopXG4gICAgICAgIGluaXRpYWxfc2l6ZTogaW50OyAgICAgICAgICAgICAgICAgICgqIGluaXRpYWwgYXJyYXkgc2l6ZSAqKVxuICAgICAgfVxuXG4gICAgYW5kICdhIGJ1Y2tldGxpc3QgPVxuICAgIHwgRW1wdHlcbiAgICB8IENvbnMgb2YgaW50ICgqIGhhc2ggb2YgdGhlIGtleSAqKSAqICdhIEguY29udGFpbmVyICogJ2EgYnVja2V0bGlzdFxuXG4gICAgKCoqIHRoZSBoYXNoIG9mIHRoZSBrZXkgaXMga2VwdCBpbiBvcmRlciB0byB0ZXN0IHRoZSBlcXVhbGl0eSBvZiB0aGUgaGFzaFxuICAgICAgYmVmb3JlIHRoZSBrZXkuIFNhbWUgcmVhc29uIGFzIGZvciBXZWFrLk1ha2UgKilcblxuICAgIHR5cGUga2V5ID0gSC50XG5cbiAgICBsZXQgcmVjIHBvd2VyXzJfYWJvdmUgeCBuID1cbiAgICAgIGlmIHggPj0gbiB0aGVuIHhcbiAgICAgIGVsc2UgaWYgeCAqIDIgPiBTeXMubWF4X2FycmF5X2xlbmd0aCB0aGVuIHhcbiAgICAgIGVsc2UgcG93ZXJfMl9hYm92ZSAoeCAqIDIpIG5cblxuICAgIGxldCBwcm5nID0gbGF6eSAoUmFuZG9tLlN0YXRlLm1ha2Vfc2VsZl9pbml0KCkpXG5cbiAgICBsZXQgY3JlYXRlID8ocmFuZG9tID0gKEhhc2h0YmwuaXNfcmFuZG9taXplZCAoKSkpIGluaXRpYWxfc2l6ZSA9XG4gICAgICBsZXQgcyA9IHBvd2VyXzJfYWJvdmUgMTYgaW5pdGlhbF9zaXplIGluXG4gICAgICBsZXQgc2VlZCA9IGlmIHJhbmRvbSB0aGVuIFJhbmRvbS5TdGF0ZS5iaXRzIChMYXp5LmZvcmNlIHBybmcpIGVsc2UgMCBpblxuICAgICAgeyBpbml0aWFsX3NpemUgPSBzOyBzaXplID0gMDsgc2VlZCA9IHNlZWQ7IGRhdGEgPSBBcnJheS5tYWtlIHMgRW1wdHkgfVxuXG4gICAgbGV0IGNsZWFyIGggPVxuICAgICAgaC5zaXplIDwtIDA7XG4gICAgICBsZXQgbGVuID0gQXJyYXkubGVuZ3RoIGguZGF0YSBpblxuICAgICAgZm9yIGkgPSAwIHRvIGxlbiAtIDEgZG9cbiAgICAgICAgaC5kYXRhLihpKSA8LSBFbXB0eVxuICAgICAgZG9uZVxuXG4gICAgbGV0IHJlc2V0IGggPVxuICAgICAgbGV0IGxlbiA9IEFycmF5Lmxlbmd0aCBoLmRhdGEgaW5cbiAgICAgIGlmIGxlbiA9IGguaW5pdGlhbF9zaXplIHRoZW5cbiAgICAgICAgY2xlYXIgaFxuICAgICAgZWxzZSBiZWdpblxuICAgICAgICBoLnNpemUgPC0gMDtcbiAgICAgICAgaC5kYXRhIDwtIEFycmF5Lm1ha2UgaC5pbml0aWFsX3NpemUgRW1wdHlcbiAgICAgIGVuZFxuXG4gICAgbGV0IGNvcHkgaCA9IHsgaCB3aXRoIGRhdGEgPSBBcnJheS5jb3B5IGguZGF0YSB9XG5cbiAgICBsZXQga2V5X2luZGV4IGggaGtleSA9XG4gICAgICBoa2V5IGxhbmQgKEFycmF5Lmxlbmd0aCBoLmRhdGEgLSAxKVxuXG4gICAgbGV0IGNsZWFuIGggPVxuICAgICAgbGV0IHJlYyBkb19idWNrZXQgPSBmdW5jdGlvblxuICAgICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgICBFbXB0eVxuICAgICAgICB8IENvbnMoXywgYywgcmVzdCkgd2hlbiBub3QgKEguY2hlY2tfa2V5IGMpIC0+XG4gICAgICAgICAgICBoLnNpemUgPC0gaC5zaXplIC0gMTtcbiAgICAgICAgICAgIGRvX2J1Y2tldCByZXN0XG4gICAgICAgIHwgQ29ucyhoa2V5LCBjLCByZXN0KSAtPlxuICAgICAgICAgICAgQ29ucyhoa2V5LCBjLCBkb19idWNrZXQgcmVzdClcbiAgICAgIGluXG4gICAgICBsZXQgZCA9IGguZGF0YSBpblxuICAgICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCBkIC0gMSBkb1xuICAgICAgICBkLihpKSA8LSBkb19idWNrZXQgZC4oaSlcbiAgICAgIGRvbmVcblxuICAgICgqKiByZXNpemUgaXMgdGhlIG9ubHkgZnVuY3Rpb24gdG8gZG8gdGhlIGFjdHVhbCBjbGVhbmluZyBvZiBkZWFkIGtleXNcbiAgICAgICAgKHJlbW92ZSBkb2VzIGl0IGp1c3QgYmVjYXVzZSBpdCBjb3VsZCkuXG5cbiAgICAgICAgVGhlIGdvYWwgaXMgdG86XG5cbiAgICAgICAgLSBub3QgcmVzaXplIGluZmluaXRlbHkgd2hlbiB0aGUgYWN0dWFsIG51bWJlciBvZiBhbGl2ZSBrZXlzIGlzXG4gICAgICAgIGJvdW5kZWQgYnV0IGtleXMgYXJlIGNvbnRpbnVvdXNseSBhZGRlZC4gVGhhdCB3b3VsZCBoYXBwZW4gaWZcbiAgICAgICAgdGhpcyBmdW5jdGlvbiBhbHdheXMgcmVzaXplLlxuICAgICAgICAtIG5vdCBjYWxsIHRoaXMgZnVuY3Rpb24gYWZ0ZXIgZWFjaCBhZGRpdGlvbiwgdGhhdCB3b3VsZCBoYXBwZW4gaWYgdGhpc1xuICAgICAgICBmdW5jdGlvbiBkb24ndCByZXNpemUgZXZlbiB3aGVuIG9ubHkgb25lIGtleSBpcyBkZWFkLlxuXG4gICAgICAgIFNvIHRoZSBhbGdvcml0aG06XG4gICAgICAgIC0gY2xlYW4gdGhlIGtleXMgYmVmb3JlIHJlc2l6aW5nXG4gICAgICAgIC0gaWYgdGhlIG51bWJlciBvZiByZW1haW5pbmcga2V5cyBpcyBsZXNzIHRoYW4gaGFsZiB0aGUgc2l6ZSBvZiB0aGVcbiAgICAgICAgYXJyYXksIGRvbid0IHJlc2l6ZS5cbiAgICAgICAgLSBpZiBpdCBpcyBtb3JlLCByZXNpemUuXG5cbiAgICAgICAgVGhlIHNlY29uZCBwcm9ibGVtIHJlbWFpbnMgaWYgdGhlIHRhYmxlIHJlYWNoZXMgeyFTeXMubWF4X2FycmF5X2xlbmd0aH0uXG5cbiAgICAqKVxuICAgIGxldCByZXNpemUgaCA9XG4gICAgICBsZXQgb2RhdGEgPSBoLmRhdGEgaW5cbiAgICAgIGxldCBvc2l6ZSA9IEFycmF5Lmxlbmd0aCBvZGF0YSBpblxuICAgICAgbGV0IG5zaXplID0gb3NpemUgKiAyIGluXG4gICAgICBjbGVhbiBoO1xuICAgICAgaWYgbnNpemUgPCBTeXMubWF4X2FycmF5X2xlbmd0aCAmJiBoLnNpemUgPj0gb3NpemUgbHNyIDEgdGhlbiBiZWdpblxuICAgICAgICBsZXQgbmRhdGEgPSBBcnJheS5tYWtlIG5zaXplIEVtcHR5IGluXG4gICAgICAgIGguZGF0YSA8LSBuZGF0YTsgICAgICAgKCogc28gdGhhdCBrZXlfaW5kZXggc2VlcyB0aGUgbmV3IGJ1Y2tldCBjb3VudCAqKVxuICAgICAgICBsZXQgcmVjIGluc2VydF9idWNrZXQgPSBmdW5jdGlvblxuICAgICAgICAgICAgRW1wdHkgLT4gKClcbiAgICAgICAgICB8IENvbnMoaGtleSwgZGF0YSwgcmVzdCkgLT5cbiAgICAgICAgICAgICAgaW5zZXJ0X2J1Y2tldCByZXN0OyAoKiBwcmVzZXJ2ZSBvcmlnaW5hbCBvcmRlciBvZiBlbGVtZW50cyAqKVxuICAgICAgICAgICAgICBsZXQgbmlkeCA9IGtleV9pbmRleCBoIGhrZXkgaW5cbiAgICAgICAgICAgICAgbmRhdGEuKG5pZHgpIDwtIENvbnMoaGtleSwgZGF0YSwgbmRhdGEuKG5pZHgpKSBpblxuICAgICAgICBmb3IgaSA9IDAgdG8gb3NpemUgLSAxIGRvXG4gICAgICAgICAgaW5zZXJ0X2J1Y2tldCBvZGF0YS4oaSlcbiAgICAgICAgZG9uZVxuICAgICAgZW5kXG5cbiAgICBsZXQgYWRkIGgga2V5IGluZm8gPVxuICAgICAgbGV0IGhrZXkgPSBILmhhc2ggaC5zZWVkIGtleSBpblxuICAgICAgbGV0IGkgPSBrZXlfaW5kZXggaCBoa2V5IGluXG4gICAgICBsZXQgY29udGFpbmVyID0gSC5jcmVhdGUga2V5IGluZm8gaW5cbiAgICAgIGxldCBidWNrZXQgPSBDb25zKGhrZXksIGNvbnRhaW5lciwgaC5kYXRhLihpKSkgaW5cbiAgICAgIGguZGF0YS4oaSkgPC0gYnVja2V0O1xuICAgICAgaC5zaXplIDwtIGguc2l6ZSArIDE7XG4gICAgICBpZiBoLnNpemUgPiBBcnJheS5sZW5ndGggaC5kYXRhIGxzbCAxIHRoZW4gcmVzaXplIGhcblxuICAgIGxldCByZW1vdmUgaCBrZXkgPVxuICAgICAgbGV0IGhrZXkgPSBILmhhc2ggaC5zZWVkIGtleSBpblxuICAgICAgbGV0IHJlYyByZW1vdmVfYnVja2V0ID0gZnVuY3Rpb25cbiAgICAgICAgfCBFbXB0eSAtPiBFbXB0eVxuICAgICAgICB8IENvbnMoaGssIGMsIG5leHQpIHdoZW4gaGtleSA9IGhrIC0+XG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBILmVxdWFsIGMga2V5IHdpdGhcbiAgICAgICAgICAgIHwgRVRydWUgLT4gaC5zaXplIDwtIGguc2l6ZSAtIDE7IG5leHRcbiAgICAgICAgICAgIHwgRUZhbHNlIC0+IENvbnMoaGssIGMsIHJlbW92ZV9idWNrZXQgbmV4dClcbiAgICAgICAgICAgIHwgRURlYWQgLT5cbiAgICAgICAgICAgICAgICAoKiBUaGUgZGVhZCBrZXkgaXMgYXV0b21hdGljYWxseSByZW1vdmVkLiBJdCBpcyBhY2NlcHRhYmxlXG4gICAgICAgICAgICAgICAgICAgIGZvciB0aGlzIGZ1bmN0aW9uIHNpbmNlIGl0IGFscmVhZHkgcmVtb3ZlcyBhIGJpbmRpbmcgKilcbiAgICAgICAgICAgICAgICBoLnNpemUgPC0gaC5zaXplIC0gMTtcbiAgICAgICAgICAgICAgICByZW1vdmVfYnVja2V0IG5leHRcbiAgICAgICAgICAgIGVuZFxuICAgICAgICB8IENvbnMoaGssYyxuZXh0KSAtPiBDb25zKGhrLCBjLCByZW1vdmVfYnVja2V0IG5leHQpIGluXG4gICAgICBsZXQgaSA9IGtleV9pbmRleCBoIGhrZXkgaW5cbiAgICAgIGguZGF0YS4oaSkgPC0gcmVtb3ZlX2J1Y2tldCBoLmRhdGEuKGkpXG5cbiAgICAoKiogeyFmaW5kfSBkb24ndCByZW1vdmUgZGVhZCBrZXlzIGJlY2F1c2UgaXQgd291bGQgYmUgc3VycHJpc2luZyBmb3JcbiAgICAgICAgdGhlIHVzZXIgdGhhdCBhIHJlYWQtb25seSBmdW5jdGlvbiBtdXRhdGVzIHRoZSBzdGF0ZSAoZWcuIGNvbmN1cnJlbnRcbiAgICAgICAgYWNjZXNzKS4gU2FtZSBmb3IgeyFpdGVyfSwgeyFmb2xkfSwgeyFtZW19LlxuICAgICopXG4gICAgbGV0IHJlYyBmaW5kX3JlYyBrZXkgaGtleSA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IENvbnMoaGssIGMsIHJlc3QpIHdoZW4gaGtleSA9IGhrICAtPlxuICAgICAgICAgIGJlZ2luIG1hdGNoIEguZXF1YWwgYyBrZXkgd2l0aFxuICAgICAgICAgIHwgRVRydWUgLT5cbiAgICAgICAgICAgICAgYmVnaW4gbWF0Y2ggSC5nZXRfZGF0YSBjIHdpdGhcbiAgICAgICAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgICAgICAgICAoKiBUaGlzIGNhc2UgaXMgbm90IGltcG9zc2libGUgYmVjYXVzZSB0aGUgZ2MgY2FuIHJ1biBiZXR3ZWVuXG4gICAgICAgICAgICAgICAgICAgICAgSC5lcXVhbCBhbmQgSC5nZXRfZGF0YSAqKVxuICAgICAgICAgICAgICAgICAgZmluZF9yZWMga2V5IGhrZXkgcmVzdFxuICAgICAgICAgICAgICB8IFNvbWUgZCAtPiBkXG4gICAgICAgICAgICAgIGVuZFxuICAgICAgICAgIHwgRUZhbHNlIC0+IGZpbmRfcmVjIGtleSBoa2V5IHJlc3RcbiAgICAgICAgICB8IEVEZWFkIC0+XG4gICAgICAgICAgICAgIGZpbmRfcmVjIGtleSBoa2V5IHJlc3RcbiAgICAgICAgICBlbmRcbiAgICAgIHwgQ29ucyhfLCBfLCByZXN0KSAtPlxuICAgICAgICAgIGZpbmRfcmVjIGtleSBoa2V5IHJlc3RcblxuICAgIGxldCBmaW5kIGgga2V5ID1cbiAgICAgIGxldCBoa2V5ID0gSC5oYXNoIGguc2VlZCBrZXkgaW5cbiAgICAgICgqIFRPRE8gaW5saW5lIDMgaXRlcmF0aW9ucyAqKVxuICAgICAgZmluZF9yZWMga2V5IGhrZXkgKGguZGF0YS4oa2V5X2luZGV4IGggaGtleSkpXG5cbiAgICBsZXQgcmVjIGZpbmRfcmVjX29wdCBrZXkgaGtleSA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgTm9uZVxuICAgICAgfCBDb25zKGhrLCBjLCByZXN0KSB3aGVuIGhrZXkgPSBoayAgLT5cbiAgICAgICAgICBiZWdpbiBtYXRjaCBILmVxdWFsIGMga2V5IHdpdGhcbiAgICAgICAgICB8IEVUcnVlIC0+XG4gICAgICAgICAgICAgIGJlZ2luIG1hdGNoIEguZ2V0X2RhdGEgYyB3aXRoXG4gICAgICAgICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgICAgICAgICAgKCogVGhpcyBjYXNlIGlzIG5vdCBpbXBvc3NpYmxlIGJlY2F1c2UgdGhlIGdjIGNhbiBydW4gYmV0d2VlblxuICAgICAgICAgICAgICAgICAgICAgIEguZXF1YWwgYW5kIEguZ2V0X2RhdGEgKilcbiAgICAgICAgICAgICAgICAgIGZpbmRfcmVjX29wdCBrZXkgaGtleSByZXN0XG4gICAgICAgICAgICAgIHwgU29tZSBfIGFzIGQgLT4gZFxuICAgICAgICAgICAgICBlbmRcbiAgICAgICAgICB8IEVGYWxzZSAtPiBmaW5kX3JlY19vcHQga2V5IGhrZXkgcmVzdFxuICAgICAgICAgIHwgRURlYWQgLT5cbiAgICAgICAgICAgICAgZmluZF9yZWNfb3B0IGtleSBoa2V5IHJlc3RcbiAgICAgICAgICBlbmRcbiAgICAgIHwgQ29ucyhfLCBfLCByZXN0KSAtPlxuICAgICAgICAgIGZpbmRfcmVjX29wdCBrZXkgaGtleSByZXN0XG5cbiAgICBsZXQgZmluZF9vcHQgaCBrZXkgPVxuICAgICAgbGV0IGhrZXkgPSBILmhhc2ggaC5zZWVkIGtleSBpblxuICAgICAgKCogVE9ETyBpbmxpbmUgMyBpdGVyYXRpb25zICopXG4gICAgICBmaW5kX3JlY19vcHQga2V5IGhrZXkgKGguZGF0YS4oa2V5X2luZGV4IGggaGtleSkpXG5cbiAgICBsZXQgZmluZF9hbGwgaCBrZXkgPVxuICAgICAgbGV0IGhrZXkgPSBILmhhc2ggaC5zZWVkIGtleSBpblxuICAgICAgbGV0IHJlYyBmaW5kX2luX2J1Y2tldCA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+IFtdXG4gICAgICB8IENvbnMoaGssIGMsIHJlc3QpIHdoZW4gaGtleSA9IGhrICAtPlxuICAgICAgICAgIGJlZ2luIG1hdGNoIEguZXF1YWwgYyBrZXkgd2l0aFxuICAgICAgICAgIHwgRVRydWUgLT4gYmVnaW4gbWF0Y2ggSC5nZXRfZGF0YSBjIHdpdGhcbiAgICAgICAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgICAgICAgICBmaW5kX2luX2J1Y2tldCByZXN0XG4gICAgICAgICAgICAgIHwgU29tZSBkIC0+IGQ6OmZpbmRfaW5fYnVja2V0IHJlc3RcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIHwgRUZhbHNlIC0+IGZpbmRfaW5fYnVja2V0IHJlc3RcbiAgICAgICAgICB8IEVEZWFkIC0+XG4gICAgICAgICAgICAgIGZpbmRfaW5fYnVja2V0IHJlc3RcbiAgICAgICAgICBlbmRcbiAgICAgIHwgQ29ucyhfLCBfLCByZXN0KSAtPlxuICAgICAgICAgIGZpbmRfaW5fYnVja2V0IHJlc3QgaW5cbiAgICAgIGZpbmRfaW5fYnVja2V0IGguZGF0YS4oa2V5X2luZGV4IGggaGtleSlcblxuXG4gICAgbGV0IHJlcGxhY2UgaCBrZXkgaW5mbyA9XG4gICAgICBsZXQgaGtleSA9IEguaGFzaCBoLnNlZWQga2V5IGluXG4gICAgICBsZXQgcmVjIHJlcGxhY2VfYnVja2V0ID0gZnVuY3Rpb25cbiAgICAgICAgfCBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgICAgfCBDb25zKGhrLCBjLCBuZXh0KSB3aGVuIGhrZXkgPSBoayAtPlxuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggSC5lcXVhbCBjIGtleSB3aXRoXG4gICAgICAgICAgICB8IEVUcnVlIC0+IEguc2V0X2tleV9kYXRhIGMga2V5IGluZm9cbiAgICAgICAgICAgIHwgRUZhbHNlIHwgRURlYWQgLT4gcmVwbGFjZV9idWNrZXQgbmV4dFxuICAgICAgICAgICAgZW5kXG4gICAgICAgIHwgQ29ucyhfLF8sbmV4dCkgLT4gcmVwbGFjZV9idWNrZXQgbmV4dFxuICAgICAgaW5cbiAgICAgIGxldCBpID0ga2V5X2luZGV4IGggaGtleSBpblxuICAgICAgbGV0IGwgPSBoLmRhdGEuKGkpIGluXG4gICAgICB0cnlcbiAgICAgICAgcmVwbGFjZV9idWNrZXQgbFxuICAgICAgd2l0aCBOb3RfZm91bmQgLT5cbiAgICAgICAgbGV0IGNvbnRhaW5lciA9IEguY3JlYXRlIGtleSBpbmZvIGluXG4gICAgICAgIGguZGF0YS4oaSkgPC0gQ29ucyhoa2V5LCBjb250YWluZXIsIGwpO1xuICAgICAgICBoLnNpemUgPC0gaC5zaXplICsgMTtcbiAgICAgICAgaWYgaC5zaXplID4gQXJyYXkubGVuZ3RoIGguZGF0YSBsc2wgMSB0aGVuIHJlc2l6ZSBoXG5cbiAgICBsZXQgbWVtIGgga2V5ID1cbiAgICAgIGxldCBoa2V5ID0gSC5oYXNoIGguc2VlZCBrZXkgaW5cbiAgICAgIGxldCByZWMgbWVtX2luX2J1Y2tldCA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgZmFsc2VcbiAgICAgIHwgQ29ucyhoaywgYywgcmVzdCkgd2hlbiBoayA9IGhrZXkgLT5cbiAgICAgICAgICBiZWdpbiBtYXRjaCBILmVxdWFsIGMga2V5IHdpdGhcbiAgICAgICAgICB8IEVUcnVlIC0+IHRydWVcbiAgICAgICAgICB8IEVGYWxzZSB8IEVEZWFkIC0+IG1lbV9pbl9idWNrZXQgcmVzdFxuICAgICAgICAgIGVuZFxuICAgICAgfCBDb25zKF9oaywgX2MsIHJlc3QpIC0+IG1lbV9pbl9idWNrZXQgcmVzdCBpblxuICAgICAgbWVtX2luX2J1Y2tldCBoLmRhdGEuKGtleV9pbmRleCBoIGhrZXkpXG5cbiAgICBsZXQgaXRlciBmIGggPVxuICAgICAgbGV0IHJlYyBkb19idWNrZXQgPSBmdW5jdGlvblxuICAgICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgICAoKVxuICAgICAgICB8IENvbnMoXywgYywgcmVzdCkgLT5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIEguZ2V0X2tleSBjLCBILmdldF9kYXRhIGMgd2l0aFxuICAgICAgICAgICAgfCBOb25lLCBfIHwgXywgTm9uZSAtPiAoKVxuICAgICAgICAgICAgfCBTb21lIGssIFNvbWUgZCAtPiBmIGsgZFxuICAgICAgICAgICAgZW5kOyBkb19idWNrZXQgcmVzdCBpblxuICAgICAgbGV0IGQgPSBoLmRhdGEgaW5cbiAgICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggZCAtIDEgZG9cbiAgICAgICAgZG9fYnVja2V0IGQuKGkpXG4gICAgICBkb25lXG5cbiAgICBsZXQgZm9sZCBmIGggaW5pdCA9XG4gICAgICBsZXQgcmVjIGRvX2J1Y2tldCBiIGFjY3UgPVxuICAgICAgICBtYXRjaCBiIHdpdGhcbiAgICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgICAgYWNjdVxuICAgICAgICB8IENvbnMoXywgYywgcmVzdCkgLT5cbiAgICAgICAgICAgIGxldCBhY2N1ID0gYmVnaW4gbWF0Y2ggSC5nZXRfa2V5IGMsIEguZ2V0X2RhdGEgYyB3aXRoXG4gICAgICAgICAgICAgIHwgTm9uZSwgXyB8IF8sIE5vbmUgLT4gYWNjdVxuICAgICAgICAgICAgICB8IFNvbWUgaywgU29tZSBkIC0+IGYgayBkIGFjY3VcbiAgICAgICAgICAgIGVuZCBpblxuICAgICAgICAgICAgZG9fYnVja2V0IHJlc3QgYWNjdSAgaW5cbiAgICAgIGxldCBkID0gaC5kYXRhIGluXG4gICAgICBsZXQgYWNjdSA9IHJlZiBpbml0IGluXG4gICAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGQgLSAxIGRvXG4gICAgICAgIGFjY3UgOj0gZG9fYnVja2V0IGQuKGkpICFhY2N1XG4gICAgICBkb25lO1xuICAgICAgIWFjY3VcblxuICAgIGxldCBmaWx0ZXJfbWFwX2lucGxhY2UgZiBoID1cbiAgICAgIGxldCByZWMgZG9fYnVja2V0ID0gZnVuY3Rpb25cbiAgICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgICAgRW1wdHlcbiAgICAgICAgfCBDb25zKGhrLCBjLCByZXN0KSAtPlxuICAgICAgICAgICAgbWF0Y2ggSC5nZXRfa2V5IGMsIEguZ2V0X2RhdGEgYyB3aXRoXG4gICAgICAgICAgICB8IE5vbmUsIF8gfCBfLCBOb25lIC0+XG4gICAgICAgICAgICAgICAgZG9fYnVja2V0IHJlc3RcbiAgICAgICAgICAgIHwgU29tZSBrLCBTb21lIGQgLT5cbiAgICAgICAgICAgICAgICBtYXRjaCBmIGsgZCB3aXRoXG4gICAgICAgICAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgICAgICAgICAgIGRvX2J1Y2tldCByZXN0XG4gICAgICAgICAgICAgICAgfCBTb21lIG5ld19kIC0+XG4gICAgICAgICAgICAgICAgICAgIEguc2V0X2tleV9kYXRhIGMgayBuZXdfZDtcbiAgICAgICAgICAgICAgICAgICAgQ29ucyhoaywgYywgZG9fYnVja2V0IHJlc3QpXG4gICAgICBpblxuICAgICAgbGV0IGQgPSBoLmRhdGEgaW5cbiAgICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggZCAtIDEgZG9cbiAgICAgICAgZC4oaSkgPC0gZG9fYnVja2V0IGQuKGkpXG4gICAgICBkb25lXG5cbiAgICBsZXQgbGVuZ3RoIGggPSBoLnNpemVcblxuICAgIGxldCByZWMgYnVja2V0X2xlbmd0aCBhY2N1ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT4gYWNjdVxuICAgICAgfCBDb25zKF8sIF8sIHJlc3QpIC0+IGJ1Y2tldF9sZW5ndGggKGFjY3UgKyAxKSByZXN0XG5cbiAgICBsZXQgc3RhdHMgaCA9XG4gICAgICBsZXQgbWJsID1cbiAgICAgICAgQXJyYXkuZm9sZF9sZWZ0IChmdW4gbSBiIC0+IG1heCBtIChidWNrZXRfbGVuZ3RoIDAgYikpIDAgaC5kYXRhIGluXG4gICAgICBsZXQgaGlzdG8gPSBBcnJheS5tYWtlIChtYmwgKyAxKSAwIGluXG4gICAgICBBcnJheS5pdGVyXG4gICAgICAgIChmdW4gYiAtPlxuICAgICAgICAgICBsZXQgbCA9IGJ1Y2tldF9sZW5ndGggMCBiIGluXG4gICAgICAgICAgIGhpc3RvLihsKSA8LSBoaXN0by4obCkgKyAxKVxuICAgICAgICBoLmRhdGE7XG4gICAgICB7IEhhc2h0YmwubnVtX2JpbmRpbmdzID0gaC5zaXplO1xuICAgICAgICBudW1fYnVja2V0cyA9IEFycmF5Lmxlbmd0aCBoLmRhdGE7XG4gICAgICAgIG1heF9idWNrZXRfbGVuZ3RoID0gbWJsO1xuICAgICAgICBidWNrZXRfaGlzdG9ncmFtID0gaGlzdG8gfVxuXG4gICAgbGV0IHJlYyBidWNrZXRfbGVuZ3RoX2FsaXZlIGFjY3UgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiBhY2N1XG4gICAgICB8IENvbnMoXywgYywgcmVzdCkgd2hlbiBILmNoZWNrX2tleSBjIC0+XG4gICAgICAgICAgYnVja2V0X2xlbmd0aF9hbGl2ZSAoYWNjdSArIDEpIHJlc3RcbiAgICAgIHwgQ29ucyhfLCBfLCByZXN0KSAtPiBidWNrZXRfbGVuZ3RoX2FsaXZlIGFjY3UgcmVzdFxuXG4gICAgbGV0IHN0YXRzX2FsaXZlIGggPVxuICAgICAgbGV0IHNpemUgPSByZWYgMCBpblxuICAgICAgbGV0IG1ibCA9XG4gICAgICAgIEFycmF5LmZvbGRfbGVmdCAoZnVuIG0gYiAtPiBtYXggbSAoYnVja2V0X2xlbmd0aF9hbGl2ZSAwIGIpKSAwIGguZGF0YSBpblxuICAgICAgbGV0IGhpc3RvID0gQXJyYXkubWFrZSAobWJsICsgMSkgMCBpblxuICAgICAgQXJyYXkuaXRlclxuICAgICAgICAoZnVuIGIgLT5cbiAgICAgICAgICAgbGV0IGwgPSBidWNrZXRfbGVuZ3RoX2FsaXZlIDAgYiBpblxuICAgICAgICAgICBzaXplIDo9ICFzaXplICsgbDtcbiAgICAgICAgICAgaGlzdG8uKGwpIDwtIGhpc3RvLihsKSArIDEpXG4gICAgICAgIGguZGF0YTtcbiAgICAgIHsgSGFzaHRibC5udW1fYmluZGluZ3MgPSAhc2l6ZTtcbiAgICAgICAgbnVtX2J1Y2tldHMgPSBBcnJheS5sZW5ndGggaC5kYXRhO1xuICAgICAgICBtYXhfYnVja2V0X2xlbmd0aCA9IG1ibDtcbiAgICAgICAgYnVja2V0X2hpc3RvZ3JhbSA9IGhpc3RvIH1cblxuICAgIGxldCB0b19zZXEgdGJsID1cbiAgICAgICgqIGNhcHR1cmUgY3VycmVudCBhcnJheSwgc28gdGhhdCBldmVuIGlmIHRoZSB0YWJsZSBpcyByZXNpemVkIHdlXG4gICAgICAgICBrZWVwIGl0ZXJhdGluZyBvbiB0aGUgc2FtZSBhcnJheSAqKVxuICAgICAgbGV0IHRibF9kYXRhID0gdGJsLmRhdGEgaW5cbiAgICAgICgqIHN0YXRlOiBpbmRleCAqIG5leHQgYnVja2V0IHRvIHRyYXZlcnNlICopXG4gICAgICBsZXQgcmVjIGF1eCBpIGJ1Y2sgKCkgPSBtYXRjaCBidWNrIHdpdGhcbiAgICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgICAgaWYgaSA9IEFycmF5Lmxlbmd0aCB0YmxfZGF0YVxuICAgICAgICAgICAgdGhlbiBTZXEuTmlsXG4gICAgICAgICAgICBlbHNlIGF1eChpKzEpIHRibF9kYXRhLihpKSAoKVxuICAgICAgICB8IENvbnMgKF8sIGMsIG5leHQpIC0+XG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBILmdldF9rZXkgYywgSC5nZXRfZGF0YSBjIHdpdGhcbiAgICAgICAgICAgICAgfCBOb25lLCBfIHwgXywgTm9uZSAtPiBhdXggaSBuZXh0ICgpXG4gICAgICAgICAgICAgIHwgU29tZSBrZXksIFNvbWUgZGF0YSAtPlxuICAgICAgICAgICAgICAgICAgU2VxLkNvbnMgKChrZXksIGRhdGEpLCBhdXggaSBuZXh0KVxuICAgICAgICAgICAgZW5kXG4gICAgICBpblxuICAgICAgYXV4IDAgRW1wdHlcblxuICAgIGxldCB0b19zZXFfa2V5cyBtID0gU2VxLm1hcCBmc3QgKHRvX3NlcSBtKVxuXG4gICAgbGV0IHRvX3NlcV92YWx1ZXMgbSA9IFNlcS5tYXAgc25kICh0b19zZXEgbSlcblxuICAgIGxldCBhZGRfc2VxIHRibCBpID1cbiAgICAgIFNlcS5pdGVyIChmdW4gKGssdikgLT4gYWRkIHRibCBrIHYpIGlcblxuICAgIGxldCByZXBsYWNlX3NlcSB0YmwgaSA9XG4gICAgICBTZXEuaXRlciAoZnVuIChrLHYpIC0+IHJlcGxhY2UgdGJsIGsgdikgaVxuXG4gICAgbGV0IG9mX3NlcSBpID1cbiAgICAgIGxldCB0YmwgPSBjcmVhdGUgMTYgaW5cbiAgICAgIHJlcGxhY2Vfc2VxIHRibCBpO1xuICAgICAgdGJsXG5cbiAgZW5kXG5lbmRcblxubW9kdWxlIE9iakVwaCA9IE9iai5FcGhlbWVyb25cblxubGV0IF9vYmpfb3B0IDogT2JqLnQgb3B0aW9uIC0+ICdhIG9wdGlvbiA9IGZ1biB4IC0+XG4gIG1hdGNoIHggd2l0aFxuICB8IE5vbmUgLT4geFxuICB8IFNvbWUgdiAtPiBTb21lIChPYmoub2JqIHYpXG5cbigqKiBUaGUgcHJldmlvdXMgZnVuY3Rpb24gaXMgdHlwZWQgc28gdGhpcyBvbmUgaXMgYWxzbyBjb3JyZWN0ICopXG5sZXQgb2JqX29wdCA6IE9iai50IG9wdGlvbiAtPiAnYSBvcHRpb24gPSBmdW4geCAtPiBPYmoubWFnaWMgeFxuXG5cbm1vZHVsZSBLMSA9IHN0cnVjdFxuICB0eXBlICgnaywnZCkgdCA9IE9iakVwaC50XG5cbiAgbGV0IGNyZWF0ZSAoKSA6ICgnaywnZCkgdCA9IE9iakVwaC5jcmVhdGUgMVxuXG4gIGxldCBnZXRfa2V5ICh0OignaywnZCkgdCkgOiAnayBvcHRpb24gPSBvYmpfb3B0IChPYmpFcGguZ2V0X2tleSB0IDApXG4gIGxldCBnZXRfa2V5X2NvcHkgKHQ6KCdrLCdkKSB0KSA6ICdrIG9wdGlvbiA9IG9ial9vcHQgKE9iakVwaC5nZXRfa2V5X2NvcHkgdCAwKVxuICBsZXQgc2V0X2tleSAodDooJ2ssJ2QpIHQpIChrOidrKSA6IHVuaXQgPSBPYmpFcGguc2V0X2tleSB0IDAgKE9iai5yZXByIGspXG4gIGxldCB1bnNldF9rZXkgKHQ6KCdrLCdkKSB0KSA6IHVuaXQgPSBPYmpFcGgudW5zZXRfa2V5IHQgMFxuICBsZXQgY2hlY2tfa2V5ICh0OignaywnZCkgdCkgOiBib29sID0gT2JqRXBoLmNoZWNrX2tleSB0IDBcblxuICBsZXQgYmxpdF9rZXkgKHQxOignaywnZCkgdCkgKHQyOignaywnZCkgdCk6IHVuaXQgPVxuICAgIE9iakVwaC5ibGl0X2tleSB0MSAwIHQyIDAgMVxuXG4gIGxldCBnZXRfZGF0YSAodDooJ2ssJ2QpIHQpIDogJ2Qgb3B0aW9uID0gb2JqX29wdCAoT2JqRXBoLmdldF9kYXRhIHQpXG4gIGxldCBnZXRfZGF0YV9jb3B5ICh0OignaywnZCkgdCkgOiAnZCBvcHRpb24gPSBvYmpfb3B0IChPYmpFcGguZ2V0X2RhdGFfY29weSB0KVxuICBsZXQgc2V0X2RhdGEgKHQ6KCdrLCdkKSB0KSAoZDonZCkgOiB1bml0ID0gT2JqRXBoLnNldF9kYXRhIHQgKE9iai5yZXByIGQpXG4gIGxldCB1bnNldF9kYXRhICh0OignaywnZCkgdCkgOiB1bml0ID0gT2JqRXBoLnVuc2V0X2RhdGEgdFxuICBsZXQgY2hlY2tfZGF0YSAodDooJ2ssJ2QpIHQpIDogYm9vbCA9IE9iakVwaC5jaGVja19kYXRhIHRcbiAgbGV0IGJsaXRfZGF0YSAodDE6KF8sJ2QpIHQpICh0MjooXywnZCkgdCkgOiB1bml0ID0gT2JqRXBoLmJsaXRfZGF0YSB0MSB0MlxuXG4gIG1vZHVsZSBNYWtlU2VlZGVkIChIOkhhc2h0YmwuU2VlZGVkSGFzaGVkVHlwZSkgPVxuICAgIEdlbkhhc2hUYWJsZS5NYWtlU2VlZGVkKHN0cnVjdFxuICAgICAgdHlwZSAnYSBjb250YWluZXIgPSAoSC50LCdhKSB0XG4gICAgICB0eXBlIHQgPSBILnRcbiAgICAgIGxldCBjcmVhdGUgayBkID1cbiAgICAgICAgbGV0IGMgPSBjcmVhdGUgKCkgaW5cbiAgICAgICAgc2V0X2RhdGEgYyBkO1xuICAgICAgICBzZXRfa2V5IGMgaztcbiAgICAgICAgY1xuICAgICAgbGV0IGhhc2ggPSBILmhhc2hcbiAgICAgIGxldCBlcXVhbCBjIGsgPVxuICAgICAgICAoKiB7IWdldF9rZXlfY29weX0gaXMgbm90IHVzZWQgYmVjYXVzZSB0aGUgZXF1YWxpdHkgb2YgdGhlIHVzZXIgY2FuIGJlXG4gICAgICAgICAgICB0aGUgcGh5c2ljYWwgZXF1YWxpdHkgKilcbiAgICAgICAgbWF0Y2ggZ2V0X2tleSBjIHdpdGhcbiAgICAgICAgfCBOb25lIC0+IEdlbkhhc2hUYWJsZS5FRGVhZFxuICAgICAgICB8IFNvbWUgaycgLT5cbiAgICAgICAgICAgIGlmIEguZXF1YWwgayBrJyB0aGVuIEdlbkhhc2hUYWJsZS5FVHJ1ZSBlbHNlIEdlbkhhc2hUYWJsZS5FRmFsc2VcbiAgICAgIGxldCBnZXRfZGF0YSA9IGdldF9kYXRhXG4gICAgICBsZXQgZ2V0X2tleSA9IGdldF9rZXlcbiAgICAgIGxldCBzZXRfa2V5X2RhdGEgYyBrIGQgPVxuICAgICAgICB1bnNldF9kYXRhIGM7XG4gICAgICAgIHNldF9rZXkgYyBrO1xuICAgICAgICBzZXRfZGF0YSBjIGRcbiAgICAgIGxldCBjaGVja19rZXkgPSBjaGVja19rZXlcbiAgICBlbmQpXG5cbiAgbW9kdWxlIE1ha2UoSDogSGFzaHRibC5IYXNoZWRUeXBlKTogKFMgd2l0aCB0eXBlIGtleSA9IEgudCkgPVxuICBzdHJ1Y3RcbiAgICBpbmNsdWRlIE1ha2VTZWVkZWQoc3RydWN0XG4gICAgICAgIHR5cGUgdCA9IEgudFxuICAgICAgICBsZXQgZXF1YWwgPSBILmVxdWFsXG4gICAgICAgIGxldCBoYXNoIChfc2VlZDogaW50KSB4ID0gSC5oYXNoIHhcbiAgICAgIGVuZClcbiAgICBsZXQgY3JlYXRlIHN6ID0gY3JlYXRlIH5yYW5kb206ZmFsc2Ugc3pcbiAgICBsZXQgb2Zfc2VxIGkgPVxuICAgICAgbGV0IHRibCA9IGNyZWF0ZSAxNiBpblxuICAgICAgcmVwbGFjZV9zZXEgdGJsIGk7XG4gICAgICB0YmxcbiAgZW5kXG5cbmVuZFxuXG5tb2R1bGUgSzIgPSBzdHJ1Y3RcbiAgdHlwZSAoJ2sxLCAnazIsICdkKSB0ID0gT2JqRXBoLnRcblxuICBsZXQgY3JlYXRlICgpIDogKCdrMSwnazIsJ2QpIHQgPSBPYmpFcGguY3JlYXRlIDJcblxuICBsZXQgZ2V0X2tleTEgKHQ6KCdrMSwnazIsJ2QpIHQpIDogJ2sxIG9wdGlvbiA9IG9ial9vcHQgKE9iakVwaC5nZXRfa2V5IHQgMClcbiAgbGV0IGdldF9rZXkxX2NvcHkgKHQ6KCdrMSwnazIsJ2QpIHQpIDogJ2sxIG9wdGlvbiA9XG4gICAgb2JqX29wdCAoT2JqRXBoLmdldF9rZXlfY29weSB0IDApXG4gIGxldCBzZXRfa2V5MSAodDooJ2sxLCdrMiwnZCkgdCkgKGs6J2sxKSA6IHVuaXQgPVxuICAgIE9iakVwaC5zZXRfa2V5IHQgMCAoT2JqLnJlcHIgaylcbiAgbGV0IHVuc2V0X2tleTEgKHQ6KCdrMSwnazIsJ2QpIHQpIDogdW5pdCA9IE9iakVwaC51bnNldF9rZXkgdCAwXG4gIGxldCBjaGVja19rZXkxICh0OignazEsJ2syLCdkKSB0KSA6IGJvb2wgPSBPYmpFcGguY2hlY2tfa2V5IHQgMFxuXG4gIGxldCBnZXRfa2V5MiAodDooJ2sxLCdrMiwnZCkgdCkgOiAnazIgb3B0aW9uID0gb2JqX29wdCAoT2JqRXBoLmdldF9rZXkgdCAxKVxuICBsZXQgZ2V0X2tleTJfY29weSAodDooJ2sxLCdrMiwnZCkgdCkgOiAnazIgb3B0aW9uID1cbiAgICBvYmpfb3B0IChPYmpFcGguZ2V0X2tleV9jb3B5IHQgMSlcbiAgbGV0IHNldF9rZXkyICh0OignazEsJ2syLCdkKSB0KSAoazonazIpIDogdW5pdCA9XG4gICAgT2JqRXBoLnNldF9rZXkgdCAxIChPYmoucmVwciBrKVxuICBsZXQgdW5zZXRfa2V5MiAodDooJ2sxLCdrMiwnZCkgdCkgOiB1bml0ID0gT2JqRXBoLnVuc2V0X2tleSB0IDFcbiAgbGV0IGNoZWNrX2tleTIgKHQ6KCdrMSwnazIsJ2QpIHQpIDogYm9vbCA9IE9iakVwaC5jaGVja19rZXkgdCAxXG5cblxuICBsZXQgYmxpdF9rZXkxICh0MTooJ2sxLF8sXykgdCkgKHQyOignazEsXyxfKSB0KSA6IHVuaXQgPVxuICAgIE9iakVwaC5ibGl0X2tleSB0MSAwIHQyIDAgMVxuICBsZXQgYmxpdF9rZXkyICh0MTooXywnazIsXykgdCkgKHQyOihfLCdrMixfKSB0KSA6IHVuaXQgPVxuICAgIE9iakVwaC5ibGl0X2tleSB0MSAxIHQyIDEgMVxuICBsZXQgYmxpdF9rZXkxMiAodDE6KCdrMSwnazIsXykgdCkgKHQyOignazEsJ2syLF8pIHQpIDogdW5pdCA9XG4gICAgT2JqRXBoLmJsaXRfa2V5IHQxIDAgdDIgMCAyXG5cbiAgbGV0IGdldF9kYXRhICh0OignazEsJ2syLCdkKSB0KSA6ICdkIG9wdGlvbiA9IG9ial9vcHQgKE9iakVwaC5nZXRfZGF0YSB0KVxuICBsZXQgZ2V0X2RhdGFfY29weSAodDooJ2sxLCdrMiwnZCkgdCkgOiAnZCBvcHRpb24gPVxuICAgIG9ial9vcHQgKE9iakVwaC5nZXRfZGF0YV9jb3B5IHQpXG4gIGxldCBzZXRfZGF0YSAodDooJ2sxLCdrMiwnZCkgdCkgKGQ6J2QpIDogdW5pdCA9XG4gICAgT2JqRXBoLnNldF9kYXRhIHQgKE9iai5yZXByIGQpXG4gIGxldCB1bnNldF9kYXRhICh0OignazEsJ2syLCdkKSB0KSA6IHVuaXQgPSBPYmpFcGgudW5zZXRfZGF0YSB0XG4gIGxldCBjaGVja19kYXRhICh0OignazEsJ2syLCdkKSB0KSA6IGJvb2wgPSBPYmpFcGguY2hlY2tfZGF0YSB0XG4gIGxldCBibGl0X2RhdGEgKHQxOihfLF8sJ2QpIHQpICh0MjooXyxfLCdkKSB0KSA6IHVuaXQgPSBPYmpFcGguYmxpdF9kYXRhIHQxIHQyXG5cbiAgbW9kdWxlIE1ha2VTZWVkZWRcbiAgICAgIChIMTpIYXNodGJsLlNlZWRlZEhhc2hlZFR5cGUpXG4gICAgICAoSDI6SGFzaHRibC5TZWVkZWRIYXNoZWRUeXBlKSA9XG4gICAgR2VuSGFzaFRhYmxlLk1ha2VTZWVkZWQoc3RydWN0XG4gICAgICB0eXBlICdhIGNvbnRhaW5lciA9IChIMS50LEgyLnQsJ2EpIHRcbiAgICAgIHR5cGUgdCA9IEgxLnQgKiBIMi50XG4gICAgICBsZXQgY3JlYXRlIChrMSxrMikgZCA9XG4gICAgICAgIGxldCBjID0gY3JlYXRlICgpIGluXG4gICAgICAgIHNldF9kYXRhIGMgZDtcbiAgICAgICAgc2V0X2tleTEgYyBrMTsgc2V0X2tleTIgYyBrMjtcbiAgICAgICAgY1xuICAgICAgbGV0IGhhc2ggc2VlZCAoazEsazIpID1cbiAgICAgICAgSDEuaGFzaCBzZWVkIGsxICsgSDIuaGFzaCBzZWVkIGsyICogNjU1OTlcbiAgICAgIGxldCBlcXVhbCBjIChrMSxrMikgPVxuICAgICAgICBtYXRjaCBnZXRfa2V5MSBjLCBnZXRfa2V5MiBjIHdpdGhcbiAgICAgICAgfCBOb25lLCBfIHwgXyAsIE5vbmUgLT4gR2VuSGFzaFRhYmxlLkVEZWFkXG4gICAgICAgIHwgU29tZSBrMScsIFNvbWUgazInIC0+XG4gICAgICAgICAgICBpZiBIMS5lcXVhbCBrMSBrMScgJiYgSDIuZXF1YWwgazIgazInXG4gICAgICAgICAgICB0aGVuIEdlbkhhc2hUYWJsZS5FVHJ1ZSBlbHNlIEdlbkhhc2hUYWJsZS5FRmFsc2VcbiAgICAgIGxldCBnZXRfZGF0YSA9IGdldF9kYXRhXG4gICAgICBsZXQgZ2V0X2tleSBjID1cbiAgICAgICAgbWF0Y2ggZ2V0X2tleTEgYywgZ2V0X2tleTIgYyB3aXRoXG4gICAgICAgIHwgTm9uZSwgXyB8IF8gLCBOb25lIC0+IE5vbmVcbiAgICAgICAgfCBTb21lIGsxJywgU29tZSBrMicgLT4gU29tZSAoazEnLCBrMicpXG4gICAgICBsZXQgc2V0X2tleV9kYXRhIGMgKGsxLGsyKSBkID1cbiAgICAgICAgdW5zZXRfZGF0YSBjO1xuICAgICAgICBzZXRfa2V5MSBjIGsxOyBzZXRfa2V5MiBjIGsyO1xuICAgICAgICBzZXRfZGF0YSBjIGRcbiAgICAgIGxldCBjaGVja19rZXkgYyA9IGNoZWNrX2tleTEgYyAmJiBjaGVja19rZXkyIGNcbiAgICBlbmQpXG5cbiAgbW9kdWxlIE1ha2UoSDE6IEhhc2h0YmwuSGFzaGVkVHlwZSkoSDI6IEhhc2h0YmwuSGFzaGVkVHlwZSk6XG4gICAgKFMgd2l0aCB0eXBlIGtleSA9IEgxLnQgKiBIMi50KSA9XG4gIHN0cnVjdFxuICAgIGluY2x1ZGUgTWFrZVNlZWRlZFxuICAgICAgICAoc3RydWN0XG4gICAgICAgICAgdHlwZSB0ID0gSDEudFxuICAgICAgICAgIGxldCBlcXVhbCA9IEgxLmVxdWFsXG4gICAgICAgICAgbGV0IGhhc2ggKF9zZWVkOiBpbnQpIHggPSBIMS5oYXNoIHhcbiAgICAgICAgZW5kKVxuICAgICAgICAoc3RydWN0XG4gICAgICAgICAgdHlwZSB0ID0gSDIudFxuICAgICAgICAgIGxldCBlcXVhbCA9IEgyLmVxdWFsXG4gICAgICAgICAgbGV0IGhhc2ggKF9zZWVkOiBpbnQpIHggPSBIMi5oYXNoIHhcbiAgICAgICAgZW5kKVxuICAgIGxldCBjcmVhdGUgc3ogPSBjcmVhdGUgfnJhbmRvbTpmYWxzZSBzelxuICAgIGxldCBvZl9zZXEgaSA9XG4gICAgICBsZXQgdGJsID0gY3JlYXRlIDE2IGluXG4gICAgICByZXBsYWNlX3NlcSB0YmwgaTtcbiAgICAgIHRibFxuICBlbmRcblxuZW5kXG5cbm1vZHVsZSBLbiA9IHN0cnVjdFxuICB0eXBlICgnaywnZCkgdCA9IE9iakVwaC50XG5cbiAgbGV0IGNyZWF0ZSBuIDogKCdrLCdkKSB0ID0gT2JqRXBoLmNyZWF0ZSBuXG4gIGxldCBsZW5ndGggKGs6KCdrLCdkKSB0KSA6IGludCA9IE9iakVwaC5sZW5ndGgga1xuXG4gIGxldCBnZXRfa2V5ICh0OignaywnZCkgdCkgKG46aW50KSA6ICdrIG9wdGlvbiA9IG9ial9vcHQgKE9iakVwaC5nZXRfa2V5IHQgbilcbiAgbGV0IGdldF9rZXlfY29weSAodDooJ2ssJ2QpIHQpIChuOmludCkgOiAnayBvcHRpb24gPVxuICAgIG9ial9vcHQgKE9iakVwaC5nZXRfa2V5X2NvcHkgdCBuKVxuICBsZXQgc2V0X2tleSAodDooJ2ssJ2QpIHQpIChuOmludCkgKGs6J2spIDogdW5pdCA9XG4gICAgT2JqRXBoLnNldF9rZXkgdCBuIChPYmoucmVwciBrKVxuICBsZXQgdW5zZXRfa2V5ICh0OignaywnZCkgdCkgKG46aW50KSA6IHVuaXQgPSBPYmpFcGgudW5zZXRfa2V5IHQgblxuICBsZXQgY2hlY2tfa2V5ICh0OignaywnZCkgdCkgKG46aW50KSA6IGJvb2wgPSBPYmpFcGguY2hlY2tfa2V5IHQgblxuXG4gIGxldCBibGl0X2tleSAodDE6KCdrLCdkKSB0KSAobzE6aW50KSAodDI6KCdrLCdkKSB0KSAobzI6aW50KSAobDppbnQpIDogdW5pdCA9XG4gICAgT2JqRXBoLmJsaXRfa2V5IHQxIG8xIHQyIG8yIGxcblxuICBsZXQgZ2V0X2RhdGEgKHQ6KCdrLCdkKSB0KSA6ICdkIG9wdGlvbiA9IG9ial9vcHQgKE9iakVwaC5nZXRfZGF0YSB0KVxuICBsZXQgZ2V0X2RhdGFfY29weSAodDooJ2ssJ2QpIHQpIDogJ2Qgb3B0aW9uID0gb2JqX29wdCAoT2JqRXBoLmdldF9kYXRhX2NvcHkgdClcbiAgbGV0IHNldF9kYXRhICh0OignaywnZCkgdCkgKGQ6J2QpIDogdW5pdCA9IE9iakVwaC5zZXRfZGF0YSB0IChPYmoucmVwciBkKVxuICBsZXQgdW5zZXRfZGF0YSAodDooJ2ssJ2QpIHQpIDogdW5pdCA9IE9iakVwaC51bnNldF9kYXRhIHRcbiAgbGV0IGNoZWNrX2RhdGEgKHQ6KCdrLCdkKSB0KSA6IGJvb2wgPSBPYmpFcGguY2hlY2tfZGF0YSB0XG4gIGxldCBibGl0X2RhdGEgKHQxOihfLCdkKSB0KSAodDI6KF8sJ2QpIHQpIDogdW5pdCA9IE9iakVwaC5ibGl0X2RhdGEgdDEgdDJcblxuICBtb2R1bGUgTWFrZVNlZWRlZCAoSDpIYXNodGJsLlNlZWRlZEhhc2hlZFR5cGUpID1cbiAgICBHZW5IYXNoVGFibGUuTWFrZVNlZWRlZChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgY29udGFpbmVyID0gKEgudCwnYSkgdFxuICAgICAgdHlwZSB0ID0gSC50IGFycmF5XG4gICAgICBsZXQgY3JlYXRlIGsgZCA9XG4gICAgICAgIGxldCBjID0gY3JlYXRlIChBcnJheS5sZW5ndGggaykgaW5cbiAgICAgICAgc2V0X2RhdGEgYyBkO1xuICAgICAgICBmb3IgaT0wIHRvIEFycmF5Lmxlbmd0aCBrIC0xIGRvXG4gICAgICAgICAgc2V0X2tleSBjIGkgay4oaSk7XG4gICAgICAgIGRvbmU7XG4gICAgICAgIGNcbiAgICAgIGxldCBoYXNoIHNlZWQgayA9XG4gICAgICAgIGxldCBoID0gcmVmIDAgaW5cbiAgICAgICAgZm9yIGk9MCB0byBBcnJheS5sZW5ndGggayAtMSBkb1xuICAgICAgICAgIGggOj0gSC5oYXNoIHNlZWQgay4oaSkgKiA2NTU5OSArICFoO1xuICAgICAgICBkb25lO1xuICAgICAgICAhaFxuICAgICAgbGV0IGVxdWFsIGMgayA9XG4gICAgICAgIGxldCBsZW4gID0gQXJyYXkubGVuZ3RoIGsgaW5cbiAgICAgICAgbGV0IGxlbicgPSBsZW5ndGggYyBpblxuICAgICAgICBpZiBsZW4gIT0gbGVuJyB0aGVuIEdlbkhhc2hUYWJsZS5FRmFsc2VcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGxldCByZWMgZXF1YWxfYXJyYXkgayBjIGkgPVxuICAgICAgICAgICAgaWYgaSA8IDAgdGhlbiBHZW5IYXNoVGFibGUuRVRydWVcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgbWF0Y2ggZ2V0X2tleSBjIGkgd2l0aFxuICAgICAgICAgICAgICB8IE5vbmUgLT4gR2VuSGFzaFRhYmxlLkVEZWFkXG4gICAgICAgICAgICAgIHwgU29tZSBraSAtPlxuICAgICAgICAgICAgICAgICAgaWYgSC5lcXVhbCBrLihpKSBraVxuICAgICAgICAgICAgICAgICAgdGhlbiBlcXVhbF9hcnJheSBrIGMgKGktMSlcbiAgICAgICAgICAgICAgICAgIGVsc2UgR2VuSGFzaFRhYmxlLkVGYWxzZVxuICAgICAgICAgIGluXG4gICAgICAgICAgZXF1YWxfYXJyYXkgayBjIChsZW4tMSlcbiAgICAgIGxldCBnZXRfZGF0YSA9IGdldF9kYXRhXG4gICAgICBsZXQgZ2V0X2tleSBjID1cbiAgICAgICAgbGV0IGxlbiA9IGxlbmd0aCBjIGluXG4gICAgICAgIGlmIGxlbiA9IDAgdGhlbiBTb21lIFt8fF1cbiAgICAgICAgZWxzZVxuICAgICAgICAgIG1hdGNoIGdldF9rZXkgYyAwIHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gTm9uZVxuICAgICAgICAgIHwgU29tZSBrMCAtPlxuICAgICAgICAgICAgICBsZXQgcmVjIGZpbGwgYSBpID1cbiAgICAgICAgICAgICAgICBpZiBpIDwgMSB0aGVuIFNvbWUgYVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgIG1hdGNoIGdldF9rZXkgYyBpIHdpdGhcbiAgICAgICAgICAgICAgICAgIHwgTm9uZSAtPiBOb25lXG4gICAgICAgICAgICAgICAgICB8IFNvbWUga2kgLT5cbiAgICAgICAgICAgICAgICAgICAgICBhLihpKSA8LSBraTtcbiAgICAgICAgICAgICAgICAgICAgICBmaWxsIGEgKGktMSlcbiAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgbGV0IGEgPSBBcnJheS5tYWtlIGxlbiBrMCBpblxuICAgICAgICAgICAgICBmaWxsIGEgKGxlbi0xKVxuICAgICAgbGV0IHNldF9rZXlfZGF0YSBjIGsgZCA9XG4gICAgICAgIHVuc2V0X2RhdGEgYztcbiAgICAgICAgZm9yIGk9MCB0byBBcnJheS5sZW5ndGggayAtMSBkb1xuICAgICAgICAgIHNldF9rZXkgYyBpIGsuKGkpO1xuICAgICAgICBkb25lO1xuICAgICAgICBzZXRfZGF0YSBjIGRcbiAgICAgIGxldCBjaGVja19rZXkgYyA9XG4gICAgICAgIGxldCByZWMgY2hlY2sgYyBpID1cbiAgICAgICAgICBpIDwgMCB8fCAoY2hlY2tfa2V5IGMgaSAmJiBjaGVjayBjIChpLTEpKSBpblxuICAgICAgICBjaGVjayBjIChsZW5ndGggYyAtIDEpXG4gICAgZW5kKVxuXG4gIG1vZHVsZSBNYWtlKEg6IEhhc2h0YmwuSGFzaGVkVHlwZSk6IChTIHdpdGggdHlwZSBrZXkgPSBILnQgYXJyYXkpID1cbiAgc3RydWN0XG4gICAgaW5jbHVkZSBNYWtlU2VlZGVkKHN0cnVjdFxuICAgICAgICB0eXBlIHQgPSBILnRcbiAgICAgICAgbGV0IGVxdWFsID0gSC5lcXVhbFxuICAgICAgICBsZXQgaGFzaCAoX3NlZWQ6IGludCkgeCA9IEguaGFzaCB4XG4gICAgICBlbmQpXG4gICAgbGV0IGNyZWF0ZSBzeiA9IGNyZWF0ZSB+cmFuZG9tOmZhbHNlIHN6XG4gICAgbGV0IG9mX3NlcSBpID1cbiAgICAgIGxldCB0YmwgPSBjcmVhdGUgMTYgaW5cbiAgICAgIHJlcGxhY2Vfc2VxIHRibCBpO1xuICAgICAgdGJsXG4gIGVuZFxuZW5kXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgTWFudWVsIFNlcnJhbm8gZXQgWGF2aWVyIExlcm95LCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDAwIEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIE1vZHVsZSBbQmlnYXJyYXldOiBsYXJnZSwgbXVsdGktZGltZW5zaW9uYWwsIG51bWVyaWNhbCBhcnJheXMgKilcblxuKCogVGhlc2UgdHlwZXMgaW4gbXVzdCBiZSBrZXB0IGluIHN5bmMgd2l0aCB0aGUgdGFibGVzIGluXG4gICAuLi90eXBpbmcvdHlwZW9wdC5tbCAqKVxuXG50eXBlIGZsb2F0MzJfZWx0ID0gRmxvYXQzMl9lbHRcbnR5cGUgZmxvYXQ2NF9lbHQgPSBGbG9hdDY0X2VsdFxudHlwZSBpbnQ4X3NpZ25lZF9lbHQgPSBJbnQ4X3NpZ25lZF9lbHRcbnR5cGUgaW50OF91bnNpZ25lZF9lbHQgPSBJbnQ4X3Vuc2lnbmVkX2VsdFxudHlwZSBpbnQxNl9zaWduZWRfZWx0ID0gSW50MTZfc2lnbmVkX2VsdFxudHlwZSBpbnQxNl91bnNpZ25lZF9lbHQgPSBJbnQxNl91bnNpZ25lZF9lbHRcbnR5cGUgaW50MzJfZWx0ID0gSW50MzJfZWx0XG50eXBlIGludDY0X2VsdCA9IEludDY0X2VsdFxudHlwZSBpbnRfZWx0ID0gSW50X2VsdFxudHlwZSBuYXRpdmVpbnRfZWx0ID0gTmF0aXZlaW50X2VsdFxudHlwZSBjb21wbGV4MzJfZWx0ID0gQ29tcGxleDMyX2VsdFxudHlwZSBjb21wbGV4NjRfZWx0ID0gQ29tcGxleDY0X2VsdFxuXG50eXBlICgnYSwgJ2IpIGtpbmQgPVxuICAgIEZsb2F0MzIgOiAoZmxvYXQsIGZsb2F0MzJfZWx0KSBraW5kXG4gIHwgRmxvYXQ2NCA6IChmbG9hdCwgZmxvYXQ2NF9lbHQpIGtpbmRcbiAgfCBJbnQ4X3NpZ25lZCA6IChpbnQsIGludDhfc2lnbmVkX2VsdCkga2luZFxuICB8IEludDhfdW5zaWduZWQgOiAoaW50LCBpbnQ4X3Vuc2lnbmVkX2VsdCkga2luZFxuICB8IEludDE2X3NpZ25lZCA6IChpbnQsIGludDE2X3NpZ25lZF9lbHQpIGtpbmRcbiAgfCBJbnQxNl91bnNpZ25lZCA6IChpbnQsIGludDE2X3Vuc2lnbmVkX2VsdCkga2luZFxuICB8IEludDMyIDogKGludDMyLCBpbnQzMl9lbHQpIGtpbmRcbiAgfCBJbnQ2NCA6IChpbnQ2NCwgaW50NjRfZWx0KSBraW5kXG4gIHwgSW50IDogKGludCwgaW50X2VsdCkga2luZFxuICB8IE5hdGl2ZWludCA6IChuYXRpdmVpbnQsIG5hdGl2ZWludF9lbHQpIGtpbmRcbiAgfCBDb21wbGV4MzIgOiAoQ29tcGxleC50LCBjb21wbGV4MzJfZWx0KSBraW5kXG4gIHwgQ29tcGxleDY0IDogKENvbXBsZXgudCwgY29tcGxleDY0X2VsdCkga2luZFxuICB8IENoYXIgOiAoY2hhciwgaW50OF91bnNpZ25lZF9lbHQpIGtpbmRcblxudHlwZSBjX2xheW91dCA9IENfbGF5b3V0X3R5cFxudHlwZSBmb3J0cmFuX2xheW91dCA9IEZvcnRyYW5fbGF5b3V0X3R5cCAoKiopXG5cbnR5cGUgJ2EgbGF5b3V0ID1cbiAgICBDX2xheW91dDogY19sYXlvdXQgbGF5b3V0XG4gIHwgRm9ydHJhbl9sYXlvdXQ6IGZvcnRyYW5fbGF5b3V0IGxheW91dFxuXG4oKiBLZWVwIHRob3NlIGNvbnN0YW50cyBpbiBzeW5jIHdpdGggdGhlIGNhbWxfYmFfa2luZCBlbnVtZXJhdGlvblxuICAgaW4gYmlnYXJyYXkuaCAqKVxuXG5sZXQgZmxvYXQzMiA9IEZsb2F0MzJcbmxldCBmbG9hdDY0ID0gRmxvYXQ2NFxubGV0IGludDhfc2lnbmVkID0gSW50OF9zaWduZWRcbmxldCBpbnQ4X3Vuc2lnbmVkID0gSW50OF91bnNpZ25lZFxubGV0IGludDE2X3NpZ25lZCA9IEludDE2X3NpZ25lZFxubGV0IGludDE2X3Vuc2lnbmVkID0gSW50MTZfdW5zaWduZWRcbmxldCBpbnQzMiA9IEludDMyXG5sZXQgaW50NjQgPSBJbnQ2NFxubGV0IGludCA9IEludFxubGV0IG5hdGl2ZWludCA9IE5hdGl2ZWludFxubGV0IGNvbXBsZXgzMiA9IENvbXBsZXgzMlxubGV0IGNvbXBsZXg2NCA9IENvbXBsZXg2NFxubGV0IGNoYXIgPSBDaGFyXG5cbmxldCBraW5kX3NpemVfaW5fYnl0ZXMgOiB0eXBlIGEgYi4gKGEsIGIpIGtpbmQgLT4gaW50ID0gZnVuY3Rpb25cbiAgfCBGbG9hdDMyIC0+IDRcbiAgfCBGbG9hdDY0IC0+IDhcbiAgfCBJbnQ4X3NpZ25lZCAtPiAxXG4gIHwgSW50OF91bnNpZ25lZCAtPiAxXG4gIHwgSW50MTZfc2lnbmVkIC0+IDJcbiAgfCBJbnQxNl91bnNpZ25lZCAtPiAyXG4gIHwgSW50MzIgLT4gNFxuICB8IEludDY0IC0+IDhcbiAgfCBJbnQgLT4gU3lzLndvcmRfc2l6ZSAvIDhcbiAgfCBOYXRpdmVpbnQgLT4gU3lzLndvcmRfc2l6ZSAvIDhcbiAgfCBDb21wbGV4MzIgLT4gOFxuICB8IENvbXBsZXg2NCAtPiAxNlxuICB8IENoYXIgLT4gMVxuXG4oKiBLZWVwIHRob3NlIGNvbnN0YW50cyBpbiBzeW5jIHdpdGggdGhlIGNhbWxfYmFfbGF5b3V0IGVudW1lcmF0aW9uXG4gICBpbiBiaWdhcnJheS5oICopXG5cbmxldCBjX2xheW91dCA9IENfbGF5b3V0XG5sZXQgZm9ydHJhbl9sYXlvdXQgPSBGb3J0cmFuX2xheW91dFxuXG5tb2R1bGUgR2VuYXJyYXkgPSBzdHJ1Y3RcbiAgdHlwZSAoISdhLCAhJ2IsICEnYykgdFxuICBleHRlcm5hbCBjcmVhdGU6ICgnYSwgJ2IpIGtpbmQgLT4gJ2MgbGF5b3V0IC0+IGludCBhcnJheSAtPiAoJ2EsICdiLCAnYykgdFxuICAgICA9IFwiY2FtbF9iYV9jcmVhdGVcIlxuICBleHRlcm5hbCBnZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCBhcnJheSAtPiAnYVxuICAgICA9IFwiY2FtbF9iYV9nZXRfZ2VuZXJpY1wiXG4gIGV4dGVybmFsIHNldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IGFycmF5IC0+ICdhIC0+IHVuaXRcbiAgICAgPSBcImNhbWxfYmFfc2V0X2dlbmVyaWNcIlxuXG4gIGxldCByZWMgY2xvb3AgYXJyIGlkeCBmIGNvbCBtYXggPVxuICAgIGlmIGNvbCA9IEFycmF5Lmxlbmd0aCBpZHggdGhlbiBzZXQgYXJyIGlkeCAoZiBpZHgpXG4gICAgZWxzZSBmb3IgaiA9IDAgdG8gcHJlZCBtYXguKGNvbCkgZG9cbiAgICAgICAgICAgaWR4Lihjb2wpIDwtIGo7XG4gICAgICAgICAgIGNsb29wIGFyciBpZHggZiAoc3VjYyBjb2wpIG1heFxuICAgICAgICAgZG9uZVxuICBsZXQgcmVjIGZsb29wIGFyciBpZHggZiBjb2wgbWF4ID1cbiAgICBpZiBjb2wgPCAwIHRoZW4gc2V0IGFyciBpZHggKGYgaWR4KVxuICAgIGVsc2UgZm9yIGogPSAxIHRvIG1heC4oY29sKSBkb1xuICAgICAgICAgICBpZHguKGNvbCkgPC0gajtcbiAgICAgICAgICAgZmxvb3AgYXJyIGlkeCBmIChwcmVkIGNvbCkgbWF4XG4gICAgICAgICBkb25lXG4gIGxldCBpbml0ICh0eXBlIHQpIGtpbmQgKGxheW91dCA6IHQgbGF5b3V0KSBkaW1zIGYgPVxuICAgIGxldCBhcnIgPSBjcmVhdGUga2luZCBsYXlvdXQgZGltcyBpblxuICAgIG1hdGNoIEFycmF5Lmxlbmd0aCBkaW1zLCBsYXlvdXQgd2l0aFxuICAgIHwgMCwgXyAtPiBhcnJcbiAgICB8IGRsZW4sIENfbGF5b3V0IC0+IGNsb29wIGFyciAoQXJyYXkubWFrZSBkbGVuIDApIGYgMCBkaW1zOyBhcnJcbiAgICB8IGRsZW4sIEZvcnRyYW5fbGF5b3V0IC0+IGZsb29wIGFyciAoQXJyYXkubWFrZSBkbGVuIDEpIGYgKHByZWQgZGxlbikgZGltcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyclxuXG4gIGV4dGVybmFsIG51bV9kaW1zOiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgPSBcImNhbWxfYmFfbnVtX2RpbXNcIlxuICBleHRlcm5hbCBudGhfZGltOiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gaW50ID0gXCJjYW1sX2JhX2RpbVwiXG4gIGxldCBkaW1zIGEgPVxuICAgIGxldCBuID0gbnVtX2RpbXMgYSBpblxuICAgIGxldCBkID0gQXJyYXkubWFrZSBuIDAgaW5cbiAgICBmb3IgaSA9IDAgdG8gbi0xIGRvIGQuKGkpIDwtIG50aF9kaW0gYSBpIGRvbmU7XG4gICAgZFxuXG4gIGV4dGVybmFsIGtpbmQ6ICgnYSwgJ2IsICdjKSB0IC0+ICgnYSwgJ2IpIGtpbmQgPSBcImNhbWxfYmFfa2luZFwiXG4gIGV4dGVybmFsIGxheW91dDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2MgbGF5b3V0ID0gXCJjYW1sX2JhX2xheW91dFwiXG4gIGV4dGVybmFsIGNoYW5nZV9sYXlvdXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICdkIGxheW91dCAtPiAoJ2EsICdiLCAnZCkgdFxuICAgICA9IFwiY2FtbF9iYV9jaGFuZ2VfbGF5b3V0XCJcblxuICBsZXQgc2l6ZV9pbl9ieXRlcyBhcnIgPVxuICAgIChraW5kX3NpemVfaW5fYnl0ZXMgKGtpbmQgYXJyKSkgKiAoQXJyYXkuZm9sZF9sZWZ0ICggKiApIDEgKGRpbXMgYXJyKSlcblxuICBleHRlcm5hbCBzdWJfbGVmdDogKCdhLCAnYiwgY19sYXlvdXQpIHQgLT4gaW50IC0+IGludCAtPiAoJ2EsICdiLCBjX2xheW91dCkgdFxuICAgICA9IFwiY2FtbF9iYV9zdWJcIlxuICBleHRlcm5hbCBzdWJfcmlnaHQ6ICgnYSwgJ2IsIGZvcnRyYW5fbGF5b3V0KSB0IC0+IGludCAtPiBpbnQgLT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgKCdhLCAnYiwgZm9ydHJhbl9sYXlvdXQpIHRcbiAgICAgPSBcImNhbWxfYmFfc3ViXCJcbiAgZXh0ZXJuYWwgc2xpY2VfbGVmdDogKCdhLCAnYiwgY19sYXlvdXQpIHQgLT4gaW50IGFycmF5IC0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICgnYSwgJ2IsIGNfbGF5b3V0KSB0XG4gICAgID0gXCJjYW1sX2JhX3NsaWNlXCJcbiAgZXh0ZXJuYWwgc2xpY2VfcmlnaHQ6ICgnYSwgJ2IsIGZvcnRyYW5fbGF5b3V0KSB0IC0+IGludCBhcnJheSAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAoJ2EsICdiLCBmb3J0cmFuX2xheW91dCkgdFxuICAgICA9IFwiY2FtbF9iYV9zbGljZVwiXG4gIGV4dGVybmFsIGJsaXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICgnYSwgJ2IsICdjKSB0IC0+IHVuaXRcbiAgICAgPSBcImNhbWxfYmFfYmxpdFwiXG4gIGV4dGVybmFsIGZpbGw6ICgnYSwgJ2IsICdjKSB0IC0+ICdhIC0+IHVuaXQgPSBcImNhbWxfYmFfZmlsbFwiXG5lbmRcblxubW9kdWxlIEFycmF5MCA9IHN0cnVjdFxuICB0eXBlICghJ2EsICEnYiwgISdjKSB0ID0gKCdhLCAnYiwgJ2MpIEdlbmFycmF5LnRcbiAgbGV0IGNyZWF0ZSBraW5kIGxheW91dCA9XG4gICAgR2VuYXJyYXkuY3JlYXRlIGtpbmQgbGF5b3V0IFt8fF1cbiAgbGV0IGdldCBhcnIgPSBHZW5hcnJheS5nZXQgYXJyIFt8fF1cbiAgbGV0IHNldCBhcnIgPSBHZW5hcnJheS5zZXQgYXJyIFt8fF1cbiAgZXh0ZXJuYWwga2luZDogKCdhLCAnYiwgJ2MpIHQgLT4gKCdhLCAnYikga2luZCA9IFwiY2FtbF9iYV9raW5kXCJcbiAgZXh0ZXJuYWwgbGF5b3V0OiAoJ2EsICdiLCAnYykgdCAtPiAnYyBsYXlvdXQgPSBcImNhbWxfYmFfbGF5b3V0XCJcblxuICBleHRlcm5hbCBjaGFuZ2VfbGF5b3V0OiAoJ2EsICdiLCAnYykgdCAtPiAnZCBsYXlvdXQgLT4gKCdhLCAnYiwgJ2QpIHRcbiAgICA9IFwiY2FtbF9iYV9jaGFuZ2VfbGF5b3V0XCJcblxuICBsZXQgc2l6ZV9pbl9ieXRlcyBhcnIgPSBraW5kX3NpemVfaW5fYnl0ZXMgKGtpbmQgYXJyKVxuXG4gIGV4dGVybmFsIGJsaXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICgnYSwgJ2IsICdjKSB0IC0+IHVuaXQgPSBcImNhbWxfYmFfYmxpdFwiXG4gIGV4dGVybmFsIGZpbGw6ICgnYSwgJ2IsICdjKSB0IC0+ICdhIC0+IHVuaXQgPSBcImNhbWxfYmFfZmlsbFwiXG5cbiAgbGV0IG9mX3ZhbHVlIGtpbmQgbGF5b3V0IHYgPVxuICAgIGxldCBhID0gY3JlYXRlIGtpbmQgbGF5b3V0IGluXG4gICAgc2V0IGEgdjtcbiAgICBhXG4gIGxldCBpbml0ID0gb2ZfdmFsdWVcbmVuZFxuXG5tb2R1bGUgQXJyYXkxID0gc3RydWN0XG4gIHR5cGUgKCEnYSwgISdiLCAhJ2MpIHQgPSAoJ2EsICdiLCAnYykgR2VuYXJyYXkudFxuICBsZXQgY3JlYXRlIGtpbmQgbGF5b3V0IGRpbSA9XG4gICAgR2VuYXJyYXkuY3JlYXRlIGtpbmQgbGF5b3V0IFt8ZGltfF1cbiAgZXh0ZXJuYWwgZ2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gJ2EgPSBcIiVjYW1sX2JhX3JlZl8xXCJcbiAgZXh0ZXJuYWwgc2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gJ2EgLT4gdW5pdCA9IFwiJWNhbWxfYmFfc2V0XzFcIlxuICBleHRlcm5hbCB1bnNhZmVfZ2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gJ2EgPSBcIiVjYW1sX2JhX3Vuc2FmZV9yZWZfMVwiXG4gIGV4dGVybmFsIHVuc2FmZV9zZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiAnYSAtPiB1bml0XG4gICAgID0gXCIlY2FtbF9iYV91bnNhZmVfc2V0XzFcIlxuICBleHRlcm5hbCBkaW06ICgnYSwgJ2IsICdjKSB0IC0+IGludCA9IFwiJWNhbWxfYmFfZGltXzFcIlxuICBleHRlcm5hbCBraW5kOiAoJ2EsICdiLCAnYykgdCAtPiAoJ2EsICdiKSBraW5kID0gXCJjYW1sX2JhX2tpbmRcIlxuICBleHRlcm5hbCBsYXlvdXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICdjIGxheW91dCA9IFwiY2FtbF9iYV9sYXlvdXRcIlxuXG4gIGV4dGVybmFsIGNoYW5nZV9sYXlvdXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICdkIGxheW91dCAtPiAoJ2EsICdiLCAnZCkgdFxuICAgID0gXCJjYW1sX2JhX2NoYW5nZV9sYXlvdXRcIlxuXG4gIGxldCBzaXplX2luX2J5dGVzIGFyciA9XG4gICAgKGtpbmRfc2l6ZV9pbl9ieXRlcyAoa2luZCBhcnIpKSAqIChkaW0gYXJyKVxuXG4gIGV4dGVybmFsIHN1YjogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+IGludCAtPiAoJ2EsICdiLCAnYykgdCA9IFwiY2FtbF9iYV9zdWJcIlxuICBsZXQgc2xpY2UgKHR5cGUgdCkgKGEgOiAoXywgXywgdCkgR2VuYXJyYXkudCkgbiA9XG4gICAgbWF0Y2ggbGF5b3V0IGEgd2l0aFxuICAgIHwgQ19sYXlvdXQgLT4gKEdlbmFycmF5LnNsaWNlX2xlZnQgYSBbfG58XSA6IChfLCBfLCB0KSBHZW5hcnJheS50KVxuICAgIHwgRm9ydHJhbl9sYXlvdXQgLT4gKEdlbmFycmF5LnNsaWNlX3JpZ2h0IGEgW3xufF06IChfLCBfLCB0KSBHZW5hcnJheS50KVxuICBleHRlcm5hbCBibGl0OiAoJ2EsICdiLCAnYykgdCAtPiAoJ2EsICdiLCAnYykgdCAtPiB1bml0ID0gXCJjYW1sX2JhX2JsaXRcIlxuICBleHRlcm5hbCBmaWxsOiAoJ2EsICdiLCAnYykgdCAtPiAnYSAtPiB1bml0ID0gXCJjYW1sX2JhX2ZpbGxcIlxuICBsZXQgY19pbml0IGFyciBkaW0gZiA9XG4gICAgZm9yIGkgPSAwIHRvIHByZWQgZGltIGRvIHVuc2FmZV9zZXQgYXJyIGkgKGYgaSkgZG9uZVxuICBsZXQgZm9ydHJhbl9pbml0IGFyciBkaW0gZiA9XG4gICAgZm9yIGkgPSAxIHRvIGRpbSBkbyB1bnNhZmVfc2V0IGFyciBpIChmIGkpIGRvbmVcbiAgbGV0IGluaXQgKHR5cGUgdCkga2luZCAobGF5b3V0IDogdCBsYXlvdXQpIGRpbSBmID1cbiAgICBsZXQgYXJyID0gY3JlYXRlIGtpbmQgbGF5b3V0IGRpbSBpblxuICAgIG1hdGNoIGxheW91dCB3aXRoXG4gICAgfCBDX2xheW91dCAtPiBjX2luaXQgYXJyIGRpbSBmOyBhcnJcbiAgICB8IEZvcnRyYW5fbGF5b3V0IC0+IGZvcnRyYW5faW5pdCBhcnIgZGltIGY7IGFyclxuICBsZXQgb2ZfYXJyYXkgKHR5cGUgdCkga2luZCAobGF5b3V0OiB0IGxheW91dCkgZGF0YSA9XG4gICAgbGV0IGJhID0gY3JlYXRlIGtpbmQgbGF5b3V0IChBcnJheS5sZW5ndGggZGF0YSkgaW5cbiAgICBsZXQgb2ZzID1cbiAgICAgIG1hdGNoIGxheW91dCB3aXRoXG4gICAgICAgIENfbGF5b3V0IC0+IDBcbiAgICAgIHwgRm9ydHJhbl9sYXlvdXQgLT4gMVxuICAgIGluXG4gICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCBkYXRhIC0gMSBkbyB1bnNhZmVfc2V0IGJhIChpICsgb2ZzKSBkYXRhLihpKSBkb25lO1xuICAgIGJhXG5lbmRcblxubW9kdWxlIEFycmF5MiA9IHN0cnVjdFxuICB0eXBlICghJ2EsICEnYiwgISdjKSB0ID0gKCdhLCAnYiwgJ2MpIEdlbmFycmF5LnRcbiAgbGV0IGNyZWF0ZSBraW5kIGxheW91dCBkaW0xIGRpbTIgPVxuICAgIEdlbmFycmF5LmNyZWF0ZSBraW5kIGxheW91dCBbfGRpbTE7IGRpbTJ8XVxuICBleHRlcm5hbCBnZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiBpbnQgLT4gJ2EgPSBcIiVjYW1sX2JhX3JlZl8yXCJcbiAgZXh0ZXJuYWwgc2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gaW50IC0+ICdhIC0+IHVuaXQgPSBcIiVjYW1sX2JhX3NldF8yXCJcbiAgZXh0ZXJuYWwgdW5zYWZlX2dldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+IGludCAtPiAnYVxuICAgICA9IFwiJWNhbWxfYmFfdW5zYWZlX3JlZl8yXCJcbiAgZXh0ZXJuYWwgdW5zYWZlX3NldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+IGludCAtPiAnYSAtPiB1bml0XG4gICAgID0gXCIlY2FtbF9iYV91bnNhZmVfc2V0XzJcIlxuICBleHRlcm5hbCBkaW0xOiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgPSBcIiVjYW1sX2JhX2RpbV8xXCJcbiAgZXh0ZXJuYWwgZGltMjogKCdhLCAnYiwgJ2MpIHQgLT4gaW50ID0gXCIlY2FtbF9iYV9kaW1fMlwiXG4gIGV4dGVybmFsIGtpbmQ6ICgnYSwgJ2IsICdjKSB0IC0+ICgnYSwgJ2IpIGtpbmQgPSBcImNhbWxfYmFfa2luZFwiXG4gIGV4dGVybmFsIGxheW91dDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2MgbGF5b3V0ID0gXCJjYW1sX2JhX2xheW91dFwiXG5cbiAgZXh0ZXJuYWwgY2hhbmdlX2xheW91dDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2QgbGF5b3V0IC0+ICgnYSwgJ2IsICdkKSB0XG4gICAgPSBcImNhbWxfYmFfY2hhbmdlX2xheW91dFwiXG5cbiAgbGV0IHNpemVfaW5fYnl0ZXMgYXJyID1cbiAgICAoa2luZF9zaXplX2luX2J5dGVzIChraW5kIGFycikpICogKGRpbTEgYXJyKSAqIChkaW0yIGFycilcblxuICBleHRlcm5hbCBzdWJfbGVmdDogKCdhLCAnYiwgY19sYXlvdXQpIHQgLT4gaW50IC0+IGludCAtPiAoJ2EsICdiLCBjX2xheW91dCkgdFxuICAgICA9IFwiY2FtbF9iYV9zdWJcIlxuICBleHRlcm5hbCBzdWJfcmlnaHQ6XG4gICAgKCdhLCAnYiwgZm9ydHJhbl9sYXlvdXQpIHQgLT4gaW50IC0+IGludCAtPiAoJ2EsICdiLCBmb3J0cmFuX2xheW91dCkgdFxuICAgICA9IFwiY2FtbF9iYV9zdWJcIlxuICBsZXQgc2xpY2VfbGVmdCBhIG4gPSBHZW5hcnJheS5zbGljZV9sZWZ0IGEgW3xufF1cbiAgbGV0IHNsaWNlX3JpZ2h0IGEgbiA9IEdlbmFycmF5LnNsaWNlX3JpZ2h0IGEgW3xufF1cbiAgZXh0ZXJuYWwgYmxpdDogKCdhLCAnYiwgJ2MpIHQgLT4gKCdhLCAnYiwgJ2MpIHQgLT4gdW5pdCA9IFwiY2FtbF9iYV9ibGl0XCJcbiAgZXh0ZXJuYWwgZmlsbDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2EgLT4gdW5pdCA9IFwiY2FtbF9iYV9maWxsXCJcbiAgbGV0IGNfaW5pdCBhcnIgZGltMSBkaW0yIGYgPVxuICAgIGZvciBpID0gMCB0byBwcmVkIGRpbTEgZG9cbiAgICAgIGZvciBqID0gMCB0byBwcmVkIGRpbTIgZG9cbiAgICAgICAgdW5zYWZlX3NldCBhcnIgaSBqIChmIGkgailcbiAgICAgIGRvbmVcbiAgICBkb25lXG4gIGxldCBmb3J0cmFuX2luaXQgYXJyIGRpbTEgZGltMiBmID1cbiAgICBmb3IgaiA9IDEgdG8gZGltMiBkb1xuICAgICAgZm9yIGkgPSAxIHRvIGRpbTEgZG9cbiAgICAgICAgdW5zYWZlX3NldCBhcnIgaSBqIChmIGkgailcbiAgICAgIGRvbmVcbiAgICBkb25lXG4gIGxldCBpbml0ICh0eXBlIHQpIGtpbmQgKGxheW91dCA6IHQgbGF5b3V0KSBkaW0xIGRpbTIgZiA9XG4gICAgbGV0IGFyciA9IGNyZWF0ZSBraW5kIGxheW91dCBkaW0xIGRpbTIgaW5cbiAgICBtYXRjaCBsYXlvdXQgd2l0aFxuICAgIHwgQ19sYXlvdXQgLT4gY19pbml0IGFyciBkaW0xIGRpbTIgZjsgYXJyXG4gICAgfCBGb3J0cmFuX2xheW91dCAtPiBmb3J0cmFuX2luaXQgYXJyIGRpbTEgZGltMiBmOyBhcnJcbiAgbGV0IG9mX2FycmF5ICh0eXBlIHQpIGtpbmQgKGxheW91dDogdCBsYXlvdXQpIGRhdGEgPVxuICAgIGxldCBkaW0xID0gQXJyYXkubGVuZ3RoIGRhdGEgaW5cbiAgICBsZXQgZGltMiA9IGlmIGRpbTEgPSAwIHRoZW4gMCBlbHNlIEFycmF5Lmxlbmd0aCBkYXRhLigwKSBpblxuICAgIGxldCBiYSA9IGNyZWF0ZSBraW5kIGxheW91dCBkaW0xIGRpbTIgaW5cbiAgICBsZXQgb2ZzID1cbiAgICAgIG1hdGNoIGxheW91dCB3aXRoXG4gICAgICAgIENfbGF5b3V0IC0+IDBcbiAgICAgIHwgRm9ydHJhbl9sYXlvdXQgLT4gMVxuICAgIGluXG4gICAgZm9yIGkgPSAwIHRvIGRpbTEgLSAxIGRvXG4gICAgICBsZXQgcm93ID0gZGF0YS4oaSkgaW5cbiAgICAgIGlmIEFycmF5Lmxlbmd0aCByb3cgPD4gZGltMiB0aGVuXG4gICAgICAgIGludmFsaWRfYXJnKFwiQmlnYXJyYXkuQXJyYXkyLm9mX2FycmF5OiBub24tcmVjdGFuZ3VsYXIgZGF0YVwiKTtcbiAgICAgIGZvciBqID0gMCB0byBkaW0yIC0gMSBkb1xuICAgICAgICB1bnNhZmVfc2V0IGJhIChpICsgb2ZzKSAoaiArIG9mcykgcm93LihqKVxuICAgICAgZG9uZVxuICAgIGRvbmU7XG4gICAgYmFcbmVuZFxuXG5tb2R1bGUgQXJyYXkzID0gc3RydWN0XG4gIHR5cGUgKCEnYSwgISdiLCAhJ2MpIHQgPSAoJ2EsICdiLCAnYykgR2VuYXJyYXkudFxuICBsZXQgY3JlYXRlIGtpbmQgbGF5b3V0IGRpbTEgZGltMiBkaW0zID1cbiAgICBHZW5hcnJheS5jcmVhdGUga2luZCBsYXlvdXQgW3xkaW0xOyBkaW0yOyBkaW0zfF1cbiAgZXh0ZXJuYWwgZ2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gaW50IC0+IGludCAtPiAnYSA9IFwiJWNhbWxfYmFfcmVmXzNcIlxuICBleHRlcm5hbCBzZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiBpbnQgLT4gaW50IC0+ICdhIC0+IHVuaXRcbiAgICAgPSBcIiVjYW1sX2JhX3NldF8zXCJcbiAgZXh0ZXJuYWwgdW5zYWZlX2dldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+IGludCAtPiBpbnQgLT4gJ2FcbiAgICAgPSBcIiVjYW1sX2JhX3Vuc2FmZV9yZWZfM1wiXG4gIGV4dGVybmFsIHVuc2FmZV9zZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiBpbnQgLT4gaW50IC0+ICdhIC0+IHVuaXRcbiAgICAgPSBcIiVjYW1sX2JhX3Vuc2FmZV9zZXRfM1wiXG4gIGV4dGVybmFsIGRpbTE6ICgnYSwgJ2IsICdjKSB0IC0+IGludCA9IFwiJWNhbWxfYmFfZGltXzFcIlxuICBleHRlcm5hbCBkaW0yOiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgPSBcIiVjYW1sX2JhX2RpbV8yXCJcbiAgZXh0ZXJuYWwgZGltMzogKCdhLCAnYiwgJ2MpIHQgLT4gaW50ID0gXCIlY2FtbF9iYV9kaW1fM1wiXG4gIGV4dGVybmFsIGtpbmQ6ICgnYSwgJ2IsICdjKSB0IC0+ICgnYSwgJ2IpIGtpbmQgPSBcImNhbWxfYmFfa2luZFwiXG4gIGV4dGVybmFsIGxheW91dDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2MgbGF5b3V0ID0gXCJjYW1sX2JhX2xheW91dFwiXG5cbiAgZXh0ZXJuYWwgY2hhbmdlX2xheW91dDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2QgbGF5b3V0IC0+ICgnYSwgJ2IsICdkKSB0XG4gICAgPSBcImNhbWxfYmFfY2hhbmdlX2xheW91dFwiXG5cbiAgbGV0IHNpemVfaW5fYnl0ZXMgYXJyID1cbiAgICAoa2luZF9zaXplX2luX2J5dGVzIChraW5kIGFycikpICogKGRpbTEgYXJyKSAqIChkaW0yIGFycikgKiAoZGltMyBhcnIpXG5cbiAgZXh0ZXJuYWwgc3ViX2xlZnQ6ICgnYSwgJ2IsIGNfbGF5b3V0KSB0IC0+IGludCAtPiBpbnQgLT4gKCdhLCAnYiwgY19sYXlvdXQpIHRcbiAgICAgPSBcImNhbWxfYmFfc3ViXCJcbiAgZXh0ZXJuYWwgc3ViX3JpZ2h0OlxuICAgICAoJ2EsICdiLCBmb3J0cmFuX2xheW91dCkgdCAtPiBpbnQgLT4gaW50IC0+ICgnYSwgJ2IsIGZvcnRyYW5fbGF5b3V0KSB0XG4gICAgID0gXCJjYW1sX2JhX3N1YlwiXG4gIGxldCBzbGljZV9sZWZ0XzEgYSBuIG0gPSBHZW5hcnJheS5zbGljZV9sZWZ0IGEgW3xuOyBtfF1cbiAgbGV0IHNsaWNlX3JpZ2h0XzEgYSBuIG0gPSBHZW5hcnJheS5zbGljZV9yaWdodCBhIFt8bjsgbXxdXG4gIGxldCBzbGljZV9sZWZ0XzIgYSBuID0gR2VuYXJyYXkuc2xpY2VfbGVmdCBhIFt8bnxdXG4gIGxldCBzbGljZV9yaWdodF8yIGEgbiA9IEdlbmFycmF5LnNsaWNlX3JpZ2h0IGEgW3xufF1cbiAgZXh0ZXJuYWwgYmxpdDogKCdhLCAnYiwgJ2MpIHQgLT4gKCdhLCAnYiwgJ2MpIHQgLT4gdW5pdCA9IFwiY2FtbF9iYV9ibGl0XCJcbiAgZXh0ZXJuYWwgZmlsbDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2EgLT4gdW5pdCA9IFwiY2FtbF9iYV9maWxsXCJcbiAgbGV0IGNfaW5pdCBhcnIgZGltMSBkaW0yIGRpbTMgZiA9XG4gICAgZm9yIGkgPSAwIHRvIHByZWQgZGltMSBkb1xuICAgICAgZm9yIGogPSAwIHRvIHByZWQgZGltMiBkb1xuICAgICAgICBmb3IgayA9IDAgdG8gcHJlZCBkaW0zIGRvXG4gICAgICAgICAgdW5zYWZlX3NldCBhcnIgaSBqIGsgKGYgaSBqIGspXG4gICAgICAgIGRvbmVcbiAgICAgIGRvbmVcbiAgICBkb25lXG4gIGxldCBmb3J0cmFuX2luaXQgYXJyIGRpbTEgZGltMiBkaW0zIGYgPVxuICAgIGZvciBrID0gMSB0byBkaW0zIGRvXG4gICAgICBmb3IgaiA9IDEgdG8gZGltMiBkb1xuICAgICAgICBmb3IgaSA9IDEgdG8gZGltMSBkb1xuICAgICAgICAgIHVuc2FmZV9zZXQgYXJyIGkgaiBrIChmIGkgaiBrKVxuICAgICAgICBkb25lXG4gICAgICBkb25lXG4gICAgZG9uZVxuICBsZXQgaW5pdCAodHlwZSB0KSBraW5kIChsYXlvdXQgOiB0IGxheW91dCkgZGltMSBkaW0yIGRpbTMgZiA9XG4gICAgbGV0IGFyciA9IGNyZWF0ZSBraW5kIGxheW91dCBkaW0xIGRpbTIgZGltMyBpblxuICAgIG1hdGNoIGxheW91dCB3aXRoXG4gICAgfCBDX2xheW91dCAtPiBjX2luaXQgYXJyIGRpbTEgZGltMiBkaW0zIGY7IGFyclxuICAgIHwgRm9ydHJhbl9sYXlvdXQgLT4gZm9ydHJhbl9pbml0IGFyciBkaW0xIGRpbTIgZGltMyBmOyBhcnJcbiAgbGV0IG9mX2FycmF5ICh0eXBlIHQpIGtpbmQgKGxheW91dDogdCBsYXlvdXQpIGRhdGEgPVxuICAgIGxldCBkaW0xID0gQXJyYXkubGVuZ3RoIGRhdGEgaW5cbiAgICBsZXQgZGltMiA9IGlmIGRpbTEgPSAwIHRoZW4gMCBlbHNlIEFycmF5Lmxlbmd0aCBkYXRhLigwKSBpblxuICAgIGxldCBkaW0zID0gaWYgZGltMiA9IDAgdGhlbiAwIGVsc2UgQXJyYXkubGVuZ3RoIGRhdGEuKDApLigwKSBpblxuICAgIGxldCBiYSA9IGNyZWF0ZSBraW5kIGxheW91dCBkaW0xIGRpbTIgZGltMyBpblxuICAgIGxldCBvZnMgPVxuICAgICAgbWF0Y2ggbGF5b3V0IHdpdGhcbiAgICAgICAgQ19sYXlvdXQgLT4gMFxuICAgICAgfCBGb3J0cmFuX2xheW91dCAtPiAxXG4gICAgaW5cbiAgICBmb3IgaSA9IDAgdG8gZGltMSAtIDEgZG9cbiAgICAgIGxldCByb3cgPSBkYXRhLihpKSBpblxuICAgICAgaWYgQXJyYXkubGVuZ3RoIHJvdyA8PiBkaW0yIHRoZW5cbiAgICAgICAgaW52YWxpZF9hcmcoXCJCaWdhcnJheS5BcnJheTMub2ZfYXJyYXk6IG5vbi1jdWJpYyBkYXRhXCIpO1xuICAgICAgZm9yIGogPSAwIHRvIGRpbTIgLSAxIGRvXG4gICAgICAgIGxldCBjb2wgPSByb3cuKGopIGluXG4gICAgICAgIGlmIEFycmF5Lmxlbmd0aCBjb2wgPD4gZGltMyB0aGVuXG4gICAgICAgICAgaW52YWxpZF9hcmcoXCJCaWdhcnJheS5BcnJheTMub2ZfYXJyYXk6IG5vbi1jdWJpYyBkYXRhXCIpO1xuICAgICAgICBmb3IgayA9IDAgdG8gZGltMyAtIDEgZG9cbiAgICAgICAgICB1bnNhZmVfc2V0IGJhIChpICsgb2ZzKSAoaiArIG9mcykgKGsgKyBvZnMpIGNvbC4oaylcbiAgICAgICAgZG9uZVxuICAgICAgZG9uZVxuICAgIGRvbmU7XG4gICAgYmFcbmVuZFxuXG5leHRlcm5hbCBnZW5hcnJheV9vZl9hcnJheTA6ICgnYSwgJ2IsICdjKSBBcnJheTAudCAtPiAoJ2EsICdiLCAnYykgR2VuYXJyYXkudFxuICAgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCBnZW5hcnJheV9vZl9hcnJheTE6ICgnYSwgJ2IsICdjKSBBcnJheTEudCAtPiAoJ2EsICdiLCAnYykgR2VuYXJyYXkudFxuICAgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCBnZW5hcnJheV9vZl9hcnJheTI6ICgnYSwgJ2IsICdjKSBBcnJheTIudCAtPiAoJ2EsICdiLCAnYykgR2VuYXJyYXkudFxuICAgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCBnZW5hcnJheV9vZl9hcnJheTM6ICgnYSwgJ2IsICdjKSBBcnJheTMudCAtPiAoJ2EsICdiLCAnYykgR2VuYXJyYXkudFxuICAgPSBcIiVpZGVudGl0eVwiXG5sZXQgYXJyYXkwX29mX2dlbmFycmF5IGEgPVxuICBpZiBHZW5hcnJheS5udW1fZGltcyBhID0gMCB0aGVuIGFcbiAgZWxzZSBpbnZhbGlkX2FyZyBcIkJpZ2FycmF5LmFycmF5MF9vZl9nZW5hcnJheVwiXG5sZXQgYXJyYXkxX29mX2dlbmFycmF5IGEgPVxuICBpZiBHZW5hcnJheS5udW1fZGltcyBhID0gMSB0aGVuIGFcbiAgZWxzZSBpbnZhbGlkX2FyZyBcIkJpZ2FycmF5LmFycmF5MV9vZl9nZW5hcnJheVwiXG5sZXQgYXJyYXkyX29mX2dlbmFycmF5IGEgPVxuICBpZiBHZW5hcnJheS5udW1fZGltcyBhID0gMiB0aGVuIGFcbiAgZWxzZSBpbnZhbGlkX2FyZyBcIkJpZ2FycmF5LmFycmF5Ml9vZl9nZW5hcnJheVwiXG5sZXQgYXJyYXkzX29mX2dlbmFycmF5IGEgPVxuICBpZiBHZW5hcnJheS5udW1fZGltcyBhID0gMyB0aGVuIGFcbiAgZWxzZSBpbnZhbGlkX2FyZyBcIkJpZ2FycmF5LmFycmF5M19vZl9nZW5hcnJheVwiXG5cbmV4dGVybmFsIHJlc2hhcGU6XG4gICAoJ2EsICdiLCAnYykgR2VuYXJyYXkudCAtPiBpbnQgYXJyYXkgLT4gKCdhLCAnYiwgJ2MpIEdlbmFycmF5LnRcbiAgID0gXCJjYW1sX2JhX3Jlc2hhcGVcIlxubGV0IHJlc2hhcGVfMCBhID0gcmVzaGFwZSBhIFt8fF1cbmxldCByZXNoYXBlXzEgYSBkaW0xID0gcmVzaGFwZSBhIFt8ZGltMXxdXG5sZXQgcmVzaGFwZV8yIGEgZGltMSBkaW0yID0gcmVzaGFwZSBhIFt8ZGltMTtkaW0yfF1cbmxldCByZXNoYXBlXzMgYSBkaW0xIGRpbTIgZGltMyA9IHJlc2hhcGUgYSBbfGRpbTE7ZGltMjtkaW0zfF1cblxuKCogRm9yY2UgY2FtbF9iYV9nZXRfezEsMiwzLE59IHRvIGJlIGxpbmtlZCBpbiwgc2luY2Ugd2UgZG9uJ3QgcmVmZXJcbiAgIHRvIHRob3NlIHByaW1pdGl2ZXMgZGlyZWN0bHkgaW4gdGhpcyBmaWxlICopXG5cbmxldCBfID1cbiAgbGV0IF8gPSBHZW5hcnJheS5nZXQgaW5cbiAgbGV0IF8gPSBBcnJheTEuZ2V0IGluXG4gIGxldCBfID0gQXJyYXkyLmdldCBpblxuICBsZXQgXyA9IEFycmF5My5nZXQgaW5cbiAgKClcblxuW0BAQG9jYW1sLndhcm5pbmcgXCItMzJcIl1cbmV4dGVybmFsIGdldDE6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9iYV9nZXRfMVwiXG5leHRlcm5hbCBnZXQyOiB1bml0IC0+IHVuaXQgPSBcImNhbWxfYmFfZ2V0XzJcIlxuZXh0ZXJuYWwgZ2V0MzogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2JhX2dldF8zXCJcbmV4dGVybmFsIHNldDE6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9iYV9zZXRfMVwiXG5leHRlcm5hbCBzZXQyOiB1bml0IC0+IHVuaXQgPSBcImNhbWxfYmFfc2V0XzJcIlxuZXh0ZXJuYWwgc2V0MzogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2JhX3NldF8zXCJcbiIsIlxudHlwZSBwa21uX2NoYXIgPSBVbnVzZWQgfCBVbnJlYWRhYmxlIG9mIHN0cmluZ1xuICAgICAgICAgICAgICAgfCBVbmF2YWlsYWJsZSBvZiBzdHJpbmcgfCBBdmFpbGFibGUgb2Ygc3RyaW5nXG5cbmxldCBjaGFyc2V0X2VuZyA9XG4gIFt8XG4gICgqIDB4MC4gKilcbiAgQXZhaWxhYmxlICAgXCJfXCIgOyBVbmF2YWlsYWJsZSBcIsOAXCIgOyBVbmF2YWlsYWJsZSBcIsOBXCIgOyBVbmF2YWlsYWJsZSBcIsOCXCIgO1xuICBVbmF2YWlsYWJsZSBcIsOHXCIgOyBVbmF2YWlsYWJsZSBcIsOIXCIgOyBVbmF2YWlsYWJsZSBcIsOJXCIgOyBVbmF2YWlsYWJsZSBcIsOKXCIgO1xuICBVbmF2YWlsYWJsZSBcIsOLXCIgOyBVbmF2YWlsYWJsZSBcIsOMXCIgOyBVbnVzZWQgICAgICAgICAgOyBVbmF2YWlsYWJsZSBcIsOOXCIgO1xuICBVbmF2YWlsYWJsZSBcIsOPXCIgOyBVbmF2YWlsYWJsZSBcIsOSXCIgOyBVbmF2YWlsYWJsZSBcIsOTXCIgOyBVbmF2YWlsYWJsZSBcIsOUXCIgO1xuICAoKiAweDEuICopXG4gIFVuYXZhaWxhYmxlIFwixZJcIiA7IFVuYXZhaWxhYmxlIFwiw5lcIiA7IFVuYXZhaWxhYmxlIFwiw5pcIiA7IFVuYXZhaWxhYmxlIFwiw5tcIiA7XG4gIFVuYXZhaWxhYmxlIFwiw5FcIiA7IFVuYXZhaWxhYmxlIFwiw59cIiA7IFVuYXZhaWxhYmxlIFwiw6BcIiA7IFVuYXZhaWxhYmxlIFwiw6FcIiA7XG4gIFVudXNlZCAgICAgICAgICA7IFVuYXZhaWxhYmxlIFwiw6dcIiA7IFVuYXZhaWxhYmxlIFwiw6hcIiA7IFVuYXZhaWxhYmxlIFwiw6lcIiA7XG4gIFVuYXZhaWxhYmxlIFwiw6pcIiA7IFVuYXZhaWxhYmxlIFwiw6tcIiA7IFVuYXZhaWxhYmxlIFwiw6xcIiA7IFVudXNlZCAgICAgICAgICA7XG4gICgqIDB4Mi4gKilcbiAgVW5hdmFpbGFibGUgXCLDrlwiICA7IFVuYXZhaWxhYmxlIFwiw69cIiA7IFVuYXZhaWxhYmxlIFwiw7JcIiA7IFVuYXZhaWxhYmxlIFwiw7NcIiA7XG4gIFVuYXZhaWxhYmxlIFwiw7RcIiAgOyBVbmF2YWlsYWJsZSBcIsWTXCIgOyBVbmF2YWlsYWJsZSBcIsO5XCIgOyBVbmF2YWlsYWJsZSBcIsO6XCIgO1xuICBVbmF2YWlsYWJsZSBcIsO7XCIgIDsgVW5hdmFpbGFibGUgXCLDsVwiIDsgVW5hdmFpbGFibGUgXCLCulwiIDsgVW5hdmFpbGFibGUgXCLCqlwiIDtcbiAgVW5hdmFpbGFibGUgXCLhtYnKs1wiIDsgVW5hdmFpbGFibGUgXCImXCIgOyBVbmF2YWlsYWJsZSBcIitcIiA7IFVudXNlZCAgICAgICAgICA7XG4gICgqIDB4My4gKilcbiAgVW51c2VkICAgICAgICAgICA7IFVudXNlZCAgICAgICAgICA7IFVudXNlZCAgICAgICAgICA7IFVudXNlZCAgICAgICAgICA7XG4gIFVuYXZhaWxhYmxlIFwiTHZcIiA7IFVuYXZhaWxhYmxlIFwiPVwiIDsgVW5hdmFpbGFibGUgXCI7XCIgOyBVbnVzZWQgICAgICAgICAgO1xuICBVbnVzZWQgICAgICAgICAgIDsgVW51c2VkICAgICAgICAgIDsgVW51c2VkICAgICAgICAgIDsgVW51c2VkICAgICAgICAgIDtcbiAgVW51c2VkICAgICAgICAgICA7IFVudXNlZCAgICAgICAgICA7IFVudXNlZCAgICAgICAgICA7IFVudXNlZCAgICAgICAgICA7XG4gICgqIDB4NC4gKilcbiAgVW51c2VkICAgICAgICAgIDsgVW51c2VkICAgICAgICAgIDsgVW51c2VkICAgICAgICAgIDsgVW51c2VkICAgICAgICAgIDtcbiAgVW51c2VkICAgICAgICAgIDsgVW51c2VkICAgICAgICAgIDsgVW51c2VkICAgICAgICAgIDsgVW51c2VkICAgICAgICAgIDtcbiAgVW51c2VkICAgICAgICAgIDsgVW51c2VkICAgICAgICAgIDsgVW51c2VkICAgICAgICAgIDsgVW51c2VkICAgICAgICAgIDtcbiAgVW51c2VkICAgICAgICAgIDsgVW51c2VkICAgICAgICAgIDsgVW51c2VkICAgICAgICAgIDsgVW51c2VkICAgICAgICAgIDtcbiAgKCogMHg1LiAqKVxuICBVbmF2YWlsYWJsZSBcIuKWr1wiICAgOyBVbmF2YWlsYWJsZSBcIsK/XCIgICAgOyBVbmF2YWlsYWJsZSBcIsKhXCIgIDsgVW5hdmFpbGFibGUgXCJQS1wiICAgO1xuICBVbmF2YWlsYWJsZSBcIk1OXCIgICA7IFVuYXZhaWxhYmxlIFwiUE9cIiAgIDsgVW5hdmFpbGFibGUgXCJLw6lcIiA7IFVucmVhZGFibGUgXCIweDU3XCIgIDtcbiAgVW5yZWFkYWJsZSAgXCIweDU4XCIgOyBVbnJlYWRhYmxlIFwiMHg1OVwiICA7IFVuYXZhaWxhYmxlIFwiw41cIiAgOyBVbmF2YWlsYWJsZSBcIiVcIiAgICA7XG4gIFVuYXZhaWxhYmxlIFwiKFwiICAgIDsgVW5hdmFpbGFibGUgXCIpXCIgICAgOyBVbnVzZWQgICAgICAgICAgIDsgVW51c2VkICAgICAgICAgICAgIDtcbiAgKCogMHg2LiAqKVxuICBVbnVzZWQgICAgICAgICAgOyBVbnVzZWQgICAgICAgICAgOyBVbnVzZWQgICAgICAgICAgOyBVbnVzZWQgICAgICAgICAgO1xuICBVbnVzZWQgICAgICAgICAgOyBVbnVzZWQgICAgICAgICAgOyBVbnVzZWQgICAgICAgICAgOyBVbnVzZWQgICAgICAgICAgO1xuICBVbmF2YWlsYWJsZSBcIsOiXCIgOyBVbnVzZWQgICAgICAgICAgOyBVbnVzZWQgICAgICAgICAgOyBVbnVzZWQgICAgICAgICAgO1xuICBVbnVzZWQgICAgICAgICAgOyBVbnVzZWQgICAgICAgICAgOyBVbnVzZWQgICAgICAgICAgOyBVbmF2YWlsYWJsZSBcIsOtXCIgO1xuICAoKiAweDcuICopXG4gIFVudXNlZCAgICAgICAgICA7IFVudXNlZCAgICAgICAgICA7IFVudXNlZCAgICAgICAgICA7IFVudXNlZCAgICAgICAgICA7XG4gIFVudXNlZCAgICAgICAgICA7IFVudXNlZCAgICAgICAgICA7IFVudXNlZCAgICAgICAgICA7IFVudXNlZCAgICAgICAgICA7XG4gIFVudXNlZCAgICAgICAgICA7IFVuYXZhaWxhYmxlIFwi4qyGXCIgOyBVbmF2YWlsYWJsZSBcIuKsh1wiIDsgVW5hdmFpbGFibGUgXCLirIVcIiA7XG4gIFVuYXZhaWxhYmxlIFwi4p6hXCIgOyBVbmF2YWlsYWJsZSBcIipcIiA7IFVuYXZhaWxhYmxlIFwiKlwiIDsgVW5hdmFpbGFibGUgXCIqXCIgO1xuICAoKiAweDguICopXG4gIFVuYXZhaWxhYmxlIFwiKlwiIDsgVW5hdmFpbGFibGUgXCIqXCIgOyBVbmF2YWlsYWJsZSBcIipcIiA7IFVuYXZhaWxhYmxlIFwiKlwiIDtcbiAgVW5hdmFpbGFibGUgXCLhtYlcIiA7IFVuYXZhaWxhYmxlIFwiPFwiIDsgVW5hdmFpbGFibGUgXCI+XCIgOyBVbnVzZWQgICAgICAgICAgO1xuICBVbnVzZWQgICAgICAgICAgOyBVbnVzZWQgICAgICAgICAgOyBVbnVzZWQgICAgICAgICAgOyBVbnVzZWQgICAgICAgICAgO1xuICBVbnVzZWQgICAgICAgICAgOyBVbnVzZWQgICAgICAgICAgOyBVbnVzZWQgICAgICAgICAgOyBVbnVzZWQgICAgICAgICAgO1xuICAoKiAweDkuICopXG4gIFVudXNlZCAgICAgICAgICA7IFVudXNlZCAgICAgICAgICA7IFVudXNlZCAgICAgICAgICA7IFVudXNlZCAgICAgICAgICA7XG4gIFVudXNlZCAgICAgICAgICA7IFVudXNlZCAgICAgICAgICA7IFVudXNlZCAgICAgICAgICA7IFVudXNlZCAgICAgICAgICA7XG4gIFVudXNlZCAgICAgICAgICA7IFVudXNlZCAgICAgICAgICA7IFVudXNlZCAgICAgICAgICA7IFVudXNlZCAgICAgICAgICA7XG4gIFVudXNlZCAgICAgICAgICA7IFVudXNlZCAgICAgICAgICA7IFVudXNlZCAgICAgICAgICA7IFVudXNlZCAgICAgICAgICA7XG4gICgqIDB4QS4gKilcbiAgVW5hdmFpbGFibGUgXCLKs+G1iVwiIDsgQXZhaWxhYmxlIFwiMFwiICAgOyBBdmFpbGFibGUgXCIxXCIgOyBBdmFpbGFibGUgXCIyXCIgICAgO1xuICBBdmFpbGFibGUgXCIzXCIgICAgOyBBdmFpbGFibGUgXCI0XCIgICA7IEF2YWlsYWJsZSBcIjVcIiA7IEF2YWlsYWJsZSBcIjZcIiAgICA7XG4gIEF2YWlsYWJsZSBcIjdcIiAgICA7IEF2YWlsYWJsZSBcIjhcIiAgIDsgQXZhaWxhYmxlIFwiOVwiIDsgQXZhaWxhYmxlIFwiIVwiICAgIDtcbiAgQXZhaWxhYmxlIFwiP1wiICAgIDsgQXZhaWxhYmxlIFwiLlwiICAgOyBBdmFpbGFibGUgXCLigJNcIiA7IFVuYXZhaWxhYmxlIFwi44O7XCIgO1xuICAoKiAweEIuICopXG4gIEF2YWlsYWJsZSBcIuKAplwiICAgIDsgQXZhaWxhYmxlIFwi4oCcXCIgICA7IEF2YWlsYWJsZSBcIuKAnVwiIDsgQXZhaWxhYmxlIFwi4oCYXCIgICAgIDtcbiAgQXZhaWxhYmxlIFwi4oCZXCIgICAgOyBBdmFpbGFibGUgXCLimYJcIiAgIDsgQXZhaWxhYmxlIFwi4pmAXCIgOyBVbmF2YWlsYWJsZSBcIlBrJFwiIDtcbiAgQXZhaWxhYmxlIFwiLFwiICAgIDsgVW5hdmFpbGFibGUgXCLDl1wiIDsgQXZhaWxhYmxlIFwiL1wiIDsgQXZhaWxhYmxlIFwiQVwiICAgICA7XG4gIEF2YWlsYWJsZSBcIkJcIiAgICA7IEF2YWlsYWJsZSBcIkNcIiAgIDsgQXZhaWxhYmxlIFwiRFwiIDsgQXZhaWxhYmxlIFwiRVwiICAgICA7XG4gICgqIDB4Qy4gKilcbiAgQXZhaWxhYmxlIFwiRlwiICAgIDsgQXZhaWxhYmxlIFwiR1wiICAgOyBBdmFpbGFibGUgXCJIXCIgOyBBdmFpbGFibGUgXCJJXCIgICAgIDtcbiAgQXZhaWxhYmxlIFwiSlwiICAgIDsgQXZhaWxhYmxlIFwiS1wiICAgOyBBdmFpbGFibGUgXCJMXCIgOyBBdmFpbGFibGUgXCJNXCIgICAgIDtcbiAgQXZhaWxhYmxlIFwiTlwiICAgIDsgQXZhaWxhYmxlIFwiT1wiICAgOyBBdmFpbGFibGUgXCJQXCIgOyBBdmFpbGFibGUgXCJRXCIgICAgIDtcbiAgQXZhaWxhYmxlIFwiUlwiICAgIDsgQXZhaWxhYmxlIFwiU1wiICAgOyBBdmFpbGFibGUgXCJUXCIgOyBBdmFpbGFibGUgXCJVXCIgICAgIDtcbiAgKCogMHhELiAqKVxuICBBdmFpbGFibGUgXCJWXCIgICAgOyBBdmFpbGFibGUgXCJXXCIgICA7IEF2YWlsYWJsZSBcIlhcIiA7IEF2YWlsYWJsZSBcIllcIiAgICAgO1xuICBBdmFpbGFibGUgXCJaXCIgICAgOyBBdmFpbGFibGUgXCJhXCIgICA7IEF2YWlsYWJsZSBcImJcIiA7IEF2YWlsYWJsZSBcImNcIiAgICAgO1xuICBBdmFpbGFibGUgXCJkXCIgICAgOyBBdmFpbGFibGUgXCJlXCIgICA7IEF2YWlsYWJsZSBcImZcIiA7IEF2YWlsYWJsZSBcImdcIiAgICAgO1xuICBBdmFpbGFibGUgXCJoXCIgICAgOyBBdmFpbGFibGUgXCJpXCIgICA7IEF2YWlsYWJsZSBcImpcIiA7IEF2YWlsYWJsZSBcImtcIiAgICAgO1xuICAoKiAweEUuICopXG4gIEF2YWlsYWJsZSBcImxcIiAgICA7IEF2YWlsYWJsZSBcIm1cIiAgIDsgQXZhaWxhYmxlIFwiblwiIDsgQXZhaWxhYmxlIFwib1wiICAgICA7XG4gIEF2YWlsYWJsZSBcInBcIiAgICA7IEF2YWlsYWJsZSBcInFcIiAgIDsgQXZhaWxhYmxlIFwiclwiIDsgQXZhaWxhYmxlIFwic1wiICAgICA7XG4gIEF2YWlsYWJsZSBcInRcIiAgICA7IEF2YWlsYWJsZSBcInVcIiAgIDsgQXZhaWxhYmxlIFwidlwiIDsgQXZhaWxhYmxlIFwid1wiICAgICA7XG4gIEF2YWlsYWJsZSBcInhcIiAgICA7IEF2YWlsYWJsZSBcInlcIiAgIDsgQXZhaWxhYmxlIFwielwiIDsgVW5hdmFpbGFibGUgXCLilrZcIiAgO1xuICAoKiAweEYuICopXG4gIFVuYXZhaWxhYmxlIFwiOlwiICAgOyBVbmF2YWlsYWJsZSBcIsOEXCIgICA7IFVuYXZhaWxhYmxlIFwiw5ZcIiAgIDsgVW5hdmFpbGFibGUgXCLDnFwiICAgO1xuICBVbmF2YWlsYWJsZSBcIsOkXCIgICA7IFVuYXZhaWxhYmxlIFwiw7ZcIiAgIDsgVW5hdmFpbGFibGUgXCLDvFwiICAgOyBVbnVzZWQgICAgICAgICAgICA7XG4gIFVudXNlZCAgICAgICAgICAgIDsgVW51c2VkICAgICAgICAgICAgOyBVbnJlYWRhYmxlIFwiMHhGQVwiIDsgVW5yZWFkYWJsZSBcIjB4RkJcIiA7XG4gIFVucmVhZGFibGUgXCIweEZDXCIgOyBVbnJlYWRhYmxlIFwiMHhGRFwiIDsgVW5yZWFkYWJsZSBcIjB4RkVcIiA7IFVucmVhZGFibGUgXCIweEZGXCIgO1xuICB8XVxuXG5sZXQgY2hhcnNldF9pdGEgPSBBcnJheS5jb3B5IGNoYXJzZXRfZW5nXG5sZXQgY2hhcnNldF9zcGEgPSBBcnJheS5jb3B5IGNoYXJzZXRfZW5nXG5sZXQgY2hhcnNldF9nZXIgPVxuICBsZXQgY3MgPSBBcnJheS5jb3B5IGNoYXJzZXRfZW5nIGluXG4gIGNzLigweEIxKSA8LSBBdmFpbGFibGUgXCLigJ5cIiA7XG4gIGNzLigweEIyKSA8LSBBdmFpbGFibGUgXCLigJxcIiA7XG4gIGZvciBpPTB4RjEgdG8gMHhGNiBkb1xuICAgIGNzLihpKSA8LSBtYXRjaCBjcy4oaSkgd2l0aFxuICAgICAgfCBVbmF2YWlsYWJsZSBjIC0+IEF2YWlsYWJsZSBjXG4gICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG4gIGRvbmUgO1xuICBjc1xubGV0IGNoYXJzZXRfZnJhID1cbiAgbGV0IGNzID0gQXJyYXkuY29weSBjaGFyc2V0X2VuZyBpblxuICBjcy4oMHhCMSkgPC0gQXZhaWxhYmxlIFwiwqtcIiA7XG4gIGNzLigweEIyKSA8LSBBdmFpbGFibGUgXCLCu1wiIDtcbiAgY3NcblxubGV0IGNoYXJzZXRfamFwID1cbiAgW3xcbiAgKCogMHgwLiAqKVxuICBBdmFpbGFibGUgXCJfXCIgIDsgQXZhaWxhYmxlIFwi44GCXCIgOyBBdmFpbGFibGUgXCLjgYRcIiA7IEF2YWlsYWJsZSBcIuOBhlwiIDtcbiAgQXZhaWxhYmxlIFwi44GIXCIgOyBBdmFpbGFibGUgXCLjgYpcIiA7IEF2YWlsYWJsZSBcIuOBi1wiIDsgQXZhaWxhYmxlIFwi44GNXCIgO1xuICBBdmFpbGFibGUgXCLjgY9cIiA7IEF2YWlsYWJsZSBcIuOBkVwiIDsgQXZhaWxhYmxlIFwi44GTXCIgOyBBdmFpbGFibGUgXCLjgZVcIiA7XG4gIEF2YWlsYWJsZSBcIuOBl1wiIDsgQXZhaWxhYmxlIFwi44GZXCIgOyBBdmFpbGFibGUgXCLjgZtcIiA7IEF2YWlsYWJsZSBcIuOBnVwiIDtcbiAgKCogMHgxLiAqKVxuICBBdmFpbGFibGUgXCLjgZ9cIiA7IEF2YWlsYWJsZSBcIuOBoVwiIDsgQXZhaWxhYmxlIFwi44GkXCIgOyBBdmFpbGFibGUgXCLjgaZcIiA7XG4gIEF2YWlsYWJsZSBcIuOBqFwiIDsgQXZhaWxhYmxlIFwi44GqXCIgOyBBdmFpbGFibGUgXCLjgatcIiA7IEF2YWlsYWJsZSBcIuOBrFwiIDtcbiAgQXZhaWxhYmxlIFwi44GtXCIgOyBBdmFpbGFibGUgXCLjga5cIiA7IEF2YWlsYWJsZSBcIuOBr1wiIDsgQXZhaWxhYmxlIFwi44GyXCIgO1xuICBBdmFpbGFibGUgXCLjgbVcIiA7IEF2YWlsYWJsZSBcIuOBuFwiIDsgQXZhaWxhYmxlIFwi44G7XCIgOyBBdmFpbGFibGUgXCLjgb5cIiA7XG4gICgqIDB4Mi4gKilcbiAgQXZhaWxhYmxlIFwi44G/XCIgOyBBdmFpbGFibGUgXCLjgoBcIiA7IEF2YWlsYWJsZSBcIuOCgVwiIDsgQXZhaWxhYmxlIFwi44KCXCIgO1xuICBBdmFpbGFibGUgXCLjgoRcIiA7IEF2YWlsYWJsZSBcIuOChlwiIDsgQXZhaWxhYmxlIFwi44KIXCIgOyBBdmFpbGFibGUgXCLjgolcIiA7XG4gIEF2YWlsYWJsZSBcIuOCilwiIDsgQXZhaWxhYmxlIFwi44KLXCIgOyBBdmFpbGFibGUgXCLjgoxcIiA7IEF2YWlsYWJsZSBcIuOCjVwiIDtcbiAgQXZhaWxhYmxlIFwi44KPXCIgOyBBdmFpbGFibGUgXCLjgpJcIiA7IEF2YWlsYWJsZSBcIuOCk1wiIDsgQXZhaWxhYmxlIFwi44GBXCIgO1xuICAoKiAweDMuICopXG4gIEF2YWlsYWJsZSBcIuOBg1wiIDsgQXZhaWxhYmxlIFwi44GFXCIgOyBBdmFpbGFibGUgXCLjgYdcIiA7IEF2YWlsYWJsZSBcIuOBiVwiIDtcbiAgQXZhaWxhYmxlIFwi44KDXCIgOyBBdmFpbGFibGUgXCLjgoVcIiA7IEF2YWlsYWJsZSBcIuOCh1wiIDsgQXZhaWxhYmxlIFwi44GMXCIgO1xuICBBdmFpbGFibGUgXCLjgY5cIiA7IEF2YWlsYWJsZSBcIuOBkFwiIDsgQXZhaWxhYmxlIFwi44GSXCIgOyBBdmFpbGFibGUgXCLjgZRcIiA7XG4gIEF2YWlsYWJsZSBcIuOBllwiIDsgQXZhaWxhYmxlIFwi44GYXCIgOyBBdmFpbGFibGUgXCLjgZpcIiA7IEF2YWlsYWJsZSBcIuOBnFwiIDtcbiAgKCogMHg0LiAqKVxuICBBdmFpbGFibGUgXCLjgZ5cIiA7IEF2YWlsYWJsZSBcIuOBoFwiIDsgQXZhaWxhYmxlIFwi44GiXCIgOyBBdmFpbGFibGUgXCLjgaVcIiA7XG4gIEF2YWlsYWJsZSBcIuOBp1wiIDsgQXZhaWxhYmxlIFwi44GpXCIgOyBBdmFpbGFibGUgXCLjgbBcIiA7IEF2YWlsYWJsZSBcIuOBs1wiIDtcbiAgQXZhaWxhYmxlIFwi44G2XCIgOyBBdmFpbGFibGUgXCLjgblcIiA7IEF2YWlsYWJsZSBcIuOBvFwiIDsgQXZhaWxhYmxlIFwi44GxXCIgO1xuICBBdmFpbGFibGUgXCLjgbRcIiA7IEF2YWlsYWJsZSBcIuOBt1wiIDsgQXZhaWxhYmxlIFwi44G6XCIgOyBBdmFpbGFibGUgXCLjgb1cIiA7XG4gICgqIDB4NS4gKilcbiAgQXZhaWxhYmxlIFwi44GjXCIgOyBBdmFpbGFibGUgXCLjgqJcIiA7IEF2YWlsYWJsZSBcIuOCpFwiIDsgQXZhaWxhYmxlIFwi44KmXCIgO1xuICBBdmFpbGFibGUgXCLjgqhcIiA7IEF2YWlsYWJsZSBcIuOCqlwiIDsgQXZhaWxhYmxlIFwi44KrXCIgOyBBdmFpbGFibGUgXCLjgq1cIiA7XG4gIEF2YWlsYWJsZSBcIuOCr1wiIDsgQXZhaWxhYmxlIFwi44KxXCIgOyBBdmFpbGFibGUgXCLjgrNcIiA7IEF2YWlsYWJsZSBcIuOCtVwiIDtcbiAgQXZhaWxhYmxlIFwi44K3XCIgOyBBdmFpbGFibGUgXCLjgrlcIiA7IEF2YWlsYWJsZSBcIuOCu1wiIDsgQXZhaWxhYmxlIFwi44K9XCIgO1xuICAoKiAweDYuICopXG4gIEF2YWlsYWJsZSBcIuOCv1wiIDsgQXZhaWxhYmxlIFwi44OBXCIgOyBBdmFpbGFibGUgXCLjg4RcIiA7IEF2YWlsYWJsZSBcIuODhlwiIDtcbiAgQXZhaWxhYmxlIFwi44OIXCIgOyBBdmFpbGFibGUgXCLjg4pcIiA7IEF2YWlsYWJsZSBcIuODi1wiIDsgQXZhaWxhYmxlIFwi44OMXCIgO1xuICBBdmFpbGFibGUgXCLjg41cIiA7IEF2YWlsYWJsZSBcIuODjlwiIDsgQXZhaWxhYmxlIFwi44OPXCIgOyBBdmFpbGFibGUgXCLjg5JcIiA7XG4gIEF2YWlsYWJsZSBcIuODlVwiIDsgQXZhaWxhYmxlIFwi44OYXCIgOyBBdmFpbGFibGUgXCLjg5tcIiA7IEF2YWlsYWJsZSBcIuODnlwiIDtcbiAgKCogMHg3LiAqKVxuICBBdmFpbGFibGUgXCLjg59cIiA7IEF2YWlsYWJsZSBcIuODoFwiIDsgQXZhaWxhYmxlIFwi44OhXCIgOyBBdmFpbGFibGUgXCLjg6JcIiA7XG4gIEF2YWlsYWJsZSBcIuODpFwiIDsgQXZhaWxhYmxlIFwi44OmXCIgOyBBdmFpbGFibGUgXCLjg6hcIiA7IEF2YWlsYWJsZSBcIuODqVwiIDtcbiAgQXZhaWxhYmxlIFwi44OqXCIgOyBBdmFpbGFibGUgXCLjg6tcIiA7IEF2YWlsYWJsZSBcIuODrFwiIDsgQXZhaWxhYmxlIFwi44OtXCIgO1xuICBBdmFpbGFibGUgXCLjg69cIiA7IEF2YWlsYWJsZSBcIuODslwiIDsgQXZhaWxhYmxlIFwi44OzXCIgOyBBdmFpbGFibGUgXCLjgqFcIiA7XG4gICgqIDB4OC4gKilcbiAgQXZhaWxhYmxlIFwi44KjXCIgOyBBdmFpbGFibGUgXCLjgqVcIiA7IEF2YWlsYWJsZSBcIuOCp1wiIDsgQXZhaWxhYmxlIFwi44KpXCIgO1xuICBBdmFpbGFibGUgXCLjg6NcIiA7IEF2YWlsYWJsZSBcIuODpVwiIDsgQXZhaWxhYmxlIFwi44OnXCIgOyBBdmFpbGFibGUgXCLjgqxcIiA7XG4gIEF2YWlsYWJsZSBcIuOCrlwiIDsgQXZhaWxhYmxlIFwi44KwXCIgOyBBdmFpbGFibGUgXCLjgrJcIiA7IEF2YWlsYWJsZSBcIuOCtFwiIDtcbiAgQXZhaWxhYmxlIFwi44K2XCIgOyBBdmFpbGFibGUgXCLjgrhcIiA7IEF2YWlsYWJsZSBcIuOCulwiIDsgQXZhaWxhYmxlIFwi44K8XCIgO1xuICAoKiAweDkuICopXG4gIEF2YWlsYWJsZSBcIuOCvlwiIDsgQXZhaWxhYmxlIFwi44OAXCIgOyBBdmFpbGFibGUgXCLjg4JcIiA7IEF2YWlsYWJsZSBcIuODhVwiIDtcbiAgQXZhaWxhYmxlIFwi44OHXCIgOyBBdmFpbGFibGUgXCLjg4lcIiA7IEF2YWlsYWJsZSBcIuODkFwiIDsgQXZhaWxhYmxlIFwi44OTXCIgO1xuICBBdmFpbGFibGUgXCLjg5ZcIiA7IEF2YWlsYWJsZSBcIuODmVwiIDsgQXZhaWxhYmxlIFwi44OcXCIgOyBBdmFpbGFibGUgXCLjg5FcIiA7XG4gIEF2YWlsYWJsZSBcIuODlFwiIDsgQXZhaWxhYmxlIFwi44OXXCIgOyBBdmFpbGFibGUgXCLjg5pcIiA7IEF2YWlsYWJsZSBcIuODnVwiIDtcbiAgKCogMHhBLiAqKVxuICBBdmFpbGFibGUgXCLjg4NcIiAgIDsgQXZhaWxhYmxlIFwiMFwiICAgOyBBdmFpbGFibGUgXCIxXCIgOyBBdmFpbGFibGUgXCIyXCIgICAgO1xuICBBdmFpbGFibGUgXCIzXCIgICAgOyBBdmFpbGFibGUgXCI0XCIgICA7IEF2YWlsYWJsZSBcIjVcIiA7IEF2YWlsYWJsZSBcIjZcIiAgICA7XG4gIEF2YWlsYWJsZSBcIjdcIiAgICA7IEF2YWlsYWJsZSBcIjhcIiAgIDsgQXZhaWxhYmxlIFwiOVwiIDsgQXZhaWxhYmxlIFwi77yBXCIgICA7XG4gIEF2YWlsYWJsZSBcIu+8n1wiICAgOyBBdmFpbGFibGUgXCLjgIJcIiAgOyBBdmFpbGFibGUgXCLjg7xcIjsgQXZhaWxhYmxlIFwi44O7XCIgICAgO1xuICAoKiAweEIuICopXG4gIEF2YWlsYWJsZSBcIuKApVwiICAgIDsgQXZhaWxhYmxlIFwi44COXCIgIDsgQXZhaWxhYmxlIFwi44CPXCI7IEF2YWlsYWJsZSBcIuOAjFwiICAgIDtcbiAgQXZhaWxhYmxlIFwi44CNXCIgICA7IEF2YWlsYWJsZSBcIuKZglwiICAgOyBBdmFpbGFibGUgXCLimYBcIiA7IFVuYXZhaWxhYmxlIFwi5YaGXCIgIDtcbiAgVW5hdmFpbGFibGUgXCIuXCIgIDsgVW5hdmFpbGFibGUgXCLDl1wiIDsgQXZhaWxhYmxlIFwiL1wiIDsgQXZhaWxhYmxlIFwiQVwiICAgICA7XG4gIEF2YWlsYWJsZSBcIkJcIiAgICA7IEF2YWlsYWJsZSBcIkNcIiAgIDsgQXZhaWxhYmxlIFwiRFwiIDsgQXZhaWxhYmxlIFwiRVwiICAgICA7XG4gICgqIDB4Qy4gKilcbiAgQXZhaWxhYmxlIFwiRlwiICAgIDsgQXZhaWxhYmxlIFwiR1wiICAgOyBBdmFpbGFibGUgXCJIXCIgOyBBdmFpbGFibGUgXCJJXCIgICAgIDtcbiAgQXZhaWxhYmxlIFwiSlwiICAgIDsgQXZhaWxhYmxlIFwiS1wiICAgOyBBdmFpbGFibGUgXCJMXCIgOyBBdmFpbGFibGUgXCJNXCIgICAgIDtcbiAgQXZhaWxhYmxlIFwiTlwiICAgIDsgQXZhaWxhYmxlIFwiT1wiICAgOyBBdmFpbGFibGUgXCJQXCIgOyBBdmFpbGFibGUgXCJRXCIgICAgIDtcbiAgQXZhaWxhYmxlIFwiUlwiICAgIDsgQXZhaWxhYmxlIFwiU1wiICAgOyBBdmFpbGFibGUgXCJUXCIgOyBBdmFpbGFibGUgXCJVXCIgICAgIDtcbiAgKCogMHhELiAqKVxuICBBdmFpbGFibGUgXCJWXCIgICAgOyBBdmFpbGFibGUgXCJXXCIgICA7IEF2YWlsYWJsZSBcIlhcIiA7IEF2YWlsYWJsZSBcIllcIiAgICAgO1xuICBBdmFpbGFibGUgXCJaXCIgICAgOyBBdmFpbGFibGUgXCJhXCIgICA7IEF2YWlsYWJsZSBcImJcIiA7IEF2YWlsYWJsZSBcImNcIiAgICAgO1xuICBBdmFpbGFibGUgXCJkXCIgICAgOyBBdmFpbGFibGUgXCJlXCIgICA7IEF2YWlsYWJsZSBcImZcIiA7IEF2YWlsYWJsZSBcImdcIiAgICAgO1xuICBBdmFpbGFibGUgXCJoXCIgICAgOyBBdmFpbGFibGUgXCJpXCIgICA7IEF2YWlsYWJsZSBcImpcIiA7IEF2YWlsYWJsZSBcImtcIiAgICAgO1xuICAoKiAweEUuICopXG4gIEF2YWlsYWJsZSBcImxcIiAgICA7IEF2YWlsYWJsZSBcIm1cIiAgIDsgQXZhaWxhYmxlIFwiblwiIDsgQXZhaWxhYmxlIFwib1wiICAgICA7XG4gIEF2YWlsYWJsZSBcInBcIiAgICA7IEF2YWlsYWJsZSBcInFcIiAgIDsgQXZhaWxhYmxlIFwiclwiIDsgQXZhaWxhYmxlIFwic1wiICAgICA7XG4gIEF2YWlsYWJsZSBcInRcIiAgICA7IEF2YWlsYWJsZSBcInVcIiAgIDsgQXZhaWxhYmxlIFwidlwiIDsgQXZhaWxhYmxlIFwid1wiICAgICA7XG4gIEF2YWlsYWJsZSBcInhcIiAgICA7IEF2YWlsYWJsZSBcInlcIiAgIDsgQXZhaWxhYmxlIFwielwiIDsgVW5hdmFpbGFibGUgXCLilrZcIiAgO1xuICAoKiAweEYuICopXG4gIFVuYXZhaWxhYmxlIFwiOlwiICAgOyBVbmF2YWlsYWJsZSBcIsOEXCIgICA7IFVuYXZhaWxhYmxlIFwiw5ZcIiAgIDsgVW5hdmFpbGFibGUgXCLDnFwiICAgO1xuICBVbmF2YWlsYWJsZSBcIsOkXCIgICA7IFVuYXZhaWxhYmxlIFwiw7ZcIiAgIDsgVW5hdmFpbGFibGUgXCLDvFwiICAgOyBVbnVzZWQgICAgICAgICAgICA7XG4gIFVudXNlZCAgICAgICAgICAgIDsgVW51c2VkICAgICAgICAgICAgOyBVbnJlYWRhYmxlIFwiMHhGQVwiIDsgVW5yZWFkYWJsZSBcIjB4RkJcIiA7XG4gIFVucmVhZGFibGUgXCIweEZDXCIgOyBVbnJlYWRhYmxlIFwiMHhGRFwiIDsgVW5yZWFkYWJsZSBcIjB4RkVcIiA7IFVucmVhZGFibGUgXCIweEZGXCIgO1xuICB8XVxuXG5sZXQgY2hhcnNldCAoKSA9XG4gIG1hdGNoICFTZXR0aW5ncy5sYW5nIHdpdGhcbiAgfCBFTkcgLT4gY2hhcnNldF9lbmdcbiAgfCBGUkEgLT4gY2hhcnNldF9mcmFcbiAgfCBJVEEgLT4gY2hhcnNldF9pdGFcbiAgfCBTUEEgLT4gY2hhcnNldF9zcGFcbiAgfCBHRVIgLT4gY2hhcnNldF9nZXJcbiAgfCBKQVAgLT4gY2hhcnNldF9qYXBcblxubGV0IGlzX2NvZGVfYXZhaWxhYmxlIGNvZGUgPVxuICBtYXRjaCAoY2hhcnNldCAoKSkuKGNvZGUpIHdpdGhcbiAgfCBBdmFpbGFibGUgXyAtPiB0cnVlXG4gIHwgVW5hdmFpbGFibGUgXyB8IFVucmVhZGFibGUgXyB8IFVudXNlZCAtPiBmYWxzZVxuXG5sZXQgaXNfY29kZV9yZWFkYWJsZSBjb2RlID1cbiAgbWF0Y2ggKGNoYXJzZXQgKCkpLihjb2RlKSB3aXRoXG4gIHwgQXZhaWxhYmxlIF8gfCBVbmF2YWlsYWJsZSBfIC0+IHRydWVcbiAgfCBVbnJlYWRhYmxlIF8gfCBVbnVzZWQgLT4gZmFsc2VcblxubGV0IGlzX2NvZGVfdXNlZCBjb2RlID1cbiAgbWF0Y2ggKGNoYXJzZXQgKCkpLihjb2RlKSB3aXRoXG4gIHwgQXZhaWxhYmxlIF8gfCBVbmF2YWlsYWJsZSBfIHwgVW5yZWFkYWJsZSBfIC0+IHRydWVcbiAgfCBVbnVzZWQgLT4gZmFsc2VcblxubGV0IHNwYWNpbmdfY2hhciA9IFwiX1wiXG5sZXQgaW52YWxpZF9jaGFyID0gXCLinJZcIlxuXG5sZXQgY2hhcl9hdCBjb2RlID1cbiAgbWF0Y2ggKGNoYXJzZXQgKCkpLihjb2RlKSB3aXRoXG4gIHwgQXZhaWxhYmxlIHN0ciB8IFVuYXZhaWxhYmxlIHN0ciB8IFVucmVhZGFibGUgc3RyIC0+IHN0clxuICB8IFVudXNlZCAtPiBpbnZhbGlkX2NoYXJcblxubGV0IHJlYWRhYmxlX2NoYXJfYXQgY29kZSA9XG4gIG1hdGNoIChjaGFyc2V0ICgpKS4oY29kZSkgd2l0aFxuICB8IEF2YWlsYWJsZSBzdHIgfCBVbmF2YWlsYWJsZSBzdHIgLT4gc3RyXG4gIHwgVW5yZWFkYWJsZSBfIHwgVW51c2VkIC0+IGludmFsaWRfY2hhclxuXG5sZXQgd3JpdGFibGVfY2hhcl9hdCBjb2RlID1cbiAgbWF0Y2ggKGNoYXJzZXQgKCkpLihjb2RlKSB3aXRoXG4gIHwgQXZhaWxhYmxlIHN0ciAtPiBzdHJcbiAgfCBVbmF2YWlsYWJsZSBfIHwgVW5yZWFkYWJsZSBfIHwgVW51c2VkIC0+IGludmFsaWRfY2hhclxuXG5sZXQgYWxsX3dyaXRhYmxlX2NoYXJzID1cbiAgbGV0IHJlYyBhdXggYWNjIGkgPVxuICAgIGlmIGkgPCAwIHRoZW4gYWNjXG4gICAgZWxzZVxuICAgICAgbWF0Y2ggKGNoYXJzZXQgKCkpLihpKSB3aXRoXG4gICAgICB8IEF2YWlsYWJsZSBzdHIgLT4gYXV4IChzdHI6OmFjYykgKGktMSlcbiAgICAgIHwgVW5hdmFpbGFibGUgXyB8IFVucmVhZGFibGUgXyB8IFVudXNlZCAtPiBhdXggYWNjIChpLTEpXG4gIGluXG4gIGF1eCBbXSAweEZGXG5cbmxldCBlbmNvZGVfd3JpdGFibGVfY2hhciBzdHIgPVxuICBsZXQgcmVjIGF1eCBpID1cbiAgICBpZiBpIDwgMCB0aGVuIHJhaXNlIE5vdF9mb3VuZFxuICAgIGVsc2VcbiAgICAgIG1hdGNoIChjaGFyc2V0ICgpKS4oaSkgd2l0aFxuICAgICAgfCBBdmFpbGFibGUgc3RyJyB3aGVuIFN0cmluZy5lcXVhbCBzdHIgc3RyJyAtPiBpXG4gICAgICB8IEF2YWlsYWJsZSBfIHwgVW5hdmFpbGFibGUgXyB8IFVucmVhZGFibGUgXyB8IFVudXNlZCAtPiBhdXggKGktMSlcbiAgaW5cbiAgYXV4IDB4RkZcbiIsIm9wZW4gQXJtXG5cbnR5cGUgdW5wcm9jZXNzZWRfaW50MzIgPSBDb25zdEludDMyIG9mIGludDMyIHwgTWV0YUV4cHIgb2YgUHJlcHJvY2Vzcy5tZXRhX2V4cHJcblxudHlwZSBvZmZzZXQgPVxuICB8IE9JbW1lZGlhdGUgb2YgQXJtLnNpZ24gKiB1bnByb2Nlc3NlZF9pbnQzMlxuICB8IE9SZWdpc3RlciBvZiBBcm0uc2lnbiAqIHN0cmluZ1xuXG50eXBlIGFyZ3MgPVxuICB8IFJlZ2lzdGVyIG9mIHN0cmluZ1xuICB8IEltbWVkaWF0ZSBvZiB1bnByb2Nlc3NlZF9pbnQzMlxuICB8IE9mZnNldCBvZiBzdHJpbmcgKCogcmVnaXN0ZXIgKikgKiBvZmZzZXQgKiBBcm0uYWRkcmVzc2luZ190eXBlXG5cbnR5cGUgY29tbWFuZCA9XG4gIHwgQVNNIG9mIExleGluZy5wb3NpdGlvbiAqIHN0cmluZyAqIGFyZ3MgbGlzdCAqIE9wdGltaXplci50d2Vha2luZ19zZXR0aW5nc1xuICB8IEJJTiBvZiBMZXhpbmcucG9zaXRpb24gKiB1bnByb2Nlc3NlZF9pbnQzMlxuXG50eXBlIGFzdCA9IGNvbW1hbmQgbGlzdFxuXG5leGNlcHRpb24gQ29tbWFuZEVycm9yIG9mIExleGluZy5wb3NpdGlvblxuXG5leGNlcHRpb24gU3RydWN0RXJyb3JcblxubGV0IHByZXByb2Nlc3MgZW52IHVpID1cbiAgbWF0Y2ggdWkgd2l0aFxuICB8IENvbnN0SW50MzIgaSAtPiBpXG4gIHwgTWV0YUV4cHIgZSAtPiBQcmVwcm9jZXNzLmV2YWxfbWV0YV9leHByIGVudiBlXG5cbmxldCByZWNvZ25pemVfY29uZGl0aW9uIHN0ciBpID1cbiAgbGV0IG4gPSBTdHJpbmcubGVuZ3RoIHN0ciBpblxuICBsZXQgc3RyID0gU3RyaW5nLnN1YiBzdHIgaSAobWluIDIgKG4taSkpIGluXG4gIG1hdGNoIHN0ciB3aXRoXG4gIHwgXCJFUVwiIC0+IChTb21lIEVRLCBpKzIpXG4gIHwgXCJORVwiIC0+IChTb21lIE5FLCBpKzIpXG4gIHwgXCJDU1wiIC0+IChTb21lIENTLCBpKzIpXG4gIHwgXCJIU1wiIC0+IChTb21lIEhTLCBpKzIpXG4gIHwgXCJDQ1wiIC0+IChTb21lIENDLCBpKzIpXG4gIHwgXCJMT1wiIC0+IChTb21lIExPLCBpKzIpXG4gIHwgXCJNSVwiIC0+IChTb21lIE1JLCBpKzIpXG4gIHwgXCJQTFwiIC0+IChTb21lIFBMLCBpKzIpXG4gIHwgXCJWU1wiIC0+IChTb21lIFZTLCBpKzIpXG4gIHwgXCJWQ1wiIC0+IChTb21lIFZDLCBpKzIpXG4gIHwgXCJISVwiIC0+IChTb21lIEhJLCBpKzIpXG4gIHwgXCJMU1wiIC0+IChTb21lIExTLCBpKzIpXG4gIHwgXCJHRVwiIC0+IChTb21lIEdFLCBpKzIpXG4gIHwgXCJMVFwiIC0+IChTb21lIExULCBpKzIpXG4gIHwgXCJHVFwiIC0+IChTb21lIEdULCBpKzIpXG4gIHwgXCJMRVwiIC0+IChTb21lIExFLCBpKzIpXG4gIHwgXCJBTFwiIC0+IChTb21lIEFMLCBpKzIpXG4gIHwgXyAtPiAoTm9uZSwgaSlcblxubGV0IHJlY29nbml6ZV9sZHJfc3RyX3R5cGUgc3RyIGkgPVxuICBsZXQgbiA9IFN0cmluZy5sZW5ndGggc3RyIGluXG4gIGxldCBzdHIgPSBTdHJpbmcuc3ViIHN0ciBpIChtaW4gMiAobi1pKSkgaW5cbiAgbWF0Y2ggc3RyIHdpdGhcbiAgfCBcIlNCXCIgLT4gKFNvbWUgU0IsIGkrMilcbiAgfCBcIlNIXCIgLT4gKFNvbWUgU0gsIGkrMilcbiAgfCBcIkJUXCIgLT4gKFNvbWUgQlQsIGkrMilcbiAgfCBfIC0+XG4gIGJlZ2luXG4gICAgbGV0IHN0ciA9IFN0cmluZy5zdWIgc3RyIDAgKG1pbiAxIChuLWkpKSBpblxuICAgIG1hdGNoIHN0ciB3aXRoXG4gICAgfCBcIkJcIiAtPiAoU29tZSBCLCBpKzEpXG4gICAgfCBcIkhcIiAtPiAoU29tZSBILCBpKzEpXG4gICAgfCBcIldcIiAtPiAoU29tZSBXLCBpKzEpXG4gICAgfCBcIlRcIiAtPiAoU29tZSBULCBpKzEpXG4gICAgfCBfIC0+IChOb25lLCBpKVxuICBlbmRcblxubGV0IHJlY29nbml6ZV8xIHN0ciBpID1cbiAgbGV0IG4gPSBTdHJpbmcubGVuZ3RoIHN0ciBpblxuICBsZXQgc3RyID0gU3RyaW5nLnN1YiBzdHIgaSAobWluIDEgKG4taSkpIGluXG4gIG1hdGNoIHN0ciB3aXRoXG4gIHwgXCJTXCIgLT4gKFNvbWUgXCJTXCIsIGkrMSlcbiAgfCBcIkxcIiAtPiAoU29tZSBcIkxcIiwgaSsxKVxuICB8IFwiWFwiIC0+IChTb21lIFwiWFwiLCBpKzEpXG4gIHwgXyAtPiAoTm9uZSwgaSlcblxubGV0IGNvbWJpbmVfb3B0IG8xIG8yID1cbiAgbWF0Y2ggbzEsIG8yIHdpdGhcbiAgfCBOb25lLCBOb25lIC0+IE5vbmVcbiAgfCBTb21lIHMsIE5vbmUgfCBOb25lLCBTb21lIHMgLT4gU29tZSBzXG4gIHwgU29tZSBfLCBTb21lIF8gLT4gcmFpc2UgU3RydWN0RXJyb3JcblxubGV0IGNvbWJpbmVfYm9vbCBiMSBiMiA9XG4gIG1hdGNoIGIxLCBiMiB3aXRoXG4gIHwgZmFsc2UsIGZhbHNlIC0+IGZhbHNlXG4gIHwgdHJ1ZSwgZmFsc2UgfCBmYWxzZSwgdHJ1ZSAtPiB0cnVlXG4gIHwgdHJ1ZSwgdHJ1ZSAtPiByYWlzZSBTdHJ1Y3RFcnJvclxuXG5sZXQgY29tYmluZV9tb2RpZmllcnMgKGNvbmQsIGxzdCwgcywgbCwgeCkgKGNvbmQnLCBsc3QnLCBzJywgbCcsIHgnKSA9XG4gIGxldCBjb25kID0gY29tYmluZV9vcHQgY29uZCBjb25kJyBpblxuICBsZXQgbHN0ID0gY29tYmluZV9vcHQgbHN0IGxzdCcgaW5cbiAgbGV0IHMgPSBjb21iaW5lX2Jvb2wgcyBzJyBpblxuICBsZXQgbCA9IGNvbWJpbmVfYm9vbCBsIGwnIGluXG4gIGxldCB4ID0gY29tYmluZV9ib29sIHggeCcgaW5cbiAgKGNvbmQsIGxzdCwgcywgbCwgeClcblxubGV0IHJlY29nbml6ZV9tb2RpZmllcnMgc3RyIGkgPVxuICBsZXQgbiA9IFN0cmluZy5sZW5ndGggc3RyIGluXG4gIGxldCByZWMgYXV4IG1vZHMgaSA9XG4gICAgaWYgaSA+PSBuIHRoZW4gbW9kc1xuICAgIGVsc2VcbiAgICAgIGxldCAobm1vZHMsIGkpID1cbiAgICAgICAgbWF0Y2ggcmVjb2duaXplX2NvbmRpdGlvbiBzdHIgaSB3aXRoXG4gICAgICAgIHwgKFNvbWUgYywgaSkgLT4gKChTb21lIGMsIE5vbmUsIGZhbHNlLCBmYWxzZSwgZmFsc2UpLCBpKVxuICAgICAgICB8IChOb25lLCBpKSAtPlxuICAgICAgICAgIG1hdGNoIHJlY29nbml6ZV9sZHJfc3RyX3R5cGUgc3RyIGkgd2l0aFxuICAgICAgICAgIHwgKFNvbWUgbHN0LCBpKSAtPiAoKE5vbmUsIFNvbWUgbHN0LCBmYWxzZSwgZmFsc2UsIGZhbHNlKSwgaSlcbiAgICAgICAgICB8IChOb25lLCBpKSAtPlxuICAgICAgICAgICAgbWF0Y2ggcmVjb2duaXplXzEgc3RyIGkgd2l0aFxuICAgICAgICAgICAgfCAoU29tZSBcIlNcIiwgaSkgLT4gKChOb25lLCBOb25lLCB0cnVlLCBmYWxzZSwgZmFsc2UpLCBpKVxuICAgICAgICAgICAgfCAoU29tZSBcIkxcIiwgaSkgLT4gKChOb25lLCBOb25lLCBmYWxzZSwgdHJ1ZSwgZmFsc2UpLCBpKVxuICAgICAgICAgICAgfCAoU29tZSBcIlhcIiwgaSkgLT4gKChOb25lLCBOb25lLCBmYWxzZSwgZmFsc2UsIHRydWUpLCBpKVxuICAgICAgICAgICAgfCBfIC0+IHJhaXNlIFN0cnVjdEVycm9yXG4gICAgICBpblxuICAgICAgbGV0IG1vZHMgPSBjb21iaW5lX21vZGlmaWVycyBtb2RzIG5tb2RzIGluXG4gICAgICBhdXggbW9kcyBpXG4gIGluXG4gIGF1eCAoTm9uZSwgTm9uZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSkgaVxuXG5sZXQgcmVnaXN0ZXJfb2Zfc3RyIHN0ciA9XG4gIGxldCBzdHIgPSBTdHJpbmcubG93ZXJjYXNlX2FzY2lpIHN0ciBpblxuICBtYXRjaCBzdHIgd2l0aFxuICB8IFwicjBcIiAtPiAwICAgfCBcInIxXCIgLT4gMSAgIHwgXCJyMlwiIC0+IDIgICB8IFwicjNcIiAtPiAzICAgfCBcInI0XCIgLT4gNFxuICB8IFwicjVcIiAtPiA1ICAgfCBcInI2XCIgLT4gNiAgIHwgXCJyN1wiIC0+IDcgICB8IFwicjhcIiAtPiA4ICAgfCBcInI5XCIgLT4gOSBcbiAgfCBcInIxMFwiIC0+IDEwIHwgXCJyMTFcIiAtPiAxMSB8IFwicjEyXCIgLT4gMTIgfCBcInIxM1wiIC0+IDEzIHwgXCJyMTRcIiAtPiAxNCBcbiAgfCBcInIxNVwiIC0+IDE1IHwgXCJzYlwiIC0+IHNiICB8IFwic2xcIiAtPiBzbCAgfCBcImZwXCIgLT4gZnAgIHwgXCJpcFwiIC0+IGlwXG4gIHwgXCJzcFwiIC0+IHNwICB8IFwibHJcIiAtPiBsciAgfCBcInBjXCIgLT4gcGMgIHwgXyAtPiByYWlzZSBTdHJ1Y3RFcnJvclxuXG5sZXQgZ2V0X3JlZ2lzdGVyIGFyZyA9XG4gIG1hdGNoIGFyZyB3aXRoXG4gIHwgUmVnaXN0ZXIgc3RyIC0+IHJlZ2lzdGVyX29mX3N0ciBzdHJcbiAgfCBfIC0+IHJhaXNlIFN0cnVjdEVycm9yXG5cbmxldCBnZXRfcmQgYXJncyA9IGdldF9yZWdpc3RlciAoTGlzdC5oZCBhcmdzKVxuXG5sZXQgZ2V0X3JuIGFyZ3MgPVxuICBsZXQgbiA9IExpc3QubGVuZ3RoIGFyZ3MgaW5cbiAgZ2V0X3JlZ2lzdGVyIChMaXN0Lm50aCBhcmdzIChuLTIpKVxuXG5sZXQgZ2V0X3JtID0gZ2V0X3JkXG5cbmxldCBnZXRfaW1tZWRpYXRlIGVudiBhcmcgPVxuICBtYXRjaCBhcmcgd2l0aFxuICB8IEltbWVkaWF0ZSBpIC0+IHByZXByb2Nlc3MgZW52IGlcbiAgfCBfIC0+IHJhaXNlIFN0cnVjdEVycm9yXG5cbmxldCBnZXRfb3BlcmFuZCBlbnYgYXJnID1cbiAgbWF0Y2ggYXJnIHdpdGhcbiAgfCBJbW1lZGlhdGUgaSAtPiBBcm0uSW1tZWRpYXRlIChwcmVwcm9jZXNzIGVudiBpKVxuICB8IFJlZ2lzdGVyIHN0ciAtPiBBcm0uUmVnaXN0ZXIgKHJlZ2lzdGVyX29mX3N0ciBzdHIpXG4gIHwgXyAtPiByYWlzZSBTdHJ1Y3RFcnJvclxuXG5sZXQgZ2V0X29wMiBlbnYgYXJncyA9XG4gIGxldCBuID0gTGlzdC5sZW5ndGggYXJncyBpblxuICBnZXRfb3BlcmFuZCBlbnYgKExpc3QubnRoIGFyZ3MgKG4tMSkpXG5cbmxldCBnZXRfcnMgPSBnZXRfb3AyXG5cbmxldCBnZXRfcm8gZW52IGFyZ3MgPVxuICBsZXQgbiA9IExpc3QubGVuZ3RoIGFyZ3MgaW5cbiAgbWF0Y2ggTGlzdC5udGggYXJncyAobi0xKSB3aXRoXG4gIHwgT2Zmc2V0IChzdHIsIG9mZnNldCwgYWRkcl90eXApIC0+IGJlZ2luXG4gICAgbGV0IHIgPSByZWdpc3Rlcl9vZl9zdHIgc3RyIGluXG4gICAgbGV0IHJvID0gbWF0Y2ggb2Zmc2V0IHdpdGhcbiAgICB8IE9JbW1lZGlhdGUgKHNpZ24sIGkpIC0+IEFybS5PSW1tZWRpYXRlIChyLCBzaWduLCBwcmVwcm9jZXNzIGVudiBpKVxuICAgIHwgT1JlZ2lzdGVyIChzaWduLCBzdHIpIC0+IEFybS5PUmVnaXN0ZXIgKHIsIHNpZ24sIHJlZ2lzdGVyX29mX3N0ciBzdHIpXG4gICAgaW5cbiAgICAocm8sIGFkZHJfdHlwKVxuICAgIGVuZFxuICB8IF8gLT4gcmFpc2UgU3RydWN0RXJyb3JcblxubGV0IGdldF90YXJnZXQgZW52IGFyZ3MgPVxuICBnZXRfaW1tZWRpYXRlIGVudiAoTGlzdC5oZCBhcmdzKVxuXG5sZXQgYXNtX2NtZDNfdG9fYXJtIGVudiBjbWQgYXJncyA9XG4gIGlmIFN0cmluZy5sZW5ndGggY21kIDwgMyB0aGVuIHJhaXNlIFN0cnVjdEVycm9yIDtcbiAgbGV0IGNtZCA9IFN0cmluZy51cHBlcmNhc2VfYXNjaWkgY21kIGluXG4gIGxldCAoY29uZCwgdHlwLCBzLCBfLCBfKSA9IHJlY29nbml6ZV9tb2RpZmllcnMgY21kIDMgaW5cbiAgbGV0IGNvbmQgPSBtYXRjaCBjb25kIHdpdGggTm9uZSAtPiBBTCB8IFNvbWUgYyAtPiBjIGluXG4gIGxldCB0eXAgPSBtYXRjaCB0eXAgd2l0aCBOb25lIC0+IFcgfCBTb21lIHR5cCAtPiB0eXAgaW5cblxuICB0cnkgbWF0Y2ggU3RyaW5nLnN1YiBjbWQgMCAzIHdpdGhcbiAgfCBcIkxEUlwiIC0+IE1lbSB7IGluc3RyPUxEUiA7IHR5cCA7IGNvbmQgOyByZD1nZXRfcmQgYXJncyA7IHJvPWdldF9ybyBlbnYgYXJncyB9XG4gIHwgXCJTVFJcIiAtPiBNZW0geyBpbnN0cj1TVFIgOyB0eXAgOyBjb25kIDsgcmQ9Z2V0X3JkIGFyZ3MgOyBybz1nZXRfcm8gZW52IGFyZ3MgfVxuICB8IFwiTU9WXCIgLT4gTW92IHsgaW5zdHI9TU9WIDsgcyA7IGNvbmQgOyByZD1nZXRfcmQgYXJncyA7IHJzPWdldF9ycyBlbnYgYXJncyB9XG4gIHwgXCJNVk5cIiAtPiBNb3YgeyBpbnN0cj1NVk47IHMgOyBjb25kIDsgcmQ9Z2V0X3JkIGFyZ3MgOyBycz1nZXRfcnMgZW52IGFyZ3MgfVxuICB8IFwiQURDXCIgLT4gRGF0YVByb2MgeyBpbnN0cj1BREMgOyBzIDsgY29uZCA7IHJkPWdldF9yZCBhcmdzIDsgcm49Z2V0X3JuIGFyZ3MgOyBvcDI9Z2V0X29wMiBlbnYgYXJncyB9XG4gIHwgXCJTQkNcIiAtPiBEYXRhUHJvYyB7IGluc3RyPVNCQyA7IHMgOyBjb25kIDsgcmQ9Z2V0X3JkIGFyZ3MgOyBybj1nZXRfcm4gYXJncyA7IG9wMj1nZXRfb3AyIGVudiBhcmdzIH1cbiAgfCBcIkJJQ1wiIC0+IERhdGFQcm9jIHsgaW5zdHI9QklDIDsgcyA7IGNvbmQgOyByZD1nZXRfcmQgYXJncyA7IHJuPWdldF9ybiBhcmdzIDsgb3AyPWdldF9vcDIgZW52IGFyZ3MgfVxuICB8IFwiQU5EXCIgLT4gRGF0YVByb2MgeyBpbnN0cj1BTkQgOyBzIDsgY29uZCA7IHJkPWdldF9yZCBhcmdzIDsgcm49Z2V0X3JuIGFyZ3MgOyBvcDI9Z2V0X29wMiBlbnYgYXJncyB9XG4gIHwgXCJBRERcIiAtPiBEYXRhUHJvYyB7IGluc3RyPUFERCA7IHMgOyBjb25kIDsgcmQ9Z2V0X3JkIGFyZ3MgOyBybj1nZXRfcm4gYXJncyA7IG9wMj1nZXRfb3AyIGVudiBhcmdzIH1cbiAgfCBcIlNVQlwiIC0+IERhdGFQcm9jIHsgaW5zdHI9U1VCIDsgcyA7IGNvbmQgOyByZD1nZXRfcmQgYXJncyA7IHJuPWdldF9ybiBhcmdzIDsgb3AyPWdldF9vcDIgZW52IGFyZ3MgfVxuICB8IFwiT1JSXCIgLT4gRGF0YVByb2MgeyBpbnN0cj1PUlIgOyBzIDsgY29uZCA7IHJkPWdldF9yZCBhcmdzIDsgcm49Z2V0X3JuIGFyZ3MgOyBvcDI9Z2V0X29wMiBlbnYgYXJncyB9XG4gIHwgXCJFT1JcIiAtPiBEYXRhUHJvYyB7IGluc3RyPUVPUiA7IHMgOyBjb25kIDsgcmQ9Z2V0X3JkIGFyZ3MgOyBybj1nZXRfcm4gYXJncyA7IG9wMj1nZXRfb3AyIGVudiBhcmdzIH1cbiAgfCBfIC0+IHJhaXNlIFN0cnVjdEVycm9yXG4gIHdpdGggRmFpbHVyZSBfIHwgSW52YWxpZF9hcmd1bWVudCBfIC0+IHJhaXNlIFN0cnVjdEVycm9yXG5cbmxldCBhc21fY21kMV90b19hcm0gZW52IGNtZCBhcmdzID1cbiAgaWYgU3RyaW5nLmxlbmd0aCBjbWQgPCAxIHRoZW4gcmFpc2UgU3RydWN0RXJyb3IgO1xuICBsZXQgY21kID0gU3RyaW5nLnVwcGVyY2FzZV9hc2NpaSBjbWQgaW5cbiAgbGV0IChjb25kLCBfLCBfLCBsLCB4KSA9IHJlY29nbml6ZV9tb2RpZmllcnMgY21kIDEgaW5cbiAgbGV0IGNvbmQgPSBtYXRjaCBjb25kIHdpdGggTm9uZSAtPiBBTCB8IFNvbWUgYyAtPiBjIGluXG5cbiAgdHJ5IG1hdGNoIFN0cmluZy5zdWIgY21kIDAgMSB3aXRoXG4gIHwgXCJCXCIgd2hlbiB4IC0+IEJyYW5jaFggeyBsIDsgY29uZCA7IHJtPWdldF9ybSBhcmdzIH1cbiAgfCBcIkJcIiAtPiBCcmFuY2ggeyBsIDsgY29uZCA7IHRhcmdldD1nZXRfdGFyZ2V0IGVudiBhcmdzIH1cbiAgfCBfIC0+IHJhaXNlIFN0cnVjdEVycm9yXG4gIHdpdGggRmFpbHVyZSBfIHwgSW52YWxpZF9hcmd1bWVudCBfIC0+IHJhaXNlIFN0cnVjdEVycm9yXG5cbmxldCBhc21fY21kX3RvX2FybSBlbnYgY21kIGFyZ3MgPVxuICB0cnkgKGFzbV9jbWQzX3RvX2FybSBlbnYgY21kIGFyZ3MpXG4gIHdpdGggU3RydWN0RXJyb3IgLT4gKGFzbV9jbWQxX3RvX2FybSBlbnYgY21kIGFyZ3MpXG5cbmxldCBjbWRfdG9fYXJtIGVudiBjbWQgPVxuICBtYXRjaCBjbWQgd2l0aFxuICB8IEFTTSAocG9zLCBjbWQsIGFyZ3MsIG9wdGltaXplKSAtPlxuICAgIGJlZ2luIHRyeSAoYXNtX2NtZF90b19hcm0gZW52IGNtZCBhcmdzLCBvcHRpbWl6ZSlcbiAgICB3aXRoIFN0cnVjdEVycm9yIC0+IHJhaXNlIChDb21tYW5kRXJyb3IgcG9zKSBlbmRcbiAgfCBCSU4gKF8sIGkpIC0+IChDdXN0b20gKHByZXByb2Nlc3MgZW52IGkpLCBPcHRpbWl6ZXIuTm9Ud2Vha2luZylcblxubGV0IHRvX2FybSBlbnYgYXN0ID0gTGlzdC5tYXAgKGNtZF90b19hcm0gZW52KSBhc3RcbiIsIiMgMSBcIklPL2xleGVyLm1sbFwiXG4gXG5vcGVuIExleGluZ1xub3BlbiBQYXJzZXJcblxuZXhjZXB0aW9uIFN5bnRheEVycm9yIG9mIHN0cmluZ1xuXG5sZXQgbmV4dF9saW5lIGxleGJ1ZiA9XG4gIGxldCBwb3MgPSBsZXhidWYubGV4X2N1cnJfcCBpblxuICBsZXhidWYubGV4X2N1cnJfcCA8LVxuICAgIHsgcG9zIHdpdGggcG9zX2JvbCA9IGxleGJ1Zi5sZXhfY3Vycl9wb3M7XG4gICAgICAgICAgICAgICBwb3NfbG51bSA9IHBvcy5wb3NfbG51bSArIDFcbiAgICB9XG5cbmxldCBlb2ZfcmVhY2hlZCBsZXhidWYgPVxuICBsZXhidWYubGV4X2VvZl9yZWFjaGVkIDwtIHRydWVcblxuIyAxOSBcIklPL2xleGVyLm1sXCJcbmxldCBfX29jYW1sX2xleF90YWJsZXMgPSB7XG4gIExleGluZy5sZXhfYmFzZSA9XG4gICBcIlxcMDAwXFwwMDBcXDIxNVxcMjU1XFwyMTZcXDI1NVxcMjE3XFwyNTVcXDIxOFxcMjU1XFwyMjNcXDI1NVxcMjI0XFwyNTVcXDIyNVxcMjU1XFxcbiAgICBcXDIyNlxcMjU1XFwyMjdcXDI1NVxcMjI4XFwyNTVcXDIyOVxcMjU1XFwyMzFcXDI1NVxcMjMyXFwyNTVcXDIzM1xcMjU1XFwyMzRcXDI1NVxcXG4gICAgXFwyMzVcXDI1NVxcMjM2XFwyNTVcXDIzOFxcMjU1XFwwNzlcXDAwMFxcMTU0XFwwMDBcXDE2NFxcMDAwXFwyNDFcXDI1NVxcMDAxXFwwMDBcXFxuICAgIFxcMDAyXFwwMDBcXDAwN1xcMDAwXFwwNDlcXDAwMFxcMjQ0XFwyNTVcXDAwOVxcMDAwXFwwOTlcXDAwMFxcMDE0XFwwMDBcXDA3OFxcMDAwXFxcbiAgICBcXDA3OFxcMDAwXFwwODFcXDAwMFxcMjM3XFwwMDBcXDA1NlxcMDAxXFwxMzFcXDAwMVxcMDc4XFwwMDBcXDA4MlxcMDAwXFwxMDlcXDAwMFxcXG4gICAgXFwxMTBcXDAwMFxcMTExXFwwMDBcXDExMlxcMDAwXFwyNTRcXDI1NVxcMjA2XFwwMDFcXDAyNVxcMDAyXFwxMDBcXDAwMlxcMTc1XFwwMDJcXFxuICAgIFxcMjUwXFwwMDJcXDA2OVxcMDAzXFwxNDRcXDAwM1xcMjE5XFwwMDNcXDAzOFxcMDA0XFwxMTNcXDAwNFxcMjUwXFwyNTVcXDI0OVxcMjU1XFxcbiAgICBcXDI0N1xcMjU1XFwyNDZcXDI1NVxcMjQ1XFwyNTVcXDI0MlxcMjU1XFwwMDRcXDAwMFxcMTc0XFwwMDBcXDE4M1xcMDAwXFwxODhcXDAwNFxcXG4gICAgXFwxODVcXDAwMFxcMjExXFwwMDRcXDE5NlxcMDAwXFwyMTVcXDAwMFxcMjM2XFwwMDRcXDI0NVxcMjU1XFwyNDZcXDI1NVxcMDA3XFwwMDBcXFxuICAgIFxcMjM3XFwwMDRcXDIwNFxcMDA0XFwyNTVcXDI1NVxcMjQ4XFwyNTVcXDI0OVxcMjU1XFwyNTBcXDI1NVxcMjUxXFwyNTVcXDI1MlxcMjU1XFxcbiAgICBcXDI1M1xcMjU1XFwyNTRcXDI1NVxcMDE1XFwwMDBcXDI1M1xcMjU1XFwyNTRcXDI1NVxcMjU1XFwyNTVcXDAwOFxcMDAwXCI7XG4gIExleGluZy5sZXhfYmFja3RyayA9XG4gICBcIlxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMTZcXDAwMFxcMDE1XFwwMDBcXDAxNVxcMDAwXFwyNTVcXDI1NVxcMDE0XFwwMDBcXFxuICAgIFxcMDQwXFwwMDBcXDAxMlxcMDAwXFwwMzNcXDAwMFxcMjU1XFwyNTVcXDAzNFxcMDAwXFwwMzVcXDAwMFxcMDM2XFwwMDBcXDAyNVxcMDAwXFxcbiAgICBcXDA0MFxcMDAwXFwwNDBcXDAwMFxcMDE2XFwwMDBcXDAxNlxcMDAwXFwwMTZcXDAwMFxcMDExXFwwMDBcXDAxOFxcMDAwXFwwMDdcXDAwMFxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDAwMFxcMDAwXFwyNTVcXDI1NVxcMDE2XFwwMDBcXDAxNlxcMDAwXFwwMDJcXDAwMFxcMDE2XFwwMDBcXFxuICAgIFxcMDE2XFwwMDBcXDAwM1xcMDAwXFwwMTZcXDAwMFxcMDE2XFwwMDBcXDAxNlxcMDAwXFwwMDRcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMTNcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMDE1XFwwMDBcXDAxNVxcMDAwXFwwMTVcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDA5XFwwMDBcXFxuICAgIFxcMDA4XFwwMDBcXDAxMVxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDAwMFxcMDAwXCI7XG4gIExleGluZy5sZXhfZGVmYXVsdCA9XG4gICBcIlxcMDAxXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMDBcXDAwMFxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDAwXFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMDBcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDcyXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMjU1XFwyNTVcXFxuICAgIFxcMDcyXFwwMDBcXDI1NVxcMjU1XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDgzXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDI1NVxcMjU1XCI7XG4gIExleGluZy5sZXhfdHJhbnMgPVxuICAgXCJcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDI1XFwwMDBcXDAyMlxcMDAwXFwwMjJcXDAwMFxcMDU5XFwwMDBcXDAyM1xcMDAwXFwwNTlcXDAwMFxcMDYwXFwwMDBcXFxuICAgIFxcMDI1XFwwMDBcXDA3MFxcMDAwXFwwODVcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwODVcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwODZcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMjVcXDAwMFxcMDMxXFwwMDBcXDAxOFxcMDAwXFwwMTdcXDAwMFxcMDAwXFwwMDBcXDAyOFxcMDAwXFwwMjlcXDAwMFxcMDI1XFwwMDBcXFxuICAgIFxcMDA5XFwwMDBcXDAwOFxcMDAwXFwwMDVcXDAwMFxcMDA3XFwwMDBcXDAxMlxcMDAwXFwwMDZcXDAwMFxcMDI3XFwwMDBcXDAyNlxcMDAwXFxcbiAgICBcXDAyMVxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcXG4gICAgXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAxMFxcMDAwXFwwMjdcXDAwMFxcMDMzXFwwMDBcXDAzOFxcMDAwXFwwMzJcXDAwMFxcMDExXFwwMDBcXFxuICAgIFxcMDM3XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE2XFwwMDBcXDAyNFxcMDAwXFwwMTVcXDAwMFxcMDA0XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAyN1xcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAzNFxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMzZcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAzNVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxNFxcMDAwXFwwMzBcXDAwMFxcMDEzXFwwMDBcXDAwM1xcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDA1OFxcMDAwXFwwNTdcXDAwMFxcMDU2XFwwMDBcXDA1NVxcMDAwXFwwNTRcXDAwMFxcMDQzXFwwMDBcXDAzOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDQwXFwwMDBcXDA0MVxcMDAwXFwwNDJcXDAwMFxcMDQyXFwwMDBcXDAxOVxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXFxuICAgIFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFxcbiAgICBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDA2N1xcMDAwXFwwNjdcXDAwMFxcXG4gICAgXFwwNjdcXDAwMFxcMDY3XFwwMDBcXDA2N1xcMDAwXFwwNjdcXDAwMFxcMDY3XFwwMDBcXDA2N1xcMDAwXFwwNjJcXDAwMFxcMDY2XFwwMDBcXFxuICAgIFxcMDY2XFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFxcbiAgICBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDA2MVxcMDAwXFwwNjZcXDAwMFxcMDY2XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDY0XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDYzXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAyXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDYyXFwwMDBcXDA2N1xcMDAwXFxcbiAgICBcXDA2N1xcMDAwXFwwNjdcXDAwMFxcMDY3XFwwMDBcXDA2N1xcMDAwXFwwNjdcXDAwMFxcMDY3XFwwMDBcXDA2N1xcMDAwXFwwODRcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwNjFcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDA2NFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDA2M1xcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAxOVxcMDAwXFwwMDBcXDAwMFxcMDUwXFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwNDdcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDE5XFwwMDBcXDAwMFxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDA0NFxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDE5XFwwMDBcXDAwMFxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwNDVcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDAwXFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwNDZcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMTlcXDAwMFxcMDAwXFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMTlcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDQ4XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAxOVxcMDAwXFwwMDBcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDA0OVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAxOVxcMDAwXFwwMDBcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDUxXFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDE5XFwwMDBcXDAwMFxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDUyXFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDE5XFwwMDBcXDAwMFxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwNTNcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDAwXFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDY1XFwwMDBcXDA2NVxcMDAwXFwwNjVcXDAwMFxcMDY1XFwwMDBcXFxuICAgIFxcMDY1XFwwMDBcXDA2NVxcMDAwXFwwNjVcXDAwMFxcMDY1XFwwMDBcXDA2NVxcMDAwXFwwNjVcXDAwMFxcMDcwXFwwMDBcXDI1NVxcMjU1XFxcbiAgICBcXDAwMFxcMDAwXFwwNzFcXDAwMFxcMjU1XFwyNTVcXDA4MVxcMDAwXFwwMDBcXDAwMFxcMDY1XFwwMDBcXDA2NVxcMDAwXFwwNjVcXDAwMFxcXG4gICAgXFwwNjVcXDAwMFxcMDY1XFwwMDBcXDA2NVxcMDAwXFwwNjVcXDAwMFxcMDY1XFwwMDBcXDA2NVxcMDAwXFwwNjVcXDAwMFxcMDY1XFwwMDBcXFxuICAgIFxcMDY1XFwwMDBcXDA2NVxcMDAwXFwwNjVcXDAwMFxcMDY1XFwwMDBcXDA2NVxcMDAwXFwwMDBcXDAwMFxcMDc0XFwwMDBcXDI1NVxcMjU1XFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwNjVcXDAwMFxcMDY1XFwwMDBcXDA2NVxcMDAwXFwwNjVcXDAwMFxcXG4gICAgXFwwNjVcXDAwMFxcMDY1XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDA2NVxcMDAwXFwwNjVcXDAwMFxcMDY1XFwwMDBcXFxuICAgIFxcMDY1XFwwMDBcXDA2NVxcMDAwXFwwNjVcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDA4MFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDA3OVxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDA3OFxcMDAwXFwwMDBcXDAwMFxcMDY1XFwwMDBcXDA2NVxcMDAwXFwwNjVcXDAwMFxcMDY1XFwwMDBcXFxuICAgIFxcMDY1XFwwMDBcXDA2NVxcMDAwXFwwNzdcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDc2XFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDA3NVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwNzNcXDAwMFxcMjU1XFwyNTVcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwNjlcXDAwMFxcMjU1XFwyNTVcIjtcbiAgTGV4aW5nLmxleF9jaGVjayA9XG4gICBcIlxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAyM1xcMDAwXFwwMjRcXDAwMFxcMDAwXFwwMDBcXDA2MFxcMDAwXFwwMjRcXDAwMFxcXG4gICAgXFwwMjVcXDAwMFxcMDcxXFwwMDBcXDA4NlxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDA4MlxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDA4MlxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwyNTVcXDI1NVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMjVcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMjhcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDI2XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDI5XFwwMDBcXDAzMFxcMDAwXFwwMzFcXDAwMFxcMDMyXFwwMDBcXDAzM1xcMDAwXFwwMzdcXDAwMFxcMDM4XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMzlcXDAwMFxcMDQwXFwwMDBcXDA0MVxcMDAwXFwwNDJcXDAwMFxcMDE5XFwwMDBcXDI1NVxcMjU1XFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcXG4gICAgXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIxXFwwMDBcXDAyMVxcMDAwXFwwMjFcXDAwMFxcMDIxXFwwMDBcXFxuICAgIFxcMDIxXFwwMDBcXDAyMVxcMDAwXFwwMjFcXDAwMFxcMDIxXFwwMDBcXDAyMVxcMDAwXFwwMjFcXDAwMFxcMDYxXFwwMDBcXDA2MVxcMDAwXFxcbiAgICBcXDA2MVxcMDAwXFwwNjFcXDAwMFxcMDYxXFwwMDBcXDA2MVxcMDAwXFwwNjFcXDAwMFxcMDYxXFwwMDBcXDAyMVxcMDAwXFwwNjJcXDAwMFxcXG4gICAgXFwwNjJcXDAwMFxcMDY0XFwwMDBcXDA2NFxcMDAwXFwwNjRcXDAwMFxcMDY0XFwwMDBcXDA2NFxcMDAwXFwwNjRcXDAwMFxcMDY0XFwwMDBcXFxuICAgIFxcMDY0XFwwMDBcXDA2NFxcMDAwXFwwNjRcXDAwMFxcMDIxXFwwMDBcXDA2NlxcMDAwXFwwNjZcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwwMjFcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMjFcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwwMDBcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMjFcXDAwMFxcMDY3XFwwMDBcXFxuICAgIFxcMDY3XFwwMDBcXDA2N1xcMDAwXFwwNjdcXDAwMFxcMDY3XFwwMDBcXDA2N1xcMDAwXFwwNjdcXDAwMFxcMDY3XFwwMDBcXDA4MlxcMDAwXFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDAyMVxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMDIxXFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDIxXFwwMDBcXDAzNFxcMDAwXFwwMzRcXDAwMFxcMDM0XFwwMDBcXFxuICAgIFxcMDM0XFwwMDBcXDAzNFxcMDAwXFwwMzRcXDAwMFxcMDM0XFwwMDBcXDAzNFxcMDAwXFwwMzRcXDAwMFxcMDM0XFwwMDBcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDAzNFxcMDAwXFwwMzRcXDAwMFxcXG4gICAgXFwwMzRcXDAwMFxcMDM0XFwwMDBcXDAzNFxcMDAwXFwwMzRcXDAwMFxcMDM0XFwwMDBcXDAzNFxcMDAwXFwwMzRcXDAwMFxcMDM0XFwwMDBcXFxuICAgIFxcMDM0XFwwMDBcXDAzNFxcMDAwXFwwMzRcXDAwMFxcMDM0XFwwMDBcXDAzNFxcMDAwXFwwMzRcXDAwMFxcMDM0XFwwMDBcXDAzNFxcMDAwXFxcbiAgICBcXDAzNFxcMDAwXFwwMzRcXDAwMFxcMDM0XFwwMDBcXDAzNFxcMDAwXFwwMzRcXDAwMFxcMDM0XFwwMDBcXDAzNFxcMDAwXFwwMzRcXDAwMFxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDM0XFwwMDBcXDI1NVxcMjU1XFwwMzRcXDAwMFxcMDM0XFwwMDBcXFxuICAgIFxcMDM0XFwwMDBcXDAzNFxcMDAwXFwwMzRcXDAwMFxcMDM0XFwwMDBcXDAzNFxcMDAwXFwwMzRcXDAwMFxcMDM0XFwwMDBcXDAzNFxcMDAwXFxcbiAgICBcXDAzNFxcMDAwXFwwMzRcXDAwMFxcMDM0XFwwMDBcXDAzNFxcMDAwXFwwMzRcXDAwMFxcMDM0XFwwMDBcXDAzNFxcMDAwXFwwMzRcXDAwMFxcXG4gICAgXFwwMzRcXDAwMFxcMDM0XFwwMDBcXDAzNFxcMDAwXFwwMzRcXDAwMFxcMDM0XFwwMDBcXDAzNFxcMDAwXFwwMzRcXDAwMFxcMDM0XFwwMDBcXFxuICAgIFxcMDM1XFwwMDBcXDAzNVxcMDAwXFwwMzVcXDAwMFxcMDM1XFwwMDBcXDAzNVxcMDAwXFwwMzVcXDAwMFxcMDM1XFwwMDBcXDAzNVxcMDAwXFxcbiAgICBcXDAzNVxcMDAwXFwwMzVcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMDM1XFwwMDBcXDAzNVxcMDAwXFwwMzVcXDAwMFxcMDM1XFwwMDBcXDAzNVxcMDAwXFwwMzVcXDAwMFxcMDM1XFwwMDBcXFxuICAgIFxcMDM1XFwwMDBcXDAzNVxcMDAwXFwwMzVcXDAwMFxcMDM1XFwwMDBcXDAzNVxcMDAwXFwwMzVcXDAwMFxcMDM1XFwwMDBcXDAzNVxcMDAwXFxcbiAgICBcXDAzNVxcMDAwXFwwMzVcXDAwMFxcMDM1XFwwMDBcXDAzNVxcMDAwXFwwMzVcXDAwMFxcMDM1XFwwMDBcXDAzNVxcMDAwXFwwMzVcXDAwMFxcXG4gICAgXFwwMzVcXDAwMFxcMDM1XFwwMDBcXDAzNVxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDM1XFwwMDBcXFxuICAgIFxcMjU1XFwyNTVcXDAzNVxcMDAwXFwwMzVcXDAwMFxcMDM1XFwwMDBcXDAzNVxcMDAwXFwwMzVcXDAwMFxcMDM1XFwwMDBcXDAzNVxcMDAwXFxcbiAgICBcXDAzNVxcMDAwXFwwMzVcXDAwMFxcMDM1XFwwMDBcXDAzNVxcMDAwXFwwMzVcXDAwMFxcMDM1XFwwMDBcXDAzNVxcMDAwXFwwMzVcXDAwMFxcXG4gICAgXFwwMzVcXDAwMFxcMDM1XFwwMDBcXDAzNVxcMDAwXFwwMzVcXDAwMFxcMDM1XFwwMDBcXDAzNVxcMDAwXFwwMzVcXDAwMFxcMDM1XFwwMDBcXFxuICAgIFxcMDM1XFwwMDBcXDAzNVxcMDAwXFwwMzVcXDAwMFxcMDM2XFwwMDBcXDAzNlxcMDAwXFwwMzZcXDAwMFxcMDM2XFwwMDBcXDAzNlxcMDAwXFxcbiAgICBcXDAzNlxcMDAwXFwwMzZcXDAwMFxcMDM2XFwwMDBcXDAzNlxcMDAwXFwwMzZcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDM2XFwwMDBcXDAzNlxcMDAwXFwwMzZcXDAwMFxcMDM2XFwwMDBcXFxuICAgIFxcMDM2XFwwMDBcXDAzNlxcMDAwXFwwMzZcXDAwMFxcMDM2XFwwMDBcXDAzNlxcMDAwXFwwMzZcXDAwMFxcMDM2XFwwMDBcXDAzNlxcMDAwXFxcbiAgICBcXDAzNlxcMDAwXFwwMzZcXDAwMFxcMDM2XFwwMDBcXDAzNlxcMDAwXFwwMzZcXDAwMFxcMDM2XFwwMDBcXDAzNlxcMDAwXFwwMzZcXDAwMFxcXG4gICAgXFwwMzZcXDAwMFxcMDM2XFwwMDBcXDAzNlxcMDAwXFwwMzZcXDAwMFxcMDM2XFwwMDBcXDAzNlxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMzZcXDAwMFxcMjU1XFwyNTVcXDAzNlxcMDAwXFwwMzZcXDAwMFxcMDM2XFwwMDBcXDAzNlxcMDAwXFxcbiAgICBcXDAzNlxcMDAwXFwwMzZcXDAwMFxcMDM2XFwwMDBcXDAzNlxcMDAwXFwwMzZcXDAwMFxcMDM2XFwwMDBcXDAzNlxcMDAwXFwwMzZcXDAwMFxcXG4gICAgXFwwMzZcXDAwMFxcMDM2XFwwMDBcXDAzNlxcMDAwXFwwMzZcXDAwMFxcMDM2XFwwMDBcXDAzNlxcMDAwXFwwMzZcXDAwMFxcMDM2XFwwMDBcXFxuICAgIFxcMDM2XFwwMDBcXDAzNlxcMDAwXFwwMzZcXDAwMFxcMDM2XFwwMDBcXDAzNlxcMDAwXFwwMzZcXDAwMFxcMDQ0XFwwMDBcXDA0NFxcMDAwXFxcbiAgICBcXDA0NFxcMDAwXFwwNDRcXDAwMFxcMDQ0XFwwMDBcXDA0NFxcMDAwXFwwNDRcXDAwMFxcMDQ0XFwwMDBcXDA0NFxcMDAwXFwwNDRcXDAwMFxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDQ0XFwwMDBcXFxuICAgIFxcMDQ0XFwwMDBcXDA0NFxcMDAwXFwwNDRcXDAwMFxcMDQ0XFwwMDBcXDA0NFxcMDAwXFwwNDRcXDAwMFxcMDQ0XFwwMDBcXDA0NFxcMDAwXFxcbiAgICBcXDA0NFxcMDAwXFwwNDRcXDAwMFxcMDQ0XFwwMDBcXDA0NFxcMDAwXFwwNDRcXDAwMFxcMDQ0XFwwMDBcXDA0NFxcMDAwXFwwNDRcXDAwMFxcXG4gICAgXFwwNDRcXDAwMFxcMDQ0XFwwMDBcXDA0NFxcMDAwXFwwNDRcXDAwMFxcMDQ0XFwwMDBcXDA0NFxcMDAwXFwwNDRcXDAwMFxcMDQ0XFwwMDBcXFxuICAgIFxcMDQ0XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwNDRcXDAwMFxcMjU1XFwyNTVcXDA0NFxcMDAwXFxcbiAgICBcXDA0NFxcMDAwXFwwNDRcXDAwMFxcMDQ0XFwwMDBcXDA0NFxcMDAwXFwwNDRcXDAwMFxcMDQ0XFwwMDBcXDA0NFxcMDAwXFwwNDRcXDAwMFxcXG4gICAgXFwwNDRcXDAwMFxcMDQ0XFwwMDBcXDA0NFxcMDAwXFwwNDRcXDAwMFxcMDQ0XFwwMDBcXDA0NFxcMDAwXFwwNDRcXDAwMFxcMDQ0XFwwMDBcXFxuICAgIFxcMDQ0XFwwMDBcXDA0NFxcMDAwXFwwNDRcXDAwMFxcMDQ0XFwwMDBcXDA0NFxcMDAwXFwwNDRcXDAwMFxcMDQ0XFwwMDBcXDA0NFxcMDAwXFxcbiAgICBcXDA0NFxcMDAwXFwwNDVcXDAwMFxcMDQ1XFwwMDBcXDA0NVxcMDAwXFwwNDVcXDAwMFxcMDQ1XFwwMDBcXDA0NVxcMDAwXFwwNDVcXDAwMFxcXG4gICAgXFwwNDVcXDAwMFxcMDQ1XFwwMDBcXDA0NVxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwNDVcXDAwMFxcMDQ1XFwwMDBcXDA0NVxcMDAwXFwwNDVcXDAwMFxcMDQ1XFwwMDBcXDA0NVxcMDAwXFxcbiAgICBcXDA0NVxcMDAwXFwwNDVcXDAwMFxcMDQ1XFwwMDBcXDA0NVxcMDAwXFwwNDVcXDAwMFxcMDQ1XFwwMDBcXDA0NVxcMDAwXFwwNDVcXDAwMFxcXG4gICAgXFwwNDVcXDAwMFxcMDQ1XFwwMDBcXDA0NVxcMDAwXFwwNDVcXDAwMFxcMDQ1XFwwMDBcXDA0NVxcMDAwXFwwNDVcXDAwMFxcMDQ1XFwwMDBcXFxuICAgIFxcMDQ1XFwwMDBcXDA0NVxcMDAwXFwwNDVcXDAwMFxcMDQ1XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDA0NVxcMDAwXFwyNTVcXDI1NVxcMDQ1XFwwMDBcXDA0NVxcMDAwXFwwNDVcXDAwMFxcMDQ1XFwwMDBcXDA0NVxcMDAwXFwwNDVcXDAwMFxcXG4gICAgXFwwNDVcXDAwMFxcMDQ1XFwwMDBcXDA0NVxcMDAwXFwwNDVcXDAwMFxcMDQ1XFwwMDBcXDA0NVxcMDAwXFwwNDVcXDAwMFxcMDQ1XFwwMDBcXFxuICAgIFxcMDQ1XFwwMDBcXDA0NVxcMDAwXFwwNDVcXDAwMFxcMDQ1XFwwMDBcXDA0NVxcMDAwXFwwNDVcXDAwMFxcMDQ1XFwwMDBcXDA0NVxcMDAwXFxcbiAgICBcXDA0NVxcMDAwXFwwNDVcXDAwMFxcMDQ1XFwwMDBcXDA0NVxcMDAwXFwwNDZcXDAwMFxcMDQ2XFwwMDBcXDA0NlxcMDAwXFwwNDZcXDAwMFxcXG4gICAgXFwwNDZcXDAwMFxcMDQ2XFwwMDBcXDA0NlxcMDAwXFwwNDZcXDAwMFxcMDQ2XFwwMDBcXDA0NlxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwNDZcXDAwMFxcMDQ2XFwwMDBcXDA0NlxcMDAwXFxcbiAgICBcXDA0NlxcMDAwXFwwNDZcXDAwMFxcMDQ2XFwwMDBcXDA0NlxcMDAwXFwwNDZcXDAwMFxcMDQ2XFwwMDBcXDA0NlxcMDAwXFwwNDZcXDAwMFxcXG4gICAgXFwwNDZcXDAwMFxcMDQ2XFwwMDBcXDA0NlxcMDAwXFwwNDZcXDAwMFxcMDQ2XFwwMDBcXDA0NlxcMDAwXFwwNDZcXDAwMFxcMDQ2XFwwMDBcXFxuICAgIFxcMDQ2XFwwMDBcXDA0NlxcMDAwXFwwNDZcXDAwMFxcMDQ2XFwwMDBcXDA0NlxcMDAwXFwwNDZcXDAwMFxcMDQ2XFwwMDBcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDA0NlxcMDAwXFwyNTVcXDI1NVxcMDQ2XFwwMDBcXDA0NlxcMDAwXFwwNDZcXDAwMFxcXG4gICAgXFwwNDZcXDAwMFxcMDQ2XFwwMDBcXDA0NlxcMDAwXFwwNDZcXDAwMFxcMDQ2XFwwMDBcXDA0NlxcMDAwXFwwNDZcXDAwMFxcMDQ2XFwwMDBcXFxuICAgIFxcMDQ2XFwwMDBcXDA0NlxcMDAwXFwwNDZcXDAwMFxcMDQ2XFwwMDBcXDA0NlxcMDAwXFwwNDZcXDAwMFxcMDQ2XFwwMDBcXDA0NlxcMDAwXFxcbiAgICBcXDA0NlxcMDAwXFwwNDZcXDAwMFxcMDQ2XFwwMDBcXDA0NlxcMDAwXFwwNDZcXDAwMFxcMDQ2XFwwMDBcXDA0NlxcMDAwXFwwNDdcXDAwMFxcXG4gICAgXFwwNDdcXDAwMFxcMDQ3XFwwMDBcXDA0N1xcMDAwXFwwNDdcXDAwMFxcMDQ3XFwwMDBcXDA0N1xcMDAwXFwwNDdcXDAwMFxcMDQ3XFwwMDBcXFxuICAgIFxcMDQ3XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDA0N1xcMDAwXFwwNDdcXDAwMFxcMDQ3XFwwMDBcXDA0N1xcMDAwXFwwNDdcXDAwMFxcMDQ3XFwwMDBcXDA0N1xcMDAwXFwwNDdcXDAwMFxcXG4gICAgXFwwNDdcXDAwMFxcMDQ3XFwwMDBcXDA0N1xcMDAwXFwwNDdcXDAwMFxcMDQ3XFwwMDBcXDA0N1xcMDAwXFwwNDdcXDAwMFxcMDQ3XFwwMDBcXFxuICAgIFxcMDQ3XFwwMDBcXDA0N1xcMDAwXFwwNDdcXDAwMFxcMDQ3XFwwMDBcXDA0N1xcMDAwXFwwNDdcXDAwMFxcMDQ3XFwwMDBcXDA0N1xcMDAwXFxcbiAgICBcXDA0N1xcMDAwXFwwNDdcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDA0N1xcMDAwXFwyNTVcXDI1NVxcXG4gICAgXFwwNDdcXDAwMFxcMDQ3XFwwMDBcXDA0N1xcMDAwXFwwNDdcXDAwMFxcMDQ3XFwwMDBcXDA0N1xcMDAwXFwwNDdcXDAwMFxcMDQ3XFwwMDBcXFxuICAgIFxcMDQ3XFwwMDBcXDA0N1xcMDAwXFwwNDdcXDAwMFxcMDQ3XFwwMDBcXDA0N1xcMDAwXFwwNDdcXDAwMFxcMDQ3XFwwMDBcXDA0N1xcMDAwXFxcbiAgICBcXDA0N1xcMDAwXFwwNDdcXDAwMFxcMDQ3XFwwMDBcXDA0N1xcMDAwXFwwNDdcXDAwMFxcMDQ3XFwwMDBcXDA0N1xcMDAwXFwwNDdcXDAwMFxcXG4gICAgXFwwNDdcXDAwMFxcMDQ3XFwwMDBcXDA0OFxcMDAwXFwwNDhcXDAwMFxcMDQ4XFwwMDBcXDA0OFxcMDAwXFwwNDhcXDAwMFxcMDQ4XFwwMDBcXFxuICAgIFxcMDQ4XFwwMDBcXDA0OFxcMDAwXFwwNDhcXDAwMFxcMDQ4XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDA0OFxcMDAwXFwwNDhcXDAwMFxcMDQ4XFwwMDBcXDA0OFxcMDAwXFwwNDhcXDAwMFxcXG4gICAgXFwwNDhcXDAwMFxcMDQ4XFwwMDBcXDA0OFxcMDAwXFwwNDhcXDAwMFxcMDQ4XFwwMDBcXDA0OFxcMDAwXFwwNDhcXDAwMFxcMDQ4XFwwMDBcXFxuICAgIFxcMDQ4XFwwMDBcXDA0OFxcMDAwXFwwNDhcXDAwMFxcMDQ4XFwwMDBcXDA0OFxcMDAwXFwwNDhcXDAwMFxcMDQ4XFwwMDBcXDA0OFxcMDAwXFxcbiAgICBcXDA0OFxcMDAwXFwwNDhcXDAwMFxcMDQ4XFwwMDBcXDA0OFxcMDAwXFwwNDhcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMDQ4XFwwMDBcXDI1NVxcMjU1XFwwNDhcXDAwMFxcMDQ4XFwwMDBcXDA0OFxcMDAwXFwwNDhcXDAwMFxcMDQ4XFwwMDBcXFxuICAgIFxcMDQ4XFwwMDBcXDA0OFxcMDAwXFwwNDhcXDAwMFxcMDQ4XFwwMDBcXDA0OFxcMDAwXFwwNDhcXDAwMFxcMDQ4XFwwMDBcXDA0OFxcMDAwXFxcbiAgICBcXDA0OFxcMDAwXFwwNDhcXDAwMFxcMDQ4XFwwMDBcXDA0OFxcMDAwXFwwNDhcXDAwMFxcMDQ4XFwwMDBcXDA0OFxcMDAwXFwwNDhcXDAwMFxcXG4gICAgXFwwNDhcXDAwMFxcMDQ4XFwwMDBcXDA0OFxcMDAwXFwwNDhcXDAwMFxcMDQ4XFwwMDBcXDA0OVxcMDAwXFwwNDlcXDAwMFxcMDQ5XFwwMDBcXFxuICAgIFxcMDQ5XFwwMDBcXDA0OVxcMDAwXFwwNDlcXDAwMFxcMDQ5XFwwMDBcXDA0OVxcMDAwXFwwNDlcXDAwMFxcMDQ5XFwwMDBcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDA0OVxcMDAwXFwwNDlcXDAwMFxcXG4gICAgXFwwNDlcXDAwMFxcMDQ5XFwwMDBcXDA0OVxcMDAwXFwwNDlcXDAwMFxcMDQ5XFwwMDBcXDA0OVxcMDAwXFwwNDlcXDAwMFxcMDQ5XFwwMDBcXFxuICAgIFxcMDQ5XFwwMDBcXDA0OVxcMDAwXFwwNDlcXDAwMFxcMDQ5XFwwMDBcXDA0OVxcMDAwXFwwNDlcXDAwMFxcMDQ5XFwwMDBcXDA0OVxcMDAwXFxcbiAgICBcXDA0OVxcMDAwXFwwNDlcXDAwMFxcMDQ5XFwwMDBcXDA0OVxcMDAwXFwwNDlcXDAwMFxcMDQ5XFwwMDBcXDA0OVxcMDAwXFwwNDlcXDAwMFxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDQ5XFwwMDBcXDI1NVxcMjU1XFwwNDlcXDAwMFxcMDQ5XFwwMDBcXFxuICAgIFxcMDQ5XFwwMDBcXDA0OVxcMDAwXFwwNDlcXDAwMFxcMDQ5XFwwMDBcXDA0OVxcMDAwXFwwNDlcXDAwMFxcMDQ5XFwwMDBcXDA0OVxcMDAwXFxcbiAgICBcXDA0OVxcMDAwXFwwNDlcXDAwMFxcMDQ5XFwwMDBcXDA0OVxcMDAwXFwwNDlcXDAwMFxcMDQ5XFwwMDBcXDA0OVxcMDAwXFwwNDlcXDAwMFxcXG4gICAgXFwwNDlcXDAwMFxcMDQ5XFwwMDBcXDA0OVxcMDAwXFwwNDlcXDAwMFxcMDQ5XFwwMDBcXDA0OVxcMDAwXFwwNDlcXDAwMFxcMDQ5XFwwMDBcXFxuICAgIFxcMDUwXFwwMDBcXDA1MFxcMDAwXFwwNTBcXDAwMFxcMDUwXFwwMDBcXDA1MFxcMDAwXFwwNTBcXDAwMFxcMDUwXFwwMDBcXDA1MFxcMDAwXFxcbiAgICBcXDA1MFxcMDAwXFwwNTBcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMDUwXFwwMDBcXDA1MFxcMDAwXFwwNTBcXDAwMFxcMDUwXFwwMDBcXDA1MFxcMDAwXFwwNTBcXDAwMFxcMDUwXFwwMDBcXFxuICAgIFxcMDUwXFwwMDBcXDA1MFxcMDAwXFwwNTBcXDAwMFxcMDUwXFwwMDBcXDA1MFxcMDAwXFwwNTBcXDAwMFxcMDUwXFwwMDBcXDA1MFxcMDAwXFxcbiAgICBcXDA1MFxcMDAwXFwwNTBcXDAwMFxcMDUwXFwwMDBcXDA1MFxcMDAwXFwwNTBcXDAwMFxcMDUwXFwwMDBcXDA1MFxcMDAwXFwwNTBcXDAwMFxcXG4gICAgXFwwNTBcXDAwMFxcMDUwXFwwMDBcXDA1MFxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDUwXFwwMDBcXFxuICAgIFxcMjU1XFwyNTVcXDA1MFxcMDAwXFwwNTBcXDAwMFxcMDUwXFwwMDBcXDA1MFxcMDAwXFwwNTBcXDAwMFxcMDUwXFwwMDBcXDA1MFxcMDAwXFxcbiAgICBcXDA1MFxcMDAwXFwwNTBcXDAwMFxcMDUwXFwwMDBcXDA1MFxcMDAwXFwwNTBcXDAwMFxcMDUwXFwwMDBcXDA1MFxcMDAwXFwwNTBcXDAwMFxcXG4gICAgXFwwNTBcXDAwMFxcMDUwXFwwMDBcXDA1MFxcMDAwXFwwNTBcXDAwMFxcMDUwXFwwMDBcXDA1MFxcMDAwXFwwNTBcXDAwMFxcMDUwXFwwMDBcXFxuICAgIFxcMDUwXFwwMDBcXDA1MFxcMDAwXFwwNTBcXDAwMFxcMDUxXFwwMDBcXDA1MVxcMDAwXFwwNTFcXDAwMFxcMDUxXFwwMDBcXDA1MVxcMDAwXFxcbiAgICBcXDA1MVxcMDAwXFwwNTFcXDAwMFxcMDUxXFwwMDBcXDA1MVxcMDAwXFwwNTFcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDUxXFwwMDBcXDA1MVxcMDAwXFwwNTFcXDAwMFxcMDUxXFwwMDBcXFxuICAgIFxcMDUxXFwwMDBcXDA1MVxcMDAwXFwwNTFcXDAwMFxcMDUxXFwwMDBcXDA1MVxcMDAwXFwwNTFcXDAwMFxcMDUxXFwwMDBcXDA1MVxcMDAwXFxcbiAgICBcXDA1MVxcMDAwXFwwNTFcXDAwMFxcMDUxXFwwMDBcXDA1MVxcMDAwXFwwNTFcXDAwMFxcMDUxXFwwMDBcXDA1MVxcMDAwXFwwNTFcXDAwMFxcXG4gICAgXFwwNTFcXDAwMFxcMDUxXFwwMDBcXDA1MVxcMDAwXFwwNTFcXDAwMFxcMDUxXFwwMDBcXDA1MVxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwNTFcXDAwMFxcMjU1XFwyNTVcXDA1MVxcMDAwXFwwNTFcXDAwMFxcMDUxXFwwMDBcXDA1MVxcMDAwXFxcbiAgICBcXDA1MVxcMDAwXFwwNTFcXDAwMFxcMDUxXFwwMDBcXDA1MVxcMDAwXFwwNTFcXDAwMFxcMDUxXFwwMDBcXDA1MVxcMDAwXFwwNTFcXDAwMFxcXG4gICAgXFwwNTFcXDAwMFxcMDUxXFwwMDBcXDA1MVxcMDAwXFwwNTFcXDAwMFxcMDUxXFwwMDBcXDA1MVxcMDAwXFwwNTFcXDAwMFxcMDUxXFwwMDBcXFxuICAgIFxcMDUxXFwwMDBcXDA1MVxcMDAwXFwwNTFcXDAwMFxcMDUxXFwwMDBcXDA1MVxcMDAwXFwwNTFcXDAwMFxcMDUyXFwwMDBcXDA1MlxcMDAwXFxcbiAgICBcXDA1MlxcMDAwXFwwNTJcXDAwMFxcMDUyXFwwMDBcXDA1MlxcMDAwXFwwNTJcXDAwMFxcMDUyXFwwMDBcXDA1MlxcMDAwXFwwNTJcXDAwMFxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDUyXFwwMDBcXFxuICAgIFxcMDUyXFwwMDBcXDA1MlxcMDAwXFwwNTJcXDAwMFxcMDUyXFwwMDBcXDA1MlxcMDAwXFwwNTJcXDAwMFxcMDUyXFwwMDBcXDA1MlxcMDAwXFxcbiAgICBcXDA1MlxcMDAwXFwwNTJcXDAwMFxcMDUyXFwwMDBcXDA1MlxcMDAwXFwwNTJcXDAwMFxcMDUyXFwwMDBcXDA1MlxcMDAwXFwwNTJcXDAwMFxcXG4gICAgXFwwNTJcXDAwMFxcMDUyXFwwMDBcXDA1MlxcMDAwXFwwNTJcXDAwMFxcMDUyXFwwMDBcXDA1MlxcMDAwXFwwNTJcXDAwMFxcMDUyXFwwMDBcXFxuICAgIFxcMDUyXFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwNTJcXDAwMFxcMjU1XFwyNTVcXDA1MlxcMDAwXFxcbiAgICBcXDA1MlxcMDAwXFwwNTJcXDAwMFxcMDUyXFwwMDBcXDA1MlxcMDAwXFwwNTJcXDAwMFxcMDUyXFwwMDBcXDA1MlxcMDAwXFwwNTJcXDAwMFxcXG4gICAgXFwwNTJcXDAwMFxcMDUyXFwwMDBcXDA1MlxcMDAwXFwwNTJcXDAwMFxcMDUyXFwwMDBcXDA1MlxcMDAwXFwwNTJcXDAwMFxcMDUyXFwwMDBcXFxuICAgIFxcMDUyXFwwMDBcXDA1MlxcMDAwXFwwNTJcXDAwMFxcMDUyXFwwMDBcXDA1MlxcMDAwXFwwNTJcXDAwMFxcMDUyXFwwMDBcXDA1MlxcMDAwXFxcbiAgICBcXDA1MlxcMDAwXFwwNTNcXDAwMFxcMDUzXFwwMDBcXDA1M1xcMDAwXFwwNTNcXDAwMFxcMDUzXFwwMDBcXDA1M1xcMDAwXFwwNTNcXDAwMFxcXG4gICAgXFwwNTNcXDAwMFxcMDUzXFwwMDBcXDA1M1xcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwNTNcXDAwMFxcMDUzXFwwMDBcXDA1M1xcMDAwXFwwNTNcXDAwMFxcMDUzXFwwMDBcXDA1M1xcMDAwXFxcbiAgICBcXDA1M1xcMDAwXFwwNTNcXDAwMFxcMDUzXFwwMDBcXDA1M1xcMDAwXFwwNTNcXDAwMFxcMDUzXFwwMDBcXDA1M1xcMDAwXFwwNTNcXDAwMFxcXG4gICAgXFwwNTNcXDAwMFxcMDUzXFwwMDBcXDA1M1xcMDAwXFwwNTNcXDAwMFxcMDUzXFwwMDBcXDA1M1xcMDAwXFwwNTNcXDAwMFxcMDUzXFwwMDBcXFxuICAgIFxcMDUzXFwwMDBcXDA1M1xcMDAwXFwwNTNcXDAwMFxcMDUzXFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDA1M1xcMDAwXFwyNTVcXDI1NVxcMDUzXFwwMDBcXDA1M1xcMDAwXFwwNTNcXDAwMFxcMDUzXFwwMDBcXDA1M1xcMDAwXFwwNTNcXDAwMFxcXG4gICAgXFwwNTNcXDAwMFxcMDUzXFwwMDBcXDA1M1xcMDAwXFwwNTNcXDAwMFxcMDUzXFwwMDBcXDA1M1xcMDAwXFwwNTNcXDAwMFxcMDUzXFwwMDBcXFxuICAgIFxcMDUzXFwwMDBcXDA1M1xcMDAwXFwwNTNcXDAwMFxcMDUzXFwwMDBcXDA1M1xcMDAwXFwwNTNcXDAwMFxcMDUzXFwwMDBcXDA1M1xcMDAwXFxcbiAgICBcXDA1M1xcMDAwXFwwNTNcXDAwMFxcMDUzXFwwMDBcXDA1M1xcMDAwXFwwNjNcXDAwMFxcMDYzXFwwMDBcXDA2M1xcMDAwXFwwNjNcXDAwMFxcXG4gICAgXFwwNjNcXDAwMFxcMDYzXFwwMDBcXDA2M1xcMDAwXFwwNjNcXDAwMFxcMDYzXFwwMDBcXDA2M1xcMDAwXFwwNjhcXDAwMFxcMDcyXFwwMDBcXFxuICAgIFxcMjU1XFwyNTVcXDA2OFxcMDAwXFwwNzJcXDAwMFxcMDczXFwwMDBcXDI1NVxcMjU1XFwwNjNcXDAwMFxcMDYzXFwwMDBcXDA2M1xcMDAwXFxcbiAgICBcXDA2M1xcMDAwXFwwNjNcXDAwMFxcMDYzXFwwMDBcXDA2NVxcMDAwXFwwNjVcXDAwMFxcMDY1XFwwMDBcXDA2NVxcMDAwXFwwNjVcXDAwMFxcXG4gICAgXFwwNjVcXDAwMFxcMDY1XFwwMDBcXDA2NVxcMDAwXFwwNjVcXDAwMFxcMDY1XFwwMDBcXDI1NVxcMjU1XFwwNjhcXDAwMFxcMDcyXFwwMDBcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDA2NVxcMDAwXFwwNjVcXDAwMFxcMDY1XFwwMDBcXDA2NVxcMDAwXFxcbiAgICBcXDA2NVxcMDAwXFwwNjVcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDYzXFwwMDBcXDA2M1xcMDAwXFwwNjNcXDAwMFxcXG4gICAgXFwwNjNcXDAwMFxcMDYzXFwwMDBcXDA2M1xcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMDczXFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDczXFwwMDBcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDczXFwwMDBcXDI1NVxcMjU1XFwwNjVcXDAwMFxcMDY1XFwwMDBcXDA2NVxcMDAwXFwwNjVcXDAwMFxcXG4gICAgXFwwNjVcXDAwMFxcMDY1XFwwMDBcXDA3M1xcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwNzNcXDAwMFxcMjU1XFwyNTVcXFxuICAgIFxcMDczXFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDA2OFxcMDAwXFwwNzJcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDA2OFxcMDAwXFwwNzJcXDAwMFwiO1xuICBMZXhpbmcubGV4X2Jhc2VfY29kZSA9XG4gICBcIlwiO1xuICBMZXhpbmcubGV4X2JhY2t0cmtfY29kZSA9XG4gICBcIlwiO1xuICBMZXhpbmcubGV4X2RlZmF1bHRfY29kZSA9XG4gICBcIlwiO1xuICBMZXhpbmcubGV4X3RyYW5zX2NvZGUgPVxuICAgXCJcIjtcbiAgTGV4aW5nLmxleF9jaGVja19jb2RlID1cbiAgIFwiXCI7XG4gIExleGluZy5sZXhfY29kZSA9XG4gICBcIlwiO1xufVxuXG5sZXQgcmVjIHJlYWQgbGV4YnVmID1cbiAgIF9fb2NhbWxfbGV4X3JlYWRfcmVjIGxleGJ1ZiAwXG5hbmQgX19vY2FtbF9sZXhfcmVhZF9yZWMgbGV4YnVmIF9fb2NhbWxfbGV4X3N0YXRlID1cbiAgbWF0Y2ggTGV4aW5nLmVuZ2luZSBfX29jYW1sX2xleF90YWJsZXMgX19vY2FtbF9sZXhfc3RhdGUgbGV4YnVmIHdpdGhcbiAgICAgIHwgMCAtPlxuIyA0NCBcIklPL2xleGVyLm1sbFwiXG4gICAgICAgICAgICAgICAgICAgKCBFT0YgKVxuIyA0NjAgXCJJTy9sZXhlci5tbFwiXG5cbiAgfCAxIC0+XG4jIDQ1IFwiSU8vbGV4ZXIubWxsXCJcbiAgICAgICAgICAgICAgKCBIRUFERVIgKVxuIyA0NjUgXCJJTy9sZXhlci5tbFwiXG5cbiAgfCAyIC0+XG4jIDQ2IFwiSU8vbGV4ZXIubWxsXCJcbiAgICAgICAgICAgICAgKCBOVUxMIClcbiMgNDcwIFwiSU8vbGV4ZXIubWxcIlxuXG4gIHwgMyAtPlxuIyA0NyBcIklPL2xleGVyLm1sbFwiXG4gICAgICAgICAgICAgICggQk9PTCB0cnVlIClcbiMgNDc1IFwiSU8vbGV4ZXIubWxcIlxuXG4gIHwgNCAtPlxuIyA0OCBcIklPL2xleGVyLm1sbFwiXG4gICAgICAgICAgICAgICggQk9PTCBmYWxzZSApXG4jIDQ4MCBcIklPL2xleGVyLm1sXCJcblxuICB8IDUgLT5cbiMgNDkgXCJJTy9sZXhlci5tbGxcIlxuICAgICAgICAgICAgICAoIExTSElGVCApXG4jIDQ4NSBcIklPL2xleGVyLm1sXCJcblxuICB8IDYgLT5cbiMgNTAgXCJJTy9sZXhlci5tbGxcIlxuICAgICAgICAgICAgICAoIFJTSElGVCApXG4jIDQ5MCBcIklPL2xleGVyLm1sXCJcblxuICB8IDcgLT5cbiMgNTEgXCJJTy9sZXhlci5tbGxcIlxuICAgICAgICAgICAgICAoIEVRIClcbiMgNDk1IFwiSU8vbGV4ZXIubWxcIlxuXG4gIHwgOCAtPlxuIyA1MiBcIklPL2xleGVyLm1sbFwiXG4gICAgICAgICAgICAgICggTkVRIClcbiMgNTAwIFwiSU8vbGV4ZXIubWxcIlxuXG4gIHwgOSAtPlxuIyA1MyBcIklPL2xleGVyLm1sbFwiXG4gICAgICAgICAgICAgICggQk9SIClcbiMgNTA1IFwiSU8vbGV4ZXIubWxcIlxuXG4gIHwgMTAgLT5cbiMgNTQgXCJJTy9sZXhlci5tbGxcIlxuICAgICAgICAgICAgICAoIEJBTkQgKVxuIyA1MTAgXCJJTy9sZXhlci5tbFwiXG5cbiAgfCAxMSAtPlxuIyA1NSBcIklPL2xleGVyLm1sbFwiXG4gICAgICAgICAgICAgICggcmVhZF9jb21tZW50IGxleGJ1ZiApXG4jIDUxNSBcIklPL2xleGVyLm1sXCJcblxuICB8IDEyIC0+XG4jIDU2IFwiSU8vbGV4ZXIubWxsXCJcbiAgICAgICAgICAgICAgKCByZWFkIGxleGJ1ZiApXG4jIDUyMCBcIklPL2xleGVyLm1sXCJcblxuICB8IDEzIC0+XG4jIDU3IFwiSU8vbGV4ZXIubWxsXCJcbiAgICAgICAgICAgICAgICAgKCBuZXh0X2xpbmUgbGV4YnVmIDsgcmVhZCBsZXhidWYgKVxuIyA1MjUgXCJJTy9sZXhlci5tbFwiXG5cbiAgfCAxNCAtPlxuIyA1OCBcIklPL2xleGVyLm1sbFwiXG4gICAgICAgICAgICAgICggbmV4dF9saW5lIGxleGJ1ZiA7IEVPTCApXG4jIDUzMCBcIklPL2xleGVyLm1sXCJcblxuICB8IDE1IC0+XG4jIDU5IFwiSU8vbGV4ZXIubWxsXCJcbiAgICAgICAgICAgICAgKCBOVU1CRVIgKFV0aWxzLnVpbnQzMl9vZl9zdHIgKExleGluZy5sZXhlbWUgbGV4YnVmKSkgKVxuIyA1MzUgXCJJTy9sZXhlci5tbFwiXG5cbiAgfCAxNiAtPlxuIyA2MCBcIklPL2xleGVyLm1sbFwiXG4gICAgICAgICAgICAgICggSUQgKExleGluZy5sZXhlbWUgbGV4YnVmKSApXG4jIDU0MCBcIklPL2xleGVyLm1sXCJcblxuICB8IDE3IC0+XG4jIDYxIFwiSU8vbGV4ZXIubWxsXCJcbiAgICAgICAgICAgICAgKCByZWFkX3N0cmluZyAoQnVmZmVyLmNyZWF0ZSAxNykgbGV4YnVmIClcbiMgNTQ1IFwiSU8vbGV4ZXIubWxcIlxuXG4gIHwgMTggLT5cbiMgNjIgXCJJTy9sZXhlci5tbGxcIlxuICAgICAgICAgICAgICAoIEVRVUFMIClcbiMgNTUwIFwiSU8vbGV4ZXIubWxcIlxuXG4gIHwgMTkgLT5cbiMgNjMgXCJJTy9sZXhlci5tbGxcIlxuICAgICAgICAgICAgICAoIEhBU0ggKVxuIyA1NTUgXCJJTy9sZXhlci5tbFwiXG5cbiAgfCAyMCAtPlxuIyA2NCBcIklPL2xleGVyLm1sbFwiXG4gICAgICAgICAgICAgICggTEVGVF9CUkFDSyApXG4jIDU2MCBcIklPL2xleGVyLm1sXCJcblxuICB8IDIxIC0+XG4jIDY1IFwiSU8vbGV4ZXIubWxsXCJcbiAgICAgICAgICAgICAgKCBSSUdIVF9CUkFDSyApXG4jIDU2NSBcIklPL2xleGVyLm1sXCJcblxuICB8IDIyIC0+XG4jIDY2IFwiSU8vbGV4ZXIubWxsXCJcbiAgICAgICAgICAgICAgKCBMRUZUX0JSQUNFIClcbiMgNTcwIFwiSU8vbGV4ZXIubWxcIlxuXG4gIHwgMjMgLT5cbiMgNjcgXCJJTy9sZXhlci5tbGxcIlxuICAgICAgICAgICAgICAoIFJJR0hUX0JSQUNFIClcbiMgNTc1IFwiSU8vbGV4ZXIubWxcIlxuXG4gIHwgMjQgLT5cbiMgNjggXCJJTy9sZXhlci5tbGxcIlxuICAgICAgICAgICAgICAoIENPTU1BIClcbiMgNTgwIFwiSU8vbGV4ZXIubWxcIlxuXG4gIHwgMjUgLT5cbiMgNjkgXCJJTy9sZXhlci5tbGxcIlxuICAgICAgICAgICAgICAoIEVYQ0xBTV9NQVJLIClcbiMgNTg1IFwiSU8vbGV4ZXIubWxcIlxuXG4gIHwgMjYgLT5cbiMgNzAgXCJJTy9sZXhlci5tbGxcIlxuICAgICAgICAgICAgICAoIElOVEVSUk9HX01BUksgKVxuIyA1OTAgXCJJTy9sZXhlci5tbFwiXG5cbiAgfCAyNyAtPlxuIyA3MSBcIklPL2xleGVyLm1sbFwiXG4gICAgICAgICAgICAgICggQ09MT04gKVxuIyA1OTUgXCJJTy9sZXhlci5tbFwiXG5cbiAgfCAyOCAtPlxuIyA3MiBcIklPL2xleGVyLm1sbFwiXG4gICAgICAgICAgICAgICggTFBBUkVOIClcbiMgNjAwIFwiSU8vbGV4ZXIubWxcIlxuXG4gIHwgMjkgLT5cbiMgNzMgXCJJTy9sZXhlci5tbGxcIlxuICAgICAgICAgICAgICAoIFJQQVJFTiApXG4jIDYwNSBcIklPL2xleGVyLm1sXCJcblxuICB8IDMwIC0+XG4jIDc0IFwiSU8vbGV4ZXIubWxsXCJcbiAgICAgICAgICAgICAgKCBQTFVTIClcbiMgNjEwIFwiSU8vbGV4ZXIubWxcIlxuXG4gIHwgMzEgLT5cbiMgNzUgXCJJTy9sZXhlci5tbGxcIlxuICAgICAgICAgICAgICAoIE1JTlVTIClcbiMgNjE1IFwiSU8vbGV4ZXIubWxcIlxuXG4gIHwgMzIgLT5cbiMgNzYgXCJJTy9sZXhlci5tbGxcIlxuICAgICAgICAgICAgICAoIFRJTUVTIClcbiMgNjIwIFwiSU8vbGV4ZXIubWxcIlxuXG4gIHwgMzMgLT5cbiMgNzcgXCJJTy9sZXhlci5tbGxcIlxuICAgICAgICAgICAgICAoIERJViApXG4jIDYyNSBcIklPL2xleGVyLm1sXCJcblxuICB8IDM0IC0+XG4jIDc4IFwiSU8vbGV4ZXIubWxsXCJcbiAgICAgICAgICAgICAgKCBNT0QgKVxuIyA2MzAgXCJJTy9sZXhlci5tbFwiXG5cbiAgfCAzNSAtPlxuIyA3OSBcIklPL2xleGVyLm1sbFwiXG4gICAgICAgICAgICAgICggQU5EIClcbiMgNjM1IFwiSU8vbGV4ZXIubWxcIlxuXG4gIHwgMzYgLT5cbiMgODAgXCJJTy9sZXhlci5tbGxcIlxuICAgICAgICAgICAgICAoIE9SIClcbiMgNjQwIFwiSU8vbGV4ZXIubWxcIlxuXG4gIHwgMzcgLT5cbiMgODEgXCJJTy9sZXhlci5tbGxcIlxuICAgICAgICAgICAgICAoIFhPUiApXG4jIDY0NSBcIklPL2xleGVyLm1sXCJcblxuICB8IDM4IC0+XG4jIDgyIFwiSU8vbGV4ZXIubWxsXCJcbiAgICAgICAgICAgICAgKCBOT1QgKVxuIyA2NTAgXCJJTy9sZXhlci5tbFwiXG5cbiAgfCAzOSAtPlxuIyA4MyBcIklPL2xleGVyLm1sbFwiXG4gICAgICAgICAgICAgICggZW9mX3JlYWNoZWQgbGV4YnVmIDsgRU9GIClcbiMgNjU1IFwiSU8vbGV4ZXIubWxcIlxuXG4gIHwgNDAgLT5cbiMgODQgXCJJTy9sZXhlci5tbGxcIlxuICAgICAgKCByYWlzZSAoU3ludGF4RXJyb3IgKFwiVW5leHBlY3RlZCBjaGFyOiBcIiBeIExleGluZy5sZXhlbWUgbGV4YnVmKSkgKVxuIyA2NjAgXCJJTy9sZXhlci5tbFwiXG5cbiAgfCBfX29jYW1sX2xleF9zdGF0ZSAtPiBsZXhidWYuTGV4aW5nLnJlZmlsbF9idWZmIGxleGJ1ZjtcbiAgICAgIF9fb2NhbWxfbGV4X3JlYWRfcmVjIGxleGJ1ZiBfX29jYW1sX2xleF9zdGF0ZVxuXG5hbmQgcmVhZF9zdHJpbmcgYnVmIGxleGJ1ZiA9XG4gICBfX29jYW1sX2xleF9yZWFkX3N0cmluZ19yZWMgYnVmIGxleGJ1ZiA2OFxuYW5kIF9fb2NhbWxfbGV4X3JlYWRfc3RyaW5nX3JlYyBidWYgbGV4YnVmIF9fb2NhbWxfbGV4X3N0YXRlID1cbiAgbWF0Y2ggTGV4aW5nLmVuZ2luZSBfX29jYW1sX2xleF90YWJsZXMgX19vY2FtbF9sZXhfc3RhdGUgbGV4YnVmIHdpdGhcbiAgICAgIHwgMCAtPlxuIyA4NyBcIklPL2xleGVyLm1sbFwiXG4gICAgICAgICAgICAgICggU1RSSU5HIChCdWZmZXIuY29udGVudHMgYnVmKSApXG4jIDY3MiBcIklPL2xleGVyLm1sXCJcblxuICB8IDEgLT5cbiMgODggXCJJTy9sZXhlci5tbGxcIlxuICAgICAgICAgICAgICAoIEJ1ZmZlci5hZGRfY2hhciBidWYgJy8nOyByZWFkX3N0cmluZyBidWYgbGV4YnVmIClcbiMgNjc3IFwiSU8vbGV4ZXIubWxcIlxuXG4gIHwgMiAtPlxuIyA4OSBcIklPL2xleGVyLm1sbFwiXG4gICAgICAgICAgICAgICggQnVmZmVyLmFkZF9jaGFyIGJ1ZiAnXFxcXCc7IHJlYWRfc3RyaW5nIGJ1ZiBsZXhidWYgKVxuIyA2ODIgXCJJTy9sZXhlci5tbFwiXG5cbiAgfCAzIC0+XG4jIDkwIFwiSU8vbGV4ZXIubWxsXCJcbiAgICAgICAgICAgICAgKCBCdWZmZXIuYWRkX2NoYXIgYnVmICdcXGInOyByZWFkX3N0cmluZyBidWYgbGV4YnVmIClcbiMgNjg3IFwiSU8vbGV4ZXIubWxcIlxuXG4gIHwgNCAtPlxuIyA5MSBcIklPL2xleGVyLm1sbFwiXG4gICAgICAgICAgICAgICggQnVmZmVyLmFkZF9jaGFyIGJ1ZiAnXFwwMTInOyByZWFkX3N0cmluZyBidWYgbGV4YnVmIClcbiMgNjkyIFwiSU8vbGV4ZXIubWxcIlxuXG4gIHwgNSAtPlxuIyA5MiBcIklPL2xleGVyLm1sbFwiXG4gICAgICAgICAgICAgICggQnVmZmVyLmFkZF9jaGFyIGJ1ZiAnXFxuJzsgcmVhZF9zdHJpbmcgYnVmIGxleGJ1ZiApXG4jIDY5NyBcIklPL2xleGVyLm1sXCJcblxuICB8IDYgLT5cbiMgOTMgXCJJTy9sZXhlci5tbGxcIlxuICAgICAgICAgICAgICAoIEJ1ZmZlci5hZGRfY2hhciBidWYgJ1xccic7IHJlYWRfc3RyaW5nIGJ1ZiBsZXhidWYgKVxuIyA3MDIgXCJJTy9sZXhlci5tbFwiXG5cbiAgfCA3IC0+XG4jIDk0IFwiSU8vbGV4ZXIubWxsXCJcbiAgICAgICAgICAgICAgKCBCdWZmZXIuYWRkX2NoYXIgYnVmICdcXHQnOyByZWFkX3N0cmluZyBidWYgbGV4YnVmIClcbiMgNzA3IFwiSU8vbGV4ZXIubWxcIlxuXG4gIHwgOCAtPlxuIyA5NiBcIklPL2xleGVyLm1sbFwiXG4gICAgKCBCdWZmZXIuYWRkX3N0cmluZyBidWYgKExleGluZy5sZXhlbWUgbGV4YnVmKTtcbiAgICAgIHJlYWRfc3RyaW5nIGJ1ZiBsZXhidWZcbiAgICApXG4jIDcxNCBcIklPL2xleGVyLm1sXCJcblxuICB8IDkgLT5cbiMgOTkgXCJJTy9sZXhlci5tbGxcIlxuICAgICAgICAgICAgKCByYWlzZSAoU3ludGF4RXJyb3IgKFwiU3RyaW5nIGNhbm5vdCBiZSBtdWx0aWxpbmVcIikpIClcbiMgNzE5IFwiSU8vbGV4ZXIubWxcIlxuXG4gIHwgMTAgLT5cbiMgMTAwIFwiSU8vbGV4ZXIubWxsXCJcbiAgICAgICAgKCByYWlzZSAoU3ludGF4RXJyb3IgKFwiU3RyaW5nIGlzIG5vdCB0ZXJtaW5hdGVkXCIpKSApXG4jIDcyNCBcIklPL2xleGVyLm1sXCJcblxuICB8IDExIC0+XG4jIDEwMSBcIklPL2xleGVyLm1sbFwiXG4gICAgICAoIHJhaXNlIChTeW50YXhFcnJvciAoXCJJbGxlZ2FsIHN0cmluZyBjaGFyYWN0ZXI6IFwiIF4gTGV4aW5nLmxleGVtZSBsZXhidWYpKSApXG4jIDcyOSBcIklPL2xleGVyLm1sXCJcblxuICB8IF9fb2NhbWxfbGV4X3N0YXRlIC0+IGxleGJ1Zi5MZXhpbmcucmVmaWxsX2J1ZmYgbGV4YnVmO1xuICAgICAgX19vY2FtbF9sZXhfcmVhZF9zdHJpbmdfcmVjIGJ1ZiBsZXhidWYgX19vY2FtbF9sZXhfc3RhdGVcblxuYW5kIHJlYWRfY29tbWVudCBsZXhidWYgPVxuICAgX19vY2FtbF9sZXhfcmVhZF9jb21tZW50X3JlYyBsZXhidWYgODJcbmFuZCBfX29jYW1sX2xleF9yZWFkX2NvbW1lbnRfcmVjIGxleGJ1ZiBfX29jYW1sX2xleF9zdGF0ZSA9XG4gIG1hdGNoIExleGluZy5lbmdpbmUgX19vY2FtbF9sZXhfdGFibGVzIF9fb2NhbWxfbGV4X3N0YXRlIGxleGJ1ZiB3aXRoXG4gICAgICB8IDAgLT5cbiMgMTA0IFwiSU8vbGV4ZXIubWxsXCJcbiAgICAgICAgICAgICggbmV4dF9saW5lIGxleGJ1ZiA7IEVPTCApXG4jIDc0MSBcIklPL2xleGVyLm1sXCJcblxuICB8IDEgLT5cbiMgMTA1IFwiSU8vbGV4ZXIubWxsXCJcbiAgICAgICAgKCBlb2ZfcmVhY2hlZCBsZXhidWYgOyBFT0YgKVxuIyA3NDYgXCJJTy9sZXhlci5tbFwiXG5cbiAgfCAyIC0+XG4jIDEwNiBcIklPL2xleGVyLm1sbFwiXG4gICAgICAoIHJlYWRfY29tbWVudCBsZXhidWYgKVxuIyA3NTEgXCJJTy9sZXhlci5tbFwiXG5cbiAgfCBfX29jYW1sX2xleF9zdGF0ZSAtPiBsZXhidWYuTGV4aW5nLnJlZmlsbF9idWZmIGxleGJ1ZjtcbiAgICAgIF9fb2NhbWxfbGV4X3JlYWRfY29tbWVudF9yZWMgbGV4YnVmIF9fb2NhbWxfbGV4X3N0YXRlXG5cbjs7XG5cbiIsIlxuZXhjZXB0aW9uIEJveEZpdHRpbmdFcnJvciBvZiBzdHJpbmdcblxubGV0IGRlZmF1bHRfZmlsbGVycyA9XG4gIFt8XG4gICAgWzB4RkYgOyAweDAwIDsgMHgwMCA7IDB4MDBdKCogMDAwMDAwRkYgKikgO1xuICAgIFsweDAwIDsgMHhGRiA7IDB4MDAgOyAweDAwXSgqIDAwMDBGRjAwICopIDtcbiAgICBbMHgwMCA7IDB4MDAgOyAweEZGIDsgMHgwMF0oKiAwMEZGMDAwMCAqKSA7XG4gICAgWzB4MDAgOyAweDAwIDsgMHgwMCA7IDB4RkZdKCogRkYwMDAwMDAgKikgO1xuICB8XVxuXG5sZXQgbm9wX2NvZGUgPSBbMHgwMCA7IDB4MDAgOyAweDAwIDsgMHgwMF0gKCogMDAwMDAwMDAgOiBhbmRlcSByMCwgcjAsIHIwICopXG5sZXQgbm9wX2NvZGUyID0gWzB4MDAgOyAweDAwIDsgMHgwMCA7IDB4QjBdICgqIEIwMDAwMDAwIDogYW5kbHQgcjAsIHIwLCByMCAqKVxuXG5sZXQgbmFtZV9zaXplID0gOFxubGV0IG5iX2JveGVzID0gMTRcblxubGV0IGVvZiA9IE5hbWUuZW9mXG5cbmxldCBub19lb2YgY29kZXMgPVxuICBMaXN0LmZvcl9hbGwgKGZ1biBjIC0+IGMgPD4gZW9mKSBjb2Rlc1xuXG5sZXQgcmVjIG9ubHlfY29uc2VjdXRpdmVfZW9mIGNvZGVzID1cbiAgbWF0Y2ggY29kZXMgd2l0aFxuICB8IFtdIC0+IHRydWVcbiAgfCBjOjpjb2RlcyB3aGVuIGMgPD4gZW9mIC0+IG9ubHlfY29uc2VjdXRpdmVfZW9mIGNvZGVzXG4gIHwgXzo6Yyc6OmNvZGVzIHdoZW4gYycgPSBlb2YgLT4gb25seV9jb25zZWN1dGl2ZV9lb2YgKGMnOjpjb2RlcylcbiAgfCBfOjpjb2RlcyAtPiBub19lb2YgY29kZXNcblxubGV0IGxhc3RfZW9mX2luZGV4IGNvZGVzID1cbiAgbGV0IG4gPSBMaXN0Lmxlbmd0aCBjb2RlcyBpblxuICBsZXQgY29kZXMgPSBMaXN0LnJldiBjb2RlcyBpblxuICBsZXQgcmVjIGF1eCBhY2MgY29kZXMgPVxuICAgIG1hdGNoIGNvZGVzIHdpdGhcbiAgICB8IFtdIC0+IGFzc2VydCBmYWxzZVxuICAgIHwgYzo6XyB3aGVuIGMgPSBlb2YgLT4gYWNjXG4gICAgfCBfOjpjb2RlcyAtPiBhdXggKGFjYysxKSBjb2Rlc1xuICBpblxuICBuIC0gMSAtIChhdXggMCBjb2RlcylcblxubGV0IGZpcnN0X25vbl9lb2ZfaW5kZXggY29kZXMgPVxuICBsZXQgcmVjIGF1eCBhY2MgY29kZXMgPVxuICAgIG1hdGNoIGNvZGVzIHdpdGhcbiAgICB8IGM6OmNvZGVzIHdoZW4gYyA9IGVvZiAtPiBhdXggKGFjYysxKSBjb2Rlc1xuICAgIHwgXyAtPiBhY2NcbiAgaW5cbiAgYXV4IDAgY29kZXNcblxubGV0IHBhZCBmaWxsZXJzIHBvcyA9XG4gIGxldCBwb3MgPSBwb3MgbW9kIChuYW1lX3NpemUrMSkgaW5cbiAgbGV0IG4gPSBMaXN0Lmxlbmd0aCBub3BfY29kZSBpblxuICBpZiBwb3MgKyBuIDw9IG5hbWVfc2l6ZVxuICB0aGVuIG5vcF9jb2RlXG4gIGVsc2UgZmlsbGVycy4obmFtZV9zaXplLXBvcylcblxubGV0IHJlYyBwYWRfbmIgZmlsbGVycyBwb3MgbmIgPVxuICBpZiBuYiA8IDAgdGhlbiBmYWlsd2l0aCBcIkludmFsaWQgc3RhcnRpbmcgcG9zaXRpb24uXCJcbiAgZWxzZSBpZiBuYiA9IDAgdGhlbiBbXVxuICBlbHNlXG4gICAgbGV0IGNvZGUgPSBwYWQgZmlsbGVycyBwb3MgaW5cbiAgICBsZXQgbSA9IExpc3QubGVuZ3RoIGNvZGUgaW5cbiAgICBjb2RlQChwYWRfbmIgZmlsbGVycyAocG9zICsgbSkgKG5iIC0gbSkpXG5cbmxldCByZWMgZml0X2NvZGVfYXRfcG9zID8obmV4dD1Tb21lIFtdKSBmaWxsZXJzIHBvcyBjb2RlcyA9XG4gIGxldCBwb3MgPSBwb3MgbW9kIChuYW1lX3NpemUrMSkgaW5cbiAgbGV0IG4gPSBMaXN0Lmxlbmd0aCBjb2RlcyBpblxuICBsZXQgaXNfb2tfaGVyZSA9XG4gICAgaWYgbm9fZW9mIGNvZGVzXG4gICAgdGhlbiBwb3MgKyBuIDw9IG5hbWVfc2l6ZVxuICAgIGVsc2UgaWYgb25seV9jb25zZWN1dGl2ZV9lb2YgY29kZXNcbiAgICB0aGVuXG4gICAgICBsZXQgaSA9IGxhc3RfZW9mX2luZGV4IGNvZGVzIGluXG4gICAgICBsZXQgaiA9IG1hdGNoIG5leHQgd2l0aCBTb21lIG5leHQgLT4gZmlyc3Rfbm9uX2VvZl9pbmRleCBuZXh0IHwgTm9uZSAtPiAwIGluXG4gICAgICAocG9zK2kgPSBuYW1lX3NpemUpIHx8XG4gICAgICAoaSA9IG4tMSAmJiBwb3MraSsxID0gbmFtZV9zaXplKSB8fCAoKiBGb2xsb3dlZCBieSBmaWxsZXIgY29kZSAqKVxuICAgICAgKGkgPSBuLTEgJiYgcG9zK2kraiA9IG5hbWVfc2l6ZSkgfHwgKCogRm9sbG93ZWQgYnkgbmV4dCBjb2RlICopXG4gICAgICAobmV4dCA9IE5vbmUgJiYgaSA9IG4tMSAmJiBwb3MraSA8PSBuYW1lX3NpemUpICgqIE5vdGhpbmcgYWZ0ZXIgKilcbiAgICBlbHNlIHJhaXNlIChCb3hGaXR0aW5nRXJyb3JcbiAgICBcIlNvbWUgY29kZXMgY2Fubm90IGJlIHBvc2l0aW9ubmVkIGR1ZSB0byBub24tY29uc2VjdXRpdmUgMHhGRiBieXRlcy5cIilcbiAgaW5cbiAgaWYgaXNfb2tfaGVyZSB0aGVuIGNvZGVzXG4gIGVsc2UgYmVnaW5cbiAgICBsZXQgbm9wX2NvZGUgPVxuICAgICAgaWYgcG9zICsgbiA8PSBuYW1lX3NpemUgdGhlbiBub3BfY29kZVxuICAgICAgZWxzZSBmaWxsZXJzLihuYW1lX3NpemUtcG9zKVxuICAgIGluXG4gICAgbGV0IG0gPSBMaXN0Lmxlbmd0aCBub3BfY29kZSBpblxuICAgIG5vcF9jb2RlQChmaXRfY29kZV9hdF9wb3Mgfm5leHQgZmlsbGVycyAocG9zICsgbSkgY29kZXMpXG4gIGVuZFxuXG5sZXQgYWRkX2NvZGVzX2FmdGVyID8oZmluYWw9ZmFsc2UpIGZpbGxlcnMgcmVzIGNvZGVzID1cbiAgbGV0IHJlYyBhdXggYWNjIGNvZGVzID1cbiAgICBtYXRjaCBjb2RlcyB3aXRoXG4gICAgfCBbXSAtPiBhY2NcbiAgICB8IFtjb2Rlc10gLT5cbiAgICAgIGxldCBuZXh0ID0gaWYgZmluYWwgdGhlbiBOb25lIGVsc2UgU29tZSBbXSBpblxuICAgICAgYWNjQChmaXRfY29kZV9hdF9wb3Mgfm5leHQgZmlsbGVycyAoTGlzdC5sZW5ndGggYWNjKSBjb2RlcylcbiAgICB8IGMxOjpjMjo6Y29kZXMgLT5cbiAgICAgIGxldCBuYyA9IGZpdF9jb2RlX2F0X3BvcyB+bmV4dDooU29tZSBjMikgZmlsbGVycyAoTGlzdC5sZW5ndGggYWNjKSBjMSBpblxuICAgICAgYXV4IChhY2NAbmMpIChjMjo6Y29kZXMpXG4gIGluXG4gIGF1eCByZXMgY29kZXNcblxubGV0IG1vZHVsbyB4IHkgPVxuICBsZXQgcmVzdWx0ID0geCBtb2QgeSBpblxuICBpZiByZXN1bHQgPj0gMCB0aGVuIHJlc3VsdFxuICBlbHNlIHJlc3VsdCArIHlcblxubGV0IHNwbGl0X3Jhd19pbnRvX2JveGVzID8oZmlsbF9sYXN0PWZhbHNlKSByYXcgPVxuICBsZXQgcmVjIHNwbGl0IGZpbmlzaGVkIGN1cnJlbnQgY29kZXMgaSA9XG4gICAgbWF0Y2ggY29kZXMgd2l0aFxuICAgIHwgW10gLT5cbiAgICAgIGlmIGkgPD4gMFxuICAgICAgdGhlbiBiZWdpblxuICAgICAgICBsZXQgY3VycmVudCA9XG4gICAgICAgICAgbGV0IG4gPSBMaXN0Lmxlbmd0aCBjdXJyZW50IGluXG4gICAgICAgICAgaWYgZmlsbF9sYXN0ICYmIG4gPSBpICgqIElmIGN1cnJlbnQgYm94IGRvZXMgbm90IGVuZCBieSAweEZGICopXG4gICAgICAgICAgdGhlbiAoTGlzdC5pbml0IChuYW1lX3NpemUtbikgKGZ1biBfIC0+IE5hbWUuc3BhY2UpKUBjdXJyZW50XG4gICAgICAgICAgZWxzZSBjdXJyZW50XG4gICAgICAgIGluXG4gICAgICAgIGN1cnJlbnQ6OmZpbmlzaGVkXG4gICAgICBlbmQgZWxzZSBmaW5pc2hlZFxuICAgIHwgYzo6Y29kZXMgd2hlbiBpID0gbmFtZV9zaXplIC0+XG4gICAgICBpZiBjIDw+IGVvZlxuICAgICAgdGhlbiByYWlzZSAoQm94Rml0dGluZ0Vycm9yXG4gICAgICBcIlJlc3VsdCBpcyBpbmNvbnNpc3RlbnQuIFBsZWFzZSBjaGVjayB0aGUgZmlsbGVycy5cIikgO1xuICAgICAgc3BsaXQgKGN1cnJlbnQ6OmZpbmlzaGVkKSBbXSBjb2RlcyAwXG4gICAgfCBjOjpjb2RlcyB3aGVuIGMgPSBlb2YgLT5cbiAgICAgIHNwbGl0IGZpbmlzaGVkIGN1cnJlbnQgY29kZXMgKGkrMSlcbiAgICB8IGM6OmNvZGVzIC0+XG4gICAgICBpZiBMaXN0Lmxlbmd0aCBjdXJyZW50IDw+IGlcbiAgICAgIHRoZW4gcmFpc2UgKEJveEZpdHRpbmdFcnJvclxuICAgICAgXCJSZXN1bHQgaXMgaW5jb25zaXN0ZW50LiBQbGVhc2UgY2hlY2sgdGhlIGZpbGxlcnMuXCIpIDtcbiAgICAgIHNwbGl0IGZpbmlzaGVkIChjOjpjdXJyZW50KSBjb2RlcyAoaSsxKVxuICBpblxuICBzcGxpdCBbXSBbXSByYXcgMCB8PlxuICBMaXN0Lm1hcCBMaXN0LnJldiB8PlxuICBMaXN0LnJldlxuXG5sZXQgZml0X2NvZGVzX2ludG9fYm94ZXMgPyhmaWxsX2xhc3Q9dHJ1ZSkgPyhmaWxsZXJzPWRlZmF1bHRfZmlsbGVycykgPyhzdGFydD0wKSA/KGV4aXQ9Tm9uZSkgY29kZXMgPVxuICAoKiBNYWluIGNvZGUgKilcbiAgbGV0IHBhZGRpbmcgPSBwYWRfbmIgZmlsbGVycyAwIHN0YXJ0IGluXG4gIGxldCByZXMgPVxuICAgIGFkZF9jb2Rlc19hZnRlciB+ZmluYWw6KGV4aXQgPSBOb25lKSBmaWxsZXJzIHBhZGRpbmcgY29kZXMgaW5cbiAgKCogQWRkIGV4aXQgY29kZSAqKVxuICBsZXQgcmVzID1cbiAgICBtYXRjaCBleGl0IHdpdGhcbiAgICB8IE5vbmUgLT4gcmVzXG4gICAgfCBTb21lIGV4aXQgLT5cbiAgICAgIGxldCBpID0gTGlzdC5sZW5ndGggcmVzIGluXG4gICAgICBsZXQgKGosZWNvZGUpID0gRXhpdC5nZXRfcHJlZmVycmVkIGV4aXQgaSBpblxuICAgICAgbGV0IHBhZGRpbmcgPSBwYWRfbmIgZmlsbGVycyBpIChqLWkpIGluXG4gICAgICBsZXQgcmVzID0gcmVzQHBhZGRpbmcgaW5cbiAgICAgIGFkZF9jb2Rlc19hZnRlciB+ZmluYWw6dHJ1ZSBmaWxsZXJzIHJlcyBlY29kZVxuICBpblxuICAoKiBTcGxpdCBieSBib3ggKilcbiAgbGV0IHJlcyA9IHNwbGl0X3Jhd19pbnRvX2JveGVzIH5maWxsX2xhc3QgcmVzIGluXG4gICgqIElmIGEgYm94IGlzIGZ1bGwgb2Ygc3BhY2VzLi4uICopXG4gIHJlcyB8PiBMaXN0Lm1hcGkgKGZ1biBpIGxzdCAtPlxuICAgIGlmIE5hbWUuaXNfZnVsbF9vZl9zcGFjZXMgbHN0XG4gICAgdGhlblxuICAgICAgbGV0IG0gPSBMaXN0Lmxlbmd0aCBub3BfY29kZTIgaW5cbiAgICAgIGxldCBwb3MgPSBtb2R1bG8gKC1pKihuYW1lX3NpemUrMSkpIG0gaW5cbiAgICAgIGxldCBwcmVmaXggPSBMaXN0LmluaXQgcG9zIChmdW4gXyAtPiBOYW1lLnNwYWNlKSBpblxuICAgICAgbGV0IHN1ZmZpeF9sZW4gPSAoTGlzdC5sZW5ndGggbHN0KS1wb3MtbSBpblxuICAgICAgaWYgc3VmZml4X2xlbiA8IDAgdGhlbiBsc3RcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IHN1ZmZpeCA9IExpc3QuaW5pdCBzdWZmaXhfbGVuIChmdW4gXyAtPiBOYW1lLnNwYWNlKSBpblxuICAgICAgICBMaXN0LmNvbmNhdCBbcHJlZml4IDsgbm9wX2NvZGUyIDsgc3VmZml4XVxuICAgIGVsc2UgbHN0XG4gIClcblxubGV0IHBwX2JveGVzX25hbWVzIGZtdCBsc3QgPVxuICBsZXQgcHBfYm94IGkgY29kZXMgPVxuICAgIGxldCBjaGFycyA9IE5hbWUuY29kZXNfdG9fY2hhcnMgY29kZXMgaW5cbiAgICBGb3JtYXQuZnByaW50ZiBmbXQgXCJCb3ggJTJpOiAlYVxcdFslYV1ALlwiIChpKzEpXG4gICAgICBOYW1lLnBwX2NoYXJzIGNoYXJzIE5hbWUucHBfY2hhcnNfcmF3IGNoYXJzXG4gIGluXG4gIExpc3QuaXRlcmkgcHBfYm94IGxzdFxuXG5sZXQgcHBfYm94X3JhdyBmbXQgbHN0ID1cbiAgbGV0IHBhZCA9XG4gICAgTGlzdC5pbml0IChuYW1lX3NpemUrMS0oTGlzdC5sZW5ndGggbHN0KSkgKGZ1biBfIC0+IGVvZikgaW5cbiAgbHN0QHBhZCB8PiBMaXN0Lml0ZXIgKEZvcm1hdC5mcHJpbnRmIGZtdCBcIiUwMlggQD9cIilcbiIsIlxubGV0IGVudW1lcmF0ZV9maWxlcyBkaXJuYW1lIGV4dCA9XG4gIFN5cy5yZWFkZGlyIGRpcm5hbWVcbiAgfD4gQXJyYXkudG9fbGlzdFxuICB8PiBMaXN0LmZpbHRlciAoZnVuIHggLT4gRmlsZW5hbWUuZXh0ZW5zaW9uIHggPSBleHQpXG5cbmxldCB1aW50MzJfb2Zfc3RyIHN0ciA9XG4gIGxldCBzdHIgPSBTdHJpbmcubG93ZXJjYXNlX2FzY2lpIHN0ciBpblxuICAoKiBJc3N1ZSB3aXRoIGpzX29mX29jYW1sLi4uICopXG4gICgqXG4gIGlmIFN0ci5zdHJpbmdfbWF0Y2ggKFN0ci5yZWdleHAgXCJbMC05XSskXCIpIHN0ciAwXG4gIHRoZW4gSW50MzIub2Zfc3RyaW5nIChcIjB1XCJec3RyKVxuICBlbHNlIEludDMyLm9mX3N0cmluZyBzdHJcbiAgKilcbiAgbGV0IGk2NCA9IEludDY0Lm9mX3N0cmluZyBzdHIgaW5cbiAgaWYgSW50NjQubG9nYW5kIDB4RkZGRkZGRkYwMDAwMDAwMEwgaTY0IHw+IEludDY0LmVxdWFsIEludDY0Lnplcm9cbiAgdGhlbiBJbnQ2NC50b19pbnQzMiBpNjRcbiAgZWxzZSByYWlzZSAoRmFpbHVyZSBcIk5vdCBhIHZhbGlkIGludDMyLlwiKVxuXG5sZXQgdWludDMyX3RvX2ludCB2ID1cbiAgbWF0Y2ggSW50MzIudW5zaWduZWRfdG9faW50IHYgd2l0aCBOb25lIC0+IGFzc2VydCBmYWxzZSB8IFNvbWUgaSAtPiBpXG5cbmxldCBpbnQ2NF9vZl91aW50MzIgeCA9XG4gIEludDY0Lm9mX2ludDMyIHggfD4gSW50NjQubG9nYW5kIDB4RkZGRkZGRkZMXG5cbmxldCBkdW1teV9mbXQgPVxuICBGb3JtYXQubWFrZV9mb3JtYXR0ZXIgKGZ1biBfIF8gXyAtPiAoKSkgKGZ1biBfIC0+ICgpKVxuXG5sZXQgY29uY2F0X3N0cmluZ3MgbHN0ID1cbiAgbGV0IHBwIGZtdCBsc3QgPVxuICAgIGxzdCB8PiBMaXN0Lml0ZXIgKGZ1biBzdHIgLT4gRm9ybWF0LmZwcmludGYgZm10IFwiJXNcIiBzdHIpXG4gIGluXG4gIEZvcm1hdC5hc3ByaW50ZiBcIiVhXCIgcHAgbHN0Iiwib3BlbiBJbnQzMlxuXG50eXBlIHBva2Vtb24gPSB7IHBpZDppbnQzMiA7IG90aWQ6aW50MzIgfVxuXG5sZXQgaW50MzJfZnJvbV9sb3dfaGlnaCBsIGggPVxuICBsb2dvciBsIChzaGlmdF9sZWZ0IGggMTYpXG5cbmxldCBtYXNrMTYgPSAweEZGRkYgfD4gb2ZfaW50XG5sZXQgaW50MzJfdG9fbG93X2hpZ2ggaSA9XG4gIGxldCBsID0gbG9nYW5kIG1hc2sxNiBpIGluXG4gIGxldCBoID0gc2hpZnRfcmlnaHRfbG9naWNhbCBpIDE2IGluXG4gIChsLCBoKVxuXG5sZXQgZGF0YV9vZmZzZXQgPSAzMlxubGV0IHN1YnN0cnVjdHVyZV9zaXplID0gMTJcbmxldCBkYXRhX3NpemUgPSBzdWJzdHJ1Y3R1cmVfc2l6ZSAqIDRcbmxldCBwaWRfb2Zmc2V0ID0gMFxubGV0IG90aWRfb2Zmc2V0ID0gNFxubGV0IGNoZWNrc3VtX29mZnNldCA9IDI4XG5cbmxldCBkZWNyeXB0aW9uX2tleSB7IHBpZCA7IG90aWQgOyBfIH0gPSBsb2d4b3IgcGlkIG90aWRcblxubGV0IHN1YnN0cnVjdHVyZXNfb3JkZXIgPSBbfFxuICBcIkdBRU1cIiA7IFwiR0FNRVwiIDsgXCJHRUFNXCIgOyBcIkdFTUFcIiA7IFwiR01BRVwiIDsgXCJHTUVBXCIgO1xuICBcIkFHRU1cIiA7IFwiQUdNRVwiIDsgXCJBRUdNXCIgOyBcIkFFTUdcIiA7IFwiQU1HRVwiIDsgXCJBTUVHXCIgO1xuICBcIkVHQU1cIiA7IFwiRUdNQVwiIDsgXCJFQUdNXCIgOyBcIkVBTUdcIiA7IFwiRU1HQVwiIDsgXCJFTUFHXCIgO1xuICBcIk1HQUVcIiA7IFwiTUdFQVwiIDsgXCJNQUdFXCIgOyBcIk1BRUdcIiA7IFwiTUVHQVwiIDsgXCJNRUFHXCIgO1xufF1cblxubGV0IHBrbW5fZnJvbV9ieXRlcyBidWYgPVxuICBsZXQgcGlkID0gQnl0ZXMuZ2V0X2ludDMyX2xlIGJ1ZiBwaWRfb2Zmc2V0IGluXG4gIGxldCBvdGlkID0gQnl0ZXMuZ2V0X2ludDMyX2xlIGJ1ZiBvdGlkX29mZnNldCBpblxuICB7IHBpZCA7IG90aWQgfVxuXG5sZXQgc3Vic3RydWN0dXJlX3Bvc2l0aW9uIHsgcGlkIDsgXyB9IHNzID1cbiAgbGV0IGkgPSB1bnNpZ25lZF9yZW0gcGlkIChvZl9pbnQgMjQpIHw+IFV0aWxzLnVpbnQzMl90b19pbnQgaW5cbiAgbGV0IG9yZGVyID0gc3Vic3RydWN0dXJlc19vcmRlci4oaSkgaW5cbiAgbGV0IHJlYyBhdXggaSA9XG4gICAgaWYgb3JkZXIuW2ldID0gc3MgdGhlbiBpIGVsc2UgYXV4IChpKzEpXG4gIGluXG4gIGF1eCAwXG5cbmxldCBzdWJzdHJ1Y3R1cmVfb2Zmc2V0IHBrbW4gc3MgPVxuICBsZXQgcCA9IHN1YnN0cnVjdHVyZV9wb3NpdGlvbiBwa21uIHNzIGluXG4gIGRhdGFfb2Zmc2V0ICsgc3Vic3RydWN0dXJlX3NpemUqcFxuXG4oKiBMb2NhbCBvcGVyYXRpb25zICopXG5cbmxldCBkZWNyeXB0X2FsaWduZWRfaW50MzIgcGttbiBpID1cbiAgbGV0IGtleSA9IGRlY3J5cHRpb25fa2V5IHBrbW4gaW5cbiAgbG9neG9yIGkga2V5XG5cbmxldCBlbmNyeXB0X2FsaWduZWRfaW50MzIgPSBkZWNyeXB0X2FsaWduZWRfaW50MzJcblxubGV0IGNoZWNrc3VtX2RpZmZfZm9yX2FsaWduZWRfaW50MzIgbyBuID1cbiAgbGV0IChsbywgaG8pID0gaW50MzJfdG9fbG93X2hpZ2ggbyBpblxuICBsZXQgKGxuLCBobikgPSBpbnQzMl90b19sb3dfaGlnaCBuIGluXG4gIGxldCBkaWZmID0gYWRkIChzdWIgbG4gbG8pIChzdWIgaG4gaG8pIGluXG4gIGxvZ2FuZCBkaWZmIG1hc2sxNlxuXG4oKiBHbG9iYWwgb3BlcmF0aW9ucyAqKVxuXG5sZXQgZW5jX2RlYyBwa21uIGJ1ZiBzdGFydCBsZW4gPVxuICBsZXQgcmVjIGVuY19kZWNfZnJvbSBvZmZzZXQgPSBcbiAgICBpZiBvZmZzZXQgPj0gc3RhcnQgKyBsZW4gdGhlbiAoKVxuICAgIGVsc2UgKFxuICAgICAgbGV0IGkgPSBCeXRlcy5nZXRfaW50MzJfbGUgYnVmIG9mZnNldCBpblxuICAgICAgbGV0IGkgPSBlbmNyeXB0X2FsaWduZWRfaW50MzIgcGttbiBpIGluXG4gICAgICBCeXRlcy5zZXRfaW50MzJfbGUgYnVmIG9mZnNldCBpIDtcbiAgICAgIGVuY19kZWNfZnJvbSAob2Zmc2V0ICsgNClcbiAgICApXG4gIGluXG4gIGVuY19kZWNfZnJvbSBzdGFydFxuXG5sZXQgZXh0cmFjdF9kYXRhIGJ1ZiA9XG4gIGxldCBwa21uID0gcGttbl9mcm9tX2J5dGVzIGJ1ZiBpblxuICBsZXQgcmVzID0gQnl0ZXMuc3ViIGJ1ZiBkYXRhX29mZnNldCBkYXRhX3NpemUgaW5cbiAgZW5jX2RlYyBwa21uIHJlcyAwIGRhdGFfc2l6ZSA7XG4gIHJlc1xuXG5sZXQgY29tcHV0ZV9jaGVja3N1bSBidWYgc3RhcnQgbGVuID1cbiAgbGV0IHJlYyBhdXggYWNjIGkgPVxuICAgIGlmIGkgPj0gc3RhcnQrbGVuXG4gICAgdGhlbiBhY2NcbiAgICBlbHNlXG4gICAgICBsZXQgbmIgPSBCeXRlcy5nZXRfdWludDE2X2xlIGJ1ZiBpIHw+IEludDMyLm9mX2ludCBpblxuICAgICAgYXV4IChJbnQzMi5hZGQgYWNjIG5iKSAoaSsyKVxuICBpblxuICBsZXQgc3VtID0gYXV4IEludDMyLnplcm8gc3RhcnQgaW5cbiAgbGV0IGxvdyA9IEludDMyLmxvZ2FuZCBzdW0gbWFzazE2IGluXG4gIGxvdyB8PiBVdGlscy51aW50MzJfdG9faW50XG5cbmxldCB1cGRhdGVfd2l0aF9kYXRhIGJ1ZiBkYXRhID1cbiAgbGV0IHBrbW4gPSBwa21uX2Zyb21fYnl0ZXMgYnVmIGluXG4gIGxldCBjaGVja3N1bSA9IGNvbXB1dGVfY2hlY2tzdW0gZGF0YSAwIGRhdGFfc2l6ZSBpblxuICBCeXRlcy5ibGl0IGRhdGEgMCBidWYgZGF0YV9vZmZzZXQgZGF0YV9zaXplIDtcbiAgZW5jX2RlYyBwa21uIGJ1ZiBkYXRhX29mZnNldCBkYXRhX3NpemUgO1xuICBCeXRlcy5zZXRfdWludDE2X2xlIGJ1ZiBjaGVja3N1bV9vZmZzZXQgY2hlY2tzdW1cblxuKCogU3BlY2llcyAqKVxuXG5sZXQgc3BlY2llc19vZmZzZXQgcGttbiA9XG4gIChzdWJzdHJ1Y3R1cmVfb2Zmc2V0IHBrbW4gJ0cnKVxuXG5sZXQgc3BlY2llc19vZmZzZXRfcmVsYXRpdmVfdG9fZGF0YSBwa21uID1cbiAgKHN1YnN0cnVjdHVyZV9vZmZzZXQgcGttbiAnRycpIC0gZGF0YV9vZmZzZXRcblxuKCogSVZzICopXG5cbmxldCBpdmVhX29mZnNldCBwa21uID1cbiAgKHN1YnN0cnVjdHVyZV9vZmZzZXQgcGttbiAnTScpICsgNFxuXG5sZXQgbWFzazUgPSAwYjExMTExIHw+IG9mX2ludFxuXG5sZXQgaXZlYV9kYXRhX3RvX2l2cyBkYXRhID1cbiAgbGV0IGhwID0gbG9nYW5kIG1hc2s1IGRhdGEgaW5cbiAgbGV0IGRhdGEgPSBzaGlmdF9yaWdodF9sb2dpY2FsIGRhdGEgNSBpblxuICBsZXQgYXRrID0gbG9nYW5kIG1hc2s1IGRhdGEgaW5cbiAgbGV0IGRhdGEgPSBzaGlmdF9yaWdodF9sb2dpY2FsIGRhdGEgNSBpblxuICBsZXQgZGVmID0gbG9nYW5kIG1hc2s1IGRhdGEgaW5cbiAgbGV0IGRhdGEgPSBzaGlmdF9yaWdodF9sb2dpY2FsIGRhdGEgNSBpblxuICBsZXQgc3BlZWQgPSBsb2dhbmQgbWFzazUgZGF0YSBpblxuICBsZXQgZGF0YSA9IHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgZGF0YSA1IGluXG4gIGxldCBzcF9hdGsgPSBsb2dhbmQgbWFzazUgZGF0YSBpblxuICBsZXQgZGF0YSA9IHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgZGF0YSA1IGluXG4gIGxldCBzcF9kZWYgPSBsb2dhbmQgbWFzazUgZGF0YSBpblxuICBsZXQgZGF0YSA9IHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgZGF0YSA1IGluXG4gIChocCxhdGssZGVmLHNwZWVkLHNwX2F0ayxzcF9kZWYsZGF0YSlcblxubGV0IGl2c190b19pdmVhX2RhdGEgKGhwLGF0ayxkZWYsc3BlZWQsc3BfYXRrLHNwX2RlZixkYXRhKSA9XG4gIGxldCBkYXRhID0gc2hpZnRfbGVmdCBkYXRhIDUgaW5cbiAgbGV0IGRhdGEgPSBsb2dvciBkYXRhIHNwX2RlZiBpblxuICBsZXQgZGF0YSA9IHNoaWZ0X2xlZnQgZGF0YSA1IGluXG4gIGxldCBkYXRhID0gbG9nb3IgZGF0YSBzcF9hdGsgaW5cbiAgbGV0IGRhdGEgPSBzaGlmdF9sZWZ0IGRhdGEgNSBpblxuICBsZXQgZGF0YSA9IGxvZ29yIGRhdGEgc3BlZWQgaW5cbiAgbGV0IGRhdGEgPSBzaGlmdF9sZWZ0IGRhdGEgNSBpblxuICBsZXQgZGF0YSA9IGxvZ29yIGRhdGEgZGVmIGluXG4gIGxldCBkYXRhID0gc2hpZnRfbGVmdCBkYXRhIDUgaW5cbiAgbGV0IGRhdGEgPSBsb2dvciBkYXRhIGF0ayBpblxuICBsZXQgZGF0YSA9IHNoaWZ0X2xlZnQgZGF0YSA1IGluXG4gIGxldCBkYXRhID0gbG9nb3IgZGF0YSBocCBpblxuICBkYXRhXG4iLCJcbnR5cGUgbGFuZ3VhZ2VzID0gRU5HIHwgRlJBIHwgSVRBIHwgU1BBIHwgR0VSIHwgSkFQXG5sZXQgbGFuZyA9IHJlZiBFTkdcblxudHlwZSB0d2Vha2VyX21vZGVzID0gU3RyaWN0IHwgRmxleGlibGVcbmxldCB0d2Vha2VyX21vZGUgPSByZWYgRmxleGlibGVcblxubGV0IGNvbmZpZ3VyZSBsYW5ndWFnZSA9XG4gIHR3ZWFrZXJfbW9kZSA6PSBGbGV4aWJsZSA7XG4gIG1hdGNoIGxhbmd1YWdlIHdpdGhcbiAgfCBcImVuZ1wiIC0+IGxhbmcgOj0gRU5HXG4gIHwgXCJzcGFcIiAtPiBsYW5nIDo9IFNQQVxuICB8IFwiZnJhXCIgLT4gbGFuZyA6PSBGUkFcbiAgfCBcIml0YVwiIC0+IGxhbmcgOj0gSVRBXG4gIHwgXCJnZXJcIiAtPiBsYW5nIDo9IEdFUlxuICB8IFwiamFwXCIgLT4gbGFuZyA6PSBKQVAgOyB0d2Vha2VyX21vZGUgOj0gU3RyaWN0XG4gIHwgXyAtPiBsYW5nIDo9IEVOR1xuIiwib3BlbiBVdGlsc1xyXG5vcGVuIEJpZ19pbnRcclxuXHJcbmxldCBtdWx0X21vZCB4IHkgbSA9XHJcbiAgbW9kX2JpZ19pbnQgKG11bHRfYmlnX2ludCB4IHkpIG1cclxuXHJcbmxldCBwcmVkID0gcHJlZF9iaWdfaW50XHJcbmxldCBzdWNjID0gc3VjY19iaWdfaW50XHJcbmxldCBpbnRfbXVsID0gbXVsdF9pbnRfYmlnX2ludFxyXG5sZXQgbG9nYW5kID0gYW5kX2JpZ19pbnRcclxubGV0IHNoaWZ0X2xlZnQgPSBzaGlmdF9sZWZ0X2JpZ19pbnRcclxubGV0IHNoaWZ0X3JpZ2h0ID0gc2hpZnRfcmlnaHRfYmlnX2ludFxyXG5sZXQgdHdvX2JpZ19pbnQgPSBiaWdfaW50X29mX2ludCAyXHJcbmxldCB0aHJlZV9iaWdfaW50ID0gYmlnX2ludF9vZl9pbnQgM1xyXG5sZXQgZm91cl9iaWdfaW50ID0gYmlnX2ludF9vZl9pbnQgNFxyXG5cclxubGV0IGEgPSAweDQxYzY0ZTZkTCB8PiBiaWdfaW50X29mX2ludDY0XHJcbmxldCBiID0gMHg2MDczTCB8PiBiaWdfaW50X29mX2ludDY0XHJcbmxldCBhX2ludiA9IDB4RUVCOUVCNjVMIHw+IGJpZ19pbnRfb2ZfaW50NjRcclxubGV0IGJfaW52ID0gMHgwQTM1NjFBMUwgfD4gYmlnX2ludF9vZl9pbnQ2NFxyXG5sZXQgbSA9IDB4MV8wMF8wMF8wMF8wMEwgfD4gYmlnX2ludF9vZl9pbnQ2NFxyXG5sZXQgYl8xID0gMHgzNDFiOTQ0YmJMIHw+IGJpZ19pbnRfb2ZfaW50NjQgKCogSW52ZXJzZSBvZiBiIG1vZCAyKiozNCAqKVxyXG5sZXQgY3ljbGVfcGFydF9wcm9kdWN0ID1cclxuICBtdWx0X21vZCAocHJlZCBhKSBiXzEgKGludF9tdWwgNCBtKVxyXG5cclxubGV0IG1hc2szMiA9IGJpZ19pbnRfb2ZfaW50NjQgMHhGRkZGRkZGRkxcclxuXHJcbmxldCBldmVuIG4gPSBsb2dhbmQgbiB1bml0X2JpZ19pbnQgfD4gZXFfYmlnX2ludCB6ZXJvX2JpZ19pbnRcclxubGV0IG9kZCBuID0gZXZlbiBuIHw+IG5vdFxyXG5cclxubGV0IHJlYyBtcG93IGJhc2UgZXhwIG4gPVxyXG4gIGxldCBiYXNlID0gbW9kX2JpZ19pbnQgYmFzZSBuIGluXHJcbiAgaWYgZXFfYmlnX2ludCBleHAgemVyb19iaWdfaW50XHJcbiAgdGhlbiB1bml0X2JpZ19pbnRcclxuICBlbHNlIGlmIGVxX2JpZ19pbnQgZXhwIHVuaXRfYmlnX2ludFxyXG4gIHRoZW4gYmFzZVxyXG4gIGVsc2UgaWYgZXZlbiBleHBcclxuICB0aGVuIG1wb3cgKG11bHRfYmlnX2ludCBiYXNlIGJhc2UpIChkaXZfYmlnX2ludCBleHAgdHdvX2JpZ19pbnQpIG5cclxuICBlbHNlIG11bHRfbW9kIGJhc2UgKG1wb3cgYmFzZSAocHJlZCBleHApIG4pIG5cclxuXHJcbmxldCByZWMgcG93IGJhc2UgZXhwID1cclxuICBpZiBlcV9iaWdfaW50IGV4cCB6ZXJvX2JpZ19pbnRcclxuICB0aGVuIHVuaXRfYmlnX2ludFxyXG4gIGVsc2UgaWYgZXFfYmlnX2ludCBleHAgdW5pdF9iaWdfaW50XHJcbiAgdGhlbiBiYXNlXHJcbiAgZWxzZSBpZiBldmVuIGV4cFxyXG4gIHRoZW4gcG93IChtdWx0X2JpZ19pbnQgYmFzZSBiYXNlKSAoZGl2X2JpZ19pbnQgZXhwIHR3b19iaWdfaW50KVxyXG4gIGVsc2UgbXVsdF9iaWdfaW50IGJhc2UgKHBvdyBiYXNlIChwcmVkIGV4cCkpXHJcblxyXG5sZXQgYWRkX2lmX25lZ2F0aXZlIHggeSA9XHJcbiAgaWYgZ2VfYmlnX2ludCB4IHplcm9fYmlnX2ludCB0aGVuIHggZWxzZSBhZGRfYmlnX2ludCB4IHlcclxubGV0IHN1Yl9pZl9nZXEgeCB5ID1cclxuICBpZiBnZV9iaWdfaW50IHggeSB0aGVuIHN1Yl9iaWdfaW50IHggeSBlbHNlIHhcclxuXHJcbmxldCBzZWVkX2F0IGN5Y2xlID1cclxuICBsZXQgcmVzID0gbXVsdF9iaWdfaW50IChwcmVkIGEpIG0gaW5cclxuICBsZXQgb3AxID0gYWRkX2lmX25lZ2F0aXZlIChtcG93IGEgY3ljbGUgcmVzIHw+IHByZWQpIHJlcyBpblxyXG4gIGxldCBhdXggPSBkaXZfYmlnX2ludCBvcDEgKHByZWQgYSkgaW5cclxuICBtdWx0X21vZCBhdXggYiBtXHJcblxyXG5leGNlcHRpb24gRG9lc05vdEV4aXN0XHJcblxyXG5sZXQgZGlzY3JldGVfbG9nIGJhc2UgcG93ZXIgbiBjaGVja19leGlzdHMgPVxyXG4gIGxldCAoYSxjLG0pID0gKGJhc2UsIHBvd2VyLCBwb3cgdHdvX2JpZ19pbnQgKGJpZ19pbnRfb2ZfaW50IG4pKSBpblxyXG4gIGFzc2VydCAobiA+PSAzKSA7XHJcbiAgYXNzZXJ0IChvZGQgYSAmJiBvZGQgYykgO1xyXG4gIGlmIGNoZWNrX2V4aXN0c1xyXG4gIHRoZW4gYmVnaW5cclxuICAgIGxldCBtb2Rfc3dpdGNoID0gZXFfYmlnX2ludCAobW9kX2JpZ19pbnQgYSBmb3VyX2JpZ19pbnQpIHRocmVlX2JpZ19pbnQgaW5cclxuICAgIGxldCByZWMgYXV4IGsgbTEgPVxyXG4gICAgICBpZiBrID49IDIgdGhlbiBiZWdpblxyXG4gICAgICAgIGxldCB4ID0gaWYgbW9kX3N3aXRjaCB0aGVuIG11bHRfbW9kIGEgYSBtMSBlbHNlIG1vZF9iaWdfaW50IGEgbTEgaW5cclxuICAgICAgICBpZiBlcV9iaWdfaW50IHggdW5pdF9iaWdfaW50IHRoZW4gYmVnaW5cclxuICAgICAgICAgIGxldCB4ID0gbW9kX2JpZ19pbnQgYyBtMSBpblxyXG4gICAgICAgICAgaWYgKChlcV9iaWdfaW50IHggdW5pdF9iaWdfaW50KSB8fCAobW9kX3N3aXRjaCAmJiBlcV9iaWdfaW50IHggYSkpIHw+IG5vdFxyXG4gICAgICAgICAgdGhlbiByYWlzZSBEb2VzTm90RXhpc3RcclxuICAgICAgICBlbmQgZWxzZSBhdXggKGstMSkgKHNoaWZ0X3JpZ2h0IG0xIDEpXHJcbiAgICAgIGVuZFxyXG4gICAgaW5cclxuICAgIGF1eCAobi0xKSAoc2hpZnRfcmlnaHQgbSAxKVxyXG4gIGVuZCA7XHJcbiAgbGV0IGsgPSBuLTIgaW5cclxuICBsZXQgYml0bWFzayA9IHBvdyB0d29fYmlnX2ludCAoay0xIHw+IGJpZ19pbnRfb2ZfaW50KSB8PiBwcmVkIGluXHJcbiAgbGV0IGxzID0gQXJyYXkubWFrZSBrIGMgaW5cclxuICBsZXQgcmVjIGF1eCBpIGwgPVxyXG4gICAgaWYgaSA8IGtcclxuICAgIHRoZW4gYmVnaW5cclxuICAgICAgbGV0IGwgPSBtdWx0X21vZCBsIGwgbSBpblxyXG4gICAgICAgIGxzLihpKSA8LSBsIDsgYXV4IChpKzEpIGxcclxuICAgIGVuZFxyXG4gIGluXHJcbiAgYXV4IDEgYyA7XHJcbiAgbGV0IHJlYyBhdXggaSBiIGJpdCA9XHJcbiAgICBpZiBpID49IDBcclxuICAgIHRoZW4gYmVnaW5cclxuICAgICAgbGV0IGIgPVxyXG4gICAgICAgIGlmIGVxX2JpZ19pbnQgbHMuKGkpIChtcG93IGEgKHNoaWZ0X2xlZnQgYiBpIHw+IGxvZ2FuZCBiaXRtYXNrKSBtKSB8PiBub3RcclxuICAgICAgICB0aGVuIGFkZF9iaWdfaW50IGIgYml0XHJcbiAgICAgICAgZWxzZSBiXHJcbiAgICAgIGluXHJcbiAgICAgIGF1eCAoaS0xKSBiIChzaGlmdF9sZWZ0IGJpdCAxKVxyXG4gICAgZW5kIGVsc2UgYlxyXG4gIGluXHJcbiAgYXV4IChrLTEpIHplcm9fYmlnX2ludCB1bml0X2JpZ19pbnRcclxuXHJcbmxldCBjeWNsZV90byBzZWVkID1cclxuICBsZXQgbW9kdWxvID0gaW50X211bCA0IG0gaW5cclxuICBsZXQgcG93ZXIgPSBzdWJfaWZfZ2VxIChtdWx0X21vZCBzZWVkIGN5Y2xlX3BhcnRfcHJvZHVjdCBtb2R1bG8gfD4gc3VjYykgbW9kdWxvIGluXHJcbiAgZGlzY3JldGVfbG9nIGEgcG93ZXIgKDMyKzIpIGZhbHNlXHJcblxyXG5sZXQgbmV4dF9zZWVkIHNlZWQgPVxyXG4gIG11bHRfYmlnX2ludCBzZWVkIGEgfD4gYWRkX2JpZ19pbnQgYiB8PiBsb2dhbmQgbWFzazMyXHJcblxyXG5sZXQgcHJldl9zZWVkIHNlZWQgPVxyXG4gIG11bHRfYmlnX2ludCBzZWVkIGFfaW52IHw+IGFkZF9iaWdfaW50IGJfaW52IHw+IGxvZ2FuZCBtYXNrMzJcclxuXHJcbmxldCBiaWdfaW50X29mX3VpbnQzMiBpMzIgPVxyXG4gIGludDY0X29mX3VpbnQzMiBpMzJcclxuICB8PiBiaWdfaW50X29mX2ludDY0XHJcblxyXG5sZXQgdWludDMyX29mX2JpZ2ludCBiaSA9XHJcbiAgbGV0IG1heGludDMyID0gSW50MzIubWF4X2ludCB8PiBiaWdfaW50X29mX2ludDMyIGluXHJcbiAgbGV0IG1pbmludDMyID0gSW50MzIubWluX2ludCB8PiBiaWdfaW50X29mX2ludDMyIGluXHJcbiAgbGV0IHRvdGFsID0gc3ViX2JpZ19pbnQgbWF4aW50MzIgbWluaW50MzIgfD4gc3VjY19iaWdfaW50IGluXHJcbiAgbGV0IGJpID0gaWYgZ3RfYmlnX2ludCBiaSBtYXhpbnQzMlxyXG4gICAgdGhlbiBzdWJfYmlnX2ludCBiaSB0b3RhbFxyXG4gICAgZWxzZSBiaVxyXG4gIGluXHJcbiAgaW50MzJfb2ZfYmlnX2ludCBiaVxyXG5cclxuKCogRmlzaGluZyAoZnJvbSBTaGFvKSAqKVxyXG5cclxubGV0IHJuZ19vZiBzZWVkID0gc2hpZnRfcmlnaHQgc2VlZCAxNiB8PiBpbnRfb2ZfYmlnX2ludFxyXG5cclxubGV0IG9sZF9yb2QgPSAwXHJcbmxldCBnb29kX3JvZCA9IDFcclxubGV0IHN1cGVyX3JvZCA9IDJcclxubGV0IGFQcmVzc2VzID0gW3wxOzM7NnxdXHJcbmxldCBtb3JlQVByZXNzZXMgPSBbfDA7MTA7MzB8XVxyXG5sZXQgZmlzaGluZ19hdHRlbXB0IHJvdXRlMTE5IGZlZWJhcyBzdGFydGluZ19zZWVkIHJvZCBpbml0aWFsQWR2YW5jZXMgPVxyXG4gIGxldCBzZWVkID0gcmVmIHN0YXJ0aW5nX3NlZWQgaW5cclxuICBmb3IgXz0xIHRvIGluaXRpYWxBZHZhbmNlcyBkb1xyXG4gICAgc2VlZCA6PSBuZXh0X3NlZWQgIXNlZWRcclxuICBkb25lIDtcclxuICBsZXQgbWluUm91bmRzID0gKChybmdfb2YgIXNlZWQpIG1vZCAoYVByZXNzZXMuKHJvZCkpKSArIDEgaW5cclxuICBzZWVkIDo9IG5leHRfc2VlZCAhc2VlZCA7ICgqIE9uZSBjYWxsIHRvIGRldGVybWluZSBudW1iZXIgb2YgZG90cyBvbiBmaXJzdCBjYXN0ICopXHJcbiAgc2VlZCA6PSBuZXh0X3NlZWQgIXNlZWQgOyAoKiBjYWxsIHRoYXQgZGV0ZXJtaW5lcyBpZiBmaXNoIGlzIG9uIGxpbmUgKilcclxuXHJcbiAgbGV0IGJpdGVSb2xsID0gKHJuZ19vZiAhc2VlZCkgbW9kIDEwMCBpblxyXG4gIGxldCBiaXRlUmVzdWx0ID1cclxuICAgIGlmIGJpdGVSb2xsIGxhbmQgMSA9IDAgdGhlbiAwICgqIEEgZmlzaCB3aWxsIGJlIGdlbmVyYXRlZCByZWdhcmRsZXNzIG9mIGxlYWQgKilcclxuICAgIGVsc2UgaWYgYml0ZVJvbGwgPiAxNCB0aGVuIDEgKCogQSBTdWN0aW9uIEN1cHMgb3IgU3RpY2t5IEhvbGQgbGVhZCBpcyBuZWNlc3NhcnkgdG8gZ2V0IGEgZmlzaCAqKVxyXG4gICAgZWxzZSAyXHJcbiAgaW5cclxuXHJcbiAgZm9yIF89MSB0byBtaW5Sb3VuZHMtMSBkb1xyXG4gICAgc2VlZCA6PSBuZXh0X3NlZWQgIXNlZWQgKCogTW9yZSBjYWxscyB0byBkZXRlcm1pbmUgZG90IG51bWJlcnMgKilcclxuICBkb25lIDtcclxuXHJcbiAgbGV0IGFkdmFuY2VtZW50ID0gcmVmIChpbml0aWFsQWR2YW5jZXMgKyBtaW5Sb3VuZHMpIGluXHJcbiAgaWYgbWluUm91bmRzID0gMSB0aGVuIGJlZ2luXHJcbiAgICBzZWVkIDo9IG5leHRfc2VlZCAhc2VlZCA7ICgqIERlY2lkZSB3aGV0aGVyIG9yIG5vdCB0byBtYWtlIHRoZSBwbGF5ZXIgcmVlbCBhZ2FpbiAqKVxyXG4gICAgYWR2YW5jZW1lbnQgOj0gIWFkdmFuY2VtZW50ICsgMSA7XHJcbiAgICBsZXQgYml0ZVJvbGwgPSAocm5nX29mICFzZWVkKSBtb2QgMTAwIGluXHJcbiAgICBpZiBiaXRlUm9sbCA8IG1vcmVBUHJlc3Nlcy4ocm9kKVxyXG4gICAgdGhlbiAoc2VlZCA6PSBuZXh0X3NlZWQgIXNlZWQgOyAgYWR2YW5jZW1lbnQgOj0gIWFkdmFuY2VtZW50ICsgMSlcclxuICBlbmQgO1xyXG4gIHNlZWQgOj0gbmV4dF9zZWVkICFzZWVkIDtcclxuICBsZXQgZmVlYmFzUmVzdWx0ID0gKHJuZ19vZiAhc2VlZCkgbW9kIDEwMCA8IDUwIGluXHJcbiAgaWYgcm91dGUxMTkgJiYgbm90IGZlZWJhcyB0aGVuIGFkdmFuY2VtZW50IDo9ICFhZHZhbmNlbWVudCArIDEgO1xyXG4gIChiaXRlUmVzdWx0LCBmZWViYXNSZXN1bHQsICFhZHZhbmNlbWVudClcclxuXHJcbmxldCBiZXN0X3NlZWRfZm9yX3JvZCByb3V0ZTExOSBmZWViYXMgdGFyZ2V0X3NlZWQgcm9kID1cclxuICBsZXQgbWF4QWRkaXRpb25hbE9mZnNldHMgPSBbfDA7MTs0fF0gaW5cclxuICBsZXQgc3RhcnQgPSA3IGluXHJcbiAgbGV0IGJlc3RSZXN1bHRzID0gcmVmIE5vbmUgaW5cclxuXHJcbiAgbGV0IHN0YXJ0aW5nX3NlZWQgPSByZWYgKHByZXZfc2VlZCB0YXJnZXRfc2VlZCkgaW5cclxuICBmb3IgXz0xIHRvIHN0YXJ0ICsgMSBkb1xyXG4gICAgc3RhcnRpbmdfc2VlZCA6PSBwcmV2X3NlZWQgIXN0YXJ0aW5nX3NlZWRcclxuICBkb25lIDtcclxuXHJcbiAgbGV0IG9mZnNldDExOSA9XHJcbiAgICBpZiByb3V0ZTExOSAmJiBub3QgZmVlYmFzXHJcbiAgICB0aGVuIChzdGFydGluZ19zZWVkIDo9IHByZXZfc2VlZCAhc3RhcnRpbmdfc2VlZCA7IDEpXHJcbiAgICBlbHNlIDBcclxuICBpblxyXG5cclxuICBmb3IgYWRkaXRpb25hbE9mZnNldD0wIHRvIG1heEFkZGl0aW9uYWxPZmZzZXRzLihyb2QpIGRvXHJcbiAgICBsZXQgKGJpdGVSZXN1bHQsIGZlZWJhc1Jlc3VsdCwgYWR2YW5jZW1lbnQpID1cclxuICAgICAgZmlzaGluZ19hdHRlbXB0IHJvdXRlMTE5IGZlZWJhcyAhc3RhcnRpbmdfc2VlZCByb2Qgc3RhcnQgaW5cclxuICAgIHN0YXJ0aW5nX3NlZWQgOj0gcHJldl9zZWVkICFzdGFydGluZ19zZWVkIDtcclxuICAgIGlmIGJpdGVSZXN1bHQgPCAyICYmIChub3QgZmVlYmFzIHx8IGZlZWJhc1Jlc3VsdClcclxuICAgICAgJiYgc3RhcnQgKyAyICsgYWRkaXRpb25hbE9mZnNldCArIG9mZnNldDExOSA9IGFkdmFuY2VtZW50XHJcbiAgICB0aGVuIGJlZ2luXHJcbiAgICAgIGJlc3RSZXN1bHRzIDo9XHJcbiAgICAgICAgbWF0Y2ggIWJlc3RSZXN1bHRzIHdpdGhcclxuICAgICAgICB8IE5vbmUgLT4gU29tZSAoYml0ZVJlc3VsdCwgYWR2YW5jZW1lbnQsIG5leHRfc2VlZCAhc3RhcnRpbmdfc2VlZClcclxuICAgICAgICB8IFNvbWUgKGJyLCBhZHYsIHMpIHdoZW4gYnIgPSAwICYmIGJpdGVSZXN1bHQgPSAxIC0+IFNvbWUgKGJyLCBhZHYsIHMpXHJcbiAgICAgICAgfCBTb21lIChiciwgYWR2LCBzKSB3aGVuIGJyID0gYml0ZVJlc3VsdCAmJiBhZHYgPCBhZHZhbmNlbWVudCAtPiBTb21lIChiciwgYWR2LCBzKVxyXG4gICAgICAgIHwgXyAtPiBTb21lIChiaXRlUmVzdWx0LCBhZHZhbmNlbWVudCwgbmV4dF9zZWVkICFzdGFydGluZ19zZWVkKVxyXG4gICAgZW5kXHJcbiAgZG9uZSA7XHJcbiAgIWJlc3RSZXN1bHRzXHJcblxyXG4oKiBJbnRlcmZhY2UgKilcclxuXHJcbmxldCBuZXh0X3NlZWQgc2VlZCA9XHJcbiAgbmV4dF9zZWVkIChiaWdfaW50X29mX3VpbnQzMiBzZWVkKSB8PiB1aW50MzJfb2ZfYmlnaW50XHJcblxyXG5sZXQgcHJldl9zZWVkIHNlZWQgPVxyXG4gIHByZXZfc2VlZCAoYmlnX2ludF9vZl91aW50MzIgc2VlZCkgfD4gdWludDMyX29mX2JpZ2ludFxyXG5cclxubGV0IGN5Y2xlX3RvIHNlZWQgPVxyXG4gIGN5Y2xlX3RvIChiaWdfaW50X29mX3VpbnQzMiBzZWVkKSB8PiB1aW50MzJfb2ZfYmlnaW50XHJcblxyXG5sZXQgc2VlZF9hdCBjeWNsZSA9XHJcbiAgc2VlZF9hdCAoYmlnX2ludF9vZl91aW50MzIgY3ljbGUpIHw+IHVpbnQzMl9vZl9iaWdpbnRcclxuXHJcbmxldCBiZXN0X3NlZWRfZm9yX3JvZCByb3V0ZTExOSBmZWViYXMgdGFyZ2V0X3NlZWQgcm9kID1cclxuICBtYXRjaCBiZXN0X3NlZWRfZm9yX3JvZCByb3V0ZTExOSBmZWViYXMgKGJpZ19pbnRfb2ZfdWludDMyIHRhcmdldF9zZWVkKSByb2Qgd2l0aFxyXG4gIHwgTm9uZSAtPiBOb25lXHJcbiAgfCBTb21lIChiLGkscykgLT4gU29tZSAoYj0xLGksdWludDMyX29mX2JpZ2ludCBzKVxyXG4iLCJvcGVuIFNlZWRcblxudHlwZSByZXN1bHQgPSBcbiAgfCBDb250IG9mIChGb3JtYXQuZm9ybWF0dGVyIC0+IHN0cmluZyAtPiByZXN1bHQpXG4gIHwgTm9Db250XG5cbmxldCByZWMgbWFpbiBmbXQgPVxuICBGb3JtYXQuZnByaW50ZiBmbXQgXCJQbGVhc2UgZW50ZXIgeW91ciBzZWVkICh1c2UgMHggcHJlZml4IGlmIGhleGFkZWNpbWFsKTogQD9cIiA7XG4gIENvbnQgbWFpbl8xXG5cbmFuZCBtYWluXzEgZm10IHN0ciA9XG4gIGxldCBzZWVkID0gVXRpbHMudWludDMyX29mX3N0ciBzdHIgaW5cbiAgRm9ybWF0LmZwcmludGYgZm10IFwiRG8geW91IHdhbnQgdG8gb2J0YWluIHRoaXMgc2VlZCB1c2luZyB0aGUgZnJlZXplIFBSTkcgQUNFIGNvZGUgP0AuXCIgO1xuICBGb3JtYXQuZnByaW50ZiBmbXQgXCIxLiBZZXMsIGZvciBtZXRob2QgSDEgKHdpbGQgcG9rZW1vbikgdXNpbmcgc3dlZXQgc2NlbnQuQC5cIiA7XG4gIEZvcm1hdC5mcHJpbnRmIGZtdCBcIjIuIFllcywgZm9yIG1hc3Mgb3V0YnJlYWtzIChtZXRob2QgSDEsIHVzaW5nIHN3ZWV0IHNjZW50KS5ALlwiIDtcbiAgRm9ybWF0LmZwcmludGYgZm10IFwiMy4gWWVzLCBmb3IgbWV0aG9kIEgxICh3aWxkIHBva2Vtb24pIHVzaW5nIGEgcm9kLkAuXCIgO1xuICBGb3JtYXQuZnByaW50ZiBmbXQgXCI0LiBZZXMsIGZvciBtZXRob2QgMSAoc3RhdGlvbm5hcnkgcG9rZW1vbikuQC5cIiA7XG4gIEZvcm1hdC5mcHJpbnRmIGZtdCBcIjUuIE5vLCBidXQgcGxlYXNlIHNob3cgbWUgdGhlIHNlZWRzIGluIHRoZSB2aWNpbml0eS5ALlwiIDtcbiAgRm9ybWF0LmZwcmludGYgZm10IFwiNi4gTm8gKHF1aXQpLkAuXCIgO1xuICBDb250IChtYWluXzIgc2VlZClcblxuYW5kIHNob3dfdmljaW5pdHkgZm10IHByaW50X2N5Y2xlIHNlZWQgc3RhcnQgc3RvcCA9XG4gIGxldCBjeWNsZSA9IGN5Y2xlX3RvIHNlZWQgaW5cbiAgaWYgcHJpbnRfY3ljbGUgdGhlbiBGb3JtYXQuZnByaW50ZiBmbXQgXCJDeWNsZSBmcm9tIHNlZWQgMDogJWx1QC5cIiBjeWNsZSA7XG4gIGxldCBzdGFydF9zZWVkID0gcmVmIChzZWVkX2F0IChJbnQzMi5hZGQgY3ljbGUgKEludDMyLm9mX2ludCBzdGFydCkpKSBpblxuICBmb3IgaSA9IHN0YXJ0IHRvIHN0b3AgZG9cbiAgICBGb3JtYXQuZnByaW50ZiBmbXQgXCIlaTogJWx1ICglI2x4KUAuXCIgaSAoIXN0YXJ0X3NlZWQpICghc3RhcnRfc2VlZCkgO1xuICAgIHN0YXJ0X3NlZWQgOj0gbmV4dF9zZWVkICghc3RhcnRfc2VlZClcbiAgZG9uZVxuXG5hbmQgbWFpbl8yIHNlZWQgZm10IHN0ciA9XG4gIG1hdGNoIHN0ciB3aXRoXG4gIHwgXCIxXCIgLT5cbiAgICBGb3JtYXQuZnByaW50ZiBmbXQgXCJZb3Ugc2hvdWxkIHVzZSB0aGUgc2VlZCAlI2x4ICgyIGN5Y2xlcyBiZWZvcmUgeW91ciB0YXJnZXQpLkAuXCJcbiAgICAgIChwcmV2X3NlZWQgKHByZXZfc2VlZCBzZWVkKSkgO1xuICAgIEZvcm1hdC5mcHJpbnRmIGZtdCBcIllvdSBzaG91bGQgdXNlIHN3ZWV0IHNjZW50IGRpcmVjdGx5IGFmdGVyIHRyaWdnZXJpbmcgdGhlIEFDRSxcIiA7XG4gICAgRm9ybWF0LmZwcmludGYgZm10IFwiIHdpdGhvdXQgY2xvc2luZyB0aGUgcG9rZW1vbiBtZW51LkAuXCIgO1xuICAgIE5vQ29udFxuICB8IFwiMlwiIC0+XG4gICAgRm9ybWF0LmZwcmludGYgZm10IFwiWW91IHNob3VsZCB1c2UgdGhlIHNlZWQgJSNseCAoMSBjeWNsZSBiZWZvcmUgeW91ciB0YXJnZXQpLkAuXCJcbiAgICAgIChwcmV2X3NlZWQgc2VlZCkgO1xuICAgIEZvcm1hdC5mcHJpbnRmIGZtdCBcIllvdSBzaG91bGQgdXNlIHN3ZWV0IHNjZW50IGRpcmVjdGx5IGFmdGVyIHRyaWdnZXJpbmcgdGhlIEFDRSxcIiA7XG4gICAgRm9ybWF0LmZwcmludGYgZm10IFwiIHdpdGhvdXQgY2xvc2luZyB0aGUgcG9rZW1vbiBtZW51LkAuXCIgO1xuICAgIE5vQ29udFxuICB8IFwiM1wiIC0+XG4gICAgRm9ybWF0LmZwcmludGYgZm10IFwiUGxlYXNlIHNlbGVjdCB5b3VyIGNvbmZpZ3VyYXRpb246QC5cIiA7XG4gICAgRm9ybWF0LmZwcmludGYgZm10IFwiMS4gSSB3aWxsIG5vdCBiZSBmaXNoaW5nIG9uIHJvdXRlIDExOS5ALlwiIDtcbiAgICBGb3JtYXQuZnByaW50ZiBmbXQgXCIyLiBJIHdpbGwgYmUgZmlzaGluZyBvbiByb3V0ZSAxMTksIGJ1dCBub3QgZm9yIGEgZmVlYmFzLkAuXCIgO1xuICAgIEZvcm1hdC5mcHJpbnRmIGZtdCBcIjMuIEkgd2lsbCBiZSBmaXNoaW5nIGZvciBmZWViYXMgb24gYSBmZWViYXMgdGlsZS5ALlwiIDtcbiAgICBDb250IChtYWluXzMgc2VlZClcbiAgfCBcIjRcIiAtPlxuICAgIEZvcm1hdC5mcHJpbnRmIGZtdCBcIkZvciBtb3N0IGxlZ2VuZGFyaWVzLCB5b3Ugc2hvdWxkIHVzZSB0aGUgc2VlZCBhdCBjeWNsZSAtMy5ALlwiIDtcbiAgICBGb3JtYXQuZnByaW50ZiBmbXQgXCJQbGVhc2UgcmVmZXIgdG8gdGhlIGluc3RydWN0aW9ucyBvbiB0aGUgZnJlZXplIFBSTkcgQUNFIGNvZGUgZm9yIG90aGVyIHN0YXRpb25uYXJ5IHBva2Vtb25zLkAuXCIgO1xuICAgIEZvcm1hdC5mcHJpbnRmIGZtdCBcIllvdSBzaG91bGQgc3RhcnQgdGhlIGJhdHRsZSBhcyBzb29uIGFzIHlvdSBjYW5cIiA7XG4gICAgRm9ybWF0LmZwcmludGYgZm10IFwiIChqdXN0IGFmdGVyIGhhdmluZyBleGVjdXRlZCB0aGUgQUNFIGFuZCBjbG9zZWQgdGhlIG1lbnUpLkAuXCIgO1xuICAgIHNob3dfdmljaW5pdHkgZm10IGZhbHNlIHNlZWQgKC0xMCkgMCA7XG4gICAgTm9Db250XG4gIHwgXCI1XCIgLT5cbiAgICBGb3JtYXQuZnByaW50ZiBmbXQgXCJQbGVhc2UgZW50ZXIgdGhlIHJhbmdlIChleGFtcGxlOiAtMjUgNSk6QC5cIiA7XG4gICAgQ29udCAobWFpbl92aWNpbml0eSBzZWVkKVxuICB8IF8gLT4gTm9Db250XG5cbmFuZCBtYWluX3ZpY2luaXR5IHNlZWQgZm10IHN0ciA9XG4gIGxldCAoc3RhcnQsIHN0b3ApID0gU2NhbmYuc3NjYW5mIHN0ciBcIiAlaSAlaVwiIChmdW4gaSBqIC0+IChpLCBqKSkgaW5cbiAgc2hvd192aWNpbml0eSBmbXQgdHJ1ZSBzZWVkIHN0YXJ0IHN0b3AgO1xuICBOb0NvbnRcblxuYW5kIG1haW5fMyBzZWVkIGZtdCBzdHIgPVxuICBsZXQgKHJvdXRlMTE5LCBmZWViYXMpID1cbiAgICBtYXRjaCBzdHIgd2l0aFxuICAgIHwgXCIxXCIgLT4gKGZhbHNlLCBmYWxzZSlcbiAgICB8IFwiMlwiIC0+ICh0cnVlLCBmYWxzZSlcbiAgICB8IFwiM1wiIC0+ICh0cnVlLCB0cnVlKVxuICAgIHwgXyAtPiBmYWlsd2l0aCBcIlVua25vd24gYW5zd2VyLlwiXG4gIGluXG4gIGZvciByb2QgPSBvbGRfcm9kIHRvIHN1cGVyX3JvZCBkb1xuICAgIGxldCByb2RuYW1lID1cbiAgICAgIG1hdGNoIHJvZCB3aXRoXG4gICAgICB8IHIgd2hlbiByPW9sZF9yb2QgLT4gXCJPbGQgcm9kXCJcbiAgICAgIHwgciB3aGVuIHI9Z29vZF9yb2QgLT4gXCJHb29kIHJvZFwiXG4gICAgICB8IHIgd2hlbiByPXN1cGVyX3JvZCAtPiBcIlN1cGVyIHJvZFwiXG4gICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG4gICAgaW5cbiAgICBGb3JtYXQuZnByaW50ZiBmbXQgXCIlczpALlwiIHJvZG5hbWUgO1xuICAgIG1hdGNoIGJlc3Rfc2VlZF9mb3Jfcm9kIHJvdXRlMTE5IGZlZWJhcyBzZWVkIHJvZCB3aXRoXG4gICAgfCBOb25lIC0+IEZvcm1hdC5mcHJpbnRmIGZtdCBcIlxcdE5vIG1hdGNoZXMgZm91bmRALlwiXG4gICAgfCBTb21lIChmYWxzZSwgYWR2LCBzZWVkKSAtPlxuICAgICAgRm9ybWF0LmZwcmludGYgZm10IFwiXFx0V2l0aCBsZWFkOiBObyBsZWFkIG5lY2Vzc2FyeUAuXCIgO1xuICAgICAgRm9ybWF0LmZwcmludGYgZm10IFwiXFx0VXNlIHNlZWQgJSNseCB0byBnZW5lcmF0ZSB0YXJnZXQgb24gYWR2YW5jZW1lbnQgJWlALlwiIHNlZWQgYWR2XG4gICAgfCBTb21lICh0cnVlLCBhZHYsIHNlZWQpIC0+XG4gICAgICBGb3JtYXQuZnByaW50ZiBmbXQgXCJcXHRXaXRoIGxlYWQ6IE11c3QgaGF2ZSBTdWN0aW9uIEN1cCBvciBTdGlja3kgSG9sZCBsZWFkQC5cIiA7XG4gICAgICBGb3JtYXQuZnByaW50ZiBmbXQgXCJcXHRVc2Ugc2VlZCAlI2x4IHRvIGdlbmVyYXRlIHRhcmdldCBvbiBhZHZhbmNlbWVudCAlaUAuXCIgc2VlZCBhZHZcbiAgZG9uZSA7XG4gIEZvcm1hdC5mcHJpbnRmIGZtdCBcIllvdSBzaG91bGQgdXNlIHRoZSByb2QgZGlyZWN0bHkgYWZ0ZXIgdHJpZ2dlcmluZyB0aGUgQUNFXCIgO1xuICBGb3JtYXQuZnByaW50ZiBmbXQgXCIgKGxlYXZlIHRoZSBwb2tlbW9uIG1lbnUgYW5kIGVudGVyIHRoZSBiYWcpLkAuXCIgO1xuICBGb3JtYXQuZnByaW50ZiBmbXQgXCJUaGFua3MgdG8gU2hhbyBmb3IgdGhpcyBzY3JpcHQuQC5cIiA7XG4gIE5vQ29udCIsIlxuZXhjZXB0aW9uIEludmFsaWRTYXZlXG5cbmxldCBnYW1lX3NhdmVfQSA9IDB4MDAwMFxubGV0IGdhbWVfc2F2ZV9CID0gMHhFMDAwXG5cbmxldCBzZWN0aW9uX3NpemUgPSAweDEwMDBcbmxldCBuYl9zZWN0aW9ucyA9IDE0XG5sZXQgc2VjdGlvbl9pZF9vZmZzZXQgPSAweEZGNFxubGV0IGNoZWNrc3VtX29mZnNldCA9IDB4RkY2XG5sZXQgc2F2ZV9pbmRleF9vZmZzZXQgPSAweEZGQ1xuXG5sZXQgcGNfYnVmZmVyc19kYXRhX3NpemUgPSAzOTY4XG5sZXQgYm94X25hbWVzX3NlY3Rpb25faWQgPSAxMyAoKiBQQyBidWZmZXIgSSAqKVxubGV0IGJveF9uYW1lc19zZWN0aW9uX2RhdGFfbGVuZ3RoID0gMjAwMFxubGV0IGJveF9uYW1lc19vZmZzZXQgPSAweDgzNDQgLSA4KnBjX2J1ZmZlcnNfZGF0YV9zaXplXG5sZXQgYm94X25hbWVzX2xlbmd0aCA9IDEyNlxuXG5sZXQgdGVhbV9pdGVtc19zZWN0aW9uX2lkID0gMVxubGV0IHRlYW1faXRlbXNfc2VjdGlvbl9kYXRhX2xlbmd0aCA9IDM5NjhcbmxldCB0ZWFtX3NpemVfb2Zmc2V0ID0gMHgyMzRcbmxldCB0ZWFtX2RhdGFfb2Zmc2V0ID0gMHgyMzhcbmxldCBwa21uX2RhdGFfc2l6ZSA9IDEwMFxuXG5sZXQgYWRkcl9vZl9zZWN0aW9uIGluYyBpZCA9XG4gIGxldCByYnVmID0gQnl0ZXMuY3JlYXRlIHNlY3Rpb25fc2l6ZSBpblxuICBsZXQgcmVjIGF1eCBiYXNlIGkgPVxuICAgIGlmIGkgPj0gbmJfc2VjdGlvbnNcbiAgICB0aGVuIHJhaXNlIEludmFsaWRTYXZlXG4gICAgZWxzZVxuICAgICAgbGV0IGFkZHIgPSBiYXNlICsgaSpzZWN0aW9uX3NpemUgaW5cbiAgICAgIHNlZWtfaW4gaW5jIGFkZHIgOyByZWFsbHlfaW5wdXQgaW5jIHJidWYgMCBzZWN0aW9uX3NpemUgO1xuICAgICAgbGV0IGlkJyA9IEJ5dGVzLmdldF91aW50MTZfbGUgcmJ1ZiBzZWN0aW9uX2lkX29mZnNldCBpblxuICAgICAgbGV0IGluZGV4ID0gQnl0ZXMuZ2V0X2ludDMyX2xlIHJidWYgc2F2ZV9pbmRleF9vZmZzZXQgaW5cbiAgICAgIGlmIGlkJyA9IGlkXG4gICAgICB0aGVuIChhZGRyLCBpbmRleClcbiAgICAgIGVsc2UgYXV4IGJhc2UgKGkrMSlcbiAgaW5cbiAgbGV0IChhZGRyYSwgaW5kZXhhKSA9IGF1eCBnYW1lX3NhdmVfQSAwIGluXG4gIGxldCAoYWRkcmIsIGluZGV4YikgPSBhdXggZ2FtZV9zYXZlX0IgMCBpblxuICBpZiBJbnQzMi51bnNpZ25lZF9jb21wYXJlIGluZGV4YSBpbmRleGIgPCAwXG4gIHRoZW4gYWRkcmIgZWxzZSBhZGRyYVxuXG5sZXQgcmVhZF9zZWN0aW9uIGluYyBzZWN0aW9uX2lkID1cbiAgbGV0IGFkZHIgPSBhZGRyX29mX3NlY3Rpb24gaW5jIHNlY3Rpb25faWQgaW5cbiAgbGV0IHJlcyA9IEJ5dGVzLmNyZWF0ZSBzZWN0aW9uX3NpemUgaW5cbiAgc2Vla19pbiBpbmMgYWRkciA7IHJlYWxseV9pbnB1dCBpbmMgcmVzIDAgc2VjdGlvbl9zaXplIDtcbiAgKGFkZHIsIHJlcylcblxubGV0IHdyaXRlX3NlY3Rpb24gb2MgYWRkciBidWYgPVxuICBzZWVrX291dCBvYyBhZGRyIDsgb3V0cHV0X2J5dGVzIG9jIGJ1ZiA7IGZsdXNoIG9jXG5cbmxldCBtYXNrMTYgPSBJbnQzMi5vZl9pbnQgMHhGRkZGXG5cbmxldCBjb21wdXRlX2NoZWNrc3VtIGJ1ZiBzdGFydCBsZW4gPVxuICBsZXQgcmVjIGF1eCBhY2MgaSA9XG4gICAgaWYgaSA+PSBzdGFydCtsZW5cbiAgICB0aGVuIGFjY1xuICAgIGVsc2VcbiAgICAgIGxldCBuYiA9IEJ5dGVzLmdldF9pbnQzMl9sZSBidWYgaSBpblxuICAgICAgYXV4IChJbnQzMi5hZGQgYWNjIG5iKSAoaSs0KVxuICBpblxuICBsZXQgc3VtID0gYXV4IEludDMyLnplcm8gc3RhcnQgaW5cbiAgbGV0IGhpZ2ggPSBJbnQzMi5zaGlmdF9yaWdodF9sb2dpY2FsIHN1bSAxNiBpblxuICBsZXQgbG93ID0gSW50MzIubG9nYW5kIHN1bSBtYXNrMTYgaW5cbiAgbGV0IHJlcyA9IEludDMyLmFkZCBoaWdoIGxvdyBpblxuICBJbnQzMi5sb2dhbmQgcmVzIG1hc2sxNiB8PiBVdGlscy51aW50MzJfdG9faW50XG5cbigqIC0tLS0tIEJPWCBOQU1FUyAtLS0tLSAqKVxuXG5sZXQgZXh0cmFjdF9ib3hfbmFtZXNfZnJvbV9zZWN0aW9uIGJ1ZiA9XG4gIEJ5dGVzLnN1YiBidWYgYm94X25hbWVzX29mZnNldCBib3hfbmFtZXNfbGVuZ3RoXG5cbmxldCB1cGRhdGVfYm94X25hbWVzIGJ1ZiBib3hfbmFtZXMgPVxuICBsZXQgbGVuID0gQnl0ZXMubGVuZ3RoIGJveF9uYW1lcyBpblxuICBCeXRlcy5ibGl0IGJveF9uYW1lcyAwIGJ1ZiBib3hfbmFtZXNfb2Zmc2V0IGxlbiA7XG4gIGxldCBjaGVja3N1bSA9IGNvbXB1dGVfY2hlY2tzdW0gYnVmIDAgYm94X25hbWVzX3NlY3Rpb25fZGF0YV9sZW5ndGggaW5cbiAgQnl0ZXMuc2V0X3VpbnQxNl9sZSBidWYgY2hlY2tzdW1fb2Zmc2V0IGNoZWNrc3VtXG5cbigqIC0tLS0tIFRFQU0gLS0tLS0gKilcblxubGV0IGVtcHR5X3BrbW4gKCkgPVxuICBCeXRlcy5jcmVhdGUgcGttbl9kYXRhX3NpemVcblxubGV0IGV4dHJhY3RfdGVhbV9mcm9tX3NlY3Rpb24gYnVmID1cbiAgKCpsZXQgbmIgPSBCeXRlcy5nZXRfaW50MzJfbGUgYnVmIHRlYW1fc2l6ZV9vZmZzZXQgfD4gVXRpbHMudWludDMyX3RvX2ludCBpblxuICBsZXQgbmIgPSBpZiBuYiA+IDYgdGhlbiA2IGVsc2UgbmIgaW4qKVxuICBsZXQgbmIgPSA2IGluXG4gIGxldCByZWMgZXh0cmFjdF9wa21ucyBhY2MgaSA9XG4gICAgaWYgaSA8IDAgdGhlbiBhY2NcbiAgICBlbHNlIChcbiAgICAgIGxldCBhZGRyID0gdGVhbV9kYXRhX29mZnNldCArIHBrbW5fZGF0YV9zaXplKmkgaW5cbiAgICAgIGxldCBwa21uID0gQnl0ZXMuc3ViIGJ1ZiBhZGRyIHBrbW5fZGF0YV9zaXplIGluXG4gICAgICBleHRyYWN0X3BrbW5zIChwa21uOjphY2MpIChpLTEpXG4gICAgKVxuICBpblxuICBleHRyYWN0X3BrbW5zIFtdIChuYi0xKVxuXG5sZXQgdXBkYXRlX3RlYW0gYnVmIHBrbW5zID1cbiAgbGV0IGxlbiA9IExpc3QubGVuZ3RoIHBrbW5zIHw+IEludDMyLm9mX2ludCBpblxuICBCeXRlcy5zZXRfaW50MzJfbGUgYnVmIHRlYW1fc2l6ZV9vZmZzZXQgbGVuIDtcbiAgbGV0IHVwZGF0ZV9wa21uIGkgcGttbiA9XG4gICAgbGV0IGFkZHIgPSB0ZWFtX2RhdGFfb2Zmc2V0ICsgcGttbl9kYXRhX3NpemUqaSBpblxuICAgIEJ5dGVzLmJsaXQgcGttbiAwIGJ1ZiBhZGRyIHBrbW5fZGF0YV9zaXplXG4gIGluXG4gIExpc3QuaXRlcmkgdXBkYXRlX3BrbW4gcGttbnMgO1xuICBsZXQgY2hlY2tzdW0gPSBjb21wdXRlX2NoZWNrc3VtIGJ1ZiAwIHRlYW1faXRlbXNfc2VjdGlvbl9kYXRhX2xlbmd0aCBpblxuICBCeXRlcy5zZXRfdWludDE2X2xlIGJ1ZiBjaGVja3N1bV9vZmZzZXQgY2hlY2tzdW1cbiIsIlxudHlwZSB1bm9wID0gT0lkIHwgT05lZyB8IE9Ob3QgfCBPQk5vdFxudHlwZSBiaW5vcCA9IE9BZGQgfCBPU3ViIHwgT011bCB8IE9EaXYgfCBPTW9kXG4gICAgICAgICAgIHwgT0FuZCB8IE9Yb3IgfCBPT3IgfCBPTFNoaWZ0IHwgT1JTaGlmdFxuICAgICAgICAgICB8IE9FcSB8IE9OZXEgfCBPQk9yIHwgT0JBbmRcblxudHlwZSBtZXRhX2V4cHIgPVxuICB8IE1Db25zdCBvZiBpbnQzMlxuICB8IE1CaW5hcnkgb2YgYmlub3AgKiBtZXRhX2V4cHIgKiBtZXRhX2V4cHJcbiAgfCBNVW5hcnkgb2YgdW5vcCAqIG1ldGFfZXhwclxuICB8IE1WYXIgb2Ygc3RyaW5nXG4gIHwgTUNvbmQgb2YgbWV0YV9leHByICogbWV0YV9leHByICogbWV0YV9leHByXG5cbnR5cGUgZGVmX3ZhbCA9IEhOb25lIHwgSFN0cmluZyBvZiBzdHJpbmcgfCBISW50IG9mIGludDMyIHwgSEJvb2wgb2YgYm9vbFxudHlwZSBkZWZpbml0aW9uID0gUGFyYW0gb2Ygc3RyaW5nICogZGVmX3ZhbCB8IFZhckRlZiBvZiBzdHJpbmcgKiBib29sICogbWV0YV9leHByXG50eXBlIGhlYWRlcnMgPSBkZWZpbml0aW9uIGxpc3RcblxubW9kdWxlIFN0ck1hcCA9IE1hcC5NYWtlKFN0cmluZylcbnR5cGUgZW52ID0gaW50MzIgU3RyTWFwLnRcbmV4Y2VwdGlvbiBWYXJOb3RGb3VuZCBvZiBzdHJpbmdcblxubGV0IGdldF9wYXJhbSBoZWFkZXJzIG5hbWUgPVxuICBsZXQgcmVjIGF1eCBsc3QgPVxuICAgIG1hdGNoIGxzdCB3aXRoXG4gICAgfCBbXSAtPiBITm9uZVxuICAgIHwgKFZhckRlZiBfKTo6bHN0IC0+IGF1eCBsc3RcbiAgICB8IChQYXJhbSAobix2KSk6Ol8gd2hlbiBTdHJpbmcuZXF1YWwgbiBuYW1lIC0+IHZcbiAgICB8IChQYXJhbSBfKTo6bHN0IC0+IGF1eCBsc3RcbiAgaW5cbiAgYXV4IGhlYWRlcnNcblxubGV0IGV2YWxfdW5hcnkgb3AgaSA9XG4gIG1hdGNoIG9wIHdpdGhcbiAgfCBPSWQgLT4gaVxuICB8IE9OZWcgLT4gSW50MzIubmVnIGlcbiAgfCBPTm90IC0+IEludDMyLmxvZ25vdCBpXG4gIHwgT0JOb3QgLT4gaWYgSW50MzIuZXF1YWwgaSBJbnQzMi56ZXJvIHRoZW4gSW50MzIub25lIGVsc2UgSW50MzIuemVyb1xuXG5sZXQgZXZhbF9iaW5hcnkgb3AgaTEgaTIgPVxuICBtYXRjaCBvcCB3aXRoXG4gIHwgT0FkZCAtPiBJbnQzMi5hZGQgaTEgaTJcbiAgfCBPU3ViIC0+IEludDMyLnN1YiBpMSBpMlxuICB8IE9NdWwgLT4gSW50MzIubXVsIGkxIGkyXG4gIHwgT0RpdiAtPiBJbnQzMi51bnNpZ25lZF9kaXYgaTEgaTJcbiAgfCBPTW9kIC0+IEludDMyLnVuc2lnbmVkX3JlbSBpMSBpMlxuICB8IE9BbmQgLT4gSW50MzIubG9nYW5kIGkxIGkyXG4gIHwgT1hvciAtPiBJbnQzMi5sb2d4b3IgaTEgaTJcbiAgfCBPT3IgLT4gSW50MzIubG9nb3IgaTEgaTJcbiAgfCBPTFNoaWZ0IC0+IEludDMyLnNoaWZ0X2xlZnQgaTEgKFV0aWxzLnVpbnQzMl90b19pbnQgaTIpXG4gIHwgT1JTaGlmdCAtPiBJbnQzMi5zaGlmdF9yaWdodF9sb2dpY2FsIGkxIChVdGlscy51aW50MzJfdG9faW50IGkyKVxuICB8IE9FcSAtPiBpZiBJbnQzMi5lcXVhbCBpMSBpMiB0aGVuIEludDMyLm9uZSBlbHNlIEludDMyLnplcm9cbiAgfCBPTmVxIC0+IGlmIEludDMyLmVxdWFsIGkxIGkyIHRoZW4gSW50MzIuemVybyBlbHNlIEludDMyLm9uZVxuICB8IE9CT3IgLT5cbiAgICBpZiBJbnQzMi5lcXVhbCBpMSBJbnQzMi56ZXJvICYmIEludDMyLmVxdWFsIGkyIEludDMyLnplcm9cbiAgICB0aGVuIEludDMyLnplcm8gZWxzZSBJbnQzMi5vbmVcbiAgfCBPQkFuZCAtPlxuICAgIGlmIEludDMyLmVxdWFsIGkxIEludDMyLnplcm8gfHwgSW50MzIuZXF1YWwgaTIgSW50MzIuemVyb1xuICAgIHRoZW4gSW50MzIuemVybyBlbHNlIEludDMyLm9uZVxuXG5sZXQgZXZhbF9tZXRhX2V4cHIgZW52IGUgPVxuICBsZXQgcmVjIGF1eCBlID1cbiAgICBtYXRjaCBlIHdpdGhcbiAgICB8IE1Db25zdCBpIC0+IGlcbiAgICB8IE1WYXIgc3RyIC0+XG4gICAgICBpZiBTdHJNYXAubWVtIHN0ciBlbnZcbiAgICAgIHRoZW4gU3RyTWFwLmZpbmQgc3RyIGVudlxuICAgICAgZWxzZSByYWlzZSAoVmFyTm90Rm91bmQgc3RyKVxuICAgIHwgTVVuYXJ5IChvcCwgZSkgLT5cbiAgICAgIGxldCBpID0gYXV4IGUgaW5cbiAgICAgIGV2YWxfdW5hcnkgb3AgaVxuICAgIHwgTUJpbmFyeSAob3AsIGUxLCBlMikgLT5cbiAgICAgIGxldCBpMSA9IGF1eCBlMSBhbmQgaTIgPSBhdXggZTIgaW5cbiAgICAgIGV2YWxfYmluYXJ5IG9wIGkxIGkyXG4gICAgfCBNQ29uZCAoZTAsIGUxLCBlMikgLT5cbiAgICAgIGxldCBpMCA9IGF1eCBlMCBpblxuICAgICAgaWYgSW50MzIuZXF1YWwgaTAgSW50MzIuemVybyB0aGVuIGF1eCBlMiBlbHNlIGF1eCBlMVxuICBpblxuICBhdXggZVxuXG5sZXQgZW1wdHlfZW52ID0gU3RyTWFwLmVtcHR5XG5cbmxldCBlbnZfZnJvbV9oZWFkZXJzIGZtdCBoZWFkZXJzID1cbiAgbGV0IHRyZWF0X2RlZiAocHJpbnRlZCwgYWNjKSBkZWYgPVxuICAgIG1hdGNoIGRlZiB3aXRoXG4gICAgfCBQYXJhbSBfIC0+IChwcmludGVkLCBhY2MpXG4gICAgfCBWYXJEZWYgKHN0ciwgcHJpbnQsIGV4cHIpIC0+XG4gICAgICBsZXQgaSA9IGV2YWxfbWV0YV9leHByIGFjYyBleHByIGluXG4gICAgICBpZiBwcmludCB0aGVuIEZvcm1hdC5mcHJpbnRmIGZtdCBcIiVzID0gJWxpICglI2x4KUAuXCIgc3RyIGkgaSA7XG4gICAgICAocHJpbnRlZCB8fCBwcmludCwgU3RyTWFwLmFkZCBzdHIgaSBhY2MpXG4gIGluXG4gIGxldCAocHJpbnRlZCwgcmVzKSA9XG4gICAgTGlzdC5mb2xkX2xlZnQgdHJlYXRfZGVmIChmYWxzZSwgU3RyTWFwLmVtcHR5KSBoZWFkZXJzIGluXG4gIGlmIHByaW50ZWQgdGhlbiBGb3JtYXQuZnByaW50ZiBmbXQgXCJALlwiIDsgcmVzXG5cbmxldCBjb25jYXRfZW52IGVudjEgZW52MiA9XG4gIFN0ck1hcC5mb2xkIChmdW4gayB2IGFjYyAtPiBTdHJNYXAuYWRkIGsgdiBhY2MpIGVudjIgZW52MVxuIiwiXG50eXBlIHJlc3VsdCA9IFxuICB8IENvbnQgb2YgKEZvcm1hdC5mb3JtYXR0ZXIgLT4gc3RyaW5nIC0+IHJlc3VsdClcbiAgfCBOb0NvbnRcblxubGV0IHJlYyBtYWluIGZtdCA9XG4gIEZvcm1hdC5mcHJpbnRmIGZtdCBcIlBsZWFzZSBlbnRlciBsb3ctUElEOiBAP1wiIDtcbiAgQ29udCBtYWluXzFcblxuYW5kIG1haW5fMSBmbXQgc3RyID1cbiAgbGV0IGxwaWQgPSBTY2FuZi5zc2NhbmYgc3RyIFwiICVsaVwiIChmdW4gaSAtPiBpKSBpblxuICBGb3JtYXQuZnByaW50ZiBmbXQgXCJQbGVhc2UgZW50ZXIgaGlnaC1QSUQ6IEA/XCIgO1xuICBDb250IChtYWluXzIgbHBpZClcblxuYW5kIG1haW5fMiBscGlkIGZtdCBzdHIgPVxuICBsZXQgaHBpZCA9IFNjYW5mLnNzY2FuZiBzdHIgXCIgJWxpXCIgKGZ1biBpIC0+IGkpIGluXG4gIGxldCBwaWQgPSBTdHJ1Y3R1cmUuaW50MzJfZnJvbV9sb3dfaGlnaCBscGlkIGhwaWQgaW5cblxuICBGb3JtYXQuZnByaW50ZiBmbXQgXCJQbGVhc2UgZW50ZXIgb3JpZ2luYWwgdHJhaW5lciB2aXNpYmxlIFRJRDogQD9cIiA7XG4gIENvbnQgKG1haW5fMyBwaWQpXG5cbmFuZCBtYWluXzMgcGlkIGZtdCBzdHIgPVxuICBsZXQgdmlkID0gU2NhbmYuc3NjYW5mIHN0ciBcIiAlbGlcIiAoZnVuIGkgLT4gaSkgaW5cbiAgRm9ybWF0LmZwcmludGYgZm10IFwiUGxlYXNlIGVudGVyIG9yaWdpbmFsIHRyYWluZXIgc2VjcmV0IFRJRDogQD9cIiA7XG4gIENvbnQgKG1haW5fNCBwaWQgdmlkKVxuXG5hbmQgbWFpbl80IHBpZCB2aWQgZm10IHN0ciA9XG4gIGxldCBzaWQgPSBTY2FuZi5zc2NhbmYgc3RyIFwiICVsaVwiIChmdW4gaSAtPiBpKSBpblxuICBsZXQgdGlkID0gU3RydWN0dXJlLmludDMyX2Zyb21fbG93X2hpZ2ggdmlkIHNpZCBpblxuXG4gIGxldCBwa21uID0geyBTdHJ1Y3R1cmUucGlkPXBpZCA7IFN0cnVjdHVyZS5vdGlkPXRpZCB9IGluXG4gIGxldCBtaXNjX3BvcyA9IFN0cnVjdHVyZS5zdWJzdHJ1Y3R1cmVfcG9zaXRpb24gcGttbiAnTScgaW5cbiAgbGV0IGl2ZWFfb2Zmc2V0ID0gU3RydWN0dXJlLml2ZWFfb2Zmc2V0IHBrbW4gaW5cbiAgRm9ybWF0LmZwcmludGYgZm10IFwiTWlzYyBzdWJzdHJ1Y3R1cmUgcG9zaXRpb246ICVkQC5cIiAobWlzY19wb3MrMSkgO1xuICBGb3JtYXQuZnByaW50ZiBmbXQgXCJJVkVBIG9mZnNldDogJSN4QC5cIiBpdmVhX29mZnNldCA7XG5cbiAgRm9ybWF0LmZwcmludGYgZm10IFwiUGxlYXNlIGVudGVyIGxvdy1JVkVBOiBAP1wiIDtcbiAgQ29udCAobWFpbl81IHBrbW4pXG5cbmFuZCBtYWluXzUgcGttbiBmbXQgc3RyID1cbiAgbGV0IGxpdmVhID0gU2NhbmYuc3NjYW5mIHN0ciBcIiAlbGlcIiAoZnVuIGkgLT4gaSkgaW5cbiAgRm9ybWF0LmZwcmludGYgZm10IFwiUGxlYXNlIGVudGVyIGhpZ2gtSVZFQTogQD9cIiA7XG4gIENvbnQgKG1haW5fNiBwa21uIGxpdmVhKVxuXG5hbmQgbWFpbl82IHBrbW4gbGl2ZWEgZm10IHN0ciA9XG4gIGxldCBoaXZlYSA9IFNjYW5mLnNzY2FuZiBzdHIgXCIgJWxpXCIgKGZ1biBpIC0+IGkpIGluXG4gIGxldCBpdmVhID0gU3RydWN0dXJlLmludDMyX2Zyb21fbG93X2hpZ2ggbGl2ZWEgaGl2ZWEgaW5cbiAgbGV0IHVpdmVhID0gU3RydWN0dXJlLmRlY3J5cHRfYWxpZ25lZF9pbnQzMiBwa21uIGl2ZWEgaW5cbiAgRm9ybWF0LmZwcmludGYgZm10IFwiVW5lbmNyeXB0ZWQgSVZFQSBkYXRhOiAlI2x4QC5cIiB1aXZlYSA7XG4gIGxldCAoaHAsIGF0aywgZGVmLCBzcGVlZCwgc3BfYXRrLCBzcF9kZWYsIGRhdGEpID0gU3RydWN0dXJlLml2ZWFfZGF0YV90b19pdnMgdWl2ZWEgaW5cbiAgRm9ybWF0LmZwcmludGYgZm10IFwiUG9rZW1vbiBJVnMgKGhwIGF0ayBkZWYgc3BlZWQgc3BfYXRrIHNwX2RlZik6ICVsZCAlbGQgJWxkICVsZCAlbGQgJWxkQC5cIlxuICAgIGhwIGF0ayBkZWYgc3BlZWQgc3BfYXRrIHNwX2RlZiA7XG5cbiAgRm9ybWF0LmZwcmludGYgZm10IFwiTWF4aW5nIElWcy4uLkAuXCIgO1xuICBsZXQgaXYgPSBJbnQzMi5vZl9pbnQgMzEgaW5cbiAgbGV0IHVpdmVhJyA9IFN0cnVjdHVyZS5pdnNfdG9faXZlYV9kYXRhIChpdiwgaXYsIGl2LCBpdiwgaXYsIGl2LCBkYXRhKSBpblxuICBGb3JtYXQuZnByaW50ZiBmbXQgXCJOZXcgdW5lbmNyeXB0ZWQgSVZFQSBkYXRhOiAlI2x4QC5cIiB1aXZlYScgO1xuICBsZXQgaXZlYSA9IFN0cnVjdHVyZS5lbmNyeXB0X2FsaWduZWRfaW50MzIgcGttbiB1aXZlYScgaW5cbiAgbGV0IChsaXZlYSwgaGl2ZWEpID0gU3RydWN0dXJlLmludDMyX3RvX2xvd19oaWdoIGl2ZWEgaW5cbiAgRm9ybWF0LmZwcmludGYgZm10IFwiTmV3IGxvdy1JVkVBOiAlI2x4QC5cIiBsaXZlYSA7XG4gIEZvcm1hdC5mcHJpbnRmIGZtdCBcIk5ldyBoaWdoLUlWRUE6ICUjbHhALlwiIGhpdmVhIDtcbiAgbGV0IGNoZWNrc3VtX2RpZmYgPSBTdHJ1Y3R1cmUuY2hlY2tzdW1fZGlmZl9mb3JfYWxpZ25lZF9pbnQzMiB1aXZlYSB1aXZlYScgaW5cbiAgRm9ybWF0LmZwcmludGYgZm10IFwiQ2hlY2tzdW0gZGlmZjogJSNseEAuXCIgY2hlY2tzdW1fZGlmZiA7XG4gIE5vQ29udFxuIiwiXG50eXBlIHNpZ24gPSBpbnRcblxudHlwZSByZWdpc3RlciA9IGludFxuXG50eXBlIGNvbmRpdGlvbmFsID0gRVEgfCBORSB8IENTIHwgSFMgfCBDQyB8IExPIHwgTUkgfCBQTCBcbiAgICAgICAgICAgICAgICAgfCBWUyB8IFZDIHwgSEkgfCBMUyB8IEdFIHwgTFQgfCBHVCB8IExFIHwgQUxcbnR5cGUgbGRyX3N0cl90eXBlID0gQiB8IFNCIHwgSCB8IFNIIHwgVyB8IFQgfCBCVFxudHlwZSBhZGRyZXNzaW5nX3R5cGUgPSBPZmZzZXQgfCBQcmVJbmRleGVkIHwgUG9zdEluZGV4ZWRcblxudHlwZSBzY2FsZV90eXBlID0gTFNMIG9mIGludCB8IExTUiBvZiBpbnQgfCBBU1Igb2YgaW50IHwgUk9SIG9mIGludCB8IFJSWFxudHlwZSBvcGVyYW5kID0gSW1tZWRpYXRlIG9mIGludDMyIHwgUmVnaXN0ZXIgb2YgcmVnaXN0ZXIgfCBTY2FsZWRSZWdpc3RlciBvZiByZWdpc3RlciAqIHNjYWxlX3R5cGVcbnR5cGUgcmVnaXN0ZXJfb2Zmc2V0ID0gT0ltbWVkaWF0ZSBvZiByZWdpc3RlciAqIHNpZ24gKiBpbnQzMiB8IE9SZWdpc3RlciBvZiByZWdpc3RlciAqIHNpZ24gKiByZWdpc3RlciB8IE9TY2FsZWRSZWdpc3RlciBvZiByZWdpc3RlciAqIHNpZ24gKiByZWdpc3RlciAqIHNjYWxlX3R5cGVcblxudHlwZSBkYXRhX3Byb2NfaW5zdHIgPSBBREMgfCBTQkMgfCBCSUMgfCBBTkQgKCogZm9yIEpQOiAqKSB8IEFERCB8IFNVQiB8IE9SUiB8IEVPUlxudHlwZSBtb3ZfaW5zdHIgPSBNT1YgfCBNVk5cbnR5cGUgbWVtX2luc3RyID0gTERSIHwgU1RSXG5cbnR5cGUgYXJtID1cbiAgfCBDdXN0b20gb2YgaW50MzJcbiAgfCBNZW0gb2YgeyBpbnN0cjogbWVtX2luc3RyIDsgdHlwOiBsZHJfc3RyX3R5cGUgOyBjb25kOiBjb25kaXRpb25hbCA7IHJkOiByZWdpc3RlciA7IHJvOiByZWdpc3Rlcl9vZmZzZXQgKiBhZGRyZXNzaW5nX3R5cGUgfVxuICB8IE1vdiBvZiB7IGluc3RyOiBtb3ZfaW5zdHIgOyBzOmJvb2wgOyBjb25kOiBjb25kaXRpb25hbCA7IHJkOiByZWdpc3RlciA7IHJzOiBvcGVyYW5kIH1cbiAgfCBEYXRhUHJvYyBvZiB7IGluc3RyOiBkYXRhX3Byb2NfaW5zdHIgOyBzOmJvb2wgOyBjb25kOiBjb25kaXRpb25hbCA7IHJkOiByZWdpc3RlciA7IHJuOiByZWdpc3RlciA7IG9wMjogb3BlcmFuZCB9XG4gIHwgQnJhbmNoIG9mIHsgbDpib29sIDsgY29uZDogY29uZGl0aW9uYWwgOyB0YXJnZXQ6IGludDMyIH1cbiAgfCBCcmFuY2hYIG9mIHsgbDpib29sIDsgY29uZDogY29uZGl0aW9uYWwgOyBybTogcmVnaXN0ZXIgfVxuICAoKiBCTFhfaW1tIGlzIG5vdCBzdXBwb3J0ZWQgeWV0ICopXG5cbm9wZW4gSW50MzJcblxuZXhjZXB0aW9uIEludmFsaWRDb21tYW5kXG5cbmxldCBhMSA9IDBcbmxldCBhMiA9IDFcbmxldCBhMyA9IDJcbmxldCBhNCA9IDNcbmxldCB2MSA9IDRcbmxldCB2MiA9IDVcbmxldCB2MyA9IDZcbmxldCB2NCA9IDdcbmxldCB2NSA9IDhcbmxldCB2NiA9IDlcbmxldCB2NyA9IDEwXG5sZXQgdjggPSAxMVxubGV0IHNiID0gOVxubGV0IHNsID0gMTBcbmxldCBmcCA9IDExXG5sZXQgaXAgPSAxMlxubGV0IHNwID0gMTNcbmxldCBsciA9IDE0XG5sZXQgcGMgPSAxNVxuXG5sZXQgc2lnbl9wbHVzID0gMVxubGV0IHNpZ25fbWludXMgPSAwXG5cbmxldCBpbnQxID0gMGIxXG5sZXQgbWFzazEgPSBpbnQxIHw+IG9mX2ludFxubGV0IGludDIgPSAwYjExXG5sZXQgbWFzazIgPSBpbnQyIHw+IG9mX2ludFxubGV0IGludDQgPSAwYjExMTFcbmxldCBtYXNrNCA9IGludDQgfD4gb2ZfaW50XG5sZXQgaW50OCA9IDBiMTExMTExMTFcbmxldCBtYXNrOCA9IGludDggfD4gb2ZfaW50XG5sZXQgaW50OSA9IDBiMTExMTExMTExXG5sZXQgbWFzazkgPSBpbnQ5IHw+IG9mX2ludFxubGV0IGludDEyID0gMGIxMTExMTExMTExMTFcbmxldCBtYXNrMTIgPSBpbnQxMiB8PiBvZl9pbnRcbmxldCBpbnQyNCA9IDBiMTExMTExMTExMTExXzExMTExMTExMTExMVxubGV0IG1hc2syNCA9IGludDI0IHw+IG9mX2ludFxuXG5sZXQgY29uZGl0aW9uX2NvZGUgYyA9XG4gIGJlZ2luIG1hdGNoIGMgd2l0aFxuICB8IEVRIC0+IDBiMDAwMCB8IE5FIC0+IDBiMDAwMSB8IENTIHwgSFMgLT4gMGIwMDEwIHwgQ0MgfCBMTyAtPiAwYjAwMTFcbiAgfCBNSSAtPiAwYjAxMDAgfCBQTCAtPiAwYjAxMDEgfCBWUyAtPiAwYjAxMTAgfCBWQyAtPiAwYjAxMTFcbiAgfCBISSAtPiAwYjEwMDAgfCBMUyAtPiAwYjEwMDEgfCBHRSAtPiAwYjEwMTAgfCBMVCAtPiAwYjEwMTEgfCBHVCAtPiAwYjExMDAgfCBMRSAtPiAwYjExMDEgfCBBTCAtPiAwYjExMTBcbiAgZW5kXG4gIHw+IG9mX2ludFxuXG5sZXQgYWRkX2NvbmRpdGlvbl9jb2RlIGMgdiA9XG4gIHNoaWZ0X2xlZnQgKGNvbmRpdGlvbl9jb2RlIGMpIDI4XG4gIHw+IGxvZ29yIHZcblxubGV0IGFkZF9ybl9jb2RlIHJuIHYgPVxuICBzaGlmdF9sZWZ0IChvZl9pbnQgcm4pIDE2XG4gIHw+IGxvZ29yIHZcblxubGV0IGFkZF9yZF9jb2RlIHJkIHYgPVxuICBzaGlmdF9sZWZ0IChvZl9pbnQgcmQpIDEyXG4gIHw+IGxvZ29yIHZcblxubGV0IGFkZF9ybV9jb2RlIHJtIHYgPVxuICBvZl9pbnQgcm1cbiAgfD4gbG9nb3IgdlxuXG5sZXQgcmVnaXN0ZXJfb2ZfcmVnaXN0ZXJfb2Zmc2V0IHJvID1cbiAgbWF0Y2ggcm8gd2l0aFxuICB8IE9JbW1lZGlhdGUgKHIsIF8sIF8pIHwgT1JlZ2lzdGVyIChyLCBfLCBfKSB8IE9TY2FsZWRSZWdpc3RlciAociwgXywgXywgXykgLT4gclxuXG5sZXQgcm90YXRlX3JpZ2h0IHYgPVxuICBsZXQgbGIgPSBsb2dhbmQgdiBtYXNrMSBpblxuICBsZXQgdiA9IHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgdiAxIGluXG4gIGxvZ29yIHYgKHNoaWZ0X2xlZnQgbGIgMzEpXG5cbmxldCByb3RhdGVfbGVmdCB2ID1cbiAgbGV0IGhiID0gbG9nYW5kIHYgKHNoaWZ0X2xlZnQgbWFzazEgMzEpIGluXG4gIGxldCB2ID0gc2hpZnRfbGVmdCB2IDEgaW5cbiAgbG9nb3IgdiAoc2hpZnRfcmlnaHRfbG9naWNhbCBoYiAzMSlcblxubGV0IGRlY29tcG9zZV9pbW1lZGlhdGUgaW1tID1cbiAgbGV0IHJlYyBhdXggbiBpbW0gPVxuICAgIGlmIG4gPiBpbnQ0IHRoZW4gW11cbiAgICBlbHNlXG4gICAgICBsZXQgb3RoZXJzID0gYXV4IChuKzEpIChyb3RhdGVfbGVmdCAocm90YXRlX2xlZnQgaW1tKSkgaW5cbiAgICAgIGxldCBpbW04ID0gbG9nYW5kIGltbSBtYXNrOCBpblxuICAgICAgaWYgZXF1YWwgaW1tOCBpbW0gdGhlbiAobiwgaW1tOCk6Om90aGVycyBlbHNlIG90aGVyc1xuICBpblxuICBsZXQgcmVzID0gYXV4IDAgaW1tIGluXG4gIGlmIHJlcyA9IFtdIHRoZW4gcmFpc2UgSW52YWxpZENvbW1hbmQgZWxzZSByZXNcblxubGV0IGFkZHJfbW9kZV8xIHJzID1cbiAgbGV0IHBvc3NpYmlsaXRpZXMgPVxuICAgIG1hdGNoIHJzIHdpdGhcbiAgICB8IEltbWVkaWF0ZSBpIC0+XG4gICAgICBkZWNvbXBvc2VfaW1tZWRpYXRlIGlcbiAgICAgIHw+IExpc3QubWFwIChmdW4gKHJyLCBpbW04KSAtPlxuICAgICAgICAoMSwgbG9nb3IgaW1tOCAoc2hpZnRfbGVmdCAob2ZfaW50IHJyKSA4KSlcbiAgICAgIClcbiAgICB8IFJlZ2lzdGVyIChybSkgLT5cbiAgICAgIFsoMCwgb2ZfaW50IHJtKV1cbiAgICB8IFNjYWxlZFJlZ2lzdGVyIF8gLT4gZmFpbHdpdGggXCJOb3QgaW1wbGVtZW50ZWRcIlxuICBpblxuICBwb3NzaWJpbGl0aWVzIHw+XG4gIExpc3QubWFwIChmdW4gKGltbSwgdikgLT5cbiAgICBsZXQgaSA9IHNoaWZ0X2xlZnQgKG9mX2ludCBpbW0pIDI1IGluXG4gICAgbG9nb3IgdiBpXG4gIClcblxubGV0IHBfYW5kX3cgYWRkcl90eXAgPVxuICBtYXRjaCBhZGRyX3R5cCB3aXRoXG4gIHwgT2Zmc2V0IC0+ICgxLDApXG4gIHwgUHJlSW5kZXhlZCAtPiAoMSwxKVxuICB8IFBvc3RJbmRleGVkIC0+ICgwLDApXG5cbmxldCBhZGRyX21vZGVfMiBybyBhZGRyX3R5cCA9ICgqIExvYWQgYW5kIHN0b3JlIG9mIHdvcmQgYW5kIHVieXRlICopXG4gIGxldCAoc2lnbiwgcmVnLCB2KSA9XG4gICAgbWF0Y2ggcm8gd2l0aFxuICAgIHwgT0ltbWVkaWF0ZSAoXywgc2lnbiwgdikgLT5cbiAgICAgIGlmIHVuc2lnbmVkX2NvbXBhcmUgdiBtYXNrMTIgPiAwIHRoZW4gcmFpc2UgSW52YWxpZENvbW1hbmQgO1xuICAgICAgKHNpZ24sIDAsIHYpXG4gICAgfCBPUmVnaXN0ZXIgKF8sIHNpZ24sIHJtKSAtPlxuICAgICAgKHNpZ24sIDEsIG9mX2ludCBybSlcbiAgICB8IE9TY2FsZWRSZWdpc3RlciBfIC0+IGZhaWx3aXRoIFwiTm90IGltcGxlbWVudGVkXCJcbiAgaW5cbiAgbGV0IChwLCB3KSA9IHBfYW5kX3cgYWRkcl90eXAgaW5cbiAgbGV0IGkgPSBzaGlmdF9sZWZ0IChvZl9pbnQgcmVnKSAyNSBpblxuICBsZXQgdSA9IHNoaWZ0X2xlZnQgKG9mX2ludCBzaWduKSAyMyBpblxuICBsZXQgcCA9IHNoaWZ0X2xlZnQgKG9mX2ludCBwKSAyNCBpblxuICBsZXQgdyA9IHNoaWZ0X2xlZnQgKG9mX2ludCB3KSAyMSBpblxuICBsb2dvciB2IHUgfD4gbG9nb3IgcCB8PiBsb2dvciB3IHw+IGxvZ29yIGlcblxubGV0IGFkZHJfbW9kZV8zIHJvIGFkZHJfdHlwID0gKCogT3RoZXIgbG9hZCBhbmQgc3RvcmUgKilcbiAgbGV0IChzaWduLCBpbW0sIHYpID1cbiAgICBtYXRjaCBybyB3aXRoXG4gICAgfCBPSW1tZWRpYXRlIChfLCBzaWduLCB2KSAtPlxuICAgICAgaWYgdW5zaWduZWRfY29tcGFyZSB2IG1hc2s4ID4gMCB0aGVuIHJhaXNlIEludmFsaWRDb21tYW5kIDtcbiAgICAgIGxldCBpbW1lZEwgPSBsb2dhbmQgbWFzazQgdiBpblxuICAgICAgbGV0IGltbWVkSCA9IGxvZ2FuZCBtYXNrNCAoc2hpZnRfcmlnaHRfbG9naWNhbCB2IDQpIGluXG4gICAgICAoc2lnbiwgMSwgbG9nb3IgaW1tZWRMIChzaGlmdF9sZWZ0IGltbWVkSCA4KSlcbiAgICB8IE9SZWdpc3RlciAoXywgc2lnbiwgcm0pIC0+XG4gICAgICAoc2lnbiwgMCwgb2ZfaW50IHJtKVxuICAgIHwgT1NjYWxlZFJlZ2lzdGVyIF8gLT4gcmFpc2UgSW52YWxpZENvbW1hbmRcbiAgaW5cbiAgbGV0IChwLCB3KSA9IHBfYW5kX3cgYWRkcl90eXAgaW5cbiAgbGV0IGkgPSBzaGlmdF9sZWZ0IChvZl9pbnQgaW1tKSAyMiBpblxuICBsZXQgdSA9IHNoaWZ0X2xlZnQgKG9mX2ludCBzaWduKSAyMyBpblxuICBsZXQgcCA9IHNoaWZ0X2xlZnQgKG9mX2ludCBwKSAyNCBpblxuICBsZXQgdyA9IHNoaWZ0X2xlZnQgKG9mX2ludCB3KSAyMSBpblxuICBsb2dvciB2IHUgfD4gbG9nb3IgcCB8PiBsb2dvciB3IHw+IGxvZ29yIGlcblxubGV0IHNpZ25lZF9pbW1lZDI0IGkgPVxuICBpZiBlcXVhbCAobG9nYW5kIGkgbWFzazIpIHplcm9cbiAgdGhlblxuICAgIGxldCBpID0gc2hpZnRfcmlnaHQgaSAyIGluXG4gICAgbGV0IG1zOSA9IHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgaSAyMyBpblxuICAgIGlmIGVxdWFsIG1zOSBtYXNrOSB8fCBlcXVhbCBtczkgemVyb1xuICAgIHRoZW4gbG9nYW5kIGkgbWFzazI0XG4gICAgZWxzZSByYWlzZSBJbnZhbGlkQ29tbWFuZFxuICBlbHNlIHJhaXNlIEludmFsaWRDb21tYW5kXG5cbmxldCBsZHJfc3RyX3RvX2JpbmFyeSBpbnN0ciB0eXAgY29uZCByZCAocm4sIGFkZHJfdHlwKSA9XG4gIGxldCBjaGVja19wb3N0X2FkZHIgKCkgPVxuICAgIG1hdGNoIGFkZHJfdHlwIHdpdGhcbiAgICB8IFBvc3RJbmRleGVkIC0+ICgpXG4gICAgfCBfIC0+IHJhaXNlIEludmFsaWRDb21tYW5kXG4gIGluXG4gIGxldCBvcGNvZGUgPSBtYXRjaCBpbnN0ciwgdHlwIHdpdGhcbiAgfCBMRFIsIEIgIC0+IDBiMDEwMF8wMTAxXzAwMDBfMDAwMF8wMDAwXzAwMDBfMDAwMFxuICB8IExEUiwgU0IgLT4gMGIwMDAwXzAwMDFfMDAwMF8wMDAwXzAwMDBfMTEwMV8wMDAwXG4gIHwgTERSLCBIICAtPiAwYjAwMDBfMDAwMV8wMDAwXzAwMDBfMDAwMF8xMDExXzAwMDBcbiAgfCBMRFIsIFNIIC0+IDBiMDAwMF8wMDAxXzAwMDBfMDAwMF8wMDAwXzExMTFfMDAwMFxuICB8IExEUiwgVyAgLT4gMGIwMTAwXzAwMDFfMDAwMF8wMDAwXzAwMDBfMDAwMF8wMDAwXG4gIHwgTERSLCBUICAtPiBjaGVja19wb3N0X2FkZHIgKCkgOyAwYjAxMDBfMDAxMV8wMDAwXzAwMDBfMDAwMF8wMDAwXzAwMDBcbiAgfCBMRFIsIEJUIC0+IGNoZWNrX3Bvc3RfYWRkciAoKSA7IDBiMDEwMF8wMTExXzAwMDBfMDAwMF8wMDAwXzAwMDBfMDAwMFxuICB8IFNUUiwgQiAgLT4gMGIwMTAwXzAxMDBfMDAwMF8wMDAwXzAwMDBfMDAwMF8wMDAwXG4gIHwgU1RSLCBTQiAtPiByYWlzZSBJbnZhbGlkQ29tbWFuZFxuICB8IFNUUiwgSCAgLT4gMGIwMDAwXzAwMDBfMDAwMF8wMDAwXzAwMDBfMTAxMV8wMDAwXG4gIHwgU1RSLCBTSCAtPiByYWlzZSBJbnZhbGlkQ29tbWFuZFxuICB8IFNUUiwgVyAgLT4gMGIwMTAwXzAwMDBfMDAwMF8wMDAwXzAwMDBfMDAwMF8wMDAwXG4gIHwgU1RSLCBUICAtPiBjaGVja19wb3N0X2FkZHIgKCkgOyAwYjAxMDBfMDAxMF8wMDAwXzAwMDBfMDAwMF8wMDAwXzAwMDBcbiAgfCBTVFIsIEJUIC0+IGNoZWNrX3Bvc3RfYWRkciAoKSA7IDBiMDEwMF8wMTEwXzAwMDBfMDAwMF8wMDAwXzAwMDBfMDAwMFxuICBpblxuICBsZXQgdiA9IG9mX2ludCBvcGNvZGUgfD5cbiAgICBhZGRfY29uZGl0aW9uX2NvZGUgY29uZCB8PlxuICAgIGFkZF9ybl9jb2RlIChyZWdpc3Rlcl9vZl9yZWdpc3Rlcl9vZmZzZXQgcm4pIHw+XG4gICAgYWRkX3JkX2NvZGUgcmQgaW5cbiAgbGV0IGFkZHJfbW9kZSA9XG4gICAgbWF0Y2ggdHlwIHdpdGhcbiAgICB8IEIgfCBXIHwgVCB8IEJUIC0+IGFkZHJfbW9kZV8yIHJuIGFkZHJfdHlwXG4gICAgfCBIIHwgU0ggfCBTQiAtPiBhZGRyX21vZGVfMyBybiBhZGRyX3R5cFxuICBpblxuICBbbG9nb3IgdiBhZGRyX21vZGVdXG5cbmxldCBtb3ZfbXZuX3RvX2JpbmFyeSBpbnN0ciBzIGNvbmQgcmQgcnMgPVxuICBsZXQgb3Bjb2RlID0gbWF0Y2ggaW5zdHIgd2l0aFxuICB8IE1PViAtPiAwYjAwMDFfMTAxMF8wMDAwXzAwMDBfMDAwMF8wMDAwXzAwMDBcbiAgfCBNVk4gLT4gMGIwMDAxXzExMTBfMDAwMF8wMDAwXzAwMDBfMDAwMF8wMDAwIGluXG4gIGxldCBzY29kZSA9IGlmIHMgdGhlbiAxIGVsc2UgMCBpblxuICBsZXQgc2NvZGUgPSBzaGlmdF9sZWZ0IChvZl9pbnQgc2NvZGUpIDIwIGluXG4gIGxldCB2ID0gb2ZfaW50IG9wY29kZSB8PlxuICAgIGFkZF9jb25kaXRpb25fY29kZSBjb25kIHw+XG4gICAgYWRkX3JkX2NvZGUgcmQgfD5cbiAgICBsb2dvciBzY29kZSBpblxuICBhZGRyX21vZGVfMSBycyB8PlxuICBMaXN0Lm1hcCAoZnVuIGFkZHJfbW9kZSAtPiBsb2dvciB2IGFkZHJfbW9kZSlcblxubGV0IGNhbGN1bGF0aW9uX3RvX2JpbmFyeSBpbnN0ciBzIGNvbmQgcmQgcm4gb3AyID1cbiAgbGV0IG9wY29kZSA9IG1hdGNoIGluc3RyIHdpdGhcbiAgfCBBREMgLT4gMGIwMDAwXzEwMTBfMDAwMF8wMDAwXzAwMDBfMDAwMF8wMDAwXG4gIHwgU0JDIC0+IDBiMDAwMF8xMTAwXzAwMDBfMDAwMF8wMDAwXzAwMDBfMDAwMFxuICB8IEJJQyAtPiAwYjAwMDFfMTEwMF8wMDAwXzAwMDBfMDAwMF8wMDAwXzAwMDBcbiAgfCBBTkQgLT4gMGIwMDAwXzAwMDBfMDAwMF8wMDAwXzAwMDBfMDAwMF8wMDAwXG4gIHwgQUREIC0+IDBiMDAwMF8xMDAwXzAwMDBfMDAwMF8wMDAwXzAwMDBfMDAwMFxuICB8IFNVQiAtPiAwYjAwMDBfMDEwMF8wMDAwXzAwMDBfMDAwMF8wMDAwXzAwMDBcbiAgfCBPUlIgLT4gMGIwMDAxXzEwMDBfMDAwMF8wMDAwXzAwMDBfMDAwMF8wMDAwXG4gIHwgRU9SIC0+IDBiMDAwMF8wMDEwXzAwMDBfMDAwMF8wMDAwXzAwMDBfMDAwMFxuICBpblxuICBsZXQgc2NvZGUgPSBpZiBzIHRoZW4gMSBlbHNlIDAgaW5cbiAgbGV0IHNjb2RlID0gc2hpZnRfbGVmdCAob2ZfaW50IHNjb2RlKSAyMCBpblxuICBsZXQgdiA9IG9mX2ludCBvcGNvZGUgfD5cbiAgICBhZGRfY29uZGl0aW9uX2NvZGUgY29uZCB8PlxuICAgIGFkZF9yZF9jb2RlIHJkIHw+XG4gICAgYWRkX3JuX2NvZGUgcm4gfD5cbiAgICBsb2dvciBzY29kZSBpblxuICBhZGRyX21vZGVfMSBvcDIgfD5cbiAgTGlzdC5tYXAgKGZ1biBhZGRyX21vZGUgLT4gbG9nb3IgdiBhZGRyX21vZGUpXG5cbmxldCBicmFuY2hfdG9fYmluYXJ5IGwgY29uZCB0YXJnZXQgPVxuICBsZXQgb3Bjb2RlID1cbiAgICBpZiBsXG4gICAgdGhlbiAwYjEwMTFfMDAwMF8wMDAwXzAwMDBfMDAwMF8wMDAwXzAwMDBcbiAgICBlbHNlIDBiMTAxMF8wMDAwXzAwMDBfMDAwMF8wMDAwXzAwMDBfMDAwMFxuICBpblxuICBsZXQgdiA9IG9mX2ludCBvcGNvZGUgfD5cbiAgICBhZGRfY29uZGl0aW9uX2NvZGUgY29uZCBpblxuICBsZXQgaW1tID0gc2lnbmVkX2ltbWVkMjQgKHN1YiB0YXJnZXQgOGwpIGluXG4gIFtsb2dvciB2IGltbV1cblxubGV0IGJyYW5jaHhfdG9fYmluYXJ5IGwgY29uZCBybSA9XG4gIGxldCBvcGNvZGUgPVxuICAgIGlmIGxcbiAgICB0aGVuIDBiMDAwMV8wMDEwXzExMTFfMTExMV8xMTExXzAwMTFfMDAwMFxuICAgIGVsc2UgMGIwMDAxXzAwMTBfMTExMV8xMTExXzExMTFfMDAwMV8wMDAwXG4gIGluXG4gIFtvZl9pbnQgb3Bjb2RlIHw+XG4gIGFkZF9jb25kaXRpb25fY29kZSBjb25kIHw+XG4gIGFkZF9ybV9jb2RlIHJtXVxuXG5sZXQgYXJtX3RvX2JpbmFyeSBhcm0gPVxuICBtYXRjaCBhcm0gd2l0aFxuICB8IEN1c3RvbSBpIC0+IFtpXVxuICB8IE1lbSB7aW5zdHI7dHlwO2NvbmQ7cmQ7cm99IC0+IGxkcl9zdHJfdG9fYmluYXJ5IGluc3RyIHR5cCBjb25kIHJkIHJvXG4gIHwgTW92IHtpbnN0cjtzO2NvbmQ7cmQ7cnN9ICAgLT4gbW92X212bl90b19iaW5hcnkgaW5zdHIgcyBjb25kIHJkIHJzXG4gIHwgRGF0YVByb2Mge2luc3RyO3M7Y29uZDtyZDtybjtvcDJ9IC0+IGNhbGN1bGF0aW9uX3RvX2JpbmFyeSBpbnN0ciBzIGNvbmQgcmQgcm4gb3AyXG4gIHwgQnJhbmNoIHtsO2NvbmQ7dGFyZ2V0fSAtPiBicmFuY2hfdG9fYmluYXJ5IGwgY29uZCB0YXJnZXRcbiAgfCBCcmFuY2hYIHtsO2NvbmQ7cm19IC0+IGJyYW5jaHhfdG9fYmluYXJ5IGwgY29uZCBybVxuXG5sZXQgcmV2ZXJzZV9lbmRpYW5uZXNzIHYgPVxuICBsZXQgdjEgPSBzaGlmdF9sZWZ0IChsb2dhbmQgbWFzazggdikgKDMqOCkgaW5cbiAgbGV0IHYgPSBzaGlmdF9yaWdodF9sb2dpY2FsIHYgOCBpblxuICBsZXQgdjIgPSBzaGlmdF9sZWZ0IChsb2dhbmQgbWFzazggdikgKDIqOCkgaW5cbiAgbGV0IHYgPSBzaGlmdF9yaWdodF9sb2dpY2FsIHYgOCBpblxuICBsZXQgdjMgPSBzaGlmdF9sZWZ0IChsb2dhbmQgbWFzazggdikgKDEqOCkgaW5cbiAgbGV0IHYgPSBzaGlmdF9yaWdodF9sb2dpY2FsIHYgOCBpblxuICBsZXQgdjQgPSBsb2dhbmQgbWFzazggdiBpblxuICBsb2dvciB2MSB2MiB8PiBsb2dvciB2MyB8PiBsb2dvciB2NFxuIiwib3BlbiBJbnQzMlxub3BlbiBDaGFyc2V0XG5vcGVuIFV0aWxzXG5cbmxldCBlb2YgPSAweEZGXG5sZXQgc3BhY2UgPSAweDAwXG5cbmxldCBpbnQ4ID0gMGIxMTExMTExMVxubGV0IG1hc2s4ID0gaW50OCB8PiBvZl9pbnRcblxubGV0IGNvZGVzX2Zvcl9jb21tYW5kIHYgPVxuICBsZXQgdjEgPSBsb2dhbmQgbWFzazggdiBpblxuICBsZXQgdiA9IHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgdiA4IGluXG4gIGxldCB2MiA9IGxvZ2FuZCBtYXNrOCB2IGluXG4gIGxldCB2ID0gc2hpZnRfcmlnaHRfbG9naWNhbCB2IDggaW5cbiAgbGV0IHYzID0gbG9nYW5kIG1hc2s4IHYgaW5cbiAgbGV0IHYgPSBzaGlmdF9yaWdodF9sb2dpY2FsIHYgOCBpblxuICBsZXQgdjQgPSBsb2dhbmQgbWFzazggdiBpblxuICBbIHVpbnQzMl90b19pbnQgdjEgOyB1aW50MzJfdG9faW50IHYyIDsgdWludDMyX3RvX2ludCB2MyA7IHVpbnQzMl90b19pbnQgdjQgXVxuXG5sZXQgY29tbWFuZF9mb3JfY29kZXMgY29kZXMgPVxuICBtYXRjaCBjb2RlcyB3aXRoXG4gIHwgW2MxO2MyO2MzO2M0XSAtPlxuICAgIGxldCB2MSA9IGMxIHw+IG9mX2ludCBpblxuICAgIGxldCB2MiA9IGMyIHw+IG9mX2ludCBpblxuICAgIGxldCB2MyA9IGMzIHw+IG9mX2ludCBpblxuICAgIGxldCB2NCA9IGM0IHw+IG9mX2ludCBpblxuICAgIGxldCB2ID0gc2hpZnRfbGVmdCB2NCA4IGluXG4gICAgbGV0IHYgPSBsb2dvciB2IHYzIGluXG4gICAgbGV0IHYgPSBzaGlmdF9sZWZ0IHYgOCBpblxuICAgIGxldCB2ID0gbG9nb3IgdiB2MiBpblxuICAgIGxldCB2ID0gc2hpZnRfbGVmdCB2IDggaW5cbiAgICBsb2dvciB2IHYxXG4gIHwgXyAtPiBhc3NlcnQgZmFsc2VcblxubGV0IGNvZGVzX3RvX2NoYXJzIGMgPVxuICBMaXN0Lm1hcCB3cml0YWJsZV9jaGFyX2F0IGNcblxubGV0IGNoYXJzX2Zvcl9jb21tYW5kIHYgPVxuICBjb2Rlc19mb3JfY29tbWFuZCB2IHw+IGNvZGVzX3RvX2NoYXJzXG5cbmxldCBwcF9jaGFycyBmbXQgbHN0ID1cbiAgbHN0IHw+IExpc3QuaXRlcmkgKGZ1biBpIHN0ciAtPlxuICAgIEZvcm1hdC5mcHJpbnRmIGZtdCBcIiVzJXNcIiAoaWYgaSA9IDAgdGhlbiBcIlwiIGVsc2UgXCIgXCIpIHN0clxuICApXG5cbmxldCBwcF9jaGFyc19yYXcgZm10IGxzdCA9XG4gIGxzdCB8PiBMaXN0Lml0ZXIgKGZ1biBzdHIgLT5cbiAgICBsZXQgc3RyID0gaWYgc3RyID0gc3BhY2luZ19jaGFyIHRoZW4gXCIgXCIgZWxzZSBzdHIgaW5cbiAgICBGb3JtYXQuZnByaW50ZiBmbXQgXCIlc1wiIHN0clxuICApXG5cbmxldCBpc19jb2RlX3dyaXRhYmxlIGNvZGVzID1cbiAgTGlzdC5mb3JfYWxsIGlzX2NvZGVfYXZhaWxhYmxlIGNvZGVzXG5cbmxldCByZWMgZmlyc3RfY29kZSBmIGNvZGVzID1cbiAgbWF0Y2ggY29kZXMgd2l0aFxuICB8IFtdIC0+IHJhaXNlIE5vdF9mb3VuZFxuICB8IGNvZGU6OmNvZGVzIC0+XG4gICAgaWYgZiBjb2RlIHRoZW4gY29kZVxuICAgIGVsc2UgZmlyc3RfY29kZSBmIGNvZGVzXG5cbmxldCBmaXJzdF93cml0YWJsZV9jb2RlIGNvZGVzID1cbiAgZmlyc3RfY29kZSBpc19jb2RlX3dyaXRhYmxlIGNvZGVzXG5cbmxldCBpc19jb2RlX3dyaXRhYmxlX29yX29uZV9lb2YgY29kZSA9XG4gIChMaXN0LmZpbHRlciAoZnVuIGMgLT4gYyA8PiBlb2YpIGNvZGUgfD4gaXNfY29kZV93cml0YWJsZSkgJiZcbiAgKExpc3QuZm9sZF9sZWZ0IChmdW4gbmIgYyAtPiBpZiBjID0gZW9mIHRoZW4gbmIrMSBlbHNlIG5iKSAwIGNvZGUpIDw9IDFcblxubGV0IHByZWZlcnJlZF9jb2RlIGNvZGVzID1cbiAgdHJ5IGZpcnN0X3dyaXRhYmxlX2NvZGUgY29kZXNcbiAgd2l0aCBOb3RfZm91bmQgLT4gYmVnaW5cbiAgICB0cnkgZmlyc3RfY29kZSBpc19jb2RlX3dyaXRhYmxlX29yX29uZV9lb2YgY29kZXNcbiAgICB3aXRoIE5vdF9mb3VuZCAtPiBMaXN0LmhkIGNvZGVzXG4gIGVuZFxuXG5sZXQgaXNfZnVsbF9vZl9zcGFjZXMgY29kZXMgPVxuICBMaXN0LmZvcl9hbGwgKGZ1biBjIC0+IGMgPSBzcGFjZSkgY29kZXNcbiIsIm9wZW4gSW50MzJcbm9wZW4gVXRpbHNcbm9wZW4gQXJtXG5cbmV4Y2VwdGlvbiBDYW5ub3RPcHRpbWl6ZVxuXG50eXBlIHR3ZWFraW5nX3NldHRpbmdzID1cbiAgfCBOb1R3ZWFraW5nXG4gIHwgVHdlYWtGaXhlZExlbmd0aCBvZiBpbnRcbiAgfCBUd2Vha01pbkxlbmd0aFxuXG5tb2R1bGUgVUludDMyID0gc3RydWN0XG4gIHR5cGUgdCA9IGludDMyXG4gICgqbGV0IGVxdWFsID0gZXF1YWwqKVxuICBsZXQgY29tcGFyZSA9IHVuc2lnbmVkX2NvbXBhcmVcbmVuZFxuXG5tb2R1bGUgVUludDMyU2V0ID0gU2V0Lk1ha2UoVUludDMyKVxuXG5sZXQgcGFkZGluZ19jb2RlID0gQ3VzdG9tIHplcm9cblxubGV0IGNhcnJ5X291dCBpID0gY29tcGFyZSBpIHplcm8gPCAwXG5cbmxldCBjb21wdXRlX2FsbF9jb25zdGFudHMgXyA9XG4gIGxldCByZWMgYWxsX2ltbWVkOCBtYXggYWNjIGkgPVxuICAgIGlmIGVxdWFsIGkgbWF4IHRoZW4gaTo6YWNjXG4gICAgZWxzZSBhbGxfaW1tZWQ4IG1heCAoaTo6YWNjKSAoc3VjYyBpKVxuICBpblxuICBsZXQgaW1tZWQ4ID0gYWxsX2ltbWVkOCAob2ZfaW50IDI1NSkgW10gemVybyBpblxuICBsZXQgaW1tZWQ4ID0gaW1tZWQ4IHw+IExpc3QuZmlsdGVyIChmdW4gaSAtPlxuICAgIE5hbWUuaXNfY29kZV93cml0YWJsZSBbVXRpbHMudWludDMyX3RvX2ludCBpXVxuICApIGluXG4gIGxldCByZWMgYWxsX3JvdGF0aW9ucyBpbml0aWFsIGFjYyBpID1cbiAgICBsZXQgaSA9IEFybS5yb3RhdGVfcmlnaHQgaSB8PiBBcm0ucm90YXRlX3JpZ2h0IGluXG4gICAgaWYgZXF1YWwgaSBpbml0aWFsIHRoZW4gYWNjXG4gICAgZWxzZSBhbGxfcm90YXRpb25zIGluaXRpYWwgKGk6OmFjYykgaVxuICBpblxuICBpbW1lZDggfD4gTGlzdC5tYXAgKGZ1biBpIC0+XG4gICAgYWxsX3JvdGF0aW9ucyBpIFtpXSBpXG4gICkgfD4gTGlzdC5mbGF0dGVuIHw+IFVJbnQzMlNldC5vZl9saXN0XG5cbmxldCBjb25zdGFudHNfc2V0ID0gY29tcHV0ZV9hbGxfY29uc3RhbnRzICgpXG5sZXQgY29uc3RhbnRzX3NldF9ub19jYXJyeSA9XG4gIGNvbnN0YW50c19zZXQgfD4gVUludDMyU2V0LmZpbHRlciAoZnVuIGkgLT4gY2Fycnlfb3V0IGkgfD4gbm90KVxuXG5sZXQgY29uc3RhbnRzID0gY29uc3RhbnRzX3NldCB8PiBVSW50MzJTZXQuZWxlbWVudHNcbmxldCByZXZfY29uc3RhbnRzID0gTGlzdC5yZXYgY29uc3RhbnRzXG5cbmxldCBjb25zdGFudHNfbW92X212biA9XG4gIGxldCBuc2V0ID0gVUludDMyU2V0Lm1hcCBsb2dub3QgY29uc3RhbnRzX3NldCBpblxuICBVSW50MzJTZXQudW5pb24gY29uc3RhbnRzX3NldF9ub19jYXJyeSBuc2V0XG4gIHw+IFVJbnQzMlNldC5yZW1vdmUgSW50MzIuemVybyAoKiBXZSB0cnkgdG8gYXZvaWQgc2V0dGluZyB0aGUgemVybyBmbGFnICopXG4gIHw+IFVJbnQzMlNldC5lbGVtZW50c1xuXG5sZXQgY29uc3RhbnRzX21vdl9tdm5fc3RyaWN0ID1cbiAgbGV0IG5zZXQgPSBVSW50MzJTZXQubWFwIGxvZ25vdCBjb25zdGFudHNfc2V0IGluXG4gIFVJbnQzMlNldC51bmlvbiBjb25zdGFudHNfc2V0IG5zZXRcbiAgfD4gVUludDMyU2V0LmVsZW1lbnRzXG5cbmxldCByZXZfY29uc3RhbnRzX21vdl9tdm4gPSBMaXN0LnJldiBjb25zdGFudHNfbW92X212blxubGV0IHJldl9jb25zdGFudHNfbW92X212bl9zdHJpY3QgPSBMaXN0LnJldiBjb25zdGFudHNfbW92X212bl9zdHJpY3RcblxubGV0IHRyaWVzX2F0X2RlcHRoXzAgPSBbfCAweDEwMDAwIDsgMHgxMDAwMCA7IDB4MTAwMDAgOyAweDIwMCA7IDB4NDAgOyAweDggOyAweDEgfF1cblxubGV0IHJlYyByZW1vdmVfd2hpbGUgZiBsc3QgPVxuICBtYXRjaCBsc3Qgd2l0aFxuICB8IFtdIC0+IFtdXG4gIHwgaSc6OmxzdCB3aGVuIGYgaScgLT4gcmVtb3ZlX3doaWxlIGYgbHN0XG4gIHwgbHN0IC0+IGxzdFxuXG50eXBlIGNvbnN0YW50c19jYXQgPSBBcml0aCB8IE1vdk12biB8IE1vdk12blN0cmljdFxubGV0IHN5bnRoZXNpcyB+Y29uc3RhbnRzX2NhdCB+YWRkaXRpdmUgfmluY3IgbWF4X2NhcmQgaSBpc192YWxpZF9mc3QgaXNfdmFsaWQgPVxuICBsZXQgdGFkMCA9IHRyaWVzX2F0X2RlcHRoXzAgaW5cbiAgbGV0IHRhZDBfbGVuID0gQXJyYXkubGVuZ3RoIHRhZDAgaW5cbiAgbGV0IHRhZDAgPSBpZiB0YWQwX2xlbiA8IG1heF9jYXJkIHRoZW4gdGFkMC4odGFkMF9sZW4tMSkgZWxzZSB0YWQwLihtYXhfY2FyZC0xKSBpblxuXG4gIGxldCByZW1vdmUgPSAoZnVuIGkgLT4gcmVtb3ZlX3doaWxlIChmdW4gaiAtPiB1bnNpZ25lZF9jb21wYXJlIGkgaiA8IDApKSBpblxuICBsZXQgcmVjIG5leHQgYWNjIHJjIGkgPVxuICAgIGxldCByZWMgYXV4IHRyeV9uYiByYyA9XG4gICAgICBpZiBlcXVhbCBpIHplcm8gdGhlbiBTb21lIGFjY1xuICAgICAgZWxzZVxuICAgICAgICBsZXQgZGVwdGggPSBMaXN0Lmxlbmd0aCBhY2MgaW5cbiAgICAgICAgaWYgZGVwdGggPj0gbWF4X2NhcmQgdGhlbiBOb25lXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBsZXQgcmVtX2RlcHRoID0gbWF4X2NhcmQgLSBkZXB0aCB8PiBJbnQ2NC5vZl9pbnQgaW5cbiAgICAgICAgICBsZXQgaTY0ID0gaW50NjRfb2ZfdWludDMyIGkgaW5cbiAgICAgICAgICBsZXQgaWkgPSBpZiBpbmNyIHRoZW4gcHJlZCBpIGVsc2UgaSBpblxuICAgICAgICAgIG1hdGNoIHJlbW92ZSBpaSByYyB3aXRoXG4gICAgICAgICAgfCBbXSAtPiBOb25lXG4gICAgICAgICAgfCBmc3Q6Ol8gd2hlbiBJbnQ2NC51bnNpZ25lZF9jb21wYXJlICgqIE9wdGltaXNhdGlvbiAqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAoSW50NjQubXVsICgoaWYgaW5jciB0aGVuIHN1Y2MgZnN0IGVsc2UgZnN0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICB8PiBpbnQ2NF9vZl91aW50MzIpIHJlbV9kZXB0aCkgaTY0IDwgMCAtPiBOb25lXG4gICAgICAgICAgfCBmc3Q6OnJjIC0+XG4gICAgICAgICAgICBsZXQgcmVtYWluZGVyID0gc3ViIGlpIGZzdCBpblxuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggbmV4dCAoZnN0OjphY2MpIChmc3Q6OnJjKSByZW1haW5kZXIgd2l0aFxuICAgICAgICAgICAgfCBOb25lIC0+IGF1eCAodHJ5X25iKzEpIHJjXG4gICAgICAgICAgICB8IFNvbWUgcmVzIC0+IFNvbWUgcmVzXG4gICAgICAgICAgICBlbmRcbiAgICBpblxuICAgIGF1eCAwIHJjXG4gIGluXG5cbiAgbGV0IGZpbHRlcmVkX3Jldl9jb25zdGFudHMgPSBMaXN0LmZpbHRlciBpc192YWxpZCByZXZfY29uc3RhbnRzIGluXG4gIGxldCByZW1vdmVfaW5pdCA9XG4gICAgaWYgYWRkaXRpdmUgdGhlbiByZW1vdmVcbiAgICBlbHNlIChmdW4gaSAtPiByZW1vdmVfd2hpbGUgKGZ1biBqIC0+IHVuc2lnbmVkX2NvbXBhcmUgaSBqID4gMCkpXG4gIGluXG4gIGxldCBvcF9pbml0ID0gaWYgYWRkaXRpdmUgdGhlbiBzdWIgZWxzZSAoZnVuIHggeSAtPiBzdWIgeSB4KSBpblxuICBsZXQgcmVjIGluaXQgdHJ5X25iIHJjID1cbiAgICBpZiB0cnlfbmIgPj0gdGFkMCB0aGVuIE5vbmVcbiAgICBlbHNlIG1hdGNoIHJlbW92ZV9pbml0IGkgcmMgd2l0aFxuICAgIHwgW10gLT4gTm9uZVxuICAgIHwgZnN0OjpyYyAtPlxuICAgICAgbGV0IHJlbWFpbmRlciA9IG9wX2luaXQgaSBmc3QgaW5cbiAgICAgIGJlZ2luIG1hdGNoIG5leHQgW2ZzdF0gZmlsdGVyZWRfcmV2X2NvbnN0YW50cyByZW1haW5kZXIgd2l0aFxuICAgICAgfCBOb25lIC0+IGluaXQgKHRyeV9uYisxKSByY1xuICAgICAgfCBTb21lIHJlcyAtPiBTb21lIHJlc1xuICAgICAgZW5kXG4gIGluXG5cbiAgbGV0IGluaXRfcmMgPVxuICAgIG1hdGNoIGFkZGl0aXZlLCBjb25zdGFudHNfY2F0IHdpdGhcbiAgICB8IHRydWUsIEFyaXRoIC0+IHJldl9jb25zdGFudHNcbiAgICB8IHRydWUsIE1vdk12biAtPiByZXZfY29uc3RhbnRzX21vdl9tdm5cbiAgICB8IHRydWUsIE1vdk12blN0cmljdCAtPiByZXZfY29uc3RhbnRzX21vdl9tdm5fc3RyaWN0XG4gICAgfCBmYWxzZSwgQXJpdGggLT4gY29uc3RhbnRzXG4gICAgfCBmYWxzZSwgTW92TXZuIC0+IGNvbnN0YW50c19tb3ZfbXZuXG4gICAgfCBmYWxzZSwgTW92TXZuU3RyaWN0IC0+IGNvbnN0YW50c19tb3ZfbXZuX3N0cmljdFxuICBpblxuICBsZXQgaW5pdF9yYyA9IExpc3QuZmlsdGVyIGlzX3ZhbGlkX2ZzdCBpbml0X3JjIGluXG4gIGluaXQgMCBpbml0X3JjIHw+XG4gIChmdW5jdGlvbiBOb25lIC0+IE5vbmUgfCBTb21lIGxzdCAtPiBTb21lIChMaXN0LnJldiBsc3QpKVxuXG5sZXQgc3ludGhlc2lzX29wdGltYWwgfmNvbnN0YW50c19jYXQgfmluY3JfYWRkIH5pbmNyX3N1YiBtYXhfY2FyZCBpIGlzX3ZhbGlkX2ZzdCBpc192YWxpZCA9XG4gIGxldCByZWMgYXV4IGNhcmQgPVxuICAgICgqRm9ybWF0LnByaW50ZiBcIlRyeWluZyB3aXRoIGNhcmQ9JWlALlwiIGNhcmQgOyopXG4gICAgaWYgY2FyZCA+IG1heF9jYXJkIHRoZW4gTm9uZVxuICAgIGVsc2VcbiAgICAgIG1hdGNoIHN5bnRoZXNpcyB+Y29uc3RhbnRzX2NhdCB+YWRkaXRpdmU6dHJ1ZSB+aW5jcjppbmNyX2FkZFxuICAgICAgICAgICAgICAgICAgY2FyZCBpIGlzX3ZhbGlkX2ZzdCAoaXNfdmFsaWQgdHJ1ZSkgd2l0aFxuICAgICAgfCBTb21lIGxzdCAtPiBTb21lIChsc3QsIHRydWUpXG4gICAgICB8IE5vbmUgLT5cbiAgICAgICAgYmVnaW4gbWF0Y2ggc3ludGhlc2lzIH5jb25zdGFudHNfY2F0IH5hZGRpdGl2ZTpmYWxzZSB+aW5jcjppbmNyX3N1YlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FyZCBpIGlzX3ZhbGlkX2ZzdCAoaXNfdmFsaWQgZmFsc2UpIHdpdGhcbiAgICAgICAgfCBTb21lIGxzdCAtPiBTb21lIChsc3QsIGZhbHNlKVxuICAgICAgICB8IE5vbmUgLT4gYXV4IChjYXJkKzEpXG4gICAgICAgIGVuZFxuICBpblxuICBhdXggMVxuXG5sZXQgc3ludGhlc2lzX3Rlc3QgbWF4X2NhcmQgaSA9XG4gIHN5bnRoZXNpc19vcHRpbWFsIH5jb25zdGFudHNfY2F0Ok1vdk12biB+aW5jcl9hZGQ6ZmFsc2UgfmluY3Jfc3ViOnRydWVcbiAgICBtYXhfY2FyZCBpIChmdW4gXyAtPiB0cnVlKSAoZnVuIF8gXyAtPiB0cnVlKVxuXG5sZXQgaXNfY29tbWFuZF92YWxpZCBhcm0gPVxuICB0cnkgKFxuICAgIGFybV90b19iaW5hcnkgYXJtIHw+XG4gICAgTGlzdC5leGlzdHMgKGZ1biBpIC0+IE5hbWUuY29kZXNfZm9yX2NvbW1hbmQgaSB8PiBOYW1lLmlzX2NvZGVfd3JpdGFibGUpXG4gICkgd2l0aCBJbnZhbGlkQ29tbWFuZCAtPiBmYWxzZVxuXG5sZXQgdHdlYWtfbW92X212biBzdHJpY3QgaW5zdHIgcyBjb25kIHJkIHJzIG1heF9jYXJkID1cbiAgbGV0IGNtZCA9IE1vdiB7aW5zdHI7cztjb25kO3JkO3JzfSBpblxuICBtYXRjaCBycyB3aXRoXG4gIHwgUmVnaXN0ZXIgXyAtPiBbY21kXVxuICB8IFNjYWxlZFJlZ2lzdGVyIF8gLT4gZmFpbHdpdGggXCJOb3QgaW1wbGVtZW50ZWRcIlxuICB8IEltbWVkaWF0ZSBpIC0+XG4gICAgbGV0IG1rX2NtZF9maXJzdCBmc3QgPVxuICAgICAgbGV0IG5mc3QgPSBsb2dub3QgZnN0IGluXG4gICAgICBsZXQgY29uc3RhbnRfc2V0X21vdiA9IGlmIHN0cmljdCB0aGVuIGNvbnN0YW50c19zZXQgZWxzZSBjb25zdGFudHNfc2V0X25vX2NhcnJ5IGluXG4gICAgICBsZXQgaXNfbW92ID1cbiAgICAgICAgKGluc3RyID0gTU9WICYmIFVJbnQzMlNldC5tZW0gZnN0IGNvbnN0YW50X3NldF9tb3YpXG4gICAgICAgIHx8IChVSW50MzJTZXQubWVtIG5mc3QgY29uc3RhbnRzX3NldCB8PiBub3QpXG4gICAgICBpblxuICAgICAgbWF0Y2ggaXNfbW92LCBzdHJpY3Qgd2l0aFxuICAgICAgfCB0cnVlLCBmYWxzZSAtPiBNb3Yge2luc3RyPU1PVjtzPXRydWU7Y29uZDtyZDtycz1JbW1lZGlhdGUgZnN0fVxuICAgICAgfCB0cnVlLCB0cnVlIC0+IE1vdiB7aW5zdHI9TU9WO3M7Y29uZDtyZDtycz1JbW1lZGlhdGUgZnN0fVxuICAgICAgfCBmYWxzZSwgZmFsc2UgLT4gTW92IHtpbnN0cj1NVk47cz1mYWxzZTtjb25kO3JkO3JzPUltbWVkaWF0ZSBuZnN0fVxuICAgICAgfCBmYWxzZSwgdHJ1ZSAtPiBNb3Yge2luc3RyPU1WTjtzO2NvbmQ7cmQ7cnM9SW1tZWRpYXRlIG5mc3R9XG4gICAgaW5cbiAgICBsZXQgbWtfY21kIGFkZGl0aXZlIGkgPVxuICAgICAgbWF0Y2ggYWRkaXRpdmUsIHN0cmljdCB3aXRoXG4gICAgICB8IHRydWUsIGZhbHNlIC0+IERhdGFQcm9jIHtpbnN0cj1BREM7cz0ocmQ9MTUgfHwgcmQ9MCk7Y29uZDtyZDtybj1yZDtvcDI9SW1tZWRpYXRlIGl9XG4gICAgICB8IHRydWUsIHRydWUgLT4gRGF0YVByb2Mge2luc3RyPUFERDtzO2NvbmQ7cmQ7cm49cmQ7b3AyPUltbWVkaWF0ZSBpfVxuICAgICAgfCBmYWxzZSwgZmFsc2UgLT4gRGF0YVByb2Mge2luc3RyPVNCQztzPWZhbHNlO2NvbmQ7cmQ7cm49cmQ7b3AyPUltbWVkaWF0ZSBpfVxuICAgICAgfCBmYWxzZSwgdHJ1ZSAtPiBEYXRhUHJvYyB7aW5zdHI9U1VCO3M7Y29uZDtyZDtybj1yZDtvcDI9SW1tZWRpYXRlIGl9XG4gICAgaW5cbiAgICBsZXQgaSA9IGlmIGluc3RyID0gTU9WIHRoZW4gaSBlbHNlIGxvZ25vdCBpIGluXG4gICAgYmVnaW4gbWF0Y2ggc3ludGhlc2lzX29wdGltYWwgfmNvbnN0YW50c19jYXQ6KGlmIHN0cmljdCB0aGVuIE1vdk12blN0cmljdCBlbHNlIE1vdk12bilcbiAgICAgICAgICAgICAgICAgIH5pbmNyX2FkZDpmYWxzZSB+aW5jcl9zdWI6KG5vdCBzdHJpY3QpIG1heF9jYXJkIGlcbiAgICAgICAgICAgICAgICAgIChmdW4gaSAtPiBta19jbWRfZmlyc3QgaSB8PiBpc19jb21tYW5kX3ZhbGlkKVxuICAgICAgICAgICAgICAgICAgKGZ1biBhZGQgaSAtPiBta19jbWQgYWRkIGkgfD4gaXNfY29tbWFuZF92YWxpZCkgd2l0aFxuICAgIHwgTm9uZSAtPiBbY21kXVxuICAgIHwgU29tZSAoZnN0Ojpsc3QsIGFkZGl0aXZlKSAtPlxuICAgICAgKG1rX2NtZF9maXJzdCBmc3QpOjooTGlzdC5tYXAgKG1rX2NtZCBhZGRpdGl2ZSkgbHN0KVxuICAgIHwgXyAtPiBhc3NlcnQgZmFsc2VcbiAgICBlbmRcblxubGV0IHR3ZWFrX2FyaXRoIHN0cmljdCBpbnN0ciBzIGNvbmQgcmQgcm4gb3AyIG1heF9jYXJkID1cbiAgYXNzZXJ0IChpbnN0ciA9IEFEQyB8fCBpbnN0ciA9IFNCQyB8fCBpbnN0ciA9IEFERCB8fCBpbnN0ciA9IFNVQikgO1xuICBsZXQgY21kID0gRGF0YVByb2Mge2luc3RyO3M7Y29uZDtyZDtybjtvcDJ9IGluXG4gIG1hdGNoIG9wMiB3aXRoXG4gIHwgUmVnaXN0ZXIgXyAtPiBbY21kXVxuICB8IFNjYWxlZFJlZ2lzdGVyIF8gLT4gZmFpbHdpdGggXCJOb3QgaW1wbGVtZW50ZWRcIlxuICB8IEltbWVkaWF0ZSBpIC0+XG4gICAgbGV0IGkgPSBpZiBub3Qgc3RyaWN0ICYmIGluc3RyID0gU1VCIHRoZW4gcHJlZCBpIGVsc2UgaSBpbiAoKiBCZWNhdXNlIHRoZSBTVUIgd2lsbCBiZSByZXBsYWNlZCBieSBTQkMgKilcbiAgICBsZXQgaXNfYWRkaXRpb24gPSAgaW5zdHIgPSBBREMgfHwgaW5zdHIgPSBBREQgaW5cbiAgICBsZXQgbWtfY21kX2ZpcnN0IGZzdCA9XG4gICAgICBtYXRjaCBpc19hZGRpdGlvbiwgc3RyaWN0IHdpdGhcbiAgICAgIHwgXywgdHJ1ZSAtPiBEYXRhUHJvYyB7aW5zdHI7cztjb25kO3JkO3JuO29wMj1JbW1lZGlhdGUgZnN0fVxuICAgICAgfCB0cnVlLCBmYWxzZSAtPiBEYXRhUHJvYyB7aW5zdHI9QURDO3M9KHJuPTE1IHx8IHJuPTApO2NvbmQ7cmQ7cm47b3AyPUltbWVkaWF0ZSBmc3R9XG4gICAgICB8IGZhbHNlLCBmYWxzZSAtPiBEYXRhUHJvYyB7aW5zdHI9U0JDO3M9ZmFsc2U7Y29uZDtyZDtybjtvcDI9SW1tZWRpYXRlIGZzdH1cbiAgICBpblxuICAgIGxldCBta19jbWQgYWRkaXRpdmUgaSA9XG4gICAgICBsZXQgbXVzdF9hZGQgPSAoYWRkaXRpdmUgJiYgaXNfYWRkaXRpb24pIHx8IChub3QgYWRkaXRpdmUgJiYgbm90IGlzX2FkZGl0aW9uKSBpblxuICAgICAgbWF0Y2ggbXVzdF9hZGQsIHN0cmljdCB3aXRoXG4gICAgICB8IHRydWUsIGZhbHNlIC0+IERhdGFQcm9jIHtpbnN0cj1BREM7cz0ocmQ9MTUgfHwgcmQ9MCk7Y29uZDtyZDtybj1yZDtvcDI9SW1tZWRpYXRlIGl9XG4gICAgICB8IHRydWUsIHRydWUgLT4gRGF0YVByb2Mge2luc3RyPUFERDtzO2NvbmQ7cmQ7cm49cmQ7b3AyPUltbWVkaWF0ZSBpfVxuICAgICAgfCBmYWxzZSwgZmFsc2UgLT4gRGF0YVByb2Mge2luc3RyPVNCQztzPWZhbHNlO2NvbmQ7cmQ7cm49cmQ7b3AyPUltbWVkaWF0ZSBpfVxuICAgICAgfCBmYWxzZSwgdHJ1ZSAtPiBEYXRhUHJvYyB7aW5zdHI9U1VCO3M7Y29uZDtyZDtybj1yZDtvcDI9SW1tZWRpYXRlIGl9XG4gICAgaW5cbiAgICBiZWdpbiBtYXRjaCBzeW50aGVzaXNfb3B0aW1hbCB+Y29uc3RhbnRzX2NhdDpBcml0aCB+aW5jcl9hZGQ6KG5vdCBpc19hZGRpdGlvbiAmJiBub3Qgc3RyaWN0KVxuICAgICAgICAgICAgICAgICAgfmluY3Jfc3ViOihpc19hZGRpdGlvbiAmJiBub3Qgc3RyaWN0KSBtYXhfY2FyZCBpXG4gICAgICAgICAgICAgICAgICAoZnVuIGkgLT4gbWtfY21kX2ZpcnN0IGkgfD4gaXNfY29tbWFuZF92YWxpZClcbiAgICAgICAgICAgICAgICAgIChmdW4gYWRkIGkgLT4gbWtfY21kIGFkZCBpIHw+IGlzX2NvbW1hbmRfdmFsaWQpIHdpdGhcbiAgICB8IE5vbmUgLT4gW2NtZF1cbiAgICB8IFNvbWUgKGZzdDo6bHN0LCBhZGRpdGl2ZSkgLT5cbiAgICAgIChta19jbWRfZmlyc3QgZnN0KTo6KExpc3QubWFwIChta19jbWQgYWRkaXRpdmUpIGxzdClcbiAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG4gICAgZW5kXG5cbmxldCB0d2Vha19jb21tYW5kIChhcm0sIG9wdGltaXplKSA9XG4gIGxldCBzdHJpY3QgPVxuICAgIG1hdGNoICFTZXR0aW5ncy50d2Vha2VyX21vZGUgd2l0aFxuICAgIHwgU2V0dGluZ3MuRmxleGlibGUgLT4gZmFsc2UgfCBTZXR0aW5ncy5TdHJpY3QgLT4gdHJ1ZVxuICBpblxuICBsZXQgb3B0aW1pemVfd2l0aF9jYXJkIGFybSBuIHBhZCA9XG4gICAgbGV0IHJlcyA9XG4gICAgICBtYXRjaCBhcm0gd2l0aFxuICAgICAgfCBNb3Yge2luc3RyO3M7Y29uZDtyZDtyc30gLT4gdHdlYWtfbW92X212biBzdHJpY3QgaW5zdHIgcyBjb25kIHJkIHJzIG5cbiAgICAgIHwgRGF0YVByb2Mge2luc3RyO3M7Y29uZDtyZDtybjtvcDJ9XG4gICAgICB3aGVuIGluc3RyID0gQURDIHx8IGluc3RyID0gU0JDIHx8IGluc3RyID0gQUREIHx8IGluc3RyID0gU1VCIC0+XG4gICAgICAgIHR3ZWFrX2FyaXRoIHN0cmljdCBpbnN0ciBzIGNvbmQgcmQgcm4gb3AyIG5cbiAgICAgIHwgXyAtPiBbYXJtXVxuICAgIGluXG4gICAgaWYgcGFkXG4gICAgdGhlblxuICAgICAgbGV0IHBhZGRpbmcgPSBMaXN0LmluaXQgKG4gLSAoTGlzdC5sZW5ndGggcmVzKSkgKGZ1biBfIC0+IHBhZGRpbmdfY29kZSkgaW5cbiAgICAgIHJlc0BwYWRkaW5nXG4gICAgZWxzZSByZXNcbiAgaW5cbiAgbWF0Y2ggb3B0aW1pemUgd2l0aFxuICB8IE5vVHdlYWtpbmcgLT4gW2FybV1cbiAgfCBUd2Vha01pbkxlbmd0aCAtPiBvcHRpbWl6ZV93aXRoX2NhcmQgYXJtIDUgZmFsc2VcbiAgfCBUd2Vha0ZpeGVkTGVuZ3RoIGNhcmQgLT4gb3B0aW1pemVfd2l0aF9jYXJkIGFybSBjYXJkIHRydWVcblxubGV0IHR3ZWFrX2FybSBsc3QgPVxuICBsc3QgfD4gTGlzdC5tYXAgdHdlYWtfY29tbWFuZCB8PiBMaXN0LmZsYXR0ZW5cblxubGV0IGRvX25vdF90d2Vha19hcm0gbHN0ID1cbiAgbHN0IHw+IExpc3QubWFwIChmdW4gKGFybSwgb3B0aW1pemUpIC0+XG4gICAgaWYgb3B0aW1pemUgPD4gTm9Ud2Vha2luZyB0aGVuIHJhaXNlIENhbm5vdE9wdGltaXplIGVsc2UgYXJtXG4gIClcbiIsIlxubW9kdWxlIE1lbmhpckJhc2ljcyA9IHN0cnVjdFxuICBcbiAgZXhjZXB0aW9uIEVycm9yXG4gIFxuICB0eXBlIHRva2VuID0gXG4gICAgfCBYT1JcbiAgICB8IFRJTUVTXG4gICAgfCBTVFJJTkcgb2YgKFxuIyA3IFwiSU8vcGFyc2VyLm1seVwiXG4gICAgICAgKHN0cmluZylcbiMgMTMgXCJJTy9wYXJzZXIubWxcIlxuICApXG4gICAgfCBSU0hJRlRcbiAgICB8IFJQQVJFTlxuICAgIHwgUklHSFRfQlJBQ0tcbiAgICB8IFJJR0hUX0JSQUNFXG4gICAgfCBQTFVTXG4gICAgfCBPUlxuICAgIHwgTlVNQkVSIG9mIChcbiMgOCBcIklPL3BhcnNlci5tbHlcIlxuICAgICAgIChpbnQzMilcbiMgMjQgXCJJTy9wYXJzZXIubWxcIlxuICApXG4gICAgfCBOVUxMXG4gICAgfCBOT1RcbiAgICB8IE5FUVxuICAgIHwgTU9EXG4gICAgfCBNSU5VU1xuICAgIHwgTFNISUZUXG4gICAgfCBMUEFSRU5cbiAgICB8IExFRlRfQlJBQ0tcbiAgICB8IExFRlRfQlJBQ0VcbiAgICB8IElOVEVSUk9HX01BUktcbiAgICB8IElEIG9mIChcbiMgMTAgXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAoc3RyaW5nKVxuIyAzOSBcIklPL3BhcnNlci5tbFwiXG4gIClcbiAgICB8IEhFQURFUlxuICAgIHwgSEFTSFxuICAgIHwgRVhDTEFNX01BUktcbiAgICB8IEVRVUFMXG4gICAgfCBFUVxuICAgIHwgRU9MXG4gICAgfCBFT0ZcbiAgICB8IERJVlxuICAgIHwgQ09NTUFcbiAgICB8IENPTE9OXG4gICAgfCBCT1JcbiAgICB8IEJPT0wgb2YgKFxuIyA5IFwiSU8vcGFyc2VyLm1seVwiXG4gICAgICAgKGJvb2wpXG4jIDU1IFwiSU8vcGFyc2VyLm1sXCJcbiAgKVxuICAgIHwgQkFORFxuICAgIHwgQU5EXG4gIFxuZW5kXG5cbmluY2x1ZGUgTWVuaGlyQmFzaWNzXG5cbmxldCBfZVJSID1cbiAgTWVuaGlyQmFzaWNzLkVycm9yXG5cbnR5cGUgX21lbmhpcl9lbnYgPSB7XG4gIF9tZW5oaXJfbGV4ZXI6IExleGluZy5sZXhidWYgLT4gdG9rZW47XG4gIF9tZW5oaXJfbGV4YnVmOiBMZXhpbmcubGV4YnVmO1xuICBfbWVuaGlyX3Rva2VuOiB0b2tlbjtcbiAgbXV0YWJsZSBfbWVuaGlyX2Vycm9yOiBib29sXG59XG5cbmFuZCBfbWVuaGlyX3N0YXRlID0gXG4gIHwgTWVuaGlyU3RhdGUxMTRcbiAgfCBNZW5oaXJTdGF0ZTEwMlxuICB8IE1lbmhpclN0YXRlMTAwXG4gIHwgTWVuaGlyU3RhdGU5NlxuICB8IE1lbmhpclN0YXRlOTJcbiAgfCBNZW5oaXJTdGF0ZTg3XG4gIHwgTWVuaGlyU3RhdGU3OVxuICB8IE1lbmhpclN0YXRlNzRcbiAgfCBNZW5oaXJTdGF0ZTY5XG4gIHwgTWVuaGlyU3RhdGU2N1xuICB8IE1lbmhpclN0YXRlNjZcbiAgfCBNZW5oaXJTdGF0ZTYyXG4gIHwgTWVuaGlyU3RhdGU1OVxuICB8IE1lbmhpclN0YXRlNThcbiAgfCBNZW5oaXJTdGF0ZTUzXG4gIHwgTWVuaGlyU3RhdGU0NlxuICB8IE1lbmhpclN0YXRlNDRcbiAgfCBNZW5oaXJTdGF0ZTQyXG4gIHwgTWVuaGlyU3RhdGU0MFxuICB8IE1lbmhpclN0YXRlMzhcbiAgfCBNZW5oaXJTdGF0ZTM1XG4gIHwgTWVuaGlyU3RhdGUzM1xuICB8IE1lbmhpclN0YXRlMzFcbiAgfCBNZW5oaXJTdGF0ZTI5XG4gIHwgTWVuaGlyU3RhdGUyN1xuICB8IE1lbmhpclN0YXRlMjVcbiAgfCBNZW5oaXJTdGF0ZTIzXG4gIHwgTWVuaGlyU3RhdGUyMVxuICB8IE1lbmhpclN0YXRlMTlcbiAgfCBNZW5oaXJTdGF0ZTE3XG4gIHwgTWVuaGlyU3RhdGUxNVxuICB8IE1lbmhpclN0YXRlMTJcbiAgfCBNZW5oaXJTdGF0ZTEwXG4gIHwgTWVuaGlyU3RhdGU5XG4gIHwgTWVuaGlyU3RhdGU4XG4gIHwgTWVuaGlyU3RhdGU2XG4gIHwgTWVuaGlyU3RhdGU1XG4gIHwgTWVuaGlyU3RhdGUzXG4gIHwgTWVuaGlyU3RhdGUxXG4gIHwgTWVuaGlyU3RhdGUwXG5cbiMgMSBcIklPL3BhcnNlci5tbHlcIlxuICAgb3BlbiBQYXJzZXJfYXN0IFxuIyAxMTggXCJJTy9wYXJzZXIubWxcIlxuXG4jIDIgXCJJTy9wYXJzZXIubWx5XCJcbiAgIG9wZW4gUHJlcHJvY2VzcyBcbiMgMTIyIFwiSU8vcGFyc2VyLm1sXCJcblxubGV0IHJlYyBfbWVuaGlyX3J1bjE1IDogX21lbmhpcl9lbnYgLT4gJ3R0dl90YWlsICogX21lbmhpcl9zdGF0ZSAqIChQcmVwcm9jZXNzLm1ldGFfZXhwcikgLT4gJ3R0dl9yZXR1cm4gPVxuICBmdW4gX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayAtPlxuICAgIGxldCBfbWVuaGlyX2VudiA9IF9tZW5oaXJfZGlzY2FyZCBfbWVuaGlyX2VudiBpblxuICAgIGxldCBfdG9rID0gX21lbmhpcl9lbnYuX21lbmhpcl90b2tlbiBpblxuICAgIG1hdGNoIF90b2sgd2l0aFxuICAgIHwgRVhDTEFNX01BUksgLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMiBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMTVcbiAgICB8IElEIF92IC0+XG4gICAgICAgIF9tZW5oaXJfcnVuMTEgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTE1IF92IF9tZW5oaXJfZW52Ll9tZW5oaXJfbGV4YnVmLkxleGluZy5sZXhfc3RhcnRfcFxuICAgIHwgTFBBUkVOIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuMTAgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTE1XG4gICAgfCBNSU5VUyAtPlxuICAgICAgICBfbWVuaGlyX3J1bjkgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTE1XG4gICAgfCBOT1QgLT5cbiAgICAgICAgX21lbmhpcl9ydW44IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUxNVxuICAgIHwgTlVNQkVSIF92IC0+XG4gICAgICAgIF9tZW5oaXJfcnVuNyBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMTUgX3YgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgfCBQTFVTIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuNiBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMTVcbiAgICB8IF8gLT5cbiAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgIF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IgPC0gdHJ1ZTtcbiAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTE1XG5cbmFuZCBfbWVuaGlyX3J1bjE3IDogX21lbmhpcl9lbnYgLT4gJ3R0dl90YWlsICogX21lbmhpcl9zdGF0ZSAqIChQcmVwcm9jZXNzLm1ldGFfZXhwcikgLT4gJ3R0dl9yZXR1cm4gPVxuICBmdW4gX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayAtPlxuICAgIGxldCBfbWVuaGlyX2VudiA9IF9tZW5oaXJfZGlzY2FyZCBfbWVuaGlyX2VudiBpblxuICAgIGxldCBfdG9rID0gX21lbmhpcl9lbnYuX21lbmhpcl90b2tlbiBpblxuICAgIG1hdGNoIF90b2sgd2l0aFxuICAgIHwgRVhDTEFNX01BUksgLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMiBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMTdcbiAgICB8IElEIF92IC0+XG4gICAgICAgIF9tZW5oaXJfcnVuMTEgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTE3IF92IF9tZW5oaXJfZW52Ll9tZW5oaXJfbGV4YnVmLkxleGluZy5sZXhfc3RhcnRfcFxuICAgIHwgTFBBUkVOIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuMTAgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTE3XG4gICAgfCBNSU5VUyAtPlxuICAgICAgICBfbWVuaGlyX3J1bjkgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTE3XG4gICAgfCBOT1QgLT5cbiAgICAgICAgX21lbmhpcl9ydW44IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUxN1xuICAgIHwgTlVNQkVSIF92IC0+XG4gICAgICAgIF9tZW5oaXJfcnVuNyBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMTcgX3YgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgfCBQTFVTIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuNiBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMTdcbiAgICB8IF8gLT5cbiAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgIF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IgPC0gdHJ1ZTtcbiAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTE3XG5cbmFuZCBfbWVuaGlyX3J1bjE5IDogX21lbmhpcl9lbnYgLT4gJ3R0dl90YWlsICogX21lbmhpcl9zdGF0ZSAqIChQcmVwcm9jZXNzLm1ldGFfZXhwcikgLT4gJ3R0dl9yZXR1cm4gPVxuICBmdW4gX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayAtPlxuICAgIGxldCBfbWVuaGlyX2VudiA9IF9tZW5oaXJfZGlzY2FyZCBfbWVuaGlyX2VudiBpblxuICAgIGxldCBfdG9rID0gX21lbmhpcl9lbnYuX21lbmhpcl90b2tlbiBpblxuICAgIG1hdGNoIF90b2sgd2l0aFxuICAgIHwgRVhDTEFNX01BUksgLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMiBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMTlcbiAgICB8IElEIF92IC0+XG4gICAgICAgIF9tZW5oaXJfcnVuMTEgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTE5IF92IF9tZW5oaXJfZW52Ll9tZW5oaXJfbGV4YnVmLkxleGluZy5sZXhfc3RhcnRfcFxuICAgIHwgTFBBUkVOIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuMTAgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTE5XG4gICAgfCBNSU5VUyAtPlxuICAgICAgICBfbWVuaGlyX3J1bjkgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTE5XG4gICAgfCBOT1QgLT5cbiAgICAgICAgX21lbmhpcl9ydW44IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUxOVxuICAgIHwgTlVNQkVSIF92IC0+XG4gICAgICAgIF9tZW5oaXJfcnVuNyBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMTkgX3YgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgfCBQTFVTIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuNiBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMTlcbiAgICB8IF8gLT5cbiAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgIF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IgPC0gdHJ1ZTtcbiAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTE5XG5cbmFuZCBfbWVuaGlyX3J1bjIxIDogX21lbmhpcl9lbnYgLT4gJ3R0dl90YWlsICogX21lbmhpcl9zdGF0ZSAqIChQcmVwcm9jZXNzLm1ldGFfZXhwcikgLT4gJ3R0dl9yZXR1cm4gPVxuICBmdW4gX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayAtPlxuICAgIGxldCBfbWVuaGlyX2VudiA9IF9tZW5oaXJfZGlzY2FyZCBfbWVuaGlyX2VudiBpblxuICAgIGxldCBfdG9rID0gX21lbmhpcl9lbnYuX21lbmhpcl90b2tlbiBpblxuICAgIG1hdGNoIF90b2sgd2l0aFxuICAgIHwgRVhDTEFNX01BUksgLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMiBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMjFcbiAgICB8IElEIF92IC0+XG4gICAgICAgIF9tZW5oaXJfcnVuMTEgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTIxIF92IF9tZW5oaXJfZW52Ll9tZW5oaXJfbGV4YnVmLkxleGluZy5sZXhfc3RhcnRfcFxuICAgIHwgTFBBUkVOIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuMTAgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTIxXG4gICAgfCBNSU5VUyAtPlxuICAgICAgICBfbWVuaGlyX3J1bjkgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTIxXG4gICAgfCBOT1QgLT5cbiAgICAgICAgX21lbmhpcl9ydW44IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUyMVxuICAgIHwgTlVNQkVSIF92IC0+XG4gICAgICAgIF9tZW5oaXJfcnVuNyBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMjEgX3YgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgfCBQTFVTIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuNiBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMjFcbiAgICB8IF8gLT5cbiAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgIF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IgPC0gdHJ1ZTtcbiAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTIxXG5cbmFuZCBfbWVuaGlyX3J1bjM4IDogX21lbmhpcl9lbnYgLT4gJ3R0dl90YWlsICogX21lbmhpcl9zdGF0ZSAqIChQcmVwcm9jZXNzLm1ldGFfZXhwcikgLT4gJ3R0dl9yZXR1cm4gPVxuICBmdW4gX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayAtPlxuICAgIGxldCBfbWVuaGlyX2VudiA9IF9tZW5oaXJfZGlzY2FyZCBfbWVuaGlyX2VudiBpblxuICAgIGxldCBfdG9rID0gX21lbmhpcl9lbnYuX21lbmhpcl90b2tlbiBpblxuICAgIG1hdGNoIF90b2sgd2l0aFxuICAgIHwgRVhDTEFNX01BUksgLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMiBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMzhcbiAgICB8IElEIF92IC0+XG4gICAgICAgIF9tZW5oaXJfcnVuMTEgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTM4IF92IF9tZW5oaXJfZW52Ll9tZW5oaXJfbGV4YnVmLkxleGluZy5sZXhfc3RhcnRfcFxuICAgIHwgTFBBUkVOIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuMTAgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTM4XG4gICAgfCBNSU5VUyAtPlxuICAgICAgICBfbWVuaGlyX3J1bjkgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTM4XG4gICAgfCBOT1QgLT5cbiAgICAgICAgX21lbmhpcl9ydW44IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUzOFxuICAgIHwgTlVNQkVSIF92IC0+XG4gICAgICAgIF9tZW5oaXJfcnVuNyBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMzggX3YgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgfCBQTFVTIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuNiBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMzhcbiAgICB8IF8gLT5cbiAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgIF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IgPC0gdHJ1ZTtcbiAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTM4XG5cbmFuZCBfbWVuaGlyX3J1bjI5IDogX21lbmhpcl9lbnYgLT4gJ3R0dl90YWlsICogX21lbmhpcl9zdGF0ZSAqIChQcmVwcm9jZXNzLm1ldGFfZXhwcikgLT4gJ3R0dl9yZXR1cm4gPVxuICBmdW4gX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayAtPlxuICAgIGxldCBfbWVuaGlyX2VudiA9IF9tZW5oaXJfZGlzY2FyZCBfbWVuaGlyX2VudiBpblxuICAgIGxldCBfdG9rID0gX21lbmhpcl9lbnYuX21lbmhpcl90b2tlbiBpblxuICAgIG1hdGNoIF90b2sgd2l0aFxuICAgIHwgRVhDTEFNX01BUksgLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMiBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMjlcbiAgICB8IElEIF92IC0+XG4gICAgICAgIF9tZW5oaXJfcnVuMTEgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTI5IF92IF9tZW5oaXJfZW52Ll9tZW5oaXJfbGV4YnVmLkxleGluZy5sZXhfc3RhcnRfcFxuICAgIHwgTFBBUkVOIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuMTAgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTI5XG4gICAgfCBNSU5VUyAtPlxuICAgICAgICBfbWVuaGlyX3J1bjkgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTI5XG4gICAgfCBOT1QgLT5cbiAgICAgICAgX21lbmhpcl9ydW44IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUyOVxuICAgIHwgTlVNQkVSIF92IC0+XG4gICAgICAgIF9tZW5oaXJfcnVuNyBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMjkgX3YgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgfCBQTFVTIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuNiBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMjlcbiAgICB8IF8gLT5cbiAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgIF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IgPC0gdHJ1ZTtcbiAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTI5XG5cbmFuZCBfbWVuaGlyX3J1bjIzIDogX21lbmhpcl9lbnYgLT4gJ3R0dl90YWlsICogX21lbmhpcl9zdGF0ZSAqIChQcmVwcm9jZXNzLm1ldGFfZXhwcikgLT4gJ3R0dl9yZXR1cm4gPVxuICBmdW4gX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayAtPlxuICAgIGxldCBfbWVuaGlyX2VudiA9IF9tZW5oaXJfZGlzY2FyZCBfbWVuaGlyX2VudiBpblxuICAgIGxldCBfdG9rID0gX21lbmhpcl9lbnYuX21lbmhpcl90b2tlbiBpblxuICAgIG1hdGNoIF90b2sgd2l0aFxuICAgIHwgRVhDTEFNX01BUksgLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMiBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMjNcbiAgICB8IElEIF92IC0+XG4gICAgICAgIF9tZW5oaXJfcnVuMTEgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTIzIF92IF9tZW5oaXJfZW52Ll9tZW5oaXJfbGV4YnVmLkxleGluZy5sZXhfc3RhcnRfcFxuICAgIHwgTFBBUkVOIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuMTAgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTIzXG4gICAgfCBNSU5VUyAtPlxuICAgICAgICBfbWVuaGlyX3J1bjkgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTIzXG4gICAgfCBOT1QgLT5cbiAgICAgICAgX21lbmhpcl9ydW44IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUyM1xuICAgIHwgTlVNQkVSIF92IC0+XG4gICAgICAgIF9tZW5oaXJfcnVuNyBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMjMgX3YgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgfCBQTFVTIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuNiBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMjNcbiAgICB8IF8gLT5cbiAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgIF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IgPC0gdHJ1ZTtcbiAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTIzXG5cbmFuZCBfbWVuaGlyX3J1bjI3IDogX21lbmhpcl9lbnYgLT4gJ3R0dl90YWlsICogX21lbmhpcl9zdGF0ZSAqIChQcmVwcm9jZXNzLm1ldGFfZXhwcikgLT4gJ3R0dl9yZXR1cm4gPVxuICBmdW4gX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayAtPlxuICAgIGxldCBfbWVuaGlyX2VudiA9IF9tZW5oaXJfZGlzY2FyZCBfbWVuaGlyX2VudiBpblxuICAgIGxldCBfdG9rID0gX21lbmhpcl9lbnYuX21lbmhpcl90b2tlbiBpblxuICAgIG1hdGNoIF90b2sgd2l0aFxuICAgIHwgRVhDTEFNX01BUksgLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMiBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMjdcbiAgICB8IElEIF92IC0+XG4gICAgICAgIF9tZW5oaXJfcnVuMTEgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTI3IF92IF9tZW5oaXJfZW52Ll9tZW5oaXJfbGV4YnVmLkxleGluZy5sZXhfc3RhcnRfcFxuICAgIHwgTFBBUkVOIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuMTAgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTI3XG4gICAgfCBNSU5VUyAtPlxuICAgICAgICBfbWVuaGlyX3J1bjkgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTI3XG4gICAgfCBOT1QgLT5cbiAgICAgICAgX21lbmhpcl9ydW44IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUyN1xuICAgIHwgTlVNQkVSIF92IC0+XG4gICAgICAgIF9tZW5oaXJfcnVuNyBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMjcgX3YgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgfCBQTFVTIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuNiBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMjdcbiAgICB8IF8gLT5cbiAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgIF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IgPC0gdHJ1ZTtcbiAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTI3XG5cbmFuZCBfbWVuaGlyX3J1bjMxIDogX21lbmhpcl9lbnYgLT4gJ3R0dl90YWlsICogX21lbmhpcl9zdGF0ZSAqIChQcmVwcm9jZXNzLm1ldGFfZXhwcikgLT4gJ3R0dl9yZXR1cm4gPVxuICBmdW4gX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayAtPlxuICAgIGxldCBfbWVuaGlyX2VudiA9IF9tZW5oaXJfZGlzY2FyZCBfbWVuaGlyX2VudiBpblxuICAgIGxldCBfdG9rID0gX21lbmhpcl9lbnYuX21lbmhpcl90b2tlbiBpblxuICAgIG1hdGNoIF90b2sgd2l0aFxuICAgIHwgRVhDTEFNX01BUksgLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMiBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMzFcbiAgICB8IElEIF92IC0+XG4gICAgICAgIF9tZW5oaXJfcnVuMTEgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTMxIF92IF9tZW5oaXJfZW52Ll9tZW5oaXJfbGV4YnVmLkxleGluZy5sZXhfc3RhcnRfcFxuICAgIHwgTFBBUkVOIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuMTAgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTMxXG4gICAgfCBNSU5VUyAtPlxuICAgICAgICBfbWVuaGlyX3J1bjkgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTMxXG4gICAgfCBOT1QgLT5cbiAgICAgICAgX21lbmhpcl9ydW44IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUzMVxuICAgIHwgTlVNQkVSIF92IC0+XG4gICAgICAgIF9tZW5oaXJfcnVuNyBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMzEgX3YgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgfCBQTFVTIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuNiBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMzFcbiAgICB8IF8gLT5cbiAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgIF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IgPC0gdHJ1ZTtcbiAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTMxXG5cbmFuZCBfbWVuaGlyX3J1bjQwIDogX21lbmhpcl9lbnYgLT4gJ3R0dl90YWlsICogX21lbmhpcl9zdGF0ZSAqIChQcmVwcm9jZXNzLm1ldGFfZXhwcikgLT4gJ3R0dl9yZXR1cm4gPVxuICBmdW4gX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayAtPlxuICAgIGxldCBfbWVuaGlyX2VudiA9IF9tZW5oaXJfZGlzY2FyZCBfbWVuaGlyX2VudiBpblxuICAgIGxldCBfdG9rID0gX21lbmhpcl9lbnYuX21lbmhpcl90b2tlbiBpblxuICAgIG1hdGNoIF90b2sgd2l0aFxuICAgIHwgRVhDTEFNX01BUksgLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMiBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNDBcbiAgICB8IElEIF92IC0+XG4gICAgICAgIF9tZW5oaXJfcnVuMTEgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTQwIF92IF9tZW5oaXJfZW52Ll9tZW5oaXJfbGV4YnVmLkxleGluZy5sZXhfc3RhcnRfcFxuICAgIHwgTFBBUkVOIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuMTAgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTQwXG4gICAgfCBNSU5VUyAtPlxuICAgICAgICBfbWVuaGlyX3J1bjkgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTQwXG4gICAgfCBOT1QgLT5cbiAgICAgICAgX21lbmhpcl9ydW44IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU0MFxuICAgIHwgTlVNQkVSIF92IC0+XG4gICAgICAgIF9tZW5oaXJfcnVuNyBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNDAgX3YgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgfCBQTFVTIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuNiBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNDBcbiAgICB8IF8gLT5cbiAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgIF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IgPC0gdHJ1ZTtcbiAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTQwXG5cbmFuZCBfbWVuaGlyX3J1bjMzIDogX21lbmhpcl9lbnYgLT4gJ3R0dl90YWlsICogX21lbmhpcl9zdGF0ZSAqIChQcmVwcm9jZXNzLm1ldGFfZXhwcikgLT4gJ3R0dl9yZXR1cm4gPVxuICBmdW4gX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayAtPlxuICAgIGxldCBfbWVuaGlyX2VudiA9IF9tZW5oaXJfZGlzY2FyZCBfbWVuaGlyX2VudiBpblxuICAgIGxldCBfdG9rID0gX21lbmhpcl9lbnYuX21lbmhpcl90b2tlbiBpblxuICAgIG1hdGNoIF90b2sgd2l0aFxuICAgIHwgRVhDTEFNX01BUksgLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMiBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMzNcbiAgICB8IElEIF92IC0+XG4gICAgICAgIF9tZW5oaXJfcnVuMTEgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTMzIF92IF9tZW5oaXJfZW52Ll9tZW5oaXJfbGV4YnVmLkxleGluZy5sZXhfc3RhcnRfcFxuICAgIHwgTFBBUkVOIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuMTAgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTMzXG4gICAgfCBNSU5VUyAtPlxuICAgICAgICBfbWVuaGlyX3J1bjkgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTMzXG4gICAgfCBOT1QgLT5cbiAgICAgICAgX21lbmhpcl9ydW44IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUzM1xuICAgIHwgTlVNQkVSIF92IC0+XG4gICAgICAgIF9tZW5oaXJfcnVuNyBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMzMgX3YgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgfCBQTFVTIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuNiBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMzNcbiAgICB8IF8gLT5cbiAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgIF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IgPC0gdHJ1ZTtcbiAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTMzXG5cbmFuZCBfbWVuaGlyX3J1bjI1IDogX21lbmhpcl9lbnYgLT4gJ3R0dl90YWlsICogX21lbmhpcl9zdGF0ZSAqIChQcmVwcm9jZXNzLm1ldGFfZXhwcikgLT4gJ3R0dl9yZXR1cm4gPVxuICBmdW4gX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayAtPlxuICAgIGxldCBfbWVuaGlyX2VudiA9IF9tZW5oaXJfZGlzY2FyZCBfbWVuaGlyX2VudiBpblxuICAgIGxldCBfdG9rID0gX21lbmhpcl9lbnYuX21lbmhpcl90b2tlbiBpblxuICAgIG1hdGNoIF90b2sgd2l0aFxuICAgIHwgRVhDTEFNX01BUksgLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMiBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMjVcbiAgICB8IElEIF92IC0+XG4gICAgICAgIF9tZW5oaXJfcnVuMTEgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTI1IF92IF9tZW5oaXJfZW52Ll9tZW5oaXJfbGV4YnVmLkxleGluZy5sZXhfc3RhcnRfcFxuICAgIHwgTFBBUkVOIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuMTAgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTI1XG4gICAgfCBNSU5VUyAtPlxuICAgICAgICBfbWVuaGlyX3J1bjkgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTI1XG4gICAgfCBOT1QgLT5cbiAgICAgICAgX21lbmhpcl9ydW44IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUyNVxuICAgIHwgTlVNQkVSIF92IC0+XG4gICAgICAgIF9tZW5oaXJfcnVuNyBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMjUgX3YgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgfCBQTFVTIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuNiBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMjVcbiAgICB8IF8gLT5cbiAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgIF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IgPC0gdHJ1ZTtcbiAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTI1XG5cbmFuZCBfbWVuaGlyX3J1bjQ0IDogX21lbmhpcl9lbnYgLT4gJ3R0dl90YWlsICogX21lbmhpcl9zdGF0ZSAqIChQcmVwcm9jZXNzLm1ldGFfZXhwcikgLT4gJ3R0dl9yZXR1cm4gPVxuICBmdW4gX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayAtPlxuICAgIGxldCBfbWVuaGlyX2VudiA9IF9tZW5oaXJfZGlzY2FyZCBfbWVuaGlyX2VudiBpblxuICAgIGxldCBfdG9rID0gX21lbmhpcl9lbnYuX21lbmhpcl90b2tlbiBpblxuICAgIG1hdGNoIF90b2sgd2l0aFxuICAgIHwgRVhDTEFNX01BUksgLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMiBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNDRcbiAgICB8IElEIF92IC0+XG4gICAgICAgIF9tZW5oaXJfcnVuMTEgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTQ0IF92IF9tZW5oaXJfZW52Ll9tZW5oaXJfbGV4YnVmLkxleGluZy5sZXhfc3RhcnRfcFxuICAgIHwgTFBBUkVOIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuMTAgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTQ0XG4gICAgfCBNSU5VUyAtPlxuICAgICAgICBfbWVuaGlyX3J1bjkgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTQ0XG4gICAgfCBOT1QgLT5cbiAgICAgICAgX21lbmhpcl9ydW44IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU0NFxuICAgIHwgTlVNQkVSIF92IC0+XG4gICAgICAgIF9tZW5oaXJfcnVuNyBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNDQgX3YgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgfCBQTFVTIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuNiBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNDRcbiAgICB8IF8gLT5cbiAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgIF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IgPC0gdHJ1ZTtcbiAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTQ0XG5cbmFuZCBfbWVuaGlyX3J1bjQ2IDogX21lbmhpcl9lbnYgLT4gJ3R0dl90YWlsICogX21lbmhpcl9zdGF0ZSAqIChQcmVwcm9jZXNzLm1ldGFfZXhwcikgLT4gJ3R0dl9yZXR1cm4gPVxuICBmdW4gX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayAtPlxuICAgIGxldCBfbWVuaGlyX2VudiA9IF9tZW5oaXJfZGlzY2FyZCBfbWVuaGlyX2VudiBpblxuICAgIGxldCBfdG9rID0gX21lbmhpcl9lbnYuX21lbmhpcl90b2tlbiBpblxuICAgIG1hdGNoIF90b2sgd2l0aFxuICAgIHwgRVhDTEFNX01BUksgLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMiBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNDZcbiAgICB8IElEIF92IC0+XG4gICAgICAgIF9tZW5oaXJfcnVuMTEgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTQ2IF92IF9tZW5oaXJfZW52Ll9tZW5oaXJfbGV4YnVmLkxleGluZy5sZXhfc3RhcnRfcFxuICAgIHwgTFBBUkVOIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuMTAgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTQ2XG4gICAgfCBNSU5VUyAtPlxuICAgICAgICBfbWVuaGlyX3J1bjkgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTQ2XG4gICAgfCBOT1QgLT5cbiAgICAgICAgX21lbmhpcl9ydW44IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU0NlxuICAgIHwgTlVNQkVSIF92IC0+XG4gICAgICAgIF9tZW5oaXJfcnVuNyBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNDYgX3YgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgfCBQTFVTIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuNiBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNDZcbiAgICB8IF8gLT5cbiAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgIF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IgPC0gdHJ1ZTtcbiAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTQ2XG5cbmFuZCBfbWVuaGlyX3J1bjM1IDogX21lbmhpcl9lbnYgLT4gJ3R0dl90YWlsICogX21lbmhpcl9zdGF0ZSAqIChQcmVwcm9jZXNzLm1ldGFfZXhwcikgLT4gJ3R0dl9yZXR1cm4gPVxuICBmdW4gX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayAtPlxuICAgIGxldCBfbWVuaGlyX2VudiA9IF9tZW5oaXJfZGlzY2FyZCBfbWVuaGlyX2VudiBpblxuICAgIGxldCBfdG9rID0gX21lbmhpcl9lbnYuX21lbmhpcl90b2tlbiBpblxuICAgIG1hdGNoIF90b2sgd2l0aFxuICAgIHwgRVhDTEFNX01BUksgLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMiBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMzVcbiAgICB8IElEIF92IC0+XG4gICAgICAgIF9tZW5oaXJfcnVuMTEgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTM1IF92IF9tZW5oaXJfZW52Ll9tZW5oaXJfbGV4YnVmLkxleGluZy5sZXhfc3RhcnRfcFxuICAgIHwgTFBBUkVOIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuMTAgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTM1XG4gICAgfCBNSU5VUyAtPlxuICAgICAgICBfbWVuaGlyX3J1bjkgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTM1XG4gICAgfCBOT1QgLT5cbiAgICAgICAgX21lbmhpcl9ydW44IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUzNVxuICAgIHwgTlVNQkVSIF92IC0+XG4gICAgICAgIF9tZW5oaXJfcnVuNyBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMzUgX3YgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgfCBQTFVTIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuNiBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMzVcbiAgICB8IF8gLT5cbiAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgIF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IgPC0gdHJ1ZTtcbiAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTM1XG5cbmFuZCBfbWVuaGlyX2dvdG9fb2Zmc2V0IDogX21lbmhpcl9lbnYgLT4gJ3R0dl90YWlsIC0+IF9tZW5oaXJfc3RhdGUgLT4gKFBhcnNlcl9hc3Qub2Zmc2V0KSAtPiAndHR2X3JldHVybiA9XG4gIGZ1biBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyBfdiAtPlxuICAgIGxldCBfbWVuaGlyX3N0YWNrID0gKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgX3YpIGluXG4gICAgbWF0Y2ggX21lbmhpcl9zIHdpdGhcbiAgICB8IE1lbmhpclN0YXRlNTggLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCAoKChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MpLCAoaWQgOiAoXG4jIDEwIFwiSU8vcGFyc2VyLm1seVwiXG4gICAgICAgKHN0cmluZylcbiMgNDk0IFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgKSksIF9zdGFydHBvc19pZF8pLCBfLCAobyA6IChQYXJzZXJfYXN0Lm9mZnNldCkpKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF92IDogKFBhcnNlcl9hc3QuYXJncykgPSBcbiMgMTIxIFwiSU8vcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIE9mZnNldCAoaWQsIG8sIEFybS5Qb3N0SW5kZXhlZCkgKVxuIyA0OTkgXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAgX21lbmhpcl9nb3RvX2FyZyBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyBfdlxuICAgIHwgTWVuaGlyU3RhdGU3NCAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGFzc2VydCAobm90IF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IpO1xuICAgICAgICBsZXQgX3RvayA9IF9tZW5oaXJfZW52Ll9tZW5oaXJfdG9rZW4gaW5cbiAgICAgICAgKG1hdGNoIF90b2sgd2l0aFxuICAgICAgICB8IFJJR0hUX0JSQUNLIC0+XG4gICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBsZXQgX21lbmhpcl9lbnYgPSBfbWVuaGlyX2Rpc2NhcmQgX21lbmhpcl9lbnYgaW5cbiAgICAgICAgICAgIGxldCBfdG9rID0gX21lbmhpcl9lbnYuX21lbmhpcl90b2tlbiBpblxuICAgICAgICAgICAgKG1hdGNoIF90b2sgd2l0aFxuICAgICAgICAgICAgfCBFWENMQU1fTUFSSyAtPlxuICAgICAgICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgICAgICBsZXQgX21lbmhpcl9lbnYgPSBfbWVuaGlyX2Rpc2NhcmQgX21lbmhpcl9lbnYgaW5cbiAgICAgICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICAgICAgbGV0ICgoKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcyksIChpZCA6IChcbiMgMTAgXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAoc3RyaW5nKVxuIyA1MTkgXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICAgICAgICAgICkpLCBfc3RhcnRwb3NfaWRfKSwgXywgKG8gOiAoUGFyc2VyX2FzdC5vZmZzZXQpKSkgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICAgICAgbGV0IF92IDogKFBhcnNlcl9hc3QuYXJncykgPSBcbiMgMTE4IFwiSU8vcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggT2Zmc2V0IChpZCwgbywgQXJtLlByZUluZGV4ZWQpIClcbiMgNTI0IFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgICBfbWVuaGlyX2dvdG9fYXJnIF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX21lbmhpcl9zIF92XG4gICAgICAgICAgICB8IENPTU1BIHwgRU9GIHwgRU9MIHwgSU5URVJST0dfTUFSSyAtPlxuICAgICAgICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgICAgICBsZXQgKCgoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zKSwgKGlkIDogKFxuIyAxMCBcIklPL3BhcnNlci5tbHlcIlxuICAgICAgIChzdHJpbmcpXG4jIDUzMiBcIklPL3BhcnNlci5tbFwiXG4gICAgICAgICAgICAgICAgKSksIF9zdGFydHBvc19pZF8pLCBfLCAobyA6IChQYXJzZXJfYXN0Lm9mZnNldCkpKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgICAgICBsZXQgX3YgOiAoUGFyc2VyX2FzdC5hcmdzKSA9IFxuIyAxMTUgXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggT2Zmc2V0IChpZCwgbywgQXJtLk9mZnNldCkgKVxuIyA1MzcgXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgIF9tZW5oaXJfZ290b19hcmcgX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgX3ZcbiAgICAgICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgICAgIGFzc2VydCAobm90IF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IpO1xuICAgICAgICAgICAgICAgIF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IgPC0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICAgICAgbGV0IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIF8pID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgX21lbmhpcl9zKVxuICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgIGFzc2VydCAobm90IF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IpO1xuICAgICAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgbGV0IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIF8pID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBfbWVuaGlyX3MpXG4gICAgfCBfIC0+XG4gICAgICAgIF9tZW5oaXJfZmFpbCAoKVxuXG5hbmQgX21lbmhpcl9nb3RvX3NlcGFyYXRlZF9ub25lbXB0eV9saXN0X0NPTU1BX2FyZ18gOiBfbWVuaGlyX2VudiAtPiAndHR2X3RhaWwgLT4gX21lbmhpcl9zdGF0ZSAtPiAoUGFyc2VyX2FzdC5hcmdzIGxpc3QpIC0+ICd0dHZfcmV0dXJuID1cbiAgZnVuIF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX21lbmhpcl9zIF92IC0+XG4gICAgbWF0Y2ggX21lbmhpcl9zIHdpdGhcbiAgICB8IE1lbmhpclN0YXRlNTMgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCAoeCA6IChQYXJzZXJfYXN0LmFyZ3MgbGlzdCkpID0gX3YgaW5cbiAgICAgICAgbGV0IF92IDogKFBhcnNlcl9hc3QuYXJncyBsaXN0KSA9IFxuIyAxNDQgXCI8c3RhbmRhcmQubWx5PlwiXG4gICAgKCB4IClcbiMgNTY1IFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIF9tZW5oaXJfZ290b19sb3B0aW9uX3NlcGFyYXRlZF9ub25lbXB0eV9saXN0X0NPTU1BX2FyZ19fIF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX21lbmhpcl9zIF92XG4gICAgfCBNZW5oaXJTdGF0ZTg3IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgKHhzIDogKFBhcnNlcl9hc3QuYXJncyBsaXN0KSkgPSBfdiBpblxuICAgICAgICBsZXQgKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgKHggOiAoUGFyc2VyX2FzdC5hcmdzKSkpID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgX3YgOiAoUGFyc2VyX2FzdC5hcmdzIGxpc3QpID0gXG4jIDI0MyBcIjxzdGFuZGFyZC5tbHk+XCJcbiAgICAoIHggOjogeHMgKVxuIyA1NzYgXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAgX21lbmhpcl9nb3RvX3NlcGFyYXRlZF9ub25lbXB0eV9saXN0X0NPTU1BX2FyZ18gX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgX3ZcbiAgICB8IF8gLT5cbiAgICAgICAgX21lbmhpcl9mYWlsICgpXG5cbmFuZCBfbWVuaGlyX2dvdG9fbWV0YV9leHByIDogX21lbmhpcl9lbnYgLT4gJ3R0dl90YWlsIC0+IF9tZW5oaXJfc3RhdGUgLT4gKFByZXByb2Nlc3MubWV0YV9leHByKSAtPiAndHR2X3JldHVybiA9XG4gIGZ1biBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyBfdiAtPlxuICAgIGxldCBfbWVuaGlyX3N0YWNrID0gKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgX3YpIGluXG4gICAgbWF0Y2ggX21lbmhpcl9zIHdpdGhcbiAgICB8IE1lbmhpclN0YXRlMTIgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCAoKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcyksIF8sIChlIDogKFByZXByb2Nlc3MubWV0YV9leHByKSkpID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgX3YgOiAoUHJlcHJvY2Vzcy5tZXRhX2V4cHIpID0gXG4jIDgwIFwiSU8vcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIE1VbmFyeSAoT0JOb3QsIGUpIClcbiMgNTkzIFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIF9tZW5oaXJfZ290b19tZXRhX2V4cHIgX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgX3ZcbiAgICB8IE1lbmhpclN0YXRlMTAgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgbGV0IF90b2sgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX3Rva2VuIGluXG4gICAgICAgIChtYXRjaCBfdG9rIHdpdGhcbiAgICAgICAgfCBBTkQgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMzUgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IEJBTkQgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuNDYgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IEJPUiAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW40NCBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgRElWIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjI1IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBFUSAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4zMyBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgSU5URVJST0dfTUFSSyAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW40MCBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgTFNISUZUIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjMxIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBNSU5VUyAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4yNyBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgTU9EIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjIzIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBORVEgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMjkgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IE9SIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjM4IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBQTFVTIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjIxIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBSUEFSRU4gLT5cbiAgICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgIGxldCBfbWVuaGlyX2VudiA9IF9tZW5oaXJfZGlzY2FyZCBfbWVuaGlyX2VudiBpblxuICAgICAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgbGV0ICgoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zKSwgXywgKGUgOiAoUHJlcHJvY2Vzcy5tZXRhX2V4cHIpKSkgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBsZXQgX3YgOiAoUHJlcHJvY2Vzcy5tZXRhX2V4cHIpID0gXG4jIDYyIFwiSU8vcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggZSApXG4jIDYzMyBcIklPL3BhcnNlci5tbFwiXG4gICAgICAgICAgICAgaW5cbiAgICAgICAgICAgIF9tZW5oaXJfZ290b19tZXRhX2V4cHIgX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgX3ZcbiAgICAgICAgfCBSU0hJRlQgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMTkgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IFRJTUVTIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjE3IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBYT1IgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMTUgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgIGFzc2VydCAobm90IF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IpO1xuICAgICAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgbGV0IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIF8pID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBfbWVuaGlyX3MpXG4gICAgfCBNZW5oaXJTdGF0ZTE1IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgIGxldCBfdG9rID0gX21lbmhpcl9lbnYuX21lbmhpcl90b2tlbiBpblxuICAgICAgICAobWF0Y2ggX3RvayB3aXRoXG4gICAgICAgIHwgQU5EIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjM1IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBESVYgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMjUgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IEVRIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjMzIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBMU0hJRlQgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMzEgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IE1JTlVTIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjI3IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBNT0QgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMjMgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IE5FUSAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4yOSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgUExVUyAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4yMSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgUlNISUZUIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjE5IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBUSU1FUyAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4xNyBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgQkFORCB8IEJPUiB8IENPTE9OIHwgRU9MIHwgSU5URVJST0dfTUFSSyB8IE9SIHwgUklHSFRfQlJBQ0UgfCBSUEFSRU4gfCBYT1IgLT5cbiAgICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgIGxldCAoKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgKGUxIDogKFByZXByb2Nlc3MubWV0YV9leHByKSkpLCBfLCAoZTIgOiAoUHJlcHJvY2Vzcy5tZXRhX2V4cHIpKSkgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBsZXQgX3YgOiAoUHJlcHJvY2Vzcy5tZXRhX2V4cHIpID0gXG4jIDY5IFwiSU8vcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggTUJpbmFyeSAoT1hvciwgZTEsIGUyKSApXG4jIDY3OSBcIklPL3BhcnNlci5tbFwiXG4gICAgICAgICAgICAgaW5cbiAgICAgICAgICAgIF9tZW5oaXJfZ290b19tZXRhX2V4cHIgX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgX3ZcbiAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgICAgIF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IgPC0gdHJ1ZTtcbiAgICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgIGxldCAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zLCBfKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgX21lbmhpcl9zKVxuICAgIHwgTWVuaGlyU3RhdGUxNyAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0ICgoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zLCAoZTEgOiAoUHJlcHJvY2Vzcy5tZXRhX2V4cHIpKSksIF8sIChlMiA6IChQcmVwcm9jZXNzLm1ldGFfZXhwcikpKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF92IDogKFByZXByb2Nlc3MubWV0YV9leHByKSA9IFxuIyA2NSBcIklPL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggTUJpbmFyeSAoT011bCwgZTEsIGUyKSApXG4jIDY5NSBcIklPL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICBfbWVuaGlyX2dvdG9fbWV0YV9leHByIF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX21lbmhpcl9zIF92XG4gICAgfCBNZW5oaXJTdGF0ZTE5IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgIGxldCBfdG9rID0gX21lbmhpcl9lbnYuX21lbmhpcl90b2tlbiBpblxuICAgICAgICAobWF0Y2ggX3RvayB3aXRoXG4gICAgICAgIHwgRElWIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjI1IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBNSU5VUyAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4yNyBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgTU9EIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjIzIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBQTFVTIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjIxIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBUSU1FUyAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4xNyBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgQU5EIHwgQkFORCB8IEJPUiB8IENPTE9OIHwgRU9MIHwgRVEgfCBJTlRFUlJPR19NQVJLIHwgTFNISUZUIHwgTkVRIHwgT1IgfCBSSUdIVF9CUkFDRSB8IFJQQVJFTiB8IFJTSElGVCB8IFhPUiAtPlxuICAgICAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgbGV0ICgoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zLCAoZTEgOiAoUHJlcHJvY2Vzcy5tZXRhX2V4cHIpKSksIF8sIChlMiA6IChQcmVwcm9jZXNzLm1ldGFfZXhwcikpKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgIGxldCBfdiA6IChQcmVwcm9jZXNzLm1ldGFfZXhwcikgPSBcbiMgNzYgXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBNQmluYXJ5IChPUlNoaWZ0LCBlMSwgZTIpIClcbiMgNzE5IFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgICAgICBpblxuICAgICAgICAgICAgX21lbmhpcl9nb3RvX21ldGFfZXhwciBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyBfdlxuICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgIGFzc2VydCAobm90IF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IpO1xuICAgICAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgbGV0IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIF8pID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBfbWVuaGlyX3MpXG4gICAgfCBNZW5oaXJTdGF0ZTIxIC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgIGxldCBfdG9rID0gX21lbmhpcl9lbnYuX21lbmhpcl90b2tlbiBpblxuICAgICAgICAobWF0Y2ggX3RvayB3aXRoXG4gICAgICAgIHwgRElWIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjI1IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBNT0QgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMjMgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IFRJTUVTIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjE3IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBBTkQgfCBCQU5EIHwgQk9SIHwgQ09MT04gfCBFT0wgfCBFUSB8IElOVEVSUk9HX01BUksgfCBMU0hJRlQgfCBNSU5VUyB8IE5FUSB8IE9SIHwgUExVUyB8IFJJR0hUX0JSQUNFIHwgUlBBUkVOIHwgUlNISUZUIHwgWE9SIC0+XG4gICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBsZXQgKChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIChlMSA6IChQcmVwcm9jZXNzLm1ldGFfZXhwcikpKSwgXywgKGUyIDogKFByZXByb2Nlc3MubWV0YV9leHByKSkpID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgbGV0IF92IDogKFByZXByb2Nlc3MubWV0YV9leHByKSA9IFxuIyA2MyBcIklPL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBNQmluYXJ5IChPQWRkLCBlMSwgZTIpIClcbiMgNzQ1IFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgICAgICBpblxuICAgICAgICAgICAgX21lbmhpcl9nb3RvX21ldGFfZXhwciBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyBfdlxuICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgIGFzc2VydCAobm90IF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IpO1xuICAgICAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgbGV0IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIF8pID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBfbWVuaGlyX3MpXG4gICAgfCBNZW5oaXJTdGF0ZTIzIC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgKChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIChlMSA6IChQcmVwcm9jZXNzLm1ldGFfZXhwcikpKSwgXywgKGUyIDogKFByZXByb2Nlc3MubWV0YV9leHByKSkpID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgX3YgOiAoUHJlcHJvY2Vzcy5tZXRhX2V4cHIpID0gXG4jIDY3IFwiSU8vcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggTUJpbmFyeSAoT01vZCwgZTEsIGUyKSApXG4jIDc2MSBcIklPL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICBfbWVuaGlyX2dvdG9fbWV0YV9leHByIF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX21lbmhpcl9zIF92XG4gICAgfCBNZW5oaXJTdGF0ZTI1IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgKChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIChlMSA6IChQcmVwcm9jZXNzLm1ldGFfZXhwcikpKSwgXywgKGUyIDogKFByZXByb2Nlc3MubWV0YV9leHByKSkpID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgX3YgOiAoUHJlcHJvY2Vzcy5tZXRhX2V4cHIpID0gXG4jIDY2IFwiSU8vcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggTUJpbmFyeSAoT0RpdiwgZTEsIGUyKSApXG4jIDc3MSBcIklPL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICBfbWVuaGlyX2dvdG9fbWV0YV9leHByIF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX21lbmhpcl9zIF92XG4gICAgfCBNZW5oaXJTdGF0ZTI3IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgIGxldCBfdG9rID0gX21lbmhpcl9lbnYuX21lbmhpcl90b2tlbiBpblxuICAgICAgICAobWF0Y2ggX3RvayB3aXRoXG4gICAgICAgIHwgRElWIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjI1IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBNT0QgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMjMgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IFRJTUVTIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjE3IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBBTkQgfCBCQU5EIHwgQk9SIHwgQ09MT04gfCBFT0wgfCBFUSB8IElOVEVSUk9HX01BUksgfCBMU0hJRlQgfCBNSU5VUyB8IE5FUSB8IE9SIHwgUExVUyB8IFJJR0hUX0JSQUNFIHwgUlBBUkVOIHwgUlNISUZUIHwgWE9SIC0+XG4gICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBsZXQgKChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIChlMSA6IChQcmVwcm9jZXNzLm1ldGFfZXhwcikpKSwgXywgKGUyIDogKFByZXByb2Nlc3MubWV0YV9leHByKSkpID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgbGV0IF92IDogKFByZXByb2Nlc3MubWV0YV9leHByKSA9IFxuIyA2NCBcIklPL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggTUJpbmFyeSAoT1N1YiwgZTEsIGUyKSApXG4jIDc5MSBcIklPL3BhcnNlci5tbFwiXG4gICAgICAgICAgICAgaW5cbiAgICAgICAgICAgIF9tZW5oaXJfZ290b19tZXRhX2V4cHIgX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgX3ZcbiAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgICAgIF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IgPC0gdHJ1ZTtcbiAgICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgIGxldCAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zLCBfKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgX21lbmhpcl9zKVxuICAgIHwgTWVuaGlyU3RhdGUyOSAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGFzc2VydCAobm90IF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IpO1xuICAgICAgICBsZXQgX3RvayA9IF9tZW5oaXJfZW52Ll9tZW5oaXJfdG9rZW4gaW5cbiAgICAgICAgKG1hdGNoIF90b2sgd2l0aFxuICAgICAgICB8IERJViAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4yNSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgTFNISUZUIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjMxIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBNSU5VUyAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4yNyBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgTU9EIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjIzIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBQTFVTIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjIxIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBSU0hJRlQgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMTkgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IFRJTUVTIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjE3IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBBTkQgfCBCQU5EIHwgQk9SIHwgQ09MT04gfCBFT0wgfCBFUSB8IElOVEVSUk9HX01BUksgfCBORVEgfCBPUiB8IFJJR0hUX0JSQUNFIHwgUlBBUkVOIHwgWE9SIC0+XG4gICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBsZXQgKChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIChlMSA6IChQcmVwcm9jZXNzLm1ldGFfZXhwcikpKSwgXywgKGUyIDogKFByZXByb2Nlc3MubWV0YV9leHByKSkpID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgbGV0IF92IDogKFByZXByb2Nlc3MubWV0YV9leHByKSA9IFxuIyA3NCBcIklPL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIE1CaW5hcnkgKE9OZXEsIGUxLCBlMikgKVxuIyA4MjUgXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICAgICAgIGluXG4gICAgICAgICAgICBfbWVuaGlyX2dvdG9fbWV0YV9leHByIF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX21lbmhpcl9zIF92XG4gICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgICAgICBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yIDwtIHRydWU7XG4gICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBsZXQgKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgXykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIF9tZW5oaXJfcylcbiAgICB8IE1lbmhpclN0YXRlMzEgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgbGV0IF90b2sgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX3Rva2VuIGluXG4gICAgICAgIChtYXRjaCBfdG9rIHdpdGhcbiAgICAgICAgfCBESVYgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMjUgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IE1JTlVTIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjI3IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBNT0QgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMjMgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IFBMVVMgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMjEgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IFRJTUVTIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjE3IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBBTkQgfCBCQU5EIHwgQk9SIHwgQ09MT04gfCBFT0wgfCBFUSB8IElOVEVSUk9HX01BUksgfCBMU0hJRlQgfCBORVEgfCBPUiB8IFJJR0hUX0JSQUNFIHwgUlBBUkVOIHwgUlNISUZUIHwgWE9SIC0+XG4gICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBsZXQgKChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIChlMSA6IChQcmVwcm9jZXNzLm1ldGFfZXhwcikpKSwgXywgKGUyIDogKFByZXByb2Nlc3MubWV0YV9leHByKSkpID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgbGV0IF92IDogKFByZXByb2Nlc3MubWV0YV9leHByKSA9IFxuIyA3NSBcIklPL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIE1CaW5hcnkgKE9MU2hpZnQsIGUxLCBlMikgKVxuIyA4NTUgXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICAgICAgIGluXG4gICAgICAgICAgICBfbWVuaGlyX2dvdG9fbWV0YV9leHByIF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX21lbmhpcl9zIF92XG4gICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgICAgICBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yIDwtIHRydWU7XG4gICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBsZXQgKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgXykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIF9tZW5oaXJfcylcbiAgICB8IE1lbmhpclN0YXRlMzMgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgbGV0IF90b2sgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX3Rva2VuIGluXG4gICAgICAgIChtYXRjaCBfdG9rIHdpdGhcbiAgICAgICAgfCBESVYgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMjUgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IExTSElGVCAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4zMSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgTUlOVVMgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMjcgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IE1PRCAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4yMyBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgUExVUyAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4yMSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgUlNISUZUIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjE5IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBUSU1FUyAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4xNyBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgQU5EIHwgQkFORCB8IEJPUiB8IENPTE9OIHwgRU9MIHwgRVEgfCBJTlRFUlJPR19NQVJLIHwgTkVRIHwgT1IgfCBSSUdIVF9CUkFDRSB8IFJQQVJFTiB8IFhPUiAtPlxuICAgICAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgbGV0ICgoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zLCAoZTEgOiAoUHJlcHJvY2Vzcy5tZXRhX2V4cHIpKSksIF8sIChlMiA6IChQcmVwcm9jZXNzLm1ldGFfZXhwcikpKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgIGxldCBfdiA6IChQcmVwcm9jZXNzLm1ldGFfZXhwcikgPSBcbiMgNzMgXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIE1CaW5hcnkgKE9FcSwgZTEsIGUyKSApXG4jIDg4OSBcIklPL3BhcnNlci5tbFwiXG4gICAgICAgICAgICAgaW5cbiAgICAgICAgICAgIF9tZW5oaXJfZ290b19tZXRhX2V4cHIgX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgX3ZcbiAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgICAgIF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IgPC0gdHJ1ZTtcbiAgICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgIGxldCAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zLCBfKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgX21lbmhpcl9zKVxuICAgIHwgTWVuaGlyU3RhdGUzNSAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGFzc2VydCAobm90IF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IpO1xuICAgICAgICBsZXQgX3RvayA9IF9tZW5oaXJfZW52Ll9tZW5oaXJfdG9rZW4gaW5cbiAgICAgICAgKG1hdGNoIF90b2sgd2l0aFxuICAgICAgICB8IERJViAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4yNSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgRVEgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMzMgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IExTSElGVCAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4zMSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgTUlOVVMgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMjcgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IE1PRCAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4yMyBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgTkVRIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjI5IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBQTFVTIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjIxIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBSU0hJRlQgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMTkgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IFRJTUVTIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjE3IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBBTkQgfCBCQU5EIHwgQk9SIHwgQ09MT04gfCBFT0wgfCBJTlRFUlJPR19NQVJLIHwgT1IgfCBSSUdIVF9CUkFDRSB8IFJQQVJFTiB8IFhPUiAtPlxuICAgICAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgbGV0ICgoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zLCAoZTEgOiAoUHJlcHJvY2Vzcy5tZXRhX2V4cHIpKSksIF8sIChlMiA6IChQcmVwcm9jZXNzLm1ldGFfZXhwcikpKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgIGxldCBfdiA6IChQcmVwcm9jZXNzLm1ldGFfZXhwcikgPSBcbiMgNjggXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBNQmluYXJ5IChPQW5kLCBlMSwgZTIpIClcbiMgOTI3IFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgICAgICBpblxuICAgICAgICAgICAgX21lbmhpcl9nb3RvX21ldGFfZXhwciBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyBfdlxuICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgIGFzc2VydCAobm90IF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IpO1xuICAgICAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgbGV0IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIF8pID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBfbWVuaGlyX3MpXG4gICAgfCBNZW5oaXJTdGF0ZTM4IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgIGxldCBfdG9rID0gX21lbmhpcl9lbnYuX21lbmhpcl90b2tlbiBpblxuICAgICAgICAobWF0Y2ggX3RvayB3aXRoXG4gICAgICAgIHwgQU5EIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjM1IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBESVYgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMjUgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IEVRIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjMzIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBMU0hJRlQgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMzEgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IE1JTlVTIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjI3IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBNT0QgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMjMgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IE5FUSAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4yOSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgUExVUyAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4yMSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgUlNISUZUIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjE5IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBUSU1FUyAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4xNyBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgWE9SIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjE1IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBCQU5EIHwgQk9SIHwgQ09MT04gfCBFT0wgfCBJTlRFUlJPR19NQVJLIHwgT1IgfCBSSUdIVF9CUkFDRSB8IFJQQVJFTiAtPlxuICAgICAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgbGV0ICgoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zLCAoZTEgOiAoUHJlcHJvY2Vzcy5tZXRhX2V4cHIpKSksIF8sIChlMiA6IChQcmVwcm9jZXNzLm1ldGFfZXhwcikpKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgIGxldCBfdiA6IChQcmVwcm9jZXNzLm1ldGFfZXhwcikgPSBcbiMgNzAgXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIE1CaW5hcnkgKE9PciwgZTEsIGUyKSApXG4jIDk2OSBcIklPL3BhcnNlci5tbFwiXG4gICAgICAgICAgICAgaW5cbiAgICAgICAgICAgIF9tZW5oaXJfZ290b19tZXRhX2V4cHIgX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgX3ZcbiAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgICAgIF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IgPC0gdHJ1ZTtcbiAgICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgIGxldCAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zLCBfKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgX21lbmhpcl9zKVxuICAgIHwgTWVuaGlyU3RhdGU0MCAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGFzc2VydCAobm90IF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IpO1xuICAgICAgICBsZXQgX3RvayA9IF9tZW5oaXJfZW52Ll9tZW5oaXJfdG9rZW4gaW5cbiAgICAgICAgKG1hdGNoIF90b2sgd2l0aFxuICAgICAgICB8IEFORCAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4zNSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgQkFORCAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW40NiBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgQk9SIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjQ0IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBDT0xPTiAtPlxuICAgICAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgbGV0IF9tZW5oaXJfZW52ID0gX21lbmhpcl9kaXNjYXJkIF9tZW5oaXJfZW52IGluXG4gICAgICAgICAgICBsZXQgX3RvayA9IF9tZW5oaXJfZW52Ll9tZW5oaXJfdG9rZW4gaW5cbiAgICAgICAgICAgIChtYXRjaCBfdG9rIHdpdGhcbiAgICAgICAgICAgIHwgRVhDTEFNX01BUksgLT5cbiAgICAgICAgICAgICAgICBfbWVuaGlyX3J1bjEyIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU0MlxuICAgICAgICAgICAgfCBJRCBfdiAtPlxuICAgICAgICAgICAgICAgIF9tZW5oaXJfcnVuMTEgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTQyIF92IF9tZW5oaXJfZW52Ll9tZW5oaXJfbGV4YnVmLkxleGluZy5sZXhfc3RhcnRfcFxuICAgICAgICAgICAgfCBMUEFSRU4gLT5cbiAgICAgICAgICAgICAgICBfbWVuaGlyX3J1bjEwIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU0MlxuICAgICAgICAgICAgfCBNSU5VUyAtPlxuICAgICAgICAgICAgICAgIF9tZW5oaXJfcnVuOSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNDJcbiAgICAgICAgICAgIHwgTk9UIC0+XG4gICAgICAgICAgICAgICAgX21lbmhpcl9ydW44IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU0MlxuICAgICAgICAgICAgfCBOVU1CRVIgX3YgLT5cbiAgICAgICAgICAgICAgICBfbWVuaGlyX3J1bjcgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTQyIF92IF9tZW5oaXJfZW52Ll9tZW5oaXJfbGV4YnVmLkxleGluZy5sZXhfc3RhcnRfcFxuICAgICAgICAgICAgfCBQTFVTIC0+XG4gICAgICAgICAgICAgICAgX21lbmhpcl9ydW42IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU0MlxuICAgICAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgICAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICAgICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU0MilcbiAgICAgICAgfCBESVYgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMjUgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IEVRIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjMzIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBJTlRFUlJPR19NQVJLIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjQwIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBMU0hJRlQgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMzEgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IE1JTlVTIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjI3IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBNT0QgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMjMgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IE5FUSAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4yOSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgT1IgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMzggX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IFBMVVMgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMjEgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IFJTSElGVCAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4xOSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgVElNRVMgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMTcgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IFhPUiAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4xNSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgICAgICBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yIDwtIHRydWU7XG4gICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBsZXQgKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgXykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIF9tZW5oaXJfcylcbiAgICB8IE1lbmhpclN0YXRlNDIgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgbGV0IF90b2sgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX3Rva2VuIGluXG4gICAgICAgIChtYXRjaCBfdG9rIHdpdGhcbiAgICAgICAgfCBBTkQgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMzUgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IEJBTkQgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuNDYgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IEJPUiAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW40NCBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgRElWIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjI1IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBFUSAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4zMyBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgSU5URVJST0dfTUFSSyAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW40MCBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgTFNISUZUIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjMxIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBNSU5VUyAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4yNyBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgTU9EIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjIzIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBORVEgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMjkgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IE9SIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjM4IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBQTFVTIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjIxIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBSU0hJRlQgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMTkgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IFRJTUVTIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjE3IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBYT1IgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMTUgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IENPTE9OIHwgRU9MIHwgUklHSFRfQlJBQ0UgfCBSUEFSRU4gLT5cbiAgICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgIGxldCAoKChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIChlMCA6IChQcmVwcm9jZXNzLm1ldGFfZXhwcikpKSwgXywgKGUxIDogKFByZXByb2Nlc3MubWV0YV9leHByKSkpLCBfLCAoZTIgOiAoUHJlcHJvY2Vzcy5tZXRhX2V4cHIpKSkgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBsZXQgX3YgOiAoUHJlcHJvY2Vzcy5tZXRhX2V4cHIpID0gXG4jIDgyIFwiSU8vcGFyc2VyLm1seVwiXG4gICggTUNvbmQgKGUwLCBlMSwgZTIpIClcbiMgMTA4MyBcIklPL3BhcnNlci5tbFwiXG4gICAgICAgICAgICAgaW5cbiAgICAgICAgICAgIF9tZW5oaXJfZ290b19tZXRhX2V4cHIgX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgX3ZcbiAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgICAgIF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IgPC0gdHJ1ZTtcbiAgICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgIGxldCAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zLCBfKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgX21lbmhpcl9zKVxuICAgIHwgTWVuaGlyU3RhdGU0NCAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGFzc2VydCAobm90IF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IpO1xuICAgICAgICBsZXQgX3RvayA9IF9tZW5oaXJfZW52Ll9tZW5oaXJfdG9rZW4gaW5cbiAgICAgICAgKG1hdGNoIF90b2sgd2l0aFxuICAgICAgICB8IEFORCAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4zNSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgQkFORCAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW40NiBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgRElWIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjI1IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBFUSAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4zMyBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgTFNISUZUIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjMxIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBNSU5VUyAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4yNyBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgTU9EIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjIzIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBORVEgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMjkgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IE9SIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjM4IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBQTFVTIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjIxIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBSU0hJRlQgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMTkgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IFRJTUVTIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjE3IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBYT1IgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMTUgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IEJPUiB8IENPTE9OIHwgRU9MIHwgSU5URVJST0dfTUFSSyB8IFJJR0hUX0JSQUNFIHwgUlBBUkVOIC0+XG4gICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBsZXQgKChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIChlMSA6IChQcmVwcm9jZXNzLm1ldGFfZXhwcikpKSwgXywgKGUyIDogKFByZXByb2Nlc3MubWV0YV9leHByKSkpID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgbGV0IF92IDogKFByZXByb2Nlc3MubWV0YV9leHByKSA9IFxuIyA3MSBcIklPL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIE1CaW5hcnkgKE9CT3IsIGUxLCBlMikgKVxuIyAxMTI5IFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgICAgICBpblxuICAgICAgICAgICAgX21lbmhpcl9nb3RvX21ldGFfZXhwciBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyBfdlxuICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgIGFzc2VydCAobm90IF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IpO1xuICAgICAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgbGV0IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIF8pID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBfbWVuaGlyX3MpXG4gICAgfCBNZW5oaXJTdGF0ZTQ2IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgIGxldCBfdG9rID0gX21lbmhpcl9lbnYuX21lbmhpcl90b2tlbiBpblxuICAgICAgICAobWF0Y2ggX3RvayB3aXRoXG4gICAgICAgIHwgQU5EIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjM1IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBESVYgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMjUgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IEVRIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjMzIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBMU0hJRlQgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMzEgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IE1JTlVTIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjI3IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBNT0QgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMjMgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IE5FUSAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4yOSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgT1IgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMzggX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IFBMVVMgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMjEgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IFJTSElGVCAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4xOSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgVElNRVMgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMTcgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IFhPUiAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4xNSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgQkFORCB8IEJPUiB8IENPTE9OIHwgRU9MIHwgSU5URVJST0dfTUFSSyB8IFJJR0hUX0JSQUNFIHwgUlBBUkVOIC0+XG4gICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBsZXQgKChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIChlMSA6IChQcmVwcm9jZXNzLm1ldGFfZXhwcikpKSwgXywgKGUyIDogKFByZXByb2Nlc3MubWV0YV9leHByKSkpID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgbGV0IF92IDogKFByZXByb2Nlc3MubWV0YV9leHByKSA9IFxuIyA3MiBcIklPL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBNQmluYXJ5IChPQkFuZCwgZTEsIGUyKSApXG4jIDExNzMgXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICAgICAgIGluXG4gICAgICAgICAgICBfbWVuaGlyX2dvdG9fbWV0YV9leHByIF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX21lbmhpcl9zIF92XG4gICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgICAgICBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yIDwtIHRydWU7XG4gICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBsZXQgKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgXykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIF9tZW5oaXJfcylcbiAgICB8IE1lbmhpclN0YXRlOSAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0ICgoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zKSwgXywgKGUgOiAoUHJlcHJvY2Vzcy5tZXRhX2V4cHIpKSkgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBfdiA6IChQcmVwcm9jZXNzLm1ldGFfZXhwcikgPSBcbiMgNzggXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIE1VbmFyeSAoT05lZywgZSkgKVxuIyAxMTg5IFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIF9tZW5oaXJfZ290b19tZXRhX2V4cHIgX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgX3ZcbiAgICB8IE1lbmhpclN0YXRlOCAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0ICgoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zKSwgXywgKGUgOiAoUHJlcHJvY2Vzcy5tZXRhX2V4cHIpKSkgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBfdiA6IChQcmVwcm9jZXNzLm1ldGFfZXhwcikgPSBcbiMgNzkgXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAoIE1VbmFyeSAoT05vdCwgZSkgKVxuIyAxMTk5IFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIF9tZW5oaXJfZ290b19tZXRhX2V4cHIgX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgX3ZcbiAgICB8IE1lbmhpclN0YXRlNiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0ICgoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zKSwgXywgKGUgOiAoUHJlcHJvY2Vzcy5tZXRhX2V4cHIpKSkgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBfdiA6IChQcmVwcm9jZXNzLm1ldGFfZXhwcikgPSBcbiMgNzcgXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBNVW5hcnkgKE9JZCwgZSkgKVxuIyAxMjA5IFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIF9tZW5oaXJfZ290b19tZXRhX2V4cHIgX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgX3ZcbiAgICB8IE1lbmhpclN0YXRlNSAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGFzc2VydCAobm90IF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IpO1xuICAgICAgICBsZXQgX3RvayA9IF9tZW5oaXJfZW52Ll9tZW5oaXJfdG9rZW4gaW5cbiAgICAgICAgKG1hdGNoIF90b2sgd2l0aFxuICAgICAgICB8IEFORCAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4zNSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgQkFORCAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW40NiBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgQk9SIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjQ0IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBESVYgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMjUgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IEVRIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjMzIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBJTlRFUlJPR19NQVJLIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjQwIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBMU0hJRlQgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMzEgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IE1JTlVTIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjI3IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBNT0QgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMjMgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IE5FUSAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4yOSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgT1IgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMzggX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IFBMVVMgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMjEgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IFJJR0hUX0JSQUNFIC0+XG4gICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBsZXQgX21lbmhpcl9lbnYgPSBfbWVuaGlyX2Rpc2NhcmQgX21lbmhpcl9lbnYgaW5cbiAgICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgIGxldCAoKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgX3N0YXJ0cG9zX18xXyksIF8sIChlIDogKFByZXByb2Nlc3MubWV0YV9leHByKSkpID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19fMV8gaW5cbiAgICAgICAgICAgIGxldCBfdiA6IChQYXJzZXJfYXN0LnVucHJvY2Vzc2VkX2ludDMyKSA9IFxuIyAxMzQgXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIE1ldGFFeHByIGUgKVxuIyAxMjUwIFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgICAgICBpblxuICAgICAgICAgICAgX21lbmhpcl9nb3RvX251bWJlciBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyBfdiBfc3RhcnRwb3NcbiAgICAgICAgfCBSU0hJRlQgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMTkgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IFRJTUVTIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjE3IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBYT1IgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMTUgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgIGFzc2VydCAobm90IF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IpO1xuICAgICAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgbGV0IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIF8pID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBfbWVuaGlyX3MpXG4gICAgfCBNZW5oaXJTdGF0ZTEwMCAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGFzc2VydCAobm90IF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IpO1xuICAgICAgICBsZXQgX3RvayA9IF9tZW5oaXJfZW52Ll9tZW5oaXJfdG9rZW4gaW5cbiAgICAgICAgKG1hdGNoIF90b2sgd2l0aFxuICAgICAgICB8IEFORCAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4zNSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgQkFORCAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW40NiBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgQk9SIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjQ0IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBESVYgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMjUgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IEVRIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjMzIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBJTlRFUlJPR19NQVJLIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjQwIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBMU0hJRlQgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMzEgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IE1JTlVTIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjI3IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBNT0QgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMjMgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IE5FUSAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4yOSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgT1IgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMzggX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IFBMVVMgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMjEgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IFJTSElGVCAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4xOSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgVElNRVMgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMTcgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IFhPUiAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4xNSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgRU9MIC0+XG4gICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBsZXQgKChfbWVuaGlyX3N0YWNrLCAoaWQgOiAoXG4jIDEwIFwiSU8vcGFyc2VyLm1seVwiXG4gICAgICAgKHN0cmluZylcbiMgMTMwNSBcIklPL3BhcnNlci5tbFwiXG4gICAgICAgICAgICApKSwgX3N0YXJ0cG9zX2lkXyksIF8sIChlIDogKFByZXByb2Nlc3MubWV0YV9leHByKSkpID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgbGV0IF92IDogKFByZXByb2Nlc3MuZGVmaW5pdGlvbikgPSBcbiMgOTAgXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIFZhckRlZiAoaWQsIHRydWUsIGUpIClcbiMgMTMxMCBcIklPL3BhcnNlci5tbFwiXG4gICAgICAgICAgICAgaW5cbiAgICAgICAgICAgIF9tZW5oaXJfZ290b19kZWZpbml0aW9uIF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX3ZcbiAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgICAgIF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IgPC0gdHJ1ZTtcbiAgICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgIGxldCAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zLCBfKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgX21lbmhpcl9zKVxuICAgIHwgTWVuaGlyU3RhdGUxMDIgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgbGV0IF90b2sgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX3Rva2VuIGluXG4gICAgICAgIChtYXRjaCBfdG9rIHdpdGhcbiAgICAgICAgfCBBTkQgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMzUgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IEJBTkQgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuNDYgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IEJPUiAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW40NCBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgRElWIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjI1IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBFUSAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4zMyBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgSU5URVJST0dfTUFSSyAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW40MCBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgTFNISUZUIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjMxIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBNSU5VUyAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4yNyBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgTU9EIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjIzIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBORVEgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMjkgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IE9SIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjM4IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBQTFVTIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjIxIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBSU0hJRlQgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMTkgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IFRJTUVTIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjE3IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBYT1IgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMTUgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IEVPTCAtPlxuICAgICAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgbGV0ICgoX21lbmhpcl9zdGFjaywgKGlkIDogKFxuIyAxMCBcIklPL3BhcnNlci5tbHlcIlxuICAgICAgIChzdHJpbmcpXG4jIDEzNTkgXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICAgICAgKSksIF9zdGFydHBvc19pZF8pLCBfLCAoZSA6IChQcmVwcm9jZXNzLm1ldGFfZXhwcikpKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgIGxldCBfdiA6IChQcmVwcm9jZXNzLmRlZmluaXRpb24pID0gXG4jIDg5IFwiSU8vcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIFZhckRlZiAoaWQsIGZhbHNlLCBlKSApXG4jIDEzNjQgXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICAgICAgIGluXG4gICAgICAgICAgICBfbWVuaGlyX2dvdG9fZGVmaW5pdGlvbiBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF92XG4gICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgICAgICBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yIDwtIHRydWU7XG4gICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBsZXQgKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgXykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIF9tZW5oaXJfcylcbiAgICB8IF8gLT5cbiAgICAgICAgX21lbmhpcl9mYWlsICgpXG5cbmFuZCBfbWVuaGlyX2dvdG9fY29tbWFuZCA6IF9tZW5oaXJfZW52IC0+ICd0dHZfdGFpbCAtPiBfbWVuaGlyX3N0YXRlIC0+IChQYXJzZXJfYXN0LmNvbW1hbmQpIC0+ICd0dHZfcmV0dXJuID1cbiAgZnVuIF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX21lbmhpcl9zIF92IC0+XG4gICAgbGV0IF9tZW5oaXJfc3RhY2sgPSAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zLCBfdikgaW5cbiAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgbGV0IF90b2sgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX3Rva2VuIGluXG4gICAgbWF0Y2ggX3RvayB3aXRoXG4gICAgfCBFT0YgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCAoKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgXyksIF8sIChjbWQgOiAoUGFyc2VyX2FzdC5jb21tYW5kKSkpID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgX3YgOiAoUGFyc2VyX2FzdC5hc3QpID0gXG4jIDEwMSBcIklPL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggW2NtZF0gKVxuIyAxMzkwIFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIF9tZW5oaXJfZ290b19hc3QgX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgX3ZcbiAgICB8IEVPTCAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBfbWVuaGlyX2VudiA9IF9tZW5oaXJfZGlzY2FyZCBfbWVuaGlyX2VudiBpblxuICAgICAgICBsZXQgX3RvayA9IF9tZW5oaXJfZW52Ll9tZW5oaXJfdG9rZW4gaW5cbiAgICAgICAgKG1hdGNoIF90b2sgd2l0aFxuICAgICAgICB8IEVPTCAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4xIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU5MlxuICAgICAgICB8IEVPRiB8IElEIF8gfCBMRUZUX0JSQUNFIHwgTlVNQkVSIF8gLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcmVkdWNlMjYgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTkyXG4gICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgICAgICBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yIDwtIHRydWU7XG4gICAgICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlOTIpXG4gICAgfCBfIC0+XG4gICAgICAgIGFzc2VydCAobm90IF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IpO1xuICAgICAgICBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yIDwtIHRydWU7XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIF8pID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIF9tZW5oaXJfc1xuXG5hbmQgX21lbmhpcl9nb3RvX251bWJlciA6IF9tZW5oaXJfZW52IC0+ICd0dHZfdGFpbCAtPiBfbWVuaGlyX3N0YXRlIC0+IChQYXJzZXJfYXN0LnVucHJvY2Vzc2VkX2ludDMyKSAtPiBMZXhpbmcucG9zaXRpb24gLT4gJ3R0dl9yZXR1cm4gPVxuICBmdW4gX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgX3YgX3N0YXJ0cG9zIC0+XG4gICAgbWF0Y2ggX21lbmhpcl9zIHdpdGhcbiAgICB8IE1lbmhpclN0YXRlNTkgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCAoaSA6IChQYXJzZXJfYXN0LnVucHJvY2Vzc2VkX2ludDMyKSkgPSBfdiBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zX2lfID0gX3N0YXJ0cG9zIGluXG4gICAgICAgIGxldCAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF92IDogKFBhcnNlcl9hc3Qub2Zmc2V0KSA9IFxuIyAxMjYgXCJJTy9wYXJzZXIubWx5XCJcbiAgKCBPSW1tZWRpYXRlIChBcm0uc2lnbl9wbHVzLCBpKSApXG4jIDE0MjUgXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAgX21lbmhpcl9nb3RvX29mZnNldCBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyBfdlxuICAgIHwgTWVuaGlyU3RhdGU2MiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IChpIDogKFBhcnNlcl9hc3QudW5wcm9jZXNzZWRfaW50MzIpKSA9IF92IGluXG4gICAgICAgIGxldCBfc3RhcnRwb3NfaV8gPSBfc3RhcnRwb3MgaW5cbiAgICAgICAgbGV0IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MpID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgX3YgOiAoUGFyc2VyX2FzdC5vZmZzZXQpID0gXG4jIDEyNyBcIklPL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBPSW1tZWRpYXRlIChBcm0uc2lnbl9taW51cywgaSkgKVxuIyAxNDM3IFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIF9tZW5oaXJfZ290b19vZmZzZXQgX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgX3ZcbiAgICB8IE1lbmhpclN0YXRlNjcgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCAoaSA6IChQYXJzZXJfYXN0LnVucHJvY2Vzc2VkX2ludDMyKSkgPSBfdiBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zX2lfID0gX3N0YXJ0cG9zIGluXG4gICAgICAgIGxldCAoKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcyksIF8pID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgX3YgOiAoUGFyc2VyX2FzdC5vZmZzZXQpID0gXG4jIDEyNiBcIklPL3BhcnNlci5tbHlcIlxuICAoIE9JbW1lZGlhdGUgKEFybS5zaWduX3BsdXMsIGkpIClcbiMgMTQ0OSBcIklPL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICBfbWVuaGlyX2dvdG9fb2Zmc2V0IF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX21lbmhpcl9zIF92XG4gICAgfCBNZW5oaXJTdGF0ZTY5IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgKGkgOiAoUGFyc2VyX2FzdC51bnByb2Nlc3NlZF9pbnQzMikpID0gX3YgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvc19pXyA9IF9zdGFydHBvcyBpblxuICAgICAgICBsZXQgKChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MpLCBfKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF92IDogKFBhcnNlcl9hc3Qub2Zmc2V0KSA9IFxuIyAxMjcgXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggT0ltbWVkaWF0ZSAoQXJtLnNpZ25fbWludXMsIGkpIClcbiMgMTQ2MSBcIklPL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICBfbWVuaGlyX2dvdG9fb2Zmc2V0IF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX21lbmhpcl9zIF92XG4gICAgfCBNZW5oaXJTdGF0ZTY2IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgKGkgOiAoUGFyc2VyX2FzdC51bnByb2Nlc3NlZF9pbnQzMikpID0gX3YgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvc19pXyA9IF9zdGFydHBvcyBpblxuICAgICAgICBsZXQgKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBfdiA6IChQYXJzZXJfYXN0Lm9mZnNldCkgPSBcbiMgMTI2IFwiSU8vcGFyc2VyLm1seVwiXG4gICggT0ltbWVkaWF0ZSAoQXJtLnNpZ25fcGx1cywgaSkgKVxuIyAxNDczIFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIF9tZW5oaXJfZ290b19vZmZzZXQgX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgX3ZcbiAgICB8IE1lbmhpclN0YXRlNzQgfCBNZW5oaXJTdGF0ZTU4IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgKGkgOiAoUGFyc2VyX2FzdC51bnByb2Nlc3NlZF9pbnQzMikpID0gX3YgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvc19pXyA9IF9zdGFydHBvcyBpblxuICAgICAgICBsZXQgX3YgOiAoUGFyc2VyX2FzdC5vZmZzZXQpID0gXG4jIDEyNiBcIklPL3BhcnNlci5tbHlcIlxuICAoIE9JbW1lZGlhdGUgKEFybS5zaWduX3BsdXMsIGkpIClcbiMgMTQ4NCBcIklPL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICBfbWVuaGlyX2dvdG9fb2Zmc2V0IF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX21lbmhpcl9zIF92XG4gICAgfCBNZW5oaXJTdGF0ZTc5IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgKGkgOiAoUGFyc2VyX2FzdC51bnByb2Nlc3NlZF9pbnQzMikpID0gX3YgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvc19pXyA9IF9zdGFydHBvcyBpblxuICAgICAgICBsZXQgKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBfdiA6IChQYXJzZXJfYXN0LmFyZ3MpID0gXG4jIDExNCBcIklPL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIEltbWVkaWF0ZSBpIClcbiMgMTQ5NiBcIklPL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICBfbWVuaGlyX2dvdG9fYXJnIF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX21lbmhpcl9zIF92XG4gICAgfCBNZW5oaXJTdGF0ZTg3IHwgTWVuaGlyU3RhdGU1MyAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IChpIDogKFBhcnNlcl9hc3QudW5wcm9jZXNzZWRfaW50MzIpKSA9IF92IGluXG4gICAgICAgIGxldCBfc3RhcnRwb3NfaV8gPSBfc3RhcnRwb3MgaW5cbiAgICAgICAgbGV0IF92IDogKFBhcnNlcl9hc3QuYXJncykgPSBcbiMgMTE0IFwiSU8vcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggSW1tZWRpYXRlIGkgKVxuIyAxNTA3IFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIF9tZW5oaXJfZ290b19hcmcgX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgX3ZcbiAgICB8IE1lbmhpclN0YXRlMyAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IChuYiA6IChQYXJzZXJfYXN0LnVucHJvY2Vzc2VkX2ludDMyKSkgPSBfdiBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zX25iXyA9IF9zdGFydHBvcyBpblxuICAgICAgICBsZXQgX3YgOiAoUGFyc2VyX2FzdC5jb21tYW5kKSA9IGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfbmJfIGluXG4gICAgICAgIFxuIyAxMDkgXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAoIEJJTiAoX3N0YXJ0cG9zLCBuYikgKVxuIyAxNTE5IFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIF9tZW5oaXJfZ290b19jb21tYW5kIF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX21lbmhpcl9zIF92XG4gICAgfCBfIC0+XG4gICAgICAgIF9tZW5oaXJfZmFpbCAoKVxuXG5hbmQgX21lbmhpcl9ydW41OSA6IF9tZW5oaXJfZW52IC0+ICd0dHZfdGFpbCAtPiBfbWVuaGlyX3N0YXRlIC0+ICd0dHZfcmV0dXJuID1cbiAgZnVuIF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX21lbmhpcl9zIC0+XG4gICAgbGV0IF9tZW5oaXJfc3RhY2sgPSAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zKSBpblxuICAgIGxldCBfbWVuaGlyX2VudiA9IF9tZW5oaXJfZGlzY2FyZCBfbWVuaGlyX2VudiBpblxuICAgIGxldCBfdG9rID0gX21lbmhpcl9lbnYuX21lbmhpcl90b2tlbiBpblxuICAgIG1hdGNoIF90b2sgd2l0aFxuICAgIHwgSUQgX3YgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgX21lbmhpcl9zID0gTWVuaGlyU3RhdGU1OSBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wIGluXG4gICAgICAgIGxldCBfbWVuaGlyX2VudiA9IF9tZW5oaXJfZGlzY2FyZCBfbWVuaGlyX2VudiBpblxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCAoaWQgOiAoXG4jIDEwIFwiSU8vcGFyc2VyLm1seVwiXG4gICAgICAgKHN0cmluZylcbiMgMTU0MCBcIklPL3BhcnNlci5tbFwiXG4gICAgICAgICkpID0gX3YgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvc19pZF8gPSBfc3RhcnRwb3MgaW5cbiAgICAgICAgbGV0IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MpID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgX3YgOiAoUGFyc2VyX2FzdC5vZmZzZXQpID0gXG4jIDEyOCBcIklPL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIE9SZWdpc3RlciAoQXJtLnNpZ25fcGx1cywgaWQpIClcbiMgMTU0NyBcIklPL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICBfbWVuaGlyX2dvdG9fb2Zmc2V0IF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX21lbmhpcl9zIF92XG4gICAgfCBMRUZUX0JSQUNFIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuNSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNTkgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgfCBOVU1CRVIgX3YgLT5cbiAgICAgICAgX21lbmhpcl9ydW40IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU1OSBfdiBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BcbiAgICB8IF8gLT5cbiAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgIF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IgPC0gdHJ1ZTtcbiAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTU5XG5cbmFuZCBfbWVuaGlyX3J1bjYyIDogX21lbmhpcl9lbnYgLT4gJ3R0dl90YWlsIC0+IF9tZW5oaXJfc3RhdGUgLT4gJ3R0dl9yZXR1cm4gPVxuICBmdW4gX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgLT5cbiAgICBsZXQgX21lbmhpcl9zdGFjayA9IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MpIGluXG4gICAgbGV0IF9tZW5oaXJfZW52ID0gX21lbmhpcl9kaXNjYXJkIF9tZW5oaXJfZW52IGluXG4gICAgbGV0IF90b2sgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX3Rva2VuIGluXG4gICAgbWF0Y2ggX3RvayB3aXRoXG4gICAgfCBJRCBfdiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBfbWVuaGlyX3MgPSBNZW5oaXJTdGF0ZTYyIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3AgaW5cbiAgICAgICAgbGV0IF9tZW5oaXJfZW52ID0gX21lbmhpcl9kaXNjYXJkIF9tZW5oaXJfZW52IGluXG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IChpZCA6IChcbiMgMTAgXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAoc3RyaW5nKVxuIyAxNTc0IFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgKSkgPSBfdiBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zX2lkXyA9IF9zdGFydHBvcyBpblxuICAgICAgICBsZXQgKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBfdiA6IChQYXJzZXJfYXN0Lm9mZnNldCkgPSBcbiMgMTI5IFwiSU8vcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICggT1JlZ2lzdGVyIChBcm0uc2lnbl9taW51cywgaWQpIClcbiMgMTU4MSBcIklPL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICBfbWVuaGlyX2dvdG9fb2Zmc2V0IF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX21lbmhpcl9zIF92XG4gICAgfCBMRUZUX0JSQUNFIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuNSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNjIgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgfCBOVU1CRVIgX3YgLT5cbiAgICAgICAgX21lbmhpcl9ydW40IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU2MiBfdiBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BcbiAgICB8IF8gLT5cbiAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgIF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IgPC0gdHJ1ZTtcbiAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTYyXG5cbmFuZCBfbWVuaGlyX3J1bjY1IDogX21lbmhpcl9lbnYgLT4gJ3R0dl90YWlsIC0+IF9tZW5oaXJfc3RhdGUgLT4gKFxuIyAxMCBcIklPL3BhcnNlci5tbHlcIlxuICAgICAgIChzdHJpbmcpXG4jIDE1OTYgXCJJTy9wYXJzZXIubWxcIlxuKSAtPiBMZXhpbmcucG9zaXRpb24gLT4gJ3R0dl9yZXR1cm4gPVxuICBmdW4gX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgX3YgX3N0YXJ0cG9zIC0+XG4gICAgbGV0IF9tZW5oaXJfZW52ID0gX21lbmhpcl9kaXNjYXJkIF9tZW5oaXJfZW52IGluXG4gICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgIGxldCAoaWQgOiAoXG4jIDEwIFwiSU8vcGFyc2VyLm1seVwiXG4gICAgICAgKHN0cmluZylcbiMgMTYwNCBcIklPL3BhcnNlci5tbFwiXG4gICAgKSkgPSBfdiBpblxuICAgIGxldCBfc3RhcnRwb3NfaWRfID0gX3N0YXJ0cG9zIGluXG4gICAgbGV0IF92IDogKFBhcnNlcl9hc3Qub2Zmc2V0KSA9IFxuIyAxMjggXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBPUmVnaXN0ZXIgKEFybS5zaWduX3BsdXMsIGlkKSApXG4jIDE2MTAgXCJJTy9wYXJzZXIubWxcIlxuICAgICBpblxuICAgIF9tZW5oaXJfZ290b19vZmZzZXQgX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgX3ZcblxuYW5kIF9tZW5oaXJfcnVuNjYgOiBfbWVuaGlyX2VudiAtPiAndHR2X3RhaWwgLT4gX21lbmhpcl9zdGF0ZSAtPiAndHR2X3JldHVybiA9XG4gIGZ1biBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyAtPlxuICAgIGxldCBfbWVuaGlyX3N0YWNrID0gKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcykgaW5cbiAgICBsZXQgX21lbmhpcl9lbnYgPSBfbWVuaGlyX2Rpc2NhcmQgX21lbmhpcl9lbnYgaW5cbiAgICBsZXQgX3RvayA9IF9tZW5oaXJfZW52Ll9tZW5oaXJfdG9rZW4gaW5cbiAgICBtYXRjaCBfdG9rIHdpdGhcbiAgICB8IExFRlRfQlJBQ0UgLT5cbiAgICAgICAgX21lbmhpcl9ydW41IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU2NiBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BcbiAgICB8IE1JTlVTIC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF9tZW5oaXJfcyA9IE1lbmhpclN0YXRlNjYgaW5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zKSBpblxuICAgICAgICBsZXQgX21lbmhpcl9lbnYgPSBfbWVuaGlyX2Rpc2NhcmQgX21lbmhpcl9lbnYgaW5cbiAgICAgICAgbGV0IF90b2sgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX3Rva2VuIGluXG4gICAgICAgIChtYXRjaCBfdG9rIHdpdGhcbiAgICAgICAgfCBMRUZUX0JSQUNFIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjUgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTY5IF9tZW5oaXJfZW52Ll9tZW5oaXJfbGV4YnVmLkxleGluZy5sZXhfc3RhcnRfcFxuICAgICAgICB8IE5VTUJFUiBfdiAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW40IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU2OSBfdiBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BcbiAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgICAgIF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IgPC0gdHJ1ZTtcbiAgICAgICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU2OSlcbiAgICB8IE5VTUJFUiBfdiAtPlxuICAgICAgICBfbWVuaGlyX3J1bjQgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTY2IF92IF9tZW5oaXJfZW52Ll9tZW5oaXJfbGV4YnVmLkxleGluZy5sZXhfc3RhcnRfcFxuICAgIHwgUExVUyAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBfbWVuaGlyX3MgPSBNZW5oaXJTdGF0ZTY2IGluXG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcykgaW5cbiAgICAgICAgbGV0IF9tZW5oaXJfZW52ID0gX21lbmhpcl9kaXNjYXJkIF9tZW5oaXJfZW52IGluXG4gICAgICAgIGxldCBfdG9rID0gX21lbmhpcl9lbnYuX21lbmhpcl90b2tlbiBpblxuICAgICAgICAobWF0Y2ggX3RvayB3aXRoXG4gICAgICAgIHwgTEVGVF9CUkFDRSAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW41IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU2NyBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BcbiAgICAgICAgfCBOVU1CRVIgX3YgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuNCBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNjcgX3YgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgICAgICBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yIDwtIHRydWU7XG4gICAgICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNjcpXG4gICAgfCBfIC0+XG4gICAgICAgIGFzc2VydCAobm90IF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IpO1xuICAgICAgICBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yIDwtIHRydWU7XG4gICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU2NlxuXG5hbmQgX21lbmhpcl9nb3RvX2FyZyA6IF9tZW5oaXJfZW52IC0+ICd0dHZfdGFpbCAtPiBfbWVuaGlyX3N0YXRlIC0+IChQYXJzZXJfYXN0LmFyZ3MpIC0+ICd0dHZfcmV0dXJuID1cbiAgZnVuIF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX21lbmhpcl9zIF92IC0+XG4gICAgbGV0IF9tZW5oaXJfc3RhY2sgPSAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zLCBfdikgaW5cbiAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgbGV0IF90b2sgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX3Rva2VuIGluXG4gICAgbWF0Y2ggX3RvayB3aXRoXG4gICAgfCBDT01NQSAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBfbWVuaGlyX2VudiA9IF9tZW5oaXJfZGlzY2FyZCBfbWVuaGlyX2VudiBpblxuICAgICAgICBsZXQgX3RvayA9IF9tZW5oaXJfZW52Ll9tZW5oaXJfdG9rZW4gaW5cbiAgICAgICAgKG1hdGNoIF90b2sgd2l0aFxuICAgICAgICB8IEhBU0ggLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuNzkgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTg3XG4gICAgICAgIHwgSUQgX3YgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuNzggX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTg3IF92IF9tZW5oaXJfZW52Ll9tZW5oaXJfbGV4YnVmLkxleGluZy5sZXhfc3RhcnRfcFxuICAgICAgICB8IExFRlRfQlJBQ0UgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuNSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlODcgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgICAgIHwgTEVGVF9CUkFDSyAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW41NCBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlODdcbiAgICAgICAgfCBOVU1CRVIgX3YgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuNCBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlODcgX3YgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgICAgICBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yIDwtIHRydWU7XG4gICAgICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlODcpXG4gICAgfCBFT0YgfCBFT0wgfCBJTlRFUlJPR19NQVJLIC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsICh4IDogKFBhcnNlcl9hc3QuYXJncykpKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF92IDogKFBhcnNlcl9hc3QuYXJncyBsaXN0KSA9IFxuIyAyNDEgXCI8c3RhbmRhcmQubWx5PlwiXG4gICAgKCBbIHggXSApXG4jIDE2OTEgXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAgX21lbmhpcl9nb3RvX3NlcGFyYXRlZF9ub25lbXB0eV9saXN0X0NPTU1BX2FyZ18gX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgX3ZcbiAgICB8IF8gLT5cbiAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgIF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IgPC0gdHJ1ZTtcbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgXykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgX21lbmhpcl9zXG5cbmFuZCBfbWVuaGlyX2ZhaWwgOiB1bml0IC0+ICdhID1cbiAgZnVuICgpIC0+XG4gICAgUHJpbnRmLmZwcmludGYgc3RkZXJyIFwiSW50ZXJuYWwgZmFpbHVyZSAtLSBwbGVhc2UgY29udGFjdCB0aGUgcGFyc2VyIGdlbmVyYXRvcidzIGRldmVsb3BlcnMuXFxuJSFcIjtcbiAgICBhc3NlcnQgZmFsc2VcblxuYW5kIF9tZW5oaXJfcnVuNiA6IF9tZW5oaXJfZW52IC0+ICd0dHZfdGFpbCAtPiBfbWVuaGlyX3N0YXRlIC0+ICd0dHZfcmV0dXJuID1cbiAgZnVuIF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX21lbmhpcl9zIC0+XG4gICAgbGV0IF9tZW5oaXJfc3RhY2sgPSAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zKSBpblxuICAgIGxldCBfbWVuaGlyX2VudiA9IF9tZW5oaXJfZGlzY2FyZCBfbWVuaGlyX2VudiBpblxuICAgIGxldCBfdG9rID0gX21lbmhpcl9lbnYuX21lbmhpcl90b2tlbiBpblxuICAgIG1hdGNoIF90b2sgd2l0aFxuICAgIHwgRVhDTEFNX01BUksgLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMiBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNlxuICAgIHwgSUQgX3YgLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNiBfdiBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BcbiAgICB8IExQQVJFTiAtPlxuICAgICAgICBfbWVuaGlyX3J1bjEwIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU2XG4gICAgfCBNSU5VUyAtPlxuICAgICAgICBfbWVuaGlyX3J1bjkgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTZcbiAgICB8IE5PVCAtPlxuICAgICAgICBfbWVuaGlyX3J1bjggX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTZcbiAgICB8IE5VTUJFUiBfdiAtPlxuICAgICAgICBfbWVuaGlyX3J1bjcgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTYgX3YgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgfCBQTFVTIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuNiBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNlxuICAgIHwgXyAtPlxuICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNlxuXG5hbmQgX21lbmhpcl9ydW43IDogX21lbmhpcl9lbnYgLT4gJ3R0dl90YWlsIC0+IF9tZW5oaXJfc3RhdGUgLT4gKFxuIyA4IFwiSU8vcGFyc2VyLm1seVwiXG4gICAgICAgKGludDMyKVxuIyAxNzM0IFwiSU8vcGFyc2VyLm1sXCJcbikgLT4gTGV4aW5nLnBvc2l0aW9uIC0+ICd0dHZfcmV0dXJuID1cbiAgZnVuIF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX21lbmhpcl9zIF92IF9zdGFydHBvcyAtPlxuICAgIGxldCBfbWVuaGlyX2VudiA9IF9tZW5oaXJfZGlzY2FyZCBfbWVuaGlyX2VudiBpblxuICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICBsZXQgKGkgOiAoXG4jIDggXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAoaW50MzIpXG4jIDE3NDIgXCJJTy9wYXJzZXIubWxcIlxuICAgICkpID0gX3YgaW5cbiAgICBsZXQgX3N0YXJ0cG9zX2lfID0gX3N0YXJ0cG9zIGluXG4gICAgbGV0IF92IDogKFByZXByb2Nlc3MubWV0YV9leHByKSA9IFxuIyA2MCBcIklPL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgKCBNQ29uc3QgaSApXG4jIDE3NDggXCJJTy9wYXJzZXIubWxcIlxuICAgICBpblxuICAgIF9tZW5oaXJfZ290b19tZXRhX2V4cHIgX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgX3ZcblxuYW5kIF9tZW5oaXJfcnVuOCA6IF9tZW5oaXJfZW52IC0+ICd0dHZfdGFpbCAtPiBfbWVuaGlyX3N0YXRlIC0+ICd0dHZfcmV0dXJuID1cbiAgZnVuIF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX21lbmhpcl9zIC0+XG4gICAgbGV0IF9tZW5oaXJfc3RhY2sgPSAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zKSBpblxuICAgIGxldCBfbWVuaGlyX2VudiA9IF9tZW5oaXJfZGlzY2FyZCBfbWVuaGlyX2VudiBpblxuICAgIGxldCBfdG9rID0gX21lbmhpcl9lbnYuX21lbmhpcl90b2tlbiBpblxuICAgIG1hdGNoIF90b2sgd2l0aFxuICAgIHwgRVhDTEFNX01BUksgLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMiBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlOFxuICAgIHwgSUQgX3YgLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlOCBfdiBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BcbiAgICB8IExQQVJFTiAtPlxuICAgICAgICBfbWVuaGlyX3J1bjEwIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU4XG4gICAgfCBNSU5VUyAtPlxuICAgICAgICBfbWVuaGlyX3J1bjkgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZThcbiAgICB8IE5PVCAtPlxuICAgICAgICBfbWVuaGlyX3J1bjggX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZThcbiAgICB8IE5VTUJFUiBfdiAtPlxuICAgICAgICBfbWVuaGlyX3J1bjcgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTggX3YgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgfCBQTFVTIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuNiBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlOFxuICAgIHwgXyAtPlxuICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlOFxuXG5hbmQgX21lbmhpcl9ydW45IDogX21lbmhpcl9lbnYgLT4gJ3R0dl90YWlsIC0+IF9tZW5oaXJfc3RhdGUgLT4gJ3R0dl9yZXR1cm4gPVxuICBmdW4gX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgLT5cbiAgICBsZXQgX21lbmhpcl9zdGFjayA9IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MpIGluXG4gICAgbGV0IF9tZW5oaXJfZW52ID0gX21lbmhpcl9kaXNjYXJkIF9tZW5oaXJfZW52IGluXG4gICAgbGV0IF90b2sgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX3Rva2VuIGluXG4gICAgbWF0Y2ggX3RvayB3aXRoXG4gICAgfCBFWENMQU1fTUFSSyAtPlxuICAgICAgICBfbWVuaGlyX3J1bjEyIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU5XG4gICAgfCBJRCBfdiAtPlxuICAgICAgICBfbWVuaGlyX3J1bjExIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU5IF92IF9tZW5oaXJfZW52Ll9tZW5oaXJfbGV4YnVmLkxleGluZy5sZXhfc3RhcnRfcFxuICAgIHwgTFBBUkVOIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuMTAgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTlcbiAgICB8IE1JTlVTIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuOSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlOVxuICAgIHwgTk9UIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuOCBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlOVxuICAgIHwgTlVNQkVSIF92IC0+XG4gICAgICAgIF9tZW5oaXJfcnVuNyBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlOSBfdiBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BcbiAgICB8IFBMVVMgLT5cbiAgICAgICAgX21lbmhpcl9ydW42IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU5XG4gICAgfCBfIC0+XG4gICAgICAgIGFzc2VydCAobm90IF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IpO1xuICAgICAgICBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yIDwtIHRydWU7XG4gICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU5XG5cbmFuZCBfbWVuaGlyX3J1bjEwIDogX21lbmhpcl9lbnYgLT4gJ3R0dl90YWlsIC0+IF9tZW5oaXJfc3RhdGUgLT4gJ3R0dl9yZXR1cm4gPVxuICBmdW4gX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgLT5cbiAgICBsZXQgX21lbmhpcl9zdGFjayA9IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MpIGluXG4gICAgbGV0IF9tZW5oaXJfZW52ID0gX21lbmhpcl9kaXNjYXJkIF9tZW5oaXJfZW52IGluXG4gICAgbGV0IF90b2sgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX3Rva2VuIGluXG4gICAgbWF0Y2ggX3RvayB3aXRoXG4gICAgfCBFWENMQU1fTUFSSyAtPlxuICAgICAgICBfbWVuaGlyX3J1bjEyIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUxMFxuICAgIHwgSUQgX3YgLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMTAgX3YgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgfCBMUEFSRU4gLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMCBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMTBcbiAgICB8IE1JTlVTIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuOSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMTBcbiAgICB8IE5PVCAtPlxuICAgICAgICBfbWVuaGlyX3J1bjggX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTEwXG4gICAgfCBOVU1CRVIgX3YgLT5cbiAgICAgICAgX21lbmhpcl9ydW43IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUxMCBfdiBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BcbiAgICB8IFBMVVMgLT5cbiAgICAgICAgX21lbmhpcl9ydW42IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUxMFxuICAgIHwgXyAtPlxuICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMTBcblxuYW5kIF9tZW5oaXJfcnVuMTEgOiBfbWVuaGlyX2VudiAtPiAndHR2X3RhaWwgLT4gX21lbmhpcl9zdGF0ZSAtPiAoXG4jIDEwIFwiSU8vcGFyc2VyLm1seVwiXG4gICAgICAgKHN0cmluZylcbiMgMTgzMCBcIklPL3BhcnNlci5tbFwiXG4pIC0+IExleGluZy5wb3NpdGlvbiAtPiAndHR2X3JldHVybiA9XG4gIGZ1biBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyBfdiBfc3RhcnRwb3MgLT5cbiAgICBsZXQgX21lbmhpcl9lbnYgPSBfbWVuaGlyX2Rpc2NhcmQgX21lbmhpcl9lbnYgaW5cbiAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgbGV0ICh2IDogKFxuIyAxMCBcIklPL3BhcnNlci5tbHlcIlxuICAgICAgIChzdHJpbmcpXG4jIDE4MzggXCJJTy9wYXJzZXIubWxcIlxuICAgICkpID0gX3YgaW5cbiAgICBsZXQgX3N0YXJ0cG9zX3ZfID0gX3N0YXJ0cG9zIGluXG4gICAgbGV0IF92IDogKFByZXByb2Nlc3MubWV0YV9leHByKSA9IFxuIyA2MSBcIklPL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAoIE1WYXIgdiApXG4jIDE4NDQgXCJJTy9wYXJzZXIubWxcIlxuICAgICBpblxuICAgIF9tZW5oaXJfZ290b19tZXRhX2V4cHIgX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgX3ZcblxuYW5kIF9tZW5oaXJfcnVuMTIgOiBfbWVuaGlyX2VudiAtPiAndHR2X3RhaWwgLT4gX21lbmhpcl9zdGF0ZSAtPiAndHR2X3JldHVybiA9XG4gIGZ1biBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyAtPlxuICAgIGxldCBfbWVuaGlyX3N0YWNrID0gKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcykgaW5cbiAgICBsZXQgX21lbmhpcl9lbnYgPSBfbWVuaGlyX2Rpc2NhcmQgX21lbmhpcl9lbnYgaW5cbiAgICBsZXQgX3RvayA9IF9tZW5oaXJfZW52Ll9tZW5oaXJfdG9rZW4gaW5cbiAgICBtYXRjaCBfdG9rIHdpdGhcbiAgICB8IEVYQ0xBTV9NQVJLIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuMTIgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTEyXG4gICAgfCBJRCBfdiAtPlxuICAgICAgICBfbWVuaGlyX3J1bjExIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUxMiBfdiBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BcbiAgICB8IExQQVJFTiAtPlxuICAgICAgICBfbWVuaGlyX3J1bjEwIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUxMlxuICAgIHwgTUlOVVMgLT5cbiAgICAgICAgX21lbmhpcl9ydW45IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUxMlxuICAgIHwgTk9UIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuOCBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMTJcbiAgICB8IE5VTUJFUiBfdiAtPlxuICAgICAgICBfbWVuaGlyX3J1bjcgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTEyIF92IF9tZW5oaXJfZW52Ll9tZW5oaXJfbGV4YnVmLkxleGluZy5sZXhfc3RhcnRfcFxuICAgIHwgUExVUyAtPlxuICAgICAgICBfbWVuaGlyX3J1bjYgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTEyXG4gICAgfCBfIC0+XG4gICAgICAgIGFzc2VydCAobm90IF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IpO1xuICAgICAgICBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yIDwtIHRydWU7XG4gICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUxMlxuXG5hbmQgX21lbmhpcl9nb3RvX2RlZmluaXRpb24gOiBfbWVuaGlyX2VudiAtPiAndHR2X3RhaWwgLT4gKFByZXByb2Nlc3MuZGVmaW5pdGlvbikgLT4gJ3R0dl9yZXR1cm4gPVxuICBmdW4gX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfdiAtPlxuICAgIGxldCBfbWVuaGlyX3N0YWNrID0gKF9tZW5oaXJfc3RhY2ssIF92KSBpblxuICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICBsZXQgX3RvayA9IF9tZW5oaXJfZW52Ll9tZW5oaXJfdG9rZW4gaW5cbiAgICBtYXRjaCBfdG9rIHdpdGhcbiAgICB8IEVPTCAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBfbWVuaGlyX2VudiA9IF9tZW5oaXJfZGlzY2FyZCBfbWVuaGlyX2VudiBpblxuICAgICAgICBsZXQgX3RvayA9IF9tZW5oaXJfZW52Ll9tZW5oaXJfdG9rZW4gaW5cbiAgICAgICAgKG1hdGNoIF90b2sgd2l0aFxuICAgICAgICB8IEVPTCAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4xIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUxMTRcbiAgICAgICAgfCBIRUFERVIgfCBJRCBfIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3JlZHVjZTI2IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUxMTRcbiAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgICAgIF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IgPC0gdHJ1ZTtcbiAgICAgICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUxMTQpXG4gICAgfCBfIC0+XG4gICAgICAgIGFzc2VydCAobm90IF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IpO1xuICAgICAgICBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yIDwtIHRydWU7XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0ICgoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zLCBfKSwgXykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgX21lbmhpcl9zXG5cbmFuZCBfbWVuaGlyX2dvdG9faGVhZGVycyA6IF9tZW5oaXJfZW52IC0+ICd0dHZfdGFpbCAtPiBfbWVuaGlyX3N0YXRlIC0+IChQcmVwcm9jZXNzLmhlYWRlcnMpIC0+ICd0dHZfcmV0dXJuID1cbiAgZnVuIF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX21lbmhpcl9zIF92IC0+XG4gICAgbWF0Y2ggX21lbmhpcl9zIHdpdGhcbiAgICB8IE1lbmhpclN0YXRlMTE0IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgKGRzIDogKFByZXByb2Nlc3MuaGVhZGVycykpID0gX3YgaW5cbiAgICAgICAgbGV0ICgoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zLCBfKSwgKGQgOiAoUHJlcHJvY2Vzcy5kZWZpbml0aW9uKSkpID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgX3YgOiAoUHJlcHJvY2Vzcy5oZWFkZXJzKSA9IFxuIyA5NSBcIklPL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIGQ6OmRzIClcbiMgMTkxMSBcIklPL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICBfbWVuaGlyX2dvdG9faGVhZGVycyBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyBfdlxuICAgIHwgTWVuaGlyU3RhdGU5NiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IChfMSA6IChQcmVwcm9jZXNzLmhlYWRlcnMpKSA9IF92IGluXG4gICAgICAgIE9iai5tYWdpYyBfMVxuICAgIHwgXyAtPlxuICAgICAgICBfbWVuaGlyX2ZhaWwgKClcblxuYW5kIF9tZW5oaXJfZ290b19sb3B0aW9uX3NlcGFyYXRlZF9ub25lbXB0eV9saXN0X0NPTU1BX2FyZ19fIDogX21lbmhpcl9lbnYgLT4gJ3R0dl90YWlsIC0+IF9tZW5oaXJfc3RhdGUgLT4gKFBhcnNlcl9hc3QuYXJncyBsaXN0KSAtPiAndHR2X3JldHVybiA9XG4gIGZ1biBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyBfdiAtPlxuICAgIGxldCBfbWVuaGlyX3N0YWNrID0gKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgX3YpIGluXG4gICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgIGFzc2VydCAobm90IF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IpO1xuICAgIGxldCBfdG9rID0gX21lbmhpcl9lbnYuX21lbmhpcl90b2tlbiBpblxuICAgIG1hdGNoIF90b2sgd2l0aFxuICAgIHwgSU5URVJST0dfTUFSSyAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBfbWVuaGlyX2VudiA9IF9tZW5oaXJfZGlzY2FyZCBfbWVuaGlyX2VudiBpblxuICAgICAgICBsZXQgX3RvayA9IF9tZW5oaXJfZW52Ll9tZW5oaXJfdG9rZW4gaW5cbiAgICAgICAgKG1hdGNoIF90b2sgd2l0aFxuICAgICAgICB8IE5VTUJFUiBfdiAtPlxuICAgICAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9tZW5oaXJfZW52Ll9tZW5oaXJfbGV4YnVmLkxleGluZy5sZXhfc3RhcnRfcCBpblxuICAgICAgICAgICAgbGV0IF9tZW5oaXJfZW52ID0gX21lbmhpcl9kaXNjYXJkIF9tZW5oaXJfZW52IGluXG4gICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBsZXQgKGkgOiAoXG4jIDggXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAoaW50MzIpXG4jIDE5NDIgXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICAgICAgKSkgPSBfdiBpblxuICAgICAgICAgICAgbGV0IF9zdGFydHBvc19pXyA9IF9zdGFydHBvcyBpblxuICAgICAgICAgICAgbGV0ICgoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zLCAoaWQgOiAoXG4jIDEwIFwiSU8vcGFyc2VyLm1seVwiXG4gICAgICAgKHN0cmluZylcbiMgMTk0OCBcIklPL3BhcnNlci5tbFwiXG4gICAgICAgICAgICApKSwgX3N0YXJ0cG9zX2lkXyksIF8sICh4cyA6IChQYXJzZXJfYXN0LmFyZ3MgbGlzdCkpKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgIGxldCBfdiA6IChQYXJzZXJfYXN0LmNvbW1hbmQpID0gbGV0IGFyZ3MgPSBcbiMgMjMyIFwiPHN0YW5kYXJkLm1seT5cIlxuICAgICggeHMgKVxuIyAxOTUzIFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgICAgICBpblxuICAgICAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19pZF8gaW5cbiAgICAgICAgICAgIFxuIyAxMDggXCJJTy9wYXJzZXIubWx5XCJcbiAgKCBBU00gKF9zdGFydHBvcywgaWQsIGFyZ3MsIE9wdGltaXplci5Ud2Vha0ZpeGVkTGVuZ3RoIChVdGlscy51aW50MzJfdG9faW50IGkpKSApXG4jIDE5NTkgXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICAgICAgIGluXG4gICAgICAgICAgICBfbWVuaGlyX2dvdG9fY29tbWFuZCBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyBfdlxuICAgICAgICB8IEVPRiB8IEVPTCAtPlxuICAgICAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgbGV0ICgoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zLCAoaWQgOiAoXG4jIDEwIFwiSU8vcGFyc2VyLm1seVwiXG4gICAgICAgKHN0cmluZylcbiMgMTk2NyBcIklPL3BhcnNlci5tbFwiXG4gICAgICAgICAgICApKSwgX3N0YXJ0cG9zX2lkXyksIF8sICh4cyA6IChQYXJzZXJfYXN0LmFyZ3MgbGlzdCkpKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgIGxldCBfdiA6IChQYXJzZXJfYXN0LmNvbW1hbmQpID0gbGV0IGFyZ3MgPSBcbiMgMjMyIFwiPHN0YW5kYXJkLm1seT5cIlxuICAgICggeHMgKVxuIyAxOTcyIFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgICAgICBpblxuICAgICAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19pZF8gaW5cbiAgICAgICAgICAgIFxuIyAxMDYgXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIEFTTSAoX3N0YXJ0cG9zLCBpZCwgYXJncywgT3B0aW1pemVyLlR3ZWFrTWluTGVuZ3RoKSApXG4jIDE5NzggXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICAgICAgIGluXG4gICAgICAgICAgICBfbWVuaGlyX2dvdG9fY29tbWFuZCBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyBfdlxuICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgIGFzc2VydCAobm90IF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IpO1xuICAgICAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgbGV0IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIF8pID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBfbWVuaGlyX3MpXG4gICAgfCBFT0YgfCBFT0wgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgKChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIChpZCA6IChcbiMgMTAgXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAoc3RyaW5nKVxuIyAxOTkyIFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgKSksIF9zdGFydHBvc19pZF8pLCBfLCAoeHMgOiAoUGFyc2VyX2FzdC5hcmdzIGxpc3QpKSkgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBfdiA6IChQYXJzZXJfYXN0LmNvbW1hbmQpID0gbGV0IGFyZ3MgPSBcbiMgMjMyIFwiPHN0YW5kYXJkLm1seT5cIlxuICAgICggeHMgKVxuIyAxOTk3IFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfc3RhcnRwb3NfaWRfIGluXG4gICAgICAgIFxuIyAxMDUgXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggQVNNIChfc3RhcnRwb3MsIGlkLCBhcmdzLCBPcHRpbWl6ZXIuTm9Ud2Vha2luZykgKVxuIyAyMDAzIFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIF9tZW5oaXJfZ290b19jb21tYW5kIF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX21lbmhpcl9zIF92XG4gICAgfCBfIC0+XG4gICAgICAgIGFzc2VydCAobm90IF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IpO1xuICAgICAgICBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yIDwtIHRydWU7XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIF8pID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIF9tZW5oaXJfc1xuXG5hbmQgX21lbmhpcl9ydW40IDogX21lbmhpcl9lbnYgLT4gJ3R0dl90YWlsIC0+IF9tZW5oaXJfc3RhdGUgLT4gKFxuIyA4IFwiSU8vcGFyc2VyLm1seVwiXG4gICAgICAgKGludDMyKVxuIyAyMDE2IFwiSU8vcGFyc2VyLm1sXCJcbikgLT4gTGV4aW5nLnBvc2l0aW9uIC0+ICd0dHZfcmV0dXJuID1cbiAgZnVuIF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX21lbmhpcl9zIF92IF9zdGFydHBvcyAtPlxuICAgIGxldCBfbWVuaGlyX2VudiA9IF9tZW5oaXJfZGlzY2FyZCBfbWVuaGlyX2VudiBpblxuICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICBsZXQgKGkgOiAoXG4jIDggXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAoaW50MzIpXG4jIDIwMjQgXCJJTy9wYXJzZXIubWxcIlxuICAgICkpID0gX3YgaW5cbiAgICBsZXQgX3N0YXJ0cG9zX2lfID0gX3N0YXJ0cG9zIGluXG4gICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19pXyBpblxuICAgIGxldCBfdiA6IChQYXJzZXJfYXN0LnVucHJvY2Vzc2VkX2ludDMyKSA9IFxuIyAxMzMgXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICggQ29uc3RJbnQzMiBpIClcbiMgMjAzMSBcIklPL3BhcnNlci5tbFwiXG4gICAgIGluXG4gICAgX21lbmhpcl9nb3RvX251bWJlciBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyBfdiBfc3RhcnRwb3NcblxuYW5kIF9tZW5oaXJfcnVuNTQgOiBfbWVuaGlyX2VudiAtPiAndHR2X3RhaWwgLT4gX21lbmhpcl9zdGF0ZSAtPiAndHR2X3JldHVybiA9XG4gIGZ1biBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyAtPlxuICAgIGxldCBfbWVuaGlyX3N0YWNrID0gKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcykgaW5cbiAgICBsZXQgX21lbmhpcl9lbnYgPSBfbWVuaGlyX2Rpc2NhcmQgX21lbmhpcl9lbnYgaW5cbiAgICBsZXQgX3RvayA9IF9tZW5oaXJfZW52Ll9tZW5oaXJfdG9rZW4gaW5cbiAgICBtYXRjaCBfdG9rIHdpdGhcbiAgICB8IElEIF92IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9tZW5oaXJfZW52Ll9tZW5oaXJfbGV4YnVmLkxleGluZy5sZXhfc3RhcnRfcCBpblxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IChfbWVuaGlyX3N0YWNrLCBfdiwgX3N0YXJ0cG9zKSBpblxuICAgICAgICBsZXQgX21lbmhpcl9lbnYgPSBfbWVuaGlyX2Rpc2NhcmQgX21lbmhpcl9lbnYgaW5cbiAgICAgICAgbGV0IF90b2sgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX3Rva2VuIGluXG4gICAgICAgIChtYXRjaCBfdG9rIHdpdGhcbiAgICAgICAgfCBDT01NQSAtPlxuICAgICAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgbGV0IF9tZW5oaXJfZW52ID0gX21lbmhpcl9kaXNjYXJkIF9tZW5oaXJfZW52IGluXG4gICAgICAgICAgICBsZXQgX3RvayA9IF9tZW5oaXJfZW52Ll9tZW5oaXJfdG9rZW4gaW5cbiAgICAgICAgICAgIChtYXRjaCBfdG9rIHdpdGhcbiAgICAgICAgICAgIHwgSEFTSCAtPlxuICAgICAgICAgICAgICAgIF9tZW5oaXJfcnVuNjYgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTc0XG4gICAgICAgICAgICB8IElEIF92IC0+XG4gICAgICAgICAgICAgICAgX21lbmhpcl9ydW42NSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNzQgX3YgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgICAgICAgICB8IExFRlRfQlJBQ0UgLT5cbiAgICAgICAgICAgICAgICBfbWVuaGlyX3J1bjUgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTc0IF9tZW5oaXJfZW52Ll9tZW5oaXJfbGV4YnVmLkxleGluZy5sZXhfc3RhcnRfcFxuICAgICAgICAgICAgfCBNSU5VUyAtPlxuICAgICAgICAgICAgICAgIF9tZW5oaXJfcnVuNjIgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTc0XG4gICAgICAgICAgICB8IE5VTUJFUiBfdiAtPlxuICAgICAgICAgICAgICAgIF9tZW5oaXJfcnVuNCBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNzQgX3YgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgICAgICAgICB8IFBMVVMgLT5cbiAgICAgICAgICAgICAgICBfbWVuaGlyX3J1bjU5IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU3NFxuICAgICAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgICAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICAgICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU3NClcbiAgICAgICAgfCBSSUdIVF9CUkFDSyAtPlxuICAgICAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgbGV0IF9tZW5oaXJfZW52ID0gX21lbmhpcl9kaXNjYXJkIF9tZW5oaXJfZW52IGluXG4gICAgICAgICAgICBsZXQgX3RvayA9IF9tZW5oaXJfZW52Ll9tZW5oaXJfdG9rZW4gaW5cbiAgICAgICAgICAgIChtYXRjaCBfdG9rIHdpdGhcbiAgICAgICAgICAgIHwgQ09NTUEgLT5cbiAgICAgICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICAgICAgbGV0IF9tZW5oaXJfZW52ID0gX21lbmhpcl9kaXNjYXJkIF9tZW5oaXJfZW52IGluXG4gICAgICAgICAgICAgICAgbGV0IF90b2sgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX3Rva2VuIGluXG4gICAgICAgICAgICAgICAgKG1hdGNoIF90b2sgd2l0aFxuICAgICAgICAgICAgICAgIHwgSEFTSCAtPlxuICAgICAgICAgICAgICAgICAgICBfbWVuaGlyX3J1bjY2IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU1OFxuICAgICAgICAgICAgICAgIHwgSUQgX3YgLT5cbiAgICAgICAgICAgICAgICAgICAgX21lbmhpcl9ydW42NSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNTggX3YgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgICAgICAgICAgICAgfCBMRUZUX0JSQUNFIC0+XG4gICAgICAgICAgICAgICAgICAgIF9tZW5oaXJfcnVuNSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNTggX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgICAgICAgICAgICAgfCBNSU5VUyAtPlxuICAgICAgICAgICAgICAgICAgICBfbWVuaGlyX3J1bjYyIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU1OFxuICAgICAgICAgICAgICAgIHwgTlVNQkVSIF92IC0+XG4gICAgICAgICAgICAgICAgICAgIF9tZW5oaXJfcnVuNCBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNTggX3YgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgICAgICAgICAgICAgfCBQTFVTIC0+XG4gICAgICAgICAgICAgICAgICAgIF9tZW5oaXJfcnVuNTkgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTU4XG4gICAgICAgICAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydCAobm90IF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yIDwtIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU1OClcbiAgICAgICAgICAgIHwgRVhDTEFNX01BUksgLT5cbiAgICAgICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICAgICAgbGV0IF9tZW5oaXJfZW52ID0gX21lbmhpcl9kaXNjYXJkIF9tZW5oaXJfZW52IGluXG4gICAgICAgICAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgICAgIGxldCAoKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcyksIChpZCA6IChcbiMgMTAgXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAoc3RyaW5nKVxuIyAyMTAyIFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgICAgICAgICApKSwgX3N0YXJ0cG9zX2lkXykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICAgICAgbGV0IF92IDogKFBhcnNlcl9hc3QuYXJncykgPSBcbiMgMTIwIFwiSU8vcGFyc2VyLm1seVwiXG4gICggT2Zmc2V0IChpZCwgT0ltbWVkaWF0ZSAoQXJtLnNpZ25fcGx1cywgQ29uc3RJbnQzMiBJbnQzMi56ZXJvKSwgQXJtLlByZUluZGV4ZWQpIClcbiMgMjEwNyBcIklPL3BhcnNlci5tbFwiXG4gICAgICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgICAgX21lbmhpcl9nb3RvX2FyZyBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyBfdlxuICAgICAgICAgICAgfCBFT0YgfCBFT0wgfCBJTlRFUlJPR19NQVJLIC0+XG4gICAgICAgICAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgICAgIGxldCAoKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcyksIChpZCA6IChcbiMgMTAgXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAoc3RyaW5nKVxuIyAyMTE1IFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgICAgICAgICApKSwgX3N0YXJ0cG9zX2lkXykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICAgICAgbGV0IF92IDogKFBhcnNlcl9hc3QuYXJncykgPSBcbiMgMTE3IFwiSU8vcGFyc2VyLm1seVwiXG4gICggT2Zmc2V0IChpZCwgT0ltbWVkaWF0ZSAoQXJtLnNpZ25fcGx1cywgQ29uc3RJbnQzMiBJbnQzMi56ZXJvKSwgQXJtLk9mZnNldCkgKVxuIyAyMTIwIFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgICBfbWVuaGlyX2dvdG9fYXJnIF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX21lbmhpcl9zIF92XG4gICAgICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgICAgICAgICBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yIDwtIHRydWU7XG4gICAgICAgICAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgICAgIGxldCAoKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcyksIF8sIF8pID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgX21lbmhpcl9zKVxuICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgIGFzc2VydCAobm90IF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IpO1xuICAgICAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgbGV0ICgoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zKSwgXywgXykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIF9tZW5oaXJfcylcbiAgICB8IF8gLT5cbiAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgIF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IgPC0gdHJ1ZTtcbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgX21lbmhpcl9zXG5cbmFuZCBfbWVuaGlyX3J1bjUgOiBfbWVuaGlyX2VudiAtPiAndHR2X3RhaWwgLT4gX21lbmhpcl9zdGF0ZSAtPiBMZXhpbmcucG9zaXRpb24gLT4gJ3R0dl9yZXR1cm4gPVxuICBmdW4gX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgX3N0YXJ0cG9zIC0+XG4gICAgbGV0IF9tZW5oaXJfc3RhY2sgPSAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zLCBfc3RhcnRwb3MpIGluXG4gICAgbGV0IF9tZW5oaXJfZW52ID0gX21lbmhpcl9kaXNjYXJkIF9tZW5oaXJfZW52IGluXG4gICAgbGV0IF90b2sgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX3Rva2VuIGluXG4gICAgbWF0Y2ggX3RvayB3aXRoXG4gICAgfCBFWENMQU1fTUFSSyAtPlxuICAgICAgICBfbWVuaGlyX3J1bjEyIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU1XG4gICAgfCBJRCBfdiAtPlxuICAgICAgICBfbWVuaGlyX3J1bjExIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU1IF92IF9tZW5oaXJfZW52Ll9tZW5oaXJfbGV4YnVmLkxleGluZy5sZXhfc3RhcnRfcFxuICAgIHwgTFBBUkVOIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuMTAgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTVcbiAgICB8IE1JTlVTIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuOSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNVxuICAgIHwgTk9UIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuOCBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNVxuICAgIHwgTlVNQkVSIF92IC0+XG4gICAgICAgIF9tZW5oaXJfcnVuNyBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNSBfdiBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BcbiAgICB8IFBMVVMgLT5cbiAgICAgICAgX21lbmhpcl9ydW42IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU1XG4gICAgfCBfIC0+XG4gICAgICAgIGFzc2VydCAobm90IF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IpO1xuICAgICAgICBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yIDwtIHRydWU7XG4gICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU1XG5cbmFuZCBfbWVuaGlyX3J1bjc4IDogX21lbmhpcl9lbnYgLT4gJ3R0dl90YWlsIC0+IF9tZW5oaXJfc3RhdGUgLT4gKFxuIyAxMCBcIklPL3BhcnNlci5tbHlcIlxuICAgICAgIChzdHJpbmcpXG4jIDIxNzAgXCJJTy9wYXJzZXIubWxcIlxuKSAtPiBMZXhpbmcucG9zaXRpb24gLT4gJ3R0dl9yZXR1cm4gPVxuICBmdW4gX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgX3YgX3N0YXJ0cG9zIC0+XG4gICAgbGV0IF9tZW5oaXJfZW52ID0gX21lbmhpcl9kaXNjYXJkIF9tZW5oaXJfZW52IGluXG4gICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgIGxldCAoaWQgOiAoXG4jIDEwIFwiSU8vcGFyc2VyLm1seVwiXG4gICAgICAgKHN0cmluZylcbiMgMjE3OCBcIklPL3BhcnNlci5tbFwiXG4gICAgKSkgPSBfdiBpblxuICAgIGxldCBfc3RhcnRwb3NfaWRfID0gX3N0YXJ0cG9zIGluXG4gICAgbGV0IF92IDogKFBhcnNlcl9hc3QuYXJncykgPSBcbiMgMTEzIFwiSU8vcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAoIFJlZ2lzdGVyIGlkIClcbiMgMjE4NCBcIklPL3BhcnNlci5tbFwiXG4gICAgIGluXG4gICAgX21lbmhpcl9nb3RvX2FyZyBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyBfdlxuXG5hbmQgX21lbmhpcl9ydW43OSA6IF9tZW5oaXJfZW52IC0+ICd0dHZfdGFpbCAtPiBfbWVuaGlyX3N0YXRlIC0+ICd0dHZfcmV0dXJuID1cbiAgZnVuIF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX21lbmhpcl9zIC0+XG4gICAgbGV0IF9tZW5oaXJfc3RhY2sgPSAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zKSBpblxuICAgIGxldCBfbWVuaGlyX2VudiA9IF9tZW5oaXJfZGlzY2FyZCBfbWVuaGlyX2VudiBpblxuICAgIGxldCBfdG9rID0gX21lbmhpcl9lbnYuX21lbmhpcl90b2tlbiBpblxuICAgIG1hdGNoIF90b2sgd2l0aFxuICAgIHwgTEVGVF9CUkFDRSAtPlxuICAgICAgICBfbWVuaGlyX3J1bjUgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTc5IF9tZW5oaXJfZW52Ll9tZW5oaXJfbGV4YnVmLkxleGluZy5sZXhfc3RhcnRfcFxuICAgIHwgTlVNQkVSIF92IC0+XG4gICAgICAgIF9tZW5oaXJfcnVuNCBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNzkgX3YgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgfCBfIC0+XG4gICAgICAgIGFzc2VydCAobm90IF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IpO1xuICAgICAgICBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yIDwtIHRydWU7XG4gICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU3OVxuXG5hbmQgX21lbmhpcl9nb3RvX2FzdCA6IF9tZW5oaXJfZW52IC0+ICd0dHZfdGFpbCAtPiBfbWVuaGlyX3N0YXRlIC0+IChQYXJzZXJfYXN0LmFzdCkgLT4gJ3R0dl9yZXR1cm4gPVxuICBmdW4gX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgX3YgLT5cbiAgICBtYXRjaCBfbWVuaGlyX3Mgd2l0aFxuICAgIHwgTWVuaGlyU3RhdGU5MiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IChjbWRzIDogKFBhcnNlcl9hc3QuYXN0KSkgPSBfdiBpblxuICAgICAgICBsZXQgKChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIF8pLCBfLCAoY21kIDogKFBhcnNlcl9hc3QuY29tbWFuZCkpKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF92IDogKFBhcnNlcl9hc3QuYXN0KSA9IFxuIyAxMDAgXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBjbWQ6OmNtZHMgKVxuIyAyMjE0IFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIF9tZW5oaXJfZ290b19hc3QgX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgX3ZcbiAgICB8IE1lbmhpclN0YXRlMCAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IChfMSA6IChQYXJzZXJfYXN0LmFzdCkpID0gX3YgaW5cbiAgICAgICAgT2JqLm1hZ2ljIF8xXG4gICAgfCBfIC0+XG4gICAgICAgIF9tZW5oaXJfZmFpbCAoKVxuXG5hbmQgX21lbmhpcl9nb3RvX2xpc3RfRU9MXyA6IF9tZW5oaXJfZW52IC0+ICd0dHZfdGFpbCAtPiBfbWVuaGlyX3N0YXRlIC0+ICh1bml0IGxpc3QpIC0+ICd0dHZfcmV0dXJuID1cbiAgZnVuIF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX21lbmhpcl9zIF92IC0+XG4gICAgbGV0IF9tZW5oaXJfc3RhY2sgPSAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zLCBfdikgaW5cbiAgICBtYXRjaCBfbWVuaGlyX3Mgd2l0aFxuICAgIHwgTWVuaGlyU3RhdGUxIC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgKChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MpLCBfLCAoeHMgOiAodW5pdCBsaXN0KSkpID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgeCA9ICgpIGluXG4gICAgICAgIGxldCBfdiA6ICh1bml0IGxpc3QpID0gXG4jIDIxMyBcIjxzdGFuZGFyZC5tbHk+XCJcbiAgICAoIHggOjogeHMgKVxuIyAyMjM3IFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIF9tZW5oaXJfZ290b19saXN0X0VPTF8gX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgX3ZcbiAgICB8IE1lbmhpclN0YXRlOTIgfCBNZW5oaXJTdGF0ZTAgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgbGV0IF90b2sgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX3Rva2VuIGluXG4gICAgICAgIChtYXRjaCBfdG9rIHdpdGhcbiAgICAgICAgfCBFT0YgLT5cbiAgICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgIGxldCBfbWVuaGlyX3MgPSBNZW5oaXJTdGF0ZTMgaW5cbiAgICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgIGxldCAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zLCBfKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgIGxldCBfdiA6IChQYXJzZXJfYXN0LmFzdCkgPSBcbiMgOTkgXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICggW10gKVxuIyAyMjUzIFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgICAgICBpblxuICAgICAgICAgICAgX21lbmhpcl9nb3RvX2FzdCBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyBfdlxuICAgICAgICB8IElEIF92IC0+XG4gICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBsZXQgX21lbmhpcl9zID0gTWVuaGlyU3RhdGUzIGluXG4gICAgICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wIGluXG4gICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIF92LCBfc3RhcnRwb3MpIGluXG4gICAgICAgICAgICBsZXQgX21lbmhpcl9lbnYgPSBfbWVuaGlyX2Rpc2NhcmQgX21lbmhpcl9lbnYgaW5cbiAgICAgICAgICAgIGxldCBfdG9rID0gX21lbmhpcl9lbnYuX21lbmhpcl90b2tlbiBpblxuICAgICAgICAgICAgKG1hdGNoIF90b2sgd2l0aFxuICAgICAgICAgICAgfCBIQVNIIC0+XG4gICAgICAgICAgICAgICAgX21lbmhpcl9ydW43OSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNTNcbiAgICAgICAgICAgIHwgSUQgX3YgLT5cbiAgICAgICAgICAgICAgICBfbWVuaGlyX3J1bjc4IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU1MyBfdiBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BcbiAgICAgICAgICAgIHwgTEVGVF9CUkFDRSAtPlxuICAgICAgICAgICAgICAgIF9tZW5oaXJfcnVuNSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNTMgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgICAgICAgICB8IExFRlRfQlJBQ0sgLT5cbiAgICAgICAgICAgICAgICBfbWVuaGlyX3J1bjU0IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU1M1xuICAgICAgICAgICAgfCBOVU1CRVIgX3YgLT5cbiAgICAgICAgICAgICAgICBfbWVuaGlyX3J1bjQgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTUzIF92IF9tZW5oaXJfZW52Ll9tZW5oaXJfbGV4YnVmLkxleGluZy5sZXhfc3RhcnRfcFxuICAgICAgICAgICAgfCBFT0YgfCBFT0wgfCBJTlRFUlJPR19NQVJLIC0+XG4gICAgICAgICAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgICAgIGxldCBfbWVuaGlyX3MgPSBNZW5oaXJTdGF0ZTUzIGluXG4gICAgICAgICAgICAgICAgbGV0IF92IDogKFBhcnNlcl9hc3QuYXJncyBsaXN0KSA9IFxuIyAxNDIgXCI8c3RhbmRhcmQubWx5PlwiXG4gICAgKCBbXSApXG4jIDIyODAgXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgIF9tZW5oaXJfZ290b19sb3B0aW9uX3NlcGFyYXRlZF9ub25lbXB0eV9saXN0X0NPTU1BX2FyZ19fIF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX21lbmhpcl9zIF92XG4gICAgICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgICAgICAgICBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yIDwtIHRydWU7XG4gICAgICAgICAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTUzKVxuICAgICAgICB8IExFRlRfQlJBQ0UgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuNSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMyBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BcbiAgICAgICAgfCBOVU1CRVIgX3YgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuNCBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMyBfdiBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BcbiAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgICAgIF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IgPC0gdHJ1ZTtcbiAgICAgICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUzKVxuICAgIHwgTWVuaGlyU3RhdGUxMTQgfCBNZW5oaXJTdGF0ZTk2IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgIGxldCBfdG9rID0gX21lbmhpcl9lbnYuX21lbmhpcl90b2tlbiBpblxuICAgICAgICAobWF0Y2ggX3RvayB3aXRoXG4gICAgICAgIHwgSEVBREVSIC0+XG4gICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBsZXQgX21lbmhpcl9lbnYgPSBfbWVuaGlyX2Rpc2NhcmQgX21lbmhpcl9lbnYgaW5cbiAgICAgICAgICAgIGxldCBfdG9rID0gX21lbmhpcl9lbnYuX21lbmhpcl90b2tlbiBpblxuICAgICAgICAgICAgKG1hdGNoIF90b2sgd2l0aFxuICAgICAgICAgICAgfCBFT0YgLT5cbiAgICAgICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgICAgIGxldCAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zLCBfKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgICAgICBsZXQgX3YgOiAoUHJlcHJvY2Vzcy5oZWFkZXJzKSA9IFxuIyA5NCBcIklPL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggW10gKVxuIyAyMzEyIFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgICBfbWVuaGlyX2dvdG9faGVhZGVycyBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyBfdlxuICAgICAgICAgICAgfCBFT0wgLT5cbiAgICAgICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgICAgIGxldCAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zLCBfKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgICAgICBsZXQgX3YgOiAoUHJlcHJvY2Vzcy5oZWFkZXJzKSA9IFxuIyA5NCBcIklPL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggW10gKVxuIyAyMzIyIFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgICBfbWVuaGlyX2dvdG9faGVhZGVycyBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyBfdlxuICAgICAgICAgICAgfCBJRCBfdiAtPlxuICAgICAgICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wIGluXG4gICAgICAgICAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSAoX21lbmhpcl9zdGFjaywgX3YsIF9zdGFydHBvcykgaW5cbiAgICAgICAgICAgICAgICBsZXQgX21lbmhpcl9lbnYgPSBfbWVuaGlyX2Rpc2NhcmQgX21lbmhpcl9lbnYgaW5cbiAgICAgICAgICAgICAgICBsZXQgX3RvayA9IF9tZW5oaXJfZW52Ll9tZW5oaXJfdG9rZW4gaW5cbiAgICAgICAgICAgICAgICAobWF0Y2ggX3RvayB3aXRoXG4gICAgICAgICAgICAgICAgfCBFUVVBTCAtPlxuICAgICAgICAgICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICAgICAgICAgIGxldCBfbWVuaGlyX2VudiA9IF9tZW5oaXJfZGlzY2FyZCBfbWVuaGlyX2VudiBpblxuICAgICAgICAgICAgICAgICAgICBsZXQgX3RvayA9IF9tZW5oaXJfZW52Ll9tZW5oaXJfdG9rZW4gaW5cbiAgICAgICAgICAgICAgICAgICAgKG1hdGNoIF90b2sgd2l0aFxuICAgICAgICAgICAgICAgICAgICB8IEJPT0wgX3YgLT5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBfbWVuaGlyX2VudiA9IF9tZW5oaXJfZGlzY2FyZCBfbWVuaGlyX2VudiBpblxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IChiIDogKFxuIyA5IFwiSU8vcGFyc2VyLm1seVwiXG4gICAgICAgKGJvb2wpXG4jIDIzNDQgXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgKSkgPSBfdiBpblxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IChfbWVuaGlyX3N0YWNrLCAoaWQgOiAoXG4jIDEwIFwiSU8vcGFyc2VyLm1seVwiXG4gICAgICAgKHN0cmluZylcbiMgMjM0OSBcIklPL3BhcnNlci5tbFwiXG4gICAgICAgICAgICAgICAgICAgICAgICApKSwgX3N0YXJ0cG9zX2lkXykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgX3YgOiAoUHJlcHJvY2Vzcy5kZWZpbml0aW9uKSA9IFxuIyA4NyBcIklPL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggUGFyYW0gKGlkLCBIQm9vbCBiKSApXG4jIDIzNTQgXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgICAgICAgICAgICBfbWVuaGlyX2dvdG9fZGVmaW5pdGlvbiBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF92XG4gICAgICAgICAgICAgICAgICAgIHwgTlVMTCAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IF9tZW5oaXJfZW52ID0gX21lbmhpcl9kaXNjYXJkIF9tZW5oaXJfZW52IGluXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgKF9tZW5oaXJfc3RhY2ssIChpZCA6IChcbiMgMTAgXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAoc3RyaW5nKVxuIyAyMzY0IFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICkpLCBfc3RhcnRwb3NfaWRfKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBfdiA6IChQcmVwcm9jZXNzLmRlZmluaXRpb24pID0gXG4jIDg4IFwiSU8vcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIFBhcmFtIChpZCwgSE5vbmUpIClcbiMgMjM2OSBcIklPL3BhcnNlci5tbFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgICAgICAgICAgIF9tZW5oaXJfZ290b19kZWZpbml0aW9uIF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX3ZcbiAgICAgICAgICAgICAgICAgICAgfCBOVU1CRVIgX3YgLT5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBfc3RhcnRwb3MgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3AgaW5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBfbWVuaGlyX2VudiA9IF9tZW5oaXJfZGlzY2FyZCBfbWVuaGlyX2VudiBpblxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IChuYiA6IChcbiMgOCBcIklPL3BhcnNlci5tbHlcIlxuICAgICAgIChpbnQzMilcbiMgMjM4MCBcIklPL3BhcnNlci5tbFwiXG4gICAgICAgICAgICAgICAgICAgICAgICApKSA9IF92IGluXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgX3N0YXJ0cG9zX25iXyA9IF9zdGFydHBvcyBpblxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IChfbWVuaGlyX3N0YWNrLCAoaWQgOiAoXG4jIDEwIFwiSU8vcGFyc2VyLm1seVwiXG4gICAgICAgKHN0cmluZylcbiMgMjM4NiBcIklPL3BhcnNlci5tbFwiXG4gICAgICAgICAgICAgICAgICAgICAgICApKSwgX3N0YXJ0cG9zX2lkXykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgX3YgOiAoUHJlcHJvY2Vzcy5kZWZpbml0aW9uKSA9IFxuIyA4NiBcIklPL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggUGFyYW0gKGlkLCBISW50IG5iKSApXG4jIDIzOTEgXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgICAgICAgICAgICBfbWVuaGlyX2dvdG9fZGVmaW5pdGlvbiBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF92XG4gICAgICAgICAgICAgICAgICAgIHwgU1RSSU5HIF92IC0+XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgX21lbmhpcl9lbnYgPSBfbWVuaGlyX2Rpc2NhcmQgX21lbmhpcl9lbnYgaW5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCAoc3RyIDogKFxuIyA3IFwiSU8vcGFyc2VyLm1seVwiXG4gICAgICAgKHN0cmluZylcbiMgMjQwMSBcIklPL3BhcnNlci5tbFwiXG4gICAgICAgICAgICAgICAgICAgICAgICApKSA9IF92IGluXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgKF9tZW5oaXJfc3RhY2ssIChpZCA6IChcbiMgMTAgXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAoc3RyaW5nKVxuIyAyNDA2IFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICkpLCBfc3RhcnRwb3NfaWRfKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBfdiA6IChQcmVwcm9jZXNzLmRlZmluaXRpb24pID0gXG4jIDg1IFwiSU8vcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggUGFyYW0gKGlkLCBIU3RyaW5nIHN0cikgKVxuIyAyNDExIFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgICAgICAgICAgX21lbmhpcl9nb3RvX2RlZmluaXRpb24gX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfdlxuICAgICAgICAgICAgICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydCAobm90IF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgICAgICAgICAgICAgcmFpc2UgX2VSUilcbiAgICAgICAgICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IgPC0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgICAgICAgICByYWlzZSBfZVJSKVxuICAgICAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgICAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgICAgICBsZXQgKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgXykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBfbWVuaGlyX3MpXG4gICAgICAgIHwgSUQgX3YgLT5cbiAgICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgIGxldCBfc3RhcnRwb3MgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3AgaW5cbiAgICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gKF9tZW5oaXJfc3RhY2ssIF92LCBfc3RhcnRwb3MpIGluXG4gICAgICAgICAgICBsZXQgX21lbmhpcl9lbnYgPSBfbWVuaGlyX2Rpc2NhcmQgX21lbmhpcl9lbnYgaW5cbiAgICAgICAgICAgIGxldCBfdG9rID0gX21lbmhpcl9lbnYuX21lbmhpcl90b2tlbiBpblxuICAgICAgICAgICAgKG1hdGNoIF90b2sgd2l0aFxuICAgICAgICAgICAgfCBFUVVBTCAtPlxuICAgICAgICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgICAgICBsZXQgX21lbmhpcl9lbnYgPSBfbWVuaGlyX2Rpc2NhcmQgX21lbmhpcl9lbnYgaW5cbiAgICAgICAgICAgICAgICBsZXQgX3RvayA9IF9tZW5oaXJfZW52Ll9tZW5oaXJfdG9rZW4gaW5cbiAgICAgICAgICAgICAgICAobWF0Y2ggX3RvayB3aXRoXG4gICAgICAgICAgICAgICAgfCBFWENMQU1fTUFSSyAtPlxuICAgICAgICAgICAgICAgICAgICBfbWVuaGlyX3J1bjEyIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUxMDJcbiAgICAgICAgICAgICAgICB8IElEIF92IC0+XG4gICAgICAgICAgICAgICAgICAgIF9tZW5oaXJfcnVuMTEgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTEwMiBfdiBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BcbiAgICAgICAgICAgICAgICB8IExQQVJFTiAtPlxuICAgICAgICAgICAgICAgICAgICBfbWVuaGlyX3J1bjEwIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUxMDJcbiAgICAgICAgICAgICAgICB8IE1JTlVTIC0+XG4gICAgICAgICAgICAgICAgICAgIF9tZW5oaXJfcnVuOSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMTAyXG4gICAgICAgICAgICAgICAgfCBOT1QgLT5cbiAgICAgICAgICAgICAgICAgICAgX21lbmhpcl9ydW44IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUxMDJcbiAgICAgICAgICAgICAgICB8IE5VTUJFUiBfdiAtPlxuICAgICAgICAgICAgICAgICAgICBfbWVuaGlyX3J1bjcgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTEwMiBfdiBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BcbiAgICAgICAgICAgICAgICB8IFBMVVMgLT5cbiAgICAgICAgICAgICAgICAgICAgX21lbmhpcl9ydW42IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUxMDJcbiAgICAgICAgICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IgPC0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTEwMilcbiAgICAgICAgICAgIHwgSU5URVJST0dfTUFSSyAtPlxuICAgICAgICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgICAgICBsZXQgX21lbmhpcl9lbnYgPSBfbWVuaGlyX2Rpc2NhcmQgX21lbmhpcl9lbnYgaW5cbiAgICAgICAgICAgICAgICBsZXQgX3RvayA9IF9tZW5oaXJfZW52Ll9tZW5oaXJfdG9rZW4gaW5cbiAgICAgICAgICAgICAgICAobWF0Y2ggX3RvayB3aXRoXG4gICAgICAgICAgICAgICAgfCBFUVVBTCAtPlxuICAgICAgICAgICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICAgICAgICAgIGxldCBfbWVuaGlyX2VudiA9IF9tZW5oaXJfZGlzY2FyZCBfbWVuaGlyX2VudiBpblxuICAgICAgICAgICAgICAgICAgICBsZXQgX3RvayA9IF9tZW5oaXJfZW52Ll9tZW5oaXJfdG9rZW4gaW5cbiAgICAgICAgICAgICAgICAgICAgKG1hdGNoIF90b2sgd2l0aFxuICAgICAgICAgICAgICAgICAgICB8IEVYQ0xBTV9NQVJLIC0+XG4gICAgICAgICAgICAgICAgICAgICAgICBfbWVuaGlyX3J1bjEyIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUxMDBcbiAgICAgICAgICAgICAgICAgICAgfCBJRCBfdiAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgX21lbmhpcl9ydW4xMSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMTAwIF92IF9tZW5oaXJfZW52Ll9tZW5oaXJfbGV4YnVmLkxleGluZy5sZXhfc3RhcnRfcFxuICAgICAgICAgICAgICAgICAgICB8IExQQVJFTiAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgX21lbmhpcl9ydW4xMCBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMTAwXG4gICAgICAgICAgICAgICAgICAgIHwgTUlOVVMgLT5cbiAgICAgICAgICAgICAgICAgICAgICAgIF9tZW5oaXJfcnVuOSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMTAwXG4gICAgICAgICAgICAgICAgICAgIHwgTk9UIC0+XG4gICAgICAgICAgICAgICAgICAgICAgICBfbWVuaGlyX3J1bjggX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTEwMFxuICAgICAgICAgICAgICAgICAgICB8IE5VTUJFUiBfdiAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgX21lbmhpcl9ydW43IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUxMDAgX3YgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgICAgICAgICAgICAgICAgIHwgUExVUyAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgX21lbmhpcl9ydW42IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUxMDBcbiAgICAgICAgICAgICAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IgPC0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUxMDApXG4gICAgICAgICAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydCAobm90IF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yIDwtIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgICAgICAgICAgcmFpc2UgX2VSUilcbiAgICAgICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgICAgIGFzc2VydCAobm90IF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IpO1xuICAgICAgICAgICAgICAgIF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IgPC0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICAgICAgcmFpc2UgX2VSUilcbiAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgICAgIF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IgPC0gdHJ1ZTtcbiAgICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgIGxldCAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zLCBfKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgX21lbmhpcl9zKVxuICAgIHwgXyAtPlxuICAgICAgICBfbWVuaGlyX2ZhaWwgKClcblxuYW5kIF9tZW5oaXJfZXJyb3JjYXNlIDogX21lbmhpcl9lbnYgLT4gJ3R0dl90YWlsIC0+IF9tZW5oaXJfc3RhdGUgLT4gJ3R0dl9yZXR1cm4gPVxuICBmdW4gX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgLT5cbiAgICBtYXRjaCBfbWVuaGlyX3Mgd2l0aFxuICAgIHwgTWVuaGlyU3RhdGUxMTQgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgKChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIF8pLCBfKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBfbWVuaGlyX3NcbiAgICB8IE1lbmhpclN0YXRlMTAyIC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgcmFpc2UgX2VSUlxuICAgIHwgTWVuaGlyU3RhdGUxMDAgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICByYWlzZSBfZVJSXG4gICAgfCBNZW5oaXJTdGF0ZTk2IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgcmFpc2UgX2VSUlxuICAgIHwgTWVuaGlyU3RhdGU5MiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zLCBfKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBfbWVuaGlyX3NcbiAgICB8IE1lbmhpclN0YXRlODcgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgXykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgX21lbmhpcl9zXG4gICAgfCBNZW5oaXJTdGF0ZTc5IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MpID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIF9tZW5oaXJfc1xuICAgIHwgTWVuaGlyU3RhdGU3NCAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCAoKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcyksIF8sIF8pID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIF9tZW5oaXJfc1xuICAgIHwgTWVuaGlyU3RhdGU2OSAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBfbWVuaGlyX3NcbiAgICB8IE1lbmhpclN0YXRlNjcgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgX21lbmhpcl9zXG4gICAgfCBNZW5oaXJTdGF0ZTY2IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MpID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIF9tZW5oaXJfc1xuICAgIHwgTWVuaGlyU3RhdGU2MiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBfbWVuaGlyX3NcbiAgICB8IE1lbmhpclN0YXRlNTkgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgX21lbmhpcl9zXG4gICAgfCBNZW5oaXJTdGF0ZTU4IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0ICgoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zKSwgXywgXykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgX21lbmhpcl9zXG4gICAgfCBNZW5oaXJTdGF0ZTUzIC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIF8sIF8pID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIF9tZW5oaXJfc1xuICAgIHwgTWVuaGlyU3RhdGU0NiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zLCBfKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBfbWVuaGlyX3NcbiAgICB8IE1lbmhpclN0YXRlNDQgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgXykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgX21lbmhpcl9zXG4gICAgfCBNZW5oaXJTdGF0ZTQyIC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIF8pID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIF9tZW5oaXJfc1xuICAgIHwgTWVuaGlyU3RhdGU0MCAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zLCBfKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBfbWVuaGlyX3NcbiAgICB8IE1lbmhpclN0YXRlMzggLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgXykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgX21lbmhpcl9zXG4gICAgfCBNZW5oaXJTdGF0ZTM1IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIF8pID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIF9tZW5oaXJfc1xuICAgIHwgTWVuaGlyU3RhdGUzMyAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zLCBfKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBfbWVuaGlyX3NcbiAgICB8IE1lbmhpclN0YXRlMzEgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgXykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgX21lbmhpcl9zXG4gICAgfCBNZW5oaXJTdGF0ZTI5IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIF8pID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIF9tZW5oaXJfc1xuICAgIHwgTWVuaGlyU3RhdGUyNyAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zLCBfKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBfbWVuaGlyX3NcbiAgICB8IE1lbmhpclN0YXRlMjUgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgXykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgX21lbmhpcl9zXG4gICAgfCBNZW5oaXJTdGF0ZTIzIC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIF8pID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIF9tZW5oaXJfc1xuICAgIHwgTWVuaGlyU3RhdGUyMSAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zLCBfKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBfbWVuaGlyX3NcbiAgICB8IE1lbmhpclN0YXRlMTkgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgXykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgX21lbmhpcl9zXG4gICAgfCBNZW5oaXJTdGF0ZTE3IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIF8pID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIF9tZW5oaXJfc1xuICAgIHwgTWVuaGlyU3RhdGUxNSAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zLCBfKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBfbWVuaGlyX3NcbiAgICB8IE1lbmhpclN0YXRlMTIgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgX21lbmhpcl9zXG4gICAgfCBNZW5oaXJTdGF0ZTEwIC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MpID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIF9tZW5oaXJfc1xuICAgIHwgTWVuaGlyU3RhdGU5IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MpID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIF9tZW5oaXJfc1xuICAgIHwgTWVuaGlyU3RhdGU4IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MpID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIF9tZW5oaXJfc1xuICAgIHwgTWVuaGlyU3RhdGU2IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MpID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIF9tZW5oaXJfc1xuICAgIHwgTWVuaGlyU3RhdGU1IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIF8pID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIF9tZW5oaXJfc1xuICAgIHwgTWVuaGlyU3RhdGUzIC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIF8pID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIF9tZW5oaXJfc1xuICAgIHwgTWVuaGlyU3RhdGUxIC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MpID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIF9tZW5oaXJfc1xuICAgIHwgTWVuaGlyU3RhdGUwIC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgcmFpc2UgX2VSUlxuXG5hbmQgX21lbmhpcl9yZWR1Y2UyNiA6IF9tZW5oaXJfZW52IC0+ICd0dHZfdGFpbCAtPiBfbWVuaGlyX3N0YXRlIC0+ICd0dHZfcmV0dXJuID1cbiAgZnVuIF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX21lbmhpcl9zIC0+XG4gICAgbGV0IF92IDogKHVuaXQgbGlzdCkgPSBcbiMgMjExIFwiPHN0YW5kYXJkLm1seT5cIlxuICAgICggW10gKVxuIyAyNjcyIFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgaW5cbiAgICBfbWVuaGlyX2dvdG9fbGlzdF9FT0xfIF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX21lbmhpcl9zIF92XG5cbmFuZCBfbWVuaGlyX3J1bjEgOiBfbWVuaGlyX2VudiAtPiAndHR2X3RhaWwgLT4gX21lbmhpcl9zdGF0ZSAtPiAndHR2X3JldHVybiA9XG4gIGZ1biBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyAtPlxuICAgIGxldCBfbWVuaGlyX3N0YWNrID0gKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcykgaW5cbiAgICBsZXQgX21lbmhpcl9lbnYgPSBfbWVuaGlyX2Rpc2NhcmQgX21lbmhpcl9lbnYgaW5cbiAgICBsZXQgX3RvayA9IF9tZW5oaXJfZW52Ll9tZW5oaXJfdG9rZW4gaW5cbiAgICBtYXRjaCBfdG9rIHdpdGhcbiAgICB8IEVPTCAtPlxuICAgICAgICBfbWVuaGlyX3J1bjEgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTFcbiAgICB8IEVPRiB8IEhFQURFUiB8IElEIF8gfCBMRUZUX0JSQUNFIHwgTlVNQkVSIF8gLT5cbiAgICAgICAgX21lbmhpcl9yZWR1Y2UyNiBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMVxuICAgIHwgXyAtPlxuICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMVxuXG5hbmQgX21lbmhpcl9kaXNjYXJkIDogX21lbmhpcl9lbnYgLT4gX21lbmhpcl9lbnYgPVxuICBmdW4gX21lbmhpcl9lbnYgLT5cbiAgICBsZXQgbGV4ZXIgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGVyIGluXG4gICAgbGV0IGxleGJ1ZiA9IF9tZW5oaXJfZW52Ll9tZW5oaXJfbGV4YnVmIGluXG4gICAgbGV0IF90b2sgPSBsZXhlciBsZXhidWYgaW5cbiAgICB7XG4gICAgICBfbWVuaGlyX2xleGVyID0gbGV4ZXI7XG4gICAgICBfbWVuaGlyX2xleGJ1ZiA9IGxleGJ1ZjtcbiAgICAgIF9tZW5oaXJfdG9rZW4gPSBfdG9rO1xuICAgICAgX21lbmhpcl9lcnJvciA9IGZhbHNlO1xuICAgIH1cblxuYW5kIGFzdCA6IChMZXhpbmcubGV4YnVmIC0+IHRva2VuKSAtPiBMZXhpbmcubGV4YnVmIC0+IChQYXJzZXJfYXN0LmFzdCkgPVxuICBmdW4gbGV4ZXIgbGV4YnVmIC0+XG4gICAgbGV0IF9tZW5oaXJfZW52ID0ge1xuICAgICAgX21lbmhpcl9sZXhlciA9IGxleGVyO1xuICAgICAgX21lbmhpcl9sZXhidWYgPSBsZXhidWY7XG4gICAgICBfbWVuaGlyX3Rva2VuID0gT2JqLm1hZ2ljICgpO1xuICAgICAgX21lbmhpcl9lcnJvciA9IGZhbHNlO1xuICAgIH0gaW5cbiAgICBPYmoubWFnaWMgKGxldCBfbWVuaGlyX3N0YWNrID0gKCgpLCBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X2N1cnJfcCkgaW5cbiAgICBsZXQgX21lbmhpcl9lbnYgPSBfbWVuaGlyX2Rpc2NhcmQgX21lbmhpcl9lbnYgaW5cbiAgICBsZXQgX3RvayA9IF9tZW5oaXJfZW52Ll9tZW5oaXJfdG9rZW4gaW5cbiAgICBtYXRjaCBfdG9rIHdpdGhcbiAgICB8IEVPTCAtPlxuICAgICAgICBfbWVuaGlyX3J1bjEgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTBcbiAgICB8IEVPRiB8IElEIF8gfCBMRUZUX0JSQUNFIHwgTlVNQkVSIF8gLT5cbiAgICAgICAgX21lbmhpcl9yZWR1Y2UyNiBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMFxuICAgIHwgXyAtPlxuICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMClcblxuYW5kIGhlYWRlcnMgOiAoTGV4aW5nLmxleGJ1ZiAtPiB0b2tlbikgLT4gTGV4aW5nLmxleGJ1ZiAtPiAoUHJlcHJvY2Vzcy5oZWFkZXJzKSA9XG4gIGZ1biBsZXhlciBsZXhidWYgLT5cbiAgICBsZXQgX21lbmhpcl9lbnYgPSB7XG4gICAgICBfbWVuaGlyX2xleGVyID0gbGV4ZXI7XG4gICAgICBfbWVuaGlyX2xleGJ1ZiA9IGxleGJ1ZjtcbiAgICAgIF9tZW5oaXJfdG9rZW4gPSBPYmoubWFnaWMgKCk7XG4gICAgICBfbWVuaGlyX2Vycm9yID0gZmFsc2U7XG4gICAgfSBpblxuICAgIE9iai5tYWdpYyAobGV0IF9tZW5oaXJfc3RhY2sgPSAoKCksIF9tZW5oaXJfZW52Ll9tZW5oaXJfbGV4YnVmLkxleGluZy5sZXhfY3Vycl9wKSBpblxuICAgIGxldCBfbWVuaGlyX2VudiA9IF9tZW5oaXJfZGlzY2FyZCBfbWVuaGlyX2VudiBpblxuICAgIGxldCBfdG9rID0gX21lbmhpcl9lbnYuX21lbmhpcl90b2tlbiBpblxuICAgIG1hdGNoIF90b2sgd2l0aFxuICAgIHwgRU9MIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuMSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlOTZcbiAgICB8IEhFQURFUiB8IElEIF8gLT5cbiAgICAgICAgX21lbmhpcl9yZWR1Y2UyNiBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlOTZcbiAgICB8IF8gLT5cbiAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgIF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IgPC0gdHJ1ZTtcbiAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTk2KVxuXG4jIDI2OSBcIjxzdGFuZGFyZC5tbHk+XCJcbiAgXG5cbiMgMjc0OCBcIklPL3BhcnNlci5tbFwiXG4iLCIleyBvcGVuIFBhcnNlcl9hc3QgJX1cbiV7IG9wZW4gUHJlcHJvY2VzcyAlfVxuXG4ldG9rZW4gSEVBREVSXG4ldG9rZW4gTlVMTFxuJXRva2VuIEVRVUFMXG4ldG9rZW4gPHN0cmluZz4gU1RSSU5HXG4ldG9rZW4gPGludDMyPiBOVU1CRVJcbiV0b2tlbiA8Ym9vbD4gQk9PTFxuJXRva2VuIDxzdHJpbmc+IElEXG4ldG9rZW4gSEFTSFxuJXRva2VuIExFRlRfQlJBQ0tcbiV0b2tlbiBSSUdIVF9CUkFDS1xuJXRva2VuIExFRlRfQlJBQ0VcbiV0b2tlbiBSSUdIVF9CUkFDRVxuJXRva2VuIExQQVJFTlxuJXRva2VuIFJQQVJFTlxuJXRva2VuIExTSElGVFxuJXRva2VuIFJTSElGVFxuJXRva2VuIENPTU1BXG4ldG9rZW4gRVhDTEFNX01BUktcbiV0b2tlbiBJTlRFUlJPR19NQVJLXG4ldG9rZW4gQ09MT05cbiV0b2tlbiBUSU1FU1xuJXRva2VuIERJVlxuJXRva2VuIE1PRFxuJXRva2VuIFBMVVNcbiV0b2tlbiBNSU5VU1xuJXRva2VuIEFORFxuJXRva2VuIE9SXG4ldG9rZW4gWE9SXG4ldG9rZW4gTk9UXG4ldG9rZW4gRVFcbiV0b2tlbiBORVFcbiV0b2tlbiBCT1JcbiV0b2tlbiBCQU5EXG4ldG9rZW4gRU9MXG4ldG9rZW4gRU9GXG5cbiVub25hc3NvYyBBUkdcbiVub25hc3NvYyBDT01NQVxuXG4lcmlnaHQgSU5URVJST0dfTUFSSyBDT0xPTlxuJWxlZnQgQk9SXG4lbGVmdCBCQU5EXG4lbGVmdCBPUlxuJWxlZnQgWE9SXG4lbGVmdCBBTkRcbiVsZWZ0IEVRIE5FUVxuJWxlZnQgTFNISUZUIFJTSElGVFxuJWxlZnQgUExVUyBNSU5VU1xuJWxlZnQgVElNRVMgRElWIE1PRFxuJW5vbmFzc29jIEVYQ0xBTV9NQVJLIE5PVCBVUExVUyBVTUlOVVNcblxuJXN0YXJ0IDxQYXJzZXJfYXN0LmFzdD4gYXN0XG4lc3RhcnQgPFByZXByb2Nlc3MuaGVhZGVycz4gaGVhZGVyc1xuJSVcblxubWV0YV9leHByOlxuICB8IGkgPSBOVU1CRVIgeyBNQ29uc3QgaSB9XG4gIHwgdiA9IElEIHsgTVZhciB2IH1cbiAgfCBMUEFSRU4gZSA9IG1ldGFfZXhwciBSUEFSRU4geyBlIH1cbiAgfCBlMSA9IG1ldGFfZXhwciBQTFVTIGUyID0gbWV0YV9leHByIHsgTUJpbmFyeSAoT0FkZCwgZTEsIGUyKSB9XG4gIHwgZTEgPSBtZXRhX2V4cHIgTUlOVVMgZTIgPSBtZXRhX2V4cHIgeyBNQmluYXJ5IChPU3ViLCBlMSwgZTIpIH1cbiAgfCBlMSA9IG1ldGFfZXhwciBUSU1FUyBlMiA9IG1ldGFfZXhwciB7IE1CaW5hcnkgKE9NdWwsIGUxLCBlMikgfVxuICB8IGUxID0gbWV0YV9leHByIERJViBlMiA9IG1ldGFfZXhwciB7IE1CaW5hcnkgKE9EaXYsIGUxLCBlMikgfVxuICB8IGUxID0gbWV0YV9leHByIE1PRCBlMiA9IG1ldGFfZXhwciB7IE1CaW5hcnkgKE9Nb2QsIGUxLCBlMikgfVxuICB8IGUxID0gbWV0YV9leHByIEFORCBlMiA9IG1ldGFfZXhwciB7IE1CaW5hcnkgKE9BbmQsIGUxLCBlMikgfVxuICB8IGUxID0gbWV0YV9leHByIFhPUiBlMiA9IG1ldGFfZXhwciB7IE1CaW5hcnkgKE9Yb3IsIGUxLCBlMikgfVxuICB8IGUxID0gbWV0YV9leHByIE9SIGUyID0gbWV0YV9leHByIHsgTUJpbmFyeSAoT09yLCBlMSwgZTIpIH1cbiAgfCBlMSA9IG1ldGFfZXhwciBCT1IgZTIgPSBtZXRhX2V4cHIgeyBNQmluYXJ5IChPQk9yLCBlMSwgZTIpIH1cbiAgfCBlMSA9IG1ldGFfZXhwciBCQU5EIGUyID0gbWV0YV9leHByIHsgTUJpbmFyeSAoT0JBbmQsIGUxLCBlMikgfVxuICB8IGUxID0gbWV0YV9leHByIEVRIGUyID0gbWV0YV9leHByIHsgTUJpbmFyeSAoT0VxLCBlMSwgZTIpIH1cbiAgfCBlMSA9IG1ldGFfZXhwciBORVEgZTIgPSBtZXRhX2V4cHIgeyBNQmluYXJ5IChPTmVxLCBlMSwgZTIpIH1cbiAgfCBlMSA9IG1ldGFfZXhwciBMU0hJRlQgZTIgPSBtZXRhX2V4cHIgeyBNQmluYXJ5IChPTFNoaWZ0LCBlMSwgZTIpIH1cbiAgfCBlMSA9IG1ldGFfZXhwciBSU0hJRlQgZTIgPSBtZXRhX2V4cHIgeyBNQmluYXJ5IChPUlNoaWZ0LCBlMSwgZTIpIH1cbiAgfCBQTFVTIGUgPSBtZXRhX2V4cHIgJXByZWMgVVBMVVMgeyBNVW5hcnkgKE9JZCwgZSkgfVxuICB8IE1JTlVTIGUgPSBtZXRhX2V4cHIgJXByZWMgVU1JTlVTIHsgTVVuYXJ5IChPTmVnLCBlKSB9XG4gIHwgTk9UIGUgPSBtZXRhX2V4cHIgeyBNVW5hcnkgKE9Ob3QsIGUpIH1cbiAgfCBFWENMQU1fTUFSSyBlID0gbWV0YV9leHByIHsgTVVuYXJ5IChPQk5vdCwgZSkgfVxuICB8IGUwID0gbWV0YV9leHByIElOVEVSUk9HX01BUksgZTEgPSBtZXRhX2V4cHIgQ09MT04gZTIgPSBtZXRhX2V4cHJcbiAgeyBNQ29uZCAoZTAsIGUxLCBlMikgfVxuXG5kZWZpbml0aW9uOlxuICB8IEhFQURFUiA7IGlkID0gSUQgOyBFUVVBTCA7IHN0ciA9IFNUUklORyB7IFBhcmFtIChpZCwgSFN0cmluZyBzdHIpIH1cbiAgfCBIRUFERVIgOyBpZCA9IElEIDsgRVFVQUwgOyBuYiA9IE5VTUJFUiB7IFBhcmFtIChpZCwgSEludCBuYikgfVxuICB8IEhFQURFUiA7IGlkID0gSUQgOyBFUVVBTCA7IGIgPSBCT09MIHsgUGFyYW0gKGlkLCBIQm9vbCBiKSB9XG4gIHwgSEVBREVSIDsgaWQgPSBJRCA7IEVRVUFMIDsgTlVMTCB7IFBhcmFtIChpZCwgSE5vbmUpIH1cbiAgfCBpZCA9IElEIDsgRVFVQUwgOyBlID0gbWV0YV9leHByIHsgVmFyRGVmIChpZCwgZmFsc2UsIGUpIH1cbiAgfCBpZCA9IElEIDsgSU5URVJST0dfTUFSSyA7IEVRVUFMIDsgZSA9IG1ldGFfZXhwciB7IFZhckRlZiAoaWQsIHRydWUsIGUpIH1cbiAgO1xuXG5oZWFkZXJzOlxuICB8IGxpc3QgKEVPTCkgOyBIRUFERVIgOyBFT0wgfCBsaXN0IChFT0wpIDsgSEVBREVSIDsgRU9GIHsgW10gfVxuICB8IGxpc3QgKEVPTCkgOyBkID0gZGVmaW5pdGlvbiA7IEVPTCA7IGRzID0gaGVhZGVycyB7IGQ6OmRzIH1cbiAgO1xuXG5hc3Q6XG4gIHwgbGlzdCAoRU9MKSA7IEVPRiB7IFtdIH1cbiAgfCBsaXN0IChFT0wpIDsgY21kID0gY29tbWFuZCA7IEVPTCA7IGNtZHMgPSBhc3QgeyBjbWQ6OmNtZHMgfVxuICB8IGxpc3QgKEVPTCkgOyBjbWQgPSBjb21tYW5kIDsgRU9GIHsgW2NtZF0gfVxuICA7XG5cbmNvbW1hbmQ6XG4gIHwgaWQgPSBJRCA7IGFyZ3MgPSBzZXBhcmF0ZWRfbGlzdChDT01NQSwgYXJnKSB7IEFTTSAoJHN0YXJ0cG9zLCBpZCwgYXJncywgT3B0aW1pemVyLk5vVHdlYWtpbmcpIH1cbiAgfCBpZCA9IElEIDsgYXJncyA9IHNlcGFyYXRlZF9saXN0KENPTU1BLCBhcmcpIDsgSU5URVJST0dfTUFSSyB7IEFTTSAoJHN0YXJ0cG9zLCBpZCwgYXJncywgT3B0aW1pemVyLlR3ZWFrTWluTGVuZ3RoKSB9XG4gIHwgaWQgPSBJRCA7IGFyZ3MgPSBzZXBhcmF0ZWRfbGlzdChDT01NQSwgYXJnKSA7IElOVEVSUk9HX01BUksgOyBpID0gTlVNQkVSXG4gIHsgQVNNICgkc3RhcnRwb3MsIGlkLCBhcmdzLCBPcHRpbWl6ZXIuVHdlYWtGaXhlZExlbmd0aCAoVXRpbHMudWludDMyX3RvX2ludCBpKSkgfVxuICB8IG5iID0gbnVtYmVyIHsgQklOICgkc3RhcnRwb3MsIG5iKSB9XG4gIDtcblxuYXJnOlxuICB8IGlkID0gSUQgeyBSZWdpc3RlciBpZCB9XG4gIHwgSEFTSCA7IGkgPSBudW1iZXIgfCBpID0gbnVtYmVyIHsgSW1tZWRpYXRlIGkgfVxuICB8IExFRlRfQlJBQ0sgOyBpZCA9IElEIDsgQ09NTUEgOyBvID0gb2Zmc2V0IDsgUklHSFRfQlJBQ0sgeyBPZmZzZXQgKGlkLCBvLCBBcm0uT2Zmc2V0KSB9XG4gIHwgTEVGVF9CUkFDSyA7IGlkID0gSUQgOyBSSUdIVF9CUkFDSyAlcHJlYyBBUkdcbiAgeyBPZmZzZXQgKGlkLCBPSW1tZWRpYXRlIChBcm0uc2lnbl9wbHVzLCBDb25zdEludDMyIEludDMyLnplcm8pLCBBcm0uT2Zmc2V0KSB9XG4gIHwgTEVGVF9CUkFDSyA7IGlkID0gSUQgOyBDT01NQSA7IG8gPSBvZmZzZXQgOyBSSUdIVF9CUkFDSyA7IEVYQ0xBTV9NQVJLIHsgT2Zmc2V0IChpZCwgbywgQXJtLlByZUluZGV4ZWQpIH1cbiAgfCBMRUZUX0JSQUNLIDsgaWQgPSBJRCA7IFJJR0hUX0JSQUNLIDsgRVhDTEFNX01BUktcbiAgeyBPZmZzZXQgKGlkLCBPSW1tZWRpYXRlIChBcm0uc2lnbl9wbHVzLCBDb25zdEludDMyIEludDMyLnplcm8pLCBBcm0uUHJlSW5kZXhlZCkgfVxuICB8IExFRlRfQlJBQ0sgOyBpZCA9IElEIDsgUklHSFRfQlJBQ0sgOyBDT01NQSA7IG8gPSBvZmZzZXQgeyBPZmZzZXQgKGlkLCBvLCBBcm0uUG9zdEluZGV4ZWQpIH1cbiAgO1xuXG5vZmZzZXQ6XG4gIHwgSEFTSCA7IGkgPSBudW1iZXIgfCBIQVNIIDsgUExVUyA7IGkgPSBudW1iZXIgfCBpID0gbnVtYmVyIHwgUExVUyA7IGkgPSBudW1iZXJcbiAgeyBPSW1tZWRpYXRlIChBcm0uc2lnbl9wbHVzLCBpKSB9XG4gIHwgSEFTSCA7IE1JTlVTIDsgaSA9IG51bWJlciB8IE1JTlVTIDsgaSA9IG51bWJlciB7IE9JbW1lZGlhdGUgKEFybS5zaWduX21pbnVzLCBpKSB9XG4gIHwgaWQgPSBJRCB8IFBMVVMgOyBpZCA9IElEIHsgT1JlZ2lzdGVyIChBcm0uc2lnbl9wbHVzLCBpZCkgfVxuICB8IE1JTlVTIDsgaWQgPSBJRCB7IE9SZWdpc3RlciAoQXJtLnNpZ25fbWludXMsIGlkKSB9XG4gIDtcblxubnVtYmVyOlxuICB8IGkgPSBOVU1CRVIgeyBDb25zdEludDMyIGkgfVxuICB8IExFRlRfQlJBQ0UgOyBlPW1ldGFfZXhwciA7IFJJR0hUX0JSQUNFIHsgTWV0YUV4cHIgZSB9XG4gIDsiLCJ7XG5vcGVuIExleGluZ1xub3BlbiBQYXJzZXJcblxuZXhjZXB0aW9uIFN5bnRheEVycm9yIG9mIHN0cmluZ1xuXG5sZXQgbmV4dF9saW5lIGxleGJ1ZiA9XG4gIGxldCBwb3MgPSBsZXhidWYubGV4X2N1cnJfcCBpblxuICBsZXhidWYubGV4X2N1cnJfcCA8LVxuICAgIHsgcG9zIHdpdGggcG9zX2JvbCA9IGxleGJ1Zi5sZXhfY3Vycl9wb3M7XG4gICAgICAgICAgICAgICBwb3NfbG51bSA9IHBvcy5wb3NfbG51bSArIDFcbiAgICB9XG5cbmxldCBlb2ZfcmVhY2hlZCBsZXhidWYgPVxuICBsZXhidWYubGV4X2VvZl9yZWFjaGVkIDwtIHRydWVcbn1cblxubGV0IGRkaWdpdCA9IFsnMCctJzknXVxubGV0IGhkaWdpdCA9IFsnMCctJzknICdhJy0nZicgJ0EnLSdGJ11cbmxldCBiZGlnaXQgPSBbJzAnLScxJ11cbmxldCBvZGlnaXQgPSBbJzAnLSc3J11cblxubGV0IGRwcmVmaXggPSBcIjB1XCIgfCBcIjBVXCJcbmxldCBocHJlZml4ID0gXCIweFwiIHwgXCIwWFwiXG5sZXQgYnByZWZpeCA9IFwiMGJcIiB8IFwiMEJcIlxubGV0IG9wcmVmaXggPSBcIjBvXCIgfCBcIjBPXCJcblxubGV0IGRudW1iZXIgPSBkcHJlZml4PyBkZGlnaXQrXG5sZXQgaG51bWJlciA9IGhwcmVmaXggaGRpZ2l0K1xubGV0IGJudW1iZXIgPSBicHJlZml4IGJkaWdpdCtcbmxldCBvbnVtYmVyID0gb3ByZWZpeCBvZGlnaXQrXG5cbmxldCBudW1iZXIgPSBkbnVtYmVyIHwgaG51bWJlciB8IGJudW1iZXIgfCBvbnVtYmVyXG5cbmxldCBjb21tZW50ID0gXCJAXCIgfCBcIiUlXCIgfCBcIjtcIiB8IFwiLy9cIlxuXG5sZXQgd2hpdGUgPSBbJyAnICdcXHQnXStcbmxldCBuZXdsaW5lID0gJ1xccicgfCAnXFxuJyB8IFwiXFxyXFxuXCJcbmxldCBpZCA9IFsnYSctJ3onICdBJy0nWicgJ18nXSBbJ2EnLSd6JyAnQSctJ1onICcwJy0nOScgJ18nXSpcblxubGV0IGZpbGVfc2VwYXJhdG9yID0gXCI9PT09PVwiICc9JypcblxucnVsZSByZWFkID0gcGFyc2VcbiAgfCBmaWxlX3NlcGFyYXRvciB7IEVPRiB9XG4gIHwgXCJAQFwiICAgICAgeyBIRUFERVIgfVxuICB8IFwibnVsbFwiICAgIHsgTlVMTCB9XG4gIHwgXCJ0cnVlXCIgICAgeyBCT09MIHRydWUgfVxuICB8IFwiZmFsc2VcIiAgIHsgQk9PTCBmYWxzZSB9XG4gIHwgXCI8PFwiICAgICAgeyBMU0hJRlQgfVxuICB8IFwiPj5cIiAgICAgIHsgUlNISUZUIH1cbiAgfCBcIj09XCIgICAgICB7IEVRIH1cbiAgfCBcIiE9XCIgICAgICB7IE5FUSB9XG4gIHwgXCJ8fFwiICAgICAgeyBCT1IgfVxuICB8IFwiJiZcIiAgICAgIHsgQkFORCB9XG4gIHwgY29tbWVudCAgIHsgcmVhZF9jb21tZW50IGxleGJ1ZiB9XG4gIHwgd2hpdGUgICAgIHsgcmVhZCBsZXhidWYgfVxuICB8ICdcXFxcJyBuZXdsaW5lIHsgbmV4dF9saW5lIGxleGJ1ZiA7IHJlYWQgbGV4YnVmIH1cbiAgfCBuZXdsaW5lICAgeyBuZXh0X2xpbmUgbGV4YnVmIDsgRU9MIH1cbiAgfCBudW1iZXIgICAgeyBOVU1CRVIgKFV0aWxzLnVpbnQzMl9vZl9zdHIgKExleGluZy5sZXhlbWUgbGV4YnVmKSkgfVxuICB8IGlkICAgICAgICB7IElEIChMZXhpbmcubGV4ZW1lIGxleGJ1ZikgfVxuICB8ICdcIicgICAgICAgeyByZWFkX3N0cmluZyAoQnVmZmVyLmNyZWF0ZSAxNykgbGV4YnVmIH1cbiAgfCAnPScgICAgICAgeyBFUVVBTCB9XG4gIHwgJyMnICAgICAgIHsgSEFTSCB9XG4gIHwgJ1snICAgICAgIHsgTEVGVF9CUkFDSyB9XG4gIHwgJ10nICAgICAgIHsgUklHSFRfQlJBQ0sgfVxuICB8ICd7JyAgICAgICB7IExFRlRfQlJBQ0UgfVxuICB8ICd9JyAgICAgICB7IFJJR0hUX0JSQUNFIH1cbiAgfCAnLCcgICAgICAgeyBDT01NQSB9XG4gIHwgJyEnICAgICAgIHsgRVhDTEFNX01BUksgfVxuICB8ICc/JyAgICAgICB7IElOVEVSUk9HX01BUksgfVxuICB8ICc6JyAgICAgICB7IENPTE9OIH1cbiAgfCAnKCcgICAgICAgeyBMUEFSRU4gfVxuICB8ICcpJyAgICAgICB7IFJQQVJFTiB9XG4gIHwgJysnICAgICAgIHsgUExVUyB9XG4gIHwgJy0nICAgICAgIHsgTUlOVVMgfVxuICB8ICcqJyAgICAgICB7IFRJTUVTIH1cbiAgfCAnLycgICAgICAgeyBESVYgfVxuICB8ICclJyAgICAgICB7IE1PRCB9XG4gIHwgJyYnICAgICAgIHsgQU5EIH1cbiAgfCAnfCcgICAgICAgeyBPUiB9XG4gIHwgJ14nICAgICAgIHsgWE9SIH1cbiAgfCAnficgICAgICAgeyBOT1QgfVxuICB8IGVvZiAgICAgICB7IGVvZl9yZWFjaGVkIGxleGJ1ZiA7IEVPRiB9XG4gIHwgXyB7IHJhaXNlIChTeW50YXhFcnJvciAoXCJVbmV4cGVjdGVkIGNoYXI6IFwiIF4gTGV4aW5nLmxleGVtZSBsZXhidWYpKSB9XG5cbmFuZCByZWFkX3N0cmluZyBidWYgPSBwYXJzZVxuICB8ICdcIicgICAgICAgeyBTVFJJTkcgKEJ1ZmZlci5jb250ZW50cyBidWYpIH1cbiAgfCAnXFxcXCcgJy8nICB7IEJ1ZmZlci5hZGRfY2hhciBidWYgJy8nOyByZWFkX3N0cmluZyBidWYgbGV4YnVmIH1cbiAgfCAnXFxcXCcgJ1xcXFwnIHsgQnVmZmVyLmFkZF9jaGFyIGJ1ZiAnXFxcXCc7IHJlYWRfc3RyaW5nIGJ1ZiBsZXhidWYgfVxuICB8ICdcXFxcJyAnYicgIHsgQnVmZmVyLmFkZF9jaGFyIGJ1ZiAnXFxiJzsgcmVhZF9zdHJpbmcgYnVmIGxleGJ1ZiB9XG4gIHwgJ1xcXFwnICdmJyAgeyBCdWZmZXIuYWRkX2NoYXIgYnVmICdcXDAxMic7IHJlYWRfc3RyaW5nIGJ1ZiBsZXhidWYgfVxuICB8ICdcXFxcJyAnbicgIHsgQnVmZmVyLmFkZF9jaGFyIGJ1ZiAnXFxuJzsgcmVhZF9zdHJpbmcgYnVmIGxleGJ1ZiB9XG4gIHwgJ1xcXFwnICdyJyAgeyBCdWZmZXIuYWRkX2NoYXIgYnVmICdcXHInOyByZWFkX3N0cmluZyBidWYgbGV4YnVmIH1cbiAgfCAnXFxcXCcgJ3QnICB7IEJ1ZmZlci5hZGRfY2hhciBidWYgJ1xcdCc7IHJlYWRfc3RyaW5nIGJ1ZiBsZXhidWYgfVxuICB8IFteICdcIicgJ1xcXFwnICdcXHInICdcXG4nXStcbiAgICB7IEJ1ZmZlci5hZGRfc3RyaW5nIGJ1ZiAoTGV4aW5nLmxleGVtZSBsZXhidWYpO1xuICAgICAgcmVhZF9zdHJpbmcgYnVmIGxleGJ1ZlxuICAgIH1cbiAgfCBuZXdsaW5lIHsgcmFpc2UgKFN5bnRheEVycm9yIChcIlN0cmluZyBjYW5ub3QgYmUgbXVsdGlsaW5lXCIpKSB9XG4gIHwgZW9mIHsgcmFpc2UgKFN5bnRheEVycm9yIChcIlN0cmluZyBpcyBub3QgdGVybWluYXRlZFwiKSkgfVxuICB8IF8geyByYWlzZSAoU3ludGF4RXJyb3IgKFwiSWxsZWdhbCBzdHJpbmcgY2hhcmFjdGVyOiBcIiBeIExleGluZy5sZXhlbWUgbGV4YnVmKSkgfVxuXG5hbmQgcmVhZF9jb21tZW50ID0gcGFyc2VcbiAgfCBuZXdsaW5lIHsgbmV4dF9saW5lIGxleGJ1ZiA7IEVPTCB9XG4gIHwgZW9mIHsgZW9mX3JlYWNoZWQgbGV4YnVmIDsgRU9GIH1cbiAgfCBfIHsgcmVhZF9jb21tZW50IGxleGJ1ZiB9Iiwib3BlbiBMZXhlclxub3BlbiBMZXhpbmdcblxuZXhjZXB0aW9uIEludmFsaWRDb250ZW50IG9mIHN0cmluZ1xuXG50eXBlIHBhcnNlZF9jb250ZW50ID1cbiAgUHJlcHJvY2Vzcy5oZWFkZXJzICogUGFyc2VyX2FzdC5hc3RcblxubGV0IHByaW50X3Bvc2l0aW9uIGZtdCBwb3MgPVxuICBGb3JtYXQuZnByaW50ZiBmbXQgXCIlczolZDolZFwiIHBvcy5wb3NfZm5hbWVcbiAgICBwb3MucG9zX2xudW0gKHBvcy5wb3NfY251bSAtIHBvcy5wb3NfYm9sICsgMSlcblxubGV0IHByaW50X2xleGJ1Zl9wb3MgZm10IGxleGJ1ZiA9XG4gIHByaW50X3Bvc2l0aW9uIGZtdCBsZXhidWYubGV4X2N1cnJfcFxuXG5sZXQgcGFyc2Vfd2l0aF9lcnJvciBmIGxleGJ1ZiA9XG4gIHRyeSBmIGxleGJ1ZiB3aXRoXG4gIHwgU3ludGF4RXJyb3IgbXNnIC0+XG4gICAgcmFpc2UgKEludmFsaWRDb250ZW50XG4gICAgICAoRm9ybWF0LmFzcHJpbnRmIFwiJWE6ICVzXFxuXCIgcHJpbnRfbGV4YnVmX3BvcyBsZXhidWYgbXNnKSlcbiAgfCBQYXJzZXIuRXJyb3IgLT5cbiAgICByYWlzZSAoSW52YWxpZENvbnRlbnRcbiAgICAgIChGb3JtYXQuYXNwcmludGYgXCIlYTogcGFyc2VyIGVycm9yXFxuXCIgcHJpbnRfbGV4YnVmX3BvcyBsZXhidWYpKVxuXG5sZXQgZnJvbV9sZXhidWYgfmhlYWRlcnMgbGV4YnVmID1cbiAgbGV0IGhlYWRlcnMgPVxuICAgIGlmIGhlYWRlcnNcbiAgICB0aGVuIHBhcnNlX3dpdGhfZXJyb3IgKFBhcnNlci5oZWFkZXJzIExleGVyLnJlYWQpIGxleGJ1ZlxuICAgIGVsc2UgW11cbiAgaW5cbiAgbGV0IGFzdCA9IHBhcnNlX3dpdGhfZXJyb3IgKFBhcnNlci5hc3QgTGV4ZXIucmVhZCkgbGV4YnVmIGluXG4gIChoZWFkZXJzLCBhc3QpXG5cbmxldCBmcm9tX2ZpbGVuYW1lIH5oZWFkZXJzIGZpbGVuYW1lID1cbiAgbGV0IGNoYW5uZWwgPSBvcGVuX2luIGZpbGVuYW1lIGluXG4gIGxldCBsZXhidWYgPSBMZXhpbmcuZnJvbV9jaGFubmVsIGNoYW5uZWwgaW5cbiAgbGV4YnVmLmxleF9jdXJyX3AgPC0geyBsZXhidWYubGV4X2N1cnJfcCB3aXRoIHBvc19mbmFtZSA9IGZpbGVuYW1lIH07XG4gIGxldCByZXMgPSBmcm9tX2xleGJ1ZiB+aGVhZGVycyBsZXhidWYgaW5cbiAgY2xvc2VfaW4gY2hhbm5lbCA7IHJlc1xuXG5sZXQgZnJvbV9zdHIgfmhlYWRlcnMgc3RyID1cbiAgTGV4aW5nLmZyb21fc3RyaW5nIHN0ciB8PiBmcm9tX2xleGJ1ZiB+aGVhZGVyc1xuXG5sZXQgcGFyc2VkX2FzdF90b19hcm0gfm9wdGltaXplIGVudiBsc3QgPVxuICB0cnlcbiAgICBQYXJzZXJfYXN0LnRvX2FybSBlbnYgbHN0IHw+XG4gICAgaWYgb3B0aW1pemUgdGhlbiBPcHRpbWl6ZXIudHdlYWtfYXJtIGVsc2UgT3B0aW1pemVyLmRvX25vdF90d2Vha19hcm1cbiAgd2l0aCBQYXJzZXJfYXN0LkNvbW1hbmRFcnJvciBwb3MgLT5cbiAgICByYWlzZSAoSW52YWxpZENvbnRlbnRcbiAgICAgIChGb3JtYXQuYXNwcmludGYgXCIlYTogY29tbWFuZCBlcnJvclxcblwiIHByaW50X3Bvc2l0aW9uIHBvcylcbiAgICApXG5cbmxldCBwYXJzZWRfY29udGVudF90b19hcm0gZm10IH5vcHRpbWl6ZSBlbnYgKGhlYWRlcnMsIGxzdCkgPVxuICBsZXQgZW52ID1cbiAgICBQcmVwcm9jZXNzLmVudl9mcm9tX2hlYWRlcnMgZm10IGhlYWRlcnMgfD5cbiAgICBQcmVwcm9jZXNzLmNvbmNhdF9lbnYgZW52IGluXG4gIHBhcnNlZF9hc3RfdG9fYXJtIH5vcHRpbWl6ZSBlbnYgbHN0XG4iLCJcbm1vZHVsZSBTdHJNYXAgPSBNYXAuTWFrZShTdHJpbmcpXG5cbnR5cGUgdCA9IFBhcnNlLnBhcnNlZF9jb250ZW50ICogKFBhcnNlLnBhcnNlZF9jb250ZW50IFN0ck1hcC50KVxuXG5sZXQgcmVjIGFkZF9maWxlcyBsZXhidWYgYWNjID1cbiAgaWYgbGV4YnVmLkxleGluZy5sZXhfZW9mX3JlYWNoZWQgdGhlbiBhY2NcbiAgZWxzZSAoXG4gICAgbGV0IChoZWFkZXJzLCBhcm0pID0gUGFyc2UuZnJvbV9sZXhidWYgfmhlYWRlcnM6dHJ1ZSBsZXhidWYgaW5cbiAgICBsZXQgZm4gPVxuICAgICAgbWF0Y2ggUHJlcHJvY2Vzcy5nZXRfcGFyYW0gaGVhZGVycyBcImZpbGVuYW1lXCIgd2l0aFxuICAgICAgfCBITm9uZSAtPiBmYWlsd2l0aCBcIlBsZWFzZSBzcGVjaWZ5IHRoZSAnZmlsZW5hbWUnIGhlYWRlciBldmVyeXdoZXJlLlwiXG4gICAgICB8IEhTdHJpbmcgZm4gLT4gZm5cbiAgICAgIHwgXyAtPiBmYWlsd2l0aCBcIkludmFsaWQgaGVhZGVycy5cIlxuICAgIGluXG4gICAgU3RyTWFwLmFkZCBmbiAoaGVhZGVycywgYXJtKSBhY2MgfD4gYWRkX2ZpbGVzIGxleGJ1ZlxuICApXG5cbmxldCBwYXJzZSBsZXhidWYgPVxuICBsZXhidWYuTGV4aW5nLmxleF9lb2ZfcmVhY2hlZCA8LSBmYWxzZSA7XG4gIGxldCBtYWluX2ZpbGUgPSBQYXJzZS5mcm9tX2xleGJ1ZiB+aGVhZGVyczp0cnVlIGxleGJ1ZiBpblxuICBsZXQgZmlsZXMgPSBhZGRfZmlsZXMgbGV4YnVmIFN0ck1hcC5lbXB0eSBpblxuICAobWFpbl9maWxlLCBmaWxlcylcblxubGV0IGZyb21fZmlsZW5hbWUgZmlsZW5hbWUgPVxuICBsZXQgY2hhbm5lbCA9IG9wZW5faW4gZmlsZW5hbWUgaW5cbiAgbGV0IGxleGJ1ZiA9IExleGluZy5mcm9tX2NoYW5uZWwgY2hhbm5lbCBpblxuICBsZXhidWYubGV4X2N1cnJfcCA8LSB7IGxleGJ1Zi5sZXhfY3Vycl9wIHdpdGggcG9zX2ZuYW1lID0gZmlsZW5hbWUgfTtcbiAgbGV0IHJlcyA9IHBhcnNlIGxleGJ1ZiBpblxuICBjbG9zZV9pbiBjaGFubmVsIDsgcmVzXG5cbmxldCBmcm9tX3N0ciBzdHIgPVxuICBMZXhpbmcuZnJvbV9zdHJpbmcgc3RyIHw+IHBhcnNlXG5cbmxldCBtYWluX2ZpbGUgKG1mLCBfKSA9IG1mXG5cbmxldCBnZXRfZmlsZSBuYW1lIChfLCBmaWxlcykgPVxuICBTdHJNYXAuZmluZCBuYW1lIGZpbGVzXG4iLCJcbnR5cGUgdCA9ICgoaW50ICogKChpbnQgbGlzdCkgbGlzdCkpIGxpc3QpICogKCgoaW50IGxpc3QpIGxpc3QpIG9wdGlvbilcblxubGV0IGxvYWRfZnJvbV9kaXIgZW52IGRpcm5hbWUgPVxuICB0cnkgKFxuICAgIFV0aWxzLmVudW1lcmF0ZV9maWxlcyBkaXJuYW1lIFwiLnR4dFwiXG4gICAgfD4gTGlzdC5tYXAgKGZ1biB4IC0+XG4gICAgICBsZXQgcGF0aCA9IEZpbGVuYW1lLmNvbmNhdCBkaXJuYW1lIHggaW5cbiAgICAgIGxldCBzdHIgPSBGaWxlbmFtZS5iYXNlbmFtZSB4IHw+IEZpbGVuYW1lLnJlbW92ZV9leHRlbnNpb24gaW5cbiAgICAgIGxldCBpID0gaW50X29mX3N0cmluZyBzdHIgaW5cbiAgICAgIGxldCBhcm0gPSBQYXJzZS5mcm9tX2ZpbGVuYW1lIH5oZWFkZXJzOmZhbHNlIHBhdGggfD5cbiAgICAgICAgUGFyc2UucGFyc2VkX2NvbnRlbnRfdG9fYXJtIFV0aWxzLmR1bW15X2ZtdCB+b3B0aW1pemU6ZmFsc2UgZW52IGluXG4gICAgICBsZXQgY29kZXMgPSBhcm0gfD5cbiAgICAgICAgTGlzdC5tYXAgKGZ1biBhcm0gLT5cbiAgICAgICAgICBBcm0uYXJtX3RvX2JpbmFyeSBhcm0gfD5cbiAgICAgICAgICBMaXN0Lm1hcCBOYW1lLmNvZGVzX2Zvcl9jb21tYW5kIHw+XG4gICAgICAgICAgTmFtZS5wcmVmZXJyZWRfY29kZVxuICAgICAgICApXG4gICAgICBpblxuICAgICAgKGksIGNvZGVzKVxuICAgIClcbiAgICB8PiBMaXN0LnNvcnQgKGZ1biAoaSxfKSAoaixfKSAtPiBjb21wYXJlIGkgailcbiAgICB8PiAoZnVuIHggLT4gKHgsIE5vbmUpKVxuICApXG4gIHdpdGggT3B0aW1pemVyLkNhbm5vdE9wdGltaXplIC0+XG4gICAgZmFpbHdpdGggXCJFeGl0IGNvZGVzIGNhbm5vdCBiZSB0d2Vha2VkIChwbGVhc2UgcmVtb3ZlIGludGVycm9nYXRpb24gbWFya3MpLlwiXG5cbmxldCBsb2FkX2Zyb21fcGFyc2VkX2ZpbGUgZm10IGVudiAoaCwgYXJtKSA9XG4gIGxldCBjb2RlcyA9IChoLCBhcm0pIHw+XG4gICAgUGFyc2UucGFyc2VkX2NvbnRlbnRfdG9fYXJtIGZtdCB+b3B0aW1pemU6dHJ1ZSBlbnYgfD5cbiAgICBMaXN0Lm1hcCAoZnVuIGFybSAtPlxuICAgICAgQXJtLmFybV90b19iaW5hcnkgYXJtIHw+XG4gICAgICBMaXN0Lm1hcCBOYW1lLmNvZGVzX2Zvcl9jb21tYW5kIHw+XG4gICAgICBOYW1lLnByZWZlcnJlZF9jb2RlXG4gICAgKVxuICBpblxuICBtYXRjaCBQcmVwcm9jZXNzLmdldF9wYXJhbSBoIFwic3RhcnRcIiB3aXRoXG4gIHwgSEludCBpIC0+IChbKFV0aWxzLnVpbnQzMl90b19pbnQgaSwgY29kZXMpXSwgTm9uZSlcbiAgfCBITm9uZSAtPiAoW10sIFNvbWUgY29kZXMpXG4gIHwgXyAtPiBmYWlsd2l0aCBcIkV4aXQgY29kZSBoYXMgaW52YWxpZCBoZWFkZXJzLlwiXG5cbmxldCBsb2FkX2Zyb21fZmlsZSBmbXQgZW52IGZpbGVuYW1lID1cbiAgbGV0IChoZWFkZXJzLGFzdCkgPSBQYXJzZS5mcm9tX2ZpbGVuYW1lIH5oZWFkZXJzOnRydWUgZmlsZW5hbWUgaW5cbiAgKGhlYWRlcnMsIGxvYWRfZnJvbV9wYXJzZWRfZmlsZSBmbXQgZW52IChoZWFkZXJzLCBhc3QpKVxuXG5leGNlcHRpb24gTm9FeGl0Q29kZVxuXG5sZXQgZ2V0X3ByZWZlcnJlZCAobHN0LCBkZWZhdWx0KSBpID1cbiAgdHJ5IChcbiAgICBsZXQgcmVjIGF1eCBsc3QgPVxuICAgICAgbWF0Y2ggbHN0IHdpdGhcbiAgICAgIHwgW10gLT4gcmFpc2UgTm9FeGl0Q29kZVxuICAgICAgfCAoaiwgYyk6Ol8gd2hlbiBpIDw9IGogLT4gKGosIGMpXG4gICAgICB8IF86OmxzdCAtPiBhdXggbHN0XG4gICAgaW5cbiAgICBhdXggbHN0XG4gICkgd2l0aCBOb0V4aXRDb2RlIC0+IChcbiAgICBtYXRjaCBkZWZhdWx0IHdpdGhcbiAgICB8IE5vbmUgLT4gcmFpc2UgTm9FeGl0Q29kZVxuICAgIHwgU29tZSBjIC0+IChpLCBjKVxuICApXG5cbiIsIlxubW9kdWxlIFVTdHJpbmcgPSBVdXRmLlN0cmluZ1xubW9kdWxlIFVCdWZmZXIgPSBVdXRmLkJ1ZmZlclxuXG5sZXQgc3RyaW5nX29mX3VjaGFyIHVjaGFyID1cbiAgbGV0IGJ1ZmZlciA9IEJ1ZmZlci5jcmVhdGUgNCBpblxuICBVQnVmZmVyLmFkZF91dGZfOCBidWZmZXIgdWNoYXIgO1xuICBCdWZmZXIuY29udGVudHMgYnVmZmVyXG5cbmxldCBkZWNvbXBvc2VfaW50b191Y2hhcnMgc3RyID1cbiAgVVN0cmluZy5mb2xkX3V0Zl84IChmdW4gYWNjIF8gdWMgLT4gbWF0Y2ggdWMgd2l0aFxuICB8IGBNYWxmb3JtZWQgXyAtPiByYWlzZSBOb3RfZm91bmRcbiAgfCBgVWNoYXIgdWMgLT4gdWM6OmFjYykgW10gc3RyXG4gIHw+IExpc3QucmV2XG5cbnR5cGUgcmVzdWx0ID0gXG4gIHwgQ29udCBvZiAoRm9ybWF0LmZvcm1hdHRlciAtPiBzdHJpbmcgLT4gcmVzdWx0KVxuICB8IE5vQ29udFxuXG5sZXQgcmVjIG1haW4gZm10ID1cbiAgRm9ybWF0LmZwcmludGYgZm10IFwiQXZhaWxhYmxlIGNoYXJhY3RlcnM6IEAuXCIgO1xuICBDaGFyc2V0LmFsbF93cml0YWJsZV9jaGFycyB8PlxuICBMaXN0Lml0ZXIgKEZvcm1hdC5mcHJpbnRmIGZtdCBcIiVzXCIpIDtcbiAgRm9ybWF0LmZwcmludGYgZm10IFwiQC5QbGVhc2UgZW50ZXIgdGV4dCB0byBlbmNvZGU6IEA/XCIgO1xuICBDb250IG1haW5fMVxuXG5hbmQgbWFpbl8xIGZtdCBzdHIgPVxuICBsZXQgcmVjIGF1eDIgbHN0ID1cbiAgICBtYXRjaCBsc3Qgd2l0aFxuICAgIHwgW10gLT4gKClcbiAgICB8IGE6OmI6OmxzdCAtPlxuICAgICAgRm9ybWF0LmZwcmludGYgZm10IFwiJTAyWCUwMlggXCIgYiBhIDtcbiAgICAgIGF1eDIgbHN0XG4gICAgfCBfIC0+IGFzc2VydCBmYWxzZVxuICBpblxuICBsZXQgcmVjIGF1eDQgbHN0ID1cbiAgICBtYXRjaCBsc3Qgd2l0aFxuICAgIHwgW10gLT4gKClcbiAgICB8IGE6OmI6OmM6OmQ6OmxzdCAtPlxuICAgICAgRm9ybWF0LmZwcmludGYgZm10IFwiJTAyWCUwMlglMDJYJTAyWCBcIiBkIGMgYiBhIDtcbiAgICAgIGF1eDQgbHN0XG4gICAgfCBfIC0+IGFzc2VydCBmYWxzZVxuICBpblxuICBiZWdpbiB0cnlcbiAgICBsZXQgZW5jb2RpbmcgPVxuICAgICAgZGVjb21wb3NlX2ludG9fdWNoYXJzIHN0ciB8PlxuICAgICAgTGlzdC5tYXAgc3RyaW5nX29mX3VjaGFyIHw+XG4gICAgICBMaXN0Lm1hcCBDaGFyc2V0LmVuY29kZV93cml0YWJsZV9jaGFyIGluXG4gICAgbGV0IGVuY29kaW5nID0gZW5jb2RpbmdAW05hbWUuZW9mXSBpblxuXG4gICAgRm9ybWF0LmZwcmludGYgZm10IFwiRW5jb2RlZCBkYXRhICgxLWJ5dGUpOiBALlwiIDtcbiAgICBMaXN0Lml0ZXIgKEZvcm1hdC5mcHJpbnRmIGZtdCBcIiUwMlggXCIpIGVuY29kaW5nIDtcblxuICAgIGxldCBuID0gTGlzdC5sZW5ndGggZW5jb2RpbmcgaW5cbiAgICBsZXQgZW5jb2RpbmcgPSBpZiBuIG1vZCAyIDw+IDAgdGhlbiBlbmNvZGluZ0BbMF0gZWxzZSBlbmNvZGluZyBpblxuICAgIEZvcm1hdC5mcHJpbnRmIGZtdCBcIkAuRW5jb2RlZCBkYXRhICgyLWJ5dGVzKTogQC5cIiA7XG4gICAgYXV4MiBlbmNvZGluZyA7XG5cbiAgICBsZXQgbiA9IExpc3QubGVuZ3RoIGVuY29kaW5nIGluXG4gICAgbGV0IGVuY29kaW5nID0gaWYgbiBtb2QgNCA8PiAwIHRoZW4gZW5jb2RpbmdAWzA7MF0gZWxzZSBlbmNvZGluZyBpblxuICAgIEZvcm1hdC5mcHJpbnRmIGZtdCBcIkAuRW5jb2RlZCBkYXRhICg0LWJ5dGVzKTogQC5cIiA7XG4gICAgYXV4NCBlbmNvZGluZyA7XG4gICAgRm9ybWF0LmZwcmludGYgZm10IFwiQC5cIlxuICB3aXRoIE5vdF9mb3VuZCAtPlxuICAgIEZvcm1hdC5mcHJpbnRmIGZtdCBcIkFuIGVycm9yIG9jY3VyZWQuIFBsZWFzZSBjaGVjayB5b3Ugb25seSB1c2UgYXZhaWxhYmxlIGNoYXJhY3RlcnMuXCJcbiAgZW5kIDtcbiAgTm9Db250XG4iLCJvcGVuIEFybVxuXG5sZXQgcHBfaGV4IGZtdCBpID1cbiAgRm9ybWF0LmZwcmludGYgZm10IFwiJTA4bFhcIiBpXG5cbmxldCBjb25kX3RvX3N0ciBjID1cbiAgbWF0Y2ggYyB3aXRoXG4gIHwgRVEgLT4gXCJFUVwiIHwgTkUgLT4gXCJORVwiIHwgQ1MgLT4gXCJDU1wiIHwgSFMgLT4gXCJIU1wiXG4gIHwgQ0MgLT4gXCJDQ1wiIHwgTE8gLT4gXCJMT1wiIHwgTUkgLT4gXCJNSVwiIHwgUEwgLT4gXCJQTFwiIFxuICB8IFZTIC0+IFwiVlNcIiB8IFZDIC0+IFwiVkNcIiB8IEhJIC0+IFwiSElcIiB8IExTIC0+IFwiTFNcIlxuICB8IEdFIC0+IFwiR0VcIiB8IExUIC0+IFwiTFRcIiB8IEdUIC0+IFwiR1RcIiB8IExFIC0+IFwiTEVcIlxuICB8IEFMIC0+IFwiXCJcblxubGV0IGxkcl9zdHJfdHlwZV90b19zdHIgdCA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IEIgLT4gXCJCXCIgfCBTQiAtPiBcIlNCXCIgfCBIIC0+IFwiSFwiIHwgU0ggLT4gXCJTSFwiIHwgVyAtPiBcIlwiXG4gIHwgVCAtPiBcIlRcIiB8IEJUIC0+IFwiQlRcIlxuXG5sZXQgc2lnbl90b19zdHIgc2lnbiA9XG4gIGlmIHNpZ24gPSBzaWduX21pbnVzIHRoZW4gXCItXCIgZWxzZSBcIlwiXG5cbmxldCBzX3RvX3N0ciBzID1cbiAgaWYgcyB0aGVuIFwiU1wiIGVsc2UgXCJcIlxuXG5sZXQgbF90b19zdHIgbCA9XG4gIGlmIGwgdGhlbiBcIkxcIiBlbHNlIFwiXCJcblxubGV0IHByaW50X3JlZ2lzdGVyIGZtdCByID1cbiAgRm9ybWF0LmZwcmludGYgZm10IFwiciVkXCIgclxuXG5sZXQgcHJpbnRfaW1tZWRpYXRlIGZtdCBpID1cbiAgRm9ybWF0LmZwcmludGYgZm10IFwiIyUjbHhcIiBpXG5cbmxldCBwcmludF9vcGVyYW5kIGZtdCBvcCA9XG4gIG1hdGNoIG9wIHdpdGhcbiAgfCBJbW1lZGlhdGUgaSAtPiBwcmludF9pbW1lZGlhdGUgZm10IGlcbiAgfCBSZWdpc3RlciByIC0+IEZvcm1hdC5mcHJpbnRmIGZtdCBcIiVhXCIgcHJpbnRfcmVnaXN0ZXIgclxuICB8IFNjYWxlZFJlZ2lzdGVyIF8gLT4gZmFpbHdpdGggXCJOb3QgaW1wbGVtZW50ZWRcIlxuXG5sZXQgcHJpbnRfaW1tZWRpYXRlX29mZnNldCBmbXQgKHMsIGkpID1cbiAgRm9ybWF0LmZwcmludGYgZm10IFwiIyVzJSNseFwiIChzaWduX3RvX3N0ciBzKSBpXG5cbmxldCBwcmludF9yZWdpc3Rlcl9vZmZzZXQgZm10IChybywgYWRkcl90eXApID1cbiAgbGV0IHN0ciA9IGlmIGFkZHJfdHlwID0gUHJlSW5kZXhlZCB0aGVuIFwiIVwiIGVsc2UgXCJcIiBpblxuICBtYXRjaCBybywgYWRkcl90eXAgd2l0aFxuICB8IE9JbW1lZGlhdGUgKHIscyxpKSwgUG9zdEluZGV4ZWQgLT4gRm9ybWF0LmZwcmludGYgZm10IFwiWyVhXSwgJWFcIlxuICAgIHByaW50X3JlZ2lzdGVyIHIgcHJpbnRfaW1tZWRpYXRlX29mZnNldCAocywgaSlcbiAgfCBPUmVnaXN0ZXIgKHIscyxybyksIFBvc3RJbmRleGVkIC0+IEZvcm1hdC5mcHJpbnRmIGZtdCBcIlslYV0sICVzJWFcIlxuICAgIHByaW50X3JlZ2lzdGVyIHIgKHNpZ25fdG9fc3RyIHMpIHByaW50X3JlZ2lzdGVyIHJvXG4gIHwgT0ltbWVkaWF0ZSAocixzLGkpLCBfIC0+IEZvcm1hdC5mcHJpbnRmIGZtdCBcIlslYSwgJWFdJXNcIlxuICAgIHByaW50X3JlZ2lzdGVyIHIgcHJpbnRfaW1tZWRpYXRlX29mZnNldCAocywgaSkgc3RyXG4gIHwgT1JlZ2lzdGVyIChyLHMscm8pLCBfIC0+IEZvcm1hdC5mcHJpbnRmIGZtdCBcIlslYSwgJXMlYV0lc1wiXG4gICAgcHJpbnRfcmVnaXN0ZXIgciAoc2lnbl90b19zdHIgcykgcHJpbnRfcmVnaXN0ZXIgcm8gc3RyXG4gIHwgT1NjYWxlZFJlZ2lzdGVyIF8sIF8gLT4gZmFpbHdpdGggXCJOb3QgaW1wbGVtZW50ZWRcIlxuXG5sZXQgbWVtX2luc3RyX3RvX3N0ciBpbnN0ciA9XG4gIG1hdGNoIGluc3RyIHdpdGhcbiAgfCBTVFIgLT4gXCJTVFJcIiB8IExEUiAtPiBcIkxEUlwiXG5cbmxldCBtb3ZfaW5zdHJfdG9fc3RyIGluc3RyID1cbiAgbWF0Y2ggaW5zdHIgd2l0aFxuICB8IE1PViAtPiBcIk1PVlwiIHwgTVZOIC0+IFwiTVZOXCJcblxubGV0IGRhdGFfcHJvY19pbnN0cl90b19zdHIgaW5zdHIgPVxuICBtYXRjaCBpbnN0ciB3aXRoXG4gIHwgQURDIC0+IFwiQURDXCIgfCBTQkMgLT4gXCJTQkNcIiB8IEFORCAtPiBcIkFORFwiIHwgQklDIC0+IFwiQklDXCJcbiAgfCBBREQgLT4gXCJBRERcIiB8IFNVQiAtPiBcIlNVQlwiIHwgT1JSIC0+IFwiT1JSXCIgfCBFT1IgLT4gXCJFT1JcIlxuXG5sZXQgcHBfYXJtIGZtdCBhcm0gPVxuICBtYXRjaCBhcm0gd2l0aFxuICB8IEN1c3RvbSBpIC0+IHBwX2hleCBmbXQgaVxuICB8IE1lbSB7aW5zdHI7dHlwO2NvbmQ7cmQ7cm99IC0+IEZvcm1hdC5mcHJpbnRmIGZtdCBcIiVzJXMlcyAlYSwgJWFcIlxuICAgIChtZW1faW5zdHJfdG9fc3RyIGluc3RyKSAoY29uZF90b19zdHIgY29uZCkgKGxkcl9zdHJfdHlwZV90b19zdHIgdHlwKVxuICAgIHByaW50X3JlZ2lzdGVyIHJkIHByaW50X3JlZ2lzdGVyX29mZnNldCByb1xuICB8IE1vdiB7aW5zdHI7cztjb25kO3JkO3JzfSAgIC0+IEZvcm1hdC5mcHJpbnRmIGZtdCBcIiVzJXMlcyAlYSwgJWFcIlxuICAgIChtb3ZfaW5zdHJfdG9fc3RyIGluc3RyKSAoY29uZF90b19zdHIgY29uZCkgKHNfdG9fc3RyIHMpXG4gICAgcHJpbnRfcmVnaXN0ZXIgcmQgcHJpbnRfb3BlcmFuZCByc1xuICB8IERhdGFQcm9jIHtpbnN0cjtzO2NvbmQ7cmQ7cm47b3AyfSAtPiBGb3JtYXQuZnByaW50ZiBmbXQgXCIlcyVzJXMgJWEsICVhLCAlYVwiXG4gICAgKGRhdGFfcHJvY19pbnN0cl90b19zdHIgaW5zdHIpIChjb25kX3RvX3N0ciBjb25kKSAoc190b19zdHIgcylcbiAgICBwcmludF9yZWdpc3RlciByZCBwcmludF9yZWdpc3RlciBybiBwcmludF9vcGVyYW5kIG9wMlxuICB8IEJyYW5jaCB7bDtjb25kO3RhcmdldH0gLT4gRm9ybWF0LmZwcmludGYgZm10IFwiQiVzJXMgJWFcIlxuICAgIChsX3RvX3N0ciBsKSAoY29uZF90b19zdHIgY29uZCkgcHJpbnRfaW1tZWRpYXRlIHRhcmdldFxuICB8IEJyYW5jaFgge2w7Y29uZDtybX0gLT4gRm9ybWF0LmZwcmludGYgZm10IFwiQiVzWCVzICVhXCJcbiAgKGxfdG9fc3RyIGwpIChjb25kX3RvX3N0ciBjb25kKSBwcmludF9yZWdpc3RlciBybVxuIiwib3BlbiBBcm1cblxubGV0IHRyZWF0X2NvbW1hbmQgZm10IGFybSA9XG4gIGxldCBoZXhzID0gYXJtX3RvX2JpbmFyeSBhcm0gaW5cbiAgbGV0IGNvZGVzID0gTGlzdC5tYXAgTmFtZS5jb2Rlc19mb3JfY29tbWFuZCBoZXhzIGluXG4gIGxldCBjb2RlID0gTmFtZS5wcmVmZXJyZWRfY29kZSBjb2RlcyBpblxuICBsZXQgaGV4ID0gTmFtZS5jb21tYW5kX2Zvcl9jb2RlcyBjb2RlIGluXG4gIGxldCBjaGFycyA9IE5hbWUuY29kZXNfdG9fY2hhcnMgY29kZSBpblxuICBGb3JtYXQuZnByaW50ZiBmbXQgXCIlYSBcXHQlYVxcdCVhQC5cIlxuICAgIE5hbWUucHBfY2hhcnMgY2hhcnNcbiAgICBBcm1fcHJpbnRlci5wcF9oZXggaGV4XG4gICAgQXJtX3ByaW50ZXIucHBfYXJtIGFybSA7XG4gIGNvZGVcblxubGV0IG1haW4gZm10IGVudiAoaGVhZGVycyxoZWFkZXJzMikgcGFyc2VkIGV4aXQgPVxuICBsZXQgb25seXJhdyA9XG4gICAgbWF0Y2ggUHJlcHJvY2Vzcy5nZXRfcGFyYW0gaGVhZGVycyBcIm9ubHlyYXdcIiB3aXRoXG4gICAgfCBITm9uZSAtPiBmYWxzZVxuICAgIHwgSEJvb2wgYiAtPiBiXG4gICAgfCBfIC0+IGZhaWx3aXRoIFwiSW52YWxpZCBoZWFkZXJzLlwiXG4gIGluXG4gIGlmIG9ubHlyYXcgJiYgZXhpdCA8PiBOb25lXG4gIHRoZW4gZmFpbHdpdGggXCJPbmx5LXJhdyBtb2RlIGRvZXMgbm90IHN1cHBvcnQgZXhpdCBjb2Rlcy5cIiA7XG4gIGxldCBzdGFydCA9XG4gICAgbWF0Y2ggUHJlcHJvY2Vzcy5nZXRfcGFyYW0gaGVhZGVycyBcInN0YXJ0XCIgd2l0aFxuICAgIHwgSE5vbmUgLT4gMFxuICAgIHwgSEludCBpIC0+IFV0aWxzLnVpbnQzMl90b19pbnQgaVxuICAgIHwgXyAtPiBmYWlsd2l0aCBcIkludmFsaWQgaGVhZGVycy5cIlxuICBpblxuICBsZXQgZmlsbGVycyA9XG4gICAgQXJyYXkuaW5pdCA0IChmdW4gbiAtPlxuICAgICAgbGV0IGhlYWRlcl9uYW1lID0gRm9ybWF0LnNwcmludGYgXCJmaWxsZXIlblwiIChuKzEpIGluXG4gICAgICBtYXRjaCBQcmVwcm9jZXNzLmdldF9wYXJhbSBoZWFkZXJzIGhlYWRlcl9uYW1lIHdpdGhcbiAgICAgIHwgSE5vbmUgLT4gQm94ZXMuZGVmYXVsdF9maWxsZXJzLihuKVxuICAgICAgfCBISW50IGkgLT5cbiAgICAgICAgbGV0IGNvZGVzID0gTmFtZS5jb2Rlc19mb3JfY29tbWFuZCBpIGluXG4gICAgICAgIGlmIExpc3QubnRoIGNvZGVzIG4gPD4gTmFtZS5lb2YgdGhlbiBmYWlsd2l0aCBcIkludmFsaWQgZmlsbGVyLlwiIDtcbiAgICAgICAgY29kZXNcbiAgICAgIHwgXyAtPiBmYWlsd2l0aCBcIkludmFsaWQgaGVhZGVycy5cIlxuICAgIClcbiAgaW5cbiAgbGV0IGZpbGxfbGFzdCA9XG4gICAgbWF0Y2ggUHJlcHJvY2Vzcy5nZXRfcGFyYW0gaGVhZGVycyBcImZpbGxcIixcbiAgICAgICAgICBQcmVwcm9jZXNzLmdldF9wYXJhbSBoZWFkZXJzMiBcImZpbGxcIiB3aXRoXG4gICAgfCBITm9uZSwgSE5vbmUgLT4gdHJ1ZVxuICAgIHwgSE5vbmUsIEhCb29sIGIgfCBIQm9vbCBiLCBITm9uZSAtPiBiXG4gICAgfCBIQm9vbCBiMSwgSEJvb2wgYjIgd2hlbiBiMT1iMiAtPiBiMVxuICAgIHwgSEJvb2wgXywgSEJvb2wgXyAtPlxuICAgICAgZmFpbHdpdGggXCJUaGUgJ2ZpbGwnIGhlYWRlciBoYXMgYSBkaWZmZXJlbnQgdmFsdWUgaW4gdGhlIG1haW4gY29kZSBhbmQgaW4gdGhlIGV4aXQgY29kZS5cIlxuICAgIHwgXyAtPiBmYWlsd2l0aCBcIkludmFsaWQgaGVhZGVycy5cIlxuICBpblxuICBsZXQgcmVzID1cbiAgICBQYXJzZS5wYXJzZWRfYXN0X3RvX2FybSB+b3B0aW1pemU6dHJ1ZSBlbnYgcGFyc2VkIHw+XG4gICAgTGlzdC5tYXAgKHRyZWF0X2NvbW1hbmQgZm10KSBpblxuICBpZiBvbmx5cmF3XG4gIHRoZW4gYmVnaW5cbiAgICBsZXQgc3RhcnQgPSBMaXN0LmluaXQgc3RhcnQgKGZ1biBfIC0+IDApIGluXG4gICAgbGV0IHJlcyA9IExpc3QuY29uY2F0IChzdGFydDo6cmVzKSBpblxuICAgIEZvcm1hdC5mcHJpbnRmIGZtdCBcIkAuUmF3IGRhdGEgKGluIGhleGFkZWNpbWFsKTpALlwiIDtcbiAgICBMaXN0Lml0ZXIgKEZvcm1hdC5mcHJpbnRmIGZtdCBcIiUwMlggQD9cIikgcmVzIDtcbiAgICBGb3JtYXQuZnByaW50ZiBmbXQgXCJALlwiIDsgTm9uZVxuICBlbmQgZWxzZVxuICAgIHRyeVxuICAgICAgbGV0IGJveGVzX2NvZGVzID1cbiAgICAgICAgQm94ZXMuZml0X2NvZGVzX2ludG9fYm94ZXMgfmZpbGxfbGFzdCB+ZmlsbGVycyB+c3RhcnQgfmV4aXQgcmVzIGluXG4gICAgICBGb3JtYXQuZnByaW50ZiBmbXQgXCJALiVhQC5cIiBCb3hlcy5wcF9ib3hlc19uYW1lcyBib3hlc19jb2RlcyA7XG4gICAgICBsZXQgc2l6ZSA9IExpc3QubGVuZ3RoIGJveGVzX2NvZGVzIGluXG4gICAgICBiZWdpblxuICAgICAgICBpZiBzaXplID4gQm94ZXMubmJfYm94ZXNcbiAgICAgICAgdGhlblxuICAgICAgICAgIEZvcm1hdC5mcHJpbnRmIGZtdCBcIldhcm5pbmc6IE5vdCBlbm91Z2ggc3BhY2UuLi4gTmVlZCAlbi8lbiBib3hlcy5ALlwiXG4gICAgICAgICAgc2l6ZSBCb3hlcy5uYl9ib3hlc1xuICAgICAgZW5kIDtcbiAgICAgIGJlZ2luXG4gICAgICAgIGlmIExpc3QuZXhpc3RzIChmdW4gYyAtPiBOYW1lLmlzX2NvZGVfd3JpdGFibGUgYyB8PiBub3QpIGJveGVzX2NvZGVzXG4gICAgICAgIHRoZW4gRm9ybWF0LmZwcmludGYgZm10IFwiV2FybmluZzogQ29udGFpbnMgdW53cml0YWJsZSBjaGFyYWN0ZXJzLi4uQC5cIlxuICAgICAgICBlbHNlIGlmIExpc3QuZXhpc3RzIE5hbWUuaXNfZnVsbF9vZl9zcGFjZXMgYm94ZXNfY29kZXNcbiAgICAgICAgdGhlbiBGb3JtYXQuZnByaW50ZiBmbXQgXCJXYXJuaW5nOiBBIGJveCBuYW1lIGNhbm5vdCBiZSB3cml0dGVuIChvbmx5IGNvbnRhaW5zIHNwYWNlcykuLi5ALlwiXG4gICAgICBlbmQgO1xuICAgICAgRm9ybWF0LmZwcmludGYgZm10IFwiUmF3IGRhdGEgKGluIGhleGFkZWNpbWFsKTpALlwiIDtcbiAgICAgIGJveGVzX2NvZGVzIHw+IExpc3QuaXRlciAoRm9ybWF0LmZwcmludGYgZm10IFwiJWFcIiBCb3hlcy5wcF9ib3hfcmF3KSA7XG4gICAgICBGb3JtYXQuZnByaW50ZiBmbXQgXCJALlwiIDtcbiAgICAgIFNvbWUgKExpc3QubWFwIChmdW4gYyAtPiBOYW1lLmNvZGVzX3RvX2NoYXJzIGMgfD4gVXRpbHMuY29uY2F0X3N0cmluZ3MpIGJveGVzX2NvZGVzKVxuICAgIHdpdGggRXhpdC5Ob0V4aXRDb2RlIC0+XG4gICAgICBmYWlsd2l0aCBcIlRoZSBleGl0IGNvZGUgb3ZlcmxhcHMgdGhpcyBjb2RlICh0b28gbG9uZz8pLkAuXCJcbiIsbnVsbCwib3BlbiBBY2VfY29tbW9uXG5vcGVuIEpzX29mX29jYW1sXG5cbm1vZHVsZSBIdG1sID0gRG9tX2h0bWxcblxubGV0IHRyZWF0X2lucHV0IGxhbmcgc3RyID1cbiAgU2V0dGluZ3MuY29uZmlndXJlIGxhbmcgO1xuICBsZXQgYnVmZmVyID0gQnVmZmVyLmNyZWF0ZSAxMDAwIGluXG4gIGxldCBmbXQgPSBGb3JtYXQuZm9ybWF0dGVyX29mX2J1ZmZlciBidWZmZXIgaW5cbiAgYmVnaW4gdHJ5IChcbiAgICBsZXQgZnMgPSBGcy5mcm9tX3N0ciBzdHIgaW5cbiAgICBsZXQgKGhlYWRlcnMsIHByb2dyYW0pID0gRnMubWFpbl9maWxlIGZzIGluXG4gICAgbGV0IGVudiA9IFByZXByb2Nlc3MuZW52X2Zyb21faGVhZGVycyBmbXQgaGVhZGVycyBpblxuICAgIGxldCAoZXhpdCwgaGVhZGVyczIpID1cbiAgICAgIG1hdGNoIFByZXByb2Nlc3MuZ2V0X3BhcmFtIGhlYWRlcnMgXCJleGl0XCIgd2l0aFxuICAgICAgfCBITm9uZSAtPiAoTm9uZSwgW10pXG4gICAgICB8IEhTdHJpbmcgZm4gLT5cbiAgICAgICAgbGV0IChoZWFkZXJzLCBhc3QpID0gRnMuZ2V0X2ZpbGUgZm4gZnMgaW5cbiAgICAgICAgbGV0IGV4aXQgPSBFeGl0LmxvYWRfZnJvbV9wYXJzZWRfZmlsZSBmbXQgZW52IChoZWFkZXJzLCBhc3QpIGluXG4gICAgICAgIChTb21lIGV4aXQsIGhlYWRlcnMpXG4gICAgICB8IF8gLT4gZmFpbHdpdGggXCJJbnZhbGlkIGhlYWRlcnMuXCJcbiAgICBpblxuICAgIG1haW4gZm10IGVudiAoaGVhZGVycywgaGVhZGVyczIpIHByb2dyYW0gZXhpdCB8PiBpZ25vcmVcbiAgKSB3aXRoIGUgLT4gQnVmZmVyLmFkZF9zdHJpbmcgYnVmZmVyIChQcmludGV4Yy50b19zdHJpbmcgZSkgZW5kIDtcbiAgRm9ybWF0LnBwX3ByaW50X2ZsdXNoIGZtdCAoKSA7XG4gIEJ1ZmZlci5jb250ZW50cyBidWZmZXJcblxubGV0IGlzX2JsYW5rX3N0ciBzID0gIFxuICBsZXQgcmVjIGVtcHR5IGkgPVxuICAgIGlmIGkgPCAwIHRoZW4gdHJ1ZVxuICAgIGVsc2VcbiAgICAgIGxldCBjID0gU3RyaW5nLmdldCBzIGkgaW5cbiAgICAgIGlmIGMgPSAnICcgfHwgYyA9ICdcXHQnIHx8IGMgPSAnXFxuJyB8fCBjID0gJ1xccicgdGhlbiBlbXB0eSAoaS0xKVxuICAgICAgZWxzZSBmYWxzZVxuICBpblxuICBlbXB0eSAoKFN0cmluZy5sZW5ndGggcyktMSlcblxubGV0IGNvbXB1dGUgXyA9XG4gIGxldCBtYWluX2lucHV0ID1cbiAgICBPcHRpb24uZ2V0XG4gICAgICAoSHRtbC5nZXRFbGVtZW50QnlJZF9jb2VyY2UgXCJtYWluXCIgSHRtbC5Db2VyY2VUby50ZXh0YXJlYSlcbiAgaW5cbiAgbGV0IHNlY29uZGFyeV9pbnB1dCA9XG4gICAgT3B0aW9uLmdldFxuICAgICAgKEh0bWwuZ2V0RWxlbWVudEJ5SWRfY29lcmNlIFwic2Vjb25kYXJ5XCIgSHRtbC5Db2VyY2VUby50ZXh0YXJlYSlcbiAgaW5cbiAgbGV0IG91dHB1dCA9XG4gICAgT3B0aW9uLmdldFxuICAgICAgKEh0bWwuZ2V0RWxlbWVudEJ5SWRfY29lcmNlIFwib3V0cHV0XCIgSHRtbC5Db2VyY2VUby50ZXh0YXJlYSlcbiAgaW5cbiAgbGV0IGxhbmcgPVxuICAgIE9wdGlvbi5nZXRcbiAgICAgIChIdG1sLmdldEVsZW1lbnRCeUlkX2NvZXJjZSBcImxhbmdcIiBIdG1sLkNvZXJjZVRvLnNlbGVjdClcbiAgaW5cbiAgbGV0IG1haW5faW5wdXQgPSBKcy50b19zdHJpbmcgbWFpbl9pbnB1dCMjLnZhbHVlIGluXG4gIGxldCBzZWNvbmRhcnlfaW5wdXQgPSBKcy50b19zdHJpbmcgc2Vjb25kYXJ5X2lucHV0IyMudmFsdWUgaW5cbiAgbGV0IGlucHV0ID0gbWFpbl9pbnB1dF4oXG4gICAgaWYgaXNfYmxhbmtfc3RyIHNlY29uZGFyeV9pbnB1dFxuICAgIHRoZW4gXCJcIiBlbHNlIFwiXFxuPT09PT1cXG5cIl5zZWNvbmRhcnlfaW5wdXRcbiAgKSBpblxuICBsZXQgbGFuZyA9IEpzLnRvX3N0cmluZyBsYW5nIyMudmFsdWUgaW5cbiAgbGV0IHJlcyA9IHRyZWF0X2lucHV0IGxhbmcgaW5wdXQgaW5cbiAgb3V0cHV0IyMudmFsdWUgOj0gSnMuc3RyaW5nIHJlcztcbiAgSnMuX3RydWVcblxubGV0IGluaXQgXyA9XG4gIGxldCBjb21wdXRlX2J1dHRvbiA9XG4gICAgT3B0aW9uLmdldFxuICAgICAgKEh0bWwuZ2V0RWxlbWVudEJ5SWRfY29lcmNlIFwiY29tcHV0ZVwiIEh0bWwuQ29lcmNlVG8uYnV0dG9uKVxuICBpblxuICBIdG1sLmFkZEV2ZW50TGlzdGVuZXIgY29tcHV0ZV9idXR0b25cbiAgICAoSHRtbC5FdmVudC5tYWtlIFwiY2xpY2tcIikgKEh0bWwuaGFuZGxlciBjb21wdXRlKSAoSnMuYm9vbCBmYWxzZSlcbiAgfD4gaWdub3JlIDtcbiAgSnMuX2ZhbHNlXG5cbmxldCBfID0gSHRtbC5hZGRFdmVudExpc3RlbmVyIEh0bWwud2luZG93XG4gIChIdG1sLkV2ZW50Lm1ha2UgXCJsb2FkXCIpIChIdG1sLmhhbmRsZXIgaW5pdCkgKEpzLmJvb2wgZmFsc2UpXG4gIHw+IGlnbm9yZVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBFbnN1cmUgdGhhdCBbYXRfZXhpdF0gZnVuY3Rpb25zIGFyZSBjYWxsZWQgYXQgdGhlIGVuZCBvZiBldmVyeSBwcm9ncmFtICopXG5cbmxldCBfID0gZG9fYXRfZXhpdCgpXG4iXX0=